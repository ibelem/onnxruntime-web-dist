/*!
 * ONNX Runtime Web v1.17.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var ny=Object.create;var Ao=Object.defineProperty;var oy=Object.getOwnPropertyDescriptor;var iy=Object.getOwnPropertyNames;var ay=Object.getPrototypeOf,sy=Object.prototype.hasOwnProperty;var k=(n,e)=>()=>(n&&(e=n(n=0)),e);var Ve=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),sn=(n,e)=>{for(var r in e)Ao(n,r,{get:e[r],enumerable:!0})},wu=(n,e,r,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of iy(e))!sy.call(n,o)&&o!==r&&Ao(n,o,{get:()=>e[o],enumerable:!(t=oy(e,o))||t.enumerable});return n};var un=(n,e,r)=>(r=n!=null?ny(ay(n)):{},wu(e||!n||!n.__esModule?Ao(r,"default",{value:n,enumerable:!0}):r,n)),vr=n=>wu(Ao({},"__esModule",{value:!0}),n);var Oo,Lr,xr,Tu,oa=k(()=>{"use strict";Oo=new Map,Lr=[],xr=(n,e,r)=>{if(e&&typeof e.init=="function"&&typeof e.createInferenceSessionHandler=="function"){let t=Oo.get(n);if(t===void 0)Oo.set(n,{backend:e,priority:r});else{if(t.priority>r)return;if(t.priority===r&&t.backend!==e)throw new Error(`cannot register backend "${n}" using priority ${r}`)}if(r>=0){let o=Lr.indexOf(n);o!==-1&&Lr.splice(o,1);for(let i=0;i<Lr.length;i++)if(Oo.get(Lr[i]).priority<=r){Lr.splice(i,0,n);return}Lr.push(n)}return}throw new TypeError("not a valid backend")},Tu=async n=>{let e=n.length===0?Lr:n,r=[];for(let t of e){let o=Oo.get(t);if(o){if(o.initialized)return o.backend;if(o.aborted)continue;let i=!!o.initPromise;try{return i||(o.initPromise=o.backend.init()),await o.initPromise,o.initialized=!0,o.backend}catch(s){i||r.push({name:t,err:s}),o.aborted=!0}finally{delete o.initPromise}}}throw new Error(`no available backend found. ERR: ${r.map(t=>`[${t.name}] ${t.err}`).join(", ")}`)}});var $u=k(()=>{"use strict";oa()});var Iu,Su=k(()=>{"use strict";Iu="1.17.0"});var _u,ia,Au=k(()=>{"use strict";Su();_u="warning",ia={wasm:{},webgl:{},webgpu:{},versions:{common:Iu},set logLevel(n){if(n!==void 0){if(typeof n!="string"||["verbose","info","warning","error","fatal"].indexOf(n)===-1)throw new Error(`Unsupported logging level: ${n}`);_u=n}},get logLevel(){return _u}};Object.defineProperty(ia,"logLevel",{enumerable:!0})});var xe,Ou=k(()=>{"use strict";Au();xe=ia});var Eu,Cu,Pu=k(()=>{"use strict";Eu=(n,e)=>{let r=document.createElement("canvas");r.width=n.dims[3],r.height=n.dims[2];let t=r.getContext("2d");if(t!=null){let o,i;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(o=n.dims[2],i=n.dims[3]):(o=n.dims[3],i=n.dims[2]);let s=e?.format!==void 0?e.format:"RGB",a=e?.norm,u,l;a===void 0||a.mean===void 0?u=[255,255,255,255]:typeof a.mean=="number"?u=[a.mean,a.mean,a.mean,a.mean]:(u=[a.mean[0],a.mean[1],a.mean[2],0],a.mean[3]!==void 0&&(u[3]=a.mean[3])),a===void 0||a.bias===void 0?l=[0,0,0,0]:typeof a.bias=="number"?l=[a.bias,a.bias,a.bias,a.bias]:(l=[a.bias[0],a.bias[1],a.bias[2],0],a.bias[3]!==void 0&&(l[3]=a.bias[3]));let d=i*o,p=0,h=d,g=d*2,y=-1;s==="RGBA"?(p=0,h=d,g=d*2,y=d*3):s==="RGB"?(p=0,h=d,g=d*2):s==="RBG"&&(p=0,g=d,h=d*2);for(let b=0;b<i;b++)for(let w=0;w<o;w++){let I=(n.data[p++]-l[0])*u[0],O=(n.data[h++]-l[1])*u[1],E=(n.data[g++]-l[2])*u[2],N=y===-1?255:(n.data[y++]-l[3])*u[3];t.fillStyle="rgba("+I+","+O+","+E+","+N+")",t.fillRect(w,b,1,1)}return r.toDataURL()}else throw new Error("Can not access image data")},Cu=(n,e)=>{let r=document.createElement("canvas").getContext("2d"),t;if(r!=null){let o,i,s;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(o=n.dims[2],i=n.dims[1],s=n.dims[3]):(o=n.dims[3],i=n.dims[2],s=n.dims[1]);let a=e!==void 0&&e.format!==void 0?e.format:"RGB",u=e?.norm,l,d;u===void 0||u.mean===void 0?l=[255,255,255,255]:typeof u.mean=="number"?l=[u.mean,u.mean,u.mean,u.mean]:(l=[u.mean[0],u.mean[1],u.mean[2],255],u.mean[3]!==void 0&&(l[3]=u.mean[3])),u===void 0||u.bias===void 0?d=[0,0,0,0]:typeof u.bias=="number"?d=[u.bias,u.bias,u.bias,u.bias]:(d=[u.bias[0],u.bias[1],u.bias[2],0],u.bias[3]!==void 0&&(d[3]=u.bias[3]));let p=i*o;if(e!==void 0&&(e.format!==void 0&&s===4&&e.format!=="RGBA"||s===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let h=4,g=0,y=1,b=2,w=3,I=0,O=p,E=p*2,N=-1;a==="RGBA"?(I=0,O=p,E=p*2,N=p*3):a==="RGB"?(I=0,O=p,E=p*2):a==="RBG"&&(I=0,E=p,O=p*2),t=r.createImageData(o,i);for(let F=0;F<i*o;g+=h,y+=h,b+=h,w+=h,F++)t.data[g]=(n.data[I++]-d[0])*l[0],t.data[y]=(n.data[O++]-d[1])*l[1],t.data[b]=(n.data[E++]-d[2])*l[2],t.data[w]=N===-1?255:(n.data[N++]-d[3])*l[3]}else throw new Error("Can not access image data");return t}});var aa,Du,ku,Bu,Ru,Mu=k(()=>{"use strict";Eo();aa=(n,e)=>{if(n===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:r,width:t}=e,o=e.norm??{mean:255,bias:0},i,s;typeof o.mean=="number"?i=[o.mean,o.mean,o.mean,o.mean]:i=[o.mean[0],o.mean[1],o.mean[2],o.mean[3]??255],typeof o.bias=="number"?s=[o.bias,o.bias,o.bias,o.bias]:s=[o.bias[0],o.bias[1],o.bias[2],o.bias[3]??0];let a=e.format!==void 0?e.format:"RGBA",u=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",l=r*t,d=u==="RGBA"?new Float32Array(l*4):new Float32Array(l*3),p=4,h=0,g=1,y=2,b=3,w=0,I=l,O=l*2,E=-1;a==="RGB"&&(p=3,h=0,g=1,y=2,b=-1),u==="RGBA"?E=l*3:u==="RBG"?(w=0,O=l,I=l*2):u==="BGR"&&(O=0,I=l,w=l*2);for(let F=0;F<l;F++,h+=p,y+=p,g+=p,b+=p)d[w++]=(n[h]+s[0])/i[0],d[I++]=(n[g]+s[1])/i[1],d[O++]=(n[y]+s[2])/i[2],E!==-1&&b!==-1&&(d[E++]=(n[b]+s[3])/i[3]);return u==="RGBA"?new yt("float32",d,[1,4,r,t]):new yt("float32",d,[1,3,r,t])},Du=async(n,e)=>{let r=typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement,t=typeof ImageData<"u"&&n instanceof ImageData,o=typeof ImageBitmap<"u"&&n instanceof ImageBitmap,i=typeof n=="string",s,a=e??{};if(r){let u=document.createElement("canvas");u.width=n.width,u.height=n.height;let l=u.getContext("2d");if(l!=null){let d=n.height,p=n.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(d=e.resizedHeight,p=e.resizedWidth),e!==void 0){if(a=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");a.tensorFormat="RGBA",a.height=d,a.width=p}else a.tensorFormat="RGBA",a.height=d,a.width=p;l.drawImage(n,0,0),s=l.getImageData(0,0,p,d).data}else throw new Error("Can not access image data")}else if(t){let u,l;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?(u=e.resizedHeight,l=e.resizedWidth):(u=n.height,l=n.width),e!==void 0&&(a=e),a.format="RGBA",a.height=u,a.width=l,e!==void 0){let d=document.createElement("canvas");d.width=l,d.height=u;let p=d.getContext("2d");if(p!=null)p.putImageData(n,0,0),s=p.getImageData(0,0,l,u).data;else throw new Error("Can not access image data")}else s=n.data}else if(o){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");let u=document.createElement("canvas");u.width=n.width,u.height=n.height;let l=u.getContext("2d");if(l!=null){let d=n.height,p=n.width;return l.drawImage(n,0,0,p,d),s=l.getImageData(0,0,p,d).data,a.height=d,a.width=p,aa(s,a)}else throw new Error("Can not access image data")}else{if(i)return new Promise((u,l)=>{let d=document.createElement("canvas"),p=d.getContext("2d");if(!n||!p)return l();let h=new Image;h.crossOrigin="Anonymous",h.src=n,h.onload=()=>{d.width=h.width,d.height=h.height,p.drawImage(h,0,0,d.width,d.height);let g=p.getImageData(0,0,d.width,d.height);a.height=d.height,a.width=d.width,u(aa(g.data,a))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(s!==void 0)return aa(s,a);throw new Error("Input data provided is not supported - aborted tensor creation")},ku=(n,e)=>{let{width:r,height:t,download:o,dispose:i}=e,s=[1,t,r,4];return new yt({location:"texture",type:"float32",texture:n,dims:s,download:o,dispose:i})},Bu=(n,e)=>{let{dataType:r,dims:t,download:o,dispose:i}=e;return new yt({location:"gpu-buffer",type:r??"float32",gpuBuffer:n,dims:t,download:o,dispose:i})},Ru=(n,e,r)=>new yt({location:"cpu-pinned",type:n,data:e,dims:r??[e.length]})});var Gn,Co,Lu,Nu,Fu=k(()=>{"use strict";Gn=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),Co=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),Lu=!1,Nu=()=>{if(!Lu){Lu=!0;let n=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",e=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function";n&&(Gn.set("int64",BigInt64Array),Co.set(BigInt64Array,"int64")),e&&(Gn.set("uint64",BigUint64Array),Co.set(BigUint64Array,"uint64"))}}});var zu,Gu,Wu=k(()=>{"use strict";Eo();zu=n=>{let e=1;for(let r=0;r<n.length;r++){let t=n[r];if(typeof t!="number"||!Number.isSafeInteger(t))throw new TypeError(`dims[${r}] must be an integer, got: ${t}`);if(t<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${t}`);e*=t}return e},Gu=(n,e)=>{switch(n.location){case"cpu":return new yt(n.type,n.data,e);case"cpu-pinned":return new yt({location:"cpu-pinned",data:n.data,type:n.type,dims:e});case"texture":return new yt({location:"texture",texture:n.texture,type:n.type,dims:e});case"gpu-buffer":return new yt({location:"gpu-buffer",gpuBuffer:n.gpuBuffer,type:n.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${n.location} is not supported`)}}});var yt,Eo=k(()=>{"use strict";Pu();Mu();Fu();Wu();yt=class{constructor(e,r,t){Nu();let o,i;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,o=e.type,i=e.dims,e.location){case"cpu-pinned":{let a=Gn.get(o);if(!a)throw new TypeError(`unsupported type "${o}" to create tensor from pinned buffer`);if(!(e.data instanceof a))throw new TypeError(`buffer should be of type ${a.name}`);this.cpuData=e.data;break}case"texture":{if(o!=="float32")throw new TypeError(`unsupported type "${o}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(o!=="float32"&&o!=="float16"&&o!=="int32"&&o!=="int64"&&o!=="uint32"&&o!=="bool")throw new TypeError(`unsupported type "${o}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let a,u;if(typeof e=="string")if(o=e,u=t,e==="string"){if(!Array.isArray(r))throw new TypeError("A string tensor's data must be a string array.");a=r}else{let l=Gn.get(e);if(l===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(r)){if(e==="float16")throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");e==="uint64"||e==="int64"?a=l.from(r,BigInt):a=l.from(r)}else if(r instanceof l)a=r;else throw new TypeError(`A ${o} tensor's data must be type of ${l}`)}else if(u=r,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let l=typeof e[0];if(l==="string")o="string",a=e;else if(l==="boolean")o="bool",a=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${l}.`)}else{let l=Co.get(e.constructor);if(l===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);o=l,a=e}if(u===void 0)u=[a.length];else if(!Array.isArray(u))throw new TypeError("A tensor's dims must be a number array");i=u,this.cpuData=a,this.dataLocation="cpu"}let s=zu(i);if(this.cpuData&&s!==this.cpuData.length)throw new Error(`Tensor's size(${s}) does not match data length(${this.cpuData.length}).`);this.type=o,this.dims=i,this.size=s}static async fromImage(e,r){return Du(e,r)}static fromTexture(e,r){return ku(e,r)}static fromGpuBuffer(e,r){return Bu(e,r)}static fromPinnedBuffer(e,r,t){return Ru(e,r,t)}toDataURL(e){return Eu(this,e)}toImageData(e){return Cu(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let r=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=r,e&&this.disposer&&(this.disposer(),this.disposer=void 0),r}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return Gu(this,e)}}});var Ft,sa=k(()=>{"use strict";Eo();Ft=yt});var Po,Vu=k(()=>{"use strict";oa();sa();Po=class n{constructor(e){this.handler=e}async run(e,r,t){let o={},i={};if(typeof e!="object"||e===null||e instanceof Ft||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let s=!0;if(typeof r=="object"){if(r===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(r instanceof Ft)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(r)){if(r.length===0)throw new TypeError("'fetches' cannot be an empty array.");s=!1;for(let l of r){if(typeof l!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(l)===-1)throw new RangeError(`'fetches' contains invalid output name: ${l}.`);o[l]=null}if(typeof t=="object"&&t!==null)i=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else{let l=!1,d=Object.getOwnPropertyNames(r);for(let p of this.outputNames)if(d.indexOf(p)!==-1){let h=r[p];(h===null||h instanceof Ft)&&(l=!0,s=!1,o[p]=h)}if(l){if(typeof t=="object"&&t!==null)i=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else i=r}}else if(typeof r<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let l of this.inputNames)if(typeof e[l]>"u")throw new Error(`input '${l}' is missing in 'feeds'.`);if(s)for(let l of this.outputNames)o[l]=null;let a=await this.handler.run(e,o,i),u={};for(let l in a)if(Object.hasOwnProperty.call(a,l)){let d=a[l];d instanceof Ft?u[l]=d:u[l]=new Ft(d.type,d.data,d.dims)}return u}async release(){return this.handler.dispose()}static async create(e,r,t,o){let i,s={};if(typeof e=="string"){if(i=e,typeof r=="object"&&r!==null)s=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(i=e,typeof r=="object"&&r!==null)s=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){let p=e,h=0,g=e.byteLength;if(typeof r=="object"&&r!==null)s=r;else if(typeof r=="number"){if(h=r,!Number.isSafeInteger(h))throw new RangeError("'byteOffset' must be an integer.");if(h<0||h>=p.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${p.byteLength}).`);if(g=e.byteLength-h,typeof t=="number"){if(g=t,!Number.isSafeInteger(g))throw new RangeError("'byteLength' must be an integer.");if(g<=0||h+g>p.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${p.byteLength-h}].`);if(typeof o=="object"&&o!==null)s=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else if(typeof t<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof r<"u")throw new TypeError("'options' must be an object.");i=new Uint8Array(p,h,g)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let u=(s.executionProviders||[]).map(p=>typeof p=="string"?p:p.name),d=await(await Tu(u)).createInferenceSessionHandler(i,s);return new n(d)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var I1,Uu=k(()=>{"use strict";Vu();I1=Po});var Hu=k(()=>{"use strict"});var Do,ju=k(()=>{"use strict";Do=class{constructor(e){this.handler=e}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}static async create(e,r){throw new Error("Method not implemented")}async loadParametersBuffer(e,r){throw new Error("Method not implemented.")}async getContiguousParameters(e){throw new Error("Method not implemented.")}async runTrainStep(e,r,t){throw new Error("Method not implemented.")}async release(){return this.handler.dispose()}}});var O1,qu=k(()=>{"use strict";ju();O1=Do});var zt=k(()=>{"use strict";$u();Ou();Uu();sa();Hu();qu()});function wr(n,e,r,t){if(e===void 0)return ly(n);if(r===void 0)ko(n,e,1);else if(typeof r=="number"&&t===void 0)ko(n,e,r);else if(typeof r=="string"&&t===void 0)ko(n,r,1,e);else if(typeof r=="string"&&typeof t=="number")ko(n,r,t,e);else throw new TypeError("input is valid")}function ly(n){return{verbose:wr.verbose.bind(null,n),info:wr.info.bind(null,n),warning:wr.warning.bind(null,n),error:wr.error.bind(null,n),fatal:wr.fatal.bind(null,n)}}function ko(n,e,r,t){let o=Wn[t||""]||Wn[""];Yu[n]<Yu[o.minimalSeverity]||(o.logDateTime&&(e=`${new Date().toISOString()}|${e}`),o.logSourceLocation,uy[o.provider].log(n,e,t))}var ua,la,Yu,uy,Xu,Wn,Ne,Ro,Mo,Lo,Bo,Ot=k(()=>{"use strict";ua=class{log(e,r,t){}},la=class{log(e,r,t){console.log(`${this.color(e)} ${t?"\x1B[35m"+t+"\x1B[0m ":""}${r}`)}color(e){switch(e){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${e}`)}}},Yu={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},uy={none:new ua,console:new la},Xu={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1},Wn={"":Xu};(u=>{function n(l,d){u("verbose",l,d)}u.verbose=n;function e(l,d){u("info",l,d)}u.info=e;function r(l,d){u("warning",l,d)}u.warning=r;function t(l,d){u("error",l,d)}u.error=t;function o(l,d){u("fatal",l,d)}u.fatal=o;function i(l){Wn={},s("",l||{})}u.reset=i;function s(l,d){if(l==="*")i(d);else{let p=Wn[l]||Xu;Wn[l]={provider:d.provider||p.provider,minimalSeverity:d.minimalSeverity||p.minimalSeverity,logDateTime:d.logDateTime===void 0?p.logDateTime:d.logDateTime,logSourceLocation:d.logSourceLocation===void 0?p.logSourceLocation:d.logSourceLocation}}}u.set=s;function a(l){let d={};l.logLevel&&(d.minimalSeverity=l.logLevel),s("",d)}u.setWithEnv=a})(wr||={});Ne=wr,Ro=class{constructor(e,r,t,o,i,s){this.category=e;this.name=r;this.startTime=t;this.endCallback=o;this.timer=i;this.ctx=s}async end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}},Mo=class{constructor(e,r,t,o){this.category=e;this.name=r;this.startTime=t;this.endTime=o}},Lo=class{constructor(e,r,t){this._started=!1;this._flushPointer=0;this._started=!1,this._maxNumberEvents=e===void 0?1e4:e,this._flushBatchSize=r===void 0?10:r,this._flushIntervalInMilliseconds=t===void 0?5e3:t}static create(e){return e===void 0?new this:new this(e.maxNumberEvents,e.flushBatchSize,e.flushIntervalInMilliseconds)}start(){this._started=!0,this._timingEvents=[],this._flushTime=Bo(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(e,r,t,o){let i=this._started?this.begin(e,r,o):void 0,s=!1,a=t();if(a&&typeof a.then=="function")return s=!0,new Promise((u,l)=>{a.then(async d=>{i&&await i.end(),u(d)},async d=>{i&&await i.end(),l(d)})});if(!s&&i){let u=i.end();if(u&&typeof u.then=="function")return new Promise((l,d)=>{u.then(()=>{l(a)},p=>{d(p)})})}return a}begin(e,r,t){if(!this._started)throw new Error("profiler is not started yet");if(t===void 0){let o=Bo();return this.flush(o),new Ro(e,r,o,i=>this.endSync(i))}else{let o=t.beginTimer();return new Ro(e,r,0,async i=>this.end(i),o,t)}}async end(e){let r=await e.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new Mo(e.category,e.name,e.startTime,r)),this.flush(r))}endSync(e){let r=Bo();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new Mo(e.category,e.name,e.startTime,r)),this.flush(r))}logOneEvent(e){Ne.verbose(`Profiler.${e.category}`,`${(e.endTime-e.startTime).toFixed(2)}ms on event '${e.name}' at ${e.endTime.toFixed(2)}`)}flush(e){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||e-this._flushTime>=this._flushIntervalInMilliseconds){for(let r=this._flushPointer;this._flushPointer<r+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=Bo()}}get started(){return this._started}},Bo=typeof performance<"u"&&performance.now?()=>performance.now():Date.now});function Ju(n,e,r){for(let t of r){let o=t[0],i=t[1],s=t[2],a=t[3],u=t[4];if(n.opType===o){for(let l of e)if((l.domain===i||l.domain==="ai.onnx"&&i==="")&&cy(l.version,s))return{opImpl:a,opInit:u}}}throw new TypeError(`cannot resolve operator '${n.opType}' with opsets: ${e.map(t=>`${t.domain||"ai.onnx"} v${t.version}`).join(", ")}`)}function cy(n,e){if(e.endsWith("+")){let r=Number.parseInt(e.substring(0,e.length-1),10);return!isNaN(r)&&r<=n}else if(e.split("-").length===2){let r=e.split("-"),t=Number.parseInt(r[0],10),o=Number.parseInt(r[1],10);return!isNaN(t)&&!isNaN(o)&&t<=n&&n<=o}else return Number.parseInt(e,10)===n}var Zu=k(()=>{"use strict"});var Qu=Ve(ca=>{"use strict";ca.__esModule=!0;var dy=function(){function n(e){if(!e)throw new TypeError("Invalid argument; `value` has no value.");this.value=n.EMPTY,e&&n.isGuid(e)&&(this.value=e)}return n.isGuid=function(e){var r=e.toString();return e&&(e instanceof n||n.validator.test(r))},n.create=function(){return new n([n.gen(2),n.gen(1),n.gen(1),n.gen(1),n.gen(3)].join("-"))},n.createEmpty=function(){return new n("emptyguid")},n.parse=function(e){return new n(e)},n.raw=function(){return[n.gen(2),n.gen(1),n.gen(1),n.gen(1),n.gen(3)].join("-")},n.gen=function(e){for(var r="",t=0;t<e;t++)r+=((1+Math.random())*65536|0).toString(16).substring(1);return r},n.prototype.equals=function(e){return n.isGuid(e)&&this.value===e.toString()},n.prototype.isEmpty=function(){return this.value===n.EMPTY},n.prototype.toString=function(){return this.value},n.prototype.toJSON=function(){return{value:this.value}},n.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),n.EMPTY="00000000-0000-0000-0000-000000000000",n}();ca.Guid=dy});function Ue(n,e,r){this.low=n|0,this.high=e|0,this.unsigned=!!r}function ht(n){return(n&&n.__isLong__)===!0}function el(n){var e=Math.clz32(n&-n);return n?31-e:e}function Nr(n,e){var r,t,o;return e?(n>>>=0,(o=0<=n&&n<256)&&(t=rl[n],t)?t:(r=Re(n,0,!0),o&&(rl[n]=r),r)):(n|=0,(o=-128<=n&&n<128)&&(t=tl[n],t)?t:(r=Re(n,n<0?-1:0,!1),o&&(tl[n]=r),r))}function Ct(n,e){if(isNaN(n))return e?hr:Gt;if(e){if(n<0)return hr;if(n>=al)return ll}else{if(n<=-ol)return $t;if(n+1>=ol)return ul}return n<0?Ct(-n,e).neg():Re(n%cn|0,n/cn|0,e)}function Re(n,e,r){return new Ue(n,e,r)}function fa(n,e,r){if(n.length===0)throw Error("empty string");if(typeof e=="number"?(r=e,e=!1):e=!!e,n==="NaN"||n==="Infinity"||n==="+Infinity"||n==="-Infinity")return e?hr:Gt;if(r=r||10,r<2||36<r)throw RangeError("radix");var t;if((t=n.indexOf("-"))>0)throw Error("interior hyphen");if(t===0)return fa(n.substring(1),e,r).neg();for(var o=Ct(No(r,8)),i=Gt,s=0;s<n.length;s+=8){var a=Math.min(8,n.length-s),u=parseInt(n.substring(s,s+a),r);if(a<8){var l=Ct(No(r,a));i=i.mul(l).add(Ct(u))}else i=i.mul(o),i=i.add(Ct(u))}return i.unsigned=e,i}function Wt(n,e){return typeof n=="number"?Ct(n,e):typeof n=="string"?fa(n,e):Re(n.low,n.high,typeof e=="boolean"?e:n.unsigned)}var Et,tl,rl,No,nl,fy,cn,al,ol,il,Gt,hr,ln,sl,da,ul,ll,$t,j,mr,pa=k(()=>{Et=null;try{Et=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}Ue.prototype.__isLong__;Object.defineProperty(Ue.prototype,"__isLong__",{value:!0});Ue.isLong=ht;tl={},rl={};Ue.fromInt=Nr;Ue.fromNumber=Ct;Ue.fromBits=Re;No=Math.pow;Ue.fromString=fa;Ue.fromValue=Wt;nl=65536,fy=1<<24,cn=nl*nl,al=cn*cn,ol=al/2,il=Nr(fy),Gt=Nr(0);Ue.ZERO=Gt;hr=Nr(0,!0);Ue.UZERO=hr;ln=Nr(1);Ue.ONE=ln;sl=Nr(1,!0);Ue.UONE=sl;da=Nr(-1);Ue.NEG_ONE=da;ul=Re(-1,2147483647,!1);Ue.MAX_VALUE=ul;ll=Re(-1,-1,!0);Ue.MAX_UNSIGNED_VALUE=ll;$t=Re(0,-2147483648,!1);Ue.MIN_VALUE=$t;j=Ue.prototype;j.toInt=function(){return this.unsigned?this.low>>>0:this.low};j.toNumber=function(){return this.unsigned?(this.high>>>0)*cn+(this.low>>>0):this.high*cn+(this.low>>>0)};j.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq($t)){var r=Ct(e),t=this.div(r),o=t.mul(r).sub(this);return t.toString(e)+o.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var i=Ct(No(e,6),this.unsigned),s=this,a="";;){var u=s.div(i),l=s.sub(u.mul(i)).toInt()>>>0,d=l.toString(e);if(s=u,s.isZero())return d+a;for(;d.length<6;)d="0"+d;a=""+d+a}};j.getHighBits=function(){return this.high};j.getHighBitsUnsigned=function(){return this.high>>>0};j.getLowBits=function(){return this.low};j.getLowBitsUnsigned=function(){return this.low>>>0};j.getNumBitsAbs=function(){if(this.isNegative())return this.eq($t)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,r=31;r>0&&!(e&1<<r);r--);return this.high!=0?r+33:r+1};j.isZero=function(){return this.high===0&&this.low===0};j.eqz=j.isZero;j.isNegative=function(){return!this.unsigned&&this.high<0};j.isPositive=function(){return this.unsigned||this.high>=0};j.isOdd=function(){return(this.low&1)===1};j.isEven=function(){return(this.low&1)===0};j.equals=function(e){return ht(e)||(e=Wt(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};j.eq=j.equals;j.notEquals=function(e){return!this.eq(e)};j.neq=j.notEquals;j.ne=j.notEquals;j.lessThan=function(e){return this.comp(e)<0};j.lt=j.lessThan;j.lessThanOrEqual=function(e){return this.comp(e)<=0};j.lte=j.lessThanOrEqual;j.le=j.lessThanOrEqual;j.greaterThan=function(e){return this.comp(e)>0};j.gt=j.greaterThan;j.greaterThanOrEqual=function(e){return this.comp(e)>=0};j.gte=j.greaterThanOrEqual;j.ge=j.greaterThanOrEqual;j.compare=function(e){if(ht(e)||(e=Wt(e)),this.eq(e))return 0;var r=this.isNegative(),t=e.isNegative();return r&&!t?-1:!r&&t?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};j.comp=j.compare;j.negate=function(){return!this.unsigned&&this.eq($t)?$t:this.not().add(ln)};j.neg=j.negate;j.add=function(e){ht(e)||(e=Wt(e));var r=this.high>>>16,t=this.high&65535,o=this.low>>>16,i=this.low&65535,s=e.high>>>16,a=e.high&65535,u=e.low>>>16,l=e.low&65535,d=0,p=0,h=0,g=0;return g+=i+l,h+=g>>>16,g&=65535,h+=o+u,p+=h>>>16,h&=65535,p+=t+a,d+=p>>>16,p&=65535,d+=r+s,d&=65535,Re(h<<16|g,d<<16|p,this.unsigned)};j.subtract=function(e){return ht(e)||(e=Wt(e)),this.add(e.neg())};j.sub=j.subtract;j.multiply=function(e){if(this.isZero())return this;if(ht(e)||(e=Wt(e)),Et){var r=Et.mul(this.low,this.high,e.low,e.high);return Re(r,Et.get_high(),this.unsigned)}if(e.isZero())return this.unsigned?hr:Gt;if(this.eq($t))return e.isOdd()?$t:Gt;if(e.eq($t))return this.isOdd()?$t:Gt;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(il)&&e.lt(il))return Ct(this.toNumber()*e.toNumber(),this.unsigned);var t=this.high>>>16,o=this.high&65535,i=this.low>>>16,s=this.low&65535,a=e.high>>>16,u=e.high&65535,l=e.low>>>16,d=e.low&65535,p=0,h=0,g=0,y=0;return y+=s*d,g+=y>>>16,y&=65535,g+=i*d,h+=g>>>16,g&=65535,g+=s*l,h+=g>>>16,g&=65535,h+=o*d,p+=h>>>16,h&=65535,h+=i*l,p+=h>>>16,h&=65535,h+=s*u,p+=h>>>16,h&=65535,p+=t*d+o*l+i*u+s*a,p&=65535,Re(g<<16|y,p<<16|h,this.unsigned)};j.mul=j.multiply;j.divide=function(e){if(ht(e)||(e=Wt(e)),e.isZero())throw Error("division by zero");if(Et){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var r=(this.unsigned?Et.div_u:Et.div_s)(this.low,this.high,e.low,e.high);return Re(r,Et.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?hr:Gt;var t,o,i;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return hr;if(e.gt(this.shru(1)))return sl;i=hr}else{if(this.eq($t)){if(e.eq(ln)||e.eq(da))return $t;if(e.eq($t))return ln;var s=this.shr(1);return t=s.div(e).shl(1),t.eq(Gt)?e.isNegative()?ln:da:(o=this.sub(e.mul(t)),i=t.add(o.div(e)),i)}else if(e.eq($t))return this.unsigned?hr:Gt;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();i=Gt}for(o=this;o.gte(e);){t=Math.max(1,Math.floor(o.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(t)/Math.LN2),u=a<=48?1:No(2,a-48),l=Ct(t),d=l.mul(e);d.isNegative()||d.gt(o);)t-=u,l=Ct(t,this.unsigned),d=l.mul(e);l.isZero()&&(l=ln),i=i.add(l),o=o.sub(d)}return i};j.div=j.divide;j.modulo=function(e){if(ht(e)||(e=Wt(e)),Et){var r=(this.unsigned?Et.rem_u:Et.rem_s)(this.low,this.high,e.low,e.high);return Re(r,Et.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};j.mod=j.modulo;j.rem=j.modulo;j.not=function(){return Re(~this.low,~this.high,this.unsigned)};j.countLeadingZeros=function(){return this.high?Math.clz32(this.high):Math.clz32(this.low)+32};j.clz=j.countLeadingZeros;j.countTrailingZeros=function(){return this.low?el(this.low):el(this.high)+32};j.ctz=j.countTrailingZeros;j.and=function(e){return ht(e)||(e=Wt(e)),Re(this.low&e.low,this.high&e.high,this.unsigned)};j.or=function(e){return ht(e)||(e=Wt(e)),Re(this.low|e.low,this.high|e.high,this.unsigned)};j.xor=function(e){return ht(e)||(e=Wt(e)),Re(this.low^e.low,this.high^e.high,this.unsigned)};j.shiftLeft=function(e){return ht(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Re(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):Re(0,this.low<<e-32,this.unsigned)};j.shl=j.shiftLeft;j.shiftRight=function(e){return ht(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Re(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):Re(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};j.shr=j.shiftRight;j.shiftRightUnsigned=function(e){return ht(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Re(this.low>>>e|this.high<<32-e,this.high>>>e,this.unsigned):e===32?Re(this.high,0,this.unsigned):Re(this.high>>>e-32,0,this.unsigned)};j.shru=j.shiftRightUnsigned;j.shr_u=j.shiftRightUnsigned;j.rotateLeft=function(e){var r;return ht(e)&&(e=e.toInt()),(e&=63)===0?this:e===32?Re(this.high,this.low,this.unsigned):e<32?(r=32-e,Re(this.low<<e|this.high>>>r,this.high<<e|this.low>>>r,this.unsigned)):(e-=32,r=32-e,Re(this.high<<e|this.low>>>r,this.low<<e|this.high>>>r,this.unsigned))};j.rotl=j.rotateLeft;j.rotateRight=function(e){var r;return ht(e)&&(e=e.toInt()),(e&=63)===0?this:e===32?Re(this.high,this.low,this.unsigned):e<32?(r=32-e,Re(this.high<<r|this.low>>>e,this.low<<r|this.high>>>e,this.unsigned)):(e-=32,r=32-e,Re(this.low<<r|this.high>>>e,this.high<<r|this.low>>>e,this.unsigned))};j.rotr=j.rotateRight;j.toSigned=function(){return this.unsigned?Re(this.low,this.high,!1):this};j.toUnsigned=function(){return this.unsigned?this:Re(this.low,this.high,!0)};j.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};j.toBytesLE=function(){var e=this.high,r=this.low;return[r&255,r>>>8&255,r>>>16&255,r>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};j.toBytesBE=function(){var e=this.high,r=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,r>>>24,r>>>16&255,r>>>8&255,r&255]};Ue.fromBytes=function(e,r,t){return t?Ue.fromBytesLE(e,r):Ue.fromBytesBE(e,r)};Ue.fromBytesLE=function(e,r){return new Ue(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,r)};Ue.fromBytesBE=function(e,r){return new Ue(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],r)};mr=Ue});var C,Fo=k(()=>{C={};C.Offset;C.Table;C.SIZEOF_SHORT=2;C.SIZEOF_INT=4;C.FILE_IDENTIFIER_LENGTH=4;C.SIZE_PREFIX_LENGTH=4;C.Encoding={UTF8_BYTES:1,UTF16_STRING:2};C.int32=new Int32Array(2);C.float32=new Float32Array(C.int32.buffer);C.float64=new Float64Array(C.int32.buffer);C.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1;C.Long=function(n,e){this.low=n|0,this.high=e|0};C.Long.create=function(n,e){return n==0&&e==0?C.Long.ZERO:new C.Long(n,e)};C.Long.prototype.toFloat64=function(){return(this.low>>>0)+this.high*4294967296};C.Long.prototype.equals=function(n){return this.low==n.low&&this.high==n.high};C.Long.ZERO=new C.Long(0,0);C.Builder=function(n){if(n)var e=n;else var e=1024;this.bb=C.ByteBuffer.allocate(e),this.space=e,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1};C.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1};C.Builder.prototype.forceDefaults=function(n){this.force_defaults=n};C.Builder.prototype.dataBuffer=function(){return this.bb};C.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())};C.Builder.prototype.prep=function(n,e){n>this.minalign&&(this.minalign=n);for(var r=~(this.bb.capacity()-this.space+e)+1&n-1;this.space<r+n+e;){var t=this.bb.capacity();this.bb=C.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-t}this.pad(r)};C.Builder.prototype.pad=function(n){for(var e=0;e<n;e++)this.bb.writeInt8(--this.space,0)};C.Builder.prototype.writeInt8=function(n){this.bb.writeInt8(this.space-=1,n)};C.Builder.prototype.writeInt16=function(n){this.bb.writeInt16(this.space-=2,n)};C.Builder.prototype.writeInt32=function(n){this.bb.writeInt32(this.space-=4,n)};C.Builder.prototype.writeInt64=function(n){this.bb.writeInt64(this.space-=8,n)};C.Builder.prototype.writeFloat32=function(n){this.bb.writeFloat32(this.space-=4,n)};C.Builder.prototype.writeFloat64=function(n){this.bb.writeFloat64(this.space-=8,n)};C.Builder.prototype.addInt8=function(n){this.prep(1,0),this.writeInt8(n)};C.Builder.prototype.addInt16=function(n){this.prep(2,0),this.writeInt16(n)};C.Builder.prototype.addInt32=function(n){this.prep(4,0),this.writeInt32(n)};C.Builder.prototype.addInt64=function(n){this.prep(8,0),this.writeInt64(n)};C.Builder.prototype.addFloat32=function(n){this.prep(4,0),this.writeFloat32(n)};C.Builder.prototype.addFloat64=function(n){this.prep(8,0),this.writeFloat64(n)};C.Builder.prototype.addFieldInt8=function(n,e,r){(this.force_defaults||e!=r)&&(this.addInt8(e),this.slot(n))};C.Builder.prototype.addFieldInt16=function(n,e,r){(this.force_defaults||e!=r)&&(this.addInt16(e),this.slot(n))};C.Builder.prototype.addFieldInt32=function(n,e,r){(this.force_defaults||e!=r)&&(this.addInt32(e),this.slot(n))};C.Builder.prototype.addFieldInt64=function(n,e,r){(this.force_defaults||!e.equals(r))&&(this.addInt64(e),this.slot(n))};C.Builder.prototype.addFieldFloat32=function(n,e,r){(this.force_defaults||e!=r)&&(this.addFloat32(e),this.slot(n))};C.Builder.prototype.addFieldFloat64=function(n,e,r){(this.force_defaults||e!=r)&&(this.addFloat64(e),this.slot(n))};C.Builder.prototype.addFieldOffset=function(n,e,r){(this.force_defaults||e!=r)&&(this.addOffset(e),this.slot(n))};C.Builder.prototype.addFieldStruct=function(n,e,r){e!=r&&(this.nested(e),this.slot(n))};C.Builder.prototype.nested=function(n){if(n!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")};C.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")};C.Builder.prototype.slot=function(n){this.vtable[n]=this.offset()};C.Builder.prototype.offset=function(){return this.bb.capacity()-this.space};C.Builder.growByteBuffer=function(n){var e=n.capacity();if(e&3221225472)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var r=e<<1,t=C.ByteBuffer.allocate(r);return t.setPosition(r-e),t.bytes().set(n.bytes(),r-e),t};C.Builder.prototype.addOffset=function(n){this.prep(C.SIZEOF_INT,0),this.writeInt32(this.offset()-n+C.SIZEOF_INT)};C.Builder.prototype.startObject=function(n){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=n;for(var e=0;e<n;e++)this.vtable[e]=0;this.isNested=!0,this.object_start=this.offset()};C.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var n=this.offset(),e=this.vtable_in_use-1;e>=0&&this.vtable[e]==0;e--);for(var r=e+1;e>=0;e--)this.addInt16(this.vtable[e]!=0?n-this.vtable[e]:0);var t=2;this.addInt16(n-this.object_start);var o=(r+t)*C.SIZEOF_SHORT;this.addInt16(o);var i=0,s=this.space;e:for(e=0;e<this.vtables.length;e++){var a=this.bb.capacity()-this.vtables[e];if(o==this.bb.readInt16(a)){for(var u=C.SIZEOF_SHORT;u<o;u+=C.SIZEOF_SHORT)if(this.bb.readInt16(s+u)!=this.bb.readInt16(a+u))continue e;i=this.vtables[e];break}}return i?(this.space=this.bb.capacity()-n,this.bb.writeInt32(this.space,i-n)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-n,this.offset()-n)),this.isNested=!1,n};C.Builder.prototype.finish=function(n,e,r){var t=r?C.SIZE_PREFIX_LENGTH:0;if(e){var o=e;if(this.prep(this.minalign,C.SIZEOF_INT+C.FILE_IDENTIFIER_LENGTH+t),o.length!=C.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+C.FILE_IDENTIFIER_LENGTH);for(var i=C.FILE_IDENTIFIER_LENGTH-1;i>=0;i--)this.writeInt8(o.charCodeAt(i))}this.prep(this.minalign,C.SIZEOF_INT+t),this.addOffset(n),t&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)};C.Builder.prototype.finishSizePrefixed=function(n,e){this.finish(n,e,!0)};C.Builder.prototype.requiredField=function(n,e){var r=this.bb.capacity()-n,t=r-this.bb.readInt32(r),o=this.bb.readInt16(t+e)!=0;if(!o)throw new Error("FlatBuffers: field "+e+" must be set")};C.Builder.prototype.startVector=function(n,e,r){this.notNested(),this.vector_num_elems=e,this.prep(C.SIZEOF_INT,n*e),this.prep(r,n*e)};C.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()};C.Builder.prototype.createString=function(n){if(n instanceof Uint8Array)var e=n;else for(var e=[],r=0;r<n.length;){var t,o=n.charCodeAt(r++);if(o<55296||o>=56320)t=o;else{var i=n.charCodeAt(r++);t=(o<<10)+i+(65536-56623104-56320)}t<128?e.push(t):(t<2048?e.push(t>>6&31|192):(t<65536?e.push(t>>12&15|224):e.push(t>>18&7|240,t>>12&63|128),e.push(t>>6&63|128)),e.push(t&63|128))}this.addInt8(0),this.startVector(1,e.length,1),this.bb.setPosition(this.space-=e.length);for(var r=0,s=this.space,a=this.bb.bytes();r<e.length;r++)a[s++]=e[r];return this.endVector()};C.Builder.prototype.createLong=function(n,e){return C.Long.create(n,e)};C.ByteBuffer=function(n){this.bytes_=n,this.position_=0};C.ByteBuffer.allocate=function(n){return new C.ByteBuffer(new Uint8Array(n))};C.ByteBuffer.prototype.clear=function(){this.position_=0};C.ByteBuffer.prototype.bytes=function(){return this.bytes_};C.ByteBuffer.prototype.position=function(){return this.position_};C.ByteBuffer.prototype.setPosition=function(n){this.position_=n};C.ByteBuffer.prototype.capacity=function(){return this.bytes_.length};C.ByteBuffer.prototype.readInt8=function(n){return this.readUint8(n)<<24>>24};C.ByteBuffer.prototype.readUint8=function(n){return this.bytes_[n]};C.ByteBuffer.prototype.readInt16=function(n){return this.readUint16(n)<<16>>16};C.ByteBuffer.prototype.readUint16=function(n){return this.bytes_[n]|this.bytes_[n+1]<<8};C.ByteBuffer.prototype.readInt32=function(n){return this.bytes_[n]|this.bytes_[n+1]<<8|this.bytes_[n+2]<<16|this.bytes_[n+3]<<24};C.ByteBuffer.prototype.readUint32=function(n){return this.readInt32(n)>>>0};C.ByteBuffer.prototype.readInt64=function(n){return new C.Long(this.readInt32(n),this.readInt32(n+4))};C.ByteBuffer.prototype.readUint64=function(n){return new C.Long(this.readUint32(n),this.readUint32(n+4))};C.ByteBuffer.prototype.readFloat32=function(n){return C.int32[0]=this.readInt32(n),C.float32[0]};C.ByteBuffer.prototype.readFloat64=function(n){return C.int32[C.isLittleEndian?0:1]=this.readInt32(n),C.int32[C.isLittleEndian?1:0]=this.readInt32(n+4),C.float64[0]};C.ByteBuffer.prototype.writeInt8=function(n,e){this.bytes_[n]=e};C.ByteBuffer.prototype.writeUint8=function(n,e){this.bytes_[n]=e};C.ByteBuffer.prototype.writeInt16=function(n,e){this.bytes_[n]=e,this.bytes_[n+1]=e>>8};C.ByteBuffer.prototype.writeUint16=function(n,e){this.bytes_[n]=e,this.bytes_[n+1]=e>>8};C.ByteBuffer.prototype.writeInt32=function(n,e){this.bytes_[n]=e,this.bytes_[n+1]=e>>8,this.bytes_[n+2]=e>>16,this.bytes_[n+3]=e>>24};C.ByteBuffer.prototype.writeUint32=function(n,e){this.bytes_[n]=e,this.bytes_[n+1]=e>>8,this.bytes_[n+2]=e>>16,this.bytes_[n+3]=e>>24};C.ByteBuffer.prototype.writeInt64=function(n,e){this.writeInt32(n,e.low),this.writeInt32(n+4,e.high)};C.ByteBuffer.prototype.writeUint64=function(n,e){this.writeUint32(n,e.low),this.writeUint32(n+4,e.high)};C.ByteBuffer.prototype.writeFloat32=function(n,e){C.float32[0]=e,this.writeInt32(n,C.int32[0])};C.ByteBuffer.prototype.writeFloat64=function(n,e){C.float64[0]=e,this.writeInt32(n,C.int32[C.isLittleEndian?0:1]),this.writeInt32(n+4,C.int32[C.isLittleEndian?1:0])};C.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+C.SIZEOF_INT+C.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var n="",e=0;e<C.FILE_IDENTIFIER_LENGTH;e++)n+=String.fromCharCode(this.readInt8(this.position_+C.SIZEOF_INT+e));return n};C.ByteBuffer.prototype.__offset=function(n,e){var r=n-this.readInt32(n);return e<this.readInt16(r)?this.readInt16(r+e):0};C.ByteBuffer.prototype.__union=function(n,e){return n.bb_pos=e+this.readInt32(e),n.bb=this,n};C.ByteBuffer.prototype.__string=function(n,e){n+=this.readInt32(n);var r=this.readInt32(n),t="",o=0;if(n+=C.SIZEOF_INT,e===C.Encoding.UTF8_BYTES)return this.bytes_.subarray(n,n+r);for(;o<r;){var i,s=this.readUint8(n+o++);if(s<192)i=s;else{var a=this.readUint8(n+o++);if(s<224)i=(s&31)<<6|a&63;else{var u=this.readUint8(n+o++);if(s<240)i=(s&15)<<12|(a&63)<<6|u&63;else{var l=this.readUint8(n+o++);i=(s&7)<<18|(a&63)<<12|(u&63)<<6|l&63}}}i<65536?t+=String.fromCharCode(i):(i-=65536,t+=String.fromCharCode((i>>10)+55296,(i&1024-1)+56320))}return t};C.ByteBuffer.prototype.__indirect=function(n){return n+this.readInt32(n)};C.ByteBuffer.prototype.__vector=function(n){return n+this.readInt32(n)+C.SIZEOF_INT};C.ByteBuffer.prototype.__vector_len=function(n){return this.readInt32(n+this.readInt32(n))};C.ByteBuffer.prototype.__has_identifier=function(n){if(n.length!=C.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+C.FILE_IDENTIFIER_LENGTH);for(var e=0;e<C.FILE_IDENTIFIER_LENGTH;e++)if(n.charCodeAt(e)!=this.readInt8(this.position_+C.SIZEOF_INT+e))return!1;return!0};C.ByteBuffer.prototype.createLong=function(n,e){return C.Long.create(n,e)}});var ne,Vn=k(()=>{"use strict";Fo();(e=>{let n;(t=>{let r;(i=>{let o;(E=>(E[E.UNDEFINED=0]="UNDEFINED",E[E.FLOAT=1]="FLOAT",E[E.INT=2]="INT",E[E.STRING=3]="STRING",E[E.TENSOR=4]="TENSOR",E[E.GRAPH=5]="GRAPH",E[E.FLOATS=6]="FLOATS",E[E.INTS=7]="INTS",E[E.STRINGS=8]="STRINGS",E[E.TENSORS=9]="TENSORS",E[E.GRAPHS=10]="GRAPHS",E[E.SPARSE_TENSOR=11]="SPARSE_TENSOR",E[E.SPARSE_TENSORS=12]="SPARSE_TENSORS"))(o=i.AttributeType||={})})(r=t.fbs||={})})(n=e.experimental||={})})(ne||={});(e=>{let n;(t=>{let r;(i=>{let o;(l=>(l[l.UNKNOWN=0]="UNKNOWN",l[l.VALUE=1]="VALUE",l[l.PARAM=2]="PARAM"))(o=i.DimensionValueType||={})})(r=t.fbs||={})})(n=e.experimental||={})})(ne||={});(e=>{let n;(t=>{let r;(i=>{let o;(P=>(P[P.UNDEFINED=0]="UNDEFINED",P[P.FLOAT=1]="FLOAT",P[P.UINT8=2]="UINT8",P[P.INT8=3]="INT8",P[P.UINT16=4]="UINT16",P[P.INT16=5]="INT16",P[P.INT32=6]="INT32",P[P.INT64=7]="INT64",P[P.STRING=8]="STRING",P[P.BOOL=9]="BOOL",P[P.FLOAT16=10]="FLOAT16",P[P.DOUBLE=11]="DOUBLE",P[P.UINT32=12]="UINT32",P[P.UINT64=13]="UINT64",P[P.COMPLEX64=14]="COMPLEX64",P[P.COMPLEX128=15]="COMPLEX128",P[P.BFLOAT16=16]="BFLOAT16",P[P.FLOAT8E4M3FN=17]="FLOAT8E4M3FN",P[P.FLOAT8E4M3FNUZ=18]="FLOAT8E4M3FNUZ",P[P.FLOAT8E5M2=19]="FLOAT8E5M2",P[P.FLOAT8E5M2FNUZ=20]="FLOAT8E5M2FNUZ"))(o=i.TensorDataType||={})})(r=t.fbs||={})})(n=e.experimental||={})})(ne||={});(e=>{let n;(t=>{let r;(i=>{let o;(u=>(u[u.Primitive=0]="Primitive",u[u.Fused=1]="Fused"))(o=i.NodeType||={})})(r=t.fbs||={})})(n=e.experimental||={})})(ne||={});(e=>{let n;(t=>{let r;(i=>{let o;(d=>(d[d.NONE=0]="NONE",d[d.tensor_type=1]="tensor_type",d[d.sequence_type=2]="sequence_type",d[d.map_type=3]="map_type"))(o=i.TypeInfoValue||={})})(r=t.fbs||={})})(n=e.experimental||={})})(ne||={});(e=>{let n;(t=>{let r;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsShape(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsShape(a,u){return a.setPosition(a.position()+C.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}dim(a,u){let l=this.bb.__offset(this.bb_pos,4);return l?(u||new e.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}dimLength(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__vector_len(this.bb_pos+a):0}static startShape(a){a.startObject(1)}static addDim(a,u){a.addFieldOffset(0,u,0)}static createDimVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startDimVector(a,u){a.startVector(4,u,4)}static endShape(a){return a.endObject()}static createShape(a,u){return o.startShape(a),o.addDim(a,u),o.endShape(a)}}i.Shape=o})(r=t.fbs||={})})(n=e.experimental||={})})(ne||={});(e=>{let n;(t=>{let r;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsDimension(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsDimension(a,u){return a.setPosition(a.position()+C.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}value(a){let u=this.bb.__offset(this.bb_pos,4);return u?(a||new e.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}denotation(a){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.__string(this.bb_pos+u,a):null}static startDimension(a){a.startObject(2)}static addValue(a,u){a.addFieldOffset(0,u,0)}static addDenotation(a,u){a.addFieldOffset(1,u,0)}static endDimension(a){return a.endObject()}static createDimension(a,u,l){return o.startDimension(a),o.addValue(a,u),o.addDenotation(a,l),o.endDimension(a)}}i.Dimension=o})(r=t.fbs||={})})(n=e.experimental||={})})(ne||={});(e=>{let n;(t=>{let r;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsDimensionValue(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsDimensionValue(a,u){return a.setPosition(a.position()+C.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}dimType(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readInt8(this.bb_pos+a):0}dimValue(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.readInt64(this.bb_pos+a):this.bb.createLong(0,0)}dimParam(a){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.__string(this.bb_pos+u,a):null}static startDimensionValue(a){a.startObject(3)}static addDimType(a,u){a.addFieldInt8(0,u,0)}static addDimValue(a,u){a.addFieldInt64(1,u,a.createLong(0,0))}static addDimParam(a,u){a.addFieldOffset(2,u,0)}static endDimensionValue(a){return a.endObject()}static createDimensionValue(a,u,l,d){return o.startDimensionValue(a),o.addDimType(a,u),o.addDimValue(a,l),o.addDimParam(a,d),o.endDimensionValue(a)}}i.DimensionValue=o})(r=t.fbs||={})})(n=e.experimental||={})})(ne||={});(e=>{let n;(t=>{let r;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsTensorTypeAndShape(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsTensorTypeAndShape(a,u){return a.setPosition(a.position()+C.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}elemType(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readInt32(this.bb_pos+a):0}shape(a){let u=this.bb.__offset(this.bb_pos,6);return u?(a||new e.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startTensorTypeAndShape(a){a.startObject(2)}static addElemType(a,u){a.addFieldInt32(0,u,0)}static addShape(a,u){a.addFieldOffset(1,u,0)}static endTensorTypeAndShape(a){return a.endObject()}static createTensorTypeAndShape(a,u,l){return o.startTensorTypeAndShape(a),o.addElemType(a,u),o.addShape(a,l),o.endTensorTypeAndShape(a)}}i.TensorTypeAndShape=o})(r=t.fbs||={})})(n=e.experimental||={})})(ne||={});(e=>{let n;(t=>{let r;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsMapType(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsMapType(a,u){return a.setPosition(a.position()+C.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}keyType(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readInt32(this.bb_pos+a):0}valueType(a){let u=this.bb.__offset(this.bb_pos,6);return u?(a||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startMapType(a){a.startObject(2)}static addKeyType(a,u){a.addFieldInt32(0,u,0)}static addValueType(a,u){a.addFieldOffset(1,u,0)}static endMapType(a){return a.endObject()}static createMapType(a,u,l){return o.startMapType(a),o.addKeyType(a,u),o.addValueType(a,l),o.endMapType(a)}}i.MapType=o})(r=t.fbs||={})})(n=e.experimental||={})})(ne||={});(e=>{let n;(t=>{let r;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsSequenceType(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsSequenceType(a,u){return a.setPosition(a.position()+C.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}elemType(a){let u=this.bb.__offset(this.bb_pos,4);return u?(a||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startSequenceType(a){a.startObject(1)}static addElemType(a,u){a.addFieldOffset(0,u,0)}static endSequenceType(a){return a.endObject()}static createSequenceType(a,u){return o.startSequenceType(a),o.addElemType(a,u),o.endSequenceType(a)}}i.SequenceType=o})(r=t.fbs||={})})(n=e.experimental||={})})(ne||={});(e=>{let n;(t=>{let r;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(a,u,l,d){return a.prep(4,12),a.writeInt32(d),a.writeInt32(l),a.writeInt32(u),a.offset()}}i.EdgeEnd=o})(r=t.fbs||={})})(n=e.experimental||={})})(ne||={});(e=>{let n;(t=>{let r;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsNodeEdge(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsNodeEdge(a,u){return a.setPosition(a.position()+C.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}nodeIndex(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readUint32(this.bb_pos+a):0}inputEdges(a,u){let l=this.bb.__offset(this.bb_pos,6);return l?(u||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+l)+a*12,this.bb):null}inputEdgesLength(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__vector_len(this.bb_pos+a):0}outputEdges(a,u){let l=this.bb.__offset(this.bb_pos,8);return l?(u||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+l)+a*12,this.bb):null}outputEdgesLength(){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__vector_len(this.bb_pos+a):0}static startNodeEdge(a){a.startObject(3)}static addNodeIndex(a,u){a.addFieldInt32(0,u,0)}static addInputEdges(a,u){a.addFieldOffset(1,u,0)}static startInputEdgesVector(a,u){a.startVector(12,u,4)}static addOutputEdges(a,u){a.addFieldOffset(2,u,0)}static startOutputEdgesVector(a,u){a.startVector(12,u,4)}static endNodeEdge(a){return a.endObject()}static createNodeEdge(a,u,l,d){return o.startNodeEdge(a),o.addNodeIndex(a,u),o.addInputEdges(a,l),o.addOutputEdges(a,d),o.endNodeEdge(a)}}i.NodeEdge=o})(r=t.fbs||={})})(n=e.experimental||={})})(ne||={});(e=>{let n;(t=>{let r;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsNode(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsNode(a,u){return a.setPosition(a.position()+C.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}name(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,a):null}docString(a){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.__string(this.bb_pos+u,a):null}domain(a){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.__string(this.bb_pos+u,a):null}sinceVersion(){let a=this.bb.__offset(this.bb_pos,10);return a?this.bb.readInt32(this.bb_pos+a):0}index(){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.readUint32(this.bb_pos+a):0}opType(a){let u=this.bb.__offset(this.bb_pos,14);return u?this.bb.__string(this.bb_pos+u,a):null}type(){let a=this.bb.__offset(this.bb_pos,16);return a?this.bb.readInt32(this.bb_pos+a):0}executionProviderType(a){let u=this.bb.__offset(this.bb_pos,18);return u?this.bb.__string(this.bb_pos+u,a):null}inputs(a,u){let l=this.bb.__offset(this.bb_pos,20);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+a*4,u):null}inputsLength(){let a=this.bb.__offset(this.bb_pos,20);return a?this.bb.__vector_len(this.bb_pos+a):0}outputs(a,u){let l=this.bb.__offset(this.bb_pos,22);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+a*4,u):null}outputsLength(){let a=this.bb.__offset(this.bb_pos,22);return a?this.bb.__vector_len(this.bb_pos+a):0}attributes(a,u){let l=this.bb.__offset(this.bb_pos,24);return l?(u||new e.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}attributesLength(){let a=this.bb.__offset(this.bb_pos,24);return a?this.bb.__vector_len(this.bb_pos+a):0}inputArgCounts(a){let u=this.bb.__offset(this.bb_pos,26);return u?this.bb.readInt32(this.bb.__vector(this.bb_pos+u)+a*4):0}inputArgCountsLength(){let a=this.bb.__offset(this.bb_pos,26);return a?this.bb.__vector_len(this.bb_pos+a):0}inputArgCountsArray(){let a=this.bb.__offset(this.bb_pos,26);return a?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+a),this.bb.__vector_len(this.bb_pos+a)):null}implicitInputs(a,u){let l=this.bb.__offset(this.bb_pos,28);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+a*4,u):null}implicitInputsLength(){let a=this.bb.__offset(this.bb_pos,28);return a?this.bb.__vector_len(this.bb_pos+a):0}static startNode(a){a.startObject(13)}static addName(a,u){a.addFieldOffset(0,u,0)}static addDocString(a,u){a.addFieldOffset(1,u,0)}static addDomain(a,u){a.addFieldOffset(2,u,0)}static addSinceVersion(a,u){a.addFieldInt32(3,u,0)}static addIndex(a,u){a.addFieldInt32(4,u,0)}static addOpType(a,u){a.addFieldOffset(5,u,0)}static addType(a,u){a.addFieldInt32(6,u,0)}static addExecutionProviderType(a,u){a.addFieldOffset(7,u,0)}static addInputs(a,u){a.addFieldOffset(8,u,0)}static createInputsVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startInputsVector(a,u){a.startVector(4,u,4)}static addOutputs(a,u){a.addFieldOffset(9,u,0)}static createOutputsVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startOutputsVector(a,u){a.startVector(4,u,4)}static addAttributes(a,u){a.addFieldOffset(10,u,0)}static createAttributesVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startAttributesVector(a,u){a.startVector(4,u,4)}static addInputArgCounts(a,u){a.addFieldOffset(11,u,0)}static createInputArgCountsVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addInt32(u[l]);return a.endVector()}static startInputArgCountsVector(a,u){a.startVector(4,u,4)}static addImplicitInputs(a,u){a.addFieldOffset(12,u,0)}static createImplicitInputsVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startImplicitInputsVector(a,u){a.startVector(4,u,4)}static endNode(a){return a.endObject()}static createNode(a,u,l,d,p,h,g,y,b,w,I,O,E,N){return o.startNode(a),o.addName(a,u),o.addDocString(a,l),o.addDomain(a,d),o.addSinceVersion(a,p),o.addIndex(a,h),o.addOpType(a,g),o.addType(a,y),o.addExecutionProviderType(a,b),o.addInputs(a,w),o.addOutputs(a,I),o.addAttributes(a,O),o.addInputArgCounts(a,E),o.addImplicitInputs(a,N),o.endNode(a)}}i.Node=o})(r=t.fbs||={})})(n=e.experimental||={})})(ne||={});(e=>{let n;(t=>{let r;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsValueInfo(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsValueInfo(a,u){return a.setPosition(a.position()+C.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}name(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,a):null}docString(a){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.__string(this.bb_pos+u,a):null}type(a){let u=this.bb.__offset(this.bb_pos,8);return u?(a||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startValueInfo(a){a.startObject(3)}static addName(a,u){a.addFieldOffset(0,u,0)}static addDocString(a,u){a.addFieldOffset(1,u,0)}static addType(a,u){a.addFieldOffset(2,u,0)}static endValueInfo(a){return a.endObject()}static createValueInfo(a,u,l,d){return o.startValueInfo(a),o.addName(a,u),o.addDocString(a,l),o.addType(a,d),o.endValueInfo(a)}}i.ValueInfo=o})(r=t.fbs||={})})(n=e.experimental||={})})(ne||={});(e=>{let n;(t=>{let r;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsTypeInfo(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsTypeInfo(a,u){return a.setPosition(a.position()+C.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}denotation(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,a):null}valueType(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.readUint8(this.bb_pos+a):0}value(a){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.__union(a,this.bb_pos+u):null}static startTypeInfo(a){a.startObject(3)}static addDenotation(a,u){a.addFieldOffset(0,u,0)}static addValueType(a,u){a.addFieldInt8(1,u,0)}static addValue(a,u){a.addFieldOffset(2,u,0)}static endTypeInfo(a){return a.endObject()}static createTypeInfo(a,u,l,d){return o.startTypeInfo(a),o.addDenotation(a,u),o.addValueType(a,l),o.addValue(a,d),o.endTypeInfo(a)}}i.TypeInfo=o})(r=t.fbs||={})})(n=e.experimental||={})})(ne||={});(e=>{let n;(t=>{let r;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsOperatorSetId(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsOperatorSetId(a,u){return a.setPosition(a.position()+C.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}domain(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,a):null}version(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.readInt64(this.bb_pos+a):this.bb.createLong(0,0)}static startOperatorSetId(a){a.startObject(2)}static addDomain(a,u){a.addFieldOffset(0,u,0)}static addVersion(a,u){a.addFieldInt64(1,u,a.createLong(0,0))}static endOperatorSetId(a){return a.endObject()}static createOperatorSetId(a,u,l){return o.startOperatorSetId(a),o.addDomain(a,u),o.addVersion(a,l),o.endOperatorSetId(a)}}i.OperatorSetId=o})(r=t.fbs||={})})(n=e.experimental||={})})(ne||={});(e=>{let n;(t=>{let r;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsTensor(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsTensor(a,u){return a.setPosition(a.position()+C.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}name(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,a):null}docString(a){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.__string(this.bb_pos+u,a):null}dims(a){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.readInt64(this.bb.__vector(this.bb_pos+u)+a*8):this.bb.createLong(0,0)}dimsLength(){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__vector_len(this.bb_pos+a):0}dataType(){let a=this.bb.__offset(this.bb_pos,10);return a?this.bb.readInt32(this.bb_pos+a):0}rawData(a){let u=this.bb.__offset(this.bb_pos,12);return u?this.bb.readUint8(this.bb.__vector(this.bb_pos+u)+a):0}rawDataLength(){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.__vector_len(this.bb_pos+a):0}rawDataArray(){let a=this.bb.__offset(this.bb_pos,12);return a?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+a),this.bb.__vector_len(this.bb_pos+a)):null}stringData(a,u){let l=this.bb.__offset(this.bb_pos,14);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+a*4,u):null}stringDataLength(){let a=this.bb.__offset(this.bb_pos,14);return a?this.bb.__vector_len(this.bb_pos+a):0}static startTensor(a){a.startObject(6)}static addName(a,u){a.addFieldOffset(0,u,0)}static addDocString(a,u){a.addFieldOffset(1,u,0)}static addDims(a,u){a.addFieldOffset(2,u,0)}static createDimsVector(a,u){a.startVector(8,u.length,8);for(let l=u.length-1;l>=0;l--)a.addInt64(u[l]);return a.endVector()}static startDimsVector(a,u){a.startVector(8,u,8)}static addDataType(a,u){a.addFieldInt32(3,u,0)}static addRawData(a,u){a.addFieldOffset(4,u,0)}static createRawDataVector(a,u){a.startVector(1,u.length,1);for(let l=u.length-1;l>=0;l--)a.addInt8(u[l]);return a.endVector()}static startRawDataVector(a,u){a.startVector(1,u,1)}static addStringData(a,u){a.addFieldOffset(5,u,0)}static createStringDataVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startStringDataVector(a,u){a.startVector(4,u,4)}static endTensor(a){return a.endObject()}static createTensor(a,u,l,d,p,h,g){return o.startTensor(a),o.addName(a,u),o.addDocString(a,l),o.addDims(a,d),o.addDataType(a,p),o.addRawData(a,h),o.addStringData(a,g),o.endTensor(a)}}i.Tensor=o})(r=t.fbs||={})})(n=e.experimental||={})})(ne||={});(e=>{let n;(t=>{let r;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsSparseTensor(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsSparseTensor(a,u){return a.setPosition(a.position()+C.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}values(a){let u=this.bb.__offset(this.bb_pos,4);return u?(a||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}indices(a){let u=this.bb.__offset(this.bb_pos,6);return u?(a||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}dims(a){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.readInt64(this.bb.__vector(this.bb_pos+u)+a*8):this.bb.createLong(0,0)}dimsLength(){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__vector_len(this.bb_pos+a):0}static startSparseTensor(a){a.startObject(3)}static addValues(a,u){a.addFieldOffset(0,u,0)}static addIndices(a,u){a.addFieldOffset(1,u,0)}static addDims(a,u){a.addFieldOffset(2,u,0)}static createDimsVector(a,u){a.startVector(8,u.length,8);for(let l=u.length-1;l>=0;l--)a.addInt64(u[l]);return a.endVector()}static startDimsVector(a,u){a.startVector(8,u,8)}static endSparseTensor(a){return a.endObject()}static createSparseTensor(a,u,l,d){return o.startSparseTensor(a),o.addValues(a,u),o.addIndices(a,l),o.addDims(a,d),o.endSparseTensor(a)}}i.SparseTensor=o})(r=t.fbs||={})})(n=e.experimental||={})})(ne||={});(e=>{let n;(t=>{let r;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsAttribute(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsAttribute(a,u){return a.setPosition(a.position()+C.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}name(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,a):null}docString(a){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.__string(this.bb_pos+u,a):null}type(){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.readInt32(this.bb_pos+a):0}f(){let a=this.bb.__offset(this.bb_pos,10);return a?this.bb.readFloat32(this.bb_pos+a):0}i(){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.readInt64(this.bb_pos+a):this.bb.createLong(0,0)}s(a){let u=this.bb.__offset(this.bb_pos,14);return u?this.bb.__string(this.bb_pos+u,a):null}t(a){let u=this.bb.__offset(this.bb_pos,16);return u?(a||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}g(a){let u=this.bb.__offset(this.bb_pos,18);return u?(a||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}floats(a){let u=this.bb.__offset(this.bb_pos,20);return u?this.bb.readFloat32(this.bb.__vector(this.bb_pos+u)+a*4):0}floatsLength(){let a=this.bb.__offset(this.bb_pos,20);return a?this.bb.__vector_len(this.bb_pos+a):0}floatsArray(){let a=this.bb.__offset(this.bb_pos,20);return a?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+a),this.bb.__vector_len(this.bb_pos+a)):null}ints(a){let u=this.bb.__offset(this.bb_pos,22);return u?this.bb.readInt64(this.bb.__vector(this.bb_pos+u)+a*8):this.bb.createLong(0,0)}intsLength(){let a=this.bb.__offset(this.bb_pos,22);return a?this.bb.__vector_len(this.bb_pos+a):0}strings(a,u){let l=this.bb.__offset(this.bb_pos,24);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+a*4,u):null}stringsLength(){let a=this.bb.__offset(this.bb_pos,24);return a?this.bb.__vector_len(this.bb_pos+a):0}tensors(a,u){let l=this.bb.__offset(this.bb_pos,26);return l?(u||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}tensorsLength(){let a=this.bb.__offset(this.bb_pos,26);return a?this.bb.__vector_len(this.bb_pos+a):0}graphs(a,u){let l=this.bb.__offset(this.bb_pos,28);return l?(u||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}graphsLength(){let a=this.bb.__offset(this.bb_pos,28);return a?this.bb.__vector_len(this.bb_pos+a):0}static startAttribute(a){a.startObject(13)}static addName(a,u){a.addFieldOffset(0,u,0)}static addDocString(a,u){a.addFieldOffset(1,u,0)}static addType(a,u){a.addFieldInt32(2,u,0)}static addF(a,u){a.addFieldFloat32(3,u,0)}static addI(a,u){a.addFieldInt64(4,u,a.createLong(0,0))}static addS(a,u){a.addFieldOffset(5,u,0)}static addT(a,u){a.addFieldOffset(6,u,0)}static addG(a,u){a.addFieldOffset(7,u,0)}static addFloats(a,u){a.addFieldOffset(8,u,0)}static createFloatsVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addFloat32(u[l]);return a.endVector()}static startFloatsVector(a,u){a.startVector(4,u,4)}static addInts(a,u){a.addFieldOffset(9,u,0)}static createIntsVector(a,u){a.startVector(8,u.length,8);for(let l=u.length-1;l>=0;l--)a.addInt64(u[l]);return a.endVector()}static startIntsVector(a,u){a.startVector(8,u,8)}static addStrings(a,u){a.addFieldOffset(10,u,0)}static createStringsVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startStringsVector(a,u){a.startVector(4,u,4)}static addTensors(a,u){a.addFieldOffset(11,u,0)}static createTensorsVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startTensorsVector(a,u){a.startVector(4,u,4)}static addGraphs(a,u){a.addFieldOffset(12,u,0)}static createGraphsVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startGraphsVector(a,u){a.startVector(4,u,4)}static endAttribute(a){return a.endObject()}static createAttribute(a,u,l,d,p,h,g,y,b,w,I,O,E,N){return o.startAttribute(a),o.addName(a,u),o.addDocString(a,l),o.addType(a,d),o.addF(a,p),o.addI(a,h),o.addS(a,g),o.addT(a,y),o.addG(a,b),o.addFloats(a,w),o.addInts(a,I),o.addStrings(a,O),o.addTensors(a,E),o.addGraphs(a,N),o.endAttribute(a)}}i.Attribute=o})(r=t.fbs||={})})(n=e.experimental||={})})(ne||={});(e=>{let n;(t=>{let r;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsGraph(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsGraph(a,u){return a.setPosition(a.position()+C.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}initializers(a,u){let l=this.bb.__offset(this.bb_pos,4);return l?(u||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}initializersLength(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__vector_len(this.bb_pos+a):0}nodeArgs(a,u){let l=this.bb.__offset(this.bb_pos,6);return l?(u||new e.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}nodeArgsLength(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__vector_len(this.bb_pos+a):0}nodes(a,u){let l=this.bb.__offset(this.bb_pos,8);return l?(u||new e.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}nodesLength(){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__vector_len(this.bb_pos+a):0}maxNodeIndex(){let a=this.bb.__offset(this.bb_pos,10);return a?this.bb.readUint32(this.bb_pos+a):0}nodeEdges(a,u){let l=this.bb.__offset(this.bb_pos,12);return l?(u||new e.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}nodeEdgesLength(){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.__vector_len(this.bb_pos+a):0}inputs(a,u){let l=this.bb.__offset(this.bb_pos,14);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+a*4,u):null}inputsLength(){let a=this.bb.__offset(this.bb_pos,14);return a?this.bb.__vector_len(this.bb_pos+a):0}outputs(a,u){let l=this.bb.__offset(this.bb_pos,16);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+a*4,u):null}outputsLength(){let a=this.bb.__offset(this.bb_pos,16);return a?this.bb.__vector_len(this.bb_pos+a):0}sparseInitializers(a,u){let l=this.bb.__offset(this.bb_pos,18);return l?(u||new e.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}sparseInitializersLength(){let a=this.bb.__offset(this.bb_pos,18);return a?this.bb.__vector_len(this.bb_pos+a):0}static startGraph(a){a.startObject(8)}static addInitializers(a,u){a.addFieldOffset(0,u,0)}static createInitializersVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startInitializersVector(a,u){a.startVector(4,u,4)}static addNodeArgs(a,u){a.addFieldOffset(1,u,0)}static createNodeArgsVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startNodeArgsVector(a,u){a.startVector(4,u,4)}static addNodes(a,u){a.addFieldOffset(2,u,0)}static createNodesVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startNodesVector(a,u){a.startVector(4,u,4)}static addMaxNodeIndex(a,u){a.addFieldInt32(3,u,0)}static addNodeEdges(a,u){a.addFieldOffset(4,u,0)}static createNodeEdgesVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startNodeEdgesVector(a,u){a.startVector(4,u,4)}static addInputs(a,u){a.addFieldOffset(5,u,0)}static createInputsVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startInputsVector(a,u){a.startVector(4,u,4)}static addOutputs(a,u){a.addFieldOffset(6,u,0)}static createOutputsVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startOutputsVector(a,u){a.startVector(4,u,4)}static addSparseInitializers(a,u){a.addFieldOffset(7,u,0)}static createSparseInitializersVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startSparseInitializersVector(a,u){a.startVector(4,u,4)}static endGraph(a){return a.endObject()}static createGraph(a,u,l,d,p,h,g,y,b){return o.startGraph(a),o.addInitializers(a,u),o.addNodeArgs(a,l),o.addNodes(a,d),o.addMaxNodeIndex(a,p),o.addNodeEdges(a,h),o.addInputs(a,g),o.addOutputs(a,y),o.addSparseInitializers(a,b),o.endGraph(a)}}i.Graph=o})(r=t.fbs||={})})(n=e.experimental||={})})(ne||={});(e=>{let n;(t=>{let r;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsModel(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsModel(a,u){return a.setPosition(a.position()+C.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}irVersion(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readInt64(this.bb_pos+a):this.bb.createLong(0,0)}opsetImport(a,u){let l=this.bb.__offset(this.bb_pos,6);return l?(u||new e.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}opsetImportLength(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__vector_len(this.bb_pos+a):0}producerName(a){let u=this.bb.__offset(this.bb_pos,8);return u?this.bb.__string(this.bb_pos+u,a):null}producerVersion(a){let u=this.bb.__offset(this.bb_pos,10);return u?this.bb.__string(this.bb_pos+u,a):null}domain(a){let u=this.bb.__offset(this.bb_pos,12);return u?this.bb.__string(this.bb_pos+u,a):null}modelVersion(){let a=this.bb.__offset(this.bb_pos,14);return a?this.bb.readInt64(this.bb_pos+a):this.bb.createLong(0,0)}docString(a){let u=this.bb.__offset(this.bb_pos,16);return u?this.bb.__string(this.bb_pos+u,a):null}graph(a){let u=this.bb.__offset(this.bb_pos,18);return u?(a||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}graphDocString(a){let u=this.bb.__offset(this.bb_pos,20);return u?this.bb.__string(this.bb_pos+u,a):null}static startModel(a){a.startObject(9)}static addIrVersion(a,u){a.addFieldInt64(0,u,a.createLong(0,0))}static addOpsetImport(a,u){a.addFieldOffset(1,u,0)}static createOpsetImportVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startOpsetImportVector(a,u){a.startVector(4,u,4)}static addProducerName(a,u){a.addFieldOffset(2,u,0)}static addProducerVersion(a,u){a.addFieldOffset(3,u,0)}static addDomain(a,u){a.addFieldOffset(4,u,0)}static addModelVersion(a,u){a.addFieldInt64(5,u,a.createLong(0,0))}static addDocString(a,u){a.addFieldOffset(6,u,0)}static addGraph(a,u){a.addFieldOffset(7,u,0)}static addGraphDocString(a,u){a.addFieldOffset(8,u,0)}static endModel(a){return a.endObject()}static createModel(a,u,l,d,p,h,g,y,b,w){return o.startModel(a),o.addIrVersion(a,u),o.addOpsetImport(a,l),o.addProducerName(a,d),o.addProducerVersion(a,p),o.addDomain(a,h),o.addModelVersion(a,g),o.addDocString(a,y),o.addGraph(a,b),o.addGraphDocString(a,w),o.endModel(a)}}i.Model=o})(r=t.fbs||={})})(n=e.experimental||={})})(ne||={});(e=>{let n;(t=>{let r;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsKernelCreateInfos(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsKernelCreateInfos(a,u){return a.setPosition(a.position()+C.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}nodeIndices(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.readUint32(this.bb.__vector(this.bb_pos+u)+a*4):0}nodeIndicesLength(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__vector_len(this.bb_pos+a):0}nodeIndicesArray(){let a=this.bb.__offset(this.bb_pos,4);return a?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+a),this.bb.__vector_len(this.bb_pos+a)):null}kernelDefHashes(a){let u=this.bb.__offset(this.bb_pos,6);return u?this.bb.readUint64(this.bb.__vector(this.bb_pos+u)+a*8):this.bb.createLong(0,0)}kernelDefHashesLength(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__vector_len(this.bb_pos+a):0}static startKernelCreateInfos(a){a.startObject(2)}static addNodeIndices(a,u){a.addFieldOffset(0,u,0)}static createNodeIndicesVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addInt32(u[l]);return a.endVector()}static startNodeIndicesVector(a,u){a.startVector(4,u,4)}static addKernelDefHashes(a,u){a.addFieldOffset(1,u,0)}static createKernelDefHashesVector(a,u){a.startVector(8,u.length,8);for(let l=u.length-1;l>=0;l--)a.addInt64(u[l]);return a.endVector()}static startKernelDefHashesVector(a,u){a.startVector(8,u,8)}static endKernelCreateInfos(a){return a.endObject()}static createKernelCreateInfos(a,u,l){return o.startKernelCreateInfos(a),o.addNodeIndices(a,u),o.addKernelDefHashes(a,l),o.endKernelCreateInfos(a)}}i.KernelCreateInfos=o})(r=t.fbs||={})})(n=e.experimental||={})})(ne||={});(e=>{let n;(t=>{let r;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsSubGraphSessionState(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsSubGraphSessionState(a,u){return a.setPosition(a.position()+C.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}graphId(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,a):null}sessionState(a){let u=this.bb.__offset(this.bb_pos,6);return u?(a||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startSubGraphSessionState(a){a.startObject(2)}static addGraphId(a,u){a.addFieldOffset(0,u,0)}static addSessionState(a,u){a.addFieldOffset(1,u,0)}static endSubGraphSessionState(a){let u=a.endObject();return a.requiredField(u,4),u}static createSubGraphSessionState(a,u,l){return o.startSubGraphSessionState(a),o.addGraphId(a,u),o.addSessionState(a,l),o.endSubGraphSessionState(a)}}i.SubGraphSessionState=o})(r=t.fbs||={})})(n=e.experimental||={})})(ne||={});(e=>{let n;(t=>{let r;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsSessionState(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsSessionState(a,u){return a.setPosition(a.position()+C.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}kernels(a){let u=this.bb.__offset(this.bb_pos,4);return u?(a||new e.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}subGraphSessionStates(a,u){let l=this.bb.__offset(this.bb_pos,6);return l?(u||new e.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}subGraphSessionStatesLength(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__vector_len(this.bb_pos+a):0}static startSessionState(a){a.startObject(2)}static addKernels(a,u){a.addFieldOffset(0,u,0)}static addSubGraphSessionStates(a,u){a.addFieldOffset(1,u,0)}static createSubGraphSessionStatesVector(a,u){a.startVector(4,u.length,4);for(let l=u.length-1;l>=0;l--)a.addOffset(u[l]);return a.endVector()}static startSubGraphSessionStatesVector(a,u){a.startVector(4,u,4)}static endSessionState(a){return a.endObject()}static createSessionState(a,u,l){return o.startSessionState(a),o.addKernels(a,u),o.addSubGraphSessionStates(a,l),o.endSessionState(a)}}i.SessionState=o})(r=t.fbs||={})})(n=e.experimental||={})})(ne||={});(e=>{let n;(t=>{let r;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,u){return this.bb_pos=a,this.bb=u,this}static getRootAsInferenceSession(a,u){return(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsInferenceSession(a,u){return a.setPosition(a.position()+C.SIZE_PREFIX_LENGTH),(u||new o).__init(a.readInt32(a.position())+a.position(),a)}static bufferHasIdentifier(a){return a.__has_identifier("ORTM")}ortVersion(a){let u=this.bb.__offset(this.bb_pos,4);return u?this.bb.__string(this.bb_pos+u,a):null}model(a){let u=this.bb.__offset(this.bb_pos,6);return u?(a||new e.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}sessionState(a){let u=this.bb.__offset(this.bb_pos,8);return u?(a||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+u),this.bb):null}static startInferenceSession(a){a.startObject(3)}static addOrtVersion(a,u){a.addFieldOffset(0,u,0)}static addModel(a,u){a.addFieldOffset(1,u,0)}static addSessionState(a,u){a.addFieldOffset(2,u,0)}static endInferenceSession(a){return a.endObject()}static finishInferenceSessionBuffer(a,u){a.finish(u,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(a,u){a.finish(u,"ORTM",!0)}static createInferenceSession(a,u,l,d){return o.startInferenceSession(a),o.addOrtVersion(a,u),o.addModel(a,l),o.addSessionState(a,d),o.endInferenceSession(a)}}i.InferenceSession=o})(r=t.fbs||={})})(n=e.experimental||={})})(ne||={})});var dl=Ve((H1,cl)=>{"use strict";cl.exports=py;function py(n,e){for(var r=new Array(arguments.length-1),t=0,o=2,i=!0;o<arguments.length;)r[t++]=arguments[o++];return new Promise(function(a,u){r[t]=function(d){if(i)if(i=!1,d)u(d);else{for(var p=new Array(arguments.length-1),h=0;h<p.length;)p[h++]=arguments[h];a.apply(null,p)}};try{n.apply(e||null,r)}catch(l){i&&(i=!1,u(l))}})}});var ml=Ve(hl=>{"use strict";var zo=hl;zo.length=function(e){var r=e.length;if(!r)return 0;for(var t=0;--r%4>1&&e.charAt(r)==="=";)++t;return Math.ceil(e.length*3)/4-t};var dn=new Array(64),pl=new Array(123);for(Vt=0;Vt<64;)pl[dn[Vt]=Vt<26?Vt+65:Vt<52?Vt+71:Vt<62?Vt-4:Vt-59|43]=Vt++;var Vt;zo.encode=function(e,r,t){for(var o=null,i=[],s=0,a=0,u;r<t;){var l=e[r++];switch(a){case 0:i[s++]=dn[l>>2],u=(l&3)<<4,a=1;break;case 1:i[s++]=dn[u|l>>4],u=(l&15)<<2,a=2;break;case 2:i[s++]=dn[u|l>>6],i[s++]=dn[l&63],a=0;break}s>8191&&((o||(o=[])).push(String.fromCharCode.apply(String,i)),s=0)}return a&&(i[s++]=dn[u],i[s++]=61,a===1&&(i[s++]=61)),o?(s&&o.push(String.fromCharCode.apply(String,i.slice(0,s))),o.join("")):String.fromCharCode.apply(String,i.slice(0,s))};var fl="invalid encoding";zo.decode=function(e,r,t){for(var o=t,i=0,s,a=0;a<e.length;){var u=e.charCodeAt(a++);if(u===61&&i>1)break;if((u=pl[u])===void 0)throw Error(fl);switch(i){case 0:s=u,i=1;break;case 1:r[t++]=s<<2|(u&48)>>4,s=u,i=2;break;case 2:r[t++]=(s&15)<<4|(u&60)>>2,s=u,i=3;break;case 3:r[t++]=(s&3)<<6|u,i=0;break}}if(i===1)throw Error(fl);return t-o};zo.test=function(e){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e)}});var bl=Ve((q1,gl)=>{"use strict";gl.exports=Go;function Go(){this._listeners={}}Go.prototype.on=function(e,r,t){return(this._listeners[e]||(this._listeners[e]=[])).push({fn:r,ctx:t||this}),this};Go.prototype.off=function(e,r){if(e===void 0)this._listeners={};else if(r===void 0)this._listeners[e]=[];else for(var t=this._listeners[e],o=0;o<t.length;)t[o].fn===r?t.splice(o,1):++o;return this};Go.prototype.emit=function(e){var r=this._listeners[e];if(r){for(var t=[],o=1;o<arguments.length;)t.push(arguments[o++]);for(o=0;o<r.length;)r[o].fn.apply(r[o++].ctx,t)}return this}});var Il=Ve((K1,$l)=>{"use strict";$l.exports=yl(yl);function yl(n){return typeof Float32Array<"u"?function(){var e=new Float32Array([-0]),r=new Uint8Array(e.buffer),t=r[3]===128;function o(u,l,d){e[0]=u,l[d]=r[0],l[d+1]=r[1],l[d+2]=r[2],l[d+3]=r[3]}function i(u,l,d){e[0]=u,l[d]=r[3],l[d+1]=r[2],l[d+2]=r[1],l[d+3]=r[0]}n.writeFloatLE=t?o:i,n.writeFloatBE=t?i:o;function s(u,l){return r[0]=u[l],r[1]=u[l+1],r[2]=u[l+2],r[3]=u[l+3],e[0]}function a(u,l){return r[3]=u[l],r[2]=u[l+1],r[1]=u[l+2],r[0]=u[l+3],e[0]}n.readFloatLE=t?s:a,n.readFloatBE=t?a:s}():function(){function e(t,o,i,s){var a=o<0?1:0;if(a&&(o=-o),o===0)t(1/o>0?0:2147483648,i,s);else if(isNaN(o))t(2143289344,i,s);else if(o>34028234663852886e22)t((a<<31|2139095040)>>>0,i,s);else if(o<11754943508222875e-54)t((a<<31|Math.round(o/1401298464324817e-60))>>>0,i,s);else{var u=Math.floor(Math.log(o)/Math.LN2),l=Math.round(o*Math.pow(2,-u)*8388608)&8388607;t((a<<31|u+127<<23|l)>>>0,i,s)}}n.writeFloatLE=e.bind(null,vl),n.writeFloatBE=e.bind(null,xl);function r(t,o,i){var s=t(o,i),a=(s>>31)*2+1,u=s>>>23&255,l=s&8388607;return u===255?l?NaN:a*(1/0):u===0?a*1401298464324817e-60*l:a*Math.pow(2,u-150)*(l+8388608)}n.readFloatLE=r.bind(null,wl),n.readFloatBE=r.bind(null,Tl)}(),typeof Float64Array<"u"?function(){var e=new Float64Array([-0]),r=new Uint8Array(e.buffer),t=r[7]===128;function o(u,l,d){e[0]=u,l[d]=r[0],l[d+1]=r[1],l[d+2]=r[2],l[d+3]=r[3],l[d+4]=r[4],l[d+5]=r[5],l[d+6]=r[6],l[d+7]=r[7]}function i(u,l,d){e[0]=u,l[d]=r[7],l[d+1]=r[6],l[d+2]=r[5],l[d+3]=r[4],l[d+4]=r[3],l[d+5]=r[2],l[d+6]=r[1],l[d+7]=r[0]}n.writeDoubleLE=t?o:i,n.writeDoubleBE=t?i:o;function s(u,l){return r[0]=u[l],r[1]=u[l+1],r[2]=u[l+2],r[3]=u[l+3],r[4]=u[l+4],r[5]=u[l+5],r[6]=u[l+6],r[7]=u[l+7],e[0]}function a(u,l){return r[7]=u[l],r[6]=u[l+1],r[5]=u[l+2],r[4]=u[l+3],r[3]=u[l+4],r[2]=u[l+5],r[1]=u[l+6],r[0]=u[l+7],e[0]}n.readDoubleLE=t?s:a,n.readDoubleBE=t?a:s}():function(){function e(t,o,i,s,a,u){var l=s<0?1:0;if(l&&(s=-s),s===0)t(0,a,u+o),t(1/s>0?0:2147483648,a,u+i);else if(isNaN(s))t(0,a,u+o),t(2146959360,a,u+i);else if(s>17976931348623157e292)t(0,a,u+o),t((l<<31|2146435072)>>>0,a,u+i);else{var d;if(s<22250738585072014e-324)d=s/5e-324,t(d>>>0,a,u+o),t((l<<31|d/4294967296)>>>0,a,u+i);else{var p=Math.floor(Math.log(s)/Math.LN2);p===1024&&(p=1023),d=s*Math.pow(2,-p),t(d*4503599627370496>>>0,a,u+o),t((l<<31|p+1023<<20|d*1048576&1048575)>>>0,a,u+i)}}}n.writeDoubleLE=e.bind(null,vl,0,4),n.writeDoubleBE=e.bind(null,xl,4,0);function r(t,o,i,s,a){var u=t(s,a+o),l=t(s,a+i),d=(l>>31)*2+1,p=l>>>20&2047,h=4294967296*(l&1048575)+u;return p===2047?h?NaN:d*(1/0):p===0?d*5e-324*h:d*Math.pow(2,p-1075)*(h+4503599627370496)}n.readDoubleLE=r.bind(null,wl,0,4),n.readDoubleBE=r.bind(null,Tl,4,0)}(),n}function vl(n,e,r){e[r]=n&255,e[r+1]=n>>>8&255,e[r+2]=n>>>16&255,e[r+3]=n>>>24}function xl(n,e,r){e[r]=n>>>24,e[r+1]=n>>>16&255,e[r+2]=n>>>8&255,e[r+3]=n&255}function wl(n,e){return(n[e]|n[e+1]<<8|n[e+2]<<16|n[e+3]<<24)>>>0}function Tl(n,e){return(n[e]<<24|n[e+1]<<16|n[e+2]<<8|n[e+3])>>>0}});var Sl=Ve((exports,module)=>{"use strict";module.exports=inquire;function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(n){}return null}});var Al=Ve(_l=>{"use strict";var ha=_l;ha.length=function(e){for(var r=0,t=0,o=0;o<e.length;++o)t=e.charCodeAt(o),t<128?r+=1:t<2048?r+=2:(t&64512)===55296&&(e.charCodeAt(o+1)&64512)===56320?(++o,r+=4):r+=3;return r};ha.read=function(e,r,t){var o=t-r;if(o<1)return"";for(var i=null,s=[],a=0,u;r<t;)u=e[r++],u<128?s[a++]=u:u>191&&u<224?s[a++]=(u&31)<<6|e[r++]&63:u>239&&u<365?(u=((u&7)<<18|(e[r++]&63)<<12|(e[r++]&63)<<6|e[r++]&63)-65536,s[a++]=55296+(u>>10),s[a++]=56320+(u&1023)):s[a++]=(u&15)<<12|(e[r++]&63)<<6|e[r++]&63,a>8191&&((i||(i=[])).push(String.fromCharCode.apply(String,s)),a=0);return i?(a&&i.push(String.fromCharCode.apply(String,s.slice(0,a))),i.join("")):String.fromCharCode.apply(String,s.slice(0,a))};ha.write=function(e,r,t){for(var o=t,i,s,a=0;a<e.length;++a)i=e.charCodeAt(a),i<128?r[t++]=i:i<2048?(r[t++]=i>>6|192,r[t++]=i&63|128):(i&64512)===55296&&((s=e.charCodeAt(a+1))&64512)===56320?(i=65536+((i&1023)<<10)+(s&1023),++a,r[t++]=i>>18|240,r[t++]=i>>12&63|128,r[t++]=i>>6&63|128,r[t++]=i&63|128):(r[t++]=i>>12|224,r[t++]=i>>6&63|128,r[t++]=i&63|128);return t-o}});var El=Ve((X1,Ol)=>{"use strict";Ol.exports=hy;function hy(n,e,r){var t=r||8192,o=t>>>1,i=null,s=t;return function(u){if(u<1||u>o)return n(u);s+u>t&&(i=n(t),s=0);var l=e.call(i,s,s+=u);return s&7&&(s=(s|7)+1),l}}});var Pl=Ve((J1,Cl)=>{"use strict";Cl.exports=lt;var Un=$r();function lt(n,e){this.lo=n>>>0,this.hi=e>>>0}var Fr=lt.zero=new lt(0,0);Fr.toNumber=function(){return 0};Fr.zzEncode=Fr.zzDecode=function(){return this};Fr.length=function(){return 1};var my=lt.zeroHash="\0\0\0\0\0\0\0\0";lt.fromNumber=function(e){if(e===0)return Fr;var r=e<0;r&&(e=-e);var t=e>>>0,o=(e-t)/4294967296>>>0;return r&&(o=~o>>>0,t=~t>>>0,++t>4294967295&&(t=0,++o>4294967295&&(o=0))),new lt(t,o)};lt.from=function(e){if(typeof e=="number")return lt.fromNumber(e);if(Un.isString(e))if(Un.Long)e=Un.Long.fromString(e);else return lt.fromNumber(parseInt(e,10));return e.low||e.high?new lt(e.low>>>0,e.high>>>0):Fr};lt.prototype.toNumber=function(e){if(!e&&this.hi>>>31){var r=~this.lo+1>>>0,t=~this.hi>>>0;return r||(t=t+1>>>0),-(r+t*4294967296)}return this.lo+this.hi*4294967296};lt.prototype.toLong=function(e){return Un.Long?new Un.Long(this.lo|0,this.hi|0,!!e):{low:this.lo|0,high:this.hi|0,unsigned:!!e}};var Tr=String.prototype.charCodeAt;lt.fromHash=function(e){return e===my?Fr:new lt((Tr.call(e,0)|Tr.call(e,1)<<8|Tr.call(e,2)<<16|Tr.call(e,3)<<24)>>>0,(Tr.call(e,4)|Tr.call(e,5)<<8|Tr.call(e,6)<<16|Tr.call(e,7)<<24)>>>0)};lt.prototype.toHash=function(){return String.fromCharCode(this.lo&255,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,this.hi&255,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)};lt.prototype.zzEncode=function(){var e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this};lt.prototype.zzDecode=function(){var e=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this};lt.prototype.length=function(){var e=this.lo,r=(this.lo>>>28|this.hi<<4)>>>0,t=this.hi>>>24;return t===0?r===0?e<16384?e<128?1:2:e<2097152?3:4:r<16384?r<128?5:6:r<2097152?7:8:t<128?9:10}});var $r=Ve(ma=>{"use strict";var se=ma;se.asPromise=dl();se.base64=ml();se.EventEmitter=bl();se.float=Il();se.inquire=Sl();se.utf8=Al();se.pool=El();se.LongBits=Pl();se.isNode=!!(typeof global<"u"&&global&&global.process&&global.process.versions&&global.process.versions.node);se.global=se.isNode&&global||typeof window<"u"&&window||typeof self<"u"&&self||ma;se.emptyArray=Object.freeze?Object.freeze([]):[];se.emptyObject=Object.freeze?Object.freeze({}):{};se.isInteger=Number.isInteger||function(e){return typeof e=="number"&&isFinite(e)&&Math.floor(e)===e};se.isString=function(e){return typeof e=="string"||e instanceof String};se.isObject=function(e){return e&&typeof e=="object"};se.isset=se.isSet=function(e,r){var t=e[r];return t!=null&&e.hasOwnProperty(r)?typeof t!="object"||(Array.isArray(t)?t.length:Object.keys(t).length)>0:!1};se.Buffer=function(){try{var n=se.inquire("buffer").Buffer;return n.prototype.utf8Write?n:null}catch{return null}}();se._Buffer_from=null;se._Buffer_allocUnsafe=null;se.newBuffer=function(e){return typeof e=="number"?se.Buffer?se._Buffer_allocUnsafe(e):new se.Array(e):se.Buffer?se._Buffer_from(e):typeof Uint8Array>"u"?e:new Uint8Array(e)};se.Array=typeof Uint8Array<"u"?Uint8Array:Array;se.Long=se.global.dcodeIO&&se.global.dcodeIO.Long||se.global.Long||se.inquire("long");se.key2Re=/^true|false|0|1$/;se.key32Re=/^-?(?:0|[1-9][0-9]*)$/;se.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;se.longToHash=function(e){return e?se.LongBits.from(e).toHash():se.LongBits.zeroHash};se.longFromHash=function(e,r){var t=se.LongBits.fromHash(e);return se.Long?se.Long.fromBits(t.lo,t.hi,r):t.toNumber(!!r)};function Dl(n,e,r){for(var t=Object.keys(e),o=0;o<t.length;++o)(n[t[o]]===void 0||!r)&&(n[t[o]]=e[t[o]]);return n}se.merge=Dl;se.lcFirst=function(e){return e.charAt(0).toLowerCase()+e.substring(1)};function kl(n){function e(r,t){if(!(this instanceof e))return new e(r,t);Object.defineProperty(this,"message",{get:function(){return r}}),Error.captureStackTrace?Error.captureStackTrace(this,e):Object.defineProperty(this,"stack",{value:new Error().stack||""}),t&&Dl(this,t)}return e.prototype=Object.create(Error.prototype,{constructor:{value:e,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return n},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),e}se.newError=kl;se.ProtocolError=kl("ProtocolError");se.oneOfGetter=function(e){for(var r={},t=0;t<e.length;++t)r[e[t]]=1;return function(){for(var o=Object.keys(this),i=o.length-1;i>-1;--i)if(r[o[i]]===1&&this[o[i]]!==void 0&&this[o[i]]!==null)return o[i]}};se.oneOfSetter=function(e){return function(r){for(var t=0;t<e.length;++t)e[t]!==r&&delete this[e[t]]}};se.toJSONOptions={longs:String,enums:String,bytes:String,json:!0};se._configure=function(){var n=se.Buffer;if(!n){se._Buffer_from=se._Buffer_allocUnsafe=null;return}se._Buffer_from=n.from!==Uint8Array.from&&n.from||function(r,t){return new n(r,t)},se._Buffer_allocUnsafe=n.allocUnsafe||function(r){return new n(r)}}});var Ta=Ve((Q1,Ll)=>{"use strict";Ll.exports=Pe;var Pt=$r(),ga,Wo=Pt.LongBits,Bl=Pt.base64,Rl=Pt.utf8;function Hn(n,e,r){this.fn=n,this.len=e,this.next=void 0,this.val=r}function ya(){}function gy(n){this.head=n.head,this.tail=n.tail,this.len=n.len,this.next=n.states}function Pe(){this.len=0,this.head=new Hn(ya,0,0),this.tail=this.head,this.states=null}var Ml=function(){return Pt.Buffer?function(){return(Pe.create=function(){return new ga})()}:function(){return new Pe}};Pe.create=Ml();Pe.alloc=function(e){return new Pt.Array(e)};Pt.Array!==Array&&(Pe.alloc=Pt.pool(Pe.alloc,Pt.Array.prototype.subarray));Pe.prototype._push=function(e,r,t){return this.tail=this.tail.next=new Hn(e,r,t),this.len+=r,this};function va(n,e,r){e[r]=n&255}function by(n,e,r){for(;n>127;)e[r++]=n&127|128,n>>>=7;e[r]=n}function xa(n,e){this.len=n,this.next=void 0,this.val=e}xa.prototype=Object.create(Hn.prototype);xa.prototype.fn=by;Pe.prototype.uint32=function(e){return this.len+=(this.tail=this.tail.next=new xa((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this};Pe.prototype.int32=function(e){return e<0?this._push(wa,10,Wo.fromNumber(e)):this.uint32(e)};Pe.prototype.sint32=function(e){return this.uint32((e<<1^e>>31)>>>0)};function wa(n,e,r){for(;n.hi;)e[r++]=n.lo&127|128,n.lo=(n.lo>>>7|n.hi<<25)>>>0,n.hi>>>=7;for(;n.lo>127;)e[r++]=n.lo&127|128,n.lo=n.lo>>>7;e[r++]=n.lo}Pe.prototype.uint64=function(e){var r=Wo.from(e);return this._push(wa,r.length(),r)};Pe.prototype.int64=Pe.prototype.uint64;Pe.prototype.sint64=function(e){var r=Wo.from(e).zzEncode();return this._push(wa,r.length(),r)};Pe.prototype.bool=function(e){return this._push(va,1,e?1:0)};function ba(n,e,r){e[r]=n&255,e[r+1]=n>>>8&255,e[r+2]=n>>>16&255,e[r+3]=n>>>24}Pe.prototype.fixed32=function(e){return this._push(ba,4,e>>>0)};Pe.prototype.sfixed32=Pe.prototype.fixed32;Pe.prototype.fixed64=function(e){var r=Wo.from(e);return this._push(ba,4,r.lo)._push(ba,4,r.hi)};Pe.prototype.sfixed64=Pe.prototype.fixed64;Pe.prototype.float=function(e){return this._push(Pt.float.writeFloatLE,4,e)};Pe.prototype.double=function(e){return this._push(Pt.float.writeDoubleLE,8,e)};var yy=Pt.Array.prototype.set?function(e,r,t){r.set(e,t)}:function(e,r,t){for(var o=0;o<e.length;++o)r[t+o]=e[o]};Pe.prototype.bytes=function(e){var r=e.length>>>0;if(!r)return this._push(va,1,0);if(Pt.isString(e)){var t=Pe.alloc(r=Bl.length(e));Bl.decode(e,t,0),e=t}return this.uint32(r)._push(yy,r,e)};Pe.prototype.string=function(e){var r=Rl.length(e);return r?this.uint32(r)._push(Rl.write,r,e):this._push(va,1,0)};Pe.prototype.fork=function(){return this.states=new gy(this),this.head=this.tail=new Hn(ya,0,0),this.len=0,this};Pe.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Hn(ya,0,0),this.len=0),this};Pe.prototype.ldelim=function(){var e=this.head,r=this.tail,t=this.len;return this.reset().uint32(t),t&&(this.tail.next=e.next,this.tail=r,this.len+=t),this};Pe.prototype.finish=function(){for(var e=this.head.next,r=this.constructor.alloc(this.len),t=0;e;)e.fn(e.val,r,t),t+=e.len,e=e.next;return r};Pe._configure=function(n){ga=n,Pe.create=Ml(),ga._configure()}});var zl=Ve((eT,Fl)=>{"use strict";Fl.exports=er;var Nl=Ta();(er.prototype=Object.create(Nl.prototype)).constructor=er;var Ir=$r();function er(){Nl.call(this)}er._configure=function(){er.alloc=Ir._Buffer_allocUnsafe,er.writeBytesBuffer=Ir.Buffer&&Ir.Buffer.prototype instanceof Uint8Array&&Ir.Buffer.prototype.set.name==="set"?function(e,r,t){r.set(e,t)}:function(e,r,t){if(e.copy)e.copy(r,t,0,e.length);else for(var o=0;o<e.length;)r[t++]=e[o++]}};er.prototype.bytes=function(e){Ir.isString(e)&&(e=Ir._Buffer_from(e,"base64"));var r=e.length>>>0;return this.uint32(r),r&&this._push(er.writeBytesBuffer,r,e),this};function vy(n,e,r){n.length<40?Ir.utf8.write(n,e,r):e.utf8Write?e.utf8Write(n,r):e.write(n,r)}er.prototype.string=function(e){var r=Ir.Buffer.byteLength(e);return this.uint32(r),r&&this._push(vy,r,e),this};er._configure()});var Sa=Ve((tT,Hl)=>{"use strict";Hl.exports=et;var tr=$r(),Ia,Vl=tr.LongBits,xy=tr.utf8;function Ut(n,e){return RangeError("index out of range: "+n.pos+" + "+(e||1)+" > "+n.len)}function et(n){this.buf=n,this.pos=0,this.len=n.length}var Gl=typeof Uint8Array<"u"?function(e){if(e instanceof Uint8Array||Array.isArray(e))return new et(e);throw Error("illegal buffer")}:function(e){if(Array.isArray(e))return new et(e);throw Error("illegal buffer")},Ul=function(){return tr.Buffer?function(r){return(et.create=function(o){return tr.Buffer.isBuffer(o)?new Ia(o):Gl(o)})(r)}:Gl};et.create=Ul();et.prototype._slice=tr.Array.prototype.subarray||tr.Array.prototype.slice;et.prototype.uint32=function(){var e=4294967295;return function(){if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,Ut(this,10);return e}}();et.prototype.int32=function(){return this.uint32()|0};et.prototype.sint32=function(){var e=this.uint32();return e>>>1^-(e&1)|0};function $a(){var n=new Vl(0,0),e=0;if(this.len-this.pos>4){for(;e<4;++e)if(n.lo=(n.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return n;if(n.lo=(n.lo|(this.buf[this.pos]&127)<<28)>>>0,n.hi=(n.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return n;e=0}else{for(;e<3;++e){if(this.pos>=this.len)throw Ut(this);if(n.lo=(n.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return n}return n.lo=(n.lo|(this.buf[this.pos++]&127)<<e*7)>>>0,n}if(this.len-this.pos>4){for(;e<5;++e)if(n.hi=(n.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return n}else for(;e<5;++e){if(this.pos>=this.len)throw Ut(this);if(n.hi=(n.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return n}throw Error("invalid varint encoding")}et.prototype.bool=function(){return this.uint32()!==0};function Vo(n,e){return(n[e-4]|n[e-3]<<8|n[e-2]<<16|n[e-1]<<24)>>>0}et.prototype.fixed32=function(){if(this.pos+4>this.len)throw Ut(this,4);return Vo(this.buf,this.pos+=4)};et.prototype.sfixed32=function(){if(this.pos+4>this.len)throw Ut(this,4);return Vo(this.buf,this.pos+=4)|0};function Wl(){if(this.pos+8>this.len)throw Ut(this,8);return new Vl(Vo(this.buf,this.pos+=4),Vo(this.buf,this.pos+=4))}et.prototype.float=function(){if(this.pos+4>this.len)throw Ut(this,4);var e=tr.float.readFloatLE(this.buf,this.pos);return this.pos+=4,e};et.prototype.double=function(){if(this.pos+8>this.len)throw Ut(this,4);var e=tr.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,e};et.prototype.bytes=function(){var e=this.uint32(),r=this.pos,t=this.pos+e;if(t>this.len)throw Ut(this,e);return this.pos+=e,Array.isArray(this.buf)?this.buf.slice(r,t):r===t?new this.buf.constructor(0):this._slice.call(this.buf,r,t)};et.prototype.string=function(){var e=this.bytes();return xy.read(e,0,e.length)};et.prototype.skip=function(e){if(typeof e=="number"){if(this.pos+e>this.len)throw Ut(this,e);this.pos+=e}else do if(this.pos>=this.len)throw Ut(this);while(this.buf[this.pos++]&128);return this};et.prototype.skipType=function(n){switch(n){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(n=this.uint32()&7)!==4;)this.skipType(n);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+n+" at offset "+this.pos)}return this};et._configure=function(n){Ia=n,et.create=Ul(),Ia._configure();var e=tr.Long?"toLong":"toNumber";tr.merge(et.prototype,{int64:function(){return $a.call(this)[e](!1)},uint64:function(){return $a.call(this)[e](!0)},sint64:function(){return $a.call(this).zzDecode()[e](!1)},fixed64:function(){return Wl.call(this)[e](!0)},sfixed64:function(){return Wl.call(this)[e](!1)}})}});var Yl=Ve((rT,Kl)=>{"use strict";Kl.exports=zr;var ql=Sa();(zr.prototype=Object.create(ql.prototype)).constructor=zr;var jl=$r();function zr(n){ql.call(this,n)}zr._configure=function(){jl.Buffer&&(zr.prototype._slice=jl.Buffer.prototype.slice)};zr.prototype.string=function(){var e=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+e,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+e,this.len))};zr._configure()});var Jl=Ve((nT,Xl)=>{"use strict";Xl.exports=jn;var _a=$r();(jn.prototype=Object.create(_a.EventEmitter.prototype)).constructor=jn;function jn(n,e,r){if(typeof n!="function")throw TypeError("rpcImpl must be a function");_a.EventEmitter.call(this),this.rpcImpl=n,this.requestDelimited=!!e,this.responseDelimited=!!r}jn.prototype.rpcCall=function n(e,r,t,o,i){if(!o)throw TypeError("request must be specified");var s=this;if(!i)return _a.asPromise(n,s,e,r,t,o);if(!s.rpcImpl){setTimeout(function(){i(Error("already ended"))},0);return}try{return s.rpcImpl(e,r[s.requestDelimited?"encodeDelimited":"encode"](o).finish(),function(u,l){if(u)return s.emit("error",u,e),i(u);if(l===null){s.end(!0);return}if(!(l instanceof t))try{l=t[s.responseDelimited?"decodeDelimited":"decode"](l)}catch(d){return s.emit("error",d,e),i(d)}return s.emit("data",l,e),i(null,l)})}catch(a){s.emit("error",a,e),setTimeout(function(){i(a)},0);return}};jn.prototype.end=function(e){return this.rpcImpl&&(e||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}});var Ql=Ve(Zl=>{"use strict";var wy=Zl;wy.Service=Jl()});var tc=Ve((iT,ec)=>{"use strict";ec.exports={}});var oc=Ve(nc=>{"use strict";var It=nc;It.build="minimal";It.Writer=Ta();It.BufferWriter=zl();It.Reader=Sa();It.BufferReader=Yl();It.util=$r();It.rpc=Ql();It.roots=tc();It.configure=rc;function rc(){It.util._configure(),It.Writer._configure(It.BufferWriter),It.Reader._configure(It.BufferReader)}rc()});var ac=Ve((sT,ic)=>{"use strict";ic.exports=oc()});var fn=Ve((uT,sc)=>{"use strict";var He=ac(),q=He.Reader,tt=He.Writer,_=He.util,T=He.roots.default||(He.roots.default={});T.onnx=function(){var n={};return n.Version=function(){var e={},r=Object.create(e);return r[e[0]="_START_VERSION"]=0,r[e[1]="IR_VERSION_2017_10_10"]=1,r[e[2]="IR_VERSION_2017_10_30"]=2,r[e[3]="IR_VERSION_2017_11_3"]=3,r[e[4]="IR_VERSION_2019_1_22"]=4,r[e[5]="IR_VERSION_2019_3_18"]=5,r[e[6]="IR_VERSION_2019_9_19"]=6,r[e[7]="IR_VERSION_2020_5_8"]=7,r[e[8]="IR_VERSION_2021_7_30"]=8,r[e[9]="IR_VERSION"]=9,r}(),n.AttributeProto=function(){function e(r){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],this.sparseTensors=[],this.typeProtos=[],r)for(var t=Object.keys(r),o=0;o<t.length;++o)r[t[o]]!=null&&(this[t[o]]=r[t[o]])}return e.prototype.name="",e.prototype.refAttrName="",e.prototype.docString="",e.prototype.type=0,e.prototype.f=0,e.prototype.i=_.Long?_.Long.fromBits(0,0,!1):0,e.prototype.s=_.newBuffer([]),e.prototype.t=null,e.prototype.g=null,e.prototype.sparseTensor=null,e.prototype.tp=null,e.prototype.floats=_.emptyArray,e.prototype.ints=_.emptyArray,e.prototype.strings=_.emptyArray,e.prototype.tensors=_.emptyArray,e.prototype.graphs=_.emptyArray,e.prototype.sparseTensors=_.emptyArray,e.prototype.typeProtos=_.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=tt.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&o.uint32(10).string(t.name),t.f!=null&&Object.hasOwnProperty.call(t,"f")&&o.uint32(21).float(t.f),t.i!=null&&Object.hasOwnProperty.call(t,"i")&&o.uint32(24).int64(t.i),t.s!=null&&Object.hasOwnProperty.call(t,"s")&&o.uint32(34).bytes(t.s),t.t!=null&&Object.hasOwnProperty.call(t,"t")&&T.onnx.TensorProto.encode(t.t,o.uint32(42).fork()).ldelim(),t.g!=null&&Object.hasOwnProperty.call(t,"g")&&T.onnx.GraphProto.encode(t.g,o.uint32(50).fork()).ldelim(),t.floats!=null&&t.floats.length){o.uint32(58).fork();for(var i=0;i<t.floats.length;++i)o.float(t.floats[i]);o.ldelim()}if(t.ints!=null&&t.ints.length){o.uint32(66).fork();for(var i=0;i<t.ints.length;++i)o.int64(t.ints[i]);o.ldelim()}if(t.strings!=null&&t.strings.length)for(var i=0;i<t.strings.length;++i)o.uint32(74).bytes(t.strings[i]);if(t.tensors!=null&&t.tensors.length)for(var i=0;i<t.tensors.length;++i)T.onnx.TensorProto.encode(t.tensors[i],o.uint32(82).fork()).ldelim();if(t.graphs!=null&&t.graphs.length)for(var i=0;i<t.graphs.length;++i)T.onnx.GraphProto.encode(t.graphs[i],o.uint32(90).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&o.uint32(106).string(t.docString),t.tp!=null&&Object.hasOwnProperty.call(t,"tp")&&T.onnx.TypeProto.encode(t.tp,o.uint32(114).fork()).ldelim(),t.typeProtos!=null&&t.typeProtos.length)for(var i=0;i<t.typeProtos.length;++i)T.onnx.TypeProto.encode(t.typeProtos[i],o.uint32(122).fork()).ldelim();if(t.type!=null&&Object.hasOwnProperty.call(t,"type")&&o.uint32(160).int32(t.type),t.refAttrName!=null&&Object.hasOwnProperty.call(t,"refAttrName")&&o.uint32(170).string(t.refAttrName),t.sparseTensor!=null&&Object.hasOwnProperty.call(t,"sparseTensor")&&T.onnx.SparseTensorProto.encode(t.sparseTensor,o.uint32(178).fork()).ldelim(),t.sparseTensors!=null&&t.sparseTensors.length)for(var i=0;i<t.sparseTensors.length;++i)T.onnx.SparseTensorProto.encode(t.sparseTensors[i],o.uint32(186).fork()).ldelim();return o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof q||(t=q.create(t));for(var i=o===void 0?t.len:t.pos+o,s=new T.onnx.AttributeProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{s.name=t.string();break}case 21:{s.refAttrName=t.string();break}case 13:{s.docString=t.string();break}case 20:{s.type=t.int32();break}case 2:{s.f=t.float();break}case 3:{s.i=t.int64();break}case 4:{s.s=t.bytes();break}case 5:{s.t=T.onnx.TensorProto.decode(t,t.uint32());break}case 6:{s.g=T.onnx.GraphProto.decode(t,t.uint32());break}case 22:{s.sparseTensor=T.onnx.SparseTensorProto.decode(t,t.uint32());break}case 14:{s.tp=T.onnx.TypeProto.decode(t,t.uint32());break}case 7:{if(s.floats&&s.floats.length||(s.floats=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.floats.push(t.float());else s.floats.push(t.float());break}case 8:{if(s.ints&&s.ints.length||(s.ints=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.ints.push(t.int64());else s.ints.push(t.int64());break}case 9:{s.strings&&s.strings.length||(s.strings=[]),s.strings.push(t.bytes());break}case 10:{s.tensors&&s.tensors.length||(s.tensors=[]),s.tensors.push(T.onnx.TensorProto.decode(t,t.uint32()));break}case 11:{s.graphs&&s.graphs.length||(s.graphs=[]),s.graphs.push(T.onnx.GraphProto.decode(t,t.uint32()));break}case 23:{s.sparseTensors&&s.sparseTensors.length||(s.sparseTensors=[]),s.sparseTensors.push(T.onnx.SparseTensorProto.decode(t,t.uint32()));break}case 15:{s.typeProtos&&s.typeProtos.length||(s.typeProtos=[]),s.typeProtos.push(T.onnx.TypeProto.decode(t,t.uint32()));break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof q||(t=new q(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!_.isString(t.name))return"name: string expected";if(t.refAttrName!=null&&t.hasOwnProperty("refAttrName")&&!_.isString(t.refAttrName))return"refAttrName: string expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!_.isString(t.docString))return"docString: string expected";if(t.type!=null&&t.hasOwnProperty("type"))switch(t.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 11:case 13:case 6:case 7:case 8:case 9:case 10:case 12:case 14:break}if(t.f!=null&&t.hasOwnProperty("f")&&typeof t.f!="number")return"f: number expected";if(t.i!=null&&t.hasOwnProperty("i")&&!_.isInteger(t.i)&&!(t.i&&_.isInteger(t.i.low)&&_.isInteger(t.i.high)))return"i: integer|Long expected";if(t.s!=null&&t.hasOwnProperty("s")&&!(t.s&&typeof t.s.length=="number"||_.isString(t.s)))return"s: buffer expected";if(t.t!=null&&t.hasOwnProperty("t")){var o=T.onnx.TensorProto.verify(t.t);if(o)return"t."+o}if(t.g!=null&&t.hasOwnProperty("g")){var o=T.onnx.GraphProto.verify(t.g);if(o)return"g."+o}if(t.sparseTensor!=null&&t.hasOwnProperty("sparseTensor")){var o=T.onnx.SparseTensorProto.verify(t.sparseTensor);if(o)return"sparseTensor."+o}if(t.tp!=null&&t.hasOwnProperty("tp")){var o=T.onnx.TypeProto.verify(t.tp);if(o)return"tp."+o}if(t.floats!=null&&t.hasOwnProperty("floats")){if(!Array.isArray(t.floats))return"floats: array expected";for(var i=0;i<t.floats.length;++i)if(typeof t.floats[i]!="number")return"floats: number[] expected"}if(t.ints!=null&&t.hasOwnProperty("ints")){if(!Array.isArray(t.ints))return"ints: array expected";for(var i=0;i<t.ints.length;++i)if(!_.isInteger(t.ints[i])&&!(t.ints[i]&&_.isInteger(t.ints[i].low)&&_.isInteger(t.ints[i].high)))return"ints: integer|Long[] expected"}if(t.strings!=null&&t.hasOwnProperty("strings")){if(!Array.isArray(t.strings))return"strings: array expected";for(var i=0;i<t.strings.length;++i)if(!(t.strings[i]&&typeof t.strings[i].length=="number"||_.isString(t.strings[i])))return"strings: buffer[] expected"}if(t.tensors!=null&&t.hasOwnProperty("tensors")){if(!Array.isArray(t.tensors))return"tensors: array expected";for(var i=0;i<t.tensors.length;++i){var o=T.onnx.TensorProto.verify(t.tensors[i]);if(o)return"tensors."+o}}if(t.graphs!=null&&t.hasOwnProperty("graphs")){if(!Array.isArray(t.graphs))return"graphs: array expected";for(var i=0;i<t.graphs.length;++i){var o=T.onnx.GraphProto.verify(t.graphs[i]);if(o)return"graphs."+o}}if(t.sparseTensors!=null&&t.hasOwnProperty("sparseTensors")){if(!Array.isArray(t.sparseTensors))return"sparseTensors: array expected";for(var i=0;i<t.sparseTensors.length;++i){var o=T.onnx.SparseTensorProto.verify(t.sparseTensors[i]);if(o)return"sparseTensors."+o}}if(t.typeProtos!=null&&t.hasOwnProperty("typeProtos")){if(!Array.isArray(t.typeProtos))return"typeProtos: array expected";for(var i=0;i<t.typeProtos.length;++i){var o=T.onnx.TypeProto.verify(t.typeProtos[i]);if(o)return"typeProtos."+o}}return null},e.fromObject=function(t){if(t instanceof T.onnx.AttributeProto)return t;var o=new T.onnx.AttributeProto;switch(t.name!=null&&(o.name=String(t.name)),t.refAttrName!=null&&(o.refAttrName=String(t.refAttrName)),t.docString!=null&&(o.docString=String(t.docString)),t.type){default:if(typeof t.type=="number"){o.type=t.type;break}break;case"UNDEFINED":case 0:o.type=0;break;case"FLOAT":case 1:o.type=1;break;case"INT":case 2:o.type=2;break;case"STRING":case 3:o.type=3;break;case"TENSOR":case 4:o.type=4;break;case"GRAPH":case 5:o.type=5;break;case"SPARSE_TENSOR":case 11:o.type=11;break;case"TYPE_PROTO":case 13:o.type=13;break;case"FLOATS":case 6:o.type=6;break;case"INTS":case 7:o.type=7;break;case"STRINGS":case 8:o.type=8;break;case"TENSORS":case 9:o.type=9;break;case"GRAPHS":case 10:o.type=10;break;case"SPARSE_TENSORS":case 12:o.type=12;break;case"TYPE_PROTOS":case 14:o.type=14;break}if(t.f!=null&&(o.f=Number(t.f)),t.i!=null&&(_.Long?(o.i=_.Long.fromValue(t.i)).unsigned=!1:typeof t.i=="string"?o.i=parseInt(t.i,10):typeof t.i=="number"?o.i=t.i:typeof t.i=="object"&&(o.i=new _.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber())),t.s!=null&&(typeof t.s=="string"?_.base64.decode(t.s,o.s=_.newBuffer(_.base64.length(t.s)),0):t.s.length>=0&&(o.s=t.s)),t.t!=null){if(typeof t.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");o.t=T.onnx.TensorProto.fromObject(t.t)}if(t.g!=null){if(typeof t.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");o.g=T.onnx.GraphProto.fromObject(t.g)}if(t.sparseTensor!=null){if(typeof t.sparseTensor!="object")throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");o.sparseTensor=T.onnx.SparseTensorProto.fromObject(t.sparseTensor)}if(t.tp!=null){if(typeof t.tp!="object")throw TypeError(".onnx.AttributeProto.tp: object expected");o.tp=T.onnx.TypeProto.fromObject(t.tp)}if(t.floats){if(!Array.isArray(t.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");o.floats=[];for(var i=0;i<t.floats.length;++i)o.floats[i]=Number(t.floats[i])}if(t.ints){if(!Array.isArray(t.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");o.ints=[];for(var i=0;i<t.ints.length;++i)_.Long?(o.ints[i]=_.Long.fromValue(t.ints[i])).unsigned=!1:typeof t.ints[i]=="string"?o.ints[i]=parseInt(t.ints[i],10):typeof t.ints[i]=="number"?o.ints[i]=t.ints[i]:typeof t.ints[i]=="object"&&(o.ints[i]=new _.LongBits(t.ints[i].low>>>0,t.ints[i].high>>>0).toNumber())}if(t.strings){if(!Array.isArray(t.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");o.strings=[];for(var i=0;i<t.strings.length;++i)typeof t.strings[i]=="string"?_.base64.decode(t.strings[i],o.strings[i]=_.newBuffer(_.base64.length(t.strings[i])),0):t.strings[i].length>=0&&(o.strings[i]=t.strings[i])}if(t.tensors){if(!Array.isArray(t.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");o.tensors=[];for(var i=0;i<t.tensors.length;++i){if(typeof t.tensors[i]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");o.tensors[i]=T.onnx.TensorProto.fromObject(t.tensors[i])}}if(t.graphs){if(!Array.isArray(t.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");o.graphs=[];for(var i=0;i<t.graphs.length;++i){if(typeof t.graphs[i]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");o.graphs[i]=T.onnx.GraphProto.fromObject(t.graphs[i])}}if(t.sparseTensors){if(!Array.isArray(t.sparseTensors))throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");o.sparseTensors=[];for(var i=0;i<t.sparseTensors.length;++i){if(typeof t.sparseTensors[i]!="object")throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");o.sparseTensors[i]=T.onnx.SparseTensorProto.fromObject(t.sparseTensors[i])}}if(t.typeProtos){if(!Array.isArray(t.typeProtos))throw TypeError(".onnx.AttributeProto.typeProtos: array expected");o.typeProtos=[];for(var i=0;i<t.typeProtos.length;++i){if(typeof t.typeProtos[i]!="object")throw TypeError(".onnx.AttributeProto.typeProtos: object expected");o.typeProtos[i]=T.onnx.TypeProto.fromObject(t.typeProtos[i])}}return o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.floats=[],i.ints=[],i.strings=[],i.tensors=[],i.graphs=[],i.typeProtos=[],i.sparseTensors=[]),o.defaults){if(i.name="",i.f=0,_.Long){var s=new _.Long(0,0,!1);i.i=o.longs===String?s.toString():o.longs===Number?s.toNumber():s}else i.i=o.longs===String?"0":0;o.bytes===String?i.s="":(i.s=[],o.bytes!==Array&&(i.s=_.newBuffer(i.s))),i.t=null,i.g=null,i.docString="",i.tp=null,i.type=o.enums===String?"UNDEFINED":0,i.refAttrName="",i.sparseTensor=null}if(t.name!=null&&t.hasOwnProperty("name")&&(i.name=t.name),t.f!=null&&t.hasOwnProperty("f")&&(i.f=o.json&&!isFinite(t.f)?String(t.f):t.f),t.i!=null&&t.hasOwnProperty("i")&&(typeof t.i=="number"?i.i=o.longs===String?String(t.i):t.i:i.i=o.longs===String?_.Long.prototype.toString.call(t.i):o.longs===Number?new _.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber():t.i),t.s!=null&&t.hasOwnProperty("s")&&(i.s=o.bytes===String?_.base64.encode(t.s,0,t.s.length):o.bytes===Array?Array.prototype.slice.call(t.s):t.s),t.t!=null&&t.hasOwnProperty("t")&&(i.t=T.onnx.TensorProto.toObject(t.t,o)),t.g!=null&&t.hasOwnProperty("g")&&(i.g=T.onnx.GraphProto.toObject(t.g,o)),t.floats&&t.floats.length){i.floats=[];for(var a=0;a<t.floats.length;++a)i.floats[a]=o.json&&!isFinite(t.floats[a])?String(t.floats[a]):t.floats[a]}if(t.ints&&t.ints.length){i.ints=[];for(var a=0;a<t.ints.length;++a)typeof t.ints[a]=="number"?i.ints[a]=o.longs===String?String(t.ints[a]):t.ints[a]:i.ints[a]=o.longs===String?_.Long.prototype.toString.call(t.ints[a]):o.longs===Number?new _.LongBits(t.ints[a].low>>>0,t.ints[a].high>>>0).toNumber():t.ints[a]}if(t.strings&&t.strings.length){i.strings=[];for(var a=0;a<t.strings.length;++a)i.strings[a]=o.bytes===String?_.base64.encode(t.strings[a],0,t.strings[a].length):o.bytes===Array?Array.prototype.slice.call(t.strings[a]):t.strings[a]}if(t.tensors&&t.tensors.length){i.tensors=[];for(var a=0;a<t.tensors.length;++a)i.tensors[a]=T.onnx.TensorProto.toObject(t.tensors[a],o)}if(t.graphs&&t.graphs.length){i.graphs=[];for(var a=0;a<t.graphs.length;++a)i.graphs[a]=T.onnx.GraphProto.toObject(t.graphs[a],o)}if(t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),t.tp!=null&&t.hasOwnProperty("tp")&&(i.tp=T.onnx.TypeProto.toObject(t.tp,o)),t.typeProtos&&t.typeProtos.length){i.typeProtos=[];for(var a=0;a<t.typeProtos.length;++a)i.typeProtos[a]=T.onnx.TypeProto.toObject(t.typeProtos[a],o)}if(t.type!=null&&t.hasOwnProperty("type")&&(i.type=o.enums===String?T.onnx.AttributeProto.AttributeType[t.type]===void 0?t.type:T.onnx.AttributeProto.AttributeType[t.type]:t.type),t.refAttrName!=null&&t.hasOwnProperty("refAttrName")&&(i.refAttrName=t.refAttrName),t.sparseTensor!=null&&t.hasOwnProperty("sparseTensor")&&(i.sparseTensor=T.onnx.SparseTensorProto.toObject(t.sparseTensor,o)),t.sparseTensors&&t.sparseTensors.length){i.sparseTensors=[];for(var a=0;a<t.sparseTensors.length;++a)i.sparseTensors[a]=T.onnx.SparseTensorProto.toObject(t.sparseTensors[a],o)}return i},e.prototype.toJSON=function(){return this.constructor.toObject(this,He.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.AttributeProto"},e.AttributeType=function(){var r={},t=Object.create(r);return t[r[0]="UNDEFINED"]=0,t[r[1]="FLOAT"]=1,t[r[2]="INT"]=2,t[r[3]="STRING"]=3,t[r[4]="TENSOR"]=4,t[r[5]="GRAPH"]=5,t[r[11]="SPARSE_TENSOR"]=11,t[r[13]="TYPE_PROTO"]=13,t[r[6]="FLOATS"]=6,t[r[7]="INTS"]=7,t[r[8]="STRINGS"]=8,t[r[9]="TENSORS"]=9,t[r[10]="GRAPHS"]=10,t[r[12]="SPARSE_TENSORS"]=12,t[r[14]="TYPE_PROTOS"]=14,t}(),e}(),n.ValueInfoProto=function(){function e(r){if(r)for(var t=Object.keys(r),o=0;o<t.length;++o)r[t[o]]!=null&&(this[t[o]]=r[t[o]])}return e.prototype.name="",e.prototype.type=null,e.prototype.docString="",e.create=function(t){return new e(t)},e.encode=function(t,o){return o||(o=tt.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&o.uint32(10).string(t.name),t.type!=null&&Object.hasOwnProperty.call(t,"type")&&T.onnx.TypeProto.encode(t.type,o.uint32(18).fork()).ldelim(),t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&o.uint32(26).string(t.docString),o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof q||(t=q.create(t));for(var i=o===void 0?t.len:t.pos+o,s=new T.onnx.ValueInfoProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{s.name=t.string();break}case 2:{s.type=T.onnx.TypeProto.decode(t,t.uint32());break}case 3:{s.docString=t.string();break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof q||(t=new q(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!_.isString(t.name))return"name: string expected";if(t.type!=null&&t.hasOwnProperty("type")){var o=T.onnx.TypeProto.verify(t.type);if(o)return"type."+o}return t.docString!=null&&t.hasOwnProperty("docString")&&!_.isString(t.docString)?"docString: string expected":null},e.fromObject=function(t){if(t instanceof T.onnx.ValueInfoProto)return t;var o=new T.onnx.ValueInfoProto;if(t.name!=null&&(o.name=String(t.name)),t.type!=null){if(typeof t.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");o.type=T.onnx.TypeProto.fromObject(t.type)}return t.docString!=null&&(o.docString=String(t.docString)),o},e.toObject=function(t,o){o||(o={});var i={};return o.defaults&&(i.name="",i.type=null,i.docString=""),t.name!=null&&t.hasOwnProperty("name")&&(i.name=t.name),t.type!=null&&t.hasOwnProperty("type")&&(i.type=T.onnx.TypeProto.toObject(t.type,o)),t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,He.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.ValueInfoProto"},e}(),n.NodeProto=function(){function e(r){if(this.input=[],this.output=[],this.attribute=[],r)for(var t=Object.keys(r),o=0;o<t.length;++o)r[t[o]]!=null&&(this[t[o]]=r[t[o]])}return e.prototype.input=_.emptyArray,e.prototype.output=_.emptyArray,e.prototype.name="",e.prototype.opType="",e.prototype.domain="",e.prototype.attribute=_.emptyArray,e.prototype.docString="",e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=tt.create()),t.input!=null&&t.input.length)for(var i=0;i<t.input.length;++i)o.uint32(10).string(t.input[i]);if(t.output!=null&&t.output.length)for(var i=0;i<t.output.length;++i)o.uint32(18).string(t.output[i]);if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&o.uint32(26).string(t.name),t.opType!=null&&Object.hasOwnProperty.call(t,"opType")&&o.uint32(34).string(t.opType),t.attribute!=null&&t.attribute.length)for(var i=0;i<t.attribute.length;++i)T.onnx.AttributeProto.encode(t.attribute[i],o.uint32(42).fork()).ldelim();return t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&o.uint32(50).string(t.docString),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&o.uint32(58).string(t.domain),o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof q||(t=q.create(t));for(var i=o===void 0?t.len:t.pos+o,s=new T.onnx.NodeProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{s.input&&s.input.length||(s.input=[]),s.input.push(t.string());break}case 2:{s.output&&s.output.length||(s.output=[]),s.output.push(t.string());break}case 3:{s.name=t.string();break}case 4:{s.opType=t.string();break}case 7:{s.domain=t.string();break}case 5:{s.attribute&&s.attribute.length||(s.attribute=[]),s.attribute.push(T.onnx.AttributeProto.decode(t,t.uint32()));break}case 6:{s.docString=t.string();break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof q||(t=new q(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var o=0;o<t.input.length;++o)if(!_.isString(t.input[o]))return"input: string[] expected"}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(var o=0;o<t.output.length;++o)if(!_.isString(t.output[o]))return"output: string[] expected"}if(t.name!=null&&t.hasOwnProperty("name")&&!_.isString(t.name))return"name: string expected";if(t.opType!=null&&t.hasOwnProperty("opType")&&!_.isString(t.opType))return"opType: string expected";if(t.domain!=null&&t.hasOwnProperty("domain")&&!_.isString(t.domain))return"domain: string expected";if(t.attribute!=null&&t.hasOwnProperty("attribute")){if(!Array.isArray(t.attribute))return"attribute: array expected";for(var o=0;o<t.attribute.length;++o){var i=T.onnx.AttributeProto.verify(t.attribute[o]);if(i)return"attribute."+i}}return t.docString!=null&&t.hasOwnProperty("docString")&&!_.isString(t.docString)?"docString: string expected":null},e.fromObject=function(t){if(t instanceof T.onnx.NodeProto)return t;var o=new T.onnx.NodeProto;if(t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.NodeProto.input: array expected");o.input=[];for(var i=0;i<t.input.length;++i)o.input[i]=String(t.input[i])}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.NodeProto.output: array expected");o.output=[];for(var i=0;i<t.output.length;++i)o.output[i]=String(t.output[i])}if(t.name!=null&&(o.name=String(t.name)),t.opType!=null&&(o.opType=String(t.opType)),t.domain!=null&&(o.domain=String(t.domain)),t.attribute){if(!Array.isArray(t.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");o.attribute=[];for(var i=0;i<t.attribute.length;++i){if(typeof t.attribute[i]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");o.attribute[i]=T.onnx.AttributeProto.fromObject(t.attribute[i])}}return t.docString!=null&&(o.docString=String(t.docString)),o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.input=[],i.output=[],i.attribute=[]),o.defaults&&(i.name="",i.opType="",i.docString="",i.domain=""),t.input&&t.input.length){i.input=[];for(var s=0;s<t.input.length;++s)i.input[s]=t.input[s]}if(t.output&&t.output.length){i.output=[];for(var s=0;s<t.output.length;++s)i.output[s]=t.output[s]}if(t.name!=null&&t.hasOwnProperty("name")&&(i.name=t.name),t.opType!=null&&t.hasOwnProperty("opType")&&(i.opType=t.opType),t.attribute&&t.attribute.length){i.attribute=[];for(var s=0;s<t.attribute.length;++s)i.attribute[s]=T.onnx.AttributeProto.toObject(t.attribute[s],o)}return t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),t.domain!=null&&t.hasOwnProperty("domain")&&(i.domain=t.domain),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,He.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.NodeProto"},e}(),n.TrainingInfoProto=function(){function e(r){if(this.initializationBinding=[],this.updateBinding=[],r)for(var t=Object.keys(r),o=0;o<t.length;++o)r[t[o]]!=null&&(this[t[o]]=r[t[o]])}return e.prototype.initialization=null,e.prototype.algorithm=null,e.prototype.initializationBinding=_.emptyArray,e.prototype.updateBinding=_.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=tt.create()),t.initialization!=null&&Object.hasOwnProperty.call(t,"initialization")&&T.onnx.GraphProto.encode(t.initialization,o.uint32(10).fork()).ldelim(),t.algorithm!=null&&Object.hasOwnProperty.call(t,"algorithm")&&T.onnx.GraphProto.encode(t.algorithm,o.uint32(18).fork()).ldelim(),t.initializationBinding!=null&&t.initializationBinding.length)for(var i=0;i<t.initializationBinding.length;++i)T.onnx.StringStringEntryProto.encode(t.initializationBinding[i],o.uint32(26).fork()).ldelim();if(t.updateBinding!=null&&t.updateBinding.length)for(var i=0;i<t.updateBinding.length;++i)T.onnx.StringStringEntryProto.encode(t.updateBinding[i],o.uint32(34).fork()).ldelim();return o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof q||(t=q.create(t));for(var i=o===void 0?t.len:t.pos+o,s=new T.onnx.TrainingInfoProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{s.initialization=T.onnx.GraphProto.decode(t,t.uint32());break}case 2:{s.algorithm=T.onnx.GraphProto.decode(t,t.uint32());break}case 3:{s.initializationBinding&&s.initializationBinding.length||(s.initializationBinding=[]),s.initializationBinding.push(T.onnx.StringStringEntryProto.decode(t,t.uint32()));break}case 4:{s.updateBinding&&s.updateBinding.length||(s.updateBinding=[]),s.updateBinding.push(T.onnx.StringStringEntryProto.decode(t,t.uint32()));break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof q||(t=new q(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.initialization!=null&&t.hasOwnProperty("initialization")){var o=T.onnx.GraphProto.verify(t.initialization);if(o)return"initialization."+o}if(t.algorithm!=null&&t.hasOwnProperty("algorithm")){var o=T.onnx.GraphProto.verify(t.algorithm);if(o)return"algorithm."+o}if(t.initializationBinding!=null&&t.hasOwnProperty("initializationBinding")){if(!Array.isArray(t.initializationBinding))return"initializationBinding: array expected";for(var i=0;i<t.initializationBinding.length;++i){var o=T.onnx.StringStringEntryProto.verify(t.initializationBinding[i]);if(o)return"initializationBinding."+o}}if(t.updateBinding!=null&&t.hasOwnProperty("updateBinding")){if(!Array.isArray(t.updateBinding))return"updateBinding: array expected";for(var i=0;i<t.updateBinding.length;++i){var o=T.onnx.StringStringEntryProto.verify(t.updateBinding[i]);if(o)return"updateBinding."+o}}return null},e.fromObject=function(t){if(t instanceof T.onnx.TrainingInfoProto)return t;var o=new T.onnx.TrainingInfoProto;if(t.initialization!=null){if(typeof t.initialization!="object")throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");o.initialization=T.onnx.GraphProto.fromObject(t.initialization)}if(t.algorithm!=null){if(typeof t.algorithm!="object")throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");o.algorithm=T.onnx.GraphProto.fromObject(t.algorithm)}if(t.initializationBinding){if(!Array.isArray(t.initializationBinding))throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");o.initializationBinding=[];for(var i=0;i<t.initializationBinding.length;++i){if(typeof t.initializationBinding[i]!="object")throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");o.initializationBinding[i]=T.onnx.StringStringEntryProto.fromObject(t.initializationBinding[i])}}if(t.updateBinding){if(!Array.isArray(t.updateBinding))throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");o.updateBinding=[];for(var i=0;i<t.updateBinding.length;++i){if(typeof t.updateBinding[i]!="object")throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");o.updateBinding[i]=T.onnx.StringStringEntryProto.fromObject(t.updateBinding[i])}}return o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.initializationBinding=[],i.updateBinding=[]),o.defaults&&(i.initialization=null,i.algorithm=null),t.initialization!=null&&t.hasOwnProperty("initialization")&&(i.initialization=T.onnx.GraphProto.toObject(t.initialization,o)),t.algorithm!=null&&t.hasOwnProperty("algorithm")&&(i.algorithm=T.onnx.GraphProto.toObject(t.algorithm,o)),t.initializationBinding&&t.initializationBinding.length){i.initializationBinding=[];for(var s=0;s<t.initializationBinding.length;++s)i.initializationBinding[s]=T.onnx.StringStringEntryProto.toObject(t.initializationBinding[s],o)}if(t.updateBinding&&t.updateBinding.length){i.updateBinding=[];for(var s=0;s<t.updateBinding.length;++s)i.updateBinding[s]=T.onnx.StringStringEntryProto.toObject(t.updateBinding[s],o)}return i},e.prototype.toJSON=function(){return this.constructor.toObject(this,He.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TrainingInfoProto"},e}(),n.ModelProto=function(){function e(r){if(this.opsetImport=[],this.metadataProps=[],this.trainingInfo=[],this.functions=[],r)for(var t=Object.keys(r),o=0;o<t.length;++o)r[t[o]]!=null&&(this[t[o]]=r[t[o]])}return e.prototype.irVersion=_.Long?_.Long.fromBits(0,0,!1):0,e.prototype.opsetImport=_.emptyArray,e.prototype.producerName="",e.prototype.producerVersion="",e.prototype.domain="",e.prototype.modelVersion=_.Long?_.Long.fromBits(0,0,!1):0,e.prototype.docString="",e.prototype.graph=null,e.prototype.metadataProps=_.emptyArray,e.prototype.trainingInfo=_.emptyArray,e.prototype.functions=_.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=tt.create()),t.irVersion!=null&&Object.hasOwnProperty.call(t,"irVersion")&&o.uint32(8).int64(t.irVersion),t.producerName!=null&&Object.hasOwnProperty.call(t,"producerName")&&o.uint32(18).string(t.producerName),t.producerVersion!=null&&Object.hasOwnProperty.call(t,"producerVersion")&&o.uint32(26).string(t.producerVersion),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&o.uint32(34).string(t.domain),t.modelVersion!=null&&Object.hasOwnProperty.call(t,"modelVersion")&&o.uint32(40).int64(t.modelVersion),t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&o.uint32(50).string(t.docString),t.graph!=null&&Object.hasOwnProperty.call(t,"graph")&&T.onnx.GraphProto.encode(t.graph,o.uint32(58).fork()).ldelim(),t.opsetImport!=null&&t.opsetImport.length)for(var i=0;i<t.opsetImport.length;++i)T.onnx.OperatorSetIdProto.encode(t.opsetImport[i],o.uint32(66).fork()).ldelim();if(t.metadataProps!=null&&t.metadataProps.length)for(var i=0;i<t.metadataProps.length;++i)T.onnx.StringStringEntryProto.encode(t.metadataProps[i],o.uint32(114).fork()).ldelim();if(t.trainingInfo!=null&&t.trainingInfo.length)for(var i=0;i<t.trainingInfo.length;++i)T.onnx.TrainingInfoProto.encode(t.trainingInfo[i],o.uint32(162).fork()).ldelim();if(t.functions!=null&&t.functions.length)for(var i=0;i<t.functions.length;++i)T.onnx.FunctionProto.encode(t.functions[i],o.uint32(202).fork()).ldelim();return o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof q||(t=q.create(t));for(var i=o===void 0?t.len:t.pos+o,s=new T.onnx.ModelProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{s.irVersion=t.int64();break}case 8:{s.opsetImport&&s.opsetImport.length||(s.opsetImport=[]),s.opsetImport.push(T.onnx.OperatorSetIdProto.decode(t,t.uint32()));break}case 2:{s.producerName=t.string();break}case 3:{s.producerVersion=t.string();break}case 4:{s.domain=t.string();break}case 5:{s.modelVersion=t.int64();break}case 6:{s.docString=t.string();break}case 7:{s.graph=T.onnx.GraphProto.decode(t,t.uint32());break}case 14:{s.metadataProps&&s.metadataProps.length||(s.metadataProps=[]),s.metadataProps.push(T.onnx.StringStringEntryProto.decode(t,t.uint32()));break}case 20:{s.trainingInfo&&s.trainingInfo.length||(s.trainingInfo=[]),s.trainingInfo.push(T.onnx.TrainingInfoProto.decode(t,t.uint32()));break}case 25:{s.functions&&s.functions.length||(s.functions=[]),s.functions.push(T.onnx.FunctionProto.decode(t,t.uint32()));break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof q||(t=new q(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.irVersion!=null&&t.hasOwnProperty("irVersion")&&!_.isInteger(t.irVersion)&&!(t.irVersion&&_.isInteger(t.irVersion.low)&&_.isInteger(t.irVersion.high)))return"irVersion: integer|Long expected";if(t.opsetImport!=null&&t.hasOwnProperty("opsetImport")){if(!Array.isArray(t.opsetImport))return"opsetImport: array expected";for(var o=0;o<t.opsetImport.length;++o){var i=T.onnx.OperatorSetIdProto.verify(t.opsetImport[o]);if(i)return"opsetImport."+i}}if(t.producerName!=null&&t.hasOwnProperty("producerName")&&!_.isString(t.producerName))return"producerName: string expected";if(t.producerVersion!=null&&t.hasOwnProperty("producerVersion")&&!_.isString(t.producerVersion))return"producerVersion: string expected";if(t.domain!=null&&t.hasOwnProperty("domain")&&!_.isString(t.domain))return"domain: string expected";if(t.modelVersion!=null&&t.hasOwnProperty("modelVersion")&&!_.isInteger(t.modelVersion)&&!(t.modelVersion&&_.isInteger(t.modelVersion.low)&&_.isInteger(t.modelVersion.high)))return"modelVersion: integer|Long expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!_.isString(t.docString))return"docString: string expected";if(t.graph!=null&&t.hasOwnProperty("graph")){var i=T.onnx.GraphProto.verify(t.graph);if(i)return"graph."+i}if(t.metadataProps!=null&&t.hasOwnProperty("metadataProps")){if(!Array.isArray(t.metadataProps))return"metadataProps: array expected";for(var o=0;o<t.metadataProps.length;++o){var i=T.onnx.StringStringEntryProto.verify(t.metadataProps[o]);if(i)return"metadataProps."+i}}if(t.trainingInfo!=null&&t.hasOwnProperty("trainingInfo")){if(!Array.isArray(t.trainingInfo))return"trainingInfo: array expected";for(var o=0;o<t.trainingInfo.length;++o){var i=T.onnx.TrainingInfoProto.verify(t.trainingInfo[o]);if(i)return"trainingInfo."+i}}if(t.functions!=null&&t.hasOwnProperty("functions")){if(!Array.isArray(t.functions))return"functions: array expected";for(var o=0;o<t.functions.length;++o){var i=T.onnx.FunctionProto.verify(t.functions[o]);if(i)return"functions."+i}}return null},e.fromObject=function(t){if(t instanceof T.onnx.ModelProto)return t;var o=new T.onnx.ModelProto;if(t.irVersion!=null&&(_.Long?(o.irVersion=_.Long.fromValue(t.irVersion)).unsigned=!1:typeof t.irVersion=="string"?o.irVersion=parseInt(t.irVersion,10):typeof t.irVersion=="number"?o.irVersion=t.irVersion:typeof t.irVersion=="object"&&(o.irVersion=new _.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber())),t.opsetImport){if(!Array.isArray(t.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");o.opsetImport=[];for(var i=0;i<t.opsetImport.length;++i){if(typeof t.opsetImport[i]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");o.opsetImport[i]=T.onnx.OperatorSetIdProto.fromObject(t.opsetImport[i])}}if(t.producerName!=null&&(o.producerName=String(t.producerName)),t.producerVersion!=null&&(o.producerVersion=String(t.producerVersion)),t.domain!=null&&(o.domain=String(t.domain)),t.modelVersion!=null&&(_.Long?(o.modelVersion=_.Long.fromValue(t.modelVersion)).unsigned=!1:typeof t.modelVersion=="string"?o.modelVersion=parseInt(t.modelVersion,10):typeof t.modelVersion=="number"?o.modelVersion=t.modelVersion:typeof t.modelVersion=="object"&&(o.modelVersion=new _.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber())),t.docString!=null&&(o.docString=String(t.docString)),t.graph!=null){if(typeof t.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");o.graph=T.onnx.GraphProto.fromObject(t.graph)}if(t.metadataProps){if(!Array.isArray(t.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");o.metadataProps=[];for(var i=0;i<t.metadataProps.length;++i){if(typeof t.metadataProps[i]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");o.metadataProps[i]=T.onnx.StringStringEntryProto.fromObject(t.metadataProps[i])}}if(t.trainingInfo){if(!Array.isArray(t.trainingInfo))throw TypeError(".onnx.ModelProto.trainingInfo: array expected");o.trainingInfo=[];for(var i=0;i<t.trainingInfo.length;++i){if(typeof t.trainingInfo[i]!="object")throw TypeError(".onnx.ModelProto.trainingInfo: object expected");o.trainingInfo[i]=T.onnx.TrainingInfoProto.fromObject(t.trainingInfo[i])}}if(t.functions){if(!Array.isArray(t.functions))throw TypeError(".onnx.ModelProto.functions: array expected");o.functions=[];for(var i=0;i<t.functions.length;++i){if(typeof t.functions[i]!="object")throw TypeError(".onnx.ModelProto.functions: object expected");o.functions[i]=T.onnx.FunctionProto.fromObject(t.functions[i])}}return o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.opsetImport=[],i.metadataProps=[],i.trainingInfo=[],i.functions=[]),o.defaults){if(_.Long){var s=new _.Long(0,0,!1);i.irVersion=o.longs===String?s.toString():o.longs===Number?s.toNumber():s}else i.irVersion=o.longs===String?"0":0;if(i.producerName="",i.producerVersion="",i.domain="",_.Long){var s=new _.Long(0,0,!1);i.modelVersion=o.longs===String?s.toString():o.longs===Number?s.toNumber():s}else i.modelVersion=o.longs===String?"0":0;i.docString="",i.graph=null}if(t.irVersion!=null&&t.hasOwnProperty("irVersion")&&(typeof t.irVersion=="number"?i.irVersion=o.longs===String?String(t.irVersion):t.irVersion:i.irVersion=o.longs===String?_.Long.prototype.toString.call(t.irVersion):o.longs===Number?new _.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber():t.irVersion),t.producerName!=null&&t.hasOwnProperty("producerName")&&(i.producerName=t.producerName),t.producerVersion!=null&&t.hasOwnProperty("producerVersion")&&(i.producerVersion=t.producerVersion),t.domain!=null&&t.hasOwnProperty("domain")&&(i.domain=t.domain),t.modelVersion!=null&&t.hasOwnProperty("modelVersion")&&(typeof t.modelVersion=="number"?i.modelVersion=o.longs===String?String(t.modelVersion):t.modelVersion:i.modelVersion=o.longs===String?_.Long.prototype.toString.call(t.modelVersion):o.longs===Number?new _.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber():t.modelVersion),t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),t.graph!=null&&t.hasOwnProperty("graph")&&(i.graph=T.onnx.GraphProto.toObject(t.graph,o)),t.opsetImport&&t.opsetImport.length){i.opsetImport=[];for(var a=0;a<t.opsetImport.length;++a)i.opsetImport[a]=T.onnx.OperatorSetIdProto.toObject(t.opsetImport[a],o)}if(t.metadataProps&&t.metadataProps.length){i.metadataProps=[];for(var a=0;a<t.metadataProps.length;++a)i.metadataProps[a]=T.onnx.StringStringEntryProto.toObject(t.metadataProps[a],o)}if(t.trainingInfo&&t.trainingInfo.length){i.trainingInfo=[];for(var a=0;a<t.trainingInfo.length;++a)i.trainingInfo[a]=T.onnx.TrainingInfoProto.toObject(t.trainingInfo[a],o)}if(t.functions&&t.functions.length){i.functions=[];for(var a=0;a<t.functions.length;++a)i.functions[a]=T.onnx.FunctionProto.toObject(t.functions[a],o)}return i},e.prototype.toJSON=function(){return this.constructor.toObject(this,He.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.ModelProto"},e}(),n.StringStringEntryProto=function(){function e(r){if(r)for(var t=Object.keys(r),o=0;o<t.length;++o)r[t[o]]!=null&&(this[t[o]]=r[t[o]])}return e.prototype.key="",e.prototype.value="",e.create=function(t){return new e(t)},e.encode=function(t,o){return o||(o=tt.create()),t.key!=null&&Object.hasOwnProperty.call(t,"key")&&o.uint32(10).string(t.key),t.value!=null&&Object.hasOwnProperty.call(t,"value")&&o.uint32(18).string(t.value),o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof q||(t=q.create(t));for(var i=o===void 0?t.len:t.pos+o,s=new T.onnx.StringStringEntryProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{s.key=t.string();break}case 2:{s.value=t.string();break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof q||(t=new q(t)),this.decode(t,t.uint32())},e.verify=function(t){return typeof t!="object"||t===null?"object expected":t.key!=null&&t.hasOwnProperty("key")&&!_.isString(t.key)?"key: string expected":t.value!=null&&t.hasOwnProperty("value")&&!_.isString(t.value)?"value: string expected":null},e.fromObject=function(t){if(t instanceof T.onnx.StringStringEntryProto)return t;var o=new T.onnx.StringStringEntryProto;return t.key!=null&&(o.key=String(t.key)),t.value!=null&&(o.value=String(t.value)),o},e.toObject=function(t,o){o||(o={});var i={};return o.defaults&&(i.key="",i.value=""),t.key!=null&&t.hasOwnProperty("key")&&(i.key=t.key),t.value!=null&&t.hasOwnProperty("value")&&(i.value=t.value),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,He.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.StringStringEntryProto"},e}(),n.TensorAnnotation=function(){function e(r){if(this.quantParameterTensorNames=[],r)for(var t=Object.keys(r),o=0;o<t.length;++o)r[t[o]]!=null&&(this[t[o]]=r[t[o]])}return e.prototype.tensorName="",e.prototype.quantParameterTensorNames=_.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=tt.create()),t.tensorName!=null&&Object.hasOwnProperty.call(t,"tensorName")&&o.uint32(10).string(t.tensorName),t.quantParameterTensorNames!=null&&t.quantParameterTensorNames.length)for(var i=0;i<t.quantParameterTensorNames.length;++i)T.onnx.StringStringEntryProto.encode(t.quantParameterTensorNames[i],o.uint32(18).fork()).ldelim();return o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof q||(t=q.create(t));for(var i=o===void 0?t.len:t.pos+o,s=new T.onnx.TensorAnnotation;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{s.tensorName=t.string();break}case 2:{s.quantParameterTensorNames&&s.quantParameterTensorNames.length||(s.quantParameterTensorNames=[]),s.quantParameterTensorNames.push(T.onnx.StringStringEntryProto.decode(t,t.uint32()));break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof q||(t=new q(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.tensorName!=null&&t.hasOwnProperty("tensorName")&&!_.isString(t.tensorName))return"tensorName: string expected";if(t.quantParameterTensorNames!=null&&t.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(t.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var o=0;o<t.quantParameterTensorNames.length;++o){var i=T.onnx.StringStringEntryProto.verify(t.quantParameterTensorNames[o]);if(i)return"quantParameterTensorNames."+i}}return null},e.fromObject=function(t){if(t instanceof T.onnx.TensorAnnotation)return t;var o=new T.onnx.TensorAnnotation;if(t.tensorName!=null&&(o.tensorName=String(t.tensorName)),t.quantParameterTensorNames){if(!Array.isArray(t.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");o.quantParameterTensorNames=[];for(var i=0;i<t.quantParameterTensorNames.length;++i){if(typeof t.quantParameterTensorNames[i]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");o.quantParameterTensorNames[i]=T.onnx.StringStringEntryProto.fromObject(t.quantParameterTensorNames[i])}}return o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.quantParameterTensorNames=[]),o.defaults&&(i.tensorName=""),t.tensorName!=null&&t.hasOwnProperty("tensorName")&&(i.tensorName=t.tensorName),t.quantParameterTensorNames&&t.quantParameterTensorNames.length){i.quantParameterTensorNames=[];for(var s=0;s<t.quantParameterTensorNames.length;++s)i.quantParameterTensorNames[s]=T.onnx.StringStringEntryProto.toObject(t.quantParameterTensorNames[s],o)}return i},e.prototype.toJSON=function(){return this.constructor.toObject(this,He.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorAnnotation"},e}(),n.GraphProto=function(){function e(r){if(this.node=[],this.initializer=[],this.sparseInitializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],r)for(var t=Object.keys(r),o=0;o<t.length;++o)r[t[o]]!=null&&(this[t[o]]=r[t[o]])}return e.prototype.node=_.emptyArray,e.prototype.name="",e.prototype.initializer=_.emptyArray,e.prototype.sparseInitializer=_.emptyArray,e.prototype.docString="",e.prototype.input=_.emptyArray,e.prototype.output=_.emptyArray,e.prototype.valueInfo=_.emptyArray,e.prototype.quantizationAnnotation=_.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=tt.create()),t.node!=null&&t.node.length)for(var i=0;i<t.node.length;++i)T.onnx.NodeProto.encode(t.node[i],o.uint32(10).fork()).ldelim();if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&o.uint32(18).string(t.name),t.initializer!=null&&t.initializer.length)for(var i=0;i<t.initializer.length;++i)T.onnx.TensorProto.encode(t.initializer[i],o.uint32(42).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&o.uint32(82).string(t.docString),t.input!=null&&t.input.length)for(var i=0;i<t.input.length;++i)T.onnx.ValueInfoProto.encode(t.input[i],o.uint32(90).fork()).ldelim();if(t.output!=null&&t.output.length)for(var i=0;i<t.output.length;++i)T.onnx.ValueInfoProto.encode(t.output[i],o.uint32(98).fork()).ldelim();if(t.valueInfo!=null&&t.valueInfo.length)for(var i=0;i<t.valueInfo.length;++i)T.onnx.ValueInfoProto.encode(t.valueInfo[i],o.uint32(106).fork()).ldelim();if(t.quantizationAnnotation!=null&&t.quantizationAnnotation.length)for(var i=0;i<t.quantizationAnnotation.length;++i)T.onnx.TensorAnnotation.encode(t.quantizationAnnotation[i],o.uint32(114).fork()).ldelim();if(t.sparseInitializer!=null&&t.sparseInitializer.length)for(var i=0;i<t.sparseInitializer.length;++i)T.onnx.SparseTensorProto.encode(t.sparseInitializer[i],o.uint32(122).fork()).ldelim();return o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof q||(t=q.create(t));for(var i=o===void 0?t.len:t.pos+o,s=new T.onnx.GraphProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{s.node&&s.node.length||(s.node=[]),s.node.push(T.onnx.NodeProto.decode(t,t.uint32()));break}case 2:{s.name=t.string();break}case 5:{s.initializer&&s.initializer.length||(s.initializer=[]),s.initializer.push(T.onnx.TensorProto.decode(t,t.uint32()));break}case 15:{s.sparseInitializer&&s.sparseInitializer.length||(s.sparseInitializer=[]),s.sparseInitializer.push(T.onnx.SparseTensorProto.decode(t,t.uint32()));break}case 10:{s.docString=t.string();break}case 11:{s.input&&s.input.length||(s.input=[]),s.input.push(T.onnx.ValueInfoProto.decode(t,t.uint32()));break}case 12:{s.output&&s.output.length||(s.output=[]),s.output.push(T.onnx.ValueInfoProto.decode(t,t.uint32()));break}case 13:{s.valueInfo&&s.valueInfo.length||(s.valueInfo=[]),s.valueInfo.push(T.onnx.ValueInfoProto.decode(t,t.uint32()));break}case 14:{s.quantizationAnnotation&&s.quantizationAnnotation.length||(s.quantizationAnnotation=[]),s.quantizationAnnotation.push(T.onnx.TensorAnnotation.decode(t,t.uint32()));break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof q||(t=new q(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.node!=null&&t.hasOwnProperty("node")){if(!Array.isArray(t.node))return"node: array expected";for(var o=0;o<t.node.length;++o){var i=T.onnx.NodeProto.verify(t.node[o]);if(i)return"node."+i}}if(t.name!=null&&t.hasOwnProperty("name")&&!_.isString(t.name))return"name: string expected";if(t.initializer!=null&&t.hasOwnProperty("initializer")){if(!Array.isArray(t.initializer))return"initializer: array expected";for(var o=0;o<t.initializer.length;++o){var i=T.onnx.TensorProto.verify(t.initializer[o]);if(i)return"initializer."+i}}if(t.sparseInitializer!=null&&t.hasOwnProperty("sparseInitializer")){if(!Array.isArray(t.sparseInitializer))return"sparseInitializer: array expected";for(var o=0;o<t.sparseInitializer.length;++o){var i=T.onnx.SparseTensorProto.verify(t.sparseInitializer[o]);if(i)return"sparseInitializer."+i}}if(t.docString!=null&&t.hasOwnProperty("docString")&&!_.isString(t.docString))return"docString: string expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var o=0;o<t.input.length;++o){var i=T.onnx.ValueInfoProto.verify(t.input[o]);if(i)return"input."+i}}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(var o=0;o<t.output.length;++o){var i=T.onnx.ValueInfoProto.verify(t.output[o]);if(i)return"output."+i}}if(t.valueInfo!=null&&t.hasOwnProperty("valueInfo")){if(!Array.isArray(t.valueInfo))return"valueInfo: array expected";for(var o=0;o<t.valueInfo.length;++o){var i=T.onnx.ValueInfoProto.verify(t.valueInfo[o]);if(i)return"valueInfo."+i}}if(t.quantizationAnnotation!=null&&t.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(t.quantizationAnnotation))return"quantizationAnnotation: array expected";for(var o=0;o<t.quantizationAnnotation.length;++o){var i=T.onnx.TensorAnnotation.verify(t.quantizationAnnotation[o]);if(i)return"quantizationAnnotation."+i}}return null},e.fromObject=function(t){if(t instanceof T.onnx.GraphProto)return t;var o=new T.onnx.GraphProto;if(t.node){if(!Array.isArray(t.node))throw TypeError(".onnx.GraphProto.node: array expected");o.node=[];for(var i=0;i<t.node.length;++i){if(typeof t.node[i]!="object")throw TypeError(".onnx.GraphProto.node: object expected");o.node[i]=T.onnx.NodeProto.fromObject(t.node[i])}}if(t.name!=null&&(o.name=String(t.name)),t.initializer){if(!Array.isArray(t.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");o.initializer=[];for(var i=0;i<t.initializer.length;++i){if(typeof t.initializer[i]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");o.initializer[i]=T.onnx.TensorProto.fromObject(t.initializer[i])}}if(t.sparseInitializer){if(!Array.isArray(t.sparseInitializer))throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");o.sparseInitializer=[];for(var i=0;i<t.sparseInitializer.length;++i){if(typeof t.sparseInitializer[i]!="object")throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");o.sparseInitializer[i]=T.onnx.SparseTensorProto.fromObject(t.sparseInitializer[i])}}if(t.docString!=null&&(o.docString=String(t.docString)),t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.GraphProto.input: array expected");o.input=[];for(var i=0;i<t.input.length;++i){if(typeof t.input[i]!="object")throw TypeError(".onnx.GraphProto.input: object expected");o.input[i]=T.onnx.ValueInfoProto.fromObject(t.input[i])}}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.GraphProto.output: array expected");o.output=[];for(var i=0;i<t.output.length;++i){if(typeof t.output[i]!="object")throw TypeError(".onnx.GraphProto.output: object expected");o.output[i]=T.onnx.ValueInfoProto.fromObject(t.output[i])}}if(t.valueInfo){if(!Array.isArray(t.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");o.valueInfo=[];for(var i=0;i<t.valueInfo.length;++i){if(typeof t.valueInfo[i]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");o.valueInfo[i]=T.onnx.ValueInfoProto.fromObject(t.valueInfo[i])}}if(t.quantizationAnnotation){if(!Array.isArray(t.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");o.quantizationAnnotation=[];for(var i=0;i<t.quantizationAnnotation.length;++i){if(typeof t.quantizationAnnotation[i]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");o.quantizationAnnotation[i]=T.onnx.TensorAnnotation.fromObject(t.quantizationAnnotation[i])}}return o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.node=[],i.initializer=[],i.input=[],i.output=[],i.valueInfo=[],i.quantizationAnnotation=[],i.sparseInitializer=[]),o.defaults&&(i.name="",i.docString=""),t.node&&t.node.length){i.node=[];for(var s=0;s<t.node.length;++s)i.node[s]=T.onnx.NodeProto.toObject(t.node[s],o)}if(t.name!=null&&t.hasOwnProperty("name")&&(i.name=t.name),t.initializer&&t.initializer.length){i.initializer=[];for(var s=0;s<t.initializer.length;++s)i.initializer[s]=T.onnx.TensorProto.toObject(t.initializer[s],o)}if(t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),t.input&&t.input.length){i.input=[];for(var s=0;s<t.input.length;++s)i.input[s]=T.onnx.ValueInfoProto.toObject(t.input[s],o)}if(t.output&&t.output.length){i.output=[];for(var s=0;s<t.output.length;++s)i.output[s]=T.onnx.ValueInfoProto.toObject(t.output[s],o)}if(t.valueInfo&&t.valueInfo.length){i.valueInfo=[];for(var s=0;s<t.valueInfo.length;++s)i.valueInfo[s]=T.onnx.ValueInfoProto.toObject(t.valueInfo[s],o)}if(t.quantizationAnnotation&&t.quantizationAnnotation.length){i.quantizationAnnotation=[];for(var s=0;s<t.quantizationAnnotation.length;++s)i.quantizationAnnotation[s]=T.onnx.TensorAnnotation.toObject(t.quantizationAnnotation[s],o)}if(t.sparseInitializer&&t.sparseInitializer.length){i.sparseInitializer=[];for(var s=0;s<t.sparseInitializer.length;++s)i.sparseInitializer[s]=T.onnx.SparseTensorProto.toObject(t.sparseInitializer[s],o)}return i},e.prototype.toJSON=function(){return this.constructor.toObject(this,He.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.GraphProto"},e}(),n.TensorProto=function(){function e(r){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],r)for(var t=Object.keys(r),o=0;o<t.length;++o)r[t[o]]!=null&&(this[t[o]]=r[t[o]])}return e.prototype.dims=_.emptyArray,e.prototype.dataType=0,e.prototype.segment=null,e.prototype.floatData=_.emptyArray,e.prototype.int32Data=_.emptyArray,e.prototype.stringData=_.emptyArray,e.prototype.int64Data=_.emptyArray,e.prototype.name="",e.prototype.docString="",e.prototype.rawData=_.newBuffer([]),e.prototype.externalData=_.emptyArray,e.prototype.dataLocation=0,e.prototype.doubleData=_.emptyArray,e.prototype.uint64Data=_.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=tt.create()),t.dims!=null&&t.dims.length){o.uint32(10).fork();for(var i=0;i<t.dims.length;++i)o.int64(t.dims[i]);o.ldelim()}if(t.dataType!=null&&Object.hasOwnProperty.call(t,"dataType")&&o.uint32(16).int32(t.dataType),t.segment!=null&&Object.hasOwnProperty.call(t,"segment")&&T.onnx.TensorProto.Segment.encode(t.segment,o.uint32(26).fork()).ldelim(),t.floatData!=null&&t.floatData.length){o.uint32(34).fork();for(var i=0;i<t.floatData.length;++i)o.float(t.floatData[i]);o.ldelim()}if(t.int32Data!=null&&t.int32Data.length){o.uint32(42).fork();for(var i=0;i<t.int32Data.length;++i)o.int32(t.int32Data[i]);o.ldelim()}if(t.stringData!=null&&t.stringData.length)for(var i=0;i<t.stringData.length;++i)o.uint32(50).bytes(t.stringData[i]);if(t.int64Data!=null&&t.int64Data.length){o.uint32(58).fork();for(var i=0;i<t.int64Data.length;++i)o.int64(t.int64Data[i]);o.ldelim()}if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&o.uint32(66).string(t.name),t.rawData!=null&&Object.hasOwnProperty.call(t,"rawData")&&o.uint32(74).bytes(t.rawData),t.doubleData!=null&&t.doubleData.length){o.uint32(82).fork();for(var i=0;i<t.doubleData.length;++i)o.double(t.doubleData[i]);o.ldelim()}if(t.uint64Data!=null&&t.uint64Data.length){o.uint32(90).fork();for(var i=0;i<t.uint64Data.length;++i)o.uint64(t.uint64Data[i]);o.ldelim()}if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&o.uint32(98).string(t.docString),t.externalData!=null&&t.externalData.length)for(var i=0;i<t.externalData.length;++i)T.onnx.StringStringEntryProto.encode(t.externalData[i],o.uint32(106).fork()).ldelim();return t.dataLocation!=null&&Object.hasOwnProperty.call(t,"dataLocation")&&o.uint32(112).int32(t.dataLocation),o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof q||(t=q.create(t));for(var i=o===void 0?t.len:t.pos+o,s=new T.onnx.TensorProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{if(s.dims&&s.dims.length||(s.dims=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.dims.push(t.int64());else s.dims.push(t.int64());break}case 2:{s.dataType=t.int32();break}case 3:{s.segment=T.onnx.TensorProto.Segment.decode(t,t.uint32());break}case 4:{if(s.floatData&&s.floatData.length||(s.floatData=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.floatData.push(t.float());else s.floatData.push(t.float());break}case 5:{if(s.int32Data&&s.int32Data.length||(s.int32Data=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.int32Data.push(t.int32());else s.int32Data.push(t.int32());break}case 6:{s.stringData&&s.stringData.length||(s.stringData=[]),s.stringData.push(t.bytes());break}case 7:{if(s.int64Data&&s.int64Data.length||(s.int64Data=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.int64Data.push(t.int64());else s.int64Data.push(t.int64());break}case 8:{s.name=t.string();break}case 12:{s.docString=t.string();break}case 9:{s.rawData=t.bytes();break}case 13:{s.externalData&&s.externalData.length||(s.externalData=[]),s.externalData.push(T.onnx.StringStringEntryProto.decode(t,t.uint32()));break}case 14:{s.dataLocation=t.int32();break}case 10:{if(s.doubleData&&s.doubleData.length||(s.doubleData=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.doubleData.push(t.double());else s.doubleData.push(t.double());break}case 11:{if(s.uint64Data&&s.uint64Data.length||(s.uint64Data=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.uint64Data.push(t.uint64());else s.uint64Data.push(t.uint64());break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof q||(t=new q(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.dims!=null&&t.hasOwnProperty("dims")){if(!Array.isArray(t.dims))return"dims: array expected";for(var o=0;o<t.dims.length;++o)if(!_.isInteger(t.dims[o])&&!(t.dims[o]&&_.isInteger(t.dims[o].low)&&_.isInteger(t.dims[o].high)))return"dims: integer|Long[] expected"}if(t.dataType!=null&&t.hasOwnProperty("dataType")&&!_.isInteger(t.dataType))return"dataType: integer expected";if(t.segment!=null&&t.hasOwnProperty("segment")){var i=T.onnx.TensorProto.Segment.verify(t.segment);if(i)return"segment."+i}if(t.floatData!=null&&t.hasOwnProperty("floatData")){if(!Array.isArray(t.floatData))return"floatData: array expected";for(var o=0;o<t.floatData.length;++o)if(typeof t.floatData[o]!="number")return"floatData: number[] expected"}if(t.int32Data!=null&&t.hasOwnProperty("int32Data")){if(!Array.isArray(t.int32Data))return"int32Data: array expected";for(var o=0;o<t.int32Data.length;++o)if(!_.isInteger(t.int32Data[o]))return"int32Data: integer[] expected"}if(t.stringData!=null&&t.hasOwnProperty("stringData")){if(!Array.isArray(t.stringData))return"stringData: array expected";for(var o=0;o<t.stringData.length;++o)if(!(t.stringData[o]&&typeof t.stringData[o].length=="number"||_.isString(t.stringData[o])))return"stringData: buffer[] expected"}if(t.int64Data!=null&&t.hasOwnProperty("int64Data")){if(!Array.isArray(t.int64Data))return"int64Data: array expected";for(var o=0;o<t.int64Data.length;++o)if(!_.isInteger(t.int64Data[o])&&!(t.int64Data[o]&&_.isInteger(t.int64Data[o].low)&&_.isInteger(t.int64Data[o].high)))return"int64Data: integer|Long[] expected"}if(t.name!=null&&t.hasOwnProperty("name")&&!_.isString(t.name))return"name: string expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!_.isString(t.docString))return"docString: string expected";if(t.rawData!=null&&t.hasOwnProperty("rawData")&&!(t.rawData&&typeof t.rawData.length=="number"||_.isString(t.rawData)))return"rawData: buffer expected";if(t.externalData!=null&&t.hasOwnProperty("externalData")){if(!Array.isArray(t.externalData))return"externalData: array expected";for(var o=0;o<t.externalData.length;++o){var i=T.onnx.StringStringEntryProto.verify(t.externalData[o]);if(i)return"externalData."+i}}if(t.dataLocation!=null&&t.hasOwnProperty("dataLocation"))switch(t.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:break}if(t.doubleData!=null&&t.hasOwnProperty("doubleData")){if(!Array.isArray(t.doubleData))return"doubleData: array expected";for(var o=0;o<t.doubleData.length;++o)if(typeof t.doubleData[o]!="number")return"doubleData: number[] expected"}if(t.uint64Data!=null&&t.hasOwnProperty("uint64Data")){if(!Array.isArray(t.uint64Data))return"uint64Data: array expected";for(var o=0;o<t.uint64Data.length;++o)if(!_.isInteger(t.uint64Data[o])&&!(t.uint64Data[o]&&_.isInteger(t.uint64Data[o].low)&&_.isInteger(t.uint64Data[o].high)))return"uint64Data: integer|Long[] expected"}return null},e.fromObject=function(t){if(t instanceof T.onnx.TensorProto)return t;var o=new T.onnx.TensorProto;if(t.dims){if(!Array.isArray(t.dims))throw TypeError(".onnx.TensorProto.dims: array expected");o.dims=[];for(var i=0;i<t.dims.length;++i)_.Long?(o.dims[i]=_.Long.fromValue(t.dims[i])).unsigned=!1:typeof t.dims[i]=="string"?o.dims[i]=parseInt(t.dims[i],10):typeof t.dims[i]=="number"?o.dims[i]=t.dims[i]:typeof t.dims[i]=="object"&&(o.dims[i]=new _.LongBits(t.dims[i].low>>>0,t.dims[i].high>>>0).toNumber())}if(t.dataType!=null&&(o.dataType=t.dataType|0),t.segment!=null){if(typeof t.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");o.segment=T.onnx.TensorProto.Segment.fromObject(t.segment)}if(t.floatData){if(!Array.isArray(t.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");o.floatData=[];for(var i=0;i<t.floatData.length;++i)o.floatData[i]=Number(t.floatData[i])}if(t.int32Data){if(!Array.isArray(t.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");o.int32Data=[];for(var i=0;i<t.int32Data.length;++i)o.int32Data[i]=t.int32Data[i]|0}if(t.stringData){if(!Array.isArray(t.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");o.stringData=[];for(var i=0;i<t.stringData.length;++i)typeof t.stringData[i]=="string"?_.base64.decode(t.stringData[i],o.stringData[i]=_.newBuffer(_.base64.length(t.stringData[i])),0):t.stringData[i].length>=0&&(o.stringData[i]=t.stringData[i])}if(t.int64Data){if(!Array.isArray(t.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");o.int64Data=[];for(var i=0;i<t.int64Data.length;++i)_.Long?(o.int64Data[i]=_.Long.fromValue(t.int64Data[i])).unsigned=!1:typeof t.int64Data[i]=="string"?o.int64Data[i]=parseInt(t.int64Data[i],10):typeof t.int64Data[i]=="number"?o.int64Data[i]=t.int64Data[i]:typeof t.int64Data[i]=="object"&&(o.int64Data[i]=new _.LongBits(t.int64Data[i].low>>>0,t.int64Data[i].high>>>0).toNumber())}if(t.name!=null&&(o.name=String(t.name)),t.docString!=null&&(o.docString=String(t.docString)),t.rawData!=null&&(typeof t.rawData=="string"?_.base64.decode(t.rawData,o.rawData=_.newBuffer(_.base64.length(t.rawData)),0):t.rawData.length>=0&&(o.rawData=t.rawData)),t.externalData){if(!Array.isArray(t.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");o.externalData=[];for(var i=0;i<t.externalData.length;++i){if(typeof t.externalData[i]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");o.externalData[i]=T.onnx.StringStringEntryProto.fromObject(t.externalData[i])}}switch(t.dataLocation){default:if(typeof t.dataLocation=="number"){o.dataLocation=t.dataLocation;break}break;case"DEFAULT":case 0:o.dataLocation=0;break;case"EXTERNAL":case 1:o.dataLocation=1;break}if(t.doubleData){if(!Array.isArray(t.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");o.doubleData=[];for(var i=0;i<t.doubleData.length;++i)o.doubleData[i]=Number(t.doubleData[i])}if(t.uint64Data){if(!Array.isArray(t.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");o.uint64Data=[];for(var i=0;i<t.uint64Data.length;++i)_.Long?(o.uint64Data[i]=_.Long.fromValue(t.uint64Data[i])).unsigned=!0:typeof t.uint64Data[i]=="string"?o.uint64Data[i]=parseInt(t.uint64Data[i],10):typeof t.uint64Data[i]=="number"?o.uint64Data[i]=t.uint64Data[i]:typeof t.uint64Data[i]=="object"&&(o.uint64Data[i]=new _.LongBits(t.uint64Data[i].low>>>0,t.uint64Data[i].high>>>0).toNumber(!0))}return o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.dims=[],i.floatData=[],i.int32Data=[],i.stringData=[],i.int64Data=[],i.doubleData=[],i.uint64Data=[],i.externalData=[]),o.defaults&&(i.dataType=0,i.segment=null,i.name="",o.bytes===String?i.rawData="":(i.rawData=[],o.bytes!==Array&&(i.rawData=_.newBuffer(i.rawData))),i.docString="",i.dataLocation=o.enums===String?"DEFAULT":0),t.dims&&t.dims.length){i.dims=[];for(var s=0;s<t.dims.length;++s)typeof t.dims[s]=="number"?i.dims[s]=o.longs===String?String(t.dims[s]):t.dims[s]:i.dims[s]=o.longs===String?_.Long.prototype.toString.call(t.dims[s]):o.longs===Number?new _.LongBits(t.dims[s].low>>>0,t.dims[s].high>>>0).toNumber():t.dims[s]}if(t.dataType!=null&&t.hasOwnProperty("dataType")&&(i.dataType=t.dataType),t.segment!=null&&t.hasOwnProperty("segment")&&(i.segment=T.onnx.TensorProto.Segment.toObject(t.segment,o)),t.floatData&&t.floatData.length){i.floatData=[];for(var s=0;s<t.floatData.length;++s)i.floatData[s]=o.json&&!isFinite(t.floatData[s])?String(t.floatData[s]):t.floatData[s]}if(t.int32Data&&t.int32Data.length){i.int32Data=[];for(var s=0;s<t.int32Data.length;++s)i.int32Data[s]=t.int32Data[s]}if(t.stringData&&t.stringData.length){i.stringData=[];for(var s=0;s<t.stringData.length;++s)i.stringData[s]=o.bytes===String?_.base64.encode(t.stringData[s],0,t.stringData[s].length):o.bytes===Array?Array.prototype.slice.call(t.stringData[s]):t.stringData[s]}if(t.int64Data&&t.int64Data.length){i.int64Data=[];for(var s=0;s<t.int64Data.length;++s)typeof t.int64Data[s]=="number"?i.int64Data[s]=o.longs===String?String(t.int64Data[s]):t.int64Data[s]:i.int64Data[s]=o.longs===String?_.Long.prototype.toString.call(t.int64Data[s]):o.longs===Number?new _.LongBits(t.int64Data[s].low>>>0,t.int64Data[s].high>>>0).toNumber():t.int64Data[s]}if(t.name!=null&&t.hasOwnProperty("name")&&(i.name=t.name),t.rawData!=null&&t.hasOwnProperty("rawData")&&(i.rawData=o.bytes===String?_.base64.encode(t.rawData,0,t.rawData.length):o.bytes===Array?Array.prototype.slice.call(t.rawData):t.rawData),t.doubleData&&t.doubleData.length){i.doubleData=[];for(var s=0;s<t.doubleData.length;++s)i.doubleData[s]=o.json&&!isFinite(t.doubleData[s])?String(t.doubleData[s]):t.doubleData[s]}if(t.uint64Data&&t.uint64Data.length){i.uint64Data=[];for(var s=0;s<t.uint64Data.length;++s)typeof t.uint64Data[s]=="number"?i.uint64Data[s]=o.longs===String?String(t.uint64Data[s]):t.uint64Data[s]:i.uint64Data[s]=o.longs===String?_.Long.prototype.toString.call(t.uint64Data[s]):o.longs===Number?new _.LongBits(t.uint64Data[s].low>>>0,t.uint64Data[s].high>>>0).toNumber(!0):t.uint64Data[s]}if(t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),t.externalData&&t.externalData.length){i.externalData=[];for(var s=0;s<t.externalData.length;++s)i.externalData[s]=T.onnx.StringStringEntryProto.toObject(t.externalData[s],o)}return t.dataLocation!=null&&t.hasOwnProperty("dataLocation")&&(i.dataLocation=o.enums===String?T.onnx.TensorProto.DataLocation[t.dataLocation]===void 0?t.dataLocation:T.onnx.TensorProto.DataLocation[t.dataLocation]:t.dataLocation),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,He.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorProto"},e.DataType=function(){var r={},t=Object.create(r);return t[r[0]="UNDEFINED"]=0,t[r[1]="FLOAT"]=1,t[r[2]="UINT8"]=2,t[r[3]="INT8"]=3,t[r[4]="UINT16"]=4,t[r[5]="INT16"]=5,t[r[6]="INT32"]=6,t[r[7]="INT64"]=7,t[r[8]="STRING"]=8,t[r[9]="BOOL"]=9,t[r[10]="FLOAT16"]=10,t[r[11]="DOUBLE"]=11,t[r[12]="UINT32"]=12,t[r[13]="UINT64"]=13,t[r[14]="COMPLEX64"]=14,t[r[15]="COMPLEX128"]=15,t[r[16]="BFLOAT16"]=16,t[r[17]="FLOAT8E4M3FN"]=17,t[r[18]="FLOAT8E4M3FNUZ"]=18,t[r[19]="FLOAT8E5M2"]=19,t[r[20]="FLOAT8E5M2FNUZ"]=20,t}(),e.Segment=function(){function r(t){if(t)for(var o=Object.keys(t),i=0;i<o.length;++i)t[o[i]]!=null&&(this[o[i]]=t[o[i]])}return r.prototype.begin=_.Long?_.Long.fromBits(0,0,!1):0,r.prototype.end=_.Long?_.Long.fromBits(0,0,!1):0,r.create=function(o){return new r(o)},r.encode=function(o,i){return i||(i=tt.create()),o.begin!=null&&Object.hasOwnProperty.call(o,"begin")&&i.uint32(8).int64(o.begin),o.end!=null&&Object.hasOwnProperty.call(o,"end")&&i.uint32(16).int64(o.end),i},r.encodeDelimited=function(o,i){return this.encode(o,i).ldelim()},r.decode=function(o,i){o instanceof q||(o=q.create(o));for(var s=i===void 0?o.len:o.pos+i,a=new T.onnx.TensorProto.Segment;o.pos<s;){var u=o.uint32();switch(u>>>3){case 1:{a.begin=o.int64();break}case 2:{a.end=o.int64();break}default:o.skipType(u&7);break}}return a},r.decodeDelimited=function(o){return o instanceof q||(o=new q(o)),this.decode(o,o.uint32())},r.verify=function(o){return typeof o!="object"||o===null?"object expected":o.begin!=null&&o.hasOwnProperty("begin")&&!_.isInteger(o.begin)&&!(o.begin&&_.isInteger(o.begin.low)&&_.isInteger(o.begin.high))?"begin: integer|Long expected":o.end!=null&&o.hasOwnProperty("end")&&!_.isInteger(o.end)&&!(o.end&&_.isInteger(o.end.low)&&_.isInteger(o.end.high))?"end: integer|Long expected":null},r.fromObject=function(o){if(o instanceof T.onnx.TensorProto.Segment)return o;var i=new T.onnx.TensorProto.Segment;return o.begin!=null&&(_.Long?(i.begin=_.Long.fromValue(o.begin)).unsigned=!1:typeof o.begin=="string"?i.begin=parseInt(o.begin,10):typeof o.begin=="number"?i.begin=o.begin:typeof o.begin=="object"&&(i.begin=new _.LongBits(o.begin.low>>>0,o.begin.high>>>0).toNumber())),o.end!=null&&(_.Long?(i.end=_.Long.fromValue(o.end)).unsigned=!1:typeof o.end=="string"?i.end=parseInt(o.end,10):typeof o.end=="number"?i.end=o.end:typeof o.end=="object"&&(i.end=new _.LongBits(o.end.low>>>0,o.end.high>>>0).toNumber())),i},r.toObject=function(o,i){i||(i={});var s={};if(i.defaults){if(_.Long){var a=new _.Long(0,0,!1);s.begin=i.longs===String?a.toString():i.longs===Number?a.toNumber():a}else s.begin=i.longs===String?"0":0;if(_.Long){var a=new _.Long(0,0,!1);s.end=i.longs===String?a.toString():i.longs===Number?a.toNumber():a}else s.end=i.longs===String?"0":0}return o.begin!=null&&o.hasOwnProperty("begin")&&(typeof o.begin=="number"?s.begin=i.longs===String?String(o.begin):o.begin:s.begin=i.longs===String?_.Long.prototype.toString.call(o.begin):i.longs===Number?new _.LongBits(o.begin.low>>>0,o.begin.high>>>0).toNumber():o.begin),o.end!=null&&o.hasOwnProperty("end")&&(typeof o.end=="number"?s.end=i.longs===String?String(o.end):o.end:s.end=i.longs===String?_.Long.prototype.toString.call(o.end):i.longs===Number?new _.LongBits(o.end.low>>>0,o.end.high>>>0).toNumber():o.end),s},r.prototype.toJSON=function(){return this.constructor.toObject(this,He.util.toJSONOptions)},r.getTypeUrl=function(o){return o===void 0&&(o="type.googleapis.com"),o+"/onnx.TensorProto.Segment"},r}(),e.DataLocation=function(){var r={},t=Object.create(r);return t[r[0]="DEFAULT"]=0,t[r[1]="EXTERNAL"]=1,t}(),e}(),n.SparseTensorProto=function(){function e(r){if(this.dims=[],r)for(var t=Object.keys(r),o=0;o<t.length;++o)r[t[o]]!=null&&(this[t[o]]=r[t[o]])}return e.prototype.values=null,e.prototype.indices=null,e.prototype.dims=_.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=tt.create()),t.values!=null&&Object.hasOwnProperty.call(t,"values")&&T.onnx.TensorProto.encode(t.values,o.uint32(10).fork()).ldelim(),t.indices!=null&&Object.hasOwnProperty.call(t,"indices")&&T.onnx.TensorProto.encode(t.indices,o.uint32(18).fork()).ldelim(),t.dims!=null&&t.dims.length){o.uint32(26).fork();for(var i=0;i<t.dims.length;++i)o.int64(t.dims[i]);o.ldelim()}return o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof q||(t=q.create(t));for(var i=o===void 0?t.len:t.pos+o,s=new T.onnx.SparseTensorProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{s.values=T.onnx.TensorProto.decode(t,t.uint32());break}case 2:{s.indices=T.onnx.TensorProto.decode(t,t.uint32());break}case 3:{if(s.dims&&s.dims.length||(s.dims=[]),(a&7)===2)for(var u=t.uint32()+t.pos;t.pos<u;)s.dims.push(t.int64());else s.dims.push(t.int64());break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof q||(t=new q(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.values!=null&&t.hasOwnProperty("values")){var o=T.onnx.TensorProto.verify(t.values);if(o)return"values."+o}if(t.indices!=null&&t.hasOwnProperty("indices")){var o=T.onnx.TensorProto.verify(t.indices);if(o)return"indices."+o}if(t.dims!=null&&t.hasOwnProperty("dims")){if(!Array.isArray(t.dims))return"dims: array expected";for(var i=0;i<t.dims.length;++i)if(!_.isInteger(t.dims[i])&&!(t.dims[i]&&_.isInteger(t.dims[i].low)&&_.isInteger(t.dims[i].high)))return"dims: integer|Long[] expected"}return null},e.fromObject=function(t){if(t instanceof T.onnx.SparseTensorProto)return t;var o=new T.onnx.SparseTensorProto;if(t.values!=null){if(typeof t.values!="object")throw TypeError(".onnx.SparseTensorProto.values: object expected");o.values=T.onnx.TensorProto.fromObject(t.values)}if(t.indices!=null){if(typeof t.indices!="object")throw TypeError(".onnx.SparseTensorProto.indices: object expected");o.indices=T.onnx.TensorProto.fromObject(t.indices)}if(t.dims){if(!Array.isArray(t.dims))throw TypeError(".onnx.SparseTensorProto.dims: array expected");o.dims=[];for(var i=0;i<t.dims.length;++i)_.Long?(o.dims[i]=_.Long.fromValue(t.dims[i])).unsigned=!1:typeof t.dims[i]=="string"?o.dims[i]=parseInt(t.dims[i],10):typeof t.dims[i]=="number"?o.dims[i]=t.dims[i]:typeof t.dims[i]=="object"&&(o.dims[i]=new _.LongBits(t.dims[i].low>>>0,t.dims[i].high>>>0).toNumber())}return o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.dims=[]),o.defaults&&(i.values=null,i.indices=null),t.values!=null&&t.hasOwnProperty("values")&&(i.values=T.onnx.TensorProto.toObject(t.values,o)),t.indices!=null&&t.hasOwnProperty("indices")&&(i.indices=T.onnx.TensorProto.toObject(t.indices,o)),t.dims&&t.dims.length){i.dims=[];for(var s=0;s<t.dims.length;++s)typeof t.dims[s]=="number"?i.dims[s]=o.longs===String?String(t.dims[s]):t.dims[s]:i.dims[s]=o.longs===String?_.Long.prototype.toString.call(t.dims[s]):o.longs===Number?new _.LongBits(t.dims[s].low>>>0,t.dims[s].high>>>0).toNumber():t.dims[s]}return i},e.prototype.toJSON=function(){return this.constructor.toObject(this,He.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.SparseTensorProto"},e}(),n.TensorShapeProto=function(){function e(r){if(this.dim=[],r)for(var t=Object.keys(r),o=0;o<t.length;++o)r[t[o]]!=null&&(this[t[o]]=r[t[o]])}return e.prototype.dim=_.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=tt.create()),t.dim!=null&&t.dim.length)for(var i=0;i<t.dim.length;++i)T.onnx.TensorShapeProto.Dimension.encode(t.dim[i],o.uint32(10).fork()).ldelim();return o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof q||(t=q.create(t));for(var i=o===void 0?t.len:t.pos+o,s=new T.onnx.TensorShapeProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{s.dim&&s.dim.length||(s.dim=[]),s.dim.push(T.onnx.TensorShapeProto.Dimension.decode(t,t.uint32()));break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof q||(t=new q(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.dim!=null&&t.hasOwnProperty("dim")){if(!Array.isArray(t.dim))return"dim: array expected";for(var o=0;o<t.dim.length;++o){var i=T.onnx.TensorShapeProto.Dimension.verify(t.dim[o]);if(i)return"dim."+i}}return null},e.fromObject=function(t){if(t instanceof T.onnx.TensorShapeProto)return t;var o=new T.onnx.TensorShapeProto;if(t.dim){if(!Array.isArray(t.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");o.dim=[];for(var i=0;i<t.dim.length;++i){if(typeof t.dim[i]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");o.dim[i]=T.onnx.TensorShapeProto.Dimension.fromObject(t.dim[i])}}return o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.dim=[]),t.dim&&t.dim.length){i.dim=[];for(var s=0;s<t.dim.length;++s)i.dim[s]=T.onnx.TensorShapeProto.Dimension.toObject(t.dim[s],o)}return i},e.prototype.toJSON=function(){return this.constructor.toObject(this,He.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorShapeProto"},e.Dimension=function(){function r(o){if(o)for(var i=Object.keys(o),s=0;s<i.length;++s)o[i[s]]!=null&&(this[i[s]]=o[i[s]])}r.prototype.dimValue=null,r.prototype.dimParam=null,r.prototype.denotation="";var t;return Object.defineProperty(r.prototype,"value",{get:_.oneOfGetter(t=["dimValue","dimParam"]),set:_.oneOfSetter(t)}),r.create=function(i){return new r(i)},r.encode=function(i,s){return s||(s=tt.create()),i.dimValue!=null&&Object.hasOwnProperty.call(i,"dimValue")&&s.uint32(8).int64(i.dimValue),i.dimParam!=null&&Object.hasOwnProperty.call(i,"dimParam")&&s.uint32(18).string(i.dimParam),i.denotation!=null&&Object.hasOwnProperty.call(i,"denotation")&&s.uint32(26).string(i.denotation),s},r.encodeDelimited=function(i,s){return this.encode(i,s).ldelim()},r.decode=function(i,s){i instanceof q||(i=q.create(i));for(var a=s===void 0?i.len:i.pos+s,u=new T.onnx.TensorShapeProto.Dimension;i.pos<a;){var l=i.uint32();switch(l>>>3){case 1:{u.dimValue=i.int64();break}case 2:{u.dimParam=i.string();break}case 3:{u.denotation=i.string();break}default:i.skipType(l&7);break}}return u},r.decodeDelimited=function(i){return i instanceof q||(i=new q(i)),this.decode(i,i.uint32())},r.verify=function(i){if(typeof i!="object"||i===null)return"object expected";var s={};if(i.dimValue!=null&&i.hasOwnProperty("dimValue")&&(s.value=1,!_.isInteger(i.dimValue)&&!(i.dimValue&&_.isInteger(i.dimValue.low)&&_.isInteger(i.dimValue.high))))return"dimValue: integer|Long expected";if(i.dimParam!=null&&i.hasOwnProperty("dimParam")){if(s.value===1)return"value: multiple values";if(s.value=1,!_.isString(i.dimParam))return"dimParam: string expected"}return i.denotation!=null&&i.hasOwnProperty("denotation")&&!_.isString(i.denotation)?"denotation: string expected":null},r.fromObject=function(i){if(i instanceof T.onnx.TensorShapeProto.Dimension)return i;var s=new T.onnx.TensorShapeProto.Dimension;return i.dimValue!=null&&(_.Long?(s.dimValue=_.Long.fromValue(i.dimValue)).unsigned=!1:typeof i.dimValue=="string"?s.dimValue=parseInt(i.dimValue,10):typeof i.dimValue=="number"?s.dimValue=i.dimValue:typeof i.dimValue=="object"&&(s.dimValue=new _.LongBits(i.dimValue.low>>>0,i.dimValue.high>>>0).toNumber())),i.dimParam!=null&&(s.dimParam=String(i.dimParam)),i.denotation!=null&&(s.denotation=String(i.denotation)),s},r.toObject=function(i,s){s||(s={});var a={};return s.defaults&&(a.denotation=""),i.dimValue!=null&&i.hasOwnProperty("dimValue")&&(typeof i.dimValue=="number"?a.dimValue=s.longs===String?String(i.dimValue):i.dimValue:a.dimValue=s.longs===String?_.Long.prototype.toString.call(i.dimValue):s.longs===Number?new _.LongBits(i.dimValue.low>>>0,i.dimValue.high>>>0).toNumber():i.dimValue,s.oneofs&&(a.value="dimValue")),i.dimParam!=null&&i.hasOwnProperty("dimParam")&&(a.dimParam=i.dimParam,s.oneofs&&(a.value="dimParam")),i.denotation!=null&&i.hasOwnProperty("denotation")&&(a.denotation=i.denotation),a},r.prototype.toJSON=function(){return this.constructor.toObject(this,He.util.toJSONOptions)},r.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TensorShapeProto.Dimension"},r}(),e}(),n.TypeProto=function(){function e(t){if(t)for(var o=Object.keys(t),i=0;i<o.length;++i)t[o[i]]!=null&&(this[o[i]]=t[o[i]])}e.prototype.tensorType=null,e.prototype.sequenceType=null,e.prototype.mapType=null,e.prototype.optionalType=null,e.prototype.sparseTensorType=null,e.prototype.denotation="";var r;return Object.defineProperty(e.prototype,"value",{get:_.oneOfGetter(r=["tensorType","sequenceType","mapType","optionalType","sparseTensorType"]),set:_.oneOfSetter(r)}),e.create=function(o){return new e(o)},e.encode=function(o,i){return i||(i=tt.create()),o.tensorType!=null&&Object.hasOwnProperty.call(o,"tensorType")&&T.onnx.TypeProto.Tensor.encode(o.tensorType,i.uint32(10).fork()).ldelim(),o.sequenceType!=null&&Object.hasOwnProperty.call(o,"sequenceType")&&T.onnx.TypeProto.Sequence.encode(o.sequenceType,i.uint32(34).fork()).ldelim(),o.mapType!=null&&Object.hasOwnProperty.call(o,"mapType")&&T.onnx.TypeProto.Map.encode(o.mapType,i.uint32(42).fork()).ldelim(),o.denotation!=null&&Object.hasOwnProperty.call(o,"denotation")&&i.uint32(50).string(o.denotation),o.sparseTensorType!=null&&Object.hasOwnProperty.call(o,"sparseTensorType")&&T.onnx.TypeProto.SparseTensor.encode(o.sparseTensorType,i.uint32(66).fork()).ldelim(),o.optionalType!=null&&Object.hasOwnProperty.call(o,"optionalType")&&T.onnx.TypeProto.Optional.encode(o.optionalType,i.uint32(74).fork()).ldelim(),i},e.encodeDelimited=function(o,i){return this.encode(o,i).ldelim()},e.decode=function(o,i){o instanceof q||(o=q.create(o));for(var s=i===void 0?o.len:o.pos+i,a=new T.onnx.TypeProto;o.pos<s;){var u=o.uint32();switch(u>>>3){case 1:{a.tensorType=T.onnx.TypeProto.Tensor.decode(o,o.uint32());break}case 4:{a.sequenceType=T.onnx.TypeProto.Sequence.decode(o,o.uint32());break}case 5:{a.mapType=T.onnx.TypeProto.Map.decode(o,o.uint32());break}case 9:{a.optionalType=T.onnx.TypeProto.Optional.decode(o,o.uint32());break}case 8:{a.sparseTensorType=T.onnx.TypeProto.SparseTensor.decode(o,o.uint32());break}case 6:{a.denotation=o.string();break}default:o.skipType(u&7);break}}return a},e.decodeDelimited=function(o){return o instanceof q||(o=new q(o)),this.decode(o,o.uint32())},e.verify=function(o){if(typeof o!="object"||o===null)return"object expected";var i={};if(o.tensorType!=null&&o.hasOwnProperty("tensorType")){i.value=1;{var s=T.onnx.TypeProto.Tensor.verify(o.tensorType);if(s)return"tensorType."+s}}if(o.sequenceType!=null&&o.hasOwnProperty("sequenceType")){if(i.value===1)return"value: multiple values";i.value=1;{var s=T.onnx.TypeProto.Sequence.verify(o.sequenceType);if(s)return"sequenceType."+s}}if(o.mapType!=null&&o.hasOwnProperty("mapType")){if(i.value===1)return"value: multiple values";i.value=1;{var s=T.onnx.TypeProto.Map.verify(o.mapType);if(s)return"mapType."+s}}if(o.optionalType!=null&&o.hasOwnProperty("optionalType")){if(i.value===1)return"value: multiple values";i.value=1;{var s=T.onnx.TypeProto.Optional.verify(o.optionalType);if(s)return"optionalType."+s}}if(o.sparseTensorType!=null&&o.hasOwnProperty("sparseTensorType")){if(i.value===1)return"value: multiple values";i.value=1;{var s=T.onnx.TypeProto.SparseTensor.verify(o.sparseTensorType);if(s)return"sparseTensorType."+s}}return o.denotation!=null&&o.hasOwnProperty("denotation")&&!_.isString(o.denotation)?"denotation: string expected":null},e.fromObject=function(o){if(o instanceof T.onnx.TypeProto)return o;var i=new T.onnx.TypeProto;if(o.tensorType!=null){if(typeof o.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");i.tensorType=T.onnx.TypeProto.Tensor.fromObject(o.tensorType)}if(o.sequenceType!=null){if(typeof o.sequenceType!="object")throw TypeError(".onnx.TypeProto.sequenceType: object expected");i.sequenceType=T.onnx.TypeProto.Sequence.fromObject(o.sequenceType)}if(o.mapType!=null){if(typeof o.mapType!="object")throw TypeError(".onnx.TypeProto.mapType: object expected");i.mapType=T.onnx.TypeProto.Map.fromObject(o.mapType)}if(o.optionalType!=null){if(typeof o.optionalType!="object")throw TypeError(".onnx.TypeProto.optionalType: object expected");i.optionalType=T.onnx.TypeProto.Optional.fromObject(o.optionalType)}if(o.sparseTensorType!=null){if(typeof o.sparseTensorType!="object")throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");i.sparseTensorType=T.onnx.TypeProto.SparseTensor.fromObject(o.sparseTensorType)}return o.denotation!=null&&(i.denotation=String(o.denotation)),i},e.toObject=function(o,i){i||(i={});var s={};return i.defaults&&(s.denotation=""),o.tensorType!=null&&o.hasOwnProperty("tensorType")&&(s.tensorType=T.onnx.TypeProto.Tensor.toObject(o.tensorType,i),i.oneofs&&(s.value="tensorType")),o.sequenceType!=null&&o.hasOwnProperty("sequenceType")&&(s.sequenceType=T.onnx.TypeProto.Sequence.toObject(o.sequenceType,i),i.oneofs&&(s.value="sequenceType")),o.mapType!=null&&o.hasOwnProperty("mapType")&&(s.mapType=T.onnx.TypeProto.Map.toObject(o.mapType,i),i.oneofs&&(s.value="mapType")),o.denotation!=null&&o.hasOwnProperty("denotation")&&(s.denotation=o.denotation),o.sparseTensorType!=null&&o.hasOwnProperty("sparseTensorType")&&(s.sparseTensorType=T.onnx.TypeProto.SparseTensor.toObject(o.sparseTensorType,i),i.oneofs&&(s.value="sparseTensorType")),o.optionalType!=null&&o.hasOwnProperty("optionalType")&&(s.optionalType=T.onnx.TypeProto.Optional.toObject(o.optionalType,i),i.oneofs&&(s.value="optionalType")),s},e.prototype.toJSON=function(){return this.constructor.toObject(this,He.util.toJSONOptions)},e.getTypeUrl=function(o){return o===void 0&&(o="type.googleapis.com"),o+"/onnx.TypeProto"},e.Tensor=function(){function t(o){if(o)for(var i=Object.keys(o),s=0;s<i.length;++s)o[i[s]]!=null&&(this[i[s]]=o[i[s]])}return t.prototype.elemType=0,t.prototype.shape=null,t.create=function(i){return new t(i)},t.encode=function(i,s){return s||(s=tt.create()),i.elemType!=null&&Object.hasOwnProperty.call(i,"elemType")&&s.uint32(8).int32(i.elemType),i.shape!=null&&Object.hasOwnProperty.call(i,"shape")&&T.onnx.TensorShapeProto.encode(i.shape,s.uint32(18).fork()).ldelim(),s},t.encodeDelimited=function(i,s){return this.encode(i,s).ldelim()},t.decode=function(i,s){i instanceof q||(i=q.create(i));for(var a=s===void 0?i.len:i.pos+s,u=new T.onnx.TypeProto.Tensor;i.pos<a;){var l=i.uint32();switch(l>>>3){case 1:{u.elemType=i.int32();break}case 2:{u.shape=T.onnx.TensorShapeProto.decode(i,i.uint32());break}default:i.skipType(l&7);break}}return u},t.decodeDelimited=function(i){return i instanceof q||(i=new q(i)),this.decode(i,i.uint32())},t.verify=function(i){if(typeof i!="object"||i===null)return"object expected";if(i.elemType!=null&&i.hasOwnProperty("elemType")&&!_.isInteger(i.elemType))return"elemType: integer expected";if(i.shape!=null&&i.hasOwnProperty("shape")){var s=T.onnx.TensorShapeProto.verify(i.shape);if(s)return"shape."+s}return null},t.fromObject=function(i){if(i instanceof T.onnx.TypeProto.Tensor)return i;var s=new T.onnx.TypeProto.Tensor;if(i.elemType!=null&&(s.elemType=i.elemType|0),i.shape!=null){if(typeof i.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");s.shape=T.onnx.TensorShapeProto.fromObject(i.shape)}return s},t.toObject=function(i,s){s||(s={});var a={};return s.defaults&&(a.elemType=0,a.shape=null),i.elemType!=null&&i.hasOwnProperty("elemType")&&(a.elemType=i.elemType),i.shape!=null&&i.hasOwnProperty("shape")&&(a.shape=T.onnx.TensorShapeProto.toObject(i.shape,s)),a},t.prototype.toJSON=function(){return this.constructor.toObject(this,He.util.toJSONOptions)},t.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TypeProto.Tensor"},t}(),e.Sequence=function(){function t(o){if(o)for(var i=Object.keys(o),s=0;s<i.length;++s)o[i[s]]!=null&&(this[i[s]]=o[i[s]])}return t.prototype.elemType=null,t.create=function(i){return new t(i)},t.encode=function(i,s){return s||(s=tt.create()),i.elemType!=null&&Object.hasOwnProperty.call(i,"elemType")&&T.onnx.TypeProto.encode(i.elemType,s.uint32(10).fork()).ldelim(),s},t.encodeDelimited=function(i,s){return this.encode(i,s).ldelim()},t.decode=function(i,s){i instanceof q||(i=q.create(i));for(var a=s===void 0?i.len:i.pos+s,u=new T.onnx.TypeProto.Sequence;i.pos<a;){var l=i.uint32();switch(l>>>3){case 1:{u.elemType=T.onnx.TypeProto.decode(i,i.uint32());break}default:i.skipType(l&7);break}}return u},t.decodeDelimited=function(i){return i instanceof q||(i=new q(i)),this.decode(i,i.uint32())},t.verify=function(i){if(typeof i!="object"||i===null)return"object expected";if(i.elemType!=null&&i.hasOwnProperty("elemType")){var s=T.onnx.TypeProto.verify(i.elemType);if(s)return"elemType."+s}return null},t.fromObject=function(i){if(i instanceof T.onnx.TypeProto.Sequence)return i;var s=new T.onnx.TypeProto.Sequence;if(i.elemType!=null){if(typeof i.elemType!="object")throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");s.elemType=T.onnx.TypeProto.fromObject(i.elemType)}return s},t.toObject=function(i,s){s||(s={});var a={};return s.defaults&&(a.elemType=null),i.elemType!=null&&i.hasOwnProperty("elemType")&&(a.elemType=T.onnx.TypeProto.toObject(i.elemType,s)),a},t.prototype.toJSON=function(){return this.constructor.toObject(this,He.util.toJSONOptions)},t.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TypeProto.Sequence"},t}(),e.Map=function(){function t(o){if(o)for(var i=Object.keys(o),s=0;s<i.length;++s)o[i[s]]!=null&&(this[i[s]]=o[i[s]])}return t.prototype.keyType=0,t.prototype.valueType=null,t.create=function(i){return new t(i)},t.encode=function(i,s){return s||(s=tt.create()),i.keyType!=null&&Object.hasOwnProperty.call(i,"keyType")&&s.uint32(8).int32(i.keyType),i.valueType!=null&&Object.hasOwnProperty.call(i,"valueType")&&T.onnx.TypeProto.encode(i.valueType,s.uint32(18).fork()).ldelim(),s},t.encodeDelimited=function(i,s){return this.encode(i,s).ldelim()},t.decode=function(i,s){i instanceof q||(i=q.create(i));for(var a=s===void 0?i.len:i.pos+s,u=new T.onnx.TypeProto.Map;i.pos<a;){var l=i.uint32();switch(l>>>3){case 1:{u.keyType=i.int32();break}case 2:{u.valueType=T.onnx.TypeProto.decode(i,i.uint32());break}default:i.skipType(l&7);break}}return u},t.decodeDelimited=function(i){return i instanceof q||(i=new q(i)),this.decode(i,i.uint32())},t.verify=function(i){if(typeof i!="object"||i===null)return"object expected";if(i.keyType!=null&&i.hasOwnProperty("keyType")&&!_.isInteger(i.keyType))return"keyType: integer expected";if(i.valueType!=null&&i.hasOwnProperty("valueType")){var s=T.onnx.TypeProto.verify(i.valueType);if(s)return"valueType."+s}return null},t.fromObject=function(i){if(i instanceof T.onnx.TypeProto.Map)return i;var s=new T.onnx.TypeProto.Map;if(i.keyType!=null&&(s.keyType=i.keyType|0),i.valueType!=null){if(typeof i.valueType!="object")throw TypeError(".onnx.TypeProto.Map.valueType: object expected");s.valueType=T.onnx.TypeProto.fromObject(i.valueType)}return s},t.toObject=function(i,s){s||(s={});var a={};return s.defaults&&(a.keyType=0,a.valueType=null),i.keyType!=null&&i.hasOwnProperty("keyType")&&(a.keyType=i.keyType),i.valueType!=null&&i.hasOwnProperty("valueType")&&(a.valueType=T.onnx.TypeProto.toObject(i.valueType,s)),a},t.prototype.toJSON=function(){return this.constructor.toObject(this,He.util.toJSONOptions)},t.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TypeProto.Map"},t}(),e.Optional=function(){function t(o){if(o)for(var i=Object.keys(o),s=0;s<i.length;++s)o[i[s]]!=null&&(this[i[s]]=o[i[s]])}return t.prototype.elemType=null,t.create=function(i){return new t(i)},t.encode=function(i,s){return s||(s=tt.create()),i.elemType!=null&&Object.hasOwnProperty.call(i,"elemType")&&T.onnx.TypeProto.encode(i.elemType,s.uint32(10).fork()).ldelim(),s},t.encodeDelimited=function(i,s){return this.encode(i,s).ldelim()},t.decode=function(i,s){i instanceof q||(i=q.create(i));for(var a=s===void 0?i.len:i.pos+s,u=new T.onnx.TypeProto.Optional;i.pos<a;){var l=i.uint32();switch(l>>>3){case 1:{u.elemType=T.onnx.TypeProto.decode(i,i.uint32());break}default:i.skipType(l&7);break}}return u},t.decodeDelimited=function(i){return i instanceof q||(i=new q(i)),this.decode(i,i.uint32())},t.verify=function(i){if(typeof i!="object"||i===null)return"object expected";if(i.elemType!=null&&i.hasOwnProperty("elemType")){var s=T.onnx.TypeProto.verify(i.elemType);if(s)return"elemType."+s}return null},t.fromObject=function(i){if(i instanceof T.onnx.TypeProto.Optional)return i;var s=new T.onnx.TypeProto.Optional;if(i.elemType!=null){if(typeof i.elemType!="object")throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");s.elemType=T.onnx.TypeProto.fromObject(i.elemType)}return s},t.toObject=function(i,s){s||(s={});var a={};return s.defaults&&(a.elemType=null),i.elemType!=null&&i.hasOwnProperty("elemType")&&(a.elemType=T.onnx.TypeProto.toObject(i.elemType,s)),a},t.prototype.toJSON=function(){return this.constructor.toObject(this,He.util.toJSONOptions)},t.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TypeProto.Optional"},t}(),e.SparseTensor=function(){function t(o){if(o)for(var i=Object.keys(o),s=0;s<i.length;++s)o[i[s]]!=null&&(this[i[s]]=o[i[s]])}return t.prototype.elemType=0,t.prototype.shape=null,t.create=function(i){return new t(i)},t.encode=function(i,s){return s||(s=tt.create()),i.elemType!=null&&Object.hasOwnProperty.call(i,"elemType")&&s.uint32(8).int32(i.elemType),i.shape!=null&&Object.hasOwnProperty.call(i,"shape")&&T.onnx.TensorShapeProto.encode(i.shape,s.uint32(18).fork()).ldelim(),s},t.encodeDelimited=function(i,s){return this.encode(i,s).ldelim()},t.decode=function(i,s){i instanceof q||(i=q.create(i));for(var a=s===void 0?i.len:i.pos+s,u=new T.onnx.TypeProto.SparseTensor;i.pos<a;){var l=i.uint32();switch(l>>>3){case 1:{u.elemType=i.int32();break}case 2:{u.shape=T.onnx.TensorShapeProto.decode(i,i.uint32());break}default:i.skipType(l&7);break}}return u},t.decodeDelimited=function(i){return i instanceof q||(i=new q(i)),this.decode(i,i.uint32())},t.verify=function(i){if(typeof i!="object"||i===null)return"object expected";if(i.elemType!=null&&i.hasOwnProperty("elemType")&&!_.isInteger(i.elemType))return"elemType: integer expected";if(i.shape!=null&&i.hasOwnProperty("shape")){var s=T.onnx.TensorShapeProto.verify(i.shape);if(s)return"shape."+s}return null},t.fromObject=function(i){if(i instanceof T.onnx.TypeProto.SparseTensor)return i;var s=new T.onnx.TypeProto.SparseTensor;if(i.elemType!=null&&(s.elemType=i.elemType|0),i.shape!=null){if(typeof i.shape!="object")throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");s.shape=T.onnx.TensorShapeProto.fromObject(i.shape)}return s},t.toObject=function(i,s){s||(s={});var a={};return s.defaults&&(a.elemType=0,a.shape=null),i.elemType!=null&&i.hasOwnProperty("elemType")&&(a.elemType=i.elemType),i.shape!=null&&i.hasOwnProperty("shape")&&(a.shape=T.onnx.TensorShapeProto.toObject(i.shape,s)),a},t.prototype.toJSON=function(){return this.constructor.toObject(this,He.util.toJSONOptions)},t.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TypeProto.SparseTensor"},t}(),e}(),n.OperatorSetIdProto=function(){function e(r){if(r)for(var t=Object.keys(r),o=0;o<t.length;++o)r[t[o]]!=null&&(this[t[o]]=r[t[o]])}return e.prototype.domain="",e.prototype.version=_.Long?_.Long.fromBits(0,0,!1):0,e.create=function(t){return new e(t)},e.encode=function(t,o){return o||(o=tt.create()),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&o.uint32(10).string(t.domain),t.version!=null&&Object.hasOwnProperty.call(t,"version")&&o.uint32(16).int64(t.version),o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof q||(t=q.create(t));for(var i=o===void 0?t.len:t.pos+o,s=new T.onnx.OperatorSetIdProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{s.domain=t.string();break}case 2:{s.version=t.int64();break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof q||(t=new q(t)),this.decode(t,t.uint32())},e.verify=function(t){return typeof t!="object"||t===null?"object expected":t.domain!=null&&t.hasOwnProperty("domain")&&!_.isString(t.domain)?"domain: string expected":t.version!=null&&t.hasOwnProperty("version")&&!_.isInteger(t.version)&&!(t.version&&_.isInteger(t.version.low)&&_.isInteger(t.version.high))?"version: integer|Long expected":null},e.fromObject=function(t){if(t instanceof T.onnx.OperatorSetIdProto)return t;var o=new T.onnx.OperatorSetIdProto;return t.domain!=null&&(o.domain=String(t.domain)),t.version!=null&&(_.Long?(o.version=_.Long.fromValue(t.version)).unsigned=!1:typeof t.version=="string"?o.version=parseInt(t.version,10):typeof t.version=="number"?o.version=t.version:typeof t.version=="object"&&(o.version=new _.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber())),o},e.toObject=function(t,o){o||(o={});var i={};if(o.defaults)if(i.domain="",_.Long){var s=new _.Long(0,0,!1);i.version=o.longs===String?s.toString():o.longs===Number?s.toNumber():s}else i.version=o.longs===String?"0":0;return t.domain!=null&&t.hasOwnProperty("domain")&&(i.domain=t.domain),t.version!=null&&t.hasOwnProperty("version")&&(typeof t.version=="number"?i.version=o.longs===String?String(t.version):t.version:i.version=o.longs===String?_.Long.prototype.toString.call(t.version):o.longs===Number?new _.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber():t.version),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,He.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.OperatorSetIdProto"},e}(),n.OperatorStatus=function(){var e={},r=Object.create(e);return r[e[0]="EXPERIMENTAL"]=0,r[e[1]="STABLE"]=1,r}(),n.FunctionProto=function(){function e(r){if(this.input=[],this.output=[],this.attribute=[],this.attributeProto=[],this.node=[],this.opsetImport=[],r)for(var t=Object.keys(r),o=0;o<t.length;++o)r[t[o]]!=null&&(this[t[o]]=r[t[o]])}return e.prototype.name="",e.prototype.input=_.emptyArray,e.prototype.output=_.emptyArray,e.prototype.attribute=_.emptyArray,e.prototype.attributeProto=_.emptyArray,e.prototype.node=_.emptyArray,e.prototype.docString="",e.prototype.opsetImport=_.emptyArray,e.prototype.domain="",e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=tt.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&o.uint32(10).string(t.name),t.input!=null&&t.input.length)for(var i=0;i<t.input.length;++i)o.uint32(34).string(t.input[i]);if(t.output!=null&&t.output.length)for(var i=0;i<t.output.length;++i)o.uint32(42).string(t.output[i]);if(t.attribute!=null&&t.attribute.length)for(var i=0;i<t.attribute.length;++i)o.uint32(50).string(t.attribute[i]);if(t.node!=null&&t.node.length)for(var i=0;i<t.node.length;++i)T.onnx.NodeProto.encode(t.node[i],o.uint32(58).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&o.uint32(66).string(t.docString),t.opsetImport!=null&&t.opsetImport.length)for(var i=0;i<t.opsetImport.length;++i)T.onnx.OperatorSetIdProto.encode(t.opsetImport[i],o.uint32(74).fork()).ldelim();if(t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&o.uint32(82).string(t.domain),t.attributeProto!=null&&t.attributeProto.length)for(var i=0;i<t.attributeProto.length;++i)T.onnx.AttributeProto.encode(t.attributeProto[i],o.uint32(90).fork()).ldelim();return o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof q||(t=q.create(t));for(var i=o===void 0?t.len:t.pos+o,s=new T.onnx.FunctionProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{s.name=t.string();break}case 4:{s.input&&s.input.length||(s.input=[]),s.input.push(t.string());break}case 5:{s.output&&s.output.length||(s.output=[]),s.output.push(t.string());break}case 6:{s.attribute&&s.attribute.length||(s.attribute=[]),s.attribute.push(t.string());break}case 11:{s.attributeProto&&s.attributeProto.length||(s.attributeProto=[]),s.attributeProto.push(T.onnx.AttributeProto.decode(t,t.uint32()));break}case 7:{s.node&&s.node.length||(s.node=[]),s.node.push(T.onnx.NodeProto.decode(t,t.uint32()));break}case 8:{s.docString=t.string();break}case 9:{s.opsetImport&&s.opsetImport.length||(s.opsetImport=[]),s.opsetImport.push(T.onnx.OperatorSetIdProto.decode(t,t.uint32()));break}case 10:{s.domain=t.string();break}default:t.skipType(a&7);break}}return s},e.decodeDelimited=function(t){return t instanceof q||(t=new q(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!_.isString(t.name))return"name: string expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var o=0;o<t.input.length;++o)if(!_.isString(t.input[o]))return"input: string[] expected"}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(var o=0;o<t.output.length;++o)if(!_.isString(t.output[o]))return"output: string[] expected"}if(t.attribute!=null&&t.hasOwnProperty("attribute")){if(!Array.isArray(t.attribute))return"attribute: array expected";for(var o=0;o<t.attribute.length;++o)if(!_.isString(t.attribute[o]))return"attribute: string[] expected"}if(t.attributeProto!=null&&t.hasOwnProperty("attributeProto")){if(!Array.isArray(t.attributeProto))return"attributeProto: array expected";for(var o=0;o<t.attributeProto.length;++o){var i=T.onnx.AttributeProto.verify(t.attributeProto[o]);if(i)return"attributeProto."+i}}if(t.node!=null&&t.hasOwnProperty("node")){if(!Array.isArray(t.node))return"node: array expected";for(var o=0;o<t.node.length;++o){var i=T.onnx.NodeProto.verify(t.node[o]);if(i)return"node."+i}}if(t.docString!=null&&t.hasOwnProperty("docString")&&!_.isString(t.docString))return"docString: string expected";if(t.opsetImport!=null&&t.hasOwnProperty("opsetImport")){if(!Array.isArray(t.opsetImport))return"opsetImport: array expected";for(var o=0;o<t.opsetImport.length;++o){var i=T.onnx.OperatorSetIdProto.verify(t.opsetImport[o]);if(i)return"opsetImport."+i}}return t.domain!=null&&t.hasOwnProperty("domain")&&!_.isString(t.domain)?"domain: string expected":null},e.fromObject=function(t){if(t instanceof T.onnx.FunctionProto)return t;var o=new T.onnx.FunctionProto;if(t.name!=null&&(o.name=String(t.name)),t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.FunctionProto.input: array expected");o.input=[];for(var i=0;i<t.input.length;++i)o.input[i]=String(t.input[i])}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.FunctionProto.output: array expected");o.output=[];for(var i=0;i<t.output.length;++i)o.output[i]=String(t.output[i])}if(t.attribute){if(!Array.isArray(t.attribute))throw TypeError(".onnx.FunctionProto.attribute: array expected");o.attribute=[];for(var i=0;i<t.attribute.length;++i)o.attribute[i]=String(t.attribute[i])}if(t.attributeProto){if(!Array.isArray(t.attributeProto))throw TypeError(".onnx.FunctionProto.attributeProto: array expected");o.attributeProto=[];for(var i=0;i<t.attributeProto.length;++i){if(typeof t.attributeProto[i]!="object")throw TypeError(".onnx.FunctionProto.attributeProto: object expected");o.attributeProto[i]=T.onnx.AttributeProto.fromObject(t.attributeProto[i])}}if(t.node){if(!Array.isArray(t.node))throw TypeError(".onnx.FunctionProto.node: array expected");o.node=[];for(var i=0;i<t.node.length;++i){if(typeof t.node[i]!="object")throw TypeError(".onnx.FunctionProto.node: object expected");o.node[i]=T.onnx.NodeProto.fromObject(t.node[i])}}if(t.docString!=null&&(o.docString=String(t.docString)),t.opsetImport){if(!Array.isArray(t.opsetImport))throw TypeError(".onnx.FunctionProto.opsetImport: array expected");o.opsetImport=[];for(var i=0;i<t.opsetImport.length;++i){if(typeof t.opsetImport[i]!="object")throw TypeError(".onnx.FunctionProto.opsetImport: object expected");o.opsetImport[i]=T.onnx.OperatorSetIdProto.fromObject(t.opsetImport[i])}}return t.domain!=null&&(o.domain=String(t.domain)),o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.input=[],i.output=[],i.attribute=[],i.node=[],i.opsetImport=[],i.attributeProto=[]),o.defaults&&(i.name="",i.docString="",i.domain=""),t.name!=null&&t.hasOwnProperty("name")&&(i.name=t.name),t.input&&t.input.length){i.input=[];for(var s=0;s<t.input.length;++s)i.input[s]=t.input[s]}if(t.output&&t.output.length){i.output=[];for(var s=0;s<t.output.length;++s)i.output[s]=t.output[s]}if(t.attribute&&t.attribute.length){i.attribute=[];for(var s=0;s<t.attribute.length;++s)i.attribute[s]=t.attribute[s]}if(t.node&&t.node.length){i.node=[];for(var s=0;s<t.node.length;++s)i.node[s]=T.onnx.NodeProto.toObject(t.node[s],o)}if(t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),t.opsetImport&&t.opsetImport.length){i.opsetImport=[];for(var s=0;s<t.opsetImport.length;++s)i.opsetImport[s]=T.onnx.OperatorSetIdProto.toObject(t.opsetImport[s],o)}if(t.domain!=null&&t.hasOwnProperty("domain")&&(i.domain=t.domain),t.attributeProto&&t.attributeProto.length){i.attributeProto=[];for(var s=0;s<t.attributeProto.length;++s)i.attributeProto[s]=T.onnx.AttributeProto.toObject(t.attributeProto[s],o)}return i},e.prototype.toJSON=function(){return this.constructor.toObject(this,He.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.FunctionProto"},e}(),n}();sc.exports=T});function pn(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function Kn(n){return new TextDecoder().decode(n)}var je,Gr,Aa,vt,Uo,pt,St,Q,qn,Wr,Vr,Ur,Me=k(()=>{"use strict";Fo();pa();je=un(fn());Hr();Gr=class{static arraysEqual(e,r){if(e.length!==r.length)return!1;for(let t=0;t<e.length;t++)if(e[t]!==r[t])return!1;return!0}},Aa=class{static preprocessInputShapes(e,r){let t=e.length===1?[1,e[0]]:e,o=r.length===1?[r[0],1]:r;return[t,o]}static postprocessOutputShape(e,r,t){r===1&&e.splice(e.length-2,1),t===1&&e.pop()}static calcMatMulShape(e,r){return e[1]!==r[0]?void 0:[e[0],r[1]]}},vt=class n{static calcShape(e,r,t=!1){let o=e.length,i=r.length;if(o===0)return r;if(i===0)return e;let s=Math.max(e.length,r.length),a=new Array(s);if(t){if(o<2||i<2)return;let u=Aa.calcMatMulShape([e[o-2],e[o-1]],[r[i-2],r[i-1]]);if(u===void 0)return;[a[s-2],a[s-1]]=u}for(let u=t?3:1;u<=s;u++){let l=o-u<0?1:e[o-u],d=i-u<0?1:r[i-u];if(l!==d&&l>1&&d>1)return;a[s-u]=Math.max(l,d)}return a}static index(e,r){let t=new Array(r.length);return n.fillIndex(e,r,t),t}static fillIndex(e,r,t){let o=e.length-r.length;for(let i=0;i<r.length;i++)t[i]=e[o+i]%r[i]}static calc(e,r,t,o,i){let s=n.calcShape(e.dims,r.dims);if(s){if(o&&!Q.areEqual(s,e.dims))return;let a=Q.size(s),u=o?e:new at(s,i||e.type);if(s.length===0)u.set([],t(e.get([]),r.get([])));else{let l=new Array(s.length),d=new Array(e.dims.length),p=new Array(r.dims.length),h=0,g=0,y=!1,b=!1;e.dims.length===0&&(h=e.get([]),y=!0),r.dims.length===0&&(g=r.get([]),b=!0);let w;for(let I=0;I<a;I++){w=I;for(let O=s.length-1;O>=0;O--)l[O]=w%s[O],w=Math.floor(w/s[O]);y||(n.fillIndex(l,e.dims,d),h=e.get(d)),b||(n.fillIndex(l,r.dims,p),g=r.get(p)),u.set(l,t(h,g))}}return u}}static isValidBroadcast(e,r){let t=e.length,o=r.length;if(t>o)return!1;for(let i=1;i<=t;i++)if(e[t-i]!==1&&e[t-i]!==r[o-i])return!1;return!0}static getBroadcastDims(e,r){let t=e.length,o=[];for(let i=0;i<t;i++){let s=t-1-i,a=e[s]||1;(r[r.length-1-i]||1)>1&&a===1&&o.unshift(s)}return o}},Uo=class{static getShapeOfGemmResult(e,r,t,o,i){if(e.length!==2||t.length!==2)throw new Error("shape need to be of size 2");let s,a,u;r?(s=e[1],a=e[0]):(s=e[0],a=e[1]);let l=-1;if(o?(u=t[0],l=1):(u=t[1],l=0),t[l]!==a)throw new Error("dimension mismatch");if(s<=0||u<=0||a<=0)throw new Error("invalid shape specified");if(i&&!vt.isValidBroadcast(i,[s,u]))throw new Error("gemm: invalid bias shape for broadcast");return[s,u,a]}},pt=class n{static tensorDataTypeFromProto(e){switch(e){case je.onnx.TensorProto.DataType.INT8:return"int8";case je.onnx.TensorProto.DataType.UINT8:return"uint8";case je.onnx.TensorProto.DataType.BOOL:return"bool";case je.onnx.TensorProto.DataType.INT16:return"int16";case je.onnx.TensorProto.DataType.UINT16:return"uint16";case je.onnx.TensorProto.DataType.INT32:return"int32";case je.onnx.TensorProto.DataType.UINT32:return"uint32";case je.onnx.TensorProto.DataType.FLOAT:return"float32";case je.onnx.TensorProto.DataType.DOUBLE:return"float64";case je.onnx.TensorProto.DataType.STRING:return"string";case je.onnx.TensorProto.DataType.INT64:return"int32";case je.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${je.onnx.TensorProto.DataType[e]}`)}}static tensorDataTypeStringToEnum(e){switch(e){case"int8":return je.onnx.TensorProto.DataType.INT8;case"uint8":return je.onnx.TensorProto.DataType.UINT8;case"bool":return je.onnx.TensorProto.DataType.BOOL;case"int16":return je.onnx.TensorProto.DataType.INT16;case"uint16":return je.onnx.TensorProto.DataType.UINT16;case"int32":return je.onnx.TensorProto.DataType.INT32;case"uint32":return je.onnx.TensorProto.DataType.UINT32;case"float32":return je.onnx.TensorProto.DataType.FLOAT;case"float64":return je.onnx.TensorProto.DataType.DOUBLE;case"string":return je.onnx.TensorProto.DataType.STRING;case"int64":return je.onnx.TensorProto.DataType.INT64;case"uint64":return je.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${e}`)}}static tensorDimsFromProto(e){return e.map(r=>mr.isLong(r)?r.toNumber():r)}static tensorValueTypeFromProto(e){return{tensorType:n.tensorDataTypeFromProto(e.elemType),shape:{dims:n.tensorDimsFromProto(e.shape.dim.map(r=>r.dimValue))}}}static tensorDimsFromORTFormat(e){let r=[];for(let t=0;t<e.dimsLength();t++)r.push(St.longToNumber(e.dims(t)));return r}static tensorAttributesFromORTFormat(e){let r=[];for(let t=0;t<e.attributesLength();t++)r.push(e.attributes(t));return r}},St=class{static longToNumber(e,r){return mr.isLong(e)?e.toNumber():e instanceof C.Long?mr.fromValue({low:e.low,high:e.high,unsigned:r??!1}).toNumber():e}static isLong(e){return mr.isLong(e)||e instanceof C.Long}},Q=class n{static size(e){return n.getSizeFromDimensionRange(e,0,e.length)}static sizeFromDimension(e,r){if(r<0||r>e.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return n.getSizeFromDimensionRange(e,r,e.length)}static sizeToDimension(e,r){if(r<0||r>e.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${e.length} dimensions.`);return n.getSizeFromDimensionRange(e,0,r)}static getSizeFromDimensionRange(e,r,t){let o=1;for(let i=r;i<t;i++){if(e[i]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");o*=e[i]}return o}static computeStrides(e){let r=e.length;if(r===0)return[];if(r===1)return[1];let t=new Array(r);t[r-1]=1,t[r-2]=e[r-1];for(let o=r-3;o>=0;--o)t[o]=t[o+1]*e[o+1];return t}static transpose(e){return e.slice().reverse()}static indicesToOffset(e,r,t){t===void 0&&(t=e.length);let o=0;for(let i=0;i<t;++i)o+=r[i]*e[i];return o}static offsetToIndices(e,r){let t=r.length;if(t===0)return[];if(t===1)return[e*r[0]];let o=new Array(r.length);for(let i=0;i<o.length-1;++i)o[i]=Math.floor(e/r[i]),e-=o[i]*r[i];return o[o.length-1]=e,o}static normalizeAxis(e,r){if(e<-r&&e>=r)throw new Error("unsupported axis for this operation.");return e<0?e+r:e}static normalizeAxes(e,r){return e.map(t=>this.normalizeAxis(t,r))}static incrementIndex(e,r,t){if(r.length===0||e.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(t===void 0)t=r.length;else if(t<=0||t>r.length)throw new Error("Incorrect axis to increment on");for(let o=t-1;o>=0&&(e[o]++,!(e[o]<r[o]));--o)e[o]=0}static calculateReshapedDims(e,r){if(r.length===0){if(e.length===0||n.size(e)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}let t=r.length,o=new Array(t),i=-1,s=1;for(let u=0;u<t;u++){if(r[u]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(r[u]===-1){if(i!==-1)throw new Error("at most one dimension in shape hints can be -1");i=u}else{if(r[u]===0){if(u>=e.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");o[u]=e[u]}else o[u]=r[u];s*=o[u]}}let a=n.size(e);if(i!==-1){if(a%s!==0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${e}] Output shape: [${r}]`);o[i]=a/s}else if(s!==a)throw new Error("reshapedDims and originalDims don't have matching sizes");return o}static sortBasedOnPerm(e,r){return r?r.map(t=>e[t]):e.slice().reverse()}static padShape(e,r){let t=e.length;return e.map((o,i)=>o+r[i]+r[i+t])}static areEqual(e,r){return e.length!==r.length?!1:e.every((t,o)=>t===r[o])}static validateDimsAndCalcSize(e){if(e.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let r=1;for(let t of e){if(!Number.isInteger(t))throw new TypeError(`Invalid shape: ${t} is not an integer`);if(t<0||t>2147483647)throw new TypeError(`Invalid shape: length ${t} is not allowed`);r*=t}return r}static flattenShape(e,r){r<0&&(r+=e.length);let t=e.reduce((s,a)=>s*a,1),o=e.slice(r).reduce((s,a)=>s*a,1);return[t/o,o]}static squeezeShape(e,r){let t=new Array;r=n.normalizeAxes(r,e.length);for(let o=0;o<e.length;o++){let i=r.indexOf(o)>=0;if(i&&e[o]!==1)throw new Error("squeeze an axis of size different than 1");(r.length===0&&e[o]>1||r.length>0&&!i)&&t.push(e[o])}return t}static unsqueezeShape(e,r){let t=new Array(e.length+r.length);t.fill(0);for(let i=0;i<r.length;i++){let s=n.normalizeAxis(r[i],t.length);if(s>=t.length)throw new Error("'axes' has an out of range axis");if(t[s]!==0)throw new Error("'axes' has a duplicate axis");t[s]=1}let o=0;for(let i=0;i<t.length;i++)t[i]===0&&(t[i]=e[o++]);if(o!==e.length)throw new Error("the unsqueezed dimension could not be established");return t}},qn=class n{static splitShape(e,r,t,o){if(t.length===0){if(!o)throw new Error("need to know number of outputs when the 'split' attribute is not specified");n.determineSplit(e[r],o,t)}let i=[],s=[0];for(let a=0;a<t.length;++a){a!==0&&s.push(s[a-1]+t[a-1]);let u=e.slice();u[r]=t[a],i.push(u)}return[i,s]}static determineSplit(e,r,t){if(e%r!==0)throw new Error("cannot split tensor to equal sized parts");for(let o=0;o<r;++o)t.push(e/r)}},Wr=class n{static adjustPoolAttributes(e,r,t,o,i,s){if(!e&&t.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let a=0;a<r.length-2;a++)a>=t.length?t.push(r[a+2]):t[a]=r[a+2];for(let a=0;a<t.length;a++)if(a<o.length){if(o[a]<0)throw new Error("strides should be greater than or equal to 1")}else o.push(1);for(let a=0;a<t.length;a++)if(a<i.length){if(i[a]<0)throw new Error("dilations should be greater than or equal to 1")}else i.push(1);for(let a=0;a<t.length*2;a++)if(a<s.length){if(s[a]<0)throw new Error("pad should be greater than or equal to 1")}else s.push(0);for(let a=0;a<t.length;a++){if(t[a]<=0)throw new Error("kernel shapes need to be greater than 0");if(s[a]>=t[a]||s[a+t.length]>=t[a])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,r,t,o,i,s){if(s){if(i.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(o.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let a=0;a<e.length-2;a++)n.adjustPadAndReturnShape(e[a+2],r[a],t[a],o[a],i,a,a+e.length-2,s)}}static computePoolOutputShape(e,r,t,o,i,s,a){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let u=[r[0],r[1]];return n.computeShapeHelper(e,r,u,t,o,i,s,a),u}static computeConvOutputShape(e,r,t,o,i,s,a){if(e.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let u=[e[0],r[0]];return n.computeShapeHelper(!1,e,u,t,o,i,s,a),u}static computeShapeHelper(e,r,t,o,i,s,a,u){if(e)for(let l=0;l<r.length-2;l++)t.push(1);else for(let l=0;l<r.length-2;l++)t.push(n.adjustPadAndReturnShape(r[l+2],o[l],i[l],s[l],a,l,l+r.length-2,u))}static adjustPadAndReturnShape(e,r,t,o,i,s,a,u){let l=t*(o-1)+1;if(u&&u!=="NOTSET")switch(u){case"VALID":return i[s]=0,i[a]=0,Math.floor((e-l)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(t!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let p=((e+r-1)/r-1)*r+o-e;return i[s]=Math.floor(u==="SAME_LOWER"?(p+1)/2:p/2),i[a]=p-i[s],Math.floor((e+p-o)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((e+i[s]+i[a]-l)/r+1)}},Vr=-34028234663852886e22,Ur=34028234663852886e22});function Ty(n){switch(n){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${n}`)}}function uc(n){switch(n){case $e.onnx.TensorProto.DataType.UINT8:case $e.onnx.TensorProto.DataType.INT8:case $e.onnx.TensorProto.DataType.BOOL:return 1;case $e.onnx.TensorProto.DataType.UINT16:case $e.onnx.TensorProto.DataType.INT16:return 2;case $e.onnx.TensorProto.DataType.FLOAT:case $e.onnx.TensorProto.DataType.INT32:case $e.onnx.TensorProto.DataType.UINT32:return 4;case $e.onnx.TensorProto.DataType.INT64:case $e.onnx.TensorProto.DataType.DOUBLE:case $e.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${$e.onnx.TensorProto.DataType[n]}`)}}function $y(n,e){return new(dc(e))(n)}function dc(n){switch(n){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function Ea(n,e){if(e===$e.onnx.TensorProto.DataType.INT64||e===Oa.TensorDataType.INT64){if(n.greaterThanOrEqual(2147483648)||n.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else if(e===$e.onnx.TensorProto.DataType.UINT32||e===Oa.TensorDataType.UINT32||e===$e.onnx.TensorProto.DataType.UINT64||e===Oa.TensorDataType.UINT64){if(n.greaterThanOrEqual(4294967296)||n.lessThan(0))throw new TypeError("uint64 is not supported")}else throw new TypeError(`not a LONG type: ${$e.onnx.TensorProto.DataType[e]}`);return n.toNumber()}function lc(n,e,r){switch(e){case $e.onnx.TensorProto.DataType.BOOL:case $e.onnx.TensorProto.DataType.UINT8:return n.getUint8(r);case $e.onnx.TensorProto.DataType.INT8:return n.getInt8(r);case $e.onnx.TensorProto.DataType.UINT16:return n.getUint16(r,!0);case $e.onnx.TensorProto.DataType.INT16:return n.getInt16(r,!0);case $e.onnx.TensorProto.DataType.FLOAT:return n.getFloat32(r,!0);case $e.onnx.TensorProto.DataType.INT32:return n.getInt32(r,!0);case $e.onnx.TensorProto.DataType.UINT32:return n.getUint32(r,!0);case $e.onnx.TensorProto.DataType.INT64:return Ea(mr.fromBits(n.getUint32(r,!0),n.getUint32(r+4,!0),!1),e);case $e.onnx.TensorProto.DataType.DOUBLE:return n.getFloat64(r,!0);case $e.onnx.TensorProto.DataType.UINT64:return Ea(mr.fromBits(n.getUint32(r,!0),n.getUint32(r+4,!0),!0),e);default:throw new Error(`cannot read from DataView for type ${$e.onnx.TensorProto.DataType[e]}`)}}var cc,$e,Oa,at,Hr=k(()=>{"use strict";cc=un(Qu());pa();Vn();$e=un(fn());Me();Oa=ne.experimental.fbs,at=class n{constructor(e,r,t,o,i,s=cc.Guid.create()){this.dims=e;this.type=r;this.dataProvider=t;this.asyncDataProvider=o;this.cache=i;this.dataId=s;this.size=Q.validateDimsAndCalcSize(e);let a=this.size,u=t===void 0&&o===void 0&&i===void 0;if(i!==void 0&&i.length!==a)throw new RangeError("Input dims doesn't match data length.");if(r==="string"){if(i!==void 0&&(!Array.isArray(i)||!i.every(l=>typeof l=="string")))throw new TypeError("cache should be a string array");u&&(this.cache=new Array(a))}else{if(i!==void 0){let l=dc(r);if(!(i instanceof l))throw new TypeError(`cache should be type ${l.name}`)}if(u){let l=new ArrayBuffer(a*Ty(r));this.cache=$y(l,r)}}}get data(){if(this.cache===void 0){let e=this.dataProvider(this.dataId);if(e.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=e}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(e){return this.data[Q.indicesToOffset(e,this.strides)]}set(e,r){this.data[Q.indicesToOffset(e,this.strides)]=r}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=Q.computeStrides(this.dims)),this._strides}static fromProto(e){if(!e)throw new Error("cannot construct Value from an empty tensor");let r=pt.tensorDataTypeFromProto(e.dataType),t=pt.tensorDimsFromProto(e.dims),o=new n(t,r);if(r==="string")e.stringData.forEach((i,s)=>{o.data[s]=Kn(i)});else if(e.rawData&&typeof e.rawData.byteLength=="number"&&e.rawData.byteLength>0){let i=o.data,s=new DataView(e.rawData.buffer,e.rawData.byteOffset,e.rawData.byteLength),a=uc(e.dataType),u=e.rawData.byteLength/a;if(e.rawData.byteLength%a!==0)throw new Error("invalid buffer length");if(i.length!==u)throw new Error("buffer length mismatch");for(let l=0;l<u;l++){let d=lc(s,e.dataType,l*a);i[l]=d}}else{let i;switch(e.dataType){case $e.onnx.TensorProto.DataType.FLOAT:i=e.floatData;break;case $e.onnx.TensorProto.DataType.INT32:case $e.onnx.TensorProto.DataType.INT16:case $e.onnx.TensorProto.DataType.UINT16:case $e.onnx.TensorProto.DataType.INT8:case $e.onnx.TensorProto.DataType.UINT8:case $e.onnx.TensorProto.DataType.BOOL:i=e.int32Data;break;case $e.onnx.TensorProto.DataType.INT64:i=e.int64Data;break;case $e.onnx.TensorProto.DataType.DOUBLE:i=e.doubleData;break;case $e.onnx.TensorProto.DataType.UINT32:case $e.onnx.TensorProto.DataType.UINT64:i=e.uint64Data;break;default:throw new Error("unspecific error")}if(i==null)throw new Error("failed to populate data from a tensorproto value");let s=o.data;if(s.length!==i.length)throw new Error("array length mismatch");for(let a=0;a<i.length;a++){let u=i[a];mr.isLong(u)?s[a]=Ea(u,e.dataType):s[a]=u}}return o}static fromData(e,r,t){return new n(r,t,void 0,void 0,e)}static fromOrtTensor(e){if(!e)throw new Error("cannot construct Value from an empty tensor");let r=pt.tensorDimsFromORTFormat(e),t=pt.tensorDataTypeFromProto(e.dataType()),o=new n(r,t);if(t==="string")for(let i=0;i<e.stringDataLength();i++)o.data[i]=e.stringData(i);else if(e.rawDataArray()&&typeof e.rawDataLength()=="number"&&e.rawDataLength()>0){let i=o.data,s=new DataView(e.rawDataArray().buffer,e.rawDataArray().byteOffset,e.rawDataLength()),a=uc(e.dataType()),u=e.rawDataLength()/a;if(e.rawDataLength()%a!==0)throw new Error("invalid buffer length");if(i.length!==u)throw new Error("buffer length mismatch");for(let l=0;l<u;l++){let d=lc(s,e.dataType(),l*a);i[l]=d}}return o}}});function ue(n){return n===1?Iy:Sy}function fc(n){let e=ue(n);return`${e.version}
      precision highp float;
      ${e.attribute} vec3 position;
      ${e.attribute} vec2 textureCoord;

      ${e.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`}function pc(n){let e=ue(n);return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFrag} vec2 TexCoords;
    ${e.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `}function hc(n,e){let r=ue(n);return`
  void main() {
    int indices[${e}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${r.output} = result;
  }
  `}var Iy,Sy,Xe=k(()=>{"use strict";Iy={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},Sy={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"}});var _e=k(()=>{"use strict"});async function Ca(n,e=t=>0,r){return new Promise((t,o)=>{let i=0,s=()=>{if(n()){t();return}i++;let a=e(i);if(r!=null&&i>=r){o();return}setTimeout(s,a)};s()})}function Ho(n){return pn(typeof n<"u"&&n.length!==0,()=>"empty string found for sampler name"),"get"+n.charAt(0).toUpperCase()+n.slice(1)}function mc(n){return pn(typeof n<"u"&&n.length!==0,()=>"empty string found for sampler name"),"get"+n.charAt(0).toUpperCase()+n.slice(1)+"AtOutCoords"}function hn(n,e){let r=JSON.parse(JSON.stringify(n));return r=e,r}function mn(n,e){return e.map(r=>n[r]).join(", ")}function xt(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Ht(n=6){return["x","y","z","w","u","v"].slice(0,n)}var rr=k(()=>{"use strict";Me()});function _y(n,e){return Ht(e).map(r=>`${n}.${r}`)}function gn(n,e){return e===1?[n]:_y(n,e)}function nr(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}var jr=k(()=>{"use strict";rr()});function Oy(n,e,r){if(n===0)return"false";if(n===1)return`rc > ${e[0]}`;let t="";for(let o=n-2;o<n;o++)t+=`${r[o]} >= ${e[o-n+2]}`,o<n-1&&(t+="||");return t}function Ey(n,e){let r=n.length;if(r===0)return"getA(), 0, 0, 0";if(r===1)return`getA(rc),
            rc + 1 >= ${n[0]} ? 0. : getA(rc + 1),
            0, 0`;let t="r, c",o="r, cp1",i="rp1, c",s="rp1, cp1",a="";if(r>2)for(let u=0;u<r-2;++u)a=a+`${e[u]},`;return`getA(${a}${t}),
          rEdge ? 0. : getA(${a}${i}),
          cEdge ? 0. : getA(${a}${o}),
          rEdge || cEdge ? 0. : getA(${a}${s})`}function Cy(n,e,r,t){return n===0||n===1?"":`
    int r = ${e[n-2]};
    int c = ${e[n-1]};
    int rp1 = ${e[n-2]} + 1;
    int cp1 = ${e[n-1]} + 1;
    bool rEdge = rp1 >= ${t};
    bool cEdge = cp1 >= ${r};
    `}var gc,Ay,bc,yc=k(()=>{"use strict";Xe();_e();rr();jr();gc={name:"pack",inputNames:["A"],inputTypes:[1]},Ay=(n,e)=>{let r=ue(n.session.backend.glContext.version),t=e.dims,o=t.length,i=e.dims.length,s=xt(i),a=gn("rc",i),u=Cy(i,a,t[t.length-2],t[t.length-1]),l;o===0?l=[1,1]:o===1?l=[t[0],1]:l=[t[i-1],t[i-2]];let d=Oy(i,l,a),p=Ey(t,a),h=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${d}) {
            ${r.output} = vec4(0);
          } else {
            ${u}

            ${r.output} = vec4(${p});
          }
        }
      `;return{...gc,hasMain:!0,output:{dims:e.dims,type:e.type,textureType:2},shaderSource:h}},bc=(n,e)=>({...gc,get:()=>Ay(n,e)})});function Pa(n){if(n.length===0)return[1,1,1];let e=1;for(let r=0;r<n.length-2;++r)e*=n[r];return[e,n.length>1?n[n.length-2]:1,n[n.length-1]]}function xc(n,e){let r=!1;return n.length===0||e.length===0?r=!0:n.length<2||e.length<2?r=n[n.length-1]===e[e.length-1]:r=n[n.length-1]===e[e.length-1]&&n[n.length-2]===e[e.length-2],r}function ky(n){let e=Q.computeStrides(n),r=["b","r","c"],t="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e.map((i,s)=>{let a=`int ${r[s]} = ${t} / ${i}`,u=s===e.length-1?`int ${r[s+1]} = ${t} - ${r[s]} * ${i}`:`index -= ${r[s]} * ${i}`;return`${a}; ${u};`}).join("")}
      return ivec3(b, r, c);
    }
  `}function By(n){let e=Q.computeStrides(n);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${e[0]} + coords.z * ${e[1]} + coords.y;
  }
`}var Py,Dy,vc,wc=k(()=>{"use strict";Me();Xe();_e();jr();Py=n=>({name:"Reshape (packed)",inputTypes:[2],inputNames:["A"],cacheHint:`${n}`}),Dy=(n,e,r,t)=>{let o=e.dims,i=t,s="";for(let l=0;l<4;l++){let d="";switch(l){case 0:d="outputCoords = rc;";break;case 1:d="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:d="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:d="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}s+=`
        ${d}
        ${l>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${l}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${l>0?"}":""}
      `}let a=ue(n.session.backend.glContext.version),u=`
      ${ky(o)}
      ${By(i)}
      ${nr()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${i[2]};
        int cols = ${i[1]};

        ${s}
        ${a.output} = result;
      }
    `;return{...r,output:{dims:i,type:e.type,textureType:2},shaderSource:u,hasMain:!0}},vc=(n,e,r)=>{let t=Py(r);return{...t,get:()=>Dy(n,e,t,r)}}});var Da,Tc=k(()=>{"use strict";Xe();_e();Da=(n,e)=>{let r=e.shape,t=ue(n.session.backend.glContext.version),o=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${t.texture2D}(X,TexCoords).r;
      ${t.output} = encodeAsUint8(value);
    }`,i={name:"Uint8Encode",inputTypes:[0],inputNames:["X"],output:{dims:r,type:e.tensor.type,textureType:3},shaderSource:o,hasMain:!0};return n.executeProgram(i,[e.tensor])}});function My(n,e){if(n===1)return"rc";let r="";for(let t=0;t<n;t++)r+=e[t],t<n-1&&(r+=",");return r}var $c,Ry,Ic,Sc=k(()=>{"use strict";Xe();_e();rr();jr();$c={name:"unpack",inputNames:["A"],inputTypes:[2]},Ry=(n,e)=>{let r=e.dims.length,t=gn("rc",r),o=t.slice(-2),i=xt(r),s=nr(),u=e.dims.length===0?"":My(r,t),l=r<=1?"rc":`vec2(${o.join(",")})`,d=ue(n.session.backend.glContext.version),p=`
    ${s}
    void main() {
      ${i} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${u});

       ${d.output} = vec4(getChannel(packedInput, ${l}), 0, 0, 0);
     }
   `;return{...$c,hasMain:!0,output:{dims:e.dims,type:e.type,textureType:0},shaderSource:p}},Ic=(n,e)=>({...$c,get:()=>Ry(n,e)})});var jo,Yn,qo,Xn=k(()=>{"use strict";Ot();jo=class{constructor(e,r=1){if(r===1)this.internalFormat=e.R32F,this.format=e.RED,this.textureType=e.FLOAT,this.channelSize=r;else if(r===4)this.internalFormat=e.RGBA32F,this.format=e.RGBA,this.textureType=e.FLOAT,this.channelSize=r;else throw new Error(`Invalid number of channels: ${r}`)}encode(e,r){let t,o;return e.constructor!==Float32Array&&(Ne.warning("Encoder","data was not of type Float32; creating new Float32Array"),o=new Float32Array(e)),r*this.channelSize>e.length?(Ne.warning("Encoder","Source data too small. Allocating larger array"),o=e,t=this.allocate(r*this.channelSize),o.forEach((i,s)=>t[s]=i)):(o=e,t=o),t}allocate(e){return new Float32Array(e*4)}decode(e,r){return this.channelSize===1?e.filter((o,i)=>i%4===0).subarray(0,r):e.subarray(0,r)}},Yn=class{constructor(e,r=1,t){if(r!==1&&r!==4)throw new Error(`Invalid number of channels: ${r}`);this.internalFormat=e.RGBA,this.format=e.RGBA,this.channelSize=r,this.textureType=t||e.FLOAT}encode(e,r){let t=e;return this.channelSize===1&&(Ne.verbose("Encoder","Exploding into a larger array"),t=this.allocate(r),e.forEach((o,i)=>t[i*4]=o)),t}allocate(e){return new Float32Array(e*4)}decode(e,r){return this.channelSize===1?e.filter((o,i)=>i%4===0).subarray(0,r):e.subarray(0,r)}},qo=class{constructor(e,r=1){this.channelSize=4;if(r===1)this.internalFormat=e.ALPHA,this.format=e.ALPHA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=r;else if(r===4)this.internalFormat=e.RGBA,this.format=e.RGBA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=r;else throw new Error(`Invalid number of channels: ${r}`)}encode(e,r){return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}allocate(e){return new Uint8Array(e*this.channelSize)}decode(e,r){if(e instanceof Uint8Array)return e.subarray(0,r);throw new Error(`Invalid array type: ${e.constructor}`)}}});var Jn,_c,ka,Ac=k(()=>{"use strict";Me();_e();Jn=(n,e,r)=>{let t=r===0||r===1?1:4,o=r===2,i=r===1||r===2,s=r===4?e.length-1:void 0,a=r===4?e.map((u,l)=>l===e.length-1?u*4:u):void 0;return ka(n,e,t,a,{isPacked:o,reverseWH:i,breakAxis:s})},_c=(n,e,r)=>{let t=Jn(n,e,r);return[t.width,t.height]},ka=(n,e,r=1,t,o)=>{let i=!!(o&&o.isPacked),[s,a]=n.computeTextureWH(i&&t||e,o),u=e.length,l=e.slice(0);if(u===0&&(l=[1]),r===1)t=e;else if(i){if(r!==4)throw new Error("a packed texture must be 4-channel");t=e,u>0&&(l[u-1]=Math.ceil(l[u-1]/2)),u>1&&(l[u-2]=Math.ceil(l[u-2]/2))}else if(!t)throw new Error("Unpacked shape is needed when using channels > 1");return{width:s,height:a,channels:r,isPacked:i,shape:l,strides:Q.computeStrides(l),unpackedShape:t,reversedWH:o&&o.reverseWH}}});var Ny,Ko,Ec=k(()=>{"use strict";Ot();Hr();Me();yc();wc();Tc();Sc();Xn();Ac();_e();Ny=(n,e)=>{let r=e.map(o=>`${o.unpackedShape.join(",")};${o.width}x${o.height}`).join("_"),t=n.name;return n.cacheHint&&(t+="["+n.cacheHint+"]"),t+=":"+r,t},Ko=class{constructor(e){this.session=e;this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(e,r){return _c(this.session.layoutStrategy,e,r)}executeProgram(e,r){if(r.length<e.inputNames.length)throw new Error(`Input size mustn't be less than ${e.inputNames.length}.`);if(e.inputNames.length!==e.inputTypes.length)throw new Error("input names size does not match input types");let t=[];for(let l=0;l<e.inputNames.length;++l)t[l]=this.getOrCreateTextureData(r[l],e.inputTypes[l]);let o=Ny(e,t),i=this.session.programManager.getArtifact(o),s=i?i.programInfo:typeof e.get=="function"?e.get():e,a=Jn(this.session.layoutStrategy,s.output.dims,s.output.textureType),u=this.createTextureData(a,s.output.type);return i||(i=this.session.programManager.build(s,t,u),this.session.programManager.setArtifact(o,i)),this.runProgram(i,t,u),u}run(e,r){return this.executeProgram(e,r).tensor}runProgram(e,r,t){for(let o=0;o<r.length;++o)if(!!r[o].isPacked!=(e.programInfo.inputTypes[o]===2))throw new Error(`input[${o}] property packed inconsistent`);if(!!t.isPacked!=(e.programInfo.output.textureType===2))throw new Error("output property packed inconsistent");this.session.programManager.run(e,r,t)}getOrCreateTextureData(e,r){let t=this.getTextureData(e.dataId,r===2);if(!t&&(t=this.getTextureData(e.dataId,r!==2),t))return r===2?this.pack(t):this.unpack(t);if(!t){let o=Jn(this.session.layoutStrategy,e.dims,r);if(r===4){let a=e.dims;if(a.length===4){let u=[a[0],Math.ceil(a[1]*a[2]*a[3]/4)],l=Jn(this.session.layoutStrategy,u,r),d=e.numberData;if(a[1]*a[2]*a[3]%4!==0){let p=a[0],h=a[1]*a[2]*a[3],g=Math.ceil(h*1/4)*4,y=p*g;d=new Float32Array(y);for(let b=0;b<p;++b){let w=b*h,I=b*g+b%1*h;d.set(e.numberData.subarray(w,w+h),I)}}return this.createTextureData(l,e.type,d,e,1)}}if(r===2){let i=ka(this.session.layoutStrategy,e.dims,1,[],{reverseWH:!0}),s=this.createTextureData(i,e.type,e.numberData,e,1);t=this.pack(s)}else t=this.createTextureData(o,e.type,e.numberData,e,1)}return t}createTextureDataFromLayoutBindTensor(e,r,t,o){return this.createTextureData(e,r,t,o,1)}createTextureData(e,r,t,o,i){Ne.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(e)}]`);let s=this.session.textureManager.createTextureFromLayout(r,e,t,i);return this.createTextureDataFromTexture(e,r,s,o)}reshapeUnpacked(e,r){let t=this.getOrCreateTextureData(e,0),o={channels:t.channels,height:t.height,width:t.width,shape:r.length!==0?r:[1],strides:Q.computeStrides(r),unpackedShape:r};return this.createTextureDataFromTexture(o,e.type,t.texture).tensor}reshapePacked(e,r){let t=this.getOrCreateTextureData(e,2);if(xc(e.dims,r)){let l={channels:t.channels,height:t.height,width:t.width,shape:r.length!==0?r:[1],strides:Q.computeStrides(r),unpackedShape:r,isPacked:!0};return this.createTextureDataFromTexture(l,e.type,t.texture).tensor}let o=Pa(e.dims),i=Pa(r),s=this.reshapePacked(e,o),a=this.run(vc(this,s,i),[s]);return this.reshapePacked(a,r)}cast(e,r){let t=this.getOrCreateTextureData(e,0);return this.createTextureDataFromTexture(t,r,t.texture).tensor}createTextureDataFromTexture(e,r,t,o,i){let s={...e,tensor:o||new at(e.unpackedShape,r,a=>this.readTexture(s),async a=>this.readTextureAsync(s),void 0,i),texture:t};return this.setTextureData(s.tensor.dataId,s,e.isPacked),s}getTextureData(e,r=!1){return this.session.isInitializer(e)?this.session.getTextureData(e,r):r?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,r,t=!1){this.session.isInitializer(e)?this.session.setTextureData(e,r,t):(t?this.packedTextureDataCache:this.unpackedTextureDataCache).set(e,r)}isTextureLayoutCached(e,r=!1){return!!this.getTextureData(e.dataId,r)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.unpackedTextureDataCache=new Map}readTexture(e){return e.isPacked?this.readTexture(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat(Da(this,e))}async readTextureAsync(e){return e.isPacked?this.readTextureAsync(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat(Da(this,e))}pack(e){return this.executeProgram(bc(this,e.tensor),[e.tensor])}unpack(e){return this.executeProgram(Ic(this,e.tensor),[e.tensor])}}});var Ba,we,ct=k(()=>{"use strict";Ba=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(e=>`${this[e]}`).join(";")),this._cacheKey}},we=n=>new Ba(n)});var Cc,Pc,Dc,Fy,zy,kc=k(()=>{"use strict";ct();Xe();_e();Cc={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[0,0,0,0,0]},Pc=(n,e,r)=>(zy(e),[n.run({...Cc,cacheHint:r.cacheKey,get:()=>Fy(n,e,r)},e)]),Dc=n=>{let e=n.attributes.getFloat("epsilon",1e-5),r=n.attributes.getFloat("momentum",.9),t=n.attributes.getInt("spatial",1);return we({epsilon:e,momentum:r,spatial:t})},Fy=(n,e,r)=>{let t=ue(n.session.backend.glContext.version),o=e[0].dims.length,[i,s]=n.calculateTextureWidthAndHeight(e[1].dims,0),a=`
  float process(int[${o}] indices) {
    vec2 position = offsetToCoords(indices[1], ${i}, ${s});
    float scale = getColorAsFloat(${t.texture2D}(Scale, position));
    float mean = getColorAsFloat(${t.texture2D}(Mean, position));
    float variance = getColorAsFloat(${t.texture2D}(Variance, position));
    float b = getColorAsFloat(${t.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${r.epsilon})) ) + b;
  }`;return{...Cc,output:{dims:e[0].dims,type:e[0].type,textureType:0},shaderSource:a}},zy=n=>{if(!n||n.length!==5)throw new Error("BatchNormalization requires 5 inputs.");let e=n[0],r=n[1],t=n[2],o=n[3],i=n[4];if(e.dims.length<3||r.dims.length!==1||t.dims.length!==1||o.dims.length!==1||i.dims.length!==1)throw new Error("invalid input shape.");if(r.dims[0]!==e.dims[1]||t.dims[0]!==e.dims[1]||o.dims[0]!==e.dims[1]||i.dims[0]!==e.dims[1])throw new Error("invalid input shape.");if(e.type!=="float32"&&e.type!=="float64"||r.type!=="float32"&&r.type!=="float64"||t.type!=="float32"&&t.type!=="float64"||o.type!=="float32"&&o.type!=="float64"||i.type!=="float32"&&i.type!=="float64")throw new Error("invalid input tensor types.")}});var Yo,Dt,Y,Zn,Xo,gr=k(()=>{"use strict";Yo=class{constructor(e,r,t,o){this.glContext=e;this.programInfo=r;this.inputTextureLayouts=t;this.outputTextureLayout=o}},Dt=class{constructor(e){this.context=e}},Y=class{constructor(e,r){this.routineBody=e;this.dependencies=r}},Zn=class{constructor(e,r,t){this.name=e;t?this.dependencies=t:this.dependencies=[],r&&(this.routineBody=r)}addDependency(e){e&&this.dependencies.push(e)}},Xo=class{static returnOrderedNodes(e){if(!e||e.length===0)return[];if(e.length===1)return e;let r=new Set,t=new Set,o=new Array;return this.createOrderedNodes(e,r,t,o),o}static createOrderedNodes(e,r,t,o){for(let i=0;i<e.length;++i)this.dfsTraverse(e[i],r,t,o)}static dfsTraverse(e,r,t,o){if(!e||t.has(e.name))return;if(r.has(e.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");r.add(e.name);let i=e.dependencies;if(i&&i.length>0)for(let s=0;s<i.length;++s)this.dfsTraverse(i[s],r,t,o);o.push(e),t.add(e.name),r.delete(e.name)}}});function Wy(){let n="add_";return{body:`
  float ${n}(float a, float b) {
    return a + b;
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:n,type:0}}function Vy(){let n="div_";return{body:`
  float ${n}(float a, float b) {
    return a / b;
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:n,type:0}}function Uy(){let n="mul_";return{body:`
  float ${n}(float a, float b) {
    return a * b;
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:n,type:0}}function Hy(){let n="sub_";return{body:`
  float ${n}(float a, float b) {
    return a - b;
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:n,type:0}}function jy(){let n="equal_";return{body:`
  float ${n}(float a, float b) {
    return float(a == b);
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:n,type:0}}function qy(){let n="greater_";return{body:`
  float ${n}(float a, float b) {
    return float(a > b);
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:n,type:0}}function Ky(){let n="less_";return{body:`
  float ${n}(float a, float b) {
    return float(a < b);
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:n,type:0}}function Yy(){let n="and_";return{body:`
  float ${n}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:n,type:0}}function Xy(){let n="or_";return{body:`
  float ${n}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:n,type:0}}function Jy(){let n="xor_";return{body:`
  float ${n}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:n,type:0}}function Zy(){return e0("pow")}function Qy(){let n="prelu_";return{body:`
  float ${n}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:n,type:0}}function e0(n){let e=`${n}_`;return{body:`
  float ${e}(float a, float b) {
    return ${n}(a, b);
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return ${n}(v1, v2);
  }
  `,name:e,type:0}}var kt,t0,Bc,Rc,Mc,Lc,Nc,Fc,zc,Gc,Wc,Vc,Uc,Hc,jc=k(()=>{"use strict";Me();gr();Xe();_e();kt=(n,e,r,t=e[0].type,o)=>{let i=n.session.pack?2:0;return{name:r.name,inputNames:["A","B"],inputTypes:[i,i],cacheHint:o,get:()=>t0(n,e,r,t)}},t0=(n,e,r,t=e[0].type)=>{let o=n.session.pack?2:0,i=!Q.areEqual(e[0].dims,e[1].dims),s=e[0].dims,a=n.session.pack;if(i){let d=vt.calcShape(e[0].dims,e[1].dims,!1);if(!d)throw new Error("Can't perform binary op on the given tensors");s=d;let p=s.length,h=e[0].dims.length!==0?e[0].dims.length:1,g=e[1].dims.length!==0?e[1].dims.length:1,y=e[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",b=e[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",w=ue(n.session.backend.glContext.version),I=a?`
      ${r.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${r.name}(a, b);
        ${w.output} = result;
      }`:`
      ${r.body}
      float process(int indices[${p}]) {
        int aindices[${h}];
        int bindices[${g}];
        ${y}
        ${b}
        return ${r.name}(_A(aindices), _B(bindices));
      }`;return{name:r.name,inputNames:["A","B"],inputTypes:[o,o],output:{dims:s,type:t,textureType:o},shaderSource:I,hasMain:a}}let u=ue(n.session.backend.glContext.version),l=`
    ${r.body}
    void main() {
      vec4 v1 = ${u.texture2D}(A, TexCoords);
      vec4 v2 = ${u.texture2D}(B, TexCoords);
      vec4 result = ${r.name}(v1, v2);
      ${u.output} = result;
    }
    `;return{name:r.name,inputNames:["A","B"],inputTypes:[o,o],output:{dims:e[0].dims,type:t,textureType:o},shaderSource:l,hasMain:!0}},Bc=(n,e)=>[n.run(kt(n,e,Wy()),e)],Rc=(n,e)=>[n.run(kt(n,e,Yy(),"bool"),e)],Mc=(n,e)=>[n.run(kt(n,e,Vy()),e)],Lc=(n,e)=>[n.run(kt(n,e,jy(),"bool"),e)],Nc=(n,e)=>[n.run(kt(n,e,qy(),"bool"),e)],Fc=(n,e)=>[n.run(kt(n,e,Ky(),"bool"),e)],zc=(n,e)=>[n.run(kt(n,e,Uy()),e)],Gc=(n,e)=>[n.run(kt(n,e,Xy(),"bool"),e)],Wc=(n,e)=>[n.run(kt(n,e,Zy()),e)],Vc=(n,e)=>[n.run(kt(n,e,Qy()),e)],Uc=(n,e)=>[n.run(kt(n,e,Hy()),e)],Hc=(n,e)=>[n.run(kt(n,e,Jy(),"bool"),e)]});var qc,Kc,n0,Yc=k(()=>{"use strict";Me();qc=(n,e,r)=>(n0(e),[n.cast(e[0],r)]),Kc=n=>pt.tensorDataTypeFromProto(n.attributes.getInt("to")),n0=n=>{if(!n||n.length!==1)throw new Error("Cast requires 1 input.");if(n[0].type==="string")throw new Error("Invalid input type.")}});var o0,i0,Xc,Jo,Jc=k(()=>{"use strict";Xe();_e();rr();jr();o0=(n,e)=>({name:"Concat (packed)",inputNames:Array.from({length:n},(r,t)=>`X${t}`),inputTypes:Array(n).fill(2),cacheHint:e}),i0=(n,e,r,t)=>{let o=r[0].dims.slice();if(t>=o.length||t<-1*o.length)throw new Error("axis specified for concat doesn't match input dimensionality");t<0&&(t=o.length+t);let i=o.slice(0);for(let F=1;F<r.length;F++){let R=r[F].dims.slice();for(let V=0;V<o.length;V++)if(V===t)i[t]+=R[V];else if(o[V]!==R[V])throw new Error("non concat dimensions must match")}let s=i.length,a=gn("coords",s),u=xt(s),l=nr(),d=r.map(F=>F.dims),p=Ht(s),h=new Array(d.length-1);h[0]=d[0][t];for(let F=1;F<h.length;F++)h[F]=h[F-1]+d[F][t];let g=p[t],y=p.slice(-2),b=p.join(),w=`if (${g} < ${h[0]}) {
        return getChannel(
            getX0(${b}), vec2(${y.join()}));
        }`;for(let F=1;F<h.length;F++){let R=h[F-1];w+=`
            if (${g} < ${h[F]}  && ${g} >= ${h[F-1]}) {
              return getChannel(
                getX${F}(${Jo(p,g,R)}),
                vec2(${Jo(y,g,R)}));
            }`}let I=h.length,O=h[h.length-1];w+=`
            return getChannel(
              getX${I}(${Jo(p,g,O)}),
              vec2(${Jo(y,g,O)}));`;let E=ue(n.session.backend.glContext.version),N=`
          ${l}
          float getValue(${p.map(F=>"int "+F)}) {
            ${w}
          }

          void main() {
            ${u} coords = getOutputCoords();
            int lastDim = coords.${p[s-1]};
            coords.${p[s-1]} = coords.${p[s-2]};
            coords.${p[s-2]} = lastDim;

            vec4 result = vec4(getValue(${a}), 0., 0., 0.);

            ${a[s-1]} = ${a[s-1]} + 1;
            if (${a[s-1]} < ${i[s-1]}) {
              result.g = getValue(${a});
            }

            ${a[s-2]} = ${a[s-2]} + 1;
            if (${a[s-2]} < ${i[s-2]}) {
              result.a = getValue(${a});
            }

            ${a[s-1]} = ${a[s-1]} - 1;
            if (${a[s-2]} < ${i[s-2]} &&
                ${a[s-1]} < ${i[s-1]}) {
              result.b = getValue(${a});
            }
            ${E.output} = result;
          }
        `;return{...e,output:{dims:i,type:r[0].type,textureType:2},shaderSource:N,hasMain:!0}},Xc=(n,e,r)=>{let t=o0(e.length,r.cacheKey);return{...t,get:()=>i0(n,t,e,r.axis)}},Jo=(n,e,r)=>{let t=n.indexOf(e);return n.map((i,s)=>s===t?`${i} - ${r}`:i).join()}});var Zc,a0,s0,u0,Qc,l0,c0,d0,ed,f0,td=k(()=>{"use strict";ct();_e();Jc();Zc=(n,e,r)=>(f0(e),n.session.pack&&e[0].dims.length>1?[n.run(Xc(n,e,r),e)]:[n.run(u0(n,e,r),e)]),a0=(n,e)=>({name:"Concat",inputNames:Array.from({length:n},(r,t)=>`X${t}`),inputTypes:Array(n).fill(0),cacheHint:e}),s0=(n,e,r,t)=>{let o=r[0].dims.slice();if(t>=o.length||t<-1*o.length)throw new Error("axis specified for concat doesn't match input dimensionality");t<0&&(t=o.length+t);let i=o.slice(0);for(let g=1;g<r.length;g++){let y=r[g].dims.slice();for(let b=0;b<o.length;b++)if(b===t)i[t]+=y[b];else if(o[b]!==y[b])throw new Error("non concat dimensions must match")}let s=i.length,a=new Array(r.length),u=0;for(let g=0;g<a.length;++g)u+=r[g].dims[t],a[g]=u;let l="";r.length<5?l=Qc(a):l=l0(a);let d=c0(r.length,s),p=d0(a),h=`
        ${d}
        ${p}
        ${l}
        float process(int indices[${s}]) {
          int textureIndex = getTextureWhereDataResides (indices[${t}]);

          if(textureIndex != 0) {
            indices[${t}] = indices[${t}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return{...e,output:{dims:i,type:r[0].type,textureType:0},shaderSource:h}},u0=(n,e,r)=>{let t=a0(e.length,r.cacheKey);return{...t,get:()=>s0(n,t,e,r.axis)}},Qc=n=>`int getTextureWhereDataResides(int index) {
      ${n.map((r,t)=>`if(index<${r}) {return ${t};}
`).join("")}
    }`,l0=n=>Qc(n),c0=(n,e)=>{let r=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${e}]) {`];for(let t=0;t<n;++t)t===0?r.push(`	if (textureIndex == ${t}) { return _X${t}(indices); }`):t===n-1?r.push(`	else { return _X${t}(indices); }`):r.push(`	else if (textureIndex == ${t}) { return _X${t}(indices); }`);return r.push("	}"),r.join(`
`)},d0=n=>{let e=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let r=0;r<n.length;++r)r===0?e.push(`	if (index == ${r}) { return ${n[r]}; }`):r===n.length-1?e.push(`	else { return ${n[r]}; }`):e.push(`	else if (index == ${r}) { return ${n[r]}; }`);return e.push("	}"),e.join(`
`)},ed=n=>we({axis:n.attributes.getInt("axis")}),f0=n=>{if(!n||n.length<1)throw new Error("too few inputs");let e=n[0].type,r=n[0].dims.length;if(e==="string")throw new Error("string tensor is not supported yet");for(let t of n){if(t.type!==e)throw new Error("input tensors should be one type");if(t.dims.length!==r)throw new Error("input tensors should have the same shape")}}});function p0(){return Bt("abs")}function h0(){return Bt("acos")}function m0(){return Bt("asin")}function g0(){return Bt("atan")}function b0(){return Bt("ceil")}function y0(){return Bt("cos")}function v0(n){let e="elu";return{body:`
  const float alpha = float(${n});

  float ${e}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${e}_(vec4 v) {
    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));
  }
  `,name:e,type:0}}function x0(){return Bt("exp")}function w0(){return Bt("floor")}function Ra(n,e){let r="clip";return{body:`
  const float min = float(${n});
  const float max = float(${e});

  float ${r}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${r}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:r,type:0}}function T0(){let n="indentity";return{body:`
  float ${n}_(float a) {
    return a;
  }
  vec4 ${n}_(vec4 v) {
    return v;
  }
  `,name:n,type:0}}function $0(n){let e="leakyRelu";return{body:`
  const float alpha = float(${n});

  float ${e}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${e}_(vec4 v) {
    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));
  }
  `,name:e,type:0}}function I0(){return Bt("log")}function S0(){let n="neg";return{body:`
  float ${n}_(float a) {
    return -a;
  }
  vec4 ${n}_(vec4 v) {
    return -v;
  }
  `,name:n,type:0}}function _0(){let n="not";return{body:`
  float ${n}_(float a) {
    return float( ! bool(a) );
  }
  bool ${n}_(bool a) {
    return !a;
  }
  vec4 ${n}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${n}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:n,type:0}}function A0(){return Bt("sin")}function Ma(){let n="relu";return{body:`
  float ${n}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${n}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:n,type:0}}function La(){let n="sigmoid";return{body:`
  float ${n}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${n}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:n,type:0}}function O0(){return Bt("sqrt")}function E0(){return Bt("tan")}function C0(){let n="tanh";return{body:`
  float ${n}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${n}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:n,type:0}}function Bt(n){return{body:`
  float ${n}_(float a) {
    return ${n}(a);
  }
  vec4 ${n}_(vec4 v) {
    return ${n}(v);
  }
  `,name:n,type:0}}var P0,rt,rd,nd,od,id,Na,ad,sd,D0,ud,ld,cd,dd,fd,pd,Fa,hd,md,gd,bd,yd,vd,xd,wd,Td,$d,Id,za=k(()=>{"use strict";ct();Me();gr();Xe();_e();P0=(n,e,r,t)=>{let o=n.session.pack?2:0,i=ue(n.session.backend.glContext.version);return{...e,output:{dims:r.dims,type:r.type,textureType:o},shaderSource:`
     ${t.body}
     void main() {
       vec4 v = ${i.texture2D}(A, TexCoords);
       v = ${t.name}_(v);
       ${i.output} = v;
     }
     `,hasMain:!0}},rt=(n,e,r,t)=>{let o=n.session.pack?2:0,i={name:r.name,inputTypes:[o],inputNames:["A"],cacheHint:t};return{...i,get:()=>P0(n,i,e,r)}},rd=(n,e)=>[n.run(rt(n,e[0],p0()),e)],nd=(n,e)=>[n.run(rt(n,e[0],h0()),e)],od=(n,e)=>[n.run(rt(n,e[0],m0()),e)],id=(n,e)=>[n.run(rt(n,e[0],g0()),e)],Na=(n,e,r)=>[n.run(rt(n,e[0],Ra(r.min,r.max),r.cacheKey),e)],ad=n=>we({min:n.attributes.getFloat("min",Vr),max:n.attributes.getFloat("max",Ur)}),sd=(n,e)=>{let r=D0(n,e);return Na(n,[e[0]],r)},D0=(n,e)=>{if(e.length>=3&&(!n.session.isInitializer(e[1].dataId)||!n.session.isInitializer(e[2].dataId)))throw new Error("dynamic clip attributes are not allowed");let r=e.length>=3?e[1].numberData[0]:Vr,t=e.length>=3?e[2].numberData[0]:Ur;return we({min:r,max:t})},ud=(n,e)=>[n.run(rt(n,e[0],b0()),e)],ld=(n,e)=>[n.run(rt(n,e[0],y0()),e)],cd=(n,e,r)=>[n.run(rt(n,e[0],v0(r.alpha),r.cacheKey),e)],dd=n=>we({alpha:n.attributes.getFloat("alpha",1)}),fd=(n,e)=>[n.run(rt(n,e[0],x0()),e)],pd=(n,e)=>[n.run(rt(n,e[0],w0()),e)],Fa=(n,e)=>[n.run(rt(n,e[0],T0()),e)],hd=(n,e,r)=>[n.run(rt(n,e[0],$0(r.alpha),r.cacheKey),e)],md=n=>we({alpha:n.attributes.getFloat("alpha",.01)}),gd=(n,e)=>[n.run(rt(n,e[0],I0()),e)],bd=(n,e)=>[n.run(rt(n,e[0],S0()),e)],yd=(n,e)=>[n.run(rt(n,e[0],_0()),e)],vd=(n,e)=>[n.run(rt(n,e[0],Ma()),e)],xd=(n,e)=>[n.run(rt(n,e[0],La()),e)],wd=(n,e)=>[n.run(rt(n,e[0],A0()),e)],Td=(n,e)=>[n.run(rt(n,e[0],O0()),e)],$d=(n,e)=>[n.run(rt(n,e[0],E0()),e)],Id=(n,e)=>[n.run(rt(n,e[0],C0()),e)]});function or(n){let e;switch(n.activation){case"Relu":e=Ma();break;case"Sigmoid":e=La();break;case"Clip":e=Ra(n.clipMin,n.clipMax);break;default:return{activationFunction:"",applyActivation:""}}let r=e.name,t=e.body,o=`value = ${r}_(value);`;return{activationFunction:t,applyActivation:o}}var bn,qr=k(()=>{"use strict";Me();za();bn=n=>{let e=n.getString("activation","");if(e==="Clip"){let[r,t]=n.getFloats("activation_params",[Vr,Ur]);return{activation:e,clipMax:t,clipMin:r,activationCacheKey:`${e}:${r},${t}`}}return{activation:e,activationCacheKey:e}}});var B0,R0,Sd,_d=k(()=>{"use strict";Ot();Xe();_e();Zo();qr();B0=(n,e)=>({name:"GroupedConv",inputNames:n?["X","W","Bias"]:["X","W"],inputTypes:n?[0,0,0]:[0,0],cacheHint:e}),R0=(n,e,r,t)=>{let i=e.length>2?"value += getBias(output_channel);":"",s=e[0].dims.slice(),a=e[1].dims.slice(),u=a[0]/t.group;Ne.verbose("GroupedConv",`autpPad:${t.autoPad}, dilations:${t.dilations}, group:${t.group}, kernelShape:${t.kernelShape}, pads:${t.pads}, strides:${t.strides}`);let l=yn(s,a,t.dilations,t.pads,t.strides),d=ue(n.session.backend.glContext.version),{activationFunction:p,applyActivation:h}=or(t),g=`
  const ivec2 strides = ivec2(${t.strides[0]}, ${t.strides[1]});
  const ivec2 pads = ivec2(${t.pads[0]}, ${t.pads[1]});
  ${p}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${u};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${a[1]}; wInChannel++) {
      int input_channel = group_id * ${a[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${a[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${t.dilations[0]};

        if (xHeight < 0 || xHeight >= ${s[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${a[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${t.dilations[1]};
          if (xWidth < 0 || xWidth >= ${s[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${i}
    ${h}
    ${d.output} = vec4(value, .0, .0, .0);
  }
`;return{...r,output:{dims:l,type:e[0].type,textureType:0},shaderSource:g,hasMain:!0}},Sd=(n,e,r)=>{let t=B0(e.length>2,r.cacheKey);return{...t,get:()=>R0(n,e,t,r)}}});var M0,L0,Ad,Od=k(()=>{"use strict";Xe();_e();jr();M0=n=>({name:"Im2Col (packed)",inputNames:["A"],inputTypes:[2],cacheHint:n}),L0=(n,e,r,t,o,i)=>{let s=r.dims,a=t.dims,u=2,l=3,d=o.length,p=[a[1]*a[2]*a[3],o[2]*o[3]],h=a[2]*a[3],g=nr(),y=ue(n.session.backend.glContext.version),b="";for(let I=0;I<=1;I++)for(let O=0;O<=1;O++)b+=`
            blockIndex = rc.x + ${O};
            pos = rc.y + ${I};

            if(blockIndex < ${p[1]} && pos < ${p[0]}) {
              offsetY = int(blockIndex / (${o[d-1]})) * ${i.strides[0]} -
                ${i.pads[0]};
              d0 = offsetY + ${i.dilations[0]} * (imod(pos, ${h}) / ${a[2]});

              if(d0 < ${s[u]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${o[d-1]}) * ${i.strides[1]} -
                  ${i.pads[1]};
                d1 = offsetX + ${i.dilations[1]} * imod(imod(pos, ${h}), ${a[2]});

                if(d1 < ${s[l]} && d1 >= 0) {

                  ch = int(float(pos)/ ${h}.);
                    innerDims = vec2(d0, d1);
                    result[${I*2+O}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;let w=`
      ${g}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${b}
          ${y.output} = result;
      }
            `;return{...e,output:{dims:p,type:r.type,textureType:2},shaderSource:w,hasMain:!0}},Ad=(n,e,r,t,o)=>{let i=M0(o.cacheKey);return{...i,get:()=>L0(n,i,e,r,t,o)}}});function F0(n,e,r){let t=e[0].dims,o=e[1].dims,i=vt.calcShape(t,o,!0);if(!i)throw new Error("Can't use matmul on the given tensors");let s=xt(i.length),a=Ht(),{activationFunction:u,applyActivation:l}=or(r),d=e.length>2,p=d?"value += getBiasForMatmul();":"",h=d?`${Wa(s,a,e[2].dims,i,!1)}`:"",g=i.length,y=t.length,b=o.length,w=t[t.length-1],I=`
    ${u}
    ${h}
    float process(int indices[${g}]) {
        int a[${y}];
        int b[${b}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${w}; ++k) {
            a[${y-1}] = k;
            b[${b-2}] = k;
            value += _A(a) * _B(b);
        }
        ${p}
        ${l}
        return value;
    }`;return{...n,output:{dims:i,type:e[0].type,textureType:0},shaderSource:I}}function Ga(n,e){let r=N0(n.length>2,e.activationCacheKey);return{...r,get:()=>F0(r,n,e)}}function Wa(n,e,r,t,o){let i="",s=r.length,a=t.length,u=a-s;a<2&&s>0?i="coords":i=r.map((b,w)=>`coords.${e[w+u]}`).join(", ");let d=vt.getBroadcastDims(r,t).map(b=>`coords.${e[b+u]} = 0;`).join(`
`),h=Q.size(r)===1,g="vec4(outputValue.xx, outputValue.yy)";return h&&(g="vec4(outputValue.x)"),o?`
vec4 getBiasForMatmul() {
  ${n} coords = getOutputCoords();
  ${d}
  vec4 outputValue = getBias(${i});
  return ${g};
}`:`
float getBiasForMatmul() {
  ${n} coords = getOutputCoords();
  ${d}
  return getBias(coords.x);
}`}var Ed,Cd,N0,z0,Qo=k(()=>{"use strict";Me();_e();rr();qr();Va();Ed=(n,e,r)=>(z0(e),n.session.pack?[n.run(ei(n,e,r),e)]:[n.run(Ga(e,r),e)]),Cd=n=>bn(n.attributes),N0=(n,e)=>({name:"MatMul",inputNames:n?["A","B","Bias"]:["A","B"],inputTypes:n?[0,0,0]:[0,0],cacheHint:e});z0=n=>{if(!n||n.length!==2)throw new Error("MatMul requires 2 inputs.");if(n[0].dims[n[0].dims.length-1]!==n[1].dims[n[1].dims.length-2])throw new Error("shared dimension does not match.");if(n[0].type!=="float32"&&n[0].type!=="float64"||n[1].type!=="float32"&&n[1].type!=="float64")throw new Error("inputs should be float type");if(n[0].type!==n[1].type)throw new Error("inputs types should match")}});function V0(n,e,r,t){let o=[],i=[],s=r[0].dims,a=r[1].dims,u=s.length,l=a.length,d=t.length,p=d-u,h=d-l;o=s.map((E,N)=>`coords.${e[N+p]}`),o[u-1]="i*2",o.join(", "),i=a.map((E,N)=>`coords.${e[N+h]}`),i[l-2]="i*2",i.join(", ");let g=vt.getBroadcastDims(s,t),y=vt.getBroadcastDims(a,t),b=g.map(E=>`coords.${e[E+p]} = 0;`).join(`
`),w=y.map(E=>`coords.${e[E+h]} = 0;`).join(`
`),I=`int lastDim = coords.${e[d-1]};
  coords.${e[d-1]} = coords.${e[d-2]};
  coords.${e[d-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${n} coords = getOutputCoords();
  ${I}
  ${b}
  vec4 outputValue = getA(${o});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${n} coords = getOutputCoords();
  ${I}
  ${w}
  vec4 outputValue = getB(${i});
  return outputValue;
}`}function U0(n,e){let r="";for(let t=0;t<e-2;t++)r+=`rc.${n[t]}, `;return r+=`rc.${n[e-2]}, i*2`,r}function H0(n,e){let r="";for(let t=0;t<e-2;t++)r+=`rc.${n[t]}, `;return r+=`i*2, rc.${n[e-1]}`,r}var G0,W0,ei,Va=k(()=>{"use strict";Me();Xe();_e();rr();qr();Qo();G0=(n,e)=>({name:"MatMul (packed)",inputNames:n?["A","B","Bias"]:["A","B"],inputTypes:n?[2,2,2]:[2,2],cacheHint:e}),W0=(n,e,r,t)=>{let o=r.length>2,i=o?"value += getBiasForMatmul();":"",s=r[0].dims,a=r[1].dims,u=vt.calcShape(s,a,!0),l=!Q.areEqual(r[0].dims,r[1].dims);if(!u)throw new Error("Can't use matmul on the given tensors");let d=s[s.length-1],p=Math.ceil(d/2),h=s.length,g=a.length,y=ue(n.session.backend.glContext.version),b=xt(u.length),w=u.length,I=Ht(),{activationFunction:O,applyActivation:E}=or(t),N=o?`${Wa(b,I,r[2].dims,u,!0)}`:"",F=l?`${V0(b,I,r,u)}`:"",R=l?"getAAtOutCoordsMatmul(i)":`getA(${U0(I,h)})`,V=l?"getBAtOutCoordsMatmul(i)":`getB(${H0(I,g)})`,K=l?"":`${b} rc =
          getOutputCoords(); int lastDim = rc.${I[w-1]}; rc.${I[w-1]} =
          rc.${I[w-2]}; rc.${I[w-2]} = lastDim;
      `,J=`
            ${F}
            ${N}
            ${O}
            void main() {
              ${K}

              vec4 value = vec4(0);
              for (int i = 0; i < ${p}; i++) {
                vec4 a = ${R};
                vec4 b = ${V};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${i}
              ${E}
              ${y.output} = value;
            }`;return{...e,output:{dims:u,type:r[0].type,textureType:2},shaderSource:J,hasMain:!0}},ei=(n,e,r)=>{let t=G0(e.length>2,r.activationCacheKey);return{...t,get:()=>W0(n,t,e,r)}}});var Pd,Dd=k(()=>{"use strict";Zo();Od();Va();Pd=(n,e,r)=>{let t=e[0].dims,o=e[1].dims,i=yn(t,o,r.dilations,r.pads,r.strides),s=n.run(Ad(n,e[0],e[1],i,r),[e[0]]),a=n.reshapePacked(e[1],[o[0],o[1]*o[2]*o[3]]),u=e.length===3?[a,s,e[2]]:[a,s],l=n.run(ei(n,u,r),u);return n.reshapePacked(l,i)}});var j0,q0,kd,Ua,Ha=k(()=>{"use strict";_e();j0=n=>({name:"Im2Col",inputNames:["X"],inputTypes:[0],cacheHint:n}),q0=(n,e,r,t,o,i)=>{let s=r.dims,a=t.dims,u=o.length,l=Ua(s,a,o,4),d=`
        const int XC = ${s[1]};
        const int XH = ${s[2]};
        const int XW = ${s[3]};
        const int KH = ${i.kernelShape[0]};
        const int KW = ${i.kernelShape[1]};
        const int dilationH = ${i.dilations[0]};
        const int dilationW = ${i.dilations[1]};
        const int strideH = ${i.strides[0]};
        const int strideW = ${i.strides[1]};
        const int padH = ${i.pads[0]};
        const int padW = ${i.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${u}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${s.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return{...e,output:{dims:l,type:r.type,textureType:4},shaderSource:d}},kd=(n,e,r,t,o)=>{let i=j0(o.cacheKey);return{...i,get:()=>q0(n,i,e,r,t,o)}},Ua=(n,e,r,t=4)=>[r[0],r[2],r[3],Math.ceil(n[1]*e[2]*e[3]/t)]});var K0,Y0,Bd,Rd=k(()=>{"use strict";Me();Xe();_e();qr();Ha();K0=(n,e)=>({name:"ConvDotProduct",inputNames:n?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:n?[0,4,0]:[0,4],cacheKey:e.activationCacheKey}),Y0=(n,e,r,t,o)=>{let i=r[0].dims,s=r[1].dims,a=[s[0],Math.ceil(i[1]*s[2]*s[3]/4)],u=Ua(i,s,t),[l,d]=n.calculateTextureWidthAndHeight(a,4),p=Q.computeStrides(u),[h,g]=n.calculateTextureWidthAndHeight(u,4),y=t.length,b=r.length<3?"0.0":"_B(b)",w=Math.ceil(i[1]*s[2]*s[3]/4),{activationFunction:I,applyActivation:O}=or(o),E=ue(n.session.backend.glContext.version),N=`
${I}
float process(int indices[${y}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${p[0]} + im2col[1] * ${p[1]} + im2col[2] * ${p[2]};
  int kernelOffset = indices[1] * ${a[1]};
  float value = ${b};
  for (int i = 0; i < ${w}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${h}, ${g});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${l}, ${d});
    value += dot(${E.texture2D}(Im2Col, im2colCoords), ${E.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${O}
  return value;
}`;return{...e,output:{dims:t,type:r[0].type,textureType:0},shaderSource:N}},Bd=(n,e,r,t)=>{let o=K0(e.length>2,t);return{...o,get:()=>Y0(n,o,e,r,t)}}});var yn,ja,X0,J0,Z0,Q0,qa,ev,Zo=k(()=>{"use strict";ct();Me();_d();Dd();Rd();qr();Ha();Qo();yn=(n,e,r,t,o)=>{let i=n[0],s=n.slice(2),a=s.length,u=e[0],d=e.slice(2).map((y,b)=>y+(y-1)*(r[b]-1)),h=s.map((y,b)=>y+t[b]+t[b+a]).map((y,b)=>Math.floor((y-d[b]+o[b])/o[b]));return[i,u].concat(...h)},ja=(n,e,r)=>(ev(e,r),X0(n,e,r)),X0=(n,e,r)=>{let t=Q0(r,e),o=n.session.pack,i=t.kernelShape[0]===1&&t.kernelShape[1]===1;return t.group>1?[n.run(Sd(n,e,t),e)]:i&&o?[J0(n,e,t)]:o&&e[0].dims.length===4&&e[0].dims[0]===1&&!i?[Pd(n,e,t)]:[Z0(n,e,t)]},J0=(n,e,r)=>{let t=e[0].dims,o=e[1].dims,i=yn(t,o,r.dilations,r.pads,r.strides),s=n.reshapeUnpacked(e[0],[t[1],t[2]*t[3]]),a=n.reshapeUnpacked(e[1],[o[0],o[1]]),u=e.length>2?[a,s,e[2]]:[a,s],l=n.run(Ga(u,r),u);return n.reshapeUnpacked(l,i)},Z0=(n,e,r)=>{let t=e[0].dims,o=e[1].dims,i=yn(t,o,r.dilations,r.pads,r.strides),s=n.run(kd(n,e[0],e[1],i,r),[e[0]]),a=e.length===3?[s,e[1],e[2]]:[s,e[1]];return n.run(Bd(n,e,i,r),a)},Q0=(n,e)=>{let r=n.kernelShape.slice();if(n.kernelShape.length===0)for(let i=2;i<e[1].dims.length;++i)r.push(e[1].dims[i]);let t=n.pads.slice();Wr.adjustPadsBasedOnAutoPad(e[0].dims,n.strides,n.dilations,r,t,n.autoPad);let o=Object.assign({},n);return Object.assign(o,{kernelShape:r,pads:t,cacheKey:n.cacheKey}),o},qa=n=>{let e=n.attributes,r=bn(e),t=e.getString("auto_pad","NOTSET"),o=e.getInts("dilations",[1,1]),i=e.getInt("group",1),s=e.getInts("kernel_shape",[]),a=e.getInts("pads",[0,0,0,0]),u=e.getInts("strides",[1,1]);return we({autoPad:t,dilations:o,group:i,kernelShape:s,pads:a,strides:u,...r})},ev=(n,e)=>{if(!n||n.length!==2&&n.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(n[0].dims.length!==4||n[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let r=n[0].dims[1],t=n[1].dims[1]*e.group;if(r!==t)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(n.length===3&&(n[2].dims.length!==1||n[1].dims[0]!==n[2].dims[0]))throw new Error("invalid bias");let o=n[0].dims.length-2;if(e.dilations.length!==o)throw new Error(`dilations should be ${o}D`);if(e.strides.length!==o)throw new Error(`strides should be ${o}D`);if(e.pads.length!==o*2)throw new Error(`pads should be ${o*2}D`);if(e.kernelShape.length!==0&&e.kernelShape.length!==n[1].dims.length-2)throw new Error("invalid kernel shape");if(n[0].type!=="float32"||n[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(n.length===3&&n[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}});var tv,rv,nv,Md,ov,iv,av,sv,uv,lv,Ld,cv,Nd=k(()=>{"use strict";ct();Xe();_e();qr();tv=(n,e,r,t,o,i)=>(n-1)*e+r+(t-1)*o+1-i,rv=(n,e,r,t,o)=>{let i=Math.floor(n/2);e==="SAME_UPPER"?(r[t]=i,r[o]=n-i):e==="SAME_LOWER"&&(r[t]=n-i,r[o]=i)},nv=(n,e,r,t,o,i,s,a)=>{let u=n.length-2,l=a.length===0;for(let d=0;d<u;++d){let p=l?n[d+2]*i[d]:a[d],h=tv(n[d+2],i[d],o[d],e[d],r[d],p);rv(h,t,o,d,d+u),l&&a.push(i[d]*(n[d+2]-1)+s[d]+(e[d]-1)*r[d]+1-o[d]-o[d+u])}},Md=(n,e,r)=>(cv(e,r),ov(n,e,r)),ov=(n,e,r)=>{let t=lv(r,e);return[uv(n,e,t)]},iv=(n,e)=>({name:"ConvTranspose",inputNames:n?["X","W","B"]:["X","W"],inputTypes:n?[0,0,0]:[0,0],cacheHint:e}),av=(n,e,r,t)=>{let i=e.length>2?"getB(output_channel)":"0.0",s=e[0].dims,a=e[1].dims,u=a[1],l=a[0]/t.group,d=[e[0].dims[0],e[1].dims[1]*t.group,...t.outputShape],p=ue(n.session.backend.glContext.version),{activationFunction:h,applyActivation:g}=or(t),y=`
  const ivec2 strides = ivec2(${t.strides[0]}, ${t.strides[1]});
  const ivec2 pads = ivec2(${t.pads[0]}, ${t.pads[1]});
  ${h}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${u};
    int wOutChannel = output_channel - group_id * ${u};

    float value = ${i};
    for (int inChannelOffset = 0; inChannelOffset < ${l}; inChannelOffset++) {
      int input_channel = group_id * ${l} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${a[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${a[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${t.dilations[0]}, wHOff * ${t.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${s[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${s[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${g}
    ${p.output} = vec4(value, .0, .0, .0);
  }
`;return{...r,output:{dims:d,type:e[0].type,textureType:0},shaderSource:y,hasMain:!0}},sv=(n,e,r)=>{let t=iv(e.length>2,r.cacheKey);return{...t,get:()=>av(n,e,t,r)}},uv=(n,e,r)=>n.run(sv(n,e,r),e),lv=(n,e)=>{let r=n.kernelShape.slice();if(n.kernelShape.length===0)for(let a=2;a<e[1].dims.length;++a)r.push(e[1].dims[a]);let t=n.pads.slice(),o=n.outputShape.slice(),i=e[0].dims;nv(i,r,n.dilations,n.autoPad,t,n.strides,n.outputPadding,o);let s=Object.assign({},n);return Object.assign(s,{kernelShape:r,pads:t,outputShape:o,cacheKey:n.cacheKey}),s},Ld=n=>{let e=n.attributes,r=bn(e),t=e.getString("auto_pad","NOTSET"),o=e.getInts("dilations",[1,1]),i=e.getInt("group",1),s=e.getInts("kernel_shape",[]),a=e.getInts("output_padding",[0,0]),u=e.getInts("output_shape",[]),l=e.getInts("pads",[0,0,0,0]),d=e.getInts("strides",[1,1]);return we({autoPad:t,dilations:o,group:i,kernelShape:s,outputPadding:a,outputShape:u,pads:l,strides:d,...r})},cv=(n,e)=>{if(!n||n.length!==2&&n.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(n[0].dims.length!==4||n[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let r=n[0].dims[1],t=n[1].dims[0];if(r!==t)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let o=n[1].dims[1]*e.group;if(n.length===3&&(n[2].dims.length!==1||n[2].dims[0]!==o))throw new Error("invalid bias");let i=n[0].dims.length-2;if(e.dilations.length!==i)throw new Error(`dilations should be ${i}D`);if(e.strides.length!==i)throw new Error(`strides should be ${i}D`);if(e.pads.length!==i*2)throw new Error(`pads should be ${i*2}D`);if(e.outputPadding.length!==i)throw new Error(`output_padding should be ${i}D`);if(e.kernelShape.length!==0&&e.kernelShape.length!==n[1].dims.length-2)throw new Error("invalid kernel shape");if(e.outputShape.length!==0&&e.outputShape.length!==n[0].dims.length-2)throw new Error("invalid output shape");if(n[0].type!=="float32"||n[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(n.length===3&&n[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}});var Fd,Kr,zd,dv,Gd,fv,pv,hv,ti=k(()=>{"use strict";ct();Me();_e();Fd={name:"Transpose",inputNames:["A"],inputTypes:[0]},Kr=(n,e,r)=>(hv(e),[n.run({...Fd,cacheHint:r.cacheKey,get:()=>dv(n,e[0],r.perm)},e)]),zd=n=>we({perm:n.attributes.getInts("perm",[])}),dv=(n,e,r)=>{let t=e.dims;r=Gd(t,r);let o=fv(t,r),i=t.length,s=`
      ${pv("perm",r,i)}
      float process(int indices[${i}]) {
        int a[${i}];
        perm(a, indices);
        return _A(a);
      }`;return{...Fd,output:{dims:o,type:e.type,textureType:0},shaderSource:s}},Gd=(n,e)=>(e&&e.length!==n.length&&(e=[...n.keys()].reverse()),e),fv=(n,e)=>(e=Gd(n,e),Q.sortBasedOnPerm(n,e)),pv=(n,e,r)=>{let t=[];t.push(`void ${n}(out int a[${r}], int src[${r}]) {`);for(let o=0;o<r;++o)t.push(`	a[${e[o]}]=src[${o}];`);return t.push("	}"),t.join(`
`)},hv=n=>{if(!n||n.length!==1)throw new Error("Transpose requires 1 input.");if(n[0].type!=="float32"&&n[0].type!=="float64")throw new Error("input should be float tensor")}});var Wd,Vd,mv,Ud=k(()=>{"use strict";ti();Wd=(n,e,r)=>{mv(e);let t=r.blocksize,o=t*t,i=r.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],s=r.mode==="DCR"?[e[0].dims[0],t,t,e[0].dims[1]/o,e[0].dims[2],e[0].dims[3]]:[e[0].dims[0],e[0].dims[1]/o,t,t,e[0].dims[2],e[0].dims[3]],a=n.reshapeUnpacked(e[0],s),u={perm:i,cacheKey:`${i}`},[l]=Kr(n,[a],u),d=[e[0].dims[0],e[0].dims[1]/o,e[0].dims[2]*t,e[0].dims[3]*t];return[n.reshapeUnpacked(l,d)]},Vd=n=>{let e=n.attributes.getInt("blocksize");if(e<1)throw new Error(`blocksize must be >= 1, but got : ${e} for DepthToSpace`);let r=n.attributes.getString("mode","DCR");if(r!=="DCR"&&r!=="CRD")throw new Error(`unrecognized mode: ${r} for DepthToSpace`);return{mode:r,blocksize:e}},mv=n=>{if(n.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${n.length}`);if(n[0].type==="string"||n[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}});var Hd,jd,gv,qd=k(()=>{"use strict";Me();Hd=(n,e,r)=>{gv(e,r);let t=Q.flattenShape(e[0].dims,r);return[n.reshapeUnpacked(e[0],t)]},jd=n=>n.attributes.getInt("axis",1),gv=(n,e)=>{if(!n||n.length!==1)throw new Error("Flatten requires 1 input.");let r=n[0].dims.length;if(r===0)throw new Error("scalar tensor is not supported.");if(e<-r||e>r)throw new Error("Invalid axis");if(n[0].type==="string")throw new Error("string tensor is not supported.")}});var Sr,Qn=k(()=>{"use strict";Sr=["float32","float64","int32","int16","int8","uint16","uint32","uint8"]});var Kd,Yd,bv,yv,vv,xv,Xd=k(()=>{"use strict";ct();Qn();Me();_e();Kd=(n,e,r)=>(xv(e,r.axis),[n.run(vv(n,e,r),e)]),Yd=n=>we({axis:n.attributes.getInt("axis",0)}),bv={name:"Gather",inputNames:["A","B"],inputTypes:[0,0]},yv=(n,e,r,t)=>{let o=r[0].dims.slice(),i=r[1].dims.slice(),s=new Array(o.length+i.length-1);t=Q.normalizeAxis(t,o.length);let a=[];for(let h=0;h<s.length;h++)h<t?(s[h]=o[h],a.push(`inputIdx[${h}] = outputIdx[${h}];`)):h<t+i.length?(s[h]=i[h-t],a.push(`indexDataIdx[${h-t}] = outputIdx[${h}];`)):(s[h]=o[h-i.length+1],a.push(`inputIdx[${h-i.length+1}] = outputIdx[${h}];`));let u=s.length||1,l=o.length,d=i.length||1,p=`
      float process(int outputIdx[${u}]) {
        int inputIdx[${l}];
        int indexDataIdx[${d}];
        indexDataIdx[0] = 0;
        ${a.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${t}] = idx < 0 ? idx + ${o[t]} : idx;
        return _A(inputIdx);
      }`;return{...e,output:{dims:s,type:r[0].type,textureType:0},shaderSource:p}},vv=(n,e,r)=>{let t={...bv,cacheHint:r.cacheKey};return{...t,get:()=>yv(n,t,e,r.axis)}},xv=(n,e)=>{if(!n||n.length!==2)throw new Error("Gather requires 2 inputs.");let r=n[0].dims.length;if(r<1)throw new Error("Invalid input shape.");if(e<-r||e>r-1)throw new Error("Invalid axis.");if(Sr.indexOf(n[0].type)===-1)throw new Error("Invaid input type.");if(n[1].type!=="int32"&&n[1].type!=="int16")throw new Error("Invaid input type.")}});var Ka,Jd,Zd,Qd,wv,Tv,$v,ef=k(()=>{"use strict";ct();Me();_e();Ka=(n,e,r)=>($v(e,r),[n.run(wv(e,r),e)]),Jd=(n,e)=>{let r=n.attributes.getInt("transA",0)!==0,t=n.attributes.getInt("transB",0)!==0,o=n.attributes.getFloat("alpha",1),i=n.attributes.getFloat("beta",1);return we({transA:r,transB:t,alpha:o,beta:i,isOptionalC:e})},Zd=n=>Jd(n,!1),Qd=n=>Jd(n,!0),wv=(n,e)=>{let r={name:"Gemm",inputNames:n.length===3?["A","B","C"]:["A","B"],inputTypes:n.length===3?[0,0,0]:[0,0],key:e.cacheKey};return{...r,get:()=>Tv(r,n,e)}},Tv=(n,e,r)=>{let t=e[0].dims.slice(),o=e[1].dims.slice(),[i,s]=Uo.getShapeOfGemmResult(t,r.transA,o,r.transB,e.length===3?e[2].dims:void 0),a=[i,s];if(!a)throw new Error("Can't use gemm on the given tensors");let u=t[t.length-1],l="";r.transA&&(u=t[0]),r.transA&&r.transB?l="value += _A_T(a) * _B_T(b);":r.transA&&!r.transB?l="value += _A_T(a) * _B(b);":!r.transA&&r.transB?l="value += _A(a) * _B_T(b);":!r.transA&&!r.transB&&(l="value += _A(a) * _B(b);");let d=a.length,p=e.length===3?`int c[${e[2].dims.length}];`:"",h=e.length===3?"bcastIndices_C(indices, c);":"",g=e.length===3?"value += beta * _C(c);":"",y=`
      float process(int indices[${d}]) {
          int a[${d}];
          int b[${d}];
          ${p}

          copyVec(indices, a);
          copyVec(indices, b);
          ${h}

          float value = 0.0;
          for (int k=0; k<${u}; ++k) {
              a[${d-1}] = k;
              b[${d-2}] = k;
              ${l}
          }

          value = value * alpha;
          ${g}
          return value;
      }`;return{...n,output:{dims:a,type:e[0].type,textureType:0},variables:[{name:"alpha",type:"float",data:r.alpha},{name:"beta",type:"float",data:r.beta}],shaderSource:y}},$v=(n,e)=>{if(!n)throw new Error("Input is missing");if(e.isOptionalC&&(n.length<2||n.length>3))throw new Error("Invaid input shape.");if(!e.isOptionalC&&n.length!==3)throw new Error("Gemm requires 3 inputs");if(n.length===3&&n[2].dims.length!==1&&n[2].dims.length!==2)throw new Error("Invalid input shape of C");if(n[0].type!=="float32"&&n[0].type!=="float64"||n[1].type!=="float32"&&n[1].type!=="float64"||n.length===3&&n[2].type!=="float32"&&n[2].type!=="float64")throw new Error("Invalid input type.");if(n[0].type!==n[1].type||n.length===3&&n[0].type!==n[2].type)throw new Error("Input types are mismatched")}});var tf,rf,Iv,Sv,_v,Av,Ov,nf=k(()=>{"use strict";ct();_e();tf=(n,e,r)=>(Ov(e),[n.run(_v(n,e,r),e)]),rf=n=>{let e=n.attributes.getFloat("scale"),r=n.attributes.getFloats("bias");return we({scale:e,bias:r})},Iv={name:"ImageScaler",inputNames:["X"],inputTypes:[0]},Sv=(n,e,r,t)=>{let o=r[0].dims.slice(),i=o.length,a=`
      ${Av(t.bias.length)}
      float process(int indices[${i}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return{...e,output:{dims:o,type:r[0].type,textureType:0},variables:[{name:"bias",type:"float",arrayLength:t.bias.length,data:t.bias},{name:"scale",type:"float",data:t.scale}],shaderSource:a}},_v=(n,e,r)=>{let t={...Iv,cacheHint:r.cacheKey};return{...t,get:()=>Sv(n,t,e,r)}},Av=n=>{let e=[`float getBias(float bias[${n}], int channel) {`];for(let r=0;r<n;++r)r===0?e.push(`	if (channel == ${r}) { return bias[${r}]; }`):r===n-1?e.push(`	else { return bias[${r}]; }`):e.push(`	else if (channel == ${r}) { return bias[${r}]; }`);return e.push("	}"),e.join(`
`)},Ov=n=>{if(!n||n.length!==1)throw new Error("ImageScaler requires 1 input.");if(n[0].dims.length!==4)throw new Error("Invalid input shape.");if(n[0].type!=="float32"&&n[0].type!=="float64")throw new Error("Invalid input type.")}});var af,sf,of,Ev,Cv,Pv,Dv,kv,Bv,uf=k(()=>{"use strict";Xe();_e();af=(n,e,r)=>{Bv(e);let t=n.run(Cv(e[0]),e);return[n.run(kv(n,e[0],r,t.dims),[e[0],t,e[1],e[2]])]},sf=n=>n.attributes.getFloat("epsilon",1e-5),of={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[0]},Ev=(n,e)=>{let r=e.dims.slice(),t=r[1],o=r[2]*r[3],i=[r[0],t],s=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${r[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${r[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${o});
        temp = 0.0;
        for(int a2=0; a2<${r[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${r[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${o});

        return v;
      }`;return{...n,output:{dims:i,type:e.type,textureType:4},shaderSource:s}},Cv=n=>({...of,get:()=>Ev(of,n)}),Pv={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[0,4,0,0]},Dv=(n,e,r,t,o)=>{let i=ue(n.session.backend.glContext.version),[s,a]=n.calculateTextureWidthAndHeight(o,4),[u,l]=[s/4,a],d=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${u}, ${l});
        return ${i.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return{...e,output:{dims:r.dims,type:r.type,textureType:0},variables:[{name:"epsilon",type:"float",data:t}],shaderSource:d}},kv=(n,e,r,t)=>{let o={...Pv,cacheHint:`${r}`};return{...o,get:()=>Dv(n,o,e,r,t)}},Bv=n=>{if(!n||n.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");let e=n[0],r=n[1],t=n[2];if(e.dims.length<3||r.dims.length!==1||t.dims.length!==1)throw new Error("Invalid input shape.");if(r.dims[0]!==e.dims[1]||t.dims[0]!==e.dims[1])throw new Error("Input shapes are mismatched.");if(e.type!=="float32"&&e.type!=="float64"||r.type!=="float32"&&r.type!=="float64"||t.type!=="float32"&&t.type!=="float64")throw new Error("Invalid input type.");if(n[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}});function Rv(n,e){let r=n[0].dims[1],t=n[0].dims.length,o=-Math.floor((e.size-1)/2),i=Math.ceil((e.size-1)/2),s=`float(${e.alpha}) / float(${e.size})`,a=`float(${e.bias})`,u=`float(${e.beta})`,l=`
    float process(int indices[${t}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${o}; i <= ${i}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${r}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(${a} + ${s} * square_sum, ${u});
    }`;return{...df,cacheHint:e.cacheKey,output:{dims:n[0].dims,type:n[0].type,textureType:0},shaderSource:l}}function Mv(n,e){return{...df,cacheHint:e.cacheKey,get:()=>Rv(n,e)}}var lf,cf,df,Lv,ff=k(()=>{"use strict";ct();_e();lf=(n,e,r)=>(Lv(e),[n.run(Mv(e,r),e)]),cf=n=>{let e=n.attributes.getFloat("alpha",1e-4),r=n.attributes.getFloat("beta",.75),t=n.attributes.getFloat("bias",1),o=n.attributes.getInt("size");return we({alpha:e,beta:r,bias:t,size:o})},df={name:"LRN",inputNames:["X"],inputTypes:[0]};Lv=n=>{if(!n||n.length!==1)throw new Error("LRN requires 1 input.");if(n[0].dims.length!==4)throw new Error('currently only support LRN for input with "NCHW" format');if(n[0].type!=="float32")throw new Error("input should be float type")}});var Nv,Ya,pf,hf,mf,Fv,zv,Gv,Wv,Vv,Uv,Hv,jv,gf=k(()=>{"use strict";ct();Me();Xe();_e();Nv={name:"Pad",inputNames:["A"],inputTypes:[0]},Ya=(n,e,r)=>(Gv(e),[n.run({...Nv,cacheHint:r.cacheKey,get:()=>zv(n,e[0],r)},e)]),pf=n=>{let e=n.attributes.getString("mode","constant"),r=n.attributes.getFloat("value",0),t=n.attributes.getInts("pads");return we({mode:e,value:r,pads:t})},hf=(n,e,r)=>{Wv(e);let t=Fv(n,e,r);return Ya(n,[e[0]],t)},mf=n=>n.attributes.getString("mode","constant"),Fv=(n,e,r)=>{if(!n.session.isInitializer(e[1].dataId)||e.length>=3&&!n.session.isInitializer(e[2].dataId))throw new Error("dynamic pad attributes are not allowed");let t=Array.from(e[1].integerData),o=e.length>=3?e[2].floatData[0]:0;return we({mode:r,pads:t,value:o})},zv=(n,e,r)=>{let t=Q.padShape(e.dims.slice(),r.pads),o=t.length,s=`
      ${Vv(n,e,r)}
      float process(int[${o}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[0],output:{dims:t,type:e.type,textureType:0},shaderSource:s}},Gv=n=>{if(!n||n.length!==1)throw new Error("Pad requires 1 input");if(n[0].type!=="float32"&&n[0].type!=="float64")throw new Error("Invalid input type.")},Wv=n=>{if(!n||n.length!==2&&n.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(n[1].type!=="int32")throw new Error("Invalid input type.");if(n.length>=3&&n[2].type==="string")throw new Error("Invalid input type.")},Vv=(n,e,r)=>{let t=ue(n.session.backend.glContext.version),[o,i]=n.calculateTextureWidthAndHeight(e.dims,0),s=Q.computeStrides(e.dims);switch(r.mode){case"constant":return Uv(t,e.dims,s,o,i,r.pads,r.value);case"reflect":return Hv(t,e.dims,s,o,i,r.pads);case"edge":return jv(t,e.dims,s,o,i,r.pads);default:throw new Error("Invalid mode")}},Uv=(n,e,r,t,o,i,s)=>{let a=e.length,u="";for(let l=a-1;l>=0;--l)u+=`
        k = m[${l}] - ${i[l]};
        if (k < 0)  return constant;
        if (k >= ${e[l]}) return constant;
        offset += k * ${r[l]};
        `;return`
      float padA(int m[${a}]) {
        const float constant = float(${s});
        int offset = 0;
        int k = 0;
        ${u}
        vec2 coords = offsetToCoords(offset, ${t}, ${o});
        float value = getColorAsFloat(${n.texture2D}(A, coords));
        return value;
      }
      `},Hv=(n,e,r,t,o,i)=>{let s=e.length,a="";for(let u=s-1;u>=0;--u)a+=`
        k = m[${u}] - ${i[u]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(e[u]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${e[u]}) { k = _2n_1 - k; }
        }
        offset += k * ${r[u]};
        `;return`
      float padA(int m[${s}]) {
        int offset = 0;
        int k = 0;
        ${a}
        vec2 coords = offsetToCoords(offset, ${t}, ${o});
        float value = getColorAsFloat(${n.texture2D}(A, coords));
        return value;
      }
      `},jv=(n,e,r,t,o,i)=>{let s=e.length,a="";for(let u=s-1;u>=0;--u)a+=`
        k = m[${u}] - ${i[u]};
        if (k < 0)  k = 0;
        if (k >= ${e[u]}) k = ${e[u]-1};
        offset += k * ${r[u]};
      `;return`
      float padA(int m[${s}]) {
        int offset = 0;
        int k = 0;
        ${a}
        vec2 coords = offsetToCoords(offset, ${t}, ${o});
        float value = getColorAsFloat(${n.texture2D}(A, coords));
        return value;
      }
      `}});var yf,vf,xf,wf,Tf,$f,If,Sf,_f,qv,bf,Af,ni,Of,ri,Kv,Ef=k(()=>{"use strict";ct();Me();_e();yf=(n,e,r)=>{ni(e);let t={name:"AveragePool",inputNames:["X"],inputTypes:[0],cacheHint:r.cacheKey};return[n.run({...t,get:()=>xf(e,t,!1,r)},e)]},vf=n=>{let e=n.attributes.getString("auto_pad","NOTSET"),r=n.attributes.getInt("ceil_mode",0),t=n.attributes.getInt("count_include_pad",0)!==0,o=n.attributes.getInts("kernel_shape"),i=n.attributes.getInts("strides",[]),s=n.attributes.getInts("pads",[]);if(r!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return we({autoPad:e,ceilMode:r,countIncludePad:t,kernelShape:o,strides:i,pads:s})},xf=(n,e,r,t)=>{let[o,i]=_f(n,t,r),s=Q.size(o.kernelShape),a="value += _X(x);",u="";o.countIncludePad?u+=`value /= float(${s});`:u+=`value /= float(${s} - pad);`;let d=`
        ${Of(n[0].dims,o,a,u,"0.0")}
      `;return{...e,output:{dims:i,type:n[0].type,textureType:0},shaderSource:d}},wf=(n,e,r)=>{ni(e);let t={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[0],cacheHint:`${r.countIncludePad}`};return[n.run({...t,get:()=>xf(e,t,!0,r)},e)]},Tf=n=>{let e=n.attributes.getInt("count_include_pad",0)!==0;return we({autoPad:"",ceilMode:0,countIncludePad:e,kernelShape:[],strides:[],pads:[]})},$f=(n,e,r)=>{ni(e);let t={name:"MaxPool",inputNames:["X"],inputTypes:[0],cacheHint:r.cacheKey};return[n.run({...t,get:()=>Sf(e,t,!1,r)},e)]},If=n=>{let e=n.attributes.getString("auto_pad","NOTSET"),r=n.attributes.getInt("ceil_mode",0),t=n.attributes.getInts("kernel_shape"),o=n.attributes.getInts("strides",[]),i=n.attributes.getInts("pads",[]),s=n.attributes.getInt("storage_order",0),a=n.attributes.getInts("dilations",[]);if(s!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(r!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return we({autoPad:e,ceilMode:r,countIncludePad:!1,kernelShape:t,strides:o,pads:i,storageOrder:s,dilations:a})},Sf=(n,e,r,t)=>{let[o,i]=_f(n,t,r),s=`
      value = max(_X(x), value);
    `,a="",l=`
      ${Of(n[0].dims,o,s,a,"-1e5")}
    `;return{...e,output:{dims:i,type:n[0].type,textureType:0},shaderSource:l}},_f=(n,e,r)=>{let t=n[0].dims.slice(),o=Object.hasOwnProperty.call(e,"dilations"),i=e.kernelShape.slice(),s=e.strides.slice(),a=o?e.dilations.slice():[],u=e.pads.slice();Wr.adjustPoolAttributes(r,t,i,s,a,u);let l=Wr.computePoolOutputShape(r,t,s,a,i,u,e.autoPad),d=Object.assign({},e);return o?Object.assign(d,{kernelShape:i,strides:s,pads:u,dilations:a,cacheKey:e.cacheKey}):Object.assign(d,{kernelShape:i,strides:s,pads:u,cacheKey:e.cacheKey}),[d,l]},qv={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},bf={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[0]},Af=(n,e)=>(ni(e),[n.run({...bf,get:()=>Sf(e,bf,!0,qv)},e)]),ni=n=>{if(!n||n.length!==1)throw new Error("Pool ops requires 1 input.");if(n[0].type!=="float32"&&n[0].type!=="float64")throw new Error("Invalid input type.")},Of=(n,e,r,t,o)=>{let i=n.length;if(e.kernelShape.length<=2){let s=e.kernelShape[e.kernelShape.length-1],a=e.strides[e.strides.length-1],u=e.pads[e.pads.length/2-1],l=e.pads[e.pads.length-1],d=n[i-1],p="",h="",g="";if(u+l!==0?p=`
          for (int i = 0; i < ${s}; i++) {
            x[${i} - 1] = indices[${i} - 1] * ${a} - ${u} + i;
            if (x[${i} - 1] < 0 || x[${i} - 1] >= ${d}) {
              pad++;
              continue;
            }
            ${r}
          }`:p=`
          for (int i = 0; i < ${s}; i++) {
            x[${i} - 1] = indices[${i} - 1] * ${a} - ${u} + i;
            ${r}
          }`,e.kernelShape.length===2){let b=e.kernelShape[e.kernelShape.length-2],w=e.strides[e.strides.length-2],I=e.pads[e.pads.length/2-2],O=e.pads[e.pads.length-2],E=n[i-2];I+O!==0?h=`
            for (int j = 0; j < ${b}; j++) {
              x[${i} - 2] = indices[${i} - 2] * ${w} - ${I} + j;
              if (x[${i} - 2] < 0 || x[${i} - 2] >= ${E}) {
                pad+= ${s};
                continue;
              }
          `:h=`
            for (int j = 0; j < ${b}; j++) {
              x[${i} - 2] = indices[${i} - 2] * ${w} - ${I} + j;
            `,g=`
          }
        `}return`
        float process(int indices[${i}]) {
          int x[${i}];
          copyVec(indices, x);

          float value = ${o};
          int pad = 0;
          ${h}
          ${p}
          ${g}
          ${t}
          return value;
        }
      `}else{let s=Q.size(e.kernelShape),a=Q.computeStrides(e.kernelShape),u=a.length,l=e.pads.length,d=Kv(u),p=ri(n,"inputDims"),h=ri(e.pads,"pads"),g=ri(a,"kernelStrides"),y=ri(e.strides,"strides"),b=e.pads.reduce((O,E)=>O+E),w="";return b?w=`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${r}
          }`:w=`
          }
          ${r}
        `,`
        ${d}
        float process(int indices[${i}]) {
          int x[${i}];
          copyVec(indices, x);
          int offset[${u}];
          int pads[${l}];
          int inputDims[${i}];
          int kernelStrides[${u}];
          int strides[${u}];
          ${h}
          ${p}
          ${y}
          ${g}

          float value = ${o};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${s}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${i} - ${u}; j < ${i}; j++) {
              x[j] = indices[j] * strides[j - ${i} + ${u}]
                + offset[j - ${i} + ${u}] - pads[j - 2];
              ${w}
          }
          ${t}

          return value;
        }
      `}},ri=(n,e)=>{let r="";for(let t=0;t<n.length;t++)r+=`
      ${e}[${t}] = ${n[t]};
    `;return r},Kv=n=>`
  void offsetToIndices(int offset, int[${n}] strides, out int[${n}] indices) {
    if (${n} == 0) {
      return;
    }
    for (int i = 0; i < ${n} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${n} - 1] = offset;
  }`});var Yr,_r,Yv,Xv,Cf,Pf,Df,kf,Bf,Rf,Mf,Lf=k(()=>{"use strict";ct();Qn();Me();_e();Yr=(n,e,r,t,o)=>{Xv(e);let i={name:t,inputNames:["A"],inputTypes:[0]};return[n.run({...i,cacheHint:r.cacheKey,get:()=>Yv(n,e,r,t,o,i)},e)]},_r=n=>{let e=n.attributes.getInts("axes",[]),r=n.attributes.getInt("keepdims",1)===1;return we({axes:e,keepDims:r})},Yv=(n,e,r,t,o,i)=>{let s=[],a=e[0].dims.length||1,u=[],l=Q.normalizeAxes(r.axes,e[0].dims.length),d=o(e,l),p=d[1];for(let y=0;y<e[0].dims.length;y++)l.indexOf(y)>=0||l.length===0?(r.keepDims&&s.push(1),p=`
          for(int j${y} = 0; j${y} < ${e[0].dims[y]}; j${y}++) {
            inputIdx[${y}] = j${y};
            ${p}
          }`):(u.push(`inputIdx[${y}] = outputIdx[${s.length}];`),s.push(e[0].dims[y]));let g=`
      float process(int outputIdx[${s.length||1}]) {
        float value;                 // final result
        int inputIdx[${a}];      // addressing input data
        ${u.join(`
`)}
        ${d[0]}       // init ops for reduce max/min
        ${p}
        ${d[2]}       // final computation for reduce mean
        return value;
      }`;return{...i,output:{dims:s,type:e[0].type,textureType:0},shaderSource:g}},Xv=n=>{if(!n||n.length!==1)throw new Error("Reduce op requires 1 input.");if(Sr.indexOf(n[0].type)===-1)throw new Error("Invalid input type.")},Cf=(n,e,r)=>Yr(n,e,r,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),Pf=(n,e,r)=>Yr(n,e,r,"ReduceMean",(o,i)=>{let s=1;for(let a=0;a<o[0].dims.length;a++)(i.indexOf(a)>=0||i.length===0)&&(s*=o[0].dims[a]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${s}.;`]}),Df=(n,e,r)=>Yr(n,e,r,"ReduceMax",(o,i)=>{let s=[];for(let a=0;a<o[0].dims.length;a++)(i.indexOf(a)>=0||i.length===0)&&s.push(`inputIdx[${a}] = 0;`);return[`${s.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),kf=(n,e,r)=>Yr(n,e,r,"ReduceMin",(o,i)=>{let s=[];for(let a=0;a<o[0].dims.length;a++)(i.indexOf(a)>=0||i.length===0)&&s.push(`inputIdx[${a}] = 0;`);return[`${s.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),Bf=(n,e,r)=>Yr(n,e,r,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),Rf=(n,e,r)=>Yr(n,e,r,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),Mf=(n,e,r)=>Yr(n,e,r,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])});var Nf,Ff=k(()=>{"use strict";Me();Nf=(n,e)=>{let r=Q.calculateReshapedDims(e[0].dims,e[1].integerData);return n.session.pack?[n.reshapePacked(e[0],r)]:[n.reshapeUnpacked(e[0],r)]}});var zf,Xa,Gf,Wf,eo,Jv,Ja,oi,Za=k(()=>{"use strict";ct();Xe();_e();zf={name:"Upsample",inputNames:["X"],inputTypes:[0]},Xa=(n,e,r)=>(Ja(e,r),[n.run({...zf,cacheHint:r.cacheKey,get:()=>Jv(n,e,r)},e)]),Gf=n=>eo(n,7),Wf=n=>eo(n,9),eo=(n,e)=>{let r=e>=10,t=n.attributes.getString("mode","nearest");if(t!=="nearest"&&t!=="linear"&&(e<11||t!=="cubic"))throw new Error(`unrecognized mode: ${t}`);let o=[];e<9&&(o=n.attributes.getFloats("scales"),oi(o,t,r));let i=n.attributes.getFloat("extrapolation_value",0),s=e>10?n.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(s)===-1)throw new Error(`coordinate_transform_mode '${s}' is not supported`);let a=s==="tf_crop_and_resize",u=a,l=t==="nearest"&&e>=11?n.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(l)===-1)throw new Error(`nearest_mode '${l}' is not supported`);let d=n.attributes.getFloat("cubic_coeff_a",-.75),p=n.attributes.getInt("exclude_outside",0)!==0;if(p&&t!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");let h=e<11?!0:t==="nearest"&&s==="asymmetric"&&l==="floor",g=0,y=0,b=0;return e>10?n.inputs.length>2?(g=1,y=2,b=3):(y=1,b=2):e===9&&(y=1),we({opset:e,isResize:r,mode:t,scales:o,extrapolationValue:i,coordinateTransformMode:s,useExtrapolation:u,needRoiInput:a,nearestMode:l,cubicCoefficientA:d,excludeOutside:p,useNearest2xOptimization:h,roiInputIdx:g,scalesInputIdx:y,sizesInputIdx:b})},Jv=(n,e,r)=>{let t=ue(n.session.backend.glContext.version),[o,i]=n.calculateTextureWidthAndHeight(e[0].dims,0),s=e[0].dims.map((b,w)=>Math.floor(b*r.scales[w])),[a,u]=n.calculateTextureWidthAndHeight(s,0),l=s.length,d=new Array(l),p=new Array(l),h=`
      int output_pitches[${l}];
      int input_pitches[${l}];
      `;for(let b=l-1;b>=0;b--)d[b]=b===l-1?1:d[b+1]*s[b+1],p[b]=b===l-1?1:p[b+1]*e[0].dims[b+1],h+=`
        output_pitches[${b}] = ${d[b]};
        input_pitches[${b}] = ${p[b]};
        `;let g=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${o}, ${i});
        float value = getColorAsFloat(${t.texture2D}(X, coords));
        return value;
      }
      `,y=r.mode==="nearest"?`
    ${g}
    float process(int indices[${l}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${a}, ${u});

      ${h}

      int d, m;
      for (int dim = 0; dim < ${l}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:l===4?`
    ${g}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${a}, ${u});

      ${h}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${e[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${g}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${a}, ${u});

      ${h}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${e[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return{...zf,output:{dims:s,type:e[0].type,textureType:0},shaderSource:y,variables:[{name:"scales",type:"int",arrayLength:r.scales.length,data:r.scales.map(b=>Math.ceil(b))}]}},Ja=(n,e)=>{if(!n||e.opset<9&&n.length!==1||e.opset>=9&&e.opset<11&&n.length!==2||e.opset>=11&&n.length<2)throw new Error("invalid inputs.");if(e.scales.length>0&&n[0].dims.length!==e.scales.length)throw new Error("Invalid input shape.");if(n[0].type==="string")throw new Error("Invalid input tensor types.")},oi=(n,e,r)=>{if(r){for(let t of n)if(t<=0)throw new Error("Scale value should be greater than 0.")}else for(let t of n)if(t<1)throw new Error("Scale value should be greater than or equal to 1.");if((e==="linear"||e==="cubic")&&n.length!==2&&(n.length!==4||n[0]!==1||n[1]!==1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${r?"Resize":"Upsample"} opeartor.`)}});var Qa,es,Vf,Uf,Zv,Qv,ex,tx,Hf=k(()=>{"use strict";Xe();_e();rr();jr();Za();Qa={name:"Resize",inputNames:["A"],inputTypes:[2]},es=(n,e,r)=>(Ja(e,r),[n.run({...Qa,cacheHint:r.cacheKey,get:()=>Zv(n,e,r)},e)]),Vf=n=>eo(n,10),Uf=n=>eo(n,11),Zv=(n,e,r)=>{let t=ue(n.session.backend.glContext.version),[o,i]=Qv(e,r);if(o.every(E=>E===1)&&r.coordinateTransformMode!=="tf_crop_and_resize")return{...Qa,output:{dims:i,type:e[0].type,textureType:2},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${t.texture2D}(X, TexCoords);
                    ${t.output} = v;
                }`};let a=i.length;if(a<2)throw new Error(`output dimension should be at least 2, but got ${a}`);let u=i[a-2],l=i[a-1],d=e[0].dims;if(a!==d.length)throw new Error(`output dimension should match input ${d.length}, but got ${a}`);let p=d[a-2],h=d[a-1],g=o[a-2],y=o[a-1],b="";if(r.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${r.mode}'`);switch(r.coordinateTransformMode){case"asymmetric":b=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":b=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":b=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${l}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${u}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${l}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${u}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":b=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${l}.0 - 1.0, ${u}.0 - 1.0, ${l}.0 - 1.0,
                            ${u}.0 - 1.0);
                        vec4 original = vec4(${h}.0 - 1.0, ${p}.0 - 1.0, ${h}.0 - 1.0,
                            ${p}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${r.coordinateTransformMode}'`)}let w=xt(a),I=nr(),O=`
            const vec2 inputWH = vec2(${p}.0, ${h}.0);
            const vec4 scaleWHWH = vec4(float(${g}), float(${y}), float(${g}), float(${y}));
            ${I}
            ${b}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${w} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${u-1};
                bool hasNextCol = rc.z < ${l-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${t.output} = vec4(newValue);
            }
        `;return{...Qa,output:{dims:i,type:e[0].type,textureType:2},hasMain:!0,shaderSource:O}},Qv=(n,e)=>{let t=n[0].dims,o=e.scales,i;if(o.length===0){let a=n[e.scalesInputIdx];if(a&&a.size!==0){if(n[e.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");o=ex(a,e.mode,e.isResize)}else{let u=n[e.sizesInputIdx];if(!u||u.size===0)throw new Error("Either scales or sizes MUST be provided as input.");i=Array.from(u.integerData),o=tx(i,t,e.mode,e.isResize)}}else if(n[e.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");let s=i||t.map((a,u)=>Math.floor(a*o[u]));return[o,s]},ex=(n,e,r)=>{let t=Array.from(n.floatData);return oi(t,e,r),t},tx=(n,e,r,t)=>{let o=e.length,i=new Array(o);for(let s=0,a=o;s<a;s++)if(e[s]===0){if(n[s]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");i[s]=1}else i[s]=n[s]/e[s];return oi(i,r,t),i}});var jf,rx,qf=k(()=>{"use strict";Hr();jf=(n,e)=>(rx(e),[new at([e[0].dims.length],"int32",void 0,void 0,new Int32Array(e[0].dims))]),rx=n=>{if(!n||n.length!==1)throw new Error("Shape requires 1 input.")}});var ts,Kf,Yf,Xf,nx,Jf,ox,ix,Zf=k(()=>{"use strict";ct();Qn();Me();_e();ts={name:"Slice",inputNames:["A"],inputTypes:[0]},Kf=(n,e,r)=>(nx(e),[n.run({...ts,cacheHint:r.cacheKey,get:()=>Xf(n,e[0],r)},e)]),Yf=n=>{let e=n.attributes.getInts("starts"),r=n.attributes.getInts("ends"),t=n.attributes.getInts("axes",[]);return we({starts:e,ends:r,axes:t})},Xf=(n,e,r)=>{let t=r.axes.length===0?e.dims.slice(0).map((p,h)=>h):r.axes,o=Q.normalizeAxes(t,e.dims.length),i=r.starts.map((p,h)=>p>e.dims[o[h]]-1?e.dims[o[h]]:Q.normalizeAxis(p,e.dims[o[h]])),s=r.ends.map((p,h)=>p>e.dims[o[h]]-1?e.dims[o[h]]:Q.normalizeAxis(p,e.dims[o[h]])),a=e.dims.slice(),u=[];for(let p=0;p<o.length;p++)a[o[p]]=s[p]-i[p],i[p]>0&&u.push(`outputIdx[${o[p]}] += ${i[p]};`);let d=`
      float process(int outputIdx[${a.length}]) {
        ${u.join(`
      `)}
        return _A(outputIdx);
      }`;return{...ts,output:{dims:a,type:e.type,textureType:0},shaderSource:d}},nx=n=>{if(!n||n.length!==1)throw new Error("Slice requires 1 input.");if(Sr.indexOf(n[0].type)===-1)throw new Error("Invalid input type.")},Jf=(n,e)=>{ix(e);let r=ox(n,e);return[n.run({...ts,cacheHint:r.cacheKey,get:()=>Xf(n,e[0],r)},[e[0]])]},ox=(n,e)=>{if(!n.session.isInitializer(e[1].dataId)||!n.session.isInitializer(e[2].dataId)||e.length>=4&&!n.session.isInitializer(e[3].dataId)||e.length>=5&&!n.session.isInitializer(e[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(e.length>=5&&e[4].integerData.some(s=>s!==1))throw new Error("currently non-1 steps is not supported for Slice");let r=Array.from(e[1].integerData),t=Array.from(e[2].integerData),o=e.length>=4?Array.from(e[3].integerData):[],i=`${o};${r};${t}`;return{starts:r,ends:t,axes:o,cacheKey:i}},ix=n=>{if(!n||n.length<3||n.length>5)throw new Error("Invalid input number.");if(n[1].type!=="int32"||n[1].dims.length!==1)throw new Error("Invalid input type.");if(n[2].type!=="int32"||n[2].dims.length!==1)throw new Error("Invalid input type.");if(n.length>=4&&(n[3].type!=="int32"||n[3].dims.length!==1))throw new Error("Invalid input type.");if(n.length>=5&&(n[4].type!=="int32"||n[4].dims.length!==1))throw new Error("Invalid input type.")}});var Qf,ep,tp,rp,np,op,ip,ap,ax,sx,ux,sp,up=k(()=>{"use strict";ct();Me();Xe();_e();ti();Qf={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[0]},ep={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[0,0]},tp={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[0,0,0]},rp=(n,e,r)=>{sp(e);let t=e[0].dims.slice(),o=Q.normalizeAxis(r.axis,t.length),i=Q.sizeToDimension(t,o),s=Q.sizeFromDimension(t,o);return ap(n,e,r,i,s)},np=n=>we({axis:n.attributes.getInt("axis",1)}),op=n=>we({axis:n.attributes.getInt("axis",-1)}),ip=(n,e,r)=>{sp(e);let t=e[0].dims.slice(),o=Q.normalizeAxis(r.axis,t.length),i=t.length,s=o!==i-1,a=[],u=[],l=[],d;s&&(u=Array.from({length:i}).map((y,b)=>b),u[o]=i-1,u[i-1]=o,u.map(y=>a.push(t[y])),d=we({perm:u}),l=Kr(n,e,d));let p=s?Q.sizeToDimension(a,i-1):Q.sizeToDimension(t,i-1),h=s?Q.sizeFromDimension(a,i-1):Q.sizeFromDimension(t,i-1),g=ap(n,s?l:e,r,p,h);return s?Kr(n,g,d):g},ap=(n,e,r,t,o)=>{let i=ax(n,e[0],t,o,[t]),s=n.run({...Qf,cacheHint:r.cacheKey,get:()=>i},e),a=sx(n,e[0],t,o,i.output.dims,[t]),u=n.run({...ep,cacheHint:r.cacheKey,get:()=>a},[e[0],s]),l=ux(n,e[0],t,o,i.output.dims,a.output.dims);return[n.run({...tp,cacheHint:r.cacheKey,get:()=>l},[e[0],s,u])]},ax=(n,e,r,t,o)=>{let[i,s]=n.calculateTextureWidthAndHeight(e.dims,0),a=o.length;if(r<1||t<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(o.length!==1)throw new Error("Dimensionality of the output should be 1");if(o[0]!==r)throw new Error("Shape of the output should be equal to logical row count");let u=ue(n.session.backend.glContext.version),l=`
      float process(int[${a}] indices) {
        int logical_row_start_offset = indices[0] * ${t};

        float max = getColorAsFloat(${u.texture2D}(A, offsetToCoords(logical_row_start_offset, ${i},
        ${s} )));
        for(int i=1; i<${t}; ++i)
        {
          float current = getColorAsFloat(${u.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${i}, ${s})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return{...Qf,output:{dims:o,type:e.type,textureType:0},shaderSource:l}},sx=(n,e,r,t,o,i)=>{let[s,a]=n.calculateTextureWidthAndHeight(e.dims,0),u=i.length;if(r<1||t<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(i.length!==1)throw new Error("Dimensionality of the output should be 1");if(i[0]!==r)throw new Error("Shape of the output should be equal to logical row count");if(o.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(o[0]!==r)throw new Error("Shape of the intermediate results should be equal to logical row count");let l=ue(n.session.backend.glContext.version),d=`
      float process(int[${u}] indices) {
        int logical_row_start_offset = indices[0] * ${t};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${t}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${l.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${s}, ${a}))) - max);
        }

        return norm_factor;
      }`;return{...ep,output:{dims:i,type:e.type,textureType:0},shaderSource:d}},ux=(n,e,r,t,o,i)=>{let[s,a]=n.calculateTextureWidthAndHeight(e.dims,0),u=e.dims.length;if(r<1||t<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(o.length!==1||i.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(o[0]!==r||i[0]!==r)throw new Error("Shape of the intermediate results should be equal to logical row count");let l=`
      float process(int[${u}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${s}, ${a});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${t};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return{...tp,output:{dims:e.dims,type:e.type,textureType:0},shaderSource:l}},sp=n=>{if(!n||n.length!==1)throw new Error("Softmax requires 1 input.");if(n[0].type!=="float32"&&n[0].type!=="float64")throw new Error("Invalid input type")}});var lp,cp,dp,lx,cx,dx,fp=k(()=>{"use strict";ct();Me();_e();lp={name:"Split",inputNames:["A"],inputTypes:[0]},cp=(n,e,r)=>{dx(e);let t=Q.normalizeAxis(r.axis,e[0].dims.length),o=lx(n,e,t,r),i=[];for(let s=0;s<o;++s)i.push(n.run({...lp,cacheHint:`${r.cacheKey};${s}`,get:()=>cx(n,e[0],r,t,s)},e));return i},dp=n=>{let e=n.attributes.getInt("axis",0),r=n.attributes.getInts("split",[]),t=n.outputs.length;return we({axis:e,split:r,numOutputs:t})},lx=(n,e,r,t)=>{let[,o]=qn.splitShape(e[0].dims,r,t.split,t.numOutputs);return o.length},cx=(n,e,r,t,o)=>{let[i,s]=qn.splitShape(e.dims,t,r.split,r.numOutputs),a=s[o],u=i[o],d=`
      float process(int indices[${u.length}]) {
        indices[${t}] += ${a};
        return _A(indices);
      }
    `;return{...lp,cacheHint:`${r.cacheKey}:${o}`,output:{dims:u,type:e.type,textureType:0},shaderSource:d}},dx=n=>{if(!n||n.length!==1)throw new Error("Split requires one input.");if(n[0].type!=="int8"&&n[0].type!=="uint8"&&n[0].type!=="int16"&&n[0].type!=="uint16"&&n[0].type!=="int32"&&n[0].type!=="uint32"&&n[0].type!=="float32"&&n[0].type!=="float64"&&n[0].type!=="bool")throw new Error("Invalid input type.")}});var rs,pp,hp,fx,px,mp=k(()=>{"use strict";Me();rs=(n,e,r)=>{fx(e);let t=Q.squeezeShape(e[0].dims,r);return[n.reshapeUnpacked(e[0],t)]},pp=(n,e)=>(px(e),rs(n,[e[0]],Array.from(e[1].integerData))),hp=n=>n.attributes.getInts("axes"),fx=n=>{if(!n||n.length!==1)throw new Error("Squeeze requires 1 input.");if(n[0].type==="string")throw new Error("invalid input tensor types.")},px=n=>{if(!n||n.length!==2)throw new Error("Squeeze requires 2 inputs.");if(n[1].type!=="int32")throw new Error("Invalid input type.")}});var gp,hx,mx,bp=k(()=>{"use strict";Xe();_e();gp=(n,e)=>{mx(e);let r={name:"Sum",inputNames:e.map((o,i)=>`X${i}`),inputTypes:new Array(e.length).fill(0)};return[n.run({...r,get:()=>hx(n,e,r)},e)]},hx=(n,e,r)=>{let t=ue(n.session.backend.glContext.version),o=e[0].dims.slice(),s=`
      void main() {
        vec4 result = ${e.map((a,u)=>`${t.texture2D}(X${u},TexCoords)`).join(" + ")};
        ${t.output} = result;
      }
    `;return{...r,output:{dims:o,type:e[0].type,textureType:0},hasMain:!0,shaderSource:s}},mx=n=>{if(!n||n.length===0)throw new Error("Sum requires inputs.");let e=n[0].dims.length;for(let r=1;r<n.length;r++){if(e!==n[r].dims.length)throw new Error("Input shapes are mismatched.");for(let t=0;t<e;t++)if(n[0].dims[t]!==n[r].dims[t])throw new Error("Input shapes are not matched.")}if(n[0].type!=="float32"&&n[0].type!=="float64")throw new Error("Invalid input type.");for(let r=1;r<n.length;r++)if(n[0].type!==n[r].type)throw new Error("Input types are not matched.")}});var yp,gx,bx,vp=k(()=>{"use strict";Qn();_e();yp=(n,e)=>{bx(e);let r={name:"Tile",inputNames:["A"],inputTypes:[0]};return[n.run({...r,get:()=>gx(n,e,r)},e)]},gx=(n,e,r)=>{let t=e[0].dims.slice(),o=new Array(t.length),i=[];for(let u=0;u<t.length;u++)o[u]=t[u]*e[1].numberData[u],i.push(`inputIdx[${u}] = int(mod(float(outputIdx[${u}]), ${t[u]}.));`);let s=o.length,a=`
      float process(int outputIdx[${s}]) {
        int inputIdx[${s}];
        ${i.join(`
`)}
        return _A(inputIdx);
      }
    `;return{...r,output:{dims:o,type:e[0].type,textureType:0},shaderSource:a}},bx=n=>{if(!n||n.length!==2)throw new Error("Tile requires 2 input.");if(n[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(n[1].dims[0]!==n[0].dims.length)throw new Error("Invalid input shape.");if(Sr.indexOf(n[0].type)===-1)throw new Error("Invalid input type.");if(n[1].type!=="int32"&&n[1].type!=="int16")throw new Error("Invalid repeat type.")}});var ns,xp,wp,yx,vx,Tp=k(()=>{"use strict";Me();ns=(n,e,r)=>{yx(e);let t=Q.unsqueezeShape(e[0].dims,r);return[n.reshapeUnpacked(e[0],t)]},xp=(n,e)=>(vx(e),ns(n,[e[0]],Array.from(e[1].integerData))),wp=n=>n.attributes.getInts("axes"),yx=n=>{if(!n||n.length!==1)throw new Error("Unsqueeze requires 1 input.");if(n[0].type==="string")throw new Error("invalid input tensor types.")},vx=n=>{if(!n||n.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(n[1].type!=="int32")throw new Error("Invalid input type.")}});var $p,Ip=k(()=>{"use strict";kc();jc();Yc();td();Zo();Nd();Ud();qd();Xd();ef();nf();uf();ff();Qo();gf();Ef();Lf();Ff();Hf();qf();Zf();up();fp();mp();bp();vp();ti();za();Tp();Za();$p=[["Abs","","6+",rd],["Acos","","7+",nd],["Add","","7+",Bc],["And","","7+",Rc],["Asin","","7+",od],["Atan","","7+",id],["AveragePool","","7+",yf,vf],["BatchNormalization","","7+",Pc,Dc],["Cast","","6+",qc,Kc],["Ceil","","6+",ud],["Clip","","6-10",Na,ad],["Clip","","11+",sd],["Concat","","4+",Zc,ed],["Conv","","1+",ja,qa],["ConvTranspose","","1+",Md,Ld],["Cos","","7+",ld],["Div","","7+",Mc],["Dropout","","7+",Fa],["DepthToSpace","","1+",Wd,Vd],["Equal","","7+",Lc],["Elu","","6+",cd,dd],["Exp","","6+",fd],["Flatten","","1+",Hd,jd],["Floor","","6+",pd],["FusedConv","com.microsoft","1+",ja,qa],["Gather","","1+",Kd,Yd],["Gemm","","7-10",Ka,Zd],["Gemm","","11+",Ka,Qd],["GlobalAveragePool","","1+",wf,Tf],["GlobalMaxPool","","1+",Af],["Greater","","7+",Nc],["Identity","","1+",Fa],["ImageScaler","","1+",tf,rf],["InstanceNormalization","","6+",af,sf],["LeakyRelu","","6+",hd,md],["Less","","7+",Fc],["LRN","","1+",lf,cf],["Log","","6+",gd],["MatMul","","1+",Ed,Cd],["MaxPool","","1+",$f,If],["Mul","","7+",zc],["Neg","","6+",bd],["Not","","1+",yd],["Or","","7+",Gc],["Pad","","2-10",Ya,pf],["Pad","","11+",hf,mf],["Pow","","7+",Wc],["PRelu","","7+",Vc],["ReduceLogSum","","1+",Rf,_r],["ReduceMax","","1+",Df,_r],["ReduceMean","","1+",Pf,_r],["ReduceMin","","1+",kf,_r],["ReduceProd","","1+",Bf,_r],["ReduceSum","","1-12",Cf,_r],["ReduceSumSquare","","1+",Mf,_r],["Relu","","6+",vd],["Reshape","","5+",Nf],["Resize","","10",es,Vf],["Resize","","11+",es,Uf],["Shape","","1+",jf],["Sigmoid","","6+",xd],["Sin","","7+",wd],["Slice","","10+",Jf],["Slice","","1-9",Kf,Yf],["Softmax","","1-12",rp,np],["Softmax","","13+",ip,op],["Split","","2-12",cp,dp],["Sqrt","","6+",Td],["Squeeze","","1-12",rs,hp],["Squeeze","","13+",pp],["Sub","","7+",Uc],["Sum","","6+",gp],["Tan","","7+",$d],["Tanh","","6+",Id],["Tile","","6+",yp],["Transpose","","1+",Kr,zd],["Upsample","","7-8",Xa,Gf],["Upsample","","9",Xa,Wf],["Unsqueeze","","1-12",ns,wp],["Unsqueeze","","13+",xp],["Xor","","7+",Hc]]});function _p(n){let e={},r;for(;(r=Sp.exec(n))!==null;){let t=r[3].split(",").map(o=>{let i=o.trim().split(" ");return i&&i.length===2?{type:i[0],name:i[1]}:null}).filter(o=>o!==null);e[r[2]]={params:t,body:r[4]}}for(let t in e){let o=xx.replace("__FUNC__",t),i=new RegExp(o,"gm");for(;(r=i.exec(n))!==null;){let s=r[1],a=r[2],u=r[3].split(","),l=s?`${s} ${a};`:"",d=e[t].body,p="";e[t].params.forEach((g,y)=>{g&&(p+=`${g.type} ${g.name} = ${u[y]};
`)}),d=`${p}
 ${d}`,d=d.replace("return",`${a} = `);let h=`
      ${l}
      {
        ${d}
      }
      `;n=n.replace(r[0],h)}}return n=n.replace(Sp,""),n}var Sp,xx,Ap=k(()=>{"use strict";Sp=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm,xx="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;"});function vn(n,e){let r=[],t=[],o=e!=null&&Array.isArray(e)&&e.length===0,i=e==null||o?null:wx(e,n).sort(),s=0;for(let a=0;a<n.length;++a){if(i!=null){if(i[s]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(i[s]==null||i[s]>a)&&n[a]===1&&(r.push(n[a]),t.push(a)),i[s]<=a&&s++}n[a]!==1&&(r.push(n[a]),t.push(a))}return{newShape:r,keptDims:t}}function wx(n,e){let r=e.length;return n=n==null?e.map((t,o)=>o):[].concat(n),pn(n.every(t=>t>=-r&&t<r),()=>`All values in axis param must be in range [-${r}, ${r}) but got axis ${n}`),pn(n.every(Tx),()=>`All values in axis param must be integers but got axis ${n}`),n.map(t=>t<0?r+t:t)}function Tx(n){return n%1===0}function $x(n){if(n.length===0)return 1;let e=n[0];for(let r=1;r<n.length;r++)e*=n[r];return e}function Op(n){let e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}var ii,os=k(()=>{"use strict";Ot();Me();ii=class{constructor(e){this.maxTextureSize=e}computeTextureWH(e,r){let t=this.computeTexture(e,r);return r&&r.isPacked&&(t[0]/=2,t[1]/=2),r&&r.reverseWH?[t[1],t[0]]:t}computeTexture(e,r){let t=r&&r.isPacked;if(e.length===0)return t?[2,2]:[1,1];let o=this.maxTextureSize;if(r&&r.breakAxis!==void 0){let a=r.breakAxis>=e.length?1:e.slice(r.breakAxis).reduce((l,d)=>l*d),u=r.breakAxis<=0?1:e.slice(0,r.breakAxis).reduce((l,d)=>l*d);if(a>o||u>o)Ne.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${e}, breakAxis:${r.breakAxis}`);else return[a,u]}let i=e.slice(0);t&&(o=o*2,i=i.map((a,u)=>u>=i.length-2?i[u]%2===0?i[u]:i[u]+1:i[u]),i.length===1&&(i=[2,i[0]])),i.length!==2&&(i=vn(i).newShape);let s=$x(i);return i.length<=1&&s<=o?[1,s]:i.length===2&&i[0]<=o&&i[1]<=o?i:i.length===3&&i[0]*i[1]<=o&&i[2]<=o?[i[0]*i[1],i[2]]:i.length===3&&i[0]<=o&&i[1]*i[2]<=o?[i[0],i[1]*i[2]]:i.length===4&&i[0]*i[1]*i[2]<=o&&i[3]<=o?[i[0]*i[1]*i[2],i[3]]:i.length===4&&i[0]<=o&&i[1]*i[2]*i[3]<=o?[i[0],i[1]*i[2]*i[3]]:t?Op(s/4).map(a=>a*2):Op(s)}}});var ai,Ep=k(()=>{"use strict";Me();gr();Xe();os();rr();ai=class extends Dt{constructor(r){super(r)}getFunctions(){return{...this.offsetToCoords(),...this.coordsToOffset(),...this.toVec(),...this.valueFrom(),...this.getCommonUtilFuncs(),...this.getInputsSamplingSnippets(),...this.getOutputSamplingSnippet()}}getCustomTypes(){return{}}offsetToCoords(){let r="offsetToCoords";return{offsetToCoords:new Y(`
      vec2 ${r}(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){let r="coordsToOffset";return{coordsToOffset:new Y(`
      int ${r}(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){let r=this.context.outputTextureLayout;return r.isPacked?this.getPackedOutputSamplingSnippet(r):this.getUnpackedOutputSamplingSnippet(r)}getPackedOutputSamplingSnippet(r){let t=r.unpackedShape,o=[r.width,r.height],i={},s="getOutputCoords";switch(t.length){case 0:i[s]=this.getOutputScalarCoords();break;case 1:i[s]=this.getOutputPacked1DCoords(t,o);break;case 2:i[s]=this.getOutputPacked2DCoords(t,o);break;case 3:i[s]=this.getOutputPacked3DCoords(t,o);break;default:i[s]=this.getOutputPackedNDCoords(t,o)}let u=`
      void setOutput(vec4 val) {
        ${ue(this.context.glContext.version).output} = val;
      }
    `,l="floatTextureSetRGBA";return i[l]=new Y(u),i}getUnpackedOutputSamplingSnippet(r){let t=r.unpackedShape,o=[r.width,r.height],i={},s="getOutputCoords";switch(t.length){case 0:i[s]=this.getOutputScalarCoords();break;case 1:i[s]=this.getOutputUnpacked1DCoords(t,o);break;case 2:i[s]=this.getOutputUnpacked2DCoords(t,o);break;case 3:i[s]=this.getOutputUnpacked3DCoords(t,o);break;case 4:i[s]=this.getOutputUnpacked4DCoords(t,o);break;case 5:i[s]=this.getOutputUnpacked5DCoords(t,o);break;case 6:i[s]=this.getOutputUnpacked6DCoords(t,o);break;default:throw new Error(`Unsupported output dimensionality: ${t.length}`)}let u=`
        void setOutput(float val) {
          ${ue(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `,l="floatTextureSetR";return i[l]=new Y(u),i}getOutputScalarCoords(){return new Y(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(r,t){let o=t,i="";return o[0]===1?(i=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${o[1]}.0);
          }
        `,new Y(i)):o[1]===1?(i=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${o[0]}.0);
          }
        `,new Y(i)):(i=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${o[0]}, ${o[1]}));
          return 2 * (resTexRC.y * ${o[0]} + resTexRC.x);
        }
      `,new Y(i))}getOutputPacked2DCoords(r,t){let o="";if(Gr.arraysEqual(r,t))return o=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${t[0]}, ${t[1]}));
        }
      `,new Y(o);let i=t,s=Math.ceil(r[1]/2);return o=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${i[0]}, ${i[1]}));

          int index = resTexRC.y * ${i[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${s}) * 2;
          int c = 2 * (index / ${s});

          return ivec2(r, c);
        }
      `,new Y(o)}getOutputPacked3DCoords(r,t){let o=[t[0],t[1]],i=Math.ceil(r[2]/2),s=i*Math.ceil(r[1]/2),a=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${o[0]}, ${o[1]}));
          int index = resTexRC.y * ${o[0]} + resTexRC.x;

          int b = index / ${s};
          index -= b * ${s};

          // reverse r and c order for packed texture
          int r = imod(index, ${i}) * 2;
          int c = 2 * (index / ${i});

          return ivec3(b, r, c);
        }
      `;return new Y(a)}getOutputPackedNDCoords(r,t){let o=[t[0],t[1]],i=Math.ceil(r[r.length-1]/2),s=i*Math.ceil(r[r.length-2]/2),a=s,u="",l="b, r, c";for(let p=2;p<r.length-1;p++)a*=r[r.length-p-1],u=`
      int b${p} = index / ${a};
      index -= b${p} * ${a};
    `+u,l=`b${p}, `+l;let d=`
      ivec${r.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${o[0]}, ${o[1]}));
        int index = resTexRC.y * ${o[0]} + resTexRC.x;

        ${u}

        int b = index / ${s};
        index -= b * ${s};

        // reverse r and c order for packed texture
        int r = imod(index, ${i}) * 2;
        int c = 2 * (index / ${i});

        return ivec${r.length}(${l});
      }
    `;return new Y(d)}getOutputUnpacked1DCoords(r,t){let o=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          return resTexRC.y * ${t[0]} + resTexRC.x;
        }
      `;return new Y(o)}getOutputUnpacked2DCoords(r,t){let o=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          int index = resTexRC.y * ${t[0]} + resTexRC.x;
          int r = index / ${r[1]};
          int c = index - r * ${r[1]};
          return ivec2(r, c);
        }
      `;return new Y(o)}getOutputUnpacked3DCoords(r,t){let o="",i=r.length,s=null;i<2&&(s=[]),s=new Array(i-1),s[i-2]=r[i-1];for(let l=i-3;l>=0;--l)s[l]=s[l+1]*r[l+1];let a=["r","c","d"],u=s.map((l,d)=>{let p=`int ${a[d]} = index / ${l}`,h=d===s.length-1?`int ${a[d+1]} = index - ${a[d]} * ${l}`:`index -= ${a[d]} * ${l}`;return`${p}; ${h};`}).join("");return o=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          int index = resTexRC.y * ${t[0]} + resTexRC.x;
          ${u}
          return ivec3(r, c, d);
        }
      `,new Y(o)}getOutputUnpacked4DCoords(r,t){let o="",i=r.length,s=null;i<2&&(s=[]),s=new Array(i-1),s[i-2]=r[i-1];for(let l=i-3;l>=0;--l)s[l]=s[l+1]*r[l+1];let a=["r","c","d","d2"],u=s.map((l,d)=>{let p=`int ${a[d]} = index / ${l}`,h=d===s.length-1?`int ${a[d+1]} = index - ${a[d]} * ${l}`:`index -= ${a[d]} * ${l}`;return`${p}; ${h};`}).join("");return o=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          int index = resTexRC.y * ${t[0]} + resTexRC.x;
          ${u}
          return ivec4(r, c, d, d2);
        }
      `,new Y(o)}getOutputUnpacked5DCoords(r,t){let o="",i=r.length,s=null;i<2&&(s=[]),s=new Array(i-1),s[i-2]=r[i-1];for(let l=i-3;l>=0;--l)s[l]=s[l+1]*r[l+1];let a=["r","c","d","d2","d3"],u=s.map((l,d)=>{let p=`int ${a[d]} = index / ${l}`,h=d===s.length-1?`int ${a[d+1]} = index - ${a[d]} * ${l}`:`index -= ${a[d]} * ${l}`;return`${p}; ${h};`}).join("");return o=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          int index = resTexRC.y * ${t[0]} + resTexRC.x;
          ${u}
          return ivec5(r, c, d, d2, d3);
        }
      `,new Y(o)}getOutputUnpacked6DCoords(r,t){let o="",i=r.length,s=null;i<2&&(s=[]),s=new Array(i-1),s[i-2]=r[i-1];for(let l=i-3;l>=0;--l)s[l]=s[l+1]*r[l+1];let a=["r","c","d","d2","d3","d4"],u=s.map((l,d)=>{let p=`int ${a[d]} = index / ${l}`,h=d===s.length-1?`int ${a[d+1]} = index - ${a[d]} * ${l}`:`index -= ${a[d]} * ${l}`;return`${p}; ${h};`}).join("");return o=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${t[0]}, ${t[1]}));
         int index = resTexRC.y * ${t[0]} + resTexRC.x;
         ${u}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new Y(o)}getCommonUtilFuncs(){let r={},t="uvFromFlat";r[t]=new Y(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),t="packedUVfrom1D",r[t]=new Y(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),t="packedUVfrom2D",r[t]=new Y(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),t="packedUVfrom3D",r[t]=new Y(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),t="sampleTexture";let o=ue(this.context.glContext.version);return r[t]=new Y(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${o.texture2D}(textureSampler, uv).r;
        }`),r}getInputsSamplingSnippets(){let r={},t=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((o,i)=>{let s=this.context.inputTextureLayouts[i],a=Ho(o);s.isPacked?r[a]=this.getPackedSamplerFromInput(a,o,s):r[a]=this.getUnpackedSamplerFromInput(a,o,s);let u=mc(o);s.unpackedShape.length<=t.unpackedShape.length&&(s.isPacked?r[u]=this.getPackedSamplerAtOutputCoords(u,s,t,o):r[u]=this.getUnpackedSamplerAtOutputCoords(u,s,t,o))}),r}getPackedSamplerAtOutputCoords(r,t,o,i){let s=t.unpackedShape,a=o.unpackedShape,l=Ho(i),d=s.length,p=a.length,h=vt.getBroadcastDims(s,a),g=xt(p),y=p-d,b,w=Ht();d===0?b="":p<2&&h.length>=1?b="coords = 0;":b=h.map(J=>`coords.${w[J+y]} = 0;`).join(`
`);let I="";p<2&&d>0?I="coords":I=s.map((J,ge)=>`coords.${w[ge+y]}`).join(", ");let O="return outputValue;",N=Q.size(s)===1,R=Q.size(a)===1;if(d===1&&!N&&!R)O=`
        return vec4(outputValue.xy, outputValue.xy);
      `;else if(N&&!R)p===1?O=`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:O=`
          return vec4(outputValue.x);
        `;else if(h.length){let J=d-2,ge=d-1;h.indexOf(J)>-1&&h.indexOf(ge)>-1?O="return vec4(outputValue.x);":h.indexOf(J)>-1?O="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":h.indexOf(ge)>-1&&(O="return vec4(outputValue.xx, outputValue.zz);")}let V=`
        int lastDim = coords.${w[p-1]};
        coords.${w[p-1]} = coords.${w[p-2]};
        coords.${w[p-2]} = lastDim;
      `,K=`
      vec4 ${r}() {
        ${g} coords = getOutputCoords();
        ${V}
        ${b}
        vec4 outputValue = ${l}(${I});
        ${O}
      }
    `;return new Y(K,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(r,t,o,i){let s=[o.width,o.height],a=[t.width,t.height],u=t.unpackedShape.length,l=o.unpackedShape.length,d=t.unpackedShape,p=o.unpackedShape,h=Ho(i);if(u===l&&Gr.arraysEqual(a,s)){let N=`
          float ${r}() {
            return sampleTexture(${i}, TexCoords);
          }
        `;return new Y(N,["coordinates.sampleTexture"])}let g=xt(l),y=vt.getBroadcastDims(d,p),b=l-u,w,I=Ht();u===0?w="":l<2&&y.length>=1?w="coords = 0;":w=y.map(N=>`coords.${I[N+b]} = 0;`).join(`
`);let O="";l<2&&u>0?O="coords":O=t.unpackedShape.map((N,F)=>`coords.${I[F+b]}`).join(", ");let E=`
        float ${r}() {
          ${g} coords = getOutputCoords();
          ${w}
          return ${h}(${O});
        }
      `;return new Y(E,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(r,t,o){switch(o.unpackedShape.length){case 0:return this.getPackedSamplerScalar(r,t);case 1:return this.getPackedSampler1D(r,t,o);case 2:return this.getPackedSampler2D(r,t,o);case 3:return this.getPackedSampler3D(r,t,o);default:return this.getPackedSamplerND(r,t,o)}}getUnpackedSamplerFromInput(r,t,o){let i=o.unpackedShape;switch(i.length){case 0:return this.getUnpackedSamplerScalar(r,t,o);case 1:return this.getUnpackedSampler1D(r,t,o);case 2:return this.getUnpackedSampler2D(r,t,o);case 3:return this.getUnpackedSampler3D(r,t,o);case 4:return this.getUnpackedSampler4D(r,t,o);case 5:return this.getUnpackedSampler5D(r,t,o);case 6:return this.getUnpackedSampler6D(r,t,o);default:throw new Error(`Unsupported dimension ${i.length}-D`)}}getPackedSamplerScalar(r,t){let o=ue(this.context.glContext.version),i=`
          vec4 ${r}() {
            return ${o.texture2D}(${t}, halfCR);
          }
        `;return new Y(i)}getPackedSampler1D(r,t,o){let i=[o.width,o.height],s=[i[1],i[0]],a=ue(this.context.glContext.version),l=`vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
      ${s[0]}, ${s[1]}, index);
      return ${a.texture2D}(${t}, uv);
    }`;return new Y(l,["coordinates.packedUVfrom1D"])}getPackedSampler2D(r,t,o){let i=o.unpackedShape,s=[o.width,o.height],a=ue(this.context.glContext.version),u=s[0],l=s[1];if(s!=null&&Gr.arraysEqual(i,s)){let y=`vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${u}.0);
        return ${a.texture2D}(${t}, uv);
      }`;return new Y(y)}let d=s,p=Math.ceil(i[1]/2),g=`vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${d[1]}, ${d[0]}, ${p}, row, col);
      return ${a.texture2D}(${t}, uv);
    }`;return new Y(g,["coordinates.packedUVfrom2D"])}getPackedSampler3D(r,t,o){let i=o.unpackedShape,s=[o.width,o.height],a=[s[0],s[1]],u=ue(this.context.glContext.version);if(i[0]===1){let b=i.slice(1),w=[1,2],I=hn(i,b),O=["b","row","col"],E=JSON.parse(JSON.stringify(o));E.unpackedShape=I;let N=this.getPackedSamplerFromInput(r,t,E),R=`${N.routineBody}
      vec4 ${r}(int b, int row, int col) {
        return ${r}(${mn(O,w)});
      } `;return new Y(R,N.dependencies)}let l=a[0],d=a[1],p=Math.ceil(i[2]/2),h=p*Math.ceil(i[1]/2),y=`vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${d}, ${l}, ${h}, ${p}, b, row, col);
      return ${u.texture2D}(${t}, uv);}`;return new Y(y,["coordinates.packedUVfrom3D"])}getPackedSamplerND(r,t,o){let i=o.unpackedShape,s=i.length,a=[o.width,o.height],u=ue(this.context.glContext.version),l=[a[0],a[1]],d=l[1],p=l[0],h=Math.ceil(i[s-1]/2),g=h*Math.ceil(i[s-2]/2),y="int b, int row, int col",b=`b * ${g} + (row / 2) * ${h} + (col / 2)`;for(let O=2;O<s-1;O++)y=`int b${O}, `+y,g*=i[s-O-1],b=`b${O} * ${g} + `+b;let I=`vec4 ${r}(${y}) {
      int index = ${b};
      int texR = index / ${p};
      int texC = index - texR * ${p};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${d});
      return ${u.texture2D}(${t}, uv);
    }`;return new Y(I)}getUnpackedSamplerScalar(r,t,o){let[i,s]=[o.width,o.height];if(i===1&&s===1){let u=`
          float ${r}() {
            return sampleTexture(${t}, halfCR);
          }
        `;return new Y(u,["coordinates.sampleTexture"])}let a=`
        float ${r}() {
          int offset_${t} = coordsToOffset(TexCoords, ${i}, ${s});
          vec2 uv = uvFromFlat(${i}, ${s}, offset_${t});
          return sampleTexture(${t}, uv);
        }
      `;return new Y(a,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(r,t,o){let i=o.width,s=o.height;if(s===1&&i===1){let u=`
        float ${r}(int index) {
          return sampleTexture(${t}, halfCR);
        }
      `;return new Y(u,["coordinates.sampleTexture"])}if(s===1){let u=`
          float ${r}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${i}.0, 0.5);
            return sampleTexture(${t}, uv);
          }
        `;return new Y(u,["coordinates.sampleTexture"])}if(i===1){let u=`
          float ${r}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${s}.0);
            return sampleTexture(${t}, uv);
          }
        `;return new Y(u,["coordinates.sampleTexture"])}let a=`
        float ${r}(int index) {
          vec2 uv = uvFromFlat(${i}, ${s}, index);
          return sampleTexture(${t}, uv);
        }
      `;return new Y(a,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(r,t,o){let i=o.unpackedShape,s=[o.height,o.width];if(s!=null&&Gr.arraysEqual(i,s)){let g=s[1],y=s[0],b=`
          float ${r}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${g}.0, ${y}.0);
            return sampleTexture(${t}, uv);
          }
        `;return new Y(b,["coordinates.sampleTexture"])}let{newShape:a,keptDims:u}=vn(i),l=a;if(l.length<i.length){let g=hn(i,l),y=JSON.parse(JSON.stringify(o));y.unpackedShape=g;let b=["col","row"],w=`
          ${this.getUnpackedSamplerFromInput(r,t,y).routineBody}
          float ${r}(int row, int col) {
            return ${r}(${mn(b,u)});
          }
        `;return new Y(w,["coordinates.sampleTexture"])}let d=s[1],p=s[0];if(p===1){let g=`
          float ${r}(int row, int col) {
            int offset_${t} = coordsToOffset(TexCoords, ${d}, ${p});
            float index = dot(vec3(row, col, offset_${t}), vec3(${i[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${d}.0);
            return sampleTexture(${t}, uv);
          }
        `;return new Y(g,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(d===1){let g=`
          float ${r}(int row, int col) {
            int offset_${t} = coordsToOffset(TexCoords, ${d}, ${p});
            float index = dot(vec3(row, col, offset_${t}), vec3(${i[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${p}.0, 0.5);
            return sampleTexture(${t}, uv);
          }
        `;return new Y(g,["coordinates.sampleTexture","coordinates.coordsToOffset"])}let h=`
        float ${r}(int row, int col) {
          int index = col * ${i[1]} + row;
          vec2 uv = uvFromFlat(${d}, ${p}, index);
          return sampleTexture(${t}, uv);
        }
      `;return new Y(h,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(r,t,o){let i=o.unpackedShape,s=i[1]*i[2],a=i[2],{newShape:u,keptDims:l}=vn(i),d=u;if(d.length<i.length){let y=hn(i,d),b=["batch","col","row"],w=JSON.parse(JSON.stringify(o));w.unpackedShape=y;let I=this.getUnpackedSamplerFromInput(r,t,w),O=l.reverse(),E=`
          ${I.routineBody}
          float ${r}(int batch, int row, int col) {
            return ${r}(${mn(b,O)});
          }
        `;return new Y(E,I.dependencies)}let p=o.width,h=o.height,g=`
          float ${r}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${s} + col * ${a} + row;
            vec2 uv = uvFromFlat(${p}, ${h}, index);
            return sampleTexture(${t}, uv);
          }
      `;return new Y(g,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(r,t,o){let i=o.unpackedShape,s=i[3],a=i[2]*s,u=i[1]*a,l=o.width,d=o.height,p=`
        float ${r}(int row, int col, int depth, int depth2) {
          int index = row * ${u} + col * ${a} +
              depth2 * ${s} + depth;
          vec2 uv = uvFromFlat(${l}, ${d}, index);
          return sampleTexture(${t}, uv);
        }
      `;return new Y(p,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(r,t,o){let i=o.unpackedShape,s=i[4],a=i[3]*s,u=i[2]*a,l=i[1]*u,{newShape:d,keptDims:p}=vn(i);if(d.length<i.length){let b=hn(i,d),w=["row","col","depth","depth2","depth3"],I=JSON.parse(JSON.stringify(o));I.unpackedShape=b;let O=`
          ${this.getUnpackedSamplerFromInput(r,t,I).routineBody}
          float ${r}(int row, int col, int depth, int depth2, int depth3) {
            return ${r}(${mn(w,p)});
          }
        `;return new Y(O,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let h=o.width,g=o.height,y=`
        float ${r}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${l} + col * ${u} + depth * ${a} +
          depth3 * ${s} + depth2;
          vec2 uv = uvFromFlat(${h}, ${g}, index);
          return sampleTexture(${t}, uv);
        }
      `;return new Y(y,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(r,t,o){let i=o.unpackedShape,s=i[5],a=i[4]*s,u=i[3]*a,l=i[2]*u,d=i[1]*l,{newShape:p,keptDims:h}=vn(i);if(p.length<i.length){let w=hn(i,p),I=["row","col","depth","depth2","depth3","depth4"],O=JSON.parse(JSON.stringify(o));O.unpackedShape=w;let E=`
            ${this.getUnpackedSamplerFromInput(r,t,O).routineBody}
            float ${r}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${r}(${mn(I,h)});
            }
          `;return new Y(E,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let g=o.width,y=o.height,b=`
          float ${r}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${d} + col * ${l} + depth * ${u} +
            depth2 * ${a} + depth3 * ${s} + depth4;
            vec2 uv = uvFromFlat(${g}, ${y}, index);
            return sampleTexture(${t}, uv);
          }
        `;return new Y(b,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){let r=this.context.outputTextureLayout,t=r.shape.length,o=r.strides,i=r.width,s=r.height,a=[];for(let l=0;l<t-1;++l)a.push(`
        c[${l}] = offset / ${o[l]};`),a.push(`
        offset -= c[${l}] * ${o[l]};`);a.push(`
        c[${t-1}] = offset;`);let u=`
      void toVec(vec2 texCoords, out int c[${t}]) {
        int offset = coordsToOffset(texCoords, ${i}, ${s});
        ${a.join("")}
      }
      void toVec(int offset, out int c[${t}]) {
        ${a.join("")}
      }
    `;return{toVec:new Y(u,["coordinates.coordsToOffset"])}}valueFrom(){let r={};return this.context.programInfo.inputNames.forEach((t,o)=>{let i=this.context.inputTextureLayouts[o],a=(i.unpackedShape.length>0?i.unpackedShape:i.shape).length,u=`_${t}`;r[u]=new Y(this.getValueFromSingle(t,a,i.width,i.height,!1),[`shapeUtils.indicesToOffset${u}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),u=u+"_T",r[u]=new Y(this.getValueFromSingle(t,a,i.width,i.height,!0),[`shapeUtils.indicesToOffset${u}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),r}getValueFromSingle(r,t,o,i,s){let a=`_${r}`;s&&(a=a+"_T");let u=ue(this.context.glContext.version);return`
        float ${a}(int m[${t}]) {
          int offset = indicesToOffset${a}(m);
          vec2 coords = offsetToCoords(offset, ${o}, ${i});
          float value = getColorAsFloat(${u.texture2D}(${r}, coords));
          return value;
        }
        `}getPackedValueFrom(r,t,o,i,s){let a=`_${r}_Pack`;s&&(a=a+"_T");let u=ue(this.context.glContext.version);return`
        vec4 ${a}(int m[${t}]) {
          int offset = indicesToOffset_${r}(m);
          vec2 coords = offsetToCoords(offset, ${o}, ${i});
          return ${u.texture2D}(${r}, coords);
        }
        `}}});var si,Cp=k(()=>{"use strict";gr();si=class n extends Dt{constructor(e){super(e)}getFunctions(){return{...this.encodeFloat32(),...this.decodeFloat32()}}getCustomTypes(){return{}}encodeFloat32(){return{encode:new Y(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new Y(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){let e=n.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new Y(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${e}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){let e=n.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new Y(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${e}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){let e=new ArrayBuffer(4),r=new Uint32Array(e),t=new Uint8Array(e);if(r[0]=3735928559,t[0]===239)return!0;if(t[0]===222)return!1;throw new Error("unknown endianness")}}});var ui,Pp=k(()=>{"use strict";gr();Xe();ui=class extends Dt{constructor(e){super(e)}getFunctions(){return{...this.setFragColor(),...this.getColorAsFloat()}}getCustomTypes(){return{}}setFragColor(){let e=ue(this.context.glContext.version);return{setFragColor:new Y(`
        void setFragColor(float value) {
            ${e.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new Y(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}});var li,Dp=k(()=>{"use strict";gr();li=class n extends Dt{constructor(e){super(e)}getFunctions(){return{...this.bcastIndex(),...this.bcastMatmulIndex(),...this.offsetToIndices(),...this.indicesToOffset(),...this.incrementIndices()}}getCustomTypes(){return{}}bcastIndex(){let e=this.context.outputTextureLayout.shape.length,r={};return this.context.programInfo.inputNames.forEach((t,o)=>{let i=this.context.inputTextureLayouts[o].unpackedShape;if(i.length<=e){let s=i.length,a=e-s,u=`bcastIndices_${t}`,l="";for(let p=0;p<s;++p)l+=`
          realIndices[${p}] = int( mod(float(bcastedIndices[${a+p}]), ${i[p]}.0) );
          `;let d=`
        void ${u} (int bcastedIndices[${e}], out int realIndices[${s}]) {
          ${l}
        }
        `;r[u]=new Y(d)}}),r}bcastMatmulIndex(){let e=this.context.outputTextureLayout.shape.length,r={};return this.context.programInfo.inputNames.forEach((t,o)=>{let i=this.context.inputTextureLayouts[o].shape;if(!(i.length<2||i.length>e)){let s=i.length,a=e-s,u=`bcastMatmulIndices_${t}`,l="";for(let p=0;p<s-2;++p)l+=`
          realIndices[${p}] = int( mod(float(bcastedIndices[${a+p}]), ${i[p]}.0) );
          `;let d=`
        void ${u}(int bcastedIndices[${e}], out int realIndices[${s}]) {
          ${l}
          realIndices[${s-1}] = bcastedIndices[${e-1}];
          realIndices[${s-2}] = bcastedIndices[${e-2}];
        }
        `;r[u]=new Y(d)}}),r}indicesToOffset(){let e={};return this.context.programInfo.inputNames.forEach((r,t)=>{let o=this.context.inputTextureLayouts[t].shape,i=this.context.inputTextureLayouts[t].strides,s=o.length,a=`indicesToOffset_${r}`;e[a]=new Y(n.indexToOffsetSingle(a,s,i)),a=`indicesToOffset_${r}_T`,e[a]=new Y(n.indexToOffsetSingle(a,s,i.slice().reverse()))}),e}static indexToOffsetSingle(e,r,t){let o="";for(let i=r-1;i>=0;--i)o+=`
        offset += indices[${i}] * ${t[i]};
        `;return`
      int ${e}(int indices[${r}]) {
        int offset = 0;
        ${o}
        return offset;
      }
      `}offsetToIndices(){let e={};return this.context.programInfo.inputNames.forEach((r,t)=>{let o=this.context.inputTextureLayouts[t].shape,i=this.context.inputTextureLayouts[t].strides,s=o.length,a=`offsetToIndices_${r}`;e[a]=new Y(n.offsetToIndicesSingle(a,s,i)),a=`offsetToIndices_${r}_T`,e[a]=new Y(n.offsetToIndicesSingle(a,s,i.slice().reverse()))}),e}static offsetToIndicesSingle(e,r,t){let o=[];for(let i=0;i<r-1;++i)o.push(`
      indices[${i}] = offset / ${t[i]};`),o.push(`
        offset -= indices[${i}] * ${t[i]};`);return o.push(`
      indices[${r-1}] = offset;`),`
      void ${e}(int offset, out int indices[${r}]) {
        ${o.join("")}
      }
      `}incrementIndices(){let e={};return this.context.programInfo.inputNames.forEach((r,t)=>{let o=this.context.inputTextureLayouts[t].shape,i=o.length,s=`incrementIndices_${r}`,a="";for(let l=0;l<i;++l)a+=`
        shape[${l}] = ${o[l]};`;let u=`
        void ${s}(int axis, out int indices[${i}]) {
          int shape[${i}];
          ${a};
          for(int i = ${i} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;e[s]=new Y(u)}),e}}});var ci,kp=k(()=>{"use strict";gr();ci=class extends Dt{constructor(e){super(e)}getCustomTypes(){return{}}getFunctions(){return{...this.binaryVecFunctions(),...this.copyVec(),...this.setVecItem(),...this.getVecItem()}}binaryVecFunctions(){let r=this.context.outputTextureLayout.shape.length,t={add:"+=",sub:"-=",mul:"*=",div:"/="},o={};for(let i in t){let s=`${i}Vec`,a="";for(let l=0;l<r;++l)a+=`
          dest[${l}] ${t[i]} src[${l}];
          `;let u=`
        void ${s}(int src[${r}], out int dest[${r}]) {
          ${a}
        }
        `;o[s]=new Y(u)}return o}copyVec(){let r=this.context.outputTextureLayout.shape.length,t="";for(let i=0;i<r;++i)t+=`
        dest[${i}] = src[${i}];
        `;let o=`
      void copyVec(int src[${r}], out int dest[${r}]) {
        ${t}
      }
      `;return{copyVec:new Y(o)}}setVecItem(){let r=this.context.outputTextureLayout.shape.length,t=`
        if(index < 0)
            index =${r} + index;
        if (index == 0)
            m[0] = value;
        `;for(let i=1;i<r-1;++i)t+=`
        else if (index == ${i})
            m[${i}] = value;
            `;t+=`
        else
            m[${r-1}] = value;
        `;let o=`
      void setVecItem(out int m[${r}], int index, int value) {
        ${t}
      }
        `;return{setVecItem:new Y(o)}}getVecItem(){let r=this.context.outputTextureLayout.shape.length,t=`
        if(index < 0)
            index = ${r} + index;
        if (index == 0)
            return m[0];
      `;for(let i=1;i<r-1;++i)t+=`
        else if (index == ${i})
            return m[${i}];
      `;t+=`
        else
            return m[${r-1}];
        `;let o=`
      int getVecItem(int m[${r}], int index) {
        ${t}
      }
    `;return{getVecItem:new Y(o)}}}});var is,Bp=k(()=>{"use strict";Ep();Cp();Pp();Dp();kp();is={encoding:si,fragcolor:ui,vec:ci,shapeUtils:li,coordinates:ai}});var di,Rp=k(()=>{"use strict";gr();Ap();Bp();Xe();di=class{constructor(e,r,t,o){this.libs={};this.glslLibRoutineDependencyGraph={};this.context=new Yo(e,r,t,o),Object.keys(is).forEach(s=>{let a=new is[s](this.context);this.libs[s]=a});let i=this.glslLibRoutineDependencyGraph;for(let s in this.libs){let u=this.libs[s].getFunctions();for(let l in u){let d=s+"."+l,p;i[d]?(p=i[d],p.routineBody=u[l].routineBody):(p=new Zn(d,u[l].routineBody),i[d]=p);let h=u[l].dependencies;if(h)for(let g=0;g<h.length;++g)if(i[h[g]])p.addDependency(i[h[g]]);else{let y=new Zn(h[g]);i[h[g]]=y,p.addDependency(y)}}}}preprocess(){let e=this.context.programInfo,r=e.shaderSource;return this.context.programInfo.hasMain||(r=`${r}
      ${hc(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),r=_p(r),`${pc(this.context.glContext.version)}
    ${this.getUniforms(e.inputNames,e.variables)}
    ${this.getImports(r)}
    ${r}`}getImports(e){let r=this.selectGlslLibRoutinesToBeIncluded(e);if(r.length===0)return"";let t="";for(let o=0;o<r.length;++o)if(r[o].routineBody)t+=r[o].routineBody+`
`;else throw new Error(`Missing body for the Glsl Library routine: ${r[o].name}`);return t}selectGlslLibRoutinesToBeIncluded(e){let r=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(t=>{let o=t.split(".")[1];e.indexOf(o)!==-1&&r.push(this.glslLibRoutineDependencyGraph[t])}),Xo.returnOrderedNodes(r)}getUniforms(e,r){let t=[];if(e)for(let o of e)t.push(`uniform sampler2D ${o};`);if(r)for(let o of r)t.push(`uniform ${o.type} ${o.name}${o.arrayLength?`[${o.arrayLength}]`:""};`);return t.join(`
`)}}});var fi,Mp=k(()=>{"use strict";zt();Ot();Rp();Xe();fi=class{constructor(e,r,t){this.profiler=e;this.glContext=r;this.textureLayoutStrategy=t;this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,r){this.repo.set(e,r)}run(e,r,t){this.profiler.event("op",`ProgramManager.run ${e.programInfo.name??"unknown kernel"}`,()=>{let o=this.glContext.gl,i=e.program;o.useProgram(i);try{this.bindOutput(t),this.attributesBound||this.bindAttributes(e.attribLocations),this.bindUniforms(e.uniformLocations,e.programInfo.variables??[],r)}catch(s){throw Ne.error("ProgramManager",e.programInfo.shaderSource),s}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(e=>this.glContext.deleteProgram(e.program))}build(e,r,t){return this.profiler.event("backend","ProgramManager.build",()=>{let o=new di(this.glContext,e,r,t),i=o.preprocess(),s=this.compile(i);return{programInfo:e,program:s,uniformLocations:this.getUniformLocations(s,o.context.programInfo.inputNames,o.context.programInfo.variables),attribLocations:this.getAttribLocations(s)}})}compile(e){if(!this.vertexShader){Ne.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");let o=fc(this.glContext.version);this.vertexShader=this.glContext.compileShader(o,this.glContext.gl.VERTEX_SHADER)}xe.debug&&Ne.verbose("ProrgramManager",`FragShader:
${e}
`);let r=this.glContext.compileShader(e,this.glContext.gl.FRAGMENT_SHADER),t=this.glContext.createProgram(this.vertexShader,r);return this.glContext.deleteShader(r),t}bindOutput(e){let r=e.width,t=e.height;Ne.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${r}/${t}, shape=${e.shape}, type=${e.tensor.type}`),this.glContext.attachFramebuffer(e.texture,r,t)}bindAttributes(e){let r=e.position,t=e.textureCoord;this.glContext.setVertexAttributes(r,t),this.attributesBound=!0}bindUniforms(e,r,t){let o=this.glContext.gl,i=0;for(let{name:s,type:a,location:u,arrayLength:l}of e){let d=r.find(p=>p.name===s)?.data;if(a!=="sampler2D"&&!d)throw new Error(`variable '${s}' does not have data defined in program info`);switch(a){case"sampler2D":this.bindTexture(t[i],u,i),i++;break;case"float":l?o.uniform1fv(u,d):o.uniform1f(u,d);break;case"int":l?o.uniform1iv(u,d):o.uniform1i(u,d);break;default:throw new Error(`Uniform not implemented: ${a}`)}}}bindTexture(e,r,t){this.glContext.bindTextureToUniform(e.texture,t,r)}getAttribLocations(e){return{position:this.getAttribLocation(e,"position"),textureCoord:this.getAttribLocation(e,"textureCoord")}}getUniformLocations(e,r,t){let o=[];if(r)for(let i of r)o.push({name:i,type:"sampler2D",location:this.getUniformLocation(e,i)});if(t)for(let i of t)o.push({...i,location:this.getUniformLocation(e,i.name)});return o}getUniformLocation(e,r){let o=this.glContext.gl.getUniformLocation(e,r);if(o===null)throw new Error(`Uniform ${r} not found.`);return o}getAttribLocation(e,r){return this.glContext.gl.getAttribLocation(e,r)}}});var pi,Lp=k(()=>{"use strict";Ot();Xn();pi=class{constructor(e,r,t,o){this.glContext=e;this.layoutStrategy=r;this.profiler=t;this.config=o;this.pendingRead=new Map;o.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(e,r,t,o){let i=this.toEncoderType(e),s=this.glContext.getEncoder(i,r.channels||1,o);if(r.isPacked&&o===1)throw new Error("not implemented");let a=r.width,u=r.height,l,d;if(this.config.reuseTextures){l=`${a}x${u}_${s.format}_${s.internalFormat}_${s.textureType}`,d=this.inUseTextures.get(l),d||(d=[],this.inUseTextures.set(l,d));let h=this.idleTextures.get(l);if(h&&h.length>0){let g=h.pop();return d.push(g),o===1&&this.glContext.updateTexture(g,a,u,s,this.toTextureData(e,t)),g}}Ne.verbose("TextureManager",`Creating new texture of size ${r.width}x${r.height}`);let p=this.glContext.allocateTexture(a,u,s,this.toTextureData(e,t));return this.config.reuseTextures&&(d.push(p),this.textureLookup.set(p,l)),p}readTexture(e,r,t){return t||(t=1),this.profiler.event("backend","TextureManager.readTexture",()=>{let o=e.shape.reduce((s,a)=>s*a)*t,i=this.glContext.readTexture(e.texture,e.width,e.height,o,this.toEncoderType(r),t);return this.toTensorData(r,i)})}async readTextureAsync(e,r,t){let o=e.tensor.dataId;if(t||(t=1),this.pendingRead.has(o)){let i=this.pendingRead.get(o);return new Promise(s=>i?.push(s))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(o,[]);let i=e.shape.reduce((l,d)=>l*d)*t;await this.glContext.createAndWaitForFence();let s=this.glContext.readTexture(e.texture,e.width,e.height,i,this.toEncoderType(r),t),a=this.toTensorData(r,s),u=this.pendingRead.get(o);return this.pendingRead.delete(o),u?.forEach(l=>l(a)),a})}readUint8TextureAsFloat(e){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{let r=e.shape.reduce((o,i)=>o*i),t=this.glContext.readTexture(e.texture,e.width,e.height,r*4,"byte",4);return new Float32Array(t.buffer,t.byteOffset,r)})}releaseTexture(e,r){let t;if(this.config.reuseTextures&&(t=this.textureLookup.get(e.texture),t)){r&&this.textureLookup.delete(t);let o=this.inUseTextures.get(t);if(o){let i=o.indexOf(e.texture);if(i!==-1){o.splice(i,1);let s=this.idleTextures.get(t);s||(s=[],this.idleTextures.set(t,s)),s.push(e.texture)}}}(!t||r)&&(Ne.verbose("TextureManager",`Deleting texture of size ${e.width}x${e.height}`),this.glContext.deleteTexture(e.texture))}toTensorData(e,r){switch(e){case"int16":return r instanceof Int16Array?r:Int16Array.from(r);case"int32":return r instanceof Int32Array?r:Int32Array.from(r);case"int8":return r instanceof Int8Array?r:Int8Array.from(r);case"uint16":return r instanceof Uint16Array?r:Uint16Array.from(r);case"uint32":return r instanceof Uint32Array?r:Uint32Array.from(r);case"uint8":case"bool":return r instanceof Uint8Array?r:Uint8Array.from(r);case"float32":return r instanceof Float32Array?r:Float32Array.from(r);case"float64":return r instanceof Float64Array?r:Float64Array.from(r);default:throw new Error(`TensorData type ${e} is not supported`)}}toTextureData(e,r){if(r)return r instanceof Float32Array?r:new Float32Array(r)}toEncoderType(e){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}});var hi,Np=k(()=>{"use strict";Ot();Zu();Ec();Ip();Mp();os();Lp();hi=class{constructor(e,r){this.backend=e;this.context=r;this.layoutStrategy=new ii(e.glContext.maxTextureSize),this.programManager=new fi(this.context.profiler,e.glContext,this.layoutStrategy),this.textureManager=new pi(e.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:e.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=e.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new Ko(this)}onGraphInitialized(e){let r=e.getValues().filter(t=>t.from===-1&&t.tensor).map(t=>t.tensor.dataId);this.initializers=new Set(r)}isInitializer(e){return this.initializers?this.initializers.has(e):!1}addInitializer(e){this.initializers.add(e)}getTextureData(e,r){return r?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,r,t=!1){Ne.verbose("WebGLSessionHandler","Storing Texture data in cache"),t?this.packedTextureDataCache.set(e,r):this.unpackedTextureDataCache.set(e,r)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(e=>this.textureManager.releaseTexture(e,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(e=>this.textureManager.releaseTexture(e,!0)),this.unpackedTextureDataCache=new Map}resolve(e,r,t){let o=Ju(e,r,$p);return{impl:o.opImpl,context:o.opInit?o.opInit(e,t):e}}}});function Ix(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}var to,Fp=k(()=>{"use strict";zt();Xn();Xn();rr();to=class{constructor(e,r){this.frameBufferBound=!1;this.itemsToPoll=[];this.gl=e,this.version=r,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(e,r,t,o){let i=this.gl,s=i.createTexture();i.bindTexture(i.TEXTURE_2D,s),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE);let a=o?t.encode(o,e*r):null;return i.texImage2D(i.TEXTURE_2D,0,t.internalFormat,e,r,0,t.format,t.textureType,a),this.checkError(),s}updateTexture(e,r,t,o,i){let s=this.gl;s.bindTexture(s.TEXTURE_2D,e);let a=o.encode(i,r*t);s.texSubImage2D(s.TEXTURE_2D,0,0,0,r,t,o.format,o.textureType,a),this.checkError()}attachFramebuffer(e,r,t){let o=this.gl;o.bindTexture(o.TEXTURE_2D,e),o.bindFramebuffer(o.FRAMEBUFFER,this.framebuffer),o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,e,0),this.checkError(),o.viewport(0,0,r,t),o.scissor(0,0,r,t)}readTexture(e,r,t,o,i,s){let a=this.gl;s||(s=1),this.frameBufferBound||this.attachFramebuffer(e,r,t);let u=this.getEncoder(i,s),l=u.allocate(r*t);return a.bindTexture(a.TEXTURE_2D,e),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e,0),a.readPixels(0,0,r,t,a.RGBA,u.textureType,l),this.checkError(),u.decode(l,o)}isFramebufferReady(){return!0}getActiveTexture(){let e=this.gl;return`TEXTURE${e.getParameter(this.gl.ACTIVE_TEXTURE)-e.TEXTURE0}`}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(e,r){let t=this.gl;t.vertexAttribPointer(e,3,t.FLOAT,!1,20,0),t.enableVertexAttribArray(e),r!==-1&&(t.vertexAttribPointer(r,2,t.FLOAT,!1,20,12),t.enableVertexAttribArray(r)),this.checkError()}createProgram(e,r){let t=this.gl,o=t.createProgram();return t.attachShader(o,e),t.attachShader(o,r),t.linkProgram(o),o}compileShader(e,r){let t=this.gl,o=t.createShader(r);if(!o)throw new Error(`createShader() returned null with type ${r}`);if(t.shaderSource(o,e),t.compileShader(o),t.getShaderParameter(o,t.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${t.getShaderInfoLog(o)}
Shader source:
${e}`);return o}deleteShader(e){this.gl.deleteShader(e)}bindTextureToUniform(e,r,t){let o=this.gl;o.activeTexture(o.TEXTURE0+r),this.checkError(),o.bindTexture(o.TEXTURE_2D,e),this.checkError(),o.uniform1i(t,r),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(xe.debug){let e=this.gl,r=e.getError(),t="";switch(r){case e.NO_ERROR:return;case e.INVALID_ENUM:t="INVALID_ENUM";break;case e.INVALID_VALUE:t="INVALID_VALUE";break;case e.INVALID_OPERATION:t="INVALID_OPERATION";break;case e.INVALID_FRAMEBUFFER_OPERATION:t="INVALID_FRAMEBUFFER_OPERATION";break;case e.OUT_OF_MEMORY:t="OUT_OF_MEMORY";break;case e.CONTEXT_LOST_WEBGL:t="CONTEXT_LOST_WEBGL";break;default:t=`Unknown WebGL Error: ${r.toString(16)}`}throw new Error(t)}}deleteTexture(e){this.gl.deleteTexture(e)}deleteProgram(e){this.gl.deleteProgram(e)}getEncoder(e,r,t=0){if(this.version===2)return new jo(this.gl,r);switch(e){case"float":return t===1||this.isRenderFloat32Supported?new Yn(this.gl,r):new Yn(this.gl,r,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new qo(this.gl,r);default:throw new Error(`Invalid dataType: ${e}`)}}clearActiveTextures(){let e=this.gl;for(let r=0;r<this.maxTextureImageUnits;++r)e.activeTexture(e.TEXTURE0+r),e.bindTexture(e.TEXTURE_2D,null)}dispose(){if(this.disposed)return;let e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(this.framebuffer),e.bindBuffer(e.ARRAY_BUFFER,null),e.deleteBuffer(this.vertexbuffer),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),e.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){let e=this.gl,r=e.createBuffer();if(!r)throw new Error("createBuffer() returned null");let t=this.createDefaultGeometry();return e.bindBuffer(e.ARRAY_BUFFER,r),e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW),this.checkError(),r}createFramebuffer(){let e=this.gl.createFramebuffer();if(!e)throw new Error("createFramebuffer returned null");return e}queryVitalParameters(){let e=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=e.getParameter(e.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){let e=this.gl,r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);let t=this.version===2?e.RGBA32F:e.RGBA;e.texImage2D(e.TEXTURE_2D,0,t,1,1,0,e.RGBA,e.FLOAT,null);let o=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(o),i}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){let e=this.gl,r,t,o,i,s;try{r=e.createTexture(),t=e.createFramebuffer(),e.bindTexture(e.TEXTURE_2D,r);let a=this.version===2?e.RGBA32F:e.RGBA;return e.texImage2D(e.TEXTURE_2D,0,a,1,1,0,e.RGBA,e.FLOAT,null),e.bindFramebuffer(e.FRAMEBUFFER,t),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0),e.enable(e.BLEND),o=e.createShader(e.VERTEX_SHADER),!o||(e.shaderSource(o,"void main(){}"),e.compileShader(o),i=e.createShader(e.FRAGMENT_SHADER),!i)||(e.shaderSource(i,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),e.compileShader(i),s=e.createProgram(),!s)?!1:(e.attachShader(s,o),e.attachShader(s,i),e.linkProgram(s),e.useProgram(s),e.drawArrays(e.POINTS,0,1),e.getError()===e.NO_ERROR)}finally{e.disable(e.BLEND),s&&e.deleteProgram(s),o&&e.deleteShader(o),i&&e.deleteShader(i),t&&(e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(t)),r&&(e.bindTexture(e.TEXTURE_2D,null),e.deleteTexture(r))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let e=this.gl,r=this.disjointTimerQueryWebgl2Extension,t=e.createQuery();return e.beginQuery(r.TIME_ELAPSED_EXT,t),t}else throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let e=this.gl,r=this.disjointTimerQueryWebgl2Extension;e.endQuery(r.TIME_ELAPSED_EXT);return}else throw new Error("WebGL1 profiling currently not supported")}isTimerResultAvailable(e){let r=!1,t=!1;if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let o=this.gl,i=this.disjointTimerQueryWebgl2Extension;r=o.getQueryParameter(e,o.QUERY_RESULT_AVAILABLE),t=o.getParameter(i.GPU_DISJOINT_EXT)}else throw new Error("WebGL1 profiling currently not supported");return r&&!t}getTimerResult(e){let r=0;if(this.version===2){let t=this.gl;r=t.getQueryParameter(e,t.QUERY_RESULT),t.deleteQuery(e)}else throw new Error("WebGL1 profiling currently not supported");return r/1e6}async waitForQueryAndGetTime(e){return await Ca(()=>this.isTimerResultAvailable(e)),this.getTimerResult(e)}async createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let r,t=e,o=t.fenceSync(t.SYNC_GPU_COMMANDS_COMPLETE,0);return e.flush(),o===null?r=()=>!0:r=()=>{let i=t.clientWaitSync(o,0,0);return i===t.ALREADY_SIGNALED||i===t.CONDITION_SATISFIED},{query:o,isFencePassed:r}}async pollFence(e){return new Promise(r=>{this.addItemToPoll(()=>e.isFencePassed(),()=>r())})}pollItems(){let e=Ix(this.itemsToPoll.map(r=>r.isDoneFn));for(let r=0;r<=e;++r){let{resolveFn:t}=this.itemsToPoll[r];t()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}async addItemToPoll(e,r){this.itemsToPoll.push({isDoneFn:e,resolveFn:r}),!(this.itemsToPoll.length>1)&&await Ca(()=>(this.pollItems(),this.itemsToPoll.length===0))}}});function as(n){let e;if((!n||n==="webgl2")&&"webgl2"in xn?e=xn.webgl2:(!n||n==="webgl")&&"webgl"in xn&&(e=xn.webgl),!e)try{let t=_x();e=zp(t,n)}catch{let o=Sx();e=zp(o,n)}n=n||e.version===1?"webgl":"webgl2";let r=e.gl;return xn[n]=e,r.isContextLost()?(delete xn[n],as(n)):(r.disable(r.DEPTH_TEST),r.disable(r.STENCIL_TEST),r.disable(r.BLEND),r.disable(r.DITHER),r.disable(r.POLYGON_OFFSET_FILL),r.disable(r.SAMPLE_COVERAGE),r.enable(r.SCISSOR_TEST),r.enable(r.CULL_FACE),r.cullFace(r.BACK),e)}function zp(n,e){let r={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1},t,o=r;if((!e||e==="webgl2")&&(t=n.getContext("webgl2",o),t))try{return new to(t,2)}catch(i){Ne.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${i}`)}if((!e||e==="webgl")&&(t=n.getContext("webgl",o)||n.getContext("experimental-webgl",o),t))try{return new to(t,1)}catch(i){Ne.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${i}`)}throw new Error("WebGL is not supported")}function Sx(){if(typeof document>"u")throw new TypeError("failed to create canvas: document is not supported");let n=document.createElement("canvas");return n.width=1,n.height=1,n}function _x(){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}var xn,Gp=k(()=>{"use strict";Ot();Fp();xn={}});var mi,Wp=k(()=>{"use strict";zt();Ot();Np();Gp();mi=class{get contextId(){return xe.webgl.contextId}set contextId(e){xe.webgl.contextId=e}get matmulMaxBatchSize(){return xe.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(e){xe.webgl.matmulMaxBatchSize=e}get textureCacheMode(){return xe.webgl.textureCacheMode}set textureCacheMode(e){xe.webgl.textureCacheMode=e}get pack(){return xe.webgl.pack}set pack(e){xe.webgl.pack=e}get async(){return xe.webgl.async}set async(e){xe.webgl.async=e}initialize(){try{return this.glContext=as(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),Ne.setWithEnv(xe),xe.webgl.context||Object.defineProperty(xe.webgl,"context",{value:this.glContext.gl}),Ne.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(e){return Ne.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${e}`),!1}}createSessionHandler(e){return new hi(this,e)}dispose(){this.glContext.dispose()}}});async function ss(n){if(n){let e=typeof n=="string"?[n]:n;for(let r of e){let t=Vp.get(r);if(t)return t;let o=await Ox(r);if(o)return o}}else return ss(["webgl"]);throw new Error("no available backend to use")}async function Ox(n){let e=Ax;if(typeof e[n]<"u"&&Ex(e[n])){let r=e[n],t=r.initialize();if(typeof t=="object"&&"then"in t&&(t=await t),t)return Vp.set(n,r),r}}function Ex(n){let e=n;return"initialize"in e&&typeof e.initialize=="function"&&"createSessionHandler"in e&&typeof e.createSessionHandler=="function"&&"dispose"in e&&typeof e.dispose=="function"}var Vp,Ax,Up=k(()=>{"use strict";Wp();Vp=new Map,Ax={webgl:new mi}});var us,gi,Hp=k(()=>{"use strict";Ot();us=class{constructor(e,r){this.op=e;this.node=r}},gi=class{constructor(e,r,t){this.graph=e;this.profiler=t;this.initialize(r)}initialize(e){this.profiler.event("session","ExecutionPlan.initialize",()=>{let r=this.graph.getNodes();if(r.length!==e.length)throw new Error("The size of nodes and OPs do not match.");this._ops=e.map((t,o)=>new us(t,r[o])),this.reset(),this._starter=[],this._ops.forEach((t,o)=>{let i=!0;for(let s of t.node.inputs)if(!this._values[s]&&this.graph.getInputIndices().indexOf(s)===-1){i=!1;break}i&&this._starter.push(o)})})}reset(){this._values=this.graph.getValues().map(e=>e.tensor)}async execute(e,r){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();let t=e.createInferenceHandler(),o=this.graph.getInputIndices();if(r.length!==o.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${r.length} expected: ${o.length}`);r.forEach((d,p)=>{let h=o[p];this._values[h]=d});let i=this._starter.slice(0),s=this.graph.getValues(),a=this.graph.getNodes(),u=0;for(;u<i.length;){let d=i[u++],p=this._ops[d],h=p.node.inputs.map(w=>this._values[w]);if(h.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${p.node}`);let g=h;Ne.verbose("ExecPlan",`Runing op:${p.node.name} (${g.map((w,I)=>`'${p.node.inputs[I]}': ${w.type}[${w.dims.join(",")}]`).join(", ")})`);let y=await this.profiler.event("node",p.node.name,async()=>p.op.impl(t,g,p.op.context));if(y.length!==p.node.outputs.length)throw new Error("the size of output does not match model definition.");y.forEach((w,I)=>{let O=p.node.outputs[I];if(this._values[O])throw new Error(`output [${O}] already has value: op:${p.node.name}`);this._values[O]=w});let b=new Set;y.forEach((w,I)=>{let O=p.node.outputs[I];for(let E of s[O].to){let N=a[E],F=!0;for(let R of N.inputs)if(!this._values[R]){F=!1;break}F&&b.add(E)}}),i.push(...b)}let l=[];for(let d=0;d<this.graph.getOutputIndices().length;d++){let p=this.graph.getOutputIndices()[d],h=this._values[p];if(h===void 0)throw new Error(`required output [${p}] does not have value`);p===0?await h.getData():h.data,l.push(h)}return Ne.verbose("ExecPlan","disposing of inferenceHandler"),t.dispose(),l})}}});var Se,Rt,ro,jp=k(()=>{"use strict";Vn();Se=un(fn());Hr();Me();Rt=ne.experimental.fbs,ro=class n{constructor(e){if(this._attributes=new Map,e!=null){for(let r of e)r instanceof Se.onnx.AttributeProto?this._attributes.set(r.name,[n.getValue(r),n.getType(r)]):r instanceof Rt.Attribute&&this._attributes.set(r.name(),[n.getValue(r),n.getType(r)]);if(this._attributes.size<e.length)throw new Error("duplicated attribute names")}}set(e,r,t){this._attributes.set(e,[t,r])}delete(e){this._attributes.delete(e)}getFloat(e,r){return this.get(e,"float",r)}getInt(e,r){return this.get(e,"int",r)}getString(e,r){return this.get(e,"string",r)}getTensor(e,r){return this.get(e,"tensor",r)}getFloats(e,r){return this.get(e,"floats",r)}getInts(e,r){return this.get(e,"ints",r)}getStrings(e,r){return this.get(e,"strings",r)}getTensors(e,r){return this.get(e,"tensors",r)}get(e,r,t){let o=this._attributes.get(e);if(o===void 0){if(t!==void 0)return t;throw new Error(`required attribute not found: ${e}`)}if(o[1]!==r)throw new Error(`type mismatch: expected ${r} but got ${o[1]}`);return o[0]}static getType(e){let r=e instanceof Se.onnx.AttributeProto?e.type:e.type();switch(r){case Se.onnx.AttributeProto.AttributeType.FLOAT:return"float";case Se.onnx.AttributeProto.AttributeType.INT:return"int";case Se.onnx.AttributeProto.AttributeType.STRING:return"string";case Se.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case Se.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case Se.onnx.AttributeProto.AttributeType.INTS:return"ints";case Se.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case Se.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${Se.onnx.AttributeProto.AttributeType[r]}`)}}static getValue(e){let r=e instanceof Se.onnx.AttributeProto?e.type:e.type();if(r===Se.onnx.AttributeProto.AttributeType.GRAPH||r===Se.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");let t=this.getValueNoCheck(e);if(r===Se.onnx.AttributeProto.AttributeType.INT&&St.isLong(t))return St.longToNumber(t);if(r===Se.onnx.AttributeProto.AttributeType.INTS){let o=t,i=new Array(o.length);for(let s=0;s<o.length;s++){let a=o[s];i[s]=St.longToNumber(a)}return i}if(r===Se.onnx.AttributeProto.AttributeType.TENSOR)return e instanceof Se.onnx.AttributeProto?at.fromProto(t):at.fromOrtTensor(t);if(r===Se.onnx.AttributeProto.AttributeType.TENSORS){if(e instanceof Se.onnx.AttributeProto)return t.map(i=>at.fromProto(i));if(e instanceof Rt.Attribute)return t.map(i=>at.fromOrtTensor(i))}return r===Se.onnx.AttributeProto.AttributeType.STRING&&e instanceof Se.onnx.AttributeProto?Kn(t):r===Se.onnx.AttributeProto.AttributeType.STRINGS&&e instanceof Se.onnx.AttributeProto?t.map(Kn):t}static getValueNoCheck(e){return e instanceof Se.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(e):this.getValueNoCheckFromOrtFormat(e)}static getValueNoCheckFromOnnxFormat(e){switch(e.type){case Se.onnx.AttributeProto.AttributeType.FLOAT:return e.f;case Se.onnx.AttributeProto.AttributeType.INT:return e.i;case Se.onnx.AttributeProto.AttributeType.STRING:return e.s;case Se.onnx.AttributeProto.AttributeType.TENSOR:return e.t;case Se.onnx.AttributeProto.AttributeType.GRAPH:return e.g;case Se.onnx.AttributeProto.AttributeType.FLOATS:return e.floats;case Se.onnx.AttributeProto.AttributeType.INTS:return e.ints;case Se.onnx.AttributeProto.AttributeType.STRINGS:return e.strings;case Se.onnx.AttributeProto.AttributeType.TENSORS:return e.tensors;case Se.onnx.AttributeProto.AttributeType.GRAPHS:return e.graphs;default:throw new Error(`unsupported attribute type: ${Se.onnx.AttributeProto.AttributeType[e.type]}`)}}static getValueNoCheckFromOrtFormat(e){switch(e.type()){case Rt.AttributeType.FLOAT:return e.f();case Rt.AttributeType.INT:return e.i();case Rt.AttributeType.STRING:return e.s();case Rt.AttributeType.TENSOR:return e.t();case Rt.AttributeType.GRAPH:return e.g();case Rt.AttributeType.FLOATS:return e.floatsArray();case Rt.AttributeType.INTS:{let r=[];for(let t=0;t<e.intsLength();t++)r.push(e.ints(t));return r}case Rt.AttributeType.STRINGS:{let r=[];for(let t=0;t<e.stringsLength();t++)r.push(e.strings(t));return r}case Rt.AttributeType.TENSORS:{let r=[];for(let t=0;t<e.tensorsLength();t++)r.push(e.tensors(t));return r}default:throw new Error(`unsupported attribute type: ${Rt.AttributeType[e.type()]}`)}}}});var cs,bi,ds,ir,yi,ls,qp=k(()=>{"use strict";jp();Vn();cs=un(fn());Hr();Me();bi=ne.experimental.fbs,ds={from:(n,e)=>new ls(n,e)},ir=class{constructor(e){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,e&&(this.type=pt.tensorValueTypeFromProto(e.type.tensorType))}get from(){return this._from}get to(){return this._to}},yi=class{constructor(e,r){e instanceof cs.onnx.NodeProto?(this.name=e.name,this.opType=e.opType,this.attributes=new ro(e.attribute)):e instanceof bi.Node&&(this.name=r??e.name(),this.opType=e.opType(),this.attributes=new ro(pt.tensorAttributesFromORTFormat(e))),this.inputs=[],this.outputs=[],this.executeNode=!0}},ls=class{constructor(e,r){if(!e)throw new TypeError("graph is empty");this.buildGraph(e),this.transformGraph(r),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(e){if(e instanceof cs.onnx.GraphProto)this.buildGraphFromOnnxFormat(e);else if(e instanceof bi.Graph)this.buildGraphFromOrtFormat(e);else throw new TypeError("Graph type is not supported.")}buildGraphFromOnnxFormat(e){let r=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let t=new Map;if(!e.input)throw new Error("missing information in graph: input");let o=[];for(let i of e.input){if(r.has(i.name))throw new Error(`duplicated input name: ${i.name}`);let s=this._allData.push(new ir(i))-1;r.set(i.name,s),o.push(i.name)}if(!e.initializer)throw new Error("missing information in graph: initializer");for(let i of e.initializer){let s=r.get(i.name);if(s===void 0){let a=new ir;a.type={shape:{dims:pt.tensorDimsFromProto(i.dims)},tensorType:pt.tensorDataTypeFromProto(i.dataType)},s=this._allData.push(a)-1,r.set(i.name,s)}this._allData[s]._from=-1,this._allData[s].tensor=at.fromProto(i)}for(let i=0;i<this._allData.length;i++)this._allData[i].tensor||(this._allInputIndices.push(i),this._allInputNames.push(o[i]));if(!e.output)throw new Error("missing information in graph: output");for(let i of e.output){if(r.has(i.name))throw new Error(`duplicated output name: ${i.name}`);let s=this._allData.push(new ir(i))-1;r.set(i.name,s),this._allOutputIndices.push(s),this._allOutputNames.push(i.name)}if(!e.node)throw new Error("missing information in graph: node");for(let i of e.node){if(!i.name)for(let a=0;;a++){let u=`unnamed_${i.opType}_${a}`;if(!t.has(u)){i.name=u;break}}if(t.has(i.name))throw new Error(`duplicated node name: ${i.name}`);let s=this._nodes.push(new yi(i))-1;t.set(i.name,s)}for(let i=0;i<this._nodes.length;i++){let s=this._nodes[i],a=e.node[i];if(!a.output)throw new Error(`missing output for node: ${a.name}`);for(let u of a.output){let l=r.get(u);if(typeof l>"u"&&(l=this._allData.push(new ir)-1,r.set(u,l)),s.outputs.push(l),this._allData[l]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${l}`);if(this._allData[l]._from=i,a.opType==="Constant"){if(!a.attribute||a.attribute.length!==1||!a.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!a.output||a.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");s.outputs.pop(),s.executeNode=!1,this._allData[l]._from=-1,this._allData[l].tensor=at.fromProto(a.attribute[0].t)}}}for(let i=0;i<this._nodes.length;i++){let s=this._nodes[i],a=e.node[i];if(!a.input)throw new Error(`missing input for node: ${a.name}`);for(let u of a.input){let l=r.get(u);if(typeof l>"u"){if(u===""&&(a.input.length===3||a.input.length===4)&&a.opType==="Resize")continue;throw new Error(`unrecognized input '${u}' for node: ${a.name}`)}s.inputs.push(l),this._allData[l]._to.push(i)}}return!0}buildGraphFromOrtFormat(e){let r=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let t=new Map,o=[];for(let i=0;i<e.inputsLength();i++){let s=e.inputs(i);if(r.has(s))throw new Error(`duplicated input name: ${s}`);for(let a=0;a<e.nodeArgsLength();a++)if(e.nodeArgs(a)?.name()===s){let u=new ir;if(e.nodeArgs(a)?.type()?.valueType()!==bi.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");let d=e.nodeArgs(a).type().value(new bi.TensorTypeAndShape),p=pt.tensorDataTypeFromProto(d.elemType()),h=d.shape(),g=[];for(let b=0;b<h.dimLength();b++)g.push(St.longToNumber(h.dim(b).value().dimValue()));u.type={shape:{dims:g},tensorType:p};let y=this._allData.push(u)-1;r.set(s,y),o.push(s)}}for(let i=0;i<e.initializersLength();i++){let s=e.initializers(i),a=r.get(s.name());if(a===void 0){let u=new ir,l=pt.tensorDimsFromORTFormat(s),d=pt.tensorDataTypeFromProto(s.dataType());u.type={shape:{dims:l},tensorType:d},a=this._allData.push(u)-1,r.set(s.name(),a)}this._allData[a]._from=-1,this._allData[a].tensor=at.fromOrtTensor(s)}for(let i=0;i<this._allData.length;i++)this._allData[i].tensor||(this._allInputIndices.push(i),this._allInputNames.push(o[i]));for(let i=0;i<e.outputsLength();i++){let s=e.outputs(i);if(r.has(s))throw new Error(`duplicated output name: ${s}`);let a=this._allData.push(new ir)-1;r.set(s,a),this._allOutputIndices.push(a),this._allOutputNames.push(s)}if(!e.nodes)throw new Error("missing information in graph: node");for(let i=0;i<e.nodesLength();i++){let s=e.nodes(i),a=s.name();if(!a)for(let l=0;a=`unnamed_${s.opType()}_${l}`,!!t.has(a);l++);if(t.has(a))throw new Error(`duplicated node name: ${a}`);let u=this._nodes.push(new yi(s,a))-1;t.set(a,u)}for(let i=0;i<this._nodes.length;i++){let s=this._nodes[i],a=e.nodes(i);if(a==null)throw new Error(`No node exists at index ${i}`);if(a?.outputsLength()===0)throw new Error(`missing output for node: ${a.name}`);for(let u=0;u<a?.outputsLength();u++){let l=a?.outputs(u),d=r.get(l);if(typeof d>"u"&&(d=this._allData.push(new ir)-1,r.set(l,d)),s.outputs.push(d),this._allData[d]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${d}`);if(this._allData[d]._from=i,a.opType()==="Constant"){if(a.attributesLength()!==1||!a.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(a.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");s.outputs.pop(),s.executeNode=!1,this._allData[d]._from=-1,this._allData[d].tensor=at.fromOrtTensor(a.attributes(0).t())}}}for(let i=0;i<this._nodes.length;i++){let s=this._nodes[i],a=e.nodes(i);if(a.inputsLength()===0)throw new Error(`missing input for node: ${a.name}`);for(let u=0;u<a.inputsLength();u++){let l=a.inputs(u),d=r.get(l);if(typeof d>"u")throw new Error(`unrecognized input '${l}' for node: ${a.name()}`);s.inputs.push(d),this._allData[d]._to.push(i)}}}checkIsAcyclic(){let e=new Set;this._allInputIndices.forEach(o=>{this._allData[o]._to.forEach(s=>{e.add(s)})});let r=Array.from(e),t=new Array(this._nodes.length).fill("white");for(;r.length>0;){let o=r.pop();t[o]==="gray"?t[o]="black":(r.push(o),t[o]="gray",this._nodes[o].outputs.forEach(i=>{let s=this._allData[i];if(typeof s.tensor<"u")throw new Error("node outputs should not be initialized");if(s._from!==o)throw new Error("from property of the Value object doesn't match index of Node being processed");s._to.forEach(a=>{if(t[a]==="gray")throw new Error("model graph is cyclic");t[a]==="white"&&r.push(a)})}))}}transformGraph(e){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),e&&e.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let e=0,r=new Array(this._nodes.length,0),t=0;for(let o=0;o<this._nodes.length;o++)r[o]=t,this._nodes[o].executeNode?(t!==o&&(this._nodes[t]=this._nodes[o]),t++):this._nodes[o].outputs.forEach(i=>{this._allData[i]._from=-2});this._nodes.splice(t,this._nodes.length-t);for(let o=0;o<this._allData.length;o++){let i=this._allData[o];i._from!==void 0&&i._from!==-1&&i._from!==-2&&(i._from=r[i._from]);for(let s=0;s<i._to.length;s++)if(i._to[s]>=0)i._to[s]=r[i._to[s]];else throw new Error("Trying to update a removed node")}e=0;for(let o=0;o<this._allData.length;o++){if(this._allData[o].from===-2&&this._allOutputIndices.indexOf(o+e)===-1){e++,this._allData.splice(o,1),o--;continue}if(e>0){let i=-1;this._allData[o].from!==void 0&&this._allData[o].from!==-1?(i=this._nodes[this._allData[o].from].outputs.indexOf(o+e),i!==-1&&(this._nodes[this._allData[o].from].outputs[i]=o)):(i=this._allInputIndices.indexOf(o+e),i!==-1&&(this._allInputIndices[i]=o)),this._allData[o].to.forEach(s=>{i=this._nodes[s].inputs.indexOf(o+e),i!==-1&&(this._nodes[s].inputs[i]=o)}),this._allData[o].to.length===0&&(i=this._allOutputIndices.indexOf(o+e),i!==-1&&(this._allOutputIndices[i]=o))}}}deleteNode(e){let r=this._nodes[e];if(r.outputs.length>1){for(let a=1;a<r.outputs.length;a++)if(this._allData[r.outputs[a]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}r.executeNode=!1;let t=r.inputs[0],o=r.outputs[0],i=this._allData[o].to;for(let a=0;a<r.inputs.length;a++){let u=this._allData[r.inputs[a]].to.indexOf(e);if(u===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[r.inputs[a]].to.splice(u,1)}this._allData[o]._to=[];let s=this._allOutputIndices.indexOf(o);if(s!==-1&&(this._allOutputIndices[s]=t),i&&i.length>0)for(let a of i){let u=this._nodes[a].inputs.indexOf(o);if(u===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[a].inputs[u]=t,this._allData[t].to.push(a)}}removeAllDropoutNodes(){let e=0;for(let r of this._nodes){if(r.opType==="Dropout"){if(r.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(r.outputs.length!==1&&r.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(r.outputs.length===2&&this._allData[r.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(e)}e++}}removeAllIdentityNodes(){let e=0;for(let r of this._nodes)r.opType==="Identity"&&this.deleteNode(e),e++}isActivation(e){switch(e.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(let e of this._nodes)if(e.opType==="Conv"){let r=this._allData[e.outputs[0]]._to;if(r.length===1&&this.isActivation(this._nodes[r[0]])){let t=this._nodes[r[0]];if(t.opType==="Clip")if(t.inputs.length===1)try{e.attributes.set("activation_params","floats",[t.attributes.getFloat("min"),t.attributes.getFloat("max")])}catch{e.attributes.set("activation_params","floats",[Vr,Ur])}else if(t.inputs.length>=3&&this._allData[t.inputs[1]].tensor!==void 0&&this._allData[t.inputs[2]].tensor!==void 0)e.attributes.set("activation_params","floats",[this._allData[t.inputs[1]].tensor.floatData[0],this._allData[t.inputs[2]].tensor.floatData[0]]);else continue;e.attributes.set("activation","string",t.opType),this.deleteNode(r[0])}}}}});var Kp,Cx,vi,Yp=k(()=>{"use strict";Fo();qp();Vn();Kp=un(fn());Me();Cx=ne.experimental.fbs,vi=class{constructor(){}load(e,r,t){if(!t)try{this.loadFromOnnxFormat(e,r);return}catch(o){if(t!==void 0)throw o}this.loadFromOrtFormat(e,r)}loadFromOnnxFormat(e,r){let t=Kp.onnx.ModelProto.decode(e);if(St.longToNumber(t.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=t.opsetImport.map(i=>({domain:i.domain,version:St.longToNumber(i.version)})),this._graph=ds.from(t.graph,r)}loadFromOrtFormat(e,r){let t=new C.ByteBuffer(e),o=Cx.InferenceSession.getRootAsInferenceSession(t).model();if(St.longToNumber(o.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let s=0;s<o.opsetImportLength();s++){let a=o.opsetImport(s);this._opsets.push({domain:a?.domain(),version:St.longToNumber(a.version())})}this._graph=ds.from(o.graph(),r)}get graph(){return this._graph}get opsets(){return this._opsets}}});var xi,Xp=k(()=>{"use strict";Up();Hp();Ot();Yp();xi=class{constructor(e={}){this._initialized=!1,this.backendHint=e.backendHint,this.profiler=Lo.create(e.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(e,r,t){await this.profiler.event("session","Session.loadModel",async()=>{let o=await ss(this.backendHint);if(this.sessionHandler=o.createSessionHandler(this.context),this._model=new vi,typeof e=="string"){let i=e.endsWith(".ort");if(typeof process<"u"&&process.versions&&process.versions.node){let s=await(void 0)(e);this.initialize(s,i)}else{let a=await(await fetch(e)).arrayBuffer();this.initialize(new Uint8Array(a),i)}}else if(ArrayBuffer.isView(e))this.initialize(e);else{let i=new Uint8Array(e,r||0,t||e.byteLength);this.initialize(i)}})}initialize(e,r){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{let t=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(e,t,r),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new gi(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(e){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{let r=this.normalizeAndValidateInputs(e),t=await this._executionPlan.execute(this.sessionHandler,r);return this.createOutput(t)})}normalizeAndValidateInputs(e){let r=this._model.graph.getInputNames();if(Array.isArray(e)){if(e.length!==r.length)throw new Error(`incorrect input array length: expected ${r.length} but got ${e.length}`)}else{if(e.size!==r.length)throw new Error(`incorrect input map size: expected ${r.length} but got ${e.size}`);let t=new Array(e.size),o=0;for(let i=0;i<r.length;++i){let s=e.get(r[i]);if(!s)throw new Error(`missing input tensor for: '${name}'`);t[o++]=s}e=t}if(!this.context.graphInputTypes||this.context.graphInputTypes.length===0||!this.context.graphInputDims||this.context.graphInputDims.length===0){let t=this._model.graph.getInputIndices(),o=this._model.graph.getValues(),i=new Array(t.length);for(let s=0;s<t.length;++s){let a=o[t[s]];i[s]=a.type.shape.dims,this.context.graphInputTypes.push(a.type.tensorType),this.context.graphInputDims.push(e[s].dims)}this.validateInputTensorDims(i,e,!0)}else this.validateInputTensorDims(this.context.graphInputDims,e,!1);return this.validateInputTensorTypes(this.context.graphInputTypes,e),e}validateInputTensorTypes(e,r){for(let t=0;t<r.length;t++){let o=e[t],i=r[t].type;if(o!==i)throw new Error(`input tensor[${t}] check failed: expected type '${o}' but got ${i}`)}}validateInputTensorDims(e,r,t){for(let o=0;o<r.length;o++){let i=e[o],s=r[o].dims;if(!this.compareTensorDims(i,s,t))throw new Error(`input tensor[${o}] check failed: expected shape '[${i.join(",")}]' but got [${s.join(",")}]`)}}compareTensorDims(e,r,t){if(e.length!==r.length)return!1;for(let o=0;o<e.length;++o)if(e[o]!==r[o]&&(!t||e[o]!==0)&&e[o]!==null)return!1;return!0}createOutput(e){let r=this._model.graph.getOutputNames();if(e.length!==r.length)throw new Error("expected number of outputs do not match number of generated outputs");let t=new Map;for(let o=0;o<r.length;++o)t.set(r[o],e[o]);return t}initializeOps(e){let r=e.getNodes();this._ops=new Array(r.length);for(let t=0;t<r.length;t++)this._ops[t]=this.sessionHandler.resolve(r[t],this._model.opsets,e)}}});var wi,Jp=k(()=>{"use strict";zt();Hr();wi=class{constructor(e){this.session=e;this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(e,r,t){let o=new Map;for(let a in e)if(Object.hasOwnProperty.call(e,a)){let u=e[a];o.set(a,new at(u.dims,u.type,void 0,void 0,u.data))}let i=await this.session.run(o),s={};return i.forEach((a,u)=>{s[u]=new Ft(a.type,a.data,a.dims)}),s}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}});var Zp={};sn(Zp,{onnxjsBackend:()=>Dx});var fs,Dx,Qp=k(()=>{"use strict";Xp();Jp();fs=class{async init(){}async createInferenceSessionHandler(e,r){let t=new xi(r);return typeof e=="string"?await t.loadModel(e):await t.loadModel(e),new wi(t)}},Dx=new fs});var ps={};sn(ps,{readFile:()=>kx});var kx,hs=k(()=>{kx=void 0});var ms={};sn(ms,{join:()=>Bx});var Bx,gs=k(()=>{Bx=void 0});var rh=Ve((th,bs)=>{"use strict";var eh=(()=>{var n=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(n=n||__filename),function(e={}){var r=e,t,o;r.ready=new Promise((f,v)=>{t=f,o=v}),r.jsepInit=(f,v,$,A,B,G,X,pe)=>{r.Za=f,r.Oa=v,r.Qa=$,r.Ja=A,r.Pa=B,r.ra=G,r.Ra=X,r.Sa=pe,v=(re,ie,ce)=>(...Ie)=>{let Ae=At,M=ie?.();Ie=re(...Ie);let be=ie?.();return M!==be&&(re=be,ce(M),ie=ce=null),At!=Ae?go():Ie},$=re=>async(...ie)=>{try{if(r.Da)throw Error("Session already started");let ce=r.Da={Ta:ie[0],errors:[]},Ie=await re(...ie);if(r.Da!==ce)throw Error("Session mismatch");f.flush();let Ae=ce.errors;if(0<Ae.length){let M=await Promise.all(Ae);if(M=M.filter(be=>be),0<M.length)throw Error(M.join(`
`))}return Ie}finally{r.Da=null}},r._OrtRun=$(v(r._OrtRun,()=>r._OrtRun,re=>r._OrtRun=re)),r._OrtRunWithBinding=$(v(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,re=>r._OrtRunWithBinding=re)),r._OrtBindInput=v(r._OrtBindInput,()=>r._OrtBindInput,re=>r._OrtBindInput=re),r.jsepRegisterBuffer=(re,ie,ce,Ie)=>f.registerBuffer(re,ie,ce,Ie),r.jsepUnregisterBuffers=re=>{f.unregisterBuffers(re)},r.jsepGetBuffer=re=>f.getBuffer(re),r.jsepCreateDownloader=(re,ie,ce)=>f.createDownloader(re,ie,ce)};var i=Object.assign({},r),s="./this.program",a=(f,v)=>{throw v},u=typeof window=="object",l=typeof importScripts=="function",d=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",p="",h,g,y;if(d){var b=(hs(),vr(ps)),w=(gs(),vr(ms));p=l?w.dirname(p)+"/":__dirname+"/",h=(f,v)=>(f=f.startsWith("file://")?new URL(f):w.normalize(f),b.readFileSync(f,v?void 0:"utf8")),y=f=>(f=h(f,!0),f.buffer||(f=new Uint8Array(f)),f),g=(f,v,$,A=!0)=>{f=f.startsWith("file://")?new URL(f):w.normalize(f),b.readFile(f,A?void 0:"utf8",(B,G)=>{B?$(B):v(A?G.buffer:G)})},!r.thisProgram&&1<process.argv.length&&(s=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),a=(f,v)=>{throw process.exitCode=f,v},r.inspect=()=>"[Emscripten Module object]"}else(u||l)&&(l?p=self.location.href:typeof document<"u"&&document.currentScript&&(p=document.currentScript.src),n&&(p=n),p.indexOf("blob:")!==0?p=p.substr(0,p.replace(/[?#].*/,"").lastIndexOf("/")+1):p="",h=f=>{var v=new XMLHttpRequest;return v.open("GET",f,!1),v.send(null),v.responseText},l&&(y=f=>{var v=new XMLHttpRequest;return v.open("GET",f,!1),v.responseType="arraybuffer",v.send(null),new Uint8Array(v.response)}),g=(f,v,$)=>{var A=new XMLHttpRequest;A.open("GET",f,!0),A.responseType="arraybuffer",A.onload=()=>{A.status==200||A.status==0&&A.response?v(A.response):$()},A.onerror=$,A.send(null)});var I=r.print||console.log.bind(console),O=r.printErr||console.error.bind(console);Object.assign(r,i),i=null,r.thisProgram&&(s=r.thisProgram),r.quit&&(a=r.quit);var E;r.wasmBinary&&(E=r.wasmBinary);var N=r.noExitRuntime||!0;typeof WebAssembly!="object"&&gt("no native wasm support detected");var F,R,V=!1,K,J,ge,P,oe,Ke;function te(){var f=F.buffer;r.HEAP8=J=new Int8Array(f),r.HEAP16=new Int16Array(f),r.HEAP32=P=new Int32Array(f),r.HEAPU8=ge=new Uint8Array(f),r.HEAPU16=new Uint16Array(f),r.HEAPU32=oe=new Uint32Array(f),r.HEAPF32=new Float32Array(f),r.HEAPF64=Ke=new Float64Array(f)}var Z=[],mt=[],Ce=[];function st(){var f=r.preRun.shift();Z.unshift(f)}var Fe=0,ut=null,Kt=null;function gt(f){throw r.onAbort&&r.onAbort(f),f="Aborted("+f+")",O(f),V=!0,K=1,f=new WebAssembly.RuntimeError(f+". Build with -sASSERTIONS for more info."),o(f),f}function cr(f){return f.startsWith("data:application/octet-stream;base64,")}var H;if(H="ort-wasm-simd.wasm",!cr(H)){var Te=H;H=r.locateFile?r.locateFile(Te,p):p+Te}function ke(f){if(f==H&&E)return new Uint8Array(E);if(y)return y(f);throw"both async and sync fetching of the wasm failed"}function bt(f){if(!E&&(u||l)){if(typeof fetch=="function"&&!f.startsWith("file://"))return fetch(f,{credentials:"same-origin"}).then(v=>{if(!v.ok)throw"failed to load wasm binary file at '"+f+"'";return v.arrayBuffer()}).catch(()=>ke(f));if(g)return new Promise((v,$)=>{g(f,A=>v(new Uint8Array(A)),$)})}return Promise.resolve().then(()=>ke(f))}function wt(f,v,$){return bt(f).then(A=>WebAssembly.instantiate(A,v)).then(A=>A).then($,A=>{O("failed to asynchronously prepare wasm: "+A),gt(A)})}function Ze(f,v){var $=H;return E||typeof WebAssembly.instantiateStreaming!="function"||cr($)||$.startsWith("file://")||d||typeof fetch!="function"?wt($,f,v):fetch($,{credentials:"same-origin"}).then(A=>WebAssembly.instantiateStreaming(A,f).then(v,function(B){return O("wasm streaming compile failed: "+B),O("falling back to ArrayBuffer instantiation"),wt($,f,v)}))}var Ye,Tt={910336:f=>{r.ra("Abs",f,void 0)},910387:f=>{r.ra("Neg",f,void 0)},910438:f=>{r.ra("Floor",f,void 0)},910491:f=>{r.ra("Ceil",f,void 0)},910543:f=>{r.ra("Reciprocal",f,void 0)},910601:f=>{r.ra("Sqrt",f,void 0)},910653:f=>{r.ra("Exp",f,void 0)},910704:f=>{r.ra("Erf",f,void 0)},910755:f=>{r.ra("Sigmoid",f,void 0)},910810:f=>{r.ra("Log",f,void 0)},910861:f=>{r.ra("Sin",f,void 0)},910912:f=>{r.ra("Cos",f,void 0)},910963:f=>{r.ra("Tan",f,void 0)},911014:f=>{r.ra("Asin",f,void 0)},911066:f=>{r.ra("Acos",f,void 0)},911118:f=>{r.ra("Atan",f,void 0)},911170:f=>{r.ra("Sinh",f,void 0)},911222:f=>{r.ra("Cosh",f,void 0)},911274:f=>{r.ra("Asinh",f,void 0)},911327:f=>{r.ra("Acosh",f,void 0)},911380:f=>{r.ra("Atanh",f,void 0)},911433:f=>{r.ra("Tanh",f,void 0)},911485:f=>{r.ra("Not",f,void 0)},911536:(f,v,$)=>{r.ra("ClipV10",f,{min:v,max:$})},911608:f=>{r.ra("Clip",f,void 0)},911660:(f,v)=>{r.ra("Elu",f,{alpha:v})},911718:f=>{r.ra("Relu",f,void 0)},911770:(f,v)=>{r.ra("LeakyRelu",f,{alpha:v})},911834:(f,v)=>{r.ra("ThresholdedRelu",f,{alpha:v})},911904:(f,v)=>{r.ra("Cast",f,{to:v})},911962:f=>{r.ra("Add",f,void 0)},912013:f=>{r.ra("Sub",f,void 0)},912064:f=>{r.ra("Mul",f,void 0)},912115:f=>{r.ra("Div",f,void 0)},912166:f=>{r.ra("Pow",f,void 0)},912217:f=>{r.ra("Equal",f,void 0)},912270:f=>{r.ra("Greater",f,void 0)},912325:f=>{r.ra("GreaterOrEqual",f,void 0)},912387:f=>{r.ra("Less",f,void 0)},912439:f=>{r.ra("LessOrEqual",f,void 0)},912498:(f,v,$,A,B)=>{r.ra("ReduceMean",f,{keepDims:!!v,noopWithEmptyAxes:!!$,axes:A?Array.from(P.subarray(B>>>0,B+A>>>0)):[]})},912662:(f,v,$,A,B)=>{r.ra("ReduceMax",f,{keepDims:!!v,noopWithEmptyAxes:!!$,axes:A?Array.from(P.subarray(B>>>0,B+A>>>0)):[]})},912825:(f,v,$,A,B)=>{r.ra("ReduceMin",f,{keepDims:!!v,noopWithEmptyAxes:!!$,axes:A?Array.from(P.subarray(B>>>0,B+A>>>0)):[]})},912988:(f,v,$,A,B)=>{r.ra("ReduceProd",f,{keepDims:!!v,noopWithEmptyAxes:!!$,axes:A?Array.from(P.subarray(B>>>0,B+A>>>0)):[]})},913152:(f,v,$,A,B)=>{r.ra("ReduceSum",f,{keepDims:!!v,noopWithEmptyAxes:!!$,axes:A?Array.from(P.subarray(B>>>0,B+A>>>0)):[]})},913315:(f,v,$,A,B)=>{r.ra("ReduceL1",f,{keepDims:!!v,noopWithEmptyAxes:!!$,axes:A?Array.from(P.subarray(B>>>0,B+A>>>0)):[]})},913477:(f,v,$,A,B)=>{r.ra("ReduceL2",f,{keepDims:!!v,noopWithEmptyAxes:!!$,axes:A?Array.from(P.subarray(B>>>0,B+A>>>0)):[]})},913639:(f,v,$,A,B)=>{r.ra("ReduceLogSum",f,{keepDims:!!v,noopWithEmptyAxes:!!$,axes:A?Array.from(P.subarray(B>>>0,B+A>>>0)):[]})},913805:(f,v,$,A,B)=>{r.ra("ReduceSumSquare",f,{keepDims:!!v,noopWithEmptyAxes:!!$,axes:A?Array.from(P.subarray(B>>>0,B+A>>>0)):[]})},913974:(f,v,$,A,B)=>{r.ra("ReduceLogSumExp",f,{keepDims:!!v,noopWithEmptyAxes:!!$,axes:A?Array.from(P.subarray(B>>>0,B+A>>>0)):[]})},914143:f=>{r.ra("Where",f,void 0)},914196:(f,v,$)=>{r.ra("Transpose",f,{perm:v?Array.from(P.subarray($>>>0,$+v>>>0)):[]})},914309:(f,v,$,A,B,G,X,pe,re,ie)=>{r.ra("Conv",f,{format:re?"NHWC":"NCHW",auto_pad:v,dilations:[$],group:A,kernel_shape:[B],pads:[G,X],strides:[pe],w_is_const:()=>!!J[ie>>>0]})},914537:(f,v,$,A,B,G,X,pe,re,ie,ce,Ie,Ae,M,be)=>{r.ra("Conv",f,{format:M?"NHWC":"NCHW",auto_pad:v,dilations:[$,A],group:B,kernel_shape:[G,X],pads:[pe,re,ie,ce],strides:[Ie,Ae],w_is_const:()=>!!J[be>>>0]})},914796:(f,v,$,A,B,G,X,pe,re,ie)=>{r.ra("Conv",f,{format:re?"NHWC":"NCHW",auto_pad:v,dilations:[$],group:A,kernel_shape:[B],pads:[G,X],strides:[pe],w_is_const:()=>!!J[ie>>>0]})},915024:(f,v,$,A,B,G,X,pe,re,ie,ce,Ie,Ae,M,be)=>{r.ra("Conv",f,{format:M?"NHWC":"NCHW",auto_pad:v,dilations:[$,A],group:B,kernel_shape:[G,X],pads:[pe,re,ie,ce],strides:[Ie,Ae],w_is_const:()=>!!J[be>>>0]})},915283:(f,v,$,A,B,G,X,pe,re,ie,ce,Ie,Ae,M)=>{r.ra("ConvTranspose",f,{format:re?"NHWC":"NCHW",autoPad:v,dilations:[$],group:A,kernel_shape:[B],pads:[G,X],strides:[pe],wIsConst:()=>!!J[ie>>>0],outputPadding:ce?Array.from(P.subarray(Ie>>>0,Ie+ce>>>0)):[],outputShape:Ae?Array.from(P.subarray(M>>>0,M+Ae>>>0)):[]})},915663:(f,v,$,A,B,G,X,pe,re,ie,ce,Ie,Ae)=>{r.ra("ConvTranspose",f,{format:pe?"NHWC":"NCHW",autoPad:v,dilations:Array.from(P.subarray($>>>0,$+2>>>0)),group:A,kernelShape:Array.from(P.subarray(B>>>0,B+2>>>0)),pads:Array.from(P.subarray(G>>>0,G+4>>>0)),strides:Array.from(P.subarray(X>>>0,X+2>>>0)),wIsConst:()=>!!J[re>>>0],outputPadding:0<ie?Array.from(P.subarray(ce>>>0,ce+ie>>>0)):[],outputShape:0<Ie?Array.from(P.subarray(Ae>>>0,Ae+Ie>>>0)):[]})},916186:(f,v,$,A,B,G,X,pe,re,ie,ce,Ie,Ae,M)=>{r.ra("ConvTranspose",f,{format:re?"NHWC":"NCHW",autoPad:v,dilations:[$],group:A,kernel_shape:[B],pads:[G,X],strides:[pe],wIsConst:()=>!!J[ie>>>0],outputPadding:ce?Array.from(P.subarray(Ie>>>0,Ie+ce>>>0)):[],outputShape:Ae?Array.from(P.subarray(M>>>0,M+Ae>>>0)):[]})},916566:(f,v,$,A,B,G,X,pe,re,ie,ce,Ie,Ae)=>{r.ra("ConvTranspose",f,{format:pe?"NHWC":"NCHW",autoPad:v,dilations:Array.from(P.subarray($>>>0,$+2>>>0)),group:A,kernelShape:Array.from(P.subarray(B>>>0,B+2>>>0)),pads:Array.from(P.subarray(G>>>0,G+4>>>0)),strides:Array.from(P.subarray(X>>>0,X+2>>>0)),wIsConst:()=>!!J[re>>>0],outputPadding:0<ie?Array.from(P.subarray(ce>>>0,ce+ie>>>0)):[],outputShape:0<Ie?Array.from(P.subarray(Ae>>>0,Ae+Ie>>>0)):[]})},917089:(f,v)=>{r.ra("GlobalAveragePool",f,{format:v?"NHWC":"NCHW"})},917180:(f,v,$,A,B,G,X,pe,re,ie,ce,Ie,Ae,M,be,Be)=>{r.ra("AveragePool",f,{format:Be?"NHWC":"NCHW",auto_pad:v,ceil_mode:$,count_include_pad:A,storage_order:B,dilations:[G,X],kernel_shape:[pe,re],pads:[ie,ce,Ie,Ae],strides:[M,be]})},917464:(f,v)=>{r.ra("GlobalAveragePool",f,{format:v?"NHWC":"NCHW"})},917555:(f,v,$,A,B,G,X,pe,re,ie,ce,Ie,Ae,M,be,Be)=>{r.ra("AveragePool",f,{format:Be?"NHWC":"NCHW",auto_pad:v,ceil_mode:$,count_include_pad:A,storage_order:B,dilations:[G,X],kernel_shape:[pe,re],pads:[ie,ce,Ie,Ae],strides:[M,be]})},917839:(f,v)=>{r.ra("GlobalMaxPool",f,{format:v?"NHWC":"NCHW"})},917926:(f,v,$,A,B,G,X,pe,re,ie,ce,Ie,Ae,M,be,Be)=>{r.ra("MaxPool",f,{format:Be?"NHWC":"NCHW",auto_pad:v,ceil_mode:$,count_include_pad:A,storage_order:B,dilations:[G,X],kernel_shape:[pe,re],pads:[ie,ce,Ie,Ae],strides:[M,be]})},918206:(f,v)=>{r.ra("GlobalMaxPool",f,{format:v?"NHWC":"NCHW"})},918293:(f,v,$,A,B,G,X,pe,re,ie,ce,Ie,Ae,M,be,Be)=>{r.ra("MaxPool",f,{format:Be?"NHWC":"NCHW",auto_pad:v,ceil_mode:$,count_include_pad:A,storage_order:B,dilations:[G,X],kernel_shape:[pe,re],pads:[ie,ce,Ie,Ae],strides:[M,be]})},918573:(f,v,$,A,B)=>{r.ra("Gemm",f,{alpha:v,beta:$,transA:A,transB:B})},918677:f=>{r.ra("MatMul",f,void 0)},918731:(f,v,$,A)=>{r.ra("ArgMax",f,{keepDims:!!v,selectLastIndex:!!$,axis:A})},918839:(f,v,$,A)=>{r.ra("ArgMin",f,{keepDims:!!v,selectLastIndex:!!$,axis:A})},918947:(f,v)=>{r.ra("Softmax",f,{axis:v})},919010:(f,v)=>{r.ra("Concat",f,{axis:v})},919070:(f,v,$,A,B)=>{r.ra("Split",f,{axis:v,numOutputs:$,splitSizes:A?Array.from(P.subarray(B>>>0,B+A>>>0)):[]})},919215:f=>{r.ra("Expand",f,void 0)},919269:(f,v)=>{r.ra("Gather",f,{axis:Number(v)})},919340:(f,v)=>{r.ra("GatherElements",f,{axis:Number(v)})},919419:(f,v,$,A,B,G,X,pe,re,ie,ce)=>{r.ra("Resize",f,{antialias:v,axes:$?Array.from(P.subarray(A>>>0,A+$>>>0)):[],coordinateTransformMode:Lt(B),cubicCoeffA:G,excludeOutside:X,extrapolationValue:pe,keepAspectRatioPolicy:Lt(re),mode:Lt(ie),nearestMode:Lt(ce)})},919770:(f,v,$,A,B,G,X)=>{r.ra("Slice",f,{starts:v?Array.from(P.subarray($>>>0,$+v>>>0)):[],ends:A?Array.from(P.subarray(B>>>0,B+A>>>0)):[],axes:G?Array.from(P.subarray(X>>>0,X+G>>>0)):[]})},920001:f=>{r.ra("Tile",f,void 0)},920053:(f,v,$)=>{r.ra("LayerNormalization",f,{axis:Number(v),epsilon:Number($)})},920160:(f,v,$)=>{r.ra("InstanceNormalization",f,{epsilon:v,format:$?"NHWC":"NCHW"})},920274:(f,v,$)=>{r.ra("InstanceNormalization",f,{epsilon:v,format:$?"NHWC":"NCHW"})},920388:f=>{r.ra("Range",f,void 0)},920441:(f,v)=>{r.ra("Einsum",f,{equation:Lt(v)})},920522:(f,v,$,A,B)=>{r.ra("Pad",f,{mode:v,value:$,pads:A?Array.from(P.subarray(B>>>0,B+A>>>0)):[]})},920654:f=>{r.ra("Gelu",f,void 0)},920706:f=>{r.ra("BiasAdd",f,void 0)},920761:f=>{r.ra("BiasSplitGelu",f,void 0)},920822:(f,v)=>{r.ra("SkipLayerNormalization",f,{epsilon:v})},920903:f=>{r.Ra(f)},920937:(f,v)=>r.Sa(f,v,r.Da.Ta,r.Da.errors),921049:f=>r.Oa(f),921082:f=>r.Qa(f),921114:(f,v,$)=>{r.Ja(f,v,$,!0)},921153:(f,v,$)=>{r.Ja(f,v,$)}};function Yt(f){this.name="ExitStatus",this.message=`Program terminated with exit(${f})`,this.status=f}var Mt=f=>{for(;0<f.length;)f.shift()(r)};function ho(f){this.Ha=f-24,this.Ma=function(v){oe[this.Ha+4>>2>>>0]=v},this.La=function(v){oe[this.Ha+8>>2>>>0]=v},this.Ya=function(v,$){this.Ka(),this.Ma(v),this.La($)},this.Ka=function(){oe[this.Ha+16>>2>>>0]=0}}var $n=0,Xt=0,In=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,dr=(f,v,$)=>{v>>>=0;var A=v+$;for($=v;f[$]&&!($>=A);)++$;if(16<$-v&&f.buffer&&In)return In.decode(f.subarray(v,$));for(A="";v<$;){var B=f[v++];if(B&128){var G=f[v++]&63;if((B&224)==192)A+=String.fromCharCode((B&31)<<6|G);else{var X=f[v++]&63;B=(B&240)==224?(B&15)<<12|G<<6|X:(B&7)<<18|G<<12|X<<6|f[v++]&63,65536>B?A+=String.fromCharCode(B):(B-=65536,A+=String.fromCharCode(55296|B>>10,56320|B&1023))}}else A+=String.fromCharCode(B)}return A},Lt=(f,v)=>(f>>>=0)?dr(ge,f,v):"",Sn=f=>{for(var v=0,$=0;$<f.length;++$){var A=f.charCodeAt($);127>=A?v++:2047>=A?v+=2:55296<=A&&57343>=A?(v+=4,++$):v+=3}return v},Zr=(f,v,$,A)=>{if($>>>=0,!(0<A))return 0;var B=$;A=$+A-1;for(var G=0;G<f.length;++G){var X=f.charCodeAt(G);if(55296<=X&&57343>=X){var pe=f.charCodeAt(++G);X=65536+((X&1023)<<10)|pe&1023}if(127>=X){if($>=A)break;v[$++>>>0]=X}else{if(2047>=X){if($+1>=A)break;v[$++>>>0]=192|X>>6}else{if(65535>=X){if($+2>=A)break;v[$++>>>0]=224|X>>12}else{if($+3>=A)break;v[$++>>>0]=240|X>>18,v[$++>>>0]=128|X>>12&63}v[$++>>>0]=128|X>>6&63}v[$++>>>0]=128|X&63}}return v[$>>>0]=0,$-B},br=f=>f%4===0&&(f%100!==0||f%400===0),fr=[0,31,60,91,121,152,182,213,244,274,305,335],Qr=[0,31,59,90,120,151,181,212,243,273,304,334],Er=f=>{var v=Sn(f)+1,$=on(v);return $&&Zr(f,ge,$,v),$},Cr=[],_n=(f,v)=>{Cr.length=0;var $;for(v>>=2;$=ge[f++>>>0];)v+=$!=105&v,Cr.push($==105?P[v>>>0]:Ke[v++>>>1]),++v;return Cr},en={},An=()=>{if(!tn){var f={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:s||"./this.program"},v;for(v in en)en[v]===void 0?delete f[v]:f[v]=en[v];var $=[];for(v in f)$.push(`${v}=${f[v]}`);tn=$}return tn},tn,Jt=[null,[],[]],On=[31,29,31,30,31,30,31,31,30,31,30,31],rn=[31,28,31,30,31,30,31,31,30,31,30,31];function he(f){var v=Array(Sn(f)+1);return Zr(f,v,0,v.length),v}function Pr(f,v,$,A){function B(M,be,Be){for(M=typeof M=="number"?M.toString():M||"";M.length<be;)M=Be[0]+M;return M}function G(M,be){return B(M,be,"0")}function X(M,be){function Be(zn){return 0>zn?-1:0<zn?1:0}var Zt;return(Zt=Be(M.getFullYear()-be.getFullYear()))===0&&(Zt=Be(M.getMonth()-be.getMonth()))===0&&(Zt=Be(M.getDate()-be.getDate())),Zt}function pe(M){switch(M.getDay()){case 0:return new Date(M.getFullYear()-1,11,29);case 1:return M;case 2:return new Date(M.getFullYear(),0,3);case 3:return new Date(M.getFullYear(),0,2);case 4:return new Date(M.getFullYear(),0,1);case 5:return new Date(M.getFullYear()-1,11,31);case 6:return new Date(M.getFullYear()-1,11,30)}}function re(M){var be=M.Ba;for(M=new Date(new Date(M.Ca+1900,0,1).getTime());0<be;){var Be=M.getMonth(),Zt=(br(M.getFullYear())?On:rn)[Be];if(be>Zt-M.getDate())be-=Zt-M.getDate()+1,M.setDate(1),11>Be?M.setMonth(Be+1):(M.setMonth(0),M.setFullYear(M.getFullYear()+1));else{M.setDate(M.getDate()+be);break}}return Be=new Date(M.getFullYear()+1,0,4),be=pe(new Date(M.getFullYear(),0,4)),Be=pe(Be),0>=X(be,M)?0>=X(Be,M)?M.getFullYear()+1:M.getFullYear():M.getFullYear()-1}f>>>=0,v>>>=0,$>>>=0,A>>>=0;var ie=P[A+40>>2>>>0];A={Wa:P[A>>2>>>0],Va:P[A+4>>2>>>0],Ea:P[A+8>>2>>>0],Ia:P[A+12>>2>>>0],Fa:P[A+16>>2>>>0],Ca:P[A+20>>2>>>0],wa:P[A+24>>2>>>0],Ba:P[A+28>>2>>>0],$a:P[A+32>>2>>>0],Ua:P[A+36>>2>>>0],Xa:ie?Lt(ie):""},$=Lt($),ie={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ce in ie)$=$.replace(new RegExp(ce,"g"),ie[ce]);var Ie="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Ae="January February March April May June July August September October November December".split(" ");ie={"%a":M=>Ie[M.wa].substring(0,3),"%A":M=>Ie[M.wa],"%b":M=>Ae[M.Fa].substring(0,3),"%B":M=>Ae[M.Fa],"%C":M=>G((M.Ca+1900)/100|0,2),"%d":M=>G(M.Ia,2),"%e":M=>B(M.Ia,2," "),"%g":M=>re(M).toString().substring(2),"%G":M=>re(M),"%H":M=>G(M.Ea,2),"%I":M=>(M=M.Ea,M==0?M=12:12<M&&(M-=12),G(M,2)),"%j":M=>{for(var be=0,Be=0;Be<=M.Fa-1;be+=(br(M.Ca+1900)?On:rn)[Be++]);return G(M.Ia+be,3)},"%m":M=>G(M.Fa+1,2),"%M":M=>G(M.Va,2),"%n":()=>`
`,"%p":M=>0<=M.Ea&&12>M.Ea?"AM":"PM","%S":M=>G(M.Wa,2),"%t":()=>"	","%u":M=>M.wa||7,"%U":M=>G(Math.floor((M.Ba+7-M.wa)/7),2),"%V":M=>{var be=Math.floor((M.Ba+7-(M.wa+6)%7)/7);if(2>=(M.wa+371-M.Ba-2)%7&&be++,be)be==53&&(Be=(M.wa+371-M.Ba)%7,Be==4||Be==3&&br(M.Ca)||(be=1));else{be=52;var Be=(M.wa+7-M.Ba-1)%7;(Be==4||Be==5&&br(M.Ca%400-1))&&be++}return G(be,2)},"%w":M=>M.wa,"%W":M=>G(Math.floor((M.Ba+7-(M.wa+6)%7)/7),2),"%y":M=>(M.Ca+1900).toString().substring(2),"%Y":M=>M.Ca+1900,"%z":M=>{M=M.Ua;var be=0<=M;return M=Math.abs(M)/60,(be?"+":"-")+("0000"+(M/60*100+M%60)).slice(-4)},"%Z":M=>M.Xa,"%%":()=>"%"},$=$.replace(/%%/g,"\0\0");for(ce in ie)$.includes(ce)&&($=$.replace(new RegExp(ce,"g"),ie[ce](A)));return $=$.replace(/\0\0/g,"%"),ce=he($),ce.length>v?0:(J.set(ce,f>>>0),ce.length-1)}function Dr(f){try{f()}catch(v){gt(v)}}function Ji(f){var v={},$;for($ in f)(function(A){var B=f[A];v[A]=typeof B=="function"?function(){kr.push(A);try{return B.apply(null,arguments)}finally{V||(kr.pop()===A||gt(),At&&Nt===1&&kr.length===0&&(Nt=0,Dr(an),typeof Fibers<"u"&&Fibers.ab()))}}:B})($);return v}var Nt=0,At=null,En=0,kr=[],Cn={},Pn={},Dn=0,nn=null,mo=[];function go(){return new Promise((f,v)=>{nn={resolve:f,reject:v}})}function bo(){var f=on(65548),v=f+12;oe[f>>2>>>0]=v,oe[f+4>>2>>>0]=v+65536,v=kr[0];var $=Cn[v];return $===void 0&&($=Dn++,Cn[v]=$,Pn[$]=v),P[f+8>>2>>>0]=$,f}function yo(f){if(!V){if(Nt===0){var v=!1,$=!1;f((A=0)=>{if(!V&&(En=A,v=!0,$)){Nt=2,Dr(()=>Br(At)),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.resume(),A=!1;try{var B=(0,R[Pn[P[At+8>>2>>>0]]])()}catch(pe){B=pe,A=!0}var G=!1;if(!At){var X=nn;X&&(nn=null,(A?X.reject:X.resolve)(B),G=!0)}if(A&&!G)throw B}}),$=!0,v||(Nt=1,At=bo(),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.pause(),Dr(()=>Nn(At)))}else Nt===2?(Nt=0,Dr(pr),kn(At),At=null,mo.forEach(A=>{if(!V)try{if(A(),!N)try{K=K=A=K,N||(r.onExit&&r.onExit(A),V=!0),a(A,new Yt(A))}catch(B){B instanceof Yt||B=="unwind"||a(1,B)}}catch(B){B instanceof Yt||B=="unwind"||a(1,B)}})):gt(`invalid state: ${Nt}`);return En}}function vo(f){return yo(v=>{f().then(v)})}var xo={n:function(f,v,$){return vo(async()=>{await r.Pa(f,v,$)})},a:function(f,v,$){throw f>>>=0,new ho(f).Ya(v>>>0,$>>>0),$n=f,Xt++,$n},g:function(){return 0},J:function(){},z:function(){},B:function(){},L:function(){return 0},H:function(){},C:function(){},G:function(){},l:function(){},A:function(){},x:function(){},I:function(){},y:function(){},m:()=>!0,q:function(f,v,$){f=v+2097152>>>0<4194305-!!f?(f>>>0)+4294967296*v:NaN,$>>>=0,f=new Date(1e3*f),P[$>>2>>>0]=f.getUTCSeconds(),P[$+4>>2>>>0]=f.getUTCMinutes(),P[$+8>>2>>>0]=f.getUTCHours(),P[$+12>>2>>>0]=f.getUTCDate(),P[$+16>>2>>>0]=f.getUTCMonth(),P[$+20>>2>>>0]=f.getUTCFullYear()-1900,P[$+24>>2>>>0]=f.getUTCDay(),P[$+28>>2>>>0]=(f.getTime()-Date.UTC(f.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(f,v,$){f=v+2097152>>>0<4194305-!!f?(f>>>0)+4294967296*v:NaN,$>>>=0,f=new Date(1e3*f),P[$>>2>>>0]=f.getSeconds(),P[$+4>>2>>>0]=f.getMinutes(),P[$+8>>2>>>0]=f.getHours(),P[$+12>>2>>>0]=f.getDate(),P[$+16>>2>>>0]=f.getMonth(),P[$+20>>2>>>0]=f.getFullYear()-1900,P[$+24>>2>>>0]=f.getDay(),P[$+28>>2>>>0]=(br(f.getFullYear())?fr:Qr)[f.getMonth()]+f.getDate()-1|0,P[$+36>>2>>>0]=-(60*f.getTimezoneOffset()),v=new Date(f.getFullYear(),6,1).getTimezoneOffset();var A=new Date(f.getFullYear(),0,1).getTimezoneOffset();P[$+32>>2>>>0]=(v!=A&&f.getTimezoneOffset()==Math.min(A,v))|0},s:function(f){f>>>=0;var v=new Date(P[f+20>>2>>>0]+1900,P[f+16>>2>>>0],P[f+12>>2>>>0],P[f+8>>2>>>0],P[f+4>>2>>>0],P[f>>2>>>0],0),$=P[f+32>>2>>>0],A=v.getTimezoneOffset(),B=new Date(v.getFullYear(),6,1).getTimezoneOffset(),G=new Date(v.getFullYear(),0,1).getTimezoneOffset(),X=Math.min(G,B);return 0>$?P[f+32>>2>>>0]=+(B!=G&&X==A):0<$!=(X==A)&&(B=Math.max(G,B),v.setTime(v.getTime()+6e4*((0<$?X:B)-A))),P[f+24>>2>>>0]=v.getDay(),P[f+28>>2>>>0]=(br(v.getFullYear())?fr:Qr)[v.getMonth()]+v.getDate()-1|0,P[f>>2>>>0]=v.getSeconds(),P[f+4>>2>>>0]=v.getMinutes(),P[f+8>>2>>>0]=v.getHours(),P[f+12>>2>>>0]=v.getDate(),P[f+16>>2>>>0]=v.getMonth(),P[f+20>>2>>>0]=v.getYear(),f=v.getTime()/1e3,Bn((Ye=f,1<=+Math.abs(Ye)?0<Ye?+Math.floor(Ye/4294967296)>>>0:~~+Math.ceil((Ye-+(~~Ye>>>0))/4294967296)>>>0:0)),f>>>0},o:function(){return-52},p:function(){},v:function(f,v,$){function A(re){return(re=re.toTimeString().match(/\(([A-Za-z ]+)\)$/))?re[1]:"GMT"}$>>>=0;var B=new Date().getFullYear(),G=new Date(B,0,1),X=new Date(B,6,1);B=G.getTimezoneOffset();var pe=X.getTimezoneOffset();oe[f>>>0>>2>>>0]=60*Math.max(B,pe),P[v>>>0>>2>>>0]=+(B!=pe),f=A(G),v=A(X),f=Er(f),v=Er(v),pe<B?(oe[$>>2>>>0]=f,oe[$+4>>2>>>0]=v):(oe[$>>2>>>0]=v,oe[$+4>>2>>>0]=f)},e:()=>{gt("")},b:function(f,v,$){return f>>>=0,v=_n(v>>>0,$>>>0),Tt[f].apply(null,v)},i:function(f,v,$){return f>>>=0,v=_n(v>>>0,$>>>0),Tt[f].apply(null,v)},h:function(){return Date.now()},w:function(){return 4294901760},c:()=>performance.now(),K:function(f,v,$){return v>>>=0,ge.copyWithin(f>>>0>>>0,v>>>0,v+($>>>0)>>>0)},u:function(f){f>>>=0;var v=ge.length;if(4294901760<f)return!1;for(var $=1;4>=$;$*=2){var A=v*(1+.2/$);A=Math.min(A,f+100663296);var B=Math;A=Math.max(f,A);e:{B=B.min.call(B,4294901760,A+(65536-A%65536)%65536)-F.buffer.byteLength+65535>>>16;try{F.grow(B),te();var G=1;break e}catch{}G=void 0}if(G)return!0}return!1},D:function(f,v){f>>>=0,v>>>=0;var $=0;return An().forEach(function(A,B){var G=v+$;for(B=oe[f+4*B>>2>>>0]=G,G=0;G<A.length;++G)J[B++>>0>>>0]=A.charCodeAt(G);J[B>>0>>>0]=0,$+=A.length+1}),0},E:function(f,v){f>>>=0,v>>>=0;var $=An();oe[f>>2>>>0]=$.length;var A=0;return $.forEach(function(B){A+=B.length+1}),oe[v>>2>>>0]=A,0},f:()=>52,k:function(){return 52},t:function(){return 70},j:function(f,v,$,A){v>>>=0,$>>>=0,A>>>=0;for(var B=0,G=0;G<$;G++){var X=oe[v>>2>>>0],pe=oe[v+4>>2>>>0];v+=8;for(var re=0;re<pe;re++){var ie=ge[X+re>>>0],ce=Jt[f];ie===0||ie===10?((f===1?I:O)(dr(ce,0)),ce.length=0):ce.push(ie)}B+=pe}return oe[A>>2>>>0]=B,0},F:Pr,d:function(f,v,$,A){return Pr(f>>>0,v>>>0,$>>>0,A>>>0)}};(function(){function f($){if($=$.exports,$=Ji($),R=$=wo($),F=R.M,te(),mt.unshift(R.N),Fe--,r.monitorRunDependencies&&r.monitorRunDependencies(Fe),Fe==0&&(ut!==null&&(clearInterval(ut),ut=null),Kt)){var A=Kt;Kt=null,A()}return $}var v={a:xo};if(Fe++,r.monitorRunDependencies&&r.monitorRunDependencies(Fe),r.instantiateWasm)try{return r.instantiateWasm(v,f)}catch($){O("Module.instantiateWasm callback failed with error: "+$),o($)}return Ze(v,function($){f($.instance)}).catch(o),{}})(),r._OrtInit=(f,v)=>(r._OrtInit=R.O)(f,v),r._OrtGetLastError=(f,v)=>(r._OrtGetLastError=R.P)(f,v),r._OrtCreateSessionOptions=(f,v,$,A,B,G,X,pe,re,ie)=>(r._OrtCreateSessionOptions=R.Q)(f,v,$,A,B,G,X,pe,re,ie),r._OrtAppendExecutionProvider=(f,v)=>(r._OrtAppendExecutionProvider=R.R)(f,v),r._OrtAddFreeDimensionOverride=(f,v,$)=>(r._OrtAddFreeDimensionOverride=R.S)(f,v,$),r._OrtAddSessionConfigEntry=(f,v,$)=>(r._OrtAddSessionConfigEntry=R.T)(f,v,$),r._OrtReleaseSessionOptions=f=>(r._OrtReleaseSessionOptions=R.U)(f),r._OrtCreateSession=(f,v,$)=>(r._OrtCreateSession=R.V)(f,v,$),r._OrtReleaseSession=f=>(r._OrtReleaseSession=R.W)(f),r._OrtGetInputOutputCount=(f,v,$)=>(r._OrtGetInputOutputCount=R.X)(f,v,$),r._OrtGetInputName=(f,v)=>(r._OrtGetInputName=R.Y)(f,v),r._OrtGetOutputName=(f,v)=>(r._OrtGetOutputName=R.Z)(f,v),r._OrtFree=f=>(r._OrtFree=R._)(f),r._OrtCreateTensor=(f,v,$,A,B,G)=>(r._OrtCreateTensor=R.$)(f,v,$,A,B,G),r._OrtGetTensorData=(f,v,$,A,B)=>(r._OrtGetTensorData=R.aa)(f,v,$,A,B),r._OrtReleaseTensor=f=>(r._OrtReleaseTensor=R.ba)(f),r._OrtCreateRunOptions=(f,v,$,A)=>(r._OrtCreateRunOptions=R.ca)(f,v,$,A),r._OrtAddRunConfigEntry=(f,v,$)=>(r._OrtAddRunConfigEntry=R.da)(f,v,$),r._OrtReleaseRunOptions=f=>(r._OrtReleaseRunOptions=R.ea)(f),r._OrtCreateBinding=f=>(r._OrtCreateBinding=R.fa)(f),r._OrtBindInput=(f,v,$)=>(r._OrtBindInput=R.ga)(f,v,$),r._OrtBindOutput=(f,v,$,A)=>(r._OrtBindOutput=R.ha)(f,v,$,A),r._OrtClearBoundOutputs=f=>(r._OrtClearBoundOutputs=R.ia)(f),r._OrtReleaseBinding=f=>(r._OrtReleaseBinding=R.ja)(f),r._OrtRunWithBinding=(f,v,$,A,B)=>(r._OrtRunWithBinding=R.ka)(f,v,$,A,B),r._OrtRun=(f,v,$,A,B,G,X,pe)=>(r._OrtRun=R.la)(f,v,$,A,B,G,X,pe),r._OrtEndProfiling=f=>(r._OrtEndProfiling=R.ma)(f),r._JsepOutput=(f,v,$)=>(r._JsepOutput=R.na)(f,v,$),r._JsepGetNodeName=f=>(r._JsepGetNodeName=R.oa)(f);var on=r._malloc=f=>(on=r._malloc=R.pa)(f),kn=r._free=f=>(kn=r._free=R.qa)(f),Bn=f=>(Bn=R.sa)(f),Rn=()=>(Rn=R.ta)(),Mn=f=>(Mn=R.ua)(f),Ln=f=>(Ln=R.va)(f),Nn=f=>(Nn=R.xa)(f),an=()=>(an=R.ya)(),Br=f=>(Br=R.za)(f),pr=()=>(pr=R.Aa)();r.___start_em_js=921186,r.___stop_em_js=921347;function wo(f){f=Object.assign({},f);var v=A=>()=>A()>>>0,$=A=>B=>A(B)>>>0;return f.__errno_location=v(f.__errno_location),f.malloc=$(f.malloc),f.stackSave=v(f.stackSave),f.stackAlloc=$(f.stackAlloc),f}r.stackAlloc=Ln,r.stackSave=Rn,r.stackRestore=Mn,r.UTF8ToString=Lt,r.stringToUTF8=(f,v,$)=>Zr(f,ge,v,$),r.lengthBytesUTF8=Sn;var Rr;Kt=function f(){Rr||Fn(),Rr||(Kt=f)};function Fn(){function f(){if(!Rr&&(Rr=!0,r.calledRun=!0,!V)){if(Mt(mt),t(r),r.onRuntimeInitialized&&r.onRuntimeInitialized(),r.postRun)for(typeof r.postRun=="function"&&(r.postRun=[r.postRun]);r.postRun.length;){var v=r.postRun.shift();Ce.unshift(v)}Mt(Ce)}}if(!(0<Fe)){if(r.preRun)for(typeof r.preRun=="function"&&(r.preRun=[r.preRun]);r.preRun.length;)st();Mt(Z),0<Fe||(r.setStatus?(r.setStatus("Running..."),setTimeout(function(){setTimeout(function(){r.setStatus("")},1),f()},1)):f())}}if(r.preInit)for(typeof r.preInit=="function"&&(r.preInit=[r.preInit]);0<r.preInit.length;)r.preInit.pop()();return Fn(),e.ready}})();typeof th=="object"&&typeof bs=="object"?bs.exports=eh:typeof define=="function"&&define.amd&&define([],()=>eh)});var nh=Ve(()=>{});var oh=Ve(()=>{});var ih={};sn(ih,{cpus:()=>Rx});var Rx,ah=k(()=>{Rx=void 0});var lh=Ve((uh,ys)=>{"use strict";var sh=(()=>{var n=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(n=n||__filename),function(e={}){function r(){return te.buffer!=Fe.buffer&&H(),Fe}function t(){return te.buffer!=Fe.buffer&&H(),ut}function o(){return te.buffer!=Fe.buffer&&H(),Kt}function i(){return te.buffer!=Fe.buffer&&H(),gt}function s(){return te.buffer!=Fe.buffer&&H(),cr}var a=e,u,l;a.ready=new Promise((c,m)=>{u=c,l=m}),a.jsepInit=(c,m,x,S,D,z,U,de)=>{a.Qb=c,a.wb=m,a.yb=x,a.jb=S,a.xb=D,a.Ea=z,a.zb=U,a.Ab=de,m=(le,ae,fe)=>(...Oe)=>{let Le=Qt,L=ae?.();Oe=le(...Oe);let ve=ae?.();return L!==ve&&(le=ve,fe(L),ae=fe=null),Qt!=Le?Yb():Oe},x=le=>async(...ae)=>{try{if(a.bb)throw Error("Session already started");let fe=a.bb={Fb:ae[0],errors:[]},Oe=await le(...ae);if(a.bb!==fe)throw Error("Session mismatch");c.flush();let Le=fe.errors;if(0<Le.length){let L=await Promise.all(Le);if(L=L.filter(ve=>ve),0<L.length)throw Error(L.join(`
`))}return Oe}finally{a.bb=null}},a._OrtRun=x(m(a._OrtRun,()=>a._OrtRun,le=>a._OrtRun=le)),a._OrtRunWithBinding=x(m(a._OrtRunWithBinding,()=>a._OrtRunWithBinding,le=>a._OrtRunWithBinding=le)),a._OrtBindInput=m(a._OrtBindInput,()=>a._OrtBindInput,le=>a._OrtBindInput=le),a.jsepRegisterBuffer=(le,ae,fe,Oe)=>c.registerBuffer(le,ae,fe,Oe),a.jsepUnregisterBuffers=le=>{c.unregisterBuffers(le)},a.jsepGetBuffer=le=>c.getBuffer(le),a.jsepCreateDownloader=(le,ae,fe)=>c.createDownloader(le,ae,fe)};var d=Object.assign({},a),p="./this.program",h=(c,m)=>{throw m},g=typeof window=="object",y=typeof importScripts=="function",b=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",w=a.ENVIRONMENT_IS_PTHREAD||!1,I="";function O(c){return a.locateFile?a.locateFile(c,I):I+c}var E,N,F;if(b){var R=(hs(),vr(ps)),V=(gs(),vr(ms));I=y?V.dirname(I)+"/":__dirname+"/",E=(m,x)=>(m=m.startsWith("file://")?new URL(m):V.normalize(m),R.readFileSync(m,x?void 0:"utf8")),F=m=>(m=E(m,!0),m.buffer||(m=new Uint8Array(m)),m),N=(m,x,S,D=!0)=>{m=m.startsWith("file://")?new URL(m):V.normalize(m),R.readFile(m,D?void 0:"utf8",(z,U)=>{z?S(z):x(D?U.buffer:U)})},!a.thisProgram&&1<process.argv.length&&(p=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),h=(m,x)=>{throw process.exitCode=m,x},a.inspect=()=>"[Emscripten Module object]";let c;try{c=nh()}catch(m){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),m}global.Worker=c.Worker}else(g||y)&&(y?I=self.location.href:typeof document<"u"&&document.currentScript&&(I=document.currentScript.src),typeof n<"u"&&n&&(I=n),I.indexOf("blob:")!==0?I=I.substr(0,I.replace(/[?#].*/,"").lastIndexOf("/")+1):I="",b||(E=c=>{var m=new XMLHttpRequest;return m.open("GET",c,!1),m.send(null),m.responseText},y&&(F=c=>{var m=new XMLHttpRequest;return m.open("GET",c,!1),m.responseType="arraybuffer",m.send(null),new Uint8Array(m.response)}),N=(c,m,x)=>{var S=new XMLHttpRequest;S.open("GET",c,!0),S.responseType="arraybuffer",S.onload=()=>{S.status==200||S.status==0&&S.response?m(S.response):x()},S.onerror=x,S.send(null)}));b&&typeof performance>"u"&&(global.performance=oh().performance);var K=console.log.bind(console),J=console.error.bind(console);b&&(K=(...c)=>R.writeSync(1,c.join(" ")+`
`),J=(...c)=>R.writeSync(2,c.join(" ")+`
`));var ge=a.print||K,P=a.printErr||J;Object.assign(a,d),d=null,a.thisProgram&&(p=a.thisProgram),a.quit&&(h=a.quit);var oe;a.wasmBinary&&(oe=a.wasmBinary);var Ke=a.noExitRuntime||!0;typeof WebAssembly!="object"&&Xt("no native wasm support detected");var te,Z,mt,Ce=!1,st,Fe,ut,Kt,gt,cr;function H(){var c=te.buffer;a.HEAP8=Fe=new Int8Array(c),a.HEAP16=new Int16Array(c),a.HEAP32=Kt=new Int32Array(c),a.HEAPU8=ut=new Uint8Array(c),a.HEAPU16=new Uint16Array(c),a.HEAPU32=gt=new Uint32Array(c),a.HEAPF32=new Float32Array(c),a.HEAPF64=cr=new Float64Array(c)}var Te=a.INITIAL_MEMORY||16777216;if(5242880<=Te||Xt("INITIAL_MEMORY should be larger than STACK_SIZE, was "+Te+"! (STACK_SIZE=5242880)"),w)te=a.wasmMemory;else if(a.wasmMemory)te=a.wasmMemory;else if(te=new WebAssembly.Memory({initial:Te/65536,maximum:65536,shared:!0}),!(te.buffer instanceof SharedArrayBuffer))throw P("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),b&&P("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");H(),Te=te.buffer.byteLength;var ke=[],bt=[],wt=[],Ze=0;function Ye(){return Ke||0<Ze}var Tt=0,Yt=null,Mt=null;function ho(){Tt++,a.monitorRunDependencies&&a.monitorRunDependencies(Tt)}function $n(){if(Tt--,a.monitorRunDependencies&&a.monitorRunDependencies(Tt),Tt==0&&(Yt!==null&&(clearInterval(Yt),Yt=null),Mt)){var c=Mt;Mt=null,c()}}function Xt(c){throw a.onAbort&&a.onAbort(c),c="Aborted("+c+")",P(c),Ce=!0,st=1,c=new WebAssembly.RuntimeError(c+". Build with -sASSERTIONS for more info."),l(c),c}function In(c){return c.startsWith("data:application/octet-stream;base64,")}var dr;dr="ort-wasm-simd-threaded.wasm",In(dr)||(dr=O(dr));function Lt(c){if(c==dr&&oe)return new Uint8Array(oe);if(F)return F(c);throw"both async and sync fetching of the wasm failed"}function Sn(c){if(!oe&&(g||y)){if(typeof fetch=="function"&&!c.startsWith("file://"))return fetch(c,{credentials:"same-origin"}).then(m=>{if(!m.ok)throw"failed to load wasm binary file at '"+c+"'";return m.arrayBuffer()}).catch(()=>Lt(c));if(N)return new Promise((m,x)=>{N(c,S=>m(new Uint8Array(S)),x)})}return Promise.resolve().then(()=>Lt(c))}function Zr(c,m,x){return Sn(c).then(S=>WebAssembly.instantiate(S,m)).then(S=>S).then(x,S=>{P("failed to asynchronously prepare wasm: "+S),Xt(S)})}function br(c,m){var x=dr;return oe||typeof WebAssembly.instantiateStreaming!="function"||In(x)||x.startsWith("file://")||b||typeof fetch!="function"?Zr(x,c,m):fetch(x,{credentials:"same-origin"}).then(S=>WebAssembly.instantiateStreaming(S,c).then(m,function(D){return P("wasm streaming compile failed: "+D),P("falling back to ArrayBuffer instantiation"),Zr(x,c,m)}))}var fr,Qr={911532:c=>{a.Ea("Abs",c,void 0)},911583:c=>{a.Ea("Neg",c,void 0)},911634:c=>{a.Ea("Floor",c,void 0)},911687:c=>{a.Ea("Ceil",c,void 0)},911739:c=>{a.Ea("Reciprocal",c,void 0)},911797:c=>{a.Ea("Sqrt",c,void 0)},911849:c=>{a.Ea("Exp",c,void 0)},911900:c=>{a.Ea("Erf",c,void 0)},911951:c=>{a.Ea("Sigmoid",c,void 0)},912006:c=>{a.Ea("Log",c,void 0)},912057:c=>{a.Ea("Sin",c,void 0)},912108:c=>{a.Ea("Cos",c,void 0)},912159:c=>{a.Ea("Tan",c,void 0)},912210:c=>{a.Ea("Asin",c,void 0)},912262:c=>{a.Ea("Acos",c,void 0)},912314:c=>{a.Ea("Atan",c,void 0)},912366:c=>{a.Ea("Sinh",c,void 0)},912418:c=>{a.Ea("Cosh",c,void 0)},912470:c=>{a.Ea("Asinh",c,void 0)},912523:c=>{a.Ea("Acosh",c,void 0)},912576:c=>{a.Ea("Atanh",c,void 0)},912629:c=>{a.Ea("Tanh",c,void 0)},912681:c=>{a.Ea("Not",c,void 0)},912732:(c,m,x)=>{a.Ea("ClipV10",c,{min:m,max:x})},912804:c=>{a.Ea("Clip",c,void 0)},912856:(c,m)=>{a.Ea("Elu",c,{alpha:m})},912914:c=>{a.Ea("Relu",c,void 0)},912966:(c,m)=>{a.Ea("LeakyRelu",c,{alpha:m})},913030:(c,m)=>{a.Ea("ThresholdedRelu",c,{alpha:m})},913100:(c,m)=>{a.Ea("Cast",c,{to:m})},913158:c=>{a.Ea("Add",c,void 0)},913209:c=>{a.Ea("Sub",c,void 0)},913260:c=>{a.Ea("Mul",c,void 0)},913311:c=>{a.Ea("Div",c,void 0)},913362:c=>{a.Ea("Pow",c,void 0)},913413:c=>{a.Ea("Equal",c,void 0)},913466:c=>{a.Ea("Greater",c,void 0)},913521:c=>{a.Ea("GreaterOrEqual",c,void 0)},913583:c=>{a.Ea("Less",c,void 0)},913635:c=>{a.Ea("LessOrEqual",c,void 0)},913694:(c,m,x,S,D)=>{a.Ea("ReduceMean",c,{keepDims:!!m,noopWithEmptyAxes:!!x,axes:S?Array.from(o().subarray(D>>>0,D+S>>>0)):[]})},913858:(c,m,x,S,D)=>{a.Ea("ReduceMax",c,{keepDims:!!m,noopWithEmptyAxes:!!x,axes:S?Array.from(o().subarray(D>>>0,D+S>>>0)):[]})},914021:(c,m,x,S,D)=>{a.Ea("ReduceMin",c,{keepDims:!!m,noopWithEmptyAxes:!!x,axes:S?Array.from(o().subarray(D>>>0,D+S>>>0)):[]})},914184:(c,m,x,S,D)=>{a.Ea("ReduceProd",c,{keepDims:!!m,noopWithEmptyAxes:!!x,axes:S?Array.from(o().subarray(D>>>0,D+S>>>0)):[]})},914348:(c,m,x,S,D)=>{a.Ea("ReduceSum",c,{keepDims:!!m,noopWithEmptyAxes:!!x,axes:S?Array.from(o().subarray(D>>>0,D+S>>>0)):[]})},914511:(c,m,x,S,D)=>{a.Ea("ReduceL1",c,{keepDims:!!m,noopWithEmptyAxes:!!x,axes:S?Array.from(o().subarray(D>>>0,D+S>>>0)):[]})},914673:(c,m,x,S,D)=>{a.Ea("ReduceL2",c,{keepDims:!!m,noopWithEmptyAxes:!!x,axes:S?Array.from(o().subarray(D>>>0,D+S>>>0)):[]})},914835:(c,m,x,S,D)=>{a.Ea("ReduceLogSum",c,{keepDims:!!m,noopWithEmptyAxes:!!x,axes:S?Array.from(o().subarray(D>>>0,D+S>>>0)):[]})},915001:(c,m,x,S,D)=>{a.Ea("ReduceSumSquare",c,{keepDims:!!m,noopWithEmptyAxes:!!x,axes:S?Array.from(o().subarray(D>>>0,D+S>>>0)):[]})},915170:(c,m,x,S,D)=>{a.Ea("ReduceLogSumExp",c,{keepDims:!!m,noopWithEmptyAxes:!!x,axes:S?Array.from(o().subarray(D>>>0,D+S>>>0)):[]})},915339:c=>{a.Ea("Where",c,void 0)},915392:(c,m,x)=>{a.Ea("Transpose",c,{perm:m?Array.from(o().subarray(x>>>0,x+m>>>0)):[]})},915505:(c,m,x,S,D,z,U,de,le,ae)=>{a.Ea("Conv",c,{format:le?"NHWC":"NCHW",auto_pad:m,dilations:[x],group:S,kernel_shape:[D],pads:[z,U],strides:[de],w_is_const:()=>!!r()[ae>>>0]})},915733:(c,m,x,S,D,z,U,de,le,ae,fe,Oe,Le,L,ve)=>{a.Ea("Conv",c,{format:L?"NHWC":"NCHW",auto_pad:m,dilations:[x,S],group:D,kernel_shape:[z,U],pads:[de,le,ae,fe],strides:[Oe,Le],w_is_const:()=>!!r()[ve>>>0]})},915992:(c,m,x,S,D,z,U,de,le,ae)=>{a.Ea("Conv",c,{format:le?"NHWC":"NCHW",auto_pad:m,dilations:[x],group:S,kernel_shape:[D],pads:[z,U],strides:[de],w_is_const:()=>!!r()[ae>>>0]})},916220:(c,m,x,S,D,z,U,de,le,ae,fe,Oe,Le,L,ve)=>{a.Ea("Conv",c,{format:L?"NHWC":"NCHW",auto_pad:m,dilations:[x,S],group:D,kernel_shape:[z,U],pads:[de,le,ae,fe],strides:[Oe,Le],w_is_const:()=>!!r()[ve>>>0]})},916479:(c,m,x,S,D,z,U,de,le,ae,fe,Oe,Le,L)=>{a.Ea("ConvTranspose",c,{format:le?"NHWC":"NCHW",autoPad:m,dilations:[x],group:S,kernel_shape:[D],pads:[z,U],strides:[de],wIsConst:()=>!!r()[ae>>>0],outputPadding:fe?Array.from(o().subarray(Oe>>>0,Oe+fe>>>0)):[],outputShape:Le?Array.from(o().subarray(L>>>0,L+Le>>>0)):[]})},916859:(c,m,x,S,D,z,U,de,le,ae,fe,Oe,Le)=>{a.Ea("ConvTranspose",c,{format:de?"NHWC":"NCHW",autoPad:m,dilations:Array.from(o().subarray(x>>>0,x+2>>>0)),group:S,kernelShape:Array.from(o().subarray(D>>>0,D+2>>>0)),pads:Array.from(o().subarray(z>>>0,z+4>>>0)),strides:Array.from(o().subarray(U>>>0,U+2>>>0)),wIsConst:()=>!!r()[le>>>0],outputPadding:0<ae?Array.from(o().subarray(fe>>>0,fe+ae>>>0)):[],outputShape:0<Oe?Array.from(o().subarray(Le>>>0,Le+Oe>>>0)):[]})},917382:(c,m,x,S,D,z,U,de,le,ae,fe,Oe,Le,L)=>{a.Ea("ConvTranspose",c,{format:le?"NHWC":"NCHW",autoPad:m,dilations:[x],group:S,kernel_shape:[D],pads:[z,U],strides:[de],wIsConst:()=>!!r()[ae>>>0],outputPadding:fe?Array.from(o().subarray(Oe>>>0,Oe+fe>>>0)):[],outputShape:Le?Array.from(o().subarray(L>>>0,L+Le>>>0)):[]})},917762:(c,m,x,S,D,z,U,de,le,ae,fe,Oe,Le)=>{a.Ea("ConvTranspose",c,{format:de?"NHWC":"NCHW",autoPad:m,dilations:Array.from(o().subarray(x>>>0,x+2>>>0)),group:S,kernelShape:Array.from(o().subarray(D>>>0,D+2>>>0)),pads:Array.from(o().subarray(z>>>0,z+4>>>0)),strides:Array.from(o().subarray(U>>>0,U+2>>>0)),wIsConst:()=>!!r()[le>>>0],outputPadding:0<ae?Array.from(o().subarray(fe>>>0,fe+ae>>>0)):[],outputShape:0<Oe?Array.from(o().subarray(Le>>>0,Le+Oe>>>0)):[]})},918285:(c,m)=>{a.Ea("GlobalAveragePool",c,{format:m?"NHWC":"NCHW"})},918376:(c,m,x,S,D,z,U,de,le,ae,fe,Oe,Le,L,ve,ze)=>{a.Ea("AveragePool",c,{format:ze?"NHWC":"NCHW",auto_pad:m,ceil_mode:x,count_include_pad:S,storage_order:D,dilations:[z,U],kernel_shape:[de,le],pads:[ae,fe,Oe,Le],strides:[L,ve]})},918660:(c,m)=>{a.Ea("GlobalAveragePool",c,{format:m?"NHWC":"NCHW"})},918751:(c,m,x,S,D,z,U,de,le,ae,fe,Oe,Le,L,ve,ze)=>{a.Ea("AveragePool",c,{format:ze?"NHWC":"NCHW",auto_pad:m,ceil_mode:x,count_include_pad:S,storage_order:D,dilations:[z,U],kernel_shape:[de,le],pads:[ae,fe,Oe,Le],strides:[L,ve]})},919035:(c,m)=>{a.Ea("GlobalMaxPool",c,{format:m?"NHWC":"NCHW"})},919122:(c,m,x,S,D,z,U,de,le,ae,fe,Oe,Le,L,ve,ze)=>{a.Ea("MaxPool",c,{format:ze?"NHWC":"NCHW",auto_pad:m,ceil_mode:x,count_include_pad:S,storage_order:D,dilations:[z,U],kernel_shape:[de,le],pads:[ae,fe,Oe,Le],strides:[L,ve]})},919402:(c,m)=>{a.Ea("GlobalMaxPool",c,{format:m?"NHWC":"NCHW"})},919489:(c,m,x,S,D,z,U,de,le,ae,fe,Oe,Le,L,ve,ze)=>{a.Ea("MaxPool",c,{format:ze?"NHWC":"NCHW",auto_pad:m,ceil_mode:x,count_include_pad:S,storage_order:D,dilations:[z,U],kernel_shape:[de,le],pads:[ae,fe,Oe,Le],strides:[L,ve]})},919769:(c,m,x,S,D)=>{a.Ea("Gemm",c,{alpha:m,beta:x,transA:S,transB:D})},919873:c=>{a.Ea("MatMul",c,void 0)},919927:(c,m,x,S)=>{a.Ea("ArgMax",c,{keepDims:!!m,selectLastIndex:!!x,axis:S})},920035:(c,m,x,S)=>{a.Ea("ArgMin",c,{keepDims:!!m,selectLastIndex:!!x,axis:S})},920143:(c,m)=>{a.Ea("Softmax",c,{axis:m})},920206:(c,m)=>{a.Ea("Concat",c,{axis:m})},920266:(c,m,x,S,D)=>{a.Ea("Split",c,{axis:m,numOutputs:x,splitSizes:S?Array.from(o().subarray(D>>>0,D+S>>>0)):[]})},920411:c=>{a.Ea("Expand",c,void 0)},920465:(c,m)=>{a.Ea("Gather",c,{axis:Number(m)})},920536:(c,m)=>{a.Ea("GatherElements",c,{axis:Number(m)})},920615:(c,m,x,S,D,z,U,de,le,ae,fe)=>{a.Ea("Resize",c,{antialias:m,axes:x?Array.from(o().subarray(S>>>0,S+x>>>0)):[],coordinateTransformMode:Jt(D),cubicCoeffA:z,excludeOutside:U,extrapolationValue:de,keepAspectRatioPolicy:Jt(le),mode:Jt(ae),nearestMode:Jt(fe)})},920966:(c,m,x,S,D,z,U)=>{a.Ea("Slice",c,{starts:m?Array.from(o().subarray(x>>>0,x+m>>>0)):[],ends:S?Array.from(o().subarray(D>>>0,D+S>>>0)):[],axes:z?Array.from(o().subarray(U>>>0,U+z>>>0)):[]})},921197:c=>{a.Ea("Tile",c,void 0)},921249:(c,m,x)=>{a.Ea("LayerNormalization",c,{axis:Number(m),epsilon:Number(x)})},921356:(c,m,x)=>{a.Ea("InstanceNormalization",c,{epsilon:m,format:x?"NHWC":"NCHW"})},921470:(c,m,x)=>{a.Ea("InstanceNormalization",c,{epsilon:m,format:x?"NHWC":"NCHW"})},921584:c=>{a.Ea("Range",c,void 0)},921637:(c,m)=>{a.Ea("Einsum",c,{equation:Jt(m)})},921718:(c,m,x,S,D)=>{a.Ea("Pad",c,{mode:m,value:x,pads:S?Array.from(o().subarray(D>>>0,D+S>>>0)):[]})},921850:c=>{a.Ea("Gelu",c,void 0)},921902:c=>{a.Ea("BiasAdd",c,void 0)},921957:c=>{a.Ea("BiasSplitGelu",c,void 0)},922018:(c,m)=>{a.Ea("SkipLayerNormalization",c,{epsilon:m})},922099:c=>{a.zb(c)},922133:(c,m)=>a.Ab(c,m,a.bb.Fb,a.bb.errors),922245:c=>a.wb(c),922278:c=>a.yb(c),922310:(c,m,x)=>{a.jb(c,m,x,!0)},922349:(c,m,x)=>{a.jb(c,m,x)}};function Er(c){this.name="ExitStatus",this.message=`Program terminated with exit(${c})`,this.status=c}function Cr(c){c.terminate(),c.onmessage=()=>{}}function _n(c){(c=he.Qa[c])||Xt(),he.Eb(c)}function en(c){var m=he.tb();if(!m)return 6;he.Ya.push(m),he.Qa[c.Xa]=m,m.Xa=c.Xa;var x={cmd:"run",start_routine:c.Gb,arg:c.rb,pthread_ptr:c.Xa};return b&&m.unref(),m.postMessage(x,c.Mb),0}var An=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,tn=(c,m,x)=>{m>>>=0;var S=m+x;for(x=m;c[x]&&!(x>=S);)++x;if(16<x-m&&c.buffer&&An)return An.decode(c.buffer instanceof SharedArrayBuffer?c.slice(m,x):c.subarray(m,x));for(S="";m<x;){var D=c[m++];if(D&128){var z=c[m++]&63;if((D&224)==192)S+=String.fromCharCode((D&31)<<6|z);else{var U=c[m++]&63;D=(D&240)==224?(D&15)<<12|z<<6|U:(D&7)<<18|z<<12|U<<6|c[m++]&63,65536>D?S+=String.fromCharCode(D):(D-=65536,S+=String.fromCharCode(55296|D>>10,56320|D&1023))}}else S+=String.fromCharCode(D)}return S},Jt=(c,m)=>(c>>>=0)?tn(t(),c,m):"";function On(c){if(w)return G(1,1,c);st=c,Ye()||(he.Hb(),a.onExit&&a.onExit(c),Ce=!0),h(c,new Er(c))}var rn=c=>{if(st=c,w)throw Dr(c),"unwind";On(c)},he={ab:[],Ya:[],mb:[],Qa:{},gb:function(){w?he.vb():he.ub()},ub:function(){ke.unshift(()=>{ho(),he.Bb(()=>$n())})},vb:function(){he.receiveObjectTransfer=he.Db,he.threadInitTLS=he.lb,he.setExitStatus=he.kb,Ke=!1},kb:function(c){st=c},Sb:["$terminateWorker"],Hb:function(){for(var c of he.Ya)Cr(c);for(c of he.ab)Cr(c);he.ab=[],he.Ya=[],he.Qa=[]},Eb:function(c){var m=c.Xa;delete he.Qa[m],he.ab.push(c),he.Ya.splice(he.Ya.indexOf(c),1),c.Xa=0,ea(m)},Db:function(){},lb:function(){he.mb.forEach(c=>c())},Cb:c=>new Promise(m=>{c.onmessage=z=>{z=z.data;var U=z.cmd;if(z.targetThread&&z.targetThread!=Io()){var de=he.Qa[z.Rb];de?de.postMessage(z,z.transferList):P('Internal error! Worker sent a message "'+U+'" to target pthread '+z.targetThread+", but that thread no longer exists!")}else U==="checkMailbox"?Br():U==="spawnThread"?en(z):U==="cleanupThread"?_n(z.thread):U==="killThread"?(z=z.thread,U=he.Qa[z],delete he.Qa[z],Cr(U),ea(z),he.Ya.splice(he.Ya.indexOf(U),1),U.Xa=0):U==="cancelThread"?he.Qa[z.thread].postMessage({cmd:"cancel"}):U==="loaded"?(c.loaded=!0,m(c)):U==="alert"?alert("Thread "+z.threadId+": "+z.text):z.target==="setimmediate"?c.postMessage(z):U==="callHandler"?a[z.handler](...z.args):U&&P("worker sent an unknown command "+U)},c.onerror=z=>{throw P("worker sent an error! "+z.filename+":"+z.lineno+": "+z.message),z},b&&(c.on("message",function(z){c.onmessage({data:z})}),c.on("error",function(z){c.onerror(z)}));var x=[],S=["onExit","onAbort","print","printErr"],D;for(D of S)a.hasOwnProperty(D)&&x.push(D);c.postMessage({cmd:"load",handlers:x,urlOrBlob:a.mainScriptUrlOrBlob||n,wasmMemory:te,wasmModule:mt})}),Bb:function(c){c()},qb:function(){var c=O("ort-wasm-simd-threaded.worker.js");c=new Worker(c),he.ab.push(c)},tb:function(){return he.ab.length==0&&(he.qb(),he.Cb(he.ab[0])),he.ab.pop()}};a.PThread=he;var Pr=c=>{for(;0<c.length;)c.shift()(a)};a.establishStackSpace=function(){var c=Io(),m=o()[c+52>>2>>>0];c=o()[c+56>>2>>>0],pu(m,m-c),So(m)};function Dr(c){if(w)return G(2,0,c);rn(c)}a.invokeEntryPoint=function(c,m){c=hu.apply(null,[c,m]),Ye()?he.kb(c):ta(c)};function Ji(c){this.fb=c-24,this.pb=function(m){i()[this.fb+4>>2>>>0]=m},this.ob=function(m){i()[this.fb+8>>2>>>0]=m},this.gb=function(m,x){this.nb(),this.pb(m),this.ob(x)},this.nb=function(){i()[this.fb+16>>2>>>0]=0}}var Nt=0,At=0;function En(c,m,x,S){return w?G(3,1,c,m,x,S):kr(c,m,x,S)}function kr(c,m,x,S){if(c>>>=0,m>>>=0,x>>>=0,S>>>=0,typeof SharedArrayBuffer>"u")return P("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var D=[];return w&&D.length===0?En(c,m,x,S):(c={Gb:x,Xa:c,rb:S,Mb:D},w?(c.Ob="spawnThread",postMessage(c,D),0):en(c))}function Cn(c,m,x){return w?G(4,1,c,m,x):0}function Pn(c,m){if(w)return G(5,1,c,m)}var Dn=c=>{for(var m=0,x=0;x<c.length;++x){var S=c.charCodeAt(x);127>=S?m++:2047>=S?m+=2:55296<=S&&57343>=S?(m+=4,++x):m+=3}return m},nn=(c,m,x,S)=>{if(x>>>=0,!(0<S))return 0;var D=x;S=x+S-1;for(var z=0;z<c.length;++z){var U=c.charCodeAt(z);if(55296<=U&&57343>=U){var de=c.charCodeAt(++z);U=65536+((U&1023)<<10)|de&1023}if(127>=U){if(x>=S)break;m[x++>>>0]=U}else{if(2047>=U){if(x+1>=S)break;m[x++>>>0]=192|U>>6}else{if(65535>=U){if(x+2>=S)break;m[x++>>>0]=224|U>>12}else{if(x+3>=S)break;m[x++>>>0]=240|U>>18,m[x++>>>0]=128|U>>12&63}m[x++>>>0]=128|U>>6&63}m[x++>>>0]=128|U&63}}return m[x>>>0]=0,x-D},mo=(c,m,x)=>nn(c,t(),m,x);function go(c,m){if(w)return G(6,1,c,m)}function bo(c,m,x){if(w)return G(7,1,c,m,x)}function yo(c,m,x){return w?G(8,1,c,m,x):0}function vo(c,m){if(w)return G(9,1,c,m)}function xo(c,m,x){if(w)return G(10,1,c,m,x)}function on(c,m,x,S){if(w)return G(11,1,c,m,x,S)}function kn(c,m,x,S){if(w)return G(12,1,c,m,x,S)}function Bn(c,m,x,S){if(w)return G(13,1,c,m,x,S)}function Rn(c){if(w)return G(14,1,c)}function Mn(c,m){if(w)return G(15,1,c,m)}function Ln(c,m,x){if(w)return G(16,1,c,m,x)}var Nn=c=>{if(!Ce)try{if(c(),!Ye())try{w?ta(st):rn(st)}catch(m){m instanceof Er||m=="unwind"||h(1,m)}}catch(m){m instanceof Er||m=="unwind"||h(1,m)}};function an(c){c>>>=0,typeof Atomics.Nb=="function"&&(Atomics.Nb(o(),c>>2,c).value.then(Br),c+=128,Atomics.store(o(),c>>2,1))}a.__emscripten_thread_mailbox_await=an;function Br(){var c=Io();c&&(an(c),Nn(()=>du()))}a.checkMailbox=Br;var pr=c=>c%4===0&&(c%100!==0||c%400===0),wo=[0,31,60,91,121,152,182,213,244,274,305,335],Rr=[0,31,59,90,120,151,181,212,243,273,304,334];function Fn(c,m,x,S,D,z,U,de){return w?G(17,1,c,m,x,S,D,z,U,de):-52}function f(c,m,x,S,D,z,U){if(w)return G(18,1,c,m,x,S,D,z,U)}var v=c=>{var m=Dn(c)+1,x=Qi(m);return x&&mo(c,x,m),x},$=[],A=(c,m)=>{$.length=0;var x;for(m>>=2;x=t()[c++>>>0];)m+=x!=105&m,$.push(x==105?o()[m>>>0]:s()[m++>>>1]),++m;return $},B=c=>{var m=ra();return c=c(),So(m),c};function G(c,m){var x=arguments.length-2,S=arguments;return B(()=>{for(var D=na(8*x),z=D>>3,U=0;U<x;U++){var de=S[2+U];s()[z+U>>>0]=de}return cu(c,x,D,m)})}var X=[],pe={},re=()=>{if(!ie){var c={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"},m;for(m in pe)pe[m]===void 0?delete c[m]:c[m]=pe[m];var x=[];for(m in c)x.push(`${m}=${c[m]}`);ie=x}return ie},ie;function ce(c,m){if(w)return G(19,1,c,m);c>>>=0,m>>>=0;var x=0;return re().forEach(function(S,D){var z=m+x;for(D=i()[c+4*D>>2>>>0]=z,z=0;z<S.length;++z)r()[D++>>0>>>0]=S.charCodeAt(z);r()[D>>0>>>0]=0,x+=S.length+1}),0}function Ie(c,m){if(w)return G(20,1,c,m);c>>>=0,m>>>=0;var x=re();i()[c>>2>>>0]=x.length;var S=0;return x.forEach(function(D){S+=D.length+1}),i()[m>>2>>>0]=S,0}function Ae(c){return w?G(21,1,c):52}function M(c,m,x,S){return w?G(22,1,c,m,x,S):52}function be(c,m,x,S,D){return w?G(23,1,c,m,x,S,D):70}var Be=[null,[],[]];function Zt(c,m,x,S){if(w)return G(24,1,c,m,x,S);m>>>=0,x>>>=0,S>>>=0;for(var D=0,z=0;z<x;z++){var U=i()[m>>2>>>0],de=i()[m+4>>2>>>0];m+=8;for(var le=0;le<de;le++){var ae=t()[U+le>>>0],fe=Be[c];ae===0||ae===10?((c===1?ge:P)(tn(fe,0)),fe.length=0):fe.push(ae)}D+=de}return i()[S>>2>>>0]=D,0}var zn=[31,29,31,30,31,30,31,31,30,31,30,31],nu=[31,28,31,30,31,30,31,31,30,31,30,31];function Ub(c){var m=Array(Dn(c)+1);return nn(c,m,0,m.length),m}var Hb=(c,m)=>{r().set(c,m>>>0)};function ou(c,m,x,S){function D(L,ve,ze){for(L=typeof L=="number"?L.toString():L||"";L.length<ve;)L=ze[0]+L;return L}function z(L,ve){return D(L,ve,"0")}function U(L,ve){function ze(xu){return 0>xu?-1:0<xu?1:0}var Mr;return(Mr=ze(L.getFullYear()-ve.getFullYear()))===0&&(Mr=ze(L.getMonth()-ve.getMonth()))===0&&(Mr=ze(L.getDate()-ve.getDate())),Mr}function de(L){switch(L.getDay()){case 0:return new Date(L.getFullYear()-1,11,29);case 1:return L;case 2:return new Date(L.getFullYear(),0,3);case 3:return new Date(L.getFullYear(),0,2);case 4:return new Date(L.getFullYear(),0,1);case 5:return new Date(L.getFullYear()-1,11,31);case 6:return new Date(L.getFullYear()-1,11,30)}}function le(L){var ve=L.Za;for(L=new Date(new Date(L.$a+1900,0,1).getTime());0<ve;){var ze=L.getMonth(),Mr=(pr(L.getFullYear())?zn:nu)[ze];if(ve>Mr-L.getDate())ve-=Mr-L.getDate()+1,L.setDate(1),11>ze?L.setMonth(ze+1):(L.setMonth(0),L.setFullYear(L.getFullYear()+1));else{L.setDate(L.getDate()+ve);break}}return ze=new Date(L.getFullYear()+1,0,4),ve=de(new Date(L.getFullYear(),0,4)),ze=de(ze),0>=U(ve,L)?0>=U(ze,L)?L.getFullYear()+1:L.getFullYear():L.getFullYear()-1}c>>>=0,m>>>=0,x>>>=0,S>>>=0;var ae=o()[S+40>>2>>>0];S={Kb:o()[S>>2>>>0],Jb:o()[S+4>>2>>>0],cb:o()[S+8>>2>>>0],ib:o()[S+12>>2>>>0],eb:o()[S+16>>2>>>0],$a:o()[S+20>>2>>>0],Wa:o()[S+24>>2>>>0],Za:o()[S+28>>2>>>0],Tb:o()[S+32>>2>>>0],Ib:o()[S+36>>2>>>0],Lb:ae?Jt(ae):""},x=Jt(x),ae={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var fe in ae)x=x.replace(new RegExp(fe,"g"),ae[fe]);var Oe="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Le="January February March April May June July August September October November December".split(" ");ae={"%a":L=>Oe[L.Wa].substring(0,3),"%A":L=>Oe[L.Wa],"%b":L=>Le[L.eb].substring(0,3),"%B":L=>Le[L.eb],"%C":L=>z((L.$a+1900)/100|0,2),"%d":L=>z(L.ib,2),"%e":L=>D(L.ib,2," "),"%g":L=>le(L).toString().substring(2),"%G":L=>le(L),"%H":L=>z(L.cb,2),"%I":L=>(L=L.cb,L==0?L=12:12<L&&(L-=12),z(L,2)),"%j":L=>{for(var ve=0,ze=0;ze<=L.eb-1;ve+=(pr(L.$a+1900)?zn:nu)[ze++]);return z(L.ib+ve,3)},"%m":L=>z(L.eb+1,2),"%M":L=>z(L.Jb,2),"%n":()=>`
`,"%p":L=>0<=L.cb&&12>L.cb?"AM":"PM","%S":L=>z(L.Kb,2),"%t":()=>"	","%u":L=>L.Wa||7,"%U":L=>z(Math.floor((L.Za+7-L.Wa)/7),2),"%V":L=>{var ve=Math.floor((L.Za+7-(L.Wa+6)%7)/7);if(2>=(L.Wa+371-L.Za-2)%7&&ve++,ve)ve==53&&(ze=(L.Wa+371-L.Za)%7,ze==4||ze==3&&pr(L.$a)||(ve=1));else{ve=52;var ze=(L.Wa+7-L.Za-1)%7;(ze==4||ze==5&&pr(L.$a%400-1))&&ve++}return z(ve,2)},"%w":L=>L.Wa,"%W":L=>z(Math.floor((L.Za+7-(L.Wa+6)%7)/7),2),"%y":L=>(L.$a+1900).toString().substring(2),"%Y":L=>L.$a+1900,"%z":L=>{L=L.Ib;var ve=0<=L;return L=Math.abs(L)/60,(ve?"+":"-")+("0000"+(L/60*100+L%60)).slice(-4)},"%Z":L=>L.Lb,"%%":()=>"%"},x=x.replace(/%%/g,"\0\0");for(fe in ae)x.includes(fe)&&(x=x.replace(new RegExp(fe,"g"),ae[fe](S)));return x=x.replace(/\0\0/g,"%"),fe=Ub(x),fe.length>m?0:(Hb(fe,c),fe.length-1)}function To(c){try{c()}catch(m){Xt(m)}}function jb(c){var m={},x;for(x in c)(function(S){var D=c[S];m[S]=typeof D=="function"?function(){$o.push(S);try{return D.apply(null,arguments)}finally{Ce||($o.pop()===S||Xt(),Qt&&yr===1&&$o.length===0&&(yr=0,Ze+=1,To(gu),typeof Fibers<"u"&&Fibers.Ub()))}}:D})(x);return m}var yr=0,Qt=null,iu=0,$o=[],au={},su={},qb=0,Zi=null,Kb=[];function Yb(){return new Promise((c,m)=>{Zi={resolve:c,reject:m}})}function Xb(){var c=Qi(65548),m=c+12;i()[c>>2>>>0]=m,i()[c+4>>2>>>0]=m+65536,m=$o[0];var x=au[m];return x===void 0&&(x=qb++,au[m]=x,su[x]=m),m=x,o()[c+8>>2>>>0]=m,c}function Jb(){var c=o()[Qt+8>>2>>>0];return c=Z[su[c]],--Ze,c()}function Zb(c){if(!Ce){if(yr===0){var m=!1,x=!1;c((S=0)=>{if(!Ce&&(iu=S,m=!0,x)){yr=2,To(()=>bu(Qt)),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.resume(),S=!1;try{var D=Jb()}catch(de){D=de,S=!0}var z=!1;if(!Qt){var U=Zi;U&&(Zi=null,(S?U.reject:U.resolve)(D),z=!0)}if(S&&!z)throw D}}),x=!0,m||(yr=1,Qt=Xb(),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.pause(),To(()=>mu(Qt)))}else yr===2?(yr=0,To(yu),uu(Qt),Qt=null,Kb.forEach(S=>Nn(S))):Xt(`invalid state: ${yr}`);return iu}}function Qb(c){return Zb(m=>{c().then(m)})}he.gb();var ey=[null,On,Dr,En,Cn,Pn,go,bo,yo,vo,xo,on,kn,Bn,Rn,Mn,Ln,Fn,f,ce,Ie,Ae,M,be,Zt],ty={r:function(c,m,x){return Qb(async()=>{await a.xb(c,m,x)})},b:function(c,m,x){throw c>>>=0,new Ji(c).gb(m>>>0,x>>>0),Nt=c,At++,Nt},O:function(c){lu(c>>>0,!y,1,!g,131072,!1),he.lb()},l:function(c){c>>>=0,w?postMessage({cmd:"cleanupThread",thread:c}):_n(c)},I:kr,i:Cn,U:Pn,E:go,G:bo,V:yo,S:vo,K:xo,R:on,p:kn,F:Bn,C:Rn,T:Mn,D:Ln,q:()=>!0,A:function(c,m){c>>>=0,c==m>>>0?setTimeout(()=>Br()):w?postMessage({targetThread:c,cmd:"checkMailbox"}):(c=he.Qa[c])&&c.postMessage({cmd:"checkMailbox"})},M:function(){return-1},N:an,X:function(c){b&&he.Qa[c>>>0].ref()},u:function(c,m,x){c=m+2097152>>>0<4194305-!!c?(c>>>0)+4294967296*m:NaN,x>>>=0,c=new Date(1e3*c),o()[x>>2>>>0]=c.getUTCSeconds(),o()[x+4>>2>>>0]=c.getUTCMinutes(),o()[x+8>>2>>>0]=c.getUTCHours(),o()[x+12>>2>>>0]=c.getUTCDate(),o()[x+16>>2>>>0]=c.getUTCMonth(),o()[x+20>>2>>>0]=c.getUTCFullYear()-1900,o()[x+24>>2>>>0]=c.getUTCDay(),c=(c.getTime()-Date.UTC(c.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,o()[x+28>>2>>>0]=c},v:function(c,m,x){c=m+2097152>>>0<4194305-!!c?(c>>>0)+4294967296*m:NaN,x>>>=0,c=new Date(1e3*c),o()[x>>2>>>0]=c.getSeconds(),o()[x+4>>2>>>0]=c.getMinutes(),o()[x+8>>2>>>0]=c.getHours(),o()[x+12>>2>>>0]=c.getDate(),o()[x+16>>2>>>0]=c.getMonth(),o()[x+20>>2>>>0]=c.getFullYear()-1900,o()[x+24>>2>>>0]=c.getDay(),m=(pr(c.getFullYear())?wo:Rr)[c.getMonth()]+c.getDate()-1|0,o()[x+28>>2>>>0]=m,o()[x+36>>2>>>0]=-(60*c.getTimezoneOffset()),m=new Date(c.getFullYear(),6,1).getTimezoneOffset();var S=new Date(c.getFullYear(),0,1).getTimezoneOffset();c=(m!=S&&c.getTimezoneOffset()==Math.min(S,m))|0,o()[x+32>>2>>>0]=c},w:function(c){c>>>=0;var m=new Date(o()[c+20>>2>>>0]+1900,o()[c+16>>2>>>0],o()[c+12>>2>>>0],o()[c+8>>2>>>0],o()[c+4>>2>>>0],o()[c>>2>>>0],0),x=o()[c+32>>2>>>0],S=m.getTimezoneOffset(),D=new Date(m.getFullYear(),6,1).getTimezoneOffset(),z=new Date(m.getFullYear(),0,1).getTimezoneOffset(),U=Math.min(z,D);return 0>x?o()[c+32>>2>>>0]=+(D!=z&&U==S):0<x!=(U==S)&&(D=Math.max(z,D),m.setTime(m.getTime()+6e4*((0<x?U:D)-S))),o()[c+24>>2>>>0]=m.getDay(),x=(pr(m.getFullYear())?wo:Rr)[m.getMonth()]+m.getDate()-1|0,o()[c+28>>2>>>0]=x,o()[c>>2>>>0]=m.getSeconds(),o()[c+4>>2>>>0]=m.getMinutes(),o()[c+8>>2>>>0]=m.getHours(),o()[c+12>>2>>>0]=m.getDate(),o()[c+16>>2>>>0]=m.getMonth(),o()[c+20>>2>>>0]=m.getYear(),c=m.getTime()/1e3,fu((fr=c,1<=+Math.abs(fr)?0<fr?+Math.floor(fr/4294967296)>>>0:~~+Math.ceil((fr-+(~~fr>>>0))/4294967296)>>>0:0)),c>>>0},s:Fn,t:f,z:function(c,m,x){function S(ae){return(ae=ae.toTimeString().match(/\(([A-Za-z ]+)\)$/))?ae[1]:"GMT"}c>>>=0,m>>>=0,x>>>=0;var D=new Date().getFullYear(),z=new Date(D,0,1),U=new Date(D,6,1);D=z.getTimezoneOffset();var de=U.getTimezoneOffset(),le=Math.max(D,de);i()[c>>2>>>0]=60*le,o()[m>>2>>>0]=+(D!=de),c=S(z),m=S(U),c=v(c),m=v(m),de<D?(i()[x>>2>>>0]=c,i()[x+4>>2>>>0]=m):(i()[x>>2>>>0]=m,i()[x+4>>2>>>0]=c)},d:()=>{Xt("")},c:function(c,m,x){return c>>>=0,m=A(m>>>0,x>>>0),Qr[c].apply(null,m)},k:function(c,m,x){return c>>>=0,m=A(m>>>0,x>>>0),Qr[c].apply(null,m)},m:function(){},j:function(){return Date.now()},W:()=>{throw Ze+=1,"unwind"},B:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),g:function(){return b?(ah(),vr(ih)).cpus().length:navigator.hardwareConcurrency},L:function(c,m,x,S){for(he.Pb=m>>>0,X.length=x,m=S>>>0>>3,S=0;S<x;S++)X[S]=s()[m+S>>>0];return(0>c?Qr[-c-1]:ey[c]).apply(null,X)},y:function(c){c>>>=0;var m=t().length;if(c<=m||4294901760<c)return!1;for(var x=1;4>=x;x*=2){var S=m*(1+.2/x);S=Math.min(S,c+100663296);var D=Math;S=Math.max(c,S);e:{D=D.min.call(D,4294901760,S+(65536-S%65536)%65536)-te.buffer.byteLength+65535>>>16;try{te.grow(D),H();var z=1;break e}catch{}z=void 0}if(z)return!0}return!1},P:ce,Q:Ie,H:rn,h:Ae,o:M,x:be,n:Zt,a:te||a.wasmMemory,J:ou,e:function(c,m,x,S){return ou(c>>>0,m>>>0,x>>>0,S>>>0)}};(function(){function c(x,S){return x=x.exports,x=jb(x),Z=x=ry(x),he.mb.push(Z.Da),bt.unshift(Z.Y),mt=S,$n(),x}var m={a:ty};if(ho(),a.instantiateWasm)try{return a.instantiateWasm(m,c)}catch(x){P("Module.instantiateWasm callback failed with error: "+x),l(x)}return br(m,function(x){c(x.instance,x.module)}).catch(l),{}})(),a._OrtInit=(c,m)=>(a._OrtInit=Z.Z)(c,m),a._OrtGetLastError=(c,m)=>(a._OrtGetLastError=Z._)(c,m),a._OrtCreateSessionOptions=(c,m,x,S,D,z,U,de,le,ae)=>(a._OrtCreateSessionOptions=Z.$)(c,m,x,S,D,z,U,de,le,ae),a._OrtAppendExecutionProvider=(c,m)=>(a._OrtAppendExecutionProvider=Z.aa)(c,m),a._OrtAddFreeDimensionOverride=(c,m,x)=>(a._OrtAddFreeDimensionOverride=Z.ba)(c,m,x),a._OrtAddSessionConfigEntry=(c,m,x)=>(a._OrtAddSessionConfigEntry=Z.ca)(c,m,x),a._OrtReleaseSessionOptions=c=>(a._OrtReleaseSessionOptions=Z.da)(c),a._OrtCreateSession=(c,m,x)=>(a._OrtCreateSession=Z.ea)(c,m,x),a._OrtReleaseSession=c=>(a._OrtReleaseSession=Z.fa)(c),a._OrtGetInputOutputCount=(c,m,x)=>(a._OrtGetInputOutputCount=Z.ga)(c,m,x),a._OrtGetInputName=(c,m)=>(a._OrtGetInputName=Z.ha)(c,m),a._OrtGetOutputName=(c,m)=>(a._OrtGetOutputName=Z.ia)(c,m),a._OrtFree=c=>(a._OrtFree=Z.ja)(c),a._OrtCreateTensor=(c,m,x,S,D,z)=>(a._OrtCreateTensor=Z.ka)(c,m,x,S,D,z),a._OrtGetTensorData=(c,m,x,S,D)=>(a._OrtGetTensorData=Z.la)(c,m,x,S,D),a._OrtReleaseTensor=c=>(a._OrtReleaseTensor=Z.ma)(c),a._OrtCreateRunOptions=(c,m,x,S)=>(a._OrtCreateRunOptions=Z.na)(c,m,x,S),a._OrtAddRunConfigEntry=(c,m,x)=>(a._OrtAddRunConfigEntry=Z.oa)(c,m,x),a._OrtReleaseRunOptions=c=>(a._OrtReleaseRunOptions=Z.pa)(c),a._OrtCreateBinding=c=>(a._OrtCreateBinding=Z.qa)(c),a._OrtBindInput=(c,m,x)=>(a._OrtBindInput=Z.ra)(c,m,x),a._OrtBindOutput=(c,m,x,S)=>(a._OrtBindOutput=Z.sa)(c,m,x,S),a._OrtClearBoundOutputs=c=>(a._OrtClearBoundOutputs=Z.ta)(c),a._OrtReleaseBinding=c=>(a._OrtReleaseBinding=Z.ua)(c),a._OrtRunWithBinding=(c,m,x,S,D)=>(a._OrtRunWithBinding=Z.va)(c,m,x,S,D),a._OrtRun=(c,m,x,S,D,z,U,de)=>(a._OrtRun=Z.wa)(c,m,x,S,D,z,U,de),a._OrtEndProfiling=c=>(a._OrtEndProfiling=Z.xa)(c),a._JsepOutput=(c,m,x)=>(a._JsepOutput=Z.ya)(c,m,x),a._JsepGetNodeName=c=>(a._JsepGetNodeName=Z.za)(c);var Io=a._pthread_self=()=>(Io=a._pthread_self=Z.Aa)(),Qi=a._malloc=c=>(Qi=a._malloc=Z.Ba)(c),uu=a._free=c=>(uu=a._free=Z.Ca)(c);a.__emscripten_tls_init=()=>(a.__emscripten_tls_init=Z.Da)();var lu=a.__emscripten_thread_init=(c,m,x,S,D,z)=>(lu=a.__emscripten_thread_init=Z.Fa)(c,m,x,S,D,z);a.__emscripten_thread_crashed=()=>(a.__emscripten_thread_crashed=Z.Ga)();var cu=(c,m,x,S)=>(cu=Z.Ha)(c,m,x,S),ea=c=>(ea=Z.Ia)(c),ta=a.__emscripten_thread_exit=c=>(ta=a.__emscripten_thread_exit=Z.Ja)(c),du=a.__emscripten_check_mailbox=()=>(du=a.__emscripten_check_mailbox=Z.Ka)(),fu=c=>(fu=Z.La)(c),pu=(c,m)=>(pu=Z.Ma)(c,m),ra=()=>(ra=Z.Na)(),So=c=>(So=Z.Oa)(c),na=c=>(na=Z.Pa)(c),hu=a.dynCall_ii=(c,m)=>(hu=a.dynCall_ii=Z.Ra)(c,m),mu=c=>(mu=Z.Sa)(c),gu=()=>(gu=Z.Ta)(),bu=c=>(bu=Z.Ua)(c),yu=()=>(yu=Z.Va)();a.___start_em_js=922382,a.___stop_em_js=922543;function ry(c){c=Object.assign({},c);var m=S=>()=>S()>>>0,x=S=>D=>S(D)>>>0;return c.__errno_location=m(c.__errno_location),c.pthread_self=m(c.pthread_self),c.malloc=x(c.malloc),c.stackSave=m(c.stackSave),c.stackAlloc=x(c.stackAlloc),c}a.keepRuntimeAlive=Ye,a.wasmMemory=te,a.stackAlloc=na,a.stackSave=ra,a.stackRestore=So,a.UTF8ToString=Jt,a.stringToUTF8=mo,a.lengthBytesUTF8=Dn,a.ExitStatus=Er,a.PThread=he;var _o;Mt=function c(){_o||vu(),_o||(Mt=c)};function vu(){function c(){if(!_o&&(_o=!0,a.calledRun=!0,!Ce)&&(w||Pr(bt),u(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),!w)){if(a.postRun)for(typeof a.postRun=="function"&&(a.postRun=[a.postRun]);a.postRun.length;){var m=a.postRun.shift();wt.unshift(m)}Pr(wt)}}if(!(0<Tt))if(w)u(a),w||Pr(bt),startWorker(a);else{if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;)ke.unshift(a.preRun.shift());Pr(ke),0<Tt||(a.setStatus?(a.setStatus("Running..."),setTimeout(function(){setTimeout(function(){a.setStatus("")},1),c()},1)):c())}}if(a.preInit)for(typeof a.preInit=="function"&&(a.preInit=[a.preInit]);0<a.preInit.length;)a.preInit.pop()();return vu(),e.ready}})();typeof uh=="object"&&typeof ys=="object"?ys.exports=sh:typeof define=="function"&&define.amd&&define([],()=>sh)});var ch=Ve((EE,Mx)=>{Mx.exports='"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(Module.__embind_initialize_bindings(),initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err(`worker.js received unknown command ${e.data.cmd}`),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\n'});var fh,Lx,vs,xs,Ti,dh,Nx,Fx,zx,ph,Qe,wn=k(()=>{"use strict";fh=rh();Lx=lh(),xs=!1,Ti=!1,dh=!1,Nx=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},Fx=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},zx=(n,e)=>n?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":e?"ort-wasm-threaded.wasm":"ort-wasm.wasm",ph=async n=>{if(xs)return Promise.resolve();if(Ti)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(dh)throw new Error("previous call to 'initializeWebAssembly()' failed.");Ti=!0;let e=n.initTimeout,r=n.numThreads,t=n.simd,o=r>1&&Nx(),i=t&&Fx(),s=n.wasmPaths,a=typeof s=="string"?s:void 0,u=zx(i,o),l=typeof s=="object"?s[u]:void 0,d=!1,p=[];if(e>0&&p.push(new Promise(h=>{setTimeout(()=>{d=!0,h()},e)})),p.push(new Promise((h,g)=>{let y=o?Lx:fh,b={locateFile:(w,I)=>{if(o&&w.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([ch()],{type:"text/javascript"}));if(w.endsWith(".wasm")){if(l)return l;let O=a??I;return u==="ort-wasm-simd.wasm"?O+"ort-wasm-simd.jsep.wasm":u==="ort-wasm-simd-threaded.wasm"?O+"ort-wasm-simd-threaded.jsep.wasm":O+u}return I+w}};if(o)if(typeof Blob>"u")b.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let w=`var ortWasmThreaded=${y.toString()};`;b.mainScriptUrlOrBlob=new Blob([w],{type:"text/javascript"})}y(b).then(w=>{Ti=!1,xs=!0,vs=w,h()},w=>{Ti=!1,dh=!0,g(w)})})),await Promise.race(p),d)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},Qe=()=>{if(xs&&vs)return vs;throw new Error("WebAssembly is not initialized yet.")}});var nt,no,qe,$i=k(()=>{"use strict";wn();nt=(n,e)=>{let r=Qe(),t=r.lengthBytesUTF8(n)+1,o=r._malloc(t);return r.stringToUTF8(n,o,t),e.push(o),o},no=(n,e,r,t)=>{if(typeof n=="object"&&n!==null){if(r.has(n))throw new Error("Circular reference in options");r.add(n)}Object.entries(n).forEach(([o,i])=>{let s=e?e+o:o;if(typeof i=="object")no(i,s+".",r,t);else if(typeof i=="string"||typeof i=="number")t(s,i.toString());else if(typeof i=="boolean")t(s,i?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof i}`)})},qe=n=>{let e=Qe(),r=e.stackSave();try{let t=e.stackAlloc(8);e._OrtGetLastError(t,t+4);let o=e.HEAP32[t/4],i=e.HEAPU32[t/4+1],s=i?e.UTF8ToString(i):"";throw new Error(`${n} ERROR_CODE: ${o}, ERROR_MESSAGE: ${s}`)}finally{e.stackRestore(r)}}});var hh,mh=k(()=>{"use strict";wn();$i();hh=n=>{let e=Qe(),r=0,t=[],o=n||{};try{if(n?.logSeverityLevel===void 0)o.logSeverityLevel=2;else if(typeof n.logSeverityLevel!="number"||!Number.isInteger(n.logSeverityLevel)||n.logSeverityLevel<0||n.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${n.logSeverityLevel}`);if(n?.logVerbosityLevel===void 0)o.logVerbosityLevel=0;else if(typeof n.logVerbosityLevel!="number"||!Number.isInteger(n.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${n.logVerbosityLevel}`);n?.terminate===void 0&&(o.terminate=!1);let i=0;return n?.tag!==void 0&&(i=nt(n.tag,t)),r=e._OrtCreateRunOptions(o.logSeverityLevel,o.logVerbosityLevel,!!o.terminate,i),r===0&&qe("Can't create run options."),n?.extra!==void 0&&no(n.extra,"",new WeakSet,(s,a)=>{let u=nt(s,t),l=nt(a,t);e._OrtAddRunConfigEntry(r,u,l)!==0&&qe(`Can't set a run config entry: ${s} - ${a}.`)}),[r,t]}catch(i){throw r!==0&&e._OrtReleaseRunOptions(r),t.forEach(s=>e._free(s)),i}}});var Gx,Wx,Vx,Ux,gh,bh=k(()=>{"use strict";wn();$i();Gx=n=>{switch(n){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${n}`)}},Wx=n=>{switch(n){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${n}`)}},Vx=n=>{n.extra||(n.extra={}),n.extra.session||(n.extra.session={});let e=n.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1"),n.executionProviders&&n.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(n.enableMemPattern=!1)},Ux=(n,e,r)=>{for(let t of e){let o=typeof t=="string"?t:t.name;switch(o){case"xnnpack":o="XNNPACK";break;case"webnn":if(o="WEBNN",typeof t!="string"){let s=t;if(s?.deviceType){let a=nt("deviceType",r),u=nt(s.deviceType,r);Qe()._OrtAddSessionConfigEntry(n,a,u)!==0&&qe(`Can't set a session config entry: 'deviceType' - ${s.deviceType}.`)}if(s?.numThreads){let a=s.numThreads;(typeof a!="number"||!Number.isInteger(a)||a<0)&&(a=0);let u=nt("numThreads",r),l=nt(a.toString(),r);Qe()._OrtAddSessionConfigEntry(n,u,l)!==0&&qe(`Can't set a session config entry: 'numThreads' - ${s.numThreads}.`)}if(s?.powerPreference){let a=nt("powerPreference",r),u=nt(s.powerPreference,r);Qe()._OrtAddSessionConfigEntry(n,a,u)!==0&&qe(`Can't set a session config entry: 'powerPreference' - ${s.powerPreference}.`)}}break;case"webgpu":if(o="JS",typeof t!="string"){let s=t;if(s?.preferredLayout){if(s.preferredLayout!=="NCHW"&&s.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${s.preferredLayout}`);let a=nt("preferredLayout",r),u=nt(s.preferredLayout,r);Qe()._OrtAddSessionConfigEntry(n,a,u)!==0&&qe(`Can't set a session config entry: 'preferredLayout' - ${s.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${o}`)}let i=nt(o,r);Qe()._OrtAppendExecutionProvider(n,i)!==0&&qe(`Can't append execution provider: ${o}.`)}},gh=n=>{let e=Qe(),r=0,t=[],o=n||{};Vx(o);try{let i=Gx(o.graphOptimizationLevel??"all"),s=Wx(o.executionMode??"sequential"),a=typeof o.logId=="string"?nt(o.logId,t):0,u=o.logSeverityLevel??2;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log serverity level is not valid: ${u}`);let l=o.logVerbosityLevel??0;if(!Number.isInteger(l)||l<0||l>4)throw new Error(`log verbosity level is not valid: ${l}`);let d=typeof o.optimizedModelFilePath=="string"?nt(o.optimizedModelFilePath,t):0;if(r=e._OrtCreateSessionOptions(i,!!o.enableCpuMemArena,!!o.enableMemPattern,s,!!o.enableProfiling,0,a,u,l,d),r===0&&qe("Can't create session options."),o.executionProviders&&Ux(r,o.executionProviders,t),o.freeDimensionOverrides)for(let[p,h]of Object.entries(o.freeDimensionOverrides)){if(typeof p!="string")throw new Error(`free dimension override name must be a string: ${p}`);if(typeof h!="number"||!Number.isInteger(h)||h<0)throw new Error(`free dimension override value must be a non-negative integer: ${h}`);let g=nt(p,t);e._OrtAddFreeDimensionOverride(r,g,h)!==0&&qe(`Can't set a free dimension override: ${p} - ${h}.`)}return o.extra!==void 0&&no(o.extra,"",new WeakSet,(p,h)=>{let g=nt(p,t),y=nt(h,t);e._OrtAddSessionConfigEntry(r,g,y)!==0&&qe(`Can't set a session config entry: ${p} - ${h}.`)}),[r,t]}catch(i){throw r!==0&&e._OrtReleaseSessionOptions(r),t.forEach(s=>e._free(s)),i}}});var ws,oo,io,Ii,ao,Si,Ts,dt=k(()=>{"use strict";ws=n=>{switch(n){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${n}`)}},oo=n=>{switch(n){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${n}`)}},io=n=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][n],Ii=n=>{switch(n){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${n}`)}},ao=n=>{switch(n){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${n}`)}},Si=n=>n==="float32"||n==="int32"||n==="int64"||n==="bool"||n==="float16"||n==="uint32",Ts=n=>{switch(n){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${n}`)}}});var Hx,jx,yh,vh,xh,qx,Je,Ar=k(()=>{"use strict";dt();Hx=["V","I","W","E","F"],jx=(n,e)=>{console.log(`[${Hx[n]},${new Date().toISOString()}]${e}`)},xh=(n,e)=>{yh=n,vh=e},qx=(n,e)=>{let r=ao(n),t=ao(yh);r>=t&&jx(r,typeof e=="function"?e():e)},Je=(...n)=>{vh&&qx(...n)}});var wh,Th=k(()=>{"use strict";dt();wh=(n,e)=>new(Ii(e))(n)});var $h=k(()=>{"use strict"});var _i,Kx,Ih,Is,$s,Sh,_h=k(()=>{"use strict";Ar();$h();_i=n=>Math.ceil(n/16)*16,Kx=1,Ih=()=>Kx++,Is=async(n,e,r,t)=>{let o=_i(r),i=n.device.createBuffer({size:o,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let s=n.getCommandEncoder();n.endComputePass(),s.copyBufferToBuffer(e,0,i,0,o),n.flush(),await i.mapAsync(GPUMapMode.READ);let a=i.getMappedRange();if(t){let u=t();return u.set(new Uint8Array(a,0,r)),u}else return new Uint8Array(a.slice(0,r))}finally{i.destroy()}},$s=class{constructor(e){this.backend=e;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(e,r){let t=r.buffer,o=r.byteOffset,i=r.byteLength,s=_i(i),a=this.storageCache.get(e);if(!a)throw new Error("gpu data for uploading does not exist");if(a.originalSize!==i)throw new Error(`inconsistent data size. gpu data size=${a.originalSize}, data size=${i}`);let u=this.backend.device.createBuffer({mappedAtCreation:!0,size:s,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),l=u.getMappedRange();new Uint8Array(l).set(new Uint8Array(t,o,i)),u.unmap();let d=this.backend.getCommandEncoder();this.backend.endComputePass(),d.copyBufferToBuffer(u,0,a.gpuData.buffer,0,s),Je("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${e})`),this.buffersForUploadingPending.push(u)}memcpy(e,r){let t=this.storageCache.get(e);if(!t)throw new Error("source gpu data for memcpy does not exist");let o=this.storageCache.get(r);if(!o)throw new Error("destination gpu data for memcpy does not exist");if(t.originalSize!==o.originalSize)throw new Error("inconsistent source and destination gpu data size");let i=_i(t.originalSize),s=this.backend.getCommandEncoder();this.backend.endComputePass(),s.copyBufferToBuffer(t.gpuData.buffer,0,o.gpuData.buffer,0,i)}registerExternalBuffer(e,r,t){let o;if(t){if(o=this.externalBuffers.get(t),o===void 0)throw new Error("previous buffer is not registered");if(e===t)return Je("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${o}, buffer is the same, skip.`),o;this.externalBuffers.delete(t)}else o=Ih();return this.storageCache.set(o,{gpuData:{id:o,type:0,buffer:e},originalSize:r}),this.externalBuffers.set(e,o),Je("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${o}, registered.`),o}unregisterExternalBuffer(e){let r=this.externalBuffers.get(e);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(e),Je("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(e,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let t=_i(e),o,i=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,s=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(i||s){let u=i?this.freeBuffers:this.freeUniformBuffers,l=u.get(t);l||(l=[],u.set(t,l)),l.length>0?o=l.pop():o=this.backend.device.createBuffer({size:t,usage:r})}else o=this.backend.device.createBuffer({size:t,usage:r});let a={id:Ih(),type:0,buffer:o};return this.storageCache.set(a.id,{gpuData:a,originalSize:e}),Je("verbose",()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${a.id}`),a}get(e){return this.storageCache.get(e)?.gpuData}release(e){let r=this.storageCache.get(e);if(!r)throw new Error("releasing data does not exist");return Je("verbose",()=>`[WebGPU] GpuDataManager.release(id=${e}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(e),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(e,r){let t=this.storageCache.get(e);if(!t)throw new Error("data does not exist");await Is(this.backend,t.gpuData.buffer,t.originalSize,r)}refreshPendingBuffers(){for(let e of this.buffersForUploadingPending)e.destroy();this.buffersForUploadingPending=[];for(let e of this.buffersPending)(e.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(e.size).push(e):(e.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(e.size).push(e):e.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(e=>{e.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(e=>{e.forEach(r=>{r.destroy()})}),this.storageCache.forEach(e=>{e.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},Sh=(...n)=>new $s(...n)});var Ss,me,ot=k(()=>{"use strict";Ss=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(e=>`${this[e]}`).join(";")),this._cacheKey}},me=n=>new Ss(n)});var _s,ar,W,Xr,Ai,Oi,Ei,Ee=k(()=>{"use strict";_s=class{static calcMatMulShape(e,r){return e[1]!==r[0]?void 0:[e[0],r[1]]}},ar=class{static calcShape(e,r,t=!1){let o=e.length,i=r.length;if(o===0)return r;if(i===0)return e;let s=Math.max(e.length,r.length),a=new Array(s);if(t){if(o<2||i<2)return;let u=_s.calcMatMulShape([e[o-2],e[o-1]],[r[i-2],r[i-1]]);if(u===void 0)return;[a[s-2],a[s-1]]=u}for(let u=t?3:1;u<=s;u++){let l=o-u<0?1:e[o-u],d=i-u<0?1:r[i-u];if(l!==d&&l>1&&d>1)return;a[s-u]=Math.max(l,d)}return a}static isValidBroadcast(e,r){let t=e.length,o=r.length;if(t>o)return!1;for(let i=1;i<=t;i++)if(e[t-i]!==1&&e[t-i]!==r[o-i])return!1;return!0}},W=class n{static size(e){return n.getSizeFromDimensionRange(e,0,e.length)}static sizeFromDimension(e,r){if(r<0||r>e.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return n.getSizeFromDimensionRange(e,r,e.length)}static sizeToDimension(e,r){if(r<0||r>e.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${e.length} dimensions.`);return n.getSizeFromDimensionRange(e,0,r)}static getSizeFromDimensionRange(e,r,t){let o=1;for(let i=r;i<t;i++){if(e[i]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");o*=e[i]}return o}static computeStrides(e){let r=e.length;if(r===0)return[];if(r===1)return[1];let t=new Array(r);t[r-1]=1,t[r-2]=e[r-1];for(let o=r-3;o>=0;--o)t[o]=t[o+1]*e[o+1];return t}static normalizeAxis(e,r){if(e<-r&&e>=r)throw new Error("unsupported axis for this operation.");return e<0?e+r:e}static normalizeAxes(e,r){return e.map(t=>this.normalizeAxis(t,r??e.length))}static sortBasedOnPerm(e,r){return r?r.map(t=>e[t]):e.slice().reverse()}static padShape(e,r){let t=e.length;return e.map((o,i)=>o+r[i]+r[i+t])}static areEqual(e,r){return e.length!==r.length?!1:e.every((t,o)=>t===r[o])}},Xr=class n{static adjustPoolAttributes(e,r,t,o,i,s){if(!e&&t.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let a=0;a<r.length-2;a++)a>=t.length?t.push(r[a+2]):t[a]=r[a+2];for(let a=0;a<t.length;a++)if(a<o.length){if(o[a]<0)throw new Error("strides should be greater than or equal to 1")}else o.push(1);for(let a=0;a<t.length;a++)if(a<i.length){if(i[a]<0)throw new Error("dilations should be greater than or equal to 1")}else i.push(1);for(let a=0;a<t.length*2;a++)if(a<s.length){if(s[a]<0)throw new Error("pad should be greater than or equal to 1")}else s.push(0);for(let a=0;a<t.length;a++){if(t[a]<=0)throw new Error("kernel shapes need to be greater than 0");if(s[a]>=t[a]||s[a+t.length]>=t[a])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,r,t,o,i,s,a){if(a){if(i.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(o.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let u=0;u<e.length-2;u++)n.adjustPadAndReturnShape(e[u+(s?1:2)],r[u],t[u],o[u],i,u,u+e.length-2,a)}}static computePoolOutputShape(e,r,t,o,i,s,a){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let u=[r[0],r[1]];return n.computeShapeHelper(e,r,u,t,o,i,s,a),u}static computeConvOutputShape(e,r,t,o,i,s,a){if(e.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let u=[e[0],r[0]];return n.computeShapeHelper(!1,e,u,t,o,i,s,a),u}static computeShapeHelper(e,r,t,o,i,s,a,u){if(e)for(let l=0;l<r.length-2;l++)t.push(1);else for(let l=0;l<r.length-2;l++)t.push(n.adjustPadAndReturnShape(r[l+2],o[l],i[l],s[l],a,l,l+r.length-2,u))}static adjustPadAndReturnShape(e,r,t,o,i,s,a,u){let l=t*(o-1)+1;if(u&&u!=="NOTSET")switch(u){case"VALID":return i[s]=0,i[a]=0,Math.floor((e-l)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(t!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let p=((e+r-1)/r-1)*r+o-e;return i[s]=Math.floor(u==="SAME_LOWER"?(p+1)/2:p/2),i[a]=p-i[s],Math.floor((e+p-o)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((e+i[s]+i[a]-l)/r+1)}},Ai=class{static getShapeOfGemmResult(e,r,t,o,i){if(e.length!==2||t.length!==2)throw new Error("shape need to be of size 2");let s,a,u;r?(s=e[1],a=e[0]):(s=e[0],a=e[1]);let l=-1;if(o?(u=t[0],l=1):(u=t[1],l=0),t[l]!==a)throw new Error("dimension mismatch");if(s<=0||u<=0||a<=0)throw new Error("invalid shape specified");if(i&&!ar.isValidBroadcast(i,[s,u]))throw new Error("gemm: invalid bias shape for broadcast");return[s,u,a]}},Oi=-34028234663852886e22,Ei=34028234663852886e22});var Yx,Ah,it,Os,Oh,ee,ye,As,Eh,Es,Ge=k(()=>{"use strict";dt();Ee();Yx=64,Ah=(n,e)=>{if(e===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(n){case 10:return e>1?`vec${e}<f16>`:"f16";case 1:return e>1?`vec${e}<f32>`:"f32";case 6:return e>1?`vec${e}<i32>`:"i32";case 12:return e>1?`vec${e}<u32>`:"u32";case 7:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(e!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${n}`)}},it=(n,e=1)=>{let r=Ah(n,e);return typeof r=="string"?r:r[0]},Os=n=>[{type:"uint32",data:n},{type:"uint32",data:W.computeStrides(n)}],Oh=(n,e,r,t,o)=>{let i=typeof r=="number",s=i?r:r.length,a=[...new Array(s).keys()],u=s<2?"u32":s<=4?`vec${s}<u32>`:`array<u32, ${s}>`,l=Ah(e,o),d=typeof l=="string"?l:l[1],p=typeof l=="string"?l:l[0],h={indices:u,value:d,storage:p,tensor:e},g=H=>typeof H=="string"?H:`${H}u`,y={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},b=i?"uniforms.":"",w=`${b}${n}_shape`,I=`${b}${n}_strides`,O="";for(let H=0;H<s-1;H++)O+=`
    let dim${H} = current / ${I}[${H}];
    let rest${H} = current % ${I}[${H}];
    indices[${H}] = dim${H};
    current = rest${H};
    `;O+=`indices[${s-1}] = current;`;let E=s<2?"":`
  fn o2i_${n}(offset: u32) -> ${h.indices} {
    var indices: ${h.indices};
    var current = offset;
    ${O}
    return indices;
  }`,N=H=>(y.offsetToIndices=!0,s<2?H:`o2i_${n}(${H})`),F=[];if(s>=2)for(let H=s-1;H>=0;H--)F.push(`${I}[${H}] * (indices[${H}])`);let R=s<2?"":`
  fn i2o_${n}(indices: ${h.indices}) -> u32 {
    return ${F.join("+")};
  }`,V=H=>(y.indicesToOffset=!0,s<2?H:`i2o_${n}(${H})`),K=(...H)=>s===0?"0u":`${h.indices}(${H.map(g).join(",")})`,J=(H,Te)=>s<2?`${H}`:`${H}[${Te}]`,ge=(H,Te,ke)=>s<2?`${H}=${ke};`:`${H}[${Te}]=${ke};`,P={},oe=(H,Te)=>{y.broadcastedIndicesToOffset=!0;let ke=`${Te.name}broadcastedIndicesTo${n}Offset`;if(ke in P)return`${ke}(${H})`;let bt=[];for(let wt=s-1;wt>=0;wt--){let Ze=Te.indicesGet("outputIndices",wt+Te.rank-s);bt.push(`${J(I,wt)} * (${Ze} % ${J(w,wt)})`)}return P[ke]=`fn ${ke}(outputIndices: ${Te.type.indices}) -> u32 {
             return ${bt.length>0?bt.join("+"):"0u"};
           }`,`${ke}(${H})`},Ke=(H,Te)=>(()=>{if(h.storage===h.value)return`${n}[${H}]=${Te};`;if(h.storage==="vec2<u32>"&&h.value==="i32")return`${n}[${H}]=vec2<u32>(u32(${Te}), select(0u, 0xFFFFFFFFu, ${Te} < 0));`;if(h.storage==="vec2<u32>"&&h.value==="u32")return`${n}[${H}]=vec2<u32>(u32(${Te}), 0u);`;if(h.storage==="u32"&&h.value==="vec4<bool>")return`${n}[${H}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${Te}));`;throw new Error(`not supported combination of storage type ${h.storage} and value type ${h.value} yet`)})(),te=H=>(()=>{if(h.storage===h.value)return`${n}[${H}]`;if(h.storage==="vec2<u32>"&&h.value==="i32")return`i32(${n}[${H}].x)`;if(h.storage==="vec2<u32>"&&h.value==="u32")return`u32(${n}[${H}].x)`;if(h.storage==="u32"&&h.value==="vec4<bool>")return`vec4<bool>(bool(${n}[${H}] & 0xFFu), bool(${n}[${H}] & 0xFF00u), bool(${n}[${H}] & 0xFF0000u), bool(${n}[${H}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${h.storage} and value type ${h.value} yet`)})(),Z=s<2?"":`
  fn get_${n}ByIndices(indices: ${h.indices}) -> ${d} {
    return ${te(`i2o_${n}(indices)`)};
  }`,mt=s<2?"":(()=>{let H=a.map(ke=>`d${ke}: u32`).join(", "),Te=a.map(ke=>`d${ke}`).join(", ");return`
  fn get_${n}(${H}) -> ${d} {
    return get_${n}ByIndices(${K(Te)});
  }`})(),Ce=(...H)=>{if(H.length!==s)throw new Error(`indices length must be ${s}`);let Te=H.map(g).join(",");return s===0?te("0u"):s===1?te(Te[0]):(y.get=!0,y.getByIndices=!0,y.indicesToOffset=!0,`get_${n}(${Te})`)},st=H=>s<2?te(H):(y.getByIndices=!0,y.indicesToOffset=!0,`get_${n}ByIndices(${H})`),Fe=s<2?"":`
  fn set_${n}ByIndices(indices: ${h.indices}, value: ${d}) {
    ${Ke(`i2o_${n}(indices)`,"value")}
  }`,ut=s<2?"":(()=>{let H=a.map(ke=>`d${ke}: u32`).join(", "),Te=a.map(ke=>`d${ke}`).join(", ");return`
  fn set_${n}(${H}, value: ${d}) {
    set_${n}ByIndices(${K(Te)}, value);
  }`})();return{impl:()=>{let H=[];return i||(H.push(`const ${w} = ${h.indices}(${r.join(",")});`),H.push(`const ${I} = ${h.indices}(${W.computeStrides(r).join(",")});`)),y.offsetToIndices&&H.push(E),y.indicesToOffset&&H.push(R),y.broadcastedIndicesToOffset&&Object.values(P).forEach(Te=>H.push(Te)),y.set&&H.push(ut),y.setByIndices&&H.push(Fe),y.get&&H.push(mt),y.getByIndices&&H.push(Z),H.join(`
`)},type:h,offsetToIndices:N,indicesToOffset:V,broadcastedIndicesToOffset:oe,indices:K,indicesGet:J,indicesSet:ge,set:(...H)=>{if(H.length!==s+1)throw new Error(`indices length must be ${s}`);let Te=H[s];if(typeof Te!="string")throw new Error("value must be string");let ke=H.slice(0,s).map(g).join(",");return s===0?Ke("0u",Te):s===1?Ke(ke[0],Te):(y.set=!0,y.setByIndices=!0,y.indicesToOffset=!0,`set_${n}(${ke}, ${Te})`)},setByOffset:Ke,setByIndices:(H,Te)=>s<2?Ke(H,Te):(y.setByIndices=!0,y.indicesToOffset=!0,`set_${n}ByIndices(${H}, ${Te});`),get:Ce,getByOffset:te,getByIndices:st,usage:t?"input":"output",name:n,strides:I,shape:w,rank:s}},ee=(n,e,r,t=1)=>Oh(n,e,r,!0,t),ye=(n,e,r,t=1)=>Oh(n,e,r,!1,t),As=class{constructor(e){this.normalizedDispatchGroup=e;this.indicesHelpers=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${typeof e=="number"?`${e}u`:e}) { return; }`}mainStart(e=Yx){let r=typeof e=="number"?e:e[0],t=typeof e=="number"?1:e[1],o=typeof e=="number"?1:e[2],i=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,s=i?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_index : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>`,a=i?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +
          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${r*t*o}u + local_index;`;return`@compute @workgroup_size(${r}, ${t}, ${o})
  fn main(${s}) {
    ${a}
  `}declareVariable(e,r){this.indicesHelpers.push(e),e.shape.startsWith("uniforms.")&&this.uniforms.push({name:e.shape.replace("uniforms.",""),type:e.type.indices}),e.strides.startsWith("uniforms.")&&this.uniforms.push({name:e.strides.replace("uniforms.",""),type:e.type.indices});let t=e.usage==="input"?"read":"read_write",o=e.type.storage;return`@group(0) @binding(${r}) var<storage, ${t}> ${e.name}: array<${o}>;`}declareVariables(...e){return e.map(r=>this.declareVariable(r,this.variableIndex++)).join(`
`)}registerUniform(e,r){return this.uniforms.push({name:e,type:r}),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let e=[];for(let{name:r,type:t}of this.uniforms)e.push(`${r}:${t}`);return`
      struct Uniforms { ${e.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.indicesHelpers.map(e=>e.impl()).join(`
`)}},Eh=n=>new As(n),Es=(n,e)=>{let r=n.length,t=[];for(let o=0;o<r;o++){let i=r-1-o,s=n[i]||1;(e[e.length-1-o]||1)>1&&s===1&&t.unshift(i)}return t}});var sr,Xx,Ci,Jx,ur,Ch,Ph,Dh,kh,Bh,Rh,Mh,Lh,Nh,Fh,qt,Cs=k(()=>{"use strict";Ee();ot();Ge();sr=n=>{if(!n||n.length===0||n.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(n.length===2&&n[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Xx=n=>["","",`var value = ${n.getByOffset("inputOffset")};`,""],Ci=(n,e,r,t,o,i,s=!1,a=!1)=>{let u=[],l=r[0].dims,d=W.normalizeAxes(o,r[0].dims.length),p=!a&&d.length===0;l.forEach((V,K)=>{p||d.indexOf(K)>=0?s&&u.push(1):u.push(V)});let h=[],g=ee("_A",r[0].dataType,l),y=ye("output",i,u),b=t(g,y,d),w=`inputOffset = ${g.indicesToOffset("inputIndices")};`,I=`let ${w};`,O=`var ${w};`,E=b[1]===""?"":O,N=(b[1]===""?I:w)+`
`+b[2];for(let V=0,K=0;V<r[0].dims.length;V++)p||d.indexOf(V)>=0?(s&&K++,N=`for(var j${V}: u32 = 0; j${V} < ${r[0].dims[V]}; j${V}++) {
                ${b[2].includes("lastIndex")?`let lastIndex = j${V};`:""}
                ${g.indicesSet("inputIndices",V,`j${V}`)}
                ${N}
              }`):(h.push(`${g.indicesSet("inputIndices",V,y.indicesGet("outputIndices",K))};`),K++);let F=W.size(u);return{name:n,shaderCache:e,getShaderSource:V=>`
        ${V.declareVariables(g,y)}

        ${V.mainStart()}
          ${V.guardAgainstOutOfBoundsWorkgroupSizes(F)}
          var inputIndices: ${g.type.indices};
          let outputIndices = ${y.offsetToIndices("global_idx")};

          ${h.join(`
`)}
          ${b[0]}       // init ops for reduce max/min
          ${E}
          ${b[1]}
          ${N}
          ${b[3]}
          ${b.length===4?y.setByOffset("global_idx","value"):b.slice(4).join(`
`)}
        }`,getRunData:()=>({outputs:[{dims:u,dataType:i}],dispatchGroup:{x:Math.ceil(F/64)}})}},Jx=(n,e)=>{let r=[];return n[1].dims[0]>0&&n[1].getBigInt64Array().forEach(t=>r.push(Number(t))),me({axes:r,keepDims:e.keepDims,noopWithEmptyAxes:e.noopWithEmptyAxes})},ur=(n,e,r,t)=>{let o=n.inputs,i=o.length===1?r:Jx(o,r);n.compute(Ci(e,{hint:i.cacheKey},[o[0]],i.noopWithEmptyAxes&&i.axes.length===0?Xx:t,i.axes,o[0].dataType,i.keepDims,i.noopWithEmptyAxes),{inputs:[0]})},Ch=(n,e)=>{sr(n.inputs),ur(n,"ReduceLogSum",e,(t,o)=>[`var value = ${o.type.storage}(0);`,"",`value += ${t.getByOffset("inputOffset")};`,"value = log(value);"])},Ph=(n,e)=>{sr(n.inputs),ur(n,"ReduceL1",e,(t,o)=>[`var value = ${o.type.storage}(0);`,"",`value += abs(${t.getByOffset("inputOffset")});`,""])},Dh=(n,e)=>{sr(n.inputs),ur(n,"ReduceL2",e,(t,o)=>[`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,"",`t = ${t.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"])},kh=(n,e)=>{sr(n.inputs),ur(n,"ReduceLogSumExp",e,(t,o)=>[`var value = ${o.type.storage}(0);`,"",`value += exp(${t.getByOffset("inputOffset")});`,"value = log(value);"])},Bh=(n,e)=>{sr(n.inputs),ur(n,"ReduceMax",e,(t,o,i)=>{let s=[];for(let a=0;a<t.rank;a++)(i.indexOf(a)>=0||i.length===0)&&s.push(t.indicesSet("inputIndices",a,0));return[`${s.join(`
`)}`,`var value = ${t.getByOffset("inputOffset")};`,`value = max(value, ${t.getByOffset("inputOffset")});`,""]})},Rh=(n,e)=>{sr(n.inputs),ur(n,"ReduceMean",e,(t,o,i)=>{let s=1;for(let a=0;a<t.rank;a++)(i.indexOf(a)>=0||i.length===0)&&(s*=n.inputs[0].dims[a]);return["var sum = f32(0);","",`sum += f32(${t.getByOffset("inputOffset")});`,`let value = ${o.type.value}(sum / ${s});`]})},Mh=(n,e)=>{sr(n.inputs),ur(n,"ReduceMin",e,(t,o,i)=>{let s=[];for(let a=0;a<t.rank;a++)(i.indexOf(a)>=0||i.length===0)&&s.push(`inputIndices[${a}] = 0;`);return[`${s.join(`
`)}`,`var value = ${t.getByOffset("inputOffset")};`,`value = min(value, ${t.getByOffset("inputOffset")});`,""]})},Lh=(n,e)=>{sr(n.inputs),ur(n,"ReduceProd",e,(t,o)=>[`var value = ${o.type.storage}(1);`,"",`value *= ${t.getByOffset("inputOffset")};`,""])},Nh=(n,e)=>{sr(n.inputs),ur(n,"ReduceSum",e,(t,o)=>[`var value = ${o.type.storage}(0);`,"",`value += ${t.getByOffset("inputOffset")};`,""])},Fh=(n,e)=>{sr(n.inputs),ur(n,"ReduceSumSquare",e,(t,o)=>[`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,"",`t = ${t.getByOffset("inputOffset")}; value += t * t;`,""])},qt=n=>me(n)});var zh,Gh,Wh,Vh,Ps,Uh=k(()=>{"use strict";dt();ot();Cs();zh=n=>{if(!n||n.length===0||n.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(n[0].dataType!==1)throw new Error("Invalid input type.")},Gh=(n,e)=>me({axis:e.axis,keepDims:e.keepDims,selectLastIndex:e.selectLastIndex}),Wh=(n,e)=>{zh(n.inputs);let r=(o,i,s)=>{let a=[];for(let u=0;u<o.rank;u++)(s.indexOf(u)>=0||s.length===0)&&a.push(`inputIndices[${u}] = 0;`);return[`${a.join(`
`)}`,`var value = ${o.getByOffset("inputOffset")};
var bestIndex : i32 = 0;`,`if (${o.getByOffset("inputOffset")} ${e.selectLastIndex>0?"<=":"<"} value) {
         value = ${o.getByOffset("inputOffset")};
         bestIndex = i32(lastIndex);
       }`,"",i.setByOffset("global_idx","bestIndex")]},t=n.inputs.length===1?e:Gh(n.inputs,e);n.compute(Ci("ArgMin",{hint:t.cacheKey},[n.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},Vh=(n,e)=>{zh(n.inputs);let r=(o,i,s)=>{let a=[];for(let u=0;u<o.rank;u++)(s.indexOf(u)>=0||s.length===0)&&a.push(`inputIndices[${u}] = 0;`);return[`${a.join(`
`)}`,`var value = ${o.getByOffset("inputOffset")};
var bestIndex : i32 = 0;`,`if (${o.getByOffset("inputOffset")} ${e.selectLastIndex>0?">=":">"} value) {
         value = ${o.getByOffset("inputOffset")};
         bestIndex = i32(lastIndex);
       }`,"",i.setByOffset("global_idx","bestIndex")]},t=n.inputs.length===1?e:Gh(n.inputs,e);n.compute(Ci("argMax",{hint:t.cacheKey},[n.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},Ps=n=>me(n)});var Zx,Qx,Hh,jh=k(()=>{"use strict";Ee();Ge();Zx=n=>{if(n[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(n[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(n[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(n[0].dims[2]!==n[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Qx=n=>{let e=n[0].dims,r=n[0].dims[2],t=W.size(e)/4,o=n[0].dataType,i=ee("input",o,e,4),s=ee("bias",o,[r],4),a=ee("residual",o,e,4),u=ye("output",o,e,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:e,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(t/64)}}),getShaderSource:d=>`
  const channels = ${r}u / 4;
  ${d.declareVariables(i,s,a,u)}

  ${d.mainStart()}
    ${d.guardAgainstOutOfBoundsWorkgroupSizes(t)}
    let value = ${i.getByOffset("global_idx")}
      + ${s.getByOffset("global_idx % channels")} + ${a.getByOffset("global_idx")};
    ${u.setByOffset("global_idx","value")}
  }`}},Hh=n=>{Zx(n.inputs),n.compute(Qx(n.inputs))}});var ew,We,qh,Kh,Yh,Xh,Jh,Zh,Qh,em,tm,Ds,tw,rm,nm,om,im,Pi,am,Di,sm,um,lm,cm,dm,fm,pm,hm,mm,gm,bm,ym,vm,xm,wm,Tm,$m,ks=k(()=>{"use strict";dt();Ee();ot();Ge();ew=(n,e,r,t,o,i)=>{let s=Math.ceil(e/4),a="";typeof o=="string"?a=`${o}(a)`:a=o("a");let u=ee("inputData",r,[s],4),l=ye("outputData",t,[s],4);return`
  ${n.declareVariables(u,l)}

  ${i??""}

  ${n.mainStart()}
    ${n.guardAgainstOutOfBoundsWorkgroupSizes(s)}

    let a = ${u.getByOffset("global_idx")};
    ${l.setByOffset("global_idx",a)}
  }`},We=(n,e,r,t,o,i=n.dataType)=>({name:e,shaderCache:{hint:o},getShaderSource:s=>ew(s,W.size(n.dims),n.dataType,i,r,t),getRunData:s=>({outputs:[{dims:n.dims,dataType:i}],dispatchGroup:{x:Math.ceil(W.size(s[0].dims)/64/4)}})}),qh=n=>{n.compute(We(n.inputs[0],"Abs","abs"))},Kh=n=>{n.compute(We(n.inputs[0],"Acos","acos"))},Yh=n=>{n.compute(We(n.inputs[0],"Acosh","acosh"))},Xh=n=>{n.compute(We(n.inputs[0],"Asin","asin"))},Jh=n=>{n.compute(We(n.inputs[0],"Asinh","asinh"))},Zh=n=>{n.compute(We(n.inputs[0],"Atan","atan"))},Qh=n=>{n.compute(We(n.inputs[0],"Atanh","atanh"))},em=n=>me(n),tm=(n,e)=>{let r;switch(e.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${e.to}`)}n.compute(We(n.inputs[0],"Cast",r,void 0,e.cacheKey,e.to))},Ds=(n,e)=>{let r=it(n.inputs[0].dataType);n.compute(We(n.inputs[0],"Clip",t=>`clamp(${t}, clip_min_, clip_max_)`,`
    const clip_min_: vec4<${r}> = vec4(${r}(${e.min}));
    const clip_max_: vec4<${r}> = vec4(${r}(${e.max}));
`,e.cacheKey),{inputs:[0]})},tw=n=>{let e=n.length>=2?n[1].getFloat32Array()[0]:Oi,r=n.length>=3?n[2].getFloat32Array()[0]:Ei;return me({min:e,max:r})},rm=n=>{let e=tw(n.inputs);Ds(n,e)},nm=n=>{n.compute(We(n.inputs[0],"Ceil","ceil"))},om=n=>{n.compute(We(n.inputs[0],"Cos","cos"))},im=n=>{n.compute(We(n.inputs[0],"Cosh","cosh"))},Pi=n=>me(n),am=(n,e)=>{n.compute(We(n.inputs[0],"Elu",r=>`elu_vf32(${r})`,`
  const elu_alpha_: f32 = f32(${e.alpha});

  fn elu_f32(a: f32) -> f32 {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,e.cacheKey))},Di=(n,e="f32")=>`
const r0: ${e} = 0.3275911;
const r1: ${e} = 0.254829592;
const r2: ${e} = -0.284496736;
const r3: ${e} = 1.421413741;
const r4: ${e} = -1.453152027;
const r5: ${e} = 1.061405429;

fn erf_vf32(v: ${n}) -> ${n} {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,sm=n=>{let e=it(n.inputs[0].dataType);n.compute(We(n.inputs[0],"Erf",r=>`erf_vf32(${r})`,Di(`vec4<${e}>`,e)))},um=n=>{n.compute(We(n.inputs[0],"Exp","exp"))},lm=n=>{n.compute(We(n.inputs[0],"Floor","floor"))},cm=n=>{let e=it(n.inputs[0].dataType);n.compute(We(n.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,Di(`vec4<${e}>`,e)))},dm=(n,e)=>{n.compute(We(n.inputs[0],"LeakyRelu",r=>`select(leaky_relu_alpha_ * ${r}, ${r}, ${r} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${e.alpha});`,e.cacheKey))},fm=n=>{n.compute(We(n.inputs[0],"Not",e=>`!${e}`))},pm=n=>{n.compute(We(n.inputs[0],"Neg",e=>`-${e}`))},hm=n=>{n.compute(We(n.inputs[0],"Reciprocal",e=>`1.0/${e}`))},mm=n=>{n.compute(We(n.inputs[0],"Relu",e=>`select(vec4<f32>(0.0), ${e}, ${e} > vec4<f32>(0.0))`))},gm=n=>{n.compute(We(n.inputs[0],"Sigmoid",e=>`(1.0 / (1.0 + exp(-${e})))`))},bm=n=>{n.compute(We(n.inputs[0],"Sin","sin"))},ym=n=>{n.compute(We(n.inputs[0],"Sinh","sinh"))},vm=n=>{n.compute(We(n.inputs[0],"Sqrt","sqrt"))},xm=n=>{n.compute(We(n.inputs[0],"Tan","tan"))},wm=n=>{n.compute(We(n.inputs[0],"Tanh","tanh"))},Tm=(n,e)=>(n.compute(We(n.inputs[0],"ThresholdedRelu",r=>`select(vec4<f32>(0.0), ${r}, ${r} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${e.alpha});`,e.cacheKey)),0),$m=n=>{n.compute(We(n.inputs[0],"Log","log"))}});var nw,ow,Im,Sm=k(()=>{"use strict";Ee();Ge();ks();nw=n=>{if(n[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(n[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(n[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(n[0].dims[2]!==n[1].dims[0])throw new Error("last dimension of input and bias are not the same")},ow=n=>{let e=n[0].dims.slice();e[2]=e[2]/2;let r=ee("input",n[0].dataType,n[0].dims,4),t=ee("bias",n[0].dataType,[n[0].dims[2]],4),o=ye("output",n[0].dataType,e,4),i=W.size(e)/4;return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:e,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:a=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${n[0].dims[2]/4/2}u;

  ${a.declareVariables(r,t,o)}

  ${Di("vec4f")}

  ${a.mainStart()}
    ${a.guardAgainstOutOfBoundsWorkgroupSizes(i)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${o.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},Im=n=>{nw(n.inputs),n.compute(ow(n.inputs))}});var iw,aw,lr,_m,Am,Om,Em,Cm,Pm,Dm,km,Bm,Rm,Mm=k(()=>{"use strict";dt();Ee();Ge();iw=(n,e,r,t,o,i,s,a,u,l,d)=>{let p=W.size(t),h=Math.ceil(p/4),g,y;typeof s=="string"?g=y=(N,F)=>`${s}((${N}),(${F}))`:typeof s=="function"?g=y=s:(g=s.scalar,y=s.vector);let b="",w=ye("outputData",l,t,4),I=ee("aData",a,e,4),O=ee("bData",u,r,4);if(i){let N=F=>{let R=W.computeStrides(F),V=[];for(let K=F.length-1;K>=0;K--){let J=w.indicesGet("outputIndices",K+t.length-F.length);V.push(`${R[K]}u * (${J} % ${F[K]}u)`)}return V.length>0?V.join("+"):"0u"};b=`
          fn calcOffsetA(outputIndices: ${w.type.indices}) -> u32 {
            return ${N(e)};
          }

          fn calcOffsetB(outputIndices: ${w.type.indices}) -> u32 {
            return ${N(r)};
          }
        `}let E;if(o)if(i){let N=W.size(e)===1,F=W.size(r)===1;N||F?E=w.setByOffset("global_idx",y(N?`${I.type.value}(${I.getByOffset("0")}.x)`:I.getByOffset("global_idx"),F?`${O.type.value}(${O.getByOffset("0")}.x)`:O.getByOffset("global_idx"))):E=`
            let outputIndices = ${w.offsetToIndices("global_idx * 4u")};
            let offsetA = calcOffsetA(outputIndices);
            let offsetB = calcOffsetB(outputIndices);
            ${w.setByOffset("global_idx",y(I.getByOffset("offsetA / 4u"),O.getByOffset("offsetB / 4u")))}
          `}else E=w.setByOffset("global_idx",y(I.getByOffset("global_idx"),O.getByOffset("global_idx")));else{if(!i)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let N=(F,R,V="")=>{let K=`aData[indexA${R}][componentA${R}]`,J=`bData[indexB${R}][componentB${R}]`;return`
            let outputIndices${R} = ${w.offsetToIndices(`global_idx * 4u + ${R}u`)};
            let offsetA${R} = calcOffsetA(outputIndices${R});
            let offsetB${R} = calcOffsetB(outputIndices${R});
            let indexA${R} = offsetA${R} / 4u;
            let indexB${R} = offsetB${R} / 4u;
            let componentA${R} = offsetA${R} % 4u;
            let componentB${R} = offsetB${R} % 4u;
            ${F}[${R}] = ${V}(${g(K,J)});
          `};l===9?E=`
            var data = vec4<u32>(0);
            ${N("data",0,"u32")}
            ${N("data",1,"u32")}
            ${N("data",2,"u32")}
            ${N("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:E=`
            ${N("outputData[global_idx]",0)}
            ${N("outputData[global_idx]",1)}
            ${N("outputData[global_idx]",2)}
            ${N("outputData[global_idx]",3)}
          `}return`
        ${n.declareVariables(I,O,w)}

        ${d??""}
        ${b}

        ${n.mainStart()}
        ${n.guardAgainstOutOfBoundsWorkgroupSizes(h)}
        ${E}
      }`},aw=(n,e,r,t,o,i,s=r.dataType)=>{let a=!W.areEqual(r.dims,t.dims),u=r.dims,l=W.size(r.dims),d=!1;if(a){let p=ar.calcShape(r.dims,t.dims,!1);if(!p)throw new Error("Can't perform binary op on the given tensors");u=p,l=W.size(u);let h=W.size(r.dims)===1,g=W.size(t.dims)===1,y=1;for(let b=1;b<u.length;b++){let w=r.dims[r.dims.length-b]??1,I=t.dims[t.dims.length-b]??1;if(w===I)y*=w;else break}(y%4===0||h||g)&&(d=!0)}else d=!0;return{name:n,shaderCache:{hint:e},getShaderSource:p=>iw(p,r.dims,t.dims,u,d,a,o,r.dataType,t.dataType,s,i),getRunData:()=>({outputs:[{dims:u,dataType:s}],dispatchGroup:{x:Math.ceil(l/64/4)}})}},lr=(n,e,r,t,o,i)=>{n.compute(aw(e,o??"",n.inputs[0],n.inputs[1],r,t,i))},_m=n=>{lr(n,"Add",(e,r)=>`${e}+${r}`)},Am=n=>{lr(n,"Div",(e,r)=>`${e}/${r}`)},Om=n=>{lr(n,"Equal",{scalar:(e,r)=>`u32(${e}==${r})`,vector:(e,r)=>`vec4<u32>(${e}==${r})`},void 0,void 0,9)},Em=n=>{lr(n,"Mul",(e,r)=>`${e}*${r}`)},Cm=n=>{let e=ee("input",n.inputs[0].dataType,n.inputs[0].dims).type.value;lr(n,"Pow",{scalar:(t,o)=>`pow_custom(${t},${o})`,vector:(t,o)=>`pow_vector_custom(${t},${o})`},`
    fn pow_custom(a : ${e}, b : ${e}) -> ${e} {
      if (b == ${e}(0.0)) {
        return ${e}(1.0);
      } else if (a < ${e}(0.0) && f32(b) != floor(f32(b))) {
        return ${e}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${e}(1.0), round(f32(abs(b) % ${e}(2.0))) != 1.0) * ${e}(${e==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${e}>, b : vec4<${e}>) -> vec4<${e}> {
      // TODO: implement vectorized pow
      return vec4<${e}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},Pm=n=>{lr(n,"Sub",(e,r)=>`${e}-${r}`)},Dm=n=>{lr(n,"Greater",{scalar:(e,r)=>`u32(${e}>${r})`,vector:(e,r)=>`vec4<u32>(${e}>${r})`},void 0,void 0,9)},km=n=>{lr(n,"Less",{scalar:(e,r)=>`u32(${e}<${r})`,vector:(e,r)=>`vec4<u32>(${e}<${r})`},void 0,void 0,9)},Bm=n=>{lr(n,"GreaterOrEqual",{scalar:(e,r)=>`u32(${e}>=${r})`,vector:(e,r)=>`vec4<u32>(${e}>=${r})`},void 0,void 0,9)},Rm=n=>{lr(n,"LessOrEqual",{scalar:(e,r)=>`u32(${e}<=${r})`,vector:(e,r)=>`vec4<u32>(${e}<=${r})`},void 0,void 0,9)}});var uw,lw,cw,dw,Lm,Nm,Fm=k(()=>{"use strict";Ee();ot();Ge();uw=n=>{if(!n||n.length<1)throw new Error("too few inputs");let e=n[0].dataType,r=n[0].dims.length;for(let t of n){if(t.dataType!==e)throw new Error("input tensors should be one type");if(t.dims.length!==r)throw new Error("input tensors should have the same shape")}},lw=n=>`
  fn calculateInputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${n}u; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${n}u;
  }`,cw=(n,e)=>{let r=n.length,t=[];for(let o=0;o<r;++o){let i=e.setByOffset("global_idx",n[o].getByIndices("indices"));r===1?t.push(i):o===0?t.push(`if (inputIndex == ${o}u) { ${i} }`):o===r-1?t.push(`else { ${i} }`):t.push(`else if (inputIndex == ${o}) { ${i} }`)}return t.join(`
`)},dw=(n,e)=>{let r=n[0].dims.slice();if(e>=r.length||e<-1*r.length)throw new Error("axis specified for concat doesn't match input dimensionality");let t=e<0?r.length+e:e,o=r.slice(0);for(let g=1;g<n.length;g++){let y=n[g].dims.slice();for(let b=0;b<r.length;b++)if(b===t)o[t]+=y[b];else if(r[b]!==y[b])throw new Error("non concat dimensions must match")}let i=W.size(o),s=new Array(n.length),a=new Array(n.length),u=n[0].dataType,l=0;for(let g=0;g<n.length;++g)l+=n[g].dims[t],s[g]=l,a[g]=ee(`input${g}`,u,n[g].dims);let d=ye("output",u,o),p=d.indicesGet("indices",t),h=g=>`
  ${g.declareVariables(...a,d)}

  const sizeInConcatAxis = array<u32, ${s.length}>(${s.map(y=>`${y}u`).join(",")});
  ${lw(s.length)}

  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes(i)}

    var indices = ${d.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${p});
    if (inputIndex != 0u) {
      ${p} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${cw(a,d)}
  }`;return{name:"Concat",shaderCache:{hint:`${e}`},getRunData:()=>({outputs:[{dims:o,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:h}},Lm=(n,e)=>{uw(n.inputs),n.compute(dw(n.inputs,e.axis))},Nm=n=>me({axis:n.axis})});var ft,ki,Bi,Ri=k(()=>{"use strict";ft=(n,e)=>{switch(n){case 1:return e;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${n}-component is not supported.`)}},ki=(n,e=!1,r=!1,t=3)=>"",Bi=(n,e)=>`
      ${n?"value = value + getBiasByOutputCoords(coords);":""}
      ${e?"value = activation(value, coords);":""}
      `});var Mi,Bs=k(()=>{"use strict";Mi=`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));
}
`});var Li,Ni,so=k(()=>{"use strict";Ee();Li=n=>{switch(n.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${n.clipMin});const clip_max_=f32(${n.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},Ni=n=>{let e=n?.activation||"";if(e==="Clip"){let[r,t]=n?.activation_params||[Oi,Ei];return{activation:e,clipMax:t,clipMin:r,activationCacheKey:`${e}:${r},${t}`}}return{activation:e,activationCacheKey:e}}});var fw,pw,uo,zm,hw,lo,mw,Fi,co=k(()=>{"use strict";Ee();Ge();so();Ri();fw=(n,e)=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${e?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${e?", batchIndices":""});
        `,pw=(n,e)=>n?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${e===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,uo=(n,e,r="f32",t,o=!1,i=32,s=!1,a=32)=>{let u=e[1]*n[1],l=e[0]*n[0],d=o?u:i,p=o?i:u,h=d/e[0],g=i/e[1];if(!((o&&h===4&&n[1]===4||!o&&(h===3||h===4))&&d%e[0]===0&&i%e[1]===0&&n[0]===4))throw new Error(`If transposeA ${o} is true, innerElementSize ${h} and workPerThread[1] ${n[1]} must be 4.
      Otherwise, innerElementSize ${h} must be 3 or 4.
  tileAWidth ${d} must be divisible by workgroupSize[0]${e[0]}. tileInner ${i} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${n[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${h}<${r}>, ${d/h}>, ${p}>;
var<workgroup> mm_Bsub: array<array<vec4<${r}>, ${l/n[0]}>, ${i}>;

const rowPerThread = ${n[1]};
const colPerThread = ${n[0]};
const innerElementSize = ${h};
const tileInner = ${i};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${s?"0":"i32(globalId.z)"};
  ${t?`let batchIndices = ${t.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${u};

  let numTiles = ${s?`${Math.ceil(a/i)}`:"(dimInner - 1) / tileInner + 1"};
  var kStart = ${s?`i32(globalId.z) * ${a}`:"0"};

  var acc: array<vec4<${r}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${g};
  for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${fw(o,t)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${g}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${t?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${h===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${pw(o,h)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},zm=(n,e)=>n?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${e?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${e?", batchIndices":""});
            `,hw=n=>n?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",lo=(n,e,r="f32",t,o=!1,i=32,s=!1,a=32,u=!1)=>{let l=n[1]*e[1],d=n[0]*e[0],p=o?l:i,h=o?i:l;if(!(h%e[1]===0&&p%e[0]===0&&i%e[1]===0))throw new Error(`tileAHight ${h} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${p} must be divisible by workgroupSize[0]${e[0]}, tileInner ${i} must be divisible by workgroupSize[1]${e[1]}`);let g=h/e[1],y=p/e[0],b=i/e[1],w=u?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${l};
    let globalColStart = i32(workgroupId.x) * ${d};

    // Loop over shared dimension.
    for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${e[1]}) {
        for (var inputCol = localCol; inputCol < ${p}; inputCol = inputCol + ${e[0]}) {
          ${zm(o,t)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${i}; inputRow = inputRow + ${e[1]}) {
            for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${e[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${t?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${r}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${o?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${e[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${e[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${l};

let tileRowA = i32(localId.y) * ${g};
let tileColA = i32(localId.x) * ${y};
let tileRowB = i32(localId.y) * ${b};
// Loop over shared dimension.
for (var t = 0; t < numTiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${g}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${y}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${zm(o,t)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${b}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${t?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${r}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${hw(o)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${r}, ${p}>, ${h}>;
  var<workgroup> mm_Bsub : array<array<${r}, ${d}>, ${i}>;
  const rowPerThread = ${n[1]};
  const colPerThread = ${n[0]};
  const tileInner = ${i};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${s?"0":"i32(globalId.z)"};
    ${t?`let batchIndices = ${t.offsetToIndices("u32(batch)")};`:""}
    let numTiles = ${s?`${Math.ceil(a/i)}`:"(dimInner - 1) / tileInner + 1"};
    var kStart = ${s?`i32(globalId.z) * ${a}`:"0"};

    var acc : array<array<${r}, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${w}
  }
`},mw=(n,e,r,t,o,i=!1)=>{let s=o[0],a=o[1],u=o[2],l=t[0],d=t[1],p=t[2],h=t[3],g=Es(s,u),y=Es(a,u),b=it(t[0].type.tensor),w=()=>{let E=d.rank,N=l.rank,F=`var aIndices: ${d.type.indices};`;for(let R=E-2-1,V=N-1;R>=0;R--,V--)F+=`
aIndices[${R}] = ${N>1?`batchIndices[${V}]`:"batchIndices"};`;return g.forEach(R=>{F+=`
aIndices[${R}] = 0;`}),F+=`
aIndices[${E-2}] = u32(row);
                   aIndices[${E-1}] = u32(colIn);`,F},I=()=>{let E=p.rank,N=l.rank,F=`var bIndices: ${p.type.indices};`;for(let R=E-2-1,V=N-1;R>=0;R--,V--)F+=`
bIndices[${R}] = ${N>1?`batchIndices[${V}]`:"batchIndices"};`;return y.forEach(R=>{F+=`
bIndices[${R}] = 0;`}),F+=`
bIndices[${E-2}] = u32(row);
                   bIndices[${E-1}] = u32(colIn);`,F};return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${l.type.indices}) -> ${ft(n,b)} {
      var value = ${ft(n,b)}(0.0);
      let col = colIn * ${n};
      if(row < dimAOuter && col < dimInner)
      {
        ${w()}
        value = ${d.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${l.type.indices}) -> ${ft(n,b)} {
      var value = ${ft(n,b)}(0.0);
      let col = colIn * ${n};
      if(row < dimInner && col < dimBOuter)
      {
        ${I()}
        value = ${p.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${ft(n,b)}) {
      let col = colIn * ${n};
      if (row < dimAOuter && col < dimBOuter) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${e?`value = value + ${i?"bias[colIn]":`${ft(n,b)}(bias[row])`};`:""}
        ${r}
        ${h.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},Fi=(n,e,r,t,o=!1)=>{let i=n[0].dims,s=n[1].dims,a=i.slice(0,-2),u=s.slice(0,-2),l=t?t.slice(0,-2):r.slice(0,-2),d=ee("batchDims",n[0].dataType,l),p=[d],h=[a,u,l],g=W.size(l),y=i[i.length-2],b=i[i.length-1],w=s[s.length-1],I=b%4===0&&w%4===0,{activationFunction:O,applyActivation:E}=Li(e),N=y<=8?[4,1,1]:[4,4,1],F=[8,8,1],R=[Math.ceil(w/F[0]/N[0]),Math.ceil(y/F[1]/N[1]),Math.ceil(g/F[2]/N[2])],V=it(n[0].dataType),K=I?4:1,J=ee("a",n[0].dataType,[...a,y,b/K],K),ge=ee("b",n[1].dataType,[...u,b,w/K],K),P=ye("result",n[0].dataType,[g,y,w/K],K);p.push(J),p.push(ge),p.push(P);let oe=[J,ge],Ke=n.length>2,te=mw(K,Ke,E,p,h,o);if(Ke){let mt=o?K:1;oe.push(ee("bias",n[2].dataType,n[2].dims,mt))}let Z=mt=>`
  const dimAOuter: i32 = ${y};
  const dimBOuter: i32 = ${w};
  const dimInner: i32 = ${b};
  ${mt.declareVariables(...oe,P)}
  ${te}
  ${O}
  ${I?uo(N,F,V,d):lo(N,F,V,d)}
                   ${d.impl()}`;return{name:"MatMul",shaderCache:{hint:e.activationCacheKey},getRunData:()=>({outputs:[{dims:r,dataType:n[0].dataType}],dispatchGroup:{x:R[0],y:R[1],z:R[2]}}),getShaderSource:Z}}});var gw,Gm,Wm=k(()=>{"use strict";Ar();Ee();Ge();Ri();Bs();co();gw=(n,e,r,t,o=!1,i,s=!1,a=4,u=4,l=4,d="f32")=>{let p=ge=>{switch(ge){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${d}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${ge} is not supported.`)}},h=ge=>{switch(ge){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${ge} is not supported.`)}},g=n?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,y=n?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,b=n?"xShape[1]":"xShape[2]",w=n?"xShape[2]":"xShape[3]",I=n?"row":"col",O=n?"col":"row",E=`
    let inChannels = wShape[2];
    let outWidth = ${n?"outShape[2]":"outShape[3]"};
    let outRow = ${I} / outWidth;
    let outCol = ${I} % outWidth;

    let WRow = ${O} / (filterDims[1] * inChannels);
    let WCol = ${O} / inChannels % filterDims[1];
    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];
    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];
    let xCh = ${O} % inChannels;
    var resData = ${ft(a,d)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${b} && xCol >= 0 && xCol < ${w}) {
      ${g}
      let xIndex = getIndexFromCoords4D(coord, xShape);
      ${p(a)}
    }
    return resData;`,N=n?e&&t?`
    let col = colIn * ${a};
    ${E}`:`
    let col = colIn * ${a};
    if (row < dimAOuter && col < dimInner) {
      ${E}
    }
    return ${ft(a,d)}(0.0);`:t&&r?`
    let col = colIn * ${a};
    ${E}`:`
    let col = colIn * ${a};
    if (row < dimInner && col < dimBOuter) {
      ${E}
    }
    return ${ft(a,d)}(0.0);`,F=`${h(u)}`,R=ft(l,d),V=n?ft(a,d):ft(u,d),K=n?ft(u,d):ft(a,d);return`
    ${ki(i,s,l===4,4)}
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${V} {
      ${n?N:F}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${K} {
      ${n?F:N}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${R}) {
      let col = colIn * ${l};
      if (row < dimAOuter && col < dimBOuter)
      {
      var value = valueIn;
      let outWidth = ${n?"outShape[2]":"outShape[3]"};
      ${y}
      ${Bi(o,i)}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},Gm=(n,e,r,t,o,i,s,a)=>{let u=e.format==="NHWC",l=u?n[0].dims[3]:n[0].dims[1],d=r[0],p=u?r[2]:r[3],h=u?r[1]:r[2],g=u?r[3]:r[1],y=u&&(l%4===0||l%3===0)&&g%4===0,b=u?g:p*h,w=u?p*h:g,I=[8,8,1],O=t<=8?[4,1,1]:[4,4,1],E=[Math.ceil(b/I[0]/O[0]),Math.ceil(w/I[1]/O[1]),Math.ceil(d/I[2]/O[2])];Je("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${E}`);let N=y?u&&l%4!==0?3:4:O[0],F=I[1]*O[1],R=I[0]*O[0],V=Math.max(I[0]*N,I[1]),K=t%F===0,J=o%R===0,ge=i%V===0,P=y?[N,4,4]:[1,1,1],oe=it(n[0].dataType),Ke=[`@group(0) @binding(0) var<storage, read> x: array<${y&&N===4?`vec4<${oe}>`:oe}>;`,`@group(0) @binding(1) var<storage, read> w: array<${y?`vec4<${oe}>`:oe}>;`],te=`
      fn setOutputAtIndex(flatIndex : i32, value : ${y?`vec4<${oe}>`:oe}) {
        result[flatIndex] = ${y?`vec4<${oe}>`:oe}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${y?`vec4<${oe}>`:oe}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${y?"/ 4":""}, value);
      }`;return s&&(Ke.push(`@group(0) @binding(2) var<storage, read> bias: array<${y?`vec4<${oe}>`:oe}>;`),te+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${y?`vec4<${oe}>`:oe} {
          return bias[coords.${u?"w":"y"}${y?"/ 4":""}];
        }`),{name:"Conv2DMatMul",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:n[0].dataType}],dispatchGroup:{x:E[0],y:E[1],z:E[2]}}),getShaderSource:()=>`
        ${Mi}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${Ke.join("")}
        @group(0) @binding(${Ke.length}) var<storage, read_write> result: array<${y?`vec4<${oe}>`:oe}>;
        //@group(0) @binding(${Ke.length+1}) var<uniform> uniforms: Uniforms;

        const xShape : vec4<i32> = vec4<i32>(${n[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${n[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${W.computeStrides(r).slice(0,3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${e.kernelShape[0]}, ${e.kernelShape[1]});
        const pad : vec2<i32> = vec2<i32>(${e.pads[0]}, ${e.pads[1]});
        const stride : vec2<i32> = vec2<i32>(${e.strides[0]}, ${e.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${e.dilations[0]}, ${e.dilations[1]});
        const dimAOuter : i32 = ${t};
        const dimBOuter : i32 = ${o};
        const dimInner : i32 = ${i};
        ${te}
        ${gw(u,K,J,ge,s,void 0,!1,P[0],P[1],P[2],oe)}
            ${y?uo(O,I,oe,void 0,!u,V):lo(O,I,oe,void 0,!u,V,!1,void 0,a)}`}}});var Rs,Vm=k(()=>{"use strict";Ee();Ge();Ls();so();Rs=(n,e,r)=>{let t=n.length>2,o=t?"value += b[output_channel];":"",i=n[0].dims,s=n[1].dims,a=s[0]/e.group,{activationFunction:u,applyActivation:l}=Li(e),d=e.format==="NHWC",p=Ms(i,s,e.dilations,e.pads,e.strides,d),h=W.size(p),g=ye("output",n[0].dataType,p),y=ee("x",n[0].dataType,i),b=ee("w",n[1].dataType,s),w=[y,b];t&&w.push(ee("b",n[2].dataType,n[2].dims));let I=O=>`
  const strides: vec2<u32> = vec2(${e.strides[0]}u, ${e.strides[1]}u);
  const pads: vec2<u32> = vec2(${e.pads[0]}u, ${e.pads[1]}u);

  ${O.declareVariables(...w,g)}

  ${u}

  ${O.mainStart()}
    ${O.guardAgainstOutOfBoundsWorkgroupSizes(h)}

    let outputIndices = ${g.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${d?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${d?1:2}], outputIndices[${d?2:3}]) * strides - pads;
    let group_id: u32 = output_channel / ${a}u;

    var value: ${g.type.value} = ${g.type.value}(0);
    for (var wInChannel: u32 = 0u; wInChannel < ${s[1]}u; wInChannel++) {
      let input_channel = group_id * ${s[1]}u + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < ${s[2]}u; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * ${e.dilations[0]}u;

        if (xHeight < 0u || xHeight >= ${i[d?1:2]}u) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < ${s[3]}u; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * ${e.dilations[1]}u;
          if (xWidth < 0u || xWidth >= ${i[d?2:3]}u) {
            continue;
          }

          let xVal = ${d?y.get("batch","xHeight","xWidth","input_channel"):y.get("batch","input_channel","xHeight","xWidth")};
          let wVal = ${b.get("output_channel","wInChannel","wHeight","wWidth")};
          value += xVal*wVal;
        }
      }
    }
    ${o}
    ${l}
    ${g.setByOffset("global_idx","value")}
  }`;return{name:"GroupedConv",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:r?r(p):p,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)}}),getShaderSource:I}}});var bw,Um,yw,vw,Tn,Hm,jm,zi=k(()=>{"use strict";Ee();ot();Ge();bw=n=>{if(!n||n.length!==1)throw new Error("Transpose requires 1 input.")},Um=(n,e)=>e&&e.length!==n?[...new Array(n).keys()].reverse():e,yw=(n,e)=>W.sortBasedOnPerm(n,Um(n.length,e)),vw=(n,e,r,t)=>{let o=[];o.push(`fn perm(i: ${t.type.indices}) -> ${r.type.indices} {
    var a: ${r.type.indices};`);for(let i=0;i<e;++i)o.push(r.indicesSet("a",n[i],`i[${i}]`));return o.push("return a;}"),o.join(`
`)},Tn=(n,e,r)=>{let t=Um(e,r),o=ye("output",n,r&&r.length||e),i=ee("a",n,e),s=a=>`
  ${a.registerUniform("output_size","u32").declareVariables(i,o)}

  ${vw(t,e,i,o)}

  ${a.mainStart()}
    ${a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${o.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${o.setByOffset("global_idx",i.getByIndices("aIndices"))}
  }`;return{name:"Transpose",shaderCache:{hint:`${r}`,inputDependencies:["rank"]},getRunData:a=>{let u=yw(a[0].dims,t),l=W.size(u);return{outputs:[{dims:u,dataType:a[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:[{type:"uint32",data:l},...Os(a[0].dims),...Os(u)]}},getShaderSource:s}},Hm=(n,e)=>{bw(n.inputs),n.compute(Tn(n.inputs[0].dataType,n.inputs[0].dims.length,e.perm))},jm=n=>me({perm:n.perm})});var Ms,qm,xw,Km,Ym,ww,Tw,Xm,Ls=k(()=>{"use strict";Ee();ot();Wm();co();Vm();so();zi();Ms=(n,e,r,t,o,i)=>{let s=n[0],a=n.slice(i?1:2,i?3:4),u=a.length,l=e[0],p=e.slice(2).map((y,b)=>y+(y-1)*(r[b]-1)),g=a.map((y,b)=>y+t[b]+t[b+u]).map((y,b)=>Math.floor((y-p[b]+o[b])/o[b]));return g.splice(0,0,s),g.splice(i?3:1,0,l),g},qm=[2,3,1,0],xw=(n,e)=>{if(!n||n.length!==2&&n.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(n[0].dims.length!==4&&n[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(n[0].dims.length!==n[1].dims.length)throw new Error("filter does not have same dimension as input");let r=n[0].dims[e.format==="NHWC"?n[0].dims.length-1:1],t=n[1].dims[1]*e.group;if(r!==t)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(n.length===3&&(n[2].dims.length!==1||n[1].dims[0]!==n[2].dims[0]))throw new Error("invalid bias");let o=n[0].dims.length-2;if(e.dilations.length!==o)throw new Error(`dilations should be ${o}D`);if(e.strides.length!==o)throw new Error(`strides should be ${o}D`);if(e.pads.length!==o*2)throw new Error(`pads should be ${o*2}D`);if(e.kernelShape.length!==0&&e.kernelShape.length!==n[1].dims.length-2)throw new Error("invalid kernel shape")},Km=(n,e)=>{let r=n.kernelShape.slice();for(let i=2;i<e[1].dims.length;++i)r[i-2]===0&&(r[i-2]=e[1].dims[i]);let t=n.pads.slice();Xr.adjustPadsBasedOnAutoPad(e[0].dims,n.strides,n.dilations,r,t,n.format==="NHWC",n.autoPad);let o=Object.assign({},n);return Object.assign(o,{kernelShape:r,pads:t,cacheKey:n.cacheKey}),o},Ym=n=>{let e=Ni(n),r=n.format,t=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][n.auto_pad],o=n.dilations,i=n.group,s=n.kernel_shape,a=n.pads,u=n.strides,l=n.w_is_const();return me({autoPad:t,format:r,dilations:o,group:i,kernelShape:s,pads:a,strides:u,wIsConst:l,...e})},ww=(n,e,r)=>{let t=Km(r,e);if(r.group!==1){n.compute(Rs(e,t));return}let o=r.format==="NHWC",i=e.length===3,s=e[0].dims[o?1:2],a=e[0].dims[o?2:3],u=e[0].dims[o?3:1],l=e[1].dims[2],d=e[1].dims[3],p=Ms(e[0].dims,e[1].dims,r.dilations,t.pads,r.strides,o),h=p[o?1:2],g=p[o?2:3],y=p[o?3:1],b=o&&l===s&&d===a&&r.pads[0]===0&&r.pads[1]===0;if(b||l===1&&d===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let R=p[0],V,K,J,ge=[];if(o){let P=n.kernelCustomData.wT??n.compute(Tn(e[1].dataType,e[1].dims.length,qm),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!n.kernelCustomData.wT&&(n.kernelCustomData.wT=P),b){let oe=s*a*u;V=e[0].reshape([1,R,oe]),K=P.reshape([1,oe,y]),J=[1,R,y]}else V=e[0].reshape([R,s*a,u]),K=P.reshape([1,u,y]),J=[R,h*g,y];ge.push(V),ge.push(K)}else V=e[0].reshape([R,u,s*a]),K=e[1].reshape([1,y,u]),J=[R,y,h*g],ge.push(K),ge.push(V);i&&ge.push(e[2]),n.compute(Fi(ge,t,p,J,o),{inputs:ge});return}let w=!0,I=n.kernelCustomData.wT??n.compute(Tn(e[1].dataType,e[1].dims.length,qm),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!n.kernelCustomData.wT&&(n.kernelCustomData.wT=I);let O=[e[0],I];i&&O.push(e[2]);let E=o?h*g:y,N=o?y:h*g,F=l*d*u;n.compute(Gm(O,t,p,E,N,F,i,w),{inputs:O})},Tw=(n,e)=>{let r=e.format==="NHWC",t=[n.inputs[0].reshape(r?[n.inputs[0].dims[0],1,n.inputs[0].dims[1],n.inputs[0].dims[2]]:[n.inputs[0].dims[0],n.inputs[0].dims[1],1,n.inputs[0].dims[2]]),n.inputs[1].reshape([n.inputs[1].dims[0],n.inputs[1].dims[1],1,n.inputs[1].dims[2]])];n.inputs.length===3&&t.push(n.inputs[2]);let o=[0,e.pads[0],0,e.pads[1]],i=[1].concat(e.strides),s=[1].concat(e.dilations),a=[1].concat(e.kernelShape),u=Km({...e,pads:o,strides:i,dilations:s,kernelShape:a},t);n.compute(Rs(t,u,l=>r?[l[0],l[2],l[3]]:[]))},Xm=(n,e)=>{xw(n.inputs,e),n.inputs[0].dims.length===3?Tw(n,e):ww(n,n.inputs,e)}});var $w,Jm,Zm=k(()=>{"use strict";Ar();Ee();Ri();Bs();co();$w=(n,e=!1,r,t=!1,o=4)=>{let i=ft(o,"f32"),s=I=>{switch(I){case 1:return"return W[getIndexFromCoords4D(coord, wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${I} is not supported.`)}},a=n?`
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `,u=n?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,l=n?"outBackprop[1]":"outBackprop[2]",d=n?"outBackprop[2]":"outBackprop[3]",p=n?"row":"col",h=n?"col":"row",g=`
      let inChannels = ${n?"outBackprop[3]":"outBackprop[1]"};
      let outWidth = ${n?"outShape[2]":"outShape[3]"};
      let outRow = ${p} / outWidth;
      let outCol = ${p} % outWidth;

      let WRow = ${h} / (filterDims[1] * inChannels);
      let WCol = ${h} / inChannels % filterDims[1];
      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);
      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);
      if (xR < 0.0 || xR >= f32(${l}) || fract(xR) > 0.0) {
        return ${i}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${d}) || fract(xC) > 0.0) {
        return ${i}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${h} % inChannels;
      ${a}
      return x[getIndexFromCoords4D(coord, xShape)/${o}];`,y=n?`
      let col = colIn * ${o};
      if (row < dimAOuter && col < dimInner) {
        ${g}
      }
      return ${i}(0.0);`:`
      let col = colIn * ${o};
      if (row < dimInner && col < dimBOuter) {
        ${g}
      }
      return ${i}(0.0);`,b=`
      let col = colIn * ${o};
      let inChannels = ${n?"outBackprop[3]":"outBackprop[1]"};
      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);
      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];
      if (${n?"row < dimInner && col < dimBOuter":"row < dimInner && col < dimAOuter"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${s(o)}
      }
      return ${i}(0.0);
      `;return`
  ${ki(r,t,o===4,4)}
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${i} {
    ${n?y:b}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${i} {
    ${n?b:y}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${i}) {
    let col = colIn * ${o};
    if (row < dimAOuter && col < dimBOuter) {
      var value = valueInput;
      let outWidth = ${n?"outShape[2]":"outShape[3]"};
      ${u}
      ${Bi(e,r)}
      result[getIndexFromCoords4D(coords, outShape)/${o}] = value;
    }
  }`},Jm=(n,e,r,t,o,i,s,a)=>{let u=e.format==="NHWC",l=u?n[0].dims[3]:n[0].dims[1],d=r[0],p=u?r[2]:r[3],h=u?r[1]:r[2],g=u?r[3]:r[1],y=u?l%4===0&&g%4===0:p%4===0&&g%4===0,b=u?g:p*h,w=u?p*h:g,I=y?[8,8,1]:[b<=4||w<=4?4:16,b>4&&w<=4?4:16,1],O=y?[4,4,1]:[b<=4?1:4,b>4&&w<=4?1:4,1],E=[Math.ceil(b/I[0]/O[0]),Math.ceil(w/I[1]/O[1]),Math.ceil(d/I[2]/O[2])];Je("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${E}`);let N=y?4:1,F=Math.max(I[0]*N,I[1]),R=[`@group(0) @binding(0) var<storage, read> x: array<${y?"vec4<f32>":"f32"}>;`,"@group(0) @binding(1) var<storage, read> W: array<f32>;"],V="";return s&&(R.push(`@group(0) @binding(2) var<storage, read> bias: array<${y?"vec4<f32>":"f32"}>;`),V+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${y?"vec4<f32>":"f32"} {
          return bias[coords.${u?"w":"y"}${y?"/ 4":""}];
        }`),{name:"Conv2DTransposeMatMul",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:n[0].dataType}],dispatchGroup:{x:E[0],y:E[1],z:E[2]}}),getShaderSource:()=>`
        ${Mi}
        ${R.join(`
`)}
        @group(0) @binding(${R.length}) var<storage, read_write> result: array<${y?"vec4<f32>":"f32"}>;
        const outBackprop : vec4<i32> = vec4<i32>(${n[0].dims.join(",")});
        const xShape : vec4<i32> = vec4<i32>(${n[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${n[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${W.computeStrides(r).slice(0,3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${e.kernelShape[u?1:2]}, ${e.kernelShape[u?2:3]});
        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(
              ${e.dilations[0]<=1?0:(e.kernelShape[u?1:2]-1)*(e.dilations[0]-1)},
              ${e.dilations[1]<=1?0:(e.kernelShape[u?2:3]-1)*(e.dilations[1]-1)});
        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${e.pads[0]+e.pads[2]})/2,
                                         i32(effectiveFilterDims[1]) - 1 - (${e.pads[1]+e.pads[3]})/2);
        const strides : vec2<i32> = vec2<i32>(${e.strides[0]}, ${e.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${e.dilations[0]}, ${e.dilations[1]});
        const dimAOuter : i32 = ${t};
        const dimBOuter : i32 = ${o};
        const dimInner : i32 = ${i};
        ${V}
        ${$w(u,s,void 0,!1,N)}
        ${y?uo(O,I,"f32",void 0,!u,F):lo(O,I,"f32",void 0,!u,F,!1,void 0,a)}`}}});var Iw,Ns,Qm=k(()=>{"use strict";Ar();Ee();Ge();Iw=(n,e,r,t,o,i,s=!1,a)=>{let u=r.format==="NHWC",l=u?1:2,d=u?2:3,p=u?3:1,h=W.size(t),g=s?2:1,y=r.group,b=e[1].dims,w=b[0]/y,I=b[1],O=`
  fn setOutputAtIndex(flatIndex : u32, value : ${s?`vec4<${a}>`:a}) {
    result[flatIndex] = ${s?`vec4<${a}>`:a}(value);
  }`;o&&(O+=`
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${s?`vec4<${a}>`:a} {
      return bias[coords.${u?"w":"y"}${s?"/ 4":""}];
    }`);let E=s?4:1,N=ee("W",e[1].dataType,e[1].dims,E),F=ee("Dy",e[0].dataType,e[0].dims,E),R=[F,N];o&&R.push(ee("bias",e[2].dataType,[t[p]],E));let V=ye("result",e[0].dataType,t,E),K=`{
        let batch: u32 = ${i?"global_id.z":"workgroup_id.z"} / outShape[1];
        let r = ${i?"global_id.z":"workgroup_id.z"} % outShape[1];
        let c = ${i?"global_id.y":"workgroup_id.y"} * ${g};
        let d1: u32 = ${i?"global_id.x":"workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${a}>, ${g}>;
        for (var i = 0; i < ${g}; i++) {
          dotProd[i] = vec4<${a}>(0.0);
        }
        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {
          var dyR = (${a}(dyCorner.x) + ${a}(wR)) / ${a}(strides.x);
          let wRPerm = filterDims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${a}(outBackprop[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {
            let dyC = (${a}(dyCorner.y) + ${a}(wC)) / ${a}(strides.y);
            let dyC2 = (${a}(dyCorner.y) + 1.0 + ${a}(wC)) / ${a}(strides.y);
            let wCPerm = filterDims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${a}(outBackprop[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${a}(outBackprop[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${N.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${N.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${N.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${N.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${F.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${a}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${F.get("batch","idyR","idyC2","d2")};

                dotProd[1] = dotProd[1] + vec4<${a}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = outBackprop[${p}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${N.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${N.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${N.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${N.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${F.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${a}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${N.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${N.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${N.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${N.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${F.get("batch","idyR","idyC2","d2")};
                let tmpval = vec4<${a}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${g}; i = i + 1) {
          let value = dotProd[i] + ${o?"bias[c+i]":"0.0"};
          ${V.set("batch","r","c + i","d1","value")};
        }
      }`,J=`
          let outputIndices = ${V.offsetToIndices("global_idx")};
          let batch = ${V.indicesGet("outputIndices",0)};
          let d1 = ${V.indicesGet("outputIndices",p)};
          let r = ${V.indicesGet("outputIndices",l)};
          let c = ${V.indicesGet("outputIndices",d)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / ${I};
          let wOutChannel = d1 - groupId * ${I};
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = 0.0;
          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {
            if (wR % dilations.x != 0) {
              continue;
            }
            let dyR = (${a}(dyRCorner) + ${a}(wR)) / ${a}(strides[0]);
            let wRPerm = filterDims.x - 1 - wR / dilations.x;
            if (dyR < 0.0 || dyR >= ${a}(outBackprop[${l}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {
              if (wC % dilations.y != 0) {
                continue;
              }
              let dyC = (${a}(dyCCorner) + ${a}(wC)) / ${a}(strides.y);
              let wCPerm = filterDims.y - 1 - wC / dilations.y;
              if (dyC < 0.0 || dyC >= ${a}(outBackprop[${d}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * ${w};
              for (var d2: u32 = 0; d2 < ${w}; d2 = d2 + 1) {
                let xValue = ${u?F.get("batch","idyR","idyC","inputChannel"):F.get("batch","inputChannel","idyR","idyC")};
                let wValue = ${N.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${o?"bias[d1]":"0.0"};
          ${V.setByOffset("global_idx","value")};
        `;return`
  ${n.declareVariables(...R,V)}
  ${O}
  const outShape : vec4<u32> = vec4<u32>(${t.join(",")});
  const outBackprop : vec4<u32> = vec4<u32>(${e[0].dims.join(",")});
  const strides : vec2<u32> = vec2<u32>(${r.strides[0]}, ${r.strides[1]});
  const filterDims : vec2<u32> = vec2<u32>(${r.kernelShape[u?1:2]}, ${r.kernelShape[u?2:3]});
  const dilations : vec2<u32> = vec2<u32>(${r.dilations[0]}, ${r.dilations[1]});
  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(
          ${r.dilations[0]<=1?0:(r.kernelShape[u?1:2]-1)*(r.dilations[0]-1)},
          ${r.dilations[1]<=1?0:(r.kernelShape[u?2:3]-1)*(r.dilations[1]-1)});
  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${r.pads[0]+r.pads[2]})/2,
                                     i32(effectiveFilterDims[1]) - 1 - (${r.pads[1]+r.pads[3]})/2);
    ${n.mainStart()}
    ${n.guardAgainstOutOfBoundsWorkgroupSizes(h)};
  ${s?K:J}}`},Ns=(n,e,r)=>{let t=n.length>2,o=e.outputShape,i=W.size(o),s=[Math.ceil(i/64),1,1];Je("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${s}`);let a=it(n[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:e.cacheKey},getRunData:()=>({dispatchGroup:{x:s[0],y:s[1],z:s[2]},outputs:[{dims:r?r(o):o,dataType:n[0].dataType}]}),getShaderSource:u=>Iw(u,n,e,o,t,s[1]===1&&s[2]===1,!1,a)}}});var Sw,_w,Aw,eg,tg,Ow,Ew,Cw,Pw,rg,ng=k(()=>{"use strict";ot();Zm();Qm();so();zi();Sw=(n,e,r,t,o,i)=>(n-1)*e+r+(t-1)*o+1-i,_w=(n,e,r,t,o)=>{let i=Math.floor(n/2);e==="SAME_UPPER"?(r[t]=i,r[o]=n-i):e==="SAME_LOWER"&&(r[t]=n-i,r[o]=i)},Aw=(n,e,r,t,o,i,s,a,u,l)=>{let d=n.length-2,p=l.length===0;if(u.length===0)for(let y=0;y<d;++y)u.push(0);let h=n[0],g=e[a?3:1]*o;for(let y=0,b=n.length-d-(a?1:0);y<d;++y,++b){let w=n[b],I=p?w*s[y]:l[y],O=Sw(w,s[y],i[y],e[b],r[y],I);_w(O,t,i,y,y+d),p&&l.push(s[y]*(w-1)+u[y]+(e[b]-1)*r[y]+1-i[y]-i[y+d])}l.splice(0,0,h),l.splice(a?3:1,0,g)},eg=(n,e)=>{let r=n.kernelShape.slice();if(n.kernelShape.length===0||n.kernelShape.reduce((h,g)=>h*g,1)===0){r.length=0;for(let h=2;h<e[1].dims.length;++h)r.push(e[1].dims[h])}let t=n.format==="NHWC";r.splice(0,0,e[1].dims[0]),r.splice(t?3:1,0,e[1].dims[1]);let o=n.pads.slice(),i=n.outputShape.slice(),s=n.outputPadding.slice(),a=e[0].dims,u=n.dilations.slice();if(u.reduce((h,g)=>h+g,0)===0){let h=e[0].dims.length-2;u=new Array(h).fill(1)}let l=n.strides.slice();if(l.reduce((h,g)=>h+g,0)===0){let h=e[0].dims.length-2;l=new Array(h).fill(1)}Aw(a,r,u,n.autoPad,n.group,o,l,t,s,i);let d=Object.assign({},n),p=n.cacheKey+[r.join("n,"),o.join(","),l.join(","),s.join(","),i.join(","),u.join(",")].join("_");return Object.assign(d,{kernelShape:r,pads:o,outputPadding:s,outputShape:i,dilations:u,strides:l,cacheKey:p}),d},tg=n=>{let e=Ni(n),r=n.format,t=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof n.autoPad>"u"?0:n.autoPad],o=n.dilations,i=n.group,s=n.kernelShape,a=n.pads,u=n.strides,l=n.wIsConst(),d=n.outputPadding,p=n.outputShape;return me({autoPad:t,format:r,dilations:o,group:i,kernelShape:s,outputPadding:d,outputShape:p,pads:a,strides:u,wIsConst:l,...e})},Ow=(n,e)=>{if(!n||n.length!==2&&n.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(n[0].dims.length!==4&&n[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(n[0].dims.length!==n[1].dims.length)throw new Error("filter does not have same dimension as input");let r=n[0].dims[e.format==="NHWC"?n[0].dims.length-1:1],t=n[1].dims[0];if(r!==t)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let o=n[1].dims[1]*e.group;if(n.length===3&&(n[2].dims.length!==1||n[2].dims[0]!==o))throw new Error("invalid bias");let i=n[0].dims.length-2;if(e.dilations.reduce((d,p)=>d+p,0)>0&&e.dilations.length!==i)throw new Error(`dilations should be ${i}D`);if(e.strides.reduce((d,p)=>d+p,0)>0&&e.strides.length!==i)throw new Error(`strides should be ${i}D`);if(e.pads.reduce((d,p)=>d+p,0)>0&&e.pads.length!==i*2)throw new Error(`pads should be ${i*2}D`);if(e.outputPadding.length!==i&&e.outputPadding.length!==0)throw new Error(`output_padding should be ${i}D`);if(e.kernelShape.reduce((d,p)=>d+p,0)>0&&e.kernelShape.length!==0&&e.kernelShape.length!==n[1].dims.length-2)throw new Error("invalid kernel shape");if(e.outputShape.length!==0&&e.outputShape.length!==n[0].dims.length-2)throw new Error("invalid output shape")},Ew=[2,3,1,0],Cw=(n,e,r)=>{let t=eg(r,e),o=r.format==="NHWC",i=e.length===3;if(t.group!==1){n.compute(Ns(e,t));return}let s=t.outputShape,a=s[o?1:2],u=s[o?2:3],l=s[o?3:1],d=e[1].dims[2],p=e[1].dims[3],h=e[0].dims[o?3:1],g=o?a*u:l,y=o?l:a*u,b=d*p*h,w=!0,I=n.kernelCustomData.wT??n.compute(Tn(e[1].dataType,e[1].dims.length,Ew),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!n.kernelCustomData.wT&&(n.kernelCustomData.wT=I);let O=[e[0],I];i&&(!o&&e[2].dims.length===1?O.push(e[2].reshape([e[2].dims[0],1,1])):O.push(e[2])),n.compute(Jm(O,t,s,g,y,b,i,w),{inputs:O})},Pw=(n,e)=>{let r=e.format==="NHWC",t=[n.inputs[0].reshape(r?[n.inputs[0].dims[0],1,n.inputs[0].dims[1],n.inputs[0].dims[2]]:[n.inputs[0].dims[0],n.inputs[0].dims[1],1,n.inputs[0].dims[2]]),n.inputs[1].reshape([n.inputs[1].dims[0],n.inputs[1].dims[1],1,n.inputs[1].dims[2]])];t.length===3&&t.push(n.inputs[2]);let o=e.kernelShape;(o.length===0||o[0]===0)&&(o=[n.inputs[1].dims[2]]);let i=e.dilations;(i.length===0||i[0]===0)&&(i=[1]);let s=e.strides;(s.length===0||s[0]===0)&&(s=[1]);let a=e.pads;a.length===0&&(a=[0,0]),a=[0,a[0],0,a[1]],s=[1].concat(s),i=[1].concat(i),o=[1].concat(o);let u=eg({...e,pads:a,strides:s,dilations:i,kernelShape:o},t);n.compute(Ns(t,u,l=>r?[l[0],l[2],l[3]]:[l[0],l[1],l[3]]))},rg=(n,e)=>{Ow(n.inputs,e),n.inputs[0].dims.length===3?Pw(n,e):Cw(n,n.inputs,e)}});var Fs,Gi,og,Dw,kw,zs,Gs,Bw,ig,ag,sg=k(()=>{"use strict";Ee();ot();Ge();Fs="[a-zA-Z]|\\.\\.\\.",Gi="("+Fs+")+",og="^"+Gi+"$",Dw="("+Gi+",)*"+Gi,kw="^"+Dw+"$",zs=class{constructor(e=-1){this.symbolToIndices=new Map,this.inputIndex=e}addSymbol(e,r){let t=this.symbolToIndices.get(e);t===void 0?t=[r]:t.push(r),this.symbolToIndices.set(e,t)}},Gs=class{constructor(e,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[t,o]=r.includes("->")?r.split("->",2):[r,""];if(!t.match(RegExp(kw)))throw new Error("Invalid LHS term");if(t.split(",").forEach((a,u)=>{let l=e[u].dims.slice();if(!a.match(RegExp(og)))throw new Error("Invalid LHS term");let d=this.processTerm(a,!0,l,u);this.lhs.push(d)}),o==="")o+=[...this.symbolToInfo.entries()].filter(([a,u])=>u.count===1||a==="...").map(([a])=>a).join("");else if(!o.match(RegExp(Gi)))throw new Error("Invalid RHS");o.match(RegExp(Fs,"g"))?.forEach(a=>{if(a==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let u=this.symbolToInfo.get(a);if(u===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(u.dimValue)}}),this.rhs=this.processTerm(o,!0,this.outputDims)}addSymbol(e,r,t){let o=this.symbolToInfo.get(e);if(o!==void 0){if(o.dimValue!==r&&o.count!==1)throw new Error("Dimension mismatch");o.count++,o.inputIndices.push(t)}else o={count:1,dimValue:r,inputIndices:[t]};this.symbolToInfo.set(e,o)}processTerm(e,r,t,o=-1){let i=t.length,s=!1,a=[],u=0;if(!e.match(RegExp(og))&&!r&&e!=="")throw new Error("Invalid LHS term");let l=e.match(RegExp(Fs,"g")),d=new zs(o);return l?.forEach((p,h)=>{if(p==="..."){if(s)throw new Error("Only one ellipsis is allowed per input term");s=!0;let g=i-l.length+1;if(g<0)throw new Error("Ellipsis out of bounds");if(a=t.slice(u,u+g),this.hasEllipsis){if(this.ellipsisDims.length!==a.length||this.ellipsisDims.toString()!==a.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=a;else throw new Error("Ellipsis must be specified in the LHS");for(let y=0;y<a.length;y++){let b=String.fromCharCode("0".charCodeAt(0)+h);d.addSymbol(b,h+y),this.addSymbol(b,t[u++],o)}}else d.addSymbol(p,h),this.addSymbol(p,t[u++],o)}),d}},Bw=(n,e)=>{let r=n[0].dataType,t=new Array(n.length);for(let E=0;E<n.length;++E)t[E]=ee(`input${E}`,r,n[E].dims);let o=e.outputDims,i=W.size(o),s=ye("output",r,o),a=[],u=Array.from(e.rhs.symbolToIndices.keys()),l="var prod = 1.0;",d="var sum = 0.0;",p="sum += prod;",h=[],g=[],y=[],b=[],w=e.symbolToInfo.size===u.length;e.symbolToInfo.forEach((E,N)=>{if(u.includes(N)){let F=u.indexOf(N);e.lhs.forEach((R,V)=>{if(E.inputIndices.includes(V)){let K=R.symbolToIndices.get(N);if(K===void 0)throw new Error("Invalid symbol error");K.forEach(J=>{a.push(`${t[V].indicesSet(`input${V}Indices`,J,s.indicesGet("outputIndices",F))}`)})}})}else e.lhs.forEach((F,R)=>{let V=e.symbolToInfo.get(N);if(V===void 0)throw new Error("Invalid symbol error");if(V.inputIndices.includes(R)){let K=F.symbolToIndices.get(N);if(K===void 0)throw new Error("Invalid symbol error");K.forEach(J=>{h.push(`${t[R].indicesSet(`input${R}Indices`,J,`${N}`)}`)}),b.push(`prod *= ${t[R].getByIndices(`input${R}Indices`)};`)}}),g.push(`for(var ${N}: u32 = 0; ${N} < ${e.symbolToInfo.get(N)?.dimValue}; ${N}++) {`),y.push("}")});let I=w?[...a,`let sum = ${t.map((E,N)=>E.getByIndices(`input${N}Indices`)).join(" * ")};`]:[...a,d,...g,...h,l,...b,p,...y],O=E=>`
      ${E.declareVariables(...t,s)}

      ${E.mainStart()}
        ${E.guardAgainstOutOfBoundsWorkgroupSizes(i)}
        var outputIndices = ${s.offsetToIndices("global_idx")};
        ${t.map((N,F)=>`var input${F}Indices: ${t[F].type.indices};`).join(`
`)}
        ${I.join(`
`)};
        ${s.setByOffset("global_idx","sum")};
      }`;return{name:"Einsum",shaderCache:{hint:e.equation},getRunData:()=>({outputs:[{dims:o,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:O}},ig=(n,e)=>{let r=new Gs(n.inputs,e.equation);n.compute(Bw(n.inputs,r))},ag=n=>{let e=n.equation.replace(/\s+/g,"");return me({equation:e})}});var Rw,ug,Mw,Lw,lg,cg=k(()=>{"use strict";Ee();Ge();Rw=n=>{if(!n||n.length!==2)throw new Error("Expand requires 2 input.");let e=n[0].dims,r=Array.from(n[1].getBigInt64Array(),Number),t=r.length<e.length?0:r.length-e.length,o=e.length<r.length?0:e.length-r.length;for(;t<r.length&&o<e.length;++t,++o)if(r[t]!==e[o]&&r[t]!==1&&e[o]!==1)throw new Error("Expand requires shape to be broadcastable to input")},ug=(n,e)=>{let r=n.length-e.length,t=[];for(let o=0;o<r;++o)t.push(n[o]);for(let o=0;o<e.length;++o)t.push(e[o]===1?n[o+r]:e[o]);return t},Mw=(n,e)=>n.length>e.length?ug(n,e):ug(e,n),Lw=n=>{let e=n[0].dims,r=Array.from(n[1].getBigInt64Array(),Number),t=Mw(e,r),o=W.size(t),i=n[0].dataType,s=ee("input",i,e),a=ye("output",i,t),u=l=>`
  const inputShape = ${s.indices(...e)};
  ${l.declareVariables(s,a)}
  ${l.mainStart()}
  ${l.guardAgainstOutOfBoundsWorkgroupSizes(o)}
    let outputIndices = ${a.offsetToIndices("global_idx")};
    var inputIndices: ${s.type.indices};
    for (var i = 0; i < ${e.length}; i++) {
      if (${s.indicesGet("inputShape","i")} == 1) {
        ${s.indicesSet("inputIndices","i",0)}
      } else {
        ${s.indicesSet("inputIndices","i",a.indicesGet("outputIndices",`i + ${t.length-e.length}`))}
      }
    }
    ${a.setByOffset("global_idx",s.getByIndices("inputIndices"))}
  }`;return{name:"Expand",shaderCache:{hint:`${t}`},getShaderSource:u,getRunData:()=>({outputs:[{dims:t,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}})}},lg=n=>{Rw(n.inputs),n.compute(Lw(n.inputs),{inputs:[0]})}});var Nw,Fw,dg,fg,pg=k(()=>{"use strict";Ee();ot();Ge();Nw=n=>{if(!n||n.length!==2)throw new Error("Gather requires 2 inputs.")},Fw=(n,e)=>{let r=n[0].dims,t=n[1].dims,o=r.length,i=W.normalizeAxis(e.axis,o),s=r.slice(0);s.splice(i,1,...t);let a=r[i],u=W.size(s),l=ee("data",n[0].dataType,n[0].dims),d=ee("inputIndices",n[1].dataType,n[1].dims),p=ye("output",n[0].dataType,s),h=()=>{let y=t.length,b=`var indicesIndices  = ${d.type.indices}(0);`;for(let w=0;w<y;w++)b+=`${y>1?`indicesIndices[${w}]`:"indicesIndices"} = ${s.length>1?`outputIndices[${i+w}]`:"outputIndices"};`;b+=`
        var idx = ${d.getByIndices("indicesIndices")};
        if (idx < 0) {
          idx = idx + ${a};
        }
        var dataIndices = ${l.type.indices}(0);
      `;for(let w=0,I=0;w<o;w++)w===i?(b+=`${o>1?`dataIndices[${w}]`:"dataIndices"} = u32(idx);`,I+=y):(b+=`${o>1?`dataIndices[${w}]`:"dataIndices"} = ${s.length>1?`outputIndices[${I}]`:"outputIndices"};`,I++);return b},g=y=>`
      ${y.declareVariables(l,d,p)}
      ${y.mainStart()}
        ${y.guardAgainstOutOfBoundsWorkgroupSizes(u)}
        let outputIndices = ${p.offsetToIndices("global_idx")};
        ${h()};
        let value = ${l.getByIndices("dataIndices")};
        ${p.setByOffset("global_idx","value")};
      }`;return{name:"Gather",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:g}},dg=n=>me({axis:n.axis}),fg=(n,e)=>{let r=n.inputs;Nw(r),n.compute(Fw(n.inputs,e))}});var zw,Gw,hg,mg,gg=k(()=>{"use strict";Ee();ot();Ge();zw=n=>{if(!n||n.length!==2)throw new Error("GatherElements requires 2 inputs.");if(n[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(n[0].dims.length!==n[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},Gw=(n,e)=>{let r=n[0].dims,t=n[0].dataType,o=r.length,i=W.computeStrides(r),s=W.size(r),a=n[1].dims,u=n[1].dataType,l=W.size(a),d=W.normalizeAxis(e.axis,o),p=r[d],h=a.slice(0),g=W.size(h),y=ee("input",t,r),b=ee("indices",u,[l]),w=ye("output",t,h),I=O=>`
      const inputStrides = array<u32, ${i.length}>(${i.map(E=>`${E}u`).join(",")});
      ${O.declareVariables(y,b,w)}
      ${O.mainStart()}
      ${O.guardAgainstOutOfBoundsWorkgroupSizes(g)}

      let outputIndices = ${w.offsetToIndices("global_idx")};

      var idx = ${b.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + ${p};
      }

      var srcOffset = u32(0);

      for (var i = 0; i < ${r.length}; i++) {
        if (i == ${d}) {
          srcOffset +=  u32(idx) * inputStrides[i];
        } else {
          srcOffset += ${w.indicesGet("outputIndices","i")} * inputStrides[i];
        }
      }

      // Should never hit this with valid values in indices
      // This is a guard against malicious data in the indices input
      if (srcOffset < 0 || srcOffset >= ${s}) {
        return;
      }

      output[global_idx] = input[srcOffset];
  }`;return{name:"GatherElements",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:h,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(g/64)}}),getShaderSource:I}},hg=n=>me({axis:n.axis}),mg=(n,e)=>{let r=n.inputs;zw(r),n.compute(Gw(n.inputs,e))}});var Ww,Vw,Uw,bg,yg,vg=k(()=>{"use strict";Ee();ot();Ge();Ww=n=>{if(!n)throw new Error("Input is missing");if(n.length<2||n.length>3)throw new Error("Invaid input number.");if(n.length===3&&n[2].dims.length>2)throw new Error("Invalid input shape of C");if(n[0].dataType!==n[1].dataType||n.length===3&&n[0].dataType!==n[2].dataType)throw new Error("Input types are mismatched")},Vw=(n,e,r)=>{if(r.length===0)return"0u";let t=r.length===1&&n!==1||r.length===2&&r[0]!==n,o=r[r.length-1]!==e,i="0u";return t||(i+=`+ m * ${r[r.length-1]}u`),o||(i+="+n"),i},Uw=(n,e)=>{let r=n[0].dims.slice(),t=n[1].dims.slice(),[o,i,s]=Ai.getShapeOfGemmResult(r,e.transA,t,e.transB,n.length===3?n[2].dims:void 0),a=[o,i];if(!a)throw new Error("Can't use gemm on the given tensors");let u=W.size(a),l="";e.transA&&e.transB?l="value += a[k * M + m] * b[n * K + k];":e.transA&&!e.transB?l="value += a[k * M + m] * b[k * N + n];":!e.transA&&e.transB?l="value += a[m * K + k] * b[n * K + k];":!e.transA&&!e.transB&&(l="value += a[m * K + k] * b[k * N + n];");let d=it(n[0].dataType),p=e.alpha===1?"":"value *= alpha;",h=n.length===3?`value += beta * c[${Vw(o,i,n[2].dims)}];`:"",g=[`@group(0) @binding(0) var<storage, read> a : array<${d}>;`,`@group(0) @binding(1) var<storage, read> b : array<${d}>;`];n.length===3&&g.push(`@group(0) @binding(2) var<storage, read> c : array<${d}>;`);let y=b=>`
  const M: u32 = ${o}u;
  const N: u32 = ${i}u;
  const K: u32 = ${s}u;
  const alpha = ${d}(${e.alpha});
  const beta = ${d}(${e.beta});

  ${g.join(`
`)}
  @group(0) @binding(${n.length}) var<storage, read_write> output : array<${d}>;

  ${b.mainStart()}
    ${b.guardAgainstOutOfBoundsWorkgroupSizes(u)}

    let m = global_id.x / N;
    let n = global_id.x % N;

    var value = ${d}(0);
    for (var k: u32 = 0u; k<${s}u; k++) {
      ${l}
    }

    ${p}
    ${h}
    output[global_id.x] = value;

  }`;return{name:"Gemm",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:a,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)}}),getShaderSource:y}},bg=(n,e)=>{Ww(n.inputs),n.compute(Uw(n.inputs,e))},yg=n=>me(n)});var xg,Hw,jw,wg,Tg,$g=k(()=>{"use strict";Ee();ot();Ge();xg={name:"InstanceNormalization"},Hw=(n,e)=>{let r=n[0].dims,t=r,o=2,i=W.sizeToDimension(r,o),s=W.sizeFromDimension(r,o),a=r[1],u=ee("x",n[0].dataType,[r[0],r[1],s]),l=ee("scale",n[1].dataType,n[1].dims),d=ee("bias",n[2].dataType,n[2].dims),p=ye("output",n[0].dataType,[r[0],r[1],s]),h=[u,l,d,p],g=u.type.value,y=64,b=w=>`

  const C: u32 = ${a};
  const normSize: u32 = ${s};
  const epsilon: f32 = ${e.epsilon};
  var<workgroup> meanShared : ${g};
  var<workgroup> squaredNormShared : ${g};
  var<workgroup> workgroupShared : array<${g}, ${y}>;
  const workgroupSize = ${y}u;
  ${w.declareVariables(...h)}
  ${w.mainStart(y)}
    let norm = global_idx / workgroupSize;
    let batch = norm / C;
    let channel = norm % C;
    let localIndex = local_id.x;

    // initialize workgroup memory
    var initial: ${g} = 0;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      initial = initial + ${u.get("batch","channel","h")};
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the mean of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      meanShared = workgroupShared[0] / ${g}(normSize);
    }
    workgroupBarrier();

    // reinitialize workgroup memory.
    initial = 0;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      let deviation =  ${u.get("batch","channel","h")} - meanShared;
      initial = initial + deviation * deviation;
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the sum of square of deviation of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      squaredNormShared = workgroupShared[0];
    }
    workgroupBarrier();

    let invStdDev = 1 / sqrt(squaredNormShared / ${g}(normSize) + epsilon);
    let channelScale = invStdDev * ${l.getByOffset("channel")};
    let channelShift = ${d.getByOffset("channel")} - meanShared * channelScale;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      let value = ${u.get("batch","channel","h")} * channelScale + channelShift;
      ${p.set("batch","channel","h","value")};
    }
  }`;return{...xg,shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:t,dataType:n[0].dataType}],dispatchGroup:{x:i}}),getShaderSource:b}},jw=(n,e)=>{let r=n[0].dims,t=r,o=W.size(t),i=r[0],s=r[r.length-1],a=W.sizeFromDimension(r,1)/s,u=it(n[0].dataType),l=s*i,d=p=>`
  const N: u32 = ${i};
  const H: u32 = ${a};
  const C: u32 = ${s};
  const normSizeTyped: ${u} = ${a};
  const imageSize: u32 = ${a*s};
  const epsilon: f32 = ${e.epsilon};

  @group(0) @binding(0) var<storage, read> x : array<${u}>;
  @group(0) @binding(1) var<storage, read> scale : array<${u}>;
  @group(0) @binding(2) var<storage, read> bias : array<${u}>;
  @group(0) @binding(3) var<storage, read_write> output : array<${u}>;

  ${p.mainStart()}
    let currentImageNumber = global_idx / C;
    let currentChannelNumber = global_idx % C;

    // offset is channel num * N
    let offset = currentImageNumber * imageSize;
    if (offset >= ${o}) { return; }
    var mean: ${u} = 0;

    for (var i: u32 = 0u; i < H; i++) {
        mean = mean + x[offset + i * C + currentChannelNumber];
    }
    mean = mean / normSizeTyped;

    var squaredNorm: ${u} = 0;
    for (var i: u32 = 0u; i < H; i++) {
        let deviation: f32 = x[offset + i * C + currentChannelNumber] - mean;
        squaredNorm = squaredNorm + deviation * deviation;
    }
    let invStdDev = 1 / sqrt(squaredNorm / normSizeTyped + epsilon);
    let channelScale = invStdDev * scale[currentChannelNumber];
    let channelShift = bias[currentChannelNumber] - mean * channelScale;
    for (var i: u32 = 0u; i < H; i++) {
        let currentOffset = offset + i * C + currentChannelNumber;
        output[currentOffset] = x[currentOffset] * channelScale + channelShift;
    }
  }`;return{...xg,shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:t,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)}}),getShaderSource:d}},wg=n=>me({epsilon:n.epsilon,format:n.format}),Tg=(n,e)=>{e.format==="NHWC"?n.compute(jw(n.inputs,e)):n.compute(Hw(n.inputs,e))}});var qw,Kw,Ig,Sg,_g=k(()=>{"use strict";dt();Ee();ot();Ge();qw=n=>{if(!n||n.length<2)throw new Error("layerNorm requires at least 2 inputs.");if(n[0].dataType!==1||n[1].dataType!==1)throw new Error("inputs should be float type")},Kw=(n,e,r)=>{let t=n[0].dims,o=n[1],i=n[2],s=t,a=W.size(s),u=W.normalizeAxis(e.axis,t.length),l=W.sizeToDimension(t,u),d=W.sizeFromDimension(t,u),p=W.size(o.dims),h=i?W.size(i.dims):0;if(p!==d||i&&h!==d)throw new Error(`Size of X.shape()[axis:] == ${d}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${p} and bias size of ${h}`);let g=[];for(let N=0;N<t.length;++N)N<u?g.push(t[N]):g.push(1);let y=it(n[0].dataType),b=r>1,w=r>2,I=0,O=N=>`
  const normSize: u32 = ${d};
  const normSizeTyped: ${y} = ${d};
  const epsilon: f32 = ${e.epsilon};

  @group(0) @binding(${I++}) var<storage, read> x : array<${y}>;
  @group(0) @binding(${I++}) var<storage, read> scale : array<${y}>;
  ${i?`@group(0) @binding(${I++}) var<storage, read> bias : array<${y}>;`:""}
  @group(0) @binding(${I++}) var<storage, read_write> output : array<${y}>;
  ${b?`@group(0) @binding(${I++}) var<storage, read_write> meanDataOutput : array<${y}>`:""};
  ${w?`@group(0) @binding(${I++}) var<storage, read_write> invStdOutput : array<${y}>`:""};

  ${N.mainStart()}
    let offset = global_idx * normSize;
    if (offset >= ${a}) { return; }
    var mean: ${y} = 0;
    var meanSquare: ${y} = 0;

    for (var h: u32 = 0u; h < normSize; h++) {
      mean = mean + x[h + offset];
      meanSquare = meanSquare + x[h + offset] * x[h + offset];
    }
    mean = mean / normSizeTyped;
    meanSquare = sqrt(meanSquare / normSizeTyped - mean * mean + epsilon);

    for (var j: u32 = 0; j < normSize; j++) {
      output[j + offset] = (x[j + offset] - mean) / meanSquare * scale[j] ${i?"+ bias[j]":""};
    }

    ${b?"meanDataOutput[global_idx] = mean":""};
    ${w?"invStdOutput[global_idx] = 1 / meanSquare":""};
  }`,E=[{dims:s,dataType:n[0].dataType}];return b&&E.push({dims:g,dataType:n[0].dataType}),w&&E.push({dims:g,dataType:n[0].dataType}),{name:"LayerNormalization",shaderCache:{hint:`${e.cacheKey}|${r}|${n.length}`},getRunData:()=>({outputs:E,dispatchGroup:{x:Math.ceil(l/64)}}),getShaderSource:O}},Ig=n=>me({axis:n.axis,epsilon:n.epsilon}),Sg=(n,e)=>{qw(n.inputs),n.compute(Kw(n.inputs,e,n.outputCount))}});var Yw,Ag,Og=k(()=>{"use strict";Ee();co();Yw=n=>{if(!n||n.length!==2)throw new Error("MatMul requires 2 inputs.");if(n[0].dims[n[0].dims.length-1]!==n[1].dims[n[1].dims.length-2])throw new Error("shared dimension does not match.")},Ag=n=>{Yw(n.inputs);let e=ar.calcShape(n.inputs[0].dims,n.inputs[1].dims,!0);if(!e)throw new Error("Can't use matmul on the given tensors");n.compute(Fi(n.inputs,{activation:"",activationCacheKey:""},e))}});var Xw,Jw,Zw,Qw,e2,t2,r2,n2,o2,Eg,Cg,Pg=k(()=>{"use strict";dt();Ee();ot();Ge();Xw=n=>{if(!n||n.length<1)throw new Error("Too few inputs");if(n[0].dataType!==1)throw new Error("Input type must be float.");if(n.length>=2){let e=n[0].dims.length*2===n[1].dims[0];if(n.length===4&&(e=n[3].dims[0]*2===n[1].dims[0]),!e)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},Jw=(n,e,r,t,o,i,s)=>{let a=r.length,u="";for(let l=a-1;l>=0;--l)u+=`
            k = i32(${n.indicesGet("indices",l)}) - ${o[l]};
            if (k < 0) {
              break;
            }
            if (k >= ${r[l]}) {
              break;
            }
            offset += k * ${t[l]};
        `;return`
          value = ${i}(${s});
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${u}
            value = x[offset];
          }
      `},Zw=(n,e,r,t,o)=>{let i=r.length,s="";for(let a=i-1;a>=0;--a)s+=`
                k = i32(${n.indicesGet("indices",a)}) - ${o[a]};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = ${2*(r[a]-1)};
                  k = k % _2n_1;
                  if(k >= ${r[a]}) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * ${t[a]};
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},Qw=(n,e,r,t,o)=>{let i=r.length,s="";for(let a=i-1;a>=0;--a)s+=`
                k = i32(${n.indicesGet("indices",a)}) - ${o[a]};
                if (k < 0) {
                  k = 0;
                }
                if (k >= ${r[a]}) {
                  k = ${r[a]-1};
                }
                offset += k * ${t[a]};
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},e2=(n,e,r,t,o)=>{let i=r.length,s="";for(let a=i-1;a>=0;--a)s+=`
                k = i32(${n.indicesGet("indices",a)}) - ${o[a]};
                if (k < 0)  {
                  k += ${r[a]};
                }
                if (k >= ${r[a]}) {
                  k -= ${r[a]};
                }
                offset += k * ${t[a]};
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},t2=(n,e,r,t,o,i)=>{switch(o.mode){case 0:return Jw(n,e,r,t,o.pads,i,o.value);case 1:return Zw(n,e,r,t,o.pads);case 2:return Qw(n,e,r,t,o.pads);case 3:return e2(n,e,r,t,o.pads);default:throw new Error("Invalid mode")}},r2=(n,e,r,t)=>{let o=e[0].dims,i=W.padShape(o.slice(),r.pads),s=W.size(i),a=W.computeStrides(o),u=ye("output",e[0].dataType,i),l=ee("x",e[0].dataType,o),d=t2(u,i,o,a,r,t);return`
              ${n.declareVariables(l,u)}
              ${n.mainStart()}
              ${n.guardAgainstOutOfBoundsWorkgroupSizes(s)}

              let indices = ${u.offsetToIndices("global_idx")};

              var value = ${t}(0);
              ${d}
              output[global_idx] = value;
          }`},n2=(n,e)=>{let r=W.padShape(n[0].dims.slice(),e.pads);return{name:"Pad",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(W.size(r)/64)}}),getShaderSource:t=>r2(t,n,e,"f32")}},o2=(n,e)=>{if(n.length>1){let r=n[1].getBigInt64Array(),t=n.length>=3&&n[2].data?n[2].getFloat32Array()[0]:0,o=n[0].dims.length,i=new Int32Array(2*o).fill(0);if(n.length>=4){let a=n[3].getBigInt64Array();for(let u=0;u<a.length;u++)i[Number(a[u])]=Number(r[u]),i[Number(a[u])+o]=Number(r[u+a.length])}else r.forEach((a,u)=>i[Number(u)]=Number(a));let s=[];return i.forEach(a=>s.push(a)),me({mode:e.mode,value:t,pads:s})}else return e},Eg=(n,e)=>{Xw(n.inputs);let r=o2(n.inputs,e);n.compute(n2(n.inputs,r),{inputs:[0]})},Cg=n=>{let e=n.mode,r=n.value,t=n.pads;return me({mode:e,value:r,pads:t})}});var Wi,Dg,kg,Bg,Rg,Mg,Lg,Ng,Fg,zg,Gg,Wg,Vg,Ug,Hg,jg=k(()=>{"use strict";Ee();ot();Ge();Wi=n=>{if(!n||n.length!==1)throw new Error("Pool ops requires 1 input.");if(n[0].dims.length!==4)throw new Error("Pool ops supports 2-D inputs only for now.")},Dg=(n,e,r)=>{let t=e.format==="NHWC",o=t?[n.dims[0],n.dims[3],n.dims[1],n.dims[2]]:n.dims.slice(),i=Object.hasOwnProperty.call(e,"dilations"),s=e.kernelShape.slice(),a=e.strides.slice(),u=i?e.dilations.slice():[],l=e.pads.slice();Xr.adjustPoolAttributes(r,o,s,a,u,l);let d=Xr.computePoolOutputShape(r,o,a,u,s,l,e.autoPad),p=Object.assign({},e);return i?Object.assign(p,{kernelShape:s,strides:a,pads:l,dilations:u,cacheKey:e.cacheKey}):Object.assign(p,{kernelShape:s,strides:a,pads:l,cacheKey:e.cacheKey}),[p,t?[d[0],d[2],d[3],d[1]]:d]},kg=(n,e,r,t,o,i,s,a)=>{let u=o.format==="NHWC",l=r,d=e.type.value,p=l.length,h=W.size(t),g=ye("output",e.type.tensor,t);if(o.kernelShape.length<=2){let y=o.kernelShape[o.kernelShape.length-1],b=o.strides[o.strides.length-1],w=o.pads[o.pads.length/2-1],I=o.pads[o.pads.length-1],O=p-(u?2:1),E="",N="",F="";if(w+I!==0?E=`
              for (var i: u32 = 0u; i < ${y}u; i++) {
                xIndices[${O}] = indices[${O}] * ${b} - ${w} + i;
                if (xIndices[${O}] < 0 || xIndices[${O}] >= ${l[O]}) {
                  pad++;
                  continue;
                }
                let x_val = x[${e.indicesToOffset("xIndices")}];
                ${i}
              }`:E=`
              for (var i: u32 = 0u; i < ${y}u; i++) {
                xIndices[${O}] = indices[${O}] * ${b} - ${w} + i;
                let x_val = x[${e.indicesToOffset("xIndices")}];
                ${i}
              }`,o.kernelShape.length===2){let V=o.kernelShape[o.kernelShape.length-2],K=o.strides[o.strides.length-2],J=o.pads[o.pads.length/2-2],ge=o.pads[o.pads.length-2],P=p-(u?3:2),oe=l[P];J+ge!==0?N=`
                for (var j: u32 = 0u; j < ${V}u; j++) {
                  xIndices[${P}] = indices[${P}] * ${K} - ${J} + j;
                  if (xIndices[${P}] < 0 || xIndices[${P}] >= ${oe}) {
                    pad+= ${y};
                    continue;
                  }
              `:N=`
                for (var j: u32 = 0u; j < ${V}u; j++) {
                  xIndices[${P}] = indices[${P}] * ${K} - ${J} + j;
                `,F=`
              }
            `}return`
            ${n.declareVariables(e,g)}

            ${n.mainStart()}
              ${n.guardAgainstOutOfBoundsWorkgroupSizes(h)}

              let indices = ${g.offsetToIndices("global_idx")};
              var xIndices = ${g.offsetToIndices("global_idx")};

              var value: ${d} = ${d}(${a});
              var pad = 0;
              ${N}
              ${E}
              ${F}
              ${s}

              output[global_idx] = value;
            }`}else{if(u)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let y=W.size(o.kernelShape),b=W.computeStrides(o.kernelShape),w=b.length,I=o.pads.length,O=o.pads.reduce((F,R)=>F+R),E="";return O?E=`
                if (xIndices[j] >= inputDims[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${e.indicesToOffset("xIndices")}];
                ${i}
              }`:E=`
              }
              let x_val = x[${e.indicesToOffset("xIndices")}];
              ${i}
            `,`
            ${n.declareVariables(e,g)}

            const pads = array<u32, ${I}>(${o.pads.map(F=>`${F}u`).join(",")});
            const inputDims = array<u32, ${p}>(${l.map(F=>`${F}u`).join(",")});
            const kernelStrides = array<u32, ${w}>(${b.map(F=>`${F}u`).join(",")});
            const strides = array<u32, ${w}>(${o.strides.map(F=>`${F}u`).join(",")});

            ${n.mainStart()}
              ${n.guardAgainstOutOfBoundsWorkgroupSizes(h)}

              let indices = ${g.offsetToIndices("global_idx")};
              let xIndices = ${g.offsetToIndices("global_idx")};

              var offsets: array<u32, ${w}>;

              var value = ${g.type.value}(${a});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < ${y}u; i++) {
                var offset = i;
                for (var j = 0u; j < ${w-1}u; j++) {
                  offsets[j] = offset / kernelStrides[j];
                  offset -= offsets[j] * kernelStrides[j];
                }
                offsets[${w-1}] = offset;

                isPad = false;
                for (var j = ${p-w}u; j < ${p}u; j++) {
                  xIndices[j] = indices[j] * strides[j - ${p-w}u]
                    + offsets[j - ${p-w}u] - pads[j - 2u];
                  ${E}
              }
              ${s}

              output[global_idx] = value;
            }`}},Bg=n=>({format:n.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][n.auto_pad],ceilMode:n.ceil_mode,kernelShape:n.kernel_shape,strides:n.strides,pads:n.pads}),Rg=(n,e,r,t)=>{let[o,i]=Dg(e,t,r),s=W.size(o.kernelShape),a=ee("x",e.dataType,e.dims),u=a.type.value,l="value += x_val;",d="";return o.countIncludePad?d+=`value /= ${u}(${s});`:d+=`value /= ${u}(${s} - pad);`,{name:n,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(W.size(i)/64)}}),getShaderSource:p=>kg(p,a,e.dims,i,o,l,d,"0.0")}},Mg=n=>{let e=n.count_include_pad!==0,r=Bg(n);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return me({countIncludePad:e,...r})},Lg=(n,e)=>{Wi(n.inputs),n.compute(Rg("AveragePool",n.inputs[0],!1,e))},Ng={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},Fg=n=>{let e=n.format;return{format:e,...Ng,cacheKey:e}},zg=(n,e)=>{Wi(n.inputs),n.compute(Rg("GlobalAveragePool",n.inputs[0],!0,e))},Gg=(n,e,r,t)=>{let[o,i]=Dg(e,t,r),s=`
      value = max(x_val, value);
    `,a="",u=ee("x",e.dataType,e.dims);return{name:n,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(W.size(i)/64)}}),getShaderSource:l=>kg(l,u,e.dims,i,o,s,a,"-1e5")}},Wg=(n,e)=>{Wi(n.inputs),n.compute(Gg("MaxPool",n.inputs[0],!1,e))},Vg=n=>{let e=n.storage_order,r=n.dilations,t=Bg(n);if(e!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(t.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return me({storageOrder:e,dilations:r,...t})},Ug=n=>{let e=n.format;return{format:e,...Ng,cacheKey:e}},Hg=(n,e)=>{Wi(n.inputs),n.compute(Gg("GlobalMaxPool",n.inputs[0],!0,e))}});var a2,s2,qg,Kg=k(()=>{"use strict";zt();dt();Ge();a2=(n,e,r)=>{let t=n===e,o=n<e&&r<0,i=n>e&&r>0;if(t||o||i)throw new Error("Range these inputs' contents are invalid.")},s2=(n,e,r,t)=>{let o=Math.abs(Math.ceil((e-n)/r)),i=[o],s=o,a=ye("output",t,i),u=a.type.storage,l=d=>`
        ${d.declareVariables(a)}
        ${d.mainStart()}
        ${d.guardAgainstOutOfBoundsWorkgroupSizes(s)}
        output[global_idx] = ${u}(${n}) + ${u}(global_idx) * ${u}(${r});
      }`;return{name:"Range",shaderCache:{hint:[n,e,r].map(d=>d.toString()).join("_")},getShaderSource:l,getRunData:()=>({outputs:[{dims:i,dataType:t}],dispatchGroup:{x:Math.ceil(s/64)}})}},qg=n=>{let e=0,r=0,t=0;n.inputs[0].dataType===6?(e=n.inputs[0].getInt32Array()[0],r=n.inputs[1].getInt32Array()[0],t=n.inputs[2].getInt32Array()[0]):n.inputs[0].dataType===1&&(e=n.inputs[0].getFloat32Array()[0],r=n.inputs[1].getFloat32Array()[0],t=n.inputs[2].getFloat32Array()[0]),xe.webgpu.validateInputContent&&a2(e,r,t),n.compute(s2(e,r,t,n.inputs[0].dataType),{inputs:[]})}});var u2,l2,c2,d2,f2,p2,h2,m2,g2,b2,y2,v2,x2,w2,T2,Yg,Xg,Jg=k(()=>{"use strict";Ee();ot();Ge();u2=(n,e)=>{if(n.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),n.length>0){if(e.mode==="linear"){if(!(n.length===2||n.length===4&&n[0]===1&&n[1]===1||n.length===4&&n[0]===1&&n[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(e.mode==="cubic"&&!(n.length===2||n.length===4&&n[0]===1&&n[1]===1||n.length===4&&n[0]===1&&n[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},l2=(n,e,r)=>{e.every(o=>o>=0&&o<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let t=new Array(r).fill(1);return e.forEach((o,i)=>t[o]=n[i]),t},c2=(n,e,r,t,o,i)=>{let[s,a,u]=r>10?[1,2,3]:[-1,n.length>1?1:-1,-1],l=n[0].dims.length;if(s>0&&n.length>s&&n[s].dims.length>0)n[s].getFloat32Array().forEach(d=>i.push(d));else if(e.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(a>0&&n.length>a&&n[a].dims.length>0){if(n[a].getFloat32Array().forEach(d=>t.push(d)),t.length!==0&&t.length!==l&&r>=18&&t.length!==e.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");u2(t,e),e.axes.length>0&&l2(t,e.axes,l).forEach((d,p)=>t[p]=d)}if(u>0&&n.length>u&&(n[u].getBigInt64Array().forEach(d=>o.push(Number(d))),o.length!==l||r>=18&&o.length===e.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(e.axes.length>0){if(t.length!==e.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(o.length!==e.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof t<"u"&&typeof o<"u"&&t.length>0&&o.length>l)throw new Error("Resize requires only of scales or sizes to be specified")},d2=n=>"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(n){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`
`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${n} is not supported`)}})()+"}",f2=(n,e)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(n){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(e<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${n} is not supported`)}})()+"}",p2=(n,e,r)=>{let t=new Array(r).fill(0).concat(new Array(r).fill(1)),o=n.length===0?t:n.slice();return e.length>0?(e.forEach((i,s)=>{t[i]=o[s],t[s+r]=o[e.length+s]}),t):o},h2=(n,e,r,t)=>{let o=[];if(r.length>0)if(t.length>0){if(n.forEach(i=>o.push(i)),Math.max(...t)>n.length)throw new Error("axes is out of bound");t.forEach((i,s)=>o[i]=r[s])}else r.forEach(i=>o.push(i));else{if(e.length===0)throw new Error("Resize requires either scales or sizes.");o=n.map((i,s)=>Math.round(i*e[s]))}return o},m2=(n,e,r,t)=>{let o=(()=>{switch(t.keepAspectRatioPolicy){case"not_larger":return t.axes.length>0?Math.min(...t.axes.map(s=>r[s]),Number.MAX_VALUE):Math.min(...r,Number.MAX_VALUE);case"not_smaller":return t.axes.length>0?Math.max(...t.axes.map(s=>r[s]),Number.MIN_VALUE):Math.max(...r,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${t.keepAspectRatioPolicy} is not supported`)}})();r.fill(1,0,r.length);let i=n.slice();return t.axes.length>0?(t.axes.forEach(s=>r[s]=o),t.axes.forEach(s=>i[s]=Math.round(n[s]*r[s]))):(r.fill(o,0,r.length),i.forEach((s,a)=>i[a]=Math.round(s*r[a]))),i},g2=(n,e,r,t,o)=>`
    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${n.type.indices}) -> array<f32, ${r.length}> {
      const inputShape = array<u32, ${e.length}>(${e.map(i=>`${i}u`).join(",")});
      const outputShape = array<u32, ${r.length}>(${r.map(i=>`${i}u`).join(",")});
      const scales = array<f32, ${t.length}>(${t.map(i=>`${i}f`).join(",")});
      const roi = array<f32, ${o.length}>(${o.map(i=>`${i}f`).join(",")});
      var originalIndices: array<f32, ${r.length}>;
      for (var i:u32 = 0; i < ${r.length}; i++) {
        var outputIndex = ${r.length===1?"outputIndices":"outputIndices[i]"};
        if (scales[i] == 1.0) {
          originalIndices[i] = f32(outputIndex);
        } else {
          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],
                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${e.length}]);
        }
      }
      return originalIndices;
    }`,b2=(n,e,r,t,o,i,s)=>`
    fn calculateInputIndicesFromOutputIndices(outputIndices: ${e.type.indices}) -> ${n.type.indices} {
        const inputShape = array<u32, ${r.length}>(${r.map(a=>`${a}u`).join(",")});
        const outputShape = array<u32, ${t.length}>(${t.map(a=>`${a}u`).join(",")});
        const scales = array<f32, ${o.length}>(${o.map(a=>`${a}f`).join(",")});
        const roi = array<f32, ${i.length}>(${i.map(a=>`${a}f`).join(",")});
        var inputIndices: ${n.type.indices};
        for (var i:u32 = 0; i < ${t.length}; i++) {
          var outputIndex = ${t.length===1?"outputIndices":"outputIndices[i]"};
          var inputIndex: u32;
          if (scales[i] == 1.0) {
            inputIndex = outputIndex;
          } else {
            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],
                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${r.length}]);
            if (!${s} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {
              if (original_idx < 0) {
                inputIndex = 0;
              } else if (original_idx > (f32(inputShape[i]) - 1)) {
                inputIndex = inputShape[i] - 1;
              } else {
                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));
              }
            } else {
              inputIndex = u32(original_idx);
            }
          }
          ${n.indicesSet("inputIndices","i","inputIndex")}
        }
        return inputIndices;
    }`,y2=(n,e)=>`
    fn checkInputIndices(inputIndices: ${n.type.indices}) -> bool {
      const inputShape = array<u32, ${e.length}>(${e.map(r=>`${r}u`).join(",")});
      for (var i:u32 = 0; i < ${e.length}; i++) {
        var inputIndex = ${e.length===1?"inputIndices":"inputIndices[i]"};
        if (inputIndex < 0 || inputIndex >= inputShape[i]) {
          return false;
        }
      }
      return true;
    }`,v2=(n,e,r,t,o,i,s)=>{let[a,u,l,d]=r.length===2?[-1,0,1,-1]:o[1]===1?[0,2,3,1]:[0,1,2,3];return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {
      var inputIndices: ${n.type.indices};
      inputIndices[${u}] = max(0, min(row, ${r[u]} - 1));
      inputIndices[${l}] = max(0, min(col, ${r[l]} - 1));
      if (${r.length} > 2) {
        inputIndices[${d}] = channel;
        inputIndices[${a}] = batch;
      };
      return input[${n.indicesToOffset("inputIndices")}];
    }

    fn bilinearInterpolation(outputIndices: ${e.type.indices}) -> f32 {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);
      var row:f32 = originalIndices[${u}];
      var col:f32 = originalIndices[${l}];
      if (${i} && (row < 0 || row > (${r[u]} - 1) || col < 0 || col > ${r[l]} - 1)) {
        return ${s};
      }
      row = max(0, min(row, ${r[u]} - 1));
      col = max(0, min(col, ${r[l]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = 0;
      var batch: u32 = 0;
      if (${r.length>2}) {
        channel = u32(originalIndices[${d}]);
        batch = u32(originalIndices[${a}]);
      }
      var x11: f32 = getInputValue(batch, channel, row1, col1);
      var x12: f32 = getInputValue(batch, channel, row1, col2);
      var x21: f32 = getInputValue(batch, channel, row2, col1);
      var x22: f32 = getInputValue(batch, channel, row2, col2);
      var dx1: f32 = row - f32(row1);
      var dx2: f32 = f32(row2 ) - row;
      var dy1 = col - f32(col1);
      var dy2 = f32(col2) - col;
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},x2=(n,e,r,t,o,i,s,a,u,l)=>{let[d,p]=r.length===2?[0,1]:o[1]===1?[2,3]:[1,2],h=g=>{let y=g===d?"row":"col";return`
      fn ${y}CubicInterpolation(inputIndices: ${n.type.indices}, outputIndices: ${e.type.indices}) -> f32 {
        var outputIndex = ${t.length===1?"outputIndices":`outputIndices[${g}]`};
        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${o[g]},
        f32(${t[g]}), f32(${r[g]}), ${i[g]}, ${i[g]} + ${r.length});
        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${a} && (originalIdx < 0 || originalIdx > (${r[g]} - 1))) {
          return ${u};
        }
        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${y}: f32 = originalIdx + f32(i);
          if (${y} < 0 || ${y} >= ${r[g]}) {
            if (${l}) {
              coefs[i + 1] = 0.0;
              continue;
            } else if (${a}) {
              return ${u};
            } else {
              ${y} = max(0, min(${y}, ${r[g]} - 1));
            }
          }
          var inputIndicesCopy: ${n.type.indices} = inputIndices;
          inputIndicesCopy[${g}] = u32(${y});
          data[i + 1] = ${g===d?`input[${n.indicesToOffset("inputIndicesCopy")}];`:`
                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);`}
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${h(d)};
    ${h(p)};
  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {
    var absS = abs(s);
    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: f32 = 1.0 - absS;
    var twoMinusAbsS: f32 = 2.0 - absS;
    var onePlusAbsS: f32 = 1.0 + absS;
    coeffs[0] = ((${s} * onePlusAbsS - 5 * ${s}) * onePlusAbsS + 8 * ${s}) * onePlusAbsS - 4 * ${s};
    coeffs[1] = ((${s} + 2) * absS - (${s} + 3)) * absS * absS + 1;
    coeffs[2] = ((${s} + 2) * oneMinusAbsS - (${s} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${s} * twoMinusAbsS - 5 * ${s}) * twoMinusAbsS + 8 * ${s}) * twoMinusAbsS - 4 * ${s};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {
    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(outputIndices: ${e.type.indices}) -> f32 {
    var inputIndices: ${n.type.indices} = outputIndices;
    return colCubicInterpolation(inputIndices, outputIndices);
  }
    `},w2=(n,e,r,t,o,i)=>{let s=n.dims,a=p2(i,e.axes,s.length),u=h2(s,t,o,e.axes),l=t.slice();t.length===0&&(l=s.map((w,I)=>w===0?1:u[I]/w),e.keepAspectRatioPolicy!=="stretch"&&(u=m2(s,u,l,e)));let d=ye("output",n.dataType,u),p=ee("input",n.dataType,s),h=W.size(u),g=s.length===u.length&&s.every((w,I)=>w===u[I]),y=e.coordinateTransformMode==="tf_crop_and_resize",b=w=>`
      ${d2(e.coordinateTransformMode)};
      ${(()=>{switch(e.mode){case"nearest":return`
              ${y2(p,s)};
              ${f2(e.nearestMode,r)};
              ${b2(p,d,s,u,l,a,y)};
              `;case"linear":return`
              ${g2(d,s,u,l,a)};
              ${v2(p,d,s,u,l,y,e.extrapolationValue)};
              `;case"cubic":return`
            ${x2(p,d,s,u,l,a,e.cubicCoeffA,y,e.extrapolationValue,e.excludeOutside)};
            `;default:throw Error("Invalid resize mode")}})()};
      ${w.declareVariables(p,d)}
      ${w.mainStart()}
        ${w.guardAgainstOutOfBoundsWorkgroupSizes(h)}
        if (${g}) {
          output[global_idx] = input[global_idx];
        } else {
          let outputIndices = ${d.offsetToIndices("global_idx")};
          var inputIndices: ${p.type.indices};
          ${(()=>{switch(e.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);
                  if (checkInputIndices(inputIndices)) {
                    output[global_idx] = input[${p.indicesToOffset("inputIndices")}];
                  } else {
                    output[global_idx] = ${e.extrapolationValue};
                  }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${e.mode}`)}})()};
        }
      }`;return{name:"Resize",shaderCache:{hint:`${e.cacheKey}|${r}|${l.length>0?l:""}|${o.length>0?o:""}`},getShaderSource:b,getRunData:()=>({outputs:[{dims:u,dataType:n.dataType}],dispatchGroup:{x:Math.ceil(h/64)}})}},T2=n=>{let e=n.customDataBuffer;return new Uint32Array(e,e.byteOffset,1)[0]},Yg=(n,e)=>{let r=[],t=[],o=[],i=T2(n);c2(n.inputs,e,i,r,t,o),n.compute(w2(n.inputs[0],e,i,r,t,o),{inputs:[0]})},Xg=n=>{let e=n.antialias,r=n.axes,t=n.coordinateTransformMode,o=n.cubicCoeffA,i=n.excludeOutside!==0,s=n.extrapolationValue,a=n.keepAspectRatioPolicy,u=n.mode,l=n.nearestMode===""?"simple":n.nearestMode;return me({antialias:e,axes:r,coordinateTransformMode:t,cubicCoeffA:o,excludeOutside:i,extrapolationValue:s,keepAspectRatioPolicy:a,mode:u,nearestMode:l})}});var $2,I2,Zg,Qg,eb=k(()=>{"use strict";dt();Ee();ot();Ge();$2=n=>{if(!n||n.length<3)throw new Error("layerNorm requires at least 3 inputs.");if(n[0].dataType!==1||n[1].dataType!==1)throw new Error("inputs should be float type");let e=n[0],r=n[1],t=n[2];if(e.dataType!==r.dataType||e.dataType!==t.dataType)throw new Error("All inputs must have the same data type");if(e.dims.length!==3&&e.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let o=e.dims[e.dims.length-1],i=e.dims[e.dims.length-2];if(r.dims[r.dims.length-1]!==o)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==i)throw new Error("Skip must have the same sequence length as input");if(t.dims.length!==1)throw new Error("Gamma must be 1D");if(t.dims[t.dims.length-1]!==o)throw new Error("Gamma must have the same hidden size as input");if(n.length>3){let s=n[3];if(s.dims.length!==1)throw new Error("Beta must be 1D");if(s.dims[s.dims.length-1]!==o)throw new Error("Beta must have the same hidden size as input")}if(n.length>4){let s=n[4];if(s.dims.length!==1)throw new Error("Bias must be 1D");if(s.dims[s.dims.length-1]!==o)throw new Error("Bias must have the same hidden size as input")}},I2=(n,e,r,t)=>{let o=n[0].dims,i=W.size(o),s=o,a=i,u=o.slice(-1)[0],l=t?o.slice(0,-1).concat(1):[],d=n.length>3,p=n.length>4,h=it(n[0].dataType),g=t&&r>1,y=t&&r>2,b=r>3,w=0,I=E=>`
      const hiddenSize: u32 = ${u};
      const epsilon: f32 = ${e.epsilon};

      @group(0) @binding(${w++}) var<storage, read> x : array<${h}>;
      @group(0) @binding(${w++}) var<storage, read> skip : array<${h}>;
      @group(0) @binding(${w++}) var<storage, read> gamma : array<${h}>;
      ${d?`@group(0) @binding(${w++}) var<storage, read> beta : array<${h}>;`:""}
      ${p?`@group(0) @binding(${w++}) var<storage, read> bias : array<${h}>;`:""}
      @group(0) @binding(${w++}) var<storage, read_write> output : array<${h}>;
      ${g?`@group(0) @binding(${w++}) var<storage, read_write> meanOutput : array<${h}>;`:""}
      ${y?`@group(0) @binding(${w++}) var<storage, read_write> invStdOutput : array<${h}>;`:""}
      ${b?`@group(0) @binding(${w++}) var<storage, read_write> inputSkipBiasSum : array<${h}>;`:""}

      ${E.mainStart()}
        ${E.guardAgainstOutOfBoundsWorkgroupSizes(a/u)}
        let offset = global_idx * hiddenSize;
        var sum: f32 = 0.0;
        var squareSum: f32 = 0.0;
        for (var i: u32 = 0; i < hiddenSize; i++) {
          let skipValue = skip[offset + i];
          let biasValue = ${p?"bias[i]":"0.0"};
          let inputValue = x[offset + i];
          let value = inputValue + skipValue + biasValue;
          ${b?"inputSkipBiasSum[offset + i] = value;":""}
          output[offset + i] = value;
          sum += value;
          squareSum += value * value;
        }
        let mean: f32 = sum / f32(hiddenSize);
        let variance: f32 = sqrt(squareSum / f32(hiddenSize) - mean * mean + epsilon);
        ${g?"meanOutput[global_idx] = mean;":""}
        ${y?"invStdOutput[global_idx] = 1.0 / variance;":""}
        for (var i: u32 = 0; i < hiddenSize; i++) {
          output[offset + i] = (output[offset + i] - mean) / variance * gamma[i] + ${d?"beta[i]":"0.0"};
        }
      }`,O=[{dims:s,dataType:n[0].dataType}];return r>1&&O.push({dims:l,dataType:n[0].dataType}),r>2&&O.push({dims:l,dataType:n[0].dataType}),r>3&&O.push({dims:o,dataType:n[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:e.cacheKey},getShaderSource:I,getRunData:()=>({outputs:O,dispatchGroup:{x:Math.ceil(a/u/64)}})}},Zg=(n,e)=>{$2(n.inputs);let t=[0];n.outputCount>1&&t.push(-3),n.outputCount>2&&t.push(-3),n.outputCount>3&&t.push(3),n.compute(I2(n.inputs,e,n.outputCount,!1),{outputs:t})},Qg=n=>{let e=n.epsilon;return me({epsilon:e})}});var S2,Vi,_2,tb,A2,O2,rb,nb,ob=k(()=>{"use strict";dt();Ee();ot();Ge();S2=(n,e)=>{if(!n||n.length<1)throw new Error("too few inputs");if(e.axes.length!==0){if(e.axes.length!==e.starts.length||e.axes.length!==e.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(e.starts.length!==e.ends.length)throw new Error("starts and ends must have the same length");n.slice(1).forEach((r,t)=>{if(n[t+1].dataType!==6&&n[t+1].dataType!==7)throw new Error(`Input ${t} must be an array of int32 or int64`)})},Vi=(n,e)=>{let r=[];if(n.length>e)if(n[e].dataType===7)n[e].getBigInt64Array().forEach(t=>r.push(Number(t)));else if(n[e].dataType===6)n[e].getInt32Array().forEach(t=>r.push(Number(t)));else throw new Error(`Input ${e} must be an array of int32 or int64`);return r},_2=(n,e)=>{if(n.length>1){let r=Vi(n,1),t=Vi(n,2),o=Vi(n,3);return o.length===0&&(o=[...Array(n[0].dims.length).keys()]),me({starts:r,ends:t,axes:o})}else return e},tb=(n,e,r,t,o)=>{let i=n;return n<0&&(i+=r[t[e]]),o[e]<0?Math.max(0,Math.min(i,r[t[e]]-1)):Math.max(0,Math.min(i,r[t[e]]))},A2=(n,e,r,t)=>`fn calculateInputIndices(outputIndices: ${e.type.indices}) -> ${n.type.indices} {
          var inputIndices: ${n.type.indices};
          var carry = 0u;
          for (var i = ${r.length}; i >= 0; i--) {
            var outputIndex = ${t.length===1?"outputIndices":"outputIndices[i]"};
            var inputIndex = outputIndex * steps[i] + starts[i] + carry;
            carry = inputIndex / inputShape[i];
            inputIndex = inputIndex % inputShape[i];
            if (signs[i] < 0) {
              inputIndex = inputShape[i] - inputIndex - 1u + starts[i];
            }
            ${r.length===1?"inputIndices":"inputIndices[i]"} = inputIndex;
          }
          return inputIndices;
      }`,O2=(n,e)=>{let r=n[0].dims,t=W.size(r),o=e.axes.length>0?W.normalizeAxes(e.axes,r.length):[...Array(r.length).keys()],i=Vi(n,4);i.forEach(b=>b!==0||(()=>{throw new Error("step cannot be 0")})),i.length===0&&(i=Array(o.length).fill(1));let s=e.starts.map((b,w)=>tb(b,w,r,o,i)),a=e.ends.map((b,w)=>tb(b,w,r,o,i));if(o.length!==r.length)for(let b=0;b<r.length;++b)o.includes(b)||(s.splice(b,0,0),a.splice(b,0,r[b]),i.splice(b,0,1));let u=i.map(b=>Math.sign(b));i.forEach((b,w,I)=>{if(b<0){let O=(a[w]-s[w])/b,E=s[w],N=E+O*i[w];s[w]=N,a[w]=E,I[w]=-b}});let l=r.slice(0);o.forEach((b,w)=>{l[b]=Math.ceil((a[b]-s[b])/i[b])});let d={dims:l,dataType:n[0].dataType},p=ye("output",n[0].dataType,l),h=ee("input",n[0].dataType,r),g=W.size(l),y=b=>`
      ${b.declareVariables(h,p)}
        const signs = array<i32, ${u.length}>(${u.map(w=>`${w}i`).join(",")});
        const starts = array<u32, ${s.length}>(${s.map(w=>`${w}u`).join(",")});
        const ends = array<u32, ${a.length}>(${a.map(w=>`${w}u`).join(",")});
        const steps = array<u32, ${i.length}>(${i.map(w=>`${w}u`).join(",")});
        const inputShape = array<u32, ${r.length}>(${r.map(w=>`${w}u`).join(",")});

        ${A2(h,p,r,l)}
        ${b.mainStart()}
          ${b.guardAgainstOutOfBoundsWorkgroupSizes(g)}
          let outputIndices = ${p.offsetToIndices("global_idx")};
          let inputIndices = calculateInputIndices(outputIndices);
          ${p.setByOffset("global_idx",h.getByIndices("inputIndices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${e.cacheKey}|${n[4]?.dims??""}`},getShaderSource:y,getRunData:()=>({outputs:[d],dispatchGroup:{x:Math.ceil(t/64)}})}},rb=(n,e)=>{S2(n.inputs,e);let r=_2(n.inputs,e);n.compute(O2(n.inputs,r),{inputs:[0]})},nb=n=>{let e=n.starts,r=n.ends,t=n.axes;return me({starts:e,ends:r,axes:t})}});var E2,C2,ib,ab,sb=k(()=>{"use strict";Ee();ot();Ge();E2=n=>{if(!n||n.length!==1)throw new Error("Softmax op requires 1 input.")},C2=(n,e)=>{let r=it(n.dataType),t=n.dims,o=W.size(t),i=64,s=e.axis;if(s<0&&(s=t.length+s),s<t.length-1)throw new Error("softmax only supports last axis for now.");let a=t[s],u=o/a,l=r==="f32"?"var threadMax: f32 = -3.402823e+38f;":"var threadMax: f16 = -65504.0h;";return{name:"Softmax",getRunData:()=>({outputs:[{dims:t,dataType:n.dataType}],dispatchGroup:{x:u}}),getShaderSource:p=>`
      var<workgroup> rowMaxShared : ${r};
      var<workgroup> rowSumShared : ${r};
      var<workgroup> threadShared : array<${r}, ${i}>;

      @group(0) @binding(0) var<storage, read> x : array<${r}>;
      @group(0) @binding(1) var<storage, read_write> result : array<${r}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${r} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${r}) {
        let index = row * row_stride + col;
        result[index] = value;
      }

      @compute @workgroup_size(${i}, 1, 1)
      fn main(@builtin(local_invocation_id) local_id : vec3<u32>, @builtin(global_invocation_id) global_id : vec3u) {
        let gindex = i32(global_id.x);
        let lindex = i32(local_id.x);
        const wg = ${i};
        let row = gindex / wg;
        let cols = ${a};
        let row_stride : i32 = ${a};

        // find the rows max
        ${l}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = threadShared[0];
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum: ${r} = 0.0;
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = threadShared[0];
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`}},ib=(n,e)=>{E2(n.inputs),n.compute(C2(n.inputs[0],e))},ab=n=>me({axis:n.axis})});var P2,D2,k2,B2,R2,ub,lb,cb=k(()=>{"use strict";Ee();ot();Ge();P2=n=>{if(!n||n.length<1)throw new Error("too few inputs")},D2=(n,e)=>{let r=[],t=e.numOutputs;return n[1].dims[0]>0&&(n[1].getBigInt64Array().forEach(o=>r.push(Number(o))),t=r.length),me({numOutputs:t,axis:e.axis,splitSizes:r})},k2=n=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${n}u; i += 1u ) {
    if (index < sizeInConcatAxis[i]) {
        return i;
    }
    }
    return ${n}u;
}`,B2=n=>{let e=n.length,r=[];for(let t=0;t<e;++t){let o=n[t].setByIndices("indices","input[global_idx]");e===1?r.push(o):t===0?r.push(`if (outputNumber == ${t}u) { ${o} }`):t===e-1?r.push(`else { ${o} }`):r.push(`else if (outputNumber == ${t}) { ${o} }`)}return`
      fn writeBufferData(outputNumber: u32, indices: ${n[0].type.indices}, global_idx: u32) {
        ${r.join(`
`)}
      }`},R2=(n,e)=>{let r=n[0].dims,t=W.size(r),o=n[0].dataType,i=r.length,s=e.axis,a=s<0?r.length+s:s,u=new Array(e.numOutputs),l=ee("input",o,r),d=new Array(e.numOutputs),p=[],h=[],g=0;for(let w=0;w<e.numOutputs;w++){g+=e.splitSizes[w],d[w]=g;let I=r.slice();I[e.axis]=e.splitSizes[w],h.push(I),u[w]=ye(`output${w}`,o,h[w]),p.push({dims:h[w],dataType:n[0].dataType})}let y=i<2?"indices":`indices[${a}]`,b=w=>`
  ${w.declareVariables(l,...u)}
  const sizeInConcatAxis = array<u32, ${d.length}>(${d.map(I=>`${I}u`).join(",")});
  ${k2(d.length)}
  ${B2(u)}

  ${w.mainStart()}
    ${w.guardAgainstOutOfBoundsWorkgroupSizes(t)}

    var indices = ${l.offsetToIndices("global_idx")};
    let outputNumber = calculateOutputIndex(${y});
    if (outputNumber != 0) {
        ${y} -= sizeInConcatAxis[outputNumber - 1u];
    }
    writeBufferData(outputNumber, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:e.cacheKey},getShaderSource:b,getRunData:()=>({outputs:p,dispatchGroup:{x:Math.ceil(t/64)}})}},ub=(n,e)=>{P2(n.inputs);let r=n.inputs.length===1?e:D2(n.inputs,e);n.compute(R2(n.inputs,r),{inputs:[0]})},lb=n=>{let e=n.axis,r=n.splitSizes,t=n.numOutputs<0?r.length:n.numOutputs;if(t!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return me({axis:e,numOutputs:t,splitSizes:r})}});var db,M2,L2,N2,fb,pb=k(()=>{"use strict";dt();Ee();Ge();db=n=>Array.from(n.getBigInt64Array(),Number),M2=n=>{if(!n||n.length!==2)throw new Error("Tile requires 2 inputs.");if(n[0].dataType!==1&&n[0].dataType!==6&&n[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(n[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(n[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(db(n[1]).length!==n[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},L2=(n,e)=>{let r=[];for(let t=0;t<n.length;++t)r.push(n[t]*e[t]);return r},N2=n=>{let e=n[0].dims,r=db(n[1]),t=L2(e,r),o=W.size(t),i=n[0].dataType,s=ee("input",i,e),a=ye("output",i,t),u=l=>`
      const inputShape = ${s.indices(...e)};
      ${l.declareVariables(s,a)}
      ${l.mainStart()}
      ${l.guardAgainstOutOfBoundsWorkgroupSizes(o)}
      let outputIndices = ${a.offsetToIndices("global_idx")};
      var inputIndices: ${s.type.indices};
      for (var i = 0; i < ${e.length}; i++) {
        let inputDimValue = ${a.indicesGet("outputIndices","i")}  % ${s.indicesGet("inputShape","i")};

        ${s.indicesSet("inputIndices","i","inputDimValue")}
      }
      ${a.setByOffset("global_idx",s.getByIndices("inputIndices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${r}`},getRunData:()=>({outputs:[{dims:t,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:u}},fb=n=>{M2(n.inputs),n.compute(N2(n.inputs),{inputs:[0]})}});var F2,z2,hb,mb=k(()=>{"use strict";dt();Ee();Ge();F2=(n,e,r,t,o)=>{let i=W.size(r),s=Math.ceil(i/4),a=ye("outputData",o,r,4),u=ee("aData",e[1].dataType,e[1].dims,4),l=ee("bData",e[2].dataType,e[2].dims,4),d=ee("cData",e[0].dataType,e[0].dims,4),p,h=(g,y,b)=>`select(${y}, ${g}, ${b})`;if(!t)p=a.setByOffset("global_idx",h(u.getByOffset("global_idx"),l.getByOffset("global_idx"),d.getByOffset("global_idx")));else{let g=(y,b,w="")=>{let I=`aData[indexA${b}][componentA${b}]`,O=`bData[indexB${b}][componentB${b}]`,E=`bool(cData[indexC${b}] & ${4278190080>>>(3-b)*8}u)`;return`
            let outputIndices${b} = ${a.offsetToIndices(`global_idx * 4u + ${b}u`)};
            let offsetA${b} = ${u.broadcastedIndicesToOffset(`outputIndices${b}`,a)};
            let offsetB${b} = ${l.broadcastedIndicesToOffset(`outputIndices${b}`,a)};
            let offsetC${b} = ${d.broadcastedIndicesToOffset(`outputIndices${b}`,a)};
            let indexA${b} = offsetA${b} / 4u;
            let indexB${b} = offsetB${b} / 4u;
            let indexC${b} = offsetC${b} / 4u;
            let componentA${b} = offsetA${b} % 4u;
            let componentB${b} = offsetB${b} % 4u;
            ${y}[${b}] = ${w}(${h(I,O,E)});
          `};o===9?p=`
            var data = vec4<u32>(0);
            ${g("data",0,"u32")}
            ${g("data",1,"u32")}
            ${g("data",2,"u32")}
            ${g("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:p=`
            ${g("outputData[global_idx]",0)}
            ${g("outputData[global_idx]",1)}
            ${g("outputData[global_idx]",2)}
            ${g("outputData[global_idx]",3)}
          `}return`
        ${n.declareVariables(d,u,l,a)}
        ${n.mainStart()}
        ${n.guardAgainstOutOfBoundsWorkgroupSizes(s)}
        ${p}
      }`},z2=n=>{let e=n[1].dims,r=n[2].dims,t=n[0].dims,o=n[1].dataType,i=!(W.areEqual(e,r)&&W.areEqual(r,t)),s=e,a=W.size(e);if(i){let u=ar.calcShape(ar.calcShape(e,r,!1),t,!1);if(!u)throw new Error("Can't perform where op on the given tensors");s=u,a=W.size(s)}return{name:"Where",getShaderSource:u=>F2(u,n,s,i,o),getRunData:()=>({outputs:[{dims:s,dataType:o}],dispatchGroup:{x:Math.ceil(a/64/4)}})}},hb=n=>{n.compute(z2(n.inputs))}});var gb,bb=k(()=>{"use strict";Uh();jh();Sm();Mm();Fm();Ls();ng();sg();cg();pg();gg();vg();$g();_g();Og();Pg();jg();Kg();Cs();Jg();eb();ob();sb();cb();pb();zi();ks();mb();gb=new Map([["Abs",[qh]],["Acos",[Kh]],["Acosh",[Yh]],["Add",[_m]],["ArgMax",[Vh,Ps]],["ArgMin",[Wh,Ps]],["Asin",[Xh]],["Asinh",[Jh]],["Atan",[Zh]],["Atanh",[Qh]],["AveragePool",[Lg,Mg]],["BiasAdd",[Hh]],["BiasSplitGelu",[Im]],["Cast",[tm,em]],["Ceil",[nm]],["ClipV10",[Ds]],["Clip",[rm]],["Concat",[Lm,Nm]],["Conv",[Xm,Ym]],["ConvTranspose",[rg,tg]],["Cos",[om]],["Cosh",[im]],["Div",[Am]],["Einsum",[ig,ag]],["Elu",[am,Pi]],["Equal",[Om]],["Erf",[sm]],["Exp",[um]],["Expand",[lg]],["Floor",[lm]],["Gather",[fg,dg]],["GatherElements",[mg,hg]],["Gelu",[cm]],["Gemm",[bg,yg]],["GlobalAveragePool",[zg,Fg]],["GlobalMaxPool",[Hg,Ug]],["Greater",[Dm]],["GreaterOrEqual",[Bm]],["InstanceNormalization",[Tg,wg]],["LayerNormalization",[Sg,Ig]],["LeakyRelu",[dm,Pi]],["Less",[km]],["LessOrEqual",[Rm]],["Log",[$m]],["MatMul",[Ag]],["MaxPool",[Wg,Vg]],["Mul",[Em]],["Neg",[pm]],["Not",[fm]],["Pad",[Eg,Cg]],["Pow",[Cm]],["Range",[qg]],["Reciprocal",[hm]],["ReduceMin",[Mh,qt]],["ReduceMean",[Rh,qt]],["ReduceMax",[Bh,qt]],["ReduceSum",[Nh,qt]],["ReduceProd",[Lh,qt]],["ReduceL1",[Ph,qt]],["ReduceL2",[Dh,qt]],["ReduceLogSum",[Ch,qt]],["ReduceLogSumExp",[kh,qt]],["ReduceSumSquare",[Fh,qt]],["Relu",[mm]],["Resize",[Yg,Xg]],["Sigmoid",[gm]],["Sin",[bm]],["Sinh",[ym]],["Slice",[rb,nb]],["SkipLayerNormalization",[Zg,Qg]],["Split",[ub,lb]],["Sqrt",[vm]],["Softmax",[ib,ab]],["Sub",[Pm]],["Tan",[xm]],["Tanh",[wm]],["ThresholdedRelu",[Tm,Pi]],["Tile",[fb]],["Transpose",[Hm,jm]],["Where",[hb]]])});var Ui,yb=k(()=>{"use strict";dt();Ar();Ge();Ui=class{constructor(e){this.backend=e;this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,r){this.repo.set(e,r)}run(e,r,t,o,i,s,a){let u=this.backend.device,l=this.backend.getComputePassEncoder(),d=this.backend.supportTimestampQuery&&this.backend.env.webgpu.profilingMode==="default";d&&l.writeTimestamp(this.backend.profilingQuerySet,0),l.setPipeline(e.computePipeline);let p=[];for(let g of o)p.push({binding:p.length,resource:{buffer:g.buffer}});for(let g of i)p.push({binding:p.length,resource:{buffer:g.buffer}});a&&p.push({binding:p.length,resource:a});let h=u.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:p,label:e.programInfo.name});if(l.setBindGroup(0,h),l.dispatchWorkgroups(...s),this.backend.pendingDispatchNumber++,d){l.writeTimestamp(this.backend.profilingQuerySet,1),this.backend.profilingQueryData==null&&(this.backend.profilingQueryData=this.backend.gpuDataManager.create(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let g=this.backend.gpuDataManager.create(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.profilingQuerySet,0,2,this.backend.profilingQueryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.profilingQueryData.buffer,0,g.buffer,0,16),this.backend.flush();let y=this.backend.currentKernelId,b=this.backend.kernels.get(y),w=`[${b[0]}] ${b[1]}`;g.buffer.mapAsync(GPUMapMode.READ).then(()=>{let I=new BigUint64Array(g.buffer.getMappedRange()),O=I[0],E=I[1];g.buffer.unmap(),typeof this.backend.profilingTimeBase>"u"&&(this.backend.profilingTimeBase=O);let N=Number(O-this.backend.profilingTimeBase),F=Number(E-this.backend.profilingTimeBase);if(!Number.isSafeInteger(N)||!Number.isSafeInteger(F))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(g.id);let R="";r.forEach((K,J)=>{R+=`input[${J}]: [${K.dims}] | ${oo(K.dataType)}, `});let V="";t.forEach((K,J)=>{V+=`output[${J}]: [${K.dims}] | ${oo(K.dataType)}, `}),console.log(`[profiling] kernel "${y}|${w}" ${R}${V}execution time: ${F-N} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(e,r){let t=this.backend.device,o=[];t.features.has("shader-f16")&&o.push("enable f16;");let i=Eh(r),s=e.getShaderSource(i),a=`${o.join(`
`)}
${i.additionalImplementations}
${s}`,u=t.createShaderModule({code:a,label:e.name});Je("verbose",()=>`[WebGPU] shader code: ${a}`);let l=t.createComputePipeline({compute:{module:u,entryPoint:"main"},layout:"auto",label:e.name});return{programInfo:e,computePipeline:l}}normalizeDispatchGroupSize(e){let r=typeof e=="number"?e:e.x,t=typeof e=="number"?1:e.y||1,o=typeof e=="number"?1:e.z||1,i=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=i&&t<=i&&o<=i)return[r,t,o];let s=r*t*o,a=Math.ceil(Math.sqrt(s));if(a>i){if(a=Math.ceil(Math.cbrt(s)),a>i)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[a,a,a]}else return[a,a,1]}}});var G2,W2,Hi,vb=k(()=>{"use strict";Ar();Th();_h();bb();yb();G2=(n,e)=>{if(e.length!==n.length)throw new Error(`inputDependencies length ${e.length} is not equal to inputTensors length ${n.length}.`);let r=[];for(let t=0;t<n.length;++t){let o=n[t].dataType;switch(e[t]){case"none":{r.push("");break}case"type":{r.push(`${o}`);break}case"rank":{let i=n[t].dims.length;r.push(`${o};${i}`);break}case"dims":{let i=n[t].dims.join(",");r.push(`${o};${i}`);break}default:throw new Error(`unsupported input dependency: ${e[t]}`)}}return r.join("|")},W2=(n,e)=>{let r=n.name;return n.shaderCache?.hint&&(r+="["+n.shaderCache.hint+"]"),r+=`:${G2(e,n.shaderCache?.inputDependencies??new Array(e.length).fill("dims"))}`,r},Hi=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispatchNumber=0;this.supportTimestampQuery=!1;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(e){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let r=await navigator.gpu.requestAdapter();if(!r)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=e;let t=[],o={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:t};r.features.has("timestamp-query-inside-passes")&&(this.supportTimestampQuery=!0,t.push("timestamp-query-inside-passes")),r.features.has("shader-f16")&&t.push("shader-f16"),this.device=await r.requestDevice(o),this.gpuDataManager=Sh(this),this.programManager=new Ui(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,xh(e.logLevel,!!e.debug),this.device.onuncapturederror=i=>{i.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${i.error.message}`)},this.supportTimestampQuery&&(this.profilingQuerySet=this.device.createQuerySet({type:"timestamp",count:2})),Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){return this.computePassEncoder||(this.computePassEncoder=this.getCommandEncoder().beginComputePass()),this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}run(e,r,t,o,i){let s=[];for(let I=0;I<r.length;++I){let O=this.gpuDataManager.get(r[I].data);if(!O)throw new Error(`no GPU data for input: ${r[I].data}`);s[I]=O}let a=W2(e,r),u=this.programManager.getArtifact(a),{outputs:l,dispatchGroup:d,programUniforms:p}=e.getRunData(r),h=t.length===0?l.map((I,O)=>O):t;if(h.length!==l.length)throw new Error(`Output size ${h.length} must be equal to ${l.length}.`);let g=[],y=[];for(let I=0;I<l.length;++I){if(!Number.isInteger(h[I])||h[I]<-3||h[I]>=l.length)throw new Error(`Invalid output index: ${h[I]}`);if(h[I]===-3)continue;let O=h[I]===-1,E=h[I]===-2,N=O||E?i(l[I].dataType,l[I].dims):o(h[I],l[I].dataType,l[I].dims),F=this.gpuDataManager.get(N.data);if(!F)throw new Error(`no GPU data for output: ${N.data}`);if(O&&this.temporaryData.push(F),E){let R=this.kernelPersistentData.get(this.currentKernelId);R||(R=[],this.kernelPersistentData.set(this.currentKernelId,R)),R.push(F)}g.push(N),y.push(F)}let b;if(p){let I=0,O=0,E=[],N=1;p.forEach(V=>{let K=typeof V.data=="number"?[V.data]:V.data,J;switch(K.length){case 1:J=4;break;case 2:J=8;break;case 3:J=16;break;case 4:J=16;break;case 5:J=16;break;case 6:J=16;break;default:throw new Error(`unsupported data length: ${K.length}`)}(O===5||O===6)&&(J=16),J>N&&(N=J),I=Math.ceil(I/J)*J,O=K.length,E.push(I),I+=K.length*4}),I=Math.ceil(I/N)*N;let F=new ArrayBuffer(I);p.forEach((V,K)=>{let J=E[K],ge=typeof V.data=="number"?[V.data]:V.data;V.type==="int32"?new Int32Array(F,J,ge.length).set(ge):V.type==="uint32"?new Uint32Array(F,J,ge.length).set(ge):new Float32Array(F,J,ge.length).set(ge)});let R=this.gpuDataManager.create(I,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(R.buffer,0,F,0,I),this.gpuDataManager.release(R.id),b={offset:0,size:I,buffer:R.buffer}}let w=this.programManager.normalizeDispatchGroupSize(d);return u||(u=this.programManager.build(e,w),this.programManager.setArtifact(a,u)),Je("info",()=>`[ProgramManager] run "${e.name}" (key=${a}) with ${w[0]}x${w[1]}x${w[2]}`),this.programManager.run(u,r,g,s,y,w,b),g}upload(e,r){this.gpuDataManager.upload(e,r)}memcpy(e,r){this.gpuDataManager.memcpy(e,r)}async download(e,r){await this.gpuDataManager.download(e,r)}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,r,t,o){let i=gb.get(e);if(!i)throw new Error(`kernel not implemented: ${e}`);this.kernels.set(r,[e,o,i[0],[i[1],t]])}releaseKernel(e){let r=this.kernelPersistentData.get(e);if(r){for(let t of r)this.gpuDataManager.release(t.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,r,t){let o=this.kernels.get(e);if(!o)throw new Error(`kernel not created: ${e}`);let[i,s,a,u]=o;if(this.currentKernelId!==null)throw new Error(`kernel "[${i}] ${s}" is not allowed to be called recursively`);this.currentKernelId=e,u[0]&&(u[1]=u[0](u[1]),u[0]=void 0),Je("info",()=>`[WebGPU] Start to run kernel "[${i}] ${s}"...`);let l=this.env.debug;this.temporaryData=[];try{return l&&this.device.pushErrorScope("validation"),a(r,u[1]),0}catch(d){return t.push(Promise.resolve(`[WebGPU] Kernel "[${i}] ${s}" failed. ${d}`)),1}finally{l&&t.push(this.device.popErrorScope().then(d=>d?`GPU validation error for kernel "[${i}] ${s}": ${d.message}`:null));for(let d of this.temporaryData)this.gpuDataManager.release(d.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(e,r,t,o){let i=this.sessionExternalDataMapping.get(e);i||(i=new Map,this.sessionExternalDataMapping.set(e,i));let s=i.get(r),a=this.gpuDataManager.registerExternalBuffer(t,o,s?.[1]);return i.set(r,[a,t]),a}unregisterBuffers(e){let r=this.sessionExternalDataMapping.get(e);r&&(r.forEach(t=>this.gpuDataManager.unregisterExternalBuffer(t[1])),this.sessionExternalDataMapping.delete(e))}getBuffer(e){let r=this.gpuDataManager.get(e);if(!r)throw new Error(`no GPU data for buffer: ${e}`);return r.buffer}createDownloader(e,r,t){return async()=>{let o=await Is(this,e,r);return wh(o.buffer,t)}}}});var xb={};sn(xb,{init:()=>V2});var fo,Ws,V2,wb=k(()=>{"use strict";dt();vb();Ar();Ee();fo=class n{constructor(e,r,t,o){this.module=e;this.dataType=r;this.data=t;this.dims=o}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let e=W.size(this.dims);return e===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let e=W.size(this.dims);return e===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let e=W.size(this.dims);return e===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}reshape(e){if(W.size(e)!==W.size(this.dims))throw new Error("Invalid new shape");return new n(this.module,this.dataType,this.data,e)}},Ws=class{constructor(e,r,t){this.module=e;this.backend=r;this.customDataOffset=0;this.customDataSize=0;let o=e.HEAPU32,i=t>>2;this.opKernelContext=o[i++];let s=o[i++];this.outputCount=o[i++],this.customDataOffset=o[i++],this.customDataSize=o[i++];let a=[];for(let u=0;u<s;u++){let l=o[i++],d=o[i++],p=o[i++],h=[];for(let g=0;g<p;g++)h.push(o[i++]);a.push(new fo(e,l,d,h))}this.inputs=a}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(e,r){let t=r?.inputs?.map(a=>typeof a=="number"?this.inputs[a]:a)??this.inputs,o=r?.outputs??[],i=(a,u,l)=>new fo(this.module,u,this.output(a,l),l),s=(a,u)=>{let l=io(a);if(!l)throw new Error(`Unsupported data type: ${a}`);let d=l*W.size(u);return new fo(this.module,a,this.backend.gpuDataManager.create(d).id,u)};return this.backend.run(e,t,o,i,s)}output(e,r){let t=this.module.stackSave();try{let o=this.module.stackAlloc((1+r.length)*4),i=o>>2;this.module.HEAPU32[i++]=r.length;for(let s=0;s<r.length;s++)this.module.HEAPU32[i++]=r[s];return this.module._JsepOutput(this.opKernelContext,e,o)}catch(o){throw new Error(`Failed to generate kernel's output[${e}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${o}`)}finally{this.module.stackRestore(t)}}},V2=async(n,e)=>{let r=n.jsepInit;if(r&&navigator.gpu){if(!e.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let t=new Hi;await t.initialize(e),r(t,o=>t.alloc(o),o=>t.free(o),(o,i,s,a=!1)=>{if(a)Je("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${o}, dst=${i}, size=${s}`),t.memcpy(o,i);else{Je("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${o}, gpuDataId=${i}, size=${s}`);let u=n.HEAPU8.subarray(o,o+s);t.upload(i,u)}},async(o,i,s)=>{Je("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${o}, dataOffset=${i}, size=${s}`),await t.download(o,()=>n.HEAPU8.subarray(i,i+s))},(o,i,s)=>t.createKernel(o,i,s,e.debug||e.webgpu.profilingMode==="default"?n.UTF8ToString(n._JsepGetNodeName(i)):`${i}`),o=>t.releaseKernel(o),(o,i,s,a)=>{Je("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${s}, kernel=${o}, contextDataOffset=${i}`);let u=new Ws(n,t,i);return t.computeKernel(o,u,a)})}}});var U2,H2,$b,po,Vs,Us,Ib,Sb,Tb,_b,Ab,Ob,Eb=k(()=>{"use strict";mh();bh();dt();wn();$i();U2=n=>{let e=Qe(),r=e.stackSave();try{let t=e.stackAlloc(8);return e._OrtGetInputOutputCount(n,t,t+4)!==0&&qe("Can't get session input/output count."),[e.HEAP32[t/4],e.HEAP32[t/4+1]]}finally{e.stackRestore(r)}},H2=(n,e)=>{Qe()._OrtInit(n,e)!==0&&qe("Can't initialize onnxruntime.")},$b=async n=>{H2(n.wasm.numThreads,ao(n.logLevel));{let e=(wb(),vr(xb)).init;await e(Qe(),n)}},po=new Map,Vs=n=>{let e=Qe(),r=e._malloc(n.byteLength);if(r===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${n.byteLength}.`);return e.HEAPU8.set(n,r),[r,n.byteLength]},Us=(n,e)=>{let r=Qe(),t=0,o=0,i=0,s=[],a=[],u=[];try{[o,s]=gh(e),t=r._OrtCreateSession(n[0],n[1],o),t===0&&qe("Can't create a session.");let[l,d]=U2(t),p=[],h=[],g=[];for(let b=0;b<l;b++){let w=r._OrtGetInputName(t,b);w===0&&qe("Can't get an input name."),a.push(w),p.push(r.UTF8ToString(w))}for(let b=0;b<d;b++){let w=r._OrtGetOutputName(t,b);w===0&&qe("Can't get an output name."),u.push(w);let I=r.UTF8ToString(w);h.push(I);{let O=typeof e?.preferredOutputLocation=="string"?e.preferredOutputLocation:e?.preferredOutputLocation?.[I]??"cpu";if(O!=="cpu"&&O!=="cpu-pinned"&&O!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${O}.`);g.push(O)}}let y=null;return g.some(b=>b==="gpu-buffer")&&(i=r._OrtCreateBinding(t),i===0&&qe("Can't create IO binding."),y={handle:i,outputPreferredLocations:g,outputPreferredLocationsEncoded:g.map(b=>Ts(b))}),po.set(t,[t,a,u,y]),[t,p,h]}catch(l){throw a.forEach(d=>r._OrtFree(d)),u.forEach(d=>r._OrtFree(d)),i!==0&&r._OrtReleaseBinding(i),t!==0&&r._OrtReleaseSession(t),l}finally{r._free(n[0]),o!==0&&r._OrtReleaseSessionOptions(o),s.forEach(l=>r._free(l))}},Ib=(n,e)=>{let r=Vs(n);return Us(r,e)},Sb=n=>{let e=Qe(),r=po.get(n);if(!r)throw new Error(`cannot release session. invalid session id: ${n}`);let[t,o,i,s]=r;s&&e._OrtReleaseBinding(s.handle),e.jsepUnregisterBuffers?.(n),o.forEach(a=>e._OrtFree(a)),i.forEach(a=>e._OrtFree(a)),e._OrtReleaseSession(t),po.delete(n)},Tb=(n,e,r,t,o)=>{if(!n){e.push(0);return}let i=Qe(),s=n[0],a=n[1],u=n[3],l,d;if(s==="string"&&u==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(u==="gpu-buffer"){let g=n[2].gpuBuffer,y=io(ws(s));d=a.reduce((b,w)=>b*w,1)*y,l=i.jsepRegisterBuffer(t,o,g,d)}else{let g=n[2];if(Array.isArray(g)){d=4*g.length,l=i._malloc(d),r.push(l);let y=l/4;for(let b=0;b<g.length;b++){if(typeof g[b]!="string")throw new TypeError(`tensor data at index ${b} is not a string`);i.HEAPU32[y++]=nt(g[b],r)}}else d=g.byteLength,l=i._malloc(d),r.push(l),i.HEAPU8.set(new Uint8Array(g.buffer,g.byteOffset,d),l)}let p=i.stackSave(),h=i.stackAlloc(4*a.length);try{let g=h/4;a.forEach(b=>i.HEAP32[g++]=b);let y=i._OrtCreateTensor(ws(s),l,d,h,a.length,Ts(u));y===0&&qe(`Can't create tensor for input/output. session=${t}, index=${o}.`),e.push(y)}finally{i.stackRestore(p)}},_b=async(n,e,r,t,o,i)=>{let s=Qe(),a=po.get(n);if(!a)throw new Error(`cannot run inference. invalid session id: ${n}`);let[u,l,d,p]=a,h=e.length,g=t.length,y=0,b=[],w=[],I=[],O=[],E=s.stackSave(),N=s.stackAlloc(h*4),F=s.stackAlloc(h*4),R=s.stackAlloc(g*4),V=s.stackAlloc(g*4);try{[y,b]=hh(i);for(let te=0;te<h;te++)Tb(r[te],w,O,n,e[te]);for(let te=0;te<g;te++)Tb(o[te],I,O,n,h+t[te]);let K=N/4,J=F/4,ge=R/4,P=V/4;for(let te=0;te<h;te++)s.HEAPU32[K++]=w[te],s.HEAPU32[J++]=l[e[te]];for(let te=0;te<g;te++)s.HEAPU32[ge++]=I[te],s.HEAPU32[P++]=d[t[te]];if(p){let{handle:te,outputPreferredLocations:Z,outputPreferredLocationsEncoded:mt}=p;if(l.length!==h)throw new Error(`input count from feeds (${h}) is expected to be always equal to model's input count (${l.length}).`);for(let Ce=0;Ce<h;Ce++){let st=e[Ce];await s._OrtBindInput(te,l[st],w[Ce])!==0&&qe(`Can't bind input[${Ce}] for session=${n}.`)}for(let Ce=0;Ce<g;Ce++){let st=t[Ce];o[Ce]?.[3]?s._OrtBindOutput(te,d[st],I[Ce],0)!==0&&qe(`Can't bind pre-allocated output[${Ce}] for session=${n}.`):s._OrtBindOutput(te,d[st],0,mt[st])!==0&&qe(`Can't bind output[${Ce}] to ${Z[Ce]} for session=${n}.`)}}let oe;p?oe=await s._OrtRunWithBinding(u,p.handle,g,R,y):oe=await s._OrtRun(u,F,N,h,V,g,R,y),oe!==0&&qe("failed to call OrtRun().");let Ke=[];for(let te=0;te<g;te++){let Z=s.HEAPU32[R/4+te];if(Z===I[te]){Ke.push(o[te]);continue}let mt=s.stackSave(),Ce=s.stackAlloc(4*4),st=!1,Fe,ut=0;try{s._OrtGetTensorData(Z,Ce,Ce+4,Ce+8,Ce+12)!==0&&qe(`Can't access output tensor data on index ${te}.`);let gt=Ce/4,cr=s.HEAPU32[gt++];ut=s.HEAPU32[gt++];let H=s.HEAPU32[gt++],Te=s.HEAPU32[gt++],ke=[];for(let Ze=0;Ze<Te;Ze++)ke.push(s.HEAPU32[H/4+Ze]);s._OrtFree(H);let bt=ke.reduce((Ze,Ye)=>Ze*Ye,1);Fe=oo(cr);let wt=p?.outputPreferredLocations[t[te]];if(Fe==="string"){if(wt==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Ze=[],Ye=ut/4;for(let Tt=0;Tt<bt;Tt++){let Yt=s.HEAPU32[Ye++],Mt=Tt===bt-1?void 0:s.HEAPU32[Ye]-Yt;Ze.push(s.UTF8ToString(Yt,Mt))}Ke.push([Fe,ke,Ze,"cpu"])}else if(wt==="gpu-buffer"&&bt>0){let Ze=s.jsepGetBuffer(ut),Ye=io(cr);if(Ye===void 0||!Si(Fe))throw new Error(`Unsupported data type: ${Fe}`);st=!0,Ke.push([Fe,ke,{gpuBuffer:Ze,download:s.jsepCreateDownloader(Ze,bt*Ye,Fe),dispose:()=>{s._OrtReleaseTensor(Z)}},"gpu-buffer"])}else{let Ze=Ii(Fe),Ye=new Ze(bt);new Uint8Array(Ye.buffer,Ye.byteOffset,Ye.byteLength).set(s.HEAPU8.subarray(ut,ut+Ye.byteLength)),Ke.push([Fe,ke,Ye,"cpu"])}}finally{s.stackRestore(mt),Fe==="string"&&ut&&s._free(ut),st||s._OrtReleaseTensor(Z)}}return p&&s._OrtClearBoundOutputs(p.handle),Ke}finally{s.stackRestore(E),w.forEach(K=>s._OrtReleaseTensor(K)),I.forEach(K=>s._OrtReleaseTensor(K)),O.forEach(K=>s._free(K)),y!==0&&s._OrtReleaseRunOptions(y),b.forEach(K=>s._free(K))}},Ab=n=>{let e=Qe(),r=po.get(n);if(!r)throw new Error("invalid session id");let t=r[0],o=e._OrtEndProfiling(t);o===0&&qe("Can't get an profile file name."),e._OrtFree(o)},Ob=n=>{let e=[];for(let r of n){let t=r[2];!Array.isArray(t)&&"buffer"in t&&e.push(t.buffer)}return e}});var Cb=Ve((HB,q2)=>{q2.exports='/*!\n * ONNX Runtime Web v1.17.0\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n"use strict";(()=>{var qr=Object.defineProperty;var tu=Object.getOwnPropertyDescriptor;var ru=Object.getOwnPropertyNames;var nu=Object.prototype.hasOwnProperty;var H=(e,t)=>()=>(e&&(t=e(e=0)),t);var Kt=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),yr=(e,t)=>{for(var r in t)qr(e,r,{get:t[r],enumerable:!0})},ou=(e,t,r,i)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of ru(t))!nu.call(e,o)&&o!==r&&qr(e,o,{get:()=>t[o],enumerable:!(i=tu(t,o))||i.enumerable});return e};var Tt=e=>ou(qr({},"__esModule",{value:!0}),e);var Yr={};yr(Yr,{readFile:()=>au});var au,Xr=H(()=>{au=void 0});var Qr={};yr(Qr,{join:()=>iu});var iu,Jr=H(()=>{iu=void 0});var Qn=Kt((Xn,Zr)=>{"use strict";var Yn=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){var r=t,i,o;r.ready=new Promise((u,p)=>{i=u,o=p}),r.jsepInit=(u,p,h,S,T,k,F,ne)=>{r.Za=u,r.Oa=p,r.Qa=h,r.Ja=S,r.Pa=T,r.ra=k,r.Ra=F,r.Sa=ne,p=(Y,Q,ee)=>(...ce)=>{let pe=Ne,E=Q?.();ce=Y(...ce);let ie=Q?.();return E!==ie&&(Y=ie,ee(E),Q=ee=null),Ne!=pe?ir():ce},h=Y=>async(...Q)=>{try{if(r.Da)throw Error("Session already started");let ee=r.Da={Ta:Q[0],errors:[]},ce=await Y(...Q);if(r.Da!==ee)throw Error("Session mismatch");u.flush();let pe=ee.errors;if(0<pe.length){let E=await Promise.all(pe);if(E=E.filter(ie=>ie),0<E.length)throw Error(E.join(`\n`))}return ce}finally{r.Da=null}},r._OrtRun=h(p(r._OrtRun,()=>r._OrtRun,Y=>r._OrtRun=Y)),r._OrtRunWithBinding=h(p(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,Y=>r._OrtRunWithBinding=Y)),r._OrtBindInput=p(r._OrtBindInput,()=>r._OrtBindInput,Y=>r._OrtBindInput=Y),r.jsepRegisterBuffer=(Y,Q,ee,ce)=>u.registerBuffer(Y,Q,ee,ce),r.jsepUnregisterBuffers=Y=>{u.unregisterBuffers(Y)},r.jsepGetBuffer=Y=>u.getBuffer(Y),r.jsepCreateDownloader=(Y,Q,ee)=>u.createDownloader(Y,Q,ee)};var s=Object.assign({},r),l="./this.program",n=(u,p)=>{throw p},c=typeof window=="object",m=typeof importScripts=="function",g=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",C="",x,$,b;if(g){var w=(Xr(),Tt(Yr)),v=(Jr(),Tt(Qr));C=m?v.dirname(C)+"/":__dirname+"/",x=(u,p)=>(u=u.startsWith("file://")?new URL(u):v.normalize(u),w.readFileSync(u,p?void 0:"utf8")),b=u=>(u=x(u,!0),u.buffer||(u=new Uint8Array(u)),u),$=(u,p,h,S=!0)=>{u=u.startsWith("file://")?new URL(u):v.normalize(u),w.readFile(u,S?void 0:"utf8",(T,k)=>{T?h(T):p(S?k.buffer:k)})},!r.thisProgram&&1<process.argv.length&&(l=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),n=(u,p)=>{throw process.exitCode=u,p},r.inspect=()=>"[Emscripten Module object]"}else(c||m)&&(m?C=self.location.href:typeof document<"u"&&document.currentScript&&(C=document.currentScript.src),e&&(C=e),C.indexOf("blob:")!==0?C=C.substr(0,C.replace(/[?#].*/,"").lastIndexOf("/")+1):C="",x=u=>{var p=new XMLHttpRequest;return p.open("GET",u,!1),p.send(null),p.responseText},m&&(b=u=>{var p=new XMLHttpRequest;return p.open("GET",u,!1),p.responseType="arraybuffer",p.send(null),new Uint8Array(p.response)}),$=(u,p,h)=>{var S=new XMLHttpRequest;S.open("GET",u,!0),S.responseType="arraybuffer",S.onload=()=>{S.status==200||S.status==0&&S.response?p(S.response):h()},S.onerror=h,S.send(null)});var I=r.print||console.log.bind(console),B=r.printErr||console.error.bind(console);Object.assign(r,s),s=null,r.thisProgram&&(l=r.thisProgram),r.quit&&(n=r.quit);var z;r.wasmBinary&&(z=r.wasmBinary);var M=r.noExitRuntime||!0;typeof WebAssembly!="object"&&We("no native wasm support detected");var G,_,U=!1,V,j,le,R,X,Se;function q(){var u=G.buffer;r.HEAP8=j=new Int8Array(u),r.HEAP16=new Int16Array(u),r.HEAP32=R=new Int32Array(u),r.HEAPU8=le=new Uint8Array(u),r.HEAPU16=new Uint16Array(u),r.HEAPU32=X=new Uint32Array(u),r.HEAPF32=new Float32Array(u),r.HEAPF64=Se=new Float64Array(u)}var L=[],De=[],he=[];function Re(){var u=r.preRun.shift();L.unshift(u)}var we=0,Be=null,Ke=null;function We(u){throw r.onAbort&&r.onAbort(u),u="Aborted("+u+")",B(u),U=!0,V=1,u=new WebAssembly.RuntimeError(u+". Build with -sASSERTIONS for more info."),o(u),u}function nt(u){return u.startsWith("data:application/octet-stream;base64,")}var N;if(N="ort-wasm-simd.wasm",!nt(N)){var de=N;N=r.locateFile?r.locateFile(de,C):C+de}function ge(u){if(u==N&&z)return new Uint8Array(z);if(b)return b(u);throw"both async and sync fetching of the wasm failed"}function ze(u){if(!z&&(c||m)){if(typeof fetch=="function"&&!u.startsWith("file://"))return fetch(u,{credentials:"same-origin"}).then(p=>{if(!p.ok)throw"failed to load wasm binary file at \'"+u+"\'";return p.arrayBuffer()}).catch(()=>ge(u));if($)return new Promise((p,h)=>{$(u,S=>p(new Uint8Array(S)),h)})}return Promise.resolve().then(()=>ge(u))}function Ge(u,p,h){return ze(u).then(S=>WebAssembly.instantiate(S,p)).then(S=>S).then(h,S=>{B("failed to asynchronously prepare wasm: "+S),We(S)})}function Te(u,p){var h=N;return z||typeof WebAssembly.instantiateStreaming!="function"||nt(h)||h.startsWith("file://")||g||typeof fetch!="function"?Ge(h,u,p):fetch(h,{credentials:"same-origin"}).then(S=>WebAssembly.instantiateStreaming(S,u).then(p,function(T){return B("wasm streaming compile failed: "+T),B("falling back to ArrayBuffer instantiation"),Ge(h,u,p)}))}var Ae,Ue={910336:u=>{r.ra("Abs",u,void 0)},910387:u=>{r.ra("Neg",u,void 0)},910438:u=>{r.ra("Floor",u,void 0)},910491:u=>{r.ra("Ceil",u,void 0)},910543:u=>{r.ra("Reciprocal",u,void 0)},910601:u=>{r.ra("Sqrt",u,void 0)},910653:u=>{r.ra("Exp",u,void 0)},910704:u=>{r.ra("Erf",u,void 0)},910755:u=>{r.ra("Sigmoid",u,void 0)},910810:u=>{r.ra("Log",u,void 0)},910861:u=>{r.ra("Sin",u,void 0)},910912:u=>{r.ra("Cos",u,void 0)},910963:u=>{r.ra("Tan",u,void 0)},911014:u=>{r.ra("Asin",u,void 0)},911066:u=>{r.ra("Acos",u,void 0)},911118:u=>{r.ra("Atan",u,void 0)},911170:u=>{r.ra("Sinh",u,void 0)},911222:u=>{r.ra("Cosh",u,void 0)},911274:u=>{r.ra("Asinh",u,void 0)},911327:u=>{r.ra("Acosh",u,void 0)},911380:u=>{r.ra("Atanh",u,void 0)},911433:u=>{r.ra("Tanh",u,void 0)},911485:u=>{r.ra("Not",u,void 0)},911536:(u,p,h)=>{r.ra("ClipV10",u,{min:p,max:h})},911608:u=>{r.ra("Clip",u,void 0)},911660:(u,p)=>{r.ra("Elu",u,{alpha:p})},911718:u=>{r.ra("Relu",u,void 0)},911770:(u,p)=>{r.ra("LeakyRelu",u,{alpha:p})},911834:(u,p)=>{r.ra("ThresholdedRelu",u,{alpha:p})},911904:(u,p)=>{r.ra("Cast",u,{to:p})},911962:u=>{r.ra("Add",u,void 0)},912013:u=>{r.ra("Sub",u,void 0)},912064:u=>{r.ra("Mul",u,void 0)},912115:u=>{r.ra("Div",u,void 0)},912166:u=>{r.ra("Pow",u,void 0)},912217:u=>{r.ra("Equal",u,void 0)},912270:u=>{r.ra("Greater",u,void 0)},912325:u=>{r.ra("GreaterOrEqual",u,void 0)},912387:u=>{r.ra("Less",u,void 0)},912439:u=>{r.ra("LessOrEqual",u,void 0)},912498:(u,p,h,S,T)=>{r.ra("ReduceMean",u,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(R.subarray(T>>>0,T+S>>>0)):[]})},912662:(u,p,h,S,T)=>{r.ra("ReduceMax",u,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(R.subarray(T>>>0,T+S>>>0)):[]})},912825:(u,p,h,S,T)=>{r.ra("ReduceMin",u,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(R.subarray(T>>>0,T+S>>>0)):[]})},912988:(u,p,h,S,T)=>{r.ra("ReduceProd",u,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(R.subarray(T>>>0,T+S>>>0)):[]})},913152:(u,p,h,S,T)=>{r.ra("ReduceSum",u,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(R.subarray(T>>>0,T+S>>>0)):[]})},913315:(u,p,h,S,T)=>{r.ra("ReduceL1",u,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(R.subarray(T>>>0,T+S>>>0)):[]})},913477:(u,p,h,S,T)=>{r.ra("ReduceL2",u,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(R.subarray(T>>>0,T+S>>>0)):[]})},913639:(u,p,h,S,T)=>{r.ra("ReduceLogSum",u,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(R.subarray(T>>>0,T+S>>>0)):[]})},913805:(u,p,h,S,T)=>{r.ra("ReduceSumSquare",u,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(R.subarray(T>>>0,T+S>>>0)):[]})},913974:(u,p,h,S,T)=>{r.ra("ReduceLogSumExp",u,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(R.subarray(T>>>0,T+S>>>0)):[]})},914143:u=>{r.ra("Where",u,void 0)},914196:(u,p,h)=>{r.ra("Transpose",u,{perm:p?Array.from(R.subarray(h>>>0,h+p>>>0)):[]})},914309:(u,p,h,S,T,k,F,ne,Y,Q)=>{r.ra("Conv",u,{format:Y?"NHWC":"NCHW",auto_pad:p,dilations:[h],group:S,kernel_shape:[T],pads:[k,F],strides:[ne],w_is_const:()=>!!j[Q>>>0]})},914537:(u,p,h,S,T,k,F,ne,Y,Q,ee,ce,pe,E,ie)=>{r.ra("Conv",u,{format:E?"NHWC":"NCHW",auto_pad:p,dilations:[h,S],group:T,kernel_shape:[k,F],pads:[ne,Y,Q,ee],strides:[ce,pe],w_is_const:()=>!!j[ie>>>0]})},914796:(u,p,h,S,T,k,F,ne,Y,Q)=>{r.ra("Conv",u,{format:Y?"NHWC":"NCHW",auto_pad:p,dilations:[h],group:S,kernel_shape:[T],pads:[k,F],strides:[ne],w_is_const:()=>!!j[Q>>>0]})},915024:(u,p,h,S,T,k,F,ne,Y,Q,ee,ce,pe,E,ie)=>{r.ra("Conv",u,{format:E?"NHWC":"NCHW",auto_pad:p,dilations:[h,S],group:T,kernel_shape:[k,F],pads:[ne,Y,Q,ee],strides:[ce,pe],w_is_const:()=>!!j[ie>>>0]})},915283:(u,p,h,S,T,k,F,ne,Y,Q,ee,ce,pe,E)=>{r.ra("ConvTranspose",u,{format:Y?"NHWC":"NCHW",autoPad:p,dilations:[h],group:S,kernel_shape:[T],pads:[k,F],strides:[ne],wIsConst:()=>!!j[Q>>>0],outputPadding:ee?Array.from(R.subarray(ce>>>0,ce+ee>>>0)):[],outputShape:pe?Array.from(R.subarray(E>>>0,E+pe>>>0)):[]})},915663:(u,p,h,S,T,k,F,ne,Y,Q,ee,ce,pe)=>{r.ra("ConvTranspose",u,{format:ne?"NHWC":"NCHW",autoPad:p,dilations:Array.from(R.subarray(h>>>0,h+2>>>0)),group:S,kernelShape:Array.from(R.subarray(T>>>0,T+2>>>0)),pads:Array.from(R.subarray(k>>>0,k+4>>>0)),strides:Array.from(R.subarray(F>>>0,F+2>>>0)),wIsConst:()=>!!j[Y>>>0],outputPadding:0<Q?Array.from(R.subarray(ee>>>0,ee+Q>>>0)):[],outputShape:0<ce?Array.from(R.subarray(pe>>>0,pe+ce>>>0)):[]})},916186:(u,p,h,S,T,k,F,ne,Y,Q,ee,ce,pe,E)=>{r.ra("ConvTranspose",u,{format:Y?"NHWC":"NCHW",autoPad:p,dilations:[h],group:S,kernel_shape:[T],pads:[k,F],strides:[ne],wIsConst:()=>!!j[Q>>>0],outputPadding:ee?Array.from(R.subarray(ce>>>0,ce+ee>>>0)):[],outputShape:pe?Array.from(R.subarray(E>>>0,E+pe>>>0)):[]})},916566:(u,p,h,S,T,k,F,ne,Y,Q,ee,ce,pe)=>{r.ra("ConvTranspose",u,{format:ne?"NHWC":"NCHW",autoPad:p,dilations:Array.from(R.subarray(h>>>0,h+2>>>0)),group:S,kernelShape:Array.from(R.subarray(T>>>0,T+2>>>0)),pads:Array.from(R.subarray(k>>>0,k+4>>>0)),strides:Array.from(R.subarray(F>>>0,F+2>>>0)),wIsConst:()=>!!j[Y>>>0],outputPadding:0<Q?Array.from(R.subarray(ee>>>0,ee+Q>>>0)):[],outputShape:0<ce?Array.from(R.subarray(pe>>>0,pe+ce>>>0)):[]})},917089:(u,p)=>{r.ra("GlobalAveragePool",u,{format:p?"NHWC":"NCHW"})},917180:(u,p,h,S,T,k,F,ne,Y,Q,ee,ce,pe,E,ie,ye)=>{r.ra("AveragePool",u,{format:ye?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:S,storage_order:T,dilations:[k,F],kernel_shape:[ne,Y],pads:[Q,ee,ce,pe],strides:[E,ie]})},917464:(u,p)=>{r.ra("GlobalAveragePool",u,{format:p?"NHWC":"NCHW"})},917555:(u,p,h,S,T,k,F,ne,Y,Q,ee,ce,pe,E,ie,ye)=>{r.ra("AveragePool",u,{format:ye?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:S,storage_order:T,dilations:[k,F],kernel_shape:[ne,Y],pads:[Q,ee,ce,pe],strides:[E,ie]})},917839:(u,p)=>{r.ra("GlobalMaxPool",u,{format:p?"NHWC":"NCHW"})},917926:(u,p,h,S,T,k,F,ne,Y,Q,ee,ce,pe,E,ie,ye)=>{r.ra("MaxPool",u,{format:ye?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:S,storage_order:T,dilations:[k,F],kernel_shape:[ne,Y],pads:[Q,ee,ce,pe],strides:[E,ie]})},918206:(u,p)=>{r.ra("GlobalMaxPool",u,{format:p?"NHWC":"NCHW"})},918293:(u,p,h,S,T,k,F,ne,Y,Q,ee,ce,pe,E,ie,ye)=>{r.ra("MaxPool",u,{format:ye?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:S,storage_order:T,dilations:[k,F],kernel_shape:[ne,Y],pads:[Q,ee,ce,pe],strides:[E,ie]})},918573:(u,p,h,S,T)=>{r.ra("Gemm",u,{alpha:p,beta:h,transA:S,transB:T})},918677:u=>{r.ra("MatMul",u,void 0)},918731:(u,p,h,S)=>{r.ra("ArgMax",u,{keepDims:!!p,selectLastIndex:!!h,axis:S})},918839:(u,p,h,S)=>{r.ra("ArgMin",u,{keepDims:!!p,selectLastIndex:!!h,axis:S})},918947:(u,p)=>{r.ra("Softmax",u,{axis:p})},919010:(u,p)=>{r.ra("Concat",u,{axis:p})},919070:(u,p,h,S,T)=>{r.ra("Split",u,{axis:p,numOutputs:h,splitSizes:S?Array.from(R.subarray(T>>>0,T+S>>>0)):[]})},919215:u=>{r.ra("Expand",u,void 0)},919269:(u,p)=>{r.ra("Gather",u,{axis:Number(p)})},919340:(u,p)=>{r.ra("GatherElements",u,{axis:Number(p)})},919419:(u,p,h,S,T,k,F,ne,Y,Q,ee)=>{r.ra("Resize",u,{antialias:p,axes:h?Array.from(R.subarray(S>>>0,S+h>>>0)):[],coordinateTransformMode:Fe(T),cubicCoeffA:k,excludeOutside:F,extrapolationValue:ne,keepAspectRatioPolicy:Fe(Y),mode:Fe(Q),nearestMode:Fe(ee)})},919770:(u,p,h,S,T,k,F)=>{r.ra("Slice",u,{starts:p?Array.from(R.subarray(h>>>0,h+p>>>0)):[],ends:S?Array.from(R.subarray(T>>>0,T+S>>>0)):[],axes:k?Array.from(R.subarray(F>>>0,F+k>>>0)):[]})},920001:u=>{r.ra("Tile",u,void 0)},920053:(u,p,h)=>{r.ra("LayerNormalization",u,{axis:Number(p),epsilon:Number(h)})},920160:(u,p,h)=>{r.ra("InstanceNormalization",u,{epsilon:p,format:h?"NHWC":"NCHW"})},920274:(u,p,h)=>{r.ra("InstanceNormalization",u,{epsilon:p,format:h?"NHWC":"NCHW"})},920388:u=>{r.ra("Range",u,void 0)},920441:(u,p)=>{r.ra("Einsum",u,{equation:Fe(p)})},920522:(u,p,h,S,T)=>{r.ra("Pad",u,{mode:p,value:h,pads:S?Array.from(R.subarray(T>>>0,T+S>>>0)):[]})},920654:u=>{r.ra("Gelu",u,void 0)},920706:u=>{r.ra("BiasAdd",u,void 0)},920761:u=>{r.ra("BiasSplitGelu",u,void 0)},920822:(u,p)=>{r.ra("SkipLayerNormalization",u,{epsilon:p})},920903:u=>{r.Ra(u)},920937:(u,p)=>r.Sa(u,p,r.Da.Ta,r.Da.errors),921049:u=>r.Oa(u),921082:u=>r.Qa(u),921114:(u,p,h)=>{r.Ja(u,p,h,!0)},921153:(u,p,h)=>{r.Ja(u,p,h)}};function qe(u){this.name="ExitStatus",this.message=`Program terminated with exit(${u})`,this.status=u}var Ve=u=>{for(;0<u.length;)u.shift()(r)};function or(u){this.Ha=u-24,this.Ma=function(p){X[this.Ha+4>>2>>>0]=p},this.La=function(p){X[this.Ha+8>>2>>>0]=p},this.Ya=function(p,h){this.Ka(),this.Ma(p),this.La(h)},this.Ka=function(){X[this.Ha+16>>2>>>0]=0}}var Ot=0,Ye=0,_t=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,ot=(u,p,h)=>{p>>>=0;var S=p+h;for(h=p;u[h]&&!(h>=S);)++h;if(16<h-p&&u.buffer&&_t)return _t.decode(u.subarray(p,h));for(S="";p<h;){var T=u[p++];if(T&128){var k=u[p++]&63;if((T&224)==192)S+=String.fromCharCode((T&31)<<6|k);else{var F=u[p++]&63;T=(T&240)==224?(T&15)<<12|k<<6|F:(T&7)<<18|k<<12|F<<6|u[p++]&63,65536>T?S+=String.fromCharCode(T):(T-=65536,S+=String.fromCharCode(55296|T>>10,56320|T&1023))}}else S+=String.fromCharCode(T)}return S},Fe=(u,p)=>(u>>>=0)?ot(le,u,p):"",Pt=u=>{for(var p=0,h=0;h<u.length;++h){var S=u.charCodeAt(h);127>=S?p++:2047>=S?p+=2:55296<=S&&57343>=S?(p+=4,++h):p+=3}return p},wt=(u,p,h,S)=>{if(h>>>=0,!(0<S))return 0;var T=h;S=h+S-1;for(var k=0;k<u.length;++k){var F=u.charCodeAt(k);if(55296<=F&&57343>=F){var ne=u.charCodeAt(++k);F=65536+((F&1023)<<10)|ne&1023}if(127>=F){if(h>=S)break;p[h++>>>0]=F}else{if(2047>=F){if(h+1>=S)break;p[h++>>>0]=192|F>>6}else{if(65535>=F){if(h+2>=S)break;p[h++>>>0]=224|F>>12}else{if(h+3>=S)break;p[h++>>>0]=240|F>>18,p[h++>>>0]=128|F>>12&63}p[h++>>>0]=128|F>>6&63}p[h++>>>0]=128|F&63}}return p[h>>>0]=0,h-T},st=u=>u%4===0&&(u%100!==0||u%400===0),at=[0,31,60,91,121,152,182,213,244,274,305,335],vt=[0,31,59,90,120,151,181,212,243,273,304,334],dt=u=>{var p=Pt(u)+1,h=At(p);return h&&wt(u,le,h,p),h},ct=[],Rt=(u,p)=>{ct.length=0;var h;for(p>>=2;h=le[u++>>>0];)p+=h!=105&p,ct.push(h==105?R[p>>>0]:Se[p++>>>1]),++p;return ct},$t={},Bt=()=>{if(!xt){var u={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:l||"./this.program"},p;for(p in $t)$t[p]===void 0?delete u[p]:u[p]=$t[p];var h=[];for(p in u)h.push(`${p}=${u[p]}`);xt=h}return xt},xt,Xe=[null,[],[]],Mt=[31,29,31,30,31,30,31,31,30,31,30,31],Ct=[31,28,31,30,31,30,31,31,30,31,30,31];function oe(u){var p=Array(Pt(u)+1);return wt(u,p,0,p.length),p}function pt(u,p,h,S){function T(E,ie,ye){for(E=typeof E=="number"?E.toString():E||"";E.length<ie;)E=ye[0]+E;return E}function k(E,ie){return T(E,ie,"0")}function F(E,ie){function ye(jt){return 0>jt?-1:0<jt?1:0}var Qe;return(Qe=ye(E.getFullYear()-ie.getFullYear()))===0&&(Qe=ye(E.getMonth()-ie.getMonth()))===0&&(Qe=ye(E.getDate()-ie.getDate())),Qe}function ne(E){switch(E.getDay()){case 0:return new Date(E.getFullYear()-1,11,29);case 1:return E;case 2:return new Date(E.getFullYear(),0,3);case 3:return new Date(E.getFullYear(),0,2);case 4:return new Date(E.getFullYear(),0,1);case 5:return new Date(E.getFullYear()-1,11,31);case 6:return new Date(E.getFullYear()-1,11,30)}}function Y(E){var ie=E.Ba;for(E=new Date(new Date(E.Ca+1900,0,1).getTime());0<ie;){var ye=E.getMonth(),Qe=(st(E.getFullYear())?Mt:Ct)[ye];if(ie>Qe-E.getDate())ie-=Qe-E.getDate()+1,E.setDate(1),11>ye?E.setMonth(ye+1):(E.setMonth(0),E.setFullYear(E.getFullYear()+1));else{E.setDate(E.getDate()+ie);break}}return ye=new Date(E.getFullYear()+1,0,4),ie=ne(new Date(E.getFullYear(),0,4)),ye=ne(ye),0>=F(ie,E)?0>=F(ye,E)?E.getFullYear()+1:E.getFullYear():E.getFullYear()-1}u>>>=0,p>>>=0,h>>>=0,S>>>=0;var Q=R[S+40>>2>>>0];S={Wa:R[S>>2>>>0],Va:R[S+4>>2>>>0],Ea:R[S+8>>2>>>0],Ia:R[S+12>>2>>>0],Fa:R[S+16>>2>>>0],Ca:R[S+20>>2>>>0],wa:R[S+24>>2>>>0],Ba:R[S+28>>2>>>0],$a:R[S+32>>2>>>0],Ua:R[S+36>>2>>>0],Xa:Q?Fe(Q):""},h=Fe(h),Q={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ee in Q)h=h.replace(new RegExp(ee,"g"),Q[ee]);var ce="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),pe="January February March April May June July August September October November December".split(" ");Q={"%a":E=>ce[E.wa].substring(0,3),"%A":E=>ce[E.wa],"%b":E=>pe[E.Fa].substring(0,3),"%B":E=>pe[E.Fa],"%C":E=>k((E.Ca+1900)/100|0,2),"%d":E=>k(E.Ia,2),"%e":E=>T(E.Ia,2," "),"%g":E=>Y(E).toString().substring(2),"%G":E=>Y(E),"%H":E=>k(E.Ea,2),"%I":E=>(E=E.Ea,E==0?E=12:12<E&&(E-=12),k(E,2)),"%j":E=>{for(var ie=0,ye=0;ye<=E.Fa-1;ie+=(st(E.Ca+1900)?Mt:Ct)[ye++]);return k(E.Ia+ie,3)},"%m":E=>k(E.Fa+1,2),"%M":E=>k(E.Va,2),"%n":()=>`\n`,"%p":E=>0<=E.Ea&&12>E.Ea?"AM":"PM","%S":E=>k(E.Wa,2),"%t":()=>"	","%u":E=>E.wa||7,"%U":E=>k(Math.floor((E.Ba+7-E.wa)/7),2),"%V":E=>{var ie=Math.floor((E.Ba+7-(E.wa+6)%7)/7);if(2>=(E.wa+371-E.Ba-2)%7&&ie++,ie)ie==53&&(ye=(E.wa+371-E.Ba)%7,ye==4||ye==3&&st(E.Ca)||(ie=1));else{ie=52;var ye=(E.wa+7-E.Ba-1)%7;(ye==4||ye==5&&st(E.Ca%400-1))&&ie++}return k(ie,2)},"%w":E=>E.wa,"%W":E=>k(Math.floor((E.Ba+7-(E.wa+6)%7)/7),2),"%y":E=>(E.Ca+1900).toString().substring(2),"%Y":E=>E.Ca+1900,"%z":E=>{E=E.Ua;var ie=0<=E;return E=Math.abs(E)/60,(ie?"+":"-")+("0000"+(E/60*100+E%60)).slice(-4)},"%Z":E=>E.Xa,"%%":()=>"%"},h=h.replace(/%%/g,"\\0\\0");for(ee in Q)h.includes(ee)&&(h=h.replace(new RegExp(ee,"g"),Q[ee](S)));return h=h.replace(/\\0\\0/g,"%"),ee=oe(h),ee.length>p?0:(j.set(ee,u>>>0),ee.length-1)}function ft(u){try{u()}catch(p){We(p)}}function Nr(u){var p={},h;for(h in u)(function(S){var T=u[S];p[S]=typeof T=="function"?function(){mt.push(S);try{return T.apply(null,arguments)}finally{U||(mt.pop()===S||We(),Ne&&He===1&&mt.length===0&&(He=0,ft(It),typeof Fibers<"u"&&Fibers.ab()))}}:T})(h);return p}var He=0,Ne=null,kt=0,mt=[],Dt={},Wt={},zt=0,St=null,ar=[];function ir(){return new Promise((u,p)=>{St={resolve:u,reject:p}})}function sr(){var u=At(65548),p=u+12;X[u>>2>>>0]=p,X[u+4>>2>>>0]=p+65536,p=mt[0];var h=Dt[p];return h===void 0&&(h=zt++,Dt[p]=h,Wt[h]=p),R[u+8>>2>>>0]=h,u}function ur(u){if(!U){if(He===0){var p=!1,h=!1;u((S=0)=>{if(!U&&(kt=S,p=!0,h)){He=2,ft(()=>ht(Ne)),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.resume(),S=!1;try{var T=(0,_[Wt[R[Ne+8>>2>>>0]]])()}catch(ne){T=ne,S=!0}var k=!1;if(!Ne){var F=St;F&&(St=null,(S?F.reject:F.resolve)(T),k=!0)}if(S&&!k)throw T}}),h=!0,p||(He=1,Ne=sr(),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.pause(),ft(()=>Ht(Ne)))}else He===2?(He=0,ft(it),Gt(Ne),Ne=null,ar.forEach(S=>{if(!U)try{if(S(),!M)try{V=V=S=V,M||(r.onExit&&r.onExit(S),U=!0),n(S,new qe(S))}catch(T){T instanceof qe||T=="unwind"||n(1,T)}}catch(T){T instanceof qe||T=="unwind"||n(1,T)}})):We(`invalid state: ${He}`);return kt}}function lr(u){return ur(p=>{u().then(p)})}var dr={n:function(u,p,h){return lr(async()=>{await r.Pa(u,p,h)})},a:function(u,p,h){throw u>>>=0,new or(u).Ya(p>>>0,h>>>0),Ot=u,Ye++,Ot},g:function(){return 0},J:function(){},z:function(){},B:function(){},L:function(){return 0},H:function(){},C:function(){},G:function(){},l:function(){},A:function(){},x:function(){},I:function(){},y:function(){},m:()=>!0,q:function(u,p,h){u=p+2097152>>>0<4194305-!!u?(u>>>0)+4294967296*p:NaN,h>>>=0,u=new Date(1e3*u),R[h>>2>>>0]=u.getUTCSeconds(),R[h+4>>2>>>0]=u.getUTCMinutes(),R[h+8>>2>>>0]=u.getUTCHours(),R[h+12>>2>>>0]=u.getUTCDate(),R[h+16>>2>>>0]=u.getUTCMonth(),R[h+20>>2>>>0]=u.getUTCFullYear()-1900,R[h+24>>2>>>0]=u.getUTCDay(),R[h+28>>2>>>0]=(u.getTime()-Date.UTC(u.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(u,p,h){u=p+2097152>>>0<4194305-!!u?(u>>>0)+4294967296*p:NaN,h>>>=0,u=new Date(1e3*u),R[h>>2>>>0]=u.getSeconds(),R[h+4>>2>>>0]=u.getMinutes(),R[h+8>>2>>>0]=u.getHours(),R[h+12>>2>>>0]=u.getDate(),R[h+16>>2>>>0]=u.getMonth(),R[h+20>>2>>>0]=u.getFullYear()-1900,R[h+24>>2>>>0]=u.getDay(),R[h+28>>2>>>0]=(st(u.getFullYear())?at:vt)[u.getMonth()]+u.getDate()-1|0,R[h+36>>2>>>0]=-(60*u.getTimezoneOffset()),p=new Date(u.getFullYear(),6,1).getTimezoneOffset();var S=new Date(u.getFullYear(),0,1).getTimezoneOffset();R[h+32>>2>>>0]=(p!=S&&u.getTimezoneOffset()==Math.min(S,p))|0},s:function(u){u>>>=0;var p=new Date(R[u+20>>2>>>0]+1900,R[u+16>>2>>>0],R[u+12>>2>>>0],R[u+8>>2>>>0],R[u+4>>2>>>0],R[u>>2>>>0],0),h=R[u+32>>2>>>0],S=p.getTimezoneOffset(),T=new Date(p.getFullYear(),6,1).getTimezoneOffset(),k=new Date(p.getFullYear(),0,1).getTimezoneOffset(),F=Math.min(k,T);return 0>h?R[u+32>>2>>>0]=+(T!=k&&F==S):0<h!=(F==S)&&(T=Math.max(k,T),p.setTime(p.getTime()+6e4*((0<h?F:T)-S))),R[u+24>>2>>>0]=p.getDay(),R[u+28>>2>>>0]=(st(p.getFullYear())?at:vt)[p.getMonth()]+p.getDate()-1|0,R[u>>2>>>0]=p.getSeconds(),R[u+4>>2>>>0]=p.getMinutes(),R[u+8>>2>>>0]=p.getHours(),R[u+12>>2>>>0]=p.getDate(),R[u+16>>2>>>0]=p.getMonth(),R[u+20>>2>>>0]=p.getYear(),u=p.getTime()/1e3,Ut((Ae=u,1<=+Math.abs(Ae)?0<Ae?+Math.floor(Ae/4294967296)>>>0:~~+Math.ceil((Ae-+(~~Ae>>>0))/4294967296)>>>0:0)),u>>>0},o:function(){return-52},p:function(){},v:function(u,p,h){function S(Y){return(Y=Y.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?Y[1]:"GMT"}h>>>=0;var T=new Date().getFullYear(),k=new Date(T,0,1),F=new Date(T,6,1);T=k.getTimezoneOffset();var ne=F.getTimezoneOffset();X[u>>>0>>2>>>0]=60*Math.max(T,ne),R[p>>>0>>2>>>0]=+(T!=ne),u=S(k),p=S(F),u=dt(u),p=dt(p),ne<T?(X[h>>2>>>0]=u,X[h+4>>2>>>0]=p):(X[h>>2>>>0]=p,X[h+4>>2>>>0]=u)},e:()=>{We("")},b:function(u,p,h){return u>>>=0,p=Rt(p>>>0,h>>>0),Ue[u].apply(null,p)},i:function(u,p,h){return u>>>=0,p=Rt(p>>>0,h>>>0),Ue[u].apply(null,p)},h:function(){return Date.now()},w:function(){return 4294901760},c:()=>performance.now(),K:function(u,p,h){return p>>>=0,le.copyWithin(u>>>0>>>0,p>>>0,p+(h>>>0)>>>0)},u:function(u){u>>>=0;var p=le.length;if(4294901760<u)return!1;for(var h=1;4>=h;h*=2){var S=p*(1+.2/h);S=Math.min(S,u+100663296);var T=Math;S=Math.max(u,S);e:{T=T.min.call(T,4294901760,S+(65536-S%65536)%65536)-G.buffer.byteLength+65535>>>16;try{G.grow(T),q();var k=1;break e}catch{}k=void 0}if(k)return!0}return!1},D:function(u,p){u>>>=0,p>>>=0;var h=0;return Bt().forEach(function(S,T){var k=p+h;for(T=X[u+4*T>>2>>>0]=k,k=0;k<S.length;++k)j[T++>>0>>>0]=S.charCodeAt(k);j[T>>0>>>0]=0,h+=S.length+1}),0},E:function(u,p){u>>>=0,p>>>=0;var h=Bt();X[u>>2>>>0]=h.length;var S=0;return h.forEach(function(T){S+=T.length+1}),X[p>>2>>>0]=S,0},f:()=>52,k:function(){return 52},t:function(){return 70},j:function(u,p,h,S){p>>>=0,h>>>=0,S>>>=0;for(var T=0,k=0;k<h;k++){var F=X[p>>2>>>0],ne=X[p+4>>2>>>0];p+=8;for(var Y=0;Y<ne;Y++){var Q=le[F+Y>>>0],ee=Xe[u];Q===0||Q===10?((u===1?I:B)(ot(ee,0)),ee.length=0):ee.push(Q)}T+=ne}return X[S>>2>>>0]=T,0},F:pt,d:function(u,p,h,S){return pt(u>>>0,p>>>0,h>>>0,S>>>0)}};(function(){function u(h){if(h=h.exports,h=Nr(h),_=h=cr(h),G=_.M,q(),De.unshift(_.N),we--,r.monitorRunDependencies&&r.monitorRunDependencies(we),we==0&&(Be!==null&&(clearInterval(Be),Be=null),Ke)){var S=Ke;Ke=null,S()}return h}var p={a:dr};if(we++,r.monitorRunDependencies&&r.monitorRunDependencies(we),r.instantiateWasm)try{return r.instantiateWasm(p,u)}catch(h){B("Module.instantiateWasm callback failed with error: "+h),o(h)}return Te(p,function(h){u(h.instance)}).catch(o),{}})(),r._OrtInit=(u,p)=>(r._OrtInit=_.O)(u,p),r._OrtGetLastError=(u,p)=>(r._OrtGetLastError=_.P)(u,p),r._OrtCreateSessionOptions=(u,p,h,S,T,k,F,ne,Y,Q)=>(r._OrtCreateSessionOptions=_.Q)(u,p,h,S,T,k,F,ne,Y,Q),r._OrtAppendExecutionProvider=(u,p)=>(r._OrtAppendExecutionProvider=_.R)(u,p),r._OrtAddFreeDimensionOverride=(u,p,h)=>(r._OrtAddFreeDimensionOverride=_.S)(u,p,h),r._OrtAddSessionConfigEntry=(u,p,h)=>(r._OrtAddSessionConfigEntry=_.T)(u,p,h),r._OrtReleaseSessionOptions=u=>(r._OrtReleaseSessionOptions=_.U)(u),r._OrtCreateSession=(u,p,h)=>(r._OrtCreateSession=_.V)(u,p,h),r._OrtReleaseSession=u=>(r._OrtReleaseSession=_.W)(u),r._OrtGetInputOutputCount=(u,p,h)=>(r._OrtGetInputOutputCount=_.X)(u,p,h),r._OrtGetInputName=(u,p)=>(r._OrtGetInputName=_.Y)(u,p),r._OrtGetOutputName=(u,p)=>(r._OrtGetOutputName=_.Z)(u,p),r._OrtFree=u=>(r._OrtFree=_._)(u),r._OrtCreateTensor=(u,p,h,S,T,k)=>(r._OrtCreateTensor=_.$)(u,p,h,S,T,k),r._OrtGetTensorData=(u,p,h,S,T)=>(r._OrtGetTensorData=_.aa)(u,p,h,S,T),r._OrtReleaseTensor=u=>(r._OrtReleaseTensor=_.ba)(u),r._OrtCreateRunOptions=(u,p,h,S)=>(r._OrtCreateRunOptions=_.ca)(u,p,h,S),r._OrtAddRunConfigEntry=(u,p,h)=>(r._OrtAddRunConfigEntry=_.da)(u,p,h),r._OrtReleaseRunOptions=u=>(r._OrtReleaseRunOptions=_.ea)(u),r._OrtCreateBinding=u=>(r._OrtCreateBinding=_.fa)(u),r._OrtBindInput=(u,p,h)=>(r._OrtBindInput=_.ga)(u,p,h),r._OrtBindOutput=(u,p,h,S)=>(r._OrtBindOutput=_.ha)(u,p,h,S),r._OrtClearBoundOutputs=u=>(r._OrtClearBoundOutputs=_.ia)(u),r._OrtReleaseBinding=u=>(r._OrtReleaseBinding=_.ja)(u),r._OrtRunWithBinding=(u,p,h,S,T)=>(r._OrtRunWithBinding=_.ka)(u,p,h,S,T),r._OrtRun=(u,p,h,S,T,k,F,ne)=>(r._OrtRun=_.la)(u,p,h,S,T,k,F,ne),r._OrtEndProfiling=u=>(r._OrtEndProfiling=_.ma)(u),r._JsepOutput=(u,p,h)=>(r._JsepOutput=_.na)(u,p,h),r._JsepGetNodeName=u=>(r._JsepGetNodeName=_.oa)(u);var At=r._malloc=u=>(At=r._malloc=_.pa)(u),Gt=r._free=u=>(Gt=r._free=_.qa)(u),Ut=u=>(Ut=_.sa)(u),Nt=()=>(Nt=_.ta)(),Vt=u=>(Vt=_.ua)(u),Ft=u=>(Ft=_.va)(u),Ht=u=>(Ht=_.xa)(u),It=()=>(It=_.ya)(),ht=u=>(ht=_.za)(u),it=()=>(it=_.Aa)();r.___start_em_js=921186,r.___stop_em_js=921347;function cr(u){u=Object.assign({},u);var p=S=>()=>S()>>>0,h=S=>T=>S(T)>>>0;return u.__errno_location=p(u.__errno_location),u.malloc=h(u.malloc),u.stackSave=p(u.stackSave),u.stackAlloc=h(u.stackAlloc),u}r.stackAlloc=Ft,r.stackSave=Nt,r.stackRestore=Vt,r.UTF8ToString=Fe,r.stringToUTF8=(u,p,h)=>wt(u,le,p,h),r.lengthBytesUTF8=Pt;var gt;Ke=function u(){gt||Lt(),gt||(Ke=u)};function Lt(){function u(){if(!gt&&(gt=!0,r.calledRun=!0,!U)){if(Ve(De),i(r),r.onRuntimeInitialized&&r.onRuntimeInitialized(),r.postRun)for(typeof r.postRun=="function"&&(r.postRun=[r.postRun]);r.postRun.length;){var p=r.postRun.shift();he.unshift(p)}Ve(he)}}if(!(0<we)){if(r.preRun)for(typeof r.preRun=="function"&&(r.preRun=[r.preRun]);r.preRun.length;)Re();Ve(L),0<we||(r.setStatus?(r.setStatus("Running..."),setTimeout(function(){setTimeout(function(){r.setStatus("")},1),u()},1)):u())}}if(r.preInit)for(typeof r.preInit=="function"&&(r.preInit=[r.preInit]);0<r.preInit.length;)r.preInit.pop()();return Lt(),t.ready}})();typeof Xn=="object"&&typeof Zr=="object"?Zr.exports=Yn:typeof define=="function"&&define.amd&&define([],()=>Yn)});var Jn=Kt(()=>{});var Zn=Kt(()=>{});var eo={};yr(eo,{cpus:()=>su});var su,to=H(()=>{su=void 0});var oo=Kt((no,en)=>{"use strict";var ro=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){function r(){return q.buffer!=we.buffer&&N(),we}function i(){return q.buffer!=we.buffer&&N(),Be}function o(){return q.buffer!=we.buffer&&N(),Ke}function s(){return q.buffer!=we.buffer&&N(),We}function l(){return q.buffer!=we.buffer&&N(),nt}var n=t,c,m;n.ready=new Promise((a,d)=>{c=a,m=d}),n.jsepInit=(a,d,f,y,A,P,W,te)=>{n.Qb=a,n.wb=d,n.yb=f,n.jb=y,n.xb=A,n.Ea=P,n.zb=W,n.Ab=te,d=(Z,J,re)=>(...fe)=>{let be=Je,O=J?.();fe=Z(...fe);let ue=J?.();return O!==ue&&(Z=ue,re(O),J=re=null),Je!=be?Ks():fe},f=Z=>async(...J)=>{try{if(n.bb)throw Error("Session already started");let re=n.bb={Fb:J[0],errors:[]},fe=await Z(...J);if(n.bb!==re)throw Error("Session mismatch");a.flush();let be=re.errors;if(0<be.length){let O=await Promise.all(be);if(O=O.filter(ue=>ue),0<O.length)throw Error(O.join(`\n`))}return fe}finally{n.bb=null}},n._OrtRun=f(d(n._OrtRun,()=>n._OrtRun,Z=>n._OrtRun=Z)),n._OrtRunWithBinding=f(d(n._OrtRunWithBinding,()=>n._OrtRunWithBinding,Z=>n._OrtRunWithBinding=Z)),n._OrtBindInput=d(n._OrtBindInput,()=>n._OrtBindInput,Z=>n._OrtBindInput=Z),n.jsepRegisterBuffer=(Z,J,re,fe)=>a.registerBuffer(Z,J,re,fe),n.jsepUnregisterBuffers=Z=>{a.unregisterBuffers(Z)},n.jsepGetBuffer=Z=>a.getBuffer(Z),n.jsepCreateDownloader=(Z,J,re)=>a.createDownloader(Z,J,re)};var g=Object.assign({},n),C="./this.program",x=(a,d)=>{throw d},$=typeof window=="object",b=typeof importScripts=="function",w=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",v=n.ENVIRONMENT_IS_PTHREAD||!1,I="";function B(a){return n.locateFile?n.locateFile(a,I):I+a}var z,M,G;if(w){var _=(Xr(),Tt(Yr)),U=(Jr(),Tt(Qr));I=b?U.dirname(I)+"/":__dirname+"/",z=(d,f)=>(d=d.startsWith("file://")?new URL(d):U.normalize(d),_.readFileSync(d,f?void 0:"utf8")),G=d=>(d=z(d,!0),d.buffer||(d=new Uint8Array(d)),d),M=(d,f,y,A=!0)=>{d=d.startsWith("file://")?new URL(d):U.normalize(d),_.readFile(d,A?void 0:"utf8",(P,W)=>{P?y(P):f(A?W.buffer:W)})},!n.thisProgram&&1<process.argv.length&&(C=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),x=(d,f)=>{throw process.exitCode=d,f},n.inspect=()=>"[Emscripten Module object]";let a;try{a=Jn()}catch(d){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),d}global.Worker=a.Worker}else($||b)&&(b?I=self.location.href:typeof document<"u"&&document.currentScript&&(I=document.currentScript.src),typeof e<"u"&&e&&(I=e),I.indexOf("blob:")!==0?I=I.substr(0,I.replace(/[?#].*/,"").lastIndexOf("/")+1):I="",w||(z=a=>{var d=new XMLHttpRequest;return d.open("GET",a,!1),d.send(null),d.responseText},b&&(G=a=>{var d=new XMLHttpRequest;return d.open("GET",a,!1),d.responseType="arraybuffer",d.send(null),new Uint8Array(d.response)}),M=(a,d,f)=>{var y=new XMLHttpRequest;y.open("GET",a,!0),y.responseType="arraybuffer",y.onload=()=>{y.status==200||y.status==0&&y.response?d(y.response):f()},y.onerror=f,y.send(null)}));w&&typeof performance>"u"&&(global.performance=Zn().performance);var V=console.log.bind(console),j=console.error.bind(console);w&&(V=(...a)=>_.writeSync(1,a.join(" ")+`\n`),j=(...a)=>_.writeSync(2,a.join(" ")+`\n`));var le=n.print||V,R=n.printErr||j;Object.assign(n,g),g=null,n.thisProgram&&(C=n.thisProgram),n.quit&&(x=n.quit);var X;n.wasmBinary&&(X=n.wasmBinary);var Se=n.noExitRuntime||!0;typeof WebAssembly!="object"&&Ye("no native wasm support detected");var q,L,De,he=!1,Re,we,Be,Ke,We,nt;function N(){var a=q.buffer;n.HEAP8=we=new Int8Array(a),n.HEAP16=new Int16Array(a),n.HEAP32=Ke=new Int32Array(a),n.HEAPU8=Be=new Uint8Array(a),n.HEAPU16=new Uint16Array(a),n.HEAPU32=We=new Uint32Array(a),n.HEAPF32=new Float32Array(a),n.HEAPF64=nt=new Float64Array(a)}var de=n.INITIAL_MEMORY||16777216;if(5242880<=de||Ye("INITIAL_MEMORY should be larger than STACK_SIZE, was "+de+"! (STACK_SIZE=5242880)"),v)q=n.wasmMemory;else if(n.wasmMemory)q=n.wasmMemory;else if(q=new WebAssembly.Memory({initial:de/65536,maximum:65536,shared:!0}),!(q.buffer instanceof SharedArrayBuffer))throw R("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),w&&R("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");N(),de=q.buffer.byteLength;var ge=[],ze=[],Ge=[],Te=0;function Ae(){return Se||0<Te}var Ue=0,qe=null,Ve=null;function or(){Ue++,n.monitorRunDependencies&&n.monitorRunDependencies(Ue)}function Ot(){if(Ue--,n.monitorRunDependencies&&n.monitorRunDependencies(Ue),Ue==0&&(qe!==null&&(clearInterval(qe),qe=null),Ve)){var a=Ve;Ve=null,a()}}function Ye(a){throw n.onAbort&&n.onAbort(a),a="Aborted("+a+")",R(a),he=!0,Re=1,a=new WebAssembly.RuntimeError(a+". Build with -sASSERTIONS for more info."),m(a),a}function _t(a){return a.startsWith("data:application/octet-stream;base64,")}var ot;ot="ort-wasm-simd-threaded.wasm",_t(ot)||(ot=B(ot));function Fe(a){if(a==ot&&X)return new Uint8Array(X);if(G)return G(a);throw"both async and sync fetching of the wasm failed"}function Pt(a){if(!X&&($||b)){if(typeof fetch=="function"&&!a.startsWith("file://"))return fetch(a,{credentials:"same-origin"}).then(d=>{if(!d.ok)throw"failed to load wasm binary file at \'"+a+"\'";return d.arrayBuffer()}).catch(()=>Fe(a));if(M)return new Promise((d,f)=>{M(a,y=>d(new Uint8Array(y)),f)})}return Promise.resolve().then(()=>Fe(a))}function wt(a,d,f){return Pt(a).then(y=>WebAssembly.instantiate(y,d)).then(y=>y).then(f,y=>{R("failed to asynchronously prepare wasm: "+y),Ye(y)})}function st(a,d){var f=ot;return X||typeof WebAssembly.instantiateStreaming!="function"||_t(f)||f.startsWith("file://")||w||typeof fetch!="function"?wt(f,a,d):fetch(f,{credentials:"same-origin"}).then(y=>WebAssembly.instantiateStreaming(y,a).then(d,function(A){return R("wasm streaming compile failed: "+A),R("falling back to ArrayBuffer instantiation"),wt(f,a,d)}))}var at,vt={911532:a=>{n.Ea("Abs",a,void 0)},911583:a=>{n.Ea("Neg",a,void 0)},911634:a=>{n.Ea("Floor",a,void 0)},911687:a=>{n.Ea("Ceil",a,void 0)},911739:a=>{n.Ea("Reciprocal",a,void 0)},911797:a=>{n.Ea("Sqrt",a,void 0)},911849:a=>{n.Ea("Exp",a,void 0)},911900:a=>{n.Ea("Erf",a,void 0)},911951:a=>{n.Ea("Sigmoid",a,void 0)},912006:a=>{n.Ea("Log",a,void 0)},912057:a=>{n.Ea("Sin",a,void 0)},912108:a=>{n.Ea("Cos",a,void 0)},912159:a=>{n.Ea("Tan",a,void 0)},912210:a=>{n.Ea("Asin",a,void 0)},912262:a=>{n.Ea("Acos",a,void 0)},912314:a=>{n.Ea("Atan",a,void 0)},912366:a=>{n.Ea("Sinh",a,void 0)},912418:a=>{n.Ea("Cosh",a,void 0)},912470:a=>{n.Ea("Asinh",a,void 0)},912523:a=>{n.Ea("Acosh",a,void 0)},912576:a=>{n.Ea("Atanh",a,void 0)},912629:a=>{n.Ea("Tanh",a,void 0)},912681:a=>{n.Ea("Not",a,void 0)},912732:(a,d,f)=>{n.Ea("ClipV10",a,{min:d,max:f})},912804:a=>{n.Ea("Clip",a,void 0)},912856:(a,d)=>{n.Ea("Elu",a,{alpha:d})},912914:a=>{n.Ea("Relu",a,void 0)},912966:(a,d)=>{n.Ea("LeakyRelu",a,{alpha:d})},913030:(a,d)=>{n.Ea("ThresholdedRelu",a,{alpha:d})},913100:(a,d)=>{n.Ea("Cast",a,{to:d})},913158:a=>{n.Ea("Add",a,void 0)},913209:a=>{n.Ea("Sub",a,void 0)},913260:a=>{n.Ea("Mul",a,void 0)},913311:a=>{n.Ea("Div",a,void 0)},913362:a=>{n.Ea("Pow",a,void 0)},913413:a=>{n.Ea("Equal",a,void 0)},913466:a=>{n.Ea("Greater",a,void 0)},913521:a=>{n.Ea("GreaterOrEqual",a,void 0)},913583:a=>{n.Ea("Less",a,void 0)},913635:a=>{n.Ea("LessOrEqual",a,void 0)},913694:(a,d,f,y,A)=>{n.Ea("ReduceMean",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:y?Array.from(o().subarray(A>>>0,A+y>>>0)):[]})},913858:(a,d,f,y,A)=>{n.Ea("ReduceMax",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:y?Array.from(o().subarray(A>>>0,A+y>>>0)):[]})},914021:(a,d,f,y,A)=>{n.Ea("ReduceMin",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:y?Array.from(o().subarray(A>>>0,A+y>>>0)):[]})},914184:(a,d,f,y,A)=>{n.Ea("ReduceProd",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:y?Array.from(o().subarray(A>>>0,A+y>>>0)):[]})},914348:(a,d,f,y,A)=>{n.Ea("ReduceSum",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:y?Array.from(o().subarray(A>>>0,A+y>>>0)):[]})},914511:(a,d,f,y,A)=>{n.Ea("ReduceL1",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:y?Array.from(o().subarray(A>>>0,A+y>>>0)):[]})},914673:(a,d,f,y,A)=>{n.Ea("ReduceL2",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:y?Array.from(o().subarray(A>>>0,A+y>>>0)):[]})},914835:(a,d,f,y,A)=>{n.Ea("ReduceLogSum",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:y?Array.from(o().subarray(A>>>0,A+y>>>0)):[]})},915001:(a,d,f,y,A)=>{n.Ea("ReduceSumSquare",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:y?Array.from(o().subarray(A>>>0,A+y>>>0)):[]})},915170:(a,d,f,y,A)=>{n.Ea("ReduceLogSumExp",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:y?Array.from(o().subarray(A>>>0,A+y>>>0)):[]})},915339:a=>{n.Ea("Where",a,void 0)},915392:(a,d,f)=>{n.Ea("Transpose",a,{perm:d?Array.from(o().subarray(f>>>0,f+d>>>0)):[]})},915505:(a,d,f,y,A,P,W,te,Z,J)=>{n.Ea("Conv",a,{format:Z?"NHWC":"NCHW",auto_pad:d,dilations:[f],group:y,kernel_shape:[A],pads:[P,W],strides:[te],w_is_const:()=>!!r()[J>>>0]})},915733:(a,d,f,y,A,P,W,te,Z,J,re,fe,be,O,ue)=>{n.Ea("Conv",a,{format:O?"NHWC":"NCHW",auto_pad:d,dilations:[f,y],group:A,kernel_shape:[P,W],pads:[te,Z,J,re],strides:[fe,be],w_is_const:()=>!!r()[ue>>>0]})},915992:(a,d,f,y,A,P,W,te,Z,J)=>{n.Ea("Conv",a,{format:Z?"NHWC":"NCHW",auto_pad:d,dilations:[f],group:y,kernel_shape:[A],pads:[P,W],strides:[te],w_is_const:()=>!!r()[J>>>0]})},916220:(a,d,f,y,A,P,W,te,Z,J,re,fe,be,O,ue)=>{n.Ea("Conv",a,{format:O?"NHWC":"NCHW",auto_pad:d,dilations:[f,y],group:A,kernel_shape:[P,W],pads:[te,Z,J,re],strides:[fe,be],w_is_const:()=>!!r()[ue>>>0]})},916479:(a,d,f,y,A,P,W,te,Z,J,re,fe,be,O)=>{n.Ea("ConvTranspose",a,{format:Z?"NHWC":"NCHW",autoPad:d,dilations:[f],group:y,kernel_shape:[A],pads:[P,W],strides:[te],wIsConst:()=>!!r()[J>>>0],outputPadding:re?Array.from(o().subarray(fe>>>0,fe+re>>>0)):[],outputShape:be?Array.from(o().subarray(O>>>0,O+be>>>0)):[]})},916859:(a,d,f,y,A,P,W,te,Z,J,re,fe,be)=>{n.Ea("ConvTranspose",a,{format:te?"NHWC":"NCHW",autoPad:d,dilations:Array.from(o().subarray(f>>>0,f+2>>>0)),group:y,kernelShape:Array.from(o().subarray(A>>>0,A+2>>>0)),pads:Array.from(o().subarray(P>>>0,P+4>>>0)),strides:Array.from(o().subarray(W>>>0,W+2>>>0)),wIsConst:()=>!!r()[Z>>>0],outputPadding:0<J?Array.from(o().subarray(re>>>0,re+J>>>0)):[],outputShape:0<fe?Array.from(o().subarray(be>>>0,be+fe>>>0)):[]})},917382:(a,d,f,y,A,P,W,te,Z,J,re,fe,be,O)=>{n.Ea("ConvTranspose",a,{format:Z?"NHWC":"NCHW",autoPad:d,dilations:[f],group:y,kernel_shape:[A],pads:[P,W],strides:[te],wIsConst:()=>!!r()[J>>>0],outputPadding:re?Array.from(o().subarray(fe>>>0,fe+re>>>0)):[],outputShape:be?Array.from(o().subarray(O>>>0,O+be>>>0)):[]})},917762:(a,d,f,y,A,P,W,te,Z,J,re,fe,be)=>{n.Ea("ConvTranspose",a,{format:te?"NHWC":"NCHW",autoPad:d,dilations:Array.from(o().subarray(f>>>0,f+2>>>0)),group:y,kernelShape:Array.from(o().subarray(A>>>0,A+2>>>0)),pads:Array.from(o().subarray(P>>>0,P+4>>>0)),strides:Array.from(o().subarray(W>>>0,W+2>>>0)),wIsConst:()=>!!r()[Z>>>0],outputPadding:0<J?Array.from(o().subarray(re>>>0,re+J>>>0)):[],outputShape:0<fe?Array.from(o().subarray(be>>>0,be+fe>>>0)):[]})},918285:(a,d)=>{n.Ea("GlobalAveragePool",a,{format:d?"NHWC":"NCHW"})},918376:(a,d,f,y,A,P,W,te,Z,J,re,fe,be,O,ue,ve)=>{n.Ea("AveragePool",a,{format:ve?"NHWC":"NCHW",auto_pad:d,ceil_mode:f,count_include_pad:y,storage_order:A,dilations:[P,W],kernel_shape:[te,Z],pads:[J,re,fe,be],strides:[O,ue]})},918660:(a,d)=>{n.Ea("GlobalAveragePool",a,{format:d?"NHWC":"NCHW"})},918751:(a,d,f,y,A,P,W,te,Z,J,re,fe,be,O,ue,ve)=>{n.Ea("AveragePool",a,{format:ve?"NHWC":"NCHW",auto_pad:d,ceil_mode:f,count_include_pad:y,storage_order:A,dilations:[P,W],kernel_shape:[te,Z],pads:[J,re,fe,be],strides:[O,ue]})},919035:(a,d)=>{n.Ea("GlobalMaxPool",a,{format:d?"NHWC":"NCHW"})},919122:(a,d,f,y,A,P,W,te,Z,J,re,fe,be,O,ue,ve)=>{n.Ea("MaxPool",a,{format:ve?"NHWC":"NCHW",auto_pad:d,ceil_mode:f,count_include_pad:y,storage_order:A,dilations:[P,W],kernel_shape:[te,Z],pads:[J,re,fe,be],strides:[O,ue]})},919402:(a,d)=>{n.Ea("GlobalMaxPool",a,{format:d?"NHWC":"NCHW"})},919489:(a,d,f,y,A,P,W,te,Z,J,re,fe,be,O,ue,ve)=>{n.Ea("MaxPool",a,{format:ve?"NHWC":"NCHW",auto_pad:d,ceil_mode:f,count_include_pad:y,storage_order:A,dilations:[P,W],kernel_shape:[te,Z],pads:[J,re,fe,be],strides:[O,ue]})},919769:(a,d,f,y,A)=>{n.Ea("Gemm",a,{alpha:d,beta:f,transA:y,transB:A})},919873:a=>{n.Ea("MatMul",a,void 0)},919927:(a,d,f,y)=>{n.Ea("ArgMax",a,{keepDims:!!d,selectLastIndex:!!f,axis:y})},920035:(a,d,f,y)=>{n.Ea("ArgMin",a,{keepDims:!!d,selectLastIndex:!!f,axis:y})},920143:(a,d)=>{n.Ea("Softmax",a,{axis:d})},920206:(a,d)=>{n.Ea("Concat",a,{axis:d})},920266:(a,d,f,y,A)=>{n.Ea("Split",a,{axis:d,numOutputs:f,splitSizes:y?Array.from(o().subarray(A>>>0,A+y>>>0)):[]})},920411:a=>{n.Ea("Expand",a,void 0)},920465:(a,d)=>{n.Ea("Gather",a,{axis:Number(d)})},920536:(a,d)=>{n.Ea("GatherElements",a,{axis:Number(d)})},920615:(a,d,f,y,A,P,W,te,Z,J,re)=>{n.Ea("Resize",a,{antialias:d,axes:f?Array.from(o().subarray(y>>>0,y+f>>>0)):[],coordinateTransformMode:Xe(A),cubicCoeffA:P,excludeOutside:W,extrapolationValue:te,keepAspectRatioPolicy:Xe(Z),mode:Xe(J),nearestMode:Xe(re)})},920966:(a,d,f,y,A,P,W)=>{n.Ea("Slice",a,{starts:d?Array.from(o().subarray(f>>>0,f+d>>>0)):[],ends:y?Array.from(o().subarray(A>>>0,A+y>>>0)):[],axes:P?Array.from(o().subarray(W>>>0,W+P>>>0)):[]})},921197:a=>{n.Ea("Tile",a,void 0)},921249:(a,d,f)=>{n.Ea("LayerNormalization",a,{axis:Number(d),epsilon:Number(f)})},921356:(a,d,f)=>{n.Ea("InstanceNormalization",a,{epsilon:d,format:f?"NHWC":"NCHW"})},921470:(a,d,f)=>{n.Ea("InstanceNormalization",a,{epsilon:d,format:f?"NHWC":"NCHW"})},921584:a=>{n.Ea("Range",a,void 0)},921637:(a,d)=>{n.Ea("Einsum",a,{equation:Xe(d)})},921718:(a,d,f,y,A)=>{n.Ea("Pad",a,{mode:d,value:f,pads:y?Array.from(o().subarray(A>>>0,A+y>>>0)):[]})},921850:a=>{n.Ea("Gelu",a,void 0)},921902:a=>{n.Ea("BiasAdd",a,void 0)},921957:a=>{n.Ea("BiasSplitGelu",a,void 0)},922018:(a,d)=>{n.Ea("SkipLayerNormalization",a,{epsilon:d})},922099:a=>{n.zb(a)},922133:(a,d)=>n.Ab(a,d,n.bb.Fb,n.bb.errors),922245:a=>n.wb(a),922278:a=>n.yb(a),922310:(a,d,f)=>{n.jb(a,d,f,!0)},922349:(a,d,f)=>{n.jb(a,d,f)}};function dt(a){this.name="ExitStatus",this.message=`Program terminated with exit(${a})`,this.status=a}function ct(a){a.terminate(),a.onmessage=()=>{}}function Rt(a){(a=oe.Qa[a])||Ye(),oe.Eb(a)}function $t(a){var d=oe.tb();if(!d)return 6;oe.Ya.push(d),oe.Qa[a.Xa]=d,d.Xa=a.Xa;var f={cmd:"run",start_routine:a.Gb,arg:a.rb,pthread_ptr:a.Xa};return w&&d.unref(),d.postMessage(f,a.Mb),0}var Bt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,xt=(a,d,f)=>{d>>>=0;var y=d+f;for(f=d;a[f]&&!(f>=y);)++f;if(16<f-d&&a.buffer&&Bt)return Bt.decode(a.buffer instanceof SharedArrayBuffer?a.slice(d,f):a.subarray(d,f));for(y="";d<f;){var A=a[d++];if(A&128){var P=a[d++]&63;if((A&224)==192)y+=String.fromCharCode((A&31)<<6|P);else{var W=a[d++]&63;A=(A&240)==224?(A&15)<<12|P<<6|W:(A&7)<<18|P<<12|W<<6|a[d++]&63,65536>A?y+=String.fromCharCode(A):(A-=65536,y+=String.fromCharCode(55296|A>>10,56320|A&1023))}}else y+=String.fromCharCode(A)}return y},Xe=(a,d)=>(a>>>=0)?xt(i(),a,d):"";function Mt(a){if(v)return k(1,1,a);Re=a,Ae()||(oe.Hb(),n.onExit&&n.onExit(a),he=!0),x(a,new dt(a))}var Ct=a=>{if(Re=a,v)throw ft(a),"unwind";Mt(a)},oe={ab:[],Ya:[],mb:[],Qa:{},gb:function(){v?oe.vb():oe.ub()},ub:function(){ge.unshift(()=>{or(),oe.Bb(()=>Ot())})},vb:function(){oe.receiveObjectTransfer=oe.Db,oe.threadInitTLS=oe.lb,oe.setExitStatus=oe.kb,Se=!1},kb:function(a){Re=a},Sb:["$terminateWorker"],Hb:function(){for(var a of oe.Ya)ct(a);for(a of oe.ab)ct(a);oe.ab=[],oe.Ya=[],oe.Qa=[]},Eb:function(a){var d=a.Xa;delete oe.Qa[d],oe.ab.push(a),oe.Ya.splice(oe.Ya.indexOf(a),1),a.Xa=0,Hr(d)},Db:function(){},lb:function(){oe.mb.forEach(a=>a())},Cb:a=>new Promise(d=>{a.onmessage=P=>{P=P.data;var W=P.cmd;if(P.targetThread&&P.targetThread!=mr()){var te=oe.Qa[P.Rb];te?te.postMessage(P,P.transferList):R(\'Internal error! Worker sent a message "\'+W+\'" to target pthread \'+P.targetThread+", but that thread no longer exists!")}else W==="checkMailbox"?ht():W==="spawnThread"?$t(P):W==="cleanupThread"?Rt(P.thread):W==="killThread"?(P=P.thread,W=oe.Qa[P],delete oe.Qa[P],ct(W),Hr(P),oe.Ya.splice(oe.Ya.indexOf(W),1),W.Xa=0):W==="cancelThread"?oe.Qa[P.thread].postMessage({cmd:"cancel"}):W==="loaded"?(a.loaded=!0,d(a)):W==="alert"?alert("Thread "+P.threadId+": "+P.text):P.target==="setimmediate"?a.postMessage(P):W==="callHandler"?n[P.handler](...P.args):W&&R("worker sent an unknown command "+W)},a.onerror=P=>{throw R("worker sent an error! "+P.filename+":"+P.lineno+": "+P.message),P},w&&(a.on("message",function(P){a.onmessage({data:P})}),a.on("error",function(P){a.onerror(P)}));var f=[],y=["onExit","onAbort","print","printErr"],A;for(A of y)n.hasOwnProperty(A)&&f.push(A);a.postMessage({cmd:"load",handlers:f,urlOrBlob:n.mainScriptUrlOrBlob||e,wasmMemory:q,wasmModule:De})}),Bb:function(a){a()},qb:function(){var a=B("ort-wasm-simd-threaded.worker.js");a=new Worker(a),oe.ab.push(a)},tb:function(){return oe.ab.length==0&&(oe.qb(),oe.Cb(oe.ab[0])),oe.ab.pop()}};n.PThread=oe;var pt=a=>{for(;0<a.length;)a.shift()(n)};n.establishStackSpace=function(){var a=mr(),d=o()[a+52>>2>>>0];a=o()[a+56>>2>>>0],Nn(d,d-a),hr(d)};function ft(a){if(v)return k(2,0,a);Ct(a)}n.invokeEntryPoint=function(a,d){a=Vn.apply(null,[a,d]),Ae()?oe.kb(a):Lr(a)};function Nr(a){this.fb=a-24,this.pb=function(d){s()[this.fb+4>>2>>>0]=d},this.ob=function(d){s()[this.fb+8>>2>>>0]=d},this.gb=function(d,f){this.nb(),this.pb(d),this.ob(f)},this.nb=function(){s()[this.fb+16>>2>>>0]=0}}var He=0,Ne=0;function kt(a,d,f,y){return v?k(3,1,a,d,f,y):mt(a,d,f,y)}function mt(a,d,f,y){if(a>>>=0,d>>>=0,f>>>=0,y>>>=0,typeof SharedArrayBuffer>"u")return R("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var A=[];return v&&A.length===0?kt(a,d,f,y):(a={Gb:f,Xa:a,rb:y,Mb:A},v?(a.Ob="spawnThread",postMessage(a,A),0):$t(a))}function Dt(a,d,f){return v?k(4,1,a,d,f):0}function Wt(a,d){if(v)return k(5,1,a,d)}var zt=a=>{for(var d=0,f=0;f<a.length;++f){var y=a.charCodeAt(f);127>=y?d++:2047>=y?d+=2:55296<=y&&57343>=y?(d+=4,++f):d+=3}return d},St=(a,d,f,y)=>{if(f>>>=0,!(0<y))return 0;var A=f;y=f+y-1;for(var P=0;P<a.length;++P){var W=a.charCodeAt(P);if(55296<=W&&57343>=W){var te=a.charCodeAt(++P);W=65536+((W&1023)<<10)|te&1023}if(127>=W){if(f>=y)break;d[f++>>>0]=W}else{if(2047>=W){if(f+1>=y)break;d[f++>>>0]=192|W>>6}else{if(65535>=W){if(f+2>=y)break;d[f++>>>0]=224|W>>12}else{if(f+3>=y)break;d[f++>>>0]=240|W>>18,d[f++>>>0]=128|W>>12&63}d[f++>>>0]=128|W>>6&63}d[f++>>>0]=128|W&63}}return d[f>>>0]=0,f-A},ar=(a,d,f)=>St(a,i(),d,f);function ir(a,d){if(v)return k(6,1,a,d)}function sr(a,d,f){if(v)return k(7,1,a,d,f)}function ur(a,d,f){return v?k(8,1,a,d,f):0}function lr(a,d){if(v)return k(9,1,a,d)}function dr(a,d,f){if(v)return k(10,1,a,d,f)}function At(a,d,f,y){if(v)return k(11,1,a,d,f,y)}function Gt(a,d,f,y){if(v)return k(12,1,a,d,f,y)}function Ut(a,d,f,y){if(v)return k(13,1,a,d,f,y)}function Nt(a){if(v)return k(14,1,a)}function Vt(a,d){if(v)return k(15,1,a,d)}function Ft(a,d,f){if(v)return k(16,1,a,d,f)}var Ht=a=>{if(!he)try{if(a(),!Ae())try{v?Lr(Re):Ct(Re)}catch(d){d instanceof dt||d=="unwind"||x(1,d)}}catch(d){d instanceof dt||d=="unwind"||x(1,d)}};function It(a){a>>>=0,typeof Atomics.Nb=="function"&&(Atomics.Nb(o(),a>>2,a).value.then(ht),a+=128,Atomics.store(o(),a>>2,1))}n.__emscripten_thread_mailbox_await=It;function ht(){var a=mr();a&&(It(a),Ht(()=>Gn()))}n.checkMailbox=ht;var it=a=>a%4===0&&(a%100!==0||a%400===0),cr=[0,31,60,91,121,152,182,213,244,274,305,335],gt=[0,31,59,90,120,151,181,212,243,273,304,334];function Lt(a,d,f,y,A,P,W,te){return v?k(17,1,a,d,f,y,A,P,W,te):-52}function u(a,d,f,y,A,P,W){if(v)return k(18,1,a,d,f,y,A,P,W)}var p=a=>{var d=zt(a)+1,f=Fr(d);return f&&ar(a,f,d),f},h=[],S=(a,d)=>{h.length=0;var f;for(d>>=2;f=i()[a++>>>0];)d+=f!=105&d,h.push(f==105?o()[d>>>0]:l()[d++>>>1]),++d;return h},T=a=>{var d=jr();return a=a(),hr(d),a};function k(a,d){var f=arguments.length-2,y=arguments;return T(()=>{for(var A=Kr(8*f),P=A>>3,W=0;W<f;W++){var te=y[2+W];l()[P+W>>>0]=te}return zn(a,f,A,d)})}var F=[],ne={},Y=()=>{if(!Q){var a={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:C||"./this.program"},d;for(d in ne)ne[d]===void 0?delete a[d]:a[d]=ne[d];var f=[];for(d in a)f.push(`${d}=${a[d]}`);Q=f}return Q},Q;function ee(a,d){if(v)return k(19,1,a,d);a>>>=0,d>>>=0;var f=0;return Y().forEach(function(y,A){var P=d+f;for(A=s()[a+4*A>>2>>>0]=P,P=0;P<y.length;++P)r()[A++>>0>>>0]=y.charCodeAt(P);r()[A>>0>>>0]=0,f+=y.length+1}),0}function ce(a,d){if(v)return k(20,1,a,d);a>>>=0,d>>>=0;var f=Y();s()[a>>2>>>0]=f.length;var y=0;return f.forEach(function(A){y+=A.length+1}),s()[d>>2>>>0]=y,0}function pe(a){return v?k(21,1,a):52}function E(a,d,f,y){return v?k(22,1,a,d,f,y):52}function ie(a,d,f,y,A){return v?k(23,1,a,d,f,y,A):70}var ye=[null,[],[]];function Qe(a,d,f,y){if(v)return k(24,1,a,d,f,y);d>>>=0,f>>>=0,y>>>=0;for(var A=0,P=0;P<f;P++){var W=s()[d>>2>>>0],te=s()[d+4>>2>>>0];d+=8;for(var Z=0;Z<te;Z++){var J=i()[W+Z>>>0],re=ye[a];J===0||J===10?((a===1?le:R)(xt(re,0)),re.length=0):re.push(J)}A+=te}return s()[y>>2>>>0]=A,0}var jt=[31,29,31,30,31,30,31,31,30,31,30,31],Pn=[31,28,31,30,31,30,31,31,30,31,30,31];function Vs(a){var d=Array(zt(a)+1);return St(a,d,0,d.length),d}var Fs=(a,d)=>{r().set(a,d>>>0)};function Rn(a,d,f,y){function A(O,ue,ve){for(O=typeof O=="number"?O.toString():O||"";O.length<ue;)O=ve[0]+O;return O}function P(O,ue){return A(O,ue,"0")}function W(O,ue){function ve(qn){return 0>qn?-1:0<qn?1:0}var yt;return(yt=ve(O.getFullYear()-ue.getFullYear()))===0&&(yt=ve(O.getMonth()-ue.getMonth()))===0&&(yt=ve(O.getDate()-ue.getDate())),yt}function te(O){switch(O.getDay()){case 0:return new Date(O.getFullYear()-1,11,29);case 1:return O;case 2:return new Date(O.getFullYear(),0,3);case 3:return new Date(O.getFullYear(),0,2);case 4:return new Date(O.getFullYear(),0,1);case 5:return new Date(O.getFullYear()-1,11,31);case 6:return new Date(O.getFullYear()-1,11,30)}}function Z(O){var ue=O.Za;for(O=new Date(new Date(O.$a+1900,0,1).getTime());0<ue;){var ve=O.getMonth(),yt=(it(O.getFullYear())?jt:Pn)[ve];if(ue>yt-O.getDate())ue-=yt-O.getDate()+1,O.setDate(1),11>ve?O.setMonth(ve+1):(O.setMonth(0),O.setFullYear(O.getFullYear()+1));else{O.setDate(O.getDate()+ue);break}}return ve=new Date(O.getFullYear()+1,0,4),ue=te(new Date(O.getFullYear(),0,4)),ve=te(ve),0>=W(ue,O)?0>=W(ve,O)?O.getFullYear()+1:O.getFullYear():O.getFullYear()-1}a>>>=0,d>>>=0,f>>>=0,y>>>=0;var J=o()[y+40>>2>>>0];y={Kb:o()[y>>2>>>0],Jb:o()[y+4>>2>>>0],cb:o()[y+8>>2>>>0],ib:o()[y+12>>2>>>0],eb:o()[y+16>>2>>>0],$a:o()[y+20>>2>>>0],Wa:o()[y+24>>2>>>0],Za:o()[y+28>>2>>>0],Tb:o()[y+32>>2>>>0],Ib:o()[y+36>>2>>>0],Lb:J?Xe(J):""},f=Xe(f),J={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var re in J)f=f.replace(new RegExp(re,"g"),J[re]);var fe="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),be="January February March April May June July August September October November December".split(" ");J={"%a":O=>fe[O.Wa].substring(0,3),"%A":O=>fe[O.Wa],"%b":O=>be[O.eb].substring(0,3),"%B":O=>be[O.eb],"%C":O=>P((O.$a+1900)/100|0,2),"%d":O=>P(O.ib,2),"%e":O=>A(O.ib,2," "),"%g":O=>Z(O).toString().substring(2),"%G":O=>Z(O),"%H":O=>P(O.cb,2),"%I":O=>(O=O.cb,O==0?O=12:12<O&&(O-=12),P(O,2)),"%j":O=>{for(var ue=0,ve=0;ve<=O.eb-1;ue+=(it(O.$a+1900)?jt:Pn)[ve++]);return P(O.ib+ue,3)},"%m":O=>P(O.eb+1,2),"%M":O=>P(O.Jb,2),"%n":()=>`\n`,"%p":O=>0<=O.cb&&12>O.cb?"AM":"PM","%S":O=>P(O.Kb,2),"%t":()=>"	","%u":O=>O.Wa||7,"%U":O=>P(Math.floor((O.Za+7-O.Wa)/7),2),"%V":O=>{var ue=Math.floor((O.Za+7-(O.Wa+6)%7)/7);if(2>=(O.Wa+371-O.Za-2)%7&&ue++,ue)ue==53&&(ve=(O.Wa+371-O.Za)%7,ve==4||ve==3&&it(O.$a)||(ue=1));else{ue=52;var ve=(O.Wa+7-O.Za-1)%7;(ve==4||ve==5&&it(O.$a%400-1))&&ue++}return P(ue,2)},"%w":O=>O.Wa,"%W":O=>P(Math.floor((O.Za+7-(O.Wa+6)%7)/7),2),"%y":O=>(O.$a+1900).toString().substring(2),"%Y":O=>O.$a+1900,"%z":O=>{O=O.Ib;var ue=0<=O;return O=Math.abs(O)/60,(ue?"+":"-")+("0000"+(O/60*100+O%60)).slice(-4)},"%Z":O=>O.Lb,"%%":()=>"%"},f=f.replace(/%%/g,"\\0\\0");for(re in J)f.includes(re)&&(f=f.replace(new RegExp(re,"g"),J[re](y)));return f=f.replace(/\\0\\0/g,"%"),re=Vs(f),re.length>d?0:(Fs(re,a),re.length-1)}function pr(a){try{a()}catch(d){Ye(d)}}function Hs(a){var d={},f;for(f in a)(function(y){var A=a[y];d[y]=typeof A=="function"?function(){fr.push(y);try{return A.apply(null,arguments)}finally{he||(fr.pop()===y||Ye(),Je&&ut===1&&fr.length===0&&(ut=0,Te+=1,pr(Hn),typeof Fibers<"u"&&Fibers.Ub()))}}:A})(f);return d}var ut=0,Je=null,Bn=0,fr=[],Mn={},kn={},Ls=0,Vr=null,js=[];function Ks(){return new Promise((a,d)=>{Vr={resolve:a,reject:d}})}function qs(){var a=Fr(65548),d=a+12;s()[a>>2>>>0]=d,s()[a+4>>2>>>0]=d+65536,d=fr[0];var f=Mn[d];return f===void 0&&(f=Ls++,Mn[d]=f,kn[f]=d),d=f,o()[a+8>>2>>>0]=d,a}function Ys(){var a=o()[Je+8>>2>>>0];return a=L[kn[a]],--Te,a()}function Xs(a){if(!he){if(ut===0){var d=!1,f=!1;a((y=0)=>{if(!he&&(Bn=y,d=!0,f)){ut=2,pr(()=>Ln(Je)),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.resume(),y=!1;try{var A=Ys()}catch(te){A=te,y=!0}var P=!1;if(!Je){var W=Vr;W&&(Vr=null,(y?W.reject:W.resolve)(A),P=!0)}if(y&&!P)throw A}}),f=!0,d||(ut=1,Je=qs(),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.pause(),pr(()=>Fn(Je)))}else ut===2?(ut=0,pr(jn),Dn(Je),Je=null,js.forEach(y=>Ht(y))):Ye(`invalid state: ${ut}`);return Bn}}function Qs(a){return Xs(d=>{a().then(d)})}oe.gb();var Js=[null,Mt,ft,kt,Dt,Wt,ir,sr,ur,lr,dr,At,Gt,Ut,Nt,Vt,Ft,Lt,u,ee,ce,pe,E,ie,Qe],Zs={r:function(a,d,f){return Qs(async()=>{await n.xb(a,d,f)})},b:function(a,d,f){throw a>>>=0,new Nr(a).gb(d>>>0,f>>>0),He=a,Ne++,He},O:function(a){Wn(a>>>0,!b,1,!$,131072,!1),oe.lb()},l:function(a){a>>>=0,v?postMessage({cmd:"cleanupThread",thread:a}):Rt(a)},I:mt,i:Dt,U:Wt,E:ir,G:sr,V:ur,S:lr,K:dr,R:At,p:Gt,F:Ut,C:Nt,T:Vt,D:Ft,q:()=>!0,A:function(a,d){a>>>=0,a==d>>>0?setTimeout(()=>ht()):v?postMessage({targetThread:a,cmd:"checkMailbox"}):(a=oe.Qa[a])&&a.postMessage({cmd:"checkMailbox"})},M:function(){return-1},N:It,X:function(a){w&&oe.Qa[a>>>0].ref()},u:function(a,d,f){a=d+2097152>>>0<4194305-!!a?(a>>>0)+4294967296*d:NaN,f>>>=0,a=new Date(1e3*a),o()[f>>2>>>0]=a.getUTCSeconds(),o()[f+4>>2>>>0]=a.getUTCMinutes(),o()[f+8>>2>>>0]=a.getUTCHours(),o()[f+12>>2>>>0]=a.getUTCDate(),o()[f+16>>2>>>0]=a.getUTCMonth(),o()[f+20>>2>>>0]=a.getUTCFullYear()-1900,o()[f+24>>2>>>0]=a.getUTCDay(),a=(a.getTime()-Date.UTC(a.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,o()[f+28>>2>>>0]=a},v:function(a,d,f){a=d+2097152>>>0<4194305-!!a?(a>>>0)+4294967296*d:NaN,f>>>=0,a=new Date(1e3*a),o()[f>>2>>>0]=a.getSeconds(),o()[f+4>>2>>>0]=a.getMinutes(),o()[f+8>>2>>>0]=a.getHours(),o()[f+12>>2>>>0]=a.getDate(),o()[f+16>>2>>>0]=a.getMonth(),o()[f+20>>2>>>0]=a.getFullYear()-1900,o()[f+24>>2>>>0]=a.getDay(),d=(it(a.getFullYear())?cr:gt)[a.getMonth()]+a.getDate()-1|0,o()[f+28>>2>>>0]=d,o()[f+36>>2>>>0]=-(60*a.getTimezoneOffset()),d=new Date(a.getFullYear(),6,1).getTimezoneOffset();var y=new Date(a.getFullYear(),0,1).getTimezoneOffset();a=(d!=y&&a.getTimezoneOffset()==Math.min(y,d))|0,o()[f+32>>2>>>0]=a},w:function(a){a>>>=0;var d=new Date(o()[a+20>>2>>>0]+1900,o()[a+16>>2>>>0],o()[a+12>>2>>>0],o()[a+8>>2>>>0],o()[a+4>>2>>>0],o()[a>>2>>>0],0),f=o()[a+32>>2>>>0],y=d.getTimezoneOffset(),A=new Date(d.getFullYear(),6,1).getTimezoneOffset(),P=new Date(d.getFullYear(),0,1).getTimezoneOffset(),W=Math.min(P,A);return 0>f?o()[a+32>>2>>>0]=+(A!=P&&W==y):0<f!=(W==y)&&(A=Math.max(P,A),d.setTime(d.getTime()+6e4*((0<f?W:A)-y))),o()[a+24>>2>>>0]=d.getDay(),f=(it(d.getFullYear())?cr:gt)[d.getMonth()]+d.getDate()-1|0,o()[a+28>>2>>>0]=f,o()[a>>2>>>0]=d.getSeconds(),o()[a+4>>2>>>0]=d.getMinutes(),o()[a+8>>2>>>0]=d.getHours(),o()[a+12>>2>>>0]=d.getDate(),o()[a+16>>2>>>0]=d.getMonth(),o()[a+20>>2>>>0]=d.getYear(),a=d.getTime()/1e3,Un((at=a,1<=+Math.abs(at)?0<at?+Math.floor(at/4294967296)>>>0:~~+Math.ceil((at-+(~~at>>>0))/4294967296)>>>0:0)),a>>>0},s:Lt,t:u,z:function(a,d,f){function y(J){return(J=J.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?J[1]:"GMT"}a>>>=0,d>>>=0,f>>>=0;var A=new Date().getFullYear(),P=new Date(A,0,1),W=new Date(A,6,1);A=P.getTimezoneOffset();var te=W.getTimezoneOffset(),Z=Math.max(A,te);s()[a>>2>>>0]=60*Z,o()[d>>2>>>0]=+(A!=te),a=y(P),d=y(W),a=p(a),d=p(d),te<A?(s()[f>>2>>>0]=a,s()[f+4>>2>>>0]=d):(s()[f>>2>>>0]=d,s()[f+4>>2>>>0]=a)},d:()=>{Ye("")},c:function(a,d,f){return a>>>=0,d=S(d>>>0,f>>>0),vt[a].apply(null,d)},k:function(a,d,f){return a>>>=0,d=S(d>>>0,f>>>0),vt[a].apply(null,d)},m:function(){},j:function(){return Date.now()},W:()=>{throw Te+=1,"unwind"},B:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),g:function(){return w?(to(),Tt(eo)).cpus().length:navigator.hardwareConcurrency},L:function(a,d,f,y){for(oe.Pb=d>>>0,F.length=f,d=y>>>0>>3,y=0;y<f;y++)F[y]=l()[d+y>>>0];return(0>a?vt[-a-1]:Js[a]).apply(null,F)},y:function(a){a>>>=0;var d=i().length;if(a<=d||4294901760<a)return!1;for(var f=1;4>=f;f*=2){var y=d*(1+.2/f);y=Math.min(y,a+100663296);var A=Math;y=Math.max(a,y);e:{A=A.min.call(A,4294901760,y+(65536-y%65536)%65536)-q.buffer.byteLength+65535>>>16;try{q.grow(A),N();var P=1;break e}catch{}P=void 0}if(P)return!0}return!1},P:ee,Q:ce,H:Ct,h:pe,o:E,x:ie,n:Qe,a:q||n.wasmMemory,J:Rn,e:function(a,d,f,y){return Rn(a>>>0,d>>>0,f>>>0,y>>>0)}};(function(){function a(f,y){return f=f.exports,f=Hs(f),L=f=eu(f),oe.mb.push(L.Da),ze.unshift(L.Y),De=y,Ot(),f}var d={a:Zs};if(or(),n.instantiateWasm)try{return n.instantiateWasm(d,a)}catch(f){R("Module.instantiateWasm callback failed with error: "+f),m(f)}return st(d,function(f){a(f.instance,f.module)}).catch(m),{}})(),n._OrtInit=(a,d)=>(n._OrtInit=L.Z)(a,d),n._OrtGetLastError=(a,d)=>(n._OrtGetLastError=L._)(a,d),n._OrtCreateSessionOptions=(a,d,f,y,A,P,W,te,Z,J)=>(n._OrtCreateSessionOptions=L.$)(a,d,f,y,A,P,W,te,Z,J),n._OrtAppendExecutionProvider=(a,d)=>(n._OrtAppendExecutionProvider=L.aa)(a,d),n._OrtAddFreeDimensionOverride=(a,d,f)=>(n._OrtAddFreeDimensionOverride=L.ba)(a,d,f),n._OrtAddSessionConfigEntry=(a,d,f)=>(n._OrtAddSessionConfigEntry=L.ca)(a,d,f),n._OrtReleaseSessionOptions=a=>(n._OrtReleaseSessionOptions=L.da)(a),n._OrtCreateSession=(a,d,f)=>(n._OrtCreateSession=L.ea)(a,d,f),n._OrtReleaseSession=a=>(n._OrtReleaseSession=L.fa)(a),n._OrtGetInputOutputCount=(a,d,f)=>(n._OrtGetInputOutputCount=L.ga)(a,d,f),n._OrtGetInputName=(a,d)=>(n._OrtGetInputName=L.ha)(a,d),n._OrtGetOutputName=(a,d)=>(n._OrtGetOutputName=L.ia)(a,d),n._OrtFree=a=>(n._OrtFree=L.ja)(a),n._OrtCreateTensor=(a,d,f,y,A,P)=>(n._OrtCreateTensor=L.ka)(a,d,f,y,A,P),n._OrtGetTensorData=(a,d,f,y,A)=>(n._OrtGetTensorData=L.la)(a,d,f,y,A),n._OrtReleaseTensor=a=>(n._OrtReleaseTensor=L.ma)(a),n._OrtCreateRunOptions=(a,d,f,y)=>(n._OrtCreateRunOptions=L.na)(a,d,f,y),n._OrtAddRunConfigEntry=(a,d,f)=>(n._OrtAddRunConfigEntry=L.oa)(a,d,f),n._OrtReleaseRunOptions=a=>(n._OrtReleaseRunOptions=L.pa)(a),n._OrtCreateBinding=a=>(n._OrtCreateBinding=L.qa)(a),n._OrtBindInput=(a,d,f)=>(n._OrtBindInput=L.ra)(a,d,f),n._OrtBindOutput=(a,d,f,y)=>(n._OrtBindOutput=L.sa)(a,d,f,y),n._OrtClearBoundOutputs=a=>(n._OrtClearBoundOutputs=L.ta)(a),n._OrtReleaseBinding=a=>(n._OrtReleaseBinding=L.ua)(a),n._OrtRunWithBinding=(a,d,f,y,A)=>(n._OrtRunWithBinding=L.va)(a,d,f,y,A),n._OrtRun=(a,d,f,y,A,P,W,te)=>(n._OrtRun=L.wa)(a,d,f,y,A,P,W,te),n._OrtEndProfiling=a=>(n._OrtEndProfiling=L.xa)(a),n._JsepOutput=(a,d,f)=>(n._JsepOutput=L.ya)(a,d,f),n._JsepGetNodeName=a=>(n._JsepGetNodeName=L.za)(a);var mr=n._pthread_self=()=>(mr=n._pthread_self=L.Aa)(),Fr=n._malloc=a=>(Fr=n._malloc=L.Ba)(a),Dn=n._free=a=>(Dn=n._free=L.Ca)(a);n.__emscripten_tls_init=()=>(n.__emscripten_tls_init=L.Da)();var Wn=n.__emscripten_thread_init=(a,d,f,y,A,P)=>(Wn=n.__emscripten_thread_init=L.Fa)(a,d,f,y,A,P);n.__emscripten_thread_crashed=()=>(n.__emscripten_thread_crashed=L.Ga)();var zn=(a,d,f,y)=>(zn=L.Ha)(a,d,f,y),Hr=a=>(Hr=L.Ia)(a),Lr=n.__emscripten_thread_exit=a=>(Lr=n.__emscripten_thread_exit=L.Ja)(a),Gn=n.__emscripten_check_mailbox=()=>(Gn=n.__emscripten_check_mailbox=L.Ka)(),Un=a=>(Un=L.La)(a),Nn=(a,d)=>(Nn=L.Ma)(a,d),jr=()=>(jr=L.Na)(),hr=a=>(hr=L.Oa)(a),Kr=a=>(Kr=L.Pa)(a),Vn=n.dynCall_ii=(a,d)=>(Vn=n.dynCall_ii=L.Ra)(a,d),Fn=a=>(Fn=L.Sa)(a),Hn=()=>(Hn=L.Ta)(),Ln=a=>(Ln=L.Ua)(a),jn=()=>(jn=L.Va)();n.___start_em_js=922382,n.___stop_em_js=922543;function eu(a){a=Object.assign({},a);var d=y=>()=>y()>>>0,f=y=>A=>y(A)>>>0;return a.__errno_location=d(a.__errno_location),a.pthread_self=d(a.pthread_self),a.malloc=f(a.malloc),a.stackSave=d(a.stackSave),a.stackAlloc=f(a.stackAlloc),a}n.keepRuntimeAlive=Ae,n.wasmMemory=q,n.stackAlloc=Kr,n.stackSave=jr,n.stackRestore=hr,n.UTF8ToString=Xe,n.stringToUTF8=ar,n.lengthBytesUTF8=zt,n.ExitStatus=dt,n.PThread=oe;var gr;Ve=function a(){gr||Kn(),gr||(Ve=a)};function Kn(){function a(){if(!gr&&(gr=!0,n.calledRun=!0,!he)&&(v||pt(ze),c(n),n.onRuntimeInitialized&&n.onRuntimeInitialized(),!v)){if(n.postRun)for(typeof n.postRun=="function"&&(n.postRun=[n.postRun]);n.postRun.length;){var d=n.postRun.shift();Ge.unshift(d)}pt(Ge)}}if(!(0<Ue))if(v)c(n),v||pt(ze),startWorker(n);else{if(n.preRun)for(typeof n.preRun=="function"&&(n.preRun=[n.preRun]);n.preRun.length;)ge.unshift(n.preRun.shift());pt(ge),0<Ue||(n.setStatus?(n.setStatus("Running..."),setTimeout(function(){setTimeout(function(){n.setStatus("")},1),a()},1)):a())}}if(n.preInit)for(typeof n.preInit=="function"&&(n.preInit=[n.preInit]);0<n.preInit.length;)n.preInit.pop()();return Kn(),t.ready}})();typeof no=="object"&&typeof en=="object"?en.exports=ro:typeof define=="function"&&define.amd&&define([],()=>ro)});var ao=Kt((Cd,uu)=>{uu.exports=\'"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(Module.__embind_initialize_bindings(),initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err(`worker.js received unknown command ${e.data.cmd}`),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\\n\'});var nn,Yt,Xt,wr,Qt,po,on,ke=H(()=>{"use strict";nn=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},Yt=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},Xt=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],wr=e=>{switch(e){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Qt=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},po=e=>e==="float32"||e==="int32"||e==="int64"||e==="bool"||e==="float16"||e==="uint32",on=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var yu,bu,fo,mo,ho,wu,Ie,lt=H(()=>{"use strict";ke();yu=["V","I","W","E","F"],bu=(e,t)=>{console.log(`[${yu[e]},${new Date().toISOString()}]${t}`)},ho=(e,t)=>{fo=e,mo=t},wu=(e,t)=>{let r=Qt(e),i=Qt(fo);r>=i&&bu(r,typeof t=="function"?t():t)},Ie=(...e)=>{mo&&wu(...e)}});var go,yo=H(()=>{"use strict";ke();go=(e,t)=>new(wr(t))(e)});var bo=H(()=>{"use strict"});var vr,vu,wo,sn,an,vo,$o=H(()=>{"use strict";lt();bo();vr=e=>Math.ceil(e/16)*16,vu=1,wo=()=>vu++,sn=async(e,t,r,i)=>{let o=vr(r),s=e.device.createBuffer({size:o,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let l=e.getCommandEncoder();e.endComputePass(),l.copyBufferToBuffer(t,0,s,0,o),e.flush(),await s.mapAsync(GPUMapMode.READ);let n=s.getMappedRange();if(i){let c=i();return c.set(new Uint8Array(n,0,r)),c}else return new Uint8Array(n.slice(0,r))}finally{s.destroy()}},an=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(t,r){let i=r.buffer,o=r.byteOffset,s=r.byteLength,l=vr(s),n=this.storageCache.get(t);if(!n)throw new Error("gpu data for uploading does not exist");if(n.originalSize!==s)throw new Error(`inconsistent data size. gpu data size=${n.originalSize}, data size=${s}`);let c=this.backend.device.createBuffer({mappedAtCreation:!0,size:l,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),m=c.getMappedRange();new Uint8Array(m).set(new Uint8Array(i,o,s)),c.unmap();let g=this.backend.getCommandEncoder();this.backend.endComputePass(),g.copyBufferToBuffer(c,0,n.gpuData.buffer,0,l),Ie("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`),this.buffersForUploadingPending.push(c)}memcpy(t,r){let i=this.storageCache.get(t);if(!i)throw new Error("source gpu data for memcpy does not exist");let o=this.storageCache.get(r);if(!o)throw new Error("destination gpu data for memcpy does not exist");if(i.originalSize!==o.originalSize)throw new Error("inconsistent source and destination gpu data size");let s=vr(i.originalSize),l=this.backend.getCommandEncoder();this.backend.endComputePass(),l.copyBufferToBuffer(i.gpuData.buffer,0,o.gpuData.buffer,0,s)}registerExternalBuffer(t,r,i){let o;if(i){if(o=this.externalBuffers.get(i),o===void 0)throw new Error("previous buffer is not registered");if(t===i)return Ie("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${o}, buffer is the same, skip.`),o;this.externalBuffers.delete(i)}else o=wo();return this.storageCache.set(o,{gpuData:{id:o,type:0,buffer:t},originalSize:r}),this.externalBuffers.set(t,o),Ie("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${o}, registered.`),o}unregisterExternalBuffer(t){let r=this.externalBuffers.get(t);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(t),Ie("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let i=vr(t),o,s=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,l=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(s||l){let c=s?this.freeBuffers:this.freeUniformBuffers,m=c.get(i);m||(m=[],c.set(i,m)),m.length>0?o=m.pop():o=this.backend.device.createBuffer({size:i,usage:r})}else o=this.backend.device.createBuffer({size:i,usage:r});let n={id:wo(),type:0,buffer:o};return this.storageCache.set(n.id,{gpuData:n,originalSize:t}),Ie("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${n.id}`),n}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=this.storageCache.get(t);if(!r)throw new Error("releasing data does not exist");return Ie("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,r){let i=this.storageCache.get(t);if(!i)throw new Error("data does not exist");await sn(this.backend,i.gpuData.buffer,i.originalSize,r)}refreshPendingBuffers(){for(let t of this.buffersForUploadingPending)t.destroy();this.buffersForUploadingPending=[];for(let t of this.buffersPending)(t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(t.size).push(t):(t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(t.size).push(t):t.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},vo=(...e)=>new an(...e)});var un,ae,_e=H(()=>{"use strict";un=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this._cacheKey}},ae=e=>new un(e)});var ln,Ze,D,bt,$r,xr,Cr,me=H(()=>{"use strict";ln=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},Ze=class{static calcShape(t,r,i=!1){let o=t.length,s=r.length;if(o===0)return r;if(s===0)return t;let l=Math.max(t.length,r.length),n=new Array(l);if(i){if(o<2||s<2)return;let c=ln.calcMatMulShape([t[o-2],t[o-1]],[r[s-2],r[s-1]]);if(c===void 0)return;[n[l-2],n[l-1]]=c}for(let c=i?3:1;c<=l;c++){let m=o-c<0?1:t[o-c],g=s-c<0?1:r[s-c];if(m!==g&&m>1&&g>1)return;n[l-c]=Math.max(m,g)}return n}static isValidBroadcast(t,r){let i=t.length,o=r.length;if(i>o)return!1;for(let s=1;s<=i;s++)if(t[i-s]!==1&&t[i-s]!==r[o-s])return!1;return!0}},D=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,i){let o=1;for(let s=r;s<i;s++){if(t[s]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");o*=t[s]}return o}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let i=new Array(r);i[r-1]=1,i[r-2]=t[r-1];for(let o=r-3;o>=0;--o)i[o]=i[o+1]*t[o+1];return i}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error("unsupported axis for this operation.");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(i=>this.normalizeAxis(i,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(i=>t[i]):t.slice().reverse()}static padShape(t,r){let i=t.length;return t.map((o,s)=>o+r[s]+r[s+i])}static areEqual(t,r){return t.length!==r.length?!1:t.every((i,o)=>i===r[o])}},bt=class e{static adjustPoolAttributes(t,r,i,o,s,l){if(!t&&i.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let n=0;n<r.length-2;n++)n>=i.length?i.push(r[n+2]):i[n]=r[n+2];for(let n=0;n<i.length;n++)if(n<o.length){if(o[n]<0)throw new Error("strides should be greater than or equal to 1")}else o.push(1);for(let n=0;n<i.length;n++)if(n<s.length){if(s[n]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let n=0;n<i.length*2;n++)if(n<l.length){if(l[n]<0)throw new Error("pad should be greater than or equal to 1")}else l.push(0);for(let n=0;n<i.length;n++){if(i[n]<=0)throw new Error("kernel shapes need to be greater than 0");if(l[n]>=i[n]||l[n+i.length]>=i[n])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,i,o,s,l,n){if(n){if(s.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(o.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let c=0;c<t.length-2;c++)e.adjustPadAndReturnShape(t[c+(l?1:2)],r[c],i[c],o[c],s,c,c+t.length-2,n)}}static computePoolOutputShape(t,r,i,o,s,l,n){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let c=[r[0],r[1]];return e.computeShapeHelper(t,r,c,i,o,s,l,n),c}static computeConvOutputShape(t,r,i,o,s,l,n){if(t.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let c=[t[0],r[0]];return e.computeShapeHelper(!1,t,c,i,o,s,l,n),c}static computeShapeHelper(t,r,i,o,s,l,n,c){if(t)for(let m=0;m<r.length-2;m++)i.push(1);else for(let m=0;m<r.length-2;m++)i.push(e.adjustPadAndReturnShape(r[m+2],o[m],s[m],l[m],n,m,m+r.length-2,c))}static adjustPadAndReturnShape(t,r,i,o,s,l,n,c){let m=i*(o-1)+1;if(c&&c!=="NOTSET")switch(c){case"VALID":return s[l]=0,s[n]=0,Math.floor((t-m)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(i!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let C=((t+r-1)/r-1)*r+o-t;return s[l]=Math.floor(c==="SAME_LOWER"?(C+1)/2:C/2),s[n]=C-s[l],Math.floor((t+C-o)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+s[l]+s[n]-m)/r+1)}},$r=class{static getShapeOfGemmResult(t,r,i,o,s){if(t.length!==2||i.length!==2)throw new Error("shape need to be of size 2");let l,n,c;r?(l=t[1],n=t[0]):(l=t[0],n=t[1]);let m=-1;if(o?(c=i[0],m=1):(c=i[1],m=0),i[m]!==n)throw new Error("dimension mismatch");if(l<=0||c<=0||n<=0)throw new Error("invalid shape specified");if(s&&!Ze.isValidBroadcast(s,[l,c]))throw new Error("gemm: invalid bias shape for broadcast");return[l,c,n]}},xr=-34028234663852886e22,Cr=34028234663852886e22});var $u,xo,Pe,cn,Co,K,se,dn,So,pn,$e=H(()=>{"use strict";ke();me();$u=64,xo=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},Pe=(e,t=1)=>{let r=xo(e,t);return typeof r=="string"?r:r[0]},cn=e=>[{type:"uint32",data:e},{type:"uint32",data:D.computeStrides(e)}],Co=(e,t,r,i,o)=>{let s=typeof r=="number",l=s?r:r.length,n=[...new Array(l).keys()],c=l<2?"u32":l<=4?`vec${l}<u32>`:`array<u32, ${l}>`,m=xo(t,o),g=typeof m=="string"?m:m[1],C=typeof m=="string"?m:m[0],x={indices:c,value:g,storage:C,tensor:t},$=N=>typeof N=="string"?N:`${N}u`,b={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},w=s?"uniforms.":"",v=`${w}${e}_shape`,I=`${w}${e}_strides`,B="";for(let N=0;N<l-1;N++)B+=`\n    let dim${N} = current / ${I}[${N}];\n    let rest${N} = current % ${I}[${N}];\n    indices[${N}] = dim${N};\n    current = rest${N};\n    `;B+=`indices[${l-1}] = current;`;let z=l<2?"":`\n  fn o2i_${e}(offset: u32) -> ${x.indices} {\n    var indices: ${x.indices};\n    var current = offset;\n    ${B}\n    return indices;\n  }`,M=N=>(b.offsetToIndices=!0,l<2?N:`o2i_${e}(${N})`),G=[];if(l>=2)for(let N=l-1;N>=0;N--)G.push(`${I}[${N}] * (indices[${N}])`);let _=l<2?"":`\n  fn i2o_${e}(indices: ${x.indices}) -> u32 {\n    return ${G.join("+")};\n  }`,U=N=>(b.indicesToOffset=!0,l<2?N:`i2o_${e}(${N})`),V=(...N)=>l===0?"0u":`${x.indices}(${N.map($).join(",")})`,j=(N,de)=>l<2?`${N}`:`${N}[${de}]`,le=(N,de,ge)=>l<2?`${N}=${ge};`:`${N}[${de}]=${ge};`,R={},X=(N,de)=>{b.broadcastedIndicesToOffset=!0;let ge=`${de.name}broadcastedIndicesTo${e}Offset`;if(ge in R)return`${ge}(${N})`;let ze=[];for(let Ge=l-1;Ge>=0;Ge--){let Te=de.indicesGet("outputIndices",Ge+de.rank-l);ze.push(`${j(I,Ge)} * (${Te} % ${j(v,Ge)})`)}return R[ge]=`fn ${ge}(outputIndices: ${de.type.indices}) -> u32 {\n             return ${ze.length>0?ze.join("+"):"0u"};\n           }`,`${ge}(${N})`},Se=(N,de)=>(()=>{if(x.storage===x.value)return`${e}[${N}]=${de};`;if(x.storage==="vec2<u32>"&&x.value==="i32")return`${e}[${N}]=vec2<u32>(u32(${de}), select(0u, 0xFFFFFFFFu, ${de} < 0));`;if(x.storage==="vec2<u32>"&&x.value==="u32")return`${e}[${N}]=vec2<u32>(u32(${de}), 0u);`;if(x.storage==="u32"&&x.value==="vec4<bool>")return`${e}[${N}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${de}));`;throw new Error(`not supported combination of storage type ${x.storage} and value type ${x.value} yet`)})(),q=N=>(()=>{if(x.storage===x.value)return`${e}[${N}]`;if(x.storage==="vec2<u32>"&&x.value==="i32")return`i32(${e}[${N}].x)`;if(x.storage==="vec2<u32>"&&x.value==="u32")return`u32(${e}[${N}].x)`;if(x.storage==="u32"&&x.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${N}] & 0xFFu), bool(${e}[${N}] & 0xFF00u), bool(${e}[${N}] & 0xFF0000u), bool(${e}[${N}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${x.storage} and value type ${x.value} yet`)})(),L=l<2?"":`\n  fn get_${e}ByIndices(indices: ${x.indices}) -> ${g} {\n    return ${q(`i2o_${e}(indices)`)};\n  }`,De=l<2?"":(()=>{let N=n.map(ge=>`d${ge}: u32`).join(", "),de=n.map(ge=>`d${ge}`).join(", ");return`\n  fn get_${e}(${N}) -> ${g} {\n    return get_${e}ByIndices(${V(de)});\n  }`})(),he=(...N)=>{if(N.length!==l)throw new Error(`indices length must be ${l}`);let de=N.map($).join(",");return l===0?q("0u"):l===1?q(de[0]):(b.get=!0,b.getByIndices=!0,b.indicesToOffset=!0,`get_${e}(${de})`)},Re=N=>l<2?q(N):(b.getByIndices=!0,b.indicesToOffset=!0,`get_${e}ByIndices(${N})`),we=l<2?"":`\n  fn set_${e}ByIndices(indices: ${x.indices}, value: ${g}) {\n    ${Se(`i2o_${e}(indices)`,"value")}\n  }`,Be=l<2?"":(()=>{let N=n.map(ge=>`d${ge}: u32`).join(", "),de=n.map(ge=>`d${ge}`).join(", ");return`\n  fn set_${e}(${N}, value: ${g}) {\n    set_${e}ByIndices(${V(de)}, value);\n  }`})();return{impl:()=>{let N=[];return s||(N.push(`const ${v} = ${x.indices}(${r.join(",")});`),N.push(`const ${I} = ${x.indices}(${D.computeStrides(r).join(",")});`)),b.offsetToIndices&&N.push(z),b.indicesToOffset&&N.push(_),b.broadcastedIndicesToOffset&&Object.values(R).forEach(de=>N.push(de)),b.set&&N.push(Be),b.setByIndices&&N.push(we),b.get&&N.push(De),b.getByIndices&&N.push(L),N.join(`\n`)},type:x,offsetToIndices:M,indicesToOffset:U,broadcastedIndicesToOffset:X,indices:V,indicesGet:j,indicesSet:le,set:(...N)=>{if(N.length!==l+1)throw new Error(`indices length must be ${l}`);let de=N[l];if(typeof de!="string")throw new Error("value must be string");let ge=N.slice(0,l).map($).join(",");return l===0?Se("0u",de):l===1?Se(ge[0],de):(b.set=!0,b.setByIndices=!0,b.indicesToOffset=!0,`set_${e}(${ge}, ${de})`)},setByOffset:Se,setByIndices:(N,de)=>l<2?Se(N,de):(b.setByIndices=!0,b.indicesToOffset=!0,`set_${e}ByIndices(${N}, ${de});`),get:he,getByOffset:q,getByIndices:Re,usage:i?"input":"output",name:e,strides:I,shape:v,rank:l}},K=(e,t,r,i=1)=>Co(e,t,r,!0,i),se=(e,t,r,i=1)=>Co(e,t,r,!1,i),dn=class{constructor(t){this.normalizedDispatchGroup=t;this.indicesHelpers=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=$u){let r=typeof t=="number"?t:t[0],i=typeof t=="number"?1:t[1],o=typeof t=="number"?1:t[2],s=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,l=s?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_index : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>`,n=s?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +\n          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${r*i*o}u + local_index;`;return`@compute @workgroup_size(${r}, ${i}, ${o})\n  fn main(${l}) {\n    ${n}\n  `}declareVariable(t,r){this.indicesHelpers.push(t),t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:t.type.indices}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:t.type.indices});let i=t.usage==="input"?"read":"read_write",o=t.type.storage;return`@group(0) @binding(${r}) var<storage, ${i}> ${t.name}: array<${o}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`\n`)}registerUniform(t,r){return this.uniforms.push({name:t,type:r}),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:r,type:i}of this.uniforms)t.push(`${r}:${i}`);return`\n      struct Uniforms { ${t.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.indicesHelpers.map(t=>t.impl()).join(`\n`)}},So=e=>new dn(e),pn=(e,t)=>{let r=e.length,i=[];for(let o=0;o<r;o++){let s=r-1-o,l=e[s]||1;(t[t.length-1-o]||1)>1&&l===1&&i.unshift(s)}return i}});var et,xu,Sr,Cu,tt,Ao,Io,To,Eo,Oo,_o,Po,Ro,Bo,Mo,je,fn=H(()=>{"use strict";me();_e();$e();et=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},xu=e=>["","",`var value = ${e.getByOffset("inputOffset")};`,""],Sr=(e,t,r,i,o,s,l=!1,n=!1)=>{let c=[],m=r[0].dims,g=D.normalizeAxes(o,r[0].dims.length),C=!n&&g.length===0;m.forEach((U,V)=>{C||g.indexOf(V)>=0?l&&c.push(1):c.push(U)});let x=[],$=K("_A",r[0].dataType,m),b=se("output",s,c),w=i($,b,g),v=`inputOffset = ${$.indicesToOffset("inputIndices")};`,I=`let ${v};`,B=`var ${v};`,z=w[1]===""?"":B,M=(w[1]===""?I:v)+`\n`+w[2];for(let U=0,V=0;U<r[0].dims.length;U++)C||g.indexOf(U)>=0?(l&&V++,M=`for(var j${U}: u32 = 0; j${U} < ${r[0].dims[U]}; j${U}++) {\n                ${w[2].includes("lastIndex")?`let lastIndex = j${U};`:""}\n                ${$.indicesSet("inputIndices",U,`j${U}`)}\n                ${M}\n              }`):(x.push(`${$.indicesSet("inputIndices",U,b.indicesGet("outputIndices",V))};`),V++);let G=D.size(c);return{name:e,shaderCache:t,getShaderSource:U=>`\n        ${U.declareVariables($,b)}\n\n        ${U.mainStart()}\n          ${U.guardAgainstOutOfBoundsWorkgroupSizes(G)}\n          var inputIndices: ${$.type.indices};\n          let outputIndices = ${b.offsetToIndices("global_idx")};\n\n          ${x.join(`\n`)}\n          ${w[0]}       // init ops for reduce max/min\n          ${z}\n          ${w[1]}\n          ${M}\n          ${w[3]}\n          ${w.length===4?b.setByOffset("global_idx","value"):w.slice(4).join(`\n`)}\n        }`,getRunData:()=>({outputs:[{dims:c,dataType:s}],dispatchGroup:{x:Math.ceil(G/64)}})}},Cu=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(i=>r.push(Number(i))),ae({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},tt=(e,t,r,i)=>{let o=e.inputs,s=o.length===1?r:Cu(o,r);e.compute(Sr(t,{hint:s.cacheKey},[o[0]],s.noopWithEmptyAxes&&s.axes.length===0?xu:i,s.axes,o[0].dataType,s.keepDims,s.noopWithEmptyAxes),{inputs:[0]})},Ao=(e,t)=>{et(e.inputs),tt(e,"ReduceLogSum",t,(i,o)=>[`var value = ${o.type.storage}(0);`,"",`value += ${i.getByOffset("inputOffset")};`,"value = log(value);"])},Io=(e,t)=>{et(e.inputs),tt(e,"ReduceL1",t,(i,o)=>[`var value = ${o.type.storage}(0);`,"",`value += abs(${i.getByOffset("inputOffset")});`,""])},To=(e,t)=>{et(e.inputs),tt(e,"ReduceL2",t,(i,o)=>[`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,"",`t = ${i.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"])},Eo=(e,t)=>{et(e.inputs),tt(e,"ReduceLogSumExp",t,(i,o)=>[`var value = ${o.type.storage}(0);`,"",`value += exp(${i.getByOffset("inputOffset")});`,"value = log(value);"])},Oo=(e,t)=>{et(e.inputs),tt(e,"ReduceMax",t,(i,o,s)=>{let l=[];for(let n=0;n<i.rank;n++)(s.indexOf(n)>=0||s.length===0)&&l.push(i.indicesSet("inputIndices",n,0));return[`${l.join(`\n`)}`,`var value = ${i.getByOffset("inputOffset")};`,`value = max(value, ${i.getByOffset("inputOffset")});`,""]})},_o=(e,t)=>{et(e.inputs),tt(e,"ReduceMean",t,(i,o,s)=>{let l=1;for(let n=0;n<i.rank;n++)(s.indexOf(n)>=0||s.length===0)&&(l*=e.inputs[0].dims[n]);return["var sum = f32(0);","",`sum += f32(${i.getByOffset("inputOffset")});`,`let value = ${o.type.value}(sum / ${l});`]})},Po=(e,t)=>{et(e.inputs),tt(e,"ReduceMin",t,(i,o,s)=>{let l=[];for(let n=0;n<i.rank;n++)(s.indexOf(n)>=0||s.length===0)&&l.push(`inputIndices[${n}] = 0;`);return[`${l.join(`\n`)}`,`var value = ${i.getByOffset("inputOffset")};`,`value = min(value, ${i.getByOffset("inputOffset")});`,""]})},Ro=(e,t)=>{et(e.inputs),tt(e,"ReduceProd",t,(i,o)=>[`var value = ${o.type.storage}(1);`,"",`value *= ${i.getByOffset("inputOffset")};`,""])},Bo=(e,t)=>{et(e.inputs),tt(e,"ReduceSum",t,(i,o)=>[`var value = ${o.type.storage}(0);`,"",`value += ${i.getByOffset("inputOffset")};`,""])},Mo=(e,t)=>{et(e.inputs),tt(e,"ReduceSumSquare",t,(i,o)=>[`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,"",`t = ${i.getByOffset("inputOffset")}; value += t * t;`,""])},je=e=>ae(e)});var ko,Do,Wo,zo,mn,Go=H(()=>{"use strict";ke();_e();fn();ko=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},Do=(e,t)=>ae({axis:t.axis,keepDims:t.keepDims,selectLastIndex:t.selectLastIndex}),Wo=(e,t)=>{ko(e.inputs);let r=(o,s,l)=>{let n=[];for(let c=0;c<o.rank;c++)(l.indexOf(c)>=0||l.length===0)&&n.push(`inputIndices[${c}] = 0;`);return[`${n.join(`\n`)}`,`var value = ${o.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${o.getByOffset("inputOffset")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${o.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",s.setByOffset("global_idx","bestIndex")]},i=e.inputs.length===1?t:Do(e.inputs,t);e.compute(Sr("ArgMin",{hint:i.cacheKey},[e.inputs[0]],r,[i.axis],7,i.keepDims),{inputs:[0]})},zo=(e,t)=>{ko(e.inputs);let r=(o,s,l)=>{let n=[];for(let c=0;c<o.rank;c++)(l.indexOf(c)>=0||l.length===0)&&n.push(`inputIndices[${c}] = 0;`);return[`${n.join(`\n`)}`,`var value = ${o.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${o.getByOffset("inputOffset")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${o.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",s.setByOffset("global_idx","bestIndex")]},i=e.inputs.length===1?t:Do(e.inputs,t);e.compute(Sr("argMax",{hint:i.cacheKey},[e.inputs[0]],r,[i.axis],7,i.keepDims),{inputs:[0]})},mn=e=>ae(e)});var Su,Au,Uo,No=H(()=>{"use strict";me();$e();Su=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Au=e=>{let t=e[0].dims,r=e[0].dims[2],i=D.size(t)/4,o=e[0].dataType,s=K("input",o,t,4),l=K("bias",o,[r],4),n=K("residual",o,t,4),c=se("output",o,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:g=>`\n  const channels = ${r}u / 4;\n  ${g.declareVariables(s,l,n,c)}\n\n  ${g.mainStart()}\n    ${g.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n    let value = ${s.getByOffset("global_idx")}\n      + ${l.getByOffset("global_idx % channels")} + ${n.getByOffset("global_idx")};\n    ${c.setByOffset("global_idx","value")}\n  }`}},Uo=e=>{Su(e.inputs),e.compute(Au(e.inputs))}});var Iu,xe,Vo,Fo,Ho,Lo,jo,Ko,qo,Yo,Xo,hn,Tu,Qo,Jo,Zo,ea,Ar,ta,Ir,ra,na,oa,aa,ia,sa,ua,la,da,ca,pa,fa,ma,ha,ga,ya,ba,gn=H(()=>{"use strict";ke();me();_e();$e();Iu=(e,t,r,i,o,s)=>{let l=Math.ceil(t/4),n="";typeof o=="string"?n=`${o}(a)`:n=o("a");let c=K("inputData",r,[l],4),m=se("outputData",i,[l],4);return`\n  ${e.declareVariables(c,m)}\n\n  ${s??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(l)}\n\n    let a = ${c.getByOffset("global_idx")};\n    ${m.setByOffset("global_idx",n)}\n  }`},xe=(e,t,r,i,o,s=e.dataType)=>({name:t,shaderCache:{hint:o},getShaderSource:l=>Iu(l,D.size(e.dims),e.dataType,s,r,i),getRunData:l=>({outputs:[{dims:e.dims,dataType:s}],dispatchGroup:{x:Math.ceil(D.size(l[0].dims)/64/4)}})}),Vo=e=>{e.compute(xe(e.inputs[0],"Abs","abs"))},Fo=e=>{e.compute(xe(e.inputs[0],"Acos","acos"))},Ho=e=>{e.compute(xe(e.inputs[0],"Acosh","acosh"))},Lo=e=>{e.compute(xe(e.inputs[0],"Asin","asin"))},jo=e=>{e.compute(xe(e.inputs[0],"Asinh","asinh"))},Ko=e=>{e.compute(xe(e.inputs[0],"Atan","atan"))},qo=e=>{e.compute(xe(e.inputs[0],"Atanh","atanh"))},Yo=e=>ae(e),Xo=(e,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${t.to}`)}e.compute(xe(e.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},hn=(e,t)=>{let r=Pe(e.inputs[0].dataType);e.compute(xe(e.inputs[0],"Clip",i=>`clamp(${i}, clip_min_, clip_max_)`,`\n    const clip_min_: vec4<${r}> = vec4(${r}(${t.min}));\n    const clip_max_: vec4<${r}> = vec4(${r}(${t.max}));\n`,t.cacheKey),{inputs:[0]})},Tu=e=>{let t=e.length>=2?e[1].getFloat32Array()[0]:xr,r=e.length>=3?e[2].getFloat32Array()[0]:Cr;return ae({min:t,max:r})},Qo=e=>{let t=Tu(e.inputs);hn(e,t)},Jo=e=>{e.compute(xe(e.inputs[0],"Ceil","ceil"))},Zo=e=>{e.compute(xe(e.inputs[0],"Cos","cos"))},ea=e=>{e.compute(xe(e.inputs[0],"Cosh","cosh"))},Ar=e=>ae(e),ta=(e,t)=>{e.compute(xe(e.inputs[0],"Elu",r=>`elu_vf32(${r})`,`\n  const elu_alpha_: f32 = f32(${t.alpha});\n\n  fn elu_f32(a: f32) -> f32 {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},Ir=(e,t="f32")=>`\nconst r0: ${t} = 0.3275911;\nconst r1: ${t} = 0.254829592;\nconst r2: ${t} = -0.284496736;\nconst r3: ${t} = 1.421413741;\nconst r4: ${t} = -1.453152027;\nconst r5: ${t} = 1.061405429;\n\nfn erf_vf32(v: ${e}) -> ${e} {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,ra=e=>{let t=Pe(e.inputs[0].dataType);e.compute(xe(e.inputs[0],"Erf",r=>`erf_vf32(${r})`,Ir(`vec4<${t}>`,t)))},na=e=>{e.compute(xe(e.inputs[0],"Exp","exp"))},oa=e=>{e.compute(xe(e.inputs[0],"Floor","floor"))},aa=e=>{let t=Pe(e.inputs[0].dataType);e.compute(xe(e.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,Ir(`vec4<${t}>`,t)))},ia=(e,t)=>{e.compute(xe(e.inputs[0],"LeakyRelu",r=>`select(leaky_relu_alpha_ * ${r}, ${r}, ${r} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${t.alpha});`,t.cacheKey))},sa=e=>{e.compute(xe(e.inputs[0],"Not",t=>`!${t}`))},ua=e=>{e.compute(xe(e.inputs[0],"Neg",t=>`-${t}`))},la=e=>{e.compute(xe(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},da=e=>{e.compute(xe(e.inputs[0],"Relu",t=>`select(vec4<f32>(0.0), ${t}, ${t} > vec4<f32>(0.0))`))},ca=e=>{e.compute(xe(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},pa=e=>{e.compute(xe(e.inputs[0],"Sin","sin"))},fa=e=>{e.compute(xe(e.inputs[0],"Sinh","sinh"))},ma=e=>{e.compute(xe(e.inputs[0],"Sqrt","sqrt"))},ha=e=>{e.compute(xe(e.inputs[0],"Tan","tan"))},ga=e=>{e.compute(xe(e.inputs[0],"Tanh","tanh"))},ya=(e,t)=>(e.compute(xe(e.inputs[0],"ThresholdedRelu",r=>`select(vec4<f32>(0.0), ${r}, ${r} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${t.alpha});`,t.cacheKey)),0),ba=e=>{e.compute(xe(e.inputs[0],"Log","log"))}});var Ou,_u,wa,va=H(()=>{"use strict";me();$e();gn();Ou=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},_u=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=K("input",e[0].dataType,e[0].dims,4),i=K("bias",e[0].dataType,[e[0].dims[2]],4),o=se("output",e[0].dataType,t,4),s=D.size(t)/4;return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:n=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${n.declareVariables(r,i,o)}\n\n  ${Ir("vec4f")}\n\n  ${n.mainStart()}\n    ${n.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${o.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},wa=e=>{Ou(e.inputs),e.compute(_u(e.inputs))}});var Pu,Ru,rt,$a,xa,Ca,Sa,Aa,Ia,Ta,Ea,Oa,_a,Pa=H(()=>{"use strict";ke();me();$e();Pu=(e,t,r,i,o,s,l,n,c,m,g)=>{let C=D.size(i),x=Math.ceil(C/4),$,b;typeof l=="string"?$=b=(M,G)=>`${l}((${M}),(${G}))`:typeof l=="function"?$=b=l:($=l.scalar,b=l.vector);let w="",v=se("outputData",m,i,4),I=K("aData",n,t,4),B=K("bData",c,r,4);if(s){let M=G=>{let _=D.computeStrides(G),U=[];for(let V=G.length-1;V>=0;V--){let j=v.indicesGet("outputIndices",V+i.length-G.length);U.push(`${_[V]}u * (${j} % ${G[V]}u)`)}return U.length>0?U.join("+"):"0u"};w=`\n          fn calcOffsetA(outputIndices: ${v.type.indices}) -> u32 {\n            return ${M(t)};\n          }\n\n          fn calcOffsetB(outputIndices: ${v.type.indices}) -> u32 {\n            return ${M(r)};\n          }\n        `}let z;if(o)if(s){let M=D.size(t)===1,G=D.size(r)===1;M||G?z=v.setByOffset("global_idx",b(M?`${I.type.value}(${I.getByOffset("0")}.x)`:I.getByOffset("global_idx"),G?`${B.type.value}(${B.getByOffset("0")}.x)`:B.getByOffset("global_idx"))):z=`\n            let outputIndices = ${v.offsetToIndices("global_idx * 4u")};\n            let offsetA = calcOffsetA(outputIndices);\n            let offsetB = calcOffsetB(outputIndices);\n            ${v.setByOffset("global_idx",b(I.getByOffset("offsetA / 4u"),B.getByOffset("offsetB / 4u")))}\n          `}else z=v.setByOffset("global_idx",b(I.getByOffset("global_idx"),B.getByOffset("global_idx")));else{if(!s)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let M=(G,_,U="")=>{let V=`aData[indexA${_}][componentA${_}]`,j=`bData[indexB${_}][componentB${_}]`;return`\n            let outputIndices${_} = ${v.offsetToIndices(`global_idx * 4u + ${_}u`)};\n            let offsetA${_} = calcOffsetA(outputIndices${_});\n            let offsetB${_} = calcOffsetB(outputIndices${_});\n            let indexA${_} = offsetA${_} / 4u;\n            let indexB${_} = offsetB${_} / 4u;\n            let componentA${_} = offsetA${_} % 4u;\n            let componentB${_} = offsetB${_} % 4u;\n            ${G}[${_}] = ${U}(${$(V,j)});\n          `};m===9?z=`\n            var data = vec4<u32>(0);\n            ${M("data",0,"u32")}\n            ${M("data",1,"u32")}\n            ${M("data",2,"u32")}\n            ${M("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:z=`\n            ${M("outputData[global_idx]",0)}\n            ${M("outputData[global_idx]",1)}\n            ${M("outputData[global_idx]",2)}\n            ${M("outputData[global_idx]",3)}\n          `}return`\n        ${e.declareVariables(I,B,v)}\n\n        ${g??""}\n        ${w}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(x)}\n        ${z}\n      }`},Ru=(e,t,r,i,o,s,l=r.dataType)=>{let n=!D.areEqual(r.dims,i.dims),c=r.dims,m=D.size(r.dims),g=!1;if(n){let C=Ze.calcShape(r.dims,i.dims,!1);if(!C)throw new Error("Can\'t perform binary op on the given tensors");c=C,m=D.size(c);let x=D.size(r.dims)===1,$=D.size(i.dims)===1,b=1;for(let w=1;w<c.length;w++){let v=r.dims[r.dims.length-w]??1,I=i.dims[i.dims.length-w]??1;if(v===I)b*=v;else break}(b%4===0||x||$)&&(g=!0)}else g=!0;return{name:e,shaderCache:{hint:t},getShaderSource:C=>Pu(C,r.dims,i.dims,c,g,n,o,r.dataType,i.dataType,l,s),getRunData:()=>({outputs:[{dims:c,dataType:l}],dispatchGroup:{x:Math.ceil(m/64/4)}})}},rt=(e,t,r,i,o,s)=>{e.compute(Ru(t,o??"",e.inputs[0],e.inputs[1],r,i,s))},$a=e=>{rt(e,"Add",(t,r)=>`${t}+${r}`)},xa=e=>{rt(e,"Div",(t,r)=>`${t}/${r}`)},Ca=e=>{rt(e,"Equal",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},Sa=e=>{rt(e,"Mul",(t,r)=>`${t}*${r}`)},Aa=e=>{let t=K("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;rt(e,"Pow",{scalar:(i,o)=>`pow_custom(${i},${o})`,vector:(i,o)=>`pow_vector_custom(${i},${o})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},Ia=e=>{rt(e,"Sub",(t,r)=>`${t}-${r}`)},Ta=e=>{rt(e,"Greater",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},Ea=e=>{rt(e,"Less",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},Oa=e=>{rt(e,"GreaterOrEqual",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},_a=e=>{rt(e,"LessOrEqual",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var Mu,ku,Du,Wu,Ra,Ba,Ma=H(()=>{"use strict";me();_e();$e();Mu=e=>{if(!e||e.length<1)throw new Error("too few inputs");let t=e[0].dataType,r=e[0].dims.length;for(let i of e){if(i.dataType!==t)throw new Error("input tensors should be one type");if(i.dims.length!==r)throw new Error("input tensors should have the same shape")}},ku=e=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,Du=(e,t)=>{let r=e.length,i=[];for(let o=0;o<r;++o){let s=t.setByOffset("global_idx",e[o].getByIndices("indices"));r===1?i.push(s):o===0?i.push(`if (inputIndex == ${o}u) { ${s} }`):o===r-1?i.push(`else { ${s} }`):i.push(`else if (inputIndex == ${o}) { ${s} }`)}return i.join(`\n`)},Wu=(e,t)=>{let r=e[0].dims.slice();if(t>=r.length||t<-1*r.length)throw new Error("axis specified for concat doesn\'t match input dimensionality");let i=t<0?r.length+t:t,o=r.slice(0);for(let $=1;$<e.length;$++){let b=e[$].dims.slice();for(let w=0;w<r.length;w++)if(w===i)o[i]+=b[w];else if(r[w]!==b[w])throw new Error("non concat dimensions must match")}let s=D.size(o),l=new Array(e.length),n=new Array(e.length),c=e[0].dataType,m=0;for(let $=0;$<e.length;++$)m+=e[$].dims[i],l[$]=m,n[$]=K(`input${$}`,c,e[$].dims);let g=se("output",c,o),C=g.indicesGet("indices",i),x=$=>`\n  ${$.declareVariables(...n,g)}\n\n  const sizeInConcatAxis = array<u32, ${l.length}>(${l.map(b=>`${b}u`).join(",")});\n  ${ku(l.length)}\n\n  ${$.mainStart()}\n    ${$.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n\n    var indices = ${g.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${C});\n    if (inputIndex != 0u) {\n      ${C} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${Du(n,g)}\n  }`;return{name:"Concat",shaderCache:{hint:`${t}`},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:x}},Ra=(e,t)=>{Mu(e.inputs),e.compute(Wu(e.inputs,t.axis))},Ba=e=>ae({axis:e.axis})});var Me,Tr,Er,Or=H(()=>{"use strict";Me=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Tr=(e,t=!1,r=!1,i=3)=>"",Er=(e,t)=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      ${t?"value = activation(value, coords);":""}\n      `});var _r,yn=H(()=>{"use strict";_r=`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));\n}\n`});var Pr,Rr,Jt=H(()=>{"use strict";me();Pr=e=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${e.clipMin});const clip_max_=f32(${e.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},Rr=e=>{let t=e?.activation||"";if(t==="Clip"){let[r,i]=e?.activation_params||[xr,Cr];return{activation:t,clipMax:i,clipMin:r,activationCacheKey:`${t}:${r},${i}`}}return{activation:t,activationCacheKey:t}}});var zu,Gu,Zt,ka,Uu,er,Nu,Br,tr=H(()=>{"use strict";me();$e();Jt();Or();zu=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,Gu=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,Zt=(e,t,r="f32",i,o=!1,s=32,l=!1,n=32)=>{let c=t[1]*e[1],m=t[0]*e[0],g=o?c:s,C=o?s:c,x=g/t[0],$=s/t[1];if(!((o&&x===4&&e[1]===4||!o&&(x===3||x===4))&&g%t[0]===0&&s%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${o} is true, innerElementSize ${x} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${x} must be 3 or 4.\n  tileAWidth ${g} must be divisible by workgroupSize[0]${t[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${x}<${r}>, ${g/x}>, ${C}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${r}>, ${m/e[0]}>, ${s}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${x};\nconst tileInner = ${s};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${l?"0":"i32(globalId.z)"};\n  ${i?`let batchIndices = ${i.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${c};\n\n  let numTiles = ${l?`${Math.ceil(n/s)}`:"(dimInner - 1) / tileInner + 1"};\n  var kStart = ${l?`i32(globalId.z) * ${n}`:"0"};\n\n  var acc: array<vec4<${r}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${$};\n  for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${zu(o,i)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${$}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${i?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${x===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${Gu(o,x)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},ka=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,Uu=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",er=(e,t,r="f32",i,o=!1,s=32,l=!1,n=32,c=!1)=>{let m=e[1]*t[1],g=e[0]*t[0],C=o?m:s,x=o?s:m;if(!(x%t[1]===0&&C%t[0]===0&&s%t[1]===0))throw new Error(`tileAHight ${x} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${C} must be divisible by workgroupSize[0]${t[0]}, tileInner ${s} must be divisible by workgroupSize[1]${t[1]}`);let $=x/t[1],b=C/t[0],w=s/t[1],v=c?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${m};\n    let globalColStart = i32(workgroupId.x) * ${g};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${x}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${C}; inputCol = inputCol + ${t[0]}) {\n          ${ka(o,i)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${g}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${i?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${r}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${o?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${m};\n\nlet tileRowA = i32(localId.y) * ${$};\nlet tileColA = i32(localId.x) * ${b};\nlet tileRowB = i32(localId.y) * ${w};\n// Loop over shared dimension.\nfor (var t = 0; t < numTiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${$}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${b}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${ka(o,i)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${i?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${r}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${Uu(o)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${r}, ${C}>, ${x}>;\n  var<workgroup> mm_Bsub : array<array<${r}, ${g}>, ${s}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${s};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${l?"0":"i32(globalId.z)"};\n    ${i?`let batchIndices = ${i.offsetToIndices("u32(batch)")};`:""}\n    let numTiles = ${l?`${Math.ceil(n/s)}`:"(dimInner - 1) / tileInner + 1"};\n    var kStart = ${l?`i32(globalId.z) * ${n}`:"0"};\n\n    var acc : array<array<${r}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${v}\n  }\n`},Nu=(e,t,r,i,o,s=!1)=>{let l=o[0],n=o[1],c=o[2],m=i[0],g=i[1],C=i[2],x=i[3],$=pn(l,c),b=pn(n,c),w=Pe(i[0].type.tensor),v=()=>{let z=g.rank,M=m.rank,G=`var aIndices: ${g.type.indices};`;for(let _=z-2-1,U=M-1;_>=0;_--,U--)G+=`\naIndices[${_}] = ${M>1?`batchIndices[${U}]`:"batchIndices"};`;return $.forEach(_=>{G+=`\naIndices[${_}] = 0;`}),G+=`\naIndices[${z-2}] = u32(row);\n                   aIndices[${z-1}] = u32(colIn);`,G},I=()=>{let z=C.rank,M=m.rank,G=`var bIndices: ${C.type.indices};`;for(let _=z-2-1,U=M-1;_>=0;_--,U--)G+=`\nbIndices[${_}] = ${M>1?`batchIndices[${U}]`:"batchIndices"};`;return b.forEach(_=>{G+=`\nbIndices[${_}] = 0;`}),G+=`\nbIndices[${z-2}] = u32(row);\n                   bIndices[${z-1}] = u32(colIn);`,G};return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${m.type.indices}) -> ${Me(e,w)} {\n      var value = ${Me(e,w)}(0.0);\n      let col = colIn * ${e};\n      if(row < dimAOuter && col < dimInner)\n      {\n        ${v()}\n        value = ${g.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${m.type.indices}) -> ${Me(e,w)} {\n      var value = ${Me(e,w)}(0.0);\n      let col = colIn * ${e};\n      if(row < dimInner && col < dimBOuter)\n      {\n        ${I()}\n        value = ${C.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Me(e,w)}) {\n      let col = colIn * ${e};\n      if (row < dimAOuter && col < dimBOuter) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${s?"bias[colIn]":`${Me(e,w)}(bias[row])`};`:""}\n        ${r}\n        ${x.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},Br=(e,t,r,i,o=!1)=>{let s=e[0].dims,l=e[1].dims,n=s.slice(0,-2),c=l.slice(0,-2),m=i?i.slice(0,-2):r.slice(0,-2),g=K("batchDims",e[0].dataType,m),C=[g],x=[n,c,m],$=D.size(m),b=s[s.length-2],w=s[s.length-1],v=l[l.length-1],I=w%4===0&&v%4===0,{activationFunction:B,applyActivation:z}=Pr(t),M=b<=8?[4,1,1]:[4,4,1],G=[8,8,1],_=[Math.ceil(v/G[0]/M[0]),Math.ceil(b/G[1]/M[1]),Math.ceil($/G[2]/M[2])],U=Pe(e[0].dataType),V=I?4:1,j=K("a",e[0].dataType,[...n,b,w/V],V),le=K("b",e[1].dataType,[...c,w,v/V],V),R=se("result",e[0].dataType,[$,b,v/V],V);C.push(j),C.push(le),C.push(R);let X=[j,le],Se=e.length>2,q=Nu(V,Se,z,C,x,o);if(Se){let De=o?V:1;X.push(K("bias",e[2].dataType,e[2].dims,De))}let L=De=>`\n  const dimAOuter: i32 = ${b};\n  const dimBOuter: i32 = ${v};\n  const dimInner: i32 = ${w};\n  ${De.declareVariables(...X,R)}\n  ${q}\n  ${B}\n  ${I?Zt(M,G,U,g):er(M,G,U,g)}\n                   ${g.impl()}`;return{name:"MatMul",shaderCache:{hint:t.activationCacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:_[0],y:_[1],z:_[2]}}),getShaderSource:L}}});var Vu,Da,Wa=H(()=>{"use strict";lt();me();$e();Or();yn();tr();Vu=(e,t,r,i,o=!1,s,l=!1,n=4,c=4,m=4,g="f32")=>{let C=le=>{switch(le){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${g}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${le} is not supported.`)}},x=le=>{switch(le){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${le} is not supported.`)}},$=e?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,b=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,w=e?"xShape[1]":"xShape[2]",v=e?"xShape[2]":"xShape[3]",I=e?"row":"col",B=e?"col":"row",z=`\n    let inChannels = wShape[2];\n    let outWidth = ${e?"outShape[2]":"outShape[3]"};\n    let outRow = ${I} / outWidth;\n    let outCol = ${I} % outWidth;\n\n    let WRow = ${B} / (filterDims[1] * inChannels);\n    let WCol = ${B} / inChannels % filterDims[1];\n    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];\n    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];\n    let xCh = ${B} % inChannels;\n    var resData = ${Me(n,g)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the \'same\' padding type.\n    if (xRow >= 0 && xRow < ${w} && xCol >= 0 && xCol < ${v}) {\n      ${$}\n      let xIndex = getIndexFromCoords4D(coord, xShape);\n      ${C(n)}\n    }\n    return resData;`,M=e?t&&i?`\n    let col = colIn * ${n};\n    ${z}`:`\n    let col = colIn * ${n};\n    if (row < dimAOuter && col < dimInner) {\n      ${z}\n    }\n    return ${Me(n,g)}(0.0);`:i&&r?`\n    let col = colIn * ${n};\n    ${z}`:`\n    let col = colIn * ${n};\n    if (row < dimInner && col < dimBOuter) {\n      ${z}\n    }\n    return ${Me(n,g)}(0.0);`,G=`${x(c)}`,_=Me(m,g),U=e?Me(n,g):Me(c,g),V=e?Me(c,g):Me(n,g);return`\n    ${Tr(s,l,m===4,4)}\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${U} {\n      ${e?M:G}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${V} {\n      ${e?G:M}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${_}) {\n      let col = colIn * ${m};\n      if (row < dimAOuter && col < dimBOuter)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${b}\n      ${Er(o,s)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},Da=(e,t,r,i,o,s,l,n)=>{let c=t.format==="NHWC",m=c?e[0].dims[3]:e[0].dims[1],g=r[0],C=c?r[2]:r[3],x=c?r[1]:r[2],$=c?r[3]:r[1],b=c&&(m%4===0||m%3===0)&&$%4===0,w=c?$:C*x,v=c?C*x:$,I=[8,8,1],B=i<=8?[4,1,1]:[4,4,1],z=[Math.ceil(w/I[0]/B[0]),Math.ceil(v/I[1]/B[1]),Math.ceil(g/I[2]/B[2])];Ie("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${z}`);let M=b?c&&m%4!==0?3:4:B[0],G=I[1]*B[1],_=I[0]*B[0],U=Math.max(I[0]*M,I[1]),V=i%G===0,j=o%_===0,le=s%U===0,R=b?[M,4,4]:[1,1,1],X=Pe(e[0].dataType),Se=[`@group(0) @binding(0) var<storage, read> x: array<${b&&M===4?`vec4<${X}>`:X}>;`,`@group(0) @binding(1) var<storage, read> w: array<${b?`vec4<${X}>`:X}>;`],q=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${b?`vec4<${X}>`:X}) {\n        result[flatIndex] = ${b?`vec4<${X}>`:X}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${b?`vec4<${X}>`:X}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${b?"/ 4":""}, value);\n      }`;return l&&(Se.push(`@group(0) @binding(2) var<storage, read> bias: array<${b?`vec4<${X}>`:X}>;`),q+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${b?`vec4<${X}>`:X} {\n          return bias[coords.${c?"w":"y"}${b?"/ 4":""}];\n        }`),{name:"Conv2DMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:z[0],y:z[1],z:z[2]}}),getShaderSource:()=>`\n        ${_r}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${Se.join("")}\n        @group(0) @binding(${Se.length}) var<storage, read_write> result: array<${b?`vec4<${X}>`:X}>;\n        //@group(0) @binding(${Se.length+1}) var<uniform> uniforms: Uniforms;\n\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${D.computeStrides(r).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[0]}, ${t.kernelShape[1]});\n        const pad : vec2<i32> = vec2<i32>(${t.pads[0]}, ${t.pads[1]});\n        const stride : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${i};\n        const dimBOuter : i32 = ${o};\n        const dimInner : i32 = ${s};\n        ${q}\n        ${Vu(c,V,j,le,l,void 0,!1,R[0],R[1],R[2],X)}\n            ${b?Zt(B,I,X,void 0,!c,U):er(B,I,X,void 0,!c,U,!1,void 0,n)}`}}});var bn,za=H(()=>{"use strict";me();$e();vn();Jt();bn=(e,t,r)=>{let i=e.length>2,o=i?"value += b[output_channel];":"",s=e[0].dims,l=e[1].dims,n=l[0]/t.group,{activationFunction:c,applyActivation:m}=Pr(t),g=t.format==="NHWC",C=wn(s,l,t.dilations,t.pads,t.strides,g),x=D.size(C),$=se("output",e[0].dataType,C),b=K("x",e[0].dataType,s),w=K("w",e[1].dataType,l),v=[b,w];i&&v.push(K("b",e[2].dataType,e[2].dims));let I=B=>`\n  const strides: vec2<u32> = vec2(${t.strides[0]}u, ${t.strides[1]}u);\n  const pads: vec2<u32> = vec2(${t.pads[0]}u, ${t.pads[1]}u);\n\n  ${B.declareVariables(...v,$)}\n\n  ${c}\n\n  ${B.mainStart()}\n    ${B.guardAgainstOutOfBoundsWorkgroupSizes(x)}\n\n    let outputIndices = ${$.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${g?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${g?1:2}], outputIndices[${g?2:3}]) * strides - pads;\n    let group_id: u32 = output_channel / ${n}u;\n\n    var value: ${$.type.value} = ${$.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < ${l[1]}u; wInChannel++) {\n      let input_channel = group_id * ${l[1]}u + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < ${l[2]}u; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * ${t.dilations[0]}u;\n\n        if (xHeight < 0u || xHeight >= ${s[g?1:2]}u) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < ${l[3]}u; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * ${t.dilations[1]}u;\n          if (xWidth < 0u || xWidth >= ${s[g?2:3]}u) {\n            continue;\n          }\n\n          let xVal = ${g?b.get("batch","xHeight","xWidth","input_channel"):b.get("batch","input_channel","xHeight","xWidth")};\n          let wVal = ${w.get("output_channel","wInChannel","wHeight","wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${o}\n    ${m}\n    ${$.setByOffset("global_idx","value")}\n  }`;return{name:"GroupedConv",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r?r(C):C,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(x/64)}}),getShaderSource:I}}});var Fu,Ga,Hu,Lu,Et,Ua,Na,Mr=H(()=>{"use strict";me();_e();$e();Fu=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},Ga=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,Hu=(e,t)=>D.sortBasedOnPerm(e,Ga(e.length,t)),Lu=(e,t,r,i)=>{let o=[];o.push(`fn perm(i: ${i.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let s=0;s<t;++s)o.push(r.indicesSet("a",e[s],`i[${s}]`));return o.push("return a;}"),o.join(`\n`)},Et=(e,t,r)=>{let i=Ga(t,r),o=se("output",e,r&&r.length||t),s=K("a",e,t),l=n=>`\n  ${n.registerUniform("output_size","u32").declareVariables(s,o)}\n\n  ${Lu(i,t,s,o)}\n\n  ${n.mainStart()}\n    ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${o.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${o.setByOffset("global_idx",s.getByIndices("aIndices"))}\n  }`;return{name:"Transpose",shaderCache:{hint:`${r}`,inputDependencies:["rank"]},getRunData:n=>{let c=Hu(n[0].dims,i),m=D.size(c);return{outputs:[{dims:c,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:[{type:"uint32",data:m},...cn(n[0].dims),...cn(c)]}},getShaderSource:l}},Ua=(e,t)=>{Fu(e.inputs),e.compute(Et(e.inputs[0].dataType,e.inputs[0].dims.length,t.perm))},Na=e=>ae({perm:e.perm})});var wn,Va,ju,Fa,Ha,Ku,qu,La,vn=H(()=>{"use strict";me();_e();Wa();tr();za();Jt();Mr();wn=(e,t,r,i,o,s)=>{let l=e[0],n=e.slice(s?1:2,s?3:4),c=n.length,m=t[0],C=t.slice(2).map((b,w)=>b+(b-1)*(r[w]-1)),$=n.map((b,w)=>b+i[w]+i[w+c]).map((b,w)=>Math.floor((b-C[w]+o[w])/o[w]));return $.splice(0,0,l),$.splice(s?3:1,0,m),$},Va=[2,3,1,0],ju=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],i=e[1].dims[1]*t.group;if(r!==i)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let o=e[0].dims.length-2;if(t.dilations.length!==o)throw new Error(`dilations should be ${o}D`);if(t.strides.length!==o)throw new Error(`strides should be ${o}D`);if(t.pads.length!==o*2)throw new Error(`pads should be ${o*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},Fa=(e,t)=>{let r=e.kernelShape.slice();for(let s=2;s<t[1].dims.length;++s)r[s-2]===0&&(r[s-2]=t[1].dims[s]);let i=e.pads.slice();bt.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,i,e.format==="NHWC",e.autoPad);let o=Object.assign({},e);return Object.assign(o,{kernelShape:r,pads:i,cacheKey:e.cacheKey}),o},Ha=e=>{let t=Rr(e),r=e.format,i=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],o=e.dilations,s=e.group,l=e.kernel_shape,n=e.pads,c=e.strides,m=e.w_is_const();return ae({autoPad:i,format:r,dilations:o,group:s,kernelShape:l,pads:n,strides:c,wIsConst:m,...t})},Ku=(e,t,r)=>{let i=Fa(r,t);if(r.group!==1){e.compute(bn(t,i));return}let o=r.format==="NHWC",s=t.length===3,l=t[0].dims[o?1:2],n=t[0].dims[o?2:3],c=t[0].dims[o?3:1],m=t[1].dims[2],g=t[1].dims[3],C=wn(t[0].dims,t[1].dims,r.dilations,i.pads,r.strides,o),x=C[o?1:2],$=C[o?2:3],b=C[o?3:1],w=o&&m===l&&g===n&&r.pads[0]===0&&r.pads[1]===0;if(w||m===1&&g===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let _=C[0],U,V,j,le=[];if(o){let R=e.kernelCustomData.wT??e.compute(Et(t[1].dataType,t[1].dims.length,Va),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=R),w){let X=l*n*c;U=t[0].reshape([1,_,X]),V=R.reshape([1,X,b]),j=[1,_,b]}else U=t[0].reshape([_,l*n,c]),V=R.reshape([1,c,b]),j=[_,x*$,b];le.push(U),le.push(V)}else U=t[0].reshape([_,c,l*n]),V=t[1].reshape([1,b,c]),j=[_,b,x*$],le.push(V),le.push(U);s&&le.push(t[2]),e.compute(Br(le,i,C,j,o),{inputs:le});return}let v=!0,I=e.kernelCustomData.wT??e.compute(Et(t[1].dataType,t[1].dims.length,Va),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=I);let B=[t[0],I];s&&B.push(t[2]);let z=o?x*$:b,M=o?b:x*$,G=m*g*c;e.compute(Da(B,i,C,z,M,G,s,v),{inputs:B})},qu=(e,t)=>{let r=t.format==="NHWC",i=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&i.push(e.inputs[2]);let o=[0,t.pads[0],0,t.pads[1]],s=[1].concat(t.strides),l=[1].concat(t.dilations),n=[1].concat(t.kernelShape),c=Fa({...t,pads:o,strides:s,dilations:l,kernelShape:n},i);e.compute(bn(i,c,m=>r?[m[0],m[2],m[3]]:[]))},La=(e,t)=>{ju(e.inputs,t),e.inputs[0].dims.length===3?qu(e,t):Ku(e,e.inputs,t)}});var Yu,ja,Ka=H(()=>{"use strict";lt();me();Or();yn();tr();Yu=(e,t=!1,r,i=!1,o=4)=>{let s=Me(o,"f32"),l=I=>{switch(I){case 1:return"return W[getIndexFromCoords4D(coord, wShape)];";case 4:return`\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            `;default:throw new Error(`innerElementSize ${I} is not supported.`)}},n=e?`\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      `:`\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      `,c=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,m=e?"outBackprop[1]":"outBackprop[2]",g=e?"outBackprop[2]":"outBackprop[3]",C=e?"row":"col",x=e?"col":"row",$=`\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      let outRow = ${C} / outWidth;\n      let outCol = ${C} % outWidth;\n\n      let WRow = ${x} / (filterDims[1] * inChannels);\n      let WCol = ${x} / inChannels % filterDims[1];\n      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);\n      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);\n      if (xR < 0.0 || xR >= f32(${m}) || fract(xR) > 0.0) {\n        return ${s}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${g}) || fract(xC) > 0.0) {\n        return ${s}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${x} % inChannels;\n      ${n}\n      return x[getIndexFromCoords4D(coord, xShape)/${o}];`,b=e?`\n      let col = colIn * ${o};\n      if (row < dimAOuter && col < dimInner) {\n        ${$}\n      }\n      return ${s}(0.0);`:`\n      let col = colIn * ${o};\n      if (row < dimInner && col < dimBOuter) {\n        ${$}\n      }\n      return ${s}(0.0);`,w=`\n      let col = colIn * ${o};\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);\n      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];\n      if (${e?"row < dimInner && col < dimBOuter":"row < dimInner && col < dimAOuter"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${l(o)}\n      }\n      return ${s}(0.0);\n      `;return`\n  ${Tr(r,i,o===4,4)}\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${s} {\n    ${e?b:w}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${s} {\n    ${e?w:b}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${s}) {\n    let col = colIn * ${o};\n    if (row < dimAOuter && col < dimBOuter) {\n      var value = valueInput;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${c}\n      ${Er(t,r)}\n      result[getIndexFromCoords4D(coords, outShape)/${o}] = value;\n    }\n  }`},ja=(e,t,r,i,o,s,l,n)=>{let c=t.format==="NHWC",m=c?e[0].dims[3]:e[0].dims[1],g=r[0],C=c?r[2]:r[3],x=c?r[1]:r[2],$=c?r[3]:r[1],b=c?m%4===0&&$%4===0:C%4===0&&$%4===0,w=c?$:C*x,v=c?C*x:$,I=b?[8,8,1]:[w<=4||v<=4?4:16,w>4&&v<=4?4:16,1],B=b?[4,4,1]:[w<=4?1:4,w>4&&v<=4?1:4,1],z=[Math.ceil(w/I[0]/B[0]),Math.ceil(v/I[1]/B[1]),Math.ceil(g/I[2]/B[2])];Ie("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${z}`);let M=b?4:1,G=Math.max(I[0]*M,I[1]),_=[`@group(0) @binding(0) var<storage, read> x: array<${b?"vec4<f32>":"f32"}>;`,"@group(0) @binding(1) var<storage, read> W: array<f32>;"],U="";return l&&(_.push(`@group(0) @binding(2) var<storage, read> bias: array<${b?"vec4<f32>":"f32"}>;`),U+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${b?"vec4<f32>":"f32"} {\n          return bias[coords.${c?"w":"y"}${b?"/ 4":""}];\n        }`),{name:"Conv2DTransposeMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:z[0],y:z[1],z:z[2]}}),getShaderSource:()=>`\n        ${_r}\n        ${_.join(`\n`)}\n        @group(0) @binding(${_.length}) var<storage, read_write> result: array<${b?"vec4<f32>":"f32"}>;\n        const outBackprop : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${D.computeStrides(r).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[c?1:2]}, ${t.kernelShape[c?2:3]});\n        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(\n              ${t.dilations[0]<=1?0:(t.kernelShape[c?1:2]-1)*(t.dilations[0]-1)},\n              ${t.dilations[1]<=1?0:(t.kernelShape[c?2:3]-1)*(t.dilations[1]-1)});\n        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${t.pads[0]+t.pads[2]})/2,\n                                         i32(effectiveFilterDims[1]) - 1 - (${t.pads[1]+t.pads[3]})/2);\n        const strides : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${i};\n        const dimBOuter : i32 = ${o};\n        const dimInner : i32 = ${s};\n        ${U}\n        ${Yu(c,l,void 0,!1,M)}\n        ${b?Zt(B,I,"f32",void 0,!c,G):er(B,I,"f32",void 0,!c,G,!1,void 0,n)}`}}});var Xu,$n,qa=H(()=>{"use strict";lt();me();$e();Xu=(e,t,r,i,o,s,l=!1,n)=>{let c=r.format==="NHWC",m=c?1:2,g=c?2:3,C=c?3:1,x=D.size(i),$=l?2:1,b=r.group,w=t[1].dims,v=w[0]/b,I=w[1],B=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${l?`vec4<${n}>`:n}) {\n    result[flatIndex] = ${l?`vec4<${n}>`:n}(value);\n  }`;o&&(B+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${l?`vec4<${n}>`:n} {\n      return bias[coords.${c?"w":"y"}${l?"/ 4":""}];\n    }`);let z=l?4:1,M=K("W",t[1].dataType,t[1].dims,z),G=K("Dy",t[0].dataType,t[0].dims,z),_=[G,M];o&&_.push(K("bias",t[2].dataType,[i[C]],z));let U=se("result",t[0].dataType,i,z),V=`{\n        let batch: u32 = ${s?"global_id.z":"workgroup_id.z"} / outShape[1];\n        let r = ${s?"global_id.z":"workgroup_id.z"} % outShape[1];\n        let c = ${s?"global_id.y":"workgroup_id.y"} * ${$};\n        let d1: u32 = ${s?"global_id.x":"workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${n}>, ${$}>;\n        for (var i = 0; i < ${$}; i++) {\n          dotProd[i] = vec4<${n}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {\n          var dyR = (${n}(dyCorner.x) + ${n}(wR)) / ${n}(strides.x);\n          let wRPerm = filterDims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${n}(outBackprop[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {\n            let dyC = (${n}(dyCorner.y) + ${n}(wC)) / ${n}(strides.y);\n            let dyC2 = (${n}(dyCorner.y) + 1.0 + ${n}(wC)) / ${n}(strides.y);\n            let wCPerm = filterDims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${n}(outBackprop[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${n}(outBackprop[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${G.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${n}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${G.get("batch","idyR","idyC2","d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${n}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = outBackprop[${C}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${G.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${n}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${G.get("batch","idyR","idyC2","d2")};\n                let tmpval = vec4<${n}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${$}; i = i + 1) {\n          let value = dotProd[i] + ${o?"bias[c+i]":"0.0"};\n          ${U.set("batch","r","c + i","d1","value")};\n        }\n      }`,j=`\n          let outputIndices = ${U.offsetToIndices("global_idx")};\n          let batch = ${U.indicesGet("outputIndices",0)};\n          let d1 = ${U.indicesGet("outputIndices",C)};\n          let r = ${U.indicesGet("outputIndices",m)};\n          let c = ${U.indicesGet("outputIndices",g)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / ${I};\n          let wOutChannel = d1 - groupId * ${I};\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = 0.0;\n          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {\n            if (wR % dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${n}(dyRCorner) + ${n}(wR)) / ${n}(strides[0]);\n            let wRPerm = filterDims.x - 1 - wR / dilations.x;\n            if (dyR < 0.0 || dyR >= ${n}(outBackprop[${m}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {\n              if (wC % dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${n}(dyCCorner) + ${n}(wC)) / ${n}(strides.y);\n              let wCPerm = filterDims.y - 1 - wC / dilations.y;\n              if (dyC < 0.0 || dyC >= ${n}(outBackprop[${g}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * ${v};\n              for (var d2: u32 = 0; d2 < ${v}; d2 = d2 + 1) {\n                let xValue = ${c?G.get("batch","idyR","idyC","inputChannel"):G.get("batch","inputChannel","idyR","idyC")};\n                let wValue = ${M.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${o?"bias[d1]":"0.0"};\n          ${U.setByOffset("global_idx","value")};\n        `;return`\n  ${e.declareVariables(..._,U)}\n  ${B}\n  const outShape : vec4<u32> = vec4<u32>(${i.join(",")});\n  const outBackprop : vec4<u32> = vec4<u32>(${t[0].dims.join(",")});\n  const strides : vec2<u32> = vec2<u32>(${r.strides[0]}, ${r.strides[1]});\n  const filterDims : vec2<u32> = vec2<u32>(${r.kernelShape[c?1:2]}, ${r.kernelShape[c?2:3]});\n  const dilations : vec2<u32> = vec2<u32>(${r.dilations[0]}, ${r.dilations[1]});\n  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(\n          ${r.dilations[0]<=1?0:(r.kernelShape[c?1:2]-1)*(r.dilations[0]-1)},\n          ${r.dilations[1]<=1?0:(r.kernelShape[c?2:3]-1)*(r.dilations[1]-1)});\n  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${r.pads[0]+r.pads[2]})/2,\n                                     i32(effectiveFilterDims[1]) - 1 - (${r.pads[1]+r.pads[3]})/2);\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(x)};\n  ${l?V:j}}`},$n=(e,t,r)=>{let i=e.length>2,o=t.outputShape,s=D.size(o),l=[Math.ceil(s/64),1,1];Ie("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${l}`);let n=Pe(e[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:t.cacheKey},getRunData:()=>({dispatchGroup:{x:l[0],y:l[1],z:l[2]},outputs:[{dims:r?r(o):o,dataType:e[0].dataType}]}),getShaderSource:c=>Xu(c,e,t,o,i,l[1]===1&&l[2]===1,!1,n)}}});var Qu,Ju,Zu,Ya,Xa,el,tl,rl,nl,Qa,Ja=H(()=>{"use strict";_e();Ka();qa();Jt();Mr();Qu=(e,t,r,i,o,s)=>(e-1)*t+r+(i-1)*o+1-s,Ju=(e,t,r,i,o)=>{let s=Math.floor(e/2);t==="SAME_UPPER"?(r[i]=s,r[o]=e-s):t==="SAME_LOWER"&&(r[i]=e-s,r[o]=s)},Zu=(e,t,r,i,o,s,l,n,c,m)=>{let g=e.length-2,C=m.length===0;if(c.length===0)for(let b=0;b<g;++b)c.push(0);let x=e[0],$=t[n?3:1]*o;for(let b=0,w=e.length-g-(n?1:0);b<g;++b,++w){let v=e[w],I=C?v*l[b]:m[b],B=Qu(v,l[b],s[b],t[w],r[b],I);Ju(B,i,s,b,b+g),C&&m.push(l[b]*(v-1)+c[b]+(t[w]-1)*r[b]+1-s[b]-s[b+g])}m.splice(0,0,x),m.splice(n?3:1,0,$)},Ya=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((x,$)=>x*$,1)===0){r.length=0;for(let x=2;x<t[1].dims.length;++x)r.push(t[1].dims[x])}let i=e.format==="NHWC";r.splice(0,0,t[1].dims[0]),r.splice(i?3:1,0,t[1].dims[1]);let o=e.pads.slice(),s=e.outputShape.slice(),l=e.outputPadding.slice(),n=t[0].dims,c=e.dilations.slice();if(c.reduce((x,$)=>x+$,0)===0){let x=t[0].dims.length-2;c=new Array(x).fill(1)}let m=e.strides.slice();if(m.reduce((x,$)=>x+$,0)===0){let x=t[0].dims.length-2;m=new Array(x).fill(1)}Zu(n,r,c,e.autoPad,e.group,o,m,i,l,s);let g=Object.assign({},e),C=e.cacheKey+[r.join("n,"),o.join(","),m.join(","),l.join(","),s.join(","),c.join(",")].join("_");return Object.assign(g,{kernelShape:r,pads:o,outputPadding:l,outputShape:s,dilations:c,strides:m,cacheKey:C}),g},Xa=e=>{let t=Rr(e),r=e.format,i=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],o=e.dilations,s=e.group,l=e.kernelShape,n=e.pads,c=e.strides,m=e.wIsConst(),g=e.outputPadding,C=e.outputShape;return ae({autoPad:i,format:r,dilations:o,group:s,kernelShape:l,outputPadding:g,outputShape:C,pads:n,strides:c,wIsConst:m,...t})},el=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],i=e[1].dims[0];if(r!==i)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let o=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==o))throw new Error("invalid bias");let s=e[0].dims.length-2;if(t.dilations.reduce((g,C)=>g+C,0)>0&&t.dilations.length!==s)throw new Error(`dilations should be ${s}D`);if(t.strides.reduce((g,C)=>g+C,0)>0&&t.strides.length!==s)throw new Error(`strides should be ${s}D`);if(t.pads.reduce((g,C)=>g+C,0)>0&&t.pads.length!==s*2)throw new Error(`pads should be ${s*2}D`);if(t.outputPadding.length!==s&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${s}D`);if(t.kernelShape.reduce((g,C)=>g+C,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},tl=[2,3,1,0],rl=(e,t,r)=>{let i=Ya(r,t),o=r.format==="NHWC",s=t.length===3;if(i.group!==1){e.compute($n(t,i));return}let l=i.outputShape,n=l[o?1:2],c=l[o?2:3],m=l[o?3:1],g=t[1].dims[2],C=t[1].dims[3],x=t[0].dims[o?3:1],$=o?n*c:m,b=o?m:n*c,w=g*C*x,v=!0,I=e.kernelCustomData.wT??e.compute(Et(t[1].dataType,t[1].dims.length,tl),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=I);let B=[t[0],I];s&&(!o&&t[2].dims.length===1?B.push(t[2].reshape([t[2].dims[0],1,1])):B.push(t[2])),e.compute(ja(B,i,l,$,b,w,s,v),{inputs:B})},nl=(e,t)=>{let r=t.format==="NHWC",i=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];i.length===3&&i.push(e.inputs[2]);let o=t.kernelShape;(o.length===0||o[0]===0)&&(o=[e.inputs[1].dims[2]]);let s=t.dilations;(s.length===0||s[0]===0)&&(s=[1]);let l=t.strides;(l.length===0||l[0]===0)&&(l=[1]);let n=t.pads;n.length===0&&(n=[0,0]),n=[0,n[0],0,n[1]],l=[1].concat(l),s=[1].concat(s),o=[1].concat(o);let c=Ya({...t,pads:n,strides:l,dilations:s,kernelShape:o},i);e.compute($n(i,c,m=>r?[m[0],m[2],m[3]]:[m[0],m[1],m[3]]))},Qa=(e,t)=>{el(e.inputs,t),e.inputs[0].dims.length===3?nl(e,t):rl(e,e.inputs,t)}});var xn,kr,Za,ol,al,Cn,Sn,il,ei,ti,ri=H(()=>{"use strict";me();_e();$e();xn="[a-zA-Z]|\\\\.\\\\.\\\\.",kr="("+xn+")+",Za="^"+kr+"$",ol="("+kr+",)*"+kr,al="^"+ol+"$",Cn=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let i=this.symbolToIndices.get(t);i===void 0?i=[r]:i.push(r),this.symbolToIndices.set(t,i)}},Sn=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[i,o]=r.includes("->")?r.split("->",2):[r,""];if(!i.match(RegExp(al)))throw new Error("Invalid LHS term");if(i.split(",").forEach((n,c)=>{let m=t[c].dims.slice();if(!n.match(RegExp(Za)))throw new Error("Invalid LHS term");let g=this.processTerm(n,!0,m,c);this.lhs.push(g)}),o==="")o+=[...this.symbolToInfo.entries()].filter(([n,c])=>c.count===1||n==="...").map(([n])=>n).join("");else if(!o.match(RegExp(kr)))throw new Error("Invalid RHS");o.match(RegExp(xn,"g"))?.forEach(n=>{if(n==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let c=this.symbolToInfo.get(n);if(c===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(c.dimValue)}}),this.rhs=this.processTerm(o,!0,this.outputDims)}addSymbol(t,r,i){let o=this.symbolToInfo.get(t);if(o!==void 0){if(o.dimValue!==r&&o.count!==1)throw new Error("Dimension mismatch");o.count++,o.inputIndices.push(i)}else o={count:1,dimValue:r,inputIndices:[i]};this.symbolToInfo.set(t,o)}processTerm(t,r,i,o=-1){let s=i.length,l=!1,n=[],c=0;if(!t.match(RegExp(Za))&&!r&&t!=="")throw new Error("Invalid LHS term");let m=t.match(RegExp(xn,"g")),g=new Cn(o);return m?.forEach((C,x)=>{if(C==="..."){if(l)throw new Error("Only one ellipsis is allowed per input term");l=!0;let $=s-m.length+1;if($<0)throw new Error("Ellipsis out of bounds");if(n=i.slice(c,c+$),this.hasEllipsis){if(this.ellipsisDims.length!==n.length||this.ellipsisDims.toString()!==n.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=n;else throw new Error("Ellipsis must be specified in the LHS");for(let b=0;b<n.length;b++){let w=String.fromCharCode("0".charCodeAt(0)+x);g.addSymbol(w,x+b),this.addSymbol(w,i[c++],o)}}else g.addSymbol(C,x),this.addSymbol(C,i[c++],o)}),g}},il=(e,t)=>{let r=e[0].dataType,i=new Array(e.length);for(let z=0;z<e.length;++z)i[z]=K(`input${z}`,r,e[z].dims);let o=t.outputDims,s=D.size(o),l=se("output",r,o),n=[],c=Array.from(t.rhs.symbolToIndices.keys()),m="var prod = 1.0;",g="var sum = 0.0;",C="sum += prod;",x=[],$=[],b=[],w=[],v=t.symbolToInfo.size===c.length;t.symbolToInfo.forEach((z,M)=>{if(c.includes(M)){let G=c.indexOf(M);t.lhs.forEach((_,U)=>{if(z.inputIndices.includes(U)){let V=_.symbolToIndices.get(M);if(V===void 0)throw new Error("Invalid symbol error");V.forEach(j=>{n.push(`${i[U].indicesSet(`input${U}Indices`,j,l.indicesGet("outputIndices",G))}`)})}})}else t.lhs.forEach((G,_)=>{let U=t.symbolToInfo.get(M);if(U===void 0)throw new Error("Invalid symbol error");if(U.inputIndices.includes(_)){let V=G.symbolToIndices.get(M);if(V===void 0)throw new Error("Invalid symbol error");V.forEach(j=>{x.push(`${i[_].indicesSet(`input${_}Indices`,j,`${M}`)}`)}),w.push(`prod *= ${i[_].getByIndices(`input${_}Indices`)};`)}}),$.push(`for(var ${M}: u32 = 0; ${M} < ${t.symbolToInfo.get(M)?.dimValue}; ${M}++) {`),b.push("}")});let I=v?[...n,`let sum = ${i.map((z,M)=>z.getByIndices(`input${M}Indices`)).join(" * ")};`]:[...n,g,...$,...x,m,...w,C,...b],B=z=>`\n      ${z.declareVariables(...i,l)}\n\n      ${z.mainStart()}\n        ${z.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n        var outputIndices = ${l.offsetToIndices("global_idx")};\n        ${i.map((M,G)=>`var input${G}Indices: ${i[G].type.indices};`).join(`\n`)}\n        ${I.join(`\n`)};\n        ${l.setByOffset("global_idx","sum")};\n      }`;return{name:"Einsum",shaderCache:{hint:t.equation},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:B}},ei=(e,t)=>{let r=new Sn(e.inputs,t.equation);e.compute(il(e.inputs,r))},ti=e=>{let t=e.equation.replace(/\\s+/g,"");return ae({equation:t})}});var sl,ni,ul,ll,oi,ai=H(()=>{"use strict";me();$e();sl=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),i=r.length<t.length?0:r.length-t.length,o=t.length<r.length?0:t.length-r.length;for(;i<r.length&&o<t.length;++i,++o)if(r[i]!==t[o]&&r[i]!==1&&t[o]!==1)throw new Error("Expand requires shape to be broadcastable to input")},ni=(e,t)=>{let r=e.length-t.length,i=[];for(let o=0;o<r;++o)i.push(e[o]);for(let o=0;o<t.length;++o)i.push(t[o]===1?e[o+r]:t[o]);return i},ul=(e,t)=>e.length>t.length?ni(e,t):ni(t,e),ll=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),i=ul(t,r),o=D.size(i),s=e[0].dataType,l=K("input",s,t),n=se("output",s,i),c=m=>`\n  const inputShape = ${l.indices(...t)};\n  ${m.declareVariables(l,n)}\n  ${m.mainStart()}\n  ${m.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n    let outputIndices = ${n.offsetToIndices("global_idx")};\n    var inputIndices: ${l.type.indices};\n    for (var i = 0; i < ${t.length}; i++) {\n      if (${l.indicesGet("inputShape","i")} == 1) {\n        ${l.indicesSet("inputIndices","i",0)}\n      } else {\n        ${l.indicesSet("inputIndices","i",n.indicesGet("outputIndices",`i + ${i.length-t.length}`))}\n      }\n    }\n    ${n.setByOffset("global_idx",l.getByIndices("inputIndices"))}\n  }`;return{name:"Expand",shaderCache:{hint:`${i}`},getShaderSource:c,getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}})}},oi=e=>{sl(e.inputs),e.compute(ll(e.inputs),{inputs:[0]})}});var dl,cl,ii,si,ui=H(()=>{"use strict";me();_e();$e();dl=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},cl=(e,t)=>{let r=e[0].dims,i=e[1].dims,o=r.length,s=D.normalizeAxis(t.axis,o),l=r.slice(0);l.splice(s,1,...i);let n=r[s],c=D.size(l),m=K("data",e[0].dataType,e[0].dims),g=K("inputIndices",e[1].dataType,e[1].dims),C=se("output",e[0].dataType,l),x=()=>{let b=i.length,w=`var indicesIndices  = ${g.type.indices}(0);`;for(let v=0;v<b;v++)w+=`${b>1?`indicesIndices[${v}]`:"indicesIndices"} = ${l.length>1?`outputIndices[${s+v}]`:"outputIndices"};`;w+=`\n        var idx = ${g.getByIndices("indicesIndices")};\n        if (idx < 0) {\n          idx = idx + ${n};\n        }\n        var dataIndices = ${m.type.indices}(0);\n      `;for(let v=0,I=0;v<o;v++)v===s?(w+=`${o>1?`dataIndices[${v}]`:"dataIndices"} = u32(idx);`,I+=b):(w+=`${o>1?`dataIndices[${v}]`:"dataIndices"} = ${l.length>1?`outputIndices[${I}]`:"outputIndices"};`,I++);return w},$=b=>`\n      ${b.declareVariables(m,g,C)}\n      ${b.mainStart()}\n        ${b.guardAgainstOutOfBoundsWorkgroupSizes(c)}\n        let outputIndices = ${C.offsetToIndices("global_idx")};\n        ${x()};\n        let value = ${m.getByIndices("dataIndices")};\n        ${C.setByOffset("global_idx","value")};\n      }`;return{name:"Gather",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:l,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)}}),getShaderSource:$}},ii=e=>ae({axis:e.axis}),si=(e,t)=>{let r=e.inputs;dl(r),e.compute(cl(e.inputs,t))}});var pl,fl,li,di,ci=H(()=>{"use strict";me();_e();$e();pl=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},fl=(e,t)=>{let r=e[0].dims,i=e[0].dataType,o=r.length,s=D.computeStrides(r),l=D.size(r),n=e[1].dims,c=e[1].dataType,m=D.size(n),g=D.normalizeAxis(t.axis,o),C=r[g],x=n.slice(0),$=D.size(x),b=K("input",i,r),w=K("indices",c,[m]),v=se("output",i,x),I=B=>`\n      const inputStrides = array<u32, ${s.length}>(${s.map(z=>`${z}u`).join(",")});\n      ${B.declareVariables(b,w,v)}\n      ${B.mainStart()}\n      ${B.guardAgainstOutOfBoundsWorkgroupSizes($)}\n\n      let outputIndices = ${v.offsetToIndices("global_idx")};\n\n      var idx = ${w.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + ${C};\n      }\n\n      var srcOffset = u32(0);\n\n      for (var i = 0; i < ${r.length}; i++) {\n        if (i == ${g}) {\n          srcOffset +=  u32(idx) * inputStrides[i];\n        } else {\n          srcOffset += ${v.indicesGet("outputIndices","i")} * inputStrides[i];\n        }\n      }\n\n      // Should never hit this with valid values in indices\n      // This is a guard against malicious data in the indices input\n      if (srcOffset < 0 || srcOffset >= ${l}) {\n        return;\n      }\n\n      output[global_idx] = input[srcOffset];\n  }`;return{name:"GatherElements",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:x,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil($/64)}}),getShaderSource:I}},li=e=>ae({axis:e.axis}),di=(e,t)=>{let r=e.inputs;pl(r),e.compute(fl(e.inputs,t))}});var ml,hl,gl,pi,fi,mi=H(()=>{"use strict";me();_e();$e();ml=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},hl=(e,t,r)=>{if(r.length===0)return"0u";let i=r.length===1&&e!==1||r.length===2&&r[0]!==e,o=r[r.length-1]!==t,s="0u";return i||(s+=`+ m * ${r[r.length-1]}u`),o||(s+="+n"),s},gl=(e,t)=>{let r=e[0].dims.slice(),i=e[1].dims.slice(),[o,s,l]=$r.getShapeOfGemmResult(r,t.transA,i,t.transB,e.length===3?e[2].dims:void 0),n=[o,s];if(!n)throw new Error("Can\'t use gemm on the given tensors");let c=D.size(n),m="";t.transA&&t.transB?m="value += a[k * M + m] * b[n * K + k];":t.transA&&!t.transB?m="value += a[k * M + m] * b[k * N + n];":!t.transA&&t.transB?m="value += a[m * K + k] * b[n * K + k];":!t.transA&&!t.transB&&(m="value += a[m * K + k] * b[k * N + n];");let g=Pe(e[0].dataType),C=t.alpha===1?"":"value *= alpha;",x=e.length===3?`value += beta * c[${hl(o,s,e[2].dims)}];`:"",$=[`@group(0) @binding(0) var<storage, read> a : array<${g}>;`,`@group(0) @binding(1) var<storage, read> b : array<${g}>;`];e.length===3&&$.push(`@group(0) @binding(2) var<storage, read> c : array<${g}>;`);let b=w=>`\n  const M: u32 = ${o}u;\n  const N: u32 = ${s}u;\n  const K: u32 = ${l}u;\n  const alpha = ${g}(${t.alpha});\n  const beta = ${g}(${t.beta});\n\n  ${$.join(`\n`)}\n  @group(0) @binding(${e.length}) var<storage, read_write> output : array<${g}>;\n\n  ${w.mainStart()}\n    ${w.guardAgainstOutOfBoundsWorkgroupSizes(c)}\n\n    let m = global_id.x / N;\n    let n = global_id.x % N;\n\n    var value = ${g}(0);\n    for (var k: u32 = 0u; k<${l}u; k++) {\n      ${m}\n    }\n\n    ${C}\n    ${x}\n    output[global_id.x] = value;\n\n  }`;return{name:"Gemm",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)}}),getShaderSource:b}},pi=(e,t)=>{ml(e.inputs),e.compute(gl(e.inputs,t))},fi=e=>ae(e)});var hi,yl,bl,gi,yi,bi=H(()=>{"use strict";me();_e();$e();hi={name:"InstanceNormalization"},yl=(e,t)=>{let r=e[0].dims,i=r,o=2,s=D.sizeToDimension(r,o),l=D.sizeFromDimension(r,o),n=r[1],c=K("x",e[0].dataType,[r[0],r[1],l]),m=K("scale",e[1].dataType,e[1].dims),g=K("bias",e[2].dataType,e[2].dims),C=se("output",e[0].dataType,[r[0],r[1],l]),x=[c,m,g,C],$=c.type.value,b=64,w=v=>`\n\n  const C: u32 = ${n};\n  const normSize: u32 = ${l};\n  const epsilon: f32 = ${t.epsilon};\n  var<workgroup> meanShared : ${$};\n  var<workgroup> squaredNormShared : ${$};\n  var<workgroup> workgroupShared : array<${$}, ${b}>;\n  const workgroupSize = ${b}u;\n  ${v.declareVariables(...x)}\n  ${v.mainStart(b)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / C;\n    let channel = norm % C;\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial: ${$} = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      initial = initial + ${c.get("batch","channel","h")};\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = workgroupShared[0] / ${$}(normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let deviation =  ${c.get("batch","channel","h")} - meanShared;\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = workgroupShared[0];\n    }\n    workgroupBarrier();\n\n    let invStdDev = 1 / sqrt(squaredNormShared / ${$}(normSize) + epsilon);\n    let channelScale = invStdDev * ${m.getByOffset("channel")};\n    let channelShift = ${g.getByOffset("channel")} - meanShared * channelScale;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let value = ${c.get("batch","channel","h")} * channelScale + channelShift;\n      ${C.set("batch","channel","h","value")};\n    }\n  }`;return{...hi,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:s}}),getShaderSource:w}},bl=(e,t)=>{let r=e[0].dims,i=r,o=D.size(i),s=r[0],l=r[r.length-1],n=D.sizeFromDimension(r,1)/l,c=Pe(e[0].dataType),m=l*s,g=C=>`\n  const N: u32 = ${s};\n  const H: u32 = ${n};\n  const C: u32 = ${l};\n  const normSizeTyped: ${c} = ${n};\n  const imageSize: u32 = ${n*l};\n  const epsilon: f32 = ${t.epsilon};\n\n  @group(0) @binding(0) var<storage, read> x : array<${c}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${c}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${c}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${c}>;\n\n  ${C.mainStart()}\n    let currentImageNumber = global_idx / C;\n    let currentChannelNumber = global_idx % C;\n\n    // offset is channel num * N\n    let offset = currentImageNumber * imageSize;\n    if (offset >= ${o}) { return; }\n    var mean: ${c} = 0;\n\n    for (var i: u32 = 0u; i < H; i++) {\n        mean = mean + x[offset + i * C + currentChannelNumber];\n    }\n    mean = mean / normSizeTyped;\n\n    var squaredNorm: ${c} = 0;\n    for (var i: u32 = 0u; i < H; i++) {\n        let deviation: f32 = x[offset + i * C + currentChannelNumber] - mean;\n        squaredNorm = squaredNorm + deviation * deviation;\n    }\n    let invStdDev = 1 / sqrt(squaredNorm / normSizeTyped + epsilon);\n    let channelScale = invStdDev * scale[currentChannelNumber];\n    let channelShift = bias[currentChannelNumber] - mean * channelScale;\n    for (var i: u32 = 0u; i < H; i++) {\n        let currentOffset = offset + i * C + currentChannelNumber;\n        output[currentOffset] = x[currentOffset] * channelScale + channelShift;\n    }\n  }`;return{...hi,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)}}),getShaderSource:g}},gi=e=>ae({epsilon:e.epsilon,format:e.format}),yi=(e,t)=>{t.format==="NHWC"?e.compute(bl(e.inputs,t)):e.compute(yl(e.inputs,t))}});var wl,vl,wi,vi,$i=H(()=>{"use strict";ke();me();_e();$e();wl=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.");if(e[0].dataType!==1||e[1].dataType!==1)throw new Error("inputs should be float type")},vl=(e,t,r)=>{let i=e[0].dims,o=e[1],s=e[2],l=i,n=D.size(l),c=D.normalizeAxis(t.axis,i.length),m=D.sizeToDimension(i,c),g=D.sizeFromDimension(i,c),C=D.size(o.dims),x=s?D.size(s.dims):0;if(C!==g||s&&x!==g)throw new Error(`Size of X.shape()[axis:] == ${g}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${C} and bias size of ${x}`);let $=[];for(let M=0;M<i.length;++M)M<c?$.push(i[M]):$.push(1);let b=Pe(e[0].dataType),w=r>1,v=r>2,I=0,B=M=>`\n  const normSize: u32 = ${g};\n  const normSizeTyped: ${b} = ${g};\n  const epsilon: f32 = ${t.epsilon};\n\n  @group(0) @binding(${I++}) var<storage, read> x : array<${b}>;\n  @group(0) @binding(${I++}) var<storage, read> scale : array<${b}>;\n  ${s?`@group(0) @binding(${I++}) var<storage, read> bias : array<${b}>;`:""}\n  @group(0) @binding(${I++}) var<storage, read_write> output : array<${b}>;\n  ${w?`@group(0) @binding(${I++}) var<storage, read_write> meanDataOutput : array<${b}>`:""};\n  ${v?`@group(0) @binding(${I++}) var<storage, read_write> invStdOutput : array<${b}>`:""};\n\n  ${M.mainStart()}\n    let offset = global_idx * normSize;\n    if (offset >= ${n}) { return; }\n    var mean: ${b} = 0;\n    var meanSquare: ${b} = 0;\n\n    for (var h: u32 = 0u; h < normSize; h++) {\n      mean = mean + x[h + offset];\n      meanSquare = meanSquare + x[h + offset] * x[h + offset];\n    }\n    mean = mean / normSizeTyped;\n    meanSquare = sqrt(meanSquare / normSizeTyped - mean * mean + epsilon);\n\n    for (var j: u32 = 0; j < normSize; j++) {\n      output[j + offset] = (x[j + offset] - mean) / meanSquare * scale[j] ${s?"+ bias[j]":""};\n    }\n\n    ${w?"meanDataOutput[global_idx] = mean":""};\n    ${v?"invStdOutput[global_idx] = 1 / meanSquare":""};\n  }`,z=[{dims:l,dataType:e[0].dataType}];return w&&z.push({dims:$,dataType:e[0].dataType}),v&&z.push({dims:$,dataType:e[0].dataType}),{name:"LayerNormalization",shaderCache:{hint:`${t.cacheKey}|${r}|${e.length}`},getRunData:()=>({outputs:z,dispatchGroup:{x:Math.ceil(m/64)}}),getShaderSource:B}},wi=e=>ae({axis:e.axis,epsilon:e.epsilon}),vi=(e,t)=>{wl(e.inputs),e.compute(vl(e.inputs,t,e.outputCount))}});var $l,xi,Ci=H(()=>{"use strict";me();tr();$l=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},xi=e=>{$l(e.inputs);let t=Ze.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can\'t use matmul on the given tensors");e.compute(Br(e.inputs,{activation:"",activationCacheKey:""},t))}});var xl,Cl,Sl,Al,Il,Tl,El,Ol,_l,Si,Ai,Ii=H(()=>{"use strict";ke();me();_e();$e();xl=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1)throw new Error("Input type must be float.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},Cl=(e,t,r,i,o,s,l)=>{let n=r.length,c="";for(let m=n-1;m>=0;--m)c+=`\n            k = i32(${e.indicesGet("indices",m)}) - ${o[m]};\n            if (k < 0) {\n              break;\n            }\n            if (k >= ${r[m]}) {\n              break;\n            }\n            offset += k * ${i[m]};\n        `;return`\n          value = ${s}(${l});\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${c}\n            value = x[offset];\n          }\n      `},Sl=(e,t,r,i,o)=>{let s=r.length,l="";for(let n=s-1;n>=0;--n)l+=`\n                k = i32(${e.indicesGet("indices",n)}) - ${o[n]};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = ${2*(r[n]-1)};\n                  k = k % _2n_1;\n                  if(k >= ${r[n]}) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * ${i[n]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${l}\n              value = x[offset];\n          `},Al=(e,t,r,i,o)=>{let s=r.length,l="";for(let n=s-1;n>=0;--n)l+=`\n                k = i32(${e.indicesGet("indices",n)}) - ${o[n]};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= ${r[n]}) {\n                  k = ${r[n]-1};\n                }\n                offset += k * ${i[n]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${l}\n              value = x[offset];\n          `},Il=(e,t,r,i,o)=>{let s=r.length,l="";for(let n=s-1;n>=0;--n)l+=`\n                k = i32(${e.indicesGet("indices",n)}) - ${o[n]};\n                if (k < 0)  {\n                  k += ${r[n]};\n                }\n                if (k >= ${r[n]}) {\n                  k -= ${r[n]};\n                }\n                offset += k * ${i[n]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${l}\n              value = x[offset];\n          `},Tl=(e,t,r,i,o,s)=>{switch(o.mode){case 0:return Cl(e,t,r,i,o.pads,s,o.value);case 1:return Sl(e,t,r,i,o.pads);case 2:return Al(e,t,r,i,o.pads);case 3:return Il(e,t,r,i,o.pads);default:throw new Error("Invalid mode")}},El=(e,t,r,i)=>{let o=t[0].dims,s=D.padShape(o.slice(),r.pads),l=D.size(s),n=D.computeStrides(o),c=se("output",t[0].dataType,s),m=K("x",t[0].dataType,o),g=Tl(c,s,o,n,r,i);return`\n              ${e.declareVariables(m,c)}\n              ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(l)}\n\n              let indices = ${c.offsetToIndices("global_idx")};\n\n              var value = ${i}(0);\n              ${g}\n              output[global_idx] = value;\n          }`},Ol=(e,t)=>{let r=D.padShape(e[0].dims.slice(),t.pads);return{name:"Pad",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(D.size(r)/64)}}),getShaderSource:i=>El(i,e,t,"f32")}},_l=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),i=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,o=e[0].dims.length,s=new Int32Array(2*o).fill(0);if(e.length>=4){let n=e[3].getBigInt64Array();for(let c=0;c<n.length;c++)s[Number(n[c])]=Number(r[c]),s[Number(n[c])+o]=Number(r[c+n.length])}else r.forEach((n,c)=>s[Number(c)]=Number(n));let l=[];return s.forEach(n=>l.push(n)),ae({mode:t.mode,value:i,pads:l})}else return t},Si=(e,t)=>{xl(e.inputs);let r=_l(e.inputs,t);e.compute(Ol(e.inputs,r),{inputs:[0]})},Ai=e=>{let t=e.mode,r=e.value,i=e.pads;return ae({mode:t,value:r,pads:i})}});var Dr,Ti,Ei,Oi,_i,Pi,Ri,Bi,Mi,ki,Di,Wi,zi,Gi,Ui,Ni=H(()=>{"use strict";me();_e();$e();Dr=e=>{if(!e||e.length!==1)throw new Error("Pool ops requires 1 input.");if(e[0].dims.length!==4)throw new Error("Pool ops supports 2-D inputs only for now.")},Ti=(e,t,r)=>{let i=t.format==="NHWC",o=i?[e.dims[0],e.dims[3],e.dims[1],e.dims[2]]:e.dims.slice(),s=Object.hasOwnProperty.call(t,"dilations"),l=t.kernelShape.slice(),n=t.strides.slice(),c=s?t.dilations.slice():[],m=t.pads.slice();bt.adjustPoolAttributes(r,o,l,n,c,m);let g=bt.computePoolOutputShape(r,o,n,c,l,m,t.autoPad),C=Object.assign({},t);return s?Object.assign(C,{kernelShape:l,strides:n,pads:m,dilations:c,cacheKey:t.cacheKey}):Object.assign(C,{kernelShape:l,strides:n,pads:m,cacheKey:t.cacheKey}),[C,i?[g[0],g[2],g[3],g[1]]:g]},Ei=(e,t,r,i,o,s,l,n)=>{let c=o.format==="NHWC",m=r,g=t.type.value,C=m.length,x=D.size(i),$=se("output",t.type.tensor,i);if(o.kernelShape.length<=2){let b=o.kernelShape[o.kernelShape.length-1],w=o.strides[o.strides.length-1],v=o.pads[o.pads.length/2-1],I=o.pads[o.pads.length-1],B=C-(c?2:1),z="",M="",G="";if(v+I!==0?z=`\n              for (var i: u32 = 0u; i < ${b}u; i++) {\n                xIndices[${B}] = indices[${B}] * ${w} - ${v} + i;\n                if (xIndices[${B}] < 0 || xIndices[${B}] >= ${m[B]}) {\n                  pad++;\n                  continue;\n                }\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${s}\n              }`:z=`\n              for (var i: u32 = 0u; i < ${b}u; i++) {\n                xIndices[${B}] = indices[${B}] * ${w} - ${v} + i;\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${s}\n              }`,o.kernelShape.length===2){let U=o.kernelShape[o.kernelShape.length-2],V=o.strides[o.strides.length-2],j=o.pads[o.pads.length/2-2],le=o.pads[o.pads.length-2],R=C-(c?3:2),X=m[R];j+le!==0?M=`\n                for (var j: u32 = 0u; j < ${U}u; j++) {\n                  xIndices[${R}] = indices[${R}] * ${V} - ${j} + j;\n                  if (xIndices[${R}] < 0 || xIndices[${R}] >= ${X}) {\n                    pad+= ${b};\n                    continue;\n                  }\n              `:M=`\n                for (var j: u32 = 0u; j < ${U}u; j++) {\n                  xIndices[${R}] = indices[${R}] * ${V} - ${j} + j;\n                `,G=`\n              }\n            `}return`\n            ${e.declareVariables(t,$)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(x)}\n\n              let indices = ${$.offsetToIndices("global_idx")};\n              var xIndices = ${$.offsetToIndices("global_idx")};\n\n              var value: ${g} = ${g}(${n});\n              var pad = 0;\n              ${M}\n              ${z}\n              ${G}\n              ${l}\n\n              output[global_idx] = value;\n            }`}else{if(c)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let b=D.size(o.kernelShape),w=D.computeStrides(o.kernelShape),v=w.length,I=o.pads.length,B=o.pads.reduce((G,_)=>G+_),z="";return B?z=`\n                if (xIndices[j] >= inputDims[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${s}\n              }`:z=`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${s}\n            `,`\n            ${e.declareVariables(t,$)}\n\n            const pads = array<u32, ${I}>(${o.pads.map(G=>`${G}u`).join(",")});\n            const inputDims = array<u32, ${C}>(${m.map(G=>`${G}u`).join(",")});\n            const kernelStrides = array<u32, ${v}>(${w.map(G=>`${G}u`).join(",")});\n            const strides = array<u32, ${v}>(${o.strides.map(G=>`${G}u`).join(",")});\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(x)}\n\n              let indices = ${$.offsetToIndices("global_idx")};\n              let xIndices = ${$.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${v}>;\n\n              var value = ${$.type.value}(${n});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < ${b}u; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${v-1}u; j++) {\n                  offsets[j] = offset / kernelStrides[j];\n                  offset -= offsets[j] * kernelStrides[j];\n                }\n                offsets[${v-1}] = offset;\n\n                isPad = false;\n                for (var j = ${C-v}u; j < ${C}u; j++) {\n                  xIndices[j] = indices[j] * strides[j - ${C-v}u]\n                    + offsets[j - ${C-v}u] - pads[j - 2u];\n                  ${z}\n              }\n              ${l}\n\n              output[global_idx] = value;\n            }`}},Oi=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),_i=(e,t,r,i)=>{let[o,s]=Ti(t,i,r),l=D.size(o.kernelShape),n=K("x",t.dataType,t.dims),c=n.type.value,m="value += x_val;",g="";return o.countIncludePad?g+=`value /= ${c}(${l});`:g+=`value /= ${c}(${l} - pad);`,{name:e,shaderCache:{hint:i.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(D.size(s)/64)}}),getShaderSource:C=>Ei(C,n,t.dims,s,o,m,g,"0.0")}},Pi=e=>{let t=e.count_include_pad!==0,r=Oi(e);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return ae({countIncludePad:t,...r})},Ri=(e,t)=>{Dr(e.inputs),e.compute(_i("AveragePool",e.inputs[0],!1,t))},Bi={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},Mi=e=>{let t=e.format;return{format:t,...Bi,cacheKey:t}},ki=(e,t)=>{Dr(e.inputs),e.compute(_i("GlobalAveragePool",e.inputs[0],!0,t))},Di=(e,t,r,i)=>{let[o,s]=Ti(t,i,r),l=`\n      value = max(x_val, value);\n    `,n="",c=K("x",t.dataType,t.dims);return{name:e,shaderCache:{hint:i.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(D.size(s)/64)}}),getShaderSource:m=>Ei(m,c,t.dims,s,o,l,n,"-1e5")}},Wi=(e,t)=>{Dr(e.inputs),e.compute(Di("MaxPool",e.inputs[0],!1,t))},zi=e=>{let t=e.storage_order,r=e.dilations,i=Oi(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(i.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return ae({storageOrder:t,dilations:r,...i})},Gi=e=>{let t=e.format;return{format:t,...Bi,cacheKey:t}},Ui=(e,t)=>{Dr(e.inputs),e.compute(Di("GlobalMaxPool",e.inputs[0],!0,t))}});var An=H(()=>{"use strict"});var Vi=H(()=>{"use strict";An()});var Fi,Hi=H(()=>{"use strict";Fi="1.17.0"});var Li,In,ji=H(()=>{"use strict";Hi();Li="warning",In={wasm:{},webgl:{},webgpu:{},versions:{common:Fi},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);Li=e}},get logLevel(){return Li}};Object.defineProperty(In,"logLevel",{enumerable:!0})});var Ki,qi=H(()=>{"use strict";ji();Ki=In});var Yi=H(()=>{"use strict"});var Xi=H(()=>{"use strict";Wr()});var Ji=H(()=>{"use strict"});var Zi=H(()=>{"use strict";Wr()});var Wr=H(()=>{"use strict";Yi();Xi();Ji();Zi()});var Tn=H(()=>{"use strict";Wr()});var es=H(()=>{"use strict";An();Tn()});var ts=H(()=>{"use strict";es()});var rs=H(()=>{"use strict"});var ns=H(()=>{"use strict"});var os=H(()=>{"use strict";ns()});var as=H(()=>{"use strict";Vi();qi();ts();Tn();rs();os()});var Rl,Bl,is,ss=H(()=>{"use strict";as();ke();$e();Rl=(e,t,r)=>{let i=e===t,o=e<t&&r<0,s=e>t&&r>0;if(i||o||s)throw new Error("Range these inputs\' contents are invalid.")},Bl=(e,t,r,i)=>{let o=Math.abs(Math.ceil((t-e)/r)),s=[o],l=o,n=se("output",i,s),c=n.type.storage,m=g=>`\n        ${g.declareVariables(n)}\n        ${g.mainStart()}\n        ${g.guardAgainstOutOfBoundsWorkgroupSizes(l)}\n        output[global_idx] = ${c}(${e}) + ${c}(global_idx) * ${c}(${r});\n      }`;return{name:"Range",shaderCache:{hint:[e,t,r].map(g=>g.toString()).join("_")},getShaderSource:m,getRunData:()=>({outputs:[{dims:s,dataType:i}],dispatchGroup:{x:Math.ceil(l/64)}})}},is=e=>{let t=0,r=0,i=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],i=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],i=e.inputs[2].getFloat32Array()[0]),Ki.webgpu.validateInputContent&&Rl(t,r,i),e.compute(Bl(t,r,i,e.inputs[0].dataType),{inputs:[]})}});var Ml,kl,Dl,Wl,zl,Gl,Ul,Nl,Vl,Fl,Hl,Ll,jl,Kl,ql,us,ls,ds=H(()=>{"use strict";me();_e();$e();Ml=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},kl=(e,t,r)=>{t.every(o=>o>=0&&o<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let i=new Array(r).fill(1);return t.forEach((o,s)=>i[o]=e[s]),i},Dl=(e,t,r,i,o,s)=>{let[l,n,c]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],m=e[0].dims.length;if(l>0&&e.length>l&&e[l].dims.length>0)e[l].getFloat32Array().forEach(g=>s.push(g));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(n>0&&e.length>n&&e[n].dims.length>0){if(e[n].getFloat32Array().forEach(g=>i.push(g)),i.length!==0&&i.length!==m&&r>=18&&i.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");Ml(i,t),t.axes.length>0&&kl(i,t.axes,m).forEach((g,C)=>i[C]=g)}if(c>0&&e.length>c&&(e[c].getBigInt64Array().forEach(g=>o.push(Number(g))),o.length!==m||r>=18&&o.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(i.length!==t.axes.length)throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');if(o.length!==t.axes.length)throw new Error(\'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\')}if(typeof i<"u"&&typeof o<"u"&&i.length>0&&o.length>m)throw new Error("Resize requires only of scales or sizes to be specified")},Wl=e=>"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(e){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`\n`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",zl=(e,t)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",Gl=(e,t,r)=>{let i=new Array(r).fill(0).concat(new Array(r).fill(1)),o=e.length===0?i:e.slice();return t.length>0?(t.forEach((s,l)=>{i[s]=o[l],i[l+r]=o[t.length+l]}),i):o},Ul=(e,t,r,i)=>{let o=[];if(r.length>0)if(i.length>0){if(e.forEach(s=>o.push(s)),Math.max(...i)>e.length)throw new Error("axes is out of bound");i.forEach((s,l)=>o[s]=r[l])}else r.forEach(s=>o.push(s));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");o=e.map((s,l)=>Math.round(s*t[l]))}return o},Nl=(e,t,r,i)=>{let o=(()=>{switch(i.keepAspectRatioPolicy){case"not_larger":return i.axes.length>0?Math.min(...i.axes.map(l=>r[l]),Number.MAX_VALUE):Math.min(...r,Number.MAX_VALUE);case"not_smaller":return i.axes.length>0?Math.max(...i.axes.map(l=>r[l]),Number.MIN_VALUE):Math.max(...r,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${i.keepAspectRatioPolicy} is not supported`)}})();r.fill(1,0,r.length);let s=e.slice();return i.axes.length>0?(i.axes.forEach(l=>r[l]=o),i.axes.forEach(l=>s[l]=Math.round(e[l]*r[l]))):(r.fill(o,0,r.length),s.forEach((l,n)=>s[n]=Math.round(l*r[n]))),s},Vl=(e,t,r,i,o)=>`\n    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${e.type.indices}) -> array<f32, ${r.length}> {\n      const inputShape = array<u32, ${t.length}>(${t.map(s=>`${s}u`).join(",")});\n      const outputShape = array<u32, ${r.length}>(${r.map(s=>`${s}u`).join(",")});\n      const scales = array<f32, ${i.length}>(${i.map(s=>`${s}f`).join(",")});\n      const roi = array<f32, ${o.length}>(${o.map(s=>`${s}f`).join(",")});\n      var originalIndices: array<f32, ${r.length}>;\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var outputIndex = ${r.length===1?"outputIndices":"outputIndices[i]"};\n        if (scales[i] == 1.0) {\n          originalIndices[i] = f32(outputIndex);\n        } else {\n          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${t.length}]);\n        }\n      }\n      return originalIndices;\n    }`,Fl=(e,t,r,i,o,s,l)=>`\n    fn calculateInputIndicesFromOutputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\n        const inputShape = array<u32, ${r.length}>(${r.map(n=>`${n}u`).join(",")});\n        const outputShape = array<u32, ${i.length}>(${i.map(n=>`${n}u`).join(",")});\n        const scales = array<f32, ${o.length}>(${o.map(n=>`${n}f`).join(",")});\n        const roi = array<f32, ${s.length}>(${s.map(n=>`${n}f`).join(",")});\n        var inputIndices: ${e.type.indices};\n        for (var i:u32 = 0; i < ${i.length}; i++) {\n          var outputIndex = ${i.length===1?"outputIndices":"outputIndices[i]"};\n          var inputIndex: u32;\n          if (scales[i] == 1.0) {\n            inputIndex = outputIndex;\n          } else {\n            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${r.length}]);\n            if (!${l} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {\n              if (original_idx < 0) {\n                inputIndex = 0;\n              } else if (original_idx > (f32(inputShape[i]) - 1)) {\n                inputIndex = inputShape[i] - 1;\n              } else {\n                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));\n              }\n            } else {\n              inputIndex = u32(original_idx);\n            }\n          }\n          ${e.indicesSet("inputIndices","i","inputIndex")}\n        }\n        return inputIndices;\n    }`,Hl=(e,t)=>`\n    fn checkInputIndices(inputIndices: ${e.type.indices}) -> bool {\n      const inputShape = array<u32, ${t.length}>(${t.map(r=>`${r}u`).join(",")});\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var inputIndex = ${t.length===1?"inputIndices":"inputIndices[i]"};\n        if (inputIndex < 0 || inputIndex >= inputShape[i]) {\n          return false;\n        }\n      }\n      return true;\n    }`,Ll=(e,t,r,i,o,s,l)=>{let[n,c,m,g]=r.length===2?[-1,0,1,-1]:o[1]===1?[0,2,3,1]:[0,1,2,3];return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {\n      var inputIndices: ${e.type.indices};\n      inputIndices[${c}] = max(0, min(row, ${r[c]} - 1));\n      inputIndices[${m}] = max(0, min(col, ${r[m]} - 1));\n      if (${r.length} > 2) {\n        inputIndices[${g}] = channel;\n        inputIndices[${n}] = batch;\n      };\n      return input[${e.indicesToOffset("inputIndices")}];\n    }\n\n    fn bilinearInterpolation(outputIndices: ${t.type.indices}) -> f32 {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);\n      var row:f32 = originalIndices[${c}];\n      var col:f32 = originalIndices[${m}];\n      if (${s} && (row < 0 || row > (${r[c]} - 1) || col < 0 || col > ${r[m]} - 1)) {\n        return ${l};\n      }\n      row = max(0, min(row, ${r[c]} - 1));\n      col = max(0, min(col, ${r[m]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = 0;\n      var batch: u32 = 0;\n      if (${r.length>2}) {\n        channel = u32(originalIndices[${g}]);\n        batch = u32(originalIndices[${n}]);\n      }\n      var x11: f32 = getInputValue(batch, channel, row1, col1);\n      var x12: f32 = getInputValue(batch, channel, row1, col2);\n      var x21: f32 = getInputValue(batch, channel, row2, col1);\n      var x22: f32 = getInputValue(batch, channel, row2, col2);\n      var dx1: f32 = row - f32(row1);\n      var dx2: f32 = f32(row2 ) - row;\n      var dy1 = col - f32(col1);\n      var dy2 = f32(col2) - col;\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},jl=(e,t,r,i,o,s,l,n,c,m)=>{let[g,C]=r.length===2?[0,1]:o[1]===1?[2,3]:[1,2],x=$=>{let b=$===g?"row":"col";return`\n      fn ${b}CubicInterpolation(inputIndices: ${e.type.indices}, outputIndices: ${t.type.indices}) -> f32 {\n        var outputIndex = ${i.length===1?"outputIndices":`outputIndices[${$}]`};\n        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${o[$]},\n        f32(${i[$]}), f32(${r[$]}), ${s[$]}, ${s[$]} + ${r.length});\n        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${n} && (originalIdx < 0 || originalIdx > (${r[$]} - 1))) {\n          return ${c};\n        }\n        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${b}: f32 = originalIdx + f32(i);\n          if (${b} < 0 || ${b} >= ${r[$]}) {\n            if (${m}) {\n              coefs[i + 1] = 0.0;\n              continue;\n            } else if (${n}) {\n              return ${c};\n            } else {\n              ${b} = max(0, min(${b}, ${r[$]} - 1));\n            }\n          }\n          var inputIndicesCopy: ${e.type.indices} = inputIndices;\n          inputIndicesCopy[${$}] = u32(${b});\n          data[i + 1] = ${$===g?`input[${e.indicesToOffset("inputIndicesCopy")}];`:`\n                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);`}\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${x(g)};\n    ${x(C)};\n  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {\n    var absS = abs(s);\n    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: f32 = 1.0 - absS;\n    var twoMinusAbsS: f32 = 2.0 - absS;\n    var onePlusAbsS: f32 = 1.0 + absS;\n    coeffs[0] = ((${l} * onePlusAbsS - 5 * ${l}) * onePlusAbsS + 8 * ${l}) * onePlusAbsS - 4 * ${l};\n    coeffs[1] = ((${l} + 2) * absS - (${l} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${l} + 2) * oneMinusAbsS - (${l} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${l} * twoMinusAbsS - 5 * ${l}) * twoMinusAbsS + 8 * ${l}) * twoMinusAbsS - 4 * ${l};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {\n    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(outputIndices: ${t.type.indices}) -> f32 {\n    var inputIndices: ${e.type.indices} = outputIndices;\n    return colCubicInterpolation(inputIndices, outputIndices);\n  }\n    `},Kl=(e,t,r,i,o,s)=>{let l=e.dims,n=Gl(s,t.axes,l.length),c=Ul(l,i,o,t.axes),m=i.slice();i.length===0&&(m=l.map((v,I)=>v===0?1:c[I]/v),t.keepAspectRatioPolicy!=="stretch"&&(c=Nl(l,c,m,t)));let g=se("output",e.dataType,c),C=K("input",e.dataType,l),x=D.size(c),$=l.length===c.length&&l.every((v,I)=>v===c[I]),b=t.coordinateTransformMode==="tf_crop_and_resize",w=v=>`\n      ${Wl(t.coordinateTransformMode)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${Hl(C,l)};\n              ${zl(t.nearestMode,r)};\n              ${Fl(C,g,l,c,m,n,b)};\n              `;case"linear":return`\n              ${Vl(g,l,c,m,n)};\n              ${Ll(C,g,l,c,m,b,t.extrapolationValue)};\n              `;case"cubic":return`\n            ${jl(C,g,l,c,m,n,t.cubicCoeffA,b,t.extrapolationValue,t.excludeOutside)};\n            `;default:throw Error("Invalid resize mode")}})()};\n      ${v.declareVariables(C,g)}\n      ${v.mainStart()}\n        ${v.guardAgainstOutOfBoundsWorkgroupSizes(x)}\n        if (${$}) {\n          output[global_idx] = input[global_idx];\n        } else {\n          let outputIndices = ${g.offsetToIndices("global_idx")};\n          var inputIndices: ${C.type.indices};\n          ${(()=>{switch(t.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);\n                  if (checkInputIndices(inputIndices)) {\n                    output[global_idx] = input[${C.indicesToOffset("inputIndices")}];\n                  } else {\n                    output[global_idx] = ${t.extrapolationValue};\n                  }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n        }\n      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${m.length>0?m:""}|${o.length>0?o:""}`},getShaderSource:w,getRunData:()=>({outputs:[{dims:c,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(x/64)}})}},ql=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},us=(e,t)=>{let r=[],i=[],o=[],s=ql(e);Dl(e.inputs,t,s,r,i,o),e.compute(Kl(e.inputs[0],t,s,r,i,o),{inputs:[0]})},ls=e=>{let t=e.antialias,r=e.axes,i=e.coordinateTransformMode,o=e.cubicCoeffA,s=e.excludeOutside!==0,l=e.extrapolationValue,n=e.keepAspectRatioPolicy,c=e.mode,m=e.nearestMode===""?"simple":e.nearestMode;return ae({antialias:t,axes:r,coordinateTransformMode:i,cubicCoeffA:o,excludeOutside:s,extrapolationValue:l,keepAspectRatioPolicy:n,mode:c,nearestMode:m})}});var Yl,Xl,cs,ps,fs=H(()=>{"use strict";ke();me();_e();$e();Yl=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");if(e[0].dataType!==1||e[1].dataType!==1)throw new Error("inputs should be float type");let t=e[0],r=e[1],i=e[2];if(t.dataType!==r.dataType||t.dataType!==i.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let o=t.dims[t.dims.length-1],s=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==o)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==s)throw new Error("Skip must have the same sequence length as input");if(i.dims.length!==1)throw new Error("Gamma must be 1D");if(i.dims[i.dims.length-1]!==o)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let l=e[3];if(l.dims.length!==1)throw new Error("Beta must be 1D");if(l.dims[l.dims.length-1]!==o)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let l=e[4];if(l.dims.length!==1)throw new Error("Bias must be 1D");if(l.dims[l.dims.length-1]!==o)throw new Error("Bias must have the same hidden size as input")}},Xl=(e,t,r,i)=>{let o=e[0].dims,s=D.size(o),l=o,n=s,c=o.slice(-1)[0],m=i?o.slice(0,-1).concat(1):[],g=e.length>3,C=e.length>4,x=Pe(e[0].dataType),$=i&&r>1,b=i&&r>2,w=r>3,v=0,I=z=>`\n      const hiddenSize: u32 = ${c};\n      const epsilon: f32 = ${t.epsilon};\n\n      @group(0) @binding(${v++}) var<storage, read> x : array<${x}>;\n      @group(0) @binding(${v++}) var<storage, read> skip : array<${x}>;\n      @group(0) @binding(${v++}) var<storage, read> gamma : array<${x}>;\n      ${g?`@group(0) @binding(${v++}) var<storage, read> beta : array<${x}>;`:""}\n      ${C?`@group(0) @binding(${v++}) var<storage, read> bias : array<${x}>;`:""}\n      @group(0) @binding(${v++}) var<storage, read_write> output : array<${x}>;\n      ${$?`@group(0) @binding(${v++}) var<storage, read_write> meanOutput : array<${x}>;`:""}\n      ${b?`@group(0) @binding(${v++}) var<storage, read_write> invStdOutput : array<${x}>;`:""}\n      ${w?`@group(0) @binding(${v++}) var<storage, read_write> inputSkipBiasSum : array<${x}>;`:""}\n\n      ${z.mainStart()}\n        ${z.guardAgainstOutOfBoundsWorkgroupSizes(n/c)}\n        let offset = global_idx * hiddenSize;\n        var sum: f32 = 0.0;\n        var squareSum: f32 = 0.0;\n        for (var i: u32 = 0; i < hiddenSize; i++) {\n          let skipValue = skip[offset + i];\n          let biasValue = ${C?"bias[i]":"0.0"};\n          let inputValue = x[offset + i];\n          let value = inputValue + skipValue + biasValue;\n          ${w?"inputSkipBiasSum[offset + i] = value;":""}\n          output[offset + i] = value;\n          sum += value;\n          squareSum += value * value;\n        }\n        let mean: f32 = sum / f32(hiddenSize);\n        let variance: f32 = sqrt(squareSum / f32(hiddenSize) - mean * mean + epsilon);\n        ${$?"meanOutput[global_idx] = mean;":""}\n        ${b?"invStdOutput[global_idx] = 1.0 / variance;":""}\n        for (var i: u32 = 0; i < hiddenSize; i++) {\n          output[offset + i] = (output[offset + i] - mean) / variance * gamma[i] + ${g?"beta[i]":"0.0"};\n        }\n      }`,B=[{dims:l,dataType:e[0].dataType}];return r>1&&B.push({dims:m,dataType:e[0].dataType}),r>2&&B.push({dims:m,dataType:e[0].dataType}),r>3&&B.push({dims:o,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:t.cacheKey},getShaderSource:I,getRunData:()=>({outputs:B,dispatchGroup:{x:Math.ceil(n/c/64)}})}},cs=(e,t)=>{Yl(e.inputs);let i=[0];e.outputCount>1&&i.push(-3),e.outputCount>2&&i.push(-3),e.outputCount>3&&i.push(3),e.compute(Xl(e.inputs,t,e.outputCount,!1),{outputs:i})},ps=e=>{let t=e.epsilon;return ae({epsilon:t})}});var Ql,zr,Jl,ms,Zl,ed,hs,gs,ys=H(()=>{"use strict";ke();me();_e();$e();Ql=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((r,i)=>{if(e[i+1].dataType!==6&&e[i+1].dataType!==7)throw new Error(`Input ${i} must be an array of int32 or int64`)})},zr=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(i=>r.push(Number(i)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(i=>r.push(Number(i)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},Jl=(e,t)=>{if(e.length>1){let r=zr(e,1),i=zr(e,2),o=zr(e,3);return o.length===0&&(o=[...Array(e[0].dims.length).keys()]),ae({starts:r,ends:i,axes:o})}else return t},ms=(e,t,r,i,o)=>{let s=e;return e<0&&(s+=r[i[t]]),o[t]<0?Math.max(0,Math.min(s,r[i[t]]-1)):Math.max(0,Math.min(s,r[i[t]]))},Zl=(e,t,r,i)=>`fn calculateInputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\n          var inputIndices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${r.length}; i >= 0; i--) {\n            var outputIndex = ${i.length===1?"outputIndices":"outputIndices[i]"};\n            var inputIndex = outputIndex * steps[i] + starts[i] + carry;\n            carry = inputIndex / inputShape[i];\n            inputIndex = inputIndex % inputShape[i];\n            if (signs[i] < 0) {\n              inputIndex = inputShape[i] - inputIndex - 1u + starts[i];\n            }\n            ${r.length===1?"inputIndices":"inputIndices[i]"} = inputIndex;\n          }\n          return inputIndices;\n      }`,ed=(e,t)=>{let r=e[0].dims,i=D.size(r),o=t.axes.length>0?D.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],s=zr(e,4);s.forEach(w=>w!==0||(()=>{throw new Error("step cannot be 0")})),s.length===0&&(s=Array(o.length).fill(1));let l=t.starts.map((w,v)=>ms(w,v,r,o,s)),n=t.ends.map((w,v)=>ms(w,v,r,o,s));if(o.length!==r.length)for(let w=0;w<r.length;++w)o.includes(w)||(l.splice(w,0,0),n.splice(w,0,r[w]),s.splice(w,0,1));let c=s.map(w=>Math.sign(w));s.forEach((w,v,I)=>{if(w<0){let B=(n[v]-l[v])/w,z=l[v],M=z+B*s[v];l[v]=M,n[v]=z,I[v]=-w}});let m=r.slice(0);o.forEach((w,v)=>{m[w]=Math.ceil((n[w]-l[w])/s[w])});let g={dims:m,dataType:e[0].dataType},C=se("output",e[0].dataType,m),x=K("input",e[0].dataType,r),$=D.size(m),b=w=>`\n      ${w.declareVariables(x,C)}\n        const signs = array<i32, ${c.length}>(${c.map(v=>`${v}i`).join(",")});\n        const starts = array<u32, ${l.length}>(${l.map(v=>`${v}u`).join(",")});\n        const ends = array<u32, ${n.length}>(${n.map(v=>`${v}u`).join(",")});\n        const steps = array<u32, ${s.length}>(${s.map(v=>`${v}u`).join(",")});\n        const inputShape = array<u32, ${r.length}>(${r.map(v=>`${v}u`).join(",")});\n\n        ${Zl(x,C,r,m)}\n        ${w.mainStart()}\n          ${w.guardAgainstOutOfBoundsWorkgroupSizes($)}\n          let outputIndices = ${C.offsetToIndices("global_idx")};\n          let inputIndices = calculateInputIndices(outputIndices);\n          ${C.setByOffset("global_idx",x.getByIndices("inputIndices"))}\n      }`;return{name:"Slice",shaderCache:{hint:`${t.cacheKey}|${e[4]?.dims??""}`},getShaderSource:b,getRunData:()=>({outputs:[g],dispatchGroup:{x:Math.ceil(i/64)}})}},hs=(e,t)=>{Ql(e.inputs,t);let r=Jl(e.inputs,t);e.compute(ed(e.inputs,r),{inputs:[0]})},gs=e=>{let t=e.starts,r=e.ends,i=e.axes;return ae({starts:t,ends:r,axes:i})}});var td,rd,bs,ws,vs=H(()=>{"use strict";me();_e();$e();td=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},rd=(e,t)=>{let r=Pe(e.dataType),i=e.dims,o=D.size(i),s=64,l=t.axis;if(l<0&&(l=i.length+l),l<i.length-1)throw new Error("softmax only supports last axis for now.");let n=i[l],c=o/n,m=r==="f32"?"var threadMax: f32 = -3.402823e+38f;":"var threadMax: f16 = -65504.0h;";return{name:"Softmax",getRunData:()=>({outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:c}}),getShaderSource:C=>`\n      var<workgroup> rowMaxShared : ${r};\n      var<workgroup> rowSumShared : ${r};\n      var<workgroup> threadShared : array<${r}, ${s}>;\n\n      @group(0) @binding(0) var<storage, read> x : array<${r}>;\n      @group(0) @binding(1) var<storage, read_write> result : array<${r}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${r} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${r}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n\n      @compute @workgroup_size(${s}, 1, 1)\n      fn main(@builtin(local_invocation_id) local_id : vec3<u32>, @builtin(global_invocation_id) global_id : vec3u) {\n        let gindex = i32(global_id.x);\n        let lindex = i32(local_id.x);\n        const wg = ${s};\n        let row = gindex / wg;\n        let cols = ${n};\n        let row_stride : i32 = ${n};\n\n        // find the rows max\n        ${m}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = threadShared[0];\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum: ${r} = 0.0;\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = threadShared[0];\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`}},bs=(e,t)=>{td(e.inputs),e.compute(rd(e.inputs[0],t))},ws=e=>ae({axis:e.axis})});var nd,od,ad,id,sd,$s,xs,Cs=H(()=>{"use strict";me();_e();$e();nd=e=>{if(!e||e.length<1)throw new Error("too few inputs")},od=(e,t)=>{let r=[],i=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(o=>r.push(Number(o))),i=r.length),ae({numOutputs:i,axis:t.axis,splitSizes:r})},ad=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < sizeInConcatAxis[i]) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,id=e=>{let t=e.length,r=[];for(let i=0;i<t;++i){let o=e[i].setByIndices("indices","input[global_idx]");t===1?r.push(o):i===0?r.push(`if (outputNumber == ${i}u) { ${o} }`):i===t-1?r.push(`else { ${o} }`):r.push(`else if (outputNumber == ${i}) { ${o} }`)}return`\n      fn writeBufferData(outputNumber: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${r.join(`\n`)}\n      }`},sd=(e,t)=>{let r=e[0].dims,i=D.size(r),o=e[0].dataType,s=r.length,l=t.axis,n=l<0?r.length+l:l,c=new Array(t.numOutputs),m=K("input",o,r),g=new Array(t.numOutputs),C=[],x=[],$=0;for(let v=0;v<t.numOutputs;v++){$+=t.splitSizes[v],g[v]=$;let I=r.slice();I[t.axis]=t.splitSizes[v],x.push(I),c[v]=se(`output${v}`,o,x[v]),C.push({dims:x[v],dataType:e[0].dataType})}let b=s<2?"indices":`indices[${n}]`,w=v=>`\n  ${v.declareVariables(m,...c)}\n  const sizeInConcatAxis = array<u32, ${g.length}>(${g.map(I=>`${I}u`).join(",")});\n  ${ad(g.length)}\n  ${id(c)}\n\n  ${v.mainStart()}\n    ${v.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n\n    var indices = ${m.offsetToIndices("global_idx")};\n    let outputNumber = calculateOutputIndex(${b});\n    if (outputNumber != 0) {\n        ${b} -= sizeInConcatAxis[outputNumber - 1u];\n    }\n    writeBufferData(outputNumber, indices, global_idx);\n  }`;return{name:"Split",shaderCache:{hint:t.cacheKey},getShaderSource:w,getRunData:()=>({outputs:C,dispatchGroup:{x:Math.ceil(i/64)}})}},$s=(e,t)=>{nd(e.inputs);let r=e.inputs.length===1?t:od(e.inputs,t);e.compute(sd(e.inputs,r),{inputs:[0]})},xs=e=>{let t=e.axis,r=e.splitSizes,i=e.numOutputs<0?r.length:e.numOutputs;if(i!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return ae({axis:t,numOutputs:i,splitSizes:r})}});var Ss,ud,ld,dd,As,Is=H(()=>{"use strict";ke();me();$e();Ss=e=>Array.from(e.getBigInt64Array(),Number),ud=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(Ss(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},ld=(e,t)=>{let r=[];for(let i=0;i<e.length;++i)r.push(e[i]*t[i]);return r},dd=e=>{let t=e[0].dims,r=Ss(e[1]),i=ld(t,r),o=D.size(i),s=e[0].dataType,l=K("input",s,t),n=se("output",s,i),c=m=>`\n      const inputShape = ${l.indices(...t)};\n      ${m.declareVariables(l,n)}\n      ${m.mainStart()}\n      ${m.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n      let outputIndices = ${n.offsetToIndices("global_idx")};\n      var inputIndices: ${l.type.indices};\n      for (var i = 0; i < ${t.length}; i++) {\n        let inputDimValue = ${n.indicesGet("outputIndices","i")}  % ${l.indicesGet("inputShape","i")};\n\n        ${l.indicesSet("inputIndices","i","inputDimValue")}\n      }\n      ${n.setByOffset("global_idx",l.getByIndices("inputIndices"))}\n    }`;return{name:"Tile",shaderCache:{hint:`${r}`},getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:c}},As=e=>{ud(e.inputs),e.compute(dd(e.inputs),{inputs:[0]})}});var cd,pd,Ts,Es=H(()=>{"use strict";ke();me();$e();cd=(e,t,r,i,o)=>{let s=D.size(r),l=Math.ceil(s/4),n=se("outputData",o,r,4),c=K("aData",t[1].dataType,t[1].dims,4),m=K("bData",t[2].dataType,t[2].dims,4),g=K("cData",t[0].dataType,t[0].dims,4),C,x=($,b,w)=>`select(${b}, ${$}, ${w})`;if(!i)C=n.setByOffset("global_idx",x(c.getByOffset("global_idx"),m.getByOffset("global_idx"),g.getByOffset("global_idx")));else{let $=(b,w,v="")=>{let I=`aData[indexA${w}][componentA${w}]`,B=`bData[indexB${w}][componentB${w}]`,z=`bool(cData[indexC${w}] & ${4278190080>>>(3-w)*8}u)`;return`\n            let outputIndices${w} = ${n.offsetToIndices(`global_idx * 4u + ${w}u`)};\n            let offsetA${w} = ${c.broadcastedIndicesToOffset(`outputIndices${w}`,n)};\n            let offsetB${w} = ${m.broadcastedIndicesToOffset(`outputIndices${w}`,n)};\n            let offsetC${w} = ${g.broadcastedIndicesToOffset(`outputIndices${w}`,n)};\n            let indexA${w} = offsetA${w} / 4u;\n            let indexB${w} = offsetB${w} / 4u;\n            let indexC${w} = offsetC${w} / 4u;\n            let componentA${w} = offsetA${w} % 4u;\n            let componentB${w} = offsetB${w} % 4u;\n            ${b}[${w}] = ${v}(${x(I,B,z)});\n          `};o===9?C=`\n            var data = vec4<u32>(0);\n            ${$("data",0,"u32")}\n            ${$("data",1,"u32")}\n            ${$("data",2,"u32")}\n            ${$("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:C=`\n            ${$("outputData[global_idx]",0)}\n            ${$("outputData[global_idx]",1)}\n            ${$("outputData[global_idx]",2)}\n            ${$("outputData[global_idx]",3)}\n          `}return`\n        ${e.declareVariables(g,c,m,n)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(l)}\n        ${C}\n      }`},pd=e=>{let t=e[1].dims,r=e[2].dims,i=e[0].dims,o=e[1].dataType,s=!(D.areEqual(t,r)&&D.areEqual(r,i)),l=t,n=D.size(t);if(s){let c=Ze.calcShape(Ze.calcShape(t,r,!1),i,!1);if(!c)throw new Error("Can\'t perform where op on the given tensors");l=c,n=D.size(l)}return{name:"Where",getShaderSource:c=>cd(c,e,l,s,o),getRunData:()=>({outputs:[{dims:l,dataType:o}],dispatchGroup:{x:Math.ceil(n/64/4)}})}},Ts=e=>{e.compute(pd(e.inputs))}});var Os,_s=H(()=>{"use strict";Go();No();va();Pa();Ma();vn();Ja();ri();ai();ui();ci();mi();bi();$i();Ci();Ii();Ni();ss();fn();ds();fs();ys();vs();Cs();Is();Mr();gn();Es();Os=new Map([["Abs",[Vo]],["Acos",[Fo]],["Acosh",[Ho]],["Add",[$a]],["ArgMax",[zo,mn]],["ArgMin",[Wo,mn]],["Asin",[Lo]],["Asinh",[jo]],["Atan",[Ko]],["Atanh",[qo]],["AveragePool",[Ri,Pi]],["BiasAdd",[Uo]],["BiasSplitGelu",[wa]],["Cast",[Xo,Yo]],["Ceil",[Jo]],["ClipV10",[hn]],["Clip",[Qo]],["Concat",[Ra,Ba]],["Conv",[La,Ha]],["ConvTranspose",[Qa,Xa]],["Cos",[Zo]],["Cosh",[ea]],["Div",[xa]],["Einsum",[ei,ti]],["Elu",[ta,Ar]],["Equal",[Ca]],["Erf",[ra]],["Exp",[na]],["Expand",[oi]],["Floor",[oa]],["Gather",[si,ii]],["GatherElements",[di,li]],["Gelu",[aa]],["Gemm",[pi,fi]],["GlobalAveragePool",[ki,Mi]],["GlobalMaxPool",[Ui,Gi]],["Greater",[Ta]],["GreaterOrEqual",[Oa]],["InstanceNormalization",[yi,gi]],["LayerNormalization",[vi,wi]],["LeakyRelu",[ia,Ar]],["Less",[Ea]],["LessOrEqual",[_a]],["Log",[ba]],["MatMul",[xi]],["MaxPool",[Wi,zi]],["Mul",[Sa]],["Neg",[ua]],["Not",[sa]],["Pad",[Si,Ai]],["Pow",[Aa]],["Range",[is]],["Reciprocal",[la]],["ReduceMin",[Po,je]],["ReduceMean",[_o,je]],["ReduceMax",[Oo,je]],["ReduceSum",[Bo,je]],["ReduceProd",[Ro,je]],["ReduceL1",[Io,je]],["ReduceL2",[To,je]],["ReduceLogSum",[Ao,je]],["ReduceLogSumExp",[Eo,je]],["ReduceSumSquare",[Mo,je]],["Relu",[da]],["Resize",[us,ls]],["Sigmoid",[ca]],["Sin",[pa]],["Sinh",[fa]],["Slice",[hs,gs]],["SkipLayerNormalization",[cs,ps]],["Split",[$s,xs]],["Sqrt",[ma]],["Softmax",[bs,ws]],["Sub",[Ia]],["Tan",[ha]],["Tanh",[ga]],["ThresholdedRelu",[ya,Ar]],["Tile",[As]],["Transpose",[Ua,Na]],["Where",[Ts]]])});var Gr,Ps=H(()=>{"use strict";ke();lt();$e();Gr=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,i,o,s,l,n){let c=this.backend.device,m=this.backend.getComputePassEncoder(),g=this.backend.supportTimestampQuery&&this.backend.env.webgpu.profilingMode==="default";g&&m.writeTimestamp(this.backend.profilingQuerySet,0),m.setPipeline(t.computePipeline);let C=[];for(let $ of o)C.push({binding:C.length,resource:{buffer:$.buffer}});for(let $ of s)C.push({binding:C.length,resource:{buffer:$.buffer}});n&&C.push({binding:C.length,resource:n});let x=c.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:C,label:t.programInfo.name});if(m.setBindGroup(0,x),m.dispatchWorkgroups(...l),this.backend.pendingDispatchNumber++,g){m.writeTimestamp(this.backend.profilingQuerySet,1),this.backend.profilingQueryData==null&&(this.backend.profilingQueryData=this.backend.gpuDataManager.create(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let $=this.backend.gpuDataManager.create(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.profilingQuerySet,0,2,this.backend.profilingQueryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.profilingQueryData.buffer,0,$.buffer,0,16),this.backend.flush();let b=this.backend.currentKernelId,w=this.backend.kernels.get(b),v=`[${w[0]}] ${w[1]}`;$.buffer.mapAsync(GPUMapMode.READ).then(()=>{let I=new BigUint64Array($.buffer.getMappedRange()),B=I[0],z=I[1];$.buffer.unmap(),typeof this.backend.profilingTimeBase>"u"&&(this.backend.profilingTimeBase=B);let M=Number(B-this.backend.profilingTimeBase),G=Number(z-this.backend.profilingTimeBase);if(!Number.isSafeInteger(M)||!Number.isSafeInteger(G))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release($.id);let _="";r.forEach((V,j)=>{_+=`input[${j}]: [${V.dims}] | ${Yt(V.dataType)}, `});let U="";i.forEach((V,j)=>{U+=`output[${j}]: [${V.dims}] | ${Yt(V.dataType)}, `}),console.log(`[profiling] kernel "${b}|${v}" ${_}${U}execution time: ${G-M} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(t,r){let i=this.backend.device,o=[];i.features.has("shader-f16")&&o.push("enable f16;");let s=So(r),l=t.getShaderSource(s),n=`${o.join(`\n`)}\n${s.additionalImplementations}\n${l}`,c=i.createShaderModule({code:n,label:t.name});Ie("verbose",()=>`[WebGPU] shader code: ${n}`);let m=i.createComputePipeline({compute:{module:c,entryPoint:"main"},layout:"auto",label:t.name});return{programInfo:t,computePipeline:m}}normalizeDispatchGroupSize(t){let r=typeof t=="number"?t:t.x,i=typeof t=="number"?1:t.y||1,o=typeof t=="number"?1:t.z||1,s=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=s&&i<=s&&o<=s)return[r,i,o];let l=r*i*o,n=Math.ceil(Math.sqrt(l));if(n>s){if(n=Math.ceil(Math.cbrt(l)),n>s)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[n,n,n]}else return[n,n,1]}}});var fd,md,Ur,Rs=H(()=>{"use strict";lt();yo();$o();_s();Ps();fd=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let i=0;i<e.length;++i){let o=e[i].dataType;switch(t[i]){case"none":{r.push("");break}case"type":{r.push(`${o}`);break}case"rank":{let s=e[i].dims.length;r.push(`${o};${s}`);break}case"dims":{let s=e[i].dims.join(",");r.push(`${o};${s}`);break}default:throw new Error(`unsupported input dependency: ${t[i]}`)}}return r.join("|")},md=(e,t)=>{let r=e.name;return e.shaderCache?.hint&&(r+="["+e.shaderCache.hint+"]"),r+=`:${fd(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,r},Ur=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispatchNumber=0;this.supportTimestampQuery=!1;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let r=await navigator.gpu.requestAdapter();if(!r)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=t;let i=[],o={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:i};r.features.has("timestamp-query-inside-passes")&&(this.supportTimestampQuery=!0,i.push("timestamp-query-inside-passes")),r.features.has("shader-f16")&&i.push("shader-f16"),this.device=await r.requestDevice(o),this.gpuDataManager=vo(this),this.programManager=new Gr(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,ho(t.logLevel,!!t.debug),this.device.onuncapturederror=s=>{s.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${s.error.message}`)},this.supportTimestampQuery&&(this.profilingQuerySet=this.device.createQuerySet({type:"timestamp",count:2})),Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){return this.computePassEncoder||(this.computePassEncoder=this.getCommandEncoder().beginComputePass()),this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}run(t,r,i,o,s){let l=[];for(let I=0;I<r.length;++I){let B=this.gpuDataManager.get(r[I].data);if(!B)throw new Error(`no GPU data for input: ${r[I].data}`);l[I]=B}let n=md(t,r),c=this.programManager.getArtifact(n),{outputs:m,dispatchGroup:g,programUniforms:C}=t.getRunData(r),x=i.length===0?m.map((I,B)=>B):i;if(x.length!==m.length)throw new Error(`Output size ${x.length} must be equal to ${m.length}.`);let $=[],b=[];for(let I=0;I<m.length;++I){if(!Number.isInteger(x[I])||x[I]<-3||x[I]>=m.length)throw new Error(`Invalid output index: ${x[I]}`);if(x[I]===-3)continue;let B=x[I]===-1,z=x[I]===-2,M=B||z?s(m[I].dataType,m[I].dims):o(x[I],m[I].dataType,m[I].dims),G=this.gpuDataManager.get(M.data);if(!G)throw new Error(`no GPU data for output: ${M.data}`);if(B&&this.temporaryData.push(G),z){let _=this.kernelPersistentData.get(this.currentKernelId);_||(_=[],this.kernelPersistentData.set(this.currentKernelId,_)),_.push(G)}$.push(M),b.push(G)}let w;if(C){let I=0,B=0,z=[],M=1;C.forEach(U=>{let V=typeof U.data=="number"?[U.data]:U.data,j;switch(V.length){case 1:j=4;break;case 2:j=8;break;case 3:j=16;break;case 4:j=16;break;case 5:j=16;break;case 6:j=16;break;default:throw new Error(`unsupported data length: ${V.length}`)}(B===5||B===6)&&(j=16),j>M&&(M=j),I=Math.ceil(I/j)*j,B=V.length,z.push(I),I+=V.length*4}),I=Math.ceil(I/M)*M;let G=new ArrayBuffer(I);C.forEach((U,V)=>{let j=z[V],le=typeof U.data=="number"?[U.data]:U.data;U.type==="int32"?new Int32Array(G,j,le.length).set(le):U.type==="uint32"?new Uint32Array(G,j,le.length).set(le):new Float32Array(G,j,le.length).set(le)});let _=this.gpuDataManager.create(I,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(_.buffer,0,G,0,I),this.gpuDataManager.release(_.id),w={offset:0,size:I,buffer:_.buffer}}let v=this.programManager.normalizeDispatchGroupSize(g);return c||(c=this.programManager.build(t,v),this.programManager.setArtifact(n,c)),Ie("info",()=>`[ProgramManager] run "${t.name}" (key=${n}) with ${v[0]}x${v[1]}x${v[2]}`),this.programManager.run(c,r,$,l,b,v,w),$}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,i,o){let s=Os.get(t);if(!s)throw new Error(`kernel not implemented: ${t}`);this.kernels.set(r,[t,o,s[0],[s[1],i]])}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let i of r)this.gpuDataManager.release(i.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,i){let o=this.kernels.get(t);if(!o)throw new Error(`kernel not created: ${t}`);let[s,l,n,c]=o;if(this.currentKernelId!==null)throw new Error(`kernel "[${s}] ${l}" is not allowed to be called recursively`);this.currentKernelId=t,c[0]&&(c[1]=c[0](c[1]),c[0]=void 0),Ie("info",()=>`[WebGPU] Start to run kernel "[${s}] ${l}"...`);let m=this.env.debug;this.temporaryData=[];try{return m&&this.device.pushErrorScope("validation"),n(r,c[1]),0}catch(g){return i.push(Promise.resolve(`[WebGPU] Kernel "[${s}] ${l}" failed. ${g}`)),1}finally{m&&i.push(this.device.popErrorScope().then(g=>g?`GPU validation error for kernel "[${s}] ${l}": ${g.message}`:null));for(let g of this.temporaryData)this.gpuDataManager.release(g.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,i,o){let s=this.sessionExternalDataMapping.get(t);s||(s=new Map,this.sessionExternalDataMapping.set(t,s));let l=s.get(r),n=this.gpuDataManager.registerExternalBuffer(i,o,l?.[1]);return s.set(r,[n,i]),n}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(i=>this.gpuDataManager.unregisterExternalBuffer(i[1])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,i){return async()=>{let o=await sn(this,t,r);return go(o.buffer,i)}}}});var Bs={};yr(Bs,{init:()=>hd});var rr,En,hd,Ms=H(()=>{"use strict";ke();Rs();lt();me();rr=class e{constructor(t,r,i,o){this.module=t;this.dataType=r;this.data=i;this.dims=o}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=D.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=D.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=D.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(D.size(t)!==D.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},En=class{constructor(t,r,i){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;let o=t.HEAPU32,s=i>>2;this.opKernelContext=o[s++];let l=o[s++];this.outputCount=o[s++],this.customDataOffset=o[s++],this.customDataSize=o[s++];let n=[];for(let c=0;c<l;c++){let m=o[s++],g=o[s++],C=o[s++],x=[];for(let $=0;$<C;$++)x.push(o[s++]);n.push(new rr(t,m,g,x))}this.inputs=n}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,r){let i=r?.inputs?.map(n=>typeof n=="number"?this.inputs[n]:n)??this.inputs,o=r?.outputs??[],s=(n,c,m)=>new rr(this.module,c,this.output(n,m),m),l=(n,c)=>{let m=Xt(n);if(!m)throw new Error(`Unsupported data type: ${n}`);let g=m*D.size(c);return new rr(this.module,n,this.backend.gpuDataManager.create(g).id,c)};return this.backend.run(t,i,o,s,l)}output(t,r){let i=this.module.stackSave();try{let o=this.module.stackAlloc((1+r.length)*4),s=o>>2;this.module.HEAPU32[s++]=r.length;for(let l=0;l<r.length;l++)this.module.HEAPU32[s++]=r[l];return this.module._JsepOutput(this.opKernelContext,t,o)}catch(o){throw new Error(`Failed to generate kernel\'s output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${o}`)}finally{this.module.stackRestore(i)}}},hd=async(e,t)=>{let r=e.jsepInit;if(r&&navigator.gpu){if(!t.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let i=new Ur;await i.initialize(t),r(i,o=>i.alloc(o),o=>i.free(o),(o,s,l,n=!1)=>{if(n)Ie("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${o}, dst=${s}, size=${l}`),i.memcpy(o,s);else{Ie("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${o}, gpuDataId=${s}, size=${l}`);let c=e.HEAPU8.subarray(o,o+l);i.upload(s,c)}},async(o,s,l)=>{Ie("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${o}, dataOffset=${s}, size=${l}`),await i.download(o,()=>e.HEAPU8.subarray(s,s+l))},(o,s,l)=>i.createKernel(o,s,l,t.debug||t.webgpu.profilingMode==="default"?e.UTF8ToString(e._JsepGetNodeName(s)):`${s}`),o=>i.releaseKernel(o),(o,s,l,n)=>{Ie("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${l}, kernel=${o}, contextDataOffset=${s}`);let c=new En(e,i,s);return i.computeKernel(o,c,n)})}}});var so;so=Qn();var lu=oo(),tn,rn=!1,br=!1,io=!1,du=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},cu=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},pu=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",uo=async e=>{if(rn)return Promise.resolve();if(br)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(io)throw new Error("previous call to \'initializeWebAssembly()\' failed.");br=!0;let t=e.initTimeout,r=e.numThreads,i=e.simd,o=r>1&&du(),s=i&&cu(),l=e.wasmPaths,n=typeof l=="string"?l:void 0,c=pu(s,o),m=typeof l=="object"?l[c]:void 0,g=!1,C=[];if(t>0&&C.push(new Promise(x=>{setTimeout(()=>{g=!0,x()},t)})),C.push(new Promise((x,$)=>{let b=o?lu:so,w={locateFile:(v,I)=>{if(o&&v.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([ao()],{type:"text/javascript"}));if(v.endsWith(".wasm")){if(m)return m;let B=n??I;return c==="ort-wasm-simd.wasm"?B+"ort-wasm-simd.jsep.wasm":c==="ort-wasm-simd-threaded.wasm"?B+"ort-wasm-simd-threaded.jsep.wasm":B+c}return I+v}};if(o)if(typeof Blob>"u")w.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let v=`var ortWasmThreaded=${b.toString()};`;w.mainScriptUrlOrBlob=new Blob([v],{type:"text/javascript"})}b(w).then(v=>{br=!1,rn=!0,tn=v,x()},v=>{br=!1,io=!0,$(v)})})),await Promise.race(C),g)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Ee=()=>{if(rn&&tn)return tn;throw new Error("WebAssembly is not initialized yet.")};var Oe=(e,t)=>{let r=Ee(),i=r.lengthBytesUTF8(e)+1,o=r._malloc(i);return r.stringToUTF8(e,o,i),t.push(o),o},qt=(e,t,r,i)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([o,s])=>{let l=t?t+o:o;if(typeof s=="object")qt(s,l+".",r,i);else if(typeof s=="string"||typeof s=="number")i(l,s.toString());else if(typeof s=="boolean")i(l,s?"1":"0");else throw new Error(`Can\'t handle extra config type: ${typeof s}`)})},Ce=e=>{let t=Ee(),r=t.stackSave();try{let i=t.stackAlloc(8);t._OrtGetLastError(i,i+4);let o=t.HEAP32[i/4],s=t.HEAPU32[i/4+1],l=s?t.UTF8ToString(s):"";throw new Error(`${e} ERROR_CODE: ${o}, ERROR_MESSAGE: ${l}`)}finally{t.stackRestore(r)}};var lo=e=>{let t=Ee(),r=0,i=[],o=e||{};try{if(e?.logSeverityLevel===void 0)o.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)o.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(o.terminate=!1);let s=0;return e?.tag!==void 0&&(s=Oe(e.tag,i)),r=t._OrtCreateRunOptions(o.logSeverityLevel,o.logVerbosityLevel,!!o.terminate,s),r===0&&Ce("Can\'t create run options."),e?.extra!==void 0&&qt(e.extra,"",new WeakSet,(l,n)=>{let c=Oe(l,i),m=Oe(n,i);t._OrtAddRunConfigEntry(r,c,m)!==0&&Ce(`Can\'t set a run config entry: ${l} - ${n}.`)}),[r,i]}catch(s){throw r!==0&&t._OrtReleaseRunOptions(r),i.forEach(l=>t._free(l)),s}};var fu=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},mu=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},hu=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},gu=(e,t,r)=>{for(let i of t){let o=typeof i=="string"?i:i.name;switch(o){case"xnnpack":o="XNNPACK";break;case"webnn":if(o="WEBNN",typeof i!="string"){let l=i;if(l?.deviceType){let n=Oe("deviceType",r),c=Oe(l.deviceType,r);Ee()._OrtAddSessionConfigEntry(e,n,c)!==0&&Ce(`Can\'t set a session config entry: \'deviceType\' - ${l.deviceType}.`)}if(l?.numThreads){let n=l.numThreads;(typeof n!="number"||!Number.isInteger(n)||n<0)&&(n=0);let c=Oe("numThreads",r),m=Oe(n.toString(),r);Ee()._OrtAddSessionConfigEntry(e,c,m)!==0&&Ce(`Can\'t set a session config entry: \'numThreads\' - ${l.numThreads}.`)}if(l?.powerPreference){let n=Oe("powerPreference",r),c=Oe(l.powerPreference,r);Ee()._OrtAddSessionConfigEntry(e,n,c)!==0&&Ce(`Can\'t set a session config entry: \'powerPreference\' - ${l.powerPreference}.`)}}break;case"webgpu":if(o="JS",typeof i!="string"){let l=i;if(l?.preferredLayout){if(l.preferredLayout!=="NCHW"&&l.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${l.preferredLayout}`);let n=Oe("preferredLayout",r),c=Oe(l.preferredLayout,r);Ee()._OrtAddSessionConfigEntry(e,n,c)!==0&&Ce(`Can\'t set a session config entry: \'preferredLayout\' - ${l.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${o}`)}let s=Oe(o,r);Ee()._OrtAppendExecutionProvider(e,s)!==0&&Ce(`Can\'t append execution provider: ${o}.`)}},co=e=>{let t=Ee(),r=0,i=[],o=e||{};hu(o);try{let s=fu(o.graphOptimizationLevel??"all"),l=mu(o.executionMode??"sequential"),n=typeof o.logId=="string"?Oe(o.logId,i):0,c=o.logSeverityLevel??2;if(!Number.isInteger(c)||c<0||c>4)throw new Error(`log serverity level is not valid: ${c}`);let m=o.logVerbosityLevel??0;if(!Number.isInteger(m)||m<0||m>4)throw new Error(`log verbosity level is not valid: ${m}`);let g=typeof o.optimizedModelFilePath=="string"?Oe(o.optimizedModelFilePath,i):0;if(r=t._OrtCreateSessionOptions(s,!!o.enableCpuMemArena,!!o.enableMemPattern,l,!!o.enableProfiling,0,n,c,m,g),r===0&&Ce("Can\'t create session options."),o.executionProviders&&gu(r,o.executionProviders,i),o.freeDimensionOverrides)for(let[C,x]of Object.entries(o.freeDimensionOverrides)){if(typeof C!="string")throw new Error(`free dimension override name must be a string: ${C}`);if(typeof x!="number"||!Number.isInteger(x)||x<0)throw new Error(`free dimension override value must be a non-negative integer: ${x}`);let $=Oe(C,i);t._OrtAddFreeDimensionOverride(r,$,x)!==0&&Ce(`Can\'t set a free dimension override: ${C} - ${x}.`)}return o.extra!==void 0&&qt(o.extra,"",new WeakSet,(C,x)=>{let $=Oe(C,i),b=Oe(x,i);t._OrtAddSessionConfigEntry(r,$,b)!==0&&Ce(`Can\'t set a session config entry: ${C} - ${x}.`)}),[r,i]}catch(s){throw r!==0&&t._OrtReleaseSessionOptions(r),i.forEach(l=>t._free(l)),s}};ke();var gd=e=>{let t=Ee(),r=t.stackSave();try{let i=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,i,i+4)!==0&&Ce("Can\'t get session input/output count."),[t.HEAP32[i/4],t.HEAP32[i/4+1]]}finally{t.stackRestore(r)}},yd=(e,t)=>{Ee()._OrtInit(e,t)!==0&&Ce("Can\'t initialize onnxruntime.")},Ds=async e=>{yd(e.wasm.numThreads,Qt(e.logLevel));{let t=(Ms(),Tt(Bs)).init;await t(Ee(),e)}},nr=new Map,On=e=>{let t=Ee(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},_n=(e,t)=>{let r=Ee(),i=0,o=0,s=0,l=[],n=[],c=[];try{[o,l]=co(t),i=r._OrtCreateSession(e[0],e[1],o),i===0&&Ce("Can\'t create a session.");let[m,g]=gd(i),C=[],x=[],$=[];for(let w=0;w<m;w++){let v=r._OrtGetInputName(i,w);v===0&&Ce("Can\'t get an input name."),n.push(v),C.push(r.UTF8ToString(v))}for(let w=0;w<g;w++){let v=r._OrtGetOutputName(i,w);v===0&&Ce("Can\'t get an output name."),c.push(v);let I=r.UTF8ToString(v);x.push(I);{let B=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[I]??"cpu";if(B!=="cpu"&&B!=="cpu-pinned"&&B!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${B}.`);$.push(B)}}let b=null;return $.some(w=>w==="gpu-buffer")&&(s=r._OrtCreateBinding(i),s===0&&Ce("Can\'t create IO binding."),b={handle:s,outputPreferredLocations:$,outputPreferredLocationsEncoded:$.map(w=>on(w))}),nr.set(i,[i,n,c,b]),[i,C,x]}catch(m){throw n.forEach(g=>r._OrtFree(g)),c.forEach(g=>r._OrtFree(g)),s!==0&&r._OrtReleaseBinding(s),i!==0&&r._OrtReleaseSession(i),m}finally{r._free(e[0]),o!==0&&r._OrtReleaseSessionOptions(o),l.forEach(m=>r._free(m))}},Ws=(e,t)=>{let r=On(e);return _n(r,t)},zs=e=>{let t=Ee(),r=nr.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[i,o,s,l]=r;l&&t._OrtReleaseBinding(l.handle),t.jsepUnregisterBuffers?.(e),o.forEach(n=>t._OrtFree(n)),s.forEach(n=>t._OrtFree(n)),t._OrtReleaseSession(i),nr.delete(e)},ks=(e,t,r,i,o)=>{if(!e){t.push(0);return}let s=Ee(),l=e[0],n=e[1],c=e[3],m,g;if(l==="string"&&c==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(c==="gpu-buffer"){let $=e[2].gpuBuffer,b=Xt(nn(l));g=n.reduce((w,v)=>w*v,1)*b,m=s.jsepRegisterBuffer(i,o,$,g)}else{let $=e[2];if(Array.isArray($)){g=4*$.length,m=s._malloc(g),r.push(m);let b=m/4;for(let w=0;w<$.length;w++){if(typeof $[w]!="string")throw new TypeError(`tensor data at index ${w} is not a string`);s.HEAPU32[b++]=Oe($[w],r)}}else g=$.byteLength,m=s._malloc(g),r.push(m),s.HEAPU8.set(new Uint8Array($.buffer,$.byteOffset,g),m)}let C=s.stackSave(),x=s.stackAlloc(4*n.length);try{let $=x/4;n.forEach(w=>s.HEAP32[$++]=w);let b=s._OrtCreateTensor(nn(l),m,g,x,n.length,on(c));b===0&&Ce(`Can\'t create tensor for input/output. session=${i}, index=${o}.`),t.push(b)}finally{s.stackRestore(C)}},Gs=async(e,t,r,i,o,s)=>{let l=Ee(),n=nr.get(e);if(!n)throw new Error(`cannot run inference. invalid session id: ${e}`);let[c,m,g,C]=n,x=t.length,$=i.length,b=0,w=[],v=[],I=[],B=[],z=l.stackSave(),M=l.stackAlloc(x*4),G=l.stackAlloc(x*4),_=l.stackAlloc($*4),U=l.stackAlloc($*4);try{[b,w]=lo(s);for(let q=0;q<x;q++)ks(r[q],v,B,e,t[q]);for(let q=0;q<$;q++)ks(o[q],I,B,e,x+i[q]);let V=M/4,j=G/4,le=_/4,R=U/4;for(let q=0;q<x;q++)l.HEAPU32[V++]=v[q],l.HEAPU32[j++]=m[t[q]];for(let q=0;q<$;q++)l.HEAPU32[le++]=I[q],l.HEAPU32[R++]=g[i[q]];if(C){let{handle:q,outputPreferredLocations:L,outputPreferredLocationsEncoded:De}=C;if(m.length!==x)throw new Error(`input count from feeds (${x}) is expected to be always equal to model\'s input count (${m.length}).`);for(let he=0;he<x;he++){let Re=t[he];await l._OrtBindInput(q,m[Re],v[he])!==0&&Ce(`Can\'t bind input[${he}] for session=${e}.`)}for(let he=0;he<$;he++){let Re=i[he];o[he]?.[3]?l._OrtBindOutput(q,g[Re],I[he],0)!==0&&Ce(`Can\'t bind pre-allocated output[${he}] for session=${e}.`):l._OrtBindOutput(q,g[Re],0,De[Re])!==0&&Ce(`Can\'t bind output[${he}] to ${L[he]} for session=${e}.`)}}let X;C?X=await l._OrtRunWithBinding(c,C.handle,$,_,b):X=await l._OrtRun(c,G,M,x,U,$,_,b),X!==0&&Ce("failed to call OrtRun().");let Se=[];for(let q=0;q<$;q++){let L=l.HEAPU32[_/4+q];if(L===I[q]){Se.push(o[q]);continue}let De=l.stackSave(),he=l.stackAlloc(4*4),Re=!1,we,Be=0;try{l._OrtGetTensorData(L,he,he+4,he+8,he+12)!==0&&Ce(`Can\'t access output tensor data on index ${q}.`);let We=he/4,nt=l.HEAPU32[We++];Be=l.HEAPU32[We++];let N=l.HEAPU32[We++],de=l.HEAPU32[We++],ge=[];for(let Te=0;Te<de;Te++)ge.push(l.HEAPU32[N/4+Te]);l._OrtFree(N);let ze=ge.reduce((Te,Ae)=>Te*Ae,1);we=Yt(nt);let Ge=C?.outputPreferredLocations[i[q]];if(we==="string"){if(Ge==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Te=[],Ae=Be/4;for(let Ue=0;Ue<ze;Ue++){let qe=l.HEAPU32[Ae++],Ve=Ue===ze-1?void 0:l.HEAPU32[Ae]-qe;Te.push(l.UTF8ToString(qe,Ve))}Se.push([we,ge,Te,"cpu"])}else if(Ge==="gpu-buffer"&&ze>0){let Te=l.jsepGetBuffer(Be),Ae=Xt(nt);if(Ae===void 0||!po(we))throw new Error(`Unsupported data type: ${we}`);Re=!0,Se.push([we,ge,{gpuBuffer:Te,download:l.jsepCreateDownloader(Te,ze*Ae,we),dispose:()=>{l._OrtReleaseTensor(L)}},"gpu-buffer"])}else{let Te=wr(we),Ae=new Te(ze);new Uint8Array(Ae.buffer,Ae.byteOffset,Ae.byteLength).set(l.HEAPU8.subarray(Be,Be+Ae.byteLength)),Se.push([we,ge,Ae,"cpu"])}}finally{l.stackRestore(De),we==="string"&&Be&&l._free(Be),Re||l._OrtReleaseTensor(L)}}return C&&l._OrtClearBoundOutputs(C.handle),Se}finally{l.stackRestore(z),v.forEach(V=>l._OrtReleaseTensor(V)),I.forEach(V=>l._OrtReleaseTensor(V)),B.forEach(V=>l._free(V)),b!==0&&l._OrtReleaseRunOptions(b),w.forEach(V=>l._free(V))}},Us=e=>{let t=Ee(),r=nr.get(e);if(!r)throw new Error("invalid session id");let i=r[0],o=t._OrtEndProfiling(i);o===0&&Ce("Can\'t get an profile file name."),t._OrtFree(o)},Ns=e=>{let t=[];for(let r of e){let i=r[2];!Array.isArray(i)&&"buffer"in i&&t.push(i.buffer)}return t};self.onmessage=e=>{switch(e.data.type){case"init-wasm":try{uo(e.data.in).then(()=>postMessage({type:"init-wasm"}),t=>postMessage({type:"init-wasm",err:t}))}catch(t){postMessage({type:"init-wasm",err:t})}break;case"init-ort":try{Ds(e.data.in).then(()=>postMessage({type:"init-ort"}),t=>postMessage({type:"init-ort",err:t}))}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{let{model:t}=e.data.in,r=On(t);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{let{modeldata:t,options:r}=e.data.in,i=_n(t,r);postMessage({type:"create_finalize",out:i})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{let{model:t,options:r}=e.data.in,i=Ws(t,r);postMessage({type:"create",out:i})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{let t=e.data.in;zs(t),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{let{sessionId:t,inputIndices:r,inputs:i,outputIndices:o,options:s}=e.data.in;Gs(t,r,i,o,s).then(l=>{postMessage({type:"run",out:l},Ns(l))},l=>{postMessage({type:"run",err:l})})}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{let t=e.data.in;Us(t),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}break;default:}};})();\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n'});var Or,_t,qi,Qs,eu,Hs,js,qs,Ks,Ys,Xs,Js,Zs,Jr,K2,ji,Pb,Db,kb,Bb,tu,Rb,Mb,Lb,ru=k(()=>{"use strict";zt();Eb();wn();Or=()=>!!xe.wasm.proxy&&typeof document<"u",qi=!1,Qs=!1,eu=!1,qs=[],Ks=[],Ys=[],Xs=[],Js=[],Zs=[],Jr=()=>{if(qi||!Qs||eu||!_t)throw new Error("worker not ready")},K2=n=>{switch(n.data.type){case"init-wasm":qi=!1,n.data.err?(eu=!0,Hs[1](n.data.err)):(Qs=!0,Hs[0]());break;case"init-ort":n.data.err?js[1](n.data.err):js[0]();break;case"create_allocate":n.data.err?qs.shift()[1](n.data.err):qs.shift()[0](n.data.out);break;case"create_finalize":n.data.err?Ks.shift()[1](n.data.err):Ks.shift()[0](n.data.out);break;case"create":n.data.err?Ys.shift()[1](n.data.err):Ys.shift()[0](n.data.out);break;case"release":n.data.err?Xs.shift()[1](n.data.err):Xs.shift()[0]();break;case"run":n.data.err?Js.shift()[1](n.data.err):Js.shift()[0](n.data.out);break;case"end-profiling":n.data.err?Zs.shift()[1](n.data.err):Zs.shift()[0]();break;default:}},ji=typeof document<"u"?document?.currentScript?.src:void 0,Pb=async()=>{if(Or()){if(Qs)return;if(qi)throw new Error("multiple calls to 'initWasm()' detected.");if(eu)throw new Error("previous call to 'initWasm()' failed.");return qi=!0,xe.wasm.wasmPaths===void 0&&ji&&ji.indexOf("blob:")!==0&&(xe.wasm.wasmPaths=ji.substr(0,+ji.lastIndexOf("/")+1)),new Promise((n,e)=>{_t?.terminate();let r=URL.createObjectURL(new Blob([Cb()],{type:"text/javascript"}));_t=new Worker(r,{name:"ort-wasm-proxy-worker"}),_t.onerror=o=>e(o),_t.onmessage=K2,URL.revokeObjectURL(r),Hs=[n,e];let t={type:"init-wasm",in:xe.wasm};_t.postMessage(t)})}else return ph(xe.wasm)},Db=async n=>{if(Or())return Jr(),new Promise((e,r)=>{js=[e,r];let t={type:"init-ort",in:n};_t.postMessage(t)});await $b(n)},kb=async n=>Or()?(Jr(),new Promise((e,r)=>{qs.push([e,r]);let t={type:"create_allocate",in:{model:n}};_t.postMessage(t,[n.buffer])})):Vs(n),Bb=async(n,e)=>Or()?(Jr(),new Promise((r,t)=>{Ks.push([r,t]);let o={type:"create_finalize",in:{modeldata:n,options:e}};_t.postMessage(o)})):Us(n,e),tu=async(n,e)=>{if(Or()){if(e?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Jr(),new Promise((r,t)=>{Ys.push([r,t]);let o={type:"create",in:{model:n,options:e}};_t.postMessage(o,[n.buffer])})}else return Ib(n,e)},Rb=async n=>{if(Or())return Jr(),new Promise((e,r)=>{Xs.push([e,r]);let t={type:"release",in:n};_t.postMessage(t)});Sb(n)},Mb=async(n,e,r,t,o,i)=>{if(Or()){if(r.some(s=>s[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(o.some(s=>s))throw new Error("pre-allocated output tensor is not supported for proxy.");return Jr(),new Promise((s,a)=>{Js.push([s,a]);let u=r,l={type:"run",in:{sessionId:n,inputIndices:e,inputs:u,outputIndices:t,options:i}};_t.postMessage(l,Ob(u))})}else return _b(n,e,r,t,o,i)},Lb=async n=>{if(Or())return Jr(),new Promise((e,r)=>{Zs.push([e,r]);let t={type:"end-profiling",in:n};_t.postMessage(t)});Ab(n)}});var Nb,Ki,Fb,Y2,Yi,zb=k(()=>{"use strict";zt();ru();dt();Fb=(n,e)=>{switch(n.location){case"cpu":return[n.type,n.dims,n.data,"cpu"];case"gpu-buffer":return[n.type,n.dims,{gpuBuffer:n.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${n.location} for ${e()}`)}},Y2=n=>{switch(n[3]){case"cpu":return new Ft(n[0],n[2],n[1]);case"gpu-buffer":{let e=n[0];if(!Si(e))throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);let{gpuBuffer:r,download:t,dispose:o}=n[2];return Ft.fromGpuBuffer(r,{dataType:e,dims:n[1],download:t,dispose:o})}default:throw new Error(`invalid data location: ${n[3]}`)}},Yi=class{async createSessionAllocate(e){let r=await fetch(e);if(r.status!==200)throw new Error(`failed to load model: ${e}`);let t=await r.arrayBuffer();return kb(new Uint8Array(t))}async loadModel(e,r){if(Nb||(Ki||(Ki=Db(xe)),await Ki,Ki=void 0,Nb=!0),typeof e=="string")if(typeof process<"u"&&process.versions&&process.versions.node){let t=await(void 0)(e);[this.sessionId,this.inputNames,this.outputNames]=await tu(t,r)}else{let t=await this.createSessionAllocate(e);[this.sessionId,this.inputNames,this.outputNames]=await Bb(t,r)}else[this.sessionId,this.inputNames,this.outputNames]=await tu(e,r)}async dispose(){return Rb(this.sessionId)}async run(e,r,t){let o=[],i=[];Object.entries(e).forEach(h=>{let g=h[0],y=h[1],b=this.inputNames.indexOf(g);if(b===-1)throw new Error(`invalid input '${g}'`);o.push(y),i.push(b)});let s=[],a=[];Object.entries(r).forEach(h=>{let g=h[0],y=h[1],b=this.outputNames.indexOf(g);if(b===-1)throw new Error(`invalid output '${g}'`);s.push(y),a.push(b)});let u=o.map((h,g)=>Fb(h,()=>`input "${this.inputNames[i[g]]}"`)),l=s.map((h,g)=>h?Fb(h,()=>`output "${this.outputNames[a[g]]}"`):null),d=await Mb(this.sessionId,i,u,a,l,t),p={};for(let h=0;h<d.length;h++)p[this.outputNames[a[h]]]=s[h]??Y2(d[h]);return p}startProfiling(){}endProfiling(){Lb(this.sessionId)}}});var X2,Xi,Gb=k(()=>{"use strict";zt();ru();zb();X2=()=>{if((typeof xe.wasm.initTimeout!="number"||xe.wasm.initTimeout<0)&&(xe.wasm.initTimeout=0),typeof xe.wasm.simd!="boolean"&&(xe.wasm.simd=!0),typeof xe.wasm.proxy!="boolean"&&(xe.wasm.proxy=!1),typeof xe.wasm.numThreads!="number"||!Number.isInteger(xe.wasm.numThreads)||xe.wasm.numThreads<=0){let n=typeof navigator>"u"?(void 0)().length:navigator.hardwareConcurrency;xe.wasm.numThreads=Math.min(4,Math.ceil((n||1)/2))}},Xi=class{async init(){X2(),await Pb()}async createInferenceSessionHandler(e,r){let t=new Yi;return await t.loadModel(e,r),Promise.resolve(t)}}});var Wb={};sn(Wb,{wasmBackend:()=>J2});var J2,Vb=k(()=>{"use strict";Gb();J2=new Xi});zt();zt();var Ku="1.17.0";{let n=(Qp(),vr(Zp)).onnxjsBackend;xr("webgl",n,-10)}{let n=(Vb(),vr(Wb)).wasmBackend;typeof navigator<"u"&&navigator.gpu&&xr("webgpu",n,5),xr("cpu",n,10),xr("wasm",n,10),xr("xnnpack",n,9),xr("webnn",n,9)}Object.defineProperty(xe.versions,"web",{value:Ku,enumerable:!0});export{I1 as InferenceSession,Ft as Tensor,O1 as TrainingSession,xe as env,xr as registerBackend};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/*! Bundled license information:

long/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=ort.all.min.js.map
