/*!
 * ONNX Runtime Common v1.17.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.ort=t():e.ort=t()}(self,(()=>(()=>{"use strict";var e={d:(t,r)=>{for(var o in r)e.o(r,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:r[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{InferenceSession:()=>m,Tensor:()=>l,TrainingSession:()=>w,env:()=>s,registerBackend:()=>n});const r=new Map,o=[],n=(e,t,n)=>{if(!t||"function"!=typeof t.init||"function"!=typeof t.createInferenceSessionHandler)throw new TypeError("not a valid backend");{const i=r.get(e);if(void 0===i)r.set(e,{backend:t,priority:n});else{if(i.priority>n)return;if(i.priority===n&&i.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${n}`)}if(n>=0){const t=o.indexOf(e);-1!==t&&o.splice(t,1);for(let t=0;t<o.length;t++)if(r.get(o[t]).priority<=n)return void o.splice(t,0,e);o.push(e)}}};let i="warning";const a={wasm:{},webgl:{},webgpu:{},versions:{common:"1.17.0"},set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);i=e}},get logLevel(){return i}};Object.defineProperty(a,"logLevel",{enumerable:!0});const s=a,d=(e,t)=>{var r,o,n;if(void 0===e)throw new Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw new Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");const{height:i,width:a}=t,s=null!==(r=t.norm)&&void 0!==r?r:{mean:255,bias:0};let d,f;d="number"==typeof s.mean?[s.mean,s.mean,s.mean,s.mean]:[s.mean[0],s.mean[1],s.mean[2],null!==(o=s.mean[3])&&void 0!==o?o:255],f="number"==typeof s.bias?[s.bias,s.bias,s.bias,s.bias]:[s.bias[0],s.bias[1],s.bias[2],null!==(n=s.bias[3])&&void 0!==n?n:0];const u=void 0!==t.format?t.format:"RGBA",h=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",l=i*a,p="RGBA"===h?new Float32Array(4*l):new Float32Array(3*l);let m=4,w=0,g=1,y=2,b=3,v=0,E=l,A=2*l,T=-1;"RGB"===u&&(m=3,w=0,g=1,y=2,b=-1),"RGBA"===h?T=3*l:"RBG"===h?(v=0,A=l,E=2*l):"BGR"===h&&(A=0,E=l,v=2*l);for(let t=0;t<l;t++,w+=m,y+=m,g+=m,b+=m)p[v++]=(e[w]+f[0])/d[0],p[E++]=(e[g]+f[1])/d[1],p[A++]=(e[y]+f[2])/d[2],-1!==T&&-1!==b&&(p[T++]=(e[b]+f[3])/d[3]);return new c("float32",p,"RGBA"===h?[1,4,i,a]:[1,3,i,a])},f=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),u=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let h=!1;class c{constructor(e,t,r){let o,n;if((()=>{if(!h){h=!0;const e="undefined"!=typeof BigInt64Array&&"function"==typeof BigInt64Array.from,t="undefined"!=typeof BigUint64Array&&"function"==typeof BigUint64Array.from;e&&(f.set("int64",BigInt64Array),u.set(BigInt64Array,"int64")),t&&(f.set("uint64",BigUint64Array),u.set(BigUint64Array,"uint64"))}})(),"object"==typeof e&&"location"in e)switch(this.dataLocation=e.location,o=e.type,n=e.dims,e.location){case"cpu-pinned":{const t=f.get(o);if(!t)throw new TypeError(`unsupported type "${o}" to create tensor from pinned buffer`);if(!(e.data instanceof t))throw new TypeError(`buffer should be of type ${t.name}`);this.cpuData=e.data;break}case"texture":if("float32"!==o)throw new TypeError(`unsupported type "${o}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break;case"gpu-buffer":if("float32"!==o&&"float16"!==o&&"int32"!==o&&"int64"!==o&&"uint32"!==o&&"bool"!==o)throw new TypeError(`unsupported type "${o}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break;default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let i,a;if("string"==typeof e)if(o=e,a=r,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");i=t}else{const r=f.get(e);if(void 0===r)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if("float16"===e)throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");i="uint64"===e||"int64"===e?r.from(t,BigInt):r.from(t)}else{if(!(t instanceof r))throw new TypeError(`A ${o} tensor's data must be type of ${r}`);i=t}}else if(a=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");const t=typeof e[0];if("string"===t)o="string",i=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);o="bool",i=Uint8Array.from(e)}}else{const t=u.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);o=t,i=e}if(void 0===a)a=[i.length];else if(!Array.isArray(a))throw new TypeError("A tensor's dims must be a number array");n=a,this.cpuData=i,this.dataLocation="cpu"}const i=(e=>{let t=1;for(let r=0;r<e.length;r++){const o=e[r];if("number"!=typeof o||!Number.isSafeInteger(o))throw new TypeError(`dims[${r}] must be an integer, got: ${o}`);if(o<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${o}`);t*=o}return t})(n);if(this.cpuData&&i!==this.cpuData.length)throw new Error(`Tensor's size(${i}) does not match data length(${this.cpuData.length}).`);this.type=o,this.dims=n,this.size=i}static async fromImage(e,t){return(async(e,t)=>{const r="undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement,o="undefined"!=typeof ImageData&&e instanceof ImageData,n="undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap,i="string"==typeof e;let a,s=null!=t?t:{};if(r){const r=document.createElement("canvas");r.width=e.width,r.height=e.height;const o=r.getContext("2d");if(null==o)throw new Error("Can not access image data");{let r=e.height,n=e.width;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(r=t.resizedHeight,n=t.resizedWidth),void 0!==t){if(s=t,void 0!==t.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");s.tensorFormat="RGBA",s.height=r,s.width=n}else s.tensorFormat="RGBA",s.height=r,s.width=n;o.drawImage(e,0,0),a=o.getImageData(0,0,n,r).data}}else{if(!o){if(n){if(void 0===t)throw new Error("Please provide image config with format for Imagebitmap");const r=document.createElement("canvas");r.width=e.width,r.height=e.height;const o=r.getContext("2d");if(null!=o){const t=e.height,r=e.width;return o.drawImage(e,0,0,r,t),a=o.getImageData(0,0,r,t).data,s.height=t,s.width=r,d(a,s)}throw new Error("Can not access image data")}if(i)return new Promise(((t,r)=>{const o=document.createElement("canvas"),n=o.getContext("2d");if(!e||!n)return r();const i=new Image;i.crossOrigin="Anonymous",i.src=e,i.onload=()=>{o.width=i.width,o.height=i.height,n.drawImage(i,0,0,o.width,o.height);const e=n.getImageData(0,0,o.width,o.height);s.height=o.height,s.width=o.width,t(d(e.data,s))}}));throw new Error("Input data provided is not supported - aborted tensor creation")}{let r,o;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(r=t.resizedHeight,o=t.resizedWidth):(r=e.height,o=e.width),void 0!==t&&(s=t),s.format="RGBA",s.height=r,s.width=o,void 0!==t){const t=document.createElement("canvas");t.width=o,t.height=r;const n=t.getContext("2d");if(null==n)throw new Error("Can not access image data");n.putImageData(e,0,0),a=n.getImageData(0,0,o,r).data}else a=e.data}}if(void 0!==a)return d(a,s);throw new Error("Input data provided is not supported - aborted tensor creation")})(e,t)}static fromTexture(e,t){return((e,t)=>{const{width:r,height:o,download:n,dispose:i}=t;return new c({location:"texture",type:"float32",texture:e,dims:[1,o,r,4],download:n,dispose:i})})(e,t)}static fromGpuBuffer(e,t){return((e,t)=>{const{dataType:r,dims:o,download:n,dispose:i}=t;return new c({location:"gpu-buffer",type:null!=r?r:"float32",gpuBuffer:e,dims:o,download:n,dispose:i})})(e,t)}static fromPinnedBuffer(e,t,r){return((e,t,r)=>new c({location:"cpu-pinned",type:e,data:t,dims:null!=r?r:[t.length]}))(e,t,r)}toDataURL(e){return((e,t)=>{const r=document.createElement("canvas");r.width=e.dims[3],r.height=e.dims[2];const o=r.getContext("2d");if(null!=o){let n,i;void 0!==(null==t?void 0:t.tensorLayout)&&"NHWC"===t.tensorLayout?(n=e.dims[2],i=e.dims[3]):(n=e.dims[3],i=e.dims[2]);const a=void 0!==(null==t?void 0:t.format)?t.format:"RGB",s=null==t?void 0:t.norm;let d,f;void 0===s||void 0===s.mean?d=[255,255,255,255]:"number"==typeof s.mean?d=[s.mean,s.mean,s.mean,s.mean]:(d=[s.mean[0],s.mean[1],s.mean[2],0],void 0!==s.mean[3]&&(d[3]=s.mean[3])),void 0===s||void 0===s.bias?f=[0,0,0,0]:"number"==typeof s.bias?f=[s.bias,s.bias,s.bias,s.bias]:(f=[s.bias[0],s.bias[1],s.bias[2],0],void 0!==s.bias[3]&&(f[3]=s.bias[3]));const u=i*n;let h=0,c=u,l=2*u,p=-1;"RGBA"===a?(h=0,c=u,l=2*u,p=3*u):"RGB"===a?(h=0,c=u,l=2*u):"RBG"===a&&(h=0,l=u,c=2*u);for(let t=0;t<i;t++)for(let r=0;r<n;r++){const n=(e.data[h++]-f[0])*d[0],i=(e.data[c++]-f[1])*d[1],a=(e.data[l++]-f[2])*d[2],s=-1===p?255:(e.data[p++]-f[3])*d[3];o.fillStyle="rgba("+n+","+i+","+a+","+s+")",o.fillRect(r,t,1,1)}return r.toDataURL()}throw new Error("Can not access image data")})(this,e)}toImageData(e){return((e,t)=>{const r=document.createElement("canvas").getContext("2d");let o;if(null==r)throw new Error("Can not access image data");{let n,i,a;void 0!==(null==t?void 0:t.tensorLayout)&&"NHWC"===t.tensorLayout?(n=e.dims[2],i=e.dims[1],a=e.dims[3]):(n=e.dims[3],i=e.dims[2],a=e.dims[1]);const s=void 0!==t&&void 0!==t.format?t.format:"RGB",d=null==t?void 0:t.norm;let f,u;void 0===d||void 0===d.mean?f=[255,255,255,255]:"number"==typeof d.mean?f=[d.mean,d.mean,d.mean,d.mean]:(f=[d.mean[0],d.mean[1],d.mean[2],255],void 0!==d.mean[3]&&(f[3]=d.mean[3])),void 0===d||void 0===d.bias?u=[0,0,0,0]:"number"==typeof d.bias?u=[d.bias,d.bias,d.bias,d.bias]:(u=[d.bias[0],d.bias[1],d.bias[2],0],void 0!==d.bias[3]&&(u[3]=d.bias[3]));const h=i*n;if(void 0!==t&&(void 0!==t.format&&4===a&&"RGBA"!==t.format||3===a&&"RGB"!==t.format&&"BGR"!==t.format))throw new Error("Tensor format doesn't match input tensor dims");const c=4;let l=0,p=1,m=2,w=3,g=0,y=h,b=2*h,v=-1;"RGBA"===s?(g=0,y=h,b=2*h,v=3*h):"RGB"===s?(g=0,y=h,b=2*h):"RBG"===s&&(g=0,b=h,y=2*h),o=r.createImageData(n,i);for(let t=0;t<i*n;l+=c,p+=c,m+=c,w+=c,t++)o.data[l]=(e.data[g++]-u[0])*f[0],o.data[p]=(e.data[y++]-u[1])*f[1],o.data[m]=(e.data[b++]-u[2])*f[2],o.data[w]=-1===v?255:(e.data[v++]-u[3])*f[3]}return o})(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return((e,t)=>{switch(e.location){case"cpu":return new c(e.type,e.data,t);case"cpu-pinned":return new c({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new c({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new c({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}})(this,e)}}const l=c;class p{constructor(e){this.handler=e}async run(e,t,r){const o={};let n={};if("object"!=typeof e||null===e||e instanceof l||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let i=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof l)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("'fetches' cannot be an empty array.");i=!1;for(const e of t){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);o[e]=null}if("object"==typeof r&&null!==r)n=r;else if(void 0!==r)throw new TypeError("'options' must be an object.")}else{let e=!1;const a=Object.getOwnPropertyNames(t);for(const r of this.outputNames)if(-1!==a.indexOf(r)){const n=t[r];(null===n||n instanceof l)&&(e=!0,i=!1,o[r]=n)}if(e){if("object"==typeof r&&null!==r)n=r;else if(void 0!==r)throw new TypeError("'options' must be an object.")}else n=t}}else if(void 0!==t)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const t of this.inputNames)if(void 0===e[t])throw new Error(`input '${t}' is missing in 'feeds'.`);if(i)for(const e of this.outputNames)o[e]=null;const a=await this.handler.run(e,o,n),s={};for(const e in a)if(Object.hasOwnProperty.call(a,e)){const t=a[e];s[e]=t instanceof l?t:new l(t.type,t.data,t.dims)}return s}async release(){return this.handler.dispose()}static async create(e,t,n,i){let a,s={};if("string"==typeof e){if(a=e,"object"==typeof t&&null!==t)s=t;else if(void 0!==t)throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(a=e,"object"==typeof t&&null!==t)s=t;else if(void 0!==t)throw new TypeError("'options' must be an object.")}else{if(!(e instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&e instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{const r=e;let o=0,d=e.byteLength;if("object"==typeof t&&null!==t)s=t;else if("number"==typeof t){if(o=t,!Number.isSafeInteger(o))throw new RangeError("'byteOffset' must be an integer.");if(o<0||o>=r.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${r.byteLength}).`);if(d=e.byteLength-o,"number"==typeof n){if(d=n,!Number.isSafeInteger(d))throw new RangeError("'byteLength' must be an integer.");if(d<=0||o+d>r.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${r.byteLength-o}].`);if("object"==typeof i&&null!==i)s=i;else if(void 0!==i)throw new TypeError("'options' must be an object.")}else if(void 0!==n)throw new TypeError("'byteLength' must be a number.")}else if(void 0!==t)throw new TypeError("'options' must be an object.");a=new Uint8Array(r,o,d)}}const d=(s.executionProviders||[]).map((e=>"string"==typeof e?e:e.name)),f=await(async e=>{const t=0===e.length?o:e,n=[];for(const e of t){const t=r.get(e);if(t){if(t.initialized)return t.backend;if(t.aborted)continue;const r=!!t.initPromise;try{return r||(t.initPromise=t.backend.init()),await t.initPromise,t.initialized=!0,t.backend}catch(o){r||n.push({name:e,err:o}),t.aborted=!0}finally{delete t.initPromise}}}throw new Error(`no available backend found. ERR: ${n.map((e=>`[${e.name}] ${e.err}`)).join(", ")}`)})(d),u=await f.createInferenceSessionHandler(a,s);return new p(u)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}const m=p,w=class{constructor(e){this.handler=e}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}static async create(e,t){throw new Error("Method not implemented")}async loadParametersBuffer(e,t){throw new Error("Method not implemented.")}async getContiguousParameters(e){throw new Error("Method not implemented.")}async runTrainStep(e,t,r){throw new Error("Method not implemented.")}async release(){return this.handler.dispose()}};return t})()));
//# sourceMappingURL=ort-common.min.js.map