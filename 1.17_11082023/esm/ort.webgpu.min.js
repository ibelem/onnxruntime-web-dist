/*!
 * ONNX Runtime Web v1.17.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var yn=Object.defineProperty;var sl=Object.getOwnPropertyDescriptor;var ul=Object.getOwnPropertyNames;var ll=Object.prototype.hasOwnProperty;var H=(e,t)=>()=>(e&&(t=e(e=0)),t);var zt=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),ar=(e,t)=>{for(var r in t)yn(e,r,{get:t[r],enumerable:!0})},dl=(e,t,r,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let a of ul(t))!ll.call(e,a)&&a!==r&&yn(e,a,{get:()=>t[a],enumerable:!(o=sl(t,a))||o.enumerable});return e};var St=e=>dl(yn({},"__esModule",{value:!0}),e);var Or,Ct,It,Ta,bn=H(()=>{"use strict";Or=new Map,Ct=[],It=(e,t,r)=>{if(t&&typeof t.init=="function"&&typeof t.createInferenceSessionHandler=="function"){let o=Or.get(e);if(o===void 0)Or.set(e,{backend:t,priority:r});else{if(o.priority>r)return;if(o.priority===r&&o.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${r}`)}if(r>=0){let a=Ct.indexOf(e);a!==-1&&Ct.splice(a,1);for(let s=0;s<Ct.length;s++)if(Or.get(Ct[s]).priority<=r){Ct.splice(s,0,e);return}Ct.push(e)}return}throw new TypeError("not a valid backend")},Ta=async e=>{let t=e.length===0?Ct:e,r=[];for(let o of t){let a=Or.get(o);if(a){if(a.initialized)return a.backend;if(a.aborted)continue;let s=!!a.initPromise;try{return s||(a.initPromise=a.backend.init()),await a.initPromise,a.initialized=!0,a.backend}catch(u){s||r.push({name:o,err:u}),a.aborted=!0}finally{delete a.initPromise}}}throw new Error(`no available backend found. ERR: ${r.map(o=>`[${o.name}] ${o.err}`).join(", ")}`)}});var Ra=H(()=>{"use strict";bn()});var ka,Pa=H(()=>{"use strict";ka="1.17.0"});var Ba,wn,Ma=H(()=>{"use strict";Pa();Ba="warning",wn={wasm:{},webgl:{},webgpu:{},versions:{common:ka},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);Ba=e}},get logLevel(){return Ba}};Object.defineProperty(wn,"logLevel",{enumerable:!0})});var Ae,Da=H(()=>{"use strict";Ma();Ae=wn});var za,Wa,Na=H(()=>{"use strict";za=(e,t)=>{let r=document.createElement("canvas");r.width=e.dims[3],r.height=e.dims[2];let o=r.getContext("2d");if(o!=null){let a,s;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(a=e.dims[2],s=e.dims[3]):(a=e.dims[3],s=e.dims[2]);let u=t?.format!==void 0?t.format:"RGB",n=t?.norm,d,p;n===void 0||n.mean===void 0?d=[255,255,255,255]:typeof n.mean=="number"?d=[n.mean,n.mean,n.mean,n.mean]:(d=[n.mean[0],n.mean[1],n.mean[2],0],n.mean[3]!==void 0&&(d[3]=n.mean[3])),n===void 0||n.bias===void 0?p=[0,0,0,0]:typeof n.bias=="number"?p=[n.bias,n.bias,n.bias,n.bias]:(p=[n.bias[0],n.bias[1],n.bias[2],0],n.bias[3]!==void 0&&(p[3]=n.bias[3]));let h=s*a,y=0,b=h,w=h*2,$=-1;u==="RGBA"?(y=0,b=h,w=h*2,$=h*3):u==="RGB"?(y=0,b=h,w=h*2):u==="RBG"&&(y=0,w=h,b=h*2);for(let v=0;v<s;v++)for(let x=0;x<a;x++){let I=(e.data[y++]-p[0])*d[0],R=(e.data[b++]-p[1])*d[1],M=(e.data[w++]-p[2])*d[2],B=$===-1?255:(e.data[$++]-p[3])*d[3];o.fillStyle="rgba("+I+","+R+","+M+","+B+")",o.fillRect(x,v,1,1)}return r.toDataURL()}else throw new Error("Can not access image data")},Wa=(e,t)=>{let r=document.createElement("canvas").getContext("2d"),o;if(r!=null){let a,s,u;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(a=e.dims[2],s=e.dims[1],u=e.dims[3]):(a=e.dims[3],s=e.dims[2],u=e.dims[1]);let n=t!==void 0&&t.format!==void 0?t.format:"RGB",d=t?.norm,p,h;d===void 0||d.mean===void 0?p=[255,255,255,255]:typeof d.mean=="number"?p=[d.mean,d.mean,d.mean,d.mean]:(p=[d.mean[0],d.mean[1],d.mean[2],255],d.mean[3]!==void 0&&(p[3]=d.mean[3])),d===void 0||d.bias===void 0?h=[0,0,0,0]:typeof d.bias=="number"?h=[d.bias,d.bias,d.bias,d.bias]:(h=[d.bias[0],d.bias[1],d.bias[2],0],d.bias[3]!==void 0&&(h[3]=d.bias[3]));let y=s*a;if(t!==void 0&&(t.format!==void 0&&u===4&&t.format!=="RGBA"||u===3&&t.format!=="RGB"&&t.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let b=4,w=0,$=1,v=2,x=3,I=0,R=y,M=y*2,B=-1;n==="RGBA"?(I=0,R=y,M=y*2,B=y*3):n==="RGB"?(I=0,R=y,M=y*2):n==="RBG"&&(I=0,M=y,R=y*2),o=r.createImageData(a,s);for(let W=0;W<s*a;w+=b,$+=b,v+=b,x+=b,W++)o.data[w]=(e.data[I++]-h[0])*p[0],o.data[$]=(e.data[R++]-h[1])*p[1],o.data[v]=(e.data[M++]-h[2])*p[2],o.data[x]=B===-1?255:(e.data[B++]-h[3])*p[3]}else throw new Error("Can not access image data");return o}});var vn,Ua,Ga,Fa,Ha,La=H(()=>{"use strict";Tr();vn=(e,t)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(t.height===void 0||t.width===void 0)throw new Error("Image height and width must be defined");if(t.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:r,width:o}=t,a=t.norm??{mean:255,bias:0},s,u;typeof a.mean=="number"?s=[a.mean,a.mean,a.mean,a.mean]:s=[a.mean[0],a.mean[1],a.mean[2],a.mean[3]??255],typeof a.bias=="number"?u=[a.bias,a.bias,a.bias,a.bias]:u=[a.bias[0],a.bias[1],a.bias[2],a.bias[3]??0];let n=t.format!==void 0?t.format:"RGBA",d=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:"RGB",p=r*o,h=d==="RGBA"?new Float32Array(p*4):new Float32Array(p*3),y=4,b=0,w=1,$=2,v=3,x=0,I=p,R=p*2,M=-1;n==="RGB"&&(y=3,b=0,w=1,$=2,v=-1),d==="RGBA"?M=p*3:d==="RBG"?(x=0,R=p,I=p*2):d==="BGR"&&(R=0,I=p,x=p*2);for(let W=0;W<p;W++,b+=y,$+=y,w+=y,v+=y)h[x++]=(e[b]+u[0])/s[0],h[I++]=(e[w]+u[1])/s[1],h[R++]=(e[$]+u[2])/s[2],M!==-1&&v!==-1&&(h[M++]=(e[v]+u[3])/s[3]);return d==="RGBA"?new Ue("float32",h,[1,4,r,o]):new Ue("float32",h,[1,3,r,o])},Ua=async(e,t)=>{let r=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,o=typeof ImageData<"u"&&e instanceof ImageData,a=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,s=typeof e=="string",u,n=t??{};if(r){let d=document.createElement("canvas");d.width=e.width,d.height=e.height;let p=d.getContext("2d");if(p!=null){let h=e.height,y=e.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(h=t.resizedHeight,y=t.resizedWidth),t!==void 0){if(n=t,t.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");n.tensorFormat="RGBA",n.height=h,n.width=y}else n.tensorFormat="RGBA",n.height=h,n.width=y;p.drawImage(e,0,0),u=p.getImageData(0,0,y,h).data}else throw new Error("Can not access image data")}else if(o){let d,p;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(d=t.resizedHeight,p=t.resizedWidth):(d=e.height,p=e.width),t!==void 0&&(n=t),n.format="RGBA",n.height=d,n.width=p,t!==void 0){let h=document.createElement("canvas");h.width=p,h.height=d;let y=h.getContext("2d");if(y!=null)y.putImageData(e,0,0),u=y.getImageData(0,0,p,d).data;else throw new Error("Can not access image data")}else u=e.data}else if(a){if(t===void 0)throw new Error("Please provide image config with format for Imagebitmap");let d=document.createElement("canvas");d.width=e.width,d.height=e.height;let p=d.getContext("2d");if(p!=null){let h=e.height,y=e.width;return p.drawImage(e,0,0,y,h),u=p.getImageData(0,0,y,h).data,n.height=h,n.width=y,vn(u,n)}else throw new Error("Can not access image data")}else{if(s)return new Promise((d,p)=>{let h=document.createElement("canvas"),y=h.getContext("2d");if(!e||!y)return p();let b=new Image;b.crossOrigin="Anonymous",b.src=e,b.onload=()=>{h.width=b.width,h.height=b.height,y.drawImage(b,0,0,h.width,h.height);let w=y.getImageData(0,0,h.width,h.height);n.height=h.height,n.width=h.width,d(vn(w.data,n))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(u!==void 0)return vn(u,n);throw new Error("Input data provided is not supported - aborted tensor creation")},Ga=(e,t)=>{let{width:r,height:o,download:a,dispose:s}=t,u=[1,o,r,4];return new Ue({location:"texture",type:"float32",texture:e,dims:u,download:a,dispose:s})},Fa=(e,t)=>{let{dataType:r,dims:o,download:a,dispose:s}=t;return new Ue({location:"gpu-buffer",type:r??"float32",gpuBuffer:e,dims:o,download:a,dispose:s})},Ha=(e,t,r)=>new Ue({location:"cpu-pinned",type:e,data:t,dims:r??[t.length]})});var or,Rr,Va,ja,qa=H(()=>{"use strict";or=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),Rr=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),Va=!1,ja=()=>{if(!Va){Va=!0;let e=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",t=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function";e&&(or.set("int64",BigInt64Array),Rr.set(BigInt64Array,"int64")),t&&(or.set("uint64",BigUint64Array),Rr.set(BigUint64Array,"uint64"))}}});var Ka,Ya,Xa=H(()=>{"use strict";Tr();Ka=e=>{let t=1;for(let r=0;r<e.length;r++){let o=e[r];if(typeof o!="number"||!Number.isSafeInteger(o))throw new TypeError(`dims[${r}] must be an integer, got: ${o}`);if(o<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${o}`);t*=o}return t},Ya=(e,t)=>{switch(e.location){case"cpu":return new Ue(e.type,e.data,t);case"cpu-pinned":return new Ue({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new Ue({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new Ue({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}});var Ue,Tr=H(()=>{"use strict";Na();La();qa();Xa();Ue=class{constructor(t,r,o){ja();let a,s;if(typeof t=="object"&&"location"in t)switch(this.dataLocation=t.location,a=t.type,s=t.dims,t.location){case"cpu-pinned":{let n=or.get(a);if(!n)throw new TypeError(`unsupported type "${a}" to create tensor from pinned buffer`);if(!(t.data instanceof n))throw new TypeError(`buffer should be of type ${n.name}`);this.cpuData=t.data;break}case"texture":{if(a!=="float32")throw new TypeError(`unsupported type "${a}" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case"gpu-buffer":{if(a!=="float32"&&a!=="float16"&&a!=="int32"&&a!=="int64"&&a!=="uint32"&&a!=="bool")throw new TypeError(`unsupported type "${a}" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let n,d;if(typeof t=="string")if(a=t,d=o,t==="string"){if(!Array.isArray(r))throw new TypeError("A string tensor's data must be a string array.");n=r}else{let p=or.get(t);if(p===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(r)){if(t==="float16")throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");t==="uint64"||t==="int64"?n=p.from(r,BigInt):n=p.from(r)}else if(r instanceof p)n=r;else throw new TypeError(`A ${a} tensor's data must be type of ${p}`)}else if(d=r,Array.isArray(t)){if(t.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let p=typeof t[0];if(p==="string")a="string",n=t;else if(p==="boolean")a="bool",n=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${p}.`)}else{let p=Rr.get(t.constructor);if(p===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);a=p,n=t}if(d===void 0)d=[n.length];else if(!Array.isArray(d))throw new TypeError("A tensor's dims must be a number array");s=d,this.cpuData=n,this.dataLocation="cpu"}let u=Ka(s);if(this.cpuData&&u!==this.cpuData.length)throw new Error(`Tensor's size(${u}) does not match data length(${this.cpuData.length}).`);this.type=a,this.dims=s,this.size=u}static async fromImage(t,r){return Ua(t,r)}static fromTexture(t,r){return Ga(t,r)}static fromGpuBuffer(t,r){return Fa(t,r)}static fromPinnedBuffer(t,r,o){return Ha(t,r,o)}toDataURL(t){return za(this,t)}toImageData(t){return Wa(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(t){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let r=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=r,t&&this.disposer&&(this.disposer(),this.disposer=void 0),r}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return Ya(this,t)}}});var dt,$n=H(()=>{"use strict";Tr();dt=Ue});var kr,Qa=H(()=>{"use strict";bn();$n();kr=class e{constructor(t){this.handler=t}async run(t,r,o){let a={},s={};if(typeof t!="object"||t===null||t instanceof dt||Array.isArray(t))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let u=!0;if(typeof r=="object"){if(r===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(r instanceof dt)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(r)){if(r.length===0)throw new TypeError("'fetches' cannot be an empty array.");u=!1;for(let p of r){if(typeof p!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(p)===-1)throw new RangeError(`'fetches' contains invalid output name: ${p}.`);a[p]=null}if(typeof o=="object"&&o!==null)s=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else{let p=!1,h=Object.getOwnPropertyNames(r);for(let y of this.outputNames)if(h.indexOf(y)!==-1){let b=r[y];(b===null||b instanceof dt)&&(p=!0,u=!1,a[y]=b)}if(p){if(typeof o=="object"&&o!==null)s=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else s=r}}else if(typeof r<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let p of this.inputNames)if(typeof t[p]>"u")throw new Error(`input '${p}' is missing in 'feeds'.`);if(u)for(let p of this.outputNames)a[p]=null;let n=await this.handler.run(t,a,s),d={};for(let p in n)if(Object.hasOwnProperty.call(n,p)){let h=n[p];h instanceof dt?d[p]=h:d[p]=new dt(h.type,h.data,h.dims)}return d}async release(){return this.handler.dispose()}static async create(t,r,o,a){let s,u={};if(typeof t=="string"){if(s=t,typeof r=="object"&&r!==null)u=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(s=t,typeof r=="object"&&r!==null)u=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer){let y=t,b=0,w=t.byteLength;if(typeof r=="object"&&r!==null)u=r;else if(typeof r=="number"){if(b=r,!Number.isSafeInteger(b))throw new RangeError("'byteOffset' must be an integer.");if(b<0||b>=y.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${y.byteLength}).`);if(w=t.byteLength-b,typeof o=="number"){if(w=o,!Number.isSafeInteger(w))throw new RangeError("'byteLength' must be an integer.");if(w<=0||b+w>y.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${y.byteLength-b}].`);if(typeof a=="object"&&a!==null)u=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else if(typeof o<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof r<"u")throw new TypeError("'options' must be an object.");s=new Uint8Array(y,b,w)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let d=(u.executionProviders||[]).map(y=>typeof y=="string"?y:y.name),h=await(await Ta(d)).createInferenceSessionHandler(s,u);return new e(h)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var rp,Ja=H(()=>{"use strict";Qa();rp=kr});var Za=H(()=>{"use strict"});var Pr,eo=H(()=>{"use strict";Pr=class{constructor(t){this.handler=t}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}static async create(t,r){throw new Error("Method not implemented")}async loadParametersBuffer(t,r){throw new Error("Method not implemented.")}async getContiguousParameters(t){throw new Error("Method not implemented.")}async runTrainStep(t,r,o){throw new Error("Method not implemented.")}async release(){return this.handler.dispose()}}});var ip,to=H(()=>{"use strict";eo();ip=Pr});var At=H(()=>{"use strict";Ra();Da();Ja();$n();Za();to()});var xn={};ar(xn,{readFile:()=>cl});var cl,Sn=H(()=>{cl=void 0});var Cn={};ar(Cn,{join:()=>pl});var pl,In=H(()=>{pl=void 0});var oo=zt((ao,An)=>{"use strict";var no=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){var r=t,o,a;r.ready=new Promise((l,f)=>{o=l,a=f}),r.jsepInit=(l,f,g,C,_,D,L,ne)=>{r.Za=l,r.Oa=f,r.Qa=g,r.Ja=C,r.Pa=_,r.ra=D,r.Ra=L,r.Sa=ne,f=(Y,Q,ee)=>(...ce)=>{let pe=Le,E=Q?.();ce=Y(...ce);let ie=Q?.();return E!==ie&&(Y=ie,ee(E),Q=ee=null),Le!=pe?br():ce},g=Y=>async(...Q)=>{try{if(r.Da)throw Error("Session already started");let ee=r.Da={Ta:Q[0],errors:[]},ce=await Y(...Q);if(r.Da!==ee)throw Error("Session mismatch");l.flush();let pe=ee.errors;if(0<pe.length){let E=await Promise.all(pe);if(E=E.filter(ie=>ie),0<E.length)throw Error(E.join(`
`))}return ce}finally{r.Da=null}},r._OrtRun=g(f(r._OrtRun,()=>r._OrtRun,Y=>r._OrtRun=Y)),r._OrtRunWithBinding=g(f(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,Y=>r._OrtRunWithBinding=Y)),r._OrtBindInput=f(r._OrtBindInput,()=>r._OrtBindInput,Y=>r._OrtBindInput=Y),r.jsepRegisterBuffer=(Y,Q,ee,ce)=>l.registerBuffer(Y,Q,ee,ce),r.jsepUnregisterBuffers=Y=>{l.unregisterBuffers(Y)},r.jsepGetBuffer=Y=>l.getBuffer(Y),r.jsepCreateDownloader=(Y,Q,ee)=>l.createDownloader(Y,Q,ee)};var s=Object.assign({},r),u="./this.program",n=(l,f)=>{throw f},d=typeof window=="object",p=typeof importScripts=="function",h=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",y="",b,w,$;if(h){var v=(Sn(),St(xn)),x=(In(),St(Cn));y=p?x.dirname(y)+"/":__dirname+"/",b=(l,f)=>(l=l.startsWith("file://")?new URL(l):x.normalize(l),v.readFileSync(l,f?void 0:"utf8")),$=l=>(l=b(l,!0),l.buffer||(l=new Uint8Array(l)),l),w=(l,f,g,C=!0)=>{l=l.startsWith("file://")?new URL(l):x.normalize(l),v.readFile(l,C?void 0:"utf8",(_,D)=>{_?g(_):f(C?D.buffer:D)})},!r.thisProgram&&1<process.argv.length&&(u=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),n=(l,f)=>{throw process.exitCode=l,f},r.inspect=()=>"[Emscripten Module object]"}else(d||p)&&(p?y=self.location.href:typeof document<"u"&&document.currentScript&&(y=document.currentScript.src),e&&(y=e),y.indexOf("blob:")!==0?y=y.substr(0,y.replace(/[?#].*/,"").lastIndexOf("/")+1):y="",b=l=>{var f=new XMLHttpRequest;return f.open("GET",l,!1),f.send(null),f.responseText},p&&($=l=>{var f=new XMLHttpRequest;return f.open("GET",l,!1),f.responseType="arraybuffer",f.send(null),new Uint8Array(f.response)}),w=(l,f,g)=>{var C=new XMLHttpRequest;C.open("GET",l,!0),C.responseType="arraybuffer",C.onload=()=>{C.status==200||C.status==0&&C.response?f(C.response):g()},C.onerror=g,C.send(null)});var I=r.print||console.log.bind(console),R=r.printErr||console.error.bind(console);Object.assign(r,s),s=null,r.thisProgram&&(u=r.thisProgram),r.quit&&(n=r.quit);var M;r.wasmBinary&&(M=r.wasmBinary);var B=r.noExitRuntime||!0;typeof WebAssembly!="object"&&We("no native wasm support detected");var W,T,U=!1,F,j,le,P,X,Ce;function K(){var l=W.buffer;r.HEAP8=j=new Int8Array(l),r.HEAP16=new Int16Array(l),r.HEAP32=P=new Int32Array(l),r.HEAPU8=le=new Uint8Array(l),r.HEAPU16=new Uint16Array(l),r.HEAPU32=X=new Uint32Array(l),r.HEAPF32=new Float32Array(l),r.HEAPF64=Ce=new Float64Array(l)}var V=[],ze=[],he=[];function Pe(){var l=r.preRun.shift();V.unshift(l)}var we=0,Be=null,Xe=null;function We(l){throw r.onAbort&&r.onAbort(l),l="Aborted("+l+")",R(l),U=!0,F=1,l=new WebAssembly.RuntimeError(l+". Build with -sASSERTIONS for more info."),a(l),l}function it(l){return l.startsWith("data:application/octet-stream;base64,")}var G;if(G="ort-wasm-simd.wasm",!it(G)){var de=G;G=r.locateFile?r.locateFile(de,y):y+de}function ge(l){if(l==G&&M)return new Uint8Array(M);if($)return $(l);throw"both async and sync fetching of the wasm failed"}function Ne(l){if(!M&&(d||p)){if(typeof fetch=="function"&&!l.startsWith("file://"))return fetch(l,{credentials:"same-origin"}).then(f=>{if(!f.ok)throw"failed to load wasm binary file at '"+l+"'";return f.arrayBuffer()}).catch(()=>ge(l));if(w)return new Promise((f,g)=>{w(l,C=>f(new Uint8Array(C)),g)})}return Promise.resolve().then(()=>ge(l))}function Ge(l,f,g){return Ne(l).then(C=>WebAssembly.instantiate(C,f)).then(C=>C).then(g,C=>{R("failed to asynchronously prepare wasm: "+C),We(C)})}function Ee(l,f){var g=G;return M||typeof WebAssembly.instantiateStreaming!="function"||it(g)||g.startsWith("file://")||h||typeof fetch!="function"?Ge(g,l,f):fetch(g,{credentials:"same-origin"}).then(C=>WebAssembly.instantiateStreaming(C,l).then(f,function(_){return R("wasm streaming compile failed: "+_),R("falling back to ArrayBuffer instantiation"),Ge(g,l,f)}))}var Ie,Fe={910336:l=>{r.ra("Abs",l,void 0)},910387:l=>{r.ra("Neg",l,void 0)},910438:l=>{r.ra("Floor",l,void 0)},910491:l=>{r.ra("Ceil",l,void 0)},910543:l=>{r.ra("Reciprocal",l,void 0)},910601:l=>{r.ra("Sqrt",l,void 0)},910653:l=>{r.ra("Exp",l,void 0)},910704:l=>{r.ra("Erf",l,void 0)},910755:l=>{r.ra("Sigmoid",l,void 0)},910810:l=>{r.ra("Log",l,void 0)},910861:l=>{r.ra("Sin",l,void 0)},910912:l=>{r.ra("Cos",l,void 0)},910963:l=>{r.ra("Tan",l,void 0)},911014:l=>{r.ra("Asin",l,void 0)},911066:l=>{r.ra("Acos",l,void 0)},911118:l=>{r.ra("Atan",l,void 0)},911170:l=>{r.ra("Sinh",l,void 0)},911222:l=>{r.ra("Cosh",l,void 0)},911274:l=>{r.ra("Asinh",l,void 0)},911327:l=>{r.ra("Acosh",l,void 0)},911380:l=>{r.ra("Atanh",l,void 0)},911433:l=>{r.ra("Tanh",l,void 0)},911485:l=>{r.ra("Not",l,void 0)},911536:(l,f,g)=>{r.ra("ClipV10",l,{min:f,max:g})},911608:l=>{r.ra("Clip",l,void 0)},911660:(l,f)=>{r.ra("Elu",l,{alpha:f})},911718:l=>{r.ra("Relu",l,void 0)},911770:(l,f)=>{r.ra("LeakyRelu",l,{alpha:f})},911834:(l,f)=>{r.ra("ThresholdedRelu",l,{alpha:f})},911904:(l,f)=>{r.ra("Cast",l,{to:f})},911962:l=>{r.ra("Add",l,void 0)},912013:l=>{r.ra("Sub",l,void 0)},912064:l=>{r.ra("Mul",l,void 0)},912115:l=>{r.ra("Div",l,void 0)},912166:l=>{r.ra("Pow",l,void 0)},912217:l=>{r.ra("Equal",l,void 0)},912270:l=>{r.ra("Greater",l,void 0)},912325:l=>{r.ra("GreaterOrEqual",l,void 0)},912387:l=>{r.ra("Less",l,void 0)},912439:l=>{r.ra("LessOrEqual",l,void 0)},912498:(l,f,g,C,_)=>{r.ra("ReduceMean",l,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:C?Array.from(P.subarray(_>>>0,_+C>>>0)):[]})},912662:(l,f,g,C,_)=>{r.ra("ReduceMax",l,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:C?Array.from(P.subarray(_>>>0,_+C>>>0)):[]})},912825:(l,f,g,C,_)=>{r.ra("ReduceMin",l,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:C?Array.from(P.subarray(_>>>0,_+C>>>0)):[]})},912988:(l,f,g,C,_)=>{r.ra("ReduceProd",l,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:C?Array.from(P.subarray(_>>>0,_+C>>>0)):[]})},913152:(l,f,g,C,_)=>{r.ra("ReduceSum",l,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:C?Array.from(P.subarray(_>>>0,_+C>>>0)):[]})},913315:(l,f,g,C,_)=>{r.ra("ReduceL1",l,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:C?Array.from(P.subarray(_>>>0,_+C>>>0)):[]})},913477:(l,f,g,C,_)=>{r.ra("ReduceL2",l,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:C?Array.from(P.subarray(_>>>0,_+C>>>0)):[]})},913639:(l,f,g,C,_)=>{r.ra("ReduceLogSum",l,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:C?Array.from(P.subarray(_>>>0,_+C>>>0)):[]})},913805:(l,f,g,C,_)=>{r.ra("ReduceSumSquare",l,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:C?Array.from(P.subarray(_>>>0,_+C>>>0)):[]})},913974:(l,f,g,C,_)=>{r.ra("ReduceLogSumExp",l,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:C?Array.from(P.subarray(_>>>0,_+C>>>0)):[]})},914143:l=>{r.ra("Where",l,void 0)},914196:(l,f,g)=>{r.ra("Transpose",l,{perm:f?Array.from(P.subarray(g>>>0,g+f>>>0)):[]})},914309:(l,f,g,C,_,D,L,ne,Y,Q)=>{r.ra("Conv",l,{format:Y?"NHWC":"NCHW",auto_pad:f,dilations:[g],group:C,kernel_shape:[_],pads:[D,L],strides:[ne],w_is_const:()=>!!j[Q>>>0]})},914537:(l,f,g,C,_,D,L,ne,Y,Q,ee,ce,pe,E,ie)=>{r.ra("Conv",l,{format:E?"NHWC":"NCHW",auto_pad:f,dilations:[g,C],group:_,kernel_shape:[D,L],pads:[ne,Y,Q,ee],strides:[ce,pe],w_is_const:()=>!!j[ie>>>0]})},914796:(l,f,g,C,_,D,L,ne,Y,Q)=>{r.ra("Conv",l,{format:Y?"NHWC":"NCHW",auto_pad:f,dilations:[g],group:C,kernel_shape:[_],pads:[D,L],strides:[ne],w_is_const:()=>!!j[Q>>>0]})},915024:(l,f,g,C,_,D,L,ne,Y,Q,ee,ce,pe,E,ie)=>{r.ra("Conv",l,{format:E?"NHWC":"NCHW",auto_pad:f,dilations:[g,C],group:_,kernel_shape:[D,L],pads:[ne,Y,Q,ee],strides:[ce,pe],w_is_const:()=>!!j[ie>>>0]})},915283:(l,f,g,C,_,D,L,ne,Y,Q,ee,ce,pe,E)=>{r.ra("ConvTranspose",l,{format:Y?"NHWC":"NCHW",autoPad:f,dilations:[g],group:C,kernel_shape:[_],pads:[D,L],strides:[ne],wIsConst:()=>!!j[Q>>>0],outputPadding:ee?Array.from(P.subarray(ce>>>0,ce+ee>>>0)):[],outputShape:pe?Array.from(P.subarray(E>>>0,E+pe>>>0)):[]})},915663:(l,f,g,C,_,D,L,ne,Y,Q,ee,ce,pe)=>{r.ra("ConvTranspose",l,{format:ne?"NHWC":"NCHW",autoPad:f,dilations:Array.from(P.subarray(g>>>0,g+2>>>0)),group:C,kernelShape:Array.from(P.subarray(_>>>0,_+2>>>0)),pads:Array.from(P.subarray(D>>>0,D+4>>>0)),strides:Array.from(P.subarray(L>>>0,L+2>>>0)),wIsConst:()=>!!j[Y>>>0],outputPadding:0<Q?Array.from(P.subarray(ee>>>0,ee+Q>>>0)):[],outputShape:0<ce?Array.from(P.subarray(pe>>>0,pe+ce>>>0)):[]})},916186:(l,f,g,C,_,D,L,ne,Y,Q,ee,ce,pe,E)=>{r.ra("ConvTranspose",l,{format:Y?"NHWC":"NCHW",autoPad:f,dilations:[g],group:C,kernel_shape:[_],pads:[D,L],strides:[ne],wIsConst:()=>!!j[Q>>>0],outputPadding:ee?Array.from(P.subarray(ce>>>0,ce+ee>>>0)):[],outputShape:pe?Array.from(P.subarray(E>>>0,E+pe>>>0)):[]})},916566:(l,f,g,C,_,D,L,ne,Y,Q,ee,ce,pe)=>{r.ra("ConvTranspose",l,{format:ne?"NHWC":"NCHW",autoPad:f,dilations:Array.from(P.subarray(g>>>0,g+2>>>0)),group:C,kernelShape:Array.from(P.subarray(_>>>0,_+2>>>0)),pads:Array.from(P.subarray(D>>>0,D+4>>>0)),strides:Array.from(P.subarray(L>>>0,L+2>>>0)),wIsConst:()=>!!j[Y>>>0],outputPadding:0<Q?Array.from(P.subarray(ee>>>0,ee+Q>>>0)):[],outputShape:0<ce?Array.from(P.subarray(pe>>>0,pe+ce>>>0)):[]})},917089:(l,f)=>{r.ra("GlobalAveragePool",l,{format:f?"NHWC":"NCHW"})},917180:(l,f,g,C,_,D,L,ne,Y,Q,ee,ce,pe,E,ie,ye)=>{r.ra("AveragePool",l,{format:ye?"NHWC":"NCHW",auto_pad:f,ceil_mode:g,count_include_pad:C,storage_order:_,dilations:[D,L],kernel_shape:[ne,Y],pads:[Q,ee,ce,pe],strides:[E,ie]})},917464:(l,f)=>{r.ra("GlobalAveragePool",l,{format:f?"NHWC":"NCHW"})},917555:(l,f,g,C,_,D,L,ne,Y,Q,ee,ce,pe,E,ie,ye)=>{r.ra("AveragePool",l,{format:ye?"NHWC":"NCHW",auto_pad:f,ceil_mode:g,count_include_pad:C,storage_order:_,dilations:[D,L],kernel_shape:[ne,Y],pads:[Q,ee,ce,pe],strides:[E,ie]})},917839:(l,f)=>{r.ra("GlobalMaxPool",l,{format:f?"NHWC":"NCHW"})},917926:(l,f,g,C,_,D,L,ne,Y,Q,ee,ce,pe,E,ie,ye)=>{r.ra("MaxPool",l,{format:ye?"NHWC":"NCHW",auto_pad:f,ceil_mode:g,count_include_pad:C,storage_order:_,dilations:[D,L],kernel_shape:[ne,Y],pads:[Q,ee,ce,pe],strides:[E,ie]})},918206:(l,f)=>{r.ra("GlobalMaxPool",l,{format:f?"NHWC":"NCHW"})},918293:(l,f,g,C,_,D,L,ne,Y,Q,ee,ce,pe,E,ie,ye)=>{r.ra("MaxPool",l,{format:ye?"NHWC":"NCHW",auto_pad:f,ceil_mode:g,count_include_pad:C,storage_order:_,dilations:[D,L],kernel_shape:[ne,Y],pads:[Q,ee,ce,pe],strides:[E,ie]})},918573:(l,f,g,C,_)=>{r.ra("Gemm",l,{alpha:f,beta:g,transA:C,transB:_})},918677:l=>{r.ra("MatMul",l,void 0)},918731:(l,f,g,C)=>{r.ra("ArgMax",l,{keepDims:!!f,selectLastIndex:!!g,axis:C})},918839:(l,f,g,C)=>{r.ra("ArgMin",l,{keepDims:!!f,selectLastIndex:!!g,axis:C})},918947:(l,f)=>{r.ra("Softmax",l,{axis:f})},919010:(l,f)=>{r.ra("Concat",l,{axis:f})},919070:(l,f,g,C,_)=>{r.ra("Split",l,{axis:f,numOutputs:g,splitSizes:C?Array.from(P.subarray(_>>>0,_+C>>>0)):[]})},919215:l=>{r.ra("Expand",l,void 0)},919269:(l,f)=>{r.ra("Gather",l,{axis:Number(f)})},919340:(l,f)=>{r.ra("GatherElements",l,{axis:Number(f)})},919419:(l,f,g,C,_,D,L,ne,Y,Q,ee)=>{r.ra("Resize",l,{antialias:f,axes:g?Array.from(P.subarray(C>>>0,C+g>>>0)):[],coordinateTransformMode:je(_),cubicCoeffA:D,excludeOutside:L,extrapolationValue:ne,keepAspectRatioPolicy:je(Y),mode:je(Q),nearestMode:je(ee)})},919770:(l,f,g,C,_,D,L)=>{r.ra("Slice",l,{starts:f?Array.from(P.subarray(g>>>0,g+f>>>0)):[],ends:C?Array.from(P.subarray(_>>>0,_+C>>>0)):[],axes:D?Array.from(P.subarray(L>>>0,L+D>>>0)):[]})},920001:l=>{r.ra("Tile",l,void 0)},920053:(l,f,g)=>{r.ra("LayerNormalization",l,{axis:Number(f),epsilon:Number(g)})},920160:(l,f,g)=>{r.ra("InstanceNormalization",l,{epsilon:f,format:g?"NHWC":"NCHW"})},920274:(l,f,g)=>{r.ra("InstanceNormalization",l,{epsilon:f,format:g?"NHWC":"NCHW"})},920388:l=>{r.ra("Range",l,void 0)},920441:(l,f)=>{r.ra("Einsum",l,{equation:je(f)})},920522:(l,f,g,C,_)=>{r.ra("Pad",l,{mode:f,value:g,pads:C?Array.from(P.subarray(_>>>0,_+C>>>0)):[]})},920654:l=>{r.ra("Gelu",l,void 0)},920706:l=>{r.ra("BiasAdd",l,void 0)},920761:l=>{r.ra("BiasSplitGelu",l,void 0)},920822:(l,f)=>{r.ra("SkipLayerNormalization",l,{epsilon:f})},920903:l=>{r.Ra(l)},920937:(l,f)=>r.Sa(l,f,r.Da.Ta,r.Da.errors),921049:l=>r.Oa(l),921082:l=>r.Qa(l),921114:(l,f,g)=>{r.Ja(l,f,g,!0)},921153:(l,f,g)=>{r.Ja(l,f,g)}};function Qe(l){this.name="ExitStatus",this.message=`Program terminated with exit(${l})`,this.status=l}var Ve=l=>{for(;0<l.length;)l.shift()(r)};function gr(l){this.Ha=l-24,this.Ma=function(f){X[this.Ha+4>>2>>>0]=f},this.La=function(f){X[this.Ha+8>>2>>>0]=f},this.Ya=function(f,g){this.Ka(),this.Ma(f),this.La(g)},this.Ka=function(){X[this.Ha+16>>2>>>0]=0}}var Ut=0,Je=0,Gt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,st=(l,f,g)=>{f>>>=0;var C=f+g;for(g=f;l[g]&&!(g>=C);)++g;if(16<g-f&&l.buffer&&Gt)return Gt.decode(l.subarray(f,g));for(C="";f<g;){var _=l[f++];if(_&128){var D=l[f++]&63;if((_&224)==192)C+=String.fromCharCode((_&31)<<6|D);else{var L=l[f++]&63;_=(_&240)==224?(_&15)<<12|D<<6|L:(_&7)<<18|D<<12|L<<6|l[f++]&63,65536>_?C+=String.fromCharCode(_):(_-=65536,C+=String.fromCharCode(55296|_>>10,56320|_&1023))}}else C+=String.fromCharCode(_)}return C},je=(l,f)=>(l>>>=0)?st(le,l,f):"",Ft=l=>{for(var f=0,g=0;g<l.length;++g){var C=l.charCodeAt(g);127>=C?f++:2047>=C?f+=2:55296<=C&&57343>=C?(f+=4,++g):f+=3}return f},Ot=(l,f,g,C)=>{if(g>>>=0,!(0<C))return 0;var _=g;C=g+C-1;for(var D=0;D<l.length;++D){var L=l.charCodeAt(D);if(55296<=L&&57343>=L){var ne=l.charCodeAt(++D);L=65536+((L&1023)<<10)|ne&1023}if(127>=L){if(g>=C)break;f[g++>>>0]=L}else{if(2047>=L){if(g+1>=C)break;f[g++>>>0]=192|L>>6}else{if(65535>=L){if(g+2>=C)break;f[g++>>>0]=224|L>>12}else{if(g+3>=C)break;f[g++>>>0]=240|L>>18,f[g++>>>0]=128|L>>12&63}f[g++>>>0]=128|L>>6&63}f[g++>>>0]=128|L&63}}return f[g>>>0]=0,g-_},ct=l=>l%4===0&&(l%100!==0||l%400===0),ut=[0,31,60,91,121,152,182,213,244,274,305,335],Tt=[0,31,59,90,120,151,181,212,243,273,304,334],ht=l=>{var f=Ft(l)+1,g=Mt(f);return g&&Ot(l,le,g,f),g},gt=[],Ht=(l,f)=>{gt.length=0;var g;for(f>>=2;g=le[l++>>>0];)f+=g!=105&f,gt.push(g==105?P[f>>>0]:Ce[f++>>>1]),++f;return gt},Rt={},Lt=()=>{if(!kt){var l={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:u||"./this.program"},f;for(f in Rt)Rt[f]===void 0?delete l[f]:l[f]=Rt[f];var g=[];for(f in l)g.push(`${f}=${l[f]}`);kt=g}return kt},kt,Ze=[null,[],[]],Vt=[31,29,31,30,31,30,31,31,30,31,30,31],Pt=[31,28,31,30,31,30,31,31,30,31,30,31];function ae(l){var f=Array(Ft(l)+1);return Ot(l,f,0,f.length),f}function yt(l,f,g,C){function _(E,ie,ye){for(E=typeof E=="number"?E.toString():E||"";E.length<ie;)E=ye[0]+E;return E}function D(E,ie){return _(E,ie,"0")}function L(E,ie){function ye(nr){return 0>nr?-1:0<nr?1:0}var et;return(et=ye(E.getFullYear()-ie.getFullYear()))===0&&(et=ye(E.getMonth()-ie.getMonth()))===0&&(et=ye(E.getDate()-ie.getDate())),et}function ne(E){switch(E.getDay()){case 0:return new Date(E.getFullYear()-1,11,29);case 1:return E;case 2:return new Date(E.getFullYear(),0,3);case 3:return new Date(E.getFullYear(),0,2);case 4:return new Date(E.getFullYear(),0,1);case 5:return new Date(E.getFullYear()-1,11,31);case 6:return new Date(E.getFullYear()-1,11,30)}}function Y(E){var ie=E.Ba;for(E=new Date(new Date(E.Ca+1900,0,1).getTime());0<ie;){var ye=E.getMonth(),et=(ct(E.getFullYear())?Vt:Pt)[ye];if(ie>et-E.getDate())ie-=et-E.getDate()+1,E.setDate(1),11>ye?E.setMonth(ye+1):(E.setMonth(0),E.setFullYear(E.getFullYear()+1));else{E.setDate(E.getDate()+ie);break}}return ye=new Date(E.getFullYear()+1,0,4),ie=ne(new Date(E.getFullYear(),0,4)),ye=ne(ye),0>=L(ie,E)?0>=L(ye,E)?E.getFullYear()+1:E.getFullYear():E.getFullYear()-1}l>>>=0,f>>>=0,g>>>=0,C>>>=0;var Q=P[C+40>>2>>>0];C={Wa:P[C>>2>>>0],Va:P[C+4>>2>>>0],Ea:P[C+8>>2>>>0],Ia:P[C+12>>2>>>0],Fa:P[C+16>>2>>>0],Ca:P[C+20>>2>>>0],wa:P[C+24>>2>>>0],Ba:P[C+28>>2>>>0],$a:P[C+32>>2>>>0],Ua:P[C+36>>2>>>0],Xa:Q?je(Q):""},g=je(g),Q={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ee in Q)g=g.replace(new RegExp(ee,"g"),Q[ee]);var ce="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),pe="January February March April May June July August September October November December".split(" ");Q={"%a":E=>ce[E.wa].substring(0,3),"%A":E=>ce[E.wa],"%b":E=>pe[E.Fa].substring(0,3),"%B":E=>pe[E.Fa],"%C":E=>D((E.Ca+1900)/100|0,2),"%d":E=>D(E.Ia,2),"%e":E=>_(E.Ia,2," "),"%g":E=>Y(E).toString().substring(2),"%G":E=>Y(E),"%H":E=>D(E.Ea,2),"%I":E=>(E=E.Ea,E==0?E=12:12<E&&(E-=12),D(E,2)),"%j":E=>{for(var ie=0,ye=0;ye<=E.Fa-1;ie+=(ct(E.Ca+1900)?Vt:Pt)[ye++]);return D(E.Ia+ie,3)},"%m":E=>D(E.Fa+1,2),"%M":E=>D(E.Va,2),"%n":()=>`
`,"%p":E=>0<=E.Ea&&12>E.Ea?"AM":"PM","%S":E=>D(E.Wa,2),"%t":()=>"	","%u":E=>E.wa||7,"%U":E=>D(Math.floor((E.Ba+7-E.wa)/7),2),"%V":E=>{var ie=Math.floor((E.Ba+7-(E.wa+6)%7)/7);if(2>=(E.wa+371-E.Ba-2)%7&&ie++,ie)ie==53&&(ye=(E.wa+371-E.Ba)%7,ye==4||ye==3&&ct(E.Ca)||(ie=1));else{ie=52;var ye=(E.wa+7-E.Ba-1)%7;(ye==4||ye==5&&ct(E.Ca%400-1))&&ie++}return D(ie,2)},"%w":E=>E.wa,"%W":E=>D(Math.floor((E.Ba+7-(E.wa+6)%7)/7),2),"%y":E=>(E.Ca+1900).toString().substring(2),"%Y":E=>E.Ca+1900,"%z":E=>{E=E.Ua;var ie=0<=E;return E=Math.abs(E)/60,(ie?"+":"-")+("0000"+(E/60*100+E%60)).slice(-4)},"%Z":E=>E.Xa,"%%":()=>"%"},g=g.replace(/%%/g,"\0\0");for(ee in Q)g.includes(ee)&&(g=g.replace(new RegExp(ee,"g"),Q[ee](C)));return g=g.replace(/\0\0/g,"%"),ee=ae(g),ee.length>f?0:(j.set(ee,l>>>0),ee.length-1)}function bt(l){try{l()}catch(f){We(f)}}function dn(l){var f={},g;for(g in l)(function(C){var _=l[C];f[C]=typeof _=="function"?function(){wt.push(C);try{return _.apply(null,arguments)}finally{U||(wt.pop()===C||We(),Le&&qe===1&&wt.length===0&&(qe=0,bt(Dt),typeof Fibers<"u"&&Fibers.ab()))}}:_})(g);return f}var qe=0,Le=null,jt=0,wt=[],qt={},Kt={},Yt=0,Bt=null,yr=[];function br(){return new Promise((l,f)=>{Bt={resolve:l,reject:f}})}function wr(){var l=Mt(65548),f=l+12;X[l>>2>>>0]=f,X[l+4>>2>>>0]=f+65536,f=wt[0];var g=qt[f];return g===void 0&&(g=Yt++,qt[f]=g,Kt[g]=f),P[l+8>>2>>>0]=g,l}function vr(l){if(!U){if(qe===0){var f=!1,g=!1;l((C=0)=>{if(!U&&(jt=C,f=!0,g)){qe=2,bt(()=>vt(Le)),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.resume(),C=!1;try{var _=(0,T[Kt[P[Le+8>>2>>>0]]])()}catch(ne){_=ne,C=!0}var D=!1;if(!Le){var L=Bt;L&&(Bt=null,(C?L.reject:L.resolve)(_),D=!0)}if(C&&!D)throw _}}),g=!0,f||(qe=1,Le=wr(),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.pause(),bt(()=>tr(Le)))}else qe===2?(qe=0,bt(lt),Xt(Le),Le=null,yr.forEach(C=>{if(!U)try{if(C(),!B)try{F=F=C=F,B||(r.onExit&&r.onExit(C),U=!0),n(C,new Qe(C))}catch(_){_ instanceof Qe||_=="unwind"||n(1,_)}}catch(_){_ instanceof Qe||_=="unwind"||n(1,_)}})):We(`invalid state: ${qe}`);return jt}}function $r(l){return vr(f=>{l().then(f)})}var xr={n:function(l,f,g){return $r(async()=>{await r.Pa(l,f,g)})},a:function(l,f,g){throw l>>>=0,new gr(l).Ya(f>>>0,g>>>0),Ut=l,Je++,Ut},g:function(){return 0},J:function(){},z:function(){},B:function(){},L:function(){return 0},H:function(){},C:function(){},G:function(){},l:function(){},A:function(){},x:function(){},I:function(){},y:function(){},m:()=>!0,q:function(l,f,g){l=f+2097152>>>0<4194305-!!l?(l>>>0)+4294967296*f:NaN,g>>>=0,l=new Date(1e3*l),P[g>>2>>>0]=l.getUTCSeconds(),P[g+4>>2>>>0]=l.getUTCMinutes(),P[g+8>>2>>>0]=l.getUTCHours(),P[g+12>>2>>>0]=l.getUTCDate(),P[g+16>>2>>>0]=l.getUTCMonth(),P[g+20>>2>>>0]=l.getUTCFullYear()-1900,P[g+24>>2>>>0]=l.getUTCDay(),P[g+28>>2>>>0]=(l.getTime()-Date.UTC(l.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(l,f,g){l=f+2097152>>>0<4194305-!!l?(l>>>0)+4294967296*f:NaN,g>>>=0,l=new Date(1e3*l),P[g>>2>>>0]=l.getSeconds(),P[g+4>>2>>>0]=l.getMinutes(),P[g+8>>2>>>0]=l.getHours(),P[g+12>>2>>>0]=l.getDate(),P[g+16>>2>>>0]=l.getMonth(),P[g+20>>2>>>0]=l.getFullYear()-1900,P[g+24>>2>>>0]=l.getDay(),P[g+28>>2>>>0]=(ct(l.getFullYear())?ut:Tt)[l.getMonth()]+l.getDate()-1|0,P[g+36>>2>>>0]=-(60*l.getTimezoneOffset()),f=new Date(l.getFullYear(),6,1).getTimezoneOffset();var C=new Date(l.getFullYear(),0,1).getTimezoneOffset();P[g+32>>2>>>0]=(f!=C&&l.getTimezoneOffset()==Math.min(C,f))|0},s:function(l){l>>>=0;var f=new Date(P[l+20>>2>>>0]+1900,P[l+16>>2>>>0],P[l+12>>2>>>0],P[l+8>>2>>>0],P[l+4>>2>>>0],P[l>>2>>>0],0),g=P[l+32>>2>>>0],C=f.getTimezoneOffset(),_=new Date(f.getFullYear(),6,1).getTimezoneOffset(),D=new Date(f.getFullYear(),0,1).getTimezoneOffset(),L=Math.min(D,_);return 0>g?P[l+32>>2>>>0]=+(_!=D&&L==C):0<g!=(L==C)&&(_=Math.max(D,_),f.setTime(f.getTime()+6e4*((0<g?L:_)-C))),P[l+24>>2>>>0]=f.getDay(),P[l+28>>2>>>0]=(ct(f.getFullYear())?ut:Tt)[f.getMonth()]+f.getDate()-1|0,P[l>>2>>>0]=f.getSeconds(),P[l+4>>2>>>0]=f.getMinutes(),P[l+8>>2>>>0]=f.getHours(),P[l+12>>2>>>0]=f.getDate(),P[l+16>>2>>>0]=f.getMonth(),P[l+20>>2>>>0]=f.getYear(),l=f.getTime()/1e3,Qt((Ie=l,1<=+Math.abs(Ie)?0<Ie?+Math.floor(Ie/4294967296)>>>0:~~+Math.ceil((Ie-+(~~Ie>>>0))/4294967296)>>>0:0)),l>>>0},o:function(){return-52},p:function(){},v:function(l,f,g){function C(Y){return(Y=Y.toTimeString().match(/\(([A-Za-z ]+)\)$/))?Y[1]:"GMT"}g>>>=0;var _=new Date().getFullYear(),D=new Date(_,0,1),L=new Date(_,6,1);_=D.getTimezoneOffset();var ne=L.getTimezoneOffset();X[l>>>0>>2>>>0]=60*Math.max(_,ne),P[f>>>0>>2>>>0]=+(_!=ne),l=C(D),f=C(L),l=ht(l),f=ht(f),ne<_?(X[g>>2>>>0]=l,X[g+4>>2>>>0]=f):(X[g>>2>>>0]=f,X[g+4>>2>>>0]=l)},e:()=>{We("")},b:function(l,f,g){return l>>>=0,f=Ht(f>>>0,g>>>0),Fe[l].apply(null,f)},i:function(l,f,g){return l>>>=0,f=Ht(f>>>0,g>>>0),Fe[l].apply(null,f)},h:function(){return Date.now()},w:function(){return 4294901760},c:()=>performance.now(),K:function(l,f,g){return f>>>=0,le.copyWithin(l>>>0>>>0,f>>>0,f+(g>>>0)>>>0)},u:function(l){l>>>=0;var f=le.length;if(4294901760<l)return!1;for(var g=1;4>=g;g*=2){var C=f*(1+.2/g);C=Math.min(C,l+100663296);var _=Math;C=Math.max(l,C);e:{_=_.min.call(_,4294901760,C+(65536-C%65536)%65536)-W.buffer.byteLength+65535>>>16;try{W.grow(_),K();var D=1;break e}catch{}D=void 0}if(D)return!0}return!1},D:function(l,f){l>>>=0,f>>>=0;var g=0;return Lt().forEach(function(C,_){var D=f+g;for(_=X[l+4*_>>2>>>0]=D,D=0;D<C.length;++D)j[_++>>0>>>0]=C.charCodeAt(D);j[_>>0>>>0]=0,g+=C.length+1}),0},E:function(l,f){l>>>=0,f>>>=0;var g=Lt();X[l>>2>>>0]=g.length;var C=0;return g.forEach(function(_){C+=_.length+1}),X[f>>2>>>0]=C,0},f:()=>52,k:function(){return 52},t:function(){return 70},j:function(l,f,g,C){f>>>=0,g>>>=0,C>>>=0;for(var _=0,D=0;D<g;D++){var L=X[f>>2>>>0],ne=X[f+4>>2>>>0];f+=8;for(var Y=0;Y<ne;Y++){var Q=le[L+Y>>>0],ee=Ze[l];Q===0||Q===10?((l===1?I:R)(st(ee,0)),ee.length=0):ee.push(Q)}_+=ne}return X[C>>2>>>0]=_,0},F:yt,d:function(l,f,g,C){return yt(l>>>0,f>>>0,g>>>0,C>>>0)}};(function(){function l(g){if(g=g.exports,g=dn(g),T=g=Sr(g),W=T.M,K(),ze.unshift(T.N),we--,r.monitorRunDependencies&&r.monitorRunDependencies(we),we==0&&(Be!==null&&(clearInterval(Be),Be=null),Xe)){var C=Xe;Xe=null,C()}return g}var f={a:xr};if(we++,r.monitorRunDependencies&&r.monitorRunDependencies(we),r.instantiateWasm)try{return r.instantiateWasm(f,l)}catch(g){R("Module.instantiateWasm callback failed with error: "+g),a(g)}return Ee(f,function(g){l(g.instance)}).catch(a),{}})(),r._OrtInit=(l,f)=>(r._OrtInit=T.O)(l,f),r._OrtGetLastError=(l,f)=>(r._OrtGetLastError=T.P)(l,f),r._OrtCreateSessionOptions=(l,f,g,C,_,D,L,ne,Y,Q)=>(r._OrtCreateSessionOptions=T.Q)(l,f,g,C,_,D,L,ne,Y,Q),r._OrtAppendExecutionProvider=(l,f)=>(r._OrtAppendExecutionProvider=T.R)(l,f),r._OrtAddFreeDimensionOverride=(l,f,g)=>(r._OrtAddFreeDimensionOverride=T.S)(l,f,g),r._OrtAddSessionConfigEntry=(l,f,g)=>(r._OrtAddSessionConfigEntry=T.T)(l,f,g),r._OrtReleaseSessionOptions=l=>(r._OrtReleaseSessionOptions=T.U)(l),r._OrtCreateSession=(l,f,g)=>(r._OrtCreateSession=T.V)(l,f,g),r._OrtReleaseSession=l=>(r._OrtReleaseSession=T.W)(l),r._OrtGetInputOutputCount=(l,f,g)=>(r._OrtGetInputOutputCount=T.X)(l,f,g),r._OrtGetInputName=(l,f)=>(r._OrtGetInputName=T.Y)(l,f),r._OrtGetOutputName=(l,f)=>(r._OrtGetOutputName=T.Z)(l,f),r._OrtFree=l=>(r._OrtFree=T._)(l),r._OrtCreateTensor=(l,f,g,C,_,D)=>(r._OrtCreateTensor=T.$)(l,f,g,C,_,D),r._OrtGetTensorData=(l,f,g,C,_)=>(r._OrtGetTensorData=T.aa)(l,f,g,C,_),r._OrtReleaseTensor=l=>(r._OrtReleaseTensor=T.ba)(l),r._OrtCreateRunOptions=(l,f,g,C)=>(r._OrtCreateRunOptions=T.ca)(l,f,g,C),r._OrtAddRunConfigEntry=(l,f,g)=>(r._OrtAddRunConfigEntry=T.da)(l,f,g),r._OrtReleaseRunOptions=l=>(r._OrtReleaseRunOptions=T.ea)(l),r._OrtCreateBinding=l=>(r._OrtCreateBinding=T.fa)(l),r._OrtBindInput=(l,f,g)=>(r._OrtBindInput=T.ga)(l,f,g),r._OrtBindOutput=(l,f,g,C)=>(r._OrtBindOutput=T.ha)(l,f,g,C),r._OrtClearBoundOutputs=l=>(r._OrtClearBoundOutputs=T.ia)(l),r._OrtReleaseBinding=l=>(r._OrtReleaseBinding=T.ja)(l),r._OrtRunWithBinding=(l,f,g,C,_)=>(r._OrtRunWithBinding=T.ka)(l,f,g,C,_),r._OrtRun=(l,f,g,C,_,D,L,ne)=>(r._OrtRun=T.la)(l,f,g,C,_,D,L,ne),r._OrtEndProfiling=l=>(r._OrtEndProfiling=T.ma)(l),r._JsepOutput=(l,f,g)=>(r._JsepOutput=T.na)(l,f,g),r._JsepGetNodeName=l=>(r._JsepGetNodeName=T.oa)(l);var Mt=r._malloc=l=>(Mt=r._malloc=T.pa)(l),Xt=r._free=l=>(Xt=r._free=T.qa)(l),Qt=l=>(Qt=T.sa)(l),Jt=()=>(Jt=T.ta)(),Zt=l=>(Zt=T.ua)(l),er=l=>(er=T.va)(l),tr=l=>(tr=T.xa)(l),Dt=()=>(Dt=T.ya)(),vt=l=>(vt=T.za)(l),lt=()=>(lt=T.Aa)();r.___start_em_js=921186,r.___stop_em_js=921347;function Sr(l){l=Object.assign({},l);var f=C=>()=>C()>>>0,g=C=>_=>C(_)>>>0;return l.__errno_location=f(l.__errno_location),l.malloc=g(l.malloc),l.stackSave=f(l.stackSave),l.stackAlloc=g(l.stackAlloc),l}r.stackAlloc=er,r.stackSave=Jt,r.stackRestore=Zt,r.UTF8ToString=je,r.stringToUTF8=(l,f,g)=>Ot(l,le,f,g),r.lengthBytesUTF8=Ft;var $t;Xe=function l(){$t||rr(),$t||(Xe=l)};function rr(){function l(){if(!$t&&($t=!0,r.calledRun=!0,!U)){if(Ve(ze),o(r),r.onRuntimeInitialized&&r.onRuntimeInitialized(),r.postRun)for(typeof r.postRun=="function"&&(r.postRun=[r.postRun]);r.postRun.length;){var f=r.postRun.shift();he.unshift(f)}Ve(he)}}if(!(0<we)){if(r.preRun)for(typeof r.preRun=="function"&&(r.preRun=[r.preRun]);r.preRun.length;)Pe();Ve(V),0<we||(r.setStatus?(r.setStatus("Running..."),setTimeout(function(){setTimeout(function(){r.setStatus("")},1),l()},1)):l())}}if(r.preInit)for(typeof r.preInit=="function"&&(r.preInit=[r.preInit]);0<r.preInit.length;)r.preInit.pop()();return rr(),t.ready}})();typeof ao=="object"&&typeof An=="object"?An.exports=no:typeof define=="function"&&define.amd&&define([],()=>no)});var io=zt(()=>{});var so=zt(()=>{});var uo={};ar(uo,{cpus:()=>fl});var fl,lo=H(()=>{fl=void 0});var fo=zt((po,_n)=>{"use strict";var co=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){function r(){return K.buffer!=we.buffer&&G(),we}function o(){return K.buffer!=we.buffer&&G(),Be}function a(){return K.buffer!=we.buffer&&G(),Xe}function s(){return K.buffer!=we.buffer&&G(),We}function u(){return K.buffer!=we.buffer&&G(),it}var n=t,d,p;n.ready=new Promise((i,c)=>{d=i,p=c}),n.jsepInit=(i,c,m,S,A,k,N,te)=>{n.Qb=i,n.wb=c,n.yb=m,n.jb=S,n.xb=A,n.Ea=k,n.zb=N,n.Ab=te,c=(Z,J,re)=>(...fe)=>{let be=tt,O=J?.();fe=Z(...fe);let ue=J?.();return O!==ue&&(Z=ue,re(O),J=re=null),tt!=be?Zu():fe},m=Z=>async(...J)=>{try{if(n.bb)throw Error("Session already started");let re=n.bb={Fb:J[0],errors:[]},fe=await Z(...J);if(n.bb!==re)throw Error("Session mismatch");i.flush();let be=re.errors;if(0<be.length){let O=await Promise.all(be);if(O=O.filter(ue=>ue),0<O.length)throw Error(O.join(`
`))}return fe}finally{n.bb=null}},n._OrtRun=m(c(n._OrtRun,()=>n._OrtRun,Z=>n._OrtRun=Z)),n._OrtRunWithBinding=m(c(n._OrtRunWithBinding,()=>n._OrtRunWithBinding,Z=>n._OrtRunWithBinding=Z)),n._OrtBindInput=c(n._OrtBindInput,()=>n._OrtBindInput,Z=>n._OrtBindInput=Z),n.jsepRegisterBuffer=(Z,J,re,fe)=>i.registerBuffer(Z,J,re,fe),n.jsepUnregisterBuffers=Z=>{i.unregisterBuffers(Z)},n.jsepGetBuffer=Z=>i.getBuffer(Z),n.jsepCreateDownloader=(Z,J,re)=>i.createDownloader(Z,J,re)};var h=Object.assign({},n),y="./this.program",b=(i,c)=>{throw c},w=typeof window=="object",$=typeof importScripts=="function",v=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",x=n.ENVIRONMENT_IS_PTHREAD||!1,I="";function R(i){return n.locateFile?n.locateFile(i,I):I+i}var M,B,W;if(v){var T=(Sn(),St(xn)),U=(In(),St(Cn));I=$?U.dirname(I)+"/":__dirname+"/",M=(c,m)=>(c=c.startsWith("file://")?new URL(c):U.normalize(c),T.readFileSync(c,m?void 0:"utf8")),W=c=>(c=M(c,!0),c.buffer||(c=new Uint8Array(c)),c),B=(c,m,S,A=!0)=>{c=c.startsWith("file://")?new URL(c):U.normalize(c),T.readFile(c,A?void 0:"utf8",(k,N)=>{k?S(k):m(A?N.buffer:N)})},!n.thisProgram&&1<process.argv.length&&(y=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),b=(c,m)=>{throw process.exitCode=c,m},n.inspect=()=>"[Emscripten Module object]";let i;try{i=io()}catch(c){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),c}global.Worker=i.Worker}else(w||$)&&($?I=self.location.href:typeof document<"u"&&document.currentScript&&(I=document.currentScript.src),typeof e<"u"&&e&&(I=e),I.indexOf("blob:")!==0?I=I.substr(0,I.replace(/[?#].*/,"").lastIndexOf("/")+1):I="",v||(M=i=>{var c=new XMLHttpRequest;return c.open("GET",i,!1),c.send(null),c.responseText},$&&(W=i=>{var c=new XMLHttpRequest;return c.open("GET",i,!1),c.responseType="arraybuffer",c.send(null),new Uint8Array(c.response)}),B=(i,c,m)=>{var S=new XMLHttpRequest;S.open("GET",i,!0),S.responseType="arraybuffer",S.onload=()=>{S.status==200||S.status==0&&S.response?c(S.response):m()},S.onerror=m,S.send(null)}));v&&typeof performance>"u"&&(global.performance=so().performance);var F=console.log.bind(console),j=console.error.bind(console);v&&(F=(...i)=>T.writeSync(1,i.join(" ")+`
`),j=(...i)=>T.writeSync(2,i.join(" ")+`
`));var le=n.print||F,P=n.printErr||j;Object.assign(n,h),h=null,n.thisProgram&&(y=n.thisProgram),n.quit&&(b=n.quit);var X;n.wasmBinary&&(X=n.wasmBinary);var Ce=n.noExitRuntime||!0;typeof WebAssembly!="object"&&Je("no native wasm support detected");var K,V,ze,he=!1,Pe,we,Be,Xe,We,it;function G(){var i=K.buffer;n.HEAP8=we=new Int8Array(i),n.HEAP16=new Int16Array(i),n.HEAP32=Xe=new Int32Array(i),n.HEAPU8=Be=new Uint8Array(i),n.HEAPU16=new Uint16Array(i),n.HEAPU32=We=new Uint32Array(i),n.HEAPF32=new Float32Array(i),n.HEAPF64=it=new Float64Array(i)}var de=n.INITIAL_MEMORY||16777216;if(5242880<=de||Je("INITIAL_MEMORY should be larger than STACK_SIZE, was "+de+"! (STACK_SIZE=5242880)"),x)K=n.wasmMemory;else if(n.wasmMemory)K=n.wasmMemory;else if(K=new WebAssembly.Memory({initial:de/65536,maximum:65536,shared:!0}),!(K.buffer instanceof SharedArrayBuffer))throw P("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),v&&P("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");G(),de=K.buffer.byteLength;var ge=[],Ne=[],Ge=[],Ee=0;function Ie(){return Ce||0<Ee}var Fe=0,Qe=null,Ve=null;function gr(){Fe++,n.monitorRunDependencies&&n.monitorRunDependencies(Fe)}function Ut(){if(Fe--,n.monitorRunDependencies&&n.monitorRunDependencies(Fe),Fe==0&&(Qe!==null&&(clearInterval(Qe),Qe=null),Ve)){var i=Ve;Ve=null,i()}}function Je(i){throw n.onAbort&&n.onAbort(i),i="Aborted("+i+")",P(i),he=!0,Pe=1,i=new WebAssembly.RuntimeError(i+". Build with -sASSERTIONS for more info."),p(i),i}function Gt(i){return i.startsWith("data:application/octet-stream;base64,")}var st;st="ort-wasm-simd-threaded.wasm",Gt(st)||(st=R(st));function je(i){if(i==st&&X)return new Uint8Array(X);if(W)return W(i);throw"both async and sync fetching of the wasm failed"}function Ft(i){if(!X&&(w||$)){if(typeof fetch=="function"&&!i.startsWith("file://"))return fetch(i,{credentials:"same-origin"}).then(c=>{if(!c.ok)throw"failed to load wasm binary file at '"+i+"'";return c.arrayBuffer()}).catch(()=>je(i));if(B)return new Promise((c,m)=>{B(i,S=>c(new Uint8Array(S)),m)})}return Promise.resolve().then(()=>je(i))}function Ot(i,c,m){return Ft(i).then(S=>WebAssembly.instantiate(S,c)).then(S=>S).then(m,S=>{P("failed to asynchronously prepare wasm: "+S),Je(S)})}function ct(i,c){var m=st;return X||typeof WebAssembly.instantiateStreaming!="function"||Gt(m)||m.startsWith("file://")||v||typeof fetch!="function"?Ot(m,i,c):fetch(m,{credentials:"same-origin"}).then(S=>WebAssembly.instantiateStreaming(S,i).then(c,function(A){return P("wasm streaming compile failed: "+A),P("falling back to ArrayBuffer instantiation"),Ot(m,i,c)}))}var ut,Tt={911532:i=>{n.Ea("Abs",i,void 0)},911583:i=>{n.Ea("Neg",i,void 0)},911634:i=>{n.Ea("Floor",i,void 0)},911687:i=>{n.Ea("Ceil",i,void 0)},911739:i=>{n.Ea("Reciprocal",i,void 0)},911797:i=>{n.Ea("Sqrt",i,void 0)},911849:i=>{n.Ea("Exp",i,void 0)},911900:i=>{n.Ea("Erf",i,void 0)},911951:i=>{n.Ea("Sigmoid",i,void 0)},912006:i=>{n.Ea("Log",i,void 0)},912057:i=>{n.Ea("Sin",i,void 0)},912108:i=>{n.Ea("Cos",i,void 0)},912159:i=>{n.Ea("Tan",i,void 0)},912210:i=>{n.Ea("Asin",i,void 0)},912262:i=>{n.Ea("Acos",i,void 0)},912314:i=>{n.Ea("Atan",i,void 0)},912366:i=>{n.Ea("Sinh",i,void 0)},912418:i=>{n.Ea("Cosh",i,void 0)},912470:i=>{n.Ea("Asinh",i,void 0)},912523:i=>{n.Ea("Acosh",i,void 0)},912576:i=>{n.Ea("Atanh",i,void 0)},912629:i=>{n.Ea("Tanh",i,void 0)},912681:i=>{n.Ea("Not",i,void 0)},912732:(i,c,m)=>{n.Ea("ClipV10",i,{min:c,max:m})},912804:i=>{n.Ea("Clip",i,void 0)},912856:(i,c)=>{n.Ea("Elu",i,{alpha:c})},912914:i=>{n.Ea("Relu",i,void 0)},912966:(i,c)=>{n.Ea("LeakyRelu",i,{alpha:c})},913030:(i,c)=>{n.Ea("ThresholdedRelu",i,{alpha:c})},913100:(i,c)=>{n.Ea("Cast",i,{to:c})},913158:i=>{n.Ea("Add",i,void 0)},913209:i=>{n.Ea("Sub",i,void 0)},913260:i=>{n.Ea("Mul",i,void 0)},913311:i=>{n.Ea("Div",i,void 0)},913362:i=>{n.Ea("Pow",i,void 0)},913413:i=>{n.Ea("Equal",i,void 0)},913466:i=>{n.Ea("Greater",i,void 0)},913521:i=>{n.Ea("GreaterOrEqual",i,void 0)},913583:i=>{n.Ea("Less",i,void 0)},913635:i=>{n.Ea("LessOrEqual",i,void 0)},913694:(i,c,m,S,A)=>{n.Ea("ReduceMean",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:S?Array.from(a().subarray(A>>>0,A+S>>>0)):[]})},913858:(i,c,m,S,A)=>{n.Ea("ReduceMax",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:S?Array.from(a().subarray(A>>>0,A+S>>>0)):[]})},914021:(i,c,m,S,A)=>{n.Ea("ReduceMin",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:S?Array.from(a().subarray(A>>>0,A+S>>>0)):[]})},914184:(i,c,m,S,A)=>{n.Ea("ReduceProd",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:S?Array.from(a().subarray(A>>>0,A+S>>>0)):[]})},914348:(i,c,m,S,A)=>{n.Ea("ReduceSum",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:S?Array.from(a().subarray(A>>>0,A+S>>>0)):[]})},914511:(i,c,m,S,A)=>{n.Ea("ReduceL1",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:S?Array.from(a().subarray(A>>>0,A+S>>>0)):[]})},914673:(i,c,m,S,A)=>{n.Ea("ReduceL2",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:S?Array.from(a().subarray(A>>>0,A+S>>>0)):[]})},914835:(i,c,m,S,A)=>{n.Ea("ReduceLogSum",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:S?Array.from(a().subarray(A>>>0,A+S>>>0)):[]})},915001:(i,c,m,S,A)=>{n.Ea("ReduceSumSquare",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:S?Array.from(a().subarray(A>>>0,A+S>>>0)):[]})},915170:(i,c,m,S,A)=>{n.Ea("ReduceLogSumExp",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:S?Array.from(a().subarray(A>>>0,A+S>>>0)):[]})},915339:i=>{n.Ea("Where",i,void 0)},915392:(i,c,m)=>{n.Ea("Transpose",i,{perm:c?Array.from(a().subarray(m>>>0,m+c>>>0)):[]})},915505:(i,c,m,S,A,k,N,te,Z,J)=>{n.Ea("Conv",i,{format:Z?"NHWC":"NCHW",auto_pad:c,dilations:[m],group:S,kernel_shape:[A],pads:[k,N],strides:[te],w_is_const:()=>!!r()[J>>>0]})},915733:(i,c,m,S,A,k,N,te,Z,J,re,fe,be,O,ue)=>{n.Ea("Conv",i,{format:O?"NHWC":"NCHW",auto_pad:c,dilations:[m,S],group:A,kernel_shape:[k,N],pads:[te,Z,J,re],strides:[fe,be],w_is_const:()=>!!r()[ue>>>0]})},915992:(i,c,m,S,A,k,N,te,Z,J)=>{n.Ea("Conv",i,{format:Z?"NHWC":"NCHW",auto_pad:c,dilations:[m],group:S,kernel_shape:[A],pads:[k,N],strides:[te],w_is_const:()=>!!r()[J>>>0]})},916220:(i,c,m,S,A,k,N,te,Z,J,re,fe,be,O,ue)=>{n.Ea("Conv",i,{format:O?"NHWC":"NCHW",auto_pad:c,dilations:[m,S],group:A,kernel_shape:[k,N],pads:[te,Z,J,re],strides:[fe,be],w_is_const:()=>!!r()[ue>>>0]})},916479:(i,c,m,S,A,k,N,te,Z,J,re,fe,be,O)=>{n.Ea("ConvTranspose",i,{format:Z?"NHWC":"NCHW",autoPad:c,dilations:[m],group:S,kernel_shape:[A],pads:[k,N],strides:[te],wIsConst:()=>!!r()[J>>>0],outputPadding:re?Array.from(a().subarray(fe>>>0,fe+re>>>0)):[],outputShape:be?Array.from(a().subarray(O>>>0,O+be>>>0)):[]})},916859:(i,c,m,S,A,k,N,te,Z,J,re,fe,be)=>{n.Ea("ConvTranspose",i,{format:te?"NHWC":"NCHW",autoPad:c,dilations:Array.from(a().subarray(m>>>0,m+2>>>0)),group:S,kernelShape:Array.from(a().subarray(A>>>0,A+2>>>0)),pads:Array.from(a().subarray(k>>>0,k+4>>>0)),strides:Array.from(a().subarray(N>>>0,N+2>>>0)),wIsConst:()=>!!r()[Z>>>0],outputPadding:0<J?Array.from(a().subarray(re>>>0,re+J>>>0)):[],outputShape:0<fe?Array.from(a().subarray(be>>>0,be+fe>>>0)):[]})},917382:(i,c,m,S,A,k,N,te,Z,J,re,fe,be,O)=>{n.Ea("ConvTranspose",i,{format:Z?"NHWC":"NCHW",autoPad:c,dilations:[m],group:S,kernel_shape:[A],pads:[k,N],strides:[te],wIsConst:()=>!!r()[J>>>0],outputPadding:re?Array.from(a().subarray(fe>>>0,fe+re>>>0)):[],outputShape:be?Array.from(a().subarray(O>>>0,O+be>>>0)):[]})},917762:(i,c,m,S,A,k,N,te,Z,J,re,fe,be)=>{n.Ea("ConvTranspose",i,{format:te?"NHWC":"NCHW",autoPad:c,dilations:Array.from(a().subarray(m>>>0,m+2>>>0)),group:S,kernelShape:Array.from(a().subarray(A>>>0,A+2>>>0)),pads:Array.from(a().subarray(k>>>0,k+4>>>0)),strides:Array.from(a().subarray(N>>>0,N+2>>>0)),wIsConst:()=>!!r()[Z>>>0],outputPadding:0<J?Array.from(a().subarray(re>>>0,re+J>>>0)):[],outputShape:0<fe?Array.from(a().subarray(be>>>0,be+fe>>>0)):[]})},918285:(i,c)=>{n.Ea("GlobalAveragePool",i,{format:c?"NHWC":"NCHW"})},918376:(i,c,m,S,A,k,N,te,Z,J,re,fe,be,O,ue,ve)=>{n.Ea("AveragePool",i,{format:ve?"NHWC":"NCHW",auto_pad:c,ceil_mode:m,count_include_pad:S,storage_order:A,dilations:[k,N],kernel_shape:[te,Z],pads:[J,re,fe,be],strides:[O,ue]})},918660:(i,c)=>{n.Ea("GlobalAveragePool",i,{format:c?"NHWC":"NCHW"})},918751:(i,c,m,S,A,k,N,te,Z,J,re,fe,be,O,ue,ve)=>{n.Ea("AveragePool",i,{format:ve?"NHWC":"NCHW",auto_pad:c,ceil_mode:m,count_include_pad:S,storage_order:A,dilations:[k,N],kernel_shape:[te,Z],pads:[J,re,fe,be],strides:[O,ue]})},919035:(i,c)=>{n.Ea("GlobalMaxPool",i,{format:c?"NHWC":"NCHW"})},919122:(i,c,m,S,A,k,N,te,Z,J,re,fe,be,O,ue,ve)=>{n.Ea("MaxPool",i,{format:ve?"NHWC":"NCHW",auto_pad:c,ceil_mode:m,count_include_pad:S,storage_order:A,dilations:[k,N],kernel_shape:[te,Z],pads:[J,re,fe,be],strides:[O,ue]})},919402:(i,c)=>{n.Ea("GlobalMaxPool",i,{format:c?"NHWC":"NCHW"})},919489:(i,c,m,S,A,k,N,te,Z,J,re,fe,be,O,ue,ve)=>{n.Ea("MaxPool",i,{format:ve?"NHWC":"NCHW",auto_pad:c,ceil_mode:m,count_include_pad:S,storage_order:A,dilations:[k,N],kernel_shape:[te,Z],pads:[J,re,fe,be],strides:[O,ue]})},919769:(i,c,m,S,A)=>{n.Ea("Gemm",i,{alpha:c,beta:m,transA:S,transB:A})},919873:i=>{n.Ea("MatMul",i,void 0)},919927:(i,c,m,S)=>{n.Ea("ArgMax",i,{keepDims:!!c,selectLastIndex:!!m,axis:S})},920035:(i,c,m,S)=>{n.Ea("ArgMin",i,{keepDims:!!c,selectLastIndex:!!m,axis:S})},920143:(i,c)=>{n.Ea("Softmax",i,{axis:c})},920206:(i,c)=>{n.Ea("Concat",i,{axis:c})},920266:(i,c,m,S,A)=>{n.Ea("Split",i,{axis:c,numOutputs:m,splitSizes:S?Array.from(a().subarray(A>>>0,A+S>>>0)):[]})},920411:i=>{n.Ea("Expand",i,void 0)},920465:(i,c)=>{n.Ea("Gather",i,{axis:Number(c)})},920536:(i,c)=>{n.Ea("GatherElements",i,{axis:Number(c)})},920615:(i,c,m,S,A,k,N,te,Z,J,re)=>{n.Ea("Resize",i,{antialias:c,axes:m?Array.from(a().subarray(S>>>0,S+m>>>0)):[],coordinateTransformMode:Ze(A),cubicCoeffA:k,excludeOutside:N,extrapolationValue:te,keepAspectRatioPolicy:Ze(Z),mode:Ze(J),nearestMode:Ze(re)})},920966:(i,c,m,S,A,k,N)=>{n.Ea("Slice",i,{starts:c?Array.from(a().subarray(m>>>0,m+c>>>0)):[],ends:S?Array.from(a().subarray(A>>>0,A+S>>>0)):[],axes:k?Array.from(a().subarray(N>>>0,N+k>>>0)):[]})},921197:i=>{n.Ea("Tile",i,void 0)},921249:(i,c,m)=>{n.Ea("LayerNormalization",i,{axis:Number(c),epsilon:Number(m)})},921356:(i,c,m)=>{n.Ea("InstanceNormalization",i,{epsilon:c,format:m?"NHWC":"NCHW"})},921470:(i,c,m)=>{n.Ea("InstanceNormalization",i,{epsilon:c,format:m?"NHWC":"NCHW"})},921584:i=>{n.Ea("Range",i,void 0)},921637:(i,c)=>{n.Ea("Einsum",i,{equation:Ze(c)})},921718:(i,c,m,S,A)=>{n.Ea("Pad",i,{mode:c,value:m,pads:S?Array.from(a().subarray(A>>>0,A+S>>>0)):[]})},921850:i=>{n.Ea("Gelu",i,void 0)},921902:i=>{n.Ea("BiasAdd",i,void 0)},921957:i=>{n.Ea("BiasSplitGelu",i,void 0)},922018:(i,c)=>{n.Ea("SkipLayerNormalization",i,{epsilon:c})},922099:i=>{n.zb(i)},922133:(i,c)=>n.Ab(i,c,n.bb.Fb,n.bb.errors),922245:i=>n.wb(i),922278:i=>n.yb(i),922310:(i,c,m)=>{n.jb(i,c,m,!0)},922349:(i,c,m)=>{n.jb(i,c,m)}};function ht(i){this.name="ExitStatus",this.message=`Program terminated with exit(${i})`,this.status=i}function gt(i){i.terminate(),i.onmessage=()=>{}}function Ht(i){(i=ae.Qa[i])||Je(),ae.Eb(i)}function Rt(i){var c=ae.tb();if(!c)return 6;ae.Ya.push(c),ae.Qa[i.Xa]=c,c.Xa=i.Xa;var m={cmd:"run",start_routine:i.Gb,arg:i.rb,pthread_ptr:i.Xa};return v&&c.unref(),c.postMessage(m,i.Mb),0}var Lt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,kt=(i,c,m)=>{c>>>=0;var S=c+m;for(m=c;i[m]&&!(m>=S);)++m;if(16<m-c&&i.buffer&&Lt)return Lt.decode(i.buffer instanceof SharedArrayBuffer?i.slice(c,m):i.subarray(c,m));for(S="";c<m;){var A=i[c++];if(A&128){var k=i[c++]&63;if((A&224)==192)S+=String.fromCharCode((A&31)<<6|k);else{var N=i[c++]&63;A=(A&240)==224?(A&15)<<12|k<<6|N:(A&7)<<18|k<<12|N<<6|i[c++]&63,65536>A?S+=String.fromCharCode(A):(A-=65536,S+=String.fromCharCode(55296|A>>10,56320|A&1023))}}else S+=String.fromCharCode(A)}return S},Ze=(i,c)=>(i>>>=0)?kt(o(),i,c):"";function Vt(i){if(x)return D(1,1,i);Pe=i,Ie()||(ae.Hb(),n.onExit&&n.onExit(i),he=!0),b(i,new ht(i))}var Pt=i=>{if(Pe=i,x)throw bt(i),"unwind";Vt(i)},ae={ab:[],Ya:[],mb:[],Qa:{},gb:function(){x?ae.vb():ae.ub()},ub:function(){ge.unshift(()=>{gr(),ae.Bb(()=>Ut())})},vb:function(){ae.receiveObjectTransfer=ae.Db,ae.threadInitTLS=ae.lb,ae.setExitStatus=ae.kb,Ce=!1},kb:function(i){Pe=i},Sb:["$terminateWorker"],Hb:function(){for(var i of ae.Ya)gt(i);for(i of ae.ab)gt(i);ae.ab=[],ae.Ya=[],ae.Qa=[]},Eb:function(i){var c=i.Xa;delete ae.Qa[c],ae.ab.push(i),ae.Ya.splice(ae.Ya.indexOf(i),1),i.Xa=0,fn(c)},Db:function(){},lb:function(){ae.mb.forEach(i=>i())},Cb:i=>new Promise(c=>{i.onmessage=k=>{k=k.data;var N=k.cmd;if(k.targetThread&&k.targetThread!=Ar()){var te=ae.Qa[k.Rb];te?te.postMessage(k,k.transferList):P('Internal error! Worker sent a message "'+N+'" to target pthread '+k.targetThread+", but that thread no longer exists!")}else N==="checkMailbox"?vt():N==="spawnThread"?Rt(k):N==="cleanupThread"?Ht(k.thread):N==="killThread"?(k=k.thread,N=ae.Qa[k],delete ae.Qa[k],gt(N),fn(k),ae.Ya.splice(ae.Ya.indexOf(N),1),N.Xa=0):N==="cancelThread"?ae.Qa[k.thread].postMessage({cmd:"cancel"}):N==="loaded"?(i.loaded=!0,c(i)):N==="alert"?alert("Thread "+k.threadId+": "+k.text):k.target==="setimmediate"?i.postMessage(k):N==="callHandler"?n[k.handler](...k.args):N&&P("worker sent an unknown command "+N)},i.onerror=k=>{throw P("worker sent an error! "+k.filename+":"+k.lineno+": "+k.message),k},v&&(i.on("message",function(k){i.onmessage({data:k})}),i.on("error",function(k){i.onerror(k)}));var m=[],S=["onExit","onAbort","print","printErr"],A;for(A of S)n.hasOwnProperty(A)&&m.push(A);i.postMessage({cmd:"load",handlers:m,urlOrBlob:n.mainScriptUrlOrBlob||e,wasmMemory:K,wasmModule:ze})}),Bb:function(i){i()},qb:function(){var i=R("ort-wasm-simd-threaded.worker.js");i=new Worker(i),ae.ab.push(i)},tb:function(){return ae.ab.length==0&&(ae.qb(),ae.Cb(ae.ab[0])),ae.ab.pop()}};n.PThread=ae;var yt=i=>{for(;0<i.length;)i.shift()(n)};n.establishStackSpace=function(){var i=Ar(),c=a()[i+52>>2>>>0];i=a()[i+56>>2>>>0],xa(c,c-i),_r(c)};function bt(i){if(x)return D(2,0,i);Pt(i)}n.invokeEntryPoint=function(i,c){i=Sa.apply(null,[i,c]),Ie()?ae.kb(i):mn(i)};function dn(i){this.fb=i-24,this.pb=function(c){s()[this.fb+4>>2>>>0]=c},this.ob=function(c){s()[this.fb+8>>2>>>0]=c},this.gb=function(c,m){this.nb(),this.pb(c),this.ob(m)},this.nb=function(){s()[this.fb+16>>2>>>0]=0}}var qe=0,Le=0;function jt(i,c,m,S){return x?D(3,1,i,c,m,S):wt(i,c,m,S)}function wt(i,c,m,S){if(i>>>=0,c>>>=0,m>>>=0,S>>>=0,typeof SharedArrayBuffer>"u")return P("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var A=[];return x&&A.length===0?jt(i,c,m,S):(i={Gb:m,Xa:i,rb:S,Mb:A},x?(i.Ob="spawnThread",postMessage(i,A),0):Rt(i))}function qt(i,c,m){return x?D(4,1,i,c,m):0}function Kt(i,c){if(x)return D(5,1,i,c)}var Yt=i=>{for(var c=0,m=0;m<i.length;++m){var S=i.charCodeAt(m);127>=S?c++:2047>=S?c+=2:55296<=S&&57343>=S?(c+=4,++m):c+=3}return c},Bt=(i,c,m,S)=>{if(m>>>=0,!(0<S))return 0;var A=m;S=m+S-1;for(var k=0;k<i.length;++k){var N=i.charCodeAt(k);if(55296<=N&&57343>=N){var te=i.charCodeAt(++k);N=65536+((N&1023)<<10)|te&1023}if(127>=N){if(m>=S)break;c[m++>>>0]=N}else{if(2047>=N){if(m+1>=S)break;c[m++>>>0]=192|N>>6}else{if(65535>=N){if(m+2>=S)break;c[m++>>>0]=224|N>>12}else{if(m+3>=S)break;c[m++>>>0]=240|N>>18,c[m++>>>0]=128|N>>12&63}c[m++>>>0]=128|N>>6&63}c[m++>>>0]=128|N&63}}return c[m>>>0]=0,m-A},yr=(i,c,m)=>Bt(i,o(),c,m);function br(i,c){if(x)return D(6,1,i,c)}function wr(i,c,m){if(x)return D(7,1,i,c,m)}function vr(i,c,m){return x?D(8,1,i,c,m):0}function $r(i,c){if(x)return D(9,1,i,c)}function xr(i,c,m){if(x)return D(10,1,i,c,m)}function Mt(i,c,m,S){if(x)return D(11,1,i,c,m,S)}function Xt(i,c,m,S){if(x)return D(12,1,i,c,m,S)}function Qt(i,c,m,S){if(x)return D(13,1,i,c,m,S)}function Jt(i){if(x)return D(14,1,i)}function Zt(i,c){if(x)return D(15,1,i,c)}function er(i,c,m){if(x)return D(16,1,i,c,m)}var tr=i=>{if(!he)try{if(i(),!Ie())try{x?mn(Pe):Pt(Pe)}catch(c){c instanceof ht||c=="unwind"||b(1,c)}}catch(c){c instanceof ht||c=="unwind"||b(1,c)}};function Dt(i){i>>>=0,typeof Atomics.Nb=="function"&&(Atomics.Nb(a(),i>>2,i).value.then(vt),i+=128,Atomics.store(a(),i>>2,1))}n.__emscripten_thread_mailbox_await=Dt;function vt(){var i=Ar();i&&(Dt(i),tr(()=>va()))}n.checkMailbox=vt;var lt=i=>i%4===0&&(i%100!==0||i%400===0),Sr=[0,31,60,91,121,152,182,213,244,274,305,335],$t=[0,31,59,90,120,151,181,212,243,273,304,334];function rr(i,c,m,S,A,k,N,te){return x?D(17,1,i,c,m,S,A,k,N,te):-52}function l(i,c,m,S,A,k,N){if(x)return D(18,1,i,c,m,S,A,k,N)}var f=i=>{var c=Yt(i)+1,m=pn(c);return m&&yr(i,m,c),m},g=[],C=(i,c)=>{g.length=0;var m;for(c>>=2;m=o()[i++>>>0];)c+=m!=105&c,g.push(m==105?a()[c>>>0]:u()[c++>>>1]),++c;return g},_=i=>{var c=hn();return i=i(),_r(c),i};function D(i,c){var m=arguments.length-2,S=arguments;return _(()=>{for(var A=gn(8*m),k=A>>3,N=0;N<m;N++){var te=S[2+N];u()[k+N>>>0]=te}return wa(i,m,A,c)})}var L=[],ne={},Y=()=>{if(!Q){var i={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:y||"./this.program"},c;for(c in ne)ne[c]===void 0?delete i[c]:i[c]=ne[c];var m=[];for(c in i)m.push(`${c}=${i[c]}`);Q=m}return Q},Q;function ee(i,c){if(x)return D(19,1,i,c);i>>>=0,c>>>=0;var m=0;return Y().forEach(function(S,A){var k=c+m;for(A=s()[i+4*A>>2>>>0]=k,k=0;k<S.length;++k)r()[A++>>0>>>0]=S.charCodeAt(k);r()[A>>0>>>0]=0,m+=S.length+1}),0}function ce(i,c){if(x)return D(20,1,i,c);i>>>=0,c>>>=0;var m=Y();s()[i>>2>>>0]=m.length;var S=0;return m.forEach(function(A){S+=A.length+1}),s()[c>>2>>>0]=S,0}function pe(i){return x?D(21,1,i):52}function E(i,c,m,S){return x?D(22,1,i,c,m,S):52}function ie(i,c,m,S,A){return x?D(23,1,i,c,m,S,A):70}var ye=[null,[],[]];function et(i,c,m,S){if(x)return D(24,1,i,c,m,S);c>>>=0,m>>>=0,S>>>=0;for(var A=0,k=0;k<m;k++){var N=s()[c>>2>>>0],te=s()[c+4>>2>>>0];c+=8;for(var Z=0;Z<te;Z++){var J=o()[N+Z>>>0],re=ye[i];J===0||J===10?((i===1?le:P)(kt(re,0)),re.length=0):re.push(J)}A+=te}return s()[S>>2>>>0]=A,0}var nr=[31,29,31,30,31,30,31,31,30,31,30,31],pa=[31,28,31,30,31,30,31,31,30,31,30,31];function Ku(i){var c=Array(Yt(i)+1);return Bt(i,c,0,c.length),c}var Yu=(i,c)=>{r().set(i,c>>>0)};function fa(i,c,m,S){function A(O,ue,ve){for(O=typeof O=="number"?O.toString():O||"";O.length<ue;)O=ve[0]+O;return O}function k(O,ue){return A(O,ue,"0")}function N(O,ue){function ve(Oa){return 0>Oa?-1:0<Oa?1:0}var xt;return(xt=ve(O.getFullYear()-ue.getFullYear()))===0&&(xt=ve(O.getMonth()-ue.getMonth()))===0&&(xt=ve(O.getDate()-ue.getDate())),xt}function te(O){switch(O.getDay()){case 0:return new Date(O.getFullYear()-1,11,29);case 1:return O;case 2:return new Date(O.getFullYear(),0,3);case 3:return new Date(O.getFullYear(),0,2);case 4:return new Date(O.getFullYear(),0,1);case 5:return new Date(O.getFullYear()-1,11,31);case 6:return new Date(O.getFullYear()-1,11,30)}}function Z(O){var ue=O.Za;for(O=new Date(new Date(O.$a+1900,0,1).getTime());0<ue;){var ve=O.getMonth(),xt=(lt(O.getFullYear())?nr:pa)[ve];if(ue>xt-O.getDate())ue-=xt-O.getDate()+1,O.setDate(1),11>ve?O.setMonth(ve+1):(O.setMonth(0),O.setFullYear(O.getFullYear()+1));else{O.setDate(O.getDate()+ue);break}}return ve=new Date(O.getFullYear()+1,0,4),ue=te(new Date(O.getFullYear(),0,4)),ve=te(ve),0>=N(ue,O)?0>=N(ve,O)?O.getFullYear()+1:O.getFullYear():O.getFullYear()-1}i>>>=0,c>>>=0,m>>>=0,S>>>=0;var J=a()[S+40>>2>>>0];S={Kb:a()[S>>2>>>0],Jb:a()[S+4>>2>>>0],cb:a()[S+8>>2>>>0],ib:a()[S+12>>2>>>0],eb:a()[S+16>>2>>>0],$a:a()[S+20>>2>>>0],Wa:a()[S+24>>2>>>0],Za:a()[S+28>>2>>>0],Tb:a()[S+32>>2>>>0],Ib:a()[S+36>>2>>>0],Lb:J?Ze(J):""},m=Ze(m),J={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var re in J)m=m.replace(new RegExp(re,"g"),J[re]);var fe="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),be="January February March April May June July August September October November December".split(" ");J={"%a":O=>fe[O.Wa].substring(0,3),"%A":O=>fe[O.Wa],"%b":O=>be[O.eb].substring(0,3),"%B":O=>be[O.eb],"%C":O=>k((O.$a+1900)/100|0,2),"%d":O=>k(O.ib,2),"%e":O=>A(O.ib,2," "),"%g":O=>Z(O).toString().substring(2),"%G":O=>Z(O),"%H":O=>k(O.cb,2),"%I":O=>(O=O.cb,O==0?O=12:12<O&&(O-=12),k(O,2)),"%j":O=>{for(var ue=0,ve=0;ve<=O.eb-1;ue+=(lt(O.$a+1900)?nr:pa)[ve++]);return k(O.ib+ue,3)},"%m":O=>k(O.eb+1,2),"%M":O=>k(O.Jb,2),"%n":()=>`
`,"%p":O=>0<=O.cb&&12>O.cb?"AM":"PM","%S":O=>k(O.Kb,2),"%t":()=>"	","%u":O=>O.Wa||7,"%U":O=>k(Math.floor((O.Za+7-O.Wa)/7),2),"%V":O=>{var ue=Math.floor((O.Za+7-(O.Wa+6)%7)/7);if(2>=(O.Wa+371-O.Za-2)%7&&ue++,ue)ue==53&&(ve=(O.Wa+371-O.Za)%7,ve==4||ve==3&&lt(O.$a)||(ue=1));else{ue=52;var ve=(O.Wa+7-O.Za-1)%7;(ve==4||ve==5&&lt(O.$a%400-1))&&ue++}return k(ue,2)},"%w":O=>O.Wa,"%W":O=>k(Math.floor((O.Za+7-(O.Wa+6)%7)/7),2),"%y":O=>(O.$a+1900).toString().substring(2),"%Y":O=>O.$a+1900,"%z":O=>{O=O.Ib;var ue=0<=O;return O=Math.abs(O)/60,(ue?"+":"-")+("0000"+(O/60*100+O%60)).slice(-4)},"%Z":O=>O.Lb,"%%":()=>"%"},m=m.replace(/%%/g,"\0\0");for(re in J)m.includes(re)&&(m=m.replace(new RegExp(re,"g"),J[re](S)));return m=m.replace(/\0\0/g,"%"),re=Ku(m),re.length>c?0:(Yu(re,i),re.length-1)}function Cr(i){try{i()}catch(c){Je(c)}}function Xu(i){var c={},m;for(m in i)(function(S){var A=i[S];c[S]=typeof A=="function"?function(){Ir.push(S);try{return A.apply(null,arguments)}finally{he||(Ir.pop()===S||Je(),tt&&pt===1&&Ir.length===0&&(pt=0,Ee+=1,Cr(Ia),typeof Fibers<"u"&&Fibers.Ub()))}}:A})(m);return c}var pt=0,tt=null,ma=0,Ir=[],ha={},ga={},Qu=0,cn=null,Ju=[];function Zu(){return new Promise((i,c)=>{cn={resolve:i,reject:c}})}function el(){var i=pn(65548),c=i+12;s()[i>>2>>>0]=c,s()[i+4>>2>>>0]=c+65536,c=Ir[0];var m=ha[c];return m===void 0&&(m=Qu++,ha[c]=m,ga[m]=c),c=m,a()[i+8>>2>>>0]=c,i}function tl(){var i=a()[tt+8>>2>>>0];return i=V[ga[i]],--Ee,i()}function rl(i){if(!he){if(pt===0){var c=!1,m=!1;i((S=0)=>{if(!he&&(ma=S,c=!0,m)){pt=2,Cr(()=>Aa(tt)),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.resume(),S=!1;try{var A=tl()}catch(te){A=te,S=!0}var k=!1;if(!tt){var N=cn;N&&(cn=null,(S?N.reject:N.resolve)(A),k=!0)}if(S&&!k)throw A}}),m=!0,c||(pt=1,tt=el(),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.pause(),Cr(()=>Ca(tt)))}else pt===2?(pt=0,Cr(_a),ya(tt),tt=null,Ju.forEach(S=>tr(S))):Je(`invalid state: ${pt}`);return ma}}function nl(i){return rl(c=>{i().then(c)})}ae.gb();var al=[null,Vt,bt,jt,qt,Kt,br,wr,vr,$r,xr,Mt,Xt,Qt,Jt,Zt,er,rr,l,ee,ce,pe,E,ie,et],ol={r:function(i,c,m){return nl(async()=>{await n.xb(i,c,m)})},b:function(i,c,m){throw i>>>=0,new dn(i).gb(c>>>0,m>>>0),qe=i,Le++,qe},O:function(i){ba(i>>>0,!$,1,!w,131072,!1),ae.lb()},l:function(i){i>>>=0,x?postMessage({cmd:"cleanupThread",thread:i}):Ht(i)},I:wt,i:qt,U:Kt,E:br,G:wr,V:vr,S:$r,K:xr,R:Mt,p:Xt,F:Qt,C:Jt,T:Zt,D:er,q:()=>!0,A:function(i,c){i>>>=0,i==c>>>0?setTimeout(()=>vt()):x?postMessage({targetThread:i,cmd:"checkMailbox"}):(i=ae.Qa[i])&&i.postMessage({cmd:"checkMailbox"})},M:function(){return-1},N:Dt,X:function(i){v&&ae.Qa[i>>>0].ref()},u:function(i,c,m){i=c+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*c:NaN,m>>>=0,i=new Date(1e3*i),a()[m>>2>>>0]=i.getUTCSeconds(),a()[m+4>>2>>>0]=i.getUTCMinutes(),a()[m+8>>2>>>0]=i.getUTCHours(),a()[m+12>>2>>>0]=i.getUTCDate(),a()[m+16>>2>>>0]=i.getUTCMonth(),a()[m+20>>2>>>0]=i.getUTCFullYear()-1900,a()[m+24>>2>>>0]=i.getUTCDay(),i=(i.getTime()-Date.UTC(i.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[m+28>>2>>>0]=i},v:function(i,c,m){i=c+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*c:NaN,m>>>=0,i=new Date(1e3*i),a()[m>>2>>>0]=i.getSeconds(),a()[m+4>>2>>>0]=i.getMinutes(),a()[m+8>>2>>>0]=i.getHours(),a()[m+12>>2>>>0]=i.getDate(),a()[m+16>>2>>>0]=i.getMonth(),a()[m+20>>2>>>0]=i.getFullYear()-1900,a()[m+24>>2>>>0]=i.getDay(),c=(lt(i.getFullYear())?Sr:$t)[i.getMonth()]+i.getDate()-1|0,a()[m+28>>2>>>0]=c,a()[m+36>>2>>>0]=-(60*i.getTimezoneOffset()),c=new Date(i.getFullYear(),6,1).getTimezoneOffset();var S=new Date(i.getFullYear(),0,1).getTimezoneOffset();i=(c!=S&&i.getTimezoneOffset()==Math.min(S,c))|0,a()[m+32>>2>>>0]=i},w:function(i){i>>>=0;var c=new Date(a()[i+20>>2>>>0]+1900,a()[i+16>>2>>>0],a()[i+12>>2>>>0],a()[i+8>>2>>>0],a()[i+4>>2>>>0],a()[i>>2>>>0],0),m=a()[i+32>>2>>>0],S=c.getTimezoneOffset(),A=new Date(c.getFullYear(),6,1).getTimezoneOffset(),k=new Date(c.getFullYear(),0,1).getTimezoneOffset(),N=Math.min(k,A);return 0>m?a()[i+32>>2>>>0]=+(A!=k&&N==S):0<m!=(N==S)&&(A=Math.max(k,A),c.setTime(c.getTime()+6e4*((0<m?N:A)-S))),a()[i+24>>2>>>0]=c.getDay(),m=(lt(c.getFullYear())?Sr:$t)[c.getMonth()]+c.getDate()-1|0,a()[i+28>>2>>>0]=m,a()[i>>2>>>0]=c.getSeconds(),a()[i+4>>2>>>0]=c.getMinutes(),a()[i+8>>2>>>0]=c.getHours(),a()[i+12>>2>>>0]=c.getDate(),a()[i+16>>2>>>0]=c.getMonth(),a()[i+20>>2>>>0]=c.getYear(),i=c.getTime()/1e3,$a((ut=i,1<=+Math.abs(ut)?0<ut?+Math.floor(ut/4294967296)>>>0:~~+Math.ceil((ut-+(~~ut>>>0))/4294967296)>>>0:0)),i>>>0},s:rr,t:l,z:function(i,c,m){function S(J){return(J=J.toTimeString().match(/\(([A-Za-z ]+)\)$/))?J[1]:"GMT"}i>>>=0,c>>>=0,m>>>=0;var A=new Date().getFullYear(),k=new Date(A,0,1),N=new Date(A,6,1);A=k.getTimezoneOffset();var te=N.getTimezoneOffset(),Z=Math.max(A,te);s()[i>>2>>>0]=60*Z,a()[c>>2>>>0]=+(A!=te),i=S(k),c=S(N),i=f(i),c=f(c),te<A?(s()[m>>2>>>0]=i,s()[m+4>>2>>>0]=c):(s()[m>>2>>>0]=c,s()[m+4>>2>>>0]=i)},d:()=>{Je("")},c:function(i,c,m){return i>>>=0,c=C(c>>>0,m>>>0),Tt[i].apply(null,c)},k:function(i,c,m){return i>>>=0,c=C(c>>>0,m>>>0),Tt[i].apply(null,c)},m:function(){},j:function(){return Date.now()},W:()=>{throw Ee+=1,"unwind"},B:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),g:function(){return v?(lo(),St(uo)).cpus().length:navigator.hardwareConcurrency},L:function(i,c,m,S){for(ae.Pb=c>>>0,L.length=m,c=S>>>0>>3,S=0;S<m;S++)L[S]=u()[c+S>>>0];return(0>i?Tt[-i-1]:al[i]).apply(null,L)},y:function(i){i>>>=0;var c=o().length;if(i<=c||4294901760<i)return!1;for(var m=1;4>=m;m*=2){var S=c*(1+.2/m);S=Math.min(S,i+100663296);var A=Math;S=Math.max(i,S);e:{A=A.min.call(A,4294901760,S+(65536-S%65536)%65536)-K.buffer.byteLength+65535>>>16;try{K.grow(A),G();var k=1;break e}catch{}k=void 0}if(k)return!0}return!1},P:ee,Q:ce,H:Pt,h:pe,o:E,x:ie,n:et,a:K||n.wasmMemory,J:fa,e:function(i,c,m,S){return fa(i>>>0,c>>>0,m>>>0,S>>>0)}};(function(){function i(m,S){return m=m.exports,m=Xu(m),V=m=il(m),ae.mb.push(V.Da),Ne.unshift(V.Y),ze=S,Ut(),m}var c={a:ol};if(gr(),n.instantiateWasm)try{return n.instantiateWasm(c,i)}catch(m){P("Module.instantiateWasm callback failed with error: "+m),p(m)}return ct(c,function(m){i(m.instance,m.module)}).catch(p),{}})(),n._OrtInit=(i,c)=>(n._OrtInit=V.Z)(i,c),n._OrtGetLastError=(i,c)=>(n._OrtGetLastError=V._)(i,c),n._OrtCreateSessionOptions=(i,c,m,S,A,k,N,te,Z,J)=>(n._OrtCreateSessionOptions=V.$)(i,c,m,S,A,k,N,te,Z,J),n._OrtAppendExecutionProvider=(i,c)=>(n._OrtAppendExecutionProvider=V.aa)(i,c),n._OrtAddFreeDimensionOverride=(i,c,m)=>(n._OrtAddFreeDimensionOverride=V.ba)(i,c,m),n._OrtAddSessionConfigEntry=(i,c,m)=>(n._OrtAddSessionConfigEntry=V.ca)(i,c,m),n._OrtReleaseSessionOptions=i=>(n._OrtReleaseSessionOptions=V.da)(i),n._OrtCreateSession=(i,c,m)=>(n._OrtCreateSession=V.ea)(i,c,m),n._OrtReleaseSession=i=>(n._OrtReleaseSession=V.fa)(i),n._OrtGetInputOutputCount=(i,c,m)=>(n._OrtGetInputOutputCount=V.ga)(i,c,m),n._OrtGetInputName=(i,c)=>(n._OrtGetInputName=V.ha)(i,c),n._OrtGetOutputName=(i,c)=>(n._OrtGetOutputName=V.ia)(i,c),n._OrtFree=i=>(n._OrtFree=V.ja)(i),n._OrtCreateTensor=(i,c,m,S,A,k)=>(n._OrtCreateTensor=V.ka)(i,c,m,S,A,k),n._OrtGetTensorData=(i,c,m,S,A)=>(n._OrtGetTensorData=V.la)(i,c,m,S,A),n._OrtReleaseTensor=i=>(n._OrtReleaseTensor=V.ma)(i),n._OrtCreateRunOptions=(i,c,m,S)=>(n._OrtCreateRunOptions=V.na)(i,c,m,S),n._OrtAddRunConfigEntry=(i,c,m)=>(n._OrtAddRunConfigEntry=V.oa)(i,c,m),n._OrtReleaseRunOptions=i=>(n._OrtReleaseRunOptions=V.pa)(i),n._OrtCreateBinding=i=>(n._OrtCreateBinding=V.qa)(i),n._OrtBindInput=(i,c,m)=>(n._OrtBindInput=V.ra)(i,c,m),n._OrtBindOutput=(i,c,m,S)=>(n._OrtBindOutput=V.sa)(i,c,m,S),n._OrtClearBoundOutputs=i=>(n._OrtClearBoundOutputs=V.ta)(i),n._OrtReleaseBinding=i=>(n._OrtReleaseBinding=V.ua)(i),n._OrtRunWithBinding=(i,c,m,S,A)=>(n._OrtRunWithBinding=V.va)(i,c,m,S,A),n._OrtRun=(i,c,m,S,A,k,N,te)=>(n._OrtRun=V.wa)(i,c,m,S,A,k,N,te),n._OrtEndProfiling=i=>(n._OrtEndProfiling=V.xa)(i),n._JsepOutput=(i,c,m)=>(n._JsepOutput=V.ya)(i,c,m),n._JsepGetNodeName=i=>(n._JsepGetNodeName=V.za)(i);var Ar=n._pthread_self=()=>(Ar=n._pthread_self=V.Aa)(),pn=n._malloc=i=>(pn=n._malloc=V.Ba)(i),ya=n._free=i=>(ya=n._free=V.Ca)(i);n.__emscripten_tls_init=()=>(n.__emscripten_tls_init=V.Da)();var ba=n.__emscripten_thread_init=(i,c,m,S,A,k)=>(ba=n.__emscripten_thread_init=V.Fa)(i,c,m,S,A,k);n.__emscripten_thread_crashed=()=>(n.__emscripten_thread_crashed=V.Ga)();var wa=(i,c,m,S)=>(wa=V.Ha)(i,c,m,S),fn=i=>(fn=V.Ia)(i),mn=n.__emscripten_thread_exit=i=>(mn=n.__emscripten_thread_exit=V.Ja)(i),va=n.__emscripten_check_mailbox=()=>(va=n.__emscripten_check_mailbox=V.Ka)(),$a=i=>($a=V.La)(i),xa=(i,c)=>(xa=V.Ma)(i,c),hn=()=>(hn=V.Na)(),_r=i=>(_r=V.Oa)(i),gn=i=>(gn=V.Pa)(i),Sa=n.dynCall_ii=(i,c)=>(Sa=n.dynCall_ii=V.Ra)(i,c),Ca=i=>(Ca=V.Sa)(i),Ia=()=>(Ia=V.Ta)(),Aa=i=>(Aa=V.Ua)(i),_a=()=>(_a=V.Va)();n.___start_em_js=922382,n.___stop_em_js=922543;function il(i){i=Object.assign({},i);var c=S=>()=>S()>>>0,m=S=>A=>S(A)>>>0;return i.__errno_location=c(i.__errno_location),i.pthread_self=c(i.pthread_self),i.malloc=m(i.malloc),i.stackSave=c(i.stackSave),i.stackAlloc=m(i.stackAlloc),i}n.keepRuntimeAlive=Ie,n.wasmMemory=K,n.stackAlloc=gn,n.stackSave=hn,n.stackRestore=_r,n.UTF8ToString=Ze,n.stringToUTF8=yr,n.lengthBytesUTF8=Yt,n.ExitStatus=ht,n.PThread=ae;var Er;Ve=function i(){Er||Ea(),Er||(Ve=i)};function Ea(){function i(){if(!Er&&(Er=!0,n.calledRun=!0,!he)&&(x||yt(Ne),d(n),n.onRuntimeInitialized&&n.onRuntimeInitialized(),!x)){if(n.postRun)for(typeof n.postRun=="function"&&(n.postRun=[n.postRun]);n.postRun.length;){var c=n.postRun.shift();Ge.unshift(c)}yt(Ge)}}if(!(0<Fe))if(x)d(n),x||yt(Ne),startWorker(n);else{if(n.preRun)for(typeof n.preRun=="function"&&(n.preRun=[n.preRun]);n.preRun.length;)ge.unshift(n.preRun.shift());yt(ge),0<Fe||(n.setStatus?(n.setStatus("Running..."),setTimeout(function(){setTimeout(function(){n.setStatus("")},1),i()},1)):i())}}if(n.preInit)for(typeof n.preInit=="function"&&(n.preInit=[n.preInit]);0<n.preInit.length;)n.preInit.pop()();return Ea(),t.ready}})();typeof po=="object"&&typeof _n=="object"?_n.exports=co:typeof define=="function"&&define.amd&&define([],()=>co)});var mo=zt((vp,ml)=>{ml.exports='"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(Module.__embind_initialize_bindings(),initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err(`worker.js received unknown command ${e.data.cmd}`),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\n'});var go,hl,En,On,Br,ho,gl,yl,bl,yo,Oe,Wt=H(()=>{"use strict";go=oo();hl=fo(),On=!1,Br=!1,ho=!1,gl=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},yl=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},bl=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",yo=async e=>{if(On)return Promise.resolve();if(Br)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(ho)throw new Error("previous call to 'initializeWebAssembly()' failed.");Br=!0;let t=e.initTimeout,r=e.numThreads,o=e.simd,a=r>1&&gl(),s=o&&yl(),u=e.wasmPaths,n=typeof u=="string"?u:void 0,d=bl(s,a),p=typeof u=="object"?u[d]:void 0,h=!1,y=[];if(t>0&&y.push(new Promise(b=>{setTimeout(()=>{h=!0,b()},t)})),y.push(new Promise((b,w)=>{let $=a?hl:go,v={locateFile:(x,I)=>{if(a&&x.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([mo()],{type:"text/javascript"}));if(x.endsWith(".wasm")){if(p)return p;let R=n??I;return d==="ort-wasm-simd.wasm"?R+"ort-wasm-simd.jsep.wasm":d==="ort-wasm-simd-threaded.wasm"?R+"ort-wasm-simd-threaded.jsep.wasm":R+d}return I+x}};if(a)if(typeof Blob>"u")v.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let x=`var ortWasmThreaded=${$.toString()};`;v.mainScriptUrlOrBlob=new Blob([x],{type:"text/javascript"})}$(v).then(x=>{Br=!1,On=!0,En=x,b()},x=>{Br=!1,ho=!0,w(x)})})),await Promise.race(y),h)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Oe=()=>{if(On&&En)return En;throw new Error("WebAssembly is not initialized yet.")}});var Te,ir,Se,Mr=H(()=>{"use strict";Wt();Te=(e,t)=>{let r=Oe(),o=r.lengthBytesUTF8(e)+1,a=r._malloc(o);return r.stringToUTF8(e,a,o),t.push(a),a},ir=(e,t,r,o)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([a,s])=>{let u=t?t+a:a;if(typeof s=="object")ir(s,u+".",r,o);else if(typeof s=="string"||typeof s=="number")o(u,s.toString());else if(typeof s=="boolean")o(u,s?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof s}`)})},Se=e=>{let t=Oe(),r=t.stackSave();try{let o=t.stackAlloc(8);t._OrtGetLastError(o,o+4);let a=t.HEAP32[o/4],s=t.HEAPU32[o/4+1],u=s?t.UTF8ToString(s):"";throw new Error(`${e} ERROR_CODE: ${a}, ERROR_MESSAGE: ${u}`)}finally{t.stackRestore(r)}}});var bo,wo=H(()=>{"use strict";Wt();Mr();bo=e=>{let t=Oe(),r=0,o=[],a=e||{};try{if(e?.logSeverityLevel===void 0)a.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)a.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(a.terminate=!1);let s=0;return e?.tag!==void 0&&(s=Te(e.tag,o)),r=t._OrtCreateRunOptions(a.logSeverityLevel,a.logVerbosityLevel,!!a.terminate,s),r===0&&Se("Can't create run options."),e?.extra!==void 0&&ir(e.extra,"",new WeakSet,(u,n)=>{let d=Te(u,o),p=Te(n,o);t._OrtAddRunConfigEntry(r,d,p)!==0&&Se(`Can't set a run config entry: ${u} - ${n}.`)}),[r,o]}catch(s){throw r!==0&&t._OrtReleaseRunOptions(r),o.forEach(u=>t._free(u)),s}}});var wl,vl,$l,xl,vo,$o=H(()=>{"use strict";Wt();Mr();wl=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},vl=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},$l=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},xl=(e,t,r)=>{for(let o of t){let a=typeof o=="string"?o:o.name;switch(a){case"xnnpack":a="XNNPACK";break;case"webnn":if(a="WEBNN",typeof o!="string"){let u=o;if(u?.deviceType){let n=Te("deviceType",r),d=Te(u.deviceType,r);Oe()._OrtAddSessionConfigEntry(e,n,d)!==0&&Se(`Can't set a session config entry: 'deviceType' - ${u.deviceType}.`)}if(u?.numThreads){let n=u.numThreads;(typeof n!="number"||!Number.isInteger(n)||n<0)&&(n=0);let d=Te("numThreads",r),p=Te(n.toString(),r);Oe()._OrtAddSessionConfigEntry(e,d,p)!==0&&Se(`Can't set a session config entry: 'numThreads' - ${u.numThreads}.`)}if(u?.powerPreference){let n=Te("powerPreference",r),d=Te(u.powerPreference,r);Oe()._OrtAddSessionConfigEntry(e,n,d)!==0&&Se(`Can't set a session config entry: 'powerPreference' - ${u.powerPreference}.`)}}break;case"webgpu":if(a="JS",typeof o!="string"){let u=o;if(u?.preferredLayout){if(u.preferredLayout!=="NCHW"&&u.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${u.preferredLayout}`);let n=Te("preferredLayout",r),d=Te(u.preferredLayout,r);Oe()._OrtAddSessionConfigEntry(e,n,d)!==0&&Se(`Can't set a session config entry: 'preferredLayout' - ${u.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${a}`)}let s=Te(a,r);Oe()._OrtAppendExecutionProvider(e,s)!==0&&Se(`Can't append execution provider: ${a}.`)}},vo=e=>{let t=Oe(),r=0,o=[],a=e||{};$l(a);try{let s=wl(a.graphOptimizationLevel??"all"),u=vl(a.executionMode??"sequential"),n=typeof a.logId=="string"?Te(a.logId,o):0,d=a.logSeverityLevel??2;if(!Number.isInteger(d)||d<0||d>4)throw new Error(`log serverity level is not valid: ${d}`);let p=a.logVerbosityLevel??0;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log verbosity level is not valid: ${p}`);let h=typeof a.optimizedModelFilePath=="string"?Te(a.optimizedModelFilePath,o):0;if(r=t._OrtCreateSessionOptions(s,!!a.enableCpuMemArena,!!a.enableMemPattern,u,!!a.enableProfiling,0,n,d,p,h),r===0&&Se("Can't create session options."),a.executionProviders&&xl(r,a.executionProviders,o),a.freeDimensionOverrides)for(let[y,b]of Object.entries(a.freeDimensionOverrides)){if(typeof y!="string")throw new Error(`free dimension override name must be a string: ${y}`);if(typeof b!="number"||!Number.isInteger(b)||b<0)throw new Error(`free dimension override value must be a non-negative integer: ${b}`);let w=Te(y,o);t._OrtAddFreeDimensionOverride(r,w,b)!==0&&Se(`Can't set a free dimension override: ${y} - ${b}.`)}return a.extra!==void 0&&ir(a.extra,"",new WeakSet,(y,b)=>{let w=Te(y,o),$=Te(b,o);t._OrtAddSessionConfigEntry(r,w,$)!==0&&Se(`Can't set a session config entry: ${y} - ${b}.`)}),[r,o]}catch(s){throw r!==0&&t._OrtReleaseSessionOptions(r),o.forEach(u=>t._free(u)),s}}});var Tn,sr,ur,Dr,lr,zr,Rn,Me=H(()=>{"use strict";Tn=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},sr=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},ur=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],Dr=e=>{switch(e){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},lr=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},zr=e=>e==="float32"||e==="int32"||e==="int64"||e==="bool"||e==="float16"||e==="uint32",Rn=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var Sl,Cl,xo,So,Co,Il,_e,ft=H(()=>{"use strict";Me();Sl=["V","I","W","E","F"],Cl=(e,t)=>{console.log(`[${Sl[e]},${new Date().toISOString()}]${t}`)},Co=(e,t)=>{xo=e,So=t},Il=(e,t)=>{let r=lr(e),o=lr(xo);r>=o&&Cl(r,typeof t=="function"?t():t)},_e=(...e)=>{So&&Il(...e)}});var Io,Ao=H(()=>{"use strict";Me();Io=(e,t)=>new(Dr(t))(e)});var _o=H(()=>{"use strict"});var Wr,Al,Eo,Pn,kn,Oo,To=H(()=>{"use strict";ft();_o();Wr=e=>Math.ceil(e/16)*16,Al=1,Eo=()=>Al++,Pn=async(e,t,r,o)=>{let a=Wr(r),s=e.device.createBuffer({size:a,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let u=e.getCommandEncoder();e.endComputePass(),u.copyBufferToBuffer(t,0,s,0,a),e.flush(),await s.mapAsync(GPUMapMode.READ);let n=s.getMappedRange();if(o){let d=o();return d.set(new Uint8Array(n,0,r)),d}else return new Uint8Array(n.slice(0,r))}finally{s.destroy()}},kn=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(t,r){let o=r.buffer,a=r.byteOffset,s=r.byteLength,u=Wr(s),n=this.storageCache.get(t);if(!n)throw new Error("gpu data for uploading does not exist");if(n.originalSize!==s)throw new Error(`inconsistent data size. gpu data size=${n.originalSize}, data size=${s}`);let d=this.backend.device.createBuffer({mappedAtCreation:!0,size:u,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),p=d.getMappedRange();new Uint8Array(p).set(new Uint8Array(o,a,s)),d.unmap();let h=this.backend.getCommandEncoder();this.backend.endComputePass(),h.copyBufferToBuffer(d,0,n.gpuData.buffer,0,u),_e("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`),this.buffersForUploadingPending.push(d)}memcpy(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("source gpu data for memcpy does not exist");let a=this.storageCache.get(r);if(!a)throw new Error("destination gpu data for memcpy does not exist");if(o.originalSize!==a.originalSize)throw new Error("inconsistent source and destination gpu data size");let s=Wr(o.originalSize),u=this.backend.getCommandEncoder();this.backend.endComputePass(),u.copyBufferToBuffer(o.gpuData.buffer,0,a.gpuData.buffer,0,s)}registerExternalBuffer(t,r,o){let a;if(o){if(a=this.externalBuffers.get(o),a===void 0)throw new Error("previous buffer is not registered");if(t===o)return _e("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${a}, buffer is the same, skip.`),a;this.externalBuffers.delete(o)}else a=Eo();return this.storageCache.set(a,{gpuData:{id:a,type:0,buffer:t},originalSize:r}),this.externalBuffers.set(t,a),_e("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${a}, registered.`),a}unregisterExternalBuffer(t){let r=this.externalBuffers.get(t);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(t),_e("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let o=Wr(t),a,s=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,u=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(s||u){let d=s?this.freeBuffers:this.freeUniformBuffers,p=d.get(o);p||(p=[],d.set(o,p)),p.length>0?a=p.pop():a=this.backend.device.createBuffer({size:o,usage:r})}else a=this.backend.device.createBuffer({size:o,usage:r});let n={id:Eo(),type:0,buffer:a};return this.storageCache.set(n.id,{gpuData:n,originalSize:t}),_e("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${n.id}`),n}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=this.storageCache.get(t);if(!r)throw new Error("releasing data does not exist");return _e("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("data does not exist");await Pn(this.backend,o.gpuData.buffer,o.originalSize,r)}refreshPendingBuffers(){for(let t of this.buffersForUploadingPending)t.destroy();this.buffersForUploadingPending=[];for(let t of this.buffersPending)(t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(t.size).push(t):(t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(t.size).push(t):t.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},Oo=(...e)=>new kn(...e)});var Bn,oe,Re=H(()=>{"use strict";Bn=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this._cacheKey}},oe=e=>new Bn(e)});var Mn,rt,z,_t,Nr,Ur,Gr,me=H(()=>{"use strict";Mn=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},rt=class{static calcShape(t,r,o=!1){let a=t.length,s=r.length;if(a===0)return r;if(s===0)return t;let u=Math.max(t.length,r.length),n=new Array(u);if(o){if(a<2||s<2)return;let d=Mn.calcMatMulShape([t[a-2],t[a-1]],[r[s-2],r[s-1]]);if(d===void 0)return;[n[u-2],n[u-1]]=d}for(let d=o?3:1;d<=u;d++){let p=a-d<0?1:t[a-d],h=s-d<0?1:r[s-d];if(p!==h&&p>1&&h>1)return;n[u-d]=Math.max(p,h)}return n}static isValidBroadcast(t,r){let o=t.length,a=r.length;if(o>a)return!1;for(let s=1;s<=o;s++)if(t[o-s]!==1&&t[o-s]!==r[a-s])return!1;return!0}},z=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,o){let a=1;for(let s=r;s<o;s++){if(t[s]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");a*=t[s]}return a}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let o=new Array(r);o[r-1]=1,o[r-2]=t[r-1];for(let a=r-3;a>=0;--a)o[a]=o[a+1]*t[a+1];return o}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error("unsupported axis for this operation.");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(o=>this.normalizeAxis(o,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(o=>t[o]):t.slice().reverse()}static padShape(t,r){let o=t.length;return t.map((a,s)=>a+r[s]+r[s+o])}static areEqual(t,r){return t.length!==r.length?!1:t.every((o,a)=>o===r[a])}},_t=class e{static adjustPoolAttributes(t,r,o,a,s,u){if(!t&&o.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let n=0;n<r.length-2;n++)n>=o.length?o.push(r[n+2]):o[n]=r[n+2];for(let n=0;n<o.length;n++)if(n<a.length){if(a[n]<0)throw new Error("strides should be greater than or equal to 1")}else a.push(1);for(let n=0;n<o.length;n++)if(n<s.length){if(s[n]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let n=0;n<o.length*2;n++)if(n<u.length){if(u[n]<0)throw new Error("pad should be greater than or equal to 1")}else u.push(0);for(let n=0;n<o.length;n++){if(o[n]<=0)throw new Error("kernel shapes need to be greater than 0");if(u[n]>=o[n]||u[n+o.length]>=o[n])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,o,a,s,u,n){if(n){if(s.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(a.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let d=0;d<t.length-2;d++)e.adjustPadAndReturnShape(t[d+(u?1:2)],r[d],o[d],a[d],s,d,d+t.length-2,n)}}static computePoolOutputShape(t,r,o,a,s,u,n){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let d=[r[0],r[1]];return e.computeShapeHelper(t,r,d,o,a,s,u,n),d}static computeConvOutputShape(t,r,o,a,s,u,n){if(t.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let d=[t[0],r[0]];return e.computeShapeHelper(!1,t,d,o,a,s,u,n),d}static computeShapeHelper(t,r,o,a,s,u,n,d){if(t)for(let p=0;p<r.length-2;p++)o.push(1);else for(let p=0;p<r.length-2;p++)o.push(e.adjustPadAndReturnShape(r[p+2],a[p],s[p],u[p],n,p,p+r.length-2,d))}static adjustPadAndReturnShape(t,r,o,a,s,u,n,d){let p=o*(a-1)+1;if(d&&d!=="NOTSET")switch(d){case"VALID":return s[u]=0,s[n]=0,Math.floor((t-p)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(o!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let y=((t+r-1)/r-1)*r+a-t;return s[u]=Math.floor(d==="SAME_LOWER"?(y+1)/2:y/2),s[n]=y-s[u],Math.floor((t+y-a)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+s[u]+s[n]-p)/r+1)}},Nr=class{static getShapeOfGemmResult(t,r,o,a,s){if(t.length!==2||o.length!==2)throw new Error("shape need to be of size 2");let u,n,d;r?(u=t[1],n=t[0]):(u=t[0],n=t[1]);let p=-1;if(a?(d=o[0],p=1):(d=o[1],p=0),o[p]!==n)throw new Error("dimension mismatch");if(u<=0||d<=0||n<=0)throw new Error("invalid shape specified");if(s&&!rt.isValidBroadcast(s,[u,d]))throw new Error("gemm: invalid bias shape for broadcast");return[u,d,n]}},Ur=-34028234663852886e22,Gr=34028234663852886e22});var _l,Ro,ke,zn,ko,q,se,Dn,Po,Wn,$e=H(()=>{"use strict";Me();me();_l=64,Ro=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},ke=(e,t=1)=>{let r=Ro(e,t);return typeof r=="string"?r:r[0]},zn=e=>[{type:"uint32",data:e},{type:"uint32",data:z.computeStrides(e)}],ko=(e,t,r,o,a)=>{let s=typeof r=="number",u=s?r:r.length,n=[...new Array(u).keys()],d=u<2?"u32":u<=4?`vec${u}<u32>`:`array<u32, ${u}>`,p=Ro(t,a),h=typeof p=="string"?p:p[1],y=typeof p=="string"?p:p[0],b={indices:d,value:h,storage:y,tensor:t},w=G=>typeof G=="string"?G:`${G}u`,$={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},v=s?"uniforms.":"",x=`${v}${e}_shape`,I=`${v}${e}_strides`,R="";for(let G=0;G<u-1;G++)R+=`
    let dim${G} = current / ${I}[${G}];
    let rest${G} = current % ${I}[${G}];
    indices[${G}] = dim${G};
    current = rest${G};
    `;R+=`indices[${u-1}] = current;`;let M=u<2?"":`
  fn o2i_${e}(offset: u32) -> ${b.indices} {
    var indices: ${b.indices};
    var current = offset;
    ${R}
    return indices;
  }`,B=G=>($.offsetToIndices=!0,u<2?G:`o2i_${e}(${G})`),W=[];if(u>=2)for(let G=u-1;G>=0;G--)W.push(`${I}[${G}] * (indices[${G}])`);let T=u<2?"":`
  fn i2o_${e}(indices: ${b.indices}) -> u32 {
    return ${W.join("+")};
  }`,U=G=>($.indicesToOffset=!0,u<2?G:`i2o_${e}(${G})`),F=(...G)=>u===0?"0u":`${b.indices}(${G.map(w).join(",")})`,j=(G,de)=>u<2?`${G}`:`${G}[${de}]`,le=(G,de,ge)=>u<2?`${G}=${ge};`:`${G}[${de}]=${ge};`,P={},X=(G,de)=>{$.broadcastedIndicesToOffset=!0;let ge=`${de.name}broadcastedIndicesTo${e}Offset`;if(ge in P)return`${ge}(${G})`;let Ne=[];for(let Ge=u-1;Ge>=0;Ge--){let Ee=de.indicesGet("outputIndices",Ge+de.rank-u);Ne.push(`${j(I,Ge)} * (${Ee} % ${j(x,Ge)})`)}return P[ge]=`fn ${ge}(outputIndices: ${de.type.indices}) -> u32 {
             return ${Ne.length>0?Ne.join("+"):"0u"};
           }`,`${ge}(${G})`},Ce=(G,de)=>(()=>{if(b.storage===b.value)return`${e}[${G}]=${de};`;if(b.storage==="vec2<u32>"&&b.value==="i32")return`${e}[${G}]=vec2<u32>(u32(${de}), select(0u, 0xFFFFFFFFu, ${de} < 0));`;if(b.storage==="vec2<u32>"&&b.value==="u32")return`${e}[${G}]=vec2<u32>(u32(${de}), 0u);`;if(b.storage==="u32"&&b.value==="vec4<bool>")return`${e}[${G}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${de}));`;throw new Error(`not supported combination of storage type ${b.storage} and value type ${b.value} yet`)})(),K=G=>(()=>{if(b.storage===b.value)return`${e}[${G}]`;if(b.storage==="vec2<u32>"&&b.value==="i32")return`i32(${e}[${G}].x)`;if(b.storage==="vec2<u32>"&&b.value==="u32")return`u32(${e}[${G}].x)`;if(b.storage==="u32"&&b.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${G}] & 0xFFu), bool(${e}[${G}] & 0xFF00u), bool(${e}[${G}] & 0xFF0000u), bool(${e}[${G}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${b.storage} and value type ${b.value} yet`)})(),V=u<2?"":`
  fn get_${e}ByIndices(indices: ${b.indices}) -> ${h} {
    return ${K(`i2o_${e}(indices)`)};
  }`,ze=u<2?"":(()=>{let G=n.map(ge=>`d${ge}: u32`).join(", "),de=n.map(ge=>`d${ge}`).join(", ");return`
  fn get_${e}(${G}) -> ${h} {
    return get_${e}ByIndices(${F(de)});
  }`})(),he=(...G)=>{if(G.length!==u)throw new Error(`indices length must be ${u}`);let de=G.map(w).join(",");return u===0?K("0u"):u===1?K(de[0]):($.get=!0,$.getByIndices=!0,$.indicesToOffset=!0,`get_${e}(${de})`)},Pe=G=>u<2?K(G):($.getByIndices=!0,$.indicesToOffset=!0,`get_${e}ByIndices(${G})`),we=u<2?"":`
  fn set_${e}ByIndices(indices: ${b.indices}, value: ${h}) {
    ${Ce(`i2o_${e}(indices)`,"value")}
  }`,Be=u<2?"":(()=>{let G=n.map(ge=>`d${ge}: u32`).join(", "),de=n.map(ge=>`d${ge}`).join(", ");return`
  fn set_${e}(${G}, value: ${h}) {
    set_${e}ByIndices(${F(de)}, value);
  }`})();return{impl:()=>{let G=[];return s||(G.push(`const ${x} = ${b.indices}(${r.join(",")});`),G.push(`const ${I} = ${b.indices}(${z.computeStrides(r).join(",")});`)),$.offsetToIndices&&G.push(M),$.indicesToOffset&&G.push(T),$.broadcastedIndicesToOffset&&Object.values(P).forEach(de=>G.push(de)),$.set&&G.push(Be),$.setByIndices&&G.push(we),$.get&&G.push(ze),$.getByIndices&&G.push(V),G.join(`
`)},type:b,offsetToIndices:B,indicesToOffset:U,broadcastedIndicesToOffset:X,indices:F,indicesGet:j,indicesSet:le,set:(...G)=>{if(G.length!==u+1)throw new Error(`indices length must be ${u}`);let de=G[u];if(typeof de!="string")throw new Error("value must be string");let ge=G.slice(0,u).map(w).join(",");return u===0?Ce("0u",de):u===1?Ce(ge[0],de):($.set=!0,$.setByIndices=!0,$.indicesToOffset=!0,`set_${e}(${ge}, ${de})`)},setByOffset:Ce,setByIndices:(G,de)=>u<2?Ce(G,de):($.setByIndices=!0,$.indicesToOffset=!0,`set_${e}ByIndices(${G}, ${de});`),get:he,getByOffset:K,getByIndices:Pe,usage:o?"input":"output",name:e,strides:I,shape:x,rank:u}},q=(e,t,r,o=1)=>ko(e,t,r,!0,o),se=(e,t,r,o=1)=>ko(e,t,r,!1,o),Dn=class{constructor(t){this.normalizedDispatchGroup=t;this.indicesHelpers=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=_l){let r=typeof t=="number"?t:t[0],o=typeof t=="number"?1:t[1],a=typeof t=="number"?1:t[2],s=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,u=s?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_index : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>`,n=s?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +
          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${r*o*a}u + local_index;`;return`@compute @workgroup_size(${r}, ${o}, ${a})
  fn main(${u}) {
    ${n}
  `}declareVariable(t,r){this.indicesHelpers.push(t),t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:t.type.indices}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:t.type.indices});let o=t.usage==="input"?"read":"read_write",a=t.type.storage;return`@group(0) @binding(${r}) var<storage, ${o}> ${t.name}: array<${a}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`
`)}registerUniform(t,r){return this.uniforms.push({name:t,type:r}),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:r,type:o}of this.uniforms)t.push(`${r}:${o}`);return`
      struct Uniforms { ${t.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.indicesHelpers.map(t=>t.impl()).join(`
`)}},Po=e=>new Dn(e),Wn=(e,t)=>{let r=e.length,o=[];for(let a=0;a<r;a++){let s=r-1-a,u=e[s]||1;(t[t.length-1-a]||1)>1&&u===1&&o.unshift(s)}return o}});var nt,El,Fr,Ol,at,Bo,Mo,Do,zo,Wo,No,Uo,Go,Fo,Ho,Ye,Nn=H(()=>{"use strict";me();Re();$e();nt=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},El=e=>["","",`var value = ${e.getByOffset("inputOffset")};`,""],Fr=(e,t,r,o,a,s,u=!1,n=!1)=>{let d=[],p=r[0].dims,h=z.normalizeAxes(a,r[0].dims.length),y=!n&&h.length===0;p.forEach((U,F)=>{y||h.indexOf(F)>=0?u&&d.push(1):d.push(U)});let b=[],w=q("_A",r[0].dataType,p),$=se("output",s,d),v=o(w,$,h),x=`inputOffset = ${w.indicesToOffset("inputIndices")};`,I=`let ${x};`,R=`var ${x};`,M=v[1]===""?"":R,B=(v[1]===""?I:x)+`
`+v[2];for(let U=0,F=0;U<r[0].dims.length;U++)y||h.indexOf(U)>=0?(u&&F++,B=`for(var j${U}: u32 = 0; j${U} < ${r[0].dims[U]}; j${U}++) {
                ${v[2].includes("lastIndex")?`let lastIndex = j${U};`:""}
                ${w.indicesSet("inputIndices",U,`j${U}`)}
                ${B}
              }`):(b.push(`${w.indicesSet("inputIndices",U,$.indicesGet("outputIndices",F))};`),F++);let W=z.size(d);return{name:e,shaderCache:t,getShaderSource:U=>`
        ${U.declareVariables(w,$)}

        ${U.mainStart()}
          ${U.guardAgainstOutOfBoundsWorkgroupSizes(W)}
          var inputIndices: ${w.type.indices};
          let outputIndices = ${$.offsetToIndices("global_idx")};

          ${b.join(`
`)}
          ${v[0]}       // init ops for reduce max/min
          ${M}
          ${v[1]}
          ${B}
          ${v[3]}
          ${v.length===4?$.setByOffset("global_idx","value"):v.slice(4).join(`
`)}
        }`,getRunData:()=>({outputs:[{dims:d,dataType:s}],dispatchGroup:{x:Math.ceil(W/64)}})}},Ol=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(o=>r.push(Number(o))),oe({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},at=(e,t,r,o)=>{let a=e.inputs,s=a.length===1?r:Ol(a,r);e.compute(Fr(t,{hint:s.cacheKey},[a[0]],s.noopWithEmptyAxes&&s.axes.length===0?El:o,s.axes,a[0].dataType,s.keepDims,s.noopWithEmptyAxes),{inputs:[0]})},Bo=(e,t)=>{nt(e.inputs),at(e,"ReduceLogSum",t,(o,a)=>[`var value = ${a.type.storage}(0);`,"",`value += ${o.getByOffset("inputOffset")};`,"value = log(value);"])},Mo=(e,t)=>{nt(e.inputs),at(e,"ReduceL1",t,(o,a)=>[`var value = ${a.type.storage}(0);`,"",`value += abs(${o.getByOffset("inputOffset")});`,""])},Do=(e,t)=>{nt(e.inputs),at(e,"ReduceL2",t,(o,a)=>[`var t = ${a.type.value}(0); var value = ${a.type.value}(0);`,"",`t = ${o.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"])},zo=(e,t)=>{nt(e.inputs),at(e,"ReduceLogSumExp",t,(o,a)=>[`var value = ${a.type.storage}(0);`,"",`value += exp(${o.getByOffset("inputOffset")});`,"value = log(value);"])},Wo=(e,t)=>{nt(e.inputs),at(e,"ReduceMax",t,(o,a,s)=>{let u=[];for(let n=0;n<o.rank;n++)(s.indexOf(n)>=0||s.length===0)&&u.push(o.indicesSet("inputIndices",n,0));return[`${u.join(`
`)}`,`var value = ${o.getByOffset("inputOffset")};`,`value = max(value, ${o.getByOffset("inputOffset")});`,""]})},No=(e,t)=>{nt(e.inputs),at(e,"ReduceMean",t,(o,a,s)=>{let u=1;for(let n=0;n<o.rank;n++)(s.indexOf(n)>=0||s.length===0)&&(u*=e.inputs[0].dims[n]);return["var sum = f32(0);","",`sum += f32(${o.getByOffset("inputOffset")});`,`let value = ${a.type.value}(sum / ${u});`]})},Uo=(e,t)=>{nt(e.inputs),at(e,"ReduceMin",t,(o,a,s)=>{let u=[];for(let n=0;n<o.rank;n++)(s.indexOf(n)>=0||s.length===0)&&u.push(`inputIndices[${n}] = 0;`);return[`${u.join(`
`)}`,`var value = ${o.getByOffset("inputOffset")};`,`value = min(value, ${o.getByOffset("inputOffset")});`,""]})},Go=(e,t)=>{nt(e.inputs),at(e,"ReduceProd",t,(o,a)=>[`var value = ${a.type.storage}(1);`,"",`value *= ${o.getByOffset("inputOffset")};`,""])},Fo=(e,t)=>{nt(e.inputs),at(e,"ReduceSum",t,(o,a)=>[`var value = ${a.type.storage}(0);`,"",`value += ${o.getByOffset("inputOffset")};`,""])},Ho=(e,t)=>{nt(e.inputs),at(e,"ReduceSumSquare",t,(o,a)=>[`var t = ${a.type.value}(0); var value = ${a.type.value}(0);`,"",`t = ${o.getByOffset("inputOffset")}; value += t * t;`,""])},Ye=e=>oe(e)});var Lo,Vo,jo,qo,Un,Ko=H(()=>{"use strict";Me();Re();Nn();Lo=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},Vo=(e,t)=>oe({axis:t.axis,keepDims:t.keepDims,selectLastIndex:t.selectLastIndex}),jo=(e,t)=>{Lo(e.inputs);let r=(a,s,u)=>{let n=[];for(let d=0;d<a.rank;d++)(u.indexOf(d)>=0||u.length===0)&&n.push(`inputIndices[${d}] = 0;`);return[`${n.join(`
`)}`,`var value = ${a.getByOffset("inputOffset")};
var bestIndex : i32 = 0;`,`if (${a.getByOffset("inputOffset")} ${t.selectLastIndex>0?"<=":"<"} value) {
         value = ${a.getByOffset("inputOffset")};
         bestIndex = i32(lastIndex);
       }`,"",s.setByOffset("global_idx","bestIndex")]},o=e.inputs.length===1?t:Vo(e.inputs,t);e.compute(Fr("ArgMin",{hint:o.cacheKey},[e.inputs[0]],r,[o.axis],7,o.keepDims),{inputs:[0]})},qo=(e,t)=>{Lo(e.inputs);let r=(a,s,u)=>{let n=[];for(let d=0;d<a.rank;d++)(u.indexOf(d)>=0||u.length===0)&&n.push(`inputIndices[${d}] = 0;`);return[`${n.join(`
`)}`,`var value = ${a.getByOffset("inputOffset")};
var bestIndex : i32 = 0;`,`if (${a.getByOffset("inputOffset")} ${t.selectLastIndex>0?">=":">"} value) {
         value = ${a.getByOffset("inputOffset")};
         bestIndex = i32(lastIndex);
       }`,"",s.setByOffset("global_idx","bestIndex")]},o=e.inputs.length===1?t:Vo(e.inputs,t);e.compute(Fr("argMax",{hint:o.cacheKey},[e.inputs[0]],r,[o.axis],7,o.keepDims),{inputs:[0]})},Un=e=>oe(e)});var Tl,Rl,Yo,Xo=H(()=>{"use strict";me();$e();Tl=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Rl=e=>{let t=e[0].dims,r=e[0].dims[2],o=z.size(t)/4,a=e[0].dataType,s=q("input",a,t,4),u=q("bias",a,[r],4),n=q("residual",a,t,4),d=se("output",a,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:h=>`
  const channels = ${r}u / 4;
  ${h.declareVariables(s,u,n,d)}

  ${h.mainStart()}
    ${h.guardAgainstOutOfBoundsWorkgroupSizes(o)}
    let value = ${s.getByOffset("global_idx")}
      + ${u.getByOffset("global_idx % channels")} + ${n.getByOffset("global_idx")};
    ${d.setByOffset("global_idx","value")}
  }`}},Yo=e=>{Tl(e.inputs),e.compute(Rl(e.inputs))}});var kl,xe,Qo,Jo,Zo,ei,ti,ri,ni,ai,oi,Gn,Pl,ii,si,ui,li,Hr,di,Lr,ci,pi,fi,mi,hi,gi,yi,bi,wi,vi,$i,xi,Si,Ci,Ii,Ai,_i,Fn=H(()=>{"use strict";Me();me();Re();$e();kl=(e,t,r,o,a,s)=>{let u=Math.ceil(t/4),n="";typeof a=="string"?n=`${a}(a)`:n=a("a");let d=q("inputData",r,[u],4),p=se("outputData",o,[u],4);return`
  ${e.declareVariables(d,p)}

  ${s??""}

  ${e.mainStart()}
    ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}

    let a = ${d.getByOffset("global_idx")};
    ${p.setByOffset("global_idx",n)}
  }`},xe=(e,t,r,o,a,s=e.dataType)=>({name:t,shaderCache:{hint:a},getShaderSource:u=>kl(u,z.size(e.dims),e.dataType,s,r,o),getRunData:u=>({outputs:[{dims:e.dims,dataType:s}],dispatchGroup:{x:Math.ceil(z.size(u[0].dims)/64/4)}})}),Qo=e=>{e.compute(xe(e.inputs[0],"Abs","abs"))},Jo=e=>{e.compute(xe(e.inputs[0],"Acos","acos"))},Zo=e=>{e.compute(xe(e.inputs[0],"Acosh","acosh"))},ei=e=>{e.compute(xe(e.inputs[0],"Asin","asin"))},ti=e=>{e.compute(xe(e.inputs[0],"Asinh","asinh"))},ri=e=>{e.compute(xe(e.inputs[0],"Atan","atan"))},ni=e=>{e.compute(xe(e.inputs[0],"Atanh","atanh"))},ai=e=>oe(e),oi=(e,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute(xe(e.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},Gn=(e,t)=>{let r=ke(e.inputs[0].dataType);e.compute(xe(e.inputs[0],"Clip",o=>`clamp(${o}, clip_min_, clip_max_)`,`
    const clip_min_: vec4<${r}> = vec4(${r}(${t.min}));
    const clip_max_: vec4<${r}> = vec4(${r}(${t.max}));
`,t.cacheKey),{inputs:[0]})},Pl=e=>{let t=e.length>=2?e[1].getFloat32Array()[0]:Ur,r=e.length>=3?e[2].getFloat32Array()[0]:Gr;return oe({min:t,max:r})},ii=e=>{let t=Pl(e.inputs);Gn(e,t)},si=e=>{e.compute(xe(e.inputs[0],"Ceil","ceil"))},ui=e=>{e.compute(xe(e.inputs[0],"Cos","cos"))},li=e=>{e.compute(xe(e.inputs[0],"Cosh","cosh"))},Hr=e=>oe(e),di=(e,t)=>{e.compute(xe(e.inputs[0],"Elu",r=>`elu_vf32(${r})`,`
  const elu_alpha_: f32 = f32(${t.alpha});

  fn elu_f32(a: f32) -> f32 {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,t.cacheKey))},Lr=(e,t="f32")=>`
const r0: ${t} = 0.3275911;
const r1: ${t} = 0.254829592;
const r2: ${t} = -0.284496736;
const r3: ${t} = 1.421413741;
const r4: ${t} = -1.453152027;
const r5: ${t} = 1.061405429;

fn erf_vf32(v: ${e}) -> ${e} {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,ci=e=>{let t=ke(e.inputs[0].dataType);e.compute(xe(e.inputs[0],"Erf",r=>`erf_vf32(${r})`,Lr(`vec4<${t}>`,t)))},pi=e=>{e.compute(xe(e.inputs[0],"Exp","exp"))},fi=e=>{e.compute(xe(e.inputs[0],"Floor","floor"))},mi=e=>{let t=ke(e.inputs[0].dataType);e.compute(xe(e.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,Lr(`vec4<${t}>`,t)))},hi=(e,t)=>{e.compute(xe(e.inputs[0],"LeakyRelu",r=>`select(leaky_relu_alpha_ * ${r}, ${r}, ${r} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${t.alpha});`,t.cacheKey))},gi=e=>{e.compute(xe(e.inputs[0],"Not",t=>`!${t}`))},yi=e=>{e.compute(xe(e.inputs[0],"Neg",t=>`-${t}`))},bi=e=>{e.compute(xe(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},wi=e=>{e.compute(xe(e.inputs[0],"Relu",t=>`select(vec4<f32>(0.0), ${t}, ${t} > vec4<f32>(0.0))`))},vi=e=>{e.compute(xe(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},$i=e=>{e.compute(xe(e.inputs[0],"Sin","sin"))},xi=e=>{e.compute(xe(e.inputs[0],"Sinh","sinh"))},Si=e=>{e.compute(xe(e.inputs[0],"Sqrt","sqrt"))},Ci=e=>{e.compute(xe(e.inputs[0],"Tan","tan"))},Ii=e=>{e.compute(xe(e.inputs[0],"Tanh","tanh"))},Ai=(e,t)=>(e.compute(xe(e.inputs[0],"ThresholdedRelu",r=>`select(vec4<f32>(0.0), ${r}, ${r} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${t.alpha});`,t.cacheKey)),0),_i=e=>{e.compute(xe(e.inputs[0],"Log","log"))}});var Ml,Dl,Ei,Oi=H(()=>{"use strict";me();$e();Fn();Ml=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Dl=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=q("input",e[0].dataType,e[0].dims,4),o=q("bias",e[0].dataType,[e[0].dims[2]],4),a=se("output",e[0].dataType,t,4),s=z.size(t)/4;return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:n=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${e[0].dims[2]/4/2}u;

  ${n.declareVariables(r,o,a)}

  ${Lr("vec4f")}

  ${n.mainStart()}
    ${n.guardAgainstOutOfBoundsWorkgroupSizes(s)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${a.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},Ei=e=>{Ml(e.inputs),e.compute(Dl(e.inputs))}});var zl,Wl,ot,Ti,Ri,ki,Pi,Bi,Mi,Di,zi,Wi,Ni,Ui=H(()=>{"use strict";Me();me();$e();zl=(e,t,r,o,a,s,u,n,d,p,h)=>{let y=z.size(o),b=Math.ceil(y/4),w,$;typeof u=="string"?w=$=(B,W)=>`${u}((${B}),(${W}))`:typeof u=="function"?w=$=u:(w=u.scalar,$=u.vector);let v="",x=se("outputData",p,o,4),I=q("aData",n,t,4),R=q("bData",d,r,4);if(s){let B=W=>{let T=z.computeStrides(W),U=[];for(let F=W.length-1;F>=0;F--){let j=x.indicesGet("outputIndices",F+o.length-W.length);U.push(`${T[F]}u * (${j} % ${W[F]}u)`)}return U.length>0?U.join("+"):"0u"};v=`
          fn calcOffsetA(outputIndices: ${x.type.indices}) -> u32 {
            return ${B(t)};
          }

          fn calcOffsetB(outputIndices: ${x.type.indices}) -> u32 {
            return ${B(r)};
          }
        `}let M;if(a)if(s){let B=z.size(t)===1,W=z.size(r)===1;B||W?M=x.setByOffset("global_idx",$(B?`${I.type.value}(${I.getByOffset("0")}.x)`:I.getByOffset("global_idx"),W?`${R.type.value}(${R.getByOffset("0")}.x)`:R.getByOffset("global_idx"))):M=`
            let outputIndices = ${x.offsetToIndices("global_idx * 4u")};
            let offsetA = calcOffsetA(outputIndices);
            let offsetB = calcOffsetB(outputIndices);
            ${x.setByOffset("global_idx",$(I.getByOffset("offsetA / 4u"),R.getByOffset("offsetB / 4u")))}
          `}else M=x.setByOffset("global_idx",$(I.getByOffset("global_idx"),R.getByOffset("global_idx")));else{if(!s)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let B=(W,T,U="")=>{let F=`aData[indexA${T}][componentA${T}]`,j=`bData[indexB${T}][componentB${T}]`;return`
            let outputIndices${T} = ${x.offsetToIndices(`global_idx * 4u + ${T}u`)};
            let offsetA${T} = calcOffsetA(outputIndices${T});
            let offsetB${T} = calcOffsetB(outputIndices${T});
            let indexA${T} = offsetA${T} / 4u;
            let indexB${T} = offsetB${T} / 4u;
            let componentA${T} = offsetA${T} % 4u;
            let componentB${T} = offsetB${T} % 4u;
            ${W}[${T}] = ${U}(${w(F,j)});
          `};p===9?M=`
            var data = vec4<u32>(0);
            ${B("data",0,"u32")}
            ${B("data",1,"u32")}
            ${B("data",2,"u32")}
            ${B("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:M=`
            ${B("outputData[global_idx]",0)}
            ${B("outputData[global_idx]",1)}
            ${B("outputData[global_idx]",2)}
            ${B("outputData[global_idx]",3)}
          `}return`
        ${e.declareVariables(I,R,x)}

        ${h??""}
        ${v}

        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)}
        ${M}
      }`},Wl=(e,t,r,o,a,s,u=r.dataType)=>{let n=!z.areEqual(r.dims,o.dims),d=r.dims,p=z.size(r.dims),h=!1;if(n){let y=rt.calcShape(r.dims,o.dims,!1);if(!y)throw new Error("Can't perform binary op on the given tensors");d=y,p=z.size(d);let b=z.size(r.dims)===1,w=z.size(o.dims)===1,$=1;for(let v=1;v<d.length;v++){let x=r.dims[r.dims.length-v]??1,I=o.dims[o.dims.length-v]??1;if(x===I)$*=x;else break}($%4===0||b||w)&&(h=!0)}else h=!0;return{name:e,shaderCache:{hint:t},getShaderSource:y=>zl(y,r.dims,o.dims,d,h,n,a,r.dataType,o.dataType,u,s),getRunData:()=>({outputs:[{dims:d,dataType:u}],dispatchGroup:{x:Math.ceil(p/64/4)}})}},ot=(e,t,r,o,a,s)=>{e.compute(Wl(t,a??"",e.inputs[0],e.inputs[1],r,o,s))},Ti=e=>{ot(e,"Add",(t,r)=>`${t}+${r}`)},Ri=e=>{ot(e,"Div",(t,r)=>`${t}/${r}`)},ki=e=>{ot(e,"Equal",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},Pi=e=>{ot(e,"Mul",(t,r)=>`${t}*${r}`)},Bi=e=>{let t=q("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;ot(e,"Pow",{scalar:(o,a)=>`pow_custom(${o},${a})`,vector:(o,a)=>`pow_vector_custom(${o},${a})`},`
    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {
      if (b == ${t}(0.0)) {
        return ${t}(1.0);
      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {
        return ${t}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {
      // TODO: implement vectorized pow
      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},Mi=e=>{ot(e,"Sub",(t,r)=>`${t}-${r}`)},Di=e=>{ot(e,"Greater",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},zi=e=>{ot(e,"Less",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},Wi=e=>{ot(e,"GreaterOrEqual",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},Ni=e=>{ot(e,"LessOrEqual",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var Ul,Gl,Fl,Hl,Gi,Fi,Hi=H(()=>{"use strict";me();Re();$e();Ul=e=>{if(!e||e.length<1)throw new Error("too few inputs");let t=e[0].dataType,r=e[0].dims.length;for(let o of e){if(o.dataType!==t)throw new Error("input tensors should be one type");if(o.dims.length!==r)throw new Error("input tensors should have the same shape")}},Gl=e=>`
  fn calculateInputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${e}u;
  }`,Fl=(e,t)=>{let r=e.length,o=[];for(let a=0;a<r;++a){let s=t.setByOffset("global_idx",e[a].getByIndices("indices"));r===1?o.push(s):a===0?o.push(`if (inputIndex == ${a}u) { ${s} }`):a===r-1?o.push(`else { ${s} }`):o.push(`else if (inputIndex == ${a}) { ${s} }`)}return o.join(`
`)},Hl=(e,t)=>{let r=e[0].dims.slice();if(t>=r.length||t<-1*r.length)throw new Error("axis specified for concat doesn't match input dimensionality");let o=t<0?r.length+t:t,a=r.slice(0);for(let w=1;w<e.length;w++){let $=e[w].dims.slice();for(let v=0;v<r.length;v++)if(v===o)a[o]+=$[v];else if(r[v]!==$[v])throw new Error("non concat dimensions must match")}let s=z.size(a),u=new Array(e.length),n=new Array(e.length),d=e[0].dataType,p=0;for(let w=0;w<e.length;++w)p+=e[w].dims[o],u[w]=p,n[w]=q(`input${w}`,d,e[w].dims);let h=se("output",d,a),y=h.indicesGet("indices",o),b=w=>`
  ${w.declareVariables(...n,h)}

  const sizeInConcatAxis = array<u32, ${u.length}>(${u.map($=>`${$}u`).join(",")});
  ${Gl(u.length)}

  ${w.mainStart()}
    ${w.guardAgainstOutOfBoundsWorkgroupSizes(s)}

    var indices = ${h.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${y});
    if (inputIndex != 0u) {
      ${y} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${Fl(n,h)}
  }`;return{name:"Concat",shaderCache:{hint:`${t}`},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:b}},Gi=(e,t)=>{Ul(e.inputs),e.compute(Hl(e.inputs,t.axis))},Fi=e=>oe({axis:e.axis})});var De,Vr,jr,qr=H(()=>{"use strict";De=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Vr=(e,t=!1,r=!1,o=3)=>"",jr=(e,t)=>`
      ${e?"value = value + getBiasByOutputCoords(coords);":""}
      ${t?"value = activation(value, coords);":""}
      `});var Kr,Hn=H(()=>{"use strict";Kr=`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));
}
`});var Yr,Xr,dr=H(()=>{"use strict";me();Yr=e=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${e.clipMin});const clip_max_=f32(${e.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},Xr=e=>{let t=e?.activation||"";if(t==="Clip"){let[r,o]=e?.activation_params||[Ur,Gr];return{activation:t,clipMax:o,clipMin:r,activationCacheKey:`${t}:${r},${o}`}}return{activation:t,activationCacheKey:t}}});var Ll,Vl,cr,Li,jl,pr,ql,Qr,fr=H(()=>{"use strict";me();$e();dr();qr();Ll=(e,t)=>e?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${t?", batchIndices":""});
        `,Vl=(e,t)=>e?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,cr=(e,t,r="f32",o,a=!1,s=32,u=!1,n=32)=>{let d=t[1]*e[1],p=t[0]*e[0],h=a?d:s,y=a?s:d,b=h/t[0],w=s/t[1];if(!((a&&b===4&&e[1]===4||!a&&(b===3||b===4))&&h%t[0]===0&&s%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${a} is true, innerElementSize ${b} and workPerThread[1] ${e[1]} must be 4.
      Otherwise, innerElementSize ${b} must be 3 or 4.
  tileAWidth ${h} must be divisible by workgroupSize[0]${t[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${b}<${r}>, ${h/b}>, ${y}>;
var<workgroup> mm_Bsub: array<array<vec4<${r}>, ${p/e[0]}>, ${s}>;

const rowPerThread = ${e[1]};
const colPerThread = ${e[0]};
const innerElementSize = ${b};
const tileInner = ${s};

@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${u?"0":"i32(globalId.z)"};
  ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${d};

  let numTiles = ${u?`${Math.ceil(n/s)}`:"(dimInner - 1) / tileInner + 1"};
  var kStart = ${u?`i32(globalId.z) * ${n}`:"0"};

  var acc: array<vec4<${r}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${w};
  for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${Ll(a,o)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${o?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${b===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${Vl(a,b)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},Li=(e,t)=>e?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${t?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${t?", batchIndices":""});
            `,jl=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",pr=(e,t,r="f32",o,a=!1,s=32,u=!1,n=32,d=!1)=>{let p=e[1]*t[1],h=e[0]*t[0],y=a?p:s,b=a?s:p;if(!(b%t[1]===0&&y%t[0]===0&&s%t[1]===0))throw new Error(`tileAHight ${b} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${y} must be divisible by workgroupSize[0]${t[0]}, tileInner ${s} must be divisible by workgroupSize[1]${t[1]}`);let w=b/t[1],$=y/t[0],v=s/t[1],x=d?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${p};
    let globalColStart = i32(workgroupId.x) * ${h};

    // Loop over shared dimension.
    for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${b}; inputRow = inputRow + ${t[1]}) {
        for (var inputCol = localCol; inputCol < ${y}; inputCol = inputCol + ${t[0]}) {
          ${Li(a,o)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {
            for (var inputCol = localCol; inputCol < ${h}; inputCol = inputCol + ${t[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${o?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${r}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${a?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${t[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${t[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${p};

let tileRowA = i32(localId.y) * ${w};
let tileColA = i32(localId.x) * ${$};
let tileRowB = i32(localId.y) * ${v};
// Loop over shared dimension.
for (var t = 0; t < numTiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${$}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${Li(a,o)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${v}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${o?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${r}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${jl(a)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${r}, ${y}>, ${b}>;
  var<workgroup> mm_Bsub : array<array<${r}, ${h}>, ${s}>;
  const rowPerThread = ${e[1]};
  const colPerThread = ${e[0]};
  const tileInner = ${s};

@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${u?"0":"i32(globalId.z)"};
    ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}
    let numTiles = ${u?`${Math.ceil(n/s)}`:"(dimInner - 1) / tileInner + 1"};
    var kStart = ${u?`i32(globalId.z) * ${n}`:"0"};

    var acc : array<array<${r}, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${x}
  }
`},ql=(e,t,r,o,a,s=!1)=>{let u=a[0],n=a[1],d=a[2],p=o[0],h=o[1],y=o[2],b=o[3],w=Wn(u,d),$=Wn(n,d),v=ke(o[0].type.tensor),x=()=>{let M=h.rank,B=p.rank,W=`var aIndices: ${h.type.indices};`;for(let T=M-2-1,U=B-1;T>=0;T--,U--)W+=`
aIndices[${T}] = ${B>1?`batchIndices[${U}]`:"batchIndices"};`;return w.forEach(T=>{W+=`
aIndices[${T}] = 0;`}),W+=`
aIndices[${M-2}] = u32(row);
                   aIndices[${M-1}] = u32(colIn);`,W},I=()=>{let M=y.rank,B=p.rank,W=`var bIndices: ${y.type.indices};`;for(let T=M-2-1,U=B-1;T>=0;T--,U--)W+=`
bIndices[${T}] = ${B>1?`batchIndices[${U}]`:"batchIndices"};`;return $.forEach(T=>{W+=`
bIndices[${T}] = 0;`}),W+=`
bIndices[${M-2}] = u32(row);
                   bIndices[${M-1}] = u32(colIn);`,W};return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${p.type.indices}) -> ${De(e,v)} {
      var value = ${De(e,v)}(0.0);
      let col = colIn * ${e};
      if(row < dimAOuter && col < dimInner)
      {
        ${x()}
        value = ${h.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${p.type.indices}) -> ${De(e,v)} {
      var value = ${De(e,v)}(0.0);
      let col = colIn * ${e};
      if(row < dimInner && col < dimBOuter)
      {
        ${I()}
        value = ${y.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${De(e,v)}) {
      let col = colIn * ${e};
      if (row < dimAOuter && col < dimBOuter) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${t?`value = value + ${s?"bias[colIn]":`${De(e,v)}(bias[row])`};`:""}
        ${r}
        ${b.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},Qr=(e,t,r,o,a=!1)=>{let s=e[0].dims,u=e[1].dims,n=s.slice(0,-2),d=u.slice(0,-2),p=o?o.slice(0,-2):r.slice(0,-2),h=q("batchDims",e[0].dataType,p),y=[h],b=[n,d,p],w=z.size(p),$=s[s.length-2],v=s[s.length-1],x=u[u.length-1],I=v%4===0&&x%4===0,{activationFunction:R,applyActivation:M}=Yr(t),B=$<=8?[4,1,1]:[4,4,1],W=[8,8,1],T=[Math.ceil(x/W[0]/B[0]),Math.ceil($/W[1]/B[1]),Math.ceil(w/W[2]/B[2])],U=ke(e[0].dataType),F=I?4:1,j=q("a",e[0].dataType,[...n,$,v/F],F),le=q("b",e[1].dataType,[...d,v,x/F],F),P=se("result",e[0].dataType,[w,$,x/F],F);y.push(j),y.push(le),y.push(P);let X=[j,le],Ce=e.length>2,K=ql(F,Ce,M,y,b,a);if(Ce){let ze=a?F:1;X.push(q("bias",e[2].dataType,e[2].dims,ze))}let V=ze=>`
  const dimAOuter: i32 = ${$};
  const dimBOuter: i32 = ${x};
  const dimInner: i32 = ${v};
  ${ze.declareVariables(...X,P)}
  ${K}
  ${R}
  ${I?cr(B,W,U,h):pr(B,W,U,h)}
                   ${h.impl()}`;return{name:"MatMul",shaderCache:{hint:t.activationCacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:T[0],y:T[1],z:T[2]}}),getShaderSource:V}}});var Kl,Vi,ji=H(()=>{"use strict";ft();me();$e();qr();Hn();fr();Kl=(e,t,r,o,a=!1,s,u=!1,n=4,d=4,p=4,h="f32")=>{let y=le=>{switch(le){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${h}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${le} is not supported.`)}},b=le=>{switch(le){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${le} is not supported.`)}},w=e?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,$=e?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,v=e?"xShape[1]":"xShape[2]",x=e?"xShape[2]":"xShape[3]",I=e?"row":"col",R=e?"col":"row",M=`
    let inChannels = wShape[2];
    let outWidth = ${e?"outShape[2]":"outShape[3]"};
    let outRow = ${I} / outWidth;
    let outCol = ${I} % outWidth;

    let WRow = ${R} / (filterDims[1] * inChannels);
    let WCol = ${R} / inChannels % filterDims[1];
    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];
    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];
    let xCh = ${R} % inChannels;
    var resData = ${De(n,h)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${v} && xCol >= 0 && xCol < ${x}) {
      ${w}
      let xIndex = getIndexFromCoords4D(coord, xShape);
      ${y(n)}
    }
    return resData;`,B=e?t&&o?`
    let col = colIn * ${n};
    ${M}`:`
    let col = colIn * ${n};
    if (row < dimAOuter && col < dimInner) {
      ${M}
    }
    return ${De(n,h)}(0.0);`:o&&r?`
    let col = colIn * ${n};
    ${M}`:`
    let col = colIn * ${n};
    if (row < dimInner && col < dimBOuter) {
      ${M}
    }
    return ${De(n,h)}(0.0);`,W=`${b(d)}`,T=De(p,h),U=e?De(n,h):De(d,h),F=e?De(d,h):De(n,h);return`
    ${Vr(s,u,p===4,4)}
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${U} {
      ${e?B:W}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${F} {
      ${e?W:B}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${T}) {
      let col = colIn * ${p};
      if (row < dimAOuter && col < dimBOuter)
      {
      var value = valueIn;
      let outWidth = ${e?"outShape[2]":"outShape[3]"};
      ${$}
      ${jr(a,s)}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},Vi=(e,t,r,o,a,s,u,n)=>{let d=t.format==="NHWC",p=d?e[0].dims[3]:e[0].dims[1],h=r[0],y=d?r[2]:r[3],b=d?r[1]:r[2],w=d?r[3]:r[1],$=d&&(p%4===0||p%3===0)&&w%4===0,v=d?w:y*b,x=d?y*b:w,I=[8,8,1],R=o<=8?[4,1,1]:[4,4,1],M=[Math.ceil(v/I[0]/R[0]),Math.ceil(x/I[1]/R[1]),Math.ceil(h/I[2]/R[2])];_e("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${M}`);let B=$?d&&p%4!==0?3:4:R[0],W=I[1]*R[1],T=I[0]*R[0],U=Math.max(I[0]*B,I[1]),F=o%W===0,j=a%T===0,le=s%U===0,P=$?[B,4,4]:[1,1,1],X=ke(e[0].dataType),Ce=[`@group(0) @binding(0) var<storage, read> x: array<${$&&B===4?`vec4<${X}>`:X}>;`,`@group(0) @binding(1) var<storage, read> w: array<${$?`vec4<${X}>`:X}>;`],K=`
      fn setOutputAtIndex(flatIndex : i32, value : ${$?`vec4<${X}>`:X}) {
        result[flatIndex] = ${$?`vec4<${X}>`:X}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${$?`vec4<${X}>`:X}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${$?"/ 4":""}, value);
      }`;return u&&(Ce.push(`@group(0) @binding(2) var<storage, read> bias: array<${$?`vec4<${X}>`:X}>;`),K+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${$?`vec4<${X}>`:X} {
          return bias[coords.${d?"w":"y"}${$?"/ 4":""}];
        }`),{name:"Conv2DMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:M[0],y:M[1],z:M[2]}}),getShaderSource:()=>`
        ${Kr}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${Ce.join("")}
        @group(0) @binding(${Ce.length}) var<storage, read_write> result: array<${$?`vec4<${X}>`:X}>;
        //@group(0) @binding(${Ce.length+1}) var<uniform> uniforms: Uniforms;

        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${z.computeStrides(r).slice(0,3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[0]}, ${t.kernelShape[1]});
        const pad : vec2<i32> = vec2<i32>(${t.pads[0]}, ${t.pads[1]});
        const stride : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});
        const dimAOuter : i32 = ${o};
        const dimBOuter : i32 = ${a};
        const dimInner : i32 = ${s};
        ${K}
        ${Kl(d,F,j,le,u,void 0,!1,P[0],P[1],P[2],X)}
            ${$?cr(R,I,X,void 0,!d,U):pr(R,I,X,void 0,!d,U,!1,void 0,n)}`}}});var Ln,qi=H(()=>{"use strict";me();$e();jn();dr();Ln=(e,t,r)=>{let o=e.length>2,a=o?"value += b[output_channel];":"",s=e[0].dims,u=e[1].dims,n=u[0]/t.group,{activationFunction:d,applyActivation:p}=Yr(t),h=t.format==="NHWC",y=Vn(s,u,t.dilations,t.pads,t.strides,h),b=z.size(y),w=se("output",e[0].dataType,y),$=q("x",e[0].dataType,s),v=q("w",e[1].dataType,u),x=[$,v];o&&x.push(q("b",e[2].dataType,e[2].dims));let I=R=>`
  const strides: vec2<u32> = vec2(${t.strides[0]}u, ${t.strides[1]}u);
  const pads: vec2<u32> = vec2(${t.pads[0]}u, ${t.pads[1]}u);

  ${R.declareVariables(...x,w)}

  ${d}

  ${R.mainStart()}
    ${R.guardAgainstOutOfBoundsWorkgroupSizes(b)}

    let outputIndices = ${w.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${h?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${h?1:2}], outputIndices[${h?2:3}]) * strides - pads;
    let group_id: u32 = output_channel / ${n}u;

    var value: ${w.type.value} = ${w.type.value}(0);
    for (var wInChannel: u32 = 0u; wInChannel < ${u[1]}u; wInChannel++) {
      let input_channel = group_id * ${u[1]}u + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < ${u[2]}u; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * ${t.dilations[0]}u;

        if (xHeight < 0u || xHeight >= ${s[h?1:2]}u) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < ${u[3]}u; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * ${t.dilations[1]}u;
          if (xWidth < 0u || xWidth >= ${s[h?2:3]}u) {
            continue;
          }

          let xVal = ${h?$.get("batch","xHeight","xWidth","input_channel"):$.get("batch","input_channel","xHeight","xWidth")};
          let wVal = ${v.get("output_channel","wInChannel","wHeight","wWidth")};
          value += xVal*wVal;
        }
      }
    }
    ${a}
    ${p}
    ${w.setByOffset("global_idx","value")}
  }`;return{name:"GroupedConv",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r?r(y):y,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(b/64)}}),getShaderSource:I}}});var Yl,Ki,Xl,Ql,Nt,Yi,Xi,Jr=H(()=>{"use strict";me();Re();$e();Yl=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},Ki=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,Xl=(e,t)=>z.sortBasedOnPerm(e,Ki(e.length,t)),Ql=(e,t,r,o)=>{let a=[];a.push(`fn perm(i: ${o.type.indices}) -> ${r.type.indices} {
    var a: ${r.type.indices};`);for(let s=0;s<t;++s)a.push(r.indicesSet("a",e[s],`i[${s}]`));return a.push("return a;}"),a.join(`
`)},Nt=(e,t,r)=>{let o=Ki(t,r),a=se("output",e,r&&r.length||t),s=q("a",e,t),u=n=>`
  ${n.registerUniform("output_size","u32").declareVariables(s,a)}

  ${Ql(o,t,s,a)}

  ${n.mainStart()}
    ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${a.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${a.setByOffset("global_idx",s.getByIndices("aIndices"))}
  }`;return{name:"Transpose",shaderCache:{hint:`${r}`,inputDependencies:["rank"]},getRunData:n=>{let d=Xl(n[0].dims,o),p=z.size(d);return{outputs:[{dims:d,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:[{type:"uint32",data:p},...zn(n[0].dims),...zn(d)]}},getShaderSource:u}},Yi=(e,t)=>{Yl(e.inputs),e.compute(Nt(e.inputs[0].dataType,e.inputs[0].dims.length,t.perm))},Xi=e=>oe({perm:e.perm})});var Vn,Qi,Jl,Ji,Zi,Zl,ed,es,jn=H(()=>{"use strict";me();Re();ji();fr();qi();dr();Jr();Vn=(e,t,r,o,a,s)=>{let u=e[0],n=e.slice(s?1:2,s?3:4),d=n.length,p=t[0],y=t.slice(2).map(($,v)=>$+($-1)*(r[v]-1)),w=n.map(($,v)=>$+o[v]+o[v+d]).map(($,v)=>Math.floor(($-y[v]+a[v])/a[v]));return w.splice(0,0,u),w.splice(s?3:1,0,p),w},Qi=[2,3,1,0],Jl=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[1]*t.group;if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let a=e[0].dims.length-2;if(t.dilations.length!==a)throw new Error(`dilations should be ${a}D`);if(t.strides.length!==a)throw new Error(`strides should be ${a}D`);if(t.pads.length!==a*2)throw new Error(`pads should be ${a*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},Ji=(e,t)=>{let r=e.kernelShape.slice();for(let s=2;s<t[1].dims.length;++s)r[s-2]===0&&(r[s-2]=t[1].dims[s]);let o=e.pads.slice();_t.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,o,e.format==="NHWC",e.autoPad);let a=Object.assign({},e);return Object.assign(a,{kernelShape:r,pads:o,cacheKey:e.cacheKey}),a},Zi=e=>{let t=Xr(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],a=e.dilations,s=e.group,u=e.kernel_shape,n=e.pads,d=e.strides,p=e.w_is_const();return oe({autoPad:o,format:r,dilations:a,group:s,kernelShape:u,pads:n,strides:d,wIsConst:p,...t})},Zl=(e,t,r)=>{let o=Ji(r,t);if(r.group!==1){e.compute(Ln(t,o));return}let a=r.format==="NHWC",s=t.length===3,u=t[0].dims[a?1:2],n=t[0].dims[a?2:3],d=t[0].dims[a?3:1],p=t[1].dims[2],h=t[1].dims[3],y=Vn(t[0].dims,t[1].dims,r.dilations,o.pads,r.strides,a),b=y[a?1:2],w=y[a?2:3],$=y[a?3:1],v=a&&p===u&&h===n&&r.pads[0]===0&&r.pads[1]===0;if(v||p===1&&h===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let T=y[0],U,F,j,le=[];if(a){let P=e.kernelCustomData.wT??e.compute(Nt(t[1].dataType,t[1].dims.length,Qi),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=P),v){let X=u*n*d;U=t[0].reshape([1,T,X]),F=P.reshape([1,X,$]),j=[1,T,$]}else U=t[0].reshape([T,u*n,d]),F=P.reshape([1,d,$]),j=[T,b*w,$];le.push(U),le.push(F)}else U=t[0].reshape([T,d,u*n]),F=t[1].reshape([1,$,d]),j=[T,$,b*w],le.push(F),le.push(U);s&&le.push(t[2]),e.compute(Qr(le,o,y,j,a),{inputs:le});return}let x=!0,I=e.kernelCustomData.wT??e.compute(Nt(t[1].dataType,t[1].dims.length,Qi),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=I);let R=[t[0],I];s&&R.push(t[2]);let M=a?b*w:$,B=a?$:b*w,W=p*h*d;e.compute(Vi(R,o,y,M,B,W,s,x),{inputs:R})},ed=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&o.push(e.inputs[2]);let a=[0,t.pads[0],0,t.pads[1]],s=[1].concat(t.strides),u=[1].concat(t.dilations),n=[1].concat(t.kernelShape),d=Ji({...t,pads:a,strides:s,dilations:u,kernelShape:n},o);e.compute(Ln(o,d,p=>r?[p[0],p[2],p[3]]:[]))},es=(e,t)=>{Jl(e.inputs,t),e.inputs[0].dims.length===3?ed(e,t):Zl(e,e.inputs,t)}});var td,ts,rs=H(()=>{"use strict";ft();me();qr();Hn();fr();td=(e,t=!1,r,o=!1,a=4)=>{let s=De(a,"f32"),u=I=>{switch(I){case 1:return"return W[getIndexFromCoords4D(coord, wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${I} is not supported.`)}},n=e?`
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `,d=e?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,p=e?"outBackprop[1]":"outBackprop[2]",h=e?"outBackprop[2]":"outBackprop[3]",y=e?"row":"col",b=e?"col":"row",w=`
      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};
      let outWidth = ${e?"outShape[2]":"outShape[3]"};
      let outRow = ${y} / outWidth;
      let outCol = ${y} % outWidth;

      let WRow = ${b} / (filterDims[1] * inChannels);
      let WCol = ${b} / inChannels % filterDims[1];
      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);
      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);
      if (xR < 0.0 || xR >= f32(${p}) || fract(xR) > 0.0) {
        return ${s}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${h}) || fract(xC) > 0.0) {
        return ${s}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${b} % inChannels;
      ${n}
      return x[getIndexFromCoords4D(coord, xShape)/${a}];`,$=e?`
      let col = colIn * ${a};
      if (row < dimAOuter && col < dimInner) {
        ${w}
      }
      return ${s}(0.0);`:`
      let col = colIn * ${a};
      if (row < dimInner && col < dimBOuter) {
        ${w}
      }
      return ${s}(0.0);`,v=`
      let col = colIn * ${a};
      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};
      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);
      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];
      if (${e?"row < dimInner && col < dimBOuter":"row < dimInner && col < dimAOuter"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${u(a)}
      }
      return ${s}(0.0);
      `;return`
  ${Vr(r,o,a===4,4)}
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${s} {
    ${e?$:v}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${s} {
    ${e?v:$}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${s}) {
    let col = colIn * ${a};
    if (row < dimAOuter && col < dimBOuter) {
      var value = valueInput;
      let outWidth = ${e?"outShape[2]":"outShape[3]"};
      ${d}
      ${jr(t,r)}
      result[getIndexFromCoords4D(coords, outShape)/${a}] = value;
    }
  }`},ts=(e,t,r,o,a,s,u,n)=>{let d=t.format==="NHWC",p=d?e[0].dims[3]:e[0].dims[1],h=r[0],y=d?r[2]:r[3],b=d?r[1]:r[2],w=d?r[3]:r[1],$=d?p%4===0&&w%4===0:y%4===0&&w%4===0,v=d?w:y*b,x=d?y*b:w,I=$?[8,8,1]:[v<=4||x<=4?4:16,v>4&&x<=4?4:16,1],R=$?[4,4,1]:[v<=4?1:4,v>4&&x<=4?1:4,1],M=[Math.ceil(v/I[0]/R[0]),Math.ceil(x/I[1]/R[1]),Math.ceil(h/I[2]/R[2])];_e("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${M}`);let B=$?4:1,W=Math.max(I[0]*B,I[1]),T=[`@group(0) @binding(0) var<storage, read> x: array<${$?"vec4<f32>":"f32"}>;`,"@group(0) @binding(1) var<storage, read> W: array<f32>;"],U="";return u&&(T.push(`@group(0) @binding(2) var<storage, read> bias: array<${$?"vec4<f32>":"f32"}>;`),U+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${$?"vec4<f32>":"f32"} {
          return bias[coords.${d?"w":"y"}${$?"/ 4":""}];
        }`),{name:"Conv2DTransposeMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:M[0],y:M[1],z:M[2]}}),getShaderSource:()=>`
        ${Kr}
        ${T.join(`
`)}
        @group(0) @binding(${T.length}) var<storage, read_write> result: array<${$?"vec4<f32>":"f32"}>;
        const outBackprop : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});
        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${z.computeStrides(r).slice(0,3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[d?1:2]}, ${t.kernelShape[d?2:3]});
        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(
              ${t.dilations[0]<=1?0:(t.kernelShape[d?1:2]-1)*(t.dilations[0]-1)},
              ${t.dilations[1]<=1?0:(t.kernelShape[d?2:3]-1)*(t.dilations[1]-1)});
        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${t.pads[0]+t.pads[2]})/2,
                                         i32(effectiveFilterDims[1]) - 1 - (${t.pads[1]+t.pads[3]})/2);
        const strides : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});
        const dimAOuter : i32 = ${o};
        const dimBOuter : i32 = ${a};
        const dimInner : i32 = ${s};
        ${U}
        ${td(d,u,void 0,!1,B)}
        ${$?cr(R,I,"f32",void 0,!d,W):pr(R,I,"f32",void 0,!d,W,!1,void 0,n)}`}}});var rd,qn,ns=H(()=>{"use strict";ft();me();$e();rd=(e,t,r,o,a,s,u=!1,n)=>{let d=r.format==="NHWC",p=d?1:2,h=d?2:3,y=d?3:1,b=z.size(o),w=u?2:1,$=r.group,v=t[1].dims,x=v[0]/$,I=v[1],R=`
  fn setOutputAtIndex(flatIndex : u32, value : ${u?`vec4<${n}>`:n}) {
    result[flatIndex] = ${u?`vec4<${n}>`:n}(value);
  }`;a&&(R+=`
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${u?`vec4<${n}>`:n} {
      return bias[coords.${d?"w":"y"}${u?"/ 4":""}];
    }`);let M=u?4:1,B=q("W",t[1].dataType,t[1].dims,M),W=q("Dy",t[0].dataType,t[0].dims,M),T=[W,B];a&&T.push(q("bias",t[2].dataType,[o[y]],M));let U=se("result",t[0].dataType,o,M),F=`{
        let batch: u32 = ${s?"global_id.z":"workgroup_id.z"} / outShape[1];
        let r = ${s?"global_id.z":"workgroup_id.z"} % outShape[1];
        let c = ${s?"global_id.y":"workgroup_id.y"} * ${w};
        let d1: u32 = ${s?"global_id.x":"workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${n}>, ${w}>;
        for (var i = 0; i < ${w}; i++) {
          dotProd[i] = vec4<${n}>(0.0);
        }
        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {
          var dyR = (${n}(dyCorner.x) + ${n}(wR)) / ${n}(strides.x);
          let wRPerm = filterDims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${n}(outBackprop[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {
            let dyC = (${n}(dyCorner.y) + ${n}(wC)) / ${n}(strides.y);
            let dyC2 = (${n}(dyCorner.y) + 1.0 + ${n}(wC)) / ${n}(strides.y);
            let wCPerm = filterDims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${n}(outBackprop[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${n}(outBackprop[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${W.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${n}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${W.get("batch","idyR","idyC2","d2")};

                dotProd[1] = dotProd[1] + vec4<${n}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = outBackprop[${y}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${W.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${n}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${B.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${W.get("batch","idyR","idyC2","d2")};
                let tmpval = vec4<${n}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${w}; i = i + 1) {
          let value = dotProd[i] + ${a?"bias[c+i]":"0.0"};
          ${U.set("batch","r","c + i","d1","value")};
        }
      }`,j=`
          let outputIndices = ${U.offsetToIndices("global_idx")};
          let batch = ${U.indicesGet("outputIndices",0)};
          let d1 = ${U.indicesGet("outputIndices",y)};
          let r = ${U.indicesGet("outputIndices",p)};
          let c = ${U.indicesGet("outputIndices",h)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / ${I};
          let wOutChannel = d1 - groupId * ${I};
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = 0.0;
          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {
            if (wR % dilations.x != 0) {
              continue;
            }
            let dyR = (${n}(dyRCorner) + ${n}(wR)) / ${n}(strides[0]);
            let wRPerm = filterDims.x - 1 - wR / dilations.x;
            if (dyR < 0.0 || dyR >= ${n}(outBackprop[${p}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {
              if (wC % dilations.y != 0) {
                continue;
              }
              let dyC = (${n}(dyCCorner) + ${n}(wC)) / ${n}(strides.y);
              let wCPerm = filterDims.y - 1 - wC / dilations.y;
              if (dyC < 0.0 || dyC >= ${n}(outBackprop[${h}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * ${x};
              for (var d2: u32 = 0; d2 < ${x}; d2 = d2 + 1) {
                let xValue = ${d?W.get("batch","idyR","idyC","inputChannel"):W.get("batch","inputChannel","idyR","idyC")};
                let wValue = ${B.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${a?"bias[d1]":"0.0"};
          ${U.setByOffset("global_idx","value")};
        `;return`
  ${e.declareVariables(...T,U)}
  ${R}
  const outShape : vec4<u32> = vec4<u32>(${o.join(",")});
  const outBackprop : vec4<u32> = vec4<u32>(${t[0].dims.join(",")});
  const strides : vec2<u32> = vec2<u32>(${r.strides[0]}, ${r.strides[1]});
  const filterDims : vec2<u32> = vec2<u32>(${r.kernelShape[d?1:2]}, ${r.kernelShape[d?2:3]});
  const dilations : vec2<u32> = vec2<u32>(${r.dilations[0]}, ${r.dilations[1]});
  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(
          ${r.dilations[0]<=1?0:(r.kernelShape[d?1:2]-1)*(r.dilations[0]-1)},
          ${r.dilations[1]<=1?0:(r.kernelShape[d?2:3]-1)*(r.dilations[1]-1)});
  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${r.pads[0]+r.pads[2]})/2,
                                     i32(effectiveFilterDims[1]) - 1 - (${r.pads[1]+r.pads[3]})/2);
    ${e.mainStart()}
    ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)};
  ${u?F:j}}`},qn=(e,t,r)=>{let o=e.length>2,a=t.outputShape,s=z.size(a),u=[Math.ceil(s/64),1,1];_e("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${u}`);let n=ke(e[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:t.cacheKey},getRunData:()=>({dispatchGroup:{x:u[0],y:u[1],z:u[2]},outputs:[{dims:r?r(a):a,dataType:e[0].dataType}]}),getShaderSource:d=>rd(d,e,t,a,o,u[1]===1&&u[2]===1,!1,n)}}});var nd,ad,od,as,os,id,sd,ud,ld,is,ss=H(()=>{"use strict";Re();rs();ns();dr();Jr();nd=(e,t,r,o,a,s)=>(e-1)*t+r+(o-1)*a+1-s,ad=(e,t,r,o,a)=>{let s=Math.floor(e/2);t==="SAME_UPPER"?(r[o]=s,r[a]=e-s):t==="SAME_LOWER"&&(r[o]=e-s,r[a]=s)},od=(e,t,r,o,a,s,u,n,d,p)=>{let h=e.length-2,y=p.length===0;if(d.length===0)for(let $=0;$<h;++$)d.push(0);let b=e[0],w=t[n?3:1]*a;for(let $=0,v=e.length-h-(n?1:0);$<h;++$,++v){let x=e[v],I=y?x*u[$]:p[$],R=nd(x,u[$],s[$],t[v],r[$],I);ad(R,o,s,$,$+h),y&&p.push(u[$]*(x-1)+d[$]+(t[v]-1)*r[$]+1-s[$]-s[$+h])}p.splice(0,0,b),p.splice(n?3:1,0,w)},as=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((b,w)=>b*w,1)===0){r.length=0;for(let b=2;b<t[1].dims.length;++b)r.push(t[1].dims[b])}let o=e.format==="NHWC";r.splice(0,0,t[1].dims[0]),r.splice(o?3:1,0,t[1].dims[1]);let a=e.pads.slice(),s=e.outputShape.slice(),u=e.outputPadding.slice(),n=t[0].dims,d=e.dilations.slice();if(d.reduce((b,w)=>b+w,0)===0){let b=t[0].dims.length-2;d=new Array(b).fill(1)}let p=e.strides.slice();if(p.reduce((b,w)=>b+w,0)===0){let b=t[0].dims.length-2;p=new Array(b).fill(1)}od(n,r,d,e.autoPad,e.group,a,p,o,u,s);let h=Object.assign({},e),y=e.cacheKey+[r.join("n,"),a.join(","),p.join(","),u.join(","),s.join(","),d.join(",")].join("_");return Object.assign(h,{kernelShape:r,pads:a,outputPadding:u,outputShape:s,dilations:d,strides:p,cacheKey:y}),h},os=e=>{let t=Xr(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],a=e.dilations,s=e.group,u=e.kernelShape,n=e.pads,d=e.strides,p=e.wIsConst(),h=e.outputPadding,y=e.outputShape;return oe({autoPad:o,format:r,dilations:a,group:s,kernelShape:u,outputPadding:h,outputShape:y,pads:n,strides:d,wIsConst:p,...t})},id=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[0];if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let a=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==a))throw new Error("invalid bias");let s=e[0].dims.length-2;if(t.dilations.reduce((h,y)=>h+y,0)>0&&t.dilations.length!==s)throw new Error(`dilations should be ${s}D`);if(t.strides.reduce((h,y)=>h+y,0)>0&&t.strides.length!==s)throw new Error(`strides should be ${s}D`);if(t.pads.reduce((h,y)=>h+y,0)>0&&t.pads.length!==s*2)throw new Error(`pads should be ${s*2}D`);if(t.outputPadding.length!==s&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${s}D`);if(t.kernelShape.reduce((h,y)=>h+y,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},sd=[2,3,1,0],ud=(e,t,r)=>{let o=as(r,t),a=r.format==="NHWC",s=t.length===3;if(o.group!==1){e.compute(qn(t,o));return}let u=o.outputShape,n=u[a?1:2],d=u[a?2:3],p=u[a?3:1],h=t[1].dims[2],y=t[1].dims[3],b=t[0].dims[a?3:1],w=a?n*d:p,$=a?p:n*d,v=h*y*b,x=!0,I=e.kernelCustomData.wT??e.compute(Nt(t[1].dataType,t[1].dims.length,sd),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=I);let R=[t[0],I];s&&(!a&&t[2].dims.length===1?R.push(t[2].reshape([t[2].dims[0],1,1])):R.push(t[2])),e.compute(ts(R,o,u,w,$,v,s,x),{inputs:R})},ld=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];o.length===3&&o.push(e.inputs[2]);let a=t.kernelShape;(a.length===0||a[0]===0)&&(a=[e.inputs[1].dims[2]]);let s=t.dilations;(s.length===0||s[0]===0)&&(s=[1]);let u=t.strides;(u.length===0||u[0]===0)&&(u=[1]);let n=t.pads;n.length===0&&(n=[0,0]),n=[0,n[0],0,n[1]],u=[1].concat(u),s=[1].concat(s),a=[1].concat(a);let d=as({...t,pads:n,strides:u,dilations:s,kernelShape:a},o);e.compute(qn(o,d,p=>r?[p[0],p[2],p[3]]:[p[0],p[1],p[3]]))},is=(e,t)=>{id(e.inputs,t),e.inputs[0].dims.length===3?ld(e,t):ud(e,e.inputs,t)}});var Kn,Zr,us,dd,cd,Yn,Xn,pd,ls,ds,cs=H(()=>{"use strict";me();Re();$e();Kn="[a-zA-Z]|\\.\\.\\.",Zr="("+Kn+")+",us="^"+Zr+"$",dd="("+Zr+",)*"+Zr,cd="^"+dd+"$",Yn=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let o=this.symbolToIndices.get(t);o===void 0?o=[r]:o.push(r),this.symbolToIndices.set(t,o)}},Xn=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[o,a]=r.includes("->")?r.split("->",2):[r,""];if(!o.match(RegExp(cd)))throw new Error("Invalid LHS term");if(o.split(",").forEach((n,d)=>{let p=t[d].dims.slice();if(!n.match(RegExp(us)))throw new Error("Invalid LHS term");let h=this.processTerm(n,!0,p,d);this.lhs.push(h)}),a==="")a+=[...this.symbolToInfo.entries()].filter(([n,d])=>d.count===1||n==="...").map(([n])=>n).join("");else if(!a.match(RegExp(Zr)))throw new Error("Invalid RHS");a.match(RegExp(Kn,"g"))?.forEach(n=>{if(n==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let d=this.symbolToInfo.get(n);if(d===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(d.dimValue)}}),this.rhs=this.processTerm(a,!0,this.outputDims)}addSymbol(t,r,o){let a=this.symbolToInfo.get(t);if(a!==void 0){if(a.dimValue!==r&&a.count!==1)throw new Error("Dimension mismatch");a.count++,a.inputIndices.push(o)}else a={count:1,dimValue:r,inputIndices:[o]};this.symbolToInfo.set(t,a)}processTerm(t,r,o,a=-1){let s=o.length,u=!1,n=[],d=0;if(!t.match(RegExp(us))&&!r&&t!=="")throw new Error("Invalid LHS term");let p=t.match(RegExp(Kn,"g")),h=new Yn(a);return p?.forEach((y,b)=>{if(y==="..."){if(u)throw new Error("Only one ellipsis is allowed per input term");u=!0;let w=s-p.length+1;if(w<0)throw new Error("Ellipsis out of bounds");if(n=o.slice(d,d+w),this.hasEllipsis){if(this.ellipsisDims.length!==n.length||this.ellipsisDims.toString()!==n.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=n;else throw new Error("Ellipsis must be specified in the LHS");for(let $=0;$<n.length;$++){let v=String.fromCharCode("0".charCodeAt(0)+b);h.addSymbol(v,b+$),this.addSymbol(v,o[d++],a)}}else h.addSymbol(y,b),this.addSymbol(y,o[d++],a)}),h}},pd=(e,t)=>{let r=e[0].dataType,o=new Array(e.length);for(let M=0;M<e.length;++M)o[M]=q(`input${M}`,r,e[M].dims);let a=t.outputDims,s=z.size(a),u=se("output",r,a),n=[],d=Array.from(t.rhs.symbolToIndices.keys()),p="var prod = 1.0;",h="var sum = 0.0;",y="sum += prod;",b=[],w=[],$=[],v=[],x=t.symbolToInfo.size===d.length;t.symbolToInfo.forEach((M,B)=>{if(d.includes(B)){let W=d.indexOf(B);t.lhs.forEach((T,U)=>{if(M.inputIndices.includes(U)){let F=T.symbolToIndices.get(B);if(F===void 0)throw new Error("Invalid symbol error");F.forEach(j=>{n.push(`${o[U].indicesSet(`input${U}Indices`,j,u.indicesGet("outputIndices",W))}`)})}})}else t.lhs.forEach((W,T)=>{let U=t.symbolToInfo.get(B);if(U===void 0)throw new Error("Invalid symbol error");if(U.inputIndices.includes(T)){let F=W.symbolToIndices.get(B);if(F===void 0)throw new Error("Invalid symbol error");F.forEach(j=>{b.push(`${o[T].indicesSet(`input${T}Indices`,j,`${B}`)}`)}),v.push(`prod *= ${o[T].getByIndices(`input${T}Indices`)};`)}}),w.push(`for(var ${B}: u32 = 0; ${B} < ${t.symbolToInfo.get(B)?.dimValue}; ${B}++) {`),$.push("}")});let I=x?[...n,`let sum = ${o.map((M,B)=>M.getByIndices(`input${B}Indices`)).join(" * ")};`]:[...n,h,...w,...b,p,...v,y,...$],R=M=>`
      ${M.declareVariables(...o,u)}

      ${M.mainStart()}
        ${M.guardAgainstOutOfBoundsWorkgroupSizes(s)}
        var outputIndices = ${u.offsetToIndices("global_idx")};
        ${o.map((B,W)=>`var input${W}Indices: ${o[W].type.indices};`).join(`
`)}
        ${I.join(`
`)};
        ${u.setByOffset("global_idx","sum")};
      }`;return{name:"Einsum",shaderCache:{hint:t.equation},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:R}},ls=(e,t)=>{let r=new Xn(e.inputs,t.equation);e.compute(pd(e.inputs,r))},ds=e=>{let t=e.equation.replace(/\s+/g,"");return oe({equation:t})}});var fd,ps,md,hd,fs,ms=H(()=>{"use strict";me();$e();fd=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=r.length<t.length?0:r.length-t.length,a=t.length<r.length?0:t.length-r.length;for(;o<r.length&&a<t.length;++o,++a)if(r[o]!==t[a]&&r[o]!==1&&t[a]!==1)throw new Error("Expand requires shape to be broadcastable to input")},ps=(e,t)=>{let r=e.length-t.length,o=[];for(let a=0;a<r;++a)o.push(e[a]);for(let a=0;a<t.length;++a)o.push(t[a]===1?e[a+r]:t[a]);return o},md=(e,t)=>e.length>t.length?ps(e,t):ps(t,e),hd=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=md(t,r),a=z.size(o),s=e[0].dataType,u=q("input",s,t),n=se("output",s,o),d=p=>`
  const inputShape = ${u.indices(...t)};
  ${p.declareVariables(u,n)}
  ${p.mainStart()}
  ${p.guardAgainstOutOfBoundsWorkgroupSizes(a)}
    let outputIndices = ${n.offsetToIndices("global_idx")};
    var inputIndices: ${u.type.indices};
    for (var i = 0; i < ${t.length}; i++) {
      if (${u.indicesGet("inputShape","i")} == 1) {
        ${u.indicesSet("inputIndices","i",0)}
      } else {
        ${u.indicesSet("inputIndices","i",n.indicesGet("outputIndices",`i + ${o.length-t.length}`))}
      }
    }
    ${n.setByOffset("global_idx",u.getByIndices("inputIndices"))}
  }`;return{name:"Expand",shaderCache:{hint:`${o}`},getShaderSource:d,getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}})}},fs=e=>{fd(e.inputs),e.compute(hd(e.inputs),{inputs:[0]})}});var gd,yd,hs,gs,ys=H(()=>{"use strict";me();Re();$e();gd=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},yd=(e,t)=>{let r=e[0].dims,o=e[1].dims,a=r.length,s=z.normalizeAxis(t.axis,a),u=r.slice(0);u.splice(s,1,...o);let n=r[s],d=z.size(u),p=q("data",e[0].dataType,e[0].dims),h=q("inputIndices",e[1].dataType,e[1].dims),y=se("output",e[0].dataType,u),b=()=>{let $=o.length,v=`var indicesIndices  = ${h.type.indices}(0);`;for(let x=0;x<$;x++)v+=`${$>1?`indicesIndices[${x}]`:"indicesIndices"} = ${u.length>1?`outputIndices[${s+x}]`:"outputIndices"};`;v+=`
        var idx = ${h.getByIndices("indicesIndices")};
        if (idx < 0) {
          idx = idx + ${n};
        }
        var dataIndices = ${p.type.indices}(0);
      `;for(let x=0,I=0;x<a;x++)x===s?(v+=`${a>1?`dataIndices[${x}]`:"dataIndices"} = u32(idx);`,I+=$):(v+=`${a>1?`dataIndices[${x}]`:"dataIndices"} = ${u.length>1?`outputIndices[${I}]`:"outputIndices"};`,I++);return v},w=$=>`
      ${$.declareVariables(p,h,y)}
      ${$.mainStart()}
        ${$.guardAgainstOutOfBoundsWorkgroupSizes(d)}
        let outputIndices = ${y.offsetToIndices("global_idx")};
        ${b()};
        let value = ${p.getByIndices("dataIndices")};
        ${y.setByOffset("global_idx","value")};
      }`;return{name:"Gather",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)}}),getShaderSource:w}},hs=e=>oe({axis:e.axis}),gs=(e,t)=>{let r=e.inputs;gd(r),e.compute(yd(e.inputs,t))}});var bd,wd,bs,ws,vs=H(()=>{"use strict";me();Re();$e();bd=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},wd=(e,t)=>{let r=e[0].dims,o=e[0].dataType,a=r.length,s=z.computeStrides(r),u=z.size(r),n=e[1].dims,d=e[1].dataType,p=z.size(n),h=z.normalizeAxis(t.axis,a),y=r[h],b=n.slice(0),w=z.size(b),$=q("input",o,r),v=q("indices",d,[p]),x=se("output",o,b),I=R=>`
      const inputStrides = array<u32, ${s.length}>(${s.map(M=>`${M}u`).join(",")});
      ${R.declareVariables($,v,x)}
      ${R.mainStart()}
      ${R.guardAgainstOutOfBoundsWorkgroupSizes(w)}

      let outputIndices = ${x.offsetToIndices("global_idx")};

      var idx = ${v.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + ${y};
      }

      var srcOffset = u32(0);

      for (var i = 0; i < ${r.length}; i++) {
        if (i == ${h}) {
          srcOffset +=  u32(idx) * inputStrides[i];
        } else {
          srcOffset += ${x.indicesGet("outputIndices","i")} * inputStrides[i];
        }
      }

      // Should never hit this with valid values in indices
      // This is a guard against malicious data in the indices input
      if (srcOffset < 0 || srcOffset >= ${u}) {
        return;
      }

      output[global_idx] = input[srcOffset];
  }`;return{name:"GatherElements",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:b,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)}}),getShaderSource:I}},bs=e=>oe({axis:e.axis}),ws=(e,t)=>{let r=e.inputs;bd(r),e.compute(wd(e.inputs,t))}});var vd,$d,xd,$s,xs,Ss=H(()=>{"use strict";me();Re();$e();vd=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},$d=(e,t,r)=>{if(r.length===0)return"0u";let o=r.length===1&&e!==1||r.length===2&&r[0]!==e,a=r[r.length-1]!==t,s="0u";return o||(s+=`+ m * ${r[r.length-1]}u`),a||(s+="+n"),s},xd=(e,t)=>{let r=e[0].dims.slice(),o=e[1].dims.slice(),[a,s,u]=Nr.getShapeOfGemmResult(r,t.transA,o,t.transB,e.length===3?e[2].dims:void 0),n=[a,s];if(!n)throw new Error("Can't use gemm on the given tensors");let d=z.size(n),p="";t.transA&&t.transB?p="value += a[k * M + m] * b[n * K + k];":t.transA&&!t.transB?p="value += a[k * M + m] * b[k * N + n];":!t.transA&&t.transB?p="value += a[m * K + k] * b[n * K + k];":!t.transA&&!t.transB&&(p="value += a[m * K + k] * b[k * N + n];");let h=ke(e[0].dataType),y=t.alpha===1?"":"value *= alpha;",b=e.length===3?`value += beta * c[${$d(a,s,e[2].dims)}];`:"",w=[`@group(0) @binding(0) var<storage, read> a : array<${h}>;`,`@group(0) @binding(1) var<storage, read> b : array<${h}>;`];e.length===3&&w.push(`@group(0) @binding(2) var<storage, read> c : array<${h}>;`);let $=v=>`
  const M: u32 = ${a}u;
  const N: u32 = ${s}u;
  const K: u32 = ${u}u;
  const alpha = ${h}(${t.alpha});
  const beta = ${h}(${t.beta});

  ${w.join(`
`)}
  @group(0) @binding(${e.length}) var<storage, read_write> output : array<${h}>;

  ${v.mainStart()}
    ${v.guardAgainstOutOfBoundsWorkgroupSizes(d)}

    let m = global_id.x / N;
    let n = global_id.x % N;

    var value = ${h}(0);
    for (var k: u32 = 0u; k<${u}u; k++) {
      ${p}
    }

    ${y}
    ${b}
    output[global_id.x] = value;

  }`;return{name:"Gemm",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)}}),getShaderSource:$}},$s=(e,t)=>{vd(e.inputs),e.compute(xd(e.inputs,t))},xs=e=>oe(e)});var Cs,Sd,Cd,Is,As,_s=H(()=>{"use strict";me();Re();$e();Cs={name:"InstanceNormalization"},Sd=(e,t)=>{let r=e[0].dims,o=r,a=2,s=z.sizeToDimension(r,a),u=z.sizeFromDimension(r,a),n=r[1],d=q("x",e[0].dataType,[r[0],r[1],u]),p=q("scale",e[1].dataType,e[1].dims),h=q("bias",e[2].dataType,e[2].dims),y=se("output",e[0].dataType,[r[0],r[1],u]),b=[d,p,h,y],w=d.type.value,$=64,v=x=>`

  const C: u32 = ${n};
  const normSize: u32 = ${u};
  const epsilon: f32 = ${t.epsilon};
  var<workgroup> meanShared : ${w};
  var<workgroup> squaredNormShared : ${w};
  var<workgroup> workgroupShared : array<${w}, ${$}>;
  const workgroupSize = ${$}u;
  ${x.declareVariables(...b)}
  ${x.mainStart($)}
    let norm = global_idx / workgroupSize;
    let batch = norm / C;
    let channel = norm % C;
    let localIndex = local_id.x;

    // initialize workgroup memory
    var initial: ${w} = 0;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      initial = initial + ${d.get("batch","channel","h")};
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the mean of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      meanShared = workgroupShared[0] / ${w}(normSize);
    }
    workgroupBarrier();

    // reinitialize workgroup memory.
    initial = 0;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      let deviation =  ${d.get("batch","channel","h")} - meanShared;
      initial = initial + deviation * deviation;
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the sum of square of deviation of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      squaredNormShared = workgroupShared[0];
    }
    workgroupBarrier();

    let invStdDev = 1 / sqrt(squaredNormShared / ${w}(normSize) + epsilon);
    let channelScale = invStdDev * ${p.getByOffset("channel")};
    let channelShift = ${h.getByOffset("channel")} - meanShared * channelScale;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      let value = ${d.get("batch","channel","h")} * channelScale + channelShift;
      ${y.set("batch","channel","h","value")};
    }
  }`;return{...Cs,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:s}}),getShaderSource:v}},Cd=(e,t)=>{let r=e[0].dims,o=r,a=z.size(o),s=r[0],u=r[r.length-1],n=z.sizeFromDimension(r,1)/u,d=ke(e[0].dataType),p=u*s,h=y=>`
  const N: u32 = ${s};
  const H: u32 = ${n};
  const C: u32 = ${u};
  const normSizeTyped: ${d} = ${n};
  const imageSize: u32 = ${n*u};
  const epsilon: f32 = ${t.epsilon};

  @group(0) @binding(0) var<storage, read> x : array<${d}>;
  @group(0) @binding(1) var<storage, read> scale : array<${d}>;
  @group(0) @binding(2) var<storage, read> bias : array<${d}>;
  @group(0) @binding(3) var<storage, read_write> output : array<${d}>;

  ${y.mainStart()}
    let currentImageNumber = global_idx / C;
    let currentChannelNumber = global_idx % C;

    // offset is channel num * N
    let offset = currentImageNumber * imageSize;
    if (offset >= ${a}) { return; }
    var mean: ${d} = 0;

    for (var i: u32 = 0u; i < H; i++) {
        mean = mean + x[offset + i * C + currentChannelNumber];
    }
    mean = mean / normSizeTyped;

    var squaredNorm: ${d} = 0;
    for (var i: u32 = 0u; i < H; i++) {
        let deviation: f32 = x[offset + i * C + currentChannelNumber] - mean;
        squaredNorm = squaredNorm + deviation * deviation;
    }
    let invStdDev = 1 / sqrt(squaredNorm / normSizeTyped + epsilon);
    let channelScale = invStdDev * scale[currentChannelNumber];
    let channelShift = bias[currentChannelNumber] - mean * channelScale;
    for (var i: u32 = 0u; i < H; i++) {
        let currentOffset = offset + i * C + currentChannelNumber;
        output[currentOffset] = x[currentOffset] * channelScale + channelShift;
    }
  }`;return{...Cs,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)}}),getShaderSource:h}},Is=e=>oe({epsilon:e.epsilon,format:e.format}),As=(e,t)=>{t.format==="NHWC"?e.compute(Cd(e.inputs,t)):e.compute(Sd(e.inputs,t))}});var Id,Ad,Es,Os,Ts=H(()=>{"use strict";Me();me();Re();$e();Id=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.");if(e[0].dataType!==1||e[1].dataType!==1)throw new Error("inputs should be float type")},Ad=(e,t,r)=>{let o=e[0].dims,a=e[1],s=e[2],u=o,n=z.size(u),d=z.normalizeAxis(t.axis,o.length),p=z.sizeToDimension(o,d),h=z.sizeFromDimension(o,d),y=z.size(a.dims),b=s?z.size(s.dims):0;if(y!==h||s&&b!==h)throw new Error(`Size of X.shape()[axis:] == ${h}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${y} and bias size of ${b}`);let w=[];for(let B=0;B<o.length;++B)B<d?w.push(o[B]):w.push(1);let $=ke(e[0].dataType),v=r>1,x=r>2,I=0,R=B=>`
  const normSize: u32 = ${h};
  const normSizeTyped: ${$} = ${h};
  const epsilon: f32 = ${t.epsilon};

  @group(0) @binding(${I++}) var<storage, read> x : array<${$}>;
  @group(0) @binding(${I++}) var<storage, read> scale : array<${$}>;
  ${s?`@group(0) @binding(${I++}) var<storage, read> bias : array<${$}>;`:""}
  @group(0) @binding(${I++}) var<storage, read_write> output : array<${$}>;
  ${v?`@group(0) @binding(${I++}) var<storage, read_write> meanDataOutput : array<${$}>`:""};
  ${x?`@group(0) @binding(${I++}) var<storage, read_write> invStdOutput : array<${$}>`:""};

  ${B.mainStart()}
    let offset = global_idx * normSize;
    if (offset >= ${n}) { return; }
    var mean: ${$} = 0;
    var meanSquare: ${$} = 0;

    for (var h: u32 = 0u; h < normSize; h++) {
      mean = mean + x[h + offset];
      meanSquare = meanSquare + x[h + offset] * x[h + offset];
    }
    mean = mean / normSizeTyped;
    meanSquare = sqrt(meanSquare / normSizeTyped - mean * mean + epsilon);

    for (var j: u32 = 0; j < normSize; j++) {
      output[j + offset] = (x[j + offset] - mean) / meanSquare * scale[j] ${s?"+ bias[j]":""};
    }

    ${v?"meanDataOutput[global_idx] = mean":""};
    ${x?"invStdOutput[global_idx] = 1 / meanSquare":""};
  }`,M=[{dims:u,dataType:e[0].dataType}];return v&&M.push({dims:w,dataType:e[0].dataType}),x&&M.push({dims:w,dataType:e[0].dataType}),{name:"LayerNormalization",shaderCache:{hint:`${t.cacheKey}|${r}|${e.length}`},getRunData:()=>({outputs:M,dispatchGroup:{x:Math.ceil(p/64)}}),getShaderSource:R}},Es=e=>oe({axis:e.axis,epsilon:e.epsilon}),Os=(e,t)=>{Id(e.inputs),e.compute(Ad(e.inputs,t,e.outputCount))}});var _d,Rs,ks=H(()=>{"use strict";me();fr();_d=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},Rs=e=>{_d(e.inputs);let t=rt.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can't use matmul on the given tensors");e.compute(Qr(e.inputs,{activation:"",activationCacheKey:""},t))}});var Ed,Od,Td,Rd,kd,Pd,Bd,Md,Dd,Ps,Bs,Ms=H(()=>{"use strict";Me();me();Re();$e();Ed=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1)throw new Error("Input type must be float.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},Od=(e,t,r,o,a,s,u)=>{let n=r.length,d="";for(let p=n-1;p>=0;--p)d+=`
            k = i32(${e.indicesGet("indices",p)}) - ${a[p]};
            if (k < 0) {
              break;
            }
            if (k >= ${r[p]}) {
              break;
            }
            offset += k * ${o[p]};
        `;return`
          value = ${s}(${u});
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${d}
            value = x[offset];
          }
      `},Td=(e,t,r,o,a)=>{let s=r.length,u="";for(let n=s-1;n>=0;--n)u+=`
                k = i32(${e.indicesGet("indices",n)}) - ${a[n]};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = ${2*(r[n]-1)};
                  k = k % _2n_1;
                  if(k >= ${r[n]}) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * ${o[n]};
            `;return`
              var offset = 0;
              var k = 0;
              ${u}
              value = x[offset];
          `},Rd=(e,t,r,o,a)=>{let s=r.length,u="";for(let n=s-1;n>=0;--n)u+=`
                k = i32(${e.indicesGet("indices",n)}) - ${a[n]};
                if (k < 0) {
                  k = 0;
                }
                if (k >= ${r[n]}) {
                  k = ${r[n]-1};
                }
                offset += k * ${o[n]};
            `;return`
              var offset = 0;
              var k = 0;
              ${u}
              value = x[offset];
          `},kd=(e,t,r,o,a)=>{let s=r.length,u="";for(let n=s-1;n>=0;--n)u+=`
                k = i32(${e.indicesGet("indices",n)}) - ${a[n]};
                if (k < 0)  {
                  k += ${r[n]};
                }
                if (k >= ${r[n]}) {
                  k -= ${r[n]};
                }
                offset += k * ${o[n]};
            `;return`
              var offset = 0;
              var k = 0;
              ${u}
              value = x[offset];
          `},Pd=(e,t,r,o,a,s)=>{switch(a.mode){case 0:return Od(e,t,r,o,a.pads,s,a.value);case 1:return Td(e,t,r,o,a.pads);case 2:return Rd(e,t,r,o,a.pads);case 3:return kd(e,t,r,o,a.pads);default:throw new Error("Invalid mode")}},Bd=(e,t,r,o)=>{let a=t[0].dims,s=z.padShape(a.slice(),r.pads),u=z.size(s),n=z.computeStrides(a),d=se("output",t[0].dataType,s),p=q("x",t[0].dataType,a),h=Pd(d,s,a,n,r,o);return`
              ${e.declareVariables(p,d)}
              ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}

              let indices = ${d.offsetToIndices("global_idx")};

              var value = ${o}(0);
              ${h}
              output[global_idx] = value;
          }`},Md=(e,t)=>{let r=z.padShape(e[0].dims.slice(),t.pads);return{name:"Pad",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(z.size(r)/64)}}),getShaderSource:o=>Bd(o,e,t,"f32")}},Dd=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),o=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,a=e[0].dims.length,s=new Int32Array(2*a).fill(0);if(e.length>=4){let n=e[3].getBigInt64Array();for(let d=0;d<n.length;d++)s[Number(n[d])]=Number(r[d]),s[Number(n[d])+a]=Number(r[d+n.length])}else r.forEach((n,d)=>s[Number(d)]=Number(n));let u=[];return s.forEach(n=>u.push(n)),oe({mode:t.mode,value:o,pads:u})}else return t},Ps=(e,t)=>{Ed(e.inputs);let r=Dd(e.inputs,t);e.compute(Md(e.inputs,r),{inputs:[0]})},Bs=e=>{let t=e.mode,r=e.value,o=e.pads;return oe({mode:t,value:r,pads:o})}});var en,Ds,zs,Ws,Ns,Us,Gs,Fs,Hs,Ls,Vs,js,qs,Ks,Ys,Xs=H(()=>{"use strict";me();Re();$e();en=e=>{if(!e||e.length!==1)throw new Error("Pool ops requires 1 input.");if(e[0].dims.length!==4)throw new Error("Pool ops supports 2-D inputs only for now.")},Ds=(e,t,r)=>{let o=t.format==="NHWC",a=o?[e.dims[0],e.dims[3],e.dims[1],e.dims[2]]:e.dims.slice(),s=Object.hasOwnProperty.call(t,"dilations"),u=t.kernelShape.slice(),n=t.strides.slice(),d=s?t.dilations.slice():[],p=t.pads.slice();_t.adjustPoolAttributes(r,a,u,n,d,p);let h=_t.computePoolOutputShape(r,a,n,d,u,p,t.autoPad),y=Object.assign({},t);return s?Object.assign(y,{kernelShape:u,strides:n,pads:p,dilations:d,cacheKey:t.cacheKey}):Object.assign(y,{kernelShape:u,strides:n,pads:p,cacheKey:t.cacheKey}),[y,o?[h[0],h[2],h[3],h[1]]:h]},zs=(e,t,r,o,a,s,u,n)=>{let d=a.format==="NHWC",p=r,h=t.type.value,y=p.length,b=z.size(o),w=se("output",t.type.tensor,o);if(a.kernelShape.length<=2){let $=a.kernelShape[a.kernelShape.length-1],v=a.strides[a.strides.length-1],x=a.pads[a.pads.length/2-1],I=a.pads[a.pads.length-1],R=y-(d?2:1),M="",B="",W="";if(x+I!==0?M=`
              for (var i: u32 = 0u; i < ${$}u; i++) {
                xIndices[${R}] = indices[${R}] * ${v} - ${x} + i;
                if (xIndices[${R}] < 0 || xIndices[${R}] >= ${p[R]}) {
                  pad++;
                  continue;
                }
                let x_val = x[${t.indicesToOffset("xIndices")}];
                ${s}
              }`:M=`
              for (var i: u32 = 0u; i < ${$}u; i++) {
                xIndices[${R}] = indices[${R}] * ${v} - ${x} + i;
                let x_val = x[${t.indicesToOffset("xIndices")}];
                ${s}
              }`,a.kernelShape.length===2){let U=a.kernelShape[a.kernelShape.length-2],F=a.strides[a.strides.length-2],j=a.pads[a.pads.length/2-2],le=a.pads[a.pads.length-2],P=y-(d?3:2),X=p[P];j+le!==0?B=`
                for (var j: u32 = 0u; j < ${U}u; j++) {
                  xIndices[${P}] = indices[${P}] * ${F} - ${j} + j;
                  if (xIndices[${P}] < 0 || xIndices[${P}] >= ${X}) {
                    pad+= ${$};
                    continue;
                  }
              `:B=`
                for (var j: u32 = 0u; j < ${U}u; j++) {
                  xIndices[${P}] = indices[${P}] * ${F} - ${j} + j;
                `,W=`
              }
            `}return`
            ${e.declareVariables(t,w)}

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)}

              let indices = ${w.offsetToIndices("global_idx")};
              var xIndices = ${w.offsetToIndices("global_idx")};

              var value: ${h} = ${h}(${n});
              var pad = 0;
              ${B}
              ${M}
              ${W}
              ${u}

              output[global_idx] = value;
            }`}else{if(d)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let $=z.size(a.kernelShape),v=z.computeStrides(a.kernelShape),x=v.length,I=a.pads.length,R=a.pads.reduce((W,T)=>W+T),M="";return R?M=`
                if (xIndices[j] >= inputDims[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${t.indicesToOffset("xIndices")}];
                ${s}
              }`:M=`
              }
              let x_val = x[${t.indicesToOffset("xIndices")}];
              ${s}
            `,`
            ${e.declareVariables(t,w)}

            const pads = array<u32, ${I}>(${a.pads.map(W=>`${W}u`).join(",")});
            const inputDims = array<u32, ${y}>(${p.map(W=>`${W}u`).join(",")});
            const kernelStrides = array<u32, ${x}>(${v.map(W=>`${W}u`).join(",")});
            const strides = array<u32, ${x}>(${a.strides.map(W=>`${W}u`).join(",")});

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes(b)}

              let indices = ${w.offsetToIndices("global_idx")};
              let xIndices = ${w.offsetToIndices("global_idx")};

              var offsets: array<u32, ${x}>;

              var value = ${w.type.value}(${n});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < ${$}u; i++) {
                var offset = i;
                for (var j = 0u; j < ${x-1}u; j++) {
                  offsets[j] = offset / kernelStrides[j];
                  offset -= offsets[j] * kernelStrides[j];
                }
                offsets[${x-1}] = offset;

                isPad = false;
                for (var j = ${y-x}u; j < ${y}u; j++) {
                  xIndices[j] = indices[j] * strides[j - ${y-x}u]
                    + offsets[j - ${y-x}u] - pads[j - 2u];
                  ${M}
              }
              ${u}

              output[global_idx] = value;
            }`}},Ws=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Ns=(e,t,r,o)=>{let[a,s]=Ds(t,o,r),u=z.size(a.kernelShape),n=q("x",t.dataType,t.dims),d=n.type.value,p="value += x_val;",h="";return a.countIncludePad?h+=`value /= ${d}(${u});`:h+=`value /= ${d}(${u} - pad);`,{name:e,shaderCache:{hint:o.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(z.size(s)/64)}}),getShaderSource:y=>zs(y,n,t.dims,s,a,p,h,"0.0")}},Us=e=>{let t=e.count_include_pad!==0,r=Ws(e);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return oe({countIncludePad:t,...r})},Gs=(e,t)=>{en(e.inputs),e.compute(Ns("AveragePool",e.inputs[0],!1,t))},Fs={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},Hs=e=>{let t=e.format;return{format:t,...Fs,cacheKey:t}},Ls=(e,t)=>{en(e.inputs),e.compute(Ns("GlobalAveragePool",e.inputs[0],!0,t))},Vs=(e,t,r,o)=>{let[a,s]=Ds(t,o,r),u=`
      value = max(x_val, value);
    `,n="",d=q("x",t.dataType,t.dims);return{name:e,shaderCache:{hint:o.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(z.size(s)/64)}}),getShaderSource:p=>zs(p,d,t.dims,s,a,u,n,"-1e5")}},js=(e,t)=>{en(e.inputs),e.compute(Vs("MaxPool",e.inputs[0],!1,t))},qs=e=>{let t=e.storage_order,r=e.dilations,o=Ws(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(o.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return oe({storageOrder:t,dilations:r,...o})},Ks=e=>{let t=e.format;return{format:t,...Fs,cacheKey:t}},Ys=(e,t)=>{en(e.inputs),e.compute(Vs("GlobalMaxPool",e.inputs[0],!0,t))}});var Wd,Nd,Qs,Js=H(()=>{"use strict";At();Me();$e();Wd=(e,t,r)=>{let o=e===t,a=e<t&&r<0,s=e>t&&r>0;if(o||a||s)throw new Error("Range these inputs' contents are invalid.")},Nd=(e,t,r,o)=>{let a=Math.abs(Math.ceil((t-e)/r)),s=[a],u=a,n=se("output",o,s),d=n.type.storage,p=h=>`
        ${h.declareVariables(n)}
        ${h.mainStart()}
        ${h.guardAgainstOutOfBoundsWorkgroupSizes(u)}
        output[global_idx] = ${d}(${e}) + ${d}(global_idx) * ${d}(${r});
      }`;return{name:"Range",shaderCache:{hint:[e,t,r].map(h=>h.toString()).join("_")},getShaderSource:p,getRunData:()=>({outputs:[{dims:s,dataType:o}],dispatchGroup:{x:Math.ceil(u/64)}})}},Qs=e=>{let t=0,r=0,o=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],o=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],o=e.inputs[2].getFloat32Array()[0]),Ae.webgpu.validateInputContent&&Wd(t,r,o),e.compute(Nd(t,r,o,e.inputs[0].dataType),{inputs:[]})}});var Ud,Gd,Fd,Hd,Ld,Vd,jd,qd,Kd,Yd,Xd,Qd,Jd,Zd,ec,Zs,eu,tu=H(()=>{"use strict";me();Re();$e();Ud=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},Gd=(e,t,r)=>{t.every(a=>a>=0&&a<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let o=new Array(r).fill(1);return t.forEach((a,s)=>o[a]=e[s]),o},Fd=(e,t,r,o,a,s)=>{let[u,n,d]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],p=e[0].dims.length;if(u>0&&e.length>u&&e[u].dims.length>0)e[u].getFloat32Array().forEach(h=>s.push(h));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(n>0&&e.length>n&&e[n].dims.length>0){if(e[n].getFloat32Array().forEach(h=>o.push(h)),o.length!==0&&o.length!==p&&r>=18&&o.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");Ud(o,t),t.axes.length>0&&Gd(o,t.axes,p).forEach((h,y)=>o[y]=h)}if(d>0&&e.length>d&&(e[d].getBigInt64Array().forEach(h=>a.push(Number(h))),a.length!==p||r>=18&&a.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(o.length!==t.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(a.length!==t.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof o<"u"&&typeof a<"u"&&o.length>0&&a.length>p)throw new Error("Resize requires only of scales or sizes to be specified")},Hd=e=>"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(e){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`
`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",Ld=(e,t)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",Vd=(e,t,r)=>{let o=new Array(r).fill(0).concat(new Array(r).fill(1)),a=e.length===0?o:e.slice();return t.length>0?(t.forEach((s,u)=>{o[s]=a[u],o[u+r]=a[t.length+u]}),o):a},jd=(e,t,r,o)=>{let a=[];if(r.length>0)if(o.length>0){if(e.forEach(s=>a.push(s)),Math.max(...o)>e.length)throw new Error("axes is out of bound");o.forEach((s,u)=>a[s]=r[u])}else r.forEach(s=>a.push(s));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");a=e.map((s,u)=>Math.round(s*t[u]))}return a},qd=(e,t,r,o)=>{let a=(()=>{switch(o.keepAspectRatioPolicy){case"not_larger":return o.axes.length>0?Math.min(...o.axes.map(u=>r[u]),Number.MAX_VALUE):Math.min(...r,Number.MAX_VALUE);case"not_smaller":return o.axes.length>0?Math.max(...o.axes.map(u=>r[u]),Number.MIN_VALUE):Math.max(...r,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${o.keepAspectRatioPolicy} is not supported`)}})();r.fill(1,0,r.length);let s=e.slice();return o.axes.length>0?(o.axes.forEach(u=>r[u]=a),o.axes.forEach(u=>s[u]=Math.round(e[u]*r[u]))):(r.fill(a,0,r.length),s.forEach((u,n)=>s[n]=Math.round(u*r[n]))),s},Kd=(e,t,r,o,a)=>`
    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${e.type.indices}) -> array<f32, ${r.length}> {
      const inputShape = array<u32, ${t.length}>(${t.map(s=>`${s}u`).join(",")});
      const outputShape = array<u32, ${r.length}>(${r.map(s=>`${s}u`).join(",")});
      const scales = array<f32, ${o.length}>(${o.map(s=>`${s}f`).join(",")});
      const roi = array<f32, ${a.length}>(${a.map(s=>`${s}f`).join(",")});
      var originalIndices: array<f32, ${r.length}>;
      for (var i:u32 = 0; i < ${r.length}; i++) {
        var outputIndex = ${r.length===1?"outputIndices":"outputIndices[i]"};
        if (scales[i] == 1.0) {
          originalIndices[i] = f32(outputIndex);
        } else {
          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],
                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${t.length}]);
        }
      }
      return originalIndices;
    }`,Yd=(e,t,r,o,a,s,u)=>`
    fn calculateInputIndicesFromOutputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {
        const inputShape = array<u32, ${r.length}>(${r.map(n=>`${n}u`).join(",")});
        const outputShape = array<u32, ${o.length}>(${o.map(n=>`${n}u`).join(",")});
        const scales = array<f32, ${a.length}>(${a.map(n=>`${n}f`).join(",")});
        const roi = array<f32, ${s.length}>(${s.map(n=>`${n}f`).join(",")});
        var inputIndices: ${e.type.indices};
        for (var i:u32 = 0; i < ${o.length}; i++) {
          var outputIndex = ${o.length===1?"outputIndices":"outputIndices[i]"};
          var inputIndex: u32;
          if (scales[i] == 1.0) {
            inputIndex = outputIndex;
          } else {
            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],
                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${r.length}]);
            if (!${u} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {
              if (original_idx < 0) {
                inputIndex = 0;
              } else if (original_idx > (f32(inputShape[i]) - 1)) {
                inputIndex = inputShape[i] - 1;
              } else {
                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));
              }
            } else {
              inputIndex = u32(original_idx);
            }
          }
          ${e.indicesSet("inputIndices","i","inputIndex")}
        }
        return inputIndices;
    }`,Xd=(e,t)=>`
    fn checkInputIndices(inputIndices: ${e.type.indices}) -> bool {
      const inputShape = array<u32, ${t.length}>(${t.map(r=>`${r}u`).join(",")});
      for (var i:u32 = 0; i < ${t.length}; i++) {
        var inputIndex = ${t.length===1?"inputIndices":"inputIndices[i]"};
        if (inputIndex < 0 || inputIndex >= inputShape[i]) {
          return false;
        }
      }
      return true;
    }`,Qd=(e,t,r,o,a,s,u)=>{let[n,d,p,h]=r.length===2?[-1,0,1,-1]:a[1]===1?[0,2,3,1]:[0,1,2,3];return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {
      var inputIndices: ${e.type.indices};
      inputIndices[${d}] = max(0, min(row, ${r[d]} - 1));
      inputIndices[${p}] = max(0, min(col, ${r[p]} - 1));
      if (${r.length} > 2) {
        inputIndices[${h}] = channel;
        inputIndices[${n}] = batch;
      };
      return input[${e.indicesToOffset("inputIndices")}];
    }

    fn bilinearInterpolation(outputIndices: ${t.type.indices}) -> f32 {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);
      var row:f32 = originalIndices[${d}];
      var col:f32 = originalIndices[${p}];
      if (${s} && (row < 0 || row > (${r[d]} - 1) || col < 0 || col > ${r[p]} - 1)) {
        return ${u};
      }
      row = max(0, min(row, ${r[d]} - 1));
      col = max(0, min(col, ${r[p]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = 0;
      var batch: u32 = 0;
      if (${r.length>2}) {
        channel = u32(originalIndices[${h}]);
        batch = u32(originalIndices[${n}]);
      }
      var x11: f32 = getInputValue(batch, channel, row1, col1);
      var x12: f32 = getInputValue(batch, channel, row1, col2);
      var x21: f32 = getInputValue(batch, channel, row2, col1);
      var x22: f32 = getInputValue(batch, channel, row2, col2);
      var dx1: f32 = row - f32(row1);
      var dx2: f32 = f32(row2 ) - row;
      var dy1 = col - f32(col1);
      var dy2 = f32(col2) - col;
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},Jd=(e,t,r,o,a,s,u,n,d,p)=>{let[h,y]=r.length===2?[0,1]:a[1]===1?[2,3]:[1,2],b=w=>{let $=w===h?"row":"col";return`
      fn ${$}CubicInterpolation(inputIndices: ${e.type.indices}, outputIndices: ${t.type.indices}) -> f32 {
        var outputIndex = ${o.length===1?"outputIndices":`outputIndices[${w}]`};
        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${a[w]},
        f32(${o[w]}), f32(${r[w]}), ${s[w]}, ${s[w]} + ${r.length});
        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${n} && (originalIdx < 0 || originalIdx > (${r[w]} - 1))) {
          return ${d};
        }
        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${$}: f32 = originalIdx + f32(i);
          if (${$} < 0 || ${$} >= ${r[w]}) {
            if (${p}) {
              coefs[i + 1] = 0.0;
              continue;
            } else if (${n}) {
              return ${d};
            } else {
              ${$} = max(0, min(${$}, ${r[w]} - 1));
            }
          }
          var inputIndicesCopy: ${e.type.indices} = inputIndices;
          inputIndicesCopy[${w}] = u32(${$});
          data[i + 1] = ${w===h?`input[${e.indicesToOffset("inputIndicesCopy")}];`:`
                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);`}
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${b(h)};
    ${b(y)};
  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {
    var absS = abs(s);
    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: f32 = 1.0 - absS;
    var twoMinusAbsS: f32 = 2.0 - absS;
    var onePlusAbsS: f32 = 1.0 + absS;
    coeffs[0] = ((${u} * onePlusAbsS - 5 * ${u}) * onePlusAbsS + 8 * ${u}) * onePlusAbsS - 4 * ${u};
    coeffs[1] = ((${u} + 2) * absS - (${u} + 3)) * absS * absS + 1;
    coeffs[2] = ((${u} + 2) * oneMinusAbsS - (${u} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${u} * twoMinusAbsS - 5 * ${u}) * twoMinusAbsS + 8 * ${u}) * twoMinusAbsS - 4 * ${u};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {
    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(outputIndices: ${t.type.indices}) -> f32 {
    var inputIndices: ${e.type.indices} = outputIndices;
    return colCubicInterpolation(inputIndices, outputIndices);
  }
    `},Zd=(e,t,r,o,a,s)=>{let u=e.dims,n=Vd(s,t.axes,u.length),d=jd(u,o,a,t.axes),p=o.slice();o.length===0&&(p=u.map((x,I)=>x===0?1:d[I]/x),t.keepAspectRatioPolicy!=="stretch"&&(d=qd(u,d,p,t)));let h=se("output",e.dataType,d),y=q("input",e.dataType,u),b=z.size(d),w=u.length===d.length&&u.every((x,I)=>x===d[I]),$=t.coordinateTransformMode==="tf_crop_and_resize",v=x=>`
      ${Hd(t.coordinateTransformMode)};
      ${(()=>{switch(t.mode){case"nearest":return`
              ${Xd(y,u)};
              ${Ld(t.nearestMode,r)};
              ${Yd(y,h,u,d,p,n,$)};
              `;case"linear":return`
              ${Kd(h,u,d,p,n)};
              ${Qd(y,h,u,d,p,$,t.extrapolationValue)};
              `;case"cubic":return`
            ${Jd(y,h,u,d,p,n,t.cubicCoeffA,$,t.extrapolationValue,t.excludeOutside)};
            `;default:throw Error("Invalid resize mode")}})()};
      ${x.declareVariables(y,h)}
      ${x.mainStart()}
        ${x.guardAgainstOutOfBoundsWorkgroupSizes(b)}
        if (${w}) {
          output[global_idx] = input[global_idx];
        } else {
          let outputIndices = ${h.offsetToIndices("global_idx")};
          var inputIndices: ${y.type.indices};
          ${(()=>{switch(t.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);
                  if (checkInputIndices(inputIndices)) {
                    output[global_idx] = input[${y.indicesToOffset("inputIndices")}];
                  } else {
                    output[global_idx] = ${t.extrapolationValue};
                  }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};
        }
      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${p.length>0?p:""}|${a.length>0?a:""}`},getShaderSource:v,getRunData:()=>({outputs:[{dims:d,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(b/64)}})}},ec=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},Zs=(e,t)=>{let r=[],o=[],a=[],s=ec(e);Fd(e.inputs,t,s,r,o,a),e.compute(Zd(e.inputs[0],t,s,r,o,a),{inputs:[0]})},eu=e=>{let t=e.antialias,r=e.axes,o=e.coordinateTransformMode,a=e.cubicCoeffA,s=e.excludeOutside!==0,u=e.extrapolationValue,n=e.keepAspectRatioPolicy,d=e.mode,p=e.nearestMode===""?"simple":e.nearestMode;return oe({antialias:t,axes:r,coordinateTransformMode:o,cubicCoeffA:a,excludeOutside:s,extrapolationValue:u,keepAspectRatioPolicy:n,mode:d,nearestMode:p})}});var tc,rc,ru,nu,au=H(()=>{"use strict";Me();me();Re();$e();tc=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");if(e[0].dataType!==1||e[1].dataType!==1)throw new Error("inputs should be float type");let t=e[0],r=e[1],o=e[2];if(t.dataType!==r.dataType||t.dataType!==o.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let a=t.dims[t.dims.length-1],s=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==a)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==s)throw new Error("Skip must have the same sequence length as input");if(o.dims.length!==1)throw new Error("Gamma must be 1D");if(o.dims[o.dims.length-1]!==a)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let u=e[3];if(u.dims.length!==1)throw new Error("Beta must be 1D");if(u.dims[u.dims.length-1]!==a)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let u=e[4];if(u.dims.length!==1)throw new Error("Bias must be 1D");if(u.dims[u.dims.length-1]!==a)throw new Error("Bias must have the same hidden size as input")}},rc=(e,t,r,o)=>{let a=e[0].dims,s=z.size(a),u=a,n=s,d=a.slice(-1)[0],p=o?a.slice(0,-1).concat(1):[],h=e.length>3,y=e.length>4,b=ke(e[0].dataType),w=o&&r>1,$=o&&r>2,v=r>3,x=0,I=M=>`
      const hiddenSize: u32 = ${d};
      const epsilon: f32 = ${t.epsilon};

      @group(0) @binding(${x++}) var<storage, read> x : array<${b}>;
      @group(0) @binding(${x++}) var<storage, read> skip : array<${b}>;
      @group(0) @binding(${x++}) var<storage, read> gamma : array<${b}>;
      ${h?`@group(0) @binding(${x++}) var<storage, read> beta : array<${b}>;`:""}
      ${y?`@group(0) @binding(${x++}) var<storage, read> bias : array<${b}>;`:""}
      @group(0) @binding(${x++}) var<storage, read_write> output : array<${b}>;
      ${w?`@group(0) @binding(${x++}) var<storage, read_write> meanOutput : array<${b}>;`:""}
      ${$?`@group(0) @binding(${x++}) var<storage, read_write> invStdOutput : array<${b}>;`:""}
      ${v?`@group(0) @binding(${x++}) var<storage, read_write> inputSkipBiasSum : array<${b}>;`:""}

      ${M.mainStart()}
        ${M.guardAgainstOutOfBoundsWorkgroupSizes(n/d)}
        let offset = global_idx * hiddenSize;
        var sum: f32 = 0.0;
        var squareSum: f32 = 0.0;
        for (var i: u32 = 0; i < hiddenSize; i++) {
          let skipValue = skip[offset + i];
          let biasValue = ${y?"bias[i]":"0.0"};
          let inputValue = x[offset + i];
          let value = inputValue + skipValue + biasValue;
          ${v?"inputSkipBiasSum[offset + i] = value;":""}
          output[offset + i] = value;
          sum += value;
          squareSum += value * value;
        }
        let mean: f32 = sum / f32(hiddenSize);
        let variance: f32 = sqrt(squareSum / f32(hiddenSize) - mean * mean + epsilon);
        ${w?"meanOutput[global_idx] = mean;":""}
        ${$?"invStdOutput[global_idx] = 1.0 / variance;":""}
        for (var i: u32 = 0; i < hiddenSize; i++) {
          output[offset + i] = (output[offset + i] - mean) / variance * gamma[i] + ${h?"beta[i]":"0.0"};
        }
      }`,R=[{dims:u,dataType:e[0].dataType}];return r>1&&R.push({dims:p,dataType:e[0].dataType}),r>2&&R.push({dims:p,dataType:e[0].dataType}),r>3&&R.push({dims:a,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:t.cacheKey},getShaderSource:I,getRunData:()=>({outputs:R,dispatchGroup:{x:Math.ceil(n/d/64)}})}},ru=(e,t)=>{tc(e.inputs);let o=[0];e.outputCount>1&&o.push(-3),e.outputCount>2&&o.push(-3),e.outputCount>3&&o.push(3),e.compute(rc(e.inputs,t,e.outputCount,!1),{outputs:o})},nu=e=>{let t=e.epsilon;return oe({epsilon:t})}});var nc,tn,ac,ou,oc,ic,iu,su,uu=H(()=>{"use strict";Me();me();Re();$e();nc=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((r,o)=>{if(e[o+1].dataType!==6&&e[o+1].dataType!==7)throw new Error(`Input ${o} must be an array of int32 or int64`)})},tn=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(o=>r.push(Number(o)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(o=>r.push(Number(o)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},ac=(e,t)=>{if(e.length>1){let r=tn(e,1),o=tn(e,2),a=tn(e,3);return a.length===0&&(a=[...Array(e[0].dims.length).keys()]),oe({starts:r,ends:o,axes:a})}else return t},ou=(e,t,r,o,a)=>{let s=e;return e<0&&(s+=r[o[t]]),a[t]<0?Math.max(0,Math.min(s,r[o[t]]-1)):Math.max(0,Math.min(s,r[o[t]]))},oc=(e,t,r,o)=>`fn calculateInputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {
          var inputIndices: ${e.type.indices};
          var carry = 0u;
          for (var i = ${r.length}; i >= 0; i--) {
            var outputIndex = ${o.length===1?"outputIndices":"outputIndices[i]"};
            var inputIndex = outputIndex * steps[i] + starts[i] + carry;
            carry = inputIndex / inputShape[i];
            inputIndex = inputIndex % inputShape[i];
            if (signs[i] < 0) {
              inputIndex = inputShape[i] - inputIndex - 1u + starts[i];
            }
            ${r.length===1?"inputIndices":"inputIndices[i]"} = inputIndex;
          }
          return inputIndices;
      }`,ic=(e,t)=>{let r=e[0].dims,o=z.size(r),a=t.axes.length>0?z.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],s=tn(e,4);s.forEach(v=>v!==0||(()=>{throw new Error("step cannot be 0")})),s.length===0&&(s=Array(a.length).fill(1));let u=t.starts.map((v,x)=>ou(v,x,r,a,s)),n=t.ends.map((v,x)=>ou(v,x,r,a,s));if(a.length!==r.length)for(let v=0;v<r.length;++v)a.includes(v)||(u.splice(v,0,0),n.splice(v,0,r[v]),s.splice(v,0,1));let d=s.map(v=>Math.sign(v));s.forEach((v,x,I)=>{if(v<0){let R=(n[x]-u[x])/v,M=u[x],B=M+R*s[x];u[x]=B,n[x]=M,I[x]=-v}});let p=r.slice(0);a.forEach((v,x)=>{p[v]=Math.ceil((n[v]-u[v])/s[v])});let h={dims:p,dataType:e[0].dataType},y=se("output",e[0].dataType,p),b=q("input",e[0].dataType,r),w=z.size(p),$=v=>`
      ${v.declareVariables(b,y)}
        const signs = array<i32, ${d.length}>(${d.map(x=>`${x}i`).join(",")});
        const starts = array<u32, ${u.length}>(${u.map(x=>`${x}u`).join(",")});
        const ends = array<u32, ${n.length}>(${n.map(x=>`${x}u`).join(",")});
        const steps = array<u32, ${s.length}>(${s.map(x=>`${x}u`).join(",")});
        const inputShape = array<u32, ${r.length}>(${r.map(x=>`${x}u`).join(",")});

        ${oc(b,y,r,p)}
        ${v.mainStart()}
          ${v.guardAgainstOutOfBoundsWorkgroupSizes(w)}
          let outputIndices = ${y.offsetToIndices("global_idx")};
          let inputIndices = calculateInputIndices(outputIndices);
          ${y.setByOffset("global_idx",b.getByIndices("inputIndices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${t.cacheKey}|${e[4]?.dims??""}`},getShaderSource:$,getRunData:()=>({outputs:[h],dispatchGroup:{x:Math.ceil(o/64)}})}},iu=(e,t)=>{nc(e.inputs,t);let r=ac(e.inputs,t);e.compute(ic(e.inputs,r),{inputs:[0]})},su=e=>{let t=e.starts,r=e.ends,o=e.axes;return oe({starts:t,ends:r,axes:o})}});var sc,uc,lu,du,cu=H(()=>{"use strict";me();Re();$e();sc=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},uc=(e,t)=>{let r=ke(e.dataType),o=e.dims,a=z.size(o),s=64,u=t.axis;if(u<0&&(u=o.length+u),u<o.length-1)throw new Error("softmax only supports last axis for now.");let n=o[u],d=a/n,p=r==="f32"?"var threadMax: f32 = -3.402823e+38f;":"var threadMax: f16 = -65504.0h;";return{name:"Softmax",getRunData:()=>({outputs:[{dims:o,dataType:e.dataType}],dispatchGroup:{x:d}}),getShaderSource:y=>`
      var<workgroup> rowMaxShared : ${r};
      var<workgroup> rowSumShared : ${r};
      var<workgroup> threadShared : array<${r}, ${s}>;

      @group(0) @binding(0) var<storage, read> x : array<${r}>;
      @group(0) @binding(1) var<storage, read_write> result : array<${r}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${r} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${r}) {
        let index = row * row_stride + col;
        result[index] = value;
      }

      @compute @workgroup_size(${s}, 1, 1)
      fn main(@builtin(local_invocation_id) local_id : vec3<u32>, @builtin(global_invocation_id) global_id : vec3u) {
        let gindex = i32(global_id.x);
        let lindex = i32(local_id.x);
        const wg = ${s};
        let row = gindex / wg;
        let cols = ${n};
        let row_stride : i32 = ${n};

        // find the rows max
        ${p}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = threadShared[0];
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum: ${r} = 0.0;
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = threadShared[0];
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`}},lu=(e,t)=>{sc(e.inputs),e.compute(uc(e.inputs[0],t))},du=e=>oe({axis:e.axis})});var lc,dc,cc,pc,fc,pu,fu,mu=H(()=>{"use strict";me();Re();$e();lc=e=>{if(!e||e.length<1)throw new Error("too few inputs")},dc=(e,t)=>{let r=[],o=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(a=>r.push(Number(a))),o=r.length),oe({numOutputs:o,axis:t.axis,splitSizes:r})},cc=e=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {
    if (index < sizeInConcatAxis[i]) {
        return i;
    }
    }
    return ${e}u;
}`,pc=e=>{let t=e.length,r=[];for(let o=0;o<t;++o){let a=e[o].setByIndices("indices","input[global_idx]");t===1?r.push(a):o===0?r.push(`if (outputNumber == ${o}u) { ${a} }`):o===t-1?r.push(`else { ${a} }`):r.push(`else if (outputNumber == ${o}) { ${a} }`)}return`
      fn writeBufferData(outputNumber: u32, indices: ${e[0].type.indices}, global_idx: u32) {
        ${r.join(`
`)}
      }`},fc=(e,t)=>{let r=e[0].dims,o=z.size(r),a=e[0].dataType,s=r.length,u=t.axis,n=u<0?r.length+u:u,d=new Array(t.numOutputs),p=q("input",a,r),h=new Array(t.numOutputs),y=[],b=[],w=0;for(let x=0;x<t.numOutputs;x++){w+=t.splitSizes[x],h[x]=w;let I=r.slice();I[t.axis]=t.splitSizes[x],b.push(I),d[x]=se(`output${x}`,a,b[x]),y.push({dims:b[x],dataType:e[0].dataType})}let $=s<2?"indices":`indices[${n}]`,v=x=>`
  ${x.declareVariables(p,...d)}
  const sizeInConcatAxis = array<u32, ${h.length}>(${h.map(I=>`${I}u`).join(",")});
  ${cc(h.length)}
  ${pc(d)}

  ${x.mainStart()}
    ${x.guardAgainstOutOfBoundsWorkgroupSizes(o)}

    var indices = ${p.offsetToIndices("global_idx")};
    let outputNumber = calculateOutputIndex(${$});
    if (outputNumber != 0) {
        ${$} -= sizeInConcatAxis[outputNumber - 1u];
    }
    writeBufferData(outputNumber, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:t.cacheKey},getShaderSource:v,getRunData:()=>({outputs:y,dispatchGroup:{x:Math.ceil(o/64)}})}},pu=(e,t)=>{lc(e.inputs);let r=e.inputs.length===1?t:dc(e.inputs,t);e.compute(fc(e.inputs,r),{inputs:[0]})},fu=e=>{let t=e.axis,r=e.splitSizes,o=e.numOutputs<0?r.length:e.numOutputs;if(o!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return oe({axis:t,numOutputs:o,splitSizes:r})}});var hu,mc,hc,gc,gu,yu=H(()=>{"use strict";Me();me();$e();hu=e=>Array.from(e.getBigInt64Array(),Number),mc=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(hu(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},hc=(e,t)=>{let r=[];for(let o=0;o<e.length;++o)r.push(e[o]*t[o]);return r},gc=e=>{let t=e[0].dims,r=hu(e[1]),o=hc(t,r),a=z.size(o),s=e[0].dataType,u=q("input",s,t),n=se("output",s,o),d=p=>`
      const inputShape = ${u.indices(...t)};
      ${p.declareVariables(u,n)}
      ${p.mainStart()}
      ${p.guardAgainstOutOfBoundsWorkgroupSizes(a)}
      let outputIndices = ${n.offsetToIndices("global_idx")};
      var inputIndices: ${u.type.indices};
      for (var i = 0; i < ${t.length}; i++) {
        let inputDimValue = ${n.indicesGet("outputIndices","i")}  % ${u.indicesGet("inputShape","i")};

        ${u.indicesSet("inputIndices","i","inputDimValue")}
      }
      ${n.setByOffset("global_idx",u.getByIndices("inputIndices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${r}`},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:d}},gu=e=>{mc(e.inputs),e.compute(gc(e.inputs),{inputs:[0]})}});var yc,bc,bu,wu=H(()=>{"use strict";Me();me();$e();yc=(e,t,r,o,a)=>{let s=z.size(r),u=Math.ceil(s/4),n=se("outputData",a,r,4),d=q("aData",t[1].dataType,t[1].dims,4),p=q("bData",t[2].dataType,t[2].dims,4),h=q("cData",t[0].dataType,t[0].dims,4),y,b=(w,$,v)=>`select(${$}, ${w}, ${v})`;if(!o)y=n.setByOffset("global_idx",b(d.getByOffset("global_idx"),p.getByOffset("global_idx"),h.getByOffset("global_idx")));else{let w=($,v,x="")=>{let I=`aData[indexA${v}][componentA${v}]`,R=`bData[indexB${v}][componentB${v}]`,M=`bool(cData[indexC${v}] & ${4278190080>>>(3-v)*8}u)`;return`
            let outputIndices${v} = ${n.offsetToIndices(`global_idx * 4u + ${v}u`)};
            let offsetA${v} = ${d.broadcastedIndicesToOffset(`outputIndices${v}`,n)};
            let offsetB${v} = ${p.broadcastedIndicesToOffset(`outputIndices${v}`,n)};
            let offsetC${v} = ${h.broadcastedIndicesToOffset(`outputIndices${v}`,n)};
            let indexA${v} = offsetA${v} / 4u;
            let indexB${v} = offsetB${v} / 4u;
            let indexC${v} = offsetC${v} / 4u;
            let componentA${v} = offsetA${v} % 4u;
            let componentB${v} = offsetB${v} % 4u;
            ${$}[${v}] = ${x}(${b(I,R,M)});
          `};a===9?y=`
            var data = vec4<u32>(0);
            ${w("data",0,"u32")}
            ${w("data",1,"u32")}
            ${w("data",2,"u32")}
            ${w("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:y=`
            ${w("outputData[global_idx]",0)}
            ${w("outputData[global_idx]",1)}
            ${w("outputData[global_idx]",2)}
            ${w("outputData[global_idx]",3)}
          `}return`
        ${e.declareVariables(h,d,p,n)}
        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}
        ${y}
      }`},bc=e=>{let t=e[1].dims,r=e[2].dims,o=e[0].dims,a=e[1].dataType,s=!(z.areEqual(t,r)&&z.areEqual(r,o)),u=t,n=z.size(t);if(s){let d=rt.calcShape(rt.calcShape(t,r,!1),o,!1);if(!d)throw new Error("Can't perform where op on the given tensors");u=d,n=z.size(u)}return{name:"Where",getShaderSource:d=>yc(d,e,u,s,a),getRunData:()=>({outputs:[{dims:u,dataType:a}],dispatchGroup:{x:Math.ceil(n/64/4)}})}},bu=e=>{e.compute(bc(e.inputs))}});var vu,$u=H(()=>{"use strict";Ko();Xo();Oi();Ui();Hi();jn();ss();cs();ms();ys();vs();Ss();_s();Ts();ks();Ms();Xs();Js();Nn();tu();au();uu();cu();mu();yu();Jr();Fn();wu();vu=new Map([["Abs",[Qo]],["Acos",[Jo]],["Acosh",[Zo]],["Add",[Ti]],["ArgMax",[qo,Un]],["ArgMin",[jo,Un]],["Asin",[ei]],["Asinh",[ti]],["Atan",[ri]],["Atanh",[ni]],["AveragePool",[Gs,Us]],["BiasAdd",[Yo]],["BiasSplitGelu",[Ei]],["Cast",[oi,ai]],["Ceil",[si]],["ClipV10",[Gn]],["Clip",[ii]],["Concat",[Gi,Fi]],["Conv",[es,Zi]],["ConvTranspose",[is,os]],["Cos",[ui]],["Cosh",[li]],["Div",[Ri]],["Einsum",[ls,ds]],["Elu",[di,Hr]],["Equal",[ki]],["Erf",[ci]],["Exp",[pi]],["Expand",[fs]],["Floor",[fi]],["Gather",[gs,hs]],["GatherElements",[ws,bs]],["Gelu",[mi]],["Gemm",[$s,xs]],["GlobalAveragePool",[Ls,Hs]],["GlobalMaxPool",[Ys,Ks]],["Greater",[Di]],["GreaterOrEqual",[Wi]],["InstanceNormalization",[As,Is]],["LayerNormalization",[Os,Es]],["LeakyRelu",[hi,Hr]],["Less",[zi]],["LessOrEqual",[Ni]],["Log",[_i]],["MatMul",[Rs]],["MaxPool",[js,qs]],["Mul",[Pi]],["Neg",[yi]],["Not",[gi]],["Pad",[Ps,Bs]],["Pow",[Bi]],["Range",[Qs]],["Reciprocal",[bi]],["ReduceMin",[Uo,Ye]],["ReduceMean",[No,Ye]],["ReduceMax",[Wo,Ye]],["ReduceSum",[Fo,Ye]],["ReduceProd",[Go,Ye]],["ReduceL1",[Mo,Ye]],["ReduceL2",[Do,Ye]],["ReduceLogSum",[Bo,Ye]],["ReduceLogSumExp",[zo,Ye]],["ReduceSumSquare",[Ho,Ye]],["Relu",[wi]],["Resize",[Zs,eu]],["Sigmoid",[vi]],["Sin",[$i]],["Sinh",[xi]],["Slice",[iu,su]],["SkipLayerNormalization",[ru,nu]],["Split",[pu,fu]],["Sqrt",[Si]],["Softmax",[lu,du]],["Sub",[Mi]],["Tan",[Ci]],["Tanh",[Ii]],["ThresholdedRelu",[Ai,Hr]],["Tile",[gu]],["Transpose",[Yi,Xi]],["Where",[bu]]])});var rn,xu=H(()=>{"use strict";Me();ft();$e();rn=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,o,a,s,u,n){let d=this.backend.device,p=this.backend.getComputePassEncoder(),h=this.backend.supportTimestampQuery&&this.backend.env.webgpu.profilingMode==="default";h&&p.writeTimestamp(this.backend.profilingQuerySet,0),p.setPipeline(t.computePipeline);let y=[];for(let w of a)y.push({binding:y.length,resource:{buffer:w.buffer}});for(let w of s)y.push({binding:y.length,resource:{buffer:w.buffer}});n&&y.push({binding:y.length,resource:n});let b=d.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:y,label:t.programInfo.name});if(p.setBindGroup(0,b),p.dispatchWorkgroups(...u),this.backend.pendingDispatchNumber++,h){p.writeTimestamp(this.backend.profilingQuerySet,1),this.backend.profilingQueryData==null&&(this.backend.profilingQueryData=this.backend.gpuDataManager.create(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let w=this.backend.gpuDataManager.create(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.profilingQuerySet,0,2,this.backend.profilingQueryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.profilingQueryData.buffer,0,w.buffer,0,16),this.backend.flush();let $=this.backend.currentKernelId,v=this.backend.kernels.get($),x=`[${v[0]}] ${v[1]}`;w.buffer.mapAsync(GPUMapMode.READ).then(()=>{let I=new BigUint64Array(w.buffer.getMappedRange()),R=I[0],M=I[1];w.buffer.unmap(),typeof this.backend.profilingTimeBase>"u"&&(this.backend.profilingTimeBase=R);let B=Number(R-this.backend.profilingTimeBase),W=Number(M-this.backend.profilingTimeBase);if(!Number.isSafeInteger(B)||!Number.isSafeInteger(W))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(w.id);let T="";r.forEach((F,j)=>{T+=`input[${j}]: [${F.dims}] | ${sr(F.dataType)}, `});let U="";o.forEach((F,j)=>{U+=`output[${j}]: [${F.dims}] | ${sr(F.dataType)}, `}),console.log(`[profiling] kernel "${$}|${x}" ${T}${U}execution time: ${W-B} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(t,r){let o=this.backend.device,a=[];o.features.has("shader-f16")&&a.push("enable f16;");let s=Po(r),u=t.getShaderSource(s),n=`${a.join(`
`)}
${s.additionalImplementations}
${u}`,d=o.createShaderModule({code:n,label:t.name});_e("verbose",()=>`[WebGPU] shader code: ${n}`);let p=o.createComputePipeline({compute:{module:d,entryPoint:"main"},layout:"auto",label:t.name});return{programInfo:t,computePipeline:p}}normalizeDispatchGroupSize(t){let r=typeof t=="number"?t:t.x,o=typeof t=="number"?1:t.y||1,a=typeof t=="number"?1:t.z||1,s=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=s&&o<=s&&a<=s)return[r,o,a];let u=r*o*a,n=Math.ceil(Math.sqrt(u));if(n>s){if(n=Math.ceil(Math.cbrt(u)),n>s)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[n,n,n]}else return[n,n,1]}}});var wc,vc,nn,Su=H(()=>{"use strict";ft();Ao();To();$u();xu();wc=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let o=0;o<e.length;++o){let a=e[o].dataType;switch(t[o]){case"none":{r.push("");break}case"type":{r.push(`${a}`);break}case"rank":{let s=e[o].dims.length;r.push(`${a};${s}`);break}case"dims":{let s=e[o].dims.join(",");r.push(`${a};${s}`);break}default:throw new Error(`unsupported input dependency: ${t[o]}`)}}return r.join("|")},vc=(e,t)=>{let r=e.name;return e.shaderCache?.hint&&(r+="["+e.shaderCache.hint+"]"),r+=`:${wc(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,r},nn=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispatchNumber=0;this.supportTimestampQuery=!1;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let r=await navigator.gpu.requestAdapter();if(!r)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=t;let o=[],a={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:o};r.features.has("timestamp-query-inside-passes")&&(this.supportTimestampQuery=!0,o.push("timestamp-query-inside-passes")),r.features.has("shader-f16")&&o.push("shader-f16"),this.device=await r.requestDevice(a),this.gpuDataManager=Oo(this),this.programManager=new rn(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Co(t.logLevel,!!t.debug),this.device.onuncapturederror=s=>{s.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${s.error.message}`)},this.supportTimestampQuery&&(this.profilingQuerySet=this.device.createQuerySet({type:"timestamp",count:2})),Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){return this.computePassEncoder||(this.computePassEncoder=this.getCommandEncoder().beginComputePass()),this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}run(t,r,o,a,s){let u=[];for(let I=0;I<r.length;++I){let R=this.gpuDataManager.get(r[I].data);if(!R)throw new Error(`no GPU data for input: ${r[I].data}`);u[I]=R}let n=vc(t,r),d=this.programManager.getArtifact(n),{outputs:p,dispatchGroup:h,programUniforms:y}=t.getRunData(r),b=o.length===0?p.map((I,R)=>R):o;if(b.length!==p.length)throw new Error(`Output size ${b.length} must be equal to ${p.length}.`);let w=[],$=[];for(let I=0;I<p.length;++I){if(!Number.isInteger(b[I])||b[I]<-3||b[I]>=p.length)throw new Error(`Invalid output index: ${b[I]}`);if(b[I]===-3)continue;let R=b[I]===-1,M=b[I]===-2,B=R||M?s(p[I].dataType,p[I].dims):a(b[I],p[I].dataType,p[I].dims),W=this.gpuDataManager.get(B.data);if(!W)throw new Error(`no GPU data for output: ${B.data}`);if(R&&this.temporaryData.push(W),M){let T=this.kernelPersistentData.get(this.currentKernelId);T||(T=[],this.kernelPersistentData.set(this.currentKernelId,T)),T.push(W)}w.push(B),$.push(W)}let v;if(y){let I=0,R=0,M=[],B=1;y.forEach(U=>{let F=typeof U.data=="number"?[U.data]:U.data,j;switch(F.length){case 1:j=4;break;case 2:j=8;break;case 3:j=16;break;case 4:j=16;break;case 5:j=16;break;case 6:j=16;break;default:throw new Error(`unsupported data length: ${F.length}`)}(R===5||R===6)&&(j=16),j>B&&(B=j),I=Math.ceil(I/j)*j,R=F.length,M.push(I),I+=F.length*4}),I=Math.ceil(I/B)*B;let W=new ArrayBuffer(I);y.forEach((U,F)=>{let j=M[F],le=typeof U.data=="number"?[U.data]:U.data;U.type==="int32"?new Int32Array(W,j,le.length).set(le):U.type==="uint32"?new Uint32Array(W,j,le.length).set(le):new Float32Array(W,j,le.length).set(le)});let T=this.gpuDataManager.create(I,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(T.buffer,0,W,0,I),this.gpuDataManager.release(T.id),v={offset:0,size:I,buffer:T.buffer}}let x=this.programManager.normalizeDispatchGroupSize(h);return d||(d=this.programManager.build(t,x),this.programManager.setArtifact(n,d)),_e("info",()=>`[ProgramManager] run "${t.name}" (key=${n}) with ${x[0]}x${x[1]}x${x[2]}`),this.programManager.run(d,r,w,u,$,x,v),w}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,o,a){let s=vu.get(t);if(!s)throw new Error(`kernel not implemented: ${t}`);this.kernels.set(r,[t,a,s[0],[s[1],o]])}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let o of r)this.gpuDataManager.release(o.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,o){let a=this.kernels.get(t);if(!a)throw new Error(`kernel not created: ${t}`);let[s,u,n,d]=a;if(this.currentKernelId!==null)throw new Error(`kernel "[${s}] ${u}" is not allowed to be called recursively`);this.currentKernelId=t,d[0]&&(d[1]=d[0](d[1]),d[0]=void 0),_e("info",()=>`[WebGPU] Start to run kernel "[${s}] ${u}"...`);let p=this.env.debug;this.temporaryData=[];try{return p&&this.device.pushErrorScope("validation"),n(r,d[1]),0}catch(h){return o.push(Promise.resolve(`[WebGPU] Kernel "[${s}] ${u}" failed. ${h}`)),1}finally{p&&o.push(this.device.popErrorScope().then(h=>h?`GPU validation error for kernel "[${s}] ${u}": ${h.message}`:null));for(let h of this.temporaryData)this.gpuDataManager.release(h.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,o,a){let s=this.sessionExternalDataMapping.get(t);s||(s=new Map,this.sessionExternalDataMapping.set(t,s));let u=s.get(r),n=this.gpuDataManager.registerExternalBuffer(o,a,u?.[1]);return s.set(r,[n,o]),n}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(o=>this.gpuDataManager.unregisterExternalBuffer(o[1])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,o){return async()=>{let a=await Pn(this,t,r);return Io(a.buffer,o)}}}});var Cu={};ar(Cu,{init:()=>$c});var mr,Qn,$c,Iu=H(()=>{"use strict";Me();Su();ft();me();mr=class e{constructor(t,r,o,a){this.module=t;this.dataType=r;this.data=o;this.dims=a}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=z.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=z.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=z.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(z.size(t)!==z.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},Qn=class{constructor(t,r,o){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;let a=t.HEAPU32,s=o>>2;this.opKernelContext=a[s++];let u=a[s++];this.outputCount=a[s++],this.customDataOffset=a[s++],this.customDataSize=a[s++];let n=[];for(let d=0;d<u;d++){let p=a[s++],h=a[s++],y=a[s++],b=[];for(let w=0;w<y;w++)b.push(a[s++]);n.push(new mr(t,p,h,b))}this.inputs=n}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,r){let o=r?.inputs?.map(n=>typeof n=="number"?this.inputs[n]:n)??this.inputs,a=r?.outputs??[],s=(n,d,p)=>new mr(this.module,d,this.output(n,p),p),u=(n,d)=>{let p=ur(n);if(!p)throw new Error(`Unsupported data type: ${n}`);let h=p*z.size(d);return new mr(this.module,n,this.backend.gpuDataManager.create(h).id,d)};return this.backend.run(t,o,a,s,u)}output(t,r){let o=this.module.stackSave();try{let a=this.module.stackAlloc((1+r.length)*4),s=a>>2;this.module.HEAPU32[s++]=r.length;for(let u=0;u<r.length;u++)this.module.HEAPU32[s++]=r[u];return this.module._JsepOutput(this.opKernelContext,t,a)}catch(a){throw new Error(`Failed to generate kernel's output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${a}`)}finally{this.module.stackRestore(o)}}},$c=async(e,t)=>{let r=e.jsepInit;if(r&&navigator.gpu){if(!t.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let o=new nn;await o.initialize(t),r(o,a=>o.alloc(a),a=>o.free(a),(a,s,u,n=!1)=>{if(n)_e("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${a}, dst=${s}, size=${u}`),o.memcpy(a,s);else{_e("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${a}, gpuDataId=${s}, size=${u}`);let d=e.HEAPU8.subarray(a,a+u);o.upload(s,d)}},async(a,s,u)=>{_e("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${a}, dataOffset=${s}, size=${u}`),await o.download(a,()=>e.HEAPU8.subarray(s,s+u))},(a,s,u)=>o.createKernel(a,s,u,t.debug||t.webgpu.profilingMode==="default"?e.UTF8ToString(e._JsepGetNodeName(s)):`${s}`),a=>o.releaseKernel(a),(a,s,u,n)=>{_e("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${u}, kernel=${a}, contextDataOffset=${s}`);let d=new Qn(e,o,s);return o.computeKernel(a,d,n)})}}});var xc,Sc,_u,hr,Jn,Zn,Eu,Ou,Au,Tu,Ru,ku,Pu=H(()=>{"use strict";wo();$o();Me();Wt();Mr();xc=e=>{let t=Oe(),r=t.stackSave();try{let o=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,o,o+4)!==0&&Se("Can't get session input/output count."),[t.HEAP32[o/4],t.HEAP32[o/4+1]]}finally{t.stackRestore(r)}},Sc=(e,t)=>{Oe()._OrtInit(e,t)!==0&&Se("Can't initialize onnxruntime.")},_u=async e=>{Sc(e.wasm.numThreads,lr(e.logLevel));{let t=(Iu(),St(Cu)).init;await t(Oe(),e)}},hr=new Map,Jn=e=>{let t=Oe(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},Zn=(e,t)=>{let r=Oe(),o=0,a=0,s=0,u=[],n=[],d=[];try{[a,u]=vo(t),o=r._OrtCreateSession(e[0],e[1],a),o===0&&Se("Can't create a session.");let[p,h]=xc(o),y=[],b=[],w=[];for(let v=0;v<p;v++){let x=r._OrtGetInputName(o,v);x===0&&Se("Can't get an input name."),n.push(x),y.push(r.UTF8ToString(x))}for(let v=0;v<h;v++){let x=r._OrtGetOutputName(o,v);x===0&&Se("Can't get an output name."),d.push(x);let I=r.UTF8ToString(x);b.push(I);{let R=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[I]??"cpu";if(R!=="cpu"&&R!=="cpu-pinned"&&R!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${R}.`);w.push(R)}}let $=null;return w.some(v=>v==="gpu-buffer")&&(s=r._OrtCreateBinding(o),s===0&&Se("Can't create IO binding."),$={handle:s,outputPreferredLocations:w,outputPreferredLocationsEncoded:w.map(v=>Rn(v))}),hr.set(o,[o,n,d,$]),[o,y,b]}catch(p){throw n.forEach(h=>r._OrtFree(h)),d.forEach(h=>r._OrtFree(h)),s!==0&&r._OrtReleaseBinding(s),o!==0&&r._OrtReleaseSession(o),p}finally{r._free(e[0]),a!==0&&r._OrtReleaseSessionOptions(a),u.forEach(p=>r._free(p))}},Eu=(e,t)=>{let r=Jn(e);return Zn(r,t)},Ou=e=>{let t=Oe(),r=hr.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[o,a,s,u]=r;u&&t._OrtReleaseBinding(u.handle),t.jsepUnregisterBuffers?.(e),a.forEach(n=>t._OrtFree(n)),s.forEach(n=>t._OrtFree(n)),t._OrtReleaseSession(o),hr.delete(e)},Au=(e,t,r,o,a)=>{if(!e){t.push(0);return}let s=Oe(),u=e[0],n=e[1],d=e[3],p,h;if(u==="string"&&d==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(d==="gpu-buffer"){let w=e[2].gpuBuffer,$=ur(Tn(u));h=n.reduce((v,x)=>v*x,1)*$,p=s.jsepRegisterBuffer(o,a,w,h)}else{let w=e[2];if(Array.isArray(w)){h=4*w.length,p=s._malloc(h),r.push(p);let $=p/4;for(let v=0;v<w.length;v++){if(typeof w[v]!="string")throw new TypeError(`tensor data at index ${v} is not a string`);s.HEAPU32[$++]=Te(w[v],r)}}else h=w.byteLength,p=s._malloc(h),r.push(p),s.HEAPU8.set(new Uint8Array(w.buffer,w.byteOffset,h),p)}let y=s.stackSave(),b=s.stackAlloc(4*n.length);try{let w=b/4;n.forEach(v=>s.HEAP32[w++]=v);let $=s._OrtCreateTensor(Tn(u),p,h,b,n.length,Rn(d));$===0&&Se(`Can't create tensor for input/output. session=${o}, index=${a}.`),t.push($)}finally{s.stackRestore(y)}},Tu=async(e,t,r,o,a,s)=>{let u=Oe(),n=hr.get(e);if(!n)throw new Error(`cannot run inference. invalid session id: ${e}`);let[d,p,h,y]=n,b=t.length,w=o.length,$=0,v=[],x=[],I=[],R=[],M=u.stackSave(),B=u.stackAlloc(b*4),W=u.stackAlloc(b*4),T=u.stackAlloc(w*4),U=u.stackAlloc(w*4);try{[$,v]=bo(s);for(let K=0;K<b;K++)Au(r[K],x,R,e,t[K]);for(let K=0;K<w;K++)Au(a[K],I,R,e,b+o[K]);let F=B/4,j=W/4,le=T/4,P=U/4;for(let K=0;K<b;K++)u.HEAPU32[F++]=x[K],u.HEAPU32[j++]=p[t[K]];for(let K=0;K<w;K++)u.HEAPU32[le++]=I[K],u.HEAPU32[P++]=h[o[K]];if(y){let{handle:K,outputPreferredLocations:V,outputPreferredLocationsEncoded:ze}=y;if(p.length!==b)throw new Error(`input count from feeds (${b}) is expected to be always equal to model's input count (${p.length}).`);for(let he=0;he<b;he++){let Pe=t[he];await u._OrtBindInput(K,p[Pe],x[he])!==0&&Se(`Can't bind input[${he}] for session=${e}.`)}for(let he=0;he<w;he++){let Pe=o[he];a[he]?.[3]?u._OrtBindOutput(K,h[Pe],I[he],0)!==0&&Se(`Can't bind pre-allocated output[${he}] for session=${e}.`):u._OrtBindOutput(K,h[Pe],0,ze[Pe])!==0&&Se(`Can't bind output[${he}] to ${V[he]} for session=${e}.`)}}let X;y?X=await u._OrtRunWithBinding(d,y.handle,w,T,$):X=await u._OrtRun(d,W,B,b,U,w,T,$),X!==0&&Se("failed to call OrtRun().");let Ce=[];for(let K=0;K<w;K++){let V=u.HEAPU32[T/4+K];if(V===I[K]){Ce.push(a[K]);continue}let ze=u.stackSave(),he=u.stackAlloc(4*4),Pe=!1,we,Be=0;try{u._OrtGetTensorData(V,he,he+4,he+8,he+12)!==0&&Se(`Can't access output tensor data on index ${K}.`);let We=he/4,it=u.HEAPU32[We++];Be=u.HEAPU32[We++];let G=u.HEAPU32[We++],de=u.HEAPU32[We++],ge=[];for(let Ee=0;Ee<de;Ee++)ge.push(u.HEAPU32[G/4+Ee]);u._OrtFree(G);let Ne=ge.reduce((Ee,Ie)=>Ee*Ie,1);we=sr(it);let Ge=y?.outputPreferredLocations[o[K]];if(we==="string"){if(Ge==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Ee=[],Ie=Be/4;for(let Fe=0;Fe<Ne;Fe++){let Qe=u.HEAPU32[Ie++],Ve=Fe===Ne-1?void 0:u.HEAPU32[Ie]-Qe;Ee.push(u.UTF8ToString(Qe,Ve))}Ce.push([we,ge,Ee,"cpu"])}else if(Ge==="gpu-buffer"&&Ne>0){let Ee=u.jsepGetBuffer(Be),Ie=ur(it);if(Ie===void 0||!zr(we))throw new Error(`Unsupported data type: ${we}`);Pe=!0,Ce.push([we,ge,{gpuBuffer:Ee,download:u.jsepCreateDownloader(Ee,Ne*Ie,we),dispose:()=>{u._OrtReleaseTensor(V)}},"gpu-buffer"])}else{let Ee=Dr(we),Ie=new Ee(Ne);new Uint8Array(Ie.buffer,Ie.byteOffset,Ie.byteLength).set(u.HEAPU8.subarray(Be,Be+Ie.byteLength)),Ce.push([we,ge,Ie,"cpu"])}}finally{u.stackRestore(ze),we==="string"&&Be&&u._free(Be),Pe||u._OrtReleaseTensor(V)}}return y&&u._OrtClearBoundOutputs(y.handle),Ce}finally{u.stackRestore(M),x.forEach(F=>u._OrtReleaseTensor(F)),I.forEach(F=>u._OrtReleaseTensor(F)),R.forEach(F=>u._free(F)),$!==0&&u._OrtReleaseRunOptions($),v.forEach(F=>u._free(F))}},Ru=e=>{let t=Oe(),r=hr.get(e);if(!r)throw new Error("invalid session id");let o=r[0],a=t._OrtEndProfiling(o);a===0&&Se("Can't get an profile file name."),t._OrtFree(a)},ku=e=>{let t=[];for(let r of e){let o=r[2];!Array.isArray(o)&&"buffer"in o&&t.push(o.buffer)}return t}});var Bu=zt((z0,Ic)=>{Ic.exports='/*!\n * ONNX Runtime Web v1.17.0\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n"use strict";(()=>{var qr=Object.defineProperty;var tu=Object.getOwnPropertyDescriptor;var ru=Object.getOwnPropertyNames;var nu=Object.prototype.hasOwnProperty;var H=(e,t)=>()=>(e&&(t=e(e=0)),t);var Kt=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),yr=(e,t)=>{for(var r in t)qr(e,r,{get:t[r],enumerable:!0})},ou=(e,t,r,i)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of ru(t))!nu.call(e,o)&&o!==r&&qr(e,o,{get:()=>t[o],enumerable:!(i=tu(t,o))||i.enumerable});return e};var Tt=e=>ou(qr({},"__esModule",{value:!0}),e);var Yr={};yr(Yr,{readFile:()=>au});var au,Xr=H(()=>{au=void 0});var Qr={};yr(Qr,{join:()=>iu});var iu,Jr=H(()=>{iu=void 0});var Qn=Kt((Xn,Zr)=>{"use strict";var Yn=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){var r=t,i,o;r.ready=new Promise((u,p)=>{i=u,o=p}),r.jsepInit=(u,p,h,S,T,k,F,ne)=>{r.Za=u,r.Oa=p,r.Qa=h,r.Ja=S,r.Pa=T,r.ra=k,r.Ra=F,r.Sa=ne,p=(Y,Q,ee)=>(...ce)=>{let pe=Ne,E=Q?.();ce=Y(...ce);let ie=Q?.();return E!==ie&&(Y=ie,ee(E),Q=ee=null),Ne!=pe?ir():ce},h=Y=>async(...Q)=>{try{if(r.Da)throw Error("Session already started");let ee=r.Da={Ta:Q[0],errors:[]},ce=await Y(...Q);if(r.Da!==ee)throw Error("Session mismatch");u.flush();let pe=ee.errors;if(0<pe.length){let E=await Promise.all(pe);if(E=E.filter(ie=>ie),0<E.length)throw Error(E.join(`\n`))}return ce}finally{r.Da=null}},r._OrtRun=h(p(r._OrtRun,()=>r._OrtRun,Y=>r._OrtRun=Y)),r._OrtRunWithBinding=h(p(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,Y=>r._OrtRunWithBinding=Y)),r._OrtBindInput=p(r._OrtBindInput,()=>r._OrtBindInput,Y=>r._OrtBindInput=Y),r.jsepRegisterBuffer=(Y,Q,ee,ce)=>u.registerBuffer(Y,Q,ee,ce),r.jsepUnregisterBuffers=Y=>{u.unregisterBuffers(Y)},r.jsepGetBuffer=Y=>u.getBuffer(Y),r.jsepCreateDownloader=(Y,Q,ee)=>u.createDownloader(Y,Q,ee)};var s=Object.assign({},r),l="./this.program",n=(u,p)=>{throw p},c=typeof window=="object",m=typeof importScripts=="function",g=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",C="",x,$,b;if(g){var w=(Xr(),Tt(Yr)),v=(Jr(),Tt(Qr));C=m?v.dirname(C)+"/":__dirname+"/",x=(u,p)=>(u=u.startsWith("file://")?new URL(u):v.normalize(u),w.readFileSync(u,p?void 0:"utf8")),b=u=>(u=x(u,!0),u.buffer||(u=new Uint8Array(u)),u),$=(u,p,h,S=!0)=>{u=u.startsWith("file://")?new URL(u):v.normalize(u),w.readFile(u,S?void 0:"utf8",(T,k)=>{T?h(T):p(S?k.buffer:k)})},!r.thisProgram&&1<process.argv.length&&(l=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),n=(u,p)=>{throw process.exitCode=u,p},r.inspect=()=>"[Emscripten Module object]"}else(c||m)&&(m?C=self.location.href:typeof document<"u"&&document.currentScript&&(C=document.currentScript.src),e&&(C=e),C.indexOf("blob:")!==0?C=C.substr(0,C.replace(/[?#].*/,"").lastIndexOf("/")+1):C="",x=u=>{var p=new XMLHttpRequest;return p.open("GET",u,!1),p.send(null),p.responseText},m&&(b=u=>{var p=new XMLHttpRequest;return p.open("GET",u,!1),p.responseType="arraybuffer",p.send(null),new Uint8Array(p.response)}),$=(u,p,h)=>{var S=new XMLHttpRequest;S.open("GET",u,!0),S.responseType="arraybuffer",S.onload=()=>{S.status==200||S.status==0&&S.response?p(S.response):h()},S.onerror=h,S.send(null)});var I=r.print||console.log.bind(console),B=r.printErr||console.error.bind(console);Object.assign(r,s),s=null,r.thisProgram&&(l=r.thisProgram),r.quit&&(n=r.quit);var z;r.wasmBinary&&(z=r.wasmBinary);var M=r.noExitRuntime||!0;typeof WebAssembly!="object"&&We("no native wasm support detected");var G,_,U=!1,V,j,le,R,X,Se;function q(){var u=G.buffer;r.HEAP8=j=new Int8Array(u),r.HEAP16=new Int16Array(u),r.HEAP32=R=new Int32Array(u),r.HEAPU8=le=new Uint8Array(u),r.HEAPU16=new Uint16Array(u),r.HEAPU32=X=new Uint32Array(u),r.HEAPF32=new Float32Array(u),r.HEAPF64=Se=new Float64Array(u)}var L=[],De=[],he=[];function Re(){var u=r.preRun.shift();L.unshift(u)}var we=0,Be=null,Ke=null;function We(u){throw r.onAbort&&r.onAbort(u),u="Aborted("+u+")",B(u),U=!0,V=1,u=new WebAssembly.RuntimeError(u+". Build with -sASSERTIONS for more info."),o(u),u}function nt(u){return u.startsWith("data:application/octet-stream;base64,")}var N;if(N="ort-wasm-simd.wasm",!nt(N)){var de=N;N=r.locateFile?r.locateFile(de,C):C+de}function ge(u){if(u==N&&z)return new Uint8Array(z);if(b)return b(u);throw"both async and sync fetching of the wasm failed"}function ze(u){if(!z&&(c||m)){if(typeof fetch=="function"&&!u.startsWith("file://"))return fetch(u,{credentials:"same-origin"}).then(p=>{if(!p.ok)throw"failed to load wasm binary file at \'"+u+"\'";return p.arrayBuffer()}).catch(()=>ge(u));if($)return new Promise((p,h)=>{$(u,S=>p(new Uint8Array(S)),h)})}return Promise.resolve().then(()=>ge(u))}function Ge(u,p,h){return ze(u).then(S=>WebAssembly.instantiate(S,p)).then(S=>S).then(h,S=>{B("failed to asynchronously prepare wasm: "+S),We(S)})}function Te(u,p){var h=N;return z||typeof WebAssembly.instantiateStreaming!="function"||nt(h)||h.startsWith("file://")||g||typeof fetch!="function"?Ge(h,u,p):fetch(h,{credentials:"same-origin"}).then(S=>WebAssembly.instantiateStreaming(S,u).then(p,function(T){return B("wasm streaming compile failed: "+T),B("falling back to ArrayBuffer instantiation"),Ge(h,u,p)}))}var Ae,Ue={910336:u=>{r.ra("Abs",u,void 0)},910387:u=>{r.ra("Neg",u,void 0)},910438:u=>{r.ra("Floor",u,void 0)},910491:u=>{r.ra("Ceil",u,void 0)},910543:u=>{r.ra("Reciprocal",u,void 0)},910601:u=>{r.ra("Sqrt",u,void 0)},910653:u=>{r.ra("Exp",u,void 0)},910704:u=>{r.ra("Erf",u,void 0)},910755:u=>{r.ra("Sigmoid",u,void 0)},910810:u=>{r.ra("Log",u,void 0)},910861:u=>{r.ra("Sin",u,void 0)},910912:u=>{r.ra("Cos",u,void 0)},910963:u=>{r.ra("Tan",u,void 0)},911014:u=>{r.ra("Asin",u,void 0)},911066:u=>{r.ra("Acos",u,void 0)},911118:u=>{r.ra("Atan",u,void 0)},911170:u=>{r.ra("Sinh",u,void 0)},911222:u=>{r.ra("Cosh",u,void 0)},911274:u=>{r.ra("Asinh",u,void 0)},911327:u=>{r.ra("Acosh",u,void 0)},911380:u=>{r.ra("Atanh",u,void 0)},911433:u=>{r.ra("Tanh",u,void 0)},911485:u=>{r.ra("Not",u,void 0)},911536:(u,p,h)=>{r.ra("ClipV10",u,{min:p,max:h})},911608:u=>{r.ra("Clip",u,void 0)},911660:(u,p)=>{r.ra("Elu",u,{alpha:p})},911718:u=>{r.ra("Relu",u,void 0)},911770:(u,p)=>{r.ra("LeakyRelu",u,{alpha:p})},911834:(u,p)=>{r.ra("ThresholdedRelu",u,{alpha:p})},911904:(u,p)=>{r.ra("Cast",u,{to:p})},911962:u=>{r.ra("Add",u,void 0)},912013:u=>{r.ra("Sub",u,void 0)},912064:u=>{r.ra("Mul",u,void 0)},912115:u=>{r.ra("Div",u,void 0)},912166:u=>{r.ra("Pow",u,void 0)},912217:u=>{r.ra("Equal",u,void 0)},912270:u=>{r.ra("Greater",u,void 0)},912325:u=>{r.ra("GreaterOrEqual",u,void 0)},912387:u=>{r.ra("Less",u,void 0)},912439:u=>{r.ra("LessOrEqual",u,void 0)},912498:(u,p,h,S,T)=>{r.ra("ReduceMean",u,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(R.subarray(T>>>0,T+S>>>0)):[]})},912662:(u,p,h,S,T)=>{r.ra("ReduceMax",u,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(R.subarray(T>>>0,T+S>>>0)):[]})},912825:(u,p,h,S,T)=>{r.ra("ReduceMin",u,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(R.subarray(T>>>0,T+S>>>0)):[]})},912988:(u,p,h,S,T)=>{r.ra("ReduceProd",u,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(R.subarray(T>>>0,T+S>>>0)):[]})},913152:(u,p,h,S,T)=>{r.ra("ReduceSum",u,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(R.subarray(T>>>0,T+S>>>0)):[]})},913315:(u,p,h,S,T)=>{r.ra("ReduceL1",u,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(R.subarray(T>>>0,T+S>>>0)):[]})},913477:(u,p,h,S,T)=>{r.ra("ReduceL2",u,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(R.subarray(T>>>0,T+S>>>0)):[]})},913639:(u,p,h,S,T)=>{r.ra("ReduceLogSum",u,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(R.subarray(T>>>0,T+S>>>0)):[]})},913805:(u,p,h,S,T)=>{r.ra("ReduceSumSquare",u,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(R.subarray(T>>>0,T+S>>>0)):[]})},913974:(u,p,h,S,T)=>{r.ra("ReduceLogSumExp",u,{keepDims:!!p,noopWithEmptyAxes:!!h,axes:S?Array.from(R.subarray(T>>>0,T+S>>>0)):[]})},914143:u=>{r.ra("Where",u,void 0)},914196:(u,p,h)=>{r.ra("Transpose",u,{perm:p?Array.from(R.subarray(h>>>0,h+p>>>0)):[]})},914309:(u,p,h,S,T,k,F,ne,Y,Q)=>{r.ra("Conv",u,{format:Y?"NHWC":"NCHW",auto_pad:p,dilations:[h],group:S,kernel_shape:[T],pads:[k,F],strides:[ne],w_is_const:()=>!!j[Q>>>0]})},914537:(u,p,h,S,T,k,F,ne,Y,Q,ee,ce,pe,E,ie)=>{r.ra("Conv",u,{format:E?"NHWC":"NCHW",auto_pad:p,dilations:[h,S],group:T,kernel_shape:[k,F],pads:[ne,Y,Q,ee],strides:[ce,pe],w_is_const:()=>!!j[ie>>>0]})},914796:(u,p,h,S,T,k,F,ne,Y,Q)=>{r.ra("Conv",u,{format:Y?"NHWC":"NCHW",auto_pad:p,dilations:[h],group:S,kernel_shape:[T],pads:[k,F],strides:[ne],w_is_const:()=>!!j[Q>>>0]})},915024:(u,p,h,S,T,k,F,ne,Y,Q,ee,ce,pe,E,ie)=>{r.ra("Conv",u,{format:E?"NHWC":"NCHW",auto_pad:p,dilations:[h,S],group:T,kernel_shape:[k,F],pads:[ne,Y,Q,ee],strides:[ce,pe],w_is_const:()=>!!j[ie>>>0]})},915283:(u,p,h,S,T,k,F,ne,Y,Q,ee,ce,pe,E)=>{r.ra("ConvTranspose",u,{format:Y?"NHWC":"NCHW",autoPad:p,dilations:[h],group:S,kernel_shape:[T],pads:[k,F],strides:[ne],wIsConst:()=>!!j[Q>>>0],outputPadding:ee?Array.from(R.subarray(ce>>>0,ce+ee>>>0)):[],outputShape:pe?Array.from(R.subarray(E>>>0,E+pe>>>0)):[]})},915663:(u,p,h,S,T,k,F,ne,Y,Q,ee,ce,pe)=>{r.ra("ConvTranspose",u,{format:ne?"NHWC":"NCHW",autoPad:p,dilations:Array.from(R.subarray(h>>>0,h+2>>>0)),group:S,kernelShape:Array.from(R.subarray(T>>>0,T+2>>>0)),pads:Array.from(R.subarray(k>>>0,k+4>>>0)),strides:Array.from(R.subarray(F>>>0,F+2>>>0)),wIsConst:()=>!!j[Y>>>0],outputPadding:0<Q?Array.from(R.subarray(ee>>>0,ee+Q>>>0)):[],outputShape:0<ce?Array.from(R.subarray(pe>>>0,pe+ce>>>0)):[]})},916186:(u,p,h,S,T,k,F,ne,Y,Q,ee,ce,pe,E)=>{r.ra("ConvTranspose",u,{format:Y?"NHWC":"NCHW",autoPad:p,dilations:[h],group:S,kernel_shape:[T],pads:[k,F],strides:[ne],wIsConst:()=>!!j[Q>>>0],outputPadding:ee?Array.from(R.subarray(ce>>>0,ce+ee>>>0)):[],outputShape:pe?Array.from(R.subarray(E>>>0,E+pe>>>0)):[]})},916566:(u,p,h,S,T,k,F,ne,Y,Q,ee,ce,pe)=>{r.ra("ConvTranspose",u,{format:ne?"NHWC":"NCHW",autoPad:p,dilations:Array.from(R.subarray(h>>>0,h+2>>>0)),group:S,kernelShape:Array.from(R.subarray(T>>>0,T+2>>>0)),pads:Array.from(R.subarray(k>>>0,k+4>>>0)),strides:Array.from(R.subarray(F>>>0,F+2>>>0)),wIsConst:()=>!!j[Y>>>0],outputPadding:0<Q?Array.from(R.subarray(ee>>>0,ee+Q>>>0)):[],outputShape:0<ce?Array.from(R.subarray(pe>>>0,pe+ce>>>0)):[]})},917089:(u,p)=>{r.ra("GlobalAveragePool",u,{format:p?"NHWC":"NCHW"})},917180:(u,p,h,S,T,k,F,ne,Y,Q,ee,ce,pe,E,ie,ye)=>{r.ra("AveragePool",u,{format:ye?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:S,storage_order:T,dilations:[k,F],kernel_shape:[ne,Y],pads:[Q,ee,ce,pe],strides:[E,ie]})},917464:(u,p)=>{r.ra("GlobalAveragePool",u,{format:p?"NHWC":"NCHW"})},917555:(u,p,h,S,T,k,F,ne,Y,Q,ee,ce,pe,E,ie,ye)=>{r.ra("AveragePool",u,{format:ye?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:S,storage_order:T,dilations:[k,F],kernel_shape:[ne,Y],pads:[Q,ee,ce,pe],strides:[E,ie]})},917839:(u,p)=>{r.ra("GlobalMaxPool",u,{format:p?"NHWC":"NCHW"})},917926:(u,p,h,S,T,k,F,ne,Y,Q,ee,ce,pe,E,ie,ye)=>{r.ra("MaxPool",u,{format:ye?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:S,storage_order:T,dilations:[k,F],kernel_shape:[ne,Y],pads:[Q,ee,ce,pe],strides:[E,ie]})},918206:(u,p)=>{r.ra("GlobalMaxPool",u,{format:p?"NHWC":"NCHW"})},918293:(u,p,h,S,T,k,F,ne,Y,Q,ee,ce,pe,E,ie,ye)=>{r.ra("MaxPool",u,{format:ye?"NHWC":"NCHW",auto_pad:p,ceil_mode:h,count_include_pad:S,storage_order:T,dilations:[k,F],kernel_shape:[ne,Y],pads:[Q,ee,ce,pe],strides:[E,ie]})},918573:(u,p,h,S,T)=>{r.ra("Gemm",u,{alpha:p,beta:h,transA:S,transB:T})},918677:u=>{r.ra("MatMul",u,void 0)},918731:(u,p,h,S)=>{r.ra("ArgMax",u,{keepDims:!!p,selectLastIndex:!!h,axis:S})},918839:(u,p,h,S)=>{r.ra("ArgMin",u,{keepDims:!!p,selectLastIndex:!!h,axis:S})},918947:(u,p)=>{r.ra("Softmax",u,{axis:p})},919010:(u,p)=>{r.ra("Concat",u,{axis:p})},919070:(u,p,h,S,T)=>{r.ra("Split",u,{axis:p,numOutputs:h,splitSizes:S?Array.from(R.subarray(T>>>0,T+S>>>0)):[]})},919215:u=>{r.ra("Expand",u,void 0)},919269:(u,p)=>{r.ra("Gather",u,{axis:Number(p)})},919340:(u,p)=>{r.ra("GatherElements",u,{axis:Number(p)})},919419:(u,p,h,S,T,k,F,ne,Y,Q,ee)=>{r.ra("Resize",u,{antialias:p,axes:h?Array.from(R.subarray(S>>>0,S+h>>>0)):[],coordinateTransformMode:Fe(T),cubicCoeffA:k,excludeOutside:F,extrapolationValue:ne,keepAspectRatioPolicy:Fe(Y),mode:Fe(Q),nearestMode:Fe(ee)})},919770:(u,p,h,S,T,k,F)=>{r.ra("Slice",u,{starts:p?Array.from(R.subarray(h>>>0,h+p>>>0)):[],ends:S?Array.from(R.subarray(T>>>0,T+S>>>0)):[],axes:k?Array.from(R.subarray(F>>>0,F+k>>>0)):[]})},920001:u=>{r.ra("Tile",u,void 0)},920053:(u,p,h)=>{r.ra("LayerNormalization",u,{axis:Number(p),epsilon:Number(h)})},920160:(u,p,h)=>{r.ra("InstanceNormalization",u,{epsilon:p,format:h?"NHWC":"NCHW"})},920274:(u,p,h)=>{r.ra("InstanceNormalization",u,{epsilon:p,format:h?"NHWC":"NCHW"})},920388:u=>{r.ra("Range",u,void 0)},920441:(u,p)=>{r.ra("Einsum",u,{equation:Fe(p)})},920522:(u,p,h,S,T)=>{r.ra("Pad",u,{mode:p,value:h,pads:S?Array.from(R.subarray(T>>>0,T+S>>>0)):[]})},920654:u=>{r.ra("Gelu",u,void 0)},920706:u=>{r.ra("BiasAdd",u,void 0)},920761:u=>{r.ra("BiasSplitGelu",u,void 0)},920822:(u,p)=>{r.ra("SkipLayerNormalization",u,{epsilon:p})},920903:u=>{r.Ra(u)},920937:(u,p)=>r.Sa(u,p,r.Da.Ta,r.Da.errors),921049:u=>r.Oa(u),921082:u=>r.Qa(u),921114:(u,p,h)=>{r.Ja(u,p,h,!0)},921153:(u,p,h)=>{r.Ja(u,p,h)}};function qe(u){this.name="ExitStatus",this.message=`Program terminated with exit(${u})`,this.status=u}var Ve=u=>{for(;0<u.length;)u.shift()(r)};function or(u){this.Ha=u-24,this.Ma=function(p){X[this.Ha+4>>2>>>0]=p},this.La=function(p){X[this.Ha+8>>2>>>0]=p},this.Ya=function(p,h){this.Ka(),this.Ma(p),this.La(h)},this.Ka=function(){X[this.Ha+16>>2>>>0]=0}}var Ot=0,Ye=0,_t=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,ot=(u,p,h)=>{p>>>=0;var S=p+h;for(h=p;u[h]&&!(h>=S);)++h;if(16<h-p&&u.buffer&&_t)return _t.decode(u.subarray(p,h));for(S="";p<h;){var T=u[p++];if(T&128){var k=u[p++]&63;if((T&224)==192)S+=String.fromCharCode((T&31)<<6|k);else{var F=u[p++]&63;T=(T&240)==224?(T&15)<<12|k<<6|F:(T&7)<<18|k<<12|F<<6|u[p++]&63,65536>T?S+=String.fromCharCode(T):(T-=65536,S+=String.fromCharCode(55296|T>>10,56320|T&1023))}}else S+=String.fromCharCode(T)}return S},Fe=(u,p)=>(u>>>=0)?ot(le,u,p):"",Pt=u=>{for(var p=0,h=0;h<u.length;++h){var S=u.charCodeAt(h);127>=S?p++:2047>=S?p+=2:55296<=S&&57343>=S?(p+=4,++h):p+=3}return p},wt=(u,p,h,S)=>{if(h>>>=0,!(0<S))return 0;var T=h;S=h+S-1;for(var k=0;k<u.length;++k){var F=u.charCodeAt(k);if(55296<=F&&57343>=F){var ne=u.charCodeAt(++k);F=65536+((F&1023)<<10)|ne&1023}if(127>=F){if(h>=S)break;p[h++>>>0]=F}else{if(2047>=F){if(h+1>=S)break;p[h++>>>0]=192|F>>6}else{if(65535>=F){if(h+2>=S)break;p[h++>>>0]=224|F>>12}else{if(h+3>=S)break;p[h++>>>0]=240|F>>18,p[h++>>>0]=128|F>>12&63}p[h++>>>0]=128|F>>6&63}p[h++>>>0]=128|F&63}}return p[h>>>0]=0,h-T},st=u=>u%4===0&&(u%100!==0||u%400===0),at=[0,31,60,91,121,152,182,213,244,274,305,335],vt=[0,31,59,90,120,151,181,212,243,273,304,334],dt=u=>{var p=Pt(u)+1,h=At(p);return h&&wt(u,le,h,p),h},ct=[],Rt=(u,p)=>{ct.length=0;var h;for(p>>=2;h=le[u++>>>0];)p+=h!=105&p,ct.push(h==105?R[p>>>0]:Se[p++>>>1]),++p;return ct},$t={},Bt=()=>{if(!xt){var u={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:l||"./this.program"},p;for(p in $t)$t[p]===void 0?delete u[p]:u[p]=$t[p];var h=[];for(p in u)h.push(`${p}=${u[p]}`);xt=h}return xt},xt,Xe=[null,[],[]],Mt=[31,29,31,30,31,30,31,31,30,31,30,31],Ct=[31,28,31,30,31,30,31,31,30,31,30,31];function oe(u){var p=Array(Pt(u)+1);return wt(u,p,0,p.length),p}function pt(u,p,h,S){function T(E,ie,ye){for(E=typeof E=="number"?E.toString():E||"";E.length<ie;)E=ye[0]+E;return E}function k(E,ie){return T(E,ie,"0")}function F(E,ie){function ye(jt){return 0>jt?-1:0<jt?1:0}var Qe;return(Qe=ye(E.getFullYear()-ie.getFullYear()))===0&&(Qe=ye(E.getMonth()-ie.getMonth()))===0&&(Qe=ye(E.getDate()-ie.getDate())),Qe}function ne(E){switch(E.getDay()){case 0:return new Date(E.getFullYear()-1,11,29);case 1:return E;case 2:return new Date(E.getFullYear(),0,3);case 3:return new Date(E.getFullYear(),0,2);case 4:return new Date(E.getFullYear(),0,1);case 5:return new Date(E.getFullYear()-1,11,31);case 6:return new Date(E.getFullYear()-1,11,30)}}function Y(E){var ie=E.Ba;for(E=new Date(new Date(E.Ca+1900,0,1).getTime());0<ie;){var ye=E.getMonth(),Qe=(st(E.getFullYear())?Mt:Ct)[ye];if(ie>Qe-E.getDate())ie-=Qe-E.getDate()+1,E.setDate(1),11>ye?E.setMonth(ye+1):(E.setMonth(0),E.setFullYear(E.getFullYear()+1));else{E.setDate(E.getDate()+ie);break}}return ye=new Date(E.getFullYear()+1,0,4),ie=ne(new Date(E.getFullYear(),0,4)),ye=ne(ye),0>=F(ie,E)?0>=F(ye,E)?E.getFullYear()+1:E.getFullYear():E.getFullYear()-1}u>>>=0,p>>>=0,h>>>=0,S>>>=0;var Q=R[S+40>>2>>>0];S={Wa:R[S>>2>>>0],Va:R[S+4>>2>>>0],Ea:R[S+8>>2>>>0],Ia:R[S+12>>2>>>0],Fa:R[S+16>>2>>>0],Ca:R[S+20>>2>>>0],wa:R[S+24>>2>>>0],Ba:R[S+28>>2>>>0],$a:R[S+32>>2>>>0],Ua:R[S+36>>2>>>0],Xa:Q?Fe(Q):""},h=Fe(h),Q={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ee in Q)h=h.replace(new RegExp(ee,"g"),Q[ee]);var ce="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),pe="January February March April May June July August September October November December".split(" ");Q={"%a":E=>ce[E.wa].substring(0,3),"%A":E=>ce[E.wa],"%b":E=>pe[E.Fa].substring(0,3),"%B":E=>pe[E.Fa],"%C":E=>k((E.Ca+1900)/100|0,2),"%d":E=>k(E.Ia,2),"%e":E=>T(E.Ia,2," "),"%g":E=>Y(E).toString().substring(2),"%G":E=>Y(E),"%H":E=>k(E.Ea,2),"%I":E=>(E=E.Ea,E==0?E=12:12<E&&(E-=12),k(E,2)),"%j":E=>{for(var ie=0,ye=0;ye<=E.Fa-1;ie+=(st(E.Ca+1900)?Mt:Ct)[ye++]);return k(E.Ia+ie,3)},"%m":E=>k(E.Fa+1,2),"%M":E=>k(E.Va,2),"%n":()=>`\n`,"%p":E=>0<=E.Ea&&12>E.Ea?"AM":"PM","%S":E=>k(E.Wa,2),"%t":()=>"	","%u":E=>E.wa||7,"%U":E=>k(Math.floor((E.Ba+7-E.wa)/7),2),"%V":E=>{var ie=Math.floor((E.Ba+7-(E.wa+6)%7)/7);if(2>=(E.wa+371-E.Ba-2)%7&&ie++,ie)ie==53&&(ye=(E.wa+371-E.Ba)%7,ye==4||ye==3&&st(E.Ca)||(ie=1));else{ie=52;var ye=(E.wa+7-E.Ba-1)%7;(ye==4||ye==5&&st(E.Ca%400-1))&&ie++}return k(ie,2)},"%w":E=>E.wa,"%W":E=>k(Math.floor((E.Ba+7-(E.wa+6)%7)/7),2),"%y":E=>(E.Ca+1900).toString().substring(2),"%Y":E=>E.Ca+1900,"%z":E=>{E=E.Ua;var ie=0<=E;return E=Math.abs(E)/60,(ie?"+":"-")+("0000"+(E/60*100+E%60)).slice(-4)},"%Z":E=>E.Xa,"%%":()=>"%"},h=h.replace(/%%/g,"\\0\\0");for(ee in Q)h.includes(ee)&&(h=h.replace(new RegExp(ee,"g"),Q[ee](S)));return h=h.replace(/\\0\\0/g,"%"),ee=oe(h),ee.length>p?0:(j.set(ee,u>>>0),ee.length-1)}function ft(u){try{u()}catch(p){We(p)}}function Nr(u){var p={},h;for(h in u)(function(S){var T=u[S];p[S]=typeof T=="function"?function(){mt.push(S);try{return T.apply(null,arguments)}finally{U||(mt.pop()===S||We(),Ne&&He===1&&mt.length===0&&(He=0,ft(It),typeof Fibers<"u"&&Fibers.ab()))}}:T})(h);return p}var He=0,Ne=null,kt=0,mt=[],Dt={},Wt={},zt=0,St=null,ar=[];function ir(){return new Promise((u,p)=>{St={resolve:u,reject:p}})}function sr(){var u=At(65548),p=u+12;X[u>>2>>>0]=p,X[u+4>>2>>>0]=p+65536,p=mt[0];var h=Dt[p];return h===void 0&&(h=zt++,Dt[p]=h,Wt[h]=p),R[u+8>>2>>>0]=h,u}function ur(u){if(!U){if(He===0){var p=!1,h=!1;u((S=0)=>{if(!U&&(kt=S,p=!0,h)){He=2,ft(()=>ht(Ne)),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.resume(),S=!1;try{var T=(0,_[Wt[R[Ne+8>>2>>>0]]])()}catch(ne){T=ne,S=!0}var k=!1;if(!Ne){var F=St;F&&(St=null,(S?F.reject:F.resolve)(T),k=!0)}if(S&&!k)throw T}}),h=!0,p||(He=1,Ne=sr(),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.pause(),ft(()=>Ht(Ne)))}else He===2?(He=0,ft(it),Gt(Ne),Ne=null,ar.forEach(S=>{if(!U)try{if(S(),!M)try{V=V=S=V,M||(r.onExit&&r.onExit(S),U=!0),n(S,new qe(S))}catch(T){T instanceof qe||T=="unwind"||n(1,T)}}catch(T){T instanceof qe||T=="unwind"||n(1,T)}})):We(`invalid state: ${He}`);return kt}}function lr(u){return ur(p=>{u().then(p)})}var dr={n:function(u,p,h){return lr(async()=>{await r.Pa(u,p,h)})},a:function(u,p,h){throw u>>>=0,new or(u).Ya(p>>>0,h>>>0),Ot=u,Ye++,Ot},g:function(){return 0},J:function(){},z:function(){},B:function(){},L:function(){return 0},H:function(){},C:function(){},G:function(){},l:function(){},A:function(){},x:function(){},I:function(){},y:function(){},m:()=>!0,q:function(u,p,h){u=p+2097152>>>0<4194305-!!u?(u>>>0)+4294967296*p:NaN,h>>>=0,u=new Date(1e3*u),R[h>>2>>>0]=u.getUTCSeconds(),R[h+4>>2>>>0]=u.getUTCMinutes(),R[h+8>>2>>>0]=u.getUTCHours(),R[h+12>>2>>>0]=u.getUTCDate(),R[h+16>>2>>>0]=u.getUTCMonth(),R[h+20>>2>>>0]=u.getUTCFullYear()-1900,R[h+24>>2>>>0]=u.getUTCDay(),R[h+28>>2>>>0]=(u.getTime()-Date.UTC(u.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(u,p,h){u=p+2097152>>>0<4194305-!!u?(u>>>0)+4294967296*p:NaN,h>>>=0,u=new Date(1e3*u),R[h>>2>>>0]=u.getSeconds(),R[h+4>>2>>>0]=u.getMinutes(),R[h+8>>2>>>0]=u.getHours(),R[h+12>>2>>>0]=u.getDate(),R[h+16>>2>>>0]=u.getMonth(),R[h+20>>2>>>0]=u.getFullYear()-1900,R[h+24>>2>>>0]=u.getDay(),R[h+28>>2>>>0]=(st(u.getFullYear())?at:vt)[u.getMonth()]+u.getDate()-1|0,R[h+36>>2>>>0]=-(60*u.getTimezoneOffset()),p=new Date(u.getFullYear(),6,1).getTimezoneOffset();var S=new Date(u.getFullYear(),0,1).getTimezoneOffset();R[h+32>>2>>>0]=(p!=S&&u.getTimezoneOffset()==Math.min(S,p))|0},s:function(u){u>>>=0;var p=new Date(R[u+20>>2>>>0]+1900,R[u+16>>2>>>0],R[u+12>>2>>>0],R[u+8>>2>>>0],R[u+4>>2>>>0],R[u>>2>>>0],0),h=R[u+32>>2>>>0],S=p.getTimezoneOffset(),T=new Date(p.getFullYear(),6,1).getTimezoneOffset(),k=new Date(p.getFullYear(),0,1).getTimezoneOffset(),F=Math.min(k,T);return 0>h?R[u+32>>2>>>0]=+(T!=k&&F==S):0<h!=(F==S)&&(T=Math.max(k,T),p.setTime(p.getTime()+6e4*((0<h?F:T)-S))),R[u+24>>2>>>0]=p.getDay(),R[u+28>>2>>>0]=(st(p.getFullYear())?at:vt)[p.getMonth()]+p.getDate()-1|0,R[u>>2>>>0]=p.getSeconds(),R[u+4>>2>>>0]=p.getMinutes(),R[u+8>>2>>>0]=p.getHours(),R[u+12>>2>>>0]=p.getDate(),R[u+16>>2>>>0]=p.getMonth(),R[u+20>>2>>>0]=p.getYear(),u=p.getTime()/1e3,Ut((Ae=u,1<=+Math.abs(Ae)?0<Ae?+Math.floor(Ae/4294967296)>>>0:~~+Math.ceil((Ae-+(~~Ae>>>0))/4294967296)>>>0:0)),u>>>0},o:function(){return-52},p:function(){},v:function(u,p,h){function S(Y){return(Y=Y.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?Y[1]:"GMT"}h>>>=0;var T=new Date().getFullYear(),k=new Date(T,0,1),F=new Date(T,6,1);T=k.getTimezoneOffset();var ne=F.getTimezoneOffset();X[u>>>0>>2>>>0]=60*Math.max(T,ne),R[p>>>0>>2>>>0]=+(T!=ne),u=S(k),p=S(F),u=dt(u),p=dt(p),ne<T?(X[h>>2>>>0]=u,X[h+4>>2>>>0]=p):(X[h>>2>>>0]=p,X[h+4>>2>>>0]=u)},e:()=>{We("")},b:function(u,p,h){return u>>>=0,p=Rt(p>>>0,h>>>0),Ue[u].apply(null,p)},i:function(u,p,h){return u>>>=0,p=Rt(p>>>0,h>>>0),Ue[u].apply(null,p)},h:function(){return Date.now()},w:function(){return 4294901760},c:()=>performance.now(),K:function(u,p,h){return p>>>=0,le.copyWithin(u>>>0>>>0,p>>>0,p+(h>>>0)>>>0)},u:function(u){u>>>=0;var p=le.length;if(4294901760<u)return!1;for(var h=1;4>=h;h*=2){var S=p*(1+.2/h);S=Math.min(S,u+100663296);var T=Math;S=Math.max(u,S);e:{T=T.min.call(T,4294901760,S+(65536-S%65536)%65536)-G.buffer.byteLength+65535>>>16;try{G.grow(T),q();var k=1;break e}catch{}k=void 0}if(k)return!0}return!1},D:function(u,p){u>>>=0,p>>>=0;var h=0;return Bt().forEach(function(S,T){var k=p+h;for(T=X[u+4*T>>2>>>0]=k,k=0;k<S.length;++k)j[T++>>0>>>0]=S.charCodeAt(k);j[T>>0>>>0]=0,h+=S.length+1}),0},E:function(u,p){u>>>=0,p>>>=0;var h=Bt();X[u>>2>>>0]=h.length;var S=0;return h.forEach(function(T){S+=T.length+1}),X[p>>2>>>0]=S,0},f:()=>52,k:function(){return 52},t:function(){return 70},j:function(u,p,h,S){p>>>=0,h>>>=0,S>>>=0;for(var T=0,k=0;k<h;k++){var F=X[p>>2>>>0],ne=X[p+4>>2>>>0];p+=8;for(var Y=0;Y<ne;Y++){var Q=le[F+Y>>>0],ee=Xe[u];Q===0||Q===10?((u===1?I:B)(ot(ee,0)),ee.length=0):ee.push(Q)}T+=ne}return X[S>>2>>>0]=T,0},F:pt,d:function(u,p,h,S){return pt(u>>>0,p>>>0,h>>>0,S>>>0)}};(function(){function u(h){if(h=h.exports,h=Nr(h),_=h=cr(h),G=_.M,q(),De.unshift(_.N),we--,r.monitorRunDependencies&&r.monitorRunDependencies(we),we==0&&(Be!==null&&(clearInterval(Be),Be=null),Ke)){var S=Ke;Ke=null,S()}return h}var p={a:dr};if(we++,r.monitorRunDependencies&&r.monitorRunDependencies(we),r.instantiateWasm)try{return r.instantiateWasm(p,u)}catch(h){B("Module.instantiateWasm callback failed with error: "+h),o(h)}return Te(p,function(h){u(h.instance)}).catch(o),{}})(),r._OrtInit=(u,p)=>(r._OrtInit=_.O)(u,p),r._OrtGetLastError=(u,p)=>(r._OrtGetLastError=_.P)(u,p),r._OrtCreateSessionOptions=(u,p,h,S,T,k,F,ne,Y,Q)=>(r._OrtCreateSessionOptions=_.Q)(u,p,h,S,T,k,F,ne,Y,Q),r._OrtAppendExecutionProvider=(u,p)=>(r._OrtAppendExecutionProvider=_.R)(u,p),r._OrtAddFreeDimensionOverride=(u,p,h)=>(r._OrtAddFreeDimensionOverride=_.S)(u,p,h),r._OrtAddSessionConfigEntry=(u,p,h)=>(r._OrtAddSessionConfigEntry=_.T)(u,p,h),r._OrtReleaseSessionOptions=u=>(r._OrtReleaseSessionOptions=_.U)(u),r._OrtCreateSession=(u,p,h)=>(r._OrtCreateSession=_.V)(u,p,h),r._OrtReleaseSession=u=>(r._OrtReleaseSession=_.W)(u),r._OrtGetInputOutputCount=(u,p,h)=>(r._OrtGetInputOutputCount=_.X)(u,p,h),r._OrtGetInputName=(u,p)=>(r._OrtGetInputName=_.Y)(u,p),r._OrtGetOutputName=(u,p)=>(r._OrtGetOutputName=_.Z)(u,p),r._OrtFree=u=>(r._OrtFree=_._)(u),r._OrtCreateTensor=(u,p,h,S,T,k)=>(r._OrtCreateTensor=_.$)(u,p,h,S,T,k),r._OrtGetTensorData=(u,p,h,S,T)=>(r._OrtGetTensorData=_.aa)(u,p,h,S,T),r._OrtReleaseTensor=u=>(r._OrtReleaseTensor=_.ba)(u),r._OrtCreateRunOptions=(u,p,h,S)=>(r._OrtCreateRunOptions=_.ca)(u,p,h,S),r._OrtAddRunConfigEntry=(u,p,h)=>(r._OrtAddRunConfigEntry=_.da)(u,p,h),r._OrtReleaseRunOptions=u=>(r._OrtReleaseRunOptions=_.ea)(u),r._OrtCreateBinding=u=>(r._OrtCreateBinding=_.fa)(u),r._OrtBindInput=(u,p,h)=>(r._OrtBindInput=_.ga)(u,p,h),r._OrtBindOutput=(u,p,h,S)=>(r._OrtBindOutput=_.ha)(u,p,h,S),r._OrtClearBoundOutputs=u=>(r._OrtClearBoundOutputs=_.ia)(u),r._OrtReleaseBinding=u=>(r._OrtReleaseBinding=_.ja)(u),r._OrtRunWithBinding=(u,p,h,S,T)=>(r._OrtRunWithBinding=_.ka)(u,p,h,S,T),r._OrtRun=(u,p,h,S,T,k,F,ne)=>(r._OrtRun=_.la)(u,p,h,S,T,k,F,ne),r._OrtEndProfiling=u=>(r._OrtEndProfiling=_.ma)(u),r._JsepOutput=(u,p,h)=>(r._JsepOutput=_.na)(u,p,h),r._JsepGetNodeName=u=>(r._JsepGetNodeName=_.oa)(u);var At=r._malloc=u=>(At=r._malloc=_.pa)(u),Gt=r._free=u=>(Gt=r._free=_.qa)(u),Ut=u=>(Ut=_.sa)(u),Nt=()=>(Nt=_.ta)(),Vt=u=>(Vt=_.ua)(u),Ft=u=>(Ft=_.va)(u),Ht=u=>(Ht=_.xa)(u),It=()=>(It=_.ya)(),ht=u=>(ht=_.za)(u),it=()=>(it=_.Aa)();r.___start_em_js=921186,r.___stop_em_js=921347;function cr(u){u=Object.assign({},u);var p=S=>()=>S()>>>0,h=S=>T=>S(T)>>>0;return u.__errno_location=p(u.__errno_location),u.malloc=h(u.malloc),u.stackSave=p(u.stackSave),u.stackAlloc=h(u.stackAlloc),u}r.stackAlloc=Ft,r.stackSave=Nt,r.stackRestore=Vt,r.UTF8ToString=Fe,r.stringToUTF8=(u,p,h)=>wt(u,le,p,h),r.lengthBytesUTF8=Pt;var gt;Ke=function u(){gt||Lt(),gt||(Ke=u)};function Lt(){function u(){if(!gt&&(gt=!0,r.calledRun=!0,!U)){if(Ve(De),i(r),r.onRuntimeInitialized&&r.onRuntimeInitialized(),r.postRun)for(typeof r.postRun=="function"&&(r.postRun=[r.postRun]);r.postRun.length;){var p=r.postRun.shift();he.unshift(p)}Ve(he)}}if(!(0<we)){if(r.preRun)for(typeof r.preRun=="function"&&(r.preRun=[r.preRun]);r.preRun.length;)Re();Ve(L),0<we||(r.setStatus?(r.setStatus("Running..."),setTimeout(function(){setTimeout(function(){r.setStatus("")},1),u()},1)):u())}}if(r.preInit)for(typeof r.preInit=="function"&&(r.preInit=[r.preInit]);0<r.preInit.length;)r.preInit.pop()();return Lt(),t.ready}})();typeof Xn=="object"&&typeof Zr=="object"?Zr.exports=Yn:typeof define=="function"&&define.amd&&define([],()=>Yn)});var Jn=Kt(()=>{});var Zn=Kt(()=>{});var eo={};yr(eo,{cpus:()=>su});var su,to=H(()=>{su=void 0});var oo=Kt((no,en)=>{"use strict";var ro=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){function r(){return q.buffer!=we.buffer&&N(),we}function i(){return q.buffer!=we.buffer&&N(),Be}function o(){return q.buffer!=we.buffer&&N(),Ke}function s(){return q.buffer!=we.buffer&&N(),We}function l(){return q.buffer!=we.buffer&&N(),nt}var n=t,c,m;n.ready=new Promise((a,d)=>{c=a,m=d}),n.jsepInit=(a,d,f,y,A,P,W,te)=>{n.Qb=a,n.wb=d,n.yb=f,n.jb=y,n.xb=A,n.Ea=P,n.zb=W,n.Ab=te,d=(Z,J,re)=>(...fe)=>{let be=Je,O=J?.();fe=Z(...fe);let ue=J?.();return O!==ue&&(Z=ue,re(O),J=re=null),Je!=be?Ks():fe},f=Z=>async(...J)=>{try{if(n.bb)throw Error("Session already started");let re=n.bb={Fb:J[0],errors:[]},fe=await Z(...J);if(n.bb!==re)throw Error("Session mismatch");a.flush();let be=re.errors;if(0<be.length){let O=await Promise.all(be);if(O=O.filter(ue=>ue),0<O.length)throw Error(O.join(`\n`))}return fe}finally{n.bb=null}},n._OrtRun=f(d(n._OrtRun,()=>n._OrtRun,Z=>n._OrtRun=Z)),n._OrtRunWithBinding=f(d(n._OrtRunWithBinding,()=>n._OrtRunWithBinding,Z=>n._OrtRunWithBinding=Z)),n._OrtBindInput=d(n._OrtBindInput,()=>n._OrtBindInput,Z=>n._OrtBindInput=Z),n.jsepRegisterBuffer=(Z,J,re,fe)=>a.registerBuffer(Z,J,re,fe),n.jsepUnregisterBuffers=Z=>{a.unregisterBuffers(Z)},n.jsepGetBuffer=Z=>a.getBuffer(Z),n.jsepCreateDownloader=(Z,J,re)=>a.createDownloader(Z,J,re)};var g=Object.assign({},n),C="./this.program",x=(a,d)=>{throw d},$=typeof window=="object",b=typeof importScripts=="function",w=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",v=n.ENVIRONMENT_IS_PTHREAD||!1,I="";function B(a){return n.locateFile?n.locateFile(a,I):I+a}var z,M,G;if(w){var _=(Xr(),Tt(Yr)),U=(Jr(),Tt(Qr));I=b?U.dirname(I)+"/":__dirname+"/",z=(d,f)=>(d=d.startsWith("file://")?new URL(d):U.normalize(d),_.readFileSync(d,f?void 0:"utf8")),G=d=>(d=z(d,!0),d.buffer||(d=new Uint8Array(d)),d),M=(d,f,y,A=!0)=>{d=d.startsWith("file://")?new URL(d):U.normalize(d),_.readFile(d,A?void 0:"utf8",(P,W)=>{P?y(P):f(A?W.buffer:W)})},!n.thisProgram&&1<process.argv.length&&(C=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),x=(d,f)=>{throw process.exitCode=d,f},n.inspect=()=>"[Emscripten Module object]";let a;try{a=Jn()}catch(d){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),d}global.Worker=a.Worker}else($||b)&&(b?I=self.location.href:typeof document<"u"&&document.currentScript&&(I=document.currentScript.src),typeof e<"u"&&e&&(I=e),I.indexOf("blob:")!==0?I=I.substr(0,I.replace(/[?#].*/,"").lastIndexOf("/")+1):I="",w||(z=a=>{var d=new XMLHttpRequest;return d.open("GET",a,!1),d.send(null),d.responseText},b&&(G=a=>{var d=new XMLHttpRequest;return d.open("GET",a,!1),d.responseType="arraybuffer",d.send(null),new Uint8Array(d.response)}),M=(a,d,f)=>{var y=new XMLHttpRequest;y.open("GET",a,!0),y.responseType="arraybuffer",y.onload=()=>{y.status==200||y.status==0&&y.response?d(y.response):f()},y.onerror=f,y.send(null)}));w&&typeof performance>"u"&&(global.performance=Zn().performance);var V=console.log.bind(console),j=console.error.bind(console);w&&(V=(...a)=>_.writeSync(1,a.join(" ")+`\n`),j=(...a)=>_.writeSync(2,a.join(" ")+`\n`));var le=n.print||V,R=n.printErr||j;Object.assign(n,g),g=null,n.thisProgram&&(C=n.thisProgram),n.quit&&(x=n.quit);var X;n.wasmBinary&&(X=n.wasmBinary);var Se=n.noExitRuntime||!0;typeof WebAssembly!="object"&&Ye("no native wasm support detected");var q,L,De,he=!1,Re,we,Be,Ke,We,nt;function N(){var a=q.buffer;n.HEAP8=we=new Int8Array(a),n.HEAP16=new Int16Array(a),n.HEAP32=Ke=new Int32Array(a),n.HEAPU8=Be=new Uint8Array(a),n.HEAPU16=new Uint16Array(a),n.HEAPU32=We=new Uint32Array(a),n.HEAPF32=new Float32Array(a),n.HEAPF64=nt=new Float64Array(a)}var de=n.INITIAL_MEMORY||16777216;if(5242880<=de||Ye("INITIAL_MEMORY should be larger than STACK_SIZE, was "+de+"! (STACK_SIZE=5242880)"),v)q=n.wasmMemory;else if(n.wasmMemory)q=n.wasmMemory;else if(q=new WebAssembly.Memory({initial:de/65536,maximum:65536,shared:!0}),!(q.buffer instanceof SharedArrayBuffer))throw R("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),w&&R("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");N(),de=q.buffer.byteLength;var ge=[],ze=[],Ge=[],Te=0;function Ae(){return Se||0<Te}var Ue=0,qe=null,Ve=null;function or(){Ue++,n.monitorRunDependencies&&n.monitorRunDependencies(Ue)}function Ot(){if(Ue--,n.monitorRunDependencies&&n.monitorRunDependencies(Ue),Ue==0&&(qe!==null&&(clearInterval(qe),qe=null),Ve)){var a=Ve;Ve=null,a()}}function Ye(a){throw n.onAbort&&n.onAbort(a),a="Aborted("+a+")",R(a),he=!0,Re=1,a=new WebAssembly.RuntimeError(a+". Build with -sASSERTIONS for more info."),m(a),a}function _t(a){return a.startsWith("data:application/octet-stream;base64,")}var ot;ot="ort-wasm-simd-threaded.wasm",_t(ot)||(ot=B(ot));function Fe(a){if(a==ot&&X)return new Uint8Array(X);if(G)return G(a);throw"both async and sync fetching of the wasm failed"}function Pt(a){if(!X&&($||b)){if(typeof fetch=="function"&&!a.startsWith("file://"))return fetch(a,{credentials:"same-origin"}).then(d=>{if(!d.ok)throw"failed to load wasm binary file at \'"+a+"\'";return d.arrayBuffer()}).catch(()=>Fe(a));if(M)return new Promise((d,f)=>{M(a,y=>d(new Uint8Array(y)),f)})}return Promise.resolve().then(()=>Fe(a))}function wt(a,d,f){return Pt(a).then(y=>WebAssembly.instantiate(y,d)).then(y=>y).then(f,y=>{R("failed to asynchronously prepare wasm: "+y),Ye(y)})}function st(a,d){var f=ot;return X||typeof WebAssembly.instantiateStreaming!="function"||_t(f)||f.startsWith("file://")||w||typeof fetch!="function"?wt(f,a,d):fetch(f,{credentials:"same-origin"}).then(y=>WebAssembly.instantiateStreaming(y,a).then(d,function(A){return R("wasm streaming compile failed: "+A),R("falling back to ArrayBuffer instantiation"),wt(f,a,d)}))}var at,vt={911532:a=>{n.Ea("Abs",a,void 0)},911583:a=>{n.Ea("Neg",a,void 0)},911634:a=>{n.Ea("Floor",a,void 0)},911687:a=>{n.Ea("Ceil",a,void 0)},911739:a=>{n.Ea("Reciprocal",a,void 0)},911797:a=>{n.Ea("Sqrt",a,void 0)},911849:a=>{n.Ea("Exp",a,void 0)},911900:a=>{n.Ea("Erf",a,void 0)},911951:a=>{n.Ea("Sigmoid",a,void 0)},912006:a=>{n.Ea("Log",a,void 0)},912057:a=>{n.Ea("Sin",a,void 0)},912108:a=>{n.Ea("Cos",a,void 0)},912159:a=>{n.Ea("Tan",a,void 0)},912210:a=>{n.Ea("Asin",a,void 0)},912262:a=>{n.Ea("Acos",a,void 0)},912314:a=>{n.Ea("Atan",a,void 0)},912366:a=>{n.Ea("Sinh",a,void 0)},912418:a=>{n.Ea("Cosh",a,void 0)},912470:a=>{n.Ea("Asinh",a,void 0)},912523:a=>{n.Ea("Acosh",a,void 0)},912576:a=>{n.Ea("Atanh",a,void 0)},912629:a=>{n.Ea("Tanh",a,void 0)},912681:a=>{n.Ea("Not",a,void 0)},912732:(a,d,f)=>{n.Ea("ClipV10",a,{min:d,max:f})},912804:a=>{n.Ea("Clip",a,void 0)},912856:(a,d)=>{n.Ea("Elu",a,{alpha:d})},912914:a=>{n.Ea("Relu",a,void 0)},912966:(a,d)=>{n.Ea("LeakyRelu",a,{alpha:d})},913030:(a,d)=>{n.Ea("ThresholdedRelu",a,{alpha:d})},913100:(a,d)=>{n.Ea("Cast",a,{to:d})},913158:a=>{n.Ea("Add",a,void 0)},913209:a=>{n.Ea("Sub",a,void 0)},913260:a=>{n.Ea("Mul",a,void 0)},913311:a=>{n.Ea("Div",a,void 0)},913362:a=>{n.Ea("Pow",a,void 0)},913413:a=>{n.Ea("Equal",a,void 0)},913466:a=>{n.Ea("Greater",a,void 0)},913521:a=>{n.Ea("GreaterOrEqual",a,void 0)},913583:a=>{n.Ea("Less",a,void 0)},913635:a=>{n.Ea("LessOrEqual",a,void 0)},913694:(a,d,f,y,A)=>{n.Ea("ReduceMean",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:y?Array.from(o().subarray(A>>>0,A+y>>>0)):[]})},913858:(a,d,f,y,A)=>{n.Ea("ReduceMax",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:y?Array.from(o().subarray(A>>>0,A+y>>>0)):[]})},914021:(a,d,f,y,A)=>{n.Ea("ReduceMin",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:y?Array.from(o().subarray(A>>>0,A+y>>>0)):[]})},914184:(a,d,f,y,A)=>{n.Ea("ReduceProd",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:y?Array.from(o().subarray(A>>>0,A+y>>>0)):[]})},914348:(a,d,f,y,A)=>{n.Ea("ReduceSum",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:y?Array.from(o().subarray(A>>>0,A+y>>>0)):[]})},914511:(a,d,f,y,A)=>{n.Ea("ReduceL1",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:y?Array.from(o().subarray(A>>>0,A+y>>>0)):[]})},914673:(a,d,f,y,A)=>{n.Ea("ReduceL2",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:y?Array.from(o().subarray(A>>>0,A+y>>>0)):[]})},914835:(a,d,f,y,A)=>{n.Ea("ReduceLogSum",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:y?Array.from(o().subarray(A>>>0,A+y>>>0)):[]})},915001:(a,d,f,y,A)=>{n.Ea("ReduceSumSquare",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:y?Array.from(o().subarray(A>>>0,A+y>>>0)):[]})},915170:(a,d,f,y,A)=>{n.Ea("ReduceLogSumExp",a,{keepDims:!!d,noopWithEmptyAxes:!!f,axes:y?Array.from(o().subarray(A>>>0,A+y>>>0)):[]})},915339:a=>{n.Ea("Where",a,void 0)},915392:(a,d,f)=>{n.Ea("Transpose",a,{perm:d?Array.from(o().subarray(f>>>0,f+d>>>0)):[]})},915505:(a,d,f,y,A,P,W,te,Z,J)=>{n.Ea("Conv",a,{format:Z?"NHWC":"NCHW",auto_pad:d,dilations:[f],group:y,kernel_shape:[A],pads:[P,W],strides:[te],w_is_const:()=>!!r()[J>>>0]})},915733:(a,d,f,y,A,P,W,te,Z,J,re,fe,be,O,ue)=>{n.Ea("Conv",a,{format:O?"NHWC":"NCHW",auto_pad:d,dilations:[f,y],group:A,kernel_shape:[P,W],pads:[te,Z,J,re],strides:[fe,be],w_is_const:()=>!!r()[ue>>>0]})},915992:(a,d,f,y,A,P,W,te,Z,J)=>{n.Ea("Conv",a,{format:Z?"NHWC":"NCHW",auto_pad:d,dilations:[f],group:y,kernel_shape:[A],pads:[P,W],strides:[te],w_is_const:()=>!!r()[J>>>0]})},916220:(a,d,f,y,A,P,W,te,Z,J,re,fe,be,O,ue)=>{n.Ea("Conv",a,{format:O?"NHWC":"NCHW",auto_pad:d,dilations:[f,y],group:A,kernel_shape:[P,W],pads:[te,Z,J,re],strides:[fe,be],w_is_const:()=>!!r()[ue>>>0]})},916479:(a,d,f,y,A,P,W,te,Z,J,re,fe,be,O)=>{n.Ea("ConvTranspose",a,{format:Z?"NHWC":"NCHW",autoPad:d,dilations:[f],group:y,kernel_shape:[A],pads:[P,W],strides:[te],wIsConst:()=>!!r()[J>>>0],outputPadding:re?Array.from(o().subarray(fe>>>0,fe+re>>>0)):[],outputShape:be?Array.from(o().subarray(O>>>0,O+be>>>0)):[]})},916859:(a,d,f,y,A,P,W,te,Z,J,re,fe,be)=>{n.Ea("ConvTranspose",a,{format:te?"NHWC":"NCHW",autoPad:d,dilations:Array.from(o().subarray(f>>>0,f+2>>>0)),group:y,kernelShape:Array.from(o().subarray(A>>>0,A+2>>>0)),pads:Array.from(o().subarray(P>>>0,P+4>>>0)),strides:Array.from(o().subarray(W>>>0,W+2>>>0)),wIsConst:()=>!!r()[Z>>>0],outputPadding:0<J?Array.from(o().subarray(re>>>0,re+J>>>0)):[],outputShape:0<fe?Array.from(o().subarray(be>>>0,be+fe>>>0)):[]})},917382:(a,d,f,y,A,P,W,te,Z,J,re,fe,be,O)=>{n.Ea("ConvTranspose",a,{format:Z?"NHWC":"NCHW",autoPad:d,dilations:[f],group:y,kernel_shape:[A],pads:[P,W],strides:[te],wIsConst:()=>!!r()[J>>>0],outputPadding:re?Array.from(o().subarray(fe>>>0,fe+re>>>0)):[],outputShape:be?Array.from(o().subarray(O>>>0,O+be>>>0)):[]})},917762:(a,d,f,y,A,P,W,te,Z,J,re,fe,be)=>{n.Ea("ConvTranspose",a,{format:te?"NHWC":"NCHW",autoPad:d,dilations:Array.from(o().subarray(f>>>0,f+2>>>0)),group:y,kernelShape:Array.from(o().subarray(A>>>0,A+2>>>0)),pads:Array.from(o().subarray(P>>>0,P+4>>>0)),strides:Array.from(o().subarray(W>>>0,W+2>>>0)),wIsConst:()=>!!r()[Z>>>0],outputPadding:0<J?Array.from(o().subarray(re>>>0,re+J>>>0)):[],outputShape:0<fe?Array.from(o().subarray(be>>>0,be+fe>>>0)):[]})},918285:(a,d)=>{n.Ea("GlobalAveragePool",a,{format:d?"NHWC":"NCHW"})},918376:(a,d,f,y,A,P,W,te,Z,J,re,fe,be,O,ue,ve)=>{n.Ea("AveragePool",a,{format:ve?"NHWC":"NCHW",auto_pad:d,ceil_mode:f,count_include_pad:y,storage_order:A,dilations:[P,W],kernel_shape:[te,Z],pads:[J,re,fe,be],strides:[O,ue]})},918660:(a,d)=>{n.Ea("GlobalAveragePool",a,{format:d?"NHWC":"NCHW"})},918751:(a,d,f,y,A,P,W,te,Z,J,re,fe,be,O,ue,ve)=>{n.Ea("AveragePool",a,{format:ve?"NHWC":"NCHW",auto_pad:d,ceil_mode:f,count_include_pad:y,storage_order:A,dilations:[P,W],kernel_shape:[te,Z],pads:[J,re,fe,be],strides:[O,ue]})},919035:(a,d)=>{n.Ea("GlobalMaxPool",a,{format:d?"NHWC":"NCHW"})},919122:(a,d,f,y,A,P,W,te,Z,J,re,fe,be,O,ue,ve)=>{n.Ea("MaxPool",a,{format:ve?"NHWC":"NCHW",auto_pad:d,ceil_mode:f,count_include_pad:y,storage_order:A,dilations:[P,W],kernel_shape:[te,Z],pads:[J,re,fe,be],strides:[O,ue]})},919402:(a,d)=>{n.Ea("GlobalMaxPool",a,{format:d?"NHWC":"NCHW"})},919489:(a,d,f,y,A,P,W,te,Z,J,re,fe,be,O,ue,ve)=>{n.Ea("MaxPool",a,{format:ve?"NHWC":"NCHW",auto_pad:d,ceil_mode:f,count_include_pad:y,storage_order:A,dilations:[P,W],kernel_shape:[te,Z],pads:[J,re,fe,be],strides:[O,ue]})},919769:(a,d,f,y,A)=>{n.Ea("Gemm",a,{alpha:d,beta:f,transA:y,transB:A})},919873:a=>{n.Ea("MatMul",a,void 0)},919927:(a,d,f,y)=>{n.Ea("ArgMax",a,{keepDims:!!d,selectLastIndex:!!f,axis:y})},920035:(a,d,f,y)=>{n.Ea("ArgMin",a,{keepDims:!!d,selectLastIndex:!!f,axis:y})},920143:(a,d)=>{n.Ea("Softmax",a,{axis:d})},920206:(a,d)=>{n.Ea("Concat",a,{axis:d})},920266:(a,d,f,y,A)=>{n.Ea("Split",a,{axis:d,numOutputs:f,splitSizes:y?Array.from(o().subarray(A>>>0,A+y>>>0)):[]})},920411:a=>{n.Ea("Expand",a,void 0)},920465:(a,d)=>{n.Ea("Gather",a,{axis:Number(d)})},920536:(a,d)=>{n.Ea("GatherElements",a,{axis:Number(d)})},920615:(a,d,f,y,A,P,W,te,Z,J,re)=>{n.Ea("Resize",a,{antialias:d,axes:f?Array.from(o().subarray(y>>>0,y+f>>>0)):[],coordinateTransformMode:Xe(A),cubicCoeffA:P,excludeOutside:W,extrapolationValue:te,keepAspectRatioPolicy:Xe(Z),mode:Xe(J),nearestMode:Xe(re)})},920966:(a,d,f,y,A,P,W)=>{n.Ea("Slice",a,{starts:d?Array.from(o().subarray(f>>>0,f+d>>>0)):[],ends:y?Array.from(o().subarray(A>>>0,A+y>>>0)):[],axes:P?Array.from(o().subarray(W>>>0,W+P>>>0)):[]})},921197:a=>{n.Ea("Tile",a,void 0)},921249:(a,d,f)=>{n.Ea("LayerNormalization",a,{axis:Number(d),epsilon:Number(f)})},921356:(a,d,f)=>{n.Ea("InstanceNormalization",a,{epsilon:d,format:f?"NHWC":"NCHW"})},921470:(a,d,f)=>{n.Ea("InstanceNormalization",a,{epsilon:d,format:f?"NHWC":"NCHW"})},921584:a=>{n.Ea("Range",a,void 0)},921637:(a,d)=>{n.Ea("Einsum",a,{equation:Xe(d)})},921718:(a,d,f,y,A)=>{n.Ea("Pad",a,{mode:d,value:f,pads:y?Array.from(o().subarray(A>>>0,A+y>>>0)):[]})},921850:a=>{n.Ea("Gelu",a,void 0)},921902:a=>{n.Ea("BiasAdd",a,void 0)},921957:a=>{n.Ea("BiasSplitGelu",a,void 0)},922018:(a,d)=>{n.Ea("SkipLayerNormalization",a,{epsilon:d})},922099:a=>{n.zb(a)},922133:(a,d)=>n.Ab(a,d,n.bb.Fb,n.bb.errors),922245:a=>n.wb(a),922278:a=>n.yb(a),922310:(a,d,f)=>{n.jb(a,d,f,!0)},922349:(a,d,f)=>{n.jb(a,d,f)}};function dt(a){this.name="ExitStatus",this.message=`Program terminated with exit(${a})`,this.status=a}function ct(a){a.terminate(),a.onmessage=()=>{}}function Rt(a){(a=oe.Qa[a])||Ye(),oe.Eb(a)}function $t(a){var d=oe.tb();if(!d)return 6;oe.Ya.push(d),oe.Qa[a.Xa]=d,d.Xa=a.Xa;var f={cmd:"run",start_routine:a.Gb,arg:a.rb,pthread_ptr:a.Xa};return w&&d.unref(),d.postMessage(f,a.Mb),0}var Bt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,xt=(a,d,f)=>{d>>>=0;var y=d+f;for(f=d;a[f]&&!(f>=y);)++f;if(16<f-d&&a.buffer&&Bt)return Bt.decode(a.buffer instanceof SharedArrayBuffer?a.slice(d,f):a.subarray(d,f));for(y="";d<f;){var A=a[d++];if(A&128){var P=a[d++]&63;if((A&224)==192)y+=String.fromCharCode((A&31)<<6|P);else{var W=a[d++]&63;A=(A&240)==224?(A&15)<<12|P<<6|W:(A&7)<<18|P<<12|W<<6|a[d++]&63,65536>A?y+=String.fromCharCode(A):(A-=65536,y+=String.fromCharCode(55296|A>>10,56320|A&1023))}}else y+=String.fromCharCode(A)}return y},Xe=(a,d)=>(a>>>=0)?xt(i(),a,d):"";function Mt(a){if(v)return k(1,1,a);Re=a,Ae()||(oe.Hb(),n.onExit&&n.onExit(a),he=!0),x(a,new dt(a))}var Ct=a=>{if(Re=a,v)throw ft(a),"unwind";Mt(a)},oe={ab:[],Ya:[],mb:[],Qa:{},gb:function(){v?oe.vb():oe.ub()},ub:function(){ge.unshift(()=>{or(),oe.Bb(()=>Ot())})},vb:function(){oe.receiveObjectTransfer=oe.Db,oe.threadInitTLS=oe.lb,oe.setExitStatus=oe.kb,Se=!1},kb:function(a){Re=a},Sb:["$terminateWorker"],Hb:function(){for(var a of oe.Ya)ct(a);for(a of oe.ab)ct(a);oe.ab=[],oe.Ya=[],oe.Qa=[]},Eb:function(a){var d=a.Xa;delete oe.Qa[d],oe.ab.push(a),oe.Ya.splice(oe.Ya.indexOf(a),1),a.Xa=0,Hr(d)},Db:function(){},lb:function(){oe.mb.forEach(a=>a())},Cb:a=>new Promise(d=>{a.onmessage=P=>{P=P.data;var W=P.cmd;if(P.targetThread&&P.targetThread!=mr()){var te=oe.Qa[P.Rb];te?te.postMessage(P,P.transferList):R(\'Internal error! Worker sent a message "\'+W+\'" to target pthread \'+P.targetThread+", but that thread no longer exists!")}else W==="checkMailbox"?ht():W==="spawnThread"?$t(P):W==="cleanupThread"?Rt(P.thread):W==="killThread"?(P=P.thread,W=oe.Qa[P],delete oe.Qa[P],ct(W),Hr(P),oe.Ya.splice(oe.Ya.indexOf(W),1),W.Xa=0):W==="cancelThread"?oe.Qa[P.thread].postMessage({cmd:"cancel"}):W==="loaded"?(a.loaded=!0,d(a)):W==="alert"?alert("Thread "+P.threadId+": "+P.text):P.target==="setimmediate"?a.postMessage(P):W==="callHandler"?n[P.handler](...P.args):W&&R("worker sent an unknown command "+W)},a.onerror=P=>{throw R("worker sent an error! "+P.filename+":"+P.lineno+": "+P.message),P},w&&(a.on("message",function(P){a.onmessage({data:P})}),a.on("error",function(P){a.onerror(P)}));var f=[],y=["onExit","onAbort","print","printErr"],A;for(A of y)n.hasOwnProperty(A)&&f.push(A);a.postMessage({cmd:"load",handlers:f,urlOrBlob:n.mainScriptUrlOrBlob||e,wasmMemory:q,wasmModule:De})}),Bb:function(a){a()},qb:function(){var a=B("ort-wasm-simd-threaded.worker.js");a=new Worker(a),oe.ab.push(a)},tb:function(){return oe.ab.length==0&&(oe.qb(),oe.Cb(oe.ab[0])),oe.ab.pop()}};n.PThread=oe;var pt=a=>{for(;0<a.length;)a.shift()(n)};n.establishStackSpace=function(){var a=mr(),d=o()[a+52>>2>>>0];a=o()[a+56>>2>>>0],Nn(d,d-a),hr(d)};function ft(a){if(v)return k(2,0,a);Ct(a)}n.invokeEntryPoint=function(a,d){a=Vn.apply(null,[a,d]),Ae()?oe.kb(a):Lr(a)};function Nr(a){this.fb=a-24,this.pb=function(d){s()[this.fb+4>>2>>>0]=d},this.ob=function(d){s()[this.fb+8>>2>>>0]=d},this.gb=function(d,f){this.nb(),this.pb(d),this.ob(f)},this.nb=function(){s()[this.fb+16>>2>>>0]=0}}var He=0,Ne=0;function kt(a,d,f,y){return v?k(3,1,a,d,f,y):mt(a,d,f,y)}function mt(a,d,f,y){if(a>>>=0,d>>>=0,f>>>=0,y>>>=0,typeof SharedArrayBuffer>"u")return R("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var A=[];return v&&A.length===0?kt(a,d,f,y):(a={Gb:f,Xa:a,rb:y,Mb:A},v?(a.Ob="spawnThread",postMessage(a,A),0):$t(a))}function Dt(a,d,f){return v?k(4,1,a,d,f):0}function Wt(a,d){if(v)return k(5,1,a,d)}var zt=a=>{for(var d=0,f=0;f<a.length;++f){var y=a.charCodeAt(f);127>=y?d++:2047>=y?d+=2:55296<=y&&57343>=y?(d+=4,++f):d+=3}return d},St=(a,d,f,y)=>{if(f>>>=0,!(0<y))return 0;var A=f;y=f+y-1;for(var P=0;P<a.length;++P){var W=a.charCodeAt(P);if(55296<=W&&57343>=W){var te=a.charCodeAt(++P);W=65536+((W&1023)<<10)|te&1023}if(127>=W){if(f>=y)break;d[f++>>>0]=W}else{if(2047>=W){if(f+1>=y)break;d[f++>>>0]=192|W>>6}else{if(65535>=W){if(f+2>=y)break;d[f++>>>0]=224|W>>12}else{if(f+3>=y)break;d[f++>>>0]=240|W>>18,d[f++>>>0]=128|W>>12&63}d[f++>>>0]=128|W>>6&63}d[f++>>>0]=128|W&63}}return d[f>>>0]=0,f-A},ar=(a,d,f)=>St(a,i(),d,f);function ir(a,d){if(v)return k(6,1,a,d)}function sr(a,d,f){if(v)return k(7,1,a,d,f)}function ur(a,d,f){return v?k(8,1,a,d,f):0}function lr(a,d){if(v)return k(9,1,a,d)}function dr(a,d,f){if(v)return k(10,1,a,d,f)}function At(a,d,f,y){if(v)return k(11,1,a,d,f,y)}function Gt(a,d,f,y){if(v)return k(12,1,a,d,f,y)}function Ut(a,d,f,y){if(v)return k(13,1,a,d,f,y)}function Nt(a){if(v)return k(14,1,a)}function Vt(a,d){if(v)return k(15,1,a,d)}function Ft(a,d,f){if(v)return k(16,1,a,d,f)}var Ht=a=>{if(!he)try{if(a(),!Ae())try{v?Lr(Re):Ct(Re)}catch(d){d instanceof dt||d=="unwind"||x(1,d)}}catch(d){d instanceof dt||d=="unwind"||x(1,d)}};function It(a){a>>>=0,typeof Atomics.Nb=="function"&&(Atomics.Nb(o(),a>>2,a).value.then(ht),a+=128,Atomics.store(o(),a>>2,1))}n.__emscripten_thread_mailbox_await=It;function ht(){var a=mr();a&&(It(a),Ht(()=>Gn()))}n.checkMailbox=ht;var it=a=>a%4===0&&(a%100!==0||a%400===0),cr=[0,31,60,91,121,152,182,213,244,274,305,335],gt=[0,31,59,90,120,151,181,212,243,273,304,334];function Lt(a,d,f,y,A,P,W,te){return v?k(17,1,a,d,f,y,A,P,W,te):-52}function u(a,d,f,y,A,P,W){if(v)return k(18,1,a,d,f,y,A,P,W)}var p=a=>{var d=zt(a)+1,f=Fr(d);return f&&ar(a,f,d),f},h=[],S=(a,d)=>{h.length=0;var f;for(d>>=2;f=i()[a++>>>0];)d+=f!=105&d,h.push(f==105?o()[d>>>0]:l()[d++>>>1]),++d;return h},T=a=>{var d=jr();return a=a(),hr(d),a};function k(a,d){var f=arguments.length-2,y=arguments;return T(()=>{for(var A=Kr(8*f),P=A>>3,W=0;W<f;W++){var te=y[2+W];l()[P+W>>>0]=te}return zn(a,f,A,d)})}var F=[],ne={},Y=()=>{if(!Q){var a={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:C||"./this.program"},d;for(d in ne)ne[d]===void 0?delete a[d]:a[d]=ne[d];var f=[];for(d in a)f.push(`${d}=${a[d]}`);Q=f}return Q},Q;function ee(a,d){if(v)return k(19,1,a,d);a>>>=0,d>>>=0;var f=0;return Y().forEach(function(y,A){var P=d+f;for(A=s()[a+4*A>>2>>>0]=P,P=0;P<y.length;++P)r()[A++>>0>>>0]=y.charCodeAt(P);r()[A>>0>>>0]=0,f+=y.length+1}),0}function ce(a,d){if(v)return k(20,1,a,d);a>>>=0,d>>>=0;var f=Y();s()[a>>2>>>0]=f.length;var y=0;return f.forEach(function(A){y+=A.length+1}),s()[d>>2>>>0]=y,0}function pe(a){return v?k(21,1,a):52}function E(a,d,f,y){return v?k(22,1,a,d,f,y):52}function ie(a,d,f,y,A){return v?k(23,1,a,d,f,y,A):70}var ye=[null,[],[]];function Qe(a,d,f,y){if(v)return k(24,1,a,d,f,y);d>>>=0,f>>>=0,y>>>=0;for(var A=0,P=0;P<f;P++){var W=s()[d>>2>>>0],te=s()[d+4>>2>>>0];d+=8;for(var Z=0;Z<te;Z++){var J=i()[W+Z>>>0],re=ye[a];J===0||J===10?((a===1?le:R)(xt(re,0)),re.length=0):re.push(J)}A+=te}return s()[y>>2>>>0]=A,0}var jt=[31,29,31,30,31,30,31,31,30,31,30,31],Pn=[31,28,31,30,31,30,31,31,30,31,30,31];function Vs(a){var d=Array(zt(a)+1);return St(a,d,0,d.length),d}var Fs=(a,d)=>{r().set(a,d>>>0)};function Rn(a,d,f,y){function A(O,ue,ve){for(O=typeof O=="number"?O.toString():O||"";O.length<ue;)O=ve[0]+O;return O}function P(O,ue){return A(O,ue,"0")}function W(O,ue){function ve(qn){return 0>qn?-1:0<qn?1:0}var yt;return(yt=ve(O.getFullYear()-ue.getFullYear()))===0&&(yt=ve(O.getMonth()-ue.getMonth()))===0&&(yt=ve(O.getDate()-ue.getDate())),yt}function te(O){switch(O.getDay()){case 0:return new Date(O.getFullYear()-1,11,29);case 1:return O;case 2:return new Date(O.getFullYear(),0,3);case 3:return new Date(O.getFullYear(),0,2);case 4:return new Date(O.getFullYear(),0,1);case 5:return new Date(O.getFullYear()-1,11,31);case 6:return new Date(O.getFullYear()-1,11,30)}}function Z(O){var ue=O.Za;for(O=new Date(new Date(O.$a+1900,0,1).getTime());0<ue;){var ve=O.getMonth(),yt=(it(O.getFullYear())?jt:Pn)[ve];if(ue>yt-O.getDate())ue-=yt-O.getDate()+1,O.setDate(1),11>ve?O.setMonth(ve+1):(O.setMonth(0),O.setFullYear(O.getFullYear()+1));else{O.setDate(O.getDate()+ue);break}}return ve=new Date(O.getFullYear()+1,0,4),ue=te(new Date(O.getFullYear(),0,4)),ve=te(ve),0>=W(ue,O)?0>=W(ve,O)?O.getFullYear()+1:O.getFullYear():O.getFullYear()-1}a>>>=0,d>>>=0,f>>>=0,y>>>=0;var J=o()[y+40>>2>>>0];y={Kb:o()[y>>2>>>0],Jb:o()[y+4>>2>>>0],cb:o()[y+8>>2>>>0],ib:o()[y+12>>2>>>0],eb:o()[y+16>>2>>>0],$a:o()[y+20>>2>>>0],Wa:o()[y+24>>2>>>0],Za:o()[y+28>>2>>>0],Tb:o()[y+32>>2>>>0],Ib:o()[y+36>>2>>>0],Lb:J?Xe(J):""},f=Xe(f),J={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var re in J)f=f.replace(new RegExp(re,"g"),J[re]);var fe="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),be="January February March April May June July August September October November December".split(" ");J={"%a":O=>fe[O.Wa].substring(0,3),"%A":O=>fe[O.Wa],"%b":O=>be[O.eb].substring(0,3),"%B":O=>be[O.eb],"%C":O=>P((O.$a+1900)/100|0,2),"%d":O=>P(O.ib,2),"%e":O=>A(O.ib,2," "),"%g":O=>Z(O).toString().substring(2),"%G":O=>Z(O),"%H":O=>P(O.cb,2),"%I":O=>(O=O.cb,O==0?O=12:12<O&&(O-=12),P(O,2)),"%j":O=>{for(var ue=0,ve=0;ve<=O.eb-1;ue+=(it(O.$a+1900)?jt:Pn)[ve++]);return P(O.ib+ue,3)},"%m":O=>P(O.eb+1,2),"%M":O=>P(O.Jb,2),"%n":()=>`\n`,"%p":O=>0<=O.cb&&12>O.cb?"AM":"PM","%S":O=>P(O.Kb,2),"%t":()=>"	","%u":O=>O.Wa||7,"%U":O=>P(Math.floor((O.Za+7-O.Wa)/7),2),"%V":O=>{var ue=Math.floor((O.Za+7-(O.Wa+6)%7)/7);if(2>=(O.Wa+371-O.Za-2)%7&&ue++,ue)ue==53&&(ve=(O.Wa+371-O.Za)%7,ve==4||ve==3&&it(O.$a)||(ue=1));else{ue=52;var ve=(O.Wa+7-O.Za-1)%7;(ve==4||ve==5&&it(O.$a%400-1))&&ue++}return P(ue,2)},"%w":O=>O.Wa,"%W":O=>P(Math.floor((O.Za+7-(O.Wa+6)%7)/7),2),"%y":O=>(O.$a+1900).toString().substring(2),"%Y":O=>O.$a+1900,"%z":O=>{O=O.Ib;var ue=0<=O;return O=Math.abs(O)/60,(ue?"+":"-")+("0000"+(O/60*100+O%60)).slice(-4)},"%Z":O=>O.Lb,"%%":()=>"%"},f=f.replace(/%%/g,"\\0\\0");for(re in J)f.includes(re)&&(f=f.replace(new RegExp(re,"g"),J[re](y)));return f=f.replace(/\\0\\0/g,"%"),re=Vs(f),re.length>d?0:(Fs(re,a),re.length-1)}function pr(a){try{a()}catch(d){Ye(d)}}function Hs(a){var d={},f;for(f in a)(function(y){var A=a[y];d[y]=typeof A=="function"?function(){fr.push(y);try{return A.apply(null,arguments)}finally{he||(fr.pop()===y||Ye(),Je&&ut===1&&fr.length===0&&(ut=0,Te+=1,pr(Hn),typeof Fibers<"u"&&Fibers.Ub()))}}:A})(f);return d}var ut=0,Je=null,Bn=0,fr=[],Mn={},kn={},Ls=0,Vr=null,js=[];function Ks(){return new Promise((a,d)=>{Vr={resolve:a,reject:d}})}function qs(){var a=Fr(65548),d=a+12;s()[a>>2>>>0]=d,s()[a+4>>2>>>0]=d+65536,d=fr[0];var f=Mn[d];return f===void 0&&(f=Ls++,Mn[d]=f,kn[f]=d),d=f,o()[a+8>>2>>>0]=d,a}function Ys(){var a=o()[Je+8>>2>>>0];return a=L[kn[a]],--Te,a()}function Xs(a){if(!he){if(ut===0){var d=!1,f=!1;a((y=0)=>{if(!he&&(Bn=y,d=!0,f)){ut=2,pr(()=>Ln(Je)),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.resume(),y=!1;try{var A=Ys()}catch(te){A=te,y=!0}var P=!1;if(!Je){var W=Vr;W&&(Vr=null,(y?W.reject:W.resolve)(A),P=!0)}if(y&&!P)throw A}}),f=!0,d||(ut=1,Je=qs(),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.pause(),pr(()=>Fn(Je)))}else ut===2?(ut=0,pr(jn),Dn(Je),Je=null,js.forEach(y=>Ht(y))):Ye(`invalid state: ${ut}`);return Bn}}function Qs(a){return Xs(d=>{a().then(d)})}oe.gb();var Js=[null,Mt,ft,kt,Dt,Wt,ir,sr,ur,lr,dr,At,Gt,Ut,Nt,Vt,Ft,Lt,u,ee,ce,pe,E,ie,Qe],Zs={r:function(a,d,f){return Qs(async()=>{await n.xb(a,d,f)})},b:function(a,d,f){throw a>>>=0,new Nr(a).gb(d>>>0,f>>>0),He=a,Ne++,He},O:function(a){Wn(a>>>0,!b,1,!$,131072,!1),oe.lb()},l:function(a){a>>>=0,v?postMessage({cmd:"cleanupThread",thread:a}):Rt(a)},I:mt,i:Dt,U:Wt,E:ir,G:sr,V:ur,S:lr,K:dr,R:At,p:Gt,F:Ut,C:Nt,T:Vt,D:Ft,q:()=>!0,A:function(a,d){a>>>=0,a==d>>>0?setTimeout(()=>ht()):v?postMessage({targetThread:a,cmd:"checkMailbox"}):(a=oe.Qa[a])&&a.postMessage({cmd:"checkMailbox"})},M:function(){return-1},N:It,X:function(a){w&&oe.Qa[a>>>0].ref()},u:function(a,d,f){a=d+2097152>>>0<4194305-!!a?(a>>>0)+4294967296*d:NaN,f>>>=0,a=new Date(1e3*a),o()[f>>2>>>0]=a.getUTCSeconds(),o()[f+4>>2>>>0]=a.getUTCMinutes(),o()[f+8>>2>>>0]=a.getUTCHours(),o()[f+12>>2>>>0]=a.getUTCDate(),o()[f+16>>2>>>0]=a.getUTCMonth(),o()[f+20>>2>>>0]=a.getUTCFullYear()-1900,o()[f+24>>2>>>0]=a.getUTCDay(),a=(a.getTime()-Date.UTC(a.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,o()[f+28>>2>>>0]=a},v:function(a,d,f){a=d+2097152>>>0<4194305-!!a?(a>>>0)+4294967296*d:NaN,f>>>=0,a=new Date(1e3*a),o()[f>>2>>>0]=a.getSeconds(),o()[f+4>>2>>>0]=a.getMinutes(),o()[f+8>>2>>>0]=a.getHours(),o()[f+12>>2>>>0]=a.getDate(),o()[f+16>>2>>>0]=a.getMonth(),o()[f+20>>2>>>0]=a.getFullYear()-1900,o()[f+24>>2>>>0]=a.getDay(),d=(it(a.getFullYear())?cr:gt)[a.getMonth()]+a.getDate()-1|0,o()[f+28>>2>>>0]=d,o()[f+36>>2>>>0]=-(60*a.getTimezoneOffset()),d=new Date(a.getFullYear(),6,1).getTimezoneOffset();var y=new Date(a.getFullYear(),0,1).getTimezoneOffset();a=(d!=y&&a.getTimezoneOffset()==Math.min(y,d))|0,o()[f+32>>2>>>0]=a},w:function(a){a>>>=0;var d=new Date(o()[a+20>>2>>>0]+1900,o()[a+16>>2>>>0],o()[a+12>>2>>>0],o()[a+8>>2>>>0],o()[a+4>>2>>>0],o()[a>>2>>>0],0),f=o()[a+32>>2>>>0],y=d.getTimezoneOffset(),A=new Date(d.getFullYear(),6,1).getTimezoneOffset(),P=new Date(d.getFullYear(),0,1).getTimezoneOffset(),W=Math.min(P,A);return 0>f?o()[a+32>>2>>>0]=+(A!=P&&W==y):0<f!=(W==y)&&(A=Math.max(P,A),d.setTime(d.getTime()+6e4*((0<f?W:A)-y))),o()[a+24>>2>>>0]=d.getDay(),f=(it(d.getFullYear())?cr:gt)[d.getMonth()]+d.getDate()-1|0,o()[a+28>>2>>>0]=f,o()[a>>2>>>0]=d.getSeconds(),o()[a+4>>2>>>0]=d.getMinutes(),o()[a+8>>2>>>0]=d.getHours(),o()[a+12>>2>>>0]=d.getDate(),o()[a+16>>2>>>0]=d.getMonth(),o()[a+20>>2>>>0]=d.getYear(),a=d.getTime()/1e3,Un((at=a,1<=+Math.abs(at)?0<at?+Math.floor(at/4294967296)>>>0:~~+Math.ceil((at-+(~~at>>>0))/4294967296)>>>0:0)),a>>>0},s:Lt,t:u,z:function(a,d,f){function y(J){return(J=J.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?J[1]:"GMT"}a>>>=0,d>>>=0,f>>>=0;var A=new Date().getFullYear(),P=new Date(A,0,1),W=new Date(A,6,1);A=P.getTimezoneOffset();var te=W.getTimezoneOffset(),Z=Math.max(A,te);s()[a>>2>>>0]=60*Z,o()[d>>2>>>0]=+(A!=te),a=y(P),d=y(W),a=p(a),d=p(d),te<A?(s()[f>>2>>>0]=a,s()[f+4>>2>>>0]=d):(s()[f>>2>>>0]=d,s()[f+4>>2>>>0]=a)},d:()=>{Ye("")},c:function(a,d,f){return a>>>=0,d=S(d>>>0,f>>>0),vt[a].apply(null,d)},k:function(a,d,f){return a>>>=0,d=S(d>>>0,f>>>0),vt[a].apply(null,d)},m:function(){},j:function(){return Date.now()},W:()=>{throw Te+=1,"unwind"},B:function(){return 4294901760},f:()=>performance.timeOrigin+performance.now(),g:function(){return w?(to(),Tt(eo)).cpus().length:navigator.hardwareConcurrency},L:function(a,d,f,y){for(oe.Pb=d>>>0,F.length=f,d=y>>>0>>3,y=0;y<f;y++)F[y]=l()[d+y>>>0];return(0>a?vt[-a-1]:Js[a]).apply(null,F)},y:function(a){a>>>=0;var d=i().length;if(a<=d||4294901760<a)return!1;for(var f=1;4>=f;f*=2){var y=d*(1+.2/f);y=Math.min(y,a+100663296);var A=Math;y=Math.max(a,y);e:{A=A.min.call(A,4294901760,y+(65536-y%65536)%65536)-q.buffer.byteLength+65535>>>16;try{q.grow(A),N();var P=1;break e}catch{}P=void 0}if(P)return!0}return!1},P:ee,Q:ce,H:Ct,h:pe,o:E,x:ie,n:Qe,a:q||n.wasmMemory,J:Rn,e:function(a,d,f,y){return Rn(a>>>0,d>>>0,f>>>0,y>>>0)}};(function(){function a(f,y){return f=f.exports,f=Hs(f),L=f=eu(f),oe.mb.push(L.Da),ze.unshift(L.Y),De=y,Ot(),f}var d={a:Zs};if(or(),n.instantiateWasm)try{return n.instantiateWasm(d,a)}catch(f){R("Module.instantiateWasm callback failed with error: "+f),m(f)}return st(d,function(f){a(f.instance,f.module)}).catch(m),{}})(),n._OrtInit=(a,d)=>(n._OrtInit=L.Z)(a,d),n._OrtGetLastError=(a,d)=>(n._OrtGetLastError=L._)(a,d),n._OrtCreateSessionOptions=(a,d,f,y,A,P,W,te,Z,J)=>(n._OrtCreateSessionOptions=L.$)(a,d,f,y,A,P,W,te,Z,J),n._OrtAppendExecutionProvider=(a,d)=>(n._OrtAppendExecutionProvider=L.aa)(a,d),n._OrtAddFreeDimensionOverride=(a,d,f)=>(n._OrtAddFreeDimensionOverride=L.ba)(a,d,f),n._OrtAddSessionConfigEntry=(a,d,f)=>(n._OrtAddSessionConfigEntry=L.ca)(a,d,f),n._OrtReleaseSessionOptions=a=>(n._OrtReleaseSessionOptions=L.da)(a),n._OrtCreateSession=(a,d,f)=>(n._OrtCreateSession=L.ea)(a,d,f),n._OrtReleaseSession=a=>(n._OrtReleaseSession=L.fa)(a),n._OrtGetInputOutputCount=(a,d,f)=>(n._OrtGetInputOutputCount=L.ga)(a,d,f),n._OrtGetInputName=(a,d)=>(n._OrtGetInputName=L.ha)(a,d),n._OrtGetOutputName=(a,d)=>(n._OrtGetOutputName=L.ia)(a,d),n._OrtFree=a=>(n._OrtFree=L.ja)(a),n._OrtCreateTensor=(a,d,f,y,A,P)=>(n._OrtCreateTensor=L.ka)(a,d,f,y,A,P),n._OrtGetTensorData=(a,d,f,y,A)=>(n._OrtGetTensorData=L.la)(a,d,f,y,A),n._OrtReleaseTensor=a=>(n._OrtReleaseTensor=L.ma)(a),n._OrtCreateRunOptions=(a,d,f,y)=>(n._OrtCreateRunOptions=L.na)(a,d,f,y),n._OrtAddRunConfigEntry=(a,d,f)=>(n._OrtAddRunConfigEntry=L.oa)(a,d,f),n._OrtReleaseRunOptions=a=>(n._OrtReleaseRunOptions=L.pa)(a),n._OrtCreateBinding=a=>(n._OrtCreateBinding=L.qa)(a),n._OrtBindInput=(a,d,f)=>(n._OrtBindInput=L.ra)(a,d,f),n._OrtBindOutput=(a,d,f,y)=>(n._OrtBindOutput=L.sa)(a,d,f,y),n._OrtClearBoundOutputs=a=>(n._OrtClearBoundOutputs=L.ta)(a),n._OrtReleaseBinding=a=>(n._OrtReleaseBinding=L.ua)(a),n._OrtRunWithBinding=(a,d,f,y,A)=>(n._OrtRunWithBinding=L.va)(a,d,f,y,A),n._OrtRun=(a,d,f,y,A,P,W,te)=>(n._OrtRun=L.wa)(a,d,f,y,A,P,W,te),n._OrtEndProfiling=a=>(n._OrtEndProfiling=L.xa)(a),n._JsepOutput=(a,d,f)=>(n._JsepOutput=L.ya)(a,d,f),n._JsepGetNodeName=a=>(n._JsepGetNodeName=L.za)(a);var mr=n._pthread_self=()=>(mr=n._pthread_self=L.Aa)(),Fr=n._malloc=a=>(Fr=n._malloc=L.Ba)(a),Dn=n._free=a=>(Dn=n._free=L.Ca)(a);n.__emscripten_tls_init=()=>(n.__emscripten_tls_init=L.Da)();var Wn=n.__emscripten_thread_init=(a,d,f,y,A,P)=>(Wn=n.__emscripten_thread_init=L.Fa)(a,d,f,y,A,P);n.__emscripten_thread_crashed=()=>(n.__emscripten_thread_crashed=L.Ga)();var zn=(a,d,f,y)=>(zn=L.Ha)(a,d,f,y),Hr=a=>(Hr=L.Ia)(a),Lr=n.__emscripten_thread_exit=a=>(Lr=n.__emscripten_thread_exit=L.Ja)(a),Gn=n.__emscripten_check_mailbox=()=>(Gn=n.__emscripten_check_mailbox=L.Ka)(),Un=a=>(Un=L.La)(a),Nn=(a,d)=>(Nn=L.Ma)(a,d),jr=()=>(jr=L.Na)(),hr=a=>(hr=L.Oa)(a),Kr=a=>(Kr=L.Pa)(a),Vn=n.dynCall_ii=(a,d)=>(Vn=n.dynCall_ii=L.Ra)(a,d),Fn=a=>(Fn=L.Sa)(a),Hn=()=>(Hn=L.Ta)(),Ln=a=>(Ln=L.Ua)(a),jn=()=>(jn=L.Va)();n.___start_em_js=922382,n.___stop_em_js=922543;function eu(a){a=Object.assign({},a);var d=y=>()=>y()>>>0,f=y=>A=>y(A)>>>0;return a.__errno_location=d(a.__errno_location),a.pthread_self=d(a.pthread_self),a.malloc=f(a.malloc),a.stackSave=d(a.stackSave),a.stackAlloc=f(a.stackAlloc),a}n.keepRuntimeAlive=Ae,n.wasmMemory=q,n.stackAlloc=Kr,n.stackSave=jr,n.stackRestore=hr,n.UTF8ToString=Xe,n.stringToUTF8=ar,n.lengthBytesUTF8=zt,n.ExitStatus=dt,n.PThread=oe;var gr;Ve=function a(){gr||Kn(),gr||(Ve=a)};function Kn(){function a(){if(!gr&&(gr=!0,n.calledRun=!0,!he)&&(v||pt(ze),c(n),n.onRuntimeInitialized&&n.onRuntimeInitialized(),!v)){if(n.postRun)for(typeof n.postRun=="function"&&(n.postRun=[n.postRun]);n.postRun.length;){var d=n.postRun.shift();Ge.unshift(d)}pt(Ge)}}if(!(0<Ue))if(v)c(n),v||pt(ze),startWorker(n);else{if(n.preRun)for(typeof n.preRun=="function"&&(n.preRun=[n.preRun]);n.preRun.length;)ge.unshift(n.preRun.shift());pt(ge),0<Ue||(n.setStatus?(n.setStatus("Running..."),setTimeout(function(){setTimeout(function(){n.setStatus("")},1),a()},1)):a())}}if(n.preInit)for(typeof n.preInit=="function"&&(n.preInit=[n.preInit]);0<n.preInit.length;)n.preInit.pop()();return Kn(),t.ready}})();typeof no=="object"&&typeof en=="object"?en.exports=ro:typeof define=="function"&&define.amd&&define([],()=>ro)});var ao=Kt((Cd,uu)=>{uu.exports=\'"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason||e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(Module.__embind_initialize_bindings(),initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err(`worker.js received unknown command ${e.data.cmd}`),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\\n\'});var nn,Yt,Xt,wr,Qt,po,on,ke=H(()=>{"use strict";nn=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},Yt=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},Xt=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],wr=e=>{switch(e){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Qt=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},po=e=>e==="float32"||e==="int32"||e==="int64"||e==="bool"||e==="float16"||e==="uint32",on=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var yu,bu,fo,mo,ho,wu,Ie,lt=H(()=>{"use strict";ke();yu=["V","I","W","E","F"],bu=(e,t)=>{console.log(`[${yu[e]},${new Date().toISOString()}]${t}`)},ho=(e,t)=>{fo=e,mo=t},wu=(e,t)=>{let r=Qt(e),i=Qt(fo);r>=i&&bu(r,typeof t=="function"?t():t)},Ie=(...e)=>{mo&&wu(...e)}});var go,yo=H(()=>{"use strict";ke();go=(e,t)=>new(wr(t))(e)});var bo=H(()=>{"use strict"});var vr,vu,wo,sn,an,vo,$o=H(()=>{"use strict";lt();bo();vr=e=>Math.ceil(e/16)*16,vu=1,wo=()=>vu++,sn=async(e,t,r,i)=>{let o=vr(r),s=e.device.createBuffer({size:o,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let l=e.getCommandEncoder();e.endComputePass(),l.copyBufferToBuffer(t,0,s,0,o),e.flush(),await s.mapAsync(GPUMapMode.READ);let n=s.getMappedRange();if(i){let c=i();return c.set(new Uint8Array(n,0,r)),c}else return new Uint8Array(n.slice(0,r))}finally{s.destroy()}},an=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(t,r){let i=r.buffer,o=r.byteOffset,s=r.byteLength,l=vr(s),n=this.storageCache.get(t);if(!n)throw new Error("gpu data for uploading does not exist");if(n.originalSize!==s)throw new Error(`inconsistent data size. gpu data size=${n.originalSize}, data size=${s}`);let c=this.backend.device.createBuffer({mappedAtCreation:!0,size:l,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),m=c.getMappedRange();new Uint8Array(m).set(new Uint8Array(i,o,s)),c.unmap();let g=this.backend.getCommandEncoder();this.backend.endComputePass(),g.copyBufferToBuffer(c,0,n.gpuData.buffer,0,l),Ie("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`),this.buffersForUploadingPending.push(c)}memcpy(t,r){let i=this.storageCache.get(t);if(!i)throw new Error("source gpu data for memcpy does not exist");let o=this.storageCache.get(r);if(!o)throw new Error("destination gpu data for memcpy does not exist");if(i.originalSize!==o.originalSize)throw new Error("inconsistent source and destination gpu data size");let s=vr(i.originalSize),l=this.backend.getCommandEncoder();this.backend.endComputePass(),l.copyBufferToBuffer(i.gpuData.buffer,0,o.gpuData.buffer,0,s)}registerExternalBuffer(t,r,i){let o;if(i){if(o=this.externalBuffers.get(i),o===void 0)throw new Error("previous buffer is not registered");if(t===i)return Ie("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${o}, buffer is the same, skip.`),o;this.externalBuffers.delete(i)}else o=wo();return this.storageCache.set(o,{gpuData:{id:o,type:0,buffer:t},originalSize:r}),this.externalBuffers.set(t,o),Ie("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${o}, registered.`),o}unregisterExternalBuffer(t){let r=this.externalBuffers.get(t);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(t),Ie("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let i=vr(t),o,s=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,l=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(s||l){let c=s?this.freeBuffers:this.freeUniformBuffers,m=c.get(i);m||(m=[],c.set(i,m)),m.length>0?o=m.pop():o=this.backend.device.createBuffer({size:i,usage:r})}else o=this.backend.device.createBuffer({size:i,usage:r});let n={id:wo(),type:0,buffer:o};return this.storageCache.set(n.id,{gpuData:n,originalSize:t}),Ie("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${n.id}`),n}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=this.storageCache.get(t);if(!r)throw new Error("releasing data does not exist");return Ie("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,r){let i=this.storageCache.get(t);if(!i)throw new Error("data does not exist");await sn(this.backend,i.gpuData.buffer,i.originalSize,r)}refreshPendingBuffers(){for(let t of this.buffersForUploadingPending)t.destroy();this.buffersForUploadingPending=[];for(let t of this.buffersPending)(t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(t.size).push(t):(t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(t.size).push(t):t.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},vo=(...e)=>new an(...e)});var un,ae,_e=H(()=>{"use strict";un=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this._cacheKey}},ae=e=>new un(e)});var ln,Ze,D,bt,$r,xr,Cr,me=H(()=>{"use strict";ln=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},Ze=class{static calcShape(t,r,i=!1){let o=t.length,s=r.length;if(o===0)return r;if(s===0)return t;let l=Math.max(t.length,r.length),n=new Array(l);if(i){if(o<2||s<2)return;let c=ln.calcMatMulShape([t[o-2],t[o-1]],[r[s-2],r[s-1]]);if(c===void 0)return;[n[l-2],n[l-1]]=c}for(let c=i?3:1;c<=l;c++){let m=o-c<0?1:t[o-c],g=s-c<0?1:r[s-c];if(m!==g&&m>1&&g>1)return;n[l-c]=Math.max(m,g)}return n}static isValidBroadcast(t,r){let i=t.length,o=r.length;if(i>o)return!1;for(let s=1;s<=i;s++)if(t[i-s]!==1&&t[i-s]!==r[o-s])return!1;return!0}},D=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,i){let o=1;for(let s=r;s<i;s++){if(t[s]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");o*=t[s]}return o}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let i=new Array(r);i[r-1]=1,i[r-2]=t[r-1];for(let o=r-3;o>=0;--o)i[o]=i[o+1]*t[o+1];return i}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error("unsupported axis for this operation.");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(i=>this.normalizeAxis(i,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(i=>t[i]):t.slice().reverse()}static padShape(t,r){let i=t.length;return t.map((o,s)=>o+r[s]+r[s+i])}static areEqual(t,r){return t.length!==r.length?!1:t.every((i,o)=>i===r[o])}},bt=class e{static adjustPoolAttributes(t,r,i,o,s,l){if(!t&&i.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let n=0;n<r.length-2;n++)n>=i.length?i.push(r[n+2]):i[n]=r[n+2];for(let n=0;n<i.length;n++)if(n<o.length){if(o[n]<0)throw new Error("strides should be greater than or equal to 1")}else o.push(1);for(let n=0;n<i.length;n++)if(n<s.length){if(s[n]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let n=0;n<i.length*2;n++)if(n<l.length){if(l[n]<0)throw new Error("pad should be greater than or equal to 1")}else l.push(0);for(let n=0;n<i.length;n++){if(i[n]<=0)throw new Error("kernel shapes need to be greater than 0");if(l[n]>=i[n]||l[n+i.length]>=i[n])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,i,o,s,l,n){if(n){if(s.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(o.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let c=0;c<t.length-2;c++)e.adjustPadAndReturnShape(t[c+(l?1:2)],r[c],i[c],o[c],s,c,c+t.length-2,n)}}static computePoolOutputShape(t,r,i,o,s,l,n){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let c=[r[0],r[1]];return e.computeShapeHelper(t,r,c,i,o,s,l,n),c}static computeConvOutputShape(t,r,i,o,s,l,n){if(t.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let c=[t[0],r[0]];return e.computeShapeHelper(!1,t,c,i,o,s,l,n),c}static computeShapeHelper(t,r,i,o,s,l,n,c){if(t)for(let m=0;m<r.length-2;m++)i.push(1);else for(let m=0;m<r.length-2;m++)i.push(e.adjustPadAndReturnShape(r[m+2],o[m],s[m],l[m],n,m,m+r.length-2,c))}static adjustPadAndReturnShape(t,r,i,o,s,l,n,c){let m=i*(o-1)+1;if(c&&c!=="NOTSET")switch(c){case"VALID":return s[l]=0,s[n]=0,Math.floor((t-m)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(i!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let C=((t+r-1)/r-1)*r+o-t;return s[l]=Math.floor(c==="SAME_LOWER"?(C+1)/2:C/2),s[n]=C-s[l],Math.floor((t+C-o)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+s[l]+s[n]-m)/r+1)}},$r=class{static getShapeOfGemmResult(t,r,i,o,s){if(t.length!==2||i.length!==2)throw new Error("shape need to be of size 2");let l,n,c;r?(l=t[1],n=t[0]):(l=t[0],n=t[1]);let m=-1;if(o?(c=i[0],m=1):(c=i[1],m=0),i[m]!==n)throw new Error("dimension mismatch");if(l<=0||c<=0||n<=0)throw new Error("invalid shape specified");if(s&&!Ze.isValidBroadcast(s,[l,c]))throw new Error("gemm: invalid bias shape for broadcast");return[l,c,n]}},xr=-34028234663852886e22,Cr=34028234663852886e22});var $u,xo,Pe,cn,Co,K,se,dn,So,pn,$e=H(()=>{"use strict";ke();me();$u=64,xo=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},Pe=(e,t=1)=>{let r=xo(e,t);return typeof r=="string"?r:r[0]},cn=e=>[{type:"uint32",data:e},{type:"uint32",data:D.computeStrides(e)}],Co=(e,t,r,i,o)=>{let s=typeof r=="number",l=s?r:r.length,n=[...new Array(l).keys()],c=l<2?"u32":l<=4?`vec${l}<u32>`:`array<u32, ${l}>`,m=xo(t,o),g=typeof m=="string"?m:m[1],C=typeof m=="string"?m:m[0],x={indices:c,value:g,storage:C,tensor:t},$=N=>typeof N=="string"?N:`${N}u`,b={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},w=s?"uniforms.":"",v=`${w}${e}_shape`,I=`${w}${e}_strides`,B="";for(let N=0;N<l-1;N++)B+=`\n    let dim${N} = current / ${I}[${N}];\n    let rest${N} = current % ${I}[${N}];\n    indices[${N}] = dim${N};\n    current = rest${N};\n    `;B+=`indices[${l-1}] = current;`;let z=l<2?"":`\n  fn o2i_${e}(offset: u32) -> ${x.indices} {\n    var indices: ${x.indices};\n    var current = offset;\n    ${B}\n    return indices;\n  }`,M=N=>(b.offsetToIndices=!0,l<2?N:`o2i_${e}(${N})`),G=[];if(l>=2)for(let N=l-1;N>=0;N--)G.push(`${I}[${N}] * (indices[${N}])`);let _=l<2?"":`\n  fn i2o_${e}(indices: ${x.indices}) -> u32 {\n    return ${G.join("+")};\n  }`,U=N=>(b.indicesToOffset=!0,l<2?N:`i2o_${e}(${N})`),V=(...N)=>l===0?"0u":`${x.indices}(${N.map($).join(",")})`,j=(N,de)=>l<2?`${N}`:`${N}[${de}]`,le=(N,de,ge)=>l<2?`${N}=${ge};`:`${N}[${de}]=${ge};`,R={},X=(N,de)=>{b.broadcastedIndicesToOffset=!0;let ge=`${de.name}broadcastedIndicesTo${e}Offset`;if(ge in R)return`${ge}(${N})`;let ze=[];for(let Ge=l-1;Ge>=0;Ge--){let Te=de.indicesGet("outputIndices",Ge+de.rank-l);ze.push(`${j(I,Ge)} * (${Te} % ${j(v,Ge)})`)}return R[ge]=`fn ${ge}(outputIndices: ${de.type.indices}) -> u32 {\n             return ${ze.length>0?ze.join("+"):"0u"};\n           }`,`${ge}(${N})`},Se=(N,de)=>(()=>{if(x.storage===x.value)return`${e}[${N}]=${de};`;if(x.storage==="vec2<u32>"&&x.value==="i32")return`${e}[${N}]=vec2<u32>(u32(${de}), select(0u, 0xFFFFFFFFu, ${de} < 0));`;if(x.storage==="vec2<u32>"&&x.value==="u32")return`${e}[${N}]=vec2<u32>(u32(${de}), 0u);`;if(x.storage==="u32"&&x.value==="vec4<bool>")return`${e}[${N}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${de}));`;throw new Error(`not supported combination of storage type ${x.storage} and value type ${x.value} yet`)})(),q=N=>(()=>{if(x.storage===x.value)return`${e}[${N}]`;if(x.storage==="vec2<u32>"&&x.value==="i32")return`i32(${e}[${N}].x)`;if(x.storage==="vec2<u32>"&&x.value==="u32")return`u32(${e}[${N}].x)`;if(x.storage==="u32"&&x.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${N}] & 0xFFu), bool(${e}[${N}] & 0xFF00u), bool(${e}[${N}] & 0xFF0000u), bool(${e}[${N}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${x.storage} and value type ${x.value} yet`)})(),L=l<2?"":`\n  fn get_${e}ByIndices(indices: ${x.indices}) -> ${g} {\n    return ${q(`i2o_${e}(indices)`)};\n  }`,De=l<2?"":(()=>{let N=n.map(ge=>`d${ge}: u32`).join(", "),de=n.map(ge=>`d${ge}`).join(", ");return`\n  fn get_${e}(${N}) -> ${g} {\n    return get_${e}ByIndices(${V(de)});\n  }`})(),he=(...N)=>{if(N.length!==l)throw new Error(`indices length must be ${l}`);let de=N.map($).join(",");return l===0?q("0u"):l===1?q(de[0]):(b.get=!0,b.getByIndices=!0,b.indicesToOffset=!0,`get_${e}(${de})`)},Re=N=>l<2?q(N):(b.getByIndices=!0,b.indicesToOffset=!0,`get_${e}ByIndices(${N})`),we=l<2?"":`\n  fn set_${e}ByIndices(indices: ${x.indices}, value: ${g}) {\n    ${Se(`i2o_${e}(indices)`,"value")}\n  }`,Be=l<2?"":(()=>{let N=n.map(ge=>`d${ge}: u32`).join(", "),de=n.map(ge=>`d${ge}`).join(", ");return`\n  fn set_${e}(${N}, value: ${g}) {\n    set_${e}ByIndices(${V(de)}, value);\n  }`})();return{impl:()=>{let N=[];return s||(N.push(`const ${v} = ${x.indices}(${r.join(",")});`),N.push(`const ${I} = ${x.indices}(${D.computeStrides(r).join(",")});`)),b.offsetToIndices&&N.push(z),b.indicesToOffset&&N.push(_),b.broadcastedIndicesToOffset&&Object.values(R).forEach(de=>N.push(de)),b.set&&N.push(Be),b.setByIndices&&N.push(we),b.get&&N.push(De),b.getByIndices&&N.push(L),N.join(`\n`)},type:x,offsetToIndices:M,indicesToOffset:U,broadcastedIndicesToOffset:X,indices:V,indicesGet:j,indicesSet:le,set:(...N)=>{if(N.length!==l+1)throw new Error(`indices length must be ${l}`);let de=N[l];if(typeof de!="string")throw new Error("value must be string");let ge=N.slice(0,l).map($).join(",");return l===0?Se("0u",de):l===1?Se(ge[0],de):(b.set=!0,b.setByIndices=!0,b.indicesToOffset=!0,`set_${e}(${ge}, ${de})`)},setByOffset:Se,setByIndices:(N,de)=>l<2?Se(N,de):(b.setByIndices=!0,b.indicesToOffset=!0,`set_${e}ByIndices(${N}, ${de});`),get:he,getByOffset:q,getByIndices:Re,usage:i?"input":"output",name:e,strides:I,shape:v,rank:l}},K=(e,t,r,i=1)=>Co(e,t,r,!0,i),se=(e,t,r,i=1)=>Co(e,t,r,!1,i),dn=class{constructor(t){this.normalizedDispatchGroup=t;this.indicesHelpers=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=$u){let r=typeof t=="number"?t:t[0],i=typeof t=="number"?1:t[1],o=typeof t=="number"?1:t[2],s=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,l=s?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_index : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>`,n=s?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +\n          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${r*i*o}u + local_index;`;return`@compute @workgroup_size(${r}, ${i}, ${o})\n  fn main(${l}) {\n    ${n}\n  `}declareVariable(t,r){this.indicesHelpers.push(t),t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:t.type.indices}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:t.type.indices});let i=t.usage==="input"?"read":"read_write",o=t.type.storage;return`@group(0) @binding(${r}) var<storage, ${i}> ${t.name}: array<${o}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`\n`)}registerUniform(t,r){return this.uniforms.push({name:t,type:r}),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:r,type:i}of this.uniforms)t.push(`${r}:${i}`);return`\n      struct Uniforms { ${t.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.indicesHelpers.map(t=>t.impl()).join(`\n`)}},So=e=>new dn(e),pn=(e,t)=>{let r=e.length,i=[];for(let o=0;o<r;o++){let s=r-1-o,l=e[s]||1;(t[t.length-1-o]||1)>1&&l===1&&i.unshift(s)}return i}});var et,xu,Sr,Cu,tt,Ao,Io,To,Eo,Oo,_o,Po,Ro,Bo,Mo,je,fn=H(()=>{"use strict";me();_e();$e();et=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},xu=e=>["","",`var value = ${e.getByOffset("inputOffset")};`,""],Sr=(e,t,r,i,o,s,l=!1,n=!1)=>{let c=[],m=r[0].dims,g=D.normalizeAxes(o,r[0].dims.length),C=!n&&g.length===0;m.forEach((U,V)=>{C||g.indexOf(V)>=0?l&&c.push(1):c.push(U)});let x=[],$=K("_A",r[0].dataType,m),b=se("output",s,c),w=i($,b,g),v=`inputOffset = ${$.indicesToOffset("inputIndices")};`,I=`let ${v};`,B=`var ${v};`,z=w[1]===""?"":B,M=(w[1]===""?I:v)+`\n`+w[2];for(let U=0,V=0;U<r[0].dims.length;U++)C||g.indexOf(U)>=0?(l&&V++,M=`for(var j${U}: u32 = 0; j${U} < ${r[0].dims[U]}; j${U}++) {\n                ${w[2].includes("lastIndex")?`let lastIndex = j${U};`:""}\n                ${$.indicesSet("inputIndices",U,`j${U}`)}\n                ${M}\n              }`):(x.push(`${$.indicesSet("inputIndices",U,b.indicesGet("outputIndices",V))};`),V++);let G=D.size(c);return{name:e,shaderCache:t,getShaderSource:U=>`\n        ${U.declareVariables($,b)}\n\n        ${U.mainStart()}\n          ${U.guardAgainstOutOfBoundsWorkgroupSizes(G)}\n          var inputIndices: ${$.type.indices};\n          let outputIndices = ${b.offsetToIndices("global_idx")};\n\n          ${x.join(`\n`)}\n          ${w[0]}       // init ops for reduce max/min\n          ${z}\n          ${w[1]}\n          ${M}\n          ${w[3]}\n          ${w.length===4?b.setByOffset("global_idx","value"):w.slice(4).join(`\n`)}\n        }`,getRunData:()=>({outputs:[{dims:c,dataType:s}],dispatchGroup:{x:Math.ceil(G/64)}})}},Cu=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(i=>r.push(Number(i))),ae({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},tt=(e,t,r,i)=>{let o=e.inputs,s=o.length===1?r:Cu(o,r);e.compute(Sr(t,{hint:s.cacheKey},[o[0]],s.noopWithEmptyAxes&&s.axes.length===0?xu:i,s.axes,o[0].dataType,s.keepDims,s.noopWithEmptyAxes),{inputs:[0]})},Ao=(e,t)=>{et(e.inputs),tt(e,"ReduceLogSum",t,(i,o)=>[`var value = ${o.type.storage}(0);`,"",`value += ${i.getByOffset("inputOffset")};`,"value = log(value);"])},Io=(e,t)=>{et(e.inputs),tt(e,"ReduceL1",t,(i,o)=>[`var value = ${o.type.storage}(0);`,"",`value += abs(${i.getByOffset("inputOffset")});`,""])},To=(e,t)=>{et(e.inputs),tt(e,"ReduceL2",t,(i,o)=>[`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,"",`t = ${i.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"])},Eo=(e,t)=>{et(e.inputs),tt(e,"ReduceLogSumExp",t,(i,o)=>[`var value = ${o.type.storage}(0);`,"",`value += exp(${i.getByOffset("inputOffset")});`,"value = log(value);"])},Oo=(e,t)=>{et(e.inputs),tt(e,"ReduceMax",t,(i,o,s)=>{let l=[];for(let n=0;n<i.rank;n++)(s.indexOf(n)>=0||s.length===0)&&l.push(i.indicesSet("inputIndices",n,0));return[`${l.join(`\n`)}`,`var value = ${i.getByOffset("inputOffset")};`,`value = max(value, ${i.getByOffset("inputOffset")});`,""]})},_o=(e,t)=>{et(e.inputs),tt(e,"ReduceMean",t,(i,o,s)=>{let l=1;for(let n=0;n<i.rank;n++)(s.indexOf(n)>=0||s.length===0)&&(l*=e.inputs[0].dims[n]);return["var sum = f32(0);","",`sum += f32(${i.getByOffset("inputOffset")});`,`let value = ${o.type.value}(sum / ${l});`]})},Po=(e,t)=>{et(e.inputs),tt(e,"ReduceMin",t,(i,o,s)=>{let l=[];for(let n=0;n<i.rank;n++)(s.indexOf(n)>=0||s.length===0)&&l.push(`inputIndices[${n}] = 0;`);return[`${l.join(`\n`)}`,`var value = ${i.getByOffset("inputOffset")};`,`value = min(value, ${i.getByOffset("inputOffset")});`,""]})},Ro=(e,t)=>{et(e.inputs),tt(e,"ReduceProd",t,(i,o)=>[`var value = ${o.type.storage}(1);`,"",`value *= ${i.getByOffset("inputOffset")};`,""])},Bo=(e,t)=>{et(e.inputs),tt(e,"ReduceSum",t,(i,o)=>[`var value = ${o.type.storage}(0);`,"",`value += ${i.getByOffset("inputOffset")};`,""])},Mo=(e,t)=>{et(e.inputs),tt(e,"ReduceSumSquare",t,(i,o)=>[`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,"",`t = ${i.getByOffset("inputOffset")}; value += t * t;`,""])},je=e=>ae(e)});var ko,Do,Wo,zo,mn,Go=H(()=>{"use strict";ke();_e();fn();ko=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},Do=(e,t)=>ae({axis:t.axis,keepDims:t.keepDims,selectLastIndex:t.selectLastIndex}),Wo=(e,t)=>{ko(e.inputs);let r=(o,s,l)=>{let n=[];for(let c=0;c<o.rank;c++)(l.indexOf(c)>=0||l.length===0)&&n.push(`inputIndices[${c}] = 0;`);return[`${n.join(`\n`)}`,`var value = ${o.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${o.getByOffset("inputOffset")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${o.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",s.setByOffset("global_idx","bestIndex")]},i=e.inputs.length===1?t:Do(e.inputs,t);e.compute(Sr("ArgMin",{hint:i.cacheKey},[e.inputs[0]],r,[i.axis],7,i.keepDims),{inputs:[0]})},zo=(e,t)=>{ko(e.inputs);let r=(o,s,l)=>{let n=[];for(let c=0;c<o.rank;c++)(l.indexOf(c)>=0||l.length===0)&&n.push(`inputIndices[${c}] = 0;`);return[`${n.join(`\n`)}`,`var value = ${o.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${o.getByOffset("inputOffset")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${o.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",s.setByOffset("global_idx","bestIndex")]},i=e.inputs.length===1?t:Do(e.inputs,t);e.compute(Sr("argMax",{hint:i.cacheKey},[e.inputs[0]],r,[i.axis],7,i.keepDims),{inputs:[0]})},mn=e=>ae(e)});var Su,Au,Uo,No=H(()=>{"use strict";me();$e();Su=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Au=e=>{let t=e[0].dims,r=e[0].dims[2],i=D.size(t)/4,o=e[0].dataType,s=K("input",o,t,4),l=K("bias",o,[r],4),n=K("residual",o,t,4),c=se("output",o,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:g=>`\n  const channels = ${r}u / 4;\n  ${g.declareVariables(s,l,n,c)}\n\n  ${g.mainStart()}\n    ${g.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n    let value = ${s.getByOffset("global_idx")}\n      + ${l.getByOffset("global_idx % channels")} + ${n.getByOffset("global_idx")};\n    ${c.setByOffset("global_idx","value")}\n  }`}},Uo=e=>{Su(e.inputs),e.compute(Au(e.inputs))}});var Iu,xe,Vo,Fo,Ho,Lo,jo,Ko,qo,Yo,Xo,hn,Tu,Qo,Jo,Zo,ea,Ar,ta,Ir,ra,na,oa,aa,ia,sa,ua,la,da,ca,pa,fa,ma,ha,ga,ya,ba,gn=H(()=>{"use strict";ke();me();_e();$e();Iu=(e,t,r,i,o,s)=>{let l=Math.ceil(t/4),n="";typeof o=="string"?n=`${o}(a)`:n=o("a");let c=K("inputData",r,[l],4),m=se("outputData",i,[l],4);return`\n  ${e.declareVariables(c,m)}\n\n  ${s??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(l)}\n\n    let a = ${c.getByOffset("global_idx")};\n    ${m.setByOffset("global_idx",n)}\n  }`},xe=(e,t,r,i,o,s=e.dataType)=>({name:t,shaderCache:{hint:o},getShaderSource:l=>Iu(l,D.size(e.dims),e.dataType,s,r,i),getRunData:l=>({outputs:[{dims:e.dims,dataType:s}],dispatchGroup:{x:Math.ceil(D.size(l[0].dims)/64/4)}})}),Vo=e=>{e.compute(xe(e.inputs[0],"Abs","abs"))},Fo=e=>{e.compute(xe(e.inputs[0],"Acos","acos"))},Ho=e=>{e.compute(xe(e.inputs[0],"Acosh","acosh"))},Lo=e=>{e.compute(xe(e.inputs[0],"Asin","asin"))},jo=e=>{e.compute(xe(e.inputs[0],"Asinh","asinh"))},Ko=e=>{e.compute(xe(e.inputs[0],"Atan","atan"))},qo=e=>{e.compute(xe(e.inputs[0],"Atanh","atanh"))},Yo=e=>ae(e),Xo=(e,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${t.to}`)}e.compute(xe(e.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},hn=(e,t)=>{let r=Pe(e.inputs[0].dataType);e.compute(xe(e.inputs[0],"Clip",i=>`clamp(${i}, clip_min_, clip_max_)`,`\n    const clip_min_: vec4<${r}> = vec4(${r}(${t.min}));\n    const clip_max_: vec4<${r}> = vec4(${r}(${t.max}));\n`,t.cacheKey),{inputs:[0]})},Tu=e=>{let t=e.length>=2?e[1].getFloat32Array()[0]:xr,r=e.length>=3?e[2].getFloat32Array()[0]:Cr;return ae({min:t,max:r})},Qo=e=>{let t=Tu(e.inputs);hn(e,t)},Jo=e=>{e.compute(xe(e.inputs[0],"Ceil","ceil"))},Zo=e=>{e.compute(xe(e.inputs[0],"Cos","cos"))},ea=e=>{e.compute(xe(e.inputs[0],"Cosh","cosh"))},Ar=e=>ae(e),ta=(e,t)=>{e.compute(xe(e.inputs[0],"Elu",r=>`elu_vf32(${r})`,`\n  const elu_alpha_: f32 = f32(${t.alpha});\n\n  fn elu_f32(a: f32) -> f32 {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},Ir=(e,t="f32")=>`\nconst r0: ${t} = 0.3275911;\nconst r1: ${t} = 0.254829592;\nconst r2: ${t} = -0.284496736;\nconst r3: ${t} = 1.421413741;\nconst r4: ${t} = -1.453152027;\nconst r5: ${t} = 1.061405429;\n\nfn erf_vf32(v: ${e}) -> ${e} {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,ra=e=>{let t=Pe(e.inputs[0].dataType);e.compute(xe(e.inputs[0],"Erf",r=>`erf_vf32(${r})`,Ir(`vec4<${t}>`,t)))},na=e=>{e.compute(xe(e.inputs[0],"Exp","exp"))},oa=e=>{e.compute(xe(e.inputs[0],"Floor","floor"))},aa=e=>{let t=Pe(e.inputs[0].dataType);e.compute(xe(e.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,Ir(`vec4<${t}>`,t)))},ia=(e,t)=>{e.compute(xe(e.inputs[0],"LeakyRelu",r=>`select(leaky_relu_alpha_ * ${r}, ${r}, ${r} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${t.alpha});`,t.cacheKey))},sa=e=>{e.compute(xe(e.inputs[0],"Not",t=>`!${t}`))},ua=e=>{e.compute(xe(e.inputs[0],"Neg",t=>`-${t}`))},la=e=>{e.compute(xe(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},da=e=>{e.compute(xe(e.inputs[0],"Relu",t=>`select(vec4<f32>(0.0), ${t}, ${t} > vec4<f32>(0.0))`))},ca=e=>{e.compute(xe(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},pa=e=>{e.compute(xe(e.inputs[0],"Sin","sin"))},fa=e=>{e.compute(xe(e.inputs[0],"Sinh","sinh"))},ma=e=>{e.compute(xe(e.inputs[0],"Sqrt","sqrt"))},ha=e=>{e.compute(xe(e.inputs[0],"Tan","tan"))},ga=e=>{e.compute(xe(e.inputs[0],"Tanh","tanh"))},ya=(e,t)=>(e.compute(xe(e.inputs[0],"ThresholdedRelu",r=>`select(vec4<f32>(0.0), ${r}, ${r} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${t.alpha});`,t.cacheKey)),0),ba=e=>{e.compute(xe(e.inputs[0],"Log","log"))}});var Ou,_u,wa,va=H(()=>{"use strict";me();$e();gn();Ou=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},_u=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=K("input",e[0].dataType,e[0].dims,4),i=K("bias",e[0].dataType,[e[0].dims[2]],4),o=se("output",e[0].dataType,t,4),s=D.size(t)/4;return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:n=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${n.declareVariables(r,i,o)}\n\n  ${Ir("vec4f")}\n\n  ${n.mainStart()}\n    ${n.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${o.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},wa=e=>{Ou(e.inputs),e.compute(_u(e.inputs))}});var Pu,Ru,rt,$a,xa,Ca,Sa,Aa,Ia,Ta,Ea,Oa,_a,Pa=H(()=>{"use strict";ke();me();$e();Pu=(e,t,r,i,o,s,l,n,c,m,g)=>{let C=D.size(i),x=Math.ceil(C/4),$,b;typeof l=="string"?$=b=(M,G)=>`${l}((${M}),(${G}))`:typeof l=="function"?$=b=l:($=l.scalar,b=l.vector);let w="",v=se("outputData",m,i,4),I=K("aData",n,t,4),B=K("bData",c,r,4);if(s){let M=G=>{let _=D.computeStrides(G),U=[];for(let V=G.length-1;V>=0;V--){let j=v.indicesGet("outputIndices",V+i.length-G.length);U.push(`${_[V]}u * (${j} % ${G[V]}u)`)}return U.length>0?U.join("+"):"0u"};w=`\n          fn calcOffsetA(outputIndices: ${v.type.indices}) -> u32 {\n            return ${M(t)};\n          }\n\n          fn calcOffsetB(outputIndices: ${v.type.indices}) -> u32 {\n            return ${M(r)};\n          }\n        `}let z;if(o)if(s){let M=D.size(t)===1,G=D.size(r)===1;M||G?z=v.setByOffset("global_idx",b(M?`${I.type.value}(${I.getByOffset("0")}.x)`:I.getByOffset("global_idx"),G?`${B.type.value}(${B.getByOffset("0")}.x)`:B.getByOffset("global_idx"))):z=`\n            let outputIndices = ${v.offsetToIndices("global_idx * 4u")};\n            let offsetA = calcOffsetA(outputIndices);\n            let offsetB = calcOffsetB(outputIndices);\n            ${v.setByOffset("global_idx",b(I.getByOffset("offsetA / 4u"),B.getByOffset("offsetB / 4u")))}\n          `}else z=v.setByOffset("global_idx",b(I.getByOffset("global_idx"),B.getByOffset("global_idx")));else{if(!s)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let M=(G,_,U="")=>{let V=`aData[indexA${_}][componentA${_}]`,j=`bData[indexB${_}][componentB${_}]`;return`\n            let outputIndices${_} = ${v.offsetToIndices(`global_idx * 4u + ${_}u`)};\n            let offsetA${_} = calcOffsetA(outputIndices${_});\n            let offsetB${_} = calcOffsetB(outputIndices${_});\n            let indexA${_} = offsetA${_} / 4u;\n            let indexB${_} = offsetB${_} / 4u;\n            let componentA${_} = offsetA${_} % 4u;\n            let componentB${_} = offsetB${_} % 4u;\n            ${G}[${_}] = ${U}(${$(V,j)});\n          `};m===9?z=`\n            var data = vec4<u32>(0);\n            ${M("data",0,"u32")}\n            ${M("data",1,"u32")}\n            ${M("data",2,"u32")}\n            ${M("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:z=`\n            ${M("outputData[global_idx]",0)}\n            ${M("outputData[global_idx]",1)}\n            ${M("outputData[global_idx]",2)}\n            ${M("outputData[global_idx]",3)}\n          `}return`\n        ${e.declareVariables(I,B,v)}\n\n        ${g??""}\n        ${w}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(x)}\n        ${z}\n      }`},Ru=(e,t,r,i,o,s,l=r.dataType)=>{let n=!D.areEqual(r.dims,i.dims),c=r.dims,m=D.size(r.dims),g=!1;if(n){let C=Ze.calcShape(r.dims,i.dims,!1);if(!C)throw new Error("Can\'t perform binary op on the given tensors");c=C,m=D.size(c);let x=D.size(r.dims)===1,$=D.size(i.dims)===1,b=1;for(let w=1;w<c.length;w++){let v=r.dims[r.dims.length-w]??1,I=i.dims[i.dims.length-w]??1;if(v===I)b*=v;else break}(b%4===0||x||$)&&(g=!0)}else g=!0;return{name:e,shaderCache:{hint:t},getShaderSource:C=>Pu(C,r.dims,i.dims,c,g,n,o,r.dataType,i.dataType,l,s),getRunData:()=>({outputs:[{dims:c,dataType:l}],dispatchGroup:{x:Math.ceil(m/64/4)}})}},rt=(e,t,r,i,o,s)=>{e.compute(Ru(t,o??"",e.inputs[0],e.inputs[1],r,i,s))},$a=e=>{rt(e,"Add",(t,r)=>`${t}+${r}`)},xa=e=>{rt(e,"Div",(t,r)=>`${t}/${r}`)},Ca=e=>{rt(e,"Equal",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},Sa=e=>{rt(e,"Mul",(t,r)=>`${t}*${r}`)},Aa=e=>{let t=K("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;rt(e,"Pow",{scalar:(i,o)=>`pow_custom(${i},${o})`,vector:(i,o)=>`pow_vector_custom(${i},${o})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},Ia=e=>{rt(e,"Sub",(t,r)=>`${t}-${r}`)},Ta=e=>{rt(e,"Greater",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},Ea=e=>{rt(e,"Less",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},Oa=e=>{rt(e,"GreaterOrEqual",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},_a=e=>{rt(e,"LessOrEqual",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var Mu,ku,Du,Wu,Ra,Ba,Ma=H(()=>{"use strict";me();_e();$e();Mu=e=>{if(!e||e.length<1)throw new Error("too few inputs");let t=e[0].dataType,r=e[0].dims.length;for(let i of e){if(i.dataType!==t)throw new Error("input tensors should be one type");if(i.dims.length!==r)throw new Error("input tensors should have the same shape")}},ku=e=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,Du=(e,t)=>{let r=e.length,i=[];for(let o=0;o<r;++o){let s=t.setByOffset("global_idx",e[o].getByIndices("indices"));r===1?i.push(s):o===0?i.push(`if (inputIndex == ${o}u) { ${s} }`):o===r-1?i.push(`else { ${s} }`):i.push(`else if (inputIndex == ${o}) { ${s} }`)}return i.join(`\n`)},Wu=(e,t)=>{let r=e[0].dims.slice();if(t>=r.length||t<-1*r.length)throw new Error("axis specified for concat doesn\'t match input dimensionality");let i=t<0?r.length+t:t,o=r.slice(0);for(let $=1;$<e.length;$++){let b=e[$].dims.slice();for(let w=0;w<r.length;w++)if(w===i)o[i]+=b[w];else if(r[w]!==b[w])throw new Error("non concat dimensions must match")}let s=D.size(o),l=new Array(e.length),n=new Array(e.length),c=e[0].dataType,m=0;for(let $=0;$<e.length;++$)m+=e[$].dims[i],l[$]=m,n[$]=K(`input${$}`,c,e[$].dims);let g=se("output",c,o),C=g.indicesGet("indices",i),x=$=>`\n  ${$.declareVariables(...n,g)}\n\n  const sizeInConcatAxis = array<u32, ${l.length}>(${l.map(b=>`${b}u`).join(",")});\n  ${ku(l.length)}\n\n  ${$.mainStart()}\n    ${$.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n\n    var indices = ${g.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${C});\n    if (inputIndex != 0u) {\n      ${C} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${Du(n,g)}\n  }`;return{name:"Concat",shaderCache:{hint:`${t}`},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:x}},Ra=(e,t)=>{Mu(e.inputs),e.compute(Wu(e.inputs,t.axis))},Ba=e=>ae({axis:e.axis})});var Me,Tr,Er,Or=H(()=>{"use strict";Me=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Tr=(e,t=!1,r=!1,i=3)=>"",Er=(e,t)=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      ${t?"value = activation(value, coords);":""}\n      `});var _r,yn=H(()=>{"use strict";_r=`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));\n}\n`});var Pr,Rr,Jt=H(()=>{"use strict";me();Pr=e=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${e.clipMin});const clip_max_=f32(${e.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},Rr=e=>{let t=e?.activation||"";if(t==="Clip"){let[r,i]=e?.activation_params||[xr,Cr];return{activation:t,clipMax:i,clipMin:r,activationCacheKey:`${t}:${r},${i}`}}return{activation:t,activationCacheKey:t}}});var zu,Gu,Zt,ka,Uu,er,Nu,Br,tr=H(()=>{"use strict";me();$e();Jt();Or();zu=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,Gu=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,Zt=(e,t,r="f32",i,o=!1,s=32,l=!1,n=32)=>{let c=t[1]*e[1],m=t[0]*e[0],g=o?c:s,C=o?s:c,x=g/t[0],$=s/t[1];if(!((o&&x===4&&e[1]===4||!o&&(x===3||x===4))&&g%t[0]===0&&s%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${o} is true, innerElementSize ${x} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${x} must be 3 or 4.\n  tileAWidth ${g} must be divisible by workgroupSize[0]${t[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${x}<${r}>, ${g/x}>, ${C}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${r}>, ${m/e[0]}>, ${s}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${x};\nconst tileInner = ${s};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${l?"0":"i32(globalId.z)"};\n  ${i?`let batchIndices = ${i.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${c};\n\n  let numTiles = ${l?`${Math.ceil(n/s)}`:"(dimInner - 1) / tileInner + 1"};\n  var kStart = ${l?`i32(globalId.z) * ${n}`:"0"};\n\n  var acc: array<vec4<${r}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${$};\n  for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${zu(o,i)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${$}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${i?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${x===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${Gu(o,x)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},ka=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,Uu=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",er=(e,t,r="f32",i,o=!1,s=32,l=!1,n=32,c=!1)=>{let m=e[1]*t[1],g=e[0]*t[0],C=o?m:s,x=o?s:m;if(!(x%t[1]===0&&C%t[0]===0&&s%t[1]===0))throw new Error(`tileAHight ${x} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${C} must be divisible by workgroupSize[0]${t[0]}, tileInner ${s} must be divisible by workgroupSize[1]${t[1]}`);let $=x/t[1],b=C/t[0],w=s/t[1],v=c?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${m};\n    let globalColStart = i32(workgroupId.x) * ${g};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${x}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${C}; inputCol = inputCol + ${t[0]}) {\n          ${ka(o,i)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${g}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${i?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${r}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${o?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${m};\n\nlet tileRowA = i32(localId.y) * ${$};\nlet tileColA = i32(localId.x) * ${b};\nlet tileRowB = i32(localId.y) * ${w};\n// Loop over shared dimension.\nfor (var t = 0; t < numTiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${$}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${b}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${ka(o,i)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${i?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${r}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${Uu(o)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${r}, ${C}>, ${x}>;\n  var<workgroup> mm_Bsub : array<array<${r}, ${g}>, ${s}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${s};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${l?"0":"i32(globalId.z)"};\n    ${i?`let batchIndices = ${i.offsetToIndices("u32(batch)")};`:""}\n    let numTiles = ${l?`${Math.ceil(n/s)}`:"(dimInner - 1) / tileInner + 1"};\n    var kStart = ${l?`i32(globalId.z) * ${n}`:"0"};\n\n    var acc : array<array<${r}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${v}\n  }\n`},Nu=(e,t,r,i,o,s=!1)=>{let l=o[0],n=o[1],c=o[2],m=i[0],g=i[1],C=i[2],x=i[3],$=pn(l,c),b=pn(n,c),w=Pe(i[0].type.tensor),v=()=>{let z=g.rank,M=m.rank,G=`var aIndices: ${g.type.indices};`;for(let _=z-2-1,U=M-1;_>=0;_--,U--)G+=`\naIndices[${_}] = ${M>1?`batchIndices[${U}]`:"batchIndices"};`;return $.forEach(_=>{G+=`\naIndices[${_}] = 0;`}),G+=`\naIndices[${z-2}] = u32(row);\n                   aIndices[${z-1}] = u32(colIn);`,G},I=()=>{let z=C.rank,M=m.rank,G=`var bIndices: ${C.type.indices};`;for(let _=z-2-1,U=M-1;_>=0;_--,U--)G+=`\nbIndices[${_}] = ${M>1?`batchIndices[${U}]`:"batchIndices"};`;return b.forEach(_=>{G+=`\nbIndices[${_}] = 0;`}),G+=`\nbIndices[${z-2}] = u32(row);\n                   bIndices[${z-1}] = u32(colIn);`,G};return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${m.type.indices}) -> ${Me(e,w)} {\n      var value = ${Me(e,w)}(0.0);\n      let col = colIn * ${e};\n      if(row < dimAOuter && col < dimInner)\n      {\n        ${v()}\n        value = ${g.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${m.type.indices}) -> ${Me(e,w)} {\n      var value = ${Me(e,w)}(0.0);\n      let col = colIn * ${e};\n      if(row < dimInner && col < dimBOuter)\n      {\n        ${I()}\n        value = ${C.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Me(e,w)}) {\n      let col = colIn * ${e};\n      if (row < dimAOuter && col < dimBOuter) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${s?"bias[colIn]":`${Me(e,w)}(bias[row])`};`:""}\n        ${r}\n        ${x.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},Br=(e,t,r,i,o=!1)=>{let s=e[0].dims,l=e[1].dims,n=s.slice(0,-2),c=l.slice(0,-2),m=i?i.slice(0,-2):r.slice(0,-2),g=K("batchDims",e[0].dataType,m),C=[g],x=[n,c,m],$=D.size(m),b=s[s.length-2],w=s[s.length-1],v=l[l.length-1],I=w%4===0&&v%4===0,{activationFunction:B,applyActivation:z}=Pr(t),M=b<=8?[4,1,1]:[4,4,1],G=[8,8,1],_=[Math.ceil(v/G[0]/M[0]),Math.ceil(b/G[1]/M[1]),Math.ceil($/G[2]/M[2])],U=Pe(e[0].dataType),V=I?4:1,j=K("a",e[0].dataType,[...n,b,w/V],V),le=K("b",e[1].dataType,[...c,w,v/V],V),R=se("result",e[0].dataType,[$,b,v/V],V);C.push(j),C.push(le),C.push(R);let X=[j,le],Se=e.length>2,q=Nu(V,Se,z,C,x,o);if(Se){let De=o?V:1;X.push(K("bias",e[2].dataType,e[2].dims,De))}let L=De=>`\n  const dimAOuter: i32 = ${b};\n  const dimBOuter: i32 = ${v};\n  const dimInner: i32 = ${w};\n  ${De.declareVariables(...X,R)}\n  ${q}\n  ${B}\n  ${I?Zt(M,G,U,g):er(M,G,U,g)}\n                   ${g.impl()}`;return{name:"MatMul",shaderCache:{hint:t.activationCacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:_[0],y:_[1],z:_[2]}}),getShaderSource:L}}});var Vu,Da,Wa=H(()=>{"use strict";lt();me();$e();Or();yn();tr();Vu=(e,t,r,i,o=!1,s,l=!1,n=4,c=4,m=4,g="f32")=>{let C=le=>{switch(le){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${g}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${le} is not supported.`)}},x=le=>{switch(le){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${le} is not supported.`)}},$=e?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,b=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,w=e?"xShape[1]":"xShape[2]",v=e?"xShape[2]":"xShape[3]",I=e?"row":"col",B=e?"col":"row",z=`\n    let inChannels = wShape[2];\n    let outWidth = ${e?"outShape[2]":"outShape[3]"};\n    let outRow = ${I} / outWidth;\n    let outCol = ${I} % outWidth;\n\n    let WRow = ${B} / (filterDims[1] * inChannels);\n    let WCol = ${B} / inChannels % filterDims[1];\n    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];\n    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];\n    let xCh = ${B} % inChannels;\n    var resData = ${Me(n,g)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the \'same\' padding type.\n    if (xRow >= 0 && xRow < ${w} && xCol >= 0 && xCol < ${v}) {\n      ${$}\n      let xIndex = getIndexFromCoords4D(coord, xShape);\n      ${C(n)}\n    }\n    return resData;`,M=e?t&&i?`\n    let col = colIn * ${n};\n    ${z}`:`\n    let col = colIn * ${n};\n    if (row < dimAOuter && col < dimInner) {\n      ${z}\n    }\n    return ${Me(n,g)}(0.0);`:i&&r?`\n    let col = colIn * ${n};\n    ${z}`:`\n    let col = colIn * ${n};\n    if (row < dimInner && col < dimBOuter) {\n      ${z}\n    }\n    return ${Me(n,g)}(0.0);`,G=`${x(c)}`,_=Me(m,g),U=e?Me(n,g):Me(c,g),V=e?Me(c,g):Me(n,g);return`\n    ${Tr(s,l,m===4,4)}\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${U} {\n      ${e?M:G}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${V} {\n      ${e?G:M}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${_}) {\n      let col = colIn * ${m};\n      if (row < dimAOuter && col < dimBOuter)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${b}\n      ${Er(o,s)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},Da=(e,t,r,i,o,s,l,n)=>{let c=t.format==="NHWC",m=c?e[0].dims[3]:e[0].dims[1],g=r[0],C=c?r[2]:r[3],x=c?r[1]:r[2],$=c?r[3]:r[1],b=c&&(m%4===0||m%3===0)&&$%4===0,w=c?$:C*x,v=c?C*x:$,I=[8,8,1],B=i<=8?[4,1,1]:[4,4,1],z=[Math.ceil(w/I[0]/B[0]),Math.ceil(v/I[1]/B[1]),Math.ceil(g/I[2]/B[2])];Ie("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${z}`);let M=b?c&&m%4!==0?3:4:B[0],G=I[1]*B[1],_=I[0]*B[0],U=Math.max(I[0]*M,I[1]),V=i%G===0,j=o%_===0,le=s%U===0,R=b?[M,4,4]:[1,1,1],X=Pe(e[0].dataType),Se=[`@group(0) @binding(0) var<storage, read> x: array<${b&&M===4?`vec4<${X}>`:X}>;`,`@group(0) @binding(1) var<storage, read> w: array<${b?`vec4<${X}>`:X}>;`],q=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${b?`vec4<${X}>`:X}) {\n        result[flatIndex] = ${b?`vec4<${X}>`:X}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${b?`vec4<${X}>`:X}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${b?"/ 4":""}, value);\n      }`;return l&&(Se.push(`@group(0) @binding(2) var<storage, read> bias: array<${b?`vec4<${X}>`:X}>;`),q+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${b?`vec4<${X}>`:X} {\n          return bias[coords.${c?"w":"y"}${b?"/ 4":""}];\n        }`),{name:"Conv2DMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:z[0],y:z[1],z:z[2]}}),getShaderSource:()=>`\n        ${_r}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${Se.join("")}\n        @group(0) @binding(${Se.length}) var<storage, read_write> result: array<${b?`vec4<${X}>`:X}>;\n        //@group(0) @binding(${Se.length+1}) var<uniform> uniforms: Uniforms;\n\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${D.computeStrides(r).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[0]}, ${t.kernelShape[1]});\n        const pad : vec2<i32> = vec2<i32>(${t.pads[0]}, ${t.pads[1]});\n        const stride : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${i};\n        const dimBOuter : i32 = ${o};\n        const dimInner : i32 = ${s};\n        ${q}\n        ${Vu(c,V,j,le,l,void 0,!1,R[0],R[1],R[2],X)}\n            ${b?Zt(B,I,X,void 0,!c,U):er(B,I,X,void 0,!c,U,!1,void 0,n)}`}}});var bn,za=H(()=>{"use strict";me();$e();vn();Jt();bn=(e,t,r)=>{let i=e.length>2,o=i?"value += b[output_channel];":"",s=e[0].dims,l=e[1].dims,n=l[0]/t.group,{activationFunction:c,applyActivation:m}=Pr(t),g=t.format==="NHWC",C=wn(s,l,t.dilations,t.pads,t.strides,g),x=D.size(C),$=se("output",e[0].dataType,C),b=K("x",e[0].dataType,s),w=K("w",e[1].dataType,l),v=[b,w];i&&v.push(K("b",e[2].dataType,e[2].dims));let I=B=>`\n  const strides: vec2<u32> = vec2(${t.strides[0]}u, ${t.strides[1]}u);\n  const pads: vec2<u32> = vec2(${t.pads[0]}u, ${t.pads[1]}u);\n\n  ${B.declareVariables(...v,$)}\n\n  ${c}\n\n  ${B.mainStart()}\n    ${B.guardAgainstOutOfBoundsWorkgroupSizes(x)}\n\n    let outputIndices = ${$.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${g?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${g?1:2}], outputIndices[${g?2:3}]) * strides - pads;\n    let group_id: u32 = output_channel / ${n}u;\n\n    var value: ${$.type.value} = ${$.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < ${l[1]}u; wInChannel++) {\n      let input_channel = group_id * ${l[1]}u + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < ${l[2]}u; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * ${t.dilations[0]}u;\n\n        if (xHeight < 0u || xHeight >= ${s[g?1:2]}u) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < ${l[3]}u; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * ${t.dilations[1]}u;\n          if (xWidth < 0u || xWidth >= ${s[g?2:3]}u) {\n            continue;\n          }\n\n          let xVal = ${g?b.get("batch","xHeight","xWidth","input_channel"):b.get("batch","input_channel","xHeight","xWidth")};\n          let wVal = ${w.get("output_channel","wInChannel","wHeight","wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${o}\n    ${m}\n    ${$.setByOffset("global_idx","value")}\n  }`;return{name:"GroupedConv",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r?r(C):C,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(x/64)}}),getShaderSource:I}}});var Fu,Ga,Hu,Lu,Et,Ua,Na,Mr=H(()=>{"use strict";me();_e();$e();Fu=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},Ga=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,Hu=(e,t)=>D.sortBasedOnPerm(e,Ga(e.length,t)),Lu=(e,t,r,i)=>{let o=[];o.push(`fn perm(i: ${i.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let s=0;s<t;++s)o.push(r.indicesSet("a",e[s],`i[${s}]`));return o.push("return a;}"),o.join(`\n`)},Et=(e,t,r)=>{let i=Ga(t,r),o=se("output",e,r&&r.length||t),s=K("a",e,t),l=n=>`\n  ${n.registerUniform("output_size","u32").declareVariables(s,o)}\n\n  ${Lu(i,t,s,o)}\n\n  ${n.mainStart()}\n    ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${o.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${o.setByOffset("global_idx",s.getByIndices("aIndices"))}\n  }`;return{name:"Transpose",shaderCache:{hint:`${r}`,inputDependencies:["rank"]},getRunData:n=>{let c=Hu(n[0].dims,i),m=D.size(c);return{outputs:[{dims:c,dataType:n[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:[{type:"uint32",data:m},...cn(n[0].dims),...cn(c)]}},getShaderSource:l}},Ua=(e,t)=>{Fu(e.inputs),e.compute(Et(e.inputs[0].dataType,e.inputs[0].dims.length,t.perm))},Na=e=>ae({perm:e.perm})});var wn,Va,ju,Fa,Ha,Ku,qu,La,vn=H(()=>{"use strict";me();_e();Wa();tr();za();Jt();Mr();wn=(e,t,r,i,o,s)=>{let l=e[0],n=e.slice(s?1:2,s?3:4),c=n.length,m=t[0],C=t.slice(2).map((b,w)=>b+(b-1)*(r[w]-1)),$=n.map((b,w)=>b+i[w]+i[w+c]).map((b,w)=>Math.floor((b-C[w]+o[w])/o[w]));return $.splice(0,0,l),$.splice(s?3:1,0,m),$},Va=[2,3,1,0],ju=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],i=e[1].dims[1]*t.group;if(r!==i)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let o=e[0].dims.length-2;if(t.dilations.length!==o)throw new Error(`dilations should be ${o}D`);if(t.strides.length!==o)throw new Error(`strides should be ${o}D`);if(t.pads.length!==o*2)throw new Error(`pads should be ${o*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},Fa=(e,t)=>{let r=e.kernelShape.slice();for(let s=2;s<t[1].dims.length;++s)r[s-2]===0&&(r[s-2]=t[1].dims[s]);let i=e.pads.slice();bt.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,i,e.format==="NHWC",e.autoPad);let o=Object.assign({},e);return Object.assign(o,{kernelShape:r,pads:i,cacheKey:e.cacheKey}),o},Ha=e=>{let t=Rr(e),r=e.format,i=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],o=e.dilations,s=e.group,l=e.kernel_shape,n=e.pads,c=e.strides,m=e.w_is_const();return ae({autoPad:i,format:r,dilations:o,group:s,kernelShape:l,pads:n,strides:c,wIsConst:m,...t})},Ku=(e,t,r)=>{let i=Fa(r,t);if(r.group!==1){e.compute(bn(t,i));return}let o=r.format==="NHWC",s=t.length===3,l=t[0].dims[o?1:2],n=t[0].dims[o?2:3],c=t[0].dims[o?3:1],m=t[1].dims[2],g=t[1].dims[3],C=wn(t[0].dims,t[1].dims,r.dilations,i.pads,r.strides,o),x=C[o?1:2],$=C[o?2:3],b=C[o?3:1],w=o&&m===l&&g===n&&r.pads[0]===0&&r.pads[1]===0;if(w||m===1&&g===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let _=C[0],U,V,j,le=[];if(o){let R=e.kernelCustomData.wT??e.compute(Et(t[1].dataType,t[1].dims.length,Va),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=R),w){let X=l*n*c;U=t[0].reshape([1,_,X]),V=R.reshape([1,X,b]),j=[1,_,b]}else U=t[0].reshape([_,l*n,c]),V=R.reshape([1,c,b]),j=[_,x*$,b];le.push(U),le.push(V)}else U=t[0].reshape([_,c,l*n]),V=t[1].reshape([1,b,c]),j=[_,b,x*$],le.push(V),le.push(U);s&&le.push(t[2]),e.compute(Br(le,i,C,j,o),{inputs:le});return}let v=!0,I=e.kernelCustomData.wT??e.compute(Et(t[1].dataType,t[1].dims.length,Va),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=I);let B=[t[0],I];s&&B.push(t[2]);let z=o?x*$:b,M=o?b:x*$,G=m*g*c;e.compute(Da(B,i,C,z,M,G,s,v),{inputs:B})},qu=(e,t)=>{let r=t.format==="NHWC",i=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&i.push(e.inputs[2]);let o=[0,t.pads[0],0,t.pads[1]],s=[1].concat(t.strides),l=[1].concat(t.dilations),n=[1].concat(t.kernelShape),c=Fa({...t,pads:o,strides:s,dilations:l,kernelShape:n},i);e.compute(bn(i,c,m=>r?[m[0],m[2],m[3]]:[]))},La=(e,t)=>{ju(e.inputs,t),e.inputs[0].dims.length===3?qu(e,t):Ku(e,e.inputs,t)}});var Yu,ja,Ka=H(()=>{"use strict";lt();me();Or();yn();tr();Yu=(e,t=!1,r,i=!1,o=4)=>{let s=Me(o,"f32"),l=I=>{switch(I){case 1:return"return W[getIndexFromCoords4D(coord, wShape)];";case 4:return`\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            `;default:throw new Error(`innerElementSize ${I} is not supported.`)}},n=e?`\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      `:`\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      `,c=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,m=e?"outBackprop[1]":"outBackprop[2]",g=e?"outBackprop[2]":"outBackprop[3]",C=e?"row":"col",x=e?"col":"row",$=`\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      let outRow = ${C} / outWidth;\n      let outCol = ${C} % outWidth;\n\n      let WRow = ${x} / (filterDims[1] * inChannels);\n      let WCol = ${x} / inChannels % filterDims[1];\n      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);\n      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);\n      if (xR < 0.0 || xR >= f32(${m}) || fract(xR) > 0.0) {\n        return ${s}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${g}) || fract(xC) > 0.0) {\n        return ${s}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${x} % inChannels;\n      ${n}\n      return x[getIndexFromCoords4D(coord, xShape)/${o}];`,b=e?`\n      let col = colIn * ${o};\n      if (row < dimAOuter && col < dimInner) {\n        ${$}\n      }\n      return ${s}(0.0);`:`\n      let col = colIn * ${o};\n      if (row < dimInner && col < dimBOuter) {\n        ${$}\n      }\n      return ${s}(0.0);`,w=`\n      let col = colIn * ${o};\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);\n      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];\n      if (${e?"row < dimInner && col < dimBOuter":"row < dimInner && col < dimAOuter"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${l(o)}\n      }\n      return ${s}(0.0);\n      `;return`\n  ${Tr(r,i,o===4,4)}\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${s} {\n    ${e?b:w}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${s} {\n    ${e?w:b}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${s}) {\n    let col = colIn * ${o};\n    if (row < dimAOuter && col < dimBOuter) {\n      var value = valueInput;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${c}\n      ${Er(t,r)}\n      result[getIndexFromCoords4D(coords, outShape)/${o}] = value;\n    }\n  }`},ja=(e,t,r,i,o,s,l,n)=>{let c=t.format==="NHWC",m=c?e[0].dims[3]:e[0].dims[1],g=r[0],C=c?r[2]:r[3],x=c?r[1]:r[2],$=c?r[3]:r[1],b=c?m%4===0&&$%4===0:C%4===0&&$%4===0,w=c?$:C*x,v=c?C*x:$,I=b?[8,8,1]:[w<=4||v<=4?4:16,w>4&&v<=4?4:16,1],B=b?[4,4,1]:[w<=4?1:4,w>4&&v<=4?1:4,1],z=[Math.ceil(w/I[0]/B[0]),Math.ceil(v/I[1]/B[1]),Math.ceil(g/I[2]/B[2])];Ie("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${z}`);let M=b?4:1,G=Math.max(I[0]*M,I[1]),_=[`@group(0) @binding(0) var<storage, read> x: array<${b?"vec4<f32>":"f32"}>;`,"@group(0) @binding(1) var<storage, read> W: array<f32>;"],U="";return l&&(_.push(`@group(0) @binding(2) var<storage, read> bias: array<${b?"vec4<f32>":"f32"}>;`),U+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${b?"vec4<f32>":"f32"} {\n          return bias[coords.${c?"w":"y"}${b?"/ 4":""}];\n        }`),{name:"Conv2DTransposeMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:z[0],y:z[1],z:z[2]}}),getShaderSource:()=>`\n        ${_r}\n        ${_.join(`\n`)}\n        @group(0) @binding(${_.length}) var<storage, read_write> result: array<${b?"vec4<f32>":"f32"}>;\n        const outBackprop : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${D.computeStrides(r).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[c?1:2]}, ${t.kernelShape[c?2:3]});\n        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(\n              ${t.dilations[0]<=1?0:(t.kernelShape[c?1:2]-1)*(t.dilations[0]-1)},\n              ${t.dilations[1]<=1?0:(t.kernelShape[c?2:3]-1)*(t.dilations[1]-1)});\n        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${t.pads[0]+t.pads[2]})/2,\n                                         i32(effectiveFilterDims[1]) - 1 - (${t.pads[1]+t.pads[3]})/2);\n        const strides : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${i};\n        const dimBOuter : i32 = ${o};\n        const dimInner : i32 = ${s};\n        ${U}\n        ${Yu(c,l,void 0,!1,M)}\n        ${b?Zt(B,I,"f32",void 0,!c,G):er(B,I,"f32",void 0,!c,G,!1,void 0,n)}`}}});var Xu,$n,qa=H(()=>{"use strict";lt();me();$e();Xu=(e,t,r,i,o,s,l=!1,n)=>{let c=r.format==="NHWC",m=c?1:2,g=c?2:3,C=c?3:1,x=D.size(i),$=l?2:1,b=r.group,w=t[1].dims,v=w[0]/b,I=w[1],B=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${l?`vec4<${n}>`:n}) {\n    result[flatIndex] = ${l?`vec4<${n}>`:n}(value);\n  }`;o&&(B+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${l?`vec4<${n}>`:n} {\n      return bias[coords.${c?"w":"y"}${l?"/ 4":""}];\n    }`);let z=l?4:1,M=K("W",t[1].dataType,t[1].dims,z),G=K("Dy",t[0].dataType,t[0].dims,z),_=[G,M];o&&_.push(K("bias",t[2].dataType,[i[C]],z));let U=se("result",t[0].dataType,i,z),V=`{\n        let batch: u32 = ${s?"global_id.z":"workgroup_id.z"} / outShape[1];\n        let r = ${s?"global_id.z":"workgroup_id.z"} % outShape[1];\n        let c = ${s?"global_id.y":"workgroup_id.y"} * ${$};\n        let d1: u32 = ${s?"global_id.x":"workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${n}>, ${$}>;\n        for (var i = 0; i < ${$}; i++) {\n          dotProd[i] = vec4<${n}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {\n          var dyR = (${n}(dyCorner.x) + ${n}(wR)) / ${n}(strides.x);\n          let wRPerm = filterDims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${n}(outBackprop[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {\n            let dyC = (${n}(dyCorner.y) + ${n}(wC)) / ${n}(strides.y);\n            let dyC2 = (${n}(dyCorner.y) + 1.0 + ${n}(wC)) / ${n}(strides.y);\n            let wCPerm = filterDims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${n}(outBackprop[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${n}(outBackprop[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${G.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${n}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${G.get("batch","idyR","idyC2","d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${n}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = outBackprop[${C}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${G.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${n}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${M.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${G.get("batch","idyR","idyC2","d2")};\n                let tmpval = vec4<${n}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${$}; i = i + 1) {\n          let value = dotProd[i] + ${o?"bias[c+i]":"0.0"};\n          ${U.set("batch","r","c + i","d1","value")};\n        }\n      }`,j=`\n          let outputIndices = ${U.offsetToIndices("global_idx")};\n          let batch = ${U.indicesGet("outputIndices",0)};\n          let d1 = ${U.indicesGet("outputIndices",C)};\n          let r = ${U.indicesGet("outputIndices",m)};\n          let c = ${U.indicesGet("outputIndices",g)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / ${I};\n          let wOutChannel = d1 - groupId * ${I};\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = 0.0;\n          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {\n            if (wR % dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${n}(dyRCorner) + ${n}(wR)) / ${n}(strides[0]);\n            let wRPerm = filterDims.x - 1 - wR / dilations.x;\n            if (dyR < 0.0 || dyR >= ${n}(outBackprop[${m}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {\n              if (wC % dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${n}(dyCCorner) + ${n}(wC)) / ${n}(strides.y);\n              let wCPerm = filterDims.y - 1 - wC / dilations.y;\n              if (dyC < 0.0 || dyC >= ${n}(outBackprop[${g}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * ${v};\n              for (var d2: u32 = 0; d2 < ${v}; d2 = d2 + 1) {\n                let xValue = ${c?G.get("batch","idyR","idyC","inputChannel"):G.get("batch","inputChannel","idyR","idyC")};\n                let wValue = ${M.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${o?"bias[d1]":"0.0"};\n          ${U.setByOffset("global_idx","value")};\n        `;return`\n  ${e.declareVariables(..._,U)}\n  ${B}\n  const outShape : vec4<u32> = vec4<u32>(${i.join(",")});\n  const outBackprop : vec4<u32> = vec4<u32>(${t[0].dims.join(",")});\n  const strides : vec2<u32> = vec2<u32>(${r.strides[0]}, ${r.strides[1]});\n  const filterDims : vec2<u32> = vec2<u32>(${r.kernelShape[c?1:2]}, ${r.kernelShape[c?2:3]});\n  const dilations : vec2<u32> = vec2<u32>(${r.dilations[0]}, ${r.dilations[1]});\n  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(\n          ${r.dilations[0]<=1?0:(r.kernelShape[c?1:2]-1)*(r.dilations[0]-1)},\n          ${r.dilations[1]<=1?0:(r.kernelShape[c?2:3]-1)*(r.dilations[1]-1)});\n  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${r.pads[0]+r.pads[2]})/2,\n                                     i32(effectiveFilterDims[1]) - 1 - (${r.pads[1]+r.pads[3]})/2);\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(x)};\n  ${l?V:j}}`},$n=(e,t,r)=>{let i=e.length>2,o=t.outputShape,s=D.size(o),l=[Math.ceil(s/64),1,1];Ie("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${l}`);let n=Pe(e[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:t.cacheKey},getRunData:()=>({dispatchGroup:{x:l[0],y:l[1],z:l[2]},outputs:[{dims:r?r(o):o,dataType:e[0].dataType}]}),getShaderSource:c=>Xu(c,e,t,o,i,l[1]===1&&l[2]===1,!1,n)}}});var Qu,Ju,Zu,Ya,Xa,el,tl,rl,nl,Qa,Ja=H(()=>{"use strict";_e();Ka();qa();Jt();Mr();Qu=(e,t,r,i,o,s)=>(e-1)*t+r+(i-1)*o+1-s,Ju=(e,t,r,i,o)=>{let s=Math.floor(e/2);t==="SAME_UPPER"?(r[i]=s,r[o]=e-s):t==="SAME_LOWER"&&(r[i]=e-s,r[o]=s)},Zu=(e,t,r,i,o,s,l,n,c,m)=>{let g=e.length-2,C=m.length===0;if(c.length===0)for(let b=0;b<g;++b)c.push(0);let x=e[0],$=t[n?3:1]*o;for(let b=0,w=e.length-g-(n?1:0);b<g;++b,++w){let v=e[w],I=C?v*l[b]:m[b],B=Qu(v,l[b],s[b],t[w],r[b],I);Ju(B,i,s,b,b+g),C&&m.push(l[b]*(v-1)+c[b]+(t[w]-1)*r[b]+1-s[b]-s[b+g])}m.splice(0,0,x),m.splice(n?3:1,0,$)},Ya=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((x,$)=>x*$,1)===0){r.length=0;for(let x=2;x<t[1].dims.length;++x)r.push(t[1].dims[x])}let i=e.format==="NHWC";r.splice(0,0,t[1].dims[0]),r.splice(i?3:1,0,t[1].dims[1]);let o=e.pads.slice(),s=e.outputShape.slice(),l=e.outputPadding.slice(),n=t[0].dims,c=e.dilations.slice();if(c.reduce((x,$)=>x+$,0)===0){let x=t[0].dims.length-2;c=new Array(x).fill(1)}let m=e.strides.slice();if(m.reduce((x,$)=>x+$,0)===0){let x=t[0].dims.length-2;m=new Array(x).fill(1)}Zu(n,r,c,e.autoPad,e.group,o,m,i,l,s);let g=Object.assign({},e),C=e.cacheKey+[r.join("n,"),o.join(","),m.join(","),l.join(","),s.join(","),c.join(",")].join("_");return Object.assign(g,{kernelShape:r,pads:o,outputPadding:l,outputShape:s,dilations:c,strides:m,cacheKey:C}),g},Xa=e=>{let t=Rr(e),r=e.format,i=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],o=e.dilations,s=e.group,l=e.kernelShape,n=e.pads,c=e.strides,m=e.wIsConst(),g=e.outputPadding,C=e.outputShape;return ae({autoPad:i,format:r,dilations:o,group:s,kernelShape:l,outputPadding:g,outputShape:C,pads:n,strides:c,wIsConst:m,...t})},el=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],i=e[1].dims[0];if(r!==i)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let o=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==o))throw new Error("invalid bias");let s=e[0].dims.length-2;if(t.dilations.reduce((g,C)=>g+C,0)>0&&t.dilations.length!==s)throw new Error(`dilations should be ${s}D`);if(t.strides.reduce((g,C)=>g+C,0)>0&&t.strides.length!==s)throw new Error(`strides should be ${s}D`);if(t.pads.reduce((g,C)=>g+C,0)>0&&t.pads.length!==s*2)throw new Error(`pads should be ${s*2}D`);if(t.outputPadding.length!==s&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${s}D`);if(t.kernelShape.reduce((g,C)=>g+C,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},tl=[2,3,1,0],rl=(e,t,r)=>{let i=Ya(r,t),o=r.format==="NHWC",s=t.length===3;if(i.group!==1){e.compute($n(t,i));return}let l=i.outputShape,n=l[o?1:2],c=l[o?2:3],m=l[o?3:1],g=t[1].dims[2],C=t[1].dims[3],x=t[0].dims[o?3:1],$=o?n*c:m,b=o?m:n*c,w=g*C*x,v=!0,I=e.kernelCustomData.wT??e.compute(Et(t[1].dataType,t[1].dims.length,tl),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=I);let B=[t[0],I];s&&(!o&&t[2].dims.length===1?B.push(t[2].reshape([t[2].dims[0],1,1])):B.push(t[2])),e.compute(ja(B,i,l,$,b,w,s,v),{inputs:B})},nl=(e,t)=>{let r=t.format==="NHWC",i=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];i.length===3&&i.push(e.inputs[2]);let o=t.kernelShape;(o.length===0||o[0]===0)&&(o=[e.inputs[1].dims[2]]);let s=t.dilations;(s.length===0||s[0]===0)&&(s=[1]);let l=t.strides;(l.length===0||l[0]===0)&&(l=[1]);let n=t.pads;n.length===0&&(n=[0,0]),n=[0,n[0],0,n[1]],l=[1].concat(l),s=[1].concat(s),o=[1].concat(o);let c=Ya({...t,pads:n,strides:l,dilations:s,kernelShape:o},i);e.compute($n(i,c,m=>r?[m[0],m[2],m[3]]:[m[0],m[1],m[3]]))},Qa=(e,t)=>{el(e.inputs,t),e.inputs[0].dims.length===3?nl(e,t):rl(e,e.inputs,t)}});var xn,kr,Za,ol,al,Cn,Sn,il,ei,ti,ri=H(()=>{"use strict";me();_e();$e();xn="[a-zA-Z]|\\\\.\\\\.\\\\.",kr="("+xn+")+",Za="^"+kr+"$",ol="("+kr+",)*"+kr,al="^"+ol+"$",Cn=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let i=this.symbolToIndices.get(t);i===void 0?i=[r]:i.push(r),this.symbolToIndices.set(t,i)}},Sn=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[i,o]=r.includes("->")?r.split("->",2):[r,""];if(!i.match(RegExp(al)))throw new Error("Invalid LHS term");if(i.split(",").forEach((n,c)=>{let m=t[c].dims.slice();if(!n.match(RegExp(Za)))throw new Error("Invalid LHS term");let g=this.processTerm(n,!0,m,c);this.lhs.push(g)}),o==="")o+=[...this.symbolToInfo.entries()].filter(([n,c])=>c.count===1||n==="...").map(([n])=>n).join("");else if(!o.match(RegExp(kr)))throw new Error("Invalid RHS");o.match(RegExp(xn,"g"))?.forEach(n=>{if(n==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let c=this.symbolToInfo.get(n);if(c===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(c.dimValue)}}),this.rhs=this.processTerm(o,!0,this.outputDims)}addSymbol(t,r,i){let o=this.symbolToInfo.get(t);if(o!==void 0){if(o.dimValue!==r&&o.count!==1)throw new Error("Dimension mismatch");o.count++,o.inputIndices.push(i)}else o={count:1,dimValue:r,inputIndices:[i]};this.symbolToInfo.set(t,o)}processTerm(t,r,i,o=-1){let s=i.length,l=!1,n=[],c=0;if(!t.match(RegExp(Za))&&!r&&t!=="")throw new Error("Invalid LHS term");let m=t.match(RegExp(xn,"g")),g=new Cn(o);return m?.forEach((C,x)=>{if(C==="..."){if(l)throw new Error("Only one ellipsis is allowed per input term");l=!0;let $=s-m.length+1;if($<0)throw new Error("Ellipsis out of bounds");if(n=i.slice(c,c+$),this.hasEllipsis){if(this.ellipsisDims.length!==n.length||this.ellipsisDims.toString()!==n.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=n;else throw new Error("Ellipsis must be specified in the LHS");for(let b=0;b<n.length;b++){let w=String.fromCharCode("0".charCodeAt(0)+x);g.addSymbol(w,x+b),this.addSymbol(w,i[c++],o)}}else g.addSymbol(C,x),this.addSymbol(C,i[c++],o)}),g}},il=(e,t)=>{let r=e[0].dataType,i=new Array(e.length);for(let z=0;z<e.length;++z)i[z]=K(`input${z}`,r,e[z].dims);let o=t.outputDims,s=D.size(o),l=se("output",r,o),n=[],c=Array.from(t.rhs.symbolToIndices.keys()),m="var prod = 1.0;",g="var sum = 0.0;",C="sum += prod;",x=[],$=[],b=[],w=[],v=t.symbolToInfo.size===c.length;t.symbolToInfo.forEach((z,M)=>{if(c.includes(M)){let G=c.indexOf(M);t.lhs.forEach((_,U)=>{if(z.inputIndices.includes(U)){let V=_.symbolToIndices.get(M);if(V===void 0)throw new Error("Invalid symbol error");V.forEach(j=>{n.push(`${i[U].indicesSet(`input${U}Indices`,j,l.indicesGet("outputIndices",G))}`)})}})}else t.lhs.forEach((G,_)=>{let U=t.symbolToInfo.get(M);if(U===void 0)throw new Error("Invalid symbol error");if(U.inputIndices.includes(_)){let V=G.symbolToIndices.get(M);if(V===void 0)throw new Error("Invalid symbol error");V.forEach(j=>{x.push(`${i[_].indicesSet(`input${_}Indices`,j,`${M}`)}`)}),w.push(`prod *= ${i[_].getByIndices(`input${_}Indices`)};`)}}),$.push(`for(var ${M}: u32 = 0; ${M} < ${t.symbolToInfo.get(M)?.dimValue}; ${M}++) {`),b.push("}")});let I=v?[...n,`let sum = ${i.map((z,M)=>z.getByIndices(`input${M}Indices`)).join(" * ")};`]:[...n,g,...$,...x,m,...w,C,...b],B=z=>`\n      ${z.declareVariables(...i,l)}\n\n      ${z.mainStart()}\n        ${z.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n        var outputIndices = ${l.offsetToIndices("global_idx")};\n        ${i.map((M,G)=>`var input${G}Indices: ${i[G].type.indices};`).join(`\n`)}\n        ${I.join(`\n`)};\n        ${l.setByOffset("global_idx","sum")};\n      }`;return{name:"Einsum",shaderCache:{hint:t.equation},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:B}},ei=(e,t)=>{let r=new Sn(e.inputs,t.equation);e.compute(il(e.inputs,r))},ti=e=>{let t=e.equation.replace(/\\s+/g,"");return ae({equation:t})}});var sl,ni,ul,ll,oi,ai=H(()=>{"use strict";me();$e();sl=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),i=r.length<t.length?0:r.length-t.length,o=t.length<r.length?0:t.length-r.length;for(;i<r.length&&o<t.length;++i,++o)if(r[i]!==t[o]&&r[i]!==1&&t[o]!==1)throw new Error("Expand requires shape to be broadcastable to input")},ni=(e,t)=>{let r=e.length-t.length,i=[];for(let o=0;o<r;++o)i.push(e[o]);for(let o=0;o<t.length;++o)i.push(t[o]===1?e[o+r]:t[o]);return i},ul=(e,t)=>e.length>t.length?ni(e,t):ni(t,e),ll=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),i=ul(t,r),o=D.size(i),s=e[0].dataType,l=K("input",s,t),n=se("output",s,i),c=m=>`\n  const inputShape = ${l.indices(...t)};\n  ${m.declareVariables(l,n)}\n  ${m.mainStart()}\n  ${m.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n    let outputIndices = ${n.offsetToIndices("global_idx")};\n    var inputIndices: ${l.type.indices};\n    for (var i = 0; i < ${t.length}; i++) {\n      if (${l.indicesGet("inputShape","i")} == 1) {\n        ${l.indicesSet("inputIndices","i",0)}\n      } else {\n        ${l.indicesSet("inputIndices","i",n.indicesGet("outputIndices",`i + ${i.length-t.length}`))}\n      }\n    }\n    ${n.setByOffset("global_idx",l.getByIndices("inputIndices"))}\n  }`;return{name:"Expand",shaderCache:{hint:`${i}`},getShaderSource:c,getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}})}},oi=e=>{sl(e.inputs),e.compute(ll(e.inputs),{inputs:[0]})}});var dl,cl,ii,si,ui=H(()=>{"use strict";me();_e();$e();dl=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},cl=(e,t)=>{let r=e[0].dims,i=e[1].dims,o=r.length,s=D.normalizeAxis(t.axis,o),l=r.slice(0);l.splice(s,1,...i);let n=r[s],c=D.size(l),m=K("data",e[0].dataType,e[0].dims),g=K("inputIndices",e[1].dataType,e[1].dims),C=se("output",e[0].dataType,l),x=()=>{let b=i.length,w=`var indicesIndices  = ${g.type.indices}(0);`;for(let v=0;v<b;v++)w+=`${b>1?`indicesIndices[${v}]`:"indicesIndices"} = ${l.length>1?`outputIndices[${s+v}]`:"outputIndices"};`;w+=`\n        var idx = ${g.getByIndices("indicesIndices")};\n        if (idx < 0) {\n          idx = idx + ${n};\n        }\n        var dataIndices = ${m.type.indices}(0);\n      `;for(let v=0,I=0;v<o;v++)v===s?(w+=`${o>1?`dataIndices[${v}]`:"dataIndices"} = u32(idx);`,I+=b):(w+=`${o>1?`dataIndices[${v}]`:"dataIndices"} = ${l.length>1?`outputIndices[${I}]`:"outputIndices"};`,I++);return w},$=b=>`\n      ${b.declareVariables(m,g,C)}\n      ${b.mainStart()}\n        ${b.guardAgainstOutOfBoundsWorkgroupSizes(c)}\n        let outputIndices = ${C.offsetToIndices("global_idx")};\n        ${x()};\n        let value = ${m.getByIndices("dataIndices")};\n        ${C.setByOffset("global_idx","value")};\n      }`;return{name:"Gather",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:l,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)}}),getShaderSource:$}},ii=e=>ae({axis:e.axis}),si=(e,t)=>{let r=e.inputs;dl(r),e.compute(cl(e.inputs,t))}});var pl,fl,li,di,ci=H(()=>{"use strict";me();_e();$e();pl=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},fl=(e,t)=>{let r=e[0].dims,i=e[0].dataType,o=r.length,s=D.computeStrides(r),l=D.size(r),n=e[1].dims,c=e[1].dataType,m=D.size(n),g=D.normalizeAxis(t.axis,o),C=r[g],x=n.slice(0),$=D.size(x),b=K("input",i,r),w=K("indices",c,[m]),v=se("output",i,x),I=B=>`\n      const inputStrides = array<u32, ${s.length}>(${s.map(z=>`${z}u`).join(",")});\n      ${B.declareVariables(b,w,v)}\n      ${B.mainStart()}\n      ${B.guardAgainstOutOfBoundsWorkgroupSizes($)}\n\n      let outputIndices = ${v.offsetToIndices("global_idx")};\n\n      var idx = ${w.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + ${C};\n      }\n\n      var srcOffset = u32(0);\n\n      for (var i = 0; i < ${r.length}; i++) {\n        if (i == ${g}) {\n          srcOffset +=  u32(idx) * inputStrides[i];\n        } else {\n          srcOffset += ${v.indicesGet("outputIndices","i")} * inputStrides[i];\n        }\n      }\n\n      // Should never hit this with valid values in indices\n      // This is a guard against malicious data in the indices input\n      if (srcOffset < 0 || srcOffset >= ${l}) {\n        return;\n      }\n\n      output[global_idx] = input[srcOffset];\n  }`;return{name:"GatherElements",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:x,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil($/64)}}),getShaderSource:I}},li=e=>ae({axis:e.axis}),di=(e,t)=>{let r=e.inputs;pl(r),e.compute(fl(e.inputs,t))}});var ml,hl,gl,pi,fi,mi=H(()=>{"use strict";me();_e();$e();ml=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},hl=(e,t,r)=>{if(r.length===0)return"0u";let i=r.length===1&&e!==1||r.length===2&&r[0]!==e,o=r[r.length-1]!==t,s="0u";return i||(s+=`+ m * ${r[r.length-1]}u`),o||(s+="+n"),s},gl=(e,t)=>{let r=e[0].dims.slice(),i=e[1].dims.slice(),[o,s,l]=$r.getShapeOfGemmResult(r,t.transA,i,t.transB,e.length===3?e[2].dims:void 0),n=[o,s];if(!n)throw new Error("Can\'t use gemm on the given tensors");let c=D.size(n),m="";t.transA&&t.transB?m="value += a[k * M + m] * b[n * K + k];":t.transA&&!t.transB?m="value += a[k * M + m] * b[k * N + n];":!t.transA&&t.transB?m="value += a[m * K + k] * b[n * K + k];":!t.transA&&!t.transB&&(m="value += a[m * K + k] * b[k * N + n];");let g=Pe(e[0].dataType),C=t.alpha===1?"":"value *= alpha;",x=e.length===3?`value += beta * c[${hl(o,s,e[2].dims)}];`:"",$=[`@group(0) @binding(0) var<storage, read> a : array<${g}>;`,`@group(0) @binding(1) var<storage, read> b : array<${g}>;`];e.length===3&&$.push(`@group(0) @binding(2) var<storage, read> c : array<${g}>;`);let b=w=>`\n  const M: u32 = ${o}u;\n  const N: u32 = ${s}u;\n  const K: u32 = ${l}u;\n  const alpha = ${g}(${t.alpha});\n  const beta = ${g}(${t.beta});\n\n  ${$.join(`\n`)}\n  @group(0) @binding(${e.length}) var<storage, read_write> output : array<${g}>;\n\n  ${w.mainStart()}\n    ${w.guardAgainstOutOfBoundsWorkgroupSizes(c)}\n\n    let m = global_id.x / N;\n    let n = global_id.x % N;\n\n    var value = ${g}(0);\n    for (var k: u32 = 0u; k<${l}u; k++) {\n      ${m}\n    }\n\n    ${C}\n    ${x}\n    output[global_id.x] = value;\n\n  }`;return{name:"Gemm",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)}}),getShaderSource:b}},pi=(e,t)=>{ml(e.inputs),e.compute(gl(e.inputs,t))},fi=e=>ae(e)});var hi,yl,bl,gi,yi,bi=H(()=>{"use strict";me();_e();$e();hi={name:"InstanceNormalization"},yl=(e,t)=>{let r=e[0].dims,i=r,o=2,s=D.sizeToDimension(r,o),l=D.sizeFromDimension(r,o),n=r[1],c=K("x",e[0].dataType,[r[0],r[1],l]),m=K("scale",e[1].dataType,e[1].dims),g=K("bias",e[2].dataType,e[2].dims),C=se("output",e[0].dataType,[r[0],r[1],l]),x=[c,m,g,C],$=c.type.value,b=64,w=v=>`\n\n  const C: u32 = ${n};\n  const normSize: u32 = ${l};\n  const epsilon: f32 = ${t.epsilon};\n  var<workgroup> meanShared : ${$};\n  var<workgroup> squaredNormShared : ${$};\n  var<workgroup> workgroupShared : array<${$}, ${b}>;\n  const workgroupSize = ${b}u;\n  ${v.declareVariables(...x)}\n  ${v.mainStart(b)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / C;\n    let channel = norm % C;\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial: ${$} = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      initial = initial + ${c.get("batch","channel","h")};\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = workgroupShared[0] / ${$}(normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let deviation =  ${c.get("batch","channel","h")} - meanShared;\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = workgroupShared[0];\n    }\n    workgroupBarrier();\n\n    let invStdDev = 1 / sqrt(squaredNormShared / ${$}(normSize) + epsilon);\n    let channelScale = invStdDev * ${m.getByOffset("channel")};\n    let channelShift = ${g.getByOffset("channel")} - meanShared * channelScale;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let value = ${c.get("batch","channel","h")} * channelScale + channelShift;\n      ${C.set("batch","channel","h","value")};\n    }\n  }`;return{...hi,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:s}}),getShaderSource:w}},bl=(e,t)=>{let r=e[0].dims,i=r,o=D.size(i),s=r[0],l=r[r.length-1],n=D.sizeFromDimension(r,1)/l,c=Pe(e[0].dataType),m=l*s,g=C=>`\n  const N: u32 = ${s};\n  const H: u32 = ${n};\n  const C: u32 = ${l};\n  const normSizeTyped: ${c} = ${n};\n  const imageSize: u32 = ${n*l};\n  const epsilon: f32 = ${t.epsilon};\n\n  @group(0) @binding(0) var<storage, read> x : array<${c}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${c}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${c}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${c}>;\n\n  ${C.mainStart()}\n    let currentImageNumber = global_idx / C;\n    let currentChannelNumber = global_idx % C;\n\n    // offset is channel num * N\n    let offset = currentImageNumber * imageSize;\n    if (offset >= ${o}) { return; }\n    var mean: ${c} = 0;\n\n    for (var i: u32 = 0u; i < H; i++) {\n        mean = mean + x[offset + i * C + currentChannelNumber];\n    }\n    mean = mean / normSizeTyped;\n\n    var squaredNorm: ${c} = 0;\n    for (var i: u32 = 0u; i < H; i++) {\n        let deviation: f32 = x[offset + i * C + currentChannelNumber] - mean;\n        squaredNorm = squaredNorm + deviation * deviation;\n    }\n    let invStdDev = 1 / sqrt(squaredNorm / normSizeTyped + epsilon);\n    let channelScale = invStdDev * scale[currentChannelNumber];\n    let channelShift = bias[currentChannelNumber] - mean * channelScale;\n    for (var i: u32 = 0u; i < H; i++) {\n        let currentOffset = offset + i * C + currentChannelNumber;\n        output[currentOffset] = x[currentOffset] * channelScale + channelShift;\n    }\n  }`;return{...hi,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(m/64)}}),getShaderSource:g}},gi=e=>ae({epsilon:e.epsilon,format:e.format}),yi=(e,t)=>{t.format==="NHWC"?e.compute(bl(e.inputs,t)):e.compute(yl(e.inputs,t))}});var wl,vl,wi,vi,$i=H(()=>{"use strict";ke();me();_e();$e();wl=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.");if(e[0].dataType!==1||e[1].dataType!==1)throw new Error("inputs should be float type")},vl=(e,t,r)=>{let i=e[0].dims,o=e[1],s=e[2],l=i,n=D.size(l),c=D.normalizeAxis(t.axis,i.length),m=D.sizeToDimension(i,c),g=D.sizeFromDimension(i,c),C=D.size(o.dims),x=s?D.size(s.dims):0;if(C!==g||s&&x!==g)throw new Error(`Size of X.shape()[axis:] == ${g}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${C} and bias size of ${x}`);let $=[];for(let M=0;M<i.length;++M)M<c?$.push(i[M]):$.push(1);let b=Pe(e[0].dataType),w=r>1,v=r>2,I=0,B=M=>`\n  const normSize: u32 = ${g};\n  const normSizeTyped: ${b} = ${g};\n  const epsilon: f32 = ${t.epsilon};\n\n  @group(0) @binding(${I++}) var<storage, read> x : array<${b}>;\n  @group(0) @binding(${I++}) var<storage, read> scale : array<${b}>;\n  ${s?`@group(0) @binding(${I++}) var<storage, read> bias : array<${b}>;`:""}\n  @group(0) @binding(${I++}) var<storage, read_write> output : array<${b}>;\n  ${w?`@group(0) @binding(${I++}) var<storage, read_write> meanDataOutput : array<${b}>`:""};\n  ${v?`@group(0) @binding(${I++}) var<storage, read_write> invStdOutput : array<${b}>`:""};\n\n  ${M.mainStart()}\n    let offset = global_idx * normSize;\n    if (offset >= ${n}) { return; }\n    var mean: ${b} = 0;\n    var meanSquare: ${b} = 0;\n\n    for (var h: u32 = 0u; h < normSize; h++) {\n      mean = mean + x[h + offset];\n      meanSquare = meanSquare + x[h + offset] * x[h + offset];\n    }\n    mean = mean / normSizeTyped;\n    meanSquare = sqrt(meanSquare / normSizeTyped - mean * mean + epsilon);\n\n    for (var j: u32 = 0; j < normSize; j++) {\n      output[j + offset] = (x[j + offset] - mean) / meanSquare * scale[j] ${s?"+ bias[j]":""};\n    }\n\n    ${w?"meanDataOutput[global_idx] = mean":""};\n    ${v?"invStdOutput[global_idx] = 1 / meanSquare":""};\n  }`,z=[{dims:l,dataType:e[0].dataType}];return w&&z.push({dims:$,dataType:e[0].dataType}),v&&z.push({dims:$,dataType:e[0].dataType}),{name:"LayerNormalization",shaderCache:{hint:`${t.cacheKey}|${r}|${e.length}`},getRunData:()=>({outputs:z,dispatchGroup:{x:Math.ceil(m/64)}}),getShaderSource:B}},wi=e=>ae({axis:e.axis,epsilon:e.epsilon}),vi=(e,t)=>{wl(e.inputs),e.compute(vl(e.inputs,t,e.outputCount))}});var $l,xi,Ci=H(()=>{"use strict";me();tr();$l=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},xi=e=>{$l(e.inputs);let t=Ze.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can\'t use matmul on the given tensors");e.compute(Br(e.inputs,{activation:"",activationCacheKey:""},t))}});var xl,Cl,Sl,Al,Il,Tl,El,Ol,_l,Si,Ai,Ii=H(()=>{"use strict";ke();me();_e();$e();xl=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1)throw new Error("Input type must be float.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},Cl=(e,t,r,i,o,s,l)=>{let n=r.length,c="";for(let m=n-1;m>=0;--m)c+=`\n            k = i32(${e.indicesGet("indices",m)}) - ${o[m]};\n            if (k < 0) {\n              break;\n            }\n            if (k >= ${r[m]}) {\n              break;\n            }\n            offset += k * ${i[m]};\n        `;return`\n          value = ${s}(${l});\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${c}\n            value = x[offset];\n          }\n      `},Sl=(e,t,r,i,o)=>{let s=r.length,l="";for(let n=s-1;n>=0;--n)l+=`\n                k = i32(${e.indicesGet("indices",n)}) - ${o[n]};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = ${2*(r[n]-1)};\n                  k = k % _2n_1;\n                  if(k >= ${r[n]}) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * ${i[n]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${l}\n              value = x[offset];\n          `},Al=(e,t,r,i,o)=>{let s=r.length,l="";for(let n=s-1;n>=0;--n)l+=`\n                k = i32(${e.indicesGet("indices",n)}) - ${o[n]};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= ${r[n]}) {\n                  k = ${r[n]-1};\n                }\n                offset += k * ${i[n]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${l}\n              value = x[offset];\n          `},Il=(e,t,r,i,o)=>{let s=r.length,l="";for(let n=s-1;n>=0;--n)l+=`\n                k = i32(${e.indicesGet("indices",n)}) - ${o[n]};\n                if (k < 0)  {\n                  k += ${r[n]};\n                }\n                if (k >= ${r[n]}) {\n                  k -= ${r[n]};\n                }\n                offset += k * ${i[n]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${l}\n              value = x[offset];\n          `},Tl=(e,t,r,i,o,s)=>{switch(o.mode){case 0:return Cl(e,t,r,i,o.pads,s,o.value);case 1:return Sl(e,t,r,i,o.pads);case 2:return Al(e,t,r,i,o.pads);case 3:return Il(e,t,r,i,o.pads);default:throw new Error("Invalid mode")}},El=(e,t,r,i)=>{let o=t[0].dims,s=D.padShape(o.slice(),r.pads),l=D.size(s),n=D.computeStrides(o),c=se("output",t[0].dataType,s),m=K("x",t[0].dataType,o),g=Tl(c,s,o,n,r,i);return`\n              ${e.declareVariables(m,c)}\n              ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(l)}\n\n              let indices = ${c.offsetToIndices("global_idx")};\n\n              var value = ${i}(0);\n              ${g}\n              output[global_idx] = value;\n          }`},Ol=(e,t)=>{let r=D.padShape(e[0].dims.slice(),t.pads);return{name:"Pad",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(D.size(r)/64)}}),getShaderSource:i=>El(i,e,t,"f32")}},_l=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),i=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,o=e[0].dims.length,s=new Int32Array(2*o).fill(0);if(e.length>=4){let n=e[3].getBigInt64Array();for(let c=0;c<n.length;c++)s[Number(n[c])]=Number(r[c]),s[Number(n[c])+o]=Number(r[c+n.length])}else r.forEach((n,c)=>s[Number(c)]=Number(n));let l=[];return s.forEach(n=>l.push(n)),ae({mode:t.mode,value:i,pads:l})}else return t},Si=(e,t)=>{xl(e.inputs);let r=_l(e.inputs,t);e.compute(Ol(e.inputs,r),{inputs:[0]})},Ai=e=>{let t=e.mode,r=e.value,i=e.pads;return ae({mode:t,value:r,pads:i})}});var Dr,Ti,Ei,Oi,_i,Pi,Ri,Bi,Mi,ki,Di,Wi,zi,Gi,Ui,Ni=H(()=>{"use strict";me();_e();$e();Dr=e=>{if(!e||e.length!==1)throw new Error("Pool ops requires 1 input.");if(e[0].dims.length!==4)throw new Error("Pool ops supports 2-D inputs only for now.")},Ti=(e,t,r)=>{let i=t.format==="NHWC",o=i?[e.dims[0],e.dims[3],e.dims[1],e.dims[2]]:e.dims.slice(),s=Object.hasOwnProperty.call(t,"dilations"),l=t.kernelShape.slice(),n=t.strides.slice(),c=s?t.dilations.slice():[],m=t.pads.slice();bt.adjustPoolAttributes(r,o,l,n,c,m);let g=bt.computePoolOutputShape(r,o,n,c,l,m,t.autoPad),C=Object.assign({},t);return s?Object.assign(C,{kernelShape:l,strides:n,pads:m,dilations:c,cacheKey:t.cacheKey}):Object.assign(C,{kernelShape:l,strides:n,pads:m,cacheKey:t.cacheKey}),[C,i?[g[0],g[2],g[3],g[1]]:g]},Ei=(e,t,r,i,o,s,l,n)=>{let c=o.format==="NHWC",m=r,g=t.type.value,C=m.length,x=D.size(i),$=se("output",t.type.tensor,i);if(o.kernelShape.length<=2){let b=o.kernelShape[o.kernelShape.length-1],w=o.strides[o.strides.length-1],v=o.pads[o.pads.length/2-1],I=o.pads[o.pads.length-1],B=C-(c?2:1),z="",M="",G="";if(v+I!==0?z=`\n              for (var i: u32 = 0u; i < ${b}u; i++) {\n                xIndices[${B}] = indices[${B}] * ${w} - ${v} + i;\n                if (xIndices[${B}] < 0 || xIndices[${B}] >= ${m[B]}) {\n                  pad++;\n                  continue;\n                }\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${s}\n              }`:z=`\n              for (var i: u32 = 0u; i < ${b}u; i++) {\n                xIndices[${B}] = indices[${B}] * ${w} - ${v} + i;\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${s}\n              }`,o.kernelShape.length===2){let U=o.kernelShape[o.kernelShape.length-2],V=o.strides[o.strides.length-2],j=o.pads[o.pads.length/2-2],le=o.pads[o.pads.length-2],R=C-(c?3:2),X=m[R];j+le!==0?M=`\n                for (var j: u32 = 0u; j < ${U}u; j++) {\n                  xIndices[${R}] = indices[${R}] * ${V} - ${j} + j;\n                  if (xIndices[${R}] < 0 || xIndices[${R}] >= ${X}) {\n                    pad+= ${b};\n                    continue;\n                  }\n              `:M=`\n                for (var j: u32 = 0u; j < ${U}u; j++) {\n                  xIndices[${R}] = indices[${R}] * ${V} - ${j} + j;\n                `,G=`\n              }\n            `}return`\n            ${e.declareVariables(t,$)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(x)}\n\n              let indices = ${$.offsetToIndices("global_idx")};\n              var xIndices = ${$.offsetToIndices("global_idx")};\n\n              var value: ${g} = ${g}(${n});\n              var pad = 0;\n              ${M}\n              ${z}\n              ${G}\n              ${l}\n\n              output[global_idx] = value;\n            }`}else{if(c)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let b=D.size(o.kernelShape),w=D.computeStrides(o.kernelShape),v=w.length,I=o.pads.length,B=o.pads.reduce((G,_)=>G+_),z="";return B?z=`\n                if (xIndices[j] >= inputDims[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${s}\n              }`:z=`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${s}\n            `,`\n            ${e.declareVariables(t,$)}\n\n            const pads = array<u32, ${I}>(${o.pads.map(G=>`${G}u`).join(",")});\n            const inputDims = array<u32, ${C}>(${m.map(G=>`${G}u`).join(",")});\n            const kernelStrides = array<u32, ${v}>(${w.map(G=>`${G}u`).join(",")});\n            const strides = array<u32, ${v}>(${o.strides.map(G=>`${G}u`).join(",")});\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(x)}\n\n              let indices = ${$.offsetToIndices("global_idx")};\n              let xIndices = ${$.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${v}>;\n\n              var value = ${$.type.value}(${n});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < ${b}u; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${v-1}u; j++) {\n                  offsets[j] = offset / kernelStrides[j];\n                  offset -= offsets[j] * kernelStrides[j];\n                }\n                offsets[${v-1}] = offset;\n\n                isPad = false;\n                for (var j = ${C-v}u; j < ${C}u; j++) {\n                  xIndices[j] = indices[j] * strides[j - ${C-v}u]\n                    + offsets[j - ${C-v}u] - pads[j - 2u];\n                  ${z}\n              }\n              ${l}\n\n              output[global_idx] = value;\n            }`}},Oi=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),_i=(e,t,r,i)=>{let[o,s]=Ti(t,i,r),l=D.size(o.kernelShape),n=K("x",t.dataType,t.dims),c=n.type.value,m="value += x_val;",g="";return o.countIncludePad?g+=`value /= ${c}(${l});`:g+=`value /= ${c}(${l} - pad);`,{name:e,shaderCache:{hint:i.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(D.size(s)/64)}}),getShaderSource:C=>Ei(C,n,t.dims,s,o,m,g,"0.0")}},Pi=e=>{let t=e.count_include_pad!==0,r=Oi(e);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return ae({countIncludePad:t,...r})},Ri=(e,t)=>{Dr(e.inputs),e.compute(_i("AveragePool",e.inputs[0],!1,t))},Bi={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},Mi=e=>{let t=e.format;return{format:t,...Bi,cacheKey:t}},ki=(e,t)=>{Dr(e.inputs),e.compute(_i("GlobalAveragePool",e.inputs[0],!0,t))},Di=(e,t,r,i)=>{let[o,s]=Ti(t,i,r),l=`\n      value = max(x_val, value);\n    `,n="",c=K("x",t.dataType,t.dims);return{name:e,shaderCache:{hint:i.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(D.size(s)/64)}}),getShaderSource:m=>Ei(m,c,t.dims,s,o,l,n,"-1e5")}},Wi=(e,t)=>{Dr(e.inputs),e.compute(Di("MaxPool",e.inputs[0],!1,t))},zi=e=>{let t=e.storage_order,r=e.dilations,i=Oi(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(i.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return ae({storageOrder:t,dilations:r,...i})},Gi=e=>{let t=e.format;return{format:t,...Bi,cacheKey:t}},Ui=(e,t)=>{Dr(e.inputs),e.compute(Di("GlobalMaxPool",e.inputs[0],!0,t))}});var An=H(()=>{"use strict"});var Vi=H(()=>{"use strict";An()});var Fi,Hi=H(()=>{"use strict";Fi="1.17.0"});var Li,In,ji=H(()=>{"use strict";Hi();Li="warning",In={wasm:{},webgl:{},webgpu:{},versions:{common:Fi},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);Li=e}},get logLevel(){return Li}};Object.defineProperty(In,"logLevel",{enumerable:!0})});var Ki,qi=H(()=>{"use strict";ji();Ki=In});var Yi=H(()=>{"use strict"});var Xi=H(()=>{"use strict";Wr()});var Ji=H(()=>{"use strict"});var Zi=H(()=>{"use strict";Wr()});var Wr=H(()=>{"use strict";Yi();Xi();Ji();Zi()});var Tn=H(()=>{"use strict";Wr()});var es=H(()=>{"use strict";An();Tn()});var ts=H(()=>{"use strict";es()});var rs=H(()=>{"use strict"});var ns=H(()=>{"use strict"});var os=H(()=>{"use strict";ns()});var as=H(()=>{"use strict";Vi();qi();ts();Tn();rs();os()});var Rl,Bl,is,ss=H(()=>{"use strict";as();ke();$e();Rl=(e,t,r)=>{let i=e===t,o=e<t&&r<0,s=e>t&&r>0;if(i||o||s)throw new Error("Range these inputs\' contents are invalid.")},Bl=(e,t,r,i)=>{let o=Math.abs(Math.ceil((t-e)/r)),s=[o],l=o,n=se("output",i,s),c=n.type.storage,m=g=>`\n        ${g.declareVariables(n)}\n        ${g.mainStart()}\n        ${g.guardAgainstOutOfBoundsWorkgroupSizes(l)}\n        output[global_idx] = ${c}(${e}) + ${c}(global_idx) * ${c}(${r});\n      }`;return{name:"Range",shaderCache:{hint:[e,t,r].map(g=>g.toString()).join("_")},getShaderSource:m,getRunData:()=>({outputs:[{dims:s,dataType:i}],dispatchGroup:{x:Math.ceil(l/64)}})}},is=e=>{let t=0,r=0,i=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],i=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],i=e.inputs[2].getFloat32Array()[0]),Ki.webgpu.validateInputContent&&Rl(t,r,i),e.compute(Bl(t,r,i,e.inputs[0].dataType),{inputs:[]})}});var Ml,kl,Dl,Wl,zl,Gl,Ul,Nl,Vl,Fl,Hl,Ll,jl,Kl,ql,us,ls,ds=H(()=>{"use strict";me();_e();$e();Ml=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},kl=(e,t,r)=>{t.every(o=>o>=0&&o<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let i=new Array(r).fill(1);return t.forEach((o,s)=>i[o]=e[s]),i},Dl=(e,t,r,i,o,s)=>{let[l,n,c]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],m=e[0].dims.length;if(l>0&&e.length>l&&e[l].dims.length>0)e[l].getFloat32Array().forEach(g=>s.push(g));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(n>0&&e.length>n&&e[n].dims.length>0){if(e[n].getFloat32Array().forEach(g=>i.push(g)),i.length!==0&&i.length!==m&&r>=18&&i.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");Ml(i,t),t.axes.length>0&&kl(i,t.axes,m).forEach((g,C)=>i[C]=g)}if(c>0&&e.length>c&&(e[c].getBigInt64Array().forEach(g=>o.push(Number(g))),o.length!==m||r>=18&&o.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(i.length!==t.axes.length)throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');if(o.length!==t.axes.length)throw new Error(\'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\')}if(typeof i<"u"&&typeof o<"u"&&i.length>0&&o.length>m)throw new Error("Resize requires only of scales or sizes to be specified")},Wl=e=>"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(e){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`\n`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",zl=(e,t)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",Gl=(e,t,r)=>{let i=new Array(r).fill(0).concat(new Array(r).fill(1)),o=e.length===0?i:e.slice();return t.length>0?(t.forEach((s,l)=>{i[s]=o[l],i[l+r]=o[t.length+l]}),i):o},Ul=(e,t,r,i)=>{let o=[];if(r.length>0)if(i.length>0){if(e.forEach(s=>o.push(s)),Math.max(...i)>e.length)throw new Error("axes is out of bound");i.forEach((s,l)=>o[s]=r[l])}else r.forEach(s=>o.push(s));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");o=e.map((s,l)=>Math.round(s*t[l]))}return o},Nl=(e,t,r,i)=>{let o=(()=>{switch(i.keepAspectRatioPolicy){case"not_larger":return i.axes.length>0?Math.min(...i.axes.map(l=>r[l]),Number.MAX_VALUE):Math.min(...r,Number.MAX_VALUE);case"not_smaller":return i.axes.length>0?Math.max(...i.axes.map(l=>r[l]),Number.MIN_VALUE):Math.max(...r,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${i.keepAspectRatioPolicy} is not supported`)}})();r.fill(1,0,r.length);let s=e.slice();return i.axes.length>0?(i.axes.forEach(l=>r[l]=o),i.axes.forEach(l=>s[l]=Math.round(e[l]*r[l]))):(r.fill(o,0,r.length),s.forEach((l,n)=>s[n]=Math.round(l*r[n]))),s},Vl=(e,t,r,i,o)=>`\n    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${e.type.indices}) -> array<f32, ${r.length}> {\n      const inputShape = array<u32, ${t.length}>(${t.map(s=>`${s}u`).join(",")});\n      const outputShape = array<u32, ${r.length}>(${r.map(s=>`${s}u`).join(",")});\n      const scales = array<f32, ${i.length}>(${i.map(s=>`${s}f`).join(",")});\n      const roi = array<f32, ${o.length}>(${o.map(s=>`${s}f`).join(",")});\n      var originalIndices: array<f32, ${r.length}>;\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var outputIndex = ${r.length===1?"outputIndices":"outputIndices[i]"};\n        if (scales[i] == 1.0) {\n          originalIndices[i] = f32(outputIndex);\n        } else {\n          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${t.length}]);\n        }\n      }\n      return originalIndices;\n    }`,Fl=(e,t,r,i,o,s,l)=>`\n    fn calculateInputIndicesFromOutputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\n        const inputShape = array<u32, ${r.length}>(${r.map(n=>`${n}u`).join(",")});\n        const outputShape = array<u32, ${i.length}>(${i.map(n=>`${n}u`).join(",")});\n        const scales = array<f32, ${o.length}>(${o.map(n=>`${n}f`).join(",")});\n        const roi = array<f32, ${s.length}>(${s.map(n=>`${n}f`).join(",")});\n        var inputIndices: ${e.type.indices};\n        for (var i:u32 = 0; i < ${i.length}; i++) {\n          var outputIndex = ${i.length===1?"outputIndices":"outputIndices[i]"};\n          var inputIndex: u32;\n          if (scales[i] == 1.0) {\n            inputIndex = outputIndex;\n          } else {\n            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${r.length}]);\n            if (!${l} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {\n              if (original_idx < 0) {\n                inputIndex = 0;\n              } else if (original_idx > (f32(inputShape[i]) - 1)) {\n                inputIndex = inputShape[i] - 1;\n              } else {\n                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));\n              }\n            } else {\n              inputIndex = u32(original_idx);\n            }\n          }\n          ${e.indicesSet("inputIndices","i","inputIndex")}\n        }\n        return inputIndices;\n    }`,Hl=(e,t)=>`\n    fn checkInputIndices(inputIndices: ${e.type.indices}) -> bool {\n      const inputShape = array<u32, ${t.length}>(${t.map(r=>`${r}u`).join(",")});\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var inputIndex = ${t.length===1?"inputIndices":"inputIndices[i]"};\n        if (inputIndex < 0 || inputIndex >= inputShape[i]) {\n          return false;\n        }\n      }\n      return true;\n    }`,Ll=(e,t,r,i,o,s,l)=>{let[n,c,m,g]=r.length===2?[-1,0,1,-1]:o[1]===1?[0,2,3,1]:[0,1,2,3];return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {\n      var inputIndices: ${e.type.indices};\n      inputIndices[${c}] = max(0, min(row, ${r[c]} - 1));\n      inputIndices[${m}] = max(0, min(col, ${r[m]} - 1));\n      if (${r.length} > 2) {\n        inputIndices[${g}] = channel;\n        inputIndices[${n}] = batch;\n      };\n      return input[${e.indicesToOffset("inputIndices")}];\n    }\n\n    fn bilinearInterpolation(outputIndices: ${t.type.indices}) -> f32 {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);\n      var row:f32 = originalIndices[${c}];\n      var col:f32 = originalIndices[${m}];\n      if (${s} && (row < 0 || row > (${r[c]} - 1) || col < 0 || col > ${r[m]} - 1)) {\n        return ${l};\n      }\n      row = max(0, min(row, ${r[c]} - 1));\n      col = max(0, min(col, ${r[m]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = 0;\n      var batch: u32 = 0;\n      if (${r.length>2}) {\n        channel = u32(originalIndices[${g}]);\n        batch = u32(originalIndices[${n}]);\n      }\n      var x11: f32 = getInputValue(batch, channel, row1, col1);\n      var x12: f32 = getInputValue(batch, channel, row1, col2);\n      var x21: f32 = getInputValue(batch, channel, row2, col1);\n      var x22: f32 = getInputValue(batch, channel, row2, col2);\n      var dx1: f32 = row - f32(row1);\n      var dx2: f32 = f32(row2 ) - row;\n      var dy1 = col - f32(col1);\n      var dy2 = f32(col2) - col;\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},jl=(e,t,r,i,o,s,l,n,c,m)=>{let[g,C]=r.length===2?[0,1]:o[1]===1?[2,3]:[1,2],x=$=>{let b=$===g?"row":"col";return`\n      fn ${b}CubicInterpolation(inputIndices: ${e.type.indices}, outputIndices: ${t.type.indices}) -> f32 {\n        var outputIndex = ${i.length===1?"outputIndices":`outputIndices[${$}]`};\n        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${o[$]},\n        f32(${i[$]}), f32(${r[$]}), ${s[$]}, ${s[$]} + ${r.length});\n        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${n} && (originalIdx < 0 || originalIdx > (${r[$]} - 1))) {\n          return ${c};\n        }\n        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${b}: f32 = originalIdx + f32(i);\n          if (${b} < 0 || ${b} >= ${r[$]}) {\n            if (${m}) {\n              coefs[i + 1] = 0.0;\n              continue;\n            } else if (${n}) {\n              return ${c};\n            } else {\n              ${b} = max(0, min(${b}, ${r[$]} - 1));\n            }\n          }\n          var inputIndicesCopy: ${e.type.indices} = inputIndices;\n          inputIndicesCopy[${$}] = u32(${b});\n          data[i + 1] = ${$===g?`input[${e.indicesToOffset("inputIndicesCopy")}];`:`\n                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);`}\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${x(g)};\n    ${x(C)};\n  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {\n    var absS = abs(s);\n    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: f32 = 1.0 - absS;\n    var twoMinusAbsS: f32 = 2.0 - absS;\n    var onePlusAbsS: f32 = 1.0 + absS;\n    coeffs[0] = ((${l} * onePlusAbsS - 5 * ${l}) * onePlusAbsS + 8 * ${l}) * onePlusAbsS - 4 * ${l};\n    coeffs[1] = ((${l} + 2) * absS - (${l} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${l} + 2) * oneMinusAbsS - (${l} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${l} * twoMinusAbsS - 5 * ${l}) * twoMinusAbsS + 8 * ${l}) * twoMinusAbsS - 4 * ${l};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {\n    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(outputIndices: ${t.type.indices}) -> f32 {\n    var inputIndices: ${e.type.indices} = outputIndices;\n    return colCubicInterpolation(inputIndices, outputIndices);\n  }\n    `},Kl=(e,t,r,i,o,s)=>{let l=e.dims,n=Gl(s,t.axes,l.length),c=Ul(l,i,o,t.axes),m=i.slice();i.length===0&&(m=l.map((v,I)=>v===0?1:c[I]/v),t.keepAspectRatioPolicy!=="stretch"&&(c=Nl(l,c,m,t)));let g=se("output",e.dataType,c),C=K("input",e.dataType,l),x=D.size(c),$=l.length===c.length&&l.every((v,I)=>v===c[I]),b=t.coordinateTransformMode==="tf_crop_and_resize",w=v=>`\n      ${Wl(t.coordinateTransformMode)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${Hl(C,l)};\n              ${zl(t.nearestMode,r)};\n              ${Fl(C,g,l,c,m,n,b)};\n              `;case"linear":return`\n              ${Vl(g,l,c,m,n)};\n              ${Ll(C,g,l,c,m,b,t.extrapolationValue)};\n              `;case"cubic":return`\n            ${jl(C,g,l,c,m,n,t.cubicCoeffA,b,t.extrapolationValue,t.excludeOutside)};\n            `;default:throw Error("Invalid resize mode")}})()};\n      ${v.declareVariables(C,g)}\n      ${v.mainStart()}\n        ${v.guardAgainstOutOfBoundsWorkgroupSizes(x)}\n        if (${$}) {\n          output[global_idx] = input[global_idx];\n        } else {\n          let outputIndices = ${g.offsetToIndices("global_idx")};\n          var inputIndices: ${C.type.indices};\n          ${(()=>{switch(t.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);\n                  if (checkInputIndices(inputIndices)) {\n                    output[global_idx] = input[${C.indicesToOffset("inputIndices")}];\n                  } else {\n                    output[global_idx] = ${t.extrapolationValue};\n                  }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n        }\n      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${m.length>0?m:""}|${o.length>0?o:""}`},getShaderSource:w,getRunData:()=>({outputs:[{dims:c,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(x/64)}})}},ql=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},us=(e,t)=>{let r=[],i=[],o=[],s=ql(e);Dl(e.inputs,t,s,r,i,o),e.compute(Kl(e.inputs[0],t,s,r,i,o),{inputs:[0]})},ls=e=>{let t=e.antialias,r=e.axes,i=e.coordinateTransformMode,o=e.cubicCoeffA,s=e.excludeOutside!==0,l=e.extrapolationValue,n=e.keepAspectRatioPolicy,c=e.mode,m=e.nearestMode===""?"simple":e.nearestMode;return ae({antialias:t,axes:r,coordinateTransformMode:i,cubicCoeffA:o,excludeOutside:s,extrapolationValue:l,keepAspectRatioPolicy:n,mode:c,nearestMode:m})}});var Yl,Xl,cs,ps,fs=H(()=>{"use strict";ke();me();_e();$e();Yl=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");if(e[0].dataType!==1||e[1].dataType!==1)throw new Error("inputs should be float type");let t=e[0],r=e[1],i=e[2];if(t.dataType!==r.dataType||t.dataType!==i.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let o=t.dims[t.dims.length-1],s=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==o)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==s)throw new Error("Skip must have the same sequence length as input");if(i.dims.length!==1)throw new Error("Gamma must be 1D");if(i.dims[i.dims.length-1]!==o)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let l=e[3];if(l.dims.length!==1)throw new Error("Beta must be 1D");if(l.dims[l.dims.length-1]!==o)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let l=e[4];if(l.dims.length!==1)throw new Error("Bias must be 1D");if(l.dims[l.dims.length-1]!==o)throw new Error("Bias must have the same hidden size as input")}},Xl=(e,t,r,i)=>{let o=e[0].dims,s=D.size(o),l=o,n=s,c=o.slice(-1)[0],m=i?o.slice(0,-1).concat(1):[],g=e.length>3,C=e.length>4,x=Pe(e[0].dataType),$=i&&r>1,b=i&&r>2,w=r>3,v=0,I=z=>`\n      const hiddenSize: u32 = ${c};\n      const epsilon: f32 = ${t.epsilon};\n\n      @group(0) @binding(${v++}) var<storage, read> x : array<${x}>;\n      @group(0) @binding(${v++}) var<storage, read> skip : array<${x}>;\n      @group(0) @binding(${v++}) var<storage, read> gamma : array<${x}>;\n      ${g?`@group(0) @binding(${v++}) var<storage, read> beta : array<${x}>;`:""}\n      ${C?`@group(0) @binding(${v++}) var<storage, read> bias : array<${x}>;`:""}\n      @group(0) @binding(${v++}) var<storage, read_write> output : array<${x}>;\n      ${$?`@group(0) @binding(${v++}) var<storage, read_write> meanOutput : array<${x}>;`:""}\n      ${b?`@group(0) @binding(${v++}) var<storage, read_write> invStdOutput : array<${x}>;`:""}\n      ${w?`@group(0) @binding(${v++}) var<storage, read_write> inputSkipBiasSum : array<${x}>;`:""}\n\n      ${z.mainStart()}\n        ${z.guardAgainstOutOfBoundsWorkgroupSizes(n/c)}\n        let offset = global_idx * hiddenSize;\n        var sum: f32 = 0.0;\n        var squareSum: f32 = 0.0;\n        for (var i: u32 = 0; i < hiddenSize; i++) {\n          let skipValue = skip[offset + i];\n          let biasValue = ${C?"bias[i]":"0.0"};\n          let inputValue = x[offset + i];\n          let value = inputValue + skipValue + biasValue;\n          ${w?"inputSkipBiasSum[offset + i] = value;":""}\n          output[offset + i] = value;\n          sum += value;\n          squareSum += value * value;\n        }\n        let mean: f32 = sum / f32(hiddenSize);\n        let variance: f32 = sqrt(squareSum / f32(hiddenSize) - mean * mean + epsilon);\n        ${$?"meanOutput[global_idx] = mean;":""}\n        ${b?"invStdOutput[global_idx] = 1.0 / variance;":""}\n        for (var i: u32 = 0; i < hiddenSize; i++) {\n          output[offset + i] = (output[offset + i] - mean) / variance * gamma[i] + ${g?"beta[i]":"0.0"};\n        }\n      }`,B=[{dims:l,dataType:e[0].dataType}];return r>1&&B.push({dims:m,dataType:e[0].dataType}),r>2&&B.push({dims:m,dataType:e[0].dataType}),r>3&&B.push({dims:o,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:t.cacheKey},getShaderSource:I,getRunData:()=>({outputs:B,dispatchGroup:{x:Math.ceil(n/c/64)}})}},cs=(e,t)=>{Yl(e.inputs);let i=[0];e.outputCount>1&&i.push(-3),e.outputCount>2&&i.push(-3),e.outputCount>3&&i.push(3),e.compute(Xl(e.inputs,t,e.outputCount,!1),{outputs:i})},ps=e=>{let t=e.epsilon;return ae({epsilon:t})}});var Ql,zr,Jl,ms,Zl,ed,hs,gs,ys=H(()=>{"use strict";ke();me();_e();$e();Ql=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((r,i)=>{if(e[i+1].dataType!==6&&e[i+1].dataType!==7)throw new Error(`Input ${i} must be an array of int32 or int64`)})},zr=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(i=>r.push(Number(i)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(i=>r.push(Number(i)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},Jl=(e,t)=>{if(e.length>1){let r=zr(e,1),i=zr(e,2),o=zr(e,3);return o.length===0&&(o=[...Array(e[0].dims.length).keys()]),ae({starts:r,ends:i,axes:o})}else return t},ms=(e,t,r,i,o)=>{let s=e;return e<0&&(s+=r[i[t]]),o[t]<0?Math.max(0,Math.min(s,r[i[t]]-1)):Math.max(0,Math.min(s,r[i[t]]))},Zl=(e,t,r,i)=>`fn calculateInputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\n          var inputIndices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${r.length}; i >= 0; i--) {\n            var outputIndex = ${i.length===1?"outputIndices":"outputIndices[i]"};\n            var inputIndex = outputIndex * steps[i] + starts[i] + carry;\n            carry = inputIndex / inputShape[i];\n            inputIndex = inputIndex % inputShape[i];\n            if (signs[i] < 0) {\n              inputIndex = inputShape[i] - inputIndex - 1u + starts[i];\n            }\n            ${r.length===1?"inputIndices":"inputIndices[i]"} = inputIndex;\n          }\n          return inputIndices;\n      }`,ed=(e,t)=>{let r=e[0].dims,i=D.size(r),o=t.axes.length>0?D.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],s=zr(e,4);s.forEach(w=>w!==0||(()=>{throw new Error("step cannot be 0")})),s.length===0&&(s=Array(o.length).fill(1));let l=t.starts.map((w,v)=>ms(w,v,r,o,s)),n=t.ends.map((w,v)=>ms(w,v,r,o,s));if(o.length!==r.length)for(let w=0;w<r.length;++w)o.includes(w)||(l.splice(w,0,0),n.splice(w,0,r[w]),s.splice(w,0,1));let c=s.map(w=>Math.sign(w));s.forEach((w,v,I)=>{if(w<0){let B=(n[v]-l[v])/w,z=l[v],M=z+B*s[v];l[v]=M,n[v]=z,I[v]=-w}});let m=r.slice(0);o.forEach((w,v)=>{m[w]=Math.ceil((n[w]-l[w])/s[w])});let g={dims:m,dataType:e[0].dataType},C=se("output",e[0].dataType,m),x=K("input",e[0].dataType,r),$=D.size(m),b=w=>`\n      ${w.declareVariables(x,C)}\n        const signs = array<i32, ${c.length}>(${c.map(v=>`${v}i`).join(",")});\n        const starts = array<u32, ${l.length}>(${l.map(v=>`${v}u`).join(",")});\n        const ends = array<u32, ${n.length}>(${n.map(v=>`${v}u`).join(",")});\n        const steps = array<u32, ${s.length}>(${s.map(v=>`${v}u`).join(",")});\n        const inputShape = array<u32, ${r.length}>(${r.map(v=>`${v}u`).join(",")});\n\n        ${Zl(x,C,r,m)}\n        ${w.mainStart()}\n          ${w.guardAgainstOutOfBoundsWorkgroupSizes($)}\n          let outputIndices = ${C.offsetToIndices("global_idx")};\n          let inputIndices = calculateInputIndices(outputIndices);\n          ${C.setByOffset("global_idx",x.getByIndices("inputIndices"))}\n      }`;return{name:"Slice",shaderCache:{hint:`${t.cacheKey}|${e[4]?.dims??""}`},getShaderSource:b,getRunData:()=>({outputs:[g],dispatchGroup:{x:Math.ceil(i/64)}})}},hs=(e,t)=>{Ql(e.inputs,t);let r=Jl(e.inputs,t);e.compute(ed(e.inputs,r),{inputs:[0]})},gs=e=>{let t=e.starts,r=e.ends,i=e.axes;return ae({starts:t,ends:r,axes:i})}});var td,rd,bs,ws,vs=H(()=>{"use strict";me();_e();$e();td=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},rd=(e,t)=>{let r=Pe(e.dataType),i=e.dims,o=D.size(i),s=64,l=t.axis;if(l<0&&(l=i.length+l),l<i.length-1)throw new Error("softmax only supports last axis for now.");let n=i[l],c=o/n,m=r==="f32"?"var threadMax: f32 = -3.402823e+38f;":"var threadMax: f16 = -65504.0h;";return{name:"Softmax",getRunData:()=>({outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:c}}),getShaderSource:C=>`\n      var<workgroup> rowMaxShared : ${r};\n      var<workgroup> rowSumShared : ${r};\n      var<workgroup> threadShared : array<${r}, ${s}>;\n\n      @group(0) @binding(0) var<storage, read> x : array<${r}>;\n      @group(0) @binding(1) var<storage, read_write> result : array<${r}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${r} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${r}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n\n      @compute @workgroup_size(${s}, 1, 1)\n      fn main(@builtin(local_invocation_id) local_id : vec3<u32>, @builtin(global_invocation_id) global_id : vec3u) {\n        let gindex = i32(global_id.x);\n        let lindex = i32(local_id.x);\n        const wg = ${s};\n        let row = gindex / wg;\n        let cols = ${n};\n        let row_stride : i32 = ${n};\n\n        // find the rows max\n        ${m}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = threadShared[0];\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum: ${r} = 0.0;\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = threadShared[0];\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`}},bs=(e,t)=>{td(e.inputs),e.compute(rd(e.inputs[0],t))},ws=e=>ae({axis:e.axis})});var nd,od,ad,id,sd,$s,xs,Cs=H(()=>{"use strict";me();_e();$e();nd=e=>{if(!e||e.length<1)throw new Error("too few inputs")},od=(e,t)=>{let r=[],i=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(o=>r.push(Number(o))),i=r.length),ae({numOutputs:i,axis:t.axis,splitSizes:r})},ad=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < sizeInConcatAxis[i]) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,id=e=>{let t=e.length,r=[];for(let i=0;i<t;++i){let o=e[i].setByIndices("indices","input[global_idx]");t===1?r.push(o):i===0?r.push(`if (outputNumber == ${i}u) { ${o} }`):i===t-1?r.push(`else { ${o} }`):r.push(`else if (outputNumber == ${i}) { ${o} }`)}return`\n      fn writeBufferData(outputNumber: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${r.join(`\n`)}\n      }`},sd=(e,t)=>{let r=e[0].dims,i=D.size(r),o=e[0].dataType,s=r.length,l=t.axis,n=l<0?r.length+l:l,c=new Array(t.numOutputs),m=K("input",o,r),g=new Array(t.numOutputs),C=[],x=[],$=0;for(let v=0;v<t.numOutputs;v++){$+=t.splitSizes[v],g[v]=$;let I=r.slice();I[t.axis]=t.splitSizes[v],x.push(I),c[v]=se(`output${v}`,o,x[v]),C.push({dims:x[v],dataType:e[0].dataType})}let b=s<2?"indices":`indices[${n}]`,w=v=>`\n  ${v.declareVariables(m,...c)}\n  const sizeInConcatAxis = array<u32, ${g.length}>(${g.map(I=>`${I}u`).join(",")});\n  ${ad(g.length)}\n  ${id(c)}\n\n  ${v.mainStart()}\n    ${v.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n\n    var indices = ${m.offsetToIndices("global_idx")};\n    let outputNumber = calculateOutputIndex(${b});\n    if (outputNumber != 0) {\n        ${b} -= sizeInConcatAxis[outputNumber - 1u];\n    }\n    writeBufferData(outputNumber, indices, global_idx);\n  }`;return{name:"Split",shaderCache:{hint:t.cacheKey},getShaderSource:w,getRunData:()=>({outputs:C,dispatchGroup:{x:Math.ceil(i/64)}})}},$s=(e,t)=>{nd(e.inputs);let r=e.inputs.length===1?t:od(e.inputs,t);e.compute(sd(e.inputs,r),{inputs:[0]})},xs=e=>{let t=e.axis,r=e.splitSizes,i=e.numOutputs<0?r.length:e.numOutputs;if(i!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return ae({axis:t,numOutputs:i,splitSizes:r})}});var Ss,ud,ld,dd,As,Is=H(()=>{"use strict";ke();me();$e();Ss=e=>Array.from(e.getBigInt64Array(),Number),ud=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(Ss(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},ld=(e,t)=>{let r=[];for(let i=0;i<e.length;++i)r.push(e[i]*t[i]);return r},dd=e=>{let t=e[0].dims,r=Ss(e[1]),i=ld(t,r),o=D.size(i),s=e[0].dataType,l=K("input",s,t),n=se("output",s,i),c=m=>`\n      const inputShape = ${l.indices(...t)};\n      ${m.declareVariables(l,n)}\n      ${m.mainStart()}\n      ${m.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n      let outputIndices = ${n.offsetToIndices("global_idx")};\n      var inputIndices: ${l.type.indices};\n      for (var i = 0; i < ${t.length}; i++) {\n        let inputDimValue = ${n.indicesGet("outputIndices","i")}  % ${l.indicesGet("inputShape","i")};\n\n        ${l.indicesSet("inputIndices","i","inputDimValue")}\n      }\n      ${n.setByOffset("global_idx",l.getByIndices("inputIndices"))}\n    }`;return{name:"Tile",shaderCache:{hint:`${r}`},getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:c}},As=e=>{ud(e.inputs),e.compute(dd(e.inputs),{inputs:[0]})}});var cd,pd,Ts,Es=H(()=>{"use strict";ke();me();$e();cd=(e,t,r,i,o)=>{let s=D.size(r),l=Math.ceil(s/4),n=se("outputData",o,r,4),c=K("aData",t[1].dataType,t[1].dims,4),m=K("bData",t[2].dataType,t[2].dims,4),g=K("cData",t[0].dataType,t[0].dims,4),C,x=($,b,w)=>`select(${b}, ${$}, ${w})`;if(!i)C=n.setByOffset("global_idx",x(c.getByOffset("global_idx"),m.getByOffset("global_idx"),g.getByOffset("global_idx")));else{let $=(b,w,v="")=>{let I=`aData[indexA${w}][componentA${w}]`,B=`bData[indexB${w}][componentB${w}]`,z=`bool(cData[indexC${w}] & ${4278190080>>>(3-w)*8}u)`;return`\n            let outputIndices${w} = ${n.offsetToIndices(`global_idx * 4u + ${w}u`)};\n            let offsetA${w} = ${c.broadcastedIndicesToOffset(`outputIndices${w}`,n)};\n            let offsetB${w} = ${m.broadcastedIndicesToOffset(`outputIndices${w}`,n)};\n            let offsetC${w} = ${g.broadcastedIndicesToOffset(`outputIndices${w}`,n)};\n            let indexA${w} = offsetA${w} / 4u;\n            let indexB${w} = offsetB${w} / 4u;\n            let indexC${w} = offsetC${w} / 4u;\n            let componentA${w} = offsetA${w} % 4u;\n            let componentB${w} = offsetB${w} % 4u;\n            ${b}[${w}] = ${v}(${x(I,B,z)});\n          `};o===9?C=`\n            var data = vec4<u32>(0);\n            ${$("data",0,"u32")}\n            ${$("data",1,"u32")}\n            ${$("data",2,"u32")}\n            ${$("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:C=`\n            ${$("outputData[global_idx]",0)}\n            ${$("outputData[global_idx]",1)}\n            ${$("outputData[global_idx]",2)}\n            ${$("outputData[global_idx]",3)}\n          `}return`\n        ${e.declareVariables(g,c,m,n)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(l)}\n        ${C}\n      }`},pd=e=>{let t=e[1].dims,r=e[2].dims,i=e[0].dims,o=e[1].dataType,s=!(D.areEqual(t,r)&&D.areEqual(r,i)),l=t,n=D.size(t);if(s){let c=Ze.calcShape(Ze.calcShape(t,r,!1),i,!1);if(!c)throw new Error("Can\'t perform where op on the given tensors");l=c,n=D.size(l)}return{name:"Where",getShaderSource:c=>cd(c,e,l,s,o),getRunData:()=>({outputs:[{dims:l,dataType:o}],dispatchGroup:{x:Math.ceil(n/64/4)}})}},Ts=e=>{e.compute(pd(e.inputs))}});var Os,_s=H(()=>{"use strict";Go();No();va();Pa();Ma();vn();Ja();ri();ai();ui();ci();mi();bi();$i();Ci();Ii();Ni();ss();fn();ds();fs();ys();vs();Cs();Is();Mr();gn();Es();Os=new Map([["Abs",[Vo]],["Acos",[Fo]],["Acosh",[Ho]],["Add",[$a]],["ArgMax",[zo,mn]],["ArgMin",[Wo,mn]],["Asin",[Lo]],["Asinh",[jo]],["Atan",[Ko]],["Atanh",[qo]],["AveragePool",[Ri,Pi]],["BiasAdd",[Uo]],["BiasSplitGelu",[wa]],["Cast",[Xo,Yo]],["Ceil",[Jo]],["ClipV10",[hn]],["Clip",[Qo]],["Concat",[Ra,Ba]],["Conv",[La,Ha]],["ConvTranspose",[Qa,Xa]],["Cos",[Zo]],["Cosh",[ea]],["Div",[xa]],["Einsum",[ei,ti]],["Elu",[ta,Ar]],["Equal",[Ca]],["Erf",[ra]],["Exp",[na]],["Expand",[oi]],["Floor",[oa]],["Gather",[si,ii]],["GatherElements",[di,li]],["Gelu",[aa]],["Gemm",[pi,fi]],["GlobalAveragePool",[ki,Mi]],["GlobalMaxPool",[Ui,Gi]],["Greater",[Ta]],["GreaterOrEqual",[Oa]],["InstanceNormalization",[yi,gi]],["LayerNormalization",[vi,wi]],["LeakyRelu",[ia,Ar]],["Less",[Ea]],["LessOrEqual",[_a]],["Log",[ba]],["MatMul",[xi]],["MaxPool",[Wi,zi]],["Mul",[Sa]],["Neg",[ua]],["Not",[sa]],["Pad",[Si,Ai]],["Pow",[Aa]],["Range",[is]],["Reciprocal",[la]],["ReduceMin",[Po,je]],["ReduceMean",[_o,je]],["ReduceMax",[Oo,je]],["ReduceSum",[Bo,je]],["ReduceProd",[Ro,je]],["ReduceL1",[Io,je]],["ReduceL2",[To,je]],["ReduceLogSum",[Ao,je]],["ReduceLogSumExp",[Eo,je]],["ReduceSumSquare",[Mo,je]],["Relu",[da]],["Resize",[us,ls]],["Sigmoid",[ca]],["Sin",[pa]],["Sinh",[fa]],["Slice",[hs,gs]],["SkipLayerNormalization",[cs,ps]],["Split",[$s,xs]],["Sqrt",[ma]],["Softmax",[bs,ws]],["Sub",[Ia]],["Tan",[ha]],["Tanh",[ga]],["ThresholdedRelu",[ya,Ar]],["Tile",[As]],["Transpose",[Ua,Na]],["Where",[Ts]]])});var Gr,Ps=H(()=>{"use strict";ke();lt();$e();Gr=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,i,o,s,l,n){let c=this.backend.device,m=this.backend.getComputePassEncoder(),g=this.backend.supportTimestampQuery&&this.backend.env.webgpu.profilingMode==="default";g&&m.writeTimestamp(this.backend.profilingQuerySet,0),m.setPipeline(t.computePipeline);let C=[];for(let $ of o)C.push({binding:C.length,resource:{buffer:$.buffer}});for(let $ of s)C.push({binding:C.length,resource:{buffer:$.buffer}});n&&C.push({binding:C.length,resource:n});let x=c.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:C,label:t.programInfo.name});if(m.setBindGroup(0,x),m.dispatchWorkgroups(...l),this.backend.pendingDispatchNumber++,g){m.writeTimestamp(this.backend.profilingQuerySet,1),this.backend.profilingQueryData==null&&(this.backend.profilingQueryData=this.backend.gpuDataManager.create(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let $=this.backend.gpuDataManager.create(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.profilingQuerySet,0,2,this.backend.profilingQueryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.profilingQueryData.buffer,0,$.buffer,0,16),this.backend.flush();let b=this.backend.currentKernelId,w=this.backend.kernels.get(b),v=`[${w[0]}] ${w[1]}`;$.buffer.mapAsync(GPUMapMode.READ).then(()=>{let I=new BigUint64Array($.buffer.getMappedRange()),B=I[0],z=I[1];$.buffer.unmap(),typeof this.backend.profilingTimeBase>"u"&&(this.backend.profilingTimeBase=B);let M=Number(B-this.backend.profilingTimeBase),G=Number(z-this.backend.profilingTimeBase);if(!Number.isSafeInteger(M)||!Number.isSafeInteger(G))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release($.id);let _="";r.forEach((V,j)=>{_+=`input[${j}]: [${V.dims}] | ${Yt(V.dataType)}, `});let U="";i.forEach((V,j)=>{U+=`output[${j}]: [${V.dims}] | ${Yt(V.dataType)}, `}),console.log(`[profiling] kernel "${b}|${v}" ${_}${U}execution time: ${G-M} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(t,r){let i=this.backend.device,o=[];i.features.has("shader-f16")&&o.push("enable f16;");let s=So(r),l=t.getShaderSource(s),n=`${o.join(`\n`)}\n${s.additionalImplementations}\n${l}`,c=i.createShaderModule({code:n,label:t.name});Ie("verbose",()=>`[WebGPU] shader code: ${n}`);let m=i.createComputePipeline({compute:{module:c,entryPoint:"main"},layout:"auto",label:t.name});return{programInfo:t,computePipeline:m}}normalizeDispatchGroupSize(t){let r=typeof t=="number"?t:t.x,i=typeof t=="number"?1:t.y||1,o=typeof t=="number"?1:t.z||1,s=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=s&&i<=s&&o<=s)return[r,i,o];let l=r*i*o,n=Math.ceil(Math.sqrt(l));if(n>s){if(n=Math.ceil(Math.cbrt(l)),n>s)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[n,n,n]}else return[n,n,1]}}});var fd,md,Ur,Rs=H(()=>{"use strict";lt();yo();$o();_s();Ps();fd=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let i=0;i<e.length;++i){let o=e[i].dataType;switch(t[i]){case"none":{r.push("");break}case"type":{r.push(`${o}`);break}case"rank":{let s=e[i].dims.length;r.push(`${o};${s}`);break}case"dims":{let s=e[i].dims.join(",");r.push(`${o};${s}`);break}default:throw new Error(`unsupported input dependency: ${t[i]}`)}}return r.join("|")},md=(e,t)=>{let r=e.name;return e.shaderCache?.hint&&(r+="["+e.shaderCache.hint+"]"),r+=`:${fd(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,r},Ur=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispatchNumber=0;this.supportTimestampQuery=!1;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let r=await navigator.gpu.requestAdapter();if(!r)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=t;let i=[],o={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:i};r.features.has("timestamp-query-inside-passes")&&(this.supportTimestampQuery=!0,i.push("timestamp-query-inside-passes")),r.features.has("shader-f16")&&i.push("shader-f16"),this.device=await r.requestDevice(o),this.gpuDataManager=vo(this),this.programManager=new Gr(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,ho(t.logLevel,!!t.debug),this.device.onuncapturederror=s=>{s.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${s.error.message}`)},this.supportTimestampQuery&&(this.profilingQuerySet=this.device.createQuerySet({type:"timestamp",count:2})),Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){return this.computePassEncoder||(this.computePassEncoder=this.getCommandEncoder().beginComputePass()),this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}run(t,r,i,o,s){let l=[];for(let I=0;I<r.length;++I){let B=this.gpuDataManager.get(r[I].data);if(!B)throw new Error(`no GPU data for input: ${r[I].data}`);l[I]=B}let n=md(t,r),c=this.programManager.getArtifact(n),{outputs:m,dispatchGroup:g,programUniforms:C}=t.getRunData(r),x=i.length===0?m.map((I,B)=>B):i;if(x.length!==m.length)throw new Error(`Output size ${x.length} must be equal to ${m.length}.`);let $=[],b=[];for(let I=0;I<m.length;++I){if(!Number.isInteger(x[I])||x[I]<-3||x[I]>=m.length)throw new Error(`Invalid output index: ${x[I]}`);if(x[I]===-3)continue;let B=x[I]===-1,z=x[I]===-2,M=B||z?s(m[I].dataType,m[I].dims):o(x[I],m[I].dataType,m[I].dims),G=this.gpuDataManager.get(M.data);if(!G)throw new Error(`no GPU data for output: ${M.data}`);if(B&&this.temporaryData.push(G),z){let _=this.kernelPersistentData.get(this.currentKernelId);_||(_=[],this.kernelPersistentData.set(this.currentKernelId,_)),_.push(G)}$.push(M),b.push(G)}let w;if(C){let I=0,B=0,z=[],M=1;C.forEach(U=>{let V=typeof U.data=="number"?[U.data]:U.data,j;switch(V.length){case 1:j=4;break;case 2:j=8;break;case 3:j=16;break;case 4:j=16;break;case 5:j=16;break;case 6:j=16;break;default:throw new Error(`unsupported data length: ${V.length}`)}(B===5||B===6)&&(j=16),j>M&&(M=j),I=Math.ceil(I/j)*j,B=V.length,z.push(I),I+=V.length*4}),I=Math.ceil(I/M)*M;let G=new ArrayBuffer(I);C.forEach((U,V)=>{let j=z[V],le=typeof U.data=="number"?[U.data]:U.data;U.type==="int32"?new Int32Array(G,j,le.length).set(le):U.type==="uint32"?new Uint32Array(G,j,le.length).set(le):new Float32Array(G,j,le.length).set(le)});let _=this.gpuDataManager.create(I,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(_.buffer,0,G,0,I),this.gpuDataManager.release(_.id),w={offset:0,size:I,buffer:_.buffer}}let v=this.programManager.normalizeDispatchGroupSize(g);return c||(c=this.programManager.build(t,v),this.programManager.setArtifact(n,c)),Ie("info",()=>`[ProgramManager] run "${t.name}" (key=${n}) with ${v[0]}x${v[1]}x${v[2]}`),this.programManager.run(c,r,$,l,b,v,w),$}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,i,o){let s=Os.get(t);if(!s)throw new Error(`kernel not implemented: ${t}`);this.kernels.set(r,[t,o,s[0],[s[1],i]])}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let i of r)this.gpuDataManager.release(i.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,i){let o=this.kernels.get(t);if(!o)throw new Error(`kernel not created: ${t}`);let[s,l,n,c]=o;if(this.currentKernelId!==null)throw new Error(`kernel "[${s}] ${l}" is not allowed to be called recursively`);this.currentKernelId=t,c[0]&&(c[1]=c[0](c[1]),c[0]=void 0),Ie("info",()=>`[WebGPU] Start to run kernel "[${s}] ${l}"...`);let m=this.env.debug;this.temporaryData=[];try{return m&&this.device.pushErrorScope("validation"),n(r,c[1]),0}catch(g){return i.push(Promise.resolve(`[WebGPU] Kernel "[${s}] ${l}" failed. ${g}`)),1}finally{m&&i.push(this.device.popErrorScope().then(g=>g?`GPU validation error for kernel "[${s}] ${l}": ${g.message}`:null));for(let g of this.temporaryData)this.gpuDataManager.release(g.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,i,o){let s=this.sessionExternalDataMapping.get(t);s||(s=new Map,this.sessionExternalDataMapping.set(t,s));let l=s.get(r),n=this.gpuDataManager.registerExternalBuffer(i,o,l?.[1]);return s.set(r,[n,i]),n}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(i=>this.gpuDataManager.unregisterExternalBuffer(i[1])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,i){return async()=>{let o=await sn(this,t,r);return go(o.buffer,i)}}}});var Bs={};yr(Bs,{init:()=>hd});var rr,En,hd,Ms=H(()=>{"use strict";ke();Rs();lt();me();rr=class e{constructor(t,r,i,o){this.module=t;this.dataType=r;this.data=i;this.dims=o}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=D.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=D.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=D.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(D.size(t)!==D.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},En=class{constructor(t,r,i){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;let o=t.HEAPU32,s=i>>2;this.opKernelContext=o[s++];let l=o[s++];this.outputCount=o[s++],this.customDataOffset=o[s++],this.customDataSize=o[s++];let n=[];for(let c=0;c<l;c++){let m=o[s++],g=o[s++],C=o[s++],x=[];for(let $=0;$<C;$++)x.push(o[s++]);n.push(new rr(t,m,g,x))}this.inputs=n}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,r){let i=r?.inputs?.map(n=>typeof n=="number"?this.inputs[n]:n)??this.inputs,o=r?.outputs??[],s=(n,c,m)=>new rr(this.module,c,this.output(n,m),m),l=(n,c)=>{let m=Xt(n);if(!m)throw new Error(`Unsupported data type: ${n}`);let g=m*D.size(c);return new rr(this.module,n,this.backend.gpuDataManager.create(g).id,c)};return this.backend.run(t,i,o,s,l)}output(t,r){let i=this.module.stackSave();try{let o=this.module.stackAlloc((1+r.length)*4),s=o>>2;this.module.HEAPU32[s++]=r.length;for(let l=0;l<r.length;l++)this.module.HEAPU32[s++]=r[l];return this.module._JsepOutput(this.opKernelContext,t,o)}catch(o){throw new Error(`Failed to generate kernel\'s output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${o}`)}finally{this.module.stackRestore(i)}}},hd=async(e,t)=>{let r=e.jsepInit;if(r&&navigator.gpu){if(!t.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let i=new Ur;await i.initialize(t),r(i,o=>i.alloc(o),o=>i.free(o),(o,s,l,n=!1)=>{if(n)Ie("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${o}, dst=${s}, size=${l}`),i.memcpy(o,s);else{Ie("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${o}, gpuDataId=${s}, size=${l}`);let c=e.HEAPU8.subarray(o,o+l);i.upload(s,c)}},async(o,s,l)=>{Ie("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${o}, dataOffset=${s}, size=${l}`),await i.download(o,()=>e.HEAPU8.subarray(s,s+l))},(o,s,l)=>i.createKernel(o,s,l,t.debug||t.webgpu.profilingMode==="default"?e.UTF8ToString(e._JsepGetNodeName(s)):`${s}`),o=>i.releaseKernel(o),(o,s,l,n)=>{Ie("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${l}, kernel=${o}, contextDataOffset=${s}`);let c=new En(e,i,s);return i.computeKernel(o,c,n)})}}});var so;so=Qn();var lu=oo(),tn,rn=!1,br=!1,io=!1,du=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},cu=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},pu=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",uo=async e=>{if(rn)return Promise.resolve();if(br)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(io)throw new Error("previous call to \'initializeWebAssembly()\' failed.");br=!0;let t=e.initTimeout,r=e.numThreads,i=e.simd,o=r>1&&du(),s=i&&cu(),l=e.wasmPaths,n=typeof l=="string"?l:void 0,c=pu(s,o),m=typeof l=="object"?l[c]:void 0,g=!1,C=[];if(t>0&&C.push(new Promise(x=>{setTimeout(()=>{g=!0,x()},t)})),C.push(new Promise((x,$)=>{let b=o?lu:so,w={locateFile:(v,I)=>{if(o&&v.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([ao()],{type:"text/javascript"}));if(v.endsWith(".wasm")){if(m)return m;let B=n??I;return c==="ort-wasm-simd.wasm"?B+"ort-wasm-simd.jsep.wasm":c==="ort-wasm-simd-threaded.wasm"?B+"ort-wasm-simd-threaded.jsep.wasm":B+c}return I+v}};if(o)if(typeof Blob>"u")w.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let v=`var ortWasmThreaded=${b.toString()};`;w.mainScriptUrlOrBlob=new Blob([v],{type:"text/javascript"})}b(w).then(v=>{br=!1,rn=!0,tn=v,x()},v=>{br=!1,io=!0,$(v)})})),await Promise.race(C),g)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Ee=()=>{if(rn&&tn)return tn;throw new Error("WebAssembly is not initialized yet.")};var Oe=(e,t)=>{let r=Ee(),i=r.lengthBytesUTF8(e)+1,o=r._malloc(i);return r.stringToUTF8(e,o,i),t.push(o),o},qt=(e,t,r,i)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([o,s])=>{let l=t?t+o:o;if(typeof s=="object")qt(s,l+".",r,i);else if(typeof s=="string"||typeof s=="number")i(l,s.toString());else if(typeof s=="boolean")i(l,s?"1":"0");else throw new Error(`Can\'t handle extra config type: ${typeof s}`)})},Ce=e=>{let t=Ee(),r=t.stackSave();try{let i=t.stackAlloc(8);t._OrtGetLastError(i,i+4);let o=t.HEAP32[i/4],s=t.HEAPU32[i/4+1],l=s?t.UTF8ToString(s):"";throw new Error(`${e} ERROR_CODE: ${o}, ERROR_MESSAGE: ${l}`)}finally{t.stackRestore(r)}};var lo=e=>{let t=Ee(),r=0,i=[],o=e||{};try{if(e?.logSeverityLevel===void 0)o.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)o.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(o.terminate=!1);let s=0;return e?.tag!==void 0&&(s=Oe(e.tag,i)),r=t._OrtCreateRunOptions(o.logSeverityLevel,o.logVerbosityLevel,!!o.terminate,s),r===0&&Ce("Can\'t create run options."),e?.extra!==void 0&&qt(e.extra,"",new WeakSet,(l,n)=>{let c=Oe(l,i),m=Oe(n,i);t._OrtAddRunConfigEntry(r,c,m)!==0&&Ce(`Can\'t set a run config entry: ${l} - ${n}.`)}),[r,i]}catch(s){throw r!==0&&t._OrtReleaseRunOptions(r),i.forEach(l=>t._free(l)),s}};var fu=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},mu=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},hu=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},gu=(e,t,r)=>{for(let i of t){let o=typeof i=="string"?i:i.name;switch(o){case"xnnpack":o="XNNPACK";break;case"webnn":if(o="WEBNN",typeof i!="string"){let l=i;if(l?.deviceType){let n=Oe("deviceType",r),c=Oe(l.deviceType,r);Ee()._OrtAddSessionConfigEntry(e,n,c)!==0&&Ce(`Can\'t set a session config entry: \'deviceType\' - ${l.deviceType}.`)}if(l?.numThreads){let n=l.numThreads;(typeof n!="number"||!Number.isInteger(n)||n<0)&&(n=0);let c=Oe("numThreads",r),m=Oe(n.toString(),r);Ee()._OrtAddSessionConfigEntry(e,c,m)!==0&&Ce(`Can\'t set a session config entry: \'numThreads\' - ${l.numThreads}.`)}if(l?.powerPreference){let n=Oe("powerPreference",r),c=Oe(l.powerPreference,r);Ee()._OrtAddSessionConfigEntry(e,n,c)!==0&&Ce(`Can\'t set a session config entry: \'powerPreference\' - ${l.powerPreference}.`)}}break;case"webgpu":if(o="JS",typeof i!="string"){let l=i;if(l?.preferredLayout){if(l.preferredLayout!=="NCHW"&&l.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${l.preferredLayout}`);let n=Oe("preferredLayout",r),c=Oe(l.preferredLayout,r);Ee()._OrtAddSessionConfigEntry(e,n,c)!==0&&Ce(`Can\'t set a session config entry: \'preferredLayout\' - ${l.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${o}`)}let s=Oe(o,r);Ee()._OrtAppendExecutionProvider(e,s)!==0&&Ce(`Can\'t append execution provider: ${o}.`)}},co=e=>{let t=Ee(),r=0,i=[],o=e||{};hu(o);try{let s=fu(o.graphOptimizationLevel??"all"),l=mu(o.executionMode??"sequential"),n=typeof o.logId=="string"?Oe(o.logId,i):0,c=o.logSeverityLevel??2;if(!Number.isInteger(c)||c<0||c>4)throw new Error(`log serverity level is not valid: ${c}`);let m=o.logVerbosityLevel??0;if(!Number.isInteger(m)||m<0||m>4)throw new Error(`log verbosity level is not valid: ${m}`);let g=typeof o.optimizedModelFilePath=="string"?Oe(o.optimizedModelFilePath,i):0;if(r=t._OrtCreateSessionOptions(s,!!o.enableCpuMemArena,!!o.enableMemPattern,l,!!o.enableProfiling,0,n,c,m,g),r===0&&Ce("Can\'t create session options."),o.executionProviders&&gu(r,o.executionProviders,i),o.freeDimensionOverrides)for(let[C,x]of Object.entries(o.freeDimensionOverrides)){if(typeof C!="string")throw new Error(`free dimension override name must be a string: ${C}`);if(typeof x!="number"||!Number.isInteger(x)||x<0)throw new Error(`free dimension override value must be a non-negative integer: ${x}`);let $=Oe(C,i);t._OrtAddFreeDimensionOverride(r,$,x)!==0&&Ce(`Can\'t set a free dimension override: ${C} - ${x}.`)}return o.extra!==void 0&&qt(o.extra,"",new WeakSet,(C,x)=>{let $=Oe(C,i),b=Oe(x,i);t._OrtAddSessionConfigEntry(r,$,b)!==0&&Ce(`Can\'t set a session config entry: ${C} - ${x}.`)}),[r,i]}catch(s){throw r!==0&&t._OrtReleaseSessionOptions(r),i.forEach(l=>t._free(l)),s}};ke();var gd=e=>{let t=Ee(),r=t.stackSave();try{let i=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,i,i+4)!==0&&Ce("Can\'t get session input/output count."),[t.HEAP32[i/4],t.HEAP32[i/4+1]]}finally{t.stackRestore(r)}},yd=(e,t)=>{Ee()._OrtInit(e,t)!==0&&Ce("Can\'t initialize onnxruntime.")},Ds=async e=>{yd(e.wasm.numThreads,Qt(e.logLevel));{let t=(Ms(),Tt(Bs)).init;await t(Ee(),e)}},nr=new Map,On=e=>{let t=Ee(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},_n=(e,t)=>{let r=Ee(),i=0,o=0,s=0,l=[],n=[],c=[];try{[o,l]=co(t),i=r._OrtCreateSession(e[0],e[1],o),i===0&&Ce("Can\'t create a session.");let[m,g]=gd(i),C=[],x=[],$=[];for(let w=0;w<m;w++){let v=r._OrtGetInputName(i,w);v===0&&Ce("Can\'t get an input name."),n.push(v),C.push(r.UTF8ToString(v))}for(let w=0;w<g;w++){let v=r._OrtGetOutputName(i,w);v===0&&Ce("Can\'t get an output name."),c.push(v);let I=r.UTF8ToString(v);x.push(I);{let B=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[I]??"cpu";if(B!=="cpu"&&B!=="cpu-pinned"&&B!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${B}.`);$.push(B)}}let b=null;return $.some(w=>w==="gpu-buffer")&&(s=r._OrtCreateBinding(i),s===0&&Ce("Can\'t create IO binding."),b={handle:s,outputPreferredLocations:$,outputPreferredLocationsEncoded:$.map(w=>on(w))}),nr.set(i,[i,n,c,b]),[i,C,x]}catch(m){throw n.forEach(g=>r._OrtFree(g)),c.forEach(g=>r._OrtFree(g)),s!==0&&r._OrtReleaseBinding(s),i!==0&&r._OrtReleaseSession(i),m}finally{r._free(e[0]),o!==0&&r._OrtReleaseSessionOptions(o),l.forEach(m=>r._free(m))}},Ws=(e,t)=>{let r=On(e);return _n(r,t)},zs=e=>{let t=Ee(),r=nr.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[i,o,s,l]=r;l&&t._OrtReleaseBinding(l.handle),t.jsepUnregisterBuffers?.(e),o.forEach(n=>t._OrtFree(n)),s.forEach(n=>t._OrtFree(n)),t._OrtReleaseSession(i),nr.delete(e)},ks=(e,t,r,i,o)=>{if(!e){t.push(0);return}let s=Ee(),l=e[0],n=e[1],c=e[3],m,g;if(l==="string"&&c==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(c==="gpu-buffer"){let $=e[2].gpuBuffer,b=Xt(nn(l));g=n.reduce((w,v)=>w*v,1)*b,m=s.jsepRegisterBuffer(i,o,$,g)}else{let $=e[2];if(Array.isArray($)){g=4*$.length,m=s._malloc(g),r.push(m);let b=m/4;for(let w=0;w<$.length;w++){if(typeof $[w]!="string")throw new TypeError(`tensor data at index ${w} is not a string`);s.HEAPU32[b++]=Oe($[w],r)}}else g=$.byteLength,m=s._malloc(g),r.push(m),s.HEAPU8.set(new Uint8Array($.buffer,$.byteOffset,g),m)}let C=s.stackSave(),x=s.stackAlloc(4*n.length);try{let $=x/4;n.forEach(w=>s.HEAP32[$++]=w);let b=s._OrtCreateTensor(nn(l),m,g,x,n.length,on(c));b===0&&Ce(`Can\'t create tensor for input/output. session=${i}, index=${o}.`),t.push(b)}finally{s.stackRestore(C)}},Gs=async(e,t,r,i,o,s)=>{let l=Ee(),n=nr.get(e);if(!n)throw new Error(`cannot run inference. invalid session id: ${e}`);let[c,m,g,C]=n,x=t.length,$=i.length,b=0,w=[],v=[],I=[],B=[],z=l.stackSave(),M=l.stackAlloc(x*4),G=l.stackAlloc(x*4),_=l.stackAlloc($*4),U=l.stackAlloc($*4);try{[b,w]=lo(s);for(let q=0;q<x;q++)ks(r[q],v,B,e,t[q]);for(let q=0;q<$;q++)ks(o[q],I,B,e,x+i[q]);let V=M/4,j=G/4,le=_/4,R=U/4;for(let q=0;q<x;q++)l.HEAPU32[V++]=v[q],l.HEAPU32[j++]=m[t[q]];for(let q=0;q<$;q++)l.HEAPU32[le++]=I[q],l.HEAPU32[R++]=g[i[q]];if(C){let{handle:q,outputPreferredLocations:L,outputPreferredLocationsEncoded:De}=C;if(m.length!==x)throw new Error(`input count from feeds (${x}) is expected to be always equal to model\'s input count (${m.length}).`);for(let he=0;he<x;he++){let Re=t[he];await l._OrtBindInput(q,m[Re],v[he])!==0&&Ce(`Can\'t bind input[${he}] for session=${e}.`)}for(let he=0;he<$;he++){let Re=i[he];o[he]?.[3]?l._OrtBindOutput(q,g[Re],I[he],0)!==0&&Ce(`Can\'t bind pre-allocated output[${he}] for session=${e}.`):l._OrtBindOutput(q,g[Re],0,De[Re])!==0&&Ce(`Can\'t bind output[${he}] to ${L[he]} for session=${e}.`)}}let X;C?X=await l._OrtRunWithBinding(c,C.handle,$,_,b):X=await l._OrtRun(c,G,M,x,U,$,_,b),X!==0&&Ce("failed to call OrtRun().");let Se=[];for(let q=0;q<$;q++){let L=l.HEAPU32[_/4+q];if(L===I[q]){Se.push(o[q]);continue}let De=l.stackSave(),he=l.stackAlloc(4*4),Re=!1,we,Be=0;try{l._OrtGetTensorData(L,he,he+4,he+8,he+12)!==0&&Ce(`Can\'t access output tensor data on index ${q}.`);let We=he/4,nt=l.HEAPU32[We++];Be=l.HEAPU32[We++];let N=l.HEAPU32[We++],de=l.HEAPU32[We++],ge=[];for(let Te=0;Te<de;Te++)ge.push(l.HEAPU32[N/4+Te]);l._OrtFree(N);let ze=ge.reduce((Te,Ae)=>Te*Ae,1);we=Yt(nt);let Ge=C?.outputPreferredLocations[i[q]];if(we==="string"){if(Ge==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Te=[],Ae=Be/4;for(let Ue=0;Ue<ze;Ue++){let qe=l.HEAPU32[Ae++],Ve=Ue===ze-1?void 0:l.HEAPU32[Ae]-qe;Te.push(l.UTF8ToString(qe,Ve))}Se.push([we,ge,Te,"cpu"])}else if(Ge==="gpu-buffer"&&ze>0){let Te=l.jsepGetBuffer(Be),Ae=Xt(nt);if(Ae===void 0||!po(we))throw new Error(`Unsupported data type: ${we}`);Re=!0,Se.push([we,ge,{gpuBuffer:Te,download:l.jsepCreateDownloader(Te,ze*Ae,we),dispose:()=>{l._OrtReleaseTensor(L)}},"gpu-buffer"])}else{let Te=wr(we),Ae=new Te(ze);new Uint8Array(Ae.buffer,Ae.byteOffset,Ae.byteLength).set(l.HEAPU8.subarray(Be,Be+Ae.byteLength)),Se.push([we,ge,Ae,"cpu"])}}finally{l.stackRestore(De),we==="string"&&Be&&l._free(Be),Re||l._OrtReleaseTensor(L)}}return C&&l._OrtClearBoundOutputs(C.handle),Se}finally{l.stackRestore(z),v.forEach(V=>l._OrtReleaseTensor(V)),I.forEach(V=>l._OrtReleaseTensor(V)),B.forEach(V=>l._free(V)),b!==0&&l._OrtReleaseRunOptions(b),w.forEach(V=>l._free(V))}},Us=e=>{let t=Ee(),r=nr.get(e);if(!r)throw new Error("invalid session id");let i=r[0],o=t._OrtEndProfiling(i);o===0&&Ce("Can\'t get an profile file name."),t._OrtFree(o)},Ns=e=>{let t=[];for(let r of e){let i=r[2];!Array.isArray(i)&&"buffer"in i&&t.push(i.buffer)}return t};self.onmessage=e=>{switch(e.data.type){case"init-wasm":try{uo(e.data.in).then(()=>postMessage({type:"init-wasm"}),t=>postMessage({type:"init-wasm",err:t}))}catch(t){postMessage({type:"init-wasm",err:t})}break;case"init-ort":try{Ds(e.data.in).then(()=>postMessage({type:"init-ort"}),t=>postMessage({type:"init-ort",err:t}))}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{let{model:t}=e.data.in,r=On(t);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{let{modeldata:t,options:r}=e.data.in,i=_n(t,r);postMessage({type:"create_finalize",out:i})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{let{model:t,options:r}=e.data.in,i=Ws(t,r);postMessage({type:"create",out:i})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{let t=e.data.in;zs(t),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{let{sessionId:t,inputIndices:r,inputs:i,outputIndices:o,options:s}=e.data.in;Gs(t,r,i,o,s).then(l=>{postMessage({type:"run",out:l},Ns(l))},l=>{postMessage({type:"run",err:l})})}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{let t=e.data.in;Us(t),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}break;default:}};})();\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n'});var mt,He,on,ua,la,ea,ta,ra,na,aa,oa,ia,sa,Et,Ac,an,Mu,Du,zu,Wu,da,Nu,Uu,Gu,ca=H(()=>{"use strict";At();Pu();Wt();mt=()=>!!Ae.wasm.proxy&&typeof document<"u",on=!1,ua=!1,la=!1,ra=[],na=[],aa=[],oa=[],ia=[],sa=[],Et=()=>{if(on||!ua||la||!He)throw new Error("worker not ready")},Ac=e=>{switch(e.data.type){case"init-wasm":on=!1,e.data.err?(la=!0,ea[1](e.data.err)):(ua=!0,ea[0]());break;case"init-ort":e.data.err?ta[1](e.data.err):ta[0]();break;case"create_allocate":e.data.err?ra.shift()[1](e.data.err):ra.shift()[0](e.data.out);break;case"create_finalize":e.data.err?na.shift()[1](e.data.err):na.shift()[0](e.data.out);break;case"create":e.data.err?aa.shift()[1](e.data.err):aa.shift()[0](e.data.out);break;case"release":e.data.err?oa.shift()[1](e.data.err):oa.shift()[0]();break;case"run":e.data.err?ia.shift()[1](e.data.err):ia.shift()[0](e.data.out);break;case"end-profiling":e.data.err?sa.shift()[1](e.data.err):sa.shift()[0]();break;default:}},an=typeof document<"u"?document?.currentScript?.src:void 0,Mu=async()=>{if(mt()){if(ua)return;if(on)throw new Error("multiple calls to 'initWasm()' detected.");if(la)throw new Error("previous call to 'initWasm()' failed.");return on=!0,Ae.wasm.wasmPaths===void 0&&an&&an.indexOf("blob:")!==0&&(Ae.wasm.wasmPaths=an.substr(0,+an.lastIndexOf("/")+1)),new Promise((e,t)=>{He?.terminate();let r=URL.createObjectURL(new Blob([Bu()],{type:"text/javascript"}));He=new Worker(r,{name:"ort-wasm-proxy-worker"}),He.onerror=a=>t(a),He.onmessage=Ac,URL.revokeObjectURL(r),ea=[e,t];let o={type:"init-wasm",in:Ae.wasm};He.postMessage(o)})}else return yo(Ae.wasm)},Du=async e=>{if(mt())return Et(),new Promise((t,r)=>{ta=[t,r];let o={type:"init-ort",in:e};He.postMessage(o)});await _u(e)},zu=async e=>mt()?(Et(),new Promise((t,r)=>{ra.push([t,r]);let o={type:"create_allocate",in:{model:e}};He.postMessage(o,[e.buffer])})):Jn(e),Wu=async(e,t)=>mt()?(Et(),new Promise((r,o)=>{na.push([r,o]);let a={type:"create_finalize",in:{modeldata:e,options:t}};He.postMessage(a)})):Zn(e,t),da=async(e,t)=>{if(mt()){if(t?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Et(),new Promise((r,o)=>{aa.push([r,o]);let a={type:"create",in:{model:e,options:t}};He.postMessage(a,[e.buffer])})}else return Eu(e,t)},Nu=async e=>{if(mt())return Et(),new Promise((t,r)=>{oa.push([t,r]);let o={type:"release",in:e};He.postMessage(o)});Ou(e)},Uu=async(e,t,r,o,a,s)=>{if(mt()){if(r.some(u=>u[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(a.some(u=>u))throw new Error("pre-allocated output tensor is not supported for proxy.");return Et(),new Promise((u,n)=>{ia.push([u,n]);let d=r,p={type:"run",in:{sessionId:e,inputIndices:t,inputs:d,outputIndices:o,options:s}};He.postMessage(p,ku(d))})}else return Tu(e,t,r,o,a,s)},Gu=async e=>{if(mt())return Et(),new Promise((t,r)=>{sa.push([t,r]);let o={type:"end-profiling",in:e};He.postMessage(o)});Ru(e)}});var Fu,sn,Hu,_c,un,Lu=H(()=>{"use strict";At();ca();Me();Hu=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},_c=e=>{switch(e[3]){case"cpu":return new dt(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!zr(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:r,download:o,dispose:a}=e[2];return dt.fromGpuBuffer(r,{dataType:t,dims:e[1],download:o,dispose:a})}default:throw new Error(`invalid data location: ${e[3]}`)}},un=class{async createSessionAllocate(t){let r=await fetch(t);if(r.status!==200)throw new Error(`failed to load model: ${t}`);let o=await r.arrayBuffer();return zu(new Uint8Array(o))}async loadModel(t,r){if(Fu||(sn||(sn=Du(Ae)),await sn,sn=void 0,Fu=!0),typeof t=="string")if(typeof process<"u"&&process.versions&&process.versions.node){let o=await(void 0)(t);[this.sessionId,this.inputNames,this.outputNames]=await da(o,r)}else{let o=await this.createSessionAllocate(t);[this.sessionId,this.inputNames,this.outputNames]=await Wu(o,r)}else[this.sessionId,this.inputNames,this.outputNames]=await da(t,r)}async dispose(){return Nu(this.sessionId)}async run(t,r,o){let a=[],s=[];Object.entries(t).forEach(b=>{let w=b[0],$=b[1],v=this.inputNames.indexOf(w);if(v===-1)throw new Error(`invalid input '${w}'`);a.push($),s.push(v)});let u=[],n=[];Object.entries(r).forEach(b=>{let w=b[0],$=b[1],v=this.outputNames.indexOf(w);if(v===-1)throw new Error(`invalid output '${w}'`);u.push($),n.push(v)});let d=a.map((b,w)=>Hu(b,()=>`input "${this.inputNames[s[w]]}"`)),p=u.map((b,w)=>b?Hu(b,()=>`output "${this.outputNames[n[w]]}"`):null),h=await Uu(this.sessionId,s,d,n,p,o),y={};for(let b=0;b<h.length;b++)y[this.outputNames[n[b]]]=u[b]??_c(h[b]);return y}startProfiling(){}endProfiling(){Gu(this.sessionId)}}});var Ec,ln,Vu=H(()=>{"use strict";At();ca();Lu();Ec=()=>{if((typeof Ae.wasm.initTimeout!="number"||Ae.wasm.initTimeout<0)&&(Ae.wasm.initTimeout=0),typeof Ae.wasm.simd!="boolean"&&(Ae.wasm.simd=!0),typeof Ae.wasm.proxy!="boolean"&&(Ae.wasm.proxy=!1),typeof Ae.wasm.numThreads!="number"||!Number.isInteger(Ae.wasm.numThreads)||Ae.wasm.numThreads<=0){let e=typeof navigator>"u"?(void 0)().length:navigator.hardwareConcurrency;Ae.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},ln=class{async init(){Ec(),await Mu()}async createInferenceSessionHandler(t,r){let o=new un;return await o.loadModel(t,r),Promise.resolve(o)}}});var ju={};ar(ju,{wasmBackend:()=>Oc});var Oc,qu=H(()=>{"use strict";Vu();Oc=new ln});At();At();var ro="1.17.0";{let e=(qu(),St(ju)).wasmBackend;typeof navigator<"u"&&navigator.gpu&&It("webgpu",e,5),It("cpu",e,10),It("wasm",e,10),It("xnnpack",e,9),It("webnn",e,9)}Object.defineProperty(Ae.versions,"web",{value:ro,enumerable:!0});export{rp as InferenceSession,dt as Tensor,ip as TrainingSession,Ae as env,It as registerBackend};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
//# sourceMappingURL=ort.webgpu.min.js.map
