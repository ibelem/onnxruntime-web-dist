/*!
 * ONNX Runtime Web v1.19.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
"use strict";var pt=Object.create;var Q=Object.defineProperty;var mt=Object.getOwnPropertyDescriptor;var gt=Object.getOwnPropertyNames;var yt=Object.getPrototypeOf,bt=Object.prototype.hasOwnProperty;var x=(e,t)=>()=>(e&&(t=e(e=0)),t);var xe=(e,t)=>{for(var r in t)Q(e,r,{get:t[r],enumerable:!0})},K=(e,t,r,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of gt(t))!bt.call(e,n)&&n!==r&&Q(e,n,{get:()=>t[n],enumerable:!(s=mt(t,n))||s.enumerable});return e},U=(e,t,r)=>(K(e,t,"default"),r&&K(r,t,"default")),wt=(e,t,r)=>(r=e!=null?pt(yt(e)):{},K(t||!e||!e.__esModule?Q(r,"default",{value:e,enumerable:!0}):r,e)),Ie=e=>K(Q({},"__esModule",{value:!0}),e);var _,Z=x(()=>{"use strict";_=!!(typeof process<"u"&&process.versions&&process.versions.node)});var D,ht,St,Et,Ot,vt,At,Le,ee=x(()=>{"use strict";Z();D=_?void 0:typeof document<"u"?document.currentScript?.src:typeof self<"u"?self.location?.href:void 0,ht=_||typeof location>"u"?void 0:location.origin,St=(e,t)=>{try{let r=t??D;return(r?new URL(e,r):new URL(e)).origin===ht}catch{return!1}},Et=(e,t)=>{let r=t??D;try{return(r?new URL(e,r):new URL(e)).href}catch{return}},Ot=(e,t)=>`${t??"./"}${e}`,vt=async e=>{let r=await(await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(r)},At=async e=>(await import(/*webpackIgnore:true*/e)).default,Le=async(e,t,r)=>{let s="ort-wasm-simd-threaded.mjs",n=e??Et(s,t),a=!_&&r&&n&&!St(n,t),o=a?await vt(n):n??Ot(s,t);return[a?o:void 0,await At(o)]}});var ue,ce,te,ke,Pt,xt,Ce,h,R=x(()=>{"use strict";ee();ce=!1,te=!1,ke=!1,Pt=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},xt=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Ce=async e=>{if(ce)return Promise.resolve();if(te)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(ke)throw new Error("previous call to 'initializeWebAssembly()' failed.");te=!0;let t=e.initTimeout,r=e.numThreads;if(!xt())throw new Error("WebAssembly SIMD is not supported in the current environment.");let s=Pt();r>1&&!s&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+r+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=r=1);let n=e.wasmPaths,a=typeof n=="string"?n:void 0,o=n?.mjs,c=o?.href??o,u=n?.wasm,d=u?.href??u,[p,f]=await Le(c,a,r>1),i=!1,y=[];if(t>0&&y.push(new Promise(l=>{setTimeout(()=>{i=!0,l()},t)})),y.push(new Promise((l,g)=>{f({numThreads:r,locateFile:(I,S)=>d??(a??S)+I}).then(I=>{te=!1,ce=!0,ue=I,l(),p&&URL.revokeObjectURL(p)},I=>{te=!1,ke=!0,g(I)})})),await Promise.race(y),i)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},h=()=>{if(ce&&ue)return ue;throw new Error("WebAssembly is not initialized yet.")}});var b,G,w,re=x(()=>{"use strict";R();b=(e,t)=>{let r=h(),s=r.lengthBytesUTF8(e)+1,n=r._malloc(s);return r.stringToUTF8(e,n,s),t.push(n),n},G=(e,t,r,s)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([n,a])=>{let o=t?t+n:n;if(typeof a=="object")G(a,o+".",r,s);else if(typeof a=="string"||typeof a=="number")s(o,a.toString());else if(typeof a=="boolean")s(o,a?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof a}`)})},w=e=>{let t=h(),r=t.stackSave();try{let s=t.stackAlloc(8);t._OrtGetLastError(s,s+4);let n=t.HEAP32[s/4],a=t.HEAPU32[s/4+1],o=a?t.UTF8ToString(a):"";throw new Error(`${e} ERROR_CODE: ${n}, ERROR_MESSAGE: ${o}`)}finally{t.stackRestore(r)}}});var Ue,Be=x(()=>{"use strict";R();re();Ue=e=>{let t=h(),r=0,s=[],n=e||{};try{if(e?.logSeverityLevel===void 0)n.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)n.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(n.terminate=!1);let a=0;return e?.tag!==void 0&&(a=b(e.tag,s)),r=t._OrtCreateRunOptions(n.logSeverityLevel,n.logVerbosityLevel,!!n.terminate,a),r===0&&w("Can't create run options."),e?.extra!==void 0&&G(e.extra,"",new WeakSet,(o,c)=>{let u=b(o,s),d=b(c,s);t._OrtAddRunConfigEntry(r,u,d)!==0&&w(`Can't set a run config entry: ${o} - ${c}.`)}),[r,s]}catch(a){throw r!==0&&t._OrtReleaseRunOptions(r),s.forEach(o=>t._free(o)),a}}});var It,Tt,Lt,kt,_e,Me=x(()=>{"use strict";R();re();It=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},Tt=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Lt=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},kt=(e,t,r)=>{for(let s of t){let n=typeof s=="string"?s:s.name;switch(n){case"webnn":if(n="WEBNN",typeof s!="string"){let o=s,c=o?.deviceType,u=o?.numThreads,d=o?.powerPreference;if(c){let p=b("deviceType",r),f=b(c,r);h()._OrtAddSessionConfigEntry(e,p,f)!==0&&w(`Can't set a session config entry: 'deviceType' - ${c}.`)}if(u!==void 0){let p=typeof u!="number"||!Number.isInteger(u)||u<0?0:u,f=b("numThreads",r),i=b(p.toString(),r);h()._OrtAddSessionConfigEntry(e,f,i)!==0&&w(`Can't set a session config entry: 'numThreads' - ${u}.`)}if(d){let p=b("powerPreference",r),f=b(d,r);h()._OrtAddSessionConfigEntry(e,p,f)!==0&&w(`Can't set a session config entry: 'powerPreference' - ${d}.`)}}break;case"webgpu":if(n="JS",typeof s!="string"){let o=s;if(o?.preferredLayout){if(o.preferredLayout!=="NCHW"&&o.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${o.preferredLayout}`);let c=b("preferredLayout",r),u=b(o.preferredLayout,r);h()._OrtAddSessionConfigEntry(e,c,u)!==0&&w(`Can't set a session config entry: 'preferredLayout' - ${o.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${n}`)}let a=b(n,r);h()._OrtAppendExecutionProvider(e,a)!==0&&w(`Can't append execution provider: ${n}.`)}},_e=e=>{let t=h(),r=0,s=[],n=e||{};Lt(n);try{let a=It(n.graphOptimizationLevel??"all"),o=Tt(n.executionMode??"sequential"),c=typeof n.logId=="string"?b(n.logId,s):0,u=n.logSeverityLevel??2;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log serverity level is not valid: ${u}`);let d=n.logVerbosityLevel??0;if(!Number.isInteger(d)||d<0||d>4)throw new Error(`log verbosity level is not valid: ${d}`);let p=typeof n.optimizedModelFilePath=="string"?b(n.optimizedModelFilePath,s):0;if(r=t._OrtCreateSessionOptions(a,!!n.enableCpuMemArena,!!n.enableMemPattern,o,!!n.enableProfiling,0,c,u,d,p),r===0&&w("Can't create session options."),n.executionProviders&&kt(r,n.executionProviders,s),n.enableGraphCapture!==void 0){if(typeof n.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${n.enableGraphCapture}`);let f=b("enableGraphCapture",s),i=b(n.enableGraphCapture.toString(),s);t._OrtAddSessionConfigEntry(r,f,i)!==0&&w(`Can't set a session config entry: 'enableGraphCapture' - ${n.enableGraphCapture}.`)}if(n.freeDimensionOverrides)for(let[f,i]of Object.entries(n.freeDimensionOverrides)){if(typeof f!="string")throw new Error(`free dimension override name must be a string: ${f}`);if(typeof i!="number"||!Number.isInteger(i)||i<0)throw new Error(`free dimension override value must be a non-negative integer: ${i}`);let y=b(f,s);t._OrtAddFreeDimensionOverride(r,y,i)!==0&&w(`Can't set a free dimension override: ${f} - ${i}.`)}return n.extra!==void 0&&G(n.extra,"",new WeakSet,(f,i)=>{let y=b(f,s),l=b(i,s);t._OrtAddSessionConfigEntry(r,y,l)!==0&&w(`Can't set a session config entry: ${f} - ${i}.`)}),[r,s]}catch(a){throw r!==0&&t._OrtReleaseSessionOptions(r),s.forEach(o=>t._free(o)),a}}});var fe,We,le,De,Fe,ne,Re,de=x(()=>{"use strict";fe=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},We=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},le=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],De=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Fe=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},ne=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint8"||e==="bool",Re=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var q,pe=x(()=>{"use strict";Z();q=async e=>{if(typeof e=="string")if(_)try{let{readFile:t}=require("node:fs/promises");return new Uint8Array(await t(e))}catch(t){if(t.code==="ERR_FS_FILE_TOO_LARGE"){let{createReadStream:r}=require("node:fs"),s=r(e),n=[];for await(let a of s)n.push(a);return new Uint8Array(Buffer.concat(n))}throw t}else{let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let r=t.headers.get("Content-Length"),s=r?parseInt(r,10):0;if(s<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let n=t.body.getReader(),a;try{a=new ArrayBuffer(s)}catch(c){if(c instanceof RangeError){let u=Math.ceil(s/65536);a=new WebAssembly.Memory({initial:u,maximum:u}).buffer}else throw c}let o=0;for(;;){let{done:c,value:u}=await n.read();if(c)break;let d=u.byteLength;new Uint8Array(a,o,d).set(u),o+=d}return new Uint8Array(a,0,s)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}});var Ct,$e,He,N,Ut,me,je,ze,Ne,Ge,qe,Ve=x(()=>{"use strict";Be();Me();de();R();re();pe();Ct=(e,t)=>{h()._OrtInit(e,t)!==0&&w("Can't initialize onnxruntime.")},$e=async e=>{Ct(e.wasm.numThreads,Fe(e.logLevel))},He=async(e,t)=>{},N=new Map,Ut=e=>{let t=h(),r=t.stackSave();try{let s=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,s,s+4)!==0&&w("Can't get session input/output count."),[t.HEAP32[s/4],t.HEAP32[s/4+1]]}finally{t.stackRestore(r)}},me=e=>{let t=h(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},je=async(e,t)=>{let r,s,n=h();Array.isArray(e)?[r,s]=e:e.buffer===n.HEAPU8.buffer?[r,s]=[e.byteOffset,e.byteLength]:[r,s]=me(e);let a=0,o=0,c=0,u=[],d=[],p=[];try{if([o,u]=_e(t),t?.externalData&&n.mountExternalData){let S=[];for(let E of t.externalData){let M=typeof E=="string"?E:E.path;S.push(q(typeof E=="string"?E:E.data).then(J=>{n.mountExternalData(M,J)}))}await Promise.all(S)}a=await n._OrtCreateSession(r,s,o),a===0&&w("Can't create a session.");let[f,i]=Ut(a),y=!!t?.enableGraphCapture,l=[],g=[],O=[];for(let S=0;S<f;S++){let E=n._OrtGetInputName(a,S);E===0&&w("Can't get an input name."),d.push(E),l.push(n.UTF8ToString(E))}for(let S=0;S<i;S++){let E=n._OrtGetOutputName(a,S);E===0&&w("Can't get an output name."),p.push(E);let M=n.UTF8ToString(E);g.push(M)}let I=null;return N.set(a,[a,d,p,I,y,!1]),[a,l,g]}catch(f){throw d.forEach(i=>n._OrtFree(i)),p.forEach(i=>n._OrtFree(i)),c!==0&&n._OrtReleaseBinding(c),a!==0&&n._OrtReleaseSession(a),f}finally{n._free(r),o!==0&&n._OrtReleaseSessionOptions(o),u.forEach(f=>n._free(f)),n.unmountExternalData?.()}},ze=e=>{let t=h(),r=N.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[s,n,a,o,c]=r;o&&(c&&t._OrtClearBoundOutputs(o.handle),t._OrtReleaseBinding(o.handle)),t.jsepOnReleaseSession?.(e),n.forEach(u=>t._OrtFree(u)),a.forEach(u=>t._OrtFree(u)),t._OrtReleaseSession(s),N.delete(e)},Ne=(e,t,r,s,n,a=!1)=>{if(!e){t.push(0);return}let o=h(),c=e[0],u=e[1],d=e[3],p,f;if(c==="string"&&d==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(a&&d!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${n} when enableGraphCapture is true.`);if(d==="gpu-buffer"){let l=e[2].gpuBuffer,g=le(fe(c));f=u.reduce((I,S)=>I*S,1)*g;let O=o.jsepRegisterBuffer;if(!O)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');p=O(s,n,l,f)}else{let l=e[2];if(Array.isArray(l)){f=4*l.length,p=o._malloc(f),r.push(p);let g=p/4;for(let O=0;O<l.length;O++){if(typeof l[O]!="string")throw new TypeError(`tensor data at index ${O} is not a string`);o.HEAPU32[g++]=b(l[O],r)}}else f=l.byteLength,p=o._malloc(f),r.push(p),o.HEAPU8.set(new Uint8Array(l.buffer,l.byteOffset,f),p)}let i=o.stackSave(),y=o.stackAlloc(4*u.length);try{let l=y/4;u.forEach(O=>o.HEAP32[l++]=O);let g=o._OrtCreateTensor(fe(c),p,f,y,u.length,Re(d));g===0&&w(`Can't create tensor for input/output. session=${s}, index=${n}.`),t.push(g)}finally{o.stackRestore(i)}},Ge=async(e,t,r,s,n,a)=>{let o=h(),c=N.get(e);if(!c)throw new Error(`cannot run inference. invalid session id: ${e}`);let u=c[0],d=c[1],p=c[2],f=c[3],i=c[4],y=c[5],l=t.length,g=s.length,O=0,I=[],S=[],E=[],M=[],J=o.stackSave(),be=o.stackAlloc(l*4),we=o.stackAlloc(l*4),ie=o.stackAlloc(g*4),he=o.stackAlloc(g*4);try{[O,I]=Ue(a);for(let m=0;m<l;m++)Ne(r[m],S,M,e,t[m],i);for(let m=0;m<g;m++)Ne(n[m],E,M,e,l+s[m],i);let k=be/4,ut=we/4,ct=ie/4,ft=he/4;for(let m=0;m<l;m++)o.HEAPU32[k++]=S[m],o.HEAPU32[ut++]=d[t[m]];for(let m=0;m<g;m++)o.HEAPU32[ct++]=E[m],o.HEAPU32[ft++]=p[s[m]];o.jsepOnRunStart?.(u);let Se;Se=await o._OrtRun(u,we,be,l,he,g,ie,O),Se!==0&&w("failed to call OrtRun().");let $=[];for(let m=0;m<g;m++){let H=o.HEAPU32[ie/4+m];if(H===E[m]){$.push(n[m]);continue}let Ee=o.stackSave(),W=o.stackAlloc(4*4),Y=!1,T,C=0;try{o._OrtGetTensorData(H,W,W+4,W+8,W+12)!==0&&w(`Can't access output tensor data on index ${m}.`);let X=W/4,Oe=o.HEAPU32[X++];C=o.HEAPU32[X++];let ve=o.HEAPU32[X++],lt=o.HEAPU32[X++],j=[];for(let A=0;A<lt;A++)j.push(o.HEAPU32[ve/4+A]);o._OrtFree(ve);let z=j.reduce((A,P)=>A*P,1);T=We(Oe);let Ae=f?.outputPreferredLocations[s[m]];if(T==="string"){if(Ae==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let A=[],P=C/4;for(let F=0;F<z;F++){let Pe=o.HEAPU32[P++],dt=F===z-1?void 0:o.HEAPU32[P]-Pe;A.push(o.UTF8ToString(Pe,dt))}$.push([T,j,A,"cpu"])}else if(Ae==="gpu-buffer"&&z>0){let A=o.jsepGetBuffer;if(!A)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let P=A(C),F=le(Oe);if(F===void 0||!ne(T))throw new Error(`Unsupported data type: ${T}`);Y=!0,$.push([T,j,{gpuBuffer:P,download:o.jsepCreateDownloader(P,z*F,T),dispose:()=>{o._OrtReleaseTensor(H)}},"gpu-buffer"])}else{let A=De(T),P=new A(z);new Uint8Array(P.buffer,P.byteOffset,P.byteLength).set(o.HEAPU8.subarray(C,C+P.byteLength)),$.push([T,j,P,"cpu"])}}finally{o.stackRestore(Ee),T==="string"&&C&&o._free(C),Y||o._OrtReleaseTensor(H)}}return f&&!i&&(o._OrtClearBoundOutputs(f.handle),N.set(e,[u,d,p,f,i,!1])),$}finally{o.stackRestore(J),S.forEach(k=>o._OrtReleaseTensor(k)),E.forEach(k=>o._OrtReleaseTensor(k)),M.forEach(k=>o._free(k)),O!==0&&o._OrtReleaseRunOptions(O),I.forEach(k=>o._free(k))}},qe=e=>{let t=h(),r=N.get(e);if(!r)throw new Error("invalid session id");let s=r[0],n=t._OrtEndProfiling(s);n===0&&w("Can't get an profile file name."),t._OrtFree(n)}});var oe,ge,Je,Ye,Xe,Ke,Qe,Ze,et,tt,rt,ye=x(()=>{"use strict";oe=require("onnxruntime-common");Ve();R();ee();ge=!1,Je=!1,Ye=!1,Xe=async()=>{if(!Je){if(ge)throw new Error("multiple calls to 'initWasm()' detected.");if(Ye)throw new Error("previous call to 'initWasm()' failed.");ge=!0;try{await Ce(oe.env.wasm),await $e(oe.env),Je=!0}catch(e){throw Ye=!0,e}finally{ge=!1}}},Ke=async e=>{await He(oe.env,e)},Qe=async e=>me(e),Ze=async(e,t)=>je(e,t),et=async e=>{ze(e)},tt=async(e,t,r,s,n,a)=>Ge(e,t,r,s,n,a),rt=async e=>{qe(e)}});var B,nt,_t,se,ot=x(()=>{"use strict";B=require("onnxruntime-common");ye();de();Z();pe();nt=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},_t=e=>{switch(e[3]){case"cpu":return new B.Tensor(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!ne(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:r,download:s,dispose:n}=e[2];return B.Tensor.fromGpuBuffer(r,{dataType:t,dims:e[1],download:s,dispose:n})}default:throw new Error(`invalid data location: ${e[3]}`)}},se=class{async fetchModelAndCopyToWasmMemory(t){return Qe(await q(t))}async loadModel(t,r){(0,B.TRACE_FUNC_BEGIN)();let s;typeof t=="string"?_?s=await q(t):s=await this.fetchModelAndCopyToWasmMemory(t):s=t,[this.sessionId,this.inputNames,this.outputNames]=await Ze(s,r),(0,B.TRACE_FUNC_END)()}async dispose(){return et(this.sessionId)}async run(t,r,s){(0,B.TRACE_FUNC_BEGIN)();let n=[],a=[];Object.entries(t).forEach(i=>{let y=i[0],l=i[1],g=this.inputNames.indexOf(y);if(g===-1)throw new Error(`invalid input '${y}'`);n.push(l),a.push(g)});let o=[],c=[];Object.entries(r).forEach(i=>{let y=i[0],l=i[1],g=this.outputNames.indexOf(y);if(g===-1)throw new Error(`invalid output '${y}'`);o.push(l),c.push(g)});let u=n.map((i,y)=>nt(i,()=>`input "${this.inputNames[a[y]]}"`)),d=o.map((i,y)=>i?nt(i,()=>`output "${this.outputNames[c[y]]}"`):null),p=await tt(this.sessionId,a,u,c,d,s),f={};for(let i=0;i<p.length;i++)f[this.outputNames[c[i]]]=o[i]??_t(p[i]);return(0,B.TRACE_FUNC_END)(),f}startProfiling(){}endProfiling(){rt(this.sessionId)}}});var v,Mt,ae,st=x(()=>{"use strict";v=require("onnxruntime-common");ye();ot();ee();Mt=()=>{if((typeof v.env.wasm.initTimeout!="number"||v.env.wasm.initTimeout<0)&&(v.env.wasm.initTimeout=0),v.env.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof v.env.wasm.proxy!="boolean"&&(v.env.wasm.proxy=!1),typeof v.env.wasm.trace!="boolean"&&(v.env.wasm.trace=!1),typeof v.env.wasm.numThreads!="number"||!Number.isInteger(v.env.wasm.numThreads)||v.env.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)v.env.wasm.numThreads=1;else{let e=typeof navigator>"u"?require("node:os").cpus().length:navigator.hardwareConcurrency;v.env.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}v.env.wasm.wasmPaths===void 0&&D&&D.indexOf("blob:")!==0&&(v.env.wasm.wasmPaths=D.substring(0,D.lastIndexOf("/")+1))},ae=class{async init(t){Mt(),await Xe(),await Ke(t)}async createInferenceSessionHandler(t,r){let s=new se;return await s.loadModel(t,r),Promise.resolve(s)}}});var at={};xe(at,{wasmBackend:()=>Wt});var Wt,it=x(()=>{"use strict";st();Wt=new ae});var L={};xe(L,{default:()=>Ft});module.exports=Ie(L);U(L,require("onnxruntime-common"),module.exports);var Dt=wt(require("onnxruntime-common")),V=require("onnxruntime-common");var Te="1.19.0";var Ft=Dt;{let e=(it(),Ie(at)).wasmBackend;(0,V.registerBackend)("cpu",e,10),(0,V.registerBackend)("wasm",e,10)}Object.defineProperty(V.env.versions,"web",{value:Te,enumerable:!0});0&&(module.exports={...require("onnxruntime-common")});
//# sourceMappingURL=ort.node.min.js.map
