/*!
 * ONNX Runtime Web v1.20.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
"use strict";var pt=Object.create;var re=Object.defineProperty;var mt=Object.getOwnPropertyDescriptor;var gt=Object.getOwnPropertyNames;var yt=Object.getPrototypeOf,bt=Object.prototype.hasOwnProperty;var T=(e,t)=>()=>(e&&(t=e(e=0)),t);var Pe=(e,t)=>{for(var n in t)re(e,n,{get:t[n],enumerable:!0})},te=(e,t,n,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of gt(t))!bt.call(e,r)&&r!==n&&re(e,r,{get:()=>t[r],enumerable:!(o=mt(t,r))||o.enumerable});return e},B=(e,t,n)=>(te(e,t,"default"),n&&te(n,t,"default")),wt=(e,t,n)=>(n=e!=null?pt(yt(e)):{},te(t||!e||!e.__esModule?re(n,"default",{value:e,enumerable:!0}):n,e)),Ie=e=>te(re({},"__esModule",{value:!0}),e);var M,ne=T(()=>{"use strict";M=!!(typeof process<"u"&&process.versions&&process.versions.node)});var F,ht,St,Et,Ot,vt,xt,Le,oe=T(()=>{"use strict";ne();F=M?void 0:typeof document<"u"?document.currentScript?.src:typeof self<"u"?self.location?.href:void 0,ht=M||typeof location>"u"?void 0:location.origin,St=(e,t)=>{try{let n=t??F;return(n?new URL(e,n):new URL(e)).origin===ht}catch{return!1}},Et=(e,t)=>{let n=t??F;try{return(n?new URL(e,n):new URL(e)).href}catch{return}},Ot=(e,t)=>`${t??"./"}${e}`,vt=async e=>{let n=await(await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(n)},xt=async e=>(await import(/*webpackIgnore:true*/e)).default,Le=async(e,t,n)=>{{let o="ort-wasm-simd-threaded.mjs",r=e??Et(o,t),a=!M&&n&&r&&!St(r,t),s=a?await vt(r):r??Ot(o,t);return[a?s:void 0,await xt(s)]}}});var fe,de,se,Ce,At,Pt,ke,S,N=T(()=>{"use strict";oe();de=!1,se=!1,Ce=!1,At=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Pt=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},ke=async e=>{if(de)return Promise.resolve();if(se)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Ce)throw new Error("previous call to 'initializeWebAssembly()' failed.");se=!0;let t=e.initTimeout,n=e.numThreads;if(!Pt())throw new Error("WebAssembly SIMD is not supported in the current environment.");let o=At();n>1&&!o&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+n+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=n=1);let r=e.wasmPaths,a=typeof r=="string"?r:void 0,s=r?.mjs,u=s?.href??s,c=r?.wasm,d=c?.href??c,y=e.wasmBinary,[l,i]=await Le(u,a,n>1),b=!1,f=[];if(t>0&&f.push(new Promise(g=>{setTimeout(()=>{b=!0,g()},t)})),f.push(new Promise((g,v)=>{let _={numThreads:n};y?_.wasmBinary=y:(d||a)&&(_.locateFile=(p,w)=>d??(a??w)+p),i(_).then(p=>{se=!1,de=!0,fe=p,g(),l&&URL.revokeObjectURL(l)},p=>{se=!1,Ce=!0,v(p)})})),await Promise.race(f),b)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},S=()=>{if(de&&fe)return fe;throw new Error("WebAssembly is not initialized yet.")}});var E,J,h,ae=T(()=>{"use strict";N();E=(e,t)=>{let n=S(),o=n.lengthBytesUTF8(e)+1,r=n._malloc(o);return n.stringToUTF8(e,r,o),t.push(r),r},J=(e,t,n,o)=>{if(typeof e=="object"&&e!==null){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach(([r,a])=>{let s=t?t+r:r;if(typeof a=="object")J(a,s+".",n,o);else if(typeof a=="string"||typeof a=="number")o(s,a.toString());else if(typeof a=="boolean")o(s,a?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof a}`)})},h=e=>{let t=S(),n=t.stackSave();try{let o=t.stackAlloc(8);t._OrtGetLastError(o,o+4);let r=t.HEAP32[o/4],a=t.HEAPU32[o/4+1],s=a?t.UTF8ToString(a):"";throw new Error(`${e} ERROR_CODE: ${r}, ERROR_MESSAGE: ${s}`)}finally{t.stackRestore(n)}}});var Be,Ue=T(()=>{"use strict";N();ae();Be=e=>{let t=S(),n=0,o=[],r=e||{};try{if(e?.logSeverityLevel===void 0)r.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)r.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(r.terminate=!1);let a=0;return e?.tag!==void 0&&(a=E(e.tag,o)),n=t._OrtCreateRunOptions(r.logSeverityLevel,r.logVerbosityLevel,!!r.terminate,a),n===0&&h("Can't create run options."),e?.extra!==void 0&&J(e.extra,"",new WeakSet,(s,u)=>{let c=E(s,o),d=E(u,o);t._OrtAddRunConfigEntry(n,c,d)!==0&&h(`Can't set a run config entry: ${s} - ${u}.`)}),[n,o]}catch(a){throw n!==0&&t._OrtReleaseRunOptions(n),o.forEach(s=>t._free(s)),a}}});var It,Tt,Lt,Ct,_e,Me=T(()=>{"use strict";N();ae();It=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},Tt=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Lt=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(n=>(typeof n=="string"?n:n.name)==="webgpu")&&(e.enableMemPattern=!1)},Ct=(e,t,n)=>{for(let o of t){let r=typeof o=="string"?o:o.name;switch(r){case"webnn":if(r="WEBNN",typeof o!="string"){let u=o?.deviceType;if(u){let c=E("deviceType",n),d=E(u,n);S()._OrtAddSessionConfigEntry(e,c,d)!==0&&h(`Can't set a session config entry: 'deviceType' - ${u}.`)}}break;case"webgpu":if(r="JS",typeof o!="string"){let s=o;if(s?.preferredLayout){if(s.preferredLayout!=="NCHW"&&s.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${s.preferredLayout}`);let u=E("preferredLayout",n),c=E(s.preferredLayout,n);S()._OrtAddSessionConfigEntry(e,u,c)!==0&&h(`Can't set a session config entry: 'preferredLayout' - ${s.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${r}`)}let a=E(r,n);S()._OrtAppendExecutionProvider(e,a)!==0&&h(`Can't append execution provider: ${r}.`)}},_e=e=>{let t=S(),n=0,o=[],r=e||{};Lt(r);try{let a=It(r.graphOptimizationLevel??"all"),s=Tt(r.executionMode??"sequential"),u=typeof r.logId=="string"?E(r.logId,o):0,c=r.logSeverityLevel??2;if(!Number.isInteger(c)||c<0||c>4)throw new Error(`log serverity level is not valid: ${c}`);let d=r.logVerbosityLevel??0;if(!Number.isInteger(d)||d<0||d>4)throw new Error(`log verbosity level is not valid: ${d}`);let y=typeof r.optimizedModelFilePath=="string"?E(r.optimizedModelFilePath,o):0;if(n=t._OrtCreateSessionOptions(a,!!r.enableCpuMemArena,!!r.enableMemPattern,s,!!r.enableProfiling,0,u,c,d,y),n===0&&h("Can't create session options."),r.executionProviders&&Ct(n,r.executionProviders,o),r.enableGraphCapture!==void 0){if(typeof r.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${r.enableGraphCapture}`);let l=E("enableGraphCapture",o),i=E(r.enableGraphCapture.toString(),o);t._OrtAddSessionConfigEntry(n,l,i)!==0&&h(`Can't set a session config entry: 'enableGraphCapture' - ${r.enableGraphCapture}.`)}if(r.freeDimensionOverrides)for(let[l,i]of Object.entries(r.freeDimensionOverrides)){if(typeof l!="string")throw new Error(`free dimension override name must be a string: ${l}`);if(typeof i!="number"||!Number.isInteger(i)||i<0)throw new Error(`free dimension override value must be a non-negative integer: ${i}`);let b=E(l,o);t._OrtAddFreeDimensionOverride(n,b,i)!==0&&h(`Can't set a free dimension override: ${l} - ${i}.`)}return r.extra!==void 0&&J(r.extra,"",new WeakSet,(l,i)=>{let b=E(l,o),f=E(i,o);t._OrtAddSessionConfigEntry(n,b,f)!==0&&h(`Can't set a session config entry: ${l} - ${i}.`)}),[n,o]}catch(a){throw n!==0&&t._OrtReleaseSessionOptions(n),o.forEach(s=>t._free(s)),a}}});var pe,We,me,De,Fe,ie,Re,ge=T(()=>{"use strict";pe=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${e}`)}},We=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${e}`)}},me=(e,t)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],o=typeof t=="number"?t:t.reduce((r,a)=>r*a,1);return n>0?Math.ceil(o*n):void 0},De=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Fe=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},ie=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",Re=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var Y,ye=T(()=>{"use strict";ne();Y=async e=>{if(typeof e=="string")if(M)try{let{readFile:t}=require("node:fs/promises");return new Uint8Array(await t(e))}catch(t){if(t.code==="ERR_FS_FILE_TOO_LARGE"){let{createReadStream:n}=require("node:fs"),o=n(e),r=[];for await(let a of o)r.push(a);return new Uint8Array(Buffer.concat(r))}throw t}else{let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let n=t.headers.get("Content-Length"),o=n?parseInt(n,10):0;if(o<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let r=t.body.getReader(),a;try{a=new ArrayBuffer(o)}catch(u){if(u instanceof RangeError){let c=Math.ceil(o/65536);a=new WebAssembly.Memory({initial:c,maximum:c}).buffer}else throw u}let s=0;for(;;){let{done:u,value:c}=await r.read();if(u)break;let d=c.byteLength;new Uint8Array(a,s,d).set(c),s+=d}return new Uint8Array(a,0,o)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}});var kt,$e,He,$,Bt,be,je,ze,Ne,Ge,qe,Ve=T(()=>{"use strict";Ue();Me();ge();N();ae();ye();kt=(e,t)=>{S()._OrtInit(e,t)!==0&&h("Can't initialize onnxruntime.")},$e=async e=>{kt(e.wasm.numThreads,Fe(e.logLevel))},He=async(e,t)=>{},$=new Map,Bt=e=>{let t=S(),n=t.stackSave();try{let o=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,o,o+4)!==0&&h("Can't get session input/output count."),[t.HEAP32[o/4],t.HEAP32[o/4+1]]}finally{t.stackRestore(n)}},be=e=>{let t=S(),n=t._malloc(e.byteLength);if(n===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},je=async(e,t)=>{let n,o,r=S();Array.isArray(e)?[n,o]=e:e.buffer===r.HEAPU8.buffer?[n,o]=[e.byteOffset,e.byteLength]:[n,o]=be(e);let a=0,s=0,u=0,c=[],d=[],y=[];try{if([s,c]=_e(t),t?.externalData&&r.mountExternalData){let p=[];for(let w of t.externalData){let x=typeof w=="string"?w:w.path;p.push(Y(typeof w=="string"?w:w.data).then(W=>{r.mountExternalData(x,W)}))}await Promise.all(p)}for(let p of t?.executionProviders??[])if((typeof p=="string"?p:p.name)==="webnn"){if(r.currentContext)throw new Error("WebNN execution provider is already set.");if(typeof p!="string"){let x=p,W=x?.context,H=x?.gpuDevice,K=x?.deviceType,j=x?.numThreads,Q=x?.powerPreference;W?r.currentContext=W:H?r.currentContext=await navigator.ml.createContext(H):r.currentContext=await navigator.ml.createContext({deviceType:K,numThreads:j,powerPreference:Q})}else r.currentContext=await navigator.ml.createContext();break}a=await r._OrtCreateSession(n,o,s),a===0&&h("Can't create a session."),r.currentContext&&(r.currentContext=void 0);let[l,i]=Bt(a),b=!!t?.enableGraphCapture,f=[],g=[],v=[];for(let p=0;p<l;p++){let w=r._OrtGetInputName(a,p);w===0&&h("Can't get an input name."),d.push(w),f.push(r.UTF8ToString(w))}for(let p=0;p<i;p++){let w=r._OrtGetOutputName(a,p);w===0&&h("Can't get an output name."),y.push(w);let x=r.UTF8ToString(w);g.push(x)}let _=null;return $.set(a,[a,d,y,_,b,!1]),[a,f,g]}catch(l){throw d.forEach(i=>r._OrtFree(i)),y.forEach(i=>r._OrtFree(i)),u!==0&&r._OrtReleaseBinding(u),a!==0&&r._OrtReleaseSession(a),l}finally{r._free(n),s!==0&&r._OrtReleaseSessionOptions(s),c.forEach(l=>r._free(l)),r.unmountExternalData?.()}},ze=e=>{let t=S(),n=$.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);let[o,r,a,s,u]=n;s&&(u&&t._OrtClearBoundOutputs(s.handle),t._OrtReleaseBinding(s.handle)),t.jsepOnReleaseSession?.(e),r.forEach(c=>t._OrtFree(c)),a.forEach(c=>t._OrtFree(c)),t._OrtReleaseSession(o),$.delete(e)},Ne=(e,t,n,o,r,a=!1)=>{if(!e){t.push(0);return}let s=S(),u=e[0],c=e[1],d=e[3],y,l;if(u==="string"&&d==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(a&&d!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${r} when enableGraphCapture is true.`);if(d==="gpu-buffer"){let f=e[2].gpuBuffer;l=me(pe(u),c);let g=s.jsepRegisterBuffer;if(!g)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');y=g(o,r,f,l)}else{let f=e[2];if(Array.isArray(f)){l=4*f.length,y=s._malloc(l),n.push(y);let g=y/4;for(let v=0;v<f.length;v++){if(typeof f[v]!="string")throw new TypeError(`tensor data at index ${v} is not a string`);s.HEAPU32[g++]=E(f[v],n)}}else l=f.byteLength,y=s._malloc(l),n.push(y),s.HEAPU8.set(new Uint8Array(f.buffer,f.byteOffset,l),y)}let i=s.stackSave(),b=s.stackAlloc(4*c.length);try{let f=b/4;c.forEach(v=>s.HEAP32[f++]=v);let g=s._OrtCreateTensor(pe(u),y,l,b,c.length,Re(d));g===0&&h(`Can't create tensor for input/output. session=${o}, index=${r}.`),t.push(g)}finally{s.stackRestore(i)}},Ge=async(e,t,n,o,r,a)=>{let s=S(),u=$.get(e);if(!u)throw new Error(`cannot run inference. invalid session id: ${e}`);let c=u[0],d=u[1],y=u[2],l=u[3],i=u[4],b=u[5],f=t.length,g=o.length,v=0,_=[],p=[],w=[],x=[],W=s.stackSave(),H=s.stackAlloc(f*4),K=s.stackAlloc(f*4),j=s.stackAlloc(g*4),Q=s.stackAlloc(g*4);try{[v,_]=Be(a);for(let m=0;m<f;m++)Ne(n[m],p,x,e,t[m],i);for(let m=0;m<g;m++)Ne(r[m],w,x,e,f+o[m],i);let C=H/4,ut=K/4,ct=j/4,lt=Q/4;for(let m=0;m<f;m++)s.HEAPU32[C++]=p[m],s.HEAPU32[ut++]=d[t[m]];for(let m=0;m<g;m++)s.HEAPU32[ct++]=w[m],s.HEAPU32[lt++]=y[o[m]];s.jsepOnRunStart?.(c);let Se;Se=await s._OrtRun(c,K,H,f,Q,g,j,v),Se!==0&&h("failed to call OrtRun().");let z=[];for(let m=0;m<g;m++){let G=s.HEAPU32[j/4+m];if(G===w[m]){z.push(r[m]);continue}let Ee=s.stackSave(),D=s.stackAlloc(4*4),Z=!1,I,k=0;try{s._OrtGetTensorData(G,D,D+4,D+8,D+12)!==0&&h(`Can't access output tensor data on index ${m}.`);let ee=D/4,Oe=s.HEAPU32[ee++];k=s.HEAPU32[ee++];let ve=s.HEAPU32[ee++],ft=s.HEAPU32[ee++],q=[];for(let A=0;A<ft;A++)q.push(s.HEAPU32[ve/4+A]);s._OrtFree(ve);let V=q.reduce((A,P)=>A*P,1);I=We(Oe);let xe=l?.outputPreferredLocations[o[m]];if(I==="string"){if(xe==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let A=[],P=k/4;for(let R=0;R<V;R++){let Ae=s.HEAPU32[P++],dt=R===V-1?void 0:s.HEAPU32[P]-Ae;A.push(s.UTF8ToString(Ae,dt))}z.push([I,q,A,"cpu"])}else if(xe==="gpu-buffer"&&V>0){let A=s.jsepGetBuffer;if(!A)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let P=A(k),R=me(Oe,V);if(R===void 0||!ie(I))throw new Error(`Unsupported data type: ${I}`);Z=!0,z.push([I,q,{gpuBuffer:P,download:s.jsepCreateDownloader(P,R,I),dispose:()=>{s._OrtReleaseTensor(G)}},"gpu-buffer"])}else{let A=De(I),P=new A(V);new Uint8Array(P.buffer,P.byteOffset,P.byteLength).set(s.HEAPU8.subarray(k,k+P.byteLength)),z.push([I,q,P,"cpu"])}}finally{s.stackRestore(Ee),I==="string"&&k&&s._free(k),Z||s._OrtReleaseTensor(G)}}return l&&!i&&(s._OrtClearBoundOutputs(l.handle),$.set(e,[c,d,y,l,i,!1])),z}finally{s.stackRestore(W),p.forEach(C=>s._OrtReleaseTensor(C)),w.forEach(C=>s._OrtReleaseTensor(C)),x.forEach(C=>s._free(C)),v!==0&&s._OrtReleaseRunOptions(v),_.forEach(C=>s._free(C))}},qe=e=>{let t=S(),n=$.get(e);if(!n)throw new Error("invalid session id");let o=n[0],r=t._OrtEndProfiling(o);r===0&&h("Can't get an profile file name."),t._OrtFree(r)}});var ue,we,Je,Ye,Xe,Ke,Qe,Ze,et,tt,rt,he=T(()=>{"use strict";ue=require("onnxruntime-common");Ve();N();oe();we=!1,Je=!1,Ye=!1,Xe=async()=>{if(!Je){if(we)throw new Error("multiple calls to 'initWasm()' detected.");if(Ye)throw new Error("previous call to 'initWasm()' failed.");we=!0;try{await ke(ue.env.wasm),await $e(ue.env),Je=!0}catch(e){throw Ye=!0,e}finally{we=!1}}},Ke=async e=>{await He(ue.env,e)},Qe=async e=>be(e),Ze=async(e,t)=>je(e,t),et=async e=>{ze(e)},tt=async(e,t,n,o,r,a)=>Ge(e,t,n,o,r,a),rt=async e=>{qe(e)}});var U,nt,_t,ce,ot=T(()=>{"use strict";U=require("onnxruntime-common");he();ge();ne();ye();nt=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},_t=e=>{switch(e[3]){case"cpu":return new U.Tensor(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!ie(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:n,download:o,dispose:r}=e[2];return U.Tensor.fromGpuBuffer(n,{dataType:t,dims:e[1],download:o,dispose:r})}default:throw new Error(`invalid data location: ${e[3]}`)}},ce=class{async fetchModelAndCopyToWasmMemory(t){return Qe(await Y(t))}async loadModel(t,n){(0,U.TRACE_FUNC_BEGIN)();let o;typeof t=="string"?M?o=await Y(t):o=await this.fetchModelAndCopyToWasmMemory(t):o=t,[this.sessionId,this.inputNames,this.outputNames]=await Ze(o,n),(0,U.TRACE_FUNC_END)()}async dispose(){return et(this.sessionId)}async run(t,n,o){(0,U.TRACE_FUNC_BEGIN)();let r=[],a=[];Object.entries(t).forEach(i=>{let b=i[0],f=i[1],g=this.inputNames.indexOf(b);if(g===-1)throw new Error(`invalid input '${b}'`);r.push(f),a.push(g)});let s=[],u=[];Object.entries(n).forEach(i=>{let b=i[0],f=i[1],g=this.outputNames.indexOf(b);if(g===-1)throw new Error(`invalid output '${b}'`);s.push(f),u.push(g)});let c=r.map((i,b)=>nt(i,()=>`input "${this.inputNames[a[b]]}"`)),d=s.map((i,b)=>i?nt(i,()=>`output "${this.outputNames[u[b]]}"`):null),y=await tt(this.sessionId,a,c,u,d,o),l={};for(let i=0;i<y.length;i++)l[this.outputNames[u[i]]]=s[i]??_t(y[i]);return(0,U.TRACE_FUNC_END)(),l}startProfiling(){}endProfiling(){rt(this.sessionId)}}});var at={};Pe(at,{OnnxruntimeWebAssemblyBackend:()=>le,initializeFlags:()=>st,wasmBackend:()=>Mt});var O,st,le,Mt,it=T(()=>{"use strict";O=require("onnxruntime-common");he();ot();oe();st=()=>{if((typeof O.env.wasm.initTimeout!="number"||O.env.wasm.initTimeout<0)&&(O.env.wasm.initTimeout=0),O.env.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof O.env.wasm.proxy!="boolean"&&(O.env.wasm.proxy=!1),typeof O.env.wasm.trace!="boolean"&&(O.env.wasm.trace=!1),typeof O.env.wasm.numThreads!="number"||!Number.isInteger(O.env.wasm.numThreads)||O.env.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)O.env.wasm.numThreads=1;else{let e=typeof navigator>"u"?require("node:os").cpus().length:navigator.hardwareConcurrency;O.env.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}O.env.wasm.wasmPaths===void 0&&F&&F.indexOf("blob:")!==0&&(O.env.wasm.wasmPaths=F.substring(0,F.lastIndexOf("/")+1))},le=class{async init(t){st(),await Xe(),await Ke(t)}async createInferenceSessionHandler(t,n){let o=new ce;return await o.loadModel(t,n),Promise.resolve(o)}},Mt=new le});var L={};Pe(L,{default:()=>Dt});module.exports=Ie(L);B(L,require("onnxruntime-common"),module.exports);var Wt=wt(require("onnxruntime-common")),X=require("onnxruntime-common");var Te="1.20.0";var Dt=Wt;{let e=(it(),Ie(at)).wasmBackend;(0,X.registerBackend)("cpu",e,10),(0,X.registerBackend)("wasm",e,10)}Object.defineProperty(X.env.versions,"web",{value:Te,enumerable:!0});0&&(module.exports={...require("onnxruntime-common")});
//# sourceMappingURL=ort.node.min.js.map
