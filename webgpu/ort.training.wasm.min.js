/*!
 * ONNX Runtime Web v1.19.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
"use strict";var ort=(()=>{var Ze=Object.defineProperty;var Wr=Object.getOwnPropertyDescriptor;var Gr=Object.getOwnPropertyNames;var jr=Object.prototype.hasOwnProperty;var et=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,r)=>(typeof require<"u"?require:e)[r]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')});var g=(t,e)=>()=>(t&&(e=t(t=0)),e);var Ee=(t,e)=>{for(var r in e)Ze(t,r,{get:e[r],enumerable:!0})},Vr=(t,e,r,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of Gr(e))!jr.call(t,n)&&n!==r&&Ze(t,n,{get:()=>e[n],enumerable:!(o=Wr(e,n))||o.enumerable});return t};var tt=t=>Vr(Ze({},"__esModule",{value:!0}),t);var Se,G,Q,Yr,Oe,Ae=g(()=>{Se=new Map,G=[],Q=(t,e,r)=>{if(e&&typeof e.init=="function"&&typeof e.createInferenceSessionHandler=="function"){let o=Se.get(t);if(o===void 0)Se.set(t,{backend:e,priority:r});else{if(o.priority>r)return;if(o.priority===r&&o.backend!==e)throw new Error(`cannot register backend "${t}" using priority ${r}`)}if(r>=0){let n=G.indexOf(t);n!==-1&&G.splice(n,1);for(let a=0;a<G.length;a++)if(Se.get(G[a]).priority<=r){G.splice(a,0,t);return}G.push(t)}return}throw new TypeError("not a valid backend")},Yr=async t=>{let e=Se.get(t);if(!e)return"backend not found.";if(e.initialized)return e.backend;if(e.aborted)return e.error;{let r=!!e.initPromise;try{return r||(e.initPromise=e.backend.init(t)),await e.initPromise,e.initialized=!0,e.backend}catch(o){return r||(e.error=`${o}`,e.aborted=!0),e.error}finally{delete e.initPromise}}},Oe=async t=>{let e=t.executionProviders||[],r=e.map(u=>typeof u=="string"?u:u.name),o=r.length===0?G:r,n,a=[],s=new Set;for(let u of o){let f=await Yr(u);typeof f=="string"?a.push({name:u,err:f}):(n||(n=f),n===f&&s.add(u))}if(!n)throw new Error(`no available backend found. ERR: ${a.map(u=>`[${u.name}] ${u.err}`).join(", ")}`);for(let{name:u,err:f}of a)r.includes(u)&&console.warn(`removing requested execution provider "${u}" from session options because it is not available: ${f}`);let i=e.filter(u=>s.has(typeof u=="string"?u:u.name));return[n,new Proxy(t,{get:(u,f)=>f==="executionProviders"?i:Reflect.get(u,f)})]}});var It=g(()=>{Ae()});var xt,Ct=g(()=>{xt="1.19.0"});var Bt,U,rt=g(()=>{Ct();Bt="warning",U={wasm:{},webgl:{},webgpu:{},versions:{common:xt},set logLevel(t){if(t!==void 0){if(typeof t!="string"||["verbose","info","warning","error","fatal"].indexOf(t)===-1)throw new Error(`Unsupported logging level: ${t}`);Bt=t}},get logLevel(){return Bt}};Object.defineProperty(U,"logLevel",{enumerable:!0})});var O,Rt=g(()=>{rt();O=U});var _t,Ut,Lt=g(()=>{_t=(t,e)=>{let r=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);r.width=t.dims[3],r.height=t.dims[2];let o=r.getContext("2d");if(o!=null){let n,a;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(n=t.dims[2],a=t.dims[3]):(n=t.dims[3],a=t.dims[2]);let s=e?.format!==void 0?e.format:"RGB",i=e?.norm,u,f;i===void 0||i.mean===void 0?u=[255,255,255,255]:typeof i.mean=="number"?u=[i.mean,i.mean,i.mean,i.mean]:(u=[i.mean[0],i.mean[1],i.mean[2],0],i.mean[3]!==void 0&&(u[3]=i.mean[3])),i===void 0||i.bias===void 0?f=[0,0,0,0]:typeof i.bias=="number"?f=[i.bias,i.bias,i.bias,i.bias]:(f=[i.bias[0],i.bias[1],i.bias[2],0],i.bias[3]!==void 0&&(f[3]=i.bias[3]));let c=a*n,l=0,d=c,p=c*2,h=-1;s==="RGBA"?(l=0,d=c,p=c*2,h=c*3):s==="RGB"?(l=0,d=c,p=c*2):s==="RBG"&&(l=0,p=c,d=c*2);for(let m=0;m<a;m++)for(let w=0;w<n;w++){let E=(t.data[l++]-f[0])*u[0],T=(t.data[d++]-f[1])*u[1],y=(t.data[p++]-f[2])*u[2],P=h===-1?255:(t.data[h++]-f[3])*u[3];o.fillStyle="rgba("+E+","+T+","+y+","+P+")",o.fillRect(w,m,1,1)}if("toDataURL"in r)return r.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},Ut=(t,e)=>{let r=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),o;if(r!=null){let n,a,s;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(n=t.dims[2],a=t.dims[1],s=t.dims[3]):(n=t.dims[3],a=t.dims[2],s=t.dims[1]);let i=e!==void 0&&e.format!==void 0?e.format:"RGB",u=e?.norm,f,c;u===void 0||u.mean===void 0?f=[255,255,255,255]:typeof u.mean=="number"?f=[u.mean,u.mean,u.mean,u.mean]:(f=[u.mean[0],u.mean[1],u.mean[2],255],u.mean[3]!==void 0&&(f[3]=u.mean[3])),u===void 0||u.bias===void 0?c=[0,0,0,0]:typeof u.bias=="number"?c=[u.bias,u.bias,u.bias,u.bias]:(c=[u.bias[0],u.bias[1],u.bias[2],0],u.bias[3]!==void 0&&(c[3]=u.bias[3]));let l=a*n;if(e!==void 0&&(e.format!==void 0&&s===4&&e.format!=="RGBA"||s===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let d=4,p=0,h=1,m=2,w=3,E=0,T=l,y=l*2,P=-1;i==="RGBA"?(E=0,T=l,y=l*2,P=l*3):i==="RGB"?(E=0,T=l,y=l*2):i==="RBG"&&(E=0,y=l,T=l*2),o=r.createImageData(n,a);for(let C=0;C<a*n;p+=d,h+=d,m+=d,w+=d,C++)o.data[p]=(t.data[E++]-c[0])*f[0],o.data[h]=(t.data[T++]-c[1])*f[1],o.data[m]=(t.data[y++]-c[2])*f[2],o.data[w]=P===-1?255:(t.data[P++]-c[3])*f[3]}else throw new Error("Can not access image data");return o}});var nt,Mt,kt,Dt,Nt,Ft=g(()=>{Pe();nt=(t,e)=>{if(t===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:r,width:o}=e,n=e.norm??{mean:255,bias:0},a,s;typeof n.mean=="number"?a=[n.mean,n.mean,n.mean,n.mean]:a=[n.mean[0],n.mean[1],n.mean[2],n.mean[3]??255],typeof n.bias=="number"?s=[n.bias,n.bias,n.bias,n.bias]:s=[n.bias[0],n.bias[1],n.bias[2],n.bias[3]??0];let i=e.format!==void 0?e.format:"RGBA",u=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",f=r*o,c=u==="RGBA"?new Float32Array(f*4):new Float32Array(f*3),l=4,d=0,p=1,h=2,m=3,w=0,E=f,T=f*2,y=-1;i==="RGB"&&(l=3,d=0,p=1,h=2,m=-1),u==="RGBA"?y=f*3:u==="RBG"?(w=0,T=f,E=f*2):u==="BGR"&&(T=0,E=f,w=f*2);for(let C=0;C<f;C++,d+=l,h+=l,p+=l,m+=l)c[w++]=(t[d]+s[0])/a[0],c[E++]=(t[p]+s[1])/a[1],c[T++]=(t[h]+s[2])/a[2],y!==-1&&m!==-1&&(c[y++]=(t[m]+s[3])/a[3]);return u==="RGBA"?new x("float32",c,[1,4,r,o]):new x("float32",c,[1,3,r,o])},Mt=async(t,e)=>{let r=typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement,o=typeof ImageData<"u"&&t instanceof ImageData,n=typeof ImageBitmap<"u"&&t instanceof ImageBitmap,a=typeof t=="string",s,i=e??{},u=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},f=c=>c instanceof HTMLCanvasElement||c instanceof OffscreenCanvas?c.getContext("2d"):null;if(r){let c=u();c.width=t.width,c.height=t.height;let l=f(c);if(l!=null){let d=t.height,p=t.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(d=e.resizedHeight,p=e.resizedWidth),e!==void 0){if(i=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");i.tensorFormat="RGBA",i.height=d,i.width=p}else i.tensorFormat="RGBA",i.height=d,i.width=p;l.drawImage(t,0,0),s=l.getImageData(0,0,p,d).data}else throw new Error("Can not access image data")}else if(o){let c,l;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?(c=e.resizedHeight,l=e.resizedWidth):(c=t.height,l=t.width),e!==void 0&&(i=e),i.format="RGBA",i.height=c,i.width=l,e!==void 0){let d=u();d.width=l,d.height=c;let p=f(d);if(p!=null)p.putImageData(t,0,0),s=p.getImageData(0,0,l,c).data;else throw new Error("Can not access image data")}else s=t.data}else if(n){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");let c=u();c.width=t.width,c.height=t.height;let l=f(c);if(l!=null){let d=t.height,p=t.width;return l.drawImage(t,0,0,p,d),s=l.getImageData(0,0,p,d).data,i.height=d,i.width=p,nt(s,i)}else throw new Error("Can not access image data")}else{if(a)return new Promise((c,l)=>{let d=u(),p=f(d);if(!t||!p)return l();let h=new Image;h.crossOrigin="Anonymous",h.src=t,h.onload=()=>{d.width=h.width,d.height=h.height,p.drawImage(h,0,0,d.width,d.height);let m=p.getImageData(0,0,d.width,d.height);i.height=d.height,i.width=d.width,c(nt(m.data,i))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(s!==void 0)return nt(s,i);throw new Error("Input data provided is not supported - aborted tensor creation")},kt=(t,e)=>{let{width:r,height:o,download:n,dispose:a}=e,s=[1,o,r,4];return new x({location:"texture",type:"float32",texture:t,dims:s,download:n,dispose:a})},Dt=(t,e)=>{let{dataType:r,dims:o,download:n,dispose:a}=e;return new x({location:"gpu-buffer",type:r??"float32",gpuBuffer:t,dims:o,download:n,dispose:a})},Nt=(t,e,r)=>new x({location:"cpu-pinned",type:t,data:e,dims:r??[e.length]})});var j,fe,Ht,zt,$t=g(()=>{j=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),fe=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),Ht=!1,zt=()=>{if(!Ht){Ht=!0;let t=typeof BigInt64Array<"u"&&BigInt64Array.from,e=typeof BigUint64Array<"u"&&BigUint64Array.from,r=typeof Float16Array<"u"&&Float16Array.from;t&&(j.set("int64",BigInt64Array),fe.set(BigInt64Array,"int64")),e&&(j.set("uint64",BigUint64Array),fe.set(BigUint64Array,"uint64")),r?(j.set("float16",Float16Array),fe.set(Float16Array,"float16")):j.set("float16",Uint16Array)}}});var Wt,Gt,jt=g(()=>{Pe();Wt=t=>{let e=1;for(let r=0;r<t.length;r++){let o=t[r];if(typeof o!="number"||!Number.isSafeInteger(o))throw new TypeError(`dims[${r}] must be an integer, got: ${o}`);if(o<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${o}`);e*=o}return e},Gt=(t,e)=>{switch(t.location){case"cpu":return new x(t.type,t.data,e);case"cpu-pinned":return new x({location:"cpu-pinned",data:t.data,type:t.type,dims:e});case"texture":return new x({location:"texture",texture:t.texture,type:t.type,dims:e});case"gpu-buffer":return new x({location:"gpu-buffer",gpuBuffer:t.gpuBuffer,type:t.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${t.location} is not supported`)}}});var x,Pe=g(()=>{Lt();Ft();$t();jt();x=class{constructor(e,r,o){zt();let n,a;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,n=e.type,a=e.dims,e.location){case"cpu-pinned":{let i=j.get(n);if(!i)throw new TypeError(`unsupported type "${n}" to create tensor from pinned buffer`);if(!(e.data instanceof i))throw new TypeError(`buffer should be of type ${i.name}`);this.cpuData=e.data;break}case"texture":{if(n!=="float32")throw new TypeError(`unsupported type "${n}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(n!=="float32"&&n!=="float16"&&n!=="int32"&&n!=="int64"&&n!=="uint32"&&n!=="uint8"&&n!=="bool")throw new TypeError(`unsupported type "${n}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let i,u;if(typeof e=="string")if(n=e,u=o,e==="string"){if(!Array.isArray(r))throw new TypeError("A string tensor's data must be a string array.");i=r}else{let f=j.get(e);if(f===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(r)){if(e==="float16"&&f===Uint16Array)throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");e==="uint64"||e==="int64"?i=f.from(r,BigInt):i=f.from(r)}else if(r instanceof f)i=r;else throw new TypeError(`A ${n} tensor's data must be type of ${f}`)}else if(u=r,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let f=typeof e[0];if(f==="string")n="string",i=e;else if(f==="boolean")n="bool",i=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${f}.`)}else{let f=fe.get(e.constructor);if(f===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);n=f,i=e}if(u===void 0)u=[i.length];else if(!Array.isArray(u))throw new TypeError("A tensor's dims must be a number array");a=u,this.cpuData=i,this.dataLocation="cpu"}let s=Wt(a);if(this.cpuData&&s!==this.cpuData.length)throw new Error(`Tensor's size(${s}) does not match data length(${this.cpuData.length}).`);this.type=n,this.dims=a,this.size=s}static async fromImage(e,r){return Mt(e,r)}static fromTexture(e,r){return kt(e,r)}static fromGpuBuffer(e,r){return Dt(e,r)}static fromPinnedBuffer(e,r,o){return Nt(e,r,o)}toDataURL(e){return _t(this,e)}toImageData(e){return Ut(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let r=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=r,e&&this.disposer&&(this.disposer(),this.disposer=void 0),r}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return Gt(this,e)}}});var I,ve=g(()=>{Pe();I=x});var ot,Vt,H,z,st=g(()=>{rt();ot=(t,e)=>{(typeof U.trace>"u"?!U.wasm.trace:!U.trace)||console.timeStamp(`${t}::ORT::${e}`)},Vt=(t,e)=>{let r=new Error().stack?.split(/\r\n|\r|\n/g)||[],o=!1;for(let n=0;n<r.length;n++){if(o&&!r[n].includes("TRACE_FUNC")){let a=`FUNC_${t}::${r[n].trim().split(" ")[1]}`;e&&(a+=`::${e}`),ot("CPU",a);return}r[n].includes("TRACE_FUNC")&&(o=!0)}},H=t=>{(typeof U.trace>"u"?!U.wasm.trace:!U.trace)||Vt("BEGIN",t)},z=t=>{(typeof U.trace>"u"?!U.wasm.trace:!U.trace)||Vt("END",t)}});var Ie,Yt=g(()=>{Ae();ve();st();Ie=class t{constructor(e){this.handler=e}async run(e,r,o){H();let n={},a={};if(typeof e!="object"||e===null||e instanceof I||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let s=!0;if(typeof r=="object"){if(r===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(r instanceof I)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(r)){if(r.length===0)throw new TypeError("'fetches' cannot be an empty array.");s=!1;for(let f of r){if(typeof f!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(f)===-1)throw new RangeError(`'fetches' contains invalid output name: ${f}.`);n[f]=null}if(typeof o=="object"&&o!==null)a=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else{let f=!1,c=Object.getOwnPropertyNames(r);for(let l of this.outputNames)if(c.indexOf(l)!==-1){let d=r[l];(d===null||d instanceof I)&&(f=!0,s=!1,n[l]=d)}if(f){if(typeof o=="object"&&o!==null)a=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else a=r}}else if(typeof r<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let f of this.inputNames)if(typeof e[f]>"u")throw new Error(`input '${f}' is missing in 'feeds'.`);if(s)for(let f of this.outputNames)n[f]=null;let i=await this.handler.run(e,n,a),u={};for(let f in i)if(Object.hasOwnProperty.call(i,f)){let c=i[f];c instanceof I?u[f]=c:u[f]=new I(c.type,c.data,c.dims)}return z(),u}async release(){return this.handler.dispose()}static async create(e,r,o,n){H();let a,s={};if(typeof e=="string"){if(a=e,typeof r=="object"&&r!==null)s=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(a=e,typeof r=="object"&&r!==null)s=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){let c=e,l=0,d=e.byteLength;if(typeof r=="object"&&r!==null)s=r;else if(typeof r=="number"){if(l=r,!Number.isSafeInteger(l))throw new RangeError("'byteOffset' must be an integer.");if(l<0||l>=c.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${c.byteLength}).`);if(d=e.byteLength-l,typeof o=="number"){if(d=o,!Number.isSafeInteger(d))throw new RangeError("'byteLength' must be an integer.");if(d<=0||l+d>c.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${c.byteLength-l}].`);if(typeof n=="object"&&n!==null)s=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(typeof o<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof r<"u")throw new TypeError("'options' must be an object.");a=new Uint8Array(c,l,d)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[i,u]=await Oe(s),f=await i.createInferenceSessionHandler(a,u);return z(),new t(f)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var qt,Jt=g(()=>{Yt();qt=Ie});var Xt=g(()=>{});var Kt=g(()=>{});var Qt=g(()=>{});var Zt=g(()=>{});var qr,xe,er=g(()=>{Ae();ve();qr="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",xe=class t{constructor(e,r,o){this.handler=e,this.hasOptimizerModel=r,this.hasEvalModel=o}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(e,r){let o=e.evalModel||"",n=e.optimizerModel||"",a=r||{},[s,i]=await Oe(a);if(s.createTrainingSessionHandler){let u=await s.createTrainingSessionHandler(e.checkpointState,e.trainModel,o,n,i);return new t(u,!!e.optimizerModel,!!e.evalModel)}else throw new Error(qr)}typeNarrowingForRunStep(e,r,o,n,a){let s={},i={};if(typeof o!="object"||o===null||o instanceof I||Array.isArray(o))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let u=!0;if(typeof n=="object"){if(n===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(n instanceof I)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(n)){if(n.length===0)throw new TypeError("'fetches' cannot be an empty array.");u=!1;for(let f of n){if(typeof f!="string")throw new TypeError("'fetches' must be a string array or an object.");if(r.indexOf(f)===-1)throw new RangeError(`'fetches' contains invalid output name: ${f}.`);s[f]=null}if(typeof a=="object"&&a!==null)i=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else{let f=!1,c=Object.getOwnPropertyNames(n);for(let l of r)if(c.indexOf(l)!==-1){let d=n[l];(d===null||d instanceof I)&&(f=!0,u=!1,s[l]=d)}if(f){if(typeof a=="object"&&a!==null)i=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else i=n}}else if(typeof n<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let f of e)if(typeof o[f]>"u")throw new Error(`input '${f}' is missing in 'feeds'.`);if(u)for(let f of r)s[f]=null;return[s,i]}convertHandlerReturnTypeToMapOfTensors(e){let r={};for(let o in e)if(Object.hasOwnProperty.call(e,o)){let n=e[o];n instanceof I?r[o]=n:r[o]=new I(n.type,n.data,n.dims)}return r}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(e,r,o){let[n,a]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,e,r,o),s=await this.handler.runTrainStep(e,n,a);return this.convertHandlerReturnTypeToMapOfTensors(s)}async runOptimizerStep(e){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(e||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(e,r,o){if(this.hasEvalModel){let[n,a]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,e,r,o),s=await this.handler.runEvalStep(e,n,a);return this.convertHandlerReturnTypeToMapOfTensors(s)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(e=!0){return this.handler.getParametersSize(e)}async loadParametersBuffer(e,r=!0){let o=await this.getParametersSize(r);if(e.length!==4*o)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(e,r)}async getContiguousParameters(e=!0){return this.handler.getContiguousParameters(e)}async release(){return this.handler.dispose()}}});var tr,rr=g(()=>{er();tr=xe});var at={};Ee(at,{InferenceSession:()=>qt,TRACE:()=>ot,TRACE_FUNC_BEGIN:()=>H,TRACE_FUNC_END:()=>z,Tensor:()=>I,TrainingSession:()=>tr,env:()=>O,registerBackend:()=>Q});var V=g(()=>{It();Rt();Jt();ve();Xt();Kt();st();Qt();Zt();rr()});var Ce=g(()=>{"use strict"});var ar={};Ee(ar,{default:()=>Jr});var or,sr,Jr,ir=g(()=>{"use strict";le();$();ce();or="ort-wasm-proxy-worker",sr=globalThis.self?.name===or;sr&&(self.onmessage=t=>{let{type:e,in:r}=t.data;try{switch(e){case"init-wasm":Be(r.wasm).then(()=>{Re(r).then(()=>{postMessage({type:e})},o=>{postMessage({type:e,err:o})})},o=>{postMessage({type:e,err:o})});break;case"init-ep":{let{epName:o,env:n}=r;_e(n,o).then(()=>{postMessage({type:e})},a=>{postMessage({type:e,err:a})});break}case"copy-from":{let{buffer:o}=r,n=Y(o);postMessage({type:e,out:n});break}case"create":{let{model:o,options:n}=r;Ue(o,n).then(a=>{postMessage({type:e,out:a})},a=>{postMessage({type:e,err:a})});break}case"release":Le(r),postMessage({type:e});break;case"run":{let{sessionId:o,inputIndices:n,inputs:a,outputIndices:s,options:i}=r;Me(o,n,a,s,new Array(s.length).fill(null),i).then(u=>{u.some(f=>f[3]!=="cpu")?postMessage({type:e,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:e,out:u},De([...a,...u]))},u=>{postMessage({type:e,err:u})});break}case"end-profiling":ke(r),postMessage({type:e});break;default:}}catch(o){postMessage({type:e,err:o})}});Jr=sr?null:t=>new Worker(t??M,{type:"classic",name:or})});var M,Xr,fr,Kr,Qr,cr,Zr,ur,lr,dr,ce=g(()=>{"use strict";Ce();M=!1?void 0:typeof document<"u"?document.currentScript?.src:typeof self<"u"?self.location?.href:void 0,Xr=!1||typeof location>"u"?void 0:location.origin,fr=(t,e)=>{try{let r=e??M;return(r?new URL(t,r):new URL(t)).origin===Xr}catch{return!1}},Kr=(t,e)=>{let r=e??M;try{return(r?new URL(t,r):new URL(t)).href}catch{return}},Qr=(t,e)=>`${e??"./"}${t}`,cr=async t=>{let r=await(await fetch(t,{credentials:"same-origin"})).blob();return URL.createObjectURL(r)},Zr=async t=>(await import(/*webpackIgnore:true*/t)).default,ur=(ir(),tt(ar)).default,lr=async()=>{if(!M)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(fr(M))return[void 0,ur()];let t=await cr(M);return[t,ur(t)]},dr=async(t,e,r)=>{let o="ort-training-wasm-simd-threaded.mjs",n=t??Kr(o,e),a=!!1&&r&&n&&!fr(n,e),s=a?await cr(n):n??Qr(o,e);return[a?s:void 0,await Zr(s)]}});var it,ut,Ne,pr,en,tn,Be,b,$=g(()=>{"use strict";ce();ut=!1,Ne=!1,pr=!1,en=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},tn=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Be=async t=>{if(ut)return Promise.resolve();if(Ne)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(pr)throw new Error("previous call to 'initializeWebAssembly()' failed.");Ne=!0;let e=t.initTimeout,r=t.numThreads;if(!tn())throw new Error("WebAssembly SIMD is not supported in the current environment.");let o=en();r>1&&!o&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+r+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),t.numThreads=r=1);let n=t.wasmPaths,a=typeof n=="string"?n:void 0,s=n?.mjs,i=s?.href??s,u=n?.wasm,f=u?.href??u,[c,l]=await dr(i,a,r>1),d=!1,p=[];if(e>0&&p.push(new Promise(h=>{setTimeout(()=>{d=!0,h()},e)})),p.push(new Promise((h,m)=>{l({numThreads:r,locateFile:(E,T)=>f??(a??T)+E}).then(E=>{Ne=!1,ut=!0,it=E,h(),c&&URL.revokeObjectURL(c)},E=>{Ne=!1,pr=!0,m(E)})})),await Promise.race(p),d)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},b=()=>{if(ut&&it)return it;throw new Error("WebAssembly is not initialized yet.")}});var v,de,A,pe=g(()=>{"use strict";$();v=(t,e)=>{let r=b(),o=r.lengthBytesUTF8(t)+1,n=r._malloc(o);return r.stringToUTF8(t,n,o),e.push(n),n},de=(t,e,r,o)=>{if(typeof t=="object"&&t!==null){if(r.has(t))throw new Error("Circular reference in options");r.add(t)}Object.entries(t).forEach(([n,a])=>{let s=e?e+n:n;if(typeof a=="object")de(a,s+".",r,o);else if(typeof a=="string"||typeof a=="number")o(s,a.toString());else if(typeof a=="boolean")o(s,a?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof a}`)})},A=t=>{let e=b(),r=e.stackSave();try{let o=e.stackAlloc(8);e._OrtGetLastError(o,o+4);let n=e.HEAP32[o/4],a=e.HEAPU32[o/4+1],s=a?e.UTF8ToString(a):"";throw new Error(`${t} ERROR_CODE: ${n}, ERROR_MESSAGE: ${s}`)}finally{e.stackRestore(r)}}});var Z,ft=g(()=>{"use strict";$();pe();Z=t=>{let e=b(),r=0,o=[],n=t||{};try{if(t?.logSeverityLevel===void 0)n.logSeverityLevel=2;else if(typeof t.logSeverityLevel!="number"||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(t?.logVerbosityLevel===void 0)n.logVerbosityLevel=0;else if(typeof t.logVerbosityLevel!="number"||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);t?.terminate===void 0&&(n.terminate=!1);let a=0;return t?.tag!==void 0&&(a=v(t.tag,o)),r=e._OrtCreateRunOptions(n.logSeverityLevel,n.logVerbosityLevel,!!n.terminate,a),r===0&&A("Can't create run options."),t?.extra!==void 0&&de(t.extra,"",new WeakSet,(s,i)=>{let u=v(s,o),f=v(i,o);e._OrtAddRunConfigEntry(r,u,f)!==0&&A(`Can't set a run config entry: ${s} - ${i}.`)}),[r,o]}catch(a){throw r!==0&&e._OrtReleaseRunOptions(r),o.forEach(s=>e._free(s)),a}}});var rn,nn,on,sn,Fe,ct=g(()=>{"use strict";$();pe();rn=t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}},nn=t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}},on=t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});let e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1"),t.executionProviders&&t.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(t.enableMemPattern=!1)},sn=(t,e,r)=>{for(let o of e){let n=typeof o=="string"?o:o.name;switch(n){case"webnn":if(n="WEBNN",typeof o!="string"){let s=o,i=s?.deviceType,u=s?.numThreads,f=s?.powerPreference;if(i){let c=v("deviceType",r),l=v(i,r);b()._OrtAddSessionConfigEntry(t,c,l)!==0&&A(`Can't set a session config entry: 'deviceType' - ${i}.`)}if(u!==void 0){let c=typeof u!="number"||!Number.isInteger(u)||u<0?0:u,l=v("numThreads",r),d=v(c.toString(),r);b()._OrtAddSessionConfigEntry(t,l,d)!==0&&A(`Can't set a session config entry: 'numThreads' - ${u}.`)}if(f){let c=v("powerPreference",r),l=v(f,r);b()._OrtAddSessionConfigEntry(t,c,l)!==0&&A(`Can't set a session config entry: 'powerPreference' - ${f}.`)}}break;case"webgpu":if(n="JS",typeof o!="string"){let s=o;if(s?.preferredLayout){if(s.preferredLayout!=="NCHW"&&s.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${s.preferredLayout}`);let i=v("preferredLayout",r),u=v(s.preferredLayout,r);b()._OrtAddSessionConfigEntry(t,i,u)!==0&&A(`Can't set a session config entry: 'preferredLayout' - ${s.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${n}`)}let a=v(n,r);b()._OrtAppendExecutionProvider(t,a)!==0&&A(`Can't append execution provider: ${n}.`)}},Fe=t=>{let e=b(),r=0,o=[],n=t||{};on(n);try{let a=rn(n.graphOptimizationLevel??"all"),s=nn(n.executionMode??"sequential"),i=typeof n.logId=="string"?v(n.logId,o):0,u=n.logSeverityLevel??2;if(!Number.isInteger(u)||u<0||u>4)throw new Error(`log serverity level is not valid: ${u}`);let f=n.logVerbosityLevel??0;if(!Number.isInteger(f)||f<0||f>4)throw new Error(`log verbosity level is not valid: ${f}`);let c=typeof n.optimizedModelFilePath=="string"?v(n.optimizedModelFilePath,o):0;if(r=e._OrtCreateSessionOptions(a,!!n.enableCpuMemArena,!!n.enableMemPattern,s,!!n.enableProfiling,0,i,u,f,c),r===0&&A("Can't create session options."),n.executionProviders&&sn(r,n.executionProviders,o),n.enableGraphCapture!==void 0){if(typeof n.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${n.enableGraphCapture}`);let l=v("enableGraphCapture",o),d=v(n.enableGraphCapture.toString(),o);e._OrtAddSessionConfigEntry(r,l,d)!==0&&A(`Can't set a session config entry: 'enableGraphCapture' - ${n.enableGraphCapture}.`)}if(n.freeDimensionOverrides)for(let[l,d]of Object.entries(n.freeDimensionOverrides)){if(typeof l!="string")throw new Error(`free dimension override name must be a string: ${l}`);if(typeof d!="number"||!Number.isInteger(d)||d<0)throw new Error(`free dimension override value must be a non-negative integer: ${d}`);let p=v(l,o);e._OrtAddFreeDimensionOverride(r,p,d)!==0&&A(`Can't set a free dimension override: ${l} - ${d}.`)}return n.extra!==void 0&&de(n.extra,"",new WeakSet,(l,d)=>{let p=v(l,o),h=v(d,o);e._OrtAddSessionConfigEntry(r,p,h)!==0&&A(`Can't set a session config entry: ${l} - ${d}.`)}),[r,o]}catch(a){throw r!==0&&e._OrtReleaseSessionOptions(r),o.forEach(s=>e._free(s)),a}}});var ee,He,lt,me,mr,ze,he,$e=g(()=>{"use strict";ee=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},He=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},lt=t=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][t],me=t=>{switch(t){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}},mr=t=>{switch(t){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${t}`)}},ze=t=>t==="float32"||t==="float16"||t==="int32"||t==="int64"||t==="uint32"||t==="uint8"||t==="bool",he=t=>{switch(t){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${t}`)}}});var ye,dt=g(()=>{"use strict";Ce();ye=async t=>{if(typeof t=="string")if(!1)try{let{readFile:e}=et("node:fs/promises");return new Uint8Array(await e(t))}catch(e){if(e.code==="ERR_FS_FILE_TOO_LARGE"){let{createReadStream:r}=et("node:fs"),o=r(t),n=[];for await(let a of o)n.push(a);return new Uint8Array(Buffer.concat(n))}throw e}else{let e=await fetch(t);if(!e.ok)throw new Error(`failed to load external data file: ${t}`);let r=e.headers.get("Content-Length"),o=r?parseInt(r,10):0;if(o<1073741824)return new Uint8Array(await e.arrayBuffer());{if(!e.body)throw new Error(`failed to load external data file: ${t}, no response body.`);let n=e.body.getReader(),a;try{a=new ArrayBuffer(o)}catch(i){if(i instanceof RangeError){let u=Math.ceil(o/65536);a=new WebAssembly.Memory({initial:u,maximum:u}).buffer}else throw i}let s=0;for(;;){let{done:i,value:u}=await n.read();if(i)break;let f=u.byteLength;new Uint8Array(a,s,f).set(u),s+=f}return new Uint8Array(a,0,o)}}else return t instanceof Blob?new Uint8Array(await t.arrayBuffer()):t instanceof Uint8Array?t:new Uint8Array(t)}});var an,Re,_e,te,un,Y,Ue,Le,We,Me,ke,De,le=g(()=>{"use strict";ft();ct();$e();$();pe();dt();an=(t,e)=>{b()._OrtInit(t,e)!==0&&A("Can't initialize onnxruntime.")},Re=async t=>{an(t.wasm.numThreads,mr(t.logLevel))},_e=async(t,e)=>{},te=new Map,un=t=>{let e=b(),r=e.stackSave();try{let o=e.stackAlloc(8);return e._OrtGetInputOutputCount(t,o,o+4)!==0&&A("Can't get session input/output count."),[e.HEAP32[o/4],e.HEAP32[o/4+1]]}finally{e.stackRestore(r)}},Y=t=>{let e=b(),r=e._malloc(t.byteLength);if(r===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${t.byteLength}.`);return e.HEAPU8.set(t,r),[r,t.byteLength]},Ue=async(t,e)=>{let r,o,n=b();Array.isArray(t)?[r,o]=t:t.buffer===n.HEAPU8.buffer?[r,o]=[t.byteOffset,t.byteLength]:[r,o]=Y(t);let a=0,s=0,i=0,u=[],f=[],c=[];try{if([s,u]=Fe(e),e?.externalData&&n.mountExternalData){let T=[];for(let y of e.externalData){let P=typeof y=="string"?y:y.path;T.push(ye(typeof y=="string"?y:y.data).then(C=>{n.mountExternalData(P,C)}))}await Promise.all(T)}a=await n._OrtCreateSession(r,o,s),a===0&&A("Can't create a session.");let[l,d]=un(a),p=!!e?.enableGraphCapture,h=[],m=[],w=[];for(let T=0;T<l;T++){let y=n._OrtGetInputName(a,T);y===0&&A("Can't get an input name."),f.push(y),h.push(n.UTF8ToString(y))}for(let T=0;T<d;T++){let y=n._OrtGetOutputName(a,T);y===0&&A("Can't get an output name."),c.push(y);let P=n.UTF8ToString(y);m.push(P)}let E=null;return te.set(a,[a,f,c,E,p,!1]),[a,h,m]}catch(l){throw f.forEach(d=>n._OrtFree(d)),c.forEach(d=>n._OrtFree(d)),i!==0&&n._OrtReleaseBinding(i),a!==0&&n._OrtReleaseSession(a),l}finally{n._free(r),s!==0&&n._OrtReleaseSessionOptions(s),u.forEach(l=>n._free(l)),n.unmountExternalData?.()}},Le=t=>{let e=b(),r=te.get(t);if(!r)throw new Error(`cannot release session. invalid session id: ${t}`);let[o,n,a,s,i]=r;s&&(i&&e._OrtClearBoundOutputs(s.handle),e._OrtReleaseBinding(s.handle)),e.jsepOnReleaseSession?.(t),n.forEach(u=>e._OrtFree(u)),a.forEach(u=>e._OrtFree(u)),e._OrtReleaseSession(o),te.delete(t)},We=(t,e,r,o,n,a=!1)=>{if(!t){e.push(0);return}let s=b(),i=t[0],u=t[1],f=t[3],c,l;if(i==="string"&&f==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(a&&f!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${n} when enableGraphCapture is true.`);if(f==="gpu-buffer"){let h=t[2].gpuBuffer,m=lt(ee(i));l=u.reduce((E,T)=>E*T,1)*m;let w=s.jsepRegisterBuffer;if(!w)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');c=w(o,n,h,l)}else{let h=t[2];if(Array.isArray(h)){l=4*h.length,c=s._malloc(l),r.push(c);let m=c/4;for(let w=0;w<h.length;w++){if(typeof h[w]!="string")throw new TypeError(`tensor data at index ${w} is not a string`);s.HEAPU32[m++]=v(h[w],r)}}else l=h.byteLength,c=s._malloc(l),r.push(c),s.HEAPU8.set(new Uint8Array(h.buffer,h.byteOffset,l),c)}let d=s.stackSave(),p=s.stackAlloc(4*u.length);try{let h=p/4;u.forEach(w=>s.HEAP32[h++]=w);let m=s._OrtCreateTensor(ee(i),c,l,p,u.length,he(f));m===0&&A(`Can't create tensor for input/output. session=${o}, index=${n}.`),e.push(m)}finally{s.stackRestore(d)}},Me=async(t,e,r,o,n,a)=>{let s=b(),i=te.get(t);if(!i)throw new Error(`cannot run inference. invalid session id: ${t}`);let u=i[0],f=i[1],c=i[2],l=i[3],d=i[4],p=i[5],h=e.length,m=o.length,w=0,E=[],T=[],y=[],P=[],C=s.stackSave(),oe=s.stackAlloc(h*4),ge=s.stackAlloc(h*4),Qe=s.stackAlloc(m*4),Tt=s.stackAlloc(m*4);try{[w,E]=Z(a);for(let S=0;S<h;S++)We(r[S],T,P,t,e[S],d);for(let S=0;S<m;S++)We(n[S],y,P,t,h+o[S],d);let N=oe/4,Nr=ge/4,Fr=Qe/4,Hr=Tt/4;for(let S=0;S<h;S++)s.HEAPU32[N++]=T[S],s.HEAPU32[Nr++]=f[e[S]];for(let S=0;S<m;S++)s.HEAPU32[Fr++]=y[S],s.HEAPU32[Hr++]=c[o[S]];s.jsepOnRunStart?.(u);let Et;Et=await s._OrtRun(u,ge,oe,h,Tt,m,Qe,w),Et!==0&&A("failed to call OrtRun().");let se=[];for(let S=0;S<m;S++){let ae=s.HEAPU32[Qe/4+S];if(ae===y[S]){se.push(n[S]);continue}let St=s.stackSave(),W=s.stackAlloc(4*4),be=!1,L,F=0;try{s._OrtGetTensorData(ae,W,W+4,W+8,W+12)!==0&&A(`Can't access output tensor data on index ${S}.`);let Te=W/4,Ot=s.HEAPU32[Te++];F=s.HEAPU32[Te++];let At=s.HEAPU32[Te++],zr=s.HEAPU32[Te++],ie=[];for(let R=0;R<zr;R++)ie.push(s.HEAPU32[At/4+R]);s._OrtFree(At);let ue=ie.reduce((R,_)=>R*_,1);L=He(Ot);let Pt=l?.outputPreferredLocations[o[S]];if(L==="string"){if(Pt==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let R=[],_=F/4;for(let K=0;K<ue;K++){let vt=s.HEAPU32[_++],$r=K===ue-1?void 0:s.HEAPU32[_]-vt;R.push(s.UTF8ToString(vt,$r))}se.push([L,ie,R,"cpu"])}else if(Pt==="gpu-buffer"&&ue>0){let R=s.jsepGetBuffer;if(!R)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let _=R(F),K=lt(Ot);if(K===void 0||!ze(L))throw new Error(`Unsupported data type: ${L}`);be=!0,se.push([L,ie,{gpuBuffer:_,download:s.jsepCreateDownloader(_,ue*K,L),dispose:()=>{s._OrtReleaseTensor(ae)}},"gpu-buffer"])}else{let R=me(L),_=new R(ue);new Uint8Array(_.buffer,_.byteOffset,_.byteLength).set(s.HEAPU8.subarray(F,F+_.byteLength)),se.push([L,ie,_,"cpu"])}}finally{s.stackRestore(St),L==="string"&&F&&s._free(F),be||s._OrtReleaseTensor(ae)}}return l&&!d&&(s._OrtClearBoundOutputs(l.handle),te.set(t,[u,f,c,l,d,!1])),se}finally{s.stackRestore(C),T.forEach(N=>s._OrtReleaseTensor(N)),y.forEach(N=>s._OrtReleaseTensor(N)),P.forEach(N=>s._free(N)),w!==0&&s._OrtReleaseRunOptions(w),E.forEach(N=>s._free(N))}},ke=t=>{let e=b(),r=te.get(t);if(!r)throw new Error("invalid session id");let o=r[0],n=e._OrtEndProfiling(o);n===0&&A("Can't get an profile file name."),e._OrtFree(n)},De=t=>{let e=[];for(let r of t){let o=r[2];!Array.isArray(o)&&"buffer"in o&&e.push(o.buffer)}return e}});var J,k,we,je,Ve,Ge,pt,mt,re,ne,cn,hr,yr,wr,gr,br,Tr,Er,ht=g(()=>{"use strict";V();le();$();ce();J=()=>!!O.wasm.proxy&&typeof document<"u",we=!1,je=!1,Ve=!1,mt=new Map,re=(t,e)=>{let r=mt.get(t);r?r.push(e):mt.set(t,[e])},ne=()=>{if(we||!je||Ve||!k)throw new Error("worker not ready")},cn=t=>{switch(t.data.type){case"init-wasm":we=!1,t.data.err?(Ve=!0,pt[1](t.data.err)):(je=!0,pt[0]()),Ge&&(URL.revokeObjectURL(Ge),Ge=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let e=mt.get(t.data.type);t.data.err?e.shift()[1](t.data.err):e.shift()[0](t.data.out);break}default:}},hr=async()=>{if(!je){if(we)throw new Error("multiple calls to 'initWasm()' detected.");if(Ve)throw new Error("previous call to 'initWasm()' failed.");if(we=!0,J())return new Promise((t,e)=>{k?.terminate(),lr().then(([r,o])=>{try{k=o,k.onerror=a=>e(a),k.onmessage=cn,pt=[t,e];let n={type:"init-wasm",in:O};k.postMessage(n),Ge=r}catch(n){e(n)}},e)});try{await Be(O.wasm),await Re(O),je=!0}catch(t){throw Ve=!0,t}finally{we=!1}}},yr=async t=>{if(J())return ne(),new Promise((e,r)=>{re("init-ep",[e,r]);let o={type:"init-ep",in:{epName:t,env:O}};k.postMessage(o)});await _e(O,t)},wr=async t=>J()?(ne(),new Promise((e,r)=>{re("copy-from",[e,r]);let o={type:"copy-from",in:{buffer:t}};k.postMessage(o,[t.buffer])})):Y(t),gr=async(t,e)=>{if(J()){if(e?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return ne(),new Promise((r,o)=>{re("create",[r,o]);let n={type:"create",in:{model:t,options:{...e}}},a=[];t instanceof Uint8Array&&a.push(t.buffer),k.postMessage(n,a)})}else return Ue(t,e)},br=async t=>{if(J())return ne(),new Promise((e,r)=>{re("release",[e,r]);let o={type:"release",in:t};k.postMessage(o)});Le(t)},Tr=async(t,e,r,o,n,a)=>{if(J()){if(r.some(s=>s[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(n.some(s=>s))throw new Error("pre-allocated output tensor is not supported for proxy.");return ne(),new Promise((s,i)=>{re("run",[s,i]);let u=r,f={type:"run",in:{sessionId:t,inputIndices:e,inputs:u,outputIndices:o,options:a}};k.postMessage(f,De(u))})}else return Me(t,e,r,o,n,a)},Er=async t=>{if(J())return ne(),new Promise((e,r)=>{re("end-profiling",[e,r]);let o={type:"end-profiling",in:t};k.postMessage(o)});ke(t)}});var X,qe,Ye,yt=g(()=>{"use strict";V();ht();$e();Ce();dt();X=(t,e)=>{switch(t.location){case"cpu":return[t.type,t.dims,t.data,"cpu"];case"gpu-buffer":return[t.type,t.dims,{gpuBuffer:t.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${t.location} for ${e()}`)}},qe=t=>{switch(t[3]){case"cpu":return new I(t[0],t[2],t[1]);case"gpu-buffer":{let e=t[0];if(!ze(e))throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);let{gpuBuffer:r,download:o,dispose:n}=t[2];return I.fromGpuBuffer(r,{dataType:e,dims:t[1],download:o,dispose:n})}default:throw new Error(`invalid data location: ${t[3]}`)}},Ye=class{async fetchModelAndCopyToWasmMemory(e){return wr(await ye(e))}async loadModel(e,r){H();let o;typeof e=="string"?!1?o=await ye(e):o=await this.fetchModelAndCopyToWasmMemory(e):o=e,[this.sessionId,this.inputNames,this.outputNames]=await gr(o,r),z()}async dispose(){return br(this.sessionId)}async run(e,r,o){H();let n=[],a=[];Object.entries(e).forEach(d=>{let p=d[0],h=d[1],m=this.inputNames.indexOf(p);if(m===-1)throw new Error(`invalid input '${p}'`);n.push(h),a.push(m)});let s=[],i=[];Object.entries(r).forEach(d=>{let p=d[0],h=d[1],m=this.outputNames.indexOf(p);if(m===-1)throw new Error(`invalid output '${p}'`);s.push(h),i.push(m)});let u=n.map((d,p)=>X(d,()=>`input "${this.inputNames[a[p]]}"`)),f=s.map((d,p)=>d?X(d,()=>`output "${this.outputNames[i[p]]}"`):null),c=await Tr(this.sessionId,a,u,i,f,o),l={};for(let d=0;d<c.length;d++)l[this.outputNames[i[d]]]=s[d]??qe(c[d]);return z(),l}startProfiling(){}endProfiling(){Er(this.sessionId)}}});var ln,Je,Sr=g(()=>{"use strict";V();ht();yt();ce();ln=()=>{if((typeof O.wasm.initTimeout!="number"||O.wasm.initTimeout<0)&&(O.wasm.initTimeout=0),O.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof O.wasm.proxy!="boolean"&&(O.wasm.proxy=!1),typeof O.wasm.trace!="boolean"&&(O.wasm.trace=!1),typeof O.wasm.numThreads!="number"||!Number.isInteger(O.wasm.numThreads)||O.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)O.wasm.numThreads=1;else{let t=typeof navigator>"u"?et("node:os").cpus().length:navigator.hardwareConcurrency;O.wasm.numThreads=Math.min(4,Math.ceil((t||1)/2))}O.wasm.wasmPaths===void 0&&M&&M.indexOf("blob:")!==0&&(O.wasm.wasmPaths=M.substring(0,M.lastIndexOf("/")+1))},Je=class{async init(e){ln(),await hr(),await yr(e)}async createInferenceSessionHandler(e,r){let o=new Ye;return await o.loadModel(e,r),Promise.resolve(o)}}});var D,B,Ar,dn,Or,wt,Pr,Xe,vr,Ir,xr,Cr,Br,gt,Rr,_r,Ur,Lr=g(()=>{"use strict";ft();ct();$e();le();$();pe();D="Built without training API's enabled. Use the onnxruntime-web/training import for training functionality, and make sure that all the correct artifacts are built & moved to the correct folder if using a custom build. Check https://onnxruntime.ai/docs/build/web.html for more information.",B=(t,e,r=!0)=>{r&&t!==0?A(e):!r&&t===0&&A(e)},Ar=t=>{let e=b(),[r,o]=t,n=0;try{if(e._OrtTrainingLoadCheckpoint)n=e._OrtTrainingLoadCheckpoint(r,o);else throw new Error(D);return B(n,"Error occurred when trying to create a CheckpointState",!1),n}catch(a){throw e._OrtTrainingReleaseCheckpoint&&n!==0&&e._OrtTrainingReleaseCheckpoint(n),a}finally{e._OrtFree(t[0])}},dn=(t,e)=>{let r=b(),o=r.stackSave();try{let n=r.stackAlloc(8);if(r._OrtTrainingGetModelInputOutputCount){let a=r._OrtTrainingGetModelInputOutputCount(t,n,n+4,e);return B(a,"Can't get session input/output count."),[r.HEAP32[n/4],r.HEAP32[n/4+1]]}else throw new Error(D)}finally{r.stackRestore(o)}},Or=(t,e,r,o)=>{let n=[],a=b();for(let s=0;s<e;s++)if(a._OrtTrainingGetModelInputOutputName){let i=a._OrtTrainingGetModelInputOutputName(t,s,r,o);B(i,`Can't get input or output name -- is input: ${r}, index ${s}`,!1),n.push(a.UTF8ToString(i)),a._free(i)}else throw new Error(D);return n},wt=(t,e)=>{let r=[],o=[],[n,a]=dn(t,e);return r=Or(t,n,!0,e),o=Or(t,a,!1,e),[r,o]},Pr=(t,e,r,o,n)=>{let a=b(),s=0,i=0,u=[];try{if([i,u]=Fe(n),a._OrtTrainingCreateSession)s=a._OrtTrainingCreateSession(i,t,e[0],e[1],r[0],r[1],o[0],o[1]);else throw new Error(D);return B(s,"Error occurred when trying to create a TrainingSession",!1),s}catch(f){throw a._OrtTrainingReleaseSession&&s!==0&&a._OrtTrainingReleaseSession(s),f}finally{a._free(e[0]),a._free(r[0]),a._free(o[0]),i!==0&&a._OrtReleaseSessionOptions(i),u.forEach(f=>a._free(f))}},Xe=(t,e,r,o,n,a)=>{let s=e.length;for(let c=0;c<s;c++)We(r[c],o,n,t,a+e[c]);let i=b(),u=i.stackAlloc(s*4),f=u/4;for(let c=0;c<s;c++)i.HEAPU32[f++]=o[c];return u},vr=(t,e,r,o)=>{let n=b(),a=[];for(let s=0;s<e;s++){let i=n.HEAPU32[t/4+s];if(i===r[s]){a.push(o[s]);continue}let u=n.stackSave(),f=n.stackAlloc(4*4),c,l=0;try{let d=n._OrtGetTensorData(i,f,f+4,f+8,f+12);B(d,`Can't access output tensor data on index ${s}.`);let p=f/4,h=n.HEAPU32[p++];l=n.HEAPU32[p++];let m=n.HEAPU32[p++],w=n.HEAPU32[p++],E=[];for(let y=0;y<w;y++)E.push(n.HEAPU32[m/4+y]);n._OrtFree(m);let T=E.reduce((y,P)=>y*P,1);if(c=He(h),c==="string"){let y=[],P=l/4;for(let C=0;C<T;C++){let oe=n.HEAPU32[P++],ge=C===T-1?void 0:n.HEAPU32[P]-oe;y.push(n.UTF8ToString(oe,ge))}a.push([c,E,y,"cpu"])}else{let y=me(c),P=new y(T);new Uint8Array(P.buffer,P.byteOffset,P.byteLength).set(n.HEAPU8.subarray(l,l+P.byteLength)),a.push([c,E,P,"cpu"])}}finally{n.stackRestore(u),c==="string"&&l&&n._free(l),n._OrtReleaseTensor(i)}}return a},Ir=async t=>{let e=b();if(e._OrtTrainingLazyResetGrad){let r=e._OrtTrainingLazyResetGrad(t);B(r,"Can't call lazyResetGrad.")}else throw new Error(D)},xr=async(t,e,r,o,n,a)=>{let s=b(),i=e.length,u=o.length,f=0,c=[],l=[],d=[],p=[],h=s.stackSave();try{[f,c]=Z(a);let m=Xe(t,e,r,l,p,0),w=Xe(t,o,n,d,p,i);if(s._OrtTrainingRunTrainStep){let E=s._OrtTrainingRunTrainStep(t,m,i,w,u,f);B(E,"failed to call OrtTrainingRunTrainStep in the WebAssembly layer")}else throw new Error(D);return vr(w,u,d,n)}finally{s.stackRestore(h),l.forEach(m=>s._OrtReleaseTensor(m)),d.forEach(m=>s._OrtReleaseTensor(m)),p.forEach(m=>s._free(m)),f!==0&&s._OrtReleaseRunOptions(f),c.forEach(m=>s._free(m))}},Cr=async(t,e)=>{let r=b(),o=0,n=[];try{if([o,n]=Z(e),r._OrtTrainingOptimizerStep){let a=r._OrtTrainingOptimizerStep(t,o);B(a,"Failed to call OrtTrainingOptimizerStep in the WebAssembly layer")}else throw new Error(D)}finally{o!==0&&r._OrtReleaseRunOptions(o),n.forEach(a=>r._free(a))}},Br=async(t,e,r,o,n,a)=>{let s=b(),i=e.length,u=o.length,f=0,c=[],l=[],d=[],p=[],h=s.stackSave();try{[f,c]=Z(a);let m=Xe(t,e,r,l,p,0),w=Xe(t,o,n,d,p,i);if(s._OrtTrainingEvalStep){let E=s._OrtTrainingEvalStep(t,m,i,w,u,f);B(E,"failed to call OrtTrainingEvalStep in the WebAssembly layer")}else throw new Error(D);return vr(w,u,d,n)}finally{s.stackRestore(h),l.forEach(m=>s._OrtReleaseTensor(m)),d.forEach(m=>s._OrtReleaseTensor(m)),p.forEach(m=>s._free(m)),f!==0&&s._OrtReleaseRunOptions(f),c.forEach(m=>s._free(m))}},gt=(t,e)=>{let r=b(),o=r.stackSave();try{let n=r.stackAlloc(4);if(r._OrtTrainingGetParametersSize){let a=r._OrtTrainingGetParametersSize(t,n,e);return B(a,"Can't get parameters size"),r.HEAP32[n/4]}else throw new Error(D)}finally{r.stackRestore(o)}},Rr=async(t,e)=>{let r=b(),o=r.stackSave(),n="float32",a="cpu",s=gt(t,e),i=0,u=4*s,f=r._malloc(u),c=[s],l=r.stackAlloc(4),d=l/4;r.HEAP32[d]=s;try{if(i=r._OrtCreateTensor(ee(n),f,u,l,c.length,he(a)),B(i,`Can't create tensor for getContiguousParameters. session=${t}.`,!1),r._OrtTrainingCopyParametersToBuffer){let w=r._OrtTrainingCopyParametersToBuffer(t,i,s,e);B(w,"Can't get contiguous parameters.")}else throw new Error(D);let p=me(n),h=new p(s),m=[];if(new Uint8Array(h.buffer,h.byteOffset,h.byteLength).set(r.HEAPU8.subarray(f,f+u)),m.push([n,c,h,a]),m.length!==1)throw new Error(`something unexpected happened in the getContiguousParameters function. Expected output length of
     one, got ${m.length}`);return m[0]}finally{i!==0&&r._OrtReleaseTensor(i),r._free(f),r._free(l),r.stackRestore(o)}},_r=async(t,e,r)=>{let o=b(),n=o.stackSave(),a="float32",s="cpu",i=e.length,u=i/4,f=o._malloc(i);o.HEAPU8.set(e,f);let c=o.stackAlloc(4);o.HEAP32[c/4]=u;let l=1,d=0;try{if(d=o._OrtCreateTensor(ee(a),f,i,c,l,he(s)),B(d,`Can't create tensor for input/output. session=${t}`,!1),o._OrtTrainingCopyParametersFromBuffer){let p=o._OrtTrainingCopyParametersFromBuffer(t,d,u,r);B(p,"Can't copy buffer to parameters.")}else throw new Error(D)}finally{d!==0&&o._OrtReleaseTensor(d),o.stackRestore(n),o._free(f),o._free(c)}},Ur=(t,e)=>{let r=b();r._OrtTrainingReleaseSession&&r._OrtTrainingReleaseSession(e),r._OrtTrainingReleaseCheckpoint&&r._OrtTrainingReleaseCheckpoint(t)}});var Ke,Mr=g(()=>{"use strict";yt();le();Lr();Ke=class{constructor(){this.evalInputNames=[];this.evalOutputNames=[]}async uriOrBufferToHeap(e){let r;if(typeof e=="string"){let n=await(await fetch(e)).arrayBuffer();r=new Uint8Array(n)}else r=e;return Y(r)}async createTrainingSession(e,r,o,n,a){let s=await this.uriOrBufferToHeap(e),i=await this.uriOrBufferToHeap(r),u=[0,0],f=[0,0];o!==""&&(u=await this.uriOrBufferToHeap(o)),n!==""&&(f=await this.uriOrBufferToHeap(n)),this.checkpointId=Ar(s),this.sessionId=Pr(this.checkpointId,i,u,f,a),[this.inputNames,this.outputNames]=wt(this.sessionId,!1),o!==""&&([this.evalInputNames,this.evalOutputNames]=wt(this.sessionId,!0))}convertMapIntoValuesArrayAndIndicesArray(e,r,o){let n=[],a=[];Object.entries(e).forEach(i=>{let u=i[0],f=i[1],c=r.indexOf(u);if(c===-1)throw new Error(`invalid input '${u}`);n.push(f),a.push(c)});let s=n.map(o);return[n,a,s]}convertTensorMetadataToReturnType(e,r,o){let n={};for(let a=0;a<e.length;a++)n[this.outputNames[o[a]]]=r[a]??qe(e[a]);return n}async lazyResetGrad(){await Ir(this.sessionId)}async runTrainStep(e,r,o){let[,n,a]=this.convertMapIntoValuesArrayAndIndicesArray(e,this.inputNames,(c,l)=>X(c,()=>`input "${this.inputNames[n[l]]}"`)),[s,i,u]=this.convertMapIntoValuesArrayAndIndicesArray(r,this.outputNames,(c,l)=>c?X(c,()=>`output "${this.outputNames[i[l]]}"`):null),f=await xr(this.sessionId,n,a,i,u,o);return this.convertTensorMetadataToReturnType(f,s,i)}async runOptimizerStep(e){await Cr(this.sessionId,e)}async runEvalStep(e,r,o){let[,n,a]=this.convertMapIntoValuesArrayAndIndicesArray(e,this.evalInputNames,(c,l)=>X(c,()=>`input "${this.evalInputNames[n[l]]}"`)),[s,i,u]=this.convertMapIntoValuesArrayAndIndicesArray(r,this.evalOutputNames,(c,l)=>c?X(c,()=>`output "${this.evalOutputNames[i[l]]}"`):null),f=await Br(this.sessionId,n,a,i,u,o);return this.convertTensorMetadataToReturnType(f,s,i)}async getParametersSize(e){return gt(this.sessionId,e)}async loadParametersBuffer(e,r){await _r(this.sessionId,e,r)}async getContiguousParameters(e){let r=await Rr(this.sessionId,e);return qe(r)}async dispose(){return Ur(this.checkpointId,this.sessionId)}}});var kr={};Ee(kr,{wasmBackend:()=>pn});var bt,pn,Dr=g(()=>{"use strict";Sr();Mr();bt=class extends Je{async createTrainingSessionHandler(e,r,o,n,a){let s=new Ke;return await s.createTrainingSession(e,r,o,n,a),Promise.resolve(s)}},pn=new bt});var hn={};Ee(hn,{InferenceSession:()=>qt,TRACE:()=>ot,TRACE_FUNC_BEGIN:()=>H,TRACE_FUNC_END:()=>z,Tensor:()=>I,TrainingSession:()=>tr,default:()=>mn,env:()=>O,registerBackend:()=>Q});V();V();V();var nr="1.19.0";var mn=at;{let t=(Dr(),tt(kr)).wasmBackend;Q("cpu",t,10),Q("wasm",t,10)}Object.defineProperty(O.versions,"web",{value:nr,enumerable:!0});return tt(hn);})();
typeof exports=="object"&&typeof module=="object"&&(module.exports=ort);
//# sourceMappingURL=ort.training.wasm.min.js.map
