/*!
 * ONNX Runtime Web v1.17.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
"use strict";var kn=Object.defineProperty;var Nl=Object.getOwnPropertyDescriptor;var Ul=Object.getOwnPropertyNames;var Hl=Object.prototype.hasOwnProperty;var F=(e,t)=>()=>(e&&(t=e(e=0)),t);var Kt=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),zt=(e,t)=>{for(var r in t)kn(e,r,{get:t[r],enumerable:!0})},Ll=(e,t,r,a)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of Ul(t))!Hl.call(e,n)&&n!==r&&kn(e,n,{get:()=>t[n],enumerable:!(a=Nl(t,n))||a.enumerable});return e};var Ct=e=>Ll(kn({},"__esModule",{value:!0}),e);var Ur,Wt,wt,Hr,Lr=F(()=>{Ur=new Map,Wt=[],wt=(e,t,r)=>{if(t&&typeof t.init=="function"&&typeof t.createInferenceSessionHandler=="function"){let a=Ur.get(e);if(a===void 0)Ur.set(e,{backend:t,priority:r});else{if(a.priority>r)return;if(a.priority===r&&a.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${r}`)}if(r>=0){let n=Wt.indexOf(e);n!==-1&&Wt.splice(n,1);for(let s=0;s<Wt.length;s++)if(Ur.get(Wt[s]).priority<=r){Wt.splice(s,0,e);return}Wt.push(e)}return}throw new TypeError("not a valid backend")},Hr=async e=>{let t=e.length===0?Wt:e,r=[];for(let a of t){let n=Ur.get(a);if(n){if(n.initialized)return n.backend;if(n.aborted)continue;let s=!!n.initPromise;try{return s||(n.initPromise=n.backend.init()),await n.initPromise,n.initialized=!0,n.backend}catch(u){s||r.push({name:a,err:u}),n.aborted=!0}finally{delete n.initPromise}}}throw new Error(`no available backend found. ERR: ${r.map(a=>`[${a.name}] ${a.err}`).join(", ")}`)}});var qa=F(()=>{Lr()});var Ka,Ya=F(()=>{Ka="1.17.0"});var Za,Rn,Xa=F(()=>{Ya();Za="warning",Rn={wasm:{},webgl:{},webgpu:{},versions:{common:Ka},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);Za=e}},get logLevel(){return Za}};Object.defineProperty(Rn,"logLevel",{enumerable:!0})});var _e,Qa=F(()=>{Xa();_e=Rn});var Ja,eo,to=F(()=>{Ja=(e,t)=>{let r=document.createElement("canvas");r.width=e.dims[3],r.height=e.dims[2];let a=r.getContext("2d");if(a!=null){let n,s;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(n=e.dims[2],s=e.dims[3]):(n=e.dims[3],s=e.dims[2]);let u=t?.format!==void 0?t.format:"RGB",l=t?.norm,o,p;l===void 0||l.mean===void 0?o=[255,255,255,255]:typeof l.mean=="number"?o=[l.mean,l.mean,l.mean,l.mean]:(o=[l.mean[0],l.mean[1],l.mean[2],0],l.mean[3]!==void 0&&(o[3]=l.mean[3])),l===void 0||l.bias===void 0?p=[0,0,0,0]:typeof l.bias=="number"?p=[l.bias,l.bias,l.bias,l.bias]:(p=[l.bias[0],l.bias[1],l.bias[2],0],l.bias[3]!==void 0&&(p[3]=l.bias[3]));let f=s*n,y=0,g=f,b=f*2,v=-1;u==="RGBA"?(y=0,g=f,b=f*2,v=f*3):u==="RGB"?(y=0,g=f,b=f*2):u==="RBG"&&(y=0,b=f,g=f*2);for(let $=0;$<s;$++)for(let I=0;I<n;I++){let _=(e.data[y++]-p[0])*o[0],C=(e.data[g++]-p[1])*o[1],P=(e.data[b++]-p[2])*o[2],A=v===-1?255:(e.data[v++]-p[3])*o[3];a.fillStyle="rgba("+_+","+C+","+P+","+A+")",a.fillRect(I,$,1,1)}return r.toDataURL()}else throw new Error("Can not access image data")},eo=(e,t)=>{let r=document.createElement("canvas").getContext("2d"),a;if(r!=null){let n,s,u;t?.tensorLayout!==void 0&&t.tensorLayout==="NHWC"?(n=e.dims[2],s=e.dims[1],u=e.dims[3]):(n=e.dims[3],s=e.dims[2],u=e.dims[1]);let l=t!==void 0&&t.format!==void 0?t.format:"RGB",o=t?.norm,p,f;o===void 0||o.mean===void 0?p=[255,255,255,255]:typeof o.mean=="number"?p=[o.mean,o.mean,o.mean,o.mean]:(p=[o.mean[0],o.mean[1],o.mean[2],255],o.mean[3]!==void 0&&(p[3]=o.mean[3])),o===void 0||o.bias===void 0?f=[0,0,0,0]:typeof o.bias=="number"?f=[o.bias,o.bias,o.bias,o.bias]:(f=[o.bias[0],o.bias[1],o.bias[2],0],o.bias[3]!==void 0&&(f[3]=o.bias[3]));let y=s*n;if(t!==void 0&&(t.format!==void 0&&u===4&&t.format!=="RGBA"||u===3&&t.format!=="RGB"&&t.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let g=4,b=0,v=1,$=2,I=3,_=0,C=y,P=y*2,A=-1;l==="RGBA"?(_=0,C=y,P=y*2,A=y*3):l==="RGB"?(_=0,C=y,P=y*2):l==="RBG"&&(_=0,P=y,C=y*2),a=r.createImageData(n,s);for(let B=0;B<s*n;b+=g,v+=g,$+=g,I+=g,B++)a.data[b]=(e.data[_++]-f[0])*p[0],a.data[v]=(e.data[C++]-f[1])*p[1],a.data[$]=(e.data[P++]-f[2])*p[2],a.data[I]=A===-1?255:(e.data[A++]-f[3])*p[3]}else throw new Error("Can not access image data");return a}});var Pn,ro,no,ao,oo,io=F(()=>{Gr();Pn=(e,t)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(t.height===void 0||t.width===void 0)throw new Error("Image height and width must be defined");if(t.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:r,width:a}=t,n=t.norm??{mean:255,bias:0},s,u;typeof n.mean=="number"?s=[n.mean,n.mean,n.mean,n.mean]:s=[n.mean[0],n.mean[1],n.mean[2],n.mean[3]??255],typeof n.bias=="number"?u=[n.bias,n.bias,n.bias,n.bias]:u=[n.bias[0],n.bias[1],n.bias[2],n.bias[3]??0];let l=t.format!==void 0?t.format:"RGBA",o=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:"RGB",p=r*a,f=o==="RGBA"?new Float32Array(p*4):new Float32Array(p*3),y=4,g=0,b=1,v=2,$=3,I=0,_=p,C=p*2,P=-1;l==="RGB"&&(y=3,g=0,b=1,v=2,$=-1),o==="RGBA"?P=p*3:o==="RBG"?(I=0,C=p,_=p*2):o==="BGR"&&(C=0,_=p,I=p*2);for(let B=0;B<p;B++,g+=y,v+=y,b+=y,$+=y)f[I++]=(e[g]+u[0])/s[0],f[_++]=(e[b]+u[1])/s[1],f[C++]=(e[v]+u[2])/s[2],P!==-1&&$!==-1&&(f[P++]=(e[$]+u[3])/s[3]);return o==="RGBA"?new Fe("float32",f,[1,4,r,a]):new Fe("float32",f,[1,3,r,a])},ro=async(e,t)=>{let r=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,a=typeof ImageData<"u"&&e instanceof ImageData,n=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,s=typeof e=="string",u,l=t??{};if(r){let o=document.createElement("canvas");o.width=e.width,o.height=e.height;let p=o.getContext("2d");if(p!=null){let f=e.height,y=e.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(f=t.resizedHeight,y=t.resizedWidth),t!==void 0){if(l=t,t.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");l.tensorFormat="RGBA",l.height=f,l.width=y}else l.tensorFormat="RGBA",l.height=f,l.width=y;p.drawImage(e,0,0),u=p.getImageData(0,0,y,f).data}else throw new Error("Can not access image data")}else if(a){let o,p;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(o=t.resizedHeight,p=t.resizedWidth):(o=e.height,p=e.width),t!==void 0&&(l=t),l.format="RGBA",l.height=o,l.width=p,t!==void 0){let f=document.createElement("canvas");f.width=p,f.height=o;let y=f.getContext("2d");if(y!=null)y.putImageData(e,0,0),u=y.getImageData(0,0,p,o).data;else throw new Error("Can not access image data")}else u=e.data}else if(n){if(t===void 0)throw new Error("Please provide image config with format for Imagebitmap");let o=document.createElement("canvas");o.width=e.width,o.height=e.height;let p=o.getContext("2d");if(p!=null){let f=e.height,y=e.width;return p.drawImage(e,0,0,y,f),u=p.getImageData(0,0,y,f).data,l.height=f,l.width=y,Pn(u,l)}else throw new Error("Can not access image data")}else{if(s)return new Promise((o,p)=>{let f=document.createElement("canvas"),y=f.getContext("2d");if(!e||!y)return p();let g=new Image;g.crossOrigin="Anonymous",g.src=e,g.onload=()=>{f.width=g.width,f.height=g.height,y.drawImage(g,0,0,f.width,f.height);let b=y.getImageData(0,0,f.width,f.height);l.height=f.height,l.width=f.width,o(Pn(b.data,l))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(u!==void 0)return Pn(u,l);throw new Error("Input data provided is not supported - aborted tensor creation")},no=(e,t)=>{let{width:r,height:a,download:n,dispose:s}=t,u=[1,a,r,4];return new Fe({location:"texture",type:"float32",texture:e,dims:u,download:n,dispose:s})},ao=(e,t)=>{let{dataType:r,dims:a,download:n,dispose:s}=t;return new Fe({location:"gpu-buffer",type:r??"float32",gpuBuffer:e,dims:a,download:n,dispose:s})},oo=(e,t,r)=>new Fe({location:"cpu-pinned",type:e,data:t,dims:r??[t.length]})});var mr,Fr,so,uo,lo=F(()=>{mr=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),Fr=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),so=!1,uo=()=>{if(!so){so=!0;let e=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",t=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function";e&&(mr.set("int64",BigInt64Array),Fr.set(BigInt64Array,"int64")),t&&(mr.set("uint64",BigUint64Array),Fr.set(BigUint64Array,"uint64"))}}});var co,po,fo=F(()=>{Gr();co=e=>{let t=1;for(let r=0;r<e.length;r++){let a=e[r];if(typeof a!="number"||!Number.isSafeInteger(a))throw new TypeError(`dims[${r}] must be an integer, got: ${a}`);if(a<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${a}`);t*=a}return t},po=(e,t)=>{switch(e.location){case"cpu":return new Fe(e.type,e.data,t);case"cpu-pinned":return new Fe({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new Fe({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new Fe({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}});var Fe,Gr=F(()=>{to();io();lo();fo();Fe=class{constructor(t,r,a){uo();let n,s;if(typeof t=="object"&&"location"in t)switch(this.dataLocation=t.location,n=t.type,s=t.dims,t.location){case"cpu-pinned":{let l=mr.get(n);if(!l)throw new TypeError(`unsupported type "${n}" to create tensor from pinned buffer`);if(!(t.data instanceof l))throw new TypeError(`buffer should be of type ${l.name}`);this.cpuData=t.data;break}case"texture":{if(n!=="float32")throw new TypeError(`unsupported type "${n}" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case"gpu-buffer":{if(n!=="float32"&&n!=="float16"&&n!=="int32"&&n!=="int64"&&n!=="uint32"&&n!=="bool")throw new TypeError(`unsupported type "${n}" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let l,o;if(typeof t=="string")if(n=t,o=a,t==="string"){if(!Array.isArray(r))throw new TypeError("A string tensor's data must be a string array.");l=r}else{let p=mr.get(t);if(p===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(r)){if(t==="float16")throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");t==="uint64"||t==="int64"?l=p.from(r,BigInt):l=p.from(r)}else if(r instanceof p)l=r;else throw new TypeError(`A ${n} tensor's data must be type of ${p}`)}else if(o=r,Array.isArray(t)){if(t.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let p=typeof t[0];if(p==="string")n="string",l=t;else if(p==="boolean")n="bool",l=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${p}.`)}else{let p=Fr.get(t.constructor);if(p===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);n=p,l=t}if(o===void 0)o=[l.length];else if(!Array.isArray(o))throw new TypeError("A tensor's dims must be a number array");s=o,this.cpuData=l,this.dataLocation="cpu"}let u=co(s);if(this.cpuData&&u!==this.cpuData.length)throw new Error(`Tensor's size(${u}) does not match data length(${this.cpuData.length}).`);this.type=n,this.dims=s,this.size=u}static async fromImage(t,r){return ro(t,r)}static fromTexture(t,r){return no(t,r)}static fromGpuBuffer(t,r){return ao(t,r)}static fromPinnedBuffer(t,r,a){return oo(t,r,a)}toDataURL(t){return Ja(this,t)}toImageData(t){return eo(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(t){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let r=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=r,t&&this.disposer&&(this.disposer(),this.disposer=void 0),r}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return po(this,t)}}});var Ue,jr=F(()=>{Gr();Ue=Fe});var qr,mo=F(()=>{Lr();jr();qr=class e{constructor(t){this.handler=t}async run(t,r,a){let n={},s={};if(typeof t!="object"||t===null||t instanceof Ue||Array.isArray(t))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let u=!0;if(typeof r=="object"){if(r===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(r instanceof Ue)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(r)){if(r.length===0)throw new TypeError("'fetches' cannot be an empty array.");u=!1;for(let p of r){if(typeof p!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(p)===-1)throw new RangeError(`'fetches' contains invalid output name: ${p}.`);n[p]=null}if(typeof a=="object"&&a!==null)s=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else{let p=!1,f=Object.getOwnPropertyNames(r);for(let y of this.outputNames)if(f.indexOf(y)!==-1){let g=r[y];(g===null||g instanceof Ue)&&(p=!0,u=!1,n[y]=g)}if(p){if(typeof a=="object"&&a!==null)s=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else s=r}}else if(typeof r<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let p of this.inputNames)if(typeof t[p]>"u")throw new Error(`input '${p}' is missing in 'feeds'.`);if(u)for(let p of this.outputNames)n[p]=null;let l=await this.handler.run(t,n,s),o={};for(let p in l)if(Object.hasOwnProperty.call(l,p)){let f=l[p];f instanceof Ue?o[p]=f:o[p]=new Ue(f.type,f.data,f.dims)}return o}async release(){return this.handler.dispose()}static async create(t,r,a,n){let s,u={};if(typeof t=="string"){if(s=t,typeof r=="object"&&r!==null)u=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(s=t,typeof r=="object"&&r!==null)u=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer){let y=t,g=0,b=t.byteLength;if(typeof r=="object"&&r!==null)u=r;else if(typeof r=="number"){if(g=r,!Number.isSafeInteger(g))throw new RangeError("'byteOffset' must be an integer.");if(g<0||g>=y.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${y.byteLength}).`);if(b=t.byteLength-g,typeof a=="number"){if(b=a,!Number.isSafeInteger(b))throw new RangeError("'byteLength' must be an integer.");if(b<=0||g+b>y.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${y.byteLength-g}].`);if(typeof n=="object"&&n!==null)u=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(typeof a<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof r<"u")throw new TypeError("'options' must be an object.");s=new Uint8Array(y,g,b)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let o=(u.executionProviders||[]).map(y=>typeof y=="string"?y:y.name),f=await(await Hr(o)).createInferenceSessionHandler(s,u);return new e(f)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var ho,go=F(()=>{mo();ho=qr});var yo=F(()=>{});var Gl,Kr,bo=F(()=>{Lr();jr();Gl="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",Kr=class e{constructor(t){this.handler=t}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}static async create(t,r){let a=t.evalModel||"",n=t.optimizerModel||"",s=r||{},l=(s.executionProviders||[]).map(p=>typeof p=="string"?p:p.name),o=await Hr(l);if(o.createTrainingSessionHandler){let p=await o.createTrainingSessionHandler(t.checkpointState,t.trainModel,a,n,s);return new e(p)}else throw new Error(Gl)}typeNarrowingForRunStep(t,r,a){let n={},s={};if(typeof t!="object"||t===null||t instanceof Ue||Array.isArray(t))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let u=!0;if(typeof r=="object"){if(r===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(r instanceof Ue)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(r)){if(r.length===0)throw new TypeError("'fetches' cannot be an empty array.");u=!1;for(let l of r){if(typeof l!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(l)===-1)throw new RangeError(`'fetches' contains invalid output name: ${l}.`);n[l]=null}if(typeof a=="object"&&a!==null)s=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else{let l=!1,o=Object.getOwnPropertyNames(r);for(let p of this.outputNames)if(o.indexOf(p)!==-1){let f=r[p];(f===null||f instanceof Ue)&&(l=!0,u=!1,n[p]=f)}if(l){if(typeof a=="object"&&a!==null)s=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else s=r}}else if(typeof r<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let l of this.inputNames)if(typeof t[l]>"u")throw new Error(`input '${l}' is missing in 'feeds'.`);if(u)for(let l of this.outputNames)n[l]=null;return[n,s]}convertHandlerReturnTypeToMapOfTensors(t){let r={};for(let a in t)if(Object.hasOwnProperty.call(t,a)){let n=t[a];n instanceof Ue?r[a]=n:r[a]=new Ue(n.type,n.data,n.dims)}return r}async runTrainStep(t,r,a){let[n,s]=this.typeNarrowingForRunStep(t,r,a),u=await this.handler.runTrainStep(t,n,s);return this.convertHandlerReturnTypeToMapOfTensors(u)}async loadParametersBuffer(t,r){throw new Error("Method not implemented.")}async getContiguousParameters(t){throw new Error("Method not implemented.")}async release(){return this.handler.dispose()}}});var wo,vo=F(()=>{bo();wo=Kr});var Bn={};zt(Bn,{InferenceSession:()=>ho,Tensor:()=>Ue,TrainingSession:()=>wo,env:()=>_e,registerBackend:()=>wt});var _t=F(()=>{qa();Qa();go();jr();yo();vo()});var Mn={};zt(Mn,{readFile:()=>Fl});var Fl,Dn=F(()=>{Fl=void 0});var zn={};zt(zn,{join:()=>jl});var jl,Wn=F(()=>{jl=void 0});var Io=Kt((xo,Vn)=>{"use strict";var So=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){var r=t,a,n;r.ready=new Promise((d,m)=>{a=d,n=m}),r.jsepInit=(d,m,w,x,T,H,U,se)=>{r.Za=d,r.Oa=m,r.Qa=w,r.Ja=x,r.Pa=T,r.ra=H,r.Ra=U,r.Sa=se,m=(Z,ee,X)=>(...ce)=>{let he=Qe,k=ee?.();ce=Z(...ce);let ne=ee?.();return k!==ne&&(Z=ne,X(k),ee=X=null),Qe!=he?kr():ce},w=Z=>async(...ee)=>{try{if(r.Da)throw Error("Session already started");let X=r.Da={Ta:ee[0],errors:[]},ce=await Z(...ee);if(r.Da!==X)throw Error("Session mismatch");d.flush();let he=X.errors;if(0<he.length){let k=await Promise.all(he);if(k=k.filter(ne=>ne),0<k.length)throw Error(k.join(`
`))}return ce}finally{r.Da=null}},r._OrtRun=w(m(r._OrtRun,()=>r._OrtRun,Z=>r._OrtRun=Z)),r._OrtRunWithBinding=w(m(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,Z=>r._OrtRunWithBinding=Z)),r._OrtBindInput=m(r._OrtBindInput,()=>r._OrtBindInput,Z=>r._OrtBindInput=Z),r.jsepRegisterBuffer=(Z,ee,X,ce)=>d.registerBuffer(Z,ee,X,ce),r.jsepUnregisterBuffers=Z=>{d.unregisterBuffers(Z)},r.jsepGetBuffer=Z=>d.getBuffer(Z),r.jsepCreateDownloader=(Z,ee,X)=>d.createDownloader(Z,ee,X)};var s=Object.assign({},r),u="./this.program",l=(d,m)=>{throw m},o=typeof window=="object",p=typeof importScripts=="function",f=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",y="",g,b,v;if(f){var $=(Dn(),Ct(Mn)),I=(Wn(),Ct(zn));y=p?I.dirname(y)+"/":__dirname+"/",g=(d,m)=>(d=d.startsWith("file://")?new URL(d):I.normalize(d),$.readFileSync(d,m?void 0:"utf8")),v=d=>(d=g(d,!0),d.buffer||(d=new Uint8Array(d)),d),b=(d,m,w,x=!0)=>{d=d.startsWith("file://")?new URL(d):I.normalize(d),$.readFile(d,x?void 0:"utf8",(T,H)=>{T?w(T):m(x?H.buffer:H)})},!r.thisProgram&&1<process.argv.length&&(u=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),l=(d,m)=>{throw process.exitCode=d,m},r.inspect=()=>"[Emscripten Module object]"}else(o||p)&&(p?y=self.location.href:typeof document<"u"&&document.currentScript&&(y=document.currentScript.src),e&&(y=e),y.indexOf("blob:")!==0?y=y.substr(0,y.replace(/[?#].*/,"").lastIndexOf("/")+1):y="",g=d=>{var m=new XMLHttpRequest;return m.open("GET",d,!1),m.send(null),m.responseText},p&&(v=d=>{var m=new XMLHttpRequest;return m.open("GET",d,!1),m.responseType="arraybuffer",m.send(null),new Uint8Array(m.response)}),b=(d,m,w)=>{var x=new XMLHttpRequest;x.open("GET",d,!0),x.responseType="arraybuffer",x.onload=()=>{x.status==200||x.status==0&&x.response?m(x.response):w()},x.onerror=w,x.send(null)});var _=r.print||console.log.bind(console),C=r.printErr||console.error.bind(console);Object.assign(r,s),s=null,r.thisProgram&&(u=r.thisProgram),r.quit&&(l=r.quit);var P;r.wasmBinary&&(P=r.wasmBinary);var A=r.noExitRuntime||!0;typeof WebAssembly!="object"&&Ze("no native wasm support detected");var B,O,W=!1,V,Y,oe,M,K,Se,ue;function ve(){var d=B.buffer;r.HEAP8=Y=new Int8Array(d),r.HEAP16=new Int16Array(d),r.HEAP32=M=new Int32Array(d),r.HEAPU8=oe=new Uint8Array(d),r.HEAPU16=new Uint16Array(d),r.HEAPU32=K=new Uint32Array(d),r.HEAPF32=Se=new Float32Array(d),r.HEAPF64=ue=new Float64Array(d)}var j=[],xe=[],Pe=[];function Ee(){var d=r.preRun.shift();j.unshift(d)}var Ie=0,$t=null,qe=null;function Ze(d){throw r.onAbort&&r.onAbort(d),d="Aborted("+d+")",C(d),W=!0,V=1,d=new WebAssembly.RuntimeError(d+". Build with -sASSERTIONS for more info."),n(d),d}function G(d){return d.startsWith("data:application/octet-stream;base64,")}var de;if(de="ort-wasm-simd.wasm",!G(de)){var pe=de;de=r.locateFile?r.locateFile(pe,y):y+pe}function Ve(d){if(d==de&&P)return new Uint8Array(P);if(v)return v(d);throw"both async and sync fetching of the wasm failed"}function Ke(d){if(!P&&(o||p)){if(typeof fetch=="function"&&!d.startsWith("file://"))return fetch(d,{credentials:"same-origin"}).then(m=>{if(!m.ok)throw"failed to load wasm binary file at '"+d+"'";return m.arrayBuffer()}).catch(()=>Ve(d));if(b)return new Promise((m,w)=>{b(d,x=>m(new Uint8Array(x)),w)})}return Promise.resolve().then(()=>Ve(d))}function ke(d,m,w){return Ke(d).then(x=>WebAssembly.instantiate(x,m)).then(x=>x).then(w,x=>{C("failed to asynchronously prepare wasm: "+x),Ze(x)})}function ze(d,m){var w=de;return P||typeof WebAssembly.instantiateStreaming!="function"||G(w)||w.startsWith("file://")||f||typeof fetch!="function"?ke(w,d,m):fetch(w,{credentials:"same-origin"}).then(x=>WebAssembly.instantiateStreaming(x,d).then(m,function(T){return C("wasm streaming compile failed: "+T),C("falling back to ArrayBuffer instantiation"),ke(w,d,m)}))}var Ge,it={911200:d=>{r.ra("Abs",d,void 0)},911251:d=>{r.ra("Neg",d,void 0)},911302:d=>{r.ra("Floor",d,void 0)},911355:d=>{r.ra("Ceil",d,void 0)},911407:d=>{r.ra("Reciprocal",d,void 0)},911465:d=>{r.ra("Sqrt",d,void 0)},911517:d=>{r.ra("Exp",d,void 0)},911568:d=>{r.ra("Erf",d,void 0)},911619:d=>{r.ra("Sigmoid",d,void 0)},911674:d=>{r.ra("Log",d,void 0)},911725:d=>{r.ra("Sin",d,void 0)},911776:d=>{r.ra("Cos",d,void 0)},911827:d=>{r.ra("Tan",d,void 0)},911878:d=>{r.ra("Asin",d,void 0)},911930:d=>{r.ra("Acos",d,void 0)},911982:d=>{r.ra("Atan",d,void 0)},912034:d=>{r.ra("Sinh",d,void 0)},912086:d=>{r.ra("Cosh",d,void 0)},912138:d=>{r.ra("Asinh",d,void 0)},912191:d=>{r.ra("Acosh",d,void 0)},912244:d=>{r.ra("Atanh",d,void 0)},912297:d=>{r.ra("Tanh",d,void 0)},912349:d=>{r.ra("Not",d,void 0)},912400:(d,m,w)=>{r.ra("Clip",d,{min:m,max:w})},912469:d=>{r.ra("Clip",d,void 0)},912521:(d,m)=>{r.ra("Elu",d,{alpha:m})},912579:d=>{r.ra("Relu",d,void 0)},912631:(d,m)=>{r.ra("LeakyRelu",d,{alpha:m})},912695:(d,m)=>{r.ra("ThresholdedRelu",d,{alpha:m})},912765:(d,m)=>{r.ra("Cast",d,{to:m})},912823:d=>{r.ra("Add",d,void 0)},912874:d=>{r.ra("Sub",d,void 0)},912925:d=>{r.ra("Mul",d,void 0)},912976:d=>{r.ra("Div",d,void 0)},913027:d=>{r.ra("Pow",d,void 0)},913078:d=>{r.ra("Equal",d,void 0)},913131:d=>{r.ra("Greater",d,void 0)},913186:d=>{r.ra("GreaterOrEqual",d,void 0)},913248:d=>{r.ra("Less",d,void 0)},913300:d=>{r.ra("LessOrEqual",d,void 0)},913359:(d,m,w,x,T)=>{r.ra("ReduceMean",d,{keepDims:!!m,noopWithEmptyAxes:!!w,axes:x?Array.from(M.subarray(T>>>0,T+x>>>0)):[]})},913523:(d,m,w,x,T)=>{r.ra("ReduceMax",d,{keepDims:!!m,noopWithEmptyAxes:!!w,axes:x?Array.from(M.subarray(T>>>0,T+x>>>0)):[]})},913686:(d,m,w,x,T)=>{r.ra("ReduceMin",d,{keepDims:!!m,noopWithEmptyAxes:!!w,axes:x?Array.from(M.subarray(T>>>0,T+x>>>0)):[]})},913849:(d,m,w,x,T)=>{r.ra("ReduceProd",d,{keepDims:!!m,noopWithEmptyAxes:!!w,axes:x?Array.from(M.subarray(T>>>0,T+x>>>0)):[]})},914013:(d,m,w,x,T)=>{r.ra("ReduceSum",d,{keepDims:!!m,noopWithEmptyAxes:!!w,axes:x?Array.from(M.subarray(T>>>0,T+x>>>0)):[]})},914176:(d,m,w,x,T)=>{r.ra("ReduceL1",d,{keepDims:!!m,noopWithEmptyAxes:!!w,axes:x?Array.from(M.subarray(T>>>0,T+x>>>0)):[]})},914338:(d,m,w,x,T)=>{r.ra("ReduceL2",d,{keepDims:!!m,noopWithEmptyAxes:!!w,axes:x?Array.from(M.subarray(T>>>0,T+x>>>0)):[]})},914500:(d,m,w,x,T)=>{r.ra("ReduceLogSum",d,{keepDims:!!m,noopWithEmptyAxes:!!w,axes:x?Array.from(M.subarray(T>>>0,T+x>>>0)):[]})},914666:(d,m,w,x,T)=>{r.ra("ReduceSumSquare",d,{keepDims:!!m,noopWithEmptyAxes:!!w,axes:x?Array.from(M.subarray(T>>>0,T+x>>>0)):[]})},914835:(d,m,w,x,T)=>{r.ra("ReduceLogSumExp",d,{keepDims:!!m,noopWithEmptyAxes:!!w,axes:x?Array.from(M.subarray(T>>>0,T+x>>>0)):[]})},915004:d=>{r.ra("Where",d,void 0)},915057:(d,m,w)=>{r.ra("Transpose",d,{perm:m?Array.from(M.subarray(w>>>0,w+m>>>0)):[]})},915170:(d,m,w,x,T,H,U,se,Z,ee,X,ce,he,k,ne)=>{r.ra("ConvTranspose",d,{format:Z?"NHWC":"NCHW",autoPad:m,dilations:[w],group:x,kernel_shape:[T],pads:[H,U],strides:[se],wIsConst:()=>!!Y[ee>>>0],outputPadding:X?Array.from(M.subarray(ce>>>0,ce+X>>>0)):[],outputShape:he?Array.from(M.subarray(k>>>0,k+he>>>0)):[],activation:Be(ne)})},915584:(d,m,w,x,T,H,U,se,Z,ee,X,ce,he,k)=>{r.ra("ConvTranspose",d,{format:se?"NHWC":"NCHW",autoPad:m,dilations:Array.from(M.subarray(w>>>0,w+2>>>0)),group:x,kernelShape:Array.from(M.subarray(T>>>0,T+2>>>0)),pads:Array.from(M.subarray(H>>>0,H+4>>>0)),strides:Array.from(M.subarray(U>>>0,U+2>>>0)),wIsConst:()=>!!Y[Z>>>0],outputPadding:0<ee?Array.from(M.subarray(X>>>0,X+ee>>>0)):[],outputShape:0<ce?Array.from(M.subarray(he>>>0,he+ce>>>0)):[],activation:Be(k)})},916141:(d,m,w,x,T,H,U,se,Z,ee,X,ce,he,k,ne)=>{r.ra("ConvTranspose",d,{format:Z?"NHWC":"NCHW",autoPad:m,dilations:[w],group:x,kernel_shape:[T],pads:[H,U],strides:[se],wIsConst:()=>!!Y[ee>>>0],outputPadding:X?Array.from(M.subarray(ce>>>0,ce+X>>>0)):[],outputShape:he?Array.from(M.subarray(k>>>0,k+he>>>0)):[],activation:Be(ne)})},916555:(d,m,w,x,T,H,U,se,Z,ee,X,ce,he,k)=>{r.ra("ConvTranspose",d,{format:se?"NHWC":"NCHW",autoPad:m,dilations:Array.from(M.subarray(w>>>0,w+2>>>0)),group:x,kernelShape:Array.from(M.subarray(T>>>0,T+2>>>0)),pads:Array.from(M.subarray(H>>>0,H+4>>>0)),strides:Array.from(M.subarray(U>>>0,U+2>>>0)),wIsConst:()=>!!Y[Z>>>0],outputPadding:0<ee?Array.from(M.subarray(X>>>0,X+ee>>>0)):[],outputShape:0<ce?Array.from(M.subarray(he>>>0,he+ce>>>0)):[],activation:Be(k)})},917112:(d,m)=>{r.ra("GlobalAveragePool",d,{format:m?"NHWC":"NCHW"})},917203:(d,m,w,x,T,H,U,se,Z,ee,X,ce,he,k,ne,fe)=>{r.ra("AveragePool",d,{format:fe?"NHWC":"NCHW",auto_pad:m,ceil_mode:w,count_include_pad:x,storage_order:T,dilations:[H,U],kernel_shape:[se,Z],pads:[ee,X,ce,he],strides:[k,ne]})},917487:(d,m)=>{r.ra("GlobalAveragePool",d,{format:m?"NHWC":"NCHW"})},917578:(d,m,w,x,T,H,U,se,Z,ee,X,ce,he,k,ne,fe)=>{r.ra("AveragePool",d,{format:fe?"NHWC":"NCHW",auto_pad:m,ceil_mode:w,count_include_pad:x,storage_order:T,dilations:[H,U],kernel_shape:[se,Z],pads:[ee,X,ce,he],strides:[k,ne]})},917862:(d,m)=>{r.ra("GlobalMaxPool",d,{format:m?"NHWC":"NCHW"})},917949:(d,m,w,x,T,H,U,se,Z,ee,X,ce,he,k,ne,fe)=>{r.ra("MaxPool",d,{format:fe?"NHWC":"NCHW",auto_pad:m,ceil_mode:w,count_include_pad:x,storage_order:T,dilations:[H,U],kernel_shape:[se,Z],pads:[ee,X,ce,he],strides:[k,ne]})},918229:(d,m)=>{r.ra("GlobalMaxPool",d,{format:m?"NHWC":"NCHW"})},918316:(d,m,w,x,T,H,U,se,Z,ee,X,ce,he,k,ne,fe)=>{r.ra("MaxPool",d,{format:fe?"NHWC":"NCHW",auto_pad:m,ceil_mode:w,count_include_pad:x,storage_order:T,dilations:[H,U],kernel_shape:[se,Z],pads:[ee,X,ce,he],strides:[k,ne]})},918596:(d,m,w,x,T)=>{r.ra("Gemm",d,{alpha:m,beta:w,transA:x,transB:T})},918700:d=>{r.ra("MatMul",d,void 0)},918754:(d,m,w,x)=>{r.ra("ArgMax",d,{keepDims:!!m,selectLastIndex:!!w,axis:x})},918862:(d,m,w,x)=>{r.ra("ArgMin",d,{keepDims:!!m,selectLastIndex:!!w,axis:x})},918970:(d,m)=>{r.ra("Softmax",d,{axis:m})},919033:(d,m)=>{r.ra("Concat",d,{axis:m})},919093:(d,m,w,x,T)=>{r.ra("Split",d,{axis:m,numOutputs:w,splitSizes:x?Array.from(M.subarray(T>>>0,T+x>>>0)):[]})},919238:d=>{r.ra("Expand",d,void 0)},919292:(d,m)=>{r.ra("Gather",d,{axis:Number(m)})},919363:(d,m)=>{r.ra("GatherElements",d,{axis:Number(m)})},919442:(d,m,w,x,T,H,U,se,Z,ee,X)=>{r.ra("Resize",d,{antialias:m,axes:w?Array.from(M.subarray(x>>>0,x+w>>>0)):[],coordinateTransformMode:Be(T),cubicCoeffA:H,excludeOutside:U,extrapolationValue:se,keepAspectRatioPolicy:Be(Z),mode:Be(ee),nearestMode:Be(X)})},919793:(d,m,w,x,T,H,U)=>{r.ra("Slice",d,{starts:m?Array.from(M.subarray(w>>>0,w+m>>>0)):[],ends:x?Array.from(M.subarray(T>>>0,T+x>>>0)):[],axes:H?Array.from(M.subarray(U>>>0,U+H>>>0)):[]})},920024:d=>{r.ra("Tile",d,void 0)},920076:(d,m,w)=>{r.ra("LayerNormalization",d,{axis:Number(m),epsilon:Number(w)})},920183:(d,m,w)=>{r.ra("InstanceNormalization",d,{epsilon:m,format:w?"NHWC":"NCHW"})},920297:(d,m,w)=>{r.ra("InstanceNormalization",d,{epsilon:m,format:w?"NHWC":"NCHW"})},920411:d=>{r.ra("Range",d,void 0)},920464:(d,m)=>{r.ra("Einsum",d,{equation:Be(m)})},920545:(d,m,w,x,T)=>{r.ra("Pad",d,{mode:m,value:w,pads:x?Array.from(M.subarray(T>>>0,T+x>>>0)):[]})},920677:(d,m,w,x,T,H,U,se,Z)=>{r.ra("Attention",d,{numHeads:m,isUnidirectional:w,maskFilterValue:x,scale:T,doRotary:H,qkvHiddenSizes:U?Array.from(M.subarray(Number(se)>>>0,Number(se)+U>>>0)):[],pastPresentShareBuffer:!!Z})},920949:d=>{r.ra("Gelu",d,void 0)},921001:(d,m,w,x,T,H)=>{r.ra("MultiHeadAttention",d,{numHeads:m,isUnidirectional:w,maskFilterValue:x,scale:T,doRotary:H})},921160:d=>{r.ra("BiasAdd",d,void 0)},921215:d=>{r.ra("BiasSplitGelu",d,void 0)},921276:(d,m)=>{r.ra("SkipLayerNormalization",d,{epsilon:m})},921357:(d,m,w,x,T,H,U,se,Z,ee,X,ce,he)=>{r.ra("Conv",d,{format:Z?"NHWC":"NCHW",auto_pad:m,dilations:[w],group:x,kernel_shape:[T],pads:H?Array.from(M.subarray(U>>>0,U+H>>>0)):[],strides:[se],w_is_const:()=>!!Y[ee>>>0],activation:Be(X),activation_params:ce?Array.from(Se.subarray(he>>>0,he+ce>>>0)):[]})},921738:(d,m,w,x,T,H,U,se,Z,ee,X,ce,he,k,ne,fe)=>{r.ra("Conv",d,{format:ce?"NHWC":"NCHW",auto_pad:m,dilations:[w,x],group:T,kernel_shape:[H,U],pads:se?Array.from(M.subarray(Z>>>0,Z+se>>>0)):[],strides:[ee,X],w_is_const:()=>!!Y[he>>>0],activation:Be(k),activation_params:ne?Array.from(Se.subarray(fe>>>0,fe+ne>>>0)):[]})},922140:d=>{r.Ra(d)},922174:(d,m)=>r.Sa(d,m,r.Da.Ta,r.Da.errors),922286:d=>r.Oa(d),922319:d=>r.Qa(d),922351:(d,m,w)=>{r.Ja(d,m,w,!0)},922390:(d,m,w)=>{r.Ja(d,m,w)}};function Xe(d){this.name="ExitStatus",this.message=`Program terminated with exit(${d})`,this.status=d}var Tt=d=>{for(;0<d.length;)d.shift()(r)};function kt(d){this.Ha=d-24,this.Ma=function(m){K[this.Ha+4>>2>>>0]=m},this.La=function(m){K[this.Ha+8>>2>>>0]=m},this.Ya=function(m,w){this.Ka(),this.Ma(m),this.La(w)},this.Ka=function(){K[this.Ha+16>>2>>>0]=0}}var Xt=0,Ir=0,tt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Qt=(d,m,w)=>{m>>>=0;var x=m+w;for(w=m;d[w]&&!(w>=x);)++w;if(16<w-m&&d.buffer&&tt)return tt.decode(d.subarray(m,w));for(x="";m<w;){var T=d[m++];if(T&128){var H=d[m++]&63;if((T&224)==192)x+=String.fromCharCode((T&31)<<6|H);else{var U=d[m++]&63;T=(T&240)==224?(T&15)<<12|H<<6|U:(T&7)<<18|H<<12|U<<6|d[m++]&63,65536>T?x+=String.fromCharCode(T):(T-=65536,x+=String.fromCharCode(55296|T>>10,56320|T&1023))}}else x+=String.fromCharCode(T)}return x},Be=(d,m)=>(d>>>=0)?Qt(oe,d,m):"",Ut=d=>{for(var m=0,w=0;w<d.length;++w){var x=d.charCodeAt(w);127>=x?m++:2047>=x?m+=2:55296<=x&&57343>=x?(m+=4,++w):m+=3}return m},Jt=(d,m,w,x)=>{if(w>>>=0,!(0<x))return 0;var T=w;x=w+x-1;for(var H=0;H<d.length;++H){var U=d.charCodeAt(H);if(55296<=U&&57343>=U){var se=d.charCodeAt(++H);U=65536+((U&1023)<<10)|se&1023}if(127>=U){if(w>=x)break;m[w++>>>0]=U}else{if(2047>=U){if(w+1>=x)break;m[w++>>>0]=192|U>>6}else{if(65535>=U){if(w+2>=x)break;m[w++>>>0]=224|U>>12}else{if(w+3>=x)break;m[w++>>>0]=240|U>>18,m[w++>>>0]=128|U>>12&63}m[w++>>>0]=128|U>>6&63}m[w++>>>0]=128|U&63}}return m[w>>>0]=0,w-T},ht=d=>d%4===0&&(d%100!==0||d%400===0),Cr=[0,31,60,91,121,152,182,213,244,274,305,335],gt=[0,31,59,90,120,151,181,212,243,273,304,334],Ht=d=>{var m=Ut(d)+1,w=jt(m);return w&&Jt(d,oe,w,m),w},St=[],Lt=(d,m)=>{St.length=0;var w;for(m>>=2;w=oe[d++>>>0];)m+=w!=105&m,St.push(w==105?M[m>>>0]:ue[m++>>>1]),++m;return St},Gt={},er=()=>{if(!Ft){var d={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:u||"./this.program"},m;for(m in Gt)Gt[m]===void 0?delete d[m]:d[m]=Gt[m];var w=[];for(m in d)w.push(`${m}=${d[m]}`);Ft=w}return Ft},Ft,_r=[null,[],[]],Ne=[31,29,31,30,31,30,31,31,30,31,30,31],tr=[31,28,31,30,31,30,31,31,30,31,30,31];function rr(d){var m=Array(Ut(d)+1);return Jt(d,m,0,m.length),m}function ie(d,m,w,x){function T(k,ne,fe){for(k=typeof k=="number"?k.toString():k||"";k.length<ne;)k=fe[0]+k;return k}function H(k,ne){return T(k,ne,"0")}function U(k,ne){function fe(fr){return 0>fr?-1:0<fr?1:0}var bt;return(bt=fe(k.getFullYear()-ne.getFullYear()))===0&&(bt=fe(k.getMonth()-ne.getMonth()))===0&&(bt=fe(k.getDate()-ne.getDate())),bt}function se(k){switch(k.getDay()){case 0:return new Date(k.getFullYear()-1,11,29);case 1:return k;case 2:return new Date(k.getFullYear(),0,3);case 3:return new Date(k.getFullYear(),0,2);case 4:return new Date(k.getFullYear(),0,1);case 5:return new Date(k.getFullYear()-1,11,31);case 6:return new Date(k.getFullYear()-1,11,30)}}function Z(k){var ne=k.Ba;for(k=new Date(new Date(k.Ca+1900,0,1).getTime());0<ne;){var fe=k.getMonth(),bt=(ht(k.getFullYear())?Ne:tr)[fe];if(ne>bt-k.getDate())ne-=bt-k.getDate()+1,k.setDate(1),11>fe?k.setMonth(fe+1):(k.setMonth(0),k.setFullYear(k.getFullYear()+1));else{k.setDate(k.getDate()+ne);break}}return fe=new Date(k.getFullYear()+1,0,4),ne=se(new Date(k.getFullYear(),0,4)),fe=se(fe),0>=U(ne,k)?0>=U(fe,k)?k.getFullYear()+1:k.getFullYear():k.getFullYear()-1}d>>>=0,m>>>=0,w>>>=0,x>>>=0;var ee=M[x+40>>2>>>0];x={Wa:M[x>>2>>>0],Va:M[x+4>>2>>>0],Ea:M[x+8>>2>>>0],Ia:M[x+12>>2>>>0],Fa:M[x+16>>2>>>0],Ca:M[x+20>>2>>>0],wa:M[x+24>>2>>>0],Ba:M[x+28>>2>>>0],$a:M[x+32>>2>>>0],Ua:M[x+36>>2>>>0],Xa:ee?Be(ee):""},w=Be(w),ee={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var X in ee)w=w.replace(new RegExp(X,"g"),ee[X]);var ce="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),he="January February March April May June July August September October November December".split(" ");ee={"%a":k=>ce[k.wa].substring(0,3),"%A":k=>ce[k.wa],"%b":k=>he[k.Fa].substring(0,3),"%B":k=>he[k.Fa],"%C":k=>H((k.Ca+1900)/100|0,2),"%d":k=>H(k.Ia,2),"%e":k=>T(k.Ia,2," "),"%g":k=>Z(k).toString().substring(2),"%G":k=>Z(k),"%H":k=>H(k.Ea,2),"%I":k=>(k=k.Ea,k==0?k=12:12<k&&(k-=12),H(k,2)),"%j":k=>{for(var ne=0,fe=0;fe<=k.Fa-1;ne+=(ht(k.Ca+1900)?Ne:tr)[fe++]);return H(k.Ia+ne,3)},"%m":k=>H(k.Fa+1,2),"%M":k=>H(k.Va,2),"%n":()=>`
`,"%p":k=>0<=k.Ea&&12>k.Ea?"AM":"PM","%S":k=>H(k.Wa,2),"%t":()=>"	","%u":k=>k.wa||7,"%U":k=>H(Math.floor((k.Ba+7-k.wa)/7),2),"%V":k=>{var ne=Math.floor((k.Ba+7-(k.wa+6)%7)/7);if(2>=(k.wa+371-k.Ba-2)%7&&ne++,ne)ne==53&&(fe=(k.wa+371-k.Ba)%7,fe==4||fe==3&&ht(k.Ca)||(ne=1));else{ne=52;var fe=(k.wa+7-k.Ba-1)%7;(fe==4||fe==5&&ht(k.Ca%400-1))&&ne++}return H(ne,2)},"%w":k=>k.wa,"%W":k=>H(Math.floor((k.Ba+7-(k.wa+6)%7)/7),2),"%y":k=>(k.Ca+1900).toString().substring(2),"%Y":k=>k.Ca+1900,"%z":k=>{k=k.Ua;var ne=0<=k;return k=Math.abs(k)/60,(ne?"+":"-")+("0000"+(k/60*100+k%60)).slice(-4)},"%Z":k=>k.Xa,"%%":()=>"%"},w=w.replace(/%%/g,"\0\0");for(X in ee)w.includes(X)&&(w=w.replace(new RegExp(X,"g"),ee[X](x)));return w=w.replace(/\0\0/g,"%"),X=rr(w),X.length>m?0:(Y.set(X,d>>>0),X.length-1)}function yt(d){try{d()}catch(m){Ze(m)}}function Ar(d){var m={},w;for(w in d)(function(x){var T=d[x];m[x]=typeof T=="function"?function(){Rt.push(x);try{return T.apply(null,arguments)}finally{W||(Rt.pop()===x||Ze(),Qe&&st===1&&Rt.length===0&&(st=0,yt(cr),typeof Fibers<"u"&&Fibers.ab()))}}:T})(w);return m}var st=0,Qe=null,Er=0,Rt=[],nr={},ar={},Or=0,Pt=null,Tr=[];function kr(){return new Promise((d,m)=>{Pt={resolve:d,reject:m}})}function Rr(){var d=jt(65548),m=d+12;K[d>>2>>>0]=m,K[d+4>>2>>>0]=m+65536,m=Rt[0];var w=nr[m];return w===void 0&&(w=Or++,nr[m]=w,ar[w]=m),M[d+8>>2>>>0]=w,d}function Pr(d){if(!W){if(st===0){var m=!1,w=!1;d((x=0)=>{if(!W&&(Er=x,m=!0,w)){st=2,yt(()=>qt(Qe)),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.resume(),x=!1;try{var T=(0,O[ar[M[Qe+8>>2>>>0]]])()}catch(se){T=se,x=!0}var H=!1;if(!Qe){var U=Pt;U&&(Pt=null,(x?U.reject:U.resolve)(T),H=!0)}if(x&&!H)throw T}}),w=!0,m||(st=1,Qe=Rr(),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.pause(),yt(()=>dr(Qe)))}else st===2?(st=0,yt(Bt),or(Qe),Qe=null,Tr.forEach(x=>{if(!W)try{if(x(),!A)try{V=V=x=V,A||(r.onExit&&r.onExit(x),W=!0),l(x,new Xe(x))}catch(T){T instanceof Xe||T=="unwind"||l(1,T)}}catch(T){T instanceof Xe||T=="unwind"||l(1,T)}})):Ze(`invalid state: ${st}`);return Er}}function Br(d){return Pr(m=>{d().then(m)})}var Mr={n:function(d,m,w){return Br(async()=>{await r.Pa(d,m,w)})},a:function(d,m,w){throw d>>>=0,new kt(d).Ya(m>>>0,w>>>0),Xt=d,Ir++,Xt},g:function(){return 0},J:function(){},z:function(){},B:function(){},L:function(){return 0},H:function(){},C:function(){},G:function(){},l:function(){},A:function(){},x:function(){},I:function(){},y:function(){},m:()=>!0,q:function(d,m,w){d=m+2097152>>>0<4194305-!!d?(d>>>0)+4294967296*m:NaN,w>>>=0,d=new Date(1e3*d),M[w>>2>>>0]=d.getUTCSeconds(),M[w+4>>2>>>0]=d.getUTCMinutes(),M[w+8>>2>>>0]=d.getUTCHours(),M[w+12>>2>>>0]=d.getUTCDate(),M[w+16>>2>>>0]=d.getUTCMonth(),M[w+20>>2>>>0]=d.getUTCFullYear()-1900,M[w+24>>2>>>0]=d.getUTCDay(),M[w+28>>2>>>0]=(d.getTime()-Date.UTC(d.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(d,m,w){d=m+2097152>>>0<4194305-!!d?(d>>>0)+4294967296*m:NaN,w>>>=0,d=new Date(1e3*d),M[w>>2>>>0]=d.getSeconds(),M[w+4>>2>>>0]=d.getMinutes(),M[w+8>>2>>>0]=d.getHours(),M[w+12>>2>>>0]=d.getDate(),M[w+16>>2>>>0]=d.getMonth(),M[w+20>>2>>>0]=d.getFullYear()-1900,M[w+24>>2>>>0]=d.getDay(),M[w+28>>2>>>0]=(ht(d.getFullYear())?Cr:gt)[d.getMonth()]+d.getDate()-1|0,M[w+36>>2>>>0]=-(60*d.getTimezoneOffset()),m=new Date(d.getFullYear(),6,1).getTimezoneOffset();var x=new Date(d.getFullYear(),0,1).getTimezoneOffset();M[w+32>>2>>>0]=(m!=x&&d.getTimezoneOffset()==Math.min(x,m))|0},s:function(d){d>>>=0;var m=new Date(M[d+20>>2>>>0]+1900,M[d+16>>2>>>0],M[d+12>>2>>>0],M[d+8>>2>>>0],M[d+4>>2>>>0],M[d>>2>>>0],0),w=M[d+32>>2>>>0],x=m.getTimezoneOffset(),T=new Date(m.getFullYear(),6,1).getTimezoneOffset(),H=new Date(m.getFullYear(),0,1).getTimezoneOffset(),U=Math.min(H,T);return 0>w?M[d+32>>2>>>0]=+(T!=H&&U==x):0<w!=(U==x)&&(T=Math.max(H,T),m.setTime(m.getTime()+6e4*((0<w?U:T)-x))),M[d+24>>2>>>0]=m.getDay(),M[d+28>>2>>>0]=(ht(m.getFullYear())?Cr:gt)[m.getMonth()]+m.getDate()-1|0,M[d>>2>>>0]=m.getSeconds(),M[d+4>>2>>>0]=m.getMinutes(),M[d+8>>2>>>0]=m.getHours(),M[d+12>>2>>>0]=m.getDate(),M[d+16>>2>>>0]=m.getMonth(),M[d+20>>2>>>0]=m.getYear(),d=m.getTime()/1e3,ir((Ge=d,1<=+Math.abs(Ge)?0<Ge?+Math.floor(Ge/4294967296)>>>0:~~+Math.ceil((Ge-+(~~Ge>>>0))/4294967296)>>>0:0)),d>>>0},o:function(){return-52},p:function(){},v:function(d,m,w){function x(Z){return(Z=Z.toTimeString().match(/\(([A-Za-z ]+)\)$/))?Z[1]:"GMT"}w>>>=0;var T=new Date().getFullYear(),H=new Date(T,0,1),U=new Date(T,6,1);T=H.getTimezoneOffset();var se=U.getTimezoneOffset();K[d>>>0>>2>>>0]=60*Math.max(T,se),M[m>>>0>>2>>>0]=+(T!=se),d=x(H),m=x(U),d=Ht(d),m=Ht(m),se<T?(K[w>>2>>>0]=d,K[w+4>>2>>>0]=m):(K[w>>2>>>0]=m,K[w+4>>2>>>0]=d)},e:()=>{Ze("")},b:function(d,m,w){return d>>>=0,m=Lt(m>>>0,w>>>0),it[d].apply(null,m)},i:function(d,m,w){return d>>>=0,m=Lt(m>>>0,w>>>0),it[d].apply(null,m)},h:function(){return Date.now()},w:function(){return 4294901760},c:()=>performance.now(),K:function(d,m,w){return m>>>=0,oe.copyWithin(d>>>0>>>0,m>>>0,m+(w>>>0)>>>0)},u:function(d){d>>>=0;var m=oe.length;if(4294901760<d)return!1;for(var w=1;4>=w;w*=2){var x=m*(1+.2/w);x=Math.min(x,d+100663296);var T=Math;x=Math.max(d,x);e:{T=T.min.call(T,4294901760,x+(65536-x%65536)%65536)-B.buffer.byteLength+65535>>>16;try{B.grow(T),ve();var H=1;break e}catch{}H=void 0}if(H)return!0}return!1},D:function(d,m){d>>>=0,m>>>=0;var w=0;return er().forEach(function(x,T){var H=m+w;for(T=K[d+4*T>>2>>>0]=H,H=0;H<x.length;++H)Y[T++>>0>>>0]=x.charCodeAt(H);Y[T>>0>>>0]=0,w+=x.length+1}),0},E:function(d,m){d>>>=0,m>>>=0;var w=er();K[d>>2>>>0]=w.length;var x=0;return w.forEach(function(T){x+=T.length+1}),K[m>>2>>>0]=x,0},f:()=>52,k:function(){return 52},t:function(){return 70},j:function(d,m,w,x){m>>>=0,w>>>=0,x>>>=0;for(var T=0,H=0;H<w;H++){var U=K[m>>2>>>0],se=K[m+4>>2>>>0];m+=8;for(var Z=0;Z<se;Z++){var ee=oe[U+Z>>>0],X=_r[d];ee===0||ee===10?((d===1?_:C)(Qt(X,0)),X.length=0):X.push(ee)}T+=se}return K[x>>2>>>0]=T,0},F:ie,d:function(d,m,w,x){return ie(d>>>0,m>>>0,w>>>0,x>>>0)}};(function(){function d(w){if(w=w.exports,w=Ar(w),O=w=xt(w),B=O.M,ve(),xe.unshift(O.N),Ie--,r.monitorRunDependencies&&r.monitorRunDependencies(Ie),Ie==0&&($t!==null&&(clearInterval($t),$t=null),qe)){var x=qe;qe=null,x()}return w}var m={a:Mr};if(Ie++,r.monitorRunDependencies&&r.monitorRunDependencies(Ie),r.instantiateWasm)try{return r.instantiateWasm(m,d)}catch(w){C("Module.instantiateWasm callback failed with error: "+w),n(w)}return ze(m,function(w){d(w.instance)}).catch(n),{}})(),r._OrtInit=(d,m)=>(r._OrtInit=O.O)(d,m),r._OrtGetLastError=(d,m)=>(r._OrtGetLastError=O.P)(d,m),r._OrtCreateSessionOptions=(d,m,w,x,T,H,U,se,Z,ee)=>(r._OrtCreateSessionOptions=O.Q)(d,m,w,x,T,H,U,se,Z,ee),r._OrtAppendExecutionProvider=(d,m)=>(r._OrtAppendExecutionProvider=O.R)(d,m),r._OrtAddFreeDimensionOverride=(d,m,w)=>(r._OrtAddFreeDimensionOverride=O.S)(d,m,w),r._OrtAddSessionConfigEntry=(d,m,w)=>(r._OrtAddSessionConfigEntry=O.T)(d,m,w),r._OrtReleaseSessionOptions=d=>(r._OrtReleaseSessionOptions=O.U)(d),r._OrtCreateSession=(d,m,w)=>(r._OrtCreateSession=O.V)(d,m,w),r._OrtReleaseSession=d=>(r._OrtReleaseSession=O.W)(d),r._OrtGetInputOutputCount=(d,m,w)=>(r._OrtGetInputOutputCount=O.X)(d,m,w),r._OrtGetInputName=(d,m)=>(r._OrtGetInputName=O.Y)(d,m),r._OrtGetOutputName=(d,m)=>(r._OrtGetOutputName=O.Z)(d,m),r._OrtFree=d=>(r._OrtFree=O._)(d),r._OrtCreateTensor=(d,m,w,x,T,H)=>(r._OrtCreateTensor=O.$)(d,m,w,x,T,H),r._OrtGetTensorData=(d,m,w,x,T)=>(r._OrtGetTensorData=O.aa)(d,m,w,x,T),r._OrtReleaseTensor=d=>(r._OrtReleaseTensor=O.ba)(d),r._OrtCreateRunOptions=(d,m,w,x)=>(r._OrtCreateRunOptions=O.ca)(d,m,w,x),r._OrtAddRunConfigEntry=(d,m,w)=>(r._OrtAddRunConfigEntry=O.da)(d,m,w),r._OrtReleaseRunOptions=d=>(r._OrtReleaseRunOptions=O.ea)(d),r._OrtCreateBinding=d=>(r._OrtCreateBinding=O.fa)(d),r._OrtBindInput=(d,m,w)=>(r._OrtBindInput=O.ga)(d,m,w),r._OrtBindOutput=(d,m,w,x)=>(r._OrtBindOutput=O.ha)(d,m,w,x),r._OrtClearBoundOutputs=d=>(r._OrtClearBoundOutputs=O.ia)(d),r._OrtReleaseBinding=d=>(r._OrtReleaseBinding=O.ja)(d),r._OrtRunWithBinding=(d,m,w,x,T)=>(r._OrtRunWithBinding=O.ka)(d,m,w,x,T),r._OrtRun=(d,m,w,x,T,H,U,se)=>(r._OrtRun=O.la)(d,m,w,x,T,H,U,se),r._OrtEndProfiling=d=>(r._OrtEndProfiling=O.ma)(d),r._JsepOutput=(d,m,w)=>(r._JsepOutput=O.na)(d,m,w),r._JsepGetNodeName=d=>(r._JsepGetNodeName=O.oa)(d);var jt=r._malloc=d=>(jt=r._malloc=O.pa)(d),or=r._free=d=>(or=r._free=O.qa)(d),ir=d=>(ir=O.sa)(d),sr=()=>(sr=O.ta)(),ur=d=>(ur=O.ua)(d),lr=d=>(lr=O.va)(d),dr=d=>(dr=O.xa)(d),cr=()=>(cr=O.ya)(),qt=d=>(qt=O.za)(d),Bt=()=>(Bt=O.Aa)();r.___start_em_js=922423,r.___stop_em_js=922584;function xt(d){d=Object.assign({},d);var m=x=>()=>x()>>>0,w=x=>T=>x(T)>>>0;return d.__errno_location=m(d.__errno_location),d.malloc=w(d.malloc),d.stackSave=m(d.stackSave),d.stackAlloc=w(d.stackAlloc),d}r.stackAlloc=lr,r.stackSave=sr,r.stackRestore=ur,r.UTF8ToString=Be,r.stringToUTF8=(d,m,w)=>Jt(d,oe,m,w),r.lengthBytesUTF8=Ut;var Mt;qe=function d(){Mt||pr(),Mt||(qe=d)};function pr(){function d(){if(!Mt&&(Mt=!0,r.calledRun=!0,!W)){if(Tt(xe),a(r),r.onRuntimeInitialized&&r.onRuntimeInitialized(),r.postRun)for(typeof r.postRun=="function"&&(r.postRun=[r.postRun]);r.postRun.length;){var m=r.postRun.shift();Pe.unshift(m)}Tt(Pe)}}if(!(0<Ie)){if(r.preRun)for(typeof r.preRun=="function"&&(r.preRun=[r.preRun]);r.preRun.length;)Ee();Tt(j),0<Ie||(r.setStatus?(r.setStatus("Running..."),setTimeout(function(){setTimeout(function(){r.setStatus("")},1),d()},1)):d())}}if(r.preInit)for(typeof r.preInit=="function"&&(r.preInit=[r.preInit]);0<r.preInit.length;)r.preInit.pop()();return pr(),t.ready}})();typeof xo=="object"&&typeof Vn=="object"?Vn.exports=So:typeof define=="function"&&define.amd&&define([],()=>So)});var Co=Kt(()=>{});var _o=Kt(()=>{});var Ao={};zt(Ao,{cpus:()=>ql});var ql,Eo=F(()=>{ql=void 0});var ko=Kt((To,Nn)=>{"use strict";var Oo=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){function r(){return ve.buffer!=Ie.buffer&&pe(),Ie}function a(){return ve.buffer!=Ie.buffer&&pe(),$t}function n(){return ve.buffer!=Ie.buffer&&pe(),qe}function s(){return ve.buffer!=Ie.buffer&&pe(),Ze}function u(){return ve.buffer!=Ie.buffer&&pe(),G}function l(){return ve.buffer!=Ie.buffer&&pe(),de}var o=t,p,f;o.ready=new Promise((i,c)=>{p=i,f=c}),o.jsepInit=(i,c,h,S,E,D,N,te)=>{o.Qb=i,o.wb=c,o.yb=h,o.jb=S,o.xb=E,o.Ea=D,o.zb=N,o.Ab=te,c=(Q,J,ae)=>(...ge)=>{let we=ut,R=J?.();ge=Q(...ge);let le=J?.();return R!==le&&(Q=le,ae(R),J=ae=null),ut!=we?Rl():ge},h=Q=>async(...J)=>{try{if(o.bb)throw Error("Session already started");let ae=o.bb={Fb:J[0],errors:[]},ge=await Q(...J);if(o.bb!==ae)throw Error("Session mismatch");i.flush();let we=ae.errors;if(0<we.length){let R=await Promise.all(we);if(R=R.filter(le=>le),0<R.length)throw Error(R.join(`
`))}return ge}finally{o.bb=null}},o._OrtRun=h(c(o._OrtRun,()=>o._OrtRun,Q=>o._OrtRun=Q)),o._OrtRunWithBinding=h(c(o._OrtRunWithBinding,()=>o._OrtRunWithBinding,Q=>o._OrtRunWithBinding=Q)),o._OrtBindInput=c(o._OrtBindInput,()=>o._OrtBindInput,Q=>o._OrtBindInput=Q),o.jsepRegisterBuffer=(Q,J,ae,ge)=>i.registerBuffer(Q,J,ae,ge),o.jsepUnregisterBuffers=Q=>{i.unregisterBuffers(Q)},o.jsepGetBuffer=Q=>i.getBuffer(Q),o.jsepCreateDownloader=(Q,J,ae)=>i.createDownloader(Q,J,ae)};var y=Object.assign({},o),g="./this.program",b=(i,c)=>{throw c},v=typeof window=="object",$=typeof importScripts=="function",I=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",_=o.ENVIRONMENT_IS_PTHREAD||!1,C="";function P(i){return o.locateFile?o.locateFile(i,C):C+i}var A,B,O;if(I){var W=(Dn(),Ct(Mn)),V=(Wn(),Ct(zn));C=$?V.dirname(C)+"/":__dirname+"/",A=(c,h)=>(c=c.startsWith("file://")?new URL(c):V.normalize(c),W.readFileSync(c,h?void 0:"utf8")),O=c=>(c=A(c,!0),c.buffer||(c=new Uint8Array(c)),c),B=(c,h,S,E=!0)=>{c=c.startsWith("file://")?new URL(c):V.normalize(c),W.readFile(c,E?void 0:"utf8",(D,N)=>{D?S(D):h(E?N.buffer:N)})},!o.thisProgram&&1<process.argv.length&&(g=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),b=(c,h)=>{throw process.exitCode=c,h},o.inspect=()=>"[Emscripten Module object]";let i;try{i=Co()}catch(c){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),c}global.Worker=i.Worker}else(v||$)&&($?C=self.location.href:typeof document<"u"&&document.currentScript&&(C=document.currentScript.src),typeof e<"u"&&e&&(C=e),C.indexOf("blob:")!==0?C=C.substr(0,C.replace(/[?#].*/,"").lastIndexOf("/")+1):C="",I||(A=i=>{var c=new XMLHttpRequest;return c.open("GET",i,!1),c.send(null),c.responseText},$&&(O=i=>{var c=new XMLHttpRequest;return c.open("GET",i,!1),c.responseType="arraybuffer",c.send(null),new Uint8Array(c.response)}),B=(i,c,h)=>{var S=new XMLHttpRequest;S.open("GET",i,!0),S.responseType="arraybuffer",S.onload=()=>{S.status==200||S.status==0&&S.response?c(S.response):h()},S.onerror=h,S.send(null)}));I&&typeof performance>"u"&&(global.performance=_o().performance);var Y=console.log.bind(console),oe=console.error.bind(console);I&&(Y=(...i)=>W.writeSync(1,i.join(" ")+`
`),oe=(...i)=>W.writeSync(2,i.join(" ")+`
`));var M=o.print||Y,K=o.printErr||oe;Object.assign(o,y),y=null,o.thisProgram&&(g=o.thisProgram),o.quit&&(b=o.quit);var Se;o.wasmBinary&&(Se=o.wasmBinary);var ue=o.noExitRuntime||!0;typeof WebAssembly!="object"&&tt("no native wasm support detected");var ve,j,xe,Pe=!1,Ee,Ie,$t,qe,Ze,G,de;function pe(){var i=ve.buffer;o.HEAP8=Ie=new Int8Array(i),o.HEAP16=new Int16Array(i),o.HEAP32=qe=new Int32Array(i),o.HEAPU8=$t=new Uint8Array(i),o.HEAPU16=new Uint16Array(i),o.HEAPU32=Ze=new Uint32Array(i),o.HEAPF32=G=new Float32Array(i),o.HEAPF64=de=new Float64Array(i)}var Ve=o.INITIAL_MEMORY||16777216;if(5242880<=Ve||tt("INITIAL_MEMORY should be larger than STACK_SIZE, was "+Ve+"! (STACK_SIZE=5242880)"),_)ve=o.wasmMemory;else if(o.wasmMemory)ve=o.wasmMemory;else if(ve=new WebAssembly.Memory({initial:Ve/65536,maximum:65536,shared:!0}),!(ve.buffer instanceof SharedArrayBuffer))throw K("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),I&&K("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");pe(),Ve=ve.buffer.byteLength;var Ke=[],ke=[],ze=[],Ge=0;function it(){return ue||0<Ge}var Xe=0,Tt=null,kt=null;function Xt(){Xe++,o.monitorRunDependencies&&o.monitorRunDependencies(Xe)}function Ir(){if(Xe--,o.monitorRunDependencies&&o.monitorRunDependencies(Xe),Xe==0&&(Tt!==null&&(clearInterval(Tt),Tt=null),kt)){var i=kt;kt=null,i()}}function tt(i){throw o.onAbort&&o.onAbort(i),i="Aborted("+i+")",K(i),Pe=!0,Ee=1,i=new WebAssembly.RuntimeError(i+". Build with -sASSERTIONS for more info."),f(i),i}function Qt(i){return i.startsWith("data:application/octet-stream;base64,")}var Be;Be="ort-wasm-simd-threaded.wasm",Qt(Be)||(Be=P(Be));function Ut(i){if(i==Be&&Se)return new Uint8Array(Se);if(O)return O(i);throw"both async and sync fetching of the wasm failed"}function Jt(i){if(!Se&&(v||$)){if(typeof fetch=="function"&&!i.startsWith("file://"))return fetch(i,{credentials:"same-origin"}).then(c=>{if(!c.ok)throw"failed to load wasm binary file at '"+i+"'";return c.arrayBuffer()}).catch(()=>Ut(i));if(B)return new Promise((c,h)=>{B(i,S=>c(new Uint8Array(S)),h)})}return Promise.resolve().then(()=>Ut(i))}function ht(i,c,h){return Jt(i).then(S=>WebAssembly.instantiate(S,c)).then(S=>S).then(h,S=>{K("failed to asynchronously prepare wasm: "+S),tt(S)})}function Cr(i,c){var h=Be;return Se||typeof WebAssembly.instantiateStreaming!="function"||Qt(h)||h.startsWith("file://")||I||typeof fetch!="function"?ht(h,i,c):fetch(h,{credentials:"same-origin"}).then(S=>WebAssembly.instantiateStreaming(S,i).then(c,function(E){return K("wasm streaming compile failed: "+E),K("falling back to ArrayBuffer instantiation"),ht(h,i,c)}))}var gt,Ht={1425328:i=>{o.Ea("Abs",i,void 0)},1425379:i=>{o.Ea("Neg",i,void 0)},1425430:i=>{o.Ea("Floor",i,void 0)},1425483:i=>{o.Ea("Ceil",i,void 0)},1425535:i=>{o.Ea("Reciprocal",i,void 0)},1425593:i=>{o.Ea("Sqrt",i,void 0)},1425645:i=>{o.Ea("Exp",i,void 0)},1425696:i=>{o.Ea("Erf",i,void 0)},1425747:i=>{o.Ea("Sigmoid",i,void 0)},1425802:i=>{o.Ea("Log",i,void 0)},1425853:i=>{o.Ea("Sin",i,void 0)},1425904:i=>{o.Ea("Cos",i,void 0)},1425955:i=>{o.Ea("Tan",i,void 0)},1426006:i=>{o.Ea("Asin",i,void 0)},1426058:i=>{o.Ea("Acos",i,void 0)},1426110:i=>{o.Ea("Atan",i,void 0)},1426162:i=>{o.Ea("Sinh",i,void 0)},1426214:i=>{o.Ea("Cosh",i,void 0)},1426266:i=>{o.Ea("Asinh",i,void 0)},1426319:i=>{o.Ea("Acosh",i,void 0)},1426372:i=>{o.Ea("Atanh",i,void 0)},1426425:i=>{o.Ea("Tanh",i,void 0)},1426477:i=>{o.Ea("Not",i,void 0)},1426528:(i,c,h)=>{o.Ea("Clip",i,{min:c,max:h})},1426597:i=>{o.Ea("Clip",i,void 0)},1426649:(i,c)=>{o.Ea("Elu",i,{alpha:c})},1426707:i=>{o.Ea("Relu",i,void 0)},1426759:(i,c)=>{o.Ea("LeakyRelu",i,{alpha:c})},1426823:(i,c)=>{o.Ea("ThresholdedRelu",i,{alpha:c})},1426893:i=>{o.zb(i)},1426927:(i,c)=>o.Ab(i,c,o.bb.Fb,o.bb.errors),1427039:(i,c)=>{o.Ea("Cast",i,{to:c})},1427097:i=>{o.Ea("Add",i,void 0)},1427148:i=>{o.Ea("Sub",i,void 0)},1427199:i=>{o.Ea("Mul",i,void 0)},1427250:i=>{o.Ea("Div",i,void 0)},1427301:i=>{o.Ea("Pow",i,void 0)},1427352:i=>{o.Ea("Equal",i,void 0)},1427405:i=>{o.Ea("Greater",i,void 0)},1427460:i=>{o.Ea("GreaterOrEqual",i,void 0)},1427522:i=>{o.Ea("Less",i,void 0)},1427574:i=>{o.Ea("LessOrEqual",i,void 0)},1427633:(i,c,h,S,E)=>{o.Ea("ReduceMean",i,{keepDims:!!c,noopWithEmptyAxes:!!h,axes:S?Array.from(n().subarray(E>>>0,E+S>>>0)):[]})},1427797:(i,c,h,S,E)=>{o.Ea("ReduceMax",i,{keepDims:!!c,noopWithEmptyAxes:!!h,axes:S?Array.from(n().subarray(E>>>0,E+S>>>0)):[]})},1427960:(i,c,h,S,E)=>{o.Ea("ReduceMin",i,{keepDims:!!c,noopWithEmptyAxes:!!h,axes:S?Array.from(n().subarray(E>>>0,E+S>>>0)):[]})},1428123:(i,c,h,S,E)=>{o.Ea("ReduceProd",i,{keepDims:!!c,noopWithEmptyAxes:!!h,axes:S?Array.from(n().subarray(E>>>0,E+S>>>0)):[]})},1428287:(i,c,h,S,E)=>{o.Ea("ReduceSum",i,{keepDims:!!c,noopWithEmptyAxes:!!h,axes:S?Array.from(n().subarray(E>>>0,E+S>>>0)):[]})},1428450:(i,c,h,S,E)=>{o.Ea("ReduceL1",i,{keepDims:!!c,noopWithEmptyAxes:!!h,axes:S?Array.from(n().subarray(E>>>0,E+S>>>0)):[]})},1428612:(i,c,h,S,E)=>{o.Ea("ReduceL2",i,{keepDims:!!c,noopWithEmptyAxes:!!h,axes:S?Array.from(n().subarray(E>>>0,E+S>>>0)):[]})},1428774:(i,c,h,S,E)=>{o.Ea("ReduceLogSum",i,{keepDims:!!c,noopWithEmptyAxes:!!h,axes:S?Array.from(n().subarray(E>>>0,E+S>>>0)):[]})},1428940:(i,c,h,S,E)=>{o.Ea("ReduceSumSquare",i,{keepDims:!!c,noopWithEmptyAxes:!!h,axes:S?Array.from(n().subarray(E>>>0,E+S>>>0)):[]})},1429109:(i,c,h,S,E)=>{o.Ea("ReduceLogSumExp",i,{keepDims:!!c,noopWithEmptyAxes:!!h,axes:S?Array.from(n().subarray(E>>>0,E+S>>>0)):[]})},1429278:i=>{o.Ea("Where",i,void 0)},1429331:(i,c,h)=>{o.Ea("Transpose",i,{perm:c?Array.from(n().subarray(h>>>0,h+c>>>0)):[]})},1429444:(i,c,h,S,E,D,N,te,Q,J,ae,ge,we)=>{o.Ea("Conv",i,{format:Q?"NHWC":"NCHW",auto_pad:c,dilations:[h],group:S,kernel_shape:[E],pads:D?Array.from(n().subarray(N>>>0,N+D>>>0)):[],strides:[te],w_is_const:()=>!!r()[J>>>0],activation:Ne(ae),activation_params:ge?Array.from(u().subarray(we>>>0,we+ge>>>0)):[]})},1429825:(i,c,h,S,E,D,N,te,Q,J,ae,ge,we,R,le,ye)=>{o.Ea("Conv",i,{format:ge?"NHWC":"NCHW",auto_pad:c,dilations:[h,S],group:E,kernel_shape:[D,N],pads:te?Array.from(n().subarray(Q>>>0,Q+te>>>0)):[],strides:[J,ae],w_is_const:()=>!!r()[we>>>0],activation:Ne(R),activation_params:le?Array.from(u().subarray(ye>>>0,ye+le>>>0)):[]})},1430227:(i,c,h,S,E,D,N,te,Q,J,ae,ge,we,R,le)=>{o.Ea("ConvTranspose",i,{format:Q?"NHWC":"NCHW",autoPad:c,dilations:[h],group:S,kernel_shape:[E],pads:[D,N],strides:[te],wIsConst:()=>!!r()[J>>>0],outputPadding:ae?Array.from(n().subarray(ge>>>0,ge+ae>>>0)):[],outputShape:we?Array.from(n().subarray(R>>>0,R+we>>>0)):[],activation:Ne(le)})},1430641:(i,c,h,S,E,D,N,te,Q,J,ae,ge,we,R)=>{o.Ea("ConvTranspose",i,{format:te?"NHWC":"NCHW",autoPad:c,dilations:Array.from(n().subarray(h>>>0,h+2>>>0)),group:S,kernelShape:Array.from(n().subarray(E>>>0,E+2>>>0)),pads:Array.from(n().subarray(D>>>0,D+4>>>0)),strides:Array.from(n().subarray(N>>>0,N+2>>>0)),wIsConst:()=>!!r()[Q>>>0],outputPadding:0<J?Array.from(n().subarray(ae>>>0,ae+J>>>0)):[],outputShape:0<ge?Array.from(n().subarray(we>>>0,we+ge>>>0)):[],activation:Ne(R)})},1431198:(i,c,h,S,E,D,N,te,Q,J,ae,ge,we,R,le)=>{o.Ea("ConvTranspose",i,{format:Q?"NHWC":"NCHW",autoPad:c,dilations:[h],group:S,kernel_shape:[E],pads:[D,N],strides:[te],wIsConst:()=>!!r()[J>>>0],outputPadding:ae?Array.from(n().subarray(ge>>>0,ge+ae>>>0)):[],outputShape:we?Array.from(n().subarray(R>>>0,R+we>>>0)):[],activation:Ne(le)})},1431612:(i,c,h,S,E,D,N,te,Q,J,ae,ge,we,R)=>{o.Ea("ConvTranspose",i,{format:te?"NHWC":"NCHW",autoPad:c,dilations:Array.from(n().subarray(h>>>0,h+2>>>0)),group:S,kernelShape:Array.from(n().subarray(E>>>0,E+2>>>0)),pads:Array.from(n().subarray(D>>>0,D+4>>>0)),strides:Array.from(n().subarray(N>>>0,N+2>>>0)),wIsConst:()=>!!r()[Q>>>0],outputPadding:0<J?Array.from(n().subarray(ae>>>0,ae+J>>>0)):[],outputShape:0<ge?Array.from(n().subarray(we>>>0,we+ge>>>0)):[],activation:Ne(R)})},1432169:(i,c)=>{o.Ea("GlobalAveragePool",i,{format:c?"NHWC":"NCHW"})},1432260:(i,c,h,S,E,D,N,te,Q,J,ae,ge,we,R,le,ye)=>{o.Ea("AveragePool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:h,count_include_pad:S,storage_order:E,dilations:[D,N],kernel_shape:[te,Q],pads:[J,ae,ge,we],strides:[R,le]})},1432544:(i,c)=>{o.Ea("GlobalAveragePool",i,{format:c?"NHWC":"NCHW"})},1432635:(i,c,h,S,E,D,N,te,Q,J,ae,ge,we,R,le,ye)=>{o.Ea("AveragePool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:h,count_include_pad:S,storage_order:E,dilations:[D,N],kernel_shape:[te,Q],pads:[J,ae,ge,we],strides:[R,le]})},1432919:(i,c)=>{o.Ea("GlobalMaxPool",i,{format:c?"NHWC":"NCHW"})},1433006:(i,c,h,S,E,D,N,te,Q,J,ae,ge,we,R,le,ye)=>{o.Ea("MaxPool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:h,count_include_pad:S,storage_order:E,dilations:[D,N],kernel_shape:[te,Q],pads:[J,ae,ge,we],strides:[R,le]})},1433286:(i,c)=>{o.Ea("GlobalMaxPool",i,{format:c?"NHWC":"NCHW"})},1433373:(i,c,h,S,E,D,N,te,Q,J,ae,ge,we,R,le,ye)=>{o.Ea("MaxPool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:h,count_include_pad:S,storage_order:E,dilations:[D,N],kernel_shape:[te,Q],pads:[J,ae,ge,we],strides:[R,le]})},1433653:(i,c,h,S,E)=>{o.Ea("Gemm",i,{alpha:c,beta:h,transA:S,transB:E})},1433757:i=>{o.Ea("MatMul",i,void 0)},1433811:(i,c,h,S)=>{o.Ea("ArgMax",i,{keepDims:!!c,selectLastIndex:!!h,axis:S})},1433919:(i,c,h,S)=>{o.Ea("ArgMin",i,{keepDims:!!c,selectLastIndex:!!h,axis:S})},1434027:(i,c)=>{o.Ea("Softmax",i,{axis:c})},1434090:(i,c)=>{o.Ea("Concat",i,{axis:c})},1434150:(i,c,h,S,E)=>{o.Ea("Split",i,{axis:c,numOutputs:h,splitSizes:S?Array.from(n().subarray(E>>>0,E+S>>>0)):[]})},1434295:i=>{o.Ea("Expand",i,void 0)},1434349:(i,c)=>{o.Ea("Gather",i,{axis:Number(c)})},1434420:(i,c)=>{o.Ea("GatherElements",i,{axis:Number(c)})},1434499:(i,c,h,S,E,D,N,te,Q,J,ae)=>{o.Ea("Resize",i,{antialias:c,axes:h?Array.from(n().subarray(S>>>0,S+h>>>0)):[],coordinateTransformMode:Ne(E),cubicCoeffA:D,excludeOutside:N,extrapolationValue:te,keepAspectRatioPolicy:Ne(Q),mode:Ne(J),nearestMode:Ne(ae)})},1434850:(i,c,h,S,E,D,N)=>{o.Ea("Slice",i,{starts:c?Array.from(n().subarray(h>>>0,h+c>>>0)):[],ends:S?Array.from(n().subarray(E>>>0,E+S>>>0)):[],axes:D?Array.from(n().subarray(N>>>0,N+D>>>0)):[]})},1435081:i=>{o.Ea("Tile",i,void 0)},1435133:(i,c,h)=>{o.Ea("LayerNormalization",i,{axis:Number(c),epsilon:Number(h)})},1435240:(i,c,h)=>{o.Ea("InstanceNormalization",i,{epsilon:c,format:h?"NHWC":"NCHW"})},1435354:(i,c,h)=>{o.Ea("InstanceNormalization",i,{epsilon:c,format:h?"NHWC":"NCHW"})},1435468:i=>{o.Ea("Range",i,void 0)},1435521:(i,c)=>{o.Ea("Einsum",i,{equation:Ne(c)})},1435602:(i,c,h,S,E)=>{o.Ea("Pad",i,{mode:c,value:h,pads:S?Array.from(n().subarray(E>>>0,E+S>>>0)):[]})},1435734:(i,c,h,S,E,D,N,te,Q)=>{o.Ea("Attention",i,{numHeads:c,isUnidirectional:h,maskFilterValue:S,scale:E,doRotary:D,qkvHiddenSizes:N?Array.from(n().subarray(Number(te)>>>0,Number(te)+N>>>0)):[],pastPresentShareBuffer:!!Q})},1436006:i=>{o.Ea("Gelu",i,void 0)},1436058:(i,c,h,S,E,D)=>{o.Ea("MultiHeadAttention",i,{numHeads:c,isUnidirectional:h,maskFilterValue:S,scale:E,doRotary:D})},1436217:i=>{o.Ea("BiasAdd",i,void 0)},1436272:i=>{o.Ea("BiasSplitGelu",i,void 0)},1436333:(i,c)=>{o.Ea("SkipLayerNormalization",i,{epsilon:c})},1436414:i=>o.wb(i),1436447:i=>o.yb(i),1436479:(i,c,h)=>{o.jb(i,c,h,!0)},1436518:(i,c,h)=>{o.jb(i,c,h)}};function St(i){this.name="ExitStatus",this.message=`Program terminated with exit(${i})`,this.status=i}function Lt(i){i.terminate(),i.onmessage=()=>{}}function Gt(i){(i=ie.Qa[i])||tt(),ie.Eb(i)}function er(i){var c=ie.tb();if(!c)return 6;ie.Ya.push(c),ie.Qa[i.Xa]=c,c.Xa=i.Xa;var h={cmd:"run",start_routine:i.Gb,arg:i.rb,pthread_ptr:i.Xa};return I&&c.unref(),c.postMessage(h,i.Mb),0}var Ft=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,_r=(i,c,h)=>{c>>>=0;var S=c+h;for(h=c;i[h]&&!(h>=S);)++h;if(16<h-c&&i.buffer&&Ft)return Ft.decode(i.buffer instanceof SharedArrayBuffer?i.slice(c,h):i.subarray(c,h));for(S="";c<h;){var E=i[c++];if(E&128){var D=i[c++]&63;if((E&224)==192)S+=String.fromCharCode((E&31)<<6|D);else{var N=i[c++]&63;E=(E&240)==224?(E&15)<<12|D<<6|N:(E&7)<<18|D<<12|N<<6|i[c++]&63,65536>E?S+=String.fromCharCode(E):(E-=65536,S+=String.fromCharCode(55296|E>>10,56320|E&1023))}}else S+=String.fromCharCode(E)}return S},Ne=(i,c)=>(i>>>=0)?_r(a(),i,c):"";function tr(i){if(_)return U(1,1,i);Ee=i,it()||(ie.Hb(),o.onExit&&o.onExit(i),Pe=!0),b(i,new St(i))}var rr=i=>{if(Ee=i,_)throw Ar(i),"unwind";tr(i)},ie={ab:[],Ya:[],mb:[],Qa:{},gb:function(){_?ie.vb():ie.ub()},ub:function(){Ke.unshift(()=>{Xt(),ie.Bb(()=>Ir())})},vb:function(){ie.receiveObjectTransfer=ie.Db,ie.threadInitTLS=ie.lb,ie.setExitStatus=ie.kb,ue=!1},kb:function(i){Ee=i},Sb:["$terminateWorker"],Hb:function(){for(var i of ie.Ya)Lt(i);for(i of ie.ab)Lt(i);ie.ab=[],ie.Ya=[],ie.Qa=[]},Eb:function(i){var c=i.Xa;delete ie.Qa[c],ie.ab.push(i),ie.Ya.splice(ie.Ya.indexOf(i),1),i.Xa=0,An(c)},Db:function(){},lb:function(){ie.mb.forEach(i=>i())},Cb:i=>new Promise(c=>{i.onmessage=D=>{D=D.data;var N=D.cmd;if(D.targetThread&&D.targetThread!=Wr()){var te=ie.Qa[D.Rb];te?te.postMessage(D,D.transferList):K('Internal error! Worker sent a message "'+N+'" to target pthread '+D.targetThread+", but that thread no longer exists!")}else N==="checkMailbox"?Bt():N==="spawnThread"?er(D):N==="cleanupThread"?Gt(D.thread):N==="killThread"?(D=D.thread,N=ie.Qa[D],delete ie.Qa[D],Lt(N),An(D),ie.Ya.splice(ie.Ya.indexOf(N),1),N.Xa=0):N==="cancelThread"?ie.Qa[D.thread].postMessage({cmd:"cancel"}):N==="loaded"?(i.loaded=!0,c(i)):N==="alert"?alert("Thread "+D.threadId+": "+D.text):D.target==="setimmediate"?i.postMessage(D):N==="callHandler"?o[D.handler](...D.args):N&&K("worker sent an unknown command "+N)},i.onerror=D=>{throw K("worker sent an error! "+D.filename+":"+D.lineno+": "+D.message),D},I&&(i.on("message",function(D){i.onmessage({data:D})}),i.on("error",function(D){i.onerror(D)}));var h=[],S=["onExit","onAbort","print","printErr"],E;for(E of S)o.hasOwnProperty(E)&&h.push(E);i.postMessage({cmd:"load",handlers:h,urlOrBlob:o.mainScriptUrlOrBlob||e,wasmMemory:ve,wasmModule:xe})}),Bb:function(i){i()},qb:function(){var i=P("ort-wasm-simd-threaded.worker.js");i=new Worker(i),ie.ab.push(i)},tb:function(){return ie.ab.length==0&&(ie.qb(),ie.Cb(ie.ab[0])),ie.ab.pop()}};o.PThread=ie;var yt=i=>{for(;0<i.length;)i.shift()(o)};o.establishStackSpace=function(){var i=Wr(),c=n()[i+52>>2>>>0];i=n()[i+56>>2>>>0],Va(c,c-i),Vr(c)};function Ar(i){if(_)return U(2,0,i);rr(i)}o.invokeEntryPoint=function(i,c){i=Na.apply(null,[i,c]),it()?ie.kb(i):En(i)};function st(i){this.fb=i-24,this.pb=function(c){s()[this.fb+4>>2>>>0]=c},this.ob=function(c){s()[this.fb+8>>2>>>0]=c},this.gb=function(c,h){this.nb(),this.pb(c),this.ob(h)},this.nb=function(){s()[this.fb+16>>2>>>0]=0}}var Qe=0,Er=0;function Rt(i,c,h,S){return _?U(3,1,i,c,h,S):nr(i,c,h,S)}function nr(i,c,h,S){if(i>>>=0,c>>>=0,h>>>=0,S>>>=0,typeof SharedArrayBuffer>"u")return K("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var E=[];return _&&E.length===0?Rt(i,c,h,S):(i={Gb:h,Xa:i,rb:S,Mb:E},_?(i.Ob="spawnThread",postMessage(i,E),0):er(i))}function ar(i,c,h){return _?U(4,1,i,c,h):0}function Or(i,c){if(_)return U(5,1,i,c)}var Pt=i=>{for(var c=0,h=0;h<i.length;++h){var S=i.charCodeAt(h);127>=S?c++:2047>=S?c+=2:55296<=S&&57343>=S?(c+=4,++h):c+=3}return c},Tr=(i,c,h,S)=>{if(h>>>=0,!(0<S))return 0;var E=h;S=h+S-1;for(var D=0;D<i.length;++D){var N=i.charCodeAt(D);if(55296<=N&&57343>=N){var te=i.charCodeAt(++D);N=65536+((N&1023)<<10)|te&1023}if(127>=N){if(h>=S)break;c[h++>>>0]=N}else{if(2047>=N){if(h+1>=S)break;c[h++>>>0]=192|N>>6}else{if(65535>=N){if(h+2>=S)break;c[h++>>>0]=224|N>>12}else{if(h+3>=S)break;c[h++>>>0]=240|N>>18,c[h++>>>0]=128|N>>12&63}c[h++>>>0]=128|N>>6&63}c[h++>>>0]=128|N&63}}return c[h>>>0]=0,h-E},kr=(i,c,h)=>Tr(i,a(),c,h);function Rr(i,c){if(_)return U(6,1,i,c)}function Pr(i,c,h){if(_)return U(7,1,i,c,h)}function Br(i,c,h){return _?U(8,1,i,c,h):0}function Mr(i,c){if(_)return U(9,1,i,c)}function jt(i,c,h){if(_)return U(10,1,i,c,h)}function or(i,c,h,S){if(_)return U(11,1,i,c,h,S)}function ir(i,c,h,S){if(_)return U(12,1,i,c,h,S)}function sr(i,c,h,S){if(_)return U(13,1,i,c,h,S)}function ur(i){if(_)return U(14,1,i)}function lr(i,c){if(_)return U(15,1,i,c)}function dr(i,c,h){if(_)return U(16,1,i,c,h)}var cr=i=>{if(!Pe)try{if(i(),!it())try{_?En(Ee):rr(Ee)}catch(c){c instanceof St||c=="unwind"||b(1,c)}}catch(c){c instanceof St||c=="unwind"||b(1,c)}};function qt(i){i>>>=0,typeof Atomics.Nb=="function"&&(Atomics.Nb(n(),i>>2,i).value.then(Bt),i+=128,Atomics.store(n(),i>>2,1))}o.__emscripten_thread_mailbox_await=qt;function Bt(){var i=Wr();i&&(qt(i),cr(()=>za()))}o.checkMailbox=Bt;var xt=i=>i%4===0&&(i%100!==0||i%400===0),Mt=[0,31,60,91,121,152,182,213,244,274,305,335],pr=[0,31,59,90,120,151,181,212,243,273,304,334];function d(i,c,h,S,E,D,N,te){return _?U(17,1,i,c,h,S,E,D,N,te):-52}function m(i,c,h,S,E,D,N){if(_)return U(18,1,i,c,h,S,E,D,N)}var w=i=>{var c=Pt(i)+1,h=_n(c);return h&&kr(i,h,c),h},x=[],T=(i,c)=>{x.length=0;var h;for(c>>=2;h=a()[i++>>>0];)c+=h!=105&c,x.push(h==105?n()[c>>>0]:l()[c++>>>1]),++c;return x},H=i=>{var c=On();return i=i(),Vr(c),i};function U(i,c){var h=arguments.length-2,S=arguments;return H(()=>{for(var E=Tn(8*h),D=E>>3,N=0;N<h;N++){var te=S[2+N];l()[D+N>>>0]=te}return Da(i,h,E,c)})}var se=[],Z={},ee=()=>{if(!X){var i={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:g||"./this.program"},c;for(c in Z)Z[c]===void 0?delete i[c]:i[c]=Z[c];var h=[];for(c in i)h.push(`${c}=${i[c]}`);X=h}return X},X;function ce(i,c){if(_)return U(19,1,i,c);i>>>=0,c>>>=0;var h=0;return ee().forEach(function(S,E){var D=c+h;for(E=s()[i+4*E>>2>>>0]=D,D=0;D<S.length;++D)r()[E++>>0>>>0]=S.charCodeAt(D);r()[E>>0>>>0]=0,h+=S.length+1}),0}function he(i,c){if(_)return U(20,1,i,c);i>>>=0,c>>>=0;var h=ee();s()[i>>2>>>0]=h.length;var S=0;return h.forEach(function(E){S+=E.length+1}),s()[c>>2>>>0]=S,0}function k(i){return _?U(21,1,i):52}function ne(i,c,h,S){return _?U(22,1,i,c,h,S):52}function fe(i,c,h,S,E){return _?U(23,1,i,c,h,S,E):70}var bt=[null,[],[]];function fr(i,c,h,S){if(_)return U(24,1,i,c,h,S);c>>>=0,h>>>=0,S>>>=0;for(var E=0,D=0;D<h;D++){var N=s()[c>>2>>>0],te=s()[c+4>>2>>>0];c+=8;for(var Q=0;Q<te;Q++){var J=a()[N+Q>>>0],ae=bt[i];J===0||J===10?((i===1?M:K)(_r(ae,0)),ae.length=0):ae.push(J)}E+=te}return s()[S>>2>>>0]=E,0}var Ea=[31,29,31,30,31,30,31,31,30,31,30,31],Oa=[31,28,31,30,31,30,31,31,30,31,30,31];function Al(i){var c=Array(Pt(i)+1);return Tr(i,c,0,c.length),c}var El=(i,c)=>{r().set(i,c>>>0)};function Ta(i,c,h,S){function E(R,le,ye){for(R=typeof R=="number"?R.toString():R||"";R.length<le;)R=ye[0]+R;return R}function D(R,le){return E(R,le,"0")}function N(R,le){function ye(ja){return 0>ja?-1:0<ja?1:0}var Dt;return(Dt=ye(R.getFullYear()-le.getFullYear()))===0&&(Dt=ye(R.getMonth()-le.getMonth()))===0&&(Dt=ye(R.getDate()-le.getDate())),Dt}function te(R){switch(R.getDay()){case 0:return new Date(R.getFullYear()-1,11,29);case 1:return R;case 2:return new Date(R.getFullYear(),0,3);case 3:return new Date(R.getFullYear(),0,2);case 4:return new Date(R.getFullYear(),0,1);case 5:return new Date(R.getFullYear()-1,11,31);case 6:return new Date(R.getFullYear()-1,11,30)}}function Q(R){var le=R.Za;for(R=new Date(new Date(R.$a+1900,0,1).getTime());0<le;){var ye=R.getMonth(),Dt=(xt(R.getFullYear())?Ea:Oa)[ye];if(le>Dt-R.getDate())le-=Dt-R.getDate()+1,R.setDate(1),11>ye?R.setMonth(ye+1):(R.setMonth(0),R.setFullYear(R.getFullYear()+1));else{R.setDate(R.getDate()+le);break}}return ye=new Date(R.getFullYear()+1,0,4),le=te(new Date(R.getFullYear(),0,4)),ye=te(ye),0>=N(le,R)?0>=N(ye,R)?R.getFullYear()+1:R.getFullYear():R.getFullYear()-1}i>>>=0,c>>>=0,h>>>=0,S>>>=0;var J=n()[S+40>>2>>>0];S={Kb:n()[S>>2>>>0],Jb:n()[S+4>>2>>>0],cb:n()[S+8>>2>>>0],ib:n()[S+12>>2>>>0],eb:n()[S+16>>2>>>0],$a:n()[S+20>>2>>>0],Wa:n()[S+24>>2>>>0],Za:n()[S+28>>2>>>0],Tb:n()[S+32>>2>>>0],Ib:n()[S+36>>2>>>0],Lb:J?Ne(J):""},h=Ne(h),J={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ae in J)h=h.replace(new RegExp(ae,"g"),J[ae]);var ge="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),we="January February March April May June July August September October November December".split(" ");J={"%a":R=>ge[R.Wa].substring(0,3),"%A":R=>ge[R.Wa],"%b":R=>we[R.eb].substring(0,3),"%B":R=>we[R.eb],"%C":R=>D((R.$a+1900)/100|0,2),"%d":R=>D(R.ib,2),"%e":R=>E(R.ib,2," "),"%g":R=>Q(R).toString().substring(2),"%G":R=>Q(R),"%H":R=>D(R.cb,2),"%I":R=>(R=R.cb,R==0?R=12:12<R&&(R-=12),D(R,2)),"%j":R=>{for(var le=0,ye=0;ye<=R.eb-1;le+=(xt(R.$a+1900)?Ea:Oa)[ye++]);return D(R.ib+le,3)},"%m":R=>D(R.eb+1,2),"%M":R=>D(R.Jb,2),"%n":()=>`
`,"%p":R=>0<=R.cb&&12>R.cb?"AM":"PM","%S":R=>D(R.Kb,2),"%t":()=>"	","%u":R=>R.Wa||7,"%U":R=>D(Math.floor((R.Za+7-R.Wa)/7),2),"%V":R=>{var le=Math.floor((R.Za+7-(R.Wa+6)%7)/7);if(2>=(R.Wa+371-R.Za-2)%7&&le++,le)le==53&&(ye=(R.Wa+371-R.Za)%7,ye==4||ye==3&&xt(R.$a)||(le=1));else{le=52;var ye=(R.Wa+7-R.Za-1)%7;(ye==4||ye==5&&xt(R.$a%400-1))&&le++}return D(le,2)},"%w":R=>R.Wa,"%W":R=>D(Math.floor((R.Za+7-(R.Wa+6)%7)/7),2),"%y":R=>(R.$a+1900).toString().substring(2),"%Y":R=>R.$a+1900,"%z":R=>{R=R.Ib;var le=0<=R;return R=Math.abs(R)/60,(le?"+":"-")+("0000"+(R/60*100+R%60)).slice(-4)},"%Z":R=>R.Lb,"%%":()=>"%"},h=h.replace(/%%/g,"\0\0");for(ae in J)h.includes(ae)&&(h=h.replace(new RegExp(ae,"g"),J[ae](S)));return h=h.replace(/\0\0/g,"%"),ae=Al(h),ae.length>c?0:(El(ae,i),ae.length-1)}function Dr(i){try{i()}catch(c){tt(c)}}function Ol(i){var c={},h;for(h in i)(function(S){var E=i[S];c[S]=typeof E=="function"?function(){zr.push(S);try{return E.apply(null,arguments)}finally{Pe||(zr.pop()===S||tt(),ut&&It===1&&zr.length===0&&(It=0,Ge+=1,Dr(Ha),typeof Fibers<"u"&&Fibers.Ub()))}}:E})(h);return c}var It=0,ut=null,ka=0,zr=[],Ra={},Pa={},Tl=0,Cn=null,kl=[];function Rl(){return new Promise((i,c)=>{Cn={resolve:i,reject:c}})}function Pl(){var i=_n(65548),c=i+12;s()[i>>2>>>0]=c,s()[i+4>>2>>>0]=c+65536,c=zr[0];var h=Ra[c];return h===void 0&&(h=Tl++,Ra[c]=h,Pa[h]=c),c=h,n()[i+8>>2>>>0]=c,i}function Bl(){var i=n()[ut+8>>2>>>0];return i=j[Pa[i]],--Ge,i()}function Ml(i){if(!Pe){if(It===0){var c=!1,h=!1;i((S=0)=>{if(!Pe&&(ka=S,c=!0,h)){It=2,Dr(()=>La(ut)),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.resume(),S=!1;try{var E=Bl()}catch(te){E=te,S=!0}var D=!1;if(!ut){var N=Cn;N&&(Cn=null,(S?N.reject:N.resolve)(E),D=!0)}if(S&&!D)throw E}}),h=!0,c||(It=1,ut=Pl(),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.pause(),Dr(()=>Ua(ut)))}else It===2?(It=0,Dr(Ga),Ba(ut),ut=null,kl.forEach(S=>cr(S))):tt(`invalid state: ${It}`);return ka}}function Dl(i){return Ml(c=>{i().then(c)})}ie.gb();var zl=[null,tr,Ar,Rt,ar,Or,Rr,Pr,Br,Mr,jt,or,ir,sr,ur,lr,dr,d,m,ce,he,k,ne,fe,fr],Wl={r:function(i,c,h){return Dl(async()=>{await o.xb(i,c,h)})},b:function(i,c,h){throw i>>>=0,new st(i).gb(c>>>0,h>>>0),Qe=i,Er++,Qe},P:function(i){Ma(i>>>0,!$,1,!v,131072,!1),ie.lb()},n:function(i){i>>>=0,_?postMessage({cmd:"cleanupThread",thread:i}):Gt(i)},K:nr,g:ar,V:Or,F:Rr,H:Pr,y:Br,T:Mr,L:jt,S:or,p:ir,G:sr,D:ur,U:lr,E:dr,q:()=>!0,B:function(i,c){i>>>=0,i==c>>>0?setTimeout(()=>Bt()):_?postMessage({targetThread:i,cmd:"checkMailbox"}):(i=ie.Qa[i])&&i.postMessage({cmd:"checkMailbox"})},N:function(){return-1},O:qt,X:function(i){I&&ie.Qa[i>>>0].ref()},u:function(i,c,h){i=c+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*c:NaN,h>>>=0,i=new Date(1e3*i),n()[h>>2>>>0]=i.getUTCSeconds(),n()[h+4>>2>>>0]=i.getUTCMinutes(),n()[h+8>>2>>>0]=i.getUTCHours(),n()[h+12>>2>>>0]=i.getUTCDate(),n()[h+16>>2>>>0]=i.getUTCMonth(),n()[h+20>>2>>>0]=i.getUTCFullYear()-1900,n()[h+24>>2>>>0]=i.getUTCDay(),i=(i.getTime()-Date.UTC(i.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,n()[h+28>>2>>>0]=i},v:function(i,c,h){i=c+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*c:NaN,h>>>=0,i=new Date(1e3*i),n()[h>>2>>>0]=i.getSeconds(),n()[h+4>>2>>>0]=i.getMinutes(),n()[h+8>>2>>>0]=i.getHours(),n()[h+12>>2>>>0]=i.getDate(),n()[h+16>>2>>>0]=i.getMonth(),n()[h+20>>2>>>0]=i.getFullYear()-1900,n()[h+24>>2>>>0]=i.getDay(),c=(xt(i.getFullYear())?Mt:pr)[i.getMonth()]+i.getDate()-1|0,n()[h+28>>2>>>0]=c,n()[h+36>>2>>>0]=-(60*i.getTimezoneOffset()),c=new Date(i.getFullYear(),6,1).getTimezoneOffset();var S=new Date(i.getFullYear(),0,1).getTimezoneOffset();i=(c!=S&&i.getTimezoneOffset()==Math.min(S,c))|0,n()[h+32>>2>>>0]=i},w:function(i){i>>>=0;var c=new Date(n()[i+20>>2>>>0]+1900,n()[i+16>>2>>>0],n()[i+12>>2>>>0],n()[i+8>>2>>>0],n()[i+4>>2>>>0],n()[i>>2>>>0],0),h=n()[i+32>>2>>>0],S=c.getTimezoneOffset(),E=new Date(c.getFullYear(),6,1).getTimezoneOffset(),D=new Date(c.getFullYear(),0,1).getTimezoneOffset(),N=Math.min(D,E);return 0>h?n()[i+32>>2>>>0]=+(E!=D&&N==S):0<h!=(N==S)&&(E=Math.max(D,E),c.setTime(c.getTime()+6e4*((0<h?N:E)-S))),n()[i+24>>2>>>0]=c.getDay(),h=(xt(c.getFullYear())?Mt:pr)[c.getMonth()]+c.getDate()-1|0,n()[i+28>>2>>>0]=h,n()[i>>2>>>0]=c.getSeconds(),n()[i+4>>2>>>0]=c.getMinutes(),n()[i+8>>2>>>0]=c.getHours(),n()[i+12>>2>>>0]=c.getDate(),n()[i+16>>2>>>0]=c.getMonth(),n()[i+20>>2>>>0]=c.getYear(),i=c.getTime()/1e3,Wa((gt=i,1<=+Math.abs(gt)?0<gt?+Math.floor(gt/4294967296)>>>0:~~+Math.ceil((gt-+(~~gt>>>0))/4294967296)>>>0:0)),i>>>0},s:d,t:m,A:function(i,c,h){function S(J){return(J=J.toTimeString().match(/\(([A-Za-z ]+)\)$/))?J[1]:"GMT"}i>>>=0,c>>>=0,h>>>=0;var E=new Date().getFullYear(),D=new Date(E,0,1),N=new Date(E,6,1);E=D.getTimezoneOffset();var te=N.getTimezoneOffset(),Q=Math.max(E,te);s()[i>>2>>>0]=60*Q,n()[c>>2>>>0]=+(E!=te),i=S(D),c=S(N),i=w(i),c=w(c),te<E?(s()[h>>2>>>0]=i,s()[h+4>>2>>>0]=c):(s()[h>>2>>>0]=c,s()[h+4>>2>>>0]=i)},e:()=>{tt("")},c:function(i,c,h){return i>>>=0,c=T(c>>>0,h>>>0),Ht[i].apply(null,c)},l:function(i,c,h){return i>>>=0,c=T(c>>>0,h>>>0),Ht[i].apply(null,c)},o:function(){},k:function(){return Date.now()},W:()=>{throw Ge+=1,"unwind"},C:function(){return 4294901760},d:()=>performance.timeOrigin+performance.now(),i:function(){return I?(Eo(),Ct(Ao)).cpus().length:navigator.hardwareConcurrency},M:function(i,c,h,S){for(ie.Pb=c>>>0,se.length=h,c=S>>>0>>3,S=0;S<h;S++)se[S]=l()[c+S>>>0];return(0>i?Ht[-i-1]:zl[i]).apply(null,se)},z:function(i){i>>>=0;var c=a().length;if(i<=c||4294901760<i)return!1;for(var h=1;4>=h;h*=2){var S=c*(1+.2/h);S=Math.min(S,i+100663296);var E=Math;S=Math.max(i,S);e:{E=E.min.call(E,4294901760,S+(65536-S%65536)%65536)-ve.buffer.byteLength+65535>>>16;try{ve.grow(E),pe();var D=1;break e}catch{}D=void 0}if(D)return!0}return!1},Q:ce,R:he,J:rr,h:k,m:ne,x:fe,j:fr,a:ve||o.wasmMemory,I:Ta,f:function(i,c,h,S){return Ta(i>>>0,c>>>0,h>>>0,S>>>0)}};(function(){function i(h,S){return h=h.exports,h=Ol(h),j=h=Vl(h),ie.mb.push(j.Da),ke.unshift(j.Y),xe=S,Ir(),h}var c={a:Wl};if(Xt(),o.instantiateWasm)try{return o.instantiateWasm(c,i)}catch(h){K("Module.instantiateWasm callback failed with error: "+h),f(h)}return Cr(c,function(h){i(h.instance,h.module)}).catch(f),{}})(),o._OrtInit=(i,c)=>(o._OrtInit=j.Z)(i,c),o._OrtGetLastError=(i,c)=>(o._OrtGetLastError=j._)(i,c),o._OrtCreateSessionOptions=(i,c,h,S,E,D,N,te,Q,J)=>(o._OrtCreateSessionOptions=j.$)(i,c,h,S,E,D,N,te,Q,J),o._OrtAppendExecutionProvider=(i,c)=>(o._OrtAppendExecutionProvider=j.aa)(i,c),o._OrtAddFreeDimensionOverride=(i,c,h)=>(o._OrtAddFreeDimensionOverride=j.ba)(i,c,h),o._OrtAddSessionConfigEntry=(i,c,h)=>(o._OrtAddSessionConfigEntry=j.ca)(i,c,h),o._OrtReleaseSessionOptions=i=>(o._OrtReleaseSessionOptions=j.da)(i),o._OrtCreateSession=(i,c,h)=>(o._OrtCreateSession=j.ea)(i,c,h),o._OrtReleaseSession=i=>(o._OrtReleaseSession=j.fa)(i),o._OrtGetInputOutputCount=(i,c,h)=>(o._OrtGetInputOutputCount=j.ga)(i,c,h),o._OrtGetInputName=(i,c)=>(o._OrtGetInputName=j.ha)(i,c),o._OrtGetOutputName=(i,c)=>(o._OrtGetOutputName=j.ia)(i,c),o._OrtFree=i=>(o._OrtFree=j.ja)(i),o._OrtCreateTensor=(i,c,h,S,E,D)=>(o._OrtCreateTensor=j.ka)(i,c,h,S,E,D),o._OrtGetTensorData=(i,c,h,S,E)=>(o._OrtGetTensorData=j.la)(i,c,h,S,E),o._OrtReleaseTensor=i=>(o._OrtReleaseTensor=j.ma)(i),o._OrtCreateRunOptions=(i,c,h,S)=>(o._OrtCreateRunOptions=j.na)(i,c,h,S),o._OrtAddRunConfigEntry=(i,c,h)=>(o._OrtAddRunConfigEntry=j.oa)(i,c,h),o._OrtReleaseRunOptions=i=>(o._OrtReleaseRunOptions=j.pa)(i),o._OrtCreateBinding=i=>(o._OrtCreateBinding=j.qa)(i),o._OrtBindInput=(i,c,h)=>(o._OrtBindInput=j.ra)(i,c,h),o._OrtBindOutput=(i,c,h,S)=>(o._OrtBindOutput=j.sa)(i,c,h,S),o._OrtClearBoundOutputs=i=>(o._OrtClearBoundOutputs=j.ta)(i),o._OrtReleaseBinding=i=>(o._OrtReleaseBinding=j.ua)(i),o._OrtRunWithBinding=(i,c,h,S,E)=>(o._OrtRunWithBinding=j.va)(i,c,h,S,E),o._OrtRun=(i,c,h,S,E,D,N,te)=>(o._OrtRun=j.wa)(i,c,h,S,E,D,N,te),o._OrtEndProfiling=i=>(o._OrtEndProfiling=j.xa)(i),o._JsepOutput=(i,c,h)=>(o._JsepOutput=j.ya)(i,c,h),o._JsepGetNodeName=i=>(o._JsepGetNodeName=j.za)(i);var Wr=o._pthread_self=()=>(Wr=o._pthread_self=j.Aa)(),_n=o._malloc=i=>(_n=o._malloc=j.Ba)(i),Ba=o._free=i=>(Ba=o._free=j.Ca)(i);o.__emscripten_tls_init=()=>(o.__emscripten_tls_init=j.Da)();var Ma=o.__emscripten_thread_init=(i,c,h,S,E,D)=>(Ma=o.__emscripten_thread_init=j.Fa)(i,c,h,S,E,D);o.__emscripten_thread_crashed=()=>(o.__emscripten_thread_crashed=j.Ga)();var Da=(i,c,h,S)=>(Da=j.Ha)(i,c,h,S),An=i=>(An=j.Ia)(i),En=o.__emscripten_thread_exit=i=>(En=o.__emscripten_thread_exit=j.Ja)(i),za=o.__emscripten_check_mailbox=()=>(za=o.__emscripten_check_mailbox=j.Ka)(),Wa=i=>(Wa=j.La)(i),Va=(i,c)=>(Va=j.Ma)(i,c),On=()=>(On=j.Na)(),Vr=i=>(Vr=j.Oa)(i),Tn=i=>(Tn=j.Pa)(i),Na=o.dynCall_ii=(i,c)=>(Na=o.dynCall_ii=j.Ra)(i,c),Ua=i=>(Ua=j.Sa)(i),Ha=()=>(Ha=j.Ta)(),La=i=>(La=j.Ua)(i),Ga=()=>(Ga=j.Va)();o.___start_em_js=1436551,o.___stop_em_js=1436712;function Vl(i){i=Object.assign({},i);var c=S=>()=>S()>>>0,h=S=>E=>S(E)>>>0;return i.__errno_location=c(i.__errno_location),i.pthread_self=c(i.pthread_self),i.malloc=h(i.malloc),i.stackSave=c(i.stackSave),i.stackAlloc=h(i.stackAlloc),i}o.keepRuntimeAlive=it,o.wasmMemory=ve,o.stackAlloc=Tn,o.stackSave=On,o.stackRestore=Vr,o.UTF8ToString=Ne,o.stringToUTF8=kr,o.lengthBytesUTF8=Pt,o.ExitStatus=St,o.PThread=ie;var Nr;kt=function i(){Nr||Fa(),Nr||(kt=i)};function Fa(){function i(){if(!Nr&&(Nr=!0,o.calledRun=!0,!Pe)&&(_||yt(ke),p(o),o.onRuntimeInitialized&&o.onRuntimeInitialized(),!_)){if(o.postRun)for(typeof o.postRun=="function"&&(o.postRun=[o.postRun]);o.postRun.length;){var c=o.postRun.shift();ze.unshift(c)}yt(ze)}}if(!(0<Xe))if(_)p(o),_||yt(ke),startWorker(o);else{if(o.preRun)for(typeof o.preRun=="function"&&(o.preRun=[o.preRun]);o.preRun.length;)Ke.unshift(o.preRun.shift());yt(Ke),0<Xe||(o.setStatus?(o.setStatus("Running..."),setTimeout(function(){setTimeout(function(){o.setStatus("")},1),i()},1)):i())}}if(o.preInit)for(typeof o.preInit=="function"&&(o.preInit=[o.preInit]);0<o.preInit.length;)o.preInit.pop()();return Fa(),t.ready}})();typeof To=="object"&&typeof Nn=="object"?Nn.exports=Oo:typeof define=="function"&&define.amd&&define([],()=>Oo)});var Ro=Kt((Tf,Kl)=>{Kl.exports='"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err("worker.js received unknown command "+e.data.cmd),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\n'});var Bo,Yl,Un,Hn,Yr,Po,Zl,Xl,Ql,Mo,Re,Yt=F(()=>{"use strict";Bo=Io();Yl=ko(),Hn=!1,Yr=!1,Po=!1,Zl=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},Xl=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Ql=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Mo=async e=>{if(Hn)return Promise.resolve();if(Yr)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Po)throw new Error("previous call to 'initializeWebAssembly()' failed.");Yr=!0;let t=e.initTimeout,r=e.numThreads,a=e.simd,n=r>1&&Zl(),s=a&&Xl(),u=e.wasmPaths,l=typeof u=="string"?u:void 0,o=Ql(s,n),p=typeof u=="object"?u[o]:void 0,f=!1,y=[];if(t>0&&y.push(new Promise(g=>{setTimeout(()=>{f=!0,g()},t)})),y.push(new Promise((g,b)=>{let v=n?Yl:Bo,$={locateFile:(I,_)=>{if(n&&I.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Ro()],{type:"text/javascript"}));if(I.endsWith(".wasm")){if(p)return p;let C=l??_;return o==="ort-wasm-simd.wasm"?C+"ort-wasm-simd.jsep.wasm":o==="ort-wasm-simd-threaded.wasm"?C+"ort-wasm-simd-threaded.jsep.wasm":C+o}return _+I}};if(n)if(typeof Blob>"u")$.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let I=`var ortWasmThreaded=${v.toString()};`;$.mainScriptUrlOrBlob=new Blob([I],{type:"text/javascript"})}v($).then(I=>{Yr=!1,Hn=!0,Un=I,g()},I=>{Yr=!1,Po=!0,b(I)})})),await Promise.race(y),f)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Re=()=>{if(Hn&&Un)return Un;throw new Error("WebAssembly is not initialized yet.")}});var Me,hr,Ae,Zr=F(()=>{"use strict";Yt();Me=(e,t)=>{let r=Re(),a=r.lengthBytesUTF8(e)+1,n=r._malloc(a);return r.stringToUTF8(e,n,a),t.push(n),n},hr=(e,t,r,a)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([n,s])=>{let u=t?t+n:n;if(typeof s=="object")hr(s,u+".",r,a);else if(typeof s=="string"||typeof s=="number")a(u,s.toString());else if(typeof s=="boolean")a(u,s?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof s}`)})},Ae=e=>{let t=Re(),r=t.stackSave();try{let a=t.stackAlloc(8);t._OrtGetLastError(a,a+4);let n=t.HEAP32[a/4],s=t.HEAPU32[a/4+1],u=s?t.UTF8ToString(s):"";throw new Error(`${e} ERROR_CODE: ${n}, ERROR_MESSAGE: ${u}`)}finally{t.stackRestore(r)}}});var Do,zo=F(()=>{"use strict";Yt();Zr();Do=e=>{let t=Re(),r=0,a=[],n=e||{};try{if(e?.logSeverityLevel===void 0)n.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)n.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(n.terminate=!1);let s=0;return e?.tag!==void 0&&(s=Me(e.tag,a)),r=t._OrtCreateRunOptions(n.logSeverityLevel,n.logVerbosityLevel,!!n.terminate,s),r===0&&Ae("Can't create run options."),e?.extra!==void 0&&hr(e.extra,"",new WeakSet,(u,l)=>{let o=Me(u,a),p=Me(l,a);t._OrtAddRunConfigEntry(r,o,p)!==0&&Ae(`Can't set a run config entry: ${u} - ${l}.`)}),[r,a]}catch(s){throw r!==0&&t._OrtReleaseRunOptions(r),a.forEach(u=>t._free(u)),s}}});var Jl,ed,td,rd,Wo,Vo=F(()=>{"use strict";Yt();Zr();Jl=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},ed=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},td=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},rd=(e,t,r)=>{for(let a of t){let n=typeof a=="string"?a:a.name;switch(n){case"xnnpack":n="XNNPACK";break;case"webnn":if(n="WEBNN",typeof a!="string"){let u=a;if(u?.deviceType){let l=Me("deviceType",r),o=Me(u.deviceType,r);Re()._OrtAddSessionConfigEntry(e,l,o)!==0&&Ae(`Can't set a session config entry: 'deviceType' - ${u.deviceType}.`)}if(u?.numThreads){let l=u.numThreads;(typeof l!="number"||!Number.isInteger(l)||l<0)&&(l=0);let o=Me("numThreads",r),p=Me(l.toString(),r);Re()._OrtAddSessionConfigEntry(e,o,p)!==0&&Ae(`Can't set a session config entry: 'numThreads' - ${u.numThreads}.`)}if(u?.powerPreference){let l=Me("powerPreference",r),o=Me(u.powerPreference,r);Re()._OrtAddSessionConfigEntry(e,l,o)!==0&&Ae(`Can't set a session config entry: 'powerPreference' - ${u.powerPreference}.`)}}break;case"webgpu":if(n="JS",typeof a!="string"){let u=a;if(u?.preferredLayout){if(u.preferredLayout!=="NCHW"&&u.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${u.preferredLayout}`);let l=Me("preferredLayout",r),o=Me(u.preferredLayout,r);Re()._OrtAddSessionConfigEntry(e,l,o)!==0&&Ae(`Can't set a session config entry: 'preferredLayout' - ${u.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${n}`)}let s=Me(n,r);Re()._OrtAppendExecutionProvider(e,s)!==0&&Ae(`Can't append execution provider: ${n}.`)}},Wo=e=>{let t=Re(),r=0,a=[],n=e||{};td(n);try{let s=Jl(n.graphOptimizationLevel??"all"),u=ed(n.executionMode??"sequential"),l=typeof n.logId=="string"?Me(n.logId,a):0,o=n.logSeverityLevel??2;if(!Number.isInteger(o)||o<0||o>4)throw new Error(`log serverity level is not valid: ${o}`);let p=n.logVerbosityLevel??0;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log verbosity level is not valid: ${p}`);let f=typeof n.optimizedModelFilePath=="string"?Me(n.optimizedModelFilePath,a):0;if(r=t._OrtCreateSessionOptions(s,!!n.enableCpuMemArena,!!n.enableMemPattern,u,!!n.enableProfiling,0,l,o,p,f),r===0&&Ae("Can't create session options."),n.executionProviders&&rd(r,n.executionProviders,a),n.freeDimensionOverrides)for(let[y,g]of Object.entries(n.freeDimensionOverrides)){if(typeof y!="string")throw new Error(`free dimension override name must be a string: ${y}`);if(typeof g!="number"||!Number.isInteger(g)||g<0)throw new Error(`free dimension override value must be a non-negative integer: ${g}`);let b=Me(y,a);t._OrtAddFreeDimensionOverride(r,b,g)!==0&&Ae(`Can't set a free dimension override: ${y} - ${g}.`)}return n.extra!==void 0&&hr(n.extra,"",new WeakSet,(y,g)=>{let b=Me(y,a),v=Me(g,a);t._OrtAddSessionConfigEntry(r,b,v)!==0&&Ae(`Can't set a session config entry: ${y} - ${g}.`)}),[r,a]}catch(s){throw r!==0&&t._OrtReleaseSessionOptions(r),a.forEach(u=>t._free(u)),s}}});var Ln,gr,yr,Xr,br,Qr,Gn,De=F(()=>{"use strict";Ln=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},gr=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},yr=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],Xr=e=>{switch(e){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},br=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Qr=e=>e==="float32"||e==="int32"||e==="int64"||e==="bool"||e==="float16"||e==="uint32",Gn=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var nd,ad,No,Uo,Ho,od,Oe,At=F(()=>{"use strict";De();nd=["V","I","W","E","F"],ad=(e,t)=>{console.log(`[${nd[e]},${new Date().toISOString()}]${t}`)},Ho=(e,t)=>{No=e,Uo=t},od=(e,t)=>{let r=br(e),a=br(No);r>=a&&ad(r,typeof t=="function"?t():t)},Oe=(...e)=>{Uo&&od(...e)}});var Lo,Go=F(()=>{"use strict";De();Lo=(e,t)=>new(Xr(t))(e)});var Jr=F(()=>{"use strict"});var en,id,Fo,jn,Fn,qo,Ko=F(()=>{"use strict";At();Jr();en=e=>Math.ceil(e/16)*16,id=1,Fo=()=>id++,jn=async(e,t,r,a)=>{let n=en(r),s=e.device.createBuffer({size:n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let u=e.getCommandEncoder();e.endComputePass(),u.copyBufferToBuffer(t,0,s,0,n),e.flush(),await s.mapAsync(GPUMapMode.READ);let l=s.getMappedRange();if(a){let o=a();return o.set(new Uint8Array(l,0,r)),o}else return new Uint8Array(l.slice(0,r))}finally{s.destroy()}},Fn=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(t,r){let a=r.buffer,n=r.byteOffset,s=r.byteLength,u=en(s),l=this.storageCache.get(t);if(!l)throw new Error("gpu data for uploading does not exist");if(l.originalSize!==s)throw new Error(`inconsistent data size. gpu data size=${l.originalSize}, data size=${s}`);let o=this.backend.device.createBuffer({mappedAtCreation:!0,size:u,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),p=o.getMappedRange();new Uint8Array(p).set(new Uint8Array(a,n,s)),o.unmap();let f=this.backend.getCommandEncoder();this.backend.endComputePass(),f.copyBufferToBuffer(o,0,l.gpuData.buffer,0,u),Oe("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`),this.buffersForUploadingPending.push(o)}memcpy(t,r){let a=this.storageCache.get(t);if(!a)throw new Error("source gpu data for memcpy does not exist");let n=this.storageCache.get(r);if(!n)throw new Error("destination gpu data for memcpy does not exist");if(a.originalSize!==n.originalSize)throw new Error("inconsistent source and destination gpu data size");let s=en(a.originalSize),u=this.backend.getCommandEncoder();this.backend.endComputePass(),u.copyBufferToBuffer(a.gpuData.buffer,0,n.gpuData.buffer,0,s)}registerExternalBuffer(t,r,a){let n;if(a){if(n=this.externalBuffers.get(a),n===void 0)throw new Error("previous buffer is not registered");if(t===a)return Oe("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, buffer is the same, skip.`),n;this.externalBuffers.delete(a)}else n=Fo();return this.storageCache.set(n,{gpuData:{id:n,type:0,buffer:t},originalSize:r}),this.externalBuffers.set(t,n),Oe("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, registered.`),n}unregisterExternalBuffer(t){let r=this.externalBuffers.get(t);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(t),Oe("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let a=en(t),n,s=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,u=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(s||u){let o=s?this.freeBuffers:this.freeUniformBuffers,p=o.get(a);p||(p=[],o.set(a,p)),p.length>0?n=p.pop():n=this.backend.device.createBuffer({size:a,usage:r})}else n=this.backend.device.createBuffer({size:a,usage:r});let l={id:Fo(),type:0,buffer:n};return this.storageCache.set(l.id,{gpuData:l,originalSize:t}),Oe("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${l.id}`),l}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=this.storageCache.get(t);if(!r)throw new Error("releasing data does not exist");return Oe("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,r){let a=this.storageCache.get(t);if(!a)throw new Error("data does not exist");await jn(this.backend,a.gpuData.buffer,a.originalSize,r)}refreshPendingBuffers(){for(let t of this.buffersForUploadingPending)t.destroy();this.buffersForUploadingPending=[];for(let t of this.buffersPending)(t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(t.size).push(t):(t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(t.size).push(t):t.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},qo=(...e)=>new Fn(...e)});var qn,re,Te=F(()=>{"use strict";qn=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this.key}},re=e=>new qn(e)});var Kn,lt,z,Vt,tn,rn,nn,me=F(()=>{"use strict";Kn=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},lt=class{static calcShape(t,r,a=!1){let n=t.length,s=r.length;if(n===0)return r;if(s===0)return t;let u=Math.max(t.length,r.length),l=new Array(u);if(a){if(n<2||s<2)return;let o=Kn.calcMatMulShape([t[n-2],t[n-1]],[r[s-2],r[s-1]]);if(o===void 0)return;[l[u-2],l[u-1]]=o}for(let o=a?3:1;o<=u;o++){let p=n-o<0?1:t[n-o],f=s-o<0?1:r[s-o];if(p!==f&&p>1&&f>1)return;l[u-o]=Math.max(p,f)}return l}static isValidBroadcast(t,r){let a=t.length,n=r.length;if(a>n)return!1;for(let s=1;s<=a;s++)if(t[a-s]!==1&&t[a-s]!==r[n-s])return!1;return!0}},z=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,a){let n=1;for(let s=r;s<a;s++){if(t[s]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");n*=t[s]}return n}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let a=new Array(r);a[r-1]=1,a[r-2]=t[r-1];for(let n=r-3;n>=0;--n)a[n]=a[n+1]*t[n+1];return a}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error("unsupported axis for this operation.");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(a=>this.normalizeAxis(a,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(a=>t[a]):t.slice().reverse()}static padShape(t,r){let a=t.length;return t.map((n,s)=>n+r[s]+r[s+a])}static areEqual(t,r){return t.length!==r.length?!1:t.every((a,n)=>a===r[n])}},Vt=class e{static adjustPoolAttributes(t,r,a,n,s,u){if(!t&&a.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let l=0;l<r.length-2;l++)l>=a.length?a.push(r[l+2]):a[l]=r[l+2];for(let l=0;l<a.length;l++)if(l<n.length){if(n[l]<0)throw new Error("strides should be greater than or equal to 1")}else n.push(1);for(let l=0;l<a.length;l++)if(l<s.length){if(s[l]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let l=0;l<a.length*2;l++)if(l<u.length){if(u[l]<0)throw new Error("pad should be greater than or equal to 1")}else u.push(0);for(let l=0;l<a.length;l++){if(a[l]<=0)throw new Error("kernel shapes need to be greater than 0");if(u[l]>=a[l]||u[l+a.length]>=a[l])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,a,n,s,u,l){if(l){if(s.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let o=0;o<t.length-2;o++)e.adjustPadAndReturnShape(t[o+(u?1:2)],r[o],a[o],n[o],s,o,o+t.length-2,l)}}static computePoolOutputShape(t,r,a,n,s,u,l){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let o=[r[0],r[1]];return e.computeShapeHelper(t,r,o,a,n,s,u,l),o}static computeConvOutputShape(t,r,a,n,s,u,l){if(t.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let o=[t[0],r[0]];return e.computeShapeHelper(!1,t,o,a,n,s,u,l),o}static computeShapeHelper(t,r,a,n,s,u,l,o){if(t)for(let p=0;p<r.length-2;p++)a.push(1);else for(let p=0;p<r.length-2;p++)a.push(e.adjustPadAndReturnShape(r[p+2],n[p],s[p],u[p],l,p,p+r.length-2,o))}static adjustPadAndReturnShape(t,r,a,n,s,u,l,o){let p=a*(n-1)+1;if(o&&o!=="NOTSET")switch(o){case"VALID":return s[u]=0,s[l]=0,Math.floor((t-p)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(a!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let y=((t+r-1)/r-1)*r+n-t;return s[u]=Math.floor(o==="SAME_LOWER"?(y+1)/2:y/2),s[l]=y-s[u],Math.floor((t+y-n)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+s[u]+s[l]-p)/r+1)}},tn=class{static getShapeOfGemmResult(t,r,a,n,s){if(t.length!==2||a.length!==2)throw new Error("shape need to be of size 2");let u,l,o;r?(u=t[1],l=t[0]):(u=t[0],l=t[1]);let p=-1;if(n?(o=a[0],p=1):(o=a[1],p=0),a[p]!==l)throw new Error("dimension mismatch");if(u<=0||o<=0||l<=0)throw new Error("invalid shape specified");if(s&&!lt.isValidBroadcast(s,[u,o]))throw new Error("gemm: invalid bias shape for broadcast");return[u,o,l]}},rn=-34028234663852886e22,nn=34028234663852886e22});var sd,Yo,Ce,He,et,Le,rt,nt,Zo,L,q,Yn,Xo,Zn,je,be=F(()=>{"use strict";De();me();sd=64,Yo=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},Ce=(e,t=1)=>{let r=Yo(e,t);return typeof r=="string"?r:r[0]},He=e=>e.length===0?[]:[{type:"uint32",data:e},{type:"uint32",data:z.computeStrides(e)}],et=e=>e%4===0?4:e%2===0?2:1,Le=(e="f32",t,r="0")=>!t||t===1?`${e}(${r})`:`vec${t}<${e}>(${r})`,rt=(e,t,r)=>e==="f32"?r:t===1?`f32(${r})`:`vec${t}f(${r})`,nt=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,Zo=(e,t,r,a,n)=>{let s=typeof r=="number",u=s?r:r.length,l=[...new Array(u).keys()],o=u<2?"u32":u<=4?`vec${u}<u32>`:`array<u32, ${u}>`,p=Yo(t,n),f=typeof p=="string"?p:p[1],y=typeof p=="string"?p:p[0],g={indices:o,value:f,storage:y,tensor:t},b=G=>typeof G=="string"?G:`${G}u`,v={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},$=s?"uniforms.":"",I=`${$}${e}_shape`,_=`${$}${e}_strides`,C="";for(let G=0;G<u-1;G++)C+=`
    let dim${G} = current / ${_}[${G}];
    let rest${G} = current % ${_}[${G}];
    indices[${G}] = dim${G};
    current = rest${G};
    `;C+=`indices[${u-1}] = current;`;let P=u<2?"":`
  fn o2i_${e}(offset: u32) -> ${g.indices} {
    var indices: ${g.indices};
    var current = offset;
    ${C}
    return indices;
  }`,A=G=>(v.offsetToIndices=!0,u<2?G:`o2i_${e}(${G})`),B=[];if(u>=2)for(let G=u-1;G>=0;G--)B.push(`${_}[${G}] * (indices[${G}])`);let O=u<2?"":`
  fn i2o_${e}(indices: ${g.indices}) -> u32 {
    return ${B.join("+")};
  }`,W=G=>(v.indicesToOffset=!0,u<2?G:`i2o_${e}(${G})`),V=(...G)=>u===0?"0u":`${g.indices}(${G.map(b).join(",")})`,Y=(G,de)=>u<2?`${G}`:`${G}[${de}]`,oe=(G,de,pe)=>u<2?`${G}=${pe};`:`${G}[${de}]=${pe};`,M={},K=(G,de)=>{v.broadcastedIndicesToOffset=!0;let pe=`${de.name}broadcastedIndicesTo${e}Offset`;if(pe in M)return`${pe}(${G})`;let Ve=[];for(let Ke=u-1;Ke>=0;Ke--){let ke=de.indicesGet("outputIndices",Ke+de.rank-u);Ve.push(`${Y(_,Ke)} * (${ke} % ${Y(I,Ke)})`)}return M[pe]=`fn ${pe}(outputIndices: ${de.type.indices}) -> u32 {
             return ${Ve.length>0?Ve.join("+"):"0u"};
           }`,`${pe}(${G})`},Se=(G,de)=>(()=>{if(g.storage===g.value)return`${e}[${G}]=${de};`;if(g.storage==="vec2<u32>"&&g.value==="i32")return`${e}[${G}]=vec2<u32>(u32(${de}), select(0u, 0xFFFFFFFFu, ${de} < 0));`;if(g.storage==="vec2<u32>"&&g.value==="u32")return`${e}[${G}]=vec2<u32>(u32(${de}), 0u);`;if(g.storage==="u32"&&g.value==="vec4<bool>")return`${e}[${G}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${de}));`;throw new Error(`not supported combination of storage type ${g.storage} and value type ${g.value} yet`)})(),ue=G=>(()=>{if(g.storage===g.value)return`${e}[${G}]`;if(g.storage==="vec2<u32>"&&g.value==="i32")return`i32(${e}[${G}].x)`;if(g.storage==="vec2<u32>"&&g.value==="u32")return`u32(${e}[${G}].x)`;if(g.storage==="u32"&&g.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${G}] & 0xFFu), bool(${e}[${G}] & 0xFF00u), bool(${e}[${G}] & 0xFF0000u), bool(${e}[${G}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${g.storage} and value type ${g.value} yet`)})(),ve=u<2?"":`
  fn get_${e}ByIndices(indices: ${g.indices}) -> ${f} {
    return ${ue(`i2o_${e}(indices)`)};
  }`,j=u<2?"":(()=>{let G=l.map(pe=>`d${pe}: u32`).join(", "),de=l.map(pe=>`d${pe}`).join(", ");return`
  fn get_${e}(${G}) -> ${f} {
    return get_${e}ByIndices(${V(de)});
  }`})(),xe=(...G)=>{if(G.length!==u)throw new Error(`indices length must be ${u}`);let de=G.map(b).join(",");return u===0?ue("0u"):u===1?ue(de[0]):(v.get=!0,v.getByIndices=!0,v.indicesToOffset=!0,`get_${e}(${de})`)},Pe=G=>u<2?ue(G):(v.getByIndices=!0,v.indicesToOffset=!0,`get_${e}ByIndices(${G})`),Ee=u<2?"":`
  fn set_${e}ByIndices(indices: ${g.indices}, value: ${f}) {
    ${Se(`i2o_${e}(indices)`,"value")}
  }`,Ie=u<2?"":(()=>{let G=l.map(pe=>`d${pe}: u32`).join(", "),de=l.map(pe=>`d${pe}`).join(", ");return`
  fn set_${e}(${G}, value: ${f}) {
    set_${e}ByIndices(${V(de)}, value);
  }`})();return{impl:()=>{let G=[];return s||(G.push(`const ${I} = ${g.indices}(${r.join(",")});`),G.push(`const ${_} = ${g.indices}(${z.computeStrides(r).join(",")});`)),v.offsetToIndices&&G.push(P),v.indicesToOffset&&G.push(O),v.broadcastedIndicesToOffset&&Object.values(M).forEach(de=>G.push(de)),v.set&&G.push(Ie),v.setByIndices&&G.push(Ee),v.get&&G.push(j),v.getByIndices&&G.push(ve),G.join(`
`)},type:g,offsetToIndices:A,indicesToOffset:W,broadcastedIndicesToOffset:K,indices:V,indicesGet:Y,indicesSet:oe,set:(...G)=>{if(G.length!==u+1)throw new Error(`indices length must be ${u}`);let de=G[u];if(typeof de!="string")throw new Error("value must be string");let pe=G.slice(0,u).map(b).join(",");return u===0?Se("0u",de):u===1?Se(pe[0],de):(v.set=!0,v.setByIndices=!0,v.indicesToOffset=!0,`set_${e}(${pe}, ${de})`)},setByOffset:Se,setByIndices:(G,de)=>u<2?Se(G,de):(v.setByIndices=!0,v.indicesToOffset=!0,`set_${e}ByIndices(${G}, ${de});`),get:xe,getByOffset:ue,getByIndices:Pe,usage:a?"input":"output",name:e,strides:_,shape:I,rank:u}},L=(e,t,r,a=1)=>Zo(e,t,r,!0,a),q=(e,t,r,a=1)=>Zo(e,t,r,!1,a),Yn=class{constructor(t){this.normalizedDispatchGroup=t;this.indicesHelpers=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=sd){let r=typeof t=="number"?t:t[0],a=typeof t=="number"?1:t[1],n=typeof t=="number"?1:t[2],s=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,u=s?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_index : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,l=s?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${r*a*n}u + local_index;`;return`@compute @workgroup_size(${r}, ${a}, ${n})
  fn main(${u}) {
    ${l}
  `}declareVariable(t,r){this.indicesHelpers.push(t),t.rank!==0&&(t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:t.type.indices}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:t.type.indices}));let a=t.usage==="input"?"read":"read_write",n=t.type.storage;return`@group(0) @binding(${r}) var<storage, ${a}> ${t.name}: array<${n}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`
`)}registerUniform(t,r){return this.uniforms.push({name:t,type:r}),this}registerUniforms(t){return this.uniforms=this.uniforms.concat(t),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:r,type:a}of this.uniforms)t.push(`${r}:${a}`);return`
      struct Uniforms { ${t.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.indicesHelpers.map(t=>t.impl()).join(`
`)}},Xo=e=>new Yn(e),Zn=(e,t)=>{let r=e.length,a=[];for(let n=0;n<r;n++){let s=r-1-n,u=e[s]||1;(t[t.length-1-n]||1)>1&&u===1&&a.unshift(s)}return a},je=e=>e<=4});var ud,Qo,ld,dd,at,Jo,ei,Zt=F(()=>{"use strict";me();Te();be();ud=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},Qo=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,ld=(e,t)=>z.sortBasedOnPerm(e,Qo(e.length,t)),dd=(e,t,r,a)=>{let n=[];n.push(`fn perm(i: ${a.type.indices}) -> ${r.type.indices} {
    var a: ${r.type.indices};`);for(let s=0;s<t;++s)n.push(r.indicesSet("a",e[s],`i[${s}]`));return n.push("return a;}"),n.join(`
`)},at=(e,t)=>{let r=e.dataType,a=e.dims.length,n=Qo(a,t),s=je(a),u=ld(e.dims,n),l=s?u.length:u,o=s?a:e.dims,p=q("output",r,l),f=L("a",r,o),y=g=>`
  ${g.registerUniform("output_size","u32").declareVariables(f,p)}

  ${dd(n,a,f,p)}

  ${g.mainStart()}
    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${p.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${p.setByOffset("global_idx",f.getByIndices("aIndices"))}
  }`;return{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:s?["rank"]:["dims"]},getRunData:g=>{let b=z.size(u);return{outputs:[{dims:u,dataType:g[0].dataType}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:s?[{type:"uint32",data:b},...He(g[0].dims),...He(u)]:[{type:"uint32",data:b}]}},getShaderSource:y}},Jo=(e,t)=>{ud(e.inputs),e.compute(at(e.inputs[0],t.perm))},ei=e=>re({perm:e.perm})});var cd,pd,fd,md,hd,gd,yd,bd,wd,vd,dt,ti,ri,ni,ai,oi,ii,si,ui,li,di,ci=F(()=>{"use strict";me();be();an();Zt();cd={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},pd={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},fd={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},md={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},hd=(e,t)=>{let r=[];for(let a=t-e;a<t;++a)r.push(a);return r},gd=(e,t)=>{let r=[],a=e.length;for(let s=0;s<a;s++)t.indexOf(s)===-1&&r.push(e[s]);let n=t.map(s=>e[s]);return[r,n]},yd=(e,t)=>{let r=e.length+t.length,a=[],n=0;for(let s=0;s<r;s++)t.indexOf(s)===-1?a.push(e[n++]):a.push(1);return a},bd=(e,t)=>{for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0},wd=(e,t)=>{let r=[];if(!bd(e,t)){for(let a=0;a<t;++a)e.indexOf(a)===-1&&r.push(a);e.forEach(a=>r.push(a))}return r},vd=(e,t,r,a,n,s,u)=>{let l=r[0].dims,o=z.size(s),p=z.size(u),f=L("_A",r[0].dataType,l),y=q("output",n,s),g=32,b=`
          var<workgroup> aBestValues : array<${y.type.storage}, ${g}>;
       `;return{name:e,shaderCache:t,getShaderSource:$=>`
        ${$.registerUniform("reduceSize","u32").declareVariables(f,y)}
        ${b}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${$.mainStart(g)}
          let local_idx = local_id.x;

          let outputIndex = global_idx / ${g};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = ${y.type.storage}(${fd[a]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${g}) {
           let candidate = ${y.type.storage}(${f.getByOffset("offset + k")});
           bestValue = ${cd[a]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${g}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${pd[a]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${y.setByOffset("outputIndex",`${a==="mean"?`bestValue / ${y.type.storage}(uniforms.reduceSize)`:`${md[a]}`}`)};
         }
        }`,getRunData:()=>({outputs:[{dims:s,dataType:n}],dispatchGroup:{x:o},programUniforms:[{type:"uint32",data:p}]})}},dt=(e,t,r,a)=>{let n=e.inputs.length===1?r:Xn(e.inputs,r),s=n.axes;s.length===0&&!n.noopWithEmptyAxes&&(s=e.inputs[0].dims.map((b,v)=>v));let u=z.normalizeAxes(s,e.inputs[0].dims.length),l=u,o=e.inputs[0],p=wd(l,e.inputs[0].dims.length);p.length>0&&(o=e.compute(at(e.inputs[0],p),{inputs:[0],outputs:[-1]})[0],l=hd(l.length,o.dims.length));let[f,y]=gd(o.dims,l),g=f;n.keepDims&&(g=yd(f,u)),e.compute(vd(t,{hint:n.cacheKey,inputDependencies:["type"]},[o],a,e.inputs[0].dataType,g,y),{inputs:[o]})},ti=(e,t)=>{dt(e,"ReduceMeanShared",t,"mean")},ri=(e,t)=>{dt(e,"ReduceL1Shared",t,"l1")},ni=(e,t)=>{dt(e,"ReduceL2Shared",t,"l2")},ai=(e,t)=>{dt(e,"ReduceLogSumExpShared",t,"logSumExp")},oi=(e,t)=>{dt(e,"ReduceMaxShared",t,"max")},ii=(e,t)=>{dt(e,"ReduceMinShared",t,"min")},si=(e,t)=>{dt(e,"ReduceProdShared",t,"prod")},ui=(e,t)=>{dt(e,"ReduceSumShared",t,"sum")},li=(e,t)=>{dt(e,"ReduceSumSquareShared",t,"sumSquare")},di=(e,t)=>{dt(e,"ReduceLogSumShared",t,"logSum")}});var ct,$d,on,Xn,pt,Sd,xd,Id,Cd,_d,Ad,Ed,Od,Td,kd,ft,pi,fi,mi,hi,gi,yi,bi,wi,vi,$i,ot,an=F(()=>{"use strict";me();Te();be();ci();ct=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},$d=e=>["","",`var value = ${e.getByOffset("inputOffset")};`,""],on=(e,t,r,a,n,s,u=!1,l=!1)=>{let o=[],p=r[0].dims,f=z.normalizeAxes(n,r[0].dims.length),y=!l&&f.length===0;p.forEach((W,V)=>{y||f.indexOf(V)>=0?u&&o.push(1):o.push(W)});let g=[],b=L("_A",r[0].dataType,p),v=q("output",s,o),$=a(b,v,f),I=`inputOffset = ${b.indicesToOffset("inputIndices")};`,_=`let ${I};`,C=`var ${I};`,P=$[1]===""?"":C,A=($[1]===""?_:I)+`
`+$[2];for(let W=0,V=0;W<r[0].dims.length;W++)y||f.indexOf(W)>=0?(u&&V++,A=`for(var j${W}: u32 = 0; j${W} < ${r[0].dims[W]}; j${W}++) {
                ${$[2].includes("lastIndex")?`let lastIndex = j${W};`:""}
                ${b.indicesSet("inputIndices",W,`j${W}`)}
                ${A}
              }`):(g.push(`${b.indicesSet("inputIndices",W,v.indicesGet("outputIndices",V))};`),V++);let B=z.size(o);return{name:e,shaderCache:t,getShaderSource:W=>`
        ${W.declareVariables(b,v)}

        ${W.mainStart()}
          ${W.guardAgainstOutOfBoundsWorkgroupSizes(B)}
          var inputIndices: ${b.type.indices};
          let outputIndices = ${v.offsetToIndices("global_idx")};

          ${g.join(`
`)}
          ${$[0]}       // init ops for reduce max/min
          ${P}
          ${$[1]}
          ${A}
          ${$[3]}
          ${$.length===4?v.setByOffset("global_idx","value"):$.slice(4).join(`
`)}
        }`,getRunData:()=>({outputs:[{dims:o,dataType:s}],dispatchGroup:{x:Math.ceil(B/64)}})}},Xn=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(a=>r.push(Number(a))),re({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},pt=(e,t,r,a)=>{let n=e.inputs,s=n.length===1?r:Xn(n,r);e.compute(on(t,{hint:s.cacheKey},[n[0]],s.noopWithEmptyAxes&&s.axes.length===0?$d:a,s.axes,n[0].dataType,s.keepDims,s.noopWithEmptyAxes),{inputs:[0]})},Sd=(e,t)=>{ct(e.inputs),pt(e,"ReduceLogSum",t,(a,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${a.getByOffset("inputOffset")};`,"value = log(value);"])},xd=(e,t)=>{ct(e.inputs),pt(e,"ReduceL1",t,(a,n)=>[`var value = ${n.type.storage}(0);`,"",`value += abs(${a.getByOffset("inputOffset")});`,""])},Id=(e,t)=>{ct(e.inputs),pt(e,"ReduceL2",t,(a,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${a.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"])},Cd=(e,t)=>{ct(e.inputs),pt(e,"ReduceLogSumExp",t,(a,n)=>[`var value = ${n.type.storage}(0);`,"",`value += exp(${a.getByOffset("inputOffset")});`,"value = log(value);"])},_d=(e,t)=>{ct(e.inputs),pt(e,"ReduceMax",t,(a,n,s)=>{let u=[];for(let l=0;l<a.rank;l++)(s.indexOf(l)>=0||s.length===0)&&u.push(a.indicesSet("inputIndices",l,0));return[`${u.join(`
`)}`,`var value = ${a.getByOffset("inputOffset")};`,`value = max(value, ${a.getByOffset("inputOffset")});`,""]})},Ad=(e,t)=>{ct(e.inputs),pt(e,"ReduceMean",t,(a,n,s)=>{let u=1;for(let l=0;l<a.rank;l++)(s.indexOf(l)>=0||s.length===0)&&(u*=e.inputs[0].dims[l]);return["var sum = f32(0);","",`sum += f32(${a.getByOffset("inputOffset")});`,`let value = ${n.type.value}(sum / ${u});`]})},Ed=(e,t)=>{ct(e.inputs),pt(e,"ReduceMin",t,(a,n,s)=>{let u=[];for(let l=0;l<a.rank;l++)(s.indexOf(l)>=0||s.length===0)&&u.push(`inputIndices[${l}] = 0;`);return[`${u.join(`
`)}`,`var value = ${a.getByOffset("inputOffset")};`,`value = min(value, ${a.getByOffset("inputOffset")});`,""]})},Od=(e,t)=>{ct(e.inputs),pt(e,"ReduceProd",t,(a,n)=>[`var value = ${n.type.storage}(1);`,"",`value *= ${a.getByOffset("inputOffset")};`,""])},Td=(e,t)=>{ct(e.inputs),pt(e,"ReduceSum",t,(a,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${a.getByOffset("inputOffset")};`,""])},kd=(e,t)=>{ct(e.inputs),pt(e,"ReduceSumSquare",t,(a,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${a.getByOffset("inputOffset")}; value += t * t;`,""])},ft=(e,t,r)=>{if(t.length===0)return!!r;let a=1,n=1;for(let s=0;s<t.length;s++)t.indexOf(s)===-1?a*=e[s]:n*=e[s];return n<32&&a>1024},pi=(e,t)=>{ft(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Ad(e,t):ti(e,t)},fi=(e,t)=>{ft(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?xd(e,t):ri(e,t)},mi=(e,t)=>{ft(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Id(e,t):ni(e,t)},hi=(e,t)=>{ft(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Cd(e,t):ai(e,t)},gi=(e,t)=>{ft(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?_d(e,t):oi(e,t)},yi=(e,t)=>{ft(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Ed(e,t):ii(e,t)},bi=(e,t)=>{ft(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Od(e,t):si(e,t)},wi=(e,t)=>{ft(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Td(e,t):ui(e,t)},vi=(e,t)=>{ft(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?kd(e,t):li(e,t)},$i=(e,t)=>{ft(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Sd(e,t):di(e,t)},ot=e=>re(e)});var Si,xi,Ii,Qn,Ci=F(()=>{"use strict";De();Te();an();Si=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},xi=(e,t)=>{Si(e.inputs);let r=(a,n,s)=>{let u=[];for(let l=0;l<a.rank;l++)(s.indexOf(l)>=0||s.length===0)&&u.push(`inputIndices[${l}] = 0;`);return[`${u.join(`
`)}`,`var value = ${a.getByOffset("inputOffset")};
var bestIndex : i32 = 0;`,`if (${a.getByOffset("inputOffset")} ${t.selectLastIndex>0?"<=":"<"} value) {
         value = ${a.getByOffset("inputOffset")};
         bestIndex = i32(lastIndex);
       }`,"",n.setByOffset("global_idx","bestIndex")]};e.compute(on("ArgMin",{hint:t.cacheKey},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},Ii=(e,t)=>{Si(e.inputs);let r=(a,n,s)=>{let u=[];for(let l=0;l<a.rank;l++)(s.indexOf(l)>=0||s.length===0)&&u.push(`inputIndices[${l}] = 0;`);return[`${u.join(`
`)}`,`var value = ${a.getByOffset("inputOffset")};
var bestIndex : i32 = 0;`,`if (${a.getByOffset("inputOffset")} ${t.selectLastIndex>0?">=":">"} value) {
         value = ${a.getByOffset("inputOffset")};
         bestIndex = i32(lastIndex);
       }`,"",n.setByOffset("global_idx","bestIndex")]};e.compute(on("argMax",{hint:t.cacheKey},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},Qn=e=>re(e)});var Rd,_i,Pd,Bd,Md,sn,Dd,Ai,Jn=F(()=>{"use strict";Te();Jr();be();Rd=(e,t)=>{let r=e[0],a=e[1],n=e[2],s=e[3],u=e[4],l=e[5];if(u&&l)throw new Error("Attention cannot have both past and relative_position_bias");if(r.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let o=r.dims[0],p=r.dims[1],f=r.dims[2];if(n.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(a.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(a.dims[0]!==f)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(n.dims[0]!==a.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let y=n.dims[0]/3,g=y,b=g;if(t.qkvHiddenSizes.length>0){if(t.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let P of t.qkvHiddenSizes)if(P%t.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");y=t.qkvHiddenSizes[0],g=t.qkvHiddenSizes[1],b=t.qkvHiddenSizes[2]}let v=p;if(y!==g)throw new Error("qkv_hidden_sizes first element should be same as the second");if(n.dims[0]!==y+g+b)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let $=0;if(u){if(g!==b)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(u.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(u.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(u.dims[1]!==o)throw new Error('Input "past" second dimension must be batch_size');if(u.dims[2]!==t.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(u.dims[4]!==g/t.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');t.pastPresentShareBuffer||($=u.dims[3])}let I=v+$,_=-1,C=0;if(s)throw new Error("Mask not supported");if(u)throw new Error("past is not supported");if(l)throw new Error("relativePositionBias is not supported");return{batchSize:o,sequenceLength:p,pastSequenceLength:$,kvSequenceLength:v,totalSequenceLength:I,maxSequenceLength:_,inputHiddenSize:f,hiddenSize:y,vHiddenSize:b,headSize:Math.floor(y/t.numHeads),vHeadSize:Math.floor(b/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:C,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},_i=e=>re({...e}),Pd=(e,t,r,a)=>{let n=et(a),s=q("x",t.dataType,t.dims,n),u="threadMaxVector";n===2?u="max(threadMaxVector.x, threadMaxVector.y)":n===4&&(u="max(max(threadMaxVector.x, threadMaxVector.y), max(threadMaxVector.z, threadMaxVector.w))");let l=Ce(t.dataType),o=64,p=a/n;p<o?o=1:p/8<64&&(o=Math.ceil(p/8));let f=Math.ceil(a/n/o),y=g=>`
  const dInv: ${l} = 1 / ${a};
  const dComp = ${a/n};
  var<workgroup> wgMax: array<f32, ${o}>;
  var<workgroup> wgSum: array<f32, ${o}>;

  ${g.declareVariables(s)}
  @compute @workgroup_size(${o}, 1, 1)
  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_index : u32) {
    let localOffset = local_index * ${f};
    let offset: u32 = workgroup_id.x * dComp + localOffset;

    var threadMaxVector = ${Le("f32",n,"-3.402823e+38f")};
    for (var i: u32 = 0; i < ${f} && i + localOffset < dComp; i++) {
      threadMaxVector = max(${rt(l,n,"x[offset + i]")}, threadMaxVector);
    }
    wgMax[local_index] = ${u};
    workgroupBarrier();

    var maxValue = -3.402823e+38f;
    for (var i = 0u; i < ${o}; i++) {
      maxValue = max(wgMax[i], maxValue);
    }

    var sumVector = ${Le("f32",n,"0")};
    for (var i: u32 = 0; i < ${f} && i + localOffset < dComp; i++) {
      sumVector += exp(${rt(l,n,"x[offset + i]")} - maxValue);
    }
    wgSum[local_index] = ${nt("sumVector",n)};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${o}; i++) {
      sum += wgSum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < ${f} && i + localOffset < dComp; i++) {
        x[offset + i] = ${Le(l,n,"dInv")};
      }
    } else {
      for (var i: u32 = 0; i < ${f} && i + localOffset < dComp; i++) {
        let f32input = ${rt(l,n,"x[offset + i]")};
        x[offset + i] = ${s.type.value}(exp(f32input - maxValue) / sum);
      }
    }
  }`;e.compute({name:"AttentionProbsSoftmax",shaderCache:{hint:`${a}`},getShaderSource:y,getRunData:()=>({outputs:[],dispatchGroup:{x:r}})},{inputs:[t],outputs:[]})},Bd=(e,t,r,a,n,s)=>{let u=[n.batchSize,n.numHeads,n.sequenceLength,n.kvSequenceLength+n.pastSequenceLength],l=s.scale===0?1/Math.sqrt(n.headSize):s.scale,o=Ce(t.dataType),p=et(n.headSize),f=L("q",t.dataType,t.dims,p),y=L("key",r.dataType,r.dims,p),g=q("output",t.dataType,u),b=n.headSize/p,v=n.sequenceLength,$=n.totalSequenceLength,I=b,_=12,C={x:Math.ceil(n.totalSequenceLength/_),y:Math.ceil(n.sequenceLength/_),z:n.batchSize*n.numHeads},P=[t,r],A=O=>`
  const M: u32 = ${v}u;
  const N: u32 = ${$}u;
  const K: u32 = ${I}u;
  const alpha: ${o} = ${l};
  const beta: ${o} = 1.0;
  const TILE_SIZE = ${_}u;

  var<workgroup> tileQ: array<${f.type.storage}, ${_*_}>;
  var<workgroup> tileK: array<${f.type.storage}, ${_*_}>;

  ${O.declareVariables(f,y,g)}

  @compute @workgroup_size(${_}, ${_}, 1)
  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,
   @builtin(local_invocation_id) local_id : vec3<u32>, @builtin(local_invocation_index) local_index : u32) {
   let global_idx = (workgroup_id.z * ${C.x*C.y}u +
          workgroup_id.y * ${C.x}u + workgroup_id.x) * ${_*_}u + local_index;

    // x holds the N and y holds the M
    let headIdx = workgroup_id.z;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let lm = m + local_id.y;
    let ln = n + local_id.x;

    let qOffset = ${n.sequenceLength*b} * headIdx + m * K;
    let kOffset = ${n.kvSequenceLength*b} * headIdx + n * K;

    var value = ${Le(o,p)};
    for (var w: u32 = 0u; w < K; w += TILE_SIZE) {
      if (m + local_id.y < M && w + local_id.x < K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * K + w + local_id.x];
      }
      if (n + local_id.y < N && w + local_id.x < K) {
        tileK[TILE_SIZE * local_id.y + local_id.x] = key[kOffset + local_id.y * K + w + local_id.x];
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k<TILE_SIZE && w+k < K; k++) {
        value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k];
      }

      workgroupBarrier();
    }

    let headOffset = headIdx * M * N;
    if (lm < M && ln < N) {
      let outputIdx = headOffset + lm * N + ln;
      output[outputIdx] = ${nt("value",p)} * alpha;
    }
  }`,B=e.compute({name:"AttentionProbs",shaderCache:{hint:JSON.stringify(n)},getRunData:()=>({outputs:[{dims:u,dataType:t.dataType,gpuDataType:0}],dispatchGroup:C}),getShaderSource:A},{inputs:P,outputs:[-1]})[0];return Pd(e,B,n.batchSize*n.numHeads*n.sequenceLength,n.totalSequenceLength),B},Md=(e,t,r,a)=>{let n=[a.batchSize,a.sequenceLength,a.vHiddenSize],s=L("probs",t.dataType,t.dims),u=L("v",r.dataType,r.dims),l=q("output",t.dataType,n),o=Ce(t.dataType),p=12,f={x:Math.ceil(a.vHeadSize/p),y:Math.ceil(a.sequenceLength/p),z:a.batchSize*a.numHeads},y=g=>`
  const M: u32 = ${a.sequenceLength}u;
  const N: u32 = ${a.vHeadSize}u;
  const K: u32 = ${a.totalSequenceLength}u;
  const numHeads: u32 = ${a.numHeads}u;
  const TILE_SIZE = ${p}u;

  var<workgroup> tileQ: array<${s.type.storage}, ${p*p}>;
  var<workgroup> tileK: array<${s.type.storage}, ${p*p}>;

  ${g.declareVariables(s,u,l)}

  @compute @workgroup_size(${p}, ${p}, 1)
  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,
   @builtin(local_invocation_id) local_id : vec3<u32>, @builtin(local_invocation_index) local_index : u32) {
   let global_idx = (workgroup_id.z * ${f.x*f.y}u +
          workgroup_id.y * ${f.x}u + workgroup_id.x) * ${p*p}u + local_index;

   let headIdx = workgroup_id.z;
   let m = workgroup_id.y * TILE_SIZE + local_id.y;
   let n = workgroup_id.x * TILE_SIZE + local_id.x;

   let offsetA = headIdx * (M * K) + m * K;
   let offsetB = headIdx * (N * K) + n;

   var value = ${o}(0);
   for (var w: u32 = 0u; w < K; w += TILE_SIZE) {
     if (m < M && w + local_id.x < K) {
       tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
     }
     if (n < N && w + local_id.y < K) {
       tileK[TILE_SIZE * local_id.y + local_id.x] = v[offsetB + (w + local_id.y) * N];
     }
     workgroupBarrier();
     for (var k: u32 = 0u; k<TILE_SIZE && w+k < K; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   let batchIdx = workgroup_id.z / ${a.numHeads};
   let currentBatchHeadNumber = workgroup_id.z % ${a.numHeads};
   let headOffset = (batchIdx * M * ${a.numHeads} + currentBatchHeadNumber) * ${a.vHeadSize};
   if (m < M && n < N) {
     let outputIdx = batchIdx * ${a.sequenceLength*a.vHiddenSize} + m * ${a.vHiddenSize}
       + currentBatchHeadNumber * ${a.vHeadSize} + n;
     output[outputIdx] = value;
   }
  }`;return e.compute({name:"AttentionScore",shaderCache:{hint:JSON.stringify(a)},getRunData:()=>({outputs:[{dims:n,dataType:t.dataType,gpuDataType:0}],dispatchGroup:f}),getShaderSource:y},{inputs:[t,r],outputs:[0]})[0]},sn=(e,t,r,a,n,s,u,l,o,p,f)=>{let y=Bd(e,t,r,o,p,f);Md(e,y,a,p)},Dd=(e,t)=>{let r=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],a=Ce(e.inputs[0].dataType),n=t.sequenceLength,s=t.inputHiddenSize,u=t.headSize,l=12,o={x:Math.ceil(t.headSize/l),y:Math.ceil(t.sequenceLength/l),z:t.batchSize*t.numHeads},p=()=>`
  const M: u32 = ${n}u;
  const K: u32 = ${s}u;
  const N: u32 = ${u}u;
  const numHeads: u32 = ${t.numHeads};
  const ldb = ${t.hiddenSize+t.hiddenSize+t.vHiddenSize}u;
  const TILE_SIZE = ${l}u;

  var<workgroup> tileInput: array<${a}, ${l*l}>;
  var<workgroup> tileWeightQ: array<${a}, ${l*l}>;
  var<workgroup> tileWeightK: array<${a}, ${l*l}>;
  var<workgroup> tileWeightV: array<${a}, ${l*l}>;

  @group(0) @binding(0) var<storage, read> input: array<${a}>;
  @group(0) @binding(1) var<storage, read> weight: array<${a}>;
  @group(0) @binding(2) var<storage, read> bias: array<${a}>;
  @group(0) @binding(3) var<storage, read_write> outputQ: array<${a}>;
  @group(0) @binding(4) var<storage, read_write> outputK: array<${a}>;
  @group(0) @binding(5) var<storage, read_write> outputV: array<${a}>;

  @compute @workgroup_size(${l}, ${l}, 1)
  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,
   @builtin(local_invocation_id) local_id : vec3<u32>, @builtin(local_invocation_index) local_index : u32) {
   let global_idx = (workgroup_id.z * ${o.x*o.y}u +
          workgroup_id.y * ${o.x}u + workgroup_id.x) * ${l*l}u + local_index;

    let batchIndex = workgroup_id.z / ${t.numHeads};
    let headNumber = workgroup_id.z % ${t.numHeads};
    let m = workgroup_id.y * TILE_SIZE + local_id.y;
    let n = workgroup_id.x * TILE_SIZE + local_id.x;

    let inputOffset = batchIndex * (M * K) + m * K;
    let biasOffsetQ = headNumber * ${t.headSize};
    let biasOffsetK = ${t.hiddenSize} + biasOffsetQ;
    let biasOffsetV = ${t.hiddenSize} + biasOffsetK;

    var valueQ = ${a}(0);
    var valueK = ${a}(0);
    var valueV = ${a}(0);
    for (var w: u32 = 0u; w < K; w += TILE_SIZE) {
      if (m < M && w + local_id.x < K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < N && w + local_id.y < K) {
        let offset = n + (w + local_id.y) * ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * N + n) % ${t.headSize};
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * M * N;
    if (m < M && n < N) {
      let outputIdx = offset + m * N + n;
      outputQ[outputIdx] = valueQ;
      outputK[outputIdx] = valueK;
      outputV[outputIdx] = valueV;
    }
  }`,f=[e.inputs[0],e.inputs[1],e.inputs[2]];return e.compute({name:"AttentionPrepare",shaderCache:{hint:JSON.stringify(t)},getRunData:()=>({outputs:[{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:o}),getShaderSource:p},{inputs:f,outputs:[-1,-1,-1]})},Ai=(e,t)=>{let r=Rd(e.inputs,t),[a,n,s]=Dd(e,r);return sn(e,a,n,s,e.inputs[4],void 0,void 0,void 0,e.inputs[5],r,t)}});var zd,Wd,Ei,Oi=F(()=>{"use strict";me();be();zd=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Wd=e=>{let t=e[0].dims,r=e[0].dims[2],a=z.size(t)/4,n=e[0].dataType,s=L("input",n,t,4),u=L("bias",n,[r],4),l=L("residual",n,t,4),o=q("output",n,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:f=>`
  const channels = ${r}u / 4;
  ${f.declareVariables(s,u,l,o)}

  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes(a)}
    let value = ${s.getByOffset("global_idx")}
      + ${u.getByOffset("global_idx % channels")} + ${l.getByOffset("global_idx")};
    ${o.setByOffset("global_idx","value")}
  }`}},Ei=e=>{zd(e.inputs),e.compute(Wd(e.inputs))}});var Vd,$e,Ti,ki,Ri,Pi,Bi,Mi,Di,zi,Wi,Nd,Vi,Ni,Ui,Hi,un,Li,ln,Gi,Fi,ji,qi,Ki,Yi,Zi,Xi,Qi,Ji,es,ts,rs,ns,as,os,is,ea=F(()=>{"use strict";De();me();Te();be();Vd=(e,t,r,a,n,s)=>{let u=Math.ceil(t/4),l="";typeof n=="string"?l=`${n}(a)`:l=n("a");let o=L("inputData",r,[u],4),p=q("outputData",a,[u],4);return`
      ${e.registerUniform("vec_size","u32").declareVariables(o,p)}

  ${s??""}

  ${e.mainStart()}
    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${o.getByOffset("global_idx")};
    ${p.setByOffset("global_idx",l)}
  }`},$e=(e,t,r,a,n,s=e.dataType)=>({name:t,shaderCache:{hint:n,inputDependencies:["type"]},getShaderSource:u=>Vd(u,z.size(e.dims),e.dataType,s,r,a),getRunData:u=>({outputs:[{dims:e.dims,dataType:s}],dispatchGroup:{x:Math.ceil(z.size(u[0].dims)/64/4)},programUniforms:[{type:"uint32",data:Math.ceil(z.size(e.dims)/4)}]})}),Ti=e=>{e.compute($e(e.inputs[0],"Abs","abs"))},ki=e=>{e.compute($e(e.inputs[0],"Acos","acos"))},Ri=e=>{e.compute($e(e.inputs[0],"Acosh","acosh"))},Pi=e=>{e.compute($e(e.inputs[0],"Asin","asin"))},Bi=e=>{e.compute($e(e.inputs[0],"Asinh","asinh"))},Mi=e=>{e.compute($e(e.inputs[0],"Atan","atan"))},Di=e=>{e.compute($e(e.inputs[0],"Atanh","atanh"))},zi=e=>re(e),Wi=(e,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute($e(e.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},Nd=e=>{let t=e.length>=2?e[1].getFloat32Array()[0]:rn,r=e.length>=3?e[2].getFloat32Array()[0]:nn;return re({min:t,max:r})},Vi=(e,t)=>{let r=e.inputs.length===1?t:Nd(e.inputs),a=Ce(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Clip",n=>`clamp(${n}, clip_min_, clip_max_)`,`
    const clip_min_: vec4<${a}> = vec4(${a}(${r.min}));
    const clip_max_: vec4<${a}> = vec4(${a}(${r.max}));
`,r.cacheKey),{inputs:[0]})},Ni=e=>{e.compute($e(e.inputs[0],"Ceil","ceil"))},Ui=e=>{e.compute($e(e.inputs[0],"Cos","cos"))},Hi=e=>{e.compute($e(e.inputs[0],"Cosh","cosh"))},un=e=>re(e),Li=(e,t)=>{e.compute($e(e.inputs[0],"Elu",r=>`elu_vf32(${r})`,`
  const elu_alpha_: f32 = f32(${t.alpha});

  fn elu_f32(a: f32) -> f32 {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,t.cacheKey))},ln=(e,t="f32")=>`
const r0: ${t} = 0.3275911;
const r1: ${t} = 0.254829592;
const r2: ${t} = -0.284496736;
const r3: ${t} = 1.421413741;
const r4: ${t} = -1.453152027;
const r5: ${t} = 1.061405429;

fn erf_vf32(v: ${e}) -> ${e} {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,Gi=e=>{let t=Ce(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Erf",r=>`erf_vf32(${r})`,ln(`vec4<${t}>`,t)))},Fi=e=>{e.compute($e(e.inputs[0],"Exp","exp"))},ji=e=>{e.compute($e(e.inputs[0],"Floor","floor"))},qi=e=>{let t=Ce(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,ln(`vec4<${t}>`,t)))},Ki=(e,t)=>{e.compute($e(e.inputs[0],"LeakyRelu",r=>`select(leaky_relu_alpha_ * ${r}, ${r}, ${r} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${t.alpha});`,t.cacheKey))},Yi=e=>{e.compute($e(e.inputs[0],"Not",t=>`!${t}`))},Zi=e=>{e.compute($e(e.inputs[0],"Neg",t=>`-${t}`))},Xi=e=>{e.compute($e(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},Qi=e=>{e.compute($e(e.inputs[0],"Relu",t=>`select(vec4<f32>(0.0), ${t}, ${t} > vec4<f32>(0.0))`))},Ji=e=>{e.compute($e(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},es=e=>{e.compute($e(e.inputs[0],"Sin","sin"))},ts=e=>{e.compute($e(e.inputs[0],"Sinh","sinh"))},rs=e=>{e.compute($e(e.inputs[0],"Sqrt","sqrt"))},ns=e=>{e.compute($e(e.inputs[0],"Tan","tan"))},as=e=>{e.compute($e(e.inputs[0],"Tanh","tanh"))},os=(e,t)=>(e.compute($e(e.inputs[0],"ThresholdedRelu",r=>`select(vec4<f32>(0.0), ${r}, ${r} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${t.alpha});`,t.cacheKey)),0),is=e=>{e.compute($e(e.inputs[0],"Log","log"))}});var Hd,Ld,ss,us=F(()=>{"use strict";me();be();ea();Hd=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Ld=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=L("input",e[0].dataType,e[0].dims,4),a=L("bias",e[0].dataType,[e[0].dims[2]],4),n=q("output",e[0].dataType,t,4),s=z.size(t)/4;return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:l=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${e[0].dims[2]/4/2}u;

  ${l.declareVariables(r,a,n)}

  ${ln("vec4f")}

  ${l.mainStart()}
    ${l.guardAgainstOutOfBoundsWorkgroupSizes(s)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${n.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},ss=e=>{Hd(e.inputs),e.compute(Ld(e.inputs))}});var Gd,Fd,mt,ls,ds,cs,ps,fs,ms,hs,gs,ys,bs,ws=F(()=>{"use strict";De();me();be();Gd=(e,t,r,a,n,s,u,l,o,p,f,y,g)=>{let b,v;typeof l=="string"?b=v=(O,W)=>`${l}((${O}),(${W}))`:typeof l=="function"?b=v=l:(b=l.scalar,v=l.vector);let $=y?t.length:t,I=y?r.length:r,_=y?a.length:a,C=q("outputData",f,_,4),P=L("aData",o,$,4),A=L("bData",p,I,4),B;if(n)if(s){let O=z.size(t)===1,W=z.size(r)===1,V=t.length>0&&t[t.length-1]%4===0,Y=r.length>0&&r[r.length-1]%4===0;O||W?B=C.setByOffset("global_idx",v(O?`${P.type.value}(${P.getByOffset("0")}.x)`:P.getByOffset("global_idx"),W?`${A.type.value}(${A.getByOffset("0")}.x)`:A.getByOffset("global_idx"))):B=`
            let outputIndices = ${C.offsetToIndices("global_idx * 4u")};
            let offsetA = ${P.broadcastedIndicesToOffset("outputIndices",C)};
            let offsetB = ${A.broadcastedIndicesToOffset("outputIndices",C)};
            ${C.setByOffset("global_idx",v(u||V?P.getByOffset("offsetA / 4u"):`${P.type.value}(${P.getByOffset("offsetA / 4u")}[offsetA % 4u])`,u||Y?A.getByOffset("offsetB / 4u"):`${A.type.value}(${A.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else B=C.setByOffset("global_idx",v(P.getByOffset("global_idx"),A.getByOffset("global_idx")));else{if(!s)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let O=(W,V,Y="")=>{let oe=`aData[indexA${V}][componentA${V}]`,M=`bData[indexB${V}][componentB${V}]`;return`
            let outputIndices${V} = ${C.offsetToIndices(`global_idx * 4u + ${V}u`)};
            let offsetA${V} = ${P.broadcastedIndicesToOffset(`outputIndices${V}`,C)};
            let offsetB${V} = ${A.broadcastedIndicesToOffset(`outputIndices${V}`,C)};
            let indexA${V} = offsetA${V} / 4u;
            let indexB${V} = offsetB${V} / 4u;
            let componentA${V} = offsetA${V} % 4u;
            let componentB${V} = offsetB${V} % 4u;
            ${W}[${V}] = ${Y}(${b(oe,M)});
          `};f===9?B=`
            var data = vec4<u32>(0);
            ${O("data",0,"u32")}
            ${O("data",1,"u32")}
            ${O("data",2,"u32")}
            ${O("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:B=`
            ${O("outputData[global_idx]",0)}
            ${O("outputData[global_idx]",1)}
            ${O("outputData[global_idx]",2)}
            ${O("outputData[global_idx]",3)}
          `}return`
        ${e.registerUniform("vec_size","u32").declareVariables(P,A,C)}

        ${g??""}

        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${B}
      }`},Fd=(e,t,r,a,n,s,u=r.dataType)=>{let l=!z.areEqual(r.dims,a.dims),o=r.dims,p=z.size(r.dims),f=!1,y=!1,g=[l];if(l){let v=lt.calcShape(r.dims,a.dims,!1);if(!v)throw new Error("Can't perform binary op on the given tensors");o=v,p=z.size(o);let $=z.size(r.dims)===1,I=z.size(a.dims)===1,_=r.dims.length>0&&r.dims[r.dims.length-1]%4===0,C=a.dims.length>0&&a.dims[a.dims.length-1]%4===0;g.push($),g.push(I),g.push(_),g.push(C);let P=1;for(let A=1;A<o.length;A++){let B=r.dims[r.dims.length-A]??1,O=a.dims[a.dims.length-A]??1;if(B===O)P*=B;else break}P%4===0?(y=!0,f=!0):($||I||_||C)&&(f=!0)}else f=!0;g.push(f);let b=je(r.dims.length)&&je(a.dims.length)&&je(o.length);return{name:e,shaderCache:{hint:t+g.map(v=>v.toString()).join("_"),inputDependencies:b?["rank","rank"]:["dims","dims"]},getShaderSource:v=>Gd(v,r.dims,a.dims,o,f,l,y,n,r.dataType,a.dataType,u,b,s),getRunData:()=>({outputs:[{dims:o,dataType:u}],dispatchGroup:{x:Math.ceil(p/64/4)},programUniforms:b?[{type:"uint32",data:Math.ceil(z.size(o)/4)},...He(r.dims),...He(a.dims),...He(o)]:[{type:"uint32",data:Math.ceil(z.size(o)/4)}]})}},mt=(e,t,r,a,n,s)=>{e.compute(Fd(t,n??"",e.inputs[0],e.inputs[1],r,a,s))},ls=e=>{mt(e,"Add",(t,r)=>`${t}+${r}`)},ds=e=>{mt(e,"Div",(t,r)=>`${t}/${r}`)},cs=e=>{mt(e,"Equal",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},ps=e=>{mt(e,"Mul",(t,r)=>`${t}*${r}`)},fs=e=>{let t=L("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;mt(e,"Pow",{scalar:(a,n)=>`pow_custom(${a},${n})`,vector:(a,n)=>`pow_vector_custom(${a},${n})`},`
    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {
      if (b == ${t}(0.0)) {
        return ${t}(1.0);
      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {
        return ${t}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {
      // TODO: implement vectorized pow
      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},ms=e=>{mt(e,"Sub",(t,r)=>`${t}-${r}`)},hs=e=>{mt(e,"Greater",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},gs=e=>{mt(e,"Less",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},ys=e=>{mt(e,"GreaterOrEqual",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},bs=e=>{mt(e,"LessOrEqual",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var qd,Kd,Yd,Zd,vs,$s,Ss=F(()=>{"use strict";me();Te();be();qd=e=>{if(!e||e.length<1)throw new Error("too few inputs");let t=e[0].dataType,r=e[0].dims.length;for(let a of e){if(a.dataType!==t)throw new Error("input tensors should be one type");if(a.dims.length!==r)throw new Error("input tensors should have the same shape")}},Kd=(e,t)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${e}u>(${t});
    for (var i: u32 = 0u; i < ${e}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${e}u;
  }`,Yd=(e,t)=>{let r=e.length,a=[];for(let n=0;n<r;++n){let s=t.setByOffset("global_idx",e[n].getByIndices("indices"));r===1?a.push(s):n===0?a.push(`if (inputIndex == ${n}u) { ${s} }`):n===r-1?a.push(`else { ${s} }`):a.push(`else if (inputIndex == ${n}) { ${s} }`)}return a.join(`
`)},Zd=(e,t)=>{let r=e[0].dims.slice();if(t>=r.length||t<-1*r.length)throw new Error("axis specified for concat doesn't match input dimensionality");let a=t<0?r.length+t:t,n=r.slice(0);for(let A=1;A<e.length;A++){let B=e[A].dims.slice();for(let O=0;O<r.length;O++)if(O===a)n[a]+=B[O];else if(r[O]!==B[O])throw new Error("non concat dimensions must match")}let s=z.size(n),u=new Array(e.length),l=new Array(e.length),o=e[0].dataType,p=0,f=[],y=[],g=[],b=[{type:"uint32",data:s}];for(let A=0;A<e.length;++A)p+=e[A].dims[a],u[A]=p,g.push(je(e[A].dims.length)),y.push(g[A]?e[A].dims.length:e[A].dims),l[A]=L(`input${A}`,o,y[A]),f.push(g[A]?"rank":"dims"),b.push({type:"uint32",data:u[A]});for(let A=0;A<e.length;++A)g[A]&&b.push(...He(e[A].dims));let v=je(n.length);v&&b.push(...He(n));let $=v?n.length:n,I=q("output",o,$),_=I.indicesGet("indices",a),C=Array.from(Array(u.length).keys()).map(A=>`uniforms.sizeInConcatAxis${A}`).join(","),P=A=>`

  ${(()=>{A.registerUniform("outputSize","u32");for(let B=0;B<e.length;B++)A.registerUniform(`sizeInConcatAxis${B}`,"u32");return A.declareVariables(...l,I)})()}

  ${Kd(u.length,C)}

  ${A.mainStart()}
    ${A.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${I.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${_});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${u.length}u>(${C});
      ${_} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${Yd(l,I)}
  }`;return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:b}),getShaderSource:P}},vs=(e,t)=>{qd(e.inputs),e.compute(Zd(e.inputs,t.axis))},$s=e=>re({axis:e.axis})});var Et,dn,Nt=F(()=>{"use strict";me();Et=(e,t)=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:`value = max(value, ${t}(0.0));`};case"Sigmoid":return{activationFunction:"",applyActivation:`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`};case"Clip":return{activationFunction:`const clip_min_=${t}(${e.clipMin});const clip_max_=${t}(${e.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},dn=e=>{let t=e?.activation||"";if(t==="Clip"){let[r,a]=e?.activation_params||[rn,nn];return{activation:t,clipMax:a,clipMin:r,activationCacheKey:`${t}:${r},${a}`}}return{activation:t,activationCacheKey:t}}});var We,cn,pn=F(()=>{"use strict";We=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},cn=e=>`
      ${e?"value = value + getBiasByOutputCoords(coords);":""}
      `});var fn,ta=F(()=>{"use strict";fn=`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));
}
`});var Xd,Qd,wr,xs,Jd,vr,ec,mn,$r=F(()=>{"use strict";me();be();Nt();pn();Xd=(e,t)=>e?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${t?", batchIndices":""});
        `,Qd=(e,t)=>e?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,wr=(e,t,r="f32",a,n=!1,s=32,u=!1,l=32)=>{let o=t[1]*e[1],p=t[0]*e[0],f=n?o:s,y=n?s:o,g=f/t[0],b=s/t[1];if(!((n&&g===4&&e[1]===4||!n&&(g===3||g===4))&&f%t[0]===0&&s%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${n} is true, innerElementSize ${g} and workPerThread[1] ${e[1]} must be 4.
      Otherwise, innerElementSize ${g} must be 3 or 4.
  tileAWidth ${f} must be divisible by workgroupSize[0]${t[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${g}<${r}>, ${f/g}>, ${y}>;
var<workgroup> mm_Bsub: array<array<vec4<${r}>, ${p/e[0]}>, ${s}>;

const rowPerThread = ${e[1]};
const colPerThread = ${e[0]};
const innerElementSize = ${g};
const tileInner = ${s};

@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${u?"0":"i32(globalId.z)"};
  ${a?`let batchIndices = ${a.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${o};

  let numTiles = ${u?`${Math.ceil(l/s)}`:"(dimInner - 1) / tileInner + 1"};
  var kStart = ${u?`i32(globalId.z) * ${l}`:"0"};

  var acc: array<vec4<${r}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${b};
  for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${Xd(n,a)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${b}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${a?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${g===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${Qd(n,g)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},xs=(e,t)=>e?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${t?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${t?", batchIndices":""});
            `,Jd=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",vr=(e,t,r="f32",a,n=!1,s=32,u=!1,l=32,o=!1)=>{let p=e[1]*t[1],f=e[0]*t[0],y=n?p:s,g=n?s:p;if(!(g%t[1]===0&&y%t[0]===0&&s%t[1]===0))throw new Error(`tileAHight ${g} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${y} must be divisible by workgroupSize[0]${t[0]}, tileInner ${s} must be divisible by workgroupSize[1]${t[1]}`);let b=g/t[1],v=y/t[0],$=s/t[1],I=o?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${p};
    let globalColStart = i32(workgroupId.x) * ${f};

    // Loop over shared dimension.
    for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${g}; inputRow = inputRow + ${t[1]}) {
        for (var inputCol = localCol; inputCol < ${y}; inputCol = inputCol + ${t[0]}) {
          ${xs(n,a)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {
            for (var inputCol = localCol; inputCol < ${f}; inputCol = inputCol + ${t[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${a?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${r}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${t[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${t[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${p};

let tileRowA = i32(localId.y) * ${b};
let tileColA = i32(localId.x) * ${v};
let tileRowB = i32(localId.y) * ${$};
// Loop over shared dimension.
for (var t = 0; t < numTiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${b}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${v}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${xs(n,a)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${$}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${a?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${r}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${Jd(n)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${r}, ${y}>, ${g}>;
  var<workgroup> mm_Bsub : array<array<${r}, ${f}>, ${s}>;
  const rowPerThread = ${e[1]};
  const colPerThread = ${e[0]};
  const tileInner = ${s};

@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${u?"0":"i32(globalId.z)"};
    ${a?`let batchIndices = ${a.offsetToIndices("u32(batch)")};`:""}
    let numTiles = ${u?`${Math.ceil(l/s)}`:"(dimInner - 1) / tileInner + 1"};
    var kStart = ${u?`i32(globalId.z) * ${l}`:"0"};

    var acc : array<array<${r}, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${I}
  }
`},ec=(e,t,r,a,n,s=!1)=>{let u=n[0],l=n[1],o=n[2],p=a[0],f=a[1],y=a[2],g=a[3],b=Zn(u,o),v=Zn(l,o),$=Ce(a[0].type.tensor),I=()=>{let P=f.rank,A=p.rank,B=`var aIndices: ${f.type.indices};`;for(let O=P-2-1,W=A-1;O>=0;O--,W--)B+=`
aIndices[${O}] = ${A>1?`batchIndices[${W}]`:"batchIndices"};`;return b.forEach(O=>{B+=`
aIndices[${O}] = 0;`}),B+=`
aIndices[${P-2}] = u32(row);
                   aIndices[${P-1}] = u32(colIn);`,B},_=()=>{let P=y.rank,A=p.rank,B=`var bIndices: ${y.type.indices};`;for(let O=P-2-1,W=A-1;O>=0;O--,W--)B+=`
bIndices[${O}] = ${A>1?`batchIndices[${W}]`:"batchIndices"};`;return v.forEach(O=>{B+=`
bIndices[${O}] = 0;`}),B+=`
bIndices[${P-2}] = u32(row);
                   bIndices[${P-1}] = u32(colIn);`,B};return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${p.type.indices}) -> ${We(e,$)} {
      var value = ${We(e,$)}(0.0);
      let col = colIn * ${e};
      if(row < dimAOuter && col < dimInner)
      {
        ${I()}
        value = ${f.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${p.type.indices}) -> ${We(e,$)} {
      var value = ${We(e,$)}(0.0);
      let col = colIn * ${e};
      if(row < dimInner && col < dimBOuter)
      {
        ${_()}
        value = ${y.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${We(e,$)}) {
      let col = colIn * ${e};
      if (row < dimAOuter && col < dimBOuter) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${t?`value = value + ${s?"bias[colIn]":`${We(e,$)}(bias[row])`};`:""}
        ${r}
        ${g.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},mn=(e,t,r,a,n=!1)=>{let s=e[0].dims,u=e[1].dims,l=s.slice(0,-2),o=u.slice(0,-2),p=a?a.slice(0,-2):r.slice(0,-2),f=L("batchDims",e[0].dataType,p),y=[f],g=[l,o,p],b=z.size(p),v=s[s.length-2],$=s[s.length-1],I=u[u.length-1],_=$%4===0&&I%4===0,C=v<=8?[4,1,1]:[4,4,1],P=[8,8,1],A=[Math.ceil(I/P[0]/C[0]),Math.ceil(v/P[1]/C[1]),Math.ceil(b/P[2]/C[2])],B=Ce(e[0].dataType),O=_?4:1,W=L("a",e[0].dataType,[...l,v,$/O],O),V=L("b",e[1].dataType,[...o,$,I/O],O),Y=q("result",e[0].dataType,[b,v,I/O],O);y.push(W),y.push(V),y.push(Y);let oe=[W,V],M=e.length>2,{activationFunction:K,applyActivation:Se}=Et(t,Y.type.value),ue=ec(O,M,Se,y,g,n);if(M){let j=n?O:1;oe.push(L("bias",e[2].dataType,e[2].dims,j))}let ve=j=>`
  const dimAOuter: i32 = ${v};
  const dimBOuter: i32 = ${I};
  const dimInner: i32 = ${$};
  ${j.declareVariables(...oe,Y)}
  ${K}
  ${ue}
  ${_?wr(C,P,B,f):vr(C,P,B,f)}
                   ${f.impl()}`;return{name:"MatMul",shaderCache:{hint:t.activationCacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:A[0],y:A[1],z:A[2]}}),getShaderSource:ve}}});var tc,Is,Cs=F(()=>{"use strict";At();me();be();Nt();pn();ta();$r();tc=(e,t,r,a,n=!1,s,u=4,l=4,o=4,p="f32")=>{let f=M=>{switch(M){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${p}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${M} is not supported.`)}},y=M=>{switch(M){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${M} is not supported.`)}},g=e?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,b=e?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,v=e?"xShape[1]":"xShape[2]",$=e?"xShape[2]":"xShape[3]",I=e?"row":"col",_=e?"col":"row",C=`
    let inChannels = wShape[2];
    let outWidth = ${e?"outShape[2]":"outShape[3]"};
    let outRow = ${I} / outWidth;
    let outCol = ${I} % outWidth;

    let WRow = ${_} / (filterDims[1] * inChannels);
    let WCol = ${_} / inChannels % filterDims[1];
    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];
    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];
    let xCh = ${_} % inChannels;
    var resData = ${We(u,p)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${v} && xCol >= 0 && xCol < ${$}) {
      ${g}
      let xIndex = getIndexFromCoords4D(coord, xShape);
      ${f(u)}
    }
    return resData;`,P=e?t&&a?`
    let col = colIn * ${u};
    ${C}`:`
    let col = colIn * ${u};
    if (row < dimAOuter && col < dimInner) {
      ${C}
    }
    return ${We(u,p)}(0.0);`:a&&r?`
    let col = colIn * ${u};
    ${C}`:`
    let col = colIn * ${u};
    if (row < dimInner && col < dimBOuter) {
      ${C}
    }
    return ${We(u,p)}(0.0);`,A=`${y(l)}`,B=We(o,p),O=e?We(u,p):We(l,p),W=e?We(l,p):We(u,p),{activationFunction:V,applyActivation:Y}=Et(s,B);return`
    ${V}
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${O} {
      ${e?P:A}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${W} {
      ${e?A:P}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${B}) {
      let col = colIn * ${o};
      if (row < dimAOuter && col < dimBOuter)
      {
      var value = valueIn;
      let outWidth = ${e?"outShape[2]":"outShape[3]"};
      ${b}
      ${cn(n)}
      ${Y}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},Is=(e,t,r,a,n,s,u,l)=>{let o=t.format==="NHWC",p=o?e[0].dims[3]:e[0].dims[1],f=r[0],y=o?r[2]:r[3],g=o?r[1]:r[2],b=o?r[3]:r[1],v=o&&(p%4===0||p%3===0)&&b%4===0,$=o?b:y*g,I=o?y*g:b,_=[8,8,1],C=a<=8?[4,1,1]:[4,4,1],P=[Math.ceil($/_[0]/C[0]),Math.ceil(I/_[1]/C[1]),Math.ceil(f/_[2]/C[2])];Oe("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${P}`);let A=v?o&&p%4!==0?3:4:C[0],B=_[1]*C[1],O=_[0]*C[0],W=Math.max(_[0]*A,_[1]),V=a%B===0,Y=n%O===0,oe=s%W===0,M=v?[A,4,4]:[1,1,1],K=Ce(e[0].dataType),Se=[`@group(0) @binding(0) var<storage, read> x: array<${v&&A===4?`vec4<${K}>`:K}>;`,`@group(0) @binding(1) var<storage, read> w: array<${v?`vec4<${K}>`:K}>;`],ue=`
      fn setOutputAtIndex(flatIndex : i32, value : ${v?`vec4<${K}>`:K}) {
        result[flatIndex] = ${v?`vec4<${K}>`:K}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${v?`vec4<${K}>`:K}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${v?"/ 4":""}, value);
      }`;return u&&(Se.push(`@group(0) @binding(2) var<storage, read> bias: array<${v?`vec4<${K}>`:K}>;`),ue+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${v?`vec4<${K}>`:K} {
          return bias[coords.${o?"w":"y"}${v?"/ 4":""}];
        }`),{name:"Conv2DMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:P[0],y:P[1],z:P[2]}}),getShaderSource:()=>`
        ${fn}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${Se.join("")}
        @group(0) @binding(${Se.length}) var<storage, read_write> result: array<${v?`vec4<${K}>`:K}>;
        //@group(0) @binding(${Se.length+1}) var<uniform> uniforms: Uniforms;

        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${z.computeStrides(r).slice(0,3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[0]}, ${t.kernelShape[1]});
        const pad : vec2<i32> = vec2<i32>(${t.pads[0]}, ${t.pads[1]});
        const stride : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});
        const dimAOuter : i32 = ${a};
        const dimBOuter : i32 = ${n};
        const dimInner : i32 = ${s};
        ${ue}
        ${tc(o,V,Y,oe,u,t,M[0],M[1],M[2],K)}
            ${v?wr(C,_,K,void 0,!o,W):vr(C,_,K,void 0,!o,W,!1,void 0,l)}`}}});var ra,_s=F(()=>{"use strict";me();be();aa();Nt();ra=(e,t,r)=>{let a=e.length>2,n=a?"value += b[output_channel];":"",s=e[0].dims,u=e[1].dims,l=u[0]/t.group,o=t.format==="NHWC",p=na(s,u,t.dilations,t.pads,t.strides,o),f=z.size(p),y=q("output",e[0].dataType,p),{activationFunction:g,applyActivation:b}=Et(t,y.type.value),v=L("x",e[0].dataType,s),$=L("w",e[1].dataType,u),I=[v,$];a&&I.push(L("b",e[2].dataType,e[2].dims));let _=C=>`
  const strides: vec2<u32> = vec2(${t.strides[0]}u, ${t.strides[1]}u);
  const pads: vec2<u32> = vec2(${t.pads[0]}u, ${t.pads[1]}u);

  ${C.declareVariables(...I,y)}

  ${g}

  ${C.mainStart()}
    ${C.guardAgainstOutOfBoundsWorkgroupSizes(f)}

    let outputIndices = ${y.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${o?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${o?1:2}], outputIndices[${o?2:3}]) * strides - pads;
    let group_id: u32 = output_channel / ${l}u;

    var value: ${y.type.value} = ${y.type.value}(0);
    for (var wInChannel: u32 = 0u; wInChannel < ${u[1]}u; wInChannel++) {
      let input_channel = group_id * ${u[1]}u + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < ${u[2]}u; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * ${t.dilations[0]}u;

        if (xHeight < 0u || xHeight >= ${s[o?1:2]}u) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < ${u[3]}u; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * ${t.dilations[1]}u;
          if (xWidth < 0u || xWidth >= ${s[o?2:3]}u) {
            continue;
          }

          let xVal = ${o?v.get("batch","xHeight","xWidth","input_channel"):v.get("batch","input_channel","xHeight","xWidth")};
          let wVal = ${$.get("output_channel","wInChannel","wHeight","wWidth")};
          value += xVal*wVal;
        }
      }
    }
    ${n}
    ${b}
    ${y.setByOffset("global_idx","value")}
  }`;return{name:"GroupedConv",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r?r(p):p,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)}}),getShaderSource:_}}});var na,As,rc,Es,oa,nc,ac,ia,aa=F(()=>{"use strict";me();Te();Cs();$r();_s();Nt();Zt();na=(e,t,r,a,n,s)=>{let u=e[0],l=e.slice(s?1:2,s?3:4),o=l.length,p=t[0],y=t.slice(2).map((v,$)=>v+(v-1)*(r[$]-1)),b=l.map((v,$)=>v+a[$]+a[$+o]).map((v,$)=>Math.floor((v-y[$]+n[$])/n[$]));return b.splice(0,0,u),b.splice(s?3:1,0,p),b},As=[2,3,1,0],rc=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],a=e[1].dims[1]*t.group;if(r!==a)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==n*2)throw new Error(`pads should be ${n*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},Es=(e,t)=>{let r=e.kernelShape.slice();for(let s=2;s<t[1].dims.length;++s)r[s-2]===0&&(r[s-2]=t[1].dims[s]);let a=e.pads.slice();Vt.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,a,e.format==="NHWC",e.autoPad);let n=Object.assign({},e);return Object.assign(n,{kernelShape:r,pads:a,cacheKey:e.cacheKey}),n},oa=e=>{let t=dn(e),r=e.format,a=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],n=e.dilations,s=e.group,u=e.kernel_shape,l=e.pads,o=e.strides,p=e.w_is_const();return re({autoPad:a,format:r,dilations:n,group:s,kernelShape:u,pads:l,strides:o,wIsConst:p,...t})},nc=(e,t,r)=>{let a=Es(r,t);if(r.group!==1){e.compute(ra(t,a));return}let n=r.format==="NHWC",s=t.length===3,u=t[0].dims[n?1:2],l=t[0].dims[n?2:3],o=t[0].dims[n?3:1],p=t[1].dims[2],f=t[1].dims[3],y=na(t[0].dims,t[1].dims,r.dilations,a.pads,r.strides,n),g=y[n?1:2],b=y[n?2:3],v=y[n?3:1],$=n&&p===u&&f===l&&r.pads[0]===0&&r.pads[1]===0;if($||p===1&&f===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let O=y[0],W,V,Y,oe=[];if(n){let M=e.kernelCustomData.wT??e.compute(at(t[1],As),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=M),$){let K=u*l*o;W=t[0].reshape([1,O,K]),V=M.reshape([1,K,v]),Y=[1,O,v]}else W=t[0].reshape([O,u*l,o]),V=M.reshape([1,o,v]),Y=[O,g*b,v];oe.push(W),oe.push(V)}else W=t[0].reshape([O,o,u*l]),V=t[1].reshape([1,v,o]),Y=[O,v,g*b],oe.push(V),oe.push(W);s&&oe.push(t[2]),e.compute(mn(oe,a,y,Y,n),{inputs:oe});return}let I=!0,_=e.kernelCustomData.wT??e.compute(at(t[1],As),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=_);let C=[t[0],_];s&&C.push(t[2]);let P=n?g*b:v,A=n?v:g*b,B=p*f*o;e.compute(Is(C,a,y,P,A,B,s,I),{inputs:C})},ac=(e,t)=>{let r=t.format==="NHWC",a=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&a.push(e.inputs[2]);let n=[0,t.pads[0],0,t.pads[1]],s=[1].concat(t.strides),u=[1].concat(t.dilations),l=[1].concat(t.kernelShape),o=Es({...t,pads:n,strides:s,dilations:u,kernelShape:l},a);e.compute(ra(a,o,p=>r?[p[0],p[2],p[3]]:[]))},ia=(e,t)=>{rc(e.inputs,t),e.inputs[0].dims.length===3?ac(e,t):nc(e,e.inputs,t)}});var oc,Os,Ts=F(()=>{"use strict";At();me();Nt();pn();ta();$r();oc=(e,t=!1,r,a=4)=>{let n=We(a,"f32"),s=C=>{switch(C){case 1:return"return W[getIndexFromCoords4D(coord, wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${C} is not supported.`)}},u=e?`
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `,l=e?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,o=e?"outBackprop[1]":"outBackprop[2]",p=e?"outBackprop[2]":"outBackprop[3]",f=e?"row":"col",y=e?"col":"row",g=`
      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};
      let outWidth = ${e?"outShape[2]":"outShape[3]"};
      let outRow = ${f} / outWidth;
      let outCol = ${f} % outWidth;

      let WRow = ${y} / (filterDims[1] * inChannels);
      let WCol = ${y} / inChannels % filterDims[1];
      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);
      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);
      if (xR < 0.0 || xR >= f32(${o}) || fract(xR) > 0.0) {
        return ${n}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${p}) || fract(xC) > 0.0) {
        return ${n}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${y} % inChannels;
      ${u}
      return x[getIndexFromCoords4D(coord, xShape)/${a}];`,b=e?`
      let col = colIn * ${a};
      if (row < dimAOuter && col < dimInner) {
        ${g}
      }
      return ${n}(0.0);`:`
      let col = colIn * ${a};
      if (row < dimInner && col < dimBOuter) {
        ${g}
      }
      return ${n}(0.0);`,v=`
      let col = colIn * ${a};
      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};
      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);
      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];
      if (${e?"row < dimInner && col < dimBOuter":"row < dimInner && col < dimAOuter"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${s(a)}
      }
      return ${n}(0.0);
      `,{activationFunction:$,applyActivation:I}=Et(r,n);return`
      ${$}
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${n} {
    ${e?b:v}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${n} {
    ${e?v:b}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${n}) {
    let col = colIn * ${a};
    if (row < dimAOuter && col < dimBOuter) {
      var value = valueInput;
      let outWidth = ${e?"outShape[2]":"outShape[3]"};
      ${l}
      ${cn(t)}
      ${I}
      result[getIndexFromCoords4D(coords, outShape)/${a}] = value;
    }
  }`},Os=(e,t,r,a,n,s,u,l)=>{let o=t.format==="NHWC",p=o?e[0].dims[3]:e[0].dims[1],f=r[0],y=o?r[2]:r[3],g=o?r[1]:r[2],b=o?r[3]:r[1],v=o?p%4===0&&b%4===0:y%4===0&&b%4===0,$=o?b:y*g,I=o?y*g:b,_=v?[8,8,1]:[$<=4||I<=4?4:16,$>4&&I<=4?4:16,1],C=v?[4,4,1]:[$<=4?1:4,$>4&&I<=4?1:4,1],P=[Math.ceil($/_[0]/C[0]),Math.ceil(I/_[1]/C[1]),Math.ceil(f/_[2]/C[2])];Oe("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${P}`);let A=v?4:1,B=Math.max(_[0]*A,_[1]),O=[`@group(0) @binding(0) var<storage, read> x: array<${v?"vec4<f32>":"f32"}>;`,"@group(0) @binding(1) var<storage, read> W: array<f32>;"],W="";return u&&(O.push(`@group(0) @binding(2) var<storage, read> bias: array<${v?"vec4<f32>":"f32"}>;`),W+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${v?"vec4<f32>":"f32"} {
          return bias[coords.${o?"w":"y"}${v?"/ 4":""}];
        }`),{name:"Conv2DTransposeMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:P[0],y:P[1],z:P[2]}}),getShaderSource:()=>`
        ${fn}
        ${O.join(`
`)}
        @group(0) @binding(${O.length}) var<storage, read_write> result: array<${v?"vec4<f32>":"f32"}>;
        const outBackprop : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});
        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${z.computeStrides(r).slice(0,3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[o?1:2]}, ${t.kernelShape[o?2:3]});
        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(
              ${t.dilations[0]<=1?0:(t.kernelShape[o?1:2]-1)*(t.dilations[0]-1)},
              ${t.dilations[1]<=1?0:(t.kernelShape[o?2:3]-1)*(t.dilations[1]-1)});
        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${t.pads[0]+t.pads[2]})/2,
                                         i32(effectiveFilterDims[1]) - 1 - (${t.pads[1]+t.pads[3]})/2);
        const strides : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});
        const dimAOuter : i32 = ${a};
        const dimBOuter : i32 = ${n};
        const dimInner : i32 = ${s};
        ${W}
        ${oc(o,u,t,A)}
        ${v?wr(C,_,"f32",void 0,!o,B):vr(C,_,"f32",void 0,!o,B,!1,void 0,l)}`}}});var ic,sa,ks=F(()=>{"use strict";At();me();be();ic=(e,t,r,a,n,s,u=!1,l)=>{let o=r.format==="NHWC",p=o?1:2,f=o?2:3,y=o?3:1,g=z.size(a),b=u?2:1,v=r.group,$=t[1].dims,I=$[0]/v,_=$[1],C=`
  fn setOutputAtIndex(flatIndex : u32, value : ${u?`vec4<${l}>`:l}) {
    result[flatIndex] = ${u?`vec4<${l}>`:l}(value);
  }`;n&&(C+=`
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${u?`vec4<${l}>`:l} {
      return bias[coords.${o?"w":"y"}${u?"/ 4":""}];
    }`);let P=u?4:1,A=L("W",t[1].dataType,t[1].dims,P),B=L("Dy",t[0].dataType,t[0].dims,P),O=[B,A];n&&O.push(L("bias",t[2].dataType,[a[y]],P));let W=q("result",t[0].dataType,a,P),V=`{
        let batch: u32 = ${s?"global_id.z":"workgroup_id.z"} / outShape[1];
        let r = ${s?"global_id.z":"workgroup_id.z"} % outShape[1];
        let c = ${s?"global_id.y":"workgroup_id.y"} * ${b};
        let d1: u32 = ${s?"global_id.x":"workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${l}>, ${b}>;
        for (var i = 0; i < ${b}; i++) {
          dotProd[i] = vec4<${l}>(0.0);
        }
        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {
          var dyR = (${l}(dyCorner.x) + ${l}(wR)) / ${l}(strides.x);
          let wRPerm = filterDims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${l}(outBackprop[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {
            let dyC = (${l}(dyCorner.y) + ${l}(wC)) / ${l}(strides.y);
            let dyC2 = (${l}(dyCorner.y) + 1.0 + ${l}(wC)) / ${l}(strides.y);
            let wCPerm = filterDims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${l}(outBackprop[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${l}(outBackprop[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${B.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${l}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${B.get("batch","idyR","idyC2","d2")};

                dotProd[1] = dotProd[1] + vec4<${l}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = outBackprop[${y}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${B.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${l}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${A.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${B.get("batch","idyR","idyC2","d2")};
                let tmpval = vec4<${l}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${b}; i = i + 1) {
          let value = dotProd[i] + ${n?"bias[c+i]":"0.0"};
          ${W.set("batch","r","c + i","d1","value")};
        }
      }`,Y=`
          let outputIndices = ${W.offsetToIndices("global_idx")};
          let batch = ${W.indicesGet("outputIndices",0)};
          let d1 = ${W.indicesGet("outputIndices",y)};
          let r = ${W.indicesGet("outputIndices",p)};
          let c = ${W.indicesGet("outputIndices",f)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / ${_};
          let wOutChannel = d1 - groupId * ${_};
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = 0.0;
          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {
            if (wR % dilations.x != 0) {
              continue;
            }
            let dyR = (${l}(dyRCorner) + ${l}(wR)) / ${l}(strides[0]);
            let wRPerm = filterDims.x - 1 - wR / dilations.x;
            if (dyR < 0.0 || dyR >= ${l}(outBackprop[${p}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {
              if (wC % dilations.y != 0) {
                continue;
              }
              let dyC = (${l}(dyCCorner) + ${l}(wC)) / ${l}(strides.y);
              let wCPerm = filterDims.y - 1 - wC / dilations.y;
              if (dyC < 0.0 || dyC >= ${l}(outBackprop[${f}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * ${I};
              for (var d2: u32 = 0; d2 < ${I}; d2 = d2 + 1) {
                let xValue = ${o?B.get("batch","idyR","idyC","inputChannel"):B.get("batch","inputChannel","idyR","idyC")};
                let wValue = ${A.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${n?"bias[d1]":"0.0"};
          ${W.setByOffset("global_idx","value")};
        `;return`
  ${e.declareVariables(...O,W)}
  ${C}
  const outShape : vec4<u32> = vec4<u32>(${a.join(",")});
  const outBackprop : vec4<u32> = vec4<u32>(${t[0].dims.join(",")});
  const strides : vec2<u32> = vec2<u32>(${r.strides[0]}, ${r.strides[1]});
  const filterDims : vec2<u32> = vec2<u32>(${r.kernelShape[o?1:2]}, ${r.kernelShape[o?2:3]});
  const dilations : vec2<u32> = vec2<u32>(${r.dilations[0]}, ${r.dilations[1]});
  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(
          ${r.dilations[0]<=1?0:(r.kernelShape[o?1:2]-1)*(r.dilations[0]-1)},
          ${r.dilations[1]<=1?0:(r.kernelShape[o?2:3]-1)*(r.dilations[1]-1)});
  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${r.pads[0]+r.pads[2]})/2,
                                     i32(effectiveFilterDims[1]) - 1 - (${r.pads[1]+r.pads[3]})/2);
    ${e.mainStart()}
    ${e.guardAgainstOutOfBoundsWorkgroupSizes(g)};
  ${u?V:Y}}`},sa=(e,t,r)=>{let a=e.length>2,n=t.outputShape,s=z.size(n),u=[Math.ceil(s/64),1,1];Oe("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${u}`);let l=Ce(e[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:t.cacheKey},getRunData:()=>({dispatchGroup:{x:u[0],y:u[1],z:u[2]},outputs:[{dims:r?r(n):n,dataType:e[0].dataType}]}),getShaderSource:o=>ic(o,e,t,n,a,u[1]===1&&u[2]===1,!1,l)}}});var sc,uc,lc,Rs,Ps,dc,cc,pc,fc,Bs,Ms=F(()=>{"use strict";Te();Ts();ks();Nt();Zt();sc=(e,t,r,a,n,s)=>(e-1)*t+r+(a-1)*n+1-s,uc=(e,t,r,a,n)=>{let s=Math.floor(e/2);t==="SAME_UPPER"?(r[a]=s,r[n]=e-s):t==="SAME_LOWER"&&(r[a]=e-s,r[n]=s)},lc=(e,t,r,a,n,s,u,l,o,p)=>{let f=e.length-2,y=p.length===0;if(o.length===0)for(let v=0;v<f;++v)o.push(0);let g=e[0],b=t[l?3:1]*n;for(let v=0,$=e.length-f-(l?1:0);v<f;++v,++$){let I=e[$],_=y?I*u[v]:p[v],C=sc(I,u[v],s[v],t[$],r[v],_);uc(C,a,s,v,v+f),y&&p.push(u[v]*(I-1)+o[v]+(t[$]-1)*r[v]+1-s[v]-s[v+f])}p.splice(0,0,g),p.splice(l?3:1,0,b)},Rs=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((g,b)=>g*b,1)===0){r.length=0;for(let g=2;g<t[1].dims.length;++g)r.push(t[1].dims[g])}let a=e.format==="NHWC";r.splice(0,0,t[1].dims[0]),r.splice(a?3:1,0,t[1].dims[1]);let n=e.pads.slice(),s=e.outputShape.slice(),u=e.outputPadding.slice(),l=t[0].dims,o=e.dilations.slice();if(o.reduce((g,b)=>g+b,0)===0){let g=t[0].dims.length-2;o=new Array(g).fill(1)}let p=e.strides.slice();if(p.reduce((g,b)=>g+b,0)===0){let g=t[0].dims.length-2;p=new Array(g).fill(1)}lc(l,r,o,e.autoPad,e.group,n,p,a,u,s);let f=Object.assign({},e),y=e.cacheKey+[r.join("n,"),n.join(","),p.join(","),u.join(","),s.join(","),o.join(",")].join("_");return Object.assign(f,{kernelShape:r,pads:n,outputPadding:u,outputShape:s,dilations:o,strides:p,cacheKey:y}),f},Ps=e=>{let t=dn(e),r=e.format,a=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],n=e.dilations,s=e.group,u=e.kernelShape,l=e.pads,o=e.strides,p=e.wIsConst(),f=e.outputPadding,y=e.outputShape;return re({autoPad:a,format:r,dilations:n,group:s,kernelShape:u,outputPadding:f,outputShape:y,pads:l,strides:o,wIsConst:p,...t})},dc=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],a=e[1].dims[0];if(r!==a)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let n=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==n))throw new Error("invalid bias");let s=e[0].dims.length-2;if(t.dilations.reduce((f,y)=>f+y,0)>0&&t.dilations.length!==s)throw new Error(`dilations should be ${s}D`);if(t.strides.reduce((f,y)=>f+y,0)>0&&t.strides.length!==s)throw new Error(`strides should be ${s}D`);if(t.pads.reduce((f,y)=>f+y,0)>0&&t.pads.length!==s*2)throw new Error(`pads should be ${s*2}D`);if(t.outputPadding.length!==s&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${s}D`);if(t.kernelShape.reduce((f,y)=>f+y,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},cc=[2,3,1,0],pc=(e,t,r)=>{let a=Rs(r,t),n=r.format==="NHWC",s=t.length===3;if(a.group!==1){e.compute(sa(t,a));return}let u=a.outputShape,l=u[n?1:2],o=u[n?2:3],p=u[n?3:1],f=t[1].dims[2],y=t[1].dims[3],g=t[0].dims[n?3:1],b=n?l*o:p,v=n?p:l*o,$=f*y*g,I=!0,_=e.kernelCustomData.wT??e.compute(at(t[1],cc),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=_);let C=[t[0],_];s&&(!n&&t[2].dims.length===1?C.push(t[2].reshape([t[2].dims[0],1,1])):C.push(t[2])),e.compute(Os(C,a,u,b,v,$,s,I),{inputs:C})},fc=(e,t)=>{let r=t.format==="NHWC",a=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];a.length===3&&a.push(e.inputs[2]);let n=t.kernelShape;(n.length===0||n[0]===0)&&(n=[e.inputs[1].dims[2]]);let s=t.dilations;(s.length===0||s[0]===0)&&(s=[1]);let u=t.strides;(u.length===0||u[0]===0)&&(u=[1]);let l=t.pads;l.length===0&&(l=[0,0]),l=[0,l[0],0,l[1]],u=[1].concat(u),s=[1].concat(s),n=[1].concat(n);let o=Rs({...t,pads:l,strides:u,dilations:s,kernelShape:n},a);e.compute(sa(a,o,p=>r?[p[0],p[2],p[3]]:[p[0],p[1],p[3]]))},Bs=(e,t)=>{dc(e.inputs,t),e.inputs[0].dims.length===3?fc(e,t):pc(e,e.inputs,t)}});var ua,hn,Ds,mc,hc,la,da,gc,zs,Ws,Vs=F(()=>{"use strict";me();Te();be();ua="[a-zA-Z]|\\.\\.\\.",hn="("+ua+")+",Ds="^"+hn+"$",mc="("+hn+",)*"+hn,hc="^"+mc+"$",la=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let a=this.symbolToIndices.get(t);a===void 0?a=[r]:a.push(r),this.symbolToIndices.set(t,a)}},da=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[a,n]=r.includes("->")?r.split("->",2):[r,""];if(!a.match(RegExp(hc)))throw new Error("Invalid LHS term");if(a.split(",").forEach((l,o)=>{let p=t[o].dims.slice();if(!l.match(RegExp(Ds)))throw new Error("Invalid LHS term");let f=this.processTerm(l,!0,p,o);this.lhs.push(f)}),n==="")n+=[...this.symbolToInfo.entries()].filter(([l,o])=>o.count===1||l==="...").map(([l])=>l).join("");else if(!n.match(RegExp(hn)))throw new Error("Invalid RHS");n.match(RegExp(ua,"g"))?.forEach(l=>{if(l==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let o=this.symbolToInfo.get(l);if(o===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(o.dimValue)}}),this.rhs=this.processTerm(n,!0,this.outputDims)}addSymbol(t,r,a){let n=this.symbolToInfo.get(t);if(n!==void 0){if(n.dimValue!==r&&n.count!==1)throw new Error("Dimension mismatch");n.count++,n.inputIndices.push(a)}else n={count:1,dimValue:r,inputIndices:[a]};this.symbolToInfo.set(t,n)}processTerm(t,r,a,n=-1){let s=a.length,u=!1,l=[],o=0;if(!t.match(RegExp(Ds))&&!r&&t!=="")throw new Error("Invalid LHS term");let p=t.match(RegExp(ua,"g")),f=new la(n);return p?.forEach((y,g)=>{if(y==="..."){if(u)throw new Error("Only one ellipsis is allowed per input term");u=!0;let b=s-p.length+1;if(b<0)throw new Error("Ellipsis out of bounds");if(l=a.slice(o,o+b),this.hasEllipsis){if(this.ellipsisDims.length!==l.length||this.ellipsisDims.toString()!==l.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=l;else throw new Error("Ellipsis must be specified in the LHS");for(let v=0;v<l.length;v++){let $=String.fromCharCode("0".charCodeAt(0)+g);f.addSymbol($,g+v),this.addSymbol($,a[o++],n)}}else f.addSymbol(y,g),this.addSymbol(y,a[o++],n)}),f}},gc=(e,t)=>{let r=e[0].dataType,a=new Array(e.length);for(let P=0;P<e.length;++P)a[P]=L(`input${P}`,r,e[P].dims);let n=t.outputDims,s=z.size(n),u=q("output",r,n),l=[],o=Array.from(t.rhs.symbolToIndices.keys()),p="var prod = 1.0;",f="var sum = 0.0;",y="sum += prod;",g=[],b=[],v=[],$=[],I=t.symbolToInfo.size===o.length;t.symbolToInfo.forEach((P,A)=>{if(o.includes(A)){let B=o.indexOf(A);t.lhs.forEach((O,W)=>{if(P.inputIndices.includes(W)){let V=O.symbolToIndices.get(A);if(V===void 0)throw new Error("Invalid symbol error");V.forEach(Y=>{l.push(`${a[W].indicesSet(`input${W}Indices`,Y,u.indicesGet("outputIndices",B))}`)})}})}else t.lhs.forEach((B,O)=>{let W=t.symbolToInfo.get(A);if(W===void 0)throw new Error("Invalid symbol error");if(W.inputIndices.includes(O)){let V=B.symbolToIndices.get(A);if(V===void 0)throw new Error("Invalid symbol error");V.forEach(Y=>{g.push(`${a[O].indicesSet(`input${O}Indices`,Y,`${A}`)}`)}),$.push(`prod *= ${a[O].getByIndices(`input${O}Indices`)};`)}}),b.push(`for(var ${A}: u32 = 0; ${A} < ${t.symbolToInfo.get(A)?.dimValue}; ${A}++) {`),v.push("}")});let _=I?[...l,`let sum = ${a.map((P,A)=>P.getByIndices(`input${A}Indices`)).join(" * ")};`]:[...l,f,...b,...g,p,...$,y,...v],C=P=>`
      ${P.declareVariables(...a,u)}

      ${P.mainStart()}
        ${P.guardAgainstOutOfBoundsWorkgroupSizes(s)}
        var outputIndices = ${u.offsetToIndices("global_idx")};
        ${a.map((A,B)=>`var input${B}Indices: ${a[B].type.indices};`).join(`
`)}
        ${_.join(`
`)};
        ${u.setByOffset("global_idx","sum")};
      }`;return{name:"Einsum",shaderCache:{hint:t.equation},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:C}},zs=(e,t)=>{let r=new da(e.inputs,t.equation);e.compute(gc(e.inputs,r))},Ws=e=>{let t=e.equation.replace(/\s+/g,"");return re({equation:t})}});var yc,Ns,bc,wc,Us,Hs=F(()=>{"use strict";me();be();yc=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),a=r.length<t.length?0:r.length-t.length,n=t.length<r.length?0:t.length-r.length;for(;a<r.length&&n<t.length;++a,++n)if(r[a]!==t[n]&&r[a]!==1&&t[n]!==1)throw new Error("Expand requires shape to be broadcastable to input")},Ns=(e,t)=>{let r=e.length-t.length,a=[];for(let n=0;n<r;++n)a.push(e[n]);for(let n=0;n<t.length;++n)a.push(t[n]===1?e[n+r]:t[n]);return a},bc=(e,t)=>e.length>t.length?Ns(e,t):Ns(t,e),wc=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),a=bc(t,r),n=z.size(a),s=e[0].dataType,u=L("input",s,t),l=q("output",s,a),o=p=>`
  const inputShape = ${u.indices(...t)};
  ${p.declareVariables(u,l)}
  ${p.mainStart()}
  ${p.guardAgainstOutOfBoundsWorkgroupSizes(n)}
    let outputIndices = ${l.offsetToIndices("global_idx")};
    var inputIndices: ${u.type.indices};
    for (var i = 0; i < ${t.length}; i++) {
      if (${u.indicesGet("inputShape","i")} == 1) {
        ${u.indicesSet("inputIndices","i",0)}
      } else {
        ${u.indicesSet("inputIndices","i",l.indicesGet("outputIndices",`i + ${a.length-t.length}`))}
      }
    }
    ${l.setByOffset("global_idx",u.getByIndices("inputIndices"))}
  }`;return{name:"Expand",shaderCache:{hint:`${a}`},getShaderSource:o,getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)}})}},Us=e=>{yc(e.inputs),e.compute(wc(e.inputs),{inputs:[0]})}});var vc,$c,Ls,Gs,Fs=F(()=>{"use strict";me();Te();be();vc=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},$c=(e,t)=>{let r=e[0].dims,a=e[1].dims,n=r.length,s=z.normalizeAxis(t.axis,n),u=r.slice(0);u.splice(s,1,...a);let l=r[s],o=z.size(u),p=je(e[0].dims.length),f=p?e[0].dims.length:e[0].dims,y=je(e[1].dims.length),g=y?e[1].dims.length:e[1].dims,b=je(u.length),v=b?u.length:u,$=L("data",e[0].dataType,f),I=L("inputIndices",e[1].dataType,g),_=q("output",e[0].dataType,v),C=[{type:"uint32",data:o},{type:"int32",data:l},{type:"uint32",data:s}];p&&C.push(...He(e[0].dims)),y&&C.push(...He(e[1].dims)),b&&C.push(...He(u));let P=[];P.push(p?"rank":"dims"),P.push(y?"rank":"dims");let A=()=>{let O=a.length,W=`var indicesIndices  = ${I.type.indices}(0);`;for(let V=0;V<O;V++)W+=`${O>1?`indicesIndices[${V}]`:"indicesIndices"} = ${u.length>1?`outputIndices[uniforms.axis + ${V}]`:"outputIndices"};`;W+=`
        var idx = ${I.getByIndices("indicesIndices")};
        if (idx < 0) {
          idx = idx + uniforms.axisDimLimit;
        }
        var dataIndices = ${$.type.indices}(0);
      `;for(let V=0,Y=0;V<n;V++)V===s?(W+=`${n>1?`dataIndices[${V}]`:"dataIndices"} = u32(idx);`,Y+=O):(W+=`${n>1?`dataIndices[${V}]`:"dataIndices"} = ${u.length>1?`outputIndices[${Y}]`:"outputIndices"};`,Y++);return W},B=O=>`
      ${O.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables($,I,_)}
      ${O.mainStart()}
        ${O.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        let outputIndices = ${_.offsetToIndices("global_idx")};
        ${A()};
        let value = ${$.getByIndices("dataIndices")};
        ${_.setByOffset("global_idx","value")};
      }`;return{name:"Gather",shaderCache:{hint:t.cacheKey,inputDependencies:P},getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:C}),getShaderSource:B}},Ls=e=>re({axis:e.axis}),Gs=(e,t)=>{let r=e.inputs;vc(r),e.compute($c(e.inputs,t))}});var Sc,xc,js,qs,Ks=F(()=>{"use strict";me();Te();be();Sc=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},xc=(e,t)=>{let r=e[0].dims,a=e[0].dataType,n=r.length,s=z.computeStrides(r),u=z.size(r),l=e[1].dims,o=e[1].dataType,p=z.size(l),f=z.normalizeAxis(t.axis,n),y=r[f],g=l.slice(0),b=z.size(g),v=L("input",a,r),$=L("indices",o,[p]),I=q("output",a,g),_=C=>`
      const inputStrides = array<u32, ${s.length}>(${s.map(P=>`${P}u`).join(",")});
      ${C.declareVariables(v,$,I)}
      ${C.mainStart()}
      ${C.guardAgainstOutOfBoundsWorkgroupSizes(b)}

      let outputIndices = ${I.offsetToIndices("global_idx")};

      var idx = ${$.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + ${y};
      }

      var srcOffset = u32(0);

      for (var i = 0; i < ${r.length}; i++) {
        if (i == ${f}) {
          srcOffset +=  u32(idx) * inputStrides[i];
        } else {
          srcOffset += ${I.indicesGet("outputIndices","i")} * inputStrides[i];
        }
      }

      // Should never hit this with valid values in indices
      // This is a guard against malicious data in the indices input
      if (srcOffset < 0 || srcOffset >= ${u}) {
        return;
      }

      output[global_idx] = input[srcOffset];
  }`;return{name:"GatherElements",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:g,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(b/64)}}),getShaderSource:_}},js=e=>re({axis:e.axis}),qs=(e,t)=>{let r=e.inputs;Sc(r),e.compute(xc(e.inputs,t))}});var Ic,Cc,_c,Ys,Zs,Xs=F(()=>{"use strict";me();Te();be();Ic=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},Cc=(e,t,r)=>{if(r.length===0)return"0u";let a=r.length===1&&e!==1||r.length===2&&r[0]!==e,n=r[r.length-1]!==t,s="0u";return a||(s+=`+ m * ${r[r.length-1]}u`),n||(s+="+n"),s},_c=(e,t)=>{let r=e[0].dims.slice(),a=e[1].dims.slice(),[n,s,u]=tn.getShapeOfGemmResult(r,t.transA,a,t.transB,e.length===3?e[2].dims:void 0),l=[n,s];if(!l)throw new Error("Can't use gemm on the given tensors");let o=z.size(l),p="";t.transA&&t.transB?p="value += a[k * M + m] * b[n * K + k];":t.transA&&!t.transB?p="value += a[k * M + m] * b[k * N + n];":!t.transA&&t.transB?p="value += a[m * K + k] * b[n * K + k];":!t.transA&&!t.transB&&(p="value += a[m * K + k] * b[k * N + n];");let f=Ce(e[0].dataType),y=t.alpha===1?"":"value *= alpha;",g=e.length===3?`value += beta * c[${Cc(n,s,e[2].dims)}];`:"",b=[`@group(0) @binding(0) var<storage, read> a : array<${f}>;`,`@group(0) @binding(1) var<storage, read> b : array<${f}>;`];e.length===3&&b.push(`@group(0) @binding(2) var<storage, read> c : array<${f}>;`);let v=$=>`
  const M: u32 = ${n}u;
  const N: u32 = ${s}u;
  const K: u32 = ${u}u;
  const alpha = ${f}(${t.alpha});
  const beta = ${f}(${t.beta});

  ${b.join(`
`)}
  @group(0) @binding(${e.length}) var<storage, read_write> output : array<${f}>;

  ${$.mainStart()}
    ${$.guardAgainstOutOfBoundsWorkgroupSizes(o)}

    let m = global_id.x / N;
    let n = global_id.x % N;

    var value = ${f}(0);
    for (var k: u32 = 0u; k<${u}u; k++) {
      ${p}
    }

    ${y}
    ${g}
    output[global_id.x] = value;

  }`;return{name:"Gemm",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:l,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:v}},Ys=(e,t)=>{Ic(e.inputs),e.compute(_c(e.inputs,t))},Zs=e=>re(e)});var Ac,Ec,Oc,Tc,Qs,Js,eu=F(()=>{"use strict";De();me();Te();be();Ac={name:"InstanceNormalization"},Ec=(e,t)=>{let r=e[0].dims,a=r,n=2,s=z.sizeToDimension(r,n),u=z.sizeFromDimension(r,n),l=r[1],o=L("x",e[0].dataType,[r[0],r[1],u]),p=L("scale",e[1].dataType,e[1].dims),f=L("bias",e[2].dataType,e[2].dims),y=q("output",e[0].dataType,[r[0],r[1],u]),g=[o,p,f,y],b=o.type.value,v=64,$=I=>`

  const C: u32 = ${l};
  const normSize: u32 = ${u};
  const epsilon: f32 = ${t.epsilon};
  var<workgroup> meanShared : ${b};
  var<workgroup> squaredNormShared : ${b};
  var<workgroup> workgroupShared : array<${b}, ${v}>;
  const workgroupSize = ${v}u;
  ${I.declareVariables(...g)}
  ${I.mainStart(v)}
    let norm = global_idx / workgroupSize;
    let batch = norm / C;
    let channel = norm % C;
    let localIndex = local_id.x;

    // initialize workgroup memory
    var initial: ${b} = 0;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      initial = initial + ${o.get("batch","channel","h")};
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the mean of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      meanShared = workgroupShared[0] / ${b}(normSize);
    }
    workgroupBarrier();

    // reinitialize workgroup memory.
    initial = 0;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      let deviation =  ${o.get("batch","channel","h")} - meanShared;
      initial = initial + deviation * deviation;
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the sum of square of deviation of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      squaredNormShared = workgroupShared[0];
    }
    workgroupBarrier();

    let invStdDev = 1 / sqrt(squaredNormShared / ${b}(normSize) + epsilon);
    let channelScale = invStdDev * ${p.getByOffset("channel")};
    let channelShift = ${f.getByOffset("channel")} - meanShared * channelScale;
    for (var h = localIndex; h < normSize; h += workgroupSize) {
      let value = ${o.get("batch","channel","h")} * channelScale + channelShift;
      ${y.set("batch","channel","h","value")};
    }
  }`;return{...Ac,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:s}}),getShaderSource:$}},Oc=(e,t,r,a,n,s,u,l)=>{let o=et(u),p=L("input",t.dataType,t.dims,o),f=L("scale",r.dataType,r.dims,o),y=L("bias",a.dataType,a.dims,o),g=64,b=o===1?"vec2f":`mat2x${o}f`,v=o===1?"f32":`vec${o}f`,$=(B,O)=>`${b}(${B}, ${O})`,I=n*u/o,_=Math.ceil(s/g),C=B=>`
  const H: u32 = ${s};
  const C: u32 = ${u/o};
  const imageSize: u32 = ${s*u/o};

  ${B.declareVariables(p)}
  @group(0) @binding(1) var<storage, read_write> output : array<${b}>;

  ${B.mainStart(g)}
    let currentImageNumber = global_idx / ${g} / C;
    let currentChannelNumber = (global_idx / ${g}) % C;
    let wgId = global_idx % ${g};
    let wgOffset = wgId * ${_};
    if (wgOffset >= H) {
        return;
    }
    let wgMax = min(wgOffset + ${_}, H);

    let offset = currentImageNumber * imageSize + currentChannelNumber;
    var sum = ${Le("f32",o)};
    var squaredSum = ${Le("f32",o)};
    for (var i: u32 = wgOffset; i < wgMax; i++) {
        let value = ${v}(input[offset + i * C]);
        sum += value;
        squaredSum += value * value;
    }
    output[global_idx] = ${$("sum","squaredSum")};
  }`,P=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:JSON.stringify({components:o,n,h:s,c:u})},getRunData:()=>({outputs:[{dims:[n,u,g,2],dataType:1}],dispatchGroup:{x:n*u/o}}),getShaderSource:C},{inputs:[t],outputs:[-1]})[0],A=B=>`
  const H: u32 = ${s};
  const C: u32 = ${u/o};
  const imageSize: u32 = ${g*u/o};
  const epsilon: f32 = ${l};

  @group(0) @binding(0) var<storage, read> input : array<${b}>;
  @group(0) @binding(1) var<storage, read> scale : array<${f.type.storage}>;
  @group(0) @binding(2) var<storage, read> bias : array<${y.type.storage}>;
  @group(0) @binding(3) var<storage, read_write> output : array<${b}>;

  ${B.mainStart()}
    ${B.guardAgainstOutOfBoundsWorkgroupSizes(I)}
    let currentImageNumber = global_idx / C;
    let currentChannelNumber = global_idx % C;

    let offset = currentImageNumber * imageSize;
    var sum = ${Le("f32",o)};
    var squaredSum = ${Le("f32",o)};
    for (var i: u32 = 0; i < ${g}; i++) {
        let value = input[offset + i + currentChannelNumber * ${g}];
        sum += value[0];
        squaredSum += value[1];
    }
    sum = sum / f32(H);
    squaredSum = squaredSum / f32(H);
    let invStdDev = 1 / sqrt(squaredSum - sum * sum + epsilon);
    let channelScale = invStdDev * ${v}(scale[currentChannelNumber]);
    let channelShift = ${v}(bias[currentChannelNumber]) - sum * channelScale;

    output[global_idx] = ${$("channelScale","channelShift")};
  }`;return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:JSON.stringify({components:o,n,h:s,c:u,epsilon:l})},getRunData:()=>({outputs:[{dims:[n,u,2],dataType:1}],dispatchGroup:{x:Math.ceil(I/64)}}),getShaderSource:A},{inputs:[P,r,a],outputs:[-1]})[0]},Tc=(e,t,r)=>{let a=t[0].dims,n=a,s=a[0],u=a[a.length-1],l=z.sizeFromDimension(a,1)/u,o=et(u),p=z.size(n)/o,f=L("input",t[0].dataType,t[0].dims,o),y=q("output",t[0].dataType,n,o),g=Ce(t[0].dataType),b=o===1?"vec2f":`mat2x${o}f`,v=o===1?g:`vec${o}<${g}>`,$=Oc(e,t[0],t[1],t[2],s,l,u,r.epsilon),I=_=>`
  const H: u32 = ${l};
  const C: u32 = ${u/o};

  @group(0) @binding(0) var<storage, read> input : array<${f.type.storage}>;
  @group(0) @binding(1) var<storage, read> scaleInput : array<${b}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${y.type.storage}>;

  ${_.mainStart()}
    let currentImageNumber = global_idx / (C * H);
    let currentChannelNumber = global_idx % C;

    let scaleOffset = currentImageNumber * C + currentChannelNumber;
    let scale = scaleInput[scaleOffset];
    output[global_idx] = fma(input[global_idx], ${v}(scale[0]), ${v}(scale[1]));
  }`;e.compute({name:"InstanceNormalization",shaderCache:{hint:`${r.cacheKey}`},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)}}),getShaderSource:I},{inputs:[t[0],$]})},Qs=e=>re({epsilon:e.epsilon,format:e.format}),Js=(e,t)=>{t.format==="NHWC"?Tc(e,e.inputs,t):e.compute(Ec(e.inputs,t))}});var kc,Rc,tu,ru,nu=F(()=>{"use strict";De();me();Te();be();kc=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},Rc=(e,t,r)=>{let a=e[0].dims,n=e[1],s=e[2],u=a,l=z.normalizeAxis(t.axis,a.length),o=z.sizeToDimension(a,l),p=z.sizeFromDimension(a,l),f=z.size(n.dims),y=s?z.size(s.dims):0;if(f!==p||s&&y!==p)throw new Error(`Size of X.shape()[axis:] == ${p}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${f} and bias size of ${y}`);let g=[];for(let A=0;A<a.length;++A)A<l?g.push(a[A]):g.push(1);let b=et(p),v=Ce(e[0].dataType),$=[L("x",e[0].dataType,e[0].dims,b),L("scale",n.dataType,n.dims,b)];s&&$.push(L("bias",s.dataType,s.dims,b)),$.push(q("output",e[0].dataType,u,b));let I=r>1,_=r>2;I&&$.push(q("meanDataOutput",1,g)),_&&$.push(q("invStdOutput",1,g));let C=A=>`
  const normSize: f32 = ${p};
  const normSizeVectorized: u32 = ${p/b};
  const epsilon: f32 = ${t.epsilon};

  ${A.declareVariables(...$)}
  ${A.mainStart()}
    ${A.guardAgainstOutOfBoundsWorkgroupSizes(o)}
    let offset = global_idx * normSizeVectorized;
    var meanVector = ${Le("f32",b)};
    var meanSquareVector = ${Le("f32",b)};

    for (var h: u32 = 0u; h < normSizeVectorized; h++) {
      let value = ${rt(v,b,"x[h + offset]")};
      meanVector += value;
      meanSquareVector += value * value;
    }
    let mean = ${nt("meanVector",b)} / normSize;
    let meanSquare = sqrt(${nt("meanSquareVector",b)} 
      / normSize - mean * mean + epsilon);

    for (var j: u32 = 0; j < normSizeVectorized; j++) {
      let f32input = ${rt(v,b,"x[j + offset]")};
      let f32scale = ${rt(v,b,"scale[j]")};
      output[j + offset] = ${$[0].type.value}((f32input - mean) / meanSquare * f32scale
        ${s?`+ ${rt(v,b,"bias[j]")}`:""}
      );
    }

    ${I?"meanDataOutput[global_idx] = mean":""};
    ${_?"invStdOutput[global_idx] = 1 / meanSquare":""};
  }`,P=[{dims:u,dataType:e[0].dataType}];return I&&P.push({dims:g,dataType:1}),_&&P.push({dims:g,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${t.cacheKey}|${r}|${e.length}`},getRunData:()=>({outputs:P,dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:C}},tu=e=>re({axis:e.axis,epsilon:e.epsilon}),ru=(e,t)=>{kc(e.inputs),e.compute(Rc(e.inputs,t,e.outputCount))}});var Pc,au,ou=F(()=>{"use strict";me();$r();Pc=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},au=e=>{Pc(e.inputs);let t=lt.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can't use matmul on the given tensors");e.compute(mn(e.inputs,{activation:"",activationCacheKey:""},t))}});var Bc,su,iu,Mc,ca,uu,lu=F(()=>{"use strict";me();Te();Jr();Jn();be();Zt();Bc=(e,t)=>{let r=e[0],a=e[1],n=e[2],s=e[3],u=e[4],l=e[5],o=e[6],p=e[7];if(r.dims.length!==3&&r.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let f=!1,y=r.dims[0],g=r.dims[1],b=r.dims.length===3?f?r.dims[2]/3:r.dims[2]:t.numHeads*r.dims[4],v=g,$=0,I=0,_=Math.floor(b/t.numHeads);if(o&&p){if(o.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(p.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');$=o.dims[2],I=o.dims[2]}else if(o||p)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let C;if(a){if(r.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(a.dims.length<3||a.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(r.dims[0]!==a.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(a.dims.length===3){if(a.dims[2]!==r.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');C=2,v=a.dims[1]}else if(a.dims.length===5){if(a.dims[2]!==t.numHeads||a.dims[3]!==2||a.dims[4]!==_)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(n)throw new Error('Expect "value" be none when "key" has packed kv format.');C=5,v=a.dims[1]}else{if(a.dims[1]!==t.numHeads||a.dims[3]!==_)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');C=0,v=a.dims[2]}}else{if(r.dims.length!==3&&r.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(r.dims.length===5&&(r.dims[2]!==t.numHeads||r.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');C=3}if(s){if(s.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(n&&r.dims.length===5&&r.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let P=0;if(u){P=8;let V=u.dims;throw V.length===1?V[0]===y?P=1:V[0]===3*y+2&&(P=3):V.length===2&&V[0]===y&&V[1]===v&&(P=5),P===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, kv_sequence_length)'):new Error("Mask not supported")}let A=!1,B=b;if(n){if(n.dims.length!==3&&n.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(r.dims[0]!==n.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(n.dims.length===3){if(v!==n.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');B=n.dims[2]}else{if(v!==n.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');B=n.dims[1]*n.dims[3],A=!0}}let O=$+v,W=!1;if(u)throw new Error("Key padding mask is not supported");if(l)throw new Error("extraAddQk is not supported");if(o)throw new Error("pastKey is not supported");if(p)throw new Error("pastValue is not supported");return{batchSize:y,sequenceLength:g,pastSequenceLength:$,kvSequenceLength:v,totalSequenceLength:O,maxSequenceLength:I,inputHiddenSize:0,hiddenSize:b,vHiddenSize:B,headSize:_,vHeadSize:Math.floor(B/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:P,scale:t.scale,broadcastResPosBias:W,passPastInKv:A,qkvFormat:C}},su=e=>re({...e}),iu=re({perm:[0,2,1,3]}),Mc=(e,t,r,a,n,s,u)=>{let l=[a,n,s],o=z.size(l),p=Ce(t.dataType),f=y=>`
  const biasOffset = ${u}u;
  const hiddenSize = ${s}u;

  @group(0) @binding(0) var<storage, read> qkv: array<${p}>;
  @group(0) @binding(1) var<storage, read> bias: array<${p}>;
  @group(0) @binding(2) var<storage, read_write> qkv_with_bias: array<${p}>;

  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes(o)}
    let biasOffsetIdx = (global_idx % hiddenSize) + biasOffset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[biasOffsetIdx];
  }`;return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{hint:JSON.stringify({batchSize:a,sequenceLength:n,hiddenSize:s,biasOffset:u})},getRunData:()=>({outputs:[{dims:l,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:f},{inputs:[t,r],outputs:[-1]})[0]},ca=(e,t,r,a,n,s,u,l)=>{let o=s;if(u){if(a===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return o=Mc(e,s,u,t,a,r*n,l),o=o.reshape([t,a,r,n]),e.compute(at(o,iu.perm),{inputs:[o],outputs:[-1]})[0]}else return s.dims.length===3&&(o=s.reshape([t,a,r,n])),e.compute(at(o,iu.perm),{inputs:[o],outputs:[-1]})[0]},uu=(e,t)=>{let r=Bc(e.inputs,t);if(e.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(e.inputs[1]?.dims.length===5)throw new Error("Packed KV is not implemented");let a=e.inputs[1]&&e.inputs[2]&&e.inputs[1].dims.length===4&&e.inputs[2].dims.length===4,n=ca(e,r.batchSize,r.numHeads,r.sequenceLength,r.headSize,e.inputs[0],e.inputs[3],0);if(a)return sn(e,n,e.inputs[1],e.inputs[2],e.inputs[4],void 0,void 0,void 0,e.inputs[5],r,t);let s=ca(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.headSize,e.inputs[1],e.inputs[3],r.hiddenSize),u=ca(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.vHeadSize,e.inputs[2],e.inputs[3],2*r.hiddenSize);sn(e,n,s,u,e.inputs[4],void 0,e.inputs[6],e.inputs[7],e.inputs[5],r,t)}});var Dc,zc,Wc,Vc,Nc,Uc,Hc,Lc,Gc,du,cu,pu=F(()=>{"use strict";De();me();Te();be();Dc=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1)throw new Error("Input type must be float.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},zc=(e,t,r,a,n,s)=>{let u=t.length,l="";for(let o=u-1;o>=0;--o)l+=`
            k = i32(${e.indicesGet("indices",o)}) - ${a[o]};
            if (k < 0) {
              break;
            }
            if (k >= ${t[o]}) {
              break;
            }
            offset += k * ${r[o]};
        `;return`
          value = ${n}(${s});
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${l}
            value = x[offset];
          }
      `},Wc=(e,t,r,a)=>{let n=t.length,s="";for(let u=n-1;u>=0;--u)s+=`
                k = i32(${e.indicesGet("indices",u)}) - ${a[u]};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = ${2*(t[u]-1)};
                  k = k % _2n_1;
                  if(k >= ${t[u]}) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * ${r[u]};
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},Vc=(e,t,r,a)=>{let n=t.length,s="";for(let u=n-1;u>=0;--u)s+=`
                k = i32(${e.indicesGet("indices",u)}) - ${a[u]};
                if (k < 0) {
                  k = 0;
                }
                if (k >= ${t[u]}) {
                  k = ${t[u]-1};
                }
                offset += k * ${r[u]};
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},Nc=(e,t,r,a)=>{let n=t.length,s="";for(let u=n-1;u>=0;--u)s+=`
                k = i32(${e.indicesGet("indices",u)}) - ${a[u]};
                if (k < 0)  {
                  k += ${t[u]};
                }
                if (k >= ${t[u]}) {
                  k -= ${t[u]};
                }
                offset += k * ${r[u]};
            `;return`
              var offset = 0;
              var k = 0;
              ${s}
              value = x[offset];
          `},Uc=(e,t,r,a,n)=>{switch(a.mode){case 0:return zc(e,t,r,a.pads,n,a.value);case 1:return Wc(e,t,r,a.pads);case 2:return Vc(e,t,r,a.pads);case 3:return Nc(e,t,r,a.pads);default:throw new Error("Invalid mode")}},Hc=(e,t,r,a)=>{let n=t[0].dims,s=z.padShape(n.slice(),r.pads),u=z.size(s),l=z.computeStrides(n),o=q("output",t[0].dataType,s),p=L("x",t[0].dataType,n),f=Uc(o,n,l,r,a);return`
              ${e.declareVariables(p,o)}
              ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}

              let indices = ${o.offsetToIndices("global_idx")};

              var value = ${a}(0);
              ${f}
              output[global_idx] = value;
          }`},Lc=(e,t)=>{let r=z.padShape(e[0].dims.slice(),t.pads);return{name:"Pad",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(z.size(r)/64)}}),getShaderSource:a=>Hc(a,e,t,"f32")}},Gc=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),a=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,n=e[0].dims.length,s=new Int32Array(2*n).fill(0);if(e.length>=4){let l=e[3].getBigInt64Array();for(let o=0;o<l.length;o++)s[Number(l[o])]=Number(r[o]),s[Number(l[o])+n]=Number(r[o+l.length])}else r.forEach((l,o)=>s[Number(o)]=Number(l));let u=[];return s.forEach(l=>u.push(l)),re({mode:t.mode,value:a,pads:u})}else return t},du=(e,t)=>{Dc(e.inputs);let r=Gc(e.inputs,t);e.compute(Lc(e.inputs,r),{inputs:[0]})},cu=e=>{let t=e.mode,r=e.value,a=e.pads;return re({mode:t,value:r,pads:a})}});var gn,fu,mu,hu,gu,yu,bu,wu,vu,$u,Su,xu,Iu,Cu,_u,Au=F(()=>{"use strict";me();Te();be();gn=e=>{if(!e||e.length!==1)throw new Error("Pool ops requires 1 input.");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("Pool ops supports 1-D or 2-D inputs only for now.")},fu=(e,t,r)=>{let a=t.format==="NHWC",n=e.dims.slice();a&&n.splice(1,0,n.pop());let s=Object.hasOwnProperty.call(t,"dilations"),u=t.kernelShape.slice(),l=t.strides.slice(),o=s?t.dilations.slice():[],p=t.pads.slice();Vt.adjustPoolAttributes(r,n,u,l,o,p);let f=Vt.computePoolOutputShape(r,n,l,o,u,p,t.autoPad),y=Object.assign({},t);s?Object.assign(y,{kernelShape:u,strides:l,pads:p,dilations:o,cacheKey:t.cacheKey}):Object.assign(y,{kernelShape:u,strides:l,pads:p,cacheKey:t.cacheKey});let g=f.slice();return g.push(g.splice(1,1)[0]),[y,a?g:f]},mu=(e,t,r,a,n,s,u,l)=>{let o=n.format==="NHWC",p=r,f=t.type.value,y=p.length,g=z.size(a),b=q("output",t.type.tensor,a);if(n.kernelShape.length<=2){let v=n.kernelShape[n.kernelShape.length-1],$=n.strides[n.strides.length-1],I=n.pads[n.pads.length/2-1],_=n.pads[n.pads.length-1],C=y-(o?2:1),P="",A="",B="";if(I+_!==0?P=`
                for (var i: u32 = 0u; i < ${v}u; i++) {
                  xIndices[${C}] = indices[${C}] * ${$} - ${I} + i;
                  if (xIndices[${C}] < 0 || xIndices[${C}] >= ${p[C]}) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${t.indicesToOffset("xIndices")}];
                  ${s}
                }`:P=`
                for (var i: u32 = 0u; i < ${v}u; i++) {
                  xIndices[${C}] = indices[${C}] * ${$} - ${I} + i;
                  let x_val = x[${t.indicesToOffset("xIndices")}];
                  ${s}
                }`,n.kernelShape.length===2){let W=n.kernelShape[n.kernelShape.length-2],V=n.strides[n.strides.length-2],Y=n.pads[n.pads.length/2-2],oe=n.pads[n.pads.length-2],M=y-(o?3:2),K=p[M];Y+oe!==0?A=`
                for (var j: u32 = 0u; j < ${W}u; j++) {
                  xIndices[${M}] = indices[${M}] * ${V} - ${Y} + j;
                  if (xIndices[${M}] < 0 || xIndices[${M}] >= ${K}) {
                    pad+= ${v};
                    continue;
                  }
              `:A=`
                for (var j: u32 = 0u; j < ${W}u; j++) {
                  xIndices[${M}] = indices[${M}] * ${V} - ${Y} + j;
                `,B=`
              }
            `}return`
            ${e.declareVariables(t,b)}

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes(g)}

              let indices = ${b.offsetToIndices("global_idx")};
              var xIndices = ${b.offsetToIndices("global_idx")};

              var value: ${f} = ${f}(${l});
              var pad = 0;
              ${A}
              ${P}
              ${B}
              ${u}

              output[global_idx] = value;
            }`}else{if(o)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let v=z.size(n.kernelShape),$=z.computeStrides(n.kernelShape),I=$.length,_=n.pads.length,C=n.pads.reduce((B,O)=>B+O),P="";return C?P=`
                if (xIndices[j] >= inputDims[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${t.indicesToOffset("xIndices")}];
                ${s}
              }`:P=`
              }
              let x_val = x[${t.indicesToOffset("xIndices")}];
              ${s}
            `,`
            ${e.declareVariables(t,b)}

            const pads = array<u32, ${_}>(${n.pads.map(B=>`${B}u`).join(",")});
            const inputDims = array<u32, ${y}>(${p.map(B=>`${B}u`).join(",")});
            const kernelStrides = array<u32, ${I}>(${$.map(B=>`${B}u`).join(",")});
            const strides = array<u32, ${I}>(${n.strides.map(B=>`${B}u`).join(",")});

            ${e.mainStart()}
              ${e.guardAgainstOutOfBoundsWorkgroupSizes(g)}

              let indices = ${b.offsetToIndices("global_idx")};
              let xIndices = ${b.offsetToIndices("global_idx")};

              var offsets: array<u32, ${I}>;

              var value = ${b.type.value}(${l});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < ${v}u; i++) {
                var offset = i;
                for (var j = 0u; j < ${I-1}u; j++) {
                  offsets[j] = offset / kernelStrides[j];
                  offset -= offsets[j] * kernelStrides[j];
                }
                offsets[${I-1}] = offset;

                isPad = false;
                for (var j = ${y-I}u; j < ${y}u; j++) {
                  xIndices[j] = indices[j] * strides[j - ${y-I}u]
                    + offsets[j - ${y-I}u] - pads[j - 2u];
                  ${P}
              }
              ${u}

              output[global_idx] = value;
            }`}},hu=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),gu=(e,t,r,a)=>{let[n,s]=fu(t,a,r),u=z.size(n.kernelShape),l=L("x",t.dataType,t.dims),o=l.type.value,p="value += x_val;",f="";return n.countIncludePad?f+=`value /= ${o}(${u});`:f+=`value /= ${o}(${u} - pad);`,{name:e,shaderCache:{hint:a.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(z.size(s)/64)}}),getShaderSource:y=>mu(y,l,t.dims,s,n,p,f,"0.0")}},yu=e=>{let t=e.count_include_pad!==0,r=hu(e);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return re({countIncludePad:t,...r})},bu=(e,t)=>{gn(e.inputs),e.compute(gu("AveragePool",e.inputs[0],!1,t))},wu={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},vu=e=>{let t=e.format;return{format:t,...wu,cacheKey:t}},$u=(e,t)=>{gn(e.inputs),e.compute(gu("GlobalAveragePool",e.inputs[0],!0,t))},Su=(e,t,r,a)=>{let[n,s]=fu(t,a,r),u=`
      value = max(x_val, value);
    `,l="",o=L("x",t.dataType,t.dims);return{name:e,shaderCache:{hint:a.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(z.size(s)/64)}}),getShaderSource:p=>mu(p,o,t.dims,s,n,u,l,"-1e5")}},xu=(e,t)=>{gn(e.inputs),e.compute(Su("MaxPool",e.inputs[0],!1,t))},Iu=e=>{let t=e.storage_order,r=e.dilations,a=hu(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(a.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return re({storageOrder:t,dilations:r,...a})},Cu=e=>{let t=e.format;return{format:t,...wu,cacheKey:t}},_u=(e,t)=>{gn(e.inputs),e.compute(Su("GlobalMaxPool",e.inputs[0],!0,t))}});var jc,qc,Eu,Ou=F(()=>{"use strict";_t();De();be();jc=(e,t,r)=>{let a=e===t,n=e<t&&r<0,s=e>t&&r>0;if(a||n||s)throw new Error("Range these inputs' contents are invalid.")},qc=(e,t,r,a)=>{let n=Math.abs(Math.ceil((t-e)/r)),s=[n],u=n,l=q("output",a,s),o=l.type.storage,p=f=>`
        ${f.declareVariables(l)}
        ${f.mainStart()}
        ${f.guardAgainstOutOfBoundsWorkgroupSizes(u)}
        output[global_idx] = ${o}(${e}) + ${o}(global_idx) * ${o}(${r});
      }`;return{name:"Range",shaderCache:{hint:[e,t,r].map(f=>f.toString()).join("_")},getShaderSource:p,getRunData:()=>({outputs:[{dims:s,dataType:a}],dispatchGroup:{x:Math.ceil(u/64)}})}},Eu=e=>{let t=0,r=0,a=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],a=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],a=e.inputs[2].getFloat32Array()[0]),_e.webgpu.validateInputContent&&jc(t,r,a),e.compute(qc(t,r,a,e.inputs[0].dataType),{inputs:[]})}});var Kc,Yc,Zc,Xc,Qc,Jc,ep,tp,rp,np,ap,op,ip,sp,up,Tu,ku,Ru=F(()=>{"use strict";me();Te();be();Kc=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},Yc=(e,t,r)=>{t.every(n=>n>=0&&n<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let a=new Array(r).fill(1);return t.forEach((n,s)=>a[n]=e[s]),a},Zc=(e,t,r,a,n,s)=>{let[u,l,o]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],p=e[0].dims.length;if(u>0&&e.length>u&&e[u].dims.length>0)e[u].getFloat32Array().forEach(f=>s.push(f));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(l>0&&e.length>l&&e[l].dims.length>0){if(e[l].getFloat32Array().forEach(f=>a.push(f)),a.length!==0&&a.length!==p&&r>=18&&a.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");Kc(a,t),t.axes.length>0&&Yc(a,t.axes,p).forEach((f,y)=>a[y]=f)}if(o>0&&e.length>o&&(e[o].getBigInt64Array().forEach(f=>n.push(Number(f))),n.length!==p||r>=18&&n.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(a.length!==t.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(n.length!==t.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof a<"u"&&typeof n<"u"&&a.length>0&&n.length>p)throw new Error("Resize requires only of scales or sizes to be specified")},Xc=e=>"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(e){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`
`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",Qc=(e,t)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",Jc=(e,t,r)=>{let a=new Array(r).fill(0).concat(new Array(r).fill(1)),n=e.length===0?a:e.slice();return t.length>0?(t.forEach((s,u)=>{a[s]=n[u],a[u+r]=n[t.length+u]}),a):n},ep=(e,t,r,a)=>{let n=[];if(r.length>0)if(a.length>0){if(e.forEach(s=>n.push(s)),Math.max(...a)>e.length)throw new Error("axes is out of bound");a.forEach((s,u)=>n[s]=r[u])}else r.forEach(s=>n.push(s));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");n=e.map((s,u)=>Math.round(s*t[u]))}return n},tp=(e,t,r)=>{let a=(()=>{switch(r.keepAspectRatioPolicy){case"not_larger":return r.axes.length>0?Math.min(...r.axes.map(s=>t[s]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case"not_smaller":return r.axes.length>0?Math.max(...r.axes.map(s=>t[s]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${r.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let n=e.slice();return r.axes.length>0?(r.axes.forEach(s=>t[s]=a),r.axes.forEach(s=>n[s]=Math.round(e[s]*t[s]))):(t.fill(a,0,t.length),n.forEach((s,u)=>n[u]=Math.round(s*t[u]))),n},rp=(e,t,r,a,n)=>`
    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${e.type.indices}) -> array<f32, ${r.length}> {
      const inputShape = array<u32, ${t.length}>(${t.map(s=>`${s}u`).join(",")});
      const outputShape = array<u32, ${r.length}>(${r.map(s=>`${s}u`).join(",")});
      const scales = array<f32, ${a.length}>(${a.map(s=>`${s}f`).join(",")});
      const roi = array<f32, ${n.length}>(${n.map(s=>`${s}f`).join(",")});
      var originalIndices: array<f32, ${r.length}>;
      for (var i:u32 = 0; i < ${r.length}; i++) {
        var outputIndex = ${r.length===1?"outputIndices":"outputIndices[i]"};
        if (scales[i] == 1.0) {
          originalIndices[i] = f32(outputIndex);
        } else {
          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],
                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${t.length}]);
        }
      }
      return originalIndices;
    }`,np=(e,t,r,a,n,s,u)=>`
    fn calculateInputIndicesFromOutputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {
        const inputShape = array<u32, ${r.length}>(${r.map(l=>`${l}u`).join(",")});
        const outputShape = array<u32, ${a.length}>(${a.map(l=>`${l}u`).join(",")});
        const scales = array<f32, ${n.length}>(${n.map(l=>`${l}f`).join(",")});
        const roi = array<f32, ${s.length}>(${s.map(l=>`${l}f`).join(",")});
        var inputIndices: ${e.type.indices};
        for (var i:u32 = 0; i < ${a.length}; i++) {
          var outputIndex = ${a.length===1?"outputIndices":"outputIndices[i]"};
          var inputIndex: u32;
          if (scales[i] == 1.0) {
            inputIndex = outputIndex;
          } else {
            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],
                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${r.length}]);
            if (!${u} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {
              if (original_idx < 0) {
                inputIndex = 0;
              } else if (original_idx > (f32(inputShape[i]) - 1)) {
                inputIndex = inputShape[i] - 1;
              } else {
                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));
              }
            } else {
              inputIndex = u32(original_idx);
            }
          }
          ${e.indicesSet("inputIndices","i","inputIndex")}
        }
        return inputIndices;
    }`,ap=(e,t)=>`
    fn checkInputIndices(inputIndices: ${e.type.indices}) -> bool {
      const inputShape = array<u32, ${t.length}>(${t.map(r=>`${r}u`).join(",")});
      for (var i:u32 = 0; i < ${t.length}; i++) {
        var inputIndex = ${t.length===1?"inputIndices":"inputIndices[i]"};
        if (inputIndex < 0 || inputIndex >= inputShape[i]) {
          return false;
        }
      }
      return true;
    }`,op=(e,t,r,a,n,s)=>{let[u,l,o,p]=r.length===2?[-1,0,1,-1]:a[1]===1?[0,2,3,1]:[0,1,2,3];return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {
      var inputIndices: ${e.type.indices};
      inputIndices[${l}] = max(0, min(row, ${r[l]} - 1));
      inputIndices[${o}] = max(0, min(col, ${r[o]} - 1));
      if (${r.length} > 2) {
        inputIndices[${p}] = channel;
        inputIndices[${u}] = batch;
      };
      return input[${e.indicesToOffset("inputIndices")}];
    }

    fn bilinearInterpolation(outputIndices: ${t.type.indices}) -> f32 {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);
      var row:f32 = originalIndices[${l}];
      var col:f32 = originalIndices[${o}];
      if (${n} && (row < 0 || row > (${r[l]} - 1) || col < 0 || col > ${r[o]} - 1)) {
        return ${s};
      }
      row = max(0, min(row, ${r[l]} - 1));
      col = max(0, min(col, ${r[o]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = 0;
      var batch: u32 = 0;
      if (${r.length>2}) {
        channel = u32(originalIndices[${p}]);
        batch = u32(originalIndices[${u}]);
      }
      var x11: f32 = getInputValue(batch, channel, row1, col1);
      var x12: f32 = getInputValue(batch, channel, row1, col2);
      var x21: f32 = getInputValue(batch, channel, row2, col1);
      var x22: f32 = getInputValue(batch, channel, row2, col2);
      var dx1: f32 = row - f32(row1);
      var dx2: f32 = f32(row2 ) - row;
      var dy1 = col - f32(col1);
      var dy2 = f32(col2) - col;
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},ip=(e,t,r,a,n,s,u,l,o,p)=>{let[f,y]=r.length===2?[0,1]:n[1]===1?[2,3]:[1,2],g=b=>{let v=b===f?"row":"col";return`
      fn ${v}CubicInterpolation(inputIndices: ${e.type.indices}, outputIndices: ${t.type.indices}) -> f32 {
        var outputIndex = ${a.length===1?"outputIndices":`outputIndices[${b}]`};
        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${n[b]},
        f32(${a[b]}), f32(${r[b]}), ${s[b]}, ${s[b]} + ${r.length});
        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${l} && (originalIdx < 0 || originalIdx > (${r[b]} - 1))) {
          return ${o};
        }
        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${v}: f32 = originalIdx + f32(i);
          if (${v} < 0 || ${v} >= ${r[b]}) {
            if (${p}) {
              coefs[i + 1] = 0.0;
              continue;
            } else if (${l}) {
              return ${o};
            } else {
              ${v} = max(0, min(${v}, ${r[b]} - 1));
            }
          }
          var inputIndicesCopy: ${e.type.indices} = inputIndices;
          inputIndicesCopy[${b}] = u32(${v});
          data[i + 1] = ${b===f?`input[${e.indicesToOffset("inputIndicesCopy")}];`:`
                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);`}
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${g(f)};
    ${g(y)};
  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {
    var absS = abs(s);
    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: f32 = 1.0 - absS;
    var twoMinusAbsS: f32 = 2.0 - absS;
    var onePlusAbsS: f32 = 1.0 + absS;
    coeffs[0] = ((${u} * onePlusAbsS - 5 * ${u}) * onePlusAbsS + 8 * ${u}) * onePlusAbsS - 4 * ${u};
    coeffs[1] = ((${u} + 2) * absS - (${u} + 3)) * absS * absS + 1;
    coeffs[2] = ((${u} + 2) * oneMinusAbsS - (${u} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${u} * twoMinusAbsS - 5 * ${u}) * twoMinusAbsS + 8 * ${u}) * twoMinusAbsS - 4 * ${u};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {
    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(outputIndices: ${t.type.indices}) -> f32 {
    var inputIndices: ${e.type.indices} = outputIndices;
    return colCubicInterpolation(inputIndices, outputIndices);
  }
    `},sp=(e,t,r,a,n,s)=>{let u=e.dims,l=Jc(s,t.axes,u.length),o=ep(u,a,n,t.axes),p=a.slice();a.length===0&&(p=u.map((I,_)=>I===0?1:o[_]/I),t.keepAspectRatioPolicy!=="stretch"&&(o=tp(u,p,t)));let f=q("output",e.dataType,o),y=L("input",e.dataType,u),g=z.size(o),b=u.length===o.length&&u.every((I,_)=>I===o[_]),v=t.coordinateTransformMode==="tf_crop_and_resize",$=I=>`
      ${b?"":`
      ${Xc(t.coordinateTransformMode)};
      ${(()=>{switch(t.mode){case"nearest":return`
              ${ap(y,u)};
              ${Qc(t.nearestMode,r)};
              ${np(y,f,u,o,p,l,v)};
              `;case"linear":return`
              ${rp(f,u,o,p,l)};
              ${op(y,f,u,p,v,t.extrapolationValue)};
              `;case"cubic":return`
            ${ip(y,f,u,o,p,l,t.cubicCoeffA,v,t.extrapolationValue,t.excludeOutside)};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${I.declareVariables(y,f)}
      ${I.mainStart()}
        ${I.guardAgainstOutOfBoundsWorkgroupSizes(g)}
        ${b?"output[global_idx] = input[global_idx];":`
        let outputIndices = ${f.offsetToIndices("global_idx")};
        var inputIndices: ${y.type.indices};
        ${(()=>{switch(t.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);
                if (checkInputIndices(inputIndices)) {
                  output[global_idx] = input[${y.indicesToOffset("inputIndices")}];
                } else {
                  output[global_idx] = ${t.extrapolationValue};
                }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};
        `}
      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${p.length>0?p:""}|${n.length>0?n:""}|${b}`},getShaderSource:$,getRunData:()=>({outputs:[{dims:o,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(g/64)}})}},up=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},Tu=(e,t)=>{let r=[],a=[],n=[],s=up(e);Zc(e.inputs,t,s,r,a,n),e.compute(sp(e.inputs[0],t,s,r,a,n),{inputs:[0]})},ku=e=>{let t=e.antialias,r=e.axes,a=e.coordinateTransformMode,n=e.cubicCoeffA,s=e.excludeOutside!==0,u=e.extrapolationValue,l=e.keepAspectRatioPolicy,o=e.mode,p=e.nearestMode===""?"simple":e.nearestMode;return re({antialias:t,axes:r,coordinateTransformMode:a,cubicCoeffA:n,excludeOutside:s,extrapolationValue:u,keepAspectRatioPolicy:l,mode:o,nearestMode:p})}});var lp,dp,Pu,Bu,Mu=F(()=>{"use strict";De();me();Te();be();lp=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],r=e[1],a=e[2];if(t.dataType!==r.dataType||t.dataType!==a.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let n=t.dims[t.dims.length-1],s=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==n)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==s)throw new Error("Skip must have the same sequence length as input");if(a.dims.length!==1)throw new Error("Gamma must be 1D");if(a.dims[a.dims.length-1]!==n)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let u=e[3];if(u.dims.length!==1)throw new Error("Beta must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let u=e[4];if(u.dims.length!==1)throw new Error("Bias must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Bias must have the same hidden size as input")}},dp=(e,t,r,a)=>{let n=e[0].dims,s=z.size(n),u=n,l=s,o=n.slice(-1)[0],p=a?n.slice(0,-1).concat(1):[],f=e.length>3,y=e.length>4,g=a&&r>1,b=a&&r>2,v=r>3,$=et(o),I=[L("x",e[0].dataType,e[0].dims,$),L("skip",e[1].dataType,e[1].dims,$),L("gamma",e[2].dataType,e[2].dims,$)];f&&I.push(L("beta",e[3].dataType,e[3].dims,$)),y&&I.push(L("bias",e[4].dataType,e[4].dims,$)),I.push(q("output",e[0].dataType,u,$)),g&&I.push(q("meanOutput",1,p)),b&&I.push(q("invStdOutput",1,p)),v&&I.push(q("inputSkipBiasSum",e[0].dataType,u,$));let _=Ce(e[0].dataType),C=A=>`
      const hiddenSize: f32 = ${o};
      const hiddenSizeVectorized: u32 = ${o/$};
      const epsilon: f32 = ${t.epsilon};

      ${A.declareVariables(...I)}

      ${A.mainStart()}
        ${A.guardAgainstOutOfBoundsWorkgroupSizes(l/o)}
        let offset = global_idx * hiddenSizeVectorized;
        var sum = ${Le("f32",$)};
        var squareSum = ${Le("f32",$)};
        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {
          let skipValue = skip[offset + i];
          let biasValue = ${y?"bias[i]":"0.0"};
          let inputValue = x[offset + i];
          let value = inputValue + skipValue + biasValue;
          ${v?"inputSkipBiasSum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32Value = ${rt(_,$,"value")};
          sum += f32Value;
          squareSum += f32Value * f32Value;
        }
        let mean = ${nt("sum",$)} / hiddenSize;
        let variance = sqrt(${nt("squareSum",$)} / hiddenSize - mean * mean + epsilon);
        ${g?"meanOutput[global_idx] = mean;":""}
        ${b?"invStdOutput[global_idx] = 1.0 / variance;":""}
        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {
          output[offset + i] = (output[offset + i] - ${_}(mean)) / ${_}(variance) * gamma[i]
           + ${f?"beta[i]":"0.0"};
        }
      }`,P=[{dims:u,dataType:e[0].dataType}];return r>1&&P.push({dims:p,dataType:1}),r>2&&P.push({dims:p,dataType:1}),r>3&&P.push({dims:n,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:t.cacheKey},getShaderSource:C,getRunData:()=>({outputs:P,dispatchGroup:{x:Math.ceil(l/o/64)}})}},Pu=(e,t)=>{lp(e.inputs);let a=[0];e.outputCount>1&&a.push(-3),e.outputCount>2&&a.push(-3),e.outputCount>3&&a.push(3),e.compute(dp(e.inputs,t,e.outputCount,!1),{outputs:a})},Bu=e=>{let t=e.epsilon;return re({epsilon:t})}});var cp,yn,pp,Du,fp,mp,zu,Wu,Vu=F(()=>{"use strict";De();me();Te();be();cp=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((r,a)=>{if(e[a+1].dataType!==6&&e[a+1].dataType!==7)throw new Error(`Input ${a} must be an array of int32 or int64`)})},yn=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(a=>r.push(Number(a)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(a=>r.push(Number(a)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},pp=(e,t)=>{if(e.length>1){let r=yn(e,1),a=yn(e,2),n=yn(e,3);return n.length===0&&(n=[...Array(e[0].dims.length).keys()]),re({starts:r,ends:a,axes:n})}else return t},Du=(e,t,r,a,n)=>{let s=e;return e<0&&(s+=r[a[t]]),n[t]<0?Math.max(0,Math.min(s,r[a[t]]-1)):Math.max(0,Math.min(s,r[a[t]]))},fp=(e,t,r,a,n)=>`fn calculateInputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {
          var inputIndices: ${e.type.indices};
          var carry = 0u;
          for (var i = ${r.length}; i >= 0; i--) {
            let input_shape_i = ${n?`uniforms.input_shape${r.length>1?"[i]":""}`:"inputShape[i]"};
            let steps_i  = ${n?`uniforms.steps${r.length>1?"[i]":""}`:"steps[i]"};
            let signs_i  = ${n?`uniforms.signs${r.length>1?"[i]":""}`:"signs[i]"};
            let starts_i  = ${n?`uniforms.starts${r.length>1?"[i]":""}`:"starts[i]"};
            var outputIndex = ${a.length===1?"outputIndices":"outputIndices[i]"};
            var inputIndex = outputIndex * steps_i + starts_i + carry;
            carry = inputIndex / input_shape_i;
            inputIndex = inputIndex % input_shape_i;
            if (signs_i < 0) {
              inputIndex = input_shape_i - inputIndex - 1u + starts_i;
            }
            ${r.length===1?"inputIndices":"inputIndices[i]"} = inputIndex;
          }
          return inputIndices;
      }`,mp=(e,t)=>{let r=e[0].dims,a=z.size(r),n=t.axes.length>0?z.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],s=yn(e,4);s.forEach(A=>A!==0||(()=>{throw new Error("step cannot be 0")})),s.length===0&&(s=Array(n.length).fill(1));let u=t.starts.map((A,B)=>Du(A,B,r,n,s)),l=t.ends.map((A,B)=>Du(A,B,r,n,s));if(n.length!==u.length||n.length!==l.length)throw new Error("start, ends and axes should have the same number of elements");if(n.length!==r.length)for(let A=0;A<r.length;++A)n.includes(A)||(u.splice(A,0,0),l.splice(A,0,r[A]),s.splice(A,0,1));let o=s.map(A=>Math.sign(A));s.forEach((A,B,O)=>{if(A<0){let W=(l[B]-u[B])/A,V=u[B],Y=V+W*s[B];u[B]=Y,l[B]=V,O[B]=-A}});let p=je(e[0].dims.length),f=p?e[0].dims.length:e[0].dims,y=r.slice(0);n.forEach((A,B)=>{y[A]=Math.ceil((l[A]-u[A])/s[A])});let g=p?y.length:y,b={dims:y,dataType:e[0].dataType},v=q("output",e[0].dataType,g),$=L("input",e[0].dataType,f),I=z.size(y),_=[],C=[];p&&(C.push({name:"starts",type:u.length>1?`vec${u.length}<u32>`:"u32"}),C.push({name:"signs",type:o.length>1?`vec${o.length}<i32>`:"i32"}),C.push({name:"steps",type:s.length>1?`vec${s.length}<u32>`:"u32"}),_.push({type:"uint32",data:u}),_.push({type:"int32",data:o}),_.push({type:"uint32",data:s})),C.push({name:"outputSize",type:"u32"}),_.push({type:"uint32",data:I}),p&&(_.push(...He(e[0].dims)),_.push(...He(y)));let P=A=>`
      ${A.registerUniforms(C).declareVariables($,v)}
        ${p?"":[`const signs = array<i32, ${o.length}>(${o.map(B=>`${B}i`).join(",")});`,`const starts = array<u32, ${u.length}>(${u.map(B=>`${B}u`).join(",")});`,`const steps = array<u32, ${s.length}>(${s.map(B=>`${B}u`).join(",")});`,`const inputShape = array<u32, ${r.length}>(${r.map(B=>`${B}u`).join(",")});`].join(`
`)}

        ${fp($,v,r,y,p)}
        ${A.mainStart()}
          ${A.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let outputIndices = ${v.offsetToIndices("global_idx")};
          let inputIndices = calculateInputIndices(outputIndices);
          ${v.setByOffset("global_idx",$.getByIndices("inputIndices"))}
      }`;return{name:"Slice",shaderCache:{hint:p?`${o.length}_${u.length}_${s.length}`:`${t.cacheKey} | ${e[4]?.dims??""}`,inputDependencies:[p?"rank":"dims"]},getShaderSource:P,getRunData:()=>({outputs:[b],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:_})}},zu=(e,t)=>{cp(e.inputs,t);let r=pp(e.inputs,t);e.compute(mp(e.inputs,r),{inputs:[0]})},Wu=e=>{let t=e.starts,r=e.ends,a=e.axes;return re({starts:t,ends:r,axes:a})}});var hp,gp,Nu,Uu,Hu=F(()=>{"use strict";me();Te();be();hp=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},gp=(e,t)=>{let r=e.dims,a=z.size(r),n=64,s=t.axis;if(s<0&&(s=r.length+s),s<r.length-1)throw new Error("softmax only supports last axis for now.");let u=r[s],l=a/u,o=et(u),p=u/o,f=(I,_)=>_===4?`max(max(${I}.x, ${I}.y), max(${I}.z, ${I}.w))`:_===2?`max(${I}.x, ${I}.y)`:_===3?`max(max(${I}.x, ${I}.y), ${I}.z)`:I,y=L("x",e.dataType,e.dims,o),g=q("result",e.dataType,e.dims,o),b=y.type.value,v=Ce(e.dataType)==="f32"?`var threadMax = ${b}(-3.402823e+38f);`:`var threadMax = ${b}(-65504.0h);`,$=I=>`
      var<workgroup> rowMaxShared : ${b};
      var<workgroup> rowSumShared : ${b};
      var<workgroup> threadShared : array<${b}, ${n}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${b} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${b}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${I.registerUniform("packedCols","i32").declareVariables(y,g)}
      ${I.mainStart()}
        let gindex = i32(global_id.x);
        let lindex = i32(local_id.x);
        const wg = ${n};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${v}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${b}(${f("threadShared[0]",o)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${b}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${b}(${nt("threadShared[0]",o)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`;return{name:"Softmax",shaderCache:{hint:`${o}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:r,dataType:e.dataType}],dispatchGroup:{x:l},programUniforms:[{type:"uint32",data:p}]}),getShaderSource:$}},Nu=(e,t)=>{hp(e.inputs),e.compute(gp(e.inputs[0],t))},Uu=e=>re({axis:e.axis})});var yp,bp,wp,vp,$p,Lu,Gu,Fu=F(()=>{"use strict";me();Te();be();yp=e=>{if(!e||e.length<1)throw new Error("too few inputs")},bp=(e,t)=>{let r=[],a=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(n=>r.push(Number(n))),a=r.length),re({numOutputs:a,axis:t.axis,splitSizes:r})},wp=e=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {
    if (index < sizeInConcatAxis[i]) {
        return i;
    }
    }
    return ${e}u;
}`,vp=e=>{let t=e.length,r=[];for(let a=0;a<t;++a){let n=e[a].setByIndices("indices","input[global_idx]");t===1?r.push(n):a===0?r.push(`if (outputNumber == ${a}u) { ${n} }`):a===t-1?r.push(`else { ${n} }`):r.push(`else if (outputNumber == ${a}) { ${n} }`)}return`
      fn writeBufferData(outputNumber: u32, indices: ${e[0].type.indices}, global_idx: u32) {
        ${r.join(`
`)}
      }`},$p=(e,t)=>{let r=e[0].dims,a=z.size(r),n=e[0].dataType,s=r.length,u=t.axis,l=u<0?r.length+u:u,o=new Array(t.numOutputs),p=L("input",n,r),f=new Array(t.numOutputs),y=[],g=[],b=0;for(let I=0;I<t.numOutputs;I++){b+=t.splitSizes[I],f[I]=b;let _=r.slice();_[t.axis]=t.splitSizes[I],g.push(_),o[I]=q(`output${I}`,n,g[I]),y.push({dims:g[I],dataType:e[0].dataType})}let v=s<2?"indices":`indices[${l}]`,$=I=>`
  ${I.declareVariables(p,...o)}
  const sizeInConcatAxis = array<u32, ${f.length}>(${f.map(_=>`${_}u`).join(",")});
  ${wp(f.length)}
  ${vp(o)}

  ${I.mainStart()}
    ${I.guardAgainstOutOfBoundsWorkgroupSizes(a)}

    var indices = ${p.offsetToIndices("global_idx")};
    let outputNumber = calculateOutputIndex(${v});
    if (outputNumber != 0) {
        ${v} -= sizeInConcatAxis[outputNumber - 1u];
    }
    writeBufferData(outputNumber, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:t.cacheKey},getShaderSource:$,getRunData:()=>({outputs:y,dispatchGroup:{x:Math.ceil(a/64)}})}},Lu=(e,t)=>{yp(e.inputs);let r=e.inputs.length===1?t:bp(e.inputs,t);e.compute($p(e.inputs,r),{inputs:[0]})},Gu=e=>{let t=e.axis,r=e.splitSizes,a=e.numOutputs<0?r.length:e.numOutputs;if(a!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return re({axis:t,numOutputs:a,splitSizes:r})}});var ju,Sp,xp,Ip,qu,Ku=F(()=>{"use strict";De();me();be();ju=e=>Array.from(e.getBigInt64Array(),Number),Sp=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(ju(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},xp=(e,t)=>{let r=[];for(let a=0;a<e.length;++a)r.push(e[a]*t[a]);return r},Ip=e=>{let t=e[0].dims,r=ju(e[1]),a=xp(t,r),n=z.size(a),s=e[0].dataType,u=L("input",s,t),l=q("output",s,a),o=p=>`
      const inputShape = ${u.indices(...t)};
      ${p.declareVariables(u,l)}
      ${p.mainStart()}
      ${p.guardAgainstOutOfBoundsWorkgroupSizes(n)}
      let outputIndices = ${l.offsetToIndices("global_idx")};
      var inputIndices: ${u.type.indices};
      for (var i = 0; i < ${t.length}; i++) {
        let inputDimValue = ${l.indicesGet("outputIndices","i")}  % ${u.indicesGet("inputShape","i")};

        ${u.indicesSet("inputIndices","i","inputDimValue")}
      }
      ${l.setByOffset("global_idx",u.getByIndices("inputIndices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${r}`},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)}}),getShaderSource:o}},qu=e=>{Sp(e.inputs),e.compute(Ip(e.inputs),{inputs:[0]})}});var Cp,_p,Yu,Zu=F(()=>{"use strict";De();me();be();Cp=(e,t,r,a,n)=>{let s=z.size(r),u=Math.ceil(s/4),l=q("outputData",n,r,4),o=L("aData",t[1].dataType,t[1].dims,4),p=L("bData",t[2].dataType,t[2].dims,4),f=L("cData",t[0].dataType,t[0].dims,4),y,g=(b,v,$)=>`select(${v}, ${b}, ${$})`;if(!a)y=l.setByOffset("global_idx",g(o.getByOffset("global_idx"),p.getByOffset("global_idx"),f.getByOffset("global_idx")));else{let b=(v,$,I="")=>{let _=`aData[indexA${$}][componentA${$}]`,C=`bData[indexB${$}][componentB${$}]`,P=`bool(cData[indexC${$}] & ${4278190080>>>(3-$)*8}u)`;return`
            let outputIndices${$} = ${l.offsetToIndices(`global_idx * 4u + ${$}u`)};
            let offsetA${$} = ${o.broadcastedIndicesToOffset(`outputIndices${$}`,l)};
            let offsetB${$} = ${p.broadcastedIndicesToOffset(`outputIndices${$}`,l)};
            let offsetC${$} = ${f.broadcastedIndicesToOffset(`outputIndices${$}`,l)};
            let indexA${$} = offsetA${$} / 4u;
            let indexB${$} = offsetB${$} / 4u;
            let indexC${$} = offsetC${$} / 4u;
            let componentA${$} = offsetA${$} % 4u;
            let componentB${$} = offsetB${$} % 4u;
            ${v}[${$}] = ${I}(${g(_,C,P)});
          `};n===9?y=`
            var data = vec4<u32>(0);
            ${b("data",0,"u32")}
            ${b("data",1,"u32")}
            ${b("data",2,"u32")}
            ${b("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:y=`
            ${b("outputData[global_idx]",0)}
            ${b("outputData[global_idx]",1)}
            ${b("outputData[global_idx]",2)}
            ${b("outputData[global_idx]",3)}
          `}return`
        ${e.declareVariables(f,o,p,l)}
        ${e.mainStart()}
        ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}
        ${y}
      }`},_p=e=>{let t=e[1].dims,r=e[2].dims,a=e[0].dims,n=e[1].dataType,s=!(z.areEqual(t,r)&&z.areEqual(r,a)),u=t,l=z.size(t);if(s){let o=lt.calcShape(lt.calcShape(t,r,!1),a,!1);if(!o)throw new Error("Can't perform where op on the given tensors");u=o,l=z.size(u)}return{name:"Where",getShaderSource:o=>Cp(o,e,u,s,n),getRunData:()=>({outputs:[{dims:u,dataType:n}],dispatchGroup:{x:Math.ceil(l/64/4)}})}},Yu=e=>{e.compute(_p(e.inputs))}});var Xu,Qu=F(()=>{"use strict";Ci();Jn();Oi();us();ws();Ss();aa();Ms();Vs();Hs();Fs();Ks();Xs();eu();nu();ou();lu();pu();Au();Ou();an();Ru();Mu();Vu();Hu();Fu();Ku();Zt();ea();Zu();Xu=new Map([["Abs",[Ti]],["Acos",[ki]],["Acosh",[Ri]],["Add",[ls]],["ArgMax",[Ii,Qn]],["ArgMin",[xi,Qn]],["Asin",[Pi]],["Asinh",[Bi]],["Atan",[Mi]],["Atanh",[Di]],["Attention",[Ai,_i]],["AveragePool",[bu,yu]],["BiasAdd",[Ei]],["BiasSplitGelu",[ss]],["Cast",[Wi,zi]],["Ceil",[Ni]],["Clip",[Vi]],["Concat",[vs,$s]],["Conv",[ia,oa]],["ConvTranspose",[Bs,Ps]],["Cos",[Ui]],["Cosh",[Hi]],["Div",[ds]],["Einsum",[zs,Ws]],["Elu",[Li,un]],["Equal",[cs]],["Erf",[Gi]],["Exp",[Fi]],["Expand",[Us]],["Floor",[ji]],["FusedConv",[ia,oa]],["Gather",[Gs,Ls]],["GatherElements",[qs,js]],["Gelu",[qi]],["Gemm",[Ys,Zs]],["GlobalAveragePool",[$u,vu]],["GlobalMaxPool",[_u,Cu]],["Greater",[hs]],["GreaterOrEqual",[ys]],["InstanceNormalization",[Js,Qs]],["LayerNormalization",[ru,tu]],["LeakyRelu",[Ki,un]],["Less",[gs]],["LessOrEqual",[bs]],["Log",[is]],["MatMul",[au]],["MaxPool",[xu,Iu]],["Mul",[ps]],["MultiHeadAttention",[uu,su]],["Neg",[Zi]],["Not",[Yi]],["Pad",[du,cu]],["Pow",[fs]],["Range",[Eu]],["Reciprocal",[Xi]],["ReduceMin",[yi,ot]],["ReduceMean",[pi,ot]],["ReduceMax",[gi,ot]],["ReduceSum",[wi,ot]],["ReduceProd",[bi,ot]],["ReduceL1",[fi,ot]],["ReduceL2",[mi,ot]],["ReduceLogSum",[$i,ot]],["ReduceLogSumExp",[hi,ot]],["ReduceSumSquare",[vi,ot]],["Relu",[Qi]],["Resize",[Tu,ku]],["Sigmoid",[Ji]],["Sin",[es]],["Sinh",[ts]],["Slice",[zu,Wu]],["SkipLayerNormalization",[Pu,Bu]],["Split",[Lu,Gu]],["Sqrt",[rs]],["Softmax",[Nu,Uu]],["Sub",[ms]],["Tan",[ns]],["Tanh",[as]],["ThresholdedRelu",[os,un]],["Tile",[qu]],["Transpose",[Jo,ei]],["Where",[Yu]]])});var bn,Ju=F(()=>{"use strict";De();At();be();bn=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,a,n,s,u,l){let o=this.backend.device,p=this.backend.getComputePassEncoder();p.setPipeline(t.computePipeline);let f=[];for(let g of n)f.push({binding:f.length,resource:{buffer:g.buffer}});for(let g of s)f.push({binding:f.length,resource:{buffer:g.buffer}});l&&f.push({binding:f.length,resource:l});let y=o.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:f,label:t.programInfo.name});if(p.setBindGroup(0,y),p.dispatchWorkgroups(...u),this.backend.pendingDispatchNumber++,this.backend.isQueryEnabled()){typeof this.backend.queryData>"u"&&(this.backend.queryData=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let g=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.querySet,0,2,this.backend.queryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.queryData.buffer,0,g.buffer,0,this.backend.querySetCount*8),this.backend.flush();let b=this.backend.currentKernelId,v=this.backend.kernels.get(b),$=`[${v[0]}] ${v[1]}`;g.buffer.mapAsync(GPUMapMode.READ).then(()=>{let I=new BigUint64Array(g.buffer.getMappedRange()),_=I[0],C=I[1];g.buffer.unmap(),typeof this.backend.queryTimeBase>"u"&&(this.backend.queryTimeBase=_);let P=Number(_-this.backend.queryTimeBase),A=Number(C-this.backend.queryTimeBase);if(!Number.isSafeInteger(P)||!Number.isSafeInteger(A))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(g.id);let B="";r.forEach((W,V)=>{B+=`input[${V}]: [${W.dims}] | ${gr(W.dataType)}, `});let O="";a.forEach((W,V)=>{O+=`output[${V}]: [${W.dims}] | ${gr(W.dataType)}, `}),console.log(`[profiling] kernel "${b}|${$}" ${B}${O}execution time: ${A-P} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(t,r){let a=this.backend.device,n=[];a.features.has("shader-f16")&&n.push("enable f16;");let s=Xo(r),u=t.getShaderSource(s),l=`${n.join(`
`)}
${s.additionalImplementations}
${u}`,o=a.createShaderModule({code:l,label:t.name});Oe("verbose",()=>`[WebGPU] ${t.name} shader code: ${l}`);let p=a.createComputePipeline({compute:{module:o,entryPoint:"main"},layout:"auto",label:t.name});return{programInfo:t,computePipeline:p}}normalizeDispatchGroupSize(t){let r=typeof t=="number"?t:t.x,a=typeof t=="number"?1:t.y||1,n=typeof t=="number"?1:t.z||1,s=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=s&&a<=s&&n<=s)return[r,a,n];let u=r*a*n,l=Math.ceil(Math.sqrt(u));if(l>s){if(l=Math.ceil(Math.cbrt(u)),l>s)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[l,l,l]}else return[l,l,1]}}});var Ap,Ep,wn,el=F(()=>{"use strict";At();Go();Ko();Qu();Ju();Ap=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let a=0;a<e.length;++a){let n=e[a].dataType;switch(t[a]){case"none":{r.push("");break}case"type":{r.push(`${n}`);break}case"rank":{let s=e[a].dims.length;r.push(`${n};${s}`);break}case"dims":{let s=e[a].dims.join(",");r.push(`${n};${s}`);break}default:throw new Error(`unsupported input dependency: ${t[a]}`)}}return r.join("|")},Ep=(e,t,r)=>{let a=e.name;return e.shaderCache?.hint&&(a+="["+e.shaderCache.hint+"]"),a+=":"+r+`:${Ap(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,a},wn=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispatchNumber=0;this.querySetCount=2;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let r=await navigator.gpu.requestAdapter();if(!r)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=t;let a=[],n={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:a};r.features.has("timestamp-query")&&a.push("timestamp-query"),r.features.has("shader-f16")&&a.push("shader-f16"),this.device=await r.requestDevice(n),this.gpuDataManager=qo(this),this.programManager=new bn(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Ho(t.logLevel,!!t.debug),this.device.onuncapturederror=s=>{s.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${s.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t={};this.isQueryEnabled()&&(typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}isQueryEnabled(){return!!(this.device.features.has("timestamp-query")&&this.env.webgpu.profilingMode==="default")}run(t,r,a,n,s){let u=[];for(let C=0;C<r.length;++C){let P=this.gpuDataManager.get(r[C].data);if(!P)throw new Error(`no GPU data for input: ${r[C].data}`);u[C]=P}let{outputs:l,dispatchGroup:o,programUniforms:p}=t.getRunData(r),f=a.length===0?l.map((C,P)=>P):a;if(f.length!==l.length)throw new Error(`Output size ${f.length} must be equal to ${l.length}.`);let y=[],g=[];for(let C=0;C<l.length;++C){if(!Number.isInteger(f[C])||f[C]<-3||f[C]>=l.length)throw new Error(`Invalid output index: ${f[C]}`);if(f[C]===-3)continue;let P=f[C]===-1,A=f[C]===-2,B=P||A?s(l[C].dataType,l[C].dims):n(f[C],l[C].dataType,l[C].dims),O=this.gpuDataManager.get(B.data);if(!O)throw new Error(`no GPU data for output: ${B.data}`);if(P&&this.temporaryData.push(O),A){let W=this.kernelPersistentData.get(this.currentKernelId);W||(W=[],this.kernelPersistentData.set(this.currentKernelId,W)),W.push(O)}y.push(B),g.push(O)}let b;if(p){let C=0,P=0,A=[],B=1;p.forEach(V=>{let Y=typeof V.data=="number"?[V.data]:V.data;if(Y.length===0)return;let oe;switch(Y.length){case 1:oe=4;break;case 2:oe=8;break;case 3:oe=16;break;case 4:oe=16;break;case 5:oe=16;break;case 6:oe=16;break;default:throw new Error(`unsupported data length: ${Y.length}`)}(P===5||P===6)&&(oe=16),oe>B&&(B=oe),C=Math.ceil(C/oe)*oe,P=Y.length,A.push(C),C+=Y.length*4}),C=Math.ceil(C/B)*B;let O=new ArrayBuffer(C);p.forEach((V,Y)=>{let oe=A[Y],M=typeof V.data=="number"?[V.data]:V.data;V.type==="int32"?new Int32Array(O,oe,M.length).set(M):V.type==="uint32"?new Uint32Array(O,oe,M.length).set(M):new Float32Array(O,oe,M.length).set(M)});let W=this.gpuDataManager.create(C,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(W.buffer,0,O,0,C),this.gpuDataManager.release(W.id),b={offset:0,size:C,buffer:W.buffer}}let v=this.programManager.normalizeDispatchGroupSize(o),$=v[1]===1&&v[2]===1,I=Ep(t,r,$),_=this.programManager.getArtifact(I);return _||(_=this.programManager.build(t,v),this.programManager.setArtifact(I,_)),Oe("info",()=>`[ProgramManager] run "${t.name}" (key=${I}) with ${v[0]}x${v[1]}x${v[2]}`),this.programManager.run(_,r,y,u,g,v,b),y}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,a,n){let s=Xu.get(t);if(!s)throw new Error(`kernel not implemented: ${t}`);this.kernels.set(r,[t,n,s[0],[s[1],a]])}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let a of r)this.gpuDataManager.release(a.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,a){let n=this.kernels.get(t);if(!n)throw new Error(`kernel not created: ${t}`);let[s,u,l,o]=n;if(this.currentKernelId!==null)throw new Error(`kernel "[${s}] ${u}" is not allowed to be called recursively`);this.currentKernelId=t,o[0]&&(o[1]=o[0](o[1]),o[0]=void 0),Oe("info",()=>`[WebGPU] Start to run kernel "[${s}] ${u}"...`);let p=this.env.debug;this.temporaryData=[];try{return p&&this.device.pushErrorScope("validation"),l(r,o[1]),0}catch(f){return a.push(Promise.resolve(`[WebGPU] Kernel "[${s}] ${u}" failed. ${f}`)),1}finally{p&&a.push(this.device.popErrorScope().then(f=>f?`GPU validation error for kernel "[${s}] ${u}": ${f.message}`:null));for(let f of this.temporaryData)this.gpuDataManager.release(f.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,a,n){let s=this.sessionExternalDataMapping.get(t);s||(s=new Map,this.sessionExternalDataMapping.set(t,s));let u=s.get(r),l=this.gpuDataManager.registerExternalBuffer(a,n,u?.[1]);return s.set(r,[l,a]),l}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(a=>this.gpuDataManager.unregisterExternalBuffer(a[1])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,a){return async()=>{let n=await jn(this,t,r);return Lo(n.buffer,a)}}}});var tl={};zt(tl,{init:()=>Op});var Sr,pa,Op,rl=F(()=>{"use strict";De();el();At();me();Sr=class e{constructor(t,r,a,n){this.module=t;this.dataType=r;this.data=a;this.dims=n}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=z.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=z.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=z.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(z.size(t)!==z.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},pa=class{constructor(t,r,a){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;let n=t.HEAPU32,s=a>>2;this.opKernelContext=n[s++];let u=n[s++];this.outputCount=n[s++],this.customDataOffset=n[s++],this.customDataSize=n[s++];let l=[];for(let o=0;o<u;o++){let p=n[s++],f=n[s++],y=n[s++],g=[];for(let b=0;b<y;b++)g.push(n[s++]);l.push(new Sr(t,p,f,g))}this.inputs=l}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,r){let a=r?.inputs?.map(l=>typeof l=="number"?this.inputs[l]:l)??this.inputs,n=r?.outputs??[],s=(l,o,p)=>new Sr(this.module,o,this.output(l,p),p),u=(l,o)=>{let p=yr(l);if(!p)throw new Error(`Unsupported data type: ${l}`);let f=p*z.size(o);return new Sr(this.module,l,this.backend.gpuDataManager.create(f).id,o)};return this.backend.run(t,a,n,s,u)}output(t,r){let a=this.module.stackSave();try{let n=this.module.stackAlloc((1+r.length)*4),s=n>>2;this.module.HEAPU32[s++]=r.length;for(let u=0;u<r.length;u++)this.module.HEAPU32[s++]=r[u];return this.module._JsepOutput(this.opKernelContext,t,n)}catch(n){throw new Error(`Failed to generate kernel's output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(a)}}},Op=async(e,t)=>{let r=e.jsepInit;if(r&&navigator.gpu){if(!t.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let a=new wn;await a.initialize(t),r(a,n=>a.alloc(n),n=>a.free(n),(n,s,u,l=!1)=>{if(l)Oe("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${n}, dst=${s}, size=${u}`),a.memcpy(n,s);else{Oe("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${n}, gpuDataId=${s}, size=${u}`);let o=e.HEAPU8.subarray(n,n+u);a.upload(s,o)}},async(n,s,u)=>{Oe("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${n}, dataOffset=${s}, size=${u}`),await a.download(n,()=>e.HEAPU8.subarray(s,s+u))},(n,s,u)=>a.createKernel(n,s,u,t.debug||t.webgpu.profilingMode==="default"?e.UTF8ToString(e._JsepGetNodeName(s)):`${s}`),n=>a.releaseKernel(n),(n,s,u,l)=>{Oe("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${u}, kernel=${n}, contextDataOffset=${s}`);let o=new pa(e,a,s);return a.computeKernel(n,o,l)})}}});var al,Tp,kp,ol,xr,il,fa,ma,sl,ul,nl,ll,dl,cl,pl=F(()=>{"use strict";zo();Vo();De();Yt();Zr();al=!1,Tp=e=>{let t=Re(),r=t.stackSave();try{let a=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,a,a+4)!==0&&Ae("Can't get session input/output count."),[t.HEAP32[a/4],t.HEAP32[a/4+1]]}finally{t.stackRestore(r)}},kp=(e,t)=>{Re()._OrtInit(e,t)!==0&&Ae("Can't initialize onnxruntime.")},ol=async e=>{kp(e.wasm.numThreads,br(e.logLevel));{let t=(rl(),Ct(tl)).init;await t(Re(),e)}al=!0},xr=new Map,il=()=>al,fa=e=>{let t=Re(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},ma=(e,t)=>{let r=Re(),a=0,n=0,s=0,u=[],l=[],o=[];try{[n,u]=Wo(t),a=r._OrtCreateSession(e[0],e[1],n),a===0&&Ae("Can't create a session.");let[p,f]=Tp(a),y=[],g=[],b=[];for(let $=0;$<p;$++){let I=r._OrtGetInputName(a,$);I===0&&Ae("Can't get an input name."),l.push(I),y.push(r.UTF8ToString(I))}for(let $=0;$<f;$++){let I=r._OrtGetOutputName(a,$);I===0&&Ae("Can't get an output name."),o.push(I);let _=r.UTF8ToString(I);g.push(_);{let C=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[_]??"cpu";if(C!=="cpu"&&C!=="cpu-pinned"&&C!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${C}.`);b.push(C)}}let v=null;return b.some($=>$==="gpu-buffer")&&(s=r._OrtCreateBinding(a),s===0&&Ae("Can't create IO binding."),v={handle:s,outputPreferredLocations:b,outputPreferredLocationsEncoded:b.map($=>Gn($))}),xr.set(a,[a,l,o,v]),[a,y,g]}catch(p){throw l.forEach(f=>r._OrtFree(f)),o.forEach(f=>r._OrtFree(f)),s!==0&&r._OrtReleaseBinding(s),a!==0&&r._OrtReleaseSession(a),p}finally{r._free(e[0]),n!==0&&r._OrtReleaseSessionOptions(n),u.forEach(p=>r._free(p))}},sl=(e,t)=>{let r=fa(e);return ma(r,t)},ul=e=>{let t=Re(),r=xr.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[a,n,s,u]=r;u&&t._OrtReleaseBinding(u.handle),t.jsepUnregisterBuffers?.(e),n.forEach(l=>t._OrtFree(l)),s.forEach(l=>t._OrtFree(l)),t._OrtReleaseSession(a),xr.delete(e)},nl=(e,t,r,a,n)=>{if(!e){t.push(0);return}let s=Re(),u=e[0],l=e[1],o=e[3],p,f;if(u==="string"&&o==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(o==="gpu-buffer"){let b=e[2].gpuBuffer,v=yr(Ln(u));f=l.reduce(($,I)=>$*I,1)*v,p=s.jsepRegisterBuffer(a,n,b,f)}else{let b=e[2];if(Array.isArray(b)){f=4*b.length,p=s._malloc(f),r.push(p);let v=p/4;for(let $=0;$<b.length;$++){if(typeof b[$]!="string")throw new TypeError(`tensor data at index ${$} is not a string`);s.HEAPU32[v++]=Me(b[$],r)}}else f=b.byteLength,p=s._malloc(f),r.push(p),s.HEAPU8.set(new Uint8Array(b.buffer,b.byteOffset,f),p)}let y=s.stackSave(),g=s.stackAlloc(4*l.length);try{let b=g/4;l.forEach($=>s.HEAP32[b++]=$);let v=s._OrtCreateTensor(Ln(u),p,f,g,l.length,Gn(o));v===0&&Ae(`Can't create tensor for input/output. session=${a}, index=${n}.`),t.push(v)}finally{s.stackRestore(y)}},ll=async(e,t,r,a,n,s)=>{let u=Re(),l=xr.get(e);if(!l)throw new Error(`cannot run inference. invalid session id: ${e}`);let[o,p,f,y]=l,g=t.length,b=a.length,v=0,$=[],I=[],_=[],C=[],P=u.stackSave(),A=u.stackAlloc(g*4),B=u.stackAlloc(g*4),O=u.stackAlloc(b*4),W=u.stackAlloc(b*4);try{[v,$]=Do(s);for(let ue=0;ue<g;ue++)nl(r[ue],I,C,e,t[ue]);for(let ue=0;ue<b;ue++)nl(n[ue],_,C,e,g+a[ue]);let V=A/4,Y=B/4,oe=O/4,M=W/4;for(let ue=0;ue<g;ue++)u.HEAPU32[V++]=I[ue],u.HEAPU32[Y++]=p[t[ue]];for(let ue=0;ue<b;ue++)u.HEAPU32[oe++]=_[ue],u.HEAPU32[M++]=f[a[ue]];if(y){let{handle:ue,outputPreferredLocations:ve,outputPreferredLocationsEncoded:j}=y;if(p.length!==g)throw new Error(`input count from feeds (${g}) is expected to be always equal to model's input count (${p.length}).`);for(let xe=0;xe<g;xe++){let Pe=t[xe];await u._OrtBindInput(ue,p[Pe],I[xe])!==0&&Ae(`Can't bind input[${xe}] for session=${e}.`)}for(let xe=0;xe<b;xe++){let Pe=a[xe];n[xe]?.[3]?u._OrtBindOutput(ue,f[Pe],_[xe],0)!==0&&Ae(`Can't bind pre-allocated output[${xe}] for session=${e}.`):u._OrtBindOutput(ue,f[Pe],0,j[Pe])!==0&&Ae(`Can't bind output[${xe}] to ${ve[xe]} for session=${e}.`)}}let K;y?K=await u._OrtRunWithBinding(o,y.handle,b,O,v):K=await u._OrtRun(o,B,A,g,W,b,O,v),K!==0&&Ae("failed to call OrtRun().");let Se=[];for(let ue=0;ue<b;ue++){let ve=u.HEAPU32[O/4+ue];if(ve===_[ue]){Se.push(n[ue]);continue}let j=u.stackSave(),xe=u.stackAlloc(4*4),Pe=!1,Ee,Ie=0;try{u._OrtGetTensorData(ve,xe,xe+4,xe+8,xe+12)!==0&&Ae(`Can't access output tensor data on index ${ue}.`);let qe=xe/4,Ze=u.HEAPU32[qe++];Ie=u.HEAPU32[qe++];let G=u.HEAPU32[qe++],de=u.HEAPU32[qe++],pe=[];for(let ke=0;ke<de;ke++)pe.push(u.HEAPU32[G/4+ke]);u._OrtFree(G);let Ve=pe.reduce((ke,ze)=>ke*ze,1);Ee=gr(Ze);let Ke=y?.outputPreferredLocations[a[ue]];if(Ee==="string"){if(Ke==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let ke=[],ze=Ie/4;for(let Ge=0;Ge<Ve;Ge++){let it=u.HEAPU32[ze++],Xe=Ge===Ve-1?void 0:u.HEAPU32[ze]-it;ke.push(u.UTF8ToString(it,Xe))}Se.push([Ee,pe,ke,"cpu"])}else if(Ke==="gpu-buffer"&&Ve>0){let ke=u.jsepGetBuffer(Ie),ze=yr(Ze);if(ze===void 0||!Qr(Ee))throw new Error(`Unsupported data type: ${Ee}`);Pe=!0,Se.push([Ee,pe,{gpuBuffer:ke,download:u.jsepCreateDownloader(ke,Ve*ze,Ee),dispose:()=>{u._OrtReleaseTensor(ve)}},"gpu-buffer"])}else{let ke=Xr(Ee),ze=new ke(Ve);new Uint8Array(ze.buffer,ze.byteOffset,ze.byteLength).set(u.HEAPU8.subarray(Ie,Ie+ze.byteLength)),Se.push([Ee,pe,ze,"cpu"])}}finally{u.stackRestore(j),Ee==="string"&&Ie&&u._free(Ie),Pe||u._OrtReleaseTensor(ve)}}return y&&u._OrtClearBoundOutputs(y.handle),Se}finally{u.stackRestore(P),I.forEach(V=>u._OrtReleaseTensor(V)),_.forEach(V=>u._OrtReleaseTensor(V)),C.forEach(V=>u._free(V)),v!==0&&u._OrtReleaseRunOptions(v),$.forEach(V=>u._free(V))}},dl=e=>{let t=Re(),r=xr.get(e);if(!r)throw new Error("invalid session id");let a=r[0],n=t._OrtEndProfiling(a);n===0&&Ae("Can't get an profile file name."),t._OrtFree(n)},cl=e=>{let t=[];for(let r of e){let a=r[2];!Array.isArray(a)&&"buffer"in a&&t.push(a.buffer)}return t}});var fl=Kt((xb,Pp)=>{Pp.exports='/*!\n * ONNX Runtime Web v1.17.0\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n"use strict";(()=>{var un=Object.defineProperty;var Ou=Object.getOwnPropertyDescriptor;var ku=Object.getOwnPropertyNames;var Pu=Object.prototype.hasOwnProperty;var F=(e,t)=>()=>(e&&(t=e(e=0)),t);var rr=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Er=(e,t)=>{for(var r in t)un(e,r,{get:t[r],enumerable:!0})},Ru=(e,t,r,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of ku(t))!Pu.call(e,n)&&n!==r&&un(e,n,{get:()=>t[n],enumerable:!(o=Ou(t,n))||o.enumerable});return e};var zt=e=>Ru(un({},"__esModule",{value:!0}),e);var ln={};Er(ln,{readFile:()=>Bu});var Bu,dn=F(()=>{Bu=void 0});var cn={};Er(cn,{join:()=>Mu});var Mu,pn=F(()=>{Mu=void 0});var po=rr((co,fn)=>{"use strict";var lo=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){var r=t,o,n;r.ready=new Promise((l,f)=>{o=l,n=f}),r.jsepInit=(l,f,g,x,O,H,U,se)=>{r.Za=l,r.Oa=f,r.Qa=g,r.Ja=x,r.Pa=O,r.ra=H,r.Ra=U,r.Sa=se,f=(Z,ee,X)=>(...ce)=>{let he=Ke,k=ee?.();ce=Z(...ce);let ne=ee?.();return k!==ne&&(Z=ne,X(k),ee=X=null),Ke!=he?wr():ce},g=Z=>async(...ee)=>{try{if(r.Da)throw Error("Session already started");let X=r.Da={Ta:ee[0],errors:[]},ce=await Z(...ee);if(r.Da!==X)throw Error("Session mismatch");l.flush();let he=X.errors;if(0<he.length){let k=await Promise.all(he);if(k=k.filter(ne=>ne),0<k.length)throw Error(k.join(`\n`))}return ce}finally{r.Da=null}},r._OrtRun=g(f(r._OrtRun,()=>r._OrtRun,Z=>r._OrtRun=Z)),r._OrtRunWithBinding=g(f(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,Z=>r._OrtRunWithBinding=Z)),r._OrtBindInput=f(r._OrtBindInput,()=>r._OrtBindInput,Z=>r._OrtBindInput=Z),r.jsepRegisterBuffer=(Z,ee,X,ce)=>l.registerBuffer(Z,ee,X,ce),r.jsepUnregisterBuffers=Z=>{l.unregisterBuffers(Z)},r.jsepGetBuffer=Z=>l.getBuffer(Z),r.jsepCreateDownloader=(Z,ee,X)=>l.createDownloader(Z,ee,X)};var s=Object.assign({},r),u="./this.program",d=(l,f)=>{throw f},a=typeof window=="object",p=typeof importScripts=="function",h=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",v="",y,b,w;if(h){var S=(dn(),zt(ln)),C=(pn(),zt(cn));v=p?C.dirname(v)+"/":__dirname+"/",y=(l,f)=>(l=l.startsWith("file://")?new URL(l):C.normalize(l),S.readFileSync(l,f?void 0:"utf8")),w=l=>(l=y(l,!0),l.buffer||(l=new Uint8Array(l)),l),b=(l,f,g,x=!0)=>{l=l.startsWith("file://")?new URL(l):C.normalize(l),S.readFile(l,x?void 0:"utf8",(O,H)=>{O?g(O):f(x?H.buffer:H)})},!r.thisProgram&&1<process.argv.length&&(u=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),d=(l,f)=>{throw process.exitCode=l,f},r.inspect=()=>"[Emscripten Module object]"}else(a||p)&&(p?v=self.location.href:typeof document<"u"&&document.currentScript&&(v=document.currentScript.src),e&&(v=e),v.indexOf("blob:")!==0?v=v.substr(0,v.replace(/[?#].*/,"").lastIndexOf("/")+1):v="",y=l=>{var f=new XMLHttpRequest;return f.open("GET",l,!1),f.send(null),f.responseText},p&&(w=l=>{var f=new XMLHttpRequest;return f.open("GET",l,!1),f.responseType="arraybuffer",f.send(null),new Uint8Array(f.response)}),b=(l,f,g)=>{var x=new XMLHttpRequest;x.open("GET",l,!0),x.responseType="arraybuffer",x.onload=()=>{x.status==200||x.status==0&&x.response?f(x.response):g()},x.onerror=g,x.send(null)});var A=r.print||console.log.bind(console),I=r.printErr||console.error.bind(console);Object.assign(r,s),s=null,r.thisProgram&&(u=r.thisProgram),r.quit&&(d=r.quit);var B;r.wasmBinary&&(B=r.wasmBinary);var _=r.noExitRuntime||!0;typeof WebAssembly!="object"&&je("no native wasm support detected");var R,E,W=!1,V,Y,ae,M,K,Se,ue;function ve(){var l=R.buffer;r.HEAP8=Y=new Int8Array(l),r.HEAP16=new Int16Array(l),r.HEAP32=M=new Int32Array(l),r.HEAPU8=ae=new Uint8Array(l),r.HEAPU16=new Uint16Array(l),r.HEAPU32=K=new Uint32Array(l),r.HEAPF32=Se=new Float32Array(l),r.HEAPF64=ue=new Float64Array(l)}var j=[],xe=[],Pe=[];function _e(){var l=r.preRun.shift();j.unshift(l)}var Ce=0,ht=null,Le=null;function je(l){throw r.onAbort&&r.onAbort(l),l="Aborted("+l+")",I(l),W=!0,V=1,l=new WebAssembly.RuntimeError(l+". Build with -sASSERTIONS for more info."),n(l),l}function L(l){return l.startsWith("data:application/octet-stream;base64,")}var de;if(de="ort-wasm-simd.wasm",!L(de)){var pe=de;de=r.locateFile?r.locateFile(pe,v):v+pe}function We(l){if(l==de&&B)return new Uint8Array(B);if(w)return w(l);throw"both async and sync fetching of the wasm failed"}function Fe(l){if(!B&&(a||p)){if(typeof fetch=="function"&&!l.startsWith("file://"))return fetch(l,{credentials:"same-origin"}).then(f=>{if(!f.ok)throw"failed to load wasm binary file at \'"+l+"\'";return f.arrayBuffer()}).catch(()=>We(l));if(b)return new Promise((f,g)=>{b(l,x=>f(new Uint8Array(x)),g)})}return Promise.resolve().then(()=>We(l))}function Oe(l,f,g){return Fe(l).then(x=>WebAssembly.instantiate(x,f)).then(x=>x).then(g,x=>{I("failed to asynchronously prepare wasm: "+x),je(x)})}function Me(l,f){var g=de;return B||typeof WebAssembly.instantiateStreaming!="function"||L(g)||g.startsWith("file://")||h||typeof fetch!="function"?Oe(g,l,f):fetch(g,{credentials:"same-origin"}).then(x=>WebAssembly.instantiateStreaming(x,l).then(f,function(O){return I("wasm streaming compile failed: "+O),I("falling back to ArrayBuffer instantiation"),Oe(g,l,f)}))}var He,rt={911200:l=>{r.ra("Abs",l,void 0)},911251:l=>{r.ra("Neg",l,void 0)},911302:l=>{r.ra("Floor",l,void 0)},911355:l=>{r.ra("Ceil",l,void 0)},911407:l=>{r.ra("Reciprocal",l,void 0)},911465:l=>{r.ra("Sqrt",l,void 0)},911517:l=>{r.ra("Exp",l,void 0)},911568:l=>{r.ra("Erf",l,void 0)},911619:l=>{r.ra("Sigmoid",l,void 0)},911674:l=>{r.ra("Log",l,void 0)},911725:l=>{r.ra("Sin",l,void 0)},911776:l=>{r.ra("Cos",l,void 0)},911827:l=>{r.ra("Tan",l,void 0)},911878:l=>{r.ra("Asin",l,void 0)},911930:l=>{r.ra("Acos",l,void 0)},911982:l=>{r.ra("Atan",l,void 0)},912034:l=>{r.ra("Sinh",l,void 0)},912086:l=>{r.ra("Cosh",l,void 0)},912138:l=>{r.ra("Asinh",l,void 0)},912191:l=>{r.ra("Acosh",l,void 0)},912244:l=>{r.ra("Atanh",l,void 0)},912297:l=>{r.ra("Tanh",l,void 0)},912349:l=>{r.ra("Not",l,void 0)},912400:(l,f,g)=>{r.ra("Clip",l,{min:f,max:g})},912469:l=>{r.ra("Clip",l,void 0)},912521:(l,f)=>{r.ra("Elu",l,{alpha:f})},912579:l=>{r.ra("Relu",l,void 0)},912631:(l,f)=>{r.ra("LeakyRelu",l,{alpha:f})},912695:(l,f)=>{r.ra("ThresholdedRelu",l,{alpha:f})},912765:(l,f)=>{r.ra("Cast",l,{to:f})},912823:l=>{r.ra("Add",l,void 0)},912874:l=>{r.ra("Sub",l,void 0)},912925:l=>{r.ra("Mul",l,void 0)},912976:l=>{r.ra("Div",l,void 0)},913027:l=>{r.ra("Pow",l,void 0)},913078:l=>{r.ra("Equal",l,void 0)},913131:l=>{r.ra("Greater",l,void 0)},913186:l=>{r.ra("GreaterOrEqual",l,void 0)},913248:l=>{r.ra("Less",l,void 0)},913300:l=>{r.ra("LessOrEqual",l,void 0)},913359:(l,f,g,x,O)=>{r.ra("ReduceMean",l,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:x?Array.from(M.subarray(O>>>0,O+x>>>0)):[]})},913523:(l,f,g,x,O)=>{r.ra("ReduceMax",l,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:x?Array.from(M.subarray(O>>>0,O+x>>>0)):[]})},913686:(l,f,g,x,O)=>{r.ra("ReduceMin",l,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:x?Array.from(M.subarray(O>>>0,O+x>>>0)):[]})},913849:(l,f,g,x,O)=>{r.ra("ReduceProd",l,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:x?Array.from(M.subarray(O>>>0,O+x>>>0)):[]})},914013:(l,f,g,x,O)=>{r.ra("ReduceSum",l,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:x?Array.from(M.subarray(O>>>0,O+x>>>0)):[]})},914176:(l,f,g,x,O)=>{r.ra("ReduceL1",l,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:x?Array.from(M.subarray(O>>>0,O+x>>>0)):[]})},914338:(l,f,g,x,O)=>{r.ra("ReduceL2",l,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:x?Array.from(M.subarray(O>>>0,O+x>>>0)):[]})},914500:(l,f,g,x,O)=>{r.ra("ReduceLogSum",l,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:x?Array.from(M.subarray(O>>>0,O+x>>>0)):[]})},914666:(l,f,g,x,O)=>{r.ra("ReduceSumSquare",l,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:x?Array.from(M.subarray(O>>>0,O+x>>>0)):[]})},914835:(l,f,g,x,O)=>{r.ra("ReduceLogSumExp",l,{keepDims:!!f,noopWithEmptyAxes:!!g,axes:x?Array.from(M.subarray(O>>>0,O+x>>>0)):[]})},915004:l=>{r.ra("Where",l,void 0)},915057:(l,f,g)=>{r.ra("Transpose",l,{perm:f?Array.from(M.subarray(g>>>0,g+f>>>0)):[]})},915170:(l,f,g,x,O,H,U,se,Z,ee,X,ce,he,k,ne)=>{r.ra("ConvTranspose",l,{format:Z?"NHWC":"NCHW",autoPad:f,dilations:[g],group:x,kernel_shape:[O],pads:[H,U],strides:[se],wIsConst:()=>!!Y[ee>>>0],outputPadding:X?Array.from(M.subarray(ce>>>0,ce+X>>>0)):[],outputShape:he?Array.from(M.subarray(k>>>0,k+he>>>0)):[],activation:Re(ne)})},915584:(l,f,g,x,O,H,U,se,Z,ee,X,ce,he,k)=>{r.ra("ConvTranspose",l,{format:se?"NHWC":"NCHW",autoPad:f,dilations:Array.from(M.subarray(g>>>0,g+2>>>0)),group:x,kernelShape:Array.from(M.subarray(O>>>0,O+2>>>0)),pads:Array.from(M.subarray(H>>>0,H+4>>>0)),strides:Array.from(M.subarray(U>>>0,U+2>>>0)),wIsConst:()=>!!Y[Z>>>0],outputPadding:0<ee?Array.from(M.subarray(X>>>0,X+ee>>>0)):[],outputShape:0<ce?Array.from(M.subarray(he>>>0,he+ce>>>0)):[],activation:Re(k)})},916141:(l,f,g,x,O,H,U,se,Z,ee,X,ce,he,k,ne)=>{r.ra("ConvTranspose",l,{format:Z?"NHWC":"NCHW",autoPad:f,dilations:[g],group:x,kernel_shape:[O],pads:[H,U],strides:[se],wIsConst:()=>!!Y[ee>>>0],outputPadding:X?Array.from(M.subarray(ce>>>0,ce+X>>>0)):[],outputShape:he?Array.from(M.subarray(k>>>0,k+he>>>0)):[],activation:Re(ne)})},916555:(l,f,g,x,O,H,U,se,Z,ee,X,ce,he,k)=>{r.ra("ConvTranspose",l,{format:se?"NHWC":"NCHW",autoPad:f,dilations:Array.from(M.subarray(g>>>0,g+2>>>0)),group:x,kernelShape:Array.from(M.subarray(O>>>0,O+2>>>0)),pads:Array.from(M.subarray(H>>>0,H+4>>>0)),strides:Array.from(M.subarray(U>>>0,U+2>>>0)),wIsConst:()=>!!Y[Z>>>0],outputPadding:0<ee?Array.from(M.subarray(X>>>0,X+ee>>>0)):[],outputShape:0<ce?Array.from(M.subarray(he>>>0,he+ce>>>0)):[],activation:Re(k)})},917112:(l,f)=>{r.ra("GlobalAveragePool",l,{format:f?"NHWC":"NCHW"})},917203:(l,f,g,x,O,H,U,se,Z,ee,X,ce,he,k,ne,fe)=>{r.ra("AveragePool",l,{format:fe?"NHWC":"NCHW",auto_pad:f,ceil_mode:g,count_include_pad:x,storage_order:O,dilations:[H,U],kernel_shape:[se,Z],pads:[ee,X,ce,he],strides:[k,ne]})},917487:(l,f)=>{r.ra("GlobalAveragePool",l,{format:f?"NHWC":"NCHW"})},917578:(l,f,g,x,O,H,U,se,Z,ee,X,ce,he,k,ne,fe)=>{r.ra("AveragePool",l,{format:fe?"NHWC":"NCHW",auto_pad:f,ceil_mode:g,count_include_pad:x,storage_order:O,dilations:[H,U],kernel_shape:[se,Z],pads:[ee,X,ce,he],strides:[k,ne]})},917862:(l,f)=>{r.ra("GlobalMaxPool",l,{format:f?"NHWC":"NCHW"})},917949:(l,f,g,x,O,H,U,se,Z,ee,X,ce,he,k,ne,fe)=>{r.ra("MaxPool",l,{format:fe?"NHWC":"NCHW",auto_pad:f,ceil_mode:g,count_include_pad:x,storage_order:O,dilations:[H,U],kernel_shape:[se,Z],pads:[ee,X,ce,he],strides:[k,ne]})},918229:(l,f)=>{r.ra("GlobalMaxPool",l,{format:f?"NHWC":"NCHW"})},918316:(l,f,g,x,O,H,U,se,Z,ee,X,ce,he,k,ne,fe)=>{r.ra("MaxPool",l,{format:fe?"NHWC":"NCHW",auto_pad:f,ceil_mode:g,count_include_pad:x,storage_order:O,dilations:[H,U],kernel_shape:[se,Z],pads:[ee,X,ce,he],strides:[k,ne]})},918596:(l,f,g,x,O)=>{r.ra("Gemm",l,{alpha:f,beta:g,transA:x,transB:O})},918700:l=>{r.ra("MatMul",l,void 0)},918754:(l,f,g,x)=>{r.ra("ArgMax",l,{keepDims:!!f,selectLastIndex:!!g,axis:x})},918862:(l,f,g,x)=>{r.ra("ArgMin",l,{keepDims:!!f,selectLastIndex:!!g,axis:x})},918970:(l,f)=>{r.ra("Softmax",l,{axis:f})},919033:(l,f)=>{r.ra("Concat",l,{axis:f})},919093:(l,f,g,x,O)=>{r.ra("Split",l,{axis:f,numOutputs:g,splitSizes:x?Array.from(M.subarray(O>>>0,O+x>>>0)):[]})},919238:l=>{r.ra("Expand",l,void 0)},919292:(l,f)=>{r.ra("Gather",l,{axis:Number(f)})},919363:(l,f)=>{r.ra("GatherElements",l,{axis:Number(f)})},919442:(l,f,g,x,O,H,U,se,Z,ee,X)=>{r.ra("Resize",l,{antialias:f,axes:g?Array.from(M.subarray(x>>>0,x+g>>>0)):[],coordinateTransformMode:Re(O),cubicCoeffA:H,excludeOutside:U,extrapolationValue:se,keepAspectRatioPolicy:Re(Z),mode:Re(ee),nearestMode:Re(X)})},919793:(l,f,g,x,O,H,U)=>{r.ra("Slice",l,{starts:f?Array.from(M.subarray(g>>>0,g+f>>>0)):[],ends:x?Array.from(M.subarray(O>>>0,O+x>>>0)):[],axes:H?Array.from(M.subarray(U>>>0,U+H>>>0)):[]})},920024:l=>{r.ra("Tile",l,void 0)},920076:(l,f,g)=>{r.ra("LayerNormalization",l,{axis:Number(f),epsilon:Number(g)})},920183:(l,f,g)=>{r.ra("InstanceNormalization",l,{epsilon:f,format:g?"NHWC":"NCHW"})},920297:(l,f,g)=>{r.ra("InstanceNormalization",l,{epsilon:f,format:g?"NHWC":"NCHW"})},920411:l=>{r.ra("Range",l,void 0)},920464:(l,f)=>{r.ra("Einsum",l,{equation:Re(f)})},920545:(l,f,g,x,O)=>{r.ra("Pad",l,{mode:f,value:g,pads:x?Array.from(M.subarray(O>>>0,O+x>>>0)):[]})},920677:(l,f,g,x,O,H,U,se,Z)=>{r.ra("Attention",l,{numHeads:f,isUnidirectional:g,maskFilterValue:x,scale:O,doRotary:H,qkvHiddenSizes:U?Array.from(M.subarray(Number(se)>>>0,Number(se)+U>>>0)):[],pastPresentShareBuffer:!!Z})},920949:l=>{r.ra("Gelu",l,void 0)},921001:(l,f,g,x,O,H)=>{r.ra("MultiHeadAttention",l,{numHeads:f,isUnidirectional:g,maskFilterValue:x,scale:O,doRotary:H})},921160:l=>{r.ra("BiasAdd",l,void 0)},921215:l=>{r.ra("BiasSplitGelu",l,void 0)},921276:(l,f)=>{r.ra("SkipLayerNormalization",l,{epsilon:f})},921357:(l,f,g,x,O,H,U,se,Z,ee,X,ce,he)=>{r.ra("Conv",l,{format:Z?"NHWC":"NCHW",auto_pad:f,dilations:[g],group:x,kernel_shape:[O],pads:H?Array.from(M.subarray(U>>>0,U+H>>>0)):[],strides:[se],w_is_const:()=>!!Y[ee>>>0],activation:Re(X),activation_params:ce?Array.from(Se.subarray(he>>>0,he+ce>>>0)):[]})},921738:(l,f,g,x,O,H,U,se,Z,ee,X,ce,he,k,ne,fe)=>{r.ra("Conv",l,{format:ce?"NHWC":"NCHW",auto_pad:f,dilations:[g,x],group:O,kernel_shape:[H,U],pads:se?Array.from(M.subarray(Z>>>0,Z+se>>>0)):[],strides:[ee,X],w_is_const:()=>!!Y[he>>>0],activation:Re(k),activation_params:ne?Array.from(Se.subarray(fe>>>0,fe+ne>>>0)):[]})},922140:l=>{r.Ra(l)},922174:(l,f)=>r.Sa(l,f,r.Da.Ta,r.Da.errors),922286:l=>r.Oa(l),922319:l=>r.Qa(l),922351:(l,f,g)=>{r.Ja(l,f,g,!0)},922390:(l,f,g)=>{r.Ja(l,f,g)}};function qe(l){this.name="ExitStatus",this.message=`Program terminated with exit(${l})`,this.status=l}var $t=l=>{for(;0<l.length;)l.shift()(r)};function St(l){this.Ha=l-24,this.Ma=function(f){K[this.Ha+4>>2>>>0]=f},this.La=function(f){K[this.Ha+8>>2>>>0]=f},this.Ya=function(f,g){this.Ka(),this.Ma(f),this.La(g)},this.Ka=function(){K[this.Ha+16>>2>>>0]=0}}var Vt=0,pr=0,Xe=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Nt=(l,f,g)=>{f>>>=0;var x=f+g;for(g=f;l[g]&&!(g>=x);)++g;if(16<g-f&&l.buffer&&Xe)return Xe.decode(l.subarray(f,g));for(x="";f<g;){var O=l[f++];if(O&128){var H=l[f++]&63;if((O&224)==192)x+=String.fromCharCode((O&31)<<6|H);else{var U=l[f++]&63;O=(O&240)==224?(O&15)<<12|H<<6|U:(O&7)<<18|H<<12|U<<6|l[f++]&63,65536>O?x+=String.fromCharCode(O):(O-=65536,x+=String.fromCharCode(55296|O>>10,56320|O&1023))}}else x+=String.fromCharCode(O)}return x},Re=(l,f)=>(l>>>=0)?Nt(ae,l,f):"",Ot=l=>{for(var f=0,g=0;g<l.length;++g){var x=l.charCodeAt(g);127>=x?f++:2047>=x?f+=2:55296<=x&&57343>=x?(f+=4,++g):f+=3}return f},Ut=(l,f,g,x)=>{if(g>>>=0,!(0<x))return 0;var O=g;x=g+x-1;for(var H=0;H<l.length;++H){var U=l.charCodeAt(H);if(55296<=U&&57343>=U){var se=l.charCodeAt(++H);U=65536+((U&1023)<<10)|se&1023}if(127>=U){if(g>=x)break;f[g++>>>0]=U}else{if(2047>=U){if(g+1>=x)break;f[g++>>>0]=192|U>>6}else{if(65535>=U){if(g+2>=x)break;f[g++>>>0]=224|U>>12}else{if(g+3>=x)break;f[g++>>>0]=240|U>>18,f[g++>>>0]=128|U>>12&63}f[g++>>>0]=128|U>>6&63}f[g++>>>0]=128|U&63}}return f[g>>>0]=0,g-O},ct=l=>l%4===0&&(l%100!==0||l%400===0),fr=[0,31,60,91,121,152,182,213,244,274,305,335],pt=[0,31,59,90,120,151,181,212,243,273,304,334],kt=l=>{var f=Ot(l)+1,g=Mt(f);return g&&Ut(l,ae,g,f),g},gt=[],Pt=(l,f)=>{gt.length=0;var g;for(f>>=2;g=ae[l++>>>0];)f+=g!=105&f,gt.push(g==105?M[f>>>0]:ue[f++>>>1]),++f;return gt},Rt={},Ht=()=>{if(!Bt){var l={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:u||"./this.program"},f;for(f in Rt)Rt[f]===void 0?delete l[f]:l[f]=Rt[f];var g=[];for(f in l)g.push(`${f}=${l[f]}`);Bt=g}return Bt},Bt,mr=[null,[],[]],Ve=[31,29,31,30,31,30,31,31,30,31,30,31],Gt=[31,28,31,30,31,30,31,31,30,31,30,31];function Lt(l){var f=Array(Ot(l)+1);return Ut(l,f,0,f.length),f}function ie(l,f,g,x){function O(k,ne,fe){for(k=typeof k=="number"?k.toString():k||"";k.length<ne;)k=fe[0]+k;return k}function H(k,ne){return O(k,ne,"0")}function U(k,ne){function fe(tr){return 0>tr?-1:0<tr?1:0}var mt;return(mt=fe(k.getFullYear()-ne.getFullYear()))===0&&(mt=fe(k.getMonth()-ne.getMonth()))===0&&(mt=fe(k.getDate()-ne.getDate())),mt}function se(k){switch(k.getDay()){case 0:return new Date(k.getFullYear()-1,11,29);case 1:return k;case 2:return new Date(k.getFullYear(),0,3);case 3:return new Date(k.getFullYear(),0,2);case 4:return new Date(k.getFullYear(),0,1);case 5:return new Date(k.getFullYear()-1,11,31);case 6:return new Date(k.getFullYear()-1,11,30)}}function Z(k){var ne=k.Ba;for(k=new Date(new Date(k.Ca+1900,0,1).getTime());0<ne;){var fe=k.getMonth(),mt=(ct(k.getFullYear())?Ve:Gt)[fe];if(ne>mt-k.getDate())ne-=mt-k.getDate()+1,k.setDate(1),11>fe?k.setMonth(fe+1):(k.setMonth(0),k.setFullYear(k.getFullYear()+1));else{k.setDate(k.getDate()+ne);break}}return fe=new Date(k.getFullYear()+1,0,4),ne=se(new Date(k.getFullYear(),0,4)),fe=se(fe),0>=U(ne,k)?0>=U(fe,k)?k.getFullYear()+1:k.getFullYear():k.getFullYear()-1}l>>>=0,f>>>=0,g>>>=0,x>>>=0;var ee=M[x+40>>2>>>0];x={Wa:M[x>>2>>>0],Va:M[x+4>>2>>>0],Ea:M[x+8>>2>>>0],Ia:M[x+12>>2>>>0],Fa:M[x+16>>2>>>0],Ca:M[x+20>>2>>>0],wa:M[x+24>>2>>>0],Ba:M[x+28>>2>>>0],$a:M[x+32>>2>>>0],Ua:M[x+36>>2>>>0],Xa:ee?Re(ee):""},g=Re(g),ee={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var X in ee)g=g.replace(new RegExp(X,"g"),ee[X]);var ce="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),he="January February March April May June July August September October November December".split(" ");ee={"%a":k=>ce[k.wa].substring(0,3),"%A":k=>ce[k.wa],"%b":k=>he[k.Fa].substring(0,3),"%B":k=>he[k.Fa],"%C":k=>H((k.Ca+1900)/100|0,2),"%d":k=>H(k.Ia,2),"%e":k=>O(k.Ia,2," "),"%g":k=>Z(k).toString().substring(2),"%G":k=>Z(k),"%H":k=>H(k.Ea,2),"%I":k=>(k=k.Ea,k==0?k=12:12<k&&(k-=12),H(k,2)),"%j":k=>{for(var ne=0,fe=0;fe<=k.Fa-1;ne+=(ct(k.Ca+1900)?Ve:Gt)[fe++]);return H(k.Ia+ne,3)},"%m":k=>H(k.Fa+1,2),"%M":k=>H(k.Va,2),"%n":()=>`\n`,"%p":k=>0<=k.Ea&&12>k.Ea?"AM":"PM","%S":k=>H(k.Wa,2),"%t":()=>"	","%u":k=>k.wa||7,"%U":k=>H(Math.floor((k.Ba+7-k.wa)/7),2),"%V":k=>{var ne=Math.floor((k.Ba+7-(k.wa+6)%7)/7);if(2>=(k.wa+371-k.Ba-2)%7&&ne++,ne)ne==53&&(fe=(k.wa+371-k.Ba)%7,fe==4||fe==3&&ct(k.Ca)||(ne=1));else{ne=52;var fe=(k.wa+7-k.Ba-1)%7;(fe==4||fe==5&&ct(k.Ca%400-1))&&ne++}return H(ne,2)},"%w":k=>k.wa,"%W":k=>H(Math.floor((k.Ba+7-(k.wa+6)%7)/7),2),"%y":k=>(k.Ca+1900).toString().substring(2),"%Y":k=>k.Ca+1900,"%z":k=>{k=k.Ua;var ne=0<=k;return k=Math.abs(k)/60,(ne?"+":"-")+("0000"+(k/60*100+k%60)).slice(-4)},"%Z":k=>k.Xa,"%%":()=>"%"},g=g.replace(/%%/g,"\\0\\0");for(X in ee)g.includes(X)&&(g=g.replace(new RegExp(X,"g"),ee[X](x)));return g=g.replace(/\\0\\0/g,"%"),X=Lt(g),X.length>f?0:(Y.set(X,l>>>0),X.length-1)}function ft(l){try{l()}catch(f){je(f)}}function hr(l){var f={},g;for(g in l)(function(x){var O=l[x];f[x]=typeof O=="function"?function(){xt.push(x);try{return O.apply(null,arguments)}finally{W||(xt.pop()===x||je(),Ke&&nt===1&&xt.length===0&&(nt=0,ft(Jt),typeof Fibers<"u"&&Fibers.ab()))}}:O})(g);return f}var nt=0,Ke=null,gr=0,xt=[],Ft={},jt={},yr=0,Ct=null,br=[];function wr(){return new Promise((l,f)=>{Ct={resolve:l,reject:f}})}function vr(){var l=Mt(65548),f=l+12;K[l>>2>>>0]=f,K[l+4>>2>>>0]=f+65536,f=xt[0];var g=Ft[f];return g===void 0&&(g=yr++,Ft[f]=g,jt[g]=f),M[l+8>>2>>>0]=g,l}function $r(l){if(!W){if(nt===0){var f=!1,g=!1;l((x=0)=>{if(!W&&(gr=x,f=!0,g)){nt=2,ft(()=>Dt(Ke)),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.resume(),x=!1;try{var O=(0,E[jt[M[Ke+8>>2>>>0]]])()}catch(se){O=se,x=!0}var H=!1;if(!Ke){var U=Ct;U&&(Ct=null,(x?U.reject:U.resolve)(O),H=!0)}if(x&&!H)throw O}}),g=!0,f||(nt=1,Ke=vr(),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.pause(),ft(()=>Qt(Ke)))}else nt===2?(nt=0,ft(It),qt(Ke),Ke=null,br.forEach(x=>{if(!W)try{if(x(),!_)try{V=V=x=V,_||(r.onExit&&r.onExit(x),W=!0),d(x,new qe(x))}catch(O){O instanceof qe||O=="unwind"||d(1,O)}}catch(O){O instanceof qe||O=="unwind"||d(1,O)}})):je(`invalid state: ${nt}`);return gr}}function Sr(l){return $r(f=>{l().then(f)})}var xr={n:function(l,f,g){return Sr(async()=>{await r.Pa(l,f,g)})},a:function(l,f,g){throw l>>>=0,new St(l).Ya(f>>>0,g>>>0),Vt=l,pr++,Vt},g:function(){return 0},J:function(){},z:function(){},B:function(){},L:function(){return 0},H:function(){},C:function(){},G:function(){},l:function(){},A:function(){},x:function(){},I:function(){},y:function(){},m:()=>!0,q:function(l,f,g){l=f+2097152>>>0<4194305-!!l?(l>>>0)+4294967296*f:NaN,g>>>=0,l=new Date(1e3*l),M[g>>2>>>0]=l.getUTCSeconds(),M[g+4>>2>>>0]=l.getUTCMinutes(),M[g+8>>2>>>0]=l.getUTCHours(),M[g+12>>2>>>0]=l.getUTCDate(),M[g+16>>2>>>0]=l.getUTCMonth(),M[g+20>>2>>>0]=l.getUTCFullYear()-1900,M[g+24>>2>>>0]=l.getUTCDay(),M[g+28>>2>>>0]=(l.getTime()-Date.UTC(l.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(l,f,g){l=f+2097152>>>0<4194305-!!l?(l>>>0)+4294967296*f:NaN,g>>>=0,l=new Date(1e3*l),M[g>>2>>>0]=l.getSeconds(),M[g+4>>2>>>0]=l.getMinutes(),M[g+8>>2>>>0]=l.getHours(),M[g+12>>2>>>0]=l.getDate(),M[g+16>>2>>>0]=l.getMonth(),M[g+20>>2>>>0]=l.getFullYear()-1900,M[g+24>>2>>>0]=l.getDay(),M[g+28>>2>>>0]=(ct(l.getFullYear())?fr:pt)[l.getMonth()]+l.getDate()-1|0,M[g+36>>2>>>0]=-(60*l.getTimezoneOffset()),f=new Date(l.getFullYear(),6,1).getTimezoneOffset();var x=new Date(l.getFullYear(),0,1).getTimezoneOffset();M[g+32>>2>>>0]=(f!=x&&l.getTimezoneOffset()==Math.min(x,f))|0},s:function(l){l>>>=0;var f=new Date(M[l+20>>2>>>0]+1900,M[l+16>>2>>>0],M[l+12>>2>>>0],M[l+8>>2>>>0],M[l+4>>2>>>0],M[l>>2>>>0],0),g=M[l+32>>2>>>0],x=f.getTimezoneOffset(),O=new Date(f.getFullYear(),6,1).getTimezoneOffset(),H=new Date(f.getFullYear(),0,1).getTimezoneOffset(),U=Math.min(H,O);return 0>g?M[l+32>>2>>>0]=+(O!=H&&U==x):0<g!=(U==x)&&(O=Math.max(H,O),f.setTime(f.getTime()+6e4*((0<g?U:O)-x))),M[l+24>>2>>>0]=f.getDay(),M[l+28>>2>>>0]=(ct(f.getFullYear())?fr:pt)[f.getMonth()]+f.getDate()-1|0,M[l>>2>>>0]=f.getSeconds(),M[l+4>>2>>>0]=f.getMinutes(),M[l+8>>2>>>0]=f.getHours(),M[l+12>>2>>>0]=f.getDate(),M[l+16>>2>>>0]=f.getMonth(),M[l+20>>2>>>0]=f.getYear(),l=f.getTime()/1e3,Kt((He=l,1<=+Math.abs(He)?0<He?+Math.floor(He/4294967296)>>>0:~~+Math.ceil((He-+(~~He>>>0))/4294967296)>>>0:0)),l>>>0},o:function(){return-52},p:function(){},v:function(l,f,g){function x(Z){return(Z=Z.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?Z[1]:"GMT"}g>>>=0;var O=new Date().getFullYear(),H=new Date(O,0,1),U=new Date(O,6,1);O=H.getTimezoneOffset();var se=U.getTimezoneOffset();K[l>>>0>>2>>>0]=60*Math.max(O,se),M[f>>>0>>2>>>0]=+(O!=se),l=x(H),f=x(U),l=kt(l),f=kt(f),se<O?(K[g>>2>>>0]=l,K[g+4>>2>>>0]=f):(K[g>>2>>>0]=f,K[g+4>>2>>>0]=l)},e:()=>{je("")},b:function(l,f,g){return l>>>=0,f=Pt(f>>>0,g>>>0),rt[l].apply(null,f)},i:function(l,f,g){return l>>>=0,f=Pt(f>>>0,g>>>0),rt[l].apply(null,f)},h:function(){return Date.now()},w:function(){return 4294901760},c:()=>performance.now(),K:function(l,f,g){return f>>>=0,ae.copyWithin(l>>>0>>>0,f>>>0,f+(g>>>0)>>>0)},u:function(l){l>>>=0;var f=ae.length;if(4294901760<l)return!1;for(var g=1;4>=g;g*=2){var x=f*(1+.2/g);x=Math.min(x,l+100663296);var O=Math;x=Math.max(l,x);e:{O=O.min.call(O,4294901760,x+(65536-x%65536)%65536)-R.buffer.byteLength+65535>>>16;try{R.grow(O),ve();var H=1;break e}catch{}H=void 0}if(H)return!0}return!1},D:function(l,f){l>>>=0,f>>>=0;var g=0;return Ht().forEach(function(x,O){var H=f+g;for(O=K[l+4*O>>2>>>0]=H,H=0;H<x.length;++H)Y[O++>>0>>>0]=x.charCodeAt(H);Y[O>>0>>>0]=0,g+=x.length+1}),0},E:function(l,f){l>>>=0,f>>>=0;var g=Ht();K[l>>2>>>0]=g.length;var x=0;return g.forEach(function(O){x+=O.length+1}),K[f>>2>>>0]=x,0},f:()=>52,k:function(){return 52},t:function(){return 70},j:function(l,f,g,x){f>>>=0,g>>>=0,x>>>=0;for(var O=0,H=0;H<g;H++){var U=K[f>>2>>>0],se=K[f+4>>2>>>0];f+=8;for(var Z=0;Z<se;Z++){var ee=ae[U+Z>>>0],X=mr[l];ee===0||ee===10?((l===1?A:I)(Nt(X,0)),X.length=0):X.push(ee)}O+=se}return K[x>>2>>>0]=O,0},F:ie,d:function(l,f,g,x){return ie(l>>>0,f>>>0,g>>>0,x>>>0)}};(function(){function l(g){if(g=g.exports,g=hr(g),E=g=yt(g),R=E.M,ve(),xe.unshift(E.N),Ce--,r.monitorRunDependencies&&r.monitorRunDependencies(Ce),Ce==0&&(ht!==null&&(clearInterval(ht),ht=null),Le)){var x=Le;Le=null,x()}return g}var f={a:xr};if(Ce++,r.monitorRunDependencies&&r.monitorRunDependencies(Ce),r.instantiateWasm)try{return r.instantiateWasm(f,l)}catch(g){I("Module.instantiateWasm callback failed with error: "+g),n(g)}return Me(f,function(g){l(g.instance)}).catch(n),{}})(),r._OrtInit=(l,f)=>(r._OrtInit=E.O)(l,f),r._OrtGetLastError=(l,f)=>(r._OrtGetLastError=E.P)(l,f),r._OrtCreateSessionOptions=(l,f,g,x,O,H,U,se,Z,ee)=>(r._OrtCreateSessionOptions=E.Q)(l,f,g,x,O,H,U,se,Z,ee),r._OrtAppendExecutionProvider=(l,f)=>(r._OrtAppendExecutionProvider=E.R)(l,f),r._OrtAddFreeDimensionOverride=(l,f,g)=>(r._OrtAddFreeDimensionOverride=E.S)(l,f,g),r._OrtAddSessionConfigEntry=(l,f,g)=>(r._OrtAddSessionConfigEntry=E.T)(l,f,g),r._OrtReleaseSessionOptions=l=>(r._OrtReleaseSessionOptions=E.U)(l),r._OrtCreateSession=(l,f,g)=>(r._OrtCreateSession=E.V)(l,f,g),r._OrtReleaseSession=l=>(r._OrtReleaseSession=E.W)(l),r._OrtGetInputOutputCount=(l,f,g)=>(r._OrtGetInputOutputCount=E.X)(l,f,g),r._OrtGetInputName=(l,f)=>(r._OrtGetInputName=E.Y)(l,f),r._OrtGetOutputName=(l,f)=>(r._OrtGetOutputName=E.Z)(l,f),r._OrtFree=l=>(r._OrtFree=E._)(l),r._OrtCreateTensor=(l,f,g,x,O,H)=>(r._OrtCreateTensor=E.$)(l,f,g,x,O,H),r._OrtGetTensorData=(l,f,g,x,O)=>(r._OrtGetTensorData=E.aa)(l,f,g,x,O),r._OrtReleaseTensor=l=>(r._OrtReleaseTensor=E.ba)(l),r._OrtCreateRunOptions=(l,f,g,x)=>(r._OrtCreateRunOptions=E.ca)(l,f,g,x),r._OrtAddRunConfigEntry=(l,f,g)=>(r._OrtAddRunConfigEntry=E.da)(l,f,g),r._OrtReleaseRunOptions=l=>(r._OrtReleaseRunOptions=E.ea)(l),r._OrtCreateBinding=l=>(r._OrtCreateBinding=E.fa)(l),r._OrtBindInput=(l,f,g)=>(r._OrtBindInput=E.ga)(l,f,g),r._OrtBindOutput=(l,f,g,x)=>(r._OrtBindOutput=E.ha)(l,f,g,x),r._OrtClearBoundOutputs=l=>(r._OrtClearBoundOutputs=E.ia)(l),r._OrtReleaseBinding=l=>(r._OrtReleaseBinding=E.ja)(l),r._OrtRunWithBinding=(l,f,g,x,O)=>(r._OrtRunWithBinding=E.ka)(l,f,g,x,O),r._OrtRun=(l,f,g,x,O,H,U,se)=>(r._OrtRun=E.la)(l,f,g,x,O,H,U,se),r._OrtEndProfiling=l=>(r._OrtEndProfiling=E.ma)(l),r._JsepOutput=(l,f,g)=>(r._JsepOutput=E.na)(l,f,g),r._JsepGetNodeName=l=>(r._JsepGetNodeName=E.oa)(l);var Mt=r._malloc=l=>(Mt=r._malloc=E.pa)(l),qt=r._free=l=>(qt=r._free=E.qa)(l),Kt=l=>(Kt=E.sa)(l),Yt=()=>(Yt=E.ta)(),Zt=l=>(Zt=E.ua)(l),Xt=l=>(Xt=E.va)(l),Qt=l=>(Qt=E.xa)(l),Jt=()=>(Jt=E.ya)(),Dt=l=>(Dt=E.za)(l),It=()=>(It=E.Aa)();r.___start_em_js=922423,r.___stop_em_js=922584;function yt(l){l=Object.assign({},l);var f=x=>()=>x()>>>0,g=x=>O=>x(O)>>>0;return l.__errno_location=f(l.__errno_location),l.malloc=g(l.malloc),l.stackSave=f(l.stackSave),l.stackAlloc=g(l.stackAlloc),l}r.stackAlloc=Xt,r.stackSave=Yt,r.stackRestore=Zt,r.UTF8ToString=Re,r.stringToUTF8=(l,f,g)=>Ut(l,ae,f,g),r.lengthBytesUTF8=Ot;var At;Le=function l(){At||er(),At||(Le=l)};function er(){function l(){if(!At&&(At=!0,r.calledRun=!0,!W)){if($t(xe),o(r),r.onRuntimeInitialized&&r.onRuntimeInitialized(),r.postRun)for(typeof r.postRun=="function"&&(r.postRun=[r.postRun]);r.postRun.length;){var f=r.postRun.shift();Pe.unshift(f)}$t(Pe)}}if(!(0<Ce)){if(r.preRun)for(typeof r.preRun=="function"&&(r.preRun=[r.preRun]);r.preRun.length;)_e();$t(j),0<Ce||(r.setStatus?(r.setStatus("Running..."),setTimeout(function(){setTimeout(function(){r.setStatus("")},1),l()},1)):l())}}if(r.preInit)for(typeof r.preInit=="function"&&(r.preInit=[r.preInit]);0<r.preInit.length;)r.preInit.pop()();return er(),t.ready}})();typeof co=="object"&&typeof fn=="object"?fn.exports=lo:typeof define=="function"&&define.amd&&define([],()=>lo)});var fo=rr(()=>{});var mo=rr(()=>{});var ho={};Er(ho,{cpus:()=>Du});var Du,go=F(()=>{Du=void 0});var wo=rr((bo,mn)=>{"use strict";var yo=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){function r(){return ve.buffer!=Ce.buffer&&pe(),Ce}function o(){return ve.buffer!=Ce.buffer&&pe(),ht}function n(){return ve.buffer!=Ce.buffer&&pe(),Le}function s(){return ve.buffer!=Ce.buffer&&pe(),je}function u(){return ve.buffer!=Ce.buffer&&pe(),L}function d(){return ve.buffer!=Ce.buffer&&pe(),de}var a=t,p,h;a.ready=new Promise((i,c)=>{p=i,h=c}),a.jsepInit=(i,c,m,$,T,D,N,te)=>{a.Qb=i,a.wb=c,a.yb=m,a.jb=$,a.xb=T,a.Ea=D,a.zb=N,a.Ab=te,c=(Q,J,oe)=>(...ge)=>{let we=ot,P=J?.();ge=Q(...ge);let le=J?.();return P!==le&&(Q=le,oe(P),J=oe=null),ot!=we?Su():ge},m=Q=>async(...J)=>{try{if(a.bb)throw Error("Session already started");let oe=a.bb={Fb:J[0],errors:[]},ge=await Q(...J);if(a.bb!==oe)throw Error("Session mismatch");i.flush();let we=oe.errors;if(0<we.length){let P=await Promise.all(we);if(P=P.filter(le=>le),0<P.length)throw Error(P.join(`\n`))}return ge}finally{a.bb=null}},a._OrtRun=m(c(a._OrtRun,()=>a._OrtRun,Q=>a._OrtRun=Q)),a._OrtRunWithBinding=m(c(a._OrtRunWithBinding,()=>a._OrtRunWithBinding,Q=>a._OrtRunWithBinding=Q)),a._OrtBindInput=c(a._OrtBindInput,()=>a._OrtBindInput,Q=>a._OrtBindInput=Q),a.jsepRegisterBuffer=(Q,J,oe,ge)=>i.registerBuffer(Q,J,oe,ge),a.jsepUnregisterBuffers=Q=>{i.unregisterBuffers(Q)},a.jsepGetBuffer=Q=>i.getBuffer(Q),a.jsepCreateDownloader=(Q,J,oe)=>i.createDownloader(Q,J,oe)};var v=Object.assign({},a),y="./this.program",b=(i,c)=>{throw c},w=typeof window=="object",S=typeof importScripts=="function",C=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",A=a.ENVIRONMENT_IS_PTHREAD||!1,I="";function B(i){return a.locateFile?a.locateFile(i,I):I+i}var _,R,E;if(C){var W=(dn(),zt(ln)),V=(pn(),zt(cn));I=S?V.dirname(I)+"/":__dirname+"/",_=(c,m)=>(c=c.startsWith("file://")?new URL(c):V.normalize(c),W.readFileSync(c,m?void 0:"utf8")),E=c=>(c=_(c,!0),c.buffer||(c=new Uint8Array(c)),c),R=(c,m,$,T=!0)=>{c=c.startsWith("file://")?new URL(c):V.normalize(c),W.readFile(c,T?void 0:"utf8",(D,N)=>{D?$(D):m(T?N.buffer:N)})},!a.thisProgram&&1<process.argv.length&&(y=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),b=(c,m)=>{throw process.exitCode=c,m},a.inspect=()=>"[Emscripten Module object]";let i;try{i=fo()}catch(c){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),c}global.Worker=i.Worker}else(w||S)&&(S?I=self.location.href:typeof document<"u"&&document.currentScript&&(I=document.currentScript.src),typeof e<"u"&&e&&(I=e),I.indexOf("blob:")!==0?I=I.substr(0,I.replace(/[?#].*/,"").lastIndexOf("/")+1):I="",C||(_=i=>{var c=new XMLHttpRequest;return c.open("GET",i,!1),c.send(null),c.responseText},S&&(E=i=>{var c=new XMLHttpRequest;return c.open("GET",i,!1),c.responseType="arraybuffer",c.send(null),new Uint8Array(c.response)}),R=(i,c,m)=>{var $=new XMLHttpRequest;$.open("GET",i,!0),$.responseType="arraybuffer",$.onload=()=>{$.status==200||$.status==0&&$.response?c($.response):m()},$.onerror=m,$.send(null)}));C&&typeof performance>"u"&&(global.performance=mo().performance);var Y=console.log.bind(console),ae=console.error.bind(console);C&&(Y=(...i)=>W.writeSync(1,i.join(" ")+`\n`),ae=(...i)=>W.writeSync(2,i.join(" ")+`\n`));var M=a.print||Y,K=a.printErr||ae;Object.assign(a,v),v=null,a.thisProgram&&(y=a.thisProgram),a.quit&&(b=a.quit);var Se;a.wasmBinary&&(Se=a.wasmBinary);var ue=a.noExitRuntime||!0;typeof WebAssembly!="object"&&Xe("no native wasm support detected");var ve,j,xe,Pe=!1,_e,Ce,ht,Le,je,L,de;function pe(){var i=ve.buffer;a.HEAP8=Ce=new Int8Array(i),a.HEAP16=new Int16Array(i),a.HEAP32=Le=new Int32Array(i),a.HEAPU8=ht=new Uint8Array(i),a.HEAPU16=new Uint16Array(i),a.HEAPU32=je=new Uint32Array(i),a.HEAPF32=L=new Float32Array(i),a.HEAPF64=de=new Float64Array(i)}var We=a.INITIAL_MEMORY||16777216;if(5242880<=We||Xe("INITIAL_MEMORY should be larger than STACK_SIZE, was "+We+"! (STACK_SIZE=5242880)"),A)ve=a.wasmMemory;else if(a.wasmMemory)ve=a.wasmMemory;else if(ve=new WebAssembly.Memory({initial:We/65536,maximum:65536,shared:!0}),!(ve.buffer instanceof SharedArrayBuffer))throw K("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),C&&K("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");pe(),We=ve.buffer.byteLength;var Fe=[],Oe=[],Me=[],He=0;function rt(){return ue||0<He}var qe=0,$t=null,St=null;function Vt(){qe++,a.monitorRunDependencies&&a.monitorRunDependencies(qe)}function pr(){if(qe--,a.monitorRunDependencies&&a.monitorRunDependencies(qe),qe==0&&($t!==null&&(clearInterval($t),$t=null),St)){var i=St;St=null,i()}}function Xe(i){throw a.onAbort&&a.onAbort(i),i="Aborted("+i+")",K(i),Pe=!0,_e=1,i=new WebAssembly.RuntimeError(i+". Build with -sASSERTIONS for more info."),h(i),i}function Nt(i){return i.startsWith("data:application/octet-stream;base64,")}var Re;Re="ort-wasm-simd-threaded.wasm",Nt(Re)||(Re=B(Re));function Ot(i){if(i==Re&&Se)return new Uint8Array(Se);if(E)return E(i);throw"both async and sync fetching of the wasm failed"}function Ut(i){if(!Se&&(w||S)){if(typeof fetch=="function"&&!i.startsWith("file://"))return fetch(i,{credentials:"same-origin"}).then(c=>{if(!c.ok)throw"failed to load wasm binary file at \'"+i+"\'";return c.arrayBuffer()}).catch(()=>Ot(i));if(R)return new Promise((c,m)=>{R(i,$=>c(new Uint8Array($)),m)})}return Promise.resolve().then(()=>Ot(i))}function ct(i,c,m){return Ut(i).then($=>WebAssembly.instantiate($,c)).then($=>$).then(m,$=>{K("failed to asynchronously prepare wasm: "+$),Xe($)})}function fr(i,c){var m=Re;return Se||typeof WebAssembly.instantiateStreaming!="function"||Nt(m)||m.startsWith("file://")||C||typeof fetch!="function"?ct(m,i,c):fetch(m,{credentials:"same-origin"}).then($=>WebAssembly.instantiateStreaming($,i).then(c,function(T){return K("wasm streaming compile failed: "+T),K("falling back to ArrayBuffer instantiation"),ct(m,i,c)}))}var pt,kt={1425328:i=>{a.Ea("Abs",i,void 0)},1425379:i=>{a.Ea("Neg",i,void 0)},1425430:i=>{a.Ea("Floor",i,void 0)},1425483:i=>{a.Ea("Ceil",i,void 0)},1425535:i=>{a.Ea("Reciprocal",i,void 0)},1425593:i=>{a.Ea("Sqrt",i,void 0)},1425645:i=>{a.Ea("Exp",i,void 0)},1425696:i=>{a.Ea("Erf",i,void 0)},1425747:i=>{a.Ea("Sigmoid",i,void 0)},1425802:i=>{a.Ea("Log",i,void 0)},1425853:i=>{a.Ea("Sin",i,void 0)},1425904:i=>{a.Ea("Cos",i,void 0)},1425955:i=>{a.Ea("Tan",i,void 0)},1426006:i=>{a.Ea("Asin",i,void 0)},1426058:i=>{a.Ea("Acos",i,void 0)},1426110:i=>{a.Ea("Atan",i,void 0)},1426162:i=>{a.Ea("Sinh",i,void 0)},1426214:i=>{a.Ea("Cosh",i,void 0)},1426266:i=>{a.Ea("Asinh",i,void 0)},1426319:i=>{a.Ea("Acosh",i,void 0)},1426372:i=>{a.Ea("Atanh",i,void 0)},1426425:i=>{a.Ea("Tanh",i,void 0)},1426477:i=>{a.Ea("Not",i,void 0)},1426528:(i,c,m)=>{a.Ea("Clip",i,{min:c,max:m})},1426597:i=>{a.Ea("Clip",i,void 0)},1426649:(i,c)=>{a.Ea("Elu",i,{alpha:c})},1426707:i=>{a.Ea("Relu",i,void 0)},1426759:(i,c)=>{a.Ea("LeakyRelu",i,{alpha:c})},1426823:(i,c)=>{a.Ea("ThresholdedRelu",i,{alpha:c})},1426893:i=>{a.zb(i)},1426927:(i,c)=>a.Ab(i,c,a.bb.Fb,a.bb.errors),1427039:(i,c)=>{a.Ea("Cast",i,{to:c})},1427097:i=>{a.Ea("Add",i,void 0)},1427148:i=>{a.Ea("Sub",i,void 0)},1427199:i=>{a.Ea("Mul",i,void 0)},1427250:i=>{a.Ea("Div",i,void 0)},1427301:i=>{a.Ea("Pow",i,void 0)},1427352:i=>{a.Ea("Equal",i,void 0)},1427405:i=>{a.Ea("Greater",i,void 0)},1427460:i=>{a.Ea("GreaterOrEqual",i,void 0)},1427522:i=>{a.Ea("Less",i,void 0)},1427574:i=>{a.Ea("LessOrEqual",i,void 0)},1427633:(i,c,m,$,T)=>{a.Ea("ReduceMean",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:$?Array.from(n().subarray(T>>>0,T+$>>>0)):[]})},1427797:(i,c,m,$,T)=>{a.Ea("ReduceMax",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:$?Array.from(n().subarray(T>>>0,T+$>>>0)):[]})},1427960:(i,c,m,$,T)=>{a.Ea("ReduceMin",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:$?Array.from(n().subarray(T>>>0,T+$>>>0)):[]})},1428123:(i,c,m,$,T)=>{a.Ea("ReduceProd",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:$?Array.from(n().subarray(T>>>0,T+$>>>0)):[]})},1428287:(i,c,m,$,T)=>{a.Ea("ReduceSum",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:$?Array.from(n().subarray(T>>>0,T+$>>>0)):[]})},1428450:(i,c,m,$,T)=>{a.Ea("ReduceL1",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:$?Array.from(n().subarray(T>>>0,T+$>>>0)):[]})},1428612:(i,c,m,$,T)=>{a.Ea("ReduceL2",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:$?Array.from(n().subarray(T>>>0,T+$>>>0)):[]})},1428774:(i,c,m,$,T)=>{a.Ea("ReduceLogSum",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:$?Array.from(n().subarray(T>>>0,T+$>>>0)):[]})},1428940:(i,c,m,$,T)=>{a.Ea("ReduceSumSquare",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:$?Array.from(n().subarray(T>>>0,T+$>>>0)):[]})},1429109:(i,c,m,$,T)=>{a.Ea("ReduceLogSumExp",i,{keepDims:!!c,noopWithEmptyAxes:!!m,axes:$?Array.from(n().subarray(T>>>0,T+$>>>0)):[]})},1429278:i=>{a.Ea("Where",i,void 0)},1429331:(i,c,m)=>{a.Ea("Transpose",i,{perm:c?Array.from(n().subarray(m>>>0,m+c>>>0)):[]})},1429444:(i,c,m,$,T,D,N,te,Q,J,oe,ge,we)=>{a.Ea("Conv",i,{format:Q?"NHWC":"NCHW",auto_pad:c,dilations:[m],group:$,kernel_shape:[T],pads:D?Array.from(n().subarray(N>>>0,N+D>>>0)):[],strides:[te],w_is_const:()=>!!r()[J>>>0],activation:Ve(oe),activation_params:ge?Array.from(u().subarray(we>>>0,we+ge>>>0)):[]})},1429825:(i,c,m,$,T,D,N,te,Q,J,oe,ge,we,P,le,ye)=>{a.Ea("Conv",i,{format:ge?"NHWC":"NCHW",auto_pad:c,dilations:[m,$],group:T,kernel_shape:[D,N],pads:te?Array.from(n().subarray(Q>>>0,Q+te>>>0)):[],strides:[J,oe],w_is_const:()=>!!r()[we>>>0],activation:Ve(P),activation_params:le?Array.from(u().subarray(ye>>>0,ye+le>>>0)):[]})},1430227:(i,c,m,$,T,D,N,te,Q,J,oe,ge,we,P,le)=>{a.Ea("ConvTranspose",i,{format:Q?"NHWC":"NCHW",autoPad:c,dilations:[m],group:$,kernel_shape:[T],pads:[D,N],strides:[te],wIsConst:()=>!!r()[J>>>0],outputPadding:oe?Array.from(n().subarray(ge>>>0,ge+oe>>>0)):[],outputShape:we?Array.from(n().subarray(P>>>0,P+we>>>0)):[],activation:Ve(le)})},1430641:(i,c,m,$,T,D,N,te,Q,J,oe,ge,we,P)=>{a.Ea("ConvTranspose",i,{format:te?"NHWC":"NCHW",autoPad:c,dilations:Array.from(n().subarray(m>>>0,m+2>>>0)),group:$,kernelShape:Array.from(n().subarray(T>>>0,T+2>>>0)),pads:Array.from(n().subarray(D>>>0,D+4>>>0)),strides:Array.from(n().subarray(N>>>0,N+2>>>0)),wIsConst:()=>!!r()[Q>>>0],outputPadding:0<J?Array.from(n().subarray(oe>>>0,oe+J>>>0)):[],outputShape:0<ge?Array.from(n().subarray(we>>>0,we+ge>>>0)):[],activation:Ve(P)})},1431198:(i,c,m,$,T,D,N,te,Q,J,oe,ge,we,P,le)=>{a.Ea("ConvTranspose",i,{format:Q?"NHWC":"NCHW",autoPad:c,dilations:[m],group:$,kernel_shape:[T],pads:[D,N],strides:[te],wIsConst:()=>!!r()[J>>>0],outputPadding:oe?Array.from(n().subarray(ge>>>0,ge+oe>>>0)):[],outputShape:we?Array.from(n().subarray(P>>>0,P+we>>>0)):[],activation:Ve(le)})},1431612:(i,c,m,$,T,D,N,te,Q,J,oe,ge,we,P)=>{a.Ea("ConvTranspose",i,{format:te?"NHWC":"NCHW",autoPad:c,dilations:Array.from(n().subarray(m>>>0,m+2>>>0)),group:$,kernelShape:Array.from(n().subarray(T>>>0,T+2>>>0)),pads:Array.from(n().subarray(D>>>0,D+4>>>0)),strides:Array.from(n().subarray(N>>>0,N+2>>>0)),wIsConst:()=>!!r()[Q>>>0],outputPadding:0<J?Array.from(n().subarray(oe>>>0,oe+J>>>0)):[],outputShape:0<ge?Array.from(n().subarray(we>>>0,we+ge>>>0)):[],activation:Ve(P)})},1432169:(i,c)=>{a.Ea("GlobalAveragePool",i,{format:c?"NHWC":"NCHW"})},1432260:(i,c,m,$,T,D,N,te,Q,J,oe,ge,we,P,le,ye)=>{a.Ea("AveragePool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:m,count_include_pad:$,storage_order:T,dilations:[D,N],kernel_shape:[te,Q],pads:[J,oe,ge,we],strides:[P,le]})},1432544:(i,c)=>{a.Ea("GlobalAveragePool",i,{format:c?"NHWC":"NCHW"})},1432635:(i,c,m,$,T,D,N,te,Q,J,oe,ge,we,P,le,ye)=>{a.Ea("AveragePool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:m,count_include_pad:$,storage_order:T,dilations:[D,N],kernel_shape:[te,Q],pads:[J,oe,ge,we],strides:[P,le]})},1432919:(i,c)=>{a.Ea("GlobalMaxPool",i,{format:c?"NHWC":"NCHW"})},1433006:(i,c,m,$,T,D,N,te,Q,J,oe,ge,we,P,le,ye)=>{a.Ea("MaxPool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:m,count_include_pad:$,storage_order:T,dilations:[D,N],kernel_shape:[te,Q],pads:[J,oe,ge,we],strides:[P,le]})},1433286:(i,c)=>{a.Ea("GlobalMaxPool",i,{format:c?"NHWC":"NCHW"})},1433373:(i,c,m,$,T,D,N,te,Q,J,oe,ge,we,P,le,ye)=>{a.Ea("MaxPool",i,{format:ye?"NHWC":"NCHW",auto_pad:c,ceil_mode:m,count_include_pad:$,storage_order:T,dilations:[D,N],kernel_shape:[te,Q],pads:[J,oe,ge,we],strides:[P,le]})},1433653:(i,c,m,$,T)=>{a.Ea("Gemm",i,{alpha:c,beta:m,transA:$,transB:T})},1433757:i=>{a.Ea("MatMul",i,void 0)},1433811:(i,c,m,$)=>{a.Ea("ArgMax",i,{keepDims:!!c,selectLastIndex:!!m,axis:$})},1433919:(i,c,m,$)=>{a.Ea("ArgMin",i,{keepDims:!!c,selectLastIndex:!!m,axis:$})},1434027:(i,c)=>{a.Ea("Softmax",i,{axis:c})},1434090:(i,c)=>{a.Ea("Concat",i,{axis:c})},1434150:(i,c,m,$,T)=>{a.Ea("Split",i,{axis:c,numOutputs:m,splitSizes:$?Array.from(n().subarray(T>>>0,T+$>>>0)):[]})},1434295:i=>{a.Ea("Expand",i,void 0)},1434349:(i,c)=>{a.Ea("Gather",i,{axis:Number(c)})},1434420:(i,c)=>{a.Ea("GatherElements",i,{axis:Number(c)})},1434499:(i,c,m,$,T,D,N,te,Q,J,oe)=>{a.Ea("Resize",i,{antialias:c,axes:m?Array.from(n().subarray($>>>0,$+m>>>0)):[],coordinateTransformMode:Ve(T),cubicCoeffA:D,excludeOutside:N,extrapolationValue:te,keepAspectRatioPolicy:Ve(Q),mode:Ve(J),nearestMode:Ve(oe)})},1434850:(i,c,m,$,T,D,N)=>{a.Ea("Slice",i,{starts:c?Array.from(n().subarray(m>>>0,m+c>>>0)):[],ends:$?Array.from(n().subarray(T>>>0,T+$>>>0)):[],axes:D?Array.from(n().subarray(N>>>0,N+D>>>0)):[]})},1435081:i=>{a.Ea("Tile",i,void 0)},1435133:(i,c,m)=>{a.Ea("LayerNormalization",i,{axis:Number(c),epsilon:Number(m)})},1435240:(i,c,m)=>{a.Ea("InstanceNormalization",i,{epsilon:c,format:m?"NHWC":"NCHW"})},1435354:(i,c,m)=>{a.Ea("InstanceNormalization",i,{epsilon:c,format:m?"NHWC":"NCHW"})},1435468:i=>{a.Ea("Range",i,void 0)},1435521:(i,c)=>{a.Ea("Einsum",i,{equation:Ve(c)})},1435602:(i,c,m,$,T)=>{a.Ea("Pad",i,{mode:c,value:m,pads:$?Array.from(n().subarray(T>>>0,T+$>>>0)):[]})},1435734:(i,c,m,$,T,D,N,te,Q)=>{a.Ea("Attention",i,{numHeads:c,isUnidirectional:m,maskFilterValue:$,scale:T,doRotary:D,qkvHiddenSizes:N?Array.from(n().subarray(Number(te)>>>0,Number(te)+N>>>0)):[],pastPresentShareBuffer:!!Q})},1436006:i=>{a.Ea("Gelu",i,void 0)},1436058:(i,c,m,$,T,D)=>{a.Ea("MultiHeadAttention",i,{numHeads:c,isUnidirectional:m,maskFilterValue:$,scale:T,doRotary:D})},1436217:i=>{a.Ea("BiasAdd",i,void 0)},1436272:i=>{a.Ea("BiasSplitGelu",i,void 0)},1436333:(i,c)=>{a.Ea("SkipLayerNormalization",i,{epsilon:c})},1436414:i=>a.wb(i),1436447:i=>a.yb(i),1436479:(i,c,m)=>{a.jb(i,c,m,!0)},1436518:(i,c,m)=>{a.jb(i,c,m)}};function gt(i){this.name="ExitStatus",this.message=`Program terminated with exit(${i})`,this.status=i}function Pt(i){i.terminate(),i.onmessage=()=>{}}function Rt(i){(i=ie.Qa[i])||Xe(),ie.Eb(i)}function Ht(i){var c=ie.tb();if(!c)return 6;ie.Ya.push(c),ie.Qa[i.Xa]=c,c.Xa=i.Xa;var m={cmd:"run",start_routine:i.Gb,arg:i.rb,pthread_ptr:i.Xa};return C&&c.unref(),c.postMessage(m,i.Mb),0}var Bt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,mr=(i,c,m)=>{c>>>=0;var $=c+m;for(m=c;i[m]&&!(m>=$);)++m;if(16<m-c&&i.buffer&&Bt)return Bt.decode(i.buffer instanceof SharedArrayBuffer?i.slice(c,m):i.subarray(c,m));for($="";c<m;){var T=i[c++];if(T&128){var D=i[c++]&63;if((T&224)==192)$+=String.fromCharCode((T&31)<<6|D);else{var N=i[c++]&63;T=(T&240)==224?(T&15)<<12|D<<6|N:(T&7)<<18|D<<12|N<<6|i[c++]&63,65536>T?$+=String.fromCharCode(T):(T-=65536,$+=String.fromCharCode(55296|T>>10,56320|T&1023))}}else $+=String.fromCharCode(T)}return $},Ve=(i,c)=>(i>>>=0)?mr(o(),i,c):"";function Gt(i){if(A)return U(1,1,i);_e=i,rt()||(ie.Hb(),a.onExit&&a.onExit(i),Pe=!0),b(i,new gt(i))}var Lt=i=>{if(_e=i,A)throw hr(i),"unwind";Gt(i)},ie={ab:[],Ya:[],mb:[],Qa:{},gb:function(){A?ie.vb():ie.ub()},ub:function(){Fe.unshift(()=>{Vt(),ie.Bb(()=>pr())})},vb:function(){ie.receiveObjectTransfer=ie.Db,ie.threadInitTLS=ie.lb,ie.setExitStatus=ie.kb,ue=!1},kb:function(i){_e=i},Sb:["$terminateWorker"],Hb:function(){for(var i of ie.Ya)Pt(i);for(i of ie.ab)Pt(i);ie.ab=[],ie.Ya=[],ie.Qa=[]},Eb:function(i){var c=i.Xa;delete ie.Qa[c],ie.ab.push(i),ie.Ya.splice(ie.Ya.indexOf(i),1),i.Xa=0,nn(c)},Db:function(){},lb:function(){ie.mb.forEach(i=>i())},Cb:i=>new Promise(c=>{i.onmessage=D=>{D=D.data;var N=D.cmd;if(D.targetThread&&D.targetThread!=Ar()){var te=ie.Qa[D.Rb];te?te.postMessage(D,D.transferList):K(\'Internal error! Worker sent a message "\'+N+\'" to target pthread \'+D.targetThread+", but that thread no longer exists!")}else N==="checkMailbox"?It():N==="spawnThread"?Ht(D):N==="cleanupThread"?Rt(D.thread):N==="killThread"?(D=D.thread,N=ie.Qa[D],delete ie.Qa[D],Pt(N),nn(D),ie.Ya.splice(ie.Ya.indexOf(N),1),N.Xa=0):N==="cancelThread"?ie.Qa[D.thread].postMessage({cmd:"cancel"}):N==="loaded"?(i.loaded=!0,c(i)):N==="alert"?alert("Thread "+D.threadId+": "+D.text):D.target==="setimmediate"?i.postMessage(D):N==="callHandler"?a[D.handler](...D.args):N&&K("worker sent an unknown command "+N)},i.onerror=D=>{throw K("worker sent an error! "+D.filename+":"+D.lineno+": "+D.message),D},C&&(i.on("message",function(D){i.onmessage({data:D})}),i.on("error",function(D){i.onerror(D)}));var m=[],$=["onExit","onAbort","print","printErr"],T;for(T of $)a.hasOwnProperty(T)&&m.push(T);i.postMessage({cmd:"load",handlers:m,urlOrBlob:a.mainScriptUrlOrBlob||e,wasmMemory:ve,wasmModule:xe})}),Bb:function(i){i()},qb:function(){var i=B("ort-wasm-simd-threaded.worker.js");i=new Worker(i),ie.ab.push(i)},tb:function(){return ie.ab.length==0&&(ie.qb(),ie.Cb(ie.ab[0])),ie.ab.pop()}};a.PThread=ie;var ft=i=>{for(;0<i.length;)i.shift()(a)};a.establishStackSpace=function(){var i=Ar(),c=n()[i+52>>2>>>0];i=n()[i+56>>2>>>0],to(c,c-i),_r(c)};function hr(i){if(A)return U(2,0,i);Lt(i)}a.invokeEntryPoint=function(i,c){i=ro.apply(null,[i,c]),rt()?ie.kb(i):on(i)};function nt(i){this.fb=i-24,this.pb=function(c){s()[this.fb+4>>2>>>0]=c},this.ob=function(c){s()[this.fb+8>>2>>>0]=c},this.gb=function(c,m){this.nb(),this.pb(c),this.ob(m)},this.nb=function(){s()[this.fb+16>>2>>>0]=0}}var Ke=0,gr=0;function xt(i,c,m,$){return A?U(3,1,i,c,m,$):Ft(i,c,m,$)}function Ft(i,c,m,$){if(i>>>=0,c>>>=0,m>>>=0,$>>>=0,typeof SharedArrayBuffer>"u")return K("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var T=[];return A&&T.length===0?xt(i,c,m,$):(i={Gb:m,Xa:i,rb:$,Mb:T},A?(i.Ob="spawnThread",postMessage(i,T),0):Ht(i))}function jt(i,c,m){return A?U(4,1,i,c,m):0}function yr(i,c){if(A)return U(5,1,i,c)}var Ct=i=>{for(var c=0,m=0;m<i.length;++m){var $=i.charCodeAt(m);127>=$?c++:2047>=$?c+=2:55296<=$&&57343>=$?(c+=4,++m):c+=3}return c},br=(i,c,m,$)=>{if(m>>>=0,!(0<$))return 0;var T=m;$=m+$-1;for(var D=0;D<i.length;++D){var N=i.charCodeAt(D);if(55296<=N&&57343>=N){var te=i.charCodeAt(++D);N=65536+((N&1023)<<10)|te&1023}if(127>=N){if(m>=$)break;c[m++>>>0]=N}else{if(2047>=N){if(m+1>=$)break;c[m++>>>0]=192|N>>6}else{if(65535>=N){if(m+2>=$)break;c[m++>>>0]=224|N>>12}else{if(m+3>=$)break;c[m++>>>0]=240|N>>18,c[m++>>>0]=128|N>>12&63}c[m++>>>0]=128|N>>6&63}c[m++>>>0]=128|N&63}}return c[m>>>0]=0,m-T},wr=(i,c,m)=>br(i,o(),c,m);function vr(i,c){if(A)return U(6,1,i,c)}function $r(i,c,m){if(A)return U(7,1,i,c,m)}function Sr(i,c,m){return A?U(8,1,i,c,m):0}function xr(i,c){if(A)return U(9,1,i,c)}function Mt(i,c,m){if(A)return U(10,1,i,c,m)}function qt(i,c,m,$){if(A)return U(11,1,i,c,m,$)}function Kt(i,c,m,$){if(A)return U(12,1,i,c,m,$)}function Yt(i,c,m,$){if(A)return U(13,1,i,c,m,$)}function Zt(i){if(A)return U(14,1,i)}function Xt(i,c){if(A)return U(15,1,i,c)}function Qt(i,c,m){if(A)return U(16,1,i,c,m)}var Jt=i=>{if(!Pe)try{if(i(),!rt())try{A?on(_e):Lt(_e)}catch(c){c instanceof gt||c=="unwind"||b(1,c)}}catch(c){c instanceof gt||c=="unwind"||b(1,c)}};function Dt(i){i>>>=0,typeof Atomics.Nb=="function"&&(Atomics.Nb(n(),i>>2,i).value.then(It),i+=128,Atomics.store(n(),i>>2,1))}a.__emscripten_thread_mailbox_await=Dt;function It(){var i=Ar();i&&(Dt(i),Jt(()=>Jn()))}a.checkMailbox=It;var yt=i=>i%4===0&&(i%100!==0||i%400===0),At=[0,31,60,91,121,152,182,213,244,274,305,335],er=[0,31,59,90,120,151,181,212,243,273,304,334];function l(i,c,m,$,T,D,N,te){return A?U(17,1,i,c,m,$,T,D,N,te):-52}function f(i,c,m,$,T,D,N){if(A)return U(18,1,i,c,m,$,T,D,N)}var g=i=>{var c=Ct(i)+1,m=rn(c);return m&&wr(i,m,c),m},x=[],O=(i,c)=>{x.length=0;var m;for(c>>=2;m=o()[i++>>>0];)c+=m!=105&c,x.push(m==105?n()[c>>>0]:d()[c++>>>1]),++c;return x},H=i=>{var c=an();return i=i(),_r(c),i};function U(i,c){var m=arguments.length-2,$=arguments;return H(()=>{for(var T=sn(8*m),D=T>>3,N=0;N<m;N++){var te=$[2+N];d()[D+N>>>0]=te}return Qn(i,m,T,c)})}var se=[],Z={},ee=()=>{if(!X){var i={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:y||"./this.program"},c;for(c in Z)Z[c]===void 0?delete i[c]:i[c]=Z[c];var m=[];for(c in i)m.push(`${c}=${i[c]}`);X=m}return X},X;function ce(i,c){if(A)return U(19,1,i,c);i>>>=0,c>>>=0;var m=0;return ee().forEach(function($,T){var D=c+m;for(T=s()[i+4*T>>2>>>0]=D,D=0;D<$.length;++D)r()[T++>>0>>>0]=$.charCodeAt(D);r()[T>>0>>>0]=0,m+=$.length+1}),0}function he(i,c){if(A)return U(20,1,i,c);i>>>=0,c>>>=0;var m=ee();s()[i>>2>>>0]=m.length;var $=0;return m.forEach(function(T){$+=T.length+1}),s()[c>>2>>>0]=$,0}function k(i){return A?U(21,1,i):52}function ne(i,c,m,$){return A?U(22,1,i,c,m,$):52}function fe(i,c,m,$,T){return A?U(23,1,i,c,m,$,T):70}var mt=[null,[],[]];function tr(i,c,m,$){if(A)return U(24,1,i,c,m,$);c>>>=0,m>>>=0,$>>>=0;for(var T=0,D=0;D<m;D++){var N=s()[c>>2>>>0],te=s()[c+4>>2>>>0];c+=8;for(var Q=0;Q<te;Q++){var J=o()[N+Q>>>0],oe=mt[i];J===0||J===10?((i===1?M:K)(mr(oe,0)),oe.length=0):oe.push(J)}T+=te}return s()[$>>2>>>0]=T,0}var Ln=[31,29,31,30,31,30,31,31,30,31,30,31],Fn=[31,28,31,30,31,30,31,31,30,31,30,31];function yu(i){var c=Array(Ct(i)+1);return br(i,c,0,c.length),c}var bu=(i,c)=>{r().set(i,c>>>0)};function jn(i,c,m,$){function T(P,le,ye){for(P=typeof P=="number"?P.toString():P||"";P.length<le;)P=ye[0]+P;return P}function D(P,le){return T(P,le,"0")}function N(P,le){function ye(uo){return 0>uo?-1:0<uo?1:0}var _t;return(_t=ye(P.getFullYear()-le.getFullYear()))===0&&(_t=ye(P.getMonth()-le.getMonth()))===0&&(_t=ye(P.getDate()-le.getDate())),_t}function te(P){switch(P.getDay()){case 0:return new Date(P.getFullYear()-1,11,29);case 1:return P;case 2:return new Date(P.getFullYear(),0,3);case 3:return new Date(P.getFullYear(),0,2);case 4:return new Date(P.getFullYear(),0,1);case 5:return new Date(P.getFullYear()-1,11,31);case 6:return new Date(P.getFullYear()-1,11,30)}}function Q(P){var le=P.Za;for(P=new Date(new Date(P.$a+1900,0,1).getTime());0<le;){var ye=P.getMonth(),_t=(yt(P.getFullYear())?Ln:Fn)[ye];if(le>_t-P.getDate())le-=_t-P.getDate()+1,P.setDate(1),11>ye?P.setMonth(ye+1):(P.setMonth(0),P.setFullYear(P.getFullYear()+1));else{P.setDate(P.getDate()+le);break}}return ye=new Date(P.getFullYear()+1,0,4),le=te(new Date(P.getFullYear(),0,4)),ye=te(ye),0>=N(le,P)?0>=N(ye,P)?P.getFullYear()+1:P.getFullYear():P.getFullYear()-1}i>>>=0,c>>>=0,m>>>=0,$>>>=0;var J=n()[$+40>>2>>>0];$={Kb:n()[$>>2>>>0],Jb:n()[$+4>>2>>>0],cb:n()[$+8>>2>>>0],ib:n()[$+12>>2>>>0],eb:n()[$+16>>2>>>0],$a:n()[$+20>>2>>>0],Wa:n()[$+24>>2>>>0],Za:n()[$+28>>2>>>0],Tb:n()[$+32>>2>>>0],Ib:n()[$+36>>2>>>0],Lb:J?Ve(J):""},m=Ve(m),J={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var oe in J)m=m.replace(new RegExp(oe,"g"),J[oe]);var ge="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),we="January February March April May June July August September October November December".split(" ");J={"%a":P=>ge[P.Wa].substring(0,3),"%A":P=>ge[P.Wa],"%b":P=>we[P.eb].substring(0,3),"%B":P=>we[P.eb],"%C":P=>D((P.$a+1900)/100|0,2),"%d":P=>D(P.ib,2),"%e":P=>T(P.ib,2," "),"%g":P=>Q(P).toString().substring(2),"%G":P=>Q(P),"%H":P=>D(P.cb,2),"%I":P=>(P=P.cb,P==0?P=12:12<P&&(P-=12),D(P,2)),"%j":P=>{for(var le=0,ye=0;ye<=P.eb-1;le+=(yt(P.$a+1900)?Ln:Fn)[ye++]);return D(P.ib+le,3)},"%m":P=>D(P.eb+1,2),"%M":P=>D(P.Jb,2),"%n":()=>`\n`,"%p":P=>0<=P.cb&&12>P.cb?"AM":"PM","%S":P=>D(P.Kb,2),"%t":()=>"	","%u":P=>P.Wa||7,"%U":P=>D(Math.floor((P.Za+7-P.Wa)/7),2),"%V":P=>{var le=Math.floor((P.Za+7-(P.Wa+6)%7)/7);if(2>=(P.Wa+371-P.Za-2)%7&&le++,le)le==53&&(ye=(P.Wa+371-P.Za)%7,ye==4||ye==3&&yt(P.$a)||(le=1));else{le=52;var ye=(P.Wa+7-P.Za-1)%7;(ye==4||ye==5&&yt(P.$a%400-1))&&le++}return D(le,2)},"%w":P=>P.Wa,"%W":P=>D(Math.floor((P.Za+7-(P.Wa+6)%7)/7),2),"%y":P=>(P.$a+1900).toString().substring(2),"%Y":P=>P.$a+1900,"%z":P=>{P=P.Ib;var le=0<=P;return P=Math.abs(P)/60,(le?"+":"-")+("0000"+(P/60*100+P%60)).slice(-4)},"%Z":P=>P.Lb,"%%":()=>"%"},m=m.replace(/%%/g,"\\0\\0");for(oe in J)m.includes(oe)&&(m=m.replace(new RegExp(oe,"g"),J[oe]($)));return m=m.replace(/\\0\\0/g,"%"),oe=yu(m),oe.length>c?0:(bu(oe,i),oe.length-1)}function Cr(i){try{i()}catch(c){Xe(c)}}function wu(i){var c={},m;for(m in i)(function($){var T=i[$];c[$]=typeof T=="function"?function(){Ir.push($);try{return T.apply(null,arguments)}finally{Pe||(Ir.pop()===$||Xe(),ot&&bt===1&&Ir.length===0&&(bt=0,He+=1,Cr(oo),typeof Fibers<"u"&&Fibers.Ub()))}}:T})(m);return c}var bt=0,ot=null,qn=0,Ir=[],Kn={},Yn={},vu=0,tn=null,$u=[];function Su(){return new Promise((i,c)=>{tn={resolve:i,reject:c}})}function xu(){var i=rn(65548),c=i+12;s()[i>>2>>>0]=c,s()[i+4>>2>>>0]=c+65536,c=Ir[0];var m=Kn[c];return m===void 0&&(m=vu++,Kn[c]=m,Yn[m]=c),c=m,n()[i+8>>2>>>0]=c,i}function Cu(){var i=n()[ot+8>>2>>>0];return i=j[Yn[i]],--He,i()}function Iu(i){if(!Pe){if(bt===0){var c=!1,m=!1;i(($=0)=>{if(!Pe&&(qn=$,c=!0,m)){bt=2,Cr(()=>ao(ot)),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.resume(),$=!1;try{var T=Cu()}catch(te){T=te,$=!0}var D=!1;if(!ot){var N=tn;N&&(tn=null,($?N.reject:N.resolve)(T),D=!0)}if($&&!D)throw T}}),m=!0,c||(bt=1,ot=xu(),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.pause(),Cr(()=>no(ot)))}else bt===2?(bt=0,Cr(io),Zn(ot),ot=null,$u.forEach($=>Jt($))):Xe(`invalid state: ${bt}`);return qn}}function Au(i){return Iu(c=>{i().then(c)})}ie.gb();var _u=[null,Gt,hr,xt,jt,yr,vr,$r,Sr,xr,Mt,qt,Kt,Yt,Zt,Xt,Qt,l,f,ce,he,k,ne,fe,tr],Tu={r:function(i,c,m){return Au(async()=>{await a.xb(i,c,m)})},b:function(i,c,m){throw i>>>=0,new nt(i).gb(c>>>0,m>>>0),Ke=i,gr++,Ke},P:function(i){Xn(i>>>0,!S,1,!w,131072,!1),ie.lb()},n:function(i){i>>>=0,A?postMessage({cmd:"cleanupThread",thread:i}):Rt(i)},K:Ft,g:jt,V:yr,F:vr,H:$r,y:Sr,T:xr,L:Mt,S:qt,p:Kt,G:Yt,D:Zt,U:Xt,E:Qt,q:()=>!0,B:function(i,c){i>>>=0,i==c>>>0?setTimeout(()=>It()):A?postMessage({targetThread:i,cmd:"checkMailbox"}):(i=ie.Qa[i])&&i.postMessage({cmd:"checkMailbox"})},N:function(){return-1},O:Dt,X:function(i){C&&ie.Qa[i>>>0].ref()},u:function(i,c,m){i=c+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*c:NaN,m>>>=0,i=new Date(1e3*i),n()[m>>2>>>0]=i.getUTCSeconds(),n()[m+4>>2>>>0]=i.getUTCMinutes(),n()[m+8>>2>>>0]=i.getUTCHours(),n()[m+12>>2>>>0]=i.getUTCDate(),n()[m+16>>2>>>0]=i.getUTCMonth(),n()[m+20>>2>>>0]=i.getUTCFullYear()-1900,n()[m+24>>2>>>0]=i.getUTCDay(),i=(i.getTime()-Date.UTC(i.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,n()[m+28>>2>>>0]=i},v:function(i,c,m){i=c+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*c:NaN,m>>>=0,i=new Date(1e3*i),n()[m>>2>>>0]=i.getSeconds(),n()[m+4>>2>>>0]=i.getMinutes(),n()[m+8>>2>>>0]=i.getHours(),n()[m+12>>2>>>0]=i.getDate(),n()[m+16>>2>>>0]=i.getMonth(),n()[m+20>>2>>>0]=i.getFullYear()-1900,n()[m+24>>2>>>0]=i.getDay(),c=(yt(i.getFullYear())?At:er)[i.getMonth()]+i.getDate()-1|0,n()[m+28>>2>>>0]=c,n()[m+36>>2>>>0]=-(60*i.getTimezoneOffset()),c=new Date(i.getFullYear(),6,1).getTimezoneOffset();var $=new Date(i.getFullYear(),0,1).getTimezoneOffset();i=(c!=$&&i.getTimezoneOffset()==Math.min($,c))|0,n()[m+32>>2>>>0]=i},w:function(i){i>>>=0;var c=new Date(n()[i+20>>2>>>0]+1900,n()[i+16>>2>>>0],n()[i+12>>2>>>0],n()[i+8>>2>>>0],n()[i+4>>2>>>0],n()[i>>2>>>0],0),m=n()[i+32>>2>>>0],$=c.getTimezoneOffset(),T=new Date(c.getFullYear(),6,1).getTimezoneOffset(),D=new Date(c.getFullYear(),0,1).getTimezoneOffset(),N=Math.min(D,T);return 0>m?n()[i+32>>2>>>0]=+(T!=D&&N==$):0<m!=(N==$)&&(T=Math.max(D,T),c.setTime(c.getTime()+6e4*((0<m?N:T)-$))),n()[i+24>>2>>>0]=c.getDay(),m=(yt(c.getFullYear())?At:er)[c.getMonth()]+c.getDate()-1|0,n()[i+28>>2>>>0]=m,n()[i>>2>>>0]=c.getSeconds(),n()[i+4>>2>>>0]=c.getMinutes(),n()[i+8>>2>>>0]=c.getHours(),n()[i+12>>2>>>0]=c.getDate(),n()[i+16>>2>>>0]=c.getMonth(),n()[i+20>>2>>>0]=c.getYear(),i=c.getTime()/1e3,eo((pt=i,1<=+Math.abs(pt)?0<pt?+Math.floor(pt/4294967296)>>>0:~~+Math.ceil((pt-+(~~pt>>>0))/4294967296)>>>0:0)),i>>>0},s:l,t:f,A:function(i,c,m){function $(J){return(J=J.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?J[1]:"GMT"}i>>>=0,c>>>=0,m>>>=0;var T=new Date().getFullYear(),D=new Date(T,0,1),N=new Date(T,6,1);T=D.getTimezoneOffset();var te=N.getTimezoneOffset(),Q=Math.max(T,te);s()[i>>2>>>0]=60*Q,n()[c>>2>>>0]=+(T!=te),i=$(D),c=$(N),i=g(i),c=g(c),te<T?(s()[m>>2>>>0]=i,s()[m+4>>2>>>0]=c):(s()[m>>2>>>0]=c,s()[m+4>>2>>>0]=i)},e:()=>{Xe("")},c:function(i,c,m){return i>>>=0,c=O(c>>>0,m>>>0),kt[i].apply(null,c)},l:function(i,c,m){return i>>>=0,c=O(c>>>0,m>>>0),kt[i].apply(null,c)},o:function(){},k:function(){return Date.now()},W:()=>{throw He+=1,"unwind"},C:function(){return 4294901760},d:()=>performance.timeOrigin+performance.now(),i:function(){return C?(go(),zt(ho)).cpus().length:navigator.hardwareConcurrency},M:function(i,c,m,$){for(ie.Pb=c>>>0,se.length=m,c=$>>>0>>3,$=0;$<m;$++)se[$]=d()[c+$>>>0];return(0>i?kt[-i-1]:_u[i]).apply(null,se)},z:function(i){i>>>=0;var c=o().length;if(i<=c||4294901760<i)return!1;for(var m=1;4>=m;m*=2){var $=c*(1+.2/m);$=Math.min($,i+100663296);var T=Math;$=Math.max(i,$);e:{T=T.min.call(T,4294901760,$+(65536-$%65536)%65536)-ve.buffer.byteLength+65535>>>16;try{ve.grow(T),pe();var D=1;break e}catch{}D=void 0}if(D)return!0}return!1},Q:ce,R:he,J:Lt,h:k,m:ne,x:fe,j:tr,a:ve||a.wasmMemory,I:jn,f:function(i,c,m,$){return jn(i>>>0,c>>>0,m>>>0,$>>>0)}};(function(){function i(m,$){return m=m.exports,m=wu(m),j=m=Eu(m),ie.mb.push(j.Da),Oe.unshift(j.Y),xe=$,pr(),m}var c={a:Tu};if(Vt(),a.instantiateWasm)try{return a.instantiateWasm(c,i)}catch(m){K("Module.instantiateWasm callback failed with error: "+m),h(m)}return fr(c,function(m){i(m.instance,m.module)}).catch(h),{}})(),a._OrtInit=(i,c)=>(a._OrtInit=j.Z)(i,c),a._OrtGetLastError=(i,c)=>(a._OrtGetLastError=j._)(i,c),a._OrtCreateSessionOptions=(i,c,m,$,T,D,N,te,Q,J)=>(a._OrtCreateSessionOptions=j.$)(i,c,m,$,T,D,N,te,Q,J),a._OrtAppendExecutionProvider=(i,c)=>(a._OrtAppendExecutionProvider=j.aa)(i,c),a._OrtAddFreeDimensionOverride=(i,c,m)=>(a._OrtAddFreeDimensionOverride=j.ba)(i,c,m),a._OrtAddSessionConfigEntry=(i,c,m)=>(a._OrtAddSessionConfigEntry=j.ca)(i,c,m),a._OrtReleaseSessionOptions=i=>(a._OrtReleaseSessionOptions=j.da)(i),a._OrtCreateSession=(i,c,m)=>(a._OrtCreateSession=j.ea)(i,c,m),a._OrtReleaseSession=i=>(a._OrtReleaseSession=j.fa)(i),a._OrtGetInputOutputCount=(i,c,m)=>(a._OrtGetInputOutputCount=j.ga)(i,c,m),a._OrtGetInputName=(i,c)=>(a._OrtGetInputName=j.ha)(i,c),a._OrtGetOutputName=(i,c)=>(a._OrtGetOutputName=j.ia)(i,c),a._OrtFree=i=>(a._OrtFree=j.ja)(i),a._OrtCreateTensor=(i,c,m,$,T,D)=>(a._OrtCreateTensor=j.ka)(i,c,m,$,T,D),a._OrtGetTensorData=(i,c,m,$,T)=>(a._OrtGetTensorData=j.la)(i,c,m,$,T),a._OrtReleaseTensor=i=>(a._OrtReleaseTensor=j.ma)(i),a._OrtCreateRunOptions=(i,c,m,$)=>(a._OrtCreateRunOptions=j.na)(i,c,m,$),a._OrtAddRunConfigEntry=(i,c,m)=>(a._OrtAddRunConfigEntry=j.oa)(i,c,m),a._OrtReleaseRunOptions=i=>(a._OrtReleaseRunOptions=j.pa)(i),a._OrtCreateBinding=i=>(a._OrtCreateBinding=j.qa)(i),a._OrtBindInput=(i,c,m)=>(a._OrtBindInput=j.ra)(i,c,m),a._OrtBindOutput=(i,c,m,$)=>(a._OrtBindOutput=j.sa)(i,c,m,$),a._OrtClearBoundOutputs=i=>(a._OrtClearBoundOutputs=j.ta)(i),a._OrtReleaseBinding=i=>(a._OrtReleaseBinding=j.ua)(i),a._OrtRunWithBinding=(i,c,m,$,T)=>(a._OrtRunWithBinding=j.va)(i,c,m,$,T),a._OrtRun=(i,c,m,$,T,D,N,te)=>(a._OrtRun=j.wa)(i,c,m,$,T,D,N,te),a._OrtEndProfiling=i=>(a._OrtEndProfiling=j.xa)(i),a._JsepOutput=(i,c,m)=>(a._JsepOutput=j.ya)(i,c,m),a._JsepGetNodeName=i=>(a._JsepGetNodeName=j.za)(i);var Ar=a._pthread_self=()=>(Ar=a._pthread_self=j.Aa)(),rn=a._malloc=i=>(rn=a._malloc=j.Ba)(i),Zn=a._free=i=>(Zn=a._free=j.Ca)(i);a.__emscripten_tls_init=()=>(a.__emscripten_tls_init=j.Da)();var Xn=a.__emscripten_thread_init=(i,c,m,$,T,D)=>(Xn=a.__emscripten_thread_init=j.Fa)(i,c,m,$,T,D);a.__emscripten_thread_crashed=()=>(a.__emscripten_thread_crashed=j.Ga)();var Qn=(i,c,m,$)=>(Qn=j.Ha)(i,c,m,$),nn=i=>(nn=j.Ia)(i),on=a.__emscripten_thread_exit=i=>(on=a.__emscripten_thread_exit=j.Ja)(i),Jn=a.__emscripten_check_mailbox=()=>(Jn=a.__emscripten_check_mailbox=j.Ka)(),eo=i=>(eo=j.La)(i),to=(i,c)=>(to=j.Ma)(i,c),an=()=>(an=j.Na)(),_r=i=>(_r=j.Oa)(i),sn=i=>(sn=j.Pa)(i),ro=a.dynCall_ii=(i,c)=>(ro=a.dynCall_ii=j.Ra)(i,c),no=i=>(no=j.Sa)(i),oo=()=>(oo=j.Ta)(),ao=i=>(ao=j.Ua)(i),io=()=>(io=j.Va)();a.___start_em_js=1436551,a.___stop_em_js=1436712;function Eu(i){i=Object.assign({},i);var c=$=>()=>$()>>>0,m=$=>T=>$(T)>>>0;return i.__errno_location=c(i.__errno_location),i.pthread_self=c(i.pthread_self),i.malloc=m(i.malloc),i.stackSave=c(i.stackSave),i.stackAlloc=m(i.stackAlloc),i}a.keepRuntimeAlive=rt,a.wasmMemory=ve,a.stackAlloc=sn,a.stackSave=an,a.stackRestore=_r,a.UTF8ToString=Ve,a.stringToUTF8=wr,a.lengthBytesUTF8=Ct,a.ExitStatus=gt,a.PThread=ie;var Tr;St=function i(){Tr||so(),Tr||(St=i)};function so(){function i(){if(!Tr&&(Tr=!0,a.calledRun=!0,!Pe)&&(A||ft(Oe),p(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),!A)){if(a.postRun)for(typeof a.postRun=="function"&&(a.postRun=[a.postRun]);a.postRun.length;){var c=a.postRun.shift();Me.unshift(c)}ft(Me)}}if(!(0<qe))if(A)p(a),A||ft(Oe),startWorker(a);else{if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;)Fe.unshift(a.preRun.shift());ft(Fe),0<qe||(a.setStatus?(a.setStatus("Running..."),setTimeout(function(){setTimeout(function(){a.setStatus("")},1),i()},1)):i())}}if(a.preInit)for(typeof a.preInit=="function"&&(a.preInit=[a.preInit]);0<a.preInit.length;)a.preInit.pop()();return so(),t.ready}})();typeof bo=="object"&&typeof mn=="object"?mn.exports=yo:typeof define=="function"&&define.amd&&define([],()=>yo)});var vo=rr((Tc,zu)=>{zu.exports=\'"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err("worker.js received unknown command "+e.data.cmd),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\\n\'});var yn,or,ar,kr,ir,Ao,bn,De=F(()=>{"use strict";yn=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},or=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},ar=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],kr=e=>{switch(e){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},ir=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Ao=e=>e==="float32"||e==="int32"||e==="int64"||e==="bool"||e==="float16"||e==="uint32",bn=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var ju,qu,_o,To,Eo,Ku,Te,wt=F(()=>{"use strict";De();ju=["V","I","W","E","F"],qu=(e,t)=>{console.log(`[${ju[e]},${new Date().toISOString()}]${t}`)},Eo=(e,t)=>{_o=e,To=t},Ku=(e,t)=>{let r=ir(e),o=ir(_o);r>=o&&qu(r,typeof t=="function"?t():t)},Te=(...e)=>{To&&Ku(...e)}});var Oo,ko=F(()=>{"use strict";De();Oo=(e,t)=>new(kr(t))(e)});var Pr=F(()=>{"use strict"});var Rr,Yu,Po,vn,wn,Bo,Mo=F(()=>{"use strict";wt();Pr();Rr=e=>Math.ceil(e/16)*16,Yu=1,Po=()=>Yu++,vn=async(e,t,r,o)=>{let n=Rr(r),s=e.device.createBuffer({size:n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let u=e.getCommandEncoder();e.endComputePass(),u.copyBufferToBuffer(t,0,s,0,n),e.flush(),await s.mapAsync(GPUMapMode.READ);let d=s.getMappedRange();if(o){let a=o();return a.set(new Uint8Array(d,0,r)),a}else return new Uint8Array(d.slice(0,r))}finally{s.destroy()}},wn=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(t,r){let o=r.buffer,n=r.byteOffset,s=r.byteLength,u=Rr(s),d=this.storageCache.get(t);if(!d)throw new Error("gpu data for uploading does not exist");if(d.originalSize!==s)throw new Error(`inconsistent data size. gpu data size=${d.originalSize}, data size=${s}`);let a=this.backend.device.createBuffer({mappedAtCreation:!0,size:u,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),p=a.getMappedRange();new Uint8Array(p).set(new Uint8Array(o,n,s)),a.unmap();let h=this.backend.getCommandEncoder();this.backend.endComputePass(),h.copyBufferToBuffer(a,0,d.gpuData.buffer,0,u),Te("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`),this.buffersForUploadingPending.push(a)}memcpy(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("source gpu data for memcpy does not exist");let n=this.storageCache.get(r);if(!n)throw new Error("destination gpu data for memcpy does not exist");if(o.originalSize!==n.originalSize)throw new Error("inconsistent source and destination gpu data size");let s=Rr(o.originalSize),u=this.backend.getCommandEncoder();this.backend.endComputePass(),u.copyBufferToBuffer(o.gpuData.buffer,0,n.gpuData.buffer,0,s)}registerExternalBuffer(t,r,o){let n;if(o){if(n=this.externalBuffers.get(o),n===void 0)throw new Error("previous buffer is not registered");if(t===o)return Te("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, buffer is the same, skip.`),n;this.externalBuffers.delete(o)}else n=Po();return this.storageCache.set(n,{gpuData:{id:n,type:0,buffer:t},originalSize:r}),this.externalBuffers.set(t,n),Te("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, registered.`),n}unregisterExternalBuffer(t){let r=this.externalBuffers.get(t);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(t),Te("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let o=Rr(t),n,s=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,u=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(s||u){let a=s?this.freeBuffers:this.freeUniformBuffers,p=a.get(o);p||(p=[],a.set(o,p)),p.length>0?n=p.pop():n=this.backend.device.createBuffer({size:o,usage:r})}else n=this.backend.device.createBuffer({size:o,usage:r});let d={id:Po(),type:0,buffer:n};return this.storageCache.set(d.id,{gpuData:d,originalSize:t}),Te("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${d.id}`),d}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=this.storageCache.get(t);if(!r)throw new Error("releasing data does not exist");return Te("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("data does not exist");await vn(this.backend,o.gpuData.buffer,o.originalSize,r)}refreshPendingBuffers(){for(let t of this.buffersForUploadingPending)t.destroy();this.buffersForUploadingPending=[];for(let t of this.buffersPending)(t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(t.size).push(t):(t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(t.size).push(t):t.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},Bo=(...e)=>new wn(...e)});var $n,re,Ee=F(()=>{"use strict";$n=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this.key}},re=e=>new $n(e)});var Sn,at,z,Tt,Br,Mr,Dr,me=F(()=>{"use strict";Sn=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},at=class{static calcShape(t,r,o=!1){let n=t.length,s=r.length;if(n===0)return r;if(s===0)return t;let u=Math.max(t.length,r.length),d=new Array(u);if(o){if(n<2||s<2)return;let a=Sn.calcMatMulShape([t[n-2],t[n-1]],[r[s-2],r[s-1]]);if(a===void 0)return;[d[u-2],d[u-1]]=a}for(let a=o?3:1;a<=u;a++){let p=n-a<0?1:t[n-a],h=s-a<0?1:r[s-a];if(p!==h&&p>1&&h>1)return;d[u-a]=Math.max(p,h)}return d}static isValidBroadcast(t,r){let o=t.length,n=r.length;if(o>n)return!1;for(let s=1;s<=o;s++)if(t[o-s]!==1&&t[o-s]!==r[n-s])return!1;return!0}},z=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,o){let n=1;for(let s=r;s<o;s++){if(t[s]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");n*=t[s]}return n}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let o=new Array(r);o[r-1]=1,o[r-2]=t[r-1];for(let n=r-3;n>=0;--n)o[n]=o[n+1]*t[n+1];return o}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error("unsupported axis for this operation.");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(o=>this.normalizeAxis(o,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(o=>t[o]):t.slice().reverse()}static padShape(t,r){let o=t.length;return t.map((n,s)=>n+r[s]+r[s+o])}static areEqual(t,r){return t.length!==r.length?!1:t.every((o,n)=>o===r[n])}},Tt=class e{static adjustPoolAttributes(t,r,o,n,s,u){if(!t&&o.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let d=0;d<r.length-2;d++)d>=o.length?o.push(r[d+2]):o[d]=r[d+2];for(let d=0;d<o.length;d++)if(d<n.length){if(n[d]<0)throw new Error("strides should be greater than or equal to 1")}else n.push(1);for(let d=0;d<o.length;d++)if(d<s.length){if(s[d]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let d=0;d<o.length*2;d++)if(d<u.length){if(u[d]<0)throw new Error("pad should be greater than or equal to 1")}else u.push(0);for(let d=0;d<o.length;d++){if(o[d]<=0)throw new Error("kernel shapes need to be greater than 0");if(u[d]>=o[d]||u[d+o.length]>=o[d])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,o,n,s,u,d){if(d){if(s.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let a=0;a<t.length-2;a++)e.adjustPadAndReturnShape(t[a+(u?1:2)],r[a],o[a],n[a],s,a,a+t.length-2,d)}}static computePoolOutputShape(t,r,o,n,s,u,d){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let a=[r[0],r[1]];return e.computeShapeHelper(t,r,a,o,n,s,u,d),a}static computeConvOutputShape(t,r,o,n,s,u,d){if(t.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let a=[t[0],r[0]];return e.computeShapeHelper(!1,t,a,o,n,s,u,d),a}static computeShapeHelper(t,r,o,n,s,u,d,a){if(t)for(let p=0;p<r.length-2;p++)o.push(1);else for(let p=0;p<r.length-2;p++)o.push(e.adjustPadAndReturnShape(r[p+2],n[p],s[p],u[p],d,p,p+r.length-2,a))}static adjustPadAndReturnShape(t,r,o,n,s,u,d,a){let p=o*(n-1)+1;if(a&&a!=="NOTSET")switch(a){case"VALID":return s[u]=0,s[d]=0,Math.floor((t-p)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(o!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let v=((t+r-1)/r-1)*r+n-t;return s[u]=Math.floor(a==="SAME_LOWER"?(v+1)/2:v/2),s[d]=v-s[u],Math.floor((t+v-n)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+s[u]+s[d]-p)/r+1)}},Br=class{static getShapeOfGemmResult(t,r,o,n,s){if(t.length!==2||o.length!==2)throw new Error("shape need to be of size 2");let u,d,a;r?(u=t[1],d=t[0]):(u=t[0],d=t[1]);let p=-1;if(n?(a=o[0],p=1):(a=o[1],p=0),o[p]!==d)throw new Error("dimension mismatch");if(u<=0||a<=0||d<=0)throw new Error("invalid shape specified");if(s&&!at.isValidBroadcast(s,[u,a]))throw new Error("gemm: invalid bias shape for broadcast");return[u,a,d]}},Mr=-34028234663852886e22,Dr=34028234663852886e22});var Zu,Do,Ie,Ne,Ze,Ue,Qe,Je,zo,G,q,xn,Wo,Cn,Ge,be=F(()=>{"use strict";De();me();Zu=64,Do=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},Ie=(e,t=1)=>{let r=Do(e,t);return typeof r=="string"?r:r[0]},Ne=e=>e.length===0?[]:[{type:"uint32",data:e},{type:"uint32",data:z.computeStrides(e)}],Ze=e=>e%4===0?4:e%2===0?2:1,Ue=(e="f32",t,r="0")=>!t||t===1?`${e}(${r})`:`vec${t}<${e}>(${r})`,Qe=(e,t,r)=>e==="f32"?r:t===1?`f32(${r})`:`vec${t}f(${r})`,Je=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,zo=(e,t,r,o,n)=>{let s=typeof r=="number",u=s?r:r.length,d=[...new Array(u).keys()],a=u<2?"u32":u<=4?`vec${u}<u32>`:`array<u32, ${u}>`,p=Do(t,n),h=typeof p=="string"?p:p[1],v=typeof p=="string"?p:p[0],y={indices:a,value:h,storage:v,tensor:t},b=L=>typeof L=="string"?L:`${L}u`,w={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},S=s?"uniforms.":"",C=`${S}${e}_shape`,A=`${S}${e}_strides`,I="";for(let L=0;L<u-1;L++)I+=`\n    let dim${L} = current / ${A}[${L}];\n    let rest${L} = current % ${A}[${L}];\n    indices[${L}] = dim${L};\n    current = rest${L};\n    `;I+=`indices[${u-1}] = current;`;let B=u<2?"":`\n  fn o2i_${e}(offset: u32) -> ${y.indices} {\n    var indices: ${y.indices};\n    var current = offset;\n    ${I}\n    return indices;\n  }`,_=L=>(w.offsetToIndices=!0,u<2?L:`o2i_${e}(${L})`),R=[];if(u>=2)for(let L=u-1;L>=0;L--)R.push(`${A}[${L}] * (indices[${L}])`);let E=u<2?"":`\n  fn i2o_${e}(indices: ${y.indices}) -> u32 {\n    return ${R.join("+")};\n  }`,W=L=>(w.indicesToOffset=!0,u<2?L:`i2o_${e}(${L})`),V=(...L)=>u===0?"0u":`${y.indices}(${L.map(b).join(",")})`,Y=(L,de)=>u<2?`${L}`:`${L}[${de}]`,ae=(L,de,pe)=>u<2?`${L}=${pe};`:`${L}[${de}]=${pe};`,M={},K=(L,de)=>{w.broadcastedIndicesToOffset=!0;let pe=`${de.name}broadcastedIndicesTo${e}Offset`;if(pe in M)return`${pe}(${L})`;let We=[];for(let Fe=u-1;Fe>=0;Fe--){let Oe=de.indicesGet("outputIndices",Fe+de.rank-u);We.push(`${Y(A,Fe)} * (${Oe} % ${Y(C,Fe)})`)}return M[pe]=`fn ${pe}(outputIndices: ${de.type.indices}) -> u32 {\n             return ${We.length>0?We.join("+"):"0u"};\n           }`,`${pe}(${L})`},Se=(L,de)=>(()=>{if(y.storage===y.value)return`${e}[${L}]=${de};`;if(y.storage==="vec2<u32>"&&y.value==="i32")return`${e}[${L}]=vec2<u32>(u32(${de}), select(0u, 0xFFFFFFFFu, ${de} < 0));`;if(y.storage==="vec2<u32>"&&y.value==="u32")return`${e}[${L}]=vec2<u32>(u32(${de}), 0u);`;if(y.storage==="u32"&&y.value==="vec4<bool>")return`${e}[${L}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${de}));`;throw new Error(`not supported combination of storage type ${y.storage} and value type ${y.value} yet`)})(),ue=L=>(()=>{if(y.storage===y.value)return`${e}[${L}]`;if(y.storage==="vec2<u32>"&&y.value==="i32")return`i32(${e}[${L}].x)`;if(y.storage==="vec2<u32>"&&y.value==="u32")return`u32(${e}[${L}].x)`;if(y.storage==="u32"&&y.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${L}] & 0xFFu), bool(${e}[${L}] & 0xFF00u), bool(${e}[${L}] & 0xFF0000u), bool(${e}[${L}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${y.storage} and value type ${y.value} yet`)})(),ve=u<2?"":`\n  fn get_${e}ByIndices(indices: ${y.indices}) -> ${h} {\n    return ${ue(`i2o_${e}(indices)`)};\n  }`,j=u<2?"":(()=>{let L=d.map(pe=>`d${pe}: u32`).join(", "),de=d.map(pe=>`d${pe}`).join(", ");return`\n  fn get_${e}(${L}) -> ${h} {\n    return get_${e}ByIndices(${V(de)});\n  }`})(),xe=(...L)=>{if(L.length!==u)throw new Error(`indices length must be ${u}`);let de=L.map(b).join(",");return u===0?ue("0u"):u===1?ue(de[0]):(w.get=!0,w.getByIndices=!0,w.indicesToOffset=!0,`get_${e}(${de})`)},Pe=L=>u<2?ue(L):(w.getByIndices=!0,w.indicesToOffset=!0,`get_${e}ByIndices(${L})`),_e=u<2?"":`\n  fn set_${e}ByIndices(indices: ${y.indices}, value: ${h}) {\n    ${Se(`i2o_${e}(indices)`,"value")}\n  }`,Ce=u<2?"":(()=>{let L=d.map(pe=>`d${pe}: u32`).join(", "),de=d.map(pe=>`d${pe}`).join(", ");return`\n  fn set_${e}(${L}, value: ${h}) {\n    set_${e}ByIndices(${V(de)}, value);\n  }`})();return{impl:()=>{let L=[];return s||(L.push(`const ${C} = ${y.indices}(${r.join(",")});`),L.push(`const ${A} = ${y.indices}(${z.computeStrides(r).join(",")});`)),w.offsetToIndices&&L.push(B),w.indicesToOffset&&L.push(E),w.broadcastedIndicesToOffset&&Object.values(M).forEach(de=>L.push(de)),w.set&&L.push(Ce),w.setByIndices&&L.push(_e),w.get&&L.push(j),w.getByIndices&&L.push(ve),L.join(`\n`)},type:y,offsetToIndices:_,indicesToOffset:W,broadcastedIndicesToOffset:K,indices:V,indicesGet:Y,indicesSet:ae,set:(...L)=>{if(L.length!==u+1)throw new Error(`indices length must be ${u}`);let de=L[u];if(typeof de!="string")throw new Error("value must be string");let pe=L.slice(0,u).map(b).join(",");return u===0?Se("0u",de):u===1?Se(pe[0],de):(w.set=!0,w.setByIndices=!0,w.indicesToOffset=!0,`set_${e}(${pe}, ${de})`)},setByOffset:Se,setByIndices:(L,de)=>u<2?Se(L,de):(w.setByIndices=!0,w.indicesToOffset=!0,`set_${e}ByIndices(${L}, ${de});`),get:xe,getByOffset:ue,getByIndices:Pe,usage:o?"input":"output",name:e,strides:A,shape:C,rank:u}},G=(e,t,r,o=1)=>zo(e,t,r,!0,o),q=(e,t,r,o=1)=>zo(e,t,r,!1,o),xn=class{constructor(t){this.normalizedDispatchGroup=t;this.indicesHelpers=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=Zu){let r=typeof t=="number"?t:t[0],o=typeof t=="number"?1:t[1],n=typeof t=="number"?1:t[2],s=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,u=s?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_index : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>`,d=s?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${r*o*n}u + local_index;`;return`@compute @workgroup_size(${r}, ${o}, ${n})\n  fn main(${u}) {\n    ${d}\n  `}declareVariable(t,r){this.indicesHelpers.push(t),t.rank!==0&&(t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:t.type.indices}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:t.type.indices}));let o=t.usage==="input"?"read":"read_write",n=t.type.storage;return`@group(0) @binding(${r}) var<storage, ${o}> ${t.name}: array<${n}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`\n`)}registerUniform(t,r){return this.uniforms.push({name:t,type:r}),this}registerUniforms(t){return this.uniforms=this.uniforms.concat(t),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:r,type:o}of this.uniforms)t.push(`${r}:${o}`);return`\n      struct Uniforms { ${t.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.indicesHelpers.map(t=>t.impl()).join(`\n`)}},Wo=e=>new xn(e),Cn=(e,t)=>{let r=e.length,o=[];for(let n=0;n<r;n++){let s=r-1-n,u=e[s]||1;(t[t.length-1-n]||1)>1&&u===1&&o.unshift(s)}return o},Ge=e=>e<=4});var Xu,Vo,Qu,Ju,et,No,Uo,Wt=F(()=>{"use strict";me();Ee();be();Xu=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},Vo=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,Qu=(e,t)=>z.sortBasedOnPerm(e,Vo(e.length,t)),Ju=(e,t,r,o)=>{let n=[];n.push(`fn perm(i: ${o.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let s=0;s<t;++s)n.push(r.indicesSet("a",e[s],`i[${s}]`));return n.push("return a;}"),n.join(`\n`)},et=(e,t)=>{let r=e.dataType,o=e.dims.length,n=Vo(o,t),s=Ge(o),u=Qu(e.dims,n),d=s?u.length:u,a=s?o:e.dims,p=q("output",r,d),h=G("a",r,a),v=y=>`\n  ${y.registerUniform("output_size","u32").declareVariables(h,p)}\n\n  ${Ju(n,o,h,p)}\n\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${p.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${p.setByOffset("global_idx",h.getByIndices("aIndices"))}\n  }`;return{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:s?["rank"]:["dims"]},getRunData:y=>{let b=z.size(u);return{outputs:[{dims:u,dataType:y[0].dataType}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:s?[{type:"uint32",data:b},...Ne(y[0].dims),...Ne(u)]:[{type:"uint32",data:b}]}},getShaderSource:v}},No=(e,t)=>{Xu(e.inputs),e.compute(et(e.inputs[0],t.perm))},Uo=e=>re({perm:e.perm})});var el,tl,rl,nl,ol,al,il,sl,ul,ll,it,Ho,Go,Lo,Fo,jo,qo,Ko,Yo,Zo,Xo,Qo=F(()=>{"use strict";me();be();zr();Wt();el={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},tl={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},rl={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},nl={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},ol=(e,t)=>{let r=[];for(let o=t-e;o<t;++o)r.push(o);return r},al=(e,t)=>{let r=[],o=e.length;for(let s=0;s<o;s++)t.indexOf(s)===-1&&r.push(e[s]);let n=t.map(s=>e[s]);return[r,n]},il=(e,t)=>{let r=e.length+t.length,o=[],n=0;for(let s=0;s<r;s++)t.indexOf(s)===-1?o.push(e[n++]):o.push(1);return o},sl=(e,t)=>{for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0},ul=(e,t)=>{let r=[];if(!sl(e,t)){for(let o=0;o<t;++o)e.indexOf(o)===-1&&r.push(o);e.forEach(o=>r.push(o))}return r},ll=(e,t,r,o,n,s,u)=>{let d=r[0].dims,a=z.size(s),p=z.size(u),h=G("_A",r[0].dataType,d),v=q("output",n,s),y=32,b=`\n          var<workgroup> aBestValues : array<${v.type.storage}, ${y}>;\n       `;return{name:e,shaderCache:t,getShaderSource:S=>`\n        ${S.registerUniform("reduceSize","u32").declareVariables(h,v)}\n        ${b}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${S.mainStart(y)}\n          let local_idx = local_id.x;\n\n          let outputIndex = global_idx / ${y};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = ${v.type.storage}(${rl[o]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${y}) {\n           let candidate = ${v.type.storage}(${h.getByOffset("offset + k")});\n           bestValue = ${el[o]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${y}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${tl[o]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${v.setByOffset("outputIndex",`${o==="mean"?`bestValue / ${v.type.storage}(uniforms.reduceSize)`:`${nl[o]}`}`)};\n         }\n        }`,getRunData:()=>({outputs:[{dims:s,dataType:n}],dispatchGroup:{x:a},programUniforms:[{type:"uint32",data:p}]})}},it=(e,t,r,o)=>{let n=e.inputs.length===1?r:In(e.inputs,r),s=n.axes;s.length===0&&!n.noopWithEmptyAxes&&(s=e.inputs[0].dims.map((b,w)=>w));let u=z.normalizeAxes(s,e.inputs[0].dims.length),d=u,a=e.inputs[0],p=ul(d,e.inputs[0].dims.length);p.length>0&&(a=e.compute(et(e.inputs[0],p),{inputs:[0],outputs:[-1]})[0],d=ol(d.length,a.dims.length));let[h,v]=al(a.dims,d),y=h;n.keepDims&&(y=il(h,u)),e.compute(ll(t,{hint:n.cacheKey,inputDependencies:["type"]},[a],o,e.inputs[0].dataType,y,v),{inputs:[a]})},Ho=(e,t)=>{it(e,"ReduceMeanShared",t,"mean")},Go=(e,t)=>{it(e,"ReduceL1Shared",t,"l1")},Lo=(e,t)=>{it(e,"ReduceL2Shared",t,"l2")},Fo=(e,t)=>{it(e,"ReduceLogSumExpShared",t,"logSumExp")},jo=(e,t)=>{it(e,"ReduceMaxShared",t,"max")},qo=(e,t)=>{it(e,"ReduceMinShared",t,"min")},Ko=(e,t)=>{it(e,"ReduceProdShared",t,"prod")},Yo=(e,t)=>{it(e,"ReduceSumShared",t,"sum")},Zo=(e,t)=>{it(e,"ReduceSumSquareShared",t,"sumSquare")},Xo=(e,t)=>{it(e,"ReduceLogSumShared",t,"logSum")}});var st,dl,Wr,In,ut,cl,pl,fl,ml,hl,gl,yl,bl,wl,vl,lt,Jo,ea,ta,ra,na,oa,aa,ia,sa,ua,tt,zr=F(()=>{"use strict";me();Ee();be();Qo();st=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},dl=e=>["","",`var value = ${e.getByOffset("inputOffset")};`,""],Wr=(e,t,r,o,n,s,u=!1,d=!1)=>{let a=[],p=r[0].dims,h=z.normalizeAxes(n,r[0].dims.length),v=!d&&h.length===0;p.forEach((W,V)=>{v||h.indexOf(V)>=0?u&&a.push(1):a.push(W)});let y=[],b=G("_A",r[0].dataType,p),w=q("output",s,a),S=o(b,w,h),C=`inputOffset = ${b.indicesToOffset("inputIndices")};`,A=`let ${C};`,I=`var ${C};`,B=S[1]===""?"":I,_=(S[1]===""?A:C)+`\n`+S[2];for(let W=0,V=0;W<r[0].dims.length;W++)v||h.indexOf(W)>=0?(u&&V++,_=`for(var j${W}: u32 = 0; j${W} < ${r[0].dims[W]}; j${W}++) {\n                ${S[2].includes("lastIndex")?`let lastIndex = j${W};`:""}\n                ${b.indicesSet("inputIndices",W,`j${W}`)}\n                ${_}\n              }`):(y.push(`${b.indicesSet("inputIndices",W,w.indicesGet("outputIndices",V))};`),V++);let R=z.size(a);return{name:e,shaderCache:t,getShaderSource:W=>`\n        ${W.declareVariables(b,w)}\n\n        ${W.mainStart()}\n          ${W.guardAgainstOutOfBoundsWorkgroupSizes(R)}\n          var inputIndices: ${b.type.indices};\n          let outputIndices = ${w.offsetToIndices("global_idx")};\n\n          ${y.join(`\n`)}\n          ${S[0]}       // init ops for reduce max/min\n          ${B}\n          ${S[1]}\n          ${_}\n          ${S[3]}\n          ${S.length===4?w.setByOffset("global_idx","value"):S.slice(4).join(`\n`)}\n        }`,getRunData:()=>({outputs:[{dims:a,dataType:s}],dispatchGroup:{x:Math.ceil(R/64)}})}},In=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(o=>r.push(Number(o))),re({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},ut=(e,t,r,o)=>{let n=e.inputs,s=n.length===1?r:In(n,r);e.compute(Wr(t,{hint:s.cacheKey},[n[0]],s.noopWithEmptyAxes&&s.axes.length===0?dl:o,s.axes,n[0].dataType,s.keepDims,s.noopWithEmptyAxes),{inputs:[0]})},cl=(e,t)=>{st(e.inputs),ut(e,"ReduceLogSum",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${o.getByOffset("inputOffset")};`,"value = log(value);"])},pl=(e,t)=>{st(e.inputs),ut(e,"ReduceL1",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += abs(${o.getByOffset("inputOffset")});`,""])},fl=(e,t)=>{st(e.inputs),ut(e,"ReduceL2",t,(o,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${o.getByOffset("inputOffset")}; value += (t * t);`,"value = sqrt(value);"])},ml=(e,t)=>{st(e.inputs),ut(e,"ReduceLogSumExp",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += exp(${o.getByOffset("inputOffset")});`,"value = log(value);"])},hl=(e,t)=>{st(e.inputs),ut(e,"ReduceMax",t,(o,n,s)=>{let u=[];for(let d=0;d<o.rank;d++)(s.indexOf(d)>=0||s.length===0)&&u.push(o.indicesSet("inputIndices",d,0));return[`${u.join(`\n`)}`,`var value = ${o.getByOffset("inputOffset")};`,`value = max(value, ${o.getByOffset("inputOffset")});`,""]})},gl=(e,t)=>{st(e.inputs),ut(e,"ReduceMean",t,(o,n,s)=>{let u=1;for(let d=0;d<o.rank;d++)(s.indexOf(d)>=0||s.length===0)&&(u*=e.inputs[0].dims[d]);return["var sum = f32(0);","",`sum += f32(${o.getByOffset("inputOffset")});`,`let value = ${n.type.value}(sum / ${u});`]})},yl=(e,t)=>{st(e.inputs),ut(e,"ReduceMin",t,(o,n,s)=>{let u=[];for(let d=0;d<o.rank;d++)(s.indexOf(d)>=0||s.length===0)&&u.push(`inputIndices[${d}] = 0;`);return[`${u.join(`\n`)}`,`var value = ${o.getByOffset("inputOffset")};`,`value = min(value, ${o.getByOffset("inputOffset")});`,""]})},bl=(e,t)=>{st(e.inputs),ut(e,"ReduceProd",t,(o,n)=>[`var value = ${n.type.storage}(1);`,"",`value *= ${o.getByOffset("inputOffset")};`,""])},wl=(e,t)=>{st(e.inputs),ut(e,"ReduceSum",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${o.getByOffset("inputOffset")};`,""])},vl=(e,t)=>{st(e.inputs),ut(e,"ReduceSumSquare",t,(o,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${o.getByOffset("inputOffset")}; value += t * t;`,""])},lt=(e,t,r)=>{if(t.length===0)return!!r;let o=1,n=1;for(let s=0;s<t.length;s++)t.indexOf(s)===-1?o*=e[s]:n*=e[s];return n<32&&o>1024},Jo=(e,t)=>{lt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?gl(e,t):Ho(e,t)},ea=(e,t)=>{lt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?pl(e,t):Go(e,t)},ta=(e,t)=>{lt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?fl(e,t):Lo(e,t)},ra=(e,t)=>{lt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ml(e,t):Fo(e,t)},na=(e,t)=>{lt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?hl(e,t):jo(e,t)},oa=(e,t)=>{lt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?yl(e,t):qo(e,t)},aa=(e,t)=>{lt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?bl(e,t):Ko(e,t)},ia=(e,t)=>{lt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?wl(e,t):Yo(e,t)},sa=(e,t)=>{lt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?vl(e,t):Zo(e,t)},ua=(e,t)=>{lt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?cl(e,t):Xo(e,t)},tt=e=>re(e)});var la,da,ca,An,pa=F(()=>{"use strict";De();Ee();zr();la=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},da=(e,t)=>{la(e.inputs);let r=(o,n,s)=>{let u=[];for(let d=0;d<o.rank;d++)(s.indexOf(d)>=0||s.length===0)&&u.push(`inputIndices[${d}] = 0;`);return[`${u.join(`\n`)}`,`var value = ${o.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${o.getByOffset("inputOffset")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${o.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",n.setByOffset("global_idx","bestIndex")]};e.compute(Wr("ArgMin",{hint:t.cacheKey},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},ca=(e,t)=>{la(e.inputs);let r=(o,n,s)=>{let u=[];for(let d=0;d<o.rank;d++)(s.indexOf(d)>=0||s.length===0)&&u.push(`inputIndices[${d}] = 0;`);return[`${u.join(`\n`)}`,`var value = ${o.getByOffset("inputOffset")};\nvar bestIndex : i32 = 0;`,`if (${o.getByOffset("inputOffset")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${o.getByOffset("inputOffset")};\n         bestIndex = i32(lastIndex);\n       }`,"",n.setByOffset("global_idx","bestIndex")]};e.compute(Wr("argMax",{hint:t.cacheKey},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},An=e=>re(e)});var $l,fa,Sl,xl,Cl,Vr,Il,ma,_n=F(()=>{"use strict";Ee();Pr();be();$l=(e,t)=>{let r=e[0],o=e[1],n=e[2],s=e[3],u=e[4],d=e[5];if(u&&d)throw new Error("Attention cannot have both past and relative_position_bias");if(r.dims.length!==3)throw new Error(\'Input "input" must have 3 dimensions\');let a=r.dims[0],p=r.dims[1],h=r.dims[2];if(n.dims.length!==1)throw new Error(\'Input "bias" is expected to have 1 dimensions\');if(o.dims.length!==2)throw new Error(\'Input "weights" is expected to have 2 dimensions\');if(o.dims[0]!==h)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(n.dims[0]!==o.dims[1])throw new Error(\'Input "bias" dimension 0 should have same length as dimension 1 of input "weights"\');let v=n.dims[0]/3,y=v,b=y;if(t.qkvHiddenSizes.length>0){if(t.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let B of t.qkvHiddenSizes)if(B%t.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");v=t.qkvHiddenSizes[0],y=t.qkvHiddenSizes[1],b=t.qkvHiddenSizes[2]}let w=p;if(v!==y)throw new Error("qkv_hidden_sizes first element should be same as the second");if(n.dims[0]!==v+y+b)throw new Error(\'Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes\');let S=0;if(u){if(y!==b)throw new Error(\'Input "past" expect k_hidden_size == v_hidden_size\');if(u.dims.length!==5)throw new Error(\'Input "past" must have 5 dimensions\');if(u.dims[0]!==2)throw new Error(\'Input "past" first dimension must be 2\');if(u.dims[1]!==a)throw new Error(\'Input "past" second dimension must be batch_size\');if(u.dims[2]!==t.numHeads)throw new Error(\'Input "past" third dimension must be num_heads\');if(u.dims[4]!==y/t.numHeads)throw new Error(\'Input "past" fifth dimension must be k_hidden_size / num_heads\');t.pastPresentShareBuffer||(S=u.dims[3])}let C=w+S,A=-1,I=0;if(s)throw new Error("Mask not supported");if(u)throw new Error("past is not supported");if(d)throw new Error("relativePositionBias is not supported");return{batchSize:a,sequenceLength:p,pastSequenceLength:S,kvSequenceLength:w,totalSequenceLength:C,maxSequenceLength:A,inputHiddenSize:h,hiddenSize:v,vHiddenSize:b,headSize:Math.floor(v/t.numHeads),vHeadSize:Math.floor(b/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:I,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},fa=e=>re({...e}),Sl=(e,t,r,o)=>{let n=Ze(o),s=q("x",t.dataType,t.dims,n),u="threadMaxVector";n===2?u="max(threadMaxVector.x, threadMaxVector.y)":n===4&&(u="max(max(threadMaxVector.x, threadMaxVector.y), max(threadMaxVector.z, threadMaxVector.w))");let d=Ie(t.dataType),a=64,p=o/n;p<a?a=1:p/8<64&&(a=Math.ceil(p/8));let h=Math.ceil(o/n/a),v=y=>`\n  const dInv: ${d} = 1 / ${o};\n  const dComp = ${o/n};\n  var<workgroup> wgMax: array<f32, ${a}>;\n  var<workgroup> wgSum: array<f32, ${a}>;\n\n  ${y.declareVariables(s)}\n  @compute @workgroup_size(${a}, 1, 1)\n  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_index) local_index : u32) {\n    let localOffset = local_index * ${h};\n    let offset: u32 = workgroup_id.x * dComp + localOffset;\n\n    var threadMaxVector = ${Ue("f32",n,"-3.402823e+38f")};\n    for (var i: u32 = 0; i < ${h} && i + localOffset < dComp; i++) {\n      threadMaxVector = max(${Qe(d,n,"x[offset + i]")}, threadMaxVector);\n    }\n    wgMax[local_index] = ${u};\n    workgroupBarrier();\n\n    var maxValue = -3.402823e+38f;\n    for (var i = 0u; i < ${a}; i++) {\n      maxValue = max(wgMax[i], maxValue);\n    }\n\n    var sumVector = ${Ue("f32",n,"0")};\n    for (var i: u32 = 0; i < ${h} && i + localOffset < dComp; i++) {\n      sumVector += exp(${Qe(d,n,"x[offset + i]")} - maxValue);\n    }\n    wgSum[local_index] = ${Je("sumVector",n)};\n    workgroupBarrier();\n\n    var sum: f32 = 0;\n    for (var i = 0u; i < ${a}; i++) {\n      sum += wgSum[i];\n    }\n\n    if (sum == 0) {\n      for (var i: u32 = 0; i < ${h} && i + localOffset < dComp; i++) {\n        x[offset + i] = ${Ue(d,n,"dInv")};\n      }\n    } else {\n      for (var i: u32 = 0; i < ${h} && i + localOffset < dComp; i++) {\n        let f32input = ${Qe(d,n,"x[offset + i]")};\n        x[offset + i] = ${s.type.value}(exp(f32input - maxValue) / sum);\n      }\n    }\n  }`;e.compute({name:"AttentionProbsSoftmax",shaderCache:{hint:`${o}`},getShaderSource:v,getRunData:()=>({outputs:[],dispatchGroup:{x:r}})},{inputs:[t],outputs:[]})},xl=(e,t,r,o,n,s)=>{let u=[n.batchSize,n.numHeads,n.sequenceLength,n.kvSequenceLength+n.pastSequenceLength],d=s.scale===0?1/Math.sqrt(n.headSize):s.scale,a=Ie(t.dataType),p=Ze(n.headSize),h=G("q",t.dataType,t.dims,p),v=G("key",r.dataType,r.dims,p),y=q("output",t.dataType,u),b=n.headSize/p,w=n.sequenceLength,S=n.totalSequenceLength,C=b,A=12,I={x:Math.ceil(n.totalSequenceLength/A),y:Math.ceil(n.sequenceLength/A),z:n.batchSize*n.numHeads},B=[t,r],_=E=>`\n  const M: u32 = ${w}u;\n  const N: u32 = ${S}u;\n  const K: u32 = ${C}u;\n  const alpha: ${a} = ${d};\n  const beta: ${a} = 1.0;\n  const TILE_SIZE = ${A}u;\n\n  var<workgroup> tileQ: array<${h.type.storage}, ${A*A}>;\n  var<workgroup> tileK: array<${h.type.storage}, ${A*A}>;\n\n  ${E.declareVariables(h,v,y)}\n\n  @compute @workgroup_size(${A}, ${A}, 1)\n  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,\n   @builtin(local_invocation_id) local_id : vec3<u32>, @builtin(local_invocation_index) local_index : u32) {\n   let global_idx = (workgroup_id.z * ${I.x*I.y}u +\n          workgroup_id.y * ${I.x}u + workgroup_id.x) * ${A*A}u + local_index;\n\n    // x holds the N and y holds the M\n    let headIdx = workgroup_id.z;\n    let m = workgroup_id.y * TILE_SIZE;\n    let n = workgroup_id.x * TILE_SIZE;\n    let lm = m + local_id.y;\n    let ln = n + local_id.x;\n\n    let qOffset = ${n.sequenceLength*b} * headIdx + m * K;\n    let kOffset = ${n.kvSequenceLength*b} * headIdx + n * K;\n\n    var value = ${Ue(a,p)};\n    for (var w: u32 = 0u; w < K; w += TILE_SIZE) {\n      if (m + local_id.y < M && w + local_id.x < K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * K + w + local_id.x];\n      }\n      if (n + local_id.y < N && w + local_id.x < K) {\n        tileK[TILE_SIZE * local_id.y + local_id.x] = key[kOffset + local_id.y * K + w + local_id.x];\n      }\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < K; k++) {\n        value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = headIdx * M * N;\n    if (lm < M && ln < N) {\n      let outputIdx = headOffset + lm * N + ln;\n      output[outputIdx] = ${Je("value",p)} * alpha;\n    }\n  }`,R=e.compute({name:"AttentionProbs",shaderCache:{hint:JSON.stringify(n)},getRunData:()=>({outputs:[{dims:u,dataType:t.dataType,gpuDataType:0}],dispatchGroup:I}),getShaderSource:_},{inputs:B,outputs:[-1]})[0];return Sl(e,R,n.batchSize*n.numHeads*n.sequenceLength,n.totalSequenceLength),R},Cl=(e,t,r,o)=>{let n=[o.batchSize,o.sequenceLength,o.vHiddenSize],s=G("probs",t.dataType,t.dims),u=G("v",r.dataType,r.dims),d=q("output",t.dataType,n),a=Ie(t.dataType),p=12,h={x:Math.ceil(o.vHeadSize/p),y:Math.ceil(o.sequenceLength/p),z:o.batchSize*o.numHeads},v=y=>`\n  const M: u32 = ${o.sequenceLength}u;\n  const N: u32 = ${o.vHeadSize}u;\n  const K: u32 = ${o.totalSequenceLength}u;\n  const numHeads: u32 = ${o.numHeads}u;\n  const TILE_SIZE = ${p}u;\n\n  var<workgroup> tileQ: array<${s.type.storage}, ${p*p}>;\n  var<workgroup> tileK: array<${s.type.storage}, ${p*p}>;\n\n  ${y.declareVariables(s,u,d)}\n\n  @compute @workgroup_size(${p}, ${p}, 1)\n  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,\n   @builtin(local_invocation_id) local_id : vec3<u32>, @builtin(local_invocation_index) local_index : u32) {\n   let global_idx = (workgroup_id.z * ${h.x*h.y}u +\n          workgroup_id.y * ${h.x}u + workgroup_id.x) * ${p*p}u + local_index;\n\n   let headIdx = workgroup_id.z;\n   let m = workgroup_id.y * TILE_SIZE + local_id.y;\n   let n = workgroup_id.x * TILE_SIZE + local_id.x;\n\n   let offsetA = headIdx * (M * K) + m * K;\n   let offsetB = headIdx * (N * K) + n;\n\n   var value = ${a}(0);\n   for (var w: u32 = 0u; w < K; w += TILE_SIZE) {\n     if (m < M && w + local_id.x < K) {\n       tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\n     }\n     if (n < N && w + local_id.y < K) {\n       tileK[TILE_SIZE * local_id.y + local_id.x] = v[offsetB + (w + local_id.y) * N];\n     }\n     workgroupBarrier();\n     for (var k: u32 = 0u; k<TILE_SIZE && w+k < K; k++) {\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];\n     }\n     workgroupBarrier();\n   }\n\n   // we need to transpose output from BNSH_v to BSND_v\n   let batchIdx = workgroup_id.z / ${o.numHeads};\n   let currentBatchHeadNumber = workgroup_id.z % ${o.numHeads};\n   let headOffset = (batchIdx * M * ${o.numHeads} + currentBatchHeadNumber) * ${o.vHeadSize};\n   if (m < M && n < N) {\n     let outputIdx = batchIdx * ${o.sequenceLength*o.vHiddenSize} + m * ${o.vHiddenSize}\n       + currentBatchHeadNumber * ${o.vHeadSize} + n;\n     output[outputIdx] = value;\n   }\n  }`;return e.compute({name:"AttentionScore",shaderCache:{hint:JSON.stringify(o)},getRunData:()=>({outputs:[{dims:n,dataType:t.dataType,gpuDataType:0}],dispatchGroup:h}),getShaderSource:v},{inputs:[t,r],outputs:[0]})[0]},Vr=(e,t,r,o,n,s,u,d,a,p,h)=>{let v=xl(e,t,r,a,p,h);Cl(e,v,o,p)},Il=(e,t)=>{let r=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],o=Ie(e.inputs[0].dataType),n=t.sequenceLength,s=t.inputHiddenSize,u=t.headSize,d=12,a={x:Math.ceil(t.headSize/d),y:Math.ceil(t.sequenceLength/d),z:t.batchSize*t.numHeads},p=()=>`\n  const M: u32 = ${n}u;\n  const K: u32 = ${s}u;\n  const N: u32 = ${u}u;\n  const numHeads: u32 = ${t.numHeads};\n  const ldb = ${t.hiddenSize+t.hiddenSize+t.vHiddenSize}u;\n  const TILE_SIZE = ${d}u;\n\n  var<workgroup> tileInput: array<${o}, ${d*d}>;\n  var<workgroup> tileWeightQ: array<${o}, ${d*d}>;\n  var<workgroup> tileWeightK: array<${o}, ${d*d}>;\n  var<workgroup> tileWeightV: array<${o}, ${d*d}>;\n\n  @group(0) @binding(0) var<storage, read> input: array<${o}>;\n  @group(0) @binding(1) var<storage, read> weight: array<${o}>;\n  @group(0) @binding(2) var<storage, read> bias: array<${o}>;\n  @group(0) @binding(3) var<storage, read_write> outputQ: array<${o}>;\n  @group(0) @binding(4) var<storage, read_write> outputK: array<${o}>;\n  @group(0) @binding(5) var<storage, read_write> outputV: array<${o}>;\n\n  @compute @workgroup_size(${d}, ${d}, 1)\n  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,\n   @builtin(local_invocation_id) local_id : vec3<u32>, @builtin(local_invocation_index) local_index : u32) {\n   let global_idx = (workgroup_id.z * ${a.x*a.y}u +\n          workgroup_id.y * ${a.x}u + workgroup_id.x) * ${d*d}u + local_index;\n\n    let batchIndex = workgroup_id.z / ${t.numHeads};\n    let headNumber = workgroup_id.z % ${t.numHeads};\n    let m = workgroup_id.y * TILE_SIZE + local_id.y;\n    let n = workgroup_id.x * TILE_SIZE + local_id.x;\n\n    let inputOffset = batchIndex * (M * K) + m * K;\n    let biasOffsetQ = headNumber * ${t.headSize};\n    let biasOffsetK = ${t.hiddenSize} + biasOffsetQ;\n    let biasOffsetV = ${t.hiddenSize} + biasOffsetK;\n\n    var valueQ = ${o}(0);\n    var valueK = ${o}(0);\n    var valueV = ${o}(0);\n    for (var w: u32 = 0u; w < K; w += TILE_SIZE) {\n      if (m < M && w + local_id.x < K) {\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\n      }\n      if (n < N && w + local_id.y < K) {\n        let offset = n + (w + local_id.y) * ldb;\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\n      }\n      workgroupBarrier();\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < K; k++) {\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = (m * N + n) % ${t.headSize};\n    valueQ += bias[headOffset + biasOffsetQ];\n    valueK += bias[headOffset + biasOffsetK];\n    valueV += bias[headOffset + biasOffsetV];\n\n    let offset = workgroup_id.z * M * N;\n    if (m < M && n < N) {\n      let outputIdx = offset + m * N + n;\n      outputQ[outputIdx] = valueQ;\n      outputK[outputIdx] = valueK;\n      outputV[outputIdx] = valueV;\n    }\n  }`,h=[e.inputs[0],e.inputs[1],e.inputs[2]];return e.compute({name:"AttentionPrepare",shaderCache:{hint:JSON.stringify(t)},getRunData:()=>({outputs:[{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:a}),getShaderSource:p},{inputs:h,outputs:[-1,-1,-1]})},ma=(e,t)=>{let r=$l(e.inputs,t),[o,n,s]=Il(e,r);return Vr(e,o,n,s,e.inputs[4],void 0,void 0,void 0,e.inputs[5],r,t)}});var Al,_l,ha,ga=F(()=>{"use strict";me();be();Al=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},_l=e=>{let t=e[0].dims,r=e[0].dims[2],o=z.size(t)/4,n=e[0].dataType,s=G("input",n,t,4),u=G("bias",n,[r],4),d=G("residual",n,t,4),a=q("output",n,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:h=>`\n  const channels = ${r}u / 4;\n  ${h.declareVariables(s,u,d,a)}\n\n  ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n    let value = ${s.getByOffset("global_idx")}\n      + ${u.getByOffset("global_idx % channels")} + ${d.getByOffset("global_idx")};\n    ${a.setByOffset("global_idx","value")}\n  }`}},ha=e=>{Al(e.inputs),e.compute(_l(e.inputs))}});var Tl,$e,ya,ba,wa,va,$a,Sa,xa,Ca,Ia,El,Aa,_a,Ta,Ea,Nr,Oa,Ur,ka,Pa,Ra,Ba,Ma,Da,za,Wa,Va,Na,Ua,Ha,Ga,La,Fa,ja,qa,Tn=F(()=>{"use strict";De();me();Ee();be();Tl=(e,t,r,o,n,s)=>{let u=Math.ceil(t/4),d="";typeof n=="string"?d=`${n}(a)`:d=n("a");let a=G("inputData",r,[u],4),p=q("outputData",o,[u],4);return`\n      ${e.registerUniform("vec_size","u32").declareVariables(a,p)}\n\n  ${s??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n\n    let a = ${a.getByOffset("global_idx")};\n    ${p.setByOffset("global_idx",d)}\n  }`},$e=(e,t,r,o,n,s=e.dataType)=>({name:t,shaderCache:{hint:n,inputDependencies:["type"]},getShaderSource:u=>Tl(u,z.size(e.dims),e.dataType,s,r,o),getRunData:u=>({outputs:[{dims:e.dims,dataType:s}],dispatchGroup:{x:Math.ceil(z.size(u[0].dims)/64/4)},programUniforms:[{type:"uint32",data:Math.ceil(z.size(e.dims)/4)}]})}),ya=e=>{e.compute($e(e.inputs[0],"Abs","abs"))},ba=e=>{e.compute($e(e.inputs[0],"Acos","acos"))},wa=e=>{e.compute($e(e.inputs[0],"Acosh","acosh"))},va=e=>{e.compute($e(e.inputs[0],"Asin","asin"))},$a=e=>{e.compute($e(e.inputs[0],"Asinh","asinh"))},Sa=e=>{e.compute($e(e.inputs[0],"Atan","atan"))},xa=e=>{e.compute($e(e.inputs[0],"Atanh","atanh"))},Ca=e=>re(e),Ia=(e,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${t.to}`)}e.compute($e(e.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},El=e=>{let t=e.length>=2?e[1].getFloat32Array()[0]:Mr,r=e.length>=3?e[2].getFloat32Array()[0]:Dr;return re({min:t,max:r})},Aa=(e,t)=>{let r=e.inputs.length===1?t:El(e.inputs),o=Ie(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Clip",n=>`clamp(${n}, clip_min_, clip_max_)`,`\n    const clip_min_: vec4<${o}> = vec4(${o}(${r.min}));\n    const clip_max_: vec4<${o}> = vec4(${o}(${r.max}));\n`,r.cacheKey),{inputs:[0]})},_a=e=>{e.compute($e(e.inputs[0],"Ceil","ceil"))},Ta=e=>{e.compute($e(e.inputs[0],"Cos","cos"))},Ea=e=>{e.compute($e(e.inputs[0],"Cosh","cosh"))},Nr=e=>re(e),Oa=(e,t)=>{e.compute($e(e.inputs[0],"Elu",r=>`elu_vf32(${r})`,`\n  const elu_alpha_: f32 = f32(${t.alpha});\n\n  fn elu_f32(a: f32) -> f32 {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},Ur=(e,t="f32")=>`\nconst r0: ${t} = 0.3275911;\nconst r1: ${t} = 0.254829592;\nconst r2: ${t} = -0.284496736;\nconst r3: ${t} = 1.421413741;\nconst r4: ${t} = -1.453152027;\nconst r5: ${t} = 1.061405429;\n\nfn erf_vf32(v: ${e}) -> ${e} {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,ka=e=>{let t=Ie(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Erf",r=>`erf_vf32(${r})`,Ur(`vec4<${t}>`,t)))},Pa=e=>{e.compute($e(e.inputs[0],"Exp","exp"))},Ra=e=>{e.compute($e(e.inputs[0],"Floor","floor"))},Ba=e=>{let t=Ie(e.inputs[0].dataType);e.compute($e(e.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,Ur(`vec4<${t}>`,t)))},Ma=(e,t)=>{e.compute($e(e.inputs[0],"LeakyRelu",r=>`select(leaky_relu_alpha_ * ${r}, ${r}, ${r} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${t.alpha});`,t.cacheKey))},Da=e=>{e.compute($e(e.inputs[0],"Not",t=>`!${t}`))},za=e=>{e.compute($e(e.inputs[0],"Neg",t=>`-${t}`))},Wa=e=>{e.compute($e(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},Va=e=>{e.compute($e(e.inputs[0],"Relu",t=>`select(vec4<f32>(0.0), ${t}, ${t} > vec4<f32>(0.0))`))},Na=e=>{e.compute($e(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},Ua=e=>{e.compute($e(e.inputs[0],"Sin","sin"))},Ha=e=>{e.compute($e(e.inputs[0],"Sinh","sinh"))},Ga=e=>{e.compute($e(e.inputs[0],"Sqrt","sqrt"))},La=e=>{e.compute($e(e.inputs[0],"Tan","tan"))},Fa=e=>{e.compute($e(e.inputs[0],"Tanh","tanh"))},ja=(e,t)=>(e.compute($e(e.inputs[0],"ThresholdedRelu",r=>`select(vec4<f32>(0.0), ${r}, ${r} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${t.alpha});`,t.cacheKey)),0),qa=e=>{e.compute($e(e.inputs[0],"Log","log"))}});var kl,Pl,Ka,Ya=F(()=>{"use strict";me();be();Tn();kl=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Pl=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=G("input",e[0].dataType,e[0].dims,4),o=G("bias",e[0].dataType,[e[0].dims[2]],4),n=q("output",e[0].dataType,t,4),s=z.size(t)/4;return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:d=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${d.declareVariables(r,o,n)}\n\n  ${Ur("vec4f")}\n\n  ${d.mainStart()}\n    ${d.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${n.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},Ka=e=>{kl(e.inputs),e.compute(Pl(e.inputs))}});var Rl,Bl,dt,Za,Xa,Qa,Ja,ei,ti,ri,ni,oi,ai,ii=F(()=>{"use strict";De();me();be();Rl=(e,t,r,o,n,s,u,d,a,p,h,v,y)=>{let b,w;typeof d=="string"?b=w=(E,W)=>`${d}((${E}),(${W}))`:typeof d=="function"?b=w=d:(b=d.scalar,w=d.vector);let S=v?t.length:t,C=v?r.length:r,A=v?o.length:o,I=q("outputData",h,A,4),B=G("aData",a,S,4),_=G("bData",p,C,4),R;if(n)if(s){let E=z.size(t)===1,W=z.size(r)===1,V=t.length>0&&t[t.length-1]%4===0,Y=r.length>0&&r[r.length-1]%4===0;E||W?R=I.setByOffset("global_idx",w(E?`${B.type.value}(${B.getByOffset("0")}.x)`:B.getByOffset("global_idx"),W?`${_.type.value}(${_.getByOffset("0")}.x)`:_.getByOffset("global_idx"))):R=`\n            let outputIndices = ${I.offsetToIndices("global_idx * 4u")};\n            let offsetA = ${B.broadcastedIndicesToOffset("outputIndices",I)};\n            let offsetB = ${_.broadcastedIndicesToOffset("outputIndices",I)};\n            ${I.setByOffset("global_idx",w(u||V?B.getByOffset("offsetA / 4u"):`${B.type.value}(${B.getByOffset("offsetA / 4u")}[offsetA % 4u])`,u||Y?_.getByOffset("offsetB / 4u"):`${_.type.value}(${_.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}\n          `}else R=I.setByOffset("global_idx",w(B.getByOffset("global_idx"),_.getByOffset("global_idx")));else{if(!s)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let E=(W,V,Y="")=>{let ae=`aData[indexA${V}][componentA${V}]`,M=`bData[indexB${V}][componentB${V}]`;return`\n            let outputIndices${V} = ${I.offsetToIndices(`global_idx * 4u + ${V}u`)};\n            let offsetA${V} = ${B.broadcastedIndicesToOffset(`outputIndices${V}`,I)};\n            let offsetB${V} = ${_.broadcastedIndicesToOffset(`outputIndices${V}`,I)};\n            let indexA${V} = offsetA${V} / 4u;\n            let indexB${V} = offsetB${V} / 4u;\n            let componentA${V} = offsetA${V} % 4u;\n            let componentB${V} = offsetB${V} % 4u;\n            ${W}[${V}] = ${Y}(${b(ae,M)});\n          `};h===9?R=`\n            var data = vec4<u32>(0);\n            ${E("data",0,"u32")}\n            ${E("data",1,"u32")}\n            ${E("data",2,"u32")}\n            ${E("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:R=`\n            ${E("outputData[global_idx]",0)}\n            ${E("outputData[global_idx]",1)}\n            ${E("outputData[global_idx]",2)}\n            ${E("outputData[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables(B,_,I)}\n\n        ${y??""}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${R}\n      }`},Bl=(e,t,r,o,n,s,u=r.dataType)=>{let d=!z.areEqual(r.dims,o.dims),a=r.dims,p=z.size(r.dims),h=!1,v=!1,y=[d];if(d){let w=at.calcShape(r.dims,o.dims,!1);if(!w)throw new Error("Can\'t perform binary op on the given tensors");a=w,p=z.size(a);let S=z.size(r.dims)===1,C=z.size(o.dims)===1,A=r.dims.length>0&&r.dims[r.dims.length-1]%4===0,I=o.dims.length>0&&o.dims[o.dims.length-1]%4===0;y.push(S),y.push(C),y.push(A),y.push(I);let B=1;for(let _=1;_<a.length;_++){let R=r.dims[r.dims.length-_]??1,E=o.dims[o.dims.length-_]??1;if(R===E)B*=R;else break}B%4===0?(v=!0,h=!0):(S||C||A||I)&&(h=!0)}else h=!0;y.push(h);let b=Ge(r.dims.length)&&Ge(o.dims.length)&&Ge(a.length);return{name:e,shaderCache:{hint:t+y.map(w=>w.toString()).join("_"),inputDependencies:b?["rank","rank"]:["dims","dims"]},getShaderSource:w=>Rl(w,r.dims,o.dims,a,h,d,v,n,r.dataType,o.dataType,u,b,s),getRunData:()=>({outputs:[{dims:a,dataType:u}],dispatchGroup:{x:Math.ceil(p/64/4)},programUniforms:b?[{type:"uint32",data:Math.ceil(z.size(a)/4)},...Ne(r.dims),...Ne(o.dims),...Ne(a)]:[{type:"uint32",data:Math.ceil(z.size(a)/4)}]})}},dt=(e,t,r,o,n,s)=>{e.compute(Bl(t,n??"",e.inputs[0],e.inputs[1],r,o,s))},Za=e=>{dt(e,"Add",(t,r)=>`${t}+${r}`)},Xa=e=>{dt(e,"Div",(t,r)=>`${t}/${r}`)},Qa=e=>{dt(e,"Equal",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},Ja=e=>{dt(e,"Mul",(t,r)=>`${t}*${r}`)},ei=e=>{let t=G("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;dt(e,"Pow",{scalar:(o,n)=>`pow_custom(${o},${n})`,vector:(o,n)=>`pow_vector_custom(${o},${n})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},ti=e=>{dt(e,"Sub",(t,r)=>`${t}-${r}`)},ri=e=>{dt(e,"Greater",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},ni=e=>{dt(e,"Less",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},oi=e=>{dt(e,"GreaterOrEqual",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},ai=e=>{dt(e,"LessOrEqual",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var Dl,zl,Wl,Vl,si,ui,li=F(()=>{"use strict";me();Ee();be();Dl=e=>{if(!e||e.length<1)throw new Error("too few inputs");let t=e[0].dataType,r=e[0].dims.length;for(let o of e){if(o.dataType!==t)throw new Error("input tensors should be one type");if(o.dims.length!==r)throw new Error("input tensors should have the same shape")}},zl=(e,t)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,Wl=(e,t)=>{let r=e.length,o=[];for(let n=0;n<r;++n){let s=t.setByOffset("global_idx",e[n].getByIndices("indices"));r===1?o.push(s):n===0?o.push(`if (inputIndex == ${n}u) { ${s} }`):n===r-1?o.push(`else { ${s} }`):o.push(`else if (inputIndex == ${n}) { ${s} }`)}return o.join(`\n`)},Vl=(e,t)=>{let r=e[0].dims.slice();if(t>=r.length||t<-1*r.length)throw new Error("axis specified for concat doesn\'t match input dimensionality");let o=t<0?r.length+t:t,n=r.slice(0);for(let _=1;_<e.length;_++){let R=e[_].dims.slice();for(let E=0;E<r.length;E++)if(E===o)n[o]+=R[E];else if(r[E]!==R[E])throw new Error("non concat dimensions must match")}let s=z.size(n),u=new Array(e.length),d=new Array(e.length),a=e[0].dataType,p=0,h=[],v=[],y=[],b=[{type:"uint32",data:s}];for(let _=0;_<e.length;++_)p+=e[_].dims[o],u[_]=p,y.push(Ge(e[_].dims.length)),v.push(y[_]?e[_].dims.length:e[_].dims),d[_]=G(`input${_}`,a,v[_]),h.push(y[_]?"rank":"dims"),b.push({type:"uint32",data:u[_]});for(let _=0;_<e.length;++_)y[_]&&b.push(...Ne(e[_].dims));let w=Ge(n.length);w&&b.push(...Ne(n));let S=w?n.length:n,C=q("output",a,S),A=C.indicesGet("indices",o),I=Array.from(Array(u.length).keys()).map(_=>`uniforms.sizeInConcatAxis${_}`).join(","),B=_=>`\n\n  ${(()=>{_.registerUniform("outputSize","u32");for(let R=0;R<e.length;R++)_.registerUniform(`sizeInConcatAxis${R}`,"u32");return _.declareVariables(...d,C)})()}\n\n  ${zl(u.length,I)}\n\n  ${_.mainStart()}\n    ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n    var indices = ${C.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${A});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${u.length}u>(${I});\n      ${A} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${Wl(d,C)}\n  }`;return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:h},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:b}),getShaderSource:B}},si=(e,t)=>{Dl(e.inputs),e.compute(Vl(e.inputs,t.axis))},ui=e=>re({axis:e.axis})});var vt,Hr,Et=F(()=>{"use strict";me();vt=(e,t)=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:`value = max(value, ${t}(0.0));`};case"Sigmoid":return{activationFunction:"",applyActivation:`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`};case"Clip":return{activationFunction:`const clip_min_=${t}(${e.clipMin});const clip_max_=${t}(${e.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},Hr=e=>{let t=e?.activation||"";if(t==="Clip"){let[r,o]=e?.activation_params||[Mr,Dr];return{activation:t,clipMax:o,clipMin:r,activationCacheKey:`${t}:${r},${o}`}}return{activation:t,activationCacheKey:t}}});var ze,Gr,Lr=F(()=>{"use strict";ze=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Gr=e=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      `});var Fr,En=F(()=>{"use strict";Fr=`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));\n}\n`});var Nl,Ul,sr,di,Hl,ur,Gl,jr,lr=F(()=>{"use strict";me();be();Et();Lr();Nl=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,Ul=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,sr=(e,t,r="f32",o,n=!1,s=32,u=!1,d=32)=>{let a=t[1]*e[1],p=t[0]*e[0],h=n?a:s,v=n?s:a,y=h/t[0],b=s/t[1];if(!((n&&y===4&&e[1]===4||!n&&(y===3||y===4))&&h%t[0]===0&&s%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${n} is true, innerElementSize ${y} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${y} must be 3 or 4.\n  tileAWidth ${h} must be divisible by workgroupSize[0]${t[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${y}<${r}>, ${h/y}>, ${v}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${r}>, ${p/e[0]}>, ${s}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${y};\nconst tileInner = ${s};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${u?"0":"i32(globalId.z)"};\n  ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${a};\n\n  let numTiles = ${u?`${Math.ceil(d/s)}`:"(dimInner - 1) / tileInner + 1"};\n  var kStart = ${u?`i32(globalId.z) * ${d}`:"0"};\n\n  var acc: array<vec4<${r}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${b};\n  for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${Nl(n,o)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${b}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${o?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${y===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${Ul(n,y)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},di=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,Hl=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",ur=(e,t,r="f32",o,n=!1,s=32,u=!1,d=32,a=!1)=>{let p=e[1]*t[1],h=e[0]*t[0],v=n?p:s,y=n?s:p;if(!(y%t[1]===0&&v%t[0]===0&&s%t[1]===0))throw new Error(`tileAHight ${y} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${v} must be divisible by workgroupSize[0]${t[0]}, tileInner ${s} must be divisible by workgroupSize[1]${t[1]}`);let b=y/t[1],w=v/t[0],S=s/t[1],C=a?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${p};\n    let globalColStart = i32(workgroupId.x) * ${h};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${y}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${v}; inputCol = inputCol + ${t[0]}) {\n          ${di(n,o)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${h}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${o?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${r}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${p};\n\nlet tileRowA = i32(localId.y) * ${b};\nlet tileColA = i32(localId.x) * ${w};\nlet tileRowB = i32(localId.y) * ${S};\n// Loop over shared dimension.\nfor (var t = 0; t < numTiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${b}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${w}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${di(n,o)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${S}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${o?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${r}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${Hl(n)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${r}, ${v}>, ${y}>;\n  var<workgroup> mm_Bsub : array<array<${r}, ${h}>, ${s}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${s};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${u?"0":"i32(globalId.z)"};\n    ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n    let numTiles = ${u?`${Math.ceil(d/s)}`:"(dimInner - 1) / tileInner + 1"};\n    var kStart = ${u?`i32(globalId.z) * ${d}`:"0"};\n\n    var acc : array<array<${r}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${C}\n  }\n`},Gl=(e,t,r,o,n,s=!1)=>{let u=n[0],d=n[1],a=n[2],p=o[0],h=o[1],v=o[2],y=o[3],b=Cn(u,a),w=Cn(d,a),S=Ie(o[0].type.tensor),C=()=>{let B=h.rank,_=p.rank,R=`var aIndices: ${h.type.indices};`;for(let E=B-2-1,W=_-1;E>=0;E--,W--)R+=`\naIndices[${E}] = ${_>1?`batchIndices[${W}]`:"batchIndices"};`;return b.forEach(E=>{R+=`\naIndices[${E}] = 0;`}),R+=`\naIndices[${B-2}] = u32(row);\n                   aIndices[${B-1}] = u32(colIn);`,R},A=()=>{let B=v.rank,_=p.rank,R=`var bIndices: ${v.type.indices};`;for(let E=B-2-1,W=_-1;E>=0;E--,W--)R+=`\nbIndices[${E}] = ${_>1?`batchIndices[${W}]`:"batchIndices"};`;return w.forEach(E=>{R+=`\nbIndices[${E}] = 0;`}),R+=`\nbIndices[${B-2}] = u32(row);\n                   bIndices[${B-1}] = u32(colIn);`,R};return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${p.type.indices}) -> ${ze(e,S)} {\n      var value = ${ze(e,S)}(0.0);\n      let col = colIn * ${e};\n      if(row < dimAOuter && col < dimInner)\n      {\n        ${C()}\n        value = ${h.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${p.type.indices}) -> ${ze(e,S)} {\n      var value = ${ze(e,S)}(0.0);\n      let col = colIn * ${e};\n      if(row < dimInner && col < dimBOuter)\n      {\n        ${A()}\n        value = ${v.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${ze(e,S)}) {\n      let col = colIn * ${e};\n      if (row < dimAOuter && col < dimBOuter) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${s?"bias[colIn]":`${ze(e,S)}(bias[row])`};`:""}\n        ${r}\n        ${y.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},jr=(e,t,r,o,n=!1)=>{let s=e[0].dims,u=e[1].dims,d=s.slice(0,-2),a=u.slice(0,-2),p=o?o.slice(0,-2):r.slice(0,-2),h=G("batchDims",e[0].dataType,p),v=[h],y=[d,a,p],b=z.size(p),w=s[s.length-2],S=s[s.length-1],C=u[u.length-1],A=S%4===0&&C%4===0,I=w<=8?[4,1,1]:[4,4,1],B=[8,8,1],_=[Math.ceil(C/B[0]/I[0]),Math.ceil(w/B[1]/I[1]),Math.ceil(b/B[2]/I[2])],R=Ie(e[0].dataType),E=A?4:1,W=G("a",e[0].dataType,[...d,w,S/E],E),V=G("b",e[1].dataType,[...a,S,C/E],E),Y=q("result",e[0].dataType,[b,w,C/E],E);v.push(W),v.push(V),v.push(Y);let ae=[W,V],M=e.length>2,{activationFunction:K,applyActivation:Se}=vt(t,Y.type.value),ue=Gl(E,M,Se,v,y,n);if(M){let j=n?E:1;ae.push(G("bias",e[2].dataType,e[2].dims,j))}let ve=j=>`\n  const dimAOuter: i32 = ${w};\n  const dimBOuter: i32 = ${C};\n  const dimInner: i32 = ${S};\n  ${j.declareVariables(...ae,Y)}\n  ${K}\n  ${ue}\n  ${A?sr(I,B,R,h):ur(I,B,R,h)}\n                   ${h.impl()}`;return{name:"MatMul",shaderCache:{hint:t.activationCacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:_[0],y:_[1],z:_[2]}}),getShaderSource:ve}}});var Ll,ci,pi=F(()=>{"use strict";wt();me();be();Et();Lr();En();lr();Ll=(e,t,r,o,n=!1,s,u=4,d=4,a=4,p="f32")=>{let h=M=>{switch(M){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${p}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${M} is not supported.`)}},v=M=>{switch(M){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${M} is not supported.`)}},y=e?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,b=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,w=e?"xShape[1]":"xShape[2]",S=e?"xShape[2]":"xShape[3]",C=e?"row":"col",A=e?"col":"row",I=`\n    let inChannels = wShape[2];\n    let outWidth = ${e?"outShape[2]":"outShape[3]"};\n    let outRow = ${C} / outWidth;\n    let outCol = ${C} % outWidth;\n\n    let WRow = ${A} / (filterDims[1] * inChannels);\n    let WCol = ${A} / inChannels % filterDims[1];\n    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];\n    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];\n    let xCh = ${A} % inChannels;\n    var resData = ${ze(u,p)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the \'same\' padding type.\n    if (xRow >= 0 && xRow < ${w} && xCol >= 0 && xCol < ${S}) {\n      ${y}\n      let xIndex = getIndexFromCoords4D(coord, xShape);\n      ${h(u)}\n    }\n    return resData;`,B=e?t&&o?`\n    let col = colIn * ${u};\n    ${I}`:`\n    let col = colIn * ${u};\n    if (row < dimAOuter && col < dimInner) {\n      ${I}\n    }\n    return ${ze(u,p)}(0.0);`:o&&r?`\n    let col = colIn * ${u};\n    ${I}`:`\n    let col = colIn * ${u};\n    if (row < dimInner && col < dimBOuter) {\n      ${I}\n    }\n    return ${ze(u,p)}(0.0);`,_=`${v(d)}`,R=ze(a,p),E=e?ze(u,p):ze(d,p),W=e?ze(d,p):ze(u,p),{activationFunction:V,applyActivation:Y}=vt(s,R);return`\n    ${V}\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${E} {\n      ${e?B:_}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${W} {\n      ${e?_:B}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${R}) {\n      let col = colIn * ${a};\n      if (row < dimAOuter && col < dimBOuter)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${b}\n      ${Gr(n)}\n      ${Y}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},ci=(e,t,r,o,n,s,u,d)=>{let a=t.format==="NHWC",p=a?e[0].dims[3]:e[0].dims[1],h=r[0],v=a?r[2]:r[3],y=a?r[1]:r[2],b=a?r[3]:r[1],w=a&&(p%4===0||p%3===0)&&b%4===0,S=a?b:v*y,C=a?v*y:b,A=[8,8,1],I=o<=8?[4,1,1]:[4,4,1],B=[Math.ceil(S/A[0]/I[0]),Math.ceil(C/A[1]/I[1]),Math.ceil(h/A[2]/I[2])];Te("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${B}`);let _=w?a&&p%4!==0?3:4:I[0],R=A[1]*I[1],E=A[0]*I[0],W=Math.max(A[0]*_,A[1]),V=o%R===0,Y=n%E===0,ae=s%W===0,M=w?[_,4,4]:[1,1,1],K=Ie(e[0].dataType),Se=[`@group(0) @binding(0) var<storage, read> x: array<${w&&_===4?`vec4<${K}>`:K}>;`,`@group(0) @binding(1) var<storage, read> w: array<${w?`vec4<${K}>`:K}>;`],ue=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${w?`vec4<${K}>`:K}) {\n        result[flatIndex] = ${w?`vec4<${K}>`:K}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${w?`vec4<${K}>`:K}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${w?"/ 4":""}, value);\n      }`;return u&&(Se.push(`@group(0) @binding(2) var<storage, read> bias: array<${w?`vec4<${K}>`:K}>;`),ue+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${w?`vec4<${K}>`:K} {\n          return bias[coords.${a?"w":"y"}${w?"/ 4":""}];\n        }`),{name:"Conv2DMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:B[0],y:B[1],z:B[2]}}),getShaderSource:()=>`\n        ${Fr}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${Se.join("")}\n        @group(0) @binding(${Se.length}) var<storage, read_write> result: array<${w?`vec4<${K}>`:K}>;\n        //@group(0) @binding(${Se.length+1}) var<uniform> uniforms: Uniforms;\n\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${z.computeStrides(r).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[0]}, ${t.kernelShape[1]});\n        const pad : vec2<i32> = vec2<i32>(${t.pads[0]}, ${t.pads[1]});\n        const stride : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${o};\n        const dimBOuter : i32 = ${n};\n        const dimInner : i32 = ${s};\n        ${ue}\n        ${Ll(a,V,Y,ae,u,t,M[0],M[1],M[2],K)}\n            ${w?sr(I,A,K,void 0,!a,W):ur(I,A,K,void 0,!a,W,!1,void 0,d)}`}}});var On,fi=F(()=>{"use strict";me();be();Pn();Et();On=(e,t,r)=>{let o=e.length>2,n=o?"value += b[output_channel];":"",s=e[0].dims,u=e[1].dims,d=u[0]/t.group,a=t.format==="NHWC",p=kn(s,u,t.dilations,t.pads,t.strides,a),h=z.size(p),v=q("output",e[0].dataType,p),{activationFunction:y,applyActivation:b}=vt(t,v.type.value),w=G("x",e[0].dataType,s),S=G("w",e[1].dataType,u),C=[w,S];o&&C.push(G("b",e[2].dataType,e[2].dims));let A=I=>`\n  const strides: vec2<u32> = vec2(${t.strides[0]}u, ${t.strides[1]}u);\n  const pads: vec2<u32> = vec2(${t.pads[0]}u, ${t.pads[1]}u);\n\n  ${I.declareVariables(...C,v)}\n\n  ${y}\n\n  ${I.mainStart()}\n    ${I.guardAgainstOutOfBoundsWorkgroupSizes(h)}\n\n    let outputIndices = ${v.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${a?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${a?1:2}], outputIndices[${a?2:3}]) * strides - pads;\n    let group_id: u32 = output_channel / ${d}u;\n\n    var value: ${v.type.value} = ${v.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < ${u[1]}u; wInChannel++) {\n      let input_channel = group_id * ${u[1]}u + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < ${u[2]}u; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * ${t.dilations[0]}u;\n\n        if (xHeight < 0u || xHeight >= ${s[a?1:2]}u) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < ${u[3]}u; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * ${t.dilations[1]}u;\n          if (xWidth < 0u || xWidth >= ${s[a?2:3]}u) {\n            continue;\n          }\n\n          let xVal = ${a?w.get("batch","xHeight","xWidth","input_channel"):w.get("batch","input_channel","xHeight","xWidth")};\n          let wVal = ${S.get("output_channel","wInChannel","wHeight","wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${n}\n    ${b}\n    ${v.setByOffset("global_idx","value")}\n  }`;return{name:"GroupedConv",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r?r(p):p,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)}}),getShaderSource:A}}});var kn,mi,Fl,hi,Rn,jl,ql,Bn,Pn=F(()=>{"use strict";me();Ee();pi();lr();fi();Et();Wt();kn=(e,t,r,o,n,s)=>{let u=e[0],d=e.slice(s?1:2,s?3:4),a=d.length,p=t[0],v=t.slice(2).map((w,S)=>w+(w-1)*(r[S]-1)),b=d.map((w,S)=>w+o[S]+o[S+a]).map((w,S)=>Math.floor((w-v[S]+n[S])/n[S]));return b.splice(0,0,u),b.splice(s?3:1,0,p),b},mi=[2,3,1,0],Fl=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[1]*t.group;if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==n*2)throw new Error(`pads should be ${n*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},hi=(e,t)=>{let r=e.kernelShape.slice();for(let s=2;s<t[1].dims.length;++s)r[s-2]===0&&(r[s-2]=t[1].dims[s]);let o=e.pads.slice();Tt.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,o,e.format==="NHWC",e.autoPad);let n=Object.assign({},e);return Object.assign(n,{kernelShape:r,pads:o,cacheKey:e.cacheKey}),n},Rn=e=>{let t=Hr(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],n=e.dilations,s=e.group,u=e.kernel_shape,d=e.pads,a=e.strides,p=e.w_is_const();return re({autoPad:o,format:r,dilations:n,group:s,kernelShape:u,pads:d,strides:a,wIsConst:p,...t})},jl=(e,t,r)=>{let o=hi(r,t);if(r.group!==1){e.compute(On(t,o));return}let n=r.format==="NHWC",s=t.length===3,u=t[0].dims[n?1:2],d=t[0].dims[n?2:3],a=t[0].dims[n?3:1],p=t[1].dims[2],h=t[1].dims[3],v=kn(t[0].dims,t[1].dims,r.dilations,o.pads,r.strides,n),y=v[n?1:2],b=v[n?2:3],w=v[n?3:1],S=n&&p===u&&h===d&&r.pads[0]===0&&r.pads[1]===0;if(S||p===1&&h===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let E=v[0],W,V,Y,ae=[];if(n){let M=e.kernelCustomData.wT??e.compute(et(t[1],mi),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=M),S){let K=u*d*a;W=t[0].reshape([1,E,K]),V=M.reshape([1,K,w]),Y=[1,E,w]}else W=t[0].reshape([E,u*d,a]),V=M.reshape([1,a,w]),Y=[E,y*b,w];ae.push(W),ae.push(V)}else W=t[0].reshape([E,a,u*d]),V=t[1].reshape([1,w,a]),Y=[E,w,y*b],ae.push(V),ae.push(W);s&&ae.push(t[2]),e.compute(jr(ae,o,v,Y,n),{inputs:ae});return}let C=!0,A=e.kernelCustomData.wT??e.compute(et(t[1],mi),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=A);let I=[t[0],A];s&&I.push(t[2]);let B=n?y*b:w,_=n?w:y*b,R=p*h*a;e.compute(ci(I,o,v,B,_,R,s,C),{inputs:I})},ql=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&o.push(e.inputs[2]);let n=[0,t.pads[0],0,t.pads[1]],s=[1].concat(t.strides),u=[1].concat(t.dilations),d=[1].concat(t.kernelShape),a=hi({...t,pads:n,strides:s,dilations:u,kernelShape:d},o);e.compute(On(o,a,p=>r?[p[0],p[2],p[3]]:[]))},Bn=(e,t)=>{Fl(e.inputs,t),e.inputs[0].dims.length===3?ql(e,t):jl(e,e.inputs,t)}});var Kl,gi,yi=F(()=>{"use strict";wt();me();Et();Lr();En();lr();Kl=(e,t=!1,r,o=4)=>{let n=ze(o,"f32"),s=I=>{switch(I){case 1:return"return W[getIndexFromCoords4D(coord, wShape)];";case 4:return`\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            `;default:throw new Error(`innerElementSize ${I} is not supported.`)}},u=e?`\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      `:`\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      `,d=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,a=e?"outBackprop[1]":"outBackprop[2]",p=e?"outBackprop[2]":"outBackprop[3]",h=e?"row":"col",v=e?"col":"row",y=`\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      let outRow = ${h} / outWidth;\n      let outCol = ${h} % outWidth;\n\n      let WRow = ${v} / (filterDims[1] * inChannels);\n      let WCol = ${v} / inChannels % filterDims[1];\n      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);\n      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);\n      if (xR < 0.0 || xR >= f32(${a}) || fract(xR) > 0.0) {\n        return ${n}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${p}) || fract(xC) > 0.0) {\n        return ${n}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${v} % inChannels;\n      ${u}\n      return x[getIndexFromCoords4D(coord, xShape)/${o}];`,b=e?`\n      let col = colIn * ${o};\n      if (row < dimAOuter && col < dimInner) {\n        ${y}\n      }\n      return ${n}(0.0);`:`\n      let col = colIn * ${o};\n      if (row < dimInner && col < dimBOuter) {\n        ${y}\n      }\n      return ${n}(0.0);`,w=`\n      let col = colIn * ${o};\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);\n      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];\n      if (${e?"row < dimInner && col < dimBOuter":"row < dimInner && col < dimAOuter"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${s(o)}\n      }\n      return ${n}(0.0);\n      `,{activationFunction:S,applyActivation:C}=vt(r,n);return`\n      ${S}\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${n} {\n    ${e?b:w}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${n} {\n    ${e?w:b}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${n}) {\n    let col = colIn * ${o};\n    if (row < dimAOuter && col < dimBOuter) {\n      var value = valueInput;\n      let outWidth = ${e?"outShape[2]":"outShape[3]"};\n      ${d}\n      ${Gr(t)}\n      ${C}\n      result[getIndexFromCoords4D(coords, outShape)/${o}] = value;\n    }\n  }`},gi=(e,t,r,o,n,s,u,d)=>{let a=t.format==="NHWC",p=a?e[0].dims[3]:e[0].dims[1],h=r[0],v=a?r[2]:r[3],y=a?r[1]:r[2],b=a?r[3]:r[1],w=a?p%4===0&&b%4===0:v%4===0&&b%4===0,S=a?b:v*y,C=a?v*y:b,A=w?[8,8,1]:[S<=4||C<=4?4:16,S>4&&C<=4?4:16,1],I=w?[4,4,1]:[S<=4?1:4,S>4&&C<=4?1:4,1],B=[Math.ceil(S/A[0]/I[0]),Math.ceil(C/A[1]/I[1]),Math.ceil(h/A[2]/I[2])];Te("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${B}`);let _=w?4:1,R=Math.max(A[0]*_,A[1]),E=[`@group(0) @binding(0) var<storage, read> x: array<${w?"vec4<f32>":"f32"}>;`,"@group(0) @binding(1) var<storage, read> W: array<f32>;"],W="";return u&&(E.push(`@group(0) @binding(2) var<storage, read> bias: array<${w?"vec4<f32>":"f32"}>;`),W+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${w?"vec4<f32>":"f32"} {\n          return bias[coords.${a?"w":"y"}${w?"/ 4":""}];\n        }`),{name:"Conv2DTransposeMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:B[0],y:B[1],z:B[2]}}),getShaderSource:()=>`\n        ${Fr}\n        ${E.join(`\n`)}\n        @group(0) @binding(${E.length}) var<storage, read_write> result: array<${w?"vec4<f32>":"f32"}>;\n        const outBackprop : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const xShape : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const wShape : vec4<i32> = vec4<i32>(${e[1].dims.join(",")});\n        const outShape : vec4<i32> = vec4<i32>(${r.join(",")});\n        const outShapeStrides : vec3<i32> = vec3<i32>(${z.computeStrides(r).slice(0,3).join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[a?1:2]}, ${t.kernelShape[a?2:3]});\n        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(\n              ${t.dilations[0]<=1?0:(t.kernelShape[a?1:2]-1)*(t.dilations[0]-1)},\n              ${t.dilations[1]<=1?0:(t.kernelShape[a?2:3]-1)*(t.dilations[1]-1)});\n        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${t.pads[0]+t.pads[2]})/2,\n                                         i32(effectiveFilterDims[1]) - 1 - (${t.pads[1]+t.pads[3]})/2);\n        const strides : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${o};\n        const dimBOuter : i32 = ${n};\n        const dimInner : i32 = ${s};\n        ${W}\n        ${Kl(a,u,t,_)}\n        ${w?sr(I,A,"f32",void 0,!a,R):ur(I,A,"f32",void 0,!a,R,!1,void 0,d)}`}}});var Yl,Mn,bi=F(()=>{"use strict";wt();me();be();Yl=(e,t,r,o,n,s,u=!1,d)=>{let a=r.format==="NHWC",p=a?1:2,h=a?2:3,v=a?3:1,y=z.size(o),b=u?2:1,w=r.group,S=t[1].dims,C=S[0]/w,A=S[1],I=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${u?`vec4<${d}>`:d}) {\n    result[flatIndex] = ${u?`vec4<${d}>`:d}(value);\n  }`;n&&(I+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${u?`vec4<${d}>`:d} {\n      return bias[coords.${a?"w":"y"}${u?"/ 4":""}];\n    }`);let B=u?4:1,_=G("W",t[1].dataType,t[1].dims,B),R=G("Dy",t[0].dataType,t[0].dims,B),E=[R,_];n&&E.push(G("bias",t[2].dataType,[o[v]],B));let W=q("result",t[0].dataType,o,B),V=`{\n        let batch: u32 = ${s?"global_id.z":"workgroup_id.z"} / outShape[1];\n        let r = ${s?"global_id.z":"workgroup_id.z"} % outShape[1];\n        let c = ${s?"global_id.y":"workgroup_id.y"} * ${b};\n        let d1: u32 = ${s?"global_id.x":"workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${d}>, ${b}>;\n        for (var i = 0; i < ${b}; i++) {\n          dotProd[i] = vec4<${d}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {\n          var dyR = (${d}(dyCorner.x) + ${d}(wR)) / ${d}(strides.x);\n          let wRPerm = filterDims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${d}(outBackprop[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {\n            let dyC = (${d}(dyCorner.y) + ${d}(wC)) / ${d}(strides.y);\n            let dyC2 = (${d}(dyCorner.y) + 1.0 + ${d}(wC)) / ${d}(strides.y);\n            let wCPerm = filterDims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${d}(outBackprop[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${d}(outBackprop[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${_.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${_.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${_.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${_.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${R.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${R.get("batch","idyR","idyC2","d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${d}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = outBackprop[${v}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${_.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${_.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${_.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${_.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${R.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${_.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${_.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${_.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${_.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${R.get("batch","idyR","idyC2","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${b}; i = i + 1) {\n          let value = dotProd[i] + ${n?"bias[c+i]":"0.0"};\n          ${W.set("batch","r","c + i","d1","value")};\n        }\n      }`,Y=`\n          let outputIndices = ${W.offsetToIndices("global_idx")};\n          let batch = ${W.indicesGet("outputIndices",0)};\n          let d1 = ${W.indicesGet("outputIndices",v)};\n          let r = ${W.indicesGet("outputIndices",p)};\n          let c = ${W.indicesGet("outputIndices",h)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / ${A};\n          let wOutChannel = d1 - groupId * ${A};\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = 0.0;\n          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {\n            if (wR % dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${d}(dyRCorner) + ${d}(wR)) / ${d}(strides[0]);\n            let wRPerm = filterDims.x - 1 - wR / dilations.x;\n            if (dyR < 0.0 || dyR >= ${d}(outBackprop[${p}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {\n              if (wC % dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${d}(dyCCorner) + ${d}(wC)) / ${d}(strides.y);\n              let wCPerm = filterDims.y - 1 - wC / dilations.y;\n              if (dyC < 0.0 || dyC >= ${d}(outBackprop[${h}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * ${C};\n              for (var d2: u32 = 0; d2 < ${C}; d2 = d2 + 1) {\n                let xValue = ${a?R.get("batch","idyR","idyC","inputChannel"):R.get("batch","inputChannel","idyR","idyC")};\n                let wValue = ${_.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${n?"bias[d1]":"0.0"};\n          ${W.setByOffset("global_idx","value")};\n        `;return`\n  ${e.declareVariables(...E,W)}\n  ${I}\n  const outShape : vec4<u32> = vec4<u32>(${o.join(",")});\n  const outBackprop : vec4<u32> = vec4<u32>(${t[0].dims.join(",")});\n  const strides : vec2<u32> = vec2<u32>(${r.strides[0]}, ${r.strides[1]});\n  const filterDims : vec2<u32> = vec2<u32>(${r.kernelShape[a?1:2]}, ${r.kernelShape[a?2:3]});\n  const dilations : vec2<u32> = vec2<u32>(${r.dilations[0]}, ${r.dilations[1]});\n  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(\n          ${r.dilations[0]<=1?0:(r.kernelShape[a?1:2]-1)*(r.dilations[0]-1)},\n          ${r.dilations[1]<=1?0:(r.kernelShape[a?2:3]-1)*(r.dilations[1]-1)});\n  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${r.pads[0]+r.pads[2]})/2,\n                                     i32(effectiveFilterDims[1]) - 1 - (${r.pads[1]+r.pads[3]})/2);\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(y)};\n  ${u?V:Y}}`},Mn=(e,t,r)=>{let o=e.length>2,n=t.outputShape,s=z.size(n),u=[Math.ceil(s/64),1,1];Te("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${u}`);let d=Ie(e[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:t.cacheKey},getRunData:()=>({dispatchGroup:{x:u[0],y:u[1],z:u[2]},outputs:[{dims:r?r(n):n,dataType:e[0].dataType}]}),getShaderSource:a=>Yl(a,e,t,n,o,u[1]===1&&u[2]===1,!1,d)}}});var Zl,Xl,Ql,wi,vi,Jl,ed,td,rd,$i,Si=F(()=>{"use strict";Ee();yi();bi();Et();Wt();Zl=(e,t,r,o,n,s)=>(e-1)*t+r+(o-1)*n+1-s,Xl=(e,t,r,o,n)=>{let s=Math.floor(e/2);t==="SAME_UPPER"?(r[o]=s,r[n]=e-s):t==="SAME_LOWER"&&(r[o]=e-s,r[n]=s)},Ql=(e,t,r,o,n,s,u,d,a,p)=>{let h=e.length-2,v=p.length===0;if(a.length===0)for(let w=0;w<h;++w)a.push(0);let y=e[0],b=t[d?3:1]*n;for(let w=0,S=e.length-h-(d?1:0);w<h;++w,++S){let C=e[S],A=v?C*u[w]:p[w],I=Zl(C,u[w],s[w],t[S],r[w],A);Xl(I,o,s,w,w+h),v&&p.push(u[w]*(C-1)+a[w]+(t[S]-1)*r[w]+1-s[w]-s[w+h])}p.splice(0,0,y),p.splice(d?3:1,0,b)},wi=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((y,b)=>y*b,1)===0){r.length=0;for(let y=2;y<t[1].dims.length;++y)r.push(t[1].dims[y])}let o=e.format==="NHWC";r.splice(0,0,t[1].dims[0]),r.splice(o?3:1,0,t[1].dims[1]);let n=e.pads.slice(),s=e.outputShape.slice(),u=e.outputPadding.slice(),d=t[0].dims,a=e.dilations.slice();if(a.reduce((y,b)=>y+b,0)===0){let y=t[0].dims.length-2;a=new Array(y).fill(1)}let p=e.strides.slice();if(p.reduce((y,b)=>y+b,0)===0){let y=t[0].dims.length-2;p=new Array(y).fill(1)}Ql(d,r,a,e.autoPad,e.group,n,p,o,u,s);let h=Object.assign({},e),v=e.cacheKey+[r.join("n,"),n.join(","),p.join(","),u.join(","),s.join(","),a.join(",")].join("_");return Object.assign(h,{kernelShape:r,pads:n,outputPadding:u,outputShape:s,dilations:a,strides:p,cacheKey:v}),h},vi=e=>{let t=Hr(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],n=e.dilations,s=e.group,u=e.kernelShape,d=e.pads,a=e.strides,p=e.wIsConst(),h=e.outputPadding,v=e.outputShape;return re({autoPad:o,format:r,dilations:n,group:s,kernelShape:u,outputPadding:h,outputShape:v,pads:d,strides:a,wIsConst:p,...t})},Jl=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[0];if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let n=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==n))throw new Error("invalid bias");let s=e[0].dims.length-2;if(t.dilations.reduce((h,v)=>h+v,0)>0&&t.dilations.length!==s)throw new Error(`dilations should be ${s}D`);if(t.strides.reduce((h,v)=>h+v,0)>0&&t.strides.length!==s)throw new Error(`strides should be ${s}D`);if(t.pads.reduce((h,v)=>h+v,0)>0&&t.pads.length!==s*2)throw new Error(`pads should be ${s*2}D`);if(t.outputPadding.length!==s&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${s}D`);if(t.kernelShape.reduce((h,v)=>h+v,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},ed=[2,3,1,0],td=(e,t,r)=>{let o=wi(r,t),n=r.format==="NHWC",s=t.length===3;if(o.group!==1){e.compute(Mn(t,o));return}let u=o.outputShape,d=u[n?1:2],a=u[n?2:3],p=u[n?3:1],h=t[1].dims[2],v=t[1].dims[3],y=t[0].dims[n?3:1],b=n?d*a:p,w=n?p:d*a,S=h*v*y,C=!0,A=e.kernelCustomData.wT??e.compute(et(t[1],ed),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=A);let I=[t[0],A];s&&(!n&&t[2].dims.length===1?I.push(t[2].reshape([t[2].dims[0],1,1])):I.push(t[2])),e.compute(gi(I,o,u,b,w,S,s,C),{inputs:I})},rd=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];o.length===3&&o.push(e.inputs[2]);let n=t.kernelShape;(n.length===0||n[0]===0)&&(n=[e.inputs[1].dims[2]]);let s=t.dilations;(s.length===0||s[0]===0)&&(s=[1]);let u=t.strides;(u.length===0||u[0]===0)&&(u=[1]);let d=t.pads;d.length===0&&(d=[0,0]),d=[0,d[0],0,d[1]],u=[1].concat(u),s=[1].concat(s),n=[1].concat(n);let a=wi({...t,pads:d,strides:u,dilations:s,kernelShape:n},o);e.compute(Mn(o,a,p=>r?[p[0],p[2],p[3]]:[p[0],p[1],p[3]]))},$i=(e,t)=>{Jl(e.inputs,t),e.inputs[0].dims.length===3?rd(e,t):td(e,e.inputs,t)}});var Dn,qr,xi,nd,od,zn,Wn,ad,Ci,Ii,Ai=F(()=>{"use strict";me();Ee();be();Dn="[a-zA-Z]|\\\\.\\\\.\\\\.",qr="("+Dn+")+",xi="^"+qr+"$",nd="("+qr+",)*"+qr,od="^"+nd+"$",zn=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let o=this.symbolToIndices.get(t);o===void 0?o=[r]:o.push(r),this.symbolToIndices.set(t,o)}},Wn=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[o,n]=r.includes("->")?r.split("->",2):[r,""];if(!o.match(RegExp(od)))throw new Error("Invalid LHS term");if(o.split(",").forEach((d,a)=>{let p=t[a].dims.slice();if(!d.match(RegExp(xi)))throw new Error("Invalid LHS term");let h=this.processTerm(d,!0,p,a);this.lhs.push(h)}),n==="")n+=[...this.symbolToInfo.entries()].filter(([d,a])=>a.count===1||d==="...").map(([d])=>d).join("");else if(!n.match(RegExp(qr)))throw new Error("Invalid RHS");n.match(RegExp(Dn,"g"))?.forEach(d=>{if(d==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let a=this.symbolToInfo.get(d);if(a===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(a.dimValue)}}),this.rhs=this.processTerm(n,!0,this.outputDims)}addSymbol(t,r,o){let n=this.symbolToInfo.get(t);if(n!==void 0){if(n.dimValue!==r&&n.count!==1)throw new Error("Dimension mismatch");n.count++,n.inputIndices.push(o)}else n={count:1,dimValue:r,inputIndices:[o]};this.symbolToInfo.set(t,n)}processTerm(t,r,o,n=-1){let s=o.length,u=!1,d=[],a=0;if(!t.match(RegExp(xi))&&!r&&t!=="")throw new Error("Invalid LHS term");let p=t.match(RegExp(Dn,"g")),h=new zn(n);return p?.forEach((v,y)=>{if(v==="..."){if(u)throw new Error("Only one ellipsis is allowed per input term");u=!0;let b=s-p.length+1;if(b<0)throw new Error("Ellipsis out of bounds");if(d=o.slice(a,a+b),this.hasEllipsis){if(this.ellipsisDims.length!==d.length||this.ellipsisDims.toString()!==d.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=d;else throw new Error("Ellipsis must be specified in the LHS");for(let w=0;w<d.length;w++){let S=String.fromCharCode("0".charCodeAt(0)+y);h.addSymbol(S,y+w),this.addSymbol(S,o[a++],n)}}else h.addSymbol(v,y),this.addSymbol(v,o[a++],n)}),h}},ad=(e,t)=>{let r=e[0].dataType,o=new Array(e.length);for(let B=0;B<e.length;++B)o[B]=G(`input${B}`,r,e[B].dims);let n=t.outputDims,s=z.size(n),u=q("output",r,n),d=[],a=Array.from(t.rhs.symbolToIndices.keys()),p="var prod = 1.0;",h="var sum = 0.0;",v="sum += prod;",y=[],b=[],w=[],S=[],C=t.symbolToInfo.size===a.length;t.symbolToInfo.forEach((B,_)=>{if(a.includes(_)){let R=a.indexOf(_);t.lhs.forEach((E,W)=>{if(B.inputIndices.includes(W)){let V=E.symbolToIndices.get(_);if(V===void 0)throw new Error("Invalid symbol error");V.forEach(Y=>{d.push(`${o[W].indicesSet(`input${W}Indices`,Y,u.indicesGet("outputIndices",R))}`)})}})}else t.lhs.forEach((R,E)=>{let W=t.symbolToInfo.get(_);if(W===void 0)throw new Error("Invalid symbol error");if(W.inputIndices.includes(E)){let V=R.symbolToIndices.get(_);if(V===void 0)throw new Error("Invalid symbol error");V.forEach(Y=>{y.push(`${o[E].indicesSet(`input${E}Indices`,Y,`${_}`)}`)}),S.push(`prod *= ${o[E].getByIndices(`input${E}Indices`)};`)}}),b.push(`for(var ${_}: u32 = 0; ${_} < ${t.symbolToInfo.get(_)?.dimValue}; ${_}++) {`),w.push("}")});let A=C?[...d,`let sum = ${o.map((B,_)=>B.getByIndices(`input${_}Indices`)).join(" * ")};`]:[...d,h,...b,...y,p,...S,v,...w],I=B=>`\n      ${B.declareVariables(...o,u)}\n\n      ${B.mainStart()}\n        ${B.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n        var outputIndices = ${u.offsetToIndices("global_idx")};\n        ${o.map((_,R)=>`var input${R}Indices: ${o[R].type.indices};`).join(`\n`)}\n        ${A.join(`\n`)};\n        ${u.setByOffset("global_idx","sum")};\n      }`;return{name:"Einsum",shaderCache:{hint:t.equation},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:I}},Ci=(e,t)=>{let r=new Wn(e.inputs,t.equation);e.compute(ad(e.inputs,r))},Ii=e=>{let t=e.equation.replace(/\\s+/g,"");return re({equation:t})}});var id,_i,sd,ud,Ti,Ei=F(()=>{"use strict";me();be();id=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=r.length<t.length?0:r.length-t.length,n=t.length<r.length?0:t.length-r.length;for(;o<r.length&&n<t.length;++o,++n)if(r[o]!==t[n]&&r[o]!==1&&t[n]!==1)throw new Error("Expand requires shape to be broadcastable to input")},_i=(e,t)=>{let r=e.length-t.length,o=[];for(let n=0;n<r;++n)o.push(e[n]);for(let n=0;n<t.length;++n)o.push(t[n]===1?e[n+r]:t[n]);return o},sd=(e,t)=>e.length>t.length?_i(e,t):_i(t,e),ud=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=sd(t,r),n=z.size(o),s=e[0].dataType,u=G("input",s,t),d=q("output",s,o),a=p=>`\n  const inputShape = ${u.indices(...t)};\n  ${p.declareVariables(u,d)}\n  ${p.mainStart()}\n  ${p.guardAgainstOutOfBoundsWorkgroupSizes(n)}\n    let outputIndices = ${d.offsetToIndices("global_idx")};\n    var inputIndices: ${u.type.indices};\n    for (var i = 0; i < ${t.length}; i++) {\n      if (${u.indicesGet("inputShape","i")} == 1) {\n        ${u.indicesSet("inputIndices","i",0)}\n      } else {\n        ${u.indicesSet("inputIndices","i",d.indicesGet("outputIndices",`i + ${o.length-t.length}`))}\n      }\n    }\n    ${d.setByOffset("global_idx",u.getByIndices("inputIndices"))}\n  }`;return{name:"Expand",shaderCache:{hint:`${o}`},getShaderSource:a,getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)}})}},Ti=e=>{id(e.inputs),e.compute(ud(e.inputs),{inputs:[0]})}});var ld,dd,Oi,ki,Pi=F(()=>{"use strict";me();Ee();be();ld=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},dd=(e,t)=>{let r=e[0].dims,o=e[1].dims,n=r.length,s=z.normalizeAxis(t.axis,n),u=r.slice(0);u.splice(s,1,...o);let d=r[s],a=z.size(u),p=Ge(e[0].dims.length),h=p?e[0].dims.length:e[0].dims,v=Ge(e[1].dims.length),y=v?e[1].dims.length:e[1].dims,b=Ge(u.length),w=b?u.length:u,S=G("data",e[0].dataType,h),C=G("inputIndices",e[1].dataType,y),A=q("output",e[0].dataType,w),I=[{type:"uint32",data:a},{type:"int32",data:d},{type:"uint32",data:s}];p&&I.push(...Ne(e[0].dims)),v&&I.push(...Ne(e[1].dims)),b&&I.push(...Ne(u));let B=[];B.push(p?"rank":"dims"),B.push(v?"rank":"dims");let _=()=>{let E=o.length,W=`var indicesIndices  = ${C.type.indices}(0);`;for(let V=0;V<E;V++)W+=`${E>1?`indicesIndices[${V}]`:"indicesIndices"} = ${u.length>1?`outputIndices[uniforms.axis + ${V}]`:"outputIndices"};`;W+=`\n        var idx = ${C.getByIndices("indicesIndices")};\n        if (idx < 0) {\n          idx = idx + uniforms.axisDimLimit;\n        }\n        var dataIndices = ${S.type.indices}(0);\n      `;for(let V=0,Y=0;V<n;V++)V===s?(W+=`${n>1?`dataIndices[${V}]`:"dataIndices"} = u32(idx);`,Y+=E):(W+=`${n>1?`dataIndices[${V}]`:"dataIndices"} = ${u.length>1?`outputIndices[${Y}]`:"outputIndices"};`,Y++);return W},R=E=>`\n      ${E.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(S,C,A)}\n      ${E.mainStart()}\n        ${E.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        let outputIndices = ${A.offsetToIndices("global_idx")};\n        ${_()};\n        let value = ${S.getByIndices("dataIndices")};\n        ${A.setByOffset("global_idx","value")};\n      }`;return{name:"Gather",shaderCache:{hint:t.cacheKey,inputDependencies:B},getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:I}),getShaderSource:R}},Oi=e=>re({axis:e.axis}),ki=(e,t)=>{let r=e.inputs;ld(r),e.compute(dd(e.inputs,t))}});var cd,pd,Ri,Bi,Mi=F(()=>{"use strict";me();Ee();be();cd=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},pd=(e,t)=>{let r=e[0].dims,o=e[0].dataType,n=r.length,s=z.computeStrides(r),u=z.size(r),d=e[1].dims,a=e[1].dataType,p=z.size(d),h=z.normalizeAxis(t.axis,n),v=r[h],y=d.slice(0),b=z.size(y),w=G("input",o,r),S=G("indices",a,[p]),C=q("output",o,y),A=I=>`\n      const inputStrides = array<u32, ${s.length}>(${s.map(B=>`${B}u`).join(",")});\n      ${I.declareVariables(w,S,C)}\n      ${I.mainStart()}\n      ${I.guardAgainstOutOfBoundsWorkgroupSizes(b)}\n\n      let outputIndices = ${C.offsetToIndices("global_idx")};\n\n      var idx = ${S.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + ${v};\n      }\n\n      var srcOffset = u32(0);\n\n      for (var i = 0; i < ${r.length}; i++) {\n        if (i == ${h}) {\n          srcOffset +=  u32(idx) * inputStrides[i];\n        } else {\n          srcOffset += ${C.indicesGet("outputIndices","i")} * inputStrides[i];\n        }\n      }\n\n      // Should never hit this with valid values in indices\n      // This is a guard against malicious data in the indices input\n      if (srcOffset < 0 || srcOffset >= ${u}) {\n        return;\n      }\n\n      output[global_idx] = input[srcOffset];\n  }`;return{name:"GatherElements",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:y,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(b/64)}}),getShaderSource:A}},Ri=e=>re({axis:e.axis}),Bi=(e,t)=>{let r=e.inputs;cd(r),e.compute(pd(e.inputs,t))}});var fd,md,hd,Di,zi,Wi=F(()=>{"use strict";me();Ee();be();fd=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},md=(e,t,r)=>{if(r.length===0)return"0u";let o=r.length===1&&e!==1||r.length===2&&r[0]!==e,n=r[r.length-1]!==t,s="0u";return o||(s+=`+ m * ${r[r.length-1]}u`),n||(s+="+n"),s},hd=(e,t)=>{let r=e[0].dims.slice(),o=e[1].dims.slice(),[n,s,u]=Br.getShapeOfGemmResult(r,t.transA,o,t.transB,e.length===3?e[2].dims:void 0),d=[n,s];if(!d)throw new Error("Can\'t use gemm on the given tensors");let a=z.size(d),p="";t.transA&&t.transB?p="value += a[k * M + m] * b[n * K + k];":t.transA&&!t.transB?p="value += a[k * M + m] * b[k * N + n];":!t.transA&&t.transB?p="value += a[m * K + k] * b[n * K + k];":!t.transA&&!t.transB&&(p="value += a[m * K + k] * b[k * N + n];");let h=Ie(e[0].dataType),v=t.alpha===1?"":"value *= alpha;",y=e.length===3?`value += beta * c[${md(n,s,e[2].dims)}];`:"",b=[`@group(0) @binding(0) var<storage, read> a : array<${h}>;`,`@group(0) @binding(1) var<storage, read> b : array<${h}>;`];e.length===3&&b.push(`@group(0) @binding(2) var<storage, read> c : array<${h}>;`);let w=S=>`\n  const M: u32 = ${n}u;\n  const N: u32 = ${s}u;\n  const K: u32 = ${u}u;\n  const alpha = ${h}(${t.alpha});\n  const beta = ${h}(${t.beta});\n\n  ${b.join(`\n`)}\n  @group(0) @binding(${e.length}) var<storage, read_write> output : array<${h}>;\n\n  ${S.mainStart()}\n    ${S.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n\n    let m = global_id.x / N;\n    let n = global_id.x % N;\n\n    var value = ${h}(0);\n    for (var k: u32 = 0u; k<${u}u; k++) {\n      ${p}\n    }\n\n    ${v}\n    ${y}\n    output[global_id.x] = value;\n\n  }`;return{name:"Gemm",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:w}},Di=(e,t)=>{fd(e.inputs),e.compute(hd(e.inputs,t))},zi=e=>re(e)});var gd,yd,bd,wd,Vi,Ni,Ui=F(()=>{"use strict";De();me();Ee();be();gd={name:"InstanceNormalization"},yd=(e,t)=>{let r=e[0].dims,o=r,n=2,s=z.sizeToDimension(r,n),u=z.sizeFromDimension(r,n),d=r[1],a=G("x",e[0].dataType,[r[0],r[1],u]),p=G("scale",e[1].dataType,e[1].dims),h=G("bias",e[2].dataType,e[2].dims),v=q("output",e[0].dataType,[r[0],r[1],u]),y=[a,p,h,v],b=a.type.value,w=64,S=C=>`\n\n  const C: u32 = ${d};\n  const normSize: u32 = ${u};\n  const epsilon: f32 = ${t.epsilon};\n  var<workgroup> meanShared : ${b};\n  var<workgroup> squaredNormShared : ${b};\n  var<workgroup> workgroupShared : array<${b}, ${w}>;\n  const workgroupSize = ${w}u;\n  ${C.declareVariables(...y)}\n  ${C.mainStart(w)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / C;\n    let channel = norm % C;\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial: ${b} = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      initial = initial + ${a.get("batch","channel","h")};\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = workgroupShared[0] / ${b}(normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = 0;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let deviation =  ${a.get("batch","channel","h")} - meanShared;\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = workgroupShared[0];\n    }\n    workgroupBarrier();\n\n    let invStdDev = 1 / sqrt(squaredNormShared / ${b}(normSize) + epsilon);\n    let channelScale = invStdDev * ${p.getByOffset("channel")};\n    let channelShift = ${h.getByOffset("channel")} - meanShared * channelScale;\n    for (var h = localIndex; h < normSize; h += workgroupSize) {\n      let value = ${a.get("batch","channel","h")} * channelScale + channelShift;\n      ${v.set("batch","channel","h","value")};\n    }\n  }`;return{...gd,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:s}}),getShaderSource:S}},bd=(e,t,r,o,n,s,u,d)=>{let a=Ze(u),p=G("input",t.dataType,t.dims,a),h=G("scale",r.dataType,r.dims,a),v=G("bias",o.dataType,o.dims,a),y=64,b=a===1?"vec2f":`mat2x${a}f`,w=a===1?"f32":`vec${a}f`,S=(R,E)=>`${b}(${R}, ${E})`,C=n*u/a,A=Math.ceil(s/y),I=R=>`\n  const H: u32 = ${s};\n  const C: u32 = ${u/a};\n  const imageSize: u32 = ${s*u/a};\n\n  ${R.declareVariables(p)}\n  @group(0) @binding(1) var<storage, read_write> output : array<${b}>;\n\n  ${R.mainStart(y)}\n    let currentImageNumber = global_idx / ${y} / C;\n    let currentChannelNumber = (global_idx / ${y}) % C;\n    let wgId = global_idx % ${y};\n    let wgOffset = wgId * ${A};\n    if (wgOffset >= H) {\n        return;\n    }\n    let wgMax = min(wgOffset + ${A}, H);\n\n    let offset = currentImageNumber * imageSize + currentChannelNumber;\n    var sum = ${Ue("f32",a)};\n    var squaredSum = ${Ue("f32",a)};\n    for (var i: u32 = wgOffset; i < wgMax; i++) {\n        let value = ${w}(input[offset + i * C]);\n        sum += value;\n        squaredSum += value * value;\n    }\n    output[global_idx] = ${S("sum","squaredSum")};\n  }`,B=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:JSON.stringify({components:a,n,h:s,c:u})},getRunData:()=>({outputs:[{dims:[n,u,y,2],dataType:1}],dispatchGroup:{x:n*u/a}}),getShaderSource:I},{inputs:[t],outputs:[-1]})[0],_=R=>`\n  const H: u32 = ${s};\n  const C: u32 = ${u/a};\n  const imageSize: u32 = ${y*u/a};\n  const epsilon: f32 = ${d};\n\n  @group(0) @binding(0) var<storage, read> input : array<${b}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${h.type.storage}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${v.type.storage}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${b}>;\n\n  ${R.mainStart()}\n    ${R.guardAgainstOutOfBoundsWorkgroupSizes(C)}\n    let currentImageNumber = global_idx / C;\n    let currentChannelNumber = global_idx % C;\n\n    let offset = currentImageNumber * imageSize;\n    var sum = ${Ue("f32",a)};\n    var squaredSum = ${Ue("f32",a)};\n    for (var i: u32 = 0; i < ${y}; i++) {\n        let value = input[offset + i + currentChannelNumber * ${y}];\n        sum += value[0];\n        squaredSum += value[1];\n    }\n    sum = sum / f32(H);\n    squaredSum = squaredSum / f32(H);\n    let invStdDev = 1 / sqrt(squaredSum - sum * sum + epsilon);\n    let channelScale = invStdDev * ${w}(scale[currentChannelNumber]);\n    let channelShift = ${w}(bias[currentChannelNumber]) - sum * channelScale;\n\n    output[global_idx] = ${S("channelScale","channelShift")};\n  }`;return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:JSON.stringify({components:a,n,h:s,c:u,epsilon:d})},getRunData:()=>({outputs:[{dims:[n,u,2],dataType:1}],dispatchGroup:{x:Math.ceil(C/64)}}),getShaderSource:_},{inputs:[B,r,o],outputs:[-1]})[0]},wd=(e,t,r)=>{let o=t[0].dims,n=o,s=o[0],u=o[o.length-1],d=z.sizeFromDimension(o,1)/u,a=Ze(u),p=z.size(n)/a,h=G("input",t[0].dataType,t[0].dims,a),v=q("output",t[0].dataType,n,a),y=Ie(t[0].dataType),b=a===1?"vec2f":`mat2x${a}f`,w=a===1?y:`vec${a}<${y}>`,S=bd(e,t[0],t[1],t[2],s,d,u,r.epsilon),C=A=>`\n  const H: u32 = ${d};\n  const C: u32 = ${u/a};\n\n  @group(0) @binding(0) var<storage, read> input : array<${h.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scaleInput : array<${b}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${v.type.storage}>;\n\n  ${A.mainStart()}\n    let currentImageNumber = global_idx / (C * H);\n    let currentChannelNumber = global_idx % C;\n\n    let scaleOffset = currentImageNumber * C + currentChannelNumber;\n    let scale = scaleInput[scaleOffset];\n    output[global_idx] = fma(input[global_idx], ${w}(scale[0]), ${w}(scale[1]));\n  }`;e.compute({name:"InstanceNormalization",shaderCache:{hint:`${r.cacheKey}`},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)}}),getShaderSource:C},{inputs:[t[0],S]})},Vi=e=>re({epsilon:e.epsilon,format:e.format}),Ni=(e,t)=>{t.format==="NHWC"?wd(e,e.inputs,t):e.compute(yd(e.inputs,t))}});var vd,$d,Hi,Gi,Li=F(()=>{"use strict";De();me();Ee();be();vd=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},$d=(e,t,r)=>{let o=e[0].dims,n=e[1],s=e[2],u=o,d=z.normalizeAxis(t.axis,o.length),a=z.sizeToDimension(o,d),p=z.sizeFromDimension(o,d),h=z.size(n.dims),v=s?z.size(s.dims):0;if(h!==p||s&&v!==p)throw new Error(`Size of X.shape()[axis:] == ${p}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${h} and bias size of ${v}`);let y=[];for(let _=0;_<o.length;++_)_<d?y.push(o[_]):y.push(1);let b=Ze(p),w=Ie(e[0].dataType),S=[G("x",e[0].dataType,e[0].dims,b),G("scale",n.dataType,n.dims,b)];s&&S.push(G("bias",s.dataType,s.dims,b)),S.push(q("output",e[0].dataType,u,b));let C=r>1,A=r>2;C&&S.push(q("meanDataOutput",1,y)),A&&S.push(q("invStdOutput",1,y));let I=_=>`\n  const normSize: f32 = ${p};\n  const normSizeVectorized: u32 = ${p/b};\n  const epsilon: f32 = ${t.epsilon};\n\n  ${_.declareVariables(...S)}\n  ${_.mainStart()}\n    ${_.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n    let offset = global_idx * normSizeVectorized;\n    var meanVector = ${Ue("f32",b)};\n    var meanSquareVector = ${Ue("f32",b)};\n\n    for (var h: u32 = 0u; h < normSizeVectorized; h++) {\n      let value = ${Qe(w,b,"x[h + offset]")};\n      meanVector += value;\n      meanSquareVector += value * value;\n    }\n    let mean = ${Je("meanVector",b)} / normSize;\n    let meanSquare = sqrt(${Je("meanSquareVector",b)} \n      / normSize - mean * mean + epsilon);\n\n    for (var j: u32 = 0; j < normSizeVectorized; j++) {\n      let f32input = ${Qe(w,b,"x[j + offset]")};\n      let f32scale = ${Qe(w,b,"scale[j]")};\n      output[j + offset] = ${S[0].type.value}((f32input - mean) / meanSquare * f32scale\n        ${s?`+ ${Qe(w,b,"bias[j]")}`:""}\n      );\n    }\n\n    ${C?"meanDataOutput[global_idx] = mean":""};\n    ${A?"invStdOutput[global_idx] = 1 / meanSquare":""};\n  }`,B=[{dims:u,dataType:e[0].dataType}];return C&&B.push({dims:y,dataType:1}),A&&B.push({dims:y,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${t.cacheKey}|${r}|${e.length}`},getRunData:()=>({outputs:B,dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:I}},Hi=e=>re({axis:e.axis,epsilon:e.epsilon}),Gi=(e,t)=>{vd(e.inputs),e.compute($d(e.inputs,t,e.outputCount))}});var Sd,Fi,ji=F(()=>{"use strict";me();lr();Sd=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},Fi=e=>{Sd(e.inputs);let t=at.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can\'t use matmul on the given tensors");e.compute(jr(e.inputs,{activation:"",activationCacheKey:""},t))}});var xd,Ki,qi,Cd,Vn,Yi,Zi=F(()=>{"use strict";me();Ee();Pr();_n();be();Wt();xd=(e,t)=>{let r=e[0],o=e[1],n=e[2],s=e[3],u=e[4],d=e[5],a=e[6],p=e[7];if(r.dims.length!==3&&r.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let h=!1,v=r.dims[0],y=r.dims[1],b=r.dims.length===3?h?r.dims[2]/3:r.dims[2]:t.numHeads*r.dims[4],w=y,S=0,C=0,A=Math.floor(b/t.numHeads);if(a&&p){if(a.dims.length!==4)throw new Error(\'Input "past_key" is expected to have 4 dimensions\');if(p.dims.length!==4)throw new Error(\'Input "past_value" is expected to have 4 dimensions\');S=a.dims[2],C=a.dims[2]}else if(a||p)throw new Error(\'Input "past_key" and "past_value" shall be both present or both absent\');let I;if(o){if(r.dims.length!==3)throw new Error(\'Input "query" is expected to have 3 dimensions when key is given\');if(o.dims.length<3||o.dims.length>5)throw new Error(\'Input "key" is expected to have 3, 4, or 5 dimensions\');if(r.dims[0]!==o.dims[0])throw new Error(\'Input "query" and "key" shall have same dim 0 (batch size)\');if(o.dims.length===3){if(o.dims[2]!==r.dims[2])throw new Error(\'Input "query" and "key" shall have same dim 2 (hidden_size)\');I=2,w=o.dims[1]}else if(o.dims.length===5){if(o.dims[2]!==t.numHeads||o.dims[3]!==2||o.dims[4]!==A)throw new Error(\'Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv\');if(n)throw new Error(\'Expect "value" be none when "key" has packed kv format.\');I=5,w=o.dims[1]}else{if(o.dims[1]!==t.numHeads||o.dims[3]!==A)throw new Error(\'Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key\');I=0,w=o.dims[2]}}else{if(r.dims.length!==3&&r.dims.length!==5)throw new Error(\'Input "query" is expected to have 3 or 5 dimensions when key is empty\');if(r.dims.length===5&&(r.dims[2]!==t.numHeads||r.dims[3]!==3))throw new Error(\'Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv\');I=3}if(s){if(s.dims.length!==1)throw new Error(\'Input "bias" is expected to have 1 dimension\');if(n&&r.dims.length===5&&r.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let B=0;if(u){B=8;let V=u.dims;throw V.length===1?V[0]===v?B=1:V[0]===3*v+2&&(B=3):V.length===2&&V[0]===v&&V[1]===w&&(B=5),B===8?new Error(\'Input "key_padding_mask" shape shall be (batch_size) or (batch_size, kv_sequence_length)\'):new Error("Mask not supported")}let _=!1,R=b;if(n){if(n.dims.length!==3&&n.dims.length!==4)throw new Error(\'Input "value" is expected to have 3 or 4 dimensions\');if(r.dims[0]!==n.dims[0])throw new Error(\'Input "query" and "value" shall have same dim 0 (batch_size)\');if(n.dims.length===3){if(w!==n.dims[1])throw new Error(\'Input "key" and "value" shall have the same dim 1 (kv_sequence_length)\');R=n.dims[2]}else{if(w!==n.dims[2])throw new Error(\'Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)\');R=n.dims[1]*n.dims[3],_=!0}}let E=S+w,W=!1;if(u)throw new Error("Key padding mask is not supported");if(d)throw new Error("extraAddQk is not supported");if(a)throw new Error("pastKey is not supported");if(p)throw new Error("pastValue is not supported");return{batchSize:v,sequenceLength:y,pastSequenceLength:S,kvSequenceLength:w,totalSequenceLength:E,maxSequenceLength:C,inputHiddenSize:0,hiddenSize:b,vHiddenSize:R,headSize:A,vHeadSize:Math.floor(R/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:B,scale:t.scale,broadcastResPosBias:W,passPastInKv:_,qkvFormat:I}},Ki=e=>re({...e}),qi=re({perm:[0,2,1,3]}),Cd=(e,t,r,o,n,s,u)=>{let d=[o,n,s],a=z.size(d),p=Ie(t.dataType),h=v=>`\n  const biasOffset = ${u}u;\n  const hiddenSize = ${s}u;\n\n  @group(0) @binding(0) var<storage, read> qkv: array<${p}>;\n  @group(0) @binding(1) var<storage, read> bias: array<${p}>;\n  @group(0) @binding(2) var<storage, read_write> qkv_with_bias: array<${p}>;\n\n  ${v.mainStart()}\n    ${v.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n    let biasOffsetIdx = (global_idx % hiddenSize) + biasOffset;\n\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[biasOffsetIdx];\n  }`;return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{hint:JSON.stringify({batchSize:o,sequenceLength:n,hiddenSize:s,biasOffset:u})},getRunData:()=>({outputs:[{dims:d,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:h},{inputs:[t,r],outputs:[-1]})[0]},Vn=(e,t,r,o,n,s,u,d)=>{let a=s;if(u){if(o===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return a=Cd(e,s,u,t,o,r*n,d),a=a.reshape([t,o,r,n]),e.compute(et(a,qi.perm),{inputs:[a],outputs:[-1]})[0]}else return s.dims.length===3&&(a=s.reshape([t,o,r,n])),e.compute(et(a,qi.perm),{inputs:[a],outputs:[-1]})[0]},Yi=(e,t)=>{let r=xd(e.inputs,t);if(e.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(e.inputs[1]?.dims.length===5)throw new Error("Packed KV is not implemented");let o=e.inputs[1]&&e.inputs[2]&&e.inputs[1].dims.length===4&&e.inputs[2].dims.length===4,n=Vn(e,r.batchSize,r.numHeads,r.sequenceLength,r.headSize,e.inputs[0],e.inputs[3],0);if(o)return Vr(e,n,e.inputs[1],e.inputs[2],e.inputs[4],void 0,void 0,void 0,e.inputs[5],r,t);let s=Vn(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.headSize,e.inputs[1],e.inputs[3],r.hiddenSize),u=Vn(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.vHeadSize,e.inputs[2],e.inputs[3],2*r.hiddenSize);Vr(e,n,s,u,e.inputs[4],void 0,e.inputs[6],e.inputs[7],e.inputs[5],r,t)}});var Id,Ad,_d,Td,Ed,Od,kd,Pd,Rd,Xi,Qi,Ji=F(()=>{"use strict";De();me();Ee();be();Id=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1)throw new Error("Input type must be float.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},Ad=(e,t,r,o,n,s)=>{let u=t.length,d="";for(let a=u-1;a>=0;--a)d+=`\n            k = i32(${e.indicesGet("indices",a)}) - ${o[a]};\n            if (k < 0) {\n              break;\n            }\n            if (k >= ${t[a]}) {\n              break;\n            }\n            offset += k * ${r[a]};\n        `;return`\n          value = ${n}(${s});\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${d}\n            value = x[offset];\n          }\n      `},_d=(e,t,r,o)=>{let n=t.length,s="";for(let u=n-1;u>=0;--u)s+=`\n                k = i32(${e.indicesGet("indices",u)}) - ${o[u]};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = ${2*(t[u]-1)};\n                  k = k % _2n_1;\n                  if(k >= ${t[u]}) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * ${r[u]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${s}\n              value = x[offset];\n          `},Td=(e,t,r,o)=>{let n=t.length,s="";for(let u=n-1;u>=0;--u)s+=`\n                k = i32(${e.indicesGet("indices",u)}) - ${o[u]};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= ${t[u]}) {\n                  k = ${t[u]-1};\n                }\n                offset += k * ${r[u]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${s}\n              value = x[offset];\n          `},Ed=(e,t,r,o)=>{let n=t.length,s="";for(let u=n-1;u>=0;--u)s+=`\n                k = i32(${e.indicesGet("indices",u)}) - ${o[u]};\n                if (k < 0)  {\n                  k += ${t[u]};\n                }\n                if (k >= ${t[u]}) {\n                  k -= ${t[u]};\n                }\n                offset += k * ${r[u]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${s}\n              value = x[offset];\n          `},Od=(e,t,r,o,n)=>{switch(o.mode){case 0:return Ad(e,t,r,o.pads,n,o.value);case 1:return _d(e,t,r,o.pads);case 2:return Td(e,t,r,o.pads);case 3:return Ed(e,t,r,o.pads);default:throw new Error("Invalid mode")}},kd=(e,t,r,o)=>{let n=t[0].dims,s=z.padShape(n.slice(),r.pads),u=z.size(s),d=z.computeStrides(n),a=q("output",t[0].dataType,s),p=G("x",t[0].dataType,n),h=Od(a,n,d,r,o);return`\n              ${e.declareVariables(p,a)}\n              ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n\n              let indices = ${a.offsetToIndices("global_idx")};\n\n              var value = ${o}(0);\n              ${h}\n              output[global_idx] = value;\n          }`},Pd=(e,t)=>{let r=z.padShape(e[0].dims.slice(),t.pads);return{name:"Pad",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(z.size(r)/64)}}),getShaderSource:o=>kd(o,e,t,"f32")}},Rd=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),o=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,n=e[0].dims.length,s=new Int32Array(2*n).fill(0);if(e.length>=4){let d=e[3].getBigInt64Array();for(let a=0;a<d.length;a++)s[Number(d[a])]=Number(r[a]),s[Number(d[a])+n]=Number(r[a+d.length])}else r.forEach((d,a)=>s[Number(a)]=Number(d));let u=[];return s.forEach(d=>u.push(d)),re({mode:t.mode,value:o,pads:u})}else return t},Xi=(e,t)=>{Id(e.inputs);let r=Rd(e.inputs,t);e.compute(Pd(e.inputs,r),{inputs:[0]})},Qi=e=>{let t=e.mode,r=e.value,o=e.pads;return re({mode:t,value:r,pads:o})}});var Kr,es,ts,rs,ns,os,as,is,ss,us,ls,ds,cs,ps,fs,ms=F(()=>{"use strict";me();Ee();be();Kr=e=>{if(!e||e.length!==1)throw new Error("Pool ops requires 1 input.");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("Pool ops supports 1-D or 2-D inputs only for now.")},es=(e,t,r)=>{let o=t.format==="NHWC",n=e.dims.slice();o&&n.splice(1,0,n.pop());let s=Object.hasOwnProperty.call(t,"dilations"),u=t.kernelShape.slice(),d=t.strides.slice(),a=s?t.dilations.slice():[],p=t.pads.slice();Tt.adjustPoolAttributes(r,n,u,d,a,p);let h=Tt.computePoolOutputShape(r,n,d,a,u,p,t.autoPad),v=Object.assign({},t);s?Object.assign(v,{kernelShape:u,strides:d,pads:p,dilations:a,cacheKey:t.cacheKey}):Object.assign(v,{kernelShape:u,strides:d,pads:p,cacheKey:t.cacheKey});let y=h.slice();return y.push(y.splice(1,1)[0]),[v,o?y:h]},ts=(e,t,r,o,n,s,u,d)=>{let a=n.format==="NHWC",p=r,h=t.type.value,v=p.length,y=z.size(o),b=q("output",t.type.tensor,o);if(n.kernelShape.length<=2){let w=n.kernelShape[n.kernelShape.length-1],S=n.strides[n.strides.length-1],C=n.pads[n.pads.length/2-1],A=n.pads[n.pads.length-1],I=v-(a?2:1),B="",_="",R="";if(C+A!==0?B=`\n                for (var i: u32 = 0u; i < ${w}u; i++) {\n                  xIndices[${I}] = indices[${I}] * ${S} - ${C} + i;\n                  if (xIndices[${I}] < 0 || xIndices[${I}] >= ${p[I]}) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${s}\n                }`:B=`\n                for (var i: u32 = 0u; i < ${w}u; i++) {\n                  xIndices[${I}] = indices[${I}] * ${S} - ${C} + i;\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${s}\n                }`,n.kernelShape.length===2){let W=n.kernelShape[n.kernelShape.length-2],V=n.strides[n.strides.length-2],Y=n.pads[n.pads.length/2-2],ae=n.pads[n.pads.length-2],M=v-(a?3:2),K=p[M];Y+ae!==0?_=`\n                for (var j: u32 = 0u; j < ${W}u; j++) {\n                  xIndices[${M}] = indices[${M}] * ${V} - ${Y} + j;\n                  if (xIndices[${M}] < 0 || xIndices[${M}] >= ${K}) {\n                    pad+= ${w};\n                    continue;\n                  }\n              `:_=`\n                for (var j: u32 = 0u; j < ${W}u; j++) {\n                  xIndices[${M}] = indices[${M}] * ${V} - ${Y} + j;\n                `,R=`\n              }\n            `}return`\n            ${e.declareVariables(t,b)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(y)}\n\n              let indices = ${b.offsetToIndices("global_idx")};\n              var xIndices = ${b.offsetToIndices("global_idx")};\n\n              var value: ${h} = ${h}(${d});\n              var pad = 0;\n              ${_}\n              ${B}\n              ${R}\n              ${u}\n\n              output[global_idx] = value;\n            }`}else{if(a)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let w=z.size(n.kernelShape),S=z.computeStrides(n.kernelShape),C=S.length,A=n.pads.length,I=n.pads.reduce((R,E)=>R+E),B="";return I?B=`\n                if (xIndices[j] >= inputDims[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${s}\n              }`:B=`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${s}\n            `,`\n            ${e.declareVariables(t,b)}\n\n            const pads = array<u32, ${A}>(${n.pads.map(R=>`${R}u`).join(",")});\n            const inputDims = array<u32, ${v}>(${p.map(R=>`${R}u`).join(",")});\n            const kernelStrides = array<u32, ${C}>(${S.map(R=>`${R}u`).join(",")});\n            const strides = array<u32, ${C}>(${n.strides.map(R=>`${R}u`).join(",")});\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(y)}\n\n              let indices = ${b.offsetToIndices("global_idx")};\n              let xIndices = ${b.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${C}>;\n\n              var value = ${b.type.value}(${d});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < ${w}u; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${C-1}u; j++) {\n                  offsets[j] = offset / kernelStrides[j];\n                  offset -= offsets[j] * kernelStrides[j];\n                }\n                offsets[${C-1}] = offset;\n\n                isPad = false;\n                for (var j = ${v-C}u; j < ${v}u; j++) {\n                  xIndices[j] = indices[j] * strides[j - ${v-C}u]\n                    + offsets[j - ${v-C}u] - pads[j - 2u];\n                  ${B}\n              }\n              ${u}\n\n              output[global_idx] = value;\n            }`}},rs=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),ns=(e,t,r,o)=>{let[n,s]=es(t,o,r),u=z.size(n.kernelShape),d=G("x",t.dataType,t.dims),a=d.type.value,p="value += x_val;",h="";return n.countIncludePad?h+=`value /= ${a}(${u});`:h+=`value /= ${a}(${u} - pad);`,{name:e,shaderCache:{hint:o.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(z.size(s)/64)}}),getShaderSource:v=>ts(v,d,t.dims,s,n,p,h,"0.0")}},os=e=>{let t=e.count_include_pad!==0,r=rs(e);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return re({countIncludePad:t,...r})},as=(e,t)=>{Kr(e.inputs),e.compute(ns("AveragePool",e.inputs[0],!1,t))},is={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},ss=e=>{let t=e.format;return{format:t,...is,cacheKey:t}},us=(e,t)=>{Kr(e.inputs),e.compute(ns("GlobalAveragePool",e.inputs[0],!0,t))},ls=(e,t,r,o)=>{let[n,s]=es(t,o,r),u=`\n      value = max(x_val, value);\n    `,d="",a=G("x",t.dataType,t.dims);return{name:e,shaderCache:{hint:o.cacheKey},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(z.size(s)/64)}}),getShaderSource:p=>ts(p,a,t.dims,s,n,u,d,"-1e5")}},ds=(e,t)=>{Kr(e.inputs),e.compute(ls("MaxPool",e.inputs[0],!1,t))},cs=e=>{let t=e.storage_order,r=e.dilations,o=rs(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(o.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return re({storageOrder:t,dilations:r,...o})},ps=e=>{let t=e.format;return{format:t,...is,cacheKey:t}},fs=(e,t)=>{Kr(e.inputs),e.compute(ls("GlobalMaxPool",e.inputs[0],!0,t))}});var Yr=F(()=>{});var hs=F(()=>{Yr()});var gs,ys=F(()=>{gs="1.17.0"});var bs,Nn,ws=F(()=>{ys();bs="warning",Nn={wasm:{},webgl:{},webgpu:{},versions:{common:gs},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);bs=e}},get logLevel(){return bs}};Object.defineProperty(Nn,"logLevel",{enumerable:!0})});var vs,$s=F(()=>{ws();vs=Nn});var Ss=F(()=>{});var xs=F(()=>{Zr()});var Is=F(()=>{});var As=F(()=>{Zr()});var Zr=F(()=>{Ss();xs();Is();As()});var Xr=F(()=>{Zr()});var _s=F(()=>{Yr();Xr()});var Ts=F(()=>{_s()});var Es=F(()=>{});var Os=F(()=>{Yr();Xr()});var ks=F(()=>{Os()});var Ps=F(()=>{hs();$s();Ts();Xr();Es();ks()});var zd,Wd,Rs,Bs=F(()=>{"use strict";Ps();De();be();zd=(e,t,r)=>{let o=e===t,n=e<t&&r<0,s=e>t&&r>0;if(o||n||s)throw new Error("Range these inputs\' contents are invalid.")},Wd=(e,t,r,o)=>{let n=Math.abs(Math.ceil((t-e)/r)),s=[n],u=n,d=q("output",o,s),a=d.type.storage,p=h=>`\n        ${h.declareVariables(d)}\n        ${h.mainStart()}\n        ${h.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n        output[global_idx] = ${a}(${e}) + ${a}(global_idx) * ${a}(${r});\n      }`;return{name:"Range",shaderCache:{hint:[e,t,r].map(h=>h.toString()).join("_")},getShaderSource:p,getRunData:()=>({outputs:[{dims:s,dataType:o}],dispatchGroup:{x:Math.ceil(u/64)}})}},Rs=e=>{let t=0,r=0,o=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],o=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],o=e.inputs[2].getFloat32Array()[0]),vs.webgpu.validateInputContent&&zd(t,r,o),e.compute(Wd(t,r,o,e.inputs[0].dataType),{inputs:[]})}});var Vd,Nd,Ud,Hd,Gd,Ld,Fd,jd,qd,Kd,Yd,Zd,Xd,Qd,Jd,Ms,Ds,zs=F(()=>{"use strict";me();Ee();be();Vd=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},Nd=(e,t,r)=>{t.every(n=>n>=0&&n<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let o=new Array(r).fill(1);return t.forEach((n,s)=>o[n]=e[s]),o},Ud=(e,t,r,o,n,s)=>{let[u,d,a]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],p=e[0].dims.length;if(u>0&&e.length>u&&e[u].dims.length>0)e[u].getFloat32Array().forEach(h=>s.push(h));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(d>0&&e.length>d&&e[d].dims.length>0){if(e[d].getFloat32Array().forEach(h=>o.push(h)),o.length!==0&&o.length!==p&&r>=18&&o.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");Vd(o,t),t.axes.length>0&&Nd(o,t.axes,p).forEach((h,v)=>o[v]=h)}if(a>0&&e.length>a&&(e[a].getBigInt64Array().forEach(h=>n.push(Number(h))),n.length!==p||r>=18&&n.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(o.length!==t.axes.length)throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');if(n.length!==t.axes.length)throw new Error(\'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\')}if(typeof o<"u"&&typeof n<"u"&&o.length>0&&n.length>p)throw new Error("Resize requires only of scales or sizes to be specified")},Hd=e=>"fn getOriginalCoordinateFromResizedCoordinate(xResized: f32, xScale: f32, lengthResized: f32,    lengthOriginal: f32, roiStart: f32, roiEnd: f32) -> f32 { "+(()=>{switch(e){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return"if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * f32(lengthOriginal - 1);                   }";case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`\n`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",Gd=(e,t)=>"fn getNearestPixelFromOriginal(xOriginal: f32, isDownSample: bool) -> f32 {"+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",Ld=(e,t,r)=>{let o=new Array(r).fill(0).concat(new Array(r).fill(1)),n=e.length===0?o:e.slice();return t.length>0?(t.forEach((s,u)=>{o[s]=n[u],o[u+r]=n[t.length+u]}),o):n},Fd=(e,t,r,o)=>{let n=[];if(r.length>0)if(o.length>0){if(e.forEach(s=>n.push(s)),Math.max(...o)>e.length)throw new Error("axes is out of bound");o.forEach((s,u)=>n[s]=r[u])}else r.forEach(s=>n.push(s));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");n=e.map((s,u)=>Math.round(s*t[u]))}return n},jd=(e,t,r)=>{let o=(()=>{switch(r.keepAspectRatioPolicy){case"not_larger":return r.axes.length>0?Math.min(...r.axes.map(s=>t[s]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case"not_smaller":return r.axes.length>0?Math.max(...r.axes.map(s=>t[s]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${r.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let n=e.slice();return r.axes.length>0?(r.axes.forEach(s=>t[s]=o),r.axes.forEach(s=>n[s]=Math.round(e[s]*t[s]))):(t.fill(o,0,t.length),n.forEach((s,u)=>n[u]=Math.round(s*t[u]))),n},qd=(e,t,r,o,n)=>`\n    fn calculateOriginalIndicesFromOutputIndices(outputIndices: ${e.type.indices}) -> array<f32, ${r.length}> {\n      const inputShape = array<u32, ${t.length}>(${t.map(s=>`${s}u`).join(",")});\n      const outputShape = array<u32, ${r.length}>(${r.map(s=>`${s}u`).join(",")});\n      const scales = array<f32, ${o.length}>(${o.map(s=>`${s}f`).join(",")});\n      const roi = array<f32, ${n.length}>(${n.map(s=>`${s}f`).join(",")});\n      var originalIndices: array<f32, ${r.length}>;\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var outputIndex = ${r.length===1?"outputIndices":"outputIndices[i]"};\n        if (scales[i] == 1.0) {\n          originalIndices[i] = f32(outputIndex);\n        } else {\n          originalIndices[i] = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${t.length}]);\n        }\n      }\n      return originalIndices;\n    }`,Kd=(e,t,r,o,n,s,u)=>`\n    fn calculateInputIndicesFromOutputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\n        const inputShape = array<u32, ${r.length}>(${r.map(d=>`${d}u`).join(",")});\n        const outputShape = array<u32, ${o.length}>(${o.map(d=>`${d}u`).join(",")});\n        const scales = array<f32, ${n.length}>(${n.map(d=>`${d}f`).join(",")});\n        const roi = array<f32, ${s.length}>(${s.map(d=>`${d}f`).join(",")});\n        var inputIndices: ${e.type.indices};\n        for (var i:u32 = 0; i < ${o.length}; i++) {\n          var outputIndex = ${o.length===1?"outputIndices":"outputIndices[i]"};\n          var inputIndex: u32;\n          if (scales[i] == 1.0) {\n            inputIndex = outputIndex;\n          } else {\n            var original_idx = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), scales[i],\n                    f32(outputShape[i]), f32(inputShape[i]), roi[i], roi[i + ${r.length}]);\n            if (!${u} || (original_idx >= 0 && original_idx < f32(inputShape[i]))) {\n              if (original_idx < 0) {\n                inputIndex = 0;\n              } else if (original_idx > (f32(inputShape[i]) - 1)) {\n                inputIndex = inputShape[i] - 1;\n              } else {\n                inputIndex = u32(getNearestPixelFromOriginal(original_idx, scales[i] < 1));\n              }\n            } else {\n              inputIndex = u32(original_idx);\n            }\n          }\n          ${e.indicesSet("inputIndices","i","inputIndex")}\n        }\n        return inputIndices;\n    }`,Yd=(e,t)=>`\n    fn checkInputIndices(inputIndices: ${e.type.indices}) -> bool {\n      const inputShape = array<u32, ${t.length}>(${t.map(r=>`${r}u`).join(",")});\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var inputIndex = ${t.length===1?"inputIndices":"inputIndices[i]"};\n        if (inputIndex < 0 || inputIndex >= inputShape[i]) {\n          return false;\n        }\n      }\n      return true;\n    }`,Zd=(e,t,r,o,n,s)=>{let[u,d,a,p]=r.length===2?[-1,0,1,-1]:o[1]===1?[0,2,3,1]:[0,1,2,3];return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> f32 {\n      var inputIndices: ${e.type.indices};\n      inputIndices[${d}] = max(0, min(row, ${r[d]} - 1));\n      inputIndices[${a}] = max(0, min(col, ${r[a]} - 1));\n      if (${r.length} > 2) {\n        inputIndices[${p}] = channel;\n        inputIndices[${u}] = batch;\n      };\n      return input[${e.indicesToOffset("inputIndices")}];\n    }\n\n    fn bilinearInterpolation(outputIndices: ${t.type.indices}) -> f32 {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(outputIndices);\n      var row:f32 = originalIndices[${d}];\n      var col:f32 = originalIndices[${a}];\n      if (${n} && (row < 0 || row > (${r[d]} - 1) || col < 0 || col > ${r[a]} - 1)) {\n        return ${s};\n      }\n      row = max(0, min(row, ${r[d]} - 1));\n      col = max(0, min(col, ${r[a]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = 0;\n      var batch: u32 = 0;\n      if (${r.length>2}) {\n        channel = u32(originalIndices[${p}]);\n        batch = u32(originalIndices[${u}]);\n      }\n      var x11: f32 = getInputValue(batch, channel, row1, col1);\n      var x12: f32 = getInputValue(batch, channel, row1, col2);\n      var x21: f32 = getInputValue(batch, channel, row2, col1);\n      var x22: f32 = getInputValue(batch, channel, row2, col2);\n      var dx1: f32 = row - f32(row1);\n      var dx2: f32 = f32(row2 ) - row;\n      var dy1 = col - f32(col1);\n      var dy2 = f32(col2) - col;\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},Xd=(e,t,r,o,n,s,u,d,a,p)=>{let[h,v]=r.length===2?[0,1]:n[1]===1?[2,3]:[1,2],y=b=>{let w=b===h?"row":"col";return`\n      fn ${w}CubicInterpolation(inputIndices: ${e.type.indices}, outputIndices: ${t.type.indices}) -> f32 {\n        var outputIndex = ${o.length===1?"outputIndices":`outputIndices[${b}]`};\n        var originalIdx: f32 = getOriginalCoordinateFromResizedCoordinate(f32(outputIndex), ${n[b]},\n        f32(${o[b]}), f32(${r[b]}), ${s[b]}, ${s[b]} + ${r.length});\n        var fractOriginalIdx: f32 = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${d} && (originalIdx < 0 || originalIdx > (${r[b]} - 1))) {\n          return ${a};\n        }\n        var data: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${w}: f32 = originalIdx + f32(i);\n          if (${w} < 0 || ${w} >= ${r[b]}) {\n            if (${p}) {\n              coefs[i + 1] = 0.0;\n              continue;\n            } else if (${d}) {\n              return ${a};\n            } else {\n              ${w} = max(0, min(${w}, ${r[b]} - 1));\n            }\n          }\n          var inputIndicesCopy: ${e.type.indices} = inputIndices;\n          inputIndicesCopy[${b}] = u32(${w});\n          data[i + 1] = ${b===h?`input[${e.indicesToOffset("inputIndicesCopy")}];`:`\n                                               rowCubicInterpolation(inputIndicesCopy, outputIndices);`}\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${y(h)};\n    ${y(v)};\n  fn getCubicInterpolationCoefs(s: f32) -> array<f32, 4> {\n    var absS = abs(s);\n    var coeffs: array<f32, 4> = array<f32, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: f32 = 1.0 - absS;\n    var twoMinusAbsS: f32 = 2.0 - absS;\n    var onePlusAbsS: f32 = 1.0 + absS;\n    coeffs[0] = ((${u} * onePlusAbsS - 5 * ${u}) * onePlusAbsS + 8 * ${u}) * onePlusAbsS - 4 * ${u};\n    coeffs[1] = ((${u} + 2) * absS - (${u} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${u} + 2) * oneMinusAbsS - (${u} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${u} * twoMinusAbsS - 5 * ${u}) * twoMinusAbsS + 8 * ${u}) * twoMinusAbsS - 4 * ${u};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<f32, 4>, coefs: array<f32, 4>) -> f32 {\n    var coefsSum: f32 = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(outputIndices: ${t.type.indices}) -> f32 {\n    var inputIndices: ${e.type.indices} = outputIndices;\n    return colCubicInterpolation(inputIndices, outputIndices);\n  }\n    `},Qd=(e,t,r,o,n,s)=>{let u=e.dims,d=Ld(s,t.axes,u.length),a=Fd(u,o,n,t.axes),p=o.slice();o.length===0&&(p=u.map((C,A)=>C===0?1:a[A]/C),t.keepAspectRatioPolicy!=="stretch"&&(a=jd(u,p,t)));let h=q("output",e.dataType,a),v=G("input",e.dataType,u),y=z.size(a),b=u.length===a.length&&u.every((C,A)=>C===a[A]),w=t.coordinateTransformMode==="tf_crop_and_resize",S=C=>`\n      ${b?"":`\n      ${Hd(t.coordinateTransformMode)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${Yd(v,u)};\n              ${Gd(t.nearestMode,r)};\n              ${Kd(v,h,u,a,p,d,w)};\n              `;case"linear":return`\n              ${qd(h,u,a,p,d)};\n              ${Zd(v,h,u,p,w,t.extrapolationValue)};\n              `;case"cubic":return`\n            ${Xd(v,h,u,a,p,d,t.cubicCoeffA,w,t.extrapolationValue,t.excludeOutside)};\n            `;default:throw Error("Invalid resize mode")}})()};\n      `}\n      ${C.declareVariables(v,h)}\n      ${C.mainStart()}\n        ${C.guardAgainstOutOfBoundsWorkgroupSizes(y)}\n        ${b?"output[global_idx] = input[global_idx];":`\n        let outputIndices = ${h.offsetToIndices("global_idx")};\n        var inputIndices: ${v.type.indices};\n        ${(()=>{switch(t.mode){case"nearest":return`inputIndices = calculateInputIndicesFromOutputIndices(outputIndices);\n                if (checkInputIndices(inputIndices)) {\n                  output[global_idx] = input[${v.indicesToOffset("inputIndices")}];\n                } else {\n                  output[global_idx] = ${t.extrapolationValue};\n                }`;case"linear":return"output[global_idx] = bilinearInterpolation(outputIndices);";case"cubic":return"output[global_idx] = bicubicInterpolation(outputIndices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n        `}\n      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${p.length>0?p:""}|${n.length>0?n:""}|${b}`},getShaderSource:S,getRunData:()=>({outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(y/64)}})}},Jd=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},Ms=(e,t)=>{let r=[],o=[],n=[],s=Jd(e);Ud(e.inputs,t,s,r,o,n),e.compute(Qd(e.inputs[0],t,s,r,o,n),{inputs:[0]})},Ds=e=>{let t=e.antialias,r=e.axes,o=e.coordinateTransformMode,n=e.cubicCoeffA,s=e.excludeOutside!==0,u=e.extrapolationValue,d=e.keepAspectRatioPolicy,a=e.mode,p=e.nearestMode===""?"simple":e.nearestMode;return re({antialias:t,axes:r,coordinateTransformMode:o,cubicCoeffA:n,excludeOutside:s,extrapolationValue:u,keepAspectRatioPolicy:d,mode:a,nearestMode:p})}});var ec,tc,Ws,Vs,Ns=F(()=>{"use strict";De();me();Ee();be();ec=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],r=e[1],o=e[2];if(t.dataType!==r.dataType||t.dataType!==o.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let n=t.dims[t.dims.length-1],s=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==n)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==s)throw new Error("Skip must have the same sequence length as input");if(o.dims.length!==1)throw new Error("Gamma must be 1D");if(o.dims[o.dims.length-1]!==n)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let u=e[3];if(u.dims.length!==1)throw new Error("Beta must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let u=e[4];if(u.dims.length!==1)throw new Error("Bias must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Bias must have the same hidden size as input")}},tc=(e,t,r,o)=>{let n=e[0].dims,s=z.size(n),u=n,d=s,a=n.slice(-1)[0],p=o?n.slice(0,-1).concat(1):[],h=e.length>3,v=e.length>4,y=o&&r>1,b=o&&r>2,w=r>3,S=Ze(a),C=[G("x",e[0].dataType,e[0].dims,S),G("skip",e[1].dataType,e[1].dims,S),G("gamma",e[2].dataType,e[2].dims,S)];h&&C.push(G("beta",e[3].dataType,e[3].dims,S)),v&&C.push(G("bias",e[4].dataType,e[4].dims,S)),C.push(q("output",e[0].dataType,u,S)),y&&C.push(q("meanOutput",1,p)),b&&C.push(q("invStdOutput",1,p)),w&&C.push(q("inputSkipBiasSum",e[0].dataType,u,S));let A=Ie(e[0].dataType),I=_=>`\n      const hiddenSize: f32 = ${a};\n      const hiddenSizeVectorized: u32 = ${a/S};\n      const epsilon: f32 = ${t.epsilon};\n\n      ${_.declareVariables(...C)}\n\n      ${_.mainStart()}\n        ${_.guardAgainstOutOfBoundsWorkgroupSizes(d/a)}\n        let offset = global_idx * hiddenSizeVectorized;\n        var sum = ${Ue("f32",S)};\n        var squareSum = ${Ue("f32",S)};\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          let skipValue = skip[offset + i];\n          let biasValue = ${v?"bias[i]":"0.0"};\n          let inputValue = x[offset + i];\n          let value = inputValue + skipValue + biasValue;\n          ${w?"inputSkipBiasSum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32Value = ${Qe(A,S,"value")};\n          sum += f32Value;\n          squareSum += f32Value * f32Value;\n        }\n        let mean = ${Je("sum",S)} / hiddenSize;\n        let variance = sqrt(${Je("squareSum",S)} / hiddenSize - mean * mean + epsilon);\n        ${y?"meanOutput[global_idx] = mean;":""}\n        ${b?"invStdOutput[global_idx] = 1.0 / variance;":""}\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          output[offset + i] = (output[offset + i] - ${A}(mean)) / ${A}(variance) * gamma[i]\n           + ${h?"beta[i]":"0.0"};\n        }\n      }`,B=[{dims:u,dataType:e[0].dataType}];return r>1&&B.push({dims:p,dataType:1}),r>2&&B.push({dims:p,dataType:1}),r>3&&B.push({dims:n,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:t.cacheKey},getShaderSource:I,getRunData:()=>({outputs:B,dispatchGroup:{x:Math.ceil(d/a/64)}})}},Ws=(e,t)=>{ec(e.inputs);let o=[0];e.outputCount>1&&o.push(-3),e.outputCount>2&&o.push(-3),e.outputCount>3&&o.push(3),e.compute(tc(e.inputs,t,e.outputCount,!1),{outputs:o})},Vs=e=>{let t=e.epsilon;return re({epsilon:t})}});var rc,Qr,nc,Us,oc,ac,Hs,Gs,Ls=F(()=>{"use strict";De();me();Ee();be();rc=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((r,o)=>{if(e[o+1].dataType!==6&&e[o+1].dataType!==7)throw new Error(`Input ${o} must be an array of int32 or int64`)})},Qr=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(o=>r.push(Number(o)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(o=>r.push(Number(o)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},nc=(e,t)=>{if(e.length>1){let r=Qr(e,1),o=Qr(e,2),n=Qr(e,3);return n.length===0&&(n=[...Array(e[0].dims.length).keys()]),re({starts:r,ends:o,axes:n})}else return t},Us=(e,t,r,o,n)=>{let s=e;return e<0&&(s+=r[o[t]]),n[t]<0?Math.max(0,Math.min(s,r[o[t]]-1)):Math.max(0,Math.min(s,r[o[t]]))},oc=(e,t,r,o,n)=>`fn calculateInputIndices(outputIndices: ${t.type.indices}) -> ${e.type.indices} {\n          var inputIndices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${r.length}; i >= 0; i--) {\n            let input_shape_i = ${n?`uniforms.input_shape${r.length>1?"[i]":""}`:"inputShape[i]"};\n            let steps_i  = ${n?`uniforms.steps${r.length>1?"[i]":""}`:"steps[i]"};\n            let signs_i  = ${n?`uniforms.signs${r.length>1?"[i]":""}`:"signs[i]"};\n            let starts_i  = ${n?`uniforms.starts${r.length>1?"[i]":""}`:"starts[i]"};\n            var outputIndex = ${o.length===1?"outputIndices":"outputIndices[i]"};\n            var inputIndex = outputIndex * steps_i + starts_i + carry;\n            carry = inputIndex / input_shape_i;\n            inputIndex = inputIndex % input_shape_i;\n            if (signs_i < 0) {\n              inputIndex = input_shape_i - inputIndex - 1u + starts_i;\n            }\n            ${r.length===1?"inputIndices":"inputIndices[i]"} = inputIndex;\n          }\n          return inputIndices;\n      }`,ac=(e,t)=>{let r=e[0].dims,o=z.size(r),n=t.axes.length>0?z.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],s=Qr(e,4);s.forEach(_=>_!==0||(()=>{throw new Error("step cannot be 0")})),s.length===0&&(s=Array(n.length).fill(1));let u=t.starts.map((_,R)=>Us(_,R,r,n,s)),d=t.ends.map((_,R)=>Us(_,R,r,n,s));if(n.length!==u.length||n.length!==d.length)throw new Error("start, ends and axes should have the same number of elements");if(n.length!==r.length)for(let _=0;_<r.length;++_)n.includes(_)||(u.splice(_,0,0),d.splice(_,0,r[_]),s.splice(_,0,1));let a=s.map(_=>Math.sign(_));s.forEach((_,R,E)=>{if(_<0){let W=(d[R]-u[R])/_,V=u[R],Y=V+W*s[R];u[R]=Y,d[R]=V,E[R]=-_}});let p=Ge(e[0].dims.length),h=p?e[0].dims.length:e[0].dims,v=r.slice(0);n.forEach((_,R)=>{v[_]=Math.ceil((d[_]-u[_])/s[_])});let y=p?v.length:v,b={dims:v,dataType:e[0].dataType},w=q("output",e[0].dataType,y),S=G("input",e[0].dataType,h),C=z.size(v),A=[],I=[];p&&(I.push({name:"starts",type:u.length>1?`vec${u.length}<u32>`:"u32"}),I.push({name:"signs",type:a.length>1?`vec${a.length}<i32>`:"i32"}),I.push({name:"steps",type:s.length>1?`vec${s.length}<u32>`:"u32"}),A.push({type:"uint32",data:u}),A.push({type:"int32",data:a}),A.push({type:"uint32",data:s})),I.push({name:"outputSize",type:"u32"}),A.push({type:"uint32",data:C}),p&&(A.push(...Ne(e[0].dims)),A.push(...Ne(v)));let B=_=>`\n      ${_.registerUniforms(I).declareVariables(S,w)}\n        ${p?"":[`const signs = array<i32, ${a.length}>(${a.map(R=>`${R}i`).join(",")});`,`const starts = array<u32, ${u.length}>(${u.map(R=>`${R}u`).join(",")});`,`const steps = array<u32, ${s.length}>(${s.map(R=>`${R}u`).join(",")});`,`const inputShape = array<u32, ${r.length}>(${r.map(R=>`${R}u`).join(",")});`].join(`\n`)}\n\n        ${oc(S,w,r,v,p)}\n        ${_.mainStart()}\n          ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n          let outputIndices = ${w.offsetToIndices("global_idx")};\n          let inputIndices = calculateInputIndices(outputIndices);\n          ${w.setByOffset("global_idx",S.getByIndices("inputIndices"))}\n      }`;return{name:"Slice",shaderCache:{hint:p?`${a.length}_${u.length}_${s.length}`:`${t.cacheKey} | ${e[4]?.dims??""}`,inputDependencies:[p?"rank":"dims"]},getShaderSource:B,getRunData:()=>({outputs:[b],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:A})}},Hs=(e,t)=>{rc(e.inputs,t);let r=nc(e.inputs,t);e.compute(ac(e.inputs,r),{inputs:[0]})},Gs=e=>{let t=e.starts,r=e.ends,o=e.axes;return re({starts:t,ends:r,axes:o})}});var ic,sc,Fs,js,qs=F(()=>{"use strict";me();Ee();be();ic=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},sc=(e,t)=>{let r=e.dims,o=z.size(r),n=64,s=t.axis;if(s<0&&(s=r.length+s),s<r.length-1)throw new Error("softmax only supports last axis for now.");let u=r[s],d=o/u,a=Ze(u),p=u/a,h=(C,A)=>A===4?`max(max(${C}.x, ${C}.y), max(${C}.z, ${C}.w))`:A===2?`max(${C}.x, ${C}.y)`:A===3?`max(max(${C}.x, ${C}.y), ${C}.z)`:C,v=G("x",e.dataType,e.dims,a),y=q("result",e.dataType,e.dims,a),b=v.type.value,w=Ie(e.dataType)==="f32"?`var threadMax = ${b}(-3.402823e+38f);`:`var threadMax = ${b}(-65504.0h);`,S=C=>`\n      var<workgroup> rowMaxShared : ${b};\n      var<workgroup> rowSumShared : ${b};\n      var<workgroup> threadShared : array<${b}, ${n}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${b} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${b}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${C.registerUniform("packedCols","i32").declareVariables(v,y)}\n      ${C.mainStart()}\n        let gindex = i32(global_id.x);\n        let lindex = i32(local_id.x);\n        const wg = ${n};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${w}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${b}(${h("threadShared[0]",a)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${b}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${b}(${Je("threadShared[0]",a)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`;return{name:"Softmax",shaderCache:{hint:`${a}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:r,dataType:e.dataType}],dispatchGroup:{x:d},programUniforms:[{type:"uint32",data:p}]}),getShaderSource:S}},Fs=(e,t)=>{ic(e.inputs),e.compute(sc(e.inputs[0],t))},js=e=>re({axis:e.axis})});var uc,lc,dc,cc,pc,Ks,Ys,Zs=F(()=>{"use strict";me();Ee();be();uc=e=>{if(!e||e.length<1)throw new Error("too few inputs")},lc=(e,t)=>{let r=[],o=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(n=>r.push(Number(n))),o=r.length),re({numOutputs:o,axis:t.axis,splitSizes:r})},dc=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < sizeInConcatAxis[i]) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,cc=e=>{let t=e.length,r=[];for(let o=0;o<t;++o){let n=e[o].setByIndices("indices","input[global_idx]");t===1?r.push(n):o===0?r.push(`if (outputNumber == ${o}u) { ${n} }`):o===t-1?r.push(`else { ${n} }`):r.push(`else if (outputNumber == ${o}) { ${n} }`)}return`\n      fn writeBufferData(outputNumber: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${r.join(`\n`)}\n      }`},pc=(e,t)=>{let r=e[0].dims,o=z.size(r),n=e[0].dataType,s=r.length,u=t.axis,d=u<0?r.length+u:u,a=new Array(t.numOutputs),p=G("input",n,r),h=new Array(t.numOutputs),v=[],y=[],b=0;for(let C=0;C<t.numOutputs;C++){b+=t.splitSizes[C],h[C]=b;let A=r.slice();A[t.axis]=t.splitSizes[C],y.push(A),a[C]=q(`output${C}`,n,y[C]),v.push({dims:y[C],dataType:e[0].dataType})}let w=s<2?"indices":`indices[${d}]`,S=C=>`\n  ${C.declareVariables(p,...a)}\n  const sizeInConcatAxis = array<u32, ${h.length}>(${h.map(A=>`${A}u`).join(",")});\n  ${dc(h.length)}\n  ${cc(a)}\n\n  ${C.mainStart()}\n    ${C.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n\n    var indices = ${p.offsetToIndices("global_idx")};\n    let outputNumber = calculateOutputIndex(${w});\n    if (outputNumber != 0) {\n        ${w} -= sizeInConcatAxis[outputNumber - 1u];\n    }\n    writeBufferData(outputNumber, indices, global_idx);\n  }`;return{name:"Split",shaderCache:{hint:t.cacheKey},getShaderSource:S,getRunData:()=>({outputs:v,dispatchGroup:{x:Math.ceil(o/64)}})}},Ks=(e,t)=>{uc(e.inputs);let r=e.inputs.length===1?t:lc(e.inputs,t);e.compute(pc(e.inputs,r),{inputs:[0]})},Ys=e=>{let t=e.axis,r=e.splitSizes,o=e.numOutputs<0?r.length:e.numOutputs;if(o!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return re({axis:t,numOutputs:o,splitSizes:r})}});var Xs,fc,mc,hc,Qs,Js=F(()=>{"use strict";De();me();be();Xs=e=>Array.from(e.getBigInt64Array(),Number),fc=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(Xs(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},mc=(e,t)=>{let r=[];for(let o=0;o<e.length;++o)r.push(e[o]*t[o]);return r},hc=e=>{let t=e[0].dims,r=Xs(e[1]),o=mc(t,r),n=z.size(o),s=e[0].dataType,u=G("input",s,t),d=q("output",s,o),a=p=>`\n      const inputShape = ${u.indices(...t)};\n      ${p.declareVariables(u,d)}\n      ${p.mainStart()}\n      ${p.guardAgainstOutOfBoundsWorkgroupSizes(n)}\n      let outputIndices = ${d.offsetToIndices("global_idx")};\n      var inputIndices: ${u.type.indices};\n      for (var i = 0; i < ${t.length}; i++) {\n        let inputDimValue = ${d.indicesGet("outputIndices","i")}  % ${u.indicesGet("inputShape","i")};\n\n        ${u.indicesSet("inputIndices","i","inputDimValue")}\n      }\n      ${d.setByOffset("global_idx",u.getByIndices("inputIndices"))}\n    }`;return{name:"Tile",shaderCache:{hint:`${r}`},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)}}),getShaderSource:a}},Qs=e=>{fc(e.inputs),e.compute(hc(e.inputs),{inputs:[0]})}});var gc,yc,eu,tu=F(()=>{"use strict";De();me();be();gc=(e,t,r,o,n)=>{let s=z.size(r),u=Math.ceil(s/4),d=q("outputData",n,r,4),a=G("aData",t[1].dataType,t[1].dims,4),p=G("bData",t[2].dataType,t[2].dims,4),h=G("cData",t[0].dataType,t[0].dims,4),v,y=(b,w,S)=>`select(${w}, ${b}, ${S})`;if(!o)v=d.setByOffset("global_idx",y(a.getByOffset("global_idx"),p.getByOffset("global_idx"),h.getByOffset("global_idx")));else{let b=(w,S,C="")=>{let A=`aData[indexA${S}][componentA${S}]`,I=`bData[indexB${S}][componentB${S}]`,B=`bool(cData[indexC${S}] & ${4278190080>>>(3-S)*8}u)`;return`\n            let outputIndices${S} = ${d.offsetToIndices(`global_idx * 4u + ${S}u`)};\n            let offsetA${S} = ${a.broadcastedIndicesToOffset(`outputIndices${S}`,d)};\n            let offsetB${S} = ${p.broadcastedIndicesToOffset(`outputIndices${S}`,d)};\n            let offsetC${S} = ${h.broadcastedIndicesToOffset(`outputIndices${S}`,d)};\n            let indexA${S} = offsetA${S} / 4u;\n            let indexB${S} = offsetB${S} / 4u;\n            let indexC${S} = offsetC${S} / 4u;\n            let componentA${S} = offsetA${S} % 4u;\n            let componentB${S} = offsetB${S} % 4u;\n            ${w}[${S}] = ${C}(${y(A,I,B)});\n          `};n===9?v=`\n            var data = vec4<u32>(0);\n            ${b("data",0,"u32")}\n            ${b("data",1,"u32")}\n            ${b("data",2,"u32")}\n            ${b("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:v=`\n            ${b("outputData[global_idx]",0)}\n            ${b("outputData[global_idx]",1)}\n            ${b("outputData[global_idx]",2)}\n            ${b("outputData[global_idx]",3)}\n          `}return`\n        ${e.declareVariables(h,a,p,d)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n        ${v}\n      }`},yc=e=>{let t=e[1].dims,r=e[2].dims,o=e[0].dims,n=e[1].dataType,s=!(z.areEqual(t,r)&&z.areEqual(r,o)),u=t,d=z.size(t);if(s){let a=at.calcShape(at.calcShape(t,r,!1),o,!1);if(!a)throw new Error("Can\'t perform where op on the given tensors");u=a,d=z.size(u)}return{name:"Where",getShaderSource:a=>gc(a,e,u,s,n),getRunData:()=>({outputs:[{dims:u,dataType:n}],dispatchGroup:{x:Math.ceil(d/64/4)}})}},eu=e=>{e.compute(yc(e.inputs))}});var ru,nu=F(()=>{"use strict";pa();_n();ga();Ya();ii();li();Pn();Si();Ai();Ei();Pi();Mi();Wi();Ui();Li();ji();Zi();Ji();ms();Bs();zr();zs();Ns();Ls();qs();Zs();Js();Wt();Tn();tu();ru=new Map([["Abs",[ya]],["Acos",[ba]],["Acosh",[wa]],["Add",[Za]],["ArgMax",[ca,An]],["ArgMin",[da,An]],["Asin",[va]],["Asinh",[$a]],["Atan",[Sa]],["Atanh",[xa]],["Attention",[ma,fa]],["AveragePool",[as,os]],["BiasAdd",[ha]],["BiasSplitGelu",[Ka]],["Cast",[Ia,Ca]],["Ceil",[_a]],["Clip",[Aa]],["Concat",[si,ui]],["Conv",[Bn,Rn]],["ConvTranspose",[$i,vi]],["Cos",[Ta]],["Cosh",[Ea]],["Div",[Xa]],["Einsum",[Ci,Ii]],["Elu",[Oa,Nr]],["Equal",[Qa]],["Erf",[ka]],["Exp",[Pa]],["Expand",[Ti]],["Floor",[Ra]],["FusedConv",[Bn,Rn]],["Gather",[ki,Oi]],["GatherElements",[Bi,Ri]],["Gelu",[Ba]],["Gemm",[Di,zi]],["GlobalAveragePool",[us,ss]],["GlobalMaxPool",[fs,ps]],["Greater",[ri]],["GreaterOrEqual",[oi]],["InstanceNormalization",[Ni,Vi]],["LayerNormalization",[Gi,Hi]],["LeakyRelu",[Ma,Nr]],["Less",[ni]],["LessOrEqual",[ai]],["Log",[qa]],["MatMul",[Fi]],["MaxPool",[ds,cs]],["Mul",[Ja]],["MultiHeadAttention",[Yi,Ki]],["Neg",[za]],["Not",[Da]],["Pad",[Xi,Qi]],["Pow",[ei]],["Range",[Rs]],["Reciprocal",[Wa]],["ReduceMin",[oa,tt]],["ReduceMean",[Jo,tt]],["ReduceMax",[na,tt]],["ReduceSum",[ia,tt]],["ReduceProd",[aa,tt]],["ReduceL1",[ea,tt]],["ReduceL2",[ta,tt]],["ReduceLogSum",[ua,tt]],["ReduceLogSumExp",[ra,tt]],["ReduceSumSquare",[sa,tt]],["Relu",[Va]],["Resize",[Ms,Ds]],["Sigmoid",[Na]],["Sin",[Ua]],["Sinh",[Ha]],["Slice",[Hs,Gs]],["SkipLayerNormalization",[Ws,Vs]],["Split",[Ks,Ys]],["Sqrt",[Ga]],["Softmax",[Fs,js]],["Sub",[ti]],["Tan",[La]],["Tanh",[Fa]],["ThresholdedRelu",[ja,Nr]],["Tile",[Qs]],["Transpose",[No,Uo]],["Where",[eu]]])});var Jr,ou=F(()=>{"use strict";De();wt();be();Jr=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,o,n,s,u,d){let a=this.backend.device,p=this.backend.getComputePassEncoder();p.setPipeline(t.computePipeline);let h=[];for(let y of n)h.push({binding:h.length,resource:{buffer:y.buffer}});for(let y of s)h.push({binding:h.length,resource:{buffer:y.buffer}});d&&h.push({binding:h.length,resource:d});let v=a.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:h,label:t.programInfo.name});if(p.setBindGroup(0,v),p.dispatchWorkgroups(...u),this.backend.pendingDispatchNumber++,this.backend.isQueryEnabled()){typeof this.backend.queryData>"u"&&(this.backend.queryData=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let y=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.querySet,0,2,this.backend.queryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.queryData.buffer,0,y.buffer,0,this.backend.querySetCount*8),this.backend.flush();let b=this.backend.currentKernelId,w=this.backend.kernels.get(b),S=`[${w[0]}] ${w[1]}`;y.buffer.mapAsync(GPUMapMode.READ).then(()=>{let C=new BigUint64Array(y.buffer.getMappedRange()),A=C[0],I=C[1];y.buffer.unmap(),typeof this.backend.queryTimeBase>"u"&&(this.backend.queryTimeBase=A);let B=Number(A-this.backend.queryTimeBase),_=Number(I-this.backend.queryTimeBase);if(!Number.isSafeInteger(B)||!Number.isSafeInteger(_))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(y.id);let R="";r.forEach((W,V)=>{R+=`input[${V}]: [${W.dims}] | ${or(W.dataType)}, `});let E="";o.forEach((W,V)=>{E+=`output[${V}]: [${W.dims}] | ${or(W.dataType)}, `}),console.log(`[profiling] kernel "${b}|${S}" ${R}${E}execution time: ${_-B} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(t,r){let o=this.backend.device,n=[];o.features.has("shader-f16")&&n.push("enable f16;");let s=Wo(r),u=t.getShaderSource(s),d=`${n.join(`\n`)}\n${s.additionalImplementations}\n${u}`,a=o.createShaderModule({code:d,label:t.name});Te("verbose",()=>`[WebGPU] ${t.name} shader code: ${d}`);let p=o.createComputePipeline({compute:{module:a,entryPoint:"main"},layout:"auto",label:t.name});return{programInfo:t,computePipeline:p}}normalizeDispatchGroupSize(t){let r=typeof t=="number"?t:t.x,o=typeof t=="number"?1:t.y||1,n=typeof t=="number"?1:t.z||1,s=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=s&&o<=s&&n<=s)return[r,o,n];let u=r*o*n,d=Math.ceil(Math.sqrt(u));if(d>s){if(d=Math.ceil(Math.cbrt(u)),d>s)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[d,d,d]}else return[d,d,1]}}});var bc,wc,en,au=F(()=>{"use strict";wt();ko();Mo();nu();ou();bc=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let o=0;o<e.length;++o){let n=e[o].dataType;switch(t[o]){case"none":{r.push("");break}case"type":{r.push(`${n}`);break}case"rank":{let s=e[o].dims.length;r.push(`${n};${s}`);break}case"dims":{let s=e[o].dims.join(",");r.push(`${n};${s}`);break}default:throw new Error(`unsupported input dependency: ${t[o]}`)}}return r.join("|")},wc=(e,t,r)=>{let o=e.name;return e.shaderCache?.hint&&(o+="["+e.shaderCache.hint+"]"),o+=":"+r+`:${bc(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,o},en=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispatchNumber=0;this.querySetCount=2;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");let r=await navigator.gpu.requestAdapter();if(!r)throw new Error("WebGpuBackend: Failed to get GPU adapter.");this.env=t;let o=[],n={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:o};r.features.has("timestamp-query")&&o.push("timestamp-query"),r.features.has("shader-f16")&&o.push("shader-f16"),this.device=await r.requestDevice(n),this.gpuDataManager=Bo(this),this.programManager=new Jr(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Eo(t.logLevel,!!t.debug),this.device.onuncapturederror=s=>{s.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${s.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t={};this.isQueryEnabled()&&(typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}isQueryEnabled(){return!!(this.device.features.has("timestamp-query")&&this.env.webgpu.profilingMode==="default")}run(t,r,o,n,s){let u=[];for(let I=0;I<r.length;++I){let B=this.gpuDataManager.get(r[I].data);if(!B)throw new Error(`no GPU data for input: ${r[I].data}`);u[I]=B}let{outputs:d,dispatchGroup:a,programUniforms:p}=t.getRunData(r),h=o.length===0?d.map((I,B)=>B):o;if(h.length!==d.length)throw new Error(`Output size ${h.length} must be equal to ${d.length}.`);let v=[],y=[];for(let I=0;I<d.length;++I){if(!Number.isInteger(h[I])||h[I]<-3||h[I]>=d.length)throw new Error(`Invalid output index: ${h[I]}`);if(h[I]===-3)continue;let B=h[I]===-1,_=h[I]===-2,R=B||_?s(d[I].dataType,d[I].dims):n(h[I],d[I].dataType,d[I].dims),E=this.gpuDataManager.get(R.data);if(!E)throw new Error(`no GPU data for output: ${R.data}`);if(B&&this.temporaryData.push(E),_){let W=this.kernelPersistentData.get(this.currentKernelId);W||(W=[],this.kernelPersistentData.set(this.currentKernelId,W)),W.push(E)}v.push(R),y.push(E)}let b;if(p){let I=0,B=0,_=[],R=1;p.forEach(V=>{let Y=typeof V.data=="number"?[V.data]:V.data;if(Y.length===0)return;let ae;switch(Y.length){case 1:ae=4;break;case 2:ae=8;break;case 3:ae=16;break;case 4:ae=16;break;case 5:ae=16;break;case 6:ae=16;break;default:throw new Error(`unsupported data length: ${Y.length}`)}(B===5||B===6)&&(ae=16),ae>R&&(R=ae),I=Math.ceil(I/ae)*ae,B=Y.length,_.push(I),I+=Y.length*4}),I=Math.ceil(I/R)*R;let E=new ArrayBuffer(I);p.forEach((V,Y)=>{let ae=_[Y],M=typeof V.data=="number"?[V.data]:V.data;V.type==="int32"?new Int32Array(E,ae,M.length).set(M):V.type==="uint32"?new Uint32Array(E,ae,M.length).set(M):new Float32Array(E,ae,M.length).set(M)});let W=this.gpuDataManager.create(I,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(W.buffer,0,E,0,I),this.gpuDataManager.release(W.id),b={offset:0,size:I,buffer:W.buffer}}let w=this.programManager.normalizeDispatchGroupSize(a),S=w[1]===1&&w[2]===1,C=wc(t,r,S),A=this.programManager.getArtifact(C);return A||(A=this.programManager.build(t,w),this.programManager.setArtifact(C,A)),Te("info",()=>`[ProgramManager] run "${t.name}" (key=${C}) with ${w[0]}x${w[1]}x${w[2]}`),this.programManager.run(A,r,v,u,y,w,b),v}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,o,n){let s=ru.get(t);if(!s)throw new Error(`kernel not implemented: ${t}`);this.kernels.set(r,[t,n,s[0],[s[1],o]])}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let o of r)this.gpuDataManager.release(o.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,o){let n=this.kernels.get(t);if(!n)throw new Error(`kernel not created: ${t}`);let[s,u,d,a]=n;if(this.currentKernelId!==null)throw new Error(`kernel "[${s}] ${u}" is not allowed to be called recursively`);this.currentKernelId=t,a[0]&&(a[1]=a[0](a[1]),a[0]=void 0),Te("info",()=>`[WebGPU] Start to run kernel "[${s}] ${u}"...`);let p=this.env.debug;this.temporaryData=[];try{return p&&this.device.pushErrorScope("validation"),d(r,a[1]),0}catch(h){return o.push(Promise.resolve(`[WebGPU] Kernel "[${s}] ${u}" failed. ${h}`)),1}finally{p&&o.push(this.device.popErrorScope().then(h=>h?`GPU validation error for kernel "[${s}] ${u}": ${h.message}`:null));for(let h of this.temporaryData)this.gpuDataManager.release(h.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,o,n){let s=this.sessionExternalDataMapping.get(t);s||(s=new Map,this.sessionExternalDataMapping.set(t,s));let u=s.get(r),d=this.gpuDataManager.registerExternalBuffer(o,n,u?.[1]);return s.set(r,[d,o]),d}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(o=>this.gpuDataManager.unregisterExternalBuffer(o[1])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,o){return async()=>{let n=await vn(this,t,r);return Oo(n.buffer,o)}}}});var iu={};Er(iu,{init:()=>vc});var dr,Un,vc,su=F(()=>{"use strict";De();au();wt();me();dr=class e{constructor(t,r,o,n){this.module=t;this.dataType=r;this.data=o;this.dims=n}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=z.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=z.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=z.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(z.size(t)!==z.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},Un=class{constructor(t,r,o){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;let n=t.HEAPU32,s=o>>2;this.opKernelContext=n[s++];let u=n[s++];this.outputCount=n[s++],this.customDataOffset=n[s++],this.customDataSize=n[s++];let d=[];for(let a=0;a<u;a++){let p=n[s++],h=n[s++],v=n[s++],y=[];for(let b=0;b<v;b++)y.push(n[s++]);d.push(new dr(t,p,h,y))}this.inputs=d}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,r){let o=r?.inputs?.map(d=>typeof d=="number"?this.inputs[d]:d)??this.inputs,n=r?.outputs??[],s=(d,a,p)=>new dr(this.module,a,this.output(d,p),p),u=(d,a)=>{let p=ar(d);if(!p)throw new Error(`Unsupported data type: ${d}`);let h=p*z.size(a);return new dr(this.module,d,this.backend.gpuDataManager.create(h).id,a)};return this.backend.run(t,o,n,s,u)}output(t,r){let o=this.module.stackSave();try{let n=this.module.stackAlloc((1+r.length)*4),s=n>>2;this.module.HEAPU32[s++]=r.length;for(let u=0;u<r.length;u++)this.module.HEAPU32[s++]=r[u];return this.module._JsepOutput(this.opKernelContext,t,n)}catch(n){throw new Error(`Failed to generate kernel\'s output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(o)}}},vc=async(e,t)=>{let r=e.jsepInit;if(r&&navigator.gpu){if(!t.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using WebGPU EP");let o=new en;await o.initialize(t),r(o,n=>o.alloc(n),n=>o.free(n),(n,s,u,d=!1)=>{if(d)Te("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${n}, dst=${s}, size=${u}`),o.memcpy(n,s);else{Te("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${n}, gpuDataId=${s}, size=${u}`);let a=e.HEAPU8.subarray(n,n+u);o.upload(s,a)}},async(n,s,u)=>{Te("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${n}, dataOffset=${s}, size=${u}`),await o.download(n,()=>e.HEAPU8.subarray(s,s+u))},(n,s,u)=>o.createKernel(n,s,u,t.debug||t.webgpu.profilingMode==="default"?e.UTF8ToString(e._JsepGetNodeName(s)):`${s}`),n=>o.releaseKernel(n),(n,s,u,d)=>{Te("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${u}, kernel=${n}, contextDataOffset=${s}`);let a=new Un(e,o,s);return o.computeKernel(n,a,d)})}}});var So;So=po();var Wu=wo(),hn,gn=!1,Or=!1,$o=!1,Vu=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},Nu=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Uu=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",xo=async e=>{if(gn)return Promise.resolve();if(Or)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if($o)throw new Error("previous call to \'initializeWebAssembly()\' failed.");Or=!0;let t=e.initTimeout,r=e.numThreads,o=e.simd,n=r>1&&Vu(),s=o&&Nu(),u=e.wasmPaths,d=typeof u=="string"?u:void 0,a=Uu(s,n),p=typeof u=="object"?u[a]:void 0,h=!1,v=[];if(t>0&&v.push(new Promise(y=>{setTimeout(()=>{h=!0,y()},t)})),v.push(new Promise((y,b)=>{let w=n?Wu:So,S={locateFile:(C,A)=>{if(n&&C.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([vo()],{type:"text/javascript"}));if(C.endsWith(".wasm")){if(p)return p;let I=d??A;return a==="ort-wasm-simd.wasm"?I+"ort-wasm-simd.jsep.wasm":a==="ort-wasm-simd-threaded.wasm"?I+"ort-wasm-simd-threaded.jsep.wasm":I+a}return A+C}};if(n)if(typeof Blob>"u")S.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let C=`var ortWasmThreaded=${w.toString()};`;S.mainScriptUrlOrBlob=new Blob([C],{type:"text/javascript"})}w(S).then(C=>{Or=!1,gn=!0,hn=C,y()},C=>{Or=!1,$o=!0,b(C)})})),await Promise.race(v),h)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},ke=()=>{if(gn&&hn)return hn;throw new Error("WebAssembly is not initialized yet.")};var Be=(e,t)=>{let r=ke(),o=r.lengthBytesUTF8(e)+1,n=r._malloc(o);return r.stringToUTF8(e,n,o),t.push(n),n},nr=(e,t,r,o)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([n,s])=>{let u=t?t+n:n;if(typeof s=="object")nr(s,u+".",r,o);else if(typeof s=="string"||typeof s=="number")o(u,s.toString());else if(typeof s=="boolean")o(u,s?"1":"0");else throw new Error(`Can\'t handle extra config type: ${typeof s}`)})},Ae=e=>{let t=ke(),r=t.stackSave();try{let o=t.stackAlloc(8);t._OrtGetLastError(o,o+4);let n=t.HEAP32[o/4],s=t.HEAPU32[o/4+1],u=s?t.UTF8ToString(s):"";throw new Error(`${e} ERROR_CODE: ${n}, ERROR_MESSAGE: ${u}`)}finally{t.stackRestore(r)}};var Co=e=>{let t=ke(),r=0,o=[],n=e||{};try{if(e?.logSeverityLevel===void 0)n.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)n.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(n.terminate=!1);let s=0;return e?.tag!==void 0&&(s=Be(e.tag,o)),r=t._OrtCreateRunOptions(n.logSeverityLevel,n.logVerbosityLevel,!!n.terminate,s),r===0&&Ae("Can\'t create run options."),e?.extra!==void 0&&nr(e.extra,"",new WeakSet,(u,d)=>{let a=Be(u,o),p=Be(d,o);t._OrtAddRunConfigEntry(r,a,p)!==0&&Ae(`Can\'t set a run config entry: ${u} - ${d}.`)}),[r,o]}catch(s){throw r!==0&&t._OrtReleaseRunOptions(r),o.forEach(u=>t._free(u)),s}};var Hu=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},Gu=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Lu=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},Fu=(e,t,r)=>{for(let o of t){let n=typeof o=="string"?o:o.name;switch(n){case"xnnpack":n="XNNPACK";break;case"webnn":if(n="WEBNN",typeof o!="string"){let u=o;if(u?.deviceType){let d=Be("deviceType",r),a=Be(u.deviceType,r);ke()._OrtAddSessionConfigEntry(e,d,a)!==0&&Ae(`Can\'t set a session config entry: \'deviceType\' - ${u.deviceType}.`)}if(u?.numThreads){let d=u.numThreads;(typeof d!="number"||!Number.isInteger(d)||d<0)&&(d=0);let a=Be("numThreads",r),p=Be(d.toString(),r);ke()._OrtAddSessionConfigEntry(e,a,p)!==0&&Ae(`Can\'t set a session config entry: \'numThreads\' - ${u.numThreads}.`)}if(u?.powerPreference){let d=Be("powerPreference",r),a=Be(u.powerPreference,r);ke()._OrtAddSessionConfigEntry(e,d,a)!==0&&Ae(`Can\'t set a session config entry: \'powerPreference\' - ${u.powerPreference}.`)}}break;case"webgpu":if(n="JS",typeof o!="string"){let u=o;if(u?.preferredLayout){if(u.preferredLayout!=="NCHW"&&u.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${u.preferredLayout}`);let d=Be("preferredLayout",r),a=Be(u.preferredLayout,r);ke()._OrtAddSessionConfigEntry(e,d,a)!==0&&Ae(`Can\'t set a session config entry: \'preferredLayout\' - ${u.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${n}`)}let s=Be(n,r);ke()._OrtAppendExecutionProvider(e,s)!==0&&Ae(`Can\'t append execution provider: ${n}.`)}},Io=e=>{let t=ke(),r=0,o=[],n=e||{};Lu(n);try{let s=Hu(n.graphOptimizationLevel??"all"),u=Gu(n.executionMode??"sequential"),d=typeof n.logId=="string"?Be(n.logId,o):0,a=n.logSeverityLevel??2;if(!Number.isInteger(a)||a<0||a>4)throw new Error(`log serverity level is not valid: ${a}`);let p=n.logVerbosityLevel??0;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log verbosity level is not valid: ${p}`);let h=typeof n.optimizedModelFilePath=="string"?Be(n.optimizedModelFilePath,o):0;if(r=t._OrtCreateSessionOptions(s,!!n.enableCpuMemArena,!!n.enableMemPattern,u,!!n.enableProfiling,0,d,a,p,h),r===0&&Ae("Can\'t create session options."),n.executionProviders&&Fu(r,n.executionProviders,o),n.freeDimensionOverrides)for(let[v,y]of Object.entries(n.freeDimensionOverrides)){if(typeof v!="string")throw new Error(`free dimension override name must be a string: ${v}`);if(typeof y!="number"||!Number.isInteger(y)||y<0)throw new Error(`free dimension override value must be a non-negative integer: ${y}`);let b=Be(v,o);t._OrtAddFreeDimensionOverride(r,b,y)!==0&&Ae(`Can\'t set a free dimension override: ${v} - ${y}.`)}return n.extra!==void 0&&nr(n.extra,"",new WeakSet,(v,y)=>{let b=Be(v,o),w=Be(y,o);t._OrtAddSessionConfigEntry(r,b,w)!==0&&Ae(`Can\'t set a session config entry: ${v} - ${y}.`)}),[r,o]}catch(s){throw r!==0&&t._OrtReleaseSessionOptions(r),o.forEach(u=>t._free(u)),s}};De();var lu=!1,$c=e=>{let t=ke(),r=t.stackSave();try{let o=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,o,o+4)!==0&&Ae("Can\'t get session input/output count."),[t.HEAP32[o/4],t.HEAP32[o/4+1]]}finally{t.stackRestore(r)}},Sc=(e,t)=>{ke()._OrtInit(e,t)!==0&&Ae("Can\'t initialize onnxruntime.")},du=async e=>{Sc(e.wasm.numThreads,ir(e.logLevel));{let t=(su(),zt(iu)).init;await t(ke(),e)}lu=!0},cr=new Map,cu=()=>lu,Hn=e=>{let t=ke(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},Gn=(e,t)=>{let r=ke(),o=0,n=0,s=0,u=[],d=[],a=[];try{[n,u]=Io(t),o=r._OrtCreateSession(e[0],e[1],n),o===0&&Ae("Can\'t create a session.");let[p,h]=$c(o),v=[],y=[],b=[];for(let S=0;S<p;S++){let C=r._OrtGetInputName(o,S);C===0&&Ae("Can\'t get an input name."),d.push(C),v.push(r.UTF8ToString(C))}for(let S=0;S<h;S++){let C=r._OrtGetOutputName(o,S);C===0&&Ae("Can\'t get an output name."),a.push(C);let A=r.UTF8ToString(C);y.push(A);{let I=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[A]??"cpu";if(I!=="cpu"&&I!=="cpu-pinned"&&I!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${I}.`);b.push(I)}}let w=null;return b.some(S=>S==="gpu-buffer")&&(s=r._OrtCreateBinding(o),s===0&&Ae("Can\'t create IO binding."),w={handle:s,outputPreferredLocations:b,outputPreferredLocationsEncoded:b.map(S=>bn(S))}),cr.set(o,[o,d,a,w]),[o,v,y]}catch(p){throw d.forEach(h=>r._OrtFree(h)),a.forEach(h=>r._OrtFree(h)),s!==0&&r._OrtReleaseBinding(s),o!==0&&r._OrtReleaseSession(o),p}finally{r._free(e[0]),n!==0&&r._OrtReleaseSessionOptions(n),u.forEach(p=>r._free(p))}},pu=(e,t)=>{let r=Hn(e);return Gn(r,t)},fu=e=>{let t=ke(),r=cr.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[o,n,s,u]=r;u&&t._OrtReleaseBinding(u.handle),t.jsepUnregisterBuffers?.(e),n.forEach(d=>t._OrtFree(d)),s.forEach(d=>t._OrtFree(d)),t._OrtReleaseSession(o),cr.delete(e)},uu=(e,t,r,o,n)=>{if(!e){t.push(0);return}let s=ke(),u=e[0],d=e[1],a=e[3],p,h;if(u==="string"&&a==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(a==="gpu-buffer"){let b=e[2].gpuBuffer,w=ar(yn(u));h=d.reduce((S,C)=>S*C,1)*w,p=s.jsepRegisterBuffer(o,n,b,h)}else{let b=e[2];if(Array.isArray(b)){h=4*b.length,p=s._malloc(h),r.push(p);let w=p/4;for(let S=0;S<b.length;S++){if(typeof b[S]!="string")throw new TypeError(`tensor data at index ${S} is not a string`);s.HEAPU32[w++]=Be(b[S],r)}}else h=b.byteLength,p=s._malloc(h),r.push(p),s.HEAPU8.set(new Uint8Array(b.buffer,b.byteOffset,h),p)}let v=s.stackSave(),y=s.stackAlloc(4*d.length);try{let b=y/4;d.forEach(S=>s.HEAP32[b++]=S);let w=s._OrtCreateTensor(yn(u),p,h,y,d.length,bn(a));w===0&&Ae(`Can\'t create tensor for input/output. session=${o}, index=${n}.`),t.push(w)}finally{s.stackRestore(v)}},mu=async(e,t,r,o,n,s)=>{let u=ke(),d=cr.get(e);if(!d)throw new Error(`cannot run inference. invalid session id: ${e}`);let[a,p,h,v]=d,y=t.length,b=o.length,w=0,S=[],C=[],A=[],I=[],B=u.stackSave(),_=u.stackAlloc(y*4),R=u.stackAlloc(y*4),E=u.stackAlloc(b*4),W=u.stackAlloc(b*4);try{[w,S]=Co(s);for(let ue=0;ue<y;ue++)uu(r[ue],C,I,e,t[ue]);for(let ue=0;ue<b;ue++)uu(n[ue],A,I,e,y+o[ue]);let V=_/4,Y=R/4,ae=E/4,M=W/4;for(let ue=0;ue<y;ue++)u.HEAPU32[V++]=C[ue],u.HEAPU32[Y++]=p[t[ue]];for(let ue=0;ue<b;ue++)u.HEAPU32[ae++]=A[ue],u.HEAPU32[M++]=h[o[ue]];if(v){let{handle:ue,outputPreferredLocations:ve,outputPreferredLocationsEncoded:j}=v;if(p.length!==y)throw new Error(`input count from feeds (${y}) is expected to be always equal to model\'s input count (${p.length}).`);for(let xe=0;xe<y;xe++){let Pe=t[xe];await u._OrtBindInput(ue,p[Pe],C[xe])!==0&&Ae(`Can\'t bind input[${xe}] for session=${e}.`)}for(let xe=0;xe<b;xe++){let Pe=o[xe];n[xe]?.[3]?u._OrtBindOutput(ue,h[Pe],A[xe],0)!==0&&Ae(`Can\'t bind pre-allocated output[${xe}] for session=${e}.`):u._OrtBindOutput(ue,h[Pe],0,j[Pe])!==0&&Ae(`Can\'t bind output[${xe}] to ${ve[xe]} for session=${e}.`)}}let K;v?K=await u._OrtRunWithBinding(a,v.handle,b,E,w):K=await u._OrtRun(a,R,_,y,W,b,E,w),K!==0&&Ae("failed to call OrtRun().");let Se=[];for(let ue=0;ue<b;ue++){let ve=u.HEAPU32[E/4+ue];if(ve===A[ue]){Se.push(n[ue]);continue}let j=u.stackSave(),xe=u.stackAlloc(4*4),Pe=!1,_e,Ce=0;try{u._OrtGetTensorData(ve,xe,xe+4,xe+8,xe+12)!==0&&Ae(`Can\'t access output tensor data on index ${ue}.`);let Le=xe/4,je=u.HEAPU32[Le++];Ce=u.HEAPU32[Le++];let L=u.HEAPU32[Le++],de=u.HEAPU32[Le++],pe=[];for(let Oe=0;Oe<de;Oe++)pe.push(u.HEAPU32[L/4+Oe]);u._OrtFree(L);let We=pe.reduce((Oe,Me)=>Oe*Me,1);_e=or(je);let Fe=v?.outputPreferredLocations[o[ue]];if(_e==="string"){if(Fe==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Oe=[],Me=Ce/4;for(let He=0;He<We;He++){let rt=u.HEAPU32[Me++],qe=He===We-1?void 0:u.HEAPU32[Me]-rt;Oe.push(u.UTF8ToString(rt,qe))}Se.push([_e,pe,Oe,"cpu"])}else if(Fe==="gpu-buffer"&&We>0){let Oe=u.jsepGetBuffer(Ce),Me=ar(je);if(Me===void 0||!Ao(_e))throw new Error(`Unsupported data type: ${_e}`);Pe=!0,Se.push([_e,pe,{gpuBuffer:Oe,download:u.jsepCreateDownloader(Oe,We*Me,_e),dispose:()=>{u._OrtReleaseTensor(ve)}},"gpu-buffer"])}else{let Oe=kr(_e),Me=new Oe(We);new Uint8Array(Me.buffer,Me.byteOffset,Me.byteLength).set(u.HEAPU8.subarray(Ce,Ce+Me.byteLength)),Se.push([_e,pe,Me,"cpu"])}}finally{u.stackRestore(j),_e==="string"&&Ce&&u._free(Ce),Pe||u._OrtReleaseTensor(ve)}}return v&&u._OrtClearBoundOutputs(v.handle),Se}finally{u.stackRestore(B),C.forEach(V=>u._OrtReleaseTensor(V)),A.forEach(V=>u._OrtReleaseTensor(V)),I.forEach(V=>u._free(V)),w!==0&&u._OrtReleaseRunOptions(w),S.forEach(V=>u._free(V))}},hu=e=>{let t=ke(),r=cr.get(e);if(!r)throw new Error("invalid session id");let o=r[0],n=t._OrtEndProfiling(o);n===0&&Ae("Can\'t get an profile file name."),t._OrtFree(n)},gu=e=>{let t=[];for(let r of e){let o=r[2];!Array.isArray(o)&&"buffer"in o&&t.push(o.buffer)}return t};self.onmessage=e=>{switch(e.data.type){case"init-wasm":try{xo(e.data.in).then(()=>postMessage({type:"init-wasm"}),t=>postMessage({type:"init-wasm",err:t}))}catch(t){postMessage({type:"init-wasm",err:t})}break;case"init-ort":try{du(e.data.in).then(()=>postMessage({type:"init-ort"}),t=>postMessage({type:"init-ort",err:t}))}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{let{model:t}=e.data.in,r=Hn(t);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{let{modeldata:t,options:r}=e.data.in,o=Gn(t,r);postMessage({type:"create_finalize",out:o})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{let{model:t,options:r}=e.data.in,o=pu(t,r);postMessage({type:"create",out:o})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{fu(e.data.in),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{let{sessionId:t,inputIndices:r,inputs:o,outputIndices:n,options:s}=e.data.in;mu(t,r,o,n,new Array(n.length).fill(null),s).then(u=>{u.some(d=>d[3]!=="cpu")?postMessage({type:"run",err:"Proxy does not support non-cpu tensor location."}):postMessage({type:"run",out:u},gu(u))},u=>{postMessage({type:"run",err:u})})}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{let t=e.data.in;hu(t),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}break;case"is-ort-env-initialized":try{let t=cu();postMessage({type:"is-ort-env-initialized",out:t})}catch(t){postMessage({type:"is-ort-env-initialized",err:t})}break;default:}};})();\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n'});var vt,Ye,$n,Ia,Ca,ha,ga,ya,ba,wa,va,$a,Sa,xa,Ot,Bp,vn,ml,hl,gl,yl,_a,bl,wl,vl,$l,Aa=F(()=>{"use strict";_t();pl();Yt();vt=()=>!!_e.wasm.proxy&&typeof document<"u",$n=!1,Ia=!1,Ca=!1,ya=[],ba=[],wa=[],va=[],$a=[],Sa=[],xa=[],Ot=()=>{if($n||!Ia||Ca||!Ye)throw new Error("worker not ready")},Bp=e=>{switch(e.data.type){case"init-wasm":$n=!1,e.data.err?(Ca=!0,ha[1](e.data.err)):(Ia=!0,ha[0]());break;case"init-ort":e.data.err?ga[1](e.data.err):ga[0]();break;case"create_allocate":e.data.err?ya.shift()[1](e.data.err):ya.shift()[0](e.data.out);break;case"create_finalize":e.data.err?ba.shift()[1](e.data.err):ba.shift()[0](e.data.out);break;case"create":e.data.err?wa.shift()[1](e.data.err):wa.shift()[0](e.data.out);break;case"release":e.data.err?va.shift()[1](e.data.err):va.shift()[0]();break;case"run":e.data.err?$a.shift()[1](e.data.err):$a.shift()[0](e.data.out);break;case"end-profiling":e.data.err?Sa.shift()[1](e.data.err):Sa.shift()[0]();break;case"is-ort-env-initialized":e.data.err?xa.shift()[1](e.data.err):xa.shift()[0](e.data.out);break;default:}},vn=typeof document<"u"?document?.currentScript?.src:void 0,ml=async()=>{if(vt()){if(Ia)return;if($n)throw new Error("multiple calls to 'initWasm()' detected.");if(Ca)throw new Error("previous call to 'initWasm()' failed.");return $n=!0,_e.wasm.wasmPaths===void 0&&vn&&vn.indexOf("blob:")!==0&&(_e.wasm.wasmPaths=vn.substr(0,+vn.lastIndexOf("/")+1)),new Promise((e,t)=>{Ye?.terminate();let r=URL.createObjectURL(new Blob([fl()],{type:"text/javascript"}));Ye=new Worker(r,{name:"ort-wasm-proxy-worker"}),Ye.onerror=n=>t(n),Ye.onmessage=Bp,URL.revokeObjectURL(r),ha=[e,t];let a={type:"init-wasm",in:_e.wasm};Ye.postMessage(a)})}else return Mo(_e.wasm)},hl=async e=>{if(vt())return Ot(),new Promise((t,r)=>{ga=[t,r];let a={type:"init-ort",in:e};Ye.postMessage(a)});await ol(e)},gl=async e=>vt()?(Ot(),new Promise((t,r)=>{ya.push([t,r]);let a={type:"create_allocate",in:{model:e}};Ye.postMessage(a,[e.buffer])})):fa(e),yl=async(e,t)=>vt()?(Ot(),new Promise((r,a)=>{ba.push([r,a]);let n={type:"create_finalize",in:{modeldata:e,options:t}};Ye.postMessage(n)})):ma(e,t),_a=async(e,t)=>{if(vt()){if(t?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Ot(),new Promise((r,a)=>{wa.push([r,a]);let n={type:"create",in:{model:e,options:t}};Ye.postMessage(n,[e.buffer])})}else return sl(e,t)},bl=async e=>{if(vt())return Ot(),new Promise((t,r)=>{va.push([t,r]);let a={type:"release",in:e};Ye.postMessage(a)});ul(e)},wl=async(e,t,r,a,n,s)=>{if(vt()){if(r.some(u=>u[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(n.some(u=>u))throw new Error("pre-allocated output tensor is not supported for proxy.");return Ot(),new Promise((u,l)=>{$a.push([u,l]);let o=r,p={type:"run",in:{sessionId:e,inputIndices:t,inputs:o,outputIndices:a,options:s}};Ye.postMessage(p,cl(o))})}else return ll(e,t,r,a,n,s)},vl=async e=>{if(vt())return Ot(),new Promise((t,r)=>{Sa.push([t,r]);let a={type:"end-profiling",in:e};Ye.postMessage(a)});dl(e)},$l=async()=>vt()?(Ot(),new Promise((e,t)=>{xa.push([e,t]);let r={type:"is-ort-env-initialized"};Ye.postMessage(r)})):il()});var Sn,Sl,Mp,xn,xl=F(()=>{"use strict";_t();Aa();De();Sl=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},Mp=e=>{switch(e[3]){case"cpu":return new Ue(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!Qr(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:r,download:a,dispose:n}=e[2];return Ue.fromGpuBuffer(r,{dataType:t,dims:e[1],download:a,dispose:n})}default:throw new Error(`invalid data location: ${e[3]}`)}},xn=class{async createSessionAllocate(t){let r=await fetch(t);if(r.status!==200)throw new Error(`failed to load model: ${t}`);let a=await r.arrayBuffer();return gl(new Uint8Array(a))}async loadModel(t,r){if(await $l()||(Sn||(Sn=hl(_e)),await Sn,Sn=void 0),typeof t=="string")if(typeof process<"u"&&process.versions&&process.versions.node){let a=await(void 0)(t);[this.sessionId,this.inputNames,this.outputNames]=await _a(a,r)}else{let a=await this.createSessionAllocate(t);[this.sessionId,this.inputNames,this.outputNames]=await yl(a,r)}else[this.sessionId,this.inputNames,this.outputNames]=await _a(t,r)}async dispose(){return bl(this.sessionId)}async run(t,r,a){let n=[],s=[];Object.entries(t).forEach(g=>{let b=g[0],v=g[1],$=this.inputNames.indexOf(b);if($===-1)throw new Error(`invalid input '${b}'`);n.push(v),s.push($)});let u=[],l=[];Object.entries(r).forEach(g=>{let b=g[0],v=g[1],$=this.outputNames.indexOf(b);if($===-1)throw new Error(`invalid output '${b}'`);u.push(v),l.push($)});let o=n.map((g,b)=>Sl(g,()=>`input "${this.inputNames[s[b]]}"`)),p=u.map((g,b)=>g?Sl(g,()=>`output "${this.outputNames[l[b]]}"`):null),f=await wl(this.sessionId,s,o,l,p,a),y={};for(let g=0;g<f.length;g++)y[this.outputNames[l[g]]]=u[g]??Mp(f[g]);return y}startProfiling(){}endProfiling(){vl(this.sessionId)}}});var Dp,In,Il=F(()=>{"use strict";_t();Aa();xl();Dp=()=>{if((typeof _e.wasm.initTimeout!="number"||_e.wasm.initTimeout<0)&&(_e.wasm.initTimeout=0),typeof _e.wasm.simd!="boolean"&&(_e.wasm.simd=!0),typeof _e.wasm.proxy!="boolean"&&(_e.wasm.proxy=!1),typeof _e.wasm.numThreads!="number"||!Number.isInteger(_e.wasm.numThreads)||_e.wasm.numThreads<=0){let e=typeof navigator>"u"?(void 0)().length:navigator.hardwareConcurrency;_e.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},In=class{async init(){Dp(),await ml()}async createInferenceSessionHandler(t,r){let a=new xn;return await a.loadModel(t,r),Promise.resolve(a)}}});var Cl={};zt(Cl,{wasmBackend:()=>zp});var zp,_l=F(()=>{"use strict";Il();zp=new In});var Vp={};zt(Vp,{InferenceSession:()=>ho,Tensor:()=>Ue,TrainingSession:()=>wo,default:()=>Wp,env:()=>_e,registerBackend:()=>wt});module.exports=Ct(Vp);_t();_t();_t();var $o="1.17.0";var Wp=Bn;{let e=(_l(),Ct(Cl)).wasmBackend;typeof navigator<"u"&&navigator.gpu&&wt("webgpu",e,5),wt("cpu",e,10),wt("wasm",e,10),wt("xnnpack",e,9),wt("webnn",e,9)}Object.defineProperty(_e.versions,"web",{value:$o,enumerable:!0});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
//# sourceMappingURL=ort.webgpu.min.js.map
