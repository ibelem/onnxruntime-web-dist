/*!
 * ONNX Runtime Web v1.19.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require2() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// web/node_modules/onnxruntime-common/dist/esm/backend-impl.js
var backends, backendsSortedByPriority, registerBackend, tryResolveAndInitializeBackend, resolveBackendAndExecutionProviders;
var init_backend_impl = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/backend-impl.js"() {
    backends = /* @__PURE__ */ new Map();
    backendsSortedByPriority = [];
    registerBackend = (name2, backend2, priority) => {
      if (backend2 && typeof backend2.init === "function" && typeof backend2.createInferenceSessionHandler === "function") {
        const currentBackend = backends.get(name2);
        if (currentBackend === void 0) {
          backends.set(name2, { backend: backend2, priority });
        } else if (currentBackend.priority > priority) {
          return;
        } else if (currentBackend.priority === priority) {
          if (currentBackend.backend !== backend2) {
            throw new Error(`cannot register backend "${name2}" using priority ${priority}`);
          }
        }
        if (priority >= 0) {
          const i = backendsSortedByPriority.indexOf(name2);
          if (i !== -1) {
            backendsSortedByPriority.splice(i, 1);
          }
          for (let i2 = 0; i2 < backendsSortedByPriority.length; i2++) {
            if (backends.get(backendsSortedByPriority[i2]).priority <= priority) {
              backendsSortedByPriority.splice(i2, 0, name2);
              return;
            }
          }
          backendsSortedByPriority.push(name2);
        }
        return;
      }
      throw new TypeError("not a valid backend");
    };
    tryResolveAndInitializeBackend = async (backendName) => {
      const backendInfo = backends.get(backendName);
      if (!backendInfo) {
        return "backend not found.";
      }
      if (backendInfo.initialized) {
        return backendInfo.backend;
      } else if (backendInfo.aborted) {
        return backendInfo.error;
      } else {
        const isInitializing = !!backendInfo.initPromise;
        try {
          if (!isInitializing) {
            backendInfo.initPromise = backendInfo.backend.init(backendName);
          }
          await backendInfo.initPromise;
          backendInfo.initialized = true;
          return backendInfo.backend;
        } catch (e) {
          if (!isInitializing) {
            backendInfo.error = `${e}`;
            backendInfo.aborted = true;
          }
          return backendInfo.error;
        } finally {
          delete backendInfo.initPromise;
        }
      }
    };
    resolveBackendAndExecutionProviders = async (options) => {
      const eps = options.executionProviders || [];
      const backendHints = eps.map((i) => typeof i === "string" ? i : i.name);
      const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;
      let backend2;
      const errors = [];
      const availableBackendNames = /* @__PURE__ */ new Set();
      for (const backendName of backendNames) {
        const resolveResult = await tryResolveAndInitializeBackend(backendName);
        if (typeof resolveResult === "string") {
          errors.push({ name: backendName, err: resolveResult });
        } else {
          if (!backend2) {
            backend2 = resolveResult;
          }
          if (backend2 === resolveResult) {
            availableBackendNames.add(backendName);
          }
        }
      }
      if (!backend2) {
        throw new Error(`no available backend found. ERR: ${errors.map((e) => `[${e.name}] ${e.err}`).join(", ")}`);
      }
      for (const { name: name2, err } of errors) {
        if (backendHints.includes(name2)) {
          console.warn(`removing requested execution provider "${name2}" from session options because it is not available: ${err}`);
        }
      }
      const filteredEps = eps.filter((i) => availableBackendNames.has(typeof i === "string" ? i : i.name));
      return [
        backend2,
        new Proxy(options, {
          get: (target, prop) => {
            if (prop === "executionProviders") {
              return filteredEps;
            }
            return Reflect.get(target, prop);
          }
        })
      ];
    };
  }
});

// web/node_modules/onnxruntime-common/dist/esm/backend.js
var init_backend = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/backend.js"() {
    init_backend_impl();
  }
});

// web/node_modules/onnxruntime-common/dist/esm/version.js
var version;
var init_version = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/version.js"() {
    version = "1.19.0";
  }
});

// web/node_modules/onnxruntime-common/dist/esm/env-impl.js
var logLevelValue, env;
var init_env_impl = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/env-impl.js"() {
    init_version();
    logLevelValue = "warning";
    env = {
      wasm: {},
      webgl: {},
      webgpu: {},
      versions: { common: version },
      set logLevel(value) {
        if (value === void 0) {
          return;
        }
        if (typeof value !== "string" || ["verbose", "info", "warning", "error", "fatal"].indexOf(value) === -1) {
          throw new Error(`Unsupported logging level: ${value}`);
        }
        logLevelValue = value;
      },
      get logLevel() {
        return logLevelValue;
      }
    };
    Object.defineProperty(env, "logLevel", { enumerable: true });
  }
});

// web/node_modules/onnxruntime-common/dist/esm/env.js
var env2;
var init_env = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/env.js"() {
    init_env_impl();
    env2 = env;
  }
});

// web/node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js
var tensorToDataURL, tensorToImageData;
var init_tensor_conversion_impl = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js"() {
    tensorToDataURL = (tensor, options) => {
      const canvas = typeof document !== "undefined" ? document.createElement("canvas") : new OffscreenCanvas(1, 1);
      canvas.width = tensor.dims[3];
      canvas.height = tensor.dims[2];
      const pixels2DContext = canvas.getContext("2d");
      if (pixels2DContext != null) {
        let width;
        let height;
        if (options?.tensorLayout !== void 0 && options.tensorLayout === "NHWC") {
          width = tensor.dims[2];
          height = tensor.dims[3];
        } else {
          width = tensor.dims[3];
          height = tensor.dims[2];
        }
        const inputformat = options?.format !== void 0 ? options.format : "RGB";
        const norm = options?.norm;
        let normMean;
        let normBias;
        if (norm === void 0 || norm.mean === void 0) {
          normMean = [255, 255, 255, 255];
        } else {
          if (typeof norm.mean === "number") {
            normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
          } else {
            normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 0];
            if (norm.mean[3] !== void 0) {
              normMean[3] = norm.mean[3];
            }
          }
        }
        if (norm === void 0 || norm.bias === void 0) {
          normBias = [0, 0, 0, 0];
        } else {
          if (typeof norm.bias === "number") {
            normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
          } else {
            normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
            if (norm.bias[3] !== void 0) {
              normBias[3] = norm.bias[3];
            }
          }
        }
        const stride = height * width;
        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
        if (inputformat === "RGBA") {
          rTensorPointer = 0;
          gTensorPointer = stride;
          bTensorPointer = stride * 2;
          aTensorPointer = stride * 3;
        } else if (inputformat === "RGB") {
          rTensorPointer = 0;
          gTensorPointer = stride;
          bTensorPointer = stride * 2;
        } else if (inputformat === "RBG") {
          rTensorPointer = 0;
          bTensorPointer = stride;
          gTensorPointer = stride * 2;
        }
        for (let i = 0; i < height; i++) {
          for (let j = 0; j < width; j++) {
            const R = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
            const G = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
            const B = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
            const A = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
            pixels2DContext.fillStyle = "rgba(" + R + "," + G + "," + B + "," + A + ")";
            pixels2DContext.fillRect(j, i, 1, 1);
          }
        }
        if ("toDataURL" in canvas) {
          return canvas.toDataURL();
        } else {
          throw new Error("toDataURL is not supported");
        }
      } else {
        throw new Error("Can not access image data");
      }
    };
    tensorToImageData = (tensor, options) => {
      const pixels2DContext = typeof document !== "undefined" ? document.createElement("canvas").getContext("2d") : new OffscreenCanvas(1, 1).getContext("2d");
      let image;
      if (pixels2DContext != null) {
        let width;
        let height;
        let channels;
        if (options?.tensorLayout !== void 0 && options.tensorLayout === "NHWC") {
          width = tensor.dims[2];
          height = tensor.dims[1];
          channels = tensor.dims[3];
        } else {
          width = tensor.dims[3];
          height = tensor.dims[2];
          channels = tensor.dims[1];
        }
        const inputformat = options !== void 0 ? options.format !== void 0 ? options.format : "RGB" : "RGB";
        const norm = options?.norm;
        let normMean;
        let normBias;
        if (norm === void 0 || norm.mean === void 0) {
          normMean = [255, 255, 255, 255];
        } else {
          if (typeof norm.mean === "number") {
            normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
          } else {
            normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 255];
            if (norm.mean[3] !== void 0) {
              normMean[3] = norm.mean[3];
            }
          }
        }
        if (norm === void 0 || norm.bias === void 0) {
          normBias = [0, 0, 0, 0];
        } else {
          if (typeof norm.bias === "number") {
            normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
          } else {
            normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
            if (norm.bias[3] !== void 0) {
              normBias[3] = norm.bias[3];
            }
          }
        }
        const stride = height * width;
        if (options !== void 0) {
          if (options.format !== void 0 && (channels === 4 && options.format !== "RGBA") || channels === 3 && (options.format !== "RGB" && options.format !== "BGR")) {
            throw new Error("Tensor format doesn't match input tensor dims");
          }
        }
        const step = 4;
        let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
        if (inputformat === "RGBA") {
          rTensorPointer = 0;
          gTensorPointer = stride;
          bTensorPointer = stride * 2;
          aTensorPointer = stride * 3;
        } else if (inputformat === "RGB") {
          rTensorPointer = 0;
          gTensorPointer = stride;
          bTensorPointer = stride * 2;
        } else if (inputformat === "RBG") {
          rTensorPointer = 0;
          bTensorPointer = stride;
          gTensorPointer = stride * 2;
        }
        image = pixels2DContext.createImageData(width, height);
        for (let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++) {
          image.data[rImagePointer] = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
          image.data[gImagePointer] = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
          image.data[bImagePointer] = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
          image.data[aImagePointer] = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
        }
      } else {
        throw new Error("Can not access image data");
      }
      return image;
    };
  }
});

// web/node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js
var bufferToTensor, tensorFromImage, tensorFromTexture, tensorFromGpuBuffer, tensorFromPinnedBuffer;
var init_tensor_factory_impl = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js"() {
    init_tensor_impl();
    bufferToTensor = (buffer, options) => {
      if (buffer === void 0) {
        throw new Error("Image buffer must be defined");
      }
      if (options.height === void 0 || options.width === void 0) {
        throw new Error("Image height and width must be defined");
      }
      if (options.tensorLayout === "NHWC") {
        throw new Error("NHWC Tensor layout is not supported yet");
      }
      const { height, width } = options;
      const norm = options.norm ?? { mean: 255, bias: 0 };
      let normMean;
      let normBias;
      if (typeof norm.mean === "number") {
        normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
      } else {
        normMean = [norm.mean[0], norm.mean[1], norm.mean[2], norm.mean[3] ?? 255];
      }
      if (typeof norm.bias === "number") {
        normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
      } else {
        normBias = [norm.bias[0], norm.bias[1], norm.bias[2], norm.bias[3] ?? 0];
      }
      const inputformat = options.format !== void 0 ? options.format : "RGBA";
      const outputformat = options.tensorFormat !== void 0 ? options.tensorFormat !== void 0 ? options.tensorFormat : "RGB" : "RGB";
      const stride = height * width;
      const float32Data = outputformat === "RGBA" ? new Float32Array(stride * 4) : new Float32Array(stride * 3);
      let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
      let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
      if (inputformat === "RGB") {
        step = 3;
        rImagePointer = 0;
        gImagePointer = 1;
        bImagePointer = 2;
        aImagePointer = -1;
      }
      if (outputformat === "RGBA") {
        aTensorPointer = stride * 3;
      } else if (outputformat === "RBG") {
        rTensorPointer = 0;
        bTensorPointer = stride;
        gTensorPointer = stride * 2;
      } else if (outputformat === "BGR") {
        bTensorPointer = 0;
        gTensorPointer = stride;
        rTensorPointer = stride * 2;
      }
      for (let i = 0; i < stride; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step) {
        float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias[0]) / normMean[0];
        float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias[1]) / normMean[1];
        float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias[2]) / normMean[2];
        if (aTensorPointer !== -1 && aImagePointer !== -1) {
          float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias[3]) / normMean[3];
        }
      }
      const outputTensor = outputformat === "RGBA" ? new Tensor("float32", float32Data, [1, 4, height, width]) : new Tensor("float32", float32Data, [1, 3, height, width]);
      return outputTensor;
    };
    tensorFromImage = async (image, options) => {
      const isHTMLImageEle = typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement;
      const isImageDataEle = typeof ImageData !== "undefined" && image instanceof ImageData;
      const isImageBitmap = typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap;
      const isString = typeof image === "string";
      let data;
      let bufferToTensorOptions = options ?? {};
      const createCanvas2 = () => {
        if (typeof document !== "undefined") {
          return document.createElement("canvas");
        } else if (typeof OffscreenCanvas !== "undefined") {
          return new OffscreenCanvas(1, 1);
        } else {
          throw new Error("Canvas is not supported");
        }
      };
      const createCanvasContext = (canvas) => {
        if (canvas instanceof HTMLCanvasElement) {
          return canvas.getContext("2d");
        } else if (canvas instanceof OffscreenCanvas) {
          return canvas.getContext("2d");
        } else {
          return null;
        }
      };
      if (isHTMLImageEle) {
        const canvas = createCanvas2();
        canvas.width = image.width;
        canvas.height = image.height;
        const pixels2DContext = createCanvasContext(canvas);
        if (pixels2DContext != null) {
          let height = image.height;
          let width = image.width;
          if (options !== void 0 && options.resizedHeight !== void 0 && options.resizedWidth !== void 0) {
            height = options.resizedHeight;
            width = options.resizedWidth;
          }
          if (options !== void 0) {
            bufferToTensorOptions = options;
            if (options.tensorFormat !== void 0) {
              throw new Error("Image input config format must be RGBA for HTMLImageElement");
            } else {
              bufferToTensorOptions.tensorFormat = "RGBA";
            }
            bufferToTensorOptions.height = height;
            bufferToTensorOptions.width = width;
          } else {
            bufferToTensorOptions.tensorFormat = "RGBA";
            bufferToTensorOptions.height = height;
            bufferToTensorOptions.width = width;
          }
          pixels2DContext.drawImage(image, 0, 0);
          data = pixels2DContext.getImageData(0, 0, width, height).data;
        } else {
          throw new Error("Can not access image data");
        }
      } else if (isImageDataEle) {
        let height;
        let width;
        if (options !== void 0 && options.resizedWidth !== void 0 && options.resizedHeight !== void 0) {
          height = options.resizedHeight;
          width = options.resizedWidth;
        } else {
          height = image.height;
          width = image.width;
        }
        if (options !== void 0) {
          bufferToTensorOptions = options;
        }
        bufferToTensorOptions.format = "RGBA";
        bufferToTensorOptions.height = height;
        bufferToTensorOptions.width = width;
        if (options !== void 0) {
          const tempCanvas = createCanvas2();
          tempCanvas.width = width;
          tempCanvas.height = height;
          const pixels2DContext = createCanvasContext(tempCanvas);
          if (pixels2DContext != null) {
            pixels2DContext.putImageData(image, 0, 0);
            data = pixels2DContext.getImageData(0, 0, width, height).data;
          } else {
            throw new Error("Can not access image data");
          }
        } else {
          data = image.data;
        }
      } else if (isImageBitmap) {
        if (options === void 0) {
          throw new Error("Please provide image config with format for Imagebitmap");
        }
        const canvas = createCanvas2();
        canvas.width = image.width;
        canvas.height = image.height;
        const pixels2DContext = createCanvasContext(canvas);
        if (pixels2DContext != null) {
          const height = image.height;
          const width = image.width;
          pixels2DContext.drawImage(image, 0, 0, width, height);
          data = pixels2DContext.getImageData(0, 0, width, height).data;
          bufferToTensorOptions.height = height;
          bufferToTensorOptions.width = width;
          return bufferToTensor(data, bufferToTensorOptions);
        } else {
          throw new Error("Can not access image data");
        }
      } else if (isString) {
        return new Promise((resolve, reject) => {
          const canvas = createCanvas2();
          const context = createCanvasContext(canvas);
          if (!image || !context) {
            return reject();
          }
          const newImage = new Image();
          newImage.crossOrigin = "Anonymous";
          newImage.src = image;
          newImage.onload = () => {
            canvas.width = newImage.width;
            canvas.height = newImage.height;
            context.drawImage(newImage, 0, 0, canvas.width, canvas.height);
            const img = context.getImageData(0, 0, canvas.width, canvas.height);
            bufferToTensorOptions.height = canvas.height;
            bufferToTensorOptions.width = canvas.width;
            resolve(bufferToTensor(img.data, bufferToTensorOptions));
          };
        });
      } else {
        throw new Error("Input data provided is not supported - aborted tensor creation");
      }
      if (data !== void 0) {
        return bufferToTensor(data, bufferToTensorOptions);
      } else {
        throw new Error("Input data provided is not supported - aborted tensor creation");
      }
    };
    tensorFromTexture = (texture, options) => {
      const { width, height, download, dispose } = options;
      const dims = [1, height, width, 4];
      return new Tensor({ location: "texture", type: "float32", texture, dims, download, dispose });
    };
    tensorFromGpuBuffer = (gpuBuffer, options) => {
      const { dataType, dims, download, dispose } = options;
      return new Tensor({ location: "gpu-buffer", type: dataType ?? "float32", gpuBuffer, dims, download, dispose });
    };
    tensorFromPinnedBuffer = (type, buffer, dims) => new Tensor({ location: "cpu-pinned", type, data: buffer, dims: dims ?? [buffer.length] });
  }
});

// web/node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js
var NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP, NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP, isTypedArrayChecked, checkTypedArray;
var init_tensor_impl_type_mapping = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js"() {
    NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = /* @__PURE__ */ new Map([
      ["float32", Float32Array],
      ["uint8", Uint8Array],
      ["int8", Int8Array],
      ["uint16", Uint16Array],
      ["int16", Int16Array],
      ["int32", Int32Array],
      ["bool", Uint8Array],
      ["float64", Float64Array],
      ["uint32", Uint32Array]
    ]);
    NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = /* @__PURE__ */ new Map([
      [Float32Array, "float32"],
      [Uint8Array, "uint8"],
      [Int8Array, "int8"],
      [Uint16Array, "uint16"],
      [Int16Array, "int16"],
      [Int32Array, "int32"],
      [Float64Array, "float64"],
      [Uint32Array, "uint32"]
    ]);
    isTypedArrayChecked = false;
    checkTypedArray = () => {
      if (!isTypedArrayChecked) {
        isTypedArrayChecked = true;
        const isBigInt64ArrayAvailable = typeof BigInt64Array !== "undefined" && BigInt64Array.from;
        const isBigUint64ArrayAvailable = typeof BigUint64Array !== "undefined" && BigUint64Array.from;
        const isFloat16ArrayAvailable = typeof Float16Array !== "undefined" && Float16Array.from;
        if (isBigInt64ArrayAvailable) {
          NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64", BigInt64Array);
          NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, "int64");
        }
        if (isBigUint64ArrayAvailable) {
          NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64", BigUint64Array);
          NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, "uint64");
        }
        if (isFloat16ArrayAvailable) {
          NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Float16Array);
          NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(Float16Array, "float16");
        } else {
          NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Uint16Array);
        }
      }
    };
  }
});

// web/node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js
var calculateSize, tensorReshape;
var init_tensor_utils_impl = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js"() {
    init_tensor_impl();
    calculateSize = (dims) => {
      let size = 1;
      for (let i = 0; i < dims.length; i++) {
        const dim = dims[i];
        if (typeof dim !== "number" || !Number.isSafeInteger(dim)) {
          throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);
        }
        if (dim < 0) {
          throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);
        }
        size *= dim;
      }
      return size;
    };
    tensorReshape = (tensor, dims) => {
      switch (tensor.location) {
        case "cpu":
          return new Tensor(tensor.type, tensor.data, dims);
        case "cpu-pinned":
          return new Tensor({
            location: "cpu-pinned",
            data: tensor.data,
            type: tensor.type,
            dims
          });
        case "texture":
          return new Tensor({
            location: "texture",
            texture: tensor.texture,
            type: tensor.type,
            dims
          });
        case "gpu-buffer":
          return new Tensor({
            location: "gpu-buffer",
            gpuBuffer: tensor.gpuBuffer,
            type: tensor.type,
            dims
          });
        default:
          throw new Error(`tensorReshape: tensor location ${tensor.location} is not supported`);
      }
    };
  }
});

// web/node_modules/onnxruntime-common/dist/esm/tensor-impl.js
var Tensor;
var init_tensor_impl = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/tensor-impl.js"() {
    init_tensor_conversion_impl();
    init_tensor_factory_impl();
    init_tensor_impl_type_mapping();
    init_tensor_utils_impl();
    Tensor = class {
      /**
       * implementation.
       */
      constructor(arg0, arg1, arg2) {
        checkTypedArray();
        let type;
        let dims;
        if (typeof arg0 === "object" && "location" in arg0) {
          this.dataLocation = arg0.location;
          type = arg0.type;
          dims = arg0.dims;
          switch (arg0.location) {
            case "cpu-pinned": {
              const expectedTypedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(type);
              if (!expectedTypedArrayConstructor) {
                throw new TypeError(`unsupported type "${type}" to create tensor from pinned buffer`);
              }
              if (!(arg0.data instanceof expectedTypedArrayConstructor)) {
                throw new TypeError(`buffer should be of type ${expectedTypedArrayConstructor.name}`);
              }
              this.cpuData = arg0.data;
              break;
            }
            case "texture": {
              if (type !== "float32") {
                throw new TypeError(`unsupported type "${type}" to create tensor from texture`);
              }
              this.gpuTextureData = arg0.texture;
              this.downloader = arg0.download;
              this.disposer = arg0.dispose;
              break;
            }
            case "gpu-buffer": {
              if (type !== "float32" && type !== "float16" && type !== "int32" && type !== "int64" && type !== "uint32" && type !== "uint8" && type !== "bool") {
                throw new TypeError(`unsupported type "${type}" to create tensor from gpu buffer`);
              }
              this.gpuBufferData = arg0.gpuBuffer;
              this.downloader = arg0.download;
              this.disposer = arg0.dispose;
              break;
            }
            default:
              throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`);
          }
        } else {
          let data;
          let maybeDims;
          if (typeof arg0 === "string") {
            type = arg0;
            maybeDims = arg2;
            if (arg0 === "string") {
              if (!Array.isArray(arg1)) {
                throw new TypeError("A string tensor's data must be a string array.");
              }
              data = arg1;
            } else {
              const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);
              if (typedArrayConstructor === void 0) {
                throw new TypeError(`Unsupported tensor type: ${arg0}.`);
              }
              if (Array.isArray(arg1)) {
                if (arg0 === "float16" && typedArrayConstructor === Uint16Array) {
                  throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");
                } else if (arg0 === "uint64" || arg0 === "int64") {
                  data = typedArrayConstructor.from(arg1, BigInt);
                } else {
                  data = typedArrayConstructor.from(arg1);
                }
              } else if (arg1 instanceof typedArrayConstructor) {
                data = arg1;
              } else {
                throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);
              }
            }
          } else {
            maybeDims = arg1;
            if (Array.isArray(arg0)) {
              if (arg0.length === 0) {
                throw new TypeError("Tensor type cannot be inferred from an empty array.");
              }
              const firstElementType = typeof arg0[0];
              if (firstElementType === "string") {
                type = "string";
                data = arg0;
              } else if (firstElementType === "boolean") {
                type = "bool";
                data = Uint8Array.from(arg0);
              } else {
                throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);
              }
            } else {
              const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);
              if (mappedType === void 0) {
                throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);
              }
              type = mappedType;
              data = arg0;
            }
          }
          if (maybeDims === void 0) {
            maybeDims = [data.length];
          } else if (!Array.isArray(maybeDims)) {
            throw new TypeError("A tensor's dims must be a number array");
          }
          dims = maybeDims;
          this.cpuData = data;
          this.dataLocation = "cpu";
        }
        const size = calculateSize(dims);
        if (this.cpuData && size !== this.cpuData.length) {
          throw new Error(`Tensor's size(${size}) does not match data length(${this.cpuData.length}).`);
        }
        this.type = type;
        this.dims = dims;
        this.size = size;
      }
      // #endregion
      // #region factory
      static async fromImage(image, options) {
        return tensorFromImage(image, options);
      }
      static fromTexture(texture, options) {
        return tensorFromTexture(texture, options);
      }
      static fromGpuBuffer(gpuBuffer, options) {
        return tensorFromGpuBuffer(gpuBuffer, options);
      }
      static fromPinnedBuffer(type, buffer, dims) {
        return tensorFromPinnedBuffer(type, buffer, dims);
      }
      // #endregion
      // #region conversions
      toDataURL(options) {
        return tensorToDataURL(this, options);
      }
      toImageData(options) {
        return tensorToImageData(this, options);
      }
      // #endregion
      // #region properties
      get data() {
        this.ensureValid();
        if (!this.cpuData) {
          throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");
        }
        return this.cpuData;
      }
      get location() {
        return this.dataLocation;
      }
      get texture() {
        this.ensureValid();
        if (!this.gpuTextureData) {
          throw new Error("The data is not stored as a WebGL texture.");
        }
        return this.gpuTextureData;
      }
      get gpuBuffer() {
        this.ensureValid();
        if (!this.gpuBufferData) {
          throw new Error("The data is not stored as a WebGPU buffer.");
        }
        return this.gpuBufferData;
      }
      // #endregion
      // #region methods
      async getData(releaseData) {
        this.ensureValid();
        switch (this.dataLocation) {
          case "cpu":
          case "cpu-pinned":
            return this.data;
          case "texture":
          case "gpu-buffer": {
            if (!this.downloader) {
              throw new Error("The current tensor is not created with a specified data downloader.");
            }
            if (this.isDownloading) {
              throw new Error("The current tensor is being downloaded.");
            }
            try {
              this.isDownloading = true;
              const data = await this.downloader();
              this.downloader = void 0;
              this.dataLocation = "cpu";
              this.cpuData = data;
              if (releaseData && this.disposer) {
                this.disposer();
                this.disposer = void 0;
              }
              return data;
            } finally {
              this.isDownloading = false;
            }
          }
          default:
            throw new Error(`cannot get data from location: ${this.dataLocation}`);
        }
      }
      dispose() {
        if (this.isDownloading) {
          throw new Error("The current tensor is being downloaded.");
        }
        if (this.disposer) {
          this.disposer();
          this.disposer = void 0;
        }
        this.cpuData = void 0;
        this.gpuTextureData = void 0;
        this.gpuBufferData = void 0;
        this.downloader = void 0;
        this.isDownloading = void 0;
        this.dataLocation = "none";
      }
      // #endregion
      // #region tensor utilities
      ensureValid() {
        if (this.dataLocation === "none") {
          throw new Error("The tensor is disposed.");
        }
      }
      reshape(dims) {
        this.ensureValid();
        if (this.downloader || this.disposer) {
          throw new Error("Cannot reshape a tensor that owns GPU resource.");
        }
        return tensorReshape(this, dims);
      }
    };
  }
});

// web/node_modules/onnxruntime-common/dist/esm/tensor.js
var Tensor2;
var init_tensor = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/tensor.js"() {
    init_tensor_impl();
    Tensor2 = Tensor;
  }
});

// web/node_modules/onnxruntime-common/dist/esm/trace.js
var TRACE, TRACE_FUNC, TRACE_FUNC_BEGIN, TRACE_FUNC_END;
var init_trace = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/trace.js"() {
    init_env_impl();
    TRACE = (deviceType, label) => {
      if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
        return;
      }
      console.timeStamp(`${deviceType}::ORT::${label}`);
    };
    TRACE_FUNC = (msg, extraMsg) => {
      const stack = new Error().stack?.split(/\r\n|\r|\n/g) || [];
      let hasTraceFunc = false;
      for (let i = 0; i < stack.length; i++) {
        if (hasTraceFunc && !stack[i].includes("TRACE_FUNC")) {
          let label = `FUNC_${msg}::${stack[i].trim().split(" ")[1]}`;
          if (extraMsg) {
            label += `::${extraMsg}`;
          }
          TRACE("CPU", label);
          return;
        }
        if (stack[i].includes("TRACE_FUNC")) {
          hasTraceFunc = true;
        }
      }
    };
    TRACE_FUNC_BEGIN = (extraMsg) => {
      if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
        return;
      }
      TRACE_FUNC("BEGIN", extraMsg);
    };
    TRACE_FUNC_END = (extraMsg) => {
      if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
        return;
      }
      TRACE_FUNC("END", extraMsg);
    };
  }
});

// web/node_modules/onnxruntime-common/dist/esm/inference-session-impl.js
var InferenceSession;
var init_inference_session_impl = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/inference-session-impl.js"() {
    init_backend_impl();
    init_tensor();
    init_trace();
    InferenceSession = class _InferenceSession {
      constructor(handler) {
        this.handler = handler;
      }
      async run(feeds, arg1, arg2) {
        TRACE_FUNC_BEGIN();
        const fetches = {};
        let options = {};
        if (typeof feeds !== "object" || feeds === null || feeds instanceof Tensor2 || Array.isArray(feeds)) {
          throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
        }
        let isFetchesEmpty = true;
        if (typeof arg1 === "object") {
          if (arg1 === null) {
            throw new TypeError("Unexpected argument[1]: cannot be null.");
          }
          if (arg1 instanceof Tensor2) {
            throw new TypeError("'fetches' cannot be a Tensor");
          }
          if (Array.isArray(arg1)) {
            if (arg1.length === 0) {
              throw new TypeError("'fetches' cannot be an empty array.");
            }
            isFetchesEmpty = false;
            for (const name2 of arg1) {
              if (typeof name2 !== "string") {
                throw new TypeError("'fetches' must be a string array or an object.");
              }
              if (this.outputNames.indexOf(name2) === -1) {
                throw new RangeError(`'fetches' contains invalid output name: ${name2}.`);
              }
              fetches[name2] = null;
            }
            if (typeof arg2 === "object" && arg2 !== null) {
              options = arg2;
            } else if (typeof arg2 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
          } else {
            let isFetches = false;
            const arg1Keys = Object.getOwnPropertyNames(arg1);
            for (const name2 of this.outputNames) {
              if (arg1Keys.indexOf(name2) !== -1) {
                const v = arg1[name2];
                if (v === null || v instanceof Tensor2) {
                  isFetches = true;
                  isFetchesEmpty = false;
                  fetches[name2] = v;
                }
              }
            }
            if (isFetches) {
              if (typeof arg2 === "object" && arg2 !== null) {
                options = arg2;
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else {
              options = arg1;
            }
          }
        } else if (typeof arg1 !== "undefined") {
          throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
        }
        for (const name2 of this.inputNames) {
          if (typeof feeds[name2] === "undefined") {
            throw new Error(`input '${name2}' is missing in 'feeds'.`);
          }
        }
        if (isFetchesEmpty) {
          for (const name2 of this.outputNames) {
            fetches[name2] = null;
          }
        }
        const results = await this.handler.run(feeds, fetches, options);
        const returnValue = {};
        for (const key in results) {
          if (Object.hasOwnProperty.call(results, key)) {
            const result = results[key];
            if (result instanceof Tensor2) {
              returnValue[key] = result;
            } else {
              returnValue[key] = new Tensor2(result.type, result.data, result.dims);
            }
          }
        }
        TRACE_FUNC_END();
        return returnValue;
      }
      async release() {
        return this.handler.dispose();
      }
      static async create(arg0, arg1, arg2, arg3) {
        TRACE_FUNC_BEGIN();
        let filePathOrUint8Array;
        let options = {};
        if (typeof arg0 === "string") {
          filePathOrUint8Array = arg0;
          if (typeof arg1 === "object" && arg1 !== null) {
            options = arg1;
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
        } else if (arg0 instanceof Uint8Array) {
          filePathOrUint8Array = arg0;
          if (typeof arg1 === "object" && arg1 !== null) {
            options = arg1;
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
        } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && arg0 instanceof SharedArrayBuffer) {
          const buffer = arg0;
          let byteOffset = 0;
          let byteLength = arg0.byteLength;
          if (typeof arg1 === "object" && arg1 !== null) {
            options = arg1;
          } else if (typeof arg1 === "number") {
            byteOffset = arg1;
            if (!Number.isSafeInteger(byteOffset)) {
              throw new RangeError("'byteOffset' must be an integer.");
            }
            if (byteOffset < 0 || byteOffset >= buffer.byteLength) {
              throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);
            }
            byteLength = arg0.byteLength - byteOffset;
            if (typeof arg2 === "number") {
              byteLength = arg2;
              if (!Number.isSafeInteger(byteLength)) {
                throw new RangeError("'byteLength' must be an integer.");
              }
              if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {
                throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);
              }
              if (typeof arg3 === "object" && arg3 !== null) {
                options = arg3;
              } else if (typeof arg3 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else if (typeof arg2 !== "undefined") {
              throw new TypeError("'byteLength' must be a number.");
            }
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
          filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);
        } else {
          throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
        }
        const [backend2, optionsWithValidatedEPs] = await resolveBackendAndExecutionProviders(options);
        const handler = await backend2.createInferenceSessionHandler(filePathOrUint8Array, optionsWithValidatedEPs);
        TRACE_FUNC_END();
        return new _InferenceSession(handler);
      }
      startProfiling() {
        this.handler.startProfiling();
      }
      endProfiling() {
        this.handler.endProfiling();
      }
      get inputNames() {
        return this.handler.inputNames;
      }
      get outputNames() {
        return this.handler.outputNames;
      }
    };
  }
});

// web/node_modules/onnxruntime-common/dist/esm/inference-session.js
var InferenceSession2;
var init_inference_session = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/inference-session.js"() {
    init_inference_session_impl();
    InferenceSession2 = InferenceSession;
  }
});

// web/node_modules/onnxruntime-common/dist/esm/tensor-conversion.js
var init_tensor_conversion = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/tensor-conversion.js"() {
  }
});

// web/node_modules/onnxruntime-common/dist/esm/tensor-factory.js
var init_tensor_factory = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/tensor-factory.js"() {
  }
});

// web/node_modules/onnxruntime-common/dist/esm/onnx-model.js
var init_onnx_model = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/onnx-model.js"() {
  }
});

// web/node_modules/onnxruntime-common/dist/esm/onnx-value.js
var init_onnx_value = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/onnx-value.js"() {
  }
});

// web/node_modules/onnxruntime-common/dist/esm/training-session-impl.js
var noBackendErrMsg, TrainingSession;
var init_training_session_impl = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/training-session-impl.js"() {
    init_backend_impl();
    init_tensor();
    noBackendErrMsg = "Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.";
    TrainingSession = class _TrainingSession {
      constructor(handler, hasOptimizerModel, hasEvalModel) {
        this.handler = handler;
        this.hasOptimizerModel = hasOptimizerModel;
        this.hasEvalModel = hasEvalModel;
      }
      get trainingInputNames() {
        return this.handler.inputNames;
      }
      get trainingOutputNames() {
        return this.handler.outputNames;
      }
      get evalInputNames() {
        if (this.hasEvalModel) {
          return this.handler.evalInputNames;
        } else {
          throw new Error("This training session has no evalModel loaded.");
        }
      }
      get evalOutputNames() {
        if (this.hasEvalModel) {
          return this.handler.evalOutputNames;
        } else {
          throw new Error("This training session has no evalModel loaded.");
        }
      }
      static async create(trainingOptions, sessionOptions) {
        const evalModel = trainingOptions.evalModel || "";
        const optimizerModel = trainingOptions.optimizerModel || "";
        const options = sessionOptions || {};
        const [backend2, optionsWithValidatedEPs] = await resolveBackendAndExecutionProviders(options);
        if (backend2.createTrainingSessionHandler) {
          const handler = await backend2.createTrainingSessionHandler(trainingOptions.checkpointState, trainingOptions.trainModel, evalModel, optimizerModel, optionsWithValidatedEPs);
          return new _TrainingSession(handler, !!trainingOptions.optimizerModel, !!trainingOptions.evalModel);
        } else {
          throw new Error(noBackendErrMsg);
        }
      }
      /**
       * Helper function for runTrainStep and future runStep methods that handles the type-narrowing conversion from
       * the given parameters to SessionHandler.FetchesType and RunOptions.
       *
       * @param inputNames the feeds object is checked that they contain all input names in the provided list of input
       * names.
       * @param outputNames the fetches object is checked that their keys match up with valid names in the list of output
       * names.
       * @param feeds the required input
       * @param arg1 narrowed & converted into the SessionHandler.FetchesType or RunOptions object
       * @param arg2 optional RunOptions object.
       * @returns
       */
      typeNarrowingForRunStep(inputNames, outputNames, feeds, arg1, arg2) {
        const fetches = {};
        let options = {};
        if (typeof feeds !== "object" || feeds === null || feeds instanceof Tensor2 || Array.isArray(feeds)) {
          throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
        }
        let isFetchesEmpty = true;
        if (typeof arg1 === "object") {
          if (arg1 === null) {
            throw new TypeError("Unexpected argument[1]: cannot be null.");
          }
          if (arg1 instanceof Tensor2) {
            throw new TypeError("'fetches' cannot be a Tensor");
          }
          if (Array.isArray(arg1)) {
            if (arg1.length === 0) {
              throw new TypeError("'fetches' cannot be an empty array.");
            }
            isFetchesEmpty = false;
            for (const name2 of arg1) {
              if (typeof name2 !== "string") {
                throw new TypeError("'fetches' must be a string array or an object.");
              }
              if (outputNames.indexOf(name2) === -1) {
                throw new RangeError(`'fetches' contains invalid output name: ${name2}.`);
              }
              fetches[name2] = null;
            }
            if (typeof arg2 === "object" && arg2 !== null) {
              options = arg2;
            } else if (typeof arg2 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
          } else {
            let isFetches = false;
            const arg1Keys = Object.getOwnPropertyNames(arg1);
            for (const name2 of outputNames) {
              if (arg1Keys.indexOf(name2) !== -1) {
                const v = arg1[name2];
                if (v === null || v instanceof Tensor2) {
                  isFetches = true;
                  isFetchesEmpty = false;
                  fetches[name2] = v;
                }
              }
            }
            if (isFetches) {
              if (typeof arg2 === "object" && arg2 !== null) {
                options = arg2;
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else {
              options = arg1;
            }
          }
        } else if (typeof arg1 !== "undefined") {
          throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
        }
        for (const name2 of inputNames) {
          if (typeof feeds[name2] === "undefined") {
            throw new Error(`input '${name2}' is missing in 'feeds'.`);
          }
        }
        if (isFetchesEmpty) {
          for (const name2 of outputNames) {
            fetches[name2] = null;
          }
        }
        return [fetches, options];
      }
      /**
       * Helper method for runTrainStep and any other runStep methods. Takes the ReturnType result from the SessionHandler
       * and changes it into a map of Tensors.
       *
       * @param results
       * @returns
       */
      convertHandlerReturnTypeToMapOfTensors(results) {
        const returnValue = {};
        for (const key in results) {
          if (Object.hasOwnProperty.call(results, key)) {
            const result = results[key];
            if (result instanceof Tensor2) {
              returnValue[key] = result;
            } else {
              returnValue[key] = new Tensor2(result.type, result.data, result.dims);
            }
          }
        }
        return returnValue;
      }
      async lazyResetGrad() {
        await this.handler.lazyResetGrad();
      }
      async runTrainStep(feeds, arg1, arg2) {
        const [fetches, options] = this.typeNarrowingForRunStep(this.trainingInputNames, this.trainingOutputNames, feeds, arg1, arg2);
        const results = await this.handler.runTrainStep(feeds, fetches, options);
        return this.convertHandlerReturnTypeToMapOfTensors(results);
      }
      async runOptimizerStep(options) {
        if (this.hasOptimizerModel) {
          await this.handler.runOptimizerStep(options || {});
        } else {
          throw new Error("This TrainingSession has no OptimizerModel loaded.");
        }
      }
      async runEvalStep(feeds, arg1, arg2) {
        if (this.hasEvalModel) {
          const [fetches, options] = this.typeNarrowingForRunStep(this.evalInputNames, this.evalOutputNames, feeds, arg1, arg2);
          const results = await this.handler.runEvalStep(feeds, fetches, options);
          return this.convertHandlerReturnTypeToMapOfTensors(results);
        } else {
          throw new Error("This TrainingSession has no EvalModel loaded.");
        }
      }
      async getParametersSize(trainableOnly = true) {
        return this.handler.getParametersSize(trainableOnly);
      }
      async loadParametersBuffer(array, trainableOnly = true) {
        const paramsSize = await this.getParametersSize(trainableOnly);
        if (array.length !== 4 * paramsSize) {
          throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");
        }
        return this.handler.loadParametersBuffer(array, trainableOnly);
      }
      async getContiguousParameters(trainableOnly = true) {
        return this.handler.getContiguousParameters(trainableOnly);
      }
      async release() {
        return this.handler.dispose();
      }
    };
  }
});

// web/node_modules/onnxruntime-common/dist/esm/training-session.js
var TrainingSession2;
var init_training_session = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/training-session.js"() {
    init_training_session_impl();
    TrainingSession2 = TrainingSession;
  }
});

// web/node_modules/onnxruntime-common/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  InferenceSession: () => InferenceSession2,
  TRACE: () => TRACE,
  TRACE_FUNC_BEGIN: () => TRACE_FUNC_BEGIN,
  TRACE_FUNC_END: () => TRACE_FUNC_END,
  Tensor: () => Tensor2,
  TrainingSession: () => TrainingSession2,
  env: () => env2,
  registerBackend: () => registerBackend
});
var init_esm = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/index.js"() {
    init_backend();
    init_env();
    init_inference_session();
    init_tensor();
    init_tensor_conversion();
    init_tensor_factory();
    init_trace();
    init_onnx_model();
    init_onnx_value();
    init_training_session();
  }
});

// web/lib/onnxjs/instrument.ts
function log(arg0, arg1, arg2, arg3) {
  if (arg1 === void 0) {
    return createCategorizedLogger(arg0);
  } else if (arg2 === void 0) {
    logInternal(arg0, arg1, 1);
  } else if (typeof arg2 === "number" && arg3 === void 0) {
    logInternal(arg0, arg1, arg2);
  } else if (typeof arg2 === "string" && arg3 === void 0) {
    logInternal(arg0, arg2, 1, arg1);
  } else if (typeof arg2 === "string" && typeof arg3 === "number") {
    logInternal(arg0, arg2, arg3, arg1);
  } else {
    throw new TypeError("input is valid");
  }
}
function createCategorizedLogger(category) {
  return {
    verbose: log.verbose.bind(null, category),
    info: log.info.bind(null, category),
    warning: log.warning.bind(null, category),
    error: log.error.bind(null, category),
    fatal: log.fatal.bind(null, category)
  };
}
function logInternal(severity, content, _stack, category) {
  const config = LOGGER_CONFIG_MAP[category || ""] || LOGGER_CONFIG_MAP[""];
  if (SEVERITY_VALUE[severity] < SEVERITY_VALUE[config.minimalSeverity]) {
    return;
  }
  if (config.logDateTime) {
    content = `${(/* @__PURE__ */ new Date()).toISOString()}|${content}`;
  }
  if (config.logSourceLocation) {
  }
  LOGGER_PROVIDER_MAP[config.provider].log(severity, content, category);
}
var NoOpLoggerProvider, ConsoleLoggerProvider, SEVERITY_VALUE, LOGGER_PROVIDER_MAP, LOGGER_DEFAULT_CONFIG, LOGGER_CONFIG_MAP, Logger, Event, EventRecord, Profiler, now;
var init_instrument = __esm({
  "web/lib/onnxjs/instrument.ts"() {
    "use strict";
    NoOpLoggerProvider = class {
      log(_severity, _content, _category) {
      }
    };
    ConsoleLoggerProvider = class {
      log(severity, content, category) {
        console.log(`${this.color(severity)} ${category ? "\x1B[35m" + category + "\x1B[0m " : ""}${content}`);
      }
      color(severity) {
        switch (severity) {
          case "verbose":
            return "\x1B[34;40mv\x1B[0m";
          case "info":
            return "\x1B[32mi\x1B[0m";
          case "warning":
            return "\x1B[30;43mw\x1B[0m";
          case "error":
            return "\x1B[31;40me\x1B[0m";
          case "fatal":
            return "\x1B[101mf\x1B[0m";
          default:
            throw new Error(`unsupported severity: ${severity}`);
        }
      }
    };
    SEVERITY_VALUE = {
      verbose: 1e3,
      info: 2e3,
      warning: 4e3,
      error: 5e3,
      fatal: 6e3
    };
    LOGGER_PROVIDER_MAP = {
      ["none"]: new NoOpLoggerProvider(),
      ["console"]: new ConsoleLoggerProvider()
    };
    LOGGER_DEFAULT_CONFIG = {
      provider: "console",
      minimalSeverity: "warning",
      logDateTime: true,
      logSourceLocation: false
    };
    LOGGER_CONFIG_MAP = { [""]: LOGGER_DEFAULT_CONFIG };
    ((log3) => {
      function verbose(arg0, arg1) {
        log3("verbose", arg0, arg1);
      }
      log3.verbose = verbose;
      function info(arg0, arg1) {
        log3("info", arg0, arg1);
      }
      log3.info = info;
      function warning(arg0, arg1) {
        log3("warning", arg0, arg1);
      }
      log3.warning = warning;
      function error(arg0, arg1) {
        log3("error", arg0, arg1);
      }
      log3.error = error;
      function fatal(arg0, arg1) {
        log3("fatal", arg0, arg1);
      }
      log3.fatal = fatal;
      function reset(config) {
        LOGGER_CONFIG_MAP = {};
        set("", config || {});
      }
      log3.reset = reset;
      function set(category, config) {
        if (category === "*") {
          reset(config);
        } else {
          const previousConfig = LOGGER_CONFIG_MAP[category] || LOGGER_DEFAULT_CONFIG;
          LOGGER_CONFIG_MAP[category] = {
            provider: config.provider || previousConfig.provider,
            minimalSeverity: config.minimalSeverity || previousConfig.minimalSeverity,
            logDateTime: config.logDateTime === void 0 ? previousConfig.logDateTime : config.logDateTime,
            logSourceLocation: config.logSourceLocation === void 0 ? previousConfig.logSourceLocation : config.logSourceLocation
          };
        }
      }
      log3.set = set;
      function setWithEnv(env3) {
        const config = {};
        if (env3.logLevel) {
          config.minimalSeverity = env3.logLevel;
        }
        set("", config);
      }
      log3.setWithEnv = setWithEnv;
    })(log || (log = {}));
    Logger = log;
    Event = class {
      constructor(category, name2, startTime, endCallback, timer, ctx) {
        this.category = category;
        this.name = name2;
        this.startTime = startTime;
        this.endCallback = endCallback;
        this.timer = timer;
        this.ctx = ctx;
      }
      async end() {
        return this.endCallback(this);
      }
      async checkTimer() {
        if (this.ctx === void 0 || this.timer === void 0) {
          throw new Error("No webgl timer found");
        } else {
          this.ctx.endTimer();
          return this.ctx.waitForQueryAndGetTime(this.timer);
        }
      }
    };
    EventRecord = class {
      constructor(category, name2, startTime, endTime) {
        this.category = category;
        this.name = name2;
        this.startTime = startTime;
        this.endTime = endTime;
      }
    };
    Profiler = class {
      constructor(maxNumberEvents, flushBatchSize, flushIntervalInMilliseconds) {
        this._started = false;
        this._flushPointer = 0;
        this._started = false;
        this._maxNumberEvents = maxNumberEvents === void 0 ? 1e4 : maxNumberEvents;
        this._flushBatchSize = flushBatchSize === void 0 ? 10 : flushBatchSize;
        this._flushIntervalInMilliseconds = flushIntervalInMilliseconds === void 0 ? 5e3 : flushIntervalInMilliseconds;
      }
      static create(config) {
        if (config === void 0) {
          return new this();
        }
        return new this(config.maxNumberEvents, config.flushBatchSize, config.flushIntervalInMilliseconds);
      }
      // start profiling
      start() {
        this._started = true;
        this._timingEvents = [];
        this._flushTime = now();
        this._flushPointer = 0;
      }
      // stop profiling
      stop() {
        this._started = false;
        for (; this._flushPointer < this._timingEvents.length; this._flushPointer++) {
          this.logOneEvent(this._timingEvents[this._flushPointer]);
        }
      }
      event(category, name2, func, ctx) {
        const event = this._started ? this.begin(category, name2, ctx) : void 0;
        let isPromise = false;
        const res = func();
        if (res && typeof res.then === "function") {
          isPromise = true;
          return new Promise((resolve, reject) => {
            res.then(
              async (value) => {
                if (event) {
                  await event.end();
                }
                resolve(value);
              },
              async (reason) => {
                if (event) {
                  await event.end();
                }
                reject(reason);
              }
            );
          });
        }
        if (!isPromise && event) {
          const eventRes = event.end();
          if (eventRes && typeof eventRes.then === "function") {
            return new Promise((resolve, reject) => {
              eventRes.then(
                () => {
                  resolve(res);
                },
                (reason) => {
                  reject(reason);
                }
              );
            });
          }
        }
        return res;
      }
      // begin an event
      begin(category, name2, ctx) {
        if (!this._started) {
          throw new Error("profiler is not started yet");
        }
        if (ctx === void 0) {
          const startTime = now();
          this.flush(startTime);
          return new Event(category, name2, startTime, (e) => this.endSync(e));
        } else {
          const timer = ctx.beginTimer();
          return new Event(category, name2, 0, async (e) => this.end(e), timer, ctx);
        }
      }
      // end the specific event
      async end(event) {
        const endTime = await event.checkTimer();
        if (this._timingEvents.length < this._maxNumberEvents) {
          this._timingEvents.push(new EventRecord(event.category, event.name, event.startTime, endTime));
          this.flush(endTime);
        }
      }
      endSync(event) {
        const endTime = now();
        if (this._timingEvents.length < this._maxNumberEvents) {
          this._timingEvents.push(new EventRecord(event.category, event.name, event.startTime, endTime));
          this.flush(endTime);
        }
      }
      logOneEvent(event) {
        Logger.verbose(
          `Profiler.${event.category}`,
          `${(event.endTime - event.startTime).toFixed(2)}ms on event '${event.name}' at ${event.endTime.toFixed(2)}`
        );
      }
      flush(currentTime) {
        if (this._timingEvents.length - this._flushPointer >= this._flushBatchSize || currentTime - this._flushTime >= this._flushIntervalInMilliseconds) {
          for (const previousPointer = this._flushPointer; this._flushPointer < previousPointer + this._flushBatchSize && this._flushPointer < this._timingEvents.length; this._flushPointer++) {
            this.logOneEvent(this._timingEvents[this._flushPointer]);
          }
          this._flushTime = now();
        }
      }
      get started() {
        return this._started;
      }
    };
    now = typeof performance !== "undefined" && performance.now ? () => performance.now() : Date.now;
  }
});

// web/lib/onnxjs/opset.ts
function resolveOperator(node, opsets, rules) {
  for (const rule of rules) {
    const opType = rule[0];
    const domain = rule[1];
    const versionSelector = rule[2];
    const opImpl = rule[3];
    const opInit = rule[4];
    if (node.opType === opType) {
      for (const opset of opsets) {
        if (opset.domain === domain || opset.domain === "ai.onnx" && domain === "") {
          if (matchSelector(opset.version, versionSelector)) {
            return { opImpl, opInit };
          }
        }
      }
    }
  }
  throw new TypeError(`cannot resolve operator '${node.opType}' with opsets: ${opsets.map((set) => `${set.domain || "ai.onnx"} v${set.version}`).join(", ")}`);
}
function matchSelector(version3, selector) {
  if (selector.endsWith("+")) {
    const rangeStart = Number.parseInt(selector.substring(0, selector.length - 1), 10);
    return !isNaN(rangeStart) && rangeStart <= version3;
  } else if (selector.split("-").length === 2) {
    const pair = selector.split("-");
    const rangeStart = Number.parseInt(pair[0], 10);
    const rangeEnd = Number.parseInt(pair[1], 10);
    return !isNaN(rangeStart) && !isNaN(rangeEnd) && rangeStart <= version3 && version3 <= rangeEnd;
  } else {
    return Number.parseInt(selector, 10) === version3;
  }
}
var init_opset = __esm({
  "web/lib/onnxjs/opset.ts"() {
    "use strict";
  }
});

// web/node_modules/guid-typescript/dist/guid.js
var require_guid = __commonJS({
  "web/node_modules/guid-typescript/dist/guid.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    var Guid2 = (
      /** @class */
      function() {
        function Guid3(guid) {
          if (!guid) {
            throw new TypeError("Invalid argument; `value` has no value.");
          }
          this.value = Guid3.EMPTY;
          if (guid && Guid3.isGuid(guid)) {
            this.value = guid;
          }
        }
        Guid3.isGuid = function(guid) {
          var value = guid.toString();
          return guid && (guid instanceof Guid3 || Guid3.validator.test(value));
        };
        Guid3.create = function() {
          return new Guid3([Guid3.gen(2), Guid3.gen(1), Guid3.gen(1), Guid3.gen(1), Guid3.gen(3)].join("-"));
        };
        Guid3.createEmpty = function() {
          return new Guid3("emptyguid");
        };
        Guid3.parse = function(guid) {
          return new Guid3(guid);
        };
        Guid3.raw = function() {
          return [Guid3.gen(2), Guid3.gen(1), Guid3.gen(1), Guid3.gen(1), Guid3.gen(3)].join("-");
        };
        Guid3.gen = function(count) {
          var out = "";
          for (var i = 0; i < count; i++) {
            out += ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
          }
          return out;
        };
        Guid3.prototype.equals = function(other) {
          return Guid3.isGuid(other) && this.value === other.toString();
        };
        Guid3.prototype.isEmpty = function() {
          return this.value === Guid3.EMPTY;
        };
        Guid3.prototype.toString = function() {
          return this.value;
        };
        Guid3.prototype.toJSON = function() {
          return {
            value: this.value
          };
        };
        Guid3.validator = new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$", "i");
        Guid3.EMPTY = "00000000-0000-0000-0000-000000000000";
        return Guid3;
      }()
    );
    exports2.Guid = Guid2;
  }
});

// web/node_modules/long/index.js
function Long(low, high, unsigned) {
  this.low = low | 0;
  this.high = high | 0;
  this.unsigned = !!unsigned;
}
function isLong(obj) {
  return (obj && obj["__isLong__"]) === true;
}
function ctz32(value) {
  var c = Math.clz32(value & -value);
  return value ? 31 - c : c;
}
function fromInt(value, unsigned) {
  var obj, cachedObj, cache2;
  if (unsigned) {
    value >>>= 0;
    if (cache2 = 0 <= value && value < 256) {
      cachedObj = UINT_CACHE[value];
      if (cachedObj)
        return cachedObj;
    }
    obj = fromBits(value, 0, true);
    if (cache2)
      UINT_CACHE[value] = obj;
    return obj;
  } else {
    value |= 0;
    if (cache2 = -128 <= value && value < 128) {
      cachedObj = INT_CACHE[value];
      if (cachedObj)
        return cachedObj;
    }
    obj = fromBits(value, value < 0 ? -1 : 0, false);
    if (cache2)
      INT_CACHE[value] = obj;
    return obj;
  }
}
function fromNumber(value, unsigned) {
  if (isNaN(value))
    return unsigned ? UZERO : ZERO;
  if (unsigned) {
    if (value < 0)
      return UZERO;
    if (value >= TWO_PWR_64_DBL)
      return MAX_UNSIGNED_VALUE;
  } else {
    if (value <= -TWO_PWR_63_DBL)
      return MIN_VALUE;
    if (value + 1 >= TWO_PWR_63_DBL)
      return MAX_VALUE;
  }
  if (value < 0)
    return fromNumber(-value, unsigned).neg();
  return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
}
function fromBits(lowBits, highBits, unsigned) {
  return new Long(lowBits, highBits, unsigned);
}
function fromString(str, unsigned, radix) {
  if (str.length === 0)
    throw Error("empty string");
  if (typeof unsigned === "number") {
    radix = unsigned;
    unsigned = false;
  } else {
    unsigned = !!unsigned;
  }
  if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
    return unsigned ? UZERO : ZERO;
  radix = radix || 10;
  if (radix < 2 || 36 < radix)
    throw RangeError("radix");
  var p;
  if ((p = str.indexOf("-")) > 0)
    throw Error("interior hyphen");
  else if (p === 0) {
    return fromString(str.substring(1), unsigned, radix).neg();
  }
  var radixToPower = fromNumber(pow_dbl(radix, 8));
  var result = ZERO;
  for (var i = 0; i < str.length; i += 8) {
    var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
    if (size < 8) {
      var power = fromNumber(pow_dbl(radix, size));
      result = result.mul(power).add(fromNumber(value));
    } else {
      result = result.mul(radixToPower);
      result = result.add(fromNumber(value));
    }
  }
  result.unsigned = unsigned;
  return result;
}
function fromValue(val, unsigned) {
  if (typeof val === "number")
    return fromNumber(val, unsigned);
  if (typeof val === "string")
    return fromString(val, unsigned);
  return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
}
var wasm, INT_CACHE, UINT_CACHE, pow_dbl, TWO_PWR_16_DBL, TWO_PWR_24_DBL, TWO_PWR_32_DBL, TWO_PWR_64_DBL, TWO_PWR_63_DBL, TWO_PWR_24, ZERO, UZERO, ONE, UONE, NEG_ONE, MAX_VALUE, MAX_UNSIGNED_VALUE, MIN_VALUE, LongPrototype, long_default;
var init_long = __esm({
  "web/node_modules/long/index.js"() {
    wasm = null;
    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        13,
        2,
        96,
        0,
        1,
        127,
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        3,
        7,
        6,
        0,
        1,
        1,
        1,
        1,
        1,
        6,
        6,
        1,
        127,
        1,
        65,
        0,
        11,
        7,
        50,
        6,
        3,
        109,
        117,
        108,
        0,
        1,
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        10,
        191,
        1,
        6,
        4,
        0,
        35,
        0,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])), {}).exports;
    } catch (e) {
    }
    Long.prototype.__isLong__;
    Object.defineProperty(Long.prototype, "__isLong__", { value: true });
    Long.isLong = isLong;
    INT_CACHE = {};
    UINT_CACHE = {};
    Long.fromInt = fromInt;
    Long.fromNumber = fromNumber;
    Long.fromBits = fromBits;
    pow_dbl = Math.pow;
    Long.fromString = fromString;
    Long.fromValue = fromValue;
    TWO_PWR_16_DBL = 1 << 16;
    TWO_PWR_24_DBL = 1 << 24;
    TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
    ZERO = fromInt(0);
    Long.ZERO = ZERO;
    UZERO = fromInt(0, true);
    Long.UZERO = UZERO;
    ONE = fromInt(1);
    Long.ONE = ONE;
    UONE = fromInt(1, true);
    Long.UONE = UONE;
    NEG_ONE = fromInt(-1);
    Long.NEG_ONE = NEG_ONE;
    MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long.MAX_VALUE = MAX_VALUE;
    MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
    MIN_VALUE = fromBits(0, 2147483648 | 0, false);
    Long.MIN_VALUE = MIN_VALUE;
    LongPrototype = Long.prototype;
    LongPrototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    LongPrototype.toNumber = function toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    LongPrototype.toString = function toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(MIN_VALUE)) {
          var radixLong = fromNumber(radix), div2 = this.div(radixLong), rem1 = div2.mul(radixLong).sub(this);
          return div2.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
      var result = "";
      while (true) {
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
          return digits + result;
        else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    };
    LongPrototype.getHighBits = function getHighBits() {
      return this.high;
    };
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
    };
    LongPrototype.getLowBits = function getLowBits() {
      return this.low;
    };
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
    };
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative())
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--)
        if ((val & 1 << bit) != 0)
          break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };
    LongPrototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
    };
    LongPrototype.eqz = LongPrototype.isZero;
    LongPrototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
    };
    LongPrototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
    };
    LongPrototype.isOdd = function isOdd() {
      return (this.low & 1) === 1;
    };
    LongPrototype.isEven = function isEven() {
      return (this.low & 1) === 0;
    };
    LongPrototype.equals = function equals(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    };
    LongPrototype.eq = LongPrototype.equals;
    LongPrototype.notEquals = function notEquals(other) {
      return !this.eq(
        /* validates */
        other
      );
    };
    LongPrototype.neq = LongPrototype.notEquals;
    LongPrototype.ne = LongPrototype.notEquals;
    LongPrototype.lessThan = function lessThan(other) {
      return this.comp(
        /* validates */
        other
      ) < 0;
    };
    LongPrototype.lt = LongPrototype.lessThan;
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) <= 0;
    };
    LongPrototype.lte = LongPrototype.lessThanOrEqual;
    LongPrototype.le = LongPrototype.lessThanOrEqual;
    LongPrototype.greaterThan = function greaterThan(other) {
      return this.comp(
        /* validates */
        other
      ) > 0;
    };
    LongPrototype.gt = LongPrototype.greaterThan;
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) >= 0;
    };
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;
    LongPrototype.ge = LongPrototype.greaterThanOrEqual;
    LongPrototype.compare = function compare(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.eq(other))
        return 0;
      var thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    LongPrototype.comp = LongPrototype.compare;
    LongPrototype.negate = function negate() {
      if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
      return this.not().add(ONE);
    };
    LongPrototype.neg = LongPrototype.negate;
    LongPrototype.add = function add(addend) {
      if (!isLong(addend))
        addend = fromValue(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.subtract = function subtract(subtrahend) {
      if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
      return this.add(subtrahend.neg());
    };
    LongPrototype.sub = LongPrototype.subtract;
    LongPrototype.multiply = function multiply(multiplier) {
      if (this.isZero())
        return this;
      if (!isLong(multiplier))
        multiplier = fromValue(multiplier);
      if (wasm) {
        var low = wasm["mul"](
          this.low,
          this.high,
          multiplier.low,
          multiplier.high
        );
        return fromBits(low, wasm["get_high"](), this.unsigned);
      }
      if (multiplier.isZero())
        return this.unsigned ? UZERO : ZERO;
      if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
      if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.mul = LongPrototype.multiply;
    LongPrototype.divide = function divide(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (divisor.isZero())
        throw Error("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm["get_high"](), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(MIN_VALUE)) {
          if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
            return MIN_VALUE;
          else if (divisor.eq(MIN_VALUE))
            return ONE;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO)) {
              return divisor.isNegative() ? ONE : NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(MIN_VALUE))
          return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = ZERO;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return UZERO;
        if (divisor.gt(this.shru(1)))
          return UONE;
        res = UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log22 = Math.ceil(Math.log(approx) / Math.LN2), delta = log22 <= 48 ? 1 : pow_dbl(2, log22 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };
    LongPrototype.div = LongPrototype.divide;
    LongPrototype.modulo = function modulo(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (wasm) {
        var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm["get_high"](), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    LongPrototype.mod = LongPrototype.modulo;
    LongPrototype.rem = LongPrototype.modulo;
    LongPrototype.not = function not() {
      return fromBits(~this.low, ~this.high, this.unsigned);
    };
    LongPrototype.countLeadingZeros = function countLeadingZeros() {
      return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
    };
    LongPrototype.clz = LongPrototype.countLeadingZeros;
    LongPrototype.countTrailingZeros = function countTrailingZeros() {
      return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
    };
    LongPrototype.ctz = LongPrototype.countTrailingZeros;
    LongPrototype.and = function and(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    LongPrototype.or = function or(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    LongPrototype.xor = function xor(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return fromBits(0, this.low << numBits - 32, this.unsigned);
    };
    LongPrototype.shl = LongPrototype.shiftLeft;
    LongPrototype.shiftRight = function shiftRight(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    LongPrototype.shr = LongPrototype.shiftRight;
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      if (numBits < 32)
        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
      if (numBits === 32)
        return fromBits(this.high, 0, this.unsigned);
      return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
    };
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;
    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
    LongPrototype.rotateLeft = function rotateLeft(numBits) {
      var b;
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      if (numBits === 32)
        return fromBits(this.high, this.low, this.unsigned);
      if (numBits < 32) {
        b = 32 - numBits;
        return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
      }
      numBits -= 32;
      b = 32 - numBits;
      return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
    };
    LongPrototype.rotl = LongPrototype.rotateLeft;
    LongPrototype.rotateRight = function rotateRight(numBits) {
      var b;
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      if (numBits === 32)
        return fromBits(this.high, this.low, this.unsigned);
      if (numBits < 32) {
        b = 32 - numBits;
        return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
      }
      numBits -= 32;
      b = 32 - numBits;
      return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
    };
    LongPrototype.rotr = LongPrototype.rotateRight;
    LongPrototype.toSigned = function toSigned() {
      if (!this.unsigned)
        return this;
      return fromBits(this.low, this.high, false);
    };
    LongPrototype.toUnsigned = function toUnsigned() {
      if (this.unsigned)
        return this;
      return fromBits(this.low, this.high, true);
    };
    LongPrototype.toBytes = function toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    };
    LongPrototype.toBytesLE = function toBytesLE() {
      var hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    };
    LongPrototype.toBytesBE = function toBytesBE() {
      var hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    };
    Long.fromBytes = function fromBytes(bytes, unsigned, le) {
      return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
    };
    Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
      return new Long(
        bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
        bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
        unsigned
      );
    };
    Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
      return new Long(
        bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
        bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
        unsigned
      );
    };
    long_default = Long;
  }
});

// web/node_modules/flatbuffers/js/flatbuffers.mjs
var flatbuffers;
var init_flatbuffers = __esm({
  "web/node_modules/flatbuffers/js/flatbuffers.mjs"() {
    flatbuffers = {};
    flatbuffers.Offset;
    flatbuffers.Table;
    flatbuffers.SIZEOF_SHORT = 2;
    flatbuffers.SIZEOF_INT = 4;
    flatbuffers.FILE_IDENTIFIER_LENGTH = 4;
    flatbuffers.SIZE_PREFIX_LENGTH = 4;
    flatbuffers.Encoding = {
      UTF8_BYTES: 1,
      UTF16_STRING: 2
    };
    flatbuffers.int32 = new Int32Array(2);
    flatbuffers.float32 = new Float32Array(flatbuffers.int32.buffer);
    flatbuffers.float64 = new Float64Array(flatbuffers.int32.buffer);
    flatbuffers.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
    flatbuffers.Long = function(low, high) {
      this.low = low | 0;
      this.high = high | 0;
    };
    flatbuffers.Long.create = function(low, high) {
      return low == 0 && high == 0 ? flatbuffers.Long.ZERO : new flatbuffers.Long(low, high);
    };
    flatbuffers.Long.prototype.toFloat64 = function() {
      return (this.low >>> 0) + this.high * 4294967296;
    };
    flatbuffers.Long.prototype.equals = function(other) {
      return this.low == other.low && this.high == other.high;
    };
    flatbuffers.Long.ZERO = new flatbuffers.Long(0, 0);
    flatbuffers.Builder = function(opt_initial_size) {
      if (!opt_initial_size) {
        var initial_size = 1024;
      } else {
        var initial_size = opt_initial_size;
      }
      this.bb = flatbuffers.ByteBuffer.allocate(initial_size);
      this.space = initial_size;
      this.minalign = 1;
      this.vtable = null;
      this.vtable_in_use = 0;
      this.isNested = false;
      this.object_start = 0;
      this.vtables = [];
      this.vector_num_elems = 0;
      this.force_defaults = false;
    };
    flatbuffers.Builder.prototype.clear = function() {
      this.bb.clear();
      this.space = this.bb.capacity();
      this.minalign = 1;
      this.vtable = null;
      this.vtable_in_use = 0;
      this.isNested = false;
      this.object_start = 0;
      this.vtables = [];
      this.vector_num_elems = 0;
      this.force_defaults = false;
    };
    flatbuffers.Builder.prototype.forceDefaults = function(forceDefaults) {
      this.force_defaults = forceDefaults;
    };
    flatbuffers.Builder.prototype.dataBuffer = function() {
      return this.bb;
    };
    flatbuffers.Builder.prototype.asUint8Array = function() {
      return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
    };
    flatbuffers.Builder.prototype.prep = function(size, additional_bytes) {
      if (size > this.minalign) {
        this.minalign = size;
      }
      var align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size - 1;
      while (this.space < align_size + size + additional_bytes) {
        var old_buf_size = this.bb.capacity();
        this.bb = flatbuffers.Builder.growByteBuffer(this.bb);
        this.space += this.bb.capacity() - old_buf_size;
      }
      this.pad(align_size);
    };
    flatbuffers.Builder.prototype.pad = function(byte_size) {
      for (var i = 0; i < byte_size; i++) {
        this.bb.writeInt8(--this.space, 0);
      }
    };
    flatbuffers.Builder.prototype.writeInt8 = function(value) {
      this.bb.writeInt8(this.space -= 1, value);
    };
    flatbuffers.Builder.prototype.writeInt16 = function(value) {
      this.bb.writeInt16(this.space -= 2, value);
    };
    flatbuffers.Builder.prototype.writeInt32 = function(value) {
      this.bb.writeInt32(this.space -= 4, value);
    };
    flatbuffers.Builder.prototype.writeInt64 = function(value) {
      this.bb.writeInt64(this.space -= 8, value);
    };
    flatbuffers.Builder.prototype.writeFloat32 = function(value) {
      this.bb.writeFloat32(this.space -= 4, value);
    };
    flatbuffers.Builder.prototype.writeFloat64 = function(value) {
      this.bb.writeFloat64(this.space -= 8, value);
    };
    flatbuffers.Builder.prototype.addInt8 = function(value) {
      this.prep(1, 0);
      this.writeInt8(value);
    };
    flatbuffers.Builder.prototype.addInt16 = function(value) {
      this.prep(2, 0);
      this.writeInt16(value);
    };
    flatbuffers.Builder.prototype.addInt32 = function(value) {
      this.prep(4, 0);
      this.writeInt32(value);
    };
    flatbuffers.Builder.prototype.addInt64 = function(value) {
      this.prep(8, 0);
      this.writeInt64(value);
    };
    flatbuffers.Builder.prototype.addFloat32 = function(value) {
      this.prep(4, 0);
      this.writeFloat32(value);
    };
    flatbuffers.Builder.prototype.addFloat64 = function(value) {
      this.prep(8, 0);
      this.writeFloat64(value);
    };
    flatbuffers.Builder.prototype.addFieldInt8 = function(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt8(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldInt16 = function(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt16(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldInt32 = function(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt32(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldInt64 = function(voffset, value, defaultValue) {
      if (this.force_defaults || !value.equals(defaultValue)) {
        this.addInt64(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldFloat32 = function(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addFloat32(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldFloat64 = function(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addFloat64(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldOffset = function(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addOffset(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.addFieldStruct = function(voffset, value, defaultValue) {
      if (value != defaultValue) {
        this.nested(value);
        this.slot(voffset);
      }
    };
    flatbuffers.Builder.prototype.nested = function(obj) {
      if (obj != this.offset()) {
        throw new Error("FlatBuffers: struct must be serialized inline.");
      }
    };
    flatbuffers.Builder.prototype.notNested = function() {
      if (this.isNested) {
        throw new Error("FlatBuffers: object serialization must not be nested.");
      }
    };
    flatbuffers.Builder.prototype.slot = function(voffset) {
      this.vtable[voffset] = this.offset();
    };
    flatbuffers.Builder.prototype.offset = function() {
      return this.bb.capacity() - this.space;
    };
    flatbuffers.Builder.growByteBuffer = function(bb) {
      var old_buf_size = bb.capacity();
      if (old_buf_size & 3221225472) {
        throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
      }
      var new_buf_size = old_buf_size << 1;
      var nbb = flatbuffers.ByteBuffer.allocate(new_buf_size);
      nbb.setPosition(new_buf_size - old_buf_size);
      nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
      return nbb;
    };
    flatbuffers.Builder.prototype.addOffset = function(offset) {
      this.prep(flatbuffers.SIZEOF_INT, 0);
      this.writeInt32(this.offset() - offset + flatbuffers.SIZEOF_INT);
    };
    flatbuffers.Builder.prototype.startObject = function(numfields) {
      this.notNested();
      if (this.vtable == null) {
        this.vtable = [];
      }
      this.vtable_in_use = numfields;
      for (var i = 0; i < numfields; i++) {
        this.vtable[i] = 0;
      }
      this.isNested = true;
      this.object_start = this.offset();
    };
    flatbuffers.Builder.prototype.endObject = function() {
      if (this.vtable == null || !this.isNested) {
        throw new Error("FlatBuffers: endObject called without startObject");
      }
      this.addInt32(0);
      var vtableloc = this.offset();
      var i = this.vtable_in_use - 1;
      for (; i >= 0 && this.vtable[i] == 0; i--) {
      }
      var trimmed_size = i + 1;
      for (; i >= 0; i--) {
        this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);
      }
      var standard_fields = 2;
      this.addInt16(vtableloc - this.object_start);
      var len = (trimmed_size + standard_fields) * flatbuffers.SIZEOF_SHORT;
      this.addInt16(len);
      var existing_vtable = 0;
      var vt1 = this.space;
      outer_loop:
        for (i = 0; i < this.vtables.length; i++) {
          var vt2 = this.bb.capacity() - this.vtables[i];
          if (len == this.bb.readInt16(vt2)) {
            for (var j = flatbuffers.SIZEOF_SHORT; j < len; j += flatbuffers.SIZEOF_SHORT) {
              if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
                continue outer_loop;
              }
            }
            existing_vtable = this.vtables[i];
            break;
          }
        }
      if (existing_vtable) {
        this.space = this.bb.capacity() - vtableloc;
        this.bb.writeInt32(this.space, existing_vtable - vtableloc);
      } else {
        this.vtables.push(this.offset());
        this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
      }
      this.isNested = false;
      return vtableloc;
    };
    flatbuffers.Builder.prototype.finish = function(root_table, opt_file_identifier, opt_size_prefix) {
      var size_prefix = opt_size_prefix ? flatbuffers.SIZE_PREFIX_LENGTH : 0;
      if (opt_file_identifier) {
        var file_identifier = opt_file_identifier;
        this.prep(this.minalign, flatbuffers.SIZEOF_INT + flatbuffers.FILE_IDENTIFIER_LENGTH + size_prefix);
        if (file_identifier.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {
          throw new Error("FlatBuffers: file identifier must be length " + flatbuffers.FILE_IDENTIFIER_LENGTH);
        }
        for (var i = flatbuffers.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {
          this.writeInt8(file_identifier.charCodeAt(i));
        }
      }
      this.prep(this.minalign, flatbuffers.SIZEOF_INT + size_prefix);
      this.addOffset(root_table);
      if (size_prefix) {
        this.addInt32(this.bb.capacity() - this.space);
      }
      this.bb.setPosition(this.space);
    };
    flatbuffers.Builder.prototype.finishSizePrefixed = function(root_table, opt_file_identifier) {
      this.finish(root_table, opt_file_identifier, true);
    };
    flatbuffers.Builder.prototype.requiredField = function(table, field) {
      var table_start = this.bb.capacity() - table;
      var vtable_start = table_start - this.bb.readInt32(table_start);
      var ok = this.bb.readInt16(vtable_start + field) != 0;
      if (!ok) {
        throw new Error("FlatBuffers: field " + field + " must be set");
      }
    };
    flatbuffers.Builder.prototype.startVector = function(elem_size, num_elems, alignment) {
      this.notNested();
      this.vector_num_elems = num_elems;
      this.prep(flatbuffers.SIZEOF_INT, elem_size * num_elems);
      this.prep(alignment, elem_size * num_elems);
    };
    flatbuffers.Builder.prototype.endVector = function() {
      this.writeInt32(this.vector_num_elems);
      return this.offset();
    };
    flatbuffers.Builder.prototype.createString = function(s) {
      if (s instanceof Uint8Array) {
        var utf8 = s;
      } else {
        var utf8 = [];
        var i = 0;
        while (i < s.length) {
          var codePoint;
          var a = s.charCodeAt(i++);
          if (a < 55296 || a >= 56320) {
            codePoint = a;
          } else {
            var b = s.charCodeAt(i++);
            codePoint = (a << 10) + b + (65536 - (55296 << 10) - 56320);
          }
          if (codePoint < 128) {
            utf8.push(codePoint);
          } else {
            if (codePoint < 2048) {
              utf8.push(codePoint >> 6 & 31 | 192);
            } else {
              if (codePoint < 65536) {
                utf8.push(codePoint >> 12 & 15 | 224);
              } else {
                utf8.push(
                  codePoint >> 18 & 7 | 240,
                  codePoint >> 12 & 63 | 128
                );
              }
              utf8.push(codePoint >> 6 & 63 | 128);
            }
            utf8.push(codePoint & 63 | 128);
          }
        }
      }
      this.addInt8(0);
      this.startVector(1, utf8.length, 1);
      this.bb.setPosition(this.space -= utf8.length);
      for (var i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {
        bytes[offset++] = utf8[i];
      }
      return this.endVector();
    };
    flatbuffers.Builder.prototype.createLong = function(low, high) {
      return flatbuffers.Long.create(low, high);
    };
    flatbuffers.ByteBuffer = function(bytes) {
      this.bytes_ = bytes;
      this.position_ = 0;
    };
    flatbuffers.ByteBuffer.allocate = function(byte_size) {
      return new flatbuffers.ByteBuffer(new Uint8Array(byte_size));
    };
    flatbuffers.ByteBuffer.prototype.clear = function() {
      this.position_ = 0;
    };
    flatbuffers.ByteBuffer.prototype.bytes = function() {
      return this.bytes_;
    };
    flatbuffers.ByteBuffer.prototype.position = function() {
      return this.position_;
    };
    flatbuffers.ByteBuffer.prototype.setPosition = function(position) {
      this.position_ = position;
    };
    flatbuffers.ByteBuffer.prototype.capacity = function() {
      return this.bytes_.length;
    };
    flatbuffers.ByteBuffer.prototype.readInt8 = function(offset) {
      return this.readUint8(offset) << 24 >> 24;
    };
    flatbuffers.ByteBuffer.prototype.readUint8 = function(offset) {
      return this.bytes_[offset];
    };
    flatbuffers.ByteBuffer.prototype.readInt16 = function(offset) {
      return this.readUint16(offset) << 16 >> 16;
    };
    flatbuffers.ByteBuffer.prototype.readUint16 = function(offset) {
      return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
    };
    flatbuffers.ByteBuffer.prototype.readInt32 = function(offset) {
      return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
    };
    flatbuffers.ByteBuffer.prototype.readUint32 = function(offset) {
      return this.readInt32(offset) >>> 0;
    };
    flatbuffers.ByteBuffer.prototype.readInt64 = function(offset) {
      return new flatbuffers.Long(this.readInt32(offset), this.readInt32(offset + 4));
    };
    flatbuffers.ByteBuffer.prototype.readUint64 = function(offset) {
      return new flatbuffers.Long(this.readUint32(offset), this.readUint32(offset + 4));
    };
    flatbuffers.ByteBuffer.prototype.readFloat32 = function(offset) {
      flatbuffers.int32[0] = this.readInt32(offset);
      return flatbuffers.float32[0];
    };
    flatbuffers.ByteBuffer.prototype.readFloat64 = function(offset) {
      flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1] = this.readInt32(offset);
      flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
      return flatbuffers.float64[0];
    };
    flatbuffers.ByteBuffer.prototype.writeInt8 = function(offset, value) {
      this.bytes_[offset] = /** @type {number} */
      value;
    };
    flatbuffers.ByteBuffer.prototype.writeUint8 = function(offset, value) {
      this.bytes_[offset] = value;
    };
    flatbuffers.ByteBuffer.prototype.writeInt16 = function(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
    };
    flatbuffers.ByteBuffer.prototype.writeUint16 = function(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
    };
    flatbuffers.ByteBuffer.prototype.writeInt32 = function(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
      this.bytes_[offset + 2] = value >> 16;
      this.bytes_[offset + 3] = value >> 24;
    };
    flatbuffers.ByteBuffer.prototype.writeUint32 = function(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
      this.bytes_[offset + 2] = value >> 16;
      this.bytes_[offset + 3] = value >> 24;
    };
    flatbuffers.ByteBuffer.prototype.writeInt64 = function(offset, value) {
      this.writeInt32(offset, value.low);
      this.writeInt32(offset + 4, value.high);
    };
    flatbuffers.ByteBuffer.prototype.writeUint64 = function(offset, value) {
      this.writeUint32(offset, value.low);
      this.writeUint32(offset + 4, value.high);
    };
    flatbuffers.ByteBuffer.prototype.writeFloat32 = function(offset, value) {
      flatbuffers.float32[0] = value;
      this.writeInt32(offset, flatbuffers.int32[0]);
    };
    flatbuffers.ByteBuffer.prototype.writeFloat64 = function(offset, value) {
      flatbuffers.float64[0] = value;
      this.writeInt32(offset, flatbuffers.int32[flatbuffers.isLittleEndian ? 0 : 1]);
      this.writeInt32(offset + 4, flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0]);
    };
    flatbuffers.ByteBuffer.prototype.getBufferIdentifier = function() {
      if (this.bytes_.length < this.position_ + flatbuffers.SIZEOF_INT + flatbuffers.FILE_IDENTIFIER_LENGTH) {
        throw new Error(
          "FlatBuffers: ByteBuffer is too short to contain an identifier."
        );
      }
      var result = "";
      for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {
        result += String.fromCharCode(
          this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i)
        );
      }
      return result;
    };
    flatbuffers.ByteBuffer.prototype.__offset = function(bb_pos, vtable_offset) {
      var vtable = bb_pos - this.readInt32(bb_pos);
      return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
    };
    flatbuffers.ByteBuffer.prototype.__union = function(t, offset) {
      t.bb_pos = offset + this.readInt32(offset);
      t.bb = this;
      return t;
    };
    flatbuffers.ByteBuffer.prototype.__string = function(offset, opt_encoding) {
      offset += this.readInt32(offset);
      var length = this.readInt32(offset);
      var result = "";
      var i = 0;
      offset += flatbuffers.SIZEOF_INT;
      if (opt_encoding === flatbuffers.Encoding.UTF8_BYTES) {
        return this.bytes_.subarray(offset, offset + length);
      }
      while (i < length) {
        var codePoint;
        var a = this.readUint8(offset + i++);
        if (a < 192) {
          codePoint = a;
        } else {
          var b = this.readUint8(offset + i++);
          if (a < 224) {
            codePoint = (a & 31) << 6 | b & 63;
          } else {
            var c = this.readUint8(offset + i++);
            if (a < 240) {
              codePoint = (a & 15) << 12 | (b & 63) << 6 | c & 63;
            } else {
              var d = this.readUint8(offset + i++);
              codePoint = (a & 7) << 18 | (b & 63) << 12 | (c & 63) << 6 | d & 63;
            }
          }
        }
        if (codePoint < 65536) {
          result += String.fromCharCode(codePoint);
        } else {
          codePoint -= 65536;
          result += String.fromCharCode(
            (codePoint >> 10) + 55296,
            (codePoint & (1 << 10) - 1) + 56320
          );
        }
      }
      return result;
    };
    flatbuffers.ByteBuffer.prototype.__indirect = function(offset) {
      return offset + this.readInt32(offset);
    };
    flatbuffers.ByteBuffer.prototype.__vector = function(offset) {
      return offset + this.readInt32(offset) + flatbuffers.SIZEOF_INT;
    };
    flatbuffers.ByteBuffer.prototype.__vector_len = function(offset) {
      return this.readInt32(offset + this.readInt32(offset));
    };
    flatbuffers.ByteBuffer.prototype.__has_identifier = function(ident) {
      if (ident.length != flatbuffers.FILE_IDENTIFIER_LENGTH) {
        throw new Error("FlatBuffers: file identifier must be length " + flatbuffers.FILE_IDENTIFIER_LENGTH);
      }
      for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {
        if (ident.charCodeAt(i) != this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i)) {
          return false;
        }
      }
      return true;
    };
    flatbuffers.ByteBuffer.prototype.createLong = function(low, high) {
      return flatbuffers.Long.create(low, high);
    };
  }
});

// web/lib/onnxjs/ort-schema/flatbuffers/ort-generated.ts
var onnxruntime;
var init_ort_generated = __esm({
  "web/lib/onnxjs/ort-schema/flatbuffers/ort-generated.ts"() {
    "use strict";
    init_flatbuffers();
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          let AttributeType;
          ((AttributeType2) => {
            AttributeType2[AttributeType2["UNDEFINED"] = 0] = "UNDEFINED";
            AttributeType2[AttributeType2["FLOAT"] = 1] = "FLOAT";
            AttributeType2[AttributeType2["INT"] = 2] = "INT";
            AttributeType2[AttributeType2["STRING"] = 3] = "STRING";
            AttributeType2[AttributeType2["TENSOR"] = 4] = "TENSOR";
            AttributeType2[AttributeType2["GRAPH"] = 5] = "GRAPH";
            AttributeType2[AttributeType2["FLOATS"] = 6] = "FLOATS";
            AttributeType2[AttributeType2["INTS"] = 7] = "INTS";
            AttributeType2[AttributeType2["STRINGS"] = 8] = "STRINGS";
            AttributeType2[AttributeType2["TENSORS"] = 9] = "TENSORS";
            AttributeType2[AttributeType2["GRAPHS"] = 10] = "GRAPHS";
            AttributeType2[AttributeType2["SPARSE_TENSOR"] = 11] = "SPARSE_TENSOR";
            AttributeType2[AttributeType2["SPARSE_TENSORS"] = 12] = "SPARSE_TENSORS";
          })(AttributeType = fbs2.AttributeType || (fbs2.AttributeType = {}));
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          let DimensionValueType;
          ((DimensionValueType2) => {
            DimensionValueType2[DimensionValueType2["UNKNOWN"] = 0] = "UNKNOWN";
            DimensionValueType2[DimensionValueType2["VALUE"] = 1] = "VALUE";
            DimensionValueType2[DimensionValueType2["PARAM"] = 2] = "PARAM";
          })(DimensionValueType = fbs2.DimensionValueType || (fbs2.DimensionValueType = {}));
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          let TensorDataType;
          ((TensorDataType2) => {
            TensorDataType2[TensorDataType2["UNDEFINED"] = 0] = "UNDEFINED";
            TensorDataType2[TensorDataType2["FLOAT"] = 1] = "FLOAT";
            TensorDataType2[TensorDataType2["UINT8"] = 2] = "UINT8";
            TensorDataType2[TensorDataType2["INT8"] = 3] = "INT8";
            TensorDataType2[TensorDataType2["UINT16"] = 4] = "UINT16";
            TensorDataType2[TensorDataType2["INT16"] = 5] = "INT16";
            TensorDataType2[TensorDataType2["INT32"] = 6] = "INT32";
            TensorDataType2[TensorDataType2["INT64"] = 7] = "INT64";
            TensorDataType2[TensorDataType2["STRING"] = 8] = "STRING";
            TensorDataType2[TensorDataType2["BOOL"] = 9] = "BOOL";
            TensorDataType2[TensorDataType2["FLOAT16"] = 10] = "FLOAT16";
            TensorDataType2[TensorDataType2["DOUBLE"] = 11] = "DOUBLE";
            TensorDataType2[TensorDataType2["UINT32"] = 12] = "UINT32";
            TensorDataType2[TensorDataType2["UINT64"] = 13] = "UINT64";
            TensorDataType2[TensorDataType2["COMPLEX64"] = 14] = "COMPLEX64";
            TensorDataType2[TensorDataType2["COMPLEX128"] = 15] = "COMPLEX128";
            TensorDataType2[TensorDataType2["BFLOAT16"] = 16] = "BFLOAT16";
            TensorDataType2[TensorDataType2["FLOAT8E4M3FN"] = 17] = "FLOAT8E4M3FN";
            TensorDataType2[TensorDataType2["FLOAT8E4M3FNUZ"] = 18] = "FLOAT8E4M3FNUZ";
            TensorDataType2[TensorDataType2["FLOAT8E5M2"] = 19] = "FLOAT8E5M2";
            TensorDataType2[TensorDataType2["FLOAT8E5M2FNUZ"] = 20] = "FLOAT8E5M2FNUZ";
          })(TensorDataType = fbs2.TensorDataType || (fbs2.TensorDataType = {}));
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          let NodeType;
          ((NodeType2) => {
            NodeType2[NodeType2["Primitive"] = 0] = "Primitive";
            NodeType2[NodeType2["Fused"] = 1] = "Fused";
          })(NodeType = fbs2.NodeType || (fbs2.NodeType = {}));
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          let TypeInfoValue;
          ((TypeInfoValue2) => {
            TypeInfoValue2[TypeInfoValue2["NONE"] = 0] = "NONE";
            TypeInfoValue2[TypeInfoValue2["tensor_type"] = 1] = "tensor_type";
            TypeInfoValue2[TypeInfoValue2["sequence_type"] = 2] = "sequence_type";
            TypeInfoValue2[TypeInfoValue2["map_type"] = 3] = "map_type";
          })(TypeInfoValue = fbs2.TypeInfoValue || (fbs2.TypeInfoValue = {}));
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class Shape {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns Shape
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Shape= obj
             * @returns Shape
             */
            static getRootAsShape(bb, obj) {
              return (obj || new Shape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Shape= obj
             * @returns Shape
             */
            static getSizePrefixedRootAsShape(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new Shape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param number index
             * @param onnxruntime.experimental.fbs.Dimension= obj
             * @returns onnxruntime.experimental.fbs.Dimension
             */
            dim(index, obj) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? (obj || new onnxruntime2.experimental.fbs.Dimension()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
            }
            /**
             * @returns number
             */
            dimLength() {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startShape(builder) {
              builder.startObject(1);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset dimOffset
             */
            static addDim(builder, dimOffset) {
              builder.addFieldOffset(0, dimOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createDimVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startDimVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endShape(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createShape(builder, dimOffset) {
              Shape.startShape(builder);
              Shape.addDim(builder, dimOffset);
              return Shape.endShape(builder);
            }
          }
          fbs2.Shape = Shape;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class Dimension {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns Dimension
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Dimension= obj
             * @returns Dimension
             */
            static getRootAsDimension(bb, obj) {
              return (obj || new Dimension()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Dimension= obj
             * @returns Dimension
             */
            static getSizePrefixedRootAsDimension(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new Dimension()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param onnxruntime.experimental.fbs.DimensionValue= obj
             * @returns onnxruntime.experimental.fbs.DimensionValue|null
             */
            value(obj) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? (obj || new onnxruntime2.experimental.fbs.DimensionValue()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            denotation(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startDimension(builder) {
              builder.startObject(2);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset valueOffset
             */
            static addValue(builder, valueOffset) {
              builder.addFieldOffset(0, valueOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset denotationOffset
             */
            static addDenotation(builder, denotationOffset) {
              builder.addFieldOffset(1, denotationOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endDimension(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createDimension(builder, valueOffset, denotationOffset) {
              Dimension.startDimension(builder);
              Dimension.addValue(builder, valueOffset);
              Dimension.addDenotation(builder, denotationOffset);
              return Dimension.endDimension(builder);
            }
          }
          fbs2.Dimension = Dimension;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class DimensionValue {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns DimensionValue
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param DimensionValue= obj
             * @returns DimensionValue
             */
            static getRootAsDimensionValue(bb, obj) {
              return (obj || new DimensionValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param DimensionValue= obj
             * @returns DimensionValue
             */
            static getSizePrefixedRootAsDimensionValue(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new DimensionValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @returns onnxruntime.experimental.fbs.DimensionValueType
             */
            dimType() {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? (
                /**  */
                this.bb.readInt8(this.bb_pos + offset)
              ) : 0 /* UNKNOWN */;
            }
            /**
             * @returns flatbuffers.Long
             */
            dimValue() {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
            }
            dimParam(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startDimensionValue(builder) {
              builder.startObject(3);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param onnxruntime.experimental.fbs.DimensionValueType dimType
             */
            static addDimType(builder, dimType) {
              builder.addFieldInt8(0, dimType, 0 /* UNKNOWN */);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Long dimValue
             */
            static addDimValue(builder, dimValue) {
              builder.addFieldInt64(1, dimValue, builder.createLong(0, 0));
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset dimParamOffset
             */
            static addDimParam(builder, dimParamOffset) {
              builder.addFieldOffset(2, dimParamOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endDimensionValue(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createDimensionValue(builder, dimType, dimValue, dimParamOffset) {
              DimensionValue.startDimensionValue(builder);
              DimensionValue.addDimType(builder, dimType);
              DimensionValue.addDimValue(builder, dimValue);
              DimensionValue.addDimParam(builder, dimParamOffset);
              return DimensionValue.endDimensionValue(builder);
            }
          }
          fbs2.DimensionValue = DimensionValue;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class TensorTypeAndShape {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns TensorTypeAndShape
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param TensorTypeAndShape= obj
             * @returns TensorTypeAndShape
             */
            static getRootAsTensorTypeAndShape(bb, obj) {
              return (obj || new TensorTypeAndShape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param TensorTypeAndShape= obj
             * @returns TensorTypeAndShape
             */
            static getSizePrefixedRootAsTensorTypeAndShape(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new TensorTypeAndShape()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @returns onnxruntime.experimental.fbs.TensorDataType
             */
            elemType() {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? (
                /**  */
                this.bb.readInt32(this.bb_pos + offset)
              ) : 0 /* UNDEFINED */;
            }
            /**
             * @param onnxruntime.experimental.fbs.Shape= obj
             * @returns onnxruntime.experimental.fbs.Shape|null
             */
            shape(obj) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? (obj || new onnxruntime2.experimental.fbs.Shape()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startTensorTypeAndShape(builder) {
              builder.startObject(2);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param onnxruntime.experimental.fbs.TensorDataType elemType
             */
            static addElemType(builder, elemType) {
              builder.addFieldInt32(0, elemType, 0 /* UNDEFINED */);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset shapeOffset
             */
            static addShape(builder, shapeOffset) {
              builder.addFieldOffset(1, shapeOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endTensorTypeAndShape(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createTensorTypeAndShape(builder, elemType, shapeOffset) {
              TensorTypeAndShape.startTensorTypeAndShape(builder);
              TensorTypeAndShape.addElemType(builder, elemType);
              TensorTypeAndShape.addShape(builder, shapeOffset);
              return TensorTypeAndShape.endTensorTypeAndShape(builder);
            }
          }
          fbs2.TensorTypeAndShape = TensorTypeAndShape;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class MapType {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns MapType
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param MapType= obj
             * @returns MapType
             */
            static getRootAsMapType(bb, obj) {
              return (obj || new MapType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param MapType= obj
             * @returns MapType
             */
            static getSizePrefixedRootAsMapType(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new MapType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @returns onnxruntime.experimental.fbs.TensorDataType
             */
            keyType() {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? (
                /**  */
                this.bb.readInt32(this.bb_pos + offset)
              ) : 0 /* UNDEFINED */;
            }
            /**
             * @param onnxruntime.experimental.fbs.TypeInfo= obj
             * @returns onnxruntime.experimental.fbs.TypeInfo|null
             */
            valueType(obj) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? (obj || new onnxruntime2.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startMapType(builder) {
              builder.startObject(2);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param onnxruntime.experimental.fbs.TensorDataType keyType
             */
            static addKeyType(builder, keyType) {
              builder.addFieldInt32(0, keyType, 0 /* UNDEFINED */);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset valueTypeOffset
             */
            static addValueType(builder, valueTypeOffset) {
              builder.addFieldOffset(1, valueTypeOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endMapType(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createMapType(builder, keyType, valueTypeOffset) {
              MapType.startMapType(builder);
              MapType.addKeyType(builder, keyType);
              MapType.addValueType(builder, valueTypeOffset);
              return MapType.endMapType(builder);
            }
          }
          fbs2.MapType = MapType;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class SequenceType {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns SequenceType
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param SequenceType= obj
             * @returns SequenceType
             */
            static getRootAsSequenceType(bb, obj) {
              return (obj || new SequenceType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param SequenceType= obj
             * @returns SequenceType
             */
            static getSizePrefixedRootAsSequenceType(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new SequenceType()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param onnxruntime.experimental.fbs.TypeInfo= obj
             * @returns onnxruntime.experimental.fbs.TypeInfo|null
             */
            elemType(obj) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? (obj || new onnxruntime2.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startSequenceType(builder) {
              builder.startObject(1);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset elemTypeOffset
             */
            static addElemType(builder, elemTypeOffset) {
              builder.addFieldOffset(0, elemTypeOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endSequenceType(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createSequenceType(builder, elemTypeOffset) {
              SequenceType.startSequenceType(builder);
              SequenceType.addElemType(builder, elemTypeOffset);
              return SequenceType.endSequenceType(builder);
            }
          }
          fbs2.SequenceType = SequenceType;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class EdgeEnd {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns EdgeEnd
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @returns number
             */
            nodeIndex() {
              return this.bb.readUint32(this.bb_pos);
            }
            /**
             * @returns number
             */
            srcArgIndex() {
              return this.bb.readInt32(this.bb_pos + 4);
            }
            /**
             * @returns number
             */
            dstArgIndex() {
              return this.bb.readInt32(this.bb_pos + 8);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number node_index
             * @param number src_arg_index
             * @param number dst_arg_index
             * @returns flatbuffers.Offset
             */
            static createEdgeEnd(builder, node_index, src_arg_index, dst_arg_index) {
              builder.prep(4, 12);
              builder.writeInt32(dst_arg_index);
              builder.writeInt32(src_arg_index);
              builder.writeInt32(node_index);
              return builder.offset();
            }
          }
          fbs2.EdgeEnd = EdgeEnd;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class NodeEdge {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns NodeEdge
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param NodeEdge= obj
             * @returns NodeEdge
             */
            static getRootAsNodeEdge(bb, obj) {
              return (obj || new NodeEdge()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param NodeEdge= obj
             * @returns NodeEdge
             */
            static getSizePrefixedRootAsNodeEdge(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new NodeEdge()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @returns number
             */
            nodeIndex() {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
            }
            /**
             * @param number index
             * @param onnxruntime.experimental.fbs.EdgeEnd= obj
             * @returns onnxruntime.experimental.fbs.EdgeEnd
             */
            inputEdges(index, obj) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? (obj || new onnxruntime2.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + offset) + index * 12, this.bb) : null;
            }
            /**
             * @returns number
             */
            inputEdgesLength() {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param number index
             * @param onnxruntime.experimental.fbs.EdgeEnd= obj
             * @returns onnxruntime.experimental.fbs.EdgeEnd
             */
            outputEdges(index, obj) {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? (obj || new onnxruntime2.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + offset) + index * 12, this.bb) : null;
            }
            /**
             * @returns number
             */
            outputEdgesLength() {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startNodeEdge(builder) {
              builder.startObject(3);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number nodeIndex
             */
            static addNodeIndex(builder, nodeIndex) {
              builder.addFieldInt32(0, nodeIndex, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset inputEdgesOffset
             */
            static addInputEdges(builder, inputEdgesOffset) {
              builder.addFieldOffset(1, inputEdgesOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startInputEdgesVector(builder, numElems) {
              builder.startVector(12, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset outputEdgesOffset
             */
            static addOutputEdges(builder, outputEdgesOffset) {
              builder.addFieldOffset(2, outputEdgesOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startOutputEdgesVector(builder, numElems) {
              builder.startVector(12, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endNodeEdge(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createNodeEdge(builder, nodeIndex, inputEdgesOffset, outputEdgesOffset) {
              NodeEdge.startNodeEdge(builder);
              NodeEdge.addNodeIndex(builder, nodeIndex);
              NodeEdge.addInputEdges(builder, inputEdgesOffset);
              NodeEdge.addOutputEdges(builder, outputEdgesOffset);
              return NodeEdge.endNodeEdge(builder);
            }
          }
          fbs2.NodeEdge = NodeEdge;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class Node2 {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns Node
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Node= obj
             * @returns Node
             */
            static getRootAsNode(bb, obj) {
              return (obj || new Node2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Node= obj
             * @returns Node
             */
            static getSizePrefixedRootAsNode(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new Node2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            name(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            docString(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            domain(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @returns number
             */
            sinceVersion() {
              let offset = this.bb.__offset(this.bb_pos, 10);
              return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
            }
            /**
             * @returns number
             */
            index() {
              let offset = this.bb.__offset(this.bb_pos, 12);
              return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
            }
            opType(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 14);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @returns onnxruntime.experimental.fbs.NodeType
             */
            type() {
              let offset = this.bb.__offset(this.bb_pos, 16);
              return offset ? (
                /**  */
                this.bb.readInt32(this.bb_pos + offset)
              ) : 0 /* Primitive */;
            }
            executionProviderType(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 18);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            inputs(index, optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 20);
              return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
            }
            /**
             * @returns number
             */
            inputsLength() {
              let offset = this.bb.__offset(this.bb_pos, 20);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            outputs(index, optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 22);
              return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
            }
            /**
             * @returns number
             */
            outputsLength() {
              let offset = this.bb.__offset(this.bb_pos, 22);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param number index
             * @param onnxruntime.experimental.fbs.Attribute= obj
             * @returns onnxruntime.experimental.fbs.Attribute
             */
            attributes(index, obj) {
              let offset = this.bb.__offset(this.bb_pos, 24);
              return offset ? (obj || new onnxruntime2.experimental.fbs.Attribute()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
            }
            /**
             * @returns number
             */
            attributesLength() {
              let offset = this.bb.__offset(this.bb_pos, 24);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param number index
             * @returns number
             */
            inputArgCounts(index) {
              let offset = this.bb.__offset(this.bb_pos, 26);
              return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
            }
            /**
             * @returns number
             */
            inputArgCountsLength() {
              let offset = this.bb.__offset(this.bb_pos, 26);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @returns Int32Array
             */
            inputArgCountsArray() {
              let offset = this.bb.__offset(this.bb_pos, 26);
              return offset ? new Int32Array(
                this.bb.bytes().buffer,
                this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
                this.bb.__vector_len(this.bb_pos + offset)
              ) : null;
            }
            implicitInputs(index, optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 28);
              return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
            }
            /**
             * @returns number
             */
            implicitInputsLength() {
              let offset = this.bb.__offset(this.bb_pos, 28);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startNode(builder) {
              builder.startObject(13);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset nameOffset
             */
            static addName(builder, nameOffset) {
              builder.addFieldOffset(0, nameOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset docStringOffset
             */
            static addDocString(builder, docStringOffset) {
              builder.addFieldOffset(1, docStringOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset domainOffset
             */
            static addDomain(builder, domainOffset) {
              builder.addFieldOffset(2, domainOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number sinceVersion
             */
            static addSinceVersion(builder, sinceVersion) {
              builder.addFieldInt32(3, sinceVersion, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number index
             */
            static addIndex(builder, index) {
              builder.addFieldInt32(4, index, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset opTypeOffset
             */
            static addOpType(builder, opTypeOffset) {
              builder.addFieldOffset(5, opTypeOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param onnxruntime.experimental.fbs.NodeType type
             */
            static addType(builder, type) {
              builder.addFieldInt32(6, type, 0 /* Primitive */);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset executionProviderTypeOffset
             */
            static addExecutionProviderType(builder, executionProviderTypeOffset) {
              builder.addFieldOffset(7, executionProviderTypeOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset inputsOffset
             */
            static addInputs(builder, inputsOffset) {
              builder.addFieldOffset(8, inputsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createInputsVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startInputsVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset outputsOffset
             */
            static addOutputs(builder, outputsOffset) {
              builder.addFieldOffset(9, outputsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createOutputsVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startOutputsVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset attributesOffset
             */
            static addAttributes(builder, attributesOffset) {
              builder.addFieldOffset(10, attributesOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createAttributesVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startAttributesVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset inputArgCountsOffset
             */
            static addInputArgCounts(builder, inputArgCountsOffset) {
              builder.addFieldOffset(11, inputArgCountsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<number> data
             * @returns flatbuffers.Offset
             */
            static createInputArgCountsVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addInt32(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startInputArgCountsVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset implicitInputsOffset
             */
            static addImplicitInputs(builder, implicitInputsOffset) {
              builder.addFieldOffset(12, implicitInputsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createImplicitInputsVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startImplicitInputsVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endNode(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createNode(builder, nameOffset, docStringOffset, domainOffset, sinceVersion, index, opTypeOffset, type, executionProviderTypeOffset, inputsOffset, outputsOffset, attributesOffset, inputArgCountsOffset, implicitInputsOffset) {
              Node2.startNode(builder);
              Node2.addName(builder, nameOffset);
              Node2.addDocString(builder, docStringOffset);
              Node2.addDomain(builder, domainOffset);
              Node2.addSinceVersion(builder, sinceVersion);
              Node2.addIndex(builder, index);
              Node2.addOpType(builder, opTypeOffset);
              Node2.addType(builder, type);
              Node2.addExecutionProviderType(builder, executionProviderTypeOffset);
              Node2.addInputs(builder, inputsOffset);
              Node2.addOutputs(builder, outputsOffset);
              Node2.addAttributes(builder, attributesOffset);
              Node2.addInputArgCounts(builder, inputArgCountsOffset);
              Node2.addImplicitInputs(builder, implicitInputsOffset);
              return Node2.endNode(builder);
            }
          }
          fbs2.Node = Node2;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class ValueInfo {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns ValueInfo
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param ValueInfo= obj
             * @returns ValueInfo
             */
            static getRootAsValueInfo(bb, obj) {
              return (obj || new ValueInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param ValueInfo= obj
             * @returns ValueInfo
             */
            static getSizePrefixedRootAsValueInfo(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new ValueInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            name(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            docString(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @param onnxruntime.experimental.fbs.TypeInfo= obj
             * @returns onnxruntime.experimental.fbs.TypeInfo|null
             */
            type(obj) {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? (obj || new onnxruntime2.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startValueInfo(builder) {
              builder.startObject(3);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset nameOffset
             */
            static addName(builder, nameOffset) {
              builder.addFieldOffset(0, nameOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset docStringOffset
             */
            static addDocString(builder, docStringOffset) {
              builder.addFieldOffset(1, docStringOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset typeOffset
             */
            static addType(builder, typeOffset) {
              builder.addFieldOffset(2, typeOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endValueInfo(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createValueInfo(builder, nameOffset, docStringOffset, typeOffset) {
              ValueInfo.startValueInfo(builder);
              ValueInfo.addName(builder, nameOffset);
              ValueInfo.addDocString(builder, docStringOffset);
              ValueInfo.addType(builder, typeOffset);
              return ValueInfo.endValueInfo(builder);
            }
          }
          fbs2.ValueInfo = ValueInfo;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class TypeInfo {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns TypeInfo
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param TypeInfo= obj
             * @returns TypeInfo
             */
            static getRootAsTypeInfo(bb, obj) {
              return (obj || new TypeInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param TypeInfo= obj
             * @returns TypeInfo
             */
            static getSizePrefixedRootAsTypeInfo(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new TypeInfo()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            denotation(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @returns onnxruntime.experimental.fbs.TypeInfoValue
             */
            valueType() {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? (
                /**  */
                this.bb.readUint8(this.bb_pos + offset)
              ) : 0 /* NONE */;
            }
            /**
             * @param flatbuffers.Table obj
             * @returns ?flatbuffers.Table
             */
            value(obj) {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startTypeInfo(builder) {
              builder.startObject(3);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset denotationOffset
             */
            static addDenotation(builder, denotationOffset) {
              builder.addFieldOffset(0, denotationOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param onnxruntime.experimental.fbs.TypeInfoValue valueType
             */
            static addValueType(builder, valueType) {
              builder.addFieldInt8(1, valueType, 0 /* NONE */);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset valueOffset
             */
            static addValue(builder, valueOffset) {
              builder.addFieldOffset(2, valueOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endTypeInfo(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createTypeInfo(builder, denotationOffset, valueType, valueOffset) {
              TypeInfo.startTypeInfo(builder);
              TypeInfo.addDenotation(builder, denotationOffset);
              TypeInfo.addValueType(builder, valueType);
              TypeInfo.addValue(builder, valueOffset);
              return TypeInfo.endTypeInfo(builder);
            }
          }
          fbs2.TypeInfo = TypeInfo;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class OperatorSetId {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns OperatorSetId
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param OperatorSetId= obj
             * @returns OperatorSetId
             */
            static getRootAsOperatorSetId(bb, obj) {
              return (obj || new OperatorSetId()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param OperatorSetId= obj
             * @returns OperatorSetId
             */
            static getSizePrefixedRootAsOperatorSetId(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new OperatorSetId()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            domain(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @returns flatbuffers.Long
             */
            version() {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startOperatorSetId(builder) {
              builder.startObject(2);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset domainOffset
             */
            static addDomain(builder, domainOffset) {
              builder.addFieldOffset(0, domainOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Long version
             */
            static addVersion(builder, version3) {
              builder.addFieldInt64(1, version3, builder.createLong(0, 0));
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endOperatorSetId(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createOperatorSetId(builder, domainOffset, version3) {
              OperatorSetId.startOperatorSetId(builder);
              OperatorSetId.addDomain(builder, domainOffset);
              OperatorSetId.addVersion(builder, version3);
              return OperatorSetId.endOperatorSetId(builder);
            }
          }
          fbs2.OperatorSetId = OperatorSetId;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class Tensor4 {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns Tensor
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Tensor= obj
             * @returns Tensor
             */
            static getRootAsTensor(bb, obj) {
              return (obj || new Tensor4()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Tensor= obj
             * @returns Tensor
             */
            static getSizePrefixedRootAsTensor(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new Tensor4()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            name(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            docString(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @param number index
             * @returns flatbuffers.Long
             */
            dims(index) {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : this.bb.createLong(0, 0);
            }
            /**
             * @returns number
             */
            dimsLength() {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @returns onnxruntime.experimental.fbs.TensorDataType
             */
            dataType() {
              let offset = this.bb.__offset(this.bb_pos, 10);
              return offset ? (
                /**  */
                this.bb.readInt32(this.bb_pos + offset)
              ) : 0 /* UNDEFINED */;
            }
            /**
             * @param number index
             * @returns number
             */
            rawData(index) {
              let offset = this.bb.__offset(this.bb_pos, 12);
              return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
            }
            /**
             * @returns number
             */
            rawDataLength() {
              let offset = this.bb.__offset(this.bb_pos, 12);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @returns Uint8Array
             */
            rawDataArray() {
              let offset = this.bb.__offset(this.bb_pos, 12);
              return offset ? new Uint8Array(
                this.bb.bytes().buffer,
                this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
                this.bb.__vector_len(this.bb_pos + offset)
              ) : null;
            }
            stringData(index, optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 14);
              return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
            }
            /**
             * @returns number
             */
            stringDataLength() {
              let offset = this.bb.__offset(this.bb_pos, 14);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startTensor(builder) {
              builder.startObject(6);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset nameOffset
             */
            static addName(builder, nameOffset) {
              builder.addFieldOffset(0, nameOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset docStringOffset
             */
            static addDocString(builder, docStringOffset) {
              builder.addFieldOffset(1, docStringOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset dimsOffset
             */
            static addDims(builder, dimsOffset) {
              builder.addFieldOffset(2, dimsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Long> data
             * @returns flatbuffers.Offset
             */
            static createDimsVector(builder, data) {
              builder.startVector(8, data.length, 8);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addInt64(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startDimsVector(builder, numElems) {
              builder.startVector(8, numElems, 8);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param onnxruntime.experimental.fbs.TensorDataType dataType
             */
            static addDataType(builder, dataType) {
              builder.addFieldInt32(3, dataType, 0 /* UNDEFINED */);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset rawDataOffset
             */
            static addRawData(builder, rawDataOffset) {
              builder.addFieldOffset(4, rawDataOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<number> data
             * @returns flatbuffers.Offset
             */
            static createRawDataVector(builder, data) {
              builder.startVector(1, data.length, 1);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addInt8(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startRawDataVector(builder, numElems) {
              builder.startVector(1, numElems, 1);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset stringDataOffset
             */
            static addStringData(builder, stringDataOffset) {
              builder.addFieldOffset(5, stringDataOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createStringDataVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startStringDataVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endTensor(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createTensor(builder, nameOffset, docStringOffset, dimsOffset, dataType, rawDataOffset, stringDataOffset) {
              Tensor4.startTensor(builder);
              Tensor4.addName(builder, nameOffset);
              Tensor4.addDocString(builder, docStringOffset);
              Tensor4.addDims(builder, dimsOffset);
              Tensor4.addDataType(builder, dataType);
              Tensor4.addRawData(builder, rawDataOffset);
              Tensor4.addStringData(builder, stringDataOffset);
              return Tensor4.endTensor(builder);
            }
          }
          fbs2.Tensor = Tensor4;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class SparseTensor {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns SparseTensor
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param SparseTensor= obj
             * @returns SparseTensor
             */
            static getRootAsSparseTensor(bb, obj) {
              return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param SparseTensor= obj
             * @returns SparseTensor
             */
            static getSizePrefixedRootAsSparseTensor(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new SparseTensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param onnxruntime.experimental.fbs.Tensor= obj
             * @returns onnxruntime.experimental.fbs.Tensor|null
             */
            values(obj) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? (obj || new onnxruntime2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            /**
             * @param onnxruntime.experimental.fbs.Tensor= obj
             * @returns onnxruntime.experimental.fbs.Tensor|null
             */
            indices(obj) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? (obj || new onnxruntime2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            /**
             * @param number index
             * @returns flatbuffers.Long
             */
            dims(index) {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : this.bb.createLong(0, 0);
            }
            /**
             * @returns number
             */
            dimsLength() {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startSparseTensor(builder) {
              builder.startObject(3);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset valuesOffset
             */
            static addValues(builder, valuesOffset) {
              builder.addFieldOffset(0, valuesOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset indicesOffset
             */
            static addIndices(builder, indicesOffset) {
              builder.addFieldOffset(1, indicesOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset dimsOffset
             */
            static addDims(builder, dimsOffset) {
              builder.addFieldOffset(2, dimsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Long> data
             * @returns flatbuffers.Offset
             */
            static createDimsVector(builder, data) {
              builder.startVector(8, data.length, 8);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addInt64(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startDimsVector(builder, numElems) {
              builder.startVector(8, numElems, 8);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endSparseTensor(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createSparseTensor(builder, valuesOffset, indicesOffset, dimsOffset) {
              SparseTensor.startSparseTensor(builder);
              SparseTensor.addValues(builder, valuesOffset);
              SparseTensor.addIndices(builder, indicesOffset);
              SparseTensor.addDims(builder, dimsOffset);
              return SparseTensor.endSparseTensor(builder);
            }
          }
          fbs2.SparseTensor = SparseTensor;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class Attribute2 {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns Attribute
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Attribute= obj
             * @returns Attribute
             */
            static getRootAsAttribute(bb, obj) {
              return (obj || new Attribute2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Attribute= obj
             * @returns Attribute
             */
            static getSizePrefixedRootAsAttribute(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new Attribute2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            name(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            docString(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @returns onnxruntime.experimental.fbs.AttributeType
             */
            type() {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? (
                /**  */
                this.bb.readInt32(this.bb_pos + offset)
              ) : 0 /* UNDEFINED */;
            }
            /**
             * @returns number
             */
            f() {
              let offset = this.bb.__offset(this.bb_pos, 10);
              return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0;
            }
            /**
             * @returns flatbuffers.Long
             */
            i() {
              let offset = this.bb.__offset(this.bb_pos, 12);
              return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
            }
            s(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 14);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @param onnxruntime.experimental.fbs.Tensor= obj
             * @returns onnxruntime.experimental.fbs.Tensor|null
             */
            t(obj) {
              let offset = this.bb.__offset(this.bb_pos, 16);
              return offset ? (obj || new onnxruntime2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            /**
             * @param onnxruntime.experimental.fbs.Graph= obj
             * @returns onnxruntime.experimental.fbs.Graph|null
             */
            g(obj) {
              let offset = this.bb.__offset(this.bb_pos, 18);
              return offset ? (obj || new onnxruntime2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            /**
             * @param number index
             * @returns number
             */
            floats(index) {
              let offset = this.bb.__offset(this.bb_pos, 20);
              return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
            }
            /**
             * @returns number
             */
            floatsLength() {
              let offset = this.bb.__offset(this.bb_pos, 20);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @returns Float32Array
             */
            floatsArray() {
              let offset = this.bb.__offset(this.bb_pos, 20);
              return offset ? new Float32Array(
                this.bb.bytes().buffer,
                this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
                this.bb.__vector_len(this.bb_pos + offset)
              ) : null;
            }
            /**
             * @param number index
             * @returns flatbuffers.Long
             */
            ints(index) {
              let offset = this.bb.__offset(this.bb_pos, 22);
              return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : this.bb.createLong(0, 0);
            }
            /**
             * @returns number
             */
            intsLength() {
              let offset = this.bb.__offset(this.bb_pos, 22);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            strings(index, optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 24);
              return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
            }
            /**
             * @returns number
             */
            stringsLength() {
              let offset = this.bb.__offset(this.bb_pos, 24);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param number index
             * @param onnxruntime.experimental.fbs.Tensor= obj
             * @returns onnxruntime.experimental.fbs.Tensor
             */
            tensors(index, obj) {
              let offset = this.bb.__offset(this.bb_pos, 26);
              return offset ? (obj || new onnxruntime2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
            }
            /**
             * @returns number
             */
            tensorsLength() {
              let offset = this.bb.__offset(this.bb_pos, 26);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param number index
             * @param onnxruntime.experimental.fbs.Graph= obj
             * @returns onnxruntime.experimental.fbs.Graph
             */
            graphs(index, obj) {
              let offset = this.bb.__offset(this.bb_pos, 28);
              return offset ? (obj || new onnxruntime2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
            }
            /**
             * @returns number
             */
            graphsLength() {
              let offset = this.bb.__offset(this.bb_pos, 28);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startAttribute(builder) {
              builder.startObject(13);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset nameOffset
             */
            static addName(builder, nameOffset) {
              builder.addFieldOffset(0, nameOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset docStringOffset
             */
            static addDocString(builder, docStringOffset) {
              builder.addFieldOffset(1, docStringOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param onnxruntime.experimental.fbs.AttributeType type
             */
            static addType(builder, type) {
              builder.addFieldInt32(2, type, 0 /* UNDEFINED */);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number f
             */
            static addF(builder, f) {
              builder.addFieldFloat32(3, f, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Long i
             */
            static addI(builder, i) {
              builder.addFieldInt64(4, i, builder.createLong(0, 0));
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset sOffset
             */
            static addS(builder, sOffset) {
              builder.addFieldOffset(5, sOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset tOffset
             */
            static addT(builder, tOffset) {
              builder.addFieldOffset(6, tOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset gOffset
             */
            static addG(builder, gOffset) {
              builder.addFieldOffset(7, gOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset floatsOffset
             */
            static addFloats(builder, floatsOffset) {
              builder.addFieldOffset(8, floatsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<number> data
             * @returns flatbuffers.Offset
             */
            static createFloatsVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addFloat32(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startFloatsVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset intsOffset
             */
            static addInts(builder, intsOffset) {
              builder.addFieldOffset(9, intsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Long> data
             * @returns flatbuffers.Offset
             */
            static createIntsVector(builder, data) {
              builder.startVector(8, data.length, 8);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addInt64(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startIntsVector(builder, numElems) {
              builder.startVector(8, numElems, 8);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset stringsOffset
             */
            static addStrings(builder, stringsOffset) {
              builder.addFieldOffset(10, stringsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createStringsVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startStringsVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset tensorsOffset
             */
            static addTensors(builder, tensorsOffset) {
              builder.addFieldOffset(11, tensorsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createTensorsVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startTensorsVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset graphsOffset
             */
            static addGraphs(builder, graphsOffset) {
              builder.addFieldOffset(12, graphsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createGraphsVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startGraphsVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endAttribute(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createAttribute(builder, nameOffset, docStringOffset, type, f, i, sOffset, tOffset, gOffset, floatsOffset, intsOffset, stringsOffset, tensorsOffset, graphsOffset) {
              Attribute2.startAttribute(builder);
              Attribute2.addName(builder, nameOffset);
              Attribute2.addDocString(builder, docStringOffset);
              Attribute2.addType(builder, type);
              Attribute2.addF(builder, f);
              Attribute2.addI(builder, i);
              Attribute2.addS(builder, sOffset);
              Attribute2.addT(builder, tOffset);
              Attribute2.addG(builder, gOffset);
              Attribute2.addFloats(builder, floatsOffset);
              Attribute2.addInts(builder, intsOffset);
              Attribute2.addStrings(builder, stringsOffset);
              Attribute2.addTensors(builder, tensorsOffset);
              Attribute2.addGraphs(builder, graphsOffset);
              return Attribute2.endAttribute(builder);
            }
          }
          fbs2.Attribute = Attribute2;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class Graph2 {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns Graph
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Graph= obj
             * @returns Graph
             */
            static getRootAsGraph(bb, obj) {
              return (obj || new Graph2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Graph= obj
             * @returns Graph
             */
            static getSizePrefixedRootAsGraph(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new Graph2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param number index
             * @param onnxruntime.experimental.fbs.Tensor= obj
             * @returns onnxruntime.experimental.fbs.Tensor
             */
            initializers(index, obj) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? (obj || new onnxruntime2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
            }
            /**
             * @returns number
             */
            initializersLength() {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param number index
             * @param onnxruntime.experimental.fbs.ValueInfo= obj
             * @returns onnxruntime.experimental.fbs.ValueInfo
             */
            nodeArgs(index, obj) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? (obj || new onnxruntime2.experimental.fbs.ValueInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
            }
            /**
             * @returns number
             */
            nodeArgsLength() {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param number index
             * @param onnxruntime.experimental.fbs.Node= obj
             * @returns onnxruntime.experimental.fbs.Node
             */
            nodes(index, obj) {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? (obj || new onnxruntime2.experimental.fbs.Node()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
            }
            /**
             * @returns number
             */
            nodesLength() {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @returns number
             */
            maxNodeIndex() {
              let offset = this.bb.__offset(this.bb_pos, 10);
              return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
            }
            /**
             * @param number index
             * @param onnxruntime.experimental.fbs.NodeEdge= obj
             * @returns onnxruntime.experimental.fbs.NodeEdge
             */
            nodeEdges(index, obj) {
              let offset = this.bb.__offset(this.bb_pos, 12);
              return offset ? (obj || new onnxruntime2.experimental.fbs.NodeEdge()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
            }
            /**
             * @returns number
             */
            nodeEdgesLength() {
              let offset = this.bb.__offset(this.bb_pos, 12);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            inputs(index, optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 14);
              return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
            }
            /**
             * @returns number
             */
            inputsLength() {
              let offset = this.bb.__offset(this.bb_pos, 14);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            outputs(index, optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 16);
              return offset ? this.bb.__string(this.bb.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
            }
            /**
             * @returns number
             */
            outputsLength() {
              let offset = this.bb.__offset(this.bb_pos, 16);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param number index
             * @param onnxruntime.experimental.fbs.SparseTensor= obj
             * @returns onnxruntime.experimental.fbs.SparseTensor
             */
            sparseInitializers(index, obj) {
              let offset = this.bb.__offset(this.bb_pos, 18);
              return offset ? (obj || new onnxruntime2.experimental.fbs.SparseTensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
            }
            /**
             * @returns number
             */
            sparseInitializersLength() {
              let offset = this.bb.__offset(this.bb_pos, 18);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startGraph(builder) {
              builder.startObject(8);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset initializersOffset
             */
            static addInitializers(builder, initializersOffset) {
              builder.addFieldOffset(0, initializersOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createInitializersVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startInitializersVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset nodeArgsOffset
             */
            static addNodeArgs(builder, nodeArgsOffset) {
              builder.addFieldOffset(1, nodeArgsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createNodeArgsVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startNodeArgsVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset nodesOffset
             */
            static addNodes(builder, nodesOffset) {
              builder.addFieldOffset(2, nodesOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createNodesVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startNodesVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number maxNodeIndex
             */
            static addMaxNodeIndex(builder, maxNodeIndex) {
              builder.addFieldInt32(3, maxNodeIndex, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset nodeEdgesOffset
             */
            static addNodeEdges(builder, nodeEdgesOffset) {
              builder.addFieldOffset(4, nodeEdgesOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createNodeEdgesVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startNodeEdgesVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset inputsOffset
             */
            static addInputs(builder, inputsOffset) {
              builder.addFieldOffset(5, inputsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createInputsVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startInputsVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset outputsOffset
             */
            static addOutputs(builder, outputsOffset) {
              builder.addFieldOffset(6, outputsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createOutputsVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startOutputsVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset sparseInitializersOffset
             */
            static addSparseInitializers(builder, sparseInitializersOffset) {
              builder.addFieldOffset(7, sparseInitializersOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createSparseInitializersVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startSparseInitializersVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endGraph(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createGraph(builder, initializersOffset, nodeArgsOffset, nodesOffset, maxNodeIndex, nodeEdgesOffset, inputsOffset, outputsOffset, sparseInitializersOffset) {
              Graph2.startGraph(builder);
              Graph2.addInitializers(builder, initializersOffset);
              Graph2.addNodeArgs(builder, nodeArgsOffset);
              Graph2.addNodes(builder, nodesOffset);
              Graph2.addMaxNodeIndex(builder, maxNodeIndex);
              Graph2.addNodeEdges(builder, nodeEdgesOffset);
              Graph2.addInputs(builder, inputsOffset);
              Graph2.addOutputs(builder, outputsOffset);
              Graph2.addSparseInitializers(builder, sparseInitializersOffset);
              return Graph2.endGraph(builder);
            }
          }
          fbs2.Graph = Graph2;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class Model2 {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns Model
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Model= obj
             * @returns Model
             */
            static getRootAsModel(bb, obj) {
              return (obj || new Model2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param Model= obj
             * @returns Model
             */
            static getSizePrefixedRootAsModel(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new Model2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @returns flatbuffers.Long
             */
            irVersion() {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
            }
            /**
             * @param number index
             * @param onnxruntime.experimental.fbs.OperatorSetId= obj
             * @returns onnxruntime.experimental.fbs.OperatorSetId
             */
            opsetImport(index, obj) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? (obj || new onnxruntime2.experimental.fbs.OperatorSetId()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
            }
            /**
             * @returns number
             */
            opsetImportLength() {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            producerName(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            producerVersion(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 10);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            domain(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 12);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @returns flatbuffers.Long
             */
            modelVersion() {
              let offset = this.bb.__offset(this.bb_pos, 14);
              return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
            }
            docString(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 16);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @param onnxruntime.experimental.fbs.Graph= obj
             * @returns onnxruntime.experimental.fbs.Graph|null
             */
            graph(obj) {
              let offset = this.bb.__offset(this.bb_pos, 18);
              return offset ? (obj || new onnxruntime2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            graphDocString(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 20);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startModel(builder) {
              builder.startObject(9);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Long irVersion
             */
            static addIrVersion(builder, irVersion) {
              builder.addFieldInt64(0, irVersion, builder.createLong(0, 0));
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset opsetImportOffset
             */
            static addOpsetImport(builder, opsetImportOffset) {
              builder.addFieldOffset(1, opsetImportOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createOpsetImportVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startOpsetImportVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset producerNameOffset
             */
            static addProducerName(builder, producerNameOffset) {
              builder.addFieldOffset(2, producerNameOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset producerVersionOffset
             */
            static addProducerVersion(builder, producerVersionOffset) {
              builder.addFieldOffset(3, producerVersionOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset domainOffset
             */
            static addDomain(builder, domainOffset) {
              builder.addFieldOffset(4, domainOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Long modelVersion
             */
            static addModelVersion(builder, modelVersion) {
              builder.addFieldInt64(5, modelVersion, builder.createLong(0, 0));
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset docStringOffset
             */
            static addDocString(builder, docStringOffset) {
              builder.addFieldOffset(6, docStringOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset graphOffset
             */
            static addGraph(builder, graphOffset) {
              builder.addFieldOffset(7, graphOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset graphDocStringOffset
             */
            static addGraphDocString(builder, graphDocStringOffset) {
              builder.addFieldOffset(8, graphDocStringOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endModel(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createModel(builder, irVersion, opsetImportOffset, producerNameOffset, producerVersionOffset, domainOffset, modelVersion, docStringOffset, graphOffset, graphDocStringOffset) {
              Model2.startModel(builder);
              Model2.addIrVersion(builder, irVersion);
              Model2.addOpsetImport(builder, opsetImportOffset);
              Model2.addProducerName(builder, producerNameOffset);
              Model2.addProducerVersion(builder, producerVersionOffset);
              Model2.addDomain(builder, domainOffset);
              Model2.addModelVersion(builder, modelVersion);
              Model2.addDocString(builder, docStringOffset);
              Model2.addGraph(builder, graphOffset);
              Model2.addGraphDocString(builder, graphDocStringOffset);
              return Model2.endModel(builder);
            }
          }
          fbs2.Model = Model2;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class KernelCreateInfos {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns KernelCreateInfos
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param KernelCreateInfos= obj
             * @returns KernelCreateInfos
             */
            static getRootAsKernelCreateInfos(bb, obj) {
              return (obj || new KernelCreateInfos()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param KernelCreateInfos= obj
             * @returns KernelCreateInfos
             */
            static getSizePrefixedRootAsKernelCreateInfos(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new KernelCreateInfos()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param number index
             * @returns number
             */
            nodeIndices(index) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.readUint32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
            }
            /**
             * @returns number
             */
            nodeIndicesLength() {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @returns Uint32Array
             */
            nodeIndicesArray() {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? new Uint32Array(
                this.bb.bytes().buffer,
                this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
                this.bb.__vector_len(this.bb_pos + offset)
              ) : null;
            }
            /**
             * @param number index
             * @returns flatbuffers.Long
             */
            kernelDefHashes(index) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? this.bb.readUint64(this.bb.__vector(this.bb_pos + offset) + index * 8) : this.bb.createLong(0, 0);
            }
            /**
             * @returns number
             */
            kernelDefHashesLength() {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startKernelCreateInfos(builder) {
              builder.startObject(2);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset nodeIndicesOffset
             */
            static addNodeIndices(builder, nodeIndicesOffset) {
              builder.addFieldOffset(0, nodeIndicesOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<number> data
             * @returns flatbuffers.Offset
             */
            static createNodeIndicesVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addInt32(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startNodeIndicesVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset kernelDefHashesOffset
             */
            static addKernelDefHashes(builder, kernelDefHashesOffset) {
              builder.addFieldOffset(1, kernelDefHashesOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Long> data
             * @returns flatbuffers.Offset
             */
            static createKernelDefHashesVector(builder, data) {
              builder.startVector(8, data.length, 8);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addInt64(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startKernelDefHashesVector(builder, numElems) {
              builder.startVector(8, numElems, 8);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endKernelCreateInfos(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createKernelCreateInfos(builder, nodeIndicesOffset, kernelDefHashesOffset) {
              KernelCreateInfos.startKernelCreateInfos(builder);
              KernelCreateInfos.addNodeIndices(builder, nodeIndicesOffset);
              KernelCreateInfos.addKernelDefHashes(builder, kernelDefHashesOffset);
              return KernelCreateInfos.endKernelCreateInfos(builder);
            }
          }
          fbs2.KernelCreateInfos = KernelCreateInfos;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class SubGraphSessionState {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns SubGraphSessionState
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param SubGraphSessionState= obj
             * @returns SubGraphSessionState
             */
            static getRootAsSubGraphSessionState(bb, obj) {
              return (obj || new SubGraphSessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param SubGraphSessionState= obj
             * @returns SubGraphSessionState
             */
            static getSizePrefixedRootAsSubGraphSessionState(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new SubGraphSessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            graphId(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @param onnxruntime.experimental.fbs.SessionState= obj
             * @returns onnxruntime.experimental.fbs.SessionState|null
             */
            sessionState(obj) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? (obj || new onnxruntime2.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startSubGraphSessionState(builder) {
              builder.startObject(2);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset graphIdOffset
             */
            static addGraphId(builder, graphIdOffset) {
              builder.addFieldOffset(0, graphIdOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset sessionStateOffset
             */
            static addSessionState(builder, sessionStateOffset) {
              builder.addFieldOffset(1, sessionStateOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endSubGraphSessionState(builder) {
              let offset = builder.endObject();
              builder.requiredField(offset, 4);
              return offset;
            }
            static createSubGraphSessionState(builder, graphIdOffset, sessionStateOffset) {
              SubGraphSessionState.startSubGraphSessionState(builder);
              SubGraphSessionState.addGraphId(builder, graphIdOffset);
              SubGraphSessionState.addSessionState(builder, sessionStateOffset);
              return SubGraphSessionState.endSubGraphSessionState(builder);
            }
          }
          fbs2.SubGraphSessionState = SubGraphSessionState;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class SessionState {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns SessionState
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param SessionState= obj
             * @returns SessionState
             */
            static getRootAsSessionState(bb, obj) {
              return (obj || new SessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param SessionState= obj
             * @returns SessionState
             */
            static getSizePrefixedRootAsSessionState(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new SessionState()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param onnxruntime.experimental.fbs.KernelCreateInfos= obj
             * @returns onnxruntime.experimental.fbs.KernelCreateInfos|null
             */
            kernels(obj) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? (obj || new onnxruntime2.experimental.fbs.KernelCreateInfos()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            /**
             * @param number index
             * @param onnxruntime.experimental.fbs.SubGraphSessionState= obj
             * @returns onnxruntime.experimental.fbs.SubGraphSessionState
             */
            subGraphSessionStates(index, obj) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? (obj || new onnxruntime2.experimental.fbs.SubGraphSessionState()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
            }
            /**
             * @returns number
             */
            subGraphSessionStatesLength() {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startSessionState(builder) {
              builder.startObject(2);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset kernelsOffset
             */
            static addKernels(builder, kernelsOffset) {
              builder.addFieldOffset(0, kernelsOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset subGraphSessionStatesOffset
             */
            static addSubGraphSessionStates(builder, subGraphSessionStatesOffset) {
              builder.addFieldOffset(1, subGraphSessionStatesOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param Array.<flatbuffers.Offset> data
             * @returns flatbuffers.Offset
             */
            static createSubGraphSessionStatesVector(builder, data) {
              builder.startVector(4, data.length, 4);
              for (let i = data.length - 1; i >= 0; i--) {
                builder.addOffset(data[i]);
              }
              return builder.endVector();
            }
            /**
             * @param flatbuffers.Builder builder
             * @param number numElems
             */
            static startSubGraphSessionStatesVector(builder, numElems) {
              builder.startVector(4, numElems, 4);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endSessionState(builder) {
              let offset = builder.endObject();
              return offset;
            }
            static createSessionState(builder, kernelsOffset, subGraphSessionStatesOffset) {
              SessionState.startSessionState(builder);
              SessionState.addKernels(builder, kernelsOffset);
              SessionState.addSubGraphSessionStates(builder, subGraphSessionStatesOffset);
              return SessionState.endSessionState(builder);
            }
          }
          fbs2.SessionState = SessionState;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
    ((onnxruntime2) => {
      let experimental;
      ((experimental2) => {
        let fbs;
        ((fbs2) => {
          class InferenceSession7 {
            constructor() {
              this.bb = null;
              this.bb_pos = 0;
            }
            /**
             * @param number i
             * @param flatbuffers.ByteBuffer bb
             * @returns InferenceSession
             */
            __init(i, bb) {
              this.bb_pos = i;
              this.bb = bb;
              return this;
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param InferenceSession= obj
             * @returns InferenceSession
             */
            static getRootAsInferenceSession(bb, obj) {
              return (obj || new InferenceSession7()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @param InferenceSession= obj
             * @returns InferenceSession
             */
            static getSizePrefixedRootAsInferenceSession(bb, obj) {
              bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
              return (obj || new InferenceSession7()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
            }
            /**
             * @param flatbuffers.ByteBuffer bb
             * @returns boolean
             */
            static bufferHasIdentifier(bb) {
              return bb.__has_identifier("ORTM");
            }
            ortVersion(optionalEncoding) {
              let offset = this.bb.__offset(this.bb_pos, 4);
              return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
            }
            /**
             * @param onnxruntime.experimental.fbs.Model= obj
             * @returns onnxruntime.experimental.fbs.Model|null
             */
            model(obj) {
              let offset = this.bb.__offset(this.bb_pos, 6);
              return offset ? (obj || new onnxruntime2.experimental.fbs.Model()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            /**
             * @param onnxruntime.experimental.fbs.SessionState= obj
             * @returns onnxruntime.experimental.fbs.SessionState|null
             */
            sessionState(obj) {
              let offset = this.bb.__offset(this.bb_pos, 8);
              return offset ? (obj || new onnxruntime2.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
            }
            /**
             * @param flatbuffers.Builder builder
             */
            static startInferenceSession(builder) {
              builder.startObject(3);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset ortVersionOffset
             */
            static addOrtVersion(builder, ortVersionOffset) {
              builder.addFieldOffset(0, ortVersionOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset modelOffset
             */
            static addModel(builder, modelOffset) {
              builder.addFieldOffset(1, modelOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset sessionStateOffset
             */
            static addSessionState(builder, sessionStateOffset) {
              builder.addFieldOffset(2, sessionStateOffset, 0);
            }
            /**
             * @param flatbuffers.Builder builder
             * @returns flatbuffers.Offset
             */
            static endInferenceSession(builder) {
              let offset = builder.endObject();
              return offset;
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset offset
             */
            static finishInferenceSessionBuffer(builder, offset) {
              builder.finish(offset, "ORTM");
            }
            /**
             * @param flatbuffers.Builder builder
             * @param flatbuffers.Offset offset
             */
            static finishSizePrefixedInferenceSessionBuffer(builder, offset) {
              builder.finish(offset, "ORTM", true);
            }
            static createInferenceSession(builder, ortVersionOffset, modelOffset, sessionStateOffset) {
              InferenceSession7.startInferenceSession(builder);
              InferenceSession7.addOrtVersion(builder, ortVersionOffset);
              InferenceSession7.addModel(builder, modelOffset);
              InferenceSession7.addSessionState(builder, sessionStateOffset);
              return InferenceSession7.endInferenceSession(builder);
            }
          }
          fbs2.InferenceSession = InferenceSession7;
        })(fbs = experimental2.fbs || (experimental2.fbs = {}));
      })(experimental = onnxruntime2.experimental || (onnxruntime2.experimental = {}));
    })(onnxruntime || (onnxruntime = {}));
  }
});

// web/node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "web/node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// web/node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "web/node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base64 = exports2;
    base64.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function encode(buffer, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode(string, buffer, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// web/node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "web/node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// web/node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "web/node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// web/node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "web/node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// web/node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "web/node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// web/node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "web/node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc, slice2, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice2.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// web/node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "web/node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber2(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber2(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// web/node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "web/node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name2) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: function get() {
            return name2;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value: function value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name2) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name2)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// web/node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "web/node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create();
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
    };
  }
});

// web/node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "web/node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// web/node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "web/node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      if (start === end) {
        var nativeBuffer = util.Buffer;
        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
      }
      return this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// web/node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "web/node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// web/node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "web/node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// web/node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "web/node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// web/node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "web/node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// web/node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "web/node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// web/node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "web/node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// web/lib/onnxjs/ort-schema/protobuf/onnx.js
var require_onnx = __commonJS({
  "web/lib/onnxjs/ort-schema/protobuf/onnx.js"(exports2, module2) {
    "use strict";
    var $protobuf = require_minimal2();
    var $Reader = $protobuf.Reader;
    var $Writer = $protobuf.Writer;
    var $util = $protobuf.util;
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    $root.onnx = function() {
      var onnx6 = {};
      onnx6.Version = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "_START_VERSION"] = 0;
        values[valuesById[1] = "IR_VERSION_2017_10_10"] = 1;
        values[valuesById[2] = "IR_VERSION_2017_10_30"] = 2;
        values[valuesById[3] = "IR_VERSION_2017_11_3"] = 3;
        values[valuesById[4] = "IR_VERSION_2019_1_22"] = 4;
        values[valuesById[5] = "IR_VERSION_2019_3_18"] = 5;
        values[valuesById[6] = "IR_VERSION_2019_9_19"] = 6;
        values[valuesById[7] = "IR_VERSION_2020_5_8"] = 7;
        values[valuesById[8] = "IR_VERSION_2021_7_30"] = 8;
        values[valuesById[9] = "IR_VERSION"] = 9;
        return values;
      }();
      onnx6.AttributeProto = function() {
        function AttributeProto(properties) {
          this.floats = [];
          this.ints = [];
          this.strings = [];
          this.tensors = [];
          this.graphs = [];
          this.sparseTensors = [];
          this.typeProtos = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        AttributeProto.prototype.name = "";
        AttributeProto.prototype.refAttrName = "";
        AttributeProto.prototype.docString = "";
        AttributeProto.prototype.type = 0;
        AttributeProto.prototype.f = 0;
        AttributeProto.prototype.i = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        AttributeProto.prototype.s = $util.newBuffer([]);
        AttributeProto.prototype.t = null;
        AttributeProto.prototype.g = null;
        AttributeProto.prototype.sparseTensor = null;
        AttributeProto.prototype.tp = null;
        AttributeProto.prototype.floats = $util.emptyArray;
        AttributeProto.prototype.ints = $util.emptyArray;
        AttributeProto.prototype.strings = $util.emptyArray;
        AttributeProto.prototype.tensors = $util.emptyArray;
        AttributeProto.prototype.graphs = $util.emptyArray;
        AttributeProto.prototype.sparseTensors = $util.emptyArray;
        AttributeProto.prototype.typeProtos = $util.emptyArray;
        AttributeProto.create = function create(properties) {
          return new AttributeProto(properties);
        };
        AttributeProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.name);
          if (message.f != null && Object.hasOwnProperty.call(message, "f"))
            writer.uint32(
              /* id 2, wireType 5 =*/
              21
            ).float(message.f);
          if (message.i != null && Object.hasOwnProperty.call(message, "i"))
            writer.uint32(
              /* id 3, wireType 0 =*/
              24
            ).int64(message.i);
          if (message.s != null && Object.hasOwnProperty.call(message, "s"))
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).bytes(message.s);
          if (message.t != null && Object.hasOwnProperty.call(message, "t"))
            $root.onnx.TensorProto.encode(message.t, writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork()).ldelim();
          if (message.g != null && Object.hasOwnProperty.call(message, "g"))
            $root.onnx.GraphProto.encode(message.g, writer.uint32(
              /* id 6, wireType 2 =*/
              50
            ).fork()).ldelim();
          if (message.floats != null && message.floats.length) {
            writer.uint32(
              /* id 7, wireType 2 =*/
              58
            ).fork();
            for (var i = 0; i < message.floats.length; ++i)
              writer.float(message.floats[i]);
            writer.ldelim();
          }
          if (message.ints != null && message.ints.length) {
            writer.uint32(
              /* id 8, wireType 2 =*/
              66
            ).fork();
            for (var i = 0; i < message.ints.length; ++i)
              writer.int64(message.ints[i]);
            writer.ldelim();
          }
          if (message.strings != null && message.strings.length)
            for (var i = 0; i < message.strings.length; ++i)
              writer.uint32(
                /* id 9, wireType 2 =*/
                74
              ).bytes(message.strings[i]);
          if (message.tensors != null && message.tensors.length)
            for (var i = 0; i < message.tensors.length; ++i)
              $root.onnx.TensorProto.encode(message.tensors[i], writer.uint32(
                /* id 10, wireType 2 =*/
                82
              ).fork()).ldelim();
          if (message.graphs != null && message.graphs.length)
            for (var i = 0; i < message.graphs.length; ++i)
              $root.onnx.GraphProto.encode(message.graphs[i], writer.uint32(
                /* id 11, wireType 2 =*/
                90
              ).fork()).ldelim();
          if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
            writer.uint32(
              /* id 13, wireType 2 =*/
              106
            ).string(message.docString);
          if (message.tp != null && Object.hasOwnProperty.call(message, "tp"))
            $root.onnx.TypeProto.encode(message.tp, writer.uint32(
              /* id 14, wireType 2 =*/
              114
            ).fork()).ldelim();
          if (message.typeProtos != null && message.typeProtos.length)
            for (var i = 0; i < message.typeProtos.length; ++i)
              $root.onnx.TypeProto.encode(message.typeProtos[i], writer.uint32(
                /* id 15, wireType 2 =*/
                122
              ).fork()).ldelim();
          if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            writer.uint32(
              /* id 20, wireType 0 =*/
              160
            ).int32(message.type);
          if (message.refAttrName != null && Object.hasOwnProperty.call(message, "refAttrName"))
            writer.uint32(
              /* id 21, wireType 2 =*/
              170
            ).string(message.refAttrName);
          if (message.sparseTensor != null && Object.hasOwnProperty.call(message, "sparseTensor"))
            $root.onnx.SparseTensorProto.encode(message.sparseTensor, writer.uint32(
              /* id 22, wireType 2 =*/
              178
            ).fork()).ldelim();
          if (message.sparseTensors != null && message.sparseTensors.length)
            for (var i = 0; i < message.sparseTensors.length; ++i)
              $root.onnx.SparseTensorProto.encode(message.sparseTensors[i], writer.uint32(
                /* id 23, wireType 2 =*/
                186
              ).fork()).ldelim();
          return writer;
        };
        AttributeProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        AttributeProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.AttributeProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.name = reader.string();
                break;
              }
              case 21: {
                message.refAttrName = reader.string();
                break;
              }
              case 13: {
                message.docString = reader.string();
                break;
              }
              case 20: {
                message.type = reader.int32();
                break;
              }
              case 2: {
                message.f = reader.float();
                break;
              }
              case 3: {
                message.i = reader.int64();
                break;
              }
              case 4: {
                message.s = reader.bytes();
                break;
              }
              case 5: {
                message.t = $root.onnx.TensorProto.decode(reader, reader.uint32());
                break;
              }
              case 6: {
                message.g = $root.onnx.GraphProto.decode(reader, reader.uint32());
                break;
              }
              case 22: {
                message.sparseTensor = $root.onnx.SparseTensorProto.decode(reader, reader.uint32());
                break;
              }
              case 14: {
                message.tp = $root.onnx.TypeProto.decode(reader, reader.uint32());
                break;
              }
              case 7: {
                if (!(message.floats && message.floats.length))
                  message.floats = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.floats.push(reader.float());
                } else
                  message.floats.push(reader.float());
                break;
              }
              case 8: {
                if (!(message.ints && message.ints.length))
                  message.ints = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.ints.push(reader.int64());
                } else
                  message.ints.push(reader.int64());
                break;
              }
              case 9: {
                if (!(message.strings && message.strings.length))
                  message.strings = [];
                message.strings.push(reader.bytes());
                break;
              }
              case 10: {
                if (!(message.tensors && message.tensors.length))
                  message.tensors = [];
                message.tensors.push($root.onnx.TensorProto.decode(reader, reader.uint32()));
                break;
              }
              case 11: {
                if (!(message.graphs && message.graphs.length))
                  message.graphs = [];
                message.graphs.push($root.onnx.GraphProto.decode(reader, reader.uint32()));
                break;
              }
              case 23: {
                if (!(message.sparseTensors && message.sparseTensors.length))
                  message.sparseTensors = [];
                message.sparseTensors.push($root.onnx.SparseTensorProto.decode(reader, reader.uint32()));
                break;
              }
              case 15: {
                if (!(message.typeProtos && message.typeProtos.length))
                  message.typeProtos = [];
                message.typeProtos.push($root.onnx.TypeProto.decode(reader, reader.uint32()));
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        AttributeProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        AttributeProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.name != null && message.hasOwnProperty("name")) {
            if (!$util.isString(message.name))
              return "name: string expected";
          }
          if (message.refAttrName != null && message.hasOwnProperty("refAttrName")) {
            if (!$util.isString(message.refAttrName))
              return "refAttrName: string expected";
          }
          if (message.docString != null && message.hasOwnProperty("docString")) {
            if (!$util.isString(message.docString))
              return "docString: string expected";
          }
          if (message.type != null && message.hasOwnProperty("type"))
            switch (message.type) {
              default:
                return "type: enum value expected";
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 11:
              case 13:
              case 6:
              case 7:
              case 8:
              case 9:
              case 10:
              case 12:
              case 14:
                break;
            }
          if (message.f != null && message.hasOwnProperty("f")) {
            if (typeof message.f !== "number")
              return "f: number expected";
          }
          if (message.i != null && message.hasOwnProperty("i")) {
            if (!$util.isInteger(message.i) && !(message.i && $util.isInteger(message.i.low) && $util.isInteger(message.i.high)))
              return "i: integer|Long expected";
          }
          if (message.s != null && message.hasOwnProperty("s")) {
            if (!(message.s && typeof message.s.length === "number" || $util.isString(message.s)))
              return "s: buffer expected";
          }
          if (message.t != null && message.hasOwnProperty("t")) {
            var error = $root.onnx.TensorProto.verify(message.t);
            if (error)
              return "t." + error;
          }
          if (message.g != null && message.hasOwnProperty("g")) {
            var error = $root.onnx.GraphProto.verify(message.g);
            if (error)
              return "g." + error;
          }
          if (message.sparseTensor != null && message.hasOwnProperty("sparseTensor")) {
            var error = $root.onnx.SparseTensorProto.verify(message.sparseTensor);
            if (error)
              return "sparseTensor." + error;
          }
          if (message.tp != null && message.hasOwnProperty("tp")) {
            var error = $root.onnx.TypeProto.verify(message.tp);
            if (error)
              return "tp." + error;
          }
          if (message.floats != null && message.hasOwnProperty("floats")) {
            if (!Array.isArray(message.floats))
              return "floats: array expected";
            for (var i = 0; i < message.floats.length; ++i)
              if (typeof message.floats[i] !== "number")
                return "floats: number[] expected";
          }
          if (message.ints != null && message.hasOwnProperty("ints")) {
            if (!Array.isArray(message.ints))
              return "ints: array expected";
            for (var i = 0; i < message.ints.length; ++i)
              if (!$util.isInteger(message.ints[i]) && !(message.ints[i] && $util.isInteger(message.ints[i].low) && $util.isInteger(message.ints[i].high)))
                return "ints: integer|Long[] expected";
          }
          if (message.strings != null && message.hasOwnProperty("strings")) {
            if (!Array.isArray(message.strings))
              return "strings: array expected";
            for (var i = 0; i < message.strings.length; ++i)
              if (!(message.strings[i] && typeof message.strings[i].length === "number" || $util.isString(message.strings[i])))
                return "strings: buffer[] expected";
          }
          if (message.tensors != null && message.hasOwnProperty("tensors")) {
            if (!Array.isArray(message.tensors))
              return "tensors: array expected";
            for (var i = 0; i < message.tensors.length; ++i) {
              var error = $root.onnx.TensorProto.verify(message.tensors[i]);
              if (error)
                return "tensors." + error;
            }
          }
          if (message.graphs != null && message.hasOwnProperty("graphs")) {
            if (!Array.isArray(message.graphs))
              return "graphs: array expected";
            for (var i = 0; i < message.graphs.length; ++i) {
              var error = $root.onnx.GraphProto.verify(message.graphs[i]);
              if (error)
                return "graphs." + error;
            }
          }
          if (message.sparseTensors != null && message.hasOwnProperty("sparseTensors")) {
            if (!Array.isArray(message.sparseTensors))
              return "sparseTensors: array expected";
            for (var i = 0; i < message.sparseTensors.length; ++i) {
              var error = $root.onnx.SparseTensorProto.verify(message.sparseTensors[i]);
              if (error)
                return "sparseTensors." + error;
            }
          }
          if (message.typeProtos != null && message.hasOwnProperty("typeProtos")) {
            if (!Array.isArray(message.typeProtos))
              return "typeProtos: array expected";
            for (var i = 0; i < message.typeProtos.length; ++i) {
              var error = $root.onnx.TypeProto.verify(message.typeProtos[i]);
              if (error)
                return "typeProtos." + error;
            }
          }
          return null;
        };
        AttributeProto.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.AttributeProto)
            return object;
          var message = new $root.onnx.AttributeProto();
          if (object.name != null)
            message.name = String(object.name);
          if (object.refAttrName != null)
            message.refAttrName = String(object.refAttrName);
          if (object.docString != null)
            message.docString = String(object.docString);
          switch (object.type) {
            default:
              if (typeof object.type === "number") {
                message.type = object.type;
                break;
              }
              break;
            case "UNDEFINED":
            case 0:
              message.type = 0;
              break;
            case "FLOAT":
            case 1:
              message.type = 1;
              break;
            case "INT":
            case 2:
              message.type = 2;
              break;
            case "STRING":
            case 3:
              message.type = 3;
              break;
            case "TENSOR":
            case 4:
              message.type = 4;
              break;
            case "GRAPH":
            case 5:
              message.type = 5;
              break;
            case "SPARSE_TENSOR":
            case 11:
              message.type = 11;
              break;
            case "TYPE_PROTO":
            case 13:
              message.type = 13;
              break;
            case "FLOATS":
            case 6:
              message.type = 6;
              break;
            case "INTS":
            case 7:
              message.type = 7;
              break;
            case "STRINGS":
            case 8:
              message.type = 8;
              break;
            case "TENSORS":
            case 9:
              message.type = 9;
              break;
            case "GRAPHS":
            case 10:
              message.type = 10;
              break;
            case "SPARSE_TENSORS":
            case 12:
              message.type = 12;
              break;
            case "TYPE_PROTOS":
            case 14:
              message.type = 14;
              break;
          }
          if (object.f != null)
            message.f = Number(object.f);
          if (object.i != null) {
            if ($util.Long)
              (message.i = $util.Long.fromValue(object.i)).unsigned = false;
            else if (typeof object.i === "string")
              message.i = parseInt(object.i, 10);
            else if (typeof object.i === "number")
              message.i = object.i;
            else if (typeof object.i === "object")
              message.i = new $util.LongBits(object.i.low >>> 0, object.i.high >>> 0).toNumber();
          }
          if (object.s != null) {
            if (typeof object.s === "string")
              $util.base64.decode(object.s, message.s = $util.newBuffer($util.base64.length(object.s)), 0);
            else if (object.s.length >= 0)
              message.s = object.s;
          }
          if (object.t != null) {
            if (typeof object.t !== "object")
              throw TypeError(".onnx.AttributeProto.t: object expected");
            message.t = $root.onnx.TensorProto.fromObject(object.t);
          }
          if (object.g != null) {
            if (typeof object.g !== "object")
              throw TypeError(".onnx.AttributeProto.g: object expected");
            message.g = $root.onnx.GraphProto.fromObject(object.g);
          }
          if (object.sparseTensor != null) {
            if (typeof object.sparseTensor !== "object")
              throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");
            message.sparseTensor = $root.onnx.SparseTensorProto.fromObject(object.sparseTensor);
          }
          if (object.tp != null) {
            if (typeof object.tp !== "object")
              throw TypeError(".onnx.AttributeProto.tp: object expected");
            message.tp = $root.onnx.TypeProto.fromObject(object.tp);
          }
          if (object.floats) {
            if (!Array.isArray(object.floats))
              throw TypeError(".onnx.AttributeProto.floats: array expected");
            message.floats = [];
            for (var i = 0; i < object.floats.length; ++i)
              message.floats[i] = Number(object.floats[i]);
          }
          if (object.ints) {
            if (!Array.isArray(object.ints))
              throw TypeError(".onnx.AttributeProto.ints: array expected");
            message.ints = [];
            for (var i = 0; i < object.ints.length; ++i)
              if ($util.Long)
                (message.ints[i] = $util.Long.fromValue(object.ints[i])).unsigned = false;
              else if (typeof object.ints[i] === "string")
                message.ints[i] = parseInt(object.ints[i], 10);
              else if (typeof object.ints[i] === "number")
                message.ints[i] = object.ints[i];
              else if (typeof object.ints[i] === "object")
                message.ints[i] = new $util.LongBits(object.ints[i].low >>> 0, object.ints[i].high >>> 0).toNumber();
          }
          if (object.strings) {
            if (!Array.isArray(object.strings))
              throw TypeError(".onnx.AttributeProto.strings: array expected");
            message.strings = [];
            for (var i = 0; i < object.strings.length; ++i)
              if (typeof object.strings[i] === "string")
                $util.base64.decode(object.strings[i], message.strings[i] = $util.newBuffer($util.base64.length(object.strings[i])), 0);
              else if (object.strings[i].length >= 0)
                message.strings[i] = object.strings[i];
          }
          if (object.tensors) {
            if (!Array.isArray(object.tensors))
              throw TypeError(".onnx.AttributeProto.tensors: array expected");
            message.tensors = [];
            for (var i = 0; i < object.tensors.length; ++i) {
              if (typeof object.tensors[i] !== "object")
                throw TypeError(".onnx.AttributeProto.tensors: object expected");
              message.tensors[i] = $root.onnx.TensorProto.fromObject(object.tensors[i]);
            }
          }
          if (object.graphs) {
            if (!Array.isArray(object.graphs))
              throw TypeError(".onnx.AttributeProto.graphs: array expected");
            message.graphs = [];
            for (var i = 0; i < object.graphs.length; ++i) {
              if (typeof object.graphs[i] !== "object")
                throw TypeError(".onnx.AttributeProto.graphs: object expected");
              message.graphs[i] = $root.onnx.GraphProto.fromObject(object.graphs[i]);
            }
          }
          if (object.sparseTensors) {
            if (!Array.isArray(object.sparseTensors))
              throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");
            message.sparseTensors = [];
            for (var i = 0; i < object.sparseTensors.length; ++i) {
              if (typeof object.sparseTensors[i] !== "object")
                throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");
              message.sparseTensors[i] = $root.onnx.SparseTensorProto.fromObject(object.sparseTensors[i]);
            }
          }
          if (object.typeProtos) {
            if (!Array.isArray(object.typeProtos))
              throw TypeError(".onnx.AttributeProto.typeProtos: array expected");
            message.typeProtos = [];
            for (var i = 0; i < object.typeProtos.length; ++i) {
              if (typeof object.typeProtos[i] !== "object")
                throw TypeError(".onnx.AttributeProto.typeProtos: object expected");
              message.typeProtos[i] = $root.onnx.TypeProto.fromObject(object.typeProtos[i]);
            }
          }
          return message;
        };
        AttributeProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.floats = [];
            object.ints = [];
            object.strings = [];
            object.tensors = [];
            object.graphs = [];
            object.typeProtos = [];
            object.sparseTensors = [];
          }
          if (options.defaults) {
            object.name = "";
            object.f = 0;
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.i = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
              object.i = options.longs === String ? "0" : 0;
            if (options.bytes === String)
              object.s = "";
            else {
              object.s = [];
              if (options.bytes !== Array)
                object.s = $util.newBuffer(object.s);
            }
            object.t = null;
            object.g = null;
            object.docString = "";
            object.tp = null;
            object.type = options.enums === String ? "UNDEFINED" : 0;
            object.refAttrName = "";
            object.sparseTensor = null;
          }
          if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
          if (message.f != null && message.hasOwnProperty("f"))
            object.f = options.json && !isFinite(message.f) ? String(message.f) : message.f;
          if (message.i != null && message.hasOwnProperty("i"))
            if (typeof message.i === "number")
              object.i = options.longs === String ? String(message.i) : message.i;
            else
              object.i = options.longs === String ? $util.Long.prototype.toString.call(message.i) : options.longs === Number ? new $util.LongBits(message.i.low >>> 0, message.i.high >>> 0).toNumber() : message.i;
          if (message.s != null && message.hasOwnProperty("s"))
            object.s = options.bytes === String ? $util.base64.encode(message.s, 0, message.s.length) : options.bytes === Array ? Array.prototype.slice.call(message.s) : message.s;
          if (message.t != null && message.hasOwnProperty("t"))
            object.t = $root.onnx.TensorProto.toObject(message.t, options);
          if (message.g != null && message.hasOwnProperty("g"))
            object.g = $root.onnx.GraphProto.toObject(message.g, options);
          if (message.floats && message.floats.length) {
            object.floats = [];
            for (var j = 0; j < message.floats.length; ++j)
              object.floats[j] = options.json && !isFinite(message.floats[j]) ? String(message.floats[j]) : message.floats[j];
          }
          if (message.ints && message.ints.length) {
            object.ints = [];
            for (var j = 0; j < message.ints.length; ++j)
              if (typeof message.ints[j] === "number")
                object.ints[j] = options.longs === String ? String(message.ints[j]) : message.ints[j];
              else
                object.ints[j] = options.longs === String ? $util.Long.prototype.toString.call(message.ints[j]) : options.longs === Number ? new $util.LongBits(message.ints[j].low >>> 0, message.ints[j].high >>> 0).toNumber() : message.ints[j];
          }
          if (message.strings && message.strings.length) {
            object.strings = [];
            for (var j = 0; j < message.strings.length; ++j)
              object.strings[j] = options.bytes === String ? $util.base64.encode(message.strings[j], 0, message.strings[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.strings[j]) : message.strings[j];
          }
          if (message.tensors && message.tensors.length) {
            object.tensors = [];
            for (var j = 0; j < message.tensors.length; ++j)
              object.tensors[j] = $root.onnx.TensorProto.toObject(message.tensors[j], options);
          }
          if (message.graphs && message.graphs.length) {
            object.graphs = [];
            for (var j = 0; j < message.graphs.length; ++j)
              object.graphs[j] = $root.onnx.GraphProto.toObject(message.graphs[j], options);
          }
          if (message.docString != null && message.hasOwnProperty("docString"))
            object.docString = message.docString;
          if (message.tp != null && message.hasOwnProperty("tp"))
            object.tp = $root.onnx.TypeProto.toObject(message.tp, options);
          if (message.typeProtos && message.typeProtos.length) {
            object.typeProtos = [];
            for (var j = 0; j < message.typeProtos.length; ++j)
              object.typeProtos[j] = $root.onnx.TypeProto.toObject(message.typeProtos[j], options);
          }
          if (message.type != null && message.hasOwnProperty("type"))
            object.type = options.enums === String ? $root.onnx.AttributeProto.AttributeType[message.type] === void 0 ? message.type : $root.onnx.AttributeProto.AttributeType[message.type] : message.type;
          if (message.refAttrName != null && message.hasOwnProperty("refAttrName"))
            object.refAttrName = message.refAttrName;
          if (message.sparseTensor != null && message.hasOwnProperty("sparseTensor"))
            object.sparseTensor = $root.onnx.SparseTensorProto.toObject(message.sparseTensor, options);
          if (message.sparseTensors && message.sparseTensors.length) {
            object.sparseTensors = [];
            for (var j = 0; j < message.sparseTensors.length; ++j)
              object.sparseTensors[j] = $root.onnx.SparseTensorProto.toObject(message.sparseTensors[j], options);
          }
          return object;
        };
        AttributeProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        AttributeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.AttributeProto";
        };
        AttributeProto.AttributeType = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "UNDEFINED"] = 0;
          values[valuesById[1] = "FLOAT"] = 1;
          values[valuesById[2] = "INT"] = 2;
          values[valuesById[3] = "STRING"] = 3;
          values[valuesById[4] = "TENSOR"] = 4;
          values[valuesById[5] = "GRAPH"] = 5;
          values[valuesById[11] = "SPARSE_TENSOR"] = 11;
          values[valuesById[13] = "TYPE_PROTO"] = 13;
          values[valuesById[6] = "FLOATS"] = 6;
          values[valuesById[7] = "INTS"] = 7;
          values[valuesById[8] = "STRINGS"] = 8;
          values[valuesById[9] = "TENSORS"] = 9;
          values[valuesById[10] = "GRAPHS"] = 10;
          values[valuesById[12] = "SPARSE_TENSORS"] = 12;
          values[valuesById[14] = "TYPE_PROTOS"] = 14;
          return values;
        }();
        return AttributeProto;
      }();
      onnx6.ValueInfoProto = function() {
        function ValueInfoProto(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        ValueInfoProto.prototype.name = "";
        ValueInfoProto.prototype.type = null;
        ValueInfoProto.prototype.docString = "";
        ValueInfoProto.create = function create(properties) {
          return new ValueInfoProto(properties);
        };
        ValueInfoProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.name);
          if (message.type != null && Object.hasOwnProperty.call(message, "type"))
            $root.onnx.TypeProto.encode(message.type, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.docString);
          return writer;
        };
        ValueInfoProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        ValueInfoProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.ValueInfoProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.name = reader.string();
                break;
              }
              case 2: {
                message.type = $root.onnx.TypeProto.decode(reader, reader.uint32());
                break;
              }
              case 3: {
                message.docString = reader.string();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        ValueInfoProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ValueInfoProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.name != null && message.hasOwnProperty("name")) {
            if (!$util.isString(message.name))
              return "name: string expected";
          }
          if (message.type != null && message.hasOwnProperty("type")) {
            var error = $root.onnx.TypeProto.verify(message.type);
            if (error)
              return "type." + error;
          }
          if (message.docString != null && message.hasOwnProperty("docString")) {
            if (!$util.isString(message.docString))
              return "docString: string expected";
          }
          return null;
        };
        ValueInfoProto.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.ValueInfoProto)
            return object;
          var message = new $root.onnx.ValueInfoProto();
          if (object.name != null)
            message.name = String(object.name);
          if (object.type != null) {
            if (typeof object.type !== "object")
              throw TypeError(".onnx.ValueInfoProto.type: object expected");
            message.type = $root.onnx.TypeProto.fromObject(object.type);
          }
          if (object.docString != null)
            message.docString = String(object.docString);
          return message;
        };
        ValueInfoProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.name = "";
            object.type = null;
            object.docString = "";
          }
          if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
          if (message.type != null && message.hasOwnProperty("type"))
            object.type = $root.onnx.TypeProto.toObject(message.type, options);
          if (message.docString != null && message.hasOwnProperty("docString"))
            object.docString = message.docString;
          return object;
        };
        ValueInfoProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        ValueInfoProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.ValueInfoProto";
        };
        return ValueInfoProto;
      }();
      onnx6.NodeProto = function() {
        function NodeProto(properties) {
          this.input = [];
          this.output = [];
          this.attribute = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        NodeProto.prototype.input = $util.emptyArray;
        NodeProto.prototype.output = $util.emptyArray;
        NodeProto.prototype.name = "";
        NodeProto.prototype.opType = "";
        NodeProto.prototype.domain = "";
        NodeProto.prototype.attribute = $util.emptyArray;
        NodeProto.prototype.docString = "";
        NodeProto.create = function create(properties) {
          return new NodeProto(properties);
        };
        NodeProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.input != null && message.input.length)
            for (var i = 0; i < message.input.length; ++i)
              writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).string(message.input[i]);
          if (message.output != null && message.output.length)
            for (var i = 0; i < message.output.length; ++i)
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.output[i]);
          if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.name);
          if (message.opType != null && Object.hasOwnProperty.call(message, "opType"))
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).string(message.opType);
          if (message.attribute != null && message.attribute.length)
            for (var i = 0; i < message.attribute.length; ++i)
              $root.onnx.AttributeProto.encode(message.attribute[i], writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork()).ldelim();
          if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
            writer.uint32(
              /* id 6, wireType 2 =*/
              50
            ).string(message.docString);
          if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
            writer.uint32(
              /* id 7, wireType 2 =*/
              58
            ).string(message.domain);
          return writer;
        };
        NodeProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        NodeProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.NodeProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (!(message.input && message.input.length))
                  message.input = [];
                message.input.push(reader.string());
                break;
              }
              case 2: {
                if (!(message.output && message.output.length))
                  message.output = [];
                message.output.push(reader.string());
                break;
              }
              case 3: {
                message.name = reader.string();
                break;
              }
              case 4: {
                message.opType = reader.string();
                break;
              }
              case 7: {
                message.domain = reader.string();
                break;
              }
              case 5: {
                if (!(message.attribute && message.attribute.length))
                  message.attribute = [];
                message.attribute.push($root.onnx.AttributeProto.decode(reader, reader.uint32()));
                break;
              }
              case 6: {
                message.docString = reader.string();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        NodeProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        NodeProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.input != null && message.hasOwnProperty("input")) {
            if (!Array.isArray(message.input))
              return "input: array expected";
            for (var i = 0; i < message.input.length; ++i)
              if (!$util.isString(message.input[i]))
                return "input: string[] expected";
          }
          if (message.output != null && message.hasOwnProperty("output")) {
            if (!Array.isArray(message.output))
              return "output: array expected";
            for (var i = 0; i < message.output.length; ++i)
              if (!$util.isString(message.output[i]))
                return "output: string[] expected";
          }
          if (message.name != null && message.hasOwnProperty("name")) {
            if (!$util.isString(message.name))
              return "name: string expected";
          }
          if (message.opType != null && message.hasOwnProperty("opType")) {
            if (!$util.isString(message.opType))
              return "opType: string expected";
          }
          if (message.domain != null && message.hasOwnProperty("domain")) {
            if (!$util.isString(message.domain))
              return "domain: string expected";
          }
          if (message.attribute != null && message.hasOwnProperty("attribute")) {
            if (!Array.isArray(message.attribute))
              return "attribute: array expected";
            for (var i = 0; i < message.attribute.length; ++i) {
              var error = $root.onnx.AttributeProto.verify(message.attribute[i]);
              if (error)
                return "attribute." + error;
            }
          }
          if (message.docString != null && message.hasOwnProperty("docString")) {
            if (!$util.isString(message.docString))
              return "docString: string expected";
          }
          return null;
        };
        NodeProto.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.NodeProto)
            return object;
          var message = new $root.onnx.NodeProto();
          if (object.input) {
            if (!Array.isArray(object.input))
              throw TypeError(".onnx.NodeProto.input: array expected");
            message.input = [];
            for (var i = 0; i < object.input.length; ++i)
              message.input[i] = String(object.input[i]);
          }
          if (object.output) {
            if (!Array.isArray(object.output))
              throw TypeError(".onnx.NodeProto.output: array expected");
            message.output = [];
            for (var i = 0; i < object.output.length; ++i)
              message.output[i] = String(object.output[i]);
          }
          if (object.name != null)
            message.name = String(object.name);
          if (object.opType != null)
            message.opType = String(object.opType);
          if (object.domain != null)
            message.domain = String(object.domain);
          if (object.attribute) {
            if (!Array.isArray(object.attribute))
              throw TypeError(".onnx.NodeProto.attribute: array expected");
            message.attribute = [];
            for (var i = 0; i < object.attribute.length; ++i) {
              if (typeof object.attribute[i] !== "object")
                throw TypeError(".onnx.NodeProto.attribute: object expected");
              message.attribute[i] = $root.onnx.AttributeProto.fromObject(object.attribute[i]);
            }
          }
          if (object.docString != null)
            message.docString = String(object.docString);
          return message;
        };
        NodeProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.input = [];
            object.output = [];
            object.attribute = [];
          }
          if (options.defaults) {
            object.name = "";
            object.opType = "";
            object.docString = "";
            object.domain = "";
          }
          if (message.input && message.input.length) {
            object.input = [];
            for (var j = 0; j < message.input.length; ++j)
              object.input[j] = message.input[j];
          }
          if (message.output && message.output.length) {
            object.output = [];
            for (var j = 0; j < message.output.length; ++j)
              object.output[j] = message.output[j];
          }
          if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
          if (message.opType != null && message.hasOwnProperty("opType"))
            object.opType = message.opType;
          if (message.attribute && message.attribute.length) {
            object.attribute = [];
            for (var j = 0; j < message.attribute.length; ++j)
              object.attribute[j] = $root.onnx.AttributeProto.toObject(message.attribute[j], options);
          }
          if (message.docString != null && message.hasOwnProperty("docString"))
            object.docString = message.docString;
          if (message.domain != null && message.hasOwnProperty("domain"))
            object.domain = message.domain;
          return object;
        };
        NodeProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        NodeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.NodeProto";
        };
        return NodeProto;
      }();
      onnx6.TrainingInfoProto = function() {
        function TrainingInfoProto(properties) {
          this.initializationBinding = [];
          this.updateBinding = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        TrainingInfoProto.prototype.initialization = null;
        TrainingInfoProto.prototype.algorithm = null;
        TrainingInfoProto.prototype.initializationBinding = $util.emptyArray;
        TrainingInfoProto.prototype.updateBinding = $util.emptyArray;
        TrainingInfoProto.create = function create(properties) {
          return new TrainingInfoProto(properties);
        };
        TrainingInfoProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.initialization != null && Object.hasOwnProperty.call(message, "initialization"))
            $root.onnx.GraphProto.encode(message.initialization, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.algorithm != null && Object.hasOwnProperty.call(message, "algorithm"))
            $root.onnx.GraphProto.encode(message.algorithm, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.initializationBinding != null && message.initializationBinding.length)
            for (var i = 0; i < message.initializationBinding.length; ++i)
              $root.onnx.StringStringEntryProto.encode(message.initializationBinding[i], writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).fork()).ldelim();
          if (message.updateBinding != null && message.updateBinding.length)
            for (var i = 0; i < message.updateBinding.length; ++i)
              $root.onnx.StringStringEntryProto.encode(message.updateBinding[i], writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).fork()).ldelim();
          return writer;
        };
        TrainingInfoProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        TrainingInfoProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TrainingInfoProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.initialization = $root.onnx.GraphProto.decode(reader, reader.uint32());
                break;
              }
              case 2: {
                message.algorithm = $root.onnx.GraphProto.decode(reader, reader.uint32());
                break;
              }
              case 3: {
                if (!(message.initializationBinding && message.initializationBinding.length))
                  message.initializationBinding = [];
                message.initializationBinding.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));
                break;
              }
              case 4: {
                if (!(message.updateBinding && message.updateBinding.length))
                  message.updateBinding = [];
                message.updateBinding.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        TrainingInfoProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        TrainingInfoProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.initialization != null && message.hasOwnProperty("initialization")) {
            var error = $root.onnx.GraphProto.verify(message.initialization);
            if (error)
              return "initialization." + error;
          }
          if (message.algorithm != null && message.hasOwnProperty("algorithm")) {
            var error = $root.onnx.GraphProto.verify(message.algorithm);
            if (error)
              return "algorithm." + error;
          }
          if (message.initializationBinding != null && message.hasOwnProperty("initializationBinding")) {
            if (!Array.isArray(message.initializationBinding))
              return "initializationBinding: array expected";
            for (var i = 0; i < message.initializationBinding.length; ++i) {
              var error = $root.onnx.StringStringEntryProto.verify(message.initializationBinding[i]);
              if (error)
                return "initializationBinding." + error;
            }
          }
          if (message.updateBinding != null && message.hasOwnProperty("updateBinding")) {
            if (!Array.isArray(message.updateBinding))
              return "updateBinding: array expected";
            for (var i = 0; i < message.updateBinding.length; ++i) {
              var error = $root.onnx.StringStringEntryProto.verify(message.updateBinding[i]);
              if (error)
                return "updateBinding." + error;
            }
          }
          return null;
        };
        TrainingInfoProto.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.TrainingInfoProto)
            return object;
          var message = new $root.onnx.TrainingInfoProto();
          if (object.initialization != null) {
            if (typeof object.initialization !== "object")
              throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");
            message.initialization = $root.onnx.GraphProto.fromObject(object.initialization);
          }
          if (object.algorithm != null) {
            if (typeof object.algorithm !== "object")
              throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");
            message.algorithm = $root.onnx.GraphProto.fromObject(object.algorithm);
          }
          if (object.initializationBinding) {
            if (!Array.isArray(object.initializationBinding))
              throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");
            message.initializationBinding = [];
            for (var i = 0; i < object.initializationBinding.length; ++i) {
              if (typeof object.initializationBinding[i] !== "object")
                throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");
              message.initializationBinding[i] = $root.onnx.StringStringEntryProto.fromObject(object.initializationBinding[i]);
            }
          }
          if (object.updateBinding) {
            if (!Array.isArray(object.updateBinding))
              throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");
            message.updateBinding = [];
            for (var i = 0; i < object.updateBinding.length; ++i) {
              if (typeof object.updateBinding[i] !== "object")
                throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");
              message.updateBinding[i] = $root.onnx.StringStringEntryProto.fromObject(object.updateBinding[i]);
            }
          }
          return message;
        };
        TrainingInfoProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.initializationBinding = [];
            object.updateBinding = [];
          }
          if (options.defaults) {
            object.initialization = null;
            object.algorithm = null;
          }
          if (message.initialization != null && message.hasOwnProperty("initialization"))
            object.initialization = $root.onnx.GraphProto.toObject(message.initialization, options);
          if (message.algorithm != null && message.hasOwnProperty("algorithm"))
            object.algorithm = $root.onnx.GraphProto.toObject(message.algorithm, options);
          if (message.initializationBinding && message.initializationBinding.length) {
            object.initializationBinding = [];
            for (var j = 0; j < message.initializationBinding.length; ++j)
              object.initializationBinding[j] = $root.onnx.StringStringEntryProto.toObject(message.initializationBinding[j], options);
          }
          if (message.updateBinding && message.updateBinding.length) {
            object.updateBinding = [];
            for (var j = 0; j < message.updateBinding.length; ++j)
              object.updateBinding[j] = $root.onnx.StringStringEntryProto.toObject(message.updateBinding[j], options);
          }
          return object;
        };
        TrainingInfoProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        TrainingInfoProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.TrainingInfoProto";
        };
        return TrainingInfoProto;
      }();
      onnx6.ModelProto = function() {
        function ModelProto(properties) {
          this.opsetImport = [];
          this.metadataProps = [];
          this.trainingInfo = [];
          this.functions = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        ModelProto.prototype.irVersion = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ModelProto.prototype.opsetImport = $util.emptyArray;
        ModelProto.prototype.producerName = "";
        ModelProto.prototype.producerVersion = "";
        ModelProto.prototype.domain = "";
        ModelProto.prototype.modelVersion = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        ModelProto.prototype.docString = "";
        ModelProto.prototype.graph = null;
        ModelProto.prototype.metadataProps = $util.emptyArray;
        ModelProto.prototype.trainingInfo = $util.emptyArray;
        ModelProto.prototype.functions = $util.emptyArray;
        ModelProto.create = function create(properties) {
          return new ModelProto(properties);
        };
        ModelProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.irVersion != null && Object.hasOwnProperty.call(message, "irVersion"))
            writer.uint32(
              /* id 1, wireType 0 =*/
              8
            ).int64(message.irVersion);
          if (message.producerName != null && Object.hasOwnProperty.call(message, "producerName"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).string(message.producerName);
          if (message.producerVersion != null && Object.hasOwnProperty.call(message, "producerVersion"))
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).string(message.producerVersion);
          if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).string(message.domain);
          if (message.modelVersion != null && Object.hasOwnProperty.call(message, "modelVersion"))
            writer.uint32(
              /* id 5, wireType 0 =*/
              40
            ).int64(message.modelVersion);
          if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
            writer.uint32(
              /* id 6, wireType 2 =*/
              50
            ).string(message.docString);
          if (message.graph != null && Object.hasOwnProperty.call(message, "graph"))
            $root.onnx.GraphProto.encode(message.graph, writer.uint32(
              /* id 7, wireType 2 =*/
              58
            ).fork()).ldelim();
          if (message.opsetImport != null && message.opsetImport.length)
            for (var i = 0; i < message.opsetImport.length; ++i)
              $root.onnx.OperatorSetIdProto.encode(message.opsetImport[i], writer.uint32(
                /* id 8, wireType 2 =*/
                66
              ).fork()).ldelim();
          if (message.metadataProps != null && message.metadataProps.length)
            for (var i = 0; i < message.metadataProps.length; ++i)
              $root.onnx.StringStringEntryProto.encode(message.metadataProps[i], writer.uint32(
                /* id 14, wireType 2 =*/
                114
              ).fork()).ldelim();
          if (message.trainingInfo != null && message.trainingInfo.length)
            for (var i = 0; i < message.trainingInfo.length; ++i)
              $root.onnx.TrainingInfoProto.encode(message.trainingInfo[i], writer.uint32(
                /* id 20, wireType 2 =*/
                162
              ).fork()).ldelim();
          if (message.functions != null && message.functions.length)
            for (var i = 0; i < message.functions.length; ++i)
              $root.onnx.FunctionProto.encode(message.functions[i], writer.uint32(
                /* id 25, wireType 2 =*/
                202
              ).fork()).ldelim();
          return writer;
        };
        ModelProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        ModelProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.ModelProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.irVersion = reader.int64();
                break;
              }
              case 8: {
                if (!(message.opsetImport && message.opsetImport.length))
                  message.opsetImport = [];
                message.opsetImport.push($root.onnx.OperatorSetIdProto.decode(reader, reader.uint32()));
                break;
              }
              case 2: {
                message.producerName = reader.string();
                break;
              }
              case 3: {
                message.producerVersion = reader.string();
                break;
              }
              case 4: {
                message.domain = reader.string();
                break;
              }
              case 5: {
                message.modelVersion = reader.int64();
                break;
              }
              case 6: {
                message.docString = reader.string();
                break;
              }
              case 7: {
                message.graph = $root.onnx.GraphProto.decode(reader, reader.uint32());
                break;
              }
              case 14: {
                if (!(message.metadataProps && message.metadataProps.length))
                  message.metadataProps = [];
                message.metadataProps.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));
                break;
              }
              case 20: {
                if (!(message.trainingInfo && message.trainingInfo.length))
                  message.trainingInfo = [];
                message.trainingInfo.push($root.onnx.TrainingInfoProto.decode(reader, reader.uint32()));
                break;
              }
              case 25: {
                if (!(message.functions && message.functions.length))
                  message.functions = [];
                message.functions.push($root.onnx.FunctionProto.decode(reader, reader.uint32()));
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        ModelProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        ModelProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.irVersion != null && message.hasOwnProperty("irVersion")) {
            if (!$util.isInteger(message.irVersion) && !(message.irVersion && $util.isInteger(message.irVersion.low) && $util.isInteger(message.irVersion.high)))
              return "irVersion: integer|Long expected";
          }
          if (message.opsetImport != null && message.hasOwnProperty("opsetImport")) {
            if (!Array.isArray(message.opsetImport))
              return "opsetImport: array expected";
            for (var i = 0; i < message.opsetImport.length; ++i) {
              var error = $root.onnx.OperatorSetIdProto.verify(message.opsetImport[i]);
              if (error)
                return "opsetImport." + error;
            }
          }
          if (message.producerName != null && message.hasOwnProperty("producerName")) {
            if (!$util.isString(message.producerName))
              return "producerName: string expected";
          }
          if (message.producerVersion != null && message.hasOwnProperty("producerVersion")) {
            if (!$util.isString(message.producerVersion))
              return "producerVersion: string expected";
          }
          if (message.domain != null && message.hasOwnProperty("domain")) {
            if (!$util.isString(message.domain))
              return "domain: string expected";
          }
          if (message.modelVersion != null && message.hasOwnProperty("modelVersion")) {
            if (!$util.isInteger(message.modelVersion) && !(message.modelVersion && $util.isInteger(message.modelVersion.low) && $util.isInteger(message.modelVersion.high)))
              return "modelVersion: integer|Long expected";
          }
          if (message.docString != null && message.hasOwnProperty("docString")) {
            if (!$util.isString(message.docString))
              return "docString: string expected";
          }
          if (message.graph != null && message.hasOwnProperty("graph")) {
            var error = $root.onnx.GraphProto.verify(message.graph);
            if (error)
              return "graph." + error;
          }
          if (message.metadataProps != null && message.hasOwnProperty("metadataProps")) {
            if (!Array.isArray(message.metadataProps))
              return "metadataProps: array expected";
            for (var i = 0; i < message.metadataProps.length; ++i) {
              var error = $root.onnx.StringStringEntryProto.verify(message.metadataProps[i]);
              if (error)
                return "metadataProps." + error;
            }
          }
          if (message.trainingInfo != null && message.hasOwnProperty("trainingInfo")) {
            if (!Array.isArray(message.trainingInfo))
              return "trainingInfo: array expected";
            for (var i = 0; i < message.trainingInfo.length; ++i) {
              var error = $root.onnx.TrainingInfoProto.verify(message.trainingInfo[i]);
              if (error)
                return "trainingInfo." + error;
            }
          }
          if (message.functions != null && message.hasOwnProperty("functions")) {
            if (!Array.isArray(message.functions))
              return "functions: array expected";
            for (var i = 0; i < message.functions.length; ++i) {
              var error = $root.onnx.FunctionProto.verify(message.functions[i]);
              if (error)
                return "functions." + error;
            }
          }
          return null;
        };
        ModelProto.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.ModelProto)
            return object;
          var message = new $root.onnx.ModelProto();
          if (object.irVersion != null) {
            if ($util.Long)
              (message.irVersion = $util.Long.fromValue(object.irVersion)).unsigned = false;
            else if (typeof object.irVersion === "string")
              message.irVersion = parseInt(object.irVersion, 10);
            else if (typeof object.irVersion === "number")
              message.irVersion = object.irVersion;
            else if (typeof object.irVersion === "object")
              message.irVersion = new $util.LongBits(object.irVersion.low >>> 0, object.irVersion.high >>> 0).toNumber();
          }
          if (object.opsetImport) {
            if (!Array.isArray(object.opsetImport))
              throw TypeError(".onnx.ModelProto.opsetImport: array expected");
            message.opsetImport = [];
            for (var i = 0; i < object.opsetImport.length; ++i) {
              if (typeof object.opsetImport[i] !== "object")
                throw TypeError(".onnx.ModelProto.opsetImport: object expected");
              message.opsetImport[i] = $root.onnx.OperatorSetIdProto.fromObject(object.opsetImport[i]);
            }
          }
          if (object.producerName != null)
            message.producerName = String(object.producerName);
          if (object.producerVersion != null)
            message.producerVersion = String(object.producerVersion);
          if (object.domain != null)
            message.domain = String(object.domain);
          if (object.modelVersion != null) {
            if ($util.Long)
              (message.modelVersion = $util.Long.fromValue(object.modelVersion)).unsigned = false;
            else if (typeof object.modelVersion === "string")
              message.modelVersion = parseInt(object.modelVersion, 10);
            else if (typeof object.modelVersion === "number")
              message.modelVersion = object.modelVersion;
            else if (typeof object.modelVersion === "object")
              message.modelVersion = new $util.LongBits(object.modelVersion.low >>> 0, object.modelVersion.high >>> 0).toNumber();
          }
          if (object.docString != null)
            message.docString = String(object.docString);
          if (object.graph != null) {
            if (typeof object.graph !== "object")
              throw TypeError(".onnx.ModelProto.graph: object expected");
            message.graph = $root.onnx.GraphProto.fromObject(object.graph);
          }
          if (object.metadataProps) {
            if (!Array.isArray(object.metadataProps))
              throw TypeError(".onnx.ModelProto.metadataProps: array expected");
            message.metadataProps = [];
            for (var i = 0; i < object.metadataProps.length; ++i) {
              if (typeof object.metadataProps[i] !== "object")
                throw TypeError(".onnx.ModelProto.metadataProps: object expected");
              message.metadataProps[i] = $root.onnx.StringStringEntryProto.fromObject(object.metadataProps[i]);
            }
          }
          if (object.trainingInfo) {
            if (!Array.isArray(object.trainingInfo))
              throw TypeError(".onnx.ModelProto.trainingInfo: array expected");
            message.trainingInfo = [];
            for (var i = 0; i < object.trainingInfo.length; ++i) {
              if (typeof object.trainingInfo[i] !== "object")
                throw TypeError(".onnx.ModelProto.trainingInfo: object expected");
              message.trainingInfo[i] = $root.onnx.TrainingInfoProto.fromObject(object.trainingInfo[i]);
            }
          }
          if (object.functions) {
            if (!Array.isArray(object.functions))
              throw TypeError(".onnx.ModelProto.functions: array expected");
            message.functions = [];
            for (var i = 0; i < object.functions.length; ++i) {
              if (typeof object.functions[i] !== "object")
                throw TypeError(".onnx.ModelProto.functions: object expected");
              message.functions[i] = $root.onnx.FunctionProto.fromObject(object.functions[i]);
            }
          }
          return message;
        };
        ModelProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.opsetImport = [];
            object.metadataProps = [];
            object.trainingInfo = [];
            object.functions = [];
          }
          if (options.defaults) {
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.irVersion = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
              object.irVersion = options.longs === String ? "0" : 0;
            object.producerName = "";
            object.producerVersion = "";
            object.domain = "";
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.modelVersion = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
              object.modelVersion = options.longs === String ? "0" : 0;
            object.docString = "";
            object.graph = null;
          }
          if (message.irVersion != null && message.hasOwnProperty("irVersion"))
            if (typeof message.irVersion === "number")
              object.irVersion = options.longs === String ? String(message.irVersion) : message.irVersion;
            else
              object.irVersion = options.longs === String ? $util.Long.prototype.toString.call(message.irVersion) : options.longs === Number ? new $util.LongBits(message.irVersion.low >>> 0, message.irVersion.high >>> 0).toNumber() : message.irVersion;
          if (message.producerName != null && message.hasOwnProperty("producerName"))
            object.producerName = message.producerName;
          if (message.producerVersion != null && message.hasOwnProperty("producerVersion"))
            object.producerVersion = message.producerVersion;
          if (message.domain != null && message.hasOwnProperty("domain"))
            object.domain = message.domain;
          if (message.modelVersion != null && message.hasOwnProperty("modelVersion"))
            if (typeof message.modelVersion === "number")
              object.modelVersion = options.longs === String ? String(message.modelVersion) : message.modelVersion;
            else
              object.modelVersion = options.longs === String ? $util.Long.prototype.toString.call(message.modelVersion) : options.longs === Number ? new $util.LongBits(message.modelVersion.low >>> 0, message.modelVersion.high >>> 0).toNumber() : message.modelVersion;
          if (message.docString != null && message.hasOwnProperty("docString"))
            object.docString = message.docString;
          if (message.graph != null && message.hasOwnProperty("graph"))
            object.graph = $root.onnx.GraphProto.toObject(message.graph, options);
          if (message.opsetImport && message.opsetImport.length) {
            object.opsetImport = [];
            for (var j = 0; j < message.opsetImport.length; ++j)
              object.opsetImport[j] = $root.onnx.OperatorSetIdProto.toObject(message.opsetImport[j], options);
          }
          if (message.metadataProps && message.metadataProps.length) {
            object.metadataProps = [];
            for (var j = 0; j < message.metadataProps.length; ++j)
              object.metadataProps[j] = $root.onnx.StringStringEntryProto.toObject(message.metadataProps[j], options);
          }
          if (message.trainingInfo && message.trainingInfo.length) {
            object.trainingInfo = [];
            for (var j = 0; j < message.trainingInfo.length; ++j)
              object.trainingInfo[j] = $root.onnx.TrainingInfoProto.toObject(message.trainingInfo[j], options);
          }
          if (message.functions && message.functions.length) {
            object.functions = [];
            for (var j = 0; j < message.functions.length; ++j)
              object.functions[j] = $root.onnx.FunctionProto.toObject(message.functions[j], options);
          }
          return object;
        };
        ModelProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        ModelProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.ModelProto";
        };
        return ModelProto;
      }();
      onnx6.StringStringEntryProto = function() {
        function StringStringEntryProto(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        StringStringEntryProto.prototype.key = "";
        StringStringEntryProto.prototype.value = "";
        StringStringEntryProto.create = function create(properties) {
          return new StringStringEntryProto(properties);
        };
        StringStringEntryProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.key != null && Object.hasOwnProperty.call(message, "key"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.key);
          if (message.value != null && Object.hasOwnProperty.call(message, "value"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).string(message.value);
          return writer;
        };
        StringStringEntryProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        StringStringEntryProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.StringStringEntryProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.key = reader.string();
                break;
              }
              case 2: {
                message.value = reader.string();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        StringStringEntryProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        StringStringEntryProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.key != null && message.hasOwnProperty("key")) {
            if (!$util.isString(message.key))
              return "key: string expected";
          }
          if (message.value != null && message.hasOwnProperty("value")) {
            if (!$util.isString(message.value))
              return "value: string expected";
          }
          return null;
        };
        StringStringEntryProto.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.StringStringEntryProto)
            return object;
          var message = new $root.onnx.StringStringEntryProto();
          if (object.key != null)
            message.key = String(object.key);
          if (object.value != null)
            message.value = String(object.value);
          return message;
        };
        StringStringEntryProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.key = "";
            object.value = "";
          }
          if (message.key != null && message.hasOwnProperty("key"))
            object.key = message.key;
          if (message.value != null && message.hasOwnProperty("value"))
            object.value = message.value;
          return object;
        };
        StringStringEntryProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        StringStringEntryProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.StringStringEntryProto";
        };
        return StringStringEntryProto;
      }();
      onnx6.TensorAnnotation = function() {
        function TensorAnnotation(properties) {
          this.quantParameterTensorNames = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        TensorAnnotation.prototype.tensorName = "";
        TensorAnnotation.prototype.quantParameterTensorNames = $util.emptyArray;
        TensorAnnotation.create = function create(properties) {
          return new TensorAnnotation(properties);
        };
        TensorAnnotation.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.tensorName != null && Object.hasOwnProperty.call(message, "tensorName"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.tensorName);
          if (message.quantParameterTensorNames != null && message.quantParameterTensorNames.length)
            for (var i = 0; i < message.quantParameterTensorNames.length; ++i)
              $root.onnx.StringStringEntryProto.encode(message.quantParameterTensorNames[i], writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
          return writer;
        };
        TensorAnnotation.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        TensorAnnotation.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TensorAnnotation();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.tensorName = reader.string();
                break;
              }
              case 2: {
                if (!(message.quantParameterTensorNames && message.quantParameterTensorNames.length))
                  message.quantParameterTensorNames = [];
                message.quantParameterTensorNames.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        TensorAnnotation.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        TensorAnnotation.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.tensorName != null && message.hasOwnProperty("tensorName")) {
            if (!$util.isString(message.tensorName))
              return "tensorName: string expected";
          }
          if (message.quantParameterTensorNames != null && message.hasOwnProperty("quantParameterTensorNames")) {
            if (!Array.isArray(message.quantParameterTensorNames))
              return "quantParameterTensorNames: array expected";
            for (var i = 0; i < message.quantParameterTensorNames.length; ++i) {
              var error = $root.onnx.StringStringEntryProto.verify(message.quantParameterTensorNames[i]);
              if (error)
                return "quantParameterTensorNames." + error;
            }
          }
          return null;
        };
        TensorAnnotation.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.TensorAnnotation)
            return object;
          var message = new $root.onnx.TensorAnnotation();
          if (object.tensorName != null)
            message.tensorName = String(object.tensorName);
          if (object.quantParameterTensorNames) {
            if (!Array.isArray(object.quantParameterTensorNames))
              throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");
            message.quantParameterTensorNames = [];
            for (var i = 0; i < object.quantParameterTensorNames.length; ++i) {
              if (typeof object.quantParameterTensorNames[i] !== "object")
                throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");
              message.quantParameterTensorNames[i] = $root.onnx.StringStringEntryProto.fromObject(object.quantParameterTensorNames[i]);
            }
          }
          return message;
        };
        TensorAnnotation.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.quantParameterTensorNames = [];
          if (options.defaults)
            object.tensorName = "";
          if (message.tensorName != null && message.hasOwnProperty("tensorName"))
            object.tensorName = message.tensorName;
          if (message.quantParameterTensorNames && message.quantParameterTensorNames.length) {
            object.quantParameterTensorNames = [];
            for (var j = 0; j < message.quantParameterTensorNames.length; ++j)
              object.quantParameterTensorNames[j] = $root.onnx.StringStringEntryProto.toObject(message.quantParameterTensorNames[j], options);
          }
          return object;
        };
        TensorAnnotation.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        TensorAnnotation.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.TensorAnnotation";
        };
        return TensorAnnotation;
      }();
      onnx6.GraphProto = function() {
        function GraphProto(properties) {
          this.node = [];
          this.initializer = [];
          this.sparseInitializer = [];
          this.input = [];
          this.output = [];
          this.valueInfo = [];
          this.quantizationAnnotation = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        GraphProto.prototype.node = $util.emptyArray;
        GraphProto.prototype.name = "";
        GraphProto.prototype.initializer = $util.emptyArray;
        GraphProto.prototype.sparseInitializer = $util.emptyArray;
        GraphProto.prototype.docString = "";
        GraphProto.prototype.input = $util.emptyArray;
        GraphProto.prototype.output = $util.emptyArray;
        GraphProto.prototype.valueInfo = $util.emptyArray;
        GraphProto.prototype.quantizationAnnotation = $util.emptyArray;
        GraphProto.create = function create(properties) {
          return new GraphProto(properties);
        };
        GraphProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.node != null && message.node.length)
            for (var i = 0; i < message.node.length; ++i)
              $root.onnx.NodeProto.encode(message.node[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
          if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).string(message.name);
          if (message.initializer != null && message.initializer.length)
            for (var i = 0; i < message.initializer.length; ++i)
              $root.onnx.TensorProto.encode(message.initializer[i], writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).fork()).ldelim();
          if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
            writer.uint32(
              /* id 10, wireType 2 =*/
              82
            ).string(message.docString);
          if (message.input != null && message.input.length)
            for (var i = 0; i < message.input.length; ++i)
              $root.onnx.ValueInfoProto.encode(message.input[i], writer.uint32(
                /* id 11, wireType 2 =*/
                90
              ).fork()).ldelim();
          if (message.output != null && message.output.length)
            for (var i = 0; i < message.output.length; ++i)
              $root.onnx.ValueInfoProto.encode(message.output[i], writer.uint32(
                /* id 12, wireType 2 =*/
                98
              ).fork()).ldelim();
          if (message.valueInfo != null && message.valueInfo.length)
            for (var i = 0; i < message.valueInfo.length; ++i)
              $root.onnx.ValueInfoProto.encode(message.valueInfo[i], writer.uint32(
                /* id 13, wireType 2 =*/
                106
              ).fork()).ldelim();
          if (message.quantizationAnnotation != null && message.quantizationAnnotation.length)
            for (var i = 0; i < message.quantizationAnnotation.length; ++i)
              $root.onnx.TensorAnnotation.encode(message.quantizationAnnotation[i], writer.uint32(
                /* id 14, wireType 2 =*/
                114
              ).fork()).ldelim();
          if (message.sparseInitializer != null && message.sparseInitializer.length)
            for (var i = 0; i < message.sparseInitializer.length; ++i)
              $root.onnx.SparseTensorProto.encode(message.sparseInitializer[i], writer.uint32(
                /* id 15, wireType 2 =*/
                122
              ).fork()).ldelim();
          return writer;
        };
        GraphProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        GraphProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.GraphProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (!(message.node && message.node.length))
                  message.node = [];
                message.node.push($root.onnx.NodeProto.decode(reader, reader.uint32()));
                break;
              }
              case 2: {
                message.name = reader.string();
                break;
              }
              case 5: {
                if (!(message.initializer && message.initializer.length))
                  message.initializer = [];
                message.initializer.push($root.onnx.TensorProto.decode(reader, reader.uint32()));
                break;
              }
              case 15: {
                if (!(message.sparseInitializer && message.sparseInitializer.length))
                  message.sparseInitializer = [];
                message.sparseInitializer.push($root.onnx.SparseTensorProto.decode(reader, reader.uint32()));
                break;
              }
              case 10: {
                message.docString = reader.string();
                break;
              }
              case 11: {
                if (!(message.input && message.input.length))
                  message.input = [];
                message.input.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));
                break;
              }
              case 12: {
                if (!(message.output && message.output.length))
                  message.output = [];
                message.output.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));
                break;
              }
              case 13: {
                if (!(message.valueInfo && message.valueInfo.length))
                  message.valueInfo = [];
                message.valueInfo.push($root.onnx.ValueInfoProto.decode(reader, reader.uint32()));
                break;
              }
              case 14: {
                if (!(message.quantizationAnnotation && message.quantizationAnnotation.length))
                  message.quantizationAnnotation = [];
                message.quantizationAnnotation.push($root.onnx.TensorAnnotation.decode(reader, reader.uint32()));
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        GraphProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        GraphProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.node != null && message.hasOwnProperty("node")) {
            if (!Array.isArray(message.node))
              return "node: array expected";
            for (var i = 0; i < message.node.length; ++i) {
              var error = $root.onnx.NodeProto.verify(message.node[i]);
              if (error)
                return "node." + error;
            }
          }
          if (message.name != null && message.hasOwnProperty("name")) {
            if (!$util.isString(message.name))
              return "name: string expected";
          }
          if (message.initializer != null && message.hasOwnProperty("initializer")) {
            if (!Array.isArray(message.initializer))
              return "initializer: array expected";
            for (var i = 0; i < message.initializer.length; ++i) {
              var error = $root.onnx.TensorProto.verify(message.initializer[i]);
              if (error)
                return "initializer." + error;
            }
          }
          if (message.sparseInitializer != null && message.hasOwnProperty("sparseInitializer")) {
            if (!Array.isArray(message.sparseInitializer))
              return "sparseInitializer: array expected";
            for (var i = 0; i < message.sparseInitializer.length; ++i) {
              var error = $root.onnx.SparseTensorProto.verify(message.sparseInitializer[i]);
              if (error)
                return "sparseInitializer." + error;
            }
          }
          if (message.docString != null && message.hasOwnProperty("docString")) {
            if (!$util.isString(message.docString))
              return "docString: string expected";
          }
          if (message.input != null && message.hasOwnProperty("input")) {
            if (!Array.isArray(message.input))
              return "input: array expected";
            for (var i = 0; i < message.input.length; ++i) {
              var error = $root.onnx.ValueInfoProto.verify(message.input[i]);
              if (error)
                return "input." + error;
            }
          }
          if (message.output != null && message.hasOwnProperty("output")) {
            if (!Array.isArray(message.output))
              return "output: array expected";
            for (var i = 0; i < message.output.length; ++i) {
              var error = $root.onnx.ValueInfoProto.verify(message.output[i]);
              if (error)
                return "output." + error;
            }
          }
          if (message.valueInfo != null && message.hasOwnProperty("valueInfo")) {
            if (!Array.isArray(message.valueInfo))
              return "valueInfo: array expected";
            for (var i = 0; i < message.valueInfo.length; ++i) {
              var error = $root.onnx.ValueInfoProto.verify(message.valueInfo[i]);
              if (error)
                return "valueInfo." + error;
            }
          }
          if (message.quantizationAnnotation != null && message.hasOwnProperty("quantizationAnnotation")) {
            if (!Array.isArray(message.quantizationAnnotation))
              return "quantizationAnnotation: array expected";
            for (var i = 0; i < message.quantizationAnnotation.length; ++i) {
              var error = $root.onnx.TensorAnnotation.verify(message.quantizationAnnotation[i]);
              if (error)
                return "quantizationAnnotation." + error;
            }
          }
          return null;
        };
        GraphProto.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.GraphProto)
            return object;
          var message = new $root.onnx.GraphProto();
          if (object.node) {
            if (!Array.isArray(object.node))
              throw TypeError(".onnx.GraphProto.node: array expected");
            message.node = [];
            for (var i = 0; i < object.node.length; ++i) {
              if (typeof object.node[i] !== "object")
                throw TypeError(".onnx.GraphProto.node: object expected");
              message.node[i] = $root.onnx.NodeProto.fromObject(object.node[i]);
            }
          }
          if (object.name != null)
            message.name = String(object.name);
          if (object.initializer) {
            if (!Array.isArray(object.initializer))
              throw TypeError(".onnx.GraphProto.initializer: array expected");
            message.initializer = [];
            for (var i = 0; i < object.initializer.length; ++i) {
              if (typeof object.initializer[i] !== "object")
                throw TypeError(".onnx.GraphProto.initializer: object expected");
              message.initializer[i] = $root.onnx.TensorProto.fromObject(object.initializer[i]);
            }
          }
          if (object.sparseInitializer) {
            if (!Array.isArray(object.sparseInitializer))
              throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");
            message.sparseInitializer = [];
            for (var i = 0; i < object.sparseInitializer.length; ++i) {
              if (typeof object.sparseInitializer[i] !== "object")
                throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");
              message.sparseInitializer[i] = $root.onnx.SparseTensorProto.fromObject(object.sparseInitializer[i]);
            }
          }
          if (object.docString != null)
            message.docString = String(object.docString);
          if (object.input) {
            if (!Array.isArray(object.input))
              throw TypeError(".onnx.GraphProto.input: array expected");
            message.input = [];
            for (var i = 0; i < object.input.length; ++i) {
              if (typeof object.input[i] !== "object")
                throw TypeError(".onnx.GraphProto.input: object expected");
              message.input[i] = $root.onnx.ValueInfoProto.fromObject(object.input[i]);
            }
          }
          if (object.output) {
            if (!Array.isArray(object.output))
              throw TypeError(".onnx.GraphProto.output: array expected");
            message.output = [];
            for (var i = 0; i < object.output.length; ++i) {
              if (typeof object.output[i] !== "object")
                throw TypeError(".onnx.GraphProto.output: object expected");
              message.output[i] = $root.onnx.ValueInfoProto.fromObject(object.output[i]);
            }
          }
          if (object.valueInfo) {
            if (!Array.isArray(object.valueInfo))
              throw TypeError(".onnx.GraphProto.valueInfo: array expected");
            message.valueInfo = [];
            for (var i = 0; i < object.valueInfo.length; ++i) {
              if (typeof object.valueInfo[i] !== "object")
                throw TypeError(".onnx.GraphProto.valueInfo: object expected");
              message.valueInfo[i] = $root.onnx.ValueInfoProto.fromObject(object.valueInfo[i]);
            }
          }
          if (object.quantizationAnnotation) {
            if (!Array.isArray(object.quantizationAnnotation))
              throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");
            message.quantizationAnnotation = [];
            for (var i = 0; i < object.quantizationAnnotation.length; ++i) {
              if (typeof object.quantizationAnnotation[i] !== "object")
                throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");
              message.quantizationAnnotation[i] = $root.onnx.TensorAnnotation.fromObject(object.quantizationAnnotation[i]);
            }
          }
          return message;
        };
        GraphProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.node = [];
            object.initializer = [];
            object.input = [];
            object.output = [];
            object.valueInfo = [];
            object.quantizationAnnotation = [];
            object.sparseInitializer = [];
          }
          if (options.defaults) {
            object.name = "";
            object.docString = "";
          }
          if (message.node && message.node.length) {
            object.node = [];
            for (var j = 0; j < message.node.length; ++j)
              object.node[j] = $root.onnx.NodeProto.toObject(message.node[j], options);
          }
          if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
          if (message.initializer && message.initializer.length) {
            object.initializer = [];
            for (var j = 0; j < message.initializer.length; ++j)
              object.initializer[j] = $root.onnx.TensorProto.toObject(message.initializer[j], options);
          }
          if (message.docString != null && message.hasOwnProperty("docString"))
            object.docString = message.docString;
          if (message.input && message.input.length) {
            object.input = [];
            for (var j = 0; j < message.input.length; ++j)
              object.input[j] = $root.onnx.ValueInfoProto.toObject(message.input[j], options);
          }
          if (message.output && message.output.length) {
            object.output = [];
            for (var j = 0; j < message.output.length; ++j)
              object.output[j] = $root.onnx.ValueInfoProto.toObject(message.output[j], options);
          }
          if (message.valueInfo && message.valueInfo.length) {
            object.valueInfo = [];
            for (var j = 0; j < message.valueInfo.length; ++j)
              object.valueInfo[j] = $root.onnx.ValueInfoProto.toObject(message.valueInfo[j], options);
          }
          if (message.quantizationAnnotation && message.quantizationAnnotation.length) {
            object.quantizationAnnotation = [];
            for (var j = 0; j < message.quantizationAnnotation.length; ++j)
              object.quantizationAnnotation[j] = $root.onnx.TensorAnnotation.toObject(message.quantizationAnnotation[j], options);
          }
          if (message.sparseInitializer && message.sparseInitializer.length) {
            object.sparseInitializer = [];
            for (var j = 0; j < message.sparseInitializer.length; ++j)
              object.sparseInitializer[j] = $root.onnx.SparseTensorProto.toObject(message.sparseInitializer[j], options);
          }
          return object;
        };
        GraphProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        GraphProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.GraphProto";
        };
        return GraphProto;
      }();
      onnx6.TensorProto = function() {
        function TensorProto(properties) {
          this.dims = [];
          this.floatData = [];
          this.int32Data = [];
          this.stringData = [];
          this.int64Data = [];
          this.externalData = [];
          this.doubleData = [];
          this.uint64Data = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        TensorProto.prototype.dims = $util.emptyArray;
        TensorProto.prototype.dataType = 0;
        TensorProto.prototype.segment = null;
        TensorProto.prototype.floatData = $util.emptyArray;
        TensorProto.prototype.int32Data = $util.emptyArray;
        TensorProto.prototype.stringData = $util.emptyArray;
        TensorProto.prototype.int64Data = $util.emptyArray;
        TensorProto.prototype.name = "";
        TensorProto.prototype.docString = "";
        TensorProto.prototype.rawData = $util.newBuffer([]);
        TensorProto.prototype.externalData = $util.emptyArray;
        TensorProto.prototype.dataLocation = 0;
        TensorProto.prototype.doubleData = $util.emptyArray;
        TensorProto.prototype.uint64Data = $util.emptyArray;
        TensorProto.create = function create(properties) {
          return new TensorProto(properties);
        };
        TensorProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.dims != null && message.dims.length) {
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork();
            for (var i = 0; i < message.dims.length; ++i)
              writer.int64(message.dims[i]);
            writer.ldelim();
          }
          if (message.dataType != null && Object.hasOwnProperty.call(message, "dataType"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int32(message.dataType);
          if (message.segment != null && Object.hasOwnProperty.call(message, "segment"))
            $root.onnx.TensorProto.Segment.encode(message.segment, writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork()).ldelim();
          if (message.floatData != null && message.floatData.length) {
            writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork();
            for (var i = 0; i < message.floatData.length; ++i)
              writer.float(message.floatData[i]);
            writer.ldelim();
          }
          if (message.int32Data != null && message.int32Data.length) {
            writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork();
            for (var i = 0; i < message.int32Data.length; ++i)
              writer.int32(message.int32Data[i]);
            writer.ldelim();
          }
          if (message.stringData != null && message.stringData.length)
            for (var i = 0; i < message.stringData.length; ++i)
              writer.uint32(
                /* id 6, wireType 2 =*/
                50
              ).bytes(message.stringData[i]);
          if (message.int64Data != null && message.int64Data.length) {
            writer.uint32(
              /* id 7, wireType 2 =*/
              58
            ).fork();
            for (var i = 0; i < message.int64Data.length; ++i)
              writer.int64(message.int64Data[i]);
            writer.ldelim();
          }
          if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(
              /* id 8, wireType 2 =*/
              66
            ).string(message.name);
          if (message.rawData != null && Object.hasOwnProperty.call(message, "rawData"))
            writer.uint32(
              /* id 9, wireType 2 =*/
              74
            ).bytes(message.rawData);
          if (message.doubleData != null && message.doubleData.length) {
            writer.uint32(
              /* id 10, wireType 2 =*/
              82
            ).fork();
            for (var i = 0; i < message.doubleData.length; ++i)
              writer.double(message.doubleData[i]);
            writer.ldelim();
          }
          if (message.uint64Data != null && message.uint64Data.length) {
            writer.uint32(
              /* id 11, wireType 2 =*/
              90
            ).fork();
            for (var i = 0; i < message.uint64Data.length; ++i)
              writer.uint64(message.uint64Data[i]);
            writer.ldelim();
          }
          if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
            writer.uint32(
              /* id 12, wireType 2 =*/
              98
            ).string(message.docString);
          if (message.externalData != null && message.externalData.length)
            for (var i = 0; i < message.externalData.length; ++i)
              $root.onnx.StringStringEntryProto.encode(message.externalData[i], writer.uint32(
                /* id 13, wireType 2 =*/
                106
              ).fork()).ldelim();
          if (message.dataLocation != null && Object.hasOwnProperty.call(message, "dataLocation"))
            writer.uint32(
              /* id 14, wireType 0 =*/
              112
            ).int32(message.dataLocation);
          return writer;
        };
        TensorProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        TensorProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TensorProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (!(message.dims && message.dims.length))
                  message.dims = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.dims.push(reader.int64());
                } else
                  message.dims.push(reader.int64());
                break;
              }
              case 2: {
                message.dataType = reader.int32();
                break;
              }
              case 3: {
                message.segment = $root.onnx.TensorProto.Segment.decode(reader, reader.uint32());
                break;
              }
              case 4: {
                if (!(message.floatData && message.floatData.length))
                  message.floatData = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.floatData.push(reader.float());
                } else
                  message.floatData.push(reader.float());
                break;
              }
              case 5: {
                if (!(message.int32Data && message.int32Data.length))
                  message.int32Data = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.int32Data.push(reader.int32());
                } else
                  message.int32Data.push(reader.int32());
                break;
              }
              case 6: {
                if (!(message.stringData && message.stringData.length))
                  message.stringData = [];
                message.stringData.push(reader.bytes());
                break;
              }
              case 7: {
                if (!(message.int64Data && message.int64Data.length))
                  message.int64Data = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.int64Data.push(reader.int64());
                } else
                  message.int64Data.push(reader.int64());
                break;
              }
              case 8: {
                message.name = reader.string();
                break;
              }
              case 12: {
                message.docString = reader.string();
                break;
              }
              case 9: {
                message.rawData = reader.bytes();
                break;
              }
              case 13: {
                if (!(message.externalData && message.externalData.length))
                  message.externalData = [];
                message.externalData.push($root.onnx.StringStringEntryProto.decode(reader, reader.uint32()));
                break;
              }
              case 14: {
                message.dataLocation = reader.int32();
                break;
              }
              case 10: {
                if (!(message.doubleData && message.doubleData.length))
                  message.doubleData = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.doubleData.push(reader.double());
                } else
                  message.doubleData.push(reader.double());
                break;
              }
              case 11: {
                if (!(message.uint64Data && message.uint64Data.length))
                  message.uint64Data = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.uint64Data.push(reader.uint64());
                } else
                  message.uint64Data.push(reader.uint64());
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        TensorProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        TensorProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.dims != null && message.hasOwnProperty("dims")) {
            if (!Array.isArray(message.dims))
              return "dims: array expected";
            for (var i = 0; i < message.dims.length; ++i)
              if (!$util.isInteger(message.dims[i]) && !(message.dims[i] && $util.isInteger(message.dims[i].low) && $util.isInteger(message.dims[i].high)))
                return "dims: integer|Long[] expected";
          }
          if (message.dataType != null && message.hasOwnProperty("dataType")) {
            if (!$util.isInteger(message.dataType))
              return "dataType: integer expected";
          }
          if (message.segment != null && message.hasOwnProperty("segment")) {
            var error = $root.onnx.TensorProto.Segment.verify(message.segment);
            if (error)
              return "segment." + error;
          }
          if (message.floatData != null && message.hasOwnProperty("floatData")) {
            if (!Array.isArray(message.floatData))
              return "floatData: array expected";
            for (var i = 0; i < message.floatData.length; ++i)
              if (typeof message.floatData[i] !== "number")
                return "floatData: number[] expected";
          }
          if (message.int32Data != null && message.hasOwnProperty("int32Data")) {
            if (!Array.isArray(message.int32Data))
              return "int32Data: array expected";
            for (var i = 0; i < message.int32Data.length; ++i)
              if (!$util.isInteger(message.int32Data[i]))
                return "int32Data: integer[] expected";
          }
          if (message.stringData != null && message.hasOwnProperty("stringData")) {
            if (!Array.isArray(message.stringData))
              return "stringData: array expected";
            for (var i = 0; i < message.stringData.length; ++i)
              if (!(message.stringData[i] && typeof message.stringData[i].length === "number" || $util.isString(message.stringData[i])))
                return "stringData: buffer[] expected";
          }
          if (message.int64Data != null && message.hasOwnProperty("int64Data")) {
            if (!Array.isArray(message.int64Data))
              return "int64Data: array expected";
            for (var i = 0; i < message.int64Data.length; ++i)
              if (!$util.isInteger(message.int64Data[i]) && !(message.int64Data[i] && $util.isInteger(message.int64Data[i].low) && $util.isInteger(message.int64Data[i].high)))
                return "int64Data: integer|Long[] expected";
          }
          if (message.name != null && message.hasOwnProperty("name")) {
            if (!$util.isString(message.name))
              return "name: string expected";
          }
          if (message.docString != null && message.hasOwnProperty("docString")) {
            if (!$util.isString(message.docString))
              return "docString: string expected";
          }
          if (message.rawData != null && message.hasOwnProperty("rawData")) {
            if (!(message.rawData && typeof message.rawData.length === "number" || $util.isString(message.rawData)))
              return "rawData: buffer expected";
          }
          if (message.externalData != null && message.hasOwnProperty("externalData")) {
            if (!Array.isArray(message.externalData))
              return "externalData: array expected";
            for (var i = 0; i < message.externalData.length; ++i) {
              var error = $root.onnx.StringStringEntryProto.verify(message.externalData[i]);
              if (error)
                return "externalData." + error;
            }
          }
          if (message.dataLocation != null && message.hasOwnProperty("dataLocation"))
            switch (message.dataLocation) {
              default:
                return "dataLocation: enum value expected";
              case 0:
              case 1:
                break;
            }
          if (message.doubleData != null && message.hasOwnProperty("doubleData")) {
            if (!Array.isArray(message.doubleData))
              return "doubleData: array expected";
            for (var i = 0; i < message.doubleData.length; ++i)
              if (typeof message.doubleData[i] !== "number")
                return "doubleData: number[] expected";
          }
          if (message.uint64Data != null && message.hasOwnProperty("uint64Data")) {
            if (!Array.isArray(message.uint64Data))
              return "uint64Data: array expected";
            for (var i = 0; i < message.uint64Data.length; ++i)
              if (!$util.isInteger(message.uint64Data[i]) && !(message.uint64Data[i] && $util.isInteger(message.uint64Data[i].low) && $util.isInteger(message.uint64Data[i].high)))
                return "uint64Data: integer|Long[] expected";
          }
          return null;
        };
        TensorProto.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.TensorProto)
            return object;
          var message = new $root.onnx.TensorProto();
          if (object.dims) {
            if (!Array.isArray(object.dims))
              throw TypeError(".onnx.TensorProto.dims: array expected");
            message.dims = [];
            for (var i = 0; i < object.dims.length; ++i)
              if ($util.Long)
                (message.dims[i] = $util.Long.fromValue(object.dims[i])).unsigned = false;
              else if (typeof object.dims[i] === "string")
                message.dims[i] = parseInt(object.dims[i], 10);
              else if (typeof object.dims[i] === "number")
                message.dims[i] = object.dims[i];
              else if (typeof object.dims[i] === "object")
                message.dims[i] = new $util.LongBits(object.dims[i].low >>> 0, object.dims[i].high >>> 0).toNumber();
          }
          if (object.dataType != null)
            message.dataType = object.dataType | 0;
          if (object.segment != null) {
            if (typeof object.segment !== "object")
              throw TypeError(".onnx.TensorProto.segment: object expected");
            message.segment = $root.onnx.TensorProto.Segment.fromObject(object.segment);
          }
          if (object.floatData) {
            if (!Array.isArray(object.floatData))
              throw TypeError(".onnx.TensorProto.floatData: array expected");
            message.floatData = [];
            for (var i = 0; i < object.floatData.length; ++i)
              message.floatData[i] = Number(object.floatData[i]);
          }
          if (object.int32Data) {
            if (!Array.isArray(object.int32Data))
              throw TypeError(".onnx.TensorProto.int32Data: array expected");
            message.int32Data = [];
            for (var i = 0; i < object.int32Data.length; ++i)
              message.int32Data[i] = object.int32Data[i] | 0;
          }
          if (object.stringData) {
            if (!Array.isArray(object.stringData))
              throw TypeError(".onnx.TensorProto.stringData: array expected");
            message.stringData = [];
            for (var i = 0; i < object.stringData.length; ++i)
              if (typeof object.stringData[i] === "string")
                $util.base64.decode(object.stringData[i], message.stringData[i] = $util.newBuffer($util.base64.length(object.stringData[i])), 0);
              else if (object.stringData[i].length >= 0)
                message.stringData[i] = object.stringData[i];
          }
          if (object.int64Data) {
            if (!Array.isArray(object.int64Data))
              throw TypeError(".onnx.TensorProto.int64Data: array expected");
            message.int64Data = [];
            for (var i = 0; i < object.int64Data.length; ++i)
              if ($util.Long)
                (message.int64Data[i] = $util.Long.fromValue(object.int64Data[i])).unsigned = false;
              else if (typeof object.int64Data[i] === "string")
                message.int64Data[i] = parseInt(object.int64Data[i], 10);
              else if (typeof object.int64Data[i] === "number")
                message.int64Data[i] = object.int64Data[i];
              else if (typeof object.int64Data[i] === "object")
                message.int64Data[i] = new $util.LongBits(object.int64Data[i].low >>> 0, object.int64Data[i].high >>> 0).toNumber();
          }
          if (object.name != null)
            message.name = String(object.name);
          if (object.docString != null)
            message.docString = String(object.docString);
          if (object.rawData != null) {
            if (typeof object.rawData === "string")
              $util.base64.decode(object.rawData, message.rawData = $util.newBuffer($util.base64.length(object.rawData)), 0);
            else if (object.rawData.length >= 0)
              message.rawData = object.rawData;
          }
          if (object.externalData) {
            if (!Array.isArray(object.externalData))
              throw TypeError(".onnx.TensorProto.externalData: array expected");
            message.externalData = [];
            for (var i = 0; i < object.externalData.length; ++i) {
              if (typeof object.externalData[i] !== "object")
                throw TypeError(".onnx.TensorProto.externalData: object expected");
              message.externalData[i] = $root.onnx.StringStringEntryProto.fromObject(object.externalData[i]);
            }
          }
          switch (object.dataLocation) {
            default:
              if (typeof object.dataLocation === "number") {
                message.dataLocation = object.dataLocation;
                break;
              }
              break;
            case "DEFAULT":
            case 0:
              message.dataLocation = 0;
              break;
            case "EXTERNAL":
            case 1:
              message.dataLocation = 1;
              break;
          }
          if (object.doubleData) {
            if (!Array.isArray(object.doubleData))
              throw TypeError(".onnx.TensorProto.doubleData: array expected");
            message.doubleData = [];
            for (var i = 0; i < object.doubleData.length; ++i)
              message.doubleData[i] = Number(object.doubleData[i]);
          }
          if (object.uint64Data) {
            if (!Array.isArray(object.uint64Data))
              throw TypeError(".onnx.TensorProto.uint64Data: array expected");
            message.uint64Data = [];
            for (var i = 0; i < object.uint64Data.length; ++i)
              if ($util.Long)
                (message.uint64Data[i] = $util.Long.fromValue(object.uint64Data[i])).unsigned = true;
              else if (typeof object.uint64Data[i] === "string")
                message.uint64Data[i] = parseInt(object.uint64Data[i], 10);
              else if (typeof object.uint64Data[i] === "number")
                message.uint64Data[i] = object.uint64Data[i];
              else if (typeof object.uint64Data[i] === "object")
                message.uint64Data[i] = new $util.LongBits(object.uint64Data[i].low >>> 0, object.uint64Data[i].high >>> 0).toNumber(true);
          }
          return message;
        };
        TensorProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.dims = [];
            object.floatData = [];
            object.int32Data = [];
            object.stringData = [];
            object.int64Data = [];
            object.doubleData = [];
            object.uint64Data = [];
            object.externalData = [];
          }
          if (options.defaults) {
            object.dataType = 0;
            object.segment = null;
            object.name = "";
            if (options.bytes === String)
              object.rawData = "";
            else {
              object.rawData = [];
              if (options.bytes !== Array)
                object.rawData = $util.newBuffer(object.rawData);
            }
            object.docString = "";
            object.dataLocation = options.enums === String ? "DEFAULT" : 0;
          }
          if (message.dims && message.dims.length) {
            object.dims = [];
            for (var j = 0; j < message.dims.length; ++j)
              if (typeof message.dims[j] === "number")
                object.dims[j] = options.longs === String ? String(message.dims[j]) : message.dims[j];
              else
                object.dims[j] = options.longs === String ? $util.Long.prototype.toString.call(message.dims[j]) : options.longs === Number ? new $util.LongBits(message.dims[j].low >>> 0, message.dims[j].high >>> 0).toNumber() : message.dims[j];
          }
          if (message.dataType != null && message.hasOwnProperty("dataType"))
            object.dataType = message.dataType;
          if (message.segment != null && message.hasOwnProperty("segment"))
            object.segment = $root.onnx.TensorProto.Segment.toObject(message.segment, options);
          if (message.floatData && message.floatData.length) {
            object.floatData = [];
            for (var j = 0; j < message.floatData.length; ++j)
              object.floatData[j] = options.json && !isFinite(message.floatData[j]) ? String(message.floatData[j]) : message.floatData[j];
          }
          if (message.int32Data && message.int32Data.length) {
            object.int32Data = [];
            for (var j = 0; j < message.int32Data.length; ++j)
              object.int32Data[j] = message.int32Data[j];
          }
          if (message.stringData && message.stringData.length) {
            object.stringData = [];
            for (var j = 0; j < message.stringData.length; ++j)
              object.stringData[j] = options.bytes === String ? $util.base64.encode(message.stringData[j], 0, message.stringData[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.stringData[j]) : message.stringData[j];
          }
          if (message.int64Data && message.int64Data.length) {
            object.int64Data = [];
            for (var j = 0; j < message.int64Data.length; ++j)
              if (typeof message.int64Data[j] === "number")
                object.int64Data[j] = options.longs === String ? String(message.int64Data[j]) : message.int64Data[j];
              else
                object.int64Data[j] = options.longs === String ? $util.Long.prototype.toString.call(message.int64Data[j]) : options.longs === Number ? new $util.LongBits(message.int64Data[j].low >>> 0, message.int64Data[j].high >>> 0).toNumber() : message.int64Data[j];
          }
          if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
          if (message.rawData != null && message.hasOwnProperty("rawData"))
            object.rawData = options.bytes === String ? $util.base64.encode(message.rawData, 0, message.rawData.length) : options.bytes === Array ? Array.prototype.slice.call(message.rawData) : message.rawData;
          if (message.doubleData && message.doubleData.length) {
            object.doubleData = [];
            for (var j = 0; j < message.doubleData.length; ++j)
              object.doubleData[j] = options.json && !isFinite(message.doubleData[j]) ? String(message.doubleData[j]) : message.doubleData[j];
          }
          if (message.uint64Data && message.uint64Data.length) {
            object.uint64Data = [];
            for (var j = 0; j < message.uint64Data.length; ++j)
              if (typeof message.uint64Data[j] === "number")
                object.uint64Data[j] = options.longs === String ? String(message.uint64Data[j]) : message.uint64Data[j];
              else
                object.uint64Data[j] = options.longs === String ? $util.Long.prototype.toString.call(message.uint64Data[j]) : options.longs === Number ? new $util.LongBits(message.uint64Data[j].low >>> 0, message.uint64Data[j].high >>> 0).toNumber(true) : message.uint64Data[j];
          }
          if (message.docString != null && message.hasOwnProperty("docString"))
            object.docString = message.docString;
          if (message.externalData && message.externalData.length) {
            object.externalData = [];
            for (var j = 0; j < message.externalData.length; ++j)
              object.externalData[j] = $root.onnx.StringStringEntryProto.toObject(message.externalData[j], options);
          }
          if (message.dataLocation != null && message.hasOwnProperty("dataLocation"))
            object.dataLocation = options.enums === String ? $root.onnx.TensorProto.DataLocation[message.dataLocation] === void 0 ? message.dataLocation : $root.onnx.TensorProto.DataLocation[message.dataLocation] : message.dataLocation;
          return object;
        };
        TensorProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        TensorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.TensorProto";
        };
        TensorProto.DataType = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "UNDEFINED"] = 0;
          values[valuesById[1] = "FLOAT"] = 1;
          values[valuesById[2] = "UINT8"] = 2;
          values[valuesById[3] = "INT8"] = 3;
          values[valuesById[4] = "UINT16"] = 4;
          values[valuesById[5] = "INT16"] = 5;
          values[valuesById[6] = "INT32"] = 6;
          values[valuesById[7] = "INT64"] = 7;
          values[valuesById[8] = "STRING"] = 8;
          values[valuesById[9] = "BOOL"] = 9;
          values[valuesById[10] = "FLOAT16"] = 10;
          values[valuesById[11] = "DOUBLE"] = 11;
          values[valuesById[12] = "UINT32"] = 12;
          values[valuesById[13] = "UINT64"] = 13;
          values[valuesById[14] = "COMPLEX64"] = 14;
          values[valuesById[15] = "COMPLEX128"] = 15;
          values[valuesById[16] = "BFLOAT16"] = 16;
          values[valuesById[17] = "FLOAT8E4M3FN"] = 17;
          values[valuesById[18] = "FLOAT8E4M3FNUZ"] = 18;
          values[valuesById[19] = "FLOAT8E5M2"] = 19;
          values[valuesById[20] = "FLOAT8E5M2FNUZ"] = 20;
          return values;
        }();
        TensorProto.Segment = function() {
          function Segment(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          Segment.prototype.begin = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          Segment.prototype.end = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
          Segment.create = function create(properties) {
            return new Segment(properties);
          };
          Segment.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.begin != null && Object.hasOwnProperty.call(message, "begin"))
              writer.uint32(
                /* id 1, wireType 0 =*/
                8
              ).int64(message.begin);
            if (message.end != null && Object.hasOwnProperty.call(message, "end"))
              writer.uint32(
                /* id 2, wireType 0 =*/
                16
              ).int64(message.end);
            return writer;
          };
          Segment.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          Segment.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TensorProto.Segment();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.begin = reader.int64();
                  break;
                }
                case 2: {
                  message.end = reader.int64();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          Segment.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          Segment.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.begin != null && message.hasOwnProperty("begin")) {
              if (!$util.isInteger(message.begin) && !(message.begin && $util.isInteger(message.begin.low) && $util.isInteger(message.begin.high)))
                return "begin: integer|Long expected";
            }
            if (message.end != null && message.hasOwnProperty("end")) {
              if (!$util.isInteger(message.end) && !(message.end && $util.isInteger(message.end.low) && $util.isInteger(message.end.high)))
                return "end: integer|Long expected";
            }
            return null;
          };
          Segment.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TensorProto.Segment)
              return object;
            var message = new $root.onnx.TensorProto.Segment();
            if (object.begin != null) {
              if ($util.Long)
                (message.begin = $util.Long.fromValue(object.begin)).unsigned = false;
              else if (typeof object.begin === "string")
                message.begin = parseInt(object.begin, 10);
              else if (typeof object.begin === "number")
                message.begin = object.begin;
              else if (typeof object.begin === "object")
                message.begin = new $util.LongBits(object.begin.low >>> 0, object.begin.high >>> 0).toNumber();
            }
            if (object.end != null) {
              if ($util.Long)
                (message.end = $util.Long.fromValue(object.end)).unsigned = false;
              else if (typeof object.end === "string")
                message.end = parseInt(object.end, 10);
              else if (typeof object.end === "number")
                message.end = object.end;
              else if (typeof object.end === "object")
                message.end = new $util.LongBits(object.end.low >>> 0, object.end.high >>> 0).toNumber();
            }
            return message;
          };
          Segment.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.begin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.begin = options.longs === String ? "0" : 0;
              if ($util.Long) {
                var long = new $util.Long(0, 0, false);
                object.end = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
              } else
                object.end = options.longs === String ? "0" : 0;
            }
            if (message.begin != null && message.hasOwnProperty("begin"))
              if (typeof message.begin === "number")
                object.begin = options.longs === String ? String(message.begin) : message.begin;
              else
                object.begin = options.longs === String ? $util.Long.prototype.toString.call(message.begin) : options.longs === Number ? new $util.LongBits(message.begin.low >>> 0, message.begin.high >>> 0).toNumber() : message.begin;
            if (message.end != null && message.hasOwnProperty("end"))
              if (typeof message.end === "number")
                object.end = options.longs === String ? String(message.end) : message.end;
              else
                object.end = options.longs === String ? $util.Long.prototype.toString.call(message.end) : options.longs === Number ? new $util.LongBits(message.end.low >>> 0, message.end.high >>> 0).toNumber() : message.end;
            return object;
          };
          Segment.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          Segment.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.TensorProto.Segment";
          };
          return Segment;
        }();
        TensorProto.DataLocation = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "DEFAULT"] = 0;
          values[valuesById[1] = "EXTERNAL"] = 1;
          return values;
        }();
        return TensorProto;
      }();
      onnx6.SparseTensorProto = function() {
        function SparseTensorProto(properties) {
          this.dims = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        SparseTensorProto.prototype.values = null;
        SparseTensorProto.prototype.indices = null;
        SparseTensorProto.prototype.dims = $util.emptyArray;
        SparseTensorProto.create = function create(properties) {
          return new SparseTensorProto(properties);
        };
        SparseTensorProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.values != null && Object.hasOwnProperty.call(message, "values"))
            $root.onnx.TensorProto.encode(message.values, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.indices != null && Object.hasOwnProperty.call(message, "indices"))
            $root.onnx.TensorProto.encode(message.indices, writer.uint32(
              /* id 2, wireType 2 =*/
              18
            ).fork()).ldelim();
          if (message.dims != null && message.dims.length) {
            writer.uint32(
              /* id 3, wireType 2 =*/
              26
            ).fork();
            for (var i = 0; i < message.dims.length; ++i)
              writer.int64(message.dims[i]);
            writer.ldelim();
          }
          return writer;
        };
        SparseTensorProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        SparseTensorProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.SparseTensorProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.values = $root.onnx.TensorProto.decode(reader, reader.uint32());
                break;
              }
              case 2: {
                message.indices = $root.onnx.TensorProto.decode(reader, reader.uint32());
                break;
              }
              case 3: {
                if (!(message.dims && message.dims.length))
                  message.dims = [];
                if ((tag & 7) === 2) {
                  var end2 = reader.uint32() + reader.pos;
                  while (reader.pos < end2)
                    message.dims.push(reader.int64());
                } else
                  message.dims.push(reader.int64());
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        SparseTensorProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        SparseTensorProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.values != null && message.hasOwnProperty("values")) {
            var error = $root.onnx.TensorProto.verify(message.values);
            if (error)
              return "values." + error;
          }
          if (message.indices != null && message.hasOwnProperty("indices")) {
            var error = $root.onnx.TensorProto.verify(message.indices);
            if (error)
              return "indices." + error;
          }
          if (message.dims != null && message.hasOwnProperty("dims")) {
            if (!Array.isArray(message.dims))
              return "dims: array expected";
            for (var i = 0; i < message.dims.length; ++i)
              if (!$util.isInteger(message.dims[i]) && !(message.dims[i] && $util.isInteger(message.dims[i].low) && $util.isInteger(message.dims[i].high)))
                return "dims: integer|Long[] expected";
          }
          return null;
        };
        SparseTensorProto.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.SparseTensorProto)
            return object;
          var message = new $root.onnx.SparseTensorProto();
          if (object.values != null) {
            if (typeof object.values !== "object")
              throw TypeError(".onnx.SparseTensorProto.values: object expected");
            message.values = $root.onnx.TensorProto.fromObject(object.values);
          }
          if (object.indices != null) {
            if (typeof object.indices !== "object")
              throw TypeError(".onnx.SparseTensorProto.indices: object expected");
            message.indices = $root.onnx.TensorProto.fromObject(object.indices);
          }
          if (object.dims) {
            if (!Array.isArray(object.dims))
              throw TypeError(".onnx.SparseTensorProto.dims: array expected");
            message.dims = [];
            for (var i = 0; i < object.dims.length; ++i)
              if ($util.Long)
                (message.dims[i] = $util.Long.fromValue(object.dims[i])).unsigned = false;
              else if (typeof object.dims[i] === "string")
                message.dims[i] = parseInt(object.dims[i], 10);
              else if (typeof object.dims[i] === "number")
                message.dims[i] = object.dims[i];
              else if (typeof object.dims[i] === "object")
                message.dims[i] = new $util.LongBits(object.dims[i].low >>> 0, object.dims[i].high >>> 0).toNumber();
          }
          return message;
        };
        SparseTensorProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.dims = [];
          if (options.defaults) {
            object.values = null;
            object.indices = null;
          }
          if (message.values != null && message.hasOwnProperty("values"))
            object.values = $root.onnx.TensorProto.toObject(message.values, options);
          if (message.indices != null && message.hasOwnProperty("indices"))
            object.indices = $root.onnx.TensorProto.toObject(message.indices, options);
          if (message.dims && message.dims.length) {
            object.dims = [];
            for (var j = 0; j < message.dims.length; ++j)
              if (typeof message.dims[j] === "number")
                object.dims[j] = options.longs === String ? String(message.dims[j]) : message.dims[j];
              else
                object.dims[j] = options.longs === String ? $util.Long.prototype.toString.call(message.dims[j]) : options.longs === Number ? new $util.LongBits(message.dims[j].low >>> 0, message.dims[j].high >>> 0).toNumber() : message.dims[j];
          }
          return object;
        };
        SparseTensorProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        SparseTensorProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.SparseTensorProto";
        };
        return SparseTensorProto;
      }();
      onnx6.TensorShapeProto = function() {
        function TensorShapeProto(properties) {
          this.dim = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        TensorShapeProto.prototype.dim = $util.emptyArray;
        TensorShapeProto.create = function create(properties) {
          return new TensorShapeProto(properties);
        };
        TensorShapeProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.dim != null && message.dim.length)
            for (var i = 0; i < message.dim.length; ++i)
              $root.onnx.TensorShapeProto.Dimension.encode(message.dim[i], writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
          return writer;
        };
        TensorShapeProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        TensorShapeProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TensorShapeProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                if (!(message.dim && message.dim.length))
                  message.dim = [];
                message.dim.push($root.onnx.TensorShapeProto.Dimension.decode(reader, reader.uint32()));
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        TensorShapeProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        TensorShapeProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.dim != null && message.hasOwnProperty("dim")) {
            if (!Array.isArray(message.dim))
              return "dim: array expected";
            for (var i = 0; i < message.dim.length; ++i) {
              var error = $root.onnx.TensorShapeProto.Dimension.verify(message.dim[i]);
              if (error)
                return "dim." + error;
            }
          }
          return null;
        };
        TensorShapeProto.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.TensorShapeProto)
            return object;
          var message = new $root.onnx.TensorShapeProto();
          if (object.dim) {
            if (!Array.isArray(object.dim))
              throw TypeError(".onnx.TensorShapeProto.dim: array expected");
            message.dim = [];
            for (var i = 0; i < object.dim.length; ++i) {
              if (typeof object.dim[i] !== "object")
                throw TypeError(".onnx.TensorShapeProto.dim: object expected");
              message.dim[i] = $root.onnx.TensorShapeProto.Dimension.fromObject(object.dim[i]);
            }
          }
          return message;
        };
        TensorShapeProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults)
            object.dim = [];
          if (message.dim && message.dim.length) {
            object.dim = [];
            for (var j = 0; j < message.dim.length; ++j)
              object.dim[j] = $root.onnx.TensorShapeProto.Dimension.toObject(message.dim[j], options);
          }
          return object;
        };
        TensorShapeProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        TensorShapeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.TensorShapeProto";
        };
        TensorShapeProto.Dimension = function() {
          function Dimension(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          Dimension.prototype.dimValue = null;
          Dimension.prototype.dimParam = null;
          Dimension.prototype.denotation = "";
          var $oneOfFields;
          Object.defineProperty(Dimension.prototype, "value", {
            get: $util.oneOfGetter($oneOfFields = ["dimValue", "dimParam"]),
            set: $util.oneOfSetter($oneOfFields)
          });
          Dimension.create = function create(properties) {
            return new Dimension(properties);
          };
          Dimension.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.dimValue != null && Object.hasOwnProperty.call(message, "dimValue"))
              writer.uint32(
                /* id 1, wireType 0 =*/
                8
              ).int64(message.dimValue);
            if (message.dimParam != null && Object.hasOwnProperty.call(message, "dimParam"))
              writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).string(message.dimParam);
            if (message.denotation != null && Object.hasOwnProperty.call(message, "denotation"))
              writer.uint32(
                /* id 3, wireType 2 =*/
                26
              ).string(message.denotation);
            return writer;
          };
          Dimension.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          Dimension.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TensorShapeProto.Dimension();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.dimValue = reader.int64();
                  break;
                }
                case 2: {
                  message.dimParam = reader.string();
                  break;
                }
                case 3: {
                  message.denotation = reader.string();
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          Dimension.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          Dimension.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            var properties = {};
            if (message.dimValue != null && message.hasOwnProperty("dimValue")) {
              properties.value = 1;
              if (!$util.isInteger(message.dimValue) && !(message.dimValue && $util.isInteger(message.dimValue.low) && $util.isInteger(message.dimValue.high)))
                return "dimValue: integer|Long expected";
            }
            if (message.dimParam != null && message.hasOwnProperty("dimParam")) {
              if (properties.value === 1)
                return "value: multiple values";
              properties.value = 1;
              if (!$util.isString(message.dimParam))
                return "dimParam: string expected";
            }
            if (message.denotation != null && message.hasOwnProperty("denotation")) {
              if (!$util.isString(message.denotation))
                return "denotation: string expected";
            }
            return null;
          };
          Dimension.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TensorShapeProto.Dimension)
              return object;
            var message = new $root.onnx.TensorShapeProto.Dimension();
            if (object.dimValue != null) {
              if ($util.Long)
                (message.dimValue = $util.Long.fromValue(object.dimValue)).unsigned = false;
              else if (typeof object.dimValue === "string")
                message.dimValue = parseInt(object.dimValue, 10);
              else if (typeof object.dimValue === "number")
                message.dimValue = object.dimValue;
              else if (typeof object.dimValue === "object")
                message.dimValue = new $util.LongBits(object.dimValue.low >>> 0, object.dimValue.high >>> 0).toNumber();
            }
            if (object.dimParam != null)
              message.dimParam = String(object.dimParam);
            if (object.denotation != null)
              message.denotation = String(object.denotation);
            return message;
          };
          Dimension.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults)
              object.denotation = "";
            if (message.dimValue != null && message.hasOwnProperty("dimValue")) {
              if (typeof message.dimValue === "number")
                object.dimValue = options.longs === String ? String(message.dimValue) : message.dimValue;
              else
                object.dimValue = options.longs === String ? $util.Long.prototype.toString.call(message.dimValue) : options.longs === Number ? new $util.LongBits(message.dimValue.low >>> 0, message.dimValue.high >>> 0).toNumber() : message.dimValue;
              if (options.oneofs)
                object.value = "dimValue";
            }
            if (message.dimParam != null && message.hasOwnProperty("dimParam")) {
              object.dimParam = message.dimParam;
              if (options.oneofs)
                object.value = "dimParam";
            }
            if (message.denotation != null && message.hasOwnProperty("denotation"))
              object.denotation = message.denotation;
            return object;
          };
          Dimension.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          Dimension.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.TensorShapeProto.Dimension";
          };
          return Dimension;
        }();
        return TensorShapeProto;
      }();
      onnx6.TypeProto = function() {
        function TypeProto(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        TypeProto.prototype.tensorType = null;
        TypeProto.prototype.sequenceType = null;
        TypeProto.prototype.mapType = null;
        TypeProto.prototype.optionalType = null;
        TypeProto.prototype.sparseTensorType = null;
        TypeProto.prototype.denotation = "";
        var $oneOfFields;
        Object.defineProperty(TypeProto.prototype, "value", {
          get: $util.oneOfGetter($oneOfFields = ["tensorType", "sequenceType", "mapType", "optionalType", "sparseTensorType"]),
          set: $util.oneOfSetter($oneOfFields)
        });
        TypeProto.create = function create(properties) {
          return new TypeProto(properties);
        };
        TypeProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.tensorType != null && Object.hasOwnProperty.call(message, "tensorType"))
            $root.onnx.TypeProto.Tensor.encode(message.tensorType, writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork()).ldelim();
          if (message.sequenceType != null && Object.hasOwnProperty.call(message, "sequenceType"))
            $root.onnx.TypeProto.Sequence.encode(message.sequenceType, writer.uint32(
              /* id 4, wireType 2 =*/
              34
            ).fork()).ldelim();
          if (message.mapType != null && Object.hasOwnProperty.call(message, "mapType"))
            $root.onnx.TypeProto.Map.encode(message.mapType, writer.uint32(
              /* id 5, wireType 2 =*/
              42
            ).fork()).ldelim();
          if (message.denotation != null && Object.hasOwnProperty.call(message, "denotation"))
            writer.uint32(
              /* id 6, wireType 2 =*/
              50
            ).string(message.denotation);
          if (message.sparseTensorType != null && Object.hasOwnProperty.call(message, "sparseTensorType"))
            $root.onnx.TypeProto.SparseTensor.encode(message.sparseTensorType, writer.uint32(
              /* id 8, wireType 2 =*/
              66
            ).fork()).ldelim();
          if (message.optionalType != null && Object.hasOwnProperty.call(message, "optionalType"))
            $root.onnx.TypeProto.Optional.encode(message.optionalType, writer.uint32(
              /* id 9, wireType 2 =*/
              74
            ).fork()).ldelim();
          return writer;
        };
        TypeProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        TypeProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.tensorType = $root.onnx.TypeProto.Tensor.decode(reader, reader.uint32());
                break;
              }
              case 4: {
                message.sequenceType = $root.onnx.TypeProto.Sequence.decode(reader, reader.uint32());
                break;
              }
              case 5: {
                message.mapType = $root.onnx.TypeProto.Map.decode(reader, reader.uint32());
                break;
              }
              case 9: {
                message.optionalType = $root.onnx.TypeProto.Optional.decode(reader, reader.uint32());
                break;
              }
              case 8: {
                message.sparseTensorType = $root.onnx.TypeProto.SparseTensor.decode(reader, reader.uint32());
                break;
              }
              case 6: {
                message.denotation = reader.string();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        TypeProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        TypeProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          var properties = {};
          if (message.tensorType != null && message.hasOwnProperty("tensorType")) {
            properties.value = 1;
            {
              var error = $root.onnx.TypeProto.Tensor.verify(message.tensorType);
              if (error)
                return "tensorType." + error;
            }
          }
          if (message.sequenceType != null && message.hasOwnProperty("sequenceType")) {
            if (properties.value === 1)
              return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.onnx.TypeProto.Sequence.verify(message.sequenceType);
              if (error)
                return "sequenceType." + error;
            }
          }
          if (message.mapType != null && message.hasOwnProperty("mapType")) {
            if (properties.value === 1)
              return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.onnx.TypeProto.Map.verify(message.mapType);
              if (error)
                return "mapType." + error;
            }
          }
          if (message.optionalType != null && message.hasOwnProperty("optionalType")) {
            if (properties.value === 1)
              return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.onnx.TypeProto.Optional.verify(message.optionalType);
              if (error)
                return "optionalType." + error;
            }
          }
          if (message.sparseTensorType != null && message.hasOwnProperty("sparseTensorType")) {
            if (properties.value === 1)
              return "value: multiple values";
            properties.value = 1;
            {
              var error = $root.onnx.TypeProto.SparseTensor.verify(message.sparseTensorType);
              if (error)
                return "sparseTensorType." + error;
            }
          }
          if (message.denotation != null && message.hasOwnProperty("denotation")) {
            if (!$util.isString(message.denotation))
              return "denotation: string expected";
          }
          return null;
        };
        TypeProto.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.TypeProto)
            return object;
          var message = new $root.onnx.TypeProto();
          if (object.tensorType != null) {
            if (typeof object.tensorType !== "object")
              throw TypeError(".onnx.TypeProto.tensorType: object expected");
            message.tensorType = $root.onnx.TypeProto.Tensor.fromObject(object.tensorType);
          }
          if (object.sequenceType != null) {
            if (typeof object.sequenceType !== "object")
              throw TypeError(".onnx.TypeProto.sequenceType: object expected");
            message.sequenceType = $root.onnx.TypeProto.Sequence.fromObject(object.sequenceType);
          }
          if (object.mapType != null) {
            if (typeof object.mapType !== "object")
              throw TypeError(".onnx.TypeProto.mapType: object expected");
            message.mapType = $root.onnx.TypeProto.Map.fromObject(object.mapType);
          }
          if (object.optionalType != null) {
            if (typeof object.optionalType !== "object")
              throw TypeError(".onnx.TypeProto.optionalType: object expected");
            message.optionalType = $root.onnx.TypeProto.Optional.fromObject(object.optionalType);
          }
          if (object.sparseTensorType != null) {
            if (typeof object.sparseTensorType !== "object")
              throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");
            message.sparseTensorType = $root.onnx.TypeProto.SparseTensor.fromObject(object.sparseTensorType);
          }
          if (object.denotation != null)
            message.denotation = String(object.denotation);
          return message;
        };
        TypeProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults)
            object.denotation = "";
          if (message.tensorType != null && message.hasOwnProperty("tensorType")) {
            object.tensorType = $root.onnx.TypeProto.Tensor.toObject(message.tensorType, options);
            if (options.oneofs)
              object.value = "tensorType";
          }
          if (message.sequenceType != null && message.hasOwnProperty("sequenceType")) {
            object.sequenceType = $root.onnx.TypeProto.Sequence.toObject(message.sequenceType, options);
            if (options.oneofs)
              object.value = "sequenceType";
          }
          if (message.mapType != null && message.hasOwnProperty("mapType")) {
            object.mapType = $root.onnx.TypeProto.Map.toObject(message.mapType, options);
            if (options.oneofs)
              object.value = "mapType";
          }
          if (message.denotation != null && message.hasOwnProperty("denotation"))
            object.denotation = message.denotation;
          if (message.sparseTensorType != null && message.hasOwnProperty("sparseTensorType")) {
            object.sparseTensorType = $root.onnx.TypeProto.SparseTensor.toObject(message.sparseTensorType, options);
            if (options.oneofs)
              object.value = "sparseTensorType";
          }
          if (message.optionalType != null && message.hasOwnProperty("optionalType")) {
            object.optionalType = $root.onnx.TypeProto.Optional.toObject(message.optionalType, options);
            if (options.oneofs)
              object.value = "optionalType";
          }
          return object;
        };
        TypeProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        TypeProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.TypeProto";
        };
        TypeProto.Tensor = function() {
          function Tensor4(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          Tensor4.prototype.elemType = 0;
          Tensor4.prototype.shape = null;
          Tensor4.create = function create(properties) {
            return new Tensor4(properties);
          };
          Tensor4.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.elemType != null && Object.hasOwnProperty.call(message, "elemType"))
              writer.uint32(
                /* id 1, wireType 0 =*/
                8
              ).int32(message.elemType);
            if (message.shape != null && Object.hasOwnProperty.call(message, "shape"))
              $root.onnx.TensorShapeProto.encode(message.shape, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            return writer;
          };
          Tensor4.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          Tensor4.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.Tensor();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.elemType = reader.int32();
                  break;
                }
                case 2: {
                  message.shape = $root.onnx.TensorShapeProto.decode(reader, reader.uint32());
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          Tensor4.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          Tensor4.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.elemType != null && message.hasOwnProperty("elemType")) {
              if (!$util.isInteger(message.elemType))
                return "elemType: integer expected";
            }
            if (message.shape != null && message.hasOwnProperty("shape")) {
              var error = $root.onnx.TensorShapeProto.verify(message.shape);
              if (error)
                return "shape." + error;
            }
            return null;
          };
          Tensor4.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TypeProto.Tensor)
              return object;
            var message = new $root.onnx.TypeProto.Tensor();
            if (object.elemType != null)
              message.elemType = object.elemType | 0;
            if (object.shape != null) {
              if (typeof object.shape !== "object")
                throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");
              message.shape = $root.onnx.TensorShapeProto.fromObject(object.shape);
            }
            return message;
          };
          Tensor4.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.elemType = 0;
              object.shape = null;
            }
            if (message.elemType != null && message.hasOwnProperty("elemType"))
              object.elemType = message.elemType;
            if (message.shape != null && message.hasOwnProperty("shape"))
              object.shape = $root.onnx.TensorShapeProto.toObject(message.shape, options);
            return object;
          };
          Tensor4.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          Tensor4.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.TypeProto.Tensor";
          };
          return Tensor4;
        }();
        TypeProto.Sequence = function() {
          function Sequence(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          Sequence.prototype.elemType = null;
          Sequence.create = function create(properties) {
            return new Sequence(properties);
          };
          Sequence.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.elemType != null && Object.hasOwnProperty.call(message, "elemType"))
              $root.onnx.TypeProto.encode(message.elemType, writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
            return writer;
          };
          Sequence.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          Sequence.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.Sequence();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.elemType = $root.onnx.TypeProto.decode(reader, reader.uint32());
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          Sequence.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          Sequence.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.elemType != null && message.hasOwnProperty("elemType")) {
              var error = $root.onnx.TypeProto.verify(message.elemType);
              if (error)
                return "elemType." + error;
            }
            return null;
          };
          Sequence.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TypeProto.Sequence)
              return object;
            var message = new $root.onnx.TypeProto.Sequence();
            if (object.elemType != null) {
              if (typeof object.elemType !== "object")
                throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");
              message.elemType = $root.onnx.TypeProto.fromObject(object.elemType);
            }
            return message;
          };
          Sequence.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults)
              object.elemType = null;
            if (message.elemType != null && message.hasOwnProperty("elemType"))
              object.elemType = $root.onnx.TypeProto.toObject(message.elemType, options);
            return object;
          };
          Sequence.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          Sequence.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.TypeProto.Sequence";
          };
          return Sequence;
        }();
        TypeProto.Map = function() {
          function Map2(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          Map2.prototype.keyType = 0;
          Map2.prototype.valueType = null;
          Map2.create = function create(properties) {
            return new Map2(properties);
          };
          Map2.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.keyType != null && Object.hasOwnProperty.call(message, "keyType"))
              writer.uint32(
                /* id 1, wireType 0 =*/
                8
              ).int32(message.keyType);
            if (message.valueType != null && Object.hasOwnProperty.call(message, "valueType"))
              $root.onnx.TypeProto.encode(message.valueType, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            return writer;
          };
          Map2.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          Map2.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.Map();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.keyType = reader.int32();
                  break;
                }
                case 2: {
                  message.valueType = $root.onnx.TypeProto.decode(reader, reader.uint32());
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          Map2.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          Map2.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.keyType != null && message.hasOwnProperty("keyType")) {
              if (!$util.isInteger(message.keyType))
                return "keyType: integer expected";
            }
            if (message.valueType != null && message.hasOwnProperty("valueType")) {
              var error = $root.onnx.TypeProto.verify(message.valueType);
              if (error)
                return "valueType." + error;
            }
            return null;
          };
          Map2.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TypeProto.Map)
              return object;
            var message = new $root.onnx.TypeProto.Map();
            if (object.keyType != null)
              message.keyType = object.keyType | 0;
            if (object.valueType != null) {
              if (typeof object.valueType !== "object")
                throw TypeError(".onnx.TypeProto.Map.valueType: object expected");
              message.valueType = $root.onnx.TypeProto.fromObject(object.valueType);
            }
            return message;
          };
          Map2.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.keyType = 0;
              object.valueType = null;
            }
            if (message.keyType != null && message.hasOwnProperty("keyType"))
              object.keyType = message.keyType;
            if (message.valueType != null && message.hasOwnProperty("valueType"))
              object.valueType = $root.onnx.TypeProto.toObject(message.valueType, options);
            return object;
          };
          Map2.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          Map2.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.TypeProto.Map";
          };
          return Map2;
        }();
        TypeProto.Optional = function() {
          function Optional(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          Optional.prototype.elemType = null;
          Optional.create = function create(properties) {
            return new Optional(properties);
          };
          Optional.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.elemType != null && Object.hasOwnProperty.call(message, "elemType"))
              $root.onnx.TypeProto.encode(message.elemType, writer.uint32(
                /* id 1, wireType 2 =*/
                10
              ).fork()).ldelim();
            return writer;
          };
          Optional.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          Optional.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.Optional();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.elemType = $root.onnx.TypeProto.decode(reader, reader.uint32());
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          Optional.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          Optional.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.elemType != null && message.hasOwnProperty("elemType")) {
              var error = $root.onnx.TypeProto.verify(message.elemType);
              if (error)
                return "elemType." + error;
            }
            return null;
          };
          Optional.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TypeProto.Optional)
              return object;
            var message = new $root.onnx.TypeProto.Optional();
            if (object.elemType != null) {
              if (typeof object.elemType !== "object")
                throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");
              message.elemType = $root.onnx.TypeProto.fromObject(object.elemType);
            }
            return message;
          };
          Optional.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults)
              object.elemType = null;
            if (message.elemType != null && message.hasOwnProperty("elemType"))
              object.elemType = $root.onnx.TypeProto.toObject(message.elemType, options);
            return object;
          };
          Optional.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          Optional.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.TypeProto.Optional";
          };
          return Optional;
        }();
        TypeProto.SparseTensor = function() {
          function SparseTensor(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          SparseTensor.prototype.elemType = 0;
          SparseTensor.prototype.shape = null;
          SparseTensor.create = function create(properties) {
            return new SparseTensor(properties);
          };
          SparseTensor.encode = function encode(message, writer) {
            if (!writer)
              writer = $Writer.create();
            if (message.elemType != null && Object.hasOwnProperty.call(message, "elemType"))
              writer.uint32(
                /* id 1, wireType 0 =*/
                8
              ).int32(message.elemType);
            if (message.shape != null && Object.hasOwnProperty.call(message, "shape"))
              $root.onnx.TensorShapeProto.encode(message.shape, writer.uint32(
                /* id 2, wireType 2 =*/
                18
              ).fork()).ldelim();
            return writer;
          };
          SparseTensor.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          SparseTensor.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
              reader = $Reader.create(reader);
            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.TypeProto.SparseTensor();
            while (reader.pos < end) {
              var tag = reader.uint32();
              switch (tag >>> 3) {
                case 1: {
                  message.elemType = reader.int32();
                  break;
                }
                case 2: {
                  message.shape = $root.onnx.TensorShapeProto.decode(reader, reader.uint32());
                  break;
                }
                default:
                  reader.skipType(tag & 7);
                  break;
              }
            }
            return message;
          };
          SparseTensor.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
              reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
          };
          SparseTensor.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.elemType != null && message.hasOwnProperty("elemType")) {
              if (!$util.isInteger(message.elemType))
                return "elemType: integer expected";
            }
            if (message.shape != null && message.hasOwnProperty("shape")) {
              var error = $root.onnx.TensorShapeProto.verify(message.shape);
              if (error)
                return "shape." + error;
            }
            return null;
          };
          SparseTensor.fromObject = function fromObject(object) {
            if (object instanceof $root.onnx.TypeProto.SparseTensor)
              return object;
            var message = new $root.onnx.TypeProto.SparseTensor();
            if (object.elemType != null)
              message.elemType = object.elemType | 0;
            if (object.shape != null) {
              if (typeof object.shape !== "object")
                throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");
              message.shape = $root.onnx.TensorShapeProto.fromObject(object.shape);
            }
            return message;
          };
          SparseTensor.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              object.elemType = 0;
              object.shape = null;
            }
            if (message.elemType != null && message.hasOwnProperty("elemType"))
              object.elemType = message.elemType;
            if (message.shape != null && message.hasOwnProperty("shape"))
              object.shape = $root.onnx.TensorShapeProto.toObject(message.shape, options);
            return object;
          };
          SparseTensor.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          SparseTensor.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === void 0) {
              typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/onnx.TypeProto.SparseTensor";
          };
          return SparseTensor;
        }();
        return TypeProto;
      }();
      onnx6.OperatorSetIdProto = function() {
        function OperatorSetIdProto(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        OperatorSetIdProto.prototype.domain = "";
        OperatorSetIdProto.prototype.version = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        OperatorSetIdProto.create = function create(properties) {
          return new OperatorSetIdProto(properties);
        };
        OperatorSetIdProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.domain);
          if (message.version != null && Object.hasOwnProperty.call(message, "version"))
            writer.uint32(
              /* id 2, wireType 0 =*/
              16
            ).int64(message.version);
          return writer;
        };
        OperatorSetIdProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        OperatorSetIdProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.OperatorSetIdProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.domain = reader.string();
                break;
              }
              case 2: {
                message.version = reader.int64();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        OperatorSetIdProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        OperatorSetIdProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.domain != null && message.hasOwnProperty("domain")) {
            if (!$util.isString(message.domain))
              return "domain: string expected";
          }
          if (message.version != null && message.hasOwnProperty("version")) {
            if (!$util.isInteger(message.version) && !(message.version && $util.isInteger(message.version.low) && $util.isInteger(message.version.high)))
              return "version: integer|Long expected";
          }
          return null;
        };
        OperatorSetIdProto.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.OperatorSetIdProto)
            return object;
          var message = new $root.onnx.OperatorSetIdProto();
          if (object.domain != null)
            message.domain = String(object.domain);
          if (object.version != null) {
            if ($util.Long)
              (message.version = $util.Long.fromValue(object.version)).unsigned = false;
            else if (typeof object.version === "string")
              message.version = parseInt(object.version, 10);
            else if (typeof object.version === "number")
              message.version = object.version;
            else if (typeof object.version === "object")
              message.version = new $util.LongBits(object.version.low >>> 0, object.version.high >>> 0).toNumber();
          }
          return message;
        };
        OperatorSetIdProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.defaults) {
            object.domain = "";
            if ($util.Long) {
              var long = new $util.Long(0, 0, false);
              object.version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
            } else
              object.version = options.longs === String ? "0" : 0;
          }
          if (message.domain != null && message.hasOwnProperty("domain"))
            object.domain = message.domain;
          if (message.version != null && message.hasOwnProperty("version"))
            if (typeof message.version === "number")
              object.version = options.longs === String ? String(message.version) : message.version;
            else
              object.version = options.longs === String ? $util.Long.prototype.toString.call(message.version) : options.longs === Number ? new $util.LongBits(message.version.low >>> 0, message.version.high >>> 0).toNumber() : message.version;
          return object;
        };
        OperatorSetIdProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        OperatorSetIdProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.OperatorSetIdProto";
        };
        return OperatorSetIdProto;
      }();
      onnx6.OperatorStatus = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "EXPERIMENTAL"] = 0;
        values[valuesById[1] = "STABLE"] = 1;
        return values;
      }();
      onnx6.FunctionProto = function() {
        function FunctionProto(properties) {
          this.input = [];
          this.output = [];
          this.attribute = [];
          this.attributeProto = [];
          this.node = [];
          this.opsetImport = [];
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
              if (properties[keys[i]] != null)
                this[keys[i]] = properties[keys[i]];
          }
        }
        FunctionProto.prototype.name = "";
        FunctionProto.prototype.input = $util.emptyArray;
        FunctionProto.prototype.output = $util.emptyArray;
        FunctionProto.prototype.attribute = $util.emptyArray;
        FunctionProto.prototype.attributeProto = $util.emptyArray;
        FunctionProto.prototype.node = $util.emptyArray;
        FunctionProto.prototype.docString = "";
        FunctionProto.prototype.opsetImport = $util.emptyArray;
        FunctionProto.prototype.domain = "";
        FunctionProto.create = function create(properties) {
          return new FunctionProto(properties);
        };
        FunctionProto.encode = function encode(message, writer) {
          if (!writer)
            writer = $Writer.create();
          if (message.name != null && Object.hasOwnProperty.call(message, "name"))
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).string(message.name);
          if (message.input != null && message.input.length)
            for (var i = 0; i < message.input.length; ++i)
              writer.uint32(
                /* id 4, wireType 2 =*/
                34
              ).string(message.input[i]);
          if (message.output != null && message.output.length)
            for (var i = 0; i < message.output.length; ++i)
              writer.uint32(
                /* id 5, wireType 2 =*/
                42
              ).string(message.output[i]);
          if (message.attribute != null && message.attribute.length)
            for (var i = 0; i < message.attribute.length; ++i)
              writer.uint32(
                /* id 6, wireType 2 =*/
                50
              ).string(message.attribute[i]);
          if (message.node != null && message.node.length)
            for (var i = 0; i < message.node.length; ++i)
              $root.onnx.NodeProto.encode(message.node[i], writer.uint32(
                /* id 7, wireType 2 =*/
                58
              ).fork()).ldelim();
          if (message.docString != null && Object.hasOwnProperty.call(message, "docString"))
            writer.uint32(
              /* id 8, wireType 2 =*/
              66
            ).string(message.docString);
          if (message.opsetImport != null && message.opsetImport.length)
            for (var i = 0; i < message.opsetImport.length; ++i)
              $root.onnx.OperatorSetIdProto.encode(message.opsetImport[i], writer.uint32(
                /* id 9, wireType 2 =*/
                74
              ).fork()).ldelim();
          if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
            writer.uint32(
              /* id 10, wireType 2 =*/
              82
            ).string(message.domain);
          if (message.attributeProto != null && message.attributeProto.length)
            for (var i = 0; i < message.attributeProto.length; ++i)
              $root.onnx.AttributeProto.encode(message.attributeProto[i], writer.uint32(
                /* id 11, wireType 2 =*/
                90
              ).fork()).ldelim();
          return writer;
        };
        FunctionProto.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        FunctionProto.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.onnx.FunctionProto();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1: {
                message.name = reader.string();
                break;
              }
              case 4: {
                if (!(message.input && message.input.length))
                  message.input = [];
                message.input.push(reader.string());
                break;
              }
              case 5: {
                if (!(message.output && message.output.length))
                  message.output = [];
                message.output.push(reader.string());
                break;
              }
              case 6: {
                if (!(message.attribute && message.attribute.length))
                  message.attribute = [];
                message.attribute.push(reader.string());
                break;
              }
              case 11: {
                if (!(message.attributeProto && message.attributeProto.length))
                  message.attributeProto = [];
                message.attributeProto.push($root.onnx.AttributeProto.decode(reader, reader.uint32()));
                break;
              }
              case 7: {
                if (!(message.node && message.node.length))
                  message.node = [];
                message.node.push($root.onnx.NodeProto.decode(reader, reader.uint32()));
                break;
              }
              case 8: {
                message.docString = reader.string();
                break;
              }
              case 9: {
                if (!(message.opsetImport && message.opsetImport.length))
                  message.opsetImport = [];
                message.opsetImport.push($root.onnx.OperatorSetIdProto.decode(reader, reader.uint32()));
                break;
              }
              case 10: {
                message.domain = reader.string();
                break;
              }
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        FunctionProto.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader))
            reader = new $Reader(reader);
          return this.decode(reader, reader.uint32());
        };
        FunctionProto.verify = function verify(message) {
          if (typeof message !== "object" || message === null)
            return "object expected";
          if (message.name != null && message.hasOwnProperty("name")) {
            if (!$util.isString(message.name))
              return "name: string expected";
          }
          if (message.input != null && message.hasOwnProperty("input")) {
            if (!Array.isArray(message.input))
              return "input: array expected";
            for (var i = 0; i < message.input.length; ++i)
              if (!$util.isString(message.input[i]))
                return "input: string[] expected";
          }
          if (message.output != null && message.hasOwnProperty("output")) {
            if (!Array.isArray(message.output))
              return "output: array expected";
            for (var i = 0; i < message.output.length; ++i)
              if (!$util.isString(message.output[i]))
                return "output: string[] expected";
          }
          if (message.attribute != null && message.hasOwnProperty("attribute")) {
            if (!Array.isArray(message.attribute))
              return "attribute: array expected";
            for (var i = 0; i < message.attribute.length; ++i)
              if (!$util.isString(message.attribute[i]))
                return "attribute: string[] expected";
          }
          if (message.attributeProto != null && message.hasOwnProperty("attributeProto")) {
            if (!Array.isArray(message.attributeProto))
              return "attributeProto: array expected";
            for (var i = 0; i < message.attributeProto.length; ++i) {
              var error = $root.onnx.AttributeProto.verify(message.attributeProto[i]);
              if (error)
                return "attributeProto." + error;
            }
          }
          if (message.node != null && message.hasOwnProperty("node")) {
            if (!Array.isArray(message.node))
              return "node: array expected";
            for (var i = 0; i < message.node.length; ++i) {
              var error = $root.onnx.NodeProto.verify(message.node[i]);
              if (error)
                return "node." + error;
            }
          }
          if (message.docString != null && message.hasOwnProperty("docString")) {
            if (!$util.isString(message.docString))
              return "docString: string expected";
          }
          if (message.opsetImport != null && message.hasOwnProperty("opsetImport")) {
            if (!Array.isArray(message.opsetImport))
              return "opsetImport: array expected";
            for (var i = 0; i < message.opsetImport.length; ++i) {
              var error = $root.onnx.OperatorSetIdProto.verify(message.opsetImport[i]);
              if (error)
                return "opsetImport." + error;
            }
          }
          if (message.domain != null && message.hasOwnProperty("domain")) {
            if (!$util.isString(message.domain))
              return "domain: string expected";
          }
          return null;
        };
        FunctionProto.fromObject = function fromObject(object) {
          if (object instanceof $root.onnx.FunctionProto)
            return object;
          var message = new $root.onnx.FunctionProto();
          if (object.name != null)
            message.name = String(object.name);
          if (object.input) {
            if (!Array.isArray(object.input))
              throw TypeError(".onnx.FunctionProto.input: array expected");
            message.input = [];
            for (var i = 0; i < object.input.length; ++i)
              message.input[i] = String(object.input[i]);
          }
          if (object.output) {
            if (!Array.isArray(object.output))
              throw TypeError(".onnx.FunctionProto.output: array expected");
            message.output = [];
            for (var i = 0; i < object.output.length; ++i)
              message.output[i] = String(object.output[i]);
          }
          if (object.attribute) {
            if (!Array.isArray(object.attribute))
              throw TypeError(".onnx.FunctionProto.attribute: array expected");
            message.attribute = [];
            for (var i = 0; i < object.attribute.length; ++i)
              message.attribute[i] = String(object.attribute[i]);
          }
          if (object.attributeProto) {
            if (!Array.isArray(object.attributeProto))
              throw TypeError(".onnx.FunctionProto.attributeProto: array expected");
            message.attributeProto = [];
            for (var i = 0; i < object.attributeProto.length; ++i) {
              if (typeof object.attributeProto[i] !== "object")
                throw TypeError(".onnx.FunctionProto.attributeProto: object expected");
              message.attributeProto[i] = $root.onnx.AttributeProto.fromObject(object.attributeProto[i]);
            }
          }
          if (object.node) {
            if (!Array.isArray(object.node))
              throw TypeError(".onnx.FunctionProto.node: array expected");
            message.node = [];
            for (var i = 0; i < object.node.length; ++i) {
              if (typeof object.node[i] !== "object")
                throw TypeError(".onnx.FunctionProto.node: object expected");
              message.node[i] = $root.onnx.NodeProto.fromObject(object.node[i]);
            }
          }
          if (object.docString != null)
            message.docString = String(object.docString);
          if (object.opsetImport) {
            if (!Array.isArray(object.opsetImport))
              throw TypeError(".onnx.FunctionProto.opsetImport: array expected");
            message.opsetImport = [];
            for (var i = 0; i < object.opsetImport.length; ++i) {
              if (typeof object.opsetImport[i] !== "object")
                throw TypeError(".onnx.FunctionProto.opsetImport: object expected");
              message.opsetImport[i] = $root.onnx.OperatorSetIdProto.fromObject(object.opsetImport[i]);
            }
          }
          if (object.domain != null)
            message.domain = String(object.domain);
          return message;
        };
        FunctionProto.toObject = function toObject(message, options) {
          if (!options)
            options = {};
          var object = {};
          if (options.arrays || options.defaults) {
            object.input = [];
            object.output = [];
            object.attribute = [];
            object.node = [];
            object.opsetImport = [];
            object.attributeProto = [];
          }
          if (options.defaults) {
            object.name = "";
            object.docString = "";
            object.domain = "";
          }
          if (message.name != null && message.hasOwnProperty("name"))
            object.name = message.name;
          if (message.input && message.input.length) {
            object.input = [];
            for (var j = 0; j < message.input.length; ++j)
              object.input[j] = message.input[j];
          }
          if (message.output && message.output.length) {
            object.output = [];
            for (var j = 0; j < message.output.length; ++j)
              object.output[j] = message.output[j];
          }
          if (message.attribute && message.attribute.length) {
            object.attribute = [];
            for (var j = 0; j < message.attribute.length; ++j)
              object.attribute[j] = message.attribute[j];
          }
          if (message.node && message.node.length) {
            object.node = [];
            for (var j = 0; j < message.node.length; ++j)
              object.node[j] = $root.onnx.NodeProto.toObject(message.node[j], options);
          }
          if (message.docString != null && message.hasOwnProperty("docString"))
            object.docString = message.docString;
          if (message.opsetImport && message.opsetImport.length) {
            object.opsetImport = [];
            for (var j = 0; j < message.opsetImport.length; ++j)
              object.opsetImport[j] = $root.onnx.OperatorSetIdProto.toObject(message.opsetImport[j], options);
          }
          if (message.domain != null && message.hasOwnProperty("domain"))
            object.domain = message.domain;
          if (message.attributeProto && message.attributeProto.length) {
            object.attributeProto = [];
            for (var j = 0; j < message.attributeProto.length; ++j)
              object.attributeProto[j] = $root.onnx.AttributeProto.toObject(message.attributeProto[j], options);
          }
          return object;
        };
        FunctionProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        FunctionProto.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
          if (typeUrlPrefix === void 0) {
            typeUrlPrefix = "type.googleapis.com";
          }
          return typeUrlPrefix + "/onnx.FunctionProto";
        };
        return FunctionProto;
      }();
      return onnx6;
    }();
    module2.exports = $root;
  }
});

// web/lib/onnxjs/util.ts
function assert(expr, msg) {
  if (!expr) {
    throw new Error(typeof msg === "string" ? msg : msg());
  }
}
function decodeUtf8String(buffer) {
  return new TextDecoder().decode(buffer);
}
var import_onnx, ArrayUtil, MatMulUtil, BroadcastUtil, GemmUtil, ProtoUtil, LongUtil, ShapeUtil, SplitUtil, PoolConvUtil, MIN_CLIP, MAX_CLIP;
var init_util = __esm({
  "web/lib/onnxjs/util.ts"() {
    "use strict";
    init_flatbuffers();
    init_long();
    import_onnx = __toESM(require_onnx());
    init_tensor2();
    ArrayUtil = class {
      /**
       * Verifies if 2 input arrays contain the same elements.
       * @param n1 Array 1
       * @param n2 Array 2
       * @returns Whether these 2 are equal
       */
      static arraysEqual(n1, n2) {
        if (n1.length !== n2.length) {
          return false;
        }
        for (let i = 0; i < n1.length; i++) {
          if (n1[i] !== n2[i]) {
            return false;
          }
        }
        return true;
      }
    };
    MatMulUtil = class {
      /**
       * Fix the input shapes for MatMul operation if they need fixing
       * @param dimsA The shape of tensor A. Should be an array of positive integers
       * @param dimsB The shape of tensor B. Should be an array of positive integers
       * @returns A tuple containing the preprocessed input shapes as required by ONNX specifications
       */
      static preprocessInputShapes(dimsA, dimsB) {
        const a = dimsA.length === 1 ? [1, dimsA[0]] : dimsA;
        const b = dimsB.length === 1 ? [dimsB[0], 1] : dimsB;
        return [a, b];
      }
      /**
       * Fix the output shape computed for MatMul operation if it needs fixing
       * @param outputShape The computed outputShape. Should be an array (atleast of length 2) of positive integers.
       * This will be mutated.
       * @param aRank The rank of tensor A.
       * @param bRank The rank of tensor B.
       */
      static postprocessOutputShape(outputShape, aRank, bRank) {
        if (aRank === 1) {
          outputShape.splice(outputShape.length - 2, 1);
        }
        if (bRank === 1) {
          outputShape.pop();
        }
      }
      /**
       * Calculate the expected shape when matrix multiplication
       * @param a The shape of tensor A. Should be a tuple of 2 positive integers
       * @param b The shape of tensor B. Should be a tuple of 2 positive integers
       * @returns The expected shape of the result, or undefined if N/A
       */
      static calcMatMulShape(a, b) {
        return a[1] !== b[0] ? void 0 : [a[0], b[1]];
      }
    };
    BroadcastUtil = class _BroadcastUtil {
      /**
       * Calculate the expected shape when broadcasting 2 tensors
       * @param a The shape of tensor A. Should be an array of positive integers
       * @param b The shape of tensor B. Should be an array of positive integers
       * @param isMatMul Whether the operation is MatMul
       * @returns The expected shape of the result, or undefined if N/A
       */
      static calcShape(adims, bdims, isMatMul = false) {
        const arank = adims.length;
        const brank = bdims.length;
        if (arank === 0) {
          return bdims;
        }
        if (brank === 0) {
          return adims;
        }
        const crank = Math.max(adims.length, bdims.length);
        const cdims = new Array(crank);
        if (isMatMul) {
          if (arank < 2 || brank < 2) {
            return void 0;
          }
          const cShapeMatMul = MatMulUtil.calcMatMulShape([adims[arank - 2], adims[arank - 1]], [bdims[brank - 2], bdims[brank - 1]]);
          if (cShapeMatMul === void 0) {
            return void 0;
          }
          [cdims[crank - 2], cdims[crank - 1]] = cShapeMatMul;
        }
        for (let i = isMatMul ? 3 : 1; i <= crank; i++) {
          const aLen = arank - i < 0 ? 1 : adims[arank - i];
          const bLen = brank - i < 0 ? 1 : bdims[brank - i];
          if (aLen !== bLen && aLen > 1 && bLen > 1) {
            return void 0;
          }
          cdims[crank - i] = Math.max(aLen, bLen);
        }
        return cdims;
      }
      /**
       * Given the indices of a broadcasted tensor, calculate the original indices
       * @param broadcastedIndices The given indices of the broadcasted tensor.
       * @param originalShape The original shape of the tensor before broadcas
       * @returns The calculated indices that maps to the original tensor.
       */
      static index(broadcastedIndices, originalShape) {
        const originalIndices = new Array(originalShape.length);
        _BroadcastUtil.fillIndex(broadcastedIndices, originalShape, originalIndices);
        return originalIndices;
      }
      /**
       * Given the indices of a broadcasted tensor, calculate the original indices
       * @param broadcastedIndices The given indices of the broadcasted tensor.
       * @param originalShape The original shape of the tensor before broadcast
       * @param originalIndices The mapping of broadcastedIndices to the originalIndices (output parameter - will be
       *     mutated).
       */
      static fillIndex(broadcastedIndices, originalShape, originalIndices) {
        const dimOffset = broadcastedIndices.length - originalShape.length;
        for (let i = 0; i < originalShape.length; i++) {
          originalIndices[i] = broadcastedIndices[dimOffset + i] % originalShape[i];
        }
      }
      /**
       * Perform the broadcasting operation on the specific operator
       * @param a The input tensor A
       * @param b The input tensor B
       * @param op The operator lambda function
       * @param inplace Whether to write the result back to A.
       * @returns The result tensor, or undefined if input not broadcastable.
       */
      static calc(a, b, op, inplace, resultType) {
        const outputShape = _BroadcastUtil.calcShape(a.dims, b.dims);
        if (outputShape) {
          if (inplace && !ShapeUtil.areEqual(outputShape, a.dims)) {
            return void 0;
          }
          const size = ShapeUtil.size(outputShape);
          const c = inplace ? a : new Tensor3(outputShape, resultType || a.type);
          if (outputShape.length === 0) {
            c.set([], op(a.get([]), b.get([])));
          } else {
            const outputIndices = new Array(outputShape.length);
            const originalIndicesA = new Array(a.dims.length);
            const originalIndicesB = new Array(b.dims.length);
            let valA = 0;
            let valB = 0;
            let isAScalar = false;
            let isBScalar = false;
            if (a.dims.length === 0) {
              valA = a.get([]);
              isAScalar = true;
            }
            if (b.dims.length === 0) {
              valB = b.get([]);
              isBScalar = true;
            }
            let rest;
            for (let i = 0; i < size; i++) {
              rest = i;
              for (let j = outputShape.length - 1; j >= 0; j--) {
                outputIndices[j] = rest % outputShape[j];
                rest = Math.floor(rest / outputShape[j]);
              }
              if (!isAScalar) {
                _BroadcastUtil.fillIndex(outputIndices, a.dims, originalIndicesA);
                valA = a.get(originalIndicesA);
              }
              if (!isBScalar) {
                _BroadcastUtil.fillIndex(outputIndices, b.dims, originalIndicesB);
                valB = b.get(originalIndicesB);
              }
              c.set(outputIndices, op(valA, valB));
            }
          }
          return c;
        }
        return void 0;
      }
      /**
       * Determine if a shape is unidirectional broadcastable to another shape
       * @param shape The input shape
       * @param finalShape The desired shape after broadcasting
       */
      static isValidBroadcast(shape2, finalShape) {
        const inputRank = shape2.length;
        const finalRank = finalShape.length;
        if (inputRank > finalRank) {
          return false;
        }
        for (let i = 1; i <= inputRank; i++) {
          if (shape2[inputRank - i] !== 1 && shape2[inputRank - i] !== finalShape[finalRank - i]) {
            return false;
          }
        }
        return true;
      }
      /**
       * Determine the broadcasted dims in input shape based on the given output shape.
       * Note that this function only returns the broadcasted dims.
       * @param inputShape The input shape
       * @param outputShape The output shape
       * @returns The broadcasted dims in input shape.
       */
      static getBroadcastDims(inputShape, outputShape) {
        const inRank = inputShape.length;
        const dims = [];
        for (let i = 0; i < inRank; i++) {
          const dim = inRank - 1 - i;
          const a = inputShape[dim] || 1;
          const b = outputShape[outputShape.length - 1 - i] || 1;
          if (b > 1 && a === 1) {
            dims.unshift(dim);
          }
        }
        return dims;
      }
    };
    GemmUtil = class {
      // will make sure input shapes are compatible for this op
      // and return back the shape of the output in the form of a tuple
      // will throw exception if the input shapes are not compatible
      static getShapeOfGemmResult(leftShape, transLeft, rightShape, transRight, biasShape) {
        if (leftShape.length !== 2 || rightShape.length !== 2) {
          throw new Error("shape need to be of size 2");
        }
        let M;
        let K;
        let N;
        if (transLeft) {
          M = leftShape[1];
          K = leftShape[0];
        } else {
          M = leftShape[0];
          K = leftShape[1];
        }
        let kDim = -1;
        if (transRight) {
          N = rightShape[0];
          kDim = 1;
        } else {
          N = rightShape[1];
          kDim = 0;
        }
        if (rightShape[kDim] !== K) {
          throw new Error("dimension mismatch");
        }
        if (M <= 0 || N <= 0 || K <= 0) {
          throw new Error("invalid shape specified");
        }
        if (biasShape && !BroadcastUtil.isValidBroadcast(biasShape, [M, N])) {
          throw new Error("gemm: invalid bias shape for broadcast");
        }
        return [M, N, K];
      }
    };
    ProtoUtil = class _ProtoUtil {
      static tensorDataTypeFromProto(typeProto) {
        switch (typeProto) {
          case import_onnx.onnx.TensorProto.DataType.INT8:
            return "int8";
          case import_onnx.onnx.TensorProto.DataType.UINT8:
            return "uint8";
          case import_onnx.onnx.TensorProto.DataType.BOOL:
            return "bool";
          case import_onnx.onnx.TensorProto.DataType.INT16:
            return "int16";
          case import_onnx.onnx.TensorProto.DataType.UINT16:
            return "uint16";
          case import_onnx.onnx.TensorProto.DataType.INT32:
            return "int32";
          case import_onnx.onnx.TensorProto.DataType.UINT32:
            return "uint32";
          case import_onnx.onnx.TensorProto.DataType.FLOAT:
            return "float32";
          case import_onnx.onnx.TensorProto.DataType.DOUBLE:
            return "float64";
          case import_onnx.onnx.TensorProto.DataType.STRING:
            return "string";
          case import_onnx.onnx.TensorProto.DataType.INT64:
            return "int32";
          case import_onnx.onnx.TensorProto.DataType.UINT64:
            return "uint32";
          default:
            throw new Error(`unsupported data type: ${import_onnx.onnx.TensorProto.DataType[typeProto]}`);
        }
      }
      static tensorDataTypeStringToEnum(type) {
        switch (type) {
          case "int8":
            return import_onnx.onnx.TensorProto.DataType.INT8;
          case "uint8":
            return import_onnx.onnx.TensorProto.DataType.UINT8;
          case "bool":
            return import_onnx.onnx.TensorProto.DataType.BOOL;
          case "int16":
            return import_onnx.onnx.TensorProto.DataType.INT16;
          case "uint16":
            return import_onnx.onnx.TensorProto.DataType.UINT16;
          case "int32":
            return import_onnx.onnx.TensorProto.DataType.INT32;
          case "uint32":
            return import_onnx.onnx.TensorProto.DataType.UINT32;
          case "float32":
            return import_onnx.onnx.TensorProto.DataType.FLOAT;
          case "float64":
            return import_onnx.onnx.TensorProto.DataType.DOUBLE;
          case "string":
            return import_onnx.onnx.TensorProto.DataType.STRING;
          case "int64":
            return import_onnx.onnx.TensorProto.DataType.INT64;
          case "uint64":
            return import_onnx.onnx.TensorProto.DataType.UINT64;
          default:
            throw new Error(`unsupported data type: ${type}`);
        }
      }
      static tensorDimsFromProto(dims) {
        return dims.map((d) => long_default.isLong(d) ? d.toNumber() : d);
      }
      static tensorValueTypeFromProto(valueType) {
        return {
          tensorType: _ProtoUtil.tensorDataTypeFromProto(valueType.elemType),
          shape: { dims: _ProtoUtil.tensorDimsFromProto(valueType.shape.dim.map((d) => d.dimValue)) }
        };
      }
      static tensorDimsFromORTFormat(tensor) {
        const dims = [];
        for (let i = 0; i < tensor.dimsLength(); i++) {
          dims.push(LongUtil.longToNumber(tensor.dims(i)));
        }
        return dims;
      }
      static tensorAttributesFromORTFormat(node) {
        const attributes = [];
        for (let i = 0; i < node.attributesLength(); i++) {
          attributes.push(node.attributes(i));
        }
        return attributes;
      }
    };
    LongUtil = class {
      // This function is called to get a number from long type of data for attribute, dim, and ir version,
      // which values are signed integers.
      // To make it more generic, add an optional paramter to convert to a unsigned number.
      static longToNumber(n, unsigned) {
        if (long_default.isLong(n)) {
          return n.toNumber();
        } else if (n instanceof flatbuffers.Long) {
          return long_default.fromValue({ low: n.low, high: n.high, unsigned: unsigned ?? false }).toNumber();
        }
        return n;
      }
      static isLong(n) {
        return long_default.isLong(n) || n instanceof flatbuffers.Long;
      }
    };
    ShapeUtil = class _ShapeUtil {
      static size(dims) {
        return _ShapeUtil.getSizeFromDimensionRange(dims, 0, dims.length);
      }
      // `axis` inclusive
      static sizeFromDimension(dims, axis) {
        if (axis < 0 || axis > dims.length) {
          throw new Error(`invalid dimension of ${axis} for sizeFromDimension as Tensor has ${dims.length} dimensions.`);
        }
        return _ShapeUtil.getSizeFromDimensionRange(dims, axis, dims.length);
      }
      // `axis` exclusive
      static sizeToDimension(dims, axis) {
        if (axis < 0 || axis > dims.length) {
          throw new Error(`invalid dimension of ${axis} for sizeToDimension as Tensor has ${dims.length} dimensions.`);
        }
        return _ShapeUtil.getSizeFromDimensionRange(dims, 0, axis);
      }
      static getSizeFromDimensionRange(dims, start, end) {
        let size = 1;
        for (let i = start; i < end; i++) {
          if (dims[i] <= 0) {
            throw new Error(
              // eslint-disable-next-line max-len
              "cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them."
            );
          }
          size *= dims[i];
        }
        return size;
      }
      static computeStrides(dims) {
        const rank = dims.length;
        if (rank === 0) {
          return [];
        } else if (rank === 1) {
          return [1];
        }
        const strides = new Array(rank);
        strides[rank - 1] = 1;
        strides[rank - 2] = dims[rank - 1];
        for (let i = rank - 3; i >= 0; --i) {
          strides[i] = strides[i + 1] * dims[i + 1];
        }
        return strides;
      }
      static transpose(dims) {
        const copy = dims.slice();
        return copy.reverse();
      }
      static indicesToOffset(indices, strides, axis) {
        if (axis === void 0) {
          axis = indices.length;
        }
        let offset = 0;
        for (let i = 0; i < axis; ++i) {
          offset += strides[i] * indices[i];
        }
        return offset;
      }
      static offsetToIndices(offset, strides) {
        const rank = strides.length;
        if (rank === 0) {
          return [];
        } else if (rank === 1) {
          return [offset * strides[0]];
        }
        const indices = new Array(strides.length);
        for (let i = 0; i < indices.length - 1; ++i) {
          indices[i] = Math.floor(offset / strides[i]);
          offset -= indices[i] * strides[i];
        }
        indices[indices.length - 1] = offset;
        return indices;
      }
      /**
       * normailze axis of range [-r, r) into [0, r).
       */
      static normalizeAxis(axis, tensorRank) {
        if (axis < -tensorRank && axis >= tensorRank) {
          throw new Error("unsupported axis for this operation.");
        }
        return axis < 0 ? axis + tensorRank : axis;
      }
      static normalizeAxes(axes, tensorRank) {
        return axes.map((x) => this.normalizeAxis(x, tensorRank));
      }
      // Increment an index into a tensor (in lexicographic
      // ordering), wrapping around the specified upper_bound.
      /**
       * Increment an index into a tensor (in lexicographic ordering), wrapping around the specified upper_bound.
       * @param index Given index to increment (Will be mutated)
       * @param dims The dimensions of the tensor for which the given index corresponds to
       * @param axisToIncrementOn The 1-indexed axis to increment on. If undefined, axisToIncrementOn == rank
       */
      static incrementIndex(index, dims, axisToIncrementOn) {
        if (dims.length === 0 || index.length === 0) {
          throw new Error("Index incrementing unsupported for scalar Tensor");
        }
        if (axisToIncrementOn === void 0) {
          axisToIncrementOn = dims.length;
        } else {
          if (axisToIncrementOn <= 0 || axisToIncrementOn > dims.length) {
            throw new Error("Incorrect axis to increment on");
          }
        }
        for (let k = axisToIncrementOn - 1; k >= 0; --k) {
          index[k]++;
          if (index[k] < dims[k]) {
            break;
          }
          index[k] = 0;
        }
      }
      /**
       * Produces a new dimensions array based on the values in the 'originalDimensions' and 'shape' array
       * Used in Reshape
       * @param originalDims Original Shape array
       * @param shapeHints array containing values to compute the new dimensions
       * For example:
       * originalDims = [2,2] and shapeHints = [0,-1] will return [2,2]
       * originalDims = [2,2] and shapeHints = [4] will return [4]
       * originalDims = [2,2] and shapeHints = [5] will throw an exception
       * https://github.com/onnx/onnx/blob/main/docs/Operators.md#Reshape
       */
      static calculateReshapedDims(originalDims, shapeHints) {
        if (shapeHints.length === 0) {
          if (originalDims.length === 0 || _ShapeUtil.size(originalDims) === 1) {
            return [];
          } else {
            throw new Error("cannot reshape to a scalar Tensor");
          }
        }
        const nDims = shapeHints.length;
        const reshapedDims = new Array(nDims);
        let unknownDimension = -1;
        let newTensorSize = 1;
        for (let i = 0; i < nDims; i++) {
          if (shapeHints[i] < -1) {
            throw new Error("a dimension in shape hints cannot be less than -1");
          }
          if (shapeHints[i] === -1) {
            if (unknownDimension !== -1) {
              throw new Error("at most one dimension in shape hints can be -1");
            }
            unknownDimension = i;
          } else {
            if (shapeHints[i] === 0) {
              if (i >= originalDims.length) {
                throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");
              }
              reshapedDims[i] = originalDims[i];
            } else {
              reshapedDims[i] = shapeHints[i];
            }
            newTensorSize *= reshapedDims[i];
          }
        }
        const oldTensorSize = _ShapeUtil.size(originalDims);
        if (unknownDimension !== -1) {
          if (oldTensorSize % newTensorSize !== 0) {
            throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${originalDims}] Output shape: [${shapeHints}]`);
          }
          reshapedDims[unknownDimension] = oldTensorSize / newTensorSize;
        } else {
          if (newTensorSize !== oldTensorSize) {
            throw new Error("reshapedDims and originalDims don't have matching sizes");
          }
        }
        return reshapedDims;
      }
      /**
       * Sorts a given array based on the indices in the Perm array
       * Used in Transpose
       * @param a Array to be sorted such as dims or strides
       * @param perm Perm given; if null a will be reversed
       */
      static sortBasedOnPerm(a, perm) {
        if (perm) {
          return perm.map((v) => a[v]);
        } else {
          return a.slice().reverse();
        }
      }
      /**
       * Pads a given shape according to the padding values
       * @param dims shape of the Tensor to be padded
       * @param pad pad values
       */
      static padShape(dims, pad) {
        const rank = dims.length;
        return dims.map((v, i) => v + pad[i] + pad[i + rank]);
      }
      /**
       * Determines if the two shapes are identical
       * @param shape1
       * @param shape2
       */
      static areEqual(shape1, shape2) {
        if (shape1.length !== shape2.length) {
          return false;
        }
        return shape1.every((v, i) => v === shape2[i]);
      }
      /**
       * Validates if the given `dims` or `shape` is valid in ONNX.js context and returns data size
       * @param dims - input `dims` that needs to be checked
       */
      static validateDimsAndCalcSize(dims) {
        if (dims.length > 6) {
          throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");
        }
        let size = 1;
        for (const n of dims) {
          if (!Number.isInteger(n)) {
            throw new TypeError(`Invalid shape: ${n} is not an integer`);
          }
          if (n < 0 || n > 2147483647) {
            throw new TypeError(`Invalid shape: length ${n} is not allowed`);
          }
          size *= n;
        }
        return size;
      }
      /**
       * Determines the shape of output tensor y = flatten(x, axis)
       * @param dims - shape of input tensor
       * @param axis - flatten axis, in the range [-r, r]
       */
      static flattenShape(dims, axis) {
        if (axis < 0) {
          axis += dims.length;
        }
        const total = dims.reduce((x, y) => x * y, 1);
        const right = dims.slice(axis).reduce((x, y) => x * y, 1);
        const outputDims = [total / right, right];
        return outputDims;
      }
      /**
       * Determines the shape of output tensor y = squeeze(x, axes)
       * @param dims - shape of input tensor
       * @param axes - squeeze axes
       */
      static squeezeShape(dims, axes) {
        const outputDims = new Array();
        axes = _ShapeUtil.normalizeAxes(axes, dims.length);
        for (let i = 0; i < dims.length; i++) {
          const inSqueezeList = axes.indexOf(i) >= 0;
          if (inSqueezeList && dims[i] !== 1) {
            throw new Error("squeeze an axis of size different than 1");
          }
          if (axes.length === 0 && dims[i] > 1 || axes.length > 0 && !inSqueezeList) {
            outputDims.push(dims[i]);
          }
        }
        return outputDims;
      }
      /**
       * Determines the shape of output tensor y = unsqueeze(x, axes)
       * @param dims - shape of input tensor
       * @param axes - unsqueeze axes
       */
      static unsqueezeShape(dims, axes) {
        const outputDims = new Array(dims.length + axes.length);
        outputDims.fill(0);
        for (let i = 0; i < axes.length; i++) {
          const axis = _ShapeUtil.normalizeAxis(axes[i], outputDims.length);
          if (axis >= outputDims.length) {
            throw new Error("'axes' has an out of range axis");
          }
          if (outputDims[axis] !== 0) {
            throw new Error("'axes' has a duplicate axis");
          }
          outputDims[axis] = 1;
        }
        let inputDimsIterator = 0;
        for (let i = 0; i < outputDims.length; i++) {
          if (outputDims[i] === 0) {
            outputDims[i] = dims[inputDimsIterator++];
          }
        }
        if (inputDimsIterator !== dims.length) {
          throw new Error("the unsqueezed dimension could not be established");
        }
        return outputDims;
      }
    };
    SplitUtil = class _SplitUtil {
      /**
       * Calculates new Shapes from existing one and the splits given along the axis provides
       * @param dims Shape of the Tensor to be splitted into two or more Shapes
       * @param axis The dimension along which the Tensor will be split
       * @param splits Offsets for the start of each split
       */
      static splitShape(dims, axis, split2, numOutputs) {
        if (split2.length === 0) {
          if (!numOutputs) {
            throw new Error("need to know number of outputs when the 'split' attribute is not specified");
          }
          _SplitUtil.determineSplit(dims[axis], numOutputs, split2);
        }
        const shapes = [];
        const offsets = [0];
        for (let i = 0; i < split2.length; ++i) {
          if (i !== 0) {
            offsets.push(offsets[i - 1] + split2[i - 1]);
          }
          const shape2 = dims.slice();
          shape2[axis] = split2[i];
          shapes.push(shape2);
        }
        return [shapes, offsets];
      }
      static determineSplit(numElementsAlongAxis, numOutputs, split2) {
        if (numElementsAlongAxis % numOutputs !== 0) {
          throw new Error("cannot split tensor to equal sized parts");
        }
        for (let i = 0; i < numOutputs; ++i) {
          split2.push(numElementsAlongAxis / numOutputs);
        }
      }
    };
    PoolConvUtil = class _PoolConvUtil {
      /**
       * Adjust the kernel, strides, pads to correct rank. Set to default value if not present
       * @param isGlobalOperator If true, perform global pooling.
       * @param inputDims The input tensor dimension.
       * @param kernelShape The size of the kernel along each axis.
       * @param strides Stride along each axis.
       * @param dilations Dilation along each axis.
       * @param pads Padding for the beginning and ending along each axis.
       */
      static adjustPoolAttributes(isGlobalOperator, inputDims, kernelShape, strides, dilations, pads) {
        if (!isGlobalOperator && kernelShape.length !== inputDims.length - 2) {
          throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
        }
        if (isGlobalOperator) {
          for (let dim = 0; dim < inputDims.length - 2; dim++) {
            if (dim >= kernelShape.length) {
              kernelShape.push(inputDims[dim + 2]);
            } else {
              kernelShape[dim] = inputDims[dim + 2];
            }
          }
        }
        for (let dim = 0; dim < kernelShape.length; dim++) {
          if (dim < strides.length) {
            if (strides[dim] < 0) {
              throw new Error("strides should be greater than or equal to 1");
            }
          } else {
            strides.push(1);
          }
        }
        for (let dim = 0; dim < kernelShape.length; dim++) {
          if (dim < dilations.length) {
            if (dilations[dim] < 0) {
              throw new Error("dilations should be greater than or equal to 1");
            }
          } else {
            dilations.push(1);
          }
        }
        for (let dim = 0; dim < kernelShape.length * 2; dim++) {
          if (dim < pads.length) {
            if (pads[dim] < 0) {
              throw new Error("pad should be greater than or equal to 1");
            }
          } else {
            pads.push(0);
          }
        }
        for (let dim = 0; dim < kernelShape.length; dim++) {
          if (kernelShape[dim] <= 0) {
            throw new Error("kernel shapes need to be greater than 0");
          }
          if (pads[dim] >= kernelShape[dim] || pads[dim + kernelShape.length] >= kernelShape[dim]) {
            throw new Error("pads should be smaller than kernel");
          }
        }
      }
      // adjust pad values based on 'autoPad' attribute
      static adjustPadsBasedOnAutoPad(inputDims, strides, dilations, kernelShape, pads, autoPad) {
        if (!autoPad) {
          return;
        }
        if (pads.length !== 2 * (inputDims.length - 2)) {
          throw new Error("length of pads should be twice the length of data dimensions");
        }
        if (strides.length !== inputDims.length - 2) {
          throw new Error("length of strides should be the length of data dimensions");
        }
        if (kernelShape.length !== inputDims.length - 2) {
          throw new Error("length of kernel shapes should be the length of data dimensions");
        }
        for (let dim = 0; dim < inputDims.length - 2; dim++) {
          _PoolConvUtil.adjustPadAndReturnShape(
            inputDims[dim + 2],
            strides[dim],
            dilations[dim],
            kernelShape[dim],
            pads,
            dim,
            dim + inputDims.length - 2,
            autoPad
          );
        }
      }
      /**
       * Calculate the output shape for Pool ops based on input attributes. (Should be used only for Pool ops)
       * @param isGlobalOperator If true, perform global pooling.
       * @param inputDims The input tensor dimension. (inputs[0].dims)
       * @param strides Stride along each axis.
       * @param dilations Dilation along each axis.
       * @param kernelShape The size of the kernel along each axis.
       * @param pads Padding for the beginning and ending along each axis.
       * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
       *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
       */
      static computePoolOutputShape(isGlobalOperator, inputDims, strides, dilations, kernelShape, pads, autoPad) {
        if (inputDims.length <= 0) {
          throw new Error("input shape must be of size greater than 0");
        }
        const outputDims = [inputDims[0], inputDims[1]];
        _PoolConvUtil.computeShapeHelper(
          isGlobalOperator,
          inputDims,
          outputDims,
          strides,
          dilations,
          kernelShape,
          pads,
          autoPad
        );
        return outputDims;
      }
      /**
       * Calculate the output shape for Conv op based on input attributes. (Should be used only for Conv op)
       * @param inputDims The input tensor dimension. (inputs[0].dims)
       * @param filterDims The filter tensor dimension. (inputs[1].dims)
       * @param strides Stride along each axis.
       * @param kernelShape The size of the kernel along each axis.
       * @param pads Padding for the beginning and ending along each axis.
       * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
       *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
       */
      static computeConvOutputShape(inputDims, filterDims, strides, dilations, kernelShape, pads, autoPad) {
        if (inputDims.length <= 0 || filterDims.length <= 0) {
          throw new Error("invalid input tensor dims or invalid filter tensor dims");
        }
        const outputDims = [inputDims[0], filterDims[0]];
        _PoolConvUtil.computeShapeHelper(false, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad);
        return outputDims;
      }
      // will compute output shapes for data dimensions ONLY (i.e.) no batch size and channels
      // called by computePoolOutputShape() and computeConvOutputShape()
      // adjust pads based on 'autoPad' attribute prior to shape computation
      static computeShapeHelper(isGlobalOperator, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad) {
        if (isGlobalOperator) {
          for (let dim = 0; dim < inputDims.length - 2; dim++) {
            outputDims.push(1);
          }
        } else {
          for (let dim = 0; dim < inputDims.length - 2; dim++) {
            outputDims.push(_PoolConvUtil.adjustPadAndReturnShape(
              inputDims[dim + 2],
              strides[dim],
              dilations[dim],
              kernelShape[dim],
              pads,
              dim,
              dim + inputDims.length - 2,
              autoPad
            ));
          }
        }
      }
      // helper for computeShapeHelper() and adjustPadsBasedOnAutoPad()
      // adjusts pad value for given 'autoPad' string and computes output shape along a particular dimension
      static adjustPadAndReturnShape(inSize, stride, dilation, kernel, pads, padHeadIndex, padTailIndex, autoPad) {
        const dkernel = dilation * (kernel - 1) + 1;
        if (autoPad && autoPad !== "NOTSET") {
          switch (autoPad) {
            case "VALID":
              pads[padHeadIndex] = 0;
              pads[padTailIndex] = 0;
              return Math.floor((inSize - dkernel) / stride + 1);
            case "SAME_LOWER":
            case "SAME_UPPER":
              if (dilation !== 1) {
                throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
              } else {
                const legacyTargetSize = (inSize + stride - 1) / stride;
                const padNeeded = (legacyTargetSize - 1) * stride + kernel - inSize;
                pads[padHeadIndex] = autoPad === "SAME_LOWER" ? Math.floor((padNeeded + 1) / 2) : Math.floor(padNeeded / 2);
                pads[padTailIndex] = padNeeded - pads[padHeadIndex];
                return Math.floor((inSize + padNeeded - kernel) / stride + 1);
              }
            default:
              throw new Error("Unsupported AutoPad type");
          }
        } else {
          return Math.floor((inSize + pads[padHeadIndex] + pads[padTailIndex] - dkernel) / stride + 1);
        }
      }
    };
    MIN_CLIP = -34028234663852886e22;
    MAX_CLIP = 34028234663852886e22;
  }
});

// web/lib/onnxjs/tensor.ts
function sizeof(type) {
  switch (type) {
    case "bool":
    case "int8":
    case "uint8":
      return 1;
    case "int16":
    case "uint16":
      return 2;
    case "int32":
    case "uint32":
    case "float32":
      return 4;
    case "float64":
      return 8;
    default:
      throw new Error(`cannot calculate sizeof() on type ${type}`);
  }
}
function sizeofProto(type) {
  switch (type) {
    case import_onnx2.onnx.TensorProto.DataType.UINT8:
    case import_onnx2.onnx.TensorProto.DataType.INT8:
    case import_onnx2.onnx.TensorProto.DataType.BOOL:
      return 1;
    case import_onnx2.onnx.TensorProto.DataType.UINT16:
    case import_onnx2.onnx.TensorProto.DataType.INT16:
      return 2;
    case import_onnx2.onnx.TensorProto.DataType.FLOAT:
    case import_onnx2.onnx.TensorProto.DataType.INT32:
    case import_onnx2.onnx.TensorProto.DataType.UINT32:
      return 4;
    case import_onnx2.onnx.TensorProto.DataType.INT64:
    case import_onnx2.onnx.TensorProto.DataType.DOUBLE:
    case import_onnx2.onnx.TensorProto.DataType.UINT64:
      return 8;
    default:
      throw new Error(`cannot calculate sizeof() on type ${import_onnx2.onnx.TensorProto.DataType[type]}`);
  }
}
function createView(dataBuffer, type) {
  return new (dataviewConstructor(type))(dataBuffer);
}
function dataviewConstructor(type) {
  switch (type) {
    case "bool":
    case "uint8":
      return Uint8Array;
    case "int8":
      return Int8Array;
    case "int16":
      return Int16Array;
    case "uint16":
      return Uint16Array;
    case "int32":
      return Int32Array;
    case "uint32":
      return Uint32Array;
    case "int64":
      return BigInt64Array;
    case "float32":
      return Float32Array;
    case "float64":
      return Float64Array;
    default:
      throw new Error("unspecified error");
  }
}
function longToNumber(i, type) {
  if (type === import_onnx2.onnx.TensorProto.DataType.INT64 || type === ortFbs.TensorDataType.INT64) {
    if (i.greaterThanOrEqual(2147483648) || i.lessThan(-2147483648)) {
      throw new TypeError("int64 is not supported");
    }
  } else if (type === import_onnx2.onnx.TensorProto.DataType.UINT32 || type === ortFbs.TensorDataType.UINT32 || type === import_onnx2.onnx.TensorProto.DataType.UINT64 || type === ortFbs.TensorDataType.UINT64) {
    if (i.greaterThanOrEqual(4294967296) || i.lessThan(0)) {
      throw new TypeError("uint64 is not supported");
    }
  } else {
    throw new TypeError(`not a LONG type: ${import_onnx2.onnx.TensorProto.DataType[type]}`);
  }
  return i.toNumber();
}
function readProto(view, type, byteOffset) {
  switch (type) {
    case import_onnx2.onnx.TensorProto.DataType.BOOL:
    case import_onnx2.onnx.TensorProto.DataType.UINT8:
      return view.getUint8(byteOffset);
    case import_onnx2.onnx.TensorProto.DataType.INT8:
      return view.getInt8(byteOffset);
    case import_onnx2.onnx.TensorProto.DataType.UINT16:
      return view.getUint16(byteOffset, true);
    case import_onnx2.onnx.TensorProto.DataType.INT16:
      return view.getInt16(byteOffset, true);
    case import_onnx2.onnx.TensorProto.DataType.FLOAT:
      return view.getFloat32(byteOffset, true);
    case import_onnx2.onnx.TensorProto.DataType.INT32:
      return view.getInt32(byteOffset, true);
    case import_onnx2.onnx.TensorProto.DataType.UINT32:
      return view.getUint32(byteOffset, true);
    case import_onnx2.onnx.TensorProto.DataType.INT64:
      return longToNumber(
        long_default.fromBits(view.getUint32(byteOffset, true), view.getUint32(byteOffset + 4, true), false),
        type
      );
    case import_onnx2.onnx.TensorProto.DataType.DOUBLE:
      return view.getFloat64(byteOffset, true);
    case import_onnx2.onnx.TensorProto.DataType.UINT64:
      return longToNumber(
        long_default.fromBits(view.getUint32(byteOffset, true), view.getUint32(byteOffset + 4, true), true),
        type
      );
    default:
      throw new Error(`cannot read from DataView for type ${import_onnx2.onnx.TensorProto.DataType[type]}`);
  }
}
var import_guid_typescript, import_onnx2, ortFbs, Tensor3;
var init_tensor2 = __esm({
  "web/lib/onnxjs/tensor.ts"() {
    "use strict";
    import_guid_typescript = __toESM(require_guid());
    init_long();
    init_ort_generated();
    import_onnx2 = __toESM(require_onnx());
    init_util();
    ortFbs = onnxruntime.experimental.fbs;
    Tensor3 = class _Tensor {
      constructor(dims, type, dataProvider, asyncDataProvider, cache2, dataId = import_guid_typescript.Guid.create()) {
        this.dims = dims;
        this.type = type;
        this.dataProvider = dataProvider;
        this.asyncDataProvider = asyncDataProvider;
        this.cache = cache2;
        this.dataId = dataId;
        this.size = ShapeUtil.validateDimsAndCalcSize(dims);
        const size = this.size;
        const empty = dataProvider === void 0 && asyncDataProvider === void 0 && cache2 === void 0;
        if (cache2 !== void 0) {
          if (cache2.length !== size) {
            throw new RangeError("Input dims doesn't match data length.");
          }
        }
        if (type === "string") {
          if (cache2 !== void 0 && (!Array.isArray(cache2) || !cache2.every((i) => typeof i === "string"))) {
            throw new TypeError("cache should be a string array");
          }
          if (empty) {
            this.cache = new Array(size);
          }
        } else {
          if (cache2 !== void 0) {
            const constructor = dataviewConstructor(type);
            if (!(cache2 instanceof constructor)) {
              throw new TypeError(`cache should be type ${constructor.name}`);
            }
          }
          if (empty) {
            const buf = new ArrayBuffer(size * sizeof(type));
            this.cache = createView(buf, type);
          }
        }
      }
      /**
       * get the underlying tensor data
       */
      get data() {
        if (this.cache === void 0) {
          const data = this.dataProvider(this.dataId);
          if (data.length !== this.size) {
            throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");
          }
          this.cache = data;
        }
        return this.cache;
      }
      /**
       * get the underlying string tensor data. Should only use when type is STRING
       */
      get stringData() {
        if (this.type !== "string") {
          throw new TypeError("data type is not string");
        }
        return this.data;
      }
      /**
       * get the underlying integer tensor data. Should only use when type is one of the following: (UINT8, INT8, UINT16,
       * INT16, INT32, UINT32, BOOL)
       */
      get integerData() {
        switch (this.type) {
          case "uint8":
          case "int8":
          case "uint16":
          case "int16":
          case "int32":
          case "uint32":
          case "bool":
            return this.data;
          default:
            throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)");
        }
      }
      /**
       * get the underlying float tensor data. Should only use when type is one of the following: (FLOAT, DOUBLE)
       */
      get floatData() {
        switch (this.type) {
          case "float32":
          case "float64":
            return this.data;
          default:
            throw new TypeError("data type is not float (float32, float64)");
        }
      }
      /**
       * get the underlying number tensor data. Should only use when type is one of the following: (UINT8, INT8, UINT16,
       * INT16, INT32, UINT32, BOOL, FLOAT, DOUBLE)
       */
      get numberData() {
        if (this.type !== "string") {
          return this.data;
        }
        throw new TypeError("type cannot be non-number (string)");
      }
      /**
       * get value of an element at the given indices
       */
      get(indices) {
        return this.data[ShapeUtil.indicesToOffset(indices, this.strides)];
      }
      /**
       * set value of an element at the given indices
       */
      set(indices, value) {
        this.data[ShapeUtil.indicesToOffset(indices, this.strides)] = value;
      }
      /**
       * get the underlying tensor data asynchronously
       */
      async getData() {
        if (this.cache === void 0) {
          this.cache = await this.asyncDataProvider(this.dataId);
        }
        return this.cache;
      }
      /**
       * get the strides for each dimension
       */
      get strides() {
        if (!this._strides) {
          this._strides = ShapeUtil.computeStrides(this.dims);
        }
        return this._strides;
      }
      /**
       * Construct new Tensor from a ONNX Tensor object
       * @param tensorProto the ONNX Tensor
       */
      static fromProto(tensorProto) {
        if (!tensorProto) {
          throw new Error("cannot construct Value from an empty tensor");
        }
        const type = ProtoUtil.tensorDataTypeFromProto(tensorProto.dataType);
        const dims = ProtoUtil.tensorDimsFromProto(tensorProto.dims);
        const value = new _Tensor(dims, type);
        if (type === "string") {
          tensorProto.stringData.forEach((str, i) => {
            value.data[i] = decodeUtf8String(str);
          });
        } else if (tensorProto.rawData && typeof tensorProto.rawData.byteLength === "number" && tensorProto.rawData.byteLength > 0) {
          const dataDest = value.data;
          const dataSource = new DataView(tensorProto.rawData.buffer, tensorProto.rawData.byteOffset, tensorProto.rawData.byteLength);
          const elementSize = sizeofProto(tensorProto.dataType);
          const length = tensorProto.rawData.byteLength / elementSize;
          if (tensorProto.rawData.byteLength % elementSize !== 0) {
            throw new Error("invalid buffer length");
          }
          if (dataDest.length !== length) {
            throw new Error("buffer length mismatch");
          }
          for (let i = 0; i < length; i++) {
            const n = readProto(dataSource, tensorProto.dataType, i * elementSize);
            dataDest[i] = n;
          }
        } else {
          let array;
          switch (tensorProto.dataType) {
            case import_onnx2.onnx.TensorProto.DataType.FLOAT:
              array = tensorProto.floatData;
              break;
            case import_onnx2.onnx.TensorProto.DataType.INT32:
            case import_onnx2.onnx.TensorProto.DataType.INT16:
            case import_onnx2.onnx.TensorProto.DataType.UINT16:
            case import_onnx2.onnx.TensorProto.DataType.INT8:
            case import_onnx2.onnx.TensorProto.DataType.UINT8:
            case import_onnx2.onnx.TensorProto.DataType.BOOL:
              array = tensorProto.int32Data;
              break;
            case import_onnx2.onnx.TensorProto.DataType.INT64:
              array = tensorProto.int64Data;
              break;
            case import_onnx2.onnx.TensorProto.DataType.DOUBLE:
              array = tensorProto.doubleData;
              break;
            case import_onnx2.onnx.TensorProto.DataType.UINT32:
            case import_onnx2.onnx.TensorProto.DataType.UINT64:
              array = tensorProto.uint64Data;
              break;
            default:
              throw new Error("unspecific error");
          }
          if (array === null || array === void 0) {
            throw new Error("failed to populate data from a tensorproto value");
          }
          const data = value.data;
          if (data.length !== array.length) {
            throw new Error("array length mismatch");
          }
          for (let i = 0; i < array.length; i++) {
            const element = array[i];
            if (long_default.isLong(element)) {
              data[i] = longToNumber(element, tensorProto.dataType);
            } else {
              data[i] = element;
            }
          }
        }
        return value;
      }
      /**
       * Construct new Tensor from raw data
       * @param data the raw data object. Should be a string array for 'string' tensor, and the corresponding typed array
       * for other types of tensor.
       * @param dims the dimensions of the tensor
       * @param type the type of the tensor
       */
      static fromData(data, dims, type) {
        return new _Tensor(dims, type, void 0, void 0, data);
      }
      static fromOrtTensor(ortTensor) {
        if (!ortTensor) {
          throw new Error("cannot construct Value from an empty tensor");
        }
        const dims = ProtoUtil.tensorDimsFromORTFormat(ortTensor);
        const type = ProtoUtil.tensorDataTypeFromProto(ortTensor.dataType());
        const value = new _Tensor(dims, type);
        if (type === "string") {
          for (let i = 0; i < ortTensor.stringDataLength(); i++) {
            value.data[i] = ortTensor.stringData(i);
          }
        } else if (ortTensor.rawDataArray() && typeof ortTensor.rawDataLength() === "number" && ortTensor.rawDataLength() > 0) {
          const dataDest = value.data;
          const dataSource = new DataView(
            ortTensor.rawDataArray().buffer,
            ortTensor.rawDataArray().byteOffset,
            ortTensor.rawDataLength()
          );
          const elementSize = sizeofProto(ortTensor.dataType());
          const length = ortTensor.rawDataLength() / elementSize;
          if (ortTensor.rawDataLength() % elementSize !== 0) {
            throw new Error("invalid buffer length");
          }
          if (dataDest.length !== length) {
            throw new Error("buffer length mismatch");
          }
          for (let i = 0; i < length; i++) {
            const n = readProto(dataSource, ortTensor.dataType(), i * elementSize);
            dataDest[i] = n;
          }
        }
        return value;
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/glsl-source.ts
function getGlsl(version3) {
  return version3 === 1 ? GLSL_ES_2_0 : GLSL_ES_3_0;
}
function getVertexShaderSource(version3) {
  const glsl = getGlsl(version3);
  return `${glsl.version}
      precision highp float;
      ${glsl.attribute} vec3 position;
      ${glsl.attribute} vec2 textureCoord;

      ${glsl.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`;
}
function getFragShaderPreamble(version3) {
  const glsl = getGlsl(version3);
  return `${glsl.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${glsl.varyingFrag} vec2 TexCoords;
    ${glsl.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `;
}
function getDefaultFragShaderMain(version3, outputShapeLength) {
  const glsl = getGlsl(version3);
  return `
  void main() {
    int indices[${outputShapeLength}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${glsl.output} = result;
  }
  `;
}
var GLSL_ES_2_0, GLSL_ES_3_0;
var init_glsl_source = __esm({
  "web/lib/onnxjs/backends/webgl/glsl-source.ts"() {
    "use strict";
    GLSL_ES_2_0 = {
      version: "",
      attribute: "attribute",
      varyingVertex: "varying",
      varyingFrag: "varying",
      texture2D: "texture2D",
      output: "gl_FragColor",
      outputDeclaration: ""
    };
    GLSL_ES_3_0 = {
      version: "#version 300 es",
      attribute: "in",
      varyingVertex: "out",
      varyingFrag: "in",
      texture2D: "texture",
      output: "outputColor",
      outputDeclaration: "out vec4 outputColor;"
    };
  }
});

// web/lib/onnxjs/backends/webgl/types.ts
var init_types = __esm({
  "web/lib/onnxjs/backends/webgl/types.ts"() {
    "use strict";
  }
});

// web/lib/onnxjs/backends/webgl/utils.ts
async function repeatedTry(checkFn, delayFn = (_counter) => 0, maxCounter) {
  return new Promise((resolve, reject) => {
    let tryCount = 0;
    const tryFn = () => {
      if (checkFn()) {
        resolve();
        return;
      }
      tryCount++;
      const nextBackoff = delayFn(tryCount);
      if (maxCounter != null && tryCount >= maxCounter) {
        reject();
        return;
      }
      setTimeout(tryFn, nextBackoff);
    };
    tryFn();
  });
}
function generateShaderFuncNameFromInputSamplerName(samplerName) {
  assert(typeof samplerName !== "undefined" && samplerName.length !== 0, () => "empty string found for sampler name");
  return "get" + samplerName.charAt(0).toUpperCase() + samplerName.slice(1);
}
function generateShaderFuncNameFromInputSamplerNameAtOutCoords(samplerName) {
  assert(typeof samplerName !== "undefined" && samplerName.length !== 0, () => "empty string found for sampler name");
  return "get" + samplerName.charAt(0).toUpperCase() + samplerName.slice(1) + "AtOutCoords";
}
function squeezeInputShape(inputShape, squeezedShape) {
  let newInputShape = JSON.parse(JSON.stringify(inputShape));
  newInputShape = squeezedShape;
  return newInputShape;
}
function getSqueezedParams(params, keptDims) {
  return keptDims.map((d) => params[d]).join(", ");
}
function getCoordsDataType(rank) {
  if (rank <= 1) {
    return "int";
  } else if (rank === 2) {
    return "ivec2";
  } else if (rank === 3) {
    return "ivec3";
  } else if (rank === 4) {
    return "ivec4";
  } else if (rank === 5) {
    return "ivec5";
  } else if (rank === 6) {
    return "ivec6";
  } else {
    throw Error(`GPU for rank ${rank} is not yet supported`);
  }
}
function getGlChannels(rank = 6) {
  return ["x", "y", "z", "w", "u", "v"].slice(0, rank);
}
var init_utils = __esm({
  "web/lib/onnxjs/backends/webgl/utils.ts"() {
    "use strict";
    init_util();
  }
});

// web/lib/onnxjs/backends/webgl/ops/packing-utils.ts
function getVecChannels(name2, rank) {
  return getGlChannels(rank).map((d) => `${name2}.${d}`);
}
function getChannels(name2, rank) {
  if (rank === 1) {
    return [name2];
  }
  return getVecChannels(name2, rank);
}
function unpackFromChannel() {
  return `
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `;
}
var init_packing_utils = __esm({
  "web/lib/onnxjs/backends/webgl/ops/packing-utils.ts"() {
    "use strict";
    init_utils();
  }
});

// web/lib/onnxjs/backends/webgl/ops/pack.ts
function getOutOfBoundsCondition(rank, shape2, dims) {
  if (rank === 0) {
    return "false";
  }
  if (rank === 1) {
    return `rc > ${shape2[0]}`;
  }
  let cond = "";
  for (let i = rank - 2; i < rank; i++) {
    cond += `${dims[i]} >= ${shape2[i - rank + 2]}`;
    if (i < rank - 1) {
      cond += "||";
    }
  }
  return cond;
}
function getOutput(shape2, dims) {
  const rank = shape2.length;
  if (rank === 0) {
    return "getA(), 0, 0, 0";
  }
  if (rank === 1) {
    return `getA(rc),
            rc + 1 >= ${shape2[0]} ? 0. : getA(rc + 1),
            0, 0`;
  }
  const coord00 = "r, c";
  const coord01 = "r, cp1";
  const coord10 = "rp1, c";
  const coord11 = "rp1, cp1";
  let D = "";
  if (rank > 2) {
    for (let i = 0; i < rank - 2; ++i) {
      D = D + `${dims[i]},`;
    }
  }
  return `getA(${D}${coord00}),
          rEdge ? 0. : getA(${D}${coord10}),
          cEdge ? 0. : getA(${D}${coord01}),
          rEdge || cEdge ? 0. : getA(${D}${coord11})`;
}
function getSetup(rank, dims, rows, cols) {
  if (rank === 0 || rank === 1) {
    return "";
  } else {
    const setup = `
    int r = ${dims[rank - 2]};
    int c = ${dims[rank - 1]};
    int rp1 = ${dims[rank - 2]} + 1;
    int cp1 = ${dims[rank - 1]} + 1;
    bool rEdge = rp1 >= ${cols};
    bool cEdge = cp1 >= ${rows};
    `;
    return setup;
  }
}
var packProgramMetadata, createPackProgramInfo, createPackProgramInfoLoader;
var init_pack = __esm({
  "web/lib/onnxjs/backends/webgl/ops/pack.ts"() {
    "use strict";
    init_glsl_source();
    init_types();
    init_utils();
    init_packing_utils();
    packProgramMetadata = {
      name: "pack",
      inputNames: ["A"],
      inputTypes: [1 /* unpackedReversed */]
    };
    createPackProgramInfo = (handler, input) => {
      const glsl = getGlsl(handler.session.backend.glContext.version);
      const inputShape = input.dims;
      const inputRank = inputShape.length;
      const outputRank = input.dims.length;
      const coordsDataType = getCoordsDataType(outputRank);
      const channels = getChannels("rc", outputRank);
      const setup = getSetup(outputRank, channels, inputShape[inputShape.length - 2], inputShape[inputShape.length - 1]);
      let reversedInputWH;
      if (inputRank === 0) {
        reversedInputWH = [1, 1];
      } else if (inputRank === 1) {
        reversedInputWH = [inputShape[0], 1];
      } else {
        reversedInputWH = [inputShape[outputRank - 1], inputShape[outputRank - 2]];
      }
      const outOfBoundsCondition = getOutOfBoundsCondition(outputRank, reversedInputWH, channels);
      const output = getOutput(inputShape, channels);
      const shaderSource = `
        void main() {
          ${coordsDataType} rc = getOutputCoords();

          if(${outOfBoundsCondition}) {
            ${glsl.output} = vec4(0);
          } else {
            ${setup}

            ${glsl.output} = vec4(${output});
          }
        }
      `;
      return {
        ...packProgramMetadata,
        hasMain: true,
        output: { dims: input.dims, type: input.type, textureType: 2 /* packed */ },
        shaderSource
      };
    };
    createPackProgramInfoLoader = (handler, input) => ({ ...packProgramMetadata, get: () => createPackProgramInfo(handler, input) });
  }
});

// web/lib/onnxjs/backends/webgl/ops/reshape-packed.ts
function processDims3D(shape2) {
  if (shape2.length === 0) {
    return [1, 1, 1];
  }
  let batch = 1;
  for (let i = 0; i < shape2.length - 2; ++i) {
    batch *= shape2[i];
  }
  return [batch, shape2.length > 1 ? shape2[shape2.length - 2] : 1, shape2[shape2.length - 1]];
}
function isReshapeCheap(dims, reshapedDims) {
  let isCheapReshape = false;
  if (dims.length === 0 || reshapedDims.length === 0) {
    isCheapReshape = true;
  } else if (dims.length < 2 || reshapedDims.length < 2) {
    isCheapReshape = dims[dims.length - 1] === reshapedDims[reshapedDims.length - 1];
  } else {
    isCheapReshape = dims[dims.length - 1] === reshapedDims[reshapedDims.length - 1] && dims[dims.length - 2] === reshapedDims[reshapedDims.length - 2];
  }
  return isCheapReshape;
}
function getReshapedInputCoords(shape2) {
  const strides = ShapeUtil.computeStrides(shape2);
  const coords = ["b", "r", "c"];
  const index = "index";
  const coordsFromIndexSnippet = strides.map((stride, i) => {
    const line1 = `int ${coords[i]} = ${index} / ${stride}`;
    const line2 = i === strides.length - 1 ? `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${stride}` : `index -= ${coords[i]} * ${stride}`;
    return `${line1}; ${line2};`;
  }).join("");
  return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${coordsFromIndexSnippet}
      return ivec3(b, r, c);
    }
  `;
}
function getFlattenedIndexFrom3D(shape2) {
  const strides = ShapeUtil.computeStrides(shape2);
  return `
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${strides[0]} + coords.z * ${strides[1]} + coords.y;
  }
`;
}
var createPackedReshape3DProgramMetadata, createPackedReshape3DProgramInfo, createPackedReshape3DProgramInfoLoader;
var init_reshape_packed = __esm({
  "web/lib/onnxjs/backends/webgl/ops/reshape-packed.ts"() {
    "use strict";
    init_util();
    init_glsl_source();
    init_types();
    init_packing_utils();
    createPackedReshape3DProgramMetadata = (outputShape3D) => ({ name: "Reshape (packed)", inputTypes: [2 /* packed */], inputNames: ["A"], cacheHint: `${outputShape3D}` });
    createPackedReshape3DProgramInfo = (handler, input3D, metadata, outputShape3D) => {
      const inputShape3D = input3D.dims;
      const squeezedOutputShape = outputShape3D;
      let mainLoop = "";
      for (let i = 0; i < 4; i++) {
        let outputCoords = "";
        switch (i) {
          case 0:
            outputCoords = "outputCoords = rc;";
            break;
          case 1:
            outputCoords = "outputCoords = ivec3(rc.x, rc.y+1, rc.z);";
            break;
          case 2:
            outputCoords = "outputCoords = ivec3(rc.x, rc.y, rc.z+1);";
            break;
          case 3:
            outputCoords = "outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";
            break;
          default:
            throw new Error();
        }
        mainLoop += `
        ${outputCoords}
        ${i > 0 ? "if(outputCoords.y < rows && outputCoords.z < cols){" : ""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${i > 0 ? "}" : ""}
      `;
      }
      const glsl = getGlsl(handler.session.backend.glContext.version);
      const shaderSource = `
      ${getReshapedInputCoords(inputShape3D)}
      ${getFlattenedIndexFrom3D(squeezedOutputShape)}
      ${unpackFromChannel()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${squeezedOutputShape[2]};
        int cols = ${squeezedOutputShape[1]};

        ${mainLoop}
        ${glsl.output} = result;
      }
    `;
      return {
        ...metadata,
        output: { dims: squeezedOutputShape, type: input3D.type, textureType: 2 /* packed */ },
        shaderSource,
        hasMain: true
      };
    };
    createPackedReshape3DProgramInfoLoader = (handler, input3D, outputShape3D) => {
      const metadata = createPackedReshape3DProgramMetadata(outputShape3D);
      return { ...metadata, get: () => createPackedReshape3DProgramInfo(handler, input3D, metadata, outputShape3D) };
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/uint8-encode.ts
var encodeAsUint8;
var init_uint8_encode = __esm({
  "web/lib/onnxjs/backends/webgl/ops/uint8-encode.ts"() {
    "use strict";
    init_glsl_source();
    init_types();
    encodeAsUint8 = (inferenceHandler, input) => {
      const outputShape = input.shape;
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      const shaderSource = `
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${glsl.texture2D}(X,TexCoords).r;
      ${glsl.output} = encodeAsUint8(value);
    }`;
      const programInfo = {
        name: "Uint8Encode",
        inputTypes: [0 /* unpacked */],
        inputNames: ["X"],
        output: { dims: outputShape, type: input.tensor.type, textureType: 3 /* downloadUint8AsFloat */ },
        shaderSource,
        hasMain: true
      };
      return inferenceHandler.executeProgram(programInfo, [input.tensor]);
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/unpack.ts
function getSourceCoords(rank, dims) {
  if (rank === 1) {
    return "rc";
  }
  let coords = "";
  for (let i = 0; i < rank; i++) {
    coords += dims[i];
    if (i < rank - 1) {
      coords += ",";
    }
  }
  return coords;
}
var unpackProgramMetadata, createUnpackProgramInfo, createUnpackProgramInfoLoader;
var init_unpack = __esm({
  "web/lib/onnxjs/backends/webgl/ops/unpack.ts"() {
    "use strict";
    init_glsl_source();
    init_types();
    init_utils();
    init_packing_utils();
    unpackProgramMetadata = {
      name: "unpack",
      inputNames: ["A"],
      inputTypes: [2 /* packed */]
    };
    createUnpackProgramInfo = (handler, input) => {
      const rank = input.dims.length;
      const channels = getChannels("rc", rank);
      const innerDims = channels.slice(-2);
      const coordsDataType = getCoordsDataType(rank);
      const unpackChannel = unpackFromChannel();
      const isScalar = input.dims.length === 0;
      const sourceCoords = isScalar ? "" : getSourceCoords(rank, channels);
      const coords = rank <= 1 ? "rc" : `vec2(${innerDims.join(",")})`;
      const glsl = getGlsl(handler.session.backend.glContext.version);
      const shaderSource = `
    ${unpackChannel}
    void main() {
      ${coordsDataType} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${sourceCoords});

       ${glsl.output} = vec4(getChannel(packedInput, ${coords}), 0, 0, 0);
     }
   `;
      return {
        ...unpackProgramMetadata,
        hasMain: true,
        output: { dims: input.dims, type: input.type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    createUnpackProgramInfoLoader = (handler, input) => ({ ...unpackProgramMetadata, get: () => createUnpackProgramInfo(handler, input) });
  }
});

// web/lib/onnxjs/backends/webgl/texture-data-encoder.ts
var RedFloat32DataEncoder, RGBAFloatDataEncoder, Uint8DataEncoder;
var init_texture_data_encoder = __esm({
  "web/lib/onnxjs/backends/webgl/texture-data-encoder.ts"() {
    "use strict";
    init_instrument();
    RedFloat32DataEncoder = class {
      constructor(gl, channels = 1) {
        if (channels === 1) {
          this.internalFormat = gl.R32F;
          this.format = gl.RED;
          this.textureType = gl.FLOAT;
          this.channelSize = channels;
        } else if (channels === 4) {
          this.internalFormat = gl.RGBA32F;
          this.format = gl.RGBA;
          this.textureType = gl.FLOAT;
          this.channelSize = channels;
        } else {
          throw new Error(`Invalid number of channels: ${channels}`);
        }
      }
      encode(src, textureSize) {
        let result;
        let source;
        if (src.constructor !== Float32Array) {
          Logger.warning("Encoder", "data was not of type Float32; creating new Float32Array");
          source = new Float32Array(src);
        }
        if (textureSize * this.channelSize > src.length) {
          Logger.warning("Encoder", "Source data too small. Allocating larger array");
          source = src;
          result = this.allocate(textureSize * this.channelSize);
          source.forEach((v, i) => result[i] = v);
        } else {
          source = src;
          result = source;
        }
        return result;
      }
      allocate(size) {
        return new Float32Array(size * 4);
      }
      decode(buffer, dataSize) {
        if (this.channelSize === 1) {
          const filteredData = buffer.filter((_value, index) => index % 4 === 0).subarray(0, dataSize);
          return filteredData;
        }
        return buffer.subarray(0, dataSize);
      }
    };
    RGBAFloatDataEncoder = class {
      constructor(gl, channels = 1, textureType) {
        if (channels !== 1 && channels !== 4) {
          throw new Error(`Invalid number of channels: ${channels}`);
        }
        this.internalFormat = gl.RGBA;
        this.format = gl.RGBA;
        this.channelSize = channels;
        this.textureType = textureType || gl.FLOAT;
      }
      encode(src, textureSize) {
        let dest = src;
        if (this.channelSize === 1) {
          Logger.verbose("Encoder", "Exploding into a larger array");
          dest = this.allocate(textureSize);
          src.forEach((v, i) => dest[i * 4] = v);
        }
        return dest;
      }
      allocate(size) {
        return new Float32Array(size * 4);
      }
      decode(buffer, dataSize) {
        if (this.channelSize === 1) {
          const filteredData = buffer.filter((_value, index) => index % 4 === 0).subarray(0, dataSize);
          return filteredData;
        }
        return buffer.subarray(0, dataSize);
      }
    };
    Uint8DataEncoder = class {
      constructor(gl, channels = 1) {
        this.channelSize = 4;
        if (channels === 1) {
          this.internalFormat = gl.ALPHA;
          this.format = gl.ALPHA;
          this.textureType = gl.UNSIGNED_BYTE;
          this.channelSize = channels;
        } else if (channels === 4) {
          this.internalFormat = gl.RGBA;
          this.format = gl.RGBA;
          this.textureType = gl.UNSIGNED_BYTE;
          this.channelSize = channels;
        } else {
          throw new Error(`Invalid number of channels: ${channels}`);
        }
      }
      encode(src, _textureSize) {
        return new Uint8Array(src.buffer, src.byteOffset, src.byteLength);
      }
      allocate(size) {
        return new Uint8Array(size * this.channelSize);
      }
      decode(buffer, dataSize) {
        if (buffer instanceof Uint8Array) {
          return buffer.subarray(0, dataSize);
        }
        throw new Error(`Invalid array type: ${buffer.constructor}`);
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/texture-layout.ts
var createTextureLayoutFromTextureType, calculateTextureWidthAndHeight, createTextureLayoutFromShape;
var init_texture_layout = __esm({
  "web/lib/onnxjs/backends/webgl/texture-layout.ts"() {
    "use strict";
    init_util();
    init_types();
    createTextureLayoutFromTextureType = (textureLayoutStrategy, shape2, textureType) => {
      const channel = textureType === 0 /* unpacked */ || textureType === 1 /* unpackedReversed */ ? 1 : 4;
      const isPacked = textureType === 2 /* packed */;
      const reverseWH = textureType === 1 /* unpackedReversed */ || textureType === 2 /* packed */;
      const breakAxis = textureType === 4 /* packedLastDimension */ ? shape2.length - 1 : void 0;
      const unpackedShape = textureType === 4 /* packedLastDimension */ ? shape2.map((d, i) => i === shape2.length - 1 ? d * 4 : d) : void 0;
      return createTextureLayoutFromShape(
        textureLayoutStrategy,
        shape2,
        channel,
        unpackedShape,
        { isPacked, reverseWH, breakAxis }
      );
    };
    calculateTextureWidthAndHeight = (textureLayoutStrategy, shape2, textureType) => {
      const layout = createTextureLayoutFromTextureType(textureLayoutStrategy, shape2, textureType);
      return [layout.width, layout.height];
    };
    createTextureLayoutFromShape = (textureLayoutStrategy, shape2, channels = 1, unpackedShape, prefs) => {
      const isPacked = !!(prefs && prefs.isPacked);
      const [width, height] = textureLayoutStrategy.computeTextureWH(isPacked ? unpackedShape || shape2 : shape2, prefs);
      const rank = shape2.length;
      let inferredDims = shape2.slice(0);
      if (rank === 0) {
        inferredDims = [1];
      }
      if (channels === 1) {
        unpackedShape = shape2;
      } else if (isPacked) {
        if (channels !== 4) {
          throw new Error("a packed texture must be 4-channel");
        }
        unpackedShape = shape2;
        if (rank > 0) {
          inferredDims[rank - 1] = Math.ceil(inferredDims[rank - 1] / 2);
        }
        if (rank > 1) {
          inferredDims[rank - 2] = Math.ceil(inferredDims[rank - 2] / 2);
        }
      } else if (!unpackedShape) {
        throw new Error("Unpacked shape is needed when using channels > 1");
      }
      return {
        width,
        height,
        channels,
        isPacked,
        shape: inferredDims,
        strides: ShapeUtil.computeStrides(inferredDims),
        unpackedShape,
        reversedWH: prefs && prefs.reverseWH
      };
    };
  }
});

// web/lib/onnxjs/backends/webgl/inference-handler.ts
var getProgramInfoUniqueKey, WebGLInferenceHandler;
var init_inference_handler = __esm({
  "web/lib/onnxjs/backends/webgl/inference-handler.ts"() {
    "use strict";
    init_instrument();
    init_tensor2();
    init_util();
    init_pack();
    init_reshape_packed();
    init_uint8_encode();
    init_unpack();
    init_texture_data_encoder();
    init_texture_layout();
    init_types();
    getProgramInfoUniqueKey = (programInfo, inputTextureDatas) => {
      const inputs = inputTextureDatas.map((texture) => `${texture.unpackedShape.join(",")};${texture.width}x${texture.height}`).join("_");
      let key = programInfo.name;
      if (programInfo.cacheHint) {
        key += "[" + programInfo.cacheHint + "]";
      }
      key += ":" + inputs;
      return key;
    };
    WebGLInferenceHandler = class {
      constructor(session) {
        this.session = session;
        this.packedTextureDataCache = /* @__PURE__ */ new Map();
        this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
      }
      /**
       * @returns [width, height]
       */
      calculateTextureWidthAndHeight(shape2, textureType) {
        return calculateTextureWidthAndHeight(this.session.layoutStrategy, shape2, textureType);
      }
      executeProgram(program, inputs) {
        if (inputs.length < program.inputNames.length) {
          throw new Error(`Input size mustn't be less than ${program.inputNames.length}.`);
        }
        if (program.inputNames.length !== program.inputTypes.length) {
          throw new Error("input names size does not match input types");
        }
        const inputTextureDatas = [];
        for (let i = 0; i < program.inputNames.length; ++i) {
          inputTextureDatas[i] = this.getOrCreateTextureData(inputs[i], program.inputTypes[i]);
        }
        const key = getProgramInfoUniqueKey(program, inputTextureDatas);
        let artifact = this.session.programManager.getArtifact(key);
        const programInfo = artifact ? artifact.programInfo : typeof program.get === "function" ? program.get() : program;
        const outputTextureLayout = createTextureLayoutFromTextureType(
          this.session.layoutStrategy,
          programInfo.output.dims,
          programInfo.output.textureType
        );
        const outputTextureData = this.createTextureData(outputTextureLayout, programInfo.output.type);
        if (!artifact) {
          artifact = this.session.programManager.build(programInfo, inputTextureDatas, outputTextureData);
          this.session.programManager.setArtifact(key, artifact);
        }
        this.runProgram(artifact, inputTextureDatas, outputTextureData);
        return outputTextureData;
      }
      run(program, inputs) {
        const outputTextureData = this.executeProgram(program, inputs);
        return outputTextureData.tensor;
      }
      runProgram(artifact, inputs, output) {
        for (let i = 0; i < inputs.length; ++i) {
          if (!!inputs[i].isPacked !== (artifact.programInfo.inputTypes[i] === 2 /* packed */)) {
            throw new Error(`input[${i}] property packed inconsistent`);
          }
        }
        if (!!output.isPacked !== (artifact.programInfo.output.textureType === 2 /* packed */)) {
          throw new Error("output property packed inconsistent");
        }
        this.session.programManager.run(artifact, inputs, output);
      }
      /**
       * Create a TextureData object from a tensor.
       * Usage = EncoderUsage.UploadOnly.
       * If a related texture data is found in cache, returns it;
       * Otherwise:
       *   Creates a new texture layout if not provided;
       *   Creates WebGLTexture with the layout;
       *   Upload tensor data to the texture;
       *   Creates a texture data object associated with the given tensor.
       * @param tensor the tensor with data to upload
       */
      getOrCreateTextureData(tensor, textureType) {
        let td = this.getTextureData(tensor.dataId, textureType === 2 /* packed */);
        if (!td) {
          td = this.getTextureData(tensor.dataId, textureType !== 2 /* packed */);
          if (td) {
            if (textureType === 2 /* packed */) {
              return this.pack(td);
            } else {
              return this.unpack(td);
            }
          }
        }
        if (!td) {
          const layout = createTextureLayoutFromTextureType(this.session.layoutStrategy, tensor.dims, textureType);
          if (textureType === 4 /* packedLastDimension */) {
            const group = 1;
            const channels = 4;
            const shape2 = tensor.dims;
            if (shape2.length === 4) {
              const adjustedKernelShape = [shape2[0], Math.ceil(shape2[1] * shape2[2] * shape2[3] / channels)];
              const adjustedLayout = createTextureLayoutFromTextureType(this.session.layoutStrategy, adjustedKernelShape, textureType);
              let buffer = tensor.numberData;
              if (shape2[1] * shape2[2] * shape2[3] % channels !== 0) {
                const numFeatureMaps = shape2[0];
                const oldRowSize = shape2[1] * shape2[2] * shape2[3];
                const newRowSize = Math.ceil(oldRowSize * group / channels) * channels;
                const newSize = numFeatureMaps * newRowSize;
                buffer = new Float32Array(newSize);
                for (let f = 0; f < numFeatureMaps; ++f) {
                  const oldOffset = f * oldRowSize;
                  const newOffset = f * newRowSize + f % group * oldRowSize;
                  buffer.set(tensor.numberData.subarray(oldOffset, oldOffset + oldRowSize), newOffset);
                }
              }
              return this.createTextureData(adjustedLayout, tensor.type, buffer, tensor, 1 /* UploadOnly */);
            }
          }
          if (textureType === 2 /* packed */) {
            const unpackedTextureLayout = createTextureLayoutFromShape(this.session.layoutStrategy, tensor.dims, 1, [], { reverseWH: true });
            const unpackedTextureData = this.createTextureData(
              unpackedTextureLayout,
              tensor.type,
              tensor.numberData,
              tensor,
              1 /* UploadOnly */
            );
            td = this.pack(unpackedTextureData);
          } else {
            td = this.createTextureData(layout, tensor.type, tensor.numberData, tensor, 1 /* UploadOnly */);
          }
        }
        return td;
      }
      /**
       * Create a TextureData object using the given data and bind to the given tensor.
       * Usage = EncoderUsage.UploadOnly.
       * NOTE: this function is a hack for Conv implementation. should remove this function, after rewriting Conv
       * implementation by Graph.Transformer
       * @param dataType the tensor data type
       * @param data the actual data to upload
       * @param tensor the tensor to bind. tensor's data is ignored.
       */
      createTextureDataFromLayoutBindTensor(layout, dataType, data, tensor) {
        return this.createTextureData(layout, dataType, data, tensor, 1 /* UploadOnly */);
      }
      createTextureData(layout, dataType, data, tensor, usage) {
        Logger.verbose("InferenceHandler", `Creating TextureData: layout:[${JSON.stringify(layout)}]`);
        const texture = this.session.textureManager.createTextureFromLayout(dataType, layout, data, usage);
        return this.createTextureDataFromTexture(layout, dataType, texture, tensor);
      }
      reshapeUnpacked(input, reshapedDims) {
        const inputTD = this.getOrCreateTextureData(input, 0 /* unpacked */);
        const newTextureLayout = {
          channels: inputTD.channels,
          height: inputTD.height,
          width: inputTD.width,
          // handle reshaping into scalar Tensors
          shape: reshapedDims.length !== 0 ? reshapedDims : [1],
          strides: ShapeUtil.computeStrides(reshapedDims),
          unpackedShape: reshapedDims
        };
        const newTextureData = this.createTextureDataFromTexture(newTextureLayout, input.type, inputTD.texture);
        return newTextureData.tensor;
      }
      reshapePacked(input, reshapedDims) {
        const inputTD = this.getOrCreateTextureData(input, 2 /* packed */);
        if (isReshapeCheap(input.dims, reshapedDims)) {
          const newTextureLayout = {
            channels: inputTD.channels,
            height: inputTD.height,
            width: inputTD.width,
            // handle reshaping into scalar Tensors
            shape: reshapedDims.length !== 0 ? reshapedDims : [1],
            strides: ShapeUtil.computeStrides(reshapedDims),
            unpackedShape: reshapedDims,
            isPacked: true
          };
          const newTextureData = this.createTextureDataFromTexture(newTextureLayout, input.type, inputTD.texture);
          return newTextureData.tensor;
        }
        const squeezedInputShape = processDims3D(input.dims);
        const squeezedOutputShape = processDims3D(reshapedDims);
        const squeezedInputTensor = this.reshapePacked(input, squeezedInputShape);
        const squeezedOutputTensor = this.run(
          createPackedReshape3DProgramInfoLoader(this, squeezedInputTensor, squeezedOutputShape),
          [squeezedInputTensor]
        );
        const outputTensor = this.reshapePacked(squeezedOutputTensor, reshapedDims);
        return outputTensor;
      }
      cast(input, type) {
        const inputTD = this.getOrCreateTextureData(input, 0 /* unpacked */);
        const newTextureData = this.createTextureDataFromTexture(inputTD, type, inputTD.texture);
        return newTextureData.tensor;
      }
      createTextureDataFromTexture(layout, dataType, texture, tensor, tensorId) {
        const textureData = {
          ...layout,
          tensor: tensor || new Tensor3(
            layout.unpackedShape,
            dataType,
            (_id) => this.readTexture(textureData),
            async (_id) => this.readTextureAsync(textureData),
            void 0,
            tensorId
          ),
          texture
        };
        this.setTextureData(textureData.tensor.dataId, textureData, layout.isPacked);
        return textureData;
      }
      getTextureData(tensorId, isPacked = false) {
        return this.session.isInitializer(tensorId) ? this.session.getTextureData(tensorId, isPacked) : isPacked ? this.packedTextureDataCache.get(tensorId) : this.unpackedTextureDataCache.get(tensorId);
      }
      setTextureData(tensorId, td, isPacked = false) {
        if (this.session.isInitializer(tensorId)) {
          this.session.setTextureData(tensorId, td, isPacked);
        } else {
          (isPacked ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(tensorId, td);
        }
      }
      isTextureLayoutCached(tensor, isPacked = false) {
        return !!this.getTextureData(tensor.dataId, isPacked);
      }
      dispose() {
        this.session.textureManager.clearActiveTextures();
        this.packedTextureDataCache.forEach((td) => this.session.textureManager.releaseTexture(td));
        this.packedTextureDataCache = /* @__PURE__ */ new Map();
        this.unpackedTextureDataCache.forEach((td) => this.session.textureManager.releaseTexture(td));
        this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
      }
      readTexture(textureData) {
        if (textureData.isPacked) {
          return this.readTexture(this.unpack(textureData));
        }
        if (!this.session.backend.glContext.isFloat32DownloadSupported) {
          return this.session.textureManager.readUint8TextureAsFloat(encodeAsUint8(this, textureData));
        }
        return this.session.textureManager.readTexture(textureData, textureData.tensor.type, textureData.channels);
      }
      async readTextureAsync(textureData) {
        if (textureData.isPacked) {
          return this.readTextureAsync(this.unpack(textureData));
        }
        if (!this.session.backend.glContext.isFloat32DownloadSupported) {
          return this.session.textureManager.readUint8TextureAsFloat(encodeAsUint8(this, textureData));
        }
        return this.session.textureManager.readTextureAsync(textureData, textureData.tensor.type, textureData.channels);
      }
      pack(input) {
        const outputTextureData = this.executeProgram(createPackProgramInfoLoader(this, input.tensor), [input.tensor]);
        return outputTextureData;
      }
      unpack(input) {
        const outputTextureData = this.executeProgram(createUnpackProgramInfoLoader(this, input.tensor), [input.tensor]);
        return outputTextureData;
      }
    };
  }
});

// web/lib/onnxjs/attribute-with-cache-key.ts
var AttributeWithCacheKeyImpl, createAttributeWithCacheKey;
var init_attribute_with_cache_key = __esm({
  "web/lib/onnxjs/attribute-with-cache-key.ts"() {
    "use strict";
    AttributeWithCacheKeyImpl = class {
      constructor(attribute) {
        Object.assign(this, attribute);
      }
      get cacheKey() {
        if (!this.key) {
          this.key = Object.getOwnPropertyNames(this).sort().map((name2) => `${this[name2]}`).join(";");
        }
        return this.key;
      }
    };
    createAttributeWithCacheKey = (attribute) => new AttributeWithCacheKeyImpl(attribute);
  }
});

// web/lib/onnxjs/backends/webgl/ops/batch-normalization.ts
var batchNormalizationProgramMetadata, batchNormalization, parseBatchNormalizationAttributes, createBatchNormalizationProgramInfo, validateInputs;
var init_batch_normalization = __esm({
  "web/lib/onnxjs/backends/webgl/ops/batch-normalization.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_glsl_source();
    init_types();
    batchNormalizationProgramMetadata = {
      name: "BatchNormalization",
      inputNames: ["A", "Scale", "B", "Mean", "Variance"],
      inputTypes: [0 /* unpacked */, 0 /* unpacked */, 0 /* unpacked */, 0 /* unpacked */, 0 /* unpacked */]
    };
    batchNormalization = (inferenceHandler, inputs, attributes) => {
      validateInputs(inputs);
      const output = inferenceHandler.run(
        {
          ...batchNormalizationProgramMetadata,
          cacheHint: attributes.cacheKey,
          get: () => createBatchNormalizationProgramInfo(inferenceHandler, inputs, attributes)
        },
        inputs
      );
      return [output];
    };
    parseBatchNormalizationAttributes = (node) => {
      const epsilon = node.attributes.getFloat("epsilon", 1e-5);
      const momentum = node.attributes.getFloat("momentum", 0.9);
      const spatial = node.attributes.getInt("spatial", 1);
      return createAttributeWithCacheKey({ epsilon, momentum, spatial });
    };
    createBatchNormalizationProgramInfo = (inferenceHandler, inputs, attributes) => {
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      const rank = inputs[0].dims.length;
      const [scaleWidth, scaleHeight] = inferenceHandler.calculateTextureWidthAndHeight(inputs[1].dims, 0 /* unpacked */);
      const shaderSource = `
  float process(int[${rank}] indices) {
    vec2 position = offsetToCoords(indices[1], ${scaleWidth}, ${scaleHeight});
    float scale = getColorAsFloat(${glsl.texture2D}(Scale, position));
    float mean = getColorAsFloat(${glsl.texture2D}(Mean, position));
    float variance = getColorAsFloat(${glsl.texture2D}(Variance, position));
    float b = getColorAsFloat(${glsl.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${attributes.epsilon})) ) + b;
  }`;
      return {
        ...batchNormalizationProgramMetadata,
        output: { dims: inputs[0].dims, type: inputs[0].type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    validateInputs = (inputs) => {
      if (!inputs || inputs.length !== 5) {
        throw new Error("BatchNormalization requires 5 inputs.");
      }
      const X = inputs[0];
      const scale = inputs[1];
      const B = inputs[2];
      const mean = inputs[3];
      const var_ = inputs[4];
      if (X.dims.length < 3 || scale.dims.length !== 1 || B.dims.length !== 1 || mean.dims.length !== 1 || var_.dims.length !== 1) {
        throw new Error("invalid input shape.");
      }
      if (scale.dims[0] !== X.dims[1] || B.dims[0] !== X.dims[1] || mean.dims[0] !== X.dims[1] || var_.dims[0] !== X.dims[1]) {
        throw new Error("invalid input shape.");
      }
      if (X.type !== "float32" && X.type !== "float64" || scale.type !== "float32" && scale.type !== "float64" || B.type !== "float32" && B.type !== "float64" || mean.type !== "float32" && mean.type !== "float64" || var_.type !== "float32" && var_.type !== "float64") {
        throw new Error("invalid input tensor types.");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/glsl-definitions.ts
var GlslContext, GlslLib, GlslLibRoutine, GlslLibRoutineNode, TopologicalSortGlslRoutines;
var init_glsl_definitions = __esm({
  "web/lib/onnxjs/backends/webgl/glsl-definitions.ts"() {
    "use strict";
    GlslContext = class {
      constructor(glContext, programInfo, inputTextureLayouts, outputTextureLayout) {
        this.glContext = glContext;
        this.programInfo = programInfo;
        this.inputTextureLayouts = inputTextureLayouts;
        this.outputTextureLayout = outputTextureLayout;
      }
    };
    GlslLib = class {
      constructor(context) {
        this.context = context;
      }
    };
    GlslLibRoutine = class {
      constructor(routineBody, dependencies) {
        this.routineBody = routineBody;
        this.dependencies = dependencies;
      }
    };
    GlslLibRoutineNode = class {
      constructor(name2, routineBody, dependencies) {
        this.name = name2;
        if (dependencies) {
          this.dependencies = dependencies;
        } else {
          this.dependencies = [];
        }
        if (routineBody) {
          this.routineBody = routineBody;
        }
      }
      addDependency(node) {
        if (node) {
          this.dependencies.push(node);
        }
      }
    };
    TopologicalSortGlslRoutines = class {
      static returnOrderedNodes(nodes) {
        if (!nodes || nodes.length === 0) {
          return [];
        }
        if (nodes.length === 1) {
          return nodes;
        }
        const cycleCheck = /* @__PURE__ */ new Set();
        const alreadyTraversed = /* @__PURE__ */ new Set();
        const result = new Array();
        this.createOrderedNodes(nodes, cycleCheck, alreadyTraversed, result);
        return result;
      }
      static createOrderedNodes(graphNodes, cycleCheck, alreadyTraversed, result) {
        for (let i = 0; i < graphNodes.length; ++i) {
          this.dfsTraverse(graphNodes[i], cycleCheck, alreadyTraversed, result);
        }
      }
      static dfsTraverse(root, cycleCheck, alreadyTraversed, result) {
        if (!root || alreadyTraversed.has(root.name)) {
          return;
        }
        if (cycleCheck.has(root.name)) {
          throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");
        }
        cycleCheck.add(root.name);
        const dependencies = root.dependencies;
        if (dependencies && dependencies.length > 0) {
          for (let i = 0; i < dependencies.length; ++i) {
            this.dfsTraverse(dependencies[i], cycleCheck, alreadyTraversed, result);
          }
        }
        result.push(root);
        alreadyTraversed.add(root.name);
        cycleCheck.delete(root.name);
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/binary-op.ts
function glslAdd() {
  const name2 = "add_";
  const body = `
  float ${name2}(float a, float b) {
    return a + b;
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslDiv() {
  const name2 = "div_";
  const body = `
  float ${name2}(float a, float b) {
    return a / b;
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslMul() {
  const name2 = "mul_";
  const body = `
  float ${name2}(float a, float b) {
    return a * b;
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslSub() {
  const name2 = "sub_";
  const body = `
  float ${name2}(float a, float b) {
    return a - b;
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslEqual() {
  const name2 = "equal_";
  const body = `
  float ${name2}(float a, float b) {
    return float(a == b);
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslGreater() {
  const name2 = "greater_";
  const body = `
  float ${name2}(float a, float b) {
    return float(a > b);
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslLess() {
  const name2 = "less_";
  const body = `
  float ${name2}(float a, float b) {
    return float(a < b);
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslAnd() {
  const name2 = "and_";
  const body = `
  float ${name2}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslOr() {
  const name2 = "or_";
  const body = `
  float ${name2}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslXor() {
  const name2 = "xor_";
  const body = `
  float ${name2}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslPow() {
  return glslBuiltinBinary("pow");
}
function glslPRelu() {
  const name2 = "prelu_";
  const body = `
  float ${name2}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslBuiltinBinary(fname) {
  const name2 = `${fname}_`;
  const body = `
  float ${name2}(float a, float b) {
    return ${fname}(a, b);
  }
  vec4 ${name2}(vec4 v1, vec4 v2) {
    return ${fname}(v1, v2);
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
var createBinaryProgramInfoLoader, createBinaryProgramInfo, add2, and2, div, equal, greater, less, mul, or2, pow, pRelu, sub, xor2;
var init_binary_op = __esm({
  "web/lib/onnxjs/backends/webgl/ops/binary-op.ts"() {
    "use strict";
    init_util();
    init_glsl_definitions();
    init_glsl_source();
    init_types();
    createBinaryProgramInfoLoader = (handler, inputs, glslFunc, outputTensorType = inputs[0].type, cacheKey) => {
      const textureType = handler.session.pack ? 2 /* packed */ : 0 /* unpacked */;
      return {
        name: glslFunc.name,
        inputNames: ["A", "B"],
        inputTypes: [textureType, textureType],
        cacheHint: cacheKey,
        get: () => createBinaryProgramInfo(handler, inputs, glslFunc, outputTensorType)
      };
    };
    createBinaryProgramInfo = (handler, inputs, glslFunc, outputTensorType = inputs[0].type) => {
      const textureType = handler.session.pack ? 2 /* packed */ : 0 /* unpacked */;
      const isBroadcast = !ShapeUtil.areEqual(inputs[0].dims, inputs[1].dims);
      let outputShape = inputs[0].dims;
      const usePackedTexture = handler.session.pack;
      if (isBroadcast) {
        const calculatedShape = BroadcastUtil.calcShape(inputs[0].dims, inputs[1].dims, false);
        if (!calculatedShape) {
          throw new Error("Can't perform binary op on the given tensors");
        }
        outputShape = calculatedShape;
        const outputRank = outputShape.length;
        const aRank = inputs[0].dims.length !== 0 ? inputs[0].dims.length : 1;
        const bRank = inputs[1].dims.length !== 0 ? inputs[1].dims.length : 1;
        const aBcast = inputs[0].dims.length !== 0 ? "bcastIndices_A(indices, aindices);" : "aindices[0] = 0;";
        const bBcast = inputs[1].dims.length !== 0 ? "bcastIndices_B(indices, bindices);" : "bindices[0] = 0;";
        const glsl2 = getGlsl(handler.session.backend.glContext.version);
        const shaderSource2 = usePackedTexture ? `
      ${glslFunc.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${glslFunc.name}(a, b);
        ${glsl2.output} = result;
      }` : `
      ${glslFunc.body}
      float process(int indices[${outputRank}]) {
        int aindices[${aRank}];
        int bindices[${bRank}];
        ${aBcast}
        ${bBcast}
        return ${glslFunc.name}(_A(aindices), _B(bindices));
      }`;
        return {
          name: glslFunc.name,
          inputNames: ["A", "B"],
          inputTypes: [textureType, textureType],
          output: { dims: outputShape, type: outputTensorType, textureType },
          shaderSource: shaderSource2,
          hasMain: usePackedTexture
        };
      }
      const glsl = getGlsl(handler.session.backend.glContext.version);
      const shaderSource = `
    ${glslFunc.body}
    void main() {
      vec4 v1 = ${glsl.texture2D}(A, TexCoords);
      vec4 v2 = ${glsl.texture2D}(B, TexCoords);
      vec4 result = ${glslFunc.name}(v1, v2);
      ${glsl.output} = result;
    }
    `;
      return {
        name: glslFunc.name,
        inputNames: ["A", "B"],
        inputTypes: [textureType, textureType],
        output: { dims: inputs[0].dims, type: outputTensorType, textureType },
        shaderSource,
        hasMain: true
      };
    };
    add2 = (handler, inputs) => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslAdd()), inputs)];
    and2 = (handler, inputs) => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslAnd(), "bool"), inputs)];
    div = (handler, inputs) => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslDiv()), inputs)];
    equal = (handler, inputs) => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslEqual(), "bool"), inputs)];
    greater = (handler, inputs) => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslGreater(), "bool"), inputs)];
    less = (handler, inputs) => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslLess(), "bool"), inputs)];
    mul = (handler, inputs) => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslMul()), inputs)];
    or2 = (handler, inputs) => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslOr(), "bool"), inputs)];
    pow = (handler, inputs) => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslPow()), inputs)];
    pRelu = (handler, inputs) => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslPRelu()), inputs)];
    sub = (handler, inputs) => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslSub()), inputs)];
    xor2 = (handler, inputs) => [handler.run(createBinaryProgramInfoLoader(handler, inputs, glslXor(), "bool"), inputs)];
  }
});

// web/lib/onnxjs/backends/webgl/ops/cast.ts
var cast, parseCastAttributes, validateInputs2;
var init_cast = __esm({
  "web/lib/onnxjs/backends/webgl/ops/cast.ts"() {
    "use strict";
    init_util();
    cast = (handler, inputs, to) => {
      validateInputs2(inputs);
      return [handler.cast(inputs[0], to)];
    };
    parseCastAttributes = (node) => ProtoUtil.tensorDataTypeFromProto(node.attributes.getInt("to"));
    validateInputs2 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Cast requires 1 input.");
      }
      if (inputs[0].type === "string") {
        throw new Error("Invalid input type.");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/concat-packed.ts
var createPackedConcatProgramMetadata, createPackedConcatProgramInfo, createPackedConcatProgramInfoLoader, getShiftedChannelsSnippet;
var init_concat_packed = __esm({
  "web/lib/onnxjs/backends/webgl/ops/concat-packed.ts"() {
    "use strict";
    init_glsl_source();
    init_types();
    init_utils();
    init_packing_utils();
    createPackedConcatProgramMetadata = (inputCount, cacheHint) => ({
      name: "Concat (packed)",
      inputNames: Array.from({ length: inputCount }, (_v, i) => `X${i}`),
      inputTypes: Array(inputCount).fill(2 /* packed */),
      cacheHint
    });
    createPackedConcatProgramInfo = (handler, metadata, inputs, axis) => {
      const inputShape = inputs[0].dims.slice();
      if (axis >= inputShape.length || axis < -1 * inputShape.length) {
        throw new Error("axis specified for concat doesn't match input dimensionality");
      }
      if (axis < 0) {
        axis = inputShape.length + axis;
      }
      const outputShape = inputShape.slice(0);
      for (let i = 1; i < inputs.length; i++) {
        const dataNShape = inputs[i].dims.slice();
        for (let axisIndex = 0; axisIndex < inputShape.length; axisIndex++) {
          if (axisIndex === axis) {
            outputShape[axis] += dataNShape[axisIndex];
          } else if (inputShape[axisIndex] !== dataNShape[axisIndex]) {
            throw new Error("non concat dimensions must match");
          }
        }
      }
      const rank = outputShape.length;
      const coords = getChannels("coords", rank);
      const dtype = getCoordsDataType(rank);
      const unpackChannel = unpackFromChannel();
      const shapes = inputs.map((i) => i.dims);
      const channels = getGlChannels(rank);
      const offsets = new Array(shapes.length - 1);
      offsets[0] = shapes[0][axis];
      for (let i = 1; i < offsets.length; i++) {
        offsets[i] = offsets[i - 1] + shapes[i][axis];
      }
      const channel = channels[axis];
      const lastChannels = channels.slice(-2);
      const allChannels = channels.join();
      let getValueSnippet = `if (${channel} < ${offsets[0]}) {
        return getChannel(
            getX0(${allChannels}), vec2(${lastChannels.join()}));
        }`;
      for (let i = 1; i < offsets.length; i++) {
        const shift2 = offsets[i - 1];
        getValueSnippet += `
            if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {
              return getChannel(
                getX${i}(${getShiftedChannelsSnippet(channels, channel, shift2)}),
                vec2(${getShiftedChannelsSnippet(lastChannels, channel, shift2)}));
            }`;
      }
      const lastIndex = offsets.length;
      const shift = offsets[offsets.length - 1];
      getValueSnippet += `
            return getChannel(
              getX${lastIndex}(${getShiftedChannelsSnippet(channels, channel, shift)}),
              vec2(${getShiftedChannelsSnippet(lastChannels, channel, shift)}));`;
      const glsl = getGlsl(handler.session.backend.glContext.version);
      const shaderSource = `
          ${unpackChannel}
          float getValue(${channels.map((x) => "int " + x)}) {
            ${getValueSnippet}
          }

          void main() {
            ${dtype} coords = getOutputCoords();
            int lastDim = coords.${channels[rank - 1]};
            coords.${channels[rank - 1]} = coords.${channels[rank - 2]};
            coords.${channels[rank - 2]} = lastDim;

            vec4 result = vec4(getValue(${coords}), 0., 0., 0.);

            ${coords[rank - 1]} = ${coords[rank - 1]} + 1;
            if (${coords[rank - 1]} < ${outputShape[rank - 1]}) {
              result.g = getValue(${coords});
            }

            ${coords[rank - 2]} = ${coords[rank - 2]} + 1;
            if (${coords[rank - 2]} < ${outputShape[rank - 2]}) {
              result.a = getValue(${coords});
            }

            ${coords[rank - 1]} = ${coords[rank - 1]} - 1;
            if (${coords[rank - 2]} < ${outputShape[rank - 2]} &&
                ${coords[rank - 1]} < ${outputShape[rank - 1]}) {
              result.b = getValue(${coords});
            }
            ${glsl.output} = result;
          }
        `;
      return {
        ...metadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 2 /* packed */ },
        shaderSource,
        hasMain: true
      };
    };
    createPackedConcatProgramInfoLoader = (handler, inputs, attributes) => {
      const metadata = createPackedConcatProgramMetadata(inputs.length, attributes.cacheKey);
      return { ...metadata, get: () => createPackedConcatProgramInfo(handler, metadata, inputs, attributes.axis) };
    };
    getShiftedChannelsSnippet = (channels, channel, shift) => {
      const channelIdx = channels.indexOf(channel);
      const res = channels.map((c, idx) => {
        if (idx === channelIdx) {
          return `${c} - ${shift}`;
        } else {
          return c;
        }
      });
      return res.join();
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/concat.ts
var concat, createUnpackedConcatProgramMetadata, createUnpackedConcatProgramInfo, createUnpackedConcatProgramInfoLoader, getTextureIndexWhereDataResidesLinearSearch, getTextureIndexWhereDataResidesBinarySearch, getFetchDataFromCorrectTextureMethod, getGetSizeInConcatAxisValueFromIndexMethod, parseConcatAttributes, validateInputs3;
var init_concat = __esm({
  "web/lib/onnxjs/backends/webgl/ops/concat.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_types();
    init_concat_packed();
    concat = (inferenceHandler, inputs, attributes) => {
      validateInputs3(inputs);
      if (inferenceHandler.session.pack && inputs[0].dims.length > 1) {
        const output = inferenceHandler.run(createPackedConcatProgramInfoLoader(inferenceHandler, inputs, attributes), inputs);
        return [output];
      } else {
        const output = inferenceHandler.run(createUnpackedConcatProgramInfoLoader(inferenceHandler, inputs, attributes), inputs);
        return [output];
      }
    };
    createUnpackedConcatProgramMetadata = (inputCount, cacheHint) => ({
      name: "Concat",
      inputNames: Array.from({ length: inputCount }, (_v, i) => `X${i}`),
      inputTypes: Array(inputCount).fill(0 /* unpacked */),
      cacheHint
    });
    createUnpackedConcatProgramInfo = (_handler, metadata, inputs, axis) => {
      const inputShape = inputs[0].dims.slice();
      if (axis >= inputShape.length || axis < -1 * inputShape.length) {
        throw new Error("axis specified for concat doesn't match input dimensionality");
      }
      if (axis < 0) {
        axis = inputShape.length + axis;
      }
      const outputShape = inputShape.slice(0);
      for (let i = 1; i < inputs.length; i++) {
        const dataNShape = inputs[i].dims.slice();
        for (let axisIndex = 0; axisIndex < inputShape.length; axisIndex++) {
          if (axisIndex === axis) {
            outputShape[axis] += dataNShape[axisIndex];
          } else if (inputShape[axisIndex] !== dataNShape[axisIndex]) {
            throw new Error("non concat dimensions must match");
          }
        }
      }
      const rank = outputShape.length;
      const sizeInConcatAxis = new Array(inputs.length);
      let previousSum = 0;
      for (let i = 0; i < sizeInConcatAxis.length; ++i) {
        previousSum += inputs[i].dims[axis];
        sizeInConcatAxis[i] = previousSum;
      }
      let getTextureIndexWhereDataResidesMethod = "";
      if (inputs.length < 5) {
        getTextureIndexWhereDataResidesMethod = getTextureIndexWhereDataResidesLinearSearch(sizeInConcatAxis);
      } else {
        getTextureIndexWhereDataResidesMethod = getTextureIndexWhereDataResidesBinarySearch(sizeInConcatAxis);
      }
      const fetchDataFromCorrectTextureMethod = getFetchDataFromCorrectTextureMethod(inputs.length, rank);
      const getSizeInConcatAxisValueFromIndexMethod = getGetSizeInConcatAxisValueFromIndexMethod(sizeInConcatAxis);
      const shaderSource = `
        ${fetchDataFromCorrectTextureMethod}
        ${getSizeInConcatAxisValueFromIndexMethod}
        ${getTextureIndexWhereDataResidesMethod}
        float process(int indices[${rank}]) {
          int textureIndex = getTextureWhereDataResides (indices[${axis}]);

          if(textureIndex != 0) {
            indices[${axis}] = indices[${axis}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;
      return {
        ...metadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    createUnpackedConcatProgramInfoLoader = (handler, inputs, attributes) => {
      const metadata = createUnpackedConcatProgramMetadata(inputs.length, attributes.cacheKey);
      return { ...metadata, get: () => createUnpackedConcatProgramInfo(handler, metadata, inputs, attributes.axis) };
    };
    getTextureIndexWhereDataResidesLinearSearch = (sizeInConcatAxis) => {
      const searchAxis = sizeInConcatAxis.map((size, i) => `if(index<${size}) {return ${i};}
`);
      return `int getTextureWhereDataResides(int index) {
      ${searchAxis.join("")}
    }`;
    };
    getTextureIndexWhereDataResidesBinarySearch = (sizeInConcatAxis) => getTextureIndexWhereDataResidesLinearSearch(sizeInConcatAxis);
    getFetchDataFromCorrectTextureMethod = (numberOfTensors, tensorRank) => {
      const codeLines = [`float fetchDataFromCorrectTexture(int textureIndex, int indices[${tensorRank}]) {`];
      for (let i = 0; i < numberOfTensors; ++i) {
        if (i === 0) {
          codeLines.push(
            `	if (textureIndex == ${i}) { return _X${i}(indices); }`
          );
        } else if (i === numberOfTensors - 1) {
          codeLines.push(
            `	else { return _X${i}(indices); }`
          );
        } else {
          codeLines.push(
            `	else if (textureIndex == ${i}) { return _X${i}(indices); }`
          );
        }
      }
      codeLines.push(
        "	}"
      );
      return codeLines.join("\n");
    };
    getGetSizeInConcatAxisValueFromIndexMethod = (sizeInConcatAxis) => {
      const codeLines = ["int getSizeInConcatAxisValueFromIndex(int index) {"];
      for (let i = 0; i < sizeInConcatAxis.length; ++i) {
        if (i === 0) {
          codeLines.push(
            `	if (index == ${i}) { return ${sizeInConcatAxis[i]}; }`
          );
        } else if (i === sizeInConcatAxis.length - 1) {
          codeLines.push(
            `	else { return ${sizeInConcatAxis[i]}; }`
          );
        } else {
          codeLines.push(
            `	else if (index == ${i}) { return ${sizeInConcatAxis[i]}; }`
          );
        }
      }
      codeLines.push(
        "	}"
      );
      return codeLines.join("\n");
    };
    parseConcatAttributes = (node) => createAttributeWithCacheKey({ axis: node.attributes.getInt("axis") });
    validateInputs3 = (inputs) => {
      if (!inputs || inputs.length < 1) {
        throw new Error("too few inputs");
      }
      const inputType = inputs[0].type;
      const inputDimensionality = inputs[0].dims.length;
      if (inputType === "string") {
        throw new Error("string tensor is not supported yet");
      }
      for (const input of inputs) {
        if (input.type !== inputType) {
          throw new Error("input tensors should be one type");
        }
        if (input.dims.length !== inputDimensionality) {
          throw new Error("input tensors should have the same shape");
        }
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/unary-op.ts
function glslAbs() {
  return glslBuiltinUnary("abs");
}
function glslAcos() {
  return glslBuiltinUnary("acos");
}
function glslAsin() {
  return glslBuiltinUnary("asin");
}
function glslAtan() {
  return glslBuiltinUnary("atan");
}
function glslCeil() {
  return glslBuiltinUnary("ceil");
}
function glslCos() {
  return glslBuiltinUnary("cos");
}
function glslElu(alpha) {
  const name2 = "elu";
  const body = `
  const float alpha = float(${alpha});

  float ${name2}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${name2}_(vec4 v) {
    return vec4(${name2}_(v.x), ${name2}_(v.y), ${name2}_(v.z), ${name2}_(v.w));
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslExp() {
  return glslBuiltinUnary("exp");
}
function glslFloor() {
  return glslBuiltinUnary("floor");
}
function glslClip(min, max) {
  const name2 = "clip";
  const body = `
  const float min = float(${min});
  const float max = float(${max});

  float ${name2}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${name2}_(vec4 v) {
    return clamp(v, min, max);
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslIdentity() {
  const name2 = "indentity";
  const body = `
  float ${name2}_(float a) {
    return a;
  }
  vec4 ${name2}_(vec4 v) {
    return v;
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslLeakyRelu(alpha) {
  const name2 = "leakyRelu";
  const body = `
  const float alpha = float(${alpha});

  float ${name2}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${name2}_(vec4 v) {
    return vec4(${name2}_(v.x), ${name2}_(v.y), ${name2}_(v.z), ${name2}_(v.w));
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslLog() {
  return glslBuiltinUnary("log");
}
function glslNeg() {
  const name2 = "neg";
  const body = `
  float ${name2}_(float a) {
    return -a;
  }
  vec4 ${name2}_(vec4 v) {
    return -v;
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslNot() {
  const name2 = "not";
  const body = `
  float ${name2}_(float a) {
    return float( ! bool(a) );
  }
  bool ${name2}_(bool a) {
    return !a;
  }
  vec4 ${name2}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${name2}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslSin() {
  return glslBuiltinUnary("sin");
}
function glslRelu() {
  const name2 = "relu";
  const body = `
  float ${name2}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${name2}_(vec4 v) {
    return max( v, 0.0 );
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslSigmoid() {
  const name2 = "sigmoid";
  const body = `
  float ${name2}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${name2}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslSqrt() {
  return glslBuiltinUnary("sqrt");
}
function glslTan() {
  return glslBuiltinUnary("tan");
}
function glslTanh() {
  const name2 = "tanh";
  const body = `
  float ${name2}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${name2}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
function glslBuiltinUnary(name2) {
  const body = `
  float ${name2}_(float a) {
    return ${name2}(a);
  }
  vec4 ${name2}_(vec4 v) {
    return ${name2}(v);
  }
  `;
  return { body, name: name2, type: 0 /* ValueBased */ };
}
var createElementwiseProgramInfo, createElementwiseProgramInfoLoader, abs, acos, asin, atan, clip, parseClipAttributes, clipV11, generateClipAttributesFromInputs, ceil, cos, elu, parseEluAttributes, exp, floor, identity, leakyRelu, parseLeakyReluAttributes, log2, neg, not2, relu, sigmoid, sin, sqrt, tan, tanh;
var init_unary_op = __esm({
  "web/lib/onnxjs/backends/webgl/ops/unary-op.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_util();
    init_glsl_definitions();
    init_glsl_source();
    init_types();
    createElementwiseProgramInfo = (handler, metadata, input, glslFunc) => {
      const textureType = handler.session.pack ? 2 /* packed */ : 0 /* unpacked */;
      const glsl = getGlsl(handler.session.backend.glContext.version);
      return {
        ...metadata,
        output: { dims: input.dims, type: input.type, textureType },
        shaderSource: `
     ${glslFunc.body}
     void main() {
       vec4 v = ${glsl.texture2D}(A, TexCoords);
       v = ${glslFunc.name}_(v);
       ${glsl.output} = v;
     }
     `,
        hasMain: true
      };
    };
    createElementwiseProgramInfoLoader = (handler, input, glslFunc, cacheKey) => {
      const textureType = handler.session.pack ? 2 /* packed */ : 0 /* unpacked */;
      const metadata = { name: glslFunc.name, inputTypes: [textureType], inputNames: ["A"], cacheHint: cacheKey };
      return { ...metadata, get: () => createElementwiseProgramInfo(handler, metadata, input, glslFunc) };
    };
    abs = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAbs()), inputs)];
    acos = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAcos()), inputs)];
    asin = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAsin()), inputs)];
    atan = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslAtan()), inputs)];
    clip = (handler, inputs, attributes) => [handler.run(
      createElementwiseProgramInfoLoader(
        handler,
        inputs[0],
        glslClip(attributes.min, attributes.max),
        attributes.cacheKey
      ),
      inputs
    )];
    parseClipAttributes = (node) => createAttributeWithCacheKey(
      { min: node.attributes.getFloat("min", MIN_CLIP), max: node.attributes.getFloat("max", MAX_CLIP) }
    );
    clipV11 = (handler, inputs) => {
      const attributes = generateClipAttributesFromInputs(handler, inputs);
      return clip(handler, [inputs[0]], attributes);
    };
    generateClipAttributesFromInputs = (handler, inputs) => {
      if (inputs.length >= 3 && (!handler.session.isInitializer(inputs[1].dataId) || !handler.session.isInitializer(inputs[2].dataId))) {
        throw new Error("dynamic clip attributes are not allowed");
      }
      const min = inputs.length >= 3 ? inputs[1].numberData[0] : MIN_CLIP;
      const max = inputs.length >= 3 ? inputs[2].numberData[0] : MAX_CLIP;
      return createAttributeWithCacheKey({ min, max });
    };
    ceil = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslCeil()), inputs)];
    cos = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslCos()), inputs)];
    elu = (handler, inputs, attributes) => [handler.run(
      createElementwiseProgramInfoLoader(handler, inputs[0], glslElu(attributes.alpha), attributes.cacheKey),
      inputs
    )];
    parseEluAttributes = (node) => createAttributeWithCacheKey({ alpha: node.attributes.getFloat("alpha", 1) });
    exp = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslExp()), inputs)];
    floor = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslFloor()), inputs)];
    identity = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslIdentity()), inputs)];
    leakyRelu = (handler, inputs, attributes) => [handler.run(
      createElementwiseProgramInfoLoader(handler, inputs[0], glslLeakyRelu(attributes.alpha), attributes.cacheKey),
      inputs
    )];
    parseLeakyReluAttributes = (node) => createAttributeWithCacheKey({ alpha: node.attributes.getFloat("alpha", 0.01) });
    log2 = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslLog()), inputs)];
    neg = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslNeg()), inputs)];
    not2 = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslNot()), inputs)];
    relu = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslRelu()), inputs)];
    sigmoid = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslSigmoid()), inputs)];
    sin = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslSin()), inputs)];
    sqrt = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslSqrt()), inputs)];
    tan = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslTan()), inputs)];
    tanh = (handler, inputs) => [handler.run(createElementwiseProgramInfoLoader(handler, inputs[0], glslTanh()), inputs)];
  }
});

// web/lib/onnxjs/backends/webgl/ops/fuse-utils.ts
function getActivationSnippet(attributes) {
  let func;
  switch (attributes.activation) {
    case "Relu":
      func = glslRelu();
      break;
    case "Sigmoid":
      func = glslSigmoid();
      break;
    case "Clip":
      func = glslClip(attributes.clipMin, attributes.clipMax);
      break;
    default:
      return { activationFunction: "", applyActivation: "" };
  }
  const activationName = func.name;
  const activationFunction = func.body;
  const applyActivation = `value = ${activationName}_(value);`;
  return { activationFunction, applyActivation };
}
var parseInternalActivationAttributes;
var init_fuse_utils = __esm({
  "web/lib/onnxjs/backends/webgl/ops/fuse-utils.ts"() {
    "use strict";
    init_util();
    init_unary_op();
    parseInternalActivationAttributes = (attributes) => {
      const activation = attributes.getString("activation", "");
      if (activation === "Clip") {
        const [clipMin, clipMax] = attributes.getFloats("activation_params", [MIN_CLIP, MAX_CLIP]);
        return { activation, clipMax, clipMin, activationCacheKey: `${activation}:${clipMin},${clipMax}` };
      }
      return { activation, activationCacheKey: activation };
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/conv-grouped.ts
var createUnpackedGroupedConvProgramMetadata, createUnpackedGroupedConvProgramInfo, createUnpackedGroupedConvProgramInfoLoader;
var init_conv_grouped = __esm({
  "web/lib/onnxjs/backends/webgl/ops/conv-grouped.ts"() {
    "use strict";
    init_instrument();
    init_glsl_source();
    init_types();
    init_conv();
    init_fuse_utils();
    createUnpackedGroupedConvProgramMetadata = (hasBias, cacheHint) => ({
      name: "GroupedConv",
      inputNames: hasBias ? ["X", "W", "Bias"] : ["X", "W"],
      inputTypes: hasBias ? [0 /* unpacked */, 0 /* unpacked */, 0 /* unpacked */] : [0 /* unpacked */, 0 /* unpacked */],
      cacheHint
    });
    createUnpackedGroupedConvProgramInfo = (inferenceHandler, inputs, metadata, attributes) => {
      const hasBias = inputs.length > 2;
      const processBias = hasBias ? "value += getBias(output_channel);" : "";
      const xShape = inputs[0].dims.slice();
      const wShape = inputs[1].dims.slice();
      const outputChannelsPerGroup = wShape[0] / attributes.group;
      Logger.verbose(
        "GroupedConv",
        `autpPad:${attributes.autoPad}, dilations:${attributes.dilations}, group:${attributes.group}, kernelShape:${attributes.kernelShape}, pads:${attributes.pads}, strides:${attributes.strides}`
      );
      const outputShape = calculateOutputShape(xShape, wShape, attributes.dilations, attributes.pads, attributes.strides);
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      const { activationFunction, applyActivation } = getActivationSnippet(attributes);
      const shaderSource = `
  const ivec2 strides = ivec2(${attributes.strides[0]}, ${attributes.strides[1]});
  const ivec2 pads = ivec2(${attributes.pads[0]}, ${attributes.pads[1]});
  ${activationFunction}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${outputChannelsPerGroup};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${wShape[1]}; wInChannel++) {
      int input_channel = group_id * ${wShape[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${wShape[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${attributes.dilations[0]};

        if (xHeight < 0 || xHeight >= ${xShape[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${wShape[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${attributes.dilations[1]};
          if (xWidth < 0 || xWidth >= ${xShape[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${processBias}
    ${applyActivation}
    ${glsl.output} = vec4(value, .0, .0, .0);
  }
`;
      return {
        ...metadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
        shaderSource,
        hasMain: true
      };
    };
    createUnpackedGroupedConvProgramInfoLoader = (inferenceHandler, inputs, attributes) => {
      const metadata = createUnpackedGroupedConvProgramMetadata(inputs.length > 2, attributes.cacheKey);
      return {
        ...metadata,
        get: () => createUnpackedGroupedConvProgramInfo(inferenceHandler, inputs, metadata, attributes)
      };
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/im2col-pack.ts
var createPackedIm2ColProgramMetadata, createPackedIm2ColProgramInfo, createPackedIm2ColProgramInfoLoader;
var init_im2col_pack = __esm({
  "web/lib/onnxjs/backends/webgl/ops/im2col-pack.ts"() {
    "use strict";
    init_glsl_source();
    init_types();
    init_packing_utils();
    createPackedIm2ColProgramMetadata = (cacheHint) => ({
      name: "Im2Col (packed)",
      inputNames: ["A"],
      inputTypes: [2 /* packed */],
      cacheHint
    });
    createPackedIm2ColProgramInfo = (inferenceHandler, metadata, x, w, outputShape, attributes) => {
      const xshape = x.dims;
      const wshape = w.dims;
      const rowDim = 2;
      const colDim = 3;
      const rank = outputShape.length;
      const im2colShape = [wshape[1] * wshape[2] * wshape[3], outputShape[2] * outputShape[3]];
      const kernelSize = wshape[2] * wshape[3];
      const unpackChannel = unpackFromChannel();
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      let unrolled = "";
      for (let row = 0; row <= 1; row++) {
        for (let col = 0; col <= 1; col++) {
          unrolled += `
            blockIndex = rc.x + ${col};
            pos = rc.y + ${row};

            if(blockIndex < ${im2colShape[1]} && pos < ${im2colShape[0]}) {
              offsetY = int(blockIndex / (${outputShape[rank - 1]})) * ${attributes.strides[0]} -
                ${attributes.pads[0]};
              d0 = offsetY + ${attributes.dilations[0]} * (imod(pos, ${kernelSize}) / ${wshape[2]});

              if(d0 < ${xshape[rowDim]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${outputShape[rank - 1]}) * ${attributes.strides[1]} -
                  ${attributes.pads[1]};
                d1 = offsetX + ${attributes.dilations[1]} * imod(imod(pos, ${kernelSize}), ${wshape[2]});

                if(d1 < ${xshape[colDim]} && d1 >= 0) {

                  ch = int(float(pos)/ ${kernelSize}.);
                    innerDims = vec2(d0, d1);
                    result[${row * 2 + col}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;
        }
      }
      const shaderSource = `
      ${unpackChannel}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${unrolled}
          ${glsl.output} = result;
      }
            `;
      return {
        ...metadata,
        output: { dims: im2colShape, type: x.type, textureType: 2 /* packed */ },
        shaderSource,
        hasMain: true
      };
    };
    createPackedIm2ColProgramInfoLoader = (inferenceHandler, x, w, outputShape, attributes) => {
      const metadata = createPackedIm2ColProgramMetadata(attributes.cacheKey);
      return {
        ...metadata,
        get: () => createPackedIm2ColProgramInfo(inferenceHandler, metadata, x, w, outputShape, attributes)
      };
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/matmul.ts
function createMatmulProgramInfo(metadata, inputs, activationAttributes) {
  const aShape = inputs[0].dims;
  const bShape = inputs[1].dims;
  const outputShape = BroadcastUtil.calcShape(aShape, bShape, true);
  if (!outputShape) {
    throw new Error("Can't use matmul on the given tensors");
  }
  const coordsDataType = getCoordsDataType(outputShape.length);
  const allGlChannels = getGlChannels();
  const { activationFunction, applyActivation } = getActivationSnippet(activationAttributes);
  const hasBias = inputs.length > 2;
  const processBias = hasBias ? "value += getBiasForMatmul();" : "";
  const getBiasForMatmulSnippet = hasBias ? `${getBiasForMatmul(coordsDataType, allGlChannels, inputs[2].dims, outputShape, false)}` : "";
  const rank = outputShape.length;
  const arank = aShape.length;
  const brank = bShape.length;
  const sharedDim = aShape[aShape.length - 1];
  const shaderSource = `
    ${activationFunction}
    ${getBiasForMatmulSnippet}
    float process(int indices[${rank}]) {
        int a[${arank}];
        int b[${brank}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${sharedDim}; ++k) {
            a[${arank - 1}] = k;
            b[${brank - 2}] = k;
            value += _A(a) * _B(b);
        }
        ${processBias}
        ${applyActivation}
        return value;
    }`;
  return {
    ...metadata,
    output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
    shaderSource
  };
}
function createMatmulProgramInfoLoader(inputs, activationAttributes) {
  const metadata = createMatmulProgramMetadata(inputs.length > 2, activationAttributes.activationCacheKey);
  return { ...metadata, get: () => createMatmulProgramInfo(metadata, inputs, activationAttributes) };
}
function getBiasForMatmul(coordsDataType, allGlChannels, inShape, outShape, isPacked) {
  let unpackedCoordsSnippet = "";
  const inRank = inShape.length;
  const outRank = outShape.length;
  const rankDiff = outRank - inRank;
  if (outRank < 2 && inRank > 0) {
    unpackedCoordsSnippet = "coords";
  } else {
    unpackedCoordsSnippet = inShape.map((_s, i) => `coords.${allGlChannels[i + rankDiff]}`).join(", ");
  }
  const broadcastDims = BroadcastUtil.getBroadcastDims(inShape, outShape);
  const coordsSnippet = broadcastDims.map((d) => `coords.${allGlChannels[d + rankDiff]} = 0;`).join("\n");
  const inSize = ShapeUtil.size(inShape);
  const isInputScalar = inSize === 1;
  let output = "vec4(outputValue.xx, outputValue.yy)";
  if (isInputScalar) {
    output = "vec4(outputValue.x)";
  }
  const getBiasForMatmulSource = isPacked ? `
vec4 getBiasForMatmul() {
  ${coordsDataType} coords = getOutputCoords();
  ${coordsSnippet}
  vec4 outputValue = getBias(${unpackedCoordsSnippet});
  return ${output};
}` : `
float getBiasForMatmul() {
  ${coordsDataType} coords = getOutputCoords();
  ${coordsSnippet}
  return getBias(coords.x);
}`;
  return getBiasForMatmulSource;
}
var matMul, parseMatMulAttributes, createMatmulProgramMetadata, validateInputs4;
var init_matmul = __esm({
  "web/lib/onnxjs/backends/webgl/ops/matmul.ts"() {
    "use strict";
    init_util();
    init_types();
    init_utils();
    init_fuse_utils();
    init_matmul_pack();
    matMul = (inferenceHandler, inputs, attributes) => {
      validateInputs4(inputs);
      if (inferenceHandler.session.pack) {
        return [inferenceHandler.run(
          createPackedMatmulProgramInfoLoader(inferenceHandler, inputs, attributes),
          inputs
        )];
      } else {
        return [inferenceHandler.run(createMatmulProgramInfoLoader(inputs, attributes), inputs)];
      }
    };
    parseMatMulAttributes = (node) => parseInternalActivationAttributes(node.attributes);
    createMatmulProgramMetadata = (hasBias, cacheHint) => ({
      name: "MatMul",
      inputNames: hasBias ? ["A", "B", "Bias"] : ["A", "B"],
      inputTypes: hasBias ? [0 /* unpacked */, 0 /* unpacked */, 0 /* unpacked */] : [0 /* unpacked */, 0 /* unpacked */],
      cacheHint
    });
    validateInputs4 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("MatMul requires 2 inputs.");
      }
      if (inputs[0].dims[inputs[0].dims.length - 1] !== inputs[1].dims[inputs[1].dims.length - 2]) {
        throw new Error("shared dimension does not match.");
      }
      if (inputs[0].type !== "float32" && inputs[0].type !== "float64" || inputs[1].type !== "float32" && inputs[1].type !== "float64") {
        throw new Error("inputs should be float type");
      }
      if (inputs[0].type !== inputs[1].type) {
        throw new Error("inputs types should match");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/matmul-pack.ts
function getBcastSamplerForMatmul(coordsDataType, allGlChannels, inputs, outShape) {
  let unpackedACoordsSnippet = [];
  let unpackedBCoordsSnippet = [];
  const inAShape = inputs[0].dims;
  const inBShape = inputs[1].dims;
  const inARank = inAShape.length;
  const inBRank = inBShape.length;
  const outRank = outShape.length;
  const rankADiff = outRank - inARank;
  const rankBDiff = outRank - inBRank;
  unpackedACoordsSnippet = inAShape.map((_s, i) => `coords.${allGlChannels[i + rankADiff]}`);
  unpackedACoordsSnippet[inARank - 1] = "i*2";
  unpackedACoordsSnippet.join(", ");
  unpackedBCoordsSnippet = inBShape.map((_s, i) => `coords.${allGlChannels[i + rankBDiff]}`);
  unpackedBCoordsSnippet[inBRank - 2] = "i*2";
  unpackedBCoordsSnippet.join(", ");
  const broadcastADims = BroadcastUtil.getBroadcastDims(inAShape, outShape);
  const broadcastBDims = BroadcastUtil.getBroadcastDims(inBShape, outShape);
  const coordsASnippet = broadcastADims.map((d) => `coords.${allGlChannels[d + rankADiff]} = 0;`).join("\n");
  const coordsBSnippet = broadcastBDims.map((d) => `coords.${allGlChannels[d + rankBDiff]} = 0;`).join("\n");
  const swapDimSnippet = `int lastDim = coords.${allGlChannels[outRank - 1]};
  coords.${allGlChannels[outRank - 1]} = coords.${allGlChannels[outRank - 2]};
  coords.${allGlChannels[outRank - 2]} = lastDim;`;
  const getBcastSamplerMatmulSource = `
vec4 getAAtOutCoordsMatmul(int i) {
  ${coordsDataType} coords = getOutputCoords();
  ${swapDimSnippet}
  ${coordsASnippet}
  vec4 outputValue = getA(${unpackedACoordsSnippet});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${coordsDataType} coords = getOutputCoords();
  ${swapDimSnippet}
  ${coordsBSnippet}
  vec4 outputValue = getB(${unpackedBCoordsSnippet});
  return outputValue;
}`;
  return getBcastSamplerMatmulSource;
}
function getA(allGlChannels, rank) {
  let res = "";
  for (let i = 0; i < rank - 2; i++) {
    res += `rc.${allGlChannels[i]}, `;
  }
  res += `rc.${allGlChannels[rank - 2]}, i*2`;
  return res;
}
function getB(allGlChannels, rank) {
  let res = "";
  for (let i = 0; i < rank - 2; i++) {
    res += `rc.${allGlChannels[i]}, `;
  }
  res += `i*2, rc.${allGlChannels[rank - 1]}`;
  return res;
}
var createPackedMatmulProgramMetadata, createPackedMatmulProgramInfo, createPackedMatmulProgramInfoLoader;
var init_matmul_pack = __esm({
  "web/lib/onnxjs/backends/webgl/ops/matmul-pack.ts"() {
    "use strict";
    init_util();
    init_glsl_source();
    init_types();
    init_utils();
    init_fuse_utils();
    init_matmul();
    createPackedMatmulProgramMetadata = (hasBias, cacheHint) => ({
      name: "MatMul (packed)",
      inputNames: hasBias ? ["A", "B", "Bias"] : ["A", "B"],
      inputTypes: hasBias ? [2 /* packed */, 2 /* packed */, 2 /* packed */] : [2 /* packed */, 2 /* packed */],
      cacheHint
    });
    createPackedMatmulProgramInfo = (inferenceHandler, metadata, inputs, activationAttributes) => {
      const hasBias = inputs.length > 2;
      const processBias = hasBias ? "value += getBiasForMatmul();" : "";
      const aShape = inputs[0].dims;
      const bShape = inputs[1].dims;
      const outputShape = BroadcastUtil.calcShape(aShape, bShape, true);
      const isBroadcast = !ShapeUtil.areEqual(inputs[0].dims, inputs[1].dims);
      if (!outputShape) {
        throw new Error("Can't use matmul on the given tensors");
      }
      const sharedDim = aShape[aShape.length - 1];
      const sharedDimIndex = Math.ceil(sharedDim / 2);
      const aRank = aShape.length;
      const bRank = bShape.length;
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      const coordsDataType = getCoordsDataType(outputShape.length);
      const outRank = outputShape.length;
      const allGlChannels = getGlChannels();
      const { activationFunction, applyActivation } = getActivationSnippet(activationAttributes);
      const getBiasForMatmulSnippet = hasBias ? `${getBiasForMatmul(coordsDataType, allGlChannels, inputs[2].dims, outputShape, true)}` : "";
      const getBcastedSamplerForMatmulSnippet = isBroadcast ? `${getBcastSamplerForMatmul(coordsDataType, allGlChannels, inputs, outputShape)}` : "";
      const getSamplerAInLoopSnippet = isBroadcast ? "getAAtOutCoordsMatmul(i)" : `getA(${getA(allGlChannels, aRank)})`;
      const getSamplerBInLoopSnippet = isBroadcast ? "getBAtOutCoordsMatmul(i)" : `getB(${getB(allGlChannels, bRank)})`;
      const getOutputCoordsSnippet = isBroadcast ? "" : `${coordsDataType} rc =
          getOutputCoords(); int lastDim = rc.${allGlChannels[outRank - 1]}; rc.${allGlChannels[outRank - 1]} =
          rc.${allGlChannels[outRank - 2]}; rc.${allGlChannels[outRank - 2]} = lastDim;
      `;
      const shaderSource = `
            ${getBcastedSamplerForMatmulSnippet}
            ${getBiasForMatmulSnippet}
            ${activationFunction}
            void main() {
              ${getOutputCoordsSnippet}

              vec4 value = vec4(0);
              for (int i = 0; i < ${sharedDimIndex}; i++) {
                vec4 a = ${getSamplerAInLoopSnippet};
                vec4 b = ${getSamplerBInLoopSnippet};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${processBias}
              ${applyActivation}
              ${glsl.output} = value;
            }`;
      return {
        ...metadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 2 /* packed */ },
        shaderSource,
        hasMain: true
      };
    };
    createPackedMatmulProgramInfoLoader = (inferenceHandler, inputs, activationAttributes) => {
      const metadata = createPackedMatmulProgramMetadata(inputs.length > 2, activationAttributes.activationCacheKey);
      return {
        ...metadata,
        get: () => createPackedMatmulProgramInfo(inferenceHandler, metadata, inputs, activationAttributes)
      };
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/conv-pack.ts
var conv2DPacked;
var init_conv_pack = __esm({
  "web/lib/onnxjs/backends/webgl/ops/conv-pack.ts"() {
    "use strict";
    init_conv();
    init_im2col_pack();
    init_matmul_pack();
    conv2DPacked = (inferenceHandler, inputs, attributes) => {
      const xshape = inputs[0].dims;
      const kshape = inputs[1].dims;
      const outputShape = calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);
      const im2colOutput = inferenceHandler.run(
        createPackedIm2ColProgramInfoLoader(inferenceHandler, inputs[0], inputs[1], outputShape, attributes),
        [inputs[0]]
      );
      const kernelReshaped = inferenceHandler.reshapePacked(inputs[1], [kshape[0], kshape[1] * kshape[2] * kshape[3]]);
      const matmulInputs = inputs.length === 3 ? [kernelReshaped, im2colOutput, inputs[2]] : [kernelReshaped, im2colOutput];
      const matmulOutput = inferenceHandler.run(
        createPackedMatmulProgramInfoLoader(inferenceHandler, matmulInputs, attributes),
        matmulInputs
      );
      const outputReshaped = inferenceHandler.reshapePacked(matmulOutput, outputShape);
      return outputReshaped;
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/im2col.ts
var createIm2ColProgramMetadata, createIm2ColProgramInfo, createIm2ColProgramInfoLoader, calculateIm2ColDims;
var init_im2col = __esm({
  "web/lib/onnxjs/backends/webgl/ops/im2col.ts"() {
    "use strict";
    init_types();
    createIm2ColProgramMetadata = (cacheHint) => ({
      name: "Im2Col",
      inputNames: ["X"],
      inputTypes: [0 /* unpacked */],
      cacheHint
    });
    createIm2ColProgramInfo = (_inferenceHandler, metadata, x, w, outputShape, attributes) => {
      const xshape = x.dims;
      const wshape = w.dims;
      const rank = outputShape.length;
      const im2colDims = calculateIm2ColDims(xshape, wshape, outputShape, 4);
      const shaderSource = `
        const int XC = ${xshape[1]};
        const int XH = ${xshape[2]};
        const int XW = ${xshape[3]};
        const int KH = ${attributes.kernelShape[0]};
        const int KW = ${attributes.kernelShape[1]};
        const int dilationH = ${attributes.dilations[0]};
        const int dilationW = ${attributes.dilations[1]};
        const int strideH = ${attributes.strides[0]};
        const int strideW = ${attributes.strides[1]};
        const int padH = ${attributes.pads[0]};
        const int padW = ${attributes.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${rank}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${xshape.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;
      return {
        ...metadata,
        output: { dims: im2colDims, type: x.type, textureType: 4 /* packedLastDimension */ },
        shaderSource
      };
    };
    createIm2ColProgramInfoLoader = (inferenceHandler, x, w, outputShape, attributes) => {
      const metadata = createIm2ColProgramMetadata(attributes.cacheKey);
      return {
        ...metadata,
        get: () => createIm2ColProgramInfo(inferenceHandler, metadata, x, w, outputShape, attributes)
      };
    };
    calculateIm2ColDims = (inputShape, kernelShape, outputShape, channels = 4) => [
      outputShape[0],
      outputShape[2],
      outputShape[3],
      Math.ceil(inputShape[1] * kernelShape[2] * kernelShape[3] / channels)
    ];
  }
});

// web/lib/onnxjs/backends/webgl/ops/dot-product.ts
var createDotProductProgramMetadata, createDotProductProgramInfo, createDotProductProgramInfoLoader;
var init_dot_product = __esm({
  "web/lib/onnxjs/backends/webgl/ops/dot-product.ts"() {
    "use strict";
    init_util();
    init_glsl_source();
    init_types();
    init_fuse_utils();
    init_im2col();
    createDotProductProgramMetadata = (hasBias, attributes) => ({
      name: "ConvDotProduct",
      inputNames: hasBias ? ["Im2Col", "K", "B"] : ["Im2Col", "K"],
      inputTypes: hasBias ? [0 /* unpacked */, 4 /* packedLastDimension */, 0 /* unpacked */] : [0 /* unpacked */, 4 /* packedLastDimension */],
      cacheKey: attributes.activationCacheKey
    });
    createDotProductProgramInfo = (inferenceHandler, metadata, inputs, outputShape, attributes) => {
      const xshape = inputs[0].dims;
      const kshape = inputs[1].dims;
      const adjustedKernelShape = [kshape[0], Math.ceil(xshape[1] * kshape[2] * kshape[3] / 4)];
      const im2colShape = calculateIm2ColDims(xshape, kshape, outputShape);
      const [kWidth, kHeight] = inferenceHandler.calculateTextureWidthAndHeight(adjustedKernelShape, 4 /* packedLastDimension */);
      const im2colStrides = ShapeUtil.computeStrides(im2colShape);
      const [im2colWidth, im2colHeight] = inferenceHandler.calculateTextureWidthAndHeight(im2colShape, 4 /* packedLastDimension */);
      const rank = outputShape.length;
      const initValue = inputs.length < 3 ? "0.0" : "_B(b)";
      const sharedDim = Math.ceil(xshape[1] * kshape[2] * kshape[3] / 4);
      const { activationFunction, applyActivation } = getActivationSnippet(attributes);
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      const shaderSource = `
${activationFunction}
float process(int indices[${rank}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${im2colStrides[0]} + im2col[1] * ${im2colStrides[1]} + im2col[2] * ${im2colStrides[2]};
  int kernelOffset = indices[1] * ${adjustedKernelShape[1]};
  float value = ${initValue};
  for (int i = 0; i < ${sharedDim}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${im2colWidth}, ${im2colHeight});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${kWidth}, ${kHeight});
    value += dot(${glsl.texture2D}(Im2Col, im2colCoords), ${glsl.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${applyActivation}
  return value;
}`;
      return {
        ...metadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    createDotProductProgramInfoLoader = (inferenceHandler, inputs, outputShape, attributes) => {
      const metadata = createDotProductProgramMetadata(inputs.length > 2, attributes);
      return {
        ...metadata,
        get: () => createDotProductProgramInfo(inferenceHandler, metadata, inputs, outputShape, attributes)
      };
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/conv.ts
var calculateOutputShape, conv, conv2d, conv2DUnpackedPointwise, conv2DUnpacked, getAdjustedConvAttributes, parseConvAttributes, validateInputs5;
var init_conv = __esm({
  "web/lib/onnxjs/backends/webgl/ops/conv.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_util();
    init_conv_grouped();
    init_conv_pack();
    init_dot_product();
    init_fuse_utils();
    init_im2col();
    init_matmul();
    calculateOutputShape = (inputShape, kernelShape, dilations, adjustPads, strides) => {
      const batchSize = inputShape[0];
      const inputSpatialShape = inputShape.slice(2);
      const spatialRank = inputSpatialShape.length;
      const outChannels = kernelShape[0];
      const kernelSpatialShape = kernelShape.slice(2);
      const dilatedKernelShape = kernelSpatialShape.map((v, i) => v + (v - 1) * (dilations[i] - 1));
      const inputSpatialShapeWithPad = inputSpatialShape.map((v, i) => v + adjustPads[i] + adjustPads[i + spatialRank]);
      const outputSpatialShape = inputSpatialShapeWithPad.map((v, i) => Math.floor((v - dilatedKernelShape[i] + strides[i]) / strides[i]));
      const outputShape = [batchSize, outChannels].concat(...outputSpatialShape);
      return outputShape;
    };
    conv = (inferenceHandler, inputs, attributes) => {
      validateInputs5(inputs, attributes);
      return conv2d(inferenceHandler, inputs, attributes);
    };
    conv2d = (inferenceHandler, inputs, attributes) => {
      const adjustedAttributes = getAdjustedConvAttributes(attributes, inputs);
      const packMode = inferenceHandler.session.pack;
      const isPointwise = adjustedAttributes.kernelShape[0] === 1 && adjustedAttributes.kernelShape[1] === 1;
      if (adjustedAttributes.group > 1) {
        const result = inferenceHandler.run(
          createUnpackedGroupedConvProgramInfoLoader(inferenceHandler, inputs, adjustedAttributes),
          inputs
        );
        return [result];
      } else if (isPointwise && packMode) {
        return [conv2DUnpackedPointwise(inferenceHandler, inputs, adjustedAttributes)];
      } else if (packMode && inputs[0].dims.length === 4 && inputs[0].dims[0] === 1 && !isPointwise) {
        return [conv2DPacked(inferenceHandler, inputs, adjustedAttributes)];
      } else {
        return [conv2DUnpacked(inferenceHandler, inputs, adjustedAttributes)];
      }
    };
    conv2DUnpackedPointwise = (inferenceHandler, inputs, attributes) => {
      const xshape = inputs[0].dims;
      const kshape = inputs[1].dims;
      const outputShape = calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);
      const reshapedX = inferenceHandler.reshapeUnpacked(inputs[0], [xshape[1], xshape[2] * xshape[3]]);
      const reshapedK = inferenceHandler.reshapeUnpacked(inputs[1], [kshape[0], kshape[1]]);
      const matmulInputs = inputs.length > 2 ? [reshapedK, reshapedX, inputs[2]] : [reshapedK, reshapedX];
      const matmulOutput = inferenceHandler.run(createMatmulProgramInfoLoader(matmulInputs, attributes), matmulInputs);
      return inferenceHandler.reshapeUnpacked(matmulOutput, outputShape);
    };
    conv2DUnpacked = (inferenceHandler, inputs, attributes) => {
      const xshape = inputs[0].dims;
      const kshape = inputs[1].dims;
      const outputShape = calculateOutputShape(xshape, kshape, attributes.dilations, attributes.pads, attributes.strides);
      const xIm2Col = inferenceHandler.run(
        createIm2ColProgramInfoLoader(inferenceHandler, inputs[0], inputs[1], outputShape, attributes),
        [inputs[0]]
      );
      const dotProductInputs = inputs.length === 3 ? [xIm2Col, inputs[1], inputs[2]] : [xIm2Col, inputs[1]];
      const output = inferenceHandler.run(
        createDotProductProgramInfoLoader(inferenceHandler, inputs, outputShape, attributes),
        dotProductInputs
      );
      return output;
    };
    getAdjustedConvAttributes = (attributes, inputs) => {
      const kernelShape = attributes.kernelShape.slice();
      if (attributes.kernelShape.length === 0) {
        for (let i = 2; i < inputs[1].dims.length; ++i) {
          kernelShape.push(inputs[1].dims[i]);
        }
      }
      const pads = attributes.pads.slice();
      PoolConvUtil.adjustPadsBasedOnAutoPad(
        inputs[0].dims,
        attributes.strides,
        attributes.dilations,
        kernelShape,
        pads,
        attributes.autoPad
      );
      const newAttributes = Object.assign({}, attributes);
      Object.assign(newAttributes, { kernelShape, pads, cacheKey: attributes.cacheKey });
      return newAttributes;
    };
    parseConvAttributes = (node) => {
      const attributes = node.attributes;
      const activationAttributes = parseInternalActivationAttributes(attributes);
      const autoPad = attributes.getString("auto_pad", "NOTSET");
      const dilations = attributes.getInts("dilations", [1, 1]);
      const group = attributes.getInt("group", 1);
      const kernelShape = attributes.getInts("kernel_shape", []);
      const pads = attributes.getInts("pads", [0, 0, 0, 0]);
      const strides = attributes.getInts("strides", [1, 1]);
      return createAttributeWithCacheKey({ autoPad, dilations, group, kernelShape, pads, strides, ...activationAttributes });
    };
    validateInputs5 = (inputs, attributes) => {
      if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
        throw new Error("Conv requires 2 or 3 inputs");
      }
      if (inputs[0].dims.length !== 4 || inputs[1].dims.length !== 4) {
        throw new Error("currently only support 2-dimensional conv");
      }
      const dataChannel = inputs[0].dims[1];
      const filterInChannel = inputs[1].dims[1] * attributes.group;
      if (dataChannel !== filterInChannel) {
        throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
      }
      if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[1].dims[0] !== inputs[2].dims[0])) {
        throw new Error("invalid bias");
      }
      const spatialRank = inputs[0].dims.length - 2;
      if (attributes.dilations.length !== spatialRank) {
        throw new Error(`dilations should be ${spatialRank}D`);
      }
      if (attributes.strides.length !== spatialRank) {
        throw new Error(`strides should be ${spatialRank}D`);
      }
      if (attributes.pads.length !== spatialRank * 2) {
        throw new Error(`pads should be ${spatialRank * 2}D`);
      }
      if (attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {
        throw new Error("invalid kernel shape");
      }
      if (inputs[0].type !== "float32" || inputs[1].type !== "float32") {
        throw new Error("Conv input(X,W) should be float tensor");
      }
      if (inputs.length === 3 && inputs[2].type !== "float32") {
        throw new Error("Conv input(bias) should be float tensor");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/conv-transpose.ts
var computeTotalPad, distributePadding, calculateOutputShapeAndPads, convTranspose, convTranspose2d, createConvTransposeProgramMetadata, createUnpackedConvTransposeProgramInfo, createUnpackedConvTransposeProgramInfoLoader, convTranspose2DUnpacked, getAdjustedConvTransposeAttributes, parseConvTransposeAttributes, validateInputs6;
var init_conv_transpose = __esm({
  "web/lib/onnxjs/backends/webgl/ops/conv-transpose.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_glsl_source();
    init_types();
    init_fuse_utils();
    computeTotalPad = (inDim, stride, adj, kernel, dilation, outSize) => (inDim - 1) * stride + adj + (kernel - 1) * dilation + 1 - outSize;
    distributePadding = (totalPad, autoPad, pads, head, tail) => {
      const smallPad = Math.floor(totalPad / 2);
      if (autoPad === "SAME_UPPER") {
        pads[head] = smallPad;
        pads[tail] = totalPad - smallPad;
      } else if (autoPad === "SAME_LOWER") {
        pads[head] = totalPad - smallPad;
        pads[tail] = smallPad;
      }
    };
    calculateOutputShapeAndPads = (inputShape, kernelShape, dilations, autoPad, pads, strides, outputPadding, outputShape) => {
      const spatialRank = inputShape.length - 2;
      const updateShape = outputShape.length === 0;
      for (let i = 0; i < spatialRank; ++i) {
        const outSize = updateShape ? inputShape[i + 2] * strides[i] : outputShape[i];
        const totalPad = computeTotalPad(inputShape[i + 2], strides[i], pads[i], kernelShape[i], dilations[i], outSize);
        distributePadding(totalPad, autoPad, pads, i, i + spatialRank);
        if (updateShape) {
          outputShape.push(
            strides[i] * (inputShape[i + 2] - 1) + outputPadding[i] + (kernelShape[i] - 1) * dilations[i] + 1 - pads[i] - pads[i + spatialRank]
          );
        }
      }
    };
    convTranspose = (inferenceHandler, inputs, attributes) => {
      validateInputs6(inputs, attributes);
      return convTranspose2d(inferenceHandler, inputs, attributes);
    };
    convTranspose2d = (inferenceHandler, inputs, attributes) => {
      const adjustedAttributes = getAdjustedConvTransposeAttributes(attributes, inputs);
      return [convTranspose2DUnpacked(inferenceHandler, inputs, adjustedAttributes)];
    };
    createConvTransposeProgramMetadata = (hasBias, cacheHint) => ({
      name: "ConvTranspose",
      inputNames: hasBias ? ["X", "W", "B"] : ["X", "W"],
      inputTypes: hasBias ? [0 /* unpacked */, 0 /* unpacked */, 0 /* unpacked */] : [0 /* unpacked */, 0 /* unpacked */],
      cacheHint
    });
    createUnpackedConvTransposeProgramInfo = (inferenceHandler, inputs, metadata, attributes) => {
      const hasBias = inputs.length > 2;
      const valueInit = hasBias ? "getB(output_channel)" : "0.0";
      const xShape = inputs[0].dims;
      const wShape = inputs[1].dims;
      const outputChannelsPerGroup = wShape[1];
      const inputChannelsPerGroup = wShape[0] / attributes.group;
      const outputShape = [inputs[0].dims[0], inputs[1].dims[1] * attributes.group, ...attributes.outputShape];
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      const { activationFunction, applyActivation } = getActivationSnippet(attributes);
      const shaderSource = `
  const ivec2 strides = ivec2(${attributes.strides[0]}, ${attributes.strides[1]});
  const ivec2 pads = ivec2(${attributes.pads[0]}, ${attributes.pads[1]});
  ${activationFunction}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${outputChannelsPerGroup};
    int wOutChannel = output_channel - group_id * ${outputChannelsPerGroup};

    float value = ${valueInit};
    for (int inChannelOffset = 0; inChannelOffset < ${inputChannelsPerGroup}; inChannelOffset++) {
      int input_channel = group_id * ${inputChannelsPerGroup} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${wShape[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${wShape[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${attributes.dilations[0]}, wHOff * ${attributes.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${xShape[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${xShape[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${applyActivation}
    ${glsl.output} = vec4(value, .0, .0, .0);
  }
`;
      return {
        ...metadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
        shaderSource,
        hasMain: true
      };
    };
    createUnpackedConvTransposeProgramInfoLoader = (inferenceHandler, inputs, attributes) => {
      const metadata = createConvTransposeProgramMetadata(inputs.length > 2, attributes.cacheKey);
      return {
        ...metadata,
        get: () => createUnpackedConvTransposeProgramInfo(inferenceHandler, inputs, metadata, attributes)
      };
    };
    convTranspose2DUnpacked = (inferenceHandler, inputs, attributes) => {
      const result = inferenceHandler.run(
        createUnpackedConvTransposeProgramInfoLoader(inferenceHandler, inputs, attributes),
        inputs
      );
      return result;
    };
    getAdjustedConvTransposeAttributes = (attributes, inputs) => {
      const kernelShape = attributes.kernelShape.slice();
      if (attributes.kernelShape.length === 0) {
        for (let i = 2; i < inputs[1].dims.length; ++i) {
          kernelShape.push(inputs[1].dims[i]);
        }
      }
      const pads = attributes.pads.slice();
      const outputShape = attributes.outputShape.slice();
      const inputShape = inputs[0].dims;
      calculateOutputShapeAndPads(
        inputShape,
        kernelShape,
        attributes.dilations,
        attributes.autoPad,
        pads,
        attributes.strides,
        attributes.outputPadding,
        outputShape
      );
      const newAttributes = Object.assign({}, attributes);
      Object.assign(newAttributes, { kernelShape, pads, outputShape, cacheKey: attributes.cacheKey });
      return newAttributes;
    };
    parseConvTransposeAttributes = (node) => {
      const attributes = node.attributes;
      const activationAttributes = parseInternalActivationAttributes(attributes);
      const autoPad = attributes.getString("auto_pad", "NOTSET");
      const dilations = attributes.getInts("dilations", [1, 1]);
      const group = attributes.getInt("group", 1);
      const kernelShape = attributes.getInts("kernel_shape", []);
      const outputPadding = attributes.getInts("output_padding", [0, 0]);
      const outputShape = attributes.getInts("output_shape", []);
      const pads = attributes.getInts("pads", [0, 0, 0, 0]);
      const strides = attributes.getInts("strides", [1, 1]);
      return createAttributeWithCacheKey(
        { autoPad, dilations, group, kernelShape, outputPadding, outputShape, pads, strides, ...activationAttributes }
      );
    };
    validateInputs6 = (inputs, attributes) => {
      if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
        throw new Error("Conv requires 2 or 3 inputs");
      }
      if (inputs[0].dims.length !== 4 || inputs[1].dims.length !== 4) {
        throw new Error("currently only support 2-dimensional conv");
      }
      const dataChannel = inputs[0].dims[1];
      const filterInChannel = inputs[1].dims[0];
      if (dataChannel !== filterInChannel) {
        throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
      }
      const featureMaps = inputs[1].dims[1] * attributes.group;
      if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[2].dims[0] !== featureMaps)) {
        throw new Error("invalid bias");
      }
      const spatialRank = inputs[0].dims.length - 2;
      if (attributes.dilations.length !== spatialRank) {
        throw new Error(`dilations should be ${spatialRank}D`);
      }
      if (attributes.strides.length !== spatialRank) {
        throw new Error(`strides should be ${spatialRank}D`);
      }
      if (attributes.pads.length !== spatialRank * 2) {
        throw new Error(`pads should be ${spatialRank * 2}D`);
      }
      if (attributes.outputPadding.length !== spatialRank) {
        throw new Error(`output_padding should be ${spatialRank}D`);
      }
      if (attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {
        throw new Error("invalid kernel shape");
      }
      if (attributes.outputShape.length !== 0 && attributes.outputShape.length !== inputs[0].dims.length - 2) {
        throw new Error("invalid output shape");
      }
      if (inputs[0].type !== "float32" || inputs[1].type !== "float32") {
        throw new Error("ConvTranspose input(X,W) should be float tensor");
      }
      if (inputs.length === 3 && inputs[2].type !== "float32") {
        throw new Error("ConvTranspose input(bias) should be float tensor");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/transpose.ts
var transposeProgramMetadata, transpose, parseTransposeAttributes, createTransposeProgramInfo, getAdjustedPerm, getOutputShape, getPermFunctionBody, validateInputs7;
var init_transpose = __esm({
  "web/lib/onnxjs/backends/webgl/ops/transpose.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_util();
    init_types();
    transposeProgramMetadata = {
      name: "Transpose",
      inputNames: ["A"],
      inputTypes: [0 /* unpacked */]
    };
    transpose = (inferenceHandler, inputs, attributes) => {
      validateInputs7(inputs);
      const output = inferenceHandler.run(
        {
          ...transposeProgramMetadata,
          cacheHint: attributes.cacheKey,
          get: () => createTransposeProgramInfo(inferenceHandler, inputs[0], attributes.perm)
        },
        inputs
      );
      return [output];
    };
    parseTransposeAttributes = (node) => createAttributeWithCacheKey({ perm: node.attributes.getInts("perm", []) });
    createTransposeProgramInfo = (_inferenceHandler, input, perm) => {
      const inputShape = input.dims;
      perm = getAdjustedPerm(inputShape, perm);
      const unpackedOutputShape = getOutputShape(inputShape, perm);
      const rank = inputShape.length;
      const shaderSource = `
      ${getPermFunctionBody("perm", perm, rank)}
      float process(int indices[${rank}]) {
        int a[${rank}];
        perm(a, indices);
        return _A(a);
      }`;
      return {
        ...transposeProgramMetadata,
        output: { dims: unpackedOutputShape, type: input.type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    getAdjustedPerm = (inputShape, perm) => {
      if (perm && perm.length !== inputShape.length) {
        perm = [...inputShape.keys()].reverse();
      }
      return perm;
    };
    getOutputShape = (inputShape, perm) => {
      perm = getAdjustedPerm(inputShape, perm);
      return ShapeUtil.sortBasedOnPerm(inputShape, perm);
    };
    getPermFunctionBody = (name2, perm, rank) => {
      const reverseFunc = [];
      reverseFunc.push(`void ${name2}(out int a[${rank}], int src[${rank}]) {`);
      for (let i = 0; i < rank; ++i) {
        reverseFunc.push(`	a[${perm[i]}]=src[${i}];`);
      }
      reverseFunc.push("	}");
      return reverseFunc.join("\n");
    };
    validateInputs7 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Transpose requires 1 input.");
      }
      if (inputs[0].type !== "float32" && inputs[0].type !== "float64") {
        throw new Error("input should be float tensor");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/depth-to-space.ts
var depthToSpace, parseDepthToSpaceAttributes, validateInputs8;
var init_depth_to_space = __esm({
  "web/lib/onnxjs/backends/webgl/ops/depth-to-space.ts"() {
    "use strict";
    init_transpose();
    depthToSpace = (inferenceHandler, inputs, attributes) => {
      validateInputs8(inputs);
      const blocksize = attributes.blocksize;
      const blocksizeSqr = blocksize * blocksize;
      const transposePerm = attributes.mode === "DCR" ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3];
      const firstReshapeShape = attributes.mode === "DCR" ? [
        inputs[0].dims[0],
        blocksize,
        blocksize,
        inputs[0].dims[1] / blocksizeSqr,
        inputs[0].dims[2],
        inputs[0].dims[3]
      ] : [
        inputs[0].dims[0],
        inputs[0].dims[1] / blocksizeSqr,
        blocksize,
        blocksize,
        inputs[0].dims[2],
        inputs[0].dims[3]
      ];
      const firstReshapedTensor = inferenceHandler.reshapeUnpacked(inputs[0], firstReshapeShape);
      const transposeAttributes = { perm: transposePerm, cacheKey: `${transposePerm}` };
      const [transposeOutput] = transpose(inferenceHandler, [firstReshapedTensor], transposeAttributes);
      const secondReshapeShape = [
        inputs[0].dims[0],
        inputs[0].dims[1] / blocksizeSqr,
        inputs[0].dims[2] * blocksize,
        inputs[0].dims[3] * blocksize
      ];
      const result = inferenceHandler.reshapeUnpacked(transposeOutput, secondReshapeShape);
      return [result];
    };
    parseDepthToSpaceAttributes = (node) => {
      const blocksize = node.attributes.getInt("blocksize");
      if (blocksize < 1) {
        throw new Error(`blocksize must be >= 1, but got : ${blocksize} for DepthToSpace`);
      }
      const mode = node.attributes.getString("mode", "DCR");
      if (mode !== "DCR" && mode !== "CRD") {
        throw new Error(`unrecognized mode: ${mode} for DepthToSpace`);
      }
      return { mode, blocksize };
    };
    validateInputs8 = (inputs) => {
      if (inputs.length !== 1) {
        throw new Error(`DepthToSpace expect 1 inputs, but got ${inputs.length}`);
      }
      if (inputs[0].type === "string" || inputs[0].dims.length !== 4) {
        throw new TypeError("DepthToSpace input should be a 4-D numeric tensor");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/flatten.ts
var flatten, parseFlattenAttributes, validateInputs9;
var init_flatten = __esm({
  "web/lib/onnxjs/backends/webgl/ops/flatten.ts"() {
    "use strict";
    init_util();
    flatten = (inferenceHandler, inputs, axis) => {
      validateInputs9(inputs, axis);
      const outputDims = ShapeUtil.flattenShape(inputs[0].dims, axis);
      return [inferenceHandler.reshapeUnpacked(inputs[0], outputDims)];
    };
    parseFlattenAttributes = (node) => node.attributes.getInt("axis", 1);
    validateInputs9 = (inputs, axis) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Flatten requires 1 input.");
      }
      const r = inputs[0].dims.length;
      if (r === 0) {
        throw new Error("scalar tensor is not supported.");
      }
      if (axis < -r || axis > r) {
        throw new Error("Invalid axis");
      }
      if (inputs[0].type === "string") {
        throw new Error("string tensor is not supported.");
      }
    };
  }
});

// web/lib/onnxjs/operators.ts
var NUMBER_TYPES;
var init_operators = __esm({
  "web/lib/onnxjs/operators.ts"() {
    "use strict";
    NUMBER_TYPES = ["float32", "float64", "int32", "int16", "int8", "uint16", "uint32", "uint8"];
  }
});

// web/lib/onnxjs/backends/webgl/ops/gather.ts
var gather, parseGatherAttributes, gatherProgramMetadata, createGatherProgramInfo, createGatherProgramInfoLoader, validateInputs10;
var init_gather = __esm({
  "web/lib/onnxjs/backends/webgl/ops/gather.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_operators();
    init_util();
    init_types();
    gather = (inferenceHandler, inputs, attributes) => {
      validateInputs10(inputs, attributes.axis);
      const output = inferenceHandler.run(createGatherProgramInfoLoader(inferenceHandler, inputs, attributes), inputs);
      return [output];
    };
    parseGatherAttributes = (node) => createAttributeWithCacheKey({ axis: node.attributes.getInt("axis", 0) });
    gatherProgramMetadata = {
      name: "Gather",
      inputNames: ["A", "B"],
      inputTypes: [0 /* unpacked */, 0 /* unpacked */]
    };
    createGatherProgramInfo = (_handler, metadata, inputs, axis) => {
      const inputShape = inputs[0].dims.slice();
      const indexDataShape = inputs[1].dims.slice();
      const outputShape = new Array(inputShape.length + indexDataShape.length - 1);
      axis = ShapeUtil.normalizeAxis(axis, inputShape.length);
      const indexCopyOps = [];
      for (let i = 0; i < outputShape.length; i++) {
        if (i < axis) {
          outputShape[i] = inputShape[i];
          indexCopyOps.push(`inputIdx[${i}] = outputIdx[${i}];`);
        } else {
          if (i < axis + indexDataShape.length) {
            outputShape[i] = indexDataShape[i - axis];
            indexCopyOps.push(`indexDataIdx[${i - axis}] = outputIdx[${i}];`);
          } else {
            outputShape[i] = inputShape[i - indexDataShape.length + 1];
            indexCopyOps.push(`inputIdx[${i - indexDataShape.length + 1}] = outputIdx[${i}];`);
          }
        }
      }
      const orank = outputShape.length || 1;
      const irank = inputShape.length;
      const iDrank = indexDataShape.length || 1;
      const shaderSource = `
      float process(int outputIdx[${orank}]) {
        int inputIdx[${irank}];
        int indexDataIdx[${iDrank}];
        indexDataIdx[0] = 0;
        ${indexCopyOps.join("\n        ")}
        int idx = int(_B(indexDataIdx));
        inputIdx[${axis}] = idx < 0 ? idx + ${inputShape[axis]} : idx;
        return _A(inputIdx);
      }`;
      return {
        ...metadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    createGatherProgramInfoLoader = (handler, inputs, attributes) => {
      const metadata = { ...gatherProgramMetadata, cacheHint: attributes.cacheKey };
      return { ...metadata, get: () => createGatherProgramInfo(handler, metadata, inputs, attributes.axis) };
    };
    validateInputs10 = (inputs, axis) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("Gather requires 2 inputs.");
      }
      const tensorRank = inputs[0].dims.length;
      if (tensorRank < 1) {
        throw new Error("Invalid input shape.");
      }
      if (axis < -tensorRank || axis > tensorRank - 1) {
        throw new Error("Invalid axis.");
      }
      if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {
        throw new Error("Invaid input type.");
      }
      if (inputs[1].type !== "int32" && inputs[1].type !== "int16") {
        throw new Error("Invaid input type.");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/gemm.ts
var gemm, parseGemmAttributes, parseGemmAttributesV7, parseGemmAttributesV11, createGemmProgramInfoLoader, createGemmProgramInfo, validateInputs11;
var init_gemm = __esm({
  "web/lib/onnxjs/backends/webgl/ops/gemm.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_util();
    init_types();
    gemm = (inferenceHandler, inputs, attributes) => {
      validateInputs11(inputs, attributes);
      const output = inferenceHandler.run(createGemmProgramInfoLoader(inputs, attributes), inputs);
      return [output];
    };
    parseGemmAttributes = (node, isOptionalC) => {
      const transA = node.attributes.getInt("transA", 0) !== 0;
      const transB = node.attributes.getInt("transB", 0) !== 0;
      const alpha = node.attributes.getFloat("alpha", 1);
      const beta = node.attributes.getFloat("beta", 1);
      return createAttributeWithCacheKey({ transA, transB, alpha, beta, isOptionalC });
    };
    parseGemmAttributesV7 = (node) => parseGemmAttributes(node, false);
    parseGemmAttributesV11 = (node) => parseGemmAttributes(node, true);
    createGemmProgramInfoLoader = (inputs, attributes) => {
      const metadata = {
        name: "Gemm",
        inputNames: inputs.length === 3 ? ["A", "B", "C"] : ["A", "B"],
        inputTypes: inputs.length === 3 ? [0 /* unpacked */, 0 /* unpacked */, 0 /* unpacked */] : [0 /* unpacked */, 0 /* unpacked */],
        key: attributes.cacheKey
      };
      return { ...metadata, get: () => createGemmProgramInfo(metadata, inputs, attributes) };
    };
    createGemmProgramInfo = (metadata, inputs, attributes) => {
      const aShape = inputs[0].dims.slice();
      const bShape = inputs[1].dims.slice();
      const [M, N] = GemmUtil.getShapeOfGemmResult(
        aShape,
        attributes.transA,
        bShape,
        attributes.transB,
        inputs.length === 3 ? inputs[2].dims : void 0
      );
      const outputShape = [M, N];
      if (!outputShape) {
        throw new Error("Can't use gemm on the given tensors");
      }
      let sharedDim = aShape[aShape.length - 1];
      let line = "";
      if (attributes.transA) {
        sharedDim = aShape[0];
      }
      if (attributes.transA && attributes.transB) {
        line = "value += _A_T(a) * _B_T(b);";
      } else if (attributes.transA && !attributes.transB) {
        line = "value += _A_T(a) * _B(b);";
      } else if (!attributes.transA && attributes.transB) {
        line = "value += _A(a) * _B_T(b);";
      } else if (!attributes.transA && !attributes.transB) {
        line = "value += _A(a) * _B(b);";
      }
      const rank = outputShape.length;
      const declareC = inputs.length === 3 ? `int c[${inputs[2].dims.length}];` : "";
      const broadcastC = inputs.length === 3 ? "bcastIndices_C(indices, c);" : "";
      const calculateC = inputs.length === 3 ? "value += beta * _C(c);" : "";
      const shaderSource = `
      float process(int indices[${rank}]) {
          int a[${rank}];
          int b[${rank}];
          ${declareC}

          copyVec(indices, a);
          copyVec(indices, b);
          ${broadcastC}

          float value = 0.0;
          for (int k=0; k<${sharedDim}; ++k) {
              a[${rank - 1}] = k;
              b[${rank - 2}] = k;
              ${line}
          }

          value = value * alpha;
          ${calculateC}
          return value;
      }`;
      return {
        ...metadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
        variables: [
          { name: "alpha", type: "float", data: attributes.alpha },
          { name: "beta", type: "float", data: attributes.beta }
        ],
        shaderSource
      };
    };
    validateInputs11 = (inputs, attributes) => {
      if (!inputs) {
        throw new Error("Input is missing");
      }
      if (attributes.isOptionalC && (inputs.length < 2 || inputs.length > 3)) {
        throw new Error("Invaid input shape.");
      }
      if (!attributes.isOptionalC && inputs.length !== 3) {
        throw new Error("Gemm requires 3 inputs");
      }
      if (inputs.length === 3 && inputs[2].dims.length !== 1 && inputs[2].dims.length !== 2) {
        throw new Error("Invalid input shape of C");
      }
      if (inputs[0].type !== "float32" && inputs[0].type !== "float64" || inputs[1].type !== "float32" && inputs[1].type !== "float64" || inputs.length === 3 && inputs[2].type !== "float32" && inputs[2].type !== "float64") {
        throw new Error("Invalid input type.");
      }
      if (inputs[0].type !== inputs[1].type || inputs.length === 3 && inputs[0].type !== inputs[2].type) {
        throw new Error("Input types are mismatched");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/image-scaler.ts
var imageScaler, parseImageScalerAttributes, imageScalerProgramMetadata, createImageScalerProgramInfo, createImageScalerProgramInfoLoader, createGetBiasMethod, validateInputs12;
var init_image_scaler = __esm({
  "web/lib/onnxjs/backends/webgl/ops/image-scaler.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_types();
    imageScaler = (inferenceHandler, inputs, attributes) => {
      validateInputs12(inputs);
      const output = inferenceHandler.run(createImageScalerProgramInfoLoader(inferenceHandler, inputs, attributes), inputs);
      return [output];
    };
    parseImageScalerAttributes = (node) => {
      const scale = node.attributes.getFloat("scale");
      const bias = node.attributes.getFloats("bias");
      return createAttributeWithCacheKey({ scale, bias });
    };
    imageScalerProgramMetadata = {
      name: "ImageScaler",
      inputNames: ["X"],
      inputTypes: [0 /* unpacked */]
    };
    createImageScalerProgramInfo = (_handler, metadata, inputs, attributes) => {
      const outputShape = inputs[0].dims.slice();
      const rank = outputShape.length;
      const getBiasMethod = createGetBiasMethod(attributes.bias.length);
      const shaderSource = `
      ${getBiasMethod}
      float process(int indices[${rank}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;
      return {
        ...metadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
        variables: [
          { name: "bias", type: "float", arrayLength: attributes.bias.length, data: attributes.bias },
          { name: "scale", type: "float", data: attributes.scale }
        ],
        shaderSource
      };
    };
    createImageScalerProgramInfoLoader = (handler, inputs, attributes) => {
      const metadata = { ...imageScalerProgramMetadata, cacheHint: attributes.cacheKey };
      return { ...metadata, get: () => createImageScalerProgramInfo(handler, metadata, inputs, attributes) };
    };
    createGetBiasMethod = (numChannels) => {
      const codeLines = [`float getBias(float bias[${numChannels}], int channel) {`];
      for (let i = 0; i < numChannels; ++i) {
        if (i === 0) {
          codeLines.push(
            `	if (channel == ${i}) { return bias[${i}]; }`
          );
        } else if (i === numChannels - 1) {
          codeLines.push(
            `	else { return bias[${i}]; }`
          );
        } else {
          codeLines.push(
            `	else if (channel == ${i}) { return bias[${i}]; }`
          );
        }
      }
      codeLines.push(
        "	}"
      );
      return codeLines.join("\n");
    };
    validateInputs12 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("ImageScaler requires 1 input.");
      }
      if (inputs[0].dims.length !== 4) {
        throw new Error("Invalid input shape.");
      }
      if (inputs[0].type !== "float32" && inputs[0].type !== "float64") {
        throw new Error("Invalid input type.");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/instance-normalization.ts
var instanceNormalization, parseInstanceNormalizationAttributes, meanAndVarianceProgramMetadata, createMeanAndVarianceProgramInfo, createMeanAndVarianceProgramInfoLoader, computeOutputProgramMetadata, createComputeOutputProgramInfo, createComputeOutputProgramInfoLoader, validateInputs13;
var init_instance_normalization = __esm({
  "web/lib/onnxjs/backends/webgl/ops/instance-normalization.ts"() {
    "use strict";
    init_glsl_source();
    init_types();
    instanceNormalization = (inferenceHandler, inputs, epsilon) => {
      validateInputs13(inputs);
      const meanAndVariance = inferenceHandler.run(createMeanAndVarianceProgramInfoLoader(inputs[0]), inputs);
      const output = inferenceHandler.run(
        createComputeOutputProgramInfoLoader(inferenceHandler, inputs[0], epsilon, meanAndVariance.dims),
        [inputs[0], meanAndVariance, inputs[1], inputs[2]]
      );
      return [output];
    };
    parseInstanceNormalizationAttributes = (node) => node.attributes.getFloat("epsilon", 1e-5);
    meanAndVarianceProgramMetadata = {
      name: "InstanceNormalization_MeanAndVariance",
      inputNames: ["X"],
      inputTypes: [0 /* unpacked */]
    };
    createMeanAndVarianceProgramInfo = (metadata, input) => {
      const xDims = input.dims.slice();
      const channel = xDims[1];
      const channelSize = xDims[2] * xDims[3];
      const outputShape = [xDims[0], channel];
      const shaderSource = `
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${xDims[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${xDims[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${channelSize});
        temp = 0.0;
        for(int a2=0; a2<${xDims[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${xDims[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${channelSize});

        return v;
      }`;
      return {
        ...metadata,
        output: { dims: outputShape, type: input.type, textureType: 4 /* packedLastDimension */ },
        shaderSource
      };
    };
    createMeanAndVarianceProgramInfoLoader = (input) => ({
      ...meanAndVarianceProgramMetadata,
      get: () => createMeanAndVarianceProgramInfo(meanAndVarianceProgramMetadata, input)
    });
    computeOutputProgramMetadata = {
      name: "InstanceNormalization_ComputeOutput",
      inputNames: ["X", "MeanAndVariance", "Scale", "B"],
      inputTypes: [0 /* unpacked */, 4 /* packedLastDimension */, 0 /* unpacked */, 0 /* unpacked */]
    };
    createComputeOutputProgramInfo = (inferenceHandler, metadata, input, epsilon, meanAndVarianceShape) => {
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      const [textureWidth, textureHeight] = inferenceHandler.calculateTextureWidthAndHeight(meanAndVarianceShape, 4 /* packedLastDimension */);
      const [meanAndVarianceWidth, meanAndVarianceHeight] = [textureWidth / 4, textureHeight];
      const shaderSource = `
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${meanAndVarianceWidth}, ${meanAndVarianceHeight});
        return ${glsl.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;
      return {
        ...metadata,
        output: { dims: input.dims, type: input.type, textureType: 0 /* unpacked */ },
        variables: [{ name: "epsilon", type: "float", data: epsilon }],
        shaderSource
      };
    };
    createComputeOutputProgramInfoLoader = (inferenceHandler, input, epsilon, meanAndVarianceShape) => {
      const metadata = { ...computeOutputProgramMetadata, cacheHint: `${epsilon}` };
      return {
        ...metadata,
        get: () => createComputeOutputProgramInfo(inferenceHandler, metadata, input, epsilon, meanAndVarianceShape)
      };
    };
    validateInputs13 = (inputs) => {
      if (!inputs || inputs.length !== 3) {
        throw new Error("InstanceNormalization requires 3 inputs.");
      }
      const X = inputs[0];
      const scale = inputs[1];
      const B = inputs[2];
      if (X.dims.length < 3 || scale.dims.length !== 1 || B.dims.length !== 1) {
        throw new Error("Invalid input shape.");
      }
      if (scale.dims[0] !== X.dims[1] || B.dims[0] !== X.dims[1]) {
        throw new Error("Input shapes are mismatched.");
      }
      if (X.type !== "float32" && X.type !== "float64" || scale.type !== "float32" && scale.type !== "float64" || B.type !== "float32" && B.type !== "float64") {
        throw new Error("Invalid input type.");
      }
      if (inputs[0].dims.length !== 4) {
        throw new Error("Only support 4-D input shape.");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/lrn.ts
function createLrnProgramInfo(inputs, attributes) {
  const C = inputs[0].dims[1];
  const rank = inputs[0].dims.length;
  const from = -Math.floor((attributes.size - 1) / 2);
  const to = Math.ceil((attributes.size - 1) / 2);
  const alpha = `float(${attributes.alpha}) / float(${attributes.size})`;
  const bias = `float(${attributes.bias})`;
  const beta = `float(${attributes.beta})`;
  const shaderSource = `
    float process(int indices[${rank}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${from}; i <= ${to}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${C}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(${bias} + ${alpha} * square_sum, ${beta});
    }`;
  return {
    ...lrnProgramMetadata,
    cacheHint: attributes.cacheKey,
    output: { dims: inputs[0].dims, type: inputs[0].type, textureType: 0 /* unpacked */ },
    shaderSource
  };
}
function createLrnProgramInfoLoader(inputs, attributes) {
  return { ...lrnProgramMetadata, cacheHint: attributes.cacheKey, get: () => createLrnProgramInfo(inputs, attributes) };
}
var lrn, parseLrnAttributes, lrnProgramMetadata, validateInputs14;
var init_lrn = __esm({
  "web/lib/onnxjs/backends/webgl/ops/lrn.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_types();
    lrn = (inferenceHandler, inputs, attributes) => {
      validateInputs14(inputs);
      return [inferenceHandler.run(createLrnProgramInfoLoader(inputs, attributes), inputs)];
    };
    parseLrnAttributes = (node) => {
      const alpha = node.attributes.getFloat("alpha", 1e-4);
      const beta = node.attributes.getFloat("beta", 0.75);
      const bias = node.attributes.getFloat("bias", 1);
      const size = node.attributes.getInt("size");
      return createAttributeWithCacheKey({ alpha, beta, bias, size });
    };
    lrnProgramMetadata = {
      name: "LRN",
      inputNames: ["X"],
      inputTypes: [0 /* unpacked */]
    };
    validateInputs14 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("LRN requires 1 input.");
      }
      if (inputs[0].dims.length !== 4) {
        throw new Error('currently only support LRN for input with "NCHW" format');
      }
      if (inputs[0].type !== "float32") {
        throw new Error("input should be float type");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/pad.ts
var padProgramMetadata, padV2, parsePadAttributesV2, padV11, parsePadAttributesV11, generatePadAttributesFromInputs, createPadProgramInfo, validateInputsV2, validateInputsV11, getPadFunction, getPadConstant, getPadReflect, getPadEdge;
var init_pad = __esm({
  "web/lib/onnxjs/backends/webgl/ops/pad.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_util();
    init_glsl_source();
    init_types();
    padProgramMetadata = {
      name: "Pad",
      inputNames: ["A"],
      inputTypes: [0 /* unpacked */]
    };
    padV2 = (inferenceHandler, inputs, attributes) => {
      validateInputsV2(inputs);
      const output = inferenceHandler.run(
        {
          ...padProgramMetadata,
          cacheHint: attributes.cacheKey,
          get: () => createPadProgramInfo(inferenceHandler, inputs[0], attributes)
        },
        inputs
      );
      return [output];
    };
    parsePadAttributesV2 = (node) => {
      const mode = node.attributes.getString("mode", "constant");
      const value = node.attributes.getFloat("value", 0);
      const pads = node.attributes.getInts("pads");
      return createAttributeWithCacheKey({ mode, value, pads });
    };
    padV11 = (inferenceHandler, inputs, mode) => {
      validateInputsV11(inputs);
      const attrubutes = generatePadAttributesFromInputs(inferenceHandler, inputs, mode);
      return padV2(inferenceHandler, [inputs[0]], attrubutes);
    };
    parsePadAttributesV11 = (node) => node.attributes.getString("mode", "constant");
    generatePadAttributesFromInputs = (inferenceHandler, inputs, mode) => {
      if (!inferenceHandler.session.isInitializer(inputs[1].dataId) || inputs.length >= 3 && !inferenceHandler.session.isInitializer(inputs[2].dataId)) {
        throw new Error("dynamic pad attributes are not allowed");
      }
      const pads = Array.from(inputs[1].integerData);
      const value = inputs.length >= 3 ? inputs[2].floatData[0] : 0;
      return createAttributeWithCacheKey({ mode, pads, value });
    };
    createPadProgramInfo = (inferenceHandler, input, attributes) => {
      const outputShape = ShapeUtil.padShape(input.dims.slice(), attributes.pads);
      const rank = outputShape.length;
      const padFunction = getPadFunction(inferenceHandler, input, attributes);
      const shaderSource = `
      ${padFunction}
      float process(int[${rank}] indices) {
          return padA(indices);
      }`;
      return {
        name: "Pad",
        inputNames: ["A"],
        inputTypes: [0 /* unpacked */],
        output: { dims: outputShape, type: input.type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    validateInputsV2 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Pad requires 1 input");
      }
      if (inputs[0].type !== "float32" && inputs[0].type !== "float64") {
        throw new Error("Invalid input type.");
      }
    };
    validateInputsV11 = (inputs) => {
      if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
        throw new Error("Pad requires 2 or 3 inputs");
      }
      if (inputs[1].type !== "int32") {
        throw new Error("Invalid input type.");
      }
      if (inputs.length >= 3 && inputs[2].type === "string") {
        throw new Error("Invalid input type.");
      }
    };
    getPadFunction = (inferenceHandler, input, attributes) => {
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      const [width, height] = inferenceHandler.calculateTextureWidthAndHeight(input.dims, 0 /* unpacked */);
      const strides = ShapeUtil.computeStrides(input.dims);
      switch (attributes.mode) {
        case "constant":
          return getPadConstant(glsl, input.dims, strides, width, height, attributes.pads, attributes.value);
        case "reflect":
          return getPadReflect(glsl, input.dims, strides, width, height, attributes.pads);
        case "edge":
          return getPadEdge(glsl, input.dims, strides, width, height, attributes.pads);
        default:
          throw new Error("Invalid mode");
      }
    };
    getPadConstant = (glsl, shape2, strides, width, height, pads, value) => {
      const rank = shape2.length;
      let block = "";
      for (let i = rank - 1; i >= 0; --i) {
        block += `
        k = m[${i}] - ${pads[i]};
        if (k < 0)  return constant;
        if (k >= ${shape2[i]}) return constant;
        offset += k * ${strides[i]};
        `;
      }
      return `
      float padA(int m[${rank}]) {
        const float constant = float(${value});
        int offset = 0;
        int k = 0;
        ${block}
        vec2 coords = offsetToCoords(offset, ${width}, ${height});
        float value = getColorAsFloat(${glsl.texture2D}(A, coords));
        return value;
      }
      `;
    };
    getPadReflect = (glsl, shape2, strides, width, height, pads) => {
      const rank = shape2.length;
      let block = "";
      for (let i = rank - 1; i >= 0; --i) {
        block += `
        k = m[${i}] - ${pads[i]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2 * (shape2[i] - 1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${shape2[i]}) { k = _2n_1 - k; }
        }
        offset += k * ${strides[i]};
        `;
      }
      return `
      float padA(int m[${rank}]) {
        int offset = 0;
        int k = 0;
        ${block}
        vec2 coords = offsetToCoords(offset, ${width}, ${height});
        float value = getColorAsFloat(${glsl.texture2D}(A, coords));
        return value;
      }
      `;
    };
    getPadEdge = (glsl, shape2, strides, width, height, pads) => {
      const rank = shape2.length;
      let block = "";
      for (let i = rank - 1; i >= 0; --i) {
        block += `
        k = m[${i}] - ${pads[i]};
        if (k < 0)  k = 0;
        if (k >= ${shape2[i]}) k = ${shape2[i] - 1};
        offset += k * ${strides[i]};
      `;
      }
      return `
      float padA(int m[${rank}]) {
        int offset = 0;
        int k = 0;
        ${block}
        vec2 coords = offsetToCoords(offset, ${width}, ${height});
        float value = getColorAsFloat(${glsl.texture2D}(A, coords));
        return value;
      }
      `;
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/pool.ts
var averagePool, parseAveragePoolAttributes, createAveragePoolProgramInfo, globalAveragePool, parseGlobalAveragePoolAttributes, maxPool, parseMaxPoolAttributes, createMaxPoolProgramInfo, getAdjustedPoolAttributesAndOutputShape, globalMaxPoolAttributes, globalMaxPoolMetadata, globalMaxPool, validateInputs15, generatePoolingCode, copyArray, offsetToIndices;
var init_pool = __esm({
  "web/lib/onnxjs/backends/webgl/ops/pool.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_util();
    init_types();
    averagePool = (inferenceHandler, inputs, attributes) => {
      validateInputs15(inputs);
      const metadata = { name: "AveragePool", inputNames: ["X"], inputTypes: [0 /* unpacked */], cacheHint: attributes.cacheKey };
      const output = inferenceHandler.run(
        { ...metadata, get: () => createAveragePoolProgramInfo(inputs, metadata, false, attributes) },
        inputs
      );
      return [output];
    };
    parseAveragePoolAttributes = (node) => {
      const autoPad = node.attributes.getString("auto_pad", "NOTSET");
      const ceilMode = node.attributes.getInt("ceil_mode", 0);
      const countIncludePad = node.attributes.getInt("count_include_pad", 0) === 0 ? false : true;
      const kernelShape = node.attributes.getInts("kernel_shape");
      const strides = node.attributes.getInts("strides", []);
      const pads = node.attributes.getInts("pads", []);
      if (ceilMode !== 0) {
        throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
      }
      return createAttributeWithCacheKey({ autoPad, ceilMode, countIncludePad, kernelShape, strides, pads });
    };
    createAveragePoolProgramInfo = (inputs, metadata, isGlobalOperator, attributes) => {
      const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(inputs, attributes, isGlobalOperator);
      const kernelSize = ShapeUtil.size(adjustedAttributes.kernelShape);
      const op1 = "value += _X(x);";
      let op2 = "";
      if (adjustedAttributes.countIncludePad) {
        op2 += `value /= float(${kernelSize});`;
      } else {
        op2 += `value /= float(${kernelSize} - pad);`;
      }
      const poolingCode = generatePoolingCode(inputs[0].dims, adjustedAttributes, op1, op2, "0.0");
      const shaderSource = `
        ${poolingCode}
      `;
      return {
        ...metadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    globalAveragePool = (inferenceHandler, inputs, attributes) => {
      validateInputs15(inputs);
      const metadata = {
        name: "GlobalAveragePool",
        inputNames: ["X"],
        inputTypes: [0 /* unpacked */],
        cacheHint: `${attributes.countIncludePad}`
      };
      const output = inferenceHandler.run(
        { ...metadata, get: () => createAveragePoolProgramInfo(inputs, metadata, true, attributes) },
        inputs
      );
      return [output];
    };
    parseGlobalAveragePoolAttributes = (node) => {
      const countIncludePad = node.attributes.getInt("count_include_pad", 0) === 0 ? false : true;
      return createAttributeWithCacheKey(
        { autoPad: "", ceilMode: 0, countIncludePad, kernelShape: [], strides: [], pads: [] }
      );
    };
    maxPool = (inferenceHandler, inputs, attributes) => {
      validateInputs15(inputs);
      const metadata = { name: "MaxPool", inputNames: ["X"], inputTypes: [0 /* unpacked */], cacheHint: attributes.cacheKey };
      const output = inferenceHandler.run(
        { ...metadata, get: () => createMaxPoolProgramInfo(inputs, metadata, false, attributes) },
        inputs
      );
      return [output];
    };
    parseMaxPoolAttributes = (node) => {
      const autoPad = node.attributes.getString("auto_pad", "NOTSET");
      const ceilMode = node.attributes.getInt("ceil_mode", 0);
      const kernelShape = node.attributes.getInts("kernel_shape");
      const strides = node.attributes.getInts("strides", []);
      const pads = node.attributes.getInts("pads", []);
      const storageOrder = node.attributes.getInt("storage_order", 0);
      const dilations = node.attributes.getInts("dilations", []);
      if (storageOrder !== 0) {
        throw new Error("column major storage order is not yet supported for MaxPool");
      }
      if (ceilMode !== 0) {
        throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
      }
      return createAttributeWithCacheKey(
        { autoPad, ceilMode, countIncludePad: false, kernelShape, strides, pads, storageOrder, dilations }
      );
    };
    createMaxPoolProgramInfo = (inputs, metadata, isGlobalOperator, attributes) => {
      const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(inputs, attributes, isGlobalOperator);
      const op1 = `
      value = max(_X(x), value);
    `;
      const op2 = "";
      const poolingCode = generatePoolingCode(inputs[0].dims, adjustedAttributes, op1, op2, "-1e5");
      const shaderSource = `
      ${poolingCode}
    `;
      return {
        ...metadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    getAdjustedPoolAttributesAndOutputShape = (inputs, attributes, isGlobalOperator) => {
      const inputShape = inputs[0].dims.slice();
      const hasDilations = Object.hasOwnProperty.call(attributes, "dilations");
      const kernelShape = attributes.kernelShape.slice();
      const strides = attributes.strides.slice();
      const dilations = hasDilations ? attributes.dilations.slice() : [];
      const pads = attributes.pads.slice();
      PoolConvUtil.adjustPoolAttributes(isGlobalOperator, inputShape, kernelShape, strides, dilations, pads);
      const outputShape = PoolConvUtil.computePoolOutputShape(
        isGlobalOperator,
        inputShape,
        strides,
        dilations,
        kernelShape,
        pads,
        attributes.autoPad
      );
      const newAttributes = Object.assign({}, attributes);
      if (hasDilations) {
        Object.assign(newAttributes, { kernelShape, strides, pads, dilations, cacheKey: attributes.cacheKey });
      } else {
        Object.assign(newAttributes, { kernelShape, strides, pads, cacheKey: attributes.cacheKey });
      }
      return [newAttributes, outputShape];
    };
    globalMaxPoolAttributes = {
      autoPad: "",
      ceilMode: 0,
      countIncludePad: false,
      kernelShape: [],
      strides: [],
      pads: [],
      storageOrder: 0,
      dilations: [],
      cacheKey: ""
    };
    globalMaxPoolMetadata = {
      name: "GlobalMaxPool",
      inputNames: ["X"],
      inputTypes: [0 /* unpacked */]
    };
    globalMaxPool = (inferenceHandler, inputs) => {
      validateInputs15(inputs);
      const output = inferenceHandler.run(
        {
          ...globalMaxPoolMetadata,
          get: () => createMaxPoolProgramInfo(inputs, globalMaxPoolMetadata, true, globalMaxPoolAttributes)
        },
        inputs
      );
      return [output];
    };
    validateInputs15 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Pool ops requires 1 input.");
      }
      if (inputs[0].type !== "float32" && inputs[0].type !== "float64") {
        throw new Error("Invalid input type.");
      }
    };
    generatePoolingCode = (inputDims, attributes, op1, op2, start) => {
      const rank = inputDims.length;
      if (attributes.kernelShape.length <= 2) {
        const kw = attributes.kernelShape[attributes.kernelShape.length - 1];
        const sw = attributes.strides[attributes.strides.length - 1];
        const pwStart = attributes.pads[attributes.pads.length / 2 - 1];
        const pwEnd = attributes.pads[attributes.pads.length - 1];
        const dimW = inputDims[rank - 1];
        let codeW = "";
        let codeH = "";
        let codeHEnd = "";
        if (pwStart + pwEnd !== 0) {
          codeW = `
          for (int i = 0; i < ${kw}; i++) {
            x[${rank} - 1] = indices[${rank} - 1] * ${sw} - ${pwStart} + i;
            if (x[${rank} - 1] < 0 || x[${rank} - 1] >= ${dimW}) {
              pad++;
              continue;
            }
            ${op1}
          }`;
        } else {
          codeW = `
          for (int i = 0; i < ${kw}; i++) {
            x[${rank} - 1] = indices[${rank} - 1] * ${sw} - ${pwStart} + i;
            ${op1}
          }`;
        }
        if (attributes.kernelShape.length === 2) {
          const kh = attributes.kernelShape[attributes.kernelShape.length - 2];
          const sh = attributes.strides[attributes.strides.length - 2];
          const phStart = attributes.pads[attributes.pads.length / 2 - 2];
          const phEnd = attributes.pads[attributes.pads.length - 2];
          const dimH = inputDims[rank - 2];
          if (phStart + phEnd !== 0) {
            codeH = `
            for (int j = 0; j < ${kh}; j++) {
              x[${rank} - 2] = indices[${rank} - 2] * ${sh} - ${phStart} + j;
              if (x[${rank} - 2] < 0 || x[${rank} - 2] >= ${dimH}) {
                pad+= ${kw};
                continue;
              }
          `;
          } else {
            codeH = `
            for (int j = 0; j < ${kh}; j++) {
              x[${rank} - 2] = indices[${rank} - 2] * ${sh} - ${phStart} + j;
            `;
          }
          codeHEnd = `
          }
        `;
        }
        const poolingCode = `
        float process(int indices[${rank}]) {
          int x[${rank}];
          copyVec(indices, x);

          float value = ${start};
          int pad = 0;
          ${codeH}
          ${codeW}
          ${codeHEnd}
          ${op2}
          return value;
        }
      `;
        return poolingCode;
      } else {
        const kernelSize = ShapeUtil.size(attributes.kernelShape);
        const kernelStrides = ShapeUtil.computeStrides(attributes.kernelShape);
        const stridesRank = kernelStrides.length;
        const padsRank = attributes.pads.length;
        const offsetToIndicesFunction = offsetToIndices(stridesRank);
        const copyInputDims = copyArray(inputDims, "inputDims");
        const copyPads = copyArray(attributes.pads, "pads");
        const copyKernelStrides = copyArray(kernelStrides, "kernelStrides");
        const copyStrides = copyArray(attributes.strides, "strides");
        const hasPads = attributes.pads.reduce((sum2, cur) => sum2 + cur);
        let padCode = "";
        if (hasPads) {
          padCode = `
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${op1}
          }`;
        } else {
          padCode = `
          }
          ${op1}
        `;
        }
        const poolingCode = `
        ${offsetToIndicesFunction}
        float process(int indices[${rank}]) {
          int x[${rank}];
          copyVec(indices, x);
          int offset[${stridesRank}];
          int pads[${padsRank}];
          int inputDims[${rank}];
          int kernelStrides[${stridesRank}];
          int strides[${stridesRank}];
          ${copyPads}
          ${copyInputDims}
          ${copyStrides}
          ${copyKernelStrides}

          float value = ${start};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${kernelSize}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${rank} - ${stridesRank}; j < ${rank}; j++) {
              x[j] = indices[j] * strides[j - ${rank} + ${stridesRank}]
                + offset[j - ${rank} + ${stridesRank}] - pads[j - 2];
              ${padCode}
          }
          ${op2}

          return value;
        }
      `;
        return poolingCode;
      }
    };
    copyArray = (array, arrayName) => {
      let block = "";
      for (let i = 0; i < array.length; i++) {
        block += `
      ${arrayName}[${i}] = ${array[i]};
    `;
      }
      return block;
    };
    offsetToIndices = (rank) => `
  void offsetToIndices(int offset, int[${rank}] strides, out int[${rank}] indices) {
    if (${rank} == 0) {
      return;
    }
    for (int i = 0; i < ${rank} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${rank} - 1] = offset;
  }`;
  }
});

// web/lib/onnxjs/backends/webgl/ops/reduce.ts
var reduce, parseReduceAttributes, createReduceProgramInfo, validateInputs16, reduceSum, reduceMean, reduceMax, reduceMin, reduceProd, reduceLogSum, reduceLogSumSquare;
var init_reduce = __esm({
  "web/lib/onnxjs/backends/webgl/ops/reduce.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_operators();
    init_util();
    init_types();
    reduce = (inferenceHandler, inputs, attributes, name2, reduceOp) => {
      validateInputs16(inputs);
      const reduceProgramMetadata = {
        name: name2,
        inputNames: ["A"],
        inputTypes: [0 /* unpacked */]
      };
      const output = inferenceHandler.run(
        {
          ...reduceProgramMetadata,
          cacheHint: attributes.cacheKey,
          get: () => createReduceProgramInfo(inferenceHandler, inputs, attributes, name2, reduceOp, reduceProgramMetadata)
        },
        inputs
      );
      return [output];
    };
    parseReduceAttributes = (node) => {
      const axes = node.attributes.getInts("axes", []);
      const keepDims = node.attributes.getInt("keepdims", 1) === 1;
      return createAttributeWithCacheKey({ axes, keepDims });
    };
    createReduceProgramInfo = (_handler, inputs, attributes, _name, reduceOp, reduceProgramMetadata) => {
      const outputShape = [];
      const iRank = inputs[0].dims.length || 1;
      const idxCopy = [];
      const axes = ShapeUtil.normalizeAxes(attributes.axes, inputs[0].dims.length);
      const ops = reduceOp(inputs, axes);
      let reduceOps = ops[1];
      for (let k = 0; k < inputs[0].dims.length; k++) {
        if (axes.indexOf(k) >= 0 || axes.length === 0) {
          if (attributes.keepDims) {
            outputShape.push(1);
          }
          reduceOps = `
          for(int j${k} = 0; j${k} < ${inputs[0].dims[k]}; j${k}++) {
            inputIdx[${k}] = j${k};
            ${reduceOps}
          }`;
        } else {
          idxCopy.push(`inputIdx[${k}] = outputIdx[${outputShape.length}];`);
          outputShape.push(inputs[0].dims[k]);
        }
      }
      const oRank = outputShape.length || 1;
      const shaderSource = `
      float process(int outputIdx[${oRank}]) {
        float value;                 // final result
        int inputIdx[${iRank}];      // addressing input data
        ${idxCopy.join("\n")}
        ${ops[0]}       // init ops for reduce max/min
        ${reduceOps}
        ${ops[2]}       // final computation for reduce mean
        return value;
      }`;
      return {
        ...reduceProgramMetadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    validateInputs16 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Reduce op requires 1 input.");
      }
      if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {
        throw new Error("Invalid input type.");
      }
    };
    reduceSum = (inferenceHandler, inputs, attributes) => {
      const reduceOp = () => ["value = 0.0;", "value += _A(inputIdx);", ""];
      return reduce(inferenceHandler, inputs, attributes, "ReduceSum", reduceOp);
    };
    reduceMean = (inferenceHandler, inputs, attributes) => {
      const reduceOp = (inputs2, axes) => {
        let size = 1;
        for (let k = 0; k < inputs2[0].dims.length; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            size *= inputs2[0].dims[k];
          }
        }
        return ["value = 0.0;", "value += _A(inputIdx);", `value /= ${size}.;`];
      };
      return reduce(inferenceHandler, inputs, attributes, "ReduceMean", reduceOp);
    };
    reduceMax = (inferenceHandler, inputs, attributes) => {
      const reduceOp = (inputs2, axes) => {
        const idxZero = [];
        for (let k = 0; k < inputs2[0].dims.length; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            idxZero.push(`inputIdx[${k}] = 0;`);
          }
        }
        return [`${idxZero.join("\n")}
value = _A(inputIdx);`, "value = max(value, _A(inputIdx));", ""];
      };
      return reduce(inferenceHandler, inputs, attributes, "ReduceMax", reduceOp);
    };
    reduceMin = (inferenceHandler, inputs, attributes) => {
      const reduceOp = (inputs2, axes) => {
        const idxZero = [];
        for (let k = 0; k < inputs2[0].dims.length; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            idxZero.push(`inputIdx[${k}] = 0;`);
          }
        }
        return [`${idxZero.join("\n")}
value = _A(inputIdx);`, "value = min(value, _A(inputIdx));", ""];
      };
      return reduce(inferenceHandler, inputs, attributes, "ReduceMin", reduceOp);
    };
    reduceProd = (inferenceHandler, inputs, attributes) => {
      const reduceOp = () => ["value = 1.0;", "value *= _A(inputIdx);", ""];
      return reduce(inferenceHandler, inputs, attributes, "ReduceProd", reduceOp);
    };
    reduceLogSum = (inferenceHandler, inputs, attributes) => {
      const reduceOp = () => ["value = 0.0;", "value += _A(inputIdx);", "value = log(value);"];
      return reduce(inferenceHandler, inputs, attributes, "ReduceLogSum", reduceOp);
    };
    reduceLogSumSquare = (inferenceHandler, inputs, attributes) => {
      const reduceOp = () => ["float t; value = 0.0;", "t = _A(inputIdx); value += t * t;", ""];
      return reduce(inferenceHandler, inputs, attributes, "ReduceLogSumSquare", reduceOp);
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/reshape.ts
var reshape;
var init_reshape = __esm({
  "web/lib/onnxjs/backends/webgl/ops/reshape.ts"() {
    "use strict";
    init_util();
    reshape = (handler, inputs) => {
      const reshapedDims = ShapeUtil.calculateReshapedDims(inputs[0].dims, inputs[1].integerData);
      if (handler.session.pack) {
        return [handler.reshapePacked(inputs[0], reshapedDims)];
      } else {
        return [handler.reshapeUnpacked(inputs[0], reshapedDims)];
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/upsample.ts
var upsampleProgramMetadata, upsample, parseUpsampleAttributesV7, parseUpsampleAttributesV9, parseUpsampleAttributes, createUpsampleProgramInfo, validateInputs17, scalesValidation;
var init_upsample = __esm({
  "web/lib/onnxjs/backends/webgl/ops/upsample.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_glsl_source();
    init_types();
    upsampleProgramMetadata = {
      name: "Upsample",
      inputNames: ["X"],
      inputTypes: [0 /* unpacked */]
    };
    upsample = (inferenceHandler, inputs, attributes) => {
      validateInputs17(inputs, attributes);
      const output = inferenceHandler.run(
        {
          ...upsampleProgramMetadata,
          cacheHint: attributes.cacheKey,
          get: () => createUpsampleProgramInfo(inferenceHandler, inputs, attributes)
        },
        inputs
      );
      return [output];
    };
    parseUpsampleAttributesV7 = (node) => parseUpsampleAttributes(node, 7);
    parseUpsampleAttributesV9 = (node) => parseUpsampleAttributes(node, 9);
    parseUpsampleAttributes = (node, opset) => {
      const isResize = opset >= 10;
      const mode = node.attributes.getString("mode", "nearest");
      if (mode !== "nearest" && mode !== "linear" && (opset < 11 || mode !== "cubic")) {
        throw new Error(`unrecognized mode: ${mode}`);
      }
      let scales = [];
      if (opset < 9) {
        scales = node.attributes.getFloats("scales");
        scalesValidation(scales, mode, isResize);
      }
      const extrapolationValue = node.attributes.getFloat("extrapolation_value", 0);
      const coordinateTransformMode = opset > 10 ? node.attributes.getString("coordinate_transformation_mode", "half_pixel") : "asymmetric";
      if ([
        "asymmetric",
        "pytorch_half_pixel",
        "tf_half_pixel_for_nn",
        "align_corners",
        "tf_crop_and_resize",
        "half_pixel"
      ].indexOf(coordinateTransformMode) === -1) {
        throw new Error(`coordinate_transform_mode '${coordinateTransformMode}' is not supported`);
      }
      const needRoiInput = coordinateTransformMode === "tf_crop_and_resize";
      const useExtrapolation = needRoiInput;
      const nearestMode = mode === "nearest" && opset >= 11 ? node.attributes.getString("nearest_mode", "round_prefer_floor") : "";
      if (["round_prefer_floor", "round_prefer_ceil", "floor", "ceil", ""].indexOf(nearestMode) === -1) {
        throw new Error(`nearest_mode '${nearestMode}' is not supported`);
      }
      const cubicCoefficientA = node.attributes.getFloat("cubic_coeff_a", -0.75);
      const excludeOutside = node.attributes.getInt("exclude_outside", 0) !== 0;
      if (excludeOutside && mode !== "cubic") {
        throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");
      }
      const useNearest2xOptimization = opset < 11 ? true : mode === "nearest" && coordinateTransformMode === "asymmetric" && nearestMode === "floor";
      let roiInputIdx = 0;
      let scalesInputIdx = 0;
      let sizesInputIdx = 0;
      if (opset > 10) {
        if (node.inputs.length > 2) {
          roiInputIdx = 1;
          scalesInputIdx = 2;
          sizesInputIdx = 3;
        } else {
          scalesInputIdx = 1;
          sizesInputIdx = 2;
        }
      } else if (opset === 9) {
        scalesInputIdx = 1;
      }
      return createAttributeWithCacheKey({
        opset,
        isResize,
        mode,
        scales,
        extrapolationValue,
        coordinateTransformMode,
        useExtrapolation,
        needRoiInput,
        nearestMode,
        cubicCoefficientA,
        excludeOutside,
        useNearest2xOptimization,
        roiInputIdx,
        scalesInputIdx,
        sizesInputIdx
      });
    };
    createUpsampleProgramInfo = (inferenceHandler, inputs, attributes) => {
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      const [inputWidth, inputHeight] = inferenceHandler.calculateTextureWidthAndHeight(inputs[0].dims, 0 /* unpacked */);
      const outputShape = inputs[0].dims.map((dim2, i) => Math.floor(dim2 * attributes.scales[i]));
      const [outputWidth, outputHeight] = inferenceHandler.calculateTextureWidthAndHeight(outputShape, 0 /* unpacked */);
      const dim = outputShape.length;
      const outputPitches = new Array(dim);
      const inputPitches = new Array(dim);
      let precalculatedPitches = `
      int output_pitches[${dim}];
      int input_pitches[${dim}];
      `;
      for (let d = dim - 1; d >= 0; d--) {
        outputPitches[d] = d === dim - 1 ? 1 : outputPitches[d + 1] * outputShape[d + 1];
        inputPitches[d] = d === dim - 1 ? 1 : inputPitches[d + 1] * inputs[0].dims[d + 1];
        precalculatedPitches += `
        output_pitches[${d}] = ${outputPitches[d]};
        input_pitches[${d}] = ${inputPitches[d]};
        `;
      }
      const getInputFloatFunction = `
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${inputWidth}, ${inputHeight});
        float value = getColorAsFloat(${glsl.texture2D}(X, coords));
        return value;
      }
      `;
      const shaderSource = attributes.mode === "nearest" ? (
        // nearest
        `
    ${getInputFloatFunction}
    float process(int indices[${dim}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});

      ${precalculatedPitches}

      int d, m;
      for (int dim = 0; dim < ${dim}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`
      ) : dim === 4 ? (
        // bilinear 4D
        `
    ${getInputFloatFunction}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});

      ${precalculatedPitches}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${inputs[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`
      ) : (
        // bilinear 2D
        `
    ${getInputFloatFunction}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${outputWidth}, ${outputHeight});

      ${precalculatedPitches}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${inputs[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`
      );
      return {
        ...upsampleProgramMetadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
        shaderSource,
        variables: [{
          name: "scales",
          type: "int",
          arrayLength: attributes.scales.length,
          data: attributes.scales.map((x) => Math.ceil(x))
        }]
      };
    };
    validateInputs17 = (inputs, attribute) => {
      if (!inputs || attribute.opset < 9 && inputs.length !== 1 || attribute.opset >= 9 && attribute.opset < 11 && inputs.length !== 2 || attribute.opset >= 11 && inputs.length < 2) {
        throw new Error("invalid inputs.");
      }
      if (attribute.scales.length > 0 && inputs[0].dims.length !== attribute.scales.length) {
        throw new Error("Invalid input shape.");
      }
      if (inputs[0].type === "string") {
        throw new Error("Invalid input tensor types.");
      }
    };
    scalesValidation = (scales, mode, isResize) => {
      if (!isResize) {
        for (const scale of scales) {
          if (scale < 1) {
            throw new Error("Scale value should be greater than or equal to 1.");
          }
        }
      } else {
        for (const scale of scales) {
          if (scale <= 0) {
            throw new Error("Scale value should be greater than 0.");
          }
        }
      }
      if (mode === "linear" || mode === "cubic") {
        if (scales.length !== 2 && (scales.length !== 4 || scales[0] !== 1 || scales[1] !== 1)) {
          throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${isResize ? "Resize" : "Upsample"} opeartor.`);
        }
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/resize-packed.ts
var resizeProgramMetadata, resize, parseResizeAttributesV10, parseResizeAttributesV11, createPackedResizeProgramInfo, prepareInputs, parseScalesData, parseScalesDataFromOutputSize;
var init_resize_packed = __esm({
  "web/lib/onnxjs/backends/webgl/ops/resize-packed.ts"() {
    "use strict";
    init_glsl_source();
    init_types();
    init_utils();
    init_packing_utils();
    init_upsample();
    resizeProgramMetadata = {
      name: "Resize",
      inputNames: ["A"],
      inputTypes: [2 /* packed */]
    };
    resize = (inferenceHandler, inputs, attributes) => {
      validateInputs17(inputs, attributes);
      const output = inferenceHandler.run(
        {
          ...resizeProgramMetadata,
          cacheHint: attributes.cacheKey,
          get: () => createPackedResizeProgramInfo(inferenceHandler, inputs, attributes)
        },
        inputs
      );
      return [output];
    };
    parseResizeAttributesV10 = (node) => parseUpsampleAttributes(node, 10);
    parseResizeAttributesV11 = (node) => parseUpsampleAttributes(node, 11);
    createPackedResizeProgramInfo = (inferenceHandler, inputs, attributes) => {
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      const [scales, outputShape] = prepareInputs(inputs, attributes);
      const isSame = scales.every((s) => s === 1) && attributes.coordinateTransformMode !== "tf_crop_and_resize";
      if (isSame) {
        return {
          ...resizeProgramMetadata,
          output: { dims: outputShape, type: inputs[0].type, textureType: 2 /* packed */ },
          hasMain: true,
          shaderSource: `void main() {
                    vec4 v = ${glsl.texture2D}(X, TexCoords);
                    ${glsl.output} = v;
                }`
        };
      }
      const dim = outputShape.length;
      if (dim < 2) {
        throw new Error(`output dimension should be at least 2, but got ${dim}`);
      }
      const outputHeight = outputShape[dim - 2];
      const outputWidth = outputShape[dim - 1];
      const inputShape = inputs[0].dims;
      if (dim !== inputShape.length) {
        throw new Error(`output dimension should match input ${inputShape.length}, but got ${dim}`);
      }
      const inputHeight = inputShape[dim - 2];
      const inputWidth = inputShape[dim - 1];
      const scalesHeight = scales[dim - 2];
      const scalesWidth = scales[dim - 1];
      let getSourceFracIndex = "";
      if (attributes.mode !== "linear") {
        throw new Error(`resize (packed) does not support mode: '${attributes.mode}'`);
      }
      switch (attributes.coordinateTransformMode) {
        case "asymmetric":
          getSourceFracIndex = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;
          break;
        case "half_pixel":
          getSourceFracIndex = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;
          break;
        case "pytorch_half_pixel":
          getSourceFracIndex = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${outputWidth}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${outputHeight}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${outputWidth}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${outputHeight}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;
          break;
        case "align_corners":
          getSourceFracIndex = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${outputWidth}.0 - 1.0, ${outputHeight}.0 - 1.0, ${outputWidth}.0 - 1.0,
                            ${outputHeight}.0 - 1.0);
                        vec4 original = vec4(${inputWidth}.0 - 1.0, ${inputHeight}.0 - 1.0, ${inputWidth}.0 - 1.0,
                            ${inputHeight}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;
          break;
        default:
          throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${attributes.coordinateTransformMode}'`);
      }
      const coordsDataType = getCoordsDataType(dim);
      const unpackChannel = unpackFromChannel();
      const shaderSource = `
            const vec2 inputWH = vec2(${inputHeight}.0, ${inputWidth}.0);
            const vec4 scaleWHWH = vec4(float(${scalesHeight}), float(${scalesWidth}), float(${scalesHeight}), float(${scalesWidth}));
            ${unpackChannel}
            ${getSourceFracIndex}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${coordsDataType} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${outputHeight - 1};
                bool hasNextCol = rc.z < ${outputWidth - 1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${glsl.output} = vec4(newValue);
            }
        `;
      return {
        ...resizeProgramMetadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 2 /* packed */ },
        hasMain: true,
        shaderSource
      };
    };
    prepareInputs = (inputs, attributes) => {
      const x = inputs[0];
      const xDims = x.dims;
      let scales = attributes.scales;
      let outputSizes;
      if (scales.length === 0) {
        const scalesTensor = inputs[attributes.scalesInputIdx];
        if (scalesTensor && scalesTensor.size !== 0) {
          if (inputs[attributes.sizesInputIdx]) {
            throw new Error("Only one of scales or sizes must be provided as input.");
          }
          scales = parseScalesData(scalesTensor, attributes.mode, attributes.isResize);
        } else {
          const sizesTensor = inputs[attributes.sizesInputIdx];
          if (!sizesTensor || sizesTensor.size === 0) {
            throw new Error("Either scales or sizes MUST be provided as input.");
          }
          outputSizes = Array.from(sizesTensor.integerData);
          scales = parseScalesDataFromOutputSize(outputSizes, xDims, attributes.mode, attributes.isResize);
        }
      } else {
        if (inputs[attributes.sizesInputIdx]) {
          throw new Error("Only one of scales or sizes must be provided as input.");
        }
      }
      const yDims = outputSizes || xDims.map((dim, i) => Math.floor(dim * scales[i]));
      return [scales, yDims];
    };
    parseScalesData = (scale, mode, isResize) => {
      const scales = Array.from(scale.floatData);
      scalesValidation(scales, mode, isResize);
      return scales;
    };
    parseScalesDataFromOutputSize = (yDims, xDims, mode, isResize) => {
      const length = xDims.length;
      const scales = new Array(length);
      for (let i = 0, end = length; i < end; i++) {
        if (xDims[i] === 0) {
          if (yDims[i] !== 0) {
            throw new Error("Input dim is zero but required output dim is non-zero.");
          }
          scales[i] = 1;
        } else {
          scales[i] = yDims[i] / xDims[i];
        }
      }
      scalesValidation(scales, mode, isResize);
      return scales;
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/shape.ts
var shape, validateInputs18;
var init_shape = __esm({
  "web/lib/onnxjs/backends/webgl/ops/shape.ts"() {
    "use strict";
    init_tensor2();
    shape = (_inferenceHandler, inputs) => {
      validateInputs18(inputs);
      return [new Tensor3([inputs[0].dims.length], "int32", void 0, void 0, new Int32Array(inputs[0].dims))];
    };
    validateInputs18 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Shape requires 1 input.");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/slice.ts
var sliceProgramMetadata, slice, parseSliceAttributes, createSliceProgramInfo, validateInputs19, sliceV10, generateSliceAttributesFromInputs, validateInputsV10;
var init_slice = __esm({
  "web/lib/onnxjs/backends/webgl/ops/slice.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_operators();
    init_util();
    init_types();
    sliceProgramMetadata = {
      name: "Slice",
      inputNames: ["A"],
      inputTypes: [0 /* unpacked */]
    };
    slice = (inferenceHandler, inputs, attributes) => {
      validateInputs19(inputs);
      const output = inferenceHandler.run(
        {
          ...sliceProgramMetadata,
          cacheHint: attributes.cacheKey,
          get: () => createSliceProgramInfo(inferenceHandler, inputs[0], attributes)
        },
        inputs
      );
      return [output];
    };
    parseSliceAttributes = (node) => {
      const starts = node.attributes.getInts("starts");
      const ends = node.attributes.getInts("ends");
      const axes = node.attributes.getInts("axes", []);
      return createAttributeWithCacheKey({ starts, ends, axes });
    };
    createSliceProgramInfo = (_inferenceHandler, input, attributes) => {
      const axes = attributes.axes.length === 0 ? input.dims.slice(0).map((_val, i) => i) : attributes.axes;
      const normalizedAxes = ShapeUtil.normalizeAxes(axes, input.dims.length);
      const starts = attributes.starts.map((start, i) => {
        if (start > input.dims[normalizedAxes[i]] - 1) {
          return input.dims[normalizedAxes[i]];
        }
        return ShapeUtil.normalizeAxis(start, input.dims[normalizedAxes[i]]);
      });
      const ends = attributes.ends.map((end, i) => {
        if (end > input.dims[normalizedAxes[i]] - 1) {
          return input.dims[normalizedAxes[i]];
        }
        return ShapeUtil.normalizeAxis(end, input.dims[normalizedAxes[i]]);
      });
      const outputShape = input.dims.slice();
      const sliceOps = [];
      for (let i = 0; i < normalizedAxes.length; i++) {
        outputShape[normalizedAxes[i]] = ends[i] - starts[i];
        if (starts[i] > 0) {
          sliceOps.push(`outputIdx[${normalizedAxes[i]}] += ${starts[i]};`);
        }
      }
      const rank = outputShape.length;
      const shaderSource = `
      float process(int outputIdx[${rank}]) {
        ${sliceOps.join("\n      ")}
        return _A(outputIdx);
      }`;
      return {
        ...sliceProgramMetadata,
        output: { dims: outputShape, type: input.type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    validateInputs19 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Slice requires 1 input.");
      }
      if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {
        throw new Error("Invalid input type.");
      }
    };
    sliceV10 = (inferenceHandler, inputs) => {
      validateInputsV10(inputs);
      const attributes = generateSliceAttributesFromInputs(inferenceHandler, inputs);
      const output = inferenceHandler.run(
        {
          ...sliceProgramMetadata,
          cacheHint: attributes.cacheKey,
          get: () => createSliceProgramInfo(inferenceHandler, inputs[0], attributes)
        },
        [inputs[0]]
      );
      return [output];
    };
    generateSliceAttributesFromInputs = (inferenceHandler, inputs) => {
      if (!inferenceHandler.session.isInitializer(inputs[1].dataId) || !inferenceHandler.session.isInitializer(inputs[2].dataId) || inputs.length >= 4 && !inferenceHandler.session.isInitializer(inputs[3].dataId) || inputs.length >= 5 && !inferenceHandler.session.isInitializer(inputs[4].dataId)) {
        throw new Error("dynamic slice attributes are not allowed");
      }
      if (inputs.length >= 5 && inputs[4].integerData.some((i) => i !== 1)) {
        throw new Error("currently non-1 steps is not supported for Slice");
      }
      const starts = Array.from(inputs[1].integerData);
      const ends = Array.from(inputs[2].integerData);
      const axes = inputs.length >= 4 ? Array.from(inputs[3].integerData) : [];
      const cacheKey = `${axes};${starts};${ends}`;
      return { starts, ends, axes, cacheKey };
    };
    validateInputsV10 = (inputs) => {
      if (!inputs || inputs.length < 3 || inputs.length > 5) {
        throw new Error("Invalid input number.");
      }
      if (inputs[1].type !== "int32" || inputs[1].dims.length !== 1) {
        throw new Error("Invalid input type.");
      }
      if (inputs[2].type !== "int32" || inputs[2].dims.length !== 1) {
        throw new Error("Invalid input type.");
      }
      if (inputs.length >= 4 && (inputs[3].type !== "int32" || inputs[3].dims.length !== 1)) {
        throw new Error("Invalid input type.");
      }
      if (inputs.length >= 5 && (inputs[4].type !== "int32" || inputs[4].dims.length !== 1)) {
        throw new Error("Invalid input type.");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/softmax.ts
var softmaxComputeMaxProgramMetadata, softmaxComputeScaleProgramMetadata, softmaxProgramMetadata, softmax, parseSoftmaxAttributes, parseSoftmaxAttributesV13, softmaxV13, computeSoftmax, createComputeMaxProgramInfo, createComputScaleProgramInfo, createSoftMaxProgramInfo, validateInputs20;
var init_softmax = __esm({
  "web/lib/onnxjs/backends/webgl/ops/softmax.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_util();
    init_glsl_source();
    init_types();
    init_transpose();
    softmaxComputeMaxProgramMetadata = {
      name: "SoftmaxComputeMax",
      inputNames: ["A"],
      inputTypes: [0 /* unpacked */]
    };
    softmaxComputeScaleProgramMetadata = {
      name: "SoftmaxComputeScale",
      inputNames: ["A", "Max"],
      inputTypes: [0 /* unpacked */, 0 /* unpacked */]
    };
    softmaxProgramMetadata = {
      name: "SoftMax",
      inputNames: ["A", "Max", "Norm"],
      inputTypes: [0 /* unpacked */, 0 /* unpacked */, 0 /* unpacked */]
    };
    softmax = (inferenceHandler, inputs, attributes) => {
      validateInputs20(inputs);
      const inputShape = inputs[0].dims.slice();
      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);
      const logicalRowCount = ShapeUtil.sizeToDimension(inputShape, axis);
      const featureCount = ShapeUtil.sizeFromDimension(inputShape, axis);
      const output = computeSoftmax(inferenceHandler, inputs, attributes, logicalRowCount, featureCount);
      return output;
    };
    parseSoftmaxAttributes = (node) => createAttributeWithCacheKey({ axis: node.attributes.getInt("axis", 1) });
    parseSoftmaxAttributesV13 = (node) => createAttributeWithCacheKey({ axis: node.attributes.getInt("axis", -1) });
    softmaxV13 = (inferenceHandler, inputs, attributes) => {
      validateInputs20(inputs);
      const inputShape = inputs[0].dims.slice();
      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);
      const rank = inputShape.length;
      const isTransposeRequired = axis !== rank - 1 ? true : false;
      const transposedInputShape = [];
      let perm = [];
      let transposedInputs = [];
      let transposeAttribute;
      if (isTransposeRequired) {
        perm = Array.from({ length: rank }).map((_, i) => i);
        perm[axis] = rank - 1;
        perm[rank - 1] = axis;
        perm.map((p) => transposedInputShape.push(inputShape[p]));
        transposeAttribute = createAttributeWithCacheKey({ perm });
        transposedInputs = transpose(inferenceHandler, inputs, transposeAttribute);
      }
      const logicalRowCount = isTransposeRequired ? ShapeUtil.sizeToDimension(transposedInputShape, rank - 1) : ShapeUtil.sizeToDimension(inputShape, rank - 1);
      const featureCount = isTransposeRequired ? ShapeUtil.sizeFromDimension(transposedInputShape, rank - 1) : ShapeUtil.sizeFromDimension(inputShape, rank - 1);
      const output = computeSoftmax(
        inferenceHandler,
        isTransposeRequired ? transposedInputs : inputs,
        attributes,
        logicalRowCount,
        featureCount
      );
      if (isTransposeRequired) {
        const reversedOutput = transpose(inferenceHandler, output, transposeAttribute);
        return reversedOutput;
      } else {
        return output;
      }
    };
    computeSoftmax = (inferenceHandler, inputs, attributes, logicalRowCount, featureCount) => {
      const computeMaxProgramInfo = createComputeMaxProgramInfo(inferenceHandler, inputs[0], logicalRowCount, featureCount, [logicalRowCount]);
      const max = inferenceHandler.run(
        { ...softmaxComputeMaxProgramMetadata, cacheHint: attributes.cacheKey, get: () => computeMaxProgramInfo },
        inputs
      );
      const computeScaleProgramInfo = createComputScaleProgramInfo(
        inferenceHandler,
        inputs[0],
        logicalRowCount,
        featureCount,
        computeMaxProgramInfo.output.dims,
        [logicalRowCount]
      );
      const scale = inferenceHandler.run(
        { ...softmaxComputeScaleProgramMetadata, cacheHint: attributes.cacheKey, get: () => computeScaleProgramInfo },
        [inputs[0], max]
      );
      const softMaxProgramInfo = createSoftMaxProgramInfo(
        inferenceHandler,
        inputs[0],
        logicalRowCount,
        featureCount,
        computeMaxProgramInfo.output.dims,
        computeScaleProgramInfo.output.dims
      );
      const output = inferenceHandler.run(
        { ...softmaxProgramMetadata, cacheHint: attributes.cacheKey, get: () => softMaxProgramInfo },
        [inputs[0], max, scale]
      );
      return [output];
    };
    createComputeMaxProgramInfo = (inferenceHandler, input, logicalRowCount, featureCount, outputShape) => {
      const [textureWidth, textureHeight] = inferenceHandler.calculateTextureWidthAndHeight(input.dims, 0 /* unpacked */);
      const rank = outputShape.length;
      if (logicalRowCount < 1 || featureCount < 1) {
        throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
      }
      if (outputShape.length !== 1) {
        throw new Error("Dimensionality of the output should be 1");
      }
      if (outputShape[0] !== logicalRowCount) {
        throw new Error("Shape of the output should be equal to logical row count");
      }
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      const shaderSource = `
      float process(int[${rank}] indices) {
        int logical_row_start_offset = indices[0] * ${featureCount};

        float max = getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset, ${textureWidth},
        ${textureHeight} )));
        for(int i=1; i<${featureCount}; ++i)
        {
          float current = getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${textureWidth}, ${textureHeight})));
          if(current > max)
          max = current;
        }

        return max;
      }`;
      return {
        ...softmaxComputeMaxProgramMetadata,
        output: { dims: outputShape, type: input.type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    createComputScaleProgramInfo = (inferenceHandler, input, logicalRowCount, featureCount, maxElementPerLogicalRow, outputShape) => {
      const [textureWidth, textureHeight] = inferenceHandler.calculateTextureWidthAndHeight(input.dims, 0 /* unpacked */);
      const rank = outputShape.length;
      if (logicalRowCount < 1 || featureCount < 1) {
        throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
      }
      if (outputShape.length !== 1) {
        throw new Error("Dimensionality of the output should be 1");
      }
      if (outputShape[0] !== logicalRowCount) {
        throw new Error("Shape of the output should be equal to logical row count");
      }
      if (maxElementPerLogicalRow.length !== 1) {
        throw new Error("Dimensionality of the intermediate results should be 1");
      }
      if (maxElementPerLogicalRow[0] !== logicalRowCount) {
        throw new Error("Shape of the intermediate results should be equal to logical row count");
      }
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      const shaderSource = `
      float process(int[${rank}] indices) {
        int logical_row_start_offset = indices[0] * ${featureCount};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${featureCount}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${glsl.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${textureWidth}, ${textureHeight}))) - max);
        }

        return norm_factor;
      }`;
      return {
        ...softmaxComputeScaleProgramMetadata,
        output: { dims: outputShape, type: input.type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    createSoftMaxProgramInfo = (inferenceHandler, input, logicalRowCount, featureCount, maxElementPerLogicalRow, normalizationPerLogicalRow) => {
      const [textureWidth, textureHeight] = inferenceHandler.calculateTextureWidthAndHeight(input.dims, 0 /* unpacked */);
      const rank = input.dims.length;
      if (logicalRowCount < 1 || featureCount < 1) {
        throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
      }
      if (maxElementPerLogicalRow.length !== 1 || normalizationPerLogicalRow.length !== 1) {
        throw new Error("Dimensionality of the intermediate results should be 1");
      }
      if (maxElementPerLogicalRow[0] !== logicalRowCount || normalizationPerLogicalRow[0] !== logicalRowCount) {
        throw new Error("Shape of the intermediate results should be equal to logical row count");
      }
      const shaderSource = `
      float process(int[${rank}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${textureWidth}, ${textureHeight});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${featureCount};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;
      return {
        ...softmaxProgramMetadata,
        output: { dims: input.dims, type: input.type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    validateInputs20 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Softmax requires 1 input.");
      }
      if (inputs[0].type !== "float32" && inputs[0].type !== "float64") {
        throw new Error("Invalid input type");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/split.ts
var splitProgramMetadata, split, parseSplitAttributes, getProgramCount, createSplitProgramInfo, validateInputs21;
var init_split = __esm({
  "web/lib/onnxjs/backends/webgl/ops/split.ts"() {
    "use strict";
    init_attribute_with_cache_key();
    init_util();
    init_types();
    splitProgramMetadata = {
      name: "Split",
      inputNames: ["A"],
      inputTypes: [0 /* unpacked */]
    };
    split = (inferenceHandler, inputs, attributes) => {
      validateInputs21(inputs);
      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputs[0].dims.length);
      const count = getProgramCount(inferenceHandler, inputs, axis, attributes);
      const output = [];
      for (let i = 0; i < count; ++i) {
        output.push(inferenceHandler.run(
          {
            ...splitProgramMetadata,
            cacheHint: `${attributes.cacheKey};${i}`,
            get: () => createSplitProgramInfo(inferenceHandler, inputs[0], attributes, axis, i)
          },
          inputs
        ));
      }
      return output;
    };
    parseSplitAttributes = (node) => {
      const axis = node.attributes.getInt("axis", 0);
      const split2 = node.attributes.getInts("split", []);
      const numOutputs = node.outputs.length;
      return createAttributeWithCacheKey({ axis, split: split2, numOutputs });
    };
    getProgramCount = (_inferenceHandler, inputs, axis, attributes) => {
      const [, offsets] = SplitUtil.splitShape(inputs[0].dims, axis, attributes.split, attributes.numOutputs);
      return offsets.length;
    };
    createSplitProgramInfo = (_inferenceHandler, input, attributes, axis, index) => {
      const [shapes, offsets] = SplitUtil.splitShape(input.dims, axis, attributes.split, attributes.numOutputs);
      const offset = offsets[index];
      const outputShape = shapes[index];
      const rank = outputShape.length;
      const shaderSource = `
      float process(int indices[${rank}]) {
        indices[${axis}] += ${offset};
        return _A(indices);
      }
    `;
      return {
        ...splitProgramMetadata,
        cacheHint: `${attributes.cacheKey}:${index}`,
        output: { dims: outputShape, type: input.type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    validateInputs21 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Split requires one input.");
      }
      if (inputs[0].type !== "int8" && inputs[0].type !== "uint8" && inputs[0].type !== "int16" && inputs[0].type !== "uint16" && inputs[0].type !== "int32" && inputs[0].type !== "uint32" && inputs[0].type !== "float32" && inputs[0].type !== "float64" && inputs[0].type !== "bool") {
        throw new Error("Invalid input type.");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/squeeze.ts
var squeeze, squeezeV13, parseSqueezeAttributes, validateInputs22, validateInputsV13;
var init_squeeze = __esm({
  "web/lib/onnxjs/backends/webgl/ops/squeeze.ts"() {
    "use strict";
    init_util();
    squeeze = (inferenceHandler, inputs, axes) => {
      validateInputs22(inputs);
      const outputShape = ShapeUtil.squeezeShape(inputs[0].dims, axes);
      const output = inferenceHandler.reshapeUnpacked(inputs[0], outputShape);
      return [output];
    };
    squeezeV13 = (inferenceHandler, inputs) => {
      validateInputsV13(inputs);
      return squeeze(inferenceHandler, [inputs[0]], Array.from(inputs[1].integerData));
    };
    parseSqueezeAttributes = (node) => node.attributes.getInts("axes");
    validateInputs22 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Squeeze requires 1 input.");
      }
      if (inputs[0].type === "string") {
        throw new Error("invalid input tensor types.");
      }
    };
    validateInputsV13 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("Squeeze requires 2 inputs.");
      }
      if (inputs[1].type !== "int32") {
        throw new Error("Invalid input type.");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/sum.ts
var sum, createSumProgramInfo, validateInputs23;
var init_sum = __esm({
  "web/lib/onnxjs/backends/webgl/ops/sum.ts"() {
    "use strict";
    init_glsl_source();
    init_types();
    sum = (inferenceHandler, inputs) => {
      validateInputs23(inputs);
      const sumProgramMetadata = {
        name: "Sum",
        inputNames: inputs.map((_v, i) => `X${i}`),
        inputTypes: new Array(inputs.length).fill(0 /* unpacked */)
      };
      const output = inferenceHandler.run(
        { ...sumProgramMetadata, get: () => createSumProgramInfo(inferenceHandler, inputs, sumProgramMetadata) },
        inputs
      );
      return [output];
    };
    createSumProgramInfo = (inferenceHandler, inputs, sumProgramMetadata) => {
      const glsl = getGlsl(inferenceHandler.session.backend.glContext.version);
      const outputShape = inputs[0].dims.slice();
      const sumLine = inputs.map((_v, i) => `${glsl.texture2D}(X${i},TexCoords)`).join(" + ");
      const shaderSource = `
      void main() {
        vec4 result = ${sumLine};
        ${glsl.output} = result;
      }
    `;
      return {
        ...sumProgramMetadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
        hasMain: true,
        shaderSource
      };
    };
    validateInputs23 = (inputs) => {
      if (!inputs || inputs.length === 0) {
        throw new Error("Sum requires inputs.");
      }
      const length = inputs[0].dims.length;
      for (let i = 1; i < inputs.length; i++) {
        if (length !== inputs[i].dims.length) {
          throw new Error("Input shapes are mismatched.");
        }
        for (let j = 0; j < length; j++) {
          if (inputs[0].dims[j] !== inputs[i].dims[j]) {
            throw new Error("Input shapes are not matched.");
          }
        }
      }
      if (inputs[0].type !== "float32" && inputs[0].type !== "float64") {
        throw new Error("Invalid input type.");
      }
      for (let i = 1; i < inputs.length; i++) {
        if (inputs[0].type !== inputs[i].type) {
          throw new Error("Input types are not matched.");
        }
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/tile.ts
var tile, createTileProgramInfo, validateInputs24;
var init_tile = __esm({
  "web/lib/onnxjs/backends/webgl/ops/tile.ts"() {
    "use strict";
    init_operators();
    init_types();
    tile = (inferenceHandler, inputs) => {
      validateInputs24(inputs);
      const tileProgramMetadata = {
        name: "Tile",
        inputNames: ["A"],
        inputTypes: [0 /* unpacked */]
      };
      const output = inferenceHandler.run(
        { ...tileProgramMetadata, get: () => createTileProgramInfo(inferenceHandler, inputs, tileProgramMetadata) },
        inputs
      );
      return [output];
    };
    createTileProgramInfo = (_handler, inputs, tileProgramMetadata) => {
      const inputShape = inputs[0].dims.slice();
      const outputShape = new Array(inputShape.length);
      const tileOps = [];
      for (let i = 0; i < inputShape.length; i++) {
        outputShape[i] = inputShape[i] * inputs[1].numberData[i];
        tileOps.push(`inputIdx[${i}] = int(mod(float(outputIdx[${i}]), ${inputShape[i]}.));`);
      }
      const rank = outputShape.length;
      const shaderSource = `
      float process(int outputIdx[${rank}]) {
        int inputIdx[${rank}];
        ${tileOps.join("\n")}
        return _A(inputIdx);
      }
    `;
      return {
        ...tileProgramMetadata,
        output: { dims: outputShape, type: inputs[0].type, textureType: 0 /* unpacked */ },
        shaderSource
      };
    };
    validateInputs24 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("Tile requires 2 input.");
      }
      if (inputs[1].dims.length !== 1) {
        throw new Error("The second input shape must 1 dimension.");
      }
      if (inputs[1].dims[0] !== inputs[0].dims.length) {
        throw new Error("Invalid input shape.");
      }
      if (NUMBER_TYPES.indexOf(inputs[0].type) === -1) {
        throw new Error("Invalid input type.");
      }
      if (inputs[1].type !== "int32" && inputs[1].type !== "int16") {
        throw new Error("Invalid repeat type.");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/ops/unsqueeze.ts
var unsqueeze, unsqueezeV13, parseUnsqueezeAttributes, validateInputs25, validateInputsV132;
var init_unsqueeze = __esm({
  "web/lib/onnxjs/backends/webgl/ops/unsqueeze.ts"() {
    "use strict";
    init_util();
    unsqueeze = (inferenceHandler, inputs, axes) => {
      validateInputs25(inputs);
      const outputShape = ShapeUtil.unsqueezeShape(inputs[0].dims, axes);
      const output = inferenceHandler.reshapeUnpacked(inputs[0], outputShape);
      return [output];
    };
    unsqueezeV13 = (inferenceHandler, inputs) => {
      validateInputsV132(inputs);
      return unsqueeze(inferenceHandler, [inputs[0]], Array.from(inputs[1].integerData));
    };
    parseUnsqueezeAttributes = (node) => node.attributes.getInts("axes");
    validateInputs25 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Unsqueeze requires 1 input.");
      }
      if (inputs[0].type === "string") {
        throw new Error("invalid input tensor types.");
      }
    };
    validateInputsV132 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("Unsqueeze requires 2 inputs.");
      }
      if (inputs[1].type !== "int32") {
        throw new Error("Invalid input type.");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/op-resolve-rules.ts
var WEBGL_OP_RESOLVE_RULES;
var init_op_resolve_rules = __esm({
  "web/lib/onnxjs/backends/webgl/op-resolve-rules.ts"() {
    "use strict";
    init_batch_normalization();
    init_binary_op();
    init_cast();
    init_concat();
    init_conv();
    init_conv_transpose();
    init_depth_to_space();
    init_flatten();
    init_gather();
    init_gemm();
    init_image_scaler();
    init_instance_normalization();
    init_lrn();
    init_matmul();
    init_pad();
    init_pool();
    init_reduce();
    init_reshape();
    init_resize_packed();
    init_shape();
    init_slice();
    init_softmax();
    init_split();
    init_squeeze();
    init_sum();
    init_tile();
    init_transpose();
    init_unary_op();
    init_unsqueeze();
    init_upsample();
    WEBGL_OP_RESOLVE_RULES = [
      ["Abs", "", "6+", abs],
      ["Acos", "", "7+", acos],
      ["Add", "", "7+", add2],
      ["And", "", "7+", and2],
      ["Asin", "", "7+", asin],
      ["Atan", "", "7+", atan],
      // TODO: support new attributes for AveragePool-10
      ["AveragePool", "", "7+", averagePool, parseAveragePoolAttributes],
      ["BatchNormalization", "", "7+", batchNormalization, parseBatchNormalizationAttributes],
      ["Cast", "", "6+", cast, parseCastAttributes],
      ["Ceil", "", "6+", ceil],
      ["Clip", "", "6-10", clip, parseClipAttributes],
      ["Clip", "", "11+", clipV11],
      ["Concat", "", "4+", concat, parseConcatAttributes],
      ["Conv", "", "1+", conv, parseConvAttributes],
      ["ConvTranspose", "", "1+", convTranspose, parseConvTransposeAttributes],
      ["Cos", "", "7+", cos],
      ["Div", "", "7+", div],
      ["Dropout", "", "7+", identity],
      ["DepthToSpace", "", "1+", depthToSpace, parseDepthToSpaceAttributes],
      ["Equal", "", "7+", equal],
      ["Elu", "", "6+", elu, parseEluAttributes],
      ["Exp", "", "6+", exp],
      ["Flatten", "", "1+", flatten, parseFlattenAttributes],
      ["Floor", "", "6+", floor],
      ["FusedConv", "com.microsoft", "1+", conv, parseConvAttributes],
      ["Gather", "", "1+", gather, parseGatherAttributes],
      ["Gemm", "", "7-10", gemm, parseGemmAttributesV7],
      ["Gemm", "", "11+", gemm, parseGemmAttributesV11],
      ["GlobalAveragePool", "", "1+", globalAveragePool, parseGlobalAveragePoolAttributes],
      ["GlobalMaxPool", "", "1+", globalMaxPool],
      ["Greater", "", "7+", greater],
      ["Identity", "", "1+", identity],
      ["ImageScaler", "", "1+", imageScaler, parseImageScalerAttributes],
      ["InstanceNormalization", "", "6+", instanceNormalization, parseInstanceNormalizationAttributes],
      ["LeakyRelu", "", "6+", leakyRelu, parseLeakyReluAttributes],
      ["Less", "", "7+", less],
      ["LRN", "", "1+", lrn, parseLrnAttributes],
      ["Log", "", "6+", log2],
      ["MatMul", "", "1+", matMul, parseMatMulAttributes],
      // TODO: support new attributes for MaxPool-8 and MaxPool-10
      ["MaxPool", "", "1+", maxPool, parseMaxPoolAttributes],
      ["Mul", "", "7+", mul],
      ["Neg", "", "6+", neg],
      ["Not", "", "1+", not2],
      ["Or", "", "7+", or2],
      ["Pad", "", "2-10", padV2, parsePadAttributesV2],
      ["Pad", "", "11+", padV11, parsePadAttributesV11],
      ["Pow", "", "7+", pow],
      ["PRelu", "", "7+", pRelu],
      ["ReduceLogSum", "", "1+", reduceLogSum, parseReduceAttributes],
      ["ReduceMax", "", "1+", reduceMax, parseReduceAttributes],
      ["ReduceMean", "", "1+", reduceMean, parseReduceAttributes],
      ["ReduceMin", "", "1+", reduceMin, parseReduceAttributes],
      ["ReduceProd", "", "1+", reduceProd, parseReduceAttributes],
      ["ReduceSum", "", "1-12", reduceSum, parseReduceAttributes],
      ["ReduceSumSquare", "", "1+", reduceLogSumSquare, parseReduceAttributes],
      ["Relu", "", "6+", relu],
      ["Reshape", "", "5+", reshape],
      ["Resize", "", "10", resize, parseResizeAttributesV10],
      ["Resize", "", "11+", resize, parseResizeAttributesV11],
      ["Shape", "", "1+", shape],
      ["Sigmoid", "", "6+", sigmoid],
      ["Sin", "", "7+", sin],
      ["Slice", "", "10+", sliceV10],
      // TODO: support 'steps' for Slice-10
      ["Slice", "", "1-9", slice, parseSliceAttributes],
      // The "semantic" meaning of axis has changed in opset-13.
      ["Softmax", "", "1-12", softmax, parseSoftmaxAttributes],
      ["Softmax", "", "13+", softmaxV13, parseSoftmaxAttributesV13],
      // 'Split' operator has an optional attribute 'split'
      // this attribute determines how the specified axis of input data is split.
      // When the attribute is missing, we need the count of number of outputs
      // so that we can determine the 'split' attribute from the runtime input to the Operator
      ["Split", "", "2-12", split, parseSplitAttributes],
      ["Sqrt", "", "6+", sqrt],
      ["Squeeze", "", "1-12", squeeze, parseSqueezeAttributes],
      ["Squeeze", "", "13+", squeezeV13],
      ["Sub", "", "7+", sub],
      ["Sum", "", "6+", sum],
      ["Tan", "", "7+", tan],
      ["Tanh", "", "6+", tanh],
      ["Tile", "", "6+", tile],
      ["Transpose", "", "1+", transpose, parseTransposeAttributes],
      ["Upsample", "", "7-8", upsample, parseUpsampleAttributesV7],
      ["Upsample", "", "9", upsample, parseUpsampleAttributesV9],
      ["Unsqueeze", "", "1-12", unsqueeze, parseUnsqueezeAttributes],
      ["Unsqueeze", "", "13+", unsqueezeV13],
      ["Xor", "", "7+", xor2]
    ];
  }
});

// web/lib/onnxjs/backends/webgl/glsl-function-inliner.ts
function replaceInlines(script) {
  const inlineDefs = {};
  let match;
  while ((match = INLINE_FUNC_DEF_REGEX.exec(script)) !== null) {
    const params = match[3].split(",").map((s) => {
      const tokens = s.trim().split(" ");
      if (tokens && tokens.length === 2) {
        return { type: tokens[0], name: tokens[1] };
      }
      return null;
    }).filter((v) => v !== null);
    inlineDefs[match[2]] = { params, body: match[4] };
  }
  for (const name2 in inlineDefs) {
    const regexString = FUNC_CALL_REGEX.replace("__FUNC__", name2);
    const regex = new RegExp(regexString, "gm");
    while ((match = regex.exec(script)) !== null) {
      const type = match[1];
      const variable = match[2];
      const params = match[3].split(",");
      const declLine = type ? `${type} ${variable};` : "";
      let newBody = inlineDefs[name2].body;
      let paramRedecLine = "";
      inlineDefs[name2].params.forEach((v, i) => {
        if (v) {
          paramRedecLine += `${v.type} ${v.name} = ${params[i]};
`;
        }
      });
      newBody = `${paramRedecLine}
 ${newBody}`;
      newBody = newBody.replace("return", `${variable} = `);
      const replacement = `
      ${declLine}
      {
        ${newBody}
      }
      `;
      script = script.replace(match[0], replacement);
    }
  }
  script = script.replace(INLINE_FUNC_DEF_REGEX, "");
  return script;
}
var INLINE_FUNC_DEF_REGEX, FUNC_CALL_REGEX;
var init_glsl_function_inliner = __esm({
  "web/lib/onnxjs/backends/webgl/glsl-function-inliner.ts"() {
    "use strict";
    INLINE_FUNC_DEF_REGEX = /@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;
    FUNC_CALL_REGEX = "(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;";
  }
});

// web/lib/onnxjs/backends/webgl/texture-layout-strategy.ts
function squeezeShape(shape2, axis) {
  const newShape = [];
  const keptDims = [];
  const isEmptyArray = axis != null && Array.isArray(axis) && axis.length === 0;
  const axes = axis == null || isEmptyArray ? null : parseAxisParam(axis, shape2).sort();
  let j = 0;
  for (let i = 0; i < shape2.length; ++i) {
    if (axes != null) {
      if (axes[j] === i && shape2[i] !== 1) {
        throw new Error(`Can't squeeze axis ${i} since its dim '${shape2[i]}' is not 1`);
      }
      if ((axes[j] == null || axes[j] > i) && shape2[i] === 1) {
        newShape.push(shape2[i]);
        keptDims.push(i);
      }
      if (axes[j] <= i) {
        j++;
      }
    }
    if (shape2[i] !== 1) {
      newShape.push(shape2[i]);
      keptDims.push(i);
    }
  }
  return { newShape, keptDims };
}
function parseAxisParam(axis, shape2) {
  const rank = shape2.length;
  axis = axis == null ? shape2.map((_s, i) => i) : [].concat(axis);
  assert(
    axis.every((ax) => ax >= -rank && ax < rank),
    () => `All values in axis param must be in range [-${rank}, ${rank}) but got axis ${axis}`
  );
  assert(
    axis.every(isInt),
    () => `All values in axis param must be integers but got axis ${axis}`
  );
  return axis.map((a) => a < 0 ? rank + a : a);
}
function isInt(a) {
  return a % 1 === 0;
}
function sizeFromShape(shape2) {
  if (shape2.length === 0) {
    return 1;
  }
  let size = shape2[0];
  for (let i = 1; i < shape2.length; i++) {
    size *= shape2[i];
  }
  return size;
}
function sizeToSquarishShape(size) {
  const width = Math.ceil(Math.sqrt(size));
  return [width, Math.ceil(size / width)];
}
var PreferLogicalStrategy;
var init_texture_layout_strategy = __esm({
  "web/lib/onnxjs/backends/webgl/texture-layout-strategy.ts"() {
    "use strict";
    init_instrument();
    init_util();
    PreferLogicalStrategy = class {
      constructor(maxTextureSize) {
        this.maxTextureSize = maxTextureSize;
      }
      computeTextureWH(shape2, prefs) {
        const wh = this.computeTexture(shape2, prefs);
        if (prefs && prefs.isPacked) {
          wh[0] /= 2;
          wh[1] /= 2;
        }
        if (prefs && prefs.reverseWH) {
          return [wh[1], wh[0]];
        }
        return wh;
      }
      computeTexture(shape2, prefs) {
        const isPacked = prefs && prefs.isPacked;
        if (shape2.length === 0) {
          return isPacked ? [2, 2] : [1, 1];
        }
        let maxTextureSize = this.maxTextureSize;
        if (prefs && prefs.breakAxis !== void 0) {
          const wsize = prefs.breakAxis >= shape2.length ? 1 : shape2.slice(prefs.breakAxis).reduce((a, b) => a * b);
          const hsize = prefs.breakAxis <= 0 ? 1 : shape2.slice(0, prefs.breakAxis).reduce((a, b) => a * b);
          if (wsize > maxTextureSize || hsize > maxTextureSize) {
            Logger.verbose(
              "TextureLayout",
              `Given width/height preferences were unattainable: shape:${shape2}, breakAxis:${prefs.breakAxis}`
            );
          } else {
            return [wsize, hsize];
          }
        }
        let logShape = shape2.slice(0);
        if (isPacked) {
          maxTextureSize = maxTextureSize * 2;
          logShape = logShape.map(
            (_d, i) => i >= logShape.length - 2 ? logShape[i] % 2 === 0 ? logShape[i] : logShape[i] + 1 : logShape[i]
          );
          if (logShape.length === 1) {
            logShape = [2, logShape[0]];
          }
        }
        if (logShape.length !== 2) {
          const squeezeResult = squeezeShape(logShape);
          logShape = squeezeResult.newShape;
        }
        const size = sizeFromShape(logShape);
        if (logShape.length <= 1 && size <= maxTextureSize) {
          return [1, size];
        } else if (logShape.length === 2 && logShape[0] <= maxTextureSize && logShape[1] <= maxTextureSize) {
          return logShape;
        } else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTextureSize && logShape[2] <= maxTextureSize) {
          return [logShape[0] * logShape[1], logShape[2]];
        } else if (logShape.length === 3 && logShape[0] <= maxTextureSize && logShape[1] * logShape[2] <= maxTextureSize) {
          return [logShape[0], logShape[1] * logShape[2]];
        } else if (logShape.length === 4 && logShape[0] * logShape[1] * logShape[2] <= maxTextureSize && logShape[3] <= maxTextureSize) {
          return [logShape[0] * logShape[1] * logShape[2], logShape[3]];
        } else if (logShape.length === 4 && logShape[0] <= maxTextureSize && logShape[1] * logShape[2] * logShape[3] <= maxTextureSize) {
          return [logShape[0], logShape[1] * logShape[2] * logShape[3]];
        } else {
          if (isPacked) {
            return sizeToSquarishShape(size / 4).map((d) => d * 2);
          }
          return sizeToSquarishShape(size);
        }
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/glsl-coordinate-lib.ts
var CoordsGlslLib;
var init_glsl_coordinate_lib = __esm({
  "web/lib/onnxjs/backends/webgl/glsl-coordinate-lib.ts"() {
    "use strict";
    init_util();
    init_glsl_definitions();
    init_glsl_source();
    init_texture_layout_strategy();
    init_utils();
    CoordsGlslLib = class extends GlslLib {
      constructor(context) {
        super(context);
      }
      getFunctions() {
        return {
          ...this.offsetToCoords(),
          ...this.coordsToOffset(),
          ...this.toVec(),
          ...this.valueFrom(),
          // TODO return these only when packing is enabled.
          ...this.getCommonUtilFuncs(),
          ...this.getInputsSamplingSnippets(),
          ...this.getOutputSamplingSnippet()
        };
      }
      getCustomTypes() {
        return {};
      }
      /**
       * Produces a function that can map from
       * 2D normalzied coordinates (s,t) to a flat offset
       */
      offsetToCoords() {
        const funcName = "offsetToCoords";
        return {
          offsetToCoords: new GlslLibRoutine(`
      vec2 ${funcName}(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)
        };
      }
      /**
       * Produces a function that can map from
       * 2D normalzied coordinates (s,t) to a flat offset
       */
      coordsToOffset() {
        const funcName = "coordsToOffset";
        return {
          coordsToOffset: new GlslLibRoutine(`
      int ${funcName}(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)
        };
      }
      /**
       * Generates code for output sampler.
       */
      getOutputSamplingSnippet() {
        const outputLayout = this.context.outputTextureLayout;
        if (outputLayout.isPacked) {
          return this.getPackedOutputSamplingSnippet(outputLayout);
        } else {
          return this.getUnpackedOutputSamplingSnippet(outputLayout);
        }
      }
      /**
       * Generates code for packed output sampler.
       */
      getPackedOutputSamplingSnippet(outputLayout) {
        const outShape = outputLayout.unpackedShape;
        const outTexShape = [outputLayout.width, outputLayout.height];
        const result = {};
        const funcName = "getOutputCoords";
        switch (outShape.length) {
          case 0:
            result[funcName] = this.getOutputScalarCoords();
            break;
          case 1:
            result[funcName] = this.getOutputPacked1DCoords(outShape, outTexShape);
            break;
          case 2:
            result[funcName] = this.getOutputPacked2DCoords(outShape, outTexShape);
            break;
          case 3:
            result[funcName] = this.getOutputPacked3DCoords(outShape, outTexShape);
            break;
          default:
            result[funcName] = this.getOutputPackedNDCoords(outShape, outTexShape);
        }
        const glsl = getGlsl(this.context.glContext.version);
        const floatTextureSetRGBASource = `
      void setOutput(vec4 val) {
        ${glsl.output} = val;
      }
    `;
        const floatTextureSetRGBAFuncName = "floatTextureSetRGBA";
        result[floatTextureSetRGBAFuncName] = new GlslLibRoutine(floatTextureSetRGBASource);
        return result;
      }
      /**
       * Generates code for unpacked output sampler.
       */
      getUnpackedOutputSamplingSnippet(outputLayout) {
        const outShape = outputLayout.unpackedShape;
        const outTexShape = [outputLayout.width, outputLayout.height];
        const result = {};
        const funcName = "getOutputCoords";
        switch (outShape.length) {
          case 0:
            result[funcName] = this.getOutputScalarCoords();
            break;
          case 1:
            result[funcName] = this.getOutputUnpacked1DCoords(outShape, outTexShape);
            break;
          case 2:
            result[funcName] = this.getOutputUnpacked2DCoords(outShape, outTexShape);
            break;
          case 3:
            result[funcName] = this.getOutputUnpacked3DCoords(outShape, outTexShape);
            break;
          case 4:
            result[funcName] = this.getOutputUnpacked4DCoords(
              outShape,
              outTexShape
            );
            break;
          case 5:
            result[funcName] = this.getOutputUnpacked5DCoords(
              outShape,
              outTexShape
            );
            break;
          case 6:
            result[funcName] = this.getOutputUnpacked6DCoords(
              outShape,
              outTexShape
            );
            break;
          default:
            throw new Error(`Unsupported output dimensionality: ${outShape.length}`);
        }
        const glsl = getGlsl(this.context.glContext.version);
        const floatTextureSetRSource = `
        void setOutput(float val) {
          ${glsl.output} = vec4(val, 0, 0, 0);
        }
    `;
        const floatTextureSetRFuncName = "floatTextureSetR";
        result[floatTextureSetRFuncName] = new GlslLibRoutine(floatTextureSetRSource);
        return result;
      }
      /**
       * Scalar output coordinates.
       */
      getOutputScalarCoords() {
        return new GlslLibRoutine(`
      int getOutputCoords() {
        return 0;
      }
    `);
      }
      /**
       * 1D packed output coordinates.
       */
      getOutputPacked1DCoords(_shape, texShape) {
        const packedTexShape = texShape;
        let source = "";
        if (packedTexShape[0] === 1) {
          source = `
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${packedTexShape[1]}.0);
          }
        `;
          return new GlslLibRoutine(source);
        }
        if (packedTexShape[1] === 1) {
          source = `
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${packedTexShape[0]}.0);
          }
        `;
          return new GlslLibRoutine(source);
        }
        source = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
          return 2 * (resTexRC.y * ${packedTexShape[0]} + resTexRC.x);
        }
      `;
        return new GlslLibRoutine(source);
      }
      /**
       * 2D packed output coordinates.
       */
      getOutputPacked2DCoords(shape2, texShape) {
        let source = "";
        if (ArrayUtil.arraysEqual(shape2, texShape)) {
          source = `
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${texShape[0]}, ${texShape[1]}));
        }
      `;
          return new GlslLibRoutine(source);
        }
        const packedTexShape = texShape;
        const texelsInLogicalRow = Math.ceil(shape2[1] / 2);
        source = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${packedTexShape[0]}, ${packedTexShape[1]}));

          int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${texelsInLogicalRow}) * 2;
          int c = 2 * (index / ${texelsInLogicalRow});

          return ivec2(r, c);
        }
      `;
        return new GlslLibRoutine(source);
      }
      /**
       * 3D packed output coordinates.
       */
      getOutputPacked3DCoords(shape2, texShape) {
        const packedTexShape = [texShape[0], texShape[1]];
        const texelsInLogicalRow = Math.ceil(shape2[2] / 2);
        const texelsInBatch = texelsInLogicalRow * Math.ceil(shape2[1] / 2);
        const source = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
          int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;

          int b = index / ${texelsInBatch};
          index -= b * ${texelsInBatch};

          // reverse r and c order for packed texture
          int r = imod(index, ${texelsInLogicalRow}) * 2;
          int c = 2 * (index / ${texelsInLogicalRow});

          return ivec3(b, r, c);
        }
      `;
        return new GlslLibRoutine(source);
      }
      /**
       * ND packed output coordinates.
       */
      getOutputPackedNDCoords(shape2, texShape) {
        const packedTexShape = [texShape[0], texShape[1]];
        const texelsInLogicalRow = Math.ceil(shape2[shape2.length - 1] / 2);
        const texelsInBatch = texelsInLogicalRow * Math.ceil(shape2[shape2.length - 2] / 2);
        let texelsInBatchN = texelsInBatch;
        let batches = "";
        let coords = "b, r, c";
        for (let b = 2; b < shape2.length - 1; b++) {
          texelsInBatchN *= shape2[shape2.length - b - 1];
          batches = `
      int b${b} = index / ${texelsInBatchN};
      index -= b${b} * ${texelsInBatchN};
    ` + batches;
          coords = `b${b}, ` + coords;
        }
        const source = `
      ivec${shape2.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${packedTexShape[0]}, ${packedTexShape[1]}));
        int index = resTexRC.y * ${packedTexShape[0]} + resTexRC.x;

        ${batches}

        int b = index / ${texelsInBatch};
        index -= b * ${texelsInBatch};

        // reverse r and c order for packed texture
        int r = imod(index, ${texelsInLogicalRow}) * 2;
        int c = 2 * (index / ${texelsInLogicalRow});

        return ivec${shape2.length}(${coords});
      }
    `;
        return new GlslLibRoutine(source);
      }
      /**
       * Unpacked 1D output coordinates.
       */
      getOutputUnpacked1DCoords(_shape, texShape) {
        const source = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${texShape[0]}, ${texShape[1]}));
          return resTexRC.y * ${texShape[0]} + resTexRC.x;
        }
      `;
        return new GlslLibRoutine(source);
      }
      /**
       * Unpacked 2D output coordinates.
       */
      getOutputUnpacked2DCoords(shape2, texShape) {
        const source = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${texShape[0]}, ${texShape[1]}));
          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;
          int r = index / ${shape2[1]};
          int c = index - r * ${shape2[1]};
          return ivec2(r, c);
        }
      `;
        return new GlslLibRoutine(source);
      }
      /**
       * Unpacked 3D output coordinates.
       */
      getOutputUnpacked3DCoords(shape2, texShape) {
        let source = "";
        const rank = shape2.length;
        let strides = null;
        if (rank < 2) {
          strides = [];
        }
        strides = new Array(rank - 1);
        strides[rank - 2] = shape2[rank - 1];
        for (let i = rank - 3; i >= 0; --i) {
          strides[i] = strides[i + 1] * shape2[i + 1];
        }
        const coordsToCompute = ["r", "c", "d"];
        const coordsFromIndexSnippet = strides.map((stride, i) => {
          const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;
          const line2 = i === strides.length - 1 ? `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` : `index -= ${coordsToCompute[i]} * ${stride}`;
          return `${line1}; ${line2};`;
        }).join("");
        source = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${texShape[0]}, ${texShape[1]}));
          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;
          ${coordsFromIndexSnippet}
          return ivec3(r, c, d);
        }
      `;
        return new GlslLibRoutine(source);
      }
      /**
       * Unpacked 4D output coordinates.
       */
      getOutputUnpacked4DCoords(shape2, texShape) {
        let source = "";
        const rank = shape2.length;
        let strides = null;
        if (rank < 2) {
          strides = [];
        }
        strides = new Array(rank - 1);
        strides[rank - 2] = shape2[rank - 1];
        for (let i = rank - 3; i >= 0; --i) {
          strides[i] = strides[i + 1] * shape2[i + 1];
        }
        const coordsToCompute = ["r", "c", "d", "d2"];
        const coordsFromIndexSnippet = strides.map((stride, i) => {
          const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;
          const line2 = i === strides.length - 1 ? `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` : `index -= ${coordsToCompute[i]} * ${stride}`;
          return `${line1}; ${line2};`;
        }).join("");
        source = `
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${texShape[0]}, ${texShape[1]}));
          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;
          ${coordsFromIndexSnippet}
          return ivec4(r, c, d, d2);
        }
      `;
        return new GlslLibRoutine(source);
      }
      /**
       * Unpacked 5D output coordinates.
       */
      getOutputUnpacked5DCoords(shape2, texShape) {
        let source = "";
        const rank = shape2.length;
        let strides = null;
        if (rank < 2) {
          strides = [];
        }
        strides = new Array(rank - 1);
        strides[rank - 2] = shape2[rank - 1];
        for (let i = rank - 3; i >= 0; --i) {
          strides[i] = strides[i + 1] * shape2[i + 1];
        }
        const coordsToCompute = ["r", "c", "d", "d2", "d3"];
        const coordsFromIndexSnippet = strides.map((stride, i) => {
          const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;
          const line2 = i === strides.length - 1 ? `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` : `index -= ${coordsToCompute[i]} * ${stride}`;
          return `${line1}; ${line2};`;
        }).join("");
        source = `
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${texShape[0]}, ${texShape[1]}));
          int index = resTexRC.y * ${texShape[0]} + resTexRC.x;
          ${coordsFromIndexSnippet}
          return ivec5(r, c, d, d2, d3);
        }
      `;
        return new GlslLibRoutine(source);
      }
      /**
       * Unpacked 6D output coordinates.
       */
      getOutputUnpacked6DCoords(shape2, texShape) {
        let source = "";
        const rank = shape2.length;
        let strides = null;
        if (rank < 2) {
          strides = [];
        }
        strides = new Array(rank - 1);
        strides[rank - 2] = shape2[rank - 1];
        for (let i = rank - 3; i >= 0; --i) {
          strides[i] = strides[i + 1] * shape2[i + 1];
        }
        const coordsToCompute = ["r", "c", "d", "d2", "d3", "d4"];
        const coordsFromIndexSnippet = strides.map((stride, i) => {
          const line1 = `int ${coordsToCompute[i]} = index / ${stride}`;
          const line2 = i === strides.length - 1 ? `int ${coordsToCompute[i + 1]} = index - ${coordsToCompute[i]} * ${stride}` : `index -= ${coordsToCompute[i]} * ${stride}`;
          return `${line1}; ${line2};`;
        }).join("");
        source = `
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${texShape[0]}, ${texShape[1]}));
         int index = resTexRC.y * ${texShape[0]} + resTexRC.x;
         ${coordsFromIndexSnippet}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `;
        return new GlslLibRoutine(source);
      }
      /**
       * Generates code for common UV coords computation utility functions.
       */
      getCommonUtilFuncs() {
        const result = {};
        let funcName = "uvFromFlat";
        result[funcName] = new GlslLibRoutine(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `);
        funcName = "packedUVfrom1D";
        result[funcName] = new GlslLibRoutine(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `);
        funcName = "packedUVfrom2D";
        result[funcName] = new GlslLibRoutine(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `);
        funcName = "packedUVfrom3D";
        result[funcName] = new GlslLibRoutine(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `);
        funcName = "sampleTexture";
        const glsl = getGlsl(this.context.glContext.version);
        result[funcName] = new GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${glsl.texture2D}(textureSampler, uv).r;
        }`);
        return result;
      }
      /**
       * Constructing snippets for inputs
       */
      getInputsSamplingSnippets() {
        const result = {};
        const outputLayout = this.context.outputTextureLayout;
        this.context.programInfo.inputNames.forEach((samplerName, i) => {
          const inputLayout = this.context.inputTextureLayouts[i];
          const funcName = generateShaderFuncNameFromInputSamplerName(samplerName);
          if (inputLayout.isPacked) {
            result[funcName] = this.getPackedSamplerFromInput(funcName, samplerName, inputLayout);
          } else {
            result[funcName] = this.getUnpackedSamplerFromInput(funcName, samplerName, inputLayout);
          }
          const outCoordFuncName = generateShaderFuncNameFromInputSamplerNameAtOutCoords(samplerName);
          if (inputLayout.unpackedShape.length <= outputLayout.unpackedShape.length) {
            if (inputLayout.isPacked) {
              result[outCoordFuncName] = this.getPackedSamplerAtOutputCoords(outCoordFuncName, inputLayout, outputLayout, samplerName);
            } else {
              result[outCoordFuncName] = this.getUnpackedSamplerAtOutputCoords(outCoordFuncName, inputLayout, outputLayout, samplerName);
            }
          }
        });
        return result;
      }
      /**
       * Constructing snippets for output coordinates of samplers
       */
      getPackedSamplerAtOutputCoords(funcName, inputLayout, outputLayout, name2) {
        const inShape = inputLayout.unpackedShape;
        const outShape = outputLayout.unpackedShape;
        const texName = name2;
        const texFuncSnippet = generateShaderFuncNameFromInputSamplerName(texName);
        const inRank = inShape.length;
        const outRank = outShape.length;
        const broadcastDims = BroadcastUtil.getBroadcastDims(inShape, outShape);
        const type = getCoordsDataType(outRank);
        const rankDiff = outRank - inRank;
        let coordsSnippet;
        const fields = getGlChannels();
        if (inRank === 0) {
          coordsSnippet = "";
        } else if (outRank < 2 && broadcastDims.length >= 1) {
          coordsSnippet = "coords = 0;";
        } else {
          coordsSnippet = broadcastDims.map((d) => `coords.${fields[d + rankDiff]} = 0;`).join("\n");
        }
        let unpackedCoordsSnippet = "";
        if (outRank < 2 && inRank > 0) {
          unpackedCoordsSnippet = "coords";
        } else {
          unpackedCoordsSnippet = inShape.map((_s, i) => `coords.${fields[i + rankDiff]}`).join(", ");
        }
        let output = "return outputValue;";
        const inSize = ShapeUtil.size(inShape);
        const isInputScalar = inSize === 1;
        const outSize = ShapeUtil.size(outShape);
        const isOutputScalar = outSize === 1;
        if (inRank === 1 && !isInputScalar && !isOutputScalar) {
          output = `
        return vec4(outputValue.xy, outputValue.xy);
      `;
        } else if (isInputScalar && !isOutputScalar) {
          if (outRank === 1) {
            output = `
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `;
          } else {
            output = `
          return vec4(outputValue.x);
        `;
          }
        } else if (broadcastDims.length) {
          const rows = inRank - 2;
          const cols = inRank - 1;
          if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) {
            output = "return vec4(outputValue.x);";
          } else if (broadcastDims.indexOf(rows) > -1) {
            output = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);";
          } else if (broadcastDims.indexOf(cols) > -1) {
            output = "return vec4(outputValue.xx, outputValue.zz);";
          }
        }
        const swapLastDimsSnippet = `
        int lastDim = coords.${fields[outRank - 1]};
        coords.${fields[outRank - 1]} = coords.${fields[outRank - 2]};
        coords.${fields[outRank - 2]} = lastDim;
      `;
        const source = `
      vec4 ${funcName}() {
        ${type} coords = getOutputCoords();
        ${swapLastDimsSnippet}
        ${coordsSnippet}
        vec4 outputValue = ${texFuncSnippet}(${unpackedCoordsSnippet});
        ${output}
      }
    `;
        return new GlslLibRoutine(source, ["coordinates.getOutputCoords"]);
      }
      /**
       * Constructing snippets for unpacked output coordinates of samplers
       */
      getUnpackedSamplerAtOutputCoords(funcName, inputLayout, outputLayout, name2) {
        const outTexShape = [outputLayout.width, outputLayout.height];
        const inTexShape = [inputLayout.width, inputLayout.height];
        const inRank = inputLayout.unpackedShape.length;
        const outRank = outputLayout.unpackedShape.length;
        const inShape = inputLayout.unpackedShape;
        const outShape = outputLayout.unpackedShape;
        const texFuncSnippet = generateShaderFuncNameFromInputSamplerName(name2);
        if (inRank === outRank && ArrayUtil.arraysEqual(inTexShape, outTexShape)) {
          const source2 = `
          float ${funcName}() {
            return sampleTexture(${name2}, TexCoords);
          }
        `;
          return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
        }
        const type = getCoordsDataType(outRank);
        const broadcastDims = BroadcastUtil.getBroadcastDims(inShape, outShape);
        const rankDiff = outRank - inRank;
        let coordsSnippet;
        const fields = getGlChannels();
        if (inRank === 0) {
          coordsSnippet = "";
        } else if (outRank < 2 && broadcastDims.length >= 1) {
          coordsSnippet = "coords = 0;";
        } else {
          coordsSnippet = broadcastDims.map((d) => `coords.${fields[d + rankDiff]} = 0;`).join("\n");
        }
        let unpackedCoordsSnippet = "";
        if (outRank < 2 && inRank > 0) {
          unpackedCoordsSnippet = "coords";
        } else {
          unpackedCoordsSnippet = inputLayout.unpackedShape.map((_s, i) => `coords.${fields[i + rankDiff]}`).join(", ");
        }
        const source = `
        float ${funcName}() {
          ${type} coords = getOutputCoords();
          ${coordsSnippet}
          return ${texFuncSnippet}(${unpackedCoordsSnippet});
        }
      `;
        return new GlslLibRoutine(source, ["coordinates.getOutputCoords"]);
      }
      /**
       * Constructing snippets for packed operations.
       */
      getPackedSamplerFromInput(funcName, name2, inputLayout) {
        switch (inputLayout.unpackedShape.length) {
          case 0:
            return this.getPackedSamplerScalar(funcName, name2);
          case 1:
            return this.getPackedSampler1D(funcName, name2, inputLayout);
          case 2:
            return this.getPackedSampler2D(funcName, name2, inputLayout);
          case 3:
            return this.getPackedSampler3D(funcName, name2, inputLayout);
          default:
            return this.getPackedSamplerND(funcName, name2, inputLayout);
        }
      }
      /**
       * Constructing snippets for unpacked operations.
       */
      getUnpackedSamplerFromInput(funcName, name2, inputLayout) {
        const shape2 = inputLayout.unpackedShape;
        switch (shape2.length) {
          case 0:
            return this.getUnpackedSamplerScalar(funcName, name2, inputLayout);
          case 1:
            return this.getUnpackedSampler1D(funcName, name2, inputLayout);
          case 2:
            return this.getUnpackedSampler2D(funcName, name2, inputLayout);
          case 3:
            return this.getUnpackedSampler3D(funcName, name2, inputLayout);
          case 4:
            return this.getUnpackedSampler4D(funcName, name2, inputLayout);
          case 5:
            return this.getUnpackedSampler5D(funcName, name2, inputLayout);
          case 6:
            return this.getUnpackedSampler6D(funcName, name2, inputLayout);
          default:
            throw new Error(`Unsupported dimension ${shape2.length}-D`);
        }
      }
      /**
       * Packed scalar snippet.
       */
      getPackedSamplerScalar(funcName, name2) {
        const glsl = getGlsl(this.context.glContext.version);
        const source = `
          vec4 ${funcName}() {
            return ${glsl.texture2D}(${name2}, halfCR);
          }
        `;
        return new GlslLibRoutine(source);
      }
      /**
       * Packed 1D snippet.
       */
      getPackedSampler1D(funcName, name2, inputLayout) {
        const texShape = [inputLayout.width, inputLayout.height];
        const packedTexShape = [texShape[1], texShape[0]];
        const glsl = getGlsl(this.context.glContext.version);
        const packedSampler = `vec4 ${funcName}(int index) {
      vec2 uv = packedUVfrom1D(
      ${packedTexShape[0]}, ${packedTexShape[1]}, index);
      return ${glsl.texture2D}(${name2}, uv);
    }`;
        const source = packedSampler;
        return new GlslLibRoutine(source, ["coordinates.packedUVfrom1D"]);
      }
      /**
       * Packed 2D snippet.
       */
      getPackedSampler2D(funcName, name2, inputLayout) {
        const shape2 = inputLayout.unpackedShape;
        const texShape = [inputLayout.width, inputLayout.height];
        const glsl = getGlsl(this.context.glContext.version);
        const texNumR = texShape[0];
        const texNumC = texShape[1];
        if (texShape != null && ArrayUtil.arraysEqual(shape2, texShape)) {
          const packedSampler2 = `vec4 ${funcName}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);
        return ${glsl.texture2D}(${name2}, uv);
      }`;
          return new GlslLibRoutine(packedSampler2);
        }
        const packedTexShape = texShape;
        const valuesPerRow = Math.ceil(shape2[1] / 2);
        const packedSampler = `vec4 ${funcName}(int row, int col) {
      vec2 uv = packedUVfrom2D(${packedTexShape[1]}, ${packedTexShape[0]}, ${valuesPerRow}, row, col);
      return ${glsl.texture2D}(${name2}, uv);
    }`;
        const source = packedSampler;
        return new GlslLibRoutine(source, ["coordinates.packedUVfrom2D"]);
      }
      /**
       * Packed 3D snippet.
       */
      getPackedSampler3D(funcName, name2, inputLayout) {
        const shape2 = inputLayout.unpackedShape;
        const texShape = [inputLayout.width, inputLayout.height];
        const packedTexShape = [texShape[0], texShape[1]];
        const glsl = getGlsl(this.context.glContext.version);
        if (shape2[0] === 1) {
          const squeezedShape = shape2.slice(1);
          const keptDims = [1, 2];
          const newInputShape = squeezeInputShape(shape2, squeezedShape);
          const params = ["b", "row", "col"];
          const newInputLayout = JSON.parse(JSON.stringify(inputLayout));
          newInputLayout.unpackedShape = newInputShape;
          const samplerRoutine = this.getPackedSamplerFromInput(funcName, name2, newInputLayout);
          const packedSampler2 = `${samplerRoutine.routineBody}
      vec4 ${funcName}(int b, int row, int col) {
        return ${funcName}(${getSqueezedParams(params, keptDims)});
      } `;
          const source2 = packedSampler2;
          return new GlslLibRoutine(source2, samplerRoutine.dependencies);
        }
        const texNumR = packedTexShape[0];
        const texNumC = packedTexShape[1];
        const valuesPerRow = Math.ceil(shape2[2] / 2);
        const texelsInBatch = valuesPerRow * Math.ceil(shape2[1] / 2);
        const packedSampler = `vec4 ${funcName}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${texNumC}, ${texNumR}, ${texelsInBatch}, ${valuesPerRow}, b, row, col);
      return ${glsl.texture2D}(${name2}, uv);}`;
        const source = packedSampler;
        return new GlslLibRoutine(source, ["coordinates.packedUVfrom3D"]);
      }
      /*
       * Packed ND snippet.
       */
      getPackedSamplerND(funcName, name2, inputLayout) {
        const shape2 = inputLayout.unpackedShape;
        const rank = shape2.length;
        const texShape = [inputLayout.width, inputLayout.height];
        const glsl = getGlsl(this.context.glContext.version);
        const packedTexShape = [texShape[0], texShape[1]];
        const texNumR = packedTexShape[1];
        const texNumC = packedTexShape[0];
        const valuesPerRow = Math.ceil(shape2[rank - 1] / 2);
        let texelsInBatch = valuesPerRow * Math.ceil(shape2[rank - 2] / 2);
        let params = "int b, int row, int col";
        let index = `b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;
        for (let b = 2; b < rank - 1; b++) {
          params = `int b${b}, ` + params;
          texelsInBatch *= shape2[rank - b - 1];
          index = `b${b} * ${texelsInBatch} + ` + index;
        }
        const packedSampler = `vec4 ${funcName}(${params}) {
      int index = ${index};
      int texR = index / ${texNumC};
      int texC = index - texR * ${texNumC};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});
      return ${glsl.texture2D}(${name2}, uv);
    }`;
        const source = packedSampler;
        return new GlslLibRoutine(source);
      }
      /**
       * Unpacked scalar snippet.
       */
      getUnpackedSamplerScalar(funcName, name2, inputLayout) {
        const [texNumR, texNumC] = [inputLayout.width, inputLayout.height];
        if (texNumR === 1 && texNumC === 1) {
          const source2 = `
          float ${funcName}() {
            return sampleTexture(${name2}, halfCR);
          }
        `;
          return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
        }
        const source = `
        float ${funcName}() {
          int offset_${name2} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});
          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, offset_${name2});
          return sampleTexture(${name2}, uv);
        }
      `;
        return new GlslLibRoutine(
          source,
          ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]
        );
      }
      /**
       * Unpacked 1D snippet.
       */
      getUnpackedSampler1D(funcName, name2, inputLayout) {
        const tNumR = inputLayout.width;
        const tNumC = inputLayout.height;
        if (tNumC === 1 && tNumR === 1) {
          const source2 = `
        float ${funcName}(int index) {
          return sampleTexture(${name2}, halfCR);
        }
      `;
          return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
        }
        if (tNumC === 1) {
          const source2 = `
          float ${funcName}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${tNumR}.0, 0.5);
            return sampleTexture(${name2}, uv);
          }
        `;
          return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
        }
        if (tNumR === 1) {
          const source2 = `
          float ${funcName}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${tNumC}.0);
            return sampleTexture(${name2}, uv);
          }
        `;
          return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
        }
        const source = `
        float ${funcName}(int index) {
          vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index);
          return sampleTexture(${name2}, uv);
        }
      `;
        return new GlslLibRoutine(source, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
      }
      /**
       * Unpacked 2D snippet.
       */
      getUnpackedSampler2D(funcName, name2, inputLayout) {
        const shape2 = inputLayout.unpackedShape;
        const texShape = [inputLayout.height, inputLayout.width];
        if (texShape != null && ArrayUtil.arraysEqual(shape2, texShape)) {
          const texNumR2 = texShape[1];
          const texNumC2 = texShape[0];
          const source2 = `
          float ${funcName}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${texNumR2}.0, ${texNumC2}.0);
            return sampleTexture(${name2}, uv);
          }
        `;
          return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
        }
        const { newShape, keptDims } = squeezeShape(shape2);
        const squeezedShape = newShape;
        if (squeezedShape.length < shape2.length) {
          const newInputShape = squeezeInputShape(shape2, squeezedShape);
          const newInputLayout = JSON.parse(JSON.stringify(inputLayout));
          newInputLayout.unpackedShape = newInputShape;
          const params = ["col", "row"];
          const source2 = `
          ${this.getUnpackedSamplerFromInput(funcName, name2, newInputLayout).routineBody}
          float ${funcName}(int row, int col) {
            return ${funcName}(${getSqueezedParams(params, keptDims)});
          }
        `;
          return new GlslLibRoutine(source2, ["coordinates.sampleTexture"]);
        }
        const texNumR = texShape[1];
        const texNumC = texShape[0];
        if (texNumC === 1) {
          const source2 = `
          float ${funcName}(int row, int col) {
            int offset_${name2} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});
            float index = dot(vec3(row, col, offset_${name2}), vec3(${shape2[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);
            return sampleTexture(${name2}, uv);
          }
        `;
          return new GlslLibRoutine(source2, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
        }
        if (texNumR === 1) {
          const source2 = `
          float ${funcName}(int row, int col) {
            int offset_${name2} = coordsToOffset(TexCoords, ${texNumR}, ${texNumC});
            float index = dot(vec3(row, col, offset_${name2}), vec3(${shape2[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);
            return sampleTexture(${name2}, uv);
          }
        `;
          return new GlslLibRoutine(source2, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
        }
        const source = `
        float ${funcName}(int row, int col) {
          int index = col * ${shape2[1]} + row;
          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
          return sampleTexture(${name2}, uv);
        }
      `;
        return new GlslLibRoutine(
          source,
          ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]
        );
      }
      /**
       * Unpacked 3D snippet.
       */
      getUnpackedSampler3D(funcName, name2, inputLayout) {
        const shape2 = inputLayout.unpackedShape;
        const stride0 = shape2[1] * shape2[2];
        const stride1 = shape2[2];
        const { newShape, keptDims } = squeezeShape(shape2);
        const squeezedShape = newShape;
        if (squeezedShape.length < shape2.length) {
          const newInputShape = squeezeInputShape(shape2, squeezedShape);
          const params = ["batch", "col", "row"];
          const newInputLayout = JSON.parse(JSON.stringify(inputLayout));
          newInputLayout.unpackedShape = newInputShape;
          const routine = this.getUnpackedSamplerFromInput(funcName, name2, newInputLayout);
          const revDims = keptDims.reverse();
          const source2 = `
          ${routine.routineBody}
          float ${funcName}(int batch, int row, int col) {
            return ${funcName}(${getSqueezedParams(params, revDims)});
          }
        `;
          return new GlslLibRoutine(source2, routine.dependencies);
        }
        const texNumR = inputLayout.width;
        const texNumC = inputLayout.height;
        const source = `
          float ${funcName}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${stride0} + col * ${stride1} + row;
            vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
            return sampleTexture(${name2}, uv);
          }
      `;
        return new GlslLibRoutine(
          source,
          ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]
        );
      }
      /**
       * Unpacked 4D snippet.
       */
      getUnpackedSampler4D(funcName, name2, inputLayout) {
        const shape2 = inputLayout.unpackedShape;
        const stride2 = shape2[3];
        const stride1 = shape2[2] * stride2;
        const stride0 = shape2[1] * stride1;
        const texNumR = inputLayout.width;
        const texNumC = inputLayout.height;
        const source = `
        float ${funcName}(int row, int col, int depth, int depth2) {
          int index = row * ${stride0} + col * ${stride1} +
              depth2 * ${stride2} + depth;
          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
          return sampleTexture(${name2}, uv);
        }
      `;
        return new GlslLibRoutine(source, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
      }
      /**
       * Unpacked 5D snippet.
       */
      getUnpackedSampler5D(funcName, name2, inputLayout) {
        const shape2 = inputLayout.unpackedShape;
        const stride3 = shape2[4];
        const stride2 = shape2[3] * stride3;
        const stride1 = shape2[2] * stride2;
        const stride0 = shape2[1] * stride1;
        const { newShape, keptDims } = squeezeShape(shape2);
        if (newShape.length < shape2.length) {
          const newInputShape = squeezeInputShape(shape2, newShape);
          const params = ["row", "col", "depth", "depth2", "depth3"];
          const newInputLayout = JSON.parse(JSON.stringify(inputLayout));
          newInputLayout.unpackedShape = newInputShape;
          const source2 = `
          ${this.getUnpackedSamplerFromInput(funcName, name2, newInputLayout).routineBody}
          float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
            return ${funcName}(${getSqueezedParams(params, keptDims)});
          }
        `;
          return new GlslLibRoutine(source2, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
        }
        const texNumR = inputLayout.width;
        const texNumC = inputLayout.height;
        const source = `
        float ${funcName}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
          depth3 * ${stride3} + depth2;
          vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
          return sampleTexture(${name2}, uv);
        }
      `;
        return new GlslLibRoutine(source, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
      }
      /**
       * Unpacked 6D snippet.
       */
      getUnpackedSampler6D(funcName, name2, inputLayout) {
        const shape2 = inputLayout.unpackedShape;
        const stride4 = shape2[5];
        const stride3 = shape2[4] * stride4;
        const stride2 = shape2[3] * stride3;
        const stride1 = shape2[2] * stride2;
        const stride0 = shape2[1] * stride1;
        const { newShape, keptDims } = squeezeShape(shape2);
        if (newShape.length < shape2.length) {
          const newInputShape = squeezeInputShape(shape2, newShape);
          const params = ["row", "col", "depth", "depth2", "depth3", "depth4"];
          const newInputLayout = JSON.parse(JSON.stringify(inputLayout));
          newInputLayout.unpackedShape = newInputShape;
          const source2 = `
            ${this.getUnpackedSamplerFromInput(funcName, name2, newInputLayout).routineBody}
            float ${funcName}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${funcName}(${getSqueezedParams(params, keptDims)});
            }
          `;
          return new GlslLibRoutine(source2, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
        }
        const texNumR = inputLayout.width;
        const texNumC = inputLayout.height;
        const source = `
          float ${funcName}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +
            depth2 * ${stride3} + depth3 * ${stride4} + depth4;
            vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);
            return sampleTexture(${name2}, uv);
          }
        `;
        return new GlslLibRoutine(
          source,
          ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]
        );
      }
      /**
       * This is the main function to map from the given texture coordiantes (s,t)
       * to logical indices for the output
       * There will only be one single variation of this
       * Also see coordsToOffset and offsetToIndices for input-specific versions
       */
      toVec() {
        const output = this.context.outputTextureLayout;
        const rank = output.shape.length;
        const strides = output.strides;
        const xScale = output.width;
        const yScale = output.height;
        const stridesBlock = [];
        for (let i = 0; i < rank - 1; ++i) {
          stridesBlock.push(`
        c[${i}] = offset / ${strides[i]};`);
          stridesBlock.push(`
        offset -= c[${i}] * ${strides[i]};`);
        }
        stridesBlock.push(`
        c[${rank - 1}] = offset;`);
        const body = `
      void toVec(vec2 texCoords, out int c[${rank}]) {
        int offset = coordsToOffset(texCoords, ${xScale}, ${yScale});
        ${stridesBlock.join("")}
      }
      void toVec(int offset, out int c[${rank}]) {
        ${stridesBlock.join("")}
      }
    `;
        return { toVec: new GlslLibRoutine(body, ["coordinates.coordsToOffset"]) };
      }
      /**
       * These are value getter functions generated for each input
       * Each function is hardwired to the name and dimensions of the input
       * An '_T' variation is also produced which accesses values as if the
       * input was transposed
       */
      valueFrom() {
        const result = {};
        this.context.programInfo.inputNames.forEach((name2, i) => {
          const layout = this.context.inputTextureLayouts[i];
          const shape2 = layout.unpackedShape.length > 0 ? layout.unpackedShape : layout.shape;
          const rank = shape2.length;
          let funcName = `_${name2}`;
          result[funcName] = new GlslLibRoutine(
            this.getValueFromSingle(name2, rank, layout.width, layout.height, false),
            [`shapeUtils.indicesToOffset${funcName}`, "coordinates.offsetToCoords", "fragcolor.getColorAsFloat"]
          );
          funcName = funcName + "_T";
          result[funcName] = new GlslLibRoutine(
            this.getValueFromSingle(name2, rank, layout.width, layout.height, true),
            [`shapeUtils.indicesToOffset${funcName}`, "coordinates.offsetToCoords", "fragcolor.getColorAsFloat"]
          );
        });
        return result;
      }
      /**
       * Produces one value getter function for the name and rank given
       * If a transpose is set proper offsetToCoords mapping will be used
       * @param name name of the function
       * @param rank rank of the input
       * @param transpose whether or not should generate a transpose variation
       */
      getValueFromSingle(varName, rank, width, height, transpose2) {
        let name2 = `_${varName}`;
        if (transpose2) {
          name2 = name2 + "_T";
        }
        const glsl = getGlsl(this.context.glContext.version);
        return `
        float ${name2}(int m[${rank}]) {
          int offset = indicesToOffset${name2}(m);
          vec2 coords = offsetToCoords(offset, ${width}, ${height});
          float value = getColorAsFloat(${glsl.texture2D}(${varName}, coords));
          return value;
        }
        `;
      }
      /**
       * Produces a packed value getter function for the name and rank given
       * If a transpose is set proper offsetToCoords mapping will be used
       * @param name name of the function
       * @param rank rank of the input
       * @param transpose whether or not should generate a transpose variation
       */
      getPackedValueFrom(varName, rank, width, height, transpose2) {
        let name2 = `_${varName}_Pack`;
        if (transpose2) {
          name2 = name2 + "_T";
        }
        const glsl = getGlsl(this.context.glContext.version);
        return `
        vec4 ${name2}(int m[${rank}]) {
          int offset = indicesToOffset_${varName}(m);
          vec2 coords = offsetToCoords(offset, ${width}, ${height});
          return ${glsl.texture2D}(${varName}, coords);
        }
        `;
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/glsl-encoding-lib.ts
var EncodingGlslLib;
var init_glsl_encoding_lib = __esm({
  "web/lib/onnxjs/backends/webgl/glsl-encoding-lib.ts"() {
    "use strict";
    init_glsl_definitions();
    EncodingGlslLib = class _EncodingGlslLib extends GlslLib {
      constructor(context) {
        super(context);
      }
      getFunctions() {
        return { ...this.encodeFloat32(), ...this.decodeFloat32() };
      }
      getCustomTypes() {
        return {};
      }
      encodeFloat32() {
        return {
          encode: new GlslLibRoutine(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)
        };
      }
      decodeFloat32() {
        return {
          decode: new GlslLibRoutine(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)
        };
      }
      /**
       * returns the routine to encode encode a 32bit float to a vec4 (of unsigned bytes)
       * @credit: https://stackoverflow.com/questions/7059962/how-do-i-convert-a-vec4-rgba-value-to-a-float
       */
      encodeUint8() {
        const endianness = _EncodingGlslLib.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
        return {
          encode: new GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${endianness}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)
        };
      }
      /**
       * returns the routine to encode a vec4 of unsigned bytes to float32
       * @credit: https://stackoverflow.com/questions/7059962/how-do-i-convert-a-vec4-rgba-value-to-a-float
       */
      decodeUint8() {
        const endianness = _EncodingGlslLib.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
        return {
          decode: new GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${endianness}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)
        };
      }
      /**
       * Determines if the machine is little endian or not
       * @credit: https://gist.github.com/TooTallNate/4750953
       */
      static isLittleEndian() {
        const b = new ArrayBuffer(4);
        const a = new Uint32Array(b);
        const c = new Uint8Array(b);
        a[0] = 3735928559;
        if (c[0] === 239) {
          return true;
        }
        if (c[0] === 222) {
          return false;
        }
        throw new Error("unknown endianness");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/glsl-fragcolor-lib.ts
var FragColorGlslLib;
var init_glsl_fragcolor_lib = __esm({
  "web/lib/onnxjs/backends/webgl/glsl-fragcolor-lib.ts"() {
    "use strict";
    init_glsl_definitions();
    init_glsl_source();
    FragColorGlslLib = class extends GlslLib {
      constructor(context) {
        super(context);
      }
      getFunctions() {
        return { ...this.setFragColor(), ...this.getColorAsFloat() };
      }
      getCustomTypes() {
        return {};
      }
      setFragColor() {
        const glsl = getGlsl(this.context.glContext.version);
        return {
          setFragColor: new GlslLibRoutine(
            `
        void setFragColor(float value) {
            ${glsl.output} = encode(value);
        }
        `,
            ["encoding.encode"]
          )
        };
      }
      getColorAsFloat() {
        return {
          getColorAsFloat: new GlslLibRoutine(
            `
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,
            ["encoding.decode"]
          )
        };
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/glsl-shape-utils-lib.ts
var ShapeUtilsGlslLib;
var init_glsl_shape_utils_lib = __esm({
  "web/lib/onnxjs/backends/webgl/glsl-shape-utils-lib.ts"() {
    "use strict";
    init_glsl_definitions();
    ShapeUtilsGlslLib = class _ShapeUtilsGlslLib extends GlslLib {
      constructor(context) {
        super(context);
      }
      getFunctions() {
        return {
          ...this.bcastIndex(),
          ...this.bcastMatmulIndex(),
          ...this.offsetToIndices(),
          ...this.indicesToOffset(),
          ...this.incrementIndices()
        };
      }
      getCustomTypes() {
        return {};
      }
      bcastIndex() {
        const outputRank = this.context.outputTextureLayout.shape.length;
        const result = {};
        this.context.programInfo.inputNames.forEach((name2, i) => {
          const shape2 = this.context.inputTextureLayouts[i].unpackedShape;
          if (shape2.length <= outputRank) {
            const rank = shape2.length;
            const dimOffset = outputRank - rank;
            const funcName = `bcastIndices_${name2}`;
            let block = "";
            for (let i2 = 0; i2 < rank; ++i2) {
              block += `
          realIndices[${i2}] = int( mod(float(bcastedIndices[${dimOffset + i2}]), ${shape2[i2]}.0) );
          `;
            }
            const body = `
        void ${funcName} (int bcastedIndices[${outputRank}], out int realIndices[${rank}]) {
          ${block}
        }
        `;
            result[funcName] = new GlslLibRoutine(body);
          }
        });
        return result;
      }
      bcastMatmulIndex() {
        const outputRank = this.context.outputTextureLayout.shape.length;
        const result = {};
        this.context.programInfo.inputNames.forEach((name2, i) => {
          const shape2 = this.context.inputTextureLayouts[i].shape;
          if (!(shape2.length < 2 || shape2.length > outputRank)) {
            const rank = shape2.length;
            const dimOffset = outputRank - rank;
            const funcName = `bcastMatmulIndices_${name2}`;
            let block = "";
            for (let i2 = 0; i2 < rank - 2; ++i2) {
              block += `
          realIndices[${i2}] = int( mod(float(bcastedIndices[${dimOffset + i2}]), ${shape2[i2]}.0) );
          `;
            }
            const body = `
        void ${funcName}(int bcastedIndices[${outputRank}], out int realIndices[${rank}]) {
          ${block}
          realIndices[${rank - 1}] = bcastedIndices[${outputRank - 1}];
          realIndices[${rank - 2}] = bcastedIndices[${outputRank - 2}];
        }
        `;
            result[funcName] = new GlslLibRoutine(body);
          }
        });
        return result;
      }
      indicesToOffset() {
        const result = {};
        this.context.programInfo.inputNames.forEach((name2, i) => {
          const shape2 = this.context.inputTextureLayouts[i].shape;
          const strides = this.context.inputTextureLayouts[i].strides;
          const rank = shape2.length;
          let funcName = `indicesToOffset_${name2}`;
          result[funcName] = new GlslLibRoutine(_ShapeUtilsGlslLib.indexToOffsetSingle(funcName, rank, strides));
          funcName = `indicesToOffset_${name2}_T`;
          result[funcName] = new GlslLibRoutine(_ShapeUtilsGlslLib.indexToOffsetSingle(funcName, rank, strides.slice().reverse()));
        });
        return result;
      }
      static indexToOffsetSingle(name2, rank, strides) {
        let block = "";
        for (let i = rank - 1; i >= 0; --i) {
          block += `
        offset += indices[${i}] * ${strides[i]};
        `;
        }
        return `
      int ${name2}(int indices[${rank}]) {
        int offset = 0;
        ${block}
        return offset;
      }
      `;
      }
      offsetToIndices() {
        const result = {};
        this.context.programInfo.inputNames.forEach((name2, i) => {
          const shape2 = this.context.inputTextureLayouts[i].shape;
          const strides = this.context.inputTextureLayouts[i].strides;
          const rank = shape2.length;
          let funcName = `offsetToIndices_${name2}`;
          result[funcName] = new GlslLibRoutine(_ShapeUtilsGlslLib.offsetToIndicesSingle(funcName, rank, strides));
          funcName = `offsetToIndices_${name2}_T`;
          result[funcName] = new GlslLibRoutine(_ShapeUtilsGlslLib.offsetToIndicesSingle(funcName, rank, strides.slice().reverse()));
        });
        return result;
      }
      static offsetToIndicesSingle(name2, rank, strides) {
        const stridesBlock = [];
        for (let i = 0; i < rank - 1; ++i) {
          stridesBlock.push(`
      indices[${i}] = offset / ${strides[i]};`);
          stridesBlock.push(`
        offset -= indices[${i}] * ${strides[i]};`);
        }
        stridesBlock.push(`
      indices[${rank - 1}] = offset;`);
        return `
      void ${name2}(int offset, out int indices[${rank}]) {
        ${stridesBlock.join("")}
      }
      `;
      }
      incrementIndices() {
        const result = {};
        this.context.programInfo.inputNames.forEach((name2, i) => {
          const shape2 = this.context.inputTextureLayouts[i].shape;
          const rank = shape2.length;
          const funcName = `incrementIndices_${name2}`;
          let shapeInit = "";
          for (let i2 = 0; i2 < rank; ++i2) {
            shapeInit += `
        shape[${i2}] = ${shape2[i2]};`;
          }
          const body = `
        void ${funcName}(int axis, out int indices[${rank}]) {
          int shape[${rank}];
          ${shapeInit};
          for(int i = ${rank} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;
          result[funcName] = new GlslLibRoutine(body);
        });
        return result;
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/glsl-vec-lib.ts
var VecGlslLib;
var init_glsl_vec_lib = __esm({
  "web/lib/onnxjs/backends/webgl/glsl-vec-lib.ts"() {
    "use strict";
    init_glsl_definitions();
    VecGlslLib = class extends GlslLib {
      constructor(context) {
        super(context);
      }
      getCustomTypes() {
        return {};
      }
      getFunctions() {
        return { ...this.binaryVecFunctions(), ...this.copyVec(), ...this.setVecItem(), ...this.getVecItem() };
      }
      binaryVecFunctions() {
        const outputLayout = this.context.outputTextureLayout;
        const rank = outputLayout.shape.length;
        const nameOp = { add: "+=", sub: "-=", mul: "*=", div: "/=" };
        const result = {};
        for (const name2 in nameOp) {
          const fname = `${name2}Vec`;
          let assignmentBlock = "";
          for (let i = 0; i < rank; ++i) {
            assignmentBlock += `
          dest[${i}] ${nameOp[name2]} src[${i}];
          `;
          }
          const body = `
        void ${fname}(int src[${rank}], out int dest[${rank}]) {
          ${assignmentBlock}
        }
        `;
          result[fname] = new GlslLibRoutine(body);
        }
        return result;
      }
      copyVec() {
        const outputLayout = this.context.outputTextureLayout;
        const rank = outputLayout.shape.length;
        let assignmentBlock = "";
        for (let i = 0; i < rank; ++i) {
          assignmentBlock += `
        dest[${i}] = src[${i}];
        `;
        }
        const body = `
      void copyVec(int src[${rank}], out int dest[${rank}]) {
        ${assignmentBlock}
      }
      `;
        return { copyVec: new GlslLibRoutine(body) };
      }
      setVecItem() {
        const outputLayout = this.context.outputTextureLayout;
        const rank = outputLayout.shape.length;
        let block = `
        if(index < 0)
            index =${rank} + index;
        if (index == 0)
            m[0] = value;
        `;
        for (let i = 1; i < rank - 1; ++i) {
          block += `
        else if (index == ${i})
            m[${i}] = value;
            `;
        }
        block += `
        else
            m[${rank - 1}] = value;
        `;
        const body = `
      void setVecItem(out int m[${rank}], int index, int value) {
        ${block}
      }
        `;
        return { setVecItem: new GlslLibRoutine(body) };
      }
      getVecItem() {
        const outputLayout = this.context.outputTextureLayout;
        const rank = outputLayout.shape.length;
        let block = `
        if(index < 0)
            index = ${rank} + index;
        if (index == 0)
            return m[0];
      `;
        for (let i = 1; i < rank - 1; ++i) {
          block += `
        else if (index == ${i})
            return m[${i}];
      `;
        }
        block += `
        else
            return m[${rank - 1}];
        `;
        const body = `
      int getVecItem(int m[${rank}], int index) {
        ${block}
      }
    `;
        return { getVecItem: new GlslLibRoutine(body) };
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/glsl-registered-libs.ts
var glslRegistry;
var init_glsl_registered_libs = __esm({
  "web/lib/onnxjs/backends/webgl/glsl-registered-libs.ts"() {
    "use strict";
    init_glsl_coordinate_lib();
    init_glsl_encoding_lib();
    init_glsl_fragcolor_lib();
    init_glsl_shape_utils_lib();
    init_glsl_vec_lib();
    glslRegistry = {
      "encoding": EncodingGlslLib,
      "fragcolor": FragColorGlslLib,
      "vec": VecGlslLib,
      "shapeUtils": ShapeUtilsGlslLib,
      "coordinates": CoordsGlslLib
      //  'arrays': ArrayGlslSLib
    };
  }
});

// web/lib/onnxjs/backends/webgl/glsl-preprocessor.ts
var GlslPreprocessor;
var init_glsl_preprocessor = __esm({
  "web/lib/onnxjs/backends/webgl/glsl-preprocessor.ts"() {
    "use strict";
    init_glsl_definitions();
    init_glsl_function_inliner();
    init_glsl_registered_libs();
    init_glsl_source();
    GlslPreprocessor = class {
      constructor(glContext, programInfo, inputTextureLayouts, outputTextureLayout) {
        this.libs = {};
        this.glslLibRoutineDependencyGraph = {};
        this.context = new GlslContext(glContext, programInfo, inputTextureLayouts, outputTextureLayout);
        Object.keys(glslRegistry).forEach((name2) => {
          const lib = new glslRegistry[name2](this.context);
          this.libs[name2] = lib;
        });
        const map = this.glslLibRoutineDependencyGraph;
        for (const libName in this.libs) {
          const lib = this.libs[libName];
          const routinesInLib = lib.getFunctions();
          for (const routine in routinesInLib) {
            const key = libName + "." + routine;
            let currentNode;
            if (map[key]) {
              currentNode = map[key];
              currentNode.routineBody = routinesInLib[routine].routineBody;
            } else {
              currentNode = new GlslLibRoutineNode(key, routinesInLib[routine].routineBody);
              map[key] = currentNode;
            }
            const dependencies = routinesInLib[routine].dependencies;
            if (dependencies) {
              for (let i = 0; i < dependencies.length; ++i) {
                if (!map[dependencies[i]]) {
                  const node = new GlslLibRoutineNode(dependencies[i]);
                  map[dependencies[i]] = node;
                  currentNode.addDependency(node);
                } else {
                  currentNode.addDependency(map[dependencies[i]]);
                }
              }
            }
          }
        }
      }
      preprocess() {
        const programInfo = this.context.programInfo;
        let source = programInfo.shaderSource;
        if (!this.context.programInfo.hasMain) {
          source = `${source}
      ${getDefaultFragShaderMain(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`;
        }
        source = replaceInlines(source);
        return `${getFragShaderPreamble(this.context.glContext.version)}
    ${this.getUniforms(programInfo.inputNames, programInfo.variables)}
    ${this.getImports(source)}
    ${source}`;
      }
      getImports(script) {
        const routinesIncluded = this.selectGlslLibRoutinesToBeIncluded(script);
        if (routinesIncluded.length === 0) {
          return "";
        }
        let routines = "";
        for (let i = 0; i < routinesIncluded.length; ++i) {
          if (routinesIncluded[i].routineBody) {
            routines += routinesIncluded[i].routineBody + "\n";
          } else {
            throw new Error(`Missing body for the Glsl Library routine: ${routinesIncluded[i].name}`);
          }
        }
        return routines;
      }
      selectGlslLibRoutinesToBeIncluded(script) {
        const nodes = [];
        Object.keys(this.glslLibRoutineDependencyGraph).forEach((classAndRoutine) => {
          const routine = classAndRoutine.split(".")[1];
          if (script.indexOf(routine) !== -1) {
            nodes.push(this.glslLibRoutineDependencyGraph[classAndRoutine]);
          }
        });
        return TopologicalSortGlslRoutines.returnOrderedNodes(nodes);
      }
      getUniforms(samplers, variables) {
        const uniformLines = [];
        if (samplers) {
          for (const sampler of samplers) {
            uniformLines.push(`uniform sampler2D ${sampler};`);
          }
        }
        if (variables) {
          for (const variable of variables) {
            uniformLines.push(
              `uniform ${variable.type} ${variable.name}${variable.arrayLength ? `[${variable.arrayLength}]` : ""};`
            );
          }
        }
        return uniformLines.join("\n");
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/program-manager.ts
var ProgramManager;
var init_program_manager = __esm({
  "web/lib/onnxjs/backends/webgl/program-manager.ts"() {
    "use strict";
    init_esm();
    init_instrument();
    init_glsl_preprocessor();
    init_glsl_source();
    ProgramManager = class {
      constructor(profiler, glContext, textureLayoutStrategy) {
        this.profiler = profiler;
        this.glContext = glContext;
        this.textureLayoutStrategy = textureLayoutStrategy;
        this.repo = /* @__PURE__ */ new Map();
        this.attributesBound = false;
      }
      getArtifact(key) {
        return this.repo.get(key);
      }
      setArtifact(key, artifact) {
        this.repo.set(key, artifact);
      }
      run(buildArtifact, inputs, output) {
        this.profiler.event("op", `ProgramManager.run ${buildArtifact.programInfo.name ?? "unknown kernel"}`, () => {
          const gl = this.glContext.gl;
          const program = buildArtifact.program;
          gl.useProgram(program);
          try {
            this.bindOutput(output);
            if (!this.attributesBound) {
              this.bindAttributes(buildArtifact.attribLocations);
            }
            this.bindUniforms(buildArtifact.uniformLocations, buildArtifact.programInfo.variables ?? [], inputs);
          } catch (err) {
            Logger.error("ProgramManager", buildArtifact.programInfo.shaderSource);
            throw err;
          }
          this.profiler.event("backend", "GlContext.draw()", () => {
            this.glContext.draw();
          });
        }, this.glContext);
      }
      dispose() {
        if (this.vertexShader) {
          this.glContext.deleteShader(this.vertexShader);
        }
        this.repo.forEach((a) => this.glContext.deleteProgram(a.program));
      }
      build(programInfo, inputTextureLayouts, outputTextureLayout) {
        return this.profiler.event("backend", "ProgramManager.build", () => {
          const preprocessor = new GlslPreprocessor(this.glContext, programInfo, inputTextureLayouts, outputTextureLayout);
          const fragScript = preprocessor.preprocess();
          const program = this.compile(fragScript);
          const artifact = {
            programInfo,
            program,
            uniformLocations: this.getUniformLocations(
              program,
              preprocessor.context.programInfo.inputNames,
              preprocessor.context.programInfo.variables
            ),
            attribLocations: this.getAttribLocations(program)
          };
          return artifact;
        });
      }
      compile(fragShaderScript) {
        if (!this.vertexShader) {
          Logger.verbose("ProrgramManager", "Compiling and caching Vertex shader for the first time");
          const vertexShaderScript = getVertexShaderSource(this.glContext.version);
          this.vertexShader = this.glContext.compileShader(vertexShaderScript, this.glContext.gl.VERTEX_SHADER);
        }
        if (env2.debug) {
          Logger.verbose("ProrgramManager", `FragShader:
${fragShaderScript}
`);
        }
        const fragShader = this.glContext.compileShader(fragShaderScript, this.glContext.gl.FRAGMENT_SHADER);
        const program = this.glContext.createProgram(this.vertexShader, fragShader);
        this.glContext.deleteShader(fragShader);
        return program;
      }
      bindOutput(td) {
        const width = td.width;
        const height = td.height;
        Logger.verbose(
          "ProrgramManager",
          `Binding output texture to Framebuffer: w/h=${width}/${height}, shape=${td.shape}, type=${td.tensor.type}`
        );
        this.glContext.attachFramebuffer(td.texture, width, height);
      }
      bindAttributes(attribLocations) {
        const positionHandle = attribLocations.position;
        const textureCoordHandle = attribLocations.textureCoord;
        this.glContext.setVertexAttributes(positionHandle, textureCoordHandle);
        this.attributesBound = true;
      }
      bindUniforms(uniformLocations, variables, textures) {
        const gl = this.glContext.gl;
        let texturePosition = 0;
        for (const { name: name2, type, location: location2, arrayLength } of uniformLocations) {
          const value = variables.find((v) => v.name === name2)?.data;
          if (type !== "sampler2D" && !value) {
            throw new Error(`variable '${name2}' does not have data defined in program info`);
          }
          switch (type) {
            case "sampler2D":
              this.bindTexture(textures[texturePosition], location2, texturePosition);
              texturePosition++;
              break;
            case "float":
              if (arrayLength) {
                gl.uniform1fv(location2, value);
              } else {
                gl.uniform1f(location2, value);
              }
              break;
            case "int":
              if (arrayLength) {
                gl.uniform1iv(location2, value);
              } else {
                gl.uniform1i(location2, value);
              }
              break;
            default:
              throw new Error(`Uniform not implemented: ${type}`);
          }
        }
      }
      bindTexture(td, uniformHandle, position) {
        this.glContext.bindTextureToUniform(td.texture, position, uniformHandle);
      }
      getAttribLocations(program) {
        return {
          position: this.getAttribLocation(program, "position"),
          textureCoord: this.getAttribLocation(program, "textureCoord")
        };
      }
      getUniformLocations(program, samplers, variables) {
        const uniformLocations = [];
        if (samplers) {
          for (const sampler of samplers) {
            uniformLocations.push({ name: sampler, type: "sampler2D", location: this.getUniformLocation(program, sampler) });
          }
        }
        if (variables) {
          for (const variable of variables) {
            uniformLocations.push({ ...variable, location: this.getUniformLocation(program, variable.name) });
          }
        }
        return uniformLocations;
      }
      getUniformLocation(program, name2) {
        const gl = this.glContext.gl;
        const reference = gl.getUniformLocation(program, name2);
        if (reference === null) {
          throw new Error(`Uniform ${name2} not found.`);
        }
        return reference;
      }
      getAttribLocation(program, name2) {
        const gl = this.glContext.gl;
        const attributeLocation = gl.getAttribLocation(program, name2);
        return attributeLocation;
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/texture-manager.ts
var TextureManager;
var init_texture_manager = __esm({
  "web/lib/onnxjs/backends/webgl/texture-manager.ts"() {
    "use strict";
    init_instrument();
    init_texture_data_encoder();
    TextureManager = class {
      constructor(glContext, layoutStrategy, profiler, config) {
        this.glContext = glContext;
        this.layoutStrategy = layoutStrategy;
        this.profiler = profiler;
        this.config = config;
        this.pendingRead = /* @__PURE__ */ new Map();
        if (config.reuseTextures) {
          this.inUseTextures = /* @__PURE__ */ new Map();
          this.idleTextures = /* @__PURE__ */ new Map();
          this.textureLookup = /* @__PURE__ */ new Map();
        }
      }
      createTextureFromLayout(dataType, layout, data, usage) {
        const textureDataType = this.toEncoderType(dataType);
        const encoder = this.glContext.getEncoder(textureDataType, layout.channels || 1, usage);
        if (layout.isPacked && usage === 1 /* UploadOnly */) {
          throw new Error("not implemented");
        }
        const width = layout.width;
        const height = layout.height;
        let key;
        let inUseTextures;
        if (this.config.reuseTextures) {
          key = `${width}x${height}_${encoder.format}_${encoder.internalFormat}_${encoder.textureType}`;
          inUseTextures = this.inUseTextures.get(key);
          if (!inUseTextures) {
            inUseTextures = [];
            this.inUseTextures.set(key, inUseTextures);
          }
          const idleTextures = this.idleTextures.get(key);
          if (idleTextures && idleTextures.length > 0) {
            const texture2 = idleTextures.pop();
            inUseTextures.push(texture2);
            if (usage === 1 /* UploadOnly */) {
              this.glContext.updateTexture(texture2, width, height, encoder, this.toTextureData(dataType, data));
            }
            return texture2;
          }
        }
        Logger.verbose("TextureManager", `Creating new texture of size ${layout.width}x${layout.height}`);
        const texture = this.glContext.allocateTexture(width, height, encoder, this.toTextureData(dataType, data));
        if (this.config.reuseTextures) {
          inUseTextures.push(texture);
          this.textureLookup.set(texture, key);
        }
        return texture;
      }
      readTexture(td, dataType, channels) {
        if (!channels) {
          channels = 1;
        }
        return this.profiler.event("backend", "TextureManager.readTexture", () => {
          const dataSize = td.shape.reduce((a, b) => a * b) * channels;
          const data = this.glContext.readTexture(
            td.texture,
            td.width,
            td.height,
            dataSize,
            this.toEncoderType(dataType),
            channels
          );
          return this.toTensorData(dataType, data);
        });
      }
      async readTextureAsync(td, dataType, channels) {
        const dataId = td.tensor.dataId;
        if (!channels) {
          channels = 1;
        }
        if (this.pendingRead.has(dataId)) {
          const subscribers = this.pendingRead.get(dataId);
          return new Promise((resolve) => subscribers?.push(resolve));
        }
        return this.profiler.event("backend", "TextureManager.readTextureAsync", async () => {
          this.pendingRead.set(dataId, []);
          const dataSize = td.shape.reduce((a, b) => a * b) * channels;
          await this.glContext.createAndWaitForFence();
          const data = this.glContext.readTexture(
            td.texture,
            td.width,
            td.height,
            dataSize,
            this.toEncoderType(dataType),
            channels
          );
          const tensorData = this.toTensorData(dataType, data);
          const subscribers = this.pendingRead.get(dataId);
          this.pendingRead.delete(dataId);
          subscribers?.forEach((resolve) => resolve(tensorData));
          return tensorData;
        });
      }
      readUint8TextureAsFloat(td) {
        return this.profiler.event("backend", "TextureManager.readUint8TextureAsFloat", () => {
          const dataSize = td.shape.reduce((a, b) => a * b);
          const data = this.glContext.readTexture(td.texture, td.width, td.height, dataSize * 4, "byte", 4);
          return new Float32Array(data.buffer, data.byteOffset, dataSize);
        });
      }
      releaseTexture(textureData, deleteTexture) {
        let key;
        if (this.config.reuseTextures) {
          key = this.textureLookup.get(textureData.texture);
          if (key) {
            if (deleteTexture) {
              this.textureLookup.delete(key);
            }
            const inUseTextures = this.inUseTextures.get(key);
            if (inUseTextures) {
              const index = inUseTextures.indexOf(textureData.texture);
              if (index !== -1) {
                inUseTextures.splice(index, 1);
                let idleTextures = this.idleTextures.get(key);
                if (!idleTextures) {
                  idleTextures = [];
                  this.idleTextures.set(key, idleTextures);
                }
                idleTextures.push(textureData.texture);
              }
            }
          }
        }
        if (!key || deleteTexture) {
          Logger.verbose("TextureManager", `Deleting texture of size ${textureData.width}x${textureData.height}`);
          this.glContext.deleteTexture(textureData.texture);
        }
      }
      toTensorData(dataType, data) {
        switch (dataType) {
          case "int16":
            return data instanceof Int16Array ? data : Int16Array.from(data);
          case "int32":
            return data instanceof Int32Array ? data : Int32Array.from(data);
          case "int8":
            return data instanceof Int8Array ? data : Int8Array.from(data);
          case "uint16":
            return data instanceof Uint16Array ? data : Uint16Array.from(data);
          case "uint32":
            return data instanceof Uint32Array ? data : Uint32Array.from(data);
          case "uint8":
          case "bool":
            return data instanceof Uint8Array ? data : Uint8Array.from(data);
          case "float32":
            return data instanceof Float32Array ? data : Float32Array.from(data);
          case "float64":
            return data instanceof Float64Array ? data : Float64Array.from(data);
          default:
            throw new Error(`TensorData type ${dataType} is not supported`);
        }
      }
      toTextureData(_dataType, data) {
        if (!data) {
          return void 0;
        }
        return data instanceof Float32Array ? data : new Float32Array(data);
      }
      toEncoderType(_dataType) {
        return "float";
      }
      clearActiveTextures() {
        this.glContext.clearActiveTextures();
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/session-handler.ts
var WebGLSessionHandler;
var init_session_handler = __esm({
  "web/lib/onnxjs/backends/webgl/session-handler.ts"() {
    "use strict";
    init_instrument();
    init_opset();
    init_inference_handler();
    init_op_resolve_rules();
    init_program_manager();
    init_texture_layout_strategy();
    init_texture_manager();
    WebGLSessionHandler = class {
      constructor(backend2, context) {
        this.backend = backend2;
        this.context = context;
        this.layoutStrategy = new PreferLogicalStrategy(backend2.glContext.maxTextureSize);
        this.programManager = new ProgramManager(this.context.profiler, backend2.glContext, this.layoutStrategy);
        this.textureManager = new TextureManager(
          backend2.glContext,
          this.layoutStrategy,
          this.context.profiler,
          { reuseTextures: backend2.textureCacheMode === "full" }
        );
        this.packedTextureDataCache = /* @__PURE__ */ new Map();
        this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
        this.pack = backend2.pack;
        this.pack2unpackMap = /* @__PURE__ */ new Map();
        this.unpack2packMap = /* @__PURE__ */ new Map();
      }
      createInferenceHandler() {
        return new WebGLInferenceHandler(this);
      }
      onGraphInitialized(graph) {
        const initializers = graph.getValues().filter((v) => v.from === -1 && v.tensor).map((v) => v.tensor.dataId);
        this.initializers = new Set(initializers);
      }
      isInitializer(tensorId) {
        return this.initializers ? this.initializers.has(tensorId) : false;
      }
      addInitializer(tensorId) {
        this.initializers.add(tensorId);
      }
      getTextureData(tensorId, isPacked) {
        if (isPacked) {
          return this.packedTextureDataCache.get(tensorId);
        } else {
          return this.unpackedTextureDataCache.get(tensorId);
        }
      }
      setTextureData(tensorId, textureData, isPacked = false) {
        Logger.verbose("WebGLSessionHandler", "Storing Texture data in cache");
        if (isPacked) {
          this.packedTextureDataCache.set(tensorId, textureData);
        } else {
          this.unpackedTextureDataCache.set(tensorId, textureData);
        }
      }
      dispose() {
        this.programManager.dispose();
        this.textureManager.clearActiveTextures();
        this.packedTextureDataCache.forEach((td) => this.textureManager.releaseTexture(td, true));
        this.packedTextureDataCache = /* @__PURE__ */ new Map();
        this.unpackedTextureDataCache.forEach((td) => this.textureManager.releaseTexture(td, true));
        this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
      }
      resolve(node, opsets, graph) {
        const op = resolveOperator(node, opsets, WEBGL_OP_RESOLVE_RULES);
        return { impl: op.opImpl, context: op.opInit ? op.opInit(node, graph) : node };
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/webgl-context.ts
function linearSearchLastTrue(arr) {
  let i = 0;
  for (; i < arr.length; ++i) {
    const isDone = arr[i]();
    if (!isDone) {
      break;
    }
  }
  return i - 1;
}
var WebGLContext;
var init_webgl_context = __esm({
  "web/lib/onnxjs/backends/webgl/webgl-context.ts"() {
    "use strict";
    init_esm();
    init_texture_data_encoder();
    init_texture_data_encoder();
    init_utils();
    WebGLContext = class {
      constructor(gl, version3) {
        this.frameBufferBound = false;
        this.itemsToPoll = [];
        this.gl = gl;
        this.version = version3;
        this.getExtensions();
        this.vertexbuffer = this.createVertexbuffer();
        this.framebuffer = this.createFramebuffer();
        this.queryVitalParameters();
      }
      allocateTexture(width, height, encoder, data) {
        const gl = this.gl;
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        const buffer = data ? encoder.encode(data, width * height) : null;
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          // Level of detail.
          encoder.internalFormat,
          width,
          height,
          0,
          // Always 0 in OpenGL ES.
          encoder.format,
          encoder.textureType,
          buffer
        );
        this.checkError();
        return texture;
      }
      updateTexture(texture, width, height, encoder, data) {
        const gl = this.gl;
        gl.bindTexture(gl.TEXTURE_2D, texture);
        const buffer = encoder.encode(data, width * height);
        gl.texSubImage2D(
          gl.TEXTURE_2D,
          0,
          // level
          0,
          // xoffset
          0,
          // yoffset
          width,
          height,
          encoder.format,
          encoder.textureType,
          buffer
        );
        this.checkError();
      }
      attachFramebuffer(texture, width, height) {
        const gl = this.gl;
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
        gl.framebufferTexture2D(
          gl.FRAMEBUFFER,
          gl.COLOR_ATTACHMENT0,
          gl.TEXTURE_2D,
          texture,
          0
        );
        this.checkError();
        gl.viewport(0, 0, width, height);
        gl.scissor(0, 0, width, height);
      }
      readTexture(texture, width, height, dataSize, dataType, channels) {
        const gl = this.gl;
        if (!channels) {
          channels = 1;
        }
        if (!this.frameBufferBound) {
          this.attachFramebuffer(texture, width, height);
        }
        const encoder = this.getEncoder(dataType, channels);
        const buffer = encoder.allocate(width * height);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.framebufferTexture2D(
          gl.FRAMEBUFFER,
          gl.COLOR_ATTACHMENT0,
          gl.TEXTURE_2D,
          texture,
          0
        );
        gl.readPixels(0, 0, width, height, gl.RGBA, encoder.textureType, buffer);
        this.checkError();
        return encoder.decode(buffer, dataSize);
      }
      isFramebufferReady() {
        return true;
      }
      getActiveTexture() {
        const gl = this.gl;
        const n = gl.getParameter(this.gl.ACTIVE_TEXTURE);
        return `TEXTURE${n - gl.TEXTURE0}`;
      }
      getTextureBinding() {
        return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);
      }
      getFramebufferBinding() {
        return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);
      }
      setVertexAttributes(positionHandle, textureCoordHandle) {
        const gl = this.gl;
        gl.vertexAttribPointer(positionHandle, 3, gl.FLOAT, false, 20, 0);
        gl.enableVertexAttribArray(positionHandle);
        if (textureCoordHandle !== -1) {
          gl.vertexAttribPointer(textureCoordHandle, 2, gl.FLOAT, false, 20, 12);
          gl.enableVertexAttribArray(textureCoordHandle);
        }
        this.checkError();
      }
      createProgram(vertexShader, fragShader) {
        const gl = this.gl;
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragShader);
        gl.linkProgram(program);
        return program;
      }
      compileShader(shaderSource, shaderType) {
        const gl = this.gl;
        const shader = gl.createShader(shaderType);
        if (!shader) {
          throw new Error(`createShader() returned null with type ${shaderType}`);
        }
        gl.shaderSource(shader, shaderSource);
        gl.compileShader(shader);
        if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
          throw new Error(`Failed to compile shader: ${gl.getShaderInfoLog(shader)}
Shader source:
${shaderSource}`);
        }
        return shader;
      }
      deleteShader(shader) {
        this.gl.deleteShader(shader);
      }
      bindTextureToUniform(texture, position, uniformHandle) {
        const gl = this.gl;
        gl.activeTexture(gl.TEXTURE0 + position);
        this.checkError();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        this.checkError();
        gl.uniform1i(uniformHandle, position);
        this.checkError();
      }
      draw() {
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
        this.checkError();
      }
      checkError() {
        if (env2.debug) {
          const gl = this.gl;
          const error = gl.getError();
          let label = "";
          switch (error) {
            case gl.NO_ERROR:
              return;
            case gl.INVALID_ENUM:
              label = "INVALID_ENUM";
              break;
            case gl.INVALID_VALUE:
              label = "INVALID_VALUE";
              break;
            case gl.INVALID_OPERATION:
              label = "INVALID_OPERATION";
              break;
            case gl.INVALID_FRAMEBUFFER_OPERATION:
              label = "INVALID_FRAMEBUFFER_OPERATION";
              break;
            case gl.OUT_OF_MEMORY:
              label = "OUT_OF_MEMORY";
              break;
            case gl.CONTEXT_LOST_WEBGL:
              label = "CONTEXT_LOST_WEBGL";
              break;
            default:
              label = `Unknown WebGL Error: ${error.toString(16)}`;
          }
          throw new Error(label);
        }
      }
      deleteTexture(texture) {
        this.gl.deleteTexture(texture);
      }
      deleteProgram(program) {
        this.gl.deleteProgram(program);
      }
      getEncoder(dataType, channels, usage = 0 /* Default */) {
        if (this.version === 2) {
          return new RedFloat32DataEncoder(this.gl, channels);
        }
        switch (dataType) {
          case "float":
            if (usage === 1 /* UploadOnly */ || this.isRenderFloat32Supported) {
              return new RGBAFloatDataEncoder(this.gl, channels);
            } else {
              return new RGBAFloatDataEncoder(
                this.gl,
                channels,
                this.textureHalfFloatExtension.HALF_FLOAT_OES
              );
            }
          case "int":
            throw new Error("not implemented");
          case "byte":
            return new Uint8DataEncoder(this.gl, channels);
          default:
            throw new Error(`Invalid dataType: ${dataType}`);
        }
      }
      clearActiveTextures() {
        const gl = this.gl;
        for (let unit = 0; unit < this.maxTextureImageUnits; ++unit) {
          gl.activeTexture(gl.TEXTURE0 + unit);
          gl.bindTexture(gl.TEXTURE_2D, null);
        }
      }
      dispose() {
        if (this.disposed) {
          return;
        }
        const gl = this.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.deleteFramebuffer(this.framebuffer);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.deleteBuffer(this.vertexbuffer);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.finish();
        this.disposed = true;
      }
      createDefaultGeometry() {
        return new Float32Array([
          -1,
          1,
          0,
          0,
          1,
          // upper left
          -1,
          -1,
          0,
          0,
          0,
          // lower left
          1,
          1,
          0,
          1,
          1,
          // upper right
          1,
          -1,
          0,
          1,
          0
          // lower right
        ]);
      }
      createVertexbuffer() {
        const gl = this.gl;
        const buffer = gl.createBuffer();
        if (!buffer) {
          throw new Error("createBuffer() returned null");
        }
        const geometry = this.createDefaultGeometry();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, geometry, gl.STATIC_DRAW);
        this.checkError();
        return buffer;
      }
      createFramebuffer() {
        const fb = this.gl.createFramebuffer();
        if (!fb) {
          throw new Error("createFramebuffer returned null");
        }
        return fb;
      }
      queryVitalParameters() {
        const gl = this.gl;
        this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer();
        this.isRenderFloat32Supported = this.checkRenderFloat32();
        this.isFloat32DownloadSupported = this.checkFloat32Download();
        if (this.version === 1 && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported) {
          throw new Error("both float32 and float16 TextureType are not supported");
        }
        this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend();
        this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        this.maxTextureImageUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        if (this.version === 2) {
        }
      }
      getExtensions() {
        if (this.version === 2) {
          this.colorBufferFloatExtension = this.gl.getExtension("EXT_color_buffer_float");
          this.disjointTimerQueryWebgl2Extension = this.gl.getExtension("EXT_disjoint_timer_query_webgl2");
        } else {
          this.textureFloatExtension = this.gl.getExtension("OES_texture_float");
          this.textureHalfFloatExtension = this.gl.getExtension("OES_texture_half_float");
        }
      }
      checkFloatTextureAttachableToFrameBuffer() {
        const gl = this.gl;
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        const internalFormat = this.version === 2 ? gl.RGBA32F : gl.RGBA;
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
        const frameBuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        const isComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.deleteTexture(texture);
        gl.deleteFramebuffer(frameBuffer);
        return isComplete;
      }
      checkRenderFloat32() {
        if (this.version === 2) {
          if (!this.colorBufferFloatExtension) {
            return false;
          }
        } else {
          if (!this.textureFloatExtension) {
            return false;
          }
        }
        return this.isFloatTextureAttachableToFrameBuffer;
      }
      checkFloat32Download() {
        if (this.version === 2) {
          if (!this.colorBufferFloatExtension) {
            return false;
          }
        } else {
          if (!this.textureFloatExtension) {
            return false;
          }
          if (!this.gl.getExtension("WEBGL_color_buffer_float")) {
            return false;
          }
        }
        return this.isFloatTextureAttachableToFrameBuffer;
      }
      /**
       * Check whether GL_BLEND is supported
       */
      checkFloat32Blend() {
        const gl = this.gl;
        let texture;
        let frameBuffer;
        let vertexShader;
        let fragmentShader;
        let program;
        try {
          texture = gl.createTexture();
          frameBuffer = gl.createFramebuffer();
          gl.bindTexture(gl.TEXTURE_2D, texture);
          const internalFormat = this.version === 2 ? gl.RGBA32F : gl.RGBA;
          gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
          gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
          gl.enable(gl.BLEND);
          vertexShader = gl.createShader(gl.VERTEX_SHADER);
          if (!vertexShader) {
            return false;
          }
          gl.shaderSource(vertexShader, "void main(){}");
          gl.compileShader(vertexShader);
          fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
          if (!fragmentShader) {
            return false;
          }
          gl.shaderSource(fragmentShader, "precision highp float;void main(){gl_FragColor=vec4(0.5);}");
          gl.compileShader(fragmentShader);
          program = gl.createProgram();
          if (!program) {
            return false;
          }
          gl.attachShader(program, vertexShader);
          gl.attachShader(program, fragmentShader);
          gl.linkProgram(program);
          gl.useProgram(program);
          gl.drawArrays(gl.POINTS, 0, 1);
          return gl.getError() === gl.NO_ERROR;
        } finally {
          gl.disable(gl.BLEND);
          if (program) {
            gl.deleteProgram(program);
          }
          if (vertexShader) {
            gl.deleteShader(vertexShader);
          }
          if (fragmentShader) {
            gl.deleteShader(fragmentShader);
          }
          if (frameBuffer) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.deleteFramebuffer(frameBuffer);
          }
          if (texture) {
            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.deleteTexture(texture);
          }
        }
      }
      beginTimer() {
        if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {
          const gl2 = this.gl;
          const ext = this.disjointTimerQueryWebgl2Extension;
          const query = gl2.createQuery();
          gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);
          return query;
        } else {
          throw new Error("WebGL1 profiling currently not supported.");
        }
      }
      endTimer() {
        if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {
          const gl2 = this.gl;
          const ext = this.disjointTimerQueryWebgl2Extension;
          gl2.endQuery(ext.TIME_ELAPSED_EXT);
          return;
        } else {
          throw new Error("WebGL1 profiling currently not supported");
        }
      }
      isTimerResultAvailable(query) {
        let available = false, disjoint = false;
        if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {
          const gl2 = this.gl;
          const ext = this.disjointTimerQueryWebgl2Extension;
          available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);
          disjoint = gl2.getParameter(ext.GPU_DISJOINT_EXT);
        } else {
          throw new Error("WebGL1 profiling currently not supported");
        }
        return available && !disjoint;
      }
      getTimerResult(query) {
        let timeElapsed = 0;
        if (this.version === 2) {
          const gl2 = this.gl;
          timeElapsed = gl2.getQueryParameter(query, gl2.QUERY_RESULT);
          gl2.deleteQuery(query);
        } else {
          throw new Error("WebGL1 profiling currently not supported");
        }
        return timeElapsed / 1e6;
      }
      async waitForQueryAndGetTime(query) {
        await repeatedTry(() => this.isTimerResultAvailable(query));
        return this.getTimerResult(query);
      }
      async createAndWaitForFence() {
        const fenceContext = this.createFence(this.gl);
        return this.pollFence(fenceContext);
      }
      createFence(gl) {
        let isFencePassed;
        const gl2 = gl;
        const query = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);
        gl.flush();
        if (query === null) {
          isFencePassed = () => true;
        } else {
          isFencePassed = () => {
            const status = gl2.clientWaitSync(query, 0, 0);
            return status === gl2.ALREADY_SIGNALED || status === gl2.CONDITION_SATISFIED;
          };
        }
        return { query, isFencePassed };
      }
      async pollFence(fenceContext) {
        return new Promise((resolve) => {
          void this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());
        });
      }
      pollItems() {
        const index = linearSearchLastTrue(this.itemsToPoll.map((x) => x.isDoneFn));
        for (let i = 0; i <= index; ++i) {
          const { resolveFn } = this.itemsToPoll[i];
          resolveFn();
        }
        this.itemsToPoll = this.itemsToPoll.slice(index + 1);
      }
      async addItemToPoll(isDoneFn, resolveFn) {
        this.itemsToPoll.push({ isDoneFn, resolveFn });
        if (this.itemsToPoll.length > 1) {
          return;
        }
        await repeatedTry(() => {
          this.pollItems();
          return this.itemsToPoll.length === 0;
        });
      }
    };
  }
});

// web/lib/onnxjs/backends/webgl/webgl-context-factory.ts
function createWebGLContext(contextId) {
  let context;
  if ((!contextId || contextId === "webgl2") && "webgl2" in cache) {
    context = cache.webgl2;
  } else if ((!contextId || contextId === "webgl") && "webgl" in cache) {
    context = cache.webgl;
  }
  if (!context) {
    try {
      const offscreenCanvas = createOffscreenCanvas();
      context = createNewWebGLContext(offscreenCanvas, contextId);
    } catch (e) {
      const canvas = createCanvas();
      context = createNewWebGLContext(canvas, contextId);
    }
  }
  contextId = contextId || context.version === 1 ? "webgl" : "webgl2";
  const gl = context.gl;
  cache[contextId] = context;
  if (gl.isContextLost()) {
    delete cache[contextId];
    return createWebGLContext(contextId);
  }
  gl.disable(gl.DEPTH_TEST);
  gl.disable(gl.STENCIL_TEST);
  gl.disable(gl.BLEND);
  gl.disable(gl.DITHER);
  gl.disable(gl.POLYGON_OFFSET_FILL);
  gl.disable(gl.SAMPLE_COVERAGE);
  gl.enable(gl.SCISSOR_TEST);
  gl.enable(gl.CULL_FACE);
  gl.cullFace(gl.BACK);
  return context;
}
function createNewWebGLContext(canvas, contextId) {
  const contextAttributes = {
    alpha: false,
    depth: false,
    antialias: false,
    stencil: false,
    preserveDrawingBuffer: false,
    premultipliedAlpha: false,
    failIfMajorPerformanceCaveat: false
  };
  let gl;
  const ca = contextAttributes;
  if (!contextId || contextId === "webgl2") {
    gl = canvas.getContext("webgl2", ca);
    if (gl) {
      try {
        return new WebGLContext(gl, 2);
      } catch (err) {
        Logger.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl2'. Error: ${err}`);
      }
    }
  }
  if (!contextId || contextId === "webgl") {
    gl = canvas.getContext("webgl", ca) || canvas.getContext("experimental-webgl", ca);
    if (gl) {
      try {
        return new WebGLContext(gl, 1);
      } catch (err) {
        Logger.warning(
          "GlContextFactory",
          `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${err}`
        );
      }
    }
  }
  throw new Error("WebGL is not supported");
}
function createCanvas() {
  if (typeof document === "undefined") {
    throw new TypeError("failed to create canvas: document is not supported");
  }
  const canvas = document.createElement("canvas");
  canvas.width = 1;
  canvas.height = 1;
  return canvas;
}
function createOffscreenCanvas() {
  if (typeof OffscreenCanvas === "undefined") {
    throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");
  }
  return new OffscreenCanvas(1, 1);
}
var cache;
var init_webgl_context_factory = __esm({
  "web/lib/onnxjs/backends/webgl/webgl-context-factory.ts"() {
    "use strict";
    init_instrument();
    init_webgl_context();
    cache = {};
  }
});

// web/lib/onnxjs/backends/backend-webgl.ts
var WebGLBackend;
var init_backend_webgl = __esm({
  "web/lib/onnxjs/backends/backend-webgl.ts"() {
    "use strict";
    init_esm();
    init_instrument();
    init_session_handler();
    init_webgl_context_factory();
    WebGLBackend = class {
      get contextId() {
        return env2.webgl.contextId;
      }
      set contextId(value) {
        env2.webgl.contextId = value;
      }
      get matmulMaxBatchSize() {
        return env2.webgl.matmulMaxBatchSize;
      }
      set matmulMaxBatchSize(value) {
        env2.webgl.matmulMaxBatchSize = value;
      }
      get textureCacheMode() {
        return env2.webgl.textureCacheMode;
      }
      set textureCacheMode(value) {
        env2.webgl.textureCacheMode = value;
      }
      get pack() {
        return env2.webgl.pack;
      }
      set pack(value) {
        env2.webgl.pack = value;
      }
      get async() {
        return env2.webgl.async;
      }
      set async(value) {
        env2.webgl.async = value;
      }
      initialize() {
        try {
          this.glContext = createWebGLContext(this.contextId);
          if (typeof this.matmulMaxBatchSize !== "number") {
            this.matmulMaxBatchSize = 16;
          }
          if (typeof this.textureCacheMode !== "string") {
            this.textureCacheMode = "full";
          }
          if (typeof this.pack !== "boolean") {
            this.pack = false;
          }
          if (typeof this.async !== "boolean") {
            this.async = false;
          }
          Logger.setWithEnv(env2);
          if (!env2.webgl.context) {
            Object.defineProperty(env2.webgl, "context", { value: this.glContext.gl });
          }
          Logger.verbose(
            "WebGLBackend",
            `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`
          );
          return true;
        } catch (e) {
          Logger.warning("WebGLBackend", `Unable to initialize WebGLBackend. ${e}`);
          return false;
        }
      }
      createSessionHandler(context) {
        return new WebGLSessionHandler(this, context);
      }
      dispose() {
        this.glContext.dispose();
      }
    };
  }
});

// web/lib/onnxjs/backend.ts
async function resolveBackend(hint) {
  if (!hint) {
    return resolveBackend(["webgl"]);
  } else {
    const hints = typeof hint === "string" ? [hint] : hint;
    for (const backendHint of hints) {
      const cache2 = backendsCache.get(backendHint);
      if (cache2) {
        return cache2;
      }
      const backend2 = await tryLoadBackend(backendHint);
      if (backend2) {
        return backend2;
      }
    }
  }
  throw new Error("no available backend to use");
}
async function tryLoadBackend(backendHint) {
  const backendObj = backend;
  if (typeof backendObj[backendHint] !== "undefined" && isBackend(backendObj[backendHint])) {
    const backend2 = backendObj[backendHint];
    let init = backend2.initialize();
    if (typeof init === "object" && "then" in init) {
      init = await init;
    }
    if (init) {
      backendsCache.set(backendHint, backend2);
      return backend2;
    }
  }
  return void 0;
}
function isBackend(obj) {
  const o = obj;
  if ("initialize" in o && typeof o.initialize === "function" && // initialize()
  "createSessionHandler" in o && typeof o.createSessionHandler === "function" && // createSessionHandler()
  "dispose" in o && typeof o.dispose === "function") {
    return true;
  }
  return false;
}
var backendsCache, backend;
var init_backend2 = __esm({
  "web/lib/onnxjs/backend.ts"() {
    "use strict";
    init_backend_webgl();
    backendsCache = /* @__PURE__ */ new Map();
    backend = {
      webgl: new WebGLBackend()
    };
  }
});

// web/lib/onnxjs/execution-plan.ts
var KernelOp, ExecutionPlan;
var init_execution_plan = __esm({
  "web/lib/onnxjs/execution-plan.ts"() {
    "use strict";
    init_instrument();
    KernelOp = class {
      constructor(op, node) {
        this.op = op;
        this.node = node;
      }
    };
    ExecutionPlan = class {
      constructor(graph, ops, profiler) {
        this.graph = graph;
        this.profiler = profiler;
        this.initialize(ops);
      }
      initialize(ops) {
        this.profiler.event("session", "ExecutionPlan.initialize", () => {
          const graphNodes = this.graph.getNodes();
          if (graphNodes.length !== ops.length) {
            throw new Error("The size of nodes and OPs do not match.");
          }
          this._ops = ops.map((op, i) => new KernelOp(op, graphNodes[i]));
          this.reset();
          this._starter = [];
          this._ops.forEach((op, i) => {
            let resolved = true;
            for (const input of op.node.inputs) {
              if (!this._values[input] && this.graph.getInputIndices().indexOf(input) === -1) {
                resolved = false;
                break;
              }
            }
            if (resolved) {
              this._starter.push(i);
            }
          });
        });
      }
      reset() {
        this._values = this.graph.getValues().map((i) => i.tensor);
      }
      async execute(sessionHandler, modelInputs) {
        return this.profiler.event("session", "ExecutionPlan.execute", async () => {
          this.reset();
          const inferenceHandler = sessionHandler.createInferenceHandler();
          const graphInputs = this.graph.getInputIndices();
          if (modelInputs.length !== graphInputs.length) {
            throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${modelInputs.length} expected: ${graphInputs.length}`);
          }
          modelInputs.forEach((input, i) => {
            const index = graphInputs[i];
            this._values[index] = input;
          });
          const sequence = this._starter.slice(0);
          const graphValues = this.graph.getValues();
          const graphNodes = this.graph.getNodes();
          let rear = 0;
          while (rear < sequence.length) {
            const thisOpIndex = sequence[rear++];
            const thisOp = this._ops[thisOpIndex];
            const inputList = thisOp.node.inputs.map((i) => this._values[i]);
            if (inputList.indexOf(void 0) !== -1) {
              throw new Error(`unresolved input detected: op: ${thisOp.node}`);
            }
            const inputTensors = inputList;
            Logger.verbose(
              "ExecPlan",
              `Runing op:${thisOp.node.name} (${inputTensors.map((t, i) => `'${thisOp.node.inputs[i]}': ${t.type}[${t.dims.join(",")}]`).join(", ")})`
            );
            const outputList = await this.profiler.event(
              "node",
              thisOp.node.name,
              async () => thisOp.op.impl(inferenceHandler, inputTensors, thisOp.op.context)
            );
            if (outputList.length !== thisOp.node.outputs.length) {
              throw new Error("the size of output does not match model definition.");
            }
            outputList.forEach((output2, i) => {
              const j = thisOp.node.outputs[i];
              if (this._values[j]) {
                throw new Error(`output [${j}] already has value: op:${thisOp.node.name}`);
              }
              this._values[j] = output2;
            });
            const downstreamNodes = /* @__PURE__ */ new Set();
            outputList.forEach((_output, i) => {
              const j = thisOp.node.outputs[i];
              for (const currentDownstreamNodeIndex of graphValues[j].to) {
                const currentDownstreamNode = graphNodes[currentDownstreamNodeIndex];
                let resolved = true;
                for (const k of currentDownstreamNode.inputs) {
                  if (!this._values[k]) {
                    resolved = false;
                    break;
                  }
                }
                if (resolved) {
                  downstreamNodes.add(currentDownstreamNodeIndex);
                }
              }
            });
            sequence.push(...downstreamNodes);
          }
          const output = [];
          for (let i = 0; i < this.graph.getOutputIndices().length; i++) {
            const outputIndex = this.graph.getOutputIndices()[i];
            const outputTensor = this._values[outputIndex];
            if (outputTensor === void 0) {
              throw new Error(`required output [${outputIndex}] does not have value`);
            }
            if (outputIndex === 0) {
              await outputTensor.getData();
            } else {
              outputTensor.data;
            }
            output.push(outputTensor);
          }
          Logger.verbose("ExecPlan", "disposing of inferenceHandler");
          inferenceHandler.dispose();
          return output;
        });
      }
    };
  }
});

// web/lib/onnxjs/attribute.ts
var import_onnx3, ortFbs2, Attribute;
var init_attribute = __esm({
  "web/lib/onnxjs/attribute.ts"() {
    "use strict";
    init_ort_generated();
    import_onnx3 = __toESM(require_onnx());
    init_tensor2();
    init_util();
    ortFbs2 = onnxruntime.experimental.fbs;
    Attribute = class _Attribute {
      constructor(attributes) {
        this._attributes = /* @__PURE__ */ new Map();
        if (attributes !== null && attributes !== void 0) {
          for (const attr of attributes) {
            if (attr instanceof import_onnx3.onnx.AttributeProto) {
              this._attributes.set(attr.name, [_Attribute.getValue(attr), _Attribute.getType(attr)]);
            } else if (attr instanceof ortFbs2.Attribute) {
              this._attributes.set(attr.name(), [_Attribute.getValue(attr), _Attribute.getType(attr)]);
            }
          }
          if (this._attributes.size < attributes.length) {
            throw new Error("duplicated attribute names");
          }
        }
      }
      set(key, type, value) {
        this._attributes.set(key, [value, type]);
      }
      delete(key) {
        this._attributes.delete(key);
      }
      getFloat(key, defaultValue) {
        return this.get(key, "float", defaultValue);
      }
      getInt(key, defaultValue) {
        return this.get(key, "int", defaultValue);
      }
      getString(key, defaultValue) {
        return this.get(key, "string", defaultValue);
      }
      getTensor(key, defaultValue) {
        return this.get(key, "tensor", defaultValue);
      }
      getFloats(key, defaultValue) {
        return this.get(key, "floats", defaultValue);
      }
      getInts(key, defaultValue) {
        return this.get(key, "ints", defaultValue);
      }
      getStrings(key, defaultValue) {
        return this.get(key, "strings", defaultValue);
      }
      getTensors(key, defaultValue) {
        return this.get(key, "tensors", defaultValue);
      }
      get(key, type, defaultValue) {
        const valueAndType = this._attributes.get(key);
        if (valueAndType === void 0) {
          if (defaultValue !== void 0) {
            return defaultValue;
          }
          throw new Error(`required attribute not found: ${key}`);
        }
        if (valueAndType[1] !== type) {
          throw new Error(`type mismatch: expected ${type} but got ${valueAndType[1]}`);
        }
        return valueAndType[0];
      }
      static getType(attr) {
        const type = attr instanceof import_onnx3.onnx.AttributeProto ? attr.type : attr.type();
        switch (type) {
          case import_onnx3.onnx.AttributeProto.AttributeType.FLOAT:
            return "float";
          case import_onnx3.onnx.AttributeProto.AttributeType.INT:
            return "int";
          case import_onnx3.onnx.AttributeProto.AttributeType.STRING:
            return "string";
          case import_onnx3.onnx.AttributeProto.AttributeType.TENSOR:
            return "tensor";
          case import_onnx3.onnx.AttributeProto.AttributeType.FLOATS:
            return "floats";
          case import_onnx3.onnx.AttributeProto.AttributeType.INTS:
            return "ints";
          case import_onnx3.onnx.AttributeProto.AttributeType.STRINGS:
            return "strings";
          case import_onnx3.onnx.AttributeProto.AttributeType.TENSORS:
            return "tensors";
          default:
            throw new Error(`attribute type is not supported yet: ${import_onnx3.onnx.AttributeProto.AttributeType[type]}`);
        }
      }
      static getValue(attr) {
        const attrType = attr instanceof import_onnx3.onnx.AttributeProto ? attr.type : attr.type();
        if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.GRAPH || attrType === import_onnx3.onnx.AttributeProto.AttributeType.GRAPHS) {
          throw new Error("graph attribute is not supported yet");
        }
        const value = this.getValueNoCheck(attr);
        if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.INT && LongUtil.isLong(value)) {
          return LongUtil.longToNumber(value);
        }
        if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.INTS) {
          const arr = value;
          const numberValue = new Array(arr.length);
          for (let i = 0; i < arr.length; i++) {
            const maybeLong = arr[i];
            numberValue[i] = LongUtil.longToNumber(maybeLong);
          }
          return numberValue;
        }
        if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.TENSOR) {
          return attr instanceof import_onnx3.onnx.AttributeProto ? Tensor3.fromProto(value) : Tensor3.fromOrtTensor(value);
        }
        if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.TENSORS) {
          if (attr instanceof import_onnx3.onnx.AttributeProto) {
            const tensorProtos = value;
            return tensorProtos.map((value2) => Tensor3.fromProto(value2));
          } else if (attr instanceof ortFbs2.Attribute) {
            const tensorProtos = value;
            return tensorProtos.map((value2) => Tensor3.fromOrtTensor(value2));
          }
        }
        if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.STRING) {
          if (attr instanceof import_onnx3.onnx.AttributeProto) {
            const utf8String = value;
            return decodeUtf8String(utf8String);
          }
        }
        if (attrType === import_onnx3.onnx.AttributeProto.AttributeType.STRINGS) {
          if (attr instanceof import_onnx3.onnx.AttributeProto) {
            const utf8Strings = value;
            return utf8Strings.map(decodeUtf8String);
          }
        }
        return value;
      }
      static getValueNoCheck(attr) {
        return attr instanceof import_onnx3.onnx.AttributeProto ? this.getValueNoCheckFromOnnxFormat(attr) : this.getValueNoCheckFromOrtFormat(attr);
      }
      static getValueNoCheckFromOnnxFormat(attr) {
        switch (attr.type) {
          case import_onnx3.onnx.AttributeProto.AttributeType.FLOAT:
            return attr.f;
          case import_onnx3.onnx.AttributeProto.AttributeType.INT:
            return attr.i;
          case import_onnx3.onnx.AttributeProto.AttributeType.STRING:
            return attr.s;
          case import_onnx3.onnx.AttributeProto.AttributeType.TENSOR:
            return attr.t;
          case import_onnx3.onnx.AttributeProto.AttributeType.GRAPH:
            return attr.g;
          case import_onnx3.onnx.AttributeProto.AttributeType.FLOATS:
            return attr.floats;
          case import_onnx3.onnx.AttributeProto.AttributeType.INTS:
            return attr.ints;
          case import_onnx3.onnx.AttributeProto.AttributeType.STRINGS:
            return attr.strings;
          case import_onnx3.onnx.AttributeProto.AttributeType.TENSORS:
            return attr.tensors;
          case import_onnx3.onnx.AttributeProto.AttributeType.GRAPHS:
            return attr.graphs;
          default:
            throw new Error(`unsupported attribute type: ${import_onnx3.onnx.AttributeProto.AttributeType[attr.type]}`);
        }
      }
      static getValueNoCheckFromOrtFormat(attr) {
        switch (attr.type()) {
          case ortFbs2.AttributeType.FLOAT:
            return attr.f();
          case ortFbs2.AttributeType.INT:
            return attr.i();
          case ortFbs2.AttributeType.STRING:
            return attr.s();
          case ortFbs2.AttributeType.TENSOR:
            return attr.t();
          case ortFbs2.AttributeType.GRAPH:
            return attr.g();
          case ortFbs2.AttributeType.FLOATS:
            return attr.floatsArray();
          case ortFbs2.AttributeType.INTS: {
            const ints = [];
            for (let i = 0; i < attr.intsLength(); i++) {
              ints.push(attr.ints(i));
            }
            return ints;
          }
          case ortFbs2.AttributeType.STRINGS: {
            const strings = [];
            for (let i = 0; i < attr.stringsLength(); i++) {
              strings.push(attr.strings(i));
            }
            return strings;
          }
          case ortFbs2.AttributeType.TENSORS: {
            const tensors = [];
            for (let i = 0; i < attr.tensorsLength(); i++) {
              tensors.push(attr.tensors(i));
            }
            return tensors;
          }
          default:
            throw new Error(`unsupported attribute type: ${ortFbs2.AttributeType[attr.type()]}`);
        }
      }
    };
  }
});

// web/lib/onnxjs/graph.ts
var import_onnx4, ortFbs3, Graph, Value, Node, GraphImpl;
var init_graph = __esm({
  "web/lib/onnxjs/graph.ts"() {
    "use strict";
    init_attribute();
    init_ort_generated();
    import_onnx4 = __toESM(require_onnx());
    init_tensor2();
    init_util();
    ortFbs3 = onnxruntime.experimental.fbs;
    Graph = {
      /**
       * construct a graph from a graph protobuf type
       */
      from: (graphProto, initializer) => new GraphImpl(graphProto, initializer)
    };
    Value = class {
      constructor(valueInfo) {
        this._from = void 0;
        this._to = [];
        this.tensor = void 0;
        this.type = void 0;
        if (valueInfo) {
          this.type = ProtoUtil.tensorValueTypeFromProto(valueInfo.type.tensorType);
        }
      }
      // -1 represent from initializer
      get from() {
        return this._from;
      }
      get to() {
        return this._to;
      }
    };
    Node = class {
      constructor(_nodeProto, name2) {
        if (_nodeProto instanceof import_onnx4.onnx.NodeProto) {
          this.name = _nodeProto.name;
          this.opType = _nodeProto.opType;
          this.attributes = new Attribute(_nodeProto.attribute);
        } else if (_nodeProto instanceof ortFbs3.Node) {
          this.name = name2 ?? _nodeProto.name();
          this.opType = _nodeProto.opType();
          this.attributes = new Attribute(ProtoUtil.tensorAttributesFromORTFormat(_nodeProto));
        }
        this.inputs = [];
        this.outputs = [];
        this.executeNode = true;
      }
    };
    GraphImpl = class {
      constructor(graph, graphInitializer) {
        if (!graph) {
          throw new TypeError("graph is empty");
        }
        this.buildGraph(graph);
        this.transformGraph(graphInitializer);
        this.checkIsAcyclic();
      }
      getInputIndices() {
        return this._allInputIndices;
      }
      getInputNames() {
        return this._allInputNames;
      }
      getOutputIndices() {
        return this._allOutputIndices;
      }
      getOutputNames() {
        return this._allOutputNames;
      }
      getValues() {
        return this._allData;
      }
      getNodes() {
        return this._nodes;
      }
      buildGraph(graph) {
        if (graph instanceof import_onnx4.onnx.GraphProto) {
          this.buildGraphFromOnnxFormat(graph);
        } else if (graph instanceof ortFbs3.Graph) {
          this.buildGraphFromOrtFormat(graph);
        } else {
          throw new TypeError("Graph type is not supported.");
        }
      }
      buildGraphFromOnnxFormat(graph) {
        const dataIndices = /* @__PURE__ */ new Map();
        this._allData = [];
        this._allInputIndices = [];
        this._allInputNames = [];
        this._allOutputIndices = [];
        this._allOutputNames = [];
        this._nodes = [];
        const nodesIndices = /* @__PURE__ */ new Map();
        if (!graph.input) {
          throw new Error("missing information in graph: input");
        }
        const inputValueNames = [];
        for (const i of graph.input) {
          if (dataIndices.has(i.name)) {
            throw new Error(`duplicated input name: ${i.name}`);
          }
          const currentIndex = this._allData.push(new Value(i)) - 1;
          dataIndices.set(i.name, currentIndex);
          inputValueNames.push(i.name);
        }
        if (!graph.initializer) {
          throw new Error("missing information in graph: initializer");
        }
        for (const i of graph.initializer) {
          let index = dataIndices.get(i.name);
          if (index === void 0) {
            const value = new Value();
            value.type = {
              shape: { dims: ProtoUtil.tensorDimsFromProto(i.dims) },
              tensorType: ProtoUtil.tensorDataTypeFromProto(i.dataType)
            };
            index = this._allData.push(value) - 1;
            dataIndices.set(i.name, index);
          }
          this._allData[index]._from = -1;
          this._allData[index].tensor = Tensor3.fromProto(i);
        }
        for (let i = 0; i < this._allData.length; i++) {
          if (!this._allData[i].tensor) {
            this._allInputIndices.push(i);
            this._allInputNames.push(inputValueNames[i]);
          }
        }
        if (!graph.output) {
          throw new Error("missing information in graph: output");
        }
        for (const i of graph.output) {
          if (dataIndices.has(i.name)) {
            throw new Error(`duplicated output name: ${i.name}`);
          }
          const currentIndex = this._allData.push(new Value(i)) - 1;
          dataIndices.set(i.name, currentIndex);
          this._allOutputIndices.push(currentIndex);
          this._allOutputNames.push(i.name);
        }
        if (!graph.node) {
          throw new Error("missing information in graph: node");
        }
        for (const nodeProto of graph.node) {
          if (!nodeProto.name) {
            for (let pick = 0; ; pick++) {
              const name2 = `unnamed_${nodeProto.opType}_${pick}`;
              if (!nodesIndices.has(name2)) {
                nodeProto.name = name2;
                break;
              }
            }
          }
          if (nodesIndices.has(nodeProto.name)) {
            throw new Error(`duplicated node name: ${nodeProto.name}`);
          }
          const currentIndex = this._nodes.push(new Node(nodeProto)) - 1;
          nodesIndices.set(nodeProto.name, currentIndex);
        }
        for (let i = 0; i < this._nodes.length; i++) {
          const node = this._nodes[i];
          const nodeProto = graph.node[i];
          if (!nodeProto.output) {
            throw new Error(`missing output for node: ${nodeProto.name}`);
          }
          for (const output of nodeProto.output) {
            let dataIndex = dataIndices.get(output);
            if (typeof dataIndex === "undefined") {
              dataIndex = this._allData.push(new Value()) - 1;
              dataIndices.set(output, dataIndex);
            }
            node.outputs.push(dataIndex);
            if (this._allData[dataIndex]._from !== void 0) {
              throw new Error(`multiple nodes output to one data value: ${dataIndex}`);
            }
            this._allData[dataIndex]._from = i;
            if (nodeProto.opType === "Constant") {
              if (!nodeProto.attribute || nodeProto.attribute.length !== 1 || !nodeProto.attribute[0].t) {
                throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
              }
              if (!nodeProto.output || nodeProto.output.length !== 1) {
                throw new Error("missing output or incorrect number of outputs for this Constant operator");
              }
              node.outputs.pop();
              node.executeNode = false;
              this._allData[dataIndex]._from = -1;
              this._allData[dataIndex].tensor = Tensor3.fromProto(nodeProto.attribute[0].t);
            }
          }
        }
        for (let i = 0; i < this._nodes.length; i++) {
          const node = this._nodes[i];
          const nodeProto = graph.node[i];
          if (!nodeProto.input) {
            throw new Error(`missing input for node: ${nodeProto.name}`);
          }
          for (const input of nodeProto.input) {
            const dataIndex = dataIndices.get(input);
            if (typeof dataIndex === "undefined") {
              if (input === "" && (nodeProto.input.length === 3 || nodeProto.input.length === 4) && nodeProto.opType === "Resize") {
                continue;
              }
              throw new Error(`unrecognized input '${input}' for node: ${nodeProto.name}`);
            }
            node.inputs.push(dataIndex);
            this._allData[dataIndex]._to.push(i);
          }
        }
        return true;
      }
      buildGraphFromOrtFormat(graph) {
        const dataIndices = /* @__PURE__ */ new Map();
        this._allData = [];
        this._allInputIndices = [];
        this._allInputNames = [];
        this._allOutputIndices = [];
        this._allOutputNames = [];
        this._nodes = [];
        const nodesIndices = /* @__PURE__ */ new Map();
        const inputValueNames = [];
        for (let i = 0; i < graph.inputsLength(); i++) {
          const inputName = graph.inputs(i);
          if (dataIndices.has(inputName)) {
            throw new Error(`duplicated input name: ${inputName}`);
          }
          for (let j = 0; j < graph.nodeArgsLength(); j++) {
            if (graph.nodeArgs(j)?.name() === inputName) {
              const value = new Value();
              const valueType = graph.nodeArgs(j)?.type()?.valueType();
              if (valueType !== ortFbs3.TypeInfoValue.tensor_type) {
                throw new Error("Unexpected value type for the nodeArg.");
              }
              const valueInfo = graph.nodeArgs(j).type().value(new ortFbs3.TensorTypeAndShape());
              const type = ProtoUtil.tensorDataTypeFromProto(valueInfo.elemType());
              const shape2 = valueInfo.shape();
              const dims = [];
              for (let k = 0; k < shape2.dimLength(); k++) {
                dims.push(LongUtil.longToNumber(shape2.dim(k).value().dimValue()));
              }
              value.type = { shape: { dims }, tensorType: type };
              const currentIndex = this._allData.push(value) - 1;
              dataIndices.set(inputName, currentIndex);
              inputValueNames.push(inputName);
            }
          }
        }
        for (let i = 0; i < graph.initializersLength(); i++) {
          const initializer = graph.initializers(i);
          let index = dataIndices.get(initializer.name());
          if (index === void 0) {
            const value = new Value();
            const dims = ProtoUtil.tensorDimsFromORTFormat(initializer);
            const type = ProtoUtil.tensorDataTypeFromProto(initializer.dataType());
            value.type = { shape: { dims }, tensorType: type };
            index = this._allData.push(value) - 1;
            dataIndices.set(initializer.name(), index);
          }
          this._allData[index]._from = -1;
          this._allData[index].tensor = Tensor3.fromOrtTensor(initializer);
        }
        for (let i = 0; i < this._allData.length; i++) {
          if (!this._allData[i].tensor) {
            this._allInputIndices.push(i);
            this._allInputNames.push(inputValueNames[i]);
          }
        }
        for (let i = 0; i < graph.outputsLength(); i++) {
          const outputName = graph.outputs(i);
          if (dataIndices.has(outputName)) {
            throw new Error(`duplicated output name: ${outputName}`);
          }
          const currentIndex = this._allData.push(new Value()) - 1;
          dataIndices.set(outputName, currentIndex);
          this._allOutputIndices.push(currentIndex);
          this._allOutputNames.push(outputName);
        }
        if (!graph.nodes) {
          throw new Error("missing information in graph: node");
        }
        for (let i = 0; i < graph.nodesLength(); i++) {
          const nodeProto = graph.nodes(i);
          let name2 = nodeProto.name();
          if (!name2) {
            for (let pick = 0; ; pick++) {
              name2 = `unnamed_${nodeProto.opType()}_${pick}`;
              if (!nodesIndices.has(name2)) {
                break;
              }
            }
          }
          if (nodesIndices.has(name2)) {
            throw new Error(`duplicated node name: ${name2}`);
          }
          const currentIndex = this._nodes.push(new Node(nodeProto, name2)) - 1;
          nodesIndices.set(name2, currentIndex);
        }
        for (let i = 0; i < this._nodes.length; i++) {
          const node = this._nodes[i];
          const nodeProto = graph.nodes(i);
          if (nodeProto == null) {
            throw new Error(`No node exists at index ${i}`);
          }
          if (nodeProto?.outputsLength() === 0) {
            throw new Error(`missing output for node: ${nodeProto.name}`);
          }
          for (let j = 0; j < nodeProto?.outputsLength(); j++) {
            const output = nodeProto?.outputs(j);
            let dataIndex = dataIndices.get(output);
            if (typeof dataIndex === "undefined") {
              dataIndex = this._allData.push(new Value()) - 1;
              dataIndices.set(output, dataIndex);
            }
            node.outputs.push(dataIndex);
            if (this._allData[dataIndex]._from !== void 0) {
              throw new Error(`multiple nodes output to one data value: ${dataIndex}`);
            }
            this._allData[dataIndex]._from = i;
            if (nodeProto.opType() === "Constant") {
              if (nodeProto.attributesLength() !== 1 || !nodeProto.attributes(0).t()) {
                throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
              }
              if (nodeProto.outputsLength() !== 1) {
                throw new Error("missing output or incorrect number of outputs for this Constant operator");
              }
              node.outputs.pop();
              node.executeNode = false;
              this._allData[dataIndex]._from = -1;
              this._allData[dataIndex].tensor = Tensor3.fromOrtTensor(nodeProto.attributes(0).t());
            }
          }
        }
        for (let i = 0; i < this._nodes.length; i++) {
          const node = this._nodes[i];
          const nodeProto = graph.nodes(i);
          if (nodeProto.inputsLength() === 0) {
            throw new Error(`missing input for node: ${nodeProto.name}`);
          }
          for (let j = 0; j < nodeProto.inputsLength(); j++) {
            const input = nodeProto.inputs(j);
            const dataIndex = dataIndices.get(input);
            if (typeof dataIndex === "undefined") {
              throw new Error(`unrecognized input '${input}' for node: ${nodeProto.name()}`);
            }
            node.inputs.push(dataIndex);
            this._allData[dataIndex]._to.push(i);
          }
        }
      }
      checkIsAcyclic() {
        const starters = /* @__PURE__ */ new Set();
        this._allInputIndices.forEach((i) => {
          const data = this._allData[i];
          data._to.forEach((j) => {
            starters.add(j);
          });
        });
        const nodesStack = Array.from(starters);
        const nodesState = new Array(this._nodes.length).fill("white");
        while (nodesStack.length > 0) {
          const nodeIndex = nodesStack.pop();
          if (nodesState[nodeIndex] === "gray") {
            nodesState[nodeIndex] = "black";
          } else {
            nodesStack.push(nodeIndex);
            nodesState[nodeIndex] = "gray";
            this._nodes[nodeIndex].outputs.forEach((outgoingEdgeIndex) => {
              const data = this._allData[outgoingEdgeIndex];
              if (typeof data.tensor !== "undefined") {
                throw new Error("node outputs should not be initialized");
              }
              if (data._from !== nodeIndex) {
                throw new Error("from property of the Value object doesn't match index of Node being processed");
              }
              data._to.forEach((downstreamNodeIndex) => {
                if (nodesState[downstreamNodeIndex] === "gray") {
                  throw new Error("model graph is cyclic");
                } else if (nodesState[downstreamNodeIndex] === "white") {
                  nodesStack.push(downstreamNodeIndex);
                }
              });
            });
          }
        }
      }
      transformGraph(graphInitializer) {
        this.removeAllIdentityNodes();
        this.removeAllDropoutNodes();
        this.fuseConvActivationNodes();
        if (graphInitializer) {
          graphInitializer.transformGraph(this);
        }
        this.finalizeGraph();
      }
      /**
       * finalize the graph.
       *
       * this function should be called after all the transformation completed.
       * this function removes all unnecessary nodes and values from the graph
       */
      finalizeGraph() {
        let offset = 0;
        const newIndices = new Array(this._nodes.length, 0);
        let nodePossition = 0;
        for (let i = 0; i < this._nodes.length; i++) {
          newIndices[i] = nodePossition;
          if (this._nodes[i].executeNode) {
            if (nodePossition !== i) {
              this._nodes[nodePossition] = this._nodes[i];
            }
            nodePossition++;
          } else {
            this._nodes[i].outputs.forEach((ind) => {
              this._allData[ind]._from = -2;
            });
          }
        }
        this._nodes.splice(nodePossition, this._nodes.length - nodePossition);
        for (let i = 0; i < this._allData.length; i++) {
          const currentData = this._allData[i];
          if (currentData._from !== void 0 && currentData._from !== -1 && currentData._from !== -2) {
            currentData._from = newIndices[currentData._from];
          }
          for (let j = 0; j < currentData._to.length; j++) {
            if (currentData._to[j] >= 0) {
              currentData._to[j] = newIndices[currentData._to[j]];
            } else {
              throw new Error("Trying to update a removed node");
            }
          }
        }
        offset = 0;
        for (let i = 0; i < this._allData.length; i++) {
          if (this._allData[i].from === -2 && this._allOutputIndices.indexOf(i + offset) === -1) {
            offset++;
            this._allData.splice(i, 1);
            i--;
            continue;
          }
          if (offset > 0) {
            let ind = -1;
            if (this._allData[i].from !== void 0 && this._allData[i].from !== -1) {
              ind = this._nodes[this._allData[i].from].outputs.indexOf(i + offset);
              if (ind !== -1) {
                this._nodes[this._allData[i].from].outputs[ind] = i;
              }
            } else {
              ind = this._allInputIndices.indexOf(i + offset);
              if (ind !== -1) {
                this._allInputIndices[ind] = i;
              }
            }
            this._allData[i].to.forEach((node) => {
              ind = this._nodes[node].inputs.indexOf(i + offset);
              if (ind !== -1) {
                this._nodes[node].inputs[ind] = i;
              }
            });
            if (this._allData[i].to.length === 0) {
              ind = this._allOutputIndices.indexOf(i + offset);
              if (ind !== -1) {
                this._allOutputIndices[ind] = i;
              }
            }
          }
        }
      }
      /**
       * Delete the specifed node. Assume the node has one incoming input and the first output connected to other nodes.
       * An input validation must be done before calling this function.
       * @param nodeIndex The index of node to be deleted
       */
      deleteNode(nodeIndex) {
        const node = this._nodes[nodeIndex];
        if (node.outputs.length > 1) {
          for (let i = 1; i < node.outputs.length; i++) {
            if (this._allData[node.outputs[i]].to.length > 0) {
              throw new Error("Node deletion with more than one output connected to other nodes is not supported. ");
            }
          }
        }
        node.executeNode = false;
        const inputValueIndex = node.inputs[0];
        const outputValueIndex = node.outputs[0];
        const nodesConsumingOutput = this._allData[outputValueIndex].to;
        for (let i = 0; i < node.inputs.length; i++) {
          const delIndex = this._allData[node.inputs[i]].to.indexOf(nodeIndex);
          if (delIndex === -1) {
            throw new Error("The Value object doesn't have the current Node in it's 'to' property ");
          }
          this._allData[node.inputs[i]].to.splice(delIndex, 1);
        }
        this._allData[outputValueIndex]._to = [];
        const index = this._allOutputIndices.indexOf(outputValueIndex);
        if (index !== -1) {
          this._allOutputIndices[index] = inputValueIndex;
        }
        if (nodesConsumingOutput && nodesConsumingOutput.length > 0) {
          for (const nodeIndex2 of nodesConsumingOutput) {
            const replaceIndex = this._nodes[nodeIndex2].inputs.indexOf(outputValueIndex);
            if (replaceIndex === -1) {
              throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");
            }
            this._nodes[nodeIndex2].inputs[replaceIndex] = inputValueIndex;
            this._allData[inputValueIndex].to.push(nodeIndex2);
          }
        }
      }
      removeAllDropoutNodes() {
        let nodeIndex = 0;
        for (const node of this._nodes) {
          if (node.opType === "Dropout") {
            if (node.inputs.length !== 1) {
              throw new Error("Dropout nodes should only contain one input. ");
            }
            if (node.outputs.length !== 1 && node.outputs.length !== 2) {
              throw new Error("Dropout nodes should contain either 1 or 2 output(s)");
            }
            if (node.outputs.length === 2 && this._allData[node.outputs[1]]._to.length !== 0) {
              throw new Error("Dropout nodes's second output should not be referenced by other nodes");
            }
            this.deleteNode(nodeIndex);
          }
          nodeIndex++;
        }
      }
      removeAllIdentityNodes() {
        let nodeIndex = 0;
        for (const node of this._nodes) {
          if (node.opType === "Identity") {
            this.deleteNode(nodeIndex);
          }
          nodeIndex++;
        }
      }
      isActivation(n) {
        switch (n.opType) {
          case "Relu":
          case "Sigmoid":
          case "Clip":
            return true;
          default:
            return false;
        }
      }
      fuseConvActivationNodes() {
        for (const node of this._nodes) {
          if (node.opType === "Conv") {
            const next = this._allData[node.outputs[0]]._to;
            if (next.length === 1 && this.isActivation(this._nodes[next[0]])) {
              const child = this._nodes[next[0]];
              if (child.opType === "Clip") {
                if (child.inputs.length === 1) {
                  try {
                    node.attributes.set(
                      "activation_params",
                      "floats",
                      [child.attributes.getFloat("min"), child.attributes.getFloat("max")]
                    );
                  } catch (e) {
                    node.attributes.set("activation_params", "floats", [MIN_CLIP, MAX_CLIP]);
                  }
                } else if (child.inputs.length >= 3 && this._allData[child.inputs[1]].tensor !== void 0 && this._allData[child.inputs[2]].tensor !== void 0) {
                  node.attributes.set("activation_params", "floats", [
                    this._allData[child.inputs[1]].tensor.floatData[0],
                    this._allData[child.inputs[2]].tensor.floatData[0]
                  ]);
                } else {
                  continue;
                }
              }
              node.attributes.set("activation", "string", child.opType);
              this.deleteNode(next[0]);
            }
          }
        }
      }
    };
  }
});

// web/lib/onnxjs/model.ts
var import_onnx5, ortFbs4, Model;
var init_model = __esm({
  "web/lib/onnxjs/model.ts"() {
    "use strict";
    init_flatbuffers();
    init_graph();
    init_ort_generated();
    import_onnx5 = __toESM(require_onnx());
    init_util();
    ortFbs4 = onnxruntime.experimental.fbs;
    Model = class {
      // empty model
      constructor() {
      }
      load(buf, graphInitializer, isOrtFormat) {
        let onnxError;
        if (!isOrtFormat) {
          try {
            this.loadFromOnnxFormat(buf, graphInitializer);
            return;
          } catch (e) {
            if (isOrtFormat !== void 0) {
              throw e;
            }
            onnxError = e;
          }
        }
        try {
          this.loadFromOrtFormat(buf, graphInitializer);
        } catch (e) {
          if (isOrtFormat !== void 0) {
            throw e;
          }
          throw new Error(`Failed to load model as ONNX format: ${onnxError}
as ORT format: ${e}`);
        }
      }
      loadFromOnnxFormat(buf, graphInitializer) {
        const modelProto = import_onnx5.onnx.ModelProto.decode(buf);
        const irVersion = LongUtil.longToNumber(modelProto.irVersion);
        if (irVersion < 3) {
          throw new Error("only support ONNX model with IR_VERSION>=3");
        }
        this._opsets = modelProto.opsetImport.map((i) => ({ domain: i.domain, version: LongUtil.longToNumber(i.version) }));
        this._graph = Graph.from(modelProto.graph, graphInitializer);
      }
      loadFromOrtFormat(buf, graphInitializer) {
        const fb = new flatbuffers.ByteBuffer(buf);
        const ortModel = ortFbs4.InferenceSession.getRootAsInferenceSession(fb).model();
        const irVersion = LongUtil.longToNumber(ortModel.irVersion());
        if (irVersion < 3) {
          throw new Error("only support ONNX model with IR_VERSION>=3");
        }
        this._opsets = [];
        for (let i = 0; i < ortModel.opsetImportLength(); i++) {
          const opsetId = ortModel.opsetImport(i);
          this._opsets.push({ domain: opsetId?.domain(), version: LongUtil.longToNumber(opsetId.version()) });
        }
        this._graph = Graph.from(ortModel.graph(), graphInitializer);
      }
      get graph() {
        return this._graph;
      }
      get opsets() {
        return this._opsets;
      }
    };
  }
});

// web/lib/onnxjs/session.ts
var Session;
var init_session = __esm({
  "web/lib/onnxjs/session.ts"() {
    "use strict";
    init_backend2();
    init_execution_plan();
    init_instrument();
    init_model();
    Session = class {
      constructor(config = {}) {
        this._initialized = false;
        this.backendHint = config.backendHint;
        this.profiler = Profiler.create(config.profiler);
        this.context = { profiler: this.profiler, graphInputTypes: [], graphInputDims: [] };
      }
      get inputNames() {
        return this._model.graph.getInputNames();
      }
      get outputNames() {
        return this._model.graph.getOutputNames();
      }
      startProfiling() {
        this.profiler.start();
      }
      endProfiling() {
        this.profiler.stop();
      }
      async loadModel(arg, byteOffset, length) {
        await this.profiler.event("session", "Session.loadModel", async () => {
          const backend2 = await resolveBackend(this.backendHint);
          this.sessionHandler = backend2.createSessionHandler(this.context);
          this._model = new Model();
          if (typeof arg === "string") {
            const isOrtFormat = arg.endsWith(".ort");
            if (false) {
              const { readFile } = null;
              const buf = await readFile(arg);
              this.initialize(buf, isOrtFormat);
            } else {
              const response = await fetch(arg);
              const buf = await response.arrayBuffer();
              this.initialize(new Uint8Array(buf), isOrtFormat);
            }
          } else if (!ArrayBuffer.isView(arg)) {
            const arr = new Uint8Array(arg, byteOffset || 0, length || arg.byteLength);
            this.initialize(arr);
          } else {
            this.initialize(arg);
          }
        });
      }
      initialize(modelProtoBlob, isOrtFormat) {
        if (this._initialized) {
          throw new Error("already initialized");
        }
        this.profiler.event("session", "Session.initialize", () => {
          const graphInitializer = this.sessionHandler.transformGraph ? this.sessionHandler : void 0;
          this._model.load(modelProtoBlob, graphInitializer, isOrtFormat);
          if (this.sessionHandler.onGraphInitialized) {
            this.sessionHandler.onGraphInitialized(this._model.graph);
          }
          this.initializeOps(this._model.graph);
          this._executionPlan = new ExecutionPlan(this._model.graph, this._ops, this.profiler);
        });
        this._initialized = true;
      }
      async run(inputs) {
        if (!this._initialized) {
          throw new Error("session not initialized yet");
        }
        return this.profiler.event("session", "Session.run", async () => {
          const inputTensors = this.normalizeAndValidateInputs(inputs);
          const outputTensors = await this._executionPlan.execute(this.sessionHandler, inputTensors);
          return this.createOutput(outputTensors);
        });
      }
      normalizeAndValidateInputs(inputs) {
        const modelInputNames = this._model.graph.getInputNames();
        if (Array.isArray(inputs)) {
          if (inputs.length !== modelInputNames.length) {
            throw new Error(`incorrect input array length: expected ${modelInputNames.length} but got ${inputs.length}`);
          }
        } else {
          if (inputs.size !== modelInputNames.length) {
            throw new Error(`incorrect input map size: expected ${modelInputNames.length} but got ${inputs.size}`);
          }
          const sortedInputs = new Array(inputs.size);
          let sortedInputsIndex = 0;
          for (let i = 0; i < modelInputNames.length; ++i) {
            const tensor = inputs.get(modelInputNames[i]);
            if (!tensor) {
              throw new Error(`missing input tensor for: '${name}'`);
            }
            sortedInputs[sortedInputsIndex++] = tensor;
          }
          inputs = sortedInputs;
        }
        if (!this.context.graphInputTypes || this.context.graphInputTypes.length === 0 || !this.context.graphInputDims || this.context.graphInputDims.length === 0) {
          const modelInputIndices = this._model.graph.getInputIndices();
          const modelValues = this._model.graph.getValues();
          const graphInputDims = new Array(modelInputIndices.length);
          for (let i = 0; i < modelInputIndices.length; ++i) {
            const graphInput = modelValues[modelInputIndices[i]];
            graphInputDims[i] = graphInput.type.shape.dims;
            this.context.graphInputTypes.push(graphInput.type.tensorType);
            this.context.graphInputDims.push(inputs[i].dims);
          }
          this.validateInputTensorDims(graphInputDims, inputs, true);
        } else {
          this.validateInputTensorDims(this.context.graphInputDims, inputs, false);
        }
        this.validateInputTensorTypes(this.context.graphInputTypes, inputs);
        return inputs;
      }
      validateInputTensorTypes(graphInputTypes, givenInputs) {
        for (let i = 0; i < givenInputs.length; i++) {
          const expectedType = graphInputTypes[i];
          const actualType = givenInputs[i].type;
          if (expectedType !== actualType) {
            throw new Error(`input tensor[${i}] check failed: expected type '${expectedType}' but got ${actualType}`);
          }
        }
      }
      validateInputTensorDims(graphInputDims, givenInputs, noneDimSupported) {
        for (let i = 0; i < givenInputs.length; i++) {
          const expectedDims = graphInputDims[i];
          const actualDims = givenInputs[i].dims;
          if (!this.compareTensorDims(expectedDims, actualDims, noneDimSupported)) {
            throw new Error(`input tensor[${i}] check failed: expected shape '[${expectedDims.join(",")}]' but got [${actualDims.join(",")}]`);
          }
        }
      }
      compareTensorDims(expectedDims, actualDims, noneDimSupported) {
        if (expectedDims.length !== actualDims.length) {
          return false;
        }
        for (let i = 0; i < expectedDims.length; ++i) {
          if (expectedDims[i] !== actualDims[i] && (!noneDimSupported || expectedDims[i] !== 0)) {
            return false;
          }
        }
        return true;
      }
      createOutput(outputTensors) {
        const modelOutputNames = this._model.graph.getOutputNames();
        if (outputTensors.length !== modelOutputNames.length) {
          throw new Error("expected number of outputs do not match number of generated outputs");
        }
        const output = /* @__PURE__ */ new Map();
        for (let i = 0; i < modelOutputNames.length; ++i) {
          output.set(modelOutputNames[i], outputTensors[i]);
        }
        return output;
      }
      initializeOps(graph) {
        const nodes = graph.getNodes();
        this._ops = new Array(nodes.length);
        for (let i = 0; i < nodes.length; i++) {
          this._ops[i] = this.sessionHandler.resolve(nodes[i], this._model.opsets, graph);
        }
      }
    };
  }
});

// web/lib/onnxjs/session-handler-inference.ts
var OnnxjsSessionHandler;
var init_session_handler_inference = __esm({
  "web/lib/onnxjs/session-handler-inference.ts"() {
    "use strict";
    init_esm();
    init_tensor2();
    OnnxjsSessionHandler = class {
      constructor(session) {
        this.session = session;
        this.inputNames = this.session.inputNames;
        this.outputNames = this.session.outputNames;
      }
      async dispose() {
      }
      async run(feeds, _fetches, _options) {
        const inputMap = /* @__PURE__ */ new Map();
        for (const name2 in feeds) {
          if (Object.hasOwnProperty.call(feeds, name2)) {
            const feed = feeds[name2];
            inputMap.set(
              name2,
              new Tensor3(
                feed.dims,
                feed.type,
                void 0,
                void 0,
                feed.data
              )
            );
          }
        }
        const outputMap = await this.session.run(inputMap);
        const output = {};
        outputMap.forEach((tensor, name2) => {
          output[name2] = new Tensor2(tensor.type, tensor.data, tensor.dims);
        });
        return output;
      }
      startProfiling() {
        this.session.startProfiling();
      }
      endProfiling() {
        this.session.endProfiling();
      }
    };
  }
});

// web/lib/backend-onnxjs.ts
var backend_onnxjs_exports = {};
__export(backend_onnxjs_exports, {
  onnxjsBackend: () => onnxjsBackend
});
var OnnxjsBackend, onnxjsBackend;
var init_backend_onnxjs = __esm({
  "web/lib/backend-onnxjs.ts"() {
    "use strict";
    init_session();
    init_session_handler_inference();
    OnnxjsBackend = class {
      // eslint-disable-next-line @typescript-eslint/no-empty-function
      async init() {
      }
      async createInferenceSessionHandler(pathOrBuffer, options) {
        const session = new Session(options);
        if (typeof pathOrBuffer === "string") {
          await session.loadModel(pathOrBuffer);
        } else {
          await session.loadModel(pathOrBuffer);
        }
        return new OnnxjsSessionHandler(session);
      }
    };
    onnxjsBackend = new OnnxjsBackend();
  }
});

// web/lib/wasm/wasm-utils-env.ts
var isNode;
var init_wasm_utils_env = __esm({
  "web/lib/wasm/wasm-utils-env.ts"() {
    "use strict";
    isNode = false;
  }
});

// web/lib/wasm/proxy-worker/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => main_default
});
var WORKER_NAME, isProxyWorker, main_default;
var init_main = __esm({
  "web/lib/wasm/proxy-worker/main.ts"() {
    "use strict";
    init_wasm_core_impl();
    init_wasm_factory();
    init_wasm_utils_import();
    WORKER_NAME = "ort-wasm-proxy-worker";
    isProxyWorker = globalThis.self?.name === WORKER_NAME;
    if (isProxyWorker) {
      self.onmessage = (ev) => {
        const { type, in: message } = ev.data;
        try {
          switch (type) {
            case "init-wasm":
              initializeWebAssembly(message.wasm).then(
                () => {
                  initRuntime(message).then(
                    () => {
                      postMessage({ type });
                    },
                    (err) => {
                      postMessage({ type, err });
                    }
                  );
                },
                (err) => {
                  postMessage({ type, err });
                }
              );
              break;
            case "init-ep": {
              const { epName, env: env3 } = message;
              initEp(env3, epName).then(
                () => {
                  postMessage({ type });
                },
                (err) => {
                  postMessage({ type, err });
                }
              );
              break;
            }
            case "copy-from": {
              const { buffer } = message;
              const bufferData = copyFromExternalBuffer(buffer);
              postMessage({ type, out: bufferData });
              break;
            }
            case "create": {
              const { model, options } = message;
              createSession(model, options).then(
                (sessionMetadata) => {
                  postMessage({ type, out: sessionMetadata });
                },
                (err) => {
                  postMessage({ type, err });
                }
              );
              break;
            }
            case "release":
              releaseSession(message);
              postMessage({ type });
              break;
            case "run": {
              const { sessionId, inputIndices, inputs, outputIndices, options } = message;
              run(sessionId, inputIndices, inputs, outputIndices, new Array(outputIndices.length).fill(null), options).then(
                (outputs) => {
                  if (outputs.some((o) => o[3] !== "cpu")) {
                    postMessage({ type, err: "Proxy does not support non-cpu tensor location." });
                  } else {
                    postMessage(
                      { type, out: outputs },
                      extractTransferableBuffers([...inputs, ...outputs])
                    );
                  }
                },
                (err) => {
                  postMessage({ type, err });
                }
              );
              break;
            }
            case "end-profiling":
              endProfiling(message);
              postMessage({ type });
              break;
            default:
          }
        } catch (err) {
          postMessage({ type, err });
        }
      };
    }
    main_default = isProxyWorker ? null : (urlOverride) => new Worker(urlOverride ?? scriptSrc, { type: true ? "module" : "classic", name: WORKER_NAME });
  }
});

// web/lib/wasm/wasm-utils-import.ts
var scriptSrc, origin, isSameOrigin, normalizeUrl, fallbackUrl, preload, dynamicImportDefault, createProxyWorker, importProxyWorker, importWasmModule;
var init_wasm_utils_import = __esm({
  "web/lib/wasm/wasm-utils-import.ts"() {
    "use strict";
    init_wasm_utils_env();
    scriptSrc = // if Nodejs, return undefined
    isNode ? void 0 : (
      // if It's ESM, use import.meta.url
      import.meta.url ?? // use `document.currentScript.src` if available
      (typeof document !== "undefined" ? document.currentScript?.src : (
        // use `self.location.href` if available
        typeof self !== "undefined" ? self.location?.href : void 0
      ))
    );
    origin = isNode || typeof location === "undefined" ? void 0 : location.origin;
    isSameOrigin = (filename, prefixOverride) => {
      try {
        const baseUrl = prefixOverride ?? scriptSrc;
        const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);
        return url.origin === origin;
      } catch {
        return false;
      }
    };
    normalizeUrl = (filename, prefixOverride) => {
      const baseUrl = prefixOverride ?? scriptSrc;
      try {
        const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);
        return url.href;
      } catch {
        return void 0;
      }
    };
    fallbackUrl = (filename, prefixOverride) => `${prefixOverride ?? "./"}${filename}`;
    preload = async (absoluteUrl) => {
      const response = await fetch(absoluteUrl, { credentials: "same-origin" });
      const blob = await response.blob();
      return URL.createObjectURL(blob);
    };
    dynamicImportDefault = async (url) => (await import(
      /* webpackIgnore: true */
      url
    )).default;
    createProxyWorker = // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
    false ? void 0 : (init_main(), __toCommonJS(main_exports)).default;
    importProxyWorker = async () => {
      if (!scriptSrc) {
        throw new Error("Failed to load proxy worker: cannot determine the script source URL.");
      }
      if (isSameOrigin(scriptSrc)) {
        return [void 0, createProxyWorker()];
      }
      const url = await preload(scriptSrc);
      return [url, createProxyWorker(url)];
    };
    importWasmModule = async (urlOverride, prefixOverride, isMultiThreaded) => {
      const wasmModuleFilename = false ? "ort-training-wasm-simd-threaded.mjs" : false ? "ort-wasm-simd-threaded.jsep.mjs" : "ort-wasm-simd-threaded.mjs";
      const wasmModuleUrl = urlOverride ?? normalizeUrl(wasmModuleFilename, prefixOverride);
      const needPreload = !isNode && isMultiThreaded && wasmModuleUrl && !isSameOrigin(wasmModuleUrl, prefixOverride);
      const url = needPreload ? await preload(wasmModuleUrl) : wasmModuleUrl ?? fallbackUrl(wasmModuleFilename, prefixOverride);
      return [needPreload ? url : void 0, await dynamicImportDefault(url)];
    };
  }
});

// web/lib/wasm/wasm-factory.ts
var wasm2, initialized, initializing, aborted, isMultiThreadSupported, isSimdSupported, initializeWebAssembly, getInstance;
var init_wasm_factory = __esm({
  "web/lib/wasm/wasm-factory.ts"() {
    "use strict";
    init_wasm_utils_import();
    initialized = false;
    initializing = false;
    aborted = false;
    isMultiThreadSupported = () => {
      if (typeof SharedArrayBuffer === "undefined") {
        return false;
      }
      try {
        if (typeof MessageChannel !== "undefined") {
          new MessageChannel().port1.postMessage(new SharedArrayBuffer(1));
        }
        return WebAssembly.validate(new Uint8Array([
          0,
          97,
          115,
          109,
          1,
          0,
          0,
          0,
          1,
          4,
          1,
          96,
          0,
          0,
          3,
          2,
          1,
          0,
          5,
          4,
          1,
          3,
          1,
          1,
          10,
          11,
          1,
          9,
          0,
          65,
          0,
          254,
          16,
          2,
          0,
          26,
          11
        ]));
      } catch (e) {
        return false;
      }
    };
    isSimdSupported = () => {
      try {
        return WebAssembly.validate(new Uint8Array([
          0,
          97,
          115,
          109,
          1,
          0,
          0,
          0,
          1,
          4,
          1,
          96,
          0,
          0,
          3,
          2,
          1,
          0,
          10,
          30,
          1,
          28,
          0,
          65,
          0,
          253,
          15,
          253,
          12,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          253,
          186,
          1,
          26,
          11
        ]));
      } catch (e) {
        return false;
      }
    };
    initializeWebAssembly = async (flags) => {
      if (initialized) {
        return Promise.resolve();
      }
      if (initializing) {
        throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
      }
      if (aborted) {
        throw new Error("previous call to 'initializeWebAssembly()' failed.");
      }
      initializing = true;
      const timeout = flags.initTimeout;
      let numThreads = flags.numThreads;
      if (!isSimdSupported()) {
        throw new Error("WebAssembly SIMD is not supported in the current environment.");
      }
      const multiThreadSupported = isMultiThreadSupported();
      if (numThreads > 1 && !multiThreadSupported) {
        if (typeof self !== "undefined" && !self.crossOriginIsolated) {
          console.warn(
            "env.wasm.numThreads is set to " + numThreads + ", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."
          );
        }
        console.warn(
          "WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."
        );
        flags.numThreads = numThreads = 1;
      }
      const wasmPaths = flags.wasmPaths;
      const wasmPrefixOverride = typeof wasmPaths === "string" ? wasmPaths : void 0;
      const mjsPathOverrideFlag = wasmPaths?.mjs;
      const mjsPathOverride = mjsPathOverrideFlag?.href ?? mjsPathOverrideFlag;
      const wasmPathOverrideFlag = wasmPaths?.wasm;
      const wasmPathOverride = wasmPathOverrideFlag?.href ?? wasmPathOverrideFlag;
      const [objectUrl, ortWasmFactory] = await importWasmModule(mjsPathOverride, wasmPrefixOverride, numThreads > 1);
      let isTimeout = false;
      const tasks = [];
      if (timeout > 0) {
        tasks.push(new Promise((resolve) => {
          setTimeout(() => {
            isTimeout = true;
            resolve();
          }, timeout);
        }));
      }
      tasks.push(new Promise((resolve, reject) => {
        const config = {
          /**
           * The number of threads. WebAssembly will create (Module.numThreads - 1) workers. If it is 1, no worker will be
           * created.
           */
          numThreads,
          /**
           * A callback function to locate the WebAssembly file. The function should return the full path of the file.
           *
           * Since Emscripten 3.1.58, this function is only called for the .wasm file.
           */
          locateFile: (fileName, scriptDirectory) => wasmPathOverride ?? (wasmPrefixOverride ?? scriptDirectory) + fileName
        };
        ortWasmFactory(config).then(
          // wasm module initialized successfully
          (module2) => {
            initializing = false;
            initialized = true;
            wasm2 = module2;
            resolve();
            if (objectUrl) {
              URL.revokeObjectURL(objectUrl);
            }
          },
          // wasm module failed to initialize
          (what) => {
            initializing = false;
            aborted = true;
            reject(what);
          }
        );
      }));
      await Promise.race(tasks);
      if (isTimeout) {
        throw new Error(`WebAssembly backend initializing failed due to timeout: ${timeout}ms`);
      }
    };
    getInstance = () => {
      if (initialized && wasm2) {
        return wasm2;
      }
      throw new Error("WebAssembly is not initialized yet.");
    };
  }
});

// web/lib/wasm/wasm-utils.ts
var allocWasmString, iterateExtraOptions, checkLastError;
var init_wasm_utils = __esm({
  "web/lib/wasm/wasm-utils.ts"() {
    "use strict";
    init_wasm_factory();
    allocWasmString = (data, allocs) => {
      const wasm3 = getInstance();
      const dataLength = wasm3.lengthBytesUTF8(data) + 1;
      const dataOffset = wasm3._malloc(dataLength);
      wasm3.stringToUTF8(data, dataOffset, dataLength);
      allocs.push(dataOffset);
      return dataOffset;
    };
    iterateExtraOptions = (options, prefix, seen, handler) => {
      if (typeof options == "object" && options !== null) {
        if (seen.has(options)) {
          throw new Error("Circular reference in options");
        } else {
          seen.add(options);
        }
      }
      Object.entries(options).forEach(([key, value]) => {
        const name2 = prefix ? prefix + key : key;
        if (typeof value === "object") {
          iterateExtraOptions(value, name2 + ".", seen, handler);
        } else if (typeof value === "string" || typeof value === "number") {
          handler(name2, value.toString());
        } else if (typeof value === "boolean") {
          handler(name2, value ? "1" : "0");
        } else {
          throw new Error(`Can't handle extra config type: ${typeof value}`);
        }
      });
    };
    checkLastError = (message) => {
      const wasm3 = getInstance();
      const stack = wasm3.stackSave();
      try {
        const paramsOffset = wasm3.stackAlloc(8);
        wasm3._OrtGetLastError(paramsOffset, paramsOffset + 4);
        const errorCode = wasm3.HEAP32[paramsOffset / 4];
        const errorMessagePointer = wasm3.HEAPU32[paramsOffset / 4 + 1];
        const errorMessage = errorMessagePointer ? wasm3.UTF8ToString(errorMessagePointer) : "";
        throw new Error(`${message} ERROR_CODE: ${errorCode}, ERROR_MESSAGE: ${errorMessage}`);
      } finally {
        wasm3.stackRestore(stack);
      }
    };
  }
});

// web/lib/wasm/run-options.ts
var setRunOptions;
var init_run_options = __esm({
  "web/lib/wasm/run-options.ts"() {
    "use strict";
    init_wasm_factory();
    init_wasm_utils();
    setRunOptions = (options) => {
      const wasm3 = getInstance();
      let runOptionsHandle = 0;
      const allocs = [];
      const runOptions = options || {};
      try {
        if (options?.logSeverityLevel === void 0) {
          runOptions.logSeverityLevel = 2;
        } else if (typeof options.logSeverityLevel !== "number" || !Number.isInteger(options.logSeverityLevel) || options.logSeverityLevel < 0 || options.logSeverityLevel > 4) {
          throw new Error(`log serverity level is not valid: ${options.logSeverityLevel}`);
        }
        if (options?.logVerbosityLevel === void 0) {
          runOptions.logVerbosityLevel = 0;
        } else if (typeof options.logVerbosityLevel !== "number" || !Number.isInteger(options.logVerbosityLevel)) {
          throw new Error(`log verbosity level is not valid: ${options.logVerbosityLevel}`);
        }
        if (options?.terminate === void 0) {
          runOptions.terminate = false;
        }
        let tagDataOffset = 0;
        if (options?.tag !== void 0) {
          tagDataOffset = allocWasmString(options.tag, allocs);
        }
        runOptionsHandle = wasm3._OrtCreateRunOptions(
          runOptions.logSeverityLevel,
          runOptions.logVerbosityLevel,
          !!runOptions.terminate,
          tagDataOffset
        );
        if (runOptionsHandle === 0) {
          checkLastError("Can't create run options.");
        }
        if (options?.extra !== void 0) {
          iterateExtraOptions(options.extra, "", /* @__PURE__ */ new WeakSet(), (key, value) => {
            const keyDataOffset = allocWasmString(key, allocs);
            const valueDataOffset = allocWasmString(value, allocs);
            if (wasm3._OrtAddRunConfigEntry(runOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
              checkLastError(`Can't set a run config entry: ${key} - ${value}.`);
            }
          });
        }
        return [runOptionsHandle, allocs];
      } catch (e) {
        if (runOptionsHandle !== 0) {
          wasm3._OrtReleaseRunOptions(runOptionsHandle);
        }
        allocs.forEach((alloc) => wasm3._free(alloc));
        throw e;
      }
    };
  }
});

// web/lib/wasm/session-options.ts
var getGraphOptimzationLevel, getExecutionMode, appendDefaultOptions, setExecutionProviders, setSessionOptions;
var init_session_options = __esm({
  "web/lib/wasm/session-options.ts"() {
    "use strict";
    init_wasm_factory();
    init_wasm_utils();
    getGraphOptimzationLevel = (graphOptimizationLevel) => {
      switch (graphOptimizationLevel) {
        case "disabled":
          return 0;
        case "basic":
          return 1;
        case "extended":
          return 2;
        case "all":
          return 99;
        default:
          throw new Error(`unsupported graph optimization level: ${graphOptimizationLevel}`);
      }
    };
    getExecutionMode = (executionMode) => {
      switch (executionMode) {
        case "sequential":
          return 0;
        case "parallel":
          return 1;
        default:
          throw new Error(`unsupported execution mode: ${executionMode}`);
      }
    };
    appendDefaultOptions = (options) => {
      if (!options.extra) {
        options.extra = {};
      }
      if (!options.extra.session) {
        options.extra.session = {};
      }
      const session = options.extra.session;
      if (!session.use_ort_model_bytes_directly) {
        session.use_ort_model_bytes_directly = "1";
      }
      if (options.executionProviders && options.executionProviders.some((ep) => (typeof ep === "string" ? ep : ep.name) === "webgpu")) {
        options.enableMemPattern = false;
      }
    };
    setExecutionProviders = (sessionOptionsHandle, executionProviders, allocs) => {
      for (const ep of executionProviders) {
        let epName = typeof ep === "string" ? ep : ep.name;
        switch (epName) {
          case "webnn":
            epName = "WEBNN";
            if (typeof ep !== "string") {
              const webnnOptions = ep;
              const deviceType = webnnOptions?.deviceType;
              const numThreads = webnnOptions?.numThreads;
              const powerPreference = webnnOptions?.powerPreference;
              if (deviceType) {
                const keyDataOffset = allocWasmString("deviceType", allocs);
                const valueDataOffset = allocWasmString(deviceType, allocs);
                if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                  checkLastError(`Can't set a session config entry: 'deviceType' - ${deviceType}.`);
                }
              }
              if (numThreads !== void 0) {
                const validatedNumThreads = typeof numThreads !== "number" || !Number.isInteger(numThreads) || numThreads < 0 ? 0 : numThreads;
                const keyDataOffset = allocWasmString("numThreads", allocs);
                const valueDataOffset = allocWasmString(validatedNumThreads.toString(), allocs);
                if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                  checkLastError(`Can't set a session config entry: 'numThreads' - ${numThreads}.`);
                }
              }
              if (powerPreference) {
                const keyDataOffset = allocWasmString("powerPreference", allocs);
                const valueDataOffset = allocWasmString(powerPreference, allocs);
                if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                  checkLastError(`Can't set a session config entry: 'powerPreference' - ${powerPreference}.`);
                }
              }
            }
            break;
          case "webgpu":
            epName = "JS";
            if (typeof ep !== "string") {
              const webgpuOptions = ep;
              if (webgpuOptions?.preferredLayout) {
                if (webgpuOptions.preferredLayout !== "NCHW" && webgpuOptions.preferredLayout !== "NHWC") {
                  throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${webgpuOptions.preferredLayout}`);
                }
                const keyDataOffset = allocWasmString("preferredLayout", allocs);
                const valueDataOffset = allocWasmString(webgpuOptions.preferredLayout, allocs);
                if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                  checkLastError(
                    `Can't set a session config entry: 'preferredLayout' - ${webgpuOptions.preferredLayout}.`
                  );
                }
              }
            }
            break;
          case "wasm":
          case "cpu":
            continue;
          default:
            throw new Error(`not supported execution provider: ${epName}`);
        }
        const epNameDataOffset = allocWasmString(epName, allocs);
        if (getInstance()._OrtAppendExecutionProvider(sessionOptionsHandle, epNameDataOffset) !== 0) {
          checkLastError(`Can't append execution provider: ${epName}.`);
        }
      }
    };
    setSessionOptions = (options) => {
      const wasm3 = getInstance();
      let sessionOptionsHandle = 0;
      const allocs = [];
      const sessionOptions = options || {};
      appendDefaultOptions(sessionOptions);
      try {
        const graphOptimizationLevel = getGraphOptimzationLevel(sessionOptions.graphOptimizationLevel ?? "all");
        const executionMode = getExecutionMode(sessionOptions.executionMode ?? "sequential");
        const logIdDataOffset = typeof sessionOptions.logId === "string" ? allocWasmString(sessionOptions.logId, allocs) : 0;
        const logSeverityLevel = sessionOptions.logSeverityLevel ?? 2;
        if (!Number.isInteger(logSeverityLevel) || logSeverityLevel < 0 || logSeverityLevel > 4) {
          throw new Error(`log serverity level is not valid: ${logSeverityLevel}`);
        }
        const logVerbosityLevel = sessionOptions.logVerbosityLevel ?? 0;
        if (!Number.isInteger(logVerbosityLevel) || logVerbosityLevel < 0 || logVerbosityLevel > 4) {
          throw new Error(`log verbosity level is not valid: ${logVerbosityLevel}`);
        }
        const optimizedModelFilePathOffset = typeof sessionOptions.optimizedModelFilePath === "string" ? allocWasmString(sessionOptions.optimizedModelFilePath, allocs) : 0;
        sessionOptionsHandle = wasm3._OrtCreateSessionOptions(
          graphOptimizationLevel,
          !!sessionOptions.enableCpuMemArena,
          !!sessionOptions.enableMemPattern,
          executionMode,
          !!sessionOptions.enableProfiling,
          0,
          logIdDataOffset,
          logSeverityLevel,
          logVerbosityLevel,
          optimizedModelFilePathOffset
        );
        if (sessionOptionsHandle === 0) {
          checkLastError("Can't create session options.");
        }
        if (sessionOptions.executionProviders) {
          setExecutionProviders(sessionOptionsHandle, sessionOptions.executionProviders, allocs);
        }
        if (sessionOptions.enableGraphCapture !== void 0) {
          if (typeof sessionOptions.enableGraphCapture !== "boolean") {
            throw new Error(`enableGraphCapture must be a boolean value: ${sessionOptions.enableGraphCapture}`);
          }
          const keyDataOffset = allocWasmString("enableGraphCapture", allocs);
          const valueDataOffset = allocWasmString(sessionOptions.enableGraphCapture.toString(), allocs);
          if (wasm3._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
            checkLastError(
              `Can't set a session config entry: 'enableGraphCapture' - ${sessionOptions.enableGraphCapture}.`
            );
          }
        }
        if (sessionOptions.freeDimensionOverrides) {
          for (const [name2, value] of Object.entries(sessionOptions.freeDimensionOverrides)) {
            if (typeof name2 !== "string") {
              throw new Error(`free dimension override name must be a string: ${name2}`);
            }
            if (typeof value !== "number" || !Number.isInteger(value) || value < 0) {
              throw new Error(`free dimension override value must be a non-negative integer: ${value}`);
            }
            const nameOffset = allocWasmString(name2, allocs);
            if (wasm3._OrtAddFreeDimensionOverride(sessionOptionsHandle, nameOffset, value) !== 0) {
              checkLastError(`Can't set a free dimension override: ${name2} - ${value}.`);
            }
          }
        }
        if (sessionOptions.extra !== void 0) {
          iterateExtraOptions(sessionOptions.extra, "", /* @__PURE__ */ new WeakSet(), (key, value) => {
            const keyDataOffset = allocWasmString(key, allocs);
            const valueDataOffset = allocWasmString(value, allocs);
            if (wasm3._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
              checkLastError(`Can't set a session config entry: ${key} - ${value}.`);
            }
          });
        }
        return [sessionOptionsHandle, allocs];
      } catch (e) {
        if (sessionOptionsHandle !== 0) {
          wasm3._OrtReleaseSessionOptions(sessionOptionsHandle);
        }
        allocs.forEach((alloc) => wasm3._free(alloc));
        throw e;
      }
    };
  }
});

// web/lib/wasm/wasm-common.ts
var tensorDataTypeStringToEnum, tensorDataTypeEnumToString, getTensorElementSize, tensorTypeToTypedArrayConstructor, logLevelStringToEnum, isGpuBufferSupportedType, dataLocationStringToEnum;
var init_wasm_common = __esm({
  "web/lib/wasm/wasm-common.ts"() {
    "use strict";
    tensorDataTypeStringToEnum = (type) => {
      switch (type) {
        case "int8":
          return 3 /* int8 */;
        case "uint8":
          return 2 /* uint8 */;
        case "bool":
          return 9 /* bool */;
        case "int16":
          return 5 /* int16 */;
        case "uint16":
          return 4 /* uint16 */;
        case "int32":
          return 6 /* int32 */;
        case "uint32":
          return 12 /* uint32 */;
        case "float16":
          return 10 /* float16 */;
        case "float32":
          return 1 /* float */;
        case "float64":
          return 11 /* double */;
        case "string":
          return 8 /* string */;
        case "int64":
          return 7 /* int64 */;
        case "uint64":
          return 13 /* uint64 */;
        default:
          throw new Error(`unsupported data type: ${type}`);
      }
    };
    tensorDataTypeEnumToString = (typeProto) => {
      switch (typeProto) {
        case 3 /* int8 */:
          return "int8";
        case 2 /* uint8 */:
          return "uint8";
        case 9 /* bool */:
          return "bool";
        case 5 /* int16 */:
          return "int16";
        case 4 /* uint16 */:
          return "uint16";
        case 6 /* int32 */:
          return "int32";
        case 12 /* uint32 */:
          return "uint32";
        case 10 /* float16 */:
          return "float16";
        case 1 /* float */:
          return "float32";
        case 11 /* double */:
          return "float64";
        case 8 /* string */:
          return "string";
        case 7 /* int64 */:
          return "int64";
        case 13 /* uint64 */:
          return "uint64";
        default:
          throw new Error(`unsupported data type: ${typeProto}`);
      }
    };
    getTensorElementSize = (dateType) => [void 0, 4, 1, 1, 2, 2, 4, 8, void 0, 1, 2, 8, 4, 8, void 0, void 0, void 0][dateType];
    tensorTypeToTypedArrayConstructor = (type) => {
      switch (type) {
        case "float16":
          return typeof Float16Array !== "undefined" && Float16Array.from ? Float16Array : Uint16Array;
        case "float32":
          return Float32Array;
        case "uint8":
          return Uint8Array;
        case "int8":
          return Int8Array;
        case "uint16":
          return Uint16Array;
        case "int16":
          return Int16Array;
        case "int32":
          return Int32Array;
        case "bool":
          return Uint8Array;
        case "float64":
          return Float64Array;
        case "uint32":
          return Uint32Array;
        case "int64":
          return BigInt64Array;
        case "uint64":
          return BigUint64Array;
        default:
          throw new Error(`unsupported type: ${type}`);
      }
    };
    logLevelStringToEnum = (logLevel) => {
      switch (logLevel) {
        case "verbose":
          return 0;
        case "info":
          return 1;
        case "warning":
          return 2;
        case "error":
          return 3;
        case "fatal":
          return 4;
        default:
          throw new Error(`unsupported logging level: ${logLevel}`);
      }
    };
    isGpuBufferSupportedType = (type) => type === "float32" || type === "float16" || type === "int32" || type === "int64" || type === "uint32" || type === "uint8" || type === "bool";
    dataLocationStringToEnum = (location2) => {
      switch (location2) {
        case "none":
          return 0;
        case "cpu":
          return 1;
        case "cpu-pinned":
          return 2;
        case "texture":
          return 3;
        case "gpu-buffer":
          return 4;
        default:
          throw new Error(`unsupported data location: ${location2}`);
      }
    };
  }
});

// web/lib/wasm/wasm-utils-load-file.ts
var loadFile;
var init_wasm_utils_load_file = __esm({
  "web/lib/wasm/wasm-utils-load-file.ts"() {
    "use strict";
    init_wasm_utils_env();
    loadFile = async (file) => {
      if (typeof file === "string") {
        if (isNode) {
          try {
            const { readFile } = __require("node:fs/promises");
            return new Uint8Array(await readFile(file));
          } catch (e) {
            if (e.code === "ERR_FS_FILE_TOO_LARGE") {
              const { createReadStream } = __require("node:fs");
              const stream = createReadStream(file);
              const chunks = [];
              for await (const chunk of stream) {
                chunks.push(chunk);
              }
              return new Uint8Array(Buffer.concat(chunks));
            }
            throw e;
          }
        } else {
          const response = await fetch(file);
          if (!response.ok) {
            throw new Error(`failed to load external data file: ${file}`);
          }
          const contentLengthHeader = response.headers.get("Content-Length");
          const fileSize = contentLengthHeader ? parseInt(contentLengthHeader, 10) : 0;
          if (fileSize < 1073741824) {
            return new Uint8Array(await response.arrayBuffer());
          } else {
            if (!response.body) {
              throw new Error(`failed to load external data file: ${file}, no response body.`);
            }
            const reader = response.body.getReader();
            let buffer;
            try {
              buffer = new ArrayBuffer(fileSize);
            } catch (e) {
              if (e instanceof RangeError) {
                const pages = Math.ceil(fileSize / 65536);
                buffer = new WebAssembly.Memory({ initial: pages, maximum: pages }).buffer;
              } else {
                throw e;
              }
            }
            let offset = 0;
            while (true) {
              const { done, value } = await reader.read();
              if (done) {
                break;
              }
              const chunkSize = value.byteLength;
              const chunk = new Uint8Array(buffer, offset, chunkSize);
              chunk.set(value);
              offset += chunkSize;
            }
            return new Uint8Array(buffer, 0, fileSize);
          }
        }
      } else if (file instanceof Blob) {
        return new Uint8Array(await file.arrayBuffer());
      } else if (file instanceof Uint8Array) {
        return file;
      } else {
        return new Uint8Array(file);
      }
    };
  }
});

// web/lib/wasm/wasm-core-impl.ts
var initOrt, initRuntime, initEp, activeSessions, getSessionInputOutputCount, copyFromExternalBuffer, createSession, releaseSession, prepareInputOutputTensor, run, endProfiling, extractTransferableBuffers;
var init_wasm_core_impl = __esm({
  "web/lib/wasm/wasm-core-impl.ts"() {
    "use strict";
    init_run_options();
    init_session_options();
    init_wasm_common();
    init_wasm_factory();
    init_wasm_utils();
    init_wasm_utils_load_file();
    initOrt = (numThreads, loggingLevel) => {
      const errorCode = getInstance()._OrtInit(numThreads, loggingLevel);
      if (errorCode !== 0) {
        checkLastError("Can't initialize onnxruntime.");
      }
    };
    initRuntime = async (env3) => {
      initOrt(env3.wasm.numThreads, logLevelStringToEnum(env3.logLevel));
    };
    initEp = async (env3, epName) => {
      if (false) {
        const initJsep = null.init;
        if (epName === "webgpu") {
          if (typeof navigator === "undefined" || !navigator.gpu) {
            throw new Error("WebGPU is not supported in current environment");
          }
          let adapter = env3.webgpu.adapter;
          if (!adapter) {
            const powerPreference = env3.webgpu.powerPreference;
            if (powerPreference !== void 0 && powerPreference !== "low-power" && powerPreference !== "high-performance") {
              throw new Error(`Invalid powerPreference setting: "${powerPreference}"`);
            }
            const forceFallbackAdapter = env3.webgpu.forceFallbackAdapter;
            if (forceFallbackAdapter !== void 0 && typeof forceFallbackAdapter !== "boolean") {
              throw new Error(`Invalid forceFallbackAdapter setting: "${forceFallbackAdapter}"`);
            }
            adapter = await navigator.gpu.requestAdapter({ powerPreference, forceFallbackAdapter });
            if (!adapter) {
              throw new Error(
                'Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.'
              );
            }
          } else {
            if (typeof adapter.limits !== "object" || typeof adapter.features !== "object" || typeof adapter.requestDevice !== "function") {
              throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.");
            }
          }
          await initJsep("webgpu", getInstance(), env3, adapter);
        }
        if (epName === "webnn") {
          if (typeof navigator === "undefined" || !navigator.ml) {
            throw new Error("WebNN is not supported in current environment");
          }
          await initJsep("webnn", getInstance(), env3);
        }
      }
    };
    activeSessions = /* @__PURE__ */ new Map();
    getSessionInputOutputCount = (sessionHandle) => {
      const wasm3 = getInstance();
      const stack = wasm3.stackSave();
      try {
        const dataOffset = wasm3.stackAlloc(8);
        const errorCode = wasm3._OrtGetInputOutputCount(sessionHandle, dataOffset, dataOffset + 4);
        if (errorCode !== 0) {
          checkLastError("Can't get session input/output count.");
        }
        return [wasm3.HEAP32[dataOffset / 4], wasm3.HEAP32[dataOffset / 4 + 1]];
      } finally {
        wasm3.stackRestore(stack);
      }
    };
    copyFromExternalBuffer = (model) => {
      const wasm3 = getInstance();
      const modelDataOffset = wasm3._malloc(model.byteLength);
      if (modelDataOffset === 0) {
        throw new Error(`Can't create a session. failed to allocate a buffer of size ${model.byteLength}.`);
      }
      wasm3.HEAPU8.set(model, modelDataOffset);
      return [modelDataOffset, model.byteLength];
    };
    createSession = async (modelData, options) => {
      let modelDataOffset, modelDataLength;
      const wasm3 = getInstance();
      if (Array.isArray(modelData)) {
        [modelDataOffset, modelDataLength] = modelData;
      } else if (modelData.buffer === wasm3.HEAPU8.buffer) {
        [modelDataOffset, modelDataLength] = [modelData.byteOffset, modelData.byteLength];
      } else {
        [modelDataOffset, modelDataLength] = copyFromExternalBuffer(modelData);
      }
      let sessionHandle = 0;
      let sessionOptionsHandle = 0;
      let ioBindingHandle = 0;
      let allocs = [];
      const inputNamesUTF8Encoded = [];
      const outputNamesUTF8Encoded = [];
      try {
        [sessionOptionsHandle, allocs] = setSessionOptions(options);
        if (options?.externalData && wasm3.mountExternalData) {
          const loadingPromises = [];
          for (const file of options.externalData) {
            const path = typeof file === "string" ? file : file.path;
            loadingPromises.push(loadFile(typeof file === "string" ? file : file.data).then((data) => {
              wasm3.mountExternalData(path, data);
            }));
          }
          await Promise.all(loadingPromises);
        }
        sessionHandle = await wasm3._OrtCreateSession(modelDataOffset, modelDataLength, sessionOptionsHandle);
        if (sessionHandle === 0) {
          checkLastError("Can't create a session.");
        }
        const [inputCount, outputCount] = getSessionInputOutputCount(sessionHandle);
        const enableGraphCapture = !!options?.enableGraphCapture;
        const inputNames = [];
        const outputNames = [];
        const outputPreferredLocations = [];
        for (let i = 0; i < inputCount; i++) {
          const name2 = wasm3._OrtGetInputName(sessionHandle, i);
          if (name2 === 0) {
            checkLastError("Can't get an input name.");
          }
          inputNamesUTF8Encoded.push(name2);
          inputNames.push(wasm3.UTF8ToString(name2));
        }
        for (let i = 0; i < outputCount; i++) {
          const name2 = wasm3._OrtGetOutputName(sessionHandle, i);
          if (name2 === 0) {
            checkLastError("Can't get an output name.");
          }
          outputNamesUTF8Encoded.push(name2);
          const nameString = wasm3.UTF8ToString(name2);
          outputNames.push(nameString);
          if (false) {
            if (enableGraphCapture && options?.preferredOutputLocation === void 0) {
              outputPreferredLocations.push("gpu-buffer");
              continue;
            }
            const location2 = typeof options?.preferredOutputLocation === "string" ? options.preferredOutputLocation : options?.preferredOutputLocation?.[nameString] ?? "cpu";
            if (location2 !== "cpu" && location2 !== "cpu-pinned" && location2 !== "gpu-buffer") {
              throw new Error(`Not supported preferred output location: ${location2}.`);
            }
            if (enableGraphCapture && location2 !== "gpu-buffer") {
              throw new Error(`Not supported preferred output location: ${location2}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);
            }
            outputPreferredLocations.push(location2);
          }
        }
        let bindingState = null;
        if (false) {
          ioBindingHandle = wasm3._OrtCreateBinding(sessionHandle);
          if (ioBindingHandle === 0) {
            checkLastError("Can't create IO binding.");
          }
          bindingState = {
            handle: ioBindingHandle,
            outputPreferredLocations,
            outputPreferredLocationsEncoded: outputPreferredLocations.map((l) => dataLocationStringToEnum(l))
          };
        }
        activeSessions.set(
          sessionHandle,
          [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded, bindingState, enableGraphCapture, false]
        );
        return [sessionHandle, inputNames, outputNames];
      } catch (e) {
        inputNamesUTF8Encoded.forEach((buf) => wasm3._OrtFree(buf));
        outputNamesUTF8Encoded.forEach((buf) => wasm3._OrtFree(buf));
        if (ioBindingHandle !== 0) {
          wasm3._OrtReleaseBinding(ioBindingHandle);
        }
        if (sessionHandle !== 0) {
          wasm3._OrtReleaseSession(sessionHandle);
        }
        throw e;
      } finally {
        wasm3._free(modelDataOffset);
        if (sessionOptionsHandle !== 0) {
          wasm3._OrtReleaseSessionOptions(sessionOptionsHandle);
        }
        allocs.forEach((alloc) => wasm3._free(alloc));
        wasm3.unmountExternalData?.();
      }
    };
    releaseSession = (sessionId) => {
      const wasm3 = getInstance();
      const session = activeSessions.get(sessionId);
      if (!session) {
        throw new Error(`cannot release session. invalid session id: ${sessionId}`);
      }
      const [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded, ioBindingState, enableGraphCapture] = session;
      if (ioBindingState) {
        if (enableGraphCapture) {
          wasm3._OrtClearBoundOutputs(ioBindingState.handle);
        }
        wasm3._OrtReleaseBinding(ioBindingState.handle);
      }
      wasm3.jsepOnReleaseSession?.(sessionId);
      inputNamesUTF8Encoded.forEach((buf) => wasm3._OrtFree(buf));
      outputNamesUTF8Encoded.forEach((buf) => wasm3._OrtFree(buf));
      wasm3._OrtReleaseSession(sessionHandle);
      activeSessions.delete(sessionId);
    };
    prepareInputOutputTensor = (tensor, tensorHandles, allocs, sessionId, index, enableGraphCapture = false) => {
      if (!tensor) {
        tensorHandles.push(0);
        return;
      }
      const wasm3 = getInstance();
      const dataType = tensor[0];
      const dims = tensor[1];
      const location2 = tensor[3];
      let rawData;
      let dataByteLength;
      if (dataType === "string" && location2 === "gpu-buffer") {
        throw new Error("String tensor is not supported on GPU.");
      }
      if (enableGraphCapture && location2 !== "gpu-buffer") {
        throw new Error(
          `External buffer must be provided for input/output index ${index} when enableGraphCapture is true.`
        );
      }
      if (location2 === "gpu-buffer") {
        const gpuBuffer = tensor[2].gpuBuffer;
        const elementSizeInBytes = getTensorElementSize(tensorDataTypeStringToEnum(dataType));
        dataByteLength = dims.reduce((a, b) => a * b, 1) * elementSizeInBytes;
        const registerBuffer = wasm3.jsepRegisterBuffer;
        if (!registerBuffer) {
          throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');
        }
        rawData = registerBuffer(sessionId, index, gpuBuffer, dataByteLength);
      } else {
        const data = tensor[2];
        if (Array.isArray(data)) {
          dataByteLength = 4 * data.length;
          rawData = wasm3._malloc(dataByteLength);
          allocs.push(rawData);
          let dataIndex = rawData / 4;
          for (let i = 0; i < data.length; i++) {
            if (typeof data[i] !== "string") {
              throw new TypeError(`tensor data at index ${i} is not a string`);
            }
            wasm3.HEAPU32[dataIndex++] = allocWasmString(data[i], allocs);
          }
        } else {
          dataByteLength = data.byteLength;
          rawData = wasm3._malloc(dataByteLength);
          allocs.push(rawData);
          wasm3.HEAPU8.set(new Uint8Array(data.buffer, data.byteOffset, dataByteLength), rawData);
        }
      }
      const stack = wasm3.stackSave();
      const dimsOffset = wasm3.stackAlloc(4 * dims.length);
      try {
        let dimIndex = dimsOffset / 4;
        dims.forEach((d) => wasm3.HEAP32[dimIndex++] = d);
        const tensor2 = wasm3._OrtCreateTensor(
          tensorDataTypeStringToEnum(dataType),
          rawData,
          dataByteLength,
          dimsOffset,
          dims.length,
          dataLocationStringToEnum(location2)
        );
        if (tensor2 === 0) {
          checkLastError(`Can't create tensor for input/output. session=${sessionId}, index=${index}.`);
        }
        tensorHandles.push(tensor2);
      } finally {
        wasm3.stackRestore(stack);
      }
    };
    run = async (sessionId, inputIndices, inputTensors, outputIndices, outputTensors, options) => {
      const wasm3 = getInstance();
      const session = activeSessions.get(sessionId);
      if (!session) {
        throw new Error(`cannot run inference. invalid session id: ${sessionId}`);
      }
      const sessionHandle = session[0];
      const inputNamesUTF8Encoded = session[1];
      const outputNamesUTF8Encoded = session[2];
      const ioBindingState = session[3];
      const enableGraphCapture = session[4];
      const inputOutputBound = session[5];
      const inputCount = inputIndices.length;
      const outputCount = outputIndices.length;
      let runOptionsHandle = 0;
      let runOptionsAllocs = [];
      const inputTensorHandles = [];
      const outputTensorHandles = [];
      const inputOutputAllocs = [];
      const beforeRunStack = wasm3.stackSave();
      const inputValuesOffset = wasm3.stackAlloc(inputCount * 4);
      const inputNamesOffset = wasm3.stackAlloc(inputCount * 4);
      const outputValuesOffset = wasm3.stackAlloc(outputCount * 4);
      const outputNamesOffset = wasm3.stackAlloc(outputCount * 4);
      try {
        [runOptionsHandle, runOptionsAllocs] = setRunOptions(options);
        for (let i = 0; i < inputCount; i++) {
          prepareInputOutputTensor(
            inputTensors[i],
            inputTensorHandles,
            inputOutputAllocs,
            sessionId,
            inputIndices[i],
            enableGraphCapture
          );
        }
        for (let i = 0; i < outputCount; i++) {
          prepareInputOutputTensor(
            outputTensors[i],
            outputTensorHandles,
            inputOutputAllocs,
            sessionId,
            inputCount + outputIndices[i],
            enableGraphCapture
          );
        }
        let inputValuesIndex = inputValuesOffset / 4;
        let inputNamesIndex = inputNamesOffset / 4;
        let outputValuesIndex = outputValuesOffset / 4;
        let outputNamesIndex = outputNamesOffset / 4;
        for (let i = 0; i < inputCount; i++) {
          wasm3.HEAPU32[inputValuesIndex++] = inputTensorHandles[i];
          wasm3.HEAPU32[inputNamesIndex++] = inputNamesUTF8Encoded[inputIndices[i]];
        }
        for (let i = 0; i < outputCount; i++) {
          wasm3.HEAPU32[outputValuesIndex++] = outputTensorHandles[i];
          wasm3.HEAPU32[outputNamesIndex++] = outputNamesUTF8Encoded[outputIndices[i]];
        }
        if (false) {
          const { handle, outputPreferredLocations, outputPreferredLocationsEncoded } = ioBindingState;
          if (inputNamesUTF8Encoded.length !== inputCount) {
            throw new Error(`input count from feeds (${inputCount}) is expected to be always equal to model's input count (${inputNamesUTF8Encoded.length}).`);
          }
          for (let i = 0; i < inputCount; i++) {
            const index = inputIndices[i];
            const errorCode2 = await wasm3._OrtBindInput(handle, inputNamesUTF8Encoded[index], inputTensorHandles[i]);
            if (errorCode2 !== 0) {
              checkLastError(`Can't bind input[${i}] for session=${sessionId}.`);
            }
          }
          for (let i = 0; i < outputCount; i++) {
            const index = outputIndices[i];
            const location2 = outputTensors[i]?.[3];
            if (location2) {
              const errorCode2 = wasm3._OrtBindOutput(handle, outputNamesUTF8Encoded[index], outputTensorHandles[i], 0);
              if (errorCode2 !== 0) {
                checkLastError(`Can't bind pre-allocated output[${i}] for session=${sessionId}.`);
              }
            } else {
              const errorCode2 = wasm3._OrtBindOutput(handle, outputNamesUTF8Encoded[index], 0, outputPreferredLocationsEncoded[index]);
              if (errorCode2 !== 0) {
                checkLastError(`Can't bind output[${i}] to ${outputPreferredLocations[i]} for session=${sessionId}.`);
              }
            }
          }
          activeSessions.set(
            sessionId,
            [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded, ioBindingState, enableGraphCapture, true]
          );
        }
        wasm3.jsepOnRunStart?.(sessionHandle);
        let errorCode;
        if (false) {
          errorCode = await wasm3._OrtRunWithBinding(
            sessionHandle,
            ioBindingState.handle,
            outputCount,
            outputValuesOffset,
            runOptionsHandle
          );
        } else {
          errorCode = await wasm3._OrtRun(
            sessionHandle,
            inputNamesOffset,
            inputValuesOffset,
            inputCount,
            outputNamesOffset,
            outputCount,
            outputValuesOffset,
            runOptionsHandle
          );
        }
        if (errorCode !== 0) {
          checkLastError("failed to call OrtRun().");
        }
        const output = [];
        for (let i = 0; i < outputCount; i++) {
          const tensor = wasm3.HEAPU32[outputValuesOffset / 4 + i];
          if (tensor === outputTensorHandles[i]) {
            output.push(outputTensors[i]);
            continue;
          }
          const beforeGetTensorDataStack = wasm3.stackSave();
          const tensorDataOffset = wasm3.stackAlloc(4 * 4);
          let keepOutputTensor = false;
          let type, dataOffset = 0;
          try {
            const errorCode2 = wasm3._OrtGetTensorData(
              tensor,
              tensorDataOffset,
              tensorDataOffset + 4,
              tensorDataOffset + 8,
              tensorDataOffset + 12
            );
            if (errorCode2 !== 0) {
              checkLastError(`Can't access output tensor data on index ${i}.`);
            }
            let tensorDataIndex = tensorDataOffset / 4;
            const dataType = wasm3.HEAPU32[tensorDataIndex++];
            dataOffset = wasm3.HEAPU32[tensorDataIndex++];
            const dimsOffset = wasm3.HEAPU32[tensorDataIndex++];
            const dimsLength = wasm3.HEAPU32[tensorDataIndex++];
            const dims = [];
            for (let i2 = 0; i2 < dimsLength; i2++) {
              dims.push(wasm3.HEAPU32[dimsOffset / 4 + i2]);
            }
            wasm3._OrtFree(dimsOffset);
            const size = dims.reduce((a, b) => a * b, 1);
            type = tensorDataTypeEnumToString(dataType);
            const preferredLocation = ioBindingState?.outputPreferredLocations[outputIndices[i]];
            if (type === "string") {
              if (preferredLocation === "gpu-buffer") {
                throw new Error("String tensor is not supported on GPU.");
              }
              const stringData = [];
              let dataIndex = dataOffset / 4;
              for (let i2 = 0; i2 < size; i2++) {
                const offset = wasm3.HEAPU32[dataIndex++];
                const maxBytesToRead = i2 === size - 1 ? void 0 : wasm3.HEAPU32[dataIndex] - offset;
                stringData.push(wasm3.UTF8ToString(offset, maxBytesToRead));
              }
              output.push([type, dims, stringData, "cpu"]);
            } else {
              if (preferredLocation === "gpu-buffer" && size > 0) {
                const getBuffer = wasm3.jsepGetBuffer;
                if (!getBuffer) {
                  throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');
                }
                const gpuBuffer = getBuffer(dataOffset);
                const elementSize = getTensorElementSize(dataType);
                if (elementSize === void 0 || !isGpuBufferSupportedType(type)) {
                  throw new Error(`Unsupported data type: ${type}`);
                }
                keepOutputTensor = true;
                output.push([
                  type,
                  dims,
                  {
                    gpuBuffer,
                    download: wasm3.jsepCreateDownloader(gpuBuffer, size * elementSize, type),
                    dispose: () => {
                      wasm3._OrtReleaseTensor(tensor);
                    }
                  },
                  "gpu-buffer"
                ]);
              } else {
                const typedArrayConstructor = tensorTypeToTypedArrayConstructor(type);
                const data = new typedArrayConstructor(size);
                new Uint8Array(data.buffer, data.byteOffset, data.byteLength).set(wasm3.HEAPU8.subarray(dataOffset, dataOffset + data.byteLength));
                output.push([type, dims, data, "cpu"]);
              }
            }
          } finally {
            wasm3.stackRestore(beforeGetTensorDataStack);
            if (type === "string" && dataOffset) {
              wasm3._free(dataOffset);
            }
            if (!keepOutputTensor) {
              wasm3._OrtReleaseTensor(tensor);
            }
          }
        }
        if (ioBindingState && !enableGraphCapture) {
          wasm3._OrtClearBoundOutputs(ioBindingState.handle);
          activeSessions.set(
            sessionId,
            [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded, ioBindingState, enableGraphCapture, false]
          );
        }
        return output;
      } finally {
        wasm3.stackRestore(beforeRunStack);
        inputTensorHandles.forEach((v) => wasm3._OrtReleaseTensor(v));
        outputTensorHandles.forEach((v) => wasm3._OrtReleaseTensor(v));
        inputOutputAllocs.forEach((p) => wasm3._free(p));
        if (runOptionsHandle !== 0) {
          wasm3._OrtReleaseRunOptions(runOptionsHandle);
        }
        runOptionsAllocs.forEach((p) => wasm3._free(p));
      }
    };
    endProfiling = (sessionId) => {
      const wasm3 = getInstance();
      const session = activeSessions.get(sessionId);
      if (!session) {
        throw new Error("invalid session id");
      }
      const sessionHandle = session[0];
      const profileFileName = wasm3._OrtEndProfiling(sessionHandle);
      if (profileFileName === 0) {
        checkLastError("Can't get an profile file name.");
      }
      wasm3._OrtFree(profileFileName);
    };
    extractTransferableBuffers = (tensors) => {
      const buffers = [];
      for (const tensor of tensors) {
        const data = tensor[2];
        if (!Array.isArray(data) && "buffer" in data) {
          buffers.push(data.buffer);
        }
      }
      return buffers;
    };
  }
});

// web/lib/wasm/proxy-wrapper.ts
var isProxy, proxyWorker, initializing2, initialized2, aborted2, temporaryObjectUrl, initWasmCallbacks, queuedCallbacks, enqueueCallbacks, ensureWorker, onProxyWorkerMessage, initializeWebAssemblyAndOrtRuntime, initializeOrtEp, copyFromExternalBuffer2, createSession2, releaseSession2, run2, endProfiling2;
var init_proxy_wrapper = __esm({
  "web/lib/wasm/proxy-wrapper.ts"() {
    "use strict";
    init_esm();
    init_wasm_core_impl();
    init_wasm_factory();
    init_wasm_utils_import();
    isProxy = () => !!env2.wasm.proxy && typeof document !== "undefined";
    initializing2 = false;
    initialized2 = false;
    aborted2 = false;
    queuedCallbacks = /* @__PURE__ */ new Map();
    enqueueCallbacks = (type, callbacks) => {
      const queue = queuedCallbacks.get(type);
      if (queue) {
        queue.push(callbacks);
      } else {
        queuedCallbacks.set(type, [callbacks]);
      }
    };
    ensureWorker = () => {
      if (initializing2 || !initialized2 || aborted2 || !proxyWorker) {
        throw new Error("worker not ready");
      }
    };
    onProxyWorkerMessage = (ev) => {
      switch (ev.data.type) {
        case "init-wasm":
          initializing2 = false;
          if (ev.data.err) {
            aborted2 = true;
            initWasmCallbacks[1](ev.data.err);
          } else {
            initialized2 = true;
            initWasmCallbacks[0]();
          }
          if (temporaryObjectUrl) {
            URL.revokeObjectURL(temporaryObjectUrl);
            temporaryObjectUrl = void 0;
          }
          break;
        case "init-ep":
        case "copy-from":
        case "create":
        case "release":
        case "run":
        case "end-profiling": {
          const callbacks = queuedCallbacks.get(ev.data.type);
          if (ev.data.err) {
            callbacks.shift()[1](ev.data.err);
          } else {
            callbacks.shift()[0](ev.data.out);
          }
          break;
        }
        default:
      }
    };
    initializeWebAssemblyAndOrtRuntime = async () => {
      if (initialized2) {
        return;
      }
      if (initializing2) {
        throw new Error("multiple calls to 'initWasm()' detected.");
      }
      if (aborted2) {
        throw new Error("previous call to 'initWasm()' failed.");
      }
      initializing2 = true;
      if (isProxy()) {
        return new Promise((resolve, reject) => {
          proxyWorker?.terminate();
          void importProxyWorker().then(([objectUrl, worker]) => {
            try {
              proxyWorker = worker;
              proxyWorker.onerror = (ev) => reject(ev);
              proxyWorker.onmessage = onProxyWorkerMessage;
              initWasmCallbacks = [resolve, reject];
              const message = { type: "init-wasm", in: env2 };
              proxyWorker.postMessage(message);
              temporaryObjectUrl = objectUrl;
            } catch (e) {
              reject(e);
            }
          }, reject);
        });
      } else {
        try {
          await initializeWebAssembly(env2.wasm);
          await initRuntime(env2);
          initialized2 = true;
        } catch (e) {
          aborted2 = true;
          throw e;
        } finally {
          initializing2 = false;
        }
      }
    };
    initializeOrtEp = async (epName) => {
      if (isProxy()) {
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("init-ep", [resolve, reject]);
          const message = { type: "init-ep", in: { epName, env: env2 } };
          proxyWorker.postMessage(message);
        });
      } else {
        await initEp(env2, epName);
      }
    };
    copyFromExternalBuffer2 = async (buffer) => {
      if (isProxy()) {
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("copy-from", [resolve, reject]);
          const message = { type: "copy-from", in: { buffer } };
          proxyWorker.postMessage(message, [buffer.buffer]);
        });
      } else {
        return copyFromExternalBuffer(buffer);
      }
    };
    createSession2 = async (model, options) => {
      if (isProxy()) {
        if (options?.preferredOutputLocation) {
          throw new Error('session option "preferredOutputLocation" is not supported for proxy.');
        }
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("create", [resolve, reject]);
          const message = { type: "create", in: { model, options: { ...options } } };
          const transferable = [];
          if (model instanceof Uint8Array) {
            transferable.push(model.buffer);
          }
          proxyWorker.postMessage(message, transferable);
        });
      } else {
        return createSession(model, options);
      }
    };
    releaseSession2 = async (sessionId) => {
      if (isProxy()) {
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("release", [resolve, reject]);
          const message = { type: "release", in: sessionId };
          proxyWorker.postMessage(message);
        });
      } else {
        releaseSession(sessionId);
      }
    };
    run2 = async (sessionId, inputIndices, inputs, outputIndices, outputs, options) => {
      if (isProxy()) {
        if (inputs.some((t) => t[3] !== "cpu")) {
          throw new Error("input tensor on GPU is not supported for proxy.");
        }
        if (outputs.some((t) => t)) {
          throw new Error("pre-allocated output tensor is not supported for proxy.");
        }
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("run", [resolve, reject]);
          const serializableInputs = inputs;
          const message = { type: "run", in: { sessionId, inputIndices, inputs: serializableInputs, outputIndices, options } };
          proxyWorker.postMessage(message, extractTransferableBuffers(serializableInputs));
        });
      } else {
        return run(sessionId, inputIndices, inputs, outputIndices, outputs, options);
      }
    };
    endProfiling2 = async (sessionId) => {
      if (isProxy()) {
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("end-profiling", [resolve, reject]);
          const message = { type: "end-profiling", in: sessionId };
          proxyWorker.postMessage(message);
        });
      } else {
        endProfiling(sessionId);
      }
    };
  }
});

// web/lib/wasm/session-handler-inference.ts
var encodeTensorMetadata, decodeTensorMetadata, OnnxruntimeWebAssemblySessionHandler;
var init_session_handler_inference2 = __esm({
  "web/lib/wasm/session-handler-inference.ts"() {
    "use strict";
    init_esm();
    init_proxy_wrapper();
    init_wasm_common();
    init_wasm_utils_env();
    init_wasm_utils_load_file();
    encodeTensorMetadata = (tensor, getName) => {
      switch (tensor.location) {
        case "cpu":
          return [tensor.type, tensor.dims, tensor.data, "cpu"];
        case "gpu-buffer":
          return [tensor.type, tensor.dims, { gpuBuffer: tensor.gpuBuffer }, "gpu-buffer"];
        default:
          throw new Error(`invalid data location: ${tensor.location} for ${getName()}`);
      }
    };
    decodeTensorMetadata = (tensor) => {
      switch (tensor[3]) {
        case "cpu":
          return new Tensor2(tensor[0], tensor[2], tensor[1]);
        case "gpu-buffer": {
          const dataType = tensor[0];
          if (!isGpuBufferSupportedType(dataType)) {
            throw new Error(`not supported data type: ${dataType} for deserializing GPU tensor`);
          }
          const { gpuBuffer, download, dispose } = tensor[2];
          return Tensor2.fromGpuBuffer(gpuBuffer, { dataType, dims: tensor[1], download, dispose });
        }
        default:
          throw new Error(`invalid data location: ${tensor[3]}`);
      }
    };
    OnnxruntimeWebAssemblySessionHandler = class {
      async fetchModelAndCopyToWasmMemory(path) {
        return copyFromExternalBuffer2(await loadFile(path));
      }
      async loadModel(pathOrBuffer, options) {
        TRACE_FUNC_BEGIN();
        let model;
        if (typeof pathOrBuffer === "string") {
          if (isNode) {
            model = await loadFile(pathOrBuffer);
          } else {
            model = await this.fetchModelAndCopyToWasmMemory(pathOrBuffer);
          }
        } else {
          model = pathOrBuffer;
        }
        [this.sessionId, this.inputNames, this.outputNames] = await createSession2(model, options);
        TRACE_FUNC_END();
      }
      async dispose() {
        return releaseSession2(this.sessionId);
      }
      async run(feeds, fetches, options) {
        TRACE_FUNC_BEGIN();
        const inputArray = [];
        const inputIndices = [];
        Object.entries(feeds).forEach((kvp) => {
          const name2 = kvp[0];
          const tensor = kvp[1];
          const index = this.inputNames.indexOf(name2);
          if (index === -1) {
            throw new Error(`invalid input '${name2}'`);
          }
          inputArray.push(tensor);
          inputIndices.push(index);
        });
        const outputArray = [];
        const outputIndices = [];
        Object.entries(fetches).forEach((kvp) => {
          const name2 = kvp[0];
          const tensor = kvp[1];
          const index = this.outputNames.indexOf(name2);
          if (index === -1) {
            throw new Error(`invalid output '${name2}'`);
          }
          outputArray.push(tensor);
          outputIndices.push(index);
        });
        const inputs = inputArray.map((t, i) => encodeTensorMetadata(t, () => `input "${this.inputNames[inputIndices[i]]}"`));
        const outputs = outputArray.map(
          (t, i) => t ? encodeTensorMetadata(t, () => `output "${this.outputNames[outputIndices[i]]}"`) : null
        );
        const results = await run2(this.sessionId, inputIndices, inputs, outputIndices, outputs, options);
        const resultMap = {};
        for (let i = 0; i < results.length; i++) {
          resultMap[this.outputNames[outputIndices[i]]] = outputArray[i] ?? decodeTensorMetadata(results[i]);
        }
        TRACE_FUNC_END();
        return resultMap;
      }
      startProfiling() {
      }
      endProfiling() {
        void endProfiling2(this.sessionId);
      }
    };
  }
});

// web/lib/backend-wasm.ts
var initializeFlags, OnnxruntimeWebAssemblyBackend;
var init_backend_wasm = __esm({
  "web/lib/backend-wasm.ts"() {
    "use strict";
    init_esm();
    init_proxy_wrapper();
    init_session_handler_inference2();
    init_wasm_utils_import();
    initializeFlags = () => {
      if (typeof env2.wasm.initTimeout !== "number" || env2.wasm.initTimeout < 0) {
        env2.wasm.initTimeout = 0;
      }
      if (env2.wasm.simd === false) {
        console.warn(
          'Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'
        );
      }
      if (typeof env2.wasm.proxy !== "boolean") {
        env2.wasm.proxy = false;
      }
      if (typeof env2.wasm.trace !== "boolean") {
        env2.wasm.trace = false;
      }
      if (typeof env2.wasm.numThreads !== "number" || !Number.isInteger(env2.wasm.numThreads) || env2.wasm.numThreads <= 0) {
        if (typeof self !== "undefined" && !self.crossOriginIsolated) {
          env2.wasm.numThreads = 1;
        } else {
          const numCpuLogicalCores = typeof navigator === "undefined" ? __require("node:os").cpus().length : navigator.hardwareConcurrency;
          env2.wasm.numThreads = Math.min(4, Math.ceil((numCpuLogicalCores || 1) / 2));
        }
      }
      if (env2.wasm.wasmPaths === void 0 && scriptSrc && scriptSrc.indexOf("blob:") !== 0) {
        env2.wasm.wasmPaths = scriptSrc.substring(0, scriptSrc.lastIndexOf("/") + 1);
      }
    };
    OnnxruntimeWebAssemblyBackend = class {
      /**
       * This function initializes the WebAssembly backend.
       *
       * This function will be called only once for each backend name. It will be called the first time when
       * `ort.InferenceSession.create()` is called with a registered backend name.
       *
       * @param backendName - the registered backend name.
       */
      async init(backendName) {
        initializeFlags();
        await initializeWebAssemblyAndOrtRuntime();
        await initializeOrtEp(backendName);
      }
      async createInferenceSessionHandler(pathOrBuffer, options) {
        const handler = new OnnxruntimeWebAssemblySessionHandler();
        await handler.loadModel(pathOrBuffer, options);
        return Promise.resolve(handler);
      }
    };
  }
});

// web/lib/backend-wasm-inference.ts
var backend_wasm_inference_exports = {};
__export(backend_wasm_inference_exports, {
  wasmBackend: () => wasmBackend
});
var wasmBackend;
var init_backend_wasm_inference = __esm({
  "web/lib/backend-wasm-inference.ts"() {
    "use strict";
    init_backend_wasm();
    wasmBackend = new OnnxruntimeWebAssemblyBackend();
  }
});

// web/lib/index.ts
init_esm();
init_esm();
init_esm();

// web/lib/version.ts
var version2 = "1.19.0";

// web/lib/index.ts
var lib_default = esm_exports;
if (true) {
  const onnxjsBackend2 = (init_backend_onnxjs(), __toCommonJS(backend_onnxjs_exports)).onnxjsBackend;
  registerBackend("webgl", onnxjsBackend2, -10);
}
if (true) {
  const wasmBackend2 = true ? (init_backend_wasm_inference(), __toCommonJS(backend_wasm_inference_exports)).wasmBackend : null.wasmBackend;
  if (false) {
    registerBackend("webgpu", wasmBackend2, 5);
    registerBackend("webnn", wasmBackend2, 5);
  }
  registerBackend("cpu", wasmBackend2, 10);
  registerBackend("wasm", wasmBackend2, 10);
}
Object.defineProperty(env2.versions, "web", { value: version2, enumerable: true });
export {
  InferenceSession2 as InferenceSession,
  TRACE,
  TRACE_FUNC_BEGIN,
  TRACE_FUNC_END,
  Tensor2 as Tensor,
  TrainingSession2 as TrainingSession,
  lib_default as default,
  env2 as env,
  registerBackend
};
/*! Bundled license information:

long/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9saWIvYmFja2VuZC1pbXBsLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vbGliL2JhY2tlbmQudHMiLCAiLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9saWIvdmVyc2lvbi50cyIsICIuLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2xpYi9lbnYtaW1wbC50cyIsICIuLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2xpYi9lbnYudHMiLCAiLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9saWIvdGVuc29yLWNvbnZlcnNpb24taW1wbC50cyIsICIuLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2xpYi90ZW5zb3ItZmFjdG9yeS1pbXBsLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vbGliL3RlbnNvci1pbXBsLXR5cGUtbWFwcGluZy50cyIsICIuLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2xpYi90ZW5zb3ItdXRpbHMtaW1wbC50cyIsICIuLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2xpYi90ZW5zb3ItaW1wbC50cyIsICIuLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2xpYi90ZW5zb3IudHMiLCAiLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9saWIvdHJhY2UudHMiLCAiLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9saWIvaW5mZXJlbmNlLXNlc3Npb24taW1wbC50cyIsICIuLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2xpYi9pbmZlcmVuY2Utc2Vzc2lvbi50cyIsICIuLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2xpYi90ZW5zb3ItY29udmVyc2lvbi50cyIsICIuLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2xpYi90ZW5zb3ItZmFjdG9yeS50cyIsICIuLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2xpYi9vbm54LW1vZGVsLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vbGliL29ubngtdmFsdWUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9saWIvdHJhaW5pbmctc2Vzc2lvbi1pbXBsLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vbGliL3RyYWluaW5nLXNlc3Npb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9saWIvaW5kZXgudHMiLCAiLi4vbGliL29ubnhqcy9pbnN0cnVtZW50LnRzIiwgIi4uL2xpYi9vbm54anMvb3BzZXQudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2d1aWQtdHlwZXNjcmlwdC9kaXN0L2d1aWQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xvbmcvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZsYXRidWZmZXJzL2pzL2ZsYXRidWZmZXJzLm1qcyIsICIuLi9saWIvb25ueGpzL29ydC1zY2hlbWEvZmxhdGJ1ZmZlcnMvb3J0LWdlbmVyYXRlZC50cyIsICIuLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvYXNwcm9taXNlL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9iYXNlNjQvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2V2ZW50ZW1pdHRlci9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvZmxvYXQvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2lucXVpcmUvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL3V0ZjgvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL3Bvb2wvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbG9uZ2JpdHMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbWluaW1hbC5qcyIsICIuLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cml0ZXJfYnVmZmVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yZWFkZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlcl9idWZmZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy9zZXJ2aWNlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9ycGMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3Jvb3RzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9pbmRleC1taW5pbWFsLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL21pbmltYWwuanMiLCAiLi4vbGliL29ubnhqcy9vcnQtc2NoZW1hL3Byb3RvYnVmL29ubnguanMiLCAiLi4vbGliL29ubnhqcy91dGlsLnRzIiwgIi4uL2xpYi9vbm54anMvdGVuc29yLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvZ2xzbC1zb3VyY2UudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC90eXBlcy50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL3V0aWxzLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3BhY2tpbmctdXRpbHMudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvcGFjay50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9yZXNoYXBlLXBhY2tlZC50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy91aW50OC1lbmNvZGUudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvdW5wYWNrLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvdGV4dHVyZS1kYXRhLWVuY29kZXIudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC90ZXh0dXJlLWxheW91dC50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL2luZmVyZW5jZS1oYW5kbGVyLnRzIiwgIi4uL2xpYi9vbm54anMvYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5LnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2JhdGNoLW5vcm1hbGl6YXRpb24udHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9nbHNsLWRlZmluaXRpb25zLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2JpbmFyeS1vcC50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9jYXN0LnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2NvbmNhdC1wYWNrZWQudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvY29uY2F0LnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3VuYXJ5LW9wLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2Z1c2UtdXRpbHMudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvY29udi1ncm91cGVkLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2ltMmNvbC1wYWNrLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL21hdG11bC50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9tYXRtdWwtcGFjay50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9jb252LXBhY2sudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvaW0yY29sLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2RvdC1wcm9kdWN0LnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2NvbnYudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvY29udi10cmFuc3Bvc2UudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvdHJhbnNwb3NlLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2RlcHRoLXRvLXNwYWNlLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2ZsYXR0ZW4udHMiLCAiLi4vbGliL29ubnhqcy9vcGVyYXRvcnMudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvZ2F0aGVyLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2dlbW0udHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvaW1hZ2Utc2NhbGVyLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL2luc3RhbmNlLW5vcm1hbGl6YXRpb24udHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvbHJuLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3BhZC50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9wb29sLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3JlZHVjZS50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9yZXNoYXBlLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3Vwc2FtcGxlLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3Jlc2l6ZS1wYWNrZWQudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvc2hhcGUudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvc2xpY2UudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9vcHMvc29mdG1heC50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9zcGxpdC50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy9zcXVlZXplLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3N1bS50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wcy90aWxlLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvb3BzL3Vuc3F1ZWV6ZS50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL29wLXJlc29sdmUtcnVsZXMudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9nbHNsLWZ1bmN0aW9uLWlubGluZXIudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC90ZXh0dXJlLWxheW91dC1zdHJhdGVneS50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL2dsc2wtY29vcmRpbmF0ZS1saWIudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9nbHNsLWVuY29kaW5nLWxpYi50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL2dsc2wtZnJhZ2NvbG9yLWxpYi50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL2dsc2wtc2hhcGUtdXRpbHMtbGliLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvZ2xzbC12ZWMtbGliLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZHMvd2ViZ2wvZ2xzbC1yZWdpc3RlcmVkLWxpYnMudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC9nbHNsLXByZXByb2Nlc3Nvci50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL3Byb2dyYW0tbWFuYWdlci50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL3RleHR1cmUtbWFuYWdlci50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL3Nlc3Npb24taGFuZGxlci50cyIsICIuLi9saWIvb25ueGpzL2JhY2tlbmRzL3dlYmdsL3dlYmdsLWNvbnRleHQudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy93ZWJnbC93ZWJnbC1jb250ZXh0LWZhY3RvcnkudHMiLCAiLi4vbGliL29ubnhqcy9iYWNrZW5kcy9iYWNrZW5kLXdlYmdsLnRzIiwgIi4uL2xpYi9vbm54anMvYmFja2VuZC50cyIsICIuLi9saWIvb25ueGpzL2V4ZWN1dGlvbi1wbGFuLnRzIiwgIi4uL2xpYi9vbm54anMvYXR0cmlidXRlLnRzIiwgIi4uL2xpYi9vbm54anMvZ3JhcGgudHMiLCAiLi4vbGliL29ubnhqcy9tb2RlbC50cyIsICIuLi9saWIvb25ueGpzL3Nlc3Npb24udHMiLCAiLi4vbGliL29ubnhqcy9zZXNzaW9uLWhhbmRsZXItaW5mZXJlbmNlLnRzIiwgIi4uL2xpYi9iYWNrZW5kLW9ubnhqcy50cyIsICIuLi9saWIvd2FzbS93YXNtLXV0aWxzLWVudi50cyIsICIuLi9saWIvd2FzbS9wcm94eS13b3JrZXIvbWFpbi50cyIsICIuLi9saWIvd2FzbS93YXNtLXV0aWxzLWltcG9ydC50cyIsICIuLi9saWIvd2FzbS93YXNtLWZhY3RvcnkudHMiLCAiLi4vbGliL3dhc20vd2FzbS11dGlscy50cyIsICIuLi9saWIvd2FzbS9ydW4tb3B0aW9ucy50cyIsICIuLi9saWIvd2FzbS9zZXNzaW9uLW9wdGlvbnMudHMiLCAiLi4vbGliL3dhc20vd2FzbS1jb21tb24udHMiLCAiLi4vbGliL3dhc20vd2FzbS11dGlscy1sb2FkLWZpbGUudHMiLCAiLi4vbGliL3dhc20vd2FzbS1jb3JlLWltcGwudHMiLCAiLi4vbGliL3dhc20vcHJveHktd3JhcHBlci50cyIsICIuLi9saWIvd2FzbS9zZXNzaW9uLWhhbmRsZXItaW5mZXJlbmNlLnRzIiwgIi4uL2xpYi9iYWNrZW5kLXdhc20udHMiLCAiLi4vbGliL2JhY2tlbmQtd2FzbS1pbmZlcmVuY2UudHMiLCAiLi4vbGliL2luZGV4LnRzIiwgIi4uL2xpYi92ZXJzaW9uLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtCYWNrZW5kfSBmcm9tICcuL2JhY2tlbmQuanMnO1xuaW1wb3J0IHtJbmZlcmVuY2VTZXNzaW9ufSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcblxuaW50ZXJmYWNlIEJhY2tlbmRJbmZvIHtcbiAgYmFja2VuZDogQmFja2VuZDtcbiAgcHJpb3JpdHk6IG51bWJlcjtcblxuICBpbml0UHJvbWlzZT86IFByb21pc2U8dm9pZD47XG4gIGluaXRpYWxpemVkPzogYm9vbGVhbjtcbiAgYWJvcnRlZD86IGJvb2xlYW47XG4gIGVycm9yPzogc3RyaW5nO1xufVxuXG5jb25zdCBiYWNrZW5kczogTWFwPHN0cmluZywgQmFja2VuZEluZm8+ID0gbmV3IE1hcCgpO1xuY29uc3QgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5OiBzdHJpbmdbXSA9IFtdO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgYmFja2VuZC5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIGFzIGEga2V5IHRvIGxvb2t1cCBhcyBhbiBleGVjdXRpb24gcHJvdmlkZXIuXG4gKiBAcGFyYW0gYmFja2VuZCAtIHRoZSBiYWNrZW5kIG9iamVjdC5cbiAqIEBwYXJhbSBwcmlvcml0eSAtIGFuIGludGVnZXIgaW5kaWNhdGluZyB0aGUgcHJpb3JpdHkgb2YgdGhlIGJhY2tlbmQuIEhpZ2hlciBudW1iZXIgbWVhbnMgaGlnaGVyIHByaW9yaXR5LiBpZiBwcmlvcml0eVxuICogPCAwLCBpdCB3aWxsIGJlIGNvbnNpZGVyZWQgYXMgYSAnYmV0YScgdmVyc2lvbiBhbmQgd2lsbCBub3QgYmUgdXNlZCBhcyBhIGZhbGxiYWNrIGJhY2tlbmQgYnkgZGVmYXVsdC5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBjb25zdCByZWdpc3RlckJhY2tlbmQgPSAobmFtZTogc3RyaW5nLCBiYWNrZW5kOiBCYWNrZW5kLCBwcmlvcml0eTogbnVtYmVyKTogdm9pZCA9PiB7XG4gIGlmIChiYWNrZW5kICYmIHR5cGVvZiBiYWNrZW5kLmluaXQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGJhY2tlbmQuY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCBjdXJyZW50QmFja2VuZCA9IGJhY2tlbmRzLmdldChuYW1lKTtcbiAgICBpZiAoY3VycmVudEJhY2tlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYmFja2VuZHMuc2V0KG5hbWUsIHtiYWNrZW5kLCBwcmlvcml0eX0pO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudEJhY2tlbmQucHJpb3JpdHkgPiBwcmlvcml0eSkge1xuICAgICAgLy8gc2FtZSBuYW1lIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCB3aXRoIGEgaGlnaGVyIHByaW9yaXR5LiBza2lwIHJlZ2lzdGVyYXRpb24uXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChjdXJyZW50QmFja2VuZC5wcmlvcml0eSA9PT0gcHJpb3JpdHkpIHtcbiAgICAgIGlmIChjdXJyZW50QmFja2VuZC5iYWNrZW5kICE9PSBiYWNrZW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlZ2lzdGVyIGJhY2tlbmQgXCIke25hbWV9XCIgdXNpbmcgcHJpb3JpdHkgJHtwcmlvcml0eX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJpb3JpdHkgPj0gMCkge1xuICAgICAgY29uc3QgaSA9IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5pbmRleE9mKG5hbWUpO1xuICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgIGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChiYWNrZW5kcy5nZXQoYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5W2ldKSEucHJpb3JpdHkgPD0gcHJpb3JpdHkpIHtcbiAgICAgICAgICBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkuc3BsaWNlKGksIDAsIG5hbWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5LnB1c2gobmFtZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vdCBhIHZhbGlkIGJhY2tlbmQnKTtcbn07XG5cbi8qKlxuICogVHJ5IHRvIHJlc29sdmUgYW5kIGluaXRpYWxpemUgYSBiYWNrZW5kLlxuICpcbiAqIEBwYXJhbSBiYWNrZW5kTmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBiYWNrZW5kLlxuICogQHJldHVybnMgdGhlIGJhY2tlbmQgaW5zdGFuY2UgaWYgcmVzb2x2ZWQgYW5kIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseSwgb3IgYW4gZXJyb3IgbWVzc2FnZSBpZiBmYWlsZWQuXG4gKi9cbmNvbnN0IHRyeVJlc29sdmVBbmRJbml0aWFsaXplQmFja2VuZCA9IGFzeW5jKGJhY2tlbmROYW1lOiBzdHJpbmcpOiBQcm9taXNlPEJhY2tlbmR8c3RyaW5nPiA9PiB7XG4gIGNvbnN0IGJhY2tlbmRJbmZvID0gYmFja2VuZHMuZ2V0KGJhY2tlbmROYW1lKTtcbiAgaWYgKCFiYWNrZW5kSW5mbykge1xuICAgIHJldHVybiAnYmFja2VuZCBub3QgZm91bmQuJztcbiAgfVxuXG4gIGlmIChiYWNrZW5kSW5mby5pbml0aWFsaXplZCkge1xuICAgIHJldHVybiBiYWNrZW5kSW5mby5iYWNrZW5kO1xuICB9IGVsc2UgaWYgKGJhY2tlbmRJbmZvLmFib3J0ZWQpIHtcbiAgICByZXR1cm4gYmFja2VuZEluZm8uZXJyb3IhO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGlzSW5pdGlhbGl6aW5nID0gISFiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICB0cnkge1xuICAgICAgaWYgKCFpc0luaXRpYWxpemluZykge1xuICAgICAgICBiYWNrZW5kSW5mby5pbml0UHJvbWlzZSA9IGJhY2tlbmRJbmZvLmJhY2tlbmQuaW5pdChiYWNrZW5kTmFtZSk7XG4gICAgICB9XG4gICAgICBhd2FpdCBiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICAgIGJhY2tlbmRJbmZvLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBiYWNrZW5kSW5mby5iYWNrZW5kO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghaXNJbml0aWFsaXppbmcpIHtcbiAgICAgICAgYmFja2VuZEluZm8uZXJyb3IgPSBgJHtlfWA7XG4gICAgICAgIGJhY2tlbmRJbmZvLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhY2tlbmRJbmZvLmVycm9yITtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZGVsZXRlIGJhY2tlbmRJbmZvLmluaXRQcm9taXNlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZXNvbHZlIGV4ZWN1dGlvbiBwcm92aWRlcnMgZnJvbSB0aGUgc3BlY2lmaWMgc2Vzc2lvbiBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gdGhlIHNlc3Npb24gb3B0aW9ucyBvYmplY3QuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHR1cGxlIG9mIGFuIGluaXRpYWxpemVkIGJhY2tlbmQgaW5zdGFuY2UgYW5kIGEgc2Vzc2lvbiBvcHRpb25zIG9iamVjdCB3aXRoXG4gKiBmaWx0ZXJlZCBFUCBsaXN0LlxuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGNvbnN0IHJlc29sdmVCYWNrZW5kQW5kRXhlY3V0aW9uUHJvdmlkZXJzID0gYXN5bmMob3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6XG4gICAgUHJvbWlzZTxbYmFja2VuZDogQmFja2VuZCwgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9uc10+ID0+IHtcbiAgICAgIC8vIGV4dHJhY3QgYmFja2VuZCBoaW50cyBmcm9tIHNlc3Npb24gb3B0aW9uc1xuICAgICAgY29uc3QgZXBzID0gb3B0aW9ucy5leGVjdXRpb25Qcm92aWRlcnMgfHwgW107XG4gICAgICBjb25zdCBiYWNrZW5kSGludHMgPSBlcHMubWFwKGkgPT4gdHlwZW9mIGkgPT09ICdzdHJpbmcnID8gaSA6IGkubmFtZSk7XG4gICAgICBjb25zdCBiYWNrZW5kTmFtZXMgPSBiYWNrZW5kSGludHMubGVuZ3RoID09PSAwID8gYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5IDogYmFja2VuZEhpbnRzO1xuXG4gICAgICAvLyB0cnkgdG8gcmVzb2x2ZSBhbmQgaW5pdGlhbGl6ZSBhbGwgcmVxdWVzdGVkIGJhY2tlbmRzXG4gICAgICBsZXQgYmFja2VuZDogQmFja2VuZHx1bmRlZmluZWQ7XG4gICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgIGNvbnN0IGF2YWlsYWJsZUJhY2tlbmROYW1lcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgZm9yIChjb25zdCBiYWNrZW5kTmFtZSBvZiBiYWNrZW5kTmFtZXMpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZVJlc3VsdCA9IGF3YWl0IHRyeVJlc29sdmVBbmRJbml0aWFsaXplQmFja2VuZChiYWNrZW5kTmFtZSk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZVJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaCh7bmFtZTogYmFja2VuZE5hbWUsIGVycjogcmVzb2x2ZVJlc3VsdH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghYmFja2VuZCkge1xuICAgICAgICAgICAgYmFja2VuZCA9IHJlc29sdmVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiYWNrZW5kID09PSByZXNvbHZlUmVzdWx0KSB7XG4gICAgICAgICAgICBhdmFpbGFibGVCYWNrZW5kTmFtZXMuYWRkKGJhY2tlbmROYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gaWYgbm8gYmFja2VuZCBpcyBhdmFpbGFibGUsIHRocm93IGVycm9yLlxuICAgICAgaWYgKCFiYWNrZW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gYXZhaWxhYmxlIGJhY2tlbmQgZm91bmQuIEVSUjogJHtlcnJvcnMubWFwKGUgPT4gYFske2UubmFtZX1dICR7ZS5lcnJ9YCkuam9pbignLCAnKX1gKTtcbiAgICAgIH1cblxuICAgICAgLy8gZm9yIGVhY2ggZXhwbGljaXRseSByZXF1ZXN0ZWQgYmFja2VuZCwgaWYgaXQncyBub3QgYXZhaWxhYmxlLCBvdXRwdXQgd2FybmluZyBtZXNzYWdlLlxuICAgICAgZm9yIChjb25zdCB7bmFtZSwgZXJyfSBvZiBlcnJvcnMpIHtcbiAgICAgICAgaWYgKGJhY2tlbmRIaW50cy5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgY29uc29sZS53YXJuKGByZW1vdmluZyByZXF1ZXN0ZWQgZXhlY3V0aW9uIHByb3ZpZGVyIFwiJHtcbiAgICAgICAgICAgICAgbmFtZX1cIiBmcm9tIHNlc3Npb24gb3B0aW9ucyBiZWNhdXNlIGl0IGlzIG5vdCBhdmFpbGFibGU6ICR7ZXJyfWApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZpbHRlcmVkRXBzID0gZXBzLmZpbHRlcihpID0+IGF2YWlsYWJsZUJhY2tlbmROYW1lcy5oYXModHlwZW9mIGkgPT09ICdzdHJpbmcnID8gaSA6IGkubmFtZSkpO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBiYWNrZW5kLCBuZXcgUHJveHkob3B0aW9ucywge1xuICAgICAgICAgIGdldDogKHRhcmdldCwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdleGVjdXRpb25Qcm92aWRlcnMnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZEVwcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIF07XG4gICAgfTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtJbmZlcmVuY2VTZXNzaW9ufSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcbmltcG9ydCB7T25ueFZhbHVlfSBmcm9tICcuL29ubngtdmFsdWUuanMnO1xuaW1wb3J0IHtUcmFpbmluZ1Nlc3Npb259IGZyb20gJy4vdHJhaW5pbmctc2Vzc2lvbi5qcyc7XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgU2Vzc2lvbkhhbmRsZXIge1xuICB0eXBlIEZlZWRzVHlwZSA9IHtbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlfTtcbiAgdHlwZSBGZXRjaGVzVHlwZSA9IHtbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlIHwgbnVsbH07XG4gIHR5cGUgUmV0dXJuVHlwZSA9IHtbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlfTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHNoYXJlZCBTZXNzaW9uSGFuZGxlciBmdW5jdGlvbmFsaXR5XG4gKlxuICogQGlnbm9yZVxuICovXG5pbnRlcmZhY2UgU2Vzc2lvbkhhbmRsZXIge1xuICBkaXNwb3NlKCk6IFByb21pc2U8dm9pZD47XG5cbiAgcmVhZG9ubHkgaW5wdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG4gIHJlYWRvbmx5IG91dHB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBoYW5kbGVyIGluc3RhbmNlIG9mIGFuIGluZmVyZW5jZSBzZXNzaW9uLlxuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbmZlcmVuY2VTZXNzaW9uSGFuZGxlciBleHRlbmRzIFNlc3Npb25IYW5kbGVyIHtcbiAgc3RhcnRQcm9maWxpbmcoKTogdm9pZDtcbiAgZW5kUHJvZmlsaW5nKCk6IHZvaWQ7XG5cbiAgcnVuKGZlZWRzOiBTZXNzaW9uSGFuZGxlci5GZWVkc1R5cGUsIGZldGNoZXM6IFNlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlLFxuICAgICAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTxTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlPjtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBoYW5kbGVyIGluc3RhbmNlIG9mIGEgdHJhaW5pbmcgaW5mZXJlbmNlIHNlc3Npb24uXG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYWluaW5nU2Vzc2lvbkhhbmRsZXIgZXh0ZW5kcyBTZXNzaW9uSGFuZGxlciB7XG4gIHJlYWRvbmx5IGV2YWxJbnB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcbiAgcmVhZG9ubHkgZXZhbE91dHB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICBsYXp5UmVzZXRHcmFkKCk6IFByb21pc2U8dm9pZD47XG4gIHJ1blRyYWluU3RlcChcbiAgICAgIGZlZWRzOiBTZXNzaW9uSGFuZGxlci5GZWVkc1R5cGUsIGZldGNoZXM6IFNlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlLFxuICAgICAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTxTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlPjtcbiAgcnVuT3B0aW1pemVyU3RlcChvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+O1xuICBydW5FdmFsU3RlcChcbiAgICAgIGZlZWRzOiBTZXNzaW9uSGFuZGxlci5GZWVkc1R5cGUsIGZldGNoZXM6IFNlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlLFxuICAgICAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTxTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlPjtcblxuICBnZXRQYXJhbWV0ZXJzU2l6ZSh0cmFpbmFibGVPbmx5OiBib29sZWFuKTogUHJvbWlzZTxudW1iZXI+O1xuICBsb2FkUGFyYW1ldGVyc0J1ZmZlcihidWZmZXI6IFVpbnQ4QXJyYXksIHRyYWluYWJsZU9ubHk6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+O1xuICBnZXRDb250aWd1b3VzUGFyYW1ldGVycyh0cmFpbmFibGVPbmx5OiBib29sZWFuKTogUHJvbWlzZTxPbm54VmFsdWU+O1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIGJhY2tlbmQgdGhhdCBwcm92aWRlcyBpbXBsZW1lbnRhdGlvbiBvZiBtb2RlbCBpbmZlcmVuY2luZy5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmFja2VuZCB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBiYWNrZW5kIGFzeW5jaHJvbm91c2x5LiBTaG91bGQgdGhyb3cgd2hlbiBmYWlsZWQuXG4gICAqL1xuICBpbml0KGJhY2tlbmROYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKHVyaU9yQnVmZmVyOiBzdHJpbmd8VWludDhBcnJheSwgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOlxuICAgICAgUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj47XG5cbiAgY3JlYXRlVHJhaW5pbmdTZXNzaW9uSGFuZGxlcj9cbiAgICAgIChjaGVja3BvaW50U3RhdGVVcmlPckJ1ZmZlcjogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyLCB0cmFpbk1vZGVsVXJpT3JCdWZmZXI6IFRyYWluaW5nU2Vzc2lvbi5VcmlPckJ1ZmZlcixcbiAgICAgICBldmFsTW9kZWxVcmlPckJ1ZmZlcjogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyLCBvcHRpbWl6ZXJNb2RlbFVyaU9yQnVmZmVyOiBUcmFpbmluZ1Nlc3Npb24uVXJpT3JCdWZmZXIsXG4gICAgICAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8VHJhaW5pbmdTZXNzaW9uSGFuZGxlcj47XG59XG5cbmV4cG9ydCB7cmVnaXN0ZXJCYWNrZW5kfSBmcm9tICcuL2JhY2tlbmQtaW1wbC5qcyc7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgL2pzL3NjcmlwdHMvdXBkYXRlLXZlcnNpb24udHNcbi8vIERvIG5vdCBtb2RpZnkgZmlsZSBjb250ZW50IG1hbnVhbGx5LlxuXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9ICcxLjE5LjAnO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0Vudn0gZnJvbSAnLi9lbnYuanMnO1xuaW1wb3J0IHt2ZXJzaW9ufSBmcm9tICcuL3ZlcnNpb24uanMnO1xuXG50eXBlIExvZ0xldmVsVHlwZSA9IEVudlsnbG9nTGV2ZWwnXTtcblxubGV0IGxvZ0xldmVsVmFsdWU6IFJlcXVpcmVkPExvZ0xldmVsVHlwZT4gPSAnd2FybmluZyc7XG5cbmV4cG9ydCBjb25zdCBlbnY6IEVudiA9IHtcbiAgd2FzbToge30gYXMgRW52LldlYkFzc2VtYmx5RmxhZ3MsXG4gIHdlYmdsOiB7fSBhcyBFbnYuV2ViR0xGbGFncyxcbiAgd2ViZ3B1OiB7fSBhcyBFbnYuV2ViR3B1RmxhZ3MsXG4gIHZlcnNpb25zOiB7Y29tbW9uOiB2ZXJzaW9ufSxcblxuICBzZXQgbG9nTGV2ZWwodmFsdWU6IExvZ0xldmVsVHlwZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8IFsndmVyYm9zZScsICdpbmZvJywgJ3dhcm5pbmcnLCAnZXJyb3InLCAnZmF0YWwnXS5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHt2YWx1ZX1gKTtcbiAgICB9XG4gICAgbG9nTGV2ZWxWYWx1ZSA9IHZhbHVlO1xuICB9LFxuICBnZXQgbG9nTGV2ZWwoKTogUmVxdWlyZWQ8TG9nTGV2ZWxUeXBlPiB7XG4gICAgcmV0dXJuIGxvZ0xldmVsVmFsdWU7XG4gIH0sXG59O1xuXG4vLyBzZXQgcHJvcGVydHkgJ2xvZ0xldmVsJyBzbyB0aGF0IHRoZXkgY2FuIGJlIGNvcnJlY3RseSB0cmFuc2ZlcnJlZCB0byB3b3JrZXIgYnkgYHBvc3RNZXNzYWdlKClgLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGVudiwgJ2xvZ0xldmVsJywge2VudW1lcmFibGU6IHRydWV9KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtlbnYgYXMgZW52SW1wbH0gZnJvbSAnLi9lbnYtaW1wbC5qcyc7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBFbnYge1xuICBleHBvcnQgdHlwZSBXYXNtUGF0aFByZWZpeCA9IHN0cmluZztcbiAgZXhwb3J0IGludGVyZmFjZSBXYXNtRmlsZVBhdGhzIHtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHRoZSBvdmVycmlkZSBwYXRoIGZvciB0aGUgbWFpbiAud2FzbSBmaWxlLlxuICAgICAqXG4gICAgICogVGhpcyBwYXRoIHNob3VsZCBiZSBhbiBhYnNvbHV0ZSBwYXRoLlxuICAgICAqXG4gICAgICogSWYgbm90IG1vZGlmaWVkLCB0aGUgZmlsZW5hbWUgb2YgdGhlIC53YXNtIGZpbGUgaXM6XG4gICAgICogLSBgb3J0LXdhc20tc2ltZC10aHJlYWRlZC53YXNtYCBmb3IgZGVmYXVsdCBidWlsZFxuICAgICAqIC0gYG9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtYCBmb3IgSlNFUCBidWlsZCAod2l0aCBXZWJHUFUgYW5kIFdlYk5OKVxuICAgICAqIC0gYG9ydC10cmFpbmluZy13YXNtLXNpbWQtdGhyZWFkZWQud2FzbWAgZm9yIHRyYWluaW5nIGJ1aWxkXG4gICAgICovXG4gICAgd2FzbT86IFVSTHxzdHJpbmc7XG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB0aGUgb3ZlcnJpZGUgcGF0aCBmb3IgdGhlIG1haW4gLm1qcyBmaWxlLlxuICAgICAqXG4gICAgICogVGhpcyBwYXRoIHNob3VsZCBiZSBhbiBhYnNvbHV0ZSBwYXRoLlxuICAgICAqXG4gICAgICogSWYgbm90IG1vZGlmaWVkLCB0aGUgZmlsZW5hbWUgb2YgdGhlIC5tanMgZmlsZSBpczpcbiAgICAgKiAtIGBvcnQtd2FzbS1zaW1kLXRocmVhZGVkLm1qc2AgZm9yIGRlZmF1bHQgYnVpbGRcbiAgICAgKiAtIGBvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAubWpzYCBmb3IgSlNFUCBidWlsZCAod2l0aCBXZWJHUFUgYW5kIFdlYk5OKVxuICAgICAqIC0gYG9ydC10cmFpbmluZy13YXNtLXNpbWQtdGhyZWFkZWQubWpzYCBmb3IgdHJhaW5pbmcgYnVpbGRcbiAgICAgKi9cbiAgICBtanM/OiBVUkx8c3RyaW5nO1xuICB9XG4gIGV4cG9ydCB0eXBlIFdhc21QcmVmaXhPckZpbGVQYXRocyA9IFdhc21QYXRoUHJlZml4fFdhc21GaWxlUGF0aHM7XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViQXNzZW1ibHlGbGFncyB7XG4gICAgLyoqXG4gICAgICogc2V0IG9yIGdldCBudW1iZXIgb2YgdGhyZWFkKHMpLiBJZiBvbWl0dGVkIG9yIHNldCB0byAwLCBudW1iZXIgb2YgdGhyZWFkKHMpIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSBzeXN0ZW0uIElmIHNldFxuICAgICAqIHRvIDEsIG5vIHdvcmtlciB0aHJlYWQgd2lsbCBiZSBzcGF3bmVkLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IHdoZW4gV2ViQXNzZW1ibHkgbXVsdGl0aHJlYWQgZmVhdHVyZSBpcyBhdmFpbGFibGUgaW4gY3VycmVudCBjb250ZXh0LlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgMGBcbiAgICAgKi9cbiAgICBudW1UaHJlYWRzPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogc2V0IG9yIGdldCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRvIGVuYWJsZSBTSU1ELiBJZiBzZXQgdG8gZmFsc2UsIFNJTUQgd2lsbCBiZSBmb3JjZWx5IGRpc2FibGVkLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IHdoZW4gV2ViQXNzZW1ibHkgU0lNRCBmZWF0dXJlIGlzIGF2YWlsYWJsZSBpbiBjdXJyZW50IGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQuIFNpbmNlIFNJTUQgaXMgc3VwcG9ydGVkIGJ5IGFsbCBtYWpvciBKYXZhU2NyaXB0IGVuZ2luZXMsIG5vbi1TSU1EXG4gICAgICogYnVpbGQgaXMgbm8gbG9uZ2VyIHByb3ZpZGVkLiBUaGlzIHByb3BlcnR5IHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZS5cbiAgICAgKiBAZGVmYXVsdFZhbHVlIGB0cnVlYFxuICAgICAqL1xuICAgIHNpbWQ/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogc2V0IG9yIGdldCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRvIGVuYWJsZSB0cmFjZS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgZW52LnRyYWNlYCBpbnN0ZWFkLiBJZiBgZW52LnRyYWNlYCBpcyBzZXQsIHRoaXMgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgICAqL1xuICAgIHRyYWNlPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgYSBudW1iZXIgc3BlY2lmeWluZyB0aGUgdGltZW91dCBmb3IgaW5pdGlhbGl6YXRpb24gb2YgV2ViQXNzZW1ibHkgYmFja2VuZCwgaW4gbWlsbGlzZWNvbmRzLiBBIHplcm9cbiAgICAgKiB2YWx1ZSBpbmRpY2F0ZXMgbm8gdGltZW91dCBpcyBzZXQuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGAwYFxuICAgICAqL1xuICAgIGluaXRUaW1lb3V0PzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogU2V0IGEgY3VzdG9tIFVSTCBwcmVmaXggdG8gdGhlIC53YXNtLy5tanMgZmlsZXMsIG9yIGFuIG9iamVjdCBvZiBvdmVycmlkZXMgZm9yIGJvdGggLndhc20vLm1qcyBmaWxlLiBUaGUgb3ZlcnJpZGVcbiAgICAgKiBwYXRoIHNob3VsZCBiZSBhbiBhYnNvbHV0ZSBwYXRoLlxuICAgICAqL1xuICAgIHdhc21QYXRocz86IFdhc21QcmVmaXhPckZpbGVQYXRocztcblxuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgYSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0byBwcm94eSB0aGUgZXhlY3V0aW9uIG9mIG1haW4gdGhyZWFkIHRvIGEgd29ya2VyIHRocmVhZC5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgICAqL1xuICAgIHByb3h5PzogYm9vbGVhbjtcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR0xGbGFncyB7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgV2ViR0wgQ29udGV4dCBJRCAod2ViZ2wgb3Igd2ViZ2wyKS5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYCd3ZWJnbDInYFxuICAgICAqL1xuICAgIGNvbnRleHRJZD86ICd3ZWJnbCd8J3dlYmdsMic7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBXZWJHTCByZW5kZXJpbmcgY29udGV4dC5cbiAgICAgKi9cbiAgICByZWFkb25seSBjb250ZXh0OiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgbWF4aW11bSBiYXRjaCBzaXplIGZvciBtYXRtdWwuIDAgbWVhbnMgdG8gZGlzYWJsZSBiYXRjaGluZy5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgbWF0bXVsTWF4QmF0Y2hTaXplPzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIHRleHR1cmUgY2FjaGUgbW9kZS5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYCdmdWxsJ2BcbiAgICAgKi9cbiAgICB0ZXh0dXJlQ2FjaGVNb2RlPzogJ2luaXRpYWxpemVyT25seSd8J2Z1bGwnO1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIHBhY2tlZCB0ZXh0dXJlIG1vZGVcbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgICAqL1xuICAgIHBhY2s/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgd2hldGhlciBlbmFibGUgYXN5bmMgZG93bmxvYWQuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICAgKi9cbiAgICBhc3luYz86IGJvb2xlYW47XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkdwdVByb2ZpbGluZ0RhdGFWMVRlbnNvck1ldGFkYXRhIHtcbiAgICBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcbiAgICBkYXRhVHlwZTogc3RyaW5nO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR3B1UHJvZmlsaW5nRGF0YVYxIHtcbiAgICB2ZXJzaW9uOiAxO1xuICAgIGlucHV0c01ldGFkYXRhOiByZWFkb25seSBXZWJHcHVQcm9maWxpbmdEYXRhVjFUZW5zb3JNZXRhZGF0YVtdO1xuICAgIG91dHB1dHNNZXRhZGF0YTogcmVhZG9ubHkgV2ViR3B1UHJvZmlsaW5nRGF0YVYxVGVuc29yTWV0YWRhdGFbXTtcbiAgICBrZXJuZWxJZDogbnVtYmVyO1xuICAgIGtlcm5lbFR5cGU6IHN0cmluZztcbiAgICBrZXJuZWxOYW1lOiBzdHJpbmc7XG4gICAgcHJvZ3JhbU5hbWU6IHN0cmluZztcbiAgICBzdGFydFRpbWU6IG51bWJlcjtcbiAgICBlbmRUaW1lOiBudW1iZXI7XG4gIH1cblxuICBleHBvcnQgdHlwZSBXZWJHcHVQcm9maWxpbmdEYXRhID0gV2ViR3B1UHJvZmlsaW5nRGF0YVYxO1xuXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR3B1RmxhZ3Mge1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIHByb2ZpbGluZyBtb2RlLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGBlbnYud2ViZ3B1LnByb2ZpbGluZy5tb2RlYCBpbnN0ZWFkLiBJZiBgZW52LndlYmdwdS5wcm9maWxpbmcubW9kZWAgaXMgc2V0LCB0aGlzIHByb3BlcnR5IHdpbGwgYmVcbiAgICAgKiBpZ25vcmVkLlxuICAgICAqL1xuICAgIHByb2ZpbGluZ01vZGU/OiAnb2ZmJ3wnZGVmYXVsdCc7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgcHJvZmlsaW5nIGNvbmZpZ3VyYXRpb24uXG4gICAgICovXG4gICAgcHJvZmlsaW5nPzoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgb3IgZ2V0IHRoZSBwcm9maWxpbmcgbW9kZS5cbiAgICAgICAqXG4gICAgICAgKiBAZGVmYXVsdFZhbHVlIGAnb2ZmJ2BcbiAgICAgICAqL1xuICAgICAgbW9kZT86ICdvZmYnfCdkZWZhdWx0JztcblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgb3IgZ2V0IGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBhIHByb2ZpbGluZyBkYXRhIGlzIHJlY2VpdmVkLiBJZiBub3Qgc2V0LCB0aGUgcHJvZmlsaW5nIGRhdGEgd2lsbCBiZVxuICAgICAgICogcHJpbnRlZCB0byBjb25zb2xlLlxuICAgICAgICovXG4gICAgICBvbmRhdGE/OiAoZGF0YTogV2ViR3B1UHJvZmlsaW5nRGF0YSkgPT4gdm9pZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIHBvd2VyIHByZWZlcmVuY2UuXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgb25seSBoYXMgZWZmZWN0IGJlZm9yZSB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuIFRoZSB2YWx1ZSB3aWxsIGJlXG4gICAgICogdXNlZCBhcyBvcHRpb25zIGZvciBgbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcigpYC5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9ncHV3ZWIuZ2l0aHViLmlvL2dwdXdlYi8jZGljdGRlZi1ncHVyZXF1ZXN0YWRhcHRlcm9wdGlvbnN9IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGB1bmRlZmluZWRgXG4gICAgICovXG4gICAgcG93ZXJQcmVmZXJlbmNlPzogJ2xvdy1wb3dlcid8J2hpZ2gtcGVyZm9ybWFuY2UnO1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIGZvcmNlIGZhbGxiYWNrIGFkYXB0ZXIgZmxhZy5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSBvbmx5IGhhcyBlZmZlY3QgYmVmb3JlIHRoZSBmaXJzdCBXZWJHUFUgaW5mZXJlbmNlIHNlc3Npb24gaXMgY3JlYXRlZC4gVGhlIHZhbHVlIHdpbGwgYmVcbiAgICAgKiB1c2VkIGFzIG9wdGlvbnMgZm9yIGBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKClgLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBodHRwczovL2dwdXdlYi5naXRodWIuaW8vZ3B1d2ViLyNkaWN0ZGVmLWdwdXJlcXVlc3RhZGFwdGVyb3B0aW9uc30gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYHVuZGVmaW5lZGBcbiAgICAgKi9cbiAgICBmb3JjZUZhbGxiYWNrQWRhcHRlcj86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgYWRhcHRlciBmb3IgV2ViR1BVLlxuICAgICAqXG4gICAgICogU2V0dGluZyB0aGlzIHByb3BlcnR5IG9ubHkgaGFzIGVmZmVjdCBiZWZvcmUgdGhlIGZpcnN0IFdlYkdQVSBpbmZlcmVuY2Ugc2Vzc2lvbiBpcyBjcmVhdGVkLiBUaGUgdmFsdWUgd2lsbCBiZVxuICAgICAqIHVzZWQgYXMgdGhlIEdQVSBhZGFwdGVyIGZvciB0aGUgdW5kZXJseWluZyBXZWJHUFUgYmFja2VuZCB0byBjcmVhdGUgR1BVIGRldmljZS5cbiAgICAgKlxuICAgICAqIElmIHRoaXMgcHJvcGVydHkgaXMgbm90IHNldCwgaXQgd2lsbCBiZSBhdmFpbGFibGUgdG8gZ2V0IGFmdGVyIHRoZSBmaXJzdCBXZWJHUFUgaW5mZXJlbmNlIHNlc3Npb24gaXMgY3JlYXRlZC4gVGhlXG4gICAgICogdmFsdWUgd2lsbCBiZSB0aGUgR1BVIGFkYXB0ZXIgdGhhdCBjcmVhdGVkIGJ5IHRoZSB1bmRlcmx5aW5nIFdlYkdQVSBiYWNrZW5kLlxuICAgICAqXG4gICAgICogV2hlbiB1c2Ugd2l0aCBUeXBlU2NyaXB0LCB0aGUgdHlwZSBvZiB0aGlzIHByb3BlcnR5IGlzIGBHUFVBZGFwdGVyYCBkZWZpbmVkIGluIFwiQHdlYmdwdS90eXBlc1wiLlxuICAgICAqIFVzZSBgY29uc3QgYWRhcHRlciA9IGVudi53ZWJncHUuYWRhcHRlciBhcyBHUFVBZGFwdGVyO2AgaW4gVHlwZVNjcmlwdCB0byBhY2Nlc3MgdGhpcyBwcm9wZXJ0eSB3aXRoIGNvcnJlY3QgdHlwZS5cbiAgICAgKlxuICAgICAqIHNlZSBjb21tZW50cyBvbiB7QGxpbmsgVGVuc29yLkdwdUJ1ZmZlclR5cGV9XG4gICAgICovXG4gICAgYWRhcHRlcjogdW5rbm93bjtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRldmljZSBmb3IgV2ViR1BVLlxuICAgICAqXG4gICAgICogVGhpcyBwcm9wZXJ0eSBpcyBvbmx5IGF2YWlsYWJsZSBhZnRlciB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBXaGVuIHVzZSB3aXRoIFR5cGVTY3JpcHQsIHRoZSB0eXBlIG9mIHRoaXMgcHJvcGVydHkgaXMgYEdQVURldmljZWAgZGVmaW5lZCBpbiBcIkB3ZWJncHUvdHlwZXNcIi5cbiAgICAgKiBVc2UgYGNvbnN0IGRldmljZSA9IGVudi53ZWJncHUuZGV2aWNlIGFzIEdQVURldmljZTtgIGluIFR5cGVTY3JpcHQgdG8gYWNjZXNzIHRoaXMgcHJvcGVydHkgd2l0aCBjb3JyZWN0IHR5cGUuXG4gICAgICpcbiAgICAgKiBzZWUgY29tbWVudHMgb24ge0BsaW5rIFRlbnNvci5HcHVCdWZmZXJUeXBlfSBmb3IgbW9yZSBkZXRhaWxzIGFib3V0IHdoeSBub3QgdXNlIHR5cGVzIGRlZmluZWQgaW4gXCJAd2ViZ3B1L3R5cGVzXCIuXG4gICAgICovXG4gICAgcmVhZG9ubHkgZGV2aWNlOiB1bmtub3duO1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgd2hldGhlciB2YWxpZGF0ZSBpbnB1dCBjb250ZW50LlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAgICovXG4gICAgdmFsaWRhdGVJbnB1dENvbnRlbnQ/OiBib29sZWFuO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRW52IHtcbiAgLyoqXG4gICAqIHNldCB0aGUgc2V2ZXJpdHkgbGV2ZWwgZm9yIGxvZ2dpbmcuXG4gICAqXG4gICAqIEBkZWZhdWx0VmFsdWUgYCd3YXJuaW5nJ2BcbiAgICovXG4gIGxvZ0xldmVsPzogJ3ZlcmJvc2UnfCdpbmZvJ3wnd2FybmluZyd8J2Vycm9yJ3wnZmF0YWwnO1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZSB3aGV0aGVyIHJ1biBpbiBkZWJ1ZyBtb2RlLlxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICovXG4gIGRlYnVnPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogc2V0IG9yIGdldCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRvIGVuYWJsZSB0cmFjZS5cbiAgICpcbiAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAqL1xuICB0cmFjZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEdldCB2ZXJzaW9uIG9mIHRoZSBjdXJyZW50IHBhY2thZ2UuXG4gICAqL1xuICByZWFkb25seSB2ZXJzaW9uczoge1xuICAgIHJlYWRvbmx5IGNvbW1vbjogc3RyaW5nO1xuICAgIHJlYWRvbmx5IHdlYj86IHN0cmluZztcbiAgICByZWFkb25seSBub2RlPzogc3RyaW5nO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICByZWFkb25seSAncmVhY3QtbmF0aXZlJz86IHN0cmluZztcbiAgfTtcblxuICAvKipcbiAgICogUmVwcmVzZW50IGEgc2V0IG9mIGZsYWdzIGZvciBXZWJBc3NlbWJseVxuICAgKi9cbiAgcmVhZG9ubHkgd2FzbTogRW52LldlYkFzc2VtYmx5RmxhZ3M7XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudCBhIHNldCBvZiBmbGFncyBmb3IgV2ViR0xcbiAgICovXG4gIHJlYWRvbmx5IHdlYmdsOiBFbnYuV2ViR0xGbGFncztcblxuICAvKipcbiAgICogUmVwcmVzZW50IGEgc2V0IG9mIGZsYWdzIGZvciBXZWJHUFVcbiAgICovXG4gIHJlYWRvbmx5IHdlYmdwdTogRW52LldlYkdwdUZsYWdzO1xuXG4gIFtuYW1lOiBzdHJpbmddOiB1bmtub3duO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIHNldCBvZiBmbGFncyBhcyBhIGdsb2JhbCBzaW5nbGV0b24uXG4gKi9cbmV4cG9ydCBjb25zdCBlbnY6IEVudiA9IGVudkltcGw7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yVG9EYXRhVXJsT3B0aW9ucywgVGVuc29yVG9JbWFnZURhdGFPcHRpb25zfSBmcm9tICcuL3RlbnNvci1jb252ZXJzaW9uLmpzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuL3RlbnNvci5qcyc7XG5cbi8qKlxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLnRvRGF0YVVSTCgpXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JUb0RhdGFVUkwgPSAodGVuc29yOiBUZW5zb3IsIG9wdGlvbnM/OiBUZW5zb3JUb0RhdGFVcmxPcHRpb25zKTogc3RyaW5nID0+IHtcbiAgY29uc3QgY2FudmFzID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpIDogKG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSkpO1xuICBjYW52YXMud2lkdGggPSB0ZW5zb3IuZGltc1szXTtcbiAgY2FudmFzLmhlaWdodCA9IHRlbnNvci5kaW1zWzJdO1xuICBjb25zdCBwaXhlbHMyRENvbnRleHQgPVxuICAgICAgY2FudmFzLmdldENvbnRleHQoJzJkJykgYXMgKENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB8IE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB8IG51bGwpO1xuXG4gIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgIC8vIERlZmF1bHQgdmFsdWVzIGZvciBoZWlnaHQgYW5kIHdpZHRoICYgZm9ybWF0XG4gICAgbGV0IHdpZHRoOiBudW1iZXI7XG4gICAgbGV0IGhlaWdodDogbnVtYmVyO1xuICAgIGlmIChvcHRpb25zPy50ZW5zb3JMYXlvdXQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnRlbnNvckxheW91dCA9PT0gJ05IV0MnKSB7XG4gICAgICB3aWR0aCA9IHRlbnNvci5kaW1zWzJdO1xuICAgICAgaGVpZ2h0ID0gdGVuc29yLmRpbXNbM107XG4gICAgfSBlbHNlIHsgIC8vIERlZmF1bHQgbGF5b3V0IGlzIE5DV0hcbiAgICAgIHdpZHRoID0gdGVuc29yLmRpbXNbM107XG4gICAgICBoZWlnaHQgPSB0ZW5zb3IuZGltc1syXTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnB1dGZvcm1hdCA9IG9wdGlvbnM/LmZvcm1hdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mb3JtYXQgOiAnUkdCJztcblxuICAgIGNvbnN0IG5vcm0gPSBvcHRpb25zPy5ub3JtO1xuICAgIGxldCBub3JtTWVhbjogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gICAgbGV0IG5vcm1CaWFzOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgICBpZiAobm9ybSA9PT0gdW5kZWZpbmVkIHx8IG5vcm0ubWVhbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBub3JtTWVhbiA9IFsyNTUsIDI1NSwgMjU1LCAyNTVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIChub3JtLm1lYW4pID09PSAnbnVtYmVyJykge1xuICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW5dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybU1lYW4gPSBbbm9ybS5tZWFuWzBdLCBub3JtLm1lYW5bMV0sIG5vcm0ubWVhblsyXSwgMF07XG4gICAgICAgIGlmIChub3JtLm1lYW5bM10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vcm1NZWFuWzNdID0gbm9ybS5tZWFuWzNdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub3JtID09PSB1bmRlZmluZWQgfHwgbm9ybS5iaWFzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5vcm1CaWFzID0gWzAsIDAsIDAsIDBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIChub3JtLmJpYXMpID09PSAnbnVtYmVyJykge1xuICAgICAgICBub3JtQmlhcyA9IFtub3JtLmJpYXMsIG5vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzWzBdLCBub3JtLmJpYXNbMV0sIG5vcm0uYmlhc1syXSwgMF07XG4gICAgICAgIGlmIChub3JtLmJpYXNbM10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vcm1CaWFzWzNdID0gbm9ybS5iaWFzWzNdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyaWRlID0gaGVpZ2h0ICogd2lkdGg7XG4gICAgLy8gRGVmYXVsdCBwb2ludGVyIGFzc2lnbm1lbnRzXG4gICAgbGV0IHJUZW5zb3JQb2ludGVyID0gMCwgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUsIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMiwgYVRlbnNvclBvaW50ZXIgPSAtMTtcblxuICAgIC8vIFVwZGF0aW5nIHRoZSBwb2ludGVyIGFzc2lnbm1lbnRzIGJhc2VkIG9uIHRoZSBpbnB1dCBpbWFnZSBmb3JtYXRcbiAgICBpZiAoaW5wdXRmb3JtYXQgPT09ICdSR0JBJykge1xuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgICBhVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDM7XG4gICAgfSBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQicpIHtcbiAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRmb3JtYXQgPT09ICdSQkcnKSB7XG4gICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICAgICAgY29uc3QgUiA9ICgodGVuc29yLmRhdGFbclRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzBdKSAqIG5vcm1NZWFuWzBdOyAgLy8gUiB2YWx1ZVxuICAgICAgICBjb25zdCBHID0gKCh0ZW5zb3IuZGF0YVtnVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbMV0pICogbm9ybU1lYW5bMV07ICAvLyBHIHZhbHVlXG4gICAgICAgIGNvbnN0IEIgPSAoKHRlbnNvci5kYXRhW2JUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1syXSkgKiBub3JtTWVhblsyXTsgIC8vIEIgdmFsdWVcbiAgICAgICAgY29uc3QgQSA9IGFUZW5zb3JQb2ludGVyID09PSAtMSA/XG4gICAgICAgICAgICAyNTUgOlxuICAgICAgICAgICAgKCh0ZW5zb3IuZGF0YVthVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbM10pICogbm9ybU1lYW5bM107ICAvLyBBIHZhbHVlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kc1xuICAgICAgICBwaXhlbHMyRENvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIFIgKyAnLCcgKyBHICsgJywnICsgQiArICcsJyArIEEgKyAnKSc7XG4gICAgICAgIHBpeGVsczJEQ29udGV4dC5maWxsUmVjdChqLCBpLCAxLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCd0b0RhdGFVUkwnIGluIGNhbnZhcykge1xuICAgICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b0RhdGFVUkwgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IudG9JbWFnZURhdGEoKVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yVG9JbWFnZURhdGEgPSAodGVuc29yOiBUZW5zb3IsIG9wdGlvbnM/OiBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnMpOiBJbWFnZURhdGEgPT4ge1xuICBjb25zdCBwaXhlbHMyRENvbnRleHQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID9cbiAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJykgOlxuICAgICAgbmV3IE9mZnNjcmVlbkNhbnZhcygxLCAxKS5nZXRDb250ZXh0KCcyZCcpIGFzIE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgbGV0IGltYWdlOiBJbWFnZURhdGE7XG4gIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgIC8vIERlZmF1bHQgdmFsdWVzIGZvciBoZWlnaHQgYW5kIHdpZHRoICYgZm9ybWF0XG4gICAgbGV0IHdpZHRoOiBudW1iZXI7XG4gICAgbGV0IGhlaWdodDogbnVtYmVyO1xuICAgIGxldCBjaGFubmVsczogbnVtYmVyO1xuICAgIGlmIChvcHRpb25zPy50ZW5zb3JMYXlvdXQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnRlbnNvckxheW91dCA9PT0gJ05IV0MnKSB7XG4gICAgICB3aWR0aCA9IHRlbnNvci5kaW1zWzJdO1xuICAgICAgaGVpZ2h0ID0gdGVuc29yLmRpbXNbMV07XG4gICAgICBjaGFubmVscyA9IHRlbnNvci5kaW1zWzNdO1xuICAgIH0gZWxzZSB7ICAvLyBEZWZhdWx0IGxheW91dCBpcyBOQ1dIXG4gICAgICB3aWR0aCA9IHRlbnNvci5kaW1zWzNdO1xuICAgICAgaGVpZ2h0ID0gdGVuc29yLmRpbXNbMl07XG4gICAgICBjaGFubmVscyA9IHRlbnNvci5kaW1zWzFdO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dGZvcm1hdCA9IG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IChvcHRpb25zLmZvcm1hdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mb3JtYXQgOiAnUkdCJykgOiAnUkdCJztcblxuICAgIGNvbnN0IG5vcm0gPSBvcHRpb25zPy5ub3JtO1xuICAgIGxldCBub3JtTWVhbjogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gICAgbGV0IG5vcm1CaWFzOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgICBpZiAobm9ybSA9PT0gdW5kZWZpbmVkIHx8IG5vcm0ubWVhbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBub3JtTWVhbiA9IFsyNTUsIDI1NSwgMjU1LCAyNTVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIChub3JtLm1lYW4pID09PSAnbnVtYmVyJykge1xuICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW5dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybU1lYW4gPSBbbm9ybS5tZWFuWzBdLCBub3JtLm1lYW5bMV0sIG5vcm0ubWVhblsyXSwgMjU1XTtcbiAgICAgICAgaWYgKG5vcm0ubWVhblszXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9ybU1lYW5bM10gPSBub3JtLm1lYW5bM107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vcm0gPT09IHVuZGVmaW5lZCB8fCBub3JtLmJpYXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9ybUJpYXMgPSBbMCwgMCwgMCwgMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgKG5vcm0uYmlhcykgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5vcm1CaWFzID0gW25vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhc107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtQmlhcyA9IFtub3JtLmJpYXNbMF0sIG5vcm0uYmlhc1sxXSwgbm9ybS5iaWFzWzJdLCAwXTtcbiAgICAgICAgaWYgKG5vcm0uYmlhc1szXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9ybUJpYXNbM10gPSBub3JtLmJpYXNbM107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzdHJpZGUgPSBoZWlnaHQgKiB3aWR0aDtcbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAob3B0aW9ucy5mb3JtYXQgIT09IHVuZGVmaW5lZCAmJiAoY2hhbm5lbHMgPT09IDQgJiYgb3B0aW9ucy5mb3JtYXQgIT09ICdSR0JBJykgfHxcbiAgICAgICAgICAoY2hhbm5lbHMgPT09IDMgJiYgKG9wdGlvbnMuZm9ybWF0ICE9PSAnUkdCJyAmJiBvcHRpb25zLmZvcm1hdCAhPT0gJ0JHUicpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBmb3JtYXQgZG9lc25cXCd0IG1hdGNoIGlucHV0IHRlbnNvciBkaW1zJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCBwb2ludGVyIGFzc2lnbm1lbnRzXG4gICAgY29uc3Qgc3RlcCA9IDQ7XG4gICAgbGV0IHJJbWFnZVBvaW50ZXIgPSAwLCBnSW1hZ2VQb2ludGVyID0gMSwgYkltYWdlUG9pbnRlciA9IDIsIGFJbWFnZVBvaW50ZXIgPSAzO1xuICAgIGxldCByVGVuc29yUG9pbnRlciA9IDAsIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlLCBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDIsIGFUZW5zb3JQb2ludGVyID0gLTE7XG5cbiAgICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgaW5wdXQgaW1hZ2UgZm9ybWF0XG4gICAgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkdCQScpIHtcbiAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgICAgYVRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAzO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRmb3JtYXQgPT09ICdSR0InKSB7XG4gICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICB9IGVsc2UgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkJHJykge1xuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgfVxuXG4gICAgaW1hZ2UgPSBwaXhlbHMyRENvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWlnaHQgKiB3aWR0aDtcbiAgICAgICAgIHJJbWFnZVBvaW50ZXIgKz0gc3RlcCwgZ0ltYWdlUG9pbnRlciArPSBzdGVwLCBiSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGFJbWFnZVBvaW50ZXIgKz0gc3RlcCwgaSsrKSB7XG4gICAgICBpbWFnZS5kYXRhW3JJbWFnZVBvaW50ZXJdID0gKCh0ZW5zb3IuZGF0YVtyVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbMF0pICogbm9ybU1lYW5bMF07ICAvLyBSIHZhbHVlXG4gICAgICBpbWFnZS5kYXRhW2dJbWFnZVBvaW50ZXJdID0gKCh0ZW5zb3IuZGF0YVtnVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbMV0pICogbm9ybU1lYW5bMV07ICAvLyBHIHZhbHVlXG4gICAgICBpbWFnZS5kYXRhW2JJbWFnZVBvaW50ZXJdID0gKCh0ZW5zb3IuZGF0YVtiVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbMl0pICogbm9ybU1lYW5bMl07ICAvLyBCIHZhbHVlXG4gICAgICBpbWFnZS5kYXRhW2FJbWFnZVBvaW50ZXJdID0gYVRlbnNvclBvaW50ZXIgPT09IC0xID9cbiAgICAgICAgICAyNTUgOlxuICAgICAgICAgICgodGVuc29yLmRhdGFbYVRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzNdKSAqIG5vcm1NZWFuWzNdOyAgLy8gQSB2YWx1ZVxuICAgIH1cblxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICB9XG4gIHJldHVybiBpbWFnZTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7T3B0aW9uc0RpbWVuc2lvbnMsIE9wdGlvbnNGb3JtYXQsIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycywgT3B0aW9uc1RlbnNvckZvcm1hdCwgT3B0aW9uc1RlbnNvckxheW91dCwgVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnMsIFRlbnNvckZyb21JbWFnZUJpdG1hcE9wdGlvbnMsIFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zLCBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9ucywgVGVuc29yRnJvbVRleHR1cmVPcHRpb25zLCBUZW5zb3JGcm9tVXJsT3B0aW9uc30gZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi90ZW5zb3ItaW1wbC5qcyc7XG5pbXBvcnQge1RlbnNvciBhcyBUZW5zb3JJbnRlcmZhY2V9IGZyb20gJy4vdGVuc29yLmpzJztcblxuaW50ZXJmYWNlIEJ1ZmZlclRvVGVuc29yT3B0aW9ucyBleHRlbmRzIE9wdGlvbnNEaW1lbnNpb25zLCBPcHRpb25zVGVuc29yTGF5b3V0LCBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3B0aW9uc0Zvcm1hdCwgT3B0aW9uc1RlbnNvckZvcm1hdCB7fVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gaW1hZ2Ugb2JqZWN0XG4gKlxuICogQHBhcmFtIGJ1ZmZlciAtIEV4dHJhY3RlZCBpbWFnZSBidWZmZXIgZGF0YSAtIGFzc3VtaW5nIFJHQkEgZm9ybWF0XG4gKiBAcGFyYW0gaW1hZ2VGb3JtYXQgLSBpbnB1dCBpbWFnZSBjb25maWd1cmF0aW9uIC0gcmVxdWlyZWQgY29uZmlndXJhdGlvbnMgaGVpZ2h0LCB3aWR0aCwgZm9ybWF0XG4gKiBAcGFyYW0gdGVuc29yRm9ybWF0IC0gb3V0cHV0IHRlbnNvciBjb25maWd1cmF0aW9uIC0gRGVmYXVsdCBpcyBSR0IgZm9ybWF0XG4gKi9cbmV4cG9ydCBjb25zdCBidWZmZXJUb1RlbnNvciA9IChidWZmZXI6IFVpbnQ4Q2xhbXBlZEFycmF5fHVuZGVmaW5lZCwgb3B0aW9uczogQnVmZmVyVG9UZW5zb3JPcHRpb25zKTogVGVuc29yID0+IHtcbiAgaWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBidWZmZXIgbXVzdCBiZSBkZWZpbmVkJyk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuaGVpZ2h0ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy53aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBoZWlnaHQgYW5kIHdpZHRoIG11c3QgYmUgZGVmaW5lZCcpO1xuICB9XG4gIGlmIChvcHRpb25zLnRlbnNvckxheW91dCA9PT0gJ05IV0MnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOSFdDIFRlbnNvciBsYXlvdXQgaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgfVxuXG4gIGNvbnN0IHtoZWlnaHQsIHdpZHRofSA9IG9wdGlvbnM7XG5cbiAgY29uc3Qgbm9ybSA9IG9wdGlvbnMubm9ybSA/PyB7bWVhbjogMjU1LCBiaWFzOiAwfTtcbiAgbGV0IG5vcm1NZWFuOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgbGV0IG5vcm1CaWFzOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcblxuICBpZiAodHlwZW9mIChub3JtLm1lYW4pID09PSAnbnVtYmVyJykge1xuICAgIG5vcm1NZWFuID0gW25vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbl07XG4gIH0gZWxzZSB7XG4gICAgbm9ybU1lYW4gPSBbbm9ybS5tZWFuIVswXSwgbm9ybS5tZWFuIVsxXSwgbm9ybS5tZWFuIVsyXSwgbm9ybS5tZWFuIVszXSA/PyAyNTVdO1xuICB9XG5cbiAgaWYgKHR5cGVvZiAobm9ybS5iaWFzKSA9PT0gJ251bWJlcicpIHtcbiAgICBub3JtQmlhcyA9IFtub3JtLmJpYXMsIG5vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXNdO1xuICB9IGVsc2Uge1xuICAgIG5vcm1CaWFzID0gW25vcm0uYmlhcyFbMF0sIG5vcm0uYmlhcyFbMV0sIG5vcm0uYmlhcyFbMl0sIG5vcm0uYmlhcyFbM10gPz8gMF07XG4gIH1cblxuICBjb25zdCBpbnB1dGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZvcm1hdCA6ICdSR0JBJztcbiAgLy8gZGVmYXVsdCB2YWx1ZSBpcyBSR0JBIHNpbmNlIGltYWdlZGF0YSBhbmQgSFRNTEltYWdlRWxlbWVudCB1c2VzIGl0XG5cbiAgY29uc3Qgb3V0cHV0Zm9ybWF0ID1cbiAgICAgIG9wdGlvbnMudGVuc29yRm9ybWF0ICE9PSB1bmRlZmluZWQgPyAob3B0aW9ucy50ZW5zb3JGb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGVuc29yRm9ybWF0IDogJ1JHQicpIDogJ1JHQic7XG4gIGNvbnN0IHN0cmlkZSA9IGhlaWdodCAqIHdpZHRoO1xuICBjb25zdCBmbG9hdDMyRGF0YSA9IG91dHB1dGZvcm1hdCA9PT0gJ1JHQkEnID8gbmV3IEZsb2F0MzJBcnJheShzdHJpZGUgKiA0KSA6IG5ldyBGbG9hdDMyQXJyYXkoc3RyaWRlICogMyk7XG5cbiAgLy8gRGVmYXVsdCBwb2ludGVyIGFzc2lnbm1lbnRzXG4gIGxldCBzdGVwID0gNCwgckltYWdlUG9pbnRlciA9IDAsIGdJbWFnZVBvaW50ZXIgPSAxLCBiSW1hZ2VQb2ludGVyID0gMiwgYUltYWdlUG9pbnRlciA9IDM7XG4gIGxldCByVGVuc29yUG9pbnRlciA9IDAsIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlLCBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDIsIGFUZW5zb3JQb2ludGVyID0gLTE7XG5cbiAgLy8gVXBkYXRpbmcgdGhlIHBvaW50ZXIgYXNzaWdubWVudHMgYmFzZWQgb24gdGhlIGlucHV0IGltYWdlIGZvcm1hdFxuICBpZiAoaW5wdXRmb3JtYXQgPT09ICdSR0InKSB7XG4gICAgc3RlcCA9IDM7XG4gICAgckltYWdlUG9pbnRlciA9IDA7XG4gICAgZ0ltYWdlUG9pbnRlciA9IDE7XG4gICAgYkltYWdlUG9pbnRlciA9IDI7XG4gICAgYUltYWdlUG9pbnRlciA9IC0xO1xuICB9XG5cbiAgLy8gVXBkYXRpbmcgdGhlIHBvaW50ZXIgYXNzaWdubWVudHMgYmFzZWQgb24gdGhlIG91dHB1dCB0ZW5zb3IgZm9ybWF0XG4gIGlmIChvdXRwdXRmb3JtYXQgPT09ICdSR0JBJykge1xuICAgIGFUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMztcbiAgfSBlbHNlIGlmIChvdXRwdXRmb3JtYXQgPT09ICdSQkcnKSB7XG4gICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgfSBlbHNlIGlmIChvdXRwdXRmb3JtYXQgPT09ICdCR1InKSB7XG4gICAgYlRlbnNvclBvaW50ZXIgPSAwO1xuICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgIHJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaWRlO1xuICAgICAgIGkrKywgckltYWdlUG9pbnRlciArPSBzdGVwLCBiSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGdJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYUltYWdlUG9pbnRlciArPSBzdGVwKSB7XG4gICAgZmxvYXQzMkRhdGFbclRlbnNvclBvaW50ZXIrK10gPSAoYnVmZmVyW3JJbWFnZVBvaW50ZXJdICsgbm9ybUJpYXNbMF0pIC8gbm9ybU1lYW5bMF07XG4gICAgZmxvYXQzMkRhdGFbZ1RlbnNvclBvaW50ZXIrK10gPSAoYnVmZmVyW2dJbWFnZVBvaW50ZXJdICsgbm9ybUJpYXNbMV0pIC8gbm9ybU1lYW5bMV07XG4gICAgZmxvYXQzMkRhdGFbYlRlbnNvclBvaW50ZXIrK10gPSAoYnVmZmVyW2JJbWFnZVBvaW50ZXJdICsgbm9ybUJpYXNbMl0pIC8gbm9ybU1lYW5bMl07XG4gICAgaWYgKGFUZW5zb3JQb2ludGVyICE9PSAtMSAmJiBhSW1hZ2VQb2ludGVyICE9PSAtMSkge1xuICAgICAgZmxvYXQzMkRhdGFbYVRlbnNvclBvaW50ZXIrK10gPSAoYnVmZmVyW2FJbWFnZVBvaW50ZXJdICsgbm9ybUJpYXNbM10pIC8gbm9ybU1lYW5bM107XG4gICAgfVxuICB9XG5cbiAgLy8gRmxvYXQzMkFycmF5IC0+IG9ydC5UZW5zb3JcbiAgY29uc3Qgb3V0cHV0VGVuc29yID0gb3V0cHV0Zm9ybWF0ID09PSAnUkdCQScgPyBuZXcgVGVuc29yKCdmbG9hdDMyJywgZmxvYXQzMkRhdGEsIFsxLCA0LCBoZWlnaHQsIHdpZHRoXSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBUZW5zb3IoJ2Zsb2F0MzInLCBmbG9hdDMyRGF0YSwgWzEsIDMsIGhlaWdodCwgd2lkdGhdKTtcbiAgcmV0dXJuIG91dHB1dFRlbnNvcjtcbn07XG5cbi8qKlxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLmZyb21JbWFnZSgpLlxuICovXG5leHBvcnQgY29uc3QgdGVuc29yRnJvbUltYWdlID0gYXN5bmMoXG4gICAgaW1hZ2U6IEltYWdlRGF0YXxIVE1MSW1hZ2VFbGVtZW50fEltYWdlQml0bWFwfHN0cmluZyxcbiAgICBvcHRpb25zPzogVGVuc29yRnJvbUltYWdlRGF0YU9wdGlvbnN8VGVuc29yRnJvbUltYWdlRWxlbWVudE9wdGlvbnN8VGVuc29yRnJvbUltYWdlQml0bWFwT3B0aW9uc3xcbiAgICBUZW5zb3JGcm9tVXJsT3B0aW9ucyk6IFByb21pc2U8VGVuc29yPiA9PiB7XG4gIC8vIGNoZWNraW5nIHRoZSB0eXBlIG9mIGltYWdlIG9iamVjdFxuICBjb25zdCBpc0hUTUxJbWFnZUVsZSA9IHR5cGVvZiAoSFRNTEltYWdlRWxlbWVudCkgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudDtcbiAgY29uc3QgaXNJbWFnZURhdGFFbGUgPSB0eXBlb2YgKEltYWdlRGF0YSkgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSW1hZ2VEYXRhO1xuICBjb25zdCBpc0ltYWdlQml0bWFwID0gdHlwZW9mIChJbWFnZUJpdG1hcCkgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXA7XG4gIGNvbnN0IGlzU3RyaW5nID0gdHlwZW9mIGltYWdlID09PSAnc3RyaW5nJztcblxuICBsZXQgZGF0YTogVWludDhDbGFtcGVkQXJyYXl8dW5kZWZpbmVkO1xuICBsZXQgYnVmZmVyVG9UZW5zb3JPcHRpb25zOiBCdWZmZXJUb1RlbnNvck9wdGlvbnMgPSBvcHRpb25zID8/IHt9O1xuXG4gIGNvbnN0IGNyZWF0ZUNhbnZhcyA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbnZhcyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9O1xuICBjb25zdCBjcmVhdGVDYW52YXNDb250ZXh0ID0gKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnR8T2Zmc2NyZWVuQ2FudmFzKSA9PiB7XG4gICAgaWYgKGNhbnZhcyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgICByZXR1cm4gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgfSBlbHNlIGlmIChjYW52YXMgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXMpIHtcbiAgICAgIHJldHVybiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSBhcyBPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcbiAgLy8gZmlsbGluZyBhbmQgY2hlY2tpbmcgaW1hZ2UgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gIGlmIChpc0hUTUxJbWFnZUVsZSkge1xuICAgIC8vIEhUTUxJbWFnZUVsZW1lbnQgLSBpbWFnZSBvYmplY3QgLSBmb3JtYXQgaXMgUkdCQSBieSBkZWZhdWx0XG4gICAgY29uc3QgY2FudmFzID0gY3JlYXRlQ2FudmFzKCk7XG4gICAgY2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICBjb25zdCBwaXhlbHMyRENvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0KGNhbnZhcyk7XG5cbiAgICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgIGxldCBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgICBsZXQgd2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZXNpemVkSGVpZ2h0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZXNpemVkV2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBoZWlnaHQgPSBvcHRpb25zLnJlc2l6ZWRIZWlnaHQ7XG4gICAgICAgIHdpZHRoID0gb3B0aW9ucy5yZXNpemVkV2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGlvbnMudGVuc29yRm9ybWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGlucHV0IGNvbmZpZyBmb3JtYXQgbXVzdCBiZSBSR0JBIGZvciBIVE1MSW1hZ2VFbGVtZW50Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLnRlbnNvckZvcm1hdCA9ICdSR0JBJztcbiAgICAgICAgfVxuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMud2lkdGggPSB3aWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy50ZW5zb3JGb3JtYXQgPSAnUkdCQSc7XG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy53aWR0aCA9IHdpZHRoO1xuICAgICAgfVxuXG4gICAgICBwaXhlbHMyRENvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwKTtcbiAgICAgIGRhdGEgPSBwaXhlbHMyRENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0ltYWdlRGF0YUVsZSkge1xuICAgIGxldCBoZWlnaHQ6IG51bWJlcjtcbiAgICBsZXQgd2lkdGg6IG51bWJlcjtcblxuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZXNpemVkV2lkdGggIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRIZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5yZXNpemVkSGVpZ2h0O1xuICAgICAgd2lkdGggPSBvcHRpb25zLnJlc2l6ZWRXaWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgd2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuZm9ybWF0ID0gJ1JHQkEnO1xuICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gd2lkdGg7XG5cbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCB0ZW1wQ2FudmFzID0gY3JlYXRlQ2FudmFzKCk7XG5cbiAgICAgIHRlbXBDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHRlbXBDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICBjb25zdCBwaXhlbHMyRENvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0KHRlbXBDYW52YXMpO1xuXG4gICAgICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgcGl4ZWxzMkRDb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZSwgMCwgMCk7XG4gICAgICAgIGRhdGEgPSBwaXhlbHMyRENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IGltYWdlLmRhdGE7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzSW1hZ2VCaXRtYXApIHtcbiAgICAvLyBJbWFnZUJpdG1hcCAtIGltYWdlIG9iamVjdCAtIGZvcm1hdCBtdXN0IGJlIHByb3ZpZGVkIGJ5IHVzZXJcbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGltYWdlIGNvbmZpZyB3aXRoIGZvcm1hdCBmb3IgSW1hZ2ViaXRtYXAnKTtcbiAgICB9XG5cbiAgICBjb25zdCBjYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcbiAgICBjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQoY2FudmFzKTtcblxuICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgIHBpeGVsczJEQ29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgZGF0YSA9IHBpeGVsczJEQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMud2lkdGggPSB3aWR0aDtcbiAgICAgIHJldHVybiBidWZmZXJUb1RlbnNvcihkYXRhLCBidWZmZXJUb1RlbnNvck9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgY2FudmFzID0gY3JlYXRlQ2FudmFzKCk7XG4gICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dChjYW52YXMpO1xuICAgICAgaWYgKCFpbWFnZSB8fCAhY29udGV4dCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KCk7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgbmV3SW1hZ2UuY3Jvc3NPcmlnaW4gPSAnQW5vbnltb3VzJztcbiAgICAgIG5ld0ltYWdlLnNyYyA9IGltYWdlO1xuICAgICAgbmV3SW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgICAgICBjYW52YXMud2lkdGggPSBuZXdJbWFnZS53aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IG5ld0ltYWdlLmhlaWdodDtcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UobmV3SW1hZ2UsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIGNvbnN0IGltZyA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICAgICAgcmVzb2x2ZShidWZmZXJUb1RlbnNvcihpbWcuZGF0YSwgYnVmZmVyVG9UZW5zb3JPcHRpb25zKSk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb24nKTtcbiAgfVxuXG4gIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYnVmZmVyVG9UZW5zb3IoZGF0YSwgYnVmZmVyVG9UZW5zb3JPcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uJyk7XG4gIH1cbn07XG5cbi8qKlxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLmZyb21UZXh0dXJlKCkuXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JGcm9tVGV4dHVyZSA9IDxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLlRleHR1cmVEYXRhVHlwZXM+KFxuICAgIHRleHR1cmU6IFRlbnNvckludGVyZmFjZS5UZXh0dXJlVHlwZSwgb3B0aW9uczogVGVuc29yRnJvbVRleHR1cmVPcHRpb25zPFQ+KTogVGVuc29yID0+IHtcbiAgY29uc3Qge3dpZHRoLCBoZWlnaHQsIGRvd25sb2FkLCBkaXNwb3NlfSA9IG9wdGlvbnM7XG4gIC8vIEFsd2F5cyBhc3N1bWUgUkdCQUYzMi4gVE9ETzogc3VwcG9ydCBkaWZmZXJlbnQgdGV4dHVyZSBmb3JtYXRcbiAgY29uc3QgZGltcyA9IFsxLCBoZWlnaHQsIHdpZHRoLCA0XTtcbiAgcmV0dXJuIG5ldyBUZW5zb3Ioe2xvY2F0aW9uOiAndGV4dHVyZScsIHR5cGU6ICdmbG9hdDMyJywgdGV4dHVyZSwgZGltcywgZG93bmxvYWQsIGRpc3Bvc2V9KTtcbn07XG5cbi8qKlxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLmZyb21HcHVCdWZmZXIoKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21HcHVCdWZmZXIgPSA8VCBleHRlbmRzIFRlbnNvckludGVyZmFjZS5HcHVCdWZmZXJEYXRhVHlwZXM+KFxuICAgIGdwdUJ1ZmZlcjogVGVuc29ySW50ZXJmYWNlLkdwdUJ1ZmZlclR5cGUsIG9wdGlvbnM6IFRlbnNvckZyb21HcHVCdWZmZXJPcHRpb25zPFQ+KTogVGVuc29yID0+IHtcbiAgY29uc3Qge2RhdGFUeXBlLCBkaW1zLCBkb3dubG9hZCwgZGlzcG9zZX0gPSBvcHRpb25zO1xuICByZXR1cm4gbmV3IFRlbnNvcih7bG9jYXRpb246ICdncHUtYnVmZmVyJywgdHlwZTogZGF0YVR5cGUgPz8gJ2Zsb2F0MzInLCBncHVCdWZmZXIsIGRpbXMsIGRvd25sb2FkLCBkaXNwb3NlfSk7XG59O1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5mcm9tUGlubmVkQnVmZmVyKCkuXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JGcm9tUGlubmVkQnVmZmVyID0gPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuQ3B1UGlubmVkRGF0YVR5cGVzPihcbiAgICB0eXBlOiBULCBidWZmZXI6IFRlbnNvckludGVyZmFjZS5EYXRhVHlwZU1hcFtUXSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29yID0+XG4gICAgbmV3IFRlbnNvcih7bG9jYXRpb246ICdjcHUtcGlubmVkJywgdHlwZSwgZGF0YTogYnVmZmVyLCBkaW1zOiBkaW1zID8/IFtidWZmZXIubGVuZ3RoXX0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi90ZW5zb3IuanMnO1xuXG5leHBvcnQgdHlwZSBTdXBwb3J0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3JzID0gRmxvYXQzMkFycmF5Q29uc3RydWN0b3J8VWludDhBcnJheUNvbnN0cnVjdG9yfEludDhBcnJheUNvbnN0cnVjdG9yfFxuICAgIFVpbnQxNkFycmF5Q29uc3RydWN0b3J8SW50MTZBcnJheUNvbnN0cnVjdG9yfEludDMyQXJyYXlDb25zdHJ1Y3RvcnxCaWdJbnQ2NEFycmF5Q29uc3RydWN0b3J8VWludDhBcnJheUNvbnN0cnVjdG9yfFxuICAgIEZsb2F0NjRBcnJheUNvbnN0cnVjdG9yfFVpbnQzMkFycmF5Q29uc3RydWN0b3J8QmlnVWludDY0QXJyYXlDb25zdHJ1Y3RvcjtcbmV4cG9ydCB0eXBlIFN1cHBvcnRlZFR5cGVkQXJyYXkgPSBJbnN0YW5jZVR5cGU8U3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycz47XG5cbi8vIGEgcnVudGltZSBtYXAgdGhhdCBtYXBzIHR5cGUgc3RyaW5nIHRvIFR5cGVkQXJyYXkgY29uc3RydWN0b3IuIFNob3VsZCBtYXRjaCBUZW5zb3IuRGF0YVR5cGVNYXAuXG5leHBvcnQgY29uc3QgTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUCA9IG5ldyBNYXA8c3RyaW5nLCBTdXBwb3J0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3JzPihbXG4gIFsnZmxvYXQzMicsIEZsb2F0MzJBcnJheV0sXG4gIFsndWludDgnLCBVaW50OEFycmF5XSxcbiAgWydpbnQ4JywgSW50OEFycmF5XSxcbiAgWyd1aW50MTYnLCBVaW50MTZBcnJheV0sXG4gIFsnaW50MTYnLCBJbnQxNkFycmF5XSxcbiAgWydpbnQzMicsIEludDMyQXJyYXldLFxuICBbJ2Jvb2wnLCBVaW50OEFycmF5XSxcbiAgWydmbG9hdDY0JywgRmxvYXQ2NEFycmF5XSxcbiAgWyd1aW50MzInLCBVaW50MzJBcnJheV0sXG5dKTtcblxuLy8gYSBydW50aW1lIG1hcCB0aGF0IG1hcHMgdHlwZSBzdHJpbmcgdG8gVHlwZWRBcnJheSBjb25zdHJ1Y3Rvci4gU2hvdWxkIG1hdGNoIFRlbnNvci5EYXRhVHlwZU1hcC5cbmV4cG9ydCBjb25zdCBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQID0gbmV3IE1hcDxTdXBwb3J0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3JzLCBUZW5zb3IuVHlwZT4oW1xuICBbRmxvYXQzMkFycmF5LCAnZmxvYXQzMiddLFxuICBbVWludDhBcnJheSwgJ3VpbnQ4J10sXG4gIFtJbnQ4QXJyYXksICdpbnQ4J10sXG4gIFtVaW50MTZBcnJheSwgJ3VpbnQxNiddLFxuICBbSW50MTZBcnJheSwgJ2ludDE2J10sXG4gIFtJbnQzMkFycmF5LCAnaW50MzInXSxcbiAgW0Zsb2F0NjRBcnJheSwgJ2Zsb2F0NjQnXSxcbiAgW1VpbnQzMkFycmF5LCAndWludDMyJ10sXG5dKTtcblxuLy8gYSBkdW1teSB0eXBlIGRlY2xhcmF0aW9uIGZvciBGbG9hdDE2QXJyYXkgaW4gY2FzZSBhbnkgcG9seWZpbGwgaXMgYXZhaWxhYmxlLlxuZGVjbGFyZSBnbG9iYWwge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGNvbnN0IEZsb2F0MTZBcnJheTogYW55O1xufVxuXG4vLyB0aGUgZm9sbG93aW5nIGNvZGUgYWxsb3dzIGRlbGF5aW5nIGV4ZWN1dGlvbiBvZiBCaWdJbnQvRmxvYXQxNkFycmF5IGNoZWNraW5nLiBUaGlzIGFsbG93cyBsYXp5IGluaXRpYWxpemF0aW9uIGZvclxuLy8gTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUCBhbmQgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUCwgd2hpY2ggYWxsb3dzIEJpZ0ludC9GbG9hdDE2QXJyYXlcbi8vIHBvbHlmaWxsIGlmIGF2YWlsYWJsZS5cbmxldCBpc1R5cGVkQXJyYXlDaGVja2VkID0gZmFsc2U7XG5leHBvcnQgY29uc3QgY2hlY2tUeXBlZEFycmF5ID0gKCkgPT4ge1xuICBpZiAoIWlzVHlwZWRBcnJheUNoZWNrZWQpIHtcbiAgICBpc1R5cGVkQXJyYXlDaGVja2VkID0gdHJ1ZTtcbiAgICBjb25zdCBpc0JpZ0ludDY0QXJyYXlBdmFpbGFibGUgPSB0eXBlb2YgQmlnSW50NjRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgQmlnSW50NjRBcnJheS5mcm9tO1xuICAgIGNvbnN0IGlzQmlnVWludDY0QXJyYXlBdmFpbGFibGUgPSB0eXBlb2YgQmlnVWludDY0QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIEJpZ1VpbnQ2NEFycmF5LmZyb207XG4gICAgY29uc3QgaXNGbG9hdDE2QXJyYXlBdmFpbGFibGUgPSB0eXBlb2YgRmxvYXQxNkFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBGbG9hdDE2QXJyYXkuZnJvbTtcblxuICAgIGlmIChpc0JpZ0ludDY0QXJyYXlBdmFpbGFibGUpIHtcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCdpbnQ2NCcsIEJpZ0ludDY0QXJyYXkpO1xuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUC5zZXQoQmlnSW50NjRBcnJheSwgJ2ludDY0Jyk7XG4gICAgfVxuICAgIGlmIChpc0JpZ1VpbnQ2NEFycmF5QXZhaWxhYmxlKSB7XG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLnNldCgndWludDY0JywgQmlnVWludDY0QXJyYXkpO1xuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUC5zZXQoQmlnVWludDY0QXJyYXksICd1aW50NjQnKTtcbiAgICB9XG4gICAgaWYgKGlzRmxvYXQxNkFycmF5QXZhaWxhYmxlKSB7XG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLnNldCgnZmxvYXQxNicsIEZsb2F0MTZBcnJheSk7XG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLnNldChGbG9hdDE2QXJyYXksICdmbG9hdDE2Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIEZsb2F0MTZBcnJheSBpcyBub3QgYXZhaWxhYmxlLCB1c2UgJ1VpbnQxNkFycmF5JyB0byBzdG9yZSB0aGUgZGF0YS5cbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCdmbG9hdDE2JywgVWludDE2QXJyYXkpO1xuICAgIH1cbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnMsIEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVycywgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVyc30gZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi90ZW5zb3ItaW1wbC5qcyc7XG5cbi8qKlxuICogY2FsY3VsYXRlIHNpemUgZnJvbSBkaW1zLlxuICpcbiAqIEBwYXJhbSBkaW1zIHRoZSBkaW1zIGFycmF5LiBNYXkgYmUgYW4gaWxsZWdhbCBpbnB1dC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZVNpemUgPSAoZGltczogcmVhZG9ubHkgdW5rbm93bltdKTogbnVtYmVyID0+IHtcbiAgbGV0IHNpemUgPSAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBkaW0gPSBkaW1zW2ldO1xuICAgIGlmICh0eXBlb2YgZGltICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzU2FmZUludGVnZXIoZGltKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZGltc1ske2l9XSBtdXN0IGJlIGFuIGludGVnZXIsIGdvdDogJHtkaW19YCk7XG4gICAgfVxuICAgIGlmIChkaW0gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgZGltc1ske2l9XSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIsIGdvdDogJHtkaW19YCk7XG4gICAgfVxuICAgIHNpemUgKj0gZGltO1xuICB9XG4gIHJldHVybiBzaXplO1xufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IucmVzaGFwZSgpXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JSZXNoYXBlID0gKHRlbnNvcjogVGVuc29yLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvciA9PiB7XG4gIHN3aXRjaCAodGVuc29yLmxvY2F0aW9uKSB7XG4gICAgY2FzZSAnY3B1JzpcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKHRlbnNvci50eXBlLCB0ZW5zb3IuZGF0YSwgZGltcyk7XG4gICAgY2FzZSAnY3B1LXBpbm5lZCc6XG4gICAgICByZXR1cm4gbmV3IFRlbnNvcih7XG4gICAgICAgIGxvY2F0aW9uOiAnY3B1LXBpbm5lZCcsXG4gICAgICAgIGRhdGE6IHRlbnNvci5kYXRhIGFzIENwdVBpbm5lZENvbnN0cnVjdG9yUGFyYW1ldGVyc1snZGF0YSddLFxuICAgICAgICB0eXBlOiB0ZW5zb3IudHlwZSBhcyBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnNbJ3R5cGUnXSxcbiAgICAgICAgZGltcyxcbiAgICAgIH0pO1xuICAgIGNhc2UgJ3RleHR1cmUnOlxuICAgICAgcmV0dXJuIG5ldyBUZW5zb3Ioe1xuICAgICAgICBsb2NhdGlvbjogJ3RleHR1cmUnLFxuICAgICAgICB0ZXh0dXJlOiB0ZW5zb3IudGV4dHVyZSxcbiAgICAgICAgdHlwZTogdGVuc29yLnR5cGUgYXMgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVyc1sndHlwZSddLFxuICAgICAgICBkaW1zLFxuICAgICAgfSk7XG4gICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XG4gICAgICByZXR1cm4gbmV3IFRlbnNvcih7XG4gICAgICAgIGxvY2F0aW9uOiAnZ3B1LWJ1ZmZlcicsXG4gICAgICAgIGdwdUJ1ZmZlcjogdGVuc29yLmdwdUJ1ZmZlcixcbiAgICAgICAgdHlwZTogdGVuc29yLnR5cGUgYXMgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzWyd0eXBlJ10sXG4gICAgICAgIGRpbXMsXG4gICAgICB9KTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0ZW5zb3JSZXNoYXBlOiB0ZW5zb3IgbG9jYXRpb24gJHt0ZW5zb3IubG9jYXRpb259IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHt0ZW5zb3JUb0RhdGFVUkwsIHRlbnNvclRvSW1hZ2VEYXRhfSBmcm9tICcuL3RlbnNvci1jb252ZXJzaW9uLWltcGwuanMnO1xuaW1wb3J0IHtUZW5zb3JUb0RhdGFVcmxPcHRpb25zLCBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnN9IGZyb20gJy4vdGVuc29yLWNvbnZlcnNpb24uanMnO1xuaW1wb3J0IHt0ZW5zb3JGcm9tR3B1QnVmZmVyLCB0ZW5zb3JGcm9tSW1hZ2UsIHRlbnNvckZyb21QaW5uZWRCdWZmZXIsIHRlbnNvckZyb21UZXh0dXJlfSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LWltcGwuanMnO1xuaW1wb3J0IHtDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnMsIEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVycywgVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnMsIFRlbnNvckZyb21JbWFnZUJpdG1hcE9wdGlvbnMsIFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zLCBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9ucywgVGVuc29yRnJvbVRleHR1cmVPcHRpb25zLCBUZW5zb3JGcm9tVXJsT3B0aW9ucywgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVyc30gZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XG5pbXBvcnQge2NoZWNrVHlwZWRBcnJheSwgTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUCwgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUCwgU3VwcG9ydGVkVHlwZWRBcnJheSwgU3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9yc30gZnJvbSAnLi90ZW5zb3ItaW1wbC10eXBlLW1hcHBpbmcuanMnO1xuaW1wb3J0IHtjYWxjdWxhdGVTaXplLCB0ZW5zb3JSZXNoYXBlfSBmcm9tICcuL3RlbnNvci11dGlscy1pbXBsLmpzJztcbmltcG9ydCB7VGVuc29yIGFzIFRlbnNvckludGVyZmFjZX0gZnJvbSAnLi90ZW5zb3IuanMnO1xuXG4vLyB0eXBlIGFsaWFzZXMgZm9yIHRob3NlIGV4cG9ydGVkIGZyb20gVGVuc29yIGludGVyZmFjZVxuXG50eXBlIFRlbnNvclR5cGUgPSBUZW5zb3JJbnRlcmZhY2UuVHlwZTtcbnR5cGUgVGVuc29yRGF0YVR5cGUgPSBUZW5zb3JJbnRlcmZhY2UuRGF0YVR5cGU7XG50eXBlIFRlbnNvckRhdGFMb2NhdGlvbiA9IFRlbnNvckludGVyZmFjZS5EYXRhTG9jYXRpb247XG50eXBlIFRlbnNvclRleHR1cmVUeXBlID0gVGVuc29ySW50ZXJmYWNlLlRleHR1cmVUeXBlO1xudHlwZSBUZW5zb3JHcHVCdWZmZXJUeXBlID0gVGVuc29ySW50ZXJmYWNlLkdwdUJ1ZmZlclR5cGU7XG5cbi8qKlxuICogdGhlIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvciBpbnRlcmZhY2UuXG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgVGVuc29yIGltcGxlbWVudHMgVGVuc29ySW50ZXJmYWNlIHtcbiAgLy8gI3JlZ2lvbiBjb25zdHJ1Y3RvcnNcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IENQVSB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIHR5cGUsIGRhdGEgYW5kIGRpbXMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIHR5cGU6IFRlbnNvclR5cGUsIGRhdGE6IFRlbnNvckRhdGFUeXBlfHJlYWRvbmx5IHN0cmluZ1tdfHJlYWRvbmx5IG51bWJlcltdfHJlYWRvbmx5IGJvb2xlYW5bXSxcbiAgICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgQ1BVIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy4gVHlwZSBpcyBpbmZlcnJlZCBmcm9tIGRhdGEuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkYXRhOiBUZW5zb3JEYXRhVHlwZXxyZWFkb25seSBzdHJpbmdbXXxyZWFkb25seSBib29sZWFuW10sIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBwaW5uZWQgQ1BVIGRhdGEgd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgZGltcy5cbiAgICpcbiAgICogVGVuc29yJ3MgbG9jYXRpb24gd2lsbCBiZSBzZXQgdG8gJ2NwdS1waW5uZWQnLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gU3BlY2lmeSB0aGUgcGFyYW1ldGVycyB0byBjb25zdHJ1Y3QgdGhlIHRlbnNvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtczogQ3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzKTtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIFdlYkdMIHRleHR1cmUgd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgZGltcy5cbiAgICpcbiAgICogVGVuc29yJ3MgbG9jYXRpb24gd2lsbCBiZSBzZXQgdG8gJ3RleHR1cmUnLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gU3BlY2lmeSB0aGUgcGFyYW1ldGVycyB0byBjb25zdHJ1Y3QgdGhlIHRlbnNvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtczogVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVycyk7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBXZWJHUFUgYnVmZmVyIHdpdGggdGhlIGdpdmVuIHR5cGUgYW5kIGRpbXMuXG4gICAqXG4gICAqIFRlbnNvcidzIGxvY2F0aW9uIHdpbGwgYmUgc2V0IHRvICdncHUtYnVmZmVyJy5cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyAtIFNwZWNpZnkgdGhlIHBhcmFtZXRlcnMgdG8gY29uc3RydWN0IHRoZSB0ZW5zb3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJhbXM6IEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVycyk7XG5cbiAgLyoqXG4gICAqIGltcGxlbWVudGF0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgICBhcmcwOiBUZW5zb3JUeXBlfFRlbnNvckRhdGFUeXBlfHJlYWRvbmx5IHN0cmluZ1tdfHJlYWRvbmx5IGJvb2xlYW5bXXxDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnN8XG4gICAgICBUZXh0dXJlQ29uc3RydWN0b3JQYXJhbWV0ZXJzfEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVycyxcbiAgICAgIGFyZzE/OiBUZW5zb3JEYXRhVHlwZXxyZWFkb25seSBudW1iZXJbXXxyZWFkb25seSBzdHJpbmdbXXxyZWFkb25seSBib29sZWFuW10sIGFyZzI/OiByZWFkb25seSBudW1iZXJbXSkge1xuICAgIC8vIHBlcmZvcm0gb25lLXRpbWUgY2hlY2sgZm9yIEJpZ0ludC9GbG9hdDE2QXJyYXkgc3VwcG9ydFxuICAgIGNoZWNrVHlwZWRBcnJheSgpO1xuXG4gICAgbGV0IHR5cGU6IFRlbnNvclR5cGU7XG4gICAgbGV0IGRpbXM6IHJlYWRvbmx5IG51bWJlcltdO1xuXG4gICAgaWYgKHR5cGVvZiBhcmcwID09PSAnb2JqZWN0JyAmJiAnbG9jYXRpb24nIGluIGFyZzApIHtcbiAgICAgIC8vXG4gICAgICAvLyBjb25zdHJ1Y3RpbmcgdGVuc29yIGZyb20gc3BlY2lmaWMgbG9jYXRpb25cbiAgICAgIC8vXG4gICAgICB0aGlzLmRhdGFMb2NhdGlvbiA9IGFyZzAubG9jYXRpb247XG4gICAgICB0eXBlID0gYXJnMC50eXBlO1xuICAgICAgZGltcyA9IGFyZzAuZGltcztcbiAgICAgIHN3aXRjaCAoYXJnMC5sb2NhdGlvbikge1xuICAgICAgICBjYXNlICdjcHUtcGlubmVkJzoge1xuICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5nZXQodHlwZSk7XG4gICAgICAgICAgaWYgKCFleHBlY3RlZFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7dHlwZX1cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gcGlubmVkIGJ1ZmZlcmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShhcmcwLmRhdGEgaW5zdGFuY2VvZiBleHBlY3RlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGJ1ZmZlciBzaG91bGQgYmUgb2YgdHlwZSAke2V4cGVjdGVkVHlwZWRBcnJheUNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY3B1RGF0YSA9IGFyZzAuZGF0YTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd0ZXh0dXJlJzoge1xuICAgICAgICAgIGlmICh0eXBlICE9PSAnZmxvYXQzMicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke3R5cGV9XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIHRleHR1cmVgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5ncHVUZXh0dXJlRGF0YSA9IGFyZzAudGV4dHVyZTtcbiAgICAgICAgICB0aGlzLmRvd25sb2FkZXIgPSBhcmcwLmRvd25sb2FkO1xuICAgICAgICAgIHRoaXMuZGlzcG9zZXIgPSBhcmcwLmRpc3Bvc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZ3B1LWJ1ZmZlcic6IHtcbiAgICAgICAgICBpZiAoKHR5cGUgIT09ICdmbG9hdDMyJyAmJiB0eXBlICE9PSAnZmxvYXQxNicgJiYgdHlwZSAhPT0gJ2ludDMyJyAmJiB0eXBlICE9PSAnaW50NjQnICYmIHR5cGUgIT09ICd1aW50MzInICYmXG4gICAgICAgICAgICAgICB0eXBlICE9PSAndWludDgnICYmIHR5cGUgIT09ICdib29sJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke3R5cGV9XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIGdwdSBidWZmZXJgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5ncHVCdWZmZXJEYXRhID0gYXJnMC5ncHVCdWZmZXI7XG4gICAgICAgICAgdGhpcy5kb3dubG9hZGVyID0gYXJnMC5kb3dubG9hZDtcbiAgICAgICAgICB0aGlzLmRpc3Bvc2VyID0gYXJnMC5kaXNwb3NlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZW5zb3IgY29uc3RydWN0b3I6IHVuc3VwcG9ydGVkIGxvY2F0aW9uICcke3RoaXMuZGF0YUxvY2F0aW9ufSdgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy9cbiAgICAgIC8vIGNvbnN0cnVjdGluZyB0ZW5zb3Igb2YgbG9jYXRpb24gJ2NwdSdcbiAgICAgIC8vXG4gICAgICBsZXQgZGF0YTogVGVuc29yRGF0YVR5cGU7XG4gICAgICBsZXQgbWF5YmVEaW1zOiB0eXBlb2YgYXJnMXx0eXBlb2YgYXJnMjtcbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgYXJnMCBpcyB0eXBlIG9yIGRhdGFcbiAgICAgIGlmICh0eXBlb2YgYXJnMCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gT3ZlcnJpZGU6IGNvbnN0cnVjdG9yKHR5cGUsIGRhdGEsIC4uLilcbiAgICAgICAgLy9cbiAgICAgICAgdHlwZSA9IGFyZzA7XG4gICAgICAgIG1heWJlRGltcyA9IGFyZzI7XG4gICAgICAgIGlmIChhcmcwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIHN0cmluZyB0ZW5zb3JcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnMSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Egc3RyaW5nIHRlbnNvclxcJ3MgZGF0YSBtdXN0IGJlIGEgc3RyaW5nIGFycmF5LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSBkb24ndCBjaGVjayB3aGV0aGVyIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIGFycmF5IGlzIHN0cmluZzsgdGhpcyBpcyB0b28gc2xvdy4gd2UgYXNzdW1lIGl0J3MgY29ycmVjdCBhbmRcbiAgICAgICAgICAvLyBlcnJvciB3aWxsIGJlIHBvcHVsYXRlZCBhdCBpbmZlcmVuY2VcbiAgICAgICAgICBkYXRhID0gYXJnMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBudW1lcmljIHRlbnNvclxuICAgICAgICAgIGNvbnN0IHR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuZ2V0KGFyZzApO1xuICAgICAgICAgIGlmICh0eXBlZEFycmF5Q29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdGVuc29yIHR5cGU6ICR7YXJnMH0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgICAgICBpZiAoYXJnMCA9PT0gJ2Zsb2F0MTYnICYmIHR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9PT0gVWludDE2QXJyYXkpIHtcbiAgICAgICAgICAgICAgLy8gV2hlbiBubyBGbG9hdDE2QXJyYXkgcG9seWZpbGwgaXMgdXNlZCwgd2UgY2Fubm90IGNyZWF0ZSAnZmxvYXQxNicgdGVuc29yIGZyb20gbnVtYmVyIGFycmF5LlxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyBUaHJvdyBlcnJvciBoZXJlIGJlY2F1c2Ugd2hlbiB1c2VyIHRyeSB0byB1c2UgbnVtYmVyIGFycmF5IGFzIGRhdGEsXG4gICAgICAgICAgICAgIC8vIGUuZy4gbmV3IFRlbnNvcignZmxvYXQxNicsIFsxLCAyLCAzLCA0XSwgZGltcykpLCBpdCB3aWxsIGFjdHVhbGx5IGNhbGxcbiAgICAgICAgICAgICAgLy8gVWludDE2QXJyYXkuZnJvbShhcmcxKSB3aGljaCBnZW5lcmF0ZXMgd3JvbmcgZGF0YS5cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICdDcmVhdGluZyBhIGZsb2F0MTYgdGVuc29yIGZyb20gbnVtYmVyIGFycmF5IGlzIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgVWludDE2QXJyYXkgYXMgZGF0YS4nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnMCA9PT0gJ3VpbnQ2NCcgfHwgYXJnMCA9PT0gJ2ludDY0Jykge1xuICAgICAgICAgICAgICAvLyB1c2UgJ2FzIGFueScgaGVyZSBiZWNhdXNlOlxuICAgICAgICAgICAgICAvLyAxLiBUeXBlU2NyaXB0J3MgY2hlY2sgb24gdHlwZSBvZiAnQXJyYXkuaXNBcnJheSgpJyBkb2VzIG5vdCB3b3JrIHdpdGggcmVhZG9ubHkgYXJyYXlzLlxuICAgICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xNzAwMlxuICAgICAgICAgICAgICAvLyAyLiBUeXBlU2NyaXB0J3MgY2hlY2sgb24gdW5pb24gdHlwZSBvZiAnKEJpZ0ludDY0QXJyYXlDb25zdHJ1Y3RvcnxCaWdVaW50NjRBcnJheUNvbnN0cnVjdG9yKS5mcm9tKCknXG4gICAgICAgICAgICAgIC8vIGRvZXMgbm90IGFjY2VwdCBwYXJhbWV0ZXIgbWFwRm4uXG4gICAgICAgICAgICAgIC8vIDMuIHBhcmFtZXRlcnMgb2YgJ1N1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMuZnJvbSgpJyBkb2VzIG5vdCBtYXRjaCB0aGUgcmVxdWlyZW1lbnQgb2YgdGhlIHVuaW9uXG4gICAgICAgICAgICAgIC8vIHR5cGUuXG5cbiAgICAgICAgICAgICAgLy8gYXNzdW1lICdhcmcxJyBpcyBvZiB0eXBlIFwicmVhZG9ubHkgbnVtYmVyW118cmVhZG9ubHkgYmlnaW50W11cIiBoZXJlLlxuXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgIGRhdGEgPSAodHlwZWRBcnJheUNvbnN0cnVjdG9yIGFzIGFueSkuZnJvbShhcmcxLCBCaWdJbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gYXNzdW1lICdhcmcxJyBpcyBvZiB0eXBlIFwicmVhZG9ubHkgbnVtYmVyW11cIiBoZXJlLlxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICBkYXRhID0gKHR5cGVkQXJyYXlDb25zdHJ1Y3RvciBhcyBhbnkpLmZyb20oYXJnMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChhcmcxIGluc3RhbmNlb2YgdHlwZWRBcnJheUNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBkYXRhID0gYXJnMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSAke3R5cGV9IHRlbnNvcidzIGRhdGEgbXVzdCBiZSB0eXBlIG9mICR7dHlwZWRBcnJheUNvbnN0cnVjdG9yfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gT3ZlcnJpZGU6IGNvbnN0cnVjdG9yKGRhdGEsIC4uLilcbiAgICAgICAgLy9cbiAgICAgICAgbWF5YmVEaW1zID0gYXJnMTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcbiAgICAgICAgICAvLyBvbmx5IGJvb2xlYW5bXSBhbmQgc3RyaW5nW10gaXMgc3VwcG9ydGVkXG4gICAgICAgICAgaWYgKGFyZzAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUZW5zb3IgdHlwZSBjYW5ub3QgYmUgaW5mZXJyZWQgZnJvbSBhbiBlbXB0eSBhcnJheS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZmlyc3RFbGVtZW50VHlwZSA9IHR5cGVvZiBhcmcwWzBdO1xuICAgICAgICAgIGlmIChmaXJzdEVsZW1lbnRUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdHlwZSA9ICdzdHJpbmcnO1xuICAgICAgICAgICAgZGF0YSA9IGFyZzA7XG4gICAgICAgICAgfSBlbHNlIGlmIChmaXJzdEVsZW1lbnRUeXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHR5cGUgPSAnYm9vbCc7XG4gICAgICAgICAgICAvLyAnYXJnMCcgaXMgb2YgdHlwZSAnYm9vbGVhbltdJy4gVWludDhBcnJheS5mcm9tKGJvb2xlYW5bXSkgYWN0dWFsbHkgd29ya3MsIGJ1dCB0eXBlc2NyaXB0IHRoaW5rcyB0aGlzIGlzXG4gICAgICAgICAgICAvLyB3cm9uZyB0eXBlLiBXZSB1c2UgJ2FzIGFueScgdG8gbWFrZSBpdCBoYXBweS5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBkYXRhID0gVWludDhBcnJheS5mcm9tKGFyZzAgYXMgYW55W10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGVsZW1lbnQgdHlwZSBvZiBkYXRhIGFycmF5OiAke2ZpcnN0RWxlbWVudFR5cGV9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBnZXQgdGVuc29yIHR5cGUgZnJvbSBUeXBlZEFycmF5XG4gICAgICAgICAgY29uc3QgbWFwcGVkVHlwZSA9XG4gICAgICAgICAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAuZ2V0KGFyZzAuY29uc3RydWN0b3IgYXMgU3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycyk7XG4gICAgICAgICAgaWYgKG1hcHBlZFR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZSBmb3IgdGVuc29yIGRhdGE6ICR7YXJnMC5jb25zdHJ1Y3Rvcn0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHR5cGUgPSBtYXBwZWRUeXBlO1xuICAgICAgICAgIGRhdGEgPSBhcmcwIGFzIFN1cHBvcnRlZFR5cGVkQXJyYXk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdHlwZSBhbmQgZGF0YSBpcyBwcm9jZXNzZWQsIG5vdyBwcm9jZXNzaW5nIGRpbXNcbiAgICAgIGlmIChtYXliZURpbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBhc3N1bWUgMS1EIHRlbnNvciBpZiBkaW1zIG9taXR0ZWRcbiAgICAgICAgbWF5YmVEaW1zID0gW2RhdGEubGVuZ3RoXTtcbiAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkobWF5YmVEaW1zKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHRlbnNvclxcJ3MgZGltcyBtdXN0IGJlIGEgbnVtYmVyIGFycmF5Jyk7XG4gICAgICB9XG4gICAgICBkaW1zID0gbWF5YmVEaW1zIGFzIHJlYWRvbmx5IG51bWJlcltdO1xuXG4gICAgICB0aGlzLmNwdURhdGEgPSBkYXRhO1xuICAgICAgdGhpcy5kYXRhTG9jYXRpb24gPSAnY3B1JztcbiAgICB9XG5cbiAgICAvLyBwZXJmb3JtIGNoZWNrIG9uIGRpbXNcbiAgICBjb25zdCBzaXplID0gY2FsY3VsYXRlU2l6ZShkaW1zKTtcbiAgICAvLyBpZiBkYXRhIGlzIG9uIENQVSwgY2hlY2sgd2hldGhlciBkYXRhIGxlbmd0aCBtYXRjaGVzIHRlbnNvciBzaXplXG4gICAgaWYgKHRoaXMuY3B1RGF0YSAmJiBzaXplICE9PSB0aGlzLmNwdURhdGEubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvcidzIHNpemUoJHtzaXplfSkgZG9lcyBub3QgbWF0Y2ggZGF0YSBsZW5ndGgoJHt0aGlzLmNwdURhdGEubGVuZ3RofSkuYCk7XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmRpbXMgPSBkaW1zO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gIH1cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gZmFjdG9yeVxuICBzdGF0aWMgYXN5bmMgZnJvbUltYWdlKFxuICAgICAgaW1hZ2U6IEltYWdlRGF0YXxIVE1MSW1hZ2VFbGVtZW50fEltYWdlQml0bWFwfHN0cmluZyxcbiAgICAgIG9wdGlvbnM/OiBUZW5zb3JGcm9tSW1hZ2VEYXRhT3B0aW9uc3xUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9uc3xUZW5zb3JGcm9tSW1hZ2VCaXRtYXBPcHRpb25zfFxuICAgICAgVGVuc29yRnJvbVVybE9wdGlvbnMpOiBQcm9taXNlPFRlbnNvckludGVyZmFjZT4ge1xuICAgIHJldHVybiB0ZW5zb3JGcm9tSW1hZ2UoaW1hZ2UsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21UZXh0dXJlPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuVGV4dHVyZURhdGFUeXBlcz4oXG4gICAgICB0ZXh0dXJlOiBUZW5zb3JUZXh0dXJlVHlwZSwgb3B0aW9uczogVGVuc29yRnJvbVRleHR1cmVPcHRpb25zPFQ+KTogVGVuc29ySW50ZXJmYWNlIHtcbiAgICByZXR1cm4gdGVuc29yRnJvbVRleHR1cmUodGV4dHVyZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUdwdUJ1ZmZlcjxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLkdwdUJ1ZmZlckRhdGFUeXBlcz4oXG4gICAgICBncHVCdWZmZXI6IFRlbnNvckdwdUJ1ZmZlclR5cGUsIG9wdGlvbnM6IFRlbnNvckZyb21HcHVCdWZmZXJPcHRpb25zPFQ+KTogVGVuc29ySW50ZXJmYWNlIHtcbiAgICByZXR1cm4gdGVuc29yRnJvbUdwdUJ1ZmZlcihncHVCdWZmZXIsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21QaW5uZWRCdWZmZXI8VCBleHRlbmRzIFRlbnNvckludGVyZmFjZS5DcHVQaW5uZWREYXRhVHlwZXM+KFxuICAgICAgdHlwZTogVCwgYnVmZmVyOiBUZW5zb3JJbnRlcmZhY2UuRGF0YVR5cGVNYXBbVF0sIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRlbnNvckZyb21QaW5uZWRCdWZmZXIodHlwZSwgYnVmZmVyLCBkaW1zKTtcbiAgfVxuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIGNvbnZlcnNpb25zXG4gIHRvRGF0YVVSTChvcHRpb25zPzogVGVuc29yVG9EYXRhVXJsT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRlbnNvclRvRGF0YVVSTCh0aGlzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHRvSW1hZ2VEYXRhKG9wdGlvbnM/OiBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnMpOiBJbWFnZURhdGEge1xuICAgIHJldHVybiB0ZW5zb3JUb0ltYWdlRGF0YSh0aGlzLCBvcHRpb25zKTtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBwdWJsaWMgZmllbGRzXG4gIHJlYWRvbmx5IGRpbXM6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSB0eXBlOiBUZW5zb3JUeXBlO1xuICByZWFkb25seSBzaXplOiBudW1iZXI7XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHByaXZhdGUgZmllbGRzXG5cbiAgLyoqXG4gICAqIHN0b3JlcyB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEuXG4gICAqL1xuICBwcml2YXRlIGRhdGFMb2NhdGlvbjogVGVuc29yRGF0YUxvY2F0aW9uO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgdGhlIGRhdGEgb24gQ1BVLCBpZiBsb2NhdGlvbiBpcyAnY3B1JyBvciAnY3B1LXBpbm5lZCcuIG90aGVyd2lzZSBlbXB0eS5cbiAgICovXG4gIHByaXZhdGUgY3B1RGF0YT86IFRlbnNvckRhdGFUeXBlO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgdGhlIHVuZGVybHlpbmcgdGV4dHVyZSB3aGVuIGxvY2F0aW9uIGlzICd0ZXh0dXJlJy4gb3RoZXJ3aXNlIGVtcHR5LlxuICAgKi9cbiAgcHJpdmF0ZSBncHVUZXh0dXJlRGF0YT86IFRlbnNvclRleHR1cmVUeXBlO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgdGhlIHVuZGVybHlpbmcgR1BVIGJ1ZmZlciB3aGVuIGxvY2F0aW9uIGlzICdncHUtYnVmZmVyJy4gb3RoZXJ3aXNlIGVtcHR5LlxuICAgKi9cbiAgcHJpdmF0ZSBncHVCdWZmZXJEYXRhPzogVGVuc29yR3B1QnVmZmVyVHlwZTtcblxuICAvKipcbiAgICogc3RvcmVzIGFuIG9wdGlvbmFsIGRvd25sb2FkZXIgZnVuY3Rpb24gdG8gZG93bmxvYWQgZGF0YSBmcm9tIEdQVSB0byBDUFUuXG4gICAqL1xuICBwcml2YXRlIGRvd25sb2FkZXI/KCk6IFByb21pc2U8VGVuc29yRGF0YVR5cGU+O1xuXG4gIC8qKlxuICAgKiBhIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkYXRhIGlzIGJlaW5nIGRvd25sb2FkZWQgZnJvbSBHUFUgdG8gQ1BVLlxuICAgKi9cbiAgcHJpdmF0ZSBpc0Rvd25sb2FkaW5nPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogc3RvcmVzIGFuIG9wdGlvbmFsIGRpc3Bvc2VyIGZ1bmN0aW9uIHRvIGRpc3Bvc2UgdGhlIHVuZGVybHlpbmcgZGF0YS5cbiAgICovXG4gIHByaXZhdGUgZGlzcG9zZXI/KCk6IHZvaWQ7XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHByb3BlcnRpZXNcbiAgZ2V0IGRhdGEoKTogVGVuc29yRGF0YVR5cGUge1xuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcbiAgICBpZiAoIXRoaXMuY3B1RGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdUaGUgZGF0YSBpcyBub3Qgb24gQ1BVLiBVc2UgYGdldERhdGEoKWAgdG8gZG93bmxvYWQgR1BVIGRhdGEgdG8gQ1BVLCAnICtcbiAgICAgICAgICAnb3IgdXNlIGB0ZXh0dXJlYCBvciBgZ3B1QnVmZmVyYCBwcm9wZXJ0eSB0byBhY2Nlc3MgdGhlIEdQVSBkYXRhIGRpcmVjdGx5LicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jcHVEYXRhO1xuICB9XG5cbiAgZ2V0IGxvY2F0aW9uKCk6IFRlbnNvckRhdGFMb2NhdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YUxvY2F0aW9uO1xuICB9XG5cbiAgZ2V0IHRleHR1cmUoKTogVGVuc29yVGV4dHVyZVR5cGUge1xuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcbiAgICBpZiAoIXRoaXMuZ3B1VGV4dHVyZURhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYkdMIHRleHR1cmUuJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdwdVRleHR1cmVEYXRhO1xuICB9XG5cbiAgZ2V0IGdwdUJ1ZmZlcigpOiBUZW5zb3JHcHVCdWZmZXJUeXBlIHtcbiAgICB0aGlzLmVuc3VyZVZhbGlkKCk7XG4gICAgaWYgKCF0aGlzLmdwdUJ1ZmZlckRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYkdQVSBidWZmZXIuJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdwdUJ1ZmZlckRhdGE7XG4gIH1cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gbWV0aG9kc1xuXG4gIGFzeW5jIGdldERhdGEocmVsZWFzZURhdGE/OiBib29sZWFuKTogUHJvbWlzZTxUZW5zb3JEYXRhVHlwZT4ge1xuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcbiAgICBzd2l0Y2ggKHRoaXMuZGF0YUxvY2F0aW9uKSB7XG4gICAgICBjYXNlICdjcHUnOlxuICAgICAgY2FzZSAnY3B1LXBpbm5lZCc6XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgICBjYXNlICd0ZXh0dXJlJzpcbiAgICAgIGNhc2UgJ2dwdS1idWZmZXInOiB7XG4gICAgICAgIGlmICghdGhpcy5kb3dubG9hZGVyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3VycmVudCB0ZW5zb3IgaXMgbm90IGNyZWF0ZWQgd2l0aCBhIHNwZWNpZmllZCBkYXRhIGRvd25sb2FkZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNEb3dubG9hZGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmlzRG93bmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmRvd25sb2FkZXIoKTtcbiAgICAgICAgICB0aGlzLmRvd25sb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy5kYXRhTG9jYXRpb24gPSAnY3B1JztcbiAgICAgICAgICB0aGlzLmNwdURhdGEgPSBkYXRhO1xuXG4gICAgICAgICAgaWYgKHJlbGVhc2VEYXRhICYmIHRoaXMuZGlzcG9zZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG5cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aGlzLmlzRG93bmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZ2V0IGRhdGEgZnJvbSBsb2NhdGlvbjogJHt0aGlzLmRhdGFMb2NhdGlvbn1gKTtcbiAgICB9XG4gIH1cblxuICBkaXNwb3NlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzRG93bmxvYWRpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGlzcG9zZXIpIHtcbiAgICAgIHRoaXMuZGlzcG9zZXIoKTtcbiAgICAgIHRoaXMuZGlzcG9zZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuY3B1RGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmdwdVRleHR1cmVEYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZ3B1QnVmZmVyRGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmRvd25sb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pc0Rvd25sb2FkaW5nID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5kYXRhTG9jYXRpb24gPSAnbm9uZSc7XG4gIH1cblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiB0ZW5zb3IgdXRpbGl0aWVzXG4gIHByaXZhdGUgZW5zdXJlVmFsaWQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZGF0YUxvY2F0aW9uID09PSAnbm9uZScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHRlbnNvciBpcyBkaXNwb3NlZC4nKTtcbiAgICB9XG4gIH1cblxuICByZXNoYXBlKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29ySW50ZXJmYWNlIHtcbiAgICB0aGlzLmVuc3VyZVZhbGlkKCk7XG4gICAgaWYgKHRoaXMuZG93bmxvYWRlciB8fCB0aGlzLmRpc3Bvc2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZXNoYXBlIGEgdGVuc29yIHRoYXQgb3ducyBHUFUgcmVzb3VyY2UuJyk7XG4gICAgfVxuICAgIHJldHVybiB0ZW5zb3JSZXNoYXBlKHRoaXMsIGRpbXMpO1xuICB9XG4gIC8vICNlbmRyZWdpb25cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3JGYWN0b3J5fSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LmpzJztcbmltcG9ydCB7VGVuc29yIGFzIFRlbnNvckltcGx9IGZyb20gJy4vdGVuc29yLWltcGwuanMnO1xuaW1wb3J0IHtUeXBlZFRlbnNvclV0aWxzfSBmcm9tICcuL3RlbnNvci11dGlscy5qcyc7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWRlY2xhcmUgKi9cblxuLyoqXG4gKiByZXByZXNlbnQgYSBiYXNpYyB0ZW5zb3Igd2l0aCBzcGVjaWZpZWQgZGltZW5zaW9ucyBhbmQgZGF0YSB0eXBlLlxuICovXG5pbnRlcmZhY2UgVHlwZWRUZW5zb3JCYXNlPFQgZXh0ZW5kcyBUZW5zb3IuVHlwZT4ge1xuICAvKipcbiAgICogR2V0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSB0ZW5zb3IuXG4gICAqL1xuICByZWFkb25seSBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcbiAgLyoqXG4gICAqIEdldCB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuXG4gICAqL1xuICByZWFkb25seSB0eXBlOiBUO1xuICAvKipcbiAgICogR2V0IHRoZSBidWZmZXIgZGF0YSBvZiB0aGUgdGVuc29yLlxuICAgKlxuICAgKiBJZiB0aGUgZGF0YSBpcyBub3Qgb24gQ1BVIChlZy4gaXQncyBpbiB0aGUgZm9ybSBvZiBXZWJHTCB0ZXh0dXJlIG9yIFdlYkdQVSBidWZmZXIpLCB0aHJvdyBlcnJvci5cbiAgICovXG4gIHJlYWRvbmx5IGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFtUXTtcbiAgLyoqXG4gICAqIEdldCB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEuXG4gICAqL1xuICByZWFkb25seSBsb2NhdGlvbjogVGVuc29yLkRhdGFMb2NhdGlvbjtcbiAgLyoqXG4gICAqIEdldCB0aGUgV2ViR0wgdGV4dHVyZSB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICpcbiAgICogSWYgdGhlIGRhdGEgaXMgbm90IG9uIEdQVSBhcyBXZWJHTCB0ZXh0dXJlLCB0aHJvdyBlcnJvci5cbiAgICovXG4gIHJlYWRvbmx5IHRleHR1cmU6IFRlbnNvci5UZXh0dXJlVHlwZTtcbiAgLyoqXG4gICAqIEdldCB0aGUgV2ViR1BVIGJ1ZmZlciB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICpcbiAgICogSWYgdGhlIGRhdGEgaXMgbm90IG9uIEdQVSBhcyBXZWJHUFUgYnVmZmVyLCB0aHJvdyBlcnJvci5cbiAgICovXG4gIHJlYWRvbmx5IGdwdUJ1ZmZlcjogVGVuc29yLkdwdUJ1ZmZlclR5cGU7XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYnVmZmVyIGRhdGEgb2YgdGhlIHRlbnNvci5cbiAgICpcbiAgICogSWYgdGhlIGRhdGEgaXMgb24gQ1BVLCByZXR1cm5zIHRoZSBkYXRhIGltbWVkaWF0ZWx5LlxuICAgKiBJZiB0aGUgZGF0YSBpcyBvbiBHUFUsIGRvd25sb2FkcyB0aGUgZGF0YSBhbmQgcmV0dXJucyB0aGUgcHJvbWlzZS5cbiAgICpcbiAgICogQHBhcmFtIHJlbGVhc2VEYXRhIC0gd2hldGhlciByZWxlYXNlIHRoZSBkYXRhIG9uIEdQVS4gSWdub3JlIGlmIGRhdGEgaXMgYWxyZWFkeSBvbiBDUFUuXG4gICAqL1xuICBnZXREYXRhKHJlbGVhc2VEYXRhPzogYm9vbGVhbik6IFByb21pc2U8VGVuc29yLkRhdGFUeXBlTWFwW1RdPjtcblxuICAvKipcbiAgICogRGlzcG9zZSB0aGUgdGVuc29yIGRhdGEuXG4gICAqXG4gICAqIElmIHRoZSBkYXRhIGlzIG9uIENQVSwgcmVtb3ZlIGl0cyBpbnRlcm5hbCByZWZlcmVuY2UgdG8gdGhlIHVuZGVybHlpbmcgZGF0YS5cbiAgICogSWYgdGhlIGRhdGEgaXMgb24gR1BVLCByZWxlYXNlIHRoZSBkYXRhIG9uIEdQVS5cbiAgICpcbiAgICogQWZ0ZXIgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLCB0aGUgdGVuc29yIGlzIGNvbnNpZGVyZWQgbm8gbG9uZ2VyIHZhbGlkLiBJdHMgbG9jYXRpb24gd2lsbCBiZSBzZXQgdG8gJ25vbmUnLlxuICAgKi9cbiAgZGlzcG9zZSgpOiB2b2lkO1xufVxuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgVGVuc29yIHtcbiAgaW50ZXJmYWNlIERhdGFUeXBlTWFwIHtcbiAgICBmbG9hdDMyOiBGbG9hdDMyQXJyYXk7XG4gICAgdWludDg6IFVpbnQ4QXJyYXk7XG4gICAgaW50ODogSW50OEFycmF5O1xuICAgIHVpbnQxNjogVWludDE2QXJyYXk7XG4gICAgaW50MTY6IEludDE2QXJyYXk7XG4gICAgaW50MzI6IEludDMyQXJyYXk7XG4gICAgaW50NjQ6IEJpZ0ludDY0QXJyYXk7XG4gICAgc3RyaW5nOiBzdHJpbmdbXTtcbiAgICBib29sOiBVaW50OEFycmF5O1xuICAgIGZsb2F0MTY6IFVpbnQxNkFycmF5OyAgLy8gS2VlcCB1c2luZyBVaW50MTZBcnJheSB1bnRpbCB3ZSBoYXZlIGEgY29uY3JldGUgc29sdXRpb24gZm9yIGZsb2F0IDE2LlxuICAgIGZsb2F0NjQ6IEZsb2F0NjRBcnJheTtcbiAgICB1aW50MzI6IFVpbnQzMkFycmF5O1xuICAgIHVpbnQ2NDogQmlnVWludDY0QXJyYXk7XG4gICAgLy8gY29tcGxleDY0OiBuZXZlcjtcbiAgICAvLyBjb21wbGV4MTI4OiBuZXZlcjtcbiAgICAvLyBiZmxvYXQxNjogbmV2ZXI7XG4gIH1cblxuICBpbnRlcmZhY2UgRWxlbWVudFR5cGVNYXAge1xuICAgIGZsb2F0MzI6IG51bWJlcjtcbiAgICB1aW50ODogbnVtYmVyO1xuICAgIGludDg6IG51bWJlcjtcbiAgICB1aW50MTY6IG51bWJlcjtcbiAgICBpbnQxNjogbnVtYmVyO1xuICAgIGludDMyOiBudW1iZXI7XG4gICAgaW50NjQ6IGJpZ2ludDtcbiAgICBzdHJpbmc6IHN0cmluZztcbiAgICBib29sOiBib29sZWFuO1xuICAgIGZsb2F0MTY6IG51bWJlcjsgIC8vIEtlZXAgdXNpbmcgVWludDE2QXJyYXkgdW50aWwgd2UgaGF2ZSBhIGNvbmNyZXRlIHNvbHV0aW9uIGZvciBmbG9hdCAxNi5cbiAgICBmbG9hdDY0OiBudW1iZXI7XG4gICAgdWludDMyOiBudW1iZXI7XG4gICAgdWludDY0OiBiaWdpbnQ7XG4gICAgLy8gY29tcGxleDY0OiBuZXZlcjtcbiAgICAvLyBjb21wbGV4MTI4OiBuZXZlcjtcbiAgICAvLyBiZmxvYXQxNjogbmV2ZXI7XG4gIH1cblxuICB0eXBlIERhdGFUeXBlID0gRGF0YVR5cGVNYXBbVHlwZV07XG4gIHR5cGUgRWxlbWVudFR5cGUgPSBFbGVtZW50VHlwZU1hcFtUeXBlXTtcblxuICAvKipcbiAgICogc3VwcG9ydGVkIGRhdGEgdHlwZXMgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgcGlubmVkIENQVSBidWZmZXJcbiAgICovXG4gIGV4cG9ydCB0eXBlIENwdVBpbm5lZERhdGFUeXBlcyA9IEV4Y2x1ZGU8VGVuc29yLlR5cGUsICdzdHJpbmcnPjtcblxuICAvKipcbiAgICogdHlwZSBhbGlhcyBmb3IgV2ViR0wgdGV4dHVyZVxuICAgKi9cbiAgZXhwb3J0IHR5cGUgVGV4dHVyZVR5cGUgPSBXZWJHTFRleHR1cmU7XG5cbiAgLyoqXG4gICAqIHN1cHBvcnRlZCBkYXRhIHR5cGVzIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIFdlYkdMIHRleHR1cmVcbiAgICovXG4gIGV4cG9ydCB0eXBlIFRleHR1cmVEYXRhVHlwZXMgPSAnZmxvYXQzMic7XG5cbiAgLyoqXG4gICAqIHR5cGUgYWxpYXMgZm9yIFdlYkdQVSBidWZmZXJcbiAgICpcbiAgICogVGhlIHJlYXNvbiB3aHkgd2UgZG9uJ3QgdXNlIHR5cGUgXCJHUFVCdWZmZXJcIiBkZWZpbmVkIGluIHdlYmdwdS5kLnRzIGZyb20gQHdlYmdwdS90eXBlcyBpcyBiZWNhdXNlIFwiQHdlYmdwdS90eXBlc1wiXG4gICAqIHJlcXVpcmVzIFwiQHR5cGVzL2RvbS13ZWJjb2RlY3NcIiBhcyBwZWVyIGRlcGVuZGVuY3kgd2hlbiB1c2luZyBUeXBlU2NyaXB0IDwgdjUuMSBhbmQgaXRzIHZlcnNpb24gbmVlZCB0byBiZSBjaG9zZW5cbiAgICogY2FyZWZ1bGx5IGFjY29yZGluZyB0byB0aGUgVHlwZVNjcmlwdCB2ZXJzaW9uIGJlaW5nIHVzZWQuIFRoaXMgbWVhbnMgc28gZmFyIHRoZXJlIGlzIG5vdCBhIHdheSB0byBrZWVwIGV2ZXJ5XG4gICAqIFR5cGVTY3JpcHQgdmVyc2lvbiBoYXBweS4gSXQgdHVybnMgb3V0IHRoYXQgd2Ugd2lsbCBlYXNpbHkgYnJva2UgdXNlcnMgb24gc29tZSBUeXBlU2NyaXB0IHZlcnNpb24uXG4gICAqXG4gICAqIGZvciBtb3JlIGluZm8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncHV3ZWIvdHlwZXMvaXNzdWVzLzEyN1xuICAgKi9cbiAgZXhwb3J0IHR5cGUgR3B1QnVmZmVyVHlwZSA9IHtzaXplOiBudW1iZXI7IG1hcFN0YXRlOiAndW5tYXBwZWQnIHwgJ3BlbmRpbmcnIHwgJ21hcHBlZCd9O1xuXG4gIC8qKlxuICAgKiBzdXBwb3J0ZWQgZGF0YSB0eXBlcyBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBXZWJHUFUgYnVmZmVyXG4gICAqL1xuICBleHBvcnQgdHlwZSBHcHVCdWZmZXJEYXRhVHlwZXMgPSAnZmxvYXQzMid8J2Zsb2F0MTYnfCdpbnQzMid8J2ludDY0J3wndWludDMyJ3wndWludDgnfCdib29sJztcblxuICAvKipcbiAgICogcmVwcmVzZW50IHdoZXJlIHRoZSB0ZW5zb3IgZGF0YSBpcyBzdG9yZWRcbiAgICovXG4gIGV4cG9ydCB0eXBlIERhdGFMb2NhdGlvbiA9ICdub25lJ3wnY3B1J3wnY3B1LXBpbm5lZCd8J3RleHR1cmUnfCdncHUtYnVmZmVyJztcblxuICAvKipcbiAgICogcmVwcmVzZW50IHRoZSBkYXRhIHR5cGUgb2YgYSB0ZW5zb3JcbiAgICovXG4gIGV4cG9ydCB0eXBlIFR5cGUgPSBrZXlvZiBEYXRhVHlwZU1hcDtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgbXVsdGktZGltZW5zaW9uYWwgYXJyYXlzIHRvIGZlZWQgdG8gb3IgZmV0Y2ggZnJvbSBtb2RlbCBpbmZlcmVuY2luZy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUeXBlZFRlbnNvcjxUIGV4dGVuZHMgVGVuc29yLlR5cGU+IGV4dGVuZHMgVHlwZWRUZW5zb3JCYXNlPFQ+LCBUeXBlZFRlbnNvclV0aWxzPFQ+IHt9XG4vKipcbiAqIFJlcHJlc2VudCBtdWx0aS1kaW1lbnNpb25hbCBhcnJheXMgdG8gZmVlZCB0byBvciBmZXRjaCBmcm9tIG1vZGVsIGluZmVyZW5jaW5nLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvciBleHRlbmRzIFR5cGVkVGVuc29yQmFzZTxUZW5zb3IuVHlwZT4sIFR5cGVkVGVuc29yVXRpbHM8VGVuc29yLlR5cGU+IHt9XG5cbi8qKlxuICogdHlwZSBUZW5zb3JDb25zdHJ1Y3RvciBkZWZpbmVzIHRoZSBjb25zdHJ1Y3RvcnMgb2YgJ1RlbnNvcicgdG8gY3JlYXRlIENQVSB0ZW5zb3IgaW5zdGFuY2VzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckNvbnN0cnVjdG9yIGV4dGVuZHMgVGVuc29yRmFjdG9yeSB7XG4gIC8vICNyZWdpb24gQ1BVIHRlbnNvciAtIHNwZWNpZnkgZWxlbWVudCB0eXBlXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgc3RyaW5nIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyh0eXBlOiAnc3RyaW5nJywgZGF0YTogVGVuc29yLkRhdGFUeXBlTWFwWydzdHJpbmcnXXxyZWFkb25seSBzdHJpbmdbXSxcbiAgICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdzdHJpbmcnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGJvb2wgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB0eXBlLCBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIFNwZWNpZnkgdGhlIGVsZW1lbnQgdHlwZS5cbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KHR5cGU6ICdib29sJywgZGF0YTogVGVuc29yLkRhdGFUeXBlTWFwWydib29sJ118cmVhZG9ubHkgYm9vbGVhbltdLCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnYm9vbCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgNjQtYml0IGludGVnZXIgdHlwZWQgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB0eXBlLCBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIFNwZWNpZnkgdGhlIGVsZW1lbnQgdHlwZS5cbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3PFQgZXh0ZW5kcyAndWludDY0J3wnaW50NjQnPihcbiAgICAgIHR5cGU6IFQsIGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFtUXXxyZWFkb25seSBiaWdpbnRbXXxyZWFkb25seSBudW1iZXJbXSxcbiAgICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPFQ+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgbnVtZXJpYyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIHR5cGUsIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gU3BlY2lmeSB0aGUgZWxlbWVudCB0eXBlLlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXc8VCBleHRlbmRzIEV4Y2x1ZGU8VGVuc29yLlR5cGUsICdzdHJpbmcnfCdib29sJ3wndWludDY0J3wnaW50NjQnPj4oXG4gICAgICB0eXBlOiBULCBkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbVF18cmVhZG9ubHkgbnVtYmVyW10sIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPFQ+O1xuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBDUFUgdGVuc29yIC0gaW5mZXIgZWxlbWVudCB0eXBlc1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgZmxvYXQzMiB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyhkYXRhOiBGbG9hdDMyQXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdmbG9hdDMyJz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBpbnQ4IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KGRhdGE6IEludDhBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2ludDgnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHVpbnQ4IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KGRhdGE6IFVpbnQ4QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50OCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdWludDE2IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KGRhdGE6IFVpbnQxNkFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwndWludDE2Jz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBpbnQxNiB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyhkYXRhOiBJbnQxNkFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnaW50MTYnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGludDMyIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KGRhdGE6IEludDMyQXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdpbnQzMic+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgaW50NjQgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcoZGF0YTogQmlnSW50NjRBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2ludDY0Jz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBzdHJpbmcgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcoZGF0YTogcmVhZG9ubHkgc3RyaW5nW10sIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdzdHJpbmcnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGJvb2wgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcoZGF0YTogcmVhZG9ubHkgYm9vbGVhbltdLCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnYm9vbCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgZmxvYXQ2NCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyhkYXRhOiBGbG9hdDY0QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdmbG9hdDY0Jz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB1aW50MzIgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcoZGF0YTogVWludDMyQXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50MzInPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHVpbnQ2NCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyhkYXRhOiBCaWdVaW50NjRBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J3VpbnQ2NCc+O1xuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIENQVSB0ZW5zb3IgLSBmYWxsIGJhY2sgdG8gbm9uLWdlbmVyaWMgdGVuc29yIHR5cGUgZGVjbGFyYXRpb25cblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyh0eXBlOiBUZW5zb3IuVHlwZSwgZGF0YTogVGVuc29yLkRhdGFUeXBlfHJlYWRvbmx5IG51bWJlcltdfHJlYWRvbmx5IHN0cmluZ1tdfHJlYWRvbmx5IGJpZ2ludFtdfHJlYWRvbmx5IGJvb2xlYW5bXSxcbiAgICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvcjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KGRhdGE6IFRlbnNvci5EYXRhVHlwZSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29yO1xuICAvLyAjZW5kcmVnaW9uXG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmV4cG9ydCBjb25zdCBUZW5zb3IgPSBUZW5zb3JJbXBsIGFzIFRlbnNvckNvbnN0cnVjdG9yO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge2Vudn0gZnJvbSAnLi9lbnYtaW1wbC5qcyc7XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY29uc3QgVFJBQ0UgPSAoZGV2aWNlVHlwZTogc3RyaW5nLCBsYWJlbDogc3RyaW5nKSA9PiB7XG4gIGlmICh0eXBlb2YgZW52LnRyYWNlID09PSAndW5kZWZpbmVkJyA/ICFlbnYud2FzbS50cmFjZSA6ICFlbnYudHJhY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgY29uc29sZS50aW1lU3RhbXAoYCR7ZGV2aWNlVHlwZX06Ok9SVDo6JHtsYWJlbH1gKTtcbn07XG5cbmNvbnN0IFRSQUNFX0ZVTkMgPSAobXNnOiBzdHJpbmcsIGV4dHJhTXNnPzogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s/LnNwbGl0KC9cXHJcXG58XFxyfFxcbi9nKSB8fCBbXTtcbiAgbGV0IGhhc1RyYWNlRnVuYyA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGhhc1RyYWNlRnVuYyAmJiAhc3RhY2tbaV0uaW5jbHVkZXMoJ1RSQUNFX0ZVTkMnKSkge1xuICAgICAgbGV0IGxhYmVsID0gYEZVTkNfJHttc2d9Ojoke3N0YWNrW2ldLnRyaW0oKS5zcGxpdCgnICcpWzFdfWA7XG4gICAgICBpZiAoZXh0cmFNc2cpIHtcbiAgICAgICAgbGFiZWwgKz0gYDo6JHtleHRyYU1zZ31gO1xuICAgICAgfVxuICAgICAgVFJBQ0UoJ0NQVScsIGxhYmVsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN0YWNrW2ldLmluY2x1ZGVzKCdUUkFDRV9GVU5DJykpIHtcbiAgICAgIGhhc1RyYWNlRnVuYyA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGNvbnN0IFRSQUNFX0ZVTkNfQkVHSU4gPSAoZXh0cmFNc2c/OiBzdHJpbmcpID0+IHtcbiAgaWYgKHR5cGVvZiBlbnYudHJhY2UgPT09ICd1bmRlZmluZWQnID8gIWVudi53YXNtLnRyYWNlIDogIWVudi50cmFjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBUUkFDRV9GVU5DKCdCRUdJTicsIGV4dHJhTXNnKTtcbn07XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY29uc3QgVFJBQ0VfRlVOQ19FTkQgPSAoZXh0cmFNc2c/OiBzdHJpbmcpID0+IHtcbiAgaWYgKHR5cGVvZiBlbnYudHJhY2UgPT09ICd1bmRlZmluZWQnID8gIWVudi53YXNtLnRyYWNlIDogIWVudi50cmFjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBUUkFDRV9GVU5DKCdFTkQnLCBleHRyYU1zZyk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge3Jlc29sdmVCYWNrZW5kQW5kRXhlY3V0aW9uUHJvdmlkZXJzfSBmcm9tICcuL2JhY2tlbmQtaW1wbC5qcyc7XG5pbXBvcnQge0luZmVyZW5jZVNlc3Npb25IYW5kbGVyfSBmcm9tICcuL2JhY2tlbmQuanMnO1xuaW1wb3J0IHtJbmZlcmVuY2VTZXNzaW9uIGFzIEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2V9IGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24uanMnO1xuaW1wb3J0IHtPbm54VmFsdWV9IGZyb20gJy4vb25ueC12YWx1ZS5qcyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi90ZW5zb3IuanMnO1xuaW1wb3J0IHtUUkFDRV9GVU5DX0JFR0lOLCBUUkFDRV9GVU5DX0VORH0gZnJvbSAnLi90cmFjZS5qcyc7XG5cbnR5cGUgU2Vzc2lvbk9wdGlvbnMgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLlNlc3Npb25PcHRpb25zO1xudHlwZSBSdW5PcHRpb25zID0gSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5SdW5PcHRpb25zO1xudHlwZSBGZWVkc1R5cGUgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLkZlZWRzVHlwZTtcbnR5cGUgRmV0Y2hlc1R5cGUgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLkZldGNoZXNUeXBlO1xudHlwZSBSZXR1cm5UeXBlID0gSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5SZXR1cm5UeXBlO1xuXG5leHBvcnQgY2xhc3MgSW5mZXJlbmNlU2Vzc2lvbiBpbXBsZW1lbnRzIEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2Uge1xuICBwcml2YXRlIGNvbnN0cnVjdG9yKGhhbmRsZXI6IEluZmVyZW5jZVNlc3Npb25IYW5kbGVyKSB7XG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgfVxuICBydW4oZmVlZHM6IEZlZWRzVHlwZSwgb3B0aW9ucz86IFJ1bk9wdGlvbnMpOiBQcm9taXNlPFJldHVyblR5cGU+O1xuICBydW4oZmVlZHM6IEZlZWRzVHlwZSwgZmV0Y2hlczogRmV0Y2hlc1R5cGUsIG9wdGlvbnM/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPjtcbiAgYXN5bmMgcnVuKGZlZWRzOiBGZWVkc1R5cGUsIGFyZzE/OiBGZXRjaGVzVHlwZXxSdW5PcHRpb25zLCBhcmcyPzogUnVuT3B0aW9ucyk6IFByb21pc2U8UmV0dXJuVHlwZT4ge1xuICAgIFRSQUNFX0ZVTkNfQkVHSU4oKTtcbiAgICBjb25zdCBmZXRjaGVzOiB7W25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZXxudWxsfSA9IHt9O1xuICAgIGxldCBvcHRpb25zOiBSdW5PcHRpb25zID0ge307XG4gICAgLy8gY2hlY2sgaW5wdXRzXG4gICAgaWYgKHR5cGVvZiBmZWVkcyAhPT0gJ29iamVjdCcgfHwgZmVlZHMgPT09IG51bGwgfHwgZmVlZHMgaW5zdGFuY2VvZiBUZW5zb3IgfHwgQXJyYXkuaXNBcnJheShmZWVkcykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ1xcJ2ZlZWRzXFwnIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgdXNlIGlucHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy4nKTtcbiAgICB9XG5cbiAgICBsZXQgaXNGZXRjaGVzRW1wdHkgPSB0cnVlO1xuICAgIC8vIGRldGVybWluZSB3aGljaCBvdmVycmlkZSBpcyBiZWluZyB1c2VkXG4gICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGFyZzEgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5leHBlY3RlZCBhcmd1bWVudFsxXTogY2Fubm90IGJlIG51bGwuJyk7XG4gICAgICB9XG4gICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdmZXRjaGVzXFwnIGNhbm5vdCBiZSBhIFRlbnNvcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcxKSkge1xuICAgICAgICBpZiAoYXJnMS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdmZXRjaGVzXFwnIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpc0ZldGNoZXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICAvLyBvdXRwdXQgbmFtZXNcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIGFyZzEpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdmZXRjaGVzXFwnIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkgb3IgYW4gb2JqZWN0LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdmZXRjaGVzJyBjb250YWlucyBpbnZhbGlkIG91dHB1dCBuYW1lOiAke25hbWV9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmZXRjaGVzW25hbWVdID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ29iamVjdCcgJiYgYXJnMiAhPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ29wdGlvbnNcXCcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlY2lkZSB3aGV0aGVyIGFyZzEgaXMgZmV0Y2hlcyBvciBvcHRpb25zXG4gICAgICAgIC8vIGlmIGFueSBvdXRwdXQgbmFtZSBpcyBwcmVzZW50IGFuZCBpdHMgdmFsdWUgaXMgdmFsaWQgT25ueFZhbHVlLCB3ZSBjb25zaWRlciBpdCBmZXRjaGVzXG4gICAgICAgIGxldCBpc0ZldGNoZXMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgYXJnMUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcmcxKTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMub3V0cHV0TmFtZXMpIHtcbiAgICAgICAgICBpZiAoYXJnMUtleXMuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSAoYXJnMSBhcyBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLk51bGxhYmxlT25ueFZhbHVlTWFwVHlwZSlbbmFtZV07XG4gICAgICAgICAgICBpZiAodiA9PT0gbnVsbCB8fCB2IGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgICAgICAgIGlzRmV0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0ZldGNoZXMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zID0gYXJnMSBhcyBSdW5PcHRpb25zO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VuZXhwZWN0ZWQgYXJndW1lbnRbMV06IG11c3QgYmUgXFwnZmV0Y2hlc1xcJyBvciBcXCdvcHRpb25zXFwnLicpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIGFsbCBpbnB1dHMgYXJlIGluIGZlZWRcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5pbnB1dE5hbWVzKSB7XG4gICAgICBpZiAodHlwZW9mIGZlZWRzW25hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGlucHV0ICcke25hbWV9JyBpcyBtaXNzaW5nIGluICdmZWVkcycuYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgbm8gZmV0Y2hlcyBpcyBzcGVjaWZpZWQsIHdlIHVzZSB0aGUgZnVsbCBvdXRwdXQgbmFtZXMgbGlzdFxuICAgIGlmIChpc0ZldGNoZXNFbXB0eSkge1xuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMub3V0cHV0TmFtZXMpIHtcbiAgICAgICAgZmV0Y2hlc1tuYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmVlZHMsIGZldGNoZXMgYW5kIG9wdGlvbnMgYXJlIHByZXBhcmVkXG5cbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5oYW5kbGVyLnJ1bihmZWVkcywgZmV0Y2hlcywgb3B0aW9ucyk7XG4gICAgY29uc3QgcmV0dXJuVmFsdWU6IHtbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlfSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdHMpIHtcbiAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHRzLCBrZXkpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdHNba2V5XTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICAgIHJldHVyblZhbHVlW2tleV0gPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuVmFsdWVba2V5XSA9IG5ldyBUZW5zb3IocmVzdWx0LnR5cGUsIHJlc3VsdC5kYXRhLCByZXN1bHQuZGltcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgVFJBQ0VfRlVOQ19FTkQoKTtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH1cblxuICBhc3luYyByZWxlYXNlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZShwYXRoOiBzdHJpbmcsIG9wdGlvbnM/OiBTZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZT47XG4gIHN0YXRpYyBjcmVhdGUoYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2UsIG9wdGlvbnM/OiBTZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZT47XG4gIHN0YXRpYyBjcmVhdGUoYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2UsIGJ5dGVPZmZzZXQ6IG51bWJlciwgYnl0ZUxlbmd0aD86IG51bWJlciwgb3B0aW9ucz86IFNlc3Npb25PcHRpb25zKTpcbiAgICAgIFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZT47XG4gIHN0YXRpYyBjcmVhdGUoYnVmZmVyOiBVaW50OEFycmF5LCBvcHRpb25zPzogU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2U+O1xuICBzdGF0aWMgYXN5bmMgY3JlYXRlKFxuICAgICAgYXJnMDogc3RyaW5nfEFycmF5QnVmZmVyTGlrZXxVaW50OEFycmF5LCBhcmcxPzogU2Vzc2lvbk9wdGlvbnN8bnVtYmVyLCBhcmcyPzogbnVtYmVyLFxuICAgICAgYXJnMz86IFNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlPiB7XG4gICAgVFJBQ0VfRlVOQ19CRUdJTigpO1xuICAgIC8vIGVpdGhlciBsb2FkIGZyb20gYSBmaWxlIG9yIGJ1ZmZlclxuICAgIGxldCBmaWxlUGF0aE9yVWludDhBcnJheTogc3RyaW5nfFVpbnQ4QXJyYXk7XG4gICAgbGV0IG9wdGlvbnM6IFNlc3Npb25PcHRpb25zID0ge307XG5cbiAgICBpZiAodHlwZW9mIGFyZzAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBmaWxlUGF0aE9yVWludDhBcnJheSA9IGFyZzA7XG4gICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnICYmIGFyZzEgIT09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IGFyZzE7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJnMCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIGZpbGVQYXRoT3JVaW50OEFycmF5ID0gYXJnMDtcbiAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcgJiYgYXJnMSAhPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ29wdGlvbnNcXCcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgICAgYXJnMCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgICAgICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGFyZzAgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcikpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGFyZzA7XG4gICAgICBsZXQgYnl0ZU9mZnNldCA9IDA7XG4gICAgICBsZXQgYnl0ZUxlbmd0aCA9IGFyZzAuYnl0ZUxlbmd0aDtcbiAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcgJiYgYXJnMSAhPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGJ5dGVPZmZzZXQgPSBhcmcxO1xuICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGJ5dGVPZmZzZXQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2J5dGVPZmZzZXRcXCcgbXVzdCBiZSBhbiBpbnRlZ2VyLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBieXRlT2Zmc2V0ID49IGJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdieXRlT2Zmc2V0JyBpcyBvdXQgb2YgcmFuZ2UgWzAsICR7YnVmZmVyLmJ5dGVMZW5ndGh9KS5gKTtcbiAgICAgICAgfVxuICAgICAgICBieXRlTGVuZ3RoID0gYXJnMC5ieXRlTGVuZ3RoIC0gYnl0ZU9mZnNldDtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcyID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGJ5dGVMZW5ndGggPSBhcmcyO1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoYnl0ZUxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdieXRlTGVuZ3RoXFwnIG11c3QgYmUgYW4gaW50ZWdlci4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJ5dGVMZW5ndGggPD0gMCB8fCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVMZW5ndGgnIGlzIG91dCBvZiByYW5nZSAoMCwgJHtidWZmZXIuYnl0ZUxlbmd0aCAtIGJ5dGVPZmZzZXR9XS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBhcmczID09PSAnb2JqZWN0JyAmJiBhcmczICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gYXJnMztcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmczICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnb3B0aW9uc1xcJyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnYnl0ZUxlbmd0aFxcJyBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgfVxuICAgICAgZmlsZVBhdGhPclVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIGFyZ3VtZW50WzBdOiBtdXN0IGJlIFxcJ3BhdGhcXCcgb3IgXFwnYnVmZmVyXFwnLicpO1xuICAgIH1cblxuICAgIC8vIHJlc29sdmUgYmFja2VuZCwgdXBkYXRlIHNlc3Npb24gb3B0aW9ucyB3aXRoIHZhbGlkYXRlZCBFUHMsIGFuZCBjcmVhdGUgc2Vzc2lvbiBoYW5kbGVyXG4gICAgY29uc3QgW2JhY2tlbmQsIG9wdGlvbnNXaXRoVmFsaWRhdGVkRVBzXSA9IGF3YWl0IHJlc29sdmVCYWNrZW5kQW5kRXhlY3V0aW9uUHJvdmlkZXJzKG9wdGlvbnMpO1xuICAgIGNvbnN0IGhhbmRsZXIgPSBhd2FpdCBiYWNrZW5kLmNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKGZpbGVQYXRoT3JVaW50OEFycmF5LCBvcHRpb25zV2l0aFZhbGlkYXRlZEVQcyk7XG4gICAgVFJBQ0VfRlVOQ19FTkQoKTtcbiAgICByZXR1cm4gbmV3IEluZmVyZW5jZVNlc3Npb24oaGFuZGxlcik7XG4gIH1cblxuICBzdGFydFByb2ZpbGluZygpOiB2b2lkIHtcbiAgICB0aGlzLmhhbmRsZXIuc3RhcnRQcm9maWxpbmcoKTtcbiAgfVxuICBlbmRQcm9maWxpbmcoKTogdm9pZCB7XG4gICAgdGhpcy5oYW5kbGVyLmVuZFByb2ZpbGluZygpO1xuICB9XG5cbiAgZ2V0IGlucHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuaW5wdXROYW1lcztcbiAgfVxuICBnZXQgb3V0cHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIub3V0cHV0TmFtZXM7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZXI6IEluZmVyZW5jZVNlc3Npb25IYW5kbGVyO1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0luZmVyZW5jZVNlc3Npb24gYXMgSW5mZXJlbmNlU2Vzc2lvbkltcGx9IGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24taW1wbC5qcyc7XG5pbXBvcnQge09ubnhNb2RlbE9wdGlvbnN9IGZyb20gJy4vb25ueC1tb2RlbC5qcyc7XG5pbXBvcnQge09ubnhWYWx1ZSwgT25ueFZhbHVlRGF0YUxvY2F0aW9ufSBmcm9tICcuL29ubngtdmFsdWUuanMnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkZWNsYXJlICovXG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBJbmZlcmVuY2VTZXNzaW9uIHtcbiAgLy8gI3JlZ2lvbiBpbnB1dC9vdXRwdXQgdHlwZXNcblxuICB0eXBlIE9ubnhWYWx1ZU1hcFR5cGUgPSB7cmVhZG9ubHkgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZX07XG4gIHR5cGUgTnVsbGFibGVPbm54VmFsdWVNYXBUeXBlID0ge3JlYWRvbmx5IFtuYW1lOiBzdHJpbmddOiBPbm54VmFsdWUgfCBudWxsfTtcblxuICAvKipcbiAgICogQSBmZWVkcyAobW9kZWwgaW5wdXRzKSBpcyBhbiBvYmplY3QgdGhhdCB1c2VzIGlucHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICovXG4gIHR5cGUgRmVlZHNUeXBlID0gT25ueFZhbHVlTWFwVHlwZTtcblxuICAvKipcbiAgICogQSBmZXRjaGVzIChtb2RlbCBvdXRwdXRzKSBjb3VsZCBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAgICpcbiAgICogLSBPbWl0dGVkLiBVc2UgbW9kZWwncyBvdXRwdXQgbmFtZXMgZGVmaW5pdGlvbi5cbiAgICogLSBBbiBhcnJheSBvZiBzdHJpbmcgaW5kaWNhdGluZyB0aGUgb3V0cHV0IG5hbWVzLlxuICAgKiAtIEFuIG9iamVjdCB0aGF0IHVzZSBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIG9yIG51bGwgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAqXG4gICAqIEByZW1hcmtcbiAgICogZGlmZmVyZW50IGZyb20gaW5wdXQgYXJndW1lbnQsIGluIG91dHB1dCwgT25ueFZhbHVlIGlzIG9wdGlvbmFsLiBJZiBhbiBPbm54VmFsdWUgaXMgcHJlc2VudCBpdCB3aWxsIGJlXG4gICAqIHVzZWQgYXMgYSBwcmUtYWxsb2NhdGVkIHZhbHVlIGJ5IHRoZSBpbmZlcmVuY2UgZW5naW5lOyBpZiBvbWl0dGVkLCBpbmZlcmVuY2UgZW5naW5lIHdpbGwgYWxsb2NhdGUgYnVmZmVyXG4gICAqIGludGVybmFsbHkuXG4gICAqL1xuICB0eXBlIEZldGNoZXNUeXBlID0gcmVhZG9ubHkgc3RyaW5nW118TnVsbGFibGVPbm54VmFsdWVNYXBUeXBlO1xuXG4gIC8qKlxuICAgKiBBIGluZmVyZW5jaW5nIHJldHVybiB0eXBlIGlzIGFuIG9iamVjdCB0aGF0IHVzZXMgb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICovXG4gIHR5cGUgUmV0dXJuVHlwZSA9IE9ubnhWYWx1ZU1hcFR5cGU7XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gc2Vzc2lvbiBvcHRpb25zXG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIGNvbmZpZ3VyYXRpb25zIGZvciBzZXNzaW9uIGJlaGF2aW9yLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uT3B0aW9ucyBleHRlbmRzIE9ubnhNb2RlbE9wdGlvbnMge1xuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIGV4ZWN1dGlvbiBwcm92aWRlciBvcHRpb25zLlxuICAgICAqXG4gICAgICogQW4gZXhlY3V0aW9uIHByb3ZpZGVyIG9wdGlvbiBjYW4gYmUgYSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgbmFtZSBvZiB0aGUgZXhlY3V0aW9uIHByb3ZpZGVyLFxuICAgICAqIG9yIGFuIG9iamVjdCBvZiBjb3JyZXNwb25kaW5nIHR5cGUuXG4gICAgICovXG4gICAgZXhlY3V0aW9uUHJvdmlkZXJzPzogcmVhZG9ubHkgRXhlY3V0aW9uUHJvdmlkZXJDb25maWdbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRyYSBPUCB0aHJlYWRzIG51bWJlci5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpLlxuICAgICAqL1xuICAgIGludHJhT3BOdW1UaHJlYWRzPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVyIE9QIHRocmVhZHMgbnVtYmVyLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkuXG4gICAgICovXG4gICAgaW50ZXJPcE51bVRocmVhZHM/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgZnJlZURpbWVuc2lvbk92ZXJyaWRlcz86IHtyZWFkb25seSBbZGltZW5zaW9uTmFtZTogc3RyaW5nXTogbnVtYmVyfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHRpbWl6YXRpb24gbGV2ZWwuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgZ3JhcGhPcHRpbWl6YXRpb25MZXZlbD86ICdkaXNhYmxlZCd8J2Jhc2ljJ3wnZXh0ZW5kZWQnfCdhbGwnO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBlbmFibGUgQ1BVIG1lbW9yeSBhcmVuYS5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBlbmFibGVDcHVNZW1BcmVuYT86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGVuYWJsZSBtZW1vcnkgcGF0dGVybi5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBlbmFibGVNZW1QYXR0ZXJuPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGlvbiBtb2RlLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGV4ZWN1dGlvbk1vZGU/OiAnc2VxdWVudGlhbCd8J3BhcmFsbGVsJztcblxuICAgIC8qKlxuICAgICAqIE9wdGltaXplZCBtb2RlbCBmaWxlIHBhdGguXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIHNldHRpbmcgaXMgc3BlY2lmaWVkLCB0aGUgb3B0aW1pemVkIG1vZGVsIHdpbGwgYmUgZHVtcGVkLiBJbiBicm93c2VyLCBhIGJsb2Igd2lsbCBiZSBjcmVhdGVkXG4gICAgICogd2l0aCBhIHBvcC11cCB3aW5kb3cuXG4gICAgICovXG4gICAgb3B0aW1pemVkTW9kZWxGaWxlUGF0aD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgZW5hYmxlIHByb2ZpbGluZy5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhIHBsYWNlaG9sZGVyIGZvciBhIGZ1dHVyZSB1c2UuXG4gICAgICovXG4gICAgZW5hYmxlUHJvZmlsaW5nPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEZpbGUgcHJlZml4IGZvciBwcm9maWxpbmcuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYSBwbGFjZWhvbGRlciBmb3IgYSBmdXR1cmUgdXNlLlxuICAgICAqL1xuICAgIHByb2ZpbGVGaWxlUHJlZml4Pzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogTG9nIElELlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGxvZ0lkPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogTG9nIHNldmVyaXR5IGxldmVsLiBTZWVcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhydW50aW1lL2Jsb2IvbWFpbi9pbmNsdWRlL29ubnhydW50aW1lL2NvcmUvY29tbW9uL2xvZ2dpbmcvc2V2ZXJpdHkuaFxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGxvZ1NldmVyaXR5TGV2ZWw/OiAwfDF8MnwzfDQ7XG5cbiAgICAvKipcbiAgICAgKiBMb2cgdmVyYm9zaXR5IGxldmVsLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIFdlYkFzc2VtYmx5IGJhY2tlbmQuIFdpbGwgc3VwcG9ydCBOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSBsYXRlclxuICAgICAqL1xuICAgIGxvZ1ZlcmJvc2l0eUxldmVsPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSBzdHJpbmcgYXMgYSBwcmVmZXJyZWQgZGF0YSBsb2NhdGlvbiBmb3IgYWxsIG91dHB1dHMsIG9yIGFuIG9iamVjdCB0aGF0IHVzZSBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgYVxuICAgICAqIHByZWZlcnJlZCBkYXRhIGxvY2F0aW9uIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIFdlYiBmb3IgV2ViR0wgYW5kIFdlYkdQVSBFUC5cbiAgICAgKi9cbiAgICBwcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj86IE9ubnhWYWx1ZURhdGFMb2NhdGlvbnx7cmVhZG9ubHkgW291dHB1dE5hbWU6IHN0cmluZ106IE9ubnhWYWx1ZURhdGFMb2NhdGlvbn07XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGVuYWJsZSBncmFwaCBjYXB0dXJlLlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSBXZWIgZm9yIFdlYkdQVSBFUC5cbiAgICAgKi9cbiAgICBlbmFibGVHcmFwaENhcHR1cmU/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogU3RvcmUgY29uZmlndXJhdGlvbnMgZm9yIGEgc2Vzc2lvbi4gU2VlXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS9ibG9iL21haW4vaW5jbHVkZS9vbm54cnVudGltZS9jb3JlL3Nlc3Npb24vXG4gICAgICogb25ueHJ1bnRpbWVfc2Vzc2lvbl9vcHRpb25zX2NvbmZpZ19rZXlzLmhcbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBXZWJBc3NlbWJseSBiYWNrZW5kLiBXaWxsIHN1cHBvcnQgTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUgbGF0ZXJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBleHRyYToge1xuICAgICAqICAgc2Vzc2lvbjoge1xuICAgICAqICAgICBzZXRfZGVub3JtYWxfYXNfemVybzogXCIxXCIsXG4gICAgICogICAgIGRpc2FibGVfcHJlcGFja2luZzogXCIxXCJcbiAgICAgKiAgIH0sXG4gICAgICogICBvcHRpbWl6YXRpb246IHtcbiAgICAgKiAgICAgZW5hYmxlX2dlbHVfYXBwcm94aW1hdGlvbjogXCIxXCJcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZXh0cmE/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgfVxuXG4gIC8vICNyZWdpb24gZXhlY3V0aW9uIHByb3ZpZGVyc1xuXG4gIC8vIEN1cnJlbnRseSwgd2UgaGF2ZSB0aGUgZm9sbG93aW5nIGJhY2tlbmRzIHRvIHN1cHBvcnQgZXhlY3V0aW9uIHByb3ZpZGVyczpcbiAgLy8gQmFja2VuZCBOb2RlLmpzIGJpbmRpbmc6IHN1cHBvcnRzICdjcHUnLCAnZG1sJyAod2luMzIpLCAnY29yZW1sJyAobWFjT1MpIGFuZCAnY3VkYScgKGxpbnV4KS5cbiAgLy8gQmFja2VuZCBXZWJBc3NlbWJseTogc3VwcG9ydHMgJ2NwdScsICd3YXNtJywgJ3dlYmdwdScgYW5kICd3ZWJubicuXG4gIC8vIEJhY2tlbmQgT05OWC5qczogc3VwcG9ydHMgJ3dlYmdsJy5cbiAgLy8gQmFja2VuZCBSZWFjdCBOYXRpdmU6IHN1cHBvcnRzICdjcHUnLCAneG5ucGFjaycsICdjb3JlbWwnIChpT1MpLCAnbm5hcGknIChBbmRyb2lkKS5cbiAgaW50ZXJmYWNlIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uTWFwIHtcbiAgICBjb3JlbWw6IENvcmVNTEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIGNwdTogQ3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgY3VkYTogQ3VkYUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIGRtbDogRG1sRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgbm5hcGk6IE5uYXBpRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgdGVuc29ycnQ6IFRlbnNvclJ0RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgd2FzbTogV2ViQXNzZW1ibHlFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICB3ZWJnbDogV2ViR0xFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICB3ZWJncHU6IFdlYkdwdUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHdlYm5uOiBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHFubjogUW5uRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgeG5ucGFjazogWG5ucGFja0V4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICB9XG5cbiAgdHlwZSBFeGVjdXRpb25Qcm92aWRlck5hbWUgPSBrZXlvZiBFeGVjdXRpb25Qcm92aWRlck9wdGlvbk1hcDtcbiAgdHlwZSBFeGVjdXRpb25Qcm92aWRlckNvbmZpZyA9XG4gICAgICBFeGVjdXRpb25Qcm92aWRlck9wdGlvbk1hcFtFeGVjdXRpb25Qcm92aWRlck5hbWVdfEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9ufEV4ZWN1dGlvblByb3ZpZGVyTmFtZXxzdHJpbmc7XG5cbiAgZXhwb3J0IGludGVyZmFjZSBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ2NwdSc7XG4gICAgdXNlQXJlbmE/OiBib29sZWFuO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ3VkYUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICdjdWRhJztcbiAgICBkZXZpY2VJZD86IG51bWJlcjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIERtbEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICdkbWwnO1xuICAgIGRldmljZUlkPzogbnVtYmVyO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgVGVuc29yUnRFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAndGVuc29ycnQnO1xuICAgIGRldmljZUlkPzogbnVtYmVyO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViQXNzZW1ibHlFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnd2FzbSc7XG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJHTEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICd3ZWJnbCc7XG4gICAgLy8gVE9ETzogYWRkIGZsYWdzXG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBYbm5wYWNrRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3hubnBhY2snO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3dlYmdwdSc7XG4gICAgcHJlZmVycmVkTGF5b3V0PzogJ05DSFcnfCdOSFdDJztcbiAgfVxuXG4gIC8vICNyZWdpb24gV2ViTk4gb3B0aW9uc1xuXG4gIGludGVyZmFjZSBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyTmFtZSBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnd2Vibm4nO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBzZXQgb2Ygb3B0aW9ucyBmb3IgY3JlYXRpbmcgYSBXZWJOTiBNTENvbnRleHQuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYm5uLyNkaWN0ZGVmLW1sY29udGV4dG9wdGlvbnNcbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViTk5Db250ZXh0T3B0aW9ucyB7XG4gICAgZGV2aWNlVHlwZT86ICdjcHUnfCdncHUnfCducHUnO1xuICAgIG51bVRocmVhZHM/OiBudW1iZXI7XG4gICAgcG93ZXJQcmVmZXJlbmNlPzogJ2RlZmF1bHQnfCdsb3ctcG93ZXInfCdoaWdoLXBlcmZvcm1hbmNlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgc2V0IG9mIG9wdGlvbnMgZm9yIFdlYk5OIGV4ZWN1dGlvbiBwcm92aWRlciB3aXRob3V0IE1MQ29udGV4dC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViTk5PcHRpb25zV2l0aG91dE1MQ29udGV4dCBleHRlbmRzIFdlYk5ORXhlY3V0aW9uUHJvdmlkZXJOYW1lLCBXZWJOTkNvbnRleHRPcHRpb25zIHtcbiAgICBjb250ZXh0PzogbmV2ZXI7XG4gIH1cblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHNldCBvZiBvcHRpb25zIGZvciBXZWJOTiBleGVjdXRpb24gcHJvdmlkZXIgd2l0aCBNTENvbnRleHQuXG4gICAqXG4gICAqIFdoZW4gTUxDb250ZXh0IGlzIHByb3ZpZGVkLCB0aGUgZGV2aWNlVHlwZSBpcyBhbHNvIHJlcXVpcmVkIHNvIHRoYXQgdGhlIFdlYk5OIEVQIGNhbiBkZXRlcm1pbmUgdGhlIHByZWZlcnJlZFxuICAgKiBjaGFubmVsIGxheW91dC5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvd2Vibm4vI2RvbS1tbC1jcmVhdGVjb250ZXh0XG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFdlYk5OT3B0aW9uc1dpdGhNTENvbnRleHQgZXh0ZW5kcyBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT21pdDxXZWJOTkNvbnRleHRPcHRpb25zLCAnZGV2aWNlVHlwZSc+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZXF1aXJlZDxQaWNrPFdlYk5OQ29udGV4dE9wdGlvbnMsICdkZXZpY2VUeXBlJz4+IHtcbiAgICBjb250ZXh0OiB1bmtub3duIC8qIE1MQ29udGV4dCAqLztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgc2V0IG9mIG9wdGlvbnMgZm9yIFdlYk5OIGV4ZWN1dGlvbiBwcm92aWRlciB3aXRoIE1MQ29udGV4dCB3aGljaCBpcyBjcmVhdGVkIGZyb20gR1BVRGV2aWNlLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJubi8jZG9tLW1sLWNyZWF0ZWNvbnRleHQtZ3B1ZGV2aWNlXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFdlYk5OT3B0aW9uc1dlYkdwdSBleHRlbmRzIFdlYk5ORXhlY3V0aW9uUHJvdmlkZXJOYW1lIHtcbiAgICBjb250ZXh0OiB1bmtub3duIC8qIE1MQ29udGV4dCAqLztcbiAgICBncHVEZXZpY2U6IHVua25vd24gLyogR1BVRGV2aWNlICovO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wdGlvbnMgZm9yIFdlYk5OIGV4ZWN1dGlvbiBwcm92aWRlci5cbiAgICovXG4gIGV4cG9ydCB0eXBlIFdlYk5ORXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gPSBXZWJOTk9wdGlvbnNXaXRob3V0TUxDb250ZXh0fFdlYk5OT3B0aW9uc1dpdGhNTENvbnRleHR8V2ViTk5PcHRpb25zV2ViR3B1O1xuXG4gIC8vICNlbmRyZWdpb25cblxuICBleHBvcnQgaW50ZXJmYWNlIFFubkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICdxbm4nO1xuICAgIC8vIFRPRE8gYWRkIGZsYWdzXG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBDb3JlTUxFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnY29yZW1sJztcbiAgICAvKipcbiAgICAgKiBUaGUgYml0IGZsYWdzIGZvciBDb3JlTUwgZXhlY3V0aW9uIHByb3ZpZGVyLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogQ09SRU1MX0ZMQUdfVVNFX0NQVV9PTkxZID0gMHgwMDFcbiAgICAgKiBDT1JFTUxfRkxBR19FTkFCTEVfT05fU1VCR1JBUEggPSAweDAwMlxuICAgICAqIENPUkVNTF9GTEFHX09OTFlfRU5BQkxFX0RFVklDRV9XSVRIX0FORSA9IDB4MDA0XG4gICAgICogQ09SRU1MX0ZMQUdfT05MWV9BTExPV19TVEFUSUNfSU5QVVRfU0hBUEVTID0gMHgwMDhcbiAgICAgKiBDT1JFTUxfRkxBR19DUkVBVEVfTUxQUk9HUkFNID0gMHgwMTBcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFNlZSBpbmNsdWRlL29ubnhydW50aW1lL2NvcmUvcHJvdmlkZXJzL2NvcmVtbC9jb3JlbWxfcHJvdmlkZXJfZmFjdG9yeS5oIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBUaGlzIGZsYWcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZykuXG4gICAgICovXG4gICAgY29yZU1sRmxhZ3M/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB3aGV0aGVyIHRvIHVzZSBDUFUgb25seSBpbiBDb3JlTUwgRVAuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKHJlYWN0LW5hdGl2ZSkuXG4gICAgICovXG4gICAgdXNlQ1BVT25seT86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB3aGV0aGVyIHRvIGVuYWJsZSBDb3JlTUwgRVAgb24gc3ViZ3JhcGguXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKHJlYWN0LW5hdGl2ZSkuXG4gICAgICovXG4gICAgZW5hYmxlT25TdWJncmFwaD86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB3aGV0aGVyIHRvIG9ubHkgZW5hYmxlIENvcmVNTCBFUCBmb3IgQXBwbGUgZGV2aWNlcyB3aXRoIEFORSAoQXBwbGUgTmV1cmFsIEVuZ2luZSkuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKHJlYWN0LW5hdGl2ZSkuXG4gICAgICovXG4gICAgb25seUVuYWJsZURldmljZVdpdGhBTkU/OiBib29sZWFuO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgTm5hcGlFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnbm5hcGknO1xuICAgIHVzZUZQMTY/OiBib29sZWFuO1xuICAgIHVzZU5DSFc/OiBib29sZWFuO1xuICAgIGNwdURpc2FibGVkPzogYm9vbGVhbjtcbiAgICBjcHVPbmx5PzogYm9vbGVhbjtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gcnVuIG9wdGlvbnNcblxuICAvKipcbiAgICogQSBzZXQgb2YgY29uZmlndXJhdGlvbnMgZm9yIGluZmVyZW5jZSBydW4gYmVoYXZpb3JcbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgUnVuT3B0aW9ucyB7XG4gICAgLyoqXG4gICAgICogTG9nIHNldmVyaXR5IGxldmVsLiBTZWVcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhydW50aW1lL2Jsb2IvbWFpbi9pbmNsdWRlL29ubnhydW50aW1lL2NvcmUvY29tbW9uL2xvZ2dpbmcvc2V2ZXJpdHkuaFxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGxvZ1NldmVyaXR5TGV2ZWw/OiAwfDF8MnwzfDQ7XG5cbiAgICAvKipcbiAgICAgKiBMb2cgdmVyYm9zaXR5IGxldmVsLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIFdlYkFzc2VtYmx5IGJhY2tlbmQuIFdpbGwgc3VwcG9ydCBOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSBsYXRlclxuICAgICAqL1xuICAgIGxvZ1ZlcmJvc2l0eUxldmVsPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGVybWluYXRlIGFsbCBpbmNvbXBsZXRlIE9ydFJ1biBjYWxscyBhcyBzb29uIGFzIHBvc3NpYmxlIGlmIHRydWVcbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBXZWJBc3NlbWJseSBiYWNrZW5kLiBXaWxsIHN1cHBvcnQgTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUgbGF0ZXJcbiAgICAgKi9cbiAgICB0ZXJtaW5hdGU/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQSB0YWcgZm9yIHRoZSBSdW4oKSBjYWxscyB1c2luZyB0aGlzXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgdGFnPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogU2V0IGEgc2luZ2xlIHJ1biBjb25maWd1cmF0aW9uIGVudHJ5LiBTZWVcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhydW50aW1lL2Jsb2IvbWFpbi9pbmNsdWRlL29ubnhydW50aW1lL2NvcmUvc2Vzc2lvbi9cbiAgICAgKiBvbm54cnVudGltZV9ydW5fb3B0aW9uc19jb25maWdfa2V5cy5oXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gV2ViQXNzZW1ibHkgYmFja2VuZC4gV2lsbCBzdXBwb3J0IE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlIGxhdGVyXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBleHRyYToge1xuICAgICAqICAgbWVtb3J5OiB7XG4gICAgICogICAgIGVuYWJsZV9tZW1vcnlfYXJlbmFfc2hyaW5rYWdlOiBcIjFcIixcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZXh0cmE/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgfVxuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHZhbHVlIG1ldGFkYXRhXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1pbnRlcmZhY2VcbiAgaW50ZXJmYWNlIFZhbHVlTWV0YWRhdGEge1xuICAgIC8vIFRCRFxuICB9XG5cbiAgLy8gI2VuZHJlZ2lvblxufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIHJ1bnRpbWUgaW5zdGFuY2Ugb2YgYW4gT05OWCBtb2RlbC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbmZlcmVuY2VTZXNzaW9uIHtcbiAgLy8gI3JlZ2lvbiBydW4oKVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIHRoZSBtb2RlbCBhc3luY2hyb25vdXNseSB3aXRoIHRoZSBnaXZlbiBmZWVkcyBhbmQgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIGZlZWRzIC0gUmVwcmVzZW50YXRpb24gb2YgdGhlIG1vZGVsIGlucHV0LiBTZWUgdHlwZSBkZXNjcmlwdGlvbiBvZiBgSW5mZXJlbmNlU2Vzc2lvbi5JbnB1dFR5cGVgIGZvciBkZXRhaWwuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwuIEEgc2V0IG9mIG9wdGlvbnMgdGhhdCBjb250cm9scyB0aGUgYmVoYXZpb3Igb2YgbW9kZWwgaW5mZXJlbmNlLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIG1hcCwgd2hpY2ggdXNlcyBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgKi9cbiAgcnVuKGZlZWRzOiBJbmZlcmVuY2VTZXNzaW9uLkZlZWRzVHlwZSwgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbi5SZXR1cm5UeXBlPjtcblxuICAvKipcbiAgICogRXhlY3V0ZSB0aGUgbW9kZWwgYXN5bmNocm9ub3VzbHkgd2l0aCB0aGUgZ2l2ZW4gZmVlZHMsIGZldGNoZXMgYW5kIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBmZWVkcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBpbnB1dC4gU2VlIHR5cGUgZGVzY3JpcHRpb24gb2YgYEluZmVyZW5jZVNlc3Npb24uSW5wdXRUeXBlYCBmb3IgZGV0YWlsLlxuICAgKiBAcGFyYW0gZmV0Y2hlcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBvdXRwdXQuIFNlZSB0eXBlIGRlc2NyaXB0aW9uIG9mIGBJbmZlcmVuY2VTZXNzaW9uLk91dHB1dFR5cGVgIGZvclxuICAgKiBkZXRhaWwuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwuIEEgc2V0IG9mIG9wdGlvbnMgdGhhdCBjb250cm9scyB0aGUgYmVoYXZpb3Igb2YgbW9kZWwgaW5mZXJlbmNlLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIG1hcCwgd2hpY2ggdXNlcyBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgKi9cbiAgcnVuKGZlZWRzOiBJbmZlcmVuY2VTZXNzaW9uLkZlZWRzVHlwZSwgZmV0Y2hlczogSW5mZXJlbmNlU2Vzc2lvbi5GZXRjaGVzVHlwZSxcbiAgICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24uUmV0dXJuVHlwZT47XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gcmVsZWFzZSgpXG5cbiAgLyoqXG4gICAqIFJlbGVhc2UgdGhlIGluZmVyZW5jZSBzZXNzaW9uIGFuZCB0aGUgdW5kZXJseWluZyByZXNvdXJjZXMuXG4gICAqL1xuICByZWxlYXNlKCk6IFByb21pc2U8dm9pZD47XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gcHJvZmlsaW5nXG5cbiAgLyoqXG4gICAqIFN0YXJ0IHByb2ZpbGluZy5cbiAgICovXG4gIHN0YXJ0UHJvZmlsaW5nKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEVuZCBwcm9maWxpbmcuXG4gICAqL1xuICBlbmRQcm9maWxpbmcoKTogdm9pZDtcblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBtZXRhZGF0YVxuXG4gIC8qKlxuICAgKiBHZXQgaW5wdXQgbmFtZXMgb2YgdGhlIGxvYWRlZCBtb2RlbC5cbiAgICovXG4gIHJlYWRvbmx5IGlucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBHZXQgb3V0cHV0IG5hbWVzIG9mIHRoZSBsb2FkZWQgbW9kZWwuXG4gICAqL1xuICByZWFkb25seSBvdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG5cbiAgLy8gLyoqXG4gIC8vICAqIEdldCBpbnB1dCBtZXRhZGF0YSBvZiB0aGUgbG9hZGVkIG1vZGVsLlxuICAvLyAgKi9cbiAgLy8gcmVhZG9ubHkgaW5wdXRNZXRhZGF0YTogUmVhZG9ubHlBcnJheTxSZWFkb25seTxJbmZlcmVuY2VTZXNzaW9uLlZhbHVlTWV0YWRhdGE+PjtcblxuICAvLyAvKipcbiAgLy8gICogR2V0IG91dHB1dCBtZXRhZGF0YSBvZiB0aGUgbG9hZGVkIG1vZGVsLlxuICAvLyAgKi9cbiAgLy8gcmVhZG9ubHkgb3V0cHV0TWV0YWRhdGE6IFJlYWRvbmx5QXJyYXk8UmVhZG9ubHk8SW5mZXJlbmNlU2Vzc2lvbi5WYWx1ZU1ldGFkYXRhPj47XG5cbiAgLy8gI2VuZHJlZ2lvblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluZmVyZW5jZVNlc3Npb25GYWN0b3J5IHtcbiAgLy8gI3JlZ2lvbiBjcmVhdGUoKVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24gYW5kIGxvYWQgbW9kZWwgYXN5bmNocm9ub3VzbHkgZnJvbSBhbiBPTk5YIG1vZGVsIGZpbGUuXG4gICAqXG4gICAqIEBwYXJhbSB1cmkgLSBUaGUgVVJJIG9yIGZpbGUgcGF0aCBvZiB0aGUgbW9kZWwgdG8gbG9hZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBzcGVjaWZ5IGNvbmZpZ3VyYXRpb24gZm9yIGNyZWF0aW5nIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBJbmZlcmVuY2VTZXNzaW9uIG9iamVjdC5cbiAgICovXG4gIGNyZWF0ZSh1cmk6IHN0cmluZywgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24+O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24gYW5kIGxvYWQgbW9kZWwgYXN5bmNocm9ub3VzbHkgZnJvbSBhbiBhcnJheSBidWZlci5cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciAtIEFuIEFycmF5QnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIGFuIE9OTlggbW9kZWwuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gc3BlY2lmeSBjb25maWd1cmF0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbi5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gSW5mZXJlbmNlU2Vzc2lvbiBvYmplY3QuXG4gICAqL1xuICBjcmVhdGUoYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2UsIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uPjtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uIGFuZCBsb2FkIG1vZGVsIGFzeW5jaHJvbm91c2x5IGZyb20gc2VnbWVudCBvZiBhbiBhcnJheSBidWZlci5cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciAtIEFuIEFycmF5QnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIGFuIE9OTlggbW9kZWwuXG4gICAqIEBwYXJhbSBieXRlT2Zmc2V0IC0gVGhlIGJlZ2lubmluZyBvZiB0aGUgc3BlY2lmaWVkIHBvcnRpb24gb2YgdGhlIGFycmF5IGJ1ZmZlci5cbiAgICogQHBhcmFtIGJ5dGVMZW5ndGggLSBUaGUgbGVuZ3RoIGluIGJ5dGVzIG9mIHRoZSBhcnJheSBidWZmZXIuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gc3BlY2lmeSBjb25maWd1cmF0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbi5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gSW5mZXJlbmNlU2Vzc2lvbiBvYmplY3QuXG4gICAqL1xuICBjcmVhdGUoYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2UsIGJ5dGVPZmZzZXQ6IG51bWJlciwgYnl0ZUxlbmd0aD86IG51bWJlciwgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOlxuICAgICAgUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uPjtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uIGFuZCBsb2FkIG1vZGVsIGFzeW5jaHJvbm91c2x5IGZyb20gYSBVaW50OEFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIC0gQSBVaW50OEFycmF5IHJlcHJlc2VudGF0aW9uIG9mIGFuIE9OTlggbW9kZWwuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gc3BlY2lmeSBjb25maWd1cmF0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbi5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gSW5mZXJlbmNlU2Vzc2lvbiBvYmplY3QuXG4gICAqL1xuICBjcmVhdGUoYnVmZmVyOiBVaW50OEFycmF5LCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbj47XG5cbiAgLy8gI2VuZHJlZ2lvblxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY29uc3QgSW5mZXJlbmNlU2Vzc2lvbjogSW5mZXJlbmNlU2Vzc2lvbkZhY3RvcnkgPSBJbmZlcmVuY2VTZXNzaW9uSW1wbDtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtPcHRpb25zRm9ybWF0LCBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMsIE9wdGlvbnNUZW5zb3JMYXlvdXR9IGZyb20gJy4vdGVuc29yLWZhY3RvcnkuanMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvclRvRGF0YVVybE9wdGlvbnMgZXh0ZW5kcyBPcHRpb25zVGVuc29yTGF5b3V0LCBPcHRpb25zRm9ybWF0LCBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge31cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnMgZXh0ZW5kcyBPcHRpb25zVGVuc29yTGF5b3V0LCBPcHRpb25zRm9ybWF0LCBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge31cblxuZXhwb3J0IGludGVyZmFjZSBDb252ZXJzaW9uVXRpbHMge1xuICAvKipcbiAgICogY3JlYXRlcyBhIERhdGFVUkwgaW5zdGFuY2UgZnJvbSB0ZW5zb3JcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIGEgRGF0YVVSTCBpbnN0YW5jZSBmcm9tIHRoZSB0ZW5zb3IuXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XG4gICAqIC0gYGZvcm1hdGA6IGAnUkdCJ2BcbiAgICogLSBgdGVuc29yTGF5b3V0YDogYCdOQ0hXJ2BcbiAgICogQHJldHVybnMgYSBEYXRhVVJMIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGltYWdlIGNvbnZlcnRlZCBmcm9tIHRlbnNvciBkYXRhXG4gICAqL1xuICB0b0RhdGFVUkwob3B0aW9ucz86IFRlbnNvclRvRGF0YVVybE9wdGlvbnMpOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGNyZWF0ZXMgYW4gSW1hZ2VEYXRhIGluc3RhbmNlIGZyb20gdGVuc29yXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyBhbiBJbWFnZURhdGEgaW5zdGFuY2UgZnJvbSB0aGUgdGVuc29yLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGRlZmF1bHQgc2V0dGluZ3Mgd2lsbCBiZSBhcHBsaWVkOlxuICAgKiAtIGBmb3JtYXRgOiBgJ1JHQidgXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXG4gICAqIEByZXR1cm5zIGFuIEltYWdlRGF0YSBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhlIGltYWdlIGNvbnZlcnRlZCBmcm9tIHRlbnNvciBkYXRhXG4gICAqL1xuICB0b0ltYWdlRGF0YShvcHRpb25zPzogVGVuc29yVG9JbWFnZURhdGFPcHRpb25zKTogSW1hZ2VEYXRhO1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RlbnNvciwgVHlwZWRUZW5zb3J9IGZyb20gJy4vdGVuc29yLmpzJztcblxuZXhwb3J0IHR5cGUgSW1hZ2VGb3JtYXQgPSAnUkdCJ3wnUkdCQSd8J0JHUid8J1JCRyc7XG5leHBvcnQgdHlwZSBJbWFnZVRlbnNvckxheW91dCA9ICdOSFdDJ3wnTkNIVyc7XG5cbi8vIHRoZSBmb2xsb3dpbmcgcmVnaW9uIGNvbnRhaW5zIHR5cGUgZGVmaW5pdGlvbnMgZm9yIGNvbnN0cnVjdGluZyB0ZW5zb3IgZnJvbSBhIHNwZWNpZmljIGxvY2F0aW9uLlxuXG4vLyAjcmVnaW9uIHR5cGVzIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIHNwZWNpZmljIGxvY2F0aW9uXG5cbi8qKlxuICogcmVwcmVzZW50IGNvbW1vbiBwcm9wZXJ0aWVzIG9mIHRoZSBwYXJhbWV0ZXIgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgc3BlY2lmaWMgbG9jYXRpb24uXG4gKi9cbmludGVyZmFjZSBDb21tb25Db25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4gZXh0ZW5kcyBQaWNrPFRlbnNvciwgJ2RpbXMnPiB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBkYXRhIHR5cGUgb2YgdGhlIHRlbnNvci5cbiAgICovXG4gIHJlYWRvbmx5IHR5cGU6IFQ7XG59XG5cbi8qKlxuICogcmVwcmVzZW50IHRoZSBwYXJhbWV0ZXIgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgR1BVIHJlc291cmNlLlxuICovXG5pbnRlcmZhY2UgR3B1UmVzb3VyY2VDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VCBleHRlbmRzIFRlbnNvci5UeXBlPiB7XG4gIC8qKlxuICAgKiBhbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBkb3dubG9hZCBkYXRhIGZyb20gR1BVIHRvIENQVS5cbiAgICpcbiAgICogSWYgbm90IHByb3ZpZGVkLCB0aGUgdGVuc29yIHRyZWF0IHRoZSBHUFUgZGF0YSBhcyBleHRlcm5hbCByZXNvdXJjZS5cbiAgICovXG4gIGRvd25sb2FkPygpOiBQcm9taXNlPFRlbnNvci5EYXRhVHlwZU1hcFtUXT47XG5cbiAgLyoqXG4gICAqIGFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgdGVuc29yIGlzIGRpc3Bvc2VkLlxuICAgKlxuICAgKiBJZiBub3QgcHJvdmlkZWQsIHRoZSB0ZW5zb3IgdHJlYXQgdGhlIEdQVSBkYXRhIGFzIGV4dGVybmFsIHJlc291cmNlLlxuICAgKi9cbiAgZGlzcG9zZT8oKTogdm9pZDtcbn1cblxuLyoqXG4gKiByZXByZXNlbnQgdGhlIHBhcmFtZXRlciBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBwaW5uZWQgQ1BVIGJ1ZmZlclxuICovXG5leHBvcnQgaW50ZXJmYWNlIENwdVBpbm5lZENvbnN0cnVjdG9yUGFyYW1ldGVyczxUIGV4dGVuZHMgVGVuc29yLkNwdVBpbm5lZERhdGFUeXBlcyA9IFRlbnNvci5DcHVQaW5uZWREYXRhVHlwZXM+IGV4dGVuZHNcbiAgICBDb21tb25Db25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4ge1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEgdG8gYmUgJ2NwdS1waW5uZWQnLlxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYXRpb246ICdjcHUtcGlubmVkJztcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIENQVSBwaW5uZWQgYnVmZmVyIHRoYXQgaG9sZHMgdGhlIHRlbnNvciBkYXRhLlxuICAgKi9cbiAgcmVhZG9ubHkgZGF0YTogVGVuc29yLkRhdGFUeXBlTWFwW1RdO1xufVxuXG4vKipcbiAqIHJlcHJlc2VudCB0aGUgcGFyYW1ldGVyIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIFdlYkdMIHRleHR1cmVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZXh0dXJlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBUZW5zb3IuVGV4dHVyZURhdGFUeXBlcyA9IFRlbnNvci5UZXh0dXJlRGF0YVR5cGVzPiBleHRlbmRzXG4gICAgQ29tbW9uQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+LCBHcHVSZXNvdXJjZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBsb2NhdGlvbiBvZiB0aGUgZGF0YSB0byBiZSAndGV4dHVyZScuXG4gICAqL1xuICByZWFkb25seSBsb2NhdGlvbjogJ3RleHR1cmUnO1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgV2ViR0wgdGV4dHVyZSB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICovXG4gIHJlYWRvbmx5IHRleHR1cmU6IFRlbnNvci5UZXh0dXJlVHlwZTtcbn1cblxuLyoqXG4gKiByZXByZXNlbnQgdGhlIHBhcmFtZXRlciBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBXZWJHUFUgYnVmZmVyXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBUZW5zb3IuR3B1QnVmZmVyRGF0YVR5cGVzID0gVGVuc29yLkdwdUJ1ZmZlckRhdGFUeXBlcz4gZXh0ZW5kc1xuICAgIENvbW1vbkNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiwgR3B1UmVzb3VyY2VDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4ge1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEgdG8gYmUgJ2dwdS1idWZmZXInLlxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYXRpb246ICdncHUtYnVmZmVyJztcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIFdlYkdQVSBidWZmZXIgdGhhdCBob2xkcyB0aGUgdGVuc29yIGRhdGEuXG4gICAqL1xuICByZWFkb25seSBncHVCdWZmZXI6IFRlbnNvci5HcHVCdWZmZXJUeXBlO1xufVxuXG4vLyAjZW5kcmVnaW9uXG5cbi8vIHRoZSBmb2xsb3dpbmcgcmVnaW9uIGNvbnRhaW5zIHR5cGUgZGVmaW5pdGlvbnMgb2YgZWFjaCBpbmRpdmlkdWFsIG9wdGlvbnMuXG4vLyB0aGUgdGVuc29yIGZhY3RvcnkgZnVuY3Rpb25zIHVzZSBhIGNvbXBvc2l0aW9uIG9mIHRob3NlIG9wdGlvbnMgYXMgdGhlIHBhcmFtZXRlciB0eXBlLlxuXG4vLyAjcmVnaW9uIE9wdGlvbnMgZmllbGRzXG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uc0Zvcm1hdCB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGltYWdlIGZvcm1hdCByZXByZXNlbnRlZCBpbiBSR0JBIGNvbG9yIHNwYWNlLlxuICAgKi9cbiAgZm9ybWF0PzogSW1hZ2VGb3JtYXQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uc1RlbnNvckZvcm1hdCB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGltYWdlIGZvcm1hdCBvZiB0aGUgdGVuc29yLlxuICAgKlxuICAgKiBOT1RFOiB0aGlzIGlzIGRpZmZlcmVudCBmcm9tIG9wdGlvbiAnZm9ybWF0Jy4gV2hpbGUgb3B0aW9uICdmb3JtYXQnIHJlcHJlc2VudHMgdGhlIG9yaWdpbmFsIGltYWdlLCAndGVuc29yRm9ybWF0J1xuICAgKiByZXByZXNlbnRzIHRoZSB0YXJnZXQgZm9ybWF0IG9mIHRoZSB0ZW5zb3IuIEEgdHJhbnNwb3NlIHdpbGwgYmUgcGVyZm9ybWVkIGlmIHRoZXkgYXJlIGRpZmZlcmVudC5cbiAgICovXG4gIHRlbnNvckZvcm1hdD86IEltYWdlRm9ybWF0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNUZW5zb3JEYXRhVHlwZSB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yLlxuICAgKi9cbiAgZGF0YVR5cGU/OiAnZmxvYXQzMid8J3VpbnQ4Jztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zVGVuc29yTGF5b3V0IHtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyB0aGUgdGVuc29yIGxheW91dCB3aGVuIHJlcHJlc2VudGluZyBkYXRhIG9mIG9uZSBvciBtb3JlIGltYWdlKHMpLlxuICAgKi9cbiAgdGVuc29yTGF5b3V0PzogSW1hZ2VUZW5zb3JMYXlvdXQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uc0RpbWVuc2lvbnMge1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSBpbWFnZSBoZWlnaHQgaW4gcGl4ZWxcbiAgICovXG4gIGhlaWdodD86IG51bWJlcjtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyB0aGUgaW1hZ2Ugd2lkdGggaW4gcGl4ZWxcbiAgICovXG4gIHdpZHRoPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvblJlc2l6ZWREaW1lbnNpb25zIHtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyB0aGUgcmVzaXplZCBoZWlnaHQuIElmIG9taXR0ZWQsIG9yaWdpbmFsIGhlaWdodCB3aWxsIGJlIHVzZWQuXG4gICAqL1xuICByZXNpemVkSGVpZ2h0PzogbnVtYmVyO1xuICAvKipcbiAgICogRGVzY3JpYmVzIHJlc2l6ZWQgd2lkdGggLSBjYW4gYmUgYWNjZXNzZWQgdmlhIHRlbnNvciBkaW1lbnNpb25zIGFzIHdlbGxcbiAgICovXG4gIHJlc2l6ZWRXaWR0aD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge1xuICAvKipcbiAgICogRGVzY3JpYmVzIG5vcm1hbGl6YXRpb24gcGFyYW1ldGVycyB3aGVuIHByZXByb2Nlc3NpbmcgdGhlIGltYWdlIGFzIG1vZGVsIGlucHV0LlxuICAgKlxuICAgKiBEYXRhIGVsZW1lbnQgYXJlIHJhbmdlZCBmcm9tIDAgdG8gMjU1LlxuICAgKi9cbiAgbm9ybT86IHtcbiAgICAvKipcbiAgICAgKiBUaGUgJ2JpYXMnIHZhbHVlIGZvciBpbWFnZSBub3JtYWxpemF0aW9uLlxuICAgICAqIC0gSWYgb21pdHRlZCwgdXNlIGRlZmF1bHQgdmFsdWUgMC5cbiAgICAgKiAtIElmIGl0J3MgYSBzaW5nbGUgbnVtYmVyLCBhcHBseSB0byBlYWNoIGNoYW5uZWxcbiAgICAgKiAtIElmIGl0J3MgYW4gYXJyYXkgb2YgMyBvciA0IG51bWJlcnMsIGFwcGx5IGVsZW1lbnQtd2lzZS4gTnVtYmVyIG9mIGVsZW1lbnRzIG5lZWQgdG8gbWF0Y2ggdGhlIG51bWJlciBvZiBjaGFubmVsc1xuICAgICAqIGZvciB0aGUgY29ycmVzcG9uZGluZyBpbWFnZSBmb3JtYXRcbiAgICAgKi9cbiAgICBiaWFzPzogbnVtYmVyfFtudW1iZXIsIG51bWJlciwgbnVtYmVyXXxbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgICAvKipcbiAgICAgKiBUaGUgJ21lYW4nIHZhbHVlIGZvciBpbWFnZSBub3JtYWxpemF0aW9uLlxuICAgICAqIC0gSWYgb21pdHRlZCwgdXNlIGRlZmF1bHQgdmFsdWUgMjU1LlxuICAgICAqIC0gSWYgaXQncyBhIHNpbmdsZSBudW1iZXIsIGFwcGx5IHRvIGVhY2ggY2hhbm5lbFxuICAgICAqIC0gSWYgaXQncyBhbiBhcnJheSBvZiAzIG9yIDQgbnVtYmVycywgYXBwbHkgZWxlbWVudC13aXNlLiBOdW1iZXIgb2YgZWxlbWVudHMgbmVlZCB0byBtYXRjaCB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzXG4gICAgICogZm9yIHRoZSBjb3JyZXNwb25kaW5nIGltYWdlIGZvcm1hdFxuICAgICAqL1xuICAgIG1lYW4/OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgfTtcbn1cblxuLy8gI2VuZHJlZ2lvblxuXG4vLyAjcmVnaW9uIE9wdGlvbnMgY29tcG9zaXRpb25cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tSW1hZ2VEYXRhT3B0aW9ucyBleHRlbmRzIE9wdGlvblJlc2l6ZWREaW1lbnNpb25zLCBPcHRpb25zVGVuc29yRm9ybWF0LCBPcHRpb25zVGVuc29yTGF5b3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnNUZW5zb3JEYXRhVHlwZSwgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbUltYWdlRWxlbWVudE9wdGlvbnMgZXh0ZW5kcyBPcHRpb25SZXNpemVkRGltZW5zaW9ucywgT3B0aW9uc1RlbnNvckZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcHRpb25zVGVuc29yTGF5b3V0LCBPcHRpb25zVGVuc29yRGF0YVR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbVVybE9wdGlvbnMgZXh0ZW5kcyBPcHRpb25zRGltZW5zaW9ucywgT3B0aW9uUmVzaXplZERpbWVuc2lvbnMsIE9wdGlvbnNUZW5zb3JGb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3B0aW9uc1RlbnNvckxheW91dCwgT3B0aW9uc1RlbnNvckRhdGFUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZyb21JbWFnZUJpdG1hcE9wdGlvbnMgZXh0ZW5kcyBPcHRpb25SZXNpemVkRGltZW5zaW9ucywgT3B0aW9uc1RlbnNvckZvcm1hdCwgT3B0aW9uc1RlbnNvckxheW91dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnNUZW5zb3JEYXRhVHlwZSwgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbVRleHR1cmVPcHRpb25zPFQgZXh0ZW5kcyBUZW5zb3IuVGV4dHVyZURhdGFUeXBlcz4gZXh0ZW5kc1xuICAgIFJlcXVpcmVkPE9wdGlvbnNEaW1lbnNpb25zPiwgT3B0aW9uc0Zvcm1hdCwgR3B1UmVzb3VyY2VDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4vKiBUT0RPOiBhZGQgbW9yZSAqLyB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZyb21HcHVCdWZmZXJPcHRpb25zPFQgZXh0ZW5kcyBUZW5zb3IuR3B1QnVmZmVyRGF0YVR5cGVzPiBleHRlbmRzXG4gICAgUGljazxUZW5zb3IsICdkaW1zJz4sIEdwdVJlc291cmNlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IHtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuXG4gICAqL1xuICBkYXRhVHlwZT86IFQ7XG59XG5cbi8vICNlbmRyZWdpb25cblxuLyoqXG4gKiB0eXBlIFRlbnNvckZhY3RvcnkgZGVmaW5lcyB0aGUgZmFjdG9yeSBmdW5jdGlvbnMgb2YgJ1RlbnNvcicgdG8gY3JlYXRlIHRlbnNvciBpbnN0YW5jZXMgZnJvbSBleGlzdGluZyBkYXRhIG9yXG4gKiByZXNvdXJjZXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRmFjdG9yeSB7XG4gIC8qKlxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhbiBJbWFnZURhdGEgb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSBpbWFnZURhdGEgLSB0aGUgSW1hZ2VEYXRhIG9iamVjdCB0byBjcmVhdGUgdGVuc29yIGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIEltYWdlRGF0YS5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBkZWZhdWx0IHNldHRpbmdzIHdpbGwgYmUgYXBwbGllZDpcbiAgICogLSBgdGVuc29yRm9ybWF0YDogYCdSR0InYFxuICAgKiAtIGB0ZW5zb3JMYXlvdXRgOiBgJ05DSFcnYFxuICAgKiAtIGBkYXRhVHlwZWA6IGAnZmxvYXQzMidgXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdGVuc29yIG9iamVjdFxuICAgKi9cbiAgZnJvbUltYWdlKGltYWdlRGF0YTogSW1hZ2VEYXRhLCBvcHRpb25zPzogVGVuc29yRnJvbUltYWdlRGF0YU9wdGlvbnMpOlxuICAgICAgUHJvbWlzZTxUeXBlZFRlbnNvcjwnZmxvYXQzMic+fFR5cGVkVGVuc29yPCd1aW50OCc+PjtcblxuICAvKipcbiAgICogY3JlYXRlIGEgdGVuc29yIGZyb20gYSBIVE1MSW1hZ2VFbGVtZW50IG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0gaW1hZ2VFbGVtZW50IC0gdGhlIEhUTUxJbWFnZUVsZW1lbnQgb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gSFRNTEltYWdlRWxlbWVudC5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBkZWZhdWx0IHNldHRpbmdzIHdpbGwgYmUgYXBwbGllZDpcbiAgICogLSBgdGVuc29yRm9ybWF0YDogYCdSR0InYFxuICAgKiAtIGB0ZW5zb3JMYXlvdXRgOiBgJ05DSFcnYFxuICAgKiAtIGBkYXRhVHlwZWA6IGAnZmxvYXQzMidgXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdGVuc29yIG9iamVjdFxuICAgKi9cbiAgZnJvbUltYWdlKGltYWdlRWxlbWVudDogSFRNTEltYWdlRWxlbWVudCwgb3B0aW9ucz86IFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zKTpcbiAgICAgIFByb21pc2U8VHlwZWRUZW5zb3I8J2Zsb2F0MzInPnxUeXBlZFRlbnNvcjwndWludDgnPj47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIFVSTFxuICAgKlxuICAgKiBAcGFyYW0gdXJsU291cmNlIC0gYSBzdHJpbmcgYXMgYSBVUkwgdG8gdGhlIGltYWdlIG9yIGEgZGF0YSBVUkwgY29udGFpbmluZyB0aGUgaW1hZ2UgZGF0YS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIFVSTC5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBkZWZhdWx0IHNldHRpbmdzIHdpbGwgYmUgYXBwbGllZDpcbiAgICogLSBgdGVuc29yRm9ybWF0YDogYCdSR0InYFxuICAgKiAtIGB0ZW5zb3JMYXlvdXRgOiBgJ05DSFcnYFxuICAgKiAtIGBkYXRhVHlwZWA6IGAnZmxvYXQzMidgXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdGVuc29yIG9iamVjdFxuICAgKi9cbiAgZnJvbUltYWdlKHVybFNvdXJjZTogc3RyaW5nLCBvcHRpb25zPzogVGVuc29yRnJvbVVybE9wdGlvbnMpOiBQcm9taXNlPFR5cGVkVGVuc29yPCdmbG9hdDMyJz58VHlwZWRUZW5zb3I8J3VpbnQ4Jz4+O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhbiBJbWFnZUJpdG1hcCBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIGJpdG1hcCAtIHRoZSBJbWFnZUJpdG1hcCBvYmplY3QgdG8gY3JlYXRlIHRlbnNvciBmcm9tXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyB0ZW5zb3IgZnJvbSBVUkwuXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XG4gICAqIC0gYHRlbnNvckZvcm1hdGA6IGAnUkdCJ2BcbiAgICogLSBgdGVuc29yTGF5b3V0YDogYCdOQ0hXJ2BcbiAgICogLSBgZGF0YVR5cGVgOiBgJ2Zsb2F0MzInYFxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHRlbnNvciBvYmplY3RcbiAgICovXG4gIGZyb21JbWFnZShiaXRtYXA6IEltYWdlQml0bWFwLCBvcHRpb25zOiBUZW5zb3JGcm9tSW1hZ2VCaXRtYXBPcHRpb25zKTpcbiAgICAgIFByb21pc2U8VHlwZWRUZW5zb3I8J2Zsb2F0MzInPnxUeXBlZFRlbnNvcjwndWludDgnPj47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIGEgV2ViR0wgdGV4dHVyZVxuICAgKlxuICAgKiBAcGFyYW0gdGV4dHVyZSAtIHRoZSBXZWJHTFRleHR1cmUgb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gV2ViR0wgdGV4dHVyZS5cbiAgICpcbiAgICogVGhlIG9wdGlvbnMgaW5jbHVkZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogLSBgd2lkdGhgOiB0aGUgd2lkdGggb2YgdGhlIHRleHR1cmUuIFJlcXVpcmVkLlxuICAgKiAtIGBoZWlnaHRgOiB0aGUgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlLiBSZXF1aXJlZC5cbiAgICogLSBgZm9ybWF0YDogdGhlIGZvcm1hdCBvZiB0aGUgdGV4dHVyZS4gSWYgb21pdHRlZCwgYXNzdW1lICdSR0JBJy5cbiAgICogLSBgZG93bmxvYWRgOiBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBkb3dubG9hZCB0aGUgdGVuc29yIGRhdGEgZnJvbSBHUFUgdG8gQ1BVLiBJZiBvbWl0dGVkLCB0aGUgR1BVIGRhdGFcbiAgICogd2lsbCBub3QgYmUgYWJsZSB0byBkb3dubG9hZC4gVXN1YWxseSwgdGhpcyBpcyBwcm92aWRlZCBieSBhIEdQVSBiYWNrZW5kIGZvciB0aGUgaW5mZXJlbmNlIG91dHB1dHMuIFVzZXJzIGRvbid0XG4gICAqIG5lZWQgdG8gcHJvdmlkZSB0aGlzIGZ1bmN0aW9uLlxuICAgKiAtIGBkaXNwb3NlYDogYW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZGlzcG9zZSB0aGUgdGVuc29yIGRhdGEgb24gR1BVLiBJZiBvbWl0dGVkLCB0aGUgR1BVIGRhdGEgd2lsbCBub3QgYmUgZGlzcG9zZWQuXG4gICAqIFVzdWFsbHksIHRoaXMgaXMgcHJvdmlkZWQgYnkgYSBHUFUgYmFja2VuZCBmb3IgdGhlIGluZmVyZW5jZSBvdXRwdXRzLiBVc2VycyBkb24ndCBuZWVkIHRvIHByb3ZpZGUgdGhpcyBmdW5jdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMgYSB0ZW5zb3Igb2JqZWN0XG4gICAqL1xuICBmcm9tVGV4dHVyZTxUIGV4dGVuZHMgVGVuc29yLlRleHR1cmVEYXRhVHlwZXMgPSAnZmxvYXQzMic+KFxuICAgICAgdGV4dHVyZTogVGVuc29yLlRleHR1cmVUeXBlLCBvcHRpb25zOiBUZW5zb3JGcm9tVGV4dHVyZU9wdGlvbnM8VD4pOiBUeXBlZFRlbnNvcjwnZmxvYXQzMic+O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhIFdlYkdQVSBidWZmZXJcbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciAtIHRoZSBHUFVCdWZmZXIgb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gV2ViR1BVIGJ1ZmZlci5cbiAgICpcbiAgICogVGhlIG9wdGlvbnMgaW5jbHVkZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogLSBgZGF0YVR5cGVgOiB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGFzc3VtZSAnZmxvYXQzMicuXG4gICAqIC0gYGRpbXNgOiB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIFJlcXVpcmVkLlxuICAgKiAtIGBkb3dubG9hZGA6IGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGRvd25sb2FkIHRoZSB0ZW5zb3IgZGF0YSBmcm9tIEdQVSB0byBDUFUuIElmIG9taXR0ZWQsIHRoZSBHUFUgZGF0YVxuICAgKiB3aWxsIG5vdCBiZSBhYmxlIHRvIGRvd25sb2FkLiBVc3VhbGx5LCB0aGlzIGlzIHByb3ZpZGVkIGJ5IGEgR1BVIGJhY2tlbmQgZm9yIHRoZSBpbmZlcmVuY2Ugb3V0cHV0cy4gVXNlcnMgZG9uJ3RcbiAgICogbmVlZCB0byBwcm92aWRlIHRoaXMgZnVuY3Rpb24uXG4gICAqIC0gYGRpc3Bvc2VgOiBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBkaXNwb3NlIHRoZSB0ZW5zb3IgZGF0YSBvbiBHUFUuIElmIG9taXR0ZWQsIHRoZSBHUFUgZGF0YSB3aWxsIG5vdCBiZSBkaXNwb3NlZC5cbiAgICogVXN1YWxseSwgdGhpcyBpcyBwcm92aWRlZCBieSBhIEdQVSBiYWNrZW5kIGZvciB0aGUgaW5mZXJlbmNlIG91dHB1dHMuIFVzZXJzIGRvbid0IG5lZWQgdG8gcHJvdmlkZSB0aGlzIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHRlbnNvciBvYmplY3RcbiAgICovXG4gIGZyb21HcHVCdWZmZXI8VCBleHRlbmRzIFRlbnNvci5HcHVCdWZmZXJEYXRhVHlwZXM+KFxuICAgICAgYnVmZmVyOiBUZW5zb3IuR3B1QnVmZmVyVHlwZSwgb3B0aW9uczogVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnM8VD4pOiBUeXBlZFRlbnNvcjxUPjtcblxuICAvKipcbiAgICogY3JlYXRlIGEgdGVuc29yIGZyb20gYSBwcmUtYWxsb2NhdGVkIGJ1ZmZlci4gVGhlIGJ1ZmZlciB3aWxsIGJlIHVzZWQgYXMgYSBwaW5uZWQgYnVmZmVyLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIHRoZSB0ZW5zb3IgZWxlbWVudCB0eXBlLlxuICAgKiBAcGFyYW0gYnVmZmVyIC0gYSBUeXBlZEFycmF5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHR5cGUuXG4gICAqIEBwYXJhbSBkaW1zIC0gc3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHRlbnNvciBvYmplY3RcbiAgICovXG4gIGZyb21QaW5uZWRCdWZmZXI8VCBleHRlbmRzIEV4Y2x1ZGU8VGVuc29yLlR5cGUsICdzdHJpbmcnPj4oXG4gICAgICB0eXBlOiBULCBidWZmZXI6IFRlbnNvci5EYXRhVHlwZU1hcFtUXSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8VD47XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8qKlxuICogQSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgZmlsZSdzIFVSTCBvciBwYXRoLlxuICpcbiAqIFBhdGggaXMgdmFpbGFibGUgb25seSBpbiBvbm54cnVudGltZS1ub2RlIG9yIG9ubnhydW50aW1lLXdlYiBydW5uaW5nIGluIE5vZGUuanMuXG4gKi9cbmV4cG9ydCB0eXBlIEZpbGVVcmxPclBhdGggPSBzdHJpbmc7XG5cbi8qKlxuICogQSBCbG9iIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYSBmaWxlLlxuICovXG5leHBvcnQgdHlwZSBGaWxlQmxvYiA9IEJsb2I7XG5cbi8qKlxuICogQSBVaW50OEFycmF5LCBBcnJheUJ1ZmZlciBvciBTaGFyZWRBcnJheUJ1ZmZlciBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgZmlsZSBjb250ZW50LlxuICpcbiAqIFdoZW4gaXQgaXMgYW4gQXJyYXlCdWZmZXIgb3IgU2hhcmVkQXJyYXlCdWZmZXIsIHRoZSB3aG9sZSBidWZmZXIgaXMgYXNzdW1lZCB0byBiZSB0aGUgZmlsZSBjb250ZW50LlxuICovXG5leHBvcnQgdHlwZSBGaWxlRGF0YSA9IFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJMaWtlO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBmaWxlIHRoYXQgY2FuIGJlIGxvYWRlZCBieSB0aGUgT05OWCBSdW50aW1lIEphdmFTY3JpcHQgQVBJLlxuICovXG5leHBvcnQgdHlwZSBGaWxlVHlwZSA9IEZpbGVVcmxPclBhdGh8RmlsZUJsb2J8RmlsZURhdGE7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBleHRlcm5hbCBkYXRhIGZpbGUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXh0ZXJuYWxEYXRhRmlsZURlc2NyaXB0aW9uIHtcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGV4dGVybmFsIGRhdGEgZmlsZS5cbiAgICovXG4gIGRhdGE6IEZpbGVUeXBlO1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgZmlsZSBwYXRoLlxuICAgKi9cbiAgcGF0aDogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZXh0ZXJuYWwgZGF0YSBmaWxlLlxuICpcbiAqIFdoZW4gdXNpbmcgYSBzdHJpbmcsIGl0IHNob3VsZCBiZSBhIGZpbGUgVVJMIG9yIHBhdGggdGhhdCBpbiB0aGUgc2FtZSBkaXJlY3RvcnkgYXMgdGhlIG1vZGVsIGZpbGUuXG4gKi9cbmV4cG9ydCB0eXBlIEV4dGVybmFsRGF0YUZpbGVUeXBlID0gRXh0ZXJuYWxEYXRhRmlsZURlc2NyaXB0aW9ufEZpbGVVcmxPclBhdGg7XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgbW9kZWwgbG9hZGluZy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBPbm54TW9kZWxPcHRpb25zIHtcbiAgLyoqXG4gICAqIFNwZWNpZnlpbmcgYSBsaXN0IG9mIGZpbGVzIHRoYXQgcmVwcmVzZW50cyB0aGUgZXh0ZXJuYWwgZGF0YS5cbiAgICovXG4gIGV4dGVybmFsRGF0YT86IHJlYWRvbmx5IEV4dGVybmFsRGF0YUZpbGVUeXBlW107XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuL3RlbnNvci5qcyc7XG5cbmV4cG9ydCB0eXBlIE5vblRlbnNvclR5cGUgPSBuZXZlcjtcblxuLyoqXG4gKiBUeXBlIE9ubnhWYWx1ZSBSZXByZXNlbnRzIGJvdGggdGVuc29ycyBhbmQgbm9uLXRlbnNvcnMgdmFsdWUgZm9yIG1vZGVsJ3MgaW5wdXRzL291dHB1dHMuXG4gKlxuICogTk9URTogY3VycmVudGx5IG5vdCBzdXBwb3J0IG5vbi10ZW5zb3JcbiAqL1xuZXhwb3J0IHR5cGUgT25ueFZhbHVlID0gVGVuc29yfE5vblRlbnNvclR5cGU7XG5cbi8qKlxuICogVHlwZSBPbm54VmFsdWVEYXRhTG9jYXRpb24gcmVwcmVzZW50cyB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEgb2YgYW4gT25ueFZhbHVlLlxuICovXG5leHBvcnQgdHlwZSBPbm54VmFsdWVEYXRhTG9jYXRpb24gPSBUZW5zb3IuRGF0YUxvY2F0aW9uO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge3Jlc29sdmVCYWNrZW5kQW5kRXhlY3V0aW9uUHJvdmlkZXJzfSBmcm9tICcuL2JhY2tlbmQtaW1wbC5qcyc7XG5pbXBvcnQge1Nlc3Npb25IYW5kbGVyLCBUcmFpbmluZ1Nlc3Npb25IYW5kbGVyfSBmcm9tICcuL2JhY2tlbmQuanMnO1xuaW1wb3J0IHtJbmZlcmVuY2VTZXNzaW9uIGFzIEluZmVyZW5jZVNlc3Npb259IGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24uanMnO1xuaW1wb3J0IHtPbm54VmFsdWV9IGZyb20gJy4vb25ueC12YWx1ZS5qcyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi90ZW5zb3IuanMnO1xuaW1wb3J0IHtUcmFpbmluZ1Nlc3Npb24gYXMgVHJhaW5pbmdTZXNzaW9uSW50ZXJmYWNlLCBUcmFpbmluZ1Nlc3Npb25DcmVhdGVPcHRpb25zfSBmcm9tICcuL3RyYWluaW5nLXNlc3Npb24uanMnO1xuXG50eXBlIFNlc3Npb25PcHRpb25zID0gSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucztcbnR5cGUgRmVlZHNUeXBlID0gSW5mZXJlbmNlU2Vzc2lvbi5GZWVkc1R5cGU7XG50eXBlIEZldGNoZXNUeXBlID0gSW5mZXJlbmNlU2Vzc2lvbi5GZXRjaGVzVHlwZTtcbnR5cGUgUmV0dXJuVHlwZSA9IEluZmVyZW5jZVNlc3Npb24uUmV0dXJuVHlwZTtcbnR5cGUgUnVuT3B0aW9ucyA9IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucztcblxuY29uc3Qgbm9CYWNrZW5kRXJyTXNnOiBzdHJpbmcgPSAnVHJhaW5pbmcgYmFja2VuZCBjb3VsZCBub3QgYmUgcmVzb2x2ZWQuICcgK1xuICAgICdNYWtlIHN1cmUgeW91XFwncmUgdXNpbmcgdGhlIGNvcnJlY3QgY29uZmlndXJhdGlvbiAmIFdlYkFzc2VtYmx5IGZpbGVzLic7XG5cbmV4cG9ydCBjbGFzcyBUcmFpbmluZ1Nlc3Npb24gaW1wbGVtZW50cyBUcmFpbmluZ1Nlc3Npb25JbnRlcmZhY2Uge1xuICBwcml2YXRlIGNvbnN0cnVjdG9yKGhhbmRsZXI6IFRyYWluaW5nU2Vzc2lvbkhhbmRsZXIsIGhhc09wdGltaXplck1vZGVsOiBib29sZWFuLCBoYXNFdmFsTW9kZWw6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIHRoaXMuaGFzT3B0aW1pemVyTW9kZWwgPSBoYXNPcHRpbWl6ZXJNb2RlbDtcbiAgICB0aGlzLmhhc0V2YWxNb2RlbCA9IGhhc0V2YWxNb2RlbDtcbiAgfVxuICBwcml2YXRlIGhhbmRsZXI6IFRyYWluaW5nU2Vzc2lvbkhhbmRsZXI7XG4gIHByaXZhdGUgaGFzT3B0aW1pemVyTW9kZWw6IGJvb2xlYW47XG4gIHByaXZhdGUgaGFzRXZhbE1vZGVsOiBib29sZWFuO1xuXG4gIGdldCB0cmFpbmluZ0lucHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuaW5wdXROYW1lcztcbiAgfVxuICBnZXQgdHJhaW5pbmdPdXRwdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vdXRwdXROYW1lcztcbiAgfVxuXG4gIGdldCBldmFsSW5wdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgaWYgKHRoaXMuaGFzRXZhbE1vZGVsKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmV2YWxJbnB1dE5hbWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdHJhaW5pbmcgc2Vzc2lvbiBoYXMgbm8gZXZhbE1vZGVsIGxvYWRlZC4nKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGV2YWxPdXRwdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgaWYgKHRoaXMuaGFzRXZhbE1vZGVsKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmV2YWxPdXRwdXROYW1lcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHRyYWluaW5nIHNlc3Npb24gaGFzIG5vIGV2YWxNb2RlbCBsb2FkZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZSh0cmFpbmluZ09wdGlvbnM6IFRyYWluaW5nU2Vzc2lvbkNyZWF0ZU9wdGlvbnMsIHNlc3Npb25PcHRpb25zPzogU2Vzc2lvbk9wdGlvbnMpOlxuICAgICAgUHJvbWlzZTxUcmFpbmluZ1Nlc3Npb24+IHtcbiAgICBjb25zdCBldmFsTW9kZWw6IHN0cmluZ3xVaW50OEFycmF5ID0gdHJhaW5pbmdPcHRpb25zLmV2YWxNb2RlbCB8fCAnJztcbiAgICBjb25zdCBvcHRpbWl6ZXJNb2RlbDogc3RyaW5nfFVpbnQ4QXJyYXkgPSB0cmFpbmluZ09wdGlvbnMub3B0aW1pemVyTW9kZWwgfHwgJyc7XG4gICAgY29uc3Qgb3B0aW9uczogU2Vzc2lvbk9wdGlvbnMgPSBzZXNzaW9uT3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIHJlc29sdmUgYmFja2VuZCwgdXBkYXRlIHNlc3Npb24gb3B0aW9ucyB3aXRoIHZhbGlkYXRlZCBFUHMsIGFuZCBjcmVhdGUgc2Vzc2lvbiBoYW5kbGVyXG4gICAgY29uc3QgW2JhY2tlbmQsIG9wdGlvbnNXaXRoVmFsaWRhdGVkRVBzXSA9IGF3YWl0IHJlc29sdmVCYWNrZW5kQW5kRXhlY3V0aW9uUHJvdmlkZXJzKG9wdGlvbnMpO1xuICAgIGlmIChiYWNrZW5kLmNyZWF0ZVRyYWluaW5nU2Vzc2lvbkhhbmRsZXIpIHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBhd2FpdCBiYWNrZW5kLmNyZWF0ZVRyYWluaW5nU2Vzc2lvbkhhbmRsZXIoXG4gICAgICAgICAgdHJhaW5pbmdPcHRpb25zLmNoZWNrcG9pbnRTdGF0ZSwgdHJhaW5pbmdPcHRpb25zLnRyYWluTW9kZWwsIGV2YWxNb2RlbCwgb3B0aW1pemVyTW9kZWwsXG4gICAgICAgICAgb3B0aW9uc1dpdGhWYWxpZGF0ZWRFUHMpO1xuICAgICAgcmV0dXJuIG5ldyBUcmFpbmluZ1Nlc3Npb24oaGFuZGxlciwgISF0cmFpbmluZ09wdGlvbnMub3B0aW1pemVyTW9kZWwsICEhdHJhaW5pbmdPcHRpb25zLmV2YWxNb2RlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihub0JhY2tlbmRFcnJNc2cpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIHJ1blRyYWluU3RlcCBhbmQgZnV0dXJlIHJ1blN0ZXAgbWV0aG9kcyB0aGF0IGhhbmRsZXMgdGhlIHR5cGUtbmFycm93aW5nIGNvbnZlcnNpb24gZnJvbVxuICAgKiB0aGUgZ2l2ZW4gcGFyYW1ldGVycyB0byBTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSBhbmQgUnVuT3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0TmFtZXMgdGhlIGZlZWRzIG9iamVjdCBpcyBjaGVja2VkIHRoYXQgdGhleSBjb250YWluIGFsbCBpbnB1dCBuYW1lcyBpbiB0aGUgcHJvdmlkZWQgbGlzdCBvZiBpbnB1dFxuICAgKiBuYW1lcy5cbiAgICogQHBhcmFtIG91dHB1dE5hbWVzIHRoZSBmZXRjaGVzIG9iamVjdCBpcyBjaGVja2VkIHRoYXQgdGhlaXIga2V5cyBtYXRjaCB1cCB3aXRoIHZhbGlkIG5hbWVzIGluIHRoZSBsaXN0IG9mIG91dHB1dFxuICAgKiBuYW1lcy5cbiAgICogQHBhcmFtIGZlZWRzIHRoZSByZXF1aXJlZCBpbnB1dFxuICAgKiBAcGFyYW0gYXJnMSBuYXJyb3dlZCAmIGNvbnZlcnRlZCBpbnRvIHRoZSBTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSBvciBSdW5PcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0gYXJnMiBvcHRpb25hbCBSdW5PcHRpb25zIG9iamVjdC5cbiAgICogQHJldHVybnNcbiAgICovXG4gIHR5cGVOYXJyb3dpbmdGb3JSdW5TdGVwKFxuICAgICAgaW5wdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW10sIG91dHB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXSwgZmVlZHM6IEZlZWRzVHlwZSwgYXJnMT86IEZldGNoZXNUeXBlfFJ1bk9wdGlvbnMsXG4gICAgICBhcmcyPzogUnVuT3B0aW9ucyk6IFtTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSwgUnVuT3B0aW9uc10ge1xuICAgIGNvbnN0IGZldGNoZXM6IHtbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlfG51bGx9ID0ge307XG4gICAgbGV0IG9wdGlvbnM6IFJ1bk9wdGlvbnMgPSB7fTtcbiAgICAvLyBjaGVjayBpbnB1dHNcbiAgICBpZiAodHlwZW9mIGZlZWRzICE9PSAnb2JqZWN0JyB8fCBmZWVkcyA9PT0gbnVsbCB8fCBmZWVkcyBpbnN0YW5jZW9mIFRlbnNvciB8fCBBcnJheS5pc0FycmF5KGZlZWRzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnXFwnZmVlZHNcXCcgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCB1c2UgaW5wdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLicpO1xuICAgIH1cblxuICAgIGxldCBpc0ZldGNoZXNFbXB0eSA9IHRydWU7XG4gICAgLy8gZGV0ZXJtaW5lIHdoaWNoIG92ZXJyaWRlIGlzIGJlaW5nIHVzZWRcbiAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoYXJnMSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBjYW5ub3QgYmUgbnVsbC4nKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmcxIGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ2ZldGNoZXNcXCcgY2Fubm90IGJlIGEgVGVuc29yJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgIGlmIChhcmcxLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ2ZldGNoZXNcXCcgY2Fubm90IGJlIGFuIGVtcHR5IGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgIC8vIG91dHB1dCBuYW1lc1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgYXJnMSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ2ZldGNoZXNcXCcgbXVzdCBiZSBhIHN0cmluZyBhcnJheSBvciBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvdXRwdXROYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdmZXRjaGVzJyBjb250YWlucyBpbnZhbGlkIG91dHB1dCBuYW1lOiAke25hbWV9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmZXRjaGVzW25hbWVdID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ29iamVjdCcgJiYgYXJnMiAhPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ29wdGlvbnNcXCcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlY2lkZSB3aGV0aGVyIGFyZzEgaXMgZmV0Y2hlcyBvciBvcHRpb25zXG4gICAgICAgIC8vIGlmIGFueSBvdXRwdXQgbmFtZSBpcyBwcmVzZW50IGFuZCBpdHMgdmFsdWUgaXMgdmFsaWQgT25ueFZhbHVlLCB3ZSBjb25zaWRlciBpdCBmZXRjaGVzXG4gICAgICAgIGxldCBpc0ZldGNoZXMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgYXJnMUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcmcxKTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIG91dHB1dE5hbWVzKSB7XG4gICAgICAgICAgaWYgKGFyZzFLZXlzLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gKGFyZzEgYXMgSW5mZXJlbmNlU2Vzc2lvbi5OdWxsYWJsZU9ubnhWYWx1ZU1hcFR5cGUpW25hbWVdO1xuICAgICAgICAgICAgaWYgKHYgPT09IG51bGwgfHwgdiBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICAgICAgICBpc0ZldGNoZXMgPSB0cnVlO1xuICAgICAgICAgICAgICBpc0ZldGNoZXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICBmZXRjaGVzW25hbWVdID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNGZXRjaGVzKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBhcmcyID09PSAnb2JqZWN0JyAmJiBhcmcyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gYXJnMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnb3B0aW9uc1xcJyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucyA9IGFyZzEgYXMgUnVuT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBtdXN0IGJlIFxcJ2ZldGNoZXNcXCcgb3IgXFwnb3B0aW9uc1xcJy4nKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBhbGwgaW5wdXRzIGFyZSBpbiBmZWVkXG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGlucHV0TmFtZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgZmVlZHNbbmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5wdXQgJyR7bmFtZX0nIGlzIG1pc3NpbmcgaW4gJ2ZlZWRzJy5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBubyBmZXRjaGVzIGlzIHNwZWNpZmllZCwgd2UgdXNlIHRoZSBmdWxsIG91dHB1dCBuYW1lcyBsaXN0XG4gICAgaWYgKGlzRmV0Y2hlc0VtcHR5KSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygb3V0cHV0TmFtZXMpIHtcbiAgICAgICAgZmV0Y2hlc1tuYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtmZXRjaGVzLCBvcHRpb25zXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgbWV0aG9kIGZvciBydW5UcmFpblN0ZXAgYW5kIGFueSBvdGhlciBydW5TdGVwIG1ldGhvZHMuIFRha2VzIHRoZSBSZXR1cm5UeXBlIHJlc3VsdCBmcm9tIHRoZSBTZXNzaW9uSGFuZGxlclxuICAgKiBhbmQgY2hhbmdlcyBpdCBpbnRvIGEgbWFwIG9mIFRlbnNvcnMuXG4gICAqXG4gICAqIEBwYXJhbSByZXN1bHRzXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBjb252ZXJ0SGFuZGxlclJldHVyblR5cGVUb01hcE9mVGVuc29ycyhyZXN1bHRzOiBTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlKTogUmV0dXJuVHlwZSB7XG4gICAgY29uc3QgcmV0dXJuVmFsdWU6IHtbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlfSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdHMpIHtcbiAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHRzLCBrZXkpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdHNba2V5XTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICAgIHJldHVyblZhbHVlW2tleV0gPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuVmFsdWVba2V5XSA9IG5ldyBUZW5zb3IocmVzdWx0LnR5cGUsIHJlc3VsdC5kYXRhLCByZXN1bHQuZGltcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9XG5cbiAgYXN5bmMgbGF6eVJlc2V0R3JhZCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLmhhbmRsZXIubGF6eVJlc2V0R3JhZCgpO1xuICB9XG5cbiAgcnVuVHJhaW5TdGVwKGZlZWRzOiBGZWVkc1R5cGUsIG9wdGlvbnM/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPjtcbiAgcnVuVHJhaW5TdGVwKGZlZWRzOiBGZWVkc1R5cGUsIGZldGNoZXM6IEZldGNoZXNUeXBlLCBvcHRpb25zPzogUnVuT3B0aW9ucyk6IFByb21pc2U8UmV0dXJuVHlwZT47XG4gIGFzeW5jIHJ1blRyYWluU3RlcChmZWVkczogRmVlZHNUeXBlLCBhcmcxPzogRmV0Y2hlc1R5cGV8UnVuT3B0aW9ucywgYXJnMj86IFJ1bk9wdGlvbnMpOiBQcm9taXNlPFJldHVyblR5cGU+IHtcbiAgICBjb25zdCBbZmV0Y2hlcywgb3B0aW9uc10gPVxuICAgICAgICB0aGlzLnR5cGVOYXJyb3dpbmdGb3JSdW5TdGVwKHRoaXMudHJhaW5pbmdJbnB1dE5hbWVzLCB0aGlzLnRyYWluaW5nT3V0cHV0TmFtZXMsIGZlZWRzLCBhcmcxLCBhcmcyKTtcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5oYW5kbGVyLnJ1blRyYWluU3RlcChmZWVkcywgZmV0Y2hlcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuY29udmVydEhhbmRsZXJSZXR1cm5UeXBlVG9NYXBPZlRlbnNvcnMocmVzdWx0cyk7XG4gIH1cblxuICBhc3luYyBydW5PcHRpbWl6ZXJTdGVwKG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnN8dW5kZWZpbmVkKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuaGFzT3B0aW1pemVyTW9kZWwpIHtcbiAgICAgIGF3YWl0IHRoaXMuaGFuZGxlci5ydW5PcHRpbWl6ZXJTdGVwKG9wdGlvbnMgfHwge30pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgVHJhaW5pbmdTZXNzaW9uIGhhcyBubyBPcHRpbWl6ZXJNb2RlbCBsb2FkZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgcnVuRXZhbFN0ZXAoZmVlZHM6IEZlZWRzVHlwZSwgb3B0aW9ucz86IFJ1bk9wdGlvbnN8dW5kZWZpbmVkKTogUHJvbWlzZTxSZXR1cm5UeXBlPjtcbiAgcnVuRXZhbFN0ZXAoZmVlZHM6IEZlZWRzVHlwZSwgZmV0Y2hlczogRmV0Y2hlc1R5cGUsIG9wdGlvbnM/OiBSdW5PcHRpb25zfHVuZGVmaW5lZCk6IFByb21pc2U8UmV0dXJuVHlwZT47XG4gIGFzeW5jIHJ1bkV2YWxTdGVwKGZlZWRzOiBGZWVkc1R5cGUsIGFyZzE/OiBGZXRjaGVzVHlwZXxSdW5PcHRpb25zLCBhcmcyPzogUnVuT3B0aW9ucyk6IFByb21pc2U8UmV0dXJuVHlwZT4ge1xuICAgIGlmICh0aGlzLmhhc0V2YWxNb2RlbCkge1xuICAgICAgY29uc3QgW2ZldGNoZXMsIG9wdGlvbnNdID1cbiAgICAgICAgICB0aGlzLnR5cGVOYXJyb3dpbmdGb3JSdW5TdGVwKHRoaXMuZXZhbElucHV0TmFtZXMsIHRoaXMuZXZhbE91dHB1dE5hbWVzLCBmZWVkcywgYXJnMSwgYXJnMik7XG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5oYW5kbGVyLnJ1bkV2YWxTdGVwKGZlZWRzLCBmZXRjaGVzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRIYW5kbGVyUmV0dXJuVHlwZVRvTWFwT2ZUZW5zb3JzKHJlc3VsdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgVHJhaW5pbmdTZXNzaW9uIGhhcyBubyBFdmFsTW9kZWwgbG9hZGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFBhcmFtZXRlcnNTaXplKHRyYWluYWJsZU9ubHkgPSB0cnVlKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmdldFBhcmFtZXRlcnNTaXplKHRyYWluYWJsZU9ubHkpO1xuICB9XG5cbiAgYXN5bmMgbG9hZFBhcmFtZXRlcnNCdWZmZXIoYXJyYXk6IFVpbnQ4QXJyYXksIHRyYWluYWJsZU9ubHkgPSB0cnVlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcGFyYW1zU2l6ZSA9IGF3YWl0IHRoaXMuZ2V0UGFyYW1ldGVyc1NpemUodHJhaW5hYmxlT25seSk7XG4gICAgLy8gY2hlY2tpbmcgdGhhdCB0aGUgc2l6ZSBvZiB0aGUgVWludDhBcnJheSBpcyBlcXVpdmFsZW50IHRvIHRoZSBieXRlIGxlbmd0aCBvZiBhIEZsb2F0MzJBcnJheSBvZiB0aGUgbnVtYmVyXG4gICAgLy8gb2YgcGFyYW1ldGVyc1xuICAgIGlmIChhcnJheS5sZW5ndGggIT09IDQgKiBwYXJhbXNTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1NpemUgb2YgdGhlIGJ1ZmZlciBwYXNzZWQgaW50byBsb2FkUGFyYW1ldGVyc0J1ZmZlciBtdXN0IG1hdGNoIHRoZSBudW1iZXIgb2YgcGFyYW1ldGVycyBpbiAnICtcbiAgICAgICAgICAndGhlIG1vZGVsLiBQbGVhc2UgdXNlIGdldFBhcmFtZXRlcnNTaXplIG1ldGhvZCB0byBjaGVjay4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5sb2FkUGFyYW1ldGVyc0J1ZmZlcihhcnJheSwgdHJhaW5hYmxlT25seSk7XG4gIH1cblxuICBhc3luYyBnZXRDb250aWd1b3VzUGFyYW1ldGVycyh0cmFpbmFibGVPbmx5ID0gdHJ1ZSk6IFByb21pc2U8T25ueFZhbHVlPiB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5nZXRDb250aWd1b3VzUGFyYW1ldGVycyh0cmFpbmFibGVPbmx5KTtcbiAgfVxuXG4gIGFzeW5jIHJlbGVhc2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5kaXNwb3NlKCk7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtJbmZlcmVuY2VTZXNzaW9ufSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcbmltcG9ydCB7T25ueFZhbHVlfSBmcm9tICcuL29ubngtdmFsdWUuanMnO1xuaW1wb3J0IHtUcmFpbmluZ1Nlc3Npb24gYXMgVHJhaW5pbmdTZXNzaW9uSW1wbH0gZnJvbSAnLi90cmFpbmluZy1zZXNzaW9uLWltcGwuanMnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkZWNsYXJlICovXG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBUcmFpbmluZ1Nlc3Npb24ge1xuICAvKipcbiAgICogRWl0aGVyIFVSSSBmaWxlIHBhdGggKHN0cmluZykgb3IgVWludDhBcnJheSBjb250YWluaW5nIG1vZGVsIG9yIGNoZWNrcG9pbnQgaW5mb3JtYXRpb24uXG4gICAqL1xuICB0eXBlIFVyaU9yQnVmZmVyID0gc3RyaW5nfFVpbnQ4QXJyYXk7XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgcnVudGltZSBpbnN0YW5jZSBvZiBhbiBPTk5YIHRyYWluaW5nIHNlc3Npb24sXG4gKiB3aGljaCBjb250YWlucyBhIG1vZGVsIHRoYXQgY2FuIGJlIHRyYWluZWQsIGFuZCwgb3B0aW9uYWxseSxcbiAqIGFuIGV2YWwgYW5kIG9wdGltaXplciBtb2RlbC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFpbmluZ1Nlc3Npb24ge1xuICAvLyAjcmVnaW9uIHJ1bigpXG5cbiAgLyoqXG4gICAqIExhemlseSByZXNldHMgdGhlIGdyYWRpZW50cyBvZiBhbGwgdHJhaW5hYmxlIHBhcmFtZXRlcnMgdG8gemVyby4gU2hvdWxkIGhhcHBlbiBhZnRlciB0aGUgaW52b2NhdGlvbiBvZlxuICAgKiBydW5PcHRpbWl6ZXJTdGVwLlxuICAgKi9cbiAgbGF6eVJlc2V0R3JhZCgpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBSdW4gVHJhaW5TdGVwIGFzeW5jaHJvbm91c2x5IHdpdGggdGhlIGdpdmVuIGZlZWRzIGFuZCBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gZmVlZHMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgaW5wdXQuIFNlZSB0eXBlIGRlc2NyaXB0aW9uIG9mIGBJbmZlcmVuY2VTZXNzaW9uLklucHV0VHlwZWAgZm9yXG4gICBkZXRhaWwuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwuIEEgc2V0IG9mIG9wdGlvbnMgdGhhdCBjb250cm9scyB0aGUgYmVoYXZpb3Igb2YgbW9kZWwgdHJhaW5pbmcuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbWFwLCB3aGljaCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAqL1xuICBydW5UcmFpblN0ZXAoZmVlZHM6IEluZmVyZW5jZVNlc3Npb24uRmVlZHNUeXBlLCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTpcbiAgICAgIFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbi5SZXR1cm5UeXBlPjtcblxuICAvKipcbiAgICogUnVuIGEgc2luZ2xlIHRyYWluIHN0ZXAgd2l0aCB0aGUgZ2l2ZW4gaW5wdXRzIGFuZCBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gZmVlZHMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgaW5wdXQuXG4gICAqIEBwYXJhbSBmZXRjaGVzIC0gUmVwcmVzZW50YXRpb24gb2YgdGhlIG1vZGVsIG91dHB1dC5cbiAgICogZGV0YWlsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBBIHNldCBvZiBvcHRpb25zIHRoYXQgY29udHJvbHMgdGhlIGJlaGF2aW9yIG9mIG1vZGVsIHRyYWluaW5nLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIG1hcCwgd2hpY2ggdXNlcyBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmdcbiAgIHZhbHVlcy5cbiAgICovXG4gIHJ1blRyYWluU3RlcChcbiAgICAgIGZlZWRzOiBJbmZlcmVuY2VTZXNzaW9uLkZlZWRzVHlwZSwgZmV0Y2hlczogSW5mZXJlbmNlU2Vzc2lvbi5GZXRjaGVzVHlwZSxcbiAgICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24uUmV0dXJuVHlwZT47XG5cbiAgLyoqXG4gICAqIFJ1bnMgYSBzaW5nbGUgb3B0aW1pemVyIHN0ZXAsIHdoaWNoIHBlcmZvcm1zIHdlaWdodCB1cGRhdGVzIGZvciB0aGUgdHJhaW5hYmxlIHBhcmFtZXRlcnMgdXNpbmcgdGhlIG9wdGltaXplciBtb2RlbC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gQSBzZXQgb2Ygb3B0aW9ucyB0aGF0IGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBtb2RlbCBvcHRpbWl6aW5nLlxuICAgKi9cbiAgcnVuT3B0aW1pemVyU3RlcChvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogUnVuIGEgc2luZ2xlIGV2YWwgc3RlcCB3aXRoIHRoZSBnaXZlbiBpbnB1dHMgYW5kIG9wdGlvbnMgdXNpbmcgdGhlIGV2YWwgbW9kZWwuXG4gICAqXG4gICAqIEBwYXJhbSBmZWVkcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBpbnB1dC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gQSBzZXQgb2Ygb3B0aW9ucyB0aGF0IGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBtb2RlbCBldmFsIHN0ZXAuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbWFwLCB3aGljaCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZ1xuICAgdmFsdWVzLlxuICAgKi9cbiAgcnVuRXZhbFN0ZXAoZmVlZHM6IEluZmVyZW5jZVNlc3Npb24uRmVlZHNUeXBlLCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTpcbiAgICAgIFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbi5SZXR1cm5UeXBlPjtcblxuICAvKipcbiAgICogUnVuIGEgc2luZ2xlIGV2YWwgc3RlcCB3aXRoIHRoZSBnaXZlbiBpbnB1dHMgYW5kIG9wdGlvbnMgdXNpbmcgdGhlIGV2YWwgbW9kZWwuXG4gICAqXG4gICAqIEBwYXJhbSBmZWVkcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBpbnB1dC5cbiAgICogQHBhcmFtIGZldGNoZXMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgb3V0cHV0LlxuICAgKiBkZXRhaWwuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwuIEEgc2V0IG9mIG9wdGlvbnMgdGhhdCBjb250cm9scyB0aGUgYmVoYXZpb3Igb2YgbW9kZWwgZXZhbCBzdGVwLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIG1hcCwgd2hpY2ggdXNlcyBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmdcbiAgIHZhbHVlcy5cbiAgICovXG4gIHJ1bkV2YWxTdGVwKFxuICAgICAgZmVlZHM6IEluZmVyZW5jZVNlc3Npb24uRmVlZHNUeXBlLCBmZXRjaGVzOiBJbmZlcmVuY2VTZXNzaW9uLkZldGNoZXNUeXBlLFxuICAgICAgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbi5SZXR1cm5UeXBlPjtcblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBjb3B5IHBhcmFtZXRlcnNcblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBzaXplIG9mIGFsbCBwYXJhbWV0ZXJzIGZvciB0aGUgdHJhaW5pbmcgc3RhdGUuIENhbGN1bGF0ZXMgdGhlIHRvdGFsIG51bWJlciBvZiBwcmltaXRpdmUgKGRhdGF0eXBlIG9mXG4gICAqIHRoZSBwYXJhbWV0ZXJzKSBlbGVtZW50cyBvZiBhbGwgdGhlIHBhcmFtZXRlcnMgaW4gdGhlIHRyYWluaW5nIHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0gdHJhaW5hYmxlT25seSAtIFdoZW4gc2V0IHRvIHRydWUsIHRoZSBzaXplIGlzIGNhbGN1bGF0ZWQgZm9yIHRyYWluYWJsZSBwYXJhbXMgb25seS4gRGVmYXVsdCB2YWx1ZSBpcyB0cnVlLlxuICAgKi9cbiAgZ2V0UGFyYW1ldGVyc1NpemUodHJhaW5hYmxlT25seTogYm9vbGVhbik6IFByb21pc2U8bnVtYmVyPjtcblxuICAvKipcbiAgICogQ29waWVzIHBhcmFtZXRlciB2YWx1ZXMgZnJvbSB0aGUgZ2l2ZW4gYnVmZmVyIHRvIHRoZSB0cmFpbmluZyBzdGF0ZS4gQ3VycmVudGx5LCBvbmx5IHN1cHBvcnRpbmcgbW9kZWxzIHdpdGhcbiAgICogcGFyYW1ldGVycyBvZiB0eXBlIEZsb2F0MzIuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgLSBBIFVpbnQ4QXJyYXkgcmVwcmVzZW50YXRpb24gb2YgRmxvYXQzMiBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0gdHJhaW5hYmxlT25seSAtIFRydWUgaWYgdHJhaW5hYmxlIHBhcmFtZXRlcnMgb25seSB0byBiZSBtb2RpZmllZCwgZmFsc2Ugb3RoZXJ3aXNlLiBEZWZhdWx0IHZhbHVlIGlzIHRydWUuXG4gICAqL1xuICBsb2FkUGFyYW1ldGVyc0J1ZmZlcihidWZmZXI6IFVpbnQ4QXJyYXksIHRyYWluYWJsZU9ubHk6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIG1vZGVsIHBhcmFtZXRlcnMgdG8gYSBjb250aWd1b3VzIGJ1ZmZlci4gVXN1YWxseSB1c2VkIGluIHRoZSBjb250ZXh0IG9mIEZlZGVyYXRlZCBMZWFybmluZy5cbiAgICogQ3VycmVudGx5LCBvbmx5IHN1cHBvcnRpbmcgbW9kZWxzIHdpdGggcGFyYW1ldGVycyBvZiB0eXBlIEZsb2F0MzIuXG4gICAqXG4gICAqIEBwYXJhbSB0cmFpbmFibGVPbmx5IC0gV2hlbiBzZXQgdG8gdHJ1ZSwgb25seSB0cmFpbmFibGUgcGFyYW1ldGVycyBhcmUgY29waWVkLiBUcmFpbmFibGUgcGFyYW1ldGVycyBhcmUgcGFyYW1ldGVyc1xuICAgKiBmb3Igd2hpY2ggcmVxdWlyZXNfZ3JhZCBpcyBzZXQgdG8gdHJ1ZS4gRGVmYXVsdCB2YWx1ZSBpcyB0cnVlLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIEZsb2F0MzIgT25ueFZhbHVlIG9mIHRoZSByZXF1ZXN0ZWQgcGFyYW1ldGVycy5cbiAgICovXG4gIGdldENvbnRpZ3VvdXNQYXJhbWV0ZXJzKHRyYWluYWJsZU9ubHk6IGJvb2xlYW4pOiBQcm9taXNlPE9ubnhWYWx1ZT47XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHJlbGVhc2UoKVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlIHRoZSBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgdGhlIHVuZGVybHlpbmcgcmVzb3VyY2VzLlxuICAgKi9cbiAgcmVsZWFzZSgpOiBQcm9taXNlPHZvaWQ+O1xuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBtZXRhZGF0YVxuXG4gIC8qKlxuICAgKiBHZXQgaW5wdXQgbmFtZXMgb2YgdGhlIGxvYWRlZCB0cmFpbmluZyBtb2RlbC5cbiAgICovXG4gIHJlYWRvbmx5IHRyYWluaW5nSW5wdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIEdldCBvdXRwdXQgbmFtZXMgb2YgdGhlIGxvYWRlZCB0cmFpbmluZyBtb2RlbC5cbiAgICovXG4gIHJlYWRvbmx5IHRyYWluaW5nT3V0cHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBHZXQgaW5wdXQgbmFtZXMgb2YgdGhlIGxvYWRlZCBldmFsIG1vZGVsLiBJcyBhbiBlbXB0eSBhcnJheSBpZiBubyBldmFsIG1vZGVsIGlzIGxvYWRlZC5cbiAgICovXG4gIHJlYWRvbmx5IGV2YWxJbnB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICAvKipcbiAgICogR2V0IG91dHB1dCBuYW1lcyBvZiB0aGUgbG9hZGVkIGV2YWwgbW9kZWwuIElzIGFuIGVtcHR5IGFycmF5IGlmIG5vIGV2YWwgbW9kZWwgaXMgbG9hZGVkLlxuICAgKi9cbiAgcmVhZG9ubHkgZXZhbE91dHB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICAvLyAjZW5kcmVnaW9uXG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgb3B0aW9uYWwgcGFyYW1ldGVycyB0aGF0IGNhbiBiZSBwYXNzZWQgaW50byB0aGUgVHJhaW5pbmdTZXNzaW9uRmFjdG9yeS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFpbmluZ1Nlc3Npb25DcmVhdGVPcHRpb25zIHtcbiAgLyoqXG4gICAqIFVSSSBvciBidWZmZXIgZm9yIGEgLmNrcHQgZmlsZSB0aGF0IGNvbnRhaW5zIHRoZSBjaGVja3BvaW50IGZvciB0aGUgdHJhaW5pbmcgbW9kZWwuXG4gICAqL1xuICBjaGVja3BvaW50U3RhdGU6IFRyYWluaW5nU2Vzc2lvbi5VcmlPckJ1ZmZlcjtcbiAgLyoqXG4gICAqIFVSSSBvciBidWZmZXIgZm9yIHRoZSAub25ueCB0cmFpbmluZyBmaWxlLlxuICAgKi9cbiAgdHJhaW5Nb2RlbDogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyO1xuICAvKipcbiAgICogT3B0aW9uYWwuIFVSSSBvciBidWZmZXIgZm9yIHRoZSAub25ueCBvcHRpbWl6ZXIgbW9kZWwgZmlsZS5cbiAgICovXG4gIG9wdGltaXplck1vZGVsPzogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyO1xuICAvKipcbiAgICogT3B0aW9uYWwuIFVSSSBvciBidWZmZXIgZm9yIHRoZSAub25ueCBldmFsIG1vZGVsIGZpbGUuXG4gICAqL1xuICBldmFsTW9kZWw/OiBUcmFpbmluZ1Nlc3Npb24uVXJpT3JCdWZmZXI7XG59XG5cbi8qKlxuICogRGVmaW5lcyBtZXRob2Qgb3ZlcmxvYWQgcG9zc2liaWxpdGllcyBmb3IgY3JlYXRpbmcgYSBUcmFpbmluZ1Nlc3Npb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhaW5pbmdTZXNzaW9uRmFjdG9yeSB7XG4gIC8vICNyZWdpb24gY3JlYXRlKClcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBUcmFpbmluZ1Nlc3Npb24gYW5kIGFzeW5jaHJvbm91c2x5IGxvYWRzIGFueSBtb2RlbHMgcGFzc2VkIGluIHRocm91Z2ggdHJhaW5pbmdPcHRpb25zXG4gICAqXG4gICAqIEBwYXJhbSB0cmFpbmluZ09wdGlvbnMgc3BlY2lmeSBtb2RlbHMgYW5kIGNoZWNrcG9pbnRzIHRvIGxvYWQgaW50byB0aGUgVHJhaW5pbmcgU2Vzc2lvblxuICAgKiBAcGFyYW0gc2Vzc2lvbk9wdGlvbnMgc3BlY2lmeSBjb25maWd1cmF0aW9uIGZvciB0cmFpbmluZyBzZXNzaW9uIGJlaGF2aW9yXG4gICAqXG4gICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIFRyYWluaW5nU2Vzc2lvbiBvYmplY3RcbiAgICovXG4gIGNyZWF0ZSh0cmFpbmluZ09wdGlvbnM6IFRyYWluaW5nU2Vzc2lvbkNyZWF0ZU9wdGlvbnMsIHNlc3Npb25PcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6XG4gICAgICBQcm9taXNlPFRyYWluaW5nU2Vzc2lvbj47XG5cbiAgLy8gI2VuZHJlZ2lvblxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY29uc3QgVHJhaW5pbmdTZXNzaW9uOiBUcmFpbmluZ1Nlc3Npb25GYWN0b3J5ID0gVHJhaW5pbmdTZXNzaW9uSW1wbDtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLyoqXG4gKiAjIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSVxuICpcbiAqIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSSBpcyBhIHVuaWZpZWQgQVBJIGZvciBhbGwgSmF2YVNjcmlwdCB1c2FnZXMsIGluY2x1ZGluZyB0aGUgZm9sbG93aW5nIE5QTSBwYWNrYWdlczpcbiAqXG4gKiAtIFtvbm54cnVudGltZS1ub2RlXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS1ub2RlKVxuICogLSBbb25ueHJ1bnRpbWUtd2ViXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS13ZWIpXG4gKiAtIFtvbm54cnVudGltZS1yZWFjdC1uYXRpdmVdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL29ubnhydW50aW1lLXJlYWN0LW5hdGl2ZSlcbiAqXG4gKiBTZWUgYWxzbzpcbiAqIC0gW0dldCBTdGFydGVkXShodHRwczovL29ubnhydW50aW1lLmFpL2RvY3MvZ2V0LXN0YXJ0ZWQvd2l0aC1qYXZhc2NyaXB0LylcbiAqIC0gW0luZmVyZW5jZSBleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS1pbmZlcmVuY2UtZXhhbXBsZXMvdHJlZS9tYWluL2pzKVxuICpcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5cbmV4cG9ydCAqIGZyb20gJy4vYmFja2VuZC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2Vudi5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdGVuc29yLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdGVuc29yLWNvbnZlcnNpb24uanMnO1xuZXhwb3J0ICogZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3RyYWNlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vb25ueC1tb2RlbC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL29ubngtdmFsdWUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi90cmFpbmluZy1zZXNzaW9uLmpzJztcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtFbnZ9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7V2ViR0xDb250ZXh0fSBmcm9tICcuL2JhY2tlbmRzL3dlYmdsL3dlYmdsLWNvbnRleHQnO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgTG9nZ2VyIHtcbiAgZXhwb3J0IGludGVyZmFjZSBTZXZlcml0eVR5cGVNYXAge1xuICAgIHZlcmJvc2U6ICd2JztcbiAgICBpbmZvOiAnaSc7XG4gICAgd2FybmluZzogJ3cnO1xuICAgIGVycm9yOiAnZSc7XG4gICAgZmF0YWw6ICdmJztcbiAgfVxuXG4gIGV4cG9ydCB0eXBlIFNldmVyaXR5ID0ga2V5b2YgU2V2ZXJpdHlUeXBlTWFwO1xuXG4gIGV4cG9ydCB0eXBlIFByb3ZpZGVyID0gJ25vbmUnfCdjb25zb2xlJztcblxuICAvKipcbiAgICogTG9nZ2luZyBjb25maWcgdGhhdCB1c2VkIHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yIG9mIGxvZ2dlclxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBDb25maWcge1xuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgdGhlIGxvZ2dpbmcgcHJvdmlkZXIuICdjb25zb2xlJyBieSBkZWZhdWx0XG4gICAgICovXG4gICAgcHJvdmlkZXI/OiBQcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHRoZSBtaW5pbWFsIGxvZ2dlciBzZXJ2ZXJpdHkuICd3YXJuaW5nJyBieSBkZWZhdWx0XG4gICAgICovXG4gICAgbWluaW1hbFNldmVyaXR5PzogTG9nZ2VyLlNldmVyaXR5O1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gb3V0cHV0IGRhdGUgdGltZSBpbiBsb2cuIHRydWUgYnkgZGVmYXVsdFxuICAgICAqL1xuICAgIGxvZ0RhdGVUaW1lPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIG91dHB1dCBzb3VyY2UgaW5mb3JtYXRpb24gKE5vdCB5ZXQgc3VwcG9ydGVkKS4gZmFsc2UgYnkgZGVmYXVsdFxuICAgICAqL1xuICAgIGxvZ1NvdXJjZUxvY2F0aW9uPzogYm9vbGVhbjtcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgQ2F0ZWdvcml6ZWRMb2dnZXIge1xuICAgIHZlcmJvc2UoY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgICBpbmZvKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gICAgd2FybmluZyhjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICAgIGVycm9yKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gICAgZmF0YWwoY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZGVjbGFyZVxuZXhwb3J0IGludGVyZmFjZSBMb2dnZXIge1xuICAoY2F0ZWdvcnk6IHN0cmluZyk6IExvZ2dlci5DYXRlZ29yaXplZExvZ2dlcjtcblxuICB2ZXJib3NlKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIHZlcmJvc2UoY2F0ZWdvcnk6IHN0cmluZywgY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgaW5mbyhjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBpbmZvKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIHdhcm5pbmcoY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgd2FybmluZyhjYXRlZ29yeTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBlcnJvcihjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBlcnJvcihjYXRlZ29yeTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBmYXRhbChjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBmYXRhbChjYXRlZ29yeTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgbG9nZ2VyIGNvbmZpZ3VyYXRpb24uXG4gICAqIEBwYXJhbSBjb25maWcgc3BlY2lmeSBhbiBvcHRpb25hbCBkZWZhdWx0IGNvbmZpZ1xuICAgKi9cbiAgcmVzZXQoY29uZmlnPzogTG9nZ2VyLkNvbmZpZyk6IHZvaWQ7XG4gIC8qKlxuICAgKiBTZXQgdGhlIGxvZ2dlcidzIGJlaGF2aW9yIG9uIHRoZSBnaXZlbiBjYXRlZ29yeVxuICAgKiBAcGFyYW0gY2F0ZWdvcnkgc3BlY2lmeSBhIGNhdGVnb3J5IHN0cmluZy4gSWYgJyonIGlzIHNwZWNpZmllZCwgYWxsIHByZXZpb3VzIGNvbmZpZ3VyYXRpb24gd2lsbCBiZSBvdmVyd3JpdHRlbi4gSWZcbiAgICogJycgaXMgc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBiZWhhdmlvciB3aWxsIGJlIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSBjb25maWcgdGhlIGNvbmZpZyBvYmplY3QgdG8gaW5kaWNhdGUgdGhlIGxvZ2dlcidzIGJlaGF2aW9yXG4gICAqL1xuICBzZXQoY2F0ZWdvcnk6IHN0cmluZywgY29uZmlnOiBMb2dnZXIuQ29uZmlnKTogdm9pZDtcblxuICAvKipcbiAgICogU2V0IHRoZSBsb2dnZXIncyBiZWhhdmlvciBmcm9tIG9ydC1jb21tb24gZW52XG4gICAqIEBwYXJhbSBlbnYgdGhlIGVudiB1c2VkIHRvIHNldCBsb2dnZXIuIEN1cnJlbnRseSBvbmx5IHNldHRpbmcgbG9nbGV2ZWwgaXMgc3VwcG9ydGVkIHRocm91Z2ggRW52LlxuICAgKi9cbiAgc2V0V2l0aEVudihlbnY6IEVudik6IHZvaWQ7XG59XG5cbmludGVyZmFjZSBMb2dnZXJQcm92aWRlciB7XG4gIGxvZyhzZXZlcml0eTogTG9nZ2VyLlNldmVyaXR5LCBjb250ZW50OiBzdHJpbmcsIGNhdGVnb3J5Pzogc3RyaW5nKTogdm9pZDtcbn1cbmNsYXNzIE5vT3BMb2dnZXJQcm92aWRlciBpbXBsZW1lbnRzIExvZ2dlclByb3ZpZGVyIHtcbiAgbG9nKF9zZXZlcml0eTogTG9nZ2VyLlNldmVyaXR5LCBfY29udGVudDogc3RyaW5nLCBfY2F0ZWdvcnk/OiBzdHJpbmcpIHtcbiAgICAvLyBkbyBub3RoaW5nXG4gIH1cbn1cbmNsYXNzIENvbnNvbGVMb2dnZXJQcm92aWRlciBpbXBsZW1lbnRzIExvZ2dlclByb3ZpZGVyIHtcbiAgbG9nKHNldmVyaXR5OiBMb2dnZXIuU2V2ZXJpdHksIGNvbnRlbnQ6IHN0cmluZywgY2F0ZWdvcnk/OiBzdHJpbmcpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUubG9nKGAke3RoaXMuY29sb3Ioc2V2ZXJpdHkpfSAke2NhdGVnb3J5ID8gJ1xceDFiWzM1bScgKyBjYXRlZ29yeSArICdcXHgxYlswbSAnIDogJyd9JHtjb250ZW50fWApO1xuICB9XG5cbiAgcHJpdmF0ZSBjb2xvcihzZXZlcml0eTogTG9nZ2VyLlNldmVyaXR5KSB7XG4gICAgc3dpdGNoIChzZXZlcml0eSkge1xuICAgICAgY2FzZSAndmVyYm9zZSc6XG4gICAgICAgIHJldHVybiAnXFx4MWJbMzQ7NDBtdlxceDFiWzBtJztcbiAgICAgIGNhc2UgJ2luZm8nOlxuICAgICAgICByZXR1cm4gJ1xceDFiWzMybWlcXHgxYlswbSc7XG4gICAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgICAgcmV0dXJuICdcXHgxYlszMDs0M213XFx4MWJbMG0nO1xuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICByZXR1cm4gJ1xceDFiWzMxOzQwbWVcXHgxYlswbSc7XG4gICAgICBjYXNlICdmYXRhbCc6XG4gICAgICAgIHJldHVybiAnXFx4MWJbMTAxbWZcXHgxYlswbSc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIHNldmVyaXR5OiAke3NldmVyaXR5fWApO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBTRVZFUklUWV9WQUxVRSA9IHtcbiAgdmVyYm9zZTogMTAwMCxcbiAgaW5mbzogMjAwMCxcbiAgd2FybmluZzogNDAwMCxcbiAgZXJyb3I6IDUwMDAsXG4gIGZhdGFsOiA2MDAwXG59O1xuXG5jb25zdCBMT0dHRVJfUFJPVklERVJfTUFQOiB7cmVhZG9ubHkgW3Byb3ZpZGVyOiBzdHJpbmddOiBSZWFkb25seTxMb2dnZXJQcm92aWRlcj59ID0ge1xuICBbJ25vbmUnXTogbmV3IE5vT3BMb2dnZXJQcm92aWRlcigpLFxuICBbJ2NvbnNvbGUnXTogbmV3IENvbnNvbGVMb2dnZXJQcm92aWRlcigpXG59O1xuY29uc3QgTE9HR0VSX0RFRkFVTFRfQ09ORklHID0ge1xuICBwcm92aWRlcjogJ2NvbnNvbGUnLFxuICBtaW5pbWFsU2V2ZXJpdHk6ICd3YXJuaW5nJyxcbiAgbG9nRGF0ZVRpbWU6IHRydWUsXG4gIGxvZ1NvdXJjZUxvY2F0aW9uOiBmYWxzZVxufTtcbmxldCBMT0dHRVJfQ09ORklHX01BUDpcbiAgICB7W2NhdGVnb3J5OiBzdHJpbmddOiBSZWFkb25seTxSZXF1aXJlZDxMb2dnZXIuQ29uZmlnPj59ID0ge1snJ106IExPR0dFUl9ERUZBVUxUX0NPTkZJRyBhcyBSZXF1aXJlZDxMb2dnZXIuQ29uZmlnPn07XG5cbmZ1bmN0aW9uIGxvZyhjYXRlZ29yeTogc3RyaW5nKTogTG9nZ2VyLkNhdGVnb3JpemVkTG9nZ2VyO1xuZnVuY3Rpb24gbG9nKHNldmVyaXR5OiBMb2dnZXIuU2V2ZXJpdHksIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG5mdW5jdGlvbiBsb2coc2V2ZXJpdHk6IExvZ2dlci5TZXZlcml0eSwgY2F0ZWdvcnk6IHN0cmluZywgY29udGVudDogc3RyaW5nKTogdm9pZDtcbmZ1bmN0aW9uIGxvZyhzZXZlcml0eTogTG9nZ2VyLlNldmVyaXR5LCBhcmcxOiBzdHJpbmcsIGFyZzI/OiBzdHJpbmcpOiB2b2lkO1xuZnVuY3Rpb24gbG9nKFxuICAgIGFyZzA6IHN0cmluZ3xMb2dnZXIuU2V2ZXJpdHksIGFyZzE/OiBzdHJpbmcsIGFyZzI/OiBzdHJpbmd8bnVtYmVyLCBhcmczPzogbnVtYmVyKTogTG9nZ2VyLkNhdGVnb3JpemVkTG9nZ2VyfHZvaWQge1xuICBpZiAoYXJnMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gbG9nKGNhdGVnb3J5OiBzdHJpbmcpOiBMb2dnZXIuQ2F0ZWdvcml6ZWRMb2dnZXI7XG4gICAgcmV0dXJuIGNyZWF0ZUNhdGVnb3JpemVkTG9nZ2VyKGFyZzApO1xuICB9IGVsc2UgaWYgKGFyZzIgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGxvZyhzZXZlcml0eSwgY29udGVudCk7XG4gICAgbG9nSW50ZXJuYWwoYXJnMCBhcyBMb2dnZXIuU2V2ZXJpdHksIGFyZzEsIDEpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcyID09PSAnbnVtYmVyJyAmJiBhcmczID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBsb2coc2V2ZXJpdHksIGNvbnRlbnQsIHN0YWNrKVxuICAgIGxvZ0ludGVybmFsKGFyZzAgYXMgTG9nZ2VyLlNldmVyaXR5LCBhcmcxLCBhcmcyKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMiA9PT0gJ3N0cmluZycgJiYgYXJnMyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gbG9nKHNldmVyaXR5LCBjYXRlZ29yeSwgY29udGVudClcbiAgICBsb2dJbnRlcm5hbChhcmcwIGFzIExvZ2dlci5TZXZlcml0eSwgYXJnMiwgMSwgYXJnMSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBhcmczID09PSAnbnVtYmVyJykge1xuICAgIC8vIGxvZyhzZXZlcml0eSwgY2F0ZWdvcnksIGNvbnRlbnQsIHN0YWNrKVxuICAgIGxvZ0ludGVybmFsKGFyZzAgYXMgTG9nZ2VyLlNldmVyaXR5LCBhcmcyLCBhcmczLCBhcmcxKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnB1dCBpcyB2YWxpZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhdGVnb3JpemVkTG9nZ2VyKGNhdGVnb3J5OiBzdHJpbmcpOiBMb2dnZXIuQ2F0ZWdvcml6ZWRMb2dnZXIge1xuICByZXR1cm4ge1xuICAgIHZlcmJvc2U6IGxvZy52ZXJib3NlLmJpbmQobnVsbCwgY2F0ZWdvcnkpLFxuICAgIGluZm86IGxvZy5pbmZvLmJpbmQobnVsbCwgY2F0ZWdvcnkpLFxuICAgIHdhcm5pbmc6IGxvZy53YXJuaW5nLmJpbmQobnVsbCwgY2F0ZWdvcnkpLFxuICAgIGVycm9yOiBsb2cuZXJyb3IuYmluZChudWxsLCBjYXRlZ29yeSksXG4gICAgZmF0YWw6IGxvZy5mYXRhbC5iaW5kKG51bGwsIGNhdGVnb3J5KVxuICB9O1xufVxuXG4vLyBOT1RFOiBhcmd1bWVudCAnY2F0ZWdvcnknIGlzIHB1dCB0aGUgbGFzdCBwYXJhbWV0ZXIgYmVhY2F1c2UgdHlwZXNjcmlwdFxuLy8gZG9lc24ndCBhbGxvdyBvcHRpb25hbCBhcmd1bWVudCBwdXQgaW4gZnJvbnQgb2YgcmVxdWlyZWQgYXJndW1lbnQuIFRoaXNcbi8vIG9yZGVyIGlzIGRpZmZlcmVudCBmcm9tIGEgdXN1YWwgbG9nZ2luZyBBUEkuXG5mdW5jdGlvbiBsb2dJbnRlcm5hbChzZXZlcml0eTogTG9nZ2VyLlNldmVyaXR5LCBjb250ZW50OiBzdHJpbmcsIF9zdGFjazogbnVtYmVyLCBjYXRlZ29yeT86IHN0cmluZykge1xuICBjb25zdCBjb25maWcgPSBMT0dHRVJfQ09ORklHX01BUFtjYXRlZ29yeSB8fCAnJ10gfHwgTE9HR0VSX0NPTkZJR19NQVBbJyddO1xuICBpZiAoU0VWRVJJVFlfVkFMVUVbc2V2ZXJpdHldIDwgU0VWRVJJVFlfVkFMVUVbY29uZmlnLm1pbmltYWxTZXZlcml0eV0pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY29uZmlnLmxvZ0RhdGVUaW1lKSB7XG4gICAgY29udGVudCA9IGAke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX18JHtjb250ZW50fWA7XG4gIH1cblxuICBpZiAoY29uZmlnLmxvZ1NvdXJjZUxvY2F0aW9uKSB7XG4gICAgLy8gVE9ETzogY2FsY3VsYXRlIHNvdXJjZSBsb2NhdGlvbiBmcm9tICdzdGFjaydcbiAgfVxuXG4gIExPR0dFUl9QUk9WSURFUl9NQVBbY29uZmlnLnByb3ZpZGVyXS5sb2coc2V2ZXJpdHksIGNvbnRlbnQsIGNhdGVnb3J5KTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1uYW1lc3BhY2Vcbm5hbWVzcGFjZSBsb2cge1xuICBleHBvcnQgZnVuY3Rpb24gdmVyYm9zZShjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBleHBvcnQgZnVuY3Rpb24gdmVyYm9zZShjYXRlZ29yeTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBleHBvcnQgZnVuY3Rpb24gdmVyYm9zZShhcmcwOiBzdHJpbmcsIGFyZzE/OiBzdHJpbmcpIHtcbiAgICBsb2coJ3ZlcmJvc2UnLCBhcmcwLCBhcmcxKTtcbiAgfVxuICBleHBvcnQgZnVuY3Rpb24gaW5mbyhjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBleHBvcnQgZnVuY3Rpb24gaW5mbyhjYXRlZ29yeTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBleHBvcnQgZnVuY3Rpb24gaW5mbyhhcmcwOiBzdHJpbmcsIGFyZzE/OiBzdHJpbmcpIHtcbiAgICBsb2coJ2luZm8nLCBhcmcwLCBhcmcxKTtcbiAgfVxuICBleHBvcnQgZnVuY3Rpb24gd2FybmluZyhjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBleHBvcnQgZnVuY3Rpb24gd2FybmluZyhjYXRlZ29yeTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBleHBvcnQgZnVuY3Rpb24gd2FybmluZyhhcmcwOiBzdHJpbmcsIGFyZzE/OiBzdHJpbmcpIHtcbiAgICBsb2coJ3dhcm5pbmcnLCBhcmcwLCBhcmcxKTtcbiAgfVxuICBleHBvcnQgZnVuY3Rpb24gZXJyb3IoY29udGVudDogc3RyaW5nKTogdm9pZDtcbiAgZXhwb3J0IGZ1bmN0aW9uIGVycm9yKGNhdGVnb3J5OiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiBlcnJvcihhcmcwOiBzdHJpbmcsIGFyZzE/OiBzdHJpbmcpIHtcbiAgICBsb2coJ2Vycm9yJywgYXJnMCwgYXJnMSk7XG4gIH1cbiAgZXhwb3J0IGZ1bmN0aW9uIGZhdGFsKGNvbnRlbnQ6IHN0cmluZyk6IHZvaWQ7XG4gIGV4cG9ydCBmdW5jdGlvbiBmYXRhbChjYXRlZ29yeTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOiB2b2lkO1xuICBleHBvcnQgZnVuY3Rpb24gZmF0YWwoYXJnMDogc3RyaW5nLCBhcmcxPzogc3RyaW5nKSB7XG4gICAgbG9nKCdmYXRhbCcsIGFyZzAsIGFyZzEpO1xuICB9XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlc2V0KGNvbmZpZz86IExvZ2dlci5Db25maWcpOiB2b2lkIHtcbiAgICBMT0dHRVJfQ09ORklHX01BUCA9IHt9O1xuICAgIHNldCgnJywgY29uZmlnIHx8IHt9KTtcbiAgfVxuICBleHBvcnQgZnVuY3Rpb24gc2V0KGNhdGVnb3J5OiBzdHJpbmcsIGNvbmZpZzogTG9nZ2VyLkNvbmZpZyk6IHZvaWQge1xuICAgIGlmIChjYXRlZ29yeSA9PT0gJyonKSB7XG4gICAgICByZXNldChjb25maWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcmV2aW91c0NvbmZpZyA9IExPR0dFUl9DT05GSUdfTUFQW2NhdGVnb3J5XSB8fCBMT0dHRVJfREVGQVVMVF9DT05GSUc7XG4gICAgICBMT0dHRVJfQ09ORklHX01BUFtjYXRlZ29yeV0gPSB7XG4gICAgICAgIHByb3ZpZGVyOiBjb25maWcucHJvdmlkZXIgfHwgcHJldmlvdXNDb25maWcucHJvdmlkZXIsXG4gICAgICAgIG1pbmltYWxTZXZlcml0eTogY29uZmlnLm1pbmltYWxTZXZlcml0eSB8fCBwcmV2aW91c0NvbmZpZy5taW5pbWFsU2V2ZXJpdHksXG4gICAgICAgIGxvZ0RhdGVUaW1lOiAoY29uZmlnLmxvZ0RhdGVUaW1lID09PSB1bmRlZmluZWQpID8gcHJldmlvdXNDb25maWcubG9nRGF0ZVRpbWUgOiBjb25maWcubG9nRGF0ZVRpbWUsXG4gICAgICAgIGxvZ1NvdXJjZUxvY2F0aW9uOiAoY29uZmlnLmxvZ1NvdXJjZUxvY2F0aW9uID09PSB1bmRlZmluZWQpID8gcHJldmlvdXNDb25maWcubG9nU291cmNlTG9jYXRpb24gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5sb2dTb3VyY2VMb2NhdGlvblxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiB3ZSB3YW50IHRvIHN1cHBvcnQgd2lsZGNhcmQgb3IgcmVnZXg/XG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gc2V0V2l0aEVudihlbnY6IEVudik6IHZvaWQge1xuICAgIGNvbnN0IGNvbmZpZzogTG9nZ2VyLkNvbmZpZyA9IHt9O1xuICAgIGlmIChlbnYubG9nTGV2ZWwpIHtcbiAgICAgIGNvbmZpZy5taW5pbWFsU2V2ZXJpdHkgPSBlbnYubG9nTGV2ZWwgYXMgTG9nZ2VyLlNldmVyaXR5O1xuICAgIH1cbiAgICBzZXQoJycsIGNvbmZpZyk7XG4gIH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWRlY2xhcmUsIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuZXhwb3J0IGNvbnN0IExvZ2dlcjogTG9nZ2VyID0gbG9nO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgUHJvZmlsZXIge1xuICBleHBvcnQgaW50ZXJmYWNlIENvbmZpZyB7XG4gICAgbWF4TnVtYmVyRXZlbnRzPzogbnVtYmVyO1xuICAgIGZsdXNoQmF0Y2hTaXplPzogbnVtYmVyO1xuICAgIGZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcz86IG51bWJlcjtcbiAgfVxuXG4gIGV4cG9ydCB0eXBlIEV2ZW50Q2F0ZWdvcnkgPSAnc2Vzc2lvbid8J25vZGUnfCdvcCd8J2JhY2tlbmQnO1xuXG4gIGV4cG9ydCBpbnRlcmZhY2UgRXZlbnQge1xuICAgIGVuZCgpOiB2b2lkfFByb21pc2U8dm9pZD47XG4gIH1cbn1cbi8vIFRPRE9cbi8vIGNsYXNzIFdlYkdMRXZlbnQgaW1wbGVtZW50cyBQcm9maWxlci5FdmVudCB7fVxuXG5jbGFzcyBFdmVudCBpbXBsZW1lbnRzIFByb2ZpbGVyLkV2ZW50IHtcbiAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgY2F0ZWdvcnk6IFByb2ZpbGVyLkV2ZW50Q2F0ZWdvcnksIHB1YmxpYyBuYW1lOiBzdHJpbmcsIHB1YmxpYyBzdGFydFRpbWU6IG51bWJlcixcbiAgICAgIHByaXZhdGUgZW5kQ2FsbGJhY2s6IChlOiBFdmVudCkgPT4gdm9pZHxQcm9taXNlPHZvaWQ+LCBwdWJsaWMgdGltZXI/OiBXZWJHTFF1ZXJ5LCBwdWJsaWMgY3R4PzogV2ViR0xDb250ZXh0KSB7fVxuXG4gIGFzeW5jIGVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmRDYWxsYmFjayh0aGlzKTtcbiAgfVxuXG4gIGFzeW5jIGNoZWNrVGltZXIoKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBpZiAodGhpcy5jdHggPT09IHVuZGVmaW5lZCB8fCB0aGlzLnRpbWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gd2ViZ2wgdGltZXIgZm91bmQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHguZW5kVGltZXIoKTtcbiAgICAgIHJldHVybiB0aGlzLmN0eC53YWl0Rm9yUXVlcnlBbmRHZXRUaW1lKHRoaXMudGltZXIpO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBFdmVudFJlY29yZCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHVibGljIGNhdGVnb3J5OiBQcm9maWxlci5FdmVudENhdGVnb3J5LCBwdWJsaWMgbmFtZTogc3RyaW5nLCBwdWJsaWMgc3RhcnRUaW1lOiBudW1iZXIsIHB1YmxpYyBlbmRUaW1lOiBudW1iZXIpIHt9XG59XG5cbmV4cG9ydCBjbGFzcyBQcm9maWxlciB7XG4gIHN0YXRpYyBjcmVhdGUoY29uZmlnPzogUHJvZmlsZXIuQ29uZmlnKTogUHJvZmlsZXIge1xuICAgIGlmIChjb25maWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgdGhpcyhjb25maWcubWF4TnVtYmVyRXZlbnRzLCBjb25maWcuZmx1c2hCYXRjaFNpemUsIGNvbmZpZy5mbHVzaEludGVydmFsSW5NaWxsaXNlY29uZHMpO1xuICB9XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihtYXhOdW1iZXJFdmVudHM/OiBudW1iZXIsIGZsdXNoQmF0Y2hTaXplPzogbnVtYmVyLCBmbHVzaEludGVydmFsSW5NaWxsaXNlY29uZHM/OiBudW1iZXIpIHtcbiAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgdGhpcy5fbWF4TnVtYmVyRXZlbnRzID0gbWF4TnVtYmVyRXZlbnRzID09PSB1bmRlZmluZWQgPyAxMDAwMCA6IG1heE51bWJlckV2ZW50cztcbiAgICB0aGlzLl9mbHVzaEJhdGNoU2l6ZSA9IGZsdXNoQmF0Y2hTaXplID09PSB1bmRlZmluZWQgPyAxMCA6IGZsdXNoQmF0Y2hTaXplO1xuICAgIHRoaXMuX2ZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyA9IGZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcyA9PT0gdW5kZWZpbmVkID8gNTAwMCA6IGZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kcztcbiAgfVxuXG4gIC8vIHN0YXJ0IHByb2ZpbGluZ1xuICBzdGFydCgpIHtcbiAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICB0aGlzLl90aW1pbmdFdmVudHMgPSBbXTtcbiAgICB0aGlzLl9mbHVzaFRpbWUgPSBub3coKTtcbiAgICB0aGlzLl9mbHVzaFBvaW50ZXIgPSAwO1xuICB9XG5cbiAgLy8gc3RvcCBwcm9maWxpbmdcbiAgc3RvcCgpIHtcbiAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgZm9yICg7IHRoaXMuX2ZsdXNoUG9pbnRlciA8IHRoaXMuX3RpbWluZ0V2ZW50cy5sZW5ndGg7IHRoaXMuX2ZsdXNoUG9pbnRlcisrKSB7XG4gICAgICB0aGlzLmxvZ09uZUV2ZW50KHRoaXMuX3RpbWluZ0V2ZW50c1t0aGlzLl9mbHVzaFBvaW50ZXJdKTtcbiAgICB9XG4gIH1cblxuICAvLyBjcmVhdGUgYW4gZXZlbnQgc2NvcGUgZm9yIHRoZSBzcGVjaWZpYyBmdW5jdGlvblxuICBldmVudDxUPihjYXRlZ29yeTogUHJvZmlsZXIuRXZlbnRDYXRlZ29yeSwgbmFtZTogc3RyaW5nLCBmdW5jOiAoKSA9PiBULCBjdHg/OiBXZWJHTENvbnRleHQpOiBUO1xuICBldmVudDxUPihjYXRlZ29yeTogUHJvZmlsZXIuRXZlbnRDYXRlZ29yeSwgbmFtZTogc3RyaW5nLCBmdW5jOiAoKSA9PiBQcm9taXNlPFQ+LCBjdHg/OiBXZWJHTENvbnRleHQpOiBQcm9taXNlPFQ+O1xuXG4gIGV2ZW50PFQ+KGNhdGVnb3J5OiBQcm9maWxlci5FdmVudENhdGVnb3J5LCBuYW1lOiBzdHJpbmcsIGZ1bmM6ICgpID0+IFQgfCBQcm9taXNlPFQ+LCBjdHg/OiBXZWJHTENvbnRleHQpOiBUXG4gICAgICB8UHJvbWlzZTxUPiB7XG4gICAgY29uc3QgZXZlbnQgPSB0aGlzLl9zdGFydGVkID8gdGhpcy5iZWdpbihjYXRlZ29yeSwgbmFtZSwgY3R4KSA6IHVuZGVmaW5lZDtcbiAgICBsZXQgaXNQcm9taXNlID0gZmFsc2U7XG5cbiAgICBjb25zdCByZXMgPSBmdW5jKCk7XG5cbiAgICAvLyB3ZSBjb25zaWRlciBhIHRoZW4tYWJsZSBvYmplY3QgaXMgYSBwcm9taXNlXG4gICAgaWYgKHJlcyAmJiB0eXBlb2YgKHJlcyBhcyBQcm9taXNlPFQ+KS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpc1Byb21pc2UgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPFQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgKHJlcyBhcyBQcm9taXNlPFQ+KVxuICAgICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICAgICAgYXN5bmMgdmFsdWUgPT4geyAgLy8gZnVsZmlsbGVkXG4gICAgICAgICAgICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgZXZlbnQuZW5kKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFzeW5jIHJlYXNvbiA9PiB7ICAvLyByZWplY3RlZFxuICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGV2ZW50LmVuZCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFpc1Byb21pc2UgJiYgZXZlbnQpIHtcbiAgICAgIGNvbnN0IGV2ZW50UmVzID0gZXZlbnQuZW5kKCk7XG4gICAgICBpZiAoZXZlbnRSZXMgJiYgdHlwZW9mIGV2ZW50UmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPFQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAoZXZlbnRSZXMpLnRoZW4oXG4gICAgICAgICAgICAgICgpID0+IHsgIC8vIGZ1bGZpbGxlZFxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgKHJlYXNvbikgPT4geyAgLy8gcmVqZWN0ZWRcbiAgICAgICAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLy8gYmVnaW4gYW4gZXZlbnRcbiAgYmVnaW4oY2F0ZWdvcnk6IFByb2ZpbGVyLkV2ZW50Q2F0ZWdvcnksIG5hbWU6IHN0cmluZywgY3R4PzogV2ViR0xDb250ZXh0KTogRXZlbnQge1xuICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9maWxlciBpcyBub3Qgc3RhcnRlZCB5ZXQnKTtcbiAgICB9XG4gICAgaWYgKGN0eCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBub3coKTtcbiAgICAgIHRoaXMuZmx1c2goc3RhcnRUaW1lKTtcbiAgICAgIHJldHVybiBuZXcgRXZlbnQoY2F0ZWdvcnksIG5hbWUsIHN0YXJ0VGltZSwgZSA9PiB0aGlzLmVuZFN5bmMoZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0aW1lcjogV2ViR0xRdWVyeSA9IGN0eC5iZWdpblRpbWVyKCk7XG4gICAgICByZXR1cm4gbmV3IEV2ZW50KGNhdGVnb3J5LCBuYW1lLCAwLCBhc3luYyBlID0+IHRoaXMuZW5kKGUpLCB0aW1lciwgY3R4KTtcbiAgICB9XG4gIH1cblxuICAvLyBlbmQgdGhlIHNwZWNpZmljIGV2ZW50XG4gIHByaXZhdGUgYXN5bmMgZW5kKGV2ZW50OiBFdmVudCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGVuZFRpbWU6IG51bWJlciA9IGF3YWl0IGV2ZW50LmNoZWNrVGltZXIoKTtcbiAgICBpZiAodGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aCA8IHRoaXMuX21heE51bWJlckV2ZW50cykge1xuICAgICAgdGhpcy5fdGltaW5nRXZlbnRzLnB1c2gobmV3IEV2ZW50UmVjb3JkKGV2ZW50LmNhdGVnb3J5LCBldmVudC5uYW1lLCBldmVudC5zdGFydFRpbWUsIGVuZFRpbWUpKTtcbiAgICAgIHRoaXMuZmx1c2goZW5kVGltZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBlbmRTeW5jKGV2ZW50OiBFdmVudCk6IHZvaWQge1xuICAgIGNvbnN0IGVuZFRpbWU6IG51bWJlciA9IG5vdygpO1xuICAgIGlmICh0aGlzLl90aW1pbmdFdmVudHMubGVuZ3RoIDwgdGhpcy5fbWF4TnVtYmVyRXZlbnRzKSB7XG4gICAgICB0aGlzLl90aW1pbmdFdmVudHMucHVzaChuZXcgRXZlbnRSZWNvcmQoZXZlbnQuY2F0ZWdvcnksIGV2ZW50Lm5hbWUsIGV2ZW50LnN0YXJ0VGltZSwgZW5kVGltZSkpO1xuICAgICAgdGhpcy5mbHVzaChlbmRUaW1lKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGxvZ09uZUV2ZW50KGV2ZW50OiBFdmVudFJlY29yZCkge1xuICAgIExvZ2dlci52ZXJib3NlKFxuICAgICAgICBgUHJvZmlsZXIuJHtldmVudC5jYXRlZ29yeX1gLFxuICAgICAgICBgJHsoZXZlbnQuZW5kVGltZSAtIGV2ZW50LnN0YXJ0VGltZSkudG9GaXhlZCgyKX1tcyBvbiBldmVudCAnJHtldmVudC5uYW1lfScgYXQgJHtldmVudC5lbmRUaW1lLnRvRml4ZWQoMil9YCk7XG4gIH1cblxuICBwcml2YXRlIGZsdXNoKGN1cnJlbnRUaW1lOiBudW1iZXIpIHtcbiAgICBpZiAodGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aCAtIHRoaXMuX2ZsdXNoUG9pbnRlciA+PSB0aGlzLl9mbHVzaEJhdGNoU2l6ZSB8fFxuICAgICAgICBjdXJyZW50VGltZSAtIHRoaXMuX2ZsdXNoVGltZSA+PSB0aGlzLl9mbHVzaEludGVydmFsSW5NaWxsaXNlY29uZHMpIHtcbiAgICAgIC8vIHNob3VsZCBmbHVzaCB3aGVuIGVpdGhlciBiYXRjaCBzaXplIGFjY3VtbGF0ZWQgb3IgaW50ZXJ2YWwgZWxlcHNlZFxuXG4gICAgICBmb3IgKGNvbnN0IHByZXZpb3VzUG9pbnRlciA9IHRoaXMuX2ZsdXNoUG9pbnRlcjsgdGhpcy5fZmx1c2hQb2ludGVyIDwgcHJldmlvdXNQb2ludGVyICsgdGhpcy5fZmx1c2hCYXRjaFNpemUgJiZcbiAgICAgICAgICAgdGhpcy5fZmx1c2hQb2ludGVyIDwgdGhpcy5fdGltaW5nRXZlbnRzLmxlbmd0aDtcbiAgICAgICAgICAgdGhpcy5fZmx1c2hQb2ludGVyKyspIHtcbiAgICAgICAgdGhpcy5sb2dPbmVFdmVudCh0aGlzLl90aW1pbmdFdmVudHNbdGhpcy5fZmx1c2hQb2ludGVyXSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2ZsdXNoVGltZSA9IG5vdygpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBzdGFydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFydGVkO1xuICB9XG4gIHByaXZhdGUgX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBfdGltaW5nRXZlbnRzOiBFdmVudFJlY29yZFtdO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgX21heE51bWJlckV2ZW50czogbnVtYmVyO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgX2ZsdXNoQmF0Y2hTaXplOiBudW1iZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgX2ZsdXNoSW50ZXJ2YWxJbk1pbGxpc2Vjb25kczogbnVtYmVyO1xuXG4gIHByaXZhdGUgX2ZsdXNoVGltZTogbnVtYmVyO1xuICBwcml2YXRlIF9mbHVzaFBvaW50ZXIgPSAwO1xufVxuXG4vKipcbiAqIHJldHVybnMgYSBudW1iZXIgdG8gcmVwcmVzZW50IHRoZSBjdXJyZW50IHRpbWVzdGFtcCBpbiBhIHJlc29sdXRpb24gYXMgaGlnaCBhcyBwb3NzaWJsZS5cbiAqL1xuZXhwb3J0IGNvbnN0IG5vdyA9ICh0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHBlcmZvcm1hbmNlLm5vdykgPyAoKSA9PiBwZXJmb3JtYW5jZS5ub3coKSA6IERhdGUubm93O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0dyYXBofSBmcm9tICcuL2dyYXBoJztcbmltcG9ydCB7T3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbn0gZnJvbSAnLi9vcGVyYXRvcnMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9wU2V0IHtcbiAgZG9tYWluOiBzdHJpbmc7XG4gIHZlcnNpb246IG51bWJlcjtcbn1cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBPcFNldCB7XG4gIC8qKlxuICAgKiBEb21haW4gb2YgYW4gb3BzZXQsIGl0IGNhbiBiZSBhbiBlbXB0eSBzdHJpbmcoZGVmYXVsdCB2YWx1ZSwgcmVwcmVzZW50IGZvciBhaS5vbm54KSwgb3IgJ2FpLm9ubngubWwnXG4gICAqL1xuICB0eXBlIERvbWFpbiA9ICcnfCdhaS5vbm54Lm1sJ3wnY29tLm1pY3Jvc29mdCc7XG4gIC8qKlxuICAgKiBBIHJlc29sdmUgcnVsZSBjb25zaXN0cyBvZiA0IG9yIDUgaXRlbXM6IG9wVHlwZSwgb3BTZXREb21haW4sIHZlcnNpb25TZWxlY3Rvciwgb3BlcmF0b3JJbXBsZW1lbnRhdGlvbiBhbmRcbiAgICogb3BlcmF0b3JJbml0aWFsaXphdGlvbiAob3B0aW9uYWwpXG4gICAqL1xuICB0eXBlIFJlc29sdmVSdWxlID0gW1xuICAgIHN0cmluZywgRG9tYWluLCBzdHJpbmcsIE9wZXJhdG9ySW1wbGVtZW50YXRpb248R3JhcGguTm9kZT5cbiAgXXxbc3RyaW5nLCBEb21haW4sIHN0cmluZywgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjx1bmtub3duPiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbjx1bmtub3duPl07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlT3BlcmF0b3Iobm9kZTogR3JhcGguTm9kZSwgb3BzZXRzOiByZWFkb25seSBPcFNldFtdLCBydWxlczogcmVhZG9ubHkgT3BTZXQuUmVzb2x2ZVJ1bGVbXSkge1xuICBmb3IgKGNvbnN0IHJ1bGUgb2YgcnVsZXMpIHtcbiAgICBjb25zdCBvcFR5cGUgPSBydWxlWzBdO1xuICAgIGNvbnN0IGRvbWFpbiA9IHJ1bGVbMV07XG4gICAgY29uc3QgdmVyc2lvblNlbGVjdG9yID0gcnVsZVsyXTtcbiAgICBjb25zdCBvcEltcGwgPSBydWxlWzNdO1xuICAgIGNvbnN0IG9wSW5pdCA9IHJ1bGVbNF07XG5cbiAgICBpZiAobm9kZS5vcFR5cGUgPT09IG9wVHlwZSkgeyAgLy8gb3BlcmF0b3IgdHlwZSBtYXRjaGVzXG4gICAgICBmb3IgKGNvbnN0IG9wc2V0IG9mIG9wc2V0cykge1xuICAgICAgICAvLyBvcHNldCAnJyBhbmQgJ2FpLm9ubngnIGFyZSBjb25zaWRlcmVkIHRoZSBzYW1lLlxuICAgICAgICBpZiAob3BzZXQuZG9tYWluID09PSBkb21haW4gfHwgKG9wc2V0LmRvbWFpbiA9PT0gJ2FpLm9ubngnICYmIGRvbWFpbiA9PT0gJycpKSB7ICAvLyBvcHNldCBkb21haW4gZm91bmRcbiAgICAgICAgICBpZiAobWF0Y2hTZWxlY3RvcihvcHNldC52ZXJzaW9uLCB2ZXJzaW9uU2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4ge29wSW1wbCwgb3BJbml0fTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKGBjYW5ub3QgcmVzb2x2ZSBvcGVyYXRvciAnJHtub2RlLm9wVHlwZX0nIHdpdGggb3BzZXRzOiAke1xuICAgICAgb3BzZXRzLm1hcChzZXQgPT4gYCR7c2V0LmRvbWFpbiB8fCAnYWkub25ueCd9IHYke3NldC52ZXJzaW9ufWApLmpvaW4oJywgJyl9YCk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoU2VsZWN0b3IodmVyc2lvbjogbnVtYmVyLCBzZWxlY3Rvcjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGlmIChzZWxlY3Rvci5lbmRzV2l0aCgnKycpKSB7XG4gICAgLy8gbWluaW11bSB2ZXJzaW9uIG1hdGNoICgnNysnIGV4cGVjdHMgdmVyc2lvbj49NylcbiAgICBjb25zdCByYW5nZVN0YXJ0ID0gTnVtYmVyLnBhcnNlSW50KHNlbGVjdG9yLnN1YnN0cmluZygwLCBzZWxlY3Rvci5sZW5ndGggLSAxKSwgMTApO1xuICAgIHJldHVybiAhaXNOYU4ocmFuZ2VTdGFydCkgJiYgcmFuZ2VTdGFydCA8PSB2ZXJzaW9uO1xuICB9IGVsc2UgaWYgKHNlbGVjdG9yLnNwbGl0KCctJykubGVuZ3RoID09PSAyKSB7XG4gICAgLy8gcmFuZ2UgbWF0Y2ggKCc2LTgnIGV4cGVjdHMgNjw9dmVyc2lvbjw9OClcbiAgICBjb25zdCBwYWlyID0gc2VsZWN0b3Iuc3BsaXQoJy0nKTtcbiAgICBjb25zdCByYW5nZVN0YXJ0ID0gTnVtYmVyLnBhcnNlSW50KHBhaXJbMF0sIDEwKTtcbiAgICBjb25zdCByYW5nZUVuZCA9IE51bWJlci5wYXJzZUludChwYWlyWzFdLCAxMCk7XG4gICAgcmV0dXJuICFpc05hTihyYW5nZVN0YXJ0KSAmJiAhaXNOYU4ocmFuZ2VFbmQpICYmIHJhbmdlU3RhcnQgPD0gdmVyc2lvbiAmJiB2ZXJzaW9uIDw9IHJhbmdlRW5kO1xuICB9IGVsc2Uge1xuICAgIC8vIGV4YWN0IG1hdGNoICgnNycgZXhwZWN0cyB2ZXJzaW9uPT09NylcbiAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KHNlbGVjdG9yLCAxMCkgPT09IHZlcnNpb247XG4gIH1cbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcclxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxudmFyIEd1aWQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBHdWlkKGd1aWQpIHtcclxuICAgICAgICBpZiAoIWd1aWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXJndW1lbnQ7IGB2YWx1ZWAgaGFzIG5vIHZhbHVlLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IEd1aWQuRU1QVFk7XHJcbiAgICAgICAgaWYgKGd1aWQgJiYgR3VpZC5pc0d1aWQoZ3VpZCkpIHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGd1aWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgR3VpZC5pc0d1aWQgPSBmdW5jdGlvbiAoZ3VpZCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IGd1aWQudG9TdHJpbmcoKTtcclxuICAgICAgICByZXR1cm4gZ3VpZCAmJiAoZ3VpZCBpbnN0YW5jZW9mIEd1aWQgfHwgR3VpZC52YWxpZGF0b3IudGVzdCh2YWx1ZSkpO1xyXG4gICAgfTtcclxuICAgIEd1aWQuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgR3VpZChbR3VpZC5nZW4oMiksIEd1aWQuZ2VuKDEpLCBHdWlkLmdlbigxKSwgR3VpZC5nZW4oMSksIEd1aWQuZ2VuKDMpXS5qb2luKFwiLVwiKSk7XHJcbiAgICB9O1xyXG4gICAgR3VpZC5jcmVhdGVFbXB0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEd1aWQoXCJlbXB0eWd1aWRcIik7XHJcbiAgICB9O1xyXG4gICAgR3VpZC5wYXJzZSA9IGZ1bmN0aW9uIChndWlkKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHdWlkKGd1aWQpO1xyXG4gICAgfTtcclxuICAgIEd1aWQucmF3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBbR3VpZC5nZW4oMiksIEd1aWQuZ2VuKDEpLCBHdWlkLmdlbigxKSwgR3VpZC5nZW4oMSksIEd1aWQuZ2VuKDMpXS5qb2luKFwiLVwiKTtcclxuICAgIH07XHJcbiAgICBHdWlkLmdlbiA9IGZ1bmN0aW9uIChjb3VudCkge1xyXG4gICAgICAgIHZhciBvdXQgPSBcIlwiO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYml0d2lzZVxyXG4gICAgICAgICAgICBvdXQgKz0gKCgoMSArIE1hdGgucmFuZG9tKCkpICogMHgxMDAwMCkgfCAwKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfTtcclxuICAgIEd1aWQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICAgIC8vIENvbXBhcmluZyBzdHJpbmcgYHZhbHVlYCBhZ2FpbnN0IHByb3ZpZGVkIGBndWlkYCB3aWxsIGF1dG8tY2FsbFxyXG4gICAgICAgIC8vIHRvU3RyaW5nIG9uIGBndWlkYCBmb3IgY29tcGFyaXNvblxyXG4gICAgICAgIHJldHVybiBHdWlkLmlzR3VpZChvdGhlcikgJiYgdGhpcy52YWx1ZSA9PT0gb3RoZXIudG9TdHJpbmcoKTtcclxuICAgIH07XHJcbiAgICBHdWlkLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSBHdWlkLkVNUFRZO1xyXG4gICAgfTtcclxuICAgIEd1aWQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG4gICAgfTtcclxuICAgIEd1aWQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgR3VpZC52YWxpZGF0b3IgPSBuZXcgUmVnRXhwKFwiXlthLXowLTldezh9LVthLXowLTldezR9LVthLXowLTldezR9LVthLXowLTldezR9LVthLXowLTldezEyfSRcIiwgXCJpXCIpO1xyXG4gICAgR3VpZC5FTVBUWSA9IFwiMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwXCI7XHJcbiAgICByZXR1cm4gR3VpZDtcclxufSgpKTtcclxuZXhwb3J0cy5HdWlkID0gR3VpZDtcclxuIiwgIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDA5IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9yc1xuICogQ29weXJpZ2h0IDIwMjAgRGFuaWVsIFdpcnR6IC8gVGhlIGxvbmcuanMgQXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG4vLyBXZWJBc3NlbWJseSBvcHRpbWl6YXRpb25zIHRvIGRvIG5hdGl2ZSBpNjQgbXVsdGlwbGljYXRpb24gYW5kIGRpdmlkZVxudmFyIHdhc20gPSBudWxsO1xudHJ5IHtcbiAgd2FzbSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKG5ldyBVaW50OEFycmF5KFtcbiAgICAwLCA5NywgMTE1LCAxMDksIDEsIDAsIDAsIDAsIDEsIDEzLCAyLCA5NiwgMCwgMSwgMTI3LCA5NiwgNCwgMTI3LCAxMjcsIDEyNywgMTI3LCAxLCAxMjcsIDMsIDcsIDYsIDAsIDEsIDEsIDEsIDEsIDEsIDYsIDYsIDEsIDEyNywgMSwgNjUsIDAsIDExLCA3LCA1MCwgNiwgMywgMTA5LCAxMTcsIDEwOCwgMCwgMSwgNSwgMTAwLCAxMDUsIDExOCwgOTUsIDExNSwgMCwgMiwgNSwgMTAwLCAxMDUsIDExOCwgOTUsIDExNywgMCwgMywgNSwgMTE0LCAxMDEsIDEwOSwgOTUsIDExNSwgMCwgNCwgNSwgMTE0LCAxMDEsIDEwOSwgOTUsIDExNywgMCwgNSwgOCwgMTAzLCAxMDEsIDExNiwgOTUsIDEwNCwgMTA1LCAxMDMsIDEwNCwgMCwgMCwgMTAsIDE5MSwgMSwgNiwgNCwgMCwgMzUsIDAsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjYsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyNywgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI4LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjksIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEzMCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMVxuICBdKSksIHt9KS5leHBvcnRzO1xufSBjYXRjaCAoZSkge1xuICAvLyBubyB3YXNtIHN1cHBvcnQgOihcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgNjQgYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciwgZ2l2ZW4gaXRzIGxvdyBhbmQgaGlnaCAzMiBiaXQgdmFsdWVzIGFzICpzaWduZWQqIGludGVnZXJzLlxuICogIFNlZSB0aGUgZnJvbSogZnVuY3Rpb25zIGJlbG93IGZvciBtb3JlIGNvbnZlbmllbnQgd2F5cyBvZiBjb25zdHJ1Y3RpbmcgTG9uZ3MuXG4gKiBAZXhwb3J0cyBMb25nXG4gKiBAY2xhc3MgQSBMb25nIGNsYXNzIGZvciByZXByZXNlbnRpbmcgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyIHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IGxvdyBUaGUgbG93IChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoIFRoZSBoaWdoIChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBMb25nKGxvdywgaGlnaCwgdW5zaWduZWQpIHtcblxuICAvKipcbiAgICogVGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5sb3cgPSBsb3cgfCAwO1xuXG4gIC8qKlxuICAgKiBUaGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5oaWdoID0gaGlnaCB8IDA7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkO1xufVxuXG4vLyBUaGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYSBsb25nIGlzIHRoZSB0d28gZ2l2ZW4gc2lnbmVkLCAzMi1iaXQgdmFsdWVzLlxuLy8gV2UgdXNlIDMyLWJpdCBwaWVjZXMgYmVjYXVzZSB0aGVzZSBhcmUgdGhlIHNpemUgb2YgaW50ZWdlcnMgb24gd2hpY2hcbi8vIEphdmFzY3JpcHQgcGVyZm9ybXMgYml0LW9wZXJhdGlvbnMuICBGb3Igb3BlcmF0aW9ucyBsaWtlIGFkZGl0aW9uIGFuZFxuLy8gbXVsdGlwbGljYXRpb24sIHdlIHNwbGl0IGVhY2ggbnVtYmVyIGludG8gMTYgYml0IHBpZWNlcywgd2hpY2ggY2FuIGVhc2lseSBiZVxuLy8gbXVsdGlwbGllZCB3aXRoaW4gSmF2YXNjcmlwdCdzIGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIHdpdGhvdXQgb3ZlcmZsb3dcbi8vIG9yIGNoYW5nZSBpbiBzaWduLlxuLy9cbi8vIEluIHRoZSBhbGdvcml0aG1zIGJlbG93LCB3ZSBmcmVxdWVudGx5IHJlZHVjZSB0aGUgbmVnYXRpdmUgY2FzZSB0byB0aGVcbi8vIHBvc2l0aXZlIGNhc2UgYnkgbmVnYXRpbmcgdGhlIGlucHV0KHMpIGFuZCB0aGVuIHBvc3QtcHJvY2Vzc2luZyB0aGUgcmVzdWx0LlxuLy8gTm90ZSB0aGF0IHdlIG11c3QgQUxXQVlTIGNoZWNrIHNwZWNpYWxseSB3aGV0aGVyIHRob3NlIHZhbHVlcyBhcmUgTUlOX1ZBTFVFXG4vLyAoLTJeNjMpIGJlY2F1c2UgLU1JTl9WQUxVRSA9PSBNSU5fVkFMVUUgKHNpbmNlIDJeNjMgY2Fubm90IGJlIHJlcHJlc2VudGVkIGFzXG4vLyBhIHBvc2l0aXZlIG51bWJlciwgaXQgb3ZlcmZsb3dzIGJhY2sgaW50byBhIG5lZ2F0aXZlKS4gIE5vdCBoYW5kbGluZyB0aGlzXG4vLyBjYXNlIHdvdWxkIG9mdGVuIHJlc3VsdCBpbiBpbmZpbml0ZSByZWN1cnNpb24uXG4vL1xuLy8gQ29tbW9uIGNvbnN0YW50IHZhbHVlcyBaRVJPLCBPTkUsIE5FR19PTkUsIGV0Yy4gYXJlIGRlZmluZWQgYmVsb3cgdGhlIGZyb20qXG4vLyBtZXRob2RzIG9uIHdoaWNoIHRoZXkgZGVwZW5kLlxuXG4vKipcbiAqIEFuIGluZGljYXRvciB1c2VkIHRvIHJlbGlhYmx5IGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBMb25nIG9yIG5vdC5cbiAqIEB0eXBlIHtib29sZWFufVxuICogQGNvbnN0XG4gKiBAcHJpdmF0ZVxuICovXG5Mb25nLnByb3RvdHlwZS5fX2lzTG9uZ19fO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTG9uZy5wcm90b3R5cGUsIFwiX19pc0xvbmdfX1wiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBpbm5lclxuICovXG5mdW5jdGlvbiBpc0xvbmcob2JqKSB7XG4gIHJldHVybiAob2JqICYmIG9ialtcIl9faXNMb25nX19cIl0pID09PSB0cnVlO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHsqfSB2YWx1ZSBudW1iZXJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKiBAaW5uZXJcbiAqL1xuZnVuY3Rpb24gY3R6MzIodmFsdWUpIHtcbiAgdmFyIGMgPSBNYXRoLmNsejMyKHZhbHVlICYgLXZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlID8gMzEgLSBjIDogYztcbn1cblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBpcyBhIExvbmcuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmcuaXNMb25nID0gaXNMb25nO1xuXG4vKipcbiAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIGludGVnZXIgdmFsdWVzLlxuICogQHR5cGUgeyFPYmplY3R9XG4gKiBAaW5uZXJcbiAqL1xudmFyIElOVF9DQUNIRSA9IHt9O1xuXG4vKipcbiAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLlxuICogQHR5cGUgeyFPYmplY3R9XG4gKiBAaW5uZXJcbiAqL1xudmFyIFVJTlRfQ0FDSEUgPSB7fTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXG4gKiBAcmV0dXJucyB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xuZnVuY3Rpb24gZnJvbUludCh2YWx1ZSwgdW5zaWduZWQpIHtcbiAgdmFyIG9iaiwgY2FjaGVkT2JqLCBjYWNoZTtcbiAgaWYgKHVuc2lnbmVkKSB7XG4gICAgdmFsdWUgPj4+PSAwO1xuICAgIGlmIChjYWNoZSA9ICgwIDw9IHZhbHVlICYmIHZhbHVlIDwgMjU2KSkge1xuICAgICAgY2FjaGVkT2JqID0gVUlOVF9DQUNIRVt2YWx1ZV07XG4gICAgICBpZiAoY2FjaGVkT2JqKVxuICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xuICAgIH1cbiAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgMCwgdHJ1ZSk7XG4gICAgaWYgKGNhY2hlKVxuICAgICAgVUlOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XG4gICAgcmV0dXJuIG9iajtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSB8PSAwO1xuICAgIGlmIChjYWNoZSA9ICgtMTI4IDw9IHZhbHVlICYmIHZhbHVlIDwgMTI4KSkge1xuICAgICAgY2FjaGVkT2JqID0gSU5UX0NBQ0hFW3ZhbHVlXTtcbiAgICAgIGlmIChjYWNoZWRPYmopXG4gICAgICAgIHJldHVybiBjYWNoZWRPYmo7XG4gICAgfVxuICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCB2YWx1ZSA8IDAgPyAtMSA6IDAsIGZhbHNlKTtcbiAgICBpZiAoY2FjaGUpXG4gICAgICBJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xuICAgIHJldHVybiBvYmo7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIDMyIGJpdCBpbnRlZ2VyIHZhbHVlLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIDMyIGJpdCBpbnRlZ2VyIGluIHF1ZXN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAqL1xuTG9uZy5mcm9tSW50ID0gZnJvbUludDtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXG4gKiBAcmV0dXJucyB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xuZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSwgdW5zaWduZWQpIHtcbiAgaWYgKGlzTmFOKHZhbHVlKSlcbiAgICByZXR1cm4gdW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XG4gIGlmICh1bnNpZ25lZCkge1xuICAgIGlmICh2YWx1ZSA8IDApXG4gICAgICByZXR1cm4gVVpFUk87XG4gICAgaWYgKHZhbHVlID49IFRXT19QV1JfNjRfREJMKVxuICAgICAgcmV0dXJuIE1BWF9VTlNJR05FRF9WQUxVRTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsdWUgPD0gLVRXT19QV1JfNjNfREJMKVxuICAgICAgcmV0dXJuIE1JTl9WQUxVRTtcbiAgICBpZiAodmFsdWUgKyAxID49IFRXT19QV1JfNjNfREJMKVxuICAgICAgcmV0dXJuIE1BWF9WQUxVRTtcbiAgfVxuICBpZiAodmFsdWUgPCAwKVxuICAgIHJldHVybiBmcm9tTnVtYmVyKC12YWx1ZSwgdW5zaWduZWQpLm5lZygpO1xuICByZXR1cm4gZnJvbUJpdHMoKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwpIHwgMCwgKHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwpIHwgMCwgdW5zaWduZWQpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gdmFsdWUsIHByb3ZpZGVkIHRoYXQgaXQgaXMgYSBmaW5pdGUgbnVtYmVyLiBPdGhlcndpc2UsIHplcm8gaXMgcmV0dXJuZWQuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIGluIHF1ZXN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAqL1xuTG9uZy5mcm9tTnVtYmVyID0gZnJvbU51bWJlcjtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbG93Qml0c1xuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxuICogQHJldHVybnMgeyFMb25nfVxuICogQGlubmVyXG4gKi9cbmZ1bmN0aW9uIGZyb21CaXRzKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCkge1xuICByZXR1cm4gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIDY0IGJpdCBpbnRlZ2VyIHRoYXQgY29tZXMgYnkgY29uY2F0ZW5hdGluZyB0aGUgZ2l2ZW4gbG93IGFuZCBoaWdoIGJpdHMuIEVhY2ggaXNcbiAqICBhc3N1bWVkIHRvIHVzZSAzMiBiaXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gbG93Qml0cyBUaGUgbG93IDMyIGJpdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0cyBUaGUgaGlnaCAzMiBiaXRzXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAqL1xuTG9uZy5mcm9tQml0cyA9IGZyb21CaXRzO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGJhc2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBvbmVudFxuICogQHJldHVybnMge251bWJlcn1cbiAqIEBpbm5lclxuICovXG52YXIgcG93X2RibCA9IE1hdGgucG93OyAvLyBVc2VkIDQgdGltZXMgKDQqOCB0byAxNSs0KVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkXG4gKiBAcGFyYW0ge251bWJlcj19IHJhZGl4XG4gKiBAcmV0dXJucyB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xuZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIsIHVuc2lnbmVkLCByYWRpeCkge1xuICBpZiAoc3RyLmxlbmd0aCA9PT0gMClcbiAgICB0aHJvdyBFcnJvcignZW1wdHkgc3RyaW5nJyk7XG4gIGlmICh0eXBlb2YgdW5zaWduZWQgPT09ICdudW1iZXInKSB7XG4gICAgLy8gRm9yIGdvb2cubWF0aC5sb25nIGNvbXBhdGliaWxpdHlcbiAgICByYWRpeCA9IHVuc2lnbmVkO1xuICAgIHVuc2lnbmVkID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdW5zaWduZWQgPSAhIXVuc2lnbmVkO1xuICB9XG4gIGlmIChzdHIgPT09IFwiTmFOXCIgfHwgc3RyID09PSBcIkluZmluaXR5XCIgfHwgc3RyID09PSBcIitJbmZpbml0eVwiIHx8IHN0ciA9PT0gXCItSW5maW5pdHlcIilcbiAgICByZXR1cm4gdW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XG4gIHJhZGl4ID0gcmFkaXggfHwgMTA7XG4gIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeClcbiAgICB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xuXG4gIHZhciBwO1xuICBpZiAoKHAgPSBzdHIuaW5kZXhPZignLScpKSA+IDApXG4gICAgdGhyb3cgRXJyb3IoJ2ludGVyaW9yIGh5cGhlbicpO1xuICBlbHNlIGlmIChwID09PSAwKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcoc3RyLnN1YnN0cmluZygxKSwgdW5zaWduZWQsIHJhZGl4KS5uZWcoKTtcbiAgfVxuXG4gIC8vIERvIHNldmVyYWwgKDgpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cbiAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXG4gIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDgpKTtcblxuICB2YXIgcmVzdWx0ID0gWkVSTztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDgpIHtcbiAgICB2YXIgc2l6ZSA9IE1hdGgubWluKDgsIHN0ci5sZW5ndGggLSBpKSxcbiAgICAgIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTtcbiAgICBpZiAoc2l6ZSA8IDgpIHtcbiAgICAgIHZhciBwb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgc2l6ZSkpO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChwb3dlcikuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChyYWRpeFRvUG93ZXIpO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7XG4gICAgfVxuICB9XG4gIHJlc3VsdC51bnNpZ25lZCA9IHVuc2lnbmVkO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBzdHJpbmcsIHdyaXR0ZW4gdXNpbmcgdGhlIHNwZWNpZmllZCByYWRpeC5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgTG9uZ1xuICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBUaGUgcmFkaXggaW4gd2hpY2ggdGhlIHRleHQgaXMgd3JpdHRlbiAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXG4gKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAqL1xuTG9uZy5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ3whe2xvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIsIHVuc2lnbmVkOiBib29sZWFufX0gdmFsXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxuICogQHJldHVybnMgeyFMb25nfVxuICogQGlubmVyXG4gKi9cbmZ1bmN0aW9uIGZyb21WYWx1ZSh2YWwsIHVuc2lnbmVkKSB7XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJylcbiAgICByZXR1cm4gZnJvbU51bWJlcih2YWwsIHVuc2lnbmVkKTtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKVxuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbCwgdW5zaWduZWQpO1xuICAvLyBUaHJvd3MgZm9yIG5vbi1vYmplY3RzLCBjb252ZXJ0cyBub24taW5zdGFuY2VvZiBMb25nOlxuICByZXR1cm4gZnJvbUJpdHModmFsLmxvdywgdmFsLmhpZ2gsIHR5cGVvZiB1bnNpZ25lZCA9PT0gJ2Jvb2xlYW4nID8gdW5zaWduZWQgOiB2YWwudW5zaWduZWQpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBzcGVjaWZpZWQgdmFsdWUgdG8gYSBMb25nIHVzaW5nIHRoZSBhcHByb3ByaWF0ZSBmcm9tKiBmdW5jdGlvbiBmb3IgaXRzIHR5cGUuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ3whe2xvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIsIHVuc2lnbmVkOiBib29sZWFufX0gdmFsIFZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gKiBAcmV0dXJucyB7IUxvbmd9XG4gKi9cbkxvbmcuZnJvbVZhbHVlID0gZnJvbVZhbHVlO1xuXG4vLyBOT1RFOiB0aGUgY29tcGlsZXIgc2hvdWxkIGlubGluZSB0aGVzZSBjb25zdGFudCB2YWx1ZXMgYmVsb3cgYW5kIHRoZW4gcmVtb3ZlIHRoZXNlIHZhcmlhYmxlcywgc28gdGhlcmUgc2hvdWxkIGJlXG4vLyBubyBydW50aW1lIHBlbmFsdHkgZm9yIHRoZXNlLlxuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqIEBpbm5lclxuICovXG52YXIgVFdPX1BXUl8xNl9EQkwgPSAxIDw8IDE2O1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqIEBpbm5lclxuICovXG52YXIgVFdPX1BXUl8yNF9EQkwgPSAxIDw8IDI0O1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqIEBpbm5lclxuICovXG52YXIgVFdPX1BXUl8zMl9EQkwgPSBUV09fUFdSXzE2X0RCTCAqIFRXT19QV1JfMTZfREJMO1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqIEBpbm5lclxuICovXG52YXIgVFdPX1BXUl82NF9EQkwgPSBUV09fUFdSXzMyX0RCTCAqIFRXT19QV1JfMzJfREJMO1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqIEBpbm5lclxuICovXG52YXIgVFdPX1BXUl82M19EQkwgPSBUV09fUFdSXzY0X0RCTCAvIDI7XG5cbi8qKlxuICogQHR5cGUgeyFMb25nfVxuICogQGNvbnN0XG4gKiBAaW5uZXJcbiAqL1xudmFyIFRXT19QV1JfMjQgPSBmcm9tSW50KFRXT19QV1JfMjRfREJMKTtcblxuLyoqXG4gKiBAdHlwZSB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xudmFyIFpFUk8gPSBmcm9tSW50KDApO1xuXG4vKipcbiAqIFNpZ25lZCB6ZXJvLlxuICogQHR5cGUgeyFMb25nfVxuICovXG5Mb25nLlpFUk8gPSBaRVJPO1xuXG4vKipcbiAqIEB0eXBlIHshTG9uZ31cbiAqIEBpbm5lclxuICovXG52YXIgVVpFUk8gPSBmcm9tSW50KDAsIHRydWUpO1xuXG4vKipcbiAqIFVuc2lnbmVkIHplcm8uXG4gKiBAdHlwZSB7IUxvbmd9XG4gKi9cbkxvbmcuVVpFUk8gPSBVWkVSTztcblxuLyoqXG4gKiBAdHlwZSB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xudmFyIE9ORSA9IGZyb21JbnQoMSk7XG5cbi8qKlxuICogU2lnbmVkIG9uZS5cbiAqIEB0eXBlIHshTG9uZ31cbiAqL1xuTG9uZy5PTkUgPSBPTkU7XG5cbi8qKlxuICogQHR5cGUgeyFMb25nfVxuICogQGlubmVyXG4gKi9cbnZhciBVT05FID0gZnJvbUludCgxLCB0cnVlKTtcblxuLyoqXG4gKiBVbnNpZ25lZCBvbmUuXG4gKiBAdHlwZSB7IUxvbmd9XG4gKi9cbkxvbmcuVU9ORSA9IFVPTkU7XG5cbi8qKlxuICogQHR5cGUgeyFMb25nfVxuICogQGlubmVyXG4gKi9cbnZhciBORUdfT05FID0gZnJvbUludCgtMSk7XG5cbi8qKlxuICogU2lnbmVkIG5lZ2F0aXZlIG9uZS5cbiAqIEB0eXBlIHshTG9uZ31cbiAqL1xuTG9uZy5ORUdfT05FID0gTkVHX09ORTtcblxuLyoqXG4gKiBAdHlwZSB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xudmFyIE1BWF9WQUxVRSA9IGZyb21CaXRzKDB4RkZGRkZGRkYgfCAwLCAweDdGRkZGRkZGIHwgMCwgZmFsc2UpO1xuXG4vKipcbiAqIE1heGltdW0gc2lnbmVkIHZhbHVlLlxuICogQHR5cGUgeyFMb25nfVxuICovXG5Mb25nLk1BWF9WQUxVRSA9IE1BWF9WQUxVRTtcblxuLyoqXG4gKiBAdHlwZSB7IUxvbmd9XG4gKiBAaW5uZXJcbiAqL1xudmFyIE1BWF9VTlNJR05FRF9WQUxVRSA9IGZyb21CaXRzKDB4RkZGRkZGRkYgfCAwLCAweEZGRkZGRkZGIHwgMCwgdHJ1ZSk7XG5cbi8qKlxuICogTWF4aW11bSB1bnNpZ25lZCB2YWx1ZS5cbiAqIEB0eXBlIHshTG9uZ31cbiAqL1xuTG9uZy5NQVhfVU5TSUdORURfVkFMVUUgPSBNQVhfVU5TSUdORURfVkFMVUU7XG5cbi8qKlxuICogQHR5cGUgeyFMb25nfVxuICogQGlubmVyXG4gKi9cbnZhciBNSU5fVkFMVUUgPSBmcm9tQml0cygwLCAweDgwMDAwMDAwIHwgMCwgZmFsc2UpO1xuXG4vKipcbiAqIE1pbmltdW0gc2lnbmVkIHZhbHVlLlxuICogQHR5cGUgeyFMb25nfVxuICovXG5Mb25nLk1JTl9WQUxVRSA9IE1JTl9WQUxVRTtcblxuLyoqXG4gKiBAYWxpYXMgTG9uZy5wcm90b3R5cGVcbiAqIEBpbm5lclxuICovXG52YXIgTG9uZ1Byb3RvdHlwZSA9IExvbmcucHJvdG90eXBlO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgMzIgYml0IGludGVnZXIsIGFzc3VtaW5nIGl0IGlzIGEgMzIgYml0IGludGVnZXIuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5Mb25nUHJvdG90eXBlLnRvSW50ID0gZnVuY3Rpb24gdG9JbnQoKSB7XG4gIHJldHVybiB0aGlzLnVuc2lnbmVkID8gdGhpcy5sb3cgPj4+IDAgOiB0aGlzLmxvdztcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhlIExvbmcgdG8gYSB0aGUgbmVhcmVzdCBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHZhbHVlIChkb3VibGUsIDUzIGJpdCBtYW50aXNzYSkuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5Mb25nUHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIoKSB7XG4gIGlmICh0aGlzLnVuc2lnbmVkKVxuICAgIHJldHVybiAoKHRoaXMuaGlnaCA+Pj4gMCkgKiBUV09fUFdSXzMyX0RCTCkgKyAodGhpcy5sb3cgPj4+IDApO1xuICByZXR1cm4gdGhpcy5oaWdoICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHN0cmluZyB3cml0dGVuIGluIHRoZSBzcGVjaWZpZWQgcmFkaXguXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0ge251bWJlcj19IHJhZGl4IFJhZGl4ICgyLTM2KSwgZGVmYXVsdHMgdG8gMTBcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKiBAb3ZlcnJpZGVcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGByYWRpeGAgaXMgb3V0IG9mIHJhbmdlXG4gKi9cbkxvbmdQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhyYWRpeCkge1xuICByYWRpeCA9IHJhZGl4IHx8IDEwO1xuICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXG4gICAgdGhyb3cgUmFuZ2VFcnJvcigncmFkaXgnKTtcbiAgaWYgKHRoaXMuaXNaZXJvKCkpXG4gICAgcmV0dXJuICcwJztcbiAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7IC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxuICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hhbmdlIHRoZSBMb25nIHZhbHVlIGJlZm9yZSBpdCBjYW4gYmUgbmVnYXRlZCwgc28gd2UgcmVtb3ZlXG4gICAgICAvLyB0aGUgYm90dG9tLW1vc3QgZGlnaXQgaW4gdGhpcyBiYXNlIGFuZCB0aGVuIHJlY3Vyc2UgdG8gZG8gdGhlIHJlc3QuXG4gICAgICB2YXIgcmFkaXhMb25nID0gZnJvbU51bWJlcihyYWRpeCksXG4gICAgICAgIGRpdiA9IHRoaXMuZGl2KHJhZGl4TG9uZyksXG4gICAgICAgIHJlbTEgPSBkaXYubXVsKHJhZGl4TG9uZykuc3ViKHRoaXMpO1xuICAgICAgcmV0dXJuIGRpdi50b1N0cmluZyhyYWRpeCkgKyByZW0xLnRvSW50KCkudG9TdHJpbmcocmFkaXgpO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuICctJyArIHRoaXMubmVnKCkudG9TdHJpbmcocmFkaXgpO1xuICB9XG5cbiAgLy8gRG8gc2V2ZXJhbCAoNikgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xuICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cbiAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgNiksIHRoaXMudW5zaWduZWQpLFxuICAgIHJlbSA9IHRoaXM7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgcmVtRGl2ID0gcmVtLmRpdihyYWRpeFRvUG93ZXIpLFxuICAgICAgaW50dmFsID0gcmVtLnN1YihyZW1EaXYubXVsKHJhZGl4VG9Qb3dlcikpLnRvSW50KCkgPj4+IDAsXG4gICAgICBkaWdpdHMgPSBpbnR2YWwudG9TdHJpbmcocmFkaXgpO1xuICAgIHJlbSA9IHJlbURpdjtcbiAgICBpZiAocmVtLmlzWmVybygpKVxuICAgICAgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDtcbiAgICBlbHNlIHtcbiAgICAgIHdoaWxlIChkaWdpdHMubGVuZ3RoIDwgNilcbiAgICAgICAgZGlnaXRzID0gJzAnICsgZGlnaXRzO1xuICAgICAgcmVzdWx0ID0gJycgKyBkaWdpdHMgKyByZXN1bHQ7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGhpZ2ggYml0c1xuICovXG5Mb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHMoKSB7XG4gIHJldHVybiB0aGlzLmhpZ2g7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGhpZ2ggMzIgYml0cyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgaGlnaCBiaXRzXG4gKi9cbkxvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldEhpZ2hCaXRzVW5zaWduZWQoKSB7XG4gIHJldHVybiB0aGlzLmhpZ2ggPj4+IDA7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgbG93IGJpdHNcbiAqL1xuTG9uZ1Byb3RvdHlwZS5nZXRMb3dCaXRzID0gZnVuY3Rpb24gZ2V0TG93Qml0cygpIHtcbiAgcmV0dXJuIHRoaXMubG93O1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsb3cgMzIgYml0cyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgbG93IGJpdHNcbiAqL1xuTG9uZ1Byb3RvdHlwZS5nZXRMb3dCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRMb3dCaXRzVW5zaWduZWQoKSB7XG4gIHJldHVybiB0aGlzLmxvdyA+Pj4gMDtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgbnVtYmVyIG9mIGJpdHMgbmVlZGVkIHRvIHJlcHJlc2VudCB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBMb25nLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5nZXROdW1CaXRzQWJzID0gZnVuY3Rpb24gZ2V0TnVtQml0c0FicygpIHtcbiAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcbiAgICByZXR1cm4gdGhpcy5lcShNSU5fVkFMVUUpID8gNjQgOiB0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTtcbiAgdmFyIHZhbCA9IHRoaXMuaGlnaCAhPSAwID8gdGhpcy5oaWdoIDogdGhpcy5sb3c7XG4gIGZvciAodmFyIGJpdCA9IDMxOyBiaXQgPiAwOyBiaXQtLSlcbiAgICBpZiAoKHZhbCAmICgxIDw8IGJpdCkpICE9IDApXG4gICAgICBicmVhaztcbiAgcmV0dXJuIHRoaXMuaGlnaCAhPSAwID8gYml0ICsgMzMgOiBiaXQgKyAxO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgemVyby5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHtcbiAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gMCAmJiB0aGlzLmxvdyA9PT0gMDtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHplcm8uIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjaXNaZXJvfS5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmVxeiA9IExvbmdQcm90b3R5cGUuaXNaZXJvO1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG5lZ2F0aXZlLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uIGlzTmVnYXRpdmUoKSB7XG4gIHJldHVybiAhdGhpcy51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPCAwO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBwb3NpdGl2ZSBvciB6ZXJvLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uIGlzUG9zaXRpdmUoKSB7XG4gIHJldHVybiB0aGlzLnVuc2lnbmVkIHx8IHRoaXMuaGlnaCA+PSAwO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBvZGQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uIGlzT2RkKCkge1xuICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDE7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGV2ZW4uXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiBpc0V2ZW4oKSB7XG4gIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMDtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHRoZSBzcGVjaWZpZWQncy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xuICBpZiAoIWlzTG9uZyhvdGhlcikpXG4gICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICBpZiAodGhpcy51bnNpZ25lZCAhPT0gb3RoZXIudW5zaWduZWQgJiYgKHRoaXMuaGlnaCA+Pj4gMzEpID09PSAxICYmIChvdGhlci5oaWdoID4+PiAzMSkgPT09IDEpXG4gICAgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdGhpcy5oaWdoID09PSBvdGhlci5oaWdoICYmIHRoaXMubG93ID09PSBvdGhlci5sb3c7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZXF1YWxzfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUuZXEgPSBMb25nUHJvdG90eXBlLmVxdWFscztcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUubm90RXF1YWxzID0gZnVuY3Rpb24gbm90RXF1YWxzKG90aGVyKSB7XG4gIHJldHVybiAhdGhpcy5lcSgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLm5lcSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbm90RXF1YWxzfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUubmUgPSBMb25nUHJvdG90eXBlLm5vdEVxdWFscztcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCdzLlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUubGVzc1RoYW4gPSBmdW5jdGlvbiBsZXNzVGhhbihvdGhlcikge1xuICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPCAwO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFufS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUubHQgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuO1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBsZXNzVGhhbk9yRXF1YWwob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpIDw9IDA7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW5PckVxdWFsfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkxvbmdQcm90b3R5cGUubHRlID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWw7XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbk9yRXF1YWx9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5sZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbiA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuKG90aGVyKSB7XG4gIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA+IDA7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW59LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5ndCA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW47XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuT3JFcXVhbChvdGhlcikge1xuICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPj0gMDtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbk9yRXF1YWx9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5ndGUgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5Mb25nUHJvdG90eXBlLmdlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7XG5cbi8qKlxuICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIgYW5kIC0xXG4gKiAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyXG4gKi9cbkxvbmdQcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUob3RoZXIpIHtcbiAgaWYgKCFpc0xvbmcob3RoZXIpKVxuICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcbiAgaWYgKHRoaXMuZXEob3RoZXIpKVxuICAgIHJldHVybiAwO1xuICB2YXIgdGhpc05lZyA9IHRoaXMuaXNOZWdhdGl2ZSgpLFxuICAgIG90aGVyTmVnID0gb3RoZXIuaXNOZWdhdGl2ZSgpO1xuICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpXG4gICAgcmV0dXJuIC0xO1xuICBpZiAoIXRoaXNOZWcgJiYgb3RoZXJOZWcpXG4gICAgcmV0dXJuIDE7XG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHNpZ24gYml0cyBhcmUgdGhlIHNhbWVcbiAgaWYgKCF0aGlzLnVuc2lnbmVkKVxuICAgIHJldHVybiB0aGlzLnN1YihvdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxO1xuICAvLyBCb3RoIGFyZSBwb3NpdGl2ZSBpZiBhdCBsZWFzdCBvbmUgaXMgdW5zaWduZWRcbiAgcmV0dXJuIChvdGhlci5oaWdoID4+PiAwKSA+ICh0aGlzLmhpZ2ggPj4+IDApIHx8IChvdGhlci5oaWdoID09PSB0aGlzLmhpZ2ggJiYgKG90aGVyLmxvdyA+Pj4gMCkgPiAodGhpcy5sb3cgPj4+IDApKSA/IC0xIDogMTtcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjY29tcGFyZX0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcbiAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcbiAqL1xuTG9uZ1Byb3RvdHlwZS5jb21wID0gTG9uZ1Byb3RvdHlwZS5jb21wYXJlO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xuICovXG5Mb25nUHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uIG5lZ2F0ZSgpIHtcbiAgaWYgKCF0aGlzLnVuc2lnbmVkICYmIHRoaXMuZXEoTUlOX1ZBTFVFKSlcbiAgICByZXR1cm4gTUlOX1ZBTFVFO1xuICByZXR1cm4gdGhpcy5ub3QoKS5hZGQoT05FKTtcbn07XG5cbi8qKlxuICogTmVnYXRlcyB0aGlzIExvbmcncyB2YWx1ZS4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNuZWdhdGV9LlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xuICovXG5Mb25nUHJvdG90eXBlLm5lZyA9IExvbmdQcm90b3R5cGUubmVnYXRlO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHN1bSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGFkZGVuZCBBZGRlbmRcbiAqIEByZXR1cm5zIHshTG9uZ30gU3VtXG4gKi9cbkxvbmdQcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKGFkZGVuZCkge1xuICBpZiAoIWlzTG9uZyhhZGRlbmQpKVxuICAgIGFkZGVuZCA9IGZyb21WYWx1ZShhZGRlbmQpO1xuXG4gIC8vIERpdmlkZSBlYWNoIG51bWJlciBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIHN1bSB0aGUgY2h1bmtzLlxuXG4gIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xuICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xuICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xuICB2YXIgYTAwID0gdGhpcy5sb3cgJiAweEZGRkY7XG5cbiAgdmFyIGI0OCA9IGFkZGVuZC5oaWdoID4+PiAxNjtcbiAgdmFyIGIzMiA9IGFkZGVuZC5oaWdoICYgMHhGRkZGO1xuICB2YXIgYjE2ID0gYWRkZW5kLmxvdyA+Pj4gMTY7XG4gIHZhciBiMDAgPSBhZGRlbmQubG93ICYgMHhGRkZGO1xuXG4gIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwO1xuICBjMDAgKz0gYTAwICsgYjAwO1xuICBjMTYgKz0gYzAwID4+PiAxNjtcbiAgYzAwICY9IDB4RkZGRjtcbiAgYzE2ICs9IGExNiArIGIxNjtcbiAgYzMyICs9IGMxNiA+Pj4gMTY7XG4gIGMxNiAmPSAweEZGRkY7XG4gIGMzMiArPSBhMzIgKyBiMzI7XG4gIGM0OCArPSBjMzIgPj4+IDE2O1xuICBjMzIgJj0gMHhGRkZGO1xuICBjNDggKz0gYTQ4ICsgYjQ4O1xuICBjNDggJj0gMHhGRkZGO1xuICByZXR1cm4gZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IHN1YnRyYWhlbmQgU3VidHJhaGVuZFxuICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXG4gKi9cbkxvbmdQcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdChzdWJ0cmFoZW5kKSB7XG4gIGlmICghaXNMb25nKHN1YnRyYWhlbmQpKVxuICAgIHN1YnRyYWhlbmQgPSBmcm9tVmFsdWUoc3VidHJhaGVuZCk7XG4gIHJldHVybiB0aGlzLmFkZChzdWJ0cmFoZW5kLm5lZygpKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc3VidHJhY3R9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IHN1YnRyYWhlbmQgU3VidHJhaGVuZFxuICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXG4gKi9cbkxvbmdQcm90b3R5cGUuc3ViID0gTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcbiAqL1xuTG9uZ1Byb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KG11bHRpcGxpZXIpIHtcbiAgaWYgKHRoaXMuaXNaZXJvKCkpXG4gICAgcmV0dXJuIHRoaXM7XG4gIGlmICghaXNMb25nKG11bHRpcGxpZXIpKVxuICAgIG11bHRpcGxpZXIgPSBmcm9tVmFsdWUobXVsdGlwbGllcik7XG5cbiAgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XG4gIGlmICh3YXNtKSB7XG4gICAgdmFyIGxvdyA9IHdhc21bXCJtdWxcIl0odGhpcy5sb3csXG4gICAgICB0aGlzLmhpZ2gsXG4gICAgICBtdWx0aXBsaWVyLmxvdyxcbiAgICAgIG11bHRpcGxpZXIuaGlnaCk7XG4gICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbVtcImdldF9oaWdoXCJdKCksIHRoaXMudW5zaWduZWQpO1xuICB9XG5cbiAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpXG4gICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XG4gIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpXG4gICAgcmV0dXJuIG11bHRpcGxpZXIuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87XG4gIGlmIChtdWx0aXBsaWVyLmVxKE1JTl9WQUxVRSkpXG4gICAgcmV0dXJuIHRoaXMuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87XG5cbiAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKVxuICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIubmVnKCkpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyKS5uZWcoKTtcbiAgfSBlbHNlIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSlcbiAgICByZXR1cm4gdGhpcy5tdWwobXVsdGlwbGllci5uZWcoKSkubmVnKCk7XG5cbiAgLy8gSWYgYm90aCBsb25ncyBhcmUgc21hbGwsIHVzZSBmbG9hdCBtdWx0aXBsaWNhdGlvblxuICBpZiAodGhpcy5sdChUV09fUFdSXzI0KSAmJiBtdWx0aXBsaWVyLmx0KFRXT19QV1JfMjQpKVxuICAgIHJldHVybiBmcm9tTnVtYmVyKHRoaXMudG9OdW1iZXIoKSAqIG11bHRpcGxpZXIudG9OdW1iZXIoKSwgdGhpcy51bnNpZ25lZCk7XG5cbiAgLy8gRGl2aWRlIGVhY2ggbG9uZyBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIGFkZCB1cCA0eDQgcHJvZHVjdHMuXG4gIC8vIFdlIGNhbiBza2lwIHByb2R1Y3RzIHRoYXQgd291bGQgb3ZlcmZsb3cuXG5cbiAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XG4gIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XG4gIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XG4gIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcblxuICB2YXIgYjQ4ID0gbXVsdGlwbGllci5oaWdoID4+PiAxNjtcbiAgdmFyIGIzMiA9IG11bHRpcGxpZXIuaGlnaCAmIDB4RkZGRjtcbiAgdmFyIGIxNiA9IG11bHRpcGxpZXIubG93ID4+PiAxNjtcbiAgdmFyIGIwMCA9IG11bHRpcGxpZXIubG93ICYgMHhGRkZGO1xuXG4gIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwO1xuICBjMDAgKz0gYTAwICogYjAwO1xuICBjMTYgKz0gYzAwID4+PiAxNjtcbiAgYzAwICY9IDB4RkZGRjtcbiAgYzE2ICs9IGExNiAqIGIwMDtcbiAgYzMyICs9IGMxNiA+Pj4gMTY7XG4gIGMxNiAmPSAweEZGRkY7XG4gIGMxNiArPSBhMDAgKiBiMTY7XG4gIGMzMiArPSBjMTYgPj4+IDE2O1xuICBjMTYgJj0gMHhGRkZGO1xuICBjMzIgKz0gYTMyICogYjAwO1xuICBjNDggKz0gYzMyID4+PiAxNjtcbiAgYzMyICY9IDB4RkZGRjtcbiAgYzMyICs9IGExNiAqIGIxNjtcbiAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gIGMzMiAmPSAweEZGRkY7XG4gIGMzMiArPSBhMDAgKiBiMzI7XG4gIGM0OCArPSBjMzIgPj4+IDE2O1xuICBjMzIgJj0gMHhGRkZGO1xuICBjNDggKz0gYTQ4ICogYjAwICsgYTMyICogYjE2ICsgYTE2ICogYjMyICsgYTAwICogYjQ4O1xuICBjNDggJj0gMHhGRkZGO1xuICByZXR1cm4gZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbXVsdGlwbHl9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG11bHRpcGxpZXIgTXVsdGlwbGllclxuICogQHJldHVybnMgeyFMb25nfSBQcm9kdWN0XG4gKi9cbkxvbmdQcm90b3R5cGUubXVsID0gTG9uZ1Byb3RvdHlwZS5tdWx0aXBseTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoZSByZXN1bHQgaXMgc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyBzaWduZWQgb3JcbiAqICB1bnNpZ25lZCBpZiB0aGlzIExvbmcgaXMgdW5zaWduZWQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxuICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxuICovXG5Mb25nUHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZShkaXZpc29yKSB7XG4gIGlmICghaXNMb25nKGRpdmlzb3IpKVxuICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7XG4gIGlmIChkaXZpc29yLmlzWmVybygpKVxuICAgIHRocm93IEVycm9yKCdkaXZpc2lvbiBieSB6ZXJvJyk7XG5cbiAgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XG4gIGlmICh3YXNtKSB7XG4gICAgLy8gZ3VhcmQgYWdhaW5zdCBzaWduZWQgZGl2aXNpb24gb3ZlcmZsb3c6IHRoZSBsYXJnZXN0XG4gICAgLy8gbmVnYXRpdmUgbnVtYmVyIC8gLTEgd291bGQgYmUgMSBsYXJnZXIgdGhhbiB0aGUgbGFyZ2VzdFxuICAgIC8vIHBvc2l0aXZlIG51bWJlciwgZHVlIHRvIHR3bydzIGNvbXBsZW1lbnQuXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmXG4gICAgICB0aGlzLmhpZ2ggPT09IC0weDgwMDAwMDAwICYmXG4gICAgICBkaXZpc29yLmxvdyA9PT0gLTEgJiYgZGl2aXNvci5oaWdoID09PSAtMSkge1xuICAgICAgLy8gYmUgY29uc2lzdGVudCB3aXRoIG5vbi13YXNtIGNvZGUgcGF0aFxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc21bXCJkaXZfdVwiXSA6IHdhc21bXCJkaXZfc1wiXSkoXG4gICAgICB0aGlzLmxvdyxcbiAgICAgIHRoaXMuaGlnaCxcbiAgICAgIGRpdmlzb3IubG93LFxuICAgICAgZGl2aXNvci5oaWdoXG4gICAgKTtcbiAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtW1wiZ2V0X2hpZ2hcIl0oKSwgdGhpcy51bnNpZ25lZCk7XG4gIH1cblxuICBpZiAodGhpcy5pc1plcm8oKSlcbiAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgdmFyIGFwcHJveCwgcmVtLCByZXM7XG4gIGlmICghdGhpcy51bnNpZ25lZCkge1xuICAgIC8vIFRoaXMgc2VjdGlvbiBpcyBvbmx5IHJlbGV2YW50IGZvciBzaWduZWQgbG9uZ3MgYW5kIGlzIGRlcml2ZWQgZnJvbSB0aGVcbiAgICAvLyBjbG9zdXJlIGxpYnJhcnkgYXMgYSB3aG9sZS5cbiAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XG4gICAgICBpZiAoZGl2aXNvci5lcShPTkUpIHx8IGRpdmlzb3IuZXEoTkVHX09ORSkpXG4gICAgICAgIHJldHVybiBNSU5fVkFMVUU7ICAvLyByZWNhbGwgdGhhdCAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRVxuICAgICAgZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKVxuICAgICAgICByZXR1cm4gT05FO1xuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgfG90aGVyfCA+PSAyLCBzbyB8dGhpcy9vdGhlcnwgPCB8TUlOX1ZBTFVFfC5cbiAgICAgICAgdmFyIGhhbGZUaGlzID0gdGhpcy5zaHIoMSk7XG4gICAgICAgIGFwcHJveCA9IGhhbGZUaGlzLmRpdihkaXZpc29yKS5zaGwoMSk7XG4gICAgICAgIGlmIChhcHByb3guZXEoWkVSTykpIHtcbiAgICAgICAgICByZXR1cm4gZGl2aXNvci5pc05lZ2F0aXZlKCkgPyBPTkUgOiBORUdfT05FO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbSA9IHRoaXMuc3ViKGRpdmlzb3IubXVsKGFwcHJveCkpO1xuICAgICAgICAgIHJlcyA9IGFwcHJveC5hZGQocmVtLmRpdihkaXZpc29yKSk7XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKVxuICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpXG4gICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yLm5lZygpKTtcbiAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yKS5uZWcoKTtcbiAgICB9IGVsc2UgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxuICAgICAgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpO1xuICAgIHJlcyA9IFpFUk87XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlIGFsZ29yaXRobSBiZWxvdyBoYXMgbm90IGJlZW4gbWFkZSBmb3IgdW5zaWduZWQgbG9uZ3MuIEl0J3MgdGhlcmVmb3JlXG4gICAgLy8gcmVxdWlyZWQgdG8gdGFrZSBzcGVjaWFsIGNhcmUgb2YgdGhlIE1TQiBwcmlvciB0byBydW5uaW5nIGl0LlxuICAgIGlmICghZGl2aXNvci51bnNpZ25lZClcbiAgICAgIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTtcbiAgICBpZiAoZGl2aXNvci5ndCh0aGlzKSlcbiAgICAgIHJldHVybiBVWkVSTztcbiAgICBpZiAoZGl2aXNvci5ndCh0aGlzLnNocnUoMSkpKSAvLyAxNSA+Pj4gMSA9IDcgOyB3aXRoIGRpdmlzb3IgPSA4IDsgdHJ1ZVxuICAgICAgcmV0dXJuIFVPTkU7XG4gICAgcmVzID0gVVpFUk87XG4gIH1cblxuICAvLyBSZXBlYXQgdGhlIGZvbGxvd2luZyB1bnRpbCB0aGUgcmVtYWluZGVyIGlzIGxlc3MgdGhhbiBvdGhlcjogIGZpbmQgYVxuICAvLyBmbG9hdGluZy1wb2ludCB0aGF0IGFwcHJveGltYXRlcyByZW1haW5kZXIgLyBvdGhlciAqZnJvbSBiZWxvdyosIGFkZCB0aGlzXG4gIC8vIGludG8gdGhlIHJlc3VsdCwgYW5kIHN1YnRyYWN0IGl0IGZyb20gdGhlIHJlbWFpbmRlci4gIEl0IGlzIGNyaXRpY2FsIHRoYXRcbiAgLy8gdGhlIGFwcHJveGltYXRlIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcmVhbCB2YWx1ZSBzbyB0aGF0IHRoZVxuICAvLyByZW1haW5kZXIgbmV2ZXIgYmVjb21lcyBuZWdhdGl2ZS5cbiAgcmVtID0gdGhpcztcbiAgd2hpbGUgKHJlbS5ndGUoZGl2aXNvcikpIHtcbiAgICAvLyBBcHByb3hpbWF0ZSB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uLiBUaGlzIG1heSBiZSBhIGxpdHRsZSBncmVhdGVyIG9yXG4gICAgLy8gc21hbGxlciB0aGFuIHRoZSBhY3R1YWwgdmFsdWUuXG4gICAgYXBwcm94ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihyZW0udG9OdW1iZXIoKSAvIGRpdmlzb3IudG9OdW1iZXIoKSkpO1xuXG4gICAgLy8gV2Ugd2lsbCB0d2VhayB0aGUgYXBwcm94aW1hdGUgcmVzdWx0IGJ5IGNoYW5naW5nIGl0IGluIHRoZSA0OC10aCBkaWdpdCBvclxuICAgIC8vIHRoZSBzbWFsbGVzdCBub24tZnJhY3Rpb25hbCBkaWdpdCwgd2hpY2hldmVyIGlzIGxhcmdlci5cbiAgICB2YXIgbG9nMiA9IE1hdGguY2VpbChNYXRoLmxvZyhhcHByb3gpIC8gTWF0aC5MTjIpLFxuICAgICAgZGVsdGEgPSAobG9nMiA8PSA0OCkgPyAxIDogcG93X2RibCgyLCBsb2cyIC0gNDgpLFxuXG4gICAgICAvLyBEZWNyZWFzZSB0aGUgYXBwcm94aW1hdGlvbiB1bnRpbCBpdCBpcyBzbWFsbGVyIHRoYW4gdGhlIHJlbWFpbmRlci4gIE5vdGVcbiAgICAgIC8vIHRoYXQgaWYgaXQgaXMgdG9vIGxhcmdlLCB0aGUgcHJvZHVjdCBvdmVyZmxvd3MgYW5kIGlzIG5lZ2F0aXZlLlxuICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gpLFxuICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTtcbiAgICB3aGlsZSAoYXBwcm94UmVtLmlzTmVnYXRpdmUoKSB8fCBhcHByb3hSZW0uZ3QocmVtKSkge1xuICAgICAgYXBwcm94IC09IGRlbHRhO1xuICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gsIHRoaXMudW5zaWduZWQpO1xuICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTtcbiAgICB9XG5cbiAgICAvLyBXZSBrbm93IHRoZSBhbnN3ZXIgY2FuJ3QgYmUgemVyby4uLiBhbmQgYWN0dWFsbHksIHplcm8gd291bGQgY2F1c2VcbiAgICAvLyBpbmZpbml0ZSByZWN1cnNpb24gc2luY2Ugd2Ugd291bGQgbWFrZSBubyBwcm9ncmVzcy5cbiAgICBpZiAoYXBwcm94UmVzLmlzWmVybygpKVxuICAgICAgYXBwcm94UmVzID0gT05FO1xuXG4gICAgcmVzID0gcmVzLmFkZChhcHByb3hSZXMpO1xuICAgIHJlbSA9IHJlbS5zdWIoYXBwcm94UmVtKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZGl2aWRlfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcbiAqIEByZXR1cm5zIHshTG9uZ30gUXVvdGllbnRcbiAqL1xuTG9uZ1Byb3RvdHlwZS5kaXYgPSBMb25nUHJvdG90eXBlLmRpdmlkZTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxuICovXG5Mb25nUHJvdG90eXBlLm1vZHVsbyA9IGZ1bmN0aW9uIG1vZHVsbyhkaXZpc29yKSB7XG4gIGlmICghaXNMb25nKGRpdmlzb3IpKVxuICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7XG5cbiAgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XG4gIGlmICh3YXNtKSB7XG4gICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbVtcInJlbV91XCJdIDogd2FzbVtcInJlbV9zXCJdKShcbiAgICAgIHRoaXMubG93LFxuICAgICAgdGhpcy5oaWdoLFxuICAgICAgZGl2aXNvci5sb3csXG4gICAgICBkaXZpc29yLmhpZ2hcbiAgICApO1xuICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc21bXCJnZXRfaGlnaFwiXSgpLCB0aGlzLnVuc2lnbmVkKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnN1Yih0aGlzLmRpdihkaXZpc29yKS5tdWwoZGl2aXNvcikpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtb2R1bG99LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxuICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcbiAqL1xuTG9uZ1Byb3RvdHlwZS5tb2QgPSBMb25nUHJvdG90eXBlLm1vZHVsbztcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtb2R1bG99LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxuICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcbiAqL1xuTG9uZ1Byb3RvdHlwZS5yZW0gPSBMb25nUHJvdG90eXBlLm1vZHVsbztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE5PVCBvZiB0aGlzIExvbmcuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7IUxvbmd9XG4gKi9cbkxvbmdQcm90b3R5cGUubm90ID0gZnVuY3Rpb24gbm90KCkge1xuICByZXR1cm4gZnJvbUJpdHMofnRoaXMubG93LCB+dGhpcy5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBjb3VudCBsZWFkaW5nIHplcm9zIG9mIHRoaXMgTG9uZy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHshbnVtYmVyfVxuICovXG5Mb25nUHJvdG90eXBlLmNvdW50TGVhZGluZ1plcm9zID0gZnVuY3Rpb24gY291bnRMZWFkaW5nWmVyb3MoKSB7XG4gIHJldHVybiB0aGlzLmhpZ2ggPyBNYXRoLmNsejMyKHRoaXMuaGlnaCkgOiBNYXRoLmNsejMyKHRoaXMubG93KSArIDMyO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGNvdW50IGxlYWRpbmcgemVyb3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjY291bnRMZWFkaW5nWmVyb3N9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyFMb25nfVxuICogQHJldHVybnMgeyFudW1iZXJ9XG4gKi9cbkxvbmdQcm90b3R5cGUuY2x6ID0gTG9uZ1Byb3RvdHlwZS5jb3VudExlYWRpbmdaZXJvcztcblxuLyoqXG4gKiBSZXR1cm5zIGNvdW50IHRyYWlsaW5nIHplcm9zIG9mIHRoaXMgTG9uZy5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHshbnVtYmVyfVxuICovXG5Mb25nUHJvdG90eXBlLmNvdW50VHJhaWxpbmdaZXJvcyA9IGZ1bmN0aW9uIGNvdW50VHJhaWxpbmdaZXJvcygpIHtcbiAgcmV0dXJuIHRoaXMubG93ID8gY3R6MzIodGhpcy5sb3cpIDogY3R6MzIodGhpcy5oaWdoKSArIDMyO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGNvdW50IHRyYWlsaW5nIHplcm9zLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2NvdW50VHJhaWxpbmdaZXJvc30uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7IUxvbmd9XG4gKiBAcmV0dXJucyB7IW51bWJlcn1cbiAqL1xuTG9uZ1Byb3RvdHlwZS5jdHogPSBMb25nUHJvdG90eXBlLmNvdW50VHJhaWxpbmdaZXJvcztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIEFORCBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcbiAqIEByZXR1cm5zIHshTG9uZ31cbiAqL1xuTG9uZ1Byb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQob3RoZXIpIHtcbiAgaWYgKCFpc0xvbmcob3RoZXIpKVxuICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcbiAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93ICYgb3RoZXIubG93LCB0aGlzLmhpZ2ggJiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYml0d2lzZSBPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcbiAqIEByZXR1cm5zIHshTG9uZ31cbiAqL1xuTG9uZ1Byb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKG90aGVyKSB7XG4gIGlmICghaXNMb25nKG90aGVyKSlcbiAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyB8IG90aGVyLmxvdywgdGhpcy5oaWdoIHwgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgWE9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIGdpdmVuIG9uZS5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xuICogQHJldHVybnMgeyFMb25nfVxuICovXG5Mb25nUHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvcihvdGhlcikge1xuICBpZiAoIWlzTG9uZyhvdGhlcikpXG4gICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgXiBvdGhlci5sb3csIHRoaXMuaGlnaCBeIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gc2hpZnRMZWZ0KG51bUJpdHMpIHtcbiAgaWYgKGlzTG9uZyhudW1CaXRzKSlcbiAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKVxuICAgIHJldHVybiB0aGlzO1xuICBlbHNlIGlmIChudW1CaXRzIDwgMzIpXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IDw8IG51bUJpdHMsICh0aGlzLmhpZ2ggPDwgbnVtQml0cykgfCAodGhpcy5sb3cgPj4+ICgzMiAtIG51bUJpdHMpKSwgdGhpcy51bnNpZ25lZCk7XG4gIGVsc2VcbiAgICByZXR1cm4gZnJvbUJpdHMoMCwgdGhpcy5sb3cgPDwgKG51bUJpdHMgLSAzMiksIHRoaXMudW5zaWduZWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0TGVmdH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICovXG5Mb25nUHJvdG90eXBlLnNobCA9IExvbmdQcm90b3R5cGUuc2hpZnRMZWZ0O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUuc2hpZnRSaWdodCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHQobnVtQml0cykge1xuICBpZiAoaXNMb25nKG51bUJpdHMpKVxuICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXG4gICAgcmV0dXJuIHRoaXM7XG4gIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcbiAgICByZXR1cm4gZnJvbUJpdHMoKHRoaXMubG93ID4+PiBudW1CaXRzKSB8ICh0aGlzLmhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLCB0aGlzLmhpZ2ggPj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XG4gIGVsc2VcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoID4+IChudW1CaXRzIC0gMzIpLCB0aGlzLmhpZ2ggPj0gMCA/IDAgOiAtMSwgdGhpcy51bnNpZ25lZCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHR9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5zaHIgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHQ7XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkID0gZnVuY3Rpb24gc2hpZnRSaWdodFVuc2lnbmVkKG51bUJpdHMpIHtcbiAgaWYgKGlzTG9uZyhudW1CaXRzKSkgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gIGlmIChudW1CaXRzIDwgMzIpIHJldHVybiBmcm9tQml0cygodGhpcy5sb3cgPj4+IG51bUJpdHMpIHwgKHRoaXMuaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIHRoaXMuaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XG4gIGlmIChudW1CaXRzID09PSAzMikgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCwgMCwgdGhpcy51bnNpZ25lZCk7XG4gIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2ggPj4+IChudW1CaXRzIC0gMzIpLCAwLCB0aGlzLnVuc2lnbmVkKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICovXG5Mb25nUHJvdG90eXBlLnNocnUgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodFVuc2lnbmVkfS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUuc2hyX3UgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICogQHRoaXMgeyFMb25nfVxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAqIEByZXR1cm5zIHshTG9uZ30gUm90YXRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUucm90YXRlTGVmdCA9IGZ1bmN0aW9uIHJvdGF0ZUxlZnQobnVtQml0cykge1xuICB2YXIgYjtcbiAgaWYgKGlzTG9uZyhudW1CaXRzKSkgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gIGlmIChudW1CaXRzID09PSAzMikgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCwgdGhpcy5sb3csIHRoaXMudW5zaWduZWQpO1xuICBpZiAobnVtQml0cyA8IDMyKSB7XG4gICAgYiA9ICgzMiAtIG51bUJpdHMpO1xuICAgIHJldHVybiBmcm9tQml0cygoKHRoaXMubG93IDw8IG51bUJpdHMpIHwgKHRoaXMuaGlnaCA+Pj4gYikpLCAoKHRoaXMuaGlnaCA8PCBudW1CaXRzKSB8ICh0aGlzLmxvdyA+Pj4gYikpLCB0aGlzLnVuc2lnbmVkKTtcbiAgfVxuICBudW1CaXRzIC09IDMyO1xuICBiID0gKDMyIC0gbnVtQml0cyk7XG4gIHJldHVybiBmcm9tQml0cygoKHRoaXMuaGlnaCA8PCBudW1CaXRzKSB8ICh0aGlzLmxvdyA+Pj4gYikpLCAoKHRoaXMubG93IDw8IG51bUJpdHMpIHwgKHRoaXMuaGlnaCA+Pj4gYikpLCB0aGlzLnVuc2lnbmVkKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHJvdGF0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNyb3RhdGVMZWZ0fS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAqIEByZXR1cm5zIHshTG9uZ30gUm90YXRlZCBMb25nXG4gKi9cbkxvbmdQcm90b3R5cGUucm90bCA9IExvbmdQcm90b3R5cGUucm90YXRlTGVmdDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJvdGF0ZWQgTG9uZ1xuICovXG5Mb25nUHJvdG90eXBlLnJvdGF0ZVJpZ2h0ID0gZnVuY3Rpb24gcm90YXRlUmlnaHQobnVtQml0cykge1xuICB2YXIgYjtcbiAgaWYgKGlzTG9uZyhudW1CaXRzKSkgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gIGlmIChudW1CaXRzID09PSAzMikgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCwgdGhpcy5sb3csIHRoaXMudW5zaWduZWQpO1xuICBpZiAobnVtQml0cyA8IDMyKSB7XG4gICAgYiA9ICgzMiAtIG51bUJpdHMpO1xuICAgIHJldHVybiBmcm9tQml0cygoKHRoaXMuaGlnaCA8PCBiKSB8ICh0aGlzLmxvdyA+Pj4gbnVtQml0cykpLCAoKHRoaXMubG93IDw8IGIpIHwgKHRoaXMuaGlnaCA+Pj4gbnVtQml0cykpLCB0aGlzLnVuc2lnbmVkKTtcbiAgfVxuICBudW1CaXRzIC09IDMyO1xuICBiID0gKDMyIC0gbnVtQml0cyk7XG4gIHJldHVybiBmcm9tQml0cygoKHRoaXMubG93IDw8IGIpIHwgKHRoaXMuaGlnaCA+Pj4gbnVtQml0cykpLCAoKHRoaXMuaGlnaCA8PCBiKSB8ICh0aGlzLmxvdyA+Pj4gbnVtQml0cykpLCB0aGlzLnVuc2lnbmVkKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHJvdGF0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjcm90YXRlUmlnaHR9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICogQHJldHVybnMgeyFMb25nfSBSb3RhdGVkIExvbmdcbiAqL1xuTG9uZ1Byb3RvdHlwZS5yb3RyID0gTG9uZ1Byb3RvdHlwZS5yb3RhdGVSaWdodDtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gc2lnbmVkLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMgeyFMb25nfSBTaWduZWQgbG9uZ1xuICovXG5Mb25nUHJvdG90eXBlLnRvU2lnbmVkID0gZnVuY3Rpb24gdG9TaWduZWQoKSB7XG4gIGlmICghdGhpcy51bnNpZ25lZClcbiAgICByZXR1cm4gdGhpcztcbiAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIHVuc2lnbmVkLlxuICogQHRoaXMgeyFMb25nfVxuICogQHJldHVybnMgeyFMb25nfSBVbnNpZ25lZCBsb25nXG4gKi9cbkxvbmdQcm90b3R5cGUudG9VbnNpZ25lZCA9IGZ1bmN0aW9uIHRvVW5zaWduZWQoKSB7XG4gIGlmICh0aGlzLnVuc2lnbmVkKVxuICAgIHJldHVybiB0aGlzO1xuICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGxlIFdoZXRoZXIgbGl0dGxlIG9yIGJpZyBlbmRpYW4sIGRlZmF1bHRzIHRvIGJpZyBlbmRpYW5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IEJ5dGUgcmVwcmVzZW50YXRpb25cbiAqL1xuTG9uZ1Byb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24gdG9CeXRlcyhsZSkge1xuICByZXR1cm4gbGUgPyB0aGlzLnRvQnl0ZXNMRSgpIDogdGhpcy50b0J5dGVzQkUoKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBsaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXG4gKiBAdGhpcyB7IUxvbmd9XG4gKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBMaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cbiAqL1xuTG9uZ1Byb3RvdHlwZS50b0J5dGVzTEUgPSBmdW5jdGlvbiB0b0J5dGVzTEUoKSB7XG4gIHZhciBoaSA9IHRoaXMuaGlnaCxcbiAgICBsbyA9IHRoaXMubG93O1xuICByZXR1cm4gW1xuICAgIGxvICYgMHhmZixcbiAgICBsbyA+Pj4gOCAmIDB4ZmYsXG4gICAgbG8gPj4+IDE2ICYgMHhmZixcbiAgICBsbyA+Pj4gMjQsXG4gICAgaGkgJiAweGZmLFxuICAgIGhpID4+PiA4ICYgMHhmZixcbiAgICBoaSA+Pj4gMTYgJiAweGZmLFxuICAgIGhpID4+PiAyNFxuICBdO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAqIEB0aGlzIHshTG9uZ31cbiAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IEJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxuICovXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXNCRSA9IGZ1bmN0aW9uIHRvQnl0ZXNCRSgpIHtcbiAgdmFyIGhpID0gdGhpcy5oaWdoLFxuICAgIGxvID0gdGhpcy5sb3c7XG4gIHJldHVybiBbXG4gICAgaGkgPj4+IDI0LFxuICAgIGhpID4+PiAxNiAmIDB4ZmYsXG4gICAgaGkgPj4+IDggJiAweGZmLFxuICAgIGhpICYgMHhmZixcbiAgICBsbyA+Pj4gMjQsXG4gICAgbG8gPj4+IDE2ICYgMHhmZixcbiAgICBsbyA+Pj4gOCAmIDB4ZmYsXG4gICAgbG8gJiAweGZmXG4gIF07XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGJ5dGUgcmVwcmVzZW50YXRpb24uXG4gKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgQnl0ZSByZXByZXNlbnRhdGlvblxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxuICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAqL1xuTG9uZy5mcm9tQnl0ZXMgPSBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMsIHVuc2lnbmVkLCBsZSkge1xuICByZXR1cm4gbGUgPyBMb25nLmZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkgOiBMb25nLmZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBMaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gKi9cbkxvbmcuZnJvbUJ5dGVzTEUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIHtcbiAgcmV0dXJuIG5ldyBMb25nKFxuICAgIGJ5dGVzWzBdIHxcbiAgICBieXRlc1sxXSA8PCA4IHxcbiAgICBieXRlc1syXSA8PCAxNiB8XG4gICAgYnl0ZXNbM10gPDwgMjQsXG4gICAgYnl0ZXNbNF0gfFxuICAgIGJ5dGVzWzVdIDw8IDggfFxuICAgIGJ5dGVzWzZdIDw8IDE2IHxcbiAgICBieXRlc1s3XSA8PCAyNCxcbiAgICB1bnNpZ25lZFxuICApO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgTG9uZyBmcm9tIGl0cyBiaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXG4gKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICovXG5Mb25nLmZyb21CeXRlc0JFID0gZnVuY3Rpb24gZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKSB7XG4gIHJldHVybiBuZXcgTG9uZyhcbiAgICBieXRlc1s0XSA8PCAyNCB8XG4gICAgYnl0ZXNbNV0gPDwgMTYgfFxuICAgIGJ5dGVzWzZdIDw8IDggfFxuICAgIGJ5dGVzWzddLFxuICAgIGJ5dGVzWzBdIDw8IDI0IHxcbiAgICBieXRlc1sxXSA8PCAxNiB8XG4gICAgYnl0ZXNbMl0gPDwgOCB8XG4gICAgYnl0ZXNbM10sXG4gICAgdW5zaWduZWRcbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IExvbmc7XG4iLCAiLy8vIEBmaWxlXG4vLy8gQGFkZHRvZ3JvdXAgZmxhdGJ1ZmZlcnNfamF2YXNjcmlwdF9hcGlcbi8vLyBAe1xuLy8vIEBjb25kIEZMQVRCVUZGRVJTX0lOVEVSTkFMXG5cbi8qKlxuICogQGZpbGVvdmVydmlld1xuICpcbiAqIE5lZWQgdG8gc3VwcHJlc3MgJ2dsb2JhbCB0aGlzJyBlcnJvciBzbyB0aGUgTm9kZS5qcyBleHBvcnQgbGluZSBkb2Vzbid0IGNhdXNlXG4gKiBjbG9zdXJlIGNvbXBpbGUgdG8gZXJyb3Igb3V0LlxuICogQHN1cHByZXNzIHtnbG9iYWxUaGlzfVxuICovXG5cbi8qKlxuICogQGNvbnN0XG4gKiBAbmFtZXNwYWNlXG4gKi9cbnZhciBmbGF0YnVmZmVycyA9IHt9O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLk9mZnNldDtcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcixcbiAqICAgYmJfcG9zOiBudW1iZXJcbiAqIH19XG4gKi9cbmZsYXRidWZmZXJzLlRhYmxlO1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqL1xuZmxhdGJ1ZmZlcnMuU0laRU9GX1NIT1JUID0gMjtcblxuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0XG4gKi9cbmZsYXRidWZmZXJzLlNJWkVPRl9JTlQgPSA0O1xuXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAY29uc3RcbiAqL1xuZmxhdGJ1ZmZlcnMuRklMRV9JREVOVElGSUVSX0xFTkdUSCA9IDQ7XG5cbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBjb25zdFxuICovXG5mbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEggPSA0O1xuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkVuY29kaW5nID0ge1xuICBVVEY4X0JZVEVTOiAxLFxuICBVVEYxNl9TVFJJTkc6IDJcbn07XG5cbi8qKlxuICogQHR5cGUge0ludDMyQXJyYXl9XG4gKiBAY29uc3RcbiAqL1xuZmxhdGJ1ZmZlcnMuaW50MzIgPSBuZXcgSW50MzJBcnJheSgyKTtcblxuLyoqXG4gKiBAdHlwZSB7RmxvYXQzMkFycmF5fVxuICogQGNvbnN0XG4gKi9cbmZsYXRidWZmZXJzLmZsb2F0MzIgPSBuZXcgRmxvYXQzMkFycmF5KGZsYXRidWZmZXJzLmludDMyLmJ1ZmZlcik7XG5cbi8qKlxuICogQHR5cGUge0Zsb2F0NjRBcnJheX1cbiAqIEBjb25zdFxuICovXG5mbGF0YnVmZmVycy5mbG9hdDY0ID0gbmV3IEZsb2F0NjRBcnJheShmbGF0YnVmZmVycy5pbnQzMi5idWZmZXIpO1xuXG4vKipcbiAqIEB0eXBlIHtib29sZWFufVxuICogQGNvbnN0XG4gKi9cbmZsYXRidWZmZXJzLmlzTGl0dGxlRW5kaWFuID0gbmV3IFVpbnQxNkFycmF5KG5ldyBVaW50OEFycmF5KFsxLCAwXSkuYnVmZmVyKVswXSA9PT0gMTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoXG4gKi9cbmZsYXRidWZmZXJzLkxvbmcgPSBmdW5jdGlvbihsb3csIGhpZ2gpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBjb25zdFxuICAgKi9cbiAgdGhpcy5sb3cgPSBsb3cgfCAwO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAY29uc3RcbiAgICovXG4gIHRoaXMuaGlnaCA9IGhpZ2ggfCAwO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbG93XG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaFxuICogQHJldHVybnMgeyFmbGF0YnVmZmVycy5Mb25nfVxuICovXG5mbGF0YnVmZmVycy5Mb25nLmNyZWF0ZSA9IGZ1bmN0aW9uKGxvdywgaGlnaCkge1xuICAvLyBTcGVjaWFsLWNhc2UgemVybyB0byBhdm9pZCBHQyBvdmVyaGVhZCBmb3IgZGVmYXVsdCB2YWx1ZXNcbiAgcmV0dXJuIGxvdyA9PSAwICYmIGhpZ2ggPT0gMCA/IGZsYXRidWZmZXJzLkxvbmcuWkVSTyA6IG5ldyBmbGF0YnVmZmVycy5Mb25nKGxvdywgaGlnaCk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkxvbmcucHJvdG90eXBlLnRvRmxvYXQ2NCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKHRoaXMubG93ID4+PiAwKSArIHRoaXMuaGlnaCAqIDB4MTAwMDAwMDAwO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLkxvbmd9IG90aGVyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZmxhdGJ1ZmZlcnMuTG9uZy5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMubG93ID09IG90aGVyLmxvdyAmJiB0aGlzLmhpZ2ggPT0gb3RoZXIuaGlnaDtcbn07XG5cbi8qKlxuICogQHR5cGUgeyFmbGF0YnVmZmVycy5Mb25nfVxuICogQGNvbnN0XG4gKi9cbmZsYXRidWZmZXJzLkxvbmcuWkVSTyA9IG5ldyBmbGF0YnVmZmVycy5Mb25nKDAsIDApO1xuXG4vLy8gQGVuZGNvbmRcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vKipcbiAqIENyZWF0ZSBhIEZsYXRCdWZmZXJCdWlsZGVyLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRfaW5pdGlhbF9zaXplXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIgPSBmdW5jdGlvbihvcHRfaW5pdGlhbF9zaXplKSB7XG4gIGlmICghb3B0X2luaXRpYWxfc2l6ZSkge1xuICAgIHZhciBpbml0aWFsX3NpemUgPSAxMDI0O1xuICB9IGVsc2Uge1xuICAgIHZhciBpbml0aWFsX3NpemUgPSBvcHRfaW5pdGlhbF9zaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtmbGF0YnVmZmVycy5CeXRlQnVmZmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5iYiA9IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIuYWxsb2NhdGUoaW5pdGlhbF9zaXplKTtcblxuICAvKipcbiAgICogUmVtYWluaW5nIHNwYWNlIGluIHRoZSBCeXRlQnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5zcGFjZSA9IGluaXRpYWxfc2l6ZTtcblxuICAvKipcbiAgICogTWluaW11bSBhbGlnbm1lbnQgZW5jb3VudGVyZWQgc28gZmFyLlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5taW5hbGlnbiA9IDE7XG5cbiAgLyoqXG4gICAqIFRoZSB2dGFibGUgZm9yIHRoZSBjdXJyZW50IHRhYmxlLlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnZ0YWJsZSA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2YgZmllbGRzIHdlJ3JlIGFjdHVhbGx5IHVzaW5nLlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy52dGFibGVfaW5fdXNlID0gMDtcblxuICAvKipcbiAgICogV2hldGhlciB3ZSBhcmUgY3VycmVudGx5IHNlcmlhbGl6aW5nIGEgdGFibGUuXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5pc05lc3RlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBTdGFydGluZyBvZmZzZXQgb2YgdGhlIGN1cnJlbnQgc3RydWN0L3RhYmxlLlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5vYmplY3Rfc3RhcnQgPSAwO1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIG9mZnNldHMgb2YgYWxsIHZ0YWJsZXMuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMudnRhYmxlcyA9IFtdO1xuXG4gIC8qKlxuICAgKiBGb3IgdGhlIGN1cnJlbnQgdmVjdG9yIGJlaW5nIGJ1aWx0LlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy52ZWN0b3JfbnVtX2VsZW1zID0gMDtcblxuICAvKipcbiAgICogRmFsc2Ugb21pdHMgZGVmYXVsdCB2YWx1ZXMgZnJvbSB0aGUgc2VyaWFsaXplZCBkYXRhXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5mb3JjZV9kZWZhdWx0cyA9IGZhbHNlO1xufTtcblxuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5iYi5jbGVhcigpO1xuICB0aGlzLnNwYWNlID0gdGhpcy5iYi5jYXBhY2l0eSgpO1xuICB0aGlzLm1pbmFsaWduID0gMTtcbiAgdGhpcy52dGFibGUgPSBudWxsO1xuICB0aGlzLnZ0YWJsZV9pbl91c2UgPSAwO1xuICB0aGlzLmlzTmVzdGVkID0gZmFsc2U7XG4gIHRoaXMub2JqZWN0X3N0YXJ0ID0gMDtcbiAgdGhpcy52dGFibGVzID0gW107XG4gIHRoaXMudmVjdG9yX251bV9lbGVtcyA9IDA7XG4gIHRoaXMuZm9yY2VfZGVmYXVsdHMgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogSW4gb3JkZXIgdG8gc2F2ZSBzcGFjZSwgZmllbGRzIHRoYXQgYXJlIHNldCB0byB0aGVpciBkZWZhdWx0IHZhbHVlXG4gKiBkb24ndCBnZXQgc2VyaWFsaXplZCBpbnRvIHRoZSBidWZmZXIuIEZvcmNpbmcgZGVmYXVsdHMgcHJvdmlkZXMgYVxuICogd2F5IHRvIG1hbnVhbGx5IGRpc2FibGUgdGhpcyBvcHRpbWl6YXRpb24uXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBmb3JjZURlZmF1bHRzIHRydWUgYWx3YXlzIHNlcmlhbGl6ZXMgZGVmYXVsdCB2YWx1ZXNcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuZm9yY2VEZWZhdWx0cyA9IGZ1bmN0aW9uKGZvcmNlRGVmYXVsdHMpIHtcbiAgdGhpcy5mb3JjZV9kZWZhdWx0cyA9IGZvcmNlRGVmYXVsdHM7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgQnl0ZUJ1ZmZlciByZXByZXNlbnRpbmcgdGhlIEZsYXRCdWZmZXIuIE9ubHkgY2FsbCB0aGlzIGFmdGVyIHlvdSd2ZVxuICogY2FsbGVkIGZpbmlzaCgpLiBUaGUgYWN0dWFsIGRhdGEgc3RhcnRzIGF0IHRoZSBCeXRlQnVmZmVyJ3MgY3VycmVudCBwb3NpdGlvbixcbiAqIG5vdCBuZWNlc3NhcmlseSBhdCAwLlxuICpcbiAqIEByZXR1cm5zIHtmbGF0YnVmZmVycy5CeXRlQnVmZmVyfVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5kYXRhQnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmJiO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGJ5dGVzIHJlcHJlc2VudGluZyB0aGUgRmxhdEJ1ZmZlci4gT25seSBjYWxsIHRoaXMgYWZ0ZXIgeW91J3ZlXG4gKiBjYWxsZWQgZmluaXNoKCkuXG4gKlxuICogQHJldHVybnMgeyFVaW50OEFycmF5fVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hc1VpbnQ4QXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYmIuYnl0ZXMoKS5zdWJhcnJheSh0aGlzLmJiLnBvc2l0aW9uKCksIHRoaXMuYmIucG9zaXRpb24oKSArIHRoaXMub2Zmc2V0KCkpO1xufTtcblxuLy8vIEBjb25kIEZMQVRCVUZGRVJTX0lOVEVSTkFMXG4vKipcbiAqIFByZXBhcmUgdG8gd3JpdGUgYW4gZWxlbWVudCBvZiBgc2l6ZWAgYWZ0ZXIgYGFkZGl0aW9uYWxfYnl0ZXNgIGhhdmUgYmVlblxuICogd3JpdHRlbiwgZS5nLiBpZiB5b3Ugd3JpdGUgYSBzdHJpbmcsIHlvdSBuZWVkIHRvIGFsaWduIHN1Y2ggdGhlIGludCBsZW5ndGhcbiAqIGZpZWxkIGlzIGFsaWduZWQgdG8gNCBieXRlcywgYW5kIHRoZSBzdHJpbmcgZGF0YSBmb2xsb3dzIGl0IGRpcmVjdGx5LiBJZiBhbGxcbiAqIHlvdSBuZWVkIHRvIGRvIGlzIGFsaWdubWVudCwgYGFkZGl0aW9uYWxfYnl0ZXNgIHdpbGwgYmUgMC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBUaGlzIGlzIHRoZSBvZiB0aGUgbmV3IGVsZW1lbnQgdG8gd3JpdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBhZGRpdGlvbmFsX2J5dGVzIFRoZSBwYWRkaW5nIHNpemVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUucHJlcCA9IGZ1bmN0aW9uKHNpemUsIGFkZGl0aW9uYWxfYnl0ZXMpIHtcbiAgLy8gVHJhY2sgdGhlIGJpZ2dlc3QgdGhpbmcgd2UndmUgZXZlciBhbGlnbmVkIHRvLlxuICBpZiAoc2l6ZSA+IHRoaXMubWluYWxpZ24pIHtcbiAgICB0aGlzLm1pbmFsaWduID0gc2l6ZTtcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGFtb3VudCBvZiBhbGlnbm1lbnQgbmVlZGVkIHN1Y2ggdGhhdCBgc2l6ZWAgaXMgcHJvcGVybHlcbiAgLy8gYWxpZ25lZCBhZnRlciBgYWRkaXRpb25hbF9ieXRlc2BcbiAgdmFyIGFsaWduX3NpemUgPSAoKH4odGhpcy5iYi5jYXBhY2l0eSgpIC0gdGhpcy5zcGFjZSArIGFkZGl0aW9uYWxfYnl0ZXMpKSArIDEpICYgKHNpemUgLSAxKTtcblxuICAvLyBSZWFsbG9jYXRlIHRoZSBidWZmZXIgaWYgbmVlZGVkLlxuICB3aGlsZSAodGhpcy5zcGFjZSA8IGFsaWduX3NpemUgKyBzaXplICsgYWRkaXRpb25hbF9ieXRlcykge1xuICAgIHZhciBvbGRfYnVmX3NpemUgPSB0aGlzLmJiLmNhcGFjaXR5KCk7XG4gICAgdGhpcy5iYiA9IGZsYXRidWZmZXJzLkJ1aWxkZXIuZ3Jvd0J5dGVCdWZmZXIodGhpcy5iYik7XG4gICAgdGhpcy5zcGFjZSArPSB0aGlzLmJiLmNhcGFjaXR5KCkgLSBvbGRfYnVmX3NpemU7XG4gIH1cblxuICB0aGlzLnBhZChhbGlnbl9zaXplKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVfc2l6ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5wYWQgPSBmdW5jdGlvbihieXRlX3NpemUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlX3NpemU7IGkrKykge1xuICAgIHRoaXMuYmIud3JpdGVJbnQ4KC0tdGhpcy5zcGFjZSwgMCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHRoaXMuYmIud3JpdGVJbnQ4KHRoaXMuc3BhY2UgLT0gMSwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUud3JpdGVJbnQxNiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHRoaXMuYmIud3JpdGVJbnQxNih0aGlzLnNwYWNlIC09IDIsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlSW50MzIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB0aGlzLmJiLndyaXRlSW50MzIodGhpcy5zcGFjZSAtPSA0LCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuTG9uZ30gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUud3JpdGVJbnQ2NCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHRoaXMuYmIud3JpdGVJbnQ2NCh0aGlzLnNwYWNlIC09IDgsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLndyaXRlRmxvYXQzMiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHRoaXMuYmIud3JpdGVGbG9hdDMyKHRoaXMuc3BhY2UgLT0gNCwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUud3JpdGVGbG9hdDY0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5iYi53cml0ZUZsb2F0NjQodGhpcy5zcGFjZSAtPSA4LCB2YWx1ZSk7XG59O1xuLy8vIEBlbmRjb25kXG5cbi8qKlxuICogQWRkIGFuIGBpbnQ4YCB0byB0aGUgYnVmZmVyLCBwcm9wZXJseSBhbGlnbmVkLCBhbmQgZ3Jvd3MgdGhlIGJ1ZmZlciAoaWYgbmVjZXNzYXJ5KS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgYGludDhgIHRvIGFkZCB0aGUgdGhlIGJ1ZmZlci5cbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkSW50OCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHRoaXMucHJlcCgxLCAwKTtcbiAgdGhpcy53cml0ZUludDgodmFsdWUpO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gYGludDE2YCB0byB0aGUgYnVmZmVyLCBwcm9wZXJseSBhbGlnbmVkLCBhbmQgZ3Jvd3MgdGhlIGJ1ZmZlciAoaWYgbmVjZXNzYXJ5KS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgYGludDE2YCB0byBhZGQgdGhlIHRoZSBidWZmZXIuXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFkZEludDE2ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5wcmVwKDIsIDApO1xuICB0aGlzLndyaXRlSW50MTYodmFsdWUpO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gYGludDMyYCB0byB0aGUgYnVmZmVyLCBwcm9wZXJseSBhbGlnbmVkLCBhbmQgZ3Jvd3MgdGhlIGJ1ZmZlciAoaWYgbmVjZXNzYXJ5KS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgYGludDMyYCB0byBhZGQgdGhlIHRoZSBidWZmZXIuXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFkZEludDMyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5wcmVwKDQsIDApO1xuICB0aGlzLndyaXRlSW50MzIodmFsdWUpO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gYGludDY0YCB0byB0aGUgYnVmZmVyLCBwcm9wZXJseSBhbGlnbmVkLCBhbmQgZ3Jvd3MgdGhlIGJ1ZmZlciAoaWYgbmVjZXNzYXJ5KS5cbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuTG9uZ30gdmFsdWUgVGhlIGBpbnQ2NGAgdG8gYWRkIHRoZSB0aGUgYnVmZmVyLlxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hZGRJbnQ2NCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHRoaXMucHJlcCg4LCAwKTtcbiAgdGhpcy53cml0ZUludDY0KHZhbHVlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgYGZsb2F0MzJgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBgZmxvYXQzMmAgdG8gYWRkIHRoZSB0aGUgYnVmZmVyLlxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hZGRGbG9hdDMyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdGhpcy5wcmVwKDQsIDApO1xuICB0aGlzLndyaXRlRmxvYXQzMih2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIGBmbG9hdDY0YCB0byB0aGUgYnVmZmVyLCBwcm9wZXJseSBhbGlnbmVkLCBhbmQgZ3Jvd3MgdGhlIGJ1ZmZlciAoaWYgbmVjZXNzYXJ5KS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgYGZsb2F0NjRgIHRvIGFkZCB0aGUgdGhlIGJ1ZmZlci5cbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkRmxvYXQ2NCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHRoaXMucHJlcCg4LCAwKTtcbiAgdGhpcy53cml0ZUZsb2F0NjQodmFsdWUpO1xufTtcblxuLy8vIEBjb25kIEZMQVRCVUZGRVJTX0lOVEVSTkFMXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWZhdWx0VmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRJbnQ4ID0gZnVuY3Rpb24odm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcbiAgICB0aGlzLmFkZEludDgodmFsdWUpO1xuICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdm9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gZGVmYXVsdFZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkSW50MTYgPSBmdW5jdGlvbih2b2Zmc2V0LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0aGlzLmZvcmNlX2RlZmF1bHRzIHx8IHZhbHVlICE9IGRlZmF1bHRWYWx1ZSkge1xuICAgIHRoaXMuYWRkSW50MTYodmFsdWUpO1xuICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdm9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gZGVmYXVsdFZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkSW50MzIgPSBmdW5jdGlvbih2b2Zmc2V0LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0aGlzLmZvcmNlX2RlZmF1bHRzIHx8IHZhbHVlICE9IGRlZmF1bHRWYWx1ZSkge1xuICAgIHRoaXMuYWRkSW50MzIodmFsdWUpO1xuICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdm9mZnNldFxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5Mb25nfSB2YWx1ZVxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5Mb25nfSBkZWZhdWx0VmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRJbnQ2NCA9IGZ1bmN0aW9uKHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHRoaXMuZm9yY2VfZGVmYXVsdHMgfHwgIXZhbHVlLmVxdWFscyhkZWZhdWx0VmFsdWUpKSB7XG4gICAgdGhpcy5hZGRJbnQ2NCh2YWx1ZSk7XG4gICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWZhdWx0VmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuYWRkRmllbGRGbG9hdDMyID0gZnVuY3Rpb24odm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcbiAgICB0aGlzLmFkZEZsb2F0MzIodmFsdWUpO1xuICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdm9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gZGVmYXVsdFZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkRmxvYXQ2NCA9IGZ1bmN0aW9uKHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHRoaXMuZm9yY2VfZGVmYXVsdHMgfHwgdmFsdWUgIT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgdGhpcy5hZGRGbG9hdDY0KHZhbHVlKTtcbiAgICB0aGlzLnNsb3Qodm9mZnNldCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZvZmZzZXRcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSB2YWx1ZVxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5PZmZzZXR9IGRlZmF1bHRWYWx1ZVxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5hZGRGaWVsZE9mZnNldCA9IGZ1bmN0aW9uKHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHRoaXMuZm9yY2VfZGVmYXVsdHMgfHwgdmFsdWUgIT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgdGhpcy5hZGRPZmZzZXQodmFsdWUpO1xuICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdHJ1Y3RzIGFyZSBzdG9yZWQgaW5saW5lLCBzbyBub3RoaW5nIGFkZGl0aW9uYWwgaXMgYmVpbmcgYWRkZWQuIGBkYCBpcyBhbHdheXMgMC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdm9mZnNldFxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5PZmZzZXR9IHZhbHVlXG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLk9mZnNldH0gZGVmYXVsdFZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFkZEZpZWxkU3RydWN0ID0gZnVuY3Rpb24odm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodmFsdWUgIT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgdGhpcy5uZXN0ZWQodmFsdWUpO1xuICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdHJ1Y3R1cmVzIGFyZSBhbHdheXMgc3RvcmVkIGlubGluZSwgdGhleSBuZWVkIHRvIGJlIGNyZWF0ZWQgcmlnaHRcbiAqIHdoZXJlIHRoZXkncmUgdXNlZC4gIFlvdSdsbCBnZXQgdGhpcyBhc3NlcnRpb24gZmFpbHVyZSBpZiB5b3VcbiAqIGNyZWF0ZWQgaXQgZWxzZXdoZXJlLlxuICpcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSBvYmogVGhlIG9mZnNldCBvZiB0aGUgY3JlYXRlZCBvYmplY3RcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUubmVzdGVkID0gZnVuY3Rpb24ob2JqKSB7XG4gIGlmIChvYmogIT0gdGhpcy5vZmZzZXQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IHN0cnVjdCBtdXN0IGJlIHNlcmlhbGl6ZWQgaW5saW5lLicpO1xuICB9XG59O1xuXG4vKipcbiAqIFNob3VsZCBub3QgYmUgY3JlYXRpbmcgYW55IG90aGVyIG9iamVjdCwgc3RyaW5nIG9yIHZlY3RvclxuICogd2hpbGUgYW4gb2JqZWN0IGlzIGJlaW5nIGNvbnN0cnVjdGVkXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLm5vdE5lc3RlZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pc05lc3RlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IG9iamVjdCBzZXJpYWxpemF0aW9uIG11c3Qgbm90IGJlIG5lc3RlZC4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgdGhlIGN1cnJlbnQgdnRhYmxlIGF0IGB2b2Zmc2V0YCB0byB0aGUgY3VycmVudCBsb2NhdGlvbiBpbiB0aGUgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB2b2Zmc2V0XG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLnNsb3QgPSBmdW5jdGlvbih2b2Zmc2V0KSB7XG4gIHRoaXMudnRhYmxlW3ZvZmZzZXRdID0gdGhpcy5vZmZzZXQoKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge2ZsYXRidWZmZXJzLk9mZnNldH0gT2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlci5cbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmJiLmNhcGFjaXR5KCkgLSB0aGlzLnNwYWNlO1xufTtcblxuLyoqXG4gKiBEb3VibGVzIHRoZSBzaXplIG9mIHRoZSBiYWNraW5nIEJ5dGVCdWZmZXIgYW5kIGNvcGllcyB0aGUgb2xkIGRhdGEgdG93YXJkc1xuICogdGhlIGVuZCBvZiB0aGUgbmV3IGJ1ZmZlciAoc2luY2Ugd2UgYnVpbGQgdGhlIGJ1ZmZlciBiYWNrd2FyZHMpLlxuICpcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcn0gYmIgVGhlIGN1cnJlbnQgYnVmZmVyIHdpdGggdGhlIGV4aXN0aW5nIGRhdGFcbiAqIEByZXR1cm5zIHshZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcn0gQSBuZXcgYnl0ZSBidWZmZXIgd2l0aCB0aGUgb2xkIGRhdGEgY29waWVkXG4gKiB0byBpdC4gVGhlIGRhdGEgaXMgbG9jYXRlZCBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIuXG4gKlxuICogdWludDhBcnJheS5zZXQoKSBmb3JtYWxseSB0YWtlcyB7QXJyYXk8bnVtYmVyPnxBcnJheUJ1ZmZlclZpZXd9LCBzbyB0byBwYXNzXG4gKiBpdCBhIHVpbnQ4QXJyYXkgd2UgbmVlZCB0byBzdXBwcmVzcyB0aGUgdHlwZSBjaGVjazpcbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc31cbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5ncm93Qnl0ZUJ1ZmZlciA9IGZ1bmN0aW9uKGJiKSB7XG4gIHZhciBvbGRfYnVmX3NpemUgPSBiYi5jYXBhY2l0eSgpO1xuXG4gIC8vIEVuc3VyZSB3ZSBkb24ndCBncm93IGJleW9uZCB3aGF0IGZpdHMgaW4gYW4gaW50LlxuICBpZiAob2xkX2J1Zl9zaXplICYgMHhDMDAwMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IGNhbm5vdCBncm93IGJ1ZmZlciBiZXlvbmQgMiBnaWdhYnl0ZXMuJyk7XG4gIH1cblxuICB2YXIgbmV3X2J1Zl9zaXplID0gb2xkX2J1Zl9zaXplIDw8IDE7XG4gIHZhciBuYmIgPSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLmFsbG9jYXRlKG5ld19idWZfc2l6ZSk7XG4gIG5iYi5zZXRQb3NpdGlvbihuZXdfYnVmX3NpemUgLSBvbGRfYnVmX3NpemUpO1xuICBuYmIuYnl0ZXMoKS5zZXQoYmIuYnl0ZXMoKSwgbmV3X2J1Zl9zaXplIC0gb2xkX2J1Zl9zaXplKTtcbiAgcmV0dXJuIG5iYjtcbn07XG4vLy8gQGVuZGNvbmRcblxuLyoqXG4gKiBBZGRzIG9uIG9mZnNldCwgcmVsYXRpdmUgdG8gd2hlcmUgaXQgd2lsbCBiZSB3cml0dGVuLlxuICpcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSBvZmZzZXQgVGhlIG9mZnNldCB0byBhZGQuXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLmFkZE9mZnNldCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICB0aGlzLnByZXAoZmxhdGJ1ZmZlcnMuU0laRU9GX0lOVCwgMCk7IC8vIEVuc3VyZSBhbGlnbm1lbnQgaXMgYWxyZWFkeSBkb25lLlxuICB0aGlzLndyaXRlSW50MzIodGhpcy5vZmZzZXQoKSAtIG9mZnNldCArIGZsYXRidWZmZXJzLlNJWkVPRl9JTlQpO1xufTtcblxuLy8vIEBjb25kIEZMQVRCVUZGRVJTX0lOVEVSTkFMXG4vKipcbiAqIFN0YXJ0IGVuY29kaW5nIGEgbmV3IG9iamVjdCBpbiB0aGUgYnVmZmVyLiAgVXNlcnMgd2lsbCBub3QgdXN1YWxseSBuZWVkIHRvXG4gKiBjYWxsIHRoaXMgZGlyZWN0bHkuIFRoZSBGbGF0QnVmZmVycyBjb21waWxlciB3aWxsIGdlbmVyYXRlIGhlbHBlciBtZXRob2RzXG4gKiB0aGF0IGNhbGwgdGhpcyBtZXRob2QgaW50ZXJuYWxseS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtZmllbGRzXG4gKi9cbmZsYXRidWZmZXJzLkJ1aWxkZXIucHJvdG90eXBlLnN0YXJ0T2JqZWN0ID0gZnVuY3Rpb24obnVtZmllbGRzKSB7XG4gIHRoaXMubm90TmVzdGVkKCk7XG4gIGlmICh0aGlzLnZ0YWJsZSA9PSBudWxsKSB7XG4gICAgdGhpcy52dGFibGUgPSBbXTtcbiAgfVxuICB0aGlzLnZ0YWJsZV9pbl91c2UgPSBudW1maWVsZHM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtZmllbGRzOyBpKyspIHtcbiAgICB0aGlzLnZ0YWJsZVtpXSA9IDA7IC8vIFRoaXMgd2lsbCBwdXNoIGFkZGl0aW9uYWwgZWxlbWVudHMgYXMgbmVlZGVkXG4gIH1cbiAgdGhpcy5pc05lc3RlZCA9IHRydWU7XG4gIHRoaXMub2JqZWN0X3N0YXJ0ID0gdGhpcy5vZmZzZXQoKTtcbn07XG5cbi8qKlxuICogRmluaXNoIG9mZiB3cml0aW5nIHRoZSBvYmplY3QgdGhhdCBpcyB1bmRlciBjb25zdHJ1Y3Rpb24uXG4gKlxuICogQHJldHVybnMge2ZsYXRidWZmZXJzLk9mZnNldH0gVGhlIG9mZnNldCB0byB0aGUgb2JqZWN0IGluc2lkZSBgZGF0YUJ1ZmZlcmBcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuZW5kT2JqZWN0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnZ0YWJsZSA9PSBudWxsIHx8ICF0aGlzLmlzTmVzdGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogZW5kT2JqZWN0IGNhbGxlZCB3aXRob3V0IHN0YXJ0T2JqZWN0Jyk7XG4gIH1cblxuICB0aGlzLmFkZEludDMyKDApO1xuICB2YXIgdnRhYmxlbG9jID0gdGhpcy5vZmZzZXQoKTtcblxuICAvLyBUcmltIHRyYWlsaW5nIHplcm9lcy5cbiAgdmFyIGkgPSB0aGlzLnZ0YWJsZV9pbl91c2UgLSAxO1xuICBmb3IgKDsgaSA+PSAwICYmIHRoaXMudnRhYmxlW2ldID09IDA7IGktLSkge31cbiAgdmFyIHRyaW1tZWRfc2l6ZSA9IGkgKyAxO1xuXG4gIC8vIFdyaXRlIG91dCB0aGUgY3VycmVudCB2dGFibGUuXG4gIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgIC8vIE9mZnNldCByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIHRhYmxlLlxuICAgIHRoaXMuYWRkSW50MTYodGhpcy52dGFibGVbaV0gIT0gMCA/IHZ0YWJsZWxvYyAtIHRoaXMudnRhYmxlW2ldIDogMCk7XG4gIH1cblxuICB2YXIgc3RhbmRhcmRfZmllbGRzID0gMjsgLy8gVGhlIGZpZWxkcyBiZWxvdzpcbiAgdGhpcy5hZGRJbnQxNih2dGFibGVsb2MgLSB0aGlzLm9iamVjdF9zdGFydCk7XG4gIHZhciBsZW4gPSAodHJpbW1lZF9zaXplICsgc3RhbmRhcmRfZmllbGRzKSAqIGZsYXRidWZmZXJzLlNJWkVPRl9TSE9SVDtcbiAgdGhpcy5hZGRJbnQxNihsZW4pO1xuXG4gIC8vIFNlYXJjaCBmb3IgYW4gZXhpc3RpbmcgdnRhYmxlIHRoYXQgbWF0Y2hlcyB0aGUgY3VycmVudCBvbmUuXG4gIHZhciBleGlzdGluZ192dGFibGUgPSAwO1xuICB2YXIgdnQxID0gdGhpcy5zcGFjZTtcbm91dGVyX2xvb3A6XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnZ0YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdnQyID0gdGhpcy5iYi5jYXBhY2l0eSgpIC0gdGhpcy52dGFibGVzW2ldO1xuICAgIGlmIChsZW4gPT0gdGhpcy5iYi5yZWFkSW50MTYodnQyKSkge1xuICAgICAgZm9yICh2YXIgaiA9IGZsYXRidWZmZXJzLlNJWkVPRl9TSE9SVDsgaiA8IGxlbjsgaiArPSBmbGF0YnVmZmVycy5TSVpFT0ZfU0hPUlQpIHtcbiAgICAgICAgaWYgKHRoaXMuYmIucmVhZEludDE2KHZ0MSArIGopICE9IHRoaXMuYmIucmVhZEludDE2KHZ0MiArIGopKSB7XG4gICAgICAgICAgY29udGludWUgb3V0ZXJfbG9vcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXhpc3RpbmdfdnRhYmxlID0gdGhpcy52dGFibGVzW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4aXN0aW5nX3Z0YWJsZSkge1xuICAgIC8vIEZvdW5kIGEgbWF0Y2g6XG4gICAgLy8gUmVtb3ZlIHRoZSBjdXJyZW50IHZ0YWJsZS5cbiAgICB0aGlzLnNwYWNlID0gdGhpcy5iYi5jYXBhY2l0eSgpIC0gdnRhYmxlbG9jO1xuXG4gICAgLy8gUG9pbnQgdGFibGUgdG8gZXhpc3RpbmcgdnRhYmxlLlxuICAgIHRoaXMuYmIud3JpdGVJbnQzMih0aGlzLnNwYWNlLCBleGlzdGluZ192dGFibGUgLSB2dGFibGVsb2MpO1xuICB9IGVsc2Uge1xuICAgIC8vIE5vIG1hdGNoOlxuICAgIC8vIEFkZCB0aGUgbG9jYXRpb24gb2YgdGhlIGN1cnJlbnQgdnRhYmxlIHRvIHRoZSBsaXN0IG9mIHZ0YWJsZXMuXG4gICAgdGhpcy52dGFibGVzLnB1c2godGhpcy5vZmZzZXQoKSk7XG5cbiAgICAvLyBQb2ludCB0YWJsZSB0byBjdXJyZW50IHZ0YWJsZS5cbiAgICB0aGlzLmJiLndyaXRlSW50MzIodGhpcy5iYi5jYXBhY2l0eSgpIC0gdnRhYmxlbG9jLCB0aGlzLm9mZnNldCgpIC0gdnRhYmxlbG9jKTtcbiAgfVxuXG4gIHRoaXMuaXNOZXN0ZWQgPSBmYWxzZTtcbiAgcmV0dXJuIHZ0YWJsZWxvYztcbn07XG4vLy8gQGVuZGNvbmRcblxuLyoqXG4gKiBGaW5hbGl6ZSBhIGJ1ZmZlciwgcG9pdGluZyB0byB0aGUgZ2l2ZW4gYHJvb3RfdGFibGVgLlxuICpcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuT2Zmc2V0fSByb290X3RhYmxlXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9maWxlX2lkZW50aWZpZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9zaXplX3ByZWZpeFxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbihyb290X3RhYmxlLCBvcHRfZmlsZV9pZGVudGlmaWVyLCBvcHRfc2l6ZV9wcmVmaXgpIHtcbiAgdmFyIHNpemVfcHJlZml4ID0gb3B0X3NpemVfcHJlZml4ID8gZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIIDogMDtcbiAgaWYgKG9wdF9maWxlX2lkZW50aWZpZXIpIHtcbiAgICB2YXIgZmlsZV9pZGVudGlmaWVyID0gb3B0X2ZpbGVfaWRlbnRpZmllcjtcbiAgICB0aGlzLnByZXAodGhpcy5taW5hbGlnbiwgZmxhdGJ1ZmZlcnMuU0laRU9GX0lOVCArXG4gICAgICBmbGF0YnVmZmVycy5GSUxFX0lERU5USUZJRVJfTEVOR1RIICsgc2l6ZV9wcmVmaXgpO1xuICAgIGlmIChmaWxlX2lkZW50aWZpZXIubGVuZ3RoICE9IGZsYXRidWZmZXJzLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IGZpbGUgaWRlbnRpZmllciBtdXN0IGJlIGxlbmd0aCAnICtcbiAgICAgICAgZmxhdGJ1ZmZlcnMuRklMRV9JREVOVElGSUVSX0xFTkdUSCk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSBmbGF0YnVmZmVycy5GSUxFX0lERU5USUZJRVJfTEVOR1RIIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRoaXMud3JpdGVJbnQ4KGZpbGVfaWRlbnRpZmllci5jaGFyQ29kZUF0KGkpKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5wcmVwKHRoaXMubWluYWxpZ24sIGZsYXRidWZmZXJzLlNJWkVPRl9JTlQgKyBzaXplX3ByZWZpeCk7XG4gIHRoaXMuYWRkT2Zmc2V0KHJvb3RfdGFibGUpO1xuICBpZiAoc2l6ZV9wcmVmaXgpIHtcbiAgICB0aGlzLmFkZEludDMyKHRoaXMuYmIuY2FwYWNpdHkoKSAtIHRoaXMuc3BhY2UpO1xuICB9XG4gIHRoaXMuYmIuc2V0UG9zaXRpb24odGhpcy5zcGFjZSk7XG59O1xuXG4vKipcbiAqIEZpbmFsaXplIGEgc2l6ZSBwcmVmaXhlZCBidWZmZXIsIHBvaW50aW5nIHRvIHRoZSBnaXZlbiBgcm9vdF90YWJsZWAuXG4gKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5PZmZzZXR9IHJvb3RfdGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X2ZpbGVfaWRlbnRpZmllclxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5maW5pc2hTaXplUHJlZml4ZWQgPSBmdW5jdGlvbiAocm9vdF90YWJsZSwgb3B0X2ZpbGVfaWRlbnRpZmllcikge1xuICB0aGlzLmZpbmlzaChyb290X3RhYmxlLCBvcHRfZmlsZV9pZGVudGlmaWVyLCB0cnVlKTtcbn07XG5cbi8vLyBAY29uZCBGTEFUQlVGRkVSU19JTlRFUk5BTFxuLyoqXG4gKiBUaGlzIGNoZWNrcyBhIHJlcXVpcmVkIGZpZWxkIGhhcyBiZWVuIHNldCBpbiBhIGdpdmVuIHRhYmxlIHRoYXQgaGFzXG4gKiBqdXN0IGJlZW4gY29uc3RydWN0ZWQuXG4gKlxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5PZmZzZXR9IHRhYmxlXG4gKiBAcGFyYW0ge251bWJlcn0gZmllbGRcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUucmVxdWlyZWRGaWVsZCA9IGZ1bmN0aW9uKHRhYmxlLCBmaWVsZCkge1xuICB2YXIgdGFibGVfc3RhcnQgPSB0aGlzLmJiLmNhcGFjaXR5KCkgLSB0YWJsZTtcbiAgdmFyIHZ0YWJsZV9zdGFydCA9IHRhYmxlX3N0YXJ0IC0gdGhpcy5iYi5yZWFkSW50MzIodGFibGVfc3RhcnQpO1xuICB2YXIgb2sgPSB0aGlzLmJiLnJlYWRJbnQxNih2dGFibGVfc3RhcnQgKyBmaWVsZCkgIT0gMDtcblxuICAvLyBJZiB0aGlzIGZhaWxzLCB0aGUgY2FsbGVyIHdpbGwgc2hvdyB3aGF0IGZpZWxkIG5lZWRzIHRvIGJlIHNldC5cbiAgaWYgKCFvaykge1xuICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IGZpZWxkICcgKyBmaWVsZCArICcgbXVzdCBiZSBzZXQnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdGFydCBhIG5ldyBhcnJheS92ZWN0b3Igb2Ygb2JqZWN0cy4gIFVzZXJzIHVzdWFsbHkgd2lsbCBub3QgY2FsbFxuICogdGhpcyBkaXJlY3RseS4gVGhlIEZsYXRCdWZmZXJzIGNvbXBpbGVyIHdpbGwgY3JlYXRlIGEgc3RhcnQvZW5kXG4gKiBtZXRob2QgZm9yIHZlY3RvciB0eXBlcyBpbiBnZW5lcmF0ZWQgY29kZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZWxlbV9zaXplIFRoZSBzaXplIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1fZWxlbXMgVGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbGlnbm1lbnQgVGhlIGFsaWdubWVudCBvZiB0aGUgYXJyYXlcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuc3RhcnRWZWN0b3IgPSBmdW5jdGlvbihlbGVtX3NpemUsIG51bV9lbGVtcywgYWxpZ25tZW50KSB7XG4gIHRoaXMubm90TmVzdGVkKCk7XG4gIHRoaXMudmVjdG9yX251bV9lbGVtcyA9IG51bV9lbGVtcztcbiAgdGhpcy5wcmVwKGZsYXRidWZmZXJzLlNJWkVPRl9JTlQsIGVsZW1fc2l6ZSAqIG51bV9lbGVtcyk7XG4gIHRoaXMucHJlcChhbGlnbm1lbnQsIGVsZW1fc2l6ZSAqIG51bV9lbGVtcyk7IC8vIEp1c3QgaW4gY2FzZSBhbGlnbm1lbnQgPiBpbnQuXG59O1xuXG4vKipcbiAqIEZpbmlzaCBvZmYgdGhlIGNyZWF0aW9uIG9mIGFuIGFycmF5IGFuZCBhbGwgaXRzIGVsZW1lbnRzLiBUaGUgYXJyYXkgbXVzdCBiZVxuICogY3JlYXRlZCB3aXRoIGBzdGFydFZlY3RvcmAuXG4gKlxuICogQHJldHVybnMge2ZsYXRidWZmZXJzLk9mZnNldH0gVGhlIG9mZnNldCBhdCB3aGljaCB0aGUgbmV3bHkgY3JlYXRlZCBhcnJheVxuICogc3RhcnRzLlxuICovXG5mbGF0YnVmZmVycy5CdWlsZGVyLnByb3RvdHlwZS5lbmRWZWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy53cml0ZUludDMyKHRoaXMudmVjdG9yX251bV9lbGVtcyk7XG4gIHJldHVybiB0aGlzLm9mZnNldCgpO1xufTtcbi8vLyBAZW5kY29uZFxuXG4vKipcbiAqIEVuY29kZSB0aGUgc3RyaW5nIGBzYCBpbiB0aGUgYnVmZmVyIHVzaW5nIFVURi04LiBJZiBhIFVpbnQ4QXJyYXkgaXMgcGFzc2VkXG4gKiBpbnN0ZWFkIG9mIGEgc3RyaW5nLCBpdCBpcyBhc3N1bWVkIHRvIGNvbnRhaW4gdmFsaWQgVVRGLTggZW5jb2RlZCBkYXRhLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFVpbnQ4QXJyYXl9IHMgVGhlIHN0cmluZyB0byBlbmNvZGVcbiAqIEByZXR1cm4ge2ZsYXRidWZmZXJzLk9mZnNldH0gVGhlIG9mZnNldCBpbiB0aGUgYnVmZmVyIHdoZXJlIHRoZSBlbmNvZGVkIHN0cmluZyBzdGFydHNcbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuY3JlYXRlU3RyaW5nID0gZnVuY3Rpb24ocykge1xuICBpZiAocyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICB2YXIgdXRmOCA9IHM7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHV0ZjggPSBbXTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IHMubGVuZ3RoKSB7XG4gICAgICB2YXIgY29kZVBvaW50O1xuXG4gICAgICAvLyBEZWNvZGUgVVRGLTE2XG4gICAgICB2YXIgYSA9IHMuY2hhckNvZGVBdChpKyspO1xuICAgICAgaWYgKGEgPCAweEQ4MDAgfHwgYSA+PSAweERDMDApIHtcbiAgICAgICAgY29kZVBvaW50ID0gYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBiID0gcy5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIGNvZGVQb2ludCA9IChhIDw8IDEwKSArIGIgKyAoMHgxMDAwMCAtICgweEQ4MDAgPDwgMTApIC0gMHhEQzAwKTtcbiAgICAgIH1cblxuICAgICAgLy8gRW5jb2RlIFVURi04XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgICB1dGY4LnB1c2goY29kZVBvaW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgICAgIHV0ZjgucHVzaCgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhDMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIHV0ZjgucHVzaCgoKGNvZGVQb2ludCA+PiAxMikgJiAweDBGKSB8IDB4RTApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGY4LnB1c2goXG4gICAgICAgICAgICAgICgoY29kZVBvaW50ID4+IDE4KSAmIDB4MDcpIHwgMHhGMCxcbiAgICAgICAgICAgICAgKChjb2RlUG9pbnQgPj4gMTIpICYgMHgzRikgfCAweDgwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXRmOC5wdXNoKCgoY29kZVBvaW50ID4+IDYpICYgMHgzRikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICB1dGY4LnB1c2goKGNvZGVQb2ludCAmIDB4M0YpIHwgMHg4MCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5hZGRJbnQ4KDApO1xuICB0aGlzLnN0YXJ0VmVjdG9yKDEsIHV0ZjgubGVuZ3RoLCAxKTtcbiAgdGhpcy5iYi5zZXRQb3NpdGlvbih0aGlzLnNwYWNlIC09IHV0ZjgubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDAsIG9mZnNldCA9IHRoaXMuc3BhY2UsIGJ5dGVzID0gdGhpcy5iYi5ieXRlcygpOyBpIDwgdXRmOC5sZW5ndGg7IGkrKykge1xuICAgIGJ5dGVzW29mZnNldCsrXSA9IHV0ZjhbaV07XG4gIH1cbiAgcmV0dXJuIHRoaXMuZW5kVmVjdG9yKCk7XG59O1xuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGF2b2lkIGdlbmVyYXRlZCBjb2RlIGRlcGVuZGluZyBvbiB0aGlzIGZpbGUgZGlyZWN0bHkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGxvd1xuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hcbiAqIEByZXR1cm5zIHshZmxhdGJ1ZmZlcnMuTG9uZ31cbiAqL1xuZmxhdGJ1ZmZlcnMuQnVpbGRlci5wcm90b3R5cGUuY3JlYXRlTG9uZyA9IGZ1bmN0aW9uKGxvdywgaGlnaCkge1xuICByZXR1cm4gZmxhdGJ1ZmZlcnMuTG9uZy5jcmVhdGUobG93LCBoaWdoKTtcbn07XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vIEBjb25kIEZMQVRCVUZGRVJTX0lOVEVSTkFMXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBCeXRlQnVmZmVyIHdpdGggYSBnaXZlbiBhcnJheSBvZiBieXRlcyAoYFVpbnQ4QXJyYXlgKS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7VWludDhBcnJheX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuYnl0ZXNfID0gYnl0ZXM7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnBvc2l0aW9uXyA9IDA7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbmQgYWxsb2NhdGUgYSBuZXcgQnl0ZUJ1ZmZlciB3aXRoIGEgZ2l2ZW4gc2l6ZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYnl0ZV9zaXplXG4gKiBAcmV0dXJucyB7IWZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIuYWxsb2NhdGUgPSBmdW5jdGlvbihieXRlX3NpemUpIHtcbiAgcmV0dXJuIG5ldyBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKG5ldyBVaW50OEFycmF5KGJ5dGVfc2l6ZSkpO1xufTtcblxuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wb3NpdGlvbl8gPSAwO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHVuZGVybHlpbmcgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5ieXRlc187XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYnVmZmVyJ3MgcG9zaXRpb24uXG4gKlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucG9zaXRpb25fO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGJ1ZmZlcidzIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvblxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gIHRoaXMucG9zaXRpb25fID0gcG9zaXRpb247XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYnVmZmVyJ3MgY2FwYWNpdHkuXG4gKlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuY2FwYWNpdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYnl0ZXNfLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMucmVhZFVpbnQ4KG9mZnNldCkgPDwgMjQgPj4gMjQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRVaW50OCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gdGhpcy5ieXRlc19bb2Zmc2V0XTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLnJlYWRVaW50MTYob2Zmc2V0KSA8PCAxNiA+PiAxNjtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNiA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gdGhpcy5ieXRlc19bb2Zmc2V0XSB8IHRoaXMuYnl0ZXNfW29mZnNldCArIDFdIDw8IDg7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMiA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gdGhpcy5ieXRlc19bb2Zmc2V0XSB8IHRoaXMuYnl0ZXNfW29mZnNldCArIDFdIDw8IDggfCB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAyXSA8PCAxNiB8IHRoaXMuYnl0ZXNfW29mZnNldCArIDNdIDw8IDI0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLnJlYWRJbnQzMihvZmZzZXQpID4+PiAwO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7IWZsYXRidWZmZXJzLkxvbmd9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ2NCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gbmV3IGZsYXRidWZmZXJzLkxvbmcodGhpcy5yZWFkSW50MzIob2Zmc2V0KSwgdGhpcy5yZWFkSW50MzIob2Zmc2V0ICsgNCkpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7IWZsYXRidWZmZXJzLkxvbmd9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLnJlYWRVaW50NjQgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgcmV0dXJuIG5ldyBmbGF0YnVmZmVycy5Mb25nKHRoaXMucmVhZFVpbnQzMihvZmZzZXQpLCB0aGlzLnJlYWRVaW50MzIob2Zmc2V0ICsgNCkpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXQzMiA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICBmbGF0YnVmZmVycy5pbnQzMlswXSA9IHRoaXMucmVhZEludDMyKG9mZnNldCk7XG4gIHJldHVybiBmbGF0YnVmZmVycy5mbG9hdDMyWzBdO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXQ2NCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICBmbGF0YnVmZmVycy5pbnQzMltmbGF0YnVmZmVycy5pc0xpdHRsZUVuZGlhbiA/IDAgOiAxXSA9IHRoaXMucmVhZEludDMyKG9mZnNldCk7XG4gIGZsYXRidWZmZXJzLmludDMyW2ZsYXRidWZmZXJzLmlzTGl0dGxlRW5kaWFuID8gMSA6IDBdID0gdGhpcy5yZWFkSW50MzIob2Zmc2V0ICsgNCk7XG4gIHJldHVybiBmbGF0YnVmZmVycy5mbG9hdDY0WzBdO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcnxib29sZWFufSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbihvZmZzZXQsIHZhbHVlKSB7XG4gIHRoaXMuYnl0ZXNfW29mZnNldF0gPSAvKiogQHR5cGUge251bWJlcn0gKi8odmFsdWUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50OCA9IGZ1bmN0aW9uKG9mZnNldCwgdmFsdWUpIHtcbiAgdGhpcy5ieXRlc19bb2Zmc2V0XSA9IHZhbHVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNiA9IGZ1bmN0aW9uKG9mZnNldCwgdmFsdWUpIHtcbiAgdGhpcy5ieXRlc19bb2Zmc2V0XSA9IHZhbHVlO1xuICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+IDg7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNiA9IGZ1bmN0aW9uKG9mZnNldCwgdmFsdWUpIHtcbiAgICB0aGlzLmJ5dGVzX1tvZmZzZXRdID0gdmFsdWU7XG4gICAgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+PiA4O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMiA9IGZ1bmN0aW9uKG9mZnNldCwgdmFsdWUpIHtcbiAgdGhpcy5ieXRlc19bb2Zmc2V0XSA9IHZhbHVlO1xuICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+IDg7XG4gIHRoaXMuYnl0ZXNfW29mZnNldCArIDJdID0gdmFsdWUgPj4gMTY7XG4gIHRoaXMuYnl0ZXNfW29mZnNldCArIDNdID0gdmFsdWUgPj4gMjQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMiA9IGZ1bmN0aW9uKG9mZnNldCwgdmFsdWUpIHtcbiAgICB0aGlzLmJ5dGVzX1tvZmZzZXRdID0gdmFsdWU7XG4gICAgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+PiA4O1xuICAgIHRoaXMuYnl0ZXNfW29mZnNldCArIDJdID0gdmFsdWUgPj4gMTY7XG4gICAgdGhpcy5ieXRlc19bb2Zmc2V0ICsgM10gPSB2YWx1ZSA+PiAyNDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtmbGF0YnVmZmVycy5Mb25nfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDY0ID0gZnVuY3Rpb24ob2Zmc2V0LCB2YWx1ZSkge1xuICB0aGlzLndyaXRlSW50MzIob2Zmc2V0LCB2YWx1ZS5sb3cpO1xuICB0aGlzLndyaXRlSW50MzIob2Zmc2V0ICsgNCwgdmFsdWUuaGlnaCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuTG9uZ30gdmFsdWVcbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50NjQgPSBmdW5jdGlvbihvZmZzZXQsIHZhbHVlKSB7XG4gICAgdGhpcy53cml0ZVVpbnQzMihvZmZzZXQsIHZhbHVlLmxvdyk7XG4gICAgdGhpcy53cml0ZVVpbnQzMihvZmZzZXQgKyA0LCB2YWx1ZS5oaWdoKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXQzMiA9IGZ1bmN0aW9uKG9mZnNldCwgdmFsdWUpIHtcbiAgZmxhdGJ1ZmZlcnMuZmxvYXQzMlswXSA9IHZhbHVlO1xuICB0aGlzLndyaXRlSW50MzIob2Zmc2V0LCBmbGF0YnVmZmVycy5pbnQzMlswXSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0NjQgPSBmdW5jdGlvbihvZmZzZXQsIHZhbHVlKSB7XG4gIGZsYXRidWZmZXJzLmZsb2F0NjRbMF0gPSB2YWx1ZTtcbiAgdGhpcy53cml0ZUludDMyKG9mZnNldCwgZmxhdGJ1ZmZlcnMuaW50MzJbZmxhdGJ1ZmZlcnMuaXNMaXR0bGVFbmRpYW4gPyAwIDogMV0pO1xuICB0aGlzLndyaXRlSW50MzIob2Zmc2V0ICsgNCwgZmxhdGJ1ZmZlcnMuaW50MzJbZmxhdGJ1ZmZlcnMuaXNMaXR0bGVFbmRpYW4gPyAxIDogMF0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGZpbGUgaWRlbnRpZmllci4gICBCZWhhdmlvciBpcyB1bmRlZmluZWQgZm9yIEZsYXRCdWZmZXJzIHdob3NlXG4gKiBzY2hlbWEgZG9lcyBub3QgaW5jbHVkZSBhIGZpbGVfaWRlbnRpZmllciAobGlrZWx5IHBvaW50cyBhdCBwYWRkaW5nIG9yIHRoZVxuICogc3RhcnQgb2YgYSB0aGUgcm9vdCB2dGFibGUpLlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuZ2V0QnVmZmVySWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5ieXRlc18ubGVuZ3RoIDwgdGhpcy5wb3NpdGlvbl8gKyBmbGF0YnVmZmVycy5TSVpFT0ZfSU5UICtcbiAgICAgIGZsYXRidWZmZXJzLkZJTEVfSURFTlRJRklFUl9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdGbGF0QnVmZmVyczogQnl0ZUJ1ZmZlciBpcyB0b28gc2hvcnQgdG8gY29udGFpbiBhbiBpZGVudGlmaWVyLicpO1xuICB9XG4gIHZhciByZXN1bHQgPSBcIlwiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZsYXRidWZmZXJzLkZJTEVfSURFTlRJRklFUl9MRU5HVEg7IGkrKykge1xuICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICB0aGlzLnJlYWRJbnQ4KHRoaXMucG9zaXRpb25fICsgZmxhdGJ1ZmZlcnMuU0laRU9GX0lOVCArIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBMb29rIHVwIGEgZmllbGQgaW4gdGhlIHZ0YWJsZSwgcmV0dXJuIGFuIG9mZnNldCBpbnRvIHRoZSBvYmplY3QsIG9yIDAgaWYgdGhlXG4gKiBmaWVsZCBpcyBub3QgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYmJfcG9zXG4gKiBAcGFyYW0ge251bWJlcn0gdnRhYmxlX29mZnNldFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX19vZmZzZXQgPSBmdW5jdGlvbihiYl9wb3MsIHZ0YWJsZV9vZmZzZXQpIHtcbiAgdmFyIHZ0YWJsZSA9IGJiX3BvcyAtIHRoaXMucmVhZEludDMyKGJiX3Bvcyk7XG4gIHJldHVybiB2dGFibGVfb2Zmc2V0IDwgdGhpcy5yZWFkSW50MTYodnRhYmxlKSA/IHRoaXMucmVhZEludDE2KHZ0YWJsZSArIHZ0YWJsZV9vZmZzZXQpIDogMDtcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhbnkgVGFibGUtZGVyaXZlZCB0eXBlIHRvIHBvaW50IHRvIHRoZSB1bmlvbiBhdCB0aGUgZ2l2ZW4gb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7ZmxhdGJ1ZmZlcnMuVGFibGV9IHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHtmbGF0YnVmZmVycy5UYWJsZX1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX191bmlvbiA9IGZ1bmN0aW9uKHQsIG9mZnNldCkge1xuICB0LmJiX3BvcyA9IG9mZnNldCArIHRoaXMucmVhZEludDMyKG9mZnNldCk7XG4gIHQuYmIgPSB0aGlzO1xuICByZXR1cm4gdDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgSmF2YVNjcmlwdCBzdHJpbmcgZnJvbSBVVEYtOCBkYXRhIHN0b3JlZCBpbnNpZGUgdGhlIEZsYXRCdWZmZXIuXG4gKiBUaGlzIGFsbG9jYXRlcyBhIG5ldyBzdHJpbmcgYW5kIGNvbnZlcnRzIHRvIHdpZGUgY2hhcnMgdXBvbiBlYWNoIGFjY2Vzcy5cbiAqXG4gKiBUbyBhdm9pZCB0aGUgY29udmVyc2lvbiB0byBVVEYtMTYsIHBhc3MgZmxhdGJ1ZmZlcnMuRW5jb2RpbmcuVVRGOF9CWVRFUyBhc1xuICogdGhlIFwib3B0aW9uYWxFbmNvZGluZ1wiIGFyZ3VtZW50LiBUaGlzIGlzIHVzZWZ1bCBmb3IgYXZvaWRpbmcgY29udmVyc2lvbiB0b1xuICogYW5kIGZyb20gVVRGLTE2IHdoZW4gdGhlIGRhdGEgd2lsbCBqdXN0IGJlIHBhY2thZ2VkIGJhY2sgdXAgaW4gYW5vdGhlclxuICogRmxhdEJ1ZmZlciBsYXRlciBvbi5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge2ZsYXRidWZmZXJzLkVuY29kaW5nPX0gb3B0X2VuY29kaW5nIERlZmF1bHRzIHRvIFVURjE2X1NUUklOR1xuICogQHJldHVybnMge3N0cmluZ3whVWludDhBcnJheX1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX19zdHJpbmcgPSBmdW5jdGlvbihvZmZzZXQsIG9wdF9lbmNvZGluZykge1xuICBvZmZzZXQgKz0gdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcblxuICB2YXIgbGVuZ3RoID0gdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB2YXIgaSA9IDA7XG5cbiAgb2Zmc2V0ICs9IGZsYXRidWZmZXJzLlNJWkVPRl9JTlQ7XG5cbiAgaWYgKG9wdF9lbmNvZGluZyA9PT0gZmxhdGJ1ZmZlcnMuRW5jb2RpbmcuVVRGOF9CWVRFUykge1xuICAgIHJldHVybiB0aGlzLmJ5dGVzXy5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XG4gIH1cblxuICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgIHZhciBjb2RlUG9pbnQ7XG5cbiAgICAvLyBEZWNvZGUgVVRGLThcbiAgICB2YXIgYSA9IHRoaXMucmVhZFVpbnQ4KG9mZnNldCArIGkrKyk7XG4gICAgaWYgKGEgPCAweEMwKSB7XG4gICAgICBjb2RlUG9pbnQgPSBhO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYiA9IHRoaXMucmVhZFVpbnQ4KG9mZnNldCArIGkrKyk7XG4gICAgICBpZiAoYSA8IDB4RTApIHtcbiAgICAgICAgY29kZVBvaW50ID1cbiAgICAgICAgICAoKGEgJiAweDFGKSA8PCA2KSB8XG4gICAgICAgICAgKGIgJiAweDNGKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5yZWFkVWludDgob2Zmc2V0ICsgaSsrKTtcbiAgICAgICAgaWYgKGEgPCAweEYwKSB7XG4gICAgICAgICAgY29kZVBvaW50ID1cbiAgICAgICAgICAgICgoYSAmIDB4MEYpIDw8IDEyKSB8XG4gICAgICAgICAgICAoKGIgJiAweDNGKSA8PCA2KSB8XG4gICAgICAgICAgICAoYyAmIDB4M0YpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkID0gdGhpcy5yZWFkVWludDgob2Zmc2V0ICsgaSsrKTtcbiAgICAgICAgICBjb2RlUG9pbnQgPVxuICAgICAgICAgICAgKChhICYgMHgwNykgPDwgMTgpIHxcbiAgICAgICAgICAgICgoYiAmIDB4M0YpIDw8IDEyKSB8XG4gICAgICAgICAgICAoKGMgJiAweDNGKSA8PCA2KSB8XG4gICAgICAgICAgICAoZCAmIDB4M0YpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW5jb2RlIFVURi0xNlxuICAgIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcbiAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICAoY29kZVBvaW50ID4+IDEwKSArIDB4RDgwMCxcbiAgICAgICAgKGNvZGVQb2ludCAmICgoMSA8PCAxMCkgLSAxKSkgKyAweERDMDApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSByZWxhdGl2ZSBvZmZzZXQgc3RvcmVkIGF0IFwib2Zmc2V0XCJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZsYXRidWZmZXJzLkJ5dGVCdWZmZXIucHJvdG90eXBlLl9faW5kaXJlY3QgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgcmV0dXJuIG9mZnNldCArIHRoaXMucmVhZEludDMyKG9mZnNldCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc3RhcnQgb2YgZGF0YSBvZiBhIHZlY3RvciB3aG9zZSBvZmZzZXQgaXMgc3RvcmVkIGF0IFwib2Zmc2V0XCIgaW4gdGhpcyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuX192ZWN0b3IgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgcmV0dXJuIG9mZnNldCArIHRoaXMucmVhZEludDMyKG9mZnNldCkgKyBmbGF0YnVmZmVycy5TSVpFT0ZfSU5UOyAvLyBkYXRhIHN0YXJ0cyBhZnRlciB0aGUgbGVuZ3RoXG59O1xuXG4vKipcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yIHdob3NlIG9mZnNldCBpcyBzdG9yZWQgYXQgXCJvZmZzZXRcIiBpbiB0aGlzIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX3ZlY3Rvcl9sZW4gPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMucmVhZEludDMyKG9mZnNldCArIHRoaXMucmVhZEludDMyKG9mZnNldCkpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mbGF0YnVmZmVycy5CeXRlQnVmZmVyLnByb3RvdHlwZS5fX2hhc19pZGVudGlmaWVyID0gZnVuY3Rpb24oaWRlbnQpIHtcbiAgaWYgKGlkZW50Lmxlbmd0aCAhPSBmbGF0YnVmZmVycy5GSUxFX0lERU5USUZJRVJfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogZmlsZSBpZGVudGlmaWVyIG11c3QgYmUgbGVuZ3RoICcgK1xuICAgICAgICAgICAgICAgICAgICBmbGF0YnVmZmVycy5GSUxFX0lERU5USUZJRVJfTEVOR1RIKTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZsYXRidWZmZXJzLkZJTEVfSURFTlRJRklFUl9MRU5HVEg7IGkrKykge1xuICAgIGlmIChpZGVudC5jaGFyQ29kZUF0KGkpICE9IHRoaXMucmVhZEludDgodGhpcy5wb3NpdGlvbl8gKyBmbGF0YnVmZmVycy5TSVpFT0ZfSU5UICsgaSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGF2b2lkIGdlbmVyYXRlZCBjb2RlIGRlcGVuZGluZyBvbiB0aGlzIGZpbGUgZGlyZWN0bHkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGxvd1xuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hcbiAqIEByZXR1cm5zIHshZmxhdGJ1ZmZlcnMuTG9uZ31cbiAqL1xuZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlci5wcm90b3R5cGUuY3JlYXRlTG9uZyA9IGZ1bmN0aW9uKGxvdywgaGlnaCkge1xuICByZXR1cm4gZmxhdGJ1ZmZlcnMuTG9uZy5jcmVhdGUobG93LCBoaWdoKTtcbn07XG5cbi8vIEV4cG9ydHMgZm9yIE5vZGUuanMgYW5kIFJlcXVpcmVKU1xuZXhwb3J0IHsgZmxhdGJ1ZmZlcnMgfTtcblxuLy8vIEBlbmRjb25kXG4vLy8gQH1cbiIsICIvLyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBieSB0aGUgRmxhdEJ1ZmZlcnMgY29tcGlsZXIsIGRvIG5vdCBtb2RpZnlcbi8qIGVzbGludC1kaXNhYmxlICovXG5cbmltcG9ydCB7ZmxhdGJ1ZmZlcnN9IGZyb20gJ2ZsYXRidWZmZXJzJztcblxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgZW51bSBBdHRyaWJ1dGVUeXBlIHtcbiAgICBVTkRFRklORUQgPSAwLFxuICAgIEZMT0FUID0gMSxcbiAgICBJTlQgPSAyLFxuICAgIFNUUklORyA9IDMsXG4gICAgVEVOU09SID0gNCxcbiAgICBHUkFQSCA9IDUsXG4gICAgRkxPQVRTID0gNixcbiAgICBJTlRTID0gNyxcbiAgICBTVFJJTkdTID0gOCxcbiAgICBURU5TT1JTID0gOSxcbiAgICBHUkFQSFMgPSAxMCxcbiAgICBTUEFSU0VfVEVOU09SID0gMTEsXG4gICAgU1BBUlNFX1RFTlNPUlMgPSAxMlxuICB9XG59XG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGVudW0gRGltZW5zaW9uVmFsdWVUeXBlIHtVTktOT1dOID0gMCwgVkFMVUUgPSAxLCBQQVJBTSA9IDJ9XG59XG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGVudW0gVGVuc29yRGF0YVR5cGUge1xuICAgIFVOREVGSU5FRCA9IDAsXG4gICAgRkxPQVQgPSAxLFxuICAgIFVJTlQ4ID0gMixcbiAgICBJTlQ4ID0gMyxcbiAgICBVSU5UMTYgPSA0LFxuICAgIElOVDE2ID0gNSxcbiAgICBJTlQzMiA9IDYsXG4gICAgSU5UNjQgPSA3LFxuICAgIFNUUklORyA9IDgsXG4gICAgQk9PTCA9IDksXG4gICAgRkxPQVQxNiA9IDEwLFxuICAgIERPVUJMRSA9IDExLFxuICAgIFVJTlQzMiA9IDEyLFxuICAgIFVJTlQ2NCA9IDEzLFxuICAgIENPTVBMRVg2NCA9IDE0LFxuICAgIENPTVBMRVgxMjggPSAxNSxcbiAgICBCRkxPQVQxNiA9IDE2LFxuICAgIEZMT0FUOEU0TTNGTiA9IDE3LFxuICAgIEZMT0FUOEU0TTNGTlVaID0gMTgsXG4gICAgRkxPQVQ4RTVNMiA9IDE5LFxuICAgIEZMT0FUOEU1TTJGTlVaID0gMjAsXG4gIH1cbn1cblxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgZW51bSBOb2RlVHlwZSB7UHJpbWl0aXZlID0gMCwgRnVzZWQgPSAxfVxufVxuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBlbnVtIFR5cGVJbmZvVmFsdWUge05PTkUgPSAwLCB0ZW5zb3JfdHlwZSA9IDEsIHNlcXVlbmNlX3R5cGUgPSAyLCBtYXBfdHlwZSA9IDN9XG59XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBTaGFwZSB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgU2hhcGVcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IFNoYXBlIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFNoYXBlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBTaGFwZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNTaGFwZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogU2hhcGUpOiBTaGFwZSB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgU2hhcGUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBTaGFwZT0gb2JqXG4gICAgICogQHJldHVybnMgU2hhcGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzU2hhcGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFNoYXBlKTogU2hhcGUge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgU2hhcGUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblxuICAgICAqL1xuICAgIGRpbShpbmRleDogbnVtYmVyLCBvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvbik6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9ufG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvbigpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGRpbUxlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0U2hhcGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkaW1PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRGltKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRpbU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDAsIGRpbU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZURpbVZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnREaW1WZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRTaGFwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlU2hhcGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGltT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgU2hhcGUuc3RhcnRTaGFwZShidWlsZGVyKTtcbiAgICAgIFNoYXBlLmFkZERpbShidWlsZGVyLCBkaW1PZmZzZXQpO1xuICAgICAgcmV0dXJuIFNoYXBlLmVuZFNoYXBlKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIERpbWVuc2lvbiB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgRGltZW5zaW9uXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBEaW1lbnNpb24ge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gRGltZW5zaW9uPSBvYmpcbiAgICAgKiBAcmV0dXJucyBEaW1lbnNpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzRGltZW5zaW9uKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBEaW1lbnNpb24pOiBEaW1lbnNpb24ge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IERpbWVuc2lvbigpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIERpbWVuc2lvbj0gb2JqXG4gICAgICogQHJldHVybnMgRGltZW5zaW9uXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc0RpbWVuc2lvbihiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogRGltZW5zaW9uKTogRGltZW5zaW9uIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IERpbWVuc2lvbigpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlfG51bGxcbiAgICAgKi9cbiAgICB2YWx1ZShvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGRlbm90YXRpb24oKTogc3RyaW5nfG51bGw7XG4gICAgZGVub3RhdGlvbihvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgZGVub3RhdGlvbihvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydERpbWVuc2lvbihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHZhbHVlT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFZhbHVlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHZhbHVlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgdmFsdWVPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGRlbm90YXRpb25PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRGVub3RhdGlvbihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkZW5vdGF0aW9uT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMSwgZGVub3RhdGlvbk9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmREaW1lbnNpb24oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZURpbWVuc2lvbihcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdmFsdWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgZGVub3RhdGlvbk9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIERpbWVuc2lvbi5zdGFydERpbWVuc2lvbihidWlsZGVyKTtcbiAgICAgIERpbWVuc2lvbi5hZGRWYWx1ZShidWlsZGVyLCB2YWx1ZU9mZnNldCk7XG4gICAgICBEaW1lbnNpb24uYWRkRGVub3RhdGlvbihidWlsZGVyLCBkZW5vdGF0aW9uT2Zmc2V0KTtcbiAgICAgIHJldHVybiBEaW1lbnNpb24uZW5kRGltZW5zaW9uKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIERpbWVuc2lvblZhbHVlIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBEaW1lbnNpb25WYWx1ZVxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogRGltZW5zaW9uVmFsdWUge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gRGltZW5zaW9uVmFsdWU9IG9ialxuICAgICAqIEByZXR1cm5zIERpbWVuc2lvblZhbHVlXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc0RpbWVuc2lvblZhbHVlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBEaW1lbnNpb25WYWx1ZSk6IERpbWVuc2lvblZhbHVlIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBEaW1lbnNpb25WYWx1ZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIERpbWVuc2lvblZhbHVlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBEaW1lbnNpb25WYWx1ZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNEaW1lbnNpb25WYWx1ZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogRGltZW5zaW9uVmFsdWUpOiBEaW1lbnNpb25WYWx1ZSB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBEaW1lbnNpb25WYWx1ZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uVmFsdWVUeXBlXG4gICAgICovXG4gICAgZGltVHlwZSgpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlVHlwZSB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IC8qKiAgKi8gKHRoaXMuYmIhLnJlYWRJbnQ4KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSkgOlxuICAgICAgICAgICAgICAgICAgICAgIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uVmFsdWVUeXBlLlVOS05PV047XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuTG9uZ1xuICAgICAqL1xuICAgIGRpbVZhbHVlKCk6IGZsYXRidWZmZXJzLkxvbmcge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkSW50NjQodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogdGhpcy5iYiEuY3JlYXRlTG9uZygwLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZGltUGFyYW0oKTogc3RyaW5nfG51bGw7XG4gICAgZGltUGFyYW0ob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIGRpbVBhcmFtKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0RGltZW5zaW9uVmFsdWUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uVmFsdWVUeXBlIGRpbVR5cGVcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRGltVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkaW1UeXBlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkRpbWVuc2lvblZhbHVlVHlwZSkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDgoMCwgZGltVHlwZSwgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5EaW1lbnNpb25WYWx1ZVR5cGUuVU5LTk9XTik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5Mb25nIGRpbVZhbHVlXG4gICAgICovXG4gICAgc3RhdGljIGFkZERpbVZhbHVlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRpbVZhbHVlOiBmbGF0YnVmZmVycy5Mb25nKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkSW50NjQoMSwgZGltVmFsdWUsIGJ1aWxkZXIuY3JlYXRlTG9uZygwLCAwKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZGltUGFyYW1PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRGltUGFyYW0oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGltUGFyYW1PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgyLCBkaW1QYXJhbU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmREaW1lbnNpb25WYWx1ZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlRGltZW5zaW9uVmFsdWUoXG4gICAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRpbVR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRGltZW5zaW9uVmFsdWVUeXBlLFxuICAgICAgICBkaW1WYWx1ZTogZmxhdGJ1ZmZlcnMuTG9uZywgZGltUGFyYW1PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBEaW1lbnNpb25WYWx1ZS5zdGFydERpbWVuc2lvblZhbHVlKGJ1aWxkZXIpO1xuICAgICAgRGltZW5zaW9uVmFsdWUuYWRkRGltVHlwZShidWlsZGVyLCBkaW1UeXBlKTtcbiAgICAgIERpbWVuc2lvblZhbHVlLmFkZERpbVZhbHVlKGJ1aWxkZXIsIGRpbVZhbHVlKTtcbiAgICAgIERpbWVuc2lvblZhbHVlLmFkZERpbVBhcmFtKGJ1aWxkZXIsIGRpbVBhcmFtT2Zmc2V0KTtcbiAgICAgIHJldHVybiBEaW1lbnNpb25WYWx1ZS5lbmREaW1lbnNpb25WYWx1ZShidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBUZW5zb3JUeXBlQW5kU2hhcGUge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyfG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIFRlbnNvclR5cGVBbmRTaGFwZVxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogVGVuc29yVHlwZUFuZFNoYXBlIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFRlbnNvclR5cGVBbmRTaGFwZT0gb2JqXG4gICAgICogQHJldHVybnMgVGVuc29yVHlwZUFuZFNoYXBlXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc1RlbnNvclR5cGVBbmRTaGFwZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogVGVuc29yVHlwZUFuZFNoYXBlKTogVGVuc29yVHlwZUFuZFNoYXBlIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBUZW5zb3JUeXBlQW5kU2hhcGUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBUZW5zb3JUeXBlQW5kU2hhcGU9IG9ialxuICAgICAqIEByZXR1cm5zIFRlbnNvclR5cGVBbmRTaGFwZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNUZW5zb3JUeXBlQW5kU2hhcGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFRlbnNvclR5cGVBbmRTaGFwZSk6XG4gICAgICAgIFRlbnNvclR5cGVBbmRTaGFwZSB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBUZW5zb3JUeXBlQW5kU2hhcGUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlXG4gICAgICovXG4gICAgZWxlbVR5cGUoKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZSB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IC8qKiAgKi8gKHRoaXMuYmIhLnJlYWRJbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLlVOREVGSU5FRDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TaGFwZT0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TaGFwZXxudWxsXG4gICAgICovXG4gICAgc2hhcGUob2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TaGFwZSk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU2hhcGV8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU2hhcGUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRUZW5zb3JUeXBlQW5kU2hhcGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUgZWxlbVR5cGVcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRWxlbVR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZWxlbVR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQzMigwLCBlbGVtVHlwZSwgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZS5VTkRFRklORUQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHNoYXBlT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFNoYXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHNoYXBlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMSwgc2hhcGVPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kVGVuc29yVHlwZUFuZFNoYXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVUZW5zb3JUeXBlQW5kU2hhcGUoXG4gICAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGVsZW1UeXBlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLFxuICAgICAgICBzaGFwZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIFRlbnNvclR5cGVBbmRTaGFwZS5zdGFydFRlbnNvclR5cGVBbmRTaGFwZShidWlsZGVyKTtcbiAgICAgIFRlbnNvclR5cGVBbmRTaGFwZS5hZGRFbGVtVHlwZShidWlsZGVyLCBlbGVtVHlwZSk7XG4gICAgICBUZW5zb3JUeXBlQW5kU2hhcGUuYWRkU2hhcGUoYnVpbGRlciwgc2hhcGVPZmZzZXQpO1xuICAgICAgcmV0dXJuIFRlbnNvclR5cGVBbmRTaGFwZS5lbmRUZW5zb3JUeXBlQW5kU2hhcGUoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgTWFwVHlwZSB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgTWFwVHlwZVxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogTWFwVHlwZSB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBNYXBUeXBlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBNYXBUeXBlXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc01hcFR5cGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IE1hcFR5cGUpOiBNYXBUeXBlIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBNYXBUeXBlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gTWFwVHlwZT0gb2JqXG4gICAgICogQHJldHVybnMgTWFwVHlwZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNNYXBUeXBlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBNYXBUeXBlKTogTWFwVHlwZSB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBNYXBUeXBlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZVxuICAgICAqL1xuICAgIGtleVR5cGUoKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZSB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IC8qKiAgKi8gKHRoaXMuYmIhLnJlYWRJbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLlVOREVGSU5FRDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbz0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mb3xudWxsXG4gICAgICovXG4gICAgdmFsdWVUeXBlKG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8pOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0TWFwVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZSBrZXlUeXBlXG4gICAgICovXG4gICAgc3RhdGljIGFkZEtleVR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwga2V5VHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZSkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDMyKDAsIGtleVR5cGUsIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUuVU5ERUZJTkVEKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCB2YWx1ZVR5cGVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVmFsdWVUeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHZhbHVlVHlwZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIHZhbHVlVHlwZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRNYXBUeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVNYXBUeXBlKFxuICAgICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBrZXlUeXBlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlLFxuICAgICAgICB2YWx1ZVR5cGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBNYXBUeXBlLnN0YXJ0TWFwVHlwZShidWlsZGVyKTtcbiAgICAgIE1hcFR5cGUuYWRkS2V5VHlwZShidWlsZGVyLCBrZXlUeXBlKTtcbiAgICAgIE1hcFR5cGUuYWRkVmFsdWVUeXBlKGJ1aWxkZXIsIHZhbHVlVHlwZU9mZnNldCk7XG4gICAgICByZXR1cm4gTWFwVHlwZS5lbmRNYXBUeXBlKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIFNlcXVlbmNlVHlwZSB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgU2VxdWVuY2VUeXBlXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBTZXF1ZW5jZVR5cGUge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gU2VxdWVuY2VUeXBlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBTZXF1ZW5jZVR5cGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzU2VxdWVuY2VUeXBlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBTZXF1ZW5jZVR5cGUpOiBTZXF1ZW5jZVR5cGUge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFNlcXVlbmNlVHlwZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFNlcXVlbmNlVHlwZT0gb2JqXG4gICAgICogQHJldHVybnMgU2VxdWVuY2VUeXBlXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1NlcXVlbmNlVHlwZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogU2VxdWVuY2VUeXBlKTogU2VxdWVuY2VUeXBlIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFNlcXVlbmNlVHlwZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvfG51bGxcbiAgICAgKi9cbiAgICBlbGVtVHlwZShvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mb3xudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mbygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFNlcXVlbmNlVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGVsZW1UeXBlT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEVsZW1UeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGVsZW1UeXBlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgZWxlbVR5cGVPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kU2VxdWVuY2VUeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVTZXF1ZW5jZVR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZWxlbVR5cGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBTZXF1ZW5jZVR5cGUuc3RhcnRTZXF1ZW5jZVR5cGUoYnVpbGRlcik7XG4gICAgICBTZXF1ZW5jZVR5cGUuYWRkRWxlbVR5cGUoYnVpbGRlciwgZWxlbVR5cGVPZmZzZXQpO1xuICAgICAgcmV0dXJuIFNlcXVlbmNlVHlwZS5lbmRTZXF1ZW5jZVR5cGUoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgRWRnZUVuZCB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgRWRnZUVuZFxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogRWRnZUVuZCB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBub2RlSW5kZXgoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLmJiIS5yZWFkVWludDMyKHRoaXMuYmJfcG9zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBzcmNBcmdJbmRleCgpOiBudW1iZXIge1xuICAgICAgcmV0dXJuIHRoaXMuYmIhLnJlYWRJbnQzMih0aGlzLmJiX3BvcyArIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGRzdEFyZ0luZGV4KCk6IG51bWJlciB7XG4gICAgICByZXR1cm4gdGhpcy5iYiEucmVhZEludDMyKHRoaXMuYmJfcG9zICsgOCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbm9kZV9pbmRleFxuICAgICAqIEBwYXJhbSBudW1iZXIgc3JjX2FyZ19pbmRleFxuICAgICAqIEBwYXJhbSBudW1iZXIgZHN0X2FyZ19pbmRleFxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVFZGdlRW5kKFxuICAgICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBub2RlX2luZGV4OiBudW1iZXIsIHNyY19hcmdfaW5kZXg6IG51bWJlcixcbiAgICAgICAgZHN0X2FyZ19pbmRleDogbnVtYmVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIucHJlcCg0LCAxMik7XG4gICAgICBidWlsZGVyLndyaXRlSW50MzIoZHN0X2FyZ19pbmRleCk7XG4gICAgICBidWlsZGVyLndyaXRlSW50MzIoc3JjX2FyZ19pbmRleCk7XG4gICAgICBidWlsZGVyLndyaXRlSW50MzIobm9kZV9pbmRleCk7XG4gICAgICByZXR1cm4gYnVpbGRlci5vZmZzZXQoKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBOb2RlRWRnZSB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgTm9kZUVkZ2VcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IE5vZGVFZGdlIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIE5vZGVFZGdlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBOb2RlRWRnZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNOb2RlRWRnZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogTm9kZUVkZ2UpOiBOb2RlRWRnZSB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgTm9kZUVkZ2UoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBOb2RlRWRnZT0gb2JqXG4gICAgICogQHJldHVybnMgTm9kZUVkZ2VcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzTm9kZUVkZ2UoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IE5vZGVFZGdlKTogTm9kZUVkZ2Uge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgTm9kZUVkZ2UoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBub2RlSW5kZXgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZFVpbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5FZGdlRW5kPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkVkZ2VFbmRcbiAgICAgKi9cbiAgICBpbnB1dEVkZ2VzKGluZGV4OiBudW1iZXIsIG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZHxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5FZGdlRW5kKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiAxMiwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGlucHV0RWRnZXNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkVkZ2VFbmQ9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZFxuICAgICAqL1xuICAgIG91dHB1dEVkZ2VzKGluZGV4OiBudW1iZXIsIG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuRWRnZUVuZHxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5FZGdlRW5kKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiAxMiwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIG91dHB1dEVkZ2VzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnROb2RlRWRnZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG5vZGVJbmRleFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGROb2RlSW5kZXgoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbm9kZUluZGV4OiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQzMigwLCBub2RlSW5kZXgsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGlucHV0RWRnZXNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkSW5wdXRFZGdlcyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBpbnB1dEVkZ2VzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMSwgaW5wdXRFZGdlc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRJbnB1dEVkZ2VzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoMTIsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBvdXRwdXRFZGdlc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRPdXRwdXRFZGdlcyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBvdXRwdXRFZGdlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDIsIG91dHB1dEVkZ2VzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydE91dHB1dEVkZ2VzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoMTIsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZE5vZGVFZGdlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVOb2RlRWRnZShcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbm9kZUluZGV4OiBudW1iZXIsIGlucHV0RWRnZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgb3V0cHV0RWRnZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBOb2RlRWRnZS5zdGFydE5vZGVFZGdlKGJ1aWxkZXIpO1xuICAgICAgTm9kZUVkZ2UuYWRkTm9kZUluZGV4KGJ1aWxkZXIsIG5vZGVJbmRleCk7XG4gICAgICBOb2RlRWRnZS5hZGRJbnB1dEVkZ2VzKGJ1aWxkZXIsIGlucHV0RWRnZXNPZmZzZXQpO1xuICAgICAgTm9kZUVkZ2UuYWRkT3V0cHV0RWRnZXMoYnVpbGRlciwgb3V0cHV0RWRnZXNPZmZzZXQpO1xuICAgICAgcmV0dXJuIE5vZGVFZGdlLmVuZE5vZGVFZGdlKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIE5vZGUge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyfG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIE5vZGVcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IE5vZGUge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gTm9kZT0gb2JqXG4gICAgICogQHJldHVybnMgTm9kZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNOb2RlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBOb2RlKTogTm9kZSB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgTm9kZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIE5vZGU9IG9ialxuICAgICAqIEByZXR1cm5zIE5vZGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzTm9kZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogTm9kZSk6IE5vZGUge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgTm9kZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBuYW1lKCk6IHN0cmluZ3xudWxsO1xuICAgIG5hbWUob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIG5hbWUob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBkb2NTdHJpbmcoKTogc3RyaW5nfG51bGw7XG4gICAgZG9jU3RyaW5nKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBkb2NTdHJpbmcob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBkb21haW4oKTogc3RyaW5nfG51bGw7XG4gICAgZG9tYWluKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBkb21haW4ob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIHNpbmNlVmVyc2lvbigpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZEludDMyKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgaW5kZXgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTIpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRVaW50MzIodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgb3BUeXBlKCk6IHN0cmluZ3xudWxsO1xuICAgIG9wVHlwZShvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgb3BUeXBlKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlVHlwZVxuICAgICAqL1xuICAgIHR5cGUoKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlVHlwZSB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAvKiogICovICh0aGlzLmJiIS5yZWFkSW50MzIodGhpcy5iYl9wb3MgKyBvZmZzZXQpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlVHlwZS5QcmltaXRpdmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGV4ZWN1dGlvblByb3ZpZGVyVHlwZSgpOiBzdHJpbmd8bnVsbDtcbiAgICBleGVjdXRpb25Qcm92aWRlclR5cGUob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIGV4ZWN1dGlvblByb3ZpZGVyVHlwZShvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheVxuICAgICAqL1xuICAgIGlucHV0cyhpbmRleDogbnVtYmVyKTogc3RyaW5nO1xuICAgIGlucHV0cyhpbmRleDogbnVtYmVyLCBvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5O1xuICAgIGlucHV0cyhpbmRleDogbnVtYmVyLCBvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDIwKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBpbnB1dHNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjApO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheVxuICAgICAqL1xuICAgIG91dHB1dHMoaW5kZXg6IG51bWJlcik6IHN0cmluZztcbiAgICBvdXRwdXRzKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXk7XG4gICAgb3V0cHV0cyhpbmRleDogbnVtYmVyLCBvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDIyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBvdXRwdXRzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDIyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuQXR0cmlidXRlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVxuICAgICAqL1xuICAgIGF0dHJpYnV0ZXMoaW5kZXg6IG51bWJlciwgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGUpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVxuICAgICAgICB8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGF0dHJpYnV0ZXNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBpbnB1dEFyZ0NvdW50cyhpbmRleDogbnVtYmVyKTogbnVtYmVyfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZEludDMyKHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGlucHV0QXJnQ291bnRzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBJbnQzMkFycmF5XG4gICAgICovXG4gICAgaW5wdXRBcmdDb3VudHNBcnJheSgpOiBJbnQzMkFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID9cbiAgICAgICAgICBuZXcgSW50MzJBcnJheShcbiAgICAgICAgICAgICAgdGhpcy5iYiEuYnl0ZXMoKS5idWZmZXIsIHRoaXMuYmIhLmJ5dGVzKCkuYnl0ZU9mZnNldCArIHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSxcbiAgICAgICAgICAgICAgdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSkgOlxuICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5XG4gICAgICovXG4gICAgaW1wbGljaXRJbnB1dHMoaW5kZXg6IG51bWJlcik6IHN0cmluZztcbiAgICBpbXBsaWNpdElucHV0cyhpbmRleDogbnVtYmVyLCBvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5O1xuICAgIGltcGxpY2l0SW5wdXRzKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGltcGxpY2l0SW5wdXRzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0Tm9kZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDEzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBuYW1lT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE5hbWUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbmFtZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDAsIG5hbWVPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGRvY1N0cmluZ09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREb2NTdHJpbmcoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZG9jU3RyaW5nT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMSwgZG9jU3RyaW5nT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkb21haW5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRG9tYWluKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRvbWFpbk9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDIsIGRvbWFpbk9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgc2luY2VWZXJzaW9uXG4gICAgICovXG4gICAgc3RhdGljIGFkZFNpbmNlVmVyc2lvbihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBzaW5jZVZlcnNpb246IG51bWJlcikge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDMyKDMsIHNpbmNlVmVyc2lvbiwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkSW5kZXgoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgaW5kZXg6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDMyKDQsIGluZGV4LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBvcFR5cGVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkT3BUeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG9wVHlwZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDUsIG9wVHlwZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGVUeXBlIHR5cGVcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVHlwZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCB0eXBlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGVUeXBlKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkSW50MzIoNiwgdHlwZSwgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlVHlwZS5QcmltaXRpdmUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGV4ZWN1dGlvblByb3ZpZGVyVHlwZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRFeGVjdXRpb25Qcm92aWRlclR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZXhlY3V0aW9uUHJvdmlkZXJUeXBlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNywgZXhlY3V0aW9uUHJvdmlkZXJUeXBlT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBpbnB1dHNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkSW5wdXRzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGlucHV0c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDgsIGlucHV0c09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUlucHV0c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRJbnB1dHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgb3V0cHV0c09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRPdXRwdXRzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG91dHB1dHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg5LCBvdXRwdXRzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlT3V0cHV0c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRPdXRwdXRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGF0dHJpYnV0ZXNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkQXR0cmlidXRlcyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBhdHRyaWJ1dGVzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMTAsIGF0dHJpYnV0ZXNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVBdHRyaWJ1dGVzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydEF0dHJpYnV0ZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgaW5wdXRBcmdDb3VudHNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkSW5wdXRBcmdDb3VudHMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgaW5wdXRBcmdDb3VudHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxMSwgaW5wdXRBcmdDb3VudHNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPG51bWJlcj4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVJbnB1dEFyZ0NvdW50c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBudW1iZXJbXXxVaW50OEFycmF5KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRJbnQzMihkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0SW5wdXRBcmdDb3VudHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgaW1wbGljaXRJbnB1dHNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkSW1wbGljaXRJbnB1dHMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgaW1wbGljaXRJbnB1dHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxMiwgaW1wbGljaXRJbnB1dHNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVJbXBsaWNpdElucHV0c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRJbXBsaWNpdElucHV0c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZE5vZGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZU5vZGUoXG4gICAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5hbWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgZG9jU3RyaW5nT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIGRvbWFpbk9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBzaW5jZVZlcnNpb246IG51bWJlciwgaW5kZXg6IG51bWJlciwgb3BUeXBlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIHR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZVR5cGUsIGV4ZWN1dGlvblByb3ZpZGVyVHlwZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBpbnB1dHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgb3V0cHV0c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBhdHRyaWJ1dGVzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIGlucHV0QXJnQ291bnRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIGltcGxpY2l0SW5wdXRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgTm9kZS5zdGFydE5vZGUoYnVpbGRlcik7XG4gICAgICBOb2RlLmFkZE5hbWUoYnVpbGRlciwgbmFtZU9mZnNldCk7XG4gICAgICBOb2RlLmFkZERvY1N0cmluZyhidWlsZGVyLCBkb2NTdHJpbmdPZmZzZXQpO1xuICAgICAgTm9kZS5hZGREb21haW4oYnVpbGRlciwgZG9tYWluT2Zmc2V0KTtcbiAgICAgIE5vZGUuYWRkU2luY2VWZXJzaW9uKGJ1aWxkZXIsIHNpbmNlVmVyc2lvbik7XG4gICAgICBOb2RlLmFkZEluZGV4KGJ1aWxkZXIsIGluZGV4KTtcbiAgICAgIE5vZGUuYWRkT3BUeXBlKGJ1aWxkZXIsIG9wVHlwZU9mZnNldCk7XG4gICAgICBOb2RlLmFkZFR5cGUoYnVpbGRlciwgdHlwZSk7XG4gICAgICBOb2RlLmFkZEV4ZWN1dGlvblByb3ZpZGVyVHlwZShidWlsZGVyLCBleGVjdXRpb25Qcm92aWRlclR5cGVPZmZzZXQpO1xuICAgICAgTm9kZS5hZGRJbnB1dHMoYnVpbGRlciwgaW5wdXRzT2Zmc2V0KTtcbiAgICAgIE5vZGUuYWRkT3V0cHV0cyhidWlsZGVyLCBvdXRwdXRzT2Zmc2V0KTtcbiAgICAgIE5vZGUuYWRkQXR0cmlidXRlcyhidWlsZGVyLCBhdHRyaWJ1dGVzT2Zmc2V0KTtcbiAgICAgIE5vZGUuYWRkSW5wdXRBcmdDb3VudHMoYnVpbGRlciwgaW5wdXRBcmdDb3VudHNPZmZzZXQpO1xuICAgICAgTm9kZS5hZGRJbXBsaWNpdElucHV0cyhidWlsZGVyLCBpbXBsaWNpdElucHV0c09mZnNldCk7XG4gICAgICByZXR1cm4gTm9kZS5lbmROb2RlKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIFZhbHVlSW5mbyB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgVmFsdWVJbmZvXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBWYWx1ZUluZm8ge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gVmFsdWVJbmZvPSBvYmpcbiAgICAgKiBAcmV0dXJucyBWYWx1ZUluZm9cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzVmFsdWVJbmZvKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBWYWx1ZUluZm8pOiBWYWx1ZUluZm8ge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFZhbHVlSW5mbygpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFZhbHVlSW5mbz0gb2JqXG4gICAgICogQHJldHVybnMgVmFsdWVJbmZvXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1ZhbHVlSW5mbyhiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogVmFsdWVJbmZvKTogVmFsdWVJbmZvIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFZhbHVlSW5mbygpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBuYW1lKCk6IHN0cmluZ3xudWxsO1xuICAgIG5hbWUob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIG5hbWUob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBkb2NTdHJpbmcoKTogc3RyaW5nfG51bGw7XG4gICAgZG9jU3RyaW5nKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBkb2NTdHJpbmcob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvfG51bGxcbiAgICAgKi9cbiAgICB0eXBlKG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm8pOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0VmFsdWVJbmZvKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgbmFtZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGROYW1lKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5hbWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBuYW1lT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkb2NTdHJpbmdPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRG9jU3RyaW5nKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIGRvY1N0cmluZ09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgdHlwZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRUeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHR5cGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgyLCB0eXBlT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZFZhbHVlSW5mbyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlVmFsdWVJbmZvKFxuICAgICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBuYW1lT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIGRvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICB0eXBlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgVmFsdWVJbmZvLnN0YXJ0VmFsdWVJbmZvKGJ1aWxkZXIpO1xuICAgICAgVmFsdWVJbmZvLmFkZE5hbWUoYnVpbGRlciwgbmFtZU9mZnNldCk7XG4gICAgICBWYWx1ZUluZm8uYWRkRG9jU3RyaW5nKGJ1aWxkZXIsIGRvY1N0cmluZ09mZnNldCk7XG4gICAgICBWYWx1ZUluZm8uYWRkVHlwZShidWlsZGVyLCB0eXBlT2Zmc2V0KTtcbiAgICAgIHJldHVybiBWYWx1ZUluZm8uZW5kVmFsdWVJbmZvKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIFR5cGVJbmZvIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBUeXBlSW5mb1xuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogVHlwZUluZm8ge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gVHlwZUluZm89IG9ialxuICAgICAqIEByZXR1cm5zIFR5cGVJbmZvXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc1R5cGVJbmZvKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBUeXBlSW5mbyk6IFR5cGVJbmZvIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBUeXBlSW5mbygpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFR5cGVJbmZvPSBvYmpcbiAgICAgKiBAcmV0dXJucyBUeXBlSW5mb1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNUeXBlSW5mbyhiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogVHlwZUluZm8pOiBUeXBlSW5mbyB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBUeXBlSW5mbygpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBkZW5vdGF0aW9uKCk6IHN0cmluZ3xudWxsO1xuICAgIGRlbm90YXRpb24ob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIGRlbm90YXRpb24ob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm9WYWx1ZVxuICAgICAqL1xuICAgIHZhbHVlVHlwZSgpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlR5cGVJbmZvVmFsdWUge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAvKiogICovICh0aGlzLmJiIS5yZWFkVWludDgodGhpcy5iYl9wb3MgKyBvZmZzZXQpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mb1ZhbHVlLk5PTkU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLlRhYmxlIG9ialxuICAgICAqIEByZXR1cm5zID9mbGF0YnVmZmVycy5UYWJsZVxuICAgICAqL1xuICAgIHZhbHVlPFQgZXh0ZW5kcyBmbGF0YnVmZmVycy5UYWJsZT4ob2JqOiBUKTogVHxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX191bmlvbihvYmosIHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFR5cGVJbmZvKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZGVub3RhdGlvbk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREZW5vdGF0aW9uKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRlbm90YXRpb25PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBkZW5vdGF0aW9uT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm9WYWx1ZSB2YWx1ZVR5cGVcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVmFsdWVUeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHZhbHVlVHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UeXBlSW5mb1ZhbHVlKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkSW50OCgxLCB2YWx1ZVR5cGUsIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm9WYWx1ZS5OT05FKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCB2YWx1ZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRWYWx1ZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCB2YWx1ZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDIsIHZhbHVlT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZFR5cGVJbmZvKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVUeXBlSW5mbyhcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGVub3RhdGlvbk9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICB2YWx1ZVR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVHlwZUluZm9WYWx1ZSwgdmFsdWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBUeXBlSW5mby5zdGFydFR5cGVJbmZvKGJ1aWxkZXIpO1xuICAgICAgVHlwZUluZm8uYWRkRGVub3RhdGlvbihidWlsZGVyLCBkZW5vdGF0aW9uT2Zmc2V0KTtcbiAgICAgIFR5cGVJbmZvLmFkZFZhbHVlVHlwZShidWlsZGVyLCB2YWx1ZVR5cGUpO1xuICAgICAgVHlwZUluZm8uYWRkVmFsdWUoYnVpbGRlciwgdmFsdWVPZmZzZXQpO1xuICAgICAgcmV0dXJuIFR5cGVJbmZvLmVuZFR5cGVJbmZvKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIE9wZXJhdG9yU2V0SWQge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyfG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIE9wZXJhdG9yU2V0SWRcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IE9wZXJhdG9yU2V0SWQge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gT3BlcmF0b3JTZXRJZD0gb2JqXG4gICAgICogQHJldHVybnMgT3BlcmF0b3JTZXRJZFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNPcGVyYXRvclNldElkKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBPcGVyYXRvclNldElkKTogT3BlcmF0b3JTZXRJZCB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgT3BlcmF0b3JTZXRJZCgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIE9wZXJhdG9yU2V0SWQ9IG9ialxuICAgICAqIEByZXR1cm5zIE9wZXJhdG9yU2V0SWRcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzT3BlcmF0b3JTZXRJZChiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogT3BlcmF0b3JTZXRJZCk6IE9wZXJhdG9yU2V0SWQge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgT3BlcmF0b3JTZXRJZCgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBkb21haW4oKTogc3RyaW5nfG51bGw7XG4gICAgZG9tYWluKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBkb21haW4ob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLkxvbmdcbiAgICAgKi9cbiAgICB2ZXJzaW9uKCk6IGZsYXRidWZmZXJzLkxvbmcge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkSW50NjQodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogdGhpcy5iYiEuY3JlYXRlTG9uZygwLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0T3BlcmF0b3JTZXRJZChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGRvbWFpbk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREb21haW4oYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZG9tYWluT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgZG9tYWluT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkxvbmcgdmVyc2lvblxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRWZXJzaW9uKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHZlcnNpb246IGZsYXRidWZmZXJzLkxvbmcpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQ2NCgxLCB2ZXJzaW9uLCBidWlsZGVyLmNyZWF0ZUxvbmcoMCwgMCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kT3BlcmF0b3JTZXRJZChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlT3BlcmF0b3JTZXRJZChcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZG9tYWluT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIHZlcnNpb246IGZsYXRidWZmZXJzLkxvbmcpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgT3BlcmF0b3JTZXRJZC5zdGFydE9wZXJhdG9yU2V0SWQoYnVpbGRlcik7XG4gICAgICBPcGVyYXRvclNldElkLmFkZERvbWFpbihidWlsZGVyLCBkb21haW5PZmZzZXQpO1xuICAgICAgT3BlcmF0b3JTZXRJZC5hZGRWZXJzaW9uKGJ1aWxkZXIsIHZlcnNpb24pO1xuICAgICAgcmV0dXJuIE9wZXJhdG9yU2V0SWQuZW5kT3BlcmF0b3JTZXRJZChidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBUZW5zb3Ige1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyfG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIFRlbnNvclxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogVGVuc29yIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFRlbnNvcj0gb2JqXG4gICAgICogQHJldHVybnMgVGVuc29yXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc1RlbnNvcihiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogVGVuc29yKTogVGVuc29yIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBUZW5zb3IoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBUZW5zb3I9IG9ialxuICAgICAqIEByZXR1cm5zIFRlbnNvclxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNUZW5zb3IoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFRlbnNvcik6IFRlbnNvciB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBUZW5zb3IoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgbmFtZSgpOiBzdHJpbmd8bnVsbDtcbiAgICBuYW1lKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBuYW1lKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgZG9jU3RyaW5nKCk6IHN0cmluZ3xudWxsO1xuICAgIGRvY1N0cmluZyhvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgZG9jU3RyaW5nKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuTG9uZ1xuICAgICAqL1xuICAgIGRpbXMoaW5kZXg6IG51bWJlcik6IGZsYXRidWZmZXJzLkxvbmd8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRJbnQ2NCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDgpIDpcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJiIS5jcmVhdGVMb25nKDAsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGRpbXNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3JEYXRhVHlwZVxuICAgICAqL1xuICAgIGRhdGFUeXBlKCk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gLyoqICAqLyAodGhpcy5iYiEucmVhZEludDMyKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSkgOlxuICAgICAgICAgICAgICAgICAgICAgIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUuVU5ERUZJTkVEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICByYXdEYXRhKGluZGV4OiBudW1iZXIpOiBudW1iZXJ8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkVWludDgodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXgpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICByYXdEYXRhTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBVaW50OEFycmF5XG4gICAgICovXG4gICAgcmF3RGF0YUFycmF5KCk6IFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgP1xuICAgICAgICAgIG5ldyBVaW50OEFycmF5KFxuICAgICAgICAgICAgICB0aGlzLmJiIS5ieXRlcygpLmJ1ZmZlciwgdGhpcy5iYiEuYnl0ZXMoKS5ieXRlT2Zmc2V0ICsgdGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpLFxuICAgICAgICAgICAgICB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpKSA6XG4gICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXlcbiAgICAgKi9cbiAgICBzdHJpbmdEYXRhKGluZGV4OiBudW1iZXIpOiBzdHJpbmc7XG4gICAgc3RyaW5nRGF0YShpbmRleDogbnVtYmVyLCBvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5O1xuICAgIHN0cmluZ0RhdGEoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgc3RyaW5nRGF0YUxlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFRlbnNvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDYpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG5hbWVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTmFtZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBuYW1lT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgbmFtZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZG9jU3RyaW5nT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERvY1N0cmluZyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkb2NTdHJpbmdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBkb2NTdHJpbmdPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGRpbXNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRGltcyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkaW1zT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMiwgZGltc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuTG9uZz4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVEaW1zVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLkxvbmdbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDgsIGRhdGEubGVuZ3RoLCA4KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkSW50NjQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydERpbXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig4LCBudW1FbGVtcywgOCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlIGRhdGFUeXBlXG4gICAgICovXG4gICAgc3RhdGljIGFkZERhdGFUeXBlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGFUeXBlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkSW50MzIoMywgZGF0YVR5cGUsIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUuVU5ERUZJTkVEKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCByYXdEYXRhT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFJhd0RhdGEoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgcmF3RGF0YU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDQsIHJhd0RhdGFPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPG51bWJlcj4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSYXdEYXRhVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IG51bWJlcltdfFVpbnQ4QXJyYXkpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3RvcigxLCBkYXRhLmxlbmd0aCwgMSk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZEludDgoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFJhd0RhdGFWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3RvcigxLCBudW1FbGVtcywgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgc3RyaW5nRGF0YU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRTdHJpbmdEYXRhKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHN0cmluZ0RhdGFPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg1LCBzdHJpbmdEYXRhT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlU3RyaW5nRGF0YVZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRTdHJpbmdEYXRhVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kVGVuc29yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVUZW5zb3IoXG4gICAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5hbWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgZG9jU3RyaW5nT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIGRpbXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgZGF0YVR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yRGF0YVR5cGUsXG4gICAgICAgIHJhd0RhdGFPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgc3RyaW5nRGF0YU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIFRlbnNvci5zdGFydFRlbnNvcihidWlsZGVyKTtcbiAgICAgIFRlbnNvci5hZGROYW1lKGJ1aWxkZXIsIG5hbWVPZmZzZXQpO1xuICAgICAgVGVuc29yLmFkZERvY1N0cmluZyhidWlsZGVyLCBkb2NTdHJpbmdPZmZzZXQpO1xuICAgICAgVGVuc29yLmFkZERpbXMoYnVpbGRlciwgZGltc09mZnNldCk7XG4gICAgICBUZW5zb3IuYWRkRGF0YVR5cGUoYnVpbGRlciwgZGF0YVR5cGUpO1xuICAgICAgVGVuc29yLmFkZFJhd0RhdGEoYnVpbGRlciwgcmF3RGF0YU9mZnNldCk7XG4gICAgICBUZW5zb3IuYWRkU3RyaW5nRGF0YShidWlsZGVyLCBzdHJpbmdEYXRhT2Zmc2V0KTtcbiAgICAgIHJldHVybiBUZW5zb3IuZW5kVGVuc29yKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIFNwYXJzZVRlbnNvciB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgU3BhcnNlVGVuc29yXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBTcGFyc2VUZW5zb3Ige1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gU3BhcnNlVGVuc29yPSBvYmpcbiAgICAgKiBAcmV0dXJucyBTcGFyc2VUZW5zb3JcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzU3BhcnNlVGVuc29yKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBTcGFyc2VUZW5zb3IpOiBTcGFyc2VUZW5zb3Ige1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFNwYXJzZVRlbnNvcigpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFNwYXJzZVRlbnNvcj0gb2JqXG4gICAgICogQHJldHVybnMgU3BhcnNlVGVuc29yXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1NwYXJzZVRlbnNvcihiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogU3BhcnNlVGVuc29yKTogU3BhcnNlVGVuc29yIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFNwYXJzZVRlbnNvcigpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcj0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3J8bnVsbFxuICAgICAqL1xuICAgIHZhbHVlcyhvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcik6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcigpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcnxudWxsXG4gICAgICovXG4gICAgaW5kaWNlcyhvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcik6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcigpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLkxvbmdcbiAgICAgKi9cbiAgICBkaW1zKGluZGV4OiBudW1iZXIpOiBmbGF0YnVmZmVycy5Mb25nfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkSW50NjQodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA4KSA6XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5iYiEuY3JlYXRlTG9uZygwLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBkaW1zTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRTcGFyc2VUZW5zb3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCB2YWx1ZXNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVmFsdWVzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHZhbHVlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDAsIHZhbHVlc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgaW5kaWNlc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRJbmRpY2VzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGluZGljZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBpbmRpY2VzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkaW1zT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERpbXMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGltc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDIsIGRpbXNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLkxvbmc+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRGltc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5Mb25nW10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig4LCBkYXRhLmxlbmd0aCwgOCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZEludDY0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnREaW1zVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoOCwgbnVtRWxlbXMsIDgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kU3BhcnNlVGVuc29yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVTcGFyc2VUZW5zb3IoXG4gICAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHZhbHVlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBpbmRpY2VzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIGRpbXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBTcGFyc2VUZW5zb3Iuc3RhcnRTcGFyc2VUZW5zb3IoYnVpbGRlcik7XG4gICAgICBTcGFyc2VUZW5zb3IuYWRkVmFsdWVzKGJ1aWxkZXIsIHZhbHVlc09mZnNldCk7XG4gICAgICBTcGFyc2VUZW5zb3IuYWRkSW5kaWNlcyhidWlsZGVyLCBpbmRpY2VzT2Zmc2V0KTtcbiAgICAgIFNwYXJzZVRlbnNvci5hZGREaW1zKGJ1aWxkZXIsIGRpbXNPZmZzZXQpO1xuICAgICAgcmV0dXJuIFNwYXJzZVRlbnNvci5lbmRTcGFyc2VUZW5zb3IoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgQXR0cmlidXRlIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBBdHRyaWJ1dGVcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IEF0dHJpYnV0ZSB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBBdHRyaWJ1dGU9IG9ialxuICAgICAqIEByZXR1cm5zIEF0dHJpYnV0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNBdHRyaWJ1dGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IEF0dHJpYnV0ZSk6IEF0dHJpYnV0ZSB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgQXR0cmlidXRlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gQXR0cmlidXRlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBBdHRyaWJ1dGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzQXR0cmlidXRlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBBdHRyaWJ1dGUpOiBBdHRyaWJ1dGUge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgQXR0cmlidXRlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIG5hbWUoKTogc3RyaW5nfG51bGw7XG4gICAgbmFtZShvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgbmFtZShvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGRvY1N0cmluZygpOiBzdHJpbmd8bnVsbDtcbiAgICBkb2NTdHJpbmcob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIGRvY1N0cmluZyhvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGVUeXBlXG4gICAgICovXG4gICAgdHlwZSgpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkF0dHJpYnV0ZVR5cGUge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAvKiogICovICh0aGlzLmJiIS5yZWFkSW50MzIodGhpcy5iYl9wb3MgKyBvZmZzZXQpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGVUeXBlLlVOREVGSU5FRDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBmKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEwKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkRmxvYXQzMih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwLjA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuTG9uZ1xuICAgICAqL1xuICAgIGkoKTogZmxhdGJ1ZmZlcnMuTG9uZyB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEyKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkSW50NjQodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogdGhpcy5iYiEuY3JlYXRlTG9uZygwLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheXxudWxsXG4gICAgICovXG4gICAgcygpOiBzdHJpbmd8bnVsbDtcbiAgICBzKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBzKG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcnxudWxsXG4gICAgICovXG4gICAgdChvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcik6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkdyYXBoPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkdyYXBofG51bGxcbiAgICAgKi9cbiAgICBnKG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGgpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkdyYXBofG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5HcmFwaCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGZsb2F0cyhpbmRleDogbnVtYmVyKTogbnVtYmVyfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyMCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZEZsb2F0MzIodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgZmxvYXRzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDIwKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBGbG9hdDMyQXJyYXlcbiAgICAgKi9cbiAgICBmbG9hdHNBcnJheSgpOiBGbG9hdDMyQXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDIwKTtcbiAgICAgIHJldHVybiBvZmZzZXQgP1xuICAgICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoXG4gICAgICAgICAgICAgIHRoaXMuYmIhLmJ5dGVzKCkuYnVmZmVyLCB0aGlzLmJiIS5ieXRlcygpLmJ5dGVPZmZzZXQgKyB0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCksXG4gICAgICAgICAgICAgIHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkpIDpcbiAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5Mb25nXG4gICAgICovXG4gICAgaW50cyhpbmRleDogbnVtYmVyKTogZmxhdGJ1ZmZlcnMuTG9uZ3xudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjIpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLnJlYWRJbnQ2NCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDgpIDpcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJiIS5jcmVhdGVMb25nKDAsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGludHNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjIpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuRW5jb2Rpbmc9IG9wdGlvbmFsRW5jb2RpbmdcbiAgICAgKiBAcmV0dXJucyBzdHJpbmd8VWludDhBcnJheVxuICAgICAqL1xuICAgIHN0cmluZ3MoaW5kZXg6IG51bWJlcik6IHN0cmluZztcbiAgICBzdHJpbmdzKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXk7XG4gICAgc3RyaW5ncyhpbmRleDogbnVtYmVyLCBvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBzdHJpbmdzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvclxuICAgICAqL1xuICAgIHRlbnNvcnMoaW5kZXg6IG51bWJlciwgb2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5UZW5zb3IpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcnxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMjYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgdGVuc29yc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkdyYXBoPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkdyYXBoXG4gICAgICovXG4gICAgZ3JhcGhzKGluZGV4OiBudW1iZXIsIG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGgpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkdyYXBofG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5HcmFwaCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGdyYXBoc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydEF0dHJpYnV0ZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDEzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBuYW1lT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE5hbWUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbmFtZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDAsIG5hbWVPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGRvY1N0cmluZ09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGREb2NTdHJpbmcoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZG9jU3RyaW5nT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMSwgZG9jU3RyaW5nT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuQXR0cmlidXRlVHlwZSB0eXBlXG4gICAgICovXG4gICAgc3RhdGljIGFkZFR5cGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgdHlwZTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGVUeXBlKSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkSW50MzIoMiwgdHlwZSwgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5BdHRyaWJ1dGVUeXBlLlVOREVGSU5FRCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgZlxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRGKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGY6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEZsb2F0MzIoMywgZiwgMC4wKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkxvbmcgaVxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRJKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGk6IGZsYXRidWZmZXJzLkxvbmcpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQ2NCg0LCBpLCBidWlsZGVyLmNyZWF0ZUxvbmcoMCwgMCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkUyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNSwgc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgdE9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRUKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHRPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg2LCB0T2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBnT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEcoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDcsIGdPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGZsb2F0c09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRGbG9hdHMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZmxvYXRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoOCwgZmxvYXRzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxudW1iZXI+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRmxvYXRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IG51bWJlcltdfFVpbnQ4QXJyYXkpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZEZsb2F0MzIoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydEZsb2F0c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBpbnRzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEludHMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgaW50c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDksIGludHNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLkxvbmc+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlSW50c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5Mb25nW10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig4LCBkYXRhLmxlbmd0aCwgOCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZEludDY0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRJbnRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoOCwgbnVtRWxlbXMsIDgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHN0cmluZ3NPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkU3RyaW5ncyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBzdHJpbmdzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMTAsIHN0cmluZ3NPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTdHJpbmdzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFN0cmluZ3NWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgdGVuc29yc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRUZW5zb3JzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHRlbnNvcnNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxMSwgdGVuc29yc09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVRlbnNvcnNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0VGVuc29yc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBncmFwaHNPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkR3JhcGhzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGdyYXBoc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEyLCBncmFwaHNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVHcmFwaHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0R3JhcGhzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kQXR0cmlidXRlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVBdHRyaWJ1dGUoXG4gICAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5hbWVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgZG9jU3RyaW5nT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIHR5cGU6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuQXR0cmlidXRlVHlwZSwgZjogbnVtYmVyLCBpOiBmbGF0YnVmZmVycy5Mb25nLCBzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIHRPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBmbG9hdHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgaW50c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBzdHJpbmdzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIHRlbnNvcnNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgZ3JhcGhzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgQXR0cmlidXRlLnN0YXJ0QXR0cmlidXRlKGJ1aWxkZXIpO1xuICAgICAgQXR0cmlidXRlLmFkZE5hbWUoYnVpbGRlciwgbmFtZU9mZnNldCk7XG4gICAgICBBdHRyaWJ1dGUuYWRkRG9jU3RyaW5nKGJ1aWxkZXIsIGRvY1N0cmluZ09mZnNldCk7XG4gICAgICBBdHRyaWJ1dGUuYWRkVHlwZShidWlsZGVyLCB0eXBlKTtcbiAgICAgIEF0dHJpYnV0ZS5hZGRGKGJ1aWxkZXIsIGYpO1xuICAgICAgQXR0cmlidXRlLmFkZEkoYnVpbGRlciwgaSk7XG4gICAgICBBdHRyaWJ1dGUuYWRkUyhidWlsZGVyLCBzT2Zmc2V0KTtcbiAgICAgIEF0dHJpYnV0ZS5hZGRUKGJ1aWxkZXIsIHRPZmZzZXQpO1xuICAgICAgQXR0cmlidXRlLmFkZEcoYnVpbGRlciwgZ09mZnNldCk7XG4gICAgICBBdHRyaWJ1dGUuYWRkRmxvYXRzKGJ1aWxkZXIsIGZsb2F0c09mZnNldCk7XG4gICAgICBBdHRyaWJ1dGUuYWRkSW50cyhidWlsZGVyLCBpbnRzT2Zmc2V0KTtcbiAgICAgIEF0dHJpYnV0ZS5hZGRTdHJpbmdzKGJ1aWxkZXIsIHN0cmluZ3NPZmZzZXQpO1xuICAgICAgQXR0cmlidXRlLmFkZFRlbnNvcnMoYnVpbGRlciwgdGVuc29yc09mZnNldCk7XG4gICAgICBBdHRyaWJ1dGUuYWRkR3JhcGhzKGJ1aWxkZXIsIGdyYXBoc09mZnNldCk7XG4gICAgICByZXR1cm4gQXR0cmlidXRlLmVuZEF0dHJpYnV0ZShidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBHcmFwaCB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgR3JhcGhcbiAgICAgKi9cbiAgICBfX2luaXQoaTogbnVtYmVyLCBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcik6IEdyYXBoIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIEdyYXBoPSBvYmpcbiAgICAgKiBAcmV0dXJucyBHcmFwaFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRSb290QXNHcmFwaChiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogR3JhcGgpOiBHcmFwaCB7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgR3JhcGgoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBHcmFwaD0gb2JqXG4gICAgICogQHJldHVybnMgR3JhcGhcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZVByZWZpeGVkUm9vdEFzR3JhcGgoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IEdyYXBoKTogR3JhcGgge1xuICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICByZXR1cm4gKG9iaiB8fCBuZXcgR3JhcGgoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvclxuICAgICAqL1xuICAgIGluaXRpYWxpemVycyhpbmRleDogbnVtYmVyLCBvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcik6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvcigpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGluaXRpYWxpemVyc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3ZlY3Rvcl9sZW4odGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4XG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVmFsdWVJbmZvPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlZhbHVlSW5mb1xuICAgICAqL1xuICAgIG5vZGVBcmdzKGluZGV4OiBudW1iZXIsIG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVmFsdWVJbmZvKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5WYWx1ZUluZm98bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVmFsdWVJbmZvKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgbm9kZUFyZ3NMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGU9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZVxuICAgICAqL1xuICAgIG5vZGVzKGluZGV4OiBudW1iZXIsIG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZSk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgbm9kZXNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgbWF4Tm9kZUluZGV4KCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEwKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkVWludDMyKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGVFZGdlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGVFZGdlXG4gICAgICovXG4gICAgbm9kZUVkZ2VzKGluZGV4OiBudW1iZXIsIG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTm9kZUVkZ2UpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGVFZGdlfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5Ob2RlRWRnZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIG5vZGVFZGdlc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5XG4gICAgICovXG4gICAgaW5wdXRzKGluZGV4OiBudW1iZXIpOiBzdHJpbmc7XG4gICAgaW5wdXRzKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXk7XG4gICAgaW5wdXRzKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIGlucHV0c0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5XG4gICAgICovXG4gICAgb3V0cHV0cyhpbmRleDogbnVtYmVyKTogc3RyaW5nO1xuICAgIG91dHB1dHMoaW5kZXg6IG51bWJlciwgb3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheTtcbiAgICBvdXRwdXRzKGluZGV4OiBudW1iZXIsIG9wdGlvbmFsRW5jb2Rpbmc/OiBhbnkpOiBzdHJpbmd8VWludDhBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIG91dHB1dHNMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TcGFyc2VUZW5zb3I9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU3BhcnNlVGVuc29yXG4gICAgICovXG4gICAgc3BhcnNlSW5pdGlhbGl6ZXJzKGluZGV4OiBudW1iZXIsIG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU3BhcnNlVGVuc29yKTpcbiAgICAgICAgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TcGFyc2VUZW5zb3J8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE4KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNwYXJzZVRlbnNvcigpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYiEuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIHNwYXJzZUluaXRpYWxpemVyc0xlbmd0aCgpOiBudW1iZXIge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydEdyYXBoKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoOCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgaW5pdGlhbGl6ZXJzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEluaXRpYWxpemVycyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBpbml0aWFsaXplcnNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBpbml0aWFsaXplcnNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVJbml0aWFsaXplcnNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0SW5pdGlhbGl6ZXJzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG5vZGVBcmdzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE5vZGVBcmdzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5vZGVBcmdzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMSwgbm9kZUFyZ3NPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVOb2RlQXJnc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBmbGF0YnVmZmVycy5PZmZzZXRbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIGRhdGEubGVuZ3RoLCA0KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkT2Zmc2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1aWxkZXIuZW5kVmVjdG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbnVtRWxlbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnROb2RlQXJnc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBub2Rlc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGROb2RlcyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBub2Rlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDIsIG5vZGVzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlTm9kZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0Tm9kZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBudW1iZXIgbWF4Tm9kZUluZGV4XG4gICAgICovXG4gICAgc3RhdGljIGFkZE1heE5vZGVJbmRleChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBtYXhOb2RlSW5kZXg6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDMyKDMsIG1heE5vZGVJbmRleCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgbm9kZUVkZ2VzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE5vZGVFZGdlcyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBub2RlRWRnZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg0LCBub2RlRWRnZXNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVOb2RlRWRnZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0Tm9kZUVkZ2VzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IGlucHV0c09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRJbnB1dHMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgaW5wdXRzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoNSwgaW5wdXRzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlSW5wdXRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydElucHV0c1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBvdXRwdXRzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE91dHB1dHMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgb3V0cHV0c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDYsIG91dHB1dHNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVPdXRwdXRzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydE91dHB1dHNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgc3BhcnNlSW5pdGlhbGl6ZXJzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZFNwYXJzZUluaXRpYWxpemVycyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBzcGFyc2VJbml0aWFsaXplcnNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg3LCBzcGFyc2VJbml0aWFsaXplcnNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLk9mZnNldD4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTcGFyc2VJbml0aWFsaXplcnNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZGF0YTogZmxhdGJ1ZmZlcnMuT2Zmc2V0W10pOlxuICAgICAgICBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBkYXRhLmxlbmd0aCwgNCk7XG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBidWlsZGVyLmFkZE9mZnNldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0U3BhcnNlSW5pdGlhbGl6ZXJzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZW5kR3JhcGgoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcik6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gYnVpbGRlci5lbmRPYmplY3QoKTtcbiAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZUdyYXBoKFxuICAgICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBpbml0aWFsaXplcnNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgbm9kZUFyZ3NPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgbm9kZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgbWF4Tm9kZUluZGV4OiBudW1iZXIsIG5vZGVFZGdlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBpbnB1dHNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgb3V0cHV0c09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBzcGFyc2VJbml0aWFsaXplcnNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBHcmFwaC5zdGFydEdyYXBoKGJ1aWxkZXIpO1xuICAgICAgR3JhcGguYWRkSW5pdGlhbGl6ZXJzKGJ1aWxkZXIsIGluaXRpYWxpemVyc09mZnNldCk7XG4gICAgICBHcmFwaC5hZGROb2RlQXJncyhidWlsZGVyLCBub2RlQXJnc09mZnNldCk7XG4gICAgICBHcmFwaC5hZGROb2RlcyhidWlsZGVyLCBub2Rlc09mZnNldCk7XG4gICAgICBHcmFwaC5hZGRNYXhOb2RlSW5kZXgoYnVpbGRlciwgbWF4Tm9kZUluZGV4KTtcbiAgICAgIEdyYXBoLmFkZE5vZGVFZGdlcyhidWlsZGVyLCBub2RlRWRnZXNPZmZzZXQpO1xuICAgICAgR3JhcGguYWRkSW5wdXRzKGJ1aWxkZXIsIGlucHV0c09mZnNldCk7XG4gICAgICBHcmFwaC5hZGRPdXRwdXRzKGJ1aWxkZXIsIG91dHB1dHNPZmZzZXQpO1xuICAgICAgR3JhcGguYWRkU3BhcnNlSW5pdGlhbGl6ZXJzKGJ1aWxkZXIsIHNwYXJzZUluaXRpYWxpemVyc09mZnNldCk7XG4gICAgICByZXR1cm4gR3JhcGguZW5kR3JhcGgoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgTW9kZWwge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyfG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIE1vZGVsXG4gICAgICovXG4gICAgX19pbml0KGk6IG51bWJlciwgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBNb2RlbCB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBNb2RlbD0gb2JqXG4gICAgICogQHJldHVybnMgTW9kZWxcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Um9vdEFzTW9kZWwoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IE1vZGVsKTogTW9kZWwge1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IE1vZGVsKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gTW9kZWw9IG9ialxuICAgICAqIEByZXR1cm5zIE1vZGVsXG4gICAgICovXG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc01vZGVsKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBNb2RlbCk6IE1vZGVsIHtcbiAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgcmV0dXJuIChvYmogfHwgbmV3IE1vZGVsKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuTG9uZ1xuICAgICAqL1xuICAgIGlyVmVyc2lvbigpOiBmbGF0YnVmZmVycy5Mb25nIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZEludDY0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IHRoaXMuYmIhLmNyZWF0ZUxvbmcoMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk9wZXJhdG9yU2V0SWQ9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuT3BlcmF0b3JTZXRJZFxuICAgICAqL1xuICAgIG9wc2V0SW1wb3J0KGluZGV4OiBudW1iZXIsIG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuT3BlcmF0b3JTZXRJZCk6XG4gICAgICAgIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuT3BlcmF0b3JTZXRJZHxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5PcGVyYXRvclNldElkKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgb3BzZXRJbXBvcnRMZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIHByb2R1Y2VyTmFtZSgpOiBzdHJpbmd8bnVsbDtcbiAgICBwcm9kdWNlck5hbWUob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIHByb2R1Y2VyTmFtZShvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIHByb2R1Y2VyVmVyc2lvbigpOiBzdHJpbmd8bnVsbDtcbiAgICBwcm9kdWNlclZlcnNpb24ob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIHByb2R1Y2VyVmVyc2lvbihvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEwKTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBkb21haW4oKTogc3RyaW5nfG51bGw7XG4gICAgZG9tYWluKG9wdGlvbmFsRW5jb2Rpbmc6IGZsYXRidWZmZXJzLkVuY29kaW5nKTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbDtcbiAgICBkb21haW4ob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMik7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5Mb25nXG4gICAgICovXG4gICAgbW9kZWxWZXJzaW9uKCk6IGZsYXRidWZmZXJzLkxvbmcge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEucmVhZEludDY0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IHRoaXMuYmIhLmNyZWF0ZUxvbmcoMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIGRvY1N0cmluZygpOiBzdHJpbmd8bnVsbDtcbiAgICBkb2NTdHJpbmcob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIGRvY1N0cmluZyhvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkdyYXBoPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkdyYXBofG51bGxcbiAgICAgKi9cbiAgICBncmFwaChvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLkdyYXBoKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5HcmFwaHxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgMTgpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuR3JhcGgoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBncmFwaERvY1N0cmluZygpOiBzdHJpbmd8bnVsbDtcbiAgICBncmFwaERvY1N0cmluZyhvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgZ3JhcGhEb2NTdHJpbmcob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyMCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYiEuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0TW9kZWwoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCg5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkxvbmcgaXJWZXJzaW9uXG4gICAgICovXG4gICAgc3RhdGljIGFkZElyVmVyc2lvbihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBpclZlcnNpb246IGZsYXRidWZmZXJzLkxvbmcpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRJbnQ2NCgwLCBpclZlcnNpb24sIGJ1aWxkZXIuY3JlYXRlTG9uZygwLCAwKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgb3BzZXRJbXBvcnRPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkT3BzZXRJbXBvcnQoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgb3BzZXRJbXBvcnRPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBvcHNldEltcG9ydE9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBBcnJheS48ZmxhdGJ1ZmZlcnMuT2Zmc2V0PiBkYXRhXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU9wc2V0SW1wb3J0VmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydE9wc2V0SW1wb3J0VmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG51bUVsZW1zOiBudW1iZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgbnVtRWxlbXMsIDQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHByb2R1Y2VyTmFtZU9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRQcm9kdWNlck5hbWUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgcHJvZHVjZXJOYW1lT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMiwgcHJvZHVjZXJOYW1lT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBwcm9kdWNlclZlcnNpb25PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkUHJvZHVjZXJWZXJzaW9uKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHByb2R1Y2VyVmVyc2lvbk9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDMsIHByb2R1Y2VyVmVyc2lvbk9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZG9tYWluT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZERvbWFpbihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkb21haW5PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg0LCBkb21haW5PZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuTG9uZyBtb2RlbFZlcnNpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTW9kZWxWZXJzaW9uKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG1vZGVsVmVyc2lvbjogZmxhdGJ1ZmZlcnMuTG9uZykge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZEludDY0KDUsIG1vZGVsVmVyc2lvbiwgYnVpbGRlci5jcmVhdGVMb25nKDAsIDApKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBkb2NTdHJpbmdPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkRG9jU3RyaW5nKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRvY1N0cmluZ09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDYsIGRvY1N0cmluZ09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZ3JhcGhPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkR3JhcGgoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZ3JhcGhPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg3LCBncmFwaE9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZ3JhcGhEb2NTdHJpbmdPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkR3JhcGhEb2NTdHJpbmcoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgZ3JhcGhEb2NTdHJpbmdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCg4LCBncmFwaERvY1N0cmluZ09mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRNb2RlbChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlTW9kZWwoXG4gICAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGlyVmVyc2lvbjogZmxhdGJ1ZmZlcnMuTG9uZywgb3BzZXRJbXBvcnRPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgcHJvZHVjZXJOYW1lT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsIHByb2R1Y2VyVmVyc2lvbk9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBkb21haW5PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgbW9kZWxWZXJzaW9uOiBmbGF0YnVmZmVycy5Mb25nLCBkb2NTdHJpbmdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgZ3JhcGhPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCwgZ3JhcGhEb2NTdHJpbmdPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBNb2RlbC5zdGFydE1vZGVsKGJ1aWxkZXIpO1xuICAgICAgTW9kZWwuYWRkSXJWZXJzaW9uKGJ1aWxkZXIsIGlyVmVyc2lvbik7XG4gICAgICBNb2RlbC5hZGRPcHNldEltcG9ydChidWlsZGVyLCBvcHNldEltcG9ydE9mZnNldCk7XG4gICAgICBNb2RlbC5hZGRQcm9kdWNlck5hbWUoYnVpbGRlciwgcHJvZHVjZXJOYW1lT2Zmc2V0KTtcbiAgICAgIE1vZGVsLmFkZFByb2R1Y2VyVmVyc2lvbihidWlsZGVyLCBwcm9kdWNlclZlcnNpb25PZmZzZXQpO1xuICAgICAgTW9kZWwuYWRkRG9tYWluKGJ1aWxkZXIsIGRvbWFpbk9mZnNldCk7XG4gICAgICBNb2RlbC5hZGRNb2RlbFZlcnNpb24oYnVpbGRlciwgbW9kZWxWZXJzaW9uKTtcbiAgICAgIE1vZGVsLmFkZERvY1N0cmluZyhidWlsZGVyLCBkb2NTdHJpbmdPZmZzZXQpO1xuICAgICAgTW9kZWwuYWRkR3JhcGgoYnVpbGRlciwgZ3JhcGhPZmZzZXQpO1xuICAgICAgTW9kZWwuYWRkR3JhcGhEb2NTdHJpbmcoYnVpbGRlciwgZ3JhcGhEb2NTdHJpbmdPZmZzZXQpO1xuICAgICAgcmV0dXJuIE1vZGVsLmVuZE1vZGVsKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIEtlcm5lbENyZWF0ZUluZm9zIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBLZXJuZWxDcmVhdGVJbmZvc1xuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogS2VybmVsQ3JlYXRlSW5mb3Mge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gS2VybmVsQ3JlYXRlSW5mb3M9IG9ialxuICAgICAqIEByZXR1cm5zIEtlcm5lbENyZWF0ZUluZm9zXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc0tlcm5lbENyZWF0ZUluZm9zKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBLZXJuZWxDcmVhdGVJbmZvcyk6IEtlcm5lbENyZWF0ZUluZm9zIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBLZXJuZWxDcmVhdGVJbmZvcygpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIEtlcm5lbENyZWF0ZUluZm9zPSBvYmpcbiAgICAgKiBAcmV0dXJucyBLZXJuZWxDcmVhdGVJbmZvc1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNLZXJuZWxDcmVhdGVJbmZvcyhiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogS2VybmVsQ3JlYXRlSW5mb3MpOlxuICAgICAgICBLZXJuZWxDcmVhdGVJbmZvcyB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBLZXJuZWxDcmVhdGVJbmZvcygpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICAgKi9cbiAgICBub2RlSW5kaWNlcyhpbmRleDogbnVtYmVyKTogbnVtYmVyfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkVWludDMyKHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIG51bWJlclxuICAgICAqL1xuICAgIG5vZGVJbmRpY2VzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFVpbnQzMkFycmF5XG4gICAgICovXG4gICAgbm9kZUluZGljZXNBcnJheSgpOiBVaW50MzJBcnJheXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID9cbiAgICAgICAgICBuZXcgVWludDMyQXJyYXkoXG4gICAgICAgICAgICAgIHRoaXMuYmIhLmJ5dGVzKCkuYnVmZmVyLCB0aGlzLmJiIS5ieXRlcygpLmJ5dGVPZmZzZXQgKyB0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCksXG4gICAgICAgICAgICAgIHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkpIDpcbiAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaW5kZXhcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5Mb25nXG4gICAgICovXG4gICAga2VybmVsRGVmSGFzaGVzKGluZGV4OiBudW1iZXIpOiBmbGF0YnVmZmVycy5Mb25nfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5yZWFkVWludDY0KHRoaXMuYmIhLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogOCkgOlxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmIhLmNyZWF0ZUxvbmcoMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAga2VybmVsRGVmSGFzaGVzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRLZXJuZWxDcmVhdGVJbmZvcyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0T2JqZWN0KDIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG5vZGVJbmRpY2VzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZE5vZGVJbmRpY2VzKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG5vZGVJbmRpY2VzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMCwgbm9kZUluZGljZXNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPG51bWJlcj4gZGF0YVxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVOb2RlSW5kaWNlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBkYXRhOiBudW1iZXJbXXxVaW50OEFycmF5KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRJbnQzMihkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmVuZFZlY3RvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gbnVtYmVyIG51bUVsZW1zXG4gICAgICovXG4gICAgc3RhdGljIHN0YXJ0Tm9kZUluZGljZXNWZWN0b3IoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbnVtRWxlbXM6IG51bWJlcikge1xuICAgICAgYnVpbGRlci5zdGFydFZlY3Rvcig0LCBudW1FbGVtcywgNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQga2VybmVsRGVmSGFzaGVzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEtlcm5lbERlZkhhc2hlcyhidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBrZXJuZWxEZWZIYXNoZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgxLCBrZXJuZWxEZWZIYXNoZXNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gQXJyYXkuPGZsYXRidWZmZXJzLkxvbmc+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlS2VybmVsRGVmSGFzaGVzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLkxvbmdbXSk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDgsIGRhdGEubGVuZ3RoLCA4KTtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkSW50NjQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydEtlcm5lbERlZkhhc2hlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDgsIG51bUVsZW1zLCA4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZEtlcm5lbENyZWF0ZUluZm9zKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVLZXJuZWxDcmVhdGVJbmZvcyhcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgbm9kZUluZGljZXNPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAga2VybmVsRGVmSGFzaGVzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgS2VybmVsQ3JlYXRlSW5mb3Muc3RhcnRLZXJuZWxDcmVhdGVJbmZvcyhidWlsZGVyKTtcbiAgICAgIEtlcm5lbENyZWF0ZUluZm9zLmFkZE5vZGVJbmRpY2VzKGJ1aWxkZXIsIG5vZGVJbmRpY2VzT2Zmc2V0KTtcbiAgICAgIEtlcm5lbENyZWF0ZUluZm9zLmFkZEtlcm5lbERlZkhhc2hlcyhidWlsZGVyLCBrZXJuZWxEZWZIYXNoZXNPZmZzZXQpO1xuICAgICAgcmV0dXJuIEtlcm5lbENyZWF0ZUluZm9zLmVuZEtlcm5lbENyZWF0ZUluZm9zKGJ1aWxkZXIpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzIHtcbiAgZXhwb3J0IGNsYXNzIFN1YkdyYXBoU2Vzc2lvblN0YXRlIHtcbiAgICBiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcnxudWxsID0gbnVsbDtcblxuICAgIGJiX3BvcyA9IDA7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBTdWJHcmFwaFNlc3Npb25TdGF0ZVxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogU3ViR3JhcGhTZXNzaW9uU3RhdGUge1xuICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gU3ViR3JhcGhTZXNzaW9uU3RhdGU9IG9ialxuICAgICAqIEByZXR1cm5zIFN1YkdyYXBoU2Vzc2lvblN0YXRlXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc1N1YkdyYXBoU2Vzc2lvblN0YXRlKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBTdWJHcmFwaFNlc3Npb25TdGF0ZSk6IFN1YkdyYXBoU2Vzc2lvblN0YXRlIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBTdWJHcmFwaFNlc3Npb25TdGF0ZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFN1YkdyYXBoU2Vzc2lvblN0YXRlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBTdWJHcmFwaFNlc3Npb25TdGF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNTdWJHcmFwaFNlc3Npb25TdGF0ZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogU3ViR3JhcGhTZXNzaW9uU3RhdGUpOlxuICAgICAgICBTdWJHcmFwaFNlc3Npb25TdGF0ZSB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBTdWJHcmFwaFNlc3Npb25TdGF0ZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5FbmNvZGluZz0gb3B0aW9uYWxFbmNvZGluZ1xuICAgICAqIEByZXR1cm5zIHN0cmluZ3xVaW50OEFycmF5fG51bGxcbiAgICAgKi9cbiAgICBncmFwaElkKCk6IHN0cmluZ3xudWxsO1xuICAgIGdyYXBoSWQob3B0aW9uYWxFbmNvZGluZzogZmxhdGJ1ZmZlcnMuRW5jb2RpbmcpOiBzdHJpbmd8VWludDhBcnJheXxudWxsO1xuICAgIGdyYXBoSWQob3B0aW9uYWxFbmNvZGluZz86IGFueSk6IHN0cmluZ3xVaW50OEFycmF5fG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiIS5fX3N0cmluZyh0aGlzLmJiX3BvcyArIG9mZnNldCwgb3B0aW9uYWxFbmNvZGluZykgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNlc3Npb25TdGF0ZT0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TZXNzaW9uU3RhdGV8bnVsbFxuICAgICAqL1xuICAgIHNlc3Npb25TdGF0ZShvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNlc3Npb25TdGF0ZSk6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNlc3Npb25TdGF0ZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFN1YkdyYXBoU2Vzc2lvblN0YXRlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgZ3JhcGhJZE9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRHcmFwaElkKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGdyYXBoSWRPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBncmFwaElkT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBzZXNzaW9uU3RhdGVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkU2Vzc2lvblN0YXRlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHNlc3Npb25TdGF0ZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIHNlc3Npb25TdGF0ZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRTdWJHcmFwaFNlc3Npb25TdGF0ZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgYnVpbGRlci5yZXF1aXJlZEZpZWxkKG9mZnNldCwgNCk7ICAvLyBncmFwaF9pZFxuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlU3ViR3JhcGhTZXNzaW9uU3RhdGUoXG4gICAgICAgIGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGdyYXBoSWRPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCxcbiAgICAgICAgc2Vzc2lvblN0YXRlT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgU3ViR3JhcGhTZXNzaW9uU3RhdGUuc3RhcnRTdWJHcmFwaFNlc3Npb25TdGF0ZShidWlsZGVyKTtcbiAgICAgIFN1YkdyYXBoU2Vzc2lvblN0YXRlLmFkZEdyYXBoSWQoYnVpbGRlciwgZ3JhcGhJZE9mZnNldCk7XG4gICAgICBTdWJHcmFwaFNlc3Npb25TdGF0ZS5hZGRTZXNzaW9uU3RhdGUoYnVpbGRlciwgc2Vzc2lvblN0YXRlT2Zmc2V0KTtcbiAgICAgIHJldHVybiBTdWJHcmFwaFNlc3Npb25TdGF0ZS5lbmRTdWJHcmFwaFNlc3Npb25TdGF0ZShidWlsZGVyKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBuYW1lc3BhY2Ugb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicyB7XG4gIGV4cG9ydCBjbGFzcyBTZXNzaW9uU3RhdGUge1xuICAgIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyfG51bGwgPSBudWxsO1xuXG4gICAgYmJfcG9zID0gMDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbnVtYmVyIGlcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEByZXR1cm5zIFNlc3Npb25TdGF0ZVxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogU2Vzc2lvblN0YXRlIHtcbiAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHBhcmFtIFNlc3Npb25TdGF0ZT0gb2JqXG4gICAgICogQHJldHVybnMgU2Vzc2lvblN0YXRlXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc1Nlc3Npb25TdGF0ZShiYjogZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciwgb2JqPzogU2Vzc2lvblN0YXRlKTogU2Vzc2lvblN0YXRlIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBTZXNzaW9uU3RhdGUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBTZXNzaW9uU3RhdGU9IG9ialxuICAgICAqIEByZXR1cm5zIFNlc3Npb25TdGF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNTZXNzaW9uU3RhdGUoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IFNlc3Npb25TdGF0ZSk6IFNlc3Npb25TdGF0ZSB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBTZXNzaW9uU3RhdGUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5LZXJuZWxDcmVhdGVJbmZvcz0gb2JqXG4gICAgICogQHJldHVybnMgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5LZXJuZWxDcmVhdGVJbmZvc3xudWxsXG4gICAgICovXG4gICAga2VybmVscyhvYmo/OiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLktlcm5lbENyZWF0ZUluZm9zKTogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5LZXJuZWxDcmVhdGVJbmZvc3xudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5LZXJuZWxDcmVhdGVJbmZvcygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuX19pbml0KHRoaXMuYmIhLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG51bWJlciBpbmRleFxuICAgICAqIEBwYXJhbSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlN1YkdyYXBoU2Vzc2lvblN0YXRlPSBvYmpcbiAgICAgKiBAcmV0dXJucyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlN1YkdyYXBoU2Vzc2lvblN0YXRlXG4gICAgICovXG4gICAgc3ViR3JhcGhTZXNzaW9uU3RhdGVzKGluZGV4OiBudW1iZXIsIG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU3ViR3JhcGhTZXNzaW9uU3RhdGUpOlxuICAgICAgICBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlN1YkdyYXBoU2Vzc2lvblN0YXRlfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlN1YkdyYXBoU2Vzc2lvblN0YXRlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiIS5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCkgKyBpbmRleCAqIDQpLCB0aGlzLmJiISkgOlxuICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMgbnVtYmVyXG4gICAgICovXG4gICAgc3ViR3JhcGhTZXNzaW9uU3RhdGVzTGVuZ3RoKCk6IG51bWJlciB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRTZXNzaW9uU3RhdGUoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlcikge1xuICAgICAgYnVpbGRlci5zdGFydE9iamVjdCgyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBrZXJuZWxzT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGFkZEtlcm5lbHMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwga2VybmVsc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDAsIGtlcm5lbHNPZmZzZXQsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IHN1YkdyYXBoU2Vzc2lvblN0YXRlc09mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRTdWJHcmFwaFNlc3Npb25TdGF0ZXMoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgc3ViR3JhcGhTZXNzaW9uU3RhdGVzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuYWRkRmllbGRPZmZzZXQoMSwgc3ViR3JhcGhTZXNzaW9uU3RhdGVzT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIEFycmF5LjxmbGF0YnVmZmVycy5PZmZzZXQ+IGRhdGFcbiAgICAgKiBAcmV0dXJucyBmbGF0YnVmZmVycy5PZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlU3ViR3JhcGhTZXNzaW9uU3RhdGVzVmVjdG9yKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIGRhdGE6IGZsYXRidWZmZXJzLk9mZnNldFtdKTpcbiAgICAgICAgZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRWZWN0b3IoNCwgZGF0YS5sZW5ndGgsIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYnVpbGRlci5hZGRPZmZzZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVpbGRlci5lbmRWZWN0b3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIG51bWJlciBudW1FbGVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBzdGFydFN1YkdyYXBoU2Vzc2lvblN0YXRlc1ZlY3RvcihidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBudW1FbGVtczogbnVtYmVyKSB7XG4gICAgICBidWlsZGVyLnN0YXJ0VmVjdG9yKDQsIG51bUVsZW1zLCA0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHJldHVybnMgZmxhdGJ1ZmZlcnMuT2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGVuZFNlc3Npb25TdGF0ZShidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyKTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIGxldCBvZmZzZXQgPSBidWlsZGVyLmVuZE9iamVjdCgpO1xuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlU2Vzc2lvblN0YXRlKFxuICAgICAgICBidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBrZXJuZWxzT2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQsXG4gICAgICAgIHN1YkdyYXBoU2Vzc2lvblN0YXRlc09mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KTogZmxhdGJ1ZmZlcnMuT2Zmc2V0IHtcbiAgICAgIFNlc3Npb25TdGF0ZS5zdGFydFNlc3Npb25TdGF0ZShidWlsZGVyKTtcbiAgICAgIFNlc3Npb25TdGF0ZS5hZGRLZXJuZWxzKGJ1aWxkZXIsIGtlcm5lbHNPZmZzZXQpO1xuICAgICAgU2Vzc2lvblN0YXRlLmFkZFN1YkdyYXBoU2Vzc2lvblN0YXRlcyhidWlsZGVyLCBzdWJHcmFwaFNlc3Npb25TdGF0ZXNPZmZzZXQpO1xuICAgICAgcmV0dXJuIFNlc3Npb25TdGF0ZS5lbmRTZXNzaW9uU3RhdGUoYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgbmFtZXNwYWNlIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMge1xuICBleHBvcnQgY2xhc3MgSW5mZXJlbmNlU2Vzc2lvbiB7XG4gICAgYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXJ8bnVsbCA9IG51bGw7XG5cbiAgICBiYl9wb3MgPSAwO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBudW1iZXIgaVxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CeXRlQnVmZmVyIGJiXG4gICAgICogQHJldHVybnMgSW5mZXJlbmNlU2Vzc2lvblxuICAgICAqL1xuICAgIF9faW5pdChpOiBudW1iZXIsIGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKTogSW5mZXJlbmNlU2Vzc2lvbiB7XG4gICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICB0aGlzLmJiID0gYmI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlciBiYlxuICAgICAqIEBwYXJhbSBJbmZlcmVuY2VTZXNzaW9uPSBvYmpcbiAgICAgKiBAcmV0dXJucyBJbmZlcmVuY2VTZXNzaW9uXG4gICAgICovXG4gICAgc3RhdGljIGdldFJvb3RBc0luZmVyZW5jZVNlc3Npb24oYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIsIG9iaj86IEluZmVyZW5jZVNlc3Npb24pOiBJbmZlcmVuY2VTZXNzaW9uIHtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBJbmZlcmVuY2VTZXNzaW9uKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcGFyYW0gSW5mZXJlbmNlU2Vzc2lvbj0gb2JqXG4gICAgICogQHJldHVybnMgSW5mZXJlbmNlU2Vzc2lvblxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNJbmZlcmVuY2VTZXNzaW9uKGJiOiBmbGF0YnVmZmVycy5CeXRlQnVmZmVyLCBvYmo/OiBJbmZlcmVuY2VTZXNzaW9uKTogSW5mZXJlbmNlU2Vzc2lvbiB7XG4gICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgIHJldHVybiAob2JqIHx8IG5ldyBJbmZlcmVuY2VTZXNzaW9uKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIgYmJcbiAgICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAgICovXG4gICAgc3RhdGljIGJ1ZmZlckhhc0lkZW50aWZpZXIoYmI6IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiBiYi5fX2hhc19pZGVudGlmaWVyKCdPUlRNJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkVuY29kaW5nPSBvcHRpb25hbEVuY29kaW5nXG4gICAgICogQHJldHVybnMgc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbFxuICAgICAqL1xuICAgIG9ydFZlcnNpb24oKTogc3RyaW5nfG51bGw7XG4gICAgb3J0VmVyc2lvbihvcHRpb25hbEVuY29kaW5nOiBmbGF0YnVmZmVycy5FbmNvZGluZyk6IHN0cmluZ3xVaW50OEFycmF5fG51bGw7XG4gICAgb3J0VmVyc2lvbihvcHRpb25hbEVuY29kaW5nPzogYW55KTogc3RyaW5nfFVpbnQ4QXJyYXl8bnVsbCB7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5iYiEuX19vZmZzZXQodGhpcy5iYl9wb3MsIDQpO1xuICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIhLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTW9kZWw9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTW9kZWx8bnVsbFxuICAgICAqL1xuICAgIG1vZGVsKG9iaj86IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuTW9kZWwpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk1vZGVsfG51bGwge1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuYmIhLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk1vZGVsKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5fX2luaXQodGhpcy5iYiEuX19pbmRpcmVjdCh0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TZXNzaW9uU3RhdGU9IG9ialxuICAgICAqIEByZXR1cm5zIG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuU2Vzc2lvblN0YXRlfG51bGxcbiAgICAgKi9cbiAgICBzZXNzaW9uU3RhdGUob2JqPzogb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TZXNzaW9uU3RhdGUpOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlNlc3Npb25TdGF0ZXxudWxsIHtcbiAgICAgIGxldCBvZmZzZXQgPSB0aGlzLmJiIS5fX29mZnNldCh0aGlzLmJiX3BvcywgOCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicy5TZXNzaW9uU3RhdGUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLl9faW5pdCh0aGlzLmJiIS5fX2luZGlyZWN0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSwgdGhpcy5iYiEpIDpcbiAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RhcnRJbmZlcmVuY2VTZXNzaW9uKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuc3RhcnRPYmplY3QoMyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgb3J0VmVyc2lvbk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRPcnRWZXJzaW9uKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG9ydFZlcnNpb25PZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCkge1xuICAgICAgYnVpbGRlci5hZGRGaWVsZE9mZnNldCgwLCBvcnRWZXJzaW9uT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBtb2RlbE9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRNb2RlbChidWlsZGVyOiBmbGF0YnVmZmVycy5CdWlsZGVyLCBtb2RlbE9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDEsIG1vZGVsT2Zmc2V0LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuQnVpbGRlciBidWlsZGVyXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLk9mZnNldCBzZXNzaW9uU3RhdGVPZmZzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkU2Vzc2lvblN0YXRlKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIHNlc3Npb25TdGF0ZU9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmFkZEZpZWxkT2Zmc2V0KDIsIHNlc3Npb25TdGF0ZU9mZnNldCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEByZXR1cm5zIGZsYXRidWZmZXJzLk9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmRJbmZlcmVuY2VTZXNzaW9uKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIpOiBmbGF0YnVmZmVycy5PZmZzZXQge1xuICAgICAgbGV0IG9mZnNldCA9IGJ1aWxkZXIuZW5kT2JqZWN0KCk7XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5CdWlsZGVyIGJ1aWxkZXJcbiAgICAgKiBAcGFyYW0gZmxhdGJ1ZmZlcnMuT2Zmc2V0IG9mZnNldFxuICAgICAqL1xuICAgIHN0YXRpYyBmaW5pc2hJbmZlcmVuY2VTZXNzaW9uQnVmZmVyKGJ1aWxkZXI6IGZsYXRidWZmZXJzLkJ1aWxkZXIsIG9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0KSB7XG4gICAgICBidWlsZGVyLmZpbmlzaChvZmZzZXQsICdPUlRNJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZsYXRidWZmZXJzLkJ1aWxkZXIgYnVpbGRlclxuICAgICAqIEBwYXJhbSBmbGF0YnVmZmVycy5PZmZzZXQgb2Zmc2V0XG4gICAgICovXG4gICAgc3RhdGljIGZpbmlzaFNpemVQcmVmaXhlZEluZmVyZW5jZVNlc3Npb25CdWZmZXIoYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgb2Zmc2V0OiBmbGF0YnVmZmVycy5PZmZzZXQpIHtcbiAgICAgIGJ1aWxkZXIuZmluaXNoKG9mZnNldCwgJ09SVE0nLCB0cnVlKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbihcbiAgICAgICAgYnVpbGRlcjogZmxhdGJ1ZmZlcnMuQnVpbGRlciwgb3J0VmVyc2lvbk9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LCBtb2RlbE9mZnNldDogZmxhdGJ1ZmZlcnMuT2Zmc2V0LFxuICAgICAgICBzZXNzaW9uU3RhdGVPZmZzZXQ6IGZsYXRidWZmZXJzLk9mZnNldCk6IGZsYXRidWZmZXJzLk9mZnNldCB7XG4gICAgICBJbmZlcmVuY2VTZXNzaW9uLnN0YXJ0SW5mZXJlbmNlU2Vzc2lvbihidWlsZGVyKTtcbiAgICAgIEluZmVyZW5jZVNlc3Npb24uYWRkT3J0VmVyc2lvbihidWlsZGVyLCBvcnRWZXJzaW9uT2Zmc2V0KTtcbiAgICAgIEluZmVyZW5jZVNlc3Npb24uYWRkTW9kZWwoYnVpbGRlciwgbW9kZWxPZmZzZXQpO1xuICAgICAgSW5mZXJlbmNlU2Vzc2lvbi5hZGRTZXNzaW9uU3RhdGUoYnVpbGRlciwgc2Vzc2lvblN0YXRlT2Zmc2V0KTtcbiAgICAgIHJldHVybiBJbmZlcmVuY2VTZXNzaW9uLmVuZEluZmVyZW5jZVNlc3Npb24oYnVpbGRlcik7XG4gICAgfVxuICB9XG59XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gYXNQcm9taXNlO1xyXG5cclxuLyoqXHJcbiAqIENhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIHV0aWwuYXNQcm9taXNlfS5cclxuICogQHR5cGVkZWYgYXNQcm9taXNlQ2FsbGJhY2tcclxuICogQHR5cGUge2Z1bmN0aW9ufVxyXG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnlcclxuICogQHBhcmFtIHsuLi4qfSBwYXJhbXMgQWRkaXRpb25hbCBhcmd1bWVudHNcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHByb21pc2UgZnJvbSBhIG5vZGUtc3R5bGUgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBwYXJhbSB7YXNQcm9taXNlQ2FsbGJhY2t9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcclxuICogQHBhcmFtIHsqfSBjdHggRnVuY3Rpb24gY29udGV4dFxyXG4gKiBAcGFyYW0gey4uLip9IHBhcmFtcyBGdW5jdGlvbiBhcmd1bWVudHNcclxuICogQHJldHVybnMge1Byb21pc2U8Kj59IFByb21pc2lmaWVkIGZ1bmN0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBhc1Byb21pc2UoZm4sIGN0eC8qLCB2YXJhcmdzICovKSB7XHJcbiAgICB2YXIgcGFyYW1zICA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSksXHJcbiAgICAgICAgb2Zmc2V0ICA9IDAsXHJcbiAgICAgICAgaW5kZXggICA9IDIsXHJcbiAgICAgICAgcGVuZGluZyA9IHRydWU7XHJcbiAgICB3aGlsZSAoaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoKVxyXG4gICAgICAgIHBhcmFtc1tvZmZzZXQrK10gPSBhcmd1bWVudHNbaW5kZXgrK107XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgcGFyYW1zW29mZnNldF0gPSBmdW5jdGlvbiBjYWxsYmFjayhlcnIvKiwgdmFyYXJncyAqLykge1xyXG4gICAgICAgICAgICBpZiAocGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycilcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBwYXJhbXMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNbb2Zmc2V0KytdID0gYXJndW1lbnRzW29mZnNldF07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZS5hcHBseShudWxsLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmbi5hcHBseShjdHggfHwgbnVsbCwgcGFyYW1zKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgaWYgKHBlbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLyoqXHJcbiAqIEEgbWluaW1hbCBiYXNlNjQgaW1wbGVtZW50YXRpb24gZm9yIG51bWJlciBhcnJheXMuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcbnZhciBiYXNlNjQgPSBleHBvcnRzO1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGJ5dGUgbGVuZ3RoIG9mIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIEJhc2U2NCBlbmNvZGVkIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gKi9cclxuYmFzZTY0Lmxlbmd0aCA9IGZ1bmN0aW9uIGxlbmd0aChzdHJpbmcpIHtcclxuICAgIHZhciBwID0gc3RyaW5nLmxlbmd0aDtcclxuICAgIGlmICghcClcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIHZhciBuID0gMDtcclxuICAgIHdoaWxlICgtLXAgJSA0ID4gMSAmJiBzdHJpbmcuY2hhckF0KHApID09PSBcIj1cIilcclxuICAgICAgICArK247XHJcbiAgICByZXR1cm4gTWF0aC5jZWlsKHN0cmluZy5sZW5ndGggKiAzKSAvIDQgLSBuO1xyXG59O1xyXG5cclxuLy8gQmFzZTY0IGVuY29kaW5nIHRhYmxlXHJcbnZhciBiNjQgPSBuZXcgQXJyYXkoNjQpO1xyXG5cclxuLy8gQmFzZTY0IGRlY29kaW5nIHRhYmxlXHJcbnZhciBzNjQgPSBuZXcgQXJyYXkoMTIzKTtcclxuXHJcbi8vIDY1Li45MCwgOTcuLjEyMiwgNDguLjU3LCA0MywgNDdcclxuZm9yICh2YXIgaSA9IDA7IGkgPCA2NDspXHJcbiAgICBzNjRbYjY0W2ldID0gaSA8IDI2ID8gaSArIDY1IDogaSA8IDUyID8gaSArIDcxIDogaSA8IDYyID8gaSAtIDQgOiBpIC0gNTkgfCA0M10gPSBpKys7XHJcblxyXG4vKipcclxuICogRW5jb2RlcyBhIGJ1ZmZlciB0byBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgU291cmNlIHN0YXJ0XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgU291cmNlIGVuZFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcclxuICovXHJcbmJhc2U2NC5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoYnVmZmVyLCBzdGFydCwgZW5kKSB7XHJcbiAgICB2YXIgcGFydHMgPSBudWxsLFxyXG4gICAgICAgIGNodW5rID0gW107XHJcbiAgICB2YXIgaSA9IDAsIC8vIG91dHB1dCBpbmRleFxyXG4gICAgICAgIGogPSAwLCAvLyBnb3RvIGluZGV4XHJcbiAgICAgICAgdDsgICAgIC8vIHRlbXBvcmFyeVxyXG4gICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XHJcbiAgICAgICAgdmFyIGIgPSBidWZmZXJbc3RhcnQrK107XHJcbiAgICAgICAgc3dpdGNoIChqKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbYiA+PiAyXTtcclxuICAgICAgICAgICAgICAgIHQgPSAoYiAmIDMpIDw8IDQ7XHJcbiAgICAgICAgICAgICAgICBqID0gMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W3QgfCBiID4+IDRdO1xyXG4gICAgICAgICAgICAgICAgdCA9IChiICYgMTUpIDw8IDI7XHJcbiAgICAgICAgICAgICAgICBqID0gMjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W3QgfCBiID4+IDZdO1xyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFtiICYgNjNdO1xyXG4gICAgICAgICAgICAgICAgaiA9IDA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGkgPiA4MTkxKSB7XHJcbiAgICAgICAgICAgIChwYXJ0cyB8fCAocGFydHMgPSBbXSkpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rKSk7XHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChqKSB7XHJcbiAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFt0XTtcclxuICAgICAgICBjaHVua1tpKytdID0gNjE7XHJcbiAgICAgICAgaWYgKGogPT09IDEpXHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSA2MTtcclxuICAgIH1cclxuICAgIGlmIChwYXJ0cykge1xyXG4gICAgICAgIGlmIChpKVxyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSkpO1xyXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSk7XHJcbn07XHJcblxyXG52YXIgaW52YWxpZEVuY29kaW5nID0gXCJpbnZhbGlkIGVuY29kaW5nXCI7XHJcblxyXG4vKipcclxuICogRGVjb2RlcyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB0byBhIGJ1ZmZlci5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTb3VyY2Ugc3RyaW5nXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIERlc3RpbmF0aW9uIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IERlc3RpbmF0aW9uIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBOdW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgZW5jb2RpbmcgaXMgaW52YWxpZFxyXG4gKi9cclxuYmFzZTY0LmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShzdHJpbmcsIGJ1ZmZlciwgb2Zmc2V0KSB7XHJcbiAgICB2YXIgc3RhcnQgPSBvZmZzZXQ7XHJcbiAgICB2YXIgaiA9IDAsIC8vIGdvdG8gaW5kZXhcclxuICAgICAgICB0OyAgICAgLy8gdGVtcG9yYXJ5XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7KSB7XHJcbiAgICAgICAgdmFyIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpKyspO1xyXG4gICAgICAgIGlmIChjID09PSA2MSAmJiBqID4gMSlcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgaWYgKChjID0gczY0W2NdKSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihpbnZhbGlkRW5jb2RpbmcpO1xyXG4gICAgICAgIHN3aXRjaCAoaikge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICB0ID0gYztcclxuICAgICAgICAgICAgICAgIGogPSAxO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSB0IDw8IDIgfCAoYyAmIDQ4KSA+PiA0O1xyXG4gICAgICAgICAgICAgICAgdCA9IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gKHQgJiAxNSkgPDwgNCB8IChjICYgNjApID4+IDI7XHJcbiAgICAgICAgICAgICAgICB0ID0gYztcclxuICAgICAgICAgICAgICAgIGogPSAzO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSAodCAmIDMpIDw8IDYgfCBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaiA9PT0gMSlcclxuICAgICAgICB0aHJvdyBFcnJvcihpbnZhbGlkRW5jb2RpbmcpO1xyXG4gICAgcmV0dXJuIG9mZnNldCAtIHN0YXJ0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgc3RyaW5nIGFwcGVhcnMgdG8gYmUgYmFzZTY0IGVuY29kZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU3RyaW5nIHRvIHRlc3RcclxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBwcm9iYWJseSBiYXNlNjQgZW5jb2RlZCwgb3RoZXJ3aXNlIGZhbHNlXHJcbiAqL1xyXG5iYXNlNjQudGVzdCA9IGZ1bmN0aW9uIHRlc3Qoc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gL14oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezJ9PT18W0EtWmEtejAtOSsvXXszfT0pPyQvLnRlc3Qoc3RyaW5nKTtcclxufTtcclxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGV2ZW50IGVtaXR0ZXIgaW5zdGFuY2UuXHJcbiAqIEBjbGFzc2Rlc2MgQSBtaW5pbWFsIGV2ZW50IGVtaXR0ZXIuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsKj59XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lci5cclxuICogQHBhcmFtIHtzdHJpbmd9IGV2dCBFdmVudCBuYW1lXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIExpc3RlbmVyXHJcbiAqIEBwYXJhbSB7Kn0gW2N0eF0gTGlzdGVuZXIgY29udGV4dFxyXG4gKiBAcmV0dXJucyB7dXRpbC5FdmVudEVtaXR0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2dCwgZm4sIGN0eCkge1xyXG4gICAgKHRoaXMuX2xpc3RlbmVyc1tldnRdIHx8ICh0aGlzLl9saXN0ZW5lcnNbZXZ0XSA9IFtdKSkucHVzaCh7XHJcbiAgICAgICAgZm4gIDogZm4sXHJcbiAgICAgICAgY3R4IDogY3R4IHx8IHRoaXNcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lciBvciBhbnkgbWF0Y2hpbmcgbGlzdGVuZXJzIGlmIGFyZ3VtZW50cyBhcmUgb21pdHRlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IFtldnRdIEV2ZW50IG5hbWUuIFJlbW92ZXMgYWxsIGxpc3RlbmVycyBpZiBvbWl0dGVkLlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbZm5dIExpc3RlbmVyIHRvIHJlbW92ZS4gUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIG9mIGBldnRgIGlmIG9taXR0ZWQuXHJcbiAqIEByZXR1cm5zIHt1dGlsLkV2ZW50RW1pdHRlcn0gYHRoaXNgXHJcbiAqL1xyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIG9mZihldnQsIGZuKSB7XHJcbiAgICBpZiAoZXZ0ID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoZm4gPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2dF0gPSBbXTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1tldnRdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7KVxyXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5mbiA9PT0gZm4pXHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICArK2k7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRW1pdHMgYW4gZXZlbnQgYnkgY2FsbGluZyBpdHMgbGlzdGVuZXJzIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBldnQgRXZlbnQgbmFtZVxyXG4gKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzXHJcbiAqIEByZXR1cm5zIHt1dGlsLkV2ZW50RW1pdHRlcn0gYHRoaXNgXHJcbiAqL1xyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2dCkge1xyXG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1tldnRdO1xyXG4gICAgaWYgKGxpc3RlbmVycykge1xyXG4gICAgICAgIHZhciBhcmdzID0gW10sXHJcbiAgICAgICAgICAgIGkgPSAxO1xyXG4gICAgICAgIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDspXHJcbiAgICAgICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7KVxyXG4gICAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2krK10uY3R4LCBhcmdzKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoZmFjdG9yeSk7XHJcblxyXG4vKipcclxuICogUmVhZHMgLyB3cml0ZXMgZmxvYXRzIC8gZG91YmxlcyBmcm9tIC8gdG8gYnVmZmVycy5cclxuICogQG5hbWUgdXRpbC5mbG9hdFxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDMyIGJpdCBmbG9hdCB0byBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVGbG9hdExFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSAzMiBiaXQgZmxvYXQgdG8gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRmxvYXRCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSAzMiBiaXQgZmxvYXQgZnJvbSBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZEZsb2F0TEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgMzIgYml0IGZsb2F0IGZyb20gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWRGbG9hdEJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSA2NCBiaXQgZG91YmxlIHRvIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZURvdWJsZUxFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSA2NCBiaXQgZG91YmxlIHRvIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZURvdWJsZUJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDY0IGJpdCBkb3VibGUgZnJvbSBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZERvdWJsZUxFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDY0IGJpdCBkb3VibGUgZnJvbSBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZERvdWJsZUJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8vIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHRoZSBwdXJwb3NlIG9mIG5vZGUtYmFzZWQgdGVzdGluZyBpbiBtb2RpZmllZCBnbG9iYWwgZW52aXJvbm1lbnRzXHJcbmZ1bmN0aW9uIGZhY3RvcnkoZXhwb3J0cykge1xyXG5cclxuICAgIC8vIGZsb2F0OiB0eXBlZCBhcnJheVxyXG4gICAgaWYgKHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgdmFyIGYzMiA9IG5ldyBGbG9hdDMyQXJyYXkoWyAtMCBdKSxcclxuICAgICAgICAgICAgZjhiID0gbmV3IFVpbnQ4QXJyYXkoZjMyLmJ1ZmZlciksXHJcbiAgICAgICAgICAgIGxlICA9IGY4YlszXSA9PT0gMTI4O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0X2YzMl9jcHkodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmMzJbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4YlswXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4YlszXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXRfZjMyX3Jldih2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGYzMlswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzNdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRMRSA9IGxlID8gd3JpdGVGbG9hdF9mMzJfY3B5IDogd3JpdGVGbG9hdF9mMzJfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0QkUgPSBsZSA/IHdyaXRlRmxvYXRfZjMyX3JldiA6IHdyaXRlRmxvYXRfZjMyX2NweTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0X2YzMl9jcHkoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICByZXR1cm4gZjMyWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0X2YzMl9yZXYoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICByZXR1cm4gZjMyWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdExFID0gbGUgPyByZWFkRmxvYXRfZjMyX2NweSA6IHJlYWRGbG9hdF9mMzJfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRCRSA9IGxlID8gcmVhZEZsb2F0X2YzMl9yZXYgOiByZWFkRmxvYXRfZjMyX2NweTtcclxuXHJcbiAgICAvLyBmbG9hdDogaWVlZTc1NFxyXG4gICAgfSkoKTsgZWxzZSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXRfaWVlZTc1NCh3cml0ZVVpbnQsIHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSB2YWwgPCAwID8gMSA6IDA7XHJcbiAgICAgICAgICAgIGlmIChzaWduKVxyXG4gICAgICAgICAgICAgICAgdmFsID0gLXZhbDtcclxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gMClcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgxIC8gdmFsID4gMCA/IC8qIHBvc2l0aXZlICovIDAgOiAvKiBuZWdhdGl2ZSAwICovIDIxNDc0ODM2NDgsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNOYU4odmFsKSlcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgyMTQzMjg5MzQ0LCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA+IDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpIC8vICstSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IDIxMzkwOTUwNDApID4+PiAwLCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA8IDEuMTc1NDk0MzUwODIyMjg3NWUtMzgpIC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBNYXRoLnJvdW5kKHZhbCAvIDEuNDAxMjk4NDY0MzI0ODE3ZS00NSkpID4+PiAwLCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4cG9uZW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWwpIC8gTWF0aC5MTjIpLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gTWF0aC5yb3VuZCh2YWwgKiBNYXRoLnBvdygyLCAtZXhwb25lbnQpICogODM4ODYwOCkgJiA4Mzg4NjA3O1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgZXhwb25lbnQgKyAxMjcgPDwgMjMgfCBtYW50aXNzYSkgPj4+IDAsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0TEUgPSB3cml0ZUZsb2F0X2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRMRSk7XHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0QkUgPSB3cml0ZUZsb2F0X2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRCRSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRGbG9hdF9pZWVlNzU0KHJlYWRVaW50LCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgdWludCA9IHJlYWRVaW50KGJ1ZiwgcG9zKSxcclxuICAgICAgICAgICAgICAgIHNpZ24gPSAodWludCA+PiAzMSkgKiAyICsgMSxcclxuICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gdWludCA+Pj4gMjMgJiAyNTUsXHJcbiAgICAgICAgICAgICAgICBtYW50aXNzYSA9IHVpbnQgJiA4Mzg4NjA3O1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwb25lbnQgPT09IDI1NVxyXG4gICAgICAgICAgICAgICAgPyBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgPyBOYU5cclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIEluZmluaXR5XHJcbiAgICAgICAgICAgICAgICA6IGV4cG9uZW50ID09PSAwIC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICA/IHNpZ24gKiAxLjQwMTI5ODQ2NDMyNDgxN2UtNDUgKiBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogTWF0aC5wb3coMiwgZXhwb25lbnQgLSAxNTApICogKG1hbnRpc3NhICsgODM4ODYwOCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdExFID0gcmVhZEZsb2F0X2llZWU3NTQuYmluZChudWxsLCByZWFkVWludExFKTtcclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdEJFID0gcmVhZEZsb2F0X2llZWU3NTQuYmluZChudWxsLCByZWFkVWludEJFKTtcclxuXHJcbiAgICB9KSgpO1xyXG5cclxuICAgIC8vIGRvdWJsZTogdHlwZWQgYXJyYXlcclxuICAgIGlmICh0eXBlb2YgRmxvYXQ2NEFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHZhciBmNjQgPSBuZXcgRmxvYXQ2NEFycmF5KFstMF0pLFxyXG4gICAgICAgICAgICBmOGIgPSBuZXcgVWludDhBcnJheShmNjQuYnVmZmVyKSxcclxuICAgICAgICAgICAgbGUgID0gZjhiWzddID09PSAxMjg7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlX2Y2NF9jcHkodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmNjRbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4YlswXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4YlszXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDRdID0gZjhiWzRdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNV0gPSBmOGJbNV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA2XSA9IGY4Yls2XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDddID0gZjhiWzddO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGVfZjY0X3Jldih2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY2NFswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzddO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbNl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4Yls1XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzRdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNF0gPSBmOGJbM107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA1XSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDZdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgN10gPSBmOGJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVMRSA9IGxlID8gd3JpdGVEb3VibGVfZjY0X2NweSA6IHdyaXRlRG91YmxlX2Y2NF9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlQkUgPSBsZSA/IHdyaXRlRG91YmxlX2Y2NF9yZXYgOiB3cml0ZURvdWJsZV9mNjRfY3B5O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRG91YmxlX2Y2NF9jcHkoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICBmOGJbNF0gPSBidWZbcG9zICsgNF07XHJcbiAgICAgICAgICAgIGY4Yls1XSA9IGJ1Zltwb3MgKyA1XTtcclxuICAgICAgICAgICAgZjhiWzZdID0gYnVmW3BvcyArIDZdO1xyXG4gICAgICAgICAgICBmOGJbN10gPSBidWZbcG9zICsgN107XHJcbiAgICAgICAgICAgIHJldHVybiBmNjRbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRG91YmxlX2Y2NF9yZXYoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzddID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbNl0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4Yls1XSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzRdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgNF07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyA1XTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDZdO1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICsgN107XHJcbiAgICAgICAgICAgIHJldHVybiBmNjRbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUxFID0gbGUgPyByZWFkRG91YmxlX2Y2NF9jcHkgOiByZWFkRG91YmxlX2Y2NF9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVCRSA9IGxlID8gcmVhZERvdWJsZV9mNjRfcmV2IDogcmVhZERvdWJsZV9mNjRfY3B5O1xyXG5cclxuICAgIC8vIGRvdWJsZTogaWVlZTc1NFxyXG4gICAgfSkoKTsgZWxzZSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlX2llZWU3NTQod3JpdGVVaW50LCBvZmYwLCBvZmYxLCB2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gdmFsIDwgMCA/IDEgOiAwO1xyXG4gICAgICAgICAgICBpZiAoc2lnbilcclxuICAgICAgICAgICAgICAgIHZhbCA9IC12YWw7XHJcbiAgICAgICAgICAgIGlmICh2YWwgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDEgLyB2YWwgPiAwID8gLyogcG9zaXRpdmUgKi8gMCA6IC8qIG5lZ2F0aXZlIDAgKi8gMjE0NzQ4MzY0OCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgyMTQ2OTU5MzYwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbCA+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KSB7IC8vICstSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgMjE0NjQzNTA3MikgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWFudGlzc2E7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsIDwgMi4yMjUwNzM4NTg1MDcyMDE0ZS0zMDgpIHsgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgICAgICBtYW50aXNzYSA9IHZhbCAvIDVlLTMyNDtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQobWFudGlzc2EgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgbWFudGlzc2EgLyA0Mjk0OTY3Mjk2KSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4cG9uZW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWwpIC8gTWF0aC5MTjIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBvbmVudCA9PT0gMTAyNClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSAxMDIzO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gdmFsICogTWF0aC5wb3coMiwgLWV4cG9uZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQobWFudGlzc2EgKiA0NTAzNTk5NjI3MzcwNDk2ID4+PiAwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IGV4cG9uZW50ICsgMTAyMyA8PCAyMCB8IG1hbnRpc3NhICogMTA0ODU3NiAmIDEwNDg1NzUpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlTEUgPSB3cml0ZURvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50TEUsIDAsIDQpO1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVCRSA9IHdyaXRlRG91YmxlX2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRCRSwgNCwgMCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfaWVlZTc1NChyZWFkVWludCwgb2ZmMCwgb2ZmMSwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIGxvID0gcmVhZFVpbnQoYnVmLCBwb3MgKyBvZmYwKSxcclxuICAgICAgICAgICAgICAgIGhpID0gcmVhZFVpbnQoYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSAoaGkgPj4gMzEpICogMiArIDEsXHJcbiAgICAgICAgICAgICAgICBleHBvbmVudCA9IGhpID4+PiAyMCAmIDIwNDcsXHJcbiAgICAgICAgICAgICAgICBtYW50aXNzYSA9IDQyOTQ5NjcyOTYgKiAoaGkgJiAxMDQ4NTc1KSArIGxvO1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwb25lbnQgPT09IDIwNDdcclxuICAgICAgICAgICAgICAgID8gbWFudGlzc2FcclxuICAgICAgICAgICAgICAgID8gTmFOXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBJbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgOiBleHBvbmVudCA9PT0gMCAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgPyBzaWduICogNWUtMzI0ICogbWFudGlzc2FcclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIE1hdGgucG93KDIsIGV4cG9uZW50IC0gMTA3NSkgKiAobWFudGlzc2EgKyA0NTAzNTk5NjI3MzcwNDk2KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUxFID0gcmVhZERvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRMRSwgMCwgNCk7XHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlQkUgPSByZWFkRG91YmxlX2llZWU3NTQuYmluZChudWxsLCByZWFkVWludEJFLCA0LCAwKTtcclxuXHJcbiAgICB9KSgpO1xyXG5cclxuICAgIHJldHVybiBleHBvcnRzO1xyXG59XHJcblxyXG4vLyB1aW50IGhlbHBlcnNcclxuXHJcbmZ1bmN0aW9uIHdyaXRlVWludExFKHZhbCwgYnVmLCBwb3MpIHtcclxuICAgIGJ1Zltwb3MgICAgXSA9ICB2YWwgICAgICAgICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDFdID0gIHZhbCA+Pj4gOCAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMl0gPSAgdmFsID4+PiAxNiAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAzXSA9ICB2YWwgPj4+IDI0O1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cml0ZVVpbnRCRSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICBidWZbcG9zICAgIF0gPSAgdmFsID4+PiAyNDtcclxuICAgIGJ1Zltwb3MgKyAxXSA9ICB2YWwgPj4+IDE2ICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDJdID0gIHZhbCA+Pj4gOCAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgM10gPSAgdmFsICAgICAgICAmIDI1NTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZFVpbnRMRShidWYsIHBvcykge1xyXG4gICAgcmV0dXJuIChidWZbcG9zICAgIF1cclxuICAgICAgICAgIHwgYnVmW3BvcyArIDFdIDw8IDhcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDJdIDw8IDE2XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAzXSA8PCAyNCkgPj4+IDA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRVaW50QkUoYnVmLCBwb3MpIHtcclxuICAgIHJldHVybiAoYnVmW3BvcyAgICBdIDw8IDI0XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAxXSA8PCAxNlxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMl0gPDwgOFxyXG4gICAgICAgICAgfCBidWZbcG9zICsgM10pID4+PiAwO1xyXG59XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBpbnF1aXJlO1xyXG5cclxuLyoqXHJcbiAqIFJlcXVpcmVzIGEgbW9kdWxlIG9ubHkgaWYgYXZhaWxhYmxlLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlTmFtZSBNb2R1bGUgdG8gcmVxdWlyZVxyXG4gKiBAcmV0dXJucyB7P09iamVjdH0gUmVxdWlyZWQgbW9kdWxlIGlmIGF2YWlsYWJsZSBhbmQgbm90IGVtcHR5LCBvdGhlcndpc2UgYG51bGxgXHJcbiAqL1xyXG5mdW5jdGlvbiBpbnF1aXJlKG1vZHVsZU5hbWUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIG1vZCA9IGV2YWwoXCJxdWlyZVwiLnJlcGxhY2UoL14vLFwicmVcIikpKG1vZHVsZU5hbWUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcclxuICAgICAgICBpZiAobW9kICYmIChtb2QubGVuZ3RoIHx8IE9iamVjdC5rZXlzKG1vZCkubGVuZ3RoKSlcclxuICAgICAgICAgICAgcmV0dXJuIG1vZDtcclxuICAgIH0gY2F0Y2ggKGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBBIG1pbmltYWwgVVRGOCBpbXBsZW1lbnRhdGlvbiBmb3IgbnVtYmVyIGFycmF5cy5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxudmFyIHV0ZjggPSBleHBvcnRzO1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIFVURjggYnl0ZSBsZW5ndGggb2YgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU3RyaW5nXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAqL1xyXG51dGY4Lmxlbmd0aCA9IGZ1bmN0aW9uIHV0ZjhfbGVuZ3RoKHN0cmluZykge1xyXG4gICAgdmFyIGxlbiA9IDAsXHJcbiAgICAgICAgYyA9IDA7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoYyA8IDEyOClcclxuICAgICAgICAgICAgbGVuICs9IDE7XHJcbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpXHJcbiAgICAgICAgICAgIGxlbiArPSAyO1xyXG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhGQzAwKSA9PT0gMHhEODAwICYmIChzdHJpbmcuY2hhckNvZGVBdChpICsgMSkgJiAweEZDMDApID09PSAweERDMDApIHtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICBsZW4gKz0gNDtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgbGVuICs9IDM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVuO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIFVURjggYnl0ZXMgYXMgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFNvdXJjZSBzdGFydFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIFNvdXJjZSBlbmRcclxuICogQHJldHVybnMge3N0cmluZ30gU3RyaW5nIHJlYWRcclxuICovXHJcbnV0ZjgucmVhZCA9IGZ1bmN0aW9uIHV0ZjhfcmVhZChidWZmZXIsIHN0YXJ0LCBlbmQpIHtcclxuICAgIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcclxuICAgIGlmIChsZW4gPCAxKVxyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgdmFyIHBhcnRzID0gbnVsbCxcclxuICAgICAgICBjaHVuayA9IFtdLFxyXG4gICAgICAgIGkgPSAwLCAvLyBjaGFyIG9mZnNldFxyXG4gICAgICAgIHQ7ICAgICAvLyB0ZW1wb3JhcnlcclxuICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xyXG4gICAgICAgIHQgPSBidWZmZXJbc3RhcnQrK107XHJcbiAgICAgICAgaWYgKHQgPCAxMjgpXHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSB0O1xyXG4gICAgICAgIGVsc2UgaWYgKHQgPiAxOTEgJiYgdCA8IDIyNClcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9ICh0ICYgMzEpIDw8IDYgfCBidWZmZXJbc3RhcnQrK10gJiA2MztcclxuICAgICAgICBlbHNlIGlmICh0ID4gMjM5ICYmIHQgPCAzNjUpIHtcclxuICAgICAgICAgICAgdCA9ICgodCAmIDcpIDw8IDE4IHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCAxMiB8IChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgNiB8IGJ1ZmZlcltzdGFydCsrXSAmIDYzKSAtIDB4MTAwMDA7XHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAweEQ4MDAgKyAodCA+PiAxMCk7XHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAweERDMDAgKyAodCAmIDEwMjMpO1xyXG4gICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gKHQgJiAxNSkgPDwgMTIgfCAoYnVmZmVyW3N0YXJ0KytdICYgNjMpIDw8IDYgfCBidWZmZXJbc3RhcnQrK10gJiA2MztcclxuICAgICAgICBpZiAoaSA+IDgxOTEpIHtcclxuICAgICAgICAgICAgKHBhcnRzIHx8IChwYXJ0cyA9IFtdKSkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmspKTtcclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHBhcnRzKSB7XHJcbiAgICAgICAgaWYgKGkpXHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKSk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSBzdHJpbmcgYXMgVVRGOCBieXRlcy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTb3VyY2Ugc3RyaW5nXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIERlc3RpbmF0aW9uIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IERlc3RpbmF0aW9uIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlcyB3cml0dGVuXHJcbiAqL1xyXG51dGY4LndyaXRlID0gZnVuY3Rpb24gdXRmOF93cml0ZShzdHJpbmcsIGJ1ZmZlciwgb2Zmc2V0KSB7XHJcbiAgICB2YXIgc3RhcnQgPSBvZmZzZXQsXHJcbiAgICAgICAgYzEsIC8vIGNoYXJhY3RlciAxXHJcbiAgICAgICAgYzI7IC8vIGNoYXJhY3RlciAyXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGMxID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMxIDwgMTI4KSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMTtcclxuICAgICAgICB9IGVsc2UgaWYgKGMxIDwgMjA0OCkge1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gNiAgICAgICB8IDE5MjtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICAgICAgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgfSBlbHNlIGlmICgoYzEgJiAweEZDMDApID09PSAweEQ4MDAgJiYgKChjMiA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKSkgJiAweEZDMDApID09PSAweERDMDApIHtcclxuICAgICAgICAgICAgYzEgPSAweDEwMDAwICsgKChjMSAmIDB4MDNGRikgPDwgMTApICsgKGMyICYgMHgwM0ZGKTtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gMTggICAgICB8IDI0MDtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDEyICYgNjMgfCAxMjg7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2ICAmIDYzIHwgMTI4O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgICAgICAgJiA2MyB8IDEyODtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gMTIgICAgICB8IDIyNDtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDYgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSAgICAgICAmIDYzIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcclxufTtcclxuIiwgIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IHBvb2w7XHJcblxyXG4vKipcclxuICogQW4gYWxsb2NhdG9yIGFzIHVzZWQgYnkge0BsaW5rIHV0aWwucG9vbH0uXHJcbiAqIEB0eXBlZGVmIFBvb2xBbGxvY2F0b3JcclxuICogQHR5cGUge2Z1bmN0aW9ufVxyXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBCdWZmZXIgc2l6ZVxyXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gQnVmZmVyXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEEgc2xpY2VyIGFzIHVzZWQgYnkge0BsaW5rIHV0aWwucG9vbH0uXHJcbiAqIEB0eXBlZGVmIFBvb2xTbGljZXJcclxuICogQHR5cGUge2Z1bmN0aW9ufVxyXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgU3RhcnQgb2Zmc2V0XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gQnVmZmVyIHNsaWNlXHJcbiAqIEB0aGlzIHtVaW50OEFycmF5fVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIGdlbmVyYWwgcHVycG9zZSBidWZmZXIgcG9vbC5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7UG9vbEFsbG9jYXRvcn0gYWxsb2MgQWxsb2NhdG9yXHJcbiAqIEBwYXJhbSB7UG9vbFNsaWNlcn0gc2xpY2UgU2xpY2VyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT04MTkyXSBTbGFiIHNpemVcclxuICogQHJldHVybnMge1Bvb2xBbGxvY2F0b3J9IFBvb2xlZCBhbGxvY2F0b3JcclxuICovXHJcbmZ1bmN0aW9uIHBvb2woYWxsb2MsIHNsaWNlLCBzaXplKSB7XHJcbiAgICB2YXIgU0laRSAgID0gc2l6ZSB8fCA4MTkyO1xyXG4gICAgdmFyIE1BWCAgICA9IFNJWkUgPj4+IDE7XHJcbiAgICB2YXIgc2xhYiAgID0gbnVsbDtcclxuICAgIHZhciBvZmZzZXQgPSBTSVpFO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBvb2xfYWxsb2Moc2l6ZSkge1xyXG4gICAgICAgIGlmIChzaXplIDwgMSB8fCBzaXplID4gTUFYKVxyXG4gICAgICAgICAgICByZXR1cm4gYWxsb2Moc2l6ZSk7XHJcbiAgICAgICAgaWYgKG9mZnNldCArIHNpemUgPiBTSVpFKSB7XHJcbiAgICAgICAgICAgIHNsYWIgPSBhbGxvYyhTSVpFKTtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJ1ZiA9IHNsaWNlLmNhbGwoc2xhYiwgb2Zmc2V0LCBvZmZzZXQgKz0gc2l6ZSk7XHJcbiAgICAgICAgaWYgKG9mZnNldCAmIDcpIC8vIGFsaWduIHRvIDMyIGJpdFxyXG4gICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0IHwgNykgKyAxO1xyXG4gICAgICAgIHJldHVybiBidWY7XHJcbiAgICB9O1xyXG59XHJcbiIsICJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gTG9uZ0JpdHM7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbWluaW1hbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMuXG4gKiBAY2xhc3NkZXNjIEhlbHBlciBjbGFzcyBmb3Igd29ya2luZyB3aXRoIHRoZSBsb3cgYW5kIGhpZ2ggYml0cyBvZiBhIDY0IGJpdCB2YWx1ZS5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBsbyBMb3cgMzIgYml0cywgdW5zaWduZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaSBIaWdoIDMyIGJpdHMsIHVuc2lnbmVkXG4gKi9cbmZ1bmN0aW9uIExvbmdCaXRzKGxvLCBoaSkge1xuXG4gICAgLy8gbm90ZSB0aGF0IHRoZSBjYXN0cyBiZWxvdyBhcmUgdGhlb3JldGljYWxseSB1bm5lY2Vzc2FyeSBhcyBvZiB0b2RheSwgYnV0IG9sZGVyIHN0YXRpY2FsbHlcbiAgICAvLyBnZW5lcmF0ZWQgY29udmVydGVyIGNvZGUgbWlnaHQgc3RpbGwgY2FsbCB0aGUgY3RvciB3aXRoIHNpZ25lZCAzMmJpdHMuIGtlcHQgZm9yIGNvbXBhdC5cblxuICAgIC8qKlxuICAgICAqIExvdyBiaXRzLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sbyA9IGxvID4+PiAwO1xuXG4gICAgLyoqXG4gICAgICogSGlnaCBiaXRzLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5oaSA9IGhpID4+PiAwO1xufVxuXG4vKipcbiAqIFplcm8gYml0cy5cbiAqIEBtZW1iZXJvZiB1dGlsLkxvbmdCaXRzXG4gKiBAdHlwZSB7dXRpbC5Mb25nQml0c31cbiAqL1xudmFyIHplcm8gPSBMb25nQml0cy56ZXJvID0gbmV3IExvbmdCaXRzKDAsIDApO1xuXG56ZXJvLnRvTnVtYmVyID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuemVyby56ekVuY29kZSA9IHplcm8uenpEZWNvZGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH07XG56ZXJvLmxlbmd0aCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMTsgfTtcblxuLyoqXG4gKiBaZXJvIGhhc2guXG4gKiBAbWVtYmVyb2YgdXRpbC5Mb25nQml0c1xuICogQHR5cGUge3N0cmluZ31cbiAqL1xudmFyIHplcm9IYXNoID0gTG9uZ0JpdHMuemVyb0hhc2ggPSBcIlxcMFxcMFxcMFxcMFxcMFxcMFxcMFxcMFwiO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gSW5zdGFuY2VcbiAqL1xuTG9uZ0JpdHMuZnJvbU51bWJlciA9IGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IDApXG4gICAgICAgIHJldHVybiB6ZXJvO1xuICAgIHZhciBzaWduID0gdmFsdWUgPCAwO1xuICAgIGlmIChzaWduKVxuICAgICAgICB2YWx1ZSA9IC12YWx1ZTtcbiAgICB2YXIgbG8gPSB2YWx1ZSA+Pj4gMCxcbiAgICAgICAgaGkgPSAodmFsdWUgLSBsbykgLyA0Mjk0OTY3Mjk2ID4+PiAwO1xuICAgIGlmIChzaWduKSB7XG4gICAgICAgIGhpID0gfmhpID4+PiAwO1xuICAgICAgICBsbyA9IH5sbyA+Pj4gMDtcbiAgICAgICAgaWYgKCsrbG8gPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICBsbyA9IDA7XG4gICAgICAgICAgICBpZiAoKytoaSA+IDQyOTQ5NjcyOTUpXG4gICAgICAgICAgICAgICAgaGkgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMobG8sIGhpKTtcbn07XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gYSBudW1iZXIsIGxvbmcgb3Igc3RyaW5nLlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gSW5zdGFuY2VcbiAqL1xuTG9uZ0JpdHMuZnJvbSA9IGZ1bmN0aW9uIGZyb20odmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4gTG9uZ0JpdHMuZnJvbU51bWJlcih2YWx1ZSk7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmICh1dGlsLkxvbmcpXG4gICAgICAgICAgICB2YWx1ZSA9IHV0aWwuTG9uZy5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIExvbmdCaXRzLmZyb21OdW1iZXIocGFyc2VJbnQodmFsdWUsIDEwKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5sb3cgfHwgdmFsdWUuaGlnaCA/IG5ldyBMb25nQml0cyh2YWx1ZS5sb3cgPj4+IDAsIHZhbHVlLmhpZ2ggPj4+IDApIDogemVybztcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBsb25nIGJpdHMgdG8gYSBwb3NzaWJseSB1bnNhZmUgSmF2YVNjcmlwdCBudW1iZXIuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1bnNpZ25lZD1mYWxzZV0gV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFBvc3NpYmx5IHVuc2FmZSBudW1iZXJcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIodW5zaWduZWQpIHtcbiAgICBpZiAoIXVuc2lnbmVkICYmIHRoaXMuaGkgPj4+IDMxKSB7XG4gICAgICAgIHZhciBsbyA9IH50aGlzLmxvICsgMSA+Pj4gMCxcbiAgICAgICAgICAgIGhpID0gfnRoaXMuaGkgICAgID4+PiAwO1xuICAgICAgICBpZiAoIWxvKVxuICAgICAgICAgICAgaGkgPSBoaSArIDEgPj4+IDA7XG4gICAgICAgIHJldHVybiAtKGxvICsgaGkgKiA0Mjk0OTY3Mjk2KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubG8gKyB0aGlzLmhpICogNDI5NDk2NzI5Njtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBsb25nIGJpdHMgdG8gYSBsb25nLlxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKiBAcmV0dXJucyB7TG9uZ30gTG9uZ1xuICovXG5Mb25nQml0cy5wcm90b3R5cGUudG9Mb25nID0gZnVuY3Rpb24gdG9Mb25nKHVuc2lnbmVkKSB7XG4gICAgcmV0dXJuIHV0aWwuTG9uZ1xuICAgICAgICA/IG5ldyB1dGlsLkxvbmcodGhpcy5sbyB8IDAsIHRoaXMuaGkgfCAwLCBCb29sZWFuKHVuc2lnbmVkKSlcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiB7IGxvdzogdGhpcy5sbyB8IDAsIGhpZ2g6IHRoaXMuaGkgfCAwLCB1bnNpZ25lZDogQm9vbGVhbih1bnNpZ25lZCkgfTtcbn07XG5cbnZhciBjaGFyQ29kZUF0ID0gU3RyaW5nLnByb3RvdHlwZS5jaGFyQ29kZUF0O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIHRoZSBzcGVjaWZpZWQgOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIEhhc2hcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBCaXRzXG4gKi9cbkxvbmdCaXRzLmZyb21IYXNoID0gZnVuY3Rpb24gZnJvbUhhc2goaGFzaCkge1xuICAgIGlmIChoYXNoID09PSB6ZXJvSGFzaClcbiAgICAgICAgcmV0dXJuIHplcm87XG4gICAgcmV0dXJuIG5ldyBMb25nQml0cyhcbiAgICAgICAgKCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMClcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMSkgPDwgOFxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAyKSA8PCAxNlxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAzKSA8PCAyNCkgPj4+IDBcbiAgICAsXG4gICAgICAgICggY2hhckNvZGVBdC5jYWxsKGhhc2gsIDQpXG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDUpIDw8IDhcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNikgPDwgMTZcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNykgPDwgMjQpID4+PiAwXG4gICAgKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBsb25nIGJpdHMgdG8gYSA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoLlxuICogQHJldHVybnMge3N0cmluZ30gSGFzaFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUudG9IYXNoID0gZnVuY3Rpb24gdG9IYXNoKCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICB0aGlzLmxvICAgICAgICAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gOCAgJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDE2ICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiAyNCAgICAgICxcbiAgICAgICAgdGhpcy5oaSAgICAgICAgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDggICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiAxNiAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gMjRcbiAgICApO1xufTtcblxuLyoqXG4gKiBaaWctemFnIGVuY29kZXMgdGhpcyBsb25nIGJpdHMuXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gYHRoaXNgXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS56ekVuY29kZSA9IGZ1bmN0aW9uIHp6RW5jb2RlKCkge1xuICAgIHZhciBtYXNrID0gICB0aGlzLmhpID4+IDMxO1xuICAgIHRoaXMuaGkgID0gKCh0aGlzLmhpIDw8IDEgfCB0aGlzLmxvID4+PiAzMSkgXiBtYXNrKSA+Pj4gMDtcbiAgICB0aGlzLmxvICA9ICggdGhpcy5sbyA8PCAxICAgICAgICAgICAgICAgICAgIF4gbWFzaykgPj4+IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFppZy16YWcgZGVjb2RlcyB0aGlzIGxvbmcgYml0cy5cbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBgdGhpc2BcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnp6RGVjb2RlID0gZnVuY3Rpb24genpEZWNvZGUoKSB7XG4gICAgdmFyIG1hc2sgPSAtKHRoaXMubG8gJiAxKTtcbiAgICB0aGlzLmxvICA9ICgodGhpcy5sbyA+Pj4gMSB8IHRoaXMuaGkgPDwgMzEpIF4gbWFzaykgPj4+IDA7XG4gICAgdGhpcy5oaSAgPSAoIHRoaXMuaGkgPj4+IDEgICAgICAgICAgICAgICAgICBeIG1hc2spID4+PiAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgdGhpcyBsb25nYml0cyB3aGVuIGVuY29kZWQgYXMgYSB2YXJpbnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBMZW5ndGhcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICB2YXIgcGFydDAgPSAgdGhpcy5sbyxcbiAgICAgICAgcGFydDEgPSAodGhpcy5sbyA+Pj4gMjggfCB0aGlzLmhpIDw8IDQpID4+PiAwLFxuICAgICAgICBwYXJ0MiA9ICB0aGlzLmhpID4+PiAyNDtcbiAgICByZXR1cm4gcGFydDIgPT09IDBcbiAgICAgICAgID8gcGFydDEgPT09IDBcbiAgICAgICAgICAgPyBwYXJ0MCA8IDE2Mzg0XG4gICAgICAgICAgICAgPyBwYXJ0MCA8IDEyOCA/IDEgOiAyXG4gICAgICAgICAgICAgOiBwYXJ0MCA8IDIwOTcxNTIgPyAzIDogNFxuICAgICAgICAgICA6IHBhcnQxIDwgMTYzODRcbiAgICAgICAgICAgICA/IHBhcnQxIDwgMTI4ID8gNSA6IDZcbiAgICAgICAgICAgICA6IHBhcnQxIDwgMjA5NzE1MiA/IDcgOiA4XG4gICAgICAgICA6IHBhcnQyIDwgMTI4ID8gOSA6IDEwO1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbnZhciB1dGlsID0gZXhwb3J0cztcblxuLy8gdXNlZCB0byByZXR1cm4gYSBQcm9taXNlIHdoZXJlIGNhbGxiYWNrIGlzIG9taXR0ZWRcbnV0aWwuYXNQcm9taXNlID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2FzcHJvbWlzZVwiKTtcblxuLy8gY29udmVydHMgdG8gLyBmcm9tIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbnV0aWwuYmFzZTY0ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2Jhc2U2NFwiKTtcblxuLy8gYmFzZSBjbGFzcyBvZiBycGMuU2VydmljZVxudXRpbC5FdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvZXZlbnRlbWl0dGVyXCIpO1xuXG4vLyBmbG9hdCBoYW5kbGluZyBhY2Nyb3NzIGJyb3dzZXJzXG51dGlsLmZsb2F0ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2Zsb2F0XCIpO1xuXG4vLyByZXF1aXJlcyBtb2R1bGVzIG9wdGlvbmFsbHkgYW5kIGhpZGVzIHRoZSBjYWxsIGZyb20gYnVuZGxlcnNcbnV0aWwuaW5xdWlyZSA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9pbnF1aXJlXCIpO1xuXG4vLyBjb252ZXJ0cyB0byAvIGZyb20gdXRmOCBlbmNvZGVkIHN0cmluZ3NcbnV0aWwudXRmOCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy91dGY4XCIpO1xuXG4vLyBwcm92aWRlcyBhIG5vZGUtbGlrZSBidWZmZXIgcG9vbCBpbiB0aGUgYnJvd3NlclxudXRpbC5wb29sID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL3Bvb2xcIik7XG5cbi8vIHV0aWxpdHkgdG8gd29yayB3aXRoIHRoZSBsb3cgYW5kIGhpZ2ggYml0cyBvZiBhIDY0IGJpdCB2YWx1ZVxudXRpbC5Mb25nQml0cyA9IHJlcXVpcmUoXCIuL2xvbmdiaXRzXCIpO1xuXG4vKipcbiAqIFdoZXRoZXIgcnVubmluZyB3aXRoaW4gbm9kZSBvciBub3QuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbnV0aWwuaXNOb2RlID0gQm9vbGVhbih0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsLnByb2Nlc3NcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWwucHJvY2Vzcy52ZXJzaW9uc1xuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbC5wcm9jZXNzLnZlcnNpb25zLm5vZGUpO1xuXG4vKipcbiAqIEdsb2JhbCBvYmplY3QgcmVmZXJlbmNlLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnV0aWwuZ2xvYmFsID0gdXRpbC5pc05vZGUgJiYgZ2xvYmFsXG4gICAgICAgICAgIHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93XG4gICAgICAgICAgIHx8IHR5cGVvZiBzZWxmICAgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZlxuICAgICAgICAgICB8fCB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWludmFsaWQtdGhpc1xuXG4vKipcbiAqIEFuIGltbXVhYmxlIGVtcHR5IGFycmF5LlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEB0eXBlIHtBcnJheS48Kj59XG4gKiBAY29uc3RcbiAqL1xudXRpbC5lbXB0eUFycmF5ID0gT2JqZWN0LmZyZWV6ZSA/IE9iamVjdC5mcmVlemUoW10pIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gW107IC8vIHVzZWQgb24gcHJvdG90eXBlc1xuXG4vKipcbiAqIEFuIGltbXV0YWJsZSBlbXB0eSBvYmplY3QuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGNvbnN0XG4gKi9cbnV0aWwuZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplID8gT2JqZWN0LmZyZWV6ZSh7fSkgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB7fTsgLy8gdXNlZCBvbiBwcm90b3R5cGVzXG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhbiBpbnRlZ2VyLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGFuIGludGVnZXJcbiAqL1xudXRpbC5pc0ludGVnZXIgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUodmFsdWUpICYmIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmdcbiAqL1xudXRpbC5pc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIG5vbi1udWxsIG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBub24tbnVsbCBvYmplY3RcbiAqL1xudXRpbC5pc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgcHJvcGVydHkgb24gYSBtZXNzYWdlIGlzIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudC5cbiAqIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIHV0aWwuaXNTZXR9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFBsYWluIG9iamVjdCBvciBtZXNzYWdlIGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xudXRpbC5pc3NldCA9XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgcHJvcGVydHkgb24gYSBtZXNzYWdlIGlzIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogUGxhaW4gb2JqZWN0IG9yIG1lc3NhZ2UgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG51dGlsLmlzU2V0ID0gZnVuY3Rpb24gaXNTZXQob2JqLCBwcm9wKSB7XG4gICAgdmFyIHZhbHVlID0gb2JqW3Byb3BdO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXEsIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmxlbmd0aCA6IE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGgpID4gMDtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEFueSBjb21wYXRpYmxlIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIFRoaXMgaXMgYSBtaW5pbWFsIHN0YW5kLWFsb25lIGRlZmluaXRpb24gb2YgYSBCdWZmZXIgaW5zdGFuY2UuIFRoZSBhY3R1YWwgdHlwZSBpcyB0aGF0IGV4cG9ydGVkIGJ5IG5vZGUncyB0eXBpbmdzLlxuICogQGludGVyZmFjZSBCdWZmZXJcbiAqIEBleHRlbmRzIFVpbnQ4QXJyYXlcbiAqL1xuXG4vKipcbiAqIE5vZGUncyBCdWZmZXIgY2xhc3MgaWYgYXZhaWxhYmxlLlxuICogQHR5cGUge0NvbnN0cnVjdG9yPEJ1ZmZlcj59XG4gKi9cbnV0aWwuQnVmZmVyID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBCdWZmZXIgPSB1dGlsLmlucXVpcmUoXCJidWZmZXJcIikuQnVmZmVyO1xuICAgICAgICAvLyByZWZ1c2UgdG8gdXNlIG5vbi1ub2RlIGJ1ZmZlcnMgaWYgbm90IGV4cGxpY2l0bHkgYXNzaWduZWQgKHBlcmYgcmVhc29ucyk6XG4gICAgICAgIHJldHVybiBCdWZmZXIucHJvdG90eXBlLnV0ZjhXcml0ZSA/IEJ1ZmZlciA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIG51bGw7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59KSgpO1xuXG4vLyBJbnRlcm5hbCBhbGlhcyBvZiBvciBwb2x5ZnVsbCBmb3IgQnVmZmVyLmZyb20uXG51dGlsLl9CdWZmZXJfZnJvbSA9IG51bGw7XG5cbi8vIEludGVybmFsIGFsaWFzIG9mIG9yIHBvbHlmaWxsIGZvciBCdWZmZXIuYWxsb2NVbnNhZmUuXG51dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBudWxsO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYnVmZmVyIG9mIHdoYXRldmVyIHR5cGUgc3VwcG9ydGVkIGJ5IHRoZSBlbnZpcm9ubWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBbc2l6ZU9yQXJyYXk9MF0gQnVmZmVyIHNpemUgb3IgbnVtYmVyIGFycmF5XG4gKiBAcmV0dXJucyB7VWludDhBcnJheXxCdWZmZXJ9IEJ1ZmZlclxuICovXG51dGlsLm5ld0J1ZmZlciA9IGZ1bmN0aW9uIG5ld0J1ZmZlcihzaXplT3JBcnJheSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHR5cGVvZiBzaXplT3JBcnJheSA9PT0gXCJudW1iZXJcIlxuICAgICAgICA/IHV0aWwuQnVmZmVyXG4gICAgICAgICAgICA/IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZShzaXplT3JBcnJheSlcbiAgICAgICAgICAgIDogbmV3IHV0aWwuQXJyYXkoc2l6ZU9yQXJyYXkpXG4gICAgICAgIDogdXRpbC5CdWZmZXJcbiAgICAgICAgICAgID8gdXRpbC5fQnVmZmVyX2Zyb20oc2l6ZU9yQXJyYXkpXG4gICAgICAgICAgICA6IHR5cGVvZiBVaW50OEFycmF5ID09PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgPyBzaXplT3JBcnJheVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoc2l6ZU9yQXJyYXkpO1xufTtcblxuLyoqXG4gKiBBcnJheSBpbXBsZW1lbnRhdGlvbiB1c2VkIGluIHRoZSBicm93c2VyLiBgVWludDhBcnJheWAgaWYgc3VwcG9ydGVkLCBvdGhlcndpc2UgYEFycmF5YC5cbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxVaW50OEFycmF5Pn1cbiAqL1xudXRpbC5BcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiID8gVWludDhBcnJheSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyA6IEFycmF5O1xuXG4vKipcbiAqIEFueSBjb21wYXRpYmxlIExvbmcgaW5zdGFuY2UuXG4gKiBUaGlzIGlzIGEgbWluaW1hbCBzdGFuZC1hbG9uZSBkZWZpbml0aW9uIG9mIGEgTG9uZyBpbnN0YW5jZS4gVGhlIGFjdHVhbCB0eXBlIGlzIHRoYXQgZXhwb3J0ZWQgYnkgbG9uZy5qcy5cbiAqIEBpbnRlcmZhY2UgTG9uZ1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGxvdyBMb3cgYml0c1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGhpZ2ggSGlnaCBiaXRzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKi9cblxuLyoqXG4gKiBMb25nLmpzJ3MgTG9uZyBjbGFzcyBpZiBhdmFpbGFibGUuXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8TG9uZz59XG4gKi9cbnV0aWwuTG9uZyA9IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLmRjb2RlSU8gJiYgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuZGNvZGVJTy5Mb25nXG4gICAgICAgICB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5Mb25nXG4gICAgICAgICB8fCB1dGlsLmlucXVpcmUoXCJsb25nXCIpO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSAyIGJpdCAoYGJvb2xgKSBtYXAga2V5cy5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5rZXkyUmUgPSAvXnRydWV8ZmFsc2V8MHwxJC87XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDMyIGJpdCAoYGludDMyYCBldGMuKSBtYXAga2V5cy5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5rZXkzMlJlID0gL14tPyg/OjB8WzEtOV1bMC05XSopJC87XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDY0IGJpdCAoYGludDY0YCBldGMuKSBtYXAga2V5cy5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5rZXk2NFJlID0gL14oPzpbXFxcXHgwMC1cXFxceGZmXXs4fXwtPyg/OjB8WzEtOV1bMC05XSopKSQvO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgbnVtYmVyIG9yIGxvbmcgdG8gYW4gOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaCBzdHJpbmcuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBIYXNoXG4gKi9cbnV0aWwubG9uZ1RvSGFzaCA9IGZ1bmN0aW9uIGxvbmdUb0hhc2godmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgPyB1dGlsLkxvbmdCaXRzLmZyb20odmFsdWUpLnRvSGFzaCgpXG4gICAgICAgIDogdXRpbC5Mb25nQml0cy56ZXJvSGFzaDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaCBzdHJpbmcgdG8gYSBsb25nIG9yIG51bWJlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIEhhc2hcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge0xvbmd8bnVtYmVyfSBPcmlnaW5hbCB2YWx1ZVxuICovXG51dGlsLmxvbmdGcm9tSGFzaCA9IGZ1bmN0aW9uIGxvbmdGcm9tSGFzaChoYXNoLCB1bnNpZ25lZCkge1xuICAgIHZhciBiaXRzID0gdXRpbC5Mb25nQml0cy5mcm9tSGFzaChoYXNoKTtcbiAgICBpZiAodXRpbC5Mb25nKVxuICAgICAgICByZXR1cm4gdXRpbC5Mb25nLmZyb21CaXRzKGJpdHMubG8sIGJpdHMuaGksIHVuc2lnbmVkKTtcbiAgICByZXR1cm4gYml0cy50b051bWJlcihCb29sZWFuKHVuc2lnbmVkKSk7XG59O1xuXG4vKipcbiAqIE1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgc291cmNlIG9iamVjdCBpbnRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gZHN0IERlc3RpbmF0aW9uIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gc3JjIFNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lmTm90U2V0PWZhbHNlXSBNZXJnZXMgb25seSBpZiB0aGUga2V5IGlzIG5vdCBhbHJlYWR5IHNldFxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBEZXN0aW5hdGlvbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoZHN0LCBzcmMsIGlmTm90U2V0KSB7IC8vIHVzZWQgYnkgY29udmVydGVyc1xuICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhzcmMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgIGlmIChkc3Rba2V5c1tpXV0gPT09IHVuZGVmaW5lZCB8fCAhaWZOb3RTZXQpXG4gICAgICAgICAgICBkc3Rba2V5c1tpXV0gPSBzcmNba2V5c1tpXV07XG4gICAgcmV0dXJuIGRzdDtcbn1cblxudXRpbC5tZXJnZSA9IG1lcmdlO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzdHJpbmcgdG8gbG93ZXIgY2FzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IENvbnZlcnRlZCBzdHJpbmdcbiAqL1xudXRpbC5sY0ZpcnN0ID0gZnVuY3Rpb24gbGNGaXJzdChzdHIpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGN1c3RvbSBlcnJvciBjb25zdHJ1Y3Rvci5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBFcnJvciBuYW1lXG4gKiBAcmV0dXJucyB7Q29uc3RydWN0b3I8RXJyb3I+fSBDdXN0b20gZXJyb3IgY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gbmV3RXJyb3IobmFtZSkge1xuXG4gICAgZnVuY3Rpb24gQ3VzdG9tRXJyb3IobWVzc2FnZSwgcHJvcGVydGllcykge1xuXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDdXN0b21FcnJvcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUVycm9yKG1lc3NhZ2UsIHByb3BlcnRpZXMpO1xuXG4gICAgICAgIC8vIEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgICAgIC8vIF4ganVzdCByZXR1cm5zIGEgbmV3IGVycm9yIGluc3RhbmNlIGJlY2F1c2UgdGhlIGN0b3IgY2FuIGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uXG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWVzc2FnZVwiLCB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtZXNzYWdlOyB9IH0pO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkgLy8gbm9kZVxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ3VzdG9tRXJyb3IpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGFja1wiLCB7IHZhbHVlOiBuZXcgRXJyb3IoKS5zdGFjayB8fCBcIlwiIH0pO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgbWVyZ2UodGhpcywgcHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgQ3VzdG9tRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgIHZhbHVlOiBDdXN0b21FcnJvcixcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkgeyByZXR1cm4gbmFtZTsgfSxcbiAgICAgICAgICAgIHNldDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAvLyBjb25maWd1cmFibGU6IGZhbHNlIHdvdWxkIGFjY3VyYXRlbHkgcHJlc2VydmUgdGhlIGJlaGF2aW9yIG9mXG4gICAgICAgICAgICAvLyB0aGUgb3JpZ2luYWwsIGJ1dCBJJ20gZ3Vlc3NpbmcgdGhhdCB3YXMgbm90IGludGVudGlvbmFsLlxuICAgICAgICAgICAgLy8gRm9yIGFuIGFjdHVhbCBlcnJvciBzdWJjbGFzcywgdGhpcyBwcm9wZXJ0eSB3b3VsZFxuICAgICAgICAgICAgLy8gYmUgY29uZmlndXJhYmxlLlxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICB0b1N0cmluZzoge1xuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkgeyByZXR1cm4gdGhpcy5uYW1lICsgXCI6IFwiICsgdGhpcy5tZXNzYWdlOyB9LFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIHJldHVybiBDdXN0b21FcnJvcjtcbn1cblxudXRpbC5uZXdFcnJvciA9IG5ld0Vycm9yO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgcHJvdG9jb2wgZXJyb3IuXG4gKiBAY2xhc3NkZXNjIEVycm9yIHN1YmNsYXNzIGluZGljYXRpbmcgYSBwcm90b2NvbCBzcGVjaWZjIGVycm9yLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBleHRlbmRzIEVycm9yXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgRXJyb3IgbWVzc2FnZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW3Byb3BlcnRpZXNdIEFkZGl0aW9uYWwgcHJvcGVydGllc1xuICogQGV4YW1wbGVcbiAqIHRyeSB7XG4gKiAgICAgTXlNZXNzYWdlLmRlY29kZShzb21lQnVmZmVyKTsgLy8gdGhyb3dzIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICogfSBjYXRjaCAoZSkge1xuICogICAgIGlmIChlIGluc3RhbmNlb2YgUHJvdG9jb2xFcnJvciAmJiBlLmluc3RhbmNlKVxuICogICAgICAgICBjb25zb2xlLmxvZyhcImRlY29kZWQgc28gZmFyOiBcIiArIEpTT04uc3RyaW5naWZ5KGUuaW5zdGFuY2UpKTtcbiAqIH1cbiAqL1xudXRpbC5Qcm90b2NvbEVycm9yID0gbmV3RXJyb3IoXCJQcm90b2NvbEVycm9yXCIpO1xuXG4vKipcbiAqIFNvIGZhciBkZWNvZGVkIG1lc3NhZ2UgaW5zdGFuY2UuXG4gKiBAbmFtZSB1dGlsLlByb3RvY29sRXJyb3IjaW5zdGFuY2VcbiAqIEB0eXBlIHtNZXNzYWdlPFQ+fVxuICovXG5cbi8qKlxuICogQSBPbmVPZiBnZXR0ZXIgYXMgcmV0dXJuZWQgYnkge0BsaW5rIHV0aWwub25lT2ZHZXR0ZXJ9LlxuICogQHR5cGVkZWYgT25lT2ZHZXR0ZXJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBTZXQgZmllbGQgbmFtZSwgaWYgYW55XG4gKi9cblxuLyoqXG4gKiBCdWlsZHMgYSBnZXR0ZXIgZm9yIGEgb25lb2YncyBwcmVzZW50IGZpZWxkIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZE5hbWVzIEZpZWxkIG5hbWVzXG4gKiBAcmV0dXJucyB7T25lT2ZHZXR0ZXJ9IFVuYm91bmQgZ2V0dGVyXG4gKi9cbnV0aWwub25lT2ZHZXR0ZXIgPSBmdW5jdGlvbiBnZXRPbmVPZihmaWVsZE5hbWVzKSB7XG4gICAgdmFyIGZpZWxkTWFwID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZE5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICBmaWVsZE1hcFtmaWVsZE5hbWVzW2ldXSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gU2V0IGZpZWxkIG5hbWUsIGlmIGFueVxuICAgICAqIEB0aGlzIE9iamVjdFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpLCBpID0ga2V5cy5sZW5ndGggLSAxOyBpID4gLTE7IC0taSlcbiAgICAgICAgICAgIGlmIChmaWVsZE1hcFtrZXlzW2ldXSA9PT0gMSAmJiB0aGlzW2tleXNbaV1dICE9PSB1bmRlZmluZWQgJiYgdGhpc1trZXlzW2ldXSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5c1tpXTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBBIE9uZU9mIHNldHRlciBhcyByZXR1cm5lZCBieSB7QGxpbmsgdXRpbC5vbmVPZlNldHRlcn0uXG4gKiBAdHlwZWRlZiBPbmVPZlNldHRlclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSB2YWx1ZSBGaWVsZCBuYW1lXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogQnVpbGRzIGEgc2V0dGVyIGZvciBhIG9uZW9mJ3MgcHJlc2VudCBmaWVsZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGROYW1lcyBGaWVsZCBuYW1lc1xuICogQHJldHVybnMge09uZU9mU2V0dGVyfSBVbmJvdW5kIHNldHRlclxuICovXG51dGlsLm9uZU9mU2V0dGVyID0gZnVuY3Rpb24gc2V0T25lT2YoZmllbGROYW1lcykge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRmllbGQgbmFtZVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICogQHRoaXMgT2JqZWN0XG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGROYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWVzW2ldICE9PSBuYW1lKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzW2ZpZWxkTmFtZXNbaV1dO1xuICAgIH07XG59O1xuXG4vKipcbiAqIERlZmF1bHQgY29udmVyc2lvbiBvcHRpb25zIHVzZWQgZm9yIHtAbGluayBNZXNzYWdlI3RvSlNPTn0gaW1wbGVtZW50YXRpb25zLlxuICpcbiAqIFRoZXNlIG9wdGlvbnMgYXJlIGNsb3NlIHRvIHByb3RvMydzIEpTT04gbWFwcGluZyB3aXRoIHRoZSBleGNlcHRpb24gdGhhdCBpbnRlcm5hbCB0eXBlcyBsaWtlIEFueSBhcmUgaGFuZGxlZCBqdXN0IGxpa2UgbWVzc2FnZXMuIE1vcmUgcHJlY2lzZWx5OlxuICpcbiAqIC0gTG9uZ3MgYmVjb21lIHN0cmluZ3NcbiAqIC0gRW51bXMgYmVjb21lIHN0cmluZyBrZXlzXG4gKiAtIEJ5dGVzIGJlY29tZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG4gKiAtIChTdWItKU1lc3NhZ2VzIGJlY29tZSBwbGFpbiBvYmplY3RzXG4gKiAtIE1hcHMgYmVjb21lIHBsYWluIG9iamVjdHMgd2l0aCBhbGwgc3RyaW5nIGtleXNcbiAqIC0gUmVwZWF0ZWQgZmllbGRzIGJlY29tZSBhcnJheXNcbiAqIC0gTmFOIGFuZCBJbmZpbml0eSBmb3IgZmxvYXQgYW5kIGRvdWJsZSBmaWVsZHMgYmVjb21lIHN0cmluZ3NcbiAqXG4gKiBAdHlwZSB7SUNvbnZlcnNpb25PcHRpb25zfVxuICogQHNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9wcm90b2NvbC1idWZmZXJzL2RvY3MvcHJvdG8zP2hsPWVuI2pzb25cbiAqL1xudXRpbC50b0pTT05PcHRpb25zID0ge1xuICAgIGxvbmdzOiBTdHJpbmcsXG4gICAgZW51bXM6IFN0cmluZyxcbiAgICBieXRlczogU3RyaW5nLFxuICAgIGpzb246IHRydWVcbn07XG5cbi8vIFNldHMgdXAgYnVmZmVyIHV0aWxpdHkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudCAoY2FsbGVkIGluIGluZGV4LW1pbmltYWwpXG51dGlsLl9jb25maWd1cmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgQnVmZmVyID0gdXRpbC5CdWZmZXI7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFCdWZmZXIpIHtcbiAgICAgICAgdXRpbC5fQnVmZmVyX2Zyb20gPSB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGJlY2F1c2Ugbm9kZSA0LnggYnVmZmVycyBhcmUgaW5jb21wYXRpYmxlICYgaW1tdXRhYmxlXG4gICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9wcm90b2J1Zi5qcy9wdWxsLzY2NVxuICAgIHV0aWwuX0J1ZmZlcl9mcm9tID0gQnVmZmVyLmZyb20gIT09IFVpbnQ4QXJyYXkuZnJvbSAmJiBCdWZmZXIuZnJvbSB8fFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBmdW5jdGlvbiBCdWZmZXJfZnJvbSh2YWx1ZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLCBlbmNvZGluZyk7XG4gICAgICAgIH07XG4gICAgdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gQnVmZmVyLmFsbG9jVW5zYWZlIHx8XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlcl9hbGxvY1Vuc2FmZShzaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihzaXplKTtcbiAgICAgICAgfTtcbn07XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRlcjtcblxudmFyIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxudmFyIEJ1ZmZlcldyaXRlcjsgLy8gY3ljbGljXG5cbnZhciBMb25nQml0cyAgPSB1dGlsLkxvbmdCaXRzLFxuICAgIGJhc2U2NCAgICA9IHV0aWwuYmFzZTY0LFxuICAgIHV0ZjggICAgICA9IHV0aWwudXRmODtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBvcGVyYXRpb24gaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFNjaGVkdWxlZCB3cml0ZXIgb3BlcmF0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIFVpbnQ4QXJyYXksIG51bWJlcil9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVmFsdWUgYnl0ZSBsZW5ndGhcbiAqIEBwYXJhbSB7Kn0gdmFsIFZhbHVlIHRvIHdyaXRlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIE9wKGZuLCBsZW4sIHZhbCkge1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gY2FsbC5cbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oVWludDhBcnJheSwgbnVtYmVyLCAqKX1cbiAgICAgKi9cbiAgICB0aGlzLmZuID0gZm47XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSBieXRlIGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gbGVuO1xuXG4gICAgLyoqXG4gICAgICogTmV4dCBvcGVyYXRpb24uXG4gICAgICogQHR5cGUge1dyaXRlci5PcHx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5uZXh0ID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHR5cGUgeyp9XG4gICAgICovXG4gICAgdGhpcy52YWwgPSB2YWw7IC8vIHR5cGUgdmFyaWVzXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBub29wKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eS1mdW5jdGlvblxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIHN0YXRlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBDb3BpZWQgd3JpdGVyIHN0YXRlLlxuICogQG1lbWJlcm9mIFdyaXRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1dyaXRlcn0gd3JpdGVyIFdyaXRlciB0byBjb3B5IHN0YXRlIGZyb21cbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gU3RhdGUod3JpdGVyKSB7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGhlYWQuXG4gICAgICogQHR5cGUge1dyaXRlci5PcH1cbiAgICAgKi9cbiAgICB0aGlzLmhlYWQgPSB3cml0ZXIuaGVhZDtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgdGFpbC5cbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfVxuICAgICAqL1xuICAgIHRoaXMudGFpbCA9IHdyaXRlci50YWlsO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBidWZmZXIgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSB3cml0ZXIubGVuO1xuXG4gICAgLyoqXG4gICAgICogTmV4dCBzdGF0ZS5cbiAgICAgKiBAdHlwZSB7U3RhdGV8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLm5leHQgPSB3cml0ZXIuc3RhdGVzO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCB3cml0ZXIgdXNpbmcgYFVpbnQ4QXJyYXlgIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBBcnJheWAuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gV3JpdGVyKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb25zIGhlYWQuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmhlYWQgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb25zIHRhaWxcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMudGFpbCA9IHRoaXMuaGVhZDtcblxuICAgIC8qKlxuICAgICAqIExpbmtlZCBmb3JrZWQgc3RhdGVzLlxuICAgICAqIEB0eXBlIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXRlcyA9IG51bGw7XG5cbiAgICAvLyBXaGVuIGEgdmFsdWUgaXMgd3JpdHRlbiwgdGhlIHdyaXRlciBjYWxjdWxhdGVzIGl0cyBieXRlIGxlbmd0aCBhbmQgcHV0cyBpdCBpbnRvIGEgbGlua2VkXG4gICAgLy8gbGlzdCBvZiBvcGVyYXRpb25zIHRvIHBlcmZvcm0gd2hlbiBmaW5pc2goKSBpcyBjYWxsZWQuIFRoaXMgYm90aCBhbGxvd3MgdXMgdG8gYWxsb2NhdGVcbiAgICAvLyBidWZmZXJzIG9mIHRoZSBleGFjdCByZXF1aXJlZCBzaXplIGFuZCByZWR1Y2VzIHRoZSBhbW91bnQgb2Ygd29yayB3ZSBoYXZlIHRvIGRvIGNvbXBhcmVkXG4gICAgLy8gdG8gZmlyc3QgY2FsY3VsYXRpbmcgb3ZlciBvYmplY3RzIGFuZCB0aGVuIGVuY29kaW5nIG92ZXIgb2JqZWN0cy4gSW4gb3VyIGNhc2UsIHRoZSBlbmNvZGluZ1xuICAgIC8vIHBhcnQgaXMganVzdCBhIGxpbmtlZCBsaXN0IHdhbGsgY2FsbGluZyBvcGVyYXRpb25zIHdpdGggYWxyZWFkeSBwcmVwYXJlZCB2YWx1ZXMuXG59XG5cbnZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIHV0aWwuQnVmZmVyXG4gICAgICAgID8gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcl9zZXR1cCgpIHtcbiAgICAgICAgICAgIHJldHVybiAoV3JpdGVyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJXcml0ZXIoKTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiBmdW5jdGlvbiBjcmVhdGVfYXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdyaXRlcigpO1xuICAgICAgICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHdyaXRlci5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0J1ZmZlcldyaXRlcnxXcml0ZXJ9IEEge0BsaW5rIEJ1ZmZlcldyaXRlcn0gd2hlbiBCdWZmZXJzIGFyZSBzdXBwb3J0ZWQsIG90aGVyd2lzZSBhIHtAbGluayBXcml0ZXJ9XG4gKi9cbldyaXRlci5jcmVhdGUgPSBjcmVhdGUoKTtcblxuLyoqXG4gKiBBbGxvY2F0ZXMgYSBidWZmZXIgb2YgdGhlIHNwZWNpZmllZCBzaXplLlxuICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXJcbiAqL1xuV3JpdGVyLmFsbG9jID0gZnVuY3Rpb24gYWxsb2Moc2l6ZSkge1xuICAgIHJldHVybiBuZXcgdXRpbC5BcnJheShzaXplKTtcbn07XG5cbi8vIFVzZSBVaW50OEFycmF5IGJ1ZmZlciBwb29sIGluIHRoZSBicm93c2VyLCBqdXN0IGxpa2Ugbm9kZSBkb2VzIHdpdGggYnVmZmVyc1xuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbmlmICh1dGlsLkFycmF5ICE9PSBBcnJheSlcbiAgICBXcml0ZXIuYWxsb2MgPSB1dGlsLnBvb2woV3JpdGVyLmFsbG9jLCB1dGlsLkFycmF5LnByb3RvdHlwZS5zdWJhcnJheSk7XG5cbi8qKlxuICogUHVzaGVzIGEgbmV3IG9wZXJhdGlvbiB0byB0aGUgcXVldWUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFVpbnQ4QXJyYXksIG51bWJlciwgKil9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVmFsdWUgYnl0ZSBsZW5ndGhcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHByaXZhdGVcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5fcHVzaCA9IGZ1bmN0aW9uIHB1c2goZm4sIGxlbiwgdmFsKSB7XG4gICAgdGhpcy50YWlsID0gdGhpcy50YWlsLm5leHQgPSBuZXcgT3AoZm4sIGxlbiwgdmFsKTtcbiAgICB0aGlzLmxlbiArPSBsZW47XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUJ5dGUodmFsLCBidWYsIHBvcykge1xuICAgIGJ1Zltwb3NdID0gdmFsICYgMjU1O1xufVxuXG5mdW5jdGlvbiB3cml0ZVZhcmludDMyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICB3aGlsZSAodmFsID4gMTI3KSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwgJiAxMjcgfCAxMjg7XG4gICAgICAgIHZhbCA+Pj49IDc7XG4gICAgfVxuICAgIGJ1Zltwb3NdID0gdmFsO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgdmFyaW50IHdyaXRlciBvcGVyYXRpb24gaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFNjaGVkdWxlZCB2YXJpbnQgd3JpdGVyIG9wZXJhdGlvbi5cbiAqIEBleHRlbmRzIE9wXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVmFsdWUgYnl0ZSBsZW5ndGhcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gVmFyaW50T3AobGVuLCB2YWwpIHtcbiAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICB0aGlzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy52YWwgPSB2YWw7XG59XG5cblZhcmludE9wLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoT3AucHJvdG90eXBlKTtcblZhcmludE9wLnByb3RvdHlwZS5mbiA9IHdyaXRlVmFyaW50MzI7XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUudWludDMyID0gZnVuY3Rpb24gd3JpdGVfdWludDMyKHZhbHVlKSB7XG4gICAgLy8gaGVyZSwgdGhlIGNhbGwgdG8gdGhpcy5wdXNoIGhhcyBiZWVuIGlubGluZWQgYW5kIGEgdmFyaW50IHNwZWNpZmljIE9wIHN1YmNsYXNzIGlzIHVzZWQuXG4gICAgLy8gdWludDMyIGlzIGJ5IGZhciB0aGUgbW9zdCBmcmVxdWVudGx5IHVzZWQgb3BlcmF0aW9uIGFuZCBiZW5lZml0cyBzaWduaWZpY2FudGx5IGZyb20gdGhpcy5cbiAgICB0aGlzLmxlbiArPSAodGhpcy50YWlsID0gdGhpcy50YWlsLm5leHQgPSBuZXcgVmFyaW50T3AoXG4gICAgICAgICh2YWx1ZSA9IHZhbHVlID4+PiAwKVxuICAgICAgICAgICAgICAgIDwgMTI4ICAgICAgID8gMVxuICAgICAgICA6IHZhbHVlIDwgMTYzODQgICAgID8gMlxuICAgICAgICA6IHZhbHVlIDwgMjA5NzE1MiAgID8gM1xuICAgICAgICA6IHZhbHVlIDwgMjY4NDM1NDU2ID8gNFxuICAgICAgICA6ICAgICAgICAgICAgICAgICAgICAgNSxcbiAgICB2YWx1ZSkpLmxlbjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5pbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX2ludDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIDwgMFxuICAgICAgICA/IHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgMTAsIExvbmdCaXRzLmZyb21OdW1iZXIodmFsdWUpKSAvLyAxMCBieXRlcyBwZXIgc3BlY1xuICAgICAgICA6IHRoaXMudWludDMyKHZhbHVlKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LCB6aWctemFnIGVuY29kZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNpbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX3NpbnQzMih2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnVpbnQzMigodmFsdWUgPDwgMSBeIHZhbHVlID4+IDMxKSA+Pj4gMCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZVZhcmludDY0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICB3aGlsZSAodmFsLmhpKSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwubG8gJiAxMjcgfCAxMjg7XG4gICAgICAgIHZhbC5sbyA9ICh2YWwubG8gPj4+IDcgfCB2YWwuaGkgPDwgMjUpID4+PiAwO1xuICAgICAgICB2YWwuaGkgPj4+PSA3O1xuICAgIH1cbiAgICB3aGlsZSAodmFsLmxvID4gMTI3KSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwubG8gJiAxMjcgfCAxMjg7XG4gICAgICAgIHZhbC5sbyA9IHZhbC5sbyA+Pj4gNztcbiAgICB9XG4gICAgYnVmW3BvcysrXSA9IHZhbC5sbztcbn1cblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUudWludDY0ID0gZnVuY3Rpb24gd3JpdGVfdWludDY0KHZhbHVlKSB7XG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCBiaXRzLmxlbmd0aCgpLCBiaXRzKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuaW50NjQgPSBXcml0ZXIucHJvdG90eXBlLnVpbnQ2NDtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LCB6aWctemFnIGVuY29kZWQuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zaW50NjQgPSBmdW5jdGlvbiB3cml0ZV9zaW50NjQodmFsdWUpIHtcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpLnp6RW5jb2RlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgYml0cy5sZW5ndGgoKSwgYml0cyk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIGJvb2xpc2ggdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24gd3JpdGVfYm9vbCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgdmFsdWUgPyAxIDogMCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUZpeGVkMzIodmFsLCBidWYsIHBvcykge1xuICAgIGJ1Zltwb3MgICAgXSA9ICB2YWwgICAgICAgICAmIDI1NTtcbiAgICBidWZbcG9zICsgMV0gPSAgdmFsID4+PiA4ICAgJiAyNTU7XG4gICAgYnVmW3BvcyArIDJdID0gIHZhbCA+Pj4gMTYgICYgMjU1O1xuICAgIGJ1Zltwb3MgKyAzXSA9ICB2YWwgPj4+IDI0O1xufVxuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgZml4ZWQgMzIgYml0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZml4ZWQzMiA9IGZ1bmN0aW9uIHdyaXRlX2ZpeGVkMzIodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIHZhbHVlID4+PiAwKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBmaXhlZCAzMiBiaXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNmaXhlZDMyID0gV3JpdGVyLnByb3RvdHlwZS5maXhlZDMyO1xuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgZml4ZWQgNjQgYml0cy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZpeGVkNjQgPSBmdW5jdGlvbiB3cml0ZV9maXhlZDY0KHZhbHVlKSB7XG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIGJpdHMubG8pLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgYml0cy5oaSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgZml4ZWQgNjQgYml0cy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ZpeGVkNjQgPSBXcml0ZXIucHJvdG90eXBlLmZpeGVkNjQ7XG5cbi8qKlxuICogV3JpdGVzIGEgZmxvYXQgKDMyIGJpdCkuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZmxvYXQgPSBmdW5jdGlvbiB3cml0ZV9mbG9hdCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHV0aWwuZmxvYXQud3JpdGVGbG9hdExFLCA0LCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIGRvdWJsZSAoNjQgYml0IGZsb2F0KS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbiB3cml0ZV9kb3VibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh1dGlsLmZsb2F0LndyaXRlRG91YmxlTEUsIDgsIHZhbHVlKTtcbn07XG5cbnZhciB3cml0ZUJ5dGVzID0gdXRpbC5BcnJheS5wcm90b3R5cGUuc2V0XG4gICAgPyBmdW5jdGlvbiB3cml0ZUJ5dGVzX3NldCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgIGJ1Zi5zZXQodmFsLCBwb3MpOyAvLyBhbHNvIHdvcmtzIGZvciBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICA6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNfZm9yKHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBidWZbcG9zICsgaV0gPSB2YWxbaV07XG4gICAgfTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzZXF1ZW5jZSBvZiBieXRlcy5cbiAqIEBwYXJhbSB7VWludDhBcnJheXxzdHJpbmd9IHZhbHVlIEJ1ZmZlciBvciBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24gd3JpdGVfYnl0ZXModmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoID4+PiAwO1xuICAgIGlmICghbGVuKVxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIDApO1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICB2YXIgYnVmID0gV3JpdGVyLmFsbG9jKGxlbiA9IGJhc2U2NC5sZW5ndGgodmFsdWUpKTtcbiAgICAgICAgYmFzZTY0LmRlY29kZSh2YWx1ZSwgYnVmLCAwKTtcbiAgICAgICAgdmFsdWUgPSBidWY7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnVpbnQzMihsZW4pLl9wdXNoKHdyaXRlQnl0ZXMsIGxlbiwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHdyaXRlX3N0cmluZyh2YWx1ZSkge1xuICAgIHZhciBsZW4gPSB1dGY4Lmxlbmd0aCh2YWx1ZSk7XG4gICAgcmV0dXJuIGxlblxuICAgICAgICA/IHRoaXMudWludDMyKGxlbikuX3B1c2godXRmOC53cml0ZSwgbGVuLCB2YWx1ZSlcbiAgICAgICAgOiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgMCk7XG59O1xuXG4vKipcbiAqIEZvcmtzIHRoaXMgd3JpdGVyJ3Mgc3RhdGUgYnkgcHVzaGluZyBpdCB0byBhIHN0YWNrLlxuICogQ2FsbGluZyB7QGxpbmsgV3JpdGVyI3Jlc2V0fHJlc2V0fSBvciB7QGxpbmsgV3JpdGVyI2xkZWxpbXxsZGVsaW19IHJlc2V0cyB0aGUgd3JpdGVyIHRvIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZvcmsgPSBmdW5jdGlvbiBmb3JrKCkge1xuICAgIHRoaXMuc3RhdGVzID0gbmV3IFN0YXRlKHRoaXMpO1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBPcChub29wLCAwLCAwKTtcbiAgICB0aGlzLmxlbiA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlc2V0cyB0aGlzIGluc3RhbmNlIHRvIHRoZSBsYXN0IHN0YXRlLlxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZXMpIHtcbiAgICAgICAgdGhpcy5oZWFkICAgPSB0aGlzLnN0YXRlcy5oZWFkO1xuICAgICAgICB0aGlzLnRhaWwgICA9IHRoaXMuc3RhdGVzLnRhaWw7XG4gICAgICAgIHRoaXMubGVuICAgID0gdGhpcy5zdGF0ZXMubGVuO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IHRoaXMuc3RhdGVzLm5leHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuICAgICAgICB0aGlzLmxlbiAgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVzZXRzIHRvIHRoZSBsYXN0IHN0YXRlIGFuZCBhcHBlbmRzIHRoZSBmb3JrIHN0YXRlJ3MgY3VycmVudCB3cml0ZSBsZW5ndGggYXMgYSB2YXJpbnQgZm9sbG93ZWQgYnkgaXRzIG9wZXJhdGlvbnMuXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5sZGVsaW0gPSBmdW5jdGlvbiBsZGVsaW0oKSB7XG4gICAgdmFyIGhlYWQgPSB0aGlzLmhlYWQsXG4gICAgICAgIHRhaWwgPSB0aGlzLnRhaWwsXG4gICAgICAgIGxlbiAgPSB0aGlzLmxlbjtcbiAgICB0aGlzLnJlc2V0KCkudWludDMyKGxlbik7XG4gICAgaWYgKGxlbikge1xuICAgICAgICB0aGlzLnRhaWwubmV4dCA9IGhlYWQubmV4dDsgLy8gc2tpcCBub29wXG4gICAgICAgIHRoaXMudGFpbCA9IHRhaWw7XG4gICAgICAgIHRoaXMubGVuICs9IGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEZpbmlzaGVzIHRoZSB3cml0ZSBvcGVyYXRpb24uXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gRmluaXNoZWQgYnVmZmVyXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gZmluaXNoKCkge1xuICAgIHZhciBoZWFkID0gdGhpcy5oZWFkLm5leHQsIC8vIHNraXAgbm9vcFxuICAgICAgICBidWYgID0gdGhpcy5jb25zdHJ1Y3Rvci5hbGxvYyh0aGlzLmxlbiksXG4gICAgICAgIHBvcyAgPSAwO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICAgIGhlYWQuZm4oaGVhZC52YWwsIGJ1ZiwgcG9zKTtcbiAgICAgICAgcG9zICs9IGhlYWQubGVuO1xuICAgICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgIH1cbiAgICAvLyB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHJldHVybiBidWY7XG59O1xuXG5Xcml0ZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKEJ1ZmZlcldyaXRlcl8pIHtcbiAgICBCdWZmZXJXcml0ZXIgPSBCdWZmZXJXcml0ZXJfO1xuICAgIFdyaXRlci5jcmVhdGUgPSBjcmVhdGUoKTtcbiAgICBCdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSgpO1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyV3JpdGVyO1xuXG4vLyBleHRlbmRzIFdyaXRlclxudmFyIFdyaXRlciA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKTtcbihCdWZmZXJXcml0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShXcml0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBCdWZmZXJXcml0ZXI7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyIHdyaXRlciBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgd3JpdGVyIHVzaW5nIG5vZGUgYnVmZmVycy5cbiAqIEBleHRlbmRzIFdyaXRlclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlcldyaXRlcigpIHtcbiAgICBXcml0ZXIuY2FsbCh0aGlzKTtcbn1cblxuQnVmZmVyV3JpdGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQWxsb2NhdGVzIGEgYnVmZmVyIG9mIHRoZSBzcGVjaWZpZWQgc2l6ZS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBCdWZmZXIgc2l6ZVxuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9IEJ1ZmZlclxuICAgICAqL1xuICAgIEJ1ZmZlcldyaXRlci5hbGxvYyA9IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZTtcblxuICAgIEJ1ZmZlcldyaXRlci53cml0ZUJ5dGVzQnVmZmVyID0gdXRpbC5CdWZmZXIgJiYgdXRpbC5CdWZmZXIucHJvdG90eXBlIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiB1dGlsLkJ1ZmZlci5wcm90b3R5cGUuc2V0Lm5hbWUgPT09IFwic2V0XCJcbiAgICAgICAgPyBmdW5jdGlvbiB3cml0ZUJ5dGVzQnVmZmVyX3NldCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgYnVmLnNldCh2YWwsIHBvcyk7IC8vIGZhc3RlciB0aGFuIGNvcHkgKHJlcXVpcmVzIG5vZGUgPj0gNCB3aGVyZSBCdWZmZXJzIGV4dGVuZCBVaW50OEFycmF5IGFuZCBzZXQgaXMgcHJvcGVybHkgaW5oZXJpdGVkKVxuICAgICAgICAgIC8vIGFsc28gd29ya3MgZm9yIHBsYWluIGFycmF5IHZhbHVlc1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogZnVuY3Rpb24gd3JpdGVCeXRlc0J1ZmZlcl9jb3B5KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgICBpZiAodmFsLmNvcHkpIC8vIEJ1ZmZlciB2YWx1ZXNcbiAgICAgICAgICAgIHZhbC5jb3B5KGJ1ZiwgcG9zLCAwLCB2YWwubGVuZ3RoKTtcbiAgICAgICAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDspIC8vIHBsYWluIGFycmF5IHZhbHVlc1xuICAgICAgICAgICAgYnVmW3BvcysrXSA9IHZhbFtpKytdO1xuICAgICAgICB9O1xufTtcblxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24gd3JpdGVfYnl0ZXNfYnVmZmVyKHZhbHVlKSB7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKVxuICAgICAgICB2YWx1ZSA9IHV0aWwuX0J1ZmZlcl9mcm9tKHZhbHVlLCBcImJhc2U2NFwiKTtcbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoID4+PiAwO1xuICAgIHRoaXMudWludDMyKGxlbik7XG4gICAgaWYgKGxlbilcbiAgICAgICAgdGhpcy5fcHVzaChCdWZmZXJXcml0ZXIud3JpdGVCeXRlc0J1ZmZlciwgbGVuLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiB3cml0ZVN0cmluZ0J1ZmZlcih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgaWYgKHZhbC5sZW5ndGggPCA0MCkgLy8gcGxhaW4ganMgaXMgZmFzdGVyIGZvciBzaG9ydCBzdHJpbmdzIChwcm9iYWJseSBkdWUgdG8gcmVkdW5kYW50IGFzc2VydGlvbnMpXG4gICAgICAgIHV0aWwudXRmOC53cml0ZSh2YWwsIGJ1ZiwgcG9zKTtcbiAgICBlbHNlIGlmIChidWYudXRmOFdyaXRlKVxuICAgICAgICBidWYudXRmOFdyaXRlKHZhbCwgcG9zKTtcbiAgICBlbHNlXG4gICAgICAgIGJ1Zi53cml0ZSh2YWwsIHBvcyk7XG59XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gd3JpdGVfc3RyaW5nX2J1ZmZlcih2YWx1ZSkge1xuICAgIHZhciBsZW4gPSB1dGlsLkJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlKTtcbiAgICB0aGlzLnVpbnQzMihsZW4pO1xuICAgIGlmIChsZW4pXG4gICAgICAgIHRoaXMuX3B1c2god3JpdGVTdHJpbmdCdWZmZXIsIGxlbiwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIEZpbmlzaGVzIHRoZSB3cml0ZSBvcGVyYXRpb24uXG4gKiBAbmFtZSBCdWZmZXJXcml0ZXIjZmluaXNoXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IEZpbmlzaGVkIGJ1ZmZlclxuICovXG5cbkJ1ZmZlcldyaXRlci5fY29uZmlndXJlKCk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRlcjtcblxudmFyIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxudmFyIEJ1ZmZlclJlYWRlcjsgLy8gY3ljbGljXG5cbnZhciBMb25nQml0cyAgPSB1dGlsLkxvbmdCaXRzLFxuICAgIHV0ZjggICAgICA9IHV0aWwudXRmODtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGluZGV4T3V0T2ZSYW5nZShyZWFkZXIsIHdyaXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIFJhbmdlRXJyb3IoXCJpbmRleCBvdXQgb2YgcmFuZ2U6IFwiICsgcmVhZGVyLnBvcyArIFwiICsgXCIgKyAod3JpdGVMZW5ndGggfHwgMSkgKyBcIiA+IFwiICsgcmVhZGVyLmxlbik7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyByZWFkZXIgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBidWZmZXIuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHJlYWRlciB1c2luZyBgVWludDhBcnJheWAgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgYEFycmF5YC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxuICovXG5mdW5jdGlvbiBSZWFkZXIoYnVmZmVyKSB7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlci5cbiAgICAgKiBAdHlwZSB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmJ1ZiA9IGJ1ZmZlcjtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyIHBvc2l0aW9uLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wb3MgPSAwO1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSBidWZmZXIubGVuZ3RoO1xufVxuXG52YXIgY3JlYXRlX2FycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCJcbiAgICA/IGZ1bmN0aW9uIGNyZWF0ZV90eXBlZF9hcnJheShidWZmZXIpIHtcbiAgICAgICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgQXJyYXkuaXNBcnJheShidWZmZXIpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIoYnVmZmVyKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICA6IGZ1bmN0aW9uIGNyZWF0ZV9hcnJheShidWZmZXIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYnVmZmVyKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVhZGVyKGJ1ZmZlcik7XG4gICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIik7XG4gICAgfTtcblxudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4gdXRpbC5CdWZmZXJcbiAgICAgICAgPyBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyX3NldHVwKGJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuIChSZWFkZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbC5CdWZmZXIuaXNCdWZmZXIoYnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICA/IG5ldyBCdWZmZXJSZWFkZXIoYnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICA6IGNyZWF0ZV9hcnJheShidWZmZXIpO1xuICAgICAgICAgICAgfSkoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IGNyZWF0ZV9hcnJheTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyByZWFkZXIgdXNpbmcgdGhlIHNwZWNpZmllZCBidWZmZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7VWludDhBcnJheXxCdWZmZXJ9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXG4gKiBAcmV0dXJucyB7UmVhZGVyfEJ1ZmZlclJlYWRlcn0gQSB7QGxpbmsgQnVmZmVyUmVhZGVyfSBpZiBgYnVmZmVyYCBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGEge0BsaW5rIFJlYWRlcn1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgYnVmZmVyYCBpcyBub3QgYSB2YWxpZCBidWZmZXJcbiAqL1xuUmVhZGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuXG5SZWFkZXIucHJvdG90eXBlLl9zbGljZSA9IHV0aWwuQXJyYXkucHJvdG90eXBlLnN1YmFycmF5IHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGFuIHVuc2lnbmVkIDMyIGJpdCB2YWx1ZS5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnVpbnQzMiA9IChmdW5jdGlvbiByZWFkX3VpbnQzMl9zZXR1cCgpIHtcbiAgICB2YXIgdmFsdWUgPSA0Mjk0OTY3Mjk1OyAvLyBvcHRpbWl6ZXIgdHlwZS1oaW50LCB0ZW5kcyB0byBkZW9wdCBvdGhlcndpc2UgKD8hKVxuICAgIHJldHVybiBmdW5jdGlvbiByZWFkX3VpbnQzMigpIHtcbiAgICAgICAgdmFsdWUgPSAoICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3NdICYgMTI3ICAgICAgICkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8ICA3KSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMTQpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAyMSkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAgMTUpIDw8IDI4KSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICgodGhpcy5wb3MgKz0gNSkgPiB0aGlzLmxlbikge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmxlbjtcbiAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5pbnQzMiA9IGZ1bmN0aW9uIHJlYWRfaW50MzIoKSB7XG4gICAgcmV0dXJuIHRoaXMudWludDMyKCkgfCAwO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHppZy16YWcgZW5jb2RlZCB2YXJpbnQgYXMgYSBzaWduZWQgMzIgYml0IHZhbHVlLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNpbnQzMiA9IGZ1bmN0aW9uIHJlYWRfc2ludDMyKCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMudWludDMyKCk7XG4gICAgcmV0dXJuIHZhbHVlID4+PiAxIF4gLSh2YWx1ZSAmIDEpIHwgMDtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG5mdW5jdGlvbiByZWFkTG9uZ1ZhcmludCgpIHtcbiAgICAvLyB0ZW5kcyB0byBkZW9wdCB3aXRoIGxvY2FsIHZhcnMgZm9yIG9jdGV0IGV0Yy5cbiAgICB2YXIgYml0cyA9IG5ldyBMb25nQml0cygwLCAwKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgaWYgKHRoaXMubGVuIC0gdGhpcy5wb3MgPiA0KSB7IC8vIGZhc3Qgcm91dGUgKGxvKVxuICAgICAgICBmb3IgKDsgaSA8IDQ7ICsraSkge1xuICAgICAgICAgICAgLy8gMXN0Li40dGhcbiAgICAgICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLyA1dGhcbiAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMjgpID4+PiAwO1xuICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA+PiAgNCkgPj4+IDA7XG4gICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICBpID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKDsgaSA8IDM7ICsraSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICAgICAgLy8gMXN0Li4zdGhcbiAgICAgICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLyA0dGhcbiAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XG4gICAgICAgIHJldHVybiBiaXRzO1xuICAgIH1cbiAgICBpZiAodGhpcy5sZW4gLSB0aGlzLnBvcyA+IDQpIHsgLy8gZmFzdCByb3V0ZSAoaGkpXG4gICAgICAgIGZvciAoOyBpIDwgNTsgKytpKSB7XG4gICAgICAgICAgICAvLyA2dGguLjEwdGhcbiAgICAgICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3ICsgMykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKDsgaSA8IDU7ICsraSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICAgICAgLy8gNnRoLi4xMHRoXG4gICAgICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNyArIDMpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIHZhcmludCBlbmNvZGluZ1wiKTtcbn1cblxuLyogZXNsaW50LWVuYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUuXG4gKiBAbmFtZSBSZWFkZXIjaW50NjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciN1aW50NjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIHZhcmludCBhcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUuXG4gKiBAbmFtZSBSZWFkZXIjc2ludDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhIGJvb2xlYW4uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmJvb2wgPSBmdW5jdGlvbiByZWFkX2Jvb2woKSB7XG4gICAgcmV0dXJuIHRoaXMudWludDMyKCkgIT09IDA7XG59O1xuXG5mdW5jdGlvbiByZWFkRml4ZWQzMl9lbmQoYnVmLCBlbmQpIHsgLy8gbm90ZSB0aGF0IHRoaXMgdXNlcyBgZW5kYCwgbm90IGBwb3NgXG4gICAgcmV0dXJuIChidWZbZW5kIC0gNF1cbiAgICAgICAgICB8IGJ1ZltlbmQgLSAzXSA8PCA4XG4gICAgICAgICAgfCBidWZbZW5kIC0gMl0gPDwgMTZcbiAgICAgICAgICB8IGJ1ZltlbmQgLSAxXSA8PCAyNCkgPj4+IDA7XG59XG5cbi8qKlxuICogUmVhZHMgZml4ZWQgMzIgYml0cyBhcyBhbiB1bnNpZ25lZCAzMiBiaXQgaW50ZWdlci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5maXhlZDMyID0gZnVuY3Rpb24gcmVhZF9maXhlZDMyKCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICByZXR1cm4gcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KTtcbn07XG5cbi8qKlxuICogUmVhZHMgZml4ZWQgMzIgYml0cyBhcyBhIHNpZ25lZCAzMiBiaXQgaW50ZWdlci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5zZml4ZWQzMiA9IGZ1bmN0aW9uIHJlYWRfc2ZpeGVkMzIoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHJldHVybiByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpIHwgMDtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG5mdW5jdGlvbiByZWFkRml4ZWQ2NCgvKiB0aGlzOiBSZWFkZXIgKi8pIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDggPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDgpO1xuXG4gICAgcmV0dXJuIG5ldyBMb25nQml0cyhyZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpLCByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpKTtcbn1cblxuLyogZXNsaW50LWVuYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuLyoqXG4gKiBSZWFkcyBmaXhlZCA2NCBiaXRzLlxuICogQG5hbWUgUmVhZGVyI2ZpeGVkNjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIHppZy16YWcgZW5jb2RlZCBmaXhlZCA2NCBiaXRzLlxuICogQG5hbWUgUmVhZGVyI3NmaXhlZDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIGZsb2F0ICgzMiBiaXQpIGFzIGEgbnVtYmVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuZmxvYXQgPSBmdW5jdGlvbiByZWFkX2Zsb2F0KCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICB2YXIgdmFsdWUgPSB1dGlsLmZsb2F0LnJlYWRGbG9hdExFKHRoaXMuYnVmLCB0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MgKz0gNDtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgZG91YmxlICg2NCBiaXQgZmxvYXQpIGFzIGEgbnVtYmVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuZG91YmxlID0gZnVuY3Rpb24gcmVhZF9kb3VibGUoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA4ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHZhciB2YWx1ZSA9IHV0aWwuZmxvYXQucmVhZERvdWJsZUxFKHRoaXMuYnVmLCB0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MgKz0gODtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgcHJlY2VlZGVkIGJ5IGl0cyBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24gcmVhZF9ieXRlcygpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy51aW50MzIoKSxcbiAgICAgICAgc3RhcnQgID0gdGhpcy5wb3MsXG4gICAgICAgIGVuZCAgICA9IHRoaXMucG9zICsgbGVuZ3RoO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGVuZCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgbGVuZ3RoKTtcblxuICAgIHRoaXMucG9zICs9IGxlbmd0aDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmJ1ZikpIC8vIHBsYWluIGFycmF5XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi5zbGljZShzdGFydCwgZW5kKTtcblxuICAgIGlmIChzdGFydCA9PT0gZW5kKSB7IC8vIGZpeCBmb3IgSUUgMTAvV2luOCBhbmQgb3RoZXJzJyBzdWJhcnJheSByZXR1cm5pbmcgYXJyYXkgb2Ygc2l6ZSAxXG4gICAgICAgIHZhciBuYXRpdmVCdWZmZXIgPSB1dGlsLkJ1ZmZlcjtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUJ1ZmZlclxuICAgICAgICAgICAgPyBuYXRpdmVCdWZmZXIuYWxsb2MoMClcbiAgICAgICAgICAgIDogbmV3IHRoaXMuYnVmLmNvbnN0cnVjdG9yKDApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2xpY2UuY2FsbCh0aGlzLmJ1Ziwgc3RhcnQsIGVuZCk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgc3RyaW5nIHByZWNlZWRlZCBieSBpdHMgYnl0ZSBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmcoKSB7XG4gICAgdmFyIGJ5dGVzID0gdGhpcy5ieXRlcygpO1xuICAgIHJldHVybiB1dGY4LnJlYWQoYnl0ZXMsIDAsIGJ5dGVzLmxlbmd0aCk7XG59O1xuXG4vKipcbiAqIFNraXBzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGJ5dGVzIGlmIHNwZWNpZmllZCwgb3RoZXJ3aXNlIHNraXBzIGEgdmFyaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIExlbmd0aCBpZiBrbm93biwgb3RoZXJ3aXNlIGEgdmFyaW50IGlzIGFzc3VtZWRcbiAqIEByZXR1cm5zIHtSZWFkZXJ9IGB0aGlzYFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiBza2lwKGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAodGhpcy5wb3MgKyBsZW5ndGggPiB0aGlzLmxlbilcbiAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xuICAgICAgICB0aGlzLnBvcyArPSBsZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICB9IHdoaWxlICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDEyOCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTa2lwcyB0aGUgbmV4dCBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgd2lyZSB0eXBlLlxuICogQHBhcmFtIHtudW1iZXJ9IHdpcmVUeXBlIFdpcmUgdHlwZSByZWNlaXZlZFxuICogQHJldHVybnMge1JlYWRlcn0gYHRoaXNgXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2tpcFR5cGUgPSBmdW5jdGlvbih3aXJlVHlwZSkge1xuICAgIHN3aXRjaCAod2lyZVR5cGUpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGhpcy5za2lwKDgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRoaXMuc2tpcCh0aGlzLnVpbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB3aGlsZSAoKHdpcmVUeXBlID0gdGhpcy51aW50MzIoKSAmIDcpICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwVHlwZSh3aXJlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdGhpcy5za2lwKDQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB3aXJlIHR5cGUgXCIgKyB3aXJlVHlwZSArIFwiIGF0IG9mZnNldCBcIiArIHRoaXMucG9zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZWFkZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKEJ1ZmZlclJlYWRlcl8pIHtcbiAgICBCdWZmZXJSZWFkZXIgPSBCdWZmZXJSZWFkZXJfO1xuICAgIFJlYWRlci5jcmVhdGUgPSBjcmVhdGUoKTtcbiAgICBCdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSgpO1xuXG4gICAgdmFyIGZuID0gdXRpbC5Mb25nID8gXCJ0b0xvbmdcIiA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFwidG9OdW1iZXJcIjtcbiAgICB1dGlsLm1lcmdlKFJlYWRlci5wcm90b3R5cGUsIHtcblxuICAgICAgICBpbnQ2NDogZnVuY3Rpb24gcmVhZF9pbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdWludDY0OiBmdW5jdGlvbiByZWFkX3VpbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaW50NjQ6IGZ1bmN0aW9uIHJlYWRfc2ludDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcykuenpEZWNvZGUoKVtmbl0oZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRfZml4ZWQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZml4ZWQ2NDogZnVuY3Rpb24gcmVhZF9zZml4ZWQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XG4gICAgICAgIH1cblxuICAgIH0pO1xufTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyUmVhZGVyO1xuXG4vLyBleHRlbmRzIFJlYWRlclxudmFyIFJlYWRlciA9IHJlcXVpcmUoXCIuL3JlYWRlclwiKTtcbihCdWZmZXJSZWFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWFkZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBCdWZmZXJSZWFkZXI7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyIHJlYWRlciBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgcmVhZGVyIHVzaW5nIG5vZGUgYnVmZmVycy5cbiAqIEBleHRlbmRzIFJlYWRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqL1xuZnVuY3Rpb24gQnVmZmVyUmVhZGVyKGJ1ZmZlcikge1xuICAgIFJlYWRlci5jYWxsKHRoaXMsIGJ1ZmZlcik7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlci5cbiAgICAgKiBAbmFtZSBCdWZmZXJSZWFkZXIjYnVmXG4gICAgICogQHR5cGUge0J1ZmZlcn1cbiAgICAgKi9cbn1cblxuQnVmZmVyUmVhZGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodXRpbC5CdWZmZXIpXG4gICAgICAgIEJ1ZmZlclJlYWRlci5wcm90b3R5cGUuX3NsaWNlID0gdXRpbC5CdWZmZXIucHJvdG90eXBlLnNsaWNlO1xufTtcblxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHJlYWRfc3RyaW5nX2J1ZmZlcigpIHtcbiAgICB2YXIgbGVuID0gdGhpcy51aW50MzIoKTsgLy8gbW9kaWZpZXMgcG9zXG4gICAgcmV0dXJuIHRoaXMuYnVmLnV0ZjhTbGljZVxuICAgICAgICA/IHRoaXMuYnVmLnV0ZjhTbGljZSh0aGlzLnBvcywgdGhpcy5wb3MgPSBNYXRoLm1pbih0aGlzLnBvcyArIGxlbiwgdGhpcy5sZW4pKVxuICAgICAgICA6IHRoaXMuYnVmLnRvU3RyaW5nKFwidXRmLThcIiwgdGhpcy5wb3MsIHRoaXMucG9zID0gTWF0aC5taW4odGhpcy5wb3MgKyBsZW4sIHRoaXMubGVuKSk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgcHJlY2VlZGVkIGJ5IGl0cyBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAbmFtZSBCdWZmZXJSZWFkZXIjYnl0ZXNcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0J1ZmZlcn0gVmFsdWUgcmVhZFxuICovXG5cbkJ1ZmZlclJlYWRlci5fY29uZmlndXJlKCk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFNlcnZpY2U7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbWluaW1hbFwiKTtcblxuLy8gRXh0ZW5kcyBFdmVudEVtaXR0ZXJcbihTZXJ2aWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodXRpbC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBTZXJ2aWNlO1xuXG4vKipcbiAqIEEgc2VydmljZSBtZXRob2QgY2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgcnBjLlNlcnZpY2VNZXRob2R8U2VydmljZU1ldGhvZH0uXG4gKlxuICogRGlmZmVycyBmcm9tIHtAbGluayBSUENJbXBsQ2FsbGJhY2t9IGluIHRoYXQgaXQgaXMgYW4gYWN0dWFsIGNhbGxiYWNrIG9mIGEgc2VydmljZSBtZXRob2Qgd2hpY2ggbWF5IG5vdCByZXR1cm4gYHJlc3BvbnNlID0gbnVsbGAuXG4gKiBAdHlwZWRlZiBycGMuU2VydmljZU1ldGhvZENhbGxiYWNrXG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueVxuICogQHBhcmFtIHtUUmVzfSBbcmVzcG9uc2VdIFJlc3BvbnNlIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBBIHNlcnZpY2UgbWV0aG9kIHBhcnQgb2YgYSB7QGxpbmsgcnBjLlNlcnZpY2V9IGFzIGNyZWF0ZWQgYnkge0BsaW5rIFNlcnZpY2UuY3JlYXRlfS5cbiAqIEB0eXBlZGVmIHJwYy5TZXJ2aWNlTWV0aG9kXG4gKiBAdGVtcGxhdGUgVFJlcSBleHRlbmRzIE1lc3NhZ2U8VFJlcT5cbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtUUmVxfFByb3BlcnRpZXM8VFJlcT59IHJlcXVlc3QgUmVxdWVzdCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdFxuICogQHBhcmFtIHtycGMuU2VydmljZU1ldGhvZENhbGxiYWNrPFRSZXM+fSBbY2FsbGJhY2tdIE5vZGUtc3R5bGUgY2FsbGJhY2sgY2FsbGVkIHdpdGggdGhlIGVycm9yLCBpZiBhbnksIGFuZCB0aGUgcmVzcG9uc2UgbWVzc2FnZVxuICogQHJldHVybnMge1Byb21pc2U8TWVzc2FnZTxUUmVzPj59IFByb21pc2UgaWYgYGNhbGxiYWNrYCBoYXMgYmVlbiBvbWl0dGVkLCBvdGhlcndpc2UgYHVuZGVmaW5lZGBcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgUlBDIHNlcnZpY2UgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIEFuIFJQQyBzZXJ2aWNlIGFzIHJldHVybmVkIGJ5IHtAbGluayBTZXJ2aWNlI2NyZWF0ZX0uXG4gKiBAZXhwb3J0cyBycGMuU2VydmljZVxuICogQGV4dGVuZHMgdXRpbC5FdmVudEVtaXR0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtSUENJbXBsfSBycGNJbXBsIFJQQyBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbcmVxdWVzdERlbGltaXRlZD1mYWxzZV0gV2hldGhlciByZXF1ZXN0cyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxuICogQHBhcmFtIHtib29sZWFufSBbcmVzcG9uc2VEZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBsZW5ndGgtZGVsaW1pdGVkXG4gKi9cbmZ1bmN0aW9uIFNlcnZpY2UocnBjSW1wbCwgcmVxdWVzdERlbGltaXRlZCwgcmVzcG9uc2VEZWxpbWl0ZWQpIHtcblxuICAgIGlmICh0eXBlb2YgcnBjSW1wbCAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJycGNJbXBsIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcblxuICAgIHV0aWwuRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBSUEMgaW1wbGVtZW50YXRpb24uIEJlY29tZXMgYG51bGxgIG9uY2UgdGhlIHNlcnZpY2UgaXMgZW5kZWQuXG4gICAgICogQHR5cGUge1JQQ0ltcGx8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJwY0ltcGwgPSBycGNJbXBsO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciByZXF1ZXN0cyBhcmUgbGVuZ3RoLWRlbGltaXRlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlcXVlc3REZWxpbWl0ZWQgPSBCb29sZWFuKHJlcXVlc3REZWxpbWl0ZWQpO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciByZXNwb25zZXMgYXJlIGxlbmd0aC1kZWxpbWl0ZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXNwb25zZURlbGltaXRlZCA9IEJvb2xlYW4ocmVzcG9uc2VEZWxpbWl0ZWQpO1xufVxuXG4vKipcbiAqIENhbGxzIGEgc2VydmljZSBtZXRob2QgdGhyb3VnaCB7QGxpbmsgcnBjLlNlcnZpY2UjcnBjSW1wbHxycGNJbXBsfS5cbiAqIEBwYXJhbSB7TWV0aG9kfHJwYy5TZXJ2aWNlTWV0aG9kPFRSZXEsVFJlcz59IG1ldGhvZCBSZWZsZWN0ZWQgb3Igc3RhdGljIG1ldGhvZFxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUUmVxPn0gcmVxdWVzdEN0b3IgUmVxdWVzdCBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUUmVzPn0gcmVzcG9uc2VDdG9yIFJlc3BvbnNlIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1RSZXF8UHJvcGVydGllczxUUmVxPn0gcmVxdWVzdCBSZXF1ZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0XG4gKiBAcGFyYW0ge3JwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2s8VFJlcz59IGNhbGxiYWNrIFNlcnZpY2UgY2FsbGJhY2tcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAdGVtcGxhdGUgVFJlcSBleHRlbmRzIE1lc3NhZ2U8VFJlcT5cbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5ycGNDYWxsID0gZnVuY3Rpb24gcnBjQ2FsbChtZXRob2QsIHJlcXVlc3RDdG9yLCByZXNwb25zZUN0b3IsIHJlcXVlc3QsIGNhbGxiYWNrKSB7XG5cbiAgICBpZiAoIXJlcXVlc3QpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJlcXVlc3QgbXVzdCBiZSBzcGVjaWZpZWRcIik7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFjYWxsYmFjaylcbiAgICAgICAgcmV0dXJuIHV0aWwuYXNQcm9taXNlKHJwY0NhbGwsIHNlbGYsIG1ldGhvZCwgcmVxdWVzdEN0b3IsIHJlc3BvbnNlQ3RvciwgcmVxdWVzdCk7XG5cbiAgICBpZiAoIXNlbGYucnBjSW1wbCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhFcnJvcihcImFscmVhZHkgZW5kZWRcIikpOyB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gc2VsZi5ycGNJbXBsKFxuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgcmVxdWVzdEN0b3Jbc2VsZi5yZXF1ZXN0RGVsaW1pdGVkID8gXCJlbmNvZGVEZWxpbWl0ZWRcIiA6IFwiZW5jb2RlXCJdKHJlcXVlc3QpLmZpbmlzaCgpLFxuICAgICAgICAgICAgZnVuY3Rpb24gcnBjQ2FsbGJhY2soZXJyLCByZXNwb25zZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVuZCgvKiBlbmRlZEJ5UlBDICovIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgcmVzcG9uc2VDdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSByZXNwb25zZUN0b3Jbc2VsZi5yZXNwb25zZURlbGltaXRlZCA/IFwiZGVjb2RlRGVsaW1pdGVkXCIgOiBcImRlY29kZVwiXShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJkYXRhXCIsIHJlc3BvbnNlLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soZXJyKTsgfSwgMCk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBFbmRzIHRoaXMgc2VydmljZSBhbmQgZW1pdHMgdGhlIGBlbmRgIGV2ZW50LlxuICogQHBhcmFtIHtib29sZWFufSBbZW5kZWRCeVJQQz1mYWxzZV0gV2hldGhlciB0aGUgc2VydmljZSBoYXMgYmVlbiBlbmRlZCBieSB0aGUgUlBDIGltcGxlbWVudGF0aW9uLlxuICogQHJldHVybnMge3JwYy5TZXJ2aWNlfSBgdGhpc2BcbiAqL1xuU2VydmljZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gZW5kKGVuZGVkQnlSUEMpIHtcbiAgICBpZiAodGhpcy5ycGNJbXBsKSB7XG4gICAgICAgIGlmICghZW5kZWRCeVJQQykgLy8gc2lnbmFsIGVuZCB0byBycGNJbXBsXG4gICAgICAgICAgICB0aGlzLnJwY0ltcGwobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIHRoaXMucnBjSW1wbCA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdChcImVuZFwiKS5vZmYoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFN0cmVhbWluZyBSUEMgaGVscGVycy5cbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIHJwYyA9IGV4cG9ydHM7XG5cbi8qKlxuICogUlBDIGltcGxlbWVudGF0aW9uIHBhc3NlZCB0byB7QGxpbmsgU2VydmljZSNjcmVhdGV9IHBlcmZvcm1pbmcgYSBzZXJ2aWNlIHJlcXVlc3Qgb24gbmV0d29yayBsZXZlbCwgaS5lLiBieSB1dGlsaXppbmcgaHR0cCByZXF1ZXN0cyBvciB3ZWJzb2NrZXRzLlxuICogQHR5cGVkZWYgUlBDSW1wbFxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtNZXRob2R8cnBjLlNlcnZpY2VNZXRob2Q8TWVzc2FnZTx7fT4sTWVzc2FnZTx7fT4+fSBtZXRob2QgUmVmbGVjdGVkIG9yIHN0YXRpYyBtZXRob2QgYmVpbmcgY2FsbGVkXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHJlcXVlc3REYXRhIFJlcXVlc3QgZGF0YVxuICogQHBhcmFtIHtSUENJbXBsQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQGV4YW1wbGVcbiAqIGZ1bmN0aW9uIHJwY0ltcGwobWV0aG9kLCByZXF1ZXN0RGF0YSwgY2FsbGJhY2spIHtcbiAqICAgICBpZiAocHJvdG9idWYudXRpbC5sY0ZpcnN0KG1ldGhvZC5uYW1lKSAhPT0gXCJteU1ldGhvZFwiKSAvLyBjb21wYXRpYmxlIHdpdGggc3RhdGljIGNvZGVcbiAqICAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIG1ldGhvZFwiKTtcbiAqICAgICBhc3luY2hyb25vdXNseU9idGFpbkFSZXNwb25zZShyZXF1ZXN0RGF0YSwgZnVuY3Rpb24oZXJyLCByZXNwb25zZURhdGEpIHtcbiAqICAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwb25zZURhdGEpO1xuICogICAgIH0pO1xuICogfVxuICovXG5cbi8qKlxuICogTm9kZS1zdHlsZSBjYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayBSUENJbXBsfS5cbiAqIEB0eXBlZGVmIFJQQ0ltcGxDYWxsYmFja1xuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55LCBvdGhlcndpc2UgYG51bGxgXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8bnVsbH0gW3Jlc3BvbnNlXSBSZXNwb25zZSBkYXRhIG9yIGBudWxsYCB0byBzaWduYWwgZW5kIG9mIHN0cmVhbSwgaWYgdGhlcmUgaGFzbid0IGJlZW4gYW4gZXJyb3JcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxucnBjLlNlcnZpY2UgPSByZXF1aXJlKFwiLi9ycGMvc2VydmljZVwiKTtcbiIsICJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qKlxuICogTmFtZWQgcm9vdHMuXG4gKiBUaGlzIGlzIHdoZXJlIHBianMgc3RvcmVzIGdlbmVyYXRlZCBzdHJ1Y3R1cmVzICh0aGUgb3B0aW9uIGAtciwgLS1yb290YCBzcGVjaWZpZXMgYSBuYW1lKS5cbiAqIENhbiBhbHNvIGJlIHVzZWQgbWFudWFsbHkgdG8gbWFrZSByb290cyBhdmFpbGFibGUgYWNyb3NzIG1vZHVsZXMuXG4gKiBAbmFtZSByb290c1xuICogQHR5cGUge09iamVjdC48c3RyaW5nLFJvb3Q+fVxuICogQGV4YW1wbGVcbiAqIC8vIHBianMgLXIgbXlyb290IC1vIGNvbXBpbGVkLmpzIC4uLlxuICpcbiAqIC8vIGluIGFub3RoZXIgbW9kdWxlOlxuICogcmVxdWlyZShcIi4vY29tcGlsZWQuanNcIik7XG4gKlxuICogLy8gaW4gYW55IHN1YnNlcXVlbnQgbW9kdWxlOlxuICogdmFyIHJvb3QgPSBwcm90b2J1Zi5yb290c1tcIm15cm9vdFwiXTtcbiAqL1xuIiwgIlwidXNlIHN0cmljdFwiO1xudmFyIHByb3RvYnVmID0gZXhwb3J0cztcblxuLyoqXG4gKiBCdWlsZCB0eXBlLCBvbmUgb2YgYFwiZnVsbFwiYCwgYFwibGlnaHRcImAgb3IgYFwibWluaW1hbFwiYC5cbiAqIEBuYW1lIGJ1aWxkXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGNvbnN0XG4gKi9cbnByb3RvYnVmLmJ1aWxkID0gXCJtaW5pbWFsXCI7XG5cbi8vIFNlcmlhbGl6YXRpb25cbnByb3RvYnVmLldyaXRlciAgICAgICA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKTtcbnByb3RvYnVmLkJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoXCIuL3dyaXRlcl9idWZmZXJcIik7XG5wcm90b2J1Zi5SZWFkZXIgICAgICAgPSByZXF1aXJlKFwiLi9yZWFkZXJcIik7XG5wcm90b2J1Zi5CdWZmZXJSZWFkZXIgPSByZXF1aXJlKFwiLi9yZWFkZXJfYnVmZmVyXCIpO1xuXG4vLyBVdGlsaXR5XG5wcm90b2J1Zi51dGlsICAgICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5wcm90b2J1Zi5ycGMgICAgICAgICAgPSByZXF1aXJlKFwiLi9ycGNcIik7XG5wcm90b2J1Zi5yb290cyAgICAgICAgPSByZXF1aXJlKFwiLi9yb290c1wiKTtcbnByb3RvYnVmLmNvbmZpZ3VyZSAgICA9IGNvbmZpZ3VyZTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogUmVjb25maWd1cmVzIHRoZSBsaWJyYXJ5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBjb25maWd1cmUoKSB7XG4gICAgcHJvdG9idWYudXRpbC5fY29uZmlndXJlKCk7XG4gICAgcHJvdG9idWYuV3JpdGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyV3JpdGVyKTtcbiAgICBwcm90b2J1Zi5SZWFkZXIuX2NvbmZpZ3VyZShwcm90b2J1Zi5CdWZmZXJSZWFkZXIpO1xufVxuXG4vLyBTZXQgdXAgYnVmZmVyIHV0aWxpdHkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudFxuY29uZmlndXJlKCk7XG4iLCAiLy8gbWluaW1hbCBsaWJyYXJ5IGVudHJ5IHBvaW50LlxuXG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vc3JjL2luZGV4LW1pbmltYWxcIik7XG4iLCAiLyplc2xpbnQtZGlzYWJsZSBibG9jay1zY29wZWQtdmFyLCBpZC1sZW5ndGgsIG5vLWNvbnRyb2wtcmVnZXgsIG5vLW1hZ2ljLW51bWJlcnMsIG5vLXByb3RvdHlwZS1idWlsdGlucywgbm8tcmVkZWNsYXJlLCBuby1zaGFkb3csIG5vLXZhciwgc29ydC12YXJzKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJHByb3RvYnVmID0gcmVxdWlyZShcInByb3RvYnVmanMvbWluaW1hbFwiKTtcblxuLy8gQ29tbW9uIGFsaWFzZXNcbnZhciAkUmVhZGVyID0gJHByb3RvYnVmLlJlYWRlciwgJFdyaXRlciA9ICRwcm90b2J1Zi5Xcml0ZXIsICR1dGlsID0gJHByb3RvYnVmLnV0aWw7XG5cbi8vIEV4cG9ydGVkIHJvb3QgbmFtZXNwYWNlXG52YXIgJHJvb3QgPSAkcHJvdG9idWYucm9vdHNbXCJkZWZhdWx0XCJdIHx8ICgkcHJvdG9idWYucm9vdHNbXCJkZWZhdWx0XCJdID0ge30pO1xuXG4kcm9vdC5vbm54ID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogTmFtZXNwYWNlIG9ubnguXG4gICAgICogQGV4cG9ydHMgb25ueFxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKi9cbiAgICB2YXIgb25ueCA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogVmVyc2lvbiBlbnVtLlxuICAgICAqIEBuYW1lIG9ubnguVmVyc2lvblxuICAgICAqIEBlbnVtIHtudW1iZXJ9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9TVEFSVF9WRVJTSU9OPTAgX1NUQVJUX1ZFUlNJT04gdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gSVJfVkVSU0lPTl8yMDE3XzEwXzEwPTEgSVJfVkVSU0lPTl8yMDE3XzEwXzEwIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElSX1ZFUlNJT05fMjAxN18xMF8zMD0yIElSX1ZFUlNJT05fMjAxN18xMF8zMCB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJUl9WRVJTSU9OXzIwMTdfMTFfMz0zIElSX1ZFUlNJT05fMjAxN18xMV8zIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElSX1ZFUlNJT05fMjAxOV8xXzIyPTQgSVJfVkVSU0lPTl8yMDE5XzFfMjIgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gSVJfVkVSU0lPTl8yMDE5XzNfMTg9NSBJUl9WRVJTSU9OXzIwMTlfM18xOCB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJUl9WRVJTSU9OXzIwMTlfOV8xOT02IElSX1ZFUlNJT05fMjAxOV85XzE5IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElSX1ZFUlNJT05fMjAyMF81Xzg9NyBJUl9WRVJTSU9OXzIwMjBfNV84IHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElSX1ZFUlNJT05fMjAyMV83XzMwPTggSVJfVkVSU0lPTl8yMDIxXzdfMzAgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gSVJfVkVSU0lPTj05IElSX1ZFUlNJT04gdmFsdWVcbiAgICAgKi9cbiAgICBvbm54LlZlcnNpb24gPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzBdID0gXCJfU1RBUlRfVkVSU0lPTlwiXSA9IDA7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzFdID0gXCJJUl9WRVJTSU9OXzIwMTdfMTBfMTBcIl0gPSAxO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsyXSA9IFwiSVJfVkVSU0lPTl8yMDE3XzEwXzMwXCJdID0gMjtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbM10gPSBcIklSX1ZFUlNJT05fMjAxN18xMV8zXCJdID0gMztcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNF0gPSBcIklSX1ZFUlNJT05fMjAxOV8xXzIyXCJdID0gNDtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNV0gPSBcIklSX1ZFUlNJT05fMjAxOV8zXzE4XCJdID0gNTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNl0gPSBcIklSX1ZFUlNJT05fMjAxOV85XzE5XCJdID0gNjtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbN10gPSBcIklSX1ZFUlNJT05fMjAyMF81XzhcIl0gPSA3O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs4XSA9IFwiSVJfVkVSU0lPTl8yMDIxXzdfMzBcIl0gPSA4O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs5XSA9IFwiSVJfVkVSU0lPTlwiXSA9IDk7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfSkoKTtcblxuICAgIG9ubnguQXR0cmlidXRlUHJvdG8gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYW4gQXR0cmlidXRlUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBpbnRlcmZhY2UgSUF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtuYW1lXSBBdHRyaWJ1dGVQcm90byBuYW1lXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtyZWZBdHRyTmFtZV0gQXR0cmlidXRlUHJvdG8gcmVmQXR0ck5hbWVcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW2RvY1N0cmluZ10gQXR0cmlidXRlUHJvdG8gZG9jU3RyaW5nXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlfG51bGx9IFt0eXBlXSBBdHRyaWJ1dGVQcm90byB0eXBlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFtmXSBBdHRyaWJ1dGVQcm90byBmXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW2ldIEF0dHJpYnV0ZVByb3RvIGlcbiAgICAgICAgICogQHByb3BlcnR5IHtVaW50OEFycmF5fG51bGx9IFtzXSBBdHRyaWJ1dGVQcm90byBzXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JVGVuc29yUHJvdG98bnVsbH0gW3RdIEF0dHJpYnV0ZVByb3RvIHRcbiAgICAgICAgICogQHByb3BlcnR5IHtvbm54LklHcmFwaFByb3RvfG51bGx9IFtnXSBBdHRyaWJ1dGVQcm90byBnXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JU3BhcnNlVGVuc29yUHJvdG98bnVsbH0gW3NwYXJzZVRlbnNvcl0gQXR0cmlidXRlUHJvdG8gc3BhcnNlVGVuc29yXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JVHlwZVByb3RvfG51bGx9IFt0cF0gQXR0cmlidXRlUHJvdG8gdHBcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPnxudWxsfSBbZmxvYXRzXSBBdHRyaWJ1dGVQcm90byBmbG9hdHNcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyfExvbmc+fG51bGx9IFtpbnRzXSBBdHRyaWJ1dGVQcm90byBpbnRzXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPFVpbnQ4QXJyYXk+fG51bGx9IFtzdHJpbmdzXSBBdHRyaWJ1dGVQcm90byBzdHJpbmdzXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSVRlbnNvclByb3RvPnxudWxsfSBbdGVuc29yc10gQXR0cmlidXRlUHJvdG8gdGVuc29yc1xuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklHcmFwaFByb3RvPnxudWxsfSBbZ3JhcGhzXSBBdHRyaWJ1dGVQcm90byBncmFwaHNcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JU3BhcnNlVGVuc29yUHJvdG8+fG51bGx9IFtzcGFyc2VUZW5zb3JzXSBBdHRyaWJ1dGVQcm90byBzcGFyc2VUZW5zb3JzXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSVR5cGVQcm90bz58bnVsbH0gW3R5cGVQcm90b3NdIEF0dHJpYnV0ZVByb3RvIHR5cGVQcm90b3NcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgQXR0cmlidXRlUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhbiBBdHRyaWJ1dGVQcm90by5cbiAgICAgICAgICogQGltcGxlbWVudHMgSUF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge29ubnguSUF0dHJpYnV0ZVByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBBdHRyaWJ1dGVQcm90byhwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLmZsb2F0cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5pbnRzID0gW107XG4gICAgICAgICAgICB0aGlzLnN0cmluZ3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMudGVuc29ycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5ncmFwaHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc3BhcnNlVGVuc29ycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy50eXBlUHJvdG9zID0gW107XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dHJpYnV0ZVByb3RvIG5hbWUuXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gbmFtZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS5uYW1lID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXR0cmlidXRlUHJvdG8gcmVmQXR0ck5hbWUuXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gcmVmQXR0ck5hbWVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUucmVmQXR0ck5hbWUgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRyaWJ1dGVQcm90byBkb2NTdHJpbmcuXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gZG9jU3RyaW5nXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLmRvY1N0cmluZyA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dHJpYnV0ZVByb3RvIHR5cGUuXG4gICAgICAgICAqIEBtZW1iZXIge29ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZX0gdHlwZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS50eXBlID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXR0cmlidXRlUHJvdG8gZi5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBmXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLmYgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRyaWJ1dGVQcm90byBpLlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8TG9uZ30gaVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS5pID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dHJpYnV0ZVByb3RvIHMuXG4gICAgICAgICAqIEBtZW1iZXIge1VpbnQ4QXJyYXl9IHNcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUucyA9ICR1dGlsLm5ld0J1ZmZlcihbXSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dHJpYnV0ZVByb3RvIHQuXG4gICAgICAgICAqIEBtZW1iZXIge29ubnguSVRlbnNvclByb3RvfG51bGx8dW5kZWZpbmVkfSB0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLnQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRyaWJ1dGVQcm90byBnLlxuICAgICAgICAgKiBAbWVtYmVyIHtvbm54LklHcmFwaFByb3RvfG51bGx8dW5kZWZpbmVkfSBnXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLmcgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRyaWJ1dGVQcm90byBzcGFyc2VUZW5zb3IuXG4gICAgICAgICAqIEBtZW1iZXIge29ubnguSVNwYXJzZVRlbnNvclByb3RvfG51bGx8dW5kZWZpbmVkfSBzcGFyc2VUZW5zb3JcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUuc3BhcnNlVGVuc29yID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXR0cmlidXRlUHJvdG8gdHAuXG4gICAgICAgICAqIEBtZW1iZXIge29ubnguSVR5cGVQcm90b3xudWxsfHVuZGVmaW5lZH0gdHBcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUudHAgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRyaWJ1dGVQcm90byBmbG9hdHMuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXI+fSBmbG9hdHNcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUuZmxvYXRzID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXR0cmlidXRlUHJvdG8gaW50cy5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcnxMb25nPn0gaW50c1xuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLnByb3RvdHlwZS5pbnRzID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQXR0cmlidXRlUHJvdG8gc3RyaW5ncy5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPFVpbnQ4QXJyYXk+fSBzdHJpbmdzXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLnN0cmluZ3MgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRyaWJ1dGVQcm90byB0ZW5zb3JzLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JVGVuc29yUHJvdG8+fSB0ZW5zb3JzXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLnRlbnNvcnMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRyaWJ1dGVQcm90byBncmFwaHMuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklHcmFwaFByb3RvPn0gZ3JhcGhzXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLmdyYXBocyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dHJpYnV0ZVByb3RvIHNwYXJzZVRlbnNvcnMuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklTcGFyc2VUZW5zb3JQcm90bz59IHNwYXJzZVRlbnNvcnNcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUuc3BhcnNlVGVuc29ycyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dHJpYnV0ZVByb3RvIHR5cGVQcm90b3MuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklUeXBlUHJvdG8+fSB0eXBlUHJvdG9zXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8ucHJvdG90eXBlLnR5cGVQcm90b3MgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IEF0dHJpYnV0ZVByb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5BdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JQXR0cmlidXRlUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge29ubnguQXR0cmlidXRlUHJvdG99IEF0dHJpYnV0ZVByb3RvIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGVQcm90byhwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEF0dHJpYnV0ZVByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguQXR0cmlidXRlUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSUF0dHJpYnV0ZVByb3RvfSBtZXNzYWdlIEF0dHJpYnV0ZVByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLzEwKS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmYgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImZcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSA1ID0qLzIxKS5mbG9hdChtZXNzYWdlLmYpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiaVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDMsIHdpcmVUeXBlIDAgPSovMjQpLmludDY0KG1lc3NhZ2UuaSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJzXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNCwgd2lyZVR5cGUgMiA9Ki8zNCkuYnl0ZXMobWVzc2FnZS5zKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnQgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInRcIikpXG4gICAgICAgICAgICAgICAgJHJvb3Qub25ueC5UZW5zb3JQcm90by5lbmNvZGUobWVzc2FnZS50LCB3cml0ZXIudWludDMyKC8qIGlkIDUsIHdpcmVUeXBlIDIgPSovNDIpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5nICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJnXCIpKVxuICAgICAgICAgICAgICAgICRyb290Lm9ubnguR3JhcGhQcm90by5lbmNvZGUobWVzc2FnZS5nLCB3cml0ZXIudWludDMyKC8qIGlkIDYsIHdpcmVUeXBlIDIgPSovNTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5mbG9hdHMgIT0gbnVsbCAmJiBtZXNzYWdlLmZsb2F0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDcsIHdpcmVUeXBlIDIgPSovNTgpLmZvcmsoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZmxvYXRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuZmxvYXQobWVzc2FnZS5mbG9hdHNbaV0pO1xuICAgICAgICAgICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmludHMgIT0gbnVsbCAmJiBtZXNzYWdlLmludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA4LCB3aXJlVHlwZSAyID0qLzY2KS5mb3JrKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmludHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5pbnQ2NChtZXNzYWdlLmludHNbaV0pO1xuICAgICAgICAgICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnN0cmluZ3MgIT0gbnVsbCAmJiBtZXNzYWdlLnN0cmluZ3MubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5zdHJpbmdzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDksIHdpcmVUeXBlIDIgPSovNzQpLmJ5dGVzKG1lc3NhZ2Uuc3RyaW5nc1tpXSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ZW5zb3JzICE9IG51bGwgJiYgbWVzc2FnZS50ZW5zb3JzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudGVuc29ycy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5UZW5zb3JQcm90by5lbmNvZGUobWVzc2FnZS50ZW5zb3JzW2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDEwLCB3aXJlVHlwZSAyID0qLzgyKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZ3JhcGhzICE9IG51bGwgJiYgbWVzc2FnZS5ncmFwaHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5ncmFwaHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguR3JhcGhQcm90by5lbmNvZGUobWVzc2FnZS5ncmFwaHNbaV0sIHdyaXRlci51aW50MzIoLyogaWQgMTEsIHdpcmVUeXBlIDIgPSovOTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImRvY1N0cmluZ1wiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEzLCB3aXJlVHlwZSAyID0qLzEwNikuc3RyaW5nKG1lc3NhZ2UuZG9jU3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRwICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ0cFwiKSlcbiAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlR5cGVQcm90by5lbmNvZGUobWVzc2FnZS50cCwgd3JpdGVyLnVpbnQzMigvKiBpZCAxNCwgd2lyZVR5cGUgMiA9Ki8xMTQpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlUHJvdG9zICE9IG51bGwgJiYgbWVzc2FnZS50eXBlUHJvdG9zLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudHlwZVByb3Rvcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5UeXBlUHJvdG8uZW5jb2RlKG1lc3NhZ2UudHlwZVByb3Rvc1tpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCAxNSwgd2lyZVR5cGUgMiA9Ki8xMjIpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ0eXBlXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMjAsIHdpcmVUeXBlIDAgPSovMTYwKS5pbnQzMihtZXNzYWdlLnR5cGUpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucmVmQXR0ck5hbWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInJlZkF0dHJOYW1lXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMjEsIHdpcmVUeXBlIDIgPSovMTcwKS5zdHJpbmcobWVzc2FnZS5yZWZBdHRyTmFtZSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zcGFyc2VUZW5zb3IgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInNwYXJzZVRlbnNvclwiKSlcbiAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlNwYXJzZVRlbnNvclByb3RvLmVuY29kZShtZXNzYWdlLnNwYXJzZVRlbnNvciwgd3JpdGVyLnVpbnQzMigvKiBpZCAyMiwgd2lyZVR5cGUgMiA9Ki8xNzgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zcGFyc2VUZW5zb3JzICE9IG51bGwgJiYgbWVzc2FnZS5zcGFyc2VUZW5zb3JzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uuc3BhcnNlVGVuc29ycy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90by5lbmNvZGUobWVzc2FnZS5zcGFyc2VUZW5zb3JzW2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDIzLCB3aXJlVHlwZSAyID0qLzE4NikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBBdHRyaWJ1dGVQcm90byBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LkF0dHJpYnV0ZVByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklBdHRyaWJ1dGVQcm90b30gbWVzc2FnZSBBdHRyaWJ1dGVQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGFuIEF0dHJpYnV0ZVByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge29ubnguQXR0cmlidXRlUHJvdG99IEF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90bygpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMjE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVmQXR0ck5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMTM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG9jU3RyaW5nID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDIwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmYgPSByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmkgPSByZWFkZXIuaW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnMgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA1OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnQgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgNjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5nID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMjI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3BhcnNlVGVuc29yID0gJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDE0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRwID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmZsb2F0cyAmJiBtZXNzYWdlLmZsb2F0cy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmxvYXRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mbG9hdHMucHVzaChyZWFkZXIuZmxvYXQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZsb2F0cy5wdXNoKHJlYWRlci5mbG9hdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmludHMgJiYgbWVzc2FnZS5pbnRzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnRzLnB1c2gocmVhZGVyLmludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnRzLnB1c2gocmVhZGVyLmludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uuc3RyaW5ncyAmJiBtZXNzYWdlLnN0cmluZ3MubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN0cmluZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyaW5ncy5wdXNoKHJlYWRlci5ieXRlcygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAxMDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS50ZW5zb3JzICYmIG1lc3NhZ2UudGVuc29ycy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGVuc29ycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50ZW5zb3JzLnB1c2goJHJvb3Qub25ueC5UZW5zb3JQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAxMToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5ncmFwaHMgJiYgbWVzc2FnZS5ncmFwaHMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmdyYXBocyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ncmFwaHMucHVzaCgkcm9vdC5vbm54LkdyYXBoUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMjM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uuc3BhcnNlVGVuc29ycyAmJiBtZXNzYWdlLnNwYXJzZVRlbnNvcnMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNwYXJzZVRlbnNvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3BhcnNlVGVuc29ycy5wdXNoKCRyb290Lm9ubnguU3BhcnNlVGVuc29yUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMTU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UudHlwZVByb3RvcyAmJiBtZXNzYWdlLnR5cGVQcm90b3MubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGVQcm90b3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZVByb3Rvcy5wdXNoKCRyb290Lm9ubnguVHlwZVByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGFuIEF0dHJpYnV0ZVByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge29ubnguQXR0cmlidXRlUHJvdG99IEF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGFuIEF0dHJpYnV0ZVByb3RvIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIEF0dHJpYnV0ZVByb3RvLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UubmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucmVmQXR0ck5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicmVmQXR0ck5hbWVcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnJlZkF0dHJOYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicmVmQXR0ck5hbWU6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuZG9jU3RyaW5nKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZG9jU3RyaW5nOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidHlwZVwiKSlcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInR5cGU6IGVudW0gdmFsdWUgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5mICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImZcIikpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmYgIT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImY6IG51bWJlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaSkgJiYgIShtZXNzYWdlLmkgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmkuaGlnaCkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic1wiKSlcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnMgJiYgdHlwZW9mIG1lc3NhZ2Uucy5sZW5ndGggPT09IFwibnVtYmVyXCIgfHwgJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5zKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInM6IGJ1ZmZlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0XCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UZW5zb3JQcm90by52ZXJpZnkobWVzc2FnZS50KTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInQuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZ1wiKSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguR3JhcGhQcm90by52ZXJpZnkobWVzc2FnZS5nKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImcuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnNwYXJzZVRlbnNvciAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzcGFyc2VUZW5zb3JcIikpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlNwYXJzZVRlbnNvclByb3RvLnZlcmlmeShtZXNzYWdlLnNwYXJzZVRlbnNvcik7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzcGFyc2VUZW5zb3IuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRwICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRwXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UeXBlUHJvdG8udmVyaWZ5KG1lc3NhZ2UudHApO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidHAuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmZsb2F0cyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJmbG9hdHNcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5mbG9hdHMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJmbG9hdHM6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmZsb2F0cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmZsb2F0c1tpXSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImZsb2F0czogbnVtYmVyW10gZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmludHMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaW50c1wiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmludHMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbnRzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbnRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmludHNbaV0pICYmICEobWVzc2FnZS5pbnRzW2ldICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmludHNbaV0ubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5pbnRzW2ldLmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImludHM6IGludGVnZXJ8TG9uZ1tdIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zdHJpbmdzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInN0cmluZ3NcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5zdHJpbmdzKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nczogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uuc3RyaW5ncy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5zdHJpbmdzW2ldICYmIHR5cGVvZiBtZXNzYWdlLnN0cmluZ3NbaV0ubGVuZ3RoID09PSBcIm51bWJlclwiIHx8ICR1dGlsLmlzU3RyaW5nKG1lc3NhZ2Uuc3RyaW5nc1tpXSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nczogYnVmZmVyW10gZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRlbnNvcnMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidGVuc29yc1wiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnRlbnNvcnMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0ZW5zb3JzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS50ZW5zb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8udmVyaWZ5KG1lc3NhZ2UudGVuc29yc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInRlbnNvcnMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ncmFwaHMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZ3JhcGhzXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuZ3JhcGhzKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZ3JhcGhzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5ncmFwaHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLnZlcmlmeShtZXNzYWdlLmdyYXBoc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImdyYXBocy5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnNwYXJzZVRlbnNvcnMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic3BhcnNlVGVuc29yc1wiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnNwYXJzZVRlbnNvcnMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzcGFyc2VUZW5zb3JzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5zcGFyc2VUZW5zb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguU3BhcnNlVGVuc29yUHJvdG8udmVyaWZ5KG1lc3NhZ2Uuc3BhcnNlVGVuc29yc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInNwYXJzZVRlbnNvcnMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlUHJvdG9zICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInR5cGVQcm90b3NcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS50eXBlUHJvdG9zKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidHlwZVByb3RvczogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudHlwZVByb3Rvcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlR5cGVQcm90by52ZXJpZnkobWVzc2FnZS50eXBlUHJvdG9zW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidHlwZVByb3Rvcy5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIEF0dHJpYnV0ZVByb3RvIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguQXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LkF0dHJpYnV0ZVByb3RvfSBBdHRyaWJ1dGVQcm90b1xuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90bylcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90bygpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5uYW1lICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gU3RyaW5nKG9iamVjdC5uYW1lKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QucmVmQXR0ck5hbWUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnJlZkF0dHJOYW1lID0gU3RyaW5nKG9iamVjdC5yZWZBdHRyTmFtZSk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmRvY1N0cmluZyAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG9jU3RyaW5nID0gU3RyaW5nKG9iamVjdC5kb2NTdHJpbmcpO1xuICAgICAgICAgICAgc3dpdGNoIChvYmplY3QudHlwZSkge1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC50eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IG9iamVjdC50eXBlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiVU5ERUZJTkVEXCI6XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJGTE9BVFwiOlxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiSU5UXCI6XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTVFJJTkdcIjpcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlRFTlNPUlwiOlxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiR1JBUEhcIjpcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNQQVJTRV9URU5TT1JcIjpcbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMTE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiVFlQRV9QUk9UT1wiOlxuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAxMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJGTE9BVFNcIjpcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIklOVFNcIjpcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNUUklOR1NcIjpcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlRFTlNPUlNcIjpcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkdSQVBIU1wiOlxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAxMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTUEFSU0VfVEVOU09SU1wiOlxuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJUWVBFX1BST1RPU1wiOlxuICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAxNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuZiAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZiA9IE51bWJlcihvYmplY3QuZik7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgICAgICAgKG1lc3NhZ2UuaSA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5pKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmkgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaSA9IHBhcnNlSW50KG9iamVjdC5pLCAxMCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5pID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmkgPSBvYmplY3QuaTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmkgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaSA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuaS5sb3cgPj4+IDAsIG9iamVjdC5pLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnMgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5zID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAkdXRpbC5iYXNlNjQuZGVjb2RlKG9iamVjdC5zLCBtZXNzYWdlLnMgPSAkdXRpbC5uZXdCdWZmZXIoJHV0aWwuYmFzZTY0Lmxlbmd0aChvYmplY3QucykpLCAwKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYmplY3Qucy5sZW5ndGggPj0gMClcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zID0gb2JqZWN0LnM7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnQgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLnQ6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnQgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLmZyb21PYmplY3Qob2JqZWN0LnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5nICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5nICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5nOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5nID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLmZyb21PYmplY3Qob2JqZWN0LmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5zcGFyc2VUZW5zb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnNwYXJzZVRlbnNvciAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uc3BhcnNlVGVuc29yOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5zcGFyc2VUZW5zb3IgPSAkcm9vdC5vbm54LlNwYXJzZVRlbnNvclByb3RvLmZyb21PYmplY3Qob2JqZWN0LnNwYXJzZVRlbnNvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LnRwICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC50cCAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8udHA6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnRwID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uZnJvbU9iamVjdChvYmplY3QudHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5mbG9hdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmZsb2F0cykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLmZsb2F0czogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5mbG9hdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5mbG9hdHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmxvYXRzW2ldID0gTnVtYmVyKG9iamVjdC5mbG9hdHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5pbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5pbnRzKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uaW50czogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5pbnRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuaW50cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5pbnRzW2ldID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LmludHNbaV0pKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmludHNbaV0gPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmludHNbaV0gPSBwYXJzZUludChvYmplY3QuaW50c1tpXSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmludHNbaV0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmludHNbaV0gPSBvYmplY3QuaW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5pbnRzW2ldID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnRzW2ldID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5pbnRzW2ldLmxvdyA+Pj4gMCwgb2JqZWN0LmludHNbaV0uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3Quc3RyaW5ncykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3Quc3RyaW5ncykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLnN0cmluZ3M6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyaW5ncyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnN0cmluZ3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnN0cmluZ3NbaV0gPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAkdXRpbC5iYXNlNjQuZGVjb2RlKG9iamVjdC5zdHJpbmdzW2ldLCBtZXNzYWdlLnN0cmluZ3NbaV0gPSAkdXRpbC5uZXdCdWZmZXIoJHV0aWwuYmFzZTY0Lmxlbmd0aChvYmplY3Quc3RyaW5nc1tpXSkpLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob2JqZWN0LnN0cmluZ3NbaV0ubGVuZ3RoID49IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN0cmluZ3NbaV0gPSBvYmplY3Quc3RyaW5nc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QudGVuc29ycykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QudGVuc29ycykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLnRlbnNvcnM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudGVuc29ycyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnRlbnNvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudGVuc29yc1tpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkF0dHJpYnV0ZVByb3RvLnRlbnNvcnM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50ZW5zb3JzW2ldID0gJHJvb3Qub25ueC5UZW5zb3JQcm90by5mcm9tT2JqZWN0KG9iamVjdC50ZW5zb3JzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LmdyYXBocykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuZ3JhcGhzKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8uZ3JhcGhzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmdyYXBocyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmdyYXBocy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5ncmFwaHNbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5ncmFwaHM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ncmFwaHNbaV0gPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8uZnJvbU9iamVjdChvYmplY3QuZ3JhcGhzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LnNwYXJzZVRlbnNvcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnNwYXJzZVRlbnNvcnMpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5zcGFyc2VUZW5zb3JzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnNwYXJzZVRlbnNvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5zcGFyc2VUZW5zb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnNwYXJzZVRlbnNvcnNbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5BdHRyaWJ1dGVQcm90by5zcGFyc2VUZW5zb3JzOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3BhcnNlVGVuc29yc1tpXSA9ICRyb290Lm9ubnguU3BhcnNlVGVuc29yUHJvdG8uZnJvbU9iamVjdChvYmplY3Quc3BhcnNlVGVuc29yc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC50eXBlUHJvdG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC50eXBlUHJvdG9zKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8udHlwZVByb3RvczogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlUHJvdG9zID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QudHlwZVByb3Rvcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC50eXBlUHJvdG9zW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguQXR0cmlidXRlUHJvdG8udHlwZVByb3Rvczogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGVQcm90b3NbaV0gPSAkcm9vdC5vbm54LlR5cGVQcm90by5mcm9tT2JqZWN0KG9iamVjdC50eXBlUHJvdG9zW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGFuIEF0dHJpYnV0ZVByb3RvIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LkF0dHJpYnV0ZVByb3RvfSBtZXNzYWdlIEF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuZmxvYXRzID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0LmludHMgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3Quc3RyaW5ncyA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC50ZW5zb3JzID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0LmdyYXBocyA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC50eXBlUHJvdG9zID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0LnNwYXJzZVRlbnNvcnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIG9iamVjdC5mID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuaSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFwiMFwiIDogMDtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QucyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5zID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzICE9PSBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5zID0gJHV0aWwubmV3QnVmZmVyKG9iamVjdC5zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqZWN0LnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIG9iamVjdC5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9jU3RyaW5nID0gXCJcIjtcbiAgICAgICAgICAgICAgICBvYmplY3QudHAgPSBudWxsO1xuICAgICAgICAgICAgICAgIG9iamVjdC50eXBlID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gXCJVTkRFRklORURcIiA6IDA7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnJlZkF0dHJOYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICBvYmplY3Quc3BhcnNlVGVuc29yID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QubmFtZSA9IG1lc3NhZ2UubmFtZTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZlwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuZiA9IG9wdGlvbnMuanNvbiAmJiAhaXNGaW5pdGUobWVzc2FnZS5mKSA/IFN0cmluZyhtZXNzYWdlLmYpIDogbWVzc2FnZS5mO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpXCIpKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5pID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuaSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmkpIDogbWVzc2FnZS5pO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuaSkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5pLmxvdyA+Pj4gMCwgbWVzc2FnZS5pLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLmk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInNcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnMgPSBvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcgPyAkdXRpbC5iYXNlNjQuZW5jb2RlKG1lc3NhZ2UucywgMCwgbWVzc2FnZS5zLmxlbmd0aCkgOiBvcHRpb25zLmJ5dGVzID09PSBBcnJheSA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG1lc3NhZ2UucykgOiBtZXNzYWdlLnM7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnQgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLnRvT2JqZWN0KG1lc3NhZ2UudCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImdcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmcgPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8udG9PYmplY3QobWVzc2FnZS5nLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmZsb2F0cyAmJiBtZXNzYWdlLmZsb2F0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuZmxvYXRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmZsb2F0cy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmZsb2F0c1tqXSA9IG9wdGlvbnMuanNvbiAmJiAhaXNGaW5pdGUobWVzc2FnZS5mbG9hdHNbal0pID8gU3RyaW5nKG1lc3NhZ2UuZmxvYXRzW2pdKSA6IG1lc3NhZ2UuZmxvYXRzW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW50cyAmJiBtZXNzYWdlLmludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmludHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuaW50cy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmludHNbal0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuaW50c1tqXSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmludHNbal0pIDogbWVzc2FnZS5pbnRzW2pdO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuaW50c1tqXSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5pbnRzW2pdKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmludHNbal0ubG93ID4+PiAwLCBtZXNzYWdlLmludHNbal0uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UuaW50c1tqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnN0cmluZ3MgJiYgbWVzc2FnZS5zdHJpbmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5zdHJpbmdzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnN0cmluZ3MubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5zdHJpbmdzW2pdID0gb3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nID8gJHV0aWwuYmFzZTY0LmVuY29kZShtZXNzYWdlLnN0cmluZ3Nbal0sIDAsIG1lc3NhZ2Uuc3RyaW5nc1tqXS5sZW5ndGgpIDogb3B0aW9ucy5ieXRlcyA9PT0gQXJyYXkgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLnN0cmluZ3Nbal0pIDogbWVzc2FnZS5zdHJpbmdzW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVuc29ycyAmJiBtZXNzYWdlLnRlbnNvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnRlbnNvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UudGVuc29ycy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnRlbnNvcnNbal0gPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLnRvT2JqZWN0KG1lc3NhZ2UudGVuc29yc1tqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ncmFwaHMgJiYgbWVzc2FnZS5ncmFwaHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmdyYXBocyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5ncmFwaHMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5ncmFwaHNbal0gPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8udG9PYmplY3QobWVzc2FnZS5ncmFwaHNbal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9jU3RyaW5nID0gbWVzc2FnZS5kb2NTdHJpbmc7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50cCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0cFwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QudHAgPSAkcm9vdC5vbm54LlR5cGVQcm90by50b09iamVjdChtZXNzYWdlLnRwLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGVQcm90b3MgJiYgbWVzc2FnZS50eXBlUHJvdG9zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC50eXBlUHJvdG9zID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnR5cGVQcm90b3MubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC50eXBlUHJvdG9zW2pdID0gJHJvb3Qub25ueC5UeXBlUHJvdG8udG9PYmplY3QobWVzc2FnZS50eXBlUHJvdG9zW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidHlwZVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QudHlwZSA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/ICRyb290Lm9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZVttZXNzYWdlLnR5cGVdID09PSB1bmRlZmluZWQgPyBtZXNzYWdlLnR5cGUgOiAkcm9vdC5vbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGVbbWVzc2FnZS50eXBlXSA6IG1lc3NhZ2UudHlwZTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnJlZkF0dHJOYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInJlZkF0dHJOYW1lXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5yZWZBdHRyTmFtZSA9IG1lc3NhZ2UucmVmQXR0ck5hbWU7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zcGFyc2VUZW5zb3IgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic3BhcnNlVGVuc29yXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5zcGFyc2VUZW5zb3IgPSAkcm9vdC5vbm54LlNwYXJzZVRlbnNvclByb3RvLnRvT2JqZWN0KG1lc3NhZ2Uuc3BhcnNlVGVuc29yLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnNwYXJzZVRlbnNvcnMgJiYgbWVzc2FnZS5zcGFyc2VUZW5zb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5zcGFyc2VUZW5zb3JzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnNwYXJzZVRlbnNvcnMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5zcGFyc2VUZW5zb3JzW2pdID0gJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90by50b09iamVjdChtZXNzYWdlLnNwYXJzZVRlbnNvcnNbal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBBdHRyaWJ1dGVQcm90byB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGRlZmF1bHQgdHlwZSB1cmwgZm9yIEF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlVXJsUHJlZml4XSB5b3VyIGN1c3RvbSB0eXBlVXJsUHJlZml4KGRlZmF1bHQgXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWZhdWx0IHR5cGUgdXJsXG4gICAgICAgICAqL1xuICAgICAgICBBdHRyaWJ1dGVQcm90by5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9vbm54LkF0dHJpYnV0ZVByb3RvXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dHJpYnV0ZVR5cGUgZW51bS5cbiAgICAgICAgICogQG5hbWUgb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlXG4gICAgICAgICAqIEBlbnVtIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBVTkRFRklORUQ9MCBVTkRFRklORUQgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEZMT0FUPTEgRkxPQVQgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElOVD0yIElOVCB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gU1RSSU5HPTMgU1RSSU5HIHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBURU5TT1I9NCBURU5TT1IgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEdSQVBIPTUgR1JBUEggdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFNQQVJTRV9URU5TT1I9MTEgU1BBUlNFX1RFTlNPUiB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9QUk9UTz0xMyBUWVBFX1BST1RPIHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBGTE9BVFM9NiBGTE9BVFMgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElOVFM9NyBJTlRTIHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTVFJJTkdTPTggU1RSSU5HUyB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gVEVOU09SUz05IFRFTlNPUlMgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEdSQVBIUz0xMCBHUkFQSFMgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFNQQVJTRV9URU5TT1JTPTEyIFNQQVJTRV9URU5TT1JTIHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX1BST1RPUz0xNCBUWVBFX1BST1RPUyB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFswXSA9IFwiVU5ERUZJTkVEXCJdID0gMDtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzFdID0gXCJGTE9BVFwiXSA9IDE7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsyXSA9IFwiSU5UXCJdID0gMjtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzNdID0gXCJTVFJJTkdcIl0gPSAzO1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNF0gPSBcIlRFTlNPUlwiXSA9IDQ7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs1XSA9IFwiR1JBUEhcIl0gPSA1O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTFdID0gXCJTUEFSU0VfVEVOU09SXCJdID0gMTE7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxM10gPSBcIlRZUEVfUFJPVE9cIl0gPSAxMztcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzZdID0gXCJGTE9BVFNcIl0gPSA2O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbN10gPSBcIklOVFNcIl0gPSA3O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbOF0gPSBcIlNUUklOR1NcIl0gPSA4O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbOV0gPSBcIlRFTlNPUlNcIl0gPSA5O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTBdID0gXCJHUkFQSFNcIl0gPSAxMDtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzEyXSA9IFwiU1BBUlNFX1RFTlNPUlNcIl0gPSAxMjtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzE0XSA9IFwiVFlQRV9QUk9UT1NcIl0gPSAxNDtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgcmV0dXJuIEF0dHJpYnV0ZVByb3RvO1xuICAgIH0pKCk7XG5cbiAgICBvbm54LlZhbHVlSW5mb1Byb3RvID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgVmFsdWVJbmZvUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBpbnRlcmZhY2UgSVZhbHVlSW5mb1Byb3RvXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtuYW1lXSBWYWx1ZUluZm9Qcm90byBuYW1lXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JVHlwZVByb3RvfG51bGx9IFt0eXBlXSBWYWx1ZUluZm9Qcm90byB0eXBlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkb2NTdHJpbmddIFZhbHVlSW5mb1Byb3RvIGRvY1N0cmluZ1xuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBWYWx1ZUluZm9Qcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgVmFsdWVJbmZvUHJvdG8uXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElWYWx1ZUluZm9Qcm90b1xuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklWYWx1ZUluZm9Qcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gVmFsdWVJbmZvUHJvdG8ocHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWx1ZUluZm9Qcm90byBuYW1lLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBWYWx1ZUluZm9Qcm90by5wcm90b3R5cGUubmFtZSA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZhbHVlSW5mb1Byb3RvIHR5cGUuXG4gICAgICAgICAqIEBtZW1iZXIge29ubnguSVR5cGVQcm90b3xudWxsfHVuZGVmaW5lZH0gdHlwZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFZhbHVlSW5mb1Byb3RvLnByb3RvdHlwZS50eXBlID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsdWVJbmZvUHJvdG8gZG9jU3RyaW5nLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRvY1N0cmluZ1xuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFZhbHVlSW5mb1Byb3RvLnByb3RvdHlwZS5kb2NTdHJpbmcgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFZhbHVlSW5mb1Byb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5WYWx1ZUluZm9Qcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVmFsdWVJbmZvUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge29ubnguVmFsdWVJbmZvUHJvdG99IFZhbHVlSW5mb1Byb3RvIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBWYWx1ZUluZm9Qcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZUluZm9Qcm90byhwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFZhbHVlSW5mb1Byb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVmFsdWVJbmZvUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVZhbHVlSW5mb1Byb3RvfSBtZXNzYWdlIFZhbHVlSW5mb1Byb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgVmFsdWVJbmZvUHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLzEwKS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInR5cGVcIikpXG4gICAgICAgICAgICAgICAgJHJvb3Qub25ueC5UeXBlUHJvdG8uZW5jb2RlKG1lc3NhZ2UudHlwZSwgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLzE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAyID0qLzI2KS5zdHJpbmcobWVzc2FnZS5kb2NTdHJpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFZhbHVlSW5mb1Byb3RvIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVmFsdWVJbmZvUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVZhbHVlSW5mb1Byb3RvfSBtZXNzYWdlIFZhbHVlSW5mb1Byb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgVmFsdWVJbmZvUHJvdG8uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBWYWx1ZUluZm9Qcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlZhbHVlSW5mb1Byb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlZhbHVlSW5mb1Byb3RvfSBWYWx1ZUluZm9Qcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIFZhbHVlSW5mb1Byb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8oKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kb2NTdHJpbmcgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBWYWx1ZUluZm9Qcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlZhbHVlSW5mb1Byb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlZhbHVlSW5mb1Byb3RvfSBWYWx1ZUluZm9Qcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIFZhbHVlSW5mb1Byb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhIFZhbHVlSW5mb1Byb3RvIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIFZhbHVlSW5mb1Byb3RvLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UubmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UeXBlUHJvdG8udmVyaWZ5KG1lc3NhZ2UudHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0eXBlLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kb2NTdHJpbmcpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBWYWx1ZUluZm9Qcm90byBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlZhbHVlSW5mb1Byb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5WYWx1ZUluZm9Qcm90b30gVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICovXG4gICAgICAgIFZhbHVlSW5mb1Byb3RvLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8oKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QubmFtZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IFN0cmluZyhvYmplY3QubmFtZSk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnR5cGUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlZhbHVlSW5mb1Byb3RvLnR5cGU6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5mcm9tT2JqZWN0KG9iamVjdC50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuZG9jU3RyaW5nICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kb2NTdHJpbmcgPSBTdHJpbmcob2JqZWN0LmRvY1N0cmluZyk7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgVmFsdWVJbmZvUHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguVmFsdWVJbmZvUHJvdG99IG1lc3NhZ2UgVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBWYWx1ZUluZm9Qcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIG9iamVjdC5uYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICBvYmplY3QudHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRvY1N0cmluZyA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5uYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5hbWUgPSBtZXNzYWdlLm5hbWU7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by50b09iamVjdChtZXNzYWdlLnR5cGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9jU3RyaW5nID0gbWVzc2FnZS5kb2NTdHJpbmc7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIFZhbHVlSW5mb1Byb3RvIHRvIEpTT04uXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFZhbHVlSW5mb1Byb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQGZ1bmN0aW9uIGdldFR5cGVVcmxcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVmFsdWVJbmZvUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgICAgICovXG4gICAgICAgIFZhbHVlSW5mb1Byb3RvLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL29ubnguVmFsdWVJbmZvUHJvdG9cIjtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gVmFsdWVJbmZvUHJvdG87XG4gICAgfSkoKTtcblxuICAgIG9ubnguTm9kZVByb3RvID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgTm9kZVByb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAaW50ZXJmYWNlIElOb2RlUHJvdG9cbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48c3RyaW5nPnxudWxsfSBbaW5wdXRdIE5vZGVQcm90byBpbnB1dFxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxzdHJpbmc+fG51bGx9IFtvdXRwdXRdIE5vZGVQcm90byBvdXRwdXRcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW25hbWVdIE5vZGVQcm90byBuYW1lXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtvcFR5cGVdIE5vZGVQcm90byBvcFR5cGVcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW2RvbWFpbl0gTm9kZVByb3RvIGRvbWFpblxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklBdHRyaWJ1dGVQcm90bz58bnVsbH0gW2F0dHJpYnV0ZV0gTm9kZVByb3RvIGF0dHJpYnV0ZVxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZG9jU3RyaW5nXSBOb2RlUHJvdG8gZG9jU3RyaW5nXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE5vZGVQcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgTm9kZVByb3RvLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJTm9kZVByb3RvXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge29ubnguSU5vZGVQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gTm9kZVByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBbXTtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gW107XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZSA9IFtdO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb2RlUHJvdG8gaW5wdXQuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxzdHJpbmc+fSBpbnB1dFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8ucHJvdG90eXBlLmlucHV0ID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTm9kZVByb3RvIG91dHB1dC5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPHN0cmluZz59IG91dHB1dFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8ucHJvdG90eXBlLm91dHB1dCA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vZGVQcm90byBuYW1lLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTm9kZVByb3RvLnByb3RvdHlwZS5uYW1lID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTm9kZVByb3RvIG9wVHlwZS5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBvcFR5cGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTm9kZVByb3RvLnByb3RvdHlwZS5vcFR5cGUgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb2RlUHJvdG8gZG9tYWluLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRvbWFpblxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8ucHJvdG90eXBlLmRvbWFpbiA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vZGVQcm90byBhdHRyaWJ1dGUuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklBdHRyaWJ1dGVQcm90bz59IGF0dHJpYnV0ZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8ucHJvdG90eXBlLmF0dHJpYnV0ZSA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vZGVQcm90byBkb2NTdHJpbmcuXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gZG9jU3RyaW5nXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE5vZGVQcm90by5wcm90b3R5cGUuZG9jU3RyaW5nID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBOb2RlUHJvdG8gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JTm9kZVByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54Lk5vZGVQcm90b30gTm9kZVByb3RvIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm9kZVByb3RvKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgTm9kZVByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguTm9kZVByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JTm9kZVByb3RvfSBtZXNzYWdlIE5vZGVQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIE5vZGVQcm90by5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5wdXQgIT0gbnVsbCAmJiBtZXNzYWdlLmlucHV0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW5wdXQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuc3RyaW5nKG1lc3NhZ2UuaW5wdXRbaV0pO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uub3V0cHV0ICE9IG51bGwgJiYgbWVzc2FnZS5vdXRwdXQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5vdXRwdXQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8xOCkuc3RyaW5nKG1lc3NhZ2Uub3V0cHV0W2ldKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAyID0qLzI2KS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm9wVHlwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwib3BUeXBlXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNCwgd2lyZVR5cGUgMiA9Ki8zNCkuc3RyaW5nKG1lc3NhZ2Uub3BUeXBlKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmF0dHJpYnV0ZSAhPSBudWxsICYmIG1lc3NhZ2UuYXR0cmlidXRlLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuYXR0cmlidXRlLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54LkF0dHJpYnV0ZVByb3RvLmVuY29kZShtZXNzYWdlLmF0dHJpYnV0ZVtpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCA1LCB3aXJlVHlwZSAyID0qLzQyKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA2LCB3aXJlVHlwZSAyID0qLzUwKS5zdHJpbmcobWVzc2FnZS5kb2NTdHJpbmcpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJkb21haW5cIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA3LCB3aXJlVHlwZSAyID0qLzU4KS5zdHJpbmcobWVzc2FnZS5kb21haW4pO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIE5vZGVQcm90byBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54Lk5vZGVQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSU5vZGVQcm90b30gbWVzc2FnZSBOb2RlUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBOb2RlUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge29ubnguTm9kZVByb3RvfSBOb2RlUHJvdG9cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5Ob2RlUHJvdG8oKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5pbnB1dCAmJiBtZXNzYWdlLmlucHV0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnB1dCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnB1dC5wdXNoKHJlYWRlci5zdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5vdXRwdXQgJiYgbWVzc2FnZS5vdXRwdXQubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm91dHB1dCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5vdXRwdXQucHVzaChyZWFkZXIuc3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9wVHlwZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRvbWFpbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA1OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmF0dHJpYnV0ZSAmJiBtZXNzYWdlLmF0dHJpYnV0ZS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXR0cmlidXRlID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmF0dHJpYnV0ZS5wdXNoKCRyb290Lm9ubnguQXR0cmlidXRlUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgNjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kb2NTdHJpbmcgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBOb2RlUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge29ubnguTm9kZVByb3RvfSBOb2RlUHJvdG9cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgTm9kZVByb3RvIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5wdXQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaW5wdXRcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5pbnB1dCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImlucHV0OiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbnB1dC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmlucHV0W2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImlucHV0OiBzdHJpbmdbXSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uub3V0cHV0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm91dHB1dFwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLm91dHB1dCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm91dHB1dDogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2Uub3V0cHV0W2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm91dHB1dDogc3RyaW5nW10gZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UubmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uub3BUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm9wVHlwZVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2Uub3BUeXBlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwib3BUeXBlOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvbWFpbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRvbWFpbikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRvbWFpbjogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5hdHRyaWJ1dGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYXR0cmlidXRlXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuYXR0cmlidXRlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYXR0cmlidXRlOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5hdHRyaWJ1dGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5BdHRyaWJ1dGVQcm90by52ZXJpZnkobWVzc2FnZS5hdHRyaWJ1dGVbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJhdHRyaWJ1dGUuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kb2NTdHJpbmcpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkb2NTdHJpbmc6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBOb2RlUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Ob2RlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54Lk5vZGVQcm90b30gTm9kZVByb3RvXG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5Ob2RlUHJvdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguTm9kZVByb3RvKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmlucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5pbnB1dCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54Lk5vZGVQcm90by5pbnB1dDogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5pbnB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmlucHV0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlucHV0W2ldID0gU3RyaW5nKG9iamVjdC5pbnB1dFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0Lm91dHB1dCkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3Qub3V0cHV0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTm9kZVByb3RvLm91dHB1dDogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5vdXRwdXQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3V0cHV0W2ldID0gU3RyaW5nKG9iamVjdC5vdXRwdXRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5uYW1lICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gU3RyaW5nKG9iamVjdC5uYW1lKTtcbiAgICAgICAgICAgIGlmIChvYmplY3Qub3BUeXBlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5vcFR5cGUgPSBTdHJpbmcob2JqZWN0Lm9wVHlwZSk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmRvbWFpbiAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG9tYWluID0gU3RyaW5nKG9iamVjdC5kb21haW4pO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5hdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmF0dHJpYnV0ZSkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54Lk5vZGVQcm90by5hdHRyaWJ1dGU6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXR0cmlidXRlID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuYXR0cmlidXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmF0dHJpYnV0ZVtpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54Lk5vZGVQcm90by5hdHRyaWJ1dGU6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hdHRyaWJ1dGVbaV0gPSAkcm9vdC5vbm54LkF0dHJpYnV0ZVByb3RvLmZyb21PYmplY3Qob2JqZWN0LmF0dHJpYnV0ZVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5kb2NTdHJpbmcgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRvY1N0cmluZyA9IFN0cmluZyhvYmplY3QuZG9jU3RyaW5nKTtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBOb2RlUHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTm9kZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54Lk5vZGVQcm90b30gbWVzc2FnZSBOb2RlUHJvdG9cbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBOb2RlUHJvdG8udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuaW5wdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3Qub3V0cHV0ID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0LmF0dHJpYnV0ZSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm9wVHlwZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRvY1N0cmluZyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRvbWFpbiA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbnB1dCAmJiBtZXNzYWdlLmlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5pbnB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5pbnB1dC5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmlucHV0W2pdID0gbWVzc2FnZS5pbnB1dFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm91dHB1dCAmJiBtZXNzYWdlLm91dHB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3Qub3V0cHV0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLm91dHB1dC5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0Lm91dHB1dFtqXSA9IG1lc3NhZ2Uub3V0cHV0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5uYW1lID0gbWVzc2FnZS5uYW1lO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uub3BUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm9wVHlwZVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3Qub3BUeXBlID0gbWVzc2FnZS5vcFR5cGU7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5hdHRyaWJ1dGUgJiYgbWVzc2FnZS5hdHRyaWJ1dGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmF0dHJpYnV0ZSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5hdHRyaWJ1dGUubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5hdHRyaWJ1dGVbal0gPSAkcm9vdC5vbm54LkF0dHJpYnV0ZVByb3RvLnRvT2JqZWN0KG1lc3NhZ2UuYXR0cmlidXRlW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmRvY1N0cmluZyA9IG1lc3NhZ2UuZG9jU3RyaW5nO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9tYWluID0gbWVzc2FnZS5kb21haW47XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIE5vZGVQcm90byB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgTm9kZVByb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgTm9kZVByb3RvXG4gICAgICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk5vZGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVmYXVsdCB0eXBlIHVybFxuICAgICAgICAgKi9cbiAgICAgICAgTm9kZVByb3RvLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL29ubnguTm9kZVByb3RvXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIE5vZGVQcm90bztcbiAgICB9KSgpO1xuXG4gICAgb25ueC5UcmFpbmluZ0luZm9Qcm90byA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIFRyYWluaW5nSW5mb1Byb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAaW50ZXJmYWNlIElUcmFpbmluZ0luZm9Qcm90b1xuICAgICAgICAgKiBAcHJvcGVydHkge29ubnguSUdyYXBoUHJvdG98bnVsbH0gW2luaXRpYWxpemF0aW9uXSBUcmFpbmluZ0luZm9Qcm90byBpbml0aWFsaXphdGlvblxuICAgICAgICAgKiBAcHJvcGVydHkge29ubnguSUdyYXBoUHJvdG98bnVsbH0gW2FsZ29yaXRobV0gVHJhaW5pbmdJbmZvUHJvdG8gYWxnb3JpdGhtXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSVN0cmluZ1N0cmluZ0VudHJ5UHJvdG8+fG51bGx9IFtpbml0aWFsaXphdGlvbkJpbmRpbmddIFRyYWluaW5nSW5mb1Byb3RvIGluaXRpYWxpemF0aW9uQmluZGluZ1xuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPnxudWxsfSBbdXBkYXRlQmluZGluZ10gVHJhaW5pbmdJbmZvUHJvdG8gdXBkYXRlQmluZGluZ1xuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBUcmFpbmluZ0luZm9Qcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgVHJhaW5pbmdJbmZvUHJvdG8uXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElUcmFpbmluZ0luZm9Qcm90b1xuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklUcmFpbmluZ0luZm9Qcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gVHJhaW5pbmdJbmZvUHJvdG8ocHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXphdGlvbkJpbmRpbmcgPSBbXTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQmluZGluZyA9IFtdO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFpbmluZ0luZm9Qcm90byBpbml0aWFsaXphdGlvbi5cbiAgICAgICAgICogQG1lbWJlciB7b25ueC5JR3JhcGhQcm90b3xudWxsfHVuZGVmaW5lZH0gaW5pdGlhbGl6YXRpb25cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUcmFpbmluZ0luZm9Qcm90by5wcm90b3R5cGUuaW5pdGlhbGl6YXRpb24gPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFpbmluZ0luZm9Qcm90byBhbGdvcml0aG0uXG4gICAgICAgICAqIEBtZW1iZXIge29ubnguSUdyYXBoUHJvdG98bnVsbHx1bmRlZmluZWR9IGFsZ29yaXRobVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UcmFpbmluZ0luZm9Qcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFRyYWluaW5nSW5mb1Byb3RvLnByb3RvdHlwZS5hbGdvcml0aG0gPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFpbmluZ0luZm9Qcm90byBpbml0aWFsaXphdGlvbkJpbmRpbmcuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPn0gaW5pdGlhbGl6YXRpb25CaW5kaW5nXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRyYWluaW5nSW5mb1Byb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVHJhaW5pbmdJbmZvUHJvdG8ucHJvdG90eXBlLmluaXRpYWxpemF0aW9uQmluZGluZyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWluaW5nSW5mb1Byb3RvIHVwZGF0ZUJpbmRpbmcuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPn0gdXBkYXRlQmluZGluZ1xuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UcmFpbmluZ0luZm9Qcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFRyYWluaW5nSW5mb1Byb3RvLnByb3RvdHlwZS51cGRhdGVCaW5kaW5nID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBUcmFpbmluZ0luZm9Qcm90byBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVRyYWluaW5nSW5mb1Byb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRyYWluaW5nSW5mb1Byb3RvfSBUcmFpbmluZ0luZm9Qcm90byBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVHJhaW5pbmdJbmZvUHJvdG8uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHJhaW5pbmdJbmZvUHJvdG8ocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBUcmFpbmluZ0luZm9Qcm90byBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlRyYWluaW5nSW5mb1Byb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRyYWluaW5nSW5mb1Byb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklUcmFpbmluZ0luZm9Qcm90b30gbWVzc2FnZSBUcmFpbmluZ0luZm9Qcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIFRyYWluaW5nSW5mb1Byb3RvLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbml0aWFsaXphdGlvbiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiaW5pdGlhbGl6YXRpb25cIikpXG4gICAgICAgICAgICAgICAgJHJvb3Qub25ueC5HcmFwaFByb3RvLmVuY29kZShtZXNzYWdlLmluaXRpYWxpemF0aW9uLCB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5hbGdvcml0aG0gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImFsZ29yaXRobVwiKSlcbiAgICAgICAgICAgICAgICAkcm9vdC5vbm54LkdyYXBoUHJvdG8uZW5jb2RlKG1lc3NhZ2UuYWxnb3JpdGhtLCB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbml0aWFsaXphdGlvbkJpbmRpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmVuY29kZShtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZ1tpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAyID0qLzI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudXBkYXRlQmluZGluZyAhPSBudWxsICYmIG1lc3NhZ2UudXBkYXRlQmluZGluZy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnVwZGF0ZUJpbmRpbmcubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGUobWVzc2FnZS51cGRhdGVCaW5kaW5nW2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDQsIHdpcmVUeXBlIDIgPSovMzQpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVHJhaW5pbmdJbmZvUHJvdG8gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UcmFpbmluZ0luZm9Qcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UcmFpbmluZ0luZm9Qcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVHJhaW5pbmdJbmZvUHJvdG99IG1lc3NhZ2UgVHJhaW5pbmdJbmZvUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBUcmFpbmluZ0luZm9Qcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIFRyYWluaW5nSW5mb1Byb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge29ubnguVHJhaW5pbmdJbmZvUHJvdG99IFRyYWluaW5nSW5mb1Byb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgVHJhaW5pbmdJbmZvUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UcmFpbmluZ0luZm9Qcm90bygpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluaXRpYWxpemF0aW9uID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hbGdvcml0aG0gPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZyAmJiBtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5pdGlhbGl6YXRpb25CaW5kaW5nID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZy5wdXNoKCRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnVwZGF0ZUJpbmRpbmcgJiYgbWVzc2FnZS51cGRhdGVCaW5kaW5nLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51cGRhdGVCaW5kaW5nID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVwZGF0ZUJpbmRpbmcucHVzaCgkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBUcmFpbmluZ0luZm9Qcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRyYWluaW5nSW5mb1Byb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRyYWluaW5nSW5mb1Byb3RvfSBUcmFpbmluZ0luZm9Qcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIFRyYWluaW5nSW5mb1Byb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhIFRyYWluaW5nSW5mb1Byb3RvIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIFRyYWluaW5nSW5mb1Byb3RvLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmluaXRpYWxpemF0aW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImluaXRpYWxpemF0aW9uXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLnZlcmlmeShtZXNzYWdlLmluaXRpYWxpemF0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImluaXRpYWxpemF0aW9uLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5hbGdvcml0aG0gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYWxnb3JpdGhtXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLnZlcmlmeShtZXNzYWdlLmFsZ29yaXRobSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJhbGdvcml0aG0uXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpbml0aWFsaXphdGlvbkJpbmRpbmdcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5pbml0aWFsaXphdGlvbkJpbmRpbmcpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbml0aWFsaXphdGlvbkJpbmRpbmc6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5KG1lc3NhZ2UuaW5pdGlhbGl6YXRpb25CaW5kaW5nW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaW5pdGlhbGl6YXRpb25CaW5kaW5nLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudXBkYXRlQmluZGluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ1cGRhdGVCaW5kaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UudXBkYXRlQmluZGluZykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInVwZGF0ZUJpbmRpbmc6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnVwZGF0ZUJpbmRpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeShtZXNzYWdlLnVwZGF0ZUJpbmRpbmdbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ1cGRhdGVCaW5kaW5nLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBUcmFpbmluZ0luZm9Qcm90byBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRyYWluaW5nSW5mb1Byb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UcmFpbmluZ0luZm9Qcm90b30gVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgICAgICovXG4gICAgICAgIFRyYWluaW5nSW5mb1Byb3RvLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVHJhaW5pbmdJbmZvUHJvdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVHJhaW5pbmdJbmZvUHJvdG8oKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuaW5pdGlhbGl6YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmluaXRpYWxpemF0aW9uICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UcmFpbmluZ0luZm9Qcm90by5pbml0aWFsaXphdGlvbjogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5pdGlhbGl6YXRpb24gPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8uZnJvbU9iamVjdChvYmplY3QuaW5pdGlhbGl6YXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5hbGdvcml0aG0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmFsZ29yaXRobSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHJhaW5pbmdJbmZvUHJvdG8uYWxnb3JpdGhtOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5hbGdvcml0aG0gPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8uZnJvbU9iamVjdChvYmplY3QuYWxnb3JpdGhtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuaW5pdGlhbGl6YXRpb25CaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5pbml0aWFsaXphdGlvbkJpbmRpbmcpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UcmFpbmluZ0luZm9Qcm90by5pbml0aWFsaXphdGlvbkJpbmRpbmc6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5pdGlhbGl6YXRpb25CaW5kaW5nID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuaW5pdGlhbGl6YXRpb25CaW5kaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmluaXRpYWxpemF0aW9uQmluZGluZ1tpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlRyYWluaW5nSW5mb1Byb3RvLmluaXRpYWxpemF0aW9uQmluZGluZzogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluaXRpYWxpemF0aW9uQmluZGluZ1tpXSA9ICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5mcm9tT2JqZWN0KG9iamVjdC5pbml0aWFsaXphdGlvbkJpbmRpbmdbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QudXBkYXRlQmluZGluZykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QudXBkYXRlQmluZGluZykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlRyYWluaW5nSW5mb1Byb3RvLnVwZGF0ZUJpbmRpbmc6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudXBkYXRlQmluZGluZyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnVwZGF0ZUJpbmRpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudXBkYXRlQmluZGluZ1tpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlRyYWluaW5nSW5mb1Byb3RvLnVwZGF0ZUJpbmRpbmc6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51cGRhdGVCaW5kaW5nW2ldID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmZyb21PYmplY3Qob2JqZWN0LnVwZGF0ZUJpbmRpbmdbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBUcmFpbmluZ0luZm9Qcm90byBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UcmFpbmluZ0luZm9Qcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5UcmFpbmluZ0luZm9Qcm90b30gbWVzc2FnZSBUcmFpbmluZ0luZm9Qcm90b1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFRyYWluaW5nSW5mb1Byb3RvLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmluaXRpYWxpemF0aW9uQmluZGluZyA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC51cGRhdGVCaW5kaW5nID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIG9iamVjdC5pbml0aWFsaXphdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmFsZ29yaXRobSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbml0aWFsaXphdGlvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpbml0aWFsaXphdGlvblwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuaW5pdGlhbGl6YXRpb24gPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8udG9PYmplY3QobWVzc2FnZS5pbml0aWFsaXphdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5hbGdvcml0aG0gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYWxnb3JpdGhtXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5hbGdvcml0aG0gPSAkcm9vdC5vbm54LkdyYXBoUHJvdG8udG9PYmplY3QobWVzc2FnZS5hbGdvcml0aG0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5pdGlhbGl6YXRpb25CaW5kaW5nICYmIG1lc3NhZ2UuaW5pdGlhbGl6YXRpb25CaW5kaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5pbml0aWFsaXphdGlvbkJpbmRpbmcgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuaW5pdGlhbGl6YXRpb25CaW5kaW5nLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuaW5pdGlhbGl6YXRpb25CaW5kaW5nW2pdID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnRvT2JqZWN0KG1lc3NhZ2UuaW5pdGlhbGl6YXRpb25CaW5kaW5nW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnVwZGF0ZUJpbmRpbmcgJiYgbWVzc2FnZS51cGRhdGVCaW5kaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC51cGRhdGVCaW5kaW5nID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnVwZGF0ZUJpbmRpbmcubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC51cGRhdGVCaW5kaW5nW2pdID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnRvT2JqZWN0KG1lc3NhZ2UudXBkYXRlQmluZGluZ1tqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIFRyYWluaW5nSW5mb1Byb3RvIHRvIEpTT04uXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFRyYWluaW5nSW5mb1Byb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgICAgICogQGZ1bmN0aW9uIGdldFR5cGVVcmxcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHJhaW5pbmdJbmZvUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgICAgICovXG4gICAgICAgIFRyYWluaW5nSW5mb1Byb3RvLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL29ubnguVHJhaW5pbmdJbmZvUHJvdG9cIjtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gVHJhaW5pbmdJbmZvUHJvdG87XG4gICAgfSkoKTtcblxuICAgIG9ubnguTW9kZWxQcm90byA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIE1vZGVsUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBpbnRlcmZhY2UgSU1vZGVsUHJvdG9cbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ3xudWxsfSBbaXJWZXJzaW9uXSBNb2RlbFByb3RvIGlyVmVyc2lvblxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklPcGVyYXRvclNldElkUHJvdG8+fG51bGx9IFtvcHNldEltcG9ydF0gTW9kZWxQcm90byBvcHNldEltcG9ydFxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbcHJvZHVjZXJOYW1lXSBNb2RlbFByb3RvIHByb2R1Y2VyTmFtZVxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbcHJvZHVjZXJWZXJzaW9uXSBNb2RlbFByb3RvIHByb2R1Y2VyVmVyc2lvblxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZG9tYWluXSBNb2RlbFByb3RvIGRvbWFpblxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfG51bGx9IFttb2RlbFZlcnNpb25dIE1vZGVsUHJvdG8gbW9kZWxWZXJzaW9uXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkb2NTdHJpbmddIE1vZGVsUHJvdG8gZG9jU3RyaW5nXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JR3JhcGhQcm90b3xudWxsfSBbZ3JhcGhdIE1vZGVsUHJvdG8gZ3JhcGhcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JU3RyaW5nU3RyaW5nRW50cnlQcm90bz58bnVsbH0gW21ldGFkYXRhUHJvcHNdIE1vZGVsUHJvdG8gbWV0YWRhdGFQcm9wc1xuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklUcmFpbmluZ0luZm9Qcm90bz58bnVsbH0gW3RyYWluaW5nSW5mb10gTW9kZWxQcm90byB0cmFpbmluZ0luZm9cbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JRnVuY3Rpb25Qcm90bz58bnVsbH0gW2Z1bmN0aW9uc10gTW9kZWxQcm90byBmdW5jdGlvbnNcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTW9kZWxQcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgTW9kZWxQcm90by5cbiAgICAgICAgICogQGltcGxlbWVudHMgSU1vZGVsUHJvdG9cbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JTW9kZWxQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gTW9kZWxQcm90byhwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLm9wc2V0SW1wb3J0ID0gW107XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhUHJvcHMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMudHJhaW5pbmdJbmZvID0gW107XG4gICAgICAgICAgICB0aGlzLmZ1bmN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2RlbFByb3RvIGlyVmVyc2lvbi5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfExvbmd9IGlyVmVyc2lvblxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by5wcm90b3R5cGUuaXJWZXJzaW9uID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZGVsUHJvdG8gb3BzZXRJbXBvcnQuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklPcGVyYXRvclNldElkUHJvdG8+fSBvcHNldEltcG9ydFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by5wcm90b3R5cGUub3BzZXRJbXBvcnQgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2RlbFByb3RvIHByb2R1Y2VyTmFtZS5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBwcm9kdWNlck5hbWVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE1vZGVsUHJvdG8ucHJvdG90eXBlLnByb2R1Y2VyTmFtZSA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZGVsUHJvdG8gcHJvZHVjZXJWZXJzaW9uLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHByb2R1Y2VyVmVyc2lvblxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by5wcm90b3R5cGUucHJvZHVjZXJWZXJzaW9uID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW9kZWxQcm90byBkb21haW4uXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gZG9tYWluXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk1vZGVsUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLnByb3RvdHlwZS5kb21haW4gPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2RlbFByb3RvIG1vZGVsVmVyc2lvbi5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfExvbmd9IG1vZGVsVmVyc2lvblxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by5wcm90b3R5cGUubW9kZWxWZXJzaW9uID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZGVsUHJvdG8gZG9jU3RyaW5nLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRvY1N0cmluZ1xuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by5wcm90b3R5cGUuZG9jU3RyaW5nID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW9kZWxQcm90byBncmFwaC5cbiAgICAgICAgICogQG1lbWJlciB7b25ueC5JR3JhcGhQcm90b3xudWxsfHVuZGVmaW5lZH0gZ3JhcGhcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE1vZGVsUHJvdG8ucHJvdG90eXBlLmdyYXBoID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW9kZWxQcm90byBtZXRhZGF0YVByb3BzLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JU3RyaW5nU3RyaW5nRW50cnlQcm90bz59IG1ldGFkYXRhUHJvcHNcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE1vZGVsUHJvdG8ucHJvdG90eXBlLm1ldGFkYXRhUHJvcHMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2RlbFByb3RvIHRyYWluaW5nSW5mby5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSVRyYWluaW5nSW5mb1Byb3RvPn0gdHJhaW5pbmdJbmZvXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk1vZGVsUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLnByb3RvdHlwZS50cmFpbmluZ0luZm8gPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2RlbFByb3RvIGZ1bmN0aW9ucy5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSUZ1bmN0aW9uUHJvdG8+fSBmdW5jdGlvbnNcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE1vZGVsUHJvdG8ucHJvdG90eXBlLmZ1bmN0aW9ucyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgTW9kZWxQcm90byBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JTW9kZWxQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5Nb2RlbFByb3RvfSBNb2RlbFByb3RvIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vZGVsUHJvdG8ocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBNb2RlbFByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguTW9kZWxQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklNb2RlbFByb3RvfSBtZXNzYWdlIE1vZGVsUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pclZlcnNpb24gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImlyVmVyc2lvblwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDAgPSovOCkuaW50NjQobWVzc2FnZS5pclZlcnNpb24pO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucHJvZHVjZXJOYW1lICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJwcm9kdWNlck5hbWVcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLzE4KS5zdHJpbmcobWVzc2FnZS5wcm9kdWNlck5hbWUpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucHJvZHVjZXJWZXJzaW9uICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJwcm9kdWNlclZlcnNpb25cIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAyID0qLzI2KS5zdHJpbmcobWVzc2FnZS5wcm9kdWNlclZlcnNpb24pO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJkb21haW5cIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA0LCB3aXJlVHlwZSAyID0qLzM0KS5zdHJpbmcobWVzc2FnZS5kb21haW4pO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubW9kZWxWZXJzaW9uICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJtb2RlbFZlcnNpb25cIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA1LCB3aXJlVHlwZSAwID0qLzQwKS5pbnQ2NChtZXNzYWdlLm1vZGVsVmVyc2lvbik7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImRvY1N0cmluZ1wiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDYsIHdpcmVUeXBlIDIgPSovNTApLnN0cmluZyhtZXNzYWdlLmRvY1N0cmluZyk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ncmFwaCAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiZ3JhcGhcIikpXG4gICAgICAgICAgICAgICAgJHJvb3Qub25ueC5HcmFwaFByb3RvLmVuY29kZShtZXNzYWdlLmdyYXBoLCB3cml0ZXIudWludDMyKC8qIGlkIDcsIHdpcmVUeXBlIDIgPSovNTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5vcHNldEltcG9ydCAhPSBudWxsICYmIG1lc3NhZ2Uub3BzZXRJbXBvcnQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5vcHNldEltcG9ydC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5PcGVyYXRvclNldElkUHJvdG8uZW5jb2RlKG1lc3NhZ2Uub3BzZXRJbXBvcnRbaV0sIHdyaXRlci51aW50MzIoLyogaWQgOCwgd2lyZVR5cGUgMiA9Ki82NikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1ldGFkYXRhUHJvcHMgIT0gbnVsbCAmJiBtZXNzYWdlLm1ldGFkYXRhUHJvcHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5tZXRhZGF0YVByb3BzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZW5jb2RlKG1lc3NhZ2UubWV0YWRhdGFQcm9wc1tpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCAxNCwgd2lyZVR5cGUgMiA9Ki8xMTQpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50cmFpbmluZ0luZm8gIT0gbnVsbCAmJiBtZXNzYWdlLnRyYWluaW5nSW5mby5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnRyYWluaW5nSW5mby5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5UcmFpbmluZ0luZm9Qcm90by5lbmNvZGUobWVzc2FnZS50cmFpbmluZ0luZm9baV0sIHdyaXRlci51aW50MzIoLyogaWQgMjAsIHdpcmVUeXBlIDIgPSovMTYyKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZnVuY3Rpb25zICE9IG51bGwgJiYgbWVzc2FnZS5mdW5jdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5mdW5jdGlvbnMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguRnVuY3Rpb25Qcm90by5lbmNvZGUobWVzc2FnZS5mdW5jdGlvbnNbaV0sIHdyaXRlci51aW50MzIoLyogaWQgMjUsIHdpcmVUeXBlIDIgPSovMjAyKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIE1vZGVsUHJvdG8gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5Nb2RlbFByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk1vZGVsUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSU1vZGVsUHJvdG99IG1lc3NhZ2UgTW9kZWxQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIE1vZGVsUHJvdG8uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBNb2RlbFByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5Nb2RlbFByb3RvfSBNb2RlbFByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgTW9kZWxQcm90by5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54Lk1vZGVsUHJvdG8oKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pclZlcnNpb24gPSByZWFkZXIuaW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLm9wc2V0SW1wb3J0ICYmIG1lc3NhZ2Uub3BzZXRJbXBvcnQubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9wc2V0SW1wb3J0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9wc2V0SW1wb3J0LnB1c2goJHJvb3Qub25ueC5PcGVyYXRvclNldElkUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcm9kdWNlck5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcm9kdWNlclZlcnNpb24gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kb21haW4gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgNToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tb2RlbFZlcnNpb24gPSByZWFkZXIuaW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA2OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRvY1N0cmluZyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA3OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmdyYXBoID0gJHJvb3Qub25ueC5HcmFwaFByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMTQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UubWV0YWRhdGFQcm9wcyAmJiBtZXNzYWdlLm1ldGFkYXRhUHJvcHMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1ldGFkYXRhUHJvcHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWV0YWRhdGFQcm9wcy5wdXNoKCRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAyMDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS50cmFpbmluZ0luZm8gJiYgbWVzc2FnZS50cmFpbmluZ0luZm8ubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRyYWluaW5nSW5mbyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50cmFpbmluZ0luZm8ucHVzaCgkcm9vdC5vbm54LlRyYWluaW5nSW5mb1Byb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDI1OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmZ1bmN0aW9ucyAmJiBtZXNzYWdlLmZ1bmN0aW9ucy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZnVuY3Rpb25zID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZ1bmN0aW9ucy5wdXNoKCRyb290Lm9ubnguRnVuY3Rpb25Qcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIE1vZGVsUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54Lk1vZGVsUHJvdG99IE1vZGVsUHJvdG9cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhIE1vZGVsUHJvdG8gbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmlyVmVyc2lvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpclZlcnNpb25cIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5pclZlcnNpb24pICYmICEobWVzc2FnZS5pclZlcnNpb24gJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaXJWZXJzaW9uLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaXJWZXJzaW9uLmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaXJWZXJzaW9uOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm9wc2V0SW1wb3J0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm9wc2V0SW1wb3J0XCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2Uub3BzZXRJbXBvcnQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvcHNldEltcG9ydDogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uub3BzZXRJbXBvcnQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5PcGVyYXRvclNldElkUHJvdG8udmVyaWZ5KG1lc3NhZ2Uub3BzZXRJbXBvcnRbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvcHNldEltcG9ydC5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnByb2R1Y2VyTmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwcm9kdWNlck5hbWVcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnByb2R1Y2VyTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInByb2R1Y2VyTmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5wcm9kdWNlclZlcnNpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicHJvZHVjZXJWZXJzaW9uXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5wcm9kdWNlclZlcnNpb24pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJwcm9kdWNlclZlcnNpb246IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuZG9tYWluKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZG9tYWluOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1vZGVsVmVyc2lvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJtb2RlbFZlcnNpb25cIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5tb2RlbFZlcnNpb24pICYmICEobWVzc2FnZS5tb2RlbFZlcnNpb24gJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UubW9kZWxWZXJzaW9uLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UubW9kZWxWZXJzaW9uLmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibW9kZWxWZXJzaW9uOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRvY1N0cmluZykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ncmFwaCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJncmFwaFwiKSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguR3JhcGhQcm90by52ZXJpZnkobWVzc2FnZS5ncmFwaCk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJncmFwaC5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWV0YWRhdGFQcm9wcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJtZXRhZGF0YVByb3BzXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UubWV0YWRhdGFQcm9wcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm1ldGFkYXRhUHJvcHM6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm1ldGFkYXRhUHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnZlcmlmeShtZXNzYWdlLm1ldGFkYXRhUHJvcHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJtZXRhZGF0YVByb3BzLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHJhaW5pbmdJbmZvICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRyYWluaW5nSW5mb1wiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnRyYWluaW5nSW5mbykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInRyYWluaW5nSW5mbzogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudHJhaW5pbmdJbmZvLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVHJhaW5pbmdJbmZvUHJvdG8udmVyaWZ5KG1lc3NhZ2UudHJhaW5pbmdJbmZvW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidHJhaW5pbmdJbmZvLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZnVuY3Rpb25zICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImZ1bmN0aW9uc1wiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmZ1bmN0aW9ucykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImZ1bmN0aW9uczogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZnVuY3Rpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguRnVuY3Rpb25Qcm90by52ZXJpZnkobWVzc2FnZS5mdW5jdGlvbnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJmdW5jdGlvbnMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIE1vZGVsUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5Nb2RlbFByb3RvfSBNb2RlbFByb3RvXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguTW9kZWxQcm90bylcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5Nb2RlbFByb3RvKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmlyVmVyc2lvbiAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5pclZlcnNpb24gPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QuaXJWZXJzaW9uKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmlyVmVyc2lvbiA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pclZlcnNpb24gPSBwYXJzZUludChvYmplY3QuaXJWZXJzaW9uLCAxMCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5pclZlcnNpb24gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaXJWZXJzaW9uID0gb2JqZWN0LmlyVmVyc2lvbjtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmlyVmVyc2lvbiA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pclZlcnNpb24gPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LmlyVmVyc2lvbi5sb3cgPj4+IDAsIG9iamVjdC5pclZlcnNpb24uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIGlmIChvYmplY3Qub3BzZXRJbXBvcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0Lm9wc2V0SW1wb3J0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5vcHNldEltcG9ydDogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5vcHNldEltcG9ydCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lm9wc2V0SW1wb3J0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0Lm9wc2V0SW1wb3J0W2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5vcHNldEltcG9ydDogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9wc2V0SW1wb3J0W2ldID0gJHJvb3Qub25ueC5PcGVyYXRvclNldElkUHJvdG8uZnJvbU9iamVjdChvYmplY3Qub3BzZXRJbXBvcnRbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QucHJvZHVjZXJOYW1lICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5wcm9kdWNlck5hbWUgPSBTdHJpbmcob2JqZWN0LnByb2R1Y2VyTmFtZSk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnByb2R1Y2VyVmVyc2lvbiAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJvZHVjZXJWZXJzaW9uID0gU3RyaW5nKG9iamVjdC5wcm9kdWNlclZlcnNpb24pO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5kb21haW4gIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRvbWFpbiA9IFN0cmluZyhvYmplY3QuZG9tYWluKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QubW9kZWxWZXJzaW9uICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgICAgICAgIChtZXNzYWdlLm1vZGVsVmVyc2lvbiA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5tb2RlbFZlcnNpb24pKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QubW9kZWxWZXJzaW9uID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1vZGVsVmVyc2lvbiA9IHBhcnNlSW50KG9iamVjdC5tb2RlbFZlcnNpb24sIDEwKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0Lm1vZGVsVmVyc2lvbiA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tb2RlbFZlcnNpb24gPSBvYmplY3QubW9kZWxWZXJzaW9uO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QubW9kZWxWZXJzaW9uID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1vZGVsVmVyc2lvbiA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QubW9kZWxWZXJzaW9uLmxvdyA+Pj4gMCwgb2JqZWN0Lm1vZGVsVmVyc2lvbi5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5kb2NTdHJpbmcgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRvY1N0cmluZyA9IFN0cmluZyhvYmplY3QuZG9jU3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuZ3JhcGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmdyYXBoICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Nb2RlbFByb3RvLmdyYXBoOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5ncmFwaCA9ICRyb290Lm9ubnguR3JhcGhQcm90by5mcm9tT2JqZWN0KG9iamVjdC5ncmFwaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0Lm1ldGFkYXRhUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0Lm1ldGFkYXRhUHJvcHMpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Nb2RlbFByb3RvLm1ldGFkYXRhUHJvcHM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UubWV0YWRhdGFQcm9wcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lm1ldGFkYXRhUHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QubWV0YWRhdGFQcm9wc1tpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54Lk1vZGVsUHJvdG8ubWV0YWRhdGFQcm9wczogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1ldGFkYXRhUHJvcHNbaV0gPSAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZnJvbU9iamVjdChvYmplY3QubWV0YWRhdGFQcm9wc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC50cmFpbmluZ0luZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnRyYWluaW5nSW5mbykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54Lk1vZGVsUHJvdG8udHJhaW5pbmdJbmZvOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnRyYWluaW5nSW5mbyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnRyYWluaW5nSW5mby5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC50cmFpbmluZ0luZm9baV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5Nb2RlbFByb3RvLnRyYWluaW5nSW5mbzogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRyYWluaW5nSW5mb1tpXSA9ICRyb290Lm9ubnguVHJhaW5pbmdJbmZvUHJvdG8uZnJvbU9iamVjdChvYmplY3QudHJhaW5pbmdJbmZvW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LmZ1bmN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuZnVuY3Rpb25zKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguTW9kZWxQcm90by5mdW5jdGlvbnM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZnVuY3Rpb25zID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuZnVuY3Rpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmZ1bmN0aW9uc1tpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54Lk1vZGVsUHJvdG8uZnVuY3Rpb25zOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZnVuY3Rpb25zW2ldID0gJHJvb3Qub25ueC5GdW5jdGlvblByb3RvLmZyb21PYmplY3Qob2JqZWN0LmZ1bmN0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIE1vZGVsUHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguTW9kZWxQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5Nb2RlbFByb3RvfSBtZXNzYWdlIE1vZGVsUHJvdG9cbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm9wc2V0SW1wb3J0ID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm1ldGFkYXRhUHJvcHMgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3QudHJhaW5pbmdJbmZvID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0LmZ1bmN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmlyVmVyc2lvbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IGxvbmcudG9TdHJpbmcoKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IGxvbmcudG9OdW1iZXIoKSA6IGxvbmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5pclZlcnNpb24gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBcIjBcIiA6IDA7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnByb2R1Y2VyTmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnByb2R1Y2VyVmVyc2lvbiA9IFwiXCI7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRvbWFpbiA9IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5tb2RlbFZlcnNpb24gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QubW9kZWxWZXJzaW9uID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gXCIwXCIgOiAwO1xuICAgICAgICAgICAgICAgIG9iamVjdC5kb2NTdHJpbmcgPSBcIlwiO1xuICAgICAgICAgICAgICAgIG9iamVjdC5ncmFwaCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pclZlcnNpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaXJWZXJzaW9uXCIpKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5pclZlcnNpb24gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5pclZlcnNpb24gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5pclZlcnNpb24pIDogbWVzc2FnZS5pclZlcnNpb247XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuaXJWZXJzaW9uID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLmlyVmVyc2lvbikgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5pclZlcnNpb24ubG93ID4+PiAwLCBtZXNzYWdlLmlyVmVyc2lvbi5oaWdoID4+PiAwKS50b051bWJlcigpIDogbWVzc2FnZS5pclZlcnNpb247XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5wcm9kdWNlck5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicHJvZHVjZXJOYW1lXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5wcm9kdWNlck5hbWUgPSBtZXNzYWdlLnByb2R1Y2VyTmFtZTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnByb2R1Y2VyVmVyc2lvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwcm9kdWNlclZlcnNpb25cIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnByb2R1Y2VyVmVyc2lvbiA9IG1lc3NhZ2UucHJvZHVjZXJWZXJzaW9uO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9tYWluID0gbWVzc2FnZS5kb21haW47XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tb2RlbFZlcnNpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibW9kZWxWZXJzaW9uXCIpKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5tb2RlbFZlcnNpb24gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5tb2RlbFZlcnNpb24gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5tb2RlbFZlcnNpb24pIDogbWVzc2FnZS5tb2RlbFZlcnNpb247XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QubW9kZWxWZXJzaW9uID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLm1vZGVsVmVyc2lvbikgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5tb2RlbFZlcnNpb24ubG93ID4+PiAwLCBtZXNzYWdlLm1vZGVsVmVyc2lvbi5oaWdoID4+PiAwKS50b051bWJlcigpIDogbWVzc2FnZS5tb2RlbFZlcnNpb247XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5kb2NTdHJpbmcgPSBtZXNzYWdlLmRvY1N0cmluZztcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmdyYXBoICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImdyYXBoXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5ncmFwaCA9ICRyb290Lm9ubnguR3JhcGhQcm90by50b09iamVjdChtZXNzYWdlLmdyYXBoLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm9wc2V0SW1wb3J0ICYmIG1lc3NhZ2Uub3BzZXRJbXBvcnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm9wc2V0SW1wb3J0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLm9wc2V0SW1wb3J0Lmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3Qub3BzZXRJbXBvcnRbal0gPSAkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by50b09iamVjdChtZXNzYWdlLm9wc2V0SW1wb3J0W2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1ldGFkYXRhUHJvcHMgJiYgbWVzc2FnZS5tZXRhZGF0YVByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5tZXRhZGF0YVByb3BzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLm1ldGFkYXRhUHJvcHMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5tZXRhZGF0YVByb3BzW2pdID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnRvT2JqZWN0KG1lc3NhZ2UubWV0YWRhdGFQcm9wc1tqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50cmFpbmluZ0luZm8gJiYgbWVzc2FnZS50cmFpbmluZ0luZm8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnRyYWluaW5nSW5mbyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS50cmFpbmluZ0luZm8ubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC50cmFpbmluZ0luZm9bal0gPSAkcm9vdC5vbm54LlRyYWluaW5nSW5mb1Byb3RvLnRvT2JqZWN0KG1lc3NhZ2UudHJhaW5pbmdJbmZvW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmZ1bmN0aW9ucyAmJiBtZXNzYWdlLmZ1bmN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuZnVuY3Rpb25zID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmZ1bmN0aW9ucy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmZ1bmN0aW9uc1tqXSA9ICRyb290Lm9ubnguRnVuY3Rpb25Qcm90by50b09iamVjdChtZXNzYWdlLmZ1bmN0aW9uc1tqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIE1vZGVsUHJvdG8gdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgTW9kZWxQcm90b1xuICAgICAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5Nb2RlbFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlVXJsUHJlZml4XSB5b3VyIGN1c3RvbSB0eXBlVXJsUHJlZml4KGRlZmF1bHQgXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWZhdWx0IHR5cGUgdXJsXG4gICAgICAgICAqL1xuICAgICAgICBNb2RlbFByb3RvLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL29ubnguTW9kZWxQcm90b1wiO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBNb2RlbFByb3RvO1xuICAgIH0pKCk7XG5cbiAgICBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAaW50ZXJmYWNlIElTdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtrZXldIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8ga2V5XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFt2YWx1ZV0gU3RyaW5nU3RyaW5nRW50cnlQcm90byB2YWx1ZVxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBTdHJpbmdTdHJpbmdFbnRyeVByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RyaW5nU3RyaW5nRW50cnlQcm90byBrZXkuXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30ga2V5XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLnByb3RvdHlwZS5rZXkgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIHZhbHVlLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHZhbHVlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLnByb3RvdHlwZS52YWx1ZSA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgU3RyaW5nU3RyaW5nRW50cnlQcm90byBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JU3RyaW5nU3RyaW5nRW50cnlQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvfSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8ocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvfSBtZXNzYWdlIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5rZXkgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImtleVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLnN0cmluZyhtZXNzYWdlLmtleSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwidmFsdWVcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLzE4KS5zdHJpbmcobWVzc2FnZS52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgU3RyaW5nU3RyaW5nRW50cnlQcm90byBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JU3RyaW5nU3RyaW5nRW50cnlQcm90b30gbWVzc2FnZSBTdHJpbmdTdHJpbmdFbnRyeVByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG99IFN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90bygpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtleSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgU3RyaW5nU3RyaW5nRW50cnlQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge29ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b30gU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgU3RyaW5nU3RyaW5nRW50cnlQcm90byBtZXNzYWdlLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uua2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2Uua2V5KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwia2V5OiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS52YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInZhbHVlOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgU3RyaW5nU3RyaW5nRW50cnlQcm90byBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG99IFN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICovXG4gICAgICAgIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8oKTtcbiAgICAgICAgICAgIGlmIChvYmplY3Qua2V5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5rZXkgPSBTdHJpbmcob2JqZWN0LmtleSk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnZhbHVlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZSA9IFN0cmluZyhvYmplY3QudmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvfSBtZXNzYWdlIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBTdHJpbmdTdHJpbmdFbnRyeVByb3RvLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmtleSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmtleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJrZXlcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmtleSA9IG1lc3NhZ2Uua2V5O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidmFsdWVcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gbWVzc2FnZS52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgU3RyaW5nU3RyaW5nRW50cnlQcm90byB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBTdHJpbmdTdHJpbmdFbnRyeVByb3RvXG4gICAgICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgICAgICovXG4gICAgICAgIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG8uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvb25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIFN0cmluZ1N0cmluZ0VudHJ5UHJvdG87XG4gICAgfSkoKTtcblxuICAgIG9ubnguVGVuc29yQW5ub3RhdGlvbiA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIFRlbnNvckFubm90YXRpb24uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBpbnRlcmZhY2UgSVRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW3RlbnNvck5hbWVdIFRlbnNvckFubm90YXRpb24gdGVuc29yTmFtZVxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPnxudWxsfSBbcXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc10gVGVuc29yQW5ub3RhdGlvbiBxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFRlbnNvckFubm90YXRpb24uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFRlbnNvckFubm90YXRpb24uXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElUZW5zb3JBbm5vdGF0aW9uXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvckFubm90YXRpb249fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFRlbnNvckFubm90YXRpb24ocHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhpcy5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzID0gW107XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlbnNvckFubm90YXRpb24gdGVuc29yTmFtZS5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSB0ZW5zb3JOYW1lXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JBbm5vdGF0aW9uLnByb3RvdHlwZS50ZW5zb3JOYW1lID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yQW5ub3RhdGlvbiBxdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JU3RyaW5nU3RyaW5nRW50cnlQcm90bz59IHF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yQW5ub3RhdGlvblxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvckFubm90YXRpb24ucHJvdG90eXBlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFRlbnNvckFubm90YXRpb24gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvckFubm90YXRpb249fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yQW5ub3RhdGlvbn0gVGVuc29yQW5ub3RhdGlvbiBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yQW5ub3RhdGlvbi5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3JBbm5vdGF0aW9uKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVGVuc29yQW5ub3RhdGlvbiBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlRlbnNvckFubm90YXRpb24udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yQW5ub3RhdGlvblxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yQW5ub3RhdGlvbn0gbWVzc2FnZSBUZW5zb3JBbm5vdGF0aW9uIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yQW5ub3RhdGlvbi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVuc29yTmFtZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwidGVuc29yTmFtZVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLnN0cmluZyhtZXNzYWdlLnRlbnNvck5hbWUpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyAhPSBudWxsICYmIG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5lbmNvZGUobWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVGVuc29yQW5ub3RhdGlvbiBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlRlbnNvckFubm90YXRpb24udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yQW5ub3RhdGlvblxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yQW5ub3RhdGlvbn0gbWVzc2FnZSBUZW5zb3JBbm5vdGF0aW9uIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yQW5ub3RhdGlvbi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIFRlbnNvckFubm90YXRpb24gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JBbm5vdGF0aW9uXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvckFubm90YXRpb259IFRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JBbm5vdGF0aW9uLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVGVuc29yQW5ub3RhdGlvbigpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRlbnNvck5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzICYmIG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLnB1c2goJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgVGVuc29yQW5ub3RhdGlvbiBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yQW5ub3RhdGlvbn0gVGVuc29yQW5ub3RhdGlvblxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvckFubm90YXRpb24uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgVGVuc29yQW5ub3RhdGlvbiBtZXNzYWdlLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvckFubm90YXRpb24udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVuc29yTmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JOYW1lXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS50ZW5zb3JOYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidGVuc29yTmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lczogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5KG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIFRlbnNvckFubm90YXRpb24gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JBbm5vdGF0aW9uXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JBbm5vdGF0aW9ufSBUZW5zb3JBbm5vdGF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JBbm5vdGF0aW9uLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVGVuc29yQW5ub3RhdGlvbilcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UZW5zb3JBbm5vdGF0aW9uKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnRlbnNvck5hbWUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnRlbnNvck5hbWUgPSBTdHJpbmcob2JqZWN0LnRlbnNvck5hbWUpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yQW5ub3RhdGlvbi5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JBbm5vdGF0aW9uLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW2ldID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmZyb21PYmplY3Qob2JqZWN0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBUZW5zb3JBbm5vdGF0aW9uIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yQW5ub3RhdGlvbn0gbWVzc2FnZSBUZW5zb3JBbm5vdGF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yQW5ub3RhdGlvbi50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cylcbiAgICAgICAgICAgICAgICBvYmplY3QucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyA9IFtdO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnRlbnNvck5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVuc29yTmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JOYW1lXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC50ZW5zb3JOYW1lID0gbWVzc2FnZS50ZW5zb3JOYW1lO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcyAmJiBtZXNzYWdlLnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UucXVhbnRQYXJhbWV0ZXJUZW5zb3JOYW1lcy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnF1YW50UGFyYW1ldGVyVGVuc29yTmFtZXNbal0gPSAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udG9PYmplY3QobWVzc2FnZS5xdWFudFBhcmFtZXRlclRlbnNvck5hbWVzW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgVGVuc29yQW5ub3RhdGlvbiB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvckFubm90YXRpb24ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBUZW5zb3JBbm5vdGF0aW9uXG4gICAgICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvckFubm90YXRpb25cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvckFubm90YXRpb24uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvb25ueC5UZW5zb3JBbm5vdGF0aW9uXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIFRlbnNvckFubm90YXRpb247XG4gICAgfSkoKTtcblxuICAgIG9ubnguR3JhcGhQcm90byA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIEdyYXBoUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBpbnRlcmZhY2UgSUdyYXBoUHJvdG9cbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JTm9kZVByb3RvPnxudWxsfSBbbm9kZV0gR3JhcGhQcm90byBub2RlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtuYW1lXSBHcmFwaFByb3RvIG5hbWVcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JVGVuc29yUHJvdG8+fG51bGx9IFtpbml0aWFsaXplcl0gR3JhcGhQcm90byBpbml0aWFsaXplclxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklTcGFyc2VUZW5zb3JQcm90bz58bnVsbH0gW3NwYXJzZUluaXRpYWxpemVyXSBHcmFwaFByb3RvIHNwYXJzZUluaXRpYWxpemVyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkb2NTdHJpbmddIEdyYXBoUHJvdG8gZG9jU3RyaW5nXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSVZhbHVlSW5mb1Byb3RvPnxudWxsfSBbaW5wdXRdIEdyYXBoUHJvdG8gaW5wdXRcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48b25ueC5JVmFsdWVJbmZvUHJvdG8+fG51bGx9IFtvdXRwdXRdIEdyYXBoUHJvdG8gb3V0cHV0XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSVZhbHVlSW5mb1Byb3RvPnxudWxsfSBbdmFsdWVJbmZvXSBHcmFwaFByb3RvIHZhbHVlSW5mb1xuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklUZW5zb3JBbm5vdGF0aW9uPnxudWxsfSBbcXVhbnRpemF0aW9uQW5ub3RhdGlvbl0gR3JhcGhQcm90byBxdWFudGl6YXRpb25Bbm5vdGF0aW9uXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEdyYXBoUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIEdyYXBoUHJvdG8uXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElHcmFwaFByb3RvXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge29ubnguSUdyYXBoUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEdyYXBoUHJvdG8ocHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhpcy5ub2RlID0gW107XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVyID0gW107XG4gICAgICAgICAgICB0aGlzLnNwYXJzZUluaXRpYWxpemVyID0gW107XG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gW107XG4gICAgICAgICAgICB0aGlzLm91dHB1dCA9IFtdO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUluZm8gPSBbXTtcbiAgICAgICAgICAgIHRoaXMucXVhbnRpemF0aW9uQW5ub3RhdGlvbiA9IFtdO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHcmFwaFByb3RvIG5vZGUuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklOb2RlUHJvdG8+fSBub2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBHcmFwaFByb3RvLnByb3RvdHlwZS5ub2RlID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR3JhcGhQcm90byBuYW1lLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8ucHJvdG90eXBlLm5hbWUgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHcmFwaFByb3RvIGluaXRpYWxpemVyLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JVGVuc29yUHJvdG8+fSBpbml0aWFsaXplclxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgR3JhcGhQcm90by5wcm90b3R5cGUuaW5pdGlhbGl6ZXIgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHcmFwaFByb3RvIHNwYXJzZUluaXRpYWxpemVyLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JU3BhcnNlVGVuc29yUHJvdG8+fSBzcGFyc2VJbml0aWFsaXplclxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgR3JhcGhQcm90by5wcm90b3R5cGUuc3BhcnNlSW5pdGlhbGl6ZXIgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHcmFwaFByb3RvIGRvY1N0cmluZy5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBkb2NTdHJpbmdcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8ucHJvdG90eXBlLmRvY1N0cmluZyA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdyYXBoUHJvdG8gaW5wdXQuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljxvbm54LklWYWx1ZUluZm9Qcm90bz59IGlucHV0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBHcmFwaFByb3RvLnByb3RvdHlwZS5pbnB1dCA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdyYXBoUHJvdG8gb3V0cHV0LlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JVmFsdWVJbmZvUHJvdG8+fSBvdXRwdXRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8ucHJvdG90eXBlLm91dHB1dCA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdyYXBoUHJvdG8gdmFsdWVJbmZvLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JVmFsdWVJbmZvUHJvdG8+fSB2YWx1ZUluZm9cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8ucHJvdG90eXBlLnZhbHVlSW5mbyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdyYXBoUHJvdG8gcXVhbnRpemF0aW9uQW5ub3RhdGlvbi5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSVRlbnNvckFubm90YXRpb24+fSBxdWFudGl6YXRpb25Bbm5vdGF0aW9uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBHcmFwaFByb3RvLnByb3RvdHlwZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBHcmFwaFByb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklHcmFwaFByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LkdyYXBoUHJvdG99IEdyYXBoUHJvdG8gaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgR3JhcGhQcm90byhwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEdyYXBoUHJvdG8gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5HcmFwaFByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSUdyYXBoUHJvdG99IG1lc3NhZ2UgR3JhcGhQcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5vZGUgIT0gbnVsbCAmJiBtZXNzYWdlLm5vZGUubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5ub2RlLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54Lk5vZGVQcm90by5lbmNvZGUobWVzc2FnZS5ub2RlW2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5uYW1lICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJuYW1lXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8xOCkuc3RyaW5nKG1lc3NhZ2UubmFtZSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbml0aWFsaXplciAhPSBudWxsICYmIG1lc3NhZ2UuaW5pdGlhbGl6ZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbml0aWFsaXplci5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5UZW5zb3JQcm90by5lbmNvZGUobWVzc2FnZS5pbml0aWFsaXplcltpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCA1LCB3aXJlVHlwZSAyID0qLzQyKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxMCwgd2lyZVR5cGUgMiA9Ki84Mikuc3RyaW5nKG1lc3NhZ2UuZG9jU3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmlucHV0ICE9IG51bGwgJiYgbWVzc2FnZS5pbnB1dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmlucHV0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLmVuY29kZShtZXNzYWdlLmlucHV0W2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDExLCB3aXJlVHlwZSAyID0qLzkwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uub3V0cHV0ICE9IG51bGwgJiYgbWVzc2FnZS5vdXRwdXQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5vdXRwdXQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8uZW5jb2RlKG1lc3NhZ2Uub3V0cHV0W2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDEyLCB3aXJlVHlwZSAyID0qLzk4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWVJbmZvICE9IG51bGwgJiYgbWVzc2FnZS52YWx1ZUluZm8ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS52YWx1ZUluZm8ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8uZW5jb2RlKG1lc3NhZ2UudmFsdWVJbmZvW2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDEzLCB3aXJlVHlwZSAyID0qLzEwNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlRlbnNvckFubm90YXRpb24uZW5jb2RlKG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbltpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCAxNCwgd2lyZVR5cGUgMiA9Ki8xMTQpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zcGFyc2VJbml0aWFsaXplciAhPSBudWxsICYmIG1lc3NhZ2Uuc3BhcnNlSW5pdGlhbGl6ZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5zcGFyc2VJbml0aWFsaXplci5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90by5lbmNvZGUobWVzc2FnZS5zcGFyc2VJbml0aWFsaXplcltpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCAxNSwgd2lyZVR5cGUgMiA9Ki8xMjIpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgR3JhcGhQcm90byBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LkdyYXBoUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JR3JhcGhQcm90b30gbWVzc2FnZSBHcmFwaFByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgR3JhcGhQcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIEdyYXBoUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LkdyYXBoUHJvdG99IEdyYXBoUHJvdG9cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBHcmFwaFByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguR3JhcGhQcm90bygpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLm5vZGUgJiYgbWVzc2FnZS5ub2RlLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ub2RlID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5vZGUucHVzaCgkcm9vdC5vbm54Lk5vZGVQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgNToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5pbml0aWFsaXplciAmJiBtZXNzYWdlLmluaXRpYWxpemVyLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbml0aWFsaXplciA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbml0aWFsaXplci5wdXNoKCRyb290Lm9ubnguVGVuc29yUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMTU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uuc3BhcnNlSW5pdGlhbGl6ZXIgJiYgbWVzc2FnZS5zcGFyc2VJbml0aWFsaXplci5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3BhcnNlSW5pdGlhbGl6ZXIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3BhcnNlSW5pdGlhbGl6ZXIucHVzaCgkcm9vdC5vbm54LlNwYXJzZVRlbnNvclByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDEwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRvY1N0cmluZyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAxMToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5pbnB1dCAmJiBtZXNzYWdlLmlucHV0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnB1dCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnB1dC5wdXNoKCRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMTI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uub3V0cHV0ICYmIG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3V0cHV0LnB1c2goJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAxMzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS52YWx1ZUluZm8gJiYgbWVzc2FnZS52YWx1ZUluZm8ubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlSW5mbyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZUluZm8ucHVzaCgkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDE0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24gJiYgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24ucHVzaCgkcm9vdC5vbm54LlRlbnNvckFubm90YXRpb24uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBHcmFwaFByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5HcmFwaFByb3RvfSBHcmFwaFByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgR3JhcGhQcm90by5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYSBHcmFwaFByb3RvIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguR3JhcGhQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgR3JhcGhQcm90by52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ub2RlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5vZGVcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5ub2RlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibm9kZTogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uubm9kZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54Lk5vZGVQcm90by52ZXJpZnkobWVzc2FnZS5ub2RlW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibm9kZS5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UubmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5pdGlhbGl6ZXIgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaW5pdGlhbGl6ZXJcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5pbml0aWFsaXplcikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImluaXRpYWxpemVyOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbml0aWFsaXplci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLnZlcmlmeShtZXNzYWdlLmluaXRpYWxpemVyW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaW5pdGlhbGl6ZXIuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zcGFyc2VJbml0aWFsaXplciAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzcGFyc2VJbml0aWFsaXplclwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnNwYXJzZUluaXRpYWxpemVyKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3BhcnNlSW5pdGlhbGl6ZXI6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnNwYXJzZUluaXRpYWxpemVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguU3BhcnNlVGVuc29yUHJvdG8udmVyaWZ5KG1lc3NhZ2Uuc3BhcnNlSW5pdGlhbGl6ZXJbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzcGFyc2VJbml0aWFsaXplci5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRvY1N0cmluZykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbnB1dCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpbnB1dFwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmlucHV0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaW5wdXQ6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmlucHV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8udmVyaWZ5KG1lc3NhZ2UuaW5wdXRbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbnB1dC5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm91dHB1dCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJvdXRwdXRcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5vdXRwdXQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvdXRwdXQ6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm91dHB1dC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLnZlcmlmeShtZXNzYWdlLm91dHB1dFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm91dHB1dC5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlSW5mbyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZUluZm9cIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS52YWx1ZUluZm8pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZUluZm86IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnZhbHVlSW5mby5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLnZlcmlmeShtZXNzYWdlLnZhbHVlSW5mb1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInZhbHVlSW5mby5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicXVhbnRpemF0aW9uQW5ub3RhdGlvblwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJxdWFudGl6YXRpb25Bbm5vdGF0aW9uOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVGVuc29yQW5ub3RhdGlvbi52ZXJpZnkobWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicXVhbnRpemF0aW9uQW5ub3RhdGlvbi5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgR3JhcGhQcm90byBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LkdyYXBoUHJvdG99IEdyYXBoUHJvdG9cbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5HcmFwaFByb3RvKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LkdyYXBoUHJvdG8oKTtcbiAgICAgICAgICAgIGlmIChvYmplY3Qubm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3Qubm9kZSkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ubm9kZTogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5ub2RlID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3Qubm9kZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5ub2RlW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5ub2RlOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uubm9kZVtpXSA9ICRyb290Lm9ubnguTm9kZVByb3RvLmZyb21PYmplY3Qob2JqZWN0Lm5vZGVbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QubmFtZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IFN0cmluZyhvYmplY3QubmFtZSk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmluaXRpYWxpemVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5pbml0aWFsaXplcikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8uaW5pdGlhbGl6ZXI6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5pdGlhbGl6ZXIgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5pbml0aWFsaXplci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5pbml0aWFsaXplcltpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8uaW5pdGlhbGl6ZXI6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbml0aWFsaXplcltpXSA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8uZnJvbU9iamVjdChvYmplY3QuaW5pdGlhbGl6ZXJbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3Quc3BhcnNlSW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnNwYXJzZUluaXRpYWxpemVyKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5zcGFyc2VJbml0aWFsaXplcjogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5zcGFyc2VJbml0aWFsaXplciA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnNwYXJzZUluaXRpYWxpemVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnNwYXJzZUluaXRpYWxpemVyW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5zcGFyc2VJbml0aWFsaXplcjogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNwYXJzZUluaXRpYWxpemVyW2ldID0gJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90by5mcm9tT2JqZWN0KG9iamVjdC5zcGFyc2VJbml0aWFsaXplcltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5kb2NTdHJpbmcgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRvY1N0cmluZyA9IFN0cmluZyhvYmplY3QuZG9jU3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmlucHV0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5pbnB1dDogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5pbnB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmlucHV0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmlucHV0W2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5pbnB1dDogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlucHV0W2ldID0gJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by5mcm9tT2JqZWN0KG9iamVjdC5pbnB1dFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5vdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0Lm91dHB1dCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ub3V0cHV0OiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm91dHB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lm91dHB1dC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5vdXRwdXRbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5HcmFwaFByb3RvLm91dHB1dDogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm91dHB1dFtpXSA9ICRyb290Lm9ubnguVmFsdWVJbmZvUHJvdG8uZnJvbU9iamVjdChvYmplY3Qub3V0cHV0W2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LnZhbHVlSW5mbykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QudmFsdWVJbmZvKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by52YWx1ZUluZm86IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWVJbmZvID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QudmFsdWVJbmZvLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnZhbHVlSW5mb1tpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8udmFsdWVJbmZvOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWVJbmZvW2ldID0gJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by5mcm9tT2JqZWN0KG9iamVjdC52YWx1ZUluZm9baV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QucXVhbnRpemF0aW9uQW5ub3RhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QucXVhbnRpemF0aW9uQW5ub3RhdGlvbikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkdyYXBoUHJvdG8ucXVhbnRpemF0aW9uQW5ub3RhdGlvbjogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QucXVhbnRpemF0aW9uQW5ub3RhdGlvbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguR3JhcGhQcm90by5xdWFudGl6YXRpb25Bbm5vdGF0aW9uOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbltpXSA9ICRyb290Lm9ubnguVGVuc29yQW5ub3RhdGlvbi5mcm9tT2JqZWN0KG9iamVjdC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgR3JhcGhQcm90byBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5HcmFwaFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LkdyYXBoUHJvdG99IG1lc3NhZ2UgR3JhcGhQcm90b1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBvYmplY3Qubm9kZSA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC5pbml0aWFsaXplciA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC5pbnB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC5vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3QudmFsdWVJbmZvID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0LnF1YW50aXphdGlvbkFubm90YXRpb24gPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3Quc3BhcnNlSW5pdGlhbGl6ZXIgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIG9iamVjdC5kb2NTdHJpbmcgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uubm9kZSAmJiBtZXNzYWdlLm5vZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5vZGUgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2Uubm9kZS5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0Lm5vZGVbal0gPSAkcm9vdC5vbm54Lk5vZGVQcm90by50b09iamVjdChtZXNzYWdlLm5vZGVbal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5uYW1lID0gbWVzc2FnZS5uYW1lO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5pdGlhbGl6ZXIgJiYgbWVzc2FnZS5pbml0aWFsaXplci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuaW5pdGlhbGl6ZXIgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuaW5pdGlhbGl6ZXIubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5pbml0aWFsaXplcltqXSA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8udG9PYmplY3QobWVzc2FnZS5pbml0aWFsaXplcltqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb2NTdHJpbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9jU3RyaW5nXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5kb2NTdHJpbmcgPSBtZXNzYWdlLmRvY1N0cmluZztcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmlucHV0ICYmIG1lc3NhZ2UuaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmlucHV0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmlucHV0Lmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuaW5wdXRbal0gPSAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLnRvT2JqZWN0KG1lc3NhZ2UuaW5wdXRbal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uub3V0cHV0ICYmIG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3Qub3V0cHV0W2pdID0gJHJvb3Qub25ueC5WYWx1ZUluZm9Qcm90by50b09iamVjdChtZXNzYWdlLm91dHB1dFtqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZUluZm8gJiYgbWVzc2FnZS52YWx1ZUluZm8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlSW5mbyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS52YWx1ZUluZm8ubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZUluZm9bal0gPSAkcm9vdC5vbm54LlZhbHVlSW5mb1Byb3RvLnRvT2JqZWN0KG1lc3NhZ2UudmFsdWVJbmZvW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24gJiYgbWVzc2FnZS5xdWFudGl6YXRpb25Bbm5vdGF0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnF1YW50aXphdGlvbkFubm90YXRpb24ubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5xdWFudGl6YXRpb25Bbm5vdGF0aW9uW2pdID0gJHJvb3Qub25ueC5UZW5zb3JBbm5vdGF0aW9uLnRvT2JqZWN0KG1lc3NhZ2UucXVhbnRpemF0aW9uQW5ub3RhdGlvbltqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zcGFyc2VJbml0aWFsaXplciAmJiBtZXNzYWdlLnNwYXJzZUluaXRpYWxpemVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5zcGFyc2VJbml0aWFsaXplciA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5zcGFyc2VJbml0aWFsaXplci5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnNwYXJzZUluaXRpYWxpemVyW2pdID0gJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90by50b09iamVjdChtZXNzYWdlLnNwYXJzZUluaXRpYWxpemVyW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgR3JhcGhQcm90byB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBHcmFwaFByb3RvXG4gICAgICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkdyYXBoUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgICAgICovXG4gICAgICAgIEdyYXBoUHJvdG8uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvb25ueC5HcmFwaFByb3RvXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIEdyYXBoUHJvdG87XG4gICAgfSkoKTtcblxuICAgIG9ubnguVGVuc29yUHJvdG8gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBUZW5zb3JQcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGludGVyZmFjZSBJVGVuc29yUHJvdG9cbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyfExvbmc+fG51bGx9IFtkaW1zXSBUZW5zb3JQcm90byBkaW1zXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFtkYXRhVHlwZV0gVGVuc29yUHJvdG8gZGF0YVR5cGVcbiAgICAgICAgICogQHByb3BlcnR5IHtvbm54LlRlbnNvclByb3RvLklTZWdtZW50fG51bGx9IFtzZWdtZW50XSBUZW5zb3JQcm90byBzZWdtZW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVsbH0gW2Zsb2F0RGF0YV0gVGVuc29yUHJvdG8gZmxvYXREYXRhXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVsbH0gW2ludDMyRGF0YV0gVGVuc29yUHJvdG8gaW50MzJEYXRhXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPFVpbnQ4QXJyYXk+fG51bGx9IFtzdHJpbmdEYXRhXSBUZW5zb3JQcm90byBzdHJpbmdEYXRhXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcnxMb25nPnxudWxsfSBbaW50NjREYXRhXSBUZW5zb3JQcm90byBpbnQ2NERhdGFcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW25hbWVdIFRlbnNvclByb3RvIG5hbWVcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW2RvY1N0cmluZ10gVGVuc29yUHJvdG8gZG9jU3RyaW5nXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheXxudWxsfSBbcmF3RGF0YV0gVGVuc29yUHJvdG8gcmF3RGF0YVxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklTdHJpbmdTdHJpbmdFbnRyeVByb3RvPnxudWxsfSBbZXh0ZXJuYWxEYXRhXSBUZW5zb3JQcm90byBleHRlcm5hbERhdGFcbiAgICAgICAgICogQHByb3BlcnR5IHtvbm54LlRlbnNvclByb3RvLkRhdGFMb2NhdGlvbnxudWxsfSBbZGF0YUxvY2F0aW9uXSBUZW5zb3JQcm90byBkYXRhTG9jYXRpb25cbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPnxudWxsfSBbZG91YmxlRGF0YV0gVGVuc29yUHJvdG8gZG91YmxlRGF0YVxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXJ8TG9uZz58bnVsbH0gW3VpbnQ2NERhdGFdIFRlbnNvclByb3RvIHVpbnQ2NERhdGFcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgVGVuc29yUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFRlbnNvclByb3RvLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJVGVuc29yUHJvdG9cbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFRlbnNvclByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZGltcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5mbG9hdERhdGEgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaW50MzJEYXRhID0gW107XG4gICAgICAgICAgICB0aGlzLnN0cmluZ0RhdGEgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaW50NjREYXRhID0gW107XG4gICAgICAgICAgICB0aGlzLmV4dGVybmFsRGF0YSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5kb3VibGVEYXRhID0gW107XG4gICAgICAgICAgICB0aGlzLnVpbnQ2NERhdGEgPSBbXTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yUHJvdG8gZGltcy5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcnxMb25nPn0gZGltc1xuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS5kaW1zID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yUHJvdG8gZGF0YVR5cGUuXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gZGF0YVR5cGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5wcm90b3R5cGUuZGF0YVR5cGUgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZW5zb3JQcm90byBzZWdtZW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtvbm54LlRlbnNvclByb3RvLklTZWdtZW50fG51bGx8dW5kZWZpbmVkfSBzZWdtZW50XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLnNlZ21lbnQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZW5zb3JQcm90byBmbG9hdERhdGEuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXI+fSBmbG9hdERhdGFcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5wcm90b3R5cGUuZmxvYXREYXRhID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yUHJvdG8gaW50MzJEYXRhLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyPn0gaW50MzJEYXRhXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLmludDMyRGF0YSA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlbnNvclByb3RvIHN0cmluZ0RhdGEuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxVaW50OEFycmF5Pn0gc3RyaW5nRGF0YVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclByb3RvLnByb3RvdHlwZS5zdHJpbmdEYXRhID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yUHJvdG8gaW50NjREYXRhLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyfExvbmc+fSBpbnQ2NERhdGFcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5wcm90b3R5cGUuaW50NjREYXRhID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yUHJvdG8gbmFtZS5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLm5hbWUgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZW5zb3JQcm90byBkb2NTdHJpbmcuXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gZG9jU3RyaW5nXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLmRvY1N0cmluZyA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlbnNvclByb3RvIHJhd0RhdGEuXG4gICAgICAgICAqIEBtZW1iZXIge1VpbnQ4QXJyYXl9IHJhd0RhdGFcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5wcm90b3R5cGUucmF3RGF0YSA9ICR1dGlsLm5ld0J1ZmZlcihbXSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlbnNvclByb3RvIGV4dGVybmFsRGF0YS5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSVN0cmluZ1N0cmluZ0VudHJ5UHJvdG8+fSBleHRlcm5hbERhdGFcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5wcm90b3R5cGUuZXh0ZXJuYWxEYXRhID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVuc29yUHJvdG8gZGF0YUxvY2F0aW9uLlxuICAgICAgICAgKiBAbWVtYmVyIHtvbm54LlRlbnNvclByb3RvLkRhdGFMb2NhdGlvbn0gZGF0YUxvY2F0aW9uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLmRhdGFMb2NhdGlvbiA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlbnNvclByb3RvIGRvdWJsZURhdGEuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXI+fSBkb3VibGVEYXRhXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLmRvdWJsZURhdGEgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZW5zb3JQcm90byB1aW50NjREYXRhLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyfExvbmc+fSB1aW50NjREYXRhXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLnVpbnQ2NERhdGEgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFRlbnNvclByb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yUHJvdG99IFRlbnNvclByb3RvIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JQcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3JQcm90byhwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFRlbnNvclByb3RvIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVGVuc29yUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvclByb3RvfSBtZXNzYWdlIFRlbnNvclByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRpbXMgIT0gbnVsbCAmJiBtZXNzYWdlLmRpbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLzEwKS5mb3JrKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmRpbXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5pbnQ2NChtZXNzYWdlLmRpbXNbaV0pO1xuICAgICAgICAgICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGFUeXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJkYXRhVHlwZVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDAgPSovMTYpLmludDMyKG1lc3NhZ2UuZGF0YVR5cGUpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc2VnbWVudCAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwic2VnbWVudFwiKSlcbiAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQuZW5jb2RlKG1lc3NhZ2Uuc2VnbWVudCwgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAyID0qLzI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZmxvYXREYXRhICE9IG51bGwgJiYgbWVzc2FnZS5mbG9hdERhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA0LCB3aXJlVHlwZSAyID0qLzM0KS5mb3JrKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmZsb2F0RGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLmZsb2F0KG1lc3NhZ2UuZmxvYXREYXRhW2ldKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIubGRlbGltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbnQzMkRhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmludDMyRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDUsIHdpcmVUeXBlIDIgPSovNDIpLmZvcmsoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW50MzJEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuaW50MzIobWVzc2FnZS5pbnQzMkRhdGFbaV0pO1xuICAgICAgICAgICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnN0cmluZ0RhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLnN0cmluZ0RhdGEubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5zdHJpbmdEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDYsIHdpcmVUeXBlIDIgPSovNTApLmJ5dGVzKG1lc3NhZ2Uuc3RyaW5nRGF0YVtpXSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbnQ2NERhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmludDY0RGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDcsIHdpcmVUeXBlIDIgPSovNTgpLmZvcmsoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW50NjREYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuaW50NjQobWVzc2FnZS5pbnQ2NERhdGFbaV0pO1xuICAgICAgICAgICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA4LCB3aXJlVHlwZSAyID0qLzY2KS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnJhd0RhdGEgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInJhd0RhdGFcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA5LCB3aXJlVHlwZSAyID0qLzc0KS5ieXRlcyhtZXNzYWdlLnJhd0RhdGEpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG91YmxlRGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuZG91YmxlRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEwLCB3aXJlVHlwZSAyID0qLzgyKS5mb3JrKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmRvdWJsZURhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5kb3VibGUobWVzc2FnZS5kb3VibGVEYXRhW2ldKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIubGRlbGltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS51aW50NjREYXRhICE9IG51bGwgJiYgbWVzc2FnZS51aW50NjREYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMTEsIHdpcmVUeXBlIDIgPSovOTApLmZvcmsoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudWludDY0RGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQ2NChtZXNzYWdlLnVpbnQ2NERhdGFbaV0pO1xuICAgICAgICAgICAgICAgIHdyaXRlci5sZGVsaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiZG9jU3RyaW5nXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMTIsIHdpcmVUeXBlIDIgPSovOTgpLnN0cmluZyhtZXNzYWdlLmRvY1N0cmluZyk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5leHRlcm5hbERhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmV4dGVybmFsRGF0YS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmV4dGVybmFsRGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmVuY29kZShtZXNzYWdlLmV4dGVybmFsRGF0YVtpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCAxMywgd2lyZVR5cGUgMiA9Ki8xMDYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kYXRhTG9jYXRpb24gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImRhdGFMb2NhdGlvblwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDE0LCB3aXJlVHlwZSAwID0qLzExMikuaW50MzIobWVzc2FnZS5kYXRhTG9jYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFRlbnNvclByb3RvIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVGVuc29yUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvclByb3RvfSBtZXNzYWdlIFRlbnNvclByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBUZW5zb3JQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclByb3RvfSBUZW5zb3JQcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVGVuc29yUHJvdG8oKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5kaW1zICYmIG1lc3NhZ2UuZGltcy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltcy5wdXNoKHJlYWRlci5pbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltcy5wdXNoKHJlYWRlci5pbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGFUeXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZWdtZW50ID0gJHJvb3Qub25ueC5UZW5zb3JQcm90by5TZWdtZW50LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5mbG9hdERhdGEgJiYgbWVzc2FnZS5mbG9hdERhdGEubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZsb2F0RGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmxvYXREYXRhLnB1c2gocmVhZGVyLmZsb2F0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mbG9hdERhdGEucHVzaChyZWFkZXIuZmxvYXQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgNToge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5pbnQzMkRhdGEgJiYgbWVzc2FnZS5pbnQzMkRhdGEubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmludDMyRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW50MzJEYXRhLnB1c2gocmVhZGVyLmludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnQzMkRhdGEucHVzaChyZWFkZXIuaW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgNjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5zdHJpbmdEYXRhICYmIG1lc3NhZ2Uuc3RyaW5nRGF0YS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyaW5nRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdHJpbmdEYXRhLnB1c2gocmVhZGVyLmJ5dGVzKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuaW50NjREYXRhICYmIG1lc3NhZ2UuaW50NjREYXRhLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnQ2NERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmludDY0RGF0YS5wdXNoKHJlYWRlci5pbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW50NjREYXRhLnB1c2gocmVhZGVyLmludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAxMjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kb2NTdHJpbmcgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgOToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yYXdEYXRhID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMTM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuZXh0ZXJuYWxEYXRhICYmIG1lc3NhZ2UuZXh0ZXJuYWxEYXRhLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5leHRlcm5hbERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXh0ZXJuYWxEYXRhLnB1c2goJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDE0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGFMb2NhdGlvbiA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDEwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmRvdWJsZURhdGEgJiYgbWVzc2FnZS5kb3VibGVEYXRhLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kb3VibGVEYXRhID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kb3VibGVEYXRhLnB1c2gocmVhZGVyLmRvdWJsZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG91YmxlRGF0YS5wdXNoKHJlYWRlci5kb3VibGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMTE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UudWludDY0RGF0YSAmJiBtZXNzYWdlLnVpbnQ2NERhdGEubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVpbnQ2NERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVpbnQ2NERhdGEucHVzaChyZWFkZXIudWludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51aW50NjREYXRhLnB1c2gocmVhZGVyLnVpbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIFRlbnNvclByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yUHJvdG99IFRlbnNvclByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgVGVuc29yUHJvdG8gbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGltcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkaW1zXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuZGltcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRpbXM6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmRpbXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZGltc1tpXSkgJiYgIShtZXNzYWdlLmRpbXNbaV0gJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZGltc1tpXS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmRpbXNbaV0uaGlnaCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZGltczogaW50ZWdlcnxMb25nW10gZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGFUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRhdGFUeXBlXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZGF0YVR5cGUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkYXRhVHlwZTogaW50ZWdlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc2VnbWVudCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzZWdtZW50XCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UZW5zb3JQcm90by5TZWdtZW50LnZlcmlmeShtZXNzYWdlLnNlZ21lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic2VnbWVudC5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZmxvYXREYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImZsb2F0RGF0YVwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmZsb2F0RGF0YSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImZsb2F0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZmxvYXREYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuZmxvYXREYXRhW2ldICE9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZmxvYXREYXRhOiBudW1iZXJbXSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW50MzJEYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImludDMyRGF0YVwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmludDMyRGF0YSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImludDMyRGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW50MzJEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmludDMyRGF0YVtpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbnQzMkRhdGE6IGludGVnZXJbXSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RyaW5nRGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzdHJpbmdEYXRhXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2Uuc3RyaW5nRGF0YSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ0RhdGE6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnN0cmluZ0RhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uuc3RyaW5nRGF0YVtpXSAmJiB0eXBlb2YgbWVzc2FnZS5zdHJpbmdEYXRhW2ldLmxlbmd0aCA9PT0gXCJudW1iZXJcIiB8fCAkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnN0cmluZ0RhdGFbaV0pKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ0RhdGE6IGJ1ZmZlcltdIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbnQ2NERhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaW50NjREYXRhXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuaW50NjREYXRhKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaW50NjREYXRhOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5pbnQ2NERhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaW50NjREYXRhW2ldKSAmJiAhKG1lc3NhZ2UuaW50NjREYXRhW2ldICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmludDY0RGF0YVtpXS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmludDY0RGF0YVtpXS5oaWdoKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbnQ2NERhdGE6IGludGVnZXJ8TG9uZ1tdIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5uYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLm5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRvY1N0cmluZykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5yYXdEYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInJhd0RhdGFcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5yYXdEYXRhICYmIHR5cGVvZiBtZXNzYWdlLnJhd0RhdGEubGVuZ3RoID09PSBcIm51bWJlclwiIHx8ICR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UucmF3RGF0YSkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJyYXdEYXRhOiBidWZmZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmV4dGVybmFsRGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJleHRlcm5hbERhdGFcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5leHRlcm5hbERhdGEpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJleHRlcm5hbERhdGE6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmV4dGVybmFsRGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlN0cmluZ1N0cmluZ0VudHJ5UHJvdG8udmVyaWZ5KG1lc3NhZ2UuZXh0ZXJuYWxEYXRhW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZXh0ZXJuYWxEYXRhLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YUxvY2F0aW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRhdGFMb2NhdGlvblwiKSlcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UuZGF0YUxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZGF0YUxvY2F0aW9uOiBlbnVtIHZhbHVlIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG91YmxlRGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb3VibGVEYXRhXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuZG91YmxlRGF0YSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRvdWJsZURhdGE6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmRvdWJsZURhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5kb3VibGVEYXRhW2ldICE9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZG91YmxlRGF0YTogbnVtYmVyW10gZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnVpbnQ2NERhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidWludDY0RGF0YVwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnVpbnQ2NERhdGEpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ1aW50NjREYXRhOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS51aW50NjREYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnVpbnQ2NERhdGFbaV0pICYmICEobWVzc2FnZS51aW50NjREYXRhW2ldICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnVpbnQ2NERhdGFbaV0ubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS51aW50NjREYXRhW2ldLmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInVpbnQ2NERhdGE6IGludGVnZXJ8TG9uZ1tdIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIFRlbnNvclByb3RvIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclByb3RvfSBUZW5zb3JQcm90b1xuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5UZW5zb3JQcm90bylcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UZW5zb3JQcm90bygpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5kaW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5kaW1zKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uZGltczogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kaW1zID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuZGltcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5kaW1zW2ldID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LmRpbXNbaV0pKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmRpbXNbaV0gPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpbXNbaV0gPSBwYXJzZUludChvYmplY3QuZGltc1tpXSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmRpbXNbaV0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpbXNbaV0gPSBvYmplY3QuZGltc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5kaW1zW2ldID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kaW1zW2ldID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5kaW1zW2ldLmxvdyA+Pj4gMCwgb2JqZWN0LmRpbXNbaV0uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuZGF0YVR5cGUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGFUeXBlID0gb2JqZWN0LmRhdGFUeXBlIHwgMDtcbiAgICAgICAgICAgIGlmIChvYmplY3Quc2VnbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Quc2VnbWVudCAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uc2VnbWVudDogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VnbWVudCA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8uU2VnbWVudC5mcm9tT2JqZWN0KG9iamVjdC5zZWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuZmxvYXREYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5mbG9hdERhdGEpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5mbG9hdERhdGE6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmxvYXREYXRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuZmxvYXREYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZsb2F0RGF0YVtpXSA9IE51bWJlcihvYmplY3QuZmxvYXREYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuaW50MzJEYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5pbnQzMkRhdGEpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5pbnQzMkRhdGE6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW50MzJEYXRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuaW50MzJEYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmludDMyRGF0YVtpXSA9IG9iamVjdC5pbnQzMkRhdGFbaV0gfCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5zdHJpbmdEYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5zdHJpbmdEYXRhKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yUHJvdG8uc3RyaW5nRGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5zdHJpbmdEYXRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3Quc3RyaW5nRGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Quc3RyaW5nRGF0YVtpXSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICR1dGlsLmJhc2U2NC5kZWNvZGUob2JqZWN0LnN0cmluZ0RhdGFbaV0sIG1lc3NhZ2Uuc3RyaW5nRGF0YVtpXSA9ICR1dGlsLm5ld0J1ZmZlcigkdXRpbC5iYXNlNjQubGVuZ3RoKG9iamVjdC5zdHJpbmdEYXRhW2ldKSksIDApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvYmplY3Quc3RyaW5nRGF0YVtpXS5sZW5ndGggPj0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyaW5nRGF0YVtpXSA9IG9iamVjdC5zdHJpbmdEYXRhW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5pbnQ2NERhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmludDY0RGF0YSkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmludDY0RGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5pbnQ2NERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5pbnQ2NERhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAgICAgICAgICAgKG1lc3NhZ2UuaW50NjREYXRhW2ldID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LmludDY0RGF0YVtpXSkpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaW50NjREYXRhW2ldID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnQ2NERhdGFbaV0gPSBwYXJzZUludChvYmplY3QuaW50NjREYXRhW2ldLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaW50NjREYXRhW2ldID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnQ2NERhdGFbaV0gPSBvYmplY3QuaW50NjREYXRhW2ldO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmludDY0RGF0YVtpXSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW50NjREYXRhW2ldID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5pbnQ2NERhdGFbaV0ubG93ID4+PiAwLCBvYmplY3QuaW50NjREYXRhW2ldLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0Lm5hbWUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSBTdHJpbmcob2JqZWN0Lm5hbWUpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5kb2NTdHJpbmcgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRvY1N0cmluZyA9IFN0cmluZyhvYmplY3QuZG9jU3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QucmF3RGF0YSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnJhd0RhdGEgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICR1dGlsLmJhc2U2NC5kZWNvZGUob2JqZWN0LnJhd0RhdGEsIG1lc3NhZ2UucmF3RGF0YSA9ICR1dGlsLm5ld0J1ZmZlcigkdXRpbC5iYXNlNjQubGVuZ3RoKG9iamVjdC5yYXdEYXRhKSksIDApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iamVjdC5yYXdEYXRhLmxlbmd0aCA+PSAwKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJhd0RhdGEgPSBvYmplY3QucmF3RGF0YTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuZXh0ZXJuYWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5leHRlcm5hbERhdGEpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by5leHRlcm5hbERhdGE6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXh0ZXJuYWxEYXRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuZXh0ZXJuYWxEYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmV4dGVybmFsRGF0YVtpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmV4dGVybmFsRGF0YTogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV4dGVybmFsRGF0YVtpXSA9ICRyb290Lm9ubnguU3RyaW5nU3RyaW5nRW50cnlQcm90by5mcm9tT2JqZWN0KG9iamVjdC5leHRlcm5hbERhdGFbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAob2JqZWN0LmRhdGFMb2NhdGlvbikge1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5kYXRhTG9jYXRpb24gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kYXRhTG9jYXRpb24gPSBvYmplY3QuZGF0YUxvY2F0aW9uO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiREVGQVVMVFwiOlxuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF0YUxvY2F0aW9uID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJFWFRFUk5BTFwiOlxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF0YUxvY2F0aW9uID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuZG91YmxlRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuZG91YmxlRGF0YSkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclByb3RvLmRvdWJsZURhdGE6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG91YmxlRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmRvdWJsZURhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG91YmxlRGF0YVtpXSA9IE51bWJlcihvYmplY3QuZG91YmxlRGF0YVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LnVpbnQ2NERhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnVpbnQ2NERhdGEpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UZW5zb3JQcm90by51aW50NjREYXRhOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnVpbnQ2NERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC51aW50NjREYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgICAgICAgICAgIChtZXNzYWdlLnVpbnQ2NERhdGFbaV0gPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QudWludDY0RGF0YVtpXSkpLnVuc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC51aW50NjREYXRhW2ldID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51aW50NjREYXRhW2ldID0gcGFyc2VJbnQob2JqZWN0LnVpbnQ2NERhdGFbaV0sIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC51aW50NjREYXRhW2ldID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51aW50NjREYXRhW2ldID0gb2JqZWN0LnVpbnQ2NERhdGFbaV07XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QudWludDY0RGF0YVtpXSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudWludDY0RGF0YVtpXSA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QudWludDY0RGF0YVtpXS5sb3cgPj4+IDAsIG9iamVjdC51aW50NjREYXRhW2ldLmhpZ2ggPj4+IDApLnRvTnVtYmVyKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIFRlbnNvclByb3RvIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LlRlbnNvclByb3RvfSBtZXNzYWdlIFRlbnNvclByb3RvXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuZGltcyA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC5mbG9hdERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3QuaW50MzJEYXRhID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0LnN0cmluZ0RhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3QuaW50NjREYXRhID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRvdWJsZURhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3QudWludDY0RGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC5leHRlcm5hbERhdGEgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRhdGFUeXBlID0gMDtcbiAgICAgICAgICAgICAgICBvYmplY3Quc2VnbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5yYXdEYXRhID0gXCJcIjtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnJhd0RhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZXMgIT09IEFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnJhd0RhdGEgPSAkdXRpbC5uZXdCdWZmZXIob2JqZWN0LnJhd0RhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3QuZG9jU3RyaW5nID0gXCJcIjtcbiAgICAgICAgICAgICAgICBvYmplY3QuZGF0YUxvY2F0aW9uID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gXCJERUZBVUxUXCIgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGltcyAmJiBtZXNzYWdlLmRpbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRpbXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuZGltcy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmRpbXNbal0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuZGltc1tqXSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmRpbXNbal0pIDogbWVzc2FnZS5kaW1zW2pdO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuZGltc1tqXSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5kaW1zW2pdKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmRpbXNbal0ubG93ID4+PiAwLCBtZXNzYWdlLmRpbXNbal0uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UuZGltc1tqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGFUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRhdGFUeXBlXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5kYXRhVHlwZSA9IG1lc3NhZ2UuZGF0YVR5cGU7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zZWdtZW50ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInNlZ21lbnRcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnNlZ21lbnQgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLlNlZ21lbnQudG9PYmplY3QobWVzc2FnZS5zZWdtZW50LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmZsb2F0RGF0YSAmJiBtZXNzYWdlLmZsb2F0RGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuZmxvYXREYXRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmZsb2F0RGF0YS5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmZsb2F0RGF0YVtqXSA9IG9wdGlvbnMuanNvbiAmJiAhaXNGaW5pdGUobWVzc2FnZS5mbG9hdERhdGFbal0pID8gU3RyaW5nKG1lc3NhZ2UuZmxvYXREYXRhW2pdKSA6IG1lc3NhZ2UuZmxvYXREYXRhW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW50MzJEYXRhICYmIG1lc3NhZ2UuaW50MzJEYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5pbnQzMkRhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuaW50MzJEYXRhLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuaW50MzJEYXRhW2pdID0gbWVzc2FnZS5pbnQzMkRhdGFbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zdHJpbmdEYXRhICYmIG1lc3NhZ2Uuc3RyaW5nRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3Quc3RyaW5nRGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5zdHJpbmdEYXRhLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3Quc3RyaW5nRGF0YVtqXSA9IG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZyA/ICR1dGlsLmJhc2U2NC5lbmNvZGUobWVzc2FnZS5zdHJpbmdEYXRhW2pdLCAwLCBtZXNzYWdlLnN0cmluZ0RhdGFbal0ubGVuZ3RoKSA6IG9wdGlvbnMuYnl0ZXMgPT09IEFycmF5ID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobWVzc2FnZS5zdHJpbmdEYXRhW2pdKSA6IG1lc3NhZ2Uuc3RyaW5nRGF0YVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmludDY0RGF0YSAmJiBtZXNzYWdlLmludDY0RGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuaW50NjREYXRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmludDY0RGF0YS5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmludDY0RGF0YVtqXSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5pbnQ2NERhdGFbal0gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5pbnQ2NERhdGFbal0pIDogbWVzc2FnZS5pbnQ2NERhdGFbal07XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5pbnQ2NERhdGFbal0gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuaW50NjREYXRhW2pdKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmludDY0RGF0YVtqXS5sb3cgPj4+IDAsIG1lc3NhZ2UuaW50NjREYXRhW2pdLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLmludDY0RGF0YVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QubmFtZSA9IG1lc3NhZ2UubmFtZTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnJhd0RhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicmF3RGF0YVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QucmF3RGF0YSA9IG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZyA/ICR1dGlsLmJhc2U2NC5lbmNvZGUobWVzc2FnZS5yYXdEYXRhLCAwLCBtZXNzYWdlLnJhd0RhdGEubGVuZ3RoKSA6IG9wdGlvbnMuYnl0ZXMgPT09IEFycmF5ID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobWVzc2FnZS5yYXdEYXRhKSA6IG1lc3NhZ2UucmF3RGF0YTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvdWJsZURhdGEgJiYgbWVzc2FnZS5kb3VibGVEYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5kb3VibGVEYXRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmRvdWJsZURhdGEubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5kb3VibGVEYXRhW2pdID0gb3B0aW9ucy5qc29uICYmICFpc0Zpbml0ZShtZXNzYWdlLmRvdWJsZURhdGFbal0pID8gU3RyaW5nKG1lc3NhZ2UuZG91YmxlRGF0YVtqXSkgOiBtZXNzYWdlLmRvdWJsZURhdGFbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS51aW50NjREYXRhICYmIG1lc3NhZ2UudWludDY0RGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QudWludDY0RGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS51aW50NjREYXRhLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UudWludDY0RGF0YVtqXSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC51aW50NjREYXRhW2pdID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UudWludDY0RGF0YVtqXSkgOiBtZXNzYWdlLnVpbnQ2NERhdGFbal07XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC51aW50NjREYXRhW2pdID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLnVpbnQ2NERhdGFbal0pIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UudWludDY0RGF0YVtqXS5sb3cgPj4+IDAsIG1lc3NhZ2UudWludDY0RGF0YVtqXS5oaWdoID4+PiAwKS50b051bWJlcih0cnVlKSA6IG1lc3NhZ2UudWludDY0RGF0YVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmRvY1N0cmluZyA9IG1lc3NhZ2UuZG9jU3RyaW5nO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZXh0ZXJuYWxEYXRhICYmIG1lc3NhZ2UuZXh0ZXJuYWxEYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5leHRlcm5hbERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuZXh0ZXJuYWxEYXRhLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuZXh0ZXJuYWxEYXRhW2pdID0gJHJvb3Qub25ueC5TdHJpbmdTdHJpbmdFbnRyeVByb3RvLnRvT2JqZWN0KG1lc3NhZ2UuZXh0ZXJuYWxEYXRhW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGFMb2NhdGlvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkYXRhTG9jYXRpb25cIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmRhdGFMb2NhdGlvbiA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/ICRyb290Lm9ubnguVGVuc29yUHJvdG8uRGF0YUxvY2F0aW9uW21lc3NhZ2UuZGF0YUxvY2F0aW9uXSA9PT0gdW5kZWZpbmVkID8gbWVzc2FnZS5kYXRhTG9jYXRpb24gOiAkcm9vdC5vbm54LlRlbnNvclByb3RvLkRhdGFMb2NhdGlvblttZXNzYWdlLmRhdGFMb2NhdGlvbl0gOiBtZXNzYWdlLmRhdGFMb2NhdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgVGVuc29yUHJvdG8gdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBUZW5zb3JQcm90b1xuICAgICAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVmYXVsdCB0eXBlIHVybFxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yUHJvdG8uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvb25ueC5UZW5zb3JQcm90b1wiO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEYXRhVHlwZSBlbnVtLlxuICAgICAgICAgKiBAbmFtZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlXG4gICAgICAgICAqIEBlbnVtIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBVTkRFRklORUQ9MCBVTkRFRklORUQgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEZMT0FUPTEgRkxPQVQgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFVJTlQ4PTIgVUlOVDggdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElOVDg9MyBJTlQ4IHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBVSU5UMTY9NCBVSU5UMTYgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElOVDE2PTUgSU5UMTYgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElOVDMyPTYgSU5UMzIgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IElOVDY0PTcgSU5UNjQgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFNUUklORz04IFNUUklORyB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQk9PTD05IEJPT0wgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEZMT0FUMTY9MTAgRkxPQVQxNiB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gRE9VQkxFPTExIERPVUJMRSB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gVUlOVDMyPTEyIFVJTlQzMiB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gVUlOVDY0PTEzIFVJTlQ2NCB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQ09NUExFWDY0PTE0IENPTVBMRVg2NCB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQ09NUExFWDEyOD0xNSBDT01QTEVYMTI4IHZhbHVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBCRkxPQVQxNj0xNiBCRkxPQVQxNiB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gRkxPQVQ4RTRNM0ZOPTE3IEZMT0FUOEU0TTNGTiB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gRkxPQVQ4RTRNM0ZOVVo9MTggRkxPQVQ4RTRNM0ZOVVogdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEZMT0FUOEU1TTI9MTkgRkxPQVQ4RTVNMiB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gRkxPQVQ4RTVNMkZOVVo9MjAgRkxPQVQ4RTVNMkZOVVogdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclByb3RvLkRhdGFUeXBlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlc0J5SWQgPSB7fSwgdmFsdWVzID0gT2JqZWN0LmNyZWF0ZSh2YWx1ZXNCeUlkKTtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzBdID0gXCJVTkRFRklORURcIl0gPSAwO1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMV0gPSBcIkZMT0FUXCJdID0gMTtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzJdID0gXCJVSU5UOFwiXSA9IDI7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFszXSA9IFwiSU5UOFwiXSA9IDM7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs0XSA9IFwiVUlOVDE2XCJdID0gNDtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzVdID0gXCJJTlQxNlwiXSA9IDU7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs2XSA9IFwiSU5UMzJcIl0gPSA2O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbN10gPSBcIklOVDY0XCJdID0gNztcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzhdID0gXCJTVFJJTkdcIl0gPSA4O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbOV0gPSBcIkJPT0xcIl0gPSA5O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTBdID0gXCJGTE9BVDE2XCJdID0gMTA7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxMV0gPSBcIkRPVUJMRVwiXSA9IDExO1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTJdID0gXCJVSU5UMzJcIl0gPSAxMjtcbiAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzEzXSA9IFwiVUlOVDY0XCJdID0gMTM7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxNF0gPSBcIkNPTVBMRVg2NFwiXSA9IDE0O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTVdID0gXCJDT01QTEVYMTI4XCJdID0gMTU7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxNl0gPSBcIkJGTE9BVDE2XCJdID0gMTY7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxN10gPSBcIkZMT0FUOEU0TTNGTlwiXSA9IDE3O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMThdID0gXCJGTE9BVDhFNE0zRk5VWlwiXSA9IDE4O1xuICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTldID0gXCJGTE9BVDhFNU0yXCJdID0gMTk7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsyMF0gPSBcIkZMT0FUOEU1TTJGTlVaXCJdID0gMjA7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIFRlbnNvclByb3RvLlNlZ21lbnQgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUHJvcGVydGllcyBvZiBhIFNlZ21lbnQuXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90b1xuICAgICAgICAgICAgICogQGludGVyZmFjZSBJU2VnbWVudFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ3xudWxsfSBbYmVnaW5dIFNlZ21lbnQgYmVnaW5cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW2VuZF0gU2VnbWVudCBlbmRcbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgU2VnbWVudC5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvXG4gICAgICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBTZWdtZW50LlxuICAgICAgICAgICAgICogQGltcGxlbWVudHMgSVNlZ21lbnRcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlRlbnNvclByb3RvLklTZWdtZW50PX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIFNlZ21lbnQocHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2VnbWVudCBiZWdpbi5cbiAgICAgICAgICAgICAqIEBtZW1iZXIge251bWJlcnxMb25nfSBiZWdpblxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudFxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNlZ21lbnQucHJvdG90eXBlLmJlZ2luID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2VnbWVudCBlbmQuXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8TG9uZ30gZW5kXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU2VnbWVudC5wcm90b3R5cGUuZW5kID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBTZWdtZW50IGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvLlNlZ21lbnRcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UZW5zb3JQcm90by5JU2VnbWVudD19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yUHJvdG8uU2VnbWVudH0gU2VnbWVudCBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTZWdtZW50LmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTZWdtZW50KHByb3BlcnRpZXMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgU2VnbWVudCBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlRlbnNvclByb3RvLlNlZ21lbnQudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yUHJvdG8uSVNlZ21lbnR9IG1lc3NhZ2UgU2VnbWVudCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTZWdtZW50LmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5iZWdpbiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiYmVnaW5cIikpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMCA9Ki84KS5pbnQ2NChtZXNzYWdlLmJlZ2luKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lbmQgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImVuZFwiKSlcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAwID0qLzE2KS5pbnQ2NChtZXNzYWdlLmVuZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFNlZ21lbnQgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UZW5zb3JQcm90by5TZWdtZW50LnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlRlbnNvclByb3RvLklTZWdtZW50fSBtZXNzYWdlIFNlZ21lbnQgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU2VnbWVudC5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlY29kZXMgYSBTZWdtZW50IG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JQcm90by5TZWdtZW50fSBTZWdtZW50XG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNlZ21lbnQuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UZW5zb3JQcm90by5TZWdtZW50KCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5iZWdpbiA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVuZCA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlY29kZXMgYSBTZWdtZW50IG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclByb3RvLlNlZ21lbnR9IFNlZ21lbnRcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU2VnbWVudC5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVmVyaWZpZXMgYSBTZWdtZW50IG1lc3NhZ2UuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNlZ21lbnQudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuYmVnaW4gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYmVnaW5cIikpXG4gICAgICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuYmVnaW4pICYmICEobWVzc2FnZS5iZWdpbiAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5iZWdpbi5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmJlZ2luLmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJlZ2luOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lbmQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZW5kXCIpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmVuZCkgJiYgIShtZXNzYWdlLmVuZCAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5lbmQubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5lbmQuaGlnaCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZW5kOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIFNlZ21lbnQgbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvLlNlZ21lbnRcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclByb3RvLlNlZ21lbnR9IFNlZ21lbnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU2VnbWVudC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5UZW5zb3JQcm90by5TZWdtZW50KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVGVuc29yUHJvdG8uU2VnbWVudCgpO1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3QuYmVnaW4gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5iZWdpbiA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5iZWdpbikpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuYmVnaW4gPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJlZ2luID0gcGFyc2VJbnQob2JqZWN0LmJlZ2luLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuYmVnaW4gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJlZ2luID0gb2JqZWN0LmJlZ2luO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmJlZ2luID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5iZWdpbiA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuYmVnaW4ubG93ID4+PiAwLCBvYmplY3QuYmVnaW4uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0LmVuZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgICAgICAgICAgIChtZXNzYWdlLmVuZCA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5lbmQpKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmVuZCA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZW5kID0gcGFyc2VJbnQob2JqZWN0LmVuZCwgMTApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmVuZCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZW5kID0gb2JqZWN0LmVuZDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5lbmQgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVuZCA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuZW5kLmxvdyA+Pj4gMCwgb2JqZWN0LmVuZC5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBTZWdtZW50IG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yUHJvdG8uU2VnbWVudFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlRlbnNvclByb3RvLlNlZ21lbnR9IG1lc3NhZ2UgU2VnbWVudFxuICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTZWdtZW50LnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuYmVnaW4gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5iZWdpbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFwiMFwiIDogMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb25nID0gbmV3ICR1dGlsLkxvbmcoMCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmVuZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IGxvbmcudG9TdHJpbmcoKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IGxvbmcudG9OdW1iZXIoKSA6IGxvbmc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmVuZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFwiMFwiIDogMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuYmVnaW4gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYmVnaW5cIikpXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5iZWdpbiA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5iZWdpbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmJlZ2luKSA6IG1lc3NhZ2UuYmVnaW47XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5iZWdpbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5iZWdpbikgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5iZWdpbi5sb3cgPj4+IDAsIG1lc3NhZ2UuYmVnaW4uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UuYmVnaW47XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZW5kICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImVuZFwiKSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmVuZCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5lbmQgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5lbmQpIDogbWVzc2FnZS5lbmQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5lbmQgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuZW5kKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmVuZC5sb3cgPj4+IDAsIG1lc3NhZ2UuZW5kLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLmVuZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIFNlZ21lbnQgdG8gSlNPTi5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclByb3RvLlNlZ21lbnRcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTZWdtZW50LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGRlZmF1bHQgdHlwZSB1cmwgZm9yIFNlZ21lbnRcbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JQcm90by5TZWdtZW50XG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWZhdWx0IHR5cGUgdXJsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNlZ21lbnQuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL29ubnguVGVuc29yUHJvdG8uU2VnbWVudFwiO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIFNlZ21lbnQ7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERhdGFMb2NhdGlvbiBlbnVtLlxuICAgICAgICAgKiBAbmFtZSBvbm54LlRlbnNvclByb3RvLkRhdGFMb2NhdGlvblxuICAgICAgICAgKiBAZW51bSB7bnVtYmVyfVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gREVGQVVMVD0wIERFRkFVTFQgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEVYVEVSTkFMPTEgRVhURVJOQUwgdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclByb3RvLkRhdGFMb2NhdGlvbiA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFswXSA9IFwiREVGQVVMVFwiXSA9IDA7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxXSA9IFwiRVhURVJOQUxcIl0gPSAxO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfSkoKTtcblxuICAgICAgICByZXR1cm4gVGVuc29yUHJvdG87XG4gICAgfSkoKTtcblxuICAgIG9ubnguU3BhcnNlVGVuc29yUHJvdG8gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBTcGFyc2VUZW5zb3JQcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGludGVyZmFjZSBJU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgICAgICogQHByb3BlcnR5IHtvbm54LklUZW5zb3JQcm90b3xudWxsfSBbdmFsdWVzXSBTcGFyc2VUZW5zb3JQcm90byB2YWx1ZXNcbiAgICAgICAgICogQHByb3BlcnR5IHtvbm54LklUZW5zb3JQcm90b3xudWxsfSBbaW5kaWNlc10gU3BhcnNlVGVuc29yUHJvdG8gaW5kaWNlc1xuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXJ8TG9uZz58bnVsbH0gW2RpbXNdIFNwYXJzZVRlbnNvclByb3RvIGRpbXNcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgU3BhcnNlVGVuc29yUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFNwYXJzZVRlbnNvclByb3RvLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JU3BhcnNlVGVuc29yUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFNwYXJzZVRlbnNvclByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZGltcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGFyc2VUZW5zb3JQcm90byB2YWx1ZXMuXG4gICAgICAgICAqIEBtZW1iZXIge29ubnguSVRlbnNvclByb3RvfG51bGx8dW5kZWZpbmVkfSB2YWx1ZXNcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBTcGFyc2VUZW5zb3JQcm90by5wcm90b3R5cGUudmFsdWVzID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BhcnNlVGVuc29yUHJvdG8gaW5kaWNlcy5cbiAgICAgICAgICogQG1lbWJlciB7b25ueC5JVGVuc29yUHJvdG98bnVsbHx1bmRlZmluZWR9IGluZGljZXNcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBTcGFyc2VUZW5zb3JQcm90by5wcm90b3R5cGUuaW5kaWNlcyA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwYXJzZVRlbnNvclByb3RvIGRpbXMuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXJ8TG9uZz59IGRpbXNcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBTcGFyc2VUZW5zb3JQcm90by5wcm90b3R5cGUuZGltcyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgU3BhcnNlVGVuc29yUHJvdG8gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlNwYXJzZVRlbnNvclByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklTcGFyc2VUZW5zb3JQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5TcGFyc2VUZW5zb3JQcm90b30gU3BhcnNlVGVuc29yUHJvdG8gaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFNwYXJzZVRlbnNvclByb3RvLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNwYXJzZVRlbnNvclByb3RvKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgU3BhcnNlVGVuc29yUHJvdG8gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5TcGFyc2VUZW5zb3JQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5TcGFyc2VUZW5zb3JQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JU3BhcnNlVGVuc29yUHJvdG99IG1lc3NhZ2UgU3BhcnNlVGVuc29yUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBTcGFyc2VUZW5zb3JQcm90by5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWVzICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ2YWx1ZXNcIikpXG4gICAgICAgICAgICAgICAgJHJvb3Qub25ueC5UZW5zb3JQcm90by5lbmNvZGUobWVzc2FnZS52YWx1ZXMsIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmluZGljZXMgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImluZGljZXNcIikpXG4gICAgICAgICAgICAgICAgJHJvb3Qub25ueC5UZW5zb3JQcm90by5lbmNvZGUobWVzc2FnZS5pbmRpY2VzLCB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kaW1zICE9IG51bGwgJiYgbWVzc2FnZS5kaW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMywgd2lyZVR5cGUgMiA9Ki8yNikuZm9yaygpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5kaW1zLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuaW50NjQobWVzc2FnZS5kaW1zW2ldKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIubGRlbGltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgU3BhcnNlVGVuc29yUHJvdG8gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5TcGFyc2VUZW5zb3JQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5TcGFyc2VUZW5zb3JQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JU3BhcnNlVGVuc29yUHJvdG99IG1lc3NhZ2UgU3BhcnNlVGVuc29yUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBTcGFyc2VUZW5zb3JQcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIFNwYXJzZVRlbnNvclByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge29ubnguU3BhcnNlVGVuc29yUHJvdG99IFNwYXJzZVRlbnNvclByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgU3BhcnNlVGVuc29yUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90bygpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlcyA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluZGljZXMgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5kaW1zICYmIG1lc3NhZ2UuZGltcy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltcy5wdXNoKHJlYWRlci5pbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltcy5wdXNoKHJlYWRlci5pbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIFNwYXJzZVRlbnNvclByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge29ubnguU3BhcnNlVGVuc29yUHJvdG99IFNwYXJzZVRlbnNvclByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgU3BhcnNlVGVuc29yUHJvdG8uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgU3BhcnNlVGVuc29yUHJvdG8gbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5TcGFyc2VUZW5zb3JQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgU3BhcnNlVGVuc29yUHJvdG8udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWVzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlc1wiKSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8udmVyaWZ5KG1lc3NhZ2UudmFsdWVzKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInZhbHVlcy5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5kaWNlcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpbmRpY2VzXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UZW5zb3JQcm90by52ZXJpZnkobWVzc2FnZS5pbmRpY2VzKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImluZGljZXMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRpbXMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGltc1wiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmRpbXMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkaW1zOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5kaW1zLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmRpbXNbaV0pICYmICEobWVzc2FnZS5kaW1zW2ldICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmRpbXNbaV0ubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kaW1zW2ldLmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRpbXM6IGludGVnZXJ8TG9uZ1tdIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIFNwYXJzZVRlbnNvclByb3RvIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguU3BhcnNlVGVuc29yUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlNwYXJzZVRlbnNvclByb3RvfSBTcGFyc2VUZW5zb3JQcm90b1xuICAgICAgICAgKi9cbiAgICAgICAgU3BhcnNlVGVuc29yUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90bylcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5TcGFyc2VUZW5zb3JQcm90bygpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC52YWx1ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnZhbHVlcyAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguU3BhcnNlVGVuc29yUHJvdG8udmFsdWVzOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZXMgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLmZyb21PYmplY3Qob2JqZWN0LnZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LmluZGljZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmluZGljZXMgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlNwYXJzZVRlbnNvclByb3RvLmluZGljZXM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmluZGljZXMgPSAkcm9vdC5vbm54LlRlbnNvclByb3RvLmZyb21PYmplY3Qob2JqZWN0LmluZGljZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5kaW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5kaW1zKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguU3BhcnNlVGVuc29yUHJvdG8uZGltczogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kaW1zID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuZGltcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5kaW1zW2ldID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LmRpbXNbaV0pKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmRpbXNbaV0gPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpbXNbaV0gPSBwYXJzZUludChvYmplY3QuZGltc1tpXSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmRpbXNbaV0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpbXNbaV0gPSBvYmplY3QuZGltc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5kaW1zW2ldID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kaW1zW2ldID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5kaW1zW2ldLmxvdyA+Pj4gMCwgb2JqZWN0LmRpbXNbaV0uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBTcGFyc2VUZW5zb3JQcm90byBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5TcGFyc2VUZW5zb3JQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5TcGFyc2VUZW5zb3JQcm90b30gbWVzc2FnZSBTcGFyc2VUZW5zb3JQcm90b1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFNwYXJzZVRlbnNvclByb3RvLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgICAgIG9iamVjdC5kaW1zID0gW107XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIG9iamVjdC5pbmRpY2VzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZXNcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlcyA9ICRyb290Lm9ubnguVGVuc29yUHJvdG8udG9PYmplY3QobWVzc2FnZS52YWx1ZXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5kaWNlcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpbmRpY2VzXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5pbmRpY2VzID0gJHJvb3Qub25ueC5UZW5zb3JQcm90by50b09iamVjdChtZXNzYWdlLmluZGljZXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGltcyAmJiBtZXNzYWdlLmRpbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRpbXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuZGltcy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmRpbXNbal0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuZGltc1tqXSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmRpbXNbal0pIDogbWVzc2FnZS5kaW1zW2pdO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QuZGltc1tqXSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5kaW1zW2pdKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmRpbXNbal0ubG93ID4+PiAwLCBtZXNzYWdlLmRpbXNbal0uaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UuZGltc1tqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgU3BhcnNlVGVuc29yUHJvdG8gdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5TcGFyc2VUZW5zb3JQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgU3BhcnNlVGVuc29yUHJvdG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBTcGFyc2VUZW5zb3JQcm90b1xuICAgICAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5TcGFyc2VUZW5zb3JQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVmYXVsdCB0eXBlIHVybFxuICAgICAgICAgKi9cbiAgICAgICAgU3BhcnNlVGVuc29yUHJvdG8uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvb25ueC5TcGFyc2VUZW5zb3JQcm90b1wiO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBTcGFyc2VUZW5zb3JQcm90bztcbiAgICB9KSgpO1xuXG4gICAgb25ueC5UZW5zb3JTaGFwZVByb3RvID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgVGVuc29yU2hhcGVQcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGludGVyZmFjZSBJVGVuc29yU2hhcGVQcm90b1xuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LlRlbnNvclNoYXBlUHJvdG8uSURpbWVuc2lvbj58bnVsbH0gW2RpbV0gVGVuc29yU2hhcGVQcm90byBkaW1cbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgVGVuc29yU2hhcGVQcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgVGVuc29yU2hhcGVQcm90by5cbiAgICAgICAgICogQGltcGxlbWVudHMgSVRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yU2hhcGVQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gVGVuc29yU2hhcGVQcm90byhwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLmRpbSA9IFtdO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZW5zb3JTaGFwZVByb3RvIGRpbS5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguVGVuc29yU2hhcGVQcm90by5JRGltZW5zaW9uPn0gZGltXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JTaGFwZVByb3RvLnByb3RvdHlwZS5kaW0gPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFRlbnNvclNoYXBlUHJvdG8gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVRlbnNvclNoYXBlUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yU2hhcGVQcm90b30gVGVuc29yU2hhcGVQcm90byBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yU2hhcGVQcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3JTaGFwZVByb3RvKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVGVuc29yU2hhcGVQcm90byBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlRlbnNvclNoYXBlUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yU2hhcGVQcm90b30gbWVzc2FnZSBUZW5zb3JTaGFwZVByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yU2hhcGVQcm90by5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGltICE9IG51bGwgJiYgbWVzc2FnZS5kaW0ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5kaW0ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24uZW5jb2RlKG1lc3NhZ2UuZGltW2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVGVuc29yU2hhcGVQcm90byBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlRlbnNvclNoYXBlUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7b25ueC5JVGVuc29yU2hhcGVQcm90b30gbWVzc2FnZSBUZW5zb3JTaGFwZVByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yU2hhcGVQcm90by5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIFRlbnNvclNoYXBlUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclNoYXBlUHJvdG99IFRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JTaGFwZVByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90bygpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmRpbSAmJiBtZXNzYWdlLmRpbS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpbS5wdXNoKCRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBUZW5zb3JTaGFwZVByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JTaGFwZVByb3RvfSBUZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yU2hhcGVQcm90by5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYSBUZW5zb3JTaGFwZVByb3RvIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yU2hhcGVQcm90by52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kaW0gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGltXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuZGltKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZGltOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5kaW0ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi52ZXJpZnkobWVzc2FnZS5kaW1baV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkaW0uXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIFRlbnNvclNoYXBlUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UZW5zb3JTaGFwZVByb3RvfSBUZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAqL1xuICAgICAgICBUZW5zb3JTaGFwZVByb3RvLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90bylcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmRpbSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuZGltKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVGVuc29yU2hhcGVQcm90by5kaW06IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuZGltLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmRpbVtpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlRlbnNvclNoYXBlUHJvdG8uZGltOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltW2ldID0gJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi5mcm9tT2JqZWN0KG9iamVjdC5kaW1baV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBUZW5zb3JTaGFwZVByb3RvIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yU2hhcGVQcm90b30gbWVzc2FnZSBUZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgVGVuc29yU2hhcGVQcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cylcbiAgICAgICAgICAgICAgICBvYmplY3QuZGltID0gW107XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kaW0gJiYgbWVzc2FnZS5kaW0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmRpbSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5kaW0ubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5kaW1bal0gPSAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLnRvT2JqZWN0KG1lc3NhZ2UuZGltW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgVGVuc29yU2hhcGVQcm90byB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclNoYXBlUHJvdG8ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBUZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgICAgICovXG4gICAgICAgIFRlbnNvclNoYXBlUHJvdG8uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvb25ueC5UZW5zb3JTaGFwZVByb3RvXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUHJvcGVydGllcyBvZiBhIERpbWVuc2lvbi5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG9cbiAgICAgICAgICAgICAqIEBpbnRlcmZhY2UgSURpbWVuc2lvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ3xudWxsfSBbZGltVmFsdWVdIERpbWVuc2lvbiBkaW1WYWx1ZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW2RpbVBhcmFtXSBEaW1lbnNpb24gZGltUGFyYW1cbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkZW5vdGF0aW9uXSBEaW1lbnNpb24gZGVub3RhdGlvblxuICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBEaW1lbnNpb24uXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvXG4gICAgICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBEaW1lbnNpb24uXG4gICAgICAgICAgICAgKiBAaW1wbGVtZW50cyBJRGltZW5zaW9uXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UZW5zb3JTaGFwZVByb3RvLklEaW1lbnNpb249fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gRGltZW5zaW9uKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERpbWVuc2lvbiBkaW1WYWx1ZS5cbiAgICAgICAgICAgICAqIEBtZW1iZXIge251bWJlcnxMb25nfG51bGx8dW5kZWZpbmVkfSBkaW1WYWx1ZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBEaW1lbnNpb24ucHJvdG90eXBlLmRpbVZhbHVlID0gbnVsbDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEaW1lbnNpb24gZGltUGFyYW0uXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd8bnVsbHx1bmRlZmluZWR9IGRpbVBhcmFtXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIERpbWVuc2lvbi5wcm90b3R5cGUuZGltUGFyYW0gPSBudWxsO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERpbWVuc2lvbiBkZW5vdGF0aW9uLlxuICAgICAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBkZW5vdGF0aW9uXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIERpbWVuc2lvbi5wcm90b3R5cGUuZGVub3RhdGlvbiA9IFwiXCI7XG5cbiAgICAgICAgICAgIC8vIE9uZU9mIGZpZWxkIG5hbWVzIGJvdW5kIHRvIHZpcnR1YWwgZ2V0dGVycyBhbmQgc2V0dGVyc1xuICAgICAgICAgICAgdmFyICRvbmVPZkZpZWxkcztcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEaW1lbnNpb24gdmFsdWUuXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtcImRpbVZhbHVlXCJ8XCJkaW1QYXJhbVwifHVuZGVmaW5lZH0gdmFsdWVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpbWVuc2lvbi5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgICAgIGdldDogJHV0aWwub25lT2ZHZXR0ZXIoJG9uZU9mRmllbGRzID0gW1wiZGltVmFsdWVcIiwgXCJkaW1QYXJhbVwiXSksXG4gICAgICAgICAgICAgICAgc2V0OiAkdXRpbC5vbmVPZlNldHRlcigkb25lT2ZGaWVsZHMpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IERpbWVuc2lvbiBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlRlbnNvclNoYXBlUHJvdG8uSURpbWVuc2lvbj19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb259IERpbWVuc2lvbiBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBEaW1lbnNpb24uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERpbWVuc2lvbihwcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIERpbWVuc2lvbiBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UZW5zb3JTaGFwZVByb3RvLklEaW1lbnNpb259IG1lc3NhZ2UgRGltZW5zaW9uIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIERpbWVuc2lvbi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGltVmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImRpbVZhbHVlXCIpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDAgPSovOCkuaW50NjQobWVzc2FnZS5kaW1WYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGltUGFyYW0gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImRpbVBhcmFtXCIpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovMTgpLnN0cmluZyhtZXNzYWdlLmRpbVBhcmFtKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5kZW5vdGF0aW9uICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJkZW5vdGF0aW9uXCIpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDMsIHdpcmVUeXBlIDIgPSovMjYpLnN0cmluZyhtZXNzYWdlLmRlbm90YXRpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBEaW1lbnNpb24gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbi52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVGVuc29yU2hhcGVQcm90by5JRGltZW5zaW9ufSBtZXNzYWdlIERpbWVuc2lvbiBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBEaW1lbnNpb24uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWNvZGVzIGEgRGltZW5zaW9uIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb259IERpbWVuc2lvblxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBEaW1lbnNpb24uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbigpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltVmFsdWUgPSByZWFkZXIuaW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kaW1QYXJhbSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kZW5vdGF0aW9uID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlY29kZXMgYSBEaW1lbnNpb24gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9uXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtvbm54LlRlbnNvclNoYXBlUHJvdG8uRGltZW5zaW9ufSBEaW1lbnNpb25cbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgRGltZW5zaW9uLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBWZXJpZmllcyBhIERpbWVuc2lvbiBtZXNzYWdlLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgRGltZW5zaW9uLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGltVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGltVmFsdWVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZGltVmFsdWUpICYmICEobWVzc2FnZS5kaW1WYWx1ZSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kaW1WYWx1ZS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmRpbVZhbHVlLmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRpbVZhbHVlOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGltUGFyYW0gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGltUGFyYW1cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMudmFsdWUgPT09IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZTogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuZGltUGFyYW0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZGltUGFyYW06IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5kZW5vdGF0aW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRlbm90YXRpb25cIikpXG4gICAgICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kZW5vdGF0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRlbm90YXRpb246IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgRGltZW5zaW9uIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb259IERpbWVuc2lvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBEaW1lbnNpb24uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb24pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbigpO1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3QuZGltVmFsdWUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5kaW1WYWx1ZSA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5kaW1WYWx1ZSkpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZGltVmFsdWUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpbVZhbHVlID0gcGFyc2VJbnQob2JqZWN0LmRpbVZhbHVlLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZGltVmFsdWUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRpbVZhbHVlID0gb2JqZWN0LmRpbVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmRpbVZhbHVlID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kaW1WYWx1ZSA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuZGltVmFsdWUubG93ID4+PiAwLCBvYmplY3QuZGltVmFsdWUuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0LmRpbVBhcmFtICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGltUGFyYW0gPSBTdHJpbmcob2JqZWN0LmRpbVBhcmFtKTtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0LmRlbm90YXRpb24gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kZW5vdGF0aW9uID0gU3RyaW5nKG9iamVjdC5kZW5vdGF0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgRGltZW5zaW9uIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvbn0gbWVzc2FnZSBEaW1lbnNpb25cbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgRGltZW5zaW9uLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cylcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmRlbm90YXRpb24gPSBcIlwiO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmRpbVZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRpbVZhbHVlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5kaW1WYWx1ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5kaW1WYWx1ZSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmRpbVZhbHVlKSA6IG1lc3NhZ2UuZGltVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5kaW1WYWx1ZSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5kaW1WYWx1ZSkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5kaW1WYWx1ZS5sb3cgPj4+IDAsIG1lc3NhZ2UuZGltVmFsdWUuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UuZGltVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwiZGltVmFsdWVcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGltUGFyYW0gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGltUGFyYW1cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmRpbVBhcmFtID0gbWVzc2FnZS5kaW1QYXJhbTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gXCJkaW1QYXJhbVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5kZW5vdGF0aW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRlbm90YXRpb25cIikpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5kZW5vdGF0aW9uID0gbWVzc2FnZS5kZW5vdGF0aW9uO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnZlcnRzIHRoaXMgRGltZW5zaW9uIHRvIEpTT04uXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIERpbWVuc2lvbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBEaW1lbnNpb25cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UZW5zb3JTaGFwZVByb3RvLkRpbWVuc2lvblxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlVXJsUHJlZml4XSB5b3VyIGN1c3RvbSB0eXBlVXJsUHJlZml4KGRlZmF1bHQgXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVmYXVsdCB0eXBlIHVybFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBEaW1lbnNpb24uZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL29ubnguVGVuc29yU2hhcGVQcm90by5EaW1lbnNpb25cIjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBEaW1lbnNpb247XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgcmV0dXJuIFRlbnNvclNoYXBlUHJvdG87XG4gICAgfSkoKTtcblxuICAgIG9ubnguVHlwZVByb3RvID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgVHlwZVByb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAaW50ZXJmYWNlIElUeXBlUHJvdG9cbiAgICAgICAgICogQHByb3BlcnR5IHtvbm54LlR5cGVQcm90by5JVGVuc29yfG51bGx9IFt0ZW5zb3JUeXBlXSBUeXBlUHJvdG8gdGVuc29yVHlwZVxuICAgICAgICAgKiBAcHJvcGVydHkge29ubnguVHlwZVByb3RvLklTZXF1ZW5jZXxudWxsfSBbc2VxdWVuY2VUeXBlXSBUeXBlUHJvdG8gc2VxdWVuY2VUeXBlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5UeXBlUHJvdG8uSU1hcHxudWxsfSBbbWFwVHlwZV0gVHlwZVByb3RvIG1hcFR5cGVcbiAgICAgICAgICogQHByb3BlcnR5IHtvbm54LlR5cGVQcm90by5JT3B0aW9uYWx8bnVsbH0gW29wdGlvbmFsVHlwZV0gVHlwZVByb3RvIG9wdGlvbmFsVHlwZVxuICAgICAgICAgKiBAcHJvcGVydHkge29ubnguVHlwZVByb3RvLklTcGFyc2VUZW5zb3J8bnVsbH0gW3NwYXJzZVRlbnNvclR5cGVdIFR5cGVQcm90byBzcGFyc2VUZW5zb3JUeXBlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkZW5vdGF0aW9uXSBUeXBlUHJvdG8gZGVub3RhdGlvblxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBUeXBlUHJvdG8uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54XG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFR5cGVQcm90by5cbiAgICAgICAgICogQGltcGxlbWVudHMgSVR5cGVQcm90b1xuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklUeXBlUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFR5cGVQcm90byhwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFR5cGVQcm90byB0ZW5zb3JUeXBlLlxuICAgICAgICAgKiBAbWVtYmVyIHtvbm54LlR5cGVQcm90by5JVGVuc29yfG51bGx8dW5kZWZpbmVkfSB0ZW5zb3JUeXBlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFR5cGVQcm90by5wcm90b3R5cGUudGVuc29yVHlwZSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFR5cGVQcm90byBzZXF1ZW5jZVR5cGUuXG4gICAgICAgICAqIEBtZW1iZXIge29ubnguVHlwZVByb3RvLklTZXF1ZW5jZXxudWxsfHVuZGVmaW5lZH0gc2VxdWVuY2VUeXBlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFR5cGVQcm90by5wcm90b3R5cGUuc2VxdWVuY2VUeXBlID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVHlwZVByb3RvIG1hcFR5cGUuXG4gICAgICAgICAqIEBtZW1iZXIge29ubnguVHlwZVByb3RvLklNYXB8bnVsbHx1bmRlZmluZWR9IG1hcFR5cGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVHlwZVByb3RvLnByb3RvdHlwZS5tYXBUeXBlID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVHlwZVByb3RvIG9wdGlvbmFsVHlwZS5cbiAgICAgICAgICogQG1lbWJlciB7b25ueC5UeXBlUHJvdG8uSU9wdGlvbmFsfG51bGx8dW5kZWZpbmVkfSBvcHRpb25hbFR5cGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgVHlwZVByb3RvLnByb3RvdHlwZS5vcHRpb25hbFR5cGUgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUeXBlUHJvdG8gc3BhcnNlVGVuc29yVHlwZS5cbiAgICAgICAgICogQG1lbWJlciB7b25ueC5UeXBlUHJvdG8uSVNwYXJzZVRlbnNvcnxudWxsfHVuZGVmaW5lZH0gc3BhcnNlVGVuc29yVHlwZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBUeXBlUHJvdG8ucHJvdG90eXBlLnNwYXJzZVRlbnNvclR5cGUgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUeXBlUHJvdG8gZGVub3RhdGlvbi5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBkZW5vdGF0aW9uXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFR5cGVQcm90by5wcm90b3R5cGUuZGVub3RhdGlvbiA9IFwiXCI7XG5cbiAgICAgICAgLy8gT25lT2YgZmllbGQgbmFtZXMgYm91bmQgdG8gdmlydHVhbCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG4gICAgICAgIHZhciAkb25lT2ZGaWVsZHM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFR5cGVQcm90byB2YWx1ZS5cbiAgICAgICAgICogQG1lbWJlciB7XCJ0ZW5zb3JUeXBlXCJ8XCJzZXF1ZW5jZVR5cGVcInxcIm1hcFR5cGVcInxcIm9wdGlvbmFsVHlwZVwifFwic3BhcnNlVGVuc29yVHlwZVwifHVuZGVmaW5lZH0gdmFsdWVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFR5cGVQcm90by5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgZ2V0OiAkdXRpbC5vbmVPZkdldHRlcigkb25lT2ZGaWVsZHMgPSBbXCJ0ZW5zb3JUeXBlXCIsIFwic2VxdWVuY2VUeXBlXCIsIFwibWFwVHlwZVwiLCBcIm9wdGlvbmFsVHlwZVwiLCBcInNwYXJzZVRlbnNvclR5cGVcIl0pLFxuICAgICAgICAgICAgc2V0OiAkdXRpbC5vbmVPZlNldHRlcigkb25lT2ZGaWVsZHMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFR5cGVQcm90byBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklUeXBlUHJvdG89fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvfSBUeXBlUHJvdG8gaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFR5cGVQcm90by5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUeXBlUHJvdG8ocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBUeXBlUHJvdG8gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UeXBlUHJvdG8udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklUeXBlUHJvdG99IG1lc3NhZ2UgVHlwZVByb3RvIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgVHlwZVByb3RvLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ZW5zb3JUeXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ0ZW5zb3JUeXBlXCIpKVxuICAgICAgICAgICAgICAgICRyb290Lm9ubnguVHlwZVByb3RvLlRlbnNvci5lbmNvZGUobWVzc2FnZS50ZW5zb3JUeXBlLCB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zZXF1ZW5jZVR5cGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInNlcXVlbmNlVHlwZVwiKSlcbiAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS5lbmNvZGUobWVzc2FnZS5zZXF1ZW5jZVR5cGUsIHdyaXRlci51aW50MzIoLyogaWQgNCwgd2lyZVR5cGUgMiA9Ki8zNCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1hcFR5cGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIm1hcFR5cGVcIikpXG4gICAgICAgICAgICAgICAgJHJvb3Qub25ueC5UeXBlUHJvdG8uTWFwLmVuY29kZShtZXNzYWdlLm1hcFR5cGUsIHdyaXRlci51aW50MzIoLyogaWQgNSwgd2lyZVR5cGUgMiA9Ki80MikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRlbm90YXRpb24gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImRlbm90YXRpb25cIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA2LCB3aXJlVHlwZSAyID0qLzUwKS5zdHJpbmcobWVzc2FnZS5kZW5vdGF0aW9uKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnNwYXJzZVRlbnNvclR5cGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInNwYXJzZVRlbnNvclR5cGVcIikpXG4gICAgICAgICAgICAgICAgJHJvb3Qub25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yLmVuY29kZShtZXNzYWdlLnNwYXJzZVRlbnNvclR5cGUsIHdyaXRlci51aW50MzIoLyogaWQgOCwgd2lyZVR5cGUgMiA9Ki82NikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm9wdGlvbmFsVHlwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwib3B0aW9uYWxUeXBlXCIpKVxuICAgICAgICAgICAgICAgICRyb290Lm9ubnguVHlwZVByb3RvLk9wdGlvbmFsLmVuY29kZShtZXNzYWdlLm9wdGlvbmFsVHlwZSwgd3JpdGVyLnVpbnQzMigvKiBpZCA5LCB3aXJlVHlwZSAyID0qLzc0KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFR5cGVQcm90byBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlR5cGVQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSVR5cGVQcm90b30gbWVzc2FnZSBUeXBlUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBUeXBlUHJvdG8uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBUeXBlUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvfSBUeXBlUHJvdG9cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBUeXBlUHJvdG8uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UeXBlUHJvdG8oKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50ZW5zb3JUeXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uVGVuc29yLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZXF1ZW5jZVR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWFwVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLk1hcC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3B0aW9uYWxUeXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uT3B0aW9uYWwuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNwYXJzZVRlbnNvclR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3IuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA2OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRlbm90YXRpb24gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBUeXBlUHJvdG8gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvfSBUeXBlUHJvdG9cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBUeXBlUHJvdG8uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgVHlwZVByb3RvIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBUeXBlUHJvdG8udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRlbnNvclR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidGVuc29yVHlwZVwiKSkge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uVGVuc29yLnZlcmlmeShtZXNzYWdlLnRlbnNvclR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0ZW5zb3JUeXBlLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc2VxdWVuY2VUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInNlcXVlbmNlVHlwZVwiKSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnZhbHVlID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZTogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS52ZXJpZnkobWVzc2FnZS5zZXF1ZW5jZVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzZXF1ZW5jZVR5cGUuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXBUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm1hcFR5cGVcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy52YWx1ZSA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uTWFwLnZlcmlmeShtZXNzYWdlLm1hcFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJtYXBUeXBlLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uub3B0aW9uYWxUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm9wdGlvbmFsVHlwZVwiKSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnZhbHVlID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZTogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlR5cGVQcm90by5PcHRpb25hbC52ZXJpZnkobWVzc2FnZS5vcHRpb25hbFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvcHRpb25hbFR5cGUuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zcGFyc2VUZW5zb3JUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInNwYXJzZVRlbnNvclR5cGVcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy52YWx1ZSA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yLnZlcmlmeShtZXNzYWdlLnNwYXJzZVRlbnNvclR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzcGFyc2VUZW5zb3JUeXBlLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVub3RhdGlvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkZW5vdGF0aW9uXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kZW5vdGF0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZGVub3RhdGlvbjogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIFR5cGVQcm90byBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvfSBUeXBlUHJvdG9cbiAgICAgICAgICovXG4gICAgICAgIFR5cGVQcm90by5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54LlR5cGVQcm90bylcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UeXBlUHJvdG8oKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QudGVuc29yVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudGVuc29yVHlwZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHlwZVByb3RvLnRlbnNvclR5cGU6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnRlbnNvclR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5UZW5zb3IuZnJvbU9iamVjdChvYmplY3QudGVuc29yVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LnNlcXVlbmNlVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Quc2VxdWVuY2VUeXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UeXBlUHJvdG8uc2VxdWVuY2VUeXBlOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5zZXF1ZW5jZVR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS5mcm9tT2JqZWN0KG9iamVjdC5zZXF1ZW5jZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5tYXBUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5tYXBUeXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UeXBlUHJvdG8ubWFwVHlwZTogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UubWFwVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLk1hcC5mcm9tT2JqZWN0KG9iamVjdC5tYXBUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3Qub3B0aW9uYWxUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5vcHRpb25hbFR5cGUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlR5cGVQcm90by5vcHRpb25hbFR5cGU6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm9wdGlvbmFsVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLk9wdGlvbmFsLmZyb21PYmplY3Qob2JqZWN0Lm9wdGlvbmFsVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LnNwYXJzZVRlbnNvclR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnNwYXJzZVRlbnNvclR5cGUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlR5cGVQcm90by5zcGFyc2VUZW5zb3JUeXBlOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5zcGFyc2VUZW5zb3JUeXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yLmZyb21PYmplY3Qob2JqZWN0LnNwYXJzZVRlbnNvclR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5kZW5vdGF0aW9uICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kZW5vdGF0aW9uID0gU3RyaW5nKG9iamVjdC5kZW5vdGF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBUeXBlUHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90b30gbWVzc2FnZSBUeXBlUHJvdG9cbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBUeXBlUHJvdG8udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmRlbm90YXRpb24gPSBcIlwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVuc29yVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0ZW5zb3JUeXBlXCIpKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnRlbnNvclR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5UZW5zb3IudG9PYmplY3QobWVzc2FnZS50ZW5zb3JUeXBlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwidGVuc29yVHlwZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc2VxdWVuY2VUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInNlcXVlbmNlVHlwZVwiKSkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5zZXF1ZW5jZVR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS50b09iamVjdChtZXNzYWdlLnNlcXVlbmNlVHlwZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBcInNlcXVlbmNlVHlwZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWFwVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJtYXBUeXBlXCIpKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm1hcFR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5NYXAudG9PYmplY3QobWVzc2FnZS5tYXBUeXBlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwibWFwVHlwZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVub3RhdGlvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkZW5vdGF0aW9uXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5kZW5vdGF0aW9uID0gbWVzc2FnZS5kZW5vdGF0aW9uO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc3BhcnNlVGVuc29yVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzcGFyc2VUZW5zb3JUeXBlXCIpKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnNwYXJzZVRlbnNvclR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3IudG9PYmplY3QobWVzc2FnZS5zcGFyc2VUZW5zb3JUeXBlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwic3BhcnNlVGVuc29yVHlwZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uub3B0aW9uYWxUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm9wdGlvbmFsVHlwZVwiKSkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5vcHRpb25hbFR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5PcHRpb25hbC50b09iamVjdChtZXNzYWdlLm9wdGlvbmFsVHlwZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBcIm9wdGlvbmFsVHlwZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBUeXBlUHJvdG8gdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFR5cGVQcm90by5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGRlZmF1bHQgdHlwZSB1cmwgZm9yIFR5cGVQcm90b1xuICAgICAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgICAgICovXG4gICAgICAgIFR5cGVQcm90by5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9vbm54LlR5cGVQcm90b1wiO1xuICAgICAgICB9O1xuXG4gICAgICAgIFR5cGVQcm90by5UZW5zb3IgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUHJvcGVydGllcyBvZiBhIFRlbnNvci5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICAgICAgICogQGludGVyZmFjZSBJVGVuc29yXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbZWxlbVR5cGVdIFRlbnNvciBlbGVtVHlwZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtvbm54LklUZW5zb3JTaGFwZVByb3RvfG51bGx9IFtzaGFwZV0gVGVuc29yIHNoYXBlXG4gICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFRlbnNvci5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgVGVuc29yLlxuICAgICAgICAgICAgICogQGltcGxlbWVudHMgSVRlbnNvclxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklUZW5zb3I9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gVGVuc29yKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRlbnNvciBlbGVtVHlwZS5cbiAgICAgICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gZWxlbVR5cGVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBUZW5zb3IucHJvdG90eXBlLmVsZW1UeXBlID0gMDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUZW5zb3Igc2hhcGUuXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtvbm54LklUZW5zb3JTaGFwZVByb3RvfG51bGx8dW5kZWZpbmVkfSBzaGFwZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlRlbnNvclxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFRlbnNvci5wcm90b3R5cGUuc2hhcGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYSBuZXcgVGVuc29yIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uSVRlbnNvcj19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLlRlbnNvcn0gVGVuc29yIGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFRlbnNvci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGVuc29yKHByb3BlcnRpZXMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgVGVuc29yIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVHlwZVByb3RvLlRlbnNvci52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uSVRlbnNvcn0gbWVzc2FnZSBUZW5zb3IgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVGVuc29yLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lbGVtVHlwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiZWxlbVR5cGVcIikpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMCA9Ki84KS5pbnQzMihtZXNzYWdlLmVsZW1UeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5zaGFwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwic2hhcGVcIikpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5lbmNvZGUobWVzc2FnZS5zaGFwZSwgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLzE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBUZW5zb3IgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UeXBlUHJvdG8uVGVuc29yLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlRlbnNvclxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JVGVuc29yfSBtZXNzYWdlIFRlbnNvciBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBUZW5zb3IuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWNvZGVzIGEgVGVuc29yIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uVGVuc29yXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uVGVuc29yfSBUZW5zb3JcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVGVuc29yLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVHlwZVByb3RvLlRlbnNvcigpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZWxlbVR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaGFwZSA9ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlY29kZXMgYSBUZW5zb3IgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLlRlbnNvcn0gVGVuc29yXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFRlbnNvci5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVmVyaWZpZXMgYSBUZW5zb3IgbWVzc2FnZS5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVGVuc29yLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmVsZW1UeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImVsZW1UeXBlXCIpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmVsZW1UeXBlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImVsZW1UeXBlOiBpbnRlZ2VyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc2hhcGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic2hhcGVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLnZlcmlmeShtZXNzYWdlLnNoYXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic2hhcGUuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYSBUZW5zb3IgbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90by5UZW5zb3J9IFRlbnNvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBUZW5zb3IuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVHlwZVByb3RvLlRlbnNvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlR5cGVQcm90by5UZW5zb3IoKTtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0LmVsZW1UeXBlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZWxlbVR5cGUgPSBvYmplY3QuZWxlbVR5cGUgfCAwO1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3Quc2hhcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5zaGFwZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlR5cGVQcm90by5UZW5zb3Iuc2hhcGU6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaGFwZSA9ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by5mcm9tT2JqZWN0KG9iamVjdC5zaGFwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBUZW5zb3IgbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uVGVuc29yXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLlRlbnNvcn0gbWVzc2FnZSBUZW5zb3JcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVGVuc29yLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3QuZWxlbVR5cGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICBvYmplY3Quc2hhcGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lbGVtVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJlbGVtVHlwZVwiKSlcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmVsZW1UeXBlID0gbWVzc2FnZS5lbGVtVHlwZTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5zaGFwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzaGFwZVwiKSlcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnNoYXBlID0gJHJvb3Qub25ueC5UZW5zb3JTaGFwZVByb3RvLnRvT2JqZWN0KG1lc3NhZ2Uuc2hhcGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnZlcnRzIHRoaXMgVGVuc29yIHRvIEpTT04uXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uVGVuc29yXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVGVuc29yLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGRlZmF1bHQgdHlwZSB1cmwgZm9yIFRlbnNvclxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGdldFR5cGVVcmxcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5UZW5zb3JcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGRlZmF1bHQgdHlwZSB1cmxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVGVuc29yLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9vbm54LlR5cGVQcm90by5UZW5zb3JcIjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBUZW5zb3I7XG4gICAgICAgIH0pKCk7XG5cbiAgICAgICAgVHlwZVByb3RvLlNlcXVlbmNlID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBTZXF1ZW5jZS5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICAgICAgICogQGludGVyZmFjZSBJU2VxdWVuY2VcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JVHlwZVByb3RvfG51bGx9IFtlbGVtVHlwZV0gU2VxdWVuY2UgZWxlbVR5cGVcbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgU2VxdWVuY2UuXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFNlcXVlbmNlLlxuICAgICAgICAgICAgICogQGltcGxlbWVudHMgSVNlcXVlbmNlXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uSVNlcXVlbmNlPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIFNlcXVlbmNlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNlcXVlbmNlIGVsZW1UeXBlLlxuICAgICAgICAgICAgICogQG1lbWJlciB7b25ueC5JVHlwZVByb3RvfG51bGx8dW5kZWZpbmVkfSBlbGVtVHlwZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNlcXVlbmNlXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU2VxdWVuY2UucHJvdG90eXBlLmVsZW1UeXBlID0gbnVsbDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFNlcXVlbmNlIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5TZXF1ZW5jZVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JU2VxdWVuY2U9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90by5TZXF1ZW5jZX0gU2VxdWVuY2UgaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU2VxdWVuY2UuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNlcXVlbmNlKHByb3BlcnRpZXMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgU2VxdWVuY2UgbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UeXBlUHJvdG8uU2VxdWVuY2UudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU2VxdWVuY2VcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uSVNlcXVlbmNlfSBtZXNzYWdlIFNlcXVlbmNlIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNlcXVlbmNlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lbGVtVHlwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiZWxlbVR5cGVcIikpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguVHlwZVByb3RvLmVuY29kZShtZXNzYWdlLmVsZW1UeXBlLCB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFNlcXVlbmNlIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVHlwZVByb3RvLlNlcXVlbmNlLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNlcXVlbmNlXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklTZXF1ZW5jZX0gbWVzc2FnZSBTZXF1ZW5jZSBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTZXF1ZW5jZS5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlY29kZXMgYSBTZXF1ZW5jZSBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNlcXVlbmNlXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uU2VxdWVuY2V9IFNlcXVlbmNlXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNlcXVlbmNlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVHlwZVByb3RvLlNlcXVlbmNlKCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lbGVtVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGVjb2RlcyBhIFNlcXVlbmNlIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU2VxdWVuY2VcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLlNlcXVlbmNlfSBTZXF1ZW5jZVxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTZXF1ZW5jZS5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVmVyaWZpZXMgYSBTZXF1ZW5jZSBtZXNzYWdlLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNlcXVlbmNlXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNlcXVlbmNlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmVsZW1UeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImVsZW1UeXBlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVHlwZVByb3RvLnZlcmlmeShtZXNzYWdlLmVsZW1UeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZWxlbVR5cGUuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYSBTZXF1ZW5jZSBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNlcXVlbmNlXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uU2VxdWVuY2V9IFNlcXVlbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNlcXVlbmNlLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54LlR5cGVQcm90by5TZXF1ZW5jZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlR5cGVQcm90by5TZXF1ZW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3QuZWxlbVR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5lbGVtVHlwZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LlR5cGVQcm90by5TZXF1ZW5jZS5lbGVtVHlwZTogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVsZW1UeXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uZnJvbU9iamVjdChvYmplY3QuZWxlbVR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgU2VxdWVuY2UgbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU2VxdWVuY2VcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uU2VxdWVuY2V9IG1lc3NhZ2UgU2VxdWVuY2VcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU2VxdWVuY2UudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuZWxlbVR5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmVsZW1UeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImVsZW1UeXBlXCIpKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuZWxlbVR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by50b09iamVjdChtZXNzYWdlLmVsZW1UeXBlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIFNlcXVlbmNlIHRvIEpTT04uXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU2VxdWVuY2VcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTZXF1ZW5jZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBTZXF1ZW5jZVxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGdldFR5cGVVcmxcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5TZXF1ZW5jZVxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlVXJsUHJlZml4XSB5b3VyIGN1c3RvbSB0eXBlVXJsUHJlZml4KGRlZmF1bHQgXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVmYXVsdCB0eXBlIHVybFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTZXF1ZW5jZS5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvb25ueC5UeXBlUHJvdG8uU2VxdWVuY2VcIjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBTZXF1ZW5jZTtcbiAgICAgICAgfSkoKTtcblxuICAgICAgICBUeXBlUHJvdG8uTWFwID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBNYXAuXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICAgICAqIEBpbnRlcmZhY2UgSU1hcFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW2tleVR5cGVdIE1hcCBrZXlUeXBlXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge29ubnguSVR5cGVQcm90b3xudWxsfSBbdmFsdWVUeXBlXSBNYXAgdmFsdWVUeXBlXG4gICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IE1hcC5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgTWFwLlxuICAgICAgICAgICAgICogQGltcGxlbWVudHMgSU1hcFxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklNYXA9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gTWFwKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1hcCBrZXlUeXBlLlxuICAgICAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBrZXlUeXBlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uTWFwXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5rZXlUeXBlID0gMDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNYXAgdmFsdWVUeXBlLlxuICAgICAgICAgICAgICogQG1lbWJlciB7b25ueC5JVHlwZVByb3RvfG51bGx8dW5kZWZpbmVkfSB2YWx1ZVR5cGVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5NYXBcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBNYXAucHJvdG90eXBlLnZhbHVlVHlwZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBNYXAgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk1hcFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JTWFwPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uTWFwfSBNYXAgaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgTWFwLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXAocHJvcGVydGllcyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBNYXAgbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5UeXBlUHJvdG8uTWFwLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk1hcFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JTWFwfSBtZXNzYWdlIE1hcCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBNYXAuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmtleVR5cGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImtleVR5cGVcIikpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMCA9Ki84KS5pbnQzMihtZXNzYWdlLmtleVR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlVHlwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwidmFsdWVUeXBlXCIpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlR5cGVQcm90by5lbmNvZGUobWVzc2FnZS52YWx1ZVR5cGUsIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8xOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgTWFwIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVHlwZVByb3RvLk1hcC52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5NYXBcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uSU1hcH0gbWVzc2FnZSBNYXAgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgTWFwLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGVjb2RlcyBhIE1hcCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk1hcFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLk1hcH0gTWFwXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIE1hcC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlR5cGVQcm90by5NYXAoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtleVR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZVR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlY29kZXMgYSBNYXAgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5NYXBcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLk1hcH0gTWFwXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIE1hcC5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVmVyaWZpZXMgYSBNYXAgbWVzc2FnZS5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5NYXBcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgTWFwLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmtleVR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwia2V5VHlwZVwiKSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5rZXlUeXBlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImtleVR5cGU6IGludGVnZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZVR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidmFsdWVUeXBlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVHlwZVByb3RvLnZlcmlmeShtZXNzYWdlLnZhbHVlVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInZhbHVlVHlwZS5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIE1hcCBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk1hcFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLk1hcH0gTWFwXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIE1hcC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5UeXBlUHJvdG8uTWFwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVHlwZVByb3RvLk1hcCgpO1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3Qua2V5VHlwZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtleVR5cGUgPSBvYmplY3Qua2V5VHlwZSB8IDA7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdC52YWx1ZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC52YWx1ZVR5cGUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UeXBlUHJvdG8uTWFwLnZhbHVlVHlwZTogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlVHlwZSA9ICRyb290Lm9ubnguVHlwZVByb3RvLmZyb21PYmplY3Qob2JqZWN0LnZhbHVlVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBNYXAgbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uTWFwXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLk1hcH0gbWVzc2FnZSBNYXBcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgTWFwLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3Qua2V5VHlwZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZVR5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5rZXlUeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImtleVR5cGVcIikpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5rZXlUeXBlID0gbWVzc2FnZS5rZXlUeXBlO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVR5cGVcIikpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZVR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by50b09iamVjdChtZXNzYWdlLnZhbHVlVHlwZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29udmVydHMgdGhpcyBNYXAgdG8gSlNPTi5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5NYXBcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBNYXAucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgTWFwXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZ2V0VHlwZVVybFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk1hcFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlVXJsUHJlZml4XSB5b3VyIGN1c3RvbSB0eXBlVXJsUHJlZml4KGRlZmF1bHQgXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVmYXVsdCB0eXBlIHVybFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBNYXAuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL29ubnguVHlwZVByb3RvLk1hcFwiO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIE1hcDtcbiAgICAgICAgfSkoKTtcblxuICAgICAgICBUeXBlUHJvdG8uT3B0aW9uYWwgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUHJvcGVydGllcyBvZiBhbiBPcHRpb25hbC5cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90b1xuICAgICAgICAgICAgICogQGludGVyZmFjZSBJT3B0aW9uYWxcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JVHlwZVByb3RvfG51bGx9IFtlbGVtVHlwZV0gT3B0aW9uYWwgZWxlbVR5cGVcbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgT3B0aW9uYWwuXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhbiBPcHRpb25hbC5cbiAgICAgICAgICAgICAqIEBpbXBsZW1lbnRzIElPcHRpb25hbFxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklPcHRpb25hbD19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBPcHRpb25hbChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPcHRpb25hbCBlbGVtVHlwZS5cbiAgICAgICAgICAgICAqIEBtZW1iZXIge29ubnguSVR5cGVQcm90b3xudWxsfHVuZGVmaW5lZH0gZWxlbVR5cGVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5PcHRpb25hbFxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIE9wdGlvbmFsLnByb3RvdHlwZS5lbGVtVHlwZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBPcHRpb25hbCBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uT3B0aW9uYWxcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uSU9wdGlvbmFsPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uT3B0aW9uYWx9IE9wdGlvbmFsIGluc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIE9wdGlvbmFsLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBPcHRpb25hbChwcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIE9wdGlvbmFsIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVHlwZVByb3RvLk9wdGlvbmFsLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLk9wdGlvbmFsXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklPcHRpb25hbH0gbWVzc2FnZSBPcHRpb25hbCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBPcHRpb25hbC5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZWxlbVR5cGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImVsZW1UeXBlXCIpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlR5cGVQcm90by5lbmNvZGUobWVzc2FnZS5lbGVtVHlwZSwgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLzEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBPcHRpb25hbCBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlR5cGVQcm90by5PcHRpb25hbC52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5PcHRpb25hbFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JT3B0aW9uYWx9IG1lc3NhZ2UgT3B0aW9uYWwgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgT3B0aW9uYWwuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWNvZGVzIGFuIE9wdGlvbmFsIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uT3B0aW9uYWxcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90by5PcHRpb25hbH0gT3B0aW9uYWxcbiAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgT3B0aW9uYWwuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UeXBlUHJvdG8uT3B0aW9uYWwoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVsZW1UeXBlID0gJHJvb3Qub25ueC5UeXBlUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWNvZGVzIGFuIE9wdGlvbmFsIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uT3B0aW9uYWxcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLk9wdGlvbmFsfSBPcHRpb25hbFxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBPcHRpb25hbC5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVmVyaWZpZXMgYW4gT3B0aW9uYWwgbWVzc2FnZS5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5PcHRpb25hbFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBPcHRpb25hbC52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lbGVtVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJlbGVtVHlwZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LlR5cGVQcm90by52ZXJpZnkobWVzc2FnZS5lbGVtVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImVsZW1UeXBlLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGFuIE9wdGlvbmFsIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uT3B0aW9uYWxcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90by5PcHRpb25hbH0gT3B0aW9uYWxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgT3B0aW9uYWwuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm9ubnguVHlwZVByb3RvLk9wdGlvbmFsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguVHlwZVByb3RvLk9wdGlvbmFsKCk7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdC5lbGVtVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmVsZW1UeXBlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguVHlwZVByb3RvLk9wdGlvbmFsLmVsZW1UeXBlOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZWxlbVR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by5mcm9tT2JqZWN0KG9iamVjdC5lbGVtVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYW4gT3B0aW9uYWwgbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uT3B0aW9uYWxcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uT3B0aW9uYWx9IG1lc3NhZ2UgT3B0aW9uYWxcbiAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgT3B0aW9uYWwudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuZWxlbVR5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmVsZW1UeXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImVsZW1UeXBlXCIpKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuZWxlbVR5cGUgPSAkcm9vdC5vbm54LlR5cGVQcm90by50b09iamVjdChtZXNzYWdlLmVsZW1UeXBlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIE9wdGlvbmFsIHRvIEpTT04uXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uT3B0aW9uYWxcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBPcHRpb25hbC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBPcHRpb25hbFxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGdldFR5cGVVcmxcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5PcHRpb25hbFxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlVXJsUHJlZml4XSB5b3VyIGN1c3RvbSB0eXBlVXJsUHJlZml4KGRlZmF1bHQgXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCIpXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVmYXVsdCB0eXBlIHVybFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBPcHRpb25hbC5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvb25ueC5UeXBlUHJvdG8uT3B0aW9uYWxcIjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBPcHRpb25hbDtcbiAgICAgICAgfSkoKTtcblxuICAgICAgICBUeXBlUHJvdG8uU3BhcnNlVGVuc29yID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBTcGFyc2VUZW5zb3IuXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICAgICAqIEBpbnRlcmZhY2UgSVNwYXJzZVRlbnNvclxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW2VsZW1UeXBlXSBTcGFyc2VUZW5zb3IgZWxlbVR5cGVcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7b25ueC5JVGVuc29yU2hhcGVQcm90b3xudWxsfSBbc2hhcGVdIFNwYXJzZVRlbnNvciBzaGFwZVxuICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBTcGFyc2VUZW5zb3IuXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG9cbiAgICAgICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFNwYXJzZVRlbnNvci5cbiAgICAgICAgICAgICAqIEBpbXBsZW1lbnRzIElTcGFyc2VUZW5zb3JcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5JU3BhcnNlVGVuc29yPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIFNwYXJzZVRlbnNvcihwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTcGFyc2VUZW5zb3IgZWxlbVR5cGUuXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGVsZW1UeXBlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yXG4gICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU3BhcnNlVGVuc29yLnByb3RvdHlwZS5lbGVtVHlwZSA9IDA7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3BhcnNlVGVuc29yIHNoYXBlLlxuICAgICAgICAgICAgICogQG1lbWJlciB7b25ueC5JVGVuc29yU2hhcGVQcm90b3xudWxsfHVuZGVmaW5lZH0gc2hhcGVcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3JcbiAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTcGFyc2VUZW5zb3IucHJvdG90eXBlLnNoYXBlID0gbnVsbDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFNwYXJzZVRlbnNvciBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklTcGFyc2VUZW5zb3I9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3J9IFNwYXJzZVRlbnNvciBpbnN0YW5jZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTcGFyc2VUZW5zb3IuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNwYXJzZVRlbnNvcihwcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFNwYXJzZVRlbnNvciBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3IudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29ubnguVHlwZVByb3RvLklTcGFyc2VUZW5zb3J9IG1lc3NhZ2UgU3BhcnNlVGVuc29yIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNwYXJzZVRlbnNvci5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZWxlbVR5cGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImVsZW1UeXBlXCIpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDAgPSovOCkuaW50MzIobWVzc2FnZS5lbGVtVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc2hhcGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInNoYXBlXCIpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8uZW5jb2RlKG1lc3NhZ2Uuc2hhcGUsIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8xOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgU3BhcnNlVGVuc29yIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvci52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBvbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3JcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b25ueC5UeXBlUHJvdG8uSVNwYXJzZVRlbnNvcn0gbWVzc2FnZSBTcGFyc2VUZW5zb3IgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU3BhcnNlVGVuc29yLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGVjb2RlcyBhIFNwYXJzZVRlbnNvciBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvclxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgICAgICogQHJldHVybnMge29ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvcn0gU3BhcnNlVGVuc29yXG4gICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNwYXJzZVRlbnNvci5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3IoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVsZW1UeXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2hhcGUgPSAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWNvZGVzIGEgU3BhcnNlVGVuc29yIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtvbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3J9IFNwYXJzZVRlbnNvclxuICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTcGFyc2VUZW5zb3IuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFZlcmlmaWVzIGEgU3BhcnNlVGVuc29yIG1lc3NhZ2UuXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNwYXJzZVRlbnNvci52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5lbGVtVHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJlbGVtVHlwZVwiKSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5lbGVtVHlwZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJlbGVtVHlwZTogaW50ZWdlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnNoYXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInNoYXBlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by52ZXJpZnkobWVzc2FnZS5zaGFwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInNoYXBlLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgU3BhcnNlVGVuc29yIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yfSBTcGFyc2VUZW5zb3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU3BhcnNlVGVuc29yLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3Qub25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yKCk7XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdC5lbGVtVHlwZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVsZW1UeXBlID0gb2JqZWN0LmVsZW1UeXBlIHwgMDtcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0LnNoYXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Quc2hhcGUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yLnNoYXBlOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2hhcGUgPSAkcm9vdC5vbm54LlRlbnNvclNoYXBlUHJvdG8uZnJvbU9iamVjdChvYmplY3Quc2hhcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgU3BhcnNlVGVuc29yIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvclxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHBhcmFtIHtvbm54LlR5cGVQcm90by5TcGFyc2VUZW5zb3J9IG1lc3NhZ2UgU3BhcnNlVGVuc29yXG4gICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNwYXJzZVRlbnNvci50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmVsZW1UeXBlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnNoYXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZWxlbVR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZWxlbVR5cGVcIikpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5lbGVtVHlwZSA9IG1lc3NhZ2UuZWxlbVR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc2hhcGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic2hhcGVcIikpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5zaGFwZSA9ICRyb290Lm9ubnguVGVuc29yU2hhcGVQcm90by50b09iamVjdChtZXNzYWdlLnNoYXBlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIFNwYXJzZVRlbnNvciB0byBKU09OLlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG9ubnguVHlwZVByb3RvLlNwYXJzZVRlbnNvclxuICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNwYXJzZVRlbnNvci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IHR5cGUgdXJsIGZvciBTcGFyc2VUZW5zb3JcbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVVcmxQcmVmaXhdIHlvdXIgY3VzdG9tIHR5cGVVcmxQcmVmaXgoZGVmYXVsdCBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIilcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBkZWZhdWx0IHR5cGUgdXJsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNwYXJzZVRlbnNvci5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvb25ueC5UeXBlUHJvdG8uU3BhcnNlVGVuc29yXCI7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gU3BhcnNlVGVuc29yO1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIHJldHVybiBUeXBlUHJvdG87XG4gICAgfSkoKTtcblxuICAgIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGFuIE9wZXJhdG9yU2V0SWRQcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGludGVyZmFjZSBJT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtkb21haW5dIE9wZXJhdG9yU2V0SWRQcm90byBkb21haW5cbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ3xudWxsfSBbdmVyc2lvbl0gT3BlcmF0b3JTZXRJZFByb3RvIHZlcnNpb25cbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgT3BlcmF0b3JTZXRJZFByb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYW4gT3BlcmF0b3JTZXRJZFByb3RvLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge29ubnguSU9wZXJhdG9yU2V0SWRQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gT3BlcmF0b3JTZXRJZFByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogT3BlcmF0b3JTZXRJZFByb3RvIGRvbWFpbi5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBkb21haW5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgT3BlcmF0b3JTZXRJZFByb3RvLnByb3RvdHlwZS5kb21haW4gPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcGVyYXRvclNldElkUHJvdG8gdmVyc2lvbi5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfExvbmd9IHZlcnNpb25cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgT3BlcmF0b3JTZXRJZFByb3RvLnByb3RvdHlwZS52ZXJzaW9uID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgT3BlcmF0b3JTZXRJZFByb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5PcGVyYXRvclNldElkUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSU9wZXJhdG9yU2V0SWRQcm90bz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5PcGVyYXRvclNldElkUHJvdG99IE9wZXJhdG9yU2V0SWRQcm90byBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgT3BlcmF0b3JTZXRJZFByb3RvLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE9wZXJhdG9yU2V0SWRQcm90byhwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIE9wZXJhdG9yU2V0SWRQcm90byBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54Lk9wZXJhdG9yU2V0SWRQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5PcGVyYXRvclNldElkUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSU9wZXJhdG9yU2V0SWRQcm90b30gbWVzc2FnZSBPcGVyYXRvclNldElkUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBPcGVyYXRvclNldElkUHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvbWFpbiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiZG9tYWluXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuc3RyaW5nKG1lc3NhZ2UuZG9tYWluKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZlcnNpb24gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInZlcnNpb25cIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAwID0qLzE2KS5pbnQ2NChtZXNzYWdlLnZlcnNpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIE9wZXJhdG9yU2V0SWRQcm90byBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBvbm54Lk9wZXJhdG9yU2V0SWRQcm90by52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5PcGVyYXRvclNldElkUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSU9wZXJhdG9yU2V0SWRQcm90b30gbWVzc2FnZSBPcGVyYXRvclNldElkUHJvdG8gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBPcGVyYXRvclNldElkUHJvdG8uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYW4gT3BlcmF0b3JTZXRJZFByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54Lk9wZXJhdG9yU2V0SWRQcm90b30gT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgT3BlcmF0b3JTZXRJZFByb3RvLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguT3BlcmF0b3JTZXRJZFByb3RvKCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG9tYWluID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmVyc2lvbiA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGFuIE9wZXJhdG9yU2V0SWRQcm90byBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5PcGVyYXRvclNldElkUHJvdG99IE9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIE9wZXJhdG9yU2V0SWRQcm90by5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYW4gT3BlcmF0b3JTZXRJZFByb3RvIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBPcGVyYXRvclNldElkUHJvdG8udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvbWFpblwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuZG9tYWluKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZG9tYWluOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZlcnNpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidmVyc2lvblwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnZlcnNpb24pICYmICEobWVzc2FnZS52ZXJzaW9uICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnZlcnNpb24ubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS52ZXJzaW9uLmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidmVyc2lvbjogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBPcGVyYXRvclNldElkUHJvdG8gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5PcGVyYXRvclNldElkUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54Lk9wZXJhdG9yU2V0SWRQcm90b30gT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqL1xuICAgICAgICBPcGVyYXRvclNldElkUHJvdG8uZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3Qub25ueC5PcGVyYXRvclNldElkUHJvdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguT3BlcmF0b3JTZXRJZFByb3RvKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmRvbWFpbiAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG9tYWluID0gU3RyaW5nKG9iamVjdC5kb21haW4pO1xuICAgICAgICAgICAgaWYgKG9iamVjdC52ZXJzaW9uICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgICAgICAgIChtZXNzYWdlLnZlcnNpb24gPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QudmVyc2lvbikpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC52ZXJzaW9uID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZlcnNpb24gPSBwYXJzZUludChvYmplY3QudmVyc2lvbiwgMTApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QudmVyc2lvbiA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52ZXJzaW9uID0gb2JqZWN0LnZlcnNpb247XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC52ZXJzaW9uID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZlcnNpb24gPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LnZlcnNpb24ubG93ID4+PiAwLCBvYmplY3QudmVyc2lvbi5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhbiBPcGVyYXRvclNldElkUHJvdG8gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54Lk9wZXJhdG9yU2V0SWRQcm90b30gbWVzc2FnZSBPcGVyYXRvclNldElkUHJvdG9cbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBPcGVyYXRvclNldElkUHJvdG8udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9tYWluID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnZlcnNpb24gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QudmVyc2lvbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFwiMFwiIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvbWFpbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb21haW5cIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmRvbWFpbiA9IG1lc3NhZ2UuZG9tYWluO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudmVyc2lvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2ZXJzaW9uXCIpKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS52ZXJzaW9uID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QudmVyc2lvbiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLnZlcnNpb24pIDogbWVzc2FnZS52ZXJzaW9uO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnZlcnNpb24gPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UudmVyc2lvbikgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS52ZXJzaW9uLmxvdyA+Pj4gMCwgbWVzc2FnZS52ZXJzaW9uLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLnZlcnNpb247XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIE9wZXJhdG9yU2V0SWRQcm90byB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgT3BlcmF0b3JTZXRJZFByb3RvLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgZGVmYXVsdCB0eXBlIHVybCBmb3IgT3BlcmF0b3JTZXRJZFByb3RvXG4gICAgICAgICAqIEBmdW5jdGlvbiBnZXRUeXBlVXJsXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54Lk9wZXJhdG9yU2V0SWRQcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVmYXVsdCB0eXBlIHVybFxuICAgICAgICAgKi9cbiAgICAgICAgT3BlcmF0b3JTZXRJZFByb3RvLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL29ubnguT3BlcmF0b3JTZXRJZFByb3RvXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIE9wZXJhdG9yU2V0SWRQcm90bztcbiAgICB9KSgpO1xuXG4gICAgLyoqXG4gICAgICogT3BlcmF0b3JTdGF0dXMgZW51bS5cbiAgICAgKiBAbmFtZSBvbm54Lk9wZXJhdG9yU3RhdHVzXG4gICAgICogQGVudW0ge251bWJlcn1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gRVhQRVJJTUVOVEFMPTAgRVhQRVJJTUVOVEFMIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFNUQUJMRT0xIFNUQUJMRSB2YWx1ZVxuICAgICAqL1xuICAgIG9ubnguT3BlcmF0b3JTdGF0dXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzBdID0gXCJFWFBFUklNRU5UQUxcIl0gPSAwO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxXSA9IFwiU1RBQkxFXCJdID0gMTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9KSgpO1xuXG4gICAgb25ueC5GdW5jdGlvblByb3RvID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgRnVuY3Rpb25Qcm90by5cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnhcbiAgICAgICAgICogQGludGVyZmFjZSBJRnVuY3Rpb25Qcm90b1xuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbbmFtZV0gRnVuY3Rpb25Qcm90byBuYW1lXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPHN0cmluZz58bnVsbH0gW2lucHV0XSBGdW5jdGlvblByb3RvIGlucHV0XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPHN0cmluZz58bnVsbH0gW291dHB1dF0gRnVuY3Rpb25Qcm90byBvdXRwdXRcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48c3RyaW5nPnxudWxsfSBbYXR0cmlidXRlXSBGdW5jdGlvblByb3RvIGF0dHJpYnV0ZVxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklBdHRyaWJ1dGVQcm90bz58bnVsbH0gW2F0dHJpYnV0ZVByb3RvXSBGdW5jdGlvblByb3RvIGF0dHJpYnV0ZVByb3RvXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG9ubnguSU5vZGVQcm90bz58bnVsbH0gW25vZGVdIEZ1bmN0aW9uUHJvdG8gbm9kZVxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZG9jU3RyaW5nXSBGdW5jdGlvblByb3RvIGRvY1N0cmluZ1xuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljxvbm54LklPcGVyYXRvclNldElkUHJvdG8+fG51bGx9IFtvcHNldEltcG9ydF0gRnVuY3Rpb25Qcm90byBvcHNldEltcG9ydFxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbZG9tYWluXSBGdW5jdGlvblByb3RvIGRvbWFpblxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBGdW5jdGlvblByb3RvLlxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueFxuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBGdW5jdGlvblByb3RvLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJRnVuY3Rpb25Qcm90b1xuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklGdW5jdGlvblByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBGdW5jdGlvblByb3RvKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBbXTtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gW107XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVQcm90byA9IFtdO1xuICAgICAgICAgICAgdGhpcy5ub2RlID0gW107XG4gICAgICAgICAgICB0aGlzLm9wc2V0SW1wb3J0ID0gW107XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZ1bmN0aW9uUHJvdG8gbmFtZS5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkZ1bmN0aW9uUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBGdW5jdGlvblByb3RvLnByb3RvdHlwZS5uYW1lID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRnVuY3Rpb25Qcm90byBpbnB1dC5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPHN0cmluZz59IGlucHV0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkZ1bmN0aW9uUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBGdW5jdGlvblByb3RvLnByb3RvdHlwZS5pbnB1dCA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZ1bmN0aW9uUHJvdG8gb3V0cHV0LlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48c3RyaW5nPn0gb3V0cHV0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkZ1bmN0aW9uUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBGdW5jdGlvblByb3RvLnByb3RvdHlwZS5vdXRwdXQgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGdW5jdGlvblByb3RvIGF0dHJpYnV0ZS5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPHN0cmluZz59IGF0dHJpYnV0ZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgRnVuY3Rpb25Qcm90by5wcm90b3R5cGUuYXR0cmlidXRlID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRnVuY3Rpb25Qcm90byBhdHRyaWJ1dGVQcm90by5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSUF0dHJpYnV0ZVByb3RvPn0gYXR0cmlidXRlUHJvdG9cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguRnVuY3Rpb25Qcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEZ1bmN0aW9uUHJvdG8ucHJvdG90eXBlLmF0dHJpYnV0ZVByb3RvID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRnVuY3Rpb25Qcm90byBub2RlLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48b25ueC5JTm9kZVByb3RvPn0gbm9kZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgRnVuY3Rpb25Qcm90by5wcm90b3R5cGUubm9kZSA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZ1bmN0aW9uUHJvdG8gZG9jU3RyaW5nLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRvY1N0cmluZ1xuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgRnVuY3Rpb25Qcm90by5wcm90b3R5cGUuZG9jU3RyaW5nID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRnVuY3Rpb25Qcm90byBvcHNldEltcG9ydC5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG9ubnguSU9wZXJhdG9yU2V0SWRQcm90bz59IG9wc2V0SW1wb3J0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkZ1bmN0aW9uUHJvdG9cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBGdW5jdGlvblByb3RvLnByb3RvdHlwZS5vcHNldEltcG9ydCA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZ1bmN0aW9uUHJvdG8gZG9tYWluLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRvbWFpblxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgRnVuY3Rpb25Qcm90by5wcm90b3R5cGUuZG9tYWluID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBGdW5jdGlvblByb3RvIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgKiBAbWVtYmVyb2Ygb25ueC5GdW5jdGlvblByb3RvXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtvbm54LklGdW5jdGlvblByb3RvPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtvbm54LkZ1bmN0aW9uUHJvdG99IEZ1bmN0aW9uUHJvdG8gaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEZ1bmN0aW9uUHJvdG8uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25Qcm90byhwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEZ1bmN0aW9uUHJvdG8gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5GdW5jdGlvblByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkZ1bmN0aW9uUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSUZ1bmN0aW9uUHJvdG99IG1lc3NhZ2UgRnVuY3Rpb25Qcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIEZ1bmN0aW9uUHJvdG8uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLzEwKS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmlucHV0ICE9IG51bGwgJiYgbWVzc2FnZS5pbnB1dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmlucHV0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDQsIHdpcmVUeXBlIDIgPSovMzQpLnN0cmluZyhtZXNzYWdlLmlucHV0W2ldKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm91dHB1dCAhPSBudWxsICYmIG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDUsIHdpcmVUeXBlIDIgPSovNDIpLnN0cmluZyhtZXNzYWdlLm91dHB1dFtpXSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5hdHRyaWJ1dGUgIT0gbnVsbCAmJiBtZXNzYWdlLmF0dHJpYnV0ZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmF0dHJpYnV0ZS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA2LCB3aXJlVHlwZSAyID0qLzUwKS5zdHJpbmcobWVzc2FnZS5hdHRyaWJ1dGVbaV0pO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uubm9kZSAhPSBudWxsICYmIG1lc3NhZ2Uubm9kZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm5vZGUubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290Lm9ubnguTm9kZVByb3RvLmVuY29kZShtZXNzYWdlLm5vZGVbaV0sIHdyaXRlci51aW50MzIoLyogaWQgNywgd2lyZVR5cGUgMiA9Ki81OCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiZG9jU3RyaW5nXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgOCwgd2lyZVR5cGUgMiA9Ki82Nikuc3RyaW5nKG1lc3NhZ2UuZG9jU3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm9wc2V0SW1wb3J0ICE9IG51bGwgJiYgbWVzc2FnZS5vcHNldEltcG9ydC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm9wc2V0SW1wb3J0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5lbmNvZGUobWVzc2FnZS5vcHNldEltcG9ydFtpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCA5LCB3aXJlVHlwZSAyID0qLzc0KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9tYWluICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJkb21haW5cIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxMCwgd2lyZVR5cGUgMiA9Ki84Mikuc3RyaW5nKG1lc3NhZ2UuZG9tYWluKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmF0dHJpYnV0ZVByb3RvICE9IG51bGwgJiYgbWVzc2FnZS5hdHRyaWJ1dGVQcm90by5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmF0dHJpYnV0ZVByb3RvLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5vbm54LkF0dHJpYnV0ZVByb3RvLmVuY29kZShtZXNzYWdlLmF0dHJpYnV0ZVByb3RvW2ldLCB3cml0ZXIudWludDMyKC8qIGlkIDExLCB3aXJlVHlwZSAyID0qLzkwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEZ1bmN0aW9uUHJvdG8gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgb25ueC5GdW5jdGlvblByb3RvLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkZ1bmN0aW9uUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguSUZ1bmN0aW9uUHJvdG99IG1lc3NhZ2UgRnVuY3Rpb25Qcm90byBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIEZ1bmN0aW9uUHJvdG8uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBGdW5jdGlvblByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguRnVuY3Rpb25Qcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5GdW5jdGlvblByb3RvfSBGdW5jdGlvblByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgRnVuY3Rpb25Qcm90by5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5vbm54LkZ1bmN0aW9uUHJvdG8oKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuaW5wdXQgJiYgbWVzc2FnZS5pbnB1dC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5wdXQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5wdXQucHVzaChyZWFkZXIuc3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uub3V0cHV0ICYmIG1lc3NhZ2Uub3V0cHV0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3V0cHV0LnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA2OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmF0dHJpYnV0ZSAmJiBtZXNzYWdlLmF0dHJpYnV0ZS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXR0cmlidXRlID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmF0dHJpYnV0ZS5wdXNoKHJlYWRlci5zdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMTE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuYXR0cmlidXRlUHJvdG8gJiYgbWVzc2FnZS5hdHRyaWJ1dGVQcm90by5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXR0cmlidXRlUHJvdG8gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXR0cmlidXRlUHJvdG8ucHVzaCgkcm9vdC5vbm54LkF0dHJpYnV0ZVByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uubm9kZSAmJiBtZXNzYWdlLm5vZGUubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5vZGUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uubm9kZS5wdXNoKCRyb290Lm9ubnguTm9kZVByb3RvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG9jU3RyaW5nID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uub3BzZXRJbXBvcnQgJiYgbWVzc2FnZS5vcHNldEltcG9ydC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3BzZXRJbXBvcnQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3BzZXRJbXBvcnQucHVzaCgkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAxMDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kb21haW4gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBGdW5jdGlvblByb3RvIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguRnVuY3Rpb25Qcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7b25ueC5GdW5jdGlvblByb3RvfSBGdW5jdGlvblByb3RvXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgRnVuY3Rpb25Qcm90by5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYSBGdW5jdGlvblByb3RvIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguRnVuY3Rpb25Qcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgRnVuY3Rpb25Qcm90by52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5uYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLm5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmlucHV0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImlucHV0XCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuaW5wdXQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbnB1dDogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuaW5wdXQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5pbnB1dFtpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbnB1dDogc3RyaW5nW10gZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm91dHB1dCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJvdXRwdXRcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5vdXRwdXQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvdXRwdXQ6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm91dHB1dC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLm91dHB1dFtpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJvdXRwdXQ6IHN0cmluZ1tdIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5hdHRyaWJ1dGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYXR0cmlidXRlXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuYXR0cmlidXRlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYXR0cmlidXRlOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5hdHRyaWJ1dGUubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5hdHRyaWJ1dGVbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYXR0cmlidXRlOiBzdHJpbmdbXSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuYXR0cmlidXRlUHJvdG8gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYXR0cmlidXRlUHJvdG9cIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5hdHRyaWJ1dGVQcm90bykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImF0dHJpYnV0ZVByb3RvOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5hdHRyaWJ1dGVQcm90by5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54LkF0dHJpYnV0ZVByb3RvLnZlcmlmeShtZXNzYWdlLmF0dHJpYnV0ZVByb3RvW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYXR0cmlidXRlUHJvdG8uXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ub2RlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5vZGVcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5ub2RlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibm9kZTogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uubm9kZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5vbm54Lk5vZGVQcm90by52ZXJpZnkobWVzc2FnZS5ub2RlW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibm9kZS5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRvY1N0cmluZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkb2NTdHJpbmdcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmRvY1N0cmluZykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImRvY1N0cmluZzogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5vcHNldEltcG9ydCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJvcHNldEltcG9ydFwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLm9wc2V0SW1wb3J0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwib3BzZXRJbXBvcnQ6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm9wc2V0SW1wb3J0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lm9ubnguT3BlcmF0b3JTZXRJZFByb3RvLnZlcmlmeShtZXNzYWdlLm9wc2V0SW1wb3J0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwib3BzZXRJbXBvcnQuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb21haW4gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5kb21haW4pKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJkb21haW46IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBGdW5jdGlvblByb3RvIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguRnVuY3Rpb25Qcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge29ubnguRnVuY3Rpb25Qcm90b30gRnVuY3Rpb25Qcm90b1xuICAgICAgICAgKi9cbiAgICAgICAgRnVuY3Rpb25Qcm90by5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5vbm54LkZ1bmN0aW9uUHJvdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm9ubnguRnVuY3Rpb25Qcm90bygpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5uYW1lICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gU3RyaW5nKG9iamVjdC5uYW1lKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmlucHV0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguRnVuY3Rpb25Qcm90by5pbnB1dDogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5pbnB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmlucHV0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlucHV0W2ldID0gU3RyaW5nKG9iamVjdC5pbnB1dFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0Lm91dHB1dCkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3Qub3V0cHV0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLm9ubnguRnVuY3Rpb25Qcm90by5vdXRwdXQ6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3V0cHV0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3Qub3V0cHV0Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm91dHB1dFtpXSA9IFN0cmluZyhvYmplY3Qub3V0cHV0W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QuYXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5hdHRyaWJ1dGUpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5GdW5jdGlvblByb3RvLmF0dHJpYnV0ZTogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5hdHRyaWJ1dGUgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5hdHRyaWJ1dGUubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXR0cmlidXRlW2ldID0gU3RyaW5nKG9iamVjdC5hdHRyaWJ1dGVbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5hdHRyaWJ1dGVQcm90bykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuYXR0cmlidXRlUHJvdG8pKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5GdW5jdGlvblByb3RvLmF0dHJpYnV0ZVByb3RvOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmF0dHJpYnV0ZVByb3RvID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuYXR0cmlidXRlUHJvdG8ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuYXR0cmlidXRlUHJvdG9baV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5GdW5jdGlvblByb3RvLmF0dHJpYnV0ZVByb3RvOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXR0cmlidXRlUHJvdG9baV0gPSAkcm9vdC5vbm54LkF0dHJpYnV0ZVByb3RvLmZyb21PYmplY3Qob2JqZWN0LmF0dHJpYnV0ZVByb3RvW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0Lm5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0Lm5vZGUpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5GdW5jdGlvblByb3RvLm5vZGU6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uubm9kZSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lm5vZGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Qubm9kZVtpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5vbm54LkZ1bmN0aW9uUHJvdG8ubm9kZTogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5vZGVbaV0gPSAkcm9vdC5vbm54Lk5vZGVQcm90by5mcm9tT2JqZWN0KG9iamVjdC5ub2RlW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LmRvY1N0cmluZyAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZG9jU3RyaW5nID0gU3RyaW5nKG9iamVjdC5kb2NTdHJpbmcpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5vcHNldEltcG9ydCkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3Qub3BzZXRJbXBvcnQpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5GdW5jdGlvblByb3RvLm9wc2V0SW1wb3J0OiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm9wc2V0SW1wb3J0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3Qub3BzZXRJbXBvcnQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Qub3BzZXRJbXBvcnRbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIub25ueC5GdW5jdGlvblByb3RvLm9wc2V0SW1wb3J0OiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3BzZXRJbXBvcnRbaV0gPSAkcm9vdC5vbm54Lk9wZXJhdG9yU2V0SWRQcm90by5mcm9tT2JqZWN0KG9iamVjdC5vcHNldEltcG9ydFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5kb21haW4gIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRvbWFpbiA9IFN0cmluZyhvYmplY3QuZG9tYWluKTtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBGdW5jdGlvblByb3RvIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBvbm54LkZ1bmN0aW9uUHJvdG9cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge29ubnguRnVuY3Rpb25Qcm90b30gbWVzc2FnZSBGdW5jdGlvblByb3RvXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgRnVuY3Rpb25Qcm90by50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIG9iamVjdC5pbnB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIG9iamVjdC5vdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3QuYXR0cmlidXRlID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5vZGUgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3Qub3BzZXRJbXBvcnQgPSBbXTtcbiAgICAgICAgICAgICAgICBvYmplY3QuYXR0cmlidXRlUHJvdG8gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIG9iamVjdC5kb2NTdHJpbmcgPSBcIlwiO1xuICAgICAgICAgICAgICAgIG9iamVjdC5kb21haW4gPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5uYW1lID0gbWVzc2FnZS5uYW1lO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaW5wdXQgJiYgbWVzc2FnZS5pbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuaW5wdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuaW5wdXQubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5pbnB1dFtqXSA9IG1lc3NhZ2UuaW5wdXRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5vdXRwdXQgJiYgbWVzc2FnZS5vdXRwdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm91dHB1dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5vdXRwdXQubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5vdXRwdXRbal0gPSBtZXNzYWdlLm91dHB1dFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmF0dHJpYnV0ZSAmJiBtZXNzYWdlLmF0dHJpYnV0ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuYXR0cmlidXRlID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmF0dHJpYnV0ZS5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmF0dHJpYnV0ZVtqXSA9IG1lc3NhZ2UuYXR0cmlidXRlW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uubm9kZSAmJiBtZXNzYWdlLm5vZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lm5vZGUgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2Uubm9kZS5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0Lm5vZGVbal0gPSAkcm9vdC5vbm54Lk5vZGVQcm90by50b09iamVjdChtZXNzYWdlLm5vZGVbal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZG9jU3RyaW5nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRvY1N0cmluZ1wiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuZG9jU3RyaW5nID0gbWVzc2FnZS5kb2NTdHJpbmc7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5vcHNldEltcG9ydCAmJiBtZXNzYWdlLm9wc2V0SW1wb3J0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5vcHNldEltcG9ydCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5vcHNldEltcG9ydC5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0Lm9wc2V0SW1wb3J0W2pdID0gJHJvb3Qub25ueC5PcGVyYXRvclNldElkUHJvdG8udG9PYmplY3QobWVzc2FnZS5vcHNldEltcG9ydFtqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kb21haW4gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZG9tYWluXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5kb21haW4gPSBtZXNzYWdlLmRvbWFpbjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmF0dHJpYnV0ZVByb3RvICYmIG1lc3NhZ2UuYXR0cmlidXRlUHJvdG8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmF0dHJpYnV0ZVByb3RvID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmF0dHJpYnV0ZVByb3RvLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuYXR0cmlidXRlUHJvdG9bal0gPSAkcm9vdC5vbm54LkF0dHJpYnV0ZVByb3RvLnRvT2JqZWN0KG1lc3NhZ2UuYXR0cmlidXRlUHJvdG9bal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBGdW5jdGlvblByb3RvIHRvIEpTT04uXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguRnVuY3Rpb25Qcm90b1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgRnVuY3Rpb25Qcm90by5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGRlZmF1bHQgdHlwZSB1cmwgZm9yIEZ1bmN0aW9uUHJvdG9cbiAgICAgICAgICogQGZ1bmN0aW9uIGdldFR5cGVVcmxcbiAgICAgICAgICogQG1lbWJlcm9mIG9ubnguRnVuY3Rpb25Qcm90b1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZVVybFByZWZpeF0geW91ciBjdXN0b20gdHlwZVVybFByZWZpeChkZWZhdWx0IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiKVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZGVmYXVsdCB0eXBlIHVybFxuICAgICAgICAgKi9cbiAgICAgICAgRnVuY3Rpb25Qcm90by5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9vbm54LkZ1bmN0aW9uUHJvdG9cIjtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gRnVuY3Rpb25Qcm90bztcbiAgICB9KSgpO1xuXG4gICAgcmV0dXJuIG9ubng7XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICRyb290O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge2ZsYXRidWZmZXJzfSBmcm9tICdmbGF0YnVmZmVycyc7XG5pbXBvcnQgTG9uZyBmcm9tICdsb25nJztcblxuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi9ncmFwaCc7XG5pbXBvcnQge29ubnhydW50aW1lfSBmcm9tICcuL29ydC1zY2hlbWEvZmxhdGJ1ZmZlcnMvb3J0LWdlbmVyYXRlZCc7XG5pbXBvcnQge29ubnh9IGZyb20gJy4vb3J0LXNjaGVtYS9wcm90b2J1Zi9vbm54JztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuL3RlbnNvcic7XG5cbi8vIGNoZWNrIHRoZSBpbnB1dHMgc2hhcGUgYmVmb3JlIHJ1bm5pbmcgYW4gT1AuXG4vLyByZXR1cm4gdHJ1ZSB3aGVuIHRoZSBpbnB1dHMgcGFzcyB0aGUgY2hlY2tcbi8vIHJldHVybiBmYWxzZSB3aGVuIHRoZSBpbnB1dHMgZG8gbm90IGZpdCB0aGUgcmVxdWlyZW1lbnRcbi8vIHRocm93IGV4Y2VwdGlvbiB3aGVuIGZhdGFsIGVycm9yIG9yIG5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrSW5wdXRzU2hhcGUoaW5wdXRzOiBUZW5zb3JbXSwgLi4uZXhwZWN0ZWREaW1lbnNpb25zOiBudW1iZXJbXSk6IGJvb2xlYW4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSBleHBlY3RlZERpbWVuc2lvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFpbnB1dHNbaV0uZGltcyB8fCBpbnB1dHNbaV0uZGltcy5sZW5ndGggIT09IGV4cGVjdGVkRGltZW5zaW9uc1tpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gRXZhbHVhdGVzIHRoZSBnaXZlbiBleHByZXNzaW9uIGFuZCBhc3NlcnRzIGVycm9yIG1lc3NhZ2UgaWYgY29uZGl0aW9uIGlzIHVubWV0LlxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChleHByOiBib29sZWFuLCBtc2c6ICgpID0+IHN0cmluZykge1xuICBpZiAoIWV4cHIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IodHlwZW9mIG1zZyA9PT0gJ3N0cmluZycgPyBtc2cgOiBtc2coKSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFycmF5VXRpbCB7XG4gIC8qKlxuICAgKiBWZXJpZmllcyBpZiAyIGlucHV0IGFycmF5cyBjb250YWluIHRoZSBzYW1lIGVsZW1lbnRzLlxuICAgKiBAcGFyYW0gbjEgQXJyYXkgMVxuICAgKiBAcGFyYW0gbjIgQXJyYXkgMlxuICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZXNlIDIgYXJlIGVxdWFsXG4gICAqL1xuICBzdGF0aWMgYXJyYXlzRXF1YWwoXG4gICAgICBuMTogcmVhZG9ubHkgbnVtYmVyW118SW50OEFycmF5fFVpbnQ4QXJyYXl8SW50MTZBcnJheXxVaW50MTZBcnJheXxJbnQzMkFycmF5fFVpbnQzMkFycmF5fFVpbnQ4Q2xhbXBlZEFycmF5fFxuICAgICAgRmxvYXQzMkFycmF5fEZsb2F0NjRBcnJheSxcbiAgICAgIG4yOiByZWFkb25seSBudW1iZXJbXXxJbnQ4QXJyYXl8VWludDhBcnJheXxJbnQxNkFycmF5fFVpbnQxNkFycmF5fEludDMyQXJyYXl8VWludDMyQXJyYXl8VWludDhDbGFtcGVkQXJyYXl8XG4gICAgICBGbG9hdDMyQXJyYXl8RmxvYXQ2NEFycmF5KSB7XG4gICAgaWYgKG4xLmxlbmd0aCAhPT0gbjIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChuMVtpXSAhPT0gbjJbaV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTWF0TXVsVXRpbCB7XG4gIC8qKlxuICAgKiBGaXggdGhlIGlucHV0IHNoYXBlcyBmb3IgTWF0TXVsIG9wZXJhdGlvbiBpZiB0aGV5IG5lZWQgZml4aW5nXG4gICAqIEBwYXJhbSBkaW1zQSBUaGUgc2hhcGUgb2YgdGVuc29yIEEuIFNob3VsZCBiZSBhbiBhcnJheSBvZiBwb3NpdGl2ZSBpbnRlZ2Vyc1xuICAgKiBAcGFyYW0gZGltc0IgVGhlIHNoYXBlIG9mIHRlbnNvciBCLiBTaG91bGQgYmUgYW4gYXJyYXkgb2YgcG9zaXRpdmUgaW50ZWdlcnNcbiAgICogQHJldHVybnMgQSB0dXBsZSBjb250YWluaW5nIHRoZSBwcmVwcm9jZXNzZWQgaW5wdXQgc2hhcGVzIGFzIHJlcXVpcmVkIGJ5IE9OTlggc3BlY2lmaWNhdGlvbnNcbiAgICovXG4gIHN0YXRpYyBwcmVwcm9jZXNzSW5wdXRTaGFwZXMoZGltc0E6IHJlYWRvbmx5IG51bWJlcltdLCBkaW1zQjogcmVhZG9ubHkgbnVtYmVyW10pOlxuICAgICAgW3JlYWRvbmx5IG51bWJlcltdLCByZWFkb25seSBudW1iZXJbXV0ge1xuICAgIC8vIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyAxLUQsIGl0IGlzIHByb21vdGVkIHRvIGEgbWF0cml4IGJ5IHByZXBlbmRpbmdcbiAgICAvLyBhIDEgdG8gaXRzIGRpbWVuc2lvbnMuIEFmdGVyIG1hdHJpeCBtdWx0aXBsaWNhdGlvbiB0aGUgcHJlcGVuZGVkIDEgaXNcbiAgICAvLyByZW1vdmVkLlxuICAgIGNvbnN0IGEgPSAoZGltc0EubGVuZ3RoID09PSAxKSA/IFsxLCBkaW1zQVswXV0gOiBkaW1zQTtcblxuICAgIC8vIElmIHRoZSBzZWNvbmQgYXJndW1lbnQgaXMgMS1ELCBpdCBpcyBwcm9tb3RlZCB0byBhIG1hdHJpeCBieSBhcHBlbmRpbmdcbiAgICAvLyBhIDEgdG8gaXRzIGRpbWVuc2lvbnMuIEFmdGVyIG1hdHJpeCBtdWx0aXBsaWNhdGlvbiB0aGUgYXBwZW5kZWQgMSBpc1xuICAgIC8vIHJlbW92ZWQuXG4gICAgY29uc3QgYiA9IChkaW1zQi5sZW5ndGggPT09IDEpID8gW2RpbXNCWzBdLCAxXSA6IGRpbXNCO1xuXG4gICAgcmV0dXJuIFthLCBiXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXggdGhlIG91dHB1dCBzaGFwZSBjb21wdXRlZCBmb3IgTWF0TXVsIG9wZXJhdGlvbiBpZiBpdCBuZWVkcyBmaXhpbmdcbiAgICogQHBhcmFtIG91dHB1dFNoYXBlIFRoZSBjb21wdXRlZCBvdXRwdXRTaGFwZS4gU2hvdWxkIGJlIGFuIGFycmF5IChhdGxlYXN0IG9mIGxlbmd0aCAyKSBvZiBwb3NpdGl2ZSBpbnRlZ2Vycy5cbiAgICogVGhpcyB3aWxsIGJlIG11dGF0ZWQuXG4gICAqIEBwYXJhbSBhUmFuayBUaGUgcmFuayBvZiB0ZW5zb3IgQS5cbiAgICogQHBhcmFtIGJSYW5rIFRoZSByYW5rIG9mIHRlbnNvciBCLlxuICAgKi9cbiAgc3RhdGljIHBvc3Rwcm9jZXNzT3V0cHV0U2hhcGUob3V0cHV0U2hhcGU6IG51bWJlcltdLCBhUmFuazogbnVtYmVyLCBiUmFuazogbnVtYmVyKSB7XG4gICAgLy8gUmVtb3ZlIHByZXBlbmRlZCBkaW1lbnNpb24gaWYgZmlyc3QgaW5wdXQgaXMgMWRcbiAgICBpZiAoYVJhbmsgPT09IDEpIHtcbiAgICAgIC8vIG91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGUuc2xpY2UoMCwgb3V0cHV0U2hhcGUubGVuZ3RoIC0gMikuY29uY2F0KG91dHB1dFNoYXBlLnNsaWNlKG91dHB1dFNoYXBlLmxlbmd0aCAtIDEpKTtcbiAgICAgIG91dHB1dFNoYXBlLnNwbGljZShvdXRwdXRTaGFwZS5sZW5ndGggLSAyLCAxKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGFwcGVuZGVkIGRpbWVuc2lvbiBpZiBzZWNvbmQgaW5wdXQgaXMgMWRcbiAgICBpZiAoYlJhbmsgPT09IDEpIHtcbiAgICAgIG91dHB1dFNoYXBlLnBvcCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGV4cGVjdGVkIHNoYXBlIHdoZW4gbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAqIEBwYXJhbSBhIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQS4gU2hvdWxkIGJlIGEgdHVwbGUgb2YgMiBwb3NpdGl2ZSBpbnRlZ2Vyc1xuICAgKiBAcGFyYW0gYiBUaGUgc2hhcGUgb2YgdGVuc29yIEIuIFNob3VsZCBiZSBhIHR1cGxlIG9mIDIgcG9zaXRpdmUgaW50ZWdlcnNcbiAgICogQHJldHVybnMgVGhlIGV4cGVjdGVkIHNoYXBlIG9mIHRoZSByZXN1bHQsIG9yIHVuZGVmaW5lZCBpZiBOL0FcbiAgICovXG4gIHN0YXRpYyBjYWxjTWF0TXVsU2hhcGUoYTogW251bWJlciwgbnVtYmVyXSwgYjogW251bWJlciwgbnVtYmVyXSk6IFtudW1iZXIsIG51bWJlcl18dW5kZWZpbmVkIHtcbiAgICByZXR1cm4gKGFbMV0gIT09IGJbMF0pID8gdW5kZWZpbmVkIDogW2FbMF0sIGJbMV1dO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCcm9hZGNhc3RVdGlsIHtcbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZXhwZWN0ZWQgc2hhcGUgd2hlbiBicm9hZGNhc3RpbmcgMiB0ZW5zb3JzXG4gICAqIEBwYXJhbSBhIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQS4gU2hvdWxkIGJlIGFuIGFycmF5IG9mIHBvc2l0aXZlIGludGVnZXJzXG4gICAqIEBwYXJhbSBiIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQi4gU2hvdWxkIGJlIGFuIGFycmF5IG9mIHBvc2l0aXZlIGludGVnZXJzXG4gICAqIEBwYXJhbSBpc01hdE11bCBXaGV0aGVyIHRoZSBvcGVyYXRpb24gaXMgTWF0TXVsXG4gICAqIEByZXR1cm5zIFRoZSBleHBlY3RlZCBzaGFwZSBvZiB0aGUgcmVzdWx0LCBvciB1bmRlZmluZWQgaWYgTi9BXG4gICAqL1xuICBzdGF0aWMgY2FsY1NoYXBlKGFkaW1zOiByZWFkb25seSBudW1iZXJbXSwgYmRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBpc01hdE11bCA9IGZhbHNlKTogcmVhZG9ubHkgbnVtYmVyW118dW5kZWZpbmVkIHtcbiAgICBjb25zdCBhcmFuayA9IGFkaW1zLmxlbmd0aDtcbiAgICBjb25zdCBicmFuayA9IGJkaW1zLmxlbmd0aDtcbiAgICBpZiAoYXJhbmsgPT09IDApIHtcbiAgICAgIHJldHVybiBiZGltcztcbiAgICB9XG4gICAgaWYgKGJyYW5rID09PSAwKSB7XG4gICAgICByZXR1cm4gYWRpbXM7XG4gICAgfVxuICAgIGNvbnN0IGNyYW5rID0gTWF0aC5tYXgoYWRpbXMubGVuZ3RoLCBiZGltcy5sZW5ndGgpO1xuICAgIGNvbnN0IGNkaW1zID0gbmV3IEFycmF5PG51bWJlcj4oY3JhbmspO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBsYXN0IDIgZGltZW5zaW9uIGlmIGl0IGlzIE1hdE11bFxuICAgIGlmIChpc01hdE11bCkge1xuICAgICAgaWYgKGFyYW5rIDwgMiB8fCBicmFuayA8IDIpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNTaGFwZU1hdE11bCA9XG4gICAgICAgICAgTWF0TXVsVXRpbC5jYWxjTWF0TXVsU2hhcGUoW2FkaW1zW2FyYW5rIC0gMl0sIGFkaW1zW2FyYW5rIC0gMV1dLCBbYmRpbXNbYnJhbmsgLSAyXSwgYmRpbXNbYnJhbmsgLSAxXV0pO1xuICAgICAgaWYgKGNTaGFwZU1hdE11bCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBbY2RpbXNbY3JhbmsgLSAyXSwgY2RpbXNbY3JhbmsgLSAxXV0gPSBjU2hhcGVNYXRNdWw7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IGlzTWF0TXVsID8gMyA6IDE7IGkgPD0gY3Jhbms7IGkrKykge1xuICAgICAgY29uc3QgYUxlbiA9IGFyYW5rIC0gaSA8IDAgPyAxIDogYWRpbXNbYXJhbmsgLSBpXTtcbiAgICAgIGNvbnN0IGJMZW4gPSBicmFuayAtIGkgPCAwID8gMSA6IGJkaW1zW2JyYW5rIC0gaV07XG5cbiAgICAgIGlmIChhTGVuICE9PSBiTGVuICYmIGFMZW4gPiAxICYmIGJMZW4gPiAxKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBjZGltc1tjcmFuayAtIGldID0gTWF0aC5tYXgoYUxlbiwgYkxlbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNkaW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIHRoZSBpbmRpY2VzIG9mIGEgYnJvYWRjYXN0ZWQgdGVuc29yLCBjYWxjdWxhdGUgdGhlIG9yaWdpbmFsIGluZGljZXNcbiAgICogQHBhcmFtIGJyb2FkY2FzdGVkSW5kaWNlcyBUaGUgZ2l2ZW4gaW5kaWNlcyBvZiB0aGUgYnJvYWRjYXN0ZWQgdGVuc29yLlxuICAgKiBAcGFyYW0gb3JpZ2luYWxTaGFwZSBUaGUgb3JpZ2luYWwgc2hhcGUgb2YgdGhlIHRlbnNvciBiZWZvcmUgYnJvYWRjYXNcbiAgICogQHJldHVybnMgVGhlIGNhbGN1bGF0ZWQgaW5kaWNlcyB0aGF0IG1hcHMgdG8gdGhlIG9yaWdpbmFsIHRlbnNvci5cbiAgICovXG4gIHN0YXRpYyBpbmRleChicm9hZGNhc3RlZEluZGljZXM6IHJlYWRvbmx5IG51bWJlcltdLCBvcmlnaW5hbFNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlcltdIHtcbiAgICAvLyBOT1RFIDE6IHdlIGFzc3VtZSB0aGUgcGFyYW1ldGVyIGJyb2FkY2FzdGVkSW5kaWNlcyBpcyB2YWxpZC4gaWUuIGl0IHNob3VsZCBoYXZlIHRoZSBzYW1lXG4gICAgLy8gbGVuZ3RoIGFzIHRoZSBicm9hZGNhc3RlZCBzaGFwZSwgYW5kIGZvciBlYWNoIGRpbWVuc2lvbiB0aGUgaW5kZXggc2hvdWxkXG4gICAgLy8gbm90IGJlIG91dCBvZiByYW5nZS5cbiAgICBjb25zdCBvcmlnaW5hbEluZGljZXMgPSBuZXcgQXJyYXkob3JpZ2luYWxTaGFwZS5sZW5ndGgpO1xuICAgIEJyb2FkY2FzdFV0aWwuZmlsbEluZGV4KGJyb2FkY2FzdGVkSW5kaWNlcywgb3JpZ2luYWxTaGFwZSwgb3JpZ2luYWxJbmRpY2VzKTtcbiAgICByZXR1cm4gb3JpZ2luYWxJbmRpY2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIHRoZSBpbmRpY2VzIG9mIGEgYnJvYWRjYXN0ZWQgdGVuc29yLCBjYWxjdWxhdGUgdGhlIG9yaWdpbmFsIGluZGljZXNcbiAgICogQHBhcmFtIGJyb2FkY2FzdGVkSW5kaWNlcyBUaGUgZ2l2ZW4gaW5kaWNlcyBvZiB0aGUgYnJvYWRjYXN0ZWQgdGVuc29yLlxuICAgKiBAcGFyYW0gb3JpZ2luYWxTaGFwZSBUaGUgb3JpZ2luYWwgc2hhcGUgb2YgdGhlIHRlbnNvciBiZWZvcmUgYnJvYWRjYXN0XG4gICAqIEBwYXJhbSBvcmlnaW5hbEluZGljZXMgVGhlIG1hcHBpbmcgb2YgYnJvYWRjYXN0ZWRJbmRpY2VzIHRvIHRoZSBvcmlnaW5hbEluZGljZXMgKG91dHB1dCBwYXJhbWV0ZXIgLSB3aWxsIGJlXG4gICAqICAgICBtdXRhdGVkKS5cbiAgICovXG4gIHN0YXRpYyBmaWxsSW5kZXgoYnJvYWRjYXN0ZWRJbmRpY2VzOiByZWFkb25seSBudW1iZXJbXSwgb3JpZ2luYWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIG9yaWdpbmFsSW5kaWNlczogbnVtYmVyW10pIHtcbiAgICAvLyBOT1RFIDE6IHdlIGFzc3VtZSB0aGUgcGFyYW1ldGVyIGJyb2FkY2FzdGVkSW5kaWNlcyBpcyB2YWxpZC4gaWUuIGl0IHNob3VsZCBoYXZlIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGVcbiAgICAvLyBicm9hZGNhc3RlZCBzaGFwZSwgYW5kIGZvciBlYWNoIGRpbWVuc2lvbiB0aGUgaW5kZXggc2hvdWxkIG5vdCBiZSBvdXQgb2YgcmFuZ2UuXG4gICAgLy8gTk9URSAyOiB3ZSBhc3N1bWUgdGhlIHBhcmFtZXRlciBvcmlnaW5hbEluZGljZXMgaGFzIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGUgb3JpZ2luYWxTaGFwZVxuICAgIGNvbnN0IGRpbU9mZnNldCA9IGJyb2FkY2FzdGVkSW5kaWNlcy5sZW5ndGggLSBvcmlnaW5hbFNoYXBlLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yaWdpbmFsU2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9yaWdpbmFsSW5kaWNlc1tpXSA9IGJyb2FkY2FzdGVkSW5kaWNlc1tkaW1PZmZzZXQgKyBpXSAlIG9yaWdpbmFsU2hhcGVbaV07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gdGhlIGJyb2FkY2FzdGluZyBvcGVyYXRpb24gb24gdGhlIHNwZWNpZmljIG9wZXJhdG9yXG4gICAqIEBwYXJhbSBhIFRoZSBpbnB1dCB0ZW5zb3IgQVxuICAgKiBAcGFyYW0gYiBUaGUgaW5wdXQgdGVuc29yIEJcbiAgICogQHBhcmFtIG9wIFRoZSBvcGVyYXRvciBsYW1iZGEgZnVuY3Rpb25cbiAgICogQHBhcmFtIGlucGxhY2UgV2hldGhlciB0byB3cml0ZSB0aGUgcmVzdWx0IGJhY2sgdG8gQS5cbiAgICogQHJldHVybnMgVGhlIHJlc3VsdCB0ZW5zb3IsIG9yIHVuZGVmaW5lZCBpZiBpbnB1dCBub3QgYnJvYWRjYXN0YWJsZS5cbiAgICovXG4gIHN0YXRpYyBjYWxjKFxuICAgICAgYTogVGVuc29yLCBiOiBUZW5zb3IsIG9wOiAoYTogc3RyaW5nfG51bWJlciwgYjogc3RyaW5nfG51bWJlcikgPT4gKHN0cmluZyB8IG51bWJlciksIGlucGxhY2U6IGJvb2xlYW4sXG4gICAgICByZXN1bHRUeXBlPzogVGVuc29yLkRhdGFUeXBlKTogVGVuc29yfHVuZGVmaW5lZCB7XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBCcm9hZGNhc3RVdGlsLmNhbGNTaGFwZShhLmRpbXMsIGIuZGltcyk7XG5cbiAgICBpZiAob3V0cHV0U2hhcGUpIHtcbiAgICAgIGlmIChpbnBsYWNlICYmICFTaGFwZVV0aWwuYXJlRXF1YWwob3V0cHV0U2hhcGUsIGEuZGltcykpIHtcbiAgICAgICAgLy8gQiBpcyBub3QgYnJvYWRjYXN0YWJsZSB0byBBLCBmYWlsZWQgdG8gY2FsY3VsYXRlIGlucGxhY2UuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gICAgICBjb25zdCBjID0gaW5wbGFjZSA/IGEgOiBuZXcgVGVuc29yKG91dHB1dFNoYXBlLCByZXN1bHRUeXBlIHx8IGEudHlwZSk7XG5cbiAgICAgIC8vIGJvdGggaW5wdXRzIGFyZSBzY2FsYXJzXG4gICAgICBpZiAob3V0cHV0U2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGMuc2V0KFtdLCBvcChhLmdldChbXSkgYXMgbnVtYmVyLCBiLmdldChbXSkgYXMgbnVtYmVyKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGF0bGVhc3Qgb25lIGlucHV0IGlzIGEgbm9uLXNjYWxhclxuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG91dHB1dEluZGljZXMgPSBuZXcgQXJyYXk8bnVtYmVyPihvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbEluZGljZXNBID0gbmV3IEFycmF5KGEuZGltcy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbEluZGljZXNCID0gbmV3IEFycmF5KGIuZGltcy5sZW5ndGgpO1xuICAgICAgICBsZXQgdmFsQTogc3RyaW5nfG51bWJlciA9IDA7XG4gICAgICAgIGxldCB2YWxCOiBzdHJpbmd8bnVtYmVyID0gMDtcbiAgICAgICAgbGV0IGlzQVNjYWxhciA9IGZhbHNlO1xuICAgICAgICBsZXQgaXNCU2NhbGFyID0gZmFsc2U7XG4gICAgICAgIGlmIChhLmRpbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdmFsQSA9IGEuZ2V0KFtdKSBhcyBudW1iZXI7XG4gICAgICAgICAgaXNBU2NhbGFyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYi5kaW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHZhbEIgPSBiLmdldChbXSkgYXMgbnVtYmVyO1xuICAgICAgICAgIGlzQlNjYWxhciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3Q6IG51bWJlcjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAvLyB0cmF2ZXJzYWwgaW5kaWNlc1xuICAgICAgICAgIHJlc3QgPSBpO1xuICAgICAgICAgIGZvciAobGV0IGogPSBvdXRwdXRTaGFwZS5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgb3V0cHV0SW5kaWNlc1tqXSA9IHJlc3QgJSBvdXRwdXRTaGFwZVtqXTtcbiAgICAgICAgICAgIHJlc3QgPSBNYXRoLmZsb29yKHJlc3QgLyBvdXRwdXRTaGFwZVtqXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpc0FTY2FsYXIpIHtcbiAgICAgICAgICAgIC8vIG1hcCBvdXRwdXRJbmRpY2VzICh3aGljaCBpcyBhY3R1YWxseSBicm9hZGNhc3RlZCkgdG8gdGhlIG9yaWdpbmFsSW5kaWNlc1xuICAgICAgICAgICAgQnJvYWRjYXN0VXRpbC5maWxsSW5kZXgob3V0cHV0SW5kaWNlcywgYS5kaW1zLCBvcmlnaW5hbEluZGljZXNBKTtcbiAgICAgICAgICAgIHZhbEEgPSBhLmdldChvcmlnaW5hbEluZGljZXNBKSBhcyBudW1iZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNCU2NhbGFyKSB7XG4gICAgICAgICAgICBCcm9hZGNhc3RVdGlsLmZpbGxJbmRleChvdXRwdXRJbmRpY2VzLCBiLmRpbXMsIG9yaWdpbmFsSW5kaWNlc0IpO1xuICAgICAgICAgICAgdmFsQiA9IGIuZ2V0KG9yaWdpbmFsSW5kaWNlc0IpIGFzIG51bWJlcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjLnNldChvdXRwdXRJbmRpY2VzLCBvcCh2YWxBLCB2YWxCKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgYSBzaGFwZSBpcyB1bmlkaXJlY3Rpb25hbCBicm9hZGNhc3RhYmxlIHRvIGFub3RoZXIgc2hhcGVcbiAgICogQHBhcmFtIHNoYXBlIFRoZSBpbnB1dCBzaGFwZVxuICAgKiBAcGFyYW0gZmluYWxTaGFwZSBUaGUgZGVzaXJlZCBzaGFwZSBhZnRlciBicm9hZGNhc3RpbmdcbiAgICovXG4gIHN0YXRpYyBpc1ZhbGlkQnJvYWRjYXN0KHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgZmluYWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBib29sZWFuIHtcbiAgICAvLyBhbGlnbiBzaGFwZSB0byB0aGUgcmlnaHRcbiAgICBjb25zdCBpbnB1dFJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gICAgY29uc3QgZmluYWxSYW5rID0gZmluYWxTaGFwZS5sZW5ndGg7XG4gICAgaWYgKGlucHV0UmFuayA+IGZpbmFsUmFuaykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBpbnB1dFJhbms7IGkrKykge1xuICAgICAgaWYgKHNoYXBlW2lucHV0UmFuayAtIGldICE9PSAxICYmIHNoYXBlW2lucHV0UmFuayAtIGldICE9PSBmaW5hbFNoYXBlW2ZpbmFsUmFuayAtIGldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSBicm9hZGNhc3RlZCBkaW1zIGluIGlucHV0IHNoYXBlIGJhc2VkIG9uIHRoZSBnaXZlbiBvdXRwdXQgc2hhcGUuXG4gICAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIG9ubHkgcmV0dXJucyB0aGUgYnJvYWRjYXN0ZWQgZGltcy5cbiAgICogQHBhcmFtIGlucHV0U2hhcGUgVGhlIGlucHV0IHNoYXBlXG4gICAqIEBwYXJhbSBvdXRwdXRTaGFwZSBUaGUgb3V0cHV0IHNoYXBlXG4gICAqIEByZXR1cm5zIFRoZSBicm9hZGNhc3RlZCBkaW1zIGluIGlucHV0IHNoYXBlLlxuICAgKi9cbiAgc3RhdGljIGdldEJyb2FkY2FzdERpbXMoaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlcltdIHtcbiAgICBjb25zdCBpblJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBkaW1zOiBudW1iZXJbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5SYW5rOyBpKyspIHtcbiAgICAgIGNvbnN0IGRpbSA9IGluUmFuayAtIDEgLSBpO1xuICAgICAgY29uc3QgYSA9IGlucHV0U2hhcGVbZGltXSB8fCAxO1xuICAgICAgY29uc3QgYiA9IG91dHB1dFNoYXBlW291dHB1dFNoYXBlLmxlbmd0aCAtIDEgLSBpXSB8fCAxO1xuICAgICAgaWYgKGIgPiAxICYmIGEgPT09IDEpIHtcbiAgICAgICAgZGltcy51bnNoaWZ0KGRpbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaW1zO1xuICB9XG59XG5cbi8vIGNvcHkgYXJyYXkgaGVscGVyXG4vLyBtaW1pY3MgbWVtY3B5IGFzIG11Y2ggYXMgcG9zc2libGVcbmV4cG9ydCBmdW5jdGlvbiBhcnJheUNvcHlIZWxwZXIoXG4gICAgdGFyZ2V0OiBudW1iZXJbXXxUZW5zb3IuTnVtYmVyVHlwZSwgc291cmNlOiBudW1iZXJbXXxUZW5zb3IuTnVtYmVyVHlwZSwgdGFyZ2V0SW5kZXg6IG51bWJlciwgc291cmNlSW5kZXg6IG51bWJlcixcbiAgICBibG9ja1NpemU6IG51bWJlcikge1xuICBpZiAoc291cmNlSW5kZXggPCAwIHx8IHNvdXJjZUluZGV4ID49IHNvdXJjZS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZUluZGV4IG91dCBvZiBib3VuZHMnKTtcbiAgfVxuICBpZiAodGFyZ2V0SW5kZXggPCAwIHx8IHRhcmdldEluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldEluZGV4IG91dCBvZiBib3VuZHMnKTtcbiAgfVxuICBpZiAoc291cmNlSW5kZXggKyBibG9ja1NpemUgPiBzb3VyY2UubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2UgaW5kaWNlcyB0byBiZSBjb3BpZWQgYXJlIG91dHNpZGUgYm91bmRzJyk7XG4gIH1cbiAgaWYgKHRhcmdldEluZGV4ICsgYmxvY2tTaXplID4gdGFyZ2V0Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0IGFycmF5IGlzIHRvbyBzbWFsbCB0byBob2xkIHJlc3VsdCcpO1xuICB9XG5cbiAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgYmxvY2tTaXplOyBvZmZzZXQrKykge1xuICAgIHRhcmdldFt0YXJnZXRJbmRleCArIG9mZnNldF0gPSBzb3VyY2Vbc291cmNlSW5kZXggKyBvZmZzZXRdO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBHZW1tVXRpbCB7XG4gIC8vIHdpbGwgbWFrZSBzdXJlIGlucHV0IHNoYXBlcyBhcmUgY29tcGF0aWJsZSBmb3IgdGhpcyBvcFxuICAvLyBhbmQgcmV0dXJuIGJhY2sgdGhlIHNoYXBlIG9mIHRoZSBvdXRwdXQgaW4gdGhlIGZvcm0gb2YgYSB0dXBsZVxuICAvLyB3aWxsIHRocm93IGV4Y2VwdGlvbiBpZiB0aGUgaW5wdXQgc2hhcGVzIGFyZSBub3QgY29tcGF0aWJsZVxuICBzdGF0aWMgZ2V0U2hhcGVPZkdlbW1SZXN1bHQoXG4gICAgICBsZWZ0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCB0cmFuc0xlZnQ6IGJvb2xlYW4sIHJpZ2h0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCB0cmFuc1JpZ2h0OiBib29sZWFuLFxuICAgICAgYmlhc1NoYXBlPzogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgaWYgKGxlZnRTaGFwZS5sZW5ndGggIT09IDIgfHwgcmlnaHRTaGFwZS5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2hhcGUgbmVlZCB0byBiZSBvZiBzaXplIDInKTtcbiAgICB9XG5cbiAgICBsZXQgTTogbnVtYmVyO1xuICAgIGxldCBLOiBudW1iZXI7XG4gICAgbGV0IE46IG51bWJlcjtcblxuICAgIGlmICh0cmFuc0xlZnQpIHtcbiAgICAgIE0gPSBsZWZ0U2hhcGVbMV07XG4gICAgICBLID0gbGVmdFNoYXBlWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBNID0gbGVmdFNoYXBlWzBdO1xuICAgICAgSyA9IGxlZnRTaGFwZVsxXTtcbiAgICB9XG5cbiAgICBsZXQga0RpbSA9IC0xO1xuXG4gICAgaWYgKHRyYW5zUmlnaHQpIHtcbiAgICAgIE4gPSByaWdodFNoYXBlWzBdO1xuICAgICAga0RpbSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIE4gPSByaWdodFNoYXBlWzFdO1xuICAgICAga0RpbSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHJpZ2h0U2hhcGVba0RpbV0gIT09IEspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZGltZW5zaW9uIG1pc21hdGNoJyk7XG4gICAgfVxuXG4gICAgaWYgKE0gPD0gMCB8fCBOIDw9IDAgfHwgSyA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2hhcGUgc3BlY2lmaWVkJyk7XG4gICAgfVxuXG4gICAgaWYgKGJpYXNTaGFwZSAmJiAhQnJvYWRjYXN0VXRpbC5pc1ZhbGlkQnJvYWRjYXN0KGJpYXNTaGFwZSwgW00sIE5dKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZW1tOiBpbnZhbGlkIGJpYXMgc2hhcGUgZm9yIGJyb2FkY2FzdCcpO1xuICAgIH1cblxuICAgIHJldHVybiBbTSwgTiwgS107XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFByb3RvVXRpbCB7XG4gIHN0YXRpYyB0ZW5zb3JEYXRhVHlwZUZyb21Qcm90byh0eXBlUHJvdG86IG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGV8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLlRlbnNvckRhdGFUeXBlKTogVGVuc29yLkRhdGFUeXBlIHtcbiAgICBzd2l0Y2ggKHR5cGVQcm90bykge1xuICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg6XG4gICAgICAgIHJldHVybiAnaW50OCc7XG4gICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDg6XG4gICAgICAgIHJldHVybiAndWludDgnO1xuICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w6XG4gICAgICAgIHJldHVybiAnYm9vbCc7XG4gICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMTY6XG4gICAgICAgIHJldHVybiAnaW50MTYnO1xuICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjpcbiAgICAgICAgcmV0dXJuICd1aW50MTYnO1xuICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOlxuICAgICAgICByZXR1cm4gJ2ludDMyJztcbiAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI6XG4gICAgICAgIHJldHVybiAndWludDMyJztcbiAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDpcbiAgICAgICAgcmV0dXJuICdmbG9hdDMyJztcbiAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU6XG4gICAgICAgIHJldHVybiAnZmxvYXQ2NCc7XG4gICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuU1RSSU5HOlxuICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG5cbiAgICAgIC8vIEZvciBJTlQ2NC9VSU5UNjQsIHJlZHVjZSB0aGVpciB2YWx1ZSB0byAzMi1iaXRzLlxuICAgICAgLy8gU2hvdWxkIHRocm93IGV4Y2VwdGlvbiB3aGVuIG92ZXJmbG93XG4gICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6XG4gICAgICAgIHJldHVybiAnaW50MzInO1xuICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDpcbiAgICAgICAgcmV0dXJuICd1aW50MzInO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlW3R5cGVQcm90b119YCk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtKHR5cGU6IHN0cmluZyk6IG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnaW50OCc6XG4gICAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg7XG4gICAgICBjYXNlICd1aW50OCc6XG4gICAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4O1xuICAgICAgY2FzZSAnYm9vbCc6XG4gICAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w7XG4gICAgICBjYXNlICdpbnQxNic6XG4gICAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDE2O1xuICAgICAgY2FzZSAndWludDE2JzpcbiAgICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDE2O1xuICAgICAgY2FzZSAnaW50MzInOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjtcbiAgICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMjtcbiAgICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDtcbiAgICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5TVFJJTkc7XG4gICAgICBjYXNlICdpbnQ2NCc6XG4gICAgICAgIHJldHVybiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDY0O1xuICAgICAgY2FzZSAndWludDY0JzpcbiAgICAgICAgcmV0dXJuIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0O1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0eXBlfWApO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyB0ZW5zb3JEaW1zRnJvbVByb3RvKGRpbXM6IEFycmF5PG51bWJlcnxMb25nPik6IG51bWJlcltdIHtcbiAgICAvLyBnZXQgcmlkIG9mIExvbmcgdHlwZSBmb3IgZGltc1xuICAgIHJldHVybiBkaW1zLm1hcChkID0+IExvbmcuaXNMb25nKGQpID8gZC50b051bWJlcigpIDogZCk7XG4gIH1cblxuICBzdGF0aWMgdGVuc29yVmFsdWVUeXBlRnJvbVByb3RvKHZhbHVlVHlwZTogb25ueC5UeXBlUHJvdG8uSVRlbnNvcik6IEdyYXBoLlZhbHVlVHlwZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRlbnNvclR5cGU6IFByb3RvVXRpbC50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byh2YWx1ZVR5cGUuZWxlbVR5cGUhKSxcbiAgICAgIHNoYXBlOiB7ZGltczogUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tUHJvdG8odmFsdWVUeXBlLnNoYXBlIS5kaW0hLm1hcChkID0+IGQuZGltVmFsdWUhKSl9XG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyB0ZW5zb3JEaW1zRnJvbU9SVEZvcm1hdCh0ZW5zb3I6IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnMuVGVuc29yKSB7XG4gICAgY29uc3QgZGltcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVuc29yLmRpbXNMZW5ndGgoKTsgaSsrKSB7XG4gICAgICBkaW1zLnB1c2goTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKHRlbnNvci5kaW1zKGkpISkpO1xuICAgIH1cbiAgICByZXR1cm4gZGltcztcbiAgfVxuXG4gIHN0YXRpYyB0ZW5zb3JBdHRyaWJ1dGVzRnJvbU9SVEZvcm1hdChub2RlOiBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzLk5vZGUpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmF0dHJpYnV0ZXNMZW5ndGgoKTsgaSsrKSB7XG4gICAgICBhdHRyaWJ1dGVzLnB1c2gobm9kZS5hdHRyaWJ1dGVzKGkpISk7XG4gICAgfVxuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBMb25nVXRpbCB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHRvIGdldCBhIG51bWJlciBmcm9tIGxvbmcgdHlwZSBvZiBkYXRhIGZvciBhdHRyaWJ1dGUsIGRpbSwgYW5kIGlyIHZlcnNpb24sXG4gIC8vIHdoaWNoIHZhbHVlcyBhcmUgc2lnbmVkIGludGVnZXJzLlxuICAvLyBUbyBtYWtlIGl0IG1vcmUgZ2VuZXJpYywgYWRkIGFuIG9wdGlvbmFsIHBhcmFtdGVyIHRvIGNvbnZlcnQgdG8gYSB1bnNpZ25lZCBudW1iZXIuXG4gIHN0YXRpYyBsb25nVG9OdW1iZXIobjogTG9uZ3xmbGF0YnVmZmVycy5Mb25nfG51bWJlciwgdW5zaWduZWQ/OiBib29sZWFuKSB7XG4gICAgaWYgKExvbmcuaXNMb25nKG4pKSB7XG4gICAgICByZXR1cm4gbi50b051bWJlcigpO1xuICAgIH0gZWxzZSBpZiAobiBpbnN0YW5jZW9mIGZsYXRidWZmZXJzLkxvbmcpIHtcbiAgICAgIHJldHVybiBMb25nLmZyb21WYWx1ZSh7bG93OiBuLmxvdywgaGlnaDogbi5oaWdoLCB1bnNpZ25lZDogdW5zaWduZWQgPz8gZmFsc2V9KS50b051bWJlcigpO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxuICBzdGF0aWMgaXNMb25nKG46IHVua25vd24pIHtcbiAgICByZXR1cm4gTG9uZy5pc0xvbmcobikgfHwgbiBpbnN0YW5jZW9mIGZsYXRidWZmZXJzLkxvbmc7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNoYXBlVXRpbCB7XG4gIHN0YXRpYyBzaXplKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogbnVtYmVyIHtcbiAgICByZXR1cm4gU2hhcGVVdGlsLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UoZGltcywgMCwgZGltcy5sZW5ndGgpO1xuICB9XG5cbiAgLy8gYGF4aXNgIGluY2x1c2l2ZVxuICBzdGF0aWMgc2l6ZUZyb21EaW1lbnNpb24oZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4aXM6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKGF4aXMgPCAwIHx8IGF4aXMgPiBkaW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke2F4aXN9IGZvciBzaXplRnJvbURpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7ZGltcy5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7XG4gICAgfVxuICAgIHJldHVybiBTaGFwZVV0aWwuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZShkaW1zLCBheGlzLCBkaW1zLmxlbmd0aCk7XG4gIH1cblxuICAvLyBgYXhpc2AgZXhjbHVzaXZlXG4gIHN0YXRpYyBzaXplVG9EaW1lbnNpb24oZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4aXM6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKGF4aXMgPCAwIHx8IGF4aXMgPiBkaW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke2F4aXN9IGZvciBzaXplVG9EaW1lbnNpb24gYXMgVGVuc29yIGhhcyAke2RpbXMubGVuZ3RofSBkaW1lbnNpb25zLmApO1xuICAgIH1cbiAgICByZXR1cm4gU2hhcGVVdGlsLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UoZGltcywgMCwgYXhpcyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZShkaW1zOiByZWFkb25seSBudW1iZXJbXSwgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGxldCBzaXplID0gMTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgLy8gc2FmZXR5IGNoZWNrIGFzIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSBtdWx0aXBsZSBvdGhlciBtZXRob2RzIHJlcXVpcmluZyBzaXplLlxuICAgICAgLy8gc2l6ZSBjYW5ub3QgYmUgMCBvciBuZWdhdGl2ZS5cbiAgICAgIGlmIChkaW1zW2ldIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICAgICAgICAgICdjYW5ub3QgZ2V0IHZhbGlkIHNpemUgZnJvbSBzcGVjaWZpZWQgZGltZW5zaW9uIHJhbmdlLiBNb3N0IGxpa2VseSB0aGUgcmFuZ2UgY29udGFpbnMgMCBvciBuZWdhdGl2ZSB2YWx1ZXMgaW4gdGhlbS4nKTtcbiAgICAgIH1cbiAgICAgIHNpemUgKj0gZGltc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG4gIH1cblxuICBzdGF0aWMgY29tcHV0ZVN0cmlkZXMoZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgY29uc3QgcmFuayA9IGRpbXMubGVuZ3RoO1xuICAgIGlmIChyYW5rID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIGlmIChyYW5rID09PSAxKSB7XG4gICAgICByZXR1cm4gWzFdO1xuICAgIH1cbiAgICBjb25zdCBzdHJpZGVzID0gbmV3IEFycmF5KHJhbmspO1xuICAgIHN0cmlkZXNbcmFuayAtIDFdID0gMTtcbiAgICBzdHJpZGVzW3JhbmsgLSAyXSA9IGRpbXNbcmFuayAtIDFdO1xuICAgIGZvciAobGV0IGkgPSByYW5rIC0gMzsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHN0cmlkZXNbaV0gPSBzdHJpZGVzW2kgKyAxXSAqIGRpbXNbaSArIDFdO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaWRlcztcbiAgfVxuXG4gIHN0YXRpYyB0cmFuc3Bvc2UoZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgY29uc3QgY29weSA9IGRpbXMuc2xpY2UoKTtcbiAgICByZXR1cm4gY29weS5yZXZlcnNlKCk7XG4gIH1cblxuICBzdGF0aWMgaW5kaWNlc1RvT2Zmc2V0KGluZGljZXM6IHJlYWRvbmx5IG51bWJlcltdLCBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSwgYXhpcz86IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKGF4aXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYXhpcyA9IGluZGljZXMubGVuZ3RoO1xuICAgIH1cbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF4aXM7ICsraSkge1xuICAgICAgb2Zmc2V0ICs9IHN0cmlkZXNbaV0gKiBpbmRpY2VzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgc3RhdGljIG9mZnNldFRvSW5kaWNlcyhvZmZzZXQ6IG51bWJlciwgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgY29uc3QgcmFuayA9IHN0cmlkZXMubGVuZ3RoO1xuICAgIGlmIChyYW5rID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIGlmIChyYW5rID09PSAxKSB7XG4gICAgICByZXR1cm4gW29mZnNldCAqIHN0cmlkZXNbMF1dO1xuICAgIH1cbiAgICBjb25zdCBpbmRpY2VzOiBudW1iZXJbXSA9IG5ldyBBcnJheShzdHJpZGVzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgaW5kaWNlc1tpXSA9IE1hdGguZmxvb3Iob2Zmc2V0IC8gc3RyaWRlc1tpXSk7XG4gICAgICBvZmZzZXQgLT0gaW5kaWNlc1tpXSAqIHN0cmlkZXNbaV07XG4gICAgfVxuICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSA9IG9mZnNldDtcbiAgICByZXR1cm4gaW5kaWNlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBub3JtYWlsemUgYXhpcyBvZiByYW5nZSBbLXIsIHIpIGludG8gWzAsIHIpLlxuICAgKi9cbiAgc3RhdGljIG5vcm1hbGl6ZUF4aXMoYXhpczogbnVtYmVyLCB0ZW5zb3JSYW5rOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChheGlzIDwgLXRlbnNvclJhbmsgJiYgYXhpcyA+PSB0ZW5zb3JSYW5rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIGF4aXMgZm9yIHRoaXMgb3BlcmF0aW9uLicpO1xuICAgIH1cbiAgICByZXR1cm4gYXhpcyA8IDAgPyBheGlzICsgdGVuc29yUmFuayA6IGF4aXM7XG4gIH1cblxuICBzdGF0aWMgbm9ybWFsaXplQXhlcyhheGVzOiByZWFkb25seSBudW1iZXJbXSwgdGVuc29yUmFuazogbnVtYmVyKTogbnVtYmVyW10ge1xuICAgIHJldHVybiBheGVzLm1hcCh4ID0+IHRoaXMubm9ybWFsaXplQXhpcyh4LCB0ZW5zb3JSYW5rKSk7XG4gIH1cblxuICAvLyBJbmNyZW1lbnQgYW4gaW5kZXggaW50byBhIHRlbnNvciAoaW4gbGV4aWNvZ3JhcGhpY1xuICAvLyBvcmRlcmluZyksIHdyYXBwaW5nIGFyb3VuZCB0aGUgc3BlY2lmaWVkIHVwcGVyX2JvdW5kLlxuICAvKipcbiAgICogSW5jcmVtZW50IGFuIGluZGV4IGludG8gYSB0ZW5zb3IgKGluIGxleGljb2dyYXBoaWMgb3JkZXJpbmcpLCB3cmFwcGluZyBhcm91bmQgdGhlIHNwZWNpZmllZCB1cHBlcl9ib3VuZC5cbiAgICogQHBhcmFtIGluZGV4IEdpdmVuIGluZGV4IHRvIGluY3JlbWVudCAoV2lsbCBiZSBtdXRhdGVkKVxuICAgKiBAcGFyYW0gZGltcyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgdGVuc29yIGZvciB3aGljaCB0aGUgZ2l2ZW4gaW5kZXggY29ycmVzcG9uZHMgdG9cbiAgICogQHBhcmFtIGF4aXNUb0luY3JlbWVudE9uIFRoZSAxLWluZGV4ZWQgYXhpcyB0byBpbmNyZW1lbnQgb24uIElmIHVuZGVmaW5lZCwgYXhpc1RvSW5jcmVtZW50T24gPT0gcmFua1xuICAgKi9cbiAgc3RhdGljIGluY3JlbWVudEluZGV4KGluZGV4OiBudW1iZXJbXSwgZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4aXNUb0luY3JlbWVudE9uPzogbnVtYmVyKSB7XG4gICAgaWYgKGRpbXMubGVuZ3RoID09PSAwIHx8IGluZGV4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmRleCBpbmNyZW1lbnRpbmcgdW5zdXBwb3J0ZWQgZm9yIHNjYWxhciBUZW5zb3InKTtcbiAgICB9XG4gICAgaWYgKGF4aXNUb0luY3JlbWVudE9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGF4aXNUb0luY3JlbWVudE9uID0gZGltcy5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChheGlzVG9JbmNyZW1lbnRPbiA8PSAwIHx8IGF4aXNUb0luY3JlbWVudE9uID4gZGltcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgYXhpcyB0byBpbmNyZW1lbnQgb24nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBrID0gYXhpc1RvSW5jcmVtZW50T24gLSAxOyBrID49IDA7IC0taykge1xuICAgICAgaW5kZXhba10rKztcbiAgICAgIGlmIChpbmRleFtrXSA8IGRpbXNba10pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpbmRleFtrXSA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb2R1Y2VzIGEgbmV3IGRpbWVuc2lvbnMgYXJyYXkgYmFzZWQgb24gdGhlIHZhbHVlcyBpbiB0aGUgJ29yaWdpbmFsRGltZW5zaW9ucycgYW5kICdzaGFwZScgYXJyYXlcbiAgICogVXNlZCBpbiBSZXNoYXBlXG4gICAqIEBwYXJhbSBvcmlnaW5hbERpbXMgT3JpZ2luYWwgU2hhcGUgYXJyYXlcbiAgICogQHBhcmFtIHNoYXBlSGludHMgYXJyYXkgY29udGFpbmluZyB2YWx1ZXMgdG8gY29tcHV0ZSB0aGUgbmV3IGRpbWVuc2lvbnNcbiAgICogRm9yIGV4YW1wbGU6XG4gICAqIG9yaWdpbmFsRGltcyA9IFsyLDJdIGFuZCBzaGFwZUhpbnRzID0gWzAsLTFdIHdpbGwgcmV0dXJuIFsyLDJdXG4gICAqIG9yaWdpbmFsRGltcyA9IFsyLDJdIGFuZCBzaGFwZUhpbnRzID0gWzRdIHdpbGwgcmV0dXJuIFs0XVxuICAgKiBvcmlnaW5hbERpbXMgPSBbMiwyXSBhbmQgc2hhcGVIaW50cyA9IFs1XSB3aWxsIHRocm93IGFuIGV4Y2VwdGlvblxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vb25ueC9vbm54L2Jsb2IvbWFpbi9kb2NzL09wZXJhdG9ycy5tZCNSZXNoYXBlXG4gICAqL1xuXG4gIHN0YXRpYyBjYWxjdWxhdGVSZXNoYXBlZERpbXMob3JpZ2luYWxEaW1zOiByZWFkb25seSBudW1iZXJbXSwgc2hhcGVIaW50czogQXJyYXlMaWtlPG51bWJlcj4pOiBudW1iZXJbXSB7XG4gICAgLy8gcmVzaGFwZSB0byBhIFNjYWxhciBUZW5zb3JcbiAgICBpZiAoc2hhcGVIaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChvcmlnaW5hbERpbXMubGVuZ3RoID09PSAwIHx8IFNoYXBlVXRpbC5zaXplKG9yaWdpbmFsRGltcykgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgcmVzaGFwZSB0byBhIHNjYWxhciBUZW5zb3InKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBuRGltcyA9IHNoYXBlSGludHMubGVuZ3RoO1xuICAgIGNvbnN0IHJlc2hhcGVkRGltcyA9IG5ldyBBcnJheTxudW1iZXI+KG5EaW1zKTtcbiAgICBsZXQgdW5rbm93bkRpbWVuc2lvbiA9IC0xO1xuICAgIGxldCBuZXdUZW5zb3JTaXplID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5EaW1zOyBpKyspIHtcbiAgICAgIGlmIChzaGFwZUhpbnRzW2ldIDwgLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhIGRpbWVuc2lvbiBpbiBzaGFwZSBoaW50cyBjYW5ub3QgYmUgbGVzcyB0aGFuIC0xJyk7XG4gICAgICB9XG4gICAgICBpZiAoc2hhcGVIaW50c1tpXSA9PT0gLTEpIHtcbiAgICAgICAgaWYgKHVua25vd25EaW1lbnNpb24gIT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdCBtb3N0IG9uZSBkaW1lbnNpb24gaW4gc2hhcGUgaGludHMgY2FuIGJlIC0xJyk7XG4gICAgICAgIH1cbiAgICAgICAgdW5rbm93bkRpbWVuc2lvbiA9IGk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2hhcGVIaW50c1tpXSA9PT0gMCkge1xuICAgICAgICAgIGlmIChpID49IG9yaWdpbmFsRGltcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGhlIGRpbWVuc2lvbiB3aXRoIHZhbHVlIHplcm8gZXhjZWVkcyB0aGUgZGltZW5zaW9uIHNpemUgb2YgdGhlIGlucHV0IHRlbnNvcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNoYXBlZERpbXNbaV0gPSBvcmlnaW5hbERpbXNbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzaGFwZWREaW1zW2ldID0gc2hhcGVIaW50c1tpXTtcbiAgICAgICAgfVxuICAgICAgICBuZXdUZW5zb3JTaXplICo9IHJlc2hhcGVkRGltc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvbGRUZW5zb3JTaXplID0gU2hhcGVVdGlsLnNpemUob3JpZ2luYWxEaW1zKTtcbiAgICBpZiAodW5rbm93bkRpbWVuc2lvbiAhPT0gLTEpIHtcbiAgICAgIGlmIChvbGRUZW5zb3JTaXplICUgbmV3VGVuc29yU2l6ZSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHRoZSBpbnB1dCB0ZW5zb3IgY2Fubm90IGJlIHJlc2hhcGVkIHRvIHRoZSByZXF1ZXN0ZWQgc2hhcGUuIElucHV0IHNoYXBlOiBbJHtcbiAgICAgICAgICAgIG9yaWdpbmFsRGltc31dIE91dHB1dCBzaGFwZTogWyR7c2hhcGVIaW50c31dYCk7XG4gICAgICB9XG4gICAgICByZXNoYXBlZERpbXNbdW5rbm93bkRpbWVuc2lvbl0gPSBvbGRUZW5zb3JTaXplIC8gbmV3VGVuc29yU2l6ZTtcbiAgICB9XG4gICAgLy8gdmFsaWRhdGUgc2l6ZXMgZnJvbSBvcmlnaW5hbERpbXMgYW5kIHJlc2hhcGVkRGltcyBtYXRjaFxuICAgIGVsc2Uge1xuICAgICAgaWYgKG5ld1RlbnNvclNpemUgIT09IG9sZFRlbnNvclNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXNoYXBlZERpbXMgYW5kIG9yaWdpbmFsRGltcyBkb25cXCd0IGhhdmUgbWF0Y2hpbmcgc2l6ZXMnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc2hhcGVkRGltcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTb3J0cyBhIGdpdmVuIGFycmF5IGJhc2VkIG9uIHRoZSBpbmRpY2VzIGluIHRoZSBQZXJtIGFycmF5XG4gICAqIFVzZWQgaW4gVHJhbnNwb3NlXG4gICAqIEBwYXJhbSBhIEFycmF5IHRvIGJlIHNvcnRlZCBzdWNoIGFzIGRpbXMgb3Igc3RyaWRlc1xuICAgKiBAcGFyYW0gcGVybSBQZXJtIGdpdmVuOyBpZiBudWxsIGEgd2lsbCBiZSByZXZlcnNlZFxuICAgKi9cbiAgc3RhdGljIHNvcnRCYXNlZE9uUGVybShhOiByZWFkb25seSBudW1iZXJbXSwgcGVybT86IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGlmIChwZXJtKSB7XG4gICAgICByZXR1cm4gcGVybS5tYXAoKHYpID0+IGFbdl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYS5zbGljZSgpLnJldmVyc2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFkcyBhIGdpdmVuIHNoYXBlIGFjY29yZGluZyB0byB0aGUgcGFkZGluZyB2YWx1ZXNcbiAgICogQHBhcmFtIGRpbXMgc2hhcGUgb2YgdGhlIFRlbnNvciB0byBiZSBwYWRkZWRcbiAgICogQHBhcmFtIHBhZCBwYWQgdmFsdWVzXG4gICAqL1xuICBzdGF0aWMgcGFkU2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIHBhZDogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgY29uc3QgcmFuayA9IGRpbXMubGVuZ3RoO1xuICAgIHJldHVybiBkaW1zLm1hcCgodiwgaSkgPT4gdiArIHBhZFtpXSArIHBhZFtpICsgcmFua10pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIHR3byBzaGFwZXMgYXJlIGlkZW50aWNhbFxuICAgKiBAcGFyYW0gc2hhcGUxXG4gICAqIEBwYXJhbSBzaGFwZTJcbiAgICovXG4gIHN0YXRpYyBhcmVFcXVhbChzaGFwZTE6IHJlYWRvbmx5IG51bWJlcltdLCBzaGFwZTI6IHJlYWRvbmx5IG51bWJlcltdKTogYm9vbGVhbiB7XG4gICAgaWYgKHNoYXBlMS5sZW5ndGggIT09IHNoYXBlMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYXBlMS5ldmVyeSgodiwgaSkgPT4gdiA9PT0gc2hhcGUyW2ldKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgaWYgdGhlIGdpdmVuIGBkaW1zYCBvciBgc2hhcGVgIGlzIHZhbGlkIGluIE9OTlguanMgY29udGV4dCBhbmQgcmV0dXJucyBkYXRhIHNpemVcbiAgICogQHBhcmFtIGRpbXMgLSBpbnB1dCBgZGltc2AgdGhhdCBuZWVkcyB0byBiZSBjaGVja2VkXG4gICAqL1xuICBzdGF0aWMgdmFsaWRhdGVEaW1zQW5kQ2FsY1NpemUoZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXIge1xuICAgIGlmIChkaW1zLmxlbmd0aCA+IDYpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09ubHkgcmFuayAwIHRvIDYgaXMgc3VwcG9ydGVkIGZvciB0ZW5zb3Igc2hhcGUuJyk7XG4gICAgfVxuICAgIGxldCBzaXplID0gMTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgZGltcykge1xuICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG4pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgc2hhcGU6ICR7bn0gaXMgbm90IGFuIGludGVnZXJgKTtcbiAgICAgIH1cbiAgICAgIGlmIChuIDwgMCB8fCBuID4gMjE0NzQ4MzY0Nykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHNoYXBlOiBsZW5ndGggJHtufSBpcyBub3QgYWxsb3dlZGApO1xuICAgICAgfVxuICAgICAgc2l6ZSAqPSBuO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBzaGFwZSBvZiBvdXRwdXQgdGVuc29yIHkgPSBmbGF0dGVuKHgsIGF4aXMpXG4gICAqIEBwYXJhbSBkaW1zIC0gc2hhcGUgb2YgaW5wdXQgdGVuc29yXG4gICAqIEBwYXJhbSBheGlzIC0gZmxhdHRlbiBheGlzLCBpbiB0aGUgcmFuZ2UgWy1yLCByXVxuICAgKi9cbiAgc3RhdGljIGZsYXR0ZW5TaGFwZShkaW1zOiByZWFkb25seSBudW1iZXJbXSwgYXhpczogbnVtYmVyKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGlmIChheGlzIDwgMCkge1xuICAgICAgYXhpcyArPSBkaW1zLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgdG90YWwgPSBkaW1zLnJlZHVjZSgoeCwgeSkgPT4geCAqIHksIDEpO1xuICAgIGNvbnN0IHJpZ2h0ID0gZGltcy5zbGljZShheGlzKS5yZWR1Y2UoKHgsIHkpID0+IHggKiB5LCAxKTtcbiAgICBjb25zdCBvdXRwdXREaW1zID0gW3RvdGFsIC8gcmlnaHQsIHJpZ2h0XTtcblxuICAgIHJldHVybiBvdXRwdXREaW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIHNoYXBlIG9mIG91dHB1dCB0ZW5zb3IgeSA9IHNxdWVlemUoeCwgYXhlcylcbiAgICogQHBhcmFtIGRpbXMgLSBzaGFwZSBvZiBpbnB1dCB0ZW5zb3JcbiAgICogQHBhcmFtIGF4ZXMgLSBzcXVlZXplIGF4ZXNcbiAgICovXG4gIHN0YXRpYyBzcXVlZXplU2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGNvbnN0IG91dHB1dERpbXMgPSBuZXcgQXJyYXk8bnVtYmVyPigpO1xuXG4gICAgLy8gc2FuaXR5IGNoZWNrXG4gICAgYXhlcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKGF4ZXMsIGRpbXMubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5TcXVlZXplTGlzdCA9IGF4ZXMuaW5kZXhPZihpKSA+PSAwO1xuICAgICAgaWYgKGluU3F1ZWV6ZUxpc3QgJiYgZGltc1tpXSAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NxdWVlemUgYW4gYXhpcyBvZiBzaXplIGRpZmZlcmVudCB0aGFuIDEnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChheGVzLmxlbmd0aCA9PT0gMCAmJiBkaW1zW2ldID4gMSkgfHwgKGF4ZXMubGVuZ3RoID4gMCAmJiAhaW5TcXVlZXplTGlzdCkpIHtcbiAgICAgICAgb3V0cHV0RGltcy5wdXNoKGRpbXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXREaW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIHNoYXBlIG9mIG91dHB1dCB0ZW5zb3IgeSA9IHVuc3F1ZWV6ZSh4LCBheGVzKVxuICAgKiBAcGFyYW0gZGltcyAtIHNoYXBlIG9mIGlucHV0IHRlbnNvclxuICAgKiBAcGFyYW0gYXhlcyAtIHVuc3F1ZWV6ZSBheGVzXG4gICAqL1xuICBzdGF0aWMgdW5zcXVlZXplU2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGNvbnN0IG91dHB1dERpbXMgPSBuZXcgQXJyYXk8bnVtYmVyPihkaW1zLmxlbmd0aCArIGF4ZXMubGVuZ3RoKTtcblxuICAgIC8vIGluaXRpYWxpemUgdGhlIGFycmF5IGVsZW1lbnRzIHRvIDBcbiAgICBvdXRwdXREaW1zLmZpbGwoMCk7XG5cbiAgICAvLyBzZXQgYWxsIGF4ZXMgaW5kaWNlcyB0byAxIGluIG91dHB1dERpbXMgYW5kIGNoZWNrIGZvciBkdXBsaWNhdGVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXhlc1tpXSwgb3V0cHV0RGltcy5sZW5ndGgpO1xuICAgICAgaWYgKGF4aXMgPj0gb3V0cHV0RGltcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcXCdheGVzXFwnIGhhcyBhbiBvdXQgb2YgcmFuZ2UgYXhpcycpO1xuICAgICAgfVxuICAgICAgaWYgKG91dHB1dERpbXNbYXhpc10gIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcXCdheGVzXFwnIGhhcyBhIGR1cGxpY2F0ZSBheGlzJyk7XG4gICAgICB9XG5cbiAgICAgIG91dHB1dERpbXNbYXhpc10gPSAxO1xuICAgIH1cblxuICAgIC8vIGZpbGwgaW4gdGhlIHplcm8gZW50cmllcyBvZiBvdXRwdXREaW1zIHdpdGggdGhlIGlucHV0IHRlbnNvcidzIHNoYXBlXG4gICAgbGV0IGlucHV0RGltc0l0ZXJhdG9yID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dERpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChvdXRwdXREaW1zW2ldID09PSAwKSB7XG4gICAgICAgIG91dHB1dERpbXNbaV0gPSBkaW1zW2lucHV0RGltc0l0ZXJhdG9yKytdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNhbml0eSBjaGVjayBhc3NlcnRpb24uICdpbnB1dERpbXNJdGVyYXRvcidcbiAgICAvLyBzaG91bGQgYmUgZXF1YWwgdG8gdGhlIGxlbmd0aCBvZiAnZGltcydcbiAgICBpZiAoaW5wdXREaW1zSXRlcmF0b3IgIT09IGRpbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZSB1bnNxdWVlemVkIGRpbWVuc2lvbiBjb3VsZCBub3QgYmUgZXN0YWJsaXNoZWQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0RGltcztcbiAgfVxufVxuXG4vLyBidW5jaCBvZiBoZWxwZXIgbWV0aG9kcyB0aGF0IGRvIGEgdmFyaWV0eSBvZiBtYXRoIG9wZXJhdGlvbnNcbmV4cG9ydCBjbGFzcyBNYXRoVXRpbCB7XG4gIC8vIHkgPSAoeCp4KSArIHlcbiAgc3RhdGljIHNxcihcbiAgICAgIHRhcmdldDogbnVtYmVyW118VGVuc29yLk51bWJlclR5cGUsIHNvdXJjZTogbnVtYmVyW118VGVuc29yLk51bWJlclR5cGUsIHRhcmdldEluZGV4OiBudW1iZXIsIHNvdXJjZUluZGV4OiBudW1iZXIsXG4gICAgICBibG9ja1NpemU6IG51bWJlcikge1xuICAgIGlmIChzb3VyY2VJbmRleCA8IDAgfHwgc291cmNlSW5kZXggPj0gc291cmNlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VJbmRleCBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmICh0YXJnZXRJbmRleCA8IDAgfHwgdGFyZ2V0SW5kZXggPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXRJbmRleCBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmIChzb3VyY2VJbmRleCArIGJsb2NrU2l6ZSA+IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlIGluZGljZXMgdG8gYmUgY29waWVkIGFyZSBvdXRzaWRlIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0SW5kZXggKyBibG9ja1NpemUgPiB0YXJnZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldCBhcnJheSBpcyB0b28gc21hbGwgdG8gaG9sZCByZXN1bHQnKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCBibG9ja1NpemU7IG9mZnNldCsrKSB7XG4gICAgICB0YXJnZXRbdGFyZ2V0SW5kZXggKyBvZmZzZXRdICs9IE1hdGgucG93KHNvdXJjZVtzb3VyY2VJbmRleCArIG9mZnNldF0sIDIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHkgPSBheCArIHlcbiAgc3RhdGljIGF4cHkoXG4gICAgICB0YXJnZXQ6IG51bWJlcltdfFRlbnNvci5OdW1iZXJUeXBlLCBzb3VyY2U6IG51bWJlcltdfFRlbnNvci5OdW1iZXJUeXBlLCB0YXJnZXRJbmRleDogbnVtYmVyLCBzb3VyY2VJbmRleDogbnVtYmVyLFxuICAgICAgYmxvY2tTaXplOiBudW1iZXIsIGFscGhhOiBudW1iZXIpIHtcbiAgICBpZiAoc291cmNlSW5kZXggPCAwIHx8IHNvdXJjZUluZGV4ID49IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlSW5kZXggb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0SW5kZXggPCAwIHx8IHRhcmdldEluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0SW5kZXggb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAoc291cmNlSW5kZXggKyBibG9ja1NpemUgPiBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZSBpbmRpY2VzIHRvIGJlIGNvcGllZCBhcmUgb3V0c2lkZSBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldEluZGV4ICsgYmxvY2tTaXplID4gdGFyZ2V0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXQgYXJyYXkgaXMgdG9vIHNtYWxsIHRvIGhvbGQgcmVzdWx0Jyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgYmxvY2tTaXplOyBvZmZzZXQrKykge1xuICAgICAgdGFyZ2V0W3RhcmdldEluZGV4ICsgb2Zmc2V0XSArPSAoYWxwaGEgKiBzb3VyY2Vbc291cmNlSW5kZXggKyBvZmZzZXRdKTtcbiAgICB9XG4gIH1cblxuICAvLyB5ID0gcG93KHgsIGIpXG4gIHN0YXRpYyBwb3d4KFxuICAgICAgdGFyZ2V0OiBudW1iZXJbXXxUZW5zb3IuTnVtYmVyVHlwZSwgc291cmNlOiBudW1iZXJbXXxUZW5zb3IuTnVtYmVyVHlwZSwgdGFyZ2V0SW5kZXg6IG51bWJlciwgc291cmNlSW5kZXg6IG51bWJlcixcbiAgICAgIGJsb2NrU2l6ZTogbnVtYmVyLCBiOiBudW1iZXIpIHtcbiAgICBpZiAoc291cmNlSW5kZXggPCAwIHx8IHNvdXJjZUluZGV4ID49IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc291cmNlSW5kZXggb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0SW5kZXggPCAwIHx8IHRhcmdldEluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0SW5kZXggb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICBpZiAoc291cmNlSW5kZXggKyBibG9ja1NpemUgPiBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZSBpbmRpY2VzIHRvIGJlIGNvcGllZCBhcmUgb3V0c2lkZSBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldEluZGV4ICsgYmxvY2tTaXplID4gdGFyZ2V0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXQgYXJyYXkgaXMgdG9vIHNtYWxsIHRvIGhvbGQgcmVzdWx0Jyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgYmxvY2tTaXplOyBvZmZzZXQrKykge1xuICAgICAgdGFyZ2V0W3RhcmdldEluZGV4ICsgb2Zmc2V0XSA9IE1hdGgucG93KHNvdXJjZVtzb3VyY2VJbmRleCArIG9mZnNldF0sIGIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHkgPSB4ICogeVxuICBzdGF0aWMgbXVsKFxuICAgICAgdGFyZ2V0OiBudW1iZXJbXXxUZW5zb3IuTnVtYmVyVHlwZSwgc291cmNlOiBudW1iZXJbXXxUZW5zb3IuTnVtYmVyVHlwZSwgdGFyZ2V0SW5kZXg6IG51bWJlciwgc291cmNlSW5kZXg6IG51bWJlcixcbiAgICAgIGJsb2NrU2l6ZTogbnVtYmVyKSB7XG4gICAgaWYgKHNvdXJjZUluZGV4IDwgMCB8fCBzb3VyY2VJbmRleCA+PSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NvdXJjZUluZGV4IG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldEluZGV4IDwgMCB8fCB0YXJnZXRJbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldEluZGV4IG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZUluZGV4ICsgYmxvY2tTaXplID4gc291cmNlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2UgaW5kaWNlcyB0byBiZSBjb3BpZWQgYXJlIG91dHNpZGUgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmICh0YXJnZXRJbmRleCArIGJsb2NrU2l6ZSA+IHRhcmdldC5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0IGFycmF5IGlzIHRvbyBzbWFsbCB0byBob2xkIHJlc3VsdCcpO1xuICAgIH1cblxuICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IGJsb2NrU2l6ZTsgb2Zmc2V0KyspIHtcbiAgICAgIHRhcmdldFt0YXJnZXRJbmRleCArIG9mZnNldF0gPSAoc291cmNlW3NvdXJjZUluZGV4ICsgb2Zmc2V0XSAqIHRhcmdldFt0YXJnZXRJbmRleCArIG9mZnNldF0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU3BsaXRVdGlsIHtcbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgbmV3IFNoYXBlcyBmcm9tIGV4aXN0aW5nIG9uZSBhbmQgdGhlIHNwbGl0cyBnaXZlbiBhbG9uZyB0aGUgYXhpcyBwcm92aWRlc1xuICAgKiBAcGFyYW0gZGltcyBTaGFwZSBvZiB0aGUgVGVuc29yIHRvIGJlIHNwbGl0dGVkIGludG8gdHdvIG9yIG1vcmUgU2hhcGVzXG4gICAqIEBwYXJhbSBheGlzIFRoZSBkaW1lbnNpb24gYWxvbmcgd2hpY2ggdGhlIFRlbnNvciB3aWxsIGJlIHNwbGl0XG4gICAqIEBwYXJhbSBzcGxpdHMgT2Zmc2V0cyBmb3IgdGhlIHN0YXJ0IG9mIGVhY2ggc3BsaXRcbiAgICovXG4gIHN0YXRpYyBzcGxpdFNoYXBlKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGlzOiBudW1iZXIsIHNwbGl0OiBudW1iZXJbXSwgbnVtT3V0cHV0cz86IG51bWJlcik6XG4gICAgICBbbnVtYmVyW11bXSwgbnVtYmVyW11dIHtcbiAgICBpZiAoc3BsaXQubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAoIW51bU91dHB1dHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWVkIHRvIGtub3cgbnVtYmVyIG9mIG91dHB1dHMgd2hlbiB0aGUgXFwnc3BsaXRcXCcgYXR0cmlidXRlIGlzIG5vdCBzcGVjaWZpZWQnKTtcbiAgICAgIH1cbiAgICAgIFNwbGl0VXRpbC5kZXRlcm1pbmVTcGxpdChkaW1zW2F4aXNdLCBudW1PdXRwdXRzLCBzcGxpdCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2hhcGVzOiBudW1iZXJbXVtdID0gW107XG4gICAgY29uc3Qgb2Zmc2V0cyA9IFswXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwbGl0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICBvZmZzZXRzLnB1c2gob2Zmc2V0c1tpIC0gMV0gKyBzcGxpdFtpIC0gMV0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2hhcGUgPSBkaW1zLnNsaWNlKCk7XG4gICAgICBzaGFwZVtheGlzXSA9IHNwbGl0W2ldO1xuICAgICAgc2hhcGVzLnB1c2goc2hhcGUpO1xuICAgIH1cbiAgICByZXR1cm4gW3NoYXBlcywgb2Zmc2V0c107XG4gIH1cblxuICBzdGF0aWMgZGV0ZXJtaW5lU3BsaXQobnVtRWxlbWVudHNBbG9uZ0F4aXM6IG51bWJlciwgbnVtT3V0cHV0czogbnVtYmVyLCBzcGxpdDogbnVtYmVyW10pIHtcbiAgICAvLyBJZiAnc3BsaXQnIGlzIG5vdCBzcGVjaWZpZWQgYnkgdGhlIHVzZXIsIHdlIG5lZWQgdG8gcGFydGl0aW9uIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgZXF1YWxseSBhbW9uZyB0aGUgb3V0cHV0c1xuICAgIGlmIChudW1FbGVtZW50c0Fsb25nQXhpcyAlIG51bU91dHB1dHMgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNwbGl0IHRlbnNvciB0byBlcXVhbCBzaXplZCBwYXJ0cycpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU91dHB1dHM7ICsraSkge1xuICAgICAgc3BsaXQucHVzaChudW1FbGVtZW50c0Fsb25nQXhpcyAvIG51bU91dHB1dHMpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmVkdWNlVXRpbCB7XG4gIC8qKlxuICAgKiBQZXJmb3JtIHJlZHVjZSBvcGVyYXRpb25zIG9uIHRoZSBzcGVjaWZpYyBvcGVyYXRvclxuICAgKiBAcGFyYW0gYSBJbnB1dCB0ZW5zb3IgZGF0YVxuICAgKiBAcGFyYW0gYXhlcyBUaGUgZGltZW5zaW9ucyBhbG9uZyB3aGljaCB0aGUgVGVuc29yIHdpbGwgYmUgcmVkdWNlZFxuICAgKiBAcGFyYW0ga2VlcGRpbXMgSWYgc2V0IHRvIHRydWUsIHRoZSBheGVzIHdoaWNoIGFyZSByZWR1Y2VkIGFyZSBsZWZ0IGluIHRoZVxuICAgKiAgICByZXN1bHQgYXMgZGltZW5zaW9ucyB3aXRoIHNpemUgb25lLlxuICAgKiBAcGFyYW0gb3AxIFRoZSBvcGVyYXRpb24gdG8gYmUgcGVyZm9ybWVkIG9uIGVhY2ggZWxlbWVudCBpbiB0aGUgdGVuc29yXG4gICAqIEBwYXJhbSBvcDIgVGhlIG9wZXJhdGlvbiB0byBiZSBwZXJmb3JtZWQgYmV0d2VlbiBlbGVtZW50cyBpbiB0aGUgdGVuc29yXG4gICAqL1xuICBzdGF0aWMgY2FsY1JlZHVjZShcbiAgICAgIGE6IFRlbnNvciwgYXhlczogbnVtYmVyW10sIGtlZXBkaW1zOiBib29sZWFuLCBvcDE6IChiOiBudW1iZXIpID0+IG51bWJlcixcbiAgICAgIG9wMjogKGE6IG51bWJlciwgYjogbnVtYmVyKSA9PiBudW1iZXIpOiBUZW5zb3Ige1xuICAgIGNvbnN0IGRpbXMgPSBhLmRpbXMuc2xpY2UoMCk7XG4gICAgLy8gaWYgYXhlcyBpcyBub3Qgc2V0LCBwZXJmb3JtIHJlZHVjZSBvbiBhbGwgYXhlc1xuICAgIGlmIChheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGltcy5mb3JFYWNoKChfZCwgaW5kKSA9PiBheGVzLnB1c2goaW5kKSk7XG4gICAgfVxuICAgIC8vIGdldCBhIHRlbXBvcmFyeSBicm9hZGNhc3RhYmxlIG91dHB1dCBzaGFwZVxuICAgIGNvbnN0IG91dHB1dERpbXMgPSBSZWR1Y2VVdGlsLmNhbGNSZWR1Y2VTaGFwZShkaW1zLCBheGVzLCB0cnVlKTtcblxuICAgIC8vIGxvb3AgdGhyb3VnaCB0aGUgb3V0cHV0IGFuZCBjYWxjdWxhdGUgcmVzdWx0IG9uZSBieSBvbmVcbiAgICBjb25zdCBzaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0RGltcyk7XG4gICAgY29uc3QgeSA9IG5ldyBUZW5zb3Iob3V0cHV0RGltcywgYS50eXBlKTtcbiAgICBjb25zdCBzdHJpZGVzID0gU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKG91dHB1dERpbXMpO1xuICAgIGNvbnN0IGlucHV0U3RyaWRlcyA9IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhkaW1zKTtcbiAgICBjb25zdCBpbmRpY2VzWSA9IG5ldyBBcnJheShkaW1zLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIGNvbnN0IGluZGljZXMgPSBTaGFwZVV0aWwub2Zmc2V0VG9JbmRpY2VzKGksIHN0cmlkZXMpO1xuICAgICAgLy8gbWFwIGluZGV4XG4gICAgICBCcm9hZGNhc3RVdGlsLmZpbGxJbmRleChpbmRpY2VzLCBkaW1zLCBpbmRpY2VzWSk7XG4gICAgICB5LnNldChcbiAgICAgICAgICBpbmRpY2VzLFxuICAgICAgICAgIFJlZHVjZVV0aWwuY2FsY1JlZHVjZUJ5QXhpcyhcbiAgICAgICAgICAgICAgYS5udW1iZXJEYXRhLCBheGVzLCBkaW1zLCAwLCBTaGFwZVV0aWwuaW5kaWNlc1RvT2Zmc2V0KGluZGljZXNZLCBpbnB1dFN0cmlkZXMpLCBvcDEsIG9wMikpO1xuICAgIH1cblxuICAgIGlmIChrZWVwZGltcykge1xuICAgICAgcmV0dXJuIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGtlZXBkaW1zID09IDAsIGNhbGN1bGF0ZSB0aGUgZXhwZWN0ZWQgc2hhcGVcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKFxuICAgICAgICAgIFJlZHVjZVV0aWwuY2FsY1JlZHVjZVNoYXBlKGRpbXMsIGF4ZXMsIGtlZXBkaW1zKSwgeS50eXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgeS5kYXRhLCB5LmRhdGFJZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gcmVkdWNlIG9wZXJhdGlvbnMgb24gdGhlIHNwZWNpZmljIG9wZXJhdG9yIG9uIHNwZWNpZmljIGF4ZXNcbiAgICogQHBhcmFtIGEgSW5wdXQgdGVuc29yIGRhdGFcbiAgICogQHBhcmFtIGF4ZXMgVGhlIGRpbWVuc2lvbnMgYWxvbmcgd2hpY2ggdGhlIFRlbnNvciB3aWxsIGJlIHJlZHVjZWRcbiAgICogQHBhcmFtIGRpbXMgVGhlIGlucHV0IGRpbWVuc2lvbi5cbiAgICogQHBhcmFtIGN1ckF4aXNJbmQgSW5kZXggaW4gYXhlcyBzcGVjaWZ5aW5nIHRoZSBjdXJyZW50IGRpbWVuc2lvbiBhbG9uZ1xuICAgKiAgICAgIHdoaWNoIHRoZSB0ZW5zb3Igd2lsbCBiZSByZWR1Y2VkXG4gICAqIEBwYXJhbSBwb3MgVGhlIGN1cnJlbnQgaW5kZXggb2YgZWxlbWVudCB0byBwZXJmb3JtIG9wZXJhdGlvblxuICAgKiBAcGFyYW0gb3AxIFRoZSBvcGVyYXRpb24gdG8gYmUgcGVyZm9ybWVkIG9uIGVhY2ggZWxlbWVudCBpbiB0aGUgdGVuc29yXG4gICAqIEBwYXJhbSBvcDIgVGhlIG9wZXJhdGlvbiB0byBiZSBwZXJmb3JtZWQgYmV0d2VlbiBlbGVtZW50cyBpbiB0aGUgdGVuc29yXG4gICAqL1xuICBzdGF0aWMgY2FsY1JlZHVjZUJ5QXhpcyhcbiAgICAgIGlucHV0OiBUZW5zb3IuTnVtYmVyVHlwZSwgYXhlczogbnVtYmVyW10sIGRpbXM6IG51bWJlcltdLCBjdXJBeGlzSW5kOiBudW1iZXIsIHBvczogbnVtYmVyLFxuICAgICAgb3AxOiAoYjogbnVtYmVyKSA9PiBudW1iZXIsIG9wMjogKGE6IG51bWJlciwgYjogbnVtYmVyKSA9PiBudW1iZXIpOiBudW1iZXIge1xuICAgIGxldCByZXMgPSAwO1xuICAgIGlmIChjdXJBeGlzSW5kID49IGF4ZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gb3AxKGlucHV0W3Bvc10pO1xuICAgIH1cbiAgICBjb25zdCBheGlzID0gYXhlc1tjdXJBeGlzSW5kXTtcbiAgICBjb25zdCBzdGVwID0gYXhpcyA+PSBkaW1zLmxlbmd0aCA/IDEgOiBTaGFwZVV0aWwuc2l6ZShkaW1zLnNsaWNlKGF4aXMgKyAxKSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1zW2F4aXNdOyBpKyspIHtcbiAgICAgIHJlcyA9IGkgPT09IDAgPyBSZWR1Y2VVdGlsLmNhbGNSZWR1Y2VCeUF4aXMoaW5wdXQsIGF4ZXMsIGRpbXMsIGN1ckF4aXNJbmQgKyAxLCBwb3MsIG9wMSwgb3AyKSA6XG4gICAgICAgICAgICAgICAgICAgICAgb3AyKHJlcywgUmVkdWNlVXRpbC5jYWxjUmVkdWNlQnlBeGlzKGlucHV0LCBheGVzLCBkaW1zLCBjdXJBeGlzSW5kICsgMSwgcG9zLCBvcDEsIG9wMikpO1xuICAgICAgcG9zICs9IHN0ZXA7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBleHBlY3RlZCBzaGFwZSBvZiBhIHJlZHVjZSBvcGVyYXRpb25cbiAgICogQHBhcmFtIGRpbXMgVGhlIGlucHV0IHRlbnNvciBkaW1lbnNpb25cbiAgICogQHBhcmFtIGF4ZXMgVGhlIGRpbWVuc2lvbnMgYWxvbmcgd2hpY2ggdGhlIFRlbnNvciB3aWxsIGJlIHJlZHVjZWRcbiAgICogQHBhcmFtIGtlZXBkaW1zIElmIHNldCB0byB0cnVlLCB0aGUgYXhlcyB3aGljaCBhcmUgcmVkdWNlZCBhcmUgbGVmdCBpbiB0aGVcbiAgICogICAgcmVzdWx0IGFzIGRpbWVuc2lvbnMgd2l0aCBzaXplIG9uZS5cbiAgICovXG4gIHN0YXRpYyBjYWxjUmVkdWNlU2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLCBrZWVwRGltczogYm9vbGVhbik6IG51bWJlcltdIHtcbiAgICBjb25zdCBvdXRwdXREaW1zID0gZGltcy5zbGljZSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGtlZXBEaW1zKSB7XG4gICAgICAgIG91dHB1dERpbXNbYXhlc1tpXV0gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0RGltc1theGVzW2ldXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXREaW1zLmZpbHRlcihkaW0gPT4gZGltICE9PSAwKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUG9vbENvbnZVdGlsIHtcbiAgLyoqXG4gICAqIEFkanVzdCB0aGUga2VybmVsLCBzdHJpZGVzLCBwYWRzIHRvIGNvcnJlY3QgcmFuay4gU2V0IHRvIGRlZmF1bHQgdmFsdWUgaWYgbm90IHByZXNlbnRcbiAgICogQHBhcmFtIGlzR2xvYmFsT3BlcmF0b3IgSWYgdHJ1ZSwgcGVyZm9ybSBnbG9iYWwgcG9vbGluZy5cbiAgICogQHBhcmFtIGlucHV0RGltcyBUaGUgaW5wdXQgdGVuc29yIGRpbWVuc2lvbi5cbiAgICogQHBhcmFtIGtlcm5lbFNoYXBlIFRoZSBzaXplIG9mIHRoZSBrZXJuZWwgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gc3RyaWRlcyBTdHJpZGUgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gZGlsYXRpb25zIERpbGF0aW9uIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIHBhZHMgUGFkZGluZyBmb3IgdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIGFsb25nIGVhY2ggYXhpcy5cbiAgICovXG4gIHN0YXRpYyBhZGp1c3RQb29sQXR0cmlidXRlcyhcbiAgICAgIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sIGlucHV0RGltczogcmVhZG9ubHkgbnVtYmVyW10sIGtlcm5lbFNoYXBlOiBudW1iZXJbXSwgc3RyaWRlczogbnVtYmVyW10sXG4gICAgICBkaWxhdGlvbnM6IG51bWJlcltdLCBwYWRzOiBudW1iZXJbXSkge1xuICAgIGlmICghaXNHbG9iYWxPcGVyYXRvciAmJiBrZXJuZWxTaGFwZS5sZW5ndGggIT09IGlucHV0RGltcy5sZW5ndGggLSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiBzcGVjaWZpZWQga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgMiBsZXNzIHRoYW4gbGVuZ3RoIG9mIGlucHV0IGRpbWVuc2lvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAoaXNHbG9iYWxPcGVyYXRvcikge1xuICAgICAgLy8gYWRqdXN0IGtlcm5lbCBzaGFwZSB0byBjb3ZlciB0aGUgaW5wdXQgZGltc1xuICAgICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgaW5wdXREaW1zLmxlbmd0aCAtIDI7IGRpbSsrKSB7XG4gICAgICAgIGlmIChkaW0gPj0ga2VybmVsU2hhcGUubGVuZ3RoKSB7XG4gICAgICAgICAga2VybmVsU2hhcGUucHVzaChpbnB1dERpbXNbZGltICsgMl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtlcm5lbFNoYXBlW2RpbV0gPSBpbnB1dERpbXNbZGltICsgMl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGp1c3Qgc3RyaWRlcyBsZW5ndGggdG8gbWF0Y2gga2VybmVsIHNoYXBlIGxlbmd0aFxuICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGtlcm5lbFNoYXBlLmxlbmd0aDsgZGltKyspIHtcbiAgICAgIGlmIChkaW0gPCBzdHJpZGVzLmxlbmd0aCkge1xuICAgICAgICBpZiAoc3RyaWRlc1tkaW1dIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyaWRlcyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyaWRlcy5wdXNoKDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkanVzdCBkaWxhdGlvbiB2YWx1ZVxuICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGtlcm5lbFNoYXBlLmxlbmd0aDsgZGltKyspIHtcbiAgICAgIGlmIChkaW0gPCBkaWxhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChkaWxhdGlvbnNbZGltXSA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpbGF0aW9ucyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlsYXRpb25zLnB1c2goMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IHBhZHMgbGVuZ3RoIHRvIG1hdGNoIDIgKiBrZXJuZWwgc2hhcGUgbGVuZ3RoXG4gICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwga2VybmVsU2hhcGUubGVuZ3RoICogMjsgZGltKyspIHtcbiAgICAgIGlmIChkaW0gPCBwYWRzLmxlbmd0aCkge1xuICAgICAgICBpZiAocGFkc1tkaW1dIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYWRzLnB1c2goMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2FuaXR5IGNoZWNrcyBmb3IgdmFsdWVzIGluIGtlcm5lbCBzaGFwZXMgYW5kIHBhZHNcbiAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBrZXJuZWxTaGFwZS5sZW5ndGg7IGRpbSsrKSB7XG4gICAgICBpZiAoa2VybmVsU2hhcGVbZGltXSA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigna2VybmVsIHNoYXBlcyBuZWVkIHRvIGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWRzW2RpbV0gPj0ga2VybmVsU2hhcGVbZGltXSB8fCBwYWRzW2RpbSArIGtlcm5lbFNoYXBlLmxlbmd0aF0gPj0ga2VybmVsU2hhcGVbZGltXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZHMgc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiBrZXJuZWwnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBhZGp1c3QgcGFkIHZhbHVlcyBiYXNlZCBvbiAnYXV0b1BhZCcgYXR0cmlidXRlXG4gIHN0YXRpYyBhZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQoXG4gICAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSwgZGlsYXRpb25zOiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgIGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgcGFkczogbnVtYmVyW10sIGF1dG9QYWQ/OiBzdHJpbmcpIHtcbiAgICBpZiAoIWF1dG9QYWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocGFkcy5sZW5ndGggIT09IDIgKiAoaW5wdXREaW1zLmxlbmd0aCAtIDIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiBwYWRzIHNob3VsZCBiZSB0d2ljZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGlmIChzdHJpZGVzLmxlbmd0aCAhPT0gKGlucHV0RGltcy5sZW5ndGggLSAyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZW5ndGggb2Ygc3RyaWRlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAoa2VybmVsU2hhcGUubGVuZ3RoICE9PSAoaW5wdXREaW1zLmxlbmd0aCAtIDIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGlucHV0RGltcy5sZW5ndGggLSAyOyBkaW0rKykge1xuICAgICAgUG9vbENvbnZVdGlsLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKFxuICAgICAgICAgIGlucHV0RGltc1tkaW0gKyAyXSwgc3RyaWRlc1tkaW1dLCBkaWxhdGlvbnNbZGltXSwga2VybmVsU2hhcGVbZGltXSwgcGFkcywgZGltLCBkaW0gKyBpbnB1dERpbXMubGVuZ3RoIC0gMixcbiAgICAgICAgICBhdXRvUGFkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBvdXRwdXQgc2hhcGUgZm9yIFBvb2wgb3BzIGJhc2VkIG9uIGlucHV0IGF0dHJpYnV0ZXMuIChTaG91bGQgYmUgdXNlZCBvbmx5IGZvciBQb29sIG9wcylcbiAgICogQHBhcmFtIGlzR2xvYmFsT3BlcmF0b3IgSWYgdHJ1ZSwgcGVyZm9ybSBnbG9iYWwgcG9vbGluZy5cbiAgICogQHBhcmFtIGlucHV0RGltcyBUaGUgaW5wdXQgdGVuc29yIGRpbWVuc2lvbi4gKGlucHV0c1swXS5kaW1zKVxuICAgKiBAcGFyYW0gc3RyaWRlcyBTdHJpZGUgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gZGlsYXRpb25zIERpbGF0aW9uIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIGtlcm5lbFNoYXBlIFRoZSBzaXplIG9mIHRoZSBrZXJuZWwgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gcGFkcyBQYWRkaW5nIGZvciB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gYXV0b1BhZCBERVBSRUNBVEVEIGF0dHJpYnV0ZSBzdXBwb3J0ZWQgZm9yIGxlZ2FjeSBtb2RlbHMuIFNwZWNpZmllcyBob3cgdG8gaW1wbGljaXRseSBjYWxjdWxhdGUgcGFkcyBpbiBlYWNoXG4gICAqICAgICBkaW1lbnNpb24uIENhbiB0YWtlIHZhbHVlcyBOT1RTRVQsIFNBTUVfVVBQRVIsIFNBTUVfTE9XRVIsIG9yIFZBTElELlxuICAgKi9cbiAgc3RhdGljIGNvbXB1dGVQb29sT3V0cHV0U2hhcGUoXG4gICAgICBpc0dsb2JhbE9wZXJhdG9yOiBib29sZWFuLCBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBzdHJpZGVzOiBudW1iZXJbXSwgZGlsYXRpb25zOiBudW1iZXJbXSxcbiAgICAgIGtlcm5lbFNoYXBlOiBudW1iZXJbXSwgcGFkczogbnVtYmVyW10sIGF1dG9QYWQ/OiBzdHJpbmcpOiBudW1iZXJbXSB7XG4gICAgaWYgKGlucHV0RGltcy5sZW5ndGggPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBzaGFwZSBtdXN0IGJlIG9mIHNpemUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgYmF0Y2ggc2l6ZSBhbmQgbnVtYmVyIG9mIGNoYW5uZWxzIG9mIG91dHB1dFxuICAgIGNvbnN0IG91dHB1dERpbXMgPSBbaW5wdXREaW1zWzBdLCBpbnB1dERpbXNbMV1dO1xuXG4gICAgUG9vbENvbnZVdGlsLmNvbXB1dGVTaGFwZUhlbHBlcihcbiAgICAgICAgaXNHbG9iYWxPcGVyYXRvciwgaW5wdXREaW1zLCBvdXRwdXREaW1zLCBzdHJpZGVzLCBkaWxhdGlvbnMsIGtlcm5lbFNoYXBlLCBwYWRzLCBhdXRvUGFkKTtcbiAgICByZXR1cm4gb3V0cHV0RGltcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIG91dHB1dCBzaGFwZSBmb3IgQ29udiBvcCBiYXNlZCBvbiBpbnB1dCBhdHRyaWJ1dGVzLiAoU2hvdWxkIGJlIHVzZWQgb25seSBmb3IgQ29udiBvcClcbiAgICogQHBhcmFtIGlucHV0RGltcyBUaGUgaW5wdXQgdGVuc29yIGRpbWVuc2lvbi4gKGlucHV0c1swXS5kaW1zKVxuICAgKiBAcGFyYW0gZmlsdGVyRGltcyBUaGUgZmlsdGVyIHRlbnNvciBkaW1lbnNpb24uIChpbnB1dHNbMV0uZGltcylcbiAgICogQHBhcmFtIHN0cmlkZXMgU3RyaWRlIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIGtlcm5lbFNoYXBlIFRoZSBzaXplIG9mIHRoZSBrZXJuZWwgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gcGFkcyBQYWRkaW5nIGZvciB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gYXV0b1BhZCBERVBSRUNBVEVEIGF0dHJpYnV0ZSBzdXBwb3J0ZWQgZm9yIGxlZ2FjeSBtb2RlbHMuIFNwZWNpZmllcyBob3cgdG8gaW1wbGljaXRseSBjYWxjdWxhdGUgcGFkcyBpbiBlYWNoXG4gICAqICAgICBkaW1lbnNpb24uIENhbiB0YWtlIHZhbHVlcyBOT1RTRVQsIFNBTUVfVVBQRVIsIFNBTUVfTE9XRVIsIG9yIFZBTElELlxuICAgKi9cbiAgc3RhdGljIGNvbXB1dGVDb252T3V0cHV0U2hhcGUoXG4gICAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBmaWx0ZXJEaW1zOiByZWFkb25seSBudW1iZXJbXSwgc3RyaWRlczogbnVtYmVyW10sIGRpbGF0aW9uczogbnVtYmVyW10sXG4gICAgICBrZXJuZWxTaGFwZTogbnVtYmVyW10sIHBhZHM6IG51bWJlcltdLCBhdXRvUGFkPzogc3RyaW5nKTogbnVtYmVyW10ge1xuICAgIGlmIChpbnB1dERpbXMubGVuZ3RoIDw9IDAgfHwgZmlsdGVyRGltcy5sZW5ndGggPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGlucHV0IHRlbnNvciBkaW1zIG9yIGludmFsaWQgZmlsdGVyIHRlbnNvciBkaW1zJyk7XG4gICAgfVxuXG4gICAgLy8gQWRkIGJhdGNoIHNpemUgYW5kIG51bWJlciBvZiBjaGFubmVscyBvZiBvdXRwdXRcbiAgICBjb25zdCBvdXRwdXREaW1zID0gW2lucHV0RGltc1swXSwgZmlsdGVyRGltc1swXV07XG5cbiAgICBQb29sQ29udlV0aWwuY29tcHV0ZVNoYXBlSGVscGVyKGZhbHNlLCBpbnB1dERpbXMsIG91dHB1dERpbXMsIHN0cmlkZXMsIGRpbGF0aW9ucywga2VybmVsU2hhcGUsIHBhZHMsIGF1dG9QYWQpO1xuICAgIHJldHVybiBvdXRwdXREaW1zO1xuICB9XG5cbiAgLy8gd2lsbCBjb21wdXRlIG91dHB1dCBzaGFwZXMgZm9yIGRhdGEgZGltZW5zaW9ucyBPTkxZIChpLmUuKSBubyBiYXRjaCBzaXplIGFuZCBjaGFubmVsc1xuICAvLyBjYWxsZWQgYnkgY29tcHV0ZVBvb2xPdXRwdXRTaGFwZSgpIGFuZCBjb21wdXRlQ29udk91dHB1dFNoYXBlKClcbiAgLy8gYWRqdXN0IHBhZHMgYmFzZWQgb24gJ2F1dG9QYWQnIGF0dHJpYnV0ZSBwcmlvciB0byBzaGFwZSBjb21wdXRhdGlvblxuICBwcml2YXRlIHN0YXRpYyBjb21wdXRlU2hhcGVIZWxwZXIoXG4gICAgICBpc0dsb2JhbE9wZXJhdG9yOiBib29sZWFuLCBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBvdXRwdXREaW1zOiBudW1iZXJbXSwgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgICBkaWxhdGlvbnM6IHJlYWRvbmx5IG51bWJlcltdLCBrZXJuZWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHBhZHM6IG51bWJlcltdLCBhdXRvUGFkPzogc3RyaW5nKSB7XG4gICAgaWYgKGlzR2xvYmFsT3BlcmF0b3IpIHtcbiAgICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGlucHV0RGltcy5sZW5ndGggLSAyOyBkaW0rKykge1xuICAgICAgICBvdXRwdXREaW1zLnB1c2goMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGlucHV0RGltcy5sZW5ndGggLSAyOyBkaW0rKykge1xuICAgICAgICBvdXRwdXREaW1zLnB1c2goUG9vbENvbnZVdGlsLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKFxuICAgICAgICAgICAgaW5wdXREaW1zW2RpbSArIDJdLCBzdHJpZGVzW2RpbV0sIGRpbGF0aW9uc1tkaW1dLCBrZXJuZWxTaGFwZVtkaW1dLCBwYWRzLCBkaW0sIGRpbSArIGlucHV0RGltcy5sZW5ndGggLSAyLFxuICAgICAgICAgICAgYXV0b1BhZCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGhlbHBlciBmb3IgY29tcHV0ZVNoYXBlSGVscGVyKCkgYW5kIGFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCgpXG4gIC8vIGFkanVzdHMgcGFkIHZhbHVlIGZvciBnaXZlbiAnYXV0b1BhZCcgc3RyaW5nIGFuZCBjb21wdXRlcyBvdXRwdXQgc2hhcGUgYWxvbmcgYSBwYXJ0aWN1bGFyIGRpbWVuc2lvblxuICBwcml2YXRlIHN0YXRpYyBhZGp1c3RQYWRBbmRSZXR1cm5TaGFwZShcbiAgICAgIGluU2l6ZTogbnVtYmVyLCBzdHJpZGU6IG51bWJlciwgZGlsYXRpb246IG51bWJlciwga2VybmVsOiBudW1iZXIsIHBhZHM6IG51bWJlcltdLCBwYWRIZWFkSW5kZXg6IG51bWJlcixcbiAgICAgIHBhZFRhaWxJbmRleDogbnVtYmVyLCBhdXRvUGFkPzogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBjb25zdCBka2VybmVsID0gZGlsYXRpb24gKiAoa2VybmVsIC0gMSkgKyAxO1xuICAgIGlmIChhdXRvUGFkICYmIGF1dG9QYWQgIT09ICdOT1RTRVQnKSB7XG4gICAgICBzd2l0Y2ggKGF1dG9QYWQpIHtcbiAgICAgICAgY2FzZSAnVkFMSUQnOlxuICAgICAgICAgIHBhZHNbcGFkSGVhZEluZGV4XSA9IDA7XG4gICAgICAgICAgcGFkc1twYWRUYWlsSW5kZXhdID0gMDtcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoKGluU2l6ZSAtIGRrZXJuZWwpIC8gc3RyaWRlKSArIDEpO1xuICAgICAgICBjYXNlICdTQU1FX0xPV0VSJzpcbiAgICAgICAgY2FzZSAnU0FNRV9VUFBFUic6XG4gICAgICAgICAgaWYgKGRpbGF0aW9uICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpbGF0aW9uIG5vdCBzdXBwb3J0ZWQgZm9yIFNBTUVfVVBQRVIgb3IgU0FNRV9MT1dFUicpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBsZWdhY3lUYXJnZXRTaXplID0gKGluU2l6ZSArIHN0cmlkZSAtIDEpIC8gc3RyaWRlO1xuICAgICAgICAgICAgY29uc3QgcGFkTmVlZGVkID0gKGxlZ2FjeVRhcmdldFNpemUgLSAxKSAqIHN0cmlkZSArIGtlcm5lbCAtIGluU2l6ZTtcbiAgICAgICAgICAgIHBhZHNbcGFkSGVhZEluZGV4XSA9XG4gICAgICAgICAgICAgICAgKGF1dG9QYWQgPT09ICdTQU1FX0xPV0VSJykgPyBNYXRoLmZsb29yKChwYWROZWVkZWQgKyAxKSAvIDIpIDogTWF0aC5mbG9vcihwYWROZWVkZWQgLyAyKTtcbiAgICAgICAgICAgIHBhZHNbcGFkVGFpbEluZGV4XSA9IHBhZE5lZWRlZCAtIHBhZHNbcGFkSGVhZEluZGV4XTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKCgoaW5TaXplICsgcGFkTmVlZGVkIC0ga2VybmVsKSAvIHN0cmlkZSkgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBBdXRvUGFkIHR5cGUnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKChpblNpemUgKyBwYWRzW3BhZEhlYWRJbmRleF0gKyBwYWRzW3BhZFRhaWxJbmRleF0gLSBka2VybmVsKSAvIHN0cmlkZSkgKyAxKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IE1JTl9DTElQID0gLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzg7XG5leHBvcnQgY29uc3QgTUFYX0NMSVAgPSAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4O1xuXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlVXRmOFN0cmluZyhidWZmZXI6IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xuICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ1ZmZlcik7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7R3VpZH0gZnJvbSAnZ3VpZC10eXBlc2NyaXB0JztcbmltcG9ydCBMb25nIGZyb20gJ2xvbmcnO1xuXG5pbXBvcnQge29ubnhydW50aW1lfSBmcm9tICcuL29ydC1zY2hlbWEvZmxhdGJ1ZmZlcnMvb3J0LWdlbmVyYXRlZCc7XG5pbXBvcnQge29ubnh9IGZyb20gJy4vb3J0LXNjaGVtYS9wcm90b2J1Zi9vbm54JztcbmltcG9ydCB7ZGVjb2RlVXRmOFN0cmluZywgUHJvdG9VdGlsLCBTaGFwZVV0aWx9IGZyb20gJy4vdXRpbCc7XG5cbmltcG9ydCBvcnRGYnMgPSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgVGVuc29yIHtcbiAgZXhwb3J0IGludGVyZmFjZSBEYXRhVHlwZU1hcCB7XG4gICAgYm9vbDogVWludDhBcnJheTtcbiAgICBmbG9hdDMyOiBGbG9hdDMyQXJyYXk7XG4gICAgZmxvYXQ2NDogRmxvYXQ2NEFycmF5O1xuICAgIHN0cmluZzogc3RyaW5nW107XG4gICAgaW50ODogSW50OEFycmF5O1xuICAgIHVpbnQ4OiBVaW50OEFycmF5O1xuICAgIGludDE2OiBJbnQxNkFycmF5O1xuICAgIHVpbnQxNjogVWludDE2QXJyYXk7XG4gICAgaW50MzI6IEludDMyQXJyYXk7XG4gICAgdWludDMyOiBVaW50MzJBcnJheTtcbiAgICBpbnQ2NDogQmlnSW50NjRBcnJheTtcbiAgfVxuXG4gIGV4cG9ydCB0eXBlIERhdGFUeXBlID0ga2V5b2YgRGF0YVR5cGVNYXA7XG5cbiAgZXhwb3J0IHR5cGUgU3RyaW5nVHlwZSA9IFRlbnNvci5EYXRhVHlwZU1hcFsnc3RyaW5nJ107XG4gIGV4cG9ydCB0eXBlIEJvb2xlYW5UeXBlID0gVGVuc29yLkRhdGFUeXBlTWFwWydib29sJ107XG4gIGV4cG9ydCB0eXBlIEludGVnZXJUeXBlID0gVGVuc29yLkRhdGFUeXBlTWFwWydpbnQ4J118VGVuc29yLkRhdGFUeXBlTWFwWyd1aW50OCddfFRlbnNvci5EYXRhVHlwZU1hcFsnaW50MTYnXXxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUZW5zb3IuRGF0YVR5cGVNYXBbJ3VpbnQxNiddfFRlbnNvci5EYXRhVHlwZU1hcFsnaW50MzInXXxUZW5zb3IuRGF0YVR5cGVNYXBbJ3VpbnQzMiddO1xuICBleHBvcnQgdHlwZSBGbG9hdFR5cGUgPSBUZW5zb3IuRGF0YVR5cGVNYXBbJ2Zsb2F0MzInXXxUZW5zb3IuRGF0YVR5cGVNYXBbJ2Zsb2F0NjQnXTtcbiAgZXhwb3J0IHR5cGUgTnVtYmVyVHlwZSA9IEJvb2xlYW5UeXBlfEludGVnZXJUeXBlfEZsb2F0VHlwZTtcblxuICBleHBvcnQgdHlwZSBJZCA9IEd1aWQ7XG59XG5cbnR5cGUgVGVuc29yRGF0YSA9IFRlbnNvci5EYXRhVHlwZU1hcFtUZW5zb3IuRGF0YVR5cGVdO1xuXG50eXBlIERhdGFQcm92aWRlciA9IChpZDogVGVuc29yLklkKSA9PiBUZW5zb3JEYXRhO1xudHlwZSBBc3luY0RhdGFQcm92aWRlciA9IChpZDogVGVuc29yLklkKSA9PiBQcm9taXNlPFRlbnNvckRhdGE+O1xuXG5leHBvcnQgY2xhc3MgVGVuc29yIHtcbiAgLyoqXG4gICAqIGdldCB0aGUgdW5kZXJseWluZyB0ZW5zb3IgZGF0YVxuICAgKi9cbiAgZ2V0IGRhdGEoKTogVGVuc29yRGF0YSB7XG4gICAgaWYgKHRoaXMuY2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YVByb3ZpZGVyISh0aGlzLmRhdGFJZCk7XG4gICAgICBpZiAoZGF0YS5sZW5ndGggIT09IHRoaXMuc2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xlbmd0aCBvZiBkYXRhIHByb3ZpZGVkIGJ5IHRoZSBEYXRhIFByb3ZpZGVyIGlzIGluY29uc2lzdGVudCB3aXRoIHRoZSBkaW1zIG9mIHRoaXMgVGVuc29yLicpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYWNoZSA9IGRhdGE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhY2hlO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgdW5kZXJseWluZyBzdHJpbmcgdGVuc29yIGRhdGEuIFNob3VsZCBvbmx5IHVzZSB3aGVuIHR5cGUgaXMgU1RSSU5HXG4gICAqL1xuICBnZXQgc3RyaW5nRGF0YSgpIHtcbiAgICBpZiAodGhpcy50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGF0YSB0eXBlIGlzIG5vdCBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhIGFzIFRlbnNvci5TdHJpbmdUeXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgdW5kZXJseWluZyBpbnRlZ2VyIHRlbnNvciBkYXRhLiBTaG91bGQgb25seSB1c2Ugd2hlbiB0eXBlIGlzIG9uZSBvZiB0aGUgZm9sbG93aW5nOiAoVUlOVDgsIElOVDgsIFVJTlQxNixcbiAgICogSU5UMTYsIElOVDMyLCBVSU5UMzIsIEJPT0wpXG4gICAqL1xuICBnZXQgaW50ZWdlckRhdGEoKSB7XG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgIGNhc2UgJ2ludDgnOlxuICAgICAgY2FzZSAndWludDE2JzpcbiAgICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgIGNhc2UgJ2ludDMyJzpcbiAgICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICBjYXNlICdib29sJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSBhcyBUZW5zb3IuSW50ZWdlclR5cGU7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RhdGEgdHlwZSBpcyBub3QgaW50ZWdlciAodWludDgsIGludDgsIHVpbnQxNiwgaW50MTYsIGludDMyLCB1aW50MzIsIGJvb2wpJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgdW5kZXJseWluZyBmbG9hdCB0ZW5zb3IgZGF0YS4gU2hvdWxkIG9ubHkgdXNlIHdoZW4gdHlwZSBpcyBvbmUgb2YgdGhlIGZvbGxvd2luZzogKEZMT0FULCBET1VCTEUpXG4gICAqL1xuICBnZXQgZmxvYXREYXRhKCkge1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhIGFzIFRlbnNvci5GbG9hdFR5cGU7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RhdGEgdHlwZSBpcyBub3QgZmxvYXQgKGZsb2F0MzIsIGZsb2F0NjQpJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgdW5kZXJseWluZyBudW1iZXIgdGVuc29yIGRhdGEuIFNob3VsZCBvbmx5IHVzZSB3aGVuIHR5cGUgaXMgb25lIG9mIHRoZSBmb2xsb3dpbmc6IChVSU5UOCwgSU5UOCwgVUlOVDE2LFxuICAgKiBJTlQxNiwgSU5UMzIsIFVJTlQzMiwgQk9PTCwgRkxPQVQsIERPVUJMRSlcbiAgICovXG4gIGdldCBudW1iZXJEYXRhKCkge1xuICAgIGlmICh0aGlzLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhIGFzIFRlbnNvci5OdW1iZXJUeXBlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0eXBlIGNhbm5vdCBiZSBub24tbnVtYmVyIChzdHJpbmcpJyk7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHZhbHVlIG9mIGFuIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGljZXNcbiAgICovXG4gIGdldChpbmRpY2VzOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvci5EYXRhVHlwZU1hcFtUZW5zb3IuRGF0YVR5cGVdW251bWJlcl0ge1xuICAgIHJldHVybiB0aGlzLmRhdGFbU2hhcGVVdGlsLmluZGljZXNUb09mZnNldChpbmRpY2VzLCB0aGlzLnN0cmlkZXMpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZXQgdmFsdWUgb2YgYW4gZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kaWNlc1xuICAgKi9cbiAgc2V0KGluZGljZXM6IHJlYWRvbmx5IG51bWJlcltdLCB2YWx1ZTogVGVuc29yLkRhdGFUeXBlTWFwW1RlbnNvci5EYXRhVHlwZV1bbnVtYmVyXSkge1xuICAgIHRoaXMuZGF0YVtTaGFwZVV0aWwuaW5kaWNlc1RvT2Zmc2V0KGluZGljZXMsIHRoaXMuc3RyaWRlcyldID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogZ2V0IHRoZSB1bmRlcmx5aW5nIHRlbnNvciBkYXRhIGFzeW5jaHJvbm91c2x5XG4gICAqL1xuICBhc3luYyBnZXREYXRhKCk6IFByb21pc2U8VGVuc29yRGF0YT4ge1xuICAgIGlmICh0aGlzLmNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuY2FjaGUgPSBhd2FpdCB0aGlzLmFzeW5jRGF0YVByb3ZpZGVyISh0aGlzLmRhdGFJZCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhY2hlO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB0ZW5zb3JcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBzaXplOiBudW1iZXI7XG5cbiAgcHJpdmF0ZSBfc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW107XG4gIC8qKlxuICAgKiBnZXQgdGhlIHN0cmlkZXMgZm9yIGVhY2ggZGltZW5zaW9uXG4gICAqL1xuICBnZXQgc3RyaWRlcygpOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgaWYgKCF0aGlzLl9zdHJpZGVzKSB7XG4gICAgICB0aGlzLl9zdHJpZGVzID0gU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKHRoaXMuZGltcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdHJpZGVzO1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICAvKipcbiAgICAgICAqIGdldCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgdGVuc29yXG4gICAgICAgKi9cbiAgICAgIHB1YmxpYyByZWFkb25seSBkaW1zOiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgIC8qKlxuICAgICAgICogZ2V0IHRoZSB0eXBlIG9mIHRoZSB0ZW5zb3JcbiAgICAgICAqL1xuICAgICAgcHVibGljIHJlYWRvbmx5IHR5cGU6IFRlbnNvci5EYXRhVHlwZSwgcHJpdmF0ZSBkYXRhUHJvdmlkZXI/OiBEYXRhUHJvdmlkZXIsXG4gICAgICBwcml2YXRlIGFzeW5jRGF0YVByb3ZpZGVyPzogQXN5bmNEYXRhUHJvdmlkZXIsIHByaXZhdGUgY2FjaGU/OiBUZW5zb3JEYXRhLFxuICAgICAgLyoqXG4gICAgICAgKiBnZXQgdGhlIGRhdGEgSUQgdGhhdCB1c2VkIHRvIG1hcCB0byBhIHRlbnNvciBkYXRhXG4gICAgICAgKi9cbiAgICAgIHB1YmxpYyByZWFkb25seSBkYXRhSWQ6IEd1aWQgPSBHdWlkLmNyZWF0ZSgpKSB7XG4gICAgdGhpcy5zaXplID0gU2hhcGVVdGlsLnZhbGlkYXRlRGltc0FuZENhbGNTaXplKGRpbXMpO1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemU7XG4gICAgY29uc3QgZW1wdHkgPSAoZGF0YVByb3ZpZGVyID09PSB1bmRlZmluZWQgJiYgYXN5bmNEYXRhUHJvdmlkZXIgPT09IHVuZGVmaW5lZCAmJiBjYWNoZSA9PT0gdW5kZWZpbmVkKTtcblxuICAgIGlmIChjYWNoZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY2FjaGUubGVuZ3RoICE9PSBzaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnB1dCBkaW1zIGRvZXNuXFwndCBtYXRjaCBkYXRhIGxlbmd0aC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChjYWNoZSAhPT0gdW5kZWZpbmVkICYmICghQXJyYXkuaXNBcnJheShjYWNoZSkgfHwgIWNhY2hlLmV2ZXJ5KGkgPT4gdHlwZW9mIGkgPT09ICdzdHJpbmcnKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FjaGUgc2hvdWxkIGJlIGEgc3RyaW5nIGFycmF5Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbXB0eSkge1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IEFycmF5PHN0cmluZz4oc2l6ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjYWNoZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gZGF0YXZpZXdDb25zdHJ1Y3Rvcih0eXBlKTtcbiAgICAgICAgaWYgKCEoY2FjaGUgaW5zdGFuY2VvZiBjb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBjYWNoZSBzaG91bGQgYmUgdHlwZSAke2NvbnN0cnVjdG9yLm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVtcHR5KSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihzaXplICogc2l6ZW9mKHR5cGUpKTtcbiAgICAgICAgdGhpcy5jYWNoZSA9IGNyZWF0ZVZpZXcoYnVmLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0IG5ldyBUZW5zb3IgZnJvbSBhIE9OTlggVGVuc29yIG9iamVjdFxuICAgKiBAcGFyYW0gdGVuc29yUHJvdG8gdGhlIE9OTlggVGVuc29yXG4gICAqL1xuICBzdGF0aWMgZnJvbVByb3RvKHRlbnNvclByb3RvOiBvbm54LklUZW5zb3JQcm90byk6IFRlbnNvciB7XG4gICAgaWYgKCF0ZW5zb3JQcm90bykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY29uc3RydWN0IFZhbHVlIGZyb20gYW4gZW1wdHkgdGVuc29yJyk7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBQcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8odGVuc29yUHJvdG8uZGF0YVR5cGUhKTtcbiAgICBjb25zdCBkaW1zID0gUHJvdG9VdGlsLnRlbnNvckRpbXNGcm9tUHJvdG8odGVuc29yUHJvdG8uZGltcyEpO1xuXG4gICAgY29uc3QgdmFsdWUgPSBuZXcgVGVuc29yKGRpbXMsIHR5cGUpO1xuXG4gICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBXaGVuIGl0J3MgU1RSSU5HIHR5cGUsIHRoZSB2YWx1ZSBzaG91bGQgYWx3YXlzIGJlIHN0b3JlZCBpbiBmaWVsZFxuICAgICAgLy8gJ3N0cmluZ0RhdGEnXG4gICAgICB0ZW5zb3JQcm90by5zdHJpbmdEYXRhIS5mb3JFYWNoKChzdHIsIGkpID0+IHtcbiAgICAgICAgdmFsdWUuZGF0YVtpXSA9IGRlY29kZVV0ZjhTdHJpbmcoc3RyKTtcbiAgICAgIH0pO1xuXG4gICAgfSBlbHNlIGlmIChcbiAgICAgICAgdGVuc29yUHJvdG8ucmF3RGF0YSAmJiB0eXBlb2YgdGVuc29yUHJvdG8ucmF3RGF0YS5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuICAgICAgICB0ZW5zb3JQcm90by5yYXdEYXRhLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgICAvLyBOT1QgY29uc2lkZXJpbmcgc2VnbWVudCBmb3Igbm93IChJTVBPUlRBTlQpXG5cbiAgICAgIC8vIHBvcHVsYXRlIHZhbHVlIGZyb20gcmF3RGF0YVxuICAgICAgY29uc3QgZGF0YURlc3QgPSB2YWx1ZS5kYXRhO1xuICAgICAgY29uc3QgZGF0YVNvdXJjZSA9XG4gICAgICAgICAgbmV3IERhdGFWaWV3KHRlbnNvclByb3RvLnJhd0RhdGEuYnVmZmVyLCB0ZW5zb3JQcm90by5yYXdEYXRhLmJ5dGVPZmZzZXQsIHRlbnNvclByb3RvLnJhd0RhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICBjb25zdCBlbGVtZW50U2l6ZSA9IHNpemVvZlByb3RvKHRlbnNvclByb3RvLmRhdGFUeXBlISk7XG4gICAgICBjb25zdCBsZW5ndGggPSB0ZW5zb3JQcm90by5yYXdEYXRhLmJ5dGVMZW5ndGggLyBlbGVtZW50U2l6ZTtcblxuICAgICAgaWYgKHRlbnNvclByb3RvLnJhd0RhdGEuYnl0ZUxlbmd0aCAlIGVsZW1lbnRTaXplICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBidWZmZXIgbGVuZ3RoJyk7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YURlc3QubGVuZ3RoICE9PSBsZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdidWZmZXIgbGVuZ3RoIG1pc21hdGNoJyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbiA9IHJlYWRQcm90byhkYXRhU291cmNlLCB0ZW5zb3JQcm90by5kYXRhVHlwZSEsIGkgKiBlbGVtZW50U2l6ZSk7XG4gICAgICAgIGRhdGFEZXN0W2ldID0gbjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcG9wdWxhdGUgdmFsdWUgZnJvbSBhcnJheVxuICAgICAgbGV0IGFycmF5OiBBcnJheTxudW1iZXJ8TG9uZz47XG4gICAgICBzd2l0Y2ggKHRlbnNvclByb3RvLmRhdGFUeXBlKSB7XG4gICAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5GTE9BVDpcbiAgICAgICAgICBhcnJheSA9IHRlbnNvclByb3RvLmZsb2F0RGF0YSE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQzMjpcbiAgICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDE2OlxuICAgICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDE2OlxuICAgICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UODpcbiAgICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4OlxuICAgICAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuQk9PTDpcbiAgICAgICAgICBhcnJheSA9IHRlbnNvclByb3RvLmludDMyRGF0YSE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NDpcbiAgICAgICAgICBhcnJheSA9IHRlbnNvclByb3RvLmludDY0RGF0YSE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU6XG4gICAgICAgICAgYXJyYXkgPSB0ZW5zb3JQcm90by5kb3VibGVEYXRhITtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMjpcbiAgICAgICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NDpcbiAgICAgICAgICBhcnJheSA9IHRlbnNvclByb3RvLnVpbnQ2NERhdGEhO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIHNob3VsZCBuZXZlciBydW4gaGVyZVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zcGVjaWZpYyBlcnJvcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJyYXkgPT09IG51bGwgfHwgYXJyYXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBwb3B1bGF0ZSBkYXRhIGZyb20gYSB0ZW5zb3Jwcm90byB2YWx1ZScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gdmFsdWUuZGF0YTtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXkgbGVuZ3RoIG1pc21hdGNoJyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2ldO1xuICAgICAgICBpZiAoTG9uZy5pc0xvbmcoZWxlbWVudCkpIHtcbiAgICAgICAgICBkYXRhW2ldID0gbG9uZ1RvTnVtYmVyKGVsZW1lbnQsIHRlbnNvclByb3RvLmRhdGFUeXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhW2ldID0gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgbmV3IFRlbnNvciBmcm9tIHJhdyBkYXRhXG4gICAqIEBwYXJhbSBkYXRhIHRoZSByYXcgZGF0YSBvYmplY3QuIFNob3VsZCBiZSBhIHN0cmluZyBhcnJheSBmb3IgJ3N0cmluZycgdGVuc29yLCBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgdHlwZWQgYXJyYXlcbiAgICogZm9yIG90aGVyIHR5cGVzIG9mIHRlbnNvci5cbiAgICogQHBhcmFtIGRpbXMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHRlbnNvclxuICAgKiBAcGFyYW0gdHlwZSB0aGUgdHlwZSBvZiB0aGUgdGVuc29yXG4gICAqL1xuICBzdGF0aWMgZnJvbURhdGEoZGF0YTogVGVuc29yLkRhdGFUeXBlTWFwW1RlbnNvci5EYXRhVHlwZV0sIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCB0eXBlOiBUZW5zb3IuRGF0YVR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFRlbnNvcihkaW1zLCB0eXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgZGF0YSk7XG4gIH1cblxuICBzdGF0aWMgZnJvbU9ydFRlbnNvcihvcnRUZW5zb3I6IG9ydEZicy5UZW5zb3IpIHtcbiAgICBpZiAoIW9ydFRlbnNvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY29uc3RydWN0IFZhbHVlIGZyb20gYW4gZW1wdHkgdGVuc29yJyk7XG4gICAgfVxuICAgIGNvbnN0IGRpbXMgPSBQcm90b1V0aWwudGVuc29yRGltc0Zyb21PUlRGb3JtYXQob3J0VGVuc29yKTtcbiAgICBjb25zdCB0eXBlID0gUHJvdG9VdGlsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKG9ydFRlbnNvci5kYXRhVHlwZSgpKTtcblxuICAgIGNvbnN0IHZhbHVlID0gbmV3IFRlbnNvcihkaW1zLCB0eXBlKTtcblxuICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gV2hlbiBpdCdzIFNUUklORyB0eXBlLCB0aGUgdmFsdWUgc2hvdWxkIGFsd2F5cyBiZSBzdG9yZWQgaW4gZmllbGRcbiAgICAgIC8vICdzdHJpbmdEYXRhJ1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcnRUZW5zb3Iuc3RyaW5nRGF0YUxlbmd0aCgpOyBpKyspIHtcbiAgICAgICAgdmFsdWUuZGF0YVtpXSA9IG9ydFRlbnNvci5zdHJpbmdEYXRhKGkpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChcbiAgICAgICAgb3J0VGVuc29yLnJhd0RhdGFBcnJheSgpICYmIHR5cGVvZiBvcnRUZW5zb3IucmF3RGF0YUxlbmd0aCgpID09PSAnbnVtYmVyJyAmJiBvcnRUZW5zb3IucmF3RGF0YUxlbmd0aCgpID4gMCkge1xuICAgICAgLy8gTk9UIGNvbnNpZGVyaW5nIHNlZ21lbnQgZm9yIG5vdyAoSU1QT1JUQU5UKVxuXG4gICAgICAvLyBwb3B1bGF0ZSB2YWx1ZSBmcm9tIHJhd0RhdGFcbiAgICAgIGNvbnN0IGRhdGFEZXN0ID0gdmFsdWUuZGF0YTtcbiAgICAgIGNvbnN0IGRhdGFTb3VyY2UgPSBuZXcgRGF0YVZpZXcoXG4gICAgICAgICAgb3J0VGVuc29yLnJhd0RhdGFBcnJheSgpIS5idWZmZXIsIG9ydFRlbnNvci5yYXdEYXRhQXJyYXkoKSEuYnl0ZU9mZnNldCwgb3J0VGVuc29yLnJhd0RhdGFMZW5ndGgoKSk7XG4gICAgICBjb25zdCBlbGVtZW50U2l6ZSA9IHNpemVvZlByb3RvKG9ydFRlbnNvci5kYXRhVHlwZSgpKTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IG9ydFRlbnNvci5yYXdEYXRhTGVuZ3RoKCkgLyBlbGVtZW50U2l6ZTtcblxuICAgICAgaWYgKG9ydFRlbnNvci5yYXdEYXRhTGVuZ3RoKCkgJSBlbGVtZW50U2l6ZSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYnVmZmVyIGxlbmd0aCcpO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGFEZXN0Lmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYnVmZmVyIGxlbmd0aCBtaXNtYXRjaCcpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG4gPSByZWFkUHJvdG8oZGF0YVNvdXJjZSwgb3J0VGVuc29yLmRhdGFUeXBlKCksIGkgKiBlbGVtZW50U2l6ZSk7XG4gICAgICAgIGRhdGFEZXN0W2ldID0gbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNpemVvZih0eXBlOiBUZW5zb3IuRGF0YVR5cGUpOiBudW1iZXIge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdib29sJzpcbiAgICBjYXNlICdpbnQ4JzpcbiAgICBjYXNlICd1aW50OCc6XG4gICAgICByZXR1cm4gMTtcbiAgICBjYXNlICdpbnQxNic6XG4gICAgY2FzZSAndWludDE2JzpcbiAgICAgIHJldHVybiAyO1xuICAgIGNhc2UgJ2ludDMyJzpcbiAgICBjYXNlICd1aW50MzInOlxuICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgcmV0dXJuIDQ7XG4gICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgICByZXR1cm4gODtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgY2FsY3VsYXRlIHNpemVvZigpIG9uIHR5cGUgJHt0eXBlfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNpemVvZlByb3RvKHR5cGU6IG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGV8b3J0RmJzLlRlbnNvckRhdGFUeXBlKTogbnVtYmVyIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4OlxuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ4OlxuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5CT09MOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQxNjpcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMTY6XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuRkxPQVQ6XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDMyOlxuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMzI6XG4gICAgICByZXR1cm4gNDtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UNjQ6XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkRPVUJMRTpcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDY0OlxuICAgICAgcmV0dXJuIDg7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGNhbGN1bGF0ZSBzaXplb2YoKSBvbiB0eXBlICR7b25ueC5UZW5zb3JQcm90by5EYXRhVHlwZVt0eXBlXX1gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVWaWV3KGRhdGFCdWZmZXI6IEFycmF5QnVmZmVyLCB0eXBlOiBUZW5zb3IuRGF0YVR5cGUpIHtcbiAgcmV0dXJuIG5ldyAoZGF0YXZpZXdDb25zdHJ1Y3Rvcih0eXBlKSkoZGF0YUJ1ZmZlcik7XG59XG5cbmZ1bmN0aW9uIGRhdGF2aWV3Q29uc3RydWN0b3IodHlwZTogVGVuc29yLkRhdGFUeXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2Jvb2wnOlxuICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgIHJldHVybiBVaW50OEFycmF5O1xuICAgIGNhc2UgJ2ludDgnOlxuICAgICAgcmV0dXJuIEludDhBcnJheTtcbiAgICBjYXNlICdpbnQxNic6XG4gICAgICByZXR1cm4gSW50MTZBcnJheTtcbiAgICBjYXNlICd1aW50MTYnOlxuICAgICAgcmV0dXJuIFVpbnQxNkFycmF5O1xuICAgIGNhc2UgJ2ludDMyJzpcbiAgICAgIHJldHVybiBJbnQzMkFycmF5O1xuICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICByZXR1cm4gVWludDMyQXJyYXk7XG4gICAgY2FzZSAnaW50NjQnOlxuICAgICAgcmV0dXJuIEJpZ0ludDY0QXJyYXk7XG4gICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICByZXR1cm4gRmxvYXQzMkFycmF5O1xuICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgcmV0dXJuIEZsb2F0NjRBcnJheTtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gc2hvdWxkIG5ldmVyIHJ1biB0byBoZXJlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3BlY2lmaWVkIGVycm9yJyk7XG4gIH1cbn1cblxuLy8gY29udmVydCBhIGxvbmcgbnVtYmVyIHRvIGEgMzItYml0IGludGVnZXIgKGNhc3QtZG93bilcbmZ1bmN0aW9uIGxvbmdUb051bWJlcihpOiBMb25nLCB0eXBlOiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlfG9ydEZicy5UZW5zb3JEYXRhVHlwZSk6IG51bWJlciB7XG4gIC8vIElOVDY0LCBVSU5UMzIsIFVJTlQ2NFxuICBpZiAodHlwZSA9PT0gb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NCB8fCB0eXBlID09PSBvcnRGYnMuVGVuc29yRGF0YVR5cGUuSU5UNjQpIHtcbiAgICBpZiAoaS5ncmVhdGVyVGhhbk9yRXF1YWwoMjE0NzQ4MzY0OCkgfHwgaS5sZXNzVGhhbigtMjE0NzQ4MzY0OCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludDY0IGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoXG4gICAgICB0eXBlID09PSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQzMiB8fCB0eXBlID09PSBvcnRGYnMuVGVuc29yRGF0YVR5cGUuVUlOVDMyIHx8XG4gICAgICB0eXBlID09PSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ2NCB8fCB0eXBlID09PSBvcnRGYnMuVGVuc29yRGF0YVR5cGUuVUlOVDY0KSB7XG4gICAgaWYgKGkuZ3JlYXRlclRoYW5PckVxdWFsKDQyOTQ5NjcyOTYpIHx8IGkubGVzc1RoYW4oMCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VpbnQ2NCBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYG5vdCBhIExPTkcgdHlwZTogJHtvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlW3R5cGVdfWApO1xuICB9XG5cbiAgcmV0dXJuIGkudG9OdW1iZXIoKTtcbn1cblxuLy8gcmVhZCBvbmUgdmFsdWUgZnJvbSBUZW5zb3JQcm90b1xuZnVuY3Rpb24gcmVhZFByb3RvKHZpZXc6IERhdGFWaWV3LCB0eXBlOiBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlfG9ydEZicy5UZW5zb3JEYXRhVHlwZSwgYnl0ZU9mZnNldDogbnVtYmVyKTogbnVtYmVyIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkJPT0w6XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLlVJTlQ4OlxuICAgICAgcmV0dXJuIHZpZXcuZ2V0VWludDgoYnl0ZU9mZnNldCk7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDg6XG4gICAgICByZXR1cm4gdmlldy5nZXRJbnQ4KGJ5dGVPZmZzZXQpO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UMTY6XG4gICAgICByZXR1cm4gdmlldy5nZXRVaW50MTYoYnl0ZU9mZnNldCwgdHJ1ZSk7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLklOVDE2OlxuICAgICAgcmV0dXJuIHZpZXcuZ2V0SW50MTYoYnl0ZU9mZnNldCwgdHJ1ZSk7XG4gICAgY2FzZSBvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlLkZMT0FUOlxuICAgICAgcmV0dXJuIHZpZXcuZ2V0RmxvYXQzMihieXRlT2Zmc2V0LCB0cnVlKTtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuSU5UMzI6XG4gICAgICByZXR1cm4gdmlldy5nZXRJbnQzMihieXRlT2Zmc2V0LCB0cnVlKTtcbiAgICBjYXNlIG9ubnguVGVuc29yUHJvdG8uRGF0YVR5cGUuVUlOVDMyOlxuICAgICAgcmV0dXJuIHZpZXcuZ2V0VWludDMyKGJ5dGVPZmZzZXQsIHRydWUpO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5JTlQ2NDpcbiAgICAgIHJldHVybiBsb25nVG9OdW1iZXIoXG4gICAgICAgICAgTG9uZy5mcm9tQml0cyh2aWV3LmdldFVpbnQzMihieXRlT2Zmc2V0LCB0cnVlKSwgdmlldy5nZXRVaW50MzIoYnl0ZU9mZnNldCArIDQsIHRydWUpLCBmYWxzZSksIHR5cGUpO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5ET1VCTEU6XG4gICAgICByZXR1cm4gdmlldy5nZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIHRydWUpO1xuICAgIGNhc2Ugb25ueC5UZW5zb3JQcm90by5EYXRhVHlwZS5VSU5UNjQ6XG4gICAgICByZXR1cm4gbG9uZ1RvTnVtYmVyKFxuICAgICAgICAgIExvbmcuZnJvbUJpdHModmlldy5nZXRVaW50MzIoYnl0ZU9mZnNldCwgdHJ1ZSksIHZpZXcuZ2V0VWludDMyKGJ5dGVPZmZzZXQgKyA0LCB0cnVlKSwgdHJ1ZSksIHR5cGUpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWFkIGZyb20gRGF0YVZpZXcgZm9yIHR5cGUgJHtvbm54LlRlbnNvclByb3RvLkRhdGFUeXBlW3R5cGVdfWApO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8qKlxuICogcmVwcmVzZW50IGEgdmVyc2lvbiBpcnJlbGV2YW50IGFic3RyYWN0aW9uIG9mIGZvciBHTFNMIHNvdXJjZSBjb2RlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR2xzbCB7XG4gIHJlYWRvbmx5IHZlcnNpb246IHN0cmluZztcbiAgcmVhZG9ubHkgYXR0cmlidXRlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHZhcnlpbmdWZXJ0ZXg6IHN0cmluZztcbiAgcmVhZG9ubHkgdmFyeWluZ0ZyYWc6IHN0cmluZztcbiAgcmVhZG9ubHkgdGV4dHVyZTJEOiBzdHJpbmc7XG4gIHJlYWRvbmx5IG91dHB1dDogc3RyaW5nO1xuICByZWFkb25seSBvdXRwdXREZWNsYXJhdGlvbjogc3RyaW5nO1xufVxuXG5jb25zdCBHTFNMX0VTXzJfMDogR2xzbCA9IHtcbiAgdmVyc2lvbjogJycsXG4gIGF0dHJpYnV0ZTogJ2F0dHJpYnV0ZScsXG4gIHZhcnlpbmdWZXJ0ZXg6ICd2YXJ5aW5nJyxcbiAgdmFyeWluZ0ZyYWc6ICd2YXJ5aW5nJyxcbiAgdGV4dHVyZTJEOiAndGV4dHVyZTJEJyxcbiAgb3V0cHV0OiAnZ2xfRnJhZ0NvbG9yJyxcbiAgb3V0cHV0RGVjbGFyYXRpb246ICcnLFxufTtcbmNvbnN0IEdMU0xfRVNfM18wOiBHbHNsID0ge1xuICB2ZXJzaW9uOiAnI3ZlcnNpb24gMzAwIGVzJyxcbiAgYXR0cmlidXRlOiAnaW4nLFxuICB2YXJ5aW5nVmVydGV4OiAnb3V0JyxcbiAgdmFyeWluZ0ZyYWc6ICdpbicsXG4gIHRleHR1cmUyRDogJ3RleHR1cmUnLFxuICBvdXRwdXQ6ICdvdXRwdXRDb2xvcicsXG4gIG91dHB1dERlY2xhcmF0aW9uOiAnb3V0IHZlYzQgb3V0cHV0Q29sb3I7Jyxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRHbHNsKHZlcnNpb246IDF8Mikge1xuICByZXR1cm4gdmVyc2lvbiA9PT0gMSA/IEdMU0xfRVNfMl8wIDogR0xTTF9FU18zXzA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRWZXJ0ZXhTaGFkZXJTb3VyY2UodmVyc2lvbjogMXwyKTogc3RyaW5nIHtcbiAgY29uc3QgZ2xzbCA9IGdldEdsc2wodmVyc2lvbik7XG4gIHJldHVybiBgJHtnbHNsLnZlcnNpb259XG4gICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgICAke2dsc2wuYXR0cmlidXRlfSB2ZWMzIHBvc2l0aW9uO1xuICAgICAgJHtnbHNsLmF0dHJpYnV0ZX0gdmVjMiB0ZXh0dXJlQ29vcmQ7XG5cbiAgICAgICR7Z2xzbC52YXJ5aW5nVmVydGV4fSB2ZWMyIFRleENvb3JkcztcblxuICAgICAgdm9pZCBtYWluKClcbiAgICAgIHtcbiAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDEuMCk7XG4gICAgICAgICAgVGV4Q29vcmRzID0gdGV4dHVyZUNvb3JkO1xuICAgICAgfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGcmFnU2hhZGVyUHJlYW1ibGUodmVyc2lvbjogMXwyKTogc3RyaW5nIHtcbiAgY29uc3QgZ2xzbCA9IGdldEdsc2wodmVyc2lvbik7XG4gIHJldHVybiBgJHtnbHNsLnZlcnNpb259XG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgIHByZWNpc2lvbiBoaWdocCBpbnQ7XG4gICAgcHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyRDtcbiAgICAke2dsc2wudmFyeWluZ0ZyYWd9IHZlYzIgVGV4Q29vcmRzO1xuICAgICR7Z2xzbC5vdXRwdXREZWNsYXJhdGlvbn1cbiAgICBjb25zdCB2ZWMyIGhhbGZDUiA9IHZlYzIoMC41LCAwLjUpO1xuXG4gICAgLy8gQ3VzdG9tIHZlY3RvciB0eXBlcyB0byBoYW5kbGUgaGlnaGVyIGRpbWVuYWxpdGllcy5cbiAgICBzdHJ1Y3QgaXZlYzVcbiAgICB7XG4gICAgICBpbnQgeDtcbiAgICAgIGludCB5O1xuICAgICAgaW50IHo7XG4gICAgICBpbnQgdztcbiAgICAgIGludCB1O1xuICAgIH07XG5cbiAgICBzdHJ1Y3QgaXZlYzZcbiAgICB7XG4gICAgICBpbnQgeDtcbiAgICAgIGludCB5O1xuICAgICAgaW50IHo7XG4gICAgICBpbnQgdztcbiAgICAgIGludCB1O1xuICAgICAgaW50IHY7XG4gICAgfTtcblxuICAgIGludCBpbW9kKGludCB4LCBpbnQgeSkge1xuICAgICAgcmV0dXJuIHggLSB5ICogKHggLyB5KTtcbiAgICB9XG5cbiAgICBgO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdEZyYWdTaGFkZXJNYWluKHZlcnNpb246IDF8Miwgb3V0cHV0U2hhcGVMZW5ndGg6IG51bWJlcik6IHN0cmluZyB7XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHZlcnNpb24pO1xuICByZXR1cm4gYFxuICB2b2lkIG1haW4oKSB7XG4gICAgaW50IGluZGljZXNbJHtvdXRwdXRTaGFwZUxlbmd0aH1dO1xuICAgIHRvVmVjKFRleENvb3JkcywgaW5kaWNlcyk7XG4gICAgdmVjNCByZXN1bHQgPSB2ZWM0KHByb2Nlc3MoaW5kaWNlcykpO1xuICAgICR7Z2xzbC5vdXRwdXR9ID0gcmVzdWx0O1xuICB9XG4gIGA7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi90ZW5zb3InO1xuXG4vKipcbiAqIExheW91dCBpbmZvIGlzIHVzZWQgZm9yIG1hcHBpbmcgbi1kaW1lbnNpb25hbCBhcnJheSB0byAyRCB0ZXh0dXJlc1xuICogVGhlIGxheW91dCBpcyBjcmVhdGVkIGJ5IHRoZSBUZXh0dXJlTGF5b3V0U3RyYXRlZ3kgYmFzZWQgb25cbiAqIHRoZSBUZW5zb3IncyBkaW1lbnNpb25zIGFuZCBzdHJpZGVzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dHVyZUxheW91dCB7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xuICAvKipcbiAgICogc3BlY2lmeSB0aGUgbnVtYmVyIG9mIHZhbHVlIHRoYXQgZW5jb2RlZCBpbiBhIHNpbmdsZSBwaXhlbFxuICAgKi9cbiAgY2hhbm5lbHM6IDF8MnwzfDQ7XG4gIC8qKlxuICAgKiB3aGV0aGVyIGluIHBhY2tlZCBtb2RlIG9yIG5vdFxuICAgKi9cbiAgaXNQYWNrZWQ/OiBib29sZWFuO1xuICAvKipcbiAgICogdGhlIG5vcm1hbGl6ZWQgc2hhcGVcbiAgICovXG4gIHNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcbiAgLyoqXG4gICAqIHRoZSBzdHJpZGUgb2YgZWFjaCBkaW1lbnNpb25zLCBjYWxjdWxhdGVkIGFjY29yZGluZyB0byBzaGFwZVxuICAgKi9cbiAgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW107XG4gIC8qKlxuICAgKiB0aGUgb3JpZ2luYWwgc2hhcGUoZGltcykgb2YgdGhlIGNvcnJlc3BvbmRpbmcgdGVuc29yXG4gICAqL1xuICB1bnBhY2tlZFNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcblxuICByZXZlcnNlZFdIPzogYm9vbGVhbjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dHVyZURhdGEgZXh0ZW5kcyBUZXh0dXJlTGF5b3V0IHtcbiAgdGVuc29yOiBUZW5zb3I7XG4gIHRleHR1cmU6IFdlYkdMVGV4dHVyZTtcbn1cblxuZXhwb3J0IGVudW0gVGV4dHVyZVR5cGUge1xuICB1bnBhY2tlZCwgICAgICAgICAgICAgIC8vIDwtLSBub3JtYWwgdW5wYWNrZWQgdGV4dHVyZVxuICB1bnBhY2tlZFJldmVyc2VkLCAgICAgIC8vIDwtLSB1bnBhY2tlZCB0ZXh0dXJlIHVzZWQgaW4gb2xkIE9OTlguanMgaW1wbGVtZW50YXRpb24gKGRlcHJlY2F0ZWQpXG4gIHBhY2tlZCwgICAgICAgICAgICAgICAgLy8gPC0tIG5vcm1hbCBwYWNrZWQgdGV4dHVyZVxuICBkb3dubG9hZFVpbnQ4QXNGbG9hdCwgIC8vIDwtLSBPTkxZIHVzZWQgaW4gdGV4dHVyZSBkb3dubG9hZGluZyBmb3IgaU9TIGRldmljZXNcbiAgcGFja2VkTGFzdERpbWVuc2lvbiAgICAvLyA8LS0gT05MWSB1c2VkIGluIG9sZCBPTk5YLmpzIENvbnYgaW1wbGVtZW50YXRpb24gZm9yIGlucHV0IFcgKGRlcHJlY2F0ZWQpXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29ySW5mbyB7XG4gIGlkPzogVGVuc29yLklkO1xuICBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcbiAgdHlwZTogVGVuc29yLkRhdGFUeXBlO1xuICB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvZ3JhbVZhcmlhYmxlIHtcbiAgdHlwZTogJ2Zsb2F0J3wnaW50JztcbiAgbmFtZTogc3RyaW5nO1xuICBhcnJheUxlbmd0aD86IG51bWJlcjtcbiAgZGF0YTogbnVtYmVyfG51bWJlcltdO1xufVxuXG4vKipcbiAqIEEgc2V0IG9mIG1ldGFkYXRhIG9mIGEgc2hhZGVyIHByb2dyYW0uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJvZ3JhbU1ldGFkYXRhIHtcbiAgLyoqXG4gICAqIHRoZSBuYW1lIG9mIHRoZSBwcm9ncmFtLiB1c2VkIGZvciBkZWJ1Z2dpbmcgYW5kIHByb2ZpbGluZ1xuICAgKi9cbiAgbmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogdGV4dHVyZSB0eXBlcyBmb3IgZWFjaCBpbnB1dFxuICAgKi9cbiAgaW5wdXRUeXBlczogVGV4dHVyZVR5cGVbXTtcbiAgLyoqXG4gICAqIG5hbWVzIG9mIGVhY2ggaW5wdXRcbiAgICovXG4gIGlucHV0TmFtZXM6IHN0cmluZ1tdO1xuICAvKipcbiAgICogYW4gb3B0aW9uYWwgc3RyaW5nIGFzIGEgY2FjaGUgaGludCBpbiB0aGUgYXJ0aWZhY3QgY2FjaGVcbiAgICovXG4gIGNhY2hlSGludD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBBIFByb2dyYW1JbmZvTG9hZGVyIGFsbG93c1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFByb2dyYW1JbmZvTG9hZGVyIGV4dGVuZHMgUHJvZ3JhbU1ldGFkYXRhIHtcbiAgLyoqXG4gICAqIGEgZnVuY3Rpb24gdG8gZ2V0IHRoZSBwcm9ncmFtIGluZm9cbiAgICovXG4gIGdldCgpOiBQcm9ncmFtSW5mbztcbn1cblxuLyoqXG4gKiBBIHNldCBvZiBkYXRhIHRoYXQgcmVwcmVzZW50IGEgc2hhZGVyIHByb2dyYW1cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcm9ncmFtSW5mbyBleHRlbmRzIFByb2dyYW1NZXRhZGF0YSB7XG4gIC8qKlxuICAgKiBpbmZvcm1hdGlvbiBvZiB1bmlmb3JtIHZhcmlhYmxlc1xuICAgKi9cbiAgdmFyaWFibGVzPzogUHJvZ3JhbVZhcmlhYmxlW107XG4gIC8qKlxuICAgKiB0ZW5zb3IgaW5mbyBmb3Igb3V0cHV0XG4gICAqL1xuICBvdXRwdXQ6IFRlbnNvckluZm87XG4gIC8qKlxuICAgKiB0aGUgc2hhZGVyJ3MgcHJvY2Vzc2luZyBzb3VyY2UgY29kZVxuICAgKi9cbiAgc2hhZGVyU291cmNlOiBzdHJpbmc7XG4gIC8qKlxuICAgKiB3aGV0aGVyIHRoZSBzaGFkZXIgc291cmNlIGNvbnRhaW5zIGEgY3VzdG9taXplZCBtYWluIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICBoYXNNYWluPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWYXJpYWJsZUluZm8ge1xuICB0eXBlOiAnZmxvYXQnfCdpbnQnO1xuICBuYW1lOiBzdHJpbmc7XG4gIGFycmF5TGVuZ3RoPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2dyYW1WYXJpYWJsZSB7XG4gIHR5cGU6ICdmbG9hdCd8J2ludCc7XG4gIG5hbWU6IHN0cmluZztcbiAgYXJyYXlMZW5ndGg/OiBudW1iZXI7XG4gIGRhdGE6IG51bWJlcnxudW1iZXJbXTtcbn1cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBvZiB1bmlmb3JtcyB0aGF0IHNoYWRlciB1c2VzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVW5pZm9ybUluZm8ge1xuICB0eXBlOiAnc2FtcGxlcjJEJ3xWYXJpYWJsZUluZm9bJ3R5cGUnXTtcbiAgbmFtZTogc3RyaW5nO1xuICBhcnJheUxlbmd0aD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVbmlmb3JtTG9jYXRpb24gZXh0ZW5kcyBVbmlmb3JtSW5mbyB7XG4gIGxvY2F0aW9uOiBXZWJHTFVuaWZvcm1Mb2NhdGlvbjtcbn1cblxuLyoqXG4gKiBBcnRpZmFjdCBpcyB0aGUgcmVzdWx0IG9mIGNvbXBpbGF0aW9uXG4gKiBJdCBkb2VzIG5vdCBjb250YWluIGlucHV0IG9mIG91dHB1dCBkYXRhXG4gKiBIb3dldmVyIGFueXRoaW5nIHRoYXQgY291bGQgYmUgcnVuIGFzIGEgXCJwcm9ncmFtXCJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBcnRpZmFjdCB7XG4gIHByb2dyYW1JbmZvOiBQcm9ncmFtSW5mbztcbiAgcHJvZ3JhbTogV2ViR0xQcm9ncmFtO1xuICB1bmlmb3JtTG9jYXRpb25zOiBVbmlmb3JtTG9jYXRpb25bXTtcbiAgYXR0cmliTG9jYXRpb25zOiB7cG9zaXRpb246IG51bWJlcjsgdGV4dHVyZUNvb3JkOiBudW1iZXJ9O1xufVxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEFydGlmYWN0IHtcbiAgdHlwZSBVbmlmb3JtTG9jYXRpb25zID0gQXJ0aWZhY3RbJ3VuaWZvcm1Mb2NhdGlvbnMnXTtcbiAgdHlwZSBBdHRyaWJMb2NhdGlvbnMgPSBBcnRpZmFjdFsnYXR0cmliTG9jYXRpb25zJ107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVW5pZm9ybURhdGEge1xuICBbbmFtZTogc3RyaW5nXTogbnVtYmVyfG51bWJlcltdO1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnLi4vLi4vdXRpbCc7XG4vKipcbiAqIEdpdmVuIGEgbm9uIFJHQkEgc2hhcGUgY2FsY3VsYXRlIHRoZSBSIHZlcnNpb25cbiAqIEl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgZGltZW5zaW9ucyBhcmUgbXVsdGlwbGVzIG9mIGdpdmVuIGNoYW5uZWxzXG4gKiBOT1RFOiBpdCBpcyBhbHdheXMgdGhlIGxhc3QgZGltIHRoYXQgZ2V0cyBwYWNrZWQuXG4gKiBAcGFyYW0gdW5wYWNrZWRTaGFwZSBvcmlnaW5hbCBzaGFwZSB0byBjcmVhdGUgYSBwYWNrZWQgdmVyc2lvbiBmcm9tXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYWNrZWRTaGFwZSh1bnBhY2tlZFNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgY29uc3QgbGVuID0gdW5wYWNrZWRTaGFwZS5sZW5ndGg7XG4gIHJldHVybiB1bnBhY2tlZFNoYXBlLnNsaWNlKDAsIGxlbiAtIDEpLmNvbmNhdCh1bnBhY2tlZFNoYXBlW2xlbiAtIDFdIC8gNCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXBlYXRlZFRyeShcbiAgICBjaGVja0ZuOiAoKSA9PiBib29sZWFuLCBkZWxheUZuID0gKF9jb3VudGVyOiBudW1iZXIpID0+IDAsIG1heENvdW50ZXI/OiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBsZXQgdHJ5Q291bnQgPSAwO1xuXG4gICAgY29uc3QgdHJ5Rm4gPSAoKSA9PiB7XG4gICAgICBpZiAoY2hlY2tGbigpKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0cnlDb3VudCsrO1xuXG4gICAgICBjb25zdCBuZXh0QmFja29mZiA9IGRlbGF5Rm4odHJ5Q291bnQpO1xuXG4gICAgICBpZiAobWF4Q291bnRlciAhPSBudWxsICYmIHRyeUNvdW50ID49IG1heENvdW50ZXIpIHtcbiAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQodHJ5Rm4sIG5leHRCYWNrb2ZmKTtcbiAgICB9O1xuXG4gICAgdHJ5Rm4oKTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIHRoZSBmdW5jdGlvbiBuYW1lIGZyb20gYW4gaW5wdXQgc2FtcGxlciBuYW1lLlxuICogQHBhcmFtIHNhbXBsZXJOYW1lIE5hbWUgb2YgdGhlIHNhbXBsZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVNoYWRlckZ1bmNOYW1lRnJvbUlucHV0U2FtcGxlck5hbWUoc2FtcGxlck5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGFzc2VydCh0eXBlb2Ygc2FtcGxlck5hbWUgIT09ICd1bmRlZmluZWQnICYmIHNhbXBsZXJOYW1lLmxlbmd0aCAhPT0gMCwgKCkgPT4gJ2VtcHR5IHN0cmluZyBmb3VuZCBmb3Igc2FtcGxlciBuYW1lJyk7XG4gIHJldHVybiAnZ2V0JyArIHNhbXBsZXJOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc2FtcGxlck5hbWUuc2xpY2UoMSk7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIHRoZSBmdW5jdGlvbiBuYW1lIGZyb20gYW4gaW5wdXQgc2FtcGxlciBuYW1lIGF0IG91dHB1dCBjb29yZGluYXRlcy5cbiAqIEBwYXJhbSBzYW1wbGVyTmFtZSBOYW1lIG9mIHRoZSBzYW1wbGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lQXRPdXRDb29yZHMoc2FtcGxlck5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGFzc2VydCh0eXBlb2Ygc2FtcGxlck5hbWUgIT09ICd1bmRlZmluZWQnICYmIHNhbXBsZXJOYW1lLmxlbmd0aCAhPT0gMCwgKCkgPT4gJ2VtcHR5IHN0cmluZyBmb3VuZCBmb3Igc2FtcGxlciBuYW1lJyk7XG4gIHJldHVybiAnZ2V0JyArIHNhbXBsZXJOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc2FtcGxlck5hbWUuc2xpY2UoMSkgKyAnQXRPdXRDb29yZHMnO1xufVxuXG4vKiogUmV0dXJucyBhIG5ldyBpbnB1dCBzaGFwZSAoYSBjb3B5KSB0aGF0IGhhcyBhIHNxdWVlemVkIGxvZ2ljYWwgc2hhcGUuICovXG5leHBvcnQgZnVuY3Rpb24gc3F1ZWV6ZUlucHV0U2hhcGUoaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHNxdWVlemVkU2hhcGU6IG51bWJlcltdKTogbnVtYmVyW10ge1xuICAvLyBEZWVwIGNvcHkuXG4gIGxldCBuZXdJbnB1dFNoYXBlOiBudW1iZXJbXSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXRTaGFwZSkpO1xuICBuZXdJbnB1dFNoYXBlID0gc3F1ZWV6ZWRTaGFwZTtcbiAgcmV0dXJuIG5ld0lucHV0U2hhcGU7XG59XG5cbi8qKiBSZXR1cm5zIGEgbGlzdCBvZiBzcXVlZXplZCBwYXJhbWV0ZXJzIGZvciBzaGFkZXIgZnVuY3Rpb25zICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zOiBzdHJpbmdbXSwga2VwdERpbXM6IG51bWJlcltdKTogc3RyaW5nIHtcbiAgcmV0dXJuIGtlcHREaW1zLm1hcChkID0+IHBhcmFtc1tkXSkuam9pbignLCAnKTtcbn1cblxuLyoqIFJldHVybnMgdGhlIGRhdGEgdHlwZSBmb3IgZGlmZmVyZW50IHJhbmtzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvb3Jkc0RhdGFUeXBlKHJhbms6IG51bWJlcik6IHN0cmluZyB7XG4gIGlmIChyYW5rIDw9IDEpIHtcbiAgICByZXR1cm4gJ2ludCc7XG4gIH0gZWxzZSBpZiAocmFuayA9PT0gMikge1xuICAgIHJldHVybiAnaXZlYzInO1xuICB9IGVsc2UgaWYgKHJhbmsgPT09IDMpIHtcbiAgICByZXR1cm4gJ2l2ZWMzJztcbiAgfSBlbHNlIGlmIChyYW5rID09PSA0KSB7XG4gICAgcmV0dXJuICdpdmVjNCc7XG4gIH0gZWxzZSBpZiAocmFuayA9PT0gNSkge1xuICAgIHJldHVybiAnaXZlYzUnO1xuICB9IGVsc2UgaWYgKHJhbmsgPT09IDYpIHtcbiAgICByZXR1cm4gJ2l2ZWM2JztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcihgR1BVIGZvciByYW5rICR7cmFua30gaXMgbm90IHlldCBzdXBwb3J0ZWRgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2xDaGFubmVscyhyYW5rID0gNik6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIFsneCcsICd5JywgJ3onLCAndycsICd1JywgJ3YnXS5zbGljZSgwLCByYW5rKTtcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtnZXRHbENoYW5uZWxzfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRWZWNDaGFubmVscyhuYW1lOiBzdHJpbmcsIHJhbms6IG51bWJlcik6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIGdldEdsQ2hhbm5lbHMocmFuaykubWFwKGQgPT4gYCR7bmFtZX0uJHtkfWApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hhbm5lbHMobmFtZTogc3RyaW5nLCByYW5rOiBudW1iZXIpOiBzdHJpbmdbXSB7XG4gIGlmIChyYW5rID09PSAxKSB7XG4gICAgcmV0dXJuIFtuYW1lXTtcbiAgfVxuICByZXR1cm4gZ2V0VmVjQ2hhbm5lbHMobmFtZSwgcmFuayk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnBhY2tGcm9tQ2hhbm5lbCgpOiBzdHJpbmcge1xuICByZXR1cm4gYFxuICAgIGZsb2F0IGdldENoYW5uZWwodmVjNCBmcmFnLCBpbnQgZGltKSB7XG4gICAgICBpbnQgbW9kQ29vcmQgPSBpbW9kKGRpbSwgMik7XG4gICAgICByZXR1cm4gbW9kQ29vcmQgPT0gMCA/IGZyYWcuciA6IGZyYWcuZztcbiAgICB9XG5cbiAgICBmbG9hdCBnZXRDaGFubmVsKHZlYzQgZnJhZywgdmVjMiBpbm5lckRpbXMpIHtcbiAgICAgIHZlYzIgbW9kQ29vcmQgPSBtb2QoaW5uZXJEaW1zLCAyLik7XG4gICAgICByZXR1cm4gbW9kQ29vcmQueCA9PSAwLiA/XG4gICAgICAgIChtb2RDb29yZC55ID09IDAuID8gZnJhZy5yIDogZnJhZy5nKSA6XG4gICAgICAgIChtb2RDb29yZC55ID09IDAuID8gZnJhZy5iIDogZnJhZy5hKTtcbiAgICB9XG4gIGA7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtnZXRHbHNsfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUHJvZ3JhbUluZm9Mb2FkZXIsIFRleHR1cmVUeXBlfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge2dldENvb3Jkc0RhdGFUeXBlfSBmcm9tICcuLi91dGlscyc7XG5cbmltcG9ydCB7Z2V0Q2hhbm5lbHN9IGZyb20gJy4vcGFja2luZy11dGlscyc7XG5cbmNvbnN0IHBhY2tQcm9ncmFtTWV0YWRhdGEgPSB7XG4gIG5hbWU6ICdwYWNrJyxcbiAgaW5wdXROYW1lczogWydBJ10sXG4gIGlucHV0VHlwZXM6IFtUZXh0dXJlVHlwZS51bnBhY2tlZFJldmVyc2VkXVxufTtcblxuY29uc3QgY3JlYXRlUGFja1Byb2dyYW1JbmZvID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXQ6IFRlbnNvcik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgZ2xzbCA9IGdldEdsc2woaGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXQuZGltcztcblxuICBjb25zdCBpbnB1dFJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcbiAgLy8gY3JlYXRlVGV4dHVyZUxheW91dEZyb21TaGFwZSB3b24ndCBjaGFuZ2Ugb3V0cHV0IHJhbmsuIE5lZWQgdG8gdmVyaWZ5IGJ5IHJ1bm5pbmcgdGVzdHNcbiAgY29uc3Qgb3V0cHV0UmFuayA9IGlucHV0LmRpbXMubGVuZ3RoO1xuXG4gIGNvbnN0IGNvb3Jkc0RhdGFUeXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUob3V0cHV0UmFuayk7XG4gIGNvbnN0IGNoYW5uZWxzID0gZ2V0Q2hhbm5lbHMoJ3JjJywgb3V0cHV0UmFuayk7XG4gIGNvbnN0IHNldHVwID0gZ2V0U2V0dXAob3V0cHV0UmFuaywgY2hhbm5lbHMsIGlucHV0U2hhcGVbaW5wdXRTaGFwZS5sZW5ndGggLSAyXSwgaW5wdXRTaGFwZVtpbnB1dFNoYXBlLmxlbmd0aCAtIDFdKTtcblxuICBsZXQgcmV2ZXJzZWRJbnB1dFdIO1xuICBpZiAoaW5wdXRSYW5rID09PSAwKSB7XG4gICAgcmV2ZXJzZWRJbnB1dFdIID0gWzEsIDFdO1xuICB9IGVsc2UgaWYgKGlucHV0UmFuayA9PT0gMSkge1xuICAgIHJldmVyc2VkSW5wdXRXSCA9IFtpbnB1dFNoYXBlWzBdLCAxXTtcbiAgfSBlbHNlIHtcbiAgICByZXZlcnNlZElucHV0V0ggPSBbaW5wdXRTaGFwZVtvdXRwdXRSYW5rIC0gMV0sIGlucHV0U2hhcGVbb3V0cHV0UmFuayAtIDJdXTtcbiAgfVxuICBjb25zdCBvdXRPZkJvdW5kc0NvbmRpdGlvbiA9IGdldE91dE9mQm91bmRzQ29uZGl0aW9uKG91dHB1dFJhbmssIHJldmVyc2VkSW5wdXRXSCwgY2hhbm5lbHMpO1xuICBjb25zdCBvdXRwdXQgPSBnZXRPdXRwdXQoaW5wdXRTaGFwZSwgY2hhbm5lbHMpO1xuXG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICR7Y29vcmRzRGF0YVR5cGV9IHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG5cbiAgICAgICAgICBpZigke291dE9mQm91bmRzQ29uZGl0aW9ufSkge1xuICAgICAgICAgICAgJHtnbHNsLm91dHB1dH0gPSB2ZWM0KDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAke3NldHVwfVxuXG4gICAgICAgICAgICAke2dsc2wub3V0cHV0fSA9IHZlYzQoJHtvdXRwdXR9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGA7XG4gIHJldHVybiB7XG4gICAgLi4ucGFja1Byb2dyYW1NZXRhZGF0YSxcbiAgICBoYXNNYWluOiB0cnVlLFxuICAgIG91dHB1dDoge2RpbXM6IGlucHV0LmRpbXMsIHR5cGU6IGlucHV0LnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS5wYWNrZWR9LFxuICAgIHNoYWRlclNvdXJjZVxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVBhY2tQcm9ncmFtSW5mb0xvYWRlciA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0OiBUZW5zb3IpOiBQcm9ncmFtSW5mb0xvYWRlciA9PlxuICAgICh7Li4ucGFja1Byb2dyYW1NZXRhZGF0YSwgZ2V0OiAoKSA9PiBjcmVhdGVQYWNrUHJvZ3JhbUluZm8oaGFuZGxlciwgaW5wdXQpfSk7XG5cbi8qKlxuICogY2hlY2sgb3V0cHV0IGNvb3JkaW5hdGUgbG9jYXRpb24gYW5kIHJldHVybiBmYWxzZSBpZiBpdCBpcyBvdXRzaWRlIGlucHV0J3Mgd2lkdGgvaGVpZ2h0IGJvdW5kYXJ5XG4gKi9cbmZ1bmN0aW9uIGdldE91dE9mQm91bmRzQ29uZGl0aW9uKHJhbms6IG51bWJlciwgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBkaW1zOiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gIGlmIChyYW5rID09PSAwKSB7XG4gICAgcmV0dXJuICdmYWxzZSc7XG4gIH1cbiAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICByZXR1cm4gYHJjID4gJHtzaGFwZVswXX1gO1xuICB9XG5cbiAgbGV0IGNvbmQgPSAnJztcbiAgZm9yIChsZXQgaSA9IHJhbmsgLSAyOyBpIDwgcmFuazsgaSsrKSB7XG4gICAgY29uZCArPSBgJHtkaW1zW2ldfSA+PSAke3NoYXBlW2kgLSByYW5rICsgMl19YDtcbiAgICBpZiAoaSA8IHJhbmsgLSAxKSB7XG4gICAgICBjb25kICs9ICd8fCc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmQ7XG59XG5cbi8qKlxuICogY29kZSBzbmlwcGV0IHRvIHNhbXBsZSBpbnB1dCB0ZXh0dXJlIHdpdGggb3V0cHV0IGNvb3JkaWFudGVzXG4gKi9cbmZ1bmN0aW9uIGdldE91dHB1dChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIGRpbXM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcblxuICBpZiAocmFuayA9PT0gMCkge1xuICAgIHJldHVybiAnZ2V0QSgpLCAwLCAwLCAwJztcbiAgfVxuXG4gIGlmIChyYW5rID09PSAxKSB7XG4gICAgcmV0dXJuIGBnZXRBKHJjKSxcbiAgICAgICAgICAgIHJjICsgMSA+PSAke3NoYXBlWzBdfSA/IDAuIDogZ2V0QShyYyArIDEpLFxuICAgICAgICAgICAgMCwgMGA7XG4gIH1cblxuICBjb25zdCBjb29yZDAwID0gJ3IsIGMnO1xuICBjb25zdCBjb29yZDAxID0gJ3IsIGNwMSc7XG4gIGNvbnN0IGNvb3JkMTAgPSAncnAxLCBjJztcbiAgY29uc3QgY29vcmQxMSA9ICdycDEsIGNwMSc7XG4gIGxldCBEID0gJyc7XG4gIGlmIChyYW5rID4gMikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuayAtIDI7ICsraSkge1xuICAgICAgRCA9IEQgKyBgJHtkaW1zW2ldfSxgO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYGdldEEoJHtEfSR7Y29vcmQwMH0pLFxuICAgICAgICAgIHJFZGdlID8gMC4gOiBnZXRBKCR7RH0ke2Nvb3JkMTB9KSxcbiAgICAgICAgICBjRWRnZSA/IDAuIDogZ2V0QSgke0R9JHtjb29yZDAxfSksXG4gICAgICAgICAgckVkZ2UgfHwgY0VkZ2UgPyAwLiA6IGdldEEoJHtEfSR7Y29vcmQxMX0pYDtcbn1cblxuLyoqXG4gKiBjb2RlIHNuaXBwZXQgdG8gc2V0dXAgNCBjb29yZGluYXRlcyBhbmQgZWRnZSBjb25kaXRpb25zXG4gKi9cbmZ1bmN0aW9uIGdldFNldHVwKHJhbms6IG51bWJlciwgZGltczogc3RyaW5nW10sIHJvd3M6IG51bWJlciwgY29sczogbnVtYmVyKTogc3RyaW5nIHtcbiAgaWYgKHJhbmsgPT09IDAgfHwgcmFuayA9PT0gMSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICAvLyByYW5rID49IDIgZm9yIHdpZHRoK2hlaWdodCBwYWNrLlxuICBlbHNlIHtcbiAgICBjb25zdCBzZXR1cCA9IGBcbiAgICBpbnQgciA9ICR7ZGltc1tyYW5rIC0gMl19O1xuICAgIGludCBjID0gJHtkaW1zW3JhbmsgLSAxXX07XG4gICAgaW50IHJwMSA9ICR7ZGltc1tyYW5rIC0gMl19ICsgMTtcbiAgICBpbnQgY3AxID0gJHtkaW1zW3JhbmsgLSAxXX0gKyAxO1xuICAgIGJvb2wgckVkZ2UgPSBycDEgPj0gJHtjb2xzfTtcbiAgICBib29sIGNFZGdlID0gY3AxID49ICR7cm93c307XG4gICAgYDtcbiAgICByZXR1cm4gc2V0dXA7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgUHJvZ3JhbU1ldGFkYXRhLCBUZXh0dXJlVHlwZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge3VucGFja0Zyb21DaGFubmVsfSBmcm9tICcuL3BhY2tpbmctdXRpbHMnO1xuXG5jb25zdCBjcmVhdGVQYWNrZWRSZXNoYXBlM0RQcm9ncmFtTWV0YWRhdGEgPSAob3V0cHV0U2hhcGUzRDogcmVhZG9ubHkgbnVtYmVyW10pID0+XG4gICAgKHtuYW1lOiAnUmVzaGFwZSAocGFja2VkKScsIGlucHV0VHlwZXM6IFtUZXh0dXJlVHlwZS5wYWNrZWRdLCBpbnB1dE5hbWVzOiBbJ0EnXSwgY2FjaGVIaW50OiBgJHtvdXRwdXRTaGFwZTNEfWB9KTtcblxuY29uc3QgY3JlYXRlUGFja2VkUmVzaGFwZTNEUHJvZ3JhbUluZm8gPVxuICAgIChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0M0Q6IFRlbnNvciwgbWV0YWRhdGE6IFByb2dyYW1NZXRhZGF0YSwgb3V0cHV0U2hhcGUzRDogcmVhZG9ubHkgbnVtYmVyW10pOlxuICAgICAgICBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICAgICAgY29uc3QgaW5wdXRTaGFwZTNEID0gaW5wdXQzRC5kaW1zIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgICAgICAgICBjb25zdCBzcXVlZXplZE91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGUzRCBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG5cbiAgICAgICAgICBsZXQgbWFpbkxvb3AgPSAnJztcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IG91dHB1dENvb3JkcyA9ICcnO1xuICAgICAgICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvdXRwdXRDb29yZHMgPSAnb3V0cHV0Q29vcmRzID0gcmM7JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG91dHB1dENvb3JkcyA9ICdvdXRwdXRDb29yZHMgPSBpdmVjMyhyYy54LCByYy55KzEsIHJjLnopOyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBvdXRwdXRDb29yZHMgPSAnb3V0cHV0Q29vcmRzID0gaXZlYzMocmMueCwgcmMueSwgcmMueisxKTsnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgb3V0cHV0Q29vcmRzID0gJ291dHB1dENvb3JkcyA9IGl2ZWMzKHJjLngsIHJjLnkrMSwgcmMueisxKTsnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICR7b3V0cHV0Q29vcmRzfVxuICAgICAgICAke2kgPiAwID8gJ2lmKG91dHB1dENvb3Jkcy55IDwgcm93cyAmJiBvdXRwdXRDb29yZHMueiA8IGNvbHMpeycgOiAnJ31cbiAgICAgICAgICBpbnQgZmxhdHRlbmVkSW5kZXggPSBnZXRGbGF0dGVuZWRJbmRleChvdXRwdXRDb29yZHMpO1xuXG4gICAgICAgICAgaXZlYzMgaW5wdXRSQyA9IGlucHV0Q29vcmRzRnJvbVJlc2hhcGVkT3V0Q29vcmRzKGZsYXR0ZW5lZEluZGV4KTtcbiAgICAgICAgICB2ZWMyIGlubmVyRGltcyA9IHZlYzIoZmxvYXQoaW5wdXRSQy55KSxmbG9hdChpbnB1dFJDLnopKTtcblxuICAgICAgICAgIHJlc3VsdFske2l9XSA9IGdldENoYW5uZWwoZ2V0QShpbnB1dFJDLngsIGlucHV0UkMueSwgaW5wdXRSQy56KSwgaW5uZXJEaW1zKTtcblxuICAgICAgICAke2kgPiAwID8gJ30nIDogJyd9XG4gICAgICBgO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBnbHNsID0gZ2V0R2xzbChoYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG5cbiAgICAgICAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICAke2dldFJlc2hhcGVkSW5wdXRDb29yZHMoaW5wdXRTaGFwZTNEKX1cbiAgICAgICR7Z2V0RmxhdHRlbmVkSW5kZXhGcm9tM0Qoc3F1ZWV6ZWRPdXRwdXRTaGFwZSl9XG4gICAgICAke3VucGFja0Zyb21DaGFubmVsKCl9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzMgcmMgPSBnZXRPdXRwdXRDb29yZHMoKTtcblxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4wKTtcblxuICAgICAgICBpdmVjMyBvdXRwdXRDb29yZHM7XG4gICAgICAgIGludCByb3dzID0gJHtzcXVlZXplZE91dHB1dFNoYXBlWzJdfTtcbiAgICAgICAgaW50IGNvbHMgPSAke3NxdWVlemVkT3V0cHV0U2hhcGVbMV19O1xuXG4gICAgICAgICR7bWFpbkxvb3B9XG4gICAgICAgICR7Z2xzbC5vdXRwdXR9ID0gcmVzdWx0O1xuICAgICAgfVxuICAgIGA7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgICAgICBvdXRwdXQ6IHtkaW1zOiBzcXVlZXplZE91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dDNELnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS5wYWNrZWR9LFxuICAgICAgICAgICAgc2hhZGVyU291cmNlLFxuICAgICAgICAgICAgaGFzTWFpbjogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQYWNrZWRSZXNoYXBlM0RQcm9ncmFtSW5mb0xvYWRlciA9XG4gICAgKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXQzRDogVGVuc29yLCBvdXRwdXRTaGFwZTNEOiByZWFkb25seSBudW1iZXJbXSk6IFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlUGFja2VkUmVzaGFwZTNEUHJvZ3JhbU1ldGFkYXRhKG91dHB1dFNoYXBlM0QpO1xuICAgICAgcmV0dXJuIHsuLi5tZXRhZGF0YSwgZ2V0OiAoKSA9PiBjcmVhdGVQYWNrZWRSZXNoYXBlM0RQcm9ncmFtSW5mbyhoYW5kbGVyLCBpbnB1dDNELCBtZXRhZGF0YSwgb3V0cHV0U2hhcGUzRCl9O1xuICAgIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzRGltczNEKHNoYXBlOiBBcnJheUxpa2U8bnVtYmVyPik6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSB7XG4gIGlmIChzaGFwZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gWzEsIDEsIDFdO1xuICB9XG4gIC8vIFRPRE86IHNxdWVlemUgb3RoZXIgc2hhcGVzIHRvIDJEIGNhc2VcbiAgbGV0IGJhdGNoID0gMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFwZS5sZW5ndGggLSAyOyArK2kpIHtcbiAgICBiYXRjaCAqPSBzaGFwZVtpXTtcbiAgfVxuICByZXR1cm4gW2JhdGNoLCBzaGFwZS5sZW5ndGggPiAxID8gc2hhcGVbc2hhcGUubGVuZ3RoIC0gMl0gOiAxLCBzaGFwZVtzaGFwZS5sZW5ndGggLSAxXV07XG59XG5cbi8vIEZvciBwYWNrZWQgcmVzaGFwZSwgd2UgbmVlZCB0byByZS1hcnJhbmdlIHRleGVsIGRhdGEgZm9yIG91dHB1dCBzaGFwZS5cbi8vIE91ciBwYWNrIGlzIGRlc2lnbmVkIHRvIHBhY2sgYSAyeDIgdGlsZSBpbiBsYXN0IGggYW5kIHcgZGltZW5zaW9uLCBzb1xuLy8gZm9yIHRoZSByZXNoYXBlZCBuZXcgdGVuc29yLCB3ZSBqdXN0IG5lZWQgdG8gcmUtYXJyYW5nZSB0aGUgbGFzdCBoIGFuZFxuLy8gdyBkaW1lbnNpb24uIEZvciBhbnkgc2hhcGUgdGhhdCBpcyBub3QgaW4gM0QsIGkuZS4gW2JhdGNoLCBXLCBIXSwgd2Vcbi8vIGZpcnN0IGNvbnZlcnQgaXQgdG8gM0QgYnkgY29sbGFwc2luZyBvdGhlciBkaW1lbnNpb24gdG8gYmF0Y2ggZGltLCB0aGVuXG4vLyBwcm9jZXNzIHdpdGggdGhlIGxhc3QgdHdvIGRpbWVuc2lvbnMuXG4vLyBOb3RlOiB3ZSBvbmx5IG5lZWQgdGhlIHNoYXBlIHRlbnNvciB0byBjYWxjdWxhdGUgb3V0cHV0IHNoYXBlLCBzbyB0aGVcbi8vIGNvbnRlbnQgaW4gc2hhcGUgdGVuc29yIGlzIG5ldmVyIHVwbG9hZGVkIHRvIEdQVS4gSXQgaXMgYWx3YXlzIGtlcHQgaW4gQ1BVLlxuLy8gVE9ETzogb3B0aW1pemUgdGhlIGFsZ29yaXRobSAtLSBpbiBzb21lIGNhc2VzLCBpZiB0aGUgbGFzdCB0d28gZGltcyBhcmVcbi8vIHRoZSBzYW1lIGJldHdlZW4gaW5wdXQgc2hhcGUgYW5kIG91dHB1dCBzaGFwZSwgdGhlIHBhY2tlZCByZXNoYXBlIGNhbiBiZVxuLy8gdHJlYXRlZCBhcyBuby1vcC5cbmV4cG9ydCBmdW5jdGlvbiBpc1Jlc2hhcGVDaGVhcChkaW1zOiByZWFkb25seSBudW1iZXJbXSwgcmVzaGFwZWREaW1zOiByZWFkb25seSBudW1iZXJbXSkge1xuICBsZXQgaXNDaGVhcFJlc2hhcGUgPSBmYWxzZTtcbiAgaWYgKGRpbXMubGVuZ3RoID09PSAwIHx8IHJlc2hhcGVkRGltcy5sZW5ndGggPT09IDApIHsgIC8vIHNjYWxhclxuICAgIGlzQ2hlYXBSZXNoYXBlID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChkaW1zLmxlbmd0aCA8IDIgfHwgcmVzaGFwZWREaW1zLmxlbmd0aCA8IDIpIHsgIC8vIDFEXG4gICAgaXNDaGVhcFJlc2hhcGUgPSBkaW1zW2RpbXMubGVuZ3RoIC0gMV0gPT09IHJlc2hhcGVkRGltc1tyZXNoYXBlZERpbXMubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7ICAvLyAyRCArXG4gICAgaXNDaGVhcFJlc2hhcGUgPSBkaW1zW2RpbXMubGVuZ3RoIC0gMV0gPT09IHJlc2hhcGVkRGltc1tyZXNoYXBlZERpbXMubGVuZ3RoIC0gMV0gJiZcbiAgICAgICAgZGltc1tkaW1zLmxlbmd0aCAtIDJdID09PSByZXNoYXBlZERpbXNbcmVzaGFwZWREaW1zLmxlbmd0aCAtIDJdO1xuICB9XG5cbiAgcmV0dXJuIGlzQ2hlYXBSZXNoYXBlO1xufVxuXG5mdW5jdGlvbiBnZXRSZXNoYXBlZElucHV0Q29vcmRzKHNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0pOiBzdHJpbmcge1xuICBjb25zdCBzdHJpZGVzID0gU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKHNoYXBlKTtcbiAgY29uc3QgY29vcmRzID0gWydiJywgJ3InLCAnYyddO1xuICBjb25zdCBpbmRleCA9ICdpbmRleCc7XG4gIGNvbnN0IGNvb3Jkc0Zyb21JbmRleFNuaXBwZXQgPSBzdHJpZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoc3RyaWRlLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5lMSA9IGBpbnQgJHtjb29yZHNbaV19ID0gJHtpbmRleH0gLyAke3N0cmlkZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZTIgPSBpID09PSBzdHJpZGVzLmxlbmd0aCAtIDEgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBpbnQgJHtjb29yZHNbaSArIDFdfSA9ICR7aW5kZXh9IC0gJHtjb29yZHNbaV19ICogJHtzdHJpZGV9YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGluZGV4IC09ICR7Y29vcmRzW2ldfSAqICR7c3RyaWRlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7bGluZTF9OyAke2xpbmUyfTtgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJycpO1xuXG4gIHJldHVybiBgXG4gICAgaXZlYzMgaW5wdXRDb29yZHNGcm9tUmVzaGFwZWRPdXRDb29yZHMoaW50IGluZGV4KSB7XG4gICAgICAke2Nvb3Jkc0Zyb21JbmRleFNuaXBwZXR9XG4gICAgICByZXR1cm4gaXZlYzMoYiwgciwgYyk7XG4gICAgfVxuICBgO1xufVxuXG5mdW5jdGlvbiBnZXRGbGF0dGVuZWRJbmRleEZyb20zRChzaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdKTogc3RyaW5nIHtcbiAgY29uc3Qgc3RyaWRlcyA9IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhzaGFwZSk7XG5cbiAgcmV0dXJuIGBcbiAgaW50IGdldEZsYXR0ZW5lZEluZGV4KGl2ZWMzIGNvb3Jkcykge1xuICAgIC8vIHJldmVyc2UgeSwgeiBvcmRlclxuICAgIHJldHVybiBjb29yZHMueCAqICR7c3RyaWRlc1swXX0gKyBjb29yZHMueiAqICR7c3RyaWRlc1sxXX0gKyBjb29yZHMueTtcbiAgfVxuYDtcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtnZXRHbHNsfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtUZXh0dXJlRGF0YSwgVGV4dHVyZVR5cGV9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IGVuY29kZUFzVWludDggPSAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dDogVGV4dHVyZURhdGEpOiBUZXh0dXJlRGF0YSA9PiB7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXQuc2hhcGU7XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgLyoqXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RmanMtY29yZS9ibG9iL21hc3Rlci9zcmMva2VybmVscy93ZWJnbC9lbmNvZGVfZmxvYXRfZ3B1LnRzXG4gICAqL1xuICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgY29uc3QgZmxvYXQgRkxPQVRfTUFYID0gMS43MDE0MTE4NGUzODtcbiAgICBjb25zdCBmbG9hdCBGTE9BVF9NSU4gPSAxLjE3NTQ5NDM1ZS0zODtcblxuICAgIGJvb2wgaXNOYU4oZmxvYXQgdmFsKSB7XG4gICAgICByZXR1cm4gKHZhbCA8IDEuMCB8fCAwLjAgPCB2YWwgfHwgdmFsID09IDAuMCkgPyBmYWxzZSA6IHRydWU7XG4gICAgfVxuXG4gICAgaGlnaHAgdmVjNCBlbmNvZGVBc1VpbnQ4KGhpZ2hwIGZsb2F0IHYpIHtcbiAgICAgIGlmIChpc05hTih2KSkge1xuICAgICAgICByZXR1cm4gdmVjNCgyNTUsIDI1NSwgMjU1LCAyNTUpO1xuICAgICAgfVxuXG4gICAgICBoaWdocCBmbG9hdCBhdiA9IGFicyh2KTtcblxuICAgICAgaWYoYXYgPCBGTE9BVF9NSU4pIHtcbiAgICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcbiAgICAgIH0gZWxzZSBpZih2ID4gRkxPQVRfTUFYKSB7XG4gICAgICAgIHJldHVybiB2ZWM0KDAuMCwgMC4wLCAxMjguMCwgMTI3LjApIC8gMjU1LjA7XG4gICAgICB9IGVsc2UgaWYodiA8IC1GTE9BVF9NQVgpIHtcbiAgICAgICAgcmV0dXJuIHZlYzQoMC4wLCAwLjAsICAxMjguMCwgMjU1LjApIC8gMjU1LjA7XG4gICAgICB9XG5cbiAgICAgIGhpZ2hwIHZlYzQgYyA9IHZlYzQoMCwwLDAsMCk7XG5cbiAgICAgIGhpZ2hwIGZsb2F0IGUgPSBmbG9vcihsb2cyKGF2KSk7XG4gICAgICBoaWdocCBmbG9hdCBtID0gZXhwMihmcmFjdChsb2cyKGF2KSkpIC0gMS4wO1xuXG4gICAgICBjWzJdID0gZmxvb3IoMTI4LjAgKiBtKTtcbiAgICAgIG0gLT0gY1syXSAvIDEyOC4wO1xuICAgICAgY1sxXSA9IGZsb29yKDMyNzY4LjAgKiBtKTtcbiAgICAgIG0gLT0gY1sxXSAvIDMyNzY4LjA7XG4gICAgICBjWzBdID0gZmxvb3IoODM4ODYwOC4wICogbSk7XG5cbiAgICAgIGhpZ2hwIGZsb2F0IGViaWFzID0gZSArIDEyNy4wO1xuICAgICAgY1szXSA9IGZsb29yKGViaWFzIC8gMi4wKTtcbiAgICAgIGViaWFzIC09IGNbM10gKiAyLjA7XG4gICAgICBjWzJdICs9IGZsb29yKGViaWFzKSAqIDEyOC4wO1xuXG4gICAgICBjWzNdICs9IDEyOC4wICogc3RlcCgwLjAsIC12KTtcblxuICAgICAgcmV0dXJuIGMgLyAyNTUuMDtcbiAgICB9XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICBmbG9hdCB2YWx1ZSA9ICR7Z2xzbC50ZXh0dXJlMkR9KFgsVGV4Q29vcmRzKS5yO1xuICAgICAgJHtnbHNsLm91dHB1dH0gPSBlbmNvZGVBc1VpbnQ4KHZhbHVlKTtcbiAgICB9YDtcbiAgY29uc3QgcHJvZ3JhbUluZm8gPSB7XG4gICAgbmFtZTogJ1VpbnQ4RW5jb2RlJyxcbiAgICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxuICAgIGlucHV0TmFtZXM6IFsnWCddLFxuICAgIG91dHB1dDoge2RpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dC50ZW5zb3IudHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLmRvd25sb2FkVWludDhBc0Zsb2F0fSxcbiAgICBzaGFkZXJTb3VyY2UsXG4gICAgaGFzTWFpbjogdHJ1ZVxuICB9O1xuICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5leGVjdXRlUHJvZ3JhbShwcm9ncmFtSW5mbywgW2lucHV0LnRlbnNvcl0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgVGV4dHVyZVR5cGV9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7Z2V0Q29vcmRzRGF0YVR5cGV9IGZyb20gJy4uL3V0aWxzJztcblxuaW1wb3J0IHtnZXRDaGFubmVscywgdW5wYWNrRnJvbUNoYW5uZWx9IGZyb20gJy4vcGFja2luZy11dGlscyc7XG5cbmNvbnN0IHVucGFja1Byb2dyYW1NZXRhZGF0YSA9IHtcbiAgbmFtZTogJ3VucGFjaycsXG4gIGlucHV0TmFtZXM6IFsnQSddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUucGFja2VkXVxufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVVucGFja1Byb2dyYW1JbmZvID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXQ6IFRlbnNvcik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgcmFuayA9IGlucHV0LmRpbXMubGVuZ3RoO1xuXG4gIGNvbnN0IGNoYW5uZWxzID0gZ2V0Q2hhbm5lbHMoJ3JjJywgcmFuayk7XG4gIGNvbnN0IGlubmVyRGltcyA9IGNoYW5uZWxzLnNsaWNlKC0yKTtcbiAgY29uc3QgY29vcmRzRGF0YVR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShyYW5rKTtcbiAgY29uc3QgdW5wYWNrQ2hhbm5lbCA9IHVucGFja0Zyb21DaGFubmVsKCk7XG4gIGNvbnN0IGlzU2NhbGFyID0gKGlucHV0LmRpbXMubGVuZ3RoID09PSAwKTtcbiAgY29uc3Qgc291cmNlQ29vcmRzID0gaXNTY2FsYXIgPyAnJyA6IGdldFNvdXJjZUNvb3JkcyhyYW5rLCBjaGFubmVscyk7XG4gIGNvbnN0IGNvb3JkcyA9IHJhbmsgPD0gMSA/ICdyYycgOiBgdmVjMigke2lubmVyRGltcy5qb2luKCcsJyl9KWA7XG4gIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICR7dW5wYWNrQ2hhbm5lbH1cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAke2Nvb3Jkc0RhdGFUeXBlfSByYyA9IGdldE91dHB1dENvb3JkcygpO1xuXG4gICAgICAgLy8gU2FtcGxlIHRoZSB0ZXh0dXJlIHdpdGggdGhlIGNvb3JkcyB0byBnZXQgdGhlIHJnYmEgY2hhbm5lbCB2YWx1ZS5cbiAgICAgICB2ZWM0IHBhY2tlZElucHV0ID0gZ2V0QSgke3NvdXJjZUNvb3Jkc30pO1xuXG4gICAgICAgJHtnbHNsLm91dHB1dH0gPSB2ZWM0KGdldENoYW5uZWwocGFja2VkSW5wdXQsICR7Y29vcmRzfSksIDAsIDAsIDApO1xuICAgICB9XG4gICBgO1xuXG4gIHJldHVybiB7XG4gICAgLi4udW5wYWNrUHJvZ3JhbU1ldGFkYXRhLFxuICAgIGhhc01haW46IHRydWUsXG4gICAgb3V0cHV0OiB7ZGltczogaW5wdXQuZGltcywgdHlwZTogaW5wdXQudHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnVucGFja2VkfSxcbiAgICBzaGFkZXJTb3VyY2VcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVVbnBhY2tQcm9ncmFtSW5mb0xvYWRlciA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0OiBUZW5zb3IpOiBQcm9ncmFtSW5mb0xvYWRlciA9PlxuICAgICh7Li4udW5wYWNrUHJvZ3JhbU1ldGFkYXRhLCBnZXQ6ICgpID0+IGNyZWF0ZVVucGFja1Byb2dyYW1JbmZvKGhhbmRsZXIsIGlucHV0KX0pO1xuXG5mdW5jdGlvbiBnZXRTb3VyY2VDb29yZHMocmFuazogbnVtYmVyLCBkaW1zOiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gIGlmIChyYW5rID09PSAxKSB7XG4gICAgcmV0dXJuICdyYyc7XG4gIH1cblxuICBsZXQgY29vcmRzID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgaSsrKSB7XG4gICAgY29vcmRzICs9IGRpbXNbaV07XG4gICAgaWYgKGkgPCByYW5rIC0gMSkge1xuICAgICAgY29vcmRzICs9ICcsJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvb3Jkcztcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtMb2dnZXJ9IGZyb20gJy4uLy4uL2luc3RydW1lbnQnO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgRW5jb2RlciB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgRGF0YVR5cGVNYXAge1xuICAgIGZsb2F0OiBGbG9hdDMyQXJyYXk7XG4gICAgYnl0ZTogVWludDhBcnJheTtcbiAgICBpbnQ6IFVpbnQzMkFycmF5O1xuICB9XG4gIGV4cG9ydCB0eXBlIERhdGFUeXBlID0ga2V5b2YgRGF0YVR5cGVNYXA7XG4gIHR5cGUgRGF0YUFycmF5VHlwZSA9IERhdGFUeXBlTWFwW0RhdGFUeXBlXTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXG5leHBvcnQgY29uc3QgZW51bSBFbmNvZGVyVXNhZ2Uge1xuICBEZWZhdWx0ID0gMCxcbiAgVXBsb2FkT25seSxcbiAgRG93bmxvYWQ0Qnl0ZXNBc0Zsb2F0MzIsXG59XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xuXG4vKipcbiAqIEFic3RyYWN0aW9uIGZvciBtYXBwaW5nIGRhdGEgdHlwZXMgdG8gdGV4dHVyZSB0ZXhsZXRzXG4gKiBFbmNvZGluZyBtZWFucyBob3cgYSBGbG9hdDMyIGlzIG1hcHBlZCB0byAxIG9yIDQgY2hhbm5lbHMgZm9yIGVhY2ggdGV4bGV0XG4gKiBEZWNvZGluZyBtZWFucyBob3cgYSB0ZXhsZXQncyBjaGFubmVscyBhcmUgbWFwcGVkIHRvIGEgcmVzdWx0aW5nIEZsb2F0MzJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEYXRhRW5jb2RlciB7XG4gIGludGVybmFsRm9ybWF0OiBudW1iZXI7XG4gIGZvcm1hdDogbnVtYmVyO1xuICB0ZXh0dXJlVHlwZTogbnVtYmVyO1xuICBjaGFubmVsU2l6ZTogbnVtYmVyO1xuICBlbmNvZGUoc3JjOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUsIHRleHR1cmVTaXplOiBudW1iZXIpOiBFbmNvZGVyLkRhdGFBcnJheVR5cGU7XG4gIGFsbG9jYXRlKHNpemU6IG51bWJlcik6IEVuY29kZXIuRGF0YUFycmF5VHlwZTtcbiAgZGVjb2RlKGJ1ZmZlcjogRW5jb2Rlci5EYXRhQXJyYXlUeXBlLCBkYXRhU2l6ZTogbnVtYmVyKTogRW5jb2Rlci5EYXRhQXJyYXlUeXBlO1xufVxuLyoqXG4gKiBXZWJHTDIgZGF0YSBlbmNvZGVyXG4gKiBVc2VzIFIzMkYgYXMgdGhlIGZvcm1hdCBmb3IgdGV4bGV0XG4gKi9cbmV4cG9ydCBjbGFzcyBSZWRGbG9hdDMyRGF0YUVuY29kZXIgaW1wbGVtZW50cyBEYXRhRW5jb2RlciB7XG4gIGludGVybmFsRm9ybWF0OiBudW1iZXI7XG4gIGZvcm1hdDogbnVtYmVyO1xuICB0ZXh0dXJlVHlwZTogbnVtYmVyO1xuICBjaGFubmVsU2l6ZTogbnVtYmVyO1xuICBjb25zdHJ1Y3RvcihnbDogV2ViR0wyUmVuZGVyaW5nQ29udGV4dCwgY2hhbm5lbHMgPSAxKSB7XG4gICAgaWYgKGNoYW5uZWxzID09PSAxKSB7XG4gICAgICB0aGlzLmludGVybmFsRm9ybWF0ID0gZ2wuUjMyRjtcbiAgICAgIHRoaXMuZm9ybWF0ID0gZ2wuUkVEO1xuICAgICAgdGhpcy50ZXh0dXJlVHlwZSA9IGdsLkZMT0FUO1xuICAgICAgdGhpcy5jaGFubmVsU2l6ZSA9IGNoYW5uZWxzO1xuICAgIH0gZWxzZSBpZiAoY2hhbm5lbHMgPT09IDQpIHtcbiAgICAgIHRoaXMuaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0JBMzJGO1xuICAgICAgdGhpcy5mb3JtYXQgPSBnbC5SR0JBO1xuICAgICAgdGhpcy50ZXh0dXJlVHlwZSA9IGdsLkZMT0FUO1xuICAgICAgdGhpcy5jaGFubmVsU2l6ZSA9IGNoYW5uZWxzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbnVtYmVyIG9mIGNoYW5uZWxzOiAke2NoYW5uZWxzfWApO1xuICAgIH1cbiAgfVxuICBlbmNvZGUoc3JjOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUsIHRleHR1cmVTaXplOiBudW1iZXIpOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUge1xuICAgIGxldCByZXN1bHQ6IEZsb2F0MzJBcnJheTtcbiAgICBsZXQgc291cmNlOiBGbG9hdDMyQXJyYXk7XG4gICAgaWYgKHNyYy5jb25zdHJ1Y3RvciAhPT0gRmxvYXQzMkFycmF5KSB7XG4gICAgICBMb2dnZXIud2FybmluZygnRW5jb2RlcicsICdkYXRhIHdhcyBub3Qgb2YgdHlwZSBGbG9hdDMyOyBjcmVhdGluZyBuZXcgRmxvYXQzMkFycmF5Jyk7XG4gICAgICBzb3VyY2UgPSBuZXcgRmxvYXQzMkFycmF5KHNyYyk7XG4gICAgfVxuICAgIGlmICh0ZXh0dXJlU2l6ZSAqIHRoaXMuY2hhbm5lbFNpemUgPiBzcmMubGVuZ3RoKSB7XG4gICAgICBMb2dnZXIud2FybmluZygnRW5jb2RlcicsICdTb3VyY2UgZGF0YSB0b28gc21hbGwuIEFsbG9jYXRpbmcgbGFyZ2VyIGFycmF5Jyk7XG4gICAgICBzb3VyY2UgPSBzcmMgYXMgRmxvYXQzMkFycmF5O1xuICAgICAgcmVzdWx0ID0gdGhpcy5hbGxvY2F0ZSh0ZXh0dXJlU2l6ZSAqIHRoaXMuY2hhbm5lbFNpemUpIGFzIEZsb2F0MzJBcnJheTtcbiAgICAgIHNvdXJjZS5mb3JFYWNoKCh2LCBpKSA9PiByZXN1bHRbaV0gPSB2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlID0gc3JjIGFzIEZsb2F0MzJBcnJheTtcbiAgICAgIHJlc3VsdCA9IHNvdXJjZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhbGxvY2F0ZShzaXplOiBudW1iZXIpOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUge1xuICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHNpemUgKiA0KTtcbiAgfVxuICBkZWNvZGUoYnVmZmVyOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUsIGRhdGFTaXplOiBudW1iZXIpOiBGbG9hdDMyQXJyYXkge1xuICAgIGlmICh0aGlzLmNoYW5uZWxTaXplID09PSAxKSB7XG4gICAgICBjb25zdCBmaWx0ZXJlZERhdGEgPSAoYnVmZmVyIGFzIEZsb2F0MzJBcnJheSkuZmlsdGVyKChfdmFsdWUsIGluZGV4KSA9PiBpbmRleCAlIDQgPT09IDApLnN1YmFycmF5KDAsIGRhdGFTaXplKTtcbiAgICAgIHJldHVybiBmaWx0ZXJlZERhdGE7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIuc3ViYXJyYXkoMCwgZGF0YVNpemUpIGFzIEZsb2F0MzJBcnJheTtcbiAgfVxufVxuLyoqXG4gKiBEYXRhIGVuY29kZXIgZm9yIFdlYkdMIDEgd2l0aCBzdXBwb3J0IGZvciBmbG9hdGluZyBwb2ludCB0ZXh0dXJlXG4gKi9cbmV4cG9ydCBjbGFzcyBSR0JBRmxvYXREYXRhRW5jb2RlciBpbXBsZW1lbnRzIERhdGFFbmNvZGVyIHtcbiAgaW50ZXJuYWxGb3JtYXQ6IG51bWJlcjtcbiAgZm9ybWF0OiBudW1iZXI7XG4gIHRleHR1cmVUeXBlOiBudW1iZXI7XG4gIGNoYW5uZWxTaXplOiBudW1iZXI7XG4gIGNvbnN0cnVjdG9yKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIGNoYW5uZWxzID0gMSwgdGV4dHVyZVR5cGU/OiBudW1iZXIpIHtcbiAgICBpZiAoY2hhbm5lbHMgIT09IDEgJiYgY2hhbm5lbHMgIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBudW1iZXIgb2YgY2hhbm5lbHM6ICR7Y2hhbm5lbHN9YCk7XG4gICAgfVxuICAgIHRoaXMuaW50ZXJuYWxGb3JtYXQgPSBnbC5SR0JBO1xuICAgIHRoaXMuZm9ybWF0ID0gZ2wuUkdCQTtcbiAgICB0aGlzLmNoYW5uZWxTaXplID0gY2hhbm5lbHM7XG4gICAgdGhpcy50ZXh0dXJlVHlwZSA9IHRleHR1cmVUeXBlIHx8IGdsLkZMT0FUO1xuICB9XG4gIGVuY29kZShzcmM6IEZsb2F0MzJBcnJheSwgdGV4dHVyZVNpemU6IG51bWJlcik6IEVuY29kZXIuRGF0YUFycmF5VHlwZSB7XG4gICAgbGV0IGRlc3QgPSBzcmM7XG4gICAgaWYgKHRoaXMuY2hhbm5lbFNpemUgPT09IDEpIHtcbiAgICAgIExvZ2dlci52ZXJib3NlKCdFbmNvZGVyJywgJ0V4cGxvZGluZyBpbnRvIGEgbGFyZ2VyIGFycmF5Jyk7XG4gICAgICBkZXN0ID0gdGhpcy5hbGxvY2F0ZSh0ZXh0dXJlU2l6ZSkgYXMgRmxvYXQzMkFycmF5O1xuICAgICAgc3JjLmZvckVhY2goKHYsIGkpID0+IGRlc3RbaSAqIDRdID0gdik7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9XG4gIGFsbG9jYXRlKHNpemU6IG51bWJlcik6IEVuY29kZXIuRGF0YUFycmF5VHlwZSB7XG4gICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSAqIDQpO1xuICB9XG4gIGRlY29kZShidWZmZXI6IEVuY29kZXIuRGF0YUFycmF5VHlwZSwgZGF0YVNpemU6IG51bWJlcik6IEZsb2F0MzJBcnJheSB7XG4gICAgaWYgKHRoaXMuY2hhbm5lbFNpemUgPT09IDEpIHtcbiAgICAgIGNvbnN0IGZpbHRlcmVkRGF0YSA9IChidWZmZXIgYXMgRmxvYXQzMkFycmF5KS5maWx0ZXIoKF92YWx1ZSwgaW5kZXgpID0+IGluZGV4ICUgNCA9PT0gMCkuc3ViYXJyYXkoMCwgZGF0YVNpemUpO1xuICAgICAgcmV0dXJuIGZpbHRlcmVkRGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlci5zdWJhcnJheSgwLCBkYXRhU2l6ZSkgYXMgRmxvYXQzMkFycmF5O1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBVaW50OERhdGFFbmNvZGVyIGltcGxlbWVudHMgRGF0YUVuY29kZXIge1xuICBpbnRlcm5hbEZvcm1hdDogbnVtYmVyO1xuICBmb3JtYXQ6IG51bWJlcjtcbiAgdGV4dHVyZVR5cGU6IG51bWJlcjtcbiAgY2hhbm5lbFNpemUgPSA0O1xuICBjb25zdHJ1Y3RvcihnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LCBjaGFubmVscyA9IDEpIHtcbiAgICBpZiAoY2hhbm5lbHMgPT09IDEpIHtcbiAgICAgIHRoaXMuaW50ZXJuYWxGb3JtYXQgPSBnbC5BTFBIQTtcbiAgICAgIHRoaXMuZm9ybWF0ID0gZ2wuQUxQSEE7ICAvLyBub3QgdGVzdGVkXG4gICAgICB0aGlzLnRleHR1cmVUeXBlID0gZ2wuVU5TSUdORURfQllURTtcbiAgICAgIHRoaXMuY2hhbm5lbFNpemUgPSBjaGFubmVscztcbiAgICB9IGVsc2UgaWYgKGNoYW5uZWxzID09PSA0KSB7XG4gICAgICB0aGlzLmludGVybmFsRm9ybWF0ID0gZ2wuUkdCQTtcbiAgICAgIHRoaXMuZm9ybWF0ID0gZ2wuUkdCQTtcbiAgICAgIHRoaXMudGV4dHVyZVR5cGUgPSBnbC5VTlNJR05FRF9CWVRFO1xuICAgICAgdGhpcy5jaGFubmVsU2l6ZSA9IGNoYW5uZWxzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbnVtYmVyIG9mIGNoYW5uZWxzOiAke2NoYW5uZWxzfWApO1xuICAgIH1cbiAgfVxuICBlbmNvZGUoc3JjOiBVaW50OEFycmF5LCBfdGV4dHVyZVNpemU6IG51bWJlcik6IEVuY29kZXIuRGF0YUFycmF5VHlwZSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNyYy5idWZmZXIsIHNyYy5ieXRlT2Zmc2V0LCBzcmMuYnl0ZUxlbmd0aCk7XG4gIH1cbiAgYWxsb2NhdGUoc2l6ZTogbnVtYmVyKTogRW5jb2Rlci5EYXRhQXJyYXlUeXBlIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoc2l6ZSAqIHRoaXMuY2hhbm5lbFNpemUpO1xuICB9XG4gIGRlY29kZShidWZmZXI6IEVuY29kZXIuRGF0YUFycmF5VHlwZSwgZGF0YVNpemU6IG51bWJlcik6IFVpbnQ4QXJyYXkge1xuICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICByZXR1cm4gYnVmZmVyLnN1YmFycmF5KDAsIGRhdGFTaXplKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFycmF5IHR5cGU6ICR7YnVmZmVyLmNvbnN0cnVjdG9yfWApO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcblxuaW1wb3J0IHtUZXh0dXJlTGF5b3V0U3RyYXRlZ3ksIFdpZHRoSGVpZ2h0UHJlZnN9IGZyb20gJy4vdGV4dHVyZS1sYXlvdXQtc3RyYXRlZ3knO1xuaW1wb3J0IHtUZXh0dXJlTGF5b3V0LCBUZXh0dXJlVHlwZX0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlID1cbiAgICAodGV4dHVyZUxheW91dFN0cmF0ZWd5OiBUZXh0dXJlTGF5b3V0U3RyYXRlZ3ksIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlKTogVGV4dHVyZUxheW91dCA9PiB7XG4gICAgICBjb25zdCBjaGFubmVsID0gKHRleHR1cmVUeXBlID09PSBUZXh0dXJlVHlwZS51bnBhY2tlZCB8fCB0ZXh0dXJlVHlwZSA9PT0gVGV4dHVyZVR5cGUudW5wYWNrZWRSZXZlcnNlZCkgPyAxIDogNDtcbiAgICAgIGNvbnN0IGlzUGFja2VkID0gdGV4dHVyZVR5cGUgPT09IFRleHR1cmVUeXBlLnBhY2tlZDtcbiAgICAgIGNvbnN0IHJldmVyc2VXSCA9ICh0ZXh0dXJlVHlwZSA9PT0gVGV4dHVyZVR5cGUudW5wYWNrZWRSZXZlcnNlZCB8fCB0ZXh0dXJlVHlwZSA9PT0gVGV4dHVyZVR5cGUucGFja2VkKTtcbiAgICAgIGNvbnN0IGJyZWFrQXhpcyA9IHRleHR1cmVUeXBlID09PSBUZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uID8gc2hhcGUubGVuZ3RoIC0gMSA6IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IHVucGFja2VkU2hhcGUgPSB0ZXh0dXJlVHlwZSA9PT0gVGV4dHVyZVR5cGUucGFja2VkTGFzdERpbWVuc2lvbiA/XG4gICAgICAgICAgc2hhcGUubWFwKChkLCBpKSA9PiBpID09PSBzaGFwZS5sZW5ndGggLSAxID8gZCAqIDQgOiBkKSA6XG4gICAgICAgICAgdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUoXG4gICAgICAgICAgdGV4dHVyZUxheW91dFN0cmF0ZWd5LCBzaGFwZSwgY2hhbm5lbCwgdW5wYWNrZWRTaGFwZSwge2lzUGFja2VkLCByZXZlcnNlV0gsIGJyZWFrQXhpc30pO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQgPVxuICAgICh0ZXh0dXJlTGF5b3V0U3RyYXRlZ3k6IFRleHR1cmVMYXlvdXRTdHJhdGVneSwgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUpOlxuICAgICAgICBbbnVtYmVyLCBudW1iZXJdID0+IHtcbiAgICAgICAgICBjb25zdCBsYXlvdXQgPSBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKHRleHR1cmVMYXlvdXRTdHJhdGVneSwgc2hhcGUsIHRleHR1cmVUeXBlKTtcbiAgICAgICAgICByZXR1cm4gW2xheW91dC53aWR0aCwgbGF5b3V0LmhlaWdodF07XG4gICAgICAgIH07XG5cbi8qKlxuICogQ3JlYXRlIGEgVGV4dHVyZUxheW91dCBvYmplY3QgZnJvbSBzaGFwZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVRleHR1cmVMYXlvdXRGcm9tU2hhcGUgPVxuICAgICh0ZXh0dXJlTGF5b3V0U3RyYXRlZ3k6IFRleHR1cmVMYXlvdXRTdHJhdGVneSwgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBjaGFubmVsczogMXw0ID0gMSxcbiAgICAgdW5wYWNrZWRTaGFwZT86IHJlYWRvbmx5IG51bWJlcltdLCBwcmVmcz86IFdpZHRoSGVpZ2h0UHJlZnMpOiBUZXh0dXJlTGF5b3V0ID0+IHtcbiAgICAgIGNvbnN0IGlzUGFja2VkID0gISEocHJlZnMgJiYgcHJlZnMuaXNQYWNrZWQpO1xuICAgICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gdGV4dHVyZUxheW91dFN0cmF0ZWd5LmNvbXB1dGVUZXh0dXJlV0goaXNQYWNrZWQgPyB1bnBhY2tlZFNoYXBlIHx8IHNoYXBlIDogc2hhcGUsIHByZWZzKTtcbiAgICAgIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gICAgICBsZXQgaW5mZXJyZWREaW1zID0gc2hhcGUuc2xpY2UoMCk7XG4gICAgICBpZiAocmFuayA9PT0gMCkge1xuICAgICAgICBpbmZlcnJlZERpbXMgPSBbMV07XG4gICAgICB9XG4gICAgICBpZiAoY2hhbm5lbHMgPT09IDEpIHtcbiAgICAgICAgLy8gdW5wYWNrZWRTaGFwZSB3aWxsIHRha2UgYHNoYXBlYCBhbmQgbm90IGBpbmZlcnJlZERpbXNgIHNvIGFzIHRvIGNyZWF0ZSBhIHNjYWxhciBUZW5zb3IgaWYgbmVlZCBiZVxuICAgICAgICB1bnBhY2tlZFNoYXBlID0gc2hhcGU7XG4gICAgICB9IGVsc2UgaWYgKGlzUGFja2VkKSB7XG4gICAgICAgIGlmIChjaGFubmVscyAhPT0gNCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYSBwYWNrZWQgdGV4dHVyZSBtdXN0IGJlIDQtY2hhbm5lbCcpO1xuICAgICAgICB9XG4gICAgICAgIHVucGFja2VkU2hhcGUgPSBzaGFwZTtcbiAgICAgICAgaWYgKHJhbmsgPiAwKSB7XG4gICAgICAgICAgaW5mZXJyZWREaW1zW3JhbmsgLSAxXSA9IE1hdGguY2VpbChpbmZlcnJlZERpbXNbcmFuayAtIDFdIC8gMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmsgPiAxKSB7XG4gICAgICAgICAgaW5mZXJyZWREaW1zW3JhbmsgLSAyXSA9IE1hdGguY2VpbChpbmZlcnJlZERpbXNbcmFuayAtIDJdIC8gMik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXVucGFja2VkU2hhcGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnBhY2tlZCBzaGFwZSBpcyBuZWVkZWQgd2hlbiB1c2luZyBjaGFubmVscyA+IDEnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGNoYW5uZWxzLFxuICAgICAgICBpc1BhY2tlZCxcbiAgICAgICAgc2hhcGU6IGluZmVycmVkRGltcyxcbiAgICAgICAgc3RyaWRlczogU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGluZmVycmVkRGltcyksXG4gICAgICAgIHVucGFja2VkU2hhcGUsXG4gICAgICAgIHJldmVyc2VkV0g6IChwcmVmcyAmJiBwcmVmcy5yZXZlcnNlV0gpXG4gICAgICB9O1xuICAgIH07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7SW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vLi4vYmFja2VuZCc7XG5pbXBvcnQge0xvZ2dlcn0gZnJvbSAnLi4vLi4vaW5zdHJ1bWVudCc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vdGVuc29yJztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcblxuaW1wb3J0IHtjcmVhdGVQYWNrUHJvZ3JhbUluZm9Mb2FkZXJ9IGZyb20gJy4vb3BzL3BhY2snO1xuaW1wb3J0IHtjcmVhdGVQYWNrZWRSZXNoYXBlM0RQcm9ncmFtSW5mb0xvYWRlciwgaXNSZXNoYXBlQ2hlYXAsIHByb2Nlc3NEaW1zM0R9IGZyb20gJy4vb3BzL3Jlc2hhcGUtcGFja2VkJztcbmltcG9ydCB7ZW5jb2RlQXNVaW50OH0gZnJvbSAnLi9vcHMvdWludDgtZW5jb2RlJztcbmltcG9ydCB7Y3JlYXRlVW5wYWNrUHJvZ3JhbUluZm9Mb2FkZXJ9IGZyb20gJy4vb3BzL3VucGFjayc7XG5pbXBvcnQge1dlYkdMU2Vzc2lvbkhhbmRsZXJ9IGZyb20gJy4vc2Vzc2lvbi1oYW5kbGVyJztcbmltcG9ydCB7RW5jb2RlclVzYWdlfSBmcm9tICcuL3RleHR1cmUtZGF0YS1lbmNvZGVyJztcbmltcG9ydCB7Y2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0LCBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlLCBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlfSBmcm9tICcuL3RleHR1cmUtbGF5b3V0JztcbmltcG9ydCB7QXJ0aWZhY3QsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgVGV4dHVyZURhdGEsIFRleHR1cmVMYXlvdXQsIFRleHR1cmVUeXBlfSBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgZ2V0UHJvZ3JhbUluZm9VbmlxdWVLZXkgPVxuICAgIChwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm98UHJvZ3JhbUluZm9Mb2FkZXIsIGlucHV0VGV4dHVyZURhdGFzOiBUZXh0dXJlRGF0YVtdKTogc3RyaW5nID0+IHtcbiAgICAgIGNvbnN0IGlucHV0cyA9XG4gICAgICAgICAgaW5wdXRUZXh0dXJlRGF0YXMubWFwKHRleHR1cmUgPT4gYCR7dGV4dHVyZS51bnBhY2tlZFNoYXBlLmpvaW4oJywnKX07JHt0ZXh0dXJlLndpZHRofXgke3RleHR1cmUuaGVpZ2h0fWApXG4gICAgICAgICAgICAgIC5qb2luKCdfJyk7XG4gICAgICBsZXQga2V5ID0gcHJvZ3JhbUluZm8ubmFtZTtcbiAgICAgIGlmIChwcm9ncmFtSW5mby5jYWNoZUhpbnQpIHtcbiAgICAgICAga2V5ICs9ICdbJyArIHByb2dyYW1JbmZvLmNhY2hlSGludCArICddJztcbiAgICAgIH1cbiAgICAgIGtleSArPSAnOicgKyBpbnB1dHM7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH07XG5cbmV4cG9ydCBjbGFzcyBXZWJHTEluZmVyZW5jZUhhbmRsZXIgaW1wbGVtZW50cyBJbmZlcmVuY2VIYW5kbGVyIHtcbiAgcHJpdmF0ZSBwYWNrZWRUZXh0dXJlRGF0YUNhY2hlOiBNYXA8VGVuc29yLklkLCBUZXh0dXJlRGF0YT47XG4gIHByaXZhdGUgdW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlOiBNYXA8VGVuc29yLklkLCBUZXh0dXJlRGF0YT47XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBzZXNzaW9uOiBXZWJHTFNlc3Npb25IYW5kbGVyKSB7XG4gICAgdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIFt3aWR0aCwgaGVpZ2h0XVxuICAgKi9cbiAgY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlKTogW251bWJlciwgbnVtYmVyXSB7XG4gICAgcmV0dXJuIGNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodCh0aGlzLnNlc3Npb24ubGF5b3V0U3RyYXRlZ3ksIHNoYXBlLCB0ZXh0dXJlVHlwZSk7XG4gIH1cblxuICBleGVjdXRlUHJvZ3JhbShwcm9ncmFtOiBQcm9ncmFtSW5mb3xQcm9ncmFtSW5mb0xvYWRlciwgaW5wdXRzOiByZWFkb25seSBUZW5zb3JbXSk6IFRleHR1cmVEYXRhIHtcbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA8IHByb2dyYW0uaW5wdXROYW1lcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgc2l6ZSBtdXN0bid0IGJlIGxlc3MgdGhhbiAke3Byb2dyYW0uaW5wdXROYW1lcy5sZW5ndGh9LmApO1xuICAgIH1cbiAgICBpZiAocHJvZ3JhbS5pbnB1dE5hbWVzLmxlbmd0aCAhPT0gcHJvZ3JhbS5pbnB1dFR5cGVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBuYW1lcyBzaXplIGRvZXMgbm90IG1hdGNoIGlucHV0IHR5cGVzJyk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIHRleHR1cmUgaW5mbyBmb3IgaW5wdXRcbiAgICBjb25zdCBpbnB1dFRleHR1cmVEYXRhczogVGV4dHVyZURhdGFbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvZ3JhbS5pbnB1dE5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpbnB1dFRleHR1cmVEYXRhc1tpXSA9IHRoaXMuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dHNbaV0sIHByb2dyYW0uaW5wdXRUeXBlc1tpXSk7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5ID0gZ2V0UHJvZ3JhbUluZm9VbmlxdWVLZXkocHJvZ3JhbSwgaW5wdXRUZXh0dXJlRGF0YXMpO1xuICAgIGxldCBhcnRpZmFjdCA9IHRoaXMuc2Vzc2lvbi5wcm9ncmFtTWFuYWdlci5nZXRBcnRpZmFjdChrZXkpO1xuICAgIGNvbnN0IHByb2dyYW1JbmZvID0gYXJ0aWZhY3QgP1xuICAgICAgICBhcnRpZmFjdC5wcm9ncmFtSW5mbyA6XG4gICAgICAgICh0eXBlb2YgKHByb2dyYW0gYXMgUHJvZ3JhbUluZm9Mb2FkZXIpLmdldCA9PT0gJ2Z1bmN0aW9uJyA/IChwcm9ncmFtIGFzIFByb2dyYW1JbmZvTG9hZGVyKS5nZXQoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwcm9ncmFtIGFzIFByb2dyYW1JbmZvKSk7XG5cbiAgICAvLyBjcmVhdGUgdGV4dHVyZSBpbmZvIGZvciBvdXRwdXRcbiAgICBjb25zdCBvdXRwdXRUZXh0dXJlTGF5b3V0ID0gY3JlYXRlVGV4dHVyZUxheW91dEZyb21UZXh0dXJlVHlwZShcbiAgICAgICAgdGhpcy5zZXNzaW9uLmxheW91dFN0cmF0ZWd5LCBwcm9ncmFtSW5mby5vdXRwdXQuZGltcywgcHJvZ3JhbUluZm8ub3V0cHV0LnRleHR1cmVUeXBlKTtcbiAgICBjb25zdCBvdXRwdXRUZXh0dXJlRGF0YSA9IHRoaXMuY3JlYXRlVGV4dHVyZURhdGEob3V0cHV0VGV4dHVyZUxheW91dCwgcHJvZ3JhbUluZm8ub3V0cHV0LnR5cGUpO1xuXG4gICAgaWYgKCFhcnRpZmFjdCkge1xuICAgICAgYXJ0aWZhY3QgPSB0aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuYnVpbGQocHJvZ3JhbUluZm8sIGlucHV0VGV4dHVyZURhdGFzLCBvdXRwdXRUZXh0dXJlRGF0YSk7XG4gICAgICB0aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIuc2V0QXJ0aWZhY3Qoa2V5LCBhcnRpZmFjdCk7XG4gICAgfVxuXG4gICAgdGhpcy5ydW5Qcm9ncmFtKGFydGlmYWN0LCBpbnB1dFRleHR1cmVEYXRhcywgb3V0cHV0VGV4dHVyZURhdGEpO1xuICAgIHJldHVybiBvdXRwdXRUZXh0dXJlRGF0YTtcbiAgfVxuXG4gIHJ1bihwcm9ncmFtOiBQcm9ncmFtSW5mb0xvYWRlciwgaW5wdXRzOiByZWFkb25seSBUZW5zb3JbXSk6IFRlbnNvciB7XG4gICAgY29uc3Qgb3V0cHV0VGV4dHVyZURhdGEgPSB0aGlzLmV4ZWN1dGVQcm9ncmFtKHByb2dyYW0sIGlucHV0cyk7XG4gICAgcmV0dXJuIG91dHB1dFRleHR1cmVEYXRhLnRlbnNvcjtcbiAgfVxuXG4gIHByaXZhdGUgcnVuUHJvZ3JhbShhcnRpZmFjdDogQXJ0aWZhY3QsIGlucHV0czogVGV4dHVyZURhdGFbXSwgb3V0cHV0OiBUZXh0dXJlRGF0YSk6IHZvaWQge1xuICAgIC8vIGlucHV0IHNob3VsZCBtYXRjaFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoISFpbnB1dHNbaV0uaXNQYWNrZWQgIT09IChhcnRpZmFjdC5wcm9ncmFtSW5mby5pbnB1dFR5cGVzW2ldID09PSBUZXh0dXJlVHlwZS5wYWNrZWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5wdXRbJHtpfV0gcHJvcGVydHkgcGFja2VkIGluY29uc2lzdGVudGApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG91dHB1dCBzaG91bGQgbWF0Y2hcbiAgICBpZiAoISFvdXRwdXQuaXNQYWNrZWQgIT09IChhcnRpZmFjdC5wcm9ncmFtSW5mby5vdXRwdXQudGV4dHVyZVR5cGUgPT09IFRleHR1cmVUeXBlLnBhY2tlZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0IHByb3BlcnR5IHBhY2tlZCBpbmNvbnNpc3RlbnQnKTtcbiAgICB9XG5cbiAgICB0aGlzLnNlc3Npb24ucHJvZ3JhbU1hbmFnZXIucnVuKGFydGlmYWN0LCBpbnB1dHMsIG91dHB1dCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgVGV4dHVyZURhdGEgb2JqZWN0IGZyb20gYSB0ZW5zb3IuXG4gICAqIFVzYWdlID0gRW5jb2RlclVzYWdlLlVwbG9hZE9ubHkuXG4gICAqIElmIGEgcmVsYXRlZCB0ZXh0dXJlIGRhdGEgaXMgZm91bmQgaW4gY2FjaGUsIHJldHVybnMgaXQ7XG4gICAqIE90aGVyd2lzZTpcbiAgICogICBDcmVhdGVzIGEgbmV3IHRleHR1cmUgbGF5b3V0IGlmIG5vdCBwcm92aWRlZDtcbiAgICogICBDcmVhdGVzIFdlYkdMVGV4dHVyZSB3aXRoIHRoZSBsYXlvdXQ7XG4gICAqICAgVXBsb2FkIHRlbnNvciBkYXRhIHRvIHRoZSB0ZXh0dXJlO1xuICAgKiAgIENyZWF0ZXMgYSB0ZXh0dXJlIGRhdGEgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gdGVuc29yLlxuICAgKiBAcGFyYW0gdGVuc29yIHRoZSB0ZW5zb3Igd2l0aCBkYXRhIHRvIHVwbG9hZFxuICAgKi9cbiAgcHJpdmF0ZSBnZXRPckNyZWF0ZVRleHR1cmVEYXRhKHRlbnNvcjogVGVuc29yLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUpIHtcbiAgICBsZXQgdGQgPSB0aGlzLmdldFRleHR1cmVEYXRhKHRlbnNvci5kYXRhSWQsIHRleHR1cmVUeXBlID09PSBUZXh0dXJlVHlwZS5wYWNrZWQpO1xuXG4gICAgaWYgKCF0ZCkge1xuICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSB0ZXh0dXJlIGRhdGEgaW4gZGlmZmVyZW50IHR5cGVcbiAgICAgIHRkID0gdGhpcy5nZXRUZXh0dXJlRGF0YSh0ZW5zb3IuZGF0YUlkLCB0ZXh0dXJlVHlwZSAhPT0gVGV4dHVyZVR5cGUucGFja2VkKTtcbiAgICAgIGlmICh0ZCkge1xuICAgICAgICBpZiAodGV4dHVyZVR5cGUgPT09IFRleHR1cmVUeXBlLnBhY2tlZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhY2sodGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnVucGFjayh0ZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRkKSB7XG4gICAgICBjb25zdCBsYXlvdXQgPSBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKHRoaXMuc2Vzc2lvbi5sYXlvdXRTdHJhdGVneSwgdGVuc29yLmRpbXMsIHRleHR1cmVUeXBlKTtcblxuICAgICAgaWYgKHRleHR1cmVUeXBlID09PSBUZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uKSB7XG4gICAgICAgIGNvbnN0IGdyb3VwID0gMTtcbiAgICAgICAgY29uc3QgY2hhbm5lbHMgPSA0O1xuICAgICAgICBjb25zdCBzaGFwZSA9IHRlbnNvci5kaW1zO1xuICAgICAgICBpZiAoc2hhcGUubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgLy8gcHJlLXByb2Nlc3NpbmcgZm9yIGtlcm5lbCBkYXRhIG9mIENvbnYuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBUT0RPOiBjdXJyZW50bHkgdGhpcyBpcyBhIGhhY2tpbmcgdG8gb3ZlcndyaXRlIENvbnYncyB3ZWlnaHQuIFRoZSBjb3JyZWN0IHdheSB0byBkbyB0aGlzIHNob3VsZCBiZTpcbiAgICAgICAgICAvLyAxLiBpbXBsZW1lbnQgdGV4dHVyZSBiYXNlZCBjb25zdC1mb2xkaW5nXG4gICAgICAgICAgLy8gMi4gY3JlYXRlIGEgV2ViR0wgcHJvZ3JhbSBcInByZXByb2Nlc3NDb252V2VpZ2h0XCIgdG8gZG8gdGhlIHNhbWUgd29yayBhcyBiZWxvd1xuICAgICAgICAgIC8vIDMuIHJ1biB0aGUgcHJvZ3JhbSBiZWZvcmUgZG90UHJvZHVjdC5cbiAgICAgICAgICAvL1xuICAgICAgICAgIGNvbnN0IGFkanVzdGVkS2VybmVsU2hhcGUgPSBbc2hhcGVbMF0sIE1hdGguY2VpbCgoc2hhcGVbMV0gKiBzaGFwZVsyXSAqIHNoYXBlWzNdKSAvIGNoYW5uZWxzKV07XG4gICAgICAgICAgY29uc3QgYWRqdXN0ZWRMYXlvdXQgPVxuICAgICAgICAgICAgICBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVRleHR1cmVUeXBlKHRoaXMuc2Vzc2lvbi5sYXlvdXRTdHJhdGVneSwgYWRqdXN0ZWRLZXJuZWxTaGFwZSwgdGV4dHVyZVR5cGUpO1xuICAgICAgICAgIGxldCBidWZmZXIgPSB0ZW5zb3IubnVtYmVyRGF0YTtcbiAgICAgICAgICBpZiAoc2hhcGVbMV0gKiBzaGFwZVsyXSAqIHNoYXBlWzNdICUgY2hhbm5lbHMgIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG51bUZlYXR1cmVNYXBzID0gc2hhcGVbMF07XG4gICAgICAgICAgICBjb25zdCBvbGRSb3dTaXplID0gc2hhcGVbMV0gKiBzaGFwZVsyXSAqIHNoYXBlWzNdO1xuICAgICAgICAgICAgY29uc3QgbmV3Um93U2l6ZSA9IE1hdGguY2VpbChvbGRSb3dTaXplICogZ3JvdXAgLyBjaGFubmVscykgKiBjaGFubmVscztcbiAgICAgICAgICAgIGNvbnN0IG5ld1NpemUgPSBudW1GZWF0dXJlTWFwcyAqIG5ld1Jvd1NpemU7XG4gICAgICAgICAgICBidWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KG5ld1NpemUpO1xuICAgICAgICAgICAgZm9yIChsZXQgZiA9IDA7IGYgPCBudW1GZWF0dXJlTWFwczsgKytmKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG9sZE9mZnNldCA9IGYgKiBvbGRSb3dTaXplO1xuICAgICAgICAgICAgICBjb25zdCBuZXdPZmZzZXQgPSBmICogbmV3Um93U2l6ZSArIGYgJSBncm91cCAqIG9sZFJvd1NpemU7XG4gICAgICAgICAgICAgIGJ1ZmZlci5zZXQodGVuc29yLm51bWJlckRhdGEuc3ViYXJyYXkob2xkT2Zmc2V0LCBvbGRPZmZzZXQgKyBvbGRSb3dTaXplKSwgbmV3T2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVGV4dHVyZURhdGEoYWRqdXN0ZWRMYXlvdXQsIHRlbnNvci50eXBlLCBidWZmZXIsIHRlbnNvciwgRW5jb2RlclVzYWdlLlVwbG9hZE9ubHkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0dXJlVHlwZSA9PT0gVGV4dHVyZVR5cGUucGFja2VkKSB7XG4gICAgICAgIGNvbnN0IHVucGFja2VkVGV4dHVyZUxheW91dCA9XG4gICAgICAgICAgICBjcmVhdGVUZXh0dXJlTGF5b3V0RnJvbVNoYXBlKHRoaXMuc2Vzc2lvbi5sYXlvdXRTdHJhdGVneSwgdGVuc29yLmRpbXMsIDEsIFtdLCB7cmV2ZXJzZVdIOiB0cnVlfSk7XG4gICAgICAgIGNvbnN0IHVucGFja2VkVGV4dHVyZURhdGEgPSB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhKFxuICAgICAgICAgICAgdW5wYWNrZWRUZXh0dXJlTGF5b3V0LCB0ZW5zb3IudHlwZSwgdGVuc29yLm51bWJlckRhdGEsIHRlbnNvciwgRW5jb2RlclVzYWdlLlVwbG9hZE9ubHkpO1xuICAgICAgICB0ZCA9IHRoaXMucGFjayh1bnBhY2tlZFRleHR1cmVEYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRkID0gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YShsYXlvdXQsIHRlbnNvci50eXBlLCB0ZW5zb3IubnVtYmVyRGF0YSwgdGVuc29yLCBFbmNvZGVyVXNhZ2UuVXBsb2FkT25seSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBUZXh0dXJlRGF0YSBvYmplY3QgdXNpbmcgdGhlIGdpdmVuIGRhdGEgYW5kIGJpbmQgdG8gdGhlIGdpdmVuIHRlbnNvci5cbiAgICogVXNhZ2UgPSBFbmNvZGVyVXNhZ2UuVXBsb2FkT25seS5cbiAgICogTk9URTogdGhpcyBmdW5jdGlvbiBpcyBhIGhhY2sgZm9yIENvbnYgaW1wbGVtZW50YXRpb24uIHNob3VsZCByZW1vdmUgdGhpcyBmdW5jdGlvbiwgYWZ0ZXIgcmV3cml0aW5nIENvbnZcbiAgICogaW1wbGVtZW50YXRpb24gYnkgR3JhcGguVHJhbnNmb3JtZXJcbiAgICogQHBhcmFtIGRhdGFUeXBlIHRoZSB0ZW5zb3IgZGF0YSB0eXBlXG4gICAqIEBwYXJhbSBkYXRhIHRoZSBhY3R1YWwgZGF0YSB0byB1cGxvYWRcbiAgICogQHBhcmFtIHRlbnNvciB0aGUgdGVuc29yIHRvIGJpbmQuIHRlbnNvcidzIGRhdGEgaXMgaWdub3JlZC5cbiAgICovXG4gIGNyZWF0ZVRleHR1cmVEYXRhRnJvbUxheW91dEJpbmRUZW5zb3IoXG4gICAgICBsYXlvdXQ6IFRleHR1cmVMYXlvdXQsIGRhdGFUeXBlOiBUZW5zb3IuRGF0YVR5cGUsIGRhdGE6IFRlbnNvci5OdW1iZXJUeXBlLCB0ZW5zb3I6IFRlbnNvcik6IFRleHR1cmVEYXRhIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YShsYXlvdXQsIGRhdGFUeXBlLCBkYXRhLCB0ZW5zb3IsIEVuY29kZXJVc2FnZS5VcGxvYWRPbmx5KTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlVGV4dHVyZURhdGEoXG4gICAgICBsYXlvdXQ6IFRleHR1cmVMYXlvdXQsIGRhdGFUeXBlOiBUZW5zb3IuRGF0YVR5cGUsIGRhdGE/OiBUZW5zb3IuTnVtYmVyVHlwZSwgdGVuc29yPzogVGVuc29yLFxuICAgICAgdXNhZ2U/OiBFbmNvZGVyVXNhZ2UpOiBUZXh0dXJlRGF0YSB7XG4gICAgTG9nZ2VyLnZlcmJvc2UoJ0luZmVyZW5jZUhhbmRsZXInLCBgQ3JlYXRpbmcgVGV4dHVyZURhdGE6IGxheW91dDpbJHtKU09OLnN0cmluZ2lmeShsYXlvdXQpfV1gKTtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLmNyZWF0ZVRleHR1cmVGcm9tTGF5b3V0KGRhdGFUeXBlLCBsYXlvdXQsIGRhdGEsIHVzYWdlKTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKGxheW91dCwgZGF0YVR5cGUsIHRleHR1cmUsIHRlbnNvcik7XG4gIH1cblxuICByZXNoYXBlVW5wYWNrZWQoaW5wdXQ6IFRlbnNvciwgcmVzaGFwZWREaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvciB7XG4gICAgY29uc3QgaW5wdXRURCA9IHRoaXMuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dCwgVGV4dHVyZVR5cGUudW5wYWNrZWQpO1xuICAgIGNvbnN0IG5ld1RleHR1cmVMYXlvdXQ6IFRleHR1cmVMYXlvdXQgPSB7XG4gICAgICBjaGFubmVsczogaW5wdXRURC5jaGFubmVscyxcbiAgICAgIGhlaWdodDogaW5wdXRURC5oZWlnaHQsXG4gICAgICB3aWR0aDogaW5wdXRURC53aWR0aCxcbiAgICAgIC8vIGhhbmRsZSByZXNoYXBpbmcgaW50byBzY2FsYXIgVGVuc29yc1xuICAgICAgc2hhcGU6IHJlc2hhcGVkRGltcy5sZW5ndGggIT09IDAgPyByZXNoYXBlZERpbXMgOiBbMV0sXG4gICAgICBzdHJpZGVzOiBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMocmVzaGFwZWREaW1zKSxcbiAgICAgIHVucGFja2VkU2hhcGU6IHJlc2hhcGVkRGltcyxcbiAgICB9O1xuICAgIGNvbnN0IG5ld1RleHR1cmVEYXRhID0gdGhpcy5jcmVhdGVUZXh0dXJlRGF0YUZyb21UZXh0dXJlKG5ld1RleHR1cmVMYXlvdXQsIGlucHV0LnR5cGUsIGlucHV0VEQudGV4dHVyZSk7XG4gICAgcmV0dXJuIG5ld1RleHR1cmVEYXRhLnRlbnNvcjtcbiAgfVxuXG4gIHJlc2hhcGVQYWNrZWQoaW5wdXQ6IFRlbnNvciwgcmVzaGFwZWREaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvciB7XG4gICAgY29uc3QgaW5wdXRURCA9IHRoaXMuZ2V0T3JDcmVhdGVUZXh0dXJlRGF0YShpbnB1dCwgVGV4dHVyZVR5cGUucGFja2VkKTtcblxuICAgIC8vIGNoZWNrIGlmIHRoZSByZXNoYXBlIGlzICdjaGVhcCdcbiAgICBpZiAoaXNSZXNoYXBlQ2hlYXAoaW5wdXQuZGltcywgcmVzaGFwZWREaW1zKSkge1xuICAgICAgY29uc3QgbmV3VGV4dHVyZUxheW91dDogVGV4dHVyZUxheW91dCA9IHtcbiAgICAgICAgY2hhbm5lbHM6IGlucHV0VEQuY2hhbm5lbHMsXG4gICAgICAgIGhlaWdodDogaW5wdXRURC5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBpbnB1dFRELndpZHRoLFxuICAgICAgICAvLyBoYW5kbGUgcmVzaGFwaW5nIGludG8gc2NhbGFyIFRlbnNvcnNcbiAgICAgICAgc2hhcGU6IHJlc2hhcGVkRGltcy5sZW5ndGggIT09IDAgPyByZXNoYXBlZERpbXMgOiBbMV0sXG4gICAgICAgIHN0cmlkZXM6IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhyZXNoYXBlZERpbXMpLFxuICAgICAgICB1bnBhY2tlZFNoYXBlOiByZXNoYXBlZERpbXMsXG4gICAgICAgIGlzUGFja2VkOiB0cnVlXG4gICAgICB9O1xuICAgICAgY29uc3QgbmV3VGV4dHVyZURhdGEgPSB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhRnJvbVRleHR1cmUobmV3VGV4dHVyZUxheW91dCwgaW5wdXQudHlwZSwgaW5wdXRURC50ZXh0dXJlKTtcbiAgICAgIHJldHVybiBuZXdUZXh0dXJlRGF0YS50ZW5zb3I7XG4gICAgfVxuXG4gICAgY29uc3Qgc3F1ZWV6ZWRJbnB1dFNoYXBlID0gcHJvY2Vzc0RpbXMzRChpbnB1dC5kaW1zKTtcbiAgICBjb25zdCBzcXVlZXplZE91dHB1dFNoYXBlID0gcHJvY2Vzc0RpbXMzRChyZXNoYXBlZERpbXMpO1xuXG4gICAgY29uc3Qgc3F1ZWV6ZWRJbnB1dFRlbnNvciA9IHRoaXMucmVzaGFwZVBhY2tlZChpbnB1dCwgc3F1ZWV6ZWRJbnB1dFNoYXBlKTtcbiAgICBjb25zdCBzcXVlZXplZE91dHB1dFRlbnNvciA9IHRoaXMucnVuKFxuICAgICAgICBjcmVhdGVQYWNrZWRSZXNoYXBlM0RQcm9ncmFtSW5mb0xvYWRlcih0aGlzLCBzcXVlZXplZElucHV0VGVuc29yLCBzcXVlZXplZE91dHB1dFNoYXBlKSwgW3NxdWVlemVkSW5wdXRUZW5zb3JdKTtcbiAgICBjb25zdCBvdXRwdXRUZW5zb3IgPSB0aGlzLnJlc2hhcGVQYWNrZWQoc3F1ZWV6ZWRPdXRwdXRUZW5zb3IsIHJlc2hhcGVkRGltcyk7XG4gICAgcmV0dXJuIG91dHB1dFRlbnNvcjtcbiAgfVxuXG4gIGNhc3QoaW5wdXQ6IFRlbnNvciwgdHlwZTogVGVuc29yLkRhdGFUeXBlKTogVGVuc29yIHtcbiAgICBjb25zdCBpbnB1dFREID0gdGhpcy5nZXRPckNyZWF0ZVRleHR1cmVEYXRhKGlucHV0LCBUZXh0dXJlVHlwZS51bnBhY2tlZCk7XG4gICAgY29uc3QgbmV3VGV4dHVyZURhdGEgPSB0aGlzLmNyZWF0ZVRleHR1cmVEYXRhRnJvbVRleHR1cmUoaW5wdXRURCBhcyBUZXh0dXJlTGF5b3V0LCB0eXBlLCBpbnB1dFRELnRleHR1cmUpO1xuICAgIHJldHVybiBuZXdUZXh0dXJlRGF0YS50ZW5zb3I7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZVRleHR1cmVEYXRhRnJvbVRleHR1cmUoXG4gICAgICBsYXlvdXQ6IFRleHR1cmVMYXlvdXQsIGRhdGFUeXBlOiBUZW5zb3IuRGF0YVR5cGUsIHRleHR1cmU6IFdlYkdMVGV4dHVyZSwgdGVuc29yPzogVGVuc29yLCB0ZW5zb3JJZD86IFRlbnNvci5JZCkge1xuICAgIGNvbnN0IHRleHR1cmVEYXRhOiBUZXh0dXJlRGF0YSA9IHtcbiAgICAgIC4uLmxheW91dCxcbiAgICAgIHRlbnNvcjogdGVuc29yIHx8XG4gICAgICAgICAgbmV3IFRlbnNvcihcbiAgICAgICAgICAgICAgICAgIGxheW91dC51bnBhY2tlZFNoYXBlLCBkYXRhVHlwZSwgKF9pZDogVGVuc29yLklkKSA9PiB0aGlzLnJlYWRUZXh0dXJlKHRleHR1cmVEYXRhKSxcbiAgICAgICAgICAgICAgICAgIGFzeW5jIChfaWQ6IFRlbnNvci5JZCkgPT4gdGhpcy5yZWFkVGV4dHVyZUFzeW5jKHRleHR1cmVEYXRhKSwgdW5kZWZpbmVkLCB0ZW5zb3JJZCksXG4gICAgICB0ZXh0dXJlXG4gICAgfTtcbiAgICB0aGlzLnNldFRleHR1cmVEYXRhKHRleHR1cmVEYXRhLnRlbnNvci5kYXRhSWQsIHRleHR1cmVEYXRhLCBsYXlvdXQuaXNQYWNrZWQpO1xuICAgIHJldHVybiB0ZXh0dXJlRGF0YTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0VGV4dHVyZURhdGEodGVuc29ySWQ6IFRlbnNvci5JZCwgaXNQYWNrZWQgPSBmYWxzZSk6IFRleHR1cmVEYXRhfHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5pc0luaXRpYWxpemVyKHRlbnNvcklkKSA/IHRoaXMuc2Vzc2lvbi5nZXRUZXh0dXJlRGF0YSh0ZW5zb3JJZCwgaXNQYWNrZWQpIDpcbiAgICAgICAgaXNQYWNrZWQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmdldCh0ZW5zb3JJZCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZS5nZXQodGVuc29ySWQpO1xuICB9XG4gIHNldFRleHR1cmVEYXRhKHRlbnNvcklkOiBUZW5zb3IuSWQsIHRkOiBUZXh0dXJlRGF0YSwgaXNQYWNrZWQgPSBmYWxzZSk6IHZvaWQge1xuICAgIGlmICh0aGlzLnNlc3Npb24uaXNJbml0aWFsaXplcih0ZW5zb3JJZCkpIHtcbiAgICAgIHRoaXMuc2Vzc2lvbi5zZXRUZXh0dXJlRGF0YSh0ZW5zb3JJZCwgdGQsIGlzUGFja2VkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgKGlzUGFja2VkID8gdGhpcy5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlIDogdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUpLnNldCh0ZW5zb3JJZCwgdGQpO1xuICAgIH1cbiAgfVxuICBpc1RleHR1cmVMYXlvdXRDYWNoZWQodGVuc29yOiBUZW5zb3IsIGlzUGFja2VkID0gZmFsc2UpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLmdldFRleHR1cmVEYXRhKHRlbnNvci5kYXRhSWQsIGlzUGFja2VkKTtcbiAgfVxuXG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLmNsZWFyQWN0aXZlVGV4dHVyZXMoKTtcbiAgICB0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZm9yRWFjaCh0ZCA9PiB0aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodGQpKTtcbiAgICB0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZm9yRWFjaCh0ZCA9PiB0aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodGQpKTtcbiAgICB0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZSA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIHJlYWRUZXh0dXJlKHRleHR1cmVEYXRhOiBUZXh0dXJlRGF0YSk6IFRlbnNvci5OdW1iZXJUeXBlIHtcbiAgICBpZiAodGV4dHVyZURhdGEuaXNQYWNrZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUZXh0dXJlKHRoaXMudW5wYWNrKHRleHR1cmVEYXRhKSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LmlzRmxvYXQzMkRvd25sb2FkU3VwcG9ydGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXNzaW9uLnRleHR1cmVNYW5hZ2VyLnJlYWRVaW50OFRleHR1cmVBc0Zsb2F0KGVuY29kZUFzVWludDgodGhpcywgdGV4dHVyZURhdGEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWFkVGV4dHVyZSh0ZXh0dXJlRGF0YSwgdGV4dHVyZURhdGEudGVuc29yLnR5cGUsIHRleHR1cmVEYXRhLmNoYW5uZWxzKTtcbiAgfVxuXG4gIGFzeW5jIHJlYWRUZXh0dXJlQXN5bmModGV4dHVyZURhdGE6IFRleHR1cmVEYXRhKTogUHJvbWlzZTxUZW5zb3IuTnVtYmVyVHlwZT4ge1xuICAgIGlmICh0ZXh0dXJlRGF0YS5pc1BhY2tlZCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRleHR1cmVBc3luYyh0aGlzLnVucGFjayh0ZXh0dXJlRGF0YSkpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC5pc0Zsb2F0MzJEb3dubG9hZFN1cHBvcnRlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi50ZXh0dXJlTWFuYWdlci5yZWFkVWludDhUZXh0dXJlQXNGbG9hdChlbmNvZGVBc1VpbnQ4KHRoaXMsIHRleHR1cmVEYXRhKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNlc3Npb24udGV4dHVyZU1hbmFnZXIucmVhZFRleHR1cmVBc3luYyh0ZXh0dXJlRGF0YSwgdGV4dHVyZURhdGEudGVuc29yLnR5cGUsIHRleHR1cmVEYXRhLmNoYW5uZWxzKTtcbiAgfVxuXG4gIHBhY2soaW5wdXQ6IFRleHR1cmVEYXRhKTogVGV4dHVyZURhdGEge1xuICAgIGNvbnN0IG91dHB1dFRleHR1cmVEYXRhID0gdGhpcy5leGVjdXRlUHJvZ3JhbShjcmVhdGVQYWNrUHJvZ3JhbUluZm9Mb2FkZXIodGhpcywgaW5wdXQudGVuc29yKSwgW2lucHV0LnRlbnNvcl0pO1xuICAgIHJldHVybiBvdXRwdXRUZXh0dXJlRGF0YTtcbiAgfVxuXG4gIHVucGFjayhpbnB1dDogVGV4dHVyZURhdGEpOiBUZXh0dXJlRGF0YSB7XG4gICAgY29uc3Qgb3V0cHV0VGV4dHVyZURhdGEgPSB0aGlzLmV4ZWN1dGVQcm9ncmFtKGNyZWF0ZVVucGFja1Byb2dyYW1JbmZvTG9hZGVyKHRoaXMsIGlucHV0LnRlbnNvciksIFtpbnB1dC50ZW5zb3JdKTtcbiAgICByZXR1cm4gb3V0cHV0VGV4dHVyZURhdGE7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuY2xhc3MgQXR0cmlidXRlV2l0aENhY2hlS2V5SW1wbCB7XG4gIGNvbnN0cnVjdG9yKGF0dHJpYnV0ZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGF0dHJpYnV0ZSk7XG4gIH1cblxuICBwcml2YXRlIGtleTogc3RyaW5nO1xuICBwdWJsaWMgZ2V0IGNhY2hlS2V5KCk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLmtleSkge1xuICAgICAgdGhpcy5rZXkgPVxuICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpLnNvcnQoKS5tYXAobmFtZSA9PiBgJHsodGhpcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilbbmFtZV19YCkuam9pbignOycpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5rZXk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBjYWNoZUtleTogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5ID0gPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oYXR0cmlidXRlOiBUKTogVCZBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgPT5cbiAgICBuZXcgQXR0cmlidXRlV2l0aENhY2hlS2V5SW1wbChhdHRyaWJ1dGUpIGFzIHVua25vd24gYXMgVCAmIEF0dHJpYnV0ZVdpdGhDYWNoZUtleTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7R3JhcGh9IGZyb20gJy4uLy4uLy4uL2dyYXBoJztcbmltcG9ydCB7T3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbn0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtnZXRHbHNsfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgVGV4dHVyZVR5cGV9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBCYXRjaE5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgZXBzaWxvbjogbnVtYmVyO1xuICBtb21lbnR1bTogbnVtYmVyO1xuICBzcGF0aWFsOiBudW1iZXI7XG59XG5cbmNvbnN0IGJhdGNoTm9ybWFsaXphdGlvblByb2dyYW1NZXRhZGF0YSA9IHtcbiAgbmFtZTogJ0JhdGNoTm9ybWFsaXphdGlvbicsXG4gIGlucHV0TmFtZXM6IFsnQScsICdTY2FsZScsICdCJywgJ01lYW4nLCAnVmFyaWFuY2UnXSxcbiAgaW5wdXRUeXBlczpcbiAgICAgIFtUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkLCBUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWRdXG59O1xuXG5leHBvcnQgY29uc3QgYmF0Y2hOb3JtYWxpemF0aW9uOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPEJhdGNoTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXM+ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBCYXRjaE5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzKTogVGVuc29yW10gPT4ge1xuICAgICAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLmJhdGNoTm9ybWFsaXphdGlvblByb2dyYW1NZXRhZGF0YSxcbiAgICAgICAgICAgIGNhY2hlSGludDogYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgICAgICAgICAgIGdldDogKCkgPT4gY3JlYXRlQmF0Y2hOb3JtYWxpemF0aW9uUHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhdHRyaWJ1dGVzKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaW5wdXRzKTtcbiAgICAgIHJldHVybiBbb3V0cHV0XTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgcGFyc2VCYXRjaE5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPEJhdGNoTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXM+ID1cbiAgICAobm9kZTogR3JhcGguTm9kZSk6IEJhdGNoTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXMgPT4ge1xuICAgICAgY29uc3QgZXBzaWxvbiA9IG5vZGUuYXR0cmlidXRlcy5nZXRGbG9hdCgnZXBzaWxvbicsIDFlLTUpO1xuICAgICAgY29uc3QgbW9tZW50dW0gPSBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ21vbWVudHVtJywgMC45KTtcbiAgICAgIGNvbnN0IHNwYXRpYWwgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCdzcGF0aWFsJywgMSk7XG4gICAgICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtlcHNpbG9uLCBtb21lbnR1bSwgc3BhdGlhbH0pO1xuICAgIH07XG5cbmNvbnN0IGNyZWF0ZUJhdGNoTm9ybWFsaXphdGlvblByb2dyYW1JbmZvID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBCYXRjaE5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzKTpcbiAgICAgICAgUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICAgICAgICBjb25zdCByYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IFtzY2FsZVdpZHRoLCBzY2FsZUhlaWdodF0gPVxuICAgICAgICAgICAgICBpbmZlcmVuY2VIYW5kbGVyLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChpbnB1dHNbMV0uZGltcywgVGV4dHVyZVR5cGUudW5wYWNrZWQpO1xuICAgICAgICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgZmxvYXQgcHJvY2VzcyhpbnRbJHtyYW5rfV0gaW5kaWNlcykge1xuICAgIHZlYzIgcG9zaXRpb24gPSBvZmZzZXRUb0Nvb3JkcyhpbmRpY2VzWzFdLCAke3NjYWxlV2lkdGh9LCAke3NjYWxlSGVpZ2h0fSk7XG4gICAgZmxvYXQgc2NhbGUgPSBnZXRDb2xvckFzRmxvYXQoJHtnbHNsLnRleHR1cmUyRH0oU2NhbGUsIHBvc2l0aW9uKSk7XG4gICAgZmxvYXQgbWVhbiA9IGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfShNZWFuLCBwb3NpdGlvbikpO1xuICAgIGZsb2F0IHZhcmlhbmNlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7Z2xzbC50ZXh0dXJlMkR9KFZhcmlhbmNlLCBwb3NpdGlvbikpO1xuICAgIGZsb2F0IGIgPSBnZXRDb2xvckFzRmxvYXQoJHtnbHNsLnRleHR1cmUyRH0oQiwgcG9zaXRpb24pKTtcblxuICAgIHJldHVybiBzY2FsZSAqICggKF9BKGluZGljZXMpIC0gbWVhbikgLyBzcXJ0KHZhcmlhbmNlICsgZmxvYXQoJHthdHRyaWJ1dGVzLmVwc2lsb259KSkgKSArIGI7XG4gIH1gO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5iYXRjaE5vcm1hbGl6YXRpb25Qcm9ncmFtTWV0YWRhdGEsXG4gICAgICAgICAgICBvdXRwdXQ6IHtkaW1zOiBpbnB1dHNbMF0uZGltcywgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgICAgICAgICBzaGFkZXJTb3VyY2VcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhdGNoTm9ybWFsaXphdGlvbiByZXF1aXJlcyA1IGlucHV0cy4nKTtcbiAgfVxuXG4gIGNvbnN0IFggPSBpbnB1dHNbMF07XG4gIGNvbnN0IHNjYWxlID0gaW5wdXRzWzFdO1xuICBjb25zdCBCID0gaW5wdXRzWzJdO1xuICBjb25zdCBtZWFuID0gaW5wdXRzWzNdO1xuICBjb25zdCB2YXJfID0gaW5wdXRzWzRdO1xuXG4gIC8vIGlucHV0IHNob3VsZCBhdGxlYXN0IGhhdmUgdGhyZWUgZGltZW5zaW9ucyAtIE4sQyxkaW0xLC4uLixkaW1uXG4gIC8vIG90aGVyIGlucHV0cyBjYW4gaGF2ZSBvbmx5IG9uZSBkaW1lbnNpb25zXG4gIGlmIChYLmRpbXMubGVuZ3RoIDwgMyB8fCBzY2FsZS5kaW1zLmxlbmd0aCAhPT0gMSB8fCBCLmRpbXMubGVuZ3RoICE9PSAxIHx8IG1lYW4uZGltcy5sZW5ndGggIT09IDEgfHxcbiAgICAgIHZhcl8uZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5wdXQgc2hhcGUuJyk7XG4gIH1cbiAgaWYgKHNjYWxlLmRpbXNbMF0gIT09IFguZGltc1sxXSB8fCBCLmRpbXNbMF0gIT09IFguZGltc1sxXSB8fCBtZWFuLmRpbXNbMF0gIT09IFguZGltc1sxXSB8fFxuICAgICAgdmFyXy5kaW1zWzBdICE9PSBYLmRpbXNbMV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5wdXQgc2hhcGUuJyk7XG4gIH1cbiAgaWYgKChYLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBYLnR5cGUgIT09ICdmbG9hdDY0JykgfHwgKHNjYWxlLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBzY2FsZS50eXBlICE9PSAnZmxvYXQ2NCcpIHx8XG4gICAgICAoQi50eXBlICE9PSAnZmxvYXQzMicgJiYgQi50eXBlICE9PSAnZmxvYXQ2NCcpIHx8IChtZWFuLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBtZWFuLnR5cGUgIT09ICdmbG9hdDY0JykgfHxcbiAgICAgICh2YXJfLnR5cGUgIT09ICdmbG9hdDMyJyAmJiB2YXJfLnR5cGUgIT09ICdmbG9hdDY0JykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5wdXQgdGVuc29yIHR5cGVzLicpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1Byb2dyYW1JbmZvLCBUZXh0dXJlTGF5b3V0fSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7V2ViR0xDb250ZXh0fSBmcm9tICcuL3dlYmdsLWNvbnRleHQnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24gKi9cbmV4cG9ydCBlbnVtIEZ1bmN0aW9uVHlwZSB7XG4gIFZhbHVlQmFzZWQsXG4gIFBvc2l0aW9uYWxcbn1cbmV4cG9ydCBpbnRlcmZhY2UgR2xzbEZ1bmN0aW9uPFQgZXh0ZW5kcyBGdW5jdGlvblR5cGU+IHtcbiAgYm9keTogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIHR5cGU6IFQ7XG59XG5leHBvcnQgdHlwZSBHbHNsVmFsdWVGdW5jdGlvbiA9IEdsc2xGdW5jdGlvbjxGdW5jdGlvblR5cGUuVmFsdWVCYXNlZD47XG5leHBvcnQgaW50ZXJmYWNlIEdsc2xQb3NpdGlvbmFsRnVuY3Rpb24gZXh0ZW5kcyBHbHNsRnVuY3Rpb248RnVuY3Rpb25UeXBlLlBvc2l0aW9uYWw+IHtcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW107XG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcbn1cblxuZXhwb3J0IGNsYXNzIEdsc2xDb250ZXh0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgZ2xDb250ZXh0OiBXZWJHTENvbnRleHQsIHB1YmxpYyBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIHB1YmxpYyBpbnB1dFRleHR1cmVMYXlvdXRzOiBUZXh0dXJlTGF5b3V0W10sXG4gICAgICBwdWJsaWMgb3V0cHV0VGV4dHVyZUxheW91dDogVGV4dHVyZUxheW91dCkge31cbn1cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBHbHNsTGliIHtcbiAgY29uc3RydWN0b3IocHVibGljIGNvbnRleHQ6IEdsc2xDb250ZXh0KSB7fVxuICBhYnN0cmFjdCBnZXRGdW5jdGlvbnMoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX07XG4gIGFic3RyYWN0IGdldEN1c3RvbVR5cGVzKCk6IHtbbmFtZTogc3RyaW5nXTogc3RyaW5nfTtcbn1cblxuLy8gYWJzdHJhY3Rpb24gdG8gcmVwcmVzZW50IGEgR0xTTCBsaWJyYXJ5IHJvdXRpbmUgYW5kIGl0J3MgZGVwZW5kZW5jaWVzXG5leHBvcnQgY2xhc3MgR2xzbExpYlJvdXRpbmUge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcm91dGluZUJvZHk6IHN0cmluZywgcHVibGljIGRlcGVuZGVuY2llcz86IHN0cmluZ1tdKSB7fVxufVxuXG4vLyBhYnN0cmFjdGlvbiB0byByZXByZXNlbnQgYSBHTFNMIGxpYnJhcnkgcm91dGluZSBhbmQgaXQncyBkZXBlbmRlbmNpZXMgQVMgR1JBUEggTm9kZXNcbi8vIHRoaXMgbGV2ZWwgb2YgYWJzdHJhY3Rpb24gaXMgdXNlZCB0byB0b3BvbG9naWNhbGx5IHNvcnQgcm91dGluZXMgYmVmb3JlIGZyYWdtZW50IHNoYWRlIGluY2x1c2lvblxuZXhwb3J0IGNsYXNzIEdsc2xMaWJSb3V0aW5lTm9kZSB7XG4gIGRlcGVuZGVuY2llczogR2xzbExpYlJvdXRpbmVOb2RlW107XG4gIHJvdXRpbmVCb2R5OiBzdHJpbmc7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBuYW1lOiBzdHJpbmcsIHJvdXRpbmVCb2R5Pzogc3RyaW5nLCBkZXBlbmRlbmNpZXM/OiBHbHNsTGliUm91dGluZU5vZGVbXSkge1xuICAgIGlmIChkZXBlbmRlbmNpZXMpIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IFtdO1xuICAgIH1cblxuICAgIGlmIChyb3V0aW5lQm9keSkge1xuICAgICAgdGhpcy5yb3V0aW5lQm9keSA9IHJvdXRpbmVCb2R5O1xuICAgIH1cbiAgfVxuICBhZGREZXBlbmRlbmN5KG5vZGU6IEdsc2xMaWJSb3V0aW5lTm9kZSkge1xuICAgIGlmIChub2RlKSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY2llcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxufVxuXG4vLyB0b3BvbG9naWNhbGx5IHNvcnQgR0xTTCBsaWJyYXJ5IHJvdXRpbmVzIChncmFwaCBub2RlcyBhYnN0cmFjdGlvbikgYmVmb3JlIHNoYWRlciBzY3JpcHQgaW5jbHVzaW9uXG5leHBvcnQgY2xhc3MgVG9wb2xvZ2ljYWxTb3J0R2xzbFJvdXRpbmVzIHtcbiAgc3RhdGljIHJldHVybk9yZGVyZWROb2Rlcyhub2RlczogR2xzbExpYlJvdXRpbmVOb2RlW10pOiBHbHNsTGliUm91dGluZU5vZGVbXSB7XG4gICAgaWYgKCFub2RlcyB8fCBub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuXG4gICAgY29uc3QgY3ljbGVDaGVjayA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGNvbnN0IGFscmVhZHlUcmF2ZXJzZWQgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXk8R2xzbExpYlJvdXRpbmVOb2RlPigpO1xuXG4gICAgdGhpcy5jcmVhdGVPcmRlcmVkTm9kZXMobm9kZXMsIGN5Y2xlQ2hlY2ssIGFscmVhZHlUcmF2ZXJzZWQsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGNyZWF0ZU9yZGVyZWROb2RlcyhcbiAgICAgIGdyYXBoTm9kZXM6IEdsc2xMaWJSb3V0aW5lTm9kZVtdLCBjeWNsZUNoZWNrOiBTZXQ8c3RyaW5nPiwgYWxyZWFkeVRyYXZlcnNlZDogU2V0PHN0cmluZz4sXG4gICAgICByZXN1bHQ6IEdsc2xMaWJSb3V0aW5lTm9kZVtdKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmFwaE5vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB0aGlzLmRmc1RyYXZlcnNlKGdyYXBoTm9kZXNbaV0sIGN5Y2xlQ2hlY2ssIGFscmVhZHlUcmF2ZXJzZWQsIHJlc3VsdCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZGZzVHJhdmVyc2UoXG4gICAgICByb290OiBHbHNsTGliUm91dGluZU5vZGUsIGN5Y2xlQ2hlY2s6IFNldDxzdHJpbmc+LCBhbHJlYWR5VHJhdmVyc2VkOiBTZXQ8c3RyaW5nPiwgcmVzdWx0OiBHbHNsTGliUm91dGluZU5vZGVbXSkge1xuICAgIC8vIGlmIHRoaXMgcm9vdCBoYXMgYWxyZWFkeSBiZWVuIHRyYXZlcnNlZCByZXR1cm5cbiAgICBpZiAoIXJvb3QgfHwgYWxyZWFkeVRyYXZlcnNlZC5oYXMocm9vdC5uYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGN5Y2xpYyBkZXBlbmRlbmN5IGhhcyBiZWVuIGRldGVjdGVkXG4gICAgaWYgKGN5Y2xlQ2hlY2suaGFzKHJvb3QubmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ3ljbGljIGRlcGVuZGVuY3kgZGV0ZWN0ZWQuIENhblxcJ3QgdG9wb2xvZ2ljYWxseSBzb3J0IHJvdXRpbmVzIG5lZWRlZCBmb3Igc2hhZGVyLicpO1xuICAgIH1cblxuICAgIC8vIGhvbGQgdGhpcyBub2RlIHRvIGRldGVjdCBjeWNsZXMgaWYgYW55XG4gICAgY3ljbGVDaGVjay5hZGQocm9vdC5uYW1lKTtcblxuICAgIC8vIHRyYXZlcnNlIGNoaWxkcmVuIGluIGEgZGZzIGZhc2hpb25cbiAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSByb290LmRlcGVuZGVuY2llcztcbiAgICBpZiAoZGVwZW5kZW5jaWVzICYmIGRlcGVuZGVuY2llcy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLmRmc1RyYXZlcnNlKGRlcGVuZGVuY2llc1tpXSwgY3ljbGVDaGVjaywgYWxyZWFkeVRyYXZlcnNlZCwgcmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGQgdG8gcmVzdWx0IGhvbGRlclxuICAgIHJlc3VsdC5wdXNoKHJvb3QpO1xuXG4gICAgLy8gbWFyayB0aGlzIG5vZGUgYXMgdHJhdmVyc2VkIHNvIHRoYXQgd2UgZG9uJ3QgdHJhdmVyc2UgZnJvbSB0aGlzIGFnYWluXG4gICAgYWxyZWFkeVRyYXZlcnNlZC5hZGQocm9vdC5uYW1lKTtcblxuICAgIC8vIHJlbGVhc2UgdGhlIGhvbGRcbiAgICBjeWNsZUNoZWNrLmRlbGV0ZShyb290Lm5hbWUpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtCcm9hZGNhc3RVdGlsLCBTaGFwZVV0aWx9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtGdW5jdGlvblR5cGUsIEdsc2xWYWx1ZUZ1bmN0aW9ufSBmcm9tICcuLi9nbHNsLWRlZmluaXRpb25zJztcbmltcG9ydCB7Z2V0R2xzbH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFByb2dyYW1JbmZvTG9hZGVyLCBUZXh0dXJlVHlwZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2xzbEFkZCgpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnYWRkXyc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiBhICsgYjtcbiAgfVxuICB2ZWM0ICR7bmFtZX0odmVjNCB2MSwgdmVjNCB2Mikge1xuICAgIHJldHVybiB2MSArIHYyO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xEaXYoKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gJ2Rpdl8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gYSAvIGI7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICByZXR1cm4gdjEgLyB2MjtcbiAgfVxuICBgO1xuICByZXR1cm4ge2JvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsTXVsKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdtdWxfJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgcmV0dXJuIGEgKiBiO1xuICB9XG4gIHZlYzQgJHtuYW1lfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XG4gICAgcmV0dXJuIHYxICogdjI7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHtib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbFN1YigpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnc3ViXyc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiBhIC0gYjtcbiAgfVxuICB2ZWM0ICR7bmFtZX0odmVjNCB2MSwgdmVjNCB2Mikge1xuICAgIHJldHVybiB2MSAtIHYyO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xFcXVhbCgpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnZXF1YWxfJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgcmV0dXJuIGZsb2F0KGEgPT0gYik7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICByZXR1cm4gdmVjNChlcXVhbCh2MSwgdjIpKTtcbiAgfVxuICBgO1xuICByZXR1cm4ge2JvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsR3JlYXRlcigpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnZ3JlYXRlcl8nO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9KGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgICByZXR1cm4gZmxvYXQoYSA+IGIpO1xuICB9XG4gIHZlYzQgJHtuYW1lfSh2ZWM0IHYxLCB2ZWM0IHYyKSB7XG4gICAgcmV0dXJuIHZlYzQoIHYxLnIgPiB2Mi5yICxcbiAgICAgIHYxLmcgPiB2Mi5nLFxuICAgICAgdjEuYiA+IHYyLmIsXG4gICAgICB2MS5hID4gdjIuYSApO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xMZXNzKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdsZXNzXyc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiBmbG9hdChhIDwgYik7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICByZXR1cm4gdmVjNCggdjEuciA8IHYyLnIgLFxuICAgICAgICAgICAgICAgIHYxLmcgPCB2Mi5nLFxuICAgICAgICAgICAgICAgIHYxLmIgPCB2Mi5iLFxuICAgICAgICAgICAgICAgIHYxLmEgPCB2Mi5hICk7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHtib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbEFuZCgpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnYW5kXyc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiBmbG9hdCggYm9vbChhKSAmJiBib29sKGIpICk7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICBidmVjNCBiMSA9IGJ2ZWM0KHYxKTtcbiAgICBidmVjNCBiMiA9IGJ2ZWM0KHYyKTtcbiAgICByZXR1cm4gdmVjNCggYjEuciAmJiBiMi5yICxcbiAgICAgICAgICAgICAgICBiMS5nICYmIGIyLmcsXG4gICAgICAgICAgICAgICAgYjEuYiAmJiBiMi5iLFxuICAgICAgICAgICAgICAgIGIxLmEgJiYgYjIuYSApO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xPcigpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnb3JfJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgcmV0dXJuIGZsb2F0KCBib29sKGEpIHx8IGJvb2woYikgKTtcbiAgfVxuICB2ZWM0ICR7bmFtZX0odmVjNCB2MSwgdmVjNCB2Mikge1xuICAgIGJ2ZWM0IGIxID0gYnZlYzQodjEpO1xuICAgIGJ2ZWM0IGIyID0gYnZlYzQodjIpO1xuICAgIHJldHVybiB2ZWM0KCBiMS5yIHx8IGIyLnIgLFxuICAgICAgICAgICAgICAgIGIxLmcgfHwgYjIuZyxcbiAgICAgICAgICAgICAgICBiMS5iIHx8IGIyLmIsXG4gICAgICAgICAgICAgICAgYjEuYSB8fCBiMi5hICk7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHtib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbFhvcigpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAneG9yXyc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiBmbG9hdCggYm9vbChhKSBeXiBib29sKGIpICk7XG4gIH1cbiAgdmVjNCAke25hbWV9KHZlYzQgdjEsIHZlYzQgdjIpIHtcbiAgICBidmVjNCBiMSA9IGJ2ZWM0KHYxKTtcbiAgICBidmVjNCBiMiA9IGJ2ZWM0KHYyKTtcbiAgICByZXR1cm4gdmVjNCggYjEuciBeXiBiMi5yICxcbiAgICAgICAgICAgICAgICBiMS5nIF5eIGIyLmcsXG4gICAgICAgICAgICAgICAgYjEuYiBeXiBiMi5iLFxuICAgICAgICAgICAgICAgIGIxLmEgXl4gYjIuYSApO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xQb3coKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5CaW5hcnkoJ3BvdycpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xQUmVsdSgpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAncHJlbHVfJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfShmbG9hdCBhLCBmbG9hdCBiKSB7XG4gICAgcmV0dXJuIGEgPCAwLjAgPyBhICogYjogYTtcbiAgfVxuICB2ZWM0ICR7bmFtZX0odmVjNCB2MSwgdmVjNCB2Mikge1xuICAgIHJldHVybiB2ZWM0KFxuICAgICAgdjEuciA8IDAuMCA/IHYxLnIgKiB2Mi5yOiB2MS5yLFxuICAgICAgdjEuZyA8IDAuMCA/IHYxLmcgKiB2Mi5nOiB2MS5nLFxuICAgICAgdjEuYiA8IDAuMCA/IHYxLmIgKiB2Mi5iOiB2MS5iLFxuICAgICAgdjEuYSA8IDAuMCA/IHYxLmEgKiB2Mi5hOiB2MS5hXG4gICAgICApO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuXG5mdW5jdGlvbiBnbHNsQnVpbHRpbkJpbmFyeShmbmFtZTogc3RyaW5nKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICBjb25zdCBuYW1lID0gYCR7Zm5hbWV9X2A7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX0oZmxvYXQgYSwgZmxvYXQgYikge1xuICAgIHJldHVybiAke2ZuYW1lfShhLCBiKTtcbiAgfVxuICB2ZWM0ICR7bmFtZX0odmVjNCB2MSwgdmVjNCB2Mikge1xuICAgIHJldHVybiAke2ZuYW1lfSh2MSwgdjIpO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuXG5jb25zdCBjcmVhdGVCaW5hcnlQcm9ncmFtSW5mb0xvYWRlciA9XG4gICAgKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgZ2xzbEZ1bmM6IEdsc2xWYWx1ZUZ1bmN0aW9uLFxuICAgICBvdXRwdXRUZW5zb3JUeXBlOiBUZW5zb3IuRGF0YVR5cGUgPSBpbnB1dHNbMF0udHlwZSwgY2FjaGVLZXk/OiBzdHJpbmcpOiBQcm9ncmFtSW5mb0xvYWRlciA9PiB7XG4gICAgICBjb25zdCB0ZXh0dXJlVHlwZSA9IGhhbmRsZXIuc2Vzc2lvbi5wYWNrID8gVGV4dHVyZVR5cGUucGFja2VkIDogVGV4dHVyZVR5cGUudW5wYWNrZWQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBnbHNsRnVuYy5uYW1lLFxuICAgICAgICBpbnB1dE5hbWVzOiBbJ0EnLCAnQiddLFxuICAgICAgICBpbnB1dFR5cGVzOiBbdGV4dHVyZVR5cGUsIHRleHR1cmVUeXBlXSxcbiAgICAgICAgY2FjaGVIaW50OiBjYWNoZUtleSxcbiAgICAgICAgZ2V0OiAoKSA9PiBjcmVhdGVCaW5hcnlQcm9ncmFtSW5mbyhoYW5kbGVyLCBpbnB1dHMsIGdsc2xGdW5jLCBvdXRwdXRUZW5zb3JUeXBlKVxuICAgICAgfTtcbiAgICB9O1xuXG5jb25zdCBjcmVhdGVCaW5hcnlQcm9ncmFtSW5mbyA9XG4gICAgKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgZ2xzbEZ1bmM6IEdsc2xWYWx1ZUZ1bmN0aW9uLFxuICAgICBvdXRwdXRUZW5zb3JUeXBlOiBUZW5zb3IuRGF0YVR5cGUgPSBpbnB1dHNbMF0udHlwZSk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IHRleHR1cmVUeXBlID0gaGFuZGxlci5zZXNzaW9uLnBhY2sgPyBUZXh0dXJlVHlwZS5wYWNrZWQgOiBUZXh0dXJlVHlwZS51bnBhY2tlZDtcbiAgICAgIGNvbnN0IGlzQnJvYWRjYXN0ID0gIVNoYXBlVXRpbC5hcmVFcXVhbChpbnB1dHNbMF0uZGltcywgaW5wdXRzWzFdLmRpbXMpO1xuICAgICAgbGV0IG91dHB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG5cbiAgICAgIGNvbnN0IHVzZVBhY2tlZFRleHR1cmUgPSBoYW5kbGVyLnNlc3Npb24ucGFjaztcblxuICAgICAgaWYgKGlzQnJvYWRjYXN0KSB7XG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRTaGFwZSA9IEJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKGlucHV0c1swXS5kaW1zLCBpbnB1dHNbMV0uZGltcywgZmFsc2UpO1xuICAgICAgICBpZiAoIWNhbGN1bGF0ZWRTaGFwZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBwZXJmb3JtIGJpbmFyeSBvcCBvbiB0aGUgZ2l2ZW4gdGVuc29ycycpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dFNoYXBlID0gY2FsY3VsYXRlZFNoYXBlO1xuICAgICAgICBjb25zdCBvdXRwdXRSYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICAgICAgICBjb25zdCBhUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gMCA/IGlucHV0c1swXS5kaW1zLmxlbmd0aCA6IDE7XG4gICAgICAgIGNvbnN0IGJSYW5rID0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSAwID8gaW5wdXRzWzFdLmRpbXMubGVuZ3RoIDogMTtcbiAgICAgICAgY29uc3QgYUJjYXN0ID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSAwID8gJ2JjYXN0SW5kaWNlc19BKGluZGljZXMsIGFpbmRpY2VzKTsnIDogJ2FpbmRpY2VzWzBdID0gMDsnO1xuICAgICAgICBjb25zdCBiQmNhc3QgPSBpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDAgPyAnYmNhc3RJbmRpY2VzX0IoaW5kaWNlcywgYmluZGljZXMpOycgOiAnYmluZGljZXNbMF0gPSAwOyc7XG5cbiAgICAgICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgICAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSB1c2VQYWNrZWRUZXh0dXJlID8gYFxuICAgICAgJHtnbHNsRnVuYy5ib2R5fVxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2ZWM0IGEgPSBnZXRBQXRPdXRDb29yZHMoKTtcbiAgICAgICAgdmVjNCBiID0gZ2V0QkF0T3V0Q29vcmRzKCk7XG4gICAgICAgIHZlYzQgcmVzdWx0ID0gJHtnbHNsRnVuYy5uYW1lfShhLCBiKTtcbiAgICAgICAgJHtnbHNsLm91dHB1dH0gPSByZXN1bHQ7XG4gICAgICB9YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXG4gICAgICAke2dsc2xGdW5jLmJvZHl9XG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7b3V0cHV0UmFua31dKSB7XG4gICAgICAgIGludCBhaW5kaWNlc1ske2FSYW5rfV07XG4gICAgICAgIGludCBiaW5kaWNlc1ske2JSYW5rfV07XG4gICAgICAgICR7YUJjYXN0fVxuICAgICAgICAke2JCY2FzdH1cbiAgICAgICAgcmV0dXJuICR7Z2xzbEZ1bmMubmFtZX0oX0EoYWluZGljZXMpLCBfQihiaW5kaWNlcykpO1xuICAgICAgfWA7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBnbHNsRnVuYy5uYW1lLFxuICAgICAgICAgIGlucHV0TmFtZXM6IFsnQScsICdCJ10sXG4gICAgICAgICAgaW5wdXRUeXBlczogW3RleHR1cmVUeXBlLCB0ZXh0dXJlVHlwZV0sXG4gICAgICAgICAgb3V0cHV0OiB7ZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IG91dHB1dFRlbnNvclR5cGUsIHRleHR1cmVUeXBlfSxcbiAgICAgICAgICBzaGFkZXJTb3VyY2UsXG4gICAgICAgICAgaGFzTWFpbjogdXNlUGFja2VkVGV4dHVyZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICR7Z2xzbEZ1bmMuYm9keX1cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICB2ZWM0IHYxID0gJHtnbHNsLnRleHR1cmUyRH0oQSwgVGV4Q29vcmRzKTtcbiAgICAgIHZlYzQgdjIgPSAke2dsc2wudGV4dHVyZTJEfShCLCBUZXhDb29yZHMpO1xuICAgICAgdmVjNCByZXN1bHQgPSAke2dsc2xGdW5jLm5hbWV9KHYxLCB2Mik7XG4gICAgICAke2dsc2wub3V0cHV0fSA9IHJlc3VsdDtcbiAgICB9XG4gICAgYDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogZ2xzbEZ1bmMubmFtZSxcbiAgICAgICAgaW5wdXROYW1lczogWydBJywgJ0InXSxcbiAgICAgICAgaW5wdXRUeXBlczogW3RleHR1cmVUeXBlLCB0ZXh0dXJlVHlwZV0sXG4gICAgICAgIG91dHB1dDoge2RpbXM6IGlucHV0c1swXS5kaW1zLCB0eXBlOiBvdXRwdXRUZW5zb3JUeXBlLCB0ZXh0dXJlVHlwZX0sXG4gICAgICAgIHNoYWRlclNvdXJjZSxcbiAgICAgICAgaGFzTWFpbjogdHJ1ZVxuICAgICAgfTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgYWRkID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6XG4gICAgVGVuc29yW10gPT4gW2hhbmRsZXIucnVuKGNyZWF0ZUJpbmFyeVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0cywgZ2xzbEFkZCgpKSwgaW5wdXRzKV07XG5cbmV4cG9ydCBjb25zdCBhbmQgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTpcbiAgICBUZW5zb3JbXSA9PiBbaGFuZGxlci5ydW4oY3JlYXRlQmluYXJ5UHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzLCBnbHNsQW5kKCksICdib29sJyksIGlucHV0cyldO1xuXG5leHBvcnQgY29uc3QgZGl2ID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6XG4gICAgVGVuc29yW10gPT4gW2hhbmRsZXIucnVuKGNyZWF0ZUJpbmFyeVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0cywgZ2xzbERpdigpKSwgaW5wdXRzKV07XG5cbmV4cG9ydCBjb25zdCBlcXVhbCA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOlxuICAgIFRlbnNvcltdID0+IFtoYW5kbGVyLnJ1bihjcmVhdGVCaW5hcnlQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHMsIGdsc2xFcXVhbCgpLCAnYm9vbCcpLCBpbnB1dHMpXTtcblxuZXhwb3J0IGNvbnN0IGdyZWF0ZXIgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTpcbiAgICBUZW5zb3JbXSA9PiBbaGFuZGxlci5ydW4oY3JlYXRlQmluYXJ5UHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzLCBnbHNsR3JlYXRlcigpLCAnYm9vbCcpLCBpbnB1dHMpXTtcblxuZXhwb3J0IGNvbnN0IGxlc3MgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTpcbiAgICBUZW5zb3JbXSA9PiBbaGFuZGxlci5ydW4oY3JlYXRlQmluYXJ5UHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzLCBnbHNsTGVzcygpLCAnYm9vbCcpLCBpbnB1dHMpXTtcblxuZXhwb3J0IGNvbnN0IG11bCA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOlxuICAgIFRlbnNvcltdID0+IFtoYW5kbGVyLnJ1bihjcmVhdGVCaW5hcnlQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHMsIGdsc2xNdWwoKSksIGlucHV0cyldO1xuXG5leHBvcnQgY29uc3Qgb3IgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTpcbiAgICBUZW5zb3JbXSA9PiBbaGFuZGxlci5ydW4oY3JlYXRlQmluYXJ5UHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzLCBnbHNsT3IoKSwgJ2Jvb2wnKSwgaW5wdXRzKV07XG5cbmV4cG9ydCBjb25zdCBwb3cgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTpcbiAgICBUZW5zb3JbXSA9PiBbaGFuZGxlci5ydW4oY3JlYXRlQmluYXJ5UHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzLCBnbHNsUG93KCkpLCBpbnB1dHMpXTtcblxuZXhwb3J0IGNvbnN0IHBSZWx1ID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6XG4gICAgVGVuc29yW10gPT4gW2hhbmRsZXIucnVuKGNyZWF0ZUJpbmFyeVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0cywgZ2xzbFBSZWx1KCkpLCBpbnB1dHMpXTtcblxuZXhwb3J0IGNvbnN0IHN1YiA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOlxuICAgIFRlbnNvcltdID0+IFtoYW5kbGVyLnJ1bihjcmVhdGVCaW5hcnlQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHMsIGdsc2xTdWIoKSksIGlucHV0cyldO1xuXG5leHBvcnQgY29uc3QgeG9yID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6XG4gICAgVGVuc29yW10gPT4gW2hhbmRsZXIucnVuKGNyZWF0ZUJpbmFyeVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0cywgZ2xzbFhvcigpLCAnYm9vbCcpLCBpbnB1dHMpXTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHtPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9ufSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1Byb3RvVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuXG5leHBvcnQgY29uc3QgY2FzdDogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxUZW5zb3IuRGF0YVR5cGU+ID1cbiAgICAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCB0bzogVGVuc29yLkRhdGFUeXBlKTogVGVuc29yW10gPT4ge1xuICAgICAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcbiAgICAgIHJldHVybiBbaGFuZGxlci5jYXN0KGlucHV0c1swXSwgdG8pXTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgcGFyc2VDYXN0QXR0cmlidXRlczogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxUZW5zb3IuRGF0YVR5cGU+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBUZW5zb3IuRGF0YVR5cGUgPT5cbiAgICBQcm90b1V0aWwudGVuc29yRGF0YVR5cGVGcm9tUHJvdG8obm9kZS5hdHRyaWJ1dGVzLmdldEludCgndG8nKSk7XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FzdCByZXF1aXJlcyAxIGlucHV0LicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS50eXBlID09PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlLicpO1xuICB9XG59OyIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgUHJvZ3JhbU1ldGFkYXRhLCBUZXh0dXJlVHlwZX0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtnZXRDb29yZHNEYXRhVHlwZSwgZ2V0R2xDaGFubmVsc30gZnJvbSAnLi4vdXRpbHMnO1xuXG5pbXBvcnQge0NvbmNhdEF0dHJpYnV0ZXN9IGZyb20gJy4vY29uY2F0JztcbmltcG9ydCB7Z2V0Q2hhbm5lbHMsIHVucGFja0Zyb21DaGFubmVsfSBmcm9tICcuL3BhY2tpbmctdXRpbHMnO1xuXG5jb25zdCBjcmVhdGVQYWNrZWRDb25jYXRQcm9ncmFtTWV0YWRhdGEgPSAoaW5wdXRDb3VudDogbnVtYmVyLCBjYWNoZUhpbnQ6IHN0cmluZykgPT4gKHtcbiAgbmFtZTogJ0NvbmNhdCAocGFja2VkKScsXG4gIGlucHV0TmFtZXM6IEFycmF5LmZyb20oe2xlbmd0aDogaW5wdXRDb3VudH0sIChfdiwgaSkgPT4gYFgke2l9YCksXG4gIGlucHV0VHlwZXM6IEFycmF5KGlucHV0Q291bnQpLmZpbGwoVGV4dHVyZVR5cGUucGFja2VkKSxcbiAgY2FjaGVIaW50XG59KTtcblxuY29uc3QgY3JlYXRlUGFja2VkQ29uY2F0UHJvZ3JhbUluZm8gPVxuICAgIChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIG1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsIGlucHV0czogVGVuc29yW10sIGF4aXM6IG51bWJlcik6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICAgICAgaWYgKGF4aXMgPj0gaW5wdXRTaGFwZS5sZW5ndGggfHwgYXhpcyA8ICgtMSAqIGlucHV0U2hhcGUubGVuZ3RoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F4aXMgc3BlY2lmaWVkIGZvciBjb25jYXQgZG9lc25cXCd0IG1hdGNoIGlucHV0IGRpbWVuc2lvbmFsaXR5Jyk7XG4gICAgICB9XG4gICAgICBpZiAoYXhpcyA8IDApIHtcbiAgICAgICAgYXhpcyA9IGlucHV0U2hhcGUubGVuZ3RoICsgYXhpcztcbiAgICAgIH1cbiAgICAgIC8vIGVuc3VyZSBhbGwgb2YgdGhlIG5vbi1jb25jYXRlbmF0ZWQgYXhlcyBtYXRjaCBlYWNoIG90aGVyXG4gICAgICAvLyBjYWxjdWxhdGUgdGhlIHNoYXBlIG9mIHRoZSBvdXRwdXQgdGVuc29yIHdoaWxlIHdlIGRvIHRoYXRcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgwKTtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRhdGFOU2hhcGUgPSBpbnB1dHNbaV0uZGltcy5zbGljZSgpO1xuICAgICAgICBmb3IgKGxldCBheGlzSW5kZXggPSAwOyBheGlzSW5kZXggPCBpbnB1dFNoYXBlLmxlbmd0aDsgYXhpc0luZGV4KyspIHtcbiAgICAgICAgICAvLyBhZGQgdG8gdGhlIHBsYWNlaG9sZGVyIGZvciBjb21wdXRpbmcgb3V0cHV0IHNoYXBlXG4gICAgICAgICAgaWYgKGF4aXNJbmRleCA9PT0gYXhpcykge1xuICAgICAgICAgICAgb3V0cHV0U2hhcGVbYXhpc10gKz0gZGF0YU5TaGFwZVtheGlzSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlbnN1cmUgYWxsIG5vbi1jYW5jYXRlbmF0ZWQgYXhlcyBtYXRjaCBlYWNoIG90aGVyXG4gICAgICAgICAgZWxzZSBpZiAoaW5wdXRTaGFwZVtheGlzSW5kZXhdICE9PSBkYXRhTlNoYXBlW2F4aXNJbmRleF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm9uIGNvbmNhdCBkaW1lbnNpb25zIG11c3QgbWF0Y2gnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICAgIGNvbnN0IGNvb3JkcyA9IGdldENoYW5uZWxzKCdjb29yZHMnLCByYW5rKTtcbiAgICAgIGNvbnN0IGR0eXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUocmFuayk7XG4gICAgICBjb25zdCB1bnBhY2tDaGFubmVsID0gdW5wYWNrRnJvbUNoYW5uZWwoKTtcblxuICAgICAgY29uc3Qgc2hhcGVzID0gaW5wdXRzLm1hcChpID0+IGkuZGltcyk7XG4gICAgICBjb25zdCBjaGFubmVscyA9IGdldEdsQ2hhbm5lbHMocmFuayk7XG4gICAgICBjb25zdCBvZmZzZXRzOiBudW1iZXJbXSA9IG5ldyBBcnJheShzaGFwZXMubGVuZ3RoIC0gMSk7XG5cbiAgICAgIG9mZnNldHNbMF0gPSBzaGFwZXNbMF1bYXhpc107XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG9mZnNldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb2Zmc2V0c1tpXSA9IG9mZnNldHNbaSAtIDFdICsgc2hhcGVzW2ldW2F4aXNdO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjaGFubmVsID0gY2hhbm5lbHNbYXhpc107XG4gICAgICBjb25zdCBsYXN0Q2hhbm5lbHMgPSBjaGFubmVscy5zbGljZSgtMik7XG4gICAgICBjb25zdCBhbGxDaGFubmVscyA9IGNoYW5uZWxzLmpvaW4oKTtcblxuICAgICAgbGV0IGdldFZhbHVlU25pcHBldCA9IGBpZiAoJHtjaGFubmVsfSA8ICR7b2Zmc2V0c1swXX0pIHtcbiAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoXG4gICAgICAgICAgICBnZXRYMCgke2FsbENoYW5uZWxzfSksIHZlYzIoJHtsYXN0Q2hhbm5lbHMuam9pbigpfSkpO1xuICAgICAgICB9YDtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgb2Zmc2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzaGlmdCA9IG9mZnNldHNbaSAtIDFdO1xuICAgICAgICBnZXRWYWx1ZVNuaXBwZXQgKz0gYFxuICAgICAgICAgICAgaWYgKCR7Y2hhbm5lbH0gPCAke29mZnNldHNbaV19ICAmJiAke2NoYW5uZWx9ID49ICR7b2Zmc2V0c1tpIC0gMV19KSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRDaGFubmVsKFxuICAgICAgICAgICAgICAgIGdldFgke2l9KCR7Z2V0U2hpZnRlZENoYW5uZWxzU25pcHBldChjaGFubmVscywgY2hhbm5lbCwgc2hpZnQpfSksXG4gICAgICAgICAgICAgICAgdmVjMigke2dldFNoaWZ0ZWRDaGFubmVsc1NuaXBwZXQobGFzdENoYW5uZWxzLCBjaGFubmVsLCBzaGlmdCl9KSk7XG4gICAgICAgICAgICB9YDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IG9mZnNldHMubGVuZ3RoO1xuICAgICAgY29uc3Qgc2hpZnQgPSBvZmZzZXRzW29mZnNldHMubGVuZ3RoIC0gMV07XG4gICAgICBnZXRWYWx1ZVNuaXBwZXQgKz0gYFxuICAgICAgICAgICAgcmV0dXJuIGdldENoYW5uZWwoXG4gICAgICAgICAgICAgIGdldFgke2xhc3RJbmRleH0oJHtnZXRTaGlmdGVkQ2hhbm5lbHNTbmlwcGV0KGNoYW5uZWxzLCBjaGFubmVsLCBzaGlmdCl9KSxcbiAgICAgICAgICAgICAgdmVjMigke2dldFNoaWZ0ZWRDaGFubmVsc1NuaXBwZXQobGFzdENoYW5uZWxzLCBjaGFubmVsLCBzaGlmdCl9KSk7YDtcblxuICAgICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuXG4gICAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICAgICAgJHt1bnBhY2tDaGFubmVsfVxuICAgICAgICAgIGZsb2F0IGdldFZhbHVlKCR7Y2hhbm5lbHMubWFwKHggPT4gJ2ludCAnICsgeCl9KSB7XG4gICAgICAgICAgICAke2dldFZhbHVlU25pcHBldH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAke2R0eXBlfSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgICAgIGludCBsYXN0RGltID0gY29vcmRzLiR7Y2hhbm5lbHNbcmFuayAtIDFdfTtcbiAgICAgICAgICAgIGNvb3Jkcy4ke2NoYW5uZWxzW3JhbmsgLSAxXX0gPSBjb29yZHMuJHtjaGFubmVsc1tyYW5rIC0gMl19O1xuICAgICAgICAgICAgY29vcmRzLiR7Y2hhbm5lbHNbcmFuayAtIDJdfSA9IGxhc3REaW07XG5cbiAgICAgICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNChnZXRWYWx1ZSgke2Nvb3Jkc30pLCAwLiwgMC4sIDAuKTtcblxuICAgICAgICAgICAgJHtjb29yZHNbcmFuayAtIDFdfSA9ICR7Y29vcmRzW3JhbmsgLSAxXX0gKyAxO1xuICAgICAgICAgICAgaWYgKCR7Y29vcmRzW3JhbmsgLSAxXX0gPCAke291dHB1dFNoYXBlW3JhbmsgLSAxXX0pIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmcgPSBnZXRWYWx1ZSgke2Nvb3Jkc30pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAke2Nvb3Jkc1tyYW5rIC0gMl19ID0gJHtjb29yZHNbcmFuayAtIDJdfSArIDE7XG4gICAgICAgICAgICBpZiAoJHtjb29yZHNbcmFuayAtIDJdfSA8ICR7b3V0cHV0U2hhcGVbcmFuayAtIDJdfSkge1xuICAgICAgICAgICAgICByZXN1bHQuYSA9IGdldFZhbHVlKCR7Y29vcmRzfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICR7Y29vcmRzW3JhbmsgLSAxXX0gPSAke2Nvb3Jkc1tyYW5rIC0gMV19IC0gMTtcbiAgICAgICAgICAgIGlmICgke2Nvb3Jkc1tyYW5rIC0gMl19IDwgJHtvdXRwdXRTaGFwZVtyYW5rIC0gMl19ICYmXG4gICAgICAgICAgICAgICAgJHtjb29yZHNbcmFuayAtIDFdfSA8ICR7b3V0cHV0U2hhcGVbcmFuayAtIDFdfSkge1xuICAgICAgICAgICAgICByZXN1bHQuYiA9IGdldFZhbHVlKCR7Y29vcmRzfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAke2dsc2wub3V0cHV0fSA9IHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICBvdXRwdXQ6IHtkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS5wYWNrZWR9LFxuICAgICAgICBzaGFkZXJTb3VyY2UsXG4gICAgICAgIGhhc01haW46IHRydWUsXG4gICAgICB9O1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQYWNrZWRDb25jYXRQcm9ncmFtSW5mb0xvYWRlciA9XG4gICAgKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogQ29uY2F0QXR0cmlidXRlcyk6IFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlUGFja2VkQ29uY2F0UHJvZ3JhbU1ldGFkYXRhKGlucHV0cy5sZW5ndGgsIGF0dHJpYnV0ZXMuY2FjaGVLZXkpO1xuICAgICAgcmV0dXJuIHsuLi5tZXRhZGF0YSwgZ2V0OiAoKSA9PiBjcmVhdGVQYWNrZWRDb25jYXRQcm9ncmFtSW5mbyhoYW5kbGVyLCBtZXRhZGF0YSwgaW5wdXRzLCBhdHRyaWJ1dGVzLmF4aXMpfTtcbiAgICB9O1xuXG5jb25zdCBnZXRTaGlmdGVkQ2hhbm5lbHNTbmlwcGV0ID0gKGNoYW5uZWxzOiBzdHJpbmdbXSwgY2hhbm5lbDogc3RyaW5nLCBzaGlmdDogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgY29uc3QgY2hhbm5lbElkeCA9IGNoYW5uZWxzLmluZGV4T2YoY2hhbm5lbCk7XG4gIGNvbnN0IHJlcyA9IGNoYW5uZWxzLm1hcCgoYywgaWR4KSA9PiB7XG4gICAgaWYgKGlkeCA9PT0gY2hhbm5lbElkeCkge1xuICAgICAgcmV0dXJuIGAke2N9IC0gJHtzaGlmdH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzLmpvaW4oKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uLy4uLy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0dyYXBofSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQge09wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb259IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgUHJvZ3JhbU1ldGFkYXRhLCBUZXh0dXJlVHlwZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2NyZWF0ZVBhY2tlZENvbmNhdFByb2dyYW1JbmZvTG9hZGVyfSBmcm9tICcuL2NvbmNhdC1wYWNrZWQnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbmNhdEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBheGlzOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBjb25jYXQ6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248Q29uY2F0QXR0cmlidXRlcz4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IENvbmNhdEF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiB7XG4gICAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICAgICAgaWYgKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5wYWNrICYmIGlucHV0c1swXS5kaW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID1cbiAgICAgICAgICAgIGluZmVyZW5jZUhhbmRsZXIucnVuKGNyZWF0ZVBhY2tlZENvbmNhdFByb2dyYW1JbmZvTG9hZGVyKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcyksIGlucHV0cyk7XG4gICAgICAgIHJldHVybiBbb3V0cHV0XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9XG4gICAgICAgICAgICBpbmZlcmVuY2VIYW5kbGVyLnJ1bihjcmVhdGVVbnBhY2tlZENvbmNhdFByb2dyYW1JbmZvTG9hZGVyKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcyksIGlucHV0cyk7XG4gICAgICAgIHJldHVybiBbb3V0cHV0XTtcbiAgICAgIH1cbiAgICB9O1xuXG5jb25zdCBjcmVhdGVVbnBhY2tlZENvbmNhdFByb2dyYW1NZXRhZGF0YSA9IChpbnB1dENvdW50OiBudW1iZXIsIGNhY2hlSGludDogc3RyaW5nKSA9PiAoe1xuICBuYW1lOiAnQ29uY2F0JyxcbiAgaW5wdXROYW1lczogQXJyYXkuZnJvbSh7bGVuZ3RoOiBpbnB1dENvdW50fSwgKF92LCBpKSA9PiBgWCR7aX1gKSxcbiAgaW5wdXRUeXBlczogQXJyYXkoaW5wdXRDb3VudCkuZmlsbChUZXh0dXJlVHlwZS51bnBhY2tlZCksXG4gIGNhY2hlSGludFxufSk7XG5cbmNvbnN0IGNyZWF0ZVVucGFja2VkQ29uY2F0UHJvZ3JhbUluZm8gPVxuICAgIChfaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLCBpbnB1dHM6IFRlbnNvcltdLCBheGlzOiBudW1iZXIpOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgICAgIGlmIChheGlzID49IGlucHV0U2hhcGUubGVuZ3RoIHx8IGF4aXMgPCAoLTEgKiBpbnB1dFNoYXBlLmxlbmd0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdheGlzIHNwZWNpZmllZCBmb3IgY29uY2F0IGRvZXNuXFwndCBtYXRjaCBpbnB1dCBkaW1lbnNpb25hbGl0eScpO1xuICAgICAgfVxuICAgICAgaWYgKGF4aXMgPCAwKSB7XG4gICAgICAgIGF4aXMgPSBpbnB1dFNoYXBlLmxlbmd0aCArIGF4aXM7XG4gICAgICB9XG4gICAgICAvLyBlbnN1cmUgYWxsIG9mIHRoZSBub24tY29uY2F0ZW5hdGVkIGF4ZXMgbWF0Y2ggZWFjaCBvdGhlclxuICAgICAgLy8gY2FsY3VsYXRlIHRoZSBzaGFwZSBvZiB0aGUgb3V0cHV0IHRlbnNvciB3aGlsZSB3ZSBkbyB0aGF0XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoMCk7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkYXRhTlNoYXBlID0gaW5wdXRzW2ldLmRpbXMuc2xpY2UoKTtcbiAgICAgICAgZm9yIChsZXQgYXhpc0luZGV4ID0gMDsgYXhpc0luZGV4IDwgaW5wdXRTaGFwZS5sZW5ndGg7IGF4aXNJbmRleCsrKSB7XG4gICAgICAgICAgLy8gYWRkIHRvIHRoZSBwbGFjZWhvbGRlciBmb3IgY29tcHV0aW5nIG91dHB1dCBzaGFwZVxuICAgICAgICAgIGlmIChheGlzSW5kZXggPT09IGF4aXMpIHtcbiAgICAgICAgICAgIG91dHB1dFNoYXBlW2F4aXNdICs9IGRhdGFOU2hhcGVbYXhpc0luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZW5zdXJlIGFsbCBub24tY2FuY2F0ZW5hdGVkIGF4ZXMgbWF0Y2ggZWFjaCBvdGhlclxuICAgICAgICAgIGVsc2UgaWYgKGlucHV0U2hhcGVbYXhpc0luZGV4XSAhPT0gZGF0YU5TaGFwZVtheGlzSW5kZXhdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vbiBjb25jYXQgZGltZW5zaW9ucyBtdXN0IG1hdGNoJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG5cbiAgICAgIGNvbnN0IHNpemVJbkNvbmNhdEF4aXMgPSBuZXcgQXJyYXk8bnVtYmVyPihpbnB1dHMubGVuZ3RoKTtcbiAgICAgIGxldCBwcmV2aW91c1N1bSA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemVJbkNvbmNhdEF4aXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcHJldmlvdXNTdW0gKz0gaW5wdXRzW2ldLmRpbXNbYXhpc107XG4gICAgICAgIHNpemVJbkNvbmNhdEF4aXNbaV0gPSBwcmV2aW91c1N1bTtcbiAgICAgIH1cblxuICAgICAgbGV0IGdldFRleHR1cmVJbmRleFdoZXJlRGF0YVJlc2lkZXNNZXRob2QgPSAnJztcbiAgICAgIC8vIGluIG1vc3QgY2FzZXMgbGluZWFyIHNlYXJjaCBpcyBzdWZmaWNpZW50LCBhcyBpbiBtb3N0IHNjZW5hcmlvcywgb25seSAyIHRlbnNvcnMgYXJlIGNvbmNhdGVuYXRlZFxuICAgICAgaWYgKGlucHV0cy5sZW5ndGggPCA1KSB7XG4gICAgICAgIGdldFRleHR1cmVJbmRleFdoZXJlRGF0YVJlc2lkZXNNZXRob2QgPSBnZXRUZXh0dXJlSW5kZXhXaGVyZURhdGFSZXNpZGVzTGluZWFyU2VhcmNoKHNpemVJbkNvbmNhdEF4aXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0VGV4dHVyZUluZGV4V2hlcmVEYXRhUmVzaWRlc01ldGhvZCA9IGdldFRleHR1cmVJbmRleFdoZXJlRGF0YVJlc2lkZXNCaW5hcnlTZWFyY2goc2l6ZUluQ29uY2F0QXhpcyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZldGNoRGF0YUZyb21Db3JyZWN0VGV4dHVyZU1ldGhvZCA9IGdldEZldGNoRGF0YUZyb21Db3JyZWN0VGV4dHVyZU1ldGhvZChpbnB1dHMubGVuZ3RoLCByYW5rKTtcbiAgICAgIGNvbnN0IGdldFNpemVJbkNvbmNhdEF4aXNWYWx1ZUZyb21JbmRleE1ldGhvZCA9IGdldEdldFNpemVJbkNvbmNhdEF4aXNWYWx1ZUZyb21JbmRleE1ldGhvZChzaXplSW5Db25jYXRBeGlzKTtcbiAgICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICAgJHtmZXRjaERhdGFGcm9tQ29ycmVjdFRleHR1cmVNZXRob2R9XG4gICAgICAgICR7Z2V0U2l6ZUluQ29uY2F0QXhpc1ZhbHVlRnJvbUluZGV4TWV0aG9kfVxuICAgICAgICAke2dldFRleHR1cmVJbmRleFdoZXJlRGF0YVJlc2lkZXNNZXRob2R9XG4gICAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgICBpbnQgdGV4dHVyZUluZGV4ID0gZ2V0VGV4dHVyZVdoZXJlRGF0YVJlc2lkZXMgKGluZGljZXNbJHtheGlzfV0pO1xuXG4gICAgICAgICAgaWYodGV4dHVyZUluZGV4ICE9IDApIHtcbiAgICAgICAgICAgIGluZGljZXNbJHtheGlzfV0gPSBpbmRpY2VzWyR7YXhpc31dIC0gaW50KGdldFNpemVJbkNvbmNhdEF4aXNWYWx1ZUZyb21JbmRleCh0ZXh0dXJlSW5kZXgtaW50KDEpKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZldGNoRGF0YUZyb21Db3JyZWN0VGV4dHVyZSh0ZXh0dXJlSW5kZXgsIGluZGljZXMpO1xuICAgICAgICB9YDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICBvdXRwdXQ6IHtkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgICAgIHNoYWRlclNvdXJjZSxcbiAgICAgIH07XG4gICAgfTtcblxuY29uc3QgY3JlYXRlVW5wYWNrZWRDb25jYXRQcm9ncmFtSW5mb0xvYWRlciA9XG4gICAgKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogQ29uY2F0QXR0cmlidXRlcyk6IFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlVW5wYWNrZWRDb25jYXRQcm9ncmFtTWV0YWRhdGEoaW5wdXRzLmxlbmd0aCwgYXR0cmlidXRlcy5jYWNoZUtleSk7XG4gICAgICByZXR1cm4gey4uLm1ldGFkYXRhLCBnZXQ6ICgpID0+IGNyZWF0ZVVucGFja2VkQ29uY2F0UHJvZ3JhbUluZm8oaGFuZGxlciwgbWV0YWRhdGEsIGlucHV0cywgYXR0cmlidXRlcy5heGlzKX07XG4gICAgfTtcblxuY29uc3QgZ2V0VGV4dHVyZUluZGV4V2hlcmVEYXRhUmVzaWRlc0xpbmVhclNlYXJjaCA9IChzaXplSW5Db25jYXRBeGlzOiBudW1iZXJbXSk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHNlYXJjaEF4aXMgPSBzaXplSW5Db25jYXRBeGlzLm1hcCgoc2l6ZSwgaSkgPT4gYGlmKGluZGV4PCR7c2l6ZX0pIHtyZXR1cm4gJHtpfTt9XG5gKTtcbiAgcmV0dXJuIGBpbnQgZ2V0VGV4dHVyZVdoZXJlRGF0YVJlc2lkZXMoaW50IGluZGV4KSB7XG4gICAgICAke3NlYXJjaEF4aXMuam9pbignJyl9XG4gICAgfWA7XG59O1xuXG4vLyBUT0RPOiBJbXBsZW1lbnQgQmluYXJ5U2VhcmNoIGluIEdMU0xcbmNvbnN0IGdldFRleHR1cmVJbmRleFdoZXJlRGF0YVJlc2lkZXNCaW5hcnlTZWFyY2ggPSAoc2l6ZUluQ29uY2F0QXhpczogbnVtYmVyW10pOiBzdHJpbmcgPT5cbiAgICBnZXRUZXh0dXJlSW5kZXhXaGVyZURhdGFSZXNpZGVzTGluZWFyU2VhcmNoKHNpemVJbkNvbmNhdEF4aXMpO1xuXG5jb25zdCBnZXRGZXRjaERhdGFGcm9tQ29ycmVjdFRleHR1cmVNZXRob2QgPSAobnVtYmVyT2ZUZW5zb3JzOiBudW1iZXIsIHRlbnNvclJhbms6IG51bWJlcikgPT4ge1xuICBjb25zdCBjb2RlTGluZXM6IHN0cmluZ1tdID0gW2BmbG9hdCBmZXRjaERhdGFGcm9tQ29ycmVjdFRleHR1cmUoaW50IHRleHR1cmVJbmRleCwgaW50IGluZGljZXNbJHt0ZW5zb3JSYW5rfV0pIHtgXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlRlbnNvcnM7ICsraSkge1xuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBjb2RlTGluZXMucHVzaChcbiAgICAgICAgICAnXFx0JyArXG4gICAgICAgICAgYGlmICh0ZXh0dXJlSW5kZXggPT0gJHtpfSkgeyByZXR1cm4gX1gke2l9KGluZGljZXMpOyB9YCk7XG4gICAgfSBlbHNlIGlmIChpID09PSBudW1iZXJPZlRlbnNvcnMgLSAxKSB7XG4gICAgICBjb2RlTGluZXMucHVzaChcbiAgICAgICAgICAnXFx0JyArXG4gICAgICAgICAgYGVsc2UgeyByZXR1cm4gX1gke2l9KGluZGljZXMpOyB9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGVMaW5lcy5wdXNoKFxuICAgICAgICAgICdcXHQnICtcbiAgICAgICAgICBgZWxzZSBpZiAodGV4dHVyZUluZGV4ID09ICR7aX0pIHsgcmV0dXJuIF9YJHtpfShpbmRpY2VzKTsgfWApO1xuICAgIH1cbiAgfVxuICBjb2RlTGluZXMucHVzaChcbiAgICAgICdcXHQnICtcbiAgICAgICd9Jyk7XG4gIHJldHVybiBjb2RlTGluZXMuam9pbignXFxuJyk7XG59O1xuXG5jb25zdCBnZXRHZXRTaXplSW5Db25jYXRBeGlzVmFsdWVGcm9tSW5kZXhNZXRob2QgPSAoc2l6ZUluQ29uY2F0QXhpczogbnVtYmVyW10pOiBzdHJpbmcgPT4ge1xuICBjb25zdCBjb2RlTGluZXM6IHN0cmluZ1tdID0gWydpbnQgZ2V0U2l6ZUluQ29uY2F0QXhpc1ZhbHVlRnJvbUluZGV4KGludCBpbmRleCkgeyddO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemVJbkNvbmNhdEF4aXMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgY29kZUxpbmVzLnB1c2goXG4gICAgICAgICAgJ1xcdCcgK1xuICAgICAgICAgIGBpZiAoaW5kZXggPT0gJHtpfSkgeyByZXR1cm4gJHtzaXplSW5Db25jYXRBeGlzW2ldfTsgfWApO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gc2l6ZUluQ29uY2F0QXhpcy5sZW5ndGggLSAxKSB7XG4gICAgICBjb2RlTGluZXMucHVzaChcbiAgICAgICAgICAnXFx0JyArXG4gICAgICAgICAgYGVsc2UgeyByZXR1cm4gJHtzaXplSW5Db25jYXRBeGlzW2ldfTsgfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlTGluZXMucHVzaChcbiAgICAgICAgICAnXFx0JyArXG4gICAgICAgICAgYGVsc2UgaWYgKGluZGV4ID09ICR7aX0pIHsgcmV0dXJuICR7c2l6ZUluQ29uY2F0QXhpc1tpXX07IH1gKTtcbiAgICB9XG4gIH1cbiAgY29kZUxpbmVzLnB1c2goXG4gICAgICAnXFx0JyArXG4gICAgICAnfScpO1xuXG4gIHJldHVybiBjb2RlTGluZXMuam9pbignXFxuJyk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VDb25jYXRBdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPENvbmNhdEF0dHJpYnV0ZXM+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBDb25jYXRBdHRyaWJ1dGVzID0+XG4gICAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtheGlzOiBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCdheGlzJyl9KTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndG9vIGZldyBpbnB1dHMnKTtcbiAgfVxuXG4gIGNvbnN0IGlucHV0VHlwZSA9IGlucHV0c1swXS50eXBlO1xuICBjb25zdCBpbnB1dERpbWVuc2lvbmFsaXR5ID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuXG4gIC8vIFRPRE86IFN1cHBvcnQgc3RyaW5nIGNvbmNhdFxuICBpZiAoaW5wdXRUeXBlID09PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignc3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIHlldCcpO1xuICB9XG5cbiAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAvLyBtYWtlIHN1cmUgdHlwZXMgb2YgYWxsIGlucHV0cyBtYXRjaFxuICAgIGlmIChpbnB1dC50eXBlICE9PSBpbnB1dFR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgdGVuc29ycyBzaG91bGQgYmUgb25lIHR5cGUnKTtcbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgdGhlIGRpbWVuc2lvbmFsaXR5IG9mIGFsbCBpbnB1dHMgYXJlIHRoZSBzYW1lXG4gICAgaWYgKGlucHV0LmRpbXMubGVuZ3RoICE9PSBpbnB1dERpbWVuc2lvbmFsaXR5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHRlbnNvcnMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgc2hhcGUnKTtcbiAgICB9XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uLy4uLy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0dyYXBofSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7TUFYX0NMSVAsIE1JTl9DTElQfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7RnVuY3Rpb25UeXBlLCBHbHNsVmFsdWVGdW5jdGlvbn0gZnJvbSAnLi4vZ2xzbC1kZWZpbml0aW9ucyc7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgUHJvZ3JhbU1ldGFkYXRhLCBUZXh0dXJlVHlwZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2xzbEFicygpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCdhYnMnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsQWNvcygpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCdhY29zJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbEFzaW4oKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgnYXNpbicpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xBdGFuKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgcmV0dXJuIGdsc2xCdWlsdGluVW5hcnkoJ2F0YW4nKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsQ2VpbCgpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCdjZWlsJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbENvcygpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCdjb3MnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsRWx1KGFscGhhOiBudW1iZXIpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnZWx1JztcbiAgY29uc3QgYm9keSA9IGBcbiAgY29uc3QgZmxvYXQgYWxwaGEgPSBmbG9hdCgke2FscGhhfSk7XG5cbiAgZmxvYXQgJHtuYW1lfV8oZmxvYXQgYSkge1xuICAgIHJldHVybiBhID49IDAuMCA/IGE6IChleHAoYSkgLSAxLjApICogYWxwaGE7XG4gIH1cbiAgdmVjNCAke25hbWV9Xyh2ZWM0IHYpIHtcbiAgICByZXR1cm4gdmVjNCgke25hbWV9Xyh2LngpLCAke25hbWV9Xyh2LnkpLCAke25hbWV9Xyh2LnopLCAke25hbWV9Xyh2LncpKTtcbiAgfVxuICBgO1xuICByZXR1cm4ge2JvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsRXhwKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgcmV0dXJuIGdsc2xCdWlsdGluVW5hcnkoJ2V4cCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xGbG9vcigpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCdmbG9vcicpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xDbGlwKG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcik6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdjbGlwJztcbiAgY29uc3QgYm9keSA9IGBcbiAgY29uc3QgZmxvYXQgbWluID0gZmxvYXQoJHttaW59KTtcbiAgY29uc3QgZmxvYXQgbWF4ID0gZmxvYXQoJHttYXh9KTtcblxuICBmbG9hdCAke25hbWV9XyhmbG9hdCBhKSB7XG4gICAgcmV0dXJuIGNsYW1wKGEsIG1pbiwgbWF4KTtcbiAgfVxuICB2ZWM0ICR7bmFtZX1fKHZlYzQgdikge1xuICAgIHJldHVybiBjbGFtcCh2LCBtaW4sIG1heCk7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHtib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbElkZW50aXR5KCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdpbmRlbnRpdHknO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9XyhmbG9hdCBhKSB7XG4gICAgcmV0dXJuIGE7XG4gIH1cbiAgdmVjNCAke25hbWV9Xyh2ZWM0IHYpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxuICBgO1xuICByZXR1cm4ge2JvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsTGVha3lSZWx1KGFscGhhOiBudW1iZXIpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnbGVha3lSZWx1JztcbiAgY29uc3QgYm9keSA9IGBcbiAgY29uc3QgZmxvYXQgYWxwaGEgPSBmbG9hdCgke2FscGhhfSk7XG5cbiAgZmxvYXQgJHtuYW1lfV8oZmxvYXQgYSkge1xuICAgIHJldHVybiBhIDwgMC4wID8gYSAqIGFscGhhIDogYTtcbiAgfVxuICB2ZWM0ICR7bmFtZX1fKHZlYzQgdikge1xuICAgIHJldHVybiB2ZWM0KCR7bmFtZX1fKHYueCksICR7bmFtZX1fKHYueSksICR7bmFtZX1fKHYueiksICR7bmFtZX1fKHYudykpO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xMb2coKTogR2xzbFZhbHVlRnVuY3Rpb24ge1xuICByZXR1cm4gZ2xzbEJ1aWx0aW5VbmFyeSgnbG9nJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbE5lZygpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAnbmVnJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfV8oZmxvYXQgYSkge1xuICAgIHJldHVybiAtYTtcbiAgfVxuICB2ZWM0ICR7bmFtZX1fKHZlYzQgdikge1xuICAgIHJldHVybiAtdjtcbiAgfVxuICBgO1xuICByZXR1cm4ge2JvZHksIG5hbWUsIHR5cGU6IEZ1bmN0aW9uVHlwZS5WYWx1ZUJhc2VkfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsTm90KCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdub3QnO1xuICBjb25zdCBib2R5ID0gYFxuICBmbG9hdCAke25hbWV9XyhmbG9hdCBhKSB7XG4gICAgcmV0dXJuIGZsb2F0KCAhIGJvb2woYSkgKTtcbiAgfVxuICBib29sICR7bmFtZX1fKGJvb2wgYSkge1xuICAgIHJldHVybiAhYTtcbiAgfVxuICB2ZWM0ICR7bmFtZX1fKHZlYzQgdikge1xuICAgIHJldHVybiB2ZWM0KCFib29sKHYueCksICFib29sKHYueSksICFib29sKHYueiksICFib29sKHYudykpO1xuICB9XG4gIGJ2ZWM0ICR7bmFtZX1fKGJ2ZWM0IHYpIHtcbiAgICByZXR1cm4gYnZlYzQoIXYueCwgIXYueSwgIXYueiwgIXYudyk7XG4gIH1cbiAgYDtcbiAgcmV0dXJuIHtib2R5LCBuYW1lLCB0eXBlOiBGdW5jdGlvblR5cGUuVmFsdWVCYXNlZH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2xzbFNpbigpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIHJldHVybiBnbHNsQnVpbHRpblVuYXJ5KCdzaW4nKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsUmVsdSgpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IG5hbWUgPSAncmVsdSc7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX1fKGZsb2F0IGEpIHtcbiAgICByZXR1cm4gbWF4KCBhLCAwLjAgKTtcbiAgfVxuICB2ZWM0ICR7bmFtZX1fKHZlYzQgdikge1xuICAgIHJldHVybiBtYXgoIHYsIDAuMCApO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xTaWdtb2lkKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICdzaWdtb2lkJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfV8oZmxvYXQgYSkge1xuICAgIHJldHVybiAxLjAgLyAoMS4wICsgZXhwKC1hKSk7XG4gIH1cbiAgdmVjNCAke25hbWV9Xyh2ZWM0IHYpIHtcbiAgICByZXR1cm4gMS4wIC8gKDEuMCArIGV4cCgtdikpO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xTcXJ0KCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgcmV0dXJuIGdsc2xCdWlsdGluVW5hcnkoJ3NxcnQnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnbHNsVGFuKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgcmV0dXJuIGdsc2xCdWlsdGluVW5hcnkoJ3RhbicpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdsc2xUYW5oKCk6IEdsc2xWYWx1ZUZ1bmN0aW9uIHtcbiAgY29uc3QgbmFtZSA9ICd0YW5oJztcbiAgY29uc3QgYm9keSA9IGBcbiAgZmxvYXQgJHtuYW1lfV8oZmxvYXQgYSkge1xuICAgIGEgPSBjbGFtcChhLCAtMTAuLCAxMC4pO1xuICAgIGEgPSBleHAoMi4qYSk7XG4gICAgcmV0dXJuIChhIC0gMS4pIC8gKGEgKyAxLik7XG4gIH1cbiAgdmVjNCAke25hbWV9Xyh2ZWM0IHYpIHtcbiAgICB2ID0gY2xhbXAodiwgLTEwLiwgMTAuKTtcbiAgICB2ID0gZXhwKDIuKnYpO1xuICAgIHJldHVybiAodiAtIDEuKSAvICh2ICsgMS4pO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuZnVuY3Rpb24gZ2xzbEJ1aWx0aW5VbmFyeShuYW1lOiBzdHJpbmcpOiBHbHNsVmFsdWVGdW5jdGlvbiB7XG4gIGNvbnN0IGJvZHkgPSBgXG4gIGZsb2F0ICR7bmFtZX1fKGZsb2F0IGEpIHtcbiAgICByZXR1cm4gJHtuYW1lfShhKTtcbiAgfVxuICB2ZWM0ICR7bmFtZX1fKHZlYzQgdikge1xuICAgIHJldHVybiAke25hbWV9KHYpO1xuICB9XG4gIGA7XG4gIHJldHVybiB7Ym9keSwgbmFtZSwgdHlwZTogRnVuY3Rpb25UeXBlLlZhbHVlQmFzZWR9O1xufVxuXG4vLy8vL1xuLy8vLy9cbi8vLy8vXG5cbmNvbnN0IGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8gPVxuICAgIChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIG1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsIGlucHV0OiBUZW5zb3IsIGdsc2xGdW5jOiBHbHNsVmFsdWVGdW5jdGlvbik6XG4gICAgICAgIFByb2dyYW1JbmZvID0+IHtcbiAgICAgICAgICBjb25zdCB0ZXh0dXJlVHlwZSA9IGhhbmRsZXIuc2Vzc2lvbi5wYWNrID8gVGV4dHVyZVR5cGUucGFja2VkIDogVGV4dHVyZVR5cGUudW5wYWNrZWQ7XG4gICAgICAgICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgICAgIG91dHB1dDoge2RpbXM6IGlucHV0LmRpbXMsIHR5cGU6IGlucHV0LnR5cGUsIHRleHR1cmVUeXBlfSxcbiAgICAgICAgICAgIHNoYWRlclNvdXJjZTogYFxuICAgICAke2dsc2xGdW5jLmJvZHl9XG4gICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICB2ZWM0IHYgPSAke2dsc2wudGV4dHVyZTJEfShBLCBUZXhDb29yZHMpO1xuICAgICAgIHYgPSAke2dsc2xGdW5jLm5hbWV9Xyh2KTtcbiAgICAgICAke2dsc2wub3V0cHV0fSA9IHY7XG4gICAgIH1cbiAgICAgYCxcbiAgICAgICAgICAgIGhhc01haW46IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG5jb25zdCBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvTG9hZGVyID1cbiAgICAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dDogVGVuc29yLCBnbHNsRnVuYzogR2xzbFZhbHVlRnVuY3Rpb24sIGNhY2hlS2V5Pzogc3RyaW5nKTpcbiAgICAgICAgUHJvZ3JhbUluZm9Mb2FkZXIgPT4ge1xuICAgICAgICAgIGNvbnN0IHRleHR1cmVUeXBlID0gaGFuZGxlci5zZXNzaW9uLnBhY2sgPyBUZXh0dXJlVHlwZS5wYWNrZWQgOiBUZXh0dXJlVHlwZS51bnBhY2tlZDtcbiAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHtuYW1lOiBnbHNsRnVuYy5uYW1lLCBpbnB1dFR5cGVzOiBbdGV4dHVyZVR5cGVdLCBpbnB1dE5hbWVzOiBbJ0EnXSwgY2FjaGVIaW50OiBjYWNoZUtleX07XG4gICAgICAgICAgcmV0dXJuIHsuLi5tZXRhZGF0YSwgZ2V0OiAoKSA9PiBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGhhbmRsZXIsIG1ldGFkYXRhLCBpbnB1dCwgZ2xzbEZ1bmMpfTtcbiAgICAgICAgfTtcblxuZXhwb3J0IGNvbnN0IGFicyA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOlxuICAgIFRlbnNvcltdID0+IFtoYW5kbGVyLnJ1bihjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0c1swXSwgZ2xzbEFicygpKSwgaW5wdXRzKV07XG5cbmV4cG9ydCBjb25zdCBhY29zID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6XG4gICAgVGVuc29yW10gPT4gW2hhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsQWNvcygpKSwgaW5wdXRzKV07XG5cbmV4cG9ydCBjb25zdCBhc2luID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6XG4gICAgVGVuc29yW10gPT4gW2hhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsQXNpbigpKSwgaW5wdXRzKV07XG5cbmV4cG9ydCBjb25zdCBhdGFuID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6XG4gICAgVGVuc29yW10gPT4gW2hhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsQXRhbigpKSwgaW5wdXRzKV07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2xpcEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBtaW46IG51bWJlcjtcbiAgcmVhZG9ubHkgbWF4OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBjbGlwID1cbiAgICAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBDbGlwQXR0cmlidXRlcyk6IFRlbnNvcltdID0+IFtoYW5kbGVyLnJ1bihcbiAgICAgICAgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihcbiAgICAgICAgICAgIGhhbmRsZXIsIGlucHV0c1swXSwgZ2xzbENsaXAoYXR0cmlidXRlcy5taW4sIGF0dHJpYnV0ZXMubWF4KSwgYXR0cmlidXRlcy5jYWNoZUtleSksXG4gICAgICAgIGlucHV0cyldO1xuXG5leHBvcnQgY29uc3QgcGFyc2VDbGlwQXR0cmlidXRlcyA9IChub2RlOiBHcmFwaC5Ob2RlKTogQ2xpcEF0dHJpYnV0ZXMgPT4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KFxuICAgIHttaW46IG5vZGUuYXR0cmlidXRlcy5nZXRGbG9hdCgnbWluJywgTUlOX0NMSVApLCBtYXg6IG5vZGUuYXR0cmlidXRlcy5nZXRGbG9hdCgnbWF4JywgTUFYX0NMSVApfSk7XG5cbmV4cG9ydCBjb25zdCBjbGlwVjExID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IGdlbmVyYXRlQ2xpcEF0dHJpYnV0ZXNGcm9tSW5wdXRzKGhhbmRsZXIsIGlucHV0cyk7XG4gIHJldHVybiBjbGlwKGhhbmRsZXIsIFtpbnB1dHNbMF1dLCBhdHRyaWJ1dGVzKTtcbn07XG5cbmNvbnN0IGdlbmVyYXRlQ2xpcEF0dHJpYnV0ZXNGcm9tSW5wdXRzID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IENsaXBBdHRyaWJ1dGVzID0+IHtcbiAgaWYgKGlucHV0cy5sZW5ndGggPj0gMyAmJlxuICAgICAgKCFoYW5kbGVyLnNlc3Npb24uaXNJbml0aWFsaXplcihpbnB1dHNbMV0uZGF0YUlkKSB8fCAhaGFuZGxlci5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIoaW5wdXRzWzJdLmRhdGFJZCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkeW5hbWljIGNsaXAgYXR0cmlidXRlcyBhcmUgbm90IGFsbG93ZWQnKTtcbiAgfVxuXG4gIGNvbnN0IG1pbiA9IChpbnB1dHMubGVuZ3RoID49IDMpID8gaW5wdXRzWzFdLm51bWJlckRhdGFbMF0gOiBNSU5fQ0xJUDtcbiAgY29uc3QgbWF4ID0gKGlucHV0cy5sZW5ndGggPj0gMykgPyBpbnB1dHNbMl0ubnVtYmVyRGF0YVswXSA6IE1BWF9DTElQO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHttaW4sIG1heH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGNlaWwgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTpcbiAgICBUZW5zb3JbXSA9PiBbaGFuZGxlci5ydW4oY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHNbMF0sIGdsc2xDZWlsKCkpLCBpbnB1dHMpXTtcblxuZXhwb3J0IGNvbnN0IGNvcyA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOlxuICAgIFRlbnNvcltdID0+IFtoYW5kbGVyLnJ1bihjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0c1swXSwgZ2xzbENvcygpKSwgaW5wdXRzKV07XG5cbmV4cG9ydCBpbnRlcmZhY2UgRWx1QXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGFscGhhOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBlbHUgPVxuICAgIChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IEVsdUF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiBbaGFuZGxlci5ydW4oXG4gICAgICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsRWx1KGF0dHJpYnV0ZXMuYWxwaGEpLCBhdHRyaWJ1dGVzLmNhY2hlS2V5KSxcbiAgICAgICAgaW5wdXRzKV07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUVsdUF0dHJpYnV0ZXMgPSAobm9kZTogR3JhcGguTm9kZSk6IEVsdUF0dHJpYnV0ZXMgPT5cbiAgICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe2FscGhhOiBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ2FscGhhJywgMS4wKX0pO1xuXG5leHBvcnQgY29uc3QgZXhwID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6XG4gICAgVGVuc29yW10gPT4gW2hhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsRXhwKCkpLCBpbnB1dHMpXTtcblxuZXhwb3J0IGNvbnN0IGZsb29yID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6XG4gICAgVGVuc29yW10gPT4gW2hhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsRmxvb3IoKSksIGlucHV0cyldO1xuXG5leHBvcnQgY29uc3QgaWRlbnRpdHkgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTpcbiAgICBUZW5zb3JbXSA9PiBbaGFuZGxlci5ydW4oY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHNbMF0sIGdsc2xJZGVudGl0eSgpKSwgaW5wdXRzKV07XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGVha3lSZWx1QXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGFscGhhOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBsZWFreVJlbHUgPVxuICAgIChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IExlYWt5UmVsdUF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiBbaGFuZGxlci5ydW4oXG4gICAgICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsTGVha3lSZWx1KGF0dHJpYnV0ZXMuYWxwaGEpLCBhdHRyaWJ1dGVzLmNhY2hlS2V5KSxcbiAgICAgICAgaW5wdXRzKV07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUxlYWt5UmVsdUF0dHJpYnV0ZXMgPSAobm9kZTogR3JhcGguTm9kZSk6IExlYWt5UmVsdUF0dHJpYnV0ZXMgPT5cbiAgICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe2FscGhhOiBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ2FscGhhJywgMC4wMSl9KTtcblxuZXhwb3J0IGNvbnN0IGxvZyA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOlxuICAgIFRlbnNvcltdID0+IFtoYW5kbGVyLnJ1bihjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0c1swXSwgZ2xzbExvZygpKSwgaW5wdXRzKV07XG5cbmV4cG9ydCBjb25zdCBuZWcgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTpcbiAgICBUZW5zb3JbXSA9PiBbaGFuZGxlci5ydW4oY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHNbMF0sIGdsc2xOZWcoKSksIGlucHV0cyldO1xuXG5leHBvcnQgY29uc3Qgbm90ID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6XG4gICAgVGVuc29yW10gPT4gW2hhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsTm90KCkpLCBpbnB1dHMpXTtcblxuZXhwb3J0IGNvbnN0IHJlbHUgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTpcbiAgICBUZW5zb3JbXSA9PiBbaGFuZGxlci5ydW4oY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHNbMF0sIGdsc2xSZWx1KCkpLCBpbnB1dHMpXTtcblxuZXhwb3J0IGNvbnN0IHNpZ21vaWQgPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTpcbiAgICBUZW5zb3JbXSA9PiBbaGFuZGxlci5ydW4oY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHNbMF0sIGdsc2xTaWdtb2lkKCkpLCBpbnB1dHMpXTtcblxuZXhwb3J0IGNvbnN0IHNpbiA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOlxuICAgIFRlbnNvcltdID0+IFtoYW5kbGVyLnJ1bihjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0c1swXSwgZ2xzbFNpbigpKSwgaW5wdXRzKV07XG5cbmV4cG9ydCBjb25zdCBzcXJ0ID0gKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6XG4gICAgVGVuc29yW10gPT4gW2hhbmRsZXIucnVuKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm9Mb2FkZXIoaGFuZGxlciwgaW5wdXRzWzBdLCBnbHNsU3FydCgpKSwgaW5wdXRzKV07XG5cbmV4cG9ydCBjb25zdCB0YW4gPSAoaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTpcbiAgICBUZW5zb3JbXSA9PiBbaGFuZGxlci5ydW4oY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mb0xvYWRlcihoYW5kbGVyLCBpbnB1dHNbMF0sIGdsc2xUYW4oKSksIGlucHV0cyldO1xuXG5leHBvcnQgY29uc3QgdGFuaCA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOlxuICAgIFRlbnNvcltdID0+IFtoYW5kbGVyLnJ1bihjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvTG9hZGVyKGhhbmRsZXIsIGlucHV0c1swXSwgZ2xzbFRhbmgoKSksIGlucHV0cyldO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlJztcbmltcG9ydCB7TUFYX0NMSVAsIE1JTl9DTElQfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7R2xzbFZhbHVlRnVuY3Rpb259IGZyb20gJy4uL2dsc2wtZGVmaW5pdGlvbnMnO1xuXG5pbXBvcnQge2dsc2xDbGlwLCBnbHNsUmVsdSwgZ2xzbFNpZ21vaWR9IGZyb20gJy4vdW5hcnktb3AnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMge1xuICByZWFkb25seSBhY3RpdmF0aW9uOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGNsaXBNaW4/OiBudW1iZXI7XG4gIHJlYWRvbmx5IGNsaXBNYXg/OiBudW1iZXI7XG4gIHJlYWRvbmx5IGFjdGl2YXRpb25DYWNoZUtleTogc3RyaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYXR0cmlidXRlczogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcykge1xuICBsZXQgZnVuYzogR2xzbFZhbHVlRnVuY3Rpb247XG4gIHN3aXRjaCAoYXR0cmlidXRlcy5hY3RpdmF0aW9uKSB7XG4gICAgY2FzZSAnUmVsdSc6XG4gICAgICBmdW5jID0gZ2xzbFJlbHUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1NpZ21vaWQnOlxuICAgICAgZnVuYyA9IGdsc2xTaWdtb2lkKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdDbGlwJzpcbiAgICAgIGZ1bmMgPSBnbHNsQ2xpcChhdHRyaWJ1dGVzLmNsaXBNaW4hLCBhdHRyaWJ1dGVzLmNsaXBNYXghKTtcbiAgICAgIGJyZWFrO1xuICAgIC8vIFRPRE86IGFkZGluZyBvdGhlciBhY3RpdmF0aW9ucyB0aGF0IGNhbiBiZSBmdXNlZC5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHthY3RpdmF0aW9uRnVuY3Rpb246ICcnLCBhcHBseUFjdGl2YXRpb246ICcnfTtcbiAgfVxuXG4gIGNvbnN0IGFjdGl2YXRpb25OYW1lID0gZnVuYy5uYW1lO1xuICBjb25zdCBhY3RpdmF0aW9uRnVuY3Rpb24gPSBmdW5jLmJvZHk7XG4gIGNvbnN0IGFwcGx5QWN0aXZhdGlvbiA9IGB2YWx1ZSA9ICR7YWN0aXZhdGlvbk5hbWV9Xyh2YWx1ZSk7YDtcbiAgcmV0dXJuIHthY3RpdmF0aW9uRnVuY3Rpb24sIGFwcGx5QWN0aXZhdGlvbn07XG59XG5cbmV4cG9ydCBjb25zdCBwYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogQXR0cmlidXRlKTogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGFjdGl2YXRpb24gPSBhdHRyaWJ1dGVzLmdldFN0cmluZygnYWN0aXZhdGlvbicsICcnKTtcblxuICBpZiAoYWN0aXZhdGlvbiA9PT0gJ0NsaXAnKSB7XG4gICAgY29uc3QgW2NsaXBNaW4sIGNsaXBNYXhdID0gYXR0cmlidXRlcy5nZXRGbG9hdHMoJ2FjdGl2YXRpb25fcGFyYW1zJywgW01JTl9DTElQLCBNQVhfQ0xJUF0pO1xuICAgIHJldHVybiB7YWN0aXZhdGlvbiwgY2xpcE1heCwgY2xpcE1pbiwgYWN0aXZhdGlvbkNhY2hlS2V5OiBgJHthY3RpdmF0aW9ufToke2NsaXBNaW59LCR7Y2xpcE1heH1gfTtcbiAgfVxuICByZXR1cm4ge2FjdGl2YXRpb24sIGFjdGl2YXRpb25DYWNoZUtleTogYWN0aXZhdGlvbn07XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0xvZ2dlcn0gZnJvbSAnLi4vLi4vLi4vaW5zdHJ1bWVudCc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7Z2V0R2xzbH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFByb2dyYW1JbmZvTG9hZGVyLCBQcm9ncmFtTWV0YWRhdGEsIFRleHR1cmVUeXBlfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y2FsY3VsYXRlT3V0cHV0U2hhcGUsIENvbnZBdHRyaWJ1dGVzfSBmcm9tICcuL2NvbnYnO1xuaW1wb3J0IHtnZXRBY3RpdmF0aW9uU25pcHBldH0gZnJvbSAnLi9mdXNlLXV0aWxzJztcblxuY29uc3QgY3JlYXRlVW5wYWNrZWRHcm91cGVkQ29udlByb2dyYW1NZXRhZGF0YSA9IChoYXNCaWFzOiBib29sZWFuLCBjYWNoZUhpbnQ6IHN0cmluZyk6IFByb2dyYW1NZXRhZGF0YSA9PiAoe1xuICBuYW1lOiAnR3JvdXBlZENvbnYnLFxuICBpbnB1dE5hbWVzOiBoYXNCaWFzID8gWydYJywgJ1cnLCAnQmlhcyddIDogWydYJywgJ1cnXSxcbiAgaW5wdXRUeXBlczogaGFzQmlhcyA/IFtUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBbVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXSxcbiAgY2FjaGVIaW50XG59KTtcblxuY29uc3QgY3JlYXRlVW5wYWNrZWRHcm91cGVkQ29udlByb2dyYW1JbmZvID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvcltdLCBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLFxuICAgICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID4gMjtcbiAgICAgIGNvbnN0IHByb2Nlc3NCaWFzID0gaGFzQmlhcyA/ICd2YWx1ZSArPSBnZXRCaWFzKG91dHB1dF9jaGFubmVsKTsnIDogJyc7XG4gICAgICBjb25zdCB4U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICAgICAgY29uc3Qgd1NoYXBlID0gaW5wdXRzWzFdLmRpbXMuc2xpY2UoKTtcbiAgICAgIGNvbnN0IG91dHB1dENoYW5uZWxzUGVyR3JvdXAgPSB3U2hhcGVbMF0gLyBhdHRyaWJ1dGVzLmdyb3VwO1xuICAgICAgTG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgICAgJ0dyb3VwZWRDb252JyxcbiAgICAgICAgICBgYXV0cFBhZDoke2F0dHJpYnV0ZXMuYXV0b1BhZH0sIGRpbGF0aW9uczoke2F0dHJpYnV0ZXMuZGlsYXRpb25zfSwgZ3JvdXA6JHthdHRyaWJ1dGVzLmdyb3VwfSwga2VybmVsU2hhcGU6JHtcbiAgICAgICAgICAgICAgYXR0cmlidXRlcy5rZXJuZWxTaGFwZX0sIHBhZHM6JHthdHRyaWJ1dGVzLnBhZHN9LCBzdHJpZGVzOiR7YXR0cmlidXRlcy5zdHJpZGVzfWApO1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPVxuICAgICAgICAgIGNhbGN1bGF0ZU91dHB1dFNoYXBlKHhTaGFwZSwgd1NoYXBlLCBhdHRyaWJ1dGVzLmRpbGF0aW9ucywgYXR0cmlidXRlcy5wYWRzLCBhdHRyaWJ1dGVzLnN0cmlkZXMpO1xuICAgICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgICAgY29uc3Qge2FjdGl2YXRpb25GdW5jdGlvbiwgYXBwbHlBY3RpdmF0aW9ufSA9IGdldEFjdGl2YXRpb25TbmlwcGV0KGF0dHJpYnV0ZXMpO1xuXG4gICAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMigke2F0dHJpYnV0ZXMuc3RyaWRlc1swXX0sICR7YXR0cmlidXRlcy5zdHJpZGVzWzFdfSk7XG4gIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke2F0dHJpYnV0ZXMucGFkc1swXX0sICR7YXR0cmlidXRlcy5wYWRzWzFdfSk7XG4gICR7YWN0aXZhdGlvbkZ1bmN0aW9ufVxuICB2b2lkIG1haW4oKSB7XG4gICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgaW50IGJhdGNoID0gY29vcmRzLng7XG4gICAgaW50IG91dHB1dF9jaGFubmVsID0gY29vcmRzLnk7XG4gICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnp3ICogc3RyaWRlcyAtIHBhZHM7XG4gICAgaW50IGdyb3VwX2lkID0gb3V0cHV0X2NoYW5uZWwgLyAke291dHB1dENoYW5uZWxzUGVyR3JvdXB9O1xuXG4gICAgZmxvYXQgdmFsdWUgPSAwLjA7XG4gICAgZm9yIChpbnQgd0luQ2hhbm5lbCA9IDA7IHdJbkNoYW5uZWwgPCAke3dTaGFwZVsxXX07IHdJbkNoYW5uZWwrKykge1xuICAgICAgaW50IGlucHV0X2NoYW5uZWwgPSBncm91cF9pZCAqICR7d1NoYXBlWzFdfSArIHdJbkNoYW5uZWw7XG4gICAgICBmb3IgKGludCB3SGVpZ2h0ID0gMDsgd0hlaWdodCA8ICR7d1NoYXBlWzJdfTsgd0hlaWdodCsrKSB7XG4gICAgICAgIGludCB4SGVpZ2h0ID0geFJDQ29ybmVyLnggKyB3SGVpZ2h0ICogJHthdHRyaWJ1dGVzLmRpbGF0aW9uc1swXX07XG5cbiAgICAgICAgaWYgKHhIZWlnaHQgPCAwIHx8IHhIZWlnaHQgPj0gJHt4U2hhcGVbMl19KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGludCB3V2lkdGggPSAwOyB3V2lkdGggPCAke3dTaGFwZVszXX07IHdXaWR0aCsrKSB7XG4gICAgICAgICAgaW50IHhXaWR0aCA9IHhSQ0Nvcm5lci55ICsgd1dpZHRoICogJHthdHRyaWJ1dGVzLmRpbGF0aW9uc1sxXX07XG4gICAgICAgICAgaWYgKHhXaWR0aCA8IDAgfHwgeFdpZHRoID49ICR7eFNoYXBlWzNdfSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmxvYXQgeFZhbCA9IGdldFgoYmF0Y2gsIGlucHV0X2NoYW5uZWwsIHhXaWR0aCwgeEhlaWdodCk7XG4gICAgICAgICAgZmxvYXQgd1ZhbCA9IGdldFcob3V0cHV0X2NoYW5uZWwsIHdJbkNoYW5uZWwsIHdXaWR0aCwgd0hlaWdodCk7XG4gICAgICAgICAgdmFsdWUgKz0geFZhbCp3VmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgICR7cHJvY2Vzc0JpYXN9XG4gICAgJHthcHBseUFjdGl2YXRpb259XG4gICAgJHtnbHNsLm91dHB1dH0gPSB2ZWM0KHZhbHVlLCAuMCwgLjAsIC4wKTtcbiAgfVxuYDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICBvdXRwdXQ6IHtkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgICAgIHNoYWRlclNvdXJjZSxcbiAgICAgICAgaGFzTWFpbjogdHJ1ZSxcbiAgICAgIH07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVVucGFja2VkR3JvdXBlZENvbnZQcm9ncmFtSW5mb0xvYWRlciA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiByZWFkb25seSBUZW5zb3JbXSwgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMpOlxuICAgICAgICBQcm9ncmFtSW5mb0xvYWRlciA9PiB7XG4gICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBjcmVhdGVVbnBhY2tlZEdyb3VwZWRDb252UHJvZ3JhbU1ldGFkYXRhKGlucHV0cy5sZW5ndGggPiAyLCBhdHRyaWJ1dGVzLmNhY2hlS2V5KTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgICAgICBnZXQ6ICgpID0+IGNyZWF0ZVVucGFja2VkR3JvdXBlZENvbnZQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIG1ldGFkYXRhLCBhdHRyaWJ1dGVzKVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtnZXRHbHNsfSBmcm9tICcuLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUHJvZ3JhbUluZm9Mb2FkZXIsIFByb2dyYW1NZXRhZGF0YSwgVGV4dHVyZVR5cGV9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtDb252QXR0cmlidXRlc30gZnJvbSAnLi9jb252JztcbmltcG9ydCB7dW5wYWNrRnJvbUNoYW5uZWx9IGZyb20gJy4vcGFja2luZy11dGlscyc7XG5cbmNvbnN0IGNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1NZXRhZGF0YSA9IChjYWNoZUhpbnQ6IHN0cmluZykgPT4gKHtcbiAgbmFtZTogJ0ltMkNvbCAocGFja2VkKScsXG4gIGlucHV0TmFtZXM6IFsnQSddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUucGFja2VkXSxcbiAgY2FjaGVIaW50LFxufSk7XG5cbmNvbnN0IGNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1JbmZvID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLCB4OiBUZW5zb3IsIHc6IFRlbnNvcixcbiAgICAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IHhzaGFwZSA9IHguZGltcztcbiAgICAgIGNvbnN0IHdzaGFwZSA9IHcuZGltcztcbiAgICAgIGNvbnN0IHJvd0RpbSA9IDI7XG4gICAgICBjb25zdCBjb2xEaW0gPSAzO1xuICAgICAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICAgIGNvbnN0IGltMmNvbFNoYXBlID0gW3dzaGFwZVsxXSAqIHdzaGFwZVsyXSAqIHdzaGFwZVszXSwgb3V0cHV0U2hhcGVbMl0gKiBvdXRwdXRTaGFwZVszXV07XG4gICAgICBjb25zdCBrZXJuZWxTaXplID0gd3NoYXBlWzJdICogd3NoYXBlWzNdO1xuICAgICAgY29uc3QgdW5wYWNrQ2hhbm5lbCA9IHVucGFja0Zyb21DaGFubmVsKCk7XG4gICAgICBjb25zdCBnbHNsID0gZ2V0R2xzbChpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgICBsZXQgdW5yb2xsZWQgPSAnJztcblxuICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDw9IDE7IHJvdysrKSB7XG4gICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8PSAxOyBjb2wrKykge1xuICAgICAgICAgIHVucm9sbGVkICs9IGBcbiAgICAgICAgICAgIGJsb2NrSW5kZXggPSByYy54ICsgJHtjb2x9O1xuICAgICAgICAgICAgcG9zID0gcmMueSArICR7cm93fTtcblxuICAgICAgICAgICAgaWYoYmxvY2tJbmRleCA8ICR7aW0yY29sU2hhcGVbMV19ICYmIHBvcyA8ICR7aW0yY29sU2hhcGVbMF19KSB7XG4gICAgICAgICAgICAgIG9mZnNldFkgPSBpbnQoYmxvY2tJbmRleCAvICgke291dHB1dFNoYXBlW3JhbmsgLSAxXX0pKSAqICR7YXR0cmlidXRlcy5zdHJpZGVzWzBdfSAtXG4gICAgICAgICAgICAgICAgJHthdHRyaWJ1dGVzLnBhZHNbMF19O1xuICAgICAgICAgICAgICBkMCA9IG9mZnNldFkgKyAke2F0dHJpYnV0ZXMuZGlsYXRpb25zWzBdfSAqIChpbW9kKHBvcywgJHtrZXJuZWxTaXplfSkgLyAke3dzaGFwZVsyXX0pO1xuXG4gICAgICAgICAgICAgIGlmKGQwIDwgJHt4c2hhcGVbcm93RGltXX0gJiYgZDAgPj0gMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldFggPSBpbW9kKGJsb2NrSW5kZXgsICR7b3V0cHV0U2hhcGVbcmFuayAtIDFdfSkgKiAke2F0dHJpYnV0ZXMuc3RyaWRlc1sxXX0gLVxuICAgICAgICAgICAgICAgICAgJHthdHRyaWJ1dGVzLnBhZHNbMV19O1xuICAgICAgICAgICAgICAgIGQxID0gb2Zmc2V0WCArICR7YXR0cmlidXRlcy5kaWxhdGlvbnNbMV19ICogaW1vZChpbW9kKHBvcywgJHtrZXJuZWxTaXplfSksICR7d3NoYXBlWzJdfSk7XG5cbiAgICAgICAgICAgICAgICBpZihkMSA8ICR7eHNoYXBlW2NvbERpbV19ICYmIGQxID49IDApIHtcblxuICAgICAgICAgICAgICAgICAgY2ggPSBpbnQoZmxvYXQocG9zKS8gJHtrZXJuZWxTaXplfS4pO1xuICAgICAgICAgICAgICAgICAgICBpbm5lckRpbXMgPSB2ZWMyKGQwLCBkMSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFske3JvdyAqIDIgKyBjb2x9XSA9IGdldENoYW5uZWwoXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0QSgwLCBjaCwgaW50KGlubmVyRGltcy54KSxcbiAgICAgICAgICAgICAgICAgICAgICBpbnQoaW5uZXJEaW1zLnkpKSwgaW5uZXJEaW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgJHt1bnBhY2tDaGFubmVsfVxuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWMyIHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgICAgdmVjNCByZXN1bHQgPSB2ZWM0KDAuMCk7XG4gICAgICAgICAgaW50IGJsb2NrSW5kZXgsIHBvcywgb2Zmc2V0WSwgZDAsIG9mZnNldFgsIGQxLCBjaDtcbiAgICAgICAgICB2ZWMyIGlubmVyRGltcztcbiAgICAgICAgICAke3Vucm9sbGVkfVxuICAgICAgICAgICR7Z2xzbC5vdXRwdXR9ID0gcmVzdWx0O1xuICAgICAgfVxuICAgICAgICAgICAgYDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICBvdXRwdXQ6IHtkaW1zOiBpbTJjb2xTaGFwZSwgdHlwZTogeC50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUucGFja2VkfSxcbiAgICAgICAgc2hhZGVyU291cmNlLFxuICAgICAgICBoYXNNYWluOiB0cnVlXG4gICAgICB9O1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQYWNrZWRJbTJDb2xQcm9ncmFtSW5mb0xvYWRlciA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgeDogVGVuc29yLCB3OiBUZW5zb3IsIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mb0xvYWRlciA9PiB7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IGNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1NZXRhZGF0YShhdHRyaWJ1dGVzLmNhY2hlS2V5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICBnZXQ6ICgpID0+IGNyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIG1ldGFkYXRhLCB4LCB3LCBvdXRwdXRTaGFwZSwgYXR0cmlidXRlcylcbiAgICAgIH07XG4gICAgfTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHtPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9ufSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge0Jyb2FkY2FzdFV0aWwsIFNoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUHJvZ3JhbUluZm9Mb2FkZXIsIFByb2dyYW1NZXRhZGF0YSwgVGV4dHVyZVR5cGV9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7Z2V0Q29vcmRzRGF0YVR5cGUsIGdldEdsQ2hhbm5lbHN9IGZyb20gJy4uL3V0aWxzJztcblxuaW1wb3J0IHtnZXRBY3RpdmF0aW9uU25pcHBldCwgSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcywgcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzfSBmcm9tICcuL2Z1c2UtdXRpbHMnO1xuaW1wb3J0IHtjcmVhdGVQYWNrZWRNYXRtdWxQcm9ncmFtSW5mb0xvYWRlcn0gZnJvbSAnLi9tYXRtdWwtcGFjayc7XG5cbmV4cG9ydCBjb25zdCBtYXRNdWw6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248SW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcz4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiB7XG4gICAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuXG4gICAgICBpZiAoaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLnBhY2spIHtcbiAgICAgICAgcmV0dXJuIFtpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICAgICAgICAgIGNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvTG9hZGVyKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcyksIGlucHV0cyldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtpbmZlcmVuY2VIYW5kbGVyLnJ1bihjcmVhdGVNYXRtdWxQcm9ncmFtSW5mb0xvYWRlcihpbnB1dHMsIGF0dHJpYnV0ZXMpLCBpbnB1dHMpXTtcbiAgICAgIH1cbiAgICB9O1xuXG5leHBvcnQgY29uc3QgcGFyc2VNYXRNdWxBdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXM+ID1cbiAgICAobm9kZTogR3JhcGguTm9kZSk6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMgPT4gcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzKG5vZGUuYXR0cmlidXRlcyk7XG5cbmNvbnN0IGNyZWF0ZU1hdG11bFByb2dyYW1NZXRhZGF0YSA9IChoYXNCaWFzOiBib29sZWFuLCBjYWNoZUhpbnQ6IHN0cmluZykgPT4gKHtcbiAgbmFtZTogJ01hdE11bCcsXG4gIGlucHV0TmFtZXM6IGhhc0JpYXMgPyBbJ0EnLCAnQicsICdCaWFzJ10gOiBbJ0EnLCAnQiddLFxuICBpbnB1dFR5cGVzOiBoYXNCaWFzID8gW1RleHR1cmVUeXBlLnVucGFja2VkLCBUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWRdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIFtUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxuICBjYWNoZUhpbnRcbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVNYXRtdWxQcm9ncmFtSW5mbyhcbiAgICBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLCBpbnB1dHM6IFRlbnNvcltdLCBhY3RpdmF0aW9uQXR0cmlidXRlczogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvIHtcbiAgY29uc3QgYVNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGJTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IEJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKGFTaGFwZSwgYlNoYXBlLCB0cnVlKTtcbiAgaWYgKCFvdXRwdXRTaGFwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCB1c2UgbWF0bXVsIG9uIHRoZSBnaXZlbiB0ZW5zb3JzJyk7XG4gIH1cbiAgY29uc3QgY29vcmRzRGF0YVR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICBjb25zdCBhbGxHbENoYW5uZWxzID0gZ2V0R2xDaGFubmVscygpO1xuICBjb25zdCB7YWN0aXZhdGlvbkZ1bmN0aW9uLCBhcHBseUFjdGl2YXRpb259ID0gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYWN0aXZhdGlvbkF0dHJpYnV0ZXMpO1xuXG4gIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID4gMjtcbiAgY29uc3QgcHJvY2Vzc0JpYXMgPSBoYXNCaWFzID8gJ3ZhbHVlICs9IGdldEJpYXNGb3JNYXRtdWwoKTsnIDogJyc7XG4gIGNvbnN0IGdldEJpYXNGb3JNYXRtdWxTbmlwcGV0ID1cbiAgICAgIGhhc0JpYXMgPyBgJHtnZXRCaWFzRm9yTWF0bXVsKGNvb3Jkc0RhdGFUeXBlLCBhbGxHbENoYW5uZWxzLCBpbnB1dHNbMl0uZGltcywgb3V0cHV0U2hhcGUsIGZhbHNlKX1gIDogJyc7XG5cbiAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgY29uc3QgYXJhbmsgPSBhU2hhcGUubGVuZ3RoO1xuICBjb25zdCBicmFuayA9IGJTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IHNoYXJlZERpbSA9IGFTaGFwZVthU2hhcGUubGVuZ3RoIC0gMV07XG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAke2FjdGl2YXRpb25GdW5jdGlvbn1cbiAgICAke2dldEJpYXNGb3JNYXRtdWxTbmlwcGV0fVxuICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgaW50IGFbJHthcmFua31dO1xuICAgICAgICBpbnQgYlske2JyYW5rfV07XG4gICAgICAgIGJjYXN0TWF0bXVsSW5kaWNlc19BKGluZGljZXMsIGEpO1xuICAgICAgICBiY2FzdE1hdG11bEluZGljZXNfQihpbmRpY2VzLCBiKTtcblxuICAgICAgICBmbG9hdCB2YWx1ZTtcbiAgICAgICAgZm9yIChpbnQgaz0wOyBrPCR7c2hhcmVkRGltfTsgKytrKSB7XG4gICAgICAgICAgICBhWyR7YXJhbmsgLSAxfV0gPSBrO1xuICAgICAgICAgICAgYlske2JyYW5rIC0gMn1dID0gaztcbiAgICAgICAgICAgIHZhbHVlICs9IF9BKGEpICogX0IoYik7XG4gICAgICAgIH1cbiAgICAgICAgJHtwcm9jZXNzQmlhc31cbiAgICAgICAgJHthcHBseUFjdGl2YXRpb259XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9YDtcbiAgcmV0dXJuIHtcbiAgICAuLi5tZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHtkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgc2hhZGVyU291cmNlLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXIoXG4gICAgaW5wdXRzOiBUZW5zb3JbXSwgYWN0aXZhdGlvbkF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mb0xvYWRlciB7XG4gIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlTWF0bXVsUHJvZ3JhbU1ldGFkYXRhKGlucHV0cy5sZW5ndGggPiAyLCBhY3RpdmF0aW9uQXR0cmlidXRlcy5hY3RpdmF0aW9uQ2FjaGVLZXkpO1xuICByZXR1cm4gey4uLm1ldGFkYXRhLCBnZXQ6ICgpID0+IGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvKG1ldGFkYXRhLCBpbnB1dHMsIGFjdGl2YXRpb25BdHRyaWJ1dGVzKX07XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignTWF0TXVsIHJlcXVpcmVzIDIgaW5wdXRzLicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zW2lucHV0c1swXS5kaW1zLmxlbmd0aCAtIDFdICE9PSBpbnB1dHNbMV0uZGltc1tpbnB1dHNbMV0uZGltcy5sZW5ndGggLSAyXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2hhcmVkIGRpbWVuc2lvbiBkb2VzIG5vdCBtYXRjaC4nKTtcbiAgfVxuXG4gIGlmICgoaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0NjQnKSB8fFxuICAgICAgKGlucHV0c1sxXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzFdLnR5cGUgIT09ICdmbG9hdDY0JykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0cyBzaG91bGQgYmUgZmxvYXQgdHlwZScpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS50eXBlICE9PSBpbnB1dHNbMV0udHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW5wdXRzIHR5cGVzIHNob3VsZCBtYXRjaCcpO1xuICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qmlhc0Zvck1hdG11bChcbiAgICBjb29yZHNEYXRhVHlwZTogc3RyaW5nLCBhbGxHbENoYW5uZWxzOiByZWFkb25seSBzdHJpbmdbXSwgaW5TaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIG91dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBpc1BhY2tlZDogYm9vbGVhbik6IHN0cmluZyB7XG4gIGxldCB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSAnJztcbiAgY29uc3QgaW5SYW5rID0gaW5TaGFwZS5sZW5ndGg7XG4gIGNvbnN0IG91dFJhbmsgPSBvdXRTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IHJhbmtEaWZmID0gb3V0UmFuayAtIGluUmFuaztcbiAgaWYgKG91dFJhbmsgPCAyICYmIGluUmFuayA+IDApIHtcbiAgICB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSAnY29vcmRzJztcbiAgfSBlbHNlIHtcbiAgICB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSBpblNoYXBlLm1hcCgoX3MsIGkpID0+IGBjb29yZHMuJHthbGxHbENoYW5uZWxzW2kgKyByYW5rRGlmZl19YCkuam9pbignLCAnKTtcbiAgfVxuICBjb25zdCBicm9hZGNhc3REaW1zID0gQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKGluU2hhcGUsIG91dFNoYXBlKTtcbiAgY29uc3QgY29vcmRzU25pcHBldCA9IGJyb2FkY2FzdERpbXMubWFwKGQgPT4gYGNvb3Jkcy4ke2FsbEdsQ2hhbm5lbHNbZCArIHJhbmtEaWZmXX0gPSAwO2ApLmpvaW4oJ1xcbicpO1xuICBjb25zdCBpblNpemUgPSBTaGFwZVV0aWwuc2l6ZShpblNoYXBlKTtcbiAgY29uc3QgaXNJbnB1dFNjYWxhciA9IGluU2l6ZSA9PT0gMTtcbiAgbGV0IG91dHB1dCA9ICd2ZWM0KG91dHB1dFZhbHVlLnh4LCBvdXRwdXRWYWx1ZS55eSknO1xuICBpZiAoaXNJbnB1dFNjYWxhcikge1xuICAgIG91dHB1dCA9ICd2ZWM0KG91dHB1dFZhbHVlLngpJztcbiAgfVxuICBjb25zdCBnZXRCaWFzRm9yTWF0bXVsU291cmNlID0gaXNQYWNrZWQgPyBgXG52ZWM0IGdldEJpYXNGb3JNYXRtdWwoKSB7XG4gICR7Y29vcmRzRGF0YVR5cGV9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAke2Nvb3Jkc1NuaXBwZXR9XG4gIHZlYzQgb3V0cHV0VmFsdWUgPSBnZXRCaWFzKCR7dW5wYWNrZWRDb29yZHNTbmlwcGV0fSk7XG4gIHJldHVybiAke291dHB1dH07XG59YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcbmZsb2F0IGdldEJpYXNGb3JNYXRtdWwoKSB7XG4gICR7Y29vcmRzRGF0YVR5cGV9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAke2Nvb3Jkc1NuaXBwZXR9XG4gIHJldHVybiBnZXRCaWFzKGNvb3Jkcy54KTtcbn1gO1xuXG4gIHJldHVybiBnZXRCaWFzRm9yTWF0bXVsU291cmNlO1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7QnJvYWRjYXN0VXRpbCwgU2hhcGVVdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7Z2V0R2xzbH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFByb2dyYW1JbmZvTG9hZGVyLCBQcm9ncmFtTWV0YWRhdGEsIFRleHR1cmVUeXBlfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge2dldENvb3Jkc0RhdGFUeXBlLCBnZXRHbENoYW5uZWxzfSBmcm9tICcuLi91dGlscyc7XG5cbmltcG9ydCB7Z2V0QWN0aXZhdGlvblNuaXBwZXQsIEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXN9IGZyb20gJy4vZnVzZS11dGlscyc7XG5pbXBvcnQge2dldEJpYXNGb3JNYXRtdWx9IGZyb20gJy4vbWF0bXVsJztcblxuY29uc3QgY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbU1ldGFkYXRhID0gKGhhc0JpYXM6IGJvb2xlYW4sIGNhY2hlSGludDogc3RyaW5nKSA9PiAoe1xuICBuYW1lOiAnTWF0TXVsIChwYWNrZWQpJyxcbiAgaW5wdXROYW1lczogaGFzQmlhcyA/IFsnQScsICdCJywgJ0JpYXMnXSA6IFsnQScsICdCJ10sXG4gIGlucHV0VHlwZXM6IGhhc0JpYXMgPyBbVGV4dHVyZVR5cGUucGFja2VkLCBUZXh0dXJlVHlwZS5wYWNrZWQsIFRleHR1cmVUeXBlLnBhY2tlZF0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgW1RleHR1cmVUeXBlLnBhY2tlZCwgVGV4dHVyZVR5cGUucGFja2VkXSxcbiAgY2FjaGVIaW50XG59KTtcblxuY29uc3QgY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm8gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIG1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsIGlucHV0czogVGVuc29yW10sXG4gICAgIGFjdGl2YXRpb25BdHRyaWJ1dGVzOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPiAyO1xuICAgICAgY29uc3QgcHJvY2Vzc0JpYXMgPSBoYXNCaWFzID8gJ3ZhbHVlICs9IGdldEJpYXNGb3JNYXRtdWwoKTsnIDogJyc7XG4gICAgICBjb25zdCBhU2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICAgIGNvbnN0IGJTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBCcm9hZGNhc3RVdGlsLmNhbGNTaGFwZShhU2hhcGUsIGJTaGFwZSwgdHJ1ZSk7XG4gICAgICBjb25zdCBpc0Jyb2FkY2FzdCA9ICFTaGFwZVV0aWwuYXJlRXF1YWwoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zKTtcblxuICAgICAgaWYgKCFvdXRwdXRTaGFwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgdXNlIG1hdG11bCBvbiB0aGUgZ2l2ZW4gdGVuc29ycycpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2hhcmVkRGltID0gYVNoYXBlW2FTaGFwZS5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IHNoYXJlZERpbUluZGV4ID0gTWF0aC5jZWlsKHNoYXJlZERpbSAvIDIpO1xuICAgICAgY29uc3QgYVJhbmsgPSBhU2hhcGUubGVuZ3RoO1xuICAgICAgY29uc3QgYlJhbmsgPSBiU2hhcGUubGVuZ3RoO1xuXG4gICAgICBjb25zdCBnbHNsID0gZ2V0R2xzbChpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uYmFja2VuZC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgICBjb25zdCBjb29yZHNEYXRhVHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gICAgICBjb25zdCBvdXRSYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICAgICAgY29uc3QgYWxsR2xDaGFubmVscyA9IGdldEdsQ2hhbm5lbHMoKTtcbiAgICAgIGNvbnN0IHthY3RpdmF0aW9uRnVuY3Rpb24sIGFwcGx5QWN0aXZhdGlvbn0gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhY3RpdmF0aW9uQXR0cmlidXRlcyk7XG5cbiAgICAgIGNvbnN0IGdldEJpYXNGb3JNYXRtdWxTbmlwcGV0ID1cbiAgICAgICAgICBoYXNCaWFzID8gYCR7Z2V0Qmlhc0Zvck1hdG11bChjb29yZHNEYXRhVHlwZSwgYWxsR2xDaGFubmVscywgaW5wdXRzWzJdLmRpbXMsIG91dHB1dFNoYXBlLCB0cnVlKX1gIDogJyc7XG5cbiAgICAgIGNvbnN0IGdldEJjYXN0ZWRTYW1wbGVyRm9yTWF0bXVsU25pcHBldCA9XG4gICAgICAgICAgaXNCcm9hZGNhc3QgPyBgJHtnZXRCY2FzdFNhbXBsZXJGb3JNYXRtdWwoY29vcmRzRGF0YVR5cGUsIGFsbEdsQ2hhbm5lbHMsIGlucHV0cywgb3V0cHV0U2hhcGUpfWAgOiAnJztcblxuICAgICAgY29uc3QgZ2V0U2FtcGxlckFJbkxvb3BTbmlwcGV0ID0gaXNCcm9hZGNhc3QgPyAnZ2V0QUF0T3V0Q29vcmRzTWF0bXVsKGkpJyA6IGBnZXRBKCR7Z2V0QShhbGxHbENoYW5uZWxzLCBhUmFuayl9KWA7XG4gICAgICBjb25zdCBnZXRTYW1wbGVyQkluTG9vcFNuaXBwZXQgPSBpc0Jyb2FkY2FzdCA/ICdnZXRCQXRPdXRDb29yZHNNYXRtdWwoaSknIDogYGdldEIoJHtnZXRCKGFsbEdsQ2hhbm5lbHMsIGJSYW5rKX0pYDtcbiAgICAgIGNvbnN0IGdldE91dHB1dENvb3Jkc1NuaXBwZXQgPSBpc0Jyb2FkY2FzdCA/ICcnIDogYCR7Y29vcmRzRGF0YVR5cGV9IHJjID1cbiAgICAgICAgICBnZXRPdXRwdXRDb29yZHMoKTsgaW50IGxhc3REaW0gPSByYy4ke2FsbEdsQ2hhbm5lbHNbb3V0UmFuayAtIDFdfTsgcmMuJHthbGxHbENoYW5uZWxzW291dFJhbmsgLSAxXX0gPVxuICAgICAgICAgIHJjLiR7YWxsR2xDaGFubmVsc1tvdXRSYW5rIC0gMl19OyByYy4ke2FsbEdsQ2hhbm5lbHNbb3V0UmFuayAtIDJdfSA9IGxhc3REaW07XG4gICAgICBgO1xuICAgICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgICAgICAgJHtnZXRCY2FzdGVkU2FtcGxlckZvck1hdG11bFNuaXBwZXR9XG4gICAgICAgICAgICAke2dldEJpYXNGb3JNYXRtdWxTbmlwcGV0fVxuICAgICAgICAgICAgJHthY3RpdmF0aW9uRnVuY3Rpb259XG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICR7Z2V0T3V0cHV0Q29vcmRzU25pcHBldH1cblxuICAgICAgICAgICAgICB2ZWM0IHZhbHVlID0gdmVjNCgwKTtcbiAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke3NoYXJlZERpbUluZGV4fTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmVjNCBhID0gJHtnZXRTYW1wbGVyQUluTG9vcFNuaXBwZXR9O1xuICAgICAgICAgICAgICAgIHZlYzQgYiA9ICR7Z2V0U2FtcGxlckJJbkxvb3BTbmlwcGV0fTtcblxuICAgICAgICAgICAgICAgIHZhbHVlICs9IChhLnJyYmIgKiBiLnJncmcpO1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IChhLmdnYWEgKiBiLmJhYmEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICR7cHJvY2Vzc0JpYXN9XG4gICAgICAgICAgICAgICR7YXBwbHlBY3RpdmF0aW9ufVxuICAgICAgICAgICAgICAke2dsc2wub3V0cHV0fSA9IHZhbHVlO1xuICAgICAgICAgICAgfWA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgb3V0cHV0OiB7ZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0c1swXS50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUucGFja2VkfSxcbiAgICAgICAgc2hhZGVyU291cmNlLFxuICAgICAgICBoYXNNYWluOiB0cnVlXG4gICAgICB9O1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQYWNrZWRNYXRtdWxQcm9ncmFtSW5mb0xvYWRlciA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSxcbiAgICAgYWN0aXZhdGlvbkF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mb0xvYWRlciA9PiB7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IGNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1NZXRhZGF0YShpbnB1dHMubGVuZ3RoID4gMiwgYWN0aXZhdGlvbkF0dHJpYnV0ZXMuYWN0aXZhdGlvbkNhY2hlS2V5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICBnZXQ6ICgpID0+IGNyZWF0ZVBhY2tlZE1hdG11bFByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIG1ldGFkYXRhLCBpbnB1dHMsIGFjdGl2YXRpb25BdHRyaWJ1dGVzKVxuICAgICAgfTtcbiAgICB9O1xuXG5mdW5jdGlvbiBnZXRCY2FzdFNhbXBsZXJGb3JNYXRtdWwoXG4gICAgY29vcmRzRGF0YVR5cGU6IHN0cmluZywgYWxsR2xDaGFubmVsczogcmVhZG9ubHkgc3RyaW5nW10sIGlucHV0czogVGVuc29yW10sIG91dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IHN0cmluZyB7XG4gIGxldCB1bnBhY2tlZEFDb29yZHNTbmlwcGV0ID0gW107XG4gIGxldCB1bnBhY2tlZEJDb29yZHNTbmlwcGV0ID0gW107XG5cbiAgY29uc3QgaW5BU2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgaW5CU2hhcGUgPSBpbnB1dHNbMV0uZGltcztcblxuICBjb25zdCBpbkFSYW5rID0gaW5BU2hhcGUubGVuZ3RoO1xuICBjb25zdCBpbkJSYW5rID0gaW5CU2hhcGUubGVuZ3RoO1xuXG4gIGNvbnN0IG91dFJhbmsgPSBvdXRTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IHJhbmtBRGlmZiA9IG91dFJhbmsgLSBpbkFSYW5rO1xuICBjb25zdCByYW5rQkRpZmYgPSBvdXRSYW5rIC0gaW5CUmFuaztcblxuICB1bnBhY2tlZEFDb29yZHNTbmlwcGV0ID0gaW5BU2hhcGUubWFwKChfcywgaSkgPT4gYGNvb3Jkcy4ke2FsbEdsQ2hhbm5lbHNbaSArIHJhbmtBRGlmZl19YCk7XG4gIHVucGFja2VkQUNvb3Jkc1NuaXBwZXRbaW5BUmFuayAtIDFdID0gJ2kqMic7XG4gIHVucGFja2VkQUNvb3Jkc1NuaXBwZXQuam9pbignLCAnKTtcbiAgdW5wYWNrZWRCQ29vcmRzU25pcHBldCA9IGluQlNoYXBlLm1hcCgoX3MsIGkpID0+IGBjb29yZHMuJHthbGxHbENoYW5uZWxzW2kgKyByYW5rQkRpZmZdfWApO1xuICB1bnBhY2tlZEJDb29yZHNTbmlwcGV0W2luQlJhbmsgLSAyXSA9ICdpKjInO1xuICB1bnBhY2tlZEJDb29yZHNTbmlwcGV0LmpvaW4oJywgJyk7XG5cbiAgY29uc3QgYnJvYWRjYXN0QURpbXMgPSBCcm9hZGNhc3RVdGlsLmdldEJyb2FkY2FzdERpbXMoaW5BU2hhcGUsIG91dFNoYXBlKTtcbiAgY29uc3QgYnJvYWRjYXN0QkRpbXMgPSBCcm9hZGNhc3RVdGlsLmdldEJyb2FkY2FzdERpbXMoaW5CU2hhcGUsIG91dFNoYXBlKTtcblxuICBjb25zdCBjb29yZHNBU25pcHBldCA9IGJyb2FkY2FzdEFEaW1zLm1hcChkID0+IGBjb29yZHMuJHthbGxHbENoYW5uZWxzW2QgKyByYW5rQURpZmZdfSA9IDA7YCkuam9pbignXFxuJyk7XG4gIGNvbnN0IGNvb3Jkc0JTbmlwcGV0ID0gYnJvYWRjYXN0QkRpbXMubWFwKGQgPT4gYGNvb3Jkcy4ke2FsbEdsQ2hhbm5lbHNbZCArIHJhbmtCRGlmZl19ID0gMDtgKS5qb2luKCdcXG4nKTtcbiAgY29uc3Qgc3dhcERpbVNuaXBwZXQgPSBgaW50IGxhc3REaW0gPSBjb29yZHMuJHthbGxHbENoYW5uZWxzW291dFJhbmsgLSAxXX07XG4gIGNvb3Jkcy4ke2FsbEdsQ2hhbm5lbHNbb3V0UmFuayAtIDFdfSA9IGNvb3Jkcy4ke2FsbEdsQ2hhbm5lbHNbb3V0UmFuayAtIDJdfTtcbiAgY29vcmRzLiR7YWxsR2xDaGFubmVsc1tvdXRSYW5rIC0gMl19ID0gbGFzdERpbTtgO1xuXG4gIGNvbnN0IGdldEJjYXN0U2FtcGxlck1hdG11bFNvdXJjZSA9IGBcbnZlYzQgZ2V0QUF0T3V0Q29vcmRzTWF0bXVsKGludCBpKSB7XG4gICR7Y29vcmRzRGF0YVR5cGV9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAke3N3YXBEaW1TbmlwcGV0fVxuICAke2Nvb3Jkc0FTbmlwcGV0fVxuICB2ZWM0IG91dHB1dFZhbHVlID0gZ2V0QSgke3VucGFja2VkQUNvb3Jkc1NuaXBwZXR9KTtcbiAgcmV0dXJuIG91dHB1dFZhbHVlO1xufVxuXG52ZWM0IGdldEJBdE91dENvb3Jkc01hdG11bChpbnQgaSkge1xuICAke2Nvb3Jkc0RhdGFUeXBlfSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgJHtzd2FwRGltU25pcHBldH1cbiAgJHtjb29yZHNCU25pcHBldH1cbiAgdmVjNCBvdXRwdXRWYWx1ZSA9IGdldEIoJHt1bnBhY2tlZEJDb29yZHNTbmlwcGV0fSk7XG4gIHJldHVybiBvdXRwdXRWYWx1ZTtcbn1gO1xuXG4gIHJldHVybiBnZXRCY2FzdFNhbXBsZXJNYXRtdWxTb3VyY2U7XG59XG5cbmZ1bmN0aW9uIGdldEEoYWxsR2xDaGFubmVsczogc3RyaW5nW10sIHJhbms6IG51bWJlcik6IHN0cmluZyB7XG4gIGxldCByZXMgPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rIC0gMjsgaSsrKSB7XG4gICAgcmVzICs9IGByYy4ke2FsbEdsQ2hhbm5lbHNbaV19LCBgO1xuICB9XG4gIHJlcyArPSBgcmMuJHthbGxHbENoYW5uZWxzW3JhbmsgLSAyXX0sIGAgK1xuICAgICAgJ2kqMic7XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGdldEIoYWxsR2xDaGFubmVsczogc3RyaW5nW10sIHJhbms6IG51bWJlcik6IHN0cmluZyB7XG4gIGxldCByZXMgPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rIC0gMjsgaSsrKSB7XG4gICAgcmVzICs9IGByYy4ke2FsbEdsQ2hhbm5lbHNbaV19LCBgO1xuICB9XG4gIHJlcyArPSAnaSoyLCAnICtcbiAgICAgIGByYy4ke2FsbEdsQ2hhbm5lbHNbcmFuayAtIDFdfWA7XG4gIHJldHVybiByZXM7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcblxuaW1wb3J0IHtjYWxjdWxhdGVPdXRwdXRTaGFwZSwgQ29udkF0dHJpYnV0ZXN9IGZyb20gJy4vY29udic7XG5pbXBvcnQge2NyZWF0ZVBhY2tlZEltMkNvbFByb2dyYW1JbmZvTG9hZGVyfSBmcm9tICcuL2ltMmNvbC1wYWNrJztcbmltcG9ydCB7Y3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXJ9IGZyb20gJy4vbWF0bXVsLXBhY2snO1xuXG5leHBvcnQgY29uc3QgY29udjJEUGFja2VkUG9pbnR3aXNlID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyk6IFRlbnNvciA9PiB7XG4gICAgICBjb25zdCB4c2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICAgIGNvbnN0IGtzaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPVxuICAgICAgICAgIGNhbGN1bGF0ZU91dHB1dFNoYXBlKHhzaGFwZSwga3NoYXBlLCBhdHRyaWJ1dGVzLmRpbGF0aW9ucywgYXR0cmlidXRlcy5wYWRzLCBhdHRyaWJ1dGVzLnN0cmlkZXMpO1xuICAgICAgY29uc3QgcmVzaGFwZWRYID0gaW5mZXJlbmNlSGFuZGxlci5yZXNoYXBlUGFja2VkKGlucHV0c1swXSwgW3hzaGFwZVsxXSwgeHNoYXBlWzJdICogeHNoYXBlWzNdXSk7XG4gICAgICBjb25zdCByZXNoYXBlZEsgPSBpbmZlcmVuY2VIYW5kbGVyLnJlc2hhcGVQYWNrZWQoaW5wdXRzWzFdLCBba3NoYXBlWzBdLCBrc2hhcGVbMV1dKTtcblxuICAgICAgY29uc3QgbWF0bXVsSW5wdXRzID0gaW5wdXRzLmxlbmd0aCA+IDIgPyBbcmVzaGFwZWRLLCByZXNoYXBlZFgsIGlucHV0c1syXV0gOiBbcmVzaGFwZWRLLCByZXNoYXBlZFhdO1xuICAgICAgY29uc3QgbWF0bXVsT3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICAgICAgY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXIoaW5mZXJlbmNlSGFuZGxlciwgbWF0bXVsSW5wdXRzLCBhdHRyaWJ1dGVzKSwgbWF0bXVsSW5wdXRzKTtcbiAgICAgIHJldHVybiBpbmZlcmVuY2VIYW5kbGVyLnJlc2hhcGVQYWNrZWQobWF0bXVsT3V0cHV0LCBvdXRwdXRTaGFwZSk7XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IGNvbnYyRFBhY2tlZCA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiByZWFkb25seSBUZW5zb3JbXSwgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMpOiBUZW5zb3IgPT4ge1xuICAgICAgY29uc3QgeHNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gICAgICBjb25zdCBrc2hhcGUgPSBpbnB1dHNbMV0uZGltcztcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID1cbiAgICAgICAgICBjYWxjdWxhdGVPdXRwdXRTaGFwZSh4c2hhcGUsIGtzaGFwZSwgYXR0cmlidXRlcy5kaWxhdGlvbnMsIGF0dHJpYnV0ZXMucGFkcywgYXR0cmlidXRlcy5zdHJpZGVzKTtcblxuICAgICAgLy8gcnVuIGltMmNvbFxuICAgICAgY29uc3QgaW0yY29sT3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICAgICAgY3JlYXRlUGFja2VkSW0yQ29sUHJvZ3JhbUluZm9Mb2FkZXIoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzWzBdLCBpbnB1dHNbMV0sIG91dHB1dFNoYXBlLCBhdHRyaWJ1dGVzKSxcbiAgICAgICAgICBbaW5wdXRzWzBdXSk7XG5cbiAgICAgIC8vIHJlc2hhcGUga2VybmVsXG4gICAgICBjb25zdCBrZXJuZWxSZXNoYXBlZCA9IGluZmVyZW5jZUhhbmRsZXIucmVzaGFwZVBhY2tlZChpbnB1dHNbMV0sIFtrc2hhcGVbMF0sIGtzaGFwZVsxXSAqIGtzaGFwZVsyXSAqIGtzaGFwZVszXV0pO1xuXG4gICAgICAvLyBydW4gbWF0bXVsXG4gICAgICBjb25zdCBtYXRtdWxJbnB1dHMgPVxuICAgICAgICAgIChpbnB1dHMubGVuZ3RoID09PSAzKSA/IFtrZXJuZWxSZXNoYXBlZCwgaW0yY29sT3V0cHV0LCBpbnB1dHNbMl1dIDogW2tlcm5lbFJlc2hhcGVkLCBpbTJjb2xPdXRwdXRdO1xuICAgICAgY29uc3QgbWF0bXVsT3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICAgICAgY3JlYXRlUGFja2VkTWF0bXVsUHJvZ3JhbUluZm9Mb2FkZXIoaW5mZXJlbmNlSGFuZGxlciwgbWF0bXVsSW5wdXRzLCBhdHRyaWJ1dGVzKSwgbWF0bXVsSW5wdXRzKTtcblxuICAgICAgLy8gcmVzaGFwZSBvdXRwdXRcbiAgICAgIGNvbnN0IG91dHB1dFJlc2hhcGVkID0gaW5mZXJlbmNlSGFuZGxlci5yZXNoYXBlUGFja2VkKG1hdG11bE91dHB1dCwgb3V0cHV0U2hhcGUpO1xuICAgICAgcmV0dXJuIG91dHB1dFJlc2hhcGVkO1xuICAgIH07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFByb2dyYW1JbmZvTG9hZGVyLCBQcm9ncmFtTWV0YWRhdGEsIFRleHR1cmVUeXBlfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Q29udkF0dHJpYnV0ZXN9IGZyb20gJy4vY29udic7XG5cbmNvbnN0IGNyZWF0ZUltMkNvbFByb2dyYW1NZXRhZGF0YSA9IChjYWNoZUhpbnQ6IHN0cmluZykgPT4gKHtcbiAgbmFtZTogJ0ltMkNvbCcsXG4gIGlucHV0TmFtZXM6IFsnWCddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxuICBjYWNoZUhpbnQsXG59KTtcblxuY29uc3QgY3JlYXRlSW0yQ29sUHJvZ3JhbUluZm8gPVxuICAgIChfaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLCB4OiBUZW5zb3IsIHc6IFRlbnNvcixcbiAgICAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IHhzaGFwZSA9IHguZGltcztcbiAgICAgIGNvbnN0IHdzaGFwZSA9IHcuZGltcztcblxuICAgICAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICAgIGNvbnN0IGltMmNvbERpbXMgPSBjYWxjdWxhdGVJbTJDb2xEaW1zKHhzaGFwZSwgd3NoYXBlLCBvdXRwdXRTaGFwZSwgNCk7XG5cbiAgICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICAgY29uc3QgaW50IFhDID0gJHt4c2hhcGVbMV19O1xuICAgICAgICBjb25zdCBpbnQgWEggPSAke3hzaGFwZVsyXX07XG4gICAgICAgIGNvbnN0IGludCBYVyA9ICR7eHNoYXBlWzNdfTtcbiAgICAgICAgY29uc3QgaW50IEtIID0gJHthdHRyaWJ1dGVzLmtlcm5lbFNoYXBlWzBdfTtcbiAgICAgICAgY29uc3QgaW50IEtXID0gJHthdHRyaWJ1dGVzLmtlcm5lbFNoYXBlWzFdfTtcbiAgICAgICAgY29uc3QgaW50IGRpbGF0aW9uSCA9ICR7YXR0cmlidXRlcy5kaWxhdGlvbnNbMF19O1xuICAgICAgICBjb25zdCBpbnQgZGlsYXRpb25XID0gJHthdHRyaWJ1dGVzLmRpbGF0aW9uc1sxXX07XG4gICAgICAgIGNvbnN0IGludCBzdHJpZGVIID0gJHthdHRyaWJ1dGVzLnN0cmlkZXNbMF19O1xuICAgICAgICBjb25zdCBpbnQgc3RyaWRlVyA9ICR7YXR0cmlidXRlcy5zdHJpZGVzWzFdfTtcbiAgICAgICAgY29uc3QgaW50IHBhZEggPSAke2F0dHJpYnV0ZXMucGFkc1swXX07XG4gICAgICAgIGNvbnN0IGludCBwYWRXID0gJHthdHRyaWJ1dGVzLnBhZHNbMV19O1xuICAgICAgICBjb25zdCBpbnQgS0hLVyA9IEtIKktXO1xuICAgICAgICBjb25zdCBpbnQgWENLSEtXID0gWEMgKiBLSEtXO1xuICAgICAgICBjb25zdCBpbnQgb3V0cHV0Q2hhbm5lbHMgPSA0O1xuICAgICAgICB2ZWM0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgICBpbnQgYiAgPSBpbmRpY2VzWzBdOyAvLyBiYXRjaCBzaXplXG4gICAgICAgICAgaW50IG9oID0gaW5kaWNlc1sxXSAqIHN0cmlkZUggLSBwYWRIOyAvL291dHB1dCBoZWlnaHRcbiAgICAgICAgICBpbnQgb3cgPSBpbmRpY2VzWzJdICogc3RyaWRlVyAtIHBhZFc7IC8vb3V0cHV0IHdpZHRoXG4gICAgICAgICAgaW50IHAgPSBpbmRpY2VzWzNdICogb3V0cHV0Q2hhbm5lbHM7IC8vcGF0Y2hcbiAgICAgICAgICB2ZWM0IHZhbHVlID0gdmVjNCgwLjApO1xuICAgICAgICAgIGZvcihpbnQgaT0wOyBpIDwgb3V0cHV0Q2hhbm5lbHM7ICsraSkge1xuICAgICAgICAgICAgaWYocCA8IFhDS0hLVykge1xuICAgICAgICAgICAgICBpbnQgcGF0Y2hDID0gcCAvIEtIS1c7XG4gICAgICAgICAgICAgIGludCBwYXRjaEggPSAocCAtIHBhdGNoQypLSEtXKSAvIEtXO1xuICAgICAgICAgICAgICBpbnQgcGF0Y2hXID0gKHAgLSBwYXRjaEMqS0hLVykgLSBwYXRjaEggKiBLVztcbiAgICAgICAgICAgICAgaW50IHhoMiA9IG9oICsgcGF0Y2hIICogZGlsYXRpb25IO1xuICAgICAgICAgICAgICBpbnQgeHcyID0gb3cgKyBwYXRjaFcgKiBkaWxhdGlvblc7XG4gICAgICAgICAgICAgIGludCB4WyR7eHNoYXBlLmxlbmd0aH1dO1xuICAgICAgICAgICAgICB4WzBdID0gYjtcbiAgICAgICAgICAgICAgeFsxXSA9IHBhdGNoQztcbiAgICAgICAgICAgICAgeFsyXSA9IHhoMjtcbiAgICAgICAgICAgICAgeFszXSA9IHh3MjtcbiAgICAgICAgICAgICAgaWYoeGgyID49IDAgJiZcbiAgICAgICAgICAgICAgICAgIHhoMiA8IFhIICYmXG4gICAgICAgICAgICAgICAgICB4dzIgPj0gMCAmJlxuICAgICAgICAgICAgICAgICAgeHcyIDwgWFcpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVtpXSA9IF9YKHgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICArK3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgIG91dHB1dDoge2RpbXM6IGltMmNvbERpbXMsIHR5cGU6IHgudHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb259LFxuICAgICAgICBzaGFkZXJTb3VyY2VcbiAgICAgIH07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUltMkNvbFByb2dyYW1JbmZvTG9hZGVyID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCB4OiBUZW5zb3IsIHc6IFRlbnNvciwgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgICBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyk6IFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlSW0yQ29sUHJvZ3JhbU1ldGFkYXRhKGF0dHJpYnV0ZXMuY2FjaGVLZXkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgIGdldDogKCkgPT4gY3JlYXRlSW0yQ29sUHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlciwgbWV0YWRhdGEsIHgsIHcsIG91dHB1dFNoYXBlLCBhdHRyaWJ1dGVzKVxuICAgICAgfTtcbiAgICB9O1xuXG5cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVJbTJDb2xEaW1zID1cbiAgICAoaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBjaGFubmVscyA9IDQpOlxuICAgICAgICBudW1iZXJbXSA9PlxuICAgICAgICAgICAgW291dHB1dFNoYXBlWzBdLCBvdXRwdXRTaGFwZVsyXSwgb3V0cHV0U2hhcGVbM10sXG4gICAgICAgICAgICAgTWF0aC5jZWlsKGlucHV0U2hhcGVbMV0gKiBrZXJuZWxTaGFwZVsyXSAqIGtlcm5lbFNoYXBlWzNdIC8gY2hhbm5lbHMpXTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgUHJvZ3JhbU1ldGFkYXRhLCBUZXh0dXJlVHlwZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2dldEFjdGl2YXRpb25TbmlwcGV0LCBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzfSBmcm9tICcuL2Z1c2UtdXRpbHMnO1xuaW1wb3J0IHtjYWxjdWxhdGVJbTJDb2xEaW1zfSBmcm9tICcuL2ltMmNvbCc7XG5cbmNvbnN0IGNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtTWV0YWRhdGEgPSAoaGFzQmlhczogYm9vbGVhbiwgYXR0cmlidXRlczogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcykgPT4gKHtcbiAgbmFtZTogJ0NvbnZEb3RQcm9kdWN0JyxcbiAgaW5wdXROYW1lczogaGFzQmlhcyA/IFsnSW0yQ29sJywgJ0snLCAnQiddIDogWydJbTJDb2wnLCAnSyddLFxuICBpbnB1dFR5cGVzOiBoYXNCaWFzID8gW1RleHR1cmVUeXBlLnVucGFja2VkLCBUZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uLCBUZXh0dXJlVHlwZS51bnBhY2tlZF0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgW1RleHR1cmVUeXBlLnVucGFja2VkLCBUZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uXSxcbiAgY2FjaGVLZXk6IGF0dHJpYnV0ZXMuYWN0aXZhdGlvbkNhY2hlS2V5XG59KTtcblxuY29uc3QgY3JlYXRlRG90UHJvZHVjdFByb2dyYW1JbmZvID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBtZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhLCBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvcltdLFxuICAgICBvdXRwdXRTaGFwZTogbnVtYmVyW10sIGF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCB4c2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICAgIGNvbnN0IGtzaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuICAgICAgY29uc3QgYWRqdXN0ZWRLZXJuZWxTaGFwZSA9IFtrc2hhcGVbMF0sIE1hdGguY2VpbCgoeHNoYXBlWzFdICoga3NoYXBlWzJdICoga3NoYXBlWzNdKSAvIDQpXTtcbiAgICAgIGNvbnN0IGltMmNvbFNoYXBlID0gY2FsY3VsYXRlSW0yQ29sRGltcyh4c2hhcGUsIGtzaGFwZSwgb3V0cHV0U2hhcGUpO1xuICAgICAgY29uc3QgW2tXaWR0aCwga0hlaWdodF0gPVxuICAgICAgICAgIGluZmVyZW5jZUhhbmRsZXIuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGFkanVzdGVkS2VybmVsU2hhcGUsIFRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24pO1xuXG4gICAgICBjb25zdCBpbTJjb2xTdHJpZGVzID0gU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGltMmNvbFNoYXBlKTtcbiAgICAgIGNvbnN0IFtpbTJjb2xXaWR0aCwgaW0yY29sSGVpZ2h0XSA9XG4gICAgICAgICAgaW5mZXJlbmNlSGFuZGxlci5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoaW0yY29sU2hhcGUsIFRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24pO1xuICAgICAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcblxuICAgICAgY29uc3QgaW5pdFZhbHVlID0gKGlucHV0cy5sZW5ndGggPCAzKSA/ICcwLjAnIDogJ19CKGIpJztcbiAgICAgIGNvbnN0IHNoYXJlZERpbSA9IE1hdGguY2VpbCh4c2hhcGVbMV0gKiBrc2hhcGVbMl0gKiBrc2hhcGVbM10gLyA0KTtcbiAgICAgIGNvbnN0IHthY3RpdmF0aW9uRnVuY3Rpb24sIGFwcGx5QWN0aXZhdGlvbn0gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhdHRyaWJ1dGVzKTtcbiAgICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiR7YWN0aXZhdGlvbkZ1bmN0aW9ufVxuZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3Jhbmt9XSkge1xuICBpbnQgYlsxXTtcbiAgYlswXSA9IGluZGljZXNbMV07XG4gIGludCBpbTJjb2xbNF07XG4gIGltMmNvbFswXSA9IGluZGljZXNbMF07XG4gIGltMmNvbFsxXSA9IGluZGljZXNbMl07XG4gIGltMmNvbFsyXSA9IGluZGljZXNbM107XG4gIGludCBpbTJjb2xPZmZzZXQgPSBpbTJjb2xbMF0gKiAke2ltMmNvbFN0cmlkZXNbMF19ICsgaW0yY29sWzFdICogJHtpbTJjb2xTdHJpZGVzWzFdfSArIGltMmNvbFsyXSAqICR7XG4gICAgICAgICAgaW0yY29sU3RyaWRlc1syXX07XG4gIGludCBrZXJuZWxPZmZzZXQgPSBpbmRpY2VzWzFdICogJHthZGp1c3RlZEtlcm5lbFNoYXBlWzFdfTtcbiAgZmxvYXQgdmFsdWUgPSAke2luaXRWYWx1ZX07XG4gIGZvciAoaW50IGkgPSAwOyBpIDwgJHtzaGFyZWREaW19OyArK2kpIHtcbiAgICB2ZWMyIGltMmNvbENvb3JkcyA9IG9mZnNldFRvQ29vcmRzKGltMmNvbE9mZnNldCwgJHtpbTJjb2xXaWR0aH0sICR7aW0yY29sSGVpZ2h0fSk7XG4gICAgdmVjMiBrZXJuZWxDb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhrZXJuZWxPZmZzZXQsICR7a1dpZHRofSwgJHtrSGVpZ2h0fSk7XG4gICAgdmFsdWUgKz0gZG90KCR7Z2xzbC50ZXh0dXJlMkR9KEltMkNvbCwgaW0yY29sQ29vcmRzKSwgJHtnbHNsLnRleHR1cmUyRH0oSywga2VybmVsQ29vcmRzKSk7XG4gICAgKytpbTJjb2xPZmZzZXQ7XG4gICAgKytrZXJuZWxPZmZzZXQ7XG4gIH1cbiAgJHthcHBseUFjdGl2YXRpb259XG4gIHJldHVybiB2YWx1ZTtcbn1gO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgIG91dHB1dDoge2RpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dHNbMF0udHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnVucGFja2VkfSxcbiAgICAgICAgc2hhZGVyU291cmNlXG4gICAgICB9O1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVEb3RQcm9kdWN0UHJvZ3JhbUluZm9Mb2FkZXIgPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogcmVhZG9ubHkgVGVuc29yW10sIG91dHB1dFNoYXBlOiBudW1iZXJbXSxcbiAgICAgYXR0cmlidXRlczogSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlRG90UHJvZHVjdFByb2dyYW1NZXRhZGF0YShpbnB1dHMubGVuZ3RoID4gMiwgYXR0cmlidXRlcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgZ2V0OiAoKSA9PiBjcmVhdGVEb3RQcm9kdWN0UHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlciwgbWV0YWRhdGEsIGlucHV0cywgb3V0cHV0U2hhcGUsIGF0dHJpYnV0ZXMpXG4gICAgICB9O1xuICAgIH07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uLy4uLy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0luZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uLy4uLy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHtPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9ufSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1Bvb2xDb252VXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuXG5pbXBvcnQge2NyZWF0ZVVucGFja2VkR3JvdXBlZENvbnZQcm9ncmFtSW5mb0xvYWRlcn0gZnJvbSAnLi9jb252LWdyb3VwZWQnO1xuaW1wb3J0IHtjb252MkRQYWNrZWR9IGZyb20gJy4vY29udi1wYWNrJztcbmltcG9ydCB7Y3JlYXRlRG90UHJvZHVjdFByb2dyYW1JbmZvTG9hZGVyfSBmcm9tICcuL2RvdC1wcm9kdWN0JztcbmltcG9ydCB7SW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcywgcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzfSBmcm9tICcuL2Z1c2UtdXRpbHMnO1xuaW1wb3J0IHtjcmVhdGVJbTJDb2xQcm9ncmFtSW5mb0xvYWRlcn0gZnJvbSAnLi9pbTJjb2wnO1xuaW1wb3J0IHtjcmVhdGVNYXRtdWxQcm9ncmFtSW5mb0xvYWRlcn0gZnJvbSAnLi9tYXRtdWwnO1xuXG5cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVPdXRwdXRTaGFwZSA9XG4gICAgKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBrZXJuZWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIGRpbGF0aW9uczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgIGFkanVzdFBhZHM6IHJlYWRvbmx5IG51bWJlcltdLCBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcbiAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IGlucHV0U2hhcGVbMF07XG4gICAgICBjb25zdCBpbnB1dFNwYXRpYWxTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoMik7XG4gICAgICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0U3BhdGlhbFNoYXBlLmxlbmd0aDtcbiAgICAgIGNvbnN0IG91dENoYW5uZWxzID0ga2VybmVsU2hhcGVbMF07XG4gICAgICBjb25zdCBrZXJuZWxTcGF0aWFsU2hhcGUgPSBrZXJuZWxTaGFwZS5zbGljZSgyKTtcbiAgICAgIGNvbnN0IGRpbGF0ZWRLZXJuZWxTaGFwZSA9IGtlcm5lbFNwYXRpYWxTaGFwZS5tYXAoKHYsIGkpID0+IHYgKyAodiAtIDEpICogKGRpbGF0aW9uc1tpXSAtIDEpKTtcbiAgICAgIGNvbnN0IGlucHV0U3BhdGlhbFNoYXBlV2l0aFBhZCA9IGlucHV0U3BhdGlhbFNoYXBlLm1hcCgodiwgaSkgPT4gdiArIGFkanVzdFBhZHNbaV0gKyBhZGp1c3RQYWRzW2kgKyBzcGF0aWFsUmFua10pO1xuICAgICAgY29uc3Qgb3V0cHV0U3BhdGlhbFNoYXBlID1cbiAgICAgICAgICBpbnB1dFNwYXRpYWxTaGFwZVdpdGhQYWQubWFwKCh2LCBpKSA9PiBNYXRoLmZsb29yKCh2IC0gZGlsYXRlZEtlcm5lbFNoYXBlW2ldICsgc3RyaWRlc1tpXSkgLyBzdHJpZGVzW2ldKSk7XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IFtiYXRjaFNpemUsIG91dENoYW5uZWxzXS5jb25jYXQoLi4ub3V0cHV0U3BhdGlhbFNoYXBlKTtcbiAgICAgIHJldHVybiBvdXRwdXRTaGFwZTtcbiAgICB9O1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbnZBdHRyaWJ1dGVzIGV4dGVuZHMgSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcywgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgYXV0b1BhZDogc3RyaW5nO1xuICByZWFkb25seSBkaWxhdGlvbnM6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSBncm91cDogbnVtYmVyO1xuICByZWFkb25seSBrZXJuZWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IHBhZHM6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXTtcbn1cblxuZXhwb3J0IGNvbnN0IGNvbnY6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248Q29udkF0dHJpYnV0ZXM+ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiB7XG4gICAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIGF0dHJpYnV0ZXMpOyAgLy8gY3VycmVudGx5IHdpbGwgZmFpbCBpZiBub3QgY29udjJEXG4gICAgICByZXR1cm4gY29udjJkKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcyk7XG4gICAgfTtcblxuY29uc3QgY29udjJkOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPENvbnZBdHRyaWJ1dGVzPiA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiB7XG4gICAgICBjb25zdCBhZGp1c3RlZEF0dHJpYnV0ZXMgPSBnZXRBZGp1c3RlZENvbnZBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIGlucHV0cyk7XG4gICAgICBjb25zdCBwYWNrTW9kZSA9IGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5wYWNrO1xuICAgICAgY29uc3QgaXNQb2ludHdpc2UgPSBhZGp1c3RlZEF0dHJpYnV0ZXMua2VybmVsU2hhcGVbMF0gPT09IDEgJiYgYWRqdXN0ZWRBdHRyaWJ1dGVzLmtlcm5lbFNoYXBlWzFdID09PSAxO1xuICAgICAgaWYgKGFkanVzdGVkQXR0cmlidXRlcy5ncm91cCA+IDEpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICAgICAgICBjcmVhdGVVbnBhY2tlZEdyb3VwZWRDb252UHJvZ3JhbUluZm9Mb2FkZXIoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMpLCBpbnB1dHMpO1xuICAgICAgICByZXR1cm4gW3Jlc3VsdF07XG4gICAgICB9IGVsc2UgaWYgKGlzUG9pbnR3aXNlICYmIHBhY2tNb2RlKSB7XG4gICAgICAgIHJldHVybiBbY29udjJEVW5wYWNrZWRQb2ludHdpc2UoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMpXTtcbiAgICAgIH0gZWxzZSBpZiAocGFja01vZGUgJiYgaW5wdXRzWzBdLmRpbXMubGVuZ3RoID09PSA0ICYmIGlucHV0c1swXS5kaW1zWzBdID09PSAxICYmICFpc1BvaW50d2lzZSkge1xuICAgICAgICByZXR1cm4gW2NvbnYyRFBhY2tlZChpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGFkanVzdGVkQXR0cmlidXRlcyldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtjb252MkRVbnBhY2tlZChpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGFkanVzdGVkQXR0cmlidXRlcyldO1xuICAgICAgfVxuICAgIH07XG5cbmNvbnN0IGNvbnYyRFVucGFja2VkUG9pbnR3aXNlID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyk6IFRlbnNvciA9PiB7XG4gICAgICBjb25zdCB4c2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICAgIGNvbnN0IGtzaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPVxuICAgICAgICAgIGNhbGN1bGF0ZU91dHB1dFNoYXBlKHhzaGFwZSwga3NoYXBlLCBhdHRyaWJ1dGVzLmRpbGF0aW9ucywgYXR0cmlidXRlcy5wYWRzLCBhdHRyaWJ1dGVzLnN0cmlkZXMpO1xuICAgICAgY29uc3QgcmVzaGFwZWRYID0gaW5mZXJlbmNlSGFuZGxlci5yZXNoYXBlVW5wYWNrZWQoaW5wdXRzWzBdLCBbeHNoYXBlWzFdLCB4c2hhcGVbMl0gKiB4c2hhcGVbM11dKTtcbiAgICAgIGNvbnN0IHJlc2hhcGVkSyA9IGluZmVyZW5jZUhhbmRsZXIucmVzaGFwZVVucGFja2VkKGlucHV0c1sxXSwgW2tzaGFwZVswXSwga3NoYXBlWzFdXSk7XG5cbiAgICAgIGNvbnN0IG1hdG11bElucHV0cyA9IGlucHV0cy5sZW5ndGggPiAyID8gW3Jlc2hhcGVkSywgcmVzaGFwZWRYLCBpbnB1dHNbMl1dIDogW3Jlc2hhcGVkSywgcmVzaGFwZWRYXTtcbiAgICAgIGNvbnN0IG1hdG11bE91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvTG9hZGVyKG1hdG11bElucHV0cywgYXR0cmlidXRlcyksIG1hdG11bElucHV0cyk7XG4gICAgICByZXR1cm4gaW5mZXJlbmNlSGFuZGxlci5yZXNoYXBlVW5wYWNrZWQobWF0bXVsT3V0cHV0LCBvdXRwdXRTaGFwZSk7XG4gICAgfTtcblxuY29uc3QgY29udjJEVW5wYWNrZWQgPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogcmVhZG9ubHkgVGVuc29yW10sIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzKTogVGVuc29yID0+IHtcbiAgICAgIGNvbnN0IHhzaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICAgICAgY29uc3Qga3NoYXBlID0gaW5wdXRzWzFdLmRpbXM7XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9XG4gICAgICAgICAgY2FsY3VsYXRlT3V0cHV0U2hhcGUoeHNoYXBlLCBrc2hhcGUsIGF0dHJpYnV0ZXMuZGlsYXRpb25zLCBhdHRyaWJ1dGVzLnBhZHMsIGF0dHJpYnV0ZXMuc3RyaWRlcyk7XG4gICAgICBjb25zdCB4SW0yQ29sID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICAgICAgY3JlYXRlSW0yQ29sUHJvZ3JhbUluZm9Mb2FkZXIoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzWzBdLCBpbnB1dHNbMV0sIG91dHB1dFNoYXBlLCBhdHRyaWJ1dGVzKSwgW2lucHV0c1swXV0pO1xuXG4gICAgICBjb25zdCBkb3RQcm9kdWN0SW5wdXRzID0gaW5wdXRzLmxlbmd0aCA9PT0gMyA/IFt4SW0yQ29sLCBpbnB1dHNbMV0sIGlucHV0c1syXV0gOiBbeEltMkNvbCwgaW5wdXRzWzFdXTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgICAgICAgIGNyZWF0ZURvdFByb2R1Y3RQcm9ncmFtSW5mb0xvYWRlcihpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIG91dHB1dFNoYXBlLCBhdHRyaWJ1dGVzKSwgZG90UHJvZHVjdElucHV0cyk7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG5cbmNvbnN0IGdldEFkanVzdGVkQ29udkF0dHJpYnV0ZXMgPSA8VCBleHRlbmRzIENvbnZBdHRyaWJ1dGVzPihhdHRyaWJ1dGVzOiBULCBpbnB1dHM6IFRlbnNvcltdKTogVCA9PiB7XG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5zbGljZSgpO1xuICAvLyBpZiBrZXJuZWxTaGFwZSBpcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBhdHRyaWJ1dGVzIG9mIHRoaXMgb3AsIGluZmVyIGl0IGZyb20gdGhlIHdlaWdodCB0ZW5zb3IgZGltc1xuICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGxldCBpID0gMjsgaSA8IGlucHV0c1sxXS5kaW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICBrZXJuZWxTaGFwZS5wdXNoKGlucHV0c1sxXS5kaW1zW2ldKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMucGFkcy5zbGljZSgpO1xuICBQb29sQ29udlV0aWwuYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKFxuICAgICAgaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuc3RyaWRlcywgYXR0cmlidXRlcy5kaWxhdGlvbnMsIGtlcm5lbFNoYXBlLCBwYWRzLCBhdHRyaWJ1dGVzLmF1dG9QYWQpO1xuXG4gIC8vIGFsd2F5cyByZXR1cm4gYSBuZXcgb2JqZWN0IHNvIGRvZXMgbm90IG1vZGlmeSB0aGUgb3JpZ2luYWwgYXR0cmlidXRlc1xuICBjb25zdCBuZXdBdHRyaWJ1dGVzOiBUID0gT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlcyk7XG4gIE9iamVjdC5hc3NpZ24obmV3QXR0cmlidXRlcywge2tlcm5lbFNoYXBlLCBwYWRzLCBjYWNoZUtleTogYXR0cmlidXRlcy5jYWNoZUtleX0pO1xuICByZXR1cm4gbmV3QXR0cmlidXRlcztcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUNvbnZBdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPENvbnZBdHRyaWJ1dGVzPiA9IChub2RlOiBHcmFwaC5Ob2RlKTogQ29udkF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzO1xuICBjb25zdCBhY3RpdmF0aW9uQXR0cmlidXRlcyA9IHBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgLy8gVE9ETyA6IE1ha2UgdGhpcyBnZW5lcmljIGVub3VnaCB0byBjb21wdXRlIGRlZmF1bHQgYXR0cmlidXRlcyBmb3IgbXVsdGktZGltZW5zaW9uYWwgY29udlxuICBjb25zdCBhdXRvUGFkID0gYXR0cmlidXRlcy5nZXRTdHJpbmcoJ2F1dG9fcGFkJywgJ05PVFNFVCcpO1xuICBjb25zdCBkaWxhdGlvbnMgPSBhdHRyaWJ1dGVzLmdldEludHMoJ2RpbGF0aW9ucycsIFsxLCAxXSk7XG4gIGNvbnN0IGdyb3VwID0gYXR0cmlidXRlcy5nZXRJbnQoJ2dyb3VwJywgMSk7XG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5nZXRJbnRzKCdrZXJuZWxfc2hhcGUnLCBbXSk7XG4gIGNvbnN0IHBhZHMgPSBhdHRyaWJ1dGVzLmdldEludHMoJ3BhZHMnLCBbMCwgMCwgMCwgMF0pO1xuICBjb25zdCBzdHJpZGVzID0gYXR0cmlidXRlcy5nZXRJbnRzKCdzdHJpZGVzJywgWzEsIDFdKTtcblxuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHthdXRvUGFkLCBkaWxhdGlvbnMsIGdyb3VwLCBrZXJuZWxTaGFwZSwgcGFkcywgc3RyaWRlcywgLi4uYWN0aXZhdGlvbkF0dHJpYnV0ZXN9KTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIC8vIFJlZmVyIHRvIHRoZSBiZWxvdyBsaW5rIGZvciBhbGwgaW5wdXQgY2hlY2tzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vbm54L29ubngvYmxvYi9tYWluL2RvY3MvT3BlcmF0b3JzLm1kI0NvbnZcbiAgaWYgKCFpbnB1dHMgfHwgKGlucHV0cy5sZW5ndGggIT09IDIgJiYgaW5wdXRzLmxlbmd0aCAhPT0gMykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0cycpO1xuICB9XG5cbiAgLy8gVE9ETyA6IE5lZWQgdG8gYWRkIHN1cHBvcnQgZm9yIG11bHRpLWRpbWVuc2lvbmFsIGNvbnZcbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gNCB8fCBpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnRseSBvbmx5IHN1cHBvcnQgMi1kaW1lbnNpb25hbCBjb252Jyk7XG4gIH1cblxuICAvLyBGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXG4gIGNvbnN0IGRhdGFDaGFubmVsID0gaW5wdXRzWzBdLmRpbXNbMV07XG4gIGNvbnN0IGZpbHRlckluQ2hhbm5lbCA9IGlucHV0c1sxXS5kaW1zWzFdICogYXR0cmlidXRlcy5ncm91cDtcbiAgaWYgKGRhdGFDaGFubmVsICE9PSBmaWx0ZXJJbkNoYW5uZWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUwnKTtcbiAgfVxuXG4gIC8vIGlmIGJpYXMgaXMgcHJvdmlkZWQgaXQgc2hvdWxkIGJlIDFEIGFuZCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHNob3VsZCBiZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGZlYXR1cmUgbWFwc1xuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiAoaW5wdXRzWzJdLmRpbXMubGVuZ3RoICE9PSAxIHx8IGlucHV0c1sxXS5kaW1zWzBdICE9PSBpbnB1dHNbMl0uZGltc1swXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYmlhcycpO1xuICB9XG5cbiAgY29uc3Qgc3BhdGlhbFJhbmsgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAyO1xuICAvLyB3cm9uZyBkaWxhdGlvbnMgZGltZW5zaW9uXG4gIGlmIChhdHRyaWJ1dGVzLmRpbGF0aW9ucy5sZW5ndGggIT09IHNwYXRpYWxSYW5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xuICB9XG5cbiAgLy8gV3Jvbmcgc3RyaWRlcyBkaW1lbnNpb25cbiAgaWYgKGF0dHJpYnV0ZXMuc3RyaWRlcy5sZW5ndGggIT09IHNwYXRpYWxSYW5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke3NwYXRpYWxSYW5rfURgKTtcbiAgfVxuXG4gIC8vIFdyb25nIHBhZHMgZGltZW5zaW9uXG4gIGlmIChhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoICE9PSBzcGF0aWFsUmFuayAqIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZHMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmsgKiAyfURgKTtcbiAgfVxuXG4gIC8vIGlmIGtlcm5lbFNoYXBlIGlzIHNwZWNpZmllZCwgaXQncyBkYXRhIGxlbmd0aCBtdXN0IGJlIDIgbGVzcyB0aGFuIGRpbXMgbGVuZ3RoIG9mIHRoZSB3ZWlnaHRzIHRlbnNvclxuICAvLyAodGhlIGZpcnN0IDIgZGltcyBhcmUgYmF0Y2hfc2l6ZSBhbmQgY2hhbm5lbHMpXG4gIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gMCAmJiBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoIC0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBrZXJuZWwgc2hhcGUnKTtcbiAgfVxuXG4gIC8vIFRPRE8gOiBOZWVkIHRvIGFkZCBzdXBwb3J0IGZvciBmbG9hdDY0XG4gIGlmIChpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0MzInIHx8IGlucHV0c1sxXS50eXBlICE9PSAnZmxvYXQzMicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnYgaW5wdXQoWCxXKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiBpbnB1dHNbMl0udHlwZSAhPT0gJ2Zsb2F0MzInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb252IGlucHV0KGJpYXMpIHNob3VsZCBiZSBmbG9hdCB0ZW5zb3InKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uLy4uLy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0luZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uLy4uLy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHtPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9ufSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBQcm9ncmFtSW5mb0xvYWRlciwgUHJvZ3JhbU1ldGFkYXRhLCBUZXh0dXJlVHlwZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge0NvbnZBdHRyaWJ1dGVzfSBmcm9tICcuL2NvbnYnO1xuaW1wb3J0IHtnZXRBY3RpdmF0aW9uU25pcHBldCwgcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzfSBmcm9tICcuL2Z1c2UtdXRpbHMnO1xuXG5jb25zdCBjb21wdXRlVG90YWxQYWQgPVxuICAgIChpbkRpbTogbnVtYmVyLCBzdHJpZGU6IG51bWJlciwgYWRqOiBudW1iZXIsIGtlcm5lbDogbnVtYmVyLCBkaWxhdGlvbjogbnVtYmVyLCBvdXRTaXplOiBudW1iZXIpID0+XG4gICAgICAgIChpbkRpbSAtIDEpICogc3RyaWRlICsgYWRqICsgKGtlcm5lbCAtIDEpICogZGlsYXRpb24gKyAxIC0gb3V0U2l6ZTtcblxuY29uc3QgZGlzdHJpYnV0ZVBhZGRpbmcgPSAodG90YWxQYWQ6IG51bWJlciwgYXV0b1BhZDogc3RyaW5nLCBwYWRzOiBudW1iZXJbXSwgaGVhZDogbnVtYmVyLCB0YWlsOiBudW1iZXIpID0+IHtcbiAgY29uc3Qgc21hbGxQYWQgPSBNYXRoLmZsb29yKHRvdGFsUGFkIC8gMik7XG4gIGlmIChhdXRvUGFkID09PSAnU0FNRV9VUFBFUicpIHtcbiAgICBwYWRzW2hlYWRdID0gc21hbGxQYWQ7XG4gICAgcGFkc1t0YWlsXSA9IHRvdGFsUGFkIC0gc21hbGxQYWQ7XG4gIH0gZWxzZSBpZiAoYXV0b1BhZCA9PT0gJ1NBTUVfTE9XRVInKSB7XG4gICAgcGFkc1toZWFkXSA9IHRvdGFsUGFkIC0gc21hbGxQYWQ7XG4gICAgcGFkc1t0YWlsXSA9IHNtYWxsUGFkO1xuICB9XG59O1xuXG5jb25zdCBjYWxjdWxhdGVPdXRwdXRTaGFwZUFuZFBhZHMgPVxuICAgIChpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBkaWxhdGlvbnM6IHJlYWRvbmx5IG51bWJlcltdLCBhdXRvUGFkOiBzdHJpbmcsXG4gICAgIHBhZHM6IG51bWJlcltdLCBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSwgb3V0cHV0UGFkZGluZzogcmVhZG9ubHkgbnVtYmVyW10sIG91dHB1dFNoYXBlOiBudW1iZXJbXSkgPT4ge1xuICAgICAgY29uc3Qgc3BhdGlhbFJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aCAtIDI7XG4gICAgICBjb25zdCB1cGRhdGVTaGFwZSA9IG91dHB1dFNoYXBlLmxlbmd0aCA9PT0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BhdGlhbFJhbms7ICsraSkge1xuICAgICAgICBjb25zdCBvdXRTaXplID0gdXBkYXRlU2hhcGUgPyBpbnB1dFNoYXBlW2kgKyAyXSAqIHN0cmlkZXNbaV0gOiBvdXRwdXRTaGFwZVtpXTtcbiAgICAgICAgY29uc3QgdG90YWxQYWQgPSBjb21wdXRlVG90YWxQYWQoaW5wdXRTaGFwZVtpICsgMl0sIHN0cmlkZXNbaV0sIHBhZHNbaV0sIGtlcm5lbFNoYXBlW2ldLCBkaWxhdGlvbnNbaV0sIG91dFNpemUpO1xuICAgICAgICBkaXN0cmlidXRlUGFkZGluZyh0b3RhbFBhZCwgYXV0b1BhZCwgcGFkcywgaSwgaSArIHNwYXRpYWxSYW5rKTtcbiAgICAgICAgaWYgKHVwZGF0ZVNoYXBlKSB7XG4gICAgICAgICAgb3V0cHV0U2hhcGUucHVzaChcbiAgICAgICAgICAgICAgc3RyaWRlc1tpXSAqIChpbnB1dFNoYXBlW2kgKyAyXSAtIDEpICsgb3V0cHV0UGFkZGluZ1tpXSArIChrZXJuZWxTaGFwZVtpXSAtIDEpICogZGlsYXRpb25zW2ldICsgMSAtXG4gICAgICAgICAgICAgIHBhZHNbaV0gLSBwYWRzW2kgKyBzcGF0aWFsUmFua10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuZXhwb3J0IGludGVyZmFjZSBDb252VHJhbnNwb3NlQXR0cmlidXRlcyBleHRlbmRzIENvbnZBdHRyaWJ1dGVzIHtcbiAgcmVhZG9ubHkgb3V0cHV0UGFkZGluZzogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcbn1cblxuZXhwb3J0IGNvbnN0IGNvbnZUcmFuc3Bvc2U6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248Q29udlRyYW5zcG9zZUF0dHJpYnV0ZXM+ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiB7XG4gICAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIGF0dHJpYnV0ZXMpOyAgLy8gY3VycmVudGx5IHdpbGwgZmFpbCBpZiBub3QgY29udlRyYW5zcG9zZTJEXG4gICAgICByZXR1cm4gY29udlRyYW5zcG9zZTJkKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcyk7XG4gICAgfTtcblxuY29uc3QgY29udlRyYW5zcG9zZTJkOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzPiA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiB7XG4gICAgICBjb25zdCBhZGp1c3RlZEF0dHJpYnV0ZXMgPSBnZXRBZGp1c3RlZENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIGlucHV0cyk7XG4gICAgICByZXR1cm4gW2NvbnZUcmFuc3Bvc2UyRFVucGFja2VkKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYWRqdXN0ZWRBdHRyaWJ1dGVzKV07XG4gICAgfTtcblxuY29uc3QgY3JlYXRlQ29udlRyYW5zcG9zZVByb2dyYW1NZXRhZGF0YSA9IChoYXNCaWFzOiBib29sZWFuLCBjYWNoZUhpbnQ6IHN0cmluZykgPT4gKHtcbiAgbmFtZTogJ0NvbnZUcmFuc3Bvc2UnLFxuICBpbnB1dE5hbWVzOiBoYXNCaWFzID8gWydYJywgJ1cnLCAnQiddIDogWydYJywgJ1cnXSxcbiAgaW5wdXRUeXBlczogaGFzQmlhcyA/IFtUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBbVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXSxcbiAgY2FjaGVIaW50XG59KTtcblxuY29uc3QgY3JlYXRlVW5wYWNrZWRDb252VHJhbnNwb3NlUHJvZ3JhbUluZm8gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogcmVhZG9ubHkgVGVuc29yW10sIG1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsXG4gICAgIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPiAyO1xuICAgICAgY29uc3QgdmFsdWVJbml0ID0gaGFzQmlhcyA/ICdnZXRCKG91dHB1dF9jaGFubmVsKScgOiAnMC4wJztcbiAgICAgIGNvbnN0IHhTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICAgICAgY29uc3Qgd1NoYXBlID0gaW5wdXRzWzFdLmRpbXM7XG4gICAgICBjb25zdCBvdXRwdXRDaGFubmVsc1Blckdyb3VwID0gd1NoYXBlWzFdO1xuICAgICAgY29uc3QgaW5wdXRDaGFubmVsc1Blckdyb3VwID0gd1NoYXBlWzBdIC8gYXR0cmlidXRlcy5ncm91cDtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gW2lucHV0c1swXS5kaW1zWzBdLCBpbnB1dHNbMV0uZGltc1sxXSAqIGF0dHJpYnV0ZXMuZ3JvdXAsIC4uLmF0dHJpYnV0ZXMub3V0cHV0U2hhcGVdO1xuICAgICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgICAgY29uc3Qge2FjdGl2YXRpb25GdW5jdGlvbiwgYXBwbHlBY3RpdmF0aW9ufSA9IGdldEFjdGl2YXRpb25TbmlwcGV0KGF0dHJpYnV0ZXMpO1xuXG4gICAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMigke2F0dHJpYnV0ZXMuc3RyaWRlc1swXX0sICR7YXR0cmlidXRlcy5zdHJpZGVzWzFdfSk7XG4gIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke2F0dHJpYnV0ZXMucGFkc1swXX0sICR7YXR0cmlidXRlcy5wYWRzWzFdfSk7XG4gICR7YWN0aXZhdGlvbkZ1bmN0aW9ufVxuICB2b2lkIG1haW4oKSB7XG4gICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgaW50IGJhdGNoID0gY29vcmRzLng7XG4gICAgaW50IG91dHB1dF9jaGFubmVsID0gY29vcmRzLnk7XG5cbiAgICBpdmVjMiBsb2MgPSBjb29yZHMuencgKyBwYWRzO1xuXG4gICAgaW50IGdyb3VwX2lkID0gb3V0cHV0X2NoYW5uZWwgLyAke291dHB1dENoYW5uZWxzUGVyR3JvdXB9O1xuICAgIGludCB3T3V0Q2hhbm5lbCA9IG91dHB1dF9jaGFubmVsIC0gZ3JvdXBfaWQgKiAke291dHB1dENoYW5uZWxzUGVyR3JvdXB9O1xuXG4gICAgZmxvYXQgdmFsdWUgPSAke3ZhbHVlSW5pdH07XG4gICAgZm9yIChpbnQgaW5DaGFubmVsT2Zmc2V0ID0gMDsgaW5DaGFubmVsT2Zmc2V0IDwgJHtpbnB1dENoYW5uZWxzUGVyR3JvdXB9OyBpbkNoYW5uZWxPZmZzZXQrKykge1xuICAgICAgaW50IGlucHV0X2NoYW5uZWwgPSBncm91cF9pZCAqICR7aW5wdXRDaGFubmVsc1Blckdyb3VwfSArIGluQ2hhbm5lbE9mZnNldDtcbiAgICAgIGZvciAoaW50IHdXT2ZmID0gMDsgd1dPZmYgPCAke3dTaGFwZVsyXX07IHdXT2ZmKyspIHtcbiAgICAgICAgZm9yIChpbnQgd0hPZmYgPSAwOyB3SE9mZiA8ICR7d1NoYXBlWzNdfTsgd0hPZmYrKykge1xuICAgICAgICAgIGl2ZWMyIHdPZmYgPSBpdmVjMih3V09mZiAqICR7YXR0cmlidXRlcy5kaWxhdGlvbnNbMF19LCB3SE9mZiAqICR7YXR0cmlidXRlcy5kaWxhdGlvbnNbMV19KTtcbiAgICAgICAgICBpdmVjMiB3TG9jID0gbG9jIC0gd09mZjtcbiAgICAgICAgICBpdmVjMiB3TG9jSW4gPSB3TG9jIC8gc3RyaWRlcztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB3TG9jSW4gKiBzdHJpZGVzID09IHdMb2MgJiZcbiAgICAgICAgICAgIHdMb2NJbi54ID49IDAgJiYgd0xvY0luLnggPCAke3hTaGFwZVsyXX0gJiZcbiAgICAgICAgICAgIHdMb2NJbi55ID49IDAgJiYgd0xvY0luLnkgPCAke3hTaGFwZVszXX1cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGZsb2F0IHhWYWwgPSBnZXRYKGJhdGNoLCBpbnB1dF9jaGFubmVsLCB3TG9jSW4ueSwgd0xvY0luLngpO1xuICAgICAgICAgICAgZmxvYXQgd1ZhbCA9IGdldFcoaW5wdXRfY2hhbm5lbCwgd091dENoYW5uZWwsIHdIT2ZmLCB3V09mZik7XG4gICAgICAgICAgICB2YWx1ZSArPSB4VmFsICogd1ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgJHthcHBseUFjdGl2YXRpb259XG4gICAgJHtnbHNsLm91dHB1dH0gPSB2ZWM0KHZhbHVlLCAuMCwgLjAsIC4wKTtcbiAgfVxuYDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICBvdXRwdXQ6IHtkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgICAgIHNoYWRlclNvdXJjZSxcbiAgICAgICAgaGFzTWFpbjogdHJ1ZSxcbiAgICAgIH07XG4gICAgfTtcblxuY29uc3QgY3JlYXRlVW5wYWNrZWRDb252VHJhbnNwb3NlUHJvZ3JhbUluZm9Mb2FkZXIgPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogcmVhZG9ubHkgVGVuc29yW10sIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzKTpcbiAgICAgICAgUHJvZ3JhbUluZm9Mb2FkZXIgPT4ge1xuICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gY3JlYXRlQ29udlRyYW5zcG9zZVByb2dyYW1NZXRhZGF0YShpbnB1dHMubGVuZ3RoID4gMiwgYXR0cmlidXRlcy5jYWNoZUtleSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiBjcmVhdGVVbnBhY2tlZENvbnZUcmFuc3Bvc2VQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIG1ldGFkYXRhLCBhdHRyaWJ1dGVzKVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG5cblxuY29uc3QgY29udlRyYW5zcG9zZTJEVW5wYWNrZWQgPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogcmVhZG9ubHkgVGVuc29yW10sIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzKTpcbiAgICAgICAgVGVuc29yID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICAgICAgICAgICAgY3JlYXRlVW5wYWNrZWRDb252VHJhbnNwb3NlUHJvZ3JhbUluZm9Mb2FkZXIoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhdHRyaWJ1dGVzKSwgaW5wdXRzKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuXG5jb25zdCBnZXRBZGp1c3RlZENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzID0gPFQgZXh0ZW5kcyBDb252VHJhbnNwb3NlQXR0cmlidXRlcz4oYXR0cmlidXRlczogVCwgaW5wdXRzOiBUZW5zb3JbXSk6IFQgPT4ge1xuICBjb25zdCBrZXJuZWxTaGFwZSA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUuc2xpY2UoKTtcbiAgLy8gaWYga2VybmVsU2hhcGUgaXMgbm90IHNwZWNpZmllZCBpbiB0aGUgYXR0cmlidXRlcyBvZiB0aGlzIG9wLCBpbmZlciBpdCBmcm9tIHRoZSB3ZWlnaHQgdGVuc29yIGRpbXNcbiAgaWYgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChsZXQgaSA9IDI7IGkgPCBpbnB1dHNbMV0uZGltcy5sZW5ndGg7ICsraSkge1xuICAgICAga2VybmVsU2hhcGUucHVzaChpbnB1dHNbMV0uZGltc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMucGFkcy5zbGljZSgpO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGF0dHJpYnV0ZXMub3V0cHV0U2hhcGUuc2xpY2UoKTtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICAvLyBJZiBvdXRwdXRTaGFwZSBpcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBhdHRyaWJ1dGVzIG9mIHRoaXMgb3AsIGluZmVyIGl0IGZyb20gdGhlIHBhcmFtZXRlcnNcbiAgLy8gU2ltaWxhcmx5LCBhdXRvbWF0aWNhbGx5IGluZmVyIHBhZHMgaWYgbm90IHNwZWNpZmllZFxuICBjYWxjdWxhdGVPdXRwdXRTaGFwZUFuZFBhZHMoXG4gICAgICBpbnB1dFNoYXBlLCBrZXJuZWxTaGFwZSwgYXR0cmlidXRlcy5kaWxhdGlvbnMsIGF0dHJpYnV0ZXMuYXV0b1BhZCwgcGFkcywgYXR0cmlidXRlcy5zdHJpZGVzLFxuICAgICAgYXR0cmlidXRlcy5vdXRwdXRQYWRkaW5nLCBvdXRwdXRTaGFwZSk7XG5cbiAgLy8gYWx3YXlzIHJldHVybiBhIG5ldyBvYmplY3Qgc28gZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCBhdHRyaWJ1dGVzXG4gIGNvbnN0IG5ld0F0dHJpYnV0ZXM6IFQgPSBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKTtcbiAgT2JqZWN0LmFzc2lnbihuZXdBdHRyaWJ1dGVzLCB7a2VybmVsU2hhcGUsIHBhZHMsIG91dHB1dFNoYXBlLCBjYWNoZUtleTogYXR0cmlidXRlcy5jYWNoZUtleX0pO1xuICByZXR1cm4gbmV3QXR0cmlidXRlcztcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzPiA9XG4gICAgKG5vZGU6IEdyYXBoLk5vZGUpOiBDb252VHJhbnNwb3NlQXR0cmlidXRlcyA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgY29uc3QgYWN0aXZhdGlvbkF0dHJpYnV0ZXMgPSBwYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMoYXR0cmlidXRlcyk7XG4gICAgICAvLyBUT0RPIDogTWFrZSB0aGlzIGdlbmVyaWMgZW5vdWdoIHRvIGNvbXB1dGUgZGVmYXVsdCBhdHRyaWJ1dGVzIGZvciBtdWx0aS1kaW1lbnNpb25hbCBjb252XG4gICAgICBjb25zdCBhdXRvUGFkID0gYXR0cmlidXRlcy5nZXRTdHJpbmcoJ2F1dG9fcGFkJywgJ05PVFNFVCcpO1xuICAgICAgY29uc3QgZGlsYXRpb25zID0gYXR0cmlidXRlcy5nZXRJbnRzKCdkaWxhdGlvbnMnLCBbMSwgMV0pO1xuICAgICAgY29uc3QgZ3JvdXAgPSBhdHRyaWJ1dGVzLmdldEludCgnZ3JvdXAnLCAxKTtcbiAgICAgIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5nZXRJbnRzKCdrZXJuZWxfc2hhcGUnLCBbXSk7XG4gICAgICBjb25zdCBvdXRwdXRQYWRkaW5nID0gYXR0cmlidXRlcy5nZXRJbnRzKCdvdXRwdXRfcGFkZGluZycsIFswLCAwXSk7XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGF0dHJpYnV0ZXMuZ2V0SW50cygnb3V0cHV0X3NoYXBlJywgW10pO1xuICAgICAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMuZ2V0SW50cygncGFkcycsIFswLCAwLCAwLCAwXSk7XG4gICAgICBjb25zdCBzdHJpZGVzID0gYXR0cmlidXRlcy5nZXRJbnRzKCdzdHJpZGVzJywgWzEsIDFdKTtcblxuICAgICAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShcbiAgICAgICAgICB7YXV0b1BhZCwgZGlsYXRpb25zLCBncm91cCwga2VybmVsU2hhcGUsIG91dHB1dFBhZGRpbmcsIG91dHB1dFNoYXBlLCBwYWRzLCBzdHJpZGVzLCAuLi5hY3RpdmF0aW9uQXR0cmlidXRlc30pO1xuICAgIH07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIC8vIFJlZmVyIHRvIHRoZSBiZWxvdyBsaW5rIGZvciBhbGwgaW5wdXQgY2hlY2tzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vbm54L29ubngvYmxvYi9tYWluL2RvY3MvT3BlcmF0b3JzLm1kI0NvbnZcbiAgaWYgKCFpbnB1dHMgfHwgKGlucHV0cy5sZW5ndGggIT09IDIgJiYgaW5wdXRzLmxlbmd0aCAhPT0gMykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0cycpO1xuICB9XG5cbiAgLy8gVE9ETyA6IE5lZWQgdG8gYWRkIHN1cHBvcnQgZm9yIG11bHRpLWRpbWVuc2lvbmFsIGNvbnZcbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gNCB8fCBpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnRseSBvbmx5IHN1cHBvcnQgMi1kaW1lbnNpb25hbCBjb252Jyk7XG4gIH1cblxuICAvLyBGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXG4gIGNvbnN0IGRhdGFDaGFubmVsID0gaW5wdXRzWzBdLmRpbXNbMV07XG4gIGNvbnN0IGZpbHRlckluQ2hhbm5lbCA9IGlucHV0c1sxXS5kaW1zWzBdO1xuICBpZiAoZGF0YUNoYW5uZWwgIT09IGZpbHRlckluQ2hhbm5lbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTCcpO1xuICB9XG5cbiAgY29uc3QgZmVhdHVyZU1hcHMgPSBpbnB1dHNbMV0uZGltc1sxXSAqIGF0dHJpYnV0ZXMuZ3JvdXA7XG5cbiAgLy8gaWYgYmlhcyBpcyBwcm92aWRlZCBpdCBzaG91bGQgYmUgMUQgYW5kIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgc2hvdWxkIGJlIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgZmVhdHVyZSBtYXBzXG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSAzICYmIChpbnB1dHNbMl0uZGltcy5sZW5ndGggIT09IDEgfHwgaW5wdXRzWzJdLmRpbXNbMF0gIT09IGZlYXR1cmVNYXBzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBiaWFzJyk7XG4gIH1cblxuICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDI7XG4gIC8vIHdyb25nIGRpbGF0aW9ucyBkaW1lbnNpb25cbiAgaWYgKGF0dHJpYnV0ZXMuZGlsYXRpb25zLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGRpbGF0aW9ucyBzaG91bGQgYmUgJHtzcGF0aWFsUmFua31EYCk7XG4gIH1cblxuICAvLyBXcm9uZyBzdHJpZGVzIGRpbWVuc2lvblxuICBpZiAoYXR0cmlidXRlcy5zdHJpZGVzLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xuICB9XG5cbiAgLy8gV3JvbmcgcGFkcyBkaW1lbnNpb25cbiAgaWYgKGF0dHJpYnV0ZXMucGFkcy5sZW5ndGggIT09IHNwYXRpYWxSYW5rICogMikge1xuICAgIHRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHtzcGF0aWFsUmFuayAqIDJ9RGApO1xuICB9XG5cbiAgLy8gV3Jvbmcgb3V0cHV0IHBhZGRpbmcgZGltZW5zaW9uXG4gIGlmIChhdHRyaWJ1dGVzLm91dHB1dFBhZGRpbmcubGVuZ3RoICE9PSBzcGF0aWFsUmFuaykge1xuICAgIHRocm93IG5ldyBFcnJvcihgb3V0cHV0X3BhZGRpbmcgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xuICB9XG5cbiAgLy8gaWYga2VybmVsU2hhcGUgaXMgc3BlY2lmaWVkLCBpdCdzIGRhdGEgbGVuZ3RoIG11c3QgYmUgMiBsZXNzIHRoYW4gZGltcyBsZW5ndGggb2YgdGhlIHdlaWdodHMgdGVuc29yXG4gIC8vICh0aGUgZmlyc3QgMiBkaW1zIGFyZSBiYXRjaF9zaXplIGFuZCBjaGFubmVscylcbiAgaWYgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoICE9PSAwICYmIGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoICE9PSBpbnB1dHNbMV0uZGltcy5sZW5ndGggLSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGtlcm5lbCBzaGFwZScpO1xuICB9XG5cbiAgLy8gYXMgd2l0aCBrZXJuZWxTaGFwZSwgbXVzdCBoYXZlIHNhbWUgbnVtYmVyIG9mIHNwYXRpYWwgZGltcyBhcyBpbnB1dFxuICBpZiAoYXR0cmlidXRlcy5vdXRwdXRTaGFwZS5sZW5ndGggIT09IDAgJiYgYXR0cmlidXRlcy5vdXRwdXRTaGFwZS5sZW5ndGggIT09IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgb3V0cHV0IHNoYXBlJyk7XG4gIH1cblxuICAvLyBUT0RPIDogTmVlZCB0byBhZGQgc3VwcG9ydCBmb3IgZmxvYXQ2NFxuICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyB8fCBpbnB1dHNbMV0udHlwZSAhPT0gJ2Zsb2F0MzInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb252VHJhbnNwb3NlIGlucHV0KFgsVykgc2hvdWxkIGJlIGZsb2F0IHRlbnNvcicpO1xuICB9XG5cbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgaW5wdXRzWzJdLnR5cGUgIT09ICdmbG9hdDMyJykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29udlRyYW5zcG9zZSBpbnB1dChiaWFzKSBzaG91bGQgYmUgZmxvYXQgdGVuc29yJyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uLy4uLy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0dyYXBofSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQge09wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb259IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBUZXh0dXJlVHlwZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zcG9zZUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBwZXJtOiBudW1iZXJbXTtcbn1cblxuY29uc3QgdHJhbnNwb3NlUHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAnVHJhbnNwb3NlJyxcbiAgaW5wdXROYW1lczogWydBJ10sXG4gIGlucHV0VHlwZXM6IFtUZXh0dXJlVHlwZS51bnBhY2tlZF1cbn07XG5cbmV4cG9ydCBjb25zdCB0cmFuc3Bvc2U6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248VHJhbnNwb3NlQXR0cmlidXRlcz4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IFRyYW5zcG9zZUF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiB7XG4gICAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICAgICAgY29uc3Qgb3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4udHJhbnNwb3NlUHJvZ3JhbU1ldGFkYXRhLFxuICAgICAgICAgICAgY2FjaGVIaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHNbMF0sIGF0dHJpYnV0ZXMucGVybSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlucHV0cyk7XG4gICAgICByZXR1cm4gW291dHB1dF07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlVHJhbnNwb3NlQXR0cmlidXRlczogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxUcmFuc3Bvc2VBdHRyaWJ1dGVzPiA9XG4gICAgKG5vZGU6IEdyYXBoLk5vZGUpOiBUcmFuc3Bvc2VBdHRyaWJ1dGVzID0+IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7cGVybTogbm9kZS5hdHRyaWJ1dGVzLmdldEludHMoJ3Blcm0nLCBbXSl9KTtcblxuY29uc3QgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8gPVxuICAgIChfaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dDogVGVuc29yLCBwZXJtOiBudW1iZXJbXSk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dC5kaW1zO1xuICAgICAgcGVybSA9IGdldEFkanVzdGVkUGVybShpbnB1dFNoYXBlLCBwZXJtKTtcbiAgICAgIGNvbnN0IHVucGFja2VkT3V0cHV0U2hhcGUgPSBnZXRPdXRwdXRTaGFwZShpbnB1dFNoYXBlLCBwZXJtKTtcbiAgICAgIGNvbnN0IHJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcbiAgICAgIC8vIEEgZGltcz1bJHtpbnB1dHNbMF0uZGltcy50b1N0cmluZygpfV1cbiAgICAgIC8vIG91dCBEaW1zPVske3VucGFja2VkT3V0cHV0U2hhcGUudG9TdHJpbmcoKX1dXG4gICAgICAvLyBiYXNlZCBvbiBwZXJtPVske3Blcm0udG9TdHJpbmcoKX1dXG4gICAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICAke2dldFBlcm1GdW5jdGlvbkJvZHkoJ3Blcm0nLCBwZXJtLCByYW5rKX1cbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgaW50IGFbJHtyYW5rfV07XG4gICAgICAgIHBlcm0oYSwgaW5kaWNlcyk7XG4gICAgICAgIHJldHVybiBfQShhKTtcbiAgICAgIH1gO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4udHJhbnNwb3NlUHJvZ3JhbU1ldGFkYXRhLFxuICAgICAgICBvdXRwdXQ6IHtkaW1zOiB1bnBhY2tlZE91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dC50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWR9LFxuICAgICAgICBzaGFkZXJTb3VyY2VcbiAgICAgIH07XG4gICAgfTtcblxuY29uc3QgZ2V0QWRqdXN0ZWRQZXJtID0gKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBwZXJtOiBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcbiAgaWYgKHBlcm0gJiYgcGVybS5sZW5ndGggIT09IGlucHV0U2hhcGUubGVuZ3RoKSB7XG4gICAgcGVybSA9IFsuLi4oaW5wdXRTaGFwZS5rZXlzKCkpXS5yZXZlcnNlKCk7XG4gIH1cbiAgcmV0dXJuIHBlcm07XG59O1xuXG5jb25zdCBnZXRPdXRwdXRTaGFwZSA9IChpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgcGVybTogbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSA9PiB7XG4gIHBlcm0gPSBnZXRBZGp1c3RlZFBlcm0oaW5wdXRTaGFwZSwgcGVybSk7XG4gIHJldHVybiBTaGFwZVV0aWwuc29ydEJhc2VkT25QZXJtKGlucHV0U2hhcGUsIHBlcm0pO1xufTtcblxuY29uc3QgZ2V0UGVybUZ1bmN0aW9uQm9keSA9IChuYW1lOiBzdHJpbmcsIHBlcm06IG51bWJlcltdLCByYW5rOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICBjb25zdCByZXZlcnNlRnVuYyA9IFtdO1xuICByZXZlcnNlRnVuYy5wdXNoKGB2b2lkICR7bmFtZX0ob3V0IGludCBhWyR7cmFua31dLCBpbnQgc3JjWyR7cmFua31dKSB7YCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgcmV2ZXJzZUZ1bmMucHVzaChgXFx0YVske3Blcm1baV19XT1zcmNbJHtpfV07YCk7XG4gIH1cbiAgcmV2ZXJzZUZ1bmMucHVzaCgnXFx0fScpO1xuICByZXR1cm4gcmV2ZXJzZUZ1bmMuam9pbignXFxuJyk7XG59O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9zZSByZXF1aXJlcyAxIGlucHV0LicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDY0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgc2hvdWxkIGJlIGZsb2F0IHRlbnNvcicpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0dyYXBofSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQge09wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb259IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5cbmltcG9ydCB7dHJhbnNwb3NlLCBUcmFuc3Bvc2VBdHRyaWJ1dGVzfSBmcm9tICcuL3RyYW5zcG9zZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVwdGhUb1NwYWNlQXR0cmlidXRlcyB7XG4gIG1vZGU6ICdEQ1InfCdDUkQnO1xuICBibG9ja3NpemU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IGRlcHRoVG9TcGFjZTogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzPiA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogRGVwdGhUb1NwYWNlQXR0cmlidXRlcyk6IFRlbnNvcltdID0+IHtcbiAgICAgIHZhbGlkYXRlSW5wdXRzKGlucHV0cyk7XG4gICAgICBjb25zdCBibG9ja3NpemUgPSBhdHRyaWJ1dGVzLmJsb2Nrc2l6ZTtcbiAgICAgIGNvbnN0IGJsb2Nrc2l6ZVNxciA9IGJsb2Nrc2l6ZSAqIGJsb2Nrc2l6ZTtcbiAgICAgIGNvbnN0IHRyYW5zcG9zZVBlcm0gPSBhdHRyaWJ1dGVzLm1vZGUgPT09ICdEQ1InID8gWzAsIDMsIDQsIDEsIDUsIDJdIDogWzAsIDEsIDQsIDIsIDUsIDNdO1xuICAgICAgY29uc3QgZmlyc3RSZXNoYXBlU2hhcGUgPSBhdHRyaWJ1dGVzLm1vZGUgPT09ICdEQ1InID9cbiAgICAgICAgICBbXG4gICAgICAgICAgICBpbnB1dHNbMF0uZGltc1swXSwgYmxvY2tzaXplLCBibG9ja3NpemUsIGlucHV0c1swXS5kaW1zWzFdIC8gYmxvY2tzaXplU3FyLCBpbnB1dHNbMF0uZGltc1syXSxcbiAgICAgICAgICAgIGlucHV0c1swXS5kaW1zWzNdXG4gICAgICAgICAgXSA6XG4gICAgICAgICAgW1xuICAgICAgICAgICAgaW5wdXRzWzBdLmRpbXNbMF0sIGlucHV0c1swXS5kaW1zWzFdIC8gYmxvY2tzaXplU3FyLCBibG9ja3NpemUsIGJsb2Nrc2l6ZSwgaW5wdXRzWzBdLmRpbXNbMl0sXG4gICAgICAgICAgICBpbnB1dHNbMF0uZGltc1szXVxuICAgICAgICAgIF07XG5cbiAgICAgIC8vIGNvbnN0IHRyYW5zcG9zZSA9IG5ldyBXZWJHTFRyYW5zcG9zZSgpO1xuICAgICAgLy8gY29uc3QgYXR0cmlidXRlcyA9IG5ldyBBdHRyaWJ1dGUodW5kZWZpbmVkKTtcbiAgICAgIC8vIGF0dHJpYnV0ZXMuc2V0KCdwZXJtJywgJ2ludHMnLCB0cmFuc3Bvc2VQZXJtKTtcbiAgICAgIC8vIHRyYW5zcG9zZS5pbml0aWFsaXplKGF0dHJpYnV0ZXMpO1xuXG4gICAgICAvLyBGaXJzdCByZXNoYXBlXG4gICAgICBjb25zdCBmaXJzdFJlc2hhcGVkVGVuc29yID0gaW5mZXJlbmNlSGFuZGxlci5yZXNoYXBlVW5wYWNrZWQoaW5wdXRzWzBdLCBmaXJzdFJlc2hhcGVTaGFwZSk7XG5cbiAgICAgIC8vIHRyYW5zcG9zZVxuICAgICAgY29uc3QgdHJhbnNwb3NlQXR0cmlidXRlczogVHJhbnNwb3NlQXR0cmlidXRlcyA9IHtwZXJtOiB0cmFuc3Bvc2VQZXJtLCBjYWNoZUtleTogYCR7dHJhbnNwb3NlUGVybX1gfTtcbiAgICAgIGNvbnN0IFt0cmFuc3Bvc2VPdXRwdXRdID0gdHJhbnNwb3NlKGluZmVyZW5jZUhhbmRsZXIsIFtmaXJzdFJlc2hhcGVkVGVuc29yXSwgdHJhbnNwb3NlQXR0cmlidXRlcyk7XG5cbiAgICAgIC8vIFNlY29uZCByZXNoYXBlXG4gICAgICBjb25zdCBzZWNvbmRSZXNoYXBlU2hhcGUgPSBbXG4gICAgICAgIGlucHV0c1swXS5kaW1zWzBdLCBpbnB1dHNbMF0uZGltc1sxXSAvIGJsb2Nrc2l6ZVNxciwgaW5wdXRzWzBdLmRpbXNbMl0gKiBibG9ja3NpemUsXG4gICAgICAgIGlucHV0c1swXS5kaW1zWzNdICogYmxvY2tzaXplXG4gICAgICBdO1xuICAgICAgY29uc3QgcmVzdWx0ID0gaW5mZXJlbmNlSGFuZGxlci5yZXNoYXBlVW5wYWNrZWQodHJhbnNwb3NlT3V0cHV0LCBzZWNvbmRSZXNoYXBlU2hhcGUpO1xuICAgICAgcmV0dXJuIFtyZXN1bHRdO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBwYXJzZURlcHRoVG9TcGFjZUF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248RGVwdGhUb1NwYWNlQXR0cmlidXRlcz4gPVxuICAgIChub2RlOiBHcmFwaC5Ob2RlKTogRGVwdGhUb1NwYWNlQXR0cmlidXRlcyA9PiB7XG4gICAgICAvLyBwcm9jZXNzaW5nIG5vZGUgYXR0cmlidXRlc1xuICAgICAgY29uc3QgYmxvY2tzaXplID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludCgnYmxvY2tzaXplJyk7XG4gICAgICBpZiAoYmxvY2tzaXplIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJsb2Nrc2l6ZSBtdXN0IGJlID49IDEsIGJ1dCBnb3QgOiAke2Jsb2Nrc2l6ZX0gZm9yIERlcHRoVG9TcGFjZWApO1xuICAgICAgfVxuICAgICAgY29uc3QgbW9kZSA9IG5vZGUuYXR0cmlidXRlcy5nZXRTdHJpbmcoJ21vZGUnLCAnRENSJyk7XG4gICAgICBpZiAobW9kZSAhPT0gJ0RDUicgJiYgbW9kZSAhPT0gJ0NSRCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgbW9kZTogJHttb2RlfSBmb3IgRGVwdGhUb1NwYWNlYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge21vZGUsIGJsb2Nrc2l6ZX07XG4gICAgfTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRGVwdGhUb1NwYWNlIGV4cGVjdCAxIGlucHV0cywgYnV0IGdvdCAke2lucHV0cy5sZW5ndGh9YCk7XG4gIH1cblxuICAvLyBJbnB1dCBoYXMgdG8gYmUgYSA0LUQgdGVuc29yXG4gIC8vIFRPRE86IFN1cHBvcnQgc3RyaW5nIGRlcHRoLXRvLXNwYWNlLlxuICBpZiAoaW5wdXRzWzBdLnR5cGUgPT09ICdzdHJpbmcnIHx8IGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RlcHRoVG9TcGFjZSBpbnB1dCBzaG91bGQgYmUgYSA0LUQgbnVtZXJpYyB0ZW5zb3InKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHtPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9ufSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuXG5leHBvcnQgY29uc3QgZmxhdHRlbjogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxudW1iZXI+ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBheGlzOiBudW1iZXIpOiBUZW5zb3JbXSA9PiB7XG4gICAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIGF4aXMpO1xuXG4gICAgICBjb25zdCBvdXRwdXREaW1zID0gU2hhcGVVdGlsLmZsYXR0ZW5TaGFwZShpbnB1dHNbMF0uZGltcywgYXhpcyk7XG4gICAgICByZXR1cm4gW2luZmVyZW5jZUhhbmRsZXIucmVzaGFwZVVucGFja2VkKGlucHV0c1swXSwgb3V0cHV0RGltcyldO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUZsYXR0ZW5BdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPG51bWJlcj4gPSAobm9kZTogR3JhcGguTm9kZSk6IG51bWJlciA9PlxuICAgIG5vZGUuYXR0cmlidXRlcy5nZXRJbnQoJ2F4aXMnLCAxKTsgIC8vIGRlZmF1bHQgYXhpcyBpcyAxXG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10sIGF4aXM6IG51bWJlcik6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0dGVuIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cblxuICBjb25zdCByID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuICBpZiAociA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2NhbGFyIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICB9XG5cbiAgaWYgKGF4aXMgPCAtciB8fCBheGlzID4gcikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBheGlzJyk7XG4gIH1cblxuICAvLyBUT0RPOiBTdXBwb3J0IHN0cmluZyB0eXBlXG4gIGlmIChpbnB1dHNbMF0udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgfVxufTsiLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7SW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi9iYWNrZW5kJztcbmltcG9ydCB7R3JhcGh9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4vdGVuc29yJztcblxuZXhwb3J0IHR5cGUgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxUPiA9IChpbmZlcmVuY2VIYW5kbGVyOiBJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBjb250ZXh0OiBUKSA9PiBUZW5zb3JbXTtcbmV4cG9ydCB0eXBlIE9wZXJhdG9ySW5pdGlhbGl6YXRpb248VD4gPSAobm9kZTogR3JhcGguTm9kZSwgZ3JhcGg6IEdyYXBoKSA9PiBUO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9wZXJhdG9yIHtcbiAgcmVhZG9ubHkgaW1wbDogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjx1bmtub3duPjtcbiAgcmVhZG9ubHkgY29udGV4dDogR3JhcGguTm9kZXx1bmtub3duO1xufVxuXG5leHBvcnQgY29uc3QgTlVNQkVSX1RZUEVTOiByZWFkb25seSBUZW5zb3IuRGF0YVR5cGVbXSA9XG4gICAgWydmbG9hdDMyJywgJ2Zsb2F0NjQnLCAnaW50MzInLCAnaW50MTYnLCAnaW50OCcsICd1aW50MTYnLCAndWludDMyJywgJ3VpbnQ4J107XG5leHBvcnQgY29uc3QgSU5UX1RZUEVTOiByZWFkb25seSBUZW5zb3IuRGF0YVR5cGVbXSA9IFsnaW50MzInLCAnaW50MTYnLCAnaW50OCcsICd1aW50MTYnLCAndWludDMyJywgJ3VpbnQ4J107XG5leHBvcnQgY29uc3QgRkxPQVRfVFlQRVM6IHJlYWRvbmx5IFRlbnNvci5EYXRhVHlwZVtdID0gWydmbG9hdDMyJywgJ2Zsb2F0NjQnXTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7R3JhcGh9IGZyb20gJy4uLy4uLy4uL2dyYXBoJztcbmltcG9ydCB7TlVNQkVSX1RZUEVTLCBPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9ufSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUHJvZ3JhbUluZm9Mb2FkZXIsIFByb2dyYW1NZXRhZGF0YSwgVGV4dHVyZVR5cGV9IGZyb20gJy4uL3R5cGVzJztcblxuaW50ZXJmYWNlIEdhdGhlckF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBheGlzOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBnYXRoZXI6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248R2F0aGVyQXR0cmlidXRlcz4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IEdhdGhlckF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiB7XG4gICAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIGF0dHJpYnV0ZXMuYXhpcyk7XG4gICAgICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihjcmVhdGVHYXRoZXJQcm9ncmFtSW5mb0xvYWRlcihpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGF0dHJpYnV0ZXMpLCBpbnB1dHMpO1xuICAgICAgcmV0dXJuIFtvdXRwdXRdO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUdhdGhlckF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248R2F0aGVyQXR0cmlidXRlcz4gPSAobm9kZTogR3JhcGguTm9kZSk6IEdhdGhlckF0dHJpYnV0ZXMgPT5cbiAgICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe2F4aXM6IG5vZGUuYXR0cmlidXRlcy5nZXRJbnQoJ2F4aXMnLCAwKX0pO1xuXG5jb25zdCBnYXRoZXJQcm9ncmFtTWV0YWRhdGEgPSB7XG4gIG5hbWU6ICdHYXRoZXInLFxuICBpbnB1dE5hbWVzOiBbJ0EnLCAnQiddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXSxcbn07XG5cbmNvbnN0IGNyZWF0ZUdhdGhlclByb2dyYW1JbmZvID1cbiAgICAoX2hhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgbWV0YWRhdGE6IFByb2dyYW1NZXRhZGF0YSwgaW5wdXRzOiBUZW5zb3JbXSwgYXhpczogbnVtYmVyKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gICAgICBjb25zdCBpbmRleERhdGFTaGFwZSA9IGlucHV0c1sxXS5kaW1zLnNsaWNlKCk7XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IG5ldyBBcnJheShpbnB1dFNoYXBlLmxlbmd0aCArIGluZGV4RGF0YVNoYXBlLmxlbmd0aCAtIDEpO1xuXG4gICAgICBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXhpcywgaW5wdXRTaGFwZS5sZW5ndGgpO1xuICAgICAgY29uc3QgaW5kZXhDb3B5T3BzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBvdXRwdXRTaGFwZSBpcyBkaXZpZGVkIGludG8gdGhyZWUgcGFydHM6IEEsIEIsIENcbiAgICAgICAgLy8gfDAgICAgICAgIGF4aXN8ICBheGlzICsgaW5kZXhEYXRhU2hhcGUubGVuZ3RoIHwgICAgICAgICAgZW5kfFxuICAgICAgICAvLyB8ICAgICBBICAgICAgIHwgICAgICAgICAgICAgQiAgICAgICAgICAgICAgICAgfCAgICAgIEMgICAgICB8XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGlucHV0SWR4OiBbQSwgaW5wdXRzWzFdW0JdLCBDXVxuICAgICAgICBpZiAoaSA8IGF4aXMpIHsgIC8vIEFcbiAgICAgICAgICBvdXRwdXRTaGFwZVtpXSA9IGlucHV0U2hhcGVbaV07XG4gICAgICAgICAgaW5kZXhDb3B5T3BzLnB1c2goYGlucHV0SWR4WyR7aX1dID0gb3V0cHV0SWR4WyR7aX1dO2ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpIDwgYXhpcyArIGluZGV4RGF0YVNoYXBlLmxlbmd0aCkgeyAgLy8gQlxuICAgICAgICAgICAgb3V0cHV0U2hhcGVbaV0gPSBpbmRleERhdGFTaGFwZVtpIC0gYXhpc107XG4gICAgICAgICAgICBpbmRleENvcHlPcHMucHVzaChgaW5kZXhEYXRhSWR4WyR7aSAtIGF4aXN9XSA9IG91dHB1dElkeFske2l9XTtgKTtcbiAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDXG4gICAgICAgICAgICBvdXRwdXRTaGFwZVtpXSA9IGlucHV0U2hhcGVbaSAtIGluZGV4RGF0YVNoYXBlLmxlbmd0aCArIDFdOyAgLy8gc2tpcCAxIGZvciBheGlzXG4gICAgICAgICAgICBpbmRleENvcHlPcHMucHVzaChgaW5wdXRJZHhbJHtpIC0gaW5kZXhEYXRhU2hhcGUubGVuZ3RoICsgMX1dID0gb3V0cHV0SWR4WyR7aX1dO2ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aCB8fCAxO1xuICAgICAgY29uc3QgaXJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcbiAgICAgIGNvbnN0IGlEcmFuayA9IGluZGV4RGF0YVNoYXBlLmxlbmd0aCB8fCAxO1xuICAgICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgb3V0cHV0SWR4WyR7b3Jhbmt9XSkge1xuICAgICAgICBpbnQgaW5wdXRJZHhbJHtpcmFua31dO1xuICAgICAgICBpbnQgaW5kZXhEYXRhSWR4WyR7aURyYW5rfV07XG4gICAgICAgIGluZGV4RGF0YUlkeFswXSA9IDA7XG4gICAgICAgICR7aW5kZXhDb3B5T3BzLmpvaW4oJ1xcbiAgICAgICAgJyl9XG4gICAgICAgIGludCBpZHggPSBpbnQoX0IoaW5kZXhEYXRhSWR4KSk7XG4gICAgICAgIGlucHV0SWR4WyR7YXhpc31dID0gaWR4IDwgMCA/IGlkeCArICR7aW5wdXRTaGFwZVtheGlzXX0gOiBpZHg7XG4gICAgICAgIHJldHVybiBfQShpbnB1dElkeCk7XG4gICAgICB9YDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICBvdXRwdXQ6IHtkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgICAgIHNoYWRlclNvdXJjZVxuICAgICAgfTtcbiAgICB9O1xuXG5jb25zdCBjcmVhdGVHYXRoZXJQcm9ncmFtSW5mb0xvYWRlciA9XG4gICAgKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogR2F0aGVyQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gey4uLmdhdGhlclByb2dyYW1NZXRhZGF0YSwgY2FjaGVIaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5fTtcbiAgICAgIHJldHVybiB7Li4ubWV0YWRhdGEsIGdldDogKCkgPT4gY3JlYXRlR2F0aGVyUHJvZ3JhbUluZm8oaGFuZGxlciwgbWV0YWRhdGEsIGlucHV0cywgYXR0cmlidXRlcy5heGlzKX07XG4gICAgfTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiBUZW5zb3JbXSwgYXhpczogbnVtYmVyKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dhdGhlciByZXF1aXJlcyAyIGlucHV0cy4nKTtcbiAgfVxuICBjb25zdCB0ZW5zb3JSYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuICBpZiAodGVuc29yUmFuayA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgc2hhcGUuJyk7XG4gIH1cbiAgaWYgKGF4aXMgPCAtdGVuc29yUmFuayB8fCBheGlzID4gdGVuc29yUmFuayAtIDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXhpcy4nKTtcbiAgfVxuICBpZiAoTlVNQkVSX1RZUEVTLmluZGV4T2YoaW5wdXRzWzBdLnR5cGUpID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWlkIGlucHV0IHR5cGUuJyk7XG4gIH1cbiAgaWYgKGlucHV0c1sxXS50eXBlICE9PSAnaW50MzInICYmIGlucHV0c1sxXS50eXBlICE9PSAnaW50MTYnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7R3JhcGh9IGZyb20gJy4uLy4uLy4uL2dyYXBoJztcbmltcG9ydCB7T3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbn0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtHZW1tVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUHJvZ3JhbUluZm9Mb2FkZXIsIFByb2dyYW1NZXRhZGF0YSwgVGV4dHVyZVR5cGV9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBHZW1tQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHRyYW5zQTogYm9vbGVhbjtcbiAgdHJhbnNCOiBib29sZWFuO1xuICBhbHBoYTogbnVtYmVyO1xuICBiZXRhOiBudW1iZXI7XG4gIGlzT3B0aW9uYWxDOiBib29sZWFuOyAgLy8gaW4gb3BzZXQgMTEsIEMgYmVjb21lcyBvcHRpb25hbFxufVxuXG5leHBvcnQgY29uc3QgZ2VtbTogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxHZW1tQXR0cmlidXRlcz4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IEdlbW1BdHRyaWJ1dGVzKTogVGVuc29yW10gPT4ge1xuICAgICAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKGNyZWF0ZUdlbW1Qcm9ncmFtSW5mb0xvYWRlcihpbnB1dHMsIGF0dHJpYnV0ZXMpLCBpbnB1dHMpO1xuICAgICAgcmV0dXJuIFtvdXRwdXRdO1xuICAgIH07XG5cbmNvbnN0IHBhcnNlR2VtbUF0dHJpYnV0ZXMgPSAobm9kZTogR3JhcGguTm9kZSwgaXNPcHRpb25hbEM6IGJvb2xlYW4pOiBHZW1tQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IHRyYW5zQSA9IG5vZGUuYXR0cmlidXRlcy5nZXRJbnQoJ3RyYW5zQScsIDApICE9PSAwO1xuICBjb25zdCB0cmFuc0IgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCd0cmFuc0InLCAwKSAhPT0gMDtcbiAgY29uc3QgYWxwaGEgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ2FscGhhJywgMS4wKTtcbiAgY29uc3QgYmV0YSA9IG5vZGUuYXR0cmlidXRlcy5nZXRGbG9hdCgnYmV0YScsIDEuMCk7XG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe3RyYW5zQSwgdHJhbnNCLCBhbHBoYSwgYmV0YSwgaXNPcHRpb25hbEN9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUdlbW1BdHRyaWJ1dGVzVjc6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248R2VtbUF0dHJpYnV0ZXM+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBHZW1tQXR0cmlidXRlcyA9PlxuICAgIHBhcnNlR2VtbUF0dHJpYnV0ZXMobm9kZSwgZmFsc2UpO1xuXG5leHBvcnQgY29uc3QgcGFyc2VHZW1tQXR0cmlidXRlc1YxMTogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxHZW1tQXR0cmlidXRlcz4gPSAobm9kZTogR3JhcGguTm9kZSk6IEdlbW1BdHRyaWJ1dGVzID0+XG4gICAgcGFyc2VHZW1tQXR0cmlidXRlcyhub2RlLCB0cnVlKTtcblxuY29uc3QgY3JlYXRlR2VtbVByb2dyYW1JbmZvTG9hZGVyID0gKGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IEdlbW1BdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm9Mb2FkZXIgPT4ge1xuICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICBuYW1lOiAnR2VtbScsXG4gICAgaW5wdXROYW1lczogaW5wdXRzLmxlbmd0aCA9PT0gMyA/IFsnQScsICdCJywgJ0MnXSA6IFsnQScsICdCJ10sXG4gICAgaW5wdXRUeXBlczogaW5wdXRzLmxlbmd0aCA9PT0gMyA/IFtUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtUZXh0dXJlVHlwZS51bnBhY2tlZCwgVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxuICAgIGtleTogYXR0cmlidXRlcy5jYWNoZUtleVxuICB9O1xuXG4gIHJldHVybiB7Li4ubWV0YWRhdGEsIGdldDogKCkgPT4gY3JlYXRlR2VtbVByb2dyYW1JbmZvKG1ldGFkYXRhLCBpbnB1dHMsIGF0dHJpYnV0ZXMpfTtcbn07XG5cbmNvbnN0IGNyZWF0ZUdlbW1Qcm9ncmFtSW5mbyA9XG4gICAgKG1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IEdlbW1BdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgYVNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgICAgIGNvbnN0IGJTaGFwZSA9IGlucHV0c1sxXS5kaW1zLnNsaWNlKCk7XG4gICAgICBjb25zdCBbTSwgTl0gPSBHZW1tVXRpbC5nZXRTaGFwZU9mR2VtbVJlc3VsdChcbiAgICAgICAgICBhU2hhcGUsIGF0dHJpYnV0ZXMudHJhbnNBLCBiU2hhcGUsIGF0dHJpYnV0ZXMudHJhbnNCLCBpbnB1dHMubGVuZ3RoID09PSAzID8gaW5wdXRzWzJdLmRpbXMgOiB1bmRlZmluZWQpO1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbTSwgTl07XG4gICAgICBpZiAoIW91dHB1dFNoYXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCB1c2UgZ2VtbSBvbiB0aGUgZ2l2ZW4gdGVuc29ycycpO1xuICAgICAgfVxuICAgICAgbGV0IHNoYXJlZERpbSA9IGFTaGFwZVthU2hhcGUubGVuZ3RoIC0gMV07XG4gICAgICBsZXQgbGluZSA9ICcnO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMudHJhbnNBKSB7XG4gICAgICAgIHNoYXJlZERpbSA9IGFTaGFwZVswXTtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGVzLnRyYW5zQSAmJiBhdHRyaWJ1dGVzLnRyYW5zQikge1xuICAgICAgICBsaW5lID0gJ3ZhbHVlICs9IF9BX1QoYSkgKiBfQl9UKGIpOyc7XG4gICAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXMudHJhbnNBICYmICFhdHRyaWJ1dGVzLnRyYW5zQikge1xuICAgICAgICBsaW5lID0gJ3ZhbHVlICs9IF9BX1QoYSkgKiBfQihiKTsnO1xuICAgICAgfSBlbHNlIGlmICghYXR0cmlidXRlcy50cmFuc0EgJiYgYXR0cmlidXRlcy50cmFuc0IpIHtcbiAgICAgICAgbGluZSA9ICd2YWx1ZSArPSBfQShhKSAqIF9CX1QoYik7JztcbiAgICAgIH0gZWxzZSBpZiAoIWF0dHJpYnV0ZXMudHJhbnNBICYmICFhdHRyaWJ1dGVzLnRyYW5zQikge1xuICAgICAgICBsaW5lID0gJ3ZhbHVlICs9IF9BKGEpICogX0IoYik7JztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gICAgICBjb25zdCBkZWNsYXJlQyA9IGlucHV0cy5sZW5ndGggPT09IDMgPyBgaW50IGNbJHtpbnB1dHNbMl0uZGltcy5sZW5ndGh9XTtgIDogJyc7XG4gICAgICBjb25zdCBicm9hZGNhc3RDID0gaW5wdXRzLmxlbmd0aCA9PT0gMyA/ICdiY2FzdEluZGljZXNfQyhpbmRpY2VzLCBjKTsnIDogJyc7XG4gICAgICBjb25zdCBjYWxjdWxhdGVDID0gaW5wdXRzLmxlbmd0aCA9PT0gMyA/ICd2YWx1ZSArPSBiZXRhICogX0MoYyk7JyA6ICcnO1xuICAgICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske3Jhbmt9XSkge1xuICAgICAgICAgIGludCBhWyR7cmFua31dO1xuICAgICAgICAgIGludCBiWyR7cmFua31dO1xuICAgICAgICAgICR7ZGVjbGFyZUN9XG5cbiAgICAgICAgICBjb3B5VmVjKGluZGljZXMsIGEpO1xuICAgICAgICAgIGNvcHlWZWMoaW5kaWNlcywgYik7XG4gICAgICAgICAgJHticm9hZGNhc3RDfVxuXG4gICAgICAgICAgZmxvYXQgdmFsdWUgPSAwLjA7XG4gICAgICAgICAgZm9yIChpbnQgaz0wOyBrPCR7c2hhcmVkRGltfTsgKytrKSB7XG4gICAgICAgICAgICAgIGFbJHtyYW5rIC0gMX1dID0gaztcbiAgICAgICAgICAgICAgYlske3JhbmsgLSAyfV0gPSBrO1xuICAgICAgICAgICAgICAke2xpbmV9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIGFscGhhO1xuICAgICAgICAgICR7Y2FsY3VsYXRlQ31cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9YDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICBvdXRwdXQ6IHtkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgICAgIHZhcmlhYmxlczogW1xuICAgICAgICAgIHtuYW1lOiAnYWxwaGEnLCB0eXBlOiAnZmxvYXQnLCBkYXRhOiBhdHRyaWJ1dGVzLmFscGhhfSwge25hbWU6ICdiZXRhJywgdHlwZTogJ2Zsb2F0JywgZGF0YTogYXR0cmlidXRlcy5iZXRhfVxuICAgICAgICBdLFxuICAgICAgICBzaGFkZXJTb3VyY2VcbiAgICAgIH07XG4gICAgfTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogR2VtbUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGlzIG1pc3NpbmcnKTtcbiAgfVxuICBpZiAoYXR0cmlidXRlcy5pc09wdGlvbmFsQyAmJiAoaW5wdXRzLmxlbmd0aCA8IDIgfHwgaW5wdXRzLmxlbmd0aCA+IDMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhaWQgaW5wdXQgc2hhcGUuJyk7XG4gIH1cbiAgaWYgKCFhdHRyaWJ1dGVzLmlzT3B0aW9uYWxDICYmIGlucHV0cy5sZW5ndGggIT09IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dlbW0gcmVxdWlyZXMgMyBpbnB1dHMnKTtcbiAgfVxuXG4gIC8vICdDJyBjYW4gYmUgb2YgZGltZW5zaW9uYWxpdHkgMSBvciAyIG9ubHlcbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgaW5wdXRzWzJdLmRpbXMubGVuZ3RoICE9PSAxICYmIGlucHV0c1syXS5kaW1zLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCBzaGFwZSBvZiBDJyk7XG4gIH1cblxuICBpZiAoKGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDY0JykgfHxcbiAgICAgIChpbnB1dHNbMV0udHlwZSAhPT0gJ2Zsb2F0MzInICYmIGlucHV0c1sxXS50eXBlICE9PSAnZmxvYXQ2NCcpIHx8XG4gICAgICAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiBpbnB1dHNbMl0udHlwZSAhPT0gJ2Zsb2F0MzInICYmIGlucHV0c1syXS50eXBlICE9PSAnZmxvYXQ2NCcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUuJyk7XG4gIH1cblxuICBpZiAoKGlucHV0c1swXS50eXBlICE9PSBpbnB1dHNbMV0udHlwZSkgfHwgKGlucHV0cy5sZW5ndGggPT09IDMgJiYgaW5wdXRzWzBdLnR5cGUgIT09IGlucHV0c1syXS50eXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgdHlwZXMgYXJlIG1pc21hdGNoZWQnKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7R3JhcGh9IGZyb20gJy4uLy4uLy4uL2dyYXBoJztcbmltcG9ydCB7T3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbn0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFByb2dyYW1JbmZvTG9hZGVyLCBQcm9ncmFtTWV0YWRhdGEsIFRleHR1cmVUeXBlfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgc2NhbGU6IG51bWJlcjtcbiAgYmlhczogbnVtYmVyW107XG59XG5cbmV4cG9ydCBjb25zdCBpbWFnZVNjYWxlcjogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxJbWFnZVNjYWxlckF0dHJpYnV0ZXM+ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBJbWFnZVNjYWxlckF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiB7XG4gICAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICAgICAgY29uc3Qgb3V0cHV0ID1cbiAgICAgICAgICBpbmZlcmVuY2VIYW5kbGVyLnJ1bihjcmVhdGVJbWFnZVNjYWxlclByb2dyYW1JbmZvTG9hZGVyKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcyksIGlucHV0cyk7XG4gICAgICByZXR1cm4gW291dHB1dF07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPEltYWdlU2NhbGVyQXR0cmlidXRlcz4gPVxuICAgIChub2RlOiBHcmFwaC5Ob2RlKTogSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzID0+IHtcbiAgICAgIGNvbnN0IHNjYWxlID0gbm9kZS5hdHRyaWJ1dGVzLmdldEZsb2F0KCdzY2FsZScpO1xuICAgICAgY29uc3QgYmlhcyA9IG5vZGUuYXR0cmlidXRlcy5nZXRGbG9hdHMoJ2JpYXMnKTtcbiAgICAgIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe3NjYWxlLCBiaWFzfSk7XG4gICAgfTtcblxuY29uc3QgaW1hZ2VTY2FsZXJQcm9ncmFtTWV0YWRhdGEgPSB7XG4gIG5hbWU6ICdJbWFnZVNjYWxlcicsXG4gIGlucHV0TmFtZXM6IFsnWCddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxufTtcblxuY29uc3QgY3JlYXRlSW1hZ2VTY2FsZXJQcm9ncmFtSW5mbyA9XG4gICAgKF9oYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIG1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IEltYWdlU2NhbGVyQXR0cmlidXRlcyk6XG4gICAgICAgIFByb2dyYW1JbmZvID0+IHtcbiAgICAgICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gICAgICAgICAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBnZXRCaWFzTWV0aG9kID0gY3JlYXRlR2V0Qmlhc01ldGhvZChhdHRyaWJ1dGVzLmJpYXMubGVuZ3RoKTtcbiAgICAgICAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICAke2dldEJpYXNNZXRob2R9XG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgIHJldHVybiBfWChpbmRpY2VzKSAqIHNjYWxlICsgZ2V0QmlhcyhiaWFzLCBpbmRpY2VzWzFdKTtcbiAgICAgIH1gO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgICAgIG91dHB1dDoge2RpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dHNbMF0udHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnVucGFja2VkfSxcbiAgICAgICAgICAgIHZhcmlhYmxlczogW1xuICAgICAgICAgICAgICB7bmFtZTogJ2JpYXMnLCB0eXBlOiAnZmxvYXQnLCBhcnJheUxlbmd0aDogYXR0cmlidXRlcy5iaWFzLmxlbmd0aCwgZGF0YTogYXR0cmlidXRlcy5iaWFzfSxcbiAgICAgICAgICAgICAge25hbWU6ICdzY2FsZScsIHR5cGU6ICdmbG9hdCcsIGRhdGE6IGF0dHJpYnV0ZXMuc2NhbGV9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgc2hhZGVyU291cmNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuY29uc3QgY3JlYXRlSW1hZ2VTY2FsZXJQcm9ncmFtSW5mb0xvYWRlciA9XG4gICAgKGhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm9Mb2FkZXIgPT4ge1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSB7Li4uaW1hZ2VTY2FsZXJQcm9ncmFtTWV0YWRhdGEsIGNhY2hlSGludDogYXR0cmlidXRlcy5jYWNoZUtleX07XG4gICAgICByZXR1cm4gey4uLm1ldGFkYXRhLCBnZXQ6ICgpID0+IGNyZWF0ZUltYWdlU2NhbGVyUHJvZ3JhbUluZm8oaGFuZGxlciwgbWV0YWRhdGEsIGlucHV0cywgYXR0cmlidXRlcyl9O1xuICAgIH07XG5cbmNvbnN0IGNyZWF0ZUdldEJpYXNNZXRob2QgPSAobnVtQ2hhbm5lbHM6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGNvZGVMaW5lczogc3RyaW5nW10gPSBbYGZsb2F0IGdldEJpYXMoZmxvYXQgYmlhc1ske251bUNoYW5uZWxzfV0sIGludCBjaGFubmVsKSB7YF07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ2hhbm5lbHM7ICsraSkge1xuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBjb2RlTGluZXMucHVzaChcbiAgICAgICAgICAnXFx0JyArXG4gICAgICAgICAgYGlmIChjaGFubmVsID09ICR7aX0pIHsgcmV0dXJuIGJpYXNbJHtpfV07IH1gKTtcbiAgICB9IGVsc2UgaWYgKGkgPT09IG51bUNoYW5uZWxzIC0gMSkge1xuICAgICAgY29kZUxpbmVzLnB1c2goXG4gICAgICAgICAgJ1xcdCcgK1xuICAgICAgICAgIGBlbHNlIHsgcmV0dXJuIGJpYXNbJHtpfV07IH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZUxpbmVzLnB1c2goXG4gICAgICAgICAgJ1xcdCcgK1xuICAgICAgICAgIGBlbHNlIGlmIChjaGFubmVsID09ICR7aX0pIHsgcmV0dXJuIGJpYXNbJHtpfV07IH1gKTtcbiAgICB9XG4gIH1cbiAgY29kZUxpbmVzLnB1c2goXG4gICAgICAnXFx0JyArXG4gICAgICAnfScpO1xuICByZXR1cm4gY29kZUxpbmVzLmpvaW4oJ1xcbicpO1xufTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZVNjYWxlciByZXF1aXJlcyAxIGlucHV0LicpO1xuICB9XG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgc2hhcGUuJyk7XG4gIH1cbiAgaWYgKGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQzMicgJiYgaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDY0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlLicpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0dyYXBofSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQge09wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb259IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7Z2V0R2xzbH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFByb2dyYW1JbmZvTG9hZGVyLCBQcm9ncmFtTWV0YWRhdGEsIFRleHR1cmVUeXBlfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBpbnN0YW5jZU5vcm1hbGl6YXRpb246IE9wZXJhdG9ySW1wbGVtZW50YXRpb248bnVtYmVyPiA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgZXBzaWxvbjogbnVtYmVyKTogVGVuc29yW10gPT4ge1xuICAgICAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcblxuICAgICAgY29uc3QgbWVhbkFuZFZhcmlhbmNlID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oY3JlYXRlTWVhbkFuZFZhcmlhbmNlUHJvZ3JhbUluZm9Mb2FkZXIoaW5wdXRzWzBdKSwgaW5wdXRzKTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgICAgICAgIGNyZWF0ZUNvbXB1dGVPdXRwdXRQcm9ncmFtSW5mb0xvYWRlcihpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHNbMF0sIGVwc2lsb24sIG1lYW5BbmRWYXJpYW5jZS5kaW1zKSxcbiAgICAgICAgICBbaW5wdXRzWzBdLCBtZWFuQW5kVmFyaWFuY2UsIGlucHV0c1sxXSwgaW5wdXRzWzJdXSk7XG4gICAgICByZXR1cm4gW291dHB1dF07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlSW5zdGFuY2VOb3JtYWxpemF0aW9uQXR0cmlidXRlczogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxudW1iZXI+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBudW1iZXIgPT5cbiAgICBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ2Vwc2lsb24nLCAxZS01KTtcblxuY29uc3QgbWVhbkFuZFZhcmlhbmNlUHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAnSW5zdGFuY2VOb3JtYWxpemF0aW9uX01lYW5BbmRWYXJpYW5jZScsXG4gIGlucHV0TmFtZXM6IFsnWCddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxufTtcblxuY29uc3QgY3JlYXRlTWVhbkFuZFZhcmlhbmNlUHJvZ3JhbUluZm8gPSAobWV0YWRhdGE6IFByb2dyYW1NZXRhZGF0YSwgaW5wdXQ6IFRlbnNvcik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgeERpbXMgPSBpbnB1dC5kaW1zLnNsaWNlKCk7XG4gIGNvbnN0IGNoYW5uZWwgPSB4RGltc1sxXTtcbiAgY29uc3QgY2hhbm5lbFNpemUgPSB4RGltc1syXSAqIHhEaW1zWzNdO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IFt4RGltc1swXSwgY2hhbm5lbF07XG5cbiAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgdmVjNCBwcm9jZXNzKGludFsyXSBpbmRpY2VzKSB7XG4gICAgICAgIHZlYzQgdiA9IHZlYzQoMC4wKTtcbiAgICAgICAgaW50IGFbNF07XG4gICAgICAgIGFbMF0gPSBpbmRpY2VzWzBdO1xuICAgICAgICBhWzFdID0gaW5kaWNlc1sxXTtcbiAgICAgICAgZmxvYXQgdGVtcCA9IDAuMDtcbiAgICAgICAgZm9yKGludCBhMj0wOyBhMjwke3hEaW1zWzJdfTsgYTIrKykge1xuICAgICAgICAgIGFbMl0gPSBhMjtcbiAgICAgICAgICBmb3IoaW50IGEzPTA7IGEzPCR7eERpbXNbM119OyBhMysrKSB7XG4gICAgICAgICAgICBhWzNdID0gYTM7XG4gICAgICAgICAgICBmbG9hdCB4ID0gX1goYSk7XG4gICAgICAgICAgICB0ZW1wICs9IHg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZsb2F0IG1lYW4gPSB0ZW1wIC8gZmxvYXQoJHtjaGFubmVsU2l6ZX0pO1xuICAgICAgICB0ZW1wID0gMC4wO1xuICAgICAgICBmb3IoaW50IGEyPTA7IGEyPCR7eERpbXNbMl19OyBhMisrKSB7XG4gICAgICAgICAgYVsyXSA9IGEyO1xuICAgICAgICAgIGZvcihpbnQgYTM9MDsgYTM8JHt4RGltc1szXX07IGEzKyspIHtcbiAgICAgICAgICAgIGFbM10gPSBhMztcbiAgICAgICAgICAgIGZsb2F0IHggPSBfWChhKTtcbiAgICAgICAgICAgIHRlbXAgKz0gKHggLSBtZWFuKSAqICh4IC0gbWVhbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHYuciA9IG1lYW47XG4gICAgICAgIHYuZyA9IHRlbXAgLyBmbG9hdCgke2NoYW5uZWxTaXplfSk7XG5cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9YDtcbiAgcmV0dXJuIHtcbiAgICAuLi5tZXRhZGF0YSxcbiAgICBvdXRwdXQ6IHtkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXQudHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb259LFxuICAgIHNoYWRlclNvdXJjZVxuICB9O1xufTtcblxuY29uc3QgY3JlYXRlTWVhbkFuZFZhcmlhbmNlUHJvZ3JhbUluZm9Mb2FkZXIgPSAoaW5wdXQ6IFRlbnNvcik6IFByb2dyYW1JbmZvTG9hZGVyID0+ICh7XG4gIC4uLm1lYW5BbmRWYXJpYW5jZVByb2dyYW1NZXRhZGF0YSxcbiAgZ2V0OiAoKSA9PiBjcmVhdGVNZWFuQW5kVmFyaWFuY2VQcm9ncmFtSW5mbyhtZWFuQW5kVmFyaWFuY2VQcm9ncmFtTWV0YWRhdGEsIGlucHV0KVxufSk7XG5cbmNvbnN0IGNvbXB1dGVPdXRwdXRQcm9ncmFtTWV0YWRhdGEgPSB7XG4gIG5hbWU6ICdJbnN0YW5jZU5vcm1hbGl6YXRpb25fQ29tcHV0ZU91dHB1dCcsXG4gIGlucHV0TmFtZXM6IFsnWCcsICdNZWFuQW5kVmFyaWFuY2UnLCAnU2NhbGUnLCAnQiddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnBhY2tlZExhc3REaW1lbnNpb24sIFRleHR1cmVUeXBlLnVucGFja2VkLCBUZXh0dXJlVHlwZS51bnBhY2tlZF0sXG59O1xuXG5jb25zdCBjcmVhdGVDb21wdXRlT3V0cHV0UHJvZ3JhbUluZm8gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIG1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsIGlucHV0OiBUZW5zb3IsIGVwc2lsb246IG51bWJlcixcbiAgICAgbWVhbkFuZFZhcmlhbmNlU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgICAgY29uc3QgW3RleHR1cmVXaWR0aCwgdGV4dHVyZUhlaWdodF0gPVxuICAgICAgICAgIGluZmVyZW5jZUhhbmRsZXIuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KG1lYW5BbmRWYXJpYW5jZVNoYXBlLCBUZXh0dXJlVHlwZS5wYWNrZWRMYXN0RGltZW5zaW9uKTtcbiAgICAgIGNvbnN0IFttZWFuQW5kVmFyaWFuY2VXaWR0aCwgbWVhbkFuZFZhcmlhbmNlSGVpZ2h0XSA9IFt0ZXh0dXJlV2lkdGggLyA0LCB0ZXh0dXJlSGVpZ2h0XTtcbiAgICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIHZlYzQgZ2V0X01lYW5BbmRWYXJpYW5jZShpbnRbMl0gbXYpIHtcbiAgICAgICAgaW50IG9mZnNldCA9IGluZGljZXNUb09mZnNldF9NZWFuQW5kVmFyaWFuY2UobXYpO1xuICAgICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKG9mZnNldCwgJHttZWFuQW5kVmFyaWFuY2VXaWR0aH0sICR7bWVhbkFuZFZhcmlhbmNlSGVpZ2h0fSk7XG4gICAgICAgIHJldHVybiAke2dsc2wudGV4dHVyZTJEfShNZWFuQW5kVmFyaWFuY2UsIGNvb3Jkcyk7XG4gICAgICB9XG5cbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50WzRdIGluZGljZXMpIHtcbiAgICAgICAgaW50IG12WzJdO1xuICAgICAgICBtdlswXSA9IGluZGljZXNbMF07XG4gICAgICAgIG12WzFdID0gaW5kaWNlc1sxXTtcbiAgICAgICAgdmVjNCBtZWFuX2FuZF92YXJpYW5jZSA9IGdldF9NZWFuQW5kVmFyaWFuY2UobXYpO1xuICAgICAgICBmbG9hdCBtZWFuID0gbWVhbl9hbmRfdmFyaWFuY2UucjtcbiAgICAgICAgZmxvYXQgdmFyaWFuY2UgPSBtZWFuX2FuZF92YXJpYW5jZS5nO1xuXG4gICAgICAgIGludCBzYlsxXTtcbiAgICAgICAgc2JbMF0gPSBpbmRpY2VzWzFdO1xuICAgICAgICBmbG9hdCBzY2FsZSA9IF9TY2FsZShzYik7XG4gICAgICAgIGZsb2F0IGIgPSBfQihzYik7XG5cbiAgICAgICAgcmV0dXJuIHNjYWxlICogKF9YKGluZGljZXMpIC0gbWVhbikgLyBzcXJ0KHZhcmlhbmNlICsgZXBzaWxvbikgKyBiO1xuICAgICAgfWA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgb3V0cHV0OiB7ZGltczogaW5wdXQuZGltcywgdHlwZTogaW5wdXQudHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnVucGFja2VkfSxcbiAgICAgICAgdmFyaWFibGVzOiBbe25hbWU6ICdlcHNpbG9uJywgdHlwZTogJ2Zsb2F0JywgZGF0YTogZXBzaWxvbn1dLFxuICAgICAgICBzaGFkZXJTb3VyY2VcbiAgICAgIH07XG4gICAgfTtcblxuY29uc3QgY3JlYXRlQ29tcHV0ZU91dHB1dFByb2dyYW1JbmZvTG9hZGVyID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dDogVGVuc29yLCBlcHNpbG9uOiBudW1iZXIsIG1lYW5BbmRWYXJpYW5jZVNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6XG4gICAgICAgIFByb2dyYW1JbmZvTG9hZGVyID0+IHtcbiAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHsuLi5jb21wdXRlT3V0cHV0UHJvZ3JhbU1ldGFkYXRhLCBjYWNoZUhpbnQ6IGAke2Vwc2lsb259YH07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiBjcmVhdGVDb21wdXRlT3V0cHV0UHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlciwgbWV0YWRhdGEsIGlucHV0LCBlcHNpbG9uLCBtZWFuQW5kVmFyaWFuY2VTaGFwZSlcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc3RhbmNlTm9ybWFsaXphdGlvbiByZXF1aXJlcyAzIGlucHV0cy4nKTtcbiAgfVxuXG4gIGNvbnN0IFggPSBpbnB1dHNbMF07XG4gIGNvbnN0IHNjYWxlID0gaW5wdXRzWzFdO1xuICBjb25zdCBCID0gaW5wdXRzWzJdO1xuXG4gIC8vIGlucHV0IHNob3VsZCBhdCBsZWFzdCBoYXZlIHRocmVlIGRpbWVuc2lvbnMgLSBOLEMsZGltMSwuLi4sZGltblxuICAvLyBvdGhlciBpbnB1dHMgY2FuIGhhdmUgb25seSBvbmUgZGltZW5zaW9uc1xuICBpZiAoWC5kaW1zLmxlbmd0aCA8IDMgfHwgc2NhbGUuZGltcy5sZW5ndGggIT09IDEgfHwgQi5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCBzaGFwZS4nKTtcbiAgfVxuICBpZiAoc2NhbGUuZGltc1swXSAhPT0gWC5kaW1zWzFdIHx8IEIuZGltc1swXSAhPT0gWC5kaW1zWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBzaGFwZXMgYXJlIG1pc21hdGNoZWQuJyk7XG4gIH1cbiAgaWYgKChYLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBYLnR5cGUgIT09ICdmbG9hdDY0JykgfHwgKHNjYWxlLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBzY2FsZS50eXBlICE9PSAnZmxvYXQ2NCcpIHx8XG4gICAgICAoQi50eXBlICE9PSAnZmxvYXQzMicgJiYgQi50eXBlICE9PSAnZmxvYXQ2NCcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUuJyk7XG4gIH1cbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgIHRocm93IG5ldyBFcnJvcignT25seSBzdXBwb3J0IDQtRCBpbnB1dCBzaGFwZS4nKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7R3JhcGh9IGZyb20gJy4uLy4uLy4uL2dyYXBoJztcbmltcG9ydCB7T3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbn0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFByb2dyYW1JbmZvTG9hZGVyLCBUZXh0dXJlVHlwZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIExybkF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBhbHBoYTogbnVtYmVyO1xuICBiZXRhOiBudW1iZXI7XG4gIGJpYXM6IG51bWJlcjtcbiAgc2l6ZTogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgbHJuOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPExybkF0dHJpYnV0ZXM+ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBMcm5BdHRyaWJ1dGVzKTogVGVuc29yW10gPT4ge1xuICAgICAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcblxuICAgICAgLy8gaWYgKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5wYWNrKSB7XG4gICAgICAvLyAgIHJldHVybiBbaW5mZXJlbmNlSGFuZGxlci5ydW4oY3JlYXRlUGFja2VkTHJuUHJvZ3JhbUluZm9Mb2FkZXIoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhdHRyaWJ1dGVzKSxcbiAgICAgIC8vICAgaW5wdXRzKV07XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtpbmZlcmVuY2VIYW5kbGVyLnJ1bihjcmVhdGVMcm5Qcm9ncmFtSW5mb0xvYWRlcihpbnB1dHMsIGF0dHJpYnV0ZXMpLCBpbnB1dHMpXTtcbiAgICAgIC8vfVxuICAgIH07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUxybkF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248THJuQXR0cmlidXRlcz4gPSAobm9kZTogR3JhcGguTm9kZSk6IExybkF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBhbHBoYSA9IG5vZGUuYXR0cmlidXRlcy5nZXRGbG9hdCgnYWxwaGEnLCAwLjAwMDEpO1xuICBjb25zdCBiZXRhID0gbm9kZS5hdHRyaWJ1dGVzLmdldEZsb2F0KCdiZXRhJywgMC43NSk7XG4gIGNvbnN0IGJpYXMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ2JpYXMnLCAxLjApO1xuICBjb25zdCBzaXplID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludCgnc2l6ZScpO1xuXG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe2FscGhhLCBiZXRhLCBiaWFzLCBzaXplfSk7XG59O1xuXG5jb25zdCBscm5Qcm9ncmFtTWV0YWRhdGEgPSB7XG4gIG5hbWU6ICdMUk4nLFxuICBpbnB1dE5hbWVzOiBbJ1gnXSxcbiAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXVxufTtcblxuZnVuY3Rpb24gY3JlYXRlTHJuUHJvZ3JhbUluZm8oaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogTHJuQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvIHtcbiAgY29uc3QgQyA9IGlucHV0c1swXS5kaW1zWzFdO1xuICBjb25zdCByYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuICBjb25zdCBmcm9tID0gLU1hdGguZmxvb3IoKGF0dHJpYnV0ZXMuc2l6ZSAtIDEpIC8gMik7XG4gIGNvbnN0IHRvID0gTWF0aC5jZWlsKChhdHRyaWJ1dGVzLnNpemUgLSAxKSAvIDIpO1xuICBjb25zdCBhbHBoYSA9IGBmbG9hdCgke2F0dHJpYnV0ZXMuYWxwaGF9KSAvIGZsb2F0KCR7YXR0cmlidXRlcy5zaXplfSlgO1xuICBjb25zdCBiaWFzID0gYGZsb2F0KCR7YXR0cmlidXRlcy5iaWFzfSlgO1xuICBjb25zdCBiZXRhID0gYGZsb2F0KCR7YXR0cmlidXRlcy5iZXRhfSlgO1xuXG4gIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgIGludCBjID0gaW5kaWNlc1sxXTtcbiAgICAgICAgZmxvYXQgeCA9IF9YKGluZGljZXMpO1xuICAgICAgICBmbG9hdCBzcXVhcmVfc3VtID0gMC4wO1xuXG4gICAgICAgIGZvciAoaW50IGkgPSAke2Zyb219OyBpIDw9ICR7dG99OyBpKyspIHtcbiAgICAgICAgICBpbnQgaWR4ID0gYyArIGk7XG4gICAgICAgICAgaWYgKGMgPj0gMCAmJiBjIDwgJHtDfSkge1xuICAgICAgICAgICAgaW5kaWNlc1sxXSA9IGlkeDtcbiAgICAgICAgICAgIGZsb2F0IGogPSBfWChpbmRpY2VzKTtcbiAgICAgICAgICAgIHNxdWFyZV9zdW0gKz0gaiAqIGo7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IC8gcG93KCR7Ymlhc30gKyAke2FscGhhfSAqIHNxdWFyZV9zdW0sICR7YmV0YX0pO1xuICAgIH1gO1xuICByZXR1cm4ge1xuICAgIC4uLmxyblByb2dyYW1NZXRhZGF0YSxcbiAgICBjYWNoZUhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gICAgb3V0cHV0OiB7ZGltczogaW5wdXRzWzBdLmRpbXMsIHR5cGU6IGlucHV0c1swXS50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWR9LFxuICAgIHNoYWRlclNvdXJjZSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxyblByb2dyYW1JbmZvTG9hZGVyKGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IExybkF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mb0xvYWRlciB7XG4gIHJldHVybiB7Li4ubHJuUHJvZ3JhbU1ldGFkYXRhLCBjYWNoZUhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksIGdldDogKCkgPT4gY3JlYXRlTHJuUHJvZ3JhbUluZm8oaW5wdXRzLCBhdHRyaWJ1dGVzKX07XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTFJOIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY3VycmVudGx5IG9ubHkgc3VwcG9ydCBMUk4gZm9yIGlucHV0IHdpdGggXCJOQ0hXXCIgZm9ybWF0Jyk7XG4gIH1cbiAgaWYgKGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQzMicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHNob3VsZCBiZSBmbG9hdCB0eXBlJyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uLy4uLy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0dyYXBofSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQge09wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb259IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7Z2V0R2xzbCwgR2xzbH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFRleHR1cmVUeXBlfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFkQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IG1vZGU6IHN0cmluZztcbiAgcmVhZG9ubHkgcGFkczogbnVtYmVyW107XG4gIHJlYWRvbmx5IHZhbHVlOiBudW1iZXI7XG59XG5cbmNvbnN0IHBhZFByb2dyYW1NZXRhZGF0YSA9IHtcbiAgbmFtZTogJ1BhZCcsXG4gIGlucHV0TmFtZXM6IFsnQSddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxufTtcblxuZXhwb3J0IGNvbnN0IHBhZFYyOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPFBhZEF0dHJpYnV0ZXM+ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBQYWRBdHRyaWJ1dGVzKTogVGVuc29yW10gPT4ge1xuICAgICAgdmFsaWRhdGVJbnB1dHNWMihpbnB1dHMpO1xuICAgICAgY29uc3Qgb3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4ucGFkUHJvZ3JhbU1ldGFkYXRhLFxuICAgICAgICAgICAgY2FjaGVIaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiBjcmVhdGVQYWRQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHNbMF0sIGF0dHJpYnV0ZXMpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnB1dHMpO1xuICAgICAgcmV0dXJuIFtvdXRwdXRdO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVBhZEF0dHJpYnV0ZXNWMjogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxQYWRBdHRyaWJ1dGVzPiA9IChub2RlOiBHcmFwaC5Ob2RlKTogUGFkQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IG1vZGUgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKCdtb2RlJywgJ2NvbnN0YW50Jyk7XG4gIGNvbnN0IHZhbHVlID0gbm9kZS5hdHRyaWJ1dGVzLmdldEZsb2F0KCd2YWx1ZScsIDAuMCk7XG4gIGNvbnN0IHBhZHMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygncGFkcycpO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHttb2RlLCB2YWx1ZSwgcGFkc30pO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhZFYxMTogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxzdHJpbmc+ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBtb2RlOiBzdHJpbmcpOiBUZW5zb3JbXSA9PiB7XG4gICAgICB2YWxpZGF0ZUlucHV0c1YxMShpbnB1dHMpO1xuICAgICAgY29uc3QgYXR0cnVidXRlcyA9IGdlbmVyYXRlUGFkQXR0cmlidXRlc0Zyb21JbnB1dHMoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBtb2RlKTtcbiAgICAgIHJldHVybiBwYWRWMihpbmZlcmVuY2VIYW5kbGVyLCBbaW5wdXRzWzBdXSwgYXR0cnVidXRlcyk7XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlUGFkQXR0cmlidXRlc1YxMTogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxzdHJpbmc+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBzdHJpbmcgPT5cbiAgICBub2RlLmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKCdtb2RlJywgJ2NvbnN0YW50Jyk7XG5cbmNvbnN0IGdlbmVyYXRlUGFkQXR0cmlidXRlc0Zyb21JbnB1dHMgPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIG1vZGU6IHN0cmluZyk6IFBhZEF0dHJpYnV0ZXMgPT4ge1xuICAgICAgaWYgKCFpbmZlcmVuY2VIYW5kbGVyLnNlc3Npb24uaXNJbml0aWFsaXplcihpbnB1dHNbMV0uZGF0YUlkKSB8fFxuICAgICAgICAgIChpbnB1dHMubGVuZ3RoID49IDMgJiYgIWluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGlucHV0c1syXS5kYXRhSWQpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2R5bmFtaWMgcGFkIGF0dHJpYnV0ZXMgYXJlIG5vdCBhbGxvd2VkJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhZHMgPSBBcnJheS5mcm9tKGlucHV0c1sxXS5pbnRlZ2VyRGF0YSk7XG4gICAgICBjb25zdCB2YWx1ZSA9IChpbnB1dHMubGVuZ3RoID49IDMpID8gaW5wdXRzWzJdLmZsb2F0RGF0YVswXSA6IDAuMDtcblxuICAgICAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7bW9kZSwgcGFkcywgdmFsdWV9KTtcbiAgICB9O1xuXG5jb25zdCBjcmVhdGVQYWRQcm9ncmFtSW5mbyA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXQ6IFRlbnNvciwgYXR0cmlidXRlczogUGFkQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gU2hhcGVVdGlsLnBhZFNoYXBlKGlucHV0LmRpbXMuc2xpY2UoKSwgYXR0cmlidXRlcy5wYWRzKTtcbiAgICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gICAgICBjb25zdCBwYWRGdW5jdGlvbiA9IGdldFBhZEZ1bmN0aW9uKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0LCBhdHRyaWJ1dGVzKTtcbiAgICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICR7cGFkRnVuY3Rpb259XG4gICAgICBmbG9hdCBwcm9jZXNzKGludFske3Jhbmt9XSBpbmRpY2VzKSB7XG4gICAgICAgICAgcmV0dXJuIHBhZEEoaW5kaWNlcyk7XG4gICAgICB9YDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdQYWQnLFxuICAgICAgICBpbnB1dE5hbWVzOiBbJ0EnXSxcbiAgICAgICAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbiAgICAgICAgb3V0cHV0OiB7ZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0LnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgICAgIHNoYWRlclNvdXJjZVxuICAgICAgfTtcbiAgICB9O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0c1YyID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFkIHJlcXVpcmVzIDEgaW5wdXQnKTtcbiAgfVxuICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0NjQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUuJyk7XG4gIH1cbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzVjExID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgKGlucHV0cy5sZW5ndGggIT09IDIgJiYgaW5wdXRzLmxlbmd0aCAhPT0gMykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhZCByZXF1aXJlcyAyIG9yIDMgaW5wdXRzJyk7XG4gIH1cbiAgaWYgKGlucHV0c1sxXS50eXBlICE9PSAnaW50MzInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUuJyk7XG4gIH1cbiAgaWYgKGlucHV0cy5sZW5ndGggPj0gMyAmJiBpbnB1dHNbMl0udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxufTtcblxuY29uc3QgZ2V0UGFkRnVuY3Rpb24gPSAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dDogVGVuc29yLCBhdHRyaWJ1dGVzOiBQYWRBdHRyaWJ1dGVzKTogc3RyaW5nID0+IHtcbiAgY29uc3QgZ2xzbCA9IGdldEdsc2woaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSBpbmZlcmVuY2VIYW5kbGVyLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChpbnB1dC5kaW1zLCBUZXh0dXJlVHlwZS51bnBhY2tlZCk7XG4gIGNvbnN0IHN0cmlkZXMgPSBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoaW5wdXQuZGltcyk7XG5cbiAgc3dpdGNoIChhdHRyaWJ1dGVzLm1vZGUpIHtcbiAgICBjYXNlICdjb25zdGFudCc6XG4gICAgICByZXR1cm4gZ2V0UGFkQ29uc3RhbnQoZ2xzbCwgaW5wdXQuZGltcywgc3RyaWRlcywgd2lkdGgsIGhlaWdodCwgYXR0cmlidXRlcy5wYWRzLCBhdHRyaWJ1dGVzLnZhbHVlKTtcbiAgICBjYXNlICdyZWZsZWN0JzpcbiAgICAgIHJldHVybiBnZXRQYWRSZWZsZWN0KGdsc2wsIGlucHV0LmRpbXMsIHN0cmlkZXMsIHdpZHRoLCBoZWlnaHQsIGF0dHJpYnV0ZXMucGFkcyk7XG4gICAgY2FzZSAnZWRnZSc6XG4gICAgICByZXR1cm4gZ2V0UGFkRWRnZShnbHNsLCBpbnB1dC5kaW1zLCBzdHJpZGVzLCB3aWR0aCwgaGVpZ2h0LCBhdHRyaWJ1dGVzLnBhZHMpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbW9kZScpO1xuICB9XG59O1xuXG5jb25zdCBnZXRQYWRDb25zdGFudCA9XG4gICAgKGdsc2w6IEdsc2wsIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10sIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBwYWRzOiBudW1iZXJbXSxcbiAgICAgdmFsdWU6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gICAgICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgICAgbGV0IGJsb2NrID0gJyc7XG4gICAgICBmb3IgKGxldCBpID0gcmFuayAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGJsb2NrICs9IGBcbiAgICAgICAgayA9IG1bJHtpfV0gLSAke3BhZHNbaV19O1xuICAgICAgICBpZiAoayA8IDApICByZXR1cm4gY29uc3RhbnQ7XG4gICAgICAgIGlmIChrID49ICR7c2hhcGVbaV19KSByZXR1cm4gY29uc3RhbnQ7XG4gICAgICAgIG9mZnNldCArPSBrICogJHtzdHJpZGVzW2ldfTtcbiAgICAgICAgYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgXG4gICAgICBmbG9hdCBwYWRBKGludCBtWyR7cmFua31dKSB7XG4gICAgICAgIGNvbnN0IGZsb2F0IGNvbnN0YW50ID0gZmxvYXQoJHt2YWx1ZX0pO1xuICAgICAgICBpbnQgb2Zmc2V0ID0gMDtcbiAgICAgICAgaW50IGsgPSAwO1xuICAgICAgICAke2Jsb2NrfVxuICAgICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKG9mZnNldCwgJHt3aWR0aH0sICR7aGVpZ2h0fSk7XG4gICAgICAgIGZsb2F0IHZhbHVlID0gZ2V0Q29sb3JBc0Zsb2F0KCR7Z2xzbC50ZXh0dXJlMkR9KEEsIGNvb3JkcykpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBgO1xuICAgIH07XG5cbmNvbnN0IGdldFBhZFJlZmxlY3QgPVxuICAgIChnbHNsOiBHbHNsLCBzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgcGFkczogbnVtYmVyW10pOlxuICAgICAgICBzdHJpbmcgPT4ge1xuICAgICAgICAgIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG5cbiAgICAgICAgICBsZXQgYmxvY2sgPSAnJztcbiAgICAgICAgICBmb3IgKGxldCBpID0gcmFuayAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBibG9jayArPSBgXG4gICAgICAgIGsgPSBtWyR7aX1dIC0gJHtwYWRzW2ldfTtcbiAgICAgICAgaWYgKGsgPCAwKSB7IGsgPSAtazsgfVxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgaW50IF8ybl8xID0gJHsyICogKHNoYXBlW2ldIC0gMSl9O1xuICAgICAgICAgIGsgPSBpbnQoIG1vZCggZmxvYXQoayksIGZsb2F0KF8ybl8xKSApICkgO1xuICAgICAgICAgIGlmKGsgPj0gJHtzaGFwZVtpXX0pIHsgayA9IF8ybl8xIC0gazsgfVxuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSBrICogJHtzdHJpZGVzW2ldfTtcbiAgICAgICAgYDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGBcbiAgICAgIGZsb2F0IHBhZEEoaW50IG1bJHtyYW5rfV0pIHtcbiAgICAgICAgaW50IG9mZnNldCA9IDA7XG4gICAgICAgIGludCBrID0gMDtcbiAgICAgICAgJHtibG9ja31cbiAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7d2lkdGh9LCAke2hlaWdodH0pO1xuICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfShBLCBjb29yZHMpKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgYDtcbiAgICAgICAgfTtcblxuY29uc3QgZ2V0UGFkRWRnZSA9XG4gICAgKGdsc2w6IEdsc2wsIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10sIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBwYWRzOiBudW1iZXJbXSk6XG4gICAgICAgIHN0cmluZyA9PiB7XG4gICAgICAgICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcblxuICAgICAgICAgIGxldCBibG9jayA9ICcnO1xuICAgICAgICAgIGZvciAobGV0IGkgPSByYW5rIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGJsb2NrICs9IGBcbiAgICAgICAgayA9IG1bJHtpfV0gLSAke3BhZHNbaV19O1xuICAgICAgICBpZiAoayA8IDApICBrID0gMDtcbiAgICAgICAgaWYgKGsgPj0gJHtzaGFwZVtpXX0pIGsgPSAke3NoYXBlW2ldIC0gMX07XG4gICAgICAgIG9mZnNldCArPSBrICogJHtzdHJpZGVzW2ldfTtcbiAgICAgIGA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBgXG4gICAgICBmbG9hdCBwYWRBKGludCBtWyR7cmFua31dKSB7XG4gICAgICAgIGludCBvZmZzZXQgPSAwO1xuICAgICAgICBpbnQgayA9IDA7XG4gICAgICAgICR7YmxvY2t9XG4gICAgICAgIHZlYzIgY29vcmRzID0gb2Zmc2V0VG9Db29yZHMob2Zmc2V0LCAke3dpZHRofSwgJHtoZWlnaHR9KTtcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRDb2xvckFzRmxvYXQoJHtnbHNsLnRleHR1cmUyRH0oQSwgY29vcmRzKSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGA7XG4gICAgICAgIH07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uLy4uLy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0dyYXBofSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQge09wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb259IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7UG9vbENvbnZVdGlsLCBTaGFwZVV0aWx9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFByb2dyYW1NZXRhZGF0YSwgVGV4dHVyZVR5cGV9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBhdXRvUGFkOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGNlaWxNb2RlOiBudW1iZXI7XG4gIHJlYWRvbmx5IGNvdW50SW5jbHVkZVBhZDogYm9vbGVhbjtcbiAgcmVhZG9ubHkga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXTtcbiAgcmVhZG9ubHkgcGFkczogcmVhZG9ubHkgbnVtYmVyW107XG59XG5cbmV4cG9ydCBjb25zdCBhdmVyYWdlUG9vbDogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxBdmVyYWdlUG9vbEF0dHJpYnV0ZXM+ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiB7XG4gICAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICAgICAgY29uc3QgbWV0YWRhdGEgPVxuICAgICAgICAgIHtuYW1lOiAnQXZlcmFnZVBvb2wnLCBpbnB1dE5hbWVzOiBbJ1gnXSwgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSwgY2FjaGVIaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5fTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgICAgICAgIHsuLi5tZXRhZGF0YSwgZ2V0OiAoKSA9PiBjcmVhdGVBdmVyYWdlUG9vbFByb2dyYW1JbmZvKGlucHV0cywgbWV0YWRhdGEsIGZhbHNlLCBhdHRyaWJ1dGVzKX0sIGlucHV0cyk7XG4gICAgICByZXR1cm4gW291dHB1dF07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPEF2ZXJhZ2VQb29sQXR0cmlidXRlcz4gPVxuICAgIChub2RlOiBHcmFwaC5Ob2RlKTogQXZlcmFnZVBvb2xBdHRyaWJ1dGVzID0+IHtcbiAgICAgIGNvbnN0IGF1dG9QYWQgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKCdhdXRvX3BhZCcsICdOT1RTRVQnKTtcbiAgICAgIGNvbnN0IGNlaWxNb2RlID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludCgnY2VpbF9tb2RlJywgMCk7XG4gICAgICBjb25zdCBjb3VudEluY2x1ZGVQYWQgPSAobm9kZS5hdHRyaWJ1dGVzLmdldEludCgnY291bnRfaW5jbHVkZV9wYWQnLCAwKSA9PT0gMCA/IGZhbHNlIDogdHJ1ZSk7XG4gICAgICBjb25zdCBrZXJuZWxTaGFwZSA9IG5vZGUuYXR0cmlidXRlcy5nZXRJbnRzKCdrZXJuZWxfc2hhcGUnKTtcbiAgICAgIGNvbnN0IHN0cmlkZXMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygnc3RyaWRlcycsIFtdKTtcbiAgICAgIGNvbnN0IHBhZHMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygncGFkcycsIFtdKTtcblxuICAgICAgLy8gVE9ETzogc3VwcG9ydCBhdHRyaWJ1dGUgJ2NlaWxfbW9kZSdcbiAgICAgIGlmIChjZWlsTW9kZSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgQXZlcmFnZVBvb2wnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7YXV0b1BhZCwgY2VpbE1vZGUsIGNvdW50SW5jbHVkZVBhZCwga2VybmVsU2hhcGUsIHN0cmlkZXMsIHBhZHN9KTtcbiAgICB9O1xuXG5jb25zdCBjcmVhdGVBdmVyYWdlUG9vbFByb2dyYW1JbmZvID1cbiAgICAoaW5wdXRzOiBUZW5zb3JbXSwgbWV0YWRhdGE6IFByb2dyYW1NZXRhZGF0YSwgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbiwgYXR0cmlidXRlczogQXZlcmFnZVBvb2xBdHRyaWJ1dGVzKTpcbiAgICAgICAgUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgICAgIGNvbnN0IFthZGp1c3RlZEF0dHJpYnV0ZXMsIG91dHB1dFNoYXBlXSA9XG4gICAgICAgICAgICAgIGdldEFkanVzdGVkUG9vbEF0dHJpYnV0ZXNBbmRPdXRwdXRTaGFwZShpbnB1dHMsIGF0dHJpYnV0ZXMsIGlzR2xvYmFsT3BlcmF0b3IpO1xuICAgICAgICAgIGNvbnN0IGtlcm5lbFNpemUgPSBTaGFwZVV0aWwuc2l6ZShhZGp1c3RlZEF0dHJpYnV0ZXMua2VybmVsU2hhcGUpO1xuICAgICAgICAgIGNvbnN0IG9wMSA9ICd2YWx1ZSArPSBfWCh4KTsnO1xuICAgICAgICAgIGxldCBvcDIgPSAnJztcbiAgICAgICAgICBpZiAoYWRqdXN0ZWRBdHRyaWJ1dGVzLmNvdW50SW5jbHVkZVBhZCkge1xuICAgICAgICAgICAgb3AyICs9IGB2YWx1ZSAvPSBmbG9hdCgke2tlcm5lbFNpemV9KTtgO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcDIgKz0gYHZhbHVlIC89IGZsb2F0KCR7a2VybmVsU2l6ZX0gLSBwYWQpO2A7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHBvb2xpbmdDb2RlID0gZ2VuZXJhdGVQb29saW5nQ29kZShpbnB1dHNbMF0uZGltcywgYWRqdXN0ZWRBdHRyaWJ1dGVzLCBvcDEsIG9wMiwgJzAuMCcpO1xuICAgICAgICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgICAgJHtwb29saW5nQ29kZX1cbiAgICAgIGA7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICAgICAgb3V0cHV0OiB7ZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0c1swXS50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWR9LFxuICAgICAgICAgICAgc2hhZGVyU291cmNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuZXhwb3J0IGNvbnN0IGdsb2JhbEF2ZXJhZ2VQb29sOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPEF2ZXJhZ2VQb29sQXR0cmlidXRlcz4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IEF2ZXJhZ2VQb29sQXR0cmlidXRlcyk6IFRlbnNvcltdID0+IHtcbiAgICAgIHZhbGlkYXRlSW5wdXRzKGlucHV0cyk7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICAgICAgbmFtZTogJ0dsb2JhbEF2ZXJhZ2VQb29sJyxcbiAgICAgICAgaW5wdXROYW1lczogWydYJ10sXG4gICAgICAgIGlucHV0VHlwZXM6IFtUZXh0dXJlVHlwZS51bnBhY2tlZF0sXG4gICAgICAgIGNhY2hlSGludDogYCR7YXR0cmlidXRlcy5jb3VudEluY2x1ZGVQYWR9YFxuICAgICAgfTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgICAgICAgIHsuLi5tZXRhZGF0YSwgZ2V0OiAoKSA9PiBjcmVhdGVBdmVyYWdlUG9vbFByb2dyYW1JbmZvKGlucHV0cywgbWV0YWRhdGEsIHRydWUsIGF0dHJpYnV0ZXMpfSwgaW5wdXRzKTtcbiAgICAgIHJldHVybiBbb3V0cHV0XTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgcGFyc2VHbG9iYWxBdmVyYWdlUG9vbEF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248QXZlcmFnZVBvb2xBdHRyaWJ1dGVzPiA9XG4gICAgKG5vZGU6IEdyYXBoLk5vZGUpOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgPT4ge1xuICAgICAgY29uc3QgY291bnRJbmNsdWRlUGFkID0gKG5vZGUuYXR0cmlidXRlcy5nZXRJbnQoJ2NvdW50X2luY2x1ZGVfcGFkJywgMCkgPT09IDAgPyBmYWxzZSA6IHRydWUpO1xuICAgICAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShcbiAgICAgICAgICB7YXV0b1BhZDogJycsIGNlaWxNb2RlOiAwLCBjb3VudEluY2x1ZGVQYWQsIGtlcm5lbFNoYXBlOiBbXSwgc3RyaWRlczogW10sIHBhZHM6IFtdfSk7XG4gICAgfTtcblxuZXhwb3J0IGludGVyZmFjZSBNYXhQb29sQXR0cmlidXRlcyBleHRlbmRzIEF2ZXJhZ2VQb29sQXR0cmlidXRlcyB7XG4gIHJlYWRvbmx5IHN0b3JhZ2VPcmRlcjogbnVtYmVyO1xuICByZWFkb25seSBkaWxhdGlvbnM6IG51bWJlcltdO1xufVxuXG5leHBvcnQgY29uc3QgbWF4UG9vbDogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxNYXhQb29sQXR0cmlidXRlcz4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IE1heFBvb2xBdHRyaWJ1dGVzKTogVGVuc29yW10gPT4ge1xuICAgICAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID1cbiAgICAgICAgICB7bmFtZTogJ01heFBvb2wnLCBpbnB1dE5hbWVzOiBbJ1gnXSwgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSwgY2FjaGVIaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5fTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucnVuKFxuICAgICAgICAgIHsuLi5tZXRhZGF0YSwgZ2V0OiAoKSA9PiBjcmVhdGVNYXhQb29sUHJvZ3JhbUluZm8oaW5wdXRzLCBtZXRhZGF0YSwgZmFsc2UsIGF0dHJpYnV0ZXMpfSwgaW5wdXRzKTtcbiAgICAgIHJldHVybiBbb3V0cHV0XTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgcGFyc2VNYXhQb29sQXR0cmlidXRlczogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxNYXhQb29sQXR0cmlidXRlcz4gPVxuICAgIChub2RlOiBHcmFwaC5Ob2RlKTogTWF4UG9vbEF0dHJpYnV0ZXMgPT4ge1xuICAgICAgY29uc3QgYXV0b1BhZCA9IG5vZGUuYXR0cmlidXRlcy5nZXRTdHJpbmcoJ2F1dG9fcGFkJywgJ05PVFNFVCcpO1xuICAgICAgY29uc3QgY2VpbE1vZGUgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCdjZWlsX21vZGUnLCAwKTtcbiAgICAgIGNvbnN0IGtlcm5lbFNoYXBlID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludHMoJ2tlcm5lbF9zaGFwZScpO1xuICAgICAgY29uc3Qgc3RyaWRlcyA9IG5vZGUuYXR0cmlidXRlcy5nZXRJbnRzKCdzdHJpZGVzJywgW10pO1xuICAgICAgY29uc3QgcGFkcyA9IG5vZGUuYXR0cmlidXRlcy5nZXRJbnRzKCdwYWRzJywgW10pO1xuICAgICAgY29uc3Qgc3RvcmFnZU9yZGVyID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludCgnc3RvcmFnZV9vcmRlcicsIDApO1xuICAgICAgY29uc3QgZGlsYXRpb25zID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludHMoJ2RpbGF0aW9ucycsIFtdKTtcblxuICAgICAgLy8gVE9ETzogc3VwcG9ydCBhdHRyaWJ1dGUgJ2NlaWxfbW9kZScgYW5kICdzdG9yYWdlX29yZGVyJ1xuICAgICAgaWYgKHN0b3JhZ2VPcmRlciAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbHVtbiBtYWpvciBzdG9yYWdlIG9yZGVyIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sJyk7XG4gICAgICB9XG4gICAgICBpZiAoY2VpbE1vZGUgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2wnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShcbiAgICAgICAgICB7YXV0b1BhZCwgY2VpbE1vZGUsIGNvdW50SW5jbHVkZVBhZDogZmFsc2UsIGtlcm5lbFNoYXBlLCBzdHJpZGVzLCBwYWRzLCBzdG9yYWdlT3JkZXIsIGRpbGF0aW9uc30pO1xuICAgIH07XG5cbmNvbnN0IGNyZWF0ZU1heFBvb2xQcm9ncmFtSW5mbyA9XG4gICAgKGlucHV0czogVGVuc29yW10sIG1ldGFkYXRhOiBQcm9ncmFtTWV0YWRhdGEsIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sIGF0dHJpYnV0ZXM6IE1heFBvb2xBdHRyaWJ1dGVzKTpcbiAgICAgICAgUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgICAgIGNvbnN0IFthZGp1c3RlZEF0dHJpYnV0ZXMsIG91dHB1dFNoYXBlXSA9XG4gICAgICAgICAgICAgIGdldEFkanVzdGVkUG9vbEF0dHJpYnV0ZXNBbmRPdXRwdXRTaGFwZShpbnB1dHMsIGF0dHJpYnV0ZXMsIGlzR2xvYmFsT3BlcmF0b3IpO1xuICAgICAgICAgIGNvbnN0IG9wMSA9IGBcbiAgICAgIHZhbHVlID0gbWF4KF9YKHgpLCB2YWx1ZSk7XG4gICAgYDtcbiAgICAgICAgICBjb25zdCBvcDIgPSAnJztcbiAgICAgICAgICBjb25zdCBwb29saW5nQ29kZSA9IGdlbmVyYXRlUG9vbGluZ0NvZGUoaW5wdXRzWzBdLmRpbXMsIGFkanVzdGVkQXR0cmlidXRlcywgb3AxLCBvcDIsICctMWU1Jyk7XG4gICAgICAgICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgJHtwb29saW5nQ29kZX1cbiAgICBgO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgICAgIG91dHB1dDoge2RpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dHNbMF0udHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnVucGFja2VkfSxcbiAgICAgICAgICAgIHNoYWRlclNvdXJjZVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbmNvbnN0IGdldEFkanVzdGVkUG9vbEF0dHJpYnV0ZXNBbmRPdXRwdXRTaGFwZSA9XG4gICAgKGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IEF2ZXJhZ2VQb29sQXR0cmlidXRlc3xNYXhQb29sQXR0cmlidXRlcywgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbik6XG4gICAgICAgIFtBdmVyYWdlUG9vbEF0dHJpYnV0ZXN8TWF4UG9vbEF0dHJpYnV0ZXMsIG51bWJlcltdXSA9PiB7XG4gICAgICAgICAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gICAgICAgICAgY29uc3QgaGFzRGlsYXRpb25zID0gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlcywgJ2RpbGF0aW9ucycpO1xuICAgICAgICAgIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5zbGljZSgpO1xuICAgICAgICAgIGNvbnN0IHN0cmlkZXMgPSBhdHRyaWJ1dGVzLnN0cmlkZXMuc2xpY2UoKTtcbiAgICAgICAgICBjb25zdCBkaWxhdGlvbnM6IG51bWJlcltdID0gaGFzRGlsYXRpb25zID8gKGF0dHJpYnV0ZXMgYXMgTWF4UG9vbEF0dHJpYnV0ZXMpLmRpbGF0aW9ucy5zbGljZSgpIDogW107XG4gICAgICAgICAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMucGFkcy5zbGljZSgpO1xuICAgICAgICAgIFBvb2xDb252VXRpbC5hZGp1c3RQb29sQXR0cmlidXRlcyhpc0dsb2JhbE9wZXJhdG9yLCBpbnB1dFNoYXBlLCBrZXJuZWxTaGFwZSwgc3RyaWRlcywgZGlsYXRpb25zLCBwYWRzKTtcblxuICAgICAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gUG9vbENvbnZVdGlsLmNvbXB1dGVQb29sT3V0cHV0U2hhcGUoXG4gICAgICAgICAgICAgIGlzR2xvYmFsT3BlcmF0b3IsIGlucHV0U2hhcGUsIHN0cmlkZXMsIGRpbGF0aW9ucywga2VybmVsU2hhcGUsIHBhZHMsIGF0dHJpYnV0ZXMuYXV0b1BhZCk7XG5cbiAgICAgICAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlcyk7XG4gICAgICAgICAgaWYgKGhhc0RpbGF0aW9ucykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdBdHRyaWJ1dGVzLCB7a2VybmVsU2hhcGUsIHN0cmlkZXMsIHBhZHMsIGRpbGF0aW9ucywgY2FjaGVLZXk6IGF0dHJpYnV0ZXMuY2FjaGVLZXl9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXdBdHRyaWJ1dGVzLCB7a2VybmVsU2hhcGUsIHN0cmlkZXMsIHBhZHMsIGNhY2hlS2V5OiBhdHRyaWJ1dGVzLmNhY2hlS2V5fSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbbmV3QXR0cmlidXRlcywgb3V0cHV0U2hhcGVdO1xuICAgICAgICB9O1xuXG5jb25zdCBnbG9iYWxNYXhQb29sQXR0cmlidXRlcyA9IHtcbiAgYXV0b1BhZDogJycsXG4gIGNlaWxNb2RlOiAwLFxuICBjb3VudEluY2x1ZGVQYWQ6IGZhbHNlLFxuICBrZXJuZWxTaGFwZTogW10sXG4gIHN0cmlkZXM6IFtdLFxuICBwYWRzOiBbXSxcbiAgc3RvcmFnZU9yZGVyOiAwLFxuICBkaWxhdGlvbnM6IFtdLFxuICBjYWNoZUtleTogJydcbn07XG5cbmNvbnN0IGdsb2JhbE1heFBvb2xNZXRhZGF0YSA9IHtcbiAgbmFtZTogJ0dsb2JhbE1heFBvb2wnLFxuICBpbnB1dE5hbWVzOiBbJ1gnXSxcbiAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXVxufTtcblxuZXhwb3J0IGNvbnN0IGdsb2JhbE1heFBvb2wgPSAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICAgIHtcbiAgICAgICAgLi4uZ2xvYmFsTWF4UG9vbE1ldGFkYXRhLFxuICAgICAgICBnZXQ6ICgpID0+IGNyZWF0ZU1heFBvb2xQcm9ncmFtSW5mbyhpbnB1dHMsIGdsb2JhbE1heFBvb2xNZXRhZGF0YSwgdHJ1ZSwgZ2xvYmFsTWF4UG9vbEF0dHJpYnV0ZXMpXG4gICAgICB9LFxuICAgICAgaW5wdXRzKTtcbiAgcmV0dXJuIFtvdXRwdXRdO1xufTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQb29sIG9wcyByZXF1aXJlcyAxIGlucHV0LicpO1xuICB9XG4gIGlmIChpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0MzInICYmIGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQ2NCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxufTtcblxuY29uc3QgZ2VuZXJhdGVQb29saW5nQ29kZSA9XG4gICAgKGlucHV0RGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF0dHJpYnV0ZXM6IEF2ZXJhZ2VQb29sQXR0cmlidXRlcywgb3AxOiBzdHJpbmcsIG9wMjogc3RyaW5nLCBzdGFydDogc3RyaW5nKTpcbiAgICAgICAgc3RyaW5nID0+IHtcbiAgICAgICAgICBjb25zdCByYW5rID0gaW5wdXREaW1zLmxlbmd0aDtcbiAgICAgICAgICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggPD0gMikge1xuICAgICAgICAgICAgY29uc3Qga3cgPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlW2F0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBzdyA9IGF0dHJpYnV0ZXMuc3RyaWRlc1thdHRyaWJ1dGVzLnN0cmlkZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBwd1N0YXJ0ID0gYXR0cmlidXRlcy5wYWRzW2F0dHJpYnV0ZXMucGFkcy5sZW5ndGggLyAyIC0gMV07XG4gICAgICAgICAgICBjb25zdCBwd0VuZCA9IGF0dHJpYnV0ZXMucGFkc1thdHRyaWJ1dGVzLnBhZHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBkaW1XID0gaW5wdXREaW1zW3JhbmsgLSAxXTtcbiAgICAgICAgICAgIGxldCBjb2RlVyA9ICcnO1xuICAgICAgICAgICAgbGV0IGNvZGVIID0gJyc7XG4gICAgICAgICAgICBsZXQgY29kZUhFbmQgPSAnJztcbiAgICAgICAgICAgIGlmIChwd1N0YXJ0ICsgcHdFbmQgIT09IDApIHtcbiAgICAgICAgICAgICAgY29kZVcgPSBgXG4gICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke2t3fTsgaSsrKSB7XG4gICAgICAgICAgICB4WyR7cmFua30gLSAxXSA9IGluZGljZXNbJHtyYW5rfSAtIDFdICogJHtzd30gLSAke3B3U3RhcnR9ICsgaTtcbiAgICAgICAgICAgIGlmICh4WyR7cmFua30gLSAxXSA8IDAgfHwgeFske3Jhbmt9IC0gMV0gPj0gJHtkaW1XfSkge1xuICAgICAgICAgICAgICBwYWQrKztcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAke29wMX1cbiAgICAgICAgICB9YDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvZGVXID0gYFxuICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtrd307IGkrKykge1xuICAgICAgICAgICAgeFske3Jhbmt9IC0gMV0gPSBpbmRpY2VzWyR7cmFua30gLSAxXSAqICR7c3d9IC0gJHtwd1N0YXJ0fSArIGk7XG4gICAgICAgICAgICAke29wMX1cbiAgICAgICAgICB9YDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGtoID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZVthdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICBjb25zdCBzaCA9IGF0dHJpYnV0ZXMuc3RyaWRlc1thdHRyaWJ1dGVzLnN0cmlkZXMubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICAgIGNvbnN0IHBoU3RhcnQgPSBhdHRyaWJ1dGVzLnBhZHNbYXR0cmlidXRlcy5wYWRzLmxlbmd0aCAvIDIgLSAyXTtcbiAgICAgICAgICAgICAgY29uc3QgcGhFbmQgPSBhdHRyaWJ1dGVzLnBhZHNbYXR0cmlidXRlcy5wYWRzLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICBjb25zdCBkaW1IID0gaW5wdXREaW1zW3JhbmsgLSAyXTtcbiAgICAgICAgICAgICAgaWYgKHBoU3RhcnQgKyBwaEVuZCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvZGVIID0gYFxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCAke2tofTsgaisrKSB7XG4gICAgICAgICAgICAgIHhbJHtyYW5rfSAtIDJdID0gaW5kaWNlc1ske3Jhbmt9IC0gMl0gKiAke3NofSAtICR7cGhTdGFydH0gKyBqO1xuICAgICAgICAgICAgICBpZiAoeFske3Jhbmt9IC0gMl0gPCAwIHx8IHhbJHtyYW5rfSAtIDJdID49ICR7ZGltSH0pIHtcbiAgICAgICAgICAgICAgICBwYWQrPSAke2t3fTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIGA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29kZUggPSBgXG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8ICR7a2h9OyBqKyspIHtcbiAgICAgICAgICAgICAgeFske3Jhbmt9IC0gMl0gPSBpbmRpY2VzWyR7cmFua30gLSAyXSAqICR7c2h9IC0gJHtwaFN0YXJ0fSArIGo7XG4gICAgICAgICAgICBgO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvZGVIRW5kID0gYFxuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcG9vbGluZ0NvZGUgPSBgXG4gICAgICAgIGZsb2F0IHByb2Nlc3MoaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgICBpbnQgeFske3Jhbmt9XTtcbiAgICAgICAgICBjb3B5VmVjKGluZGljZXMsIHgpO1xuXG4gICAgICAgICAgZmxvYXQgdmFsdWUgPSAke3N0YXJ0fTtcbiAgICAgICAgICBpbnQgcGFkID0gMDtcbiAgICAgICAgICAke2NvZGVIfVxuICAgICAgICAgICR7Y29kZVd9XG4gICAgICAgICAgJHtjb2RlSEVuZH1cbiAgICAgICAgICAke29wMn1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgICAgICAgICByZXR1cm4gcG9vbGluZ0NvZGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGtlcm5lbFNpemUgPSBTaGFwZVV0aWwuc2l6ZShhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlKTtcbiAgICAgICAgICAgIGNvbnN0IGtlcm5lbFN0cmlkZXMgPSBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoYXR0cmlidXRlcy5rZXJuZWxTaGFwZSk7XG4gICAgICAgICAgICBjb25zdCBzdHJpZGVzUmFuayA9IGtlcm5lbFN0cmlkZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgcGFkc1JhbmsgPSBhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0VG9JbmRpY2VzRnVuY3Rpb24gPSBvZmZzZXRUb0luZGljZXMoc3RyaWRlc1JhbmspO1xuICAgICAgICAgICAgY29uc3QgY29weUlucHV0RGltcyA9IGNvcHlBcnJheShpbnB1dERpbXMsICdpbnB1dERpbXMnKTtcbiAgICAgICAgICAgIGNvbnN0IGNvcHlQYWRzID0gY29weUFycmF5KGF0dHJpYnV0ZXMucGFkcywgJ3BhZHMnKTtcbiAgICAgICAgICAgIGNvbnN0IGNvcHlLZXJuZWxTdHJpZGVzID0gY29weUFycmF5KGtlcm5lbFN0cmlkZXMsICdrZXJuZWxTdHJpZGVzJyk7XG4gICAgICAgICAgICBjb25zdCBjb3B5U3RyaWRlcyA9IGNvcHlBcnJheShhdHRyaWJ1dGVzLnN0cmlkZXMsICdzdHJpZGVzJyk7XG4gICAgICAgICAgICBjb25zdCBoYXNQYWRzID0gYXR0cmlidXRlcy5wYWRzLnJlZHVjZSgoc3VtLCBjdXIpID0+IHN1bSArIGN1cik7XG4gICAgICAgICAgICBsZXQgcGFkQ29kZSA9ICcnO1xuICAgICAgICAgICAgaWYgKGhhc1BhZHMpIHtcbiAgICAgICAgICAgICAgcGFkQ29kZSA9IGBcbiAgICAgICAgICAgIGlmICh4W2pdID49IGlucHV0RGltc1tqXSB8fCB4W2pdIDwgMCkge1xuICAgICAgICAgICAgICBwYWQrKztcbiAgICAgICAgICAgICAgaXNQYWQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc1BhZCkge1xuICAgICAgICAgICAgJHtvcDF9XG4gICAgICAgICAgfWA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYWRDb2RlID0gYFxuICAgICAgICAgIH1cbiAgICAgICAgICAke29wMX1cbiAgICAgICAgYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBvb2xpbmdDb2RlID0gYFxuICAgICAgICAke29mZnNldFRvSW5kaWNlc0Z1bmN0aW9ufVxuICAgICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgICAgaW50IHhbJHtyYW5rfV07XG4gICAgICAgICAgY29weVZlYyhpbmRpY2VzLCB4KTtcbiAgICAgICAgICBpbnQgb2Zmc2V0WyR7c3RyaWRlc1Jhbmt9XTtcbiAgICAgICAgICBpbnQgcGFkc1ske3BhZHNSYW5rfV07XG4gICAgICAgICAgaW50IGlucHV0RGltc1ske3Jhbmt9XTtcbiAgICAgICAgICBpbnQga2VybmVsU3RyaWRlc1ske3N0cmlkZXNSYW5rfV07XG4gICAgICAgICAgaW50IHN0cmlkZXNbJHtzdHJpZGVzUmFua31dO1xuICAgICAgICAgICR7Y29weVBhZHN9XG4gICAgICAgICAgJHtjb3B5SW5wdXREaW1zfVxuICAgICAgICAgICR7Y29weVN0cmlkZXN9XG4gICAgICAgICAgJHtjb3B5S2VybmVsU3RyaWRlc31cblxuICAgICAgICAgIGZsb2F0IHZhbHVlID0gJHtzdGFydH07XG4gICAgICAgICAgaW50IHBhZCA9IDA7XG4gICAgICAgICAgYm9vbCBpc1BhZCA9IGZhbHNlO1xuICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgJHtrZXJuZWxTaXplfTsgaSsrKSB7XG4gICAgICAgICAgICBvZmZzZXRUb0luZGljZXMoaSwga2VybmVsU3RyaWRlcywgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlzUGFkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGludCBqID0gJHtyYW5rfSAtICR7c3RyaWRlc1Jhbmt9OyBqIDwgJHtyYW5rfTsgaisrKSB7XG4gICAgICAgICAgICAgIHhbal0gPSBpbmRpY2VzW2pdICogc3RyaWRlc1tqIC0gJHtyYW5rfSArICR7c3RyaWRlc1Jhbmt9XVxuICAgICAgICAgICAgICAgICsgb2Zmc2V0W2ogLSAke3Jhbmt9ICsgJHtzdHJpZGVzUmFua31dIC0gcGFkc1tqIC0gMl07XG4gICAgICAgICAgICAgICR7cGFkQ29kZX1cbiAgICAgICAgICB9XG4gICAgICAgICAgJHtvcDJ9XG5cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgICAgICAgICByZXR1cm4gcG9vbGluZ0NvZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG5jb25zdCBjb3B5QXJyYXkgPSAoYXJyYXk6IHJlYWRvbmx5IG51bWJlcltdLCBhcnJheU5hbWU6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIGxldCBibG9jayA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgYmxvY2sgKz0gYFxuICAgICAgJHthcnJheU5hbWV9WyR7aX1dID0gJHthcnJheVtpXX07XG4gICAgYDtcbiAgfVxuICByZXR1cm4gYmxvY2s7XG59O1xuXG5jb25zdCBvZmZzZXRUb0luZGljZXMgPSAocmFuazogbnVtYmVyKTogc3RyaW5nID0+IGBcbiAgdm9pZCBvZmZzZXRUb0luZGljZXMoaW50IG9mZnNldCwgaW50WyR7cmFua31dIHN0cmlkZXMsIG91dCBpbnRbJHtyYW5rfV0gaW5kaWNlcykge1xuICAgIGlmICgke3Jhbmt9ID09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke3Jhbmt9IC0gMTsgKytpKSB7XG4gICAgICBpbmRpY2VzW2ldID0gb2Zmc2V0IC8gc3RyaWRlc1tpXTtcbiAgICAgIG9mZnNldCAtPSBpbmRpY2VzW2ldICogc3RyaWRlc1tpXTtcbiAgICB9XG4gICAgaW5kaWNlc1ske3Jhbmt9IC0gMV0gPSBvZmZzZXQ7XG4gIH1gO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi8uLi8uLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHtOVU1CRVJfVFlQRVMsIE9wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb259IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBQcm9ncmFtTWV0YWRhdGEsIFRleHR1cmVUeXBlfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVkdWNlQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGF4ZXM6IG51bWJlcltdO1xuICByZWFkb25seSBrZWVwRGltczogYm9vbGVhbjtcbn1cblxuLy8gcmV0dXJuIFtpbml0IG9wcywgcmVkdWNlIG9wcywgZmluYWwgb3BzXVxudHlwZSBSZWR1Y2VPcCA9IChpbnB1dHM6IFRlbnNvcltdLCBheGVzOiBudW1iZXJbXSkgPT4gc3RyaW5nW107XG5cbmNvbnN0IHJlZHVjZSA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcywgbmFtZTogc3RyaW5nLFxuICAgICByZWR1Y2VPcDogUmVkdWNlT3ApOiBUZW5zb3JbXSA9PiB7XG4gICAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuXG4gICAgICBjb25zdCByZWR1Y2VQcm9ncmFtTWV0YWRhdGEgPSB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGlucHV0TmFtZXM6IFsnQSddLFxuICAgICAgICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxuICAgICAgfTtcblxuICAgICAgY29uc3Qgb3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4ucmVkdWNlUHJvZ3JhbU1ldGFkYXRhLFxuICAgICAgICAgICAgY2FjaGVIaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LFxuICAgICAgICAgICAgZ2V0OiAoKSA9PlxuICAgICAgICAgICAgICAgIGNyZWF0ZVJlZHVjZVByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcywgbmFtZSwgcmVkdWNlT3AsIHJlZHVjZVByb2dyYW1NZXRhZGF0YSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlucHV0cyk7XG4gICAgICByZXR1cm4gW291dHB1dF07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlUmVkdWNlQXR0cmlidXRlczogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxSZWR1Y2VBdHRyaWJ1dGVzPiA9IChub2RlOiBHcmFwaC5Ob2RlKTogUmVkdWNlQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGF4ZXMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygnYXhlcycsIFtdKTtcbiAgY29uc3Qga2VlcERpbXMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCdrZWVwZGltcycsIDEpID09PSAxO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtheGVzLCBrZWVwRGltc30pO1xufTtcblxuY29uc3QgY3JlYXRlUmVkdWNlUHJvZ3JhbUluZm8gPVxuICAgIChfaGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzLCBfbmFtZTogc3RyaW5nLCByZWR1Y2VPcDogUmVkdWNlT3AsXG4gICAgIHJlZHVjZVByb2dyYW1NZXRhZGF0YTogUHJvZ3JhbU1ldGFkYXRhKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gW107XG4gICAgICBjb25zdCBpUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCB8fCAxO1xuXG4gICAgICBjb25zdCBpZHhDb3B5ID0gW107ICAvLyBjb3B5IG91dHB1dCBpbmRleGVzIHRvIGlucHV0IGluZGV4ZXNcblxuICAgICAgY29uc3QgYXhlcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKGF0dHJpYnV0ZXMuYXhlcywgaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IG9wcyA9IHJlZHVjZU9wKGlucHV0cywgYXhlcyk7XG4gICAgICBsZXQgcmVkdWNlT3BzID0gb3BzWzFdO1xuXG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IGlucHV0c1swXS5kaW1zLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIC8vIGlmIHRoaXMgYXhpcyBpcyByZWR1Y2VkXG4gICAgICAgIGlmIChheGVzLmluZGV4T2YoaykgPj0gMCB8fCBheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLmtlZXBEaW1zKSB7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZS5wdXNoKDEpO1xuICAgICAgICAgIH0gIC8vIGVsc2UgeyByZW1vdmUgdGhlIGF4aXMgZnJvbSBvdXRwdXRTaGFwZTsgfVxuXG4gICAgICAgICAgLy8gbG9vcCBvdmVyIHRoZSBkLXRoIGF4aXNcbiAgICAgICAgICByZWR1Y2VPcHMgPSBgXG4gICAgICAgICAgZm9yKGludCBqJHtrfSA9IDA7IGoke2t9IDwgJHtpbnB1dHNbMF0uZGltc1trXX07IGoke2t9KyspIHtcbiAgICAgICAgICAgIGlucHV0SWR4WyR7a31dID0gaiR7a307XG4gICAgICAgICAgICAke3JlZHVjZU9wc31cbiAgICAgICAgICB9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZHhDb3B5LnB1c2goYGlucHV0SWR4WyR7a31dID0gb3V0cHV0SWR4WyR7b3V0cHV0U2hhcGUubGVuZ3RofV07YCk7XG5cbiAgICAgICAgICBvdXRwdXRTaGFwZS5wdXNoKGlucHV0c1swXS5kaW1zW2tdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvUmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aCB8fCAxO1xuXG4gICAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBvdXRwdXRJZHhbJHtvUmFua31dKSB7XG4gICAgICAgIGZsb2F0IHZhbHVlOyAgICAgICAgICAgICAgICAgLy8gZmluYWwgcmVzdWx0XG4gICAgICAgIGludCBpbnB1dElkeFske2lSYW5rfV07ICAgICAgLy8gYWRkcmVzc2luZyBpbnB1dCBkYXRhXG4gICAgICAgICR7aWR4Q29weS5qb2luKCdcXG4nKX1cbiAgICAgICAgJHtvcHNbMF19ICAgICAgIC8vIGluaXQgb3BzIGZvciByZWR1Y2UgbWF4L21pblxuICAgICAgICAke3JlZHVjZU9wc31cbiAgICAgICAgJHtvcHNbMl19ICAgICAgIC8vIGZpbmFsIGNvbXB1dGF0aW9uIGZvciByZWR1Y2UgbWVhblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9YDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmVkdWNlUHJvZ3JhbU1ldGFkYXRhLFxuICAgICAgICBvdXRwdXQ6IHtkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgICAgIHNoYWRlclNvdXJjZVxuICAgICAgfTtcbiAgICB9O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIC8vIFRPRE86IHN1cHBvcnQgUmVkdWNlKiBvcGVyYXRvcnMgd2l0aCAyIGlucHV0cy5cbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVkdWNlIG9wIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cblxuICBpZiAoTlVNQkVSX1RZUEVTLmluZGV4T2YoaW5wdXRzWzBdLnR5cGUpID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlLicpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlU3VtOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPFJlZHVjZUF0dHJpYnV0ZXM+ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogVGVuc29yW10gPT4ge1xuICAgICAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKCk6IHN0cmluZ1tdID0+IFsndmFsdWUgPSAwLjA7JywgJ3ZhbHVlICs9IF9BKGlucHV0SWR4KTsnLCAnJ107XG4gICAgICByZXR1cm4gcmVkdWNlKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcywgJ1JlZHVjZVN1bScsIHJlZHVjZU9wKTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlTWVhbjogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxSZWR1Y2VBdHRyaWJ1dGVzPiA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IFRlbnNvcltdID0+IHtcbiAgICAgIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dHM6IFRlbnNvcltdLCBheGVzOiBudW1iZXJbXSk6IHN0cmluZ1tdID0+IHtcbiAgICAgICAgbGV0IHNpemUgPSAxLjA7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICBpZiAoYXhlcy5pbmRleE9mKGspID49IDAgfHwgYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHNpemUgKj0gaW5wdXRzWzBdLmRpbXNba107XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFsndmFsdWUgPSAwLjA7JywgJ3ZhbHVlICs9IF9BKGlucHV0SWR4KTsnLCBgdmFsdWUgLz0gJHtzaXplfS47YF07ICAvLyBlbnN1cmUgcmVhbCBudW1iZXIgd2l0aCBgLmBcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVkdWNlKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcywgJ1JlZHVjZU1lYW4nLCByZWR1Y2VPcCk7XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZU1heDogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxSZWR1Y2VBdHRyaWJ1dGVzPiA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IFRlbnNvcltdID0+IHtcbiAgICAgIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dHM6IFRlbnNvcltdLCBheGVzOiBudW1iZXJbXSk6IHN0cmluZ1tdID0+IHtcbiAgICAgICAgY29uc3QgaWR4WmVybyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGlucHV0c1swXS5kaW1zLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgaWYgKGF4ZXMuaW5kZXhPZihrKSA+PSAwIHx8IGF4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpZHhaZXJvLnB1c2goYGlucHV0SWR4WyR7a31dID0gMDtgKTsgIC8vIGZpcnN0IGVsZW1lbnRcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW2Ake2lkeFplcm8uam9pbignXFxuJyl9XFxudmFsdWUgPSBfQShpbnB1dElkeCk7YCwgJ3ZhbHVlID0gbWF4KHZhbHVlLCBfQShpbnB1dElkeCkpOycsICcnXTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVkdWNlKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcywgJ1JlZHVjZU1heCcsIHJlZHVjZU9wKTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlTWluOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPFJlZHVjZUF0dHJpYnV0ZXM+ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogVGVuc29yW10gPT4ge1xuICAgICAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0czogVGVuc29yW10sIGF4ZXM6IG51bWJlcltdKTogc3RyaW5nW10gPT4ge1xuICAgICAgICBjb25zdCBpZHhaZXJvID0gW107XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICBpZiAoYXhlcy5pbmRleE9mKGspID49IDAgfHwgYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlkeFplcm8ucHVzaChgaW5wdXRJZHhbJHtrfV0gPSAwO2ApOyAgLy8gZmlyc3QgZWxlbWVudFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbYCR7aWR4WmVyby5qb2luKCdcXG4nKX1cXG52YWx1ZSA9IF9BKGlucHV0SWR4KTtgLCAndmFsdWUgPSBtaW4odmFsdWUsIF9BKGlucHV0SWR4KSk7JywgJyddO1xuICAgICAgfTtcbiAgICAgIHJldHVybiByZWR1Y2UoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhdHRyaWJ1dGVzLCAnUmVkdWNlTWluJywgcmVkdWNlT3ApO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VQcm9kOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPFJlZHVjZUF0dHJpYnV0ZXM+ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogVGVuc29yW10gPT4ge1xuICAgICAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKCk6IHN0cmluZ1tdID0+IFsndmFsdWUgPSAxLjA7JywgJ3ZhbHVlICo9IF9BKGlucHV0SWR4KTsnLCAnJ107XG4gICAgICByZXR1cm4gcmVkdWNlKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcywgJ1JlZHVjZVByb2QnLCByZWR1Y2VPcCk7XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUxvZ1N1bTogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxSZWR1Y2VBdHRyaWJ1dGVzPiA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IFRlbnNvcltdID0+IHtcbiAgICAgIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9ICgpOiBzdHJpbmdbXSA9PiBbJ3ZhbHVlID0gMC4wOycsICd2YWx1ZSArPSBfQShpbnB1dElkeCk7JywgJ3ZhbHVlID0gbG9nKHZhbHVlKTsnXTtcbiAgICAgIHJldHVybiByZWR1Y2UoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBhdHRyaWJ1dGVzLCAnUmVkdWNlTG9nU3VtJywgcmVkdWNlT3ApO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VMb2dTdW1TcXVhcmU6IE9wZXJhdG9ySW1wbGVtZW50YXRpb248UmVkdWNlQXR0cmlidXRlcz4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiB7XG4gICAgICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoKTogc3RyaW5nW10gPT4gWydmbG9hdCB0OyB2YWx1ZSA9IDAuMDsnLCAndCA9IF9BKGlucHV0SWR4KTsgdmFsdWUgKz0gdCAqIHQ7JywgJyddO1xuICAgICAgcmV0dXJuIHJlZHVjZShpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGF0dHJpYnV0ZXMsICdSZWR1Y2VMb2dTdW1TcXVhcmUnLCByZWR1Y2VPcCk7XG4gICAgfTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuXG5leHBvcnQgY29uc3QgcmVzaGFwZSA9IChoYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiB7XG4gIGNvbnN0IHJlc2hhcGVkRGltcyA9IFNoYXBlVXRpbC5jYWxjdWxhdGVSZXNoYXBlZERpbXMoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5pbnRlZ2VyRGF0YSk7XG4gIGlmIChoYW5kbGVyLnNlc3Npb24ucGFjaykge1xuICAgIHJldHVybiBbaGFuZGxlci5yZXNoYXBlUGFja2VkKGlucHV0c1swXSwgcmVzaGFwZWREaW1zKV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtoYW5kbGVyLnJlc2hhcGVVbnBhY2tlZChpbnB1dHNbMF0sIHJlc2hhcGVkRGltcyldO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi8uLi8uLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHtPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9ufSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBUZXh0dXJlVHlwZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVwc2FtcGxlQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IG9wc2V0OiBudW1iZXI7XG4gIHJlYWRvbmx5IGlzUmVzaXplOiBib29sZWFuO1xuICByZWFkb25seSBtb2RlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHNjYWxlczogbnVtYmVyW107XG4gIHJlYWRvbmx5IGV4dHJhcG9sYXRpb25WYWx1ZTogbnVtYmVyO1xuICByZWFkb25seSBjb29yZGluYXRlVHJhbnNmb3JtTW9kZTogc3RyaW5nO1xuICByZWFkb25seSB1c2VFeHRyYXBvbGF0aW9uOiBib29sZWFuO1xuICByZWFkb25seSBuZWVkUm9pSW5wdXQ6IGJvb2xlYW47XG4gIHJlYWRvbmx5IG5lYXJlc3RNb2RlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGN1YmljQ29lZmZpY2llbnRBOiBudW1iZXI7XG4gIHJlYWRvbmx5IGV4Y2x1ZGVPdXRzaWRlOiBib29sZWFuO1xuICByZWFkb25seSB1c2VOZWFyZXN0MnhPcHRpbWl6YXRpb246IGJvb2xlYW47XG4gIHJlYWRvbmx5IHJvaUlucHV0SWR4OiBudW1iZXI7XG4gIHJlYWRvbmx5IHNjYWxlc0lucHV0SWR4OiBudW1iZXI7XG4gIHJlYWRvbmx5IHNpemVzSW5wdXRJZHg6IG51bWJlcjtcbn1cblxuY29uc3QgdXBzYW1wbGVQcm9ncmFtTWV0YWRhdGEgPSB7XG4gIG5hbWU6ICdVcHNhbXBsZScsXG4gIGlucHV0TmFtZXM6IFsnWCddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWRdLFxufTtcblxuZXhwb3J0IGNvbnN0IHVwc2FtcGxlOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPFVwc2FtcGxlQXR0cmlidXRlcz4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IFVwc2FtcGxlQXR0cmlidXRlcyk6IFRlbnNvcltdID0+IHtcbiAgICAgIHZhbGlkYXRlSW5wdXRzKGlucHV0cywgYXR0cmlidXRlcyk7XG4gICAgICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi51cHNhbXBsZVByb2dyYW1NZXRhZGF0YSxcbiAgICAgICAgICAgIGNhY2hlSGludDogYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgICAgICAgICAgIGdldDogKCkgPT4gY3JlYXRlVXBzYW1wbGVQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGF0dHJpYnV0ZXMpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnB1dHMpO1xuICAgICAgcmV0dXJuIFtvdXRwdXRdO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y3OiBPcGVyYXRvckluaXRpYWxpemF0aW9uPFVwc2FtcGxlQXR0cmlidXRlcz4gPVxuICAgIChub2RlOiBHcmFwaC5Ob2RlKTogVXBzYW1wbGVBdHRyaWJ1dGVzID0+IHBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzKG5vZGUsIDcpO1xuXG5leHBvcnQgY29uc3QgcGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWOTogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxVcHNhbXBsZUF0dHJpYnV0ZXM+ID1cbiAgICAobm9kZTogR3JhcGguTm9kZSk6IFVwc2FtcGxlQXR0cmlidXRlcyA9PiBwYXJzZVVwc2FtcGxlQXR0cmlidXRlcyhub2RlLCA5KTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzID0gKG5vZGU6IEdyYXBoLk5vZGUsIG9wc2V0OiBudW1iZXIpOiBVcHNhbXBsZUF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBpc1Jlc2l6ZSA9IChvcHNldCA+PSAxMCk7XG5cbiAgLy8gcHJvY2Vzc2luZyBub2RlIGF0dHJpYnV0ZXNcbiAgY29uc3QgbW9kZSA9IG5vZGUuYXR0cmlidXRlcy5nZXRTdHJpbmcoJ21vZGUnLCAnbmVhcmVzdCcpO1xuICBpZiAobW9kZSAhPT0gJ25lYXJlc3QnICYmIG1vZGUgIT09ICdsaW5lYXInICYmIChvcHNldCA8IDExIHx8IG1vZGUgIT09ICdjdWJpYycpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgbW9kZTogJHttb2RlfWApO1xuICB9XG5cbiAgbGV0IHNjYWxlczogbnVtYmVyW10gPSBbXTtcbiAgaWYgKG9wc2V0IDwgOSkge1xuICAgIHNjYWxlcyA9IG5vZGUuYXR0cmlidXRlcy5nZXRGbG9hdHMoJ3NjYWxlcycpO1xuICAgIHNjYWxlc1ZhbGlkYXRpb24oc2NhbGVzLCBtb2RlLCBpc1Jlc2l6ZSk7XG4gIH1cblxuICBjb25zdCBleHRyYXBvbGF0aW9uVmFsdWUgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ2V4dHJhcG9sYXRpb25fdmFsdWUnLCAwLjApO1xuXG4gIGNvbnN0IGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlID1cbiAgICAgIG9wc2V0ID4gMTAgPyBub2RlLmF0dHJpYnV0ZXMuZ2V0U3RyaW5nKCdjb29yZGluYXRlX3RyYW5zZm9ybWF0aW9uX21vZGUnLCAnaGFsZl9waXhlbCcpIDogJ2FzeW1tZXRyaWMnO1xuICBpZiAoW1xuICAgICAgICAnYXN5bW1ldHJpYycsICdweXRvcmNoX2hhbGZfcGl4ZWwnLCAndGZfaGFsZl9waXhlbF9mb3Jfbm4nLCAnYWxpZ25fY29ybmVycycsICd0Zl9jcm9wX2FuZF9yZXNpemUnLCAnaGFsZl9waXhlbCdcbiAgICAgIF0uaW5kZXhPZihjb29yZGluYXRlVHJhbnNmb3JtTW9kZSkgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBjb29yZGluYXRlX3RyYW5zZm9ybV9tb2RlICcke2Nvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlfScgaXMgbm90IHN1cHBvcnRlZGApO1xuICB9XG4gIGNvbnN0IG5lZWRSb2lJbnB1dCA9IChjb29yZGluYXRlVHJhbnNmb3JtTW9kZSA9PT0gJ3RmX2Nyb3BfYW5kX3Jlc2l6ZScpO1xuICBjb25zdCB1c2VFeHRyYXBvbGF0aW9uID0gbmVlZFJvaUlucHV0O1xuXG4gIGNvbnN0IG5lYXJlc3RNb2RlID1cbiAgICAgIChtb2RlID09PSAnbmVhcmVzdCcgJiYgb3BzZXQgPj0gMTEpID8gbm9kZS5hdHRyaWJ1dGVzLmdldFN0cmluZygnbmVhcmVzdF9tb2RlJywgJ3JvdW5kX3ByZWZlcl9mbG9vcicpIDogJyc7XG4gIGlmIChbJ3JvdW5kX3ByZWZlcl9mbG9vcicsICdyb3VuZF9wcmVmZXJfY2VpbCcsICdmbG9vcicsICdjZWlsJywgJyddLmluZGV4T2YobmVhcmVzdE1vZGUpID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgbmVhcmVzdF9tb2RlICcke25lYXJlc3RNb2RlfScgaXMgbm90IHN1cHBvcnRlZGApO1xuICB9XG5cbiAgY29uc3QgY3ViaWNDb2VmZmljaWVudEEgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ2N1YmljX2NvZWZmX2EnLCAtMC43NSk7XG4gIGNvbnN0IGV4Y2x1ZGVPdXRzaWRlID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludCgnZXhjbHVkZV9vdXRzaWRlJywgMCkgIT09IDA7XG4gIGlmIChleGNsdWRlT3V0c2lkZSAmJiBtb2RlICE9PSAnY3ViaWMnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdleGNsdWRlX291dHNpZGUgY2FuIGJlIHNldCB0byAxIG9ubHkgd2hlbiBtb2RlIGlzIENVQklDLicpO1xuICB9XG5cbiAgY29uc3QgdXNlTmVhcmVzdDJ4T3B0aW1pemF0aW9uID1cbiAgICAgIChvcHNldCA8IDExKSA/IHRydWUgOiAobW9kZSA9PT0gJ25lYXJlc3QnICYmIGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlID09PSAnYXN5bW1ldHJpYycgJiYgbmVhcmVzdE1vZGUgPT09ICdmbG9vcicpO1xuXG4gIGxldCByb2lJbnB1dElkeCA9IDA7XG4gIGxldCBzY2FsZXNJbnB1dElkeCA9IDA7XG4gIGxldCBzaXplc0lucHV0SWR4ID0gMDtcblxuICBpZiAob3BzZXQgPiAxMCkge1xuICAgIC8vIGhhbmRsZSB3aGVuIHJvaUlucHV0IGlzIG5vdCBnaXZlblxuICAgIGlmIChub2RlLmlucHV0cy5sZW5ndGggPiAyKSB7XG4gICAgICByb2lJbnB1dElkeCA9IDE7XG4gICAgICBzY2FsZXNJbnB1dElkeCA9IDI7XG4gICAgICBzaXplc0lucHV0SWR4ID0gMztcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGVzSW5wdXRJZHggPSAxO1xuICAgICAgc2l6ZXNJbnB1dElkeCA9IDI7XG4gICAgfVxuICB9IGVsc2UgaWYgKG9wc2V0ID09PSA5KSB7XG4gICAgc2NhbGVzSW5wdXRJZHggPSAxO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7XG4gICAgb3BzZXQsXG4gICAgaXNSZXNpemUsXG4gICAgbW9kZSxcbiAgICBzY2FsZXMsXG4gICAgZXh0cmFwb2xhdGlvblZhbHVlLFxuICAgIGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlLFxuICAgIHVzZUV4dHJhcG9sYXRpb24sXG4gICAgbmVlZFJvaUlucHV0LFxuICAgIG5lYXJlc3RNb2RlLFxuICAgIGN1YmljQ29lZmZpY2llbnRBLFxuICAgIGV4Y2x1ZGVPdXRzaWRlLFxuICAgIHVzZU5lYXJlc3QyeE9wdGltaXphdGlvbixcbiAgICByb2lJbnB1dElkeCxcbiAgICBzY2FsZXNJbnB1dElkeCxcbiAgICBzaXplc0lucHV0SWR4XG4gIH0pO1xufTtcblxuY29uc3QgY3JlYXRlVXBzYW1wbGVQcm9ncmFtSW5mbyA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogVXBzYW1wbGVBdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgICAgY29uc3QgW2lucHV0V2lkdGgsIGlucHV0SGVpZ2h0XSA9XG4gICAgICAgICAgaW5mZXJlbmNlSGFuZGxlci5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoaW5wdXRzWzBdLmRpbXMsIFRleHR1cmVUeXBlLnVucGFja2VkKTtcblxuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5tYXAoKGRpbSwgaSkgPT4gTWF0aC5mbG9vcihkaW0gKiBhdHRyaWJ1dGVzLnNjYWxlc1tpXSkpO1xuICAgICAgY29uc3QgW291dHB1dFdpZHRoLCBvdXRwdXRIZWlnaHRdID1cbiAgICAgICAgICBpbmZlcmVuY2VIYW5kbGVyLmNhbGN1bGF0ZVRleHR1cmVXaWR0aEFuZEhlaWdodChvdXRwdXRTaGFwZSwgVGV4dHVyZVR5cGUudW5wYWNrZWQpO1xuICAgICAgY29uc3QgZGltID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuXG4gICAgICBjb25zdCBvdXRwdXRQaXRjaGVzID0gbmV3IEFycmF5PG51bWJlcj4oZGltKTtcbiAgICAgIGNvbnN0IGlucHV0UGl0Y2hlcyA9IG5ldyBBcnJheTxudW1iZXI+KGRpbSk7XG4gICAgICBsZXQgcHJlY2FsY3VsYXRlZFBpdGNoZXMgPSBgXG4gICAgICBpbnQgb3V0cHV0X3BpdGNoZXNbJHtkaW19XTtcbiAgICAgIGludCBpbnB1dF9waXRjaGVzWyR7ZGltfV07XG4gICAgICBgO1xuICAgICAgZm9yIChsZXQgZCA9IGRpbSAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIG91dHB1dFBpdGNoZXNbZF0gPSAoZCA9PT0gZGltIC0gMSkgPyAxIDogb3V0cHV0UGl0Y2hlc1tkICsgMV0gKiBvdXRwdXRTaGFwZVtkICsgMV07XG4gICAgICAgIGlucHV0UGl0Y2hlc1tkXSA9IChkID09PSBkaW0gLSAxKSA/IDEgOiBpbnB1dFBpdGNoZXNbZCArIDFdICogaW5wdXRzWzBdLmRpbXNbZCArIDFdO1xuXG4gICAgICAgIHByZWNhbGN1bGF0ZWRQaXRjaGVzICs9IGBcbiAgICAgICAgb3V0cHV0X3BpdGNoZXNbJHtkfV0gPSAke291dHB1dFBpdGNoZXNbZF19O1xuICAgICAgICBpbnB1dF9waXRjaGVzWyR7ZH1dID0gJHtpbnB1dFBpdGNoZXNbZF19O1xuICAgICAgICBgO1xuICAgICAgfVxuICAgICAgY29uc3QgZ2V0SW5wdXRGbG9hdEZ1bmN0aW9uID0gYFxuICAgICAgZmxvYXQgZ2V0SW5wdXRGbG9hdChpbnQgaW5kZXgpIHtcbiAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhpbmRleCwgJHtpbnB1dFdpZHRofSwgJHtpbnB1dEhlaWdodH0pO1xuICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfShYLCBjb29yZHMpKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgYDtcblxuICAgICAgY29uc3Qgc2hhZGVyU291cmNlID0gYXR0cmlidXRlcy5tb2RlID09PSAnbmVhcmVzdCcgP1xuICAgICAgICAgIC8vIG5lYXJlc3RcbiAgICAgICAgICBgXG4gICAgJHtnZXRJbnB1dEZsb2F0RnVuY3Rpb259XG4gICAgZmxvYXQgcHJvY2VzcyhpbnQgaW5kaWNlc1ske2RpbX1dKSB7XG4gICAgICBpbnQgaW5wdXRfaW5kZXggPSAwO1xuICAgICAgaW50IG91dHB1dF9pbmRleCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtvdXRwdXRXaWR0aH0sICR7b3V0cHV0SGVpZ2h0fSk7XG5cbiAgICAgICR7cHJlY2FsY3VsYXRlZFBpdGNoZXN9XG5cbiAgICAgIGludCBkLCBtO1xuICAgICAgZm9yIChpbnQgZGltID0gMDsgZGltIDwgJHtkaW19OyArK2RpbSkge1xuICAgICAgICBkID0gb3V0cHV0X2luZGV4IC8gb3V0cHV0X3BpdGNoZXNbZGltXTtcbiAgICAgICAgbSA9IG91dHB1dF9pbmRleCAtIGQgKiBvdXRwdXRfcGl0Y2hlc1tkaW1dO1xuICAgICAgICBvdXRwdXRfaW5kZXggPSBtO1xuXG4gICAgICAgIGlmIChzY2FsZXNbZGltXSAhPSAxICYmIGQgPiAwKSB7XG4gICAgICAgICAgaW50IGQyID0gZCAvIHNjYWxlc1tkaW1dO1xuICAgICAgICAgIG0gPSBkIC0gZDIgKiBzY2FsZXNbZGltXTtcbiAgICAgICAgICBkID0gZDI7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXRfaW5kZXggKz0gaW5wdXRfcGl0Y2hlc1tkaW1dICogZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXgpO1xuICAgIH1gIDpcbiAgICAgICAgICBkaW0gPT09IDQgP1xuICAgICAgICAgIC8vIGJpbGluZWFyIDREXG4gICAgICAgICAgICAgIGBcbiAgICAke2dldElucHV0RmxvYXRGdW5jdGlvbn1cbiAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWzRdKSB7XG4gICAgICBpbnQgaW5wdXRfaW5kZXggPSAwO1xuICAgICAgaW50IG91dHB1dF9pbmRleCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtvdXRwdXRXaWR0aH0sICR7b3V0cHV0SGVpZ2h0fSk7XG5cbiAgICAgICR7cHJlY2FsY3VsYXRlZFBpdGNoZXN9XG5cbiAgICAgIGludCBtO1xuICAgICAgaW50IGluZGV4X29mX2RpbTAsIGluZGV4X29mX2RpbTEsIGluZGV4X29mX2RpbTIsIGluZGV4X29mX2RpbTM7XG4gICAgICBpbmRleF9vZl9kaW0wID0gb3V0cHV0X2luZGV4IC8gb3V0cHV0X3BpdGNoZXNbMF07XG4gICAgICBtID0gb3V0cHV0X2luZGV4IC0gaW5kZXhfb2ZfZGltMCAqIG91dHB1dF9waXRjaGVzWzBdO1xuICAgICAgaW5kZXhfb2ZfZGltMSA9IG0gLyBvdXRwdXRfcGl0Y2hlc1sxXTtcbiAgICAgIG0gPSBtIC0gaW5kZXhfb2ZfZGltMSAqIG91dHB1dF9waXRjaGVzWzFdO1xuICAgICAgaW5kZXhfb2ZfZGltMiA9IG0gLyBvdXRwdXRfcGl0Y2hlc1syXTtcbiAgICAgIG0gPSBtIC0gaW5kZXhfb2ZfZGltMiAqIG91dHB1dF9waXRjaGVzWzJdO1xuICAgICAgaW5kZXhfb2ZfZGltMyA9IG07XG5cbiAgICAgIGludCBpbmRleF9vZl9pbnB1dF9kaW0yLCBpbmRleF9vZl9pbnB1dF9kaW0zLCB4X29mZnNldCwgeV9vZmZzZXQ7XG4gICAgICBpbmRleF9vZl9pbnB1dF9kaW0yID0gaW5kZXhfb2ZfZGltMiAvIHNjYWxlc1syXTtcbiAgICAgIHlfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMiAtIGluZGV4X29mX2lucHV0X2RpbTIgKiBzY2FsZXNbMl07XG4gICAgICBpbmRleF9vZl9pbnB1dF9kaW0zID0gaW5kZXhfb2ZfZGltMyAvIHNjYWxlc1szXTtcbiAgICAgIHhfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMyAtIGluZGV4X29mX2lucHV0X2RpbTMgKiBzY2FsZXNbM107XG5cbiAgICAgIGlucHV0X2luZGV4ID0gaW5kZXhfb2ZfZGltMCAqIGlucHV0X3BpdGNoZXNbMF0gK1xuICAgICAgICAgICAgaW5kZXhfb2ZfZGltMSAqIGlucHV0X3BpdGNoZXNbMV0gK1xuICAgICAgICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMiAqIGlucHV0X3BpdGNoZXNbMl0gK1xuICAgICAgICAgICAgaW5kZXhfb2ZfaW5wdXRfZGltMztcblxuICAgICAgZmxvYXQgeDAwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCk7XG4gICAgICBmbG9hdCB4MTAsIHgwMSwgeDExO1xuXG4gICAgICBib29sIGVuZF9vZl9kaW0yID0gZmFsc2U7XG4gICAgICBpZiAoaW5kZXhfb2ZfaW5wdXRfZGltMiA9PSAoJHtpbnB1dHNbMF0uZGltc1syXX0gLSAxKSkge1xuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDJcbiAgICAgICAgeDAxID0geDAwO1xuICAgICAgICBlbmRfb2ZfZGltMiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MDEgPSBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4ICsgaW5wdXRfcGl0Y2hlc1syXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleF9vZl9pbnB1dF9kaW0zID09IChpbnB1dF9waXRjaGVzWzJdIC0gMSkpIHtcbiAgICAgICAgLy8gSXQncyB0aGUgZW5kIGluIGRpbWVuc2lvbiAzXG4gICAgICAgIHgxMCA9IHgwMDtcbiAgICAgICAgeDExID0geDAxO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHgxMCA9IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyAxKTtcbiAgICAgICAgeDExID0gZW5kX29mX2RpbTIgPyB4MTAgOiBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4ICsgaW5wdXRfcGl0Y2hlc1syXSArIDEpO1xuICAgICAgfVxuXG4gICAgICBmbG9hdCB5MCA9IHgwMCArIGZsb2F0KHlfb2Zmc2V0KSAqICh4MDEgLSB4MDApIC8gZmxvYXQoc2NhbGVzWzJdKTtcbiAgICAgIGZsb2F0IHkxID0geDEwICsgZmxvYXQoeV9vZmZzZXQpICogKHgxMSAtIHgxMCkgLyBmbG9hdChzY2FsZXNbMl0pO1xuICAgICAgcmV0dXJuIHkwICsgZmxvYXQoeF9vZmZzZXQpICogKHkxIC0geTApIC8gZmxvYXQoc2NhbGVzWzNdKTtcbiAgICB9YCA6XG4gICAgICAgICAgICAgIC8vIGJpbGluZWFyIDJEXG4gICAgICAgICAgICAgIGBcbiAgICAke2dldElucHV0RmxvYXRGdW5jdGlvbn1cbiAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWzJdKSB7XG4gICAgICBpbnQgaW5wdXRfaW5kZXggPSAwO1xuICAgICAgaW50IG91dHB1dF9pbmRleCA9IGNvb3Jkc1RvT2Zmc2V0KFRleENvb3JkcywgJHtvdXRwdXRXaWR0aH0sICR7b3V0cHV0SGVpZ2h0fSk7XG5cbiAgICAgICR7cHJlY2FsY3VsYXRlZFBpdGNoZXN9XG5cbiAgICAgIGludCBtO1xuICAgICAgaW50IGluZGV4X29mX2RpbTAsIGluZGV4X29mX2RpbTE7XG4gICAgICBpbmRleF9vZl9kaW0wID0gb3V0cHV0X2luZGV4IC8gb3V0cHV0X3BpdGNoZXNbMF07XG4gICAgICBtID0gb3V0cHV0X2luZGV4IC0gaW5kZXhfb2ZfZGltMCAqIG91dHB1dF9waXRjaGVzWzBdO1xuICAgICAgaW5kZXhfb2ZfZGltMSA9IG07XG5cbiAgICAgIGludCBpbmRleF9vZl9pbnB1dF9kaW0wLCBpbmRleF9vZl9pbnB1dF9kaW0xLCB4X29mZnNldCwgeV9vZmZzZXQ7XG4gICAgICBpbmRleF9vZl9pbnB1dF9kaW0wID0gaW5kZXhfb2ZfZGltMCAvIHNjYWxlc1swXTtcbiAgICAgIHlfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMCAtIGluZGV4X29mX2lucHV0X2RpbTAgKiBzY2FsZXNbMF07XG4gICAgICBpbmRleF9vZl9pbnB1dF9kaW0xID0gaW5kZXhfb2ZfZGltMSAvIHNjYWxlc1sxXTtcbiAgICAgIHhfb2Zmc2V0ID0gaW5kZXhfb2ZfZGltMSAtIGluZGV4X29mX2lucHV0X2RpbTEgKiBzY2FsZXNbMV07XG5cbiAgICAgIGlucHV0X2luZGV4ID0gaW5kZXhfb2ZfaW5wdXRfZGltMCAqIGlucHV0X3BpdGNoZXNbMF0gKyBpbmRleF9vZl9pbnB1dF9kaW0xO1xuXG4gICAgICBmbG9hdCB4MDAgPSBnZXRJbnB1dEZsb2F0KGlucHV0X2luZGV4KTtcbiAgICAgIGZsb2F0IHgxMCwgeDAxLCB4MTE7XG5cbiAgICAgIGJvb2wgZW5kX29mX2RpbTAgPSBmYWxzZTtcbiAgICAgIGlmIChpbmRleF9vZl9pbnB1dF9kaW0wID09ICgke2lucHV0c1swXS5kaW1zWzBdfSAtIDEpKSB7XG4gICAgICAgIC8vIEl0J3MgdGhlIGVuZCBpbiBkaW1lbnNpb24gMFxuICAgICAgICB4MDEgPSB4MDA7XG4gICAgICAgIGVuZF9vZl9kaW0wID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgwMSA9IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzBdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4X29mX2lucHV0X2RpbTEgPT0gKGlucHV0X3BpdGNoZXNbMF0gLSAxKSkge1xuICAgICAgICAvLyBJdCdzIHRoZSBlbmQgaW4gZGltZW5zaW9uIDFcbiAgICAgICAgeDEwID0geDAwO1xuICAgICAgICB4MTEgPSB4MDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgeDEwID0gZ2V0SW5wdXRGbG9hdChpbnB1dF9pbmRleCArIDEpO1xuICAgICAgICB4MTEgPSBlbmRfb2ZfZGltMCA/IHgxMCA6IGdldElucHV0RmxvYXQoaW5wdXRfaW5kZXggKyBpbnB1dF9waXRjaGVzWzBdICsgMSk7XG4gICAgICB9XG5cbiAgICAgIGZsb2F0IHkwID0geDAwICsgZmxvYXQoeV9vZmZzZXQpICogKHgwMSAtIHgwMCkgLyBmbG9hdChzY2FsZXNbMF0pO1xuICAgICAgZmxvYXQgeTEgPSB4MTAgKyBmbG9hdCh5X29mZnNldCkgKiAoeDExIC0geDEwKSAvIGZsb2F0KHNjYWxlc1swXSk7XG4gICAgICByZXR1cm4geTAgKyBmbG9hdCh4X29mZnNldCkgKiAoeTEgLSB5MCkgLyBmbG9hdChzY2FsZXNbMV0pO1xuICAgIH1gO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4udXBzYW1wbGVQcm9ncmFtTWV0YWRhdGEsXG4gICAgICAgIG91dHB1dDoge2RpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dHNbMF0udHlwZSwgdGV4dHVyZVR5cGU6IFRleHR1cmVUeXBlLnVucGFja2VkfSxcbiAgICAgICAgc2hhZGVyU291cmNlLFxuICAgICAgICB2YXJpYWJsZXM6IFt7XG4gICAgICAgICAgbmFtZTogJ3NjYWxlcycsXG4gICAgICAgICAgdHlwZTogJ2ludCcsXG4gICAgICAgICAgYXJyYXlMZW5ndGg6IGF0dHJpYnV0ZXMuc2NhbGVzLmxlbmd0aCxcbiAgICAgICAgICBkYXRhOiBhdHRyaWJ1dGVzLnNjYWxlcy5tYXAoeCA9PiBNYXRoLmNlaWwoeCkpXG4gICAgICAgIH1dXG4gICAgICB9O1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGU6IFVwc2FtcGxlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCAoYXR0cmlidXRlLm9wc2V0IDwgOSAmJiBpbnB1dHMubGVuZ3RoICE9PSAxKSB8fFxuICAgICAgKGF0dHJpYnV0ZS5vcHNldCA+PSA5ICYmIGF0dHJpYnV0ZS5vcHNldCA8IDExICYmIGlucHV0cy5sZW5ndGggIT09IDIpIHx8XG4gICAgICAoYXR0cmlidXRlLm9wc2V0ID49IDExICYmIGlucHV0cy5sZW5ndGggPCAyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnB1dHMuJyk7XG4gIH1cblxuICBpZiAoYXR0cmlidXRlLnNjYWxlcy5sZW5ndGggPiAwICYmIGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gYXR0cmlidXRlLnNjYWxlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgc2hhcGUuJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzWzBdLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHRlbnNvciB0eXBlcy4nKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHNjYWxlc1ZhbGlkYXRpb24gPSAoc2NhbGVzOiBudW1iZXJbXSwgbW9kZTogc3RyaW5nLCBpc1Jlc2l6ZTogYm9vbGVhbik6IHZvaWQgPT4ge1xuICBpZiAoIWlzUmVzaXplKSB7XG4gICAgZm9yIChjb25zdCBzY2FsZSBvZiBzY2FsZXMpIHtcbiAgICAgIGlmIChzY2FsZSA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTY2FsZSB2YWx1ZSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEuJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3Qgc2NhbGUgb2Ygc2NhbGVzKSB7XG4gICAgICBpZiAoc2NhbGUgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NjYWxlIHZhbHVlIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gMC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdsaW5lYXInIHx8IG1vZGUgPT09ICdjdWJpYycpIHtcbiAgICBpZiAoc2NhbGVzLmxlbmd0aCAhPT0gMiAmJiAoc2NhbGVzLmxlbmd0aCAhPT0gNCB8fCBzY2FsZXNbMF0gIT09IDEgfHwgc2NhbGVzWzFdICE9PSAxKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAnTGluZWFyJyBtb2RlIGFuZCAnQ3ViaWMnIG1vZGUgb25seSBzdXBwb3J0IDItRCBpbnB1dHMgKCdCaWxpbmVhcicsICdCaWN1YmljJykgXFxcbiAgICAgICAgb3IgNC1EIGlucHV0cyB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIG91dGVybW9zdCAyIHNjYWxlIHZhbHVlcyBiZWluZyAxIFxcXG4gICAgICAgIGluIHRoZSAke2lzUmVzaXplID8gJ1Jlc2l6ZScgOiAnVXBzYW1wbGUnfSBvcGVhcnRvci5gKTtcbiAgICB9XG4gIH1cbn07IiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0dyYXBofSBmcm9tICcuLi8uLi8uLi9ncmFwaCc7XG5pbXBvcnQge09wZXJhdG9ySW1wbGVtZW50YXRpb24sIE9wZXJhdG9ySW5pdGlhbGl6YXRpb259IGZyb20gJy4uLy4uLy4uL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7Z2V0R2xzbH0gZnJvbSAnLi4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFRleHR1cmVUeXBlfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge2dldENvb3Jkc0RhdGFUeXBlfSBmcm9tICcuLi91dGlscyc7XG5cbmltcG9ydCB7dW5wYWNrRnJvbUNoYW5uZWx9IGZyb20gJy4vcGFja2luZy11dGlscyc7XG5pbXBvcnQge3BhcnNlVXBzYW1wbGVBdHRyaWJ1dGVzLCBzY2FsZXNWYWxpZGF0aW9uLCBVcHNhbXBsZUF0dHJpYnV0ZXMsIHZhbGlkYXRlSW5wdXRzfSBmcm9tICcuL3Vwc2FtcGxlJztcblxuY29uc3QgcmVzaXplUHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAnUmVzaXplJyxcbiAgaW5wdXROYW1lczogWydBJ10sXG4gIGlucHV0VHlwZXM6IFtUZXh0dXJlVHlwZS5wYWNrZWRdXG59O1xuXG5leHBvcnQgY29uc3QgcmVzaXplOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPFVwc2FtcGxlQXR0cmlidXRlcz4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IFVwc2FtcGxlQXR0cmlidXRlcyk6IFRlbnNvcltdID0+IHtcbiAgICAgIHZhbGlkYXRlSW5wdXRzKGlucHV0cywgYXR0cmlidXRlcyk7XG4gICAgICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi5yZXNpemVQcm9ncmFtTWV0YWRhdGEsXG4gICAgICAgICAgICBjYWNoZUhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gICAgICAgICAgICBnZXQ6ICgpID0+IGNyZWF0ZVBhY2tlZFJlc2l6ZVByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgYXR0cmlidXRlcylcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlucHV0cyk7XG4gICAgICByZXR1cm4gW291dHB1dF07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlUmVzaXplQXR0cmlidXRlc1YxMDogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxVcHNhbXBsZUF0dHJpYnV0ZXM+ID1cbiAgICAobm9kZTogR3JhcGguTm9kZSk6IFVwc2FtcGxlQXR0cmlidXRlcyA9PiBwYXJzZVVwc2FtcGxlQXR0cmlidXRlcyhub2RlLCAxMCk7XG5cbmV4cG9ydCBjb25zdCBwYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTE6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248VXBzYW1wbGVBdHRyaWJ1dGVzPiA9XG4gICAgKG5vZGU6IEdyYXBoLk5vZGUpOiBVcHNhbXBsZUF0dHJpYnV0ZXMgPT4gcGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXMobm9kZSwgMTEpO1xuXG5jb25zdCBjcmVhdGVQYWNrZWRSZXNpemVQcm9ncmFtSW5mbyA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogVXBzYW1wbGVBdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgZ2xzbCA9IGdldEdsc2woaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmJhY2tlbmQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgICAgY29uc3QgW3NjYWxlcywgb3V0cHV0U2hhcGVdID0gcHJlcGFyZUlucHV0cyhpbnB1dHMsIGF0dHJpYnV0ZXMpO1xuXG4gICAgICBjb25zdCBpc1NhbWUgPVxuICAgICAgICAgIHNjYWxlcy5ldmVyeSgoczogbnVtYmVyKSA9PiBzID09PSAxKSAmJiBhdHRyaWJ1dGVzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlICE9PSAndGZfY3JvcF9hbmRfcmVzaXplJztcbiAgICAgIGlmIChpc1NhbWUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5yZXNpemVQcm9ncmFtTWV0YWRhdGEsXG4gICAgICAgICAgb3V0cHV0OiB7ZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0c1swXS50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUucGFja2VkfSxcbiAgICAgICAgICBoYXNNYWluOiB0cnVlLFxuICAgICAgICAgIHNoYWRlclNvdXJjZTogYHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmVjNCB2ID0gJHtnbHNsLnRleHR1cmUyRH0oWCwgVGV4Q29vcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgJHtnbHNsLm91dHB1dH0gPSB2O1xuICAgICAgICAgICAgICAgIH1gXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRpbSA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICAgIGlmIChkaW0gPCAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgb3V0cHV0IGRpbWVuc2lvbiBzaG91bGQgYmUgYXQgbGVhc3QgMiwgYnV0IGdvdCAke2RpbX1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3V0cHV0SGVpZ2h0ID0gb3V0cHV0U2hhcGVbZGltIC0gMl07XG4gICAgICBjb25zdCBvdXRwdXRXaWR0aCA9IG91dHB1dFNoYXBlW2RpbSAtIDFdO1xuXG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gICAgICBpZiAoZGltICE9PSBpbnB1dFNoYXBlLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG91dHB1dCBkaW1lbnNpb24gc2hvdWxkIG1hdGNoIGlucHV0ICR7aW5wdXRTaGFwZS5sZW5ndGh9LCBidXQgZ290ICR7ZGltfWApO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5wdXRIZWlnaHQgPSBpbnB1dFNoYXBlW2RpbSAtIDJdO1xuICAgICAgY29uc3QgaW5wdXRXaWR0aCA9IGlucHV0U2hhcGVbZGltIC0gMV07XG5cbiAgICAgIGNvbnN0IHNjYWxlc0hlaWdodCA9IHNjYWxlc1tkaW0gLSAyXTtcbiAgICAgIGNvbnN0IHNjYWxlc1dpZHRoID0gc2NhbGVzW2RpbSAtIDFdO1xuXG4gICAgICBsZXQgZ2V0U291cmNlRnJhY0luZGV4ID0gJyc7XG5cbiAgICAgIGlmIChhdHRyaWJ1dGVzLm1vZGUgIT09ICdsaW5lYXInKSB7XG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgb3RoZXIgbW9kZXNcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZXNpemUgKHBhY2tlZCkgZG9lcyBub3Qgc3VwcG9ydCBtb2RlOiAnJHthdHRyaWJ1dGVzLm1vZGV9J2ApO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChhdHRyaWJ1dGVzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlKSB7XG4gICAgICAgIGNhc2UgJ2FzeW1tZXRyaWMnOlxuICAgICAgICAgIGdldFNvdXJjZUZyYWNJbmRleCA9IGBcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBnZXRTb3VyY2VGcmFjSW5kZXgoaXZlYzQgY29vcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVjNChjb29yZHMpIC8gc2NhbGVXSFdIO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaGFsZl9waXhlbCc6XG4gICAgICAgICAgZ2V0U291cmNlRnJhY0luZGV4ID0gYFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGdldFNvdXJjZUZyYWNJbmRleChpdmVjNCBjb29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAodmVjNChjb29yZHMpICsgMC41KSAvIHNjYWxlV0hXSCAtIDAuNTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3B5dG9yY2hfaGFsZl9waXhlbCc6XG4gICAgICAgICAgZ2V0U291cmNlRnJhY0luZGV4ID0gYFxuICAgICAgICAgICAgICAgICAgICB2ZWM0IGdldFNvdXJjZUZyYWNJbmRleChpdmVjNCBjb29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgZmNvb3JkcyA9IHZlYzQoY29vcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2ZWM0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7b3V0cHV0V2lkdGh9LjAgPiAxLjAgPyAoZmNvb3Jkcy54ICsgMC41KSAvIHNjYWxlV0hXSC54IC0gMC41IDogMC4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7b3V0cHV0SGVpZ2h0fS4wID4gMS4wID8gKGZjb29yZHMueSArIDAuNSkgLyBzY2FsZVdIV0gueSAtIDAuNSA6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke291dHB1dFdpZHRofS4wID4gMS4wID8gKGZjb29yZHMueiArIDAuNSkgLyBzY2FsZVdIV0gueiAtIDAuNSA6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke291dHB1dEhlaWdodH0uMCA+IDEuMCA/IChmY29vcmRzLncgKyAwLjUpIC8gc2NhbGVXSFdILncgLSAwLjUgOiAwLjBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FsaWduX2Nvcm5lcnMnOlxuICAgICAgICAgIGdldFNvdXJjZUZyYWNJbmRleCA9IGBcbiAgICAgICAgICAgICAgICAgICAgdmVjNCBnZXRTb3VyY2VGcmFjSW5kZXgoaXZlYzQgY29vcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWM0IHJlc2l6ZWQgPSB2ZWM0KCR7b3V0cHV0V2lkdGh9LjAgLSAxLjAsICR7b3V0cHV0SGVpZ2h0fS4wIC0gMS4wLCAke291dHB1dFdpZHRofS4wIC0gMS4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7b3V0cHV0SGVpZ2h0fS4wIC0gMS4wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzQgb3JpZ2luYWwgPSB2ZWM0KCR7aW5wdXRXaWR0aH0uMCAtIDEuMCwgJHtpbnB1dEhlaWdodH0uMCAtIDEuMCwgJHtpbnB1dFdpZHRofS4wIC0gMS4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7aW5wdXRIZWlnaHR9LjAgLSAxLjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVjNCBuZXdfc2NhbGUgPSBvcmlnaW5hbCAvIHJlc2l6ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVjNChjb29yZHMpICogbmV3X3NjYWxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBUT0RPOnN1cHBvcnRpbmcgb3RoZXIgY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGVzXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZXNpemUgKHBhY2tlZCkgZG9lcyBub3Qgc3VwcG9ydCBjb29yZGluYXRlVHJhbnNmb3JtTW9kZTogXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyR7YXR0cmlidXRlcy5jb29yZGluYXRlVHJhbnNmb3JtTW9kZX0nYCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvb3Jkc0RhdGFUeXBlID0gZ2V0Q29vcmRzRGF0YVR5cGUoZGltKTtcbiAgICAgIGNvbnN0IHVucGFja0NoYW5uZWwgPSB1bnBhY2tGcm9tQ2hhbm5lbCgpO1xuICAgICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgICAgICAgY29uc3QgdmVjMiBpbnB1dFdIID0gdmVjMigke2lucHV0SGVpZ2h0fS4wLCAke2lucHV0V2lkdGh9LjApO1xuICAgICAgICAgICAgY29uc3QgdmVjNCBzY2FsZVdIV0ggPSB2ZWM0KGZsb2F0KCR7c2NhbGVzSGVpZ2h0fSksIGZsb2F0KCR7c2NhbGVzV2lkdGh9KSwgZmxvYXQoJHtzY2FsZXNIZWlnaHR9KSwgZmxvYXQoJHtcbiAgICAgICAgICBzY2FsZXNXaWR0aH0pKTtcbiAgICAgICAgICAgICR7dW5wYWNrQ2hhbm5lbH1cbiAgICAgICAgICAgICR7Z2V0U291cmNlRnJhY0luZGV4fVxuICAgICAgICAgICAgZmxvYXQgZ2V0QVZhbHVlKGludCB4MTAsIGludCByLCBpbnQgYywgaW50IGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChnZXRBKHgxMCwgciwgYywgZCksIHZlYzIoYywgZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgICR7Y29vcmRzRGF0YVR5cGV9IHJjID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG5cbiAgICAgICAgICAgICAgICBpbnQgYmF0Y2ggPSByY1swXTtcbiAgICAgICAgICAgICAgICBpbnQgZGVwdGggPSByY1sxXTtcblxuICAgICAgICAgICAgICAgIC8vIHJldHJpZXZlIHRoZSA0IGNvb3JkaW5hdGVzIHRoYXQgaXMgdXNlZCBpbiB0aGUgNCBwYWNrZWQgb3V0cHV0IHZhbHVlcy5cbiAgICAgICAgICAgICAgICBpdmVjNCBjb29yZHMgPSBpdmVjNChyYy53eiwgcmMudyArIDEsIHJjLnogKyAxKTtcblxuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgc291cmNlIGluZGV4IGluIGZyYWN0aW9uXG4gICAgICAgICAgICAgICAgdmVjNCBzb3VyY2VGcmFjID0gZ2V0U291cmNlRnJhY0luZGV4KGNvb3Jkcyk7XG5cbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGxvd2VyIGFuZCB1cHBlciBib3VuZCBvZiB0aGUgNCB2YWx1ZXMgdGhhdCB3aWxsIGJlIHBhY2tlZCBpbnRvIG9uZSB0ZXhlbC5cbiAgICAgICAgICAgICAgICBpdmVjNCB4MDAgPSBpdmVjNChtYXgoc291cmNlRnJhYy54eSwgdmVjMigwLjApKSwgbWluKGlucHV0V0ggLSAxLjAsIGNlaWwoc291cmNlRnJhYy54eSkpKTtcbiAgICAgICAgICAgICAgICBpdmVjNCB4MDEgPSBpdmVjNChtYXgoc291cmNlRnJhYy54dywgdmVjMigwLjApKSwgbWluKGlucHV0V0ggLSAxLjAsIGNlaWwoc291cmNlRnJhYy54dykpKTtcbiAgICAgICAgICAgICAgICBpdmVjNCB4MTAgPSBpdmVjNChtYXgoc291cmNlRnJhYy56eSwgdmVjMigwLjApKSwgbWluKGlucHV0V0ggLSAxLjAsIGNlaWwoc291cmNlRnJhYy56eSkpKTtcbiAgICAgICAgICAgICAgICBpdmVjNCB4MTEgPSBpdmVjNChtYXgoc291cmNlRnJhYy56dywgdmVjMigwLjApKSwgbWluKGlucHV0V0ggLSAxLjAsIGNlaWwoc291cmNlRnJhYy56dykpKTtcblxuICAgICAgICAgICAgICAgIGJvb2wgaGFzTmV4dFJvdyA9IHJjLncgPCAke291dHB1dEhlaWdodCAtIDF9O1xuICAgICAgICAgICAgICAgIGJvb2wgaGFzTmV4dENvbCA9IHJjLnogPCAke291dHB1dFdpZHRoIC0gMX07XG5cbiAgICAgICAgICAgICAgICAvLyBwYWNrIHgwMCwgeDAxLCB4MTAsIHgxMSdzIHRvcC1sZWZ0IGNvcm5lciBpbnRvIG9uZSB2ZWM0IHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgIHZlYzQgdG9wTGVmdCA9IHZlYzQoXG4gICAgICAgICAgICAgICAgICAgIGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMC54LCB4MDAueSksXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDEueCwgeDAxLnkpIDogMC4wLFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDEwLngsIHgxMC55KSA6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTEueCwgeDExLnkpIDogMC4wKTtcblxuICAgICAgICAgICAgICAgIC8vIHBhY2sgeDAwLCB4MDEsIHgxMCwgeDExJ3MgdG9wLXJpZ2h0IGNvcm5lciBpbnRvIG9uZSB2ZWM0IHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgIHZlYzQgdG9wUmlnaHQgPSB2ZWM0KFxuICAgICAgICAgICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDAueCwgeDAwLncpLFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAxLngsIHgwMS53KSA6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMC54LCB4MTAudykgOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDExLngsIHgxMS53KSA6IDAuMCk7XG5cbiAgICAgICAgICAgICAgICAvLyBwYWNrIHgwMCwgeDAxLCB4MTAsIHgxMSdzIGJvdHRvbS1sZWZ0IGNvcm5lciBpbnRvIG9uZSB2ZWM0IHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgIHZlYzQgYm90dG9tTGVmdCA9IHZlYzQoXG4gICAgICAgICAgICAgICAgICAgIGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgwMC56LCB4MDAueSksXG4gICAgICAgICAgICAgICAgICAgIGhhc05leHRDb2wgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDEueiwgeDAxLnkpIDogMC4wLFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Um93ID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDEwLnosIHgxMC55KSA6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgKGhhc05leHRSb3cgJiYgaGFzTmV4dENvbCkgPyBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MTEueiwgeDExLnkpIDogMC4wKTtcblxuICAgICAgICAgICAgICAgIC8vIHBhY2sgeDAwLCB4MDEsIHgxMCwgeDExJ3MgYm90dG9tLXJpZ2h0IGNvcm5lciBpbnRvIG9uZSB2ZWM0IHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgIHZlYzQgYm90dG9tUmlnaHQgPSB2ZWM0KFxuICAgICAgICAgICAgICAgICAgICBnZXRBVmFsdWUoYmF0Y2gsIGRlcHRoLCB4MDAueiwgeDAwLncpLFxuICAgICAgICAgICAgICAgICAgICBoYXNOZXh0Q29sID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDAxLnosIHgwMS53KSA6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgaGFzTmV4dFJvdyA/IGdldEFWYWx1ZShiYXRjaCwgZGVwdGgsIHgxMC56LCB4MTAudykgOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgIChoYXNOZXh0Um93ICYmIGhhc05leHRDb2wpID8gZ2V0QVZhbHVlKGJhdGNoLCBkZXB0aCwgeDExLnosIHgxMS53KSA6IDAuMCk7XG5cbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGludGVycG9sYXRpb24gZnJhY3Rpb24gb24gdSBhbmQgdiBkaXJlY3Rpb25cbiAgICAgICAgICAgICAgICB2ZWM0IGZyYWMgPSB2ZWM0KHNvdXJjZUZyYWMpIC0gZmxvb3Ioc291cmNlRnJhYyk7XG4gICAgICAgICAgICAgICAgdmVjNCBjbGFtcEZyYWMgPSBjbGFtcChmcmFjLCB2ZWM0KDAuMCksIHZlYzQoMS4wKSk7XG5cbiAgICAgICAgICAgICAgICB2ZWM0IHRvcCA9IG1peCh0b3BMZWZ0LCB0b3BSaWdodCwgY2xhbXBGcmFjLnl3eXcpO1xuICAgICAgICAgICAgICAgIHZlYzQgYm90dG9tID0gbWl4KGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0LCBjbGFtcEZyYWMueXd5dyk7XG4gICAgICAgICAgICAgICAgdmVjNCBuZXdWYWx1ZSA9IG1peCh0b3AsIGJvdHRvbSwgY2xhbXBGcmFjLnh4enopO1xuXG4gICAgICAgICAgICAgICAgJHtnbHNsLm91dHB1dH0gPSB2ZWM0KG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnJlc2l6ZVByb2dyYW1NZXRhZGF0YSxcbiAgICAgICAgb3V0cHV0OiB7ZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0c1swXS50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUucGFja2VkfSxcbiAgICAgICAgaGFzTWFpbjogdHJ1ZSxcbiAgICAgICAgc2hhZGVyU291cmNlXG4gICAgICB9O1xuICAgIH07XG5cblxuY29uc3QgcHJlcGFyZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBVcHNhbXBsZUF0dHJpYnV0ZXMpOiBbcmVhZG9ubHkgbnVtYmVyW10sIHJlYWRvbmx5IG51bWJlcltdXSA9PiB7XG4gIGNvbnN0IHggPSBpbnB1dHNbMF07XG4gIGNvbnN0IHhEaW1zID0geC5kaW1zO1xuXG4gIGxldCBzY2FsZXMgPSBhdHRyaWJ1dGVzLnNjYWxlcztcbiAgbGV0IG91dHB1dFNpemVzOiBudW1iZXJbXXx1bmRlZmluZWQ7XG4gIGlmIChzY2FsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgY29uc3Qgc2NhbGVzVGVuc29yID0gaW5wdXRzW2F0dHJpYnV0ZXMuc2NhbGVzSW5wdXRJZHhdO1xuICAgIGlmIChzY2FsZXNUZW5zb3IgJiYgc2NhbGVzVGVuc29yLnNpemUgIT09IDApIHtcbiAgICAgIGlmIChpbnB1dHNbYXR0cmlidXRlcy5zaXplc0lucHV0SWR4XSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb25lIG9mIHNjYWxlcyBvciBzaXplcyBtdXN0IGJlIHByb3ZpZGVkIGFzIGlucHV0LicpO1xuICAgICAgfVxuICAgICAgc2NhbGVzID0gcGFyc2VTY2FsZXNEYXRhKHNjYWxlc1RlbnNvciwgYXR0cmlidXRlcy5tb2RlLCBhdHRyaWJ1dGVzLmlzUmVzaXplKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2l6ZXNUZW5zb3IgPSBpbnB1dHNbYXR0cmlidXRlcy5zaXplc0lucHV0SWR4XTtcbiAgICAgIGlmICghc2l6ZXNUZW5zb3IgfHwgc2l6ZXNUZW5zb3Iuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VpdGhlciBzY2FsZXMgb3Igc2l6ZXMgTVVTVCBiZSBwcm92aWRlZCBhcyBpbnB1dC4nKTtcbiAgICAgIH1cblxuICAgICAgb3V0cHV0U2l6ZXMgPSBBcnJheS5mcm9tKHNpemVzVGVuc29yLmludGVnZXJEYXRhKTtcbiAgICAgIHNjYWxlcyA9IHBhcnNlU2NhbGVzRGF0YUZyb21PdXRwdXRTaXplKG91dHB1dFNpemVzLCB4RGltcywgYXR0cmlidXRlcy5tb2RlLCBhdHRyaWJ1dGVzLmlzUmVzaXplKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlucHV0c1thdHRyaWJ1dGVzLnNpemVzSW5wdXRJZHhdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb25lIG9mIHNjYWxlcyBvciBzaXplcyBtdXN0IGJlIHByb3ZpZGVkIGFzIGlucHV0LicpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHlEaW1zID0gb3V0cHV0U2l6ZXMgfHwgKHhEaW1zLm1hcCgoZGltLCBpKSA9PiBNYXRoLmZsb29yKGRpbSAqIHNjYWxlc1tpXSkpKTtcblxuICByZXR1cm4gW3NjYWxlcywgeURpbXNdO1xufTtcblxuY29uc3QgcGFyc2VTY2FsZXNEYXRhID0gKHNjYWxlOiBUZW5zb3IsIG1vZGU6IHN0cmluZywgaXNSZXNpemU6IGJvb2xlYW4pOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IHNjYWxlcyA9IEFycmF5LmZyb20oc2NhbGUuZmxvYXREYXRhKTtcbiAgc2NhbGVzVmFsaWRhdGlvbihzY2FsZXMsIG1vZGUsIGlzUmVzaXplKTtcbiAgcmV0dXJuIHNjYWxlcztcbn07XG5cbmNvbnN0IHBhcnNlU2NhbGVzRGF0YUZyb21PdXRwdXRTaXplID1cbiAgICAoeURpbXM6IHJlYWRvbmx5IG51bWJlcltdLCB4RGltczogcmVhZG9ubHkgbnVtYmVyW10sIG1vZGU6IHN0cmluZywgaXNSZXNpemU6IGJvb2xlYW4pOiBudW1iZXJbXSA9PiB7XG4gICAgICBjb25zdCBsZW5ndGggPSB4RGltcy5sZW5ndGg7XG4gICAgICBjb25zdCBzY2FsZXMgPSBuZXcgQXJyYXk8bnVtYmVyPihsZW5ndGgpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMCwgZW5kID0gbGVuZ3RoOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgaWYgKHhEaW1zW2ldID09PSAwKSB7XG4gICAgICAgICAgaWYgKHlEaW1zW2ldICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRpbSBpcyB6ZXJvIGJ1dCByZXF1aXJlZCBvdXRwdXQgZGltIGlzIG5vbi16ZXJvLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzY2FsZXNbaV0gPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjYWxlc1tpXSA9IHlEaW1zW2ldIC8geERpbXNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNjYWxlc1ZhbGlkYXRpb24oc2NhbGVzLCBtb2RlLCBpc1Jlc2l6ZSk7XG4gICAgICByZXR1cm4gc2NhbGVzO1xuICAgIH07XG5cbi8vIHJvaSBkYXRhIGlzIG5vdCB1c2VkIHlldC4gYnV0IGxlYXZlIGhlcmUgZm9yIGZ1dHVyZSB1c2FnZS5cbi8vIGNvbnN0IGdldFJvaSA9IChpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBVcHNhbXBsZUF0dHJpYnV0ZXMpIDogbnVtYmVyW10gPT4ge1xuLy8gICAgIGxldCByb2k6IG51bWJlcltdID0gW107XG4vLyAgICAgaWYgKGF0dHJpYnV0ZXMubmVlZFJvaUlucHV0KSB7XG4vLyAgICAgICAgIGlmIChhdHRyaWJ1dGVzLnJvaUlucHV0SWR4IDw9IDApIHtcbi8vICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByb2kgaW5wdXQgaW5kZXguJyk7XG4vLyAgICAgICAgIH1cbi8vICAgICAgICAgY29uc3Qgcm9pVGVuc29yID0gaW5wdXRzW2F0dHJpYnV0ZXMucm9pSW5wdXRJZHhdO1xuLy8gICAgICAgICByb2kgPSByb2lUZW5zb3Iuc2l6ZSA+IDAgPyBBcnJheS5mcm9tKHJvaVRlbnNvci5mbG9hdERhdGEpIDogW107XG4vLyAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgcm9pID0gbmV3IEFycmF5KGlucHV0c1swXS5kaW1zLmxlbmd0aCAqIDIpLmZpbGwoMCk7XG4vLyAgICAgfVxuLy8gICAgIHJldHVybiByb2k7XG4vLyB9O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vLi4vLi4vdGVuc29yJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5cbmV4cG9ydCBjb25zdCBzaGFwZSA9IChfaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICByZXR1cm4gW25ldyBUZW5zb3IoW2lucHV0c1swXS5kaW1zLmxlbmd0aF0sICdpbnQzMicsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBuZXcgSW50MzJBcnJheShpbnB1dHNbMF0uZGltcykpXTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hhcGUgcmVxdWlyZXMgMSBpbnB1dC4nKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vLi4vLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7R3JhcGh9IGZyb20gJy4uLy4uLy4uL2dyYXBoJztcbmltcG9ydCB7TlVNQkVSX1RZUEVTLCBPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9ufSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgVGV4dHVyZVR5cGV9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBTbGljZUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBheGVzOiBudW1iZXJbXTtcbiAgcmVhZG9ubHkgZW5kczogbnVtYmVyW107XG4gIHJlYWRvbmx5IHN0YXJ0czogbnVtYmVyW107XG59XG5cbmNvbnN0IHNsaWNlUHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAnU2xpY2UnLFxuICBpbnB1dE5hbWVzOiBbJ0EnXSxcbiAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXVxufTtcblxuZXhwb3J0IGNvbnN0IHNsaWNlOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPFNsaWNlQXR0cmlidXRlcz4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IFNsaWNlQXR0cmlidXRlcyk6IFRlbnNvcltdID0+IHtcbiAgICAgIHZhbGlkYXRlSW5wdXRzKGlucHV0cyk7XG4gICAgICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi5zbGljZVByb2dyYW1NZXRhZGF0YSxcbiAgICAgICAgICAgIGNhY2hlSGludDogYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgICAgICAgICAgIGdldDogKCkgPT4gY3JlYXRlU2xpY2VQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHNbMF0sIGF0dHJpYnV0ZXMpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnB1dHMpO1xuICAgICAgcmV0dXJuIFtvdXRwdXRdO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVNsaWNlQXR0cmlidXRlczogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxTbGljZUF0dHJpYnV0ZXM+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBTbGljZUF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBzdGFydHMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygnc3RhcnRzJyk7XG4gIGNvbnN0IGVuZHMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50cygnZW5kcycpO1xuICBjb25zdCBheGVzID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludHMoJ2F4ZXMnLCBbXSk7XG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe3N0YXJ0cywgZW5kcywgYXhlc30pO1xufTtcblxuY29uc3QgY3JlYXRlU2xpY2VQcm9ncmFtSW5mbyA9XG4gICAgKF9pbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0OiBUZW5zb3IsIGF0dHJpYnV0ZXM6IFNsaWNlQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGF4ZXMgPSAoYXR0cmlidXRlcy5heGVzLmxlbmd0aCA9PT0gMCkgPyBpbnB1dC5kaW1zLnNsaWNlKDApLm1hcCgoX3ZhbCwgaSkgPT4gaSkgOiBhdHRyaWJ1dGVzLmF4ZXM7XG4gICAgICBjb25zdCBub3JtYWxpemVkQXhlcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKGF4ZXMsIGlucHV0LmRpbXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IHN0YXJ0cyA9IGF0dHJpYnV0ZXMuc3RhcnRzLm1hcCgoc3RhcnQsIGkpID0+IHtcbiAgICAgICAgaWYgKHN0YXJ0ID4gaW5wdXQuZGltc1tub3JtYWxpemVkQXhlc1tpXV0gLSAxKSB7XG4gICAgICAgICAgcmV0dXJuIGlucHV0LmRpbXNbbm9ybWFsaXplZEF4ZXNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhzdGFydCwgaW5wdXQuZGltc1tub3JtYWxpemVkQXhlc1tpXV0pO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBlbmRzID0gYXR0cmlidXRlcy5lbmRzLm1hcCgoZW5kLCBpKSA9PiB7XG4gICAgICAgIGlmIChlbmQgPiBpbnB1dC5kaW1zW25vcm1hbGl6ZWRBeGVzW2ldXSAtIDEpIHtcbiAgICAgICAgICByZXR1cm4gaW5wdXQuZGltc1tub3JtYWxpemVkQXhlc1tpXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGVuZCwgaW5wdXQuZGltc1tub3JtYWxpemVkQXhlc1tpXV0pO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXQuZGltcy5zbGljZSgpO1xuXG4gICAgICBjb25zdCBzbGljZU9wczogc3RyaW5nW10gPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9ybWFsaXplZEF4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb3V0cHV0U2hhcGVbbm9ybWFsaXplZEF4ZXNbaV1dID0gZW5kc1tpXSAtIHN0YXJ0c1tpXTtcbiAgICAgICAgaWYgKHN0YXJ0c1tpXSA+IDApIHtcbiAgICAgICAgICBzbGljZU9wcy5wdXNoKGBvdXRwdXRJZHhbJHtub3JtYWxpemVkQXhlc1tpXX1dICs9ICR7c3RhcnRzW2ldfTtgKTtcbiAgICAgICAgfSAgLy8gZWxzZSB7IHNsaWNlT3BzLnB1c2goYG91dHB1dElkeFske25vcm1hbGl6ZWRBeGVzW2ldfV0gKz0gMDtgKTsgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCByYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICAgICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgb3V0cHV0SWR4WyR7cmFua31dKSB7XG4gICAgICAgICR7c2xpY2VPcHMuam9pbignXFxuICAgICAgJyl9XG4gICAgICAgIHJldHVybiBfQShvdXRwdXRJZHgpO1xuICAgICAgfWA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zbGljZVByb2dyYW1NZXRhZGF0YSxcbiAgICAgICAgb3V0cHV0OiB7ZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0LnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgICAgIHNoYWRlclNvdXJjZVxuICAgICAgfTtcbiAgICB9O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NsaWNlIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cbiAgaWYgKE5VTUJFUl9UWVBFUy5pbmRleE9mKGlucHV0c1swXS50eXBlKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHNsaWNlVjEwID0gKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvcltdID0+IHtcbiAgdmFsaWRhdGVJbnB1dHNWMTAoaW5wdXRzKTtcbiAgY29uc3QgYXR0cmlidXRlcyA9IGdlbmVyYXRlU2xpY2VBdHRyaWJ1dGVzRnJvbUlucHV0cyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMpO1xuICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICAgIHtcbiAgICAgICAgLi4uc2xpY2VQcm9ncmFtTWV0YWRhdGEsXG4gICAgICAgIGNhY2hlSGludDogYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgICAgICAgZ2V0OiAoKSA9PiBjcmVhdGVTbGljZVByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0c1swXSwgYXR0cmlidXRlcylcbiAgICAgIH0sXG4gICAgICBbaW5wdXRzWzBdXSk7XG4gIHJldHVybiBbb3V0cHV0XTtcbn07XG5cbmNvbnN0IGdlbmVyYXRlU2xpY2VBdHRyaWJ1dGVzRnJvbUlucHV0cyA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSk6IFNsaWNlQXR0cmlidXRlcyA9PiB7XG4gICAgICBpZiAoIWluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGlucHV0c1sxXS5kYXRhSWQpIHx8XG4gICAgICAgICAgIWluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5pc0luaXRpYWxpemVyKGlucHV0c1syXS5kYXRhSWQpIHx8XG4gICAgICAgICAgKGlucHV0cy5sZW5ndGggPj0gNCAmJiAhaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIoaW5wdXRzWzNdLmRhdGFJZCkpIHx8XG4gICAgICAgICAgKGlucHV0cy5sZW5ndGggPj0gNSAmJiAhaW5mZXJlbmNlSGFuZGxlci5zZXNzaW9uLmlzSW5pdGlhbGl6ZXIoaW5wdXRzWzRdLmRhdGFJZCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZHluYW1pYyBzbGljZSBhdHRyaWJ1dGVzIGFyZSBub3QgYWxsb3dlZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5wdXRzLmxlbmd0aCA+PSA1ICYmIGlucHV0c1s0XS5pbnRlZ2VyRGF0YS5zb21lKChpOiBudW1iZXIpID0+IGkgIT09IDEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY3VycmVudGx5IG5vbi0xIHN0ZXBzIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIFNsaWNlJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0YXJ0cyA9IEFycmF5LmZyb20oaW5wdXRzWzFdLmludGVnZXJEYXRhKTtcbiAgICAgIGNvbnN0IGVuZHMgPSBBcnJheS5mcm9tKGlucHV0c1syXS5pbnRlZ2VyRGF0YSk7XG4gICAgICBjb25zdCBheGVzID0gaW5wdXRzLmxlbmd0aCA+PSA0ID8gQXJyYXkuZnJvbShpbnB1dHNbM10uaW50ZWdlckRhdGEpIDogW107XG4gICAgICBjb25zdCBjYWNoZUtleSA9IGAke2F4ZXN9OyR7c3RhcnRzfTske2VuZHN9YDtcbiAgICAgIHJldHVybiB7c3RhcnRzLCBlbmRzLCBheGVzLCBjYWNoZUtleX07XG4gICAgfTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHNWMTAgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMyB8fCBpbnB1dHMubGVuZ3RoID4gNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCBudW1iZXIuJyk7XG4gIH1cbiAgaWYgKGlucHV0c1sxXS50eXBlICE9PSAnaW50MzInIHx8IGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlLicpO1xuICB9XG4gIGlmIChpbnB1dHNbMl0udHlwZSAhPT0gJ2ludDMyJyB8fCBpbnB1dHNbMl0uZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxuICBpZiAoaW5wdXRzLmxlbmd0aCA+PSA0ICYmIChpbnB1dHNbM10udHlwZSAhPT0gJ2ludDMyJyB8fCBpbnB1dHNbM10uZGltcy5sZW5ndGggIT09IDEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUuJyk7XG4gIH1cbiAgaWYgKGlucHV0cy5sZW5ndGggPj0gNSAmJiAoaW5wdXRzWzRdLnR5cGUgIT09ICdpbnQzMicgfHwgaW5wdXRzWzRdLmRpbXMubGVuZ3RoICE9PSAxKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlLicpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi8uLi8uLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHtPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9ufSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBUZXh0dXJlVHlwZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge3RyYW5zcG9zZSwgVHJhbnNwb3NlQXR0cmlidXRlc30gZnJvbSAnLi90cmFuc3Bvc2UnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNvZnRtYXhBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgYXhpczogbnVtYmVyO1xufVxuXG5jb25zdCBzb2Z0bWF4Q29tcHV0ZU1heFByb2dyYW1NZXRhZGF0YSA9IHtcbiAgbmFtZTogJ1NvZnRtYXhDb21wdXRlTWF4JyxcbiAgaW5wdXROYW1lczogWydBJ10sXG4gIGlucHV0VHlwZXM6IFtUZXh0dXJlVHlwZS51bnBhY2tlZF0sXG59O1xuXG5jb25zdCBzb2Z0bWF4Q29tcHV0ZVNjYWxlUHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAnU29mdG1heENvbXB1dGVTY2FsZScsXG4gIGlucHV0TmFtZXM6IFsnQScsICdNYXgnXSxcbiAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkLCBUZXh0dXJlVHlwZS51bnBhY2tlZF0sXG59O1xuXG5jb25zdCBzb2Z0bWF4UHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAnU29mdE1heCcsXG4gIGlucHV0TmFtZXM6IFsnQScsICdNYXgnLCAnTm9ybSddLFxuICBpbnB1dFR5cGVzOiBbVGV4dHVyZVR5cGUudW5wYWNrZWQsIFRleHR1cmVUeXBlLnVucGFja2VkLCBUZXh0dXJlVHlwZS51bnBhY2tlZF0sXG59O1xuXG5leHBvcnQgY29uc3Qgc29mdG1heDogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxTb2Z0bWF4QXR0cmlidXRlcz4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF0dHJpYnV0ZXM6IFNvZnRtYXhBdHRyaWJ1dGVzKTogVGVuc29yW10gPT4ge1xuICAgICAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcblxuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gICAgICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dFNoYXBlLmxlbmd0aCk7XG4gICAgICBjb25zdCBsb2dpY2FsUm93Q291bnQgPSBTaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKGlucHV0U2hhcGUsIGF4aXMpO1xuICAgICAgY29uc3QgZmVhdHVyZUNvdW50ID0gU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKGlucHV0U2hhcGUsIGF4aXMpO1xuXG4gICAgICBjb25zdCBvdXRwdXQgPSBjb21wdXRlU29mdG1heChpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIGF0dHJpYnV0ZXMsIGxvZ2ljYWxSb3dDb3VudCwgZmVhdHVyZUNvdW50KTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlU29mdG1heEF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248U29mdG1heEF0dHJpYnV0ZXM+ID1cbiAgICAobm9kZTogR3JhcGguTm9kZSk6IFNvZnRtYXhBdHRyaWJ1dGVzID0+IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7YXhpczogbm9kZS5hdHRyaWJ1dGVzLmdldEludCgnYXhpcycsIDEpfSk7XG5cbmV4cG9ydCBjb25zdCBwYXJzZVNvZnRtYXhBdHRyaWJ1dGVzVjEzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPFNvZnRtYXhBdHRyaWJ1dGVzPiA9XG4gICAgKG5vZGU6IEdyYXBoLk5vZGUpOiBTb2Z0bWF4QXR0cmlidXRlcyA9PiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe2F4aXM6IG5vZGUuYXR0cmlidXRlcy5nZXRJbnQoJ2F4aXMnLCAtMSl9KTtcblxuLy8gVGhlIFwic2VtYW50aWNcIiBtZWFuaW5nIG9mIGF4aXMgaGFzIGNoYW5nZWQgaW4gb3BzZXQtMTMuXG4vLyBQbGVhc2UgY29tcGFyZTogaHR0cHM6Ly9naXRodWIuY29tL29ubngvb25ueC9ibG9iL21haW4vZG9jcy9PcGVyYXRvcnMubWQjU29mdG1heFxuLy8gd2l0aCBodHRwczovL2dpdGh1Yi5jb20vb25ueC9vbm54L2Jsb2IvbWFpbi9kb2NzL0NoYW5nZWxvZy5tZCNTb2Z0bWF4LTExIGZvciBkZXRhaWxlZCBleHBsYW5hdGlvbnNcbi8vIFRvIGFjY291bnQgZm9yIHRoZSBvcHNldC0xMyBiZWhhdmlvciwgb3VyIHBsYW4gd2lsbCBiZSB0byB0cmFuc3Bvc2UgdGhlIFwiYXhpc1wiIGRpbSB0byB0aGUgaW5uZXJtb3N0IGRpbVxuLy8gYW5kIHBlcmZvcm0gc29mdG1heCBhbmQgdGhlbiByZXZlcnNlIHRoZSB0cmFuc3Bvc2UuIFdlIGNhbiBza2lwIHRoZSB0cmFuc3Bvc2luZyBhc3BlY3QgaWYgdGhlIGF4aXMgaXMgYWxyZWFkeVxuLy8gdGhlIGlubmVybW9zdCBkaW1cbmV4cG9ydCBjb25zdCBzb2Z0bWF4VjEzOiBPcGVyYXRvckltcGxlbWVudGF0aW9uPFNvZnRtYXhBdHRyaWJ1dGVzPiA9XG4gICAgKGluZmVyZW5jZUhhbmRsZXI6IFdlYkdMSW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzOiBUZW5zb3JbXSwgYXR0cmlidXRlczogU29mdG1heEF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiB7XG4gICAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuXG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgICAgIGNvbnN0IGF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhhdHRyaWJ1dGVzLmF4aXMsIGlucHV0U2hhcGUubGVuZ3RoKTtcbiAgICAgIGNvbnN0IHJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcblxuICAgICAgY29uc3QgaXNUcmFuc3Bvc2VSZXF1aXJlZCA9IChheGlzICE9PSByYW5rIC0gMSkgPyB0cnVlIDogZmFsc2U7XG4gICAgICBjb25zdCB0cmFuc3Bvc2VkSW5wdXRTaGFwZTogbnVtYmVyW10gPSBbXTtcbiAgICAgIGxldCBwZXJtOiBudW1iZXJbXSA9IFtdO1xuICAgICAgbGV0IHRyYW5zcG9zZWRJbnB1dHM6IFRlbnNvcltdID0gW107XG4gICAgICBsZXQgdHJhbnNwb3NlQXR0cmlidXRlOiBUcmFuc3Bvc2VBdHRyaWJ1dGVzO1xuXG4gICAgICBpZiAoaXNUcmFuc3Bvc2VSZXF1aXJlZCkge1xuICAgICAgICBwZXJtID0gQXJyYXkuZnJvbSh7bGVuZ3RoOiByYW5rfSkubWFwKChfLCBpKSA9PiBpKTtcblxuICAgICAgICAvLyBzd2FwIHRoZSBpbm5lcm1vc3QgZGltIHdpdGggdGhlIGRpbSBjb3JyZXNwb25kaW5nIHRvIGF4aXNcbiAgICAgICAgcGVybVtheGlzXSA9IHJhbmsgLSAxO1xuICAgICAgICBwZXJtW3JhbmsgLSAxXSA9IGF4aXM7XG5cbiAgICAgICAgcGVybS5tYXAocCA9PiB0cmFuc3Bvc2VkSW5wdXRTaGFwZS5wdXNoKGlucHV0U2hhcGVbcF0pKTtcblxuICAgICAgICB0cmFuc3Bvc2VBdHRyaWJ1dGUgPSBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe3Blcm19KTtcbiAgICAgICAgdHJhbnNwb3NlZElucHV0cyA9IHRyYW5zcG9zZShpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIHRyYW5zcG9zZUF0dHJpYnV0ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvZ2ljYWxSb3dDb3VudCA9IGlzVHJhbnNwb3NlUmVxdWlyZWQgPyBTaGFwZVV0aWwuc2l6ZVRvRGltZW5zaW9uKHRyYW5zcG9zZWRJbnB1dFNoYXBlLCByYW5rIC0gMSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNoYXBlVXRpbC5zaXplVG9EaW1lbnNpb24oaW5wdXRTaGFwZSwgcmFuayAtIDEpO1xuICAgICAgY29uc3QgZmVhdHVyZUNvdW50ID0gaXNUcmFuc3Bvc2VSZXF1aXJlZCA/IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbih0cmFuc3Bvc2VkSW5wdXRTaGFwZSwgcmFuayAtIDEpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24oaW5wdXRTaGFwZSwgcmFuayAtIDEpO1xuXG4gICAgICBjb25zdCBvdXRwdXQgPSBjb21wdXRlU29mdG1heChcbiAgICAgICAgICBpbmZlcmVuY2VIYW5kbGVyLCBpc1RyYW5zcG9zZVJlcXVpcmVkID8gdHJhbnNwb3NlZElucHV0cyA6IGlucHV0cywgYXR0cmlidXRlcywgbG9naWNhbFJvd0NvdW50LCBmZWF0dXJlQ291bnQpO1xuXG4gICAgICBpZiAoaXNUcmFuc3Bvc2VSZXF1aXJlZCkge1xuICAgICAgICBjb25zdCByZXZlcnNlZE91dHB1dCA9IHRyYW5zcG9zZShpbmZlcmVuY2VIYW5kbGVyLCBvdXRwdXQsIHRyYW5zcG9zZUF0dHJpYnV0ZSEpO1xuICAgICAgICByZXR1cm4gcmV2ZXJzZWRPdXRwdXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgfVxuICAgIH07XG5cbmNvbnN0IGNvbXB1dGVTb2Z0bWF4ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBTb2Z0bWF4QXR0cmlidXRlcywgbG9naWNhbFJvd0NvdW50OiBudW1iZXIsXG4gICAgIGZlYXR1cmVDb3VudDogbnVtYmVyKTogVGVuc29yW10gPT4ge1xuICAgICAgY29uc3QgY29tcHV0ZU1heFByb2dyYW1JbmZvID1cbiAgICAgICAgICBjcmVhdGVDb21wdXRlTWF4UHJvZ3JhbUluZm8oaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzWzBdLCBsb2dpY2FsUm93Q291bnQsIGZlYXR1cmVDb3VudCwgW2xvZ2ljYWxSb3dDb3VudF0pO1xuICAgICAgY29uc3QgbWF4ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICAgICAgey4uLnNvZnRtYXhDb21wdXRlTWF4UHJvZ3JhbU1ldGFkYXRhLCBjYWNoZUhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksIGdldDogKCkgPT4gY29tcHV0ZU1heFByb2dyYW1JbmZvfSxcbiAgICAgICAgICBpbnB1dHMpO1xuXG4gICAgICBjb25zdCBjb21wdXRlU2NhbGVQcm9ncmFtSW5mbyA9IGNyZWF0ZUNvbXB1dFNjYWxlUHJvZ3JhbUluZm8oXG4gICAgICAgICAgaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzWzBdLCBsb2dpY2FsUm93Q291bnQsIGZlYXR1cmVDb3VudCwgY29tcHV0ZU1heFByb2dyYW1JbmZvLm91dHB1dC5kaW1zLFxuICAgICAgICAgIFtsb2dpY2FsUm93Q291bnRdKTtcbiAgICAgIGNvbnN0IHNjYWxlID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICAgICAgey4uLnNvZnRtYXhDb21wdXRlU2NhbGVQcm9ncmFtTWV0YWRhdGEsIGNhY2hlSGludDogYXR0cmlidXRlcy5jYWNoZUtleSwgZ2V0OiAoKSA9PiBjb21wdXRlU2NhbGVQcm9ncmFtSW5mb30sXG4gICAgICAgICAgW2lucHV0c1swXSwgbWF4XSk7XG5cbiAgICAgIGNvbnN0IHNvZnRNYXhQcm9ncmFtSW5mbyA9IGNyZWF0ZVNvZnRNYXhQcm9ncmFtSW5mbyhcbiAgICAgICAgICBpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHNbMF0sIGxvZ2ljYWxSb3dDb3VudCwgZmVhdHVyZUNvdW50LCBjb21wdXRlTWF4UHJvZ3JhbUluZm8ub3V0cHV0LmRpbXMsXG4gICAgICAgICAgY29tcHV0ZVNjYWxlUHJvZ3JhbUluZm8ub3V0cHV0LmRpbXMpO1xuICAgICAgY29uc3Qgb3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICAgICAgey4uLnNvZnRtYXhQcm9ncmFtTWV0YWRhdGEsIGNhY2hlSGludDogYXR0cmlidXRlcy5jYWNoZUtleSwgZ2V0OiAoKSA9PiBzb2Z0TWF4UHJvZ3JhbUluZm99LFxuICAgICAgICAgIFtpbnB1dHNbMF0sIG1heCwgc2NhbGVdKTtcbiAgICAgIHJldHVybiBbb3V0cHV0XTtcbiAgICB9O1xuXG4vKipcbiAqIENyZWF0ZSBhIHRleHR1cmUgdGhhdCBjb250YWlucyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBlYWNoIG9mIHRoZSAnTicgcm93c1xuICovXG5jb25zdCBjcmVhdGVDb21wdXRlTWF4UHJvZ3JhbUluZm8gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0OiBUZW5zb3IsIGxvZ2ljYWxSb3dDb3VudDogbnVtYmVyLCBmZWF0dXJlQ291bnQ6IG51bWJlcixcbiAgICAgb3V0cHV0U2hhcGU6IG51bWJlcltdKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgW3RleHR1cmVXaWR0aCwgdGV4dHVyZUhlaWdodF0gPVxuICAgICAgICAgIGluZmVyZW5jZUhhbmRsZXIuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGlucHV0LmRpbXMsIFRleHR1cmVUeXBlLnVucGFja2VkKTtcbiAgICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG5cbiAgICAgIGlmIChsb2dpY2FsUm93Q291bnQgPCAxIHx8IGZlYXR1cmVDb3VudCA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2dpY2FsIHJvdyBjb3VudCBOIGFuZCBmZWF0dXJlIGNvdW50IEQgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3V0cHV0U2hhcGUubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGltZW5zaW9uYWxpdHkgb2YgdGhlIG91dHB1dCBzaG91bGQgYmUgMScpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3V0cHV0U2hhcGVbMF0gIT09IGxvZ2ljYWxSb3dDb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYXBlIG9mIHRoZSBvdXRwdXQgc2hvdWxkIGJlIGVxdWFsIHRvIGxvZ2ljYWwgcm93IGNvdW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50WyR7cmFua31dIGluZGljZXMpIHtcbiAgICAgICAgaW50IGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCA9IGluZGljZXNbMF0gKiAke2ZlYXR1cmVDb3VudH07XG5cbiAgICAgICAgZmxvYXQgbWF4ID0gZ2V0Q29sb3JBc0Zsb2F0KCR7Z2xzbC50ZXh0dXJlMkR9KEEsIG9mZnNldFRvQ29vcmRzKGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCwgJHt0ZXh0dXJlV2lkdGh9LFxuICAgICAgICAke3RleHR1cmVIZWlnaHR9ICkpKTtcbiAgICAgICAgZm9yKGludCBpPTE7IGk8JHtmZWF0dXJlQ291bnR9OyArK2kpXG4gICAgICAgIHtcbiAgICAgICAgICBmbG9hdCBjdXJyZW50ID0gZ2V0Q29sb3JBc0Zsb2F0KCR7Z2xzbC50ZXh0dXJlMkR9KEEsIG9mZnNldFRvQ29vcmRzKGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCArIGksXG4gICAgICAgICAgICAke3RleHR1cmVXaWR0aH0sICR7dGV4dHVyZUhlaWdodH0pKSk7XG4gICAgICAgICAgaWYoY3VycmVudCA+IG1heClcbiAgICAgICAgICBtYXggPSBjdXJyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgIH1gO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc29mdG1heENvbXB1dGVNYXhQcm9ncmFtTWV0YWRhdGEsXG4gICAgICAgIG91dHB1dDoge2RpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dC50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWR9LFxuICAgICAgICBzaGFkZXJTb3VyY2VcbiAgICAgIH07XG4gICAgfTtcblxuLyoqXG4gKiBDcmVhdGUgYSB0ZXh0dXJlIHRoYXQgY29udGFpbnMgdGhlIG5vcm1hbGl6YXRpb24gZmFjdG9yIGZvciBlYWNoIG9mIHRoZSAnTicgcm93c1xuICovXG5jb25zdCBjcmVhdGVDb21wdXRTY2FsZVByb2dyYW1JbmZvID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dDogVGVuc29yLCBsb2dpY2FsUm93Q291bnQ6IG51bWJlciwgZmVhdHVyZUNvdW50OiBudW1iZXIsXG4gICAgIG1heEVsZW1lbnRQZXJMb2dpY2FsUm93OiByZWFkb25seSBudW1iZXJbXSwgb3V0cHV0U2hhcGU6IG51bWJlcltdKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgW3RleHR1cmVXaWR0aCwgdGV4dHVyZUhlaWdodF0gPVxuICAgICAgICAgIGluZmVyZW5jZUhhbmRsZXIuY2FsY3VsYXRlVGV4dHVyZVdpZHRoQW5kSGVpZ2h0KGlucHV0LmRpbXMsIFRleHR1cmVUeXBlLnVucGFja2VkKTtcbiAgICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG5cbiAgICAgIGlmIChsb2dpY2FsUm93Q291bnQgPCAxIHx8IGZlYXR1cmVDb3VudCA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2dpY2FsIHJvdyBjb3VudCBOIGFuZCBmZWF0dXJlIGNvdW50IEQgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3V0cHV0U2hhcGUubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGltZW5zaW9uYWxpdHkgb2YgdGhlIG91dHB1dCBzaG91bGQgYmUgMScpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3V0cHV0U2hhcGVbMF0gIT09IGxvZ2ljYWxSb3dDb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYXBlIG9mIHRoZSBvdXRwdXQgc2hvdWxkIGJlIGVxdWFsIHRvIGxvZ2ljYWwgcm93IGNvdW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXhFbGVtZW50UGVyTG9naWNhbFJvdy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb25hbGl0eSBvZiB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdHMgc2hvdWxkIGJlIDEnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1heEVsZW1lbnRQZXJMb2dpY2FsUm93WzBdICE9PSBsb2dpY2FsUm93Q291bnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFwZSBvZiB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdHMgc2hvdWxkIGJlIGVxdWFsIHRvIGxvZ2ljYWwgcm93IGNvdW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIGZsb2F0IHByb2Nlc3MoaW50WyR7cmFua31dIGluZGljZXMpIHtcbiAgICAgICAgaW50IGxvZ2ljYWxfcm93X3N0YXJ0X29mZnNldCA9IGluZGljZXNbMF0gKiAke2ZlYXR1cmVDb3VudH07XG5cbiAgICAgICAgZmxvYXQgbm9ybV9mYWN0b3IgPSAwLjA7XG4gICAgICAgIGZsb2F0IG1heCA9IF9NYXgoaW5kaWNlcyk7XG4gICAgICAgIGZvcihpbnQgaT0wOyBpPCR7ZmVhdHVyZUNvdW50fTsgKytpKVxuICAgICAgICB7XG4gICAgICAgICAgbm9ybV9mYWN0b3IgKz0gZXhwKGdldENvbG9yQXNGbG9hdCgke2dsc2wudGV4dHVyZTJEfShBLCBvZmZzZXRUb0Nvb3Jkcyhsb2dpY2FsX3Jvd19zdGFydF9vZmZzZXQgKyBpLFxuICAgICAgICAgICAgJHt0ZXh0dXJlV2lkdGh9LCAke3RleHR1cmVIZWlnaHR9KSkpIC0gbWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtX2ZhY3RvcjtcbiAgICAgIH1gO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc29mdG1heENvbXB1dGVTY2FsZVByb2dyYW1NZXRhZGF0YSxcbiAgICAgICAgb3V0cHV0OiB7ZGltczogb3V0cHV0U2hhcGUsIHR5cGU6IGlucHV0LnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgICAgIHNoYWRlclNvdXJjZVxuICAgICAgfTtcbiAgICB9O1xuXG5jb25zdCBjcmVhdGVTb2Z0TWF4UHJvZ3JhbUluZm8gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0OiBUZW5zb3IsIGxvZ2ljYWxSb3dDb3VudDogbnVtYmVyLCBmZWF0dXJlQ291bnQ6IG51bWJlcixcbiAgICAgbWF4RWxlbWVudFBlckxvZ2ljYWxSb3c6IHJlYWRvbmx5IG51bWJlcltdLCBub3JtYWxpemF0aW9uUGVyTG9naWNhbFJvdzogcmVhZG9ubHkgbnVtYmVyW10pOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCBbdGV4dHVyZVdpZHRoLCB0ZXh0dXJlSGVpZ2h0XSA9XG4gICAgICAgICAgaW5mZXJlbmNlSGFuZGxlci5jYWxjdWxhdGVUZXh0dXJlV2lkdGhBbmRIZWlnaHQoaW5wdXQuZGltcywgVGV4dHVyZVR5cGUudW5wYWNrZWQpO1xuICAgICAgY29uc3QgcmFuayA9IGlucHV0LmRpbXMubGVuZ3RoO1xuXG4gICAgICBpZiAobG9naWNhbFJvd0NvdW50IDwgMSB8fCBmZWF0dXJlQ291bnQgPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTG9naWNhbCByb3cgY291bnQgTiBhbmQgZmVhdHVyZSBjb3VudCBEIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1heEVsZW1lbnRQZXJMb2dpY2FsUm93Lmxlbmd0aCAhPT0gMSB8fCBub3JtYWxpemF0aW9uUGVyTG9naWNhbFJvdy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb25hbGl0eSBvZiB0aGUgaW50ZXJtZWRpYXRlIHJlc3VsdHMgc2hvdWxkIGJlIDEnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1heEVsZW1lbnRQZXJMb2dpY2FsUm93WzBdICE9PSBsb2dpY2FsUm93Q291bnQgfHwgbm9ybWFsaXphdGlvblBlckxvZ2ljYWxSb3dbMF0gIT09IGxvZ2ljYWxSb3dDb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYXBlIG9mIHRoZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyBzaG91bGQgYmUgZXF1YWwgdG8gbG9naWNhbCByb3cgY291bnQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnRbJHtyYW5rfV0gaW5kaWNlcykge1xuXG4gICAgICAvLyBnZXQgb2Zmc2V0IG9mIGN1cnJlbnQgbG9naWNhbCB0ZW5zb3IgaW5kZXggZnJvbSB0aGUgMi1EIHRleHR1cmUgY29vcmRpbmF0ZXMgKFRleENvb3JkcylcbiAgICAgIGludCBvZmZzZXQgPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7dGV4dHVyZVdpZHRofSwgJHt0ZXh0dXJlSGVpZ2h0fSk7XG5cbiAgICAgIC8vZGV0ZXJtaW5lIHRoZSBsb2dpY2FsIHJvdyBmb3IgdGhpcyBpbmRleFxuICAgICAgaW50IGxvZ2ljYWxfcm93X2luZGV4WzFdO1xuICAgICAgbG9naWNhbF9yb3dfaW5kZXhbMF0gPSBvZmZzZXQgLyAke2ZlYXR1cmVDb3VudH07XG5cbiAgICAgIGZsb2F0IG5vcm1fZmFjdG9yID0gX05vcm0obG9naWNhbF9yb3dfaW5kZXgpO1xuXG4gICAgICAvLyBhdm9pZCBwb3NzaWJsZSBkaXZpc2lvbiBieSAwXG4gICAgICAvLyBpZiBub3JtX2ZhY29yIGlzIDAsIGFsbCBlbGVtZW50cyBhcmUgemVyb1xuICAgICAgLy8gaWYgc28sIHJldHVybiAwXG4gICAgICBpZihub3JtX2ZhY3RvciA9PSAwLjApXG4gICAgICAgIHJldHVybiAwLjA7XG5cbiAgICAgIHJldHVybiBleHAoX0EoaW5kaWNlcykgLSBfTWF4KGxvZ2ljYWxfcm93X2luZGV4KSkgLyBub3JtX2ZhY3RvcjtcbiAgICB9YDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnNvZnRtYXhQcm9ncmFtTWV0YWRhdGEsXG4gICAgICAgIG91dHB1dDoge2RpbXM6IGlucHV0LmRpbXMsIHR5cGU6IGlucHV0LnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgICAgIHNoYWRlclNvdXJjZVxuICAgICAgfTtcbiAgICB9O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NvZnRtYXggcmVxdWlyZXMgMSBpbnB1dC4nKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0MzInICYmIGlucHV0c1swXS50eXBlICE9PSAnZmxvYXQ2NCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZScpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi8uLi8uLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHtPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9ufSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbCwgU3BsaXRVdGlsfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBUZXh0dXJlVHlwZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNwbGl0QXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGF4aXM6IG51bWJlcjtcbiAgcmVhZG9ubHkgc3BsaXQ6IG51bWJlcltdO1xuICByZWFkb25seSBudW1PdXRwdXRzOiBudW1iZXI7XG59XG5cbmNvbnN0IHNwbGl0UHJvZ3JhbU1ldGFkYXRhID0ge1xuICBuYW1lOiAnU3BsaXQnLFxuICBpbnB1dE5hbWVzOiBbJ0EnXSxcbiAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbn07XG5cbmV4cG9ydCBjb25zdCBzcGxpdDogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxTcGxpdEF0dHJpYnV0ZXM+ID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBhdHRyaWJ1dGVzOiBTcGxpdEF0dHJpYnV0ZXMpOiBUZW5zb3JbXSA9PiB7XG4gICAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuXG4gICAgICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuICAgICAgY29uc3QgY291bnQgPSBnZXRQcm9ncmFtQ291bnQoaW5mZXJlbmNlSGFuZGxlciwgaW5wdXRzLCBheGlzLCBhdHRyaWJ1dGVzKTtcbiAgICAgIGNvbnN0IG91dHB1dDogVGVuc29yW10gPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICBvdXRwdXQucHVzaChpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLi4uc3BsaXRQcm9ncmFtTWV0YWRhdGEsXG4gICAgICAgICAgICAgIGNhY2hlSGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX07JHtpfWAsXG4gICAgICAgICAgICAgIGdldDogKCkgPT4gY3JlYXRlU3BsaXRQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHNbMF0sIGF0dHJpYnV0ZXMsIGF4aXMsIGkpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5wdXRzKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlU3BsaXRBdHRyaWJ1dGVzOiBPcGVyYXRvckluaXRpYWxpemF0aW9uPFNwbGl0QXR0cmlidXRlcz4gPSAobm9kZTogR3JhcGguTm9kZSk6IFNwbGl0QXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGF4aXMgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0SW50KCdheGlzJywgMCk7XG4gIGNvbnN0IHNwbGl0ID0gbm9kZS5hdHRyaWJ1dGVzLmdldEludHMoJ3NwbGl0JywgW10pO1xuICBjb25zdCBudW1PdXRwdXRzID0gbm9kZS5vdXRwdXRzLmxlbmd0aDtcbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7YXhpcywgc3BsaXQsIG51bU91dHB1dHN9KTtcbn07XG5cbmNvbnN0IGdldFByb2dyYW1Db3VudCA9XG4gICAgKF9pbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF4aXM6IG51bWJlciwgYXR0cmlidXRlczogU3BsaXRBdHRyaWJ1dGVzKTogbnVtYmVyID0+IHtcbiAgICAgIGNvbnN0IFssIG9mZnNldHNdID0gU3BsaXRVdGlsLnNwbGl0U2hhcGUoaW5wdXRzWzBdLmRpbXMsIGF4aXMsIGF0dHJpYnV0ZXMuc3BsaXQsIGF0dHJpYnV0ZXMubnVtT3V0cHV0cyk7XG4gICAgICByZXR1cm4gb2Zmc2V0cy5sZW5ndGg7XG4gICAgfTtcblxuY29uc3QgY3JlYXRlU3BsaXRQcm9ncmFtSW5mbyA9XG4gICAgKF9pbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0OiBUZW5zb3IsIGF0dHJpYnV0ZXM6IFNwbGl0QXR0cmlidXRlcywgYXhpczogbnVtYmVyLCBpbmRleDogbnVtYmVyKTpcbiAgICAgICAgUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgICAgIGNvbnN0IFtzaGFwZXMsIG9mZnNldHNdID0gU3BsaXRVdGlsLnNwbGl0U2hhcGUoaW5wdXQuZGltcywgYXhpcywgYXR0cmlidXRlcy5zcGxpdCwgYXR0cmlidXRlcy5udW1PdXRwdXRzKTtcbiAgICAgICAgICBjb25zdCBvZmZzZXQgPSBvZmZzZXRzW2luZGV4XTtcbiAgICAgICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IHNoYXBlc1tpbmRleF07XG4gICAgICAgICAgY29uc3QgcmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBzaGFkZXJTb3VyY2UgPSBgXG4gICAgICBmbG9hdCBwcm9jZXNzKGludCBpbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgIGluZGljZXNbJHtheGlzfV0gKz0gJHtvZmZzZXR9O1xuICAgICAgICByZXR1cm4gX0EoaW5kaWNlcyk7XG4gICAgICB9XG4gICAgYDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3BsaXRQcm9ncmFtTWV0YWRhdGEsXG4gICAgICAgICAgICBjYWNoZUhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9OiR7aW5kZXh9YCxcbiAgICAgICAgICAgIG91dHB1dDoge2RpbXM6IG91dHB1dFNoYXBlLCB0eXBlOiBpbnB1dC50eXBlLCB0ZXh0dXJlVHlwZTogVGV4dHVyZVR5cGUudW5wYWNrZWR9LFxuICAgICAgICAgICAgc2hhZGVyU291cmNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTcGxpdCByZXF1aXJlcyBvbmUgaW5wdXQuJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09ICdpbnQ4JyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ3VpbnQ4JyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ2ludDE2JyAmJlxuICAgICAgaW5wdXRzWzBdLnR5cGUgIT09ICd1aW50MTYnICYmIGlucHV0c1swXS50eXBlICE9PSAnaW50MzInICYmIGlucHV0c1swXS50eXBlICE9PSAndWludDMyJyAmJlxuICAgICAgaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0NjQnICYmIGlucHV0c1swXS50eXBlICE9PSAnYm9vbCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi4vLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHtPcGVyYXRvckltcGxlbWVudGF0aW9uLCBPcGVyYXRvckluaXRpYWxpemF0aW9ufSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuXG5leHBvcnQgY29uc3Qgc3F1ZWV6ZTogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxudW1iZXJbXT4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF4ZXM6IG51bWJlcltdKTogVGVuc29yW10gPT4ge1xuICAgICAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gU2hhcGVVdGlsLnNxdWVlemVTaGFwZShpbnB1dHNbMF0uZGltcywgYXhlcyk7XG4gICAgICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJlc2hhcGVVbnBhY2tlZChpbnB1dHNbMF0sIG91dHB1dFNoYXBlKTtcbiAgICAgIHJldHVybiBbb3V0cHV0XTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3Qgc3F1ZWV6ZVYxMyA9IChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzVjEzKGlucHV0cyk7XG4gIHJldHVybiBzcXVlZXplKGluZmVyZW5jZUhhbmRsZXIsIFtpbnB1dHNbMF1dLCBBcnJheS5mcm9tKGlucHV0c1sxXS5pbnRlZ2VyRGF0YSkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlU3F1ZWV6ZUF0dHJpYnV0ZXM6IE9wZXJhdG9ySW5pdGlhbGl6YXRpb248bnVtYmVyW10+ID0gKG5vZGU6IEdyYXBoLk5vZGUpOiBudW1iZXJbXSA9PlxuICAgIG5vZGUuYXR0cmlidXRlcy5nZXRJbnRzKCdheGVzJyk7XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU3F1ZWV6ZSByZXF1aXJlcyAxIGlucHV0LicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS50eXBlID09PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnB1dCB0ZW5zb3IgdHlwZXMuJyk7XG4gIH1cbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzVjEzID0gKGlucHV0czogVGVuc29yW10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignU3F1ZWV6ZSByZXF1aXJlcyAyIGlucHV0cy4nKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMV0udHlwZSAhPT0gJ2ludDMyJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlLicpO1xuICB9XG59OyIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge2dldEdsc2x9IGZyb20gJy4uL2dsc2wtc291cmNlJztcbmltcG9ydCB7V2ViR0xJbmZlcmVuY2VIYW5kbGVyfSBmcm9tICcuLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBQcm9ncmFtTWV0YWRhdGEsIFRleHR1cmVUeXBlfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBzdW0gPSAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuXG4gIGNvbnN0IHN1bVByb2dyYW1NZXRhZGF0YSA9IHtcbiAgICBuYW1lOiAnU3VtJyxcbiAgICBpbnB1dE5hbWVzOiBpbnB1dHMubWFwKChfdiwgaSkgPT4gYFgke2l9YCksXG4gICAgaW5wdXRUeXBlczogbmV3IEFycmF5KGlucHV0cy5sZW5ndGgpLmZpbGwoVGV4dHVyZVR5cGUudW5wYWNrZWQpXG4gIH07XG5cbiAgY29uc3Qgb3V0cHV0ID0gaW5mZXJlbmNlSGFuZGxlci5ydW4oXG4gICAgICB7Li4uc3VtUHJvZ3JhbU1ldGFkYXRhLCBnZXQ6ICgpID0+IGNyZWF0ZVN1bVByb2dyYW1JbmZvKGluZmVyZW5jZUhhbmRsZXIsIGlucHV0cywgc3VtUHJvZ3JhbU1ldGFkYXRhKX0sIGlucHV0cyk7XG4gIHJldHVybiBbb3V0cHV0XTtcbn07XG5cbmNvbnN0IGNyZWF0ZVN1bVByb2dyYW1JbmZvID1cbiAgICAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdLCBzdW1Qcm9ncmFtTWV0YWRhdGE6IFByb2dyYW1NZXRhZGF0YSk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKGluZmVyZW5jZUhhbmRsZXIuc2Vzc2lvbi5iYWNrZW5kLmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgICAgIGNvbnN0IHN1bUxpbmUgPSBpbnB1dHMubWFwKChfdiwgaSkgPT4gYCR7Z2xzbC50ZXh0dXJlMkR9KFgke2l9LFRleENvb3JkcylgKS5qb2luKCcgKyAnKTtcbiAgICAgIGNvbnN0IHNoYWRlclNvdXJjZSA9IGBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjNCByZXN1bHQgPSAke3N1bUxpbmV9O1xuICAgICAgICAke2dsc2wub3V0cHV0fSA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICBgO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3VtUHJvZ3JhbU1ldGFkYXRhLFxuICAgICAgICBvdXRwdXQ6IHtkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgICAgIGhhc01haW46IHRydWUsXG4gICAgICAgIHNoYWRlclNvdXJjZVxuICAgICAgfTtcbiAgICB9O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1bSByZXF1aXJlcyBpbnB1dHMuJyk7XG4gIH1cblxuICBjb25zdCBsZW5ndGggPSBpbnB1dHNbMF0uZGltcy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxlbmd0aCAhPT0gaW5wdXRzW2ldLmRpbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHNoYXBlcyBhcmUgbWlzbWF0Y2hlZC4nKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAoaW5wdXRzWzBdLmRpbXNbal0gIT09IGlucHV0c1tpXS5kaW1zW2pdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgc2hhcGVzIGFyZSBub3QgbWF0Y2hlZC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09ICdmbG9hdDMyJyAmJiBpbnB1dHNbMF0udHlwZSAhPT0gJ2Zsb2F0NjQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHR5cGUuJyk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBpbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaW5wdXRzWzBdLnR5cGUgIT09IGlucHV0c1tpXS50eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHR5cGVzIGFyZSBub3QgbWF0Y2hlZC4nKTtcbiAgICB9XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7TlVNQkVSX1RZUEVTfSBmcm9tICcuLi8uLi8uLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi4vaW5mZXJlbmNlLWhhbmRsZXInO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUHJvZ3JhbU1ldGFkYXRhLCBUZXh0dXJlVHlwZX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgdGlsZSA9IChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10pOiBUZW5zb3JbXSA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGlucHV0cyk7XG5cbiAgY29uc3QgdGlsZVByb2dyYW1NZXRhZGF0YSA9IHtcbiAgICBuYW1lOiAnVGlsZScsXG4gICAgaW5wdXROYW1lczogWydBJ10sXG4gICAgaW5wdXRUeXBlczogW1RleHR1cmVUeXBlLnVucGFja2VkXSxcbiAgfTtcblxuICBjb25zdCBvdXRwdXQgPSBpbmZlcmVuY2VIYW5kbGVyLnJ1bihcbiAgICAgIHsuLi50aWxlUHJvZ3JhbU1ldGFkYXRhLCBnZXQ6ICgpID0+IGNyZWF0ZVRpbGVQcm9ncmFtSW5mbyhpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHMsIHRpbGVQcm9ncmFtTWV0YWRhdGEpfSxcbiAgICAgIGlucHV0cyk7XG4gIHJldHVybiBbb3V0cHV0XTtcbn07XG5cbmNvbnN0IGNyZWF0ZVRpbGVQcm9ncmFtSW5mbyA9XG4gICAgKF9oYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIHRpbGVQcm9ncmFtTWV0YWRhdGE6IFByb2dyYW1NZXRhZGF0YSk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBuZXcgQXJyYXkoaW5wdXRTaGFwZS5sZW5ndGgpO1xuXG4gICAgICBjb25zdCB0aWxlT3BzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dHB1dFNoYXBlW2ldID0gaW5wdXRTaGFwZVtpXSAqIGlucHV0c1sxXS5udW1iZXJEYXRhW2ldO1xuICAgICAgICB0aWxlT3BzLnB1c2goYGlucHV0SWR4WyR7aX1dID0gaW50KG1vZChmbG9hdChvdXRwdXRJZHhbJHtpfV0pLCAke2lucHV0U2hhcGVbaV19LikpO2ApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICAgICAgY29uc3Qgc2hhZGVyU291cmNlID0gYFxuICAgICAgZmxvYXQgcHJvY2VzcyhpbnQgb3V0cHV0SWR4WyR7cmFua31dKSB7XG4gICAgICAgIGludCBpbnB1dElkeFske3Jhbmt9XTtcbiAgICAgICAgJHt0aWxlT3BzLmpvaW4oJ1xcbicpfVxuICAgICAgICByZXR1cm4gX0EoaW5wdXRJZHgpO1xuICAgICAgfVxuICAgIGA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi50aWxlUHJvZ3JhbU1ldGFkYXRhLFxuICAgICAgICBvdXRwdXQ6IHtkaW1zOiBvdXRwdXRTaGFwZSwgdHlwZTogaW5wdXRzWzBdLnR5cGUsIHRleHR1cmVUeXBlOiBUZXh0dXJlVHlwZS51bnBhY2tlZH0sXG4gICAgICAgIHNoYWRlclNvdXJjZVxuICAgICAgfTtcbiAgICB9O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpbGUgcmVxdWlyZXMgMiBpbnB1dC4nKTtcbiAgfVxuICBpZiAoaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2Vjb25kIGlucHV0IHNoYXBlIG11c3QgMSBkaW1lbnNpb24uJyk7XG4gIH1cbiAgaWYgKGlucHV0c1sxXS5kaW1zWzBdICE9PSBpbnB1dHNbMF0uZGltcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgc2hhcGUuJyk7XG4gIH1cbiAgaWYgKE5VTUJFUl9UWVBFUy5pbmRleE9mKGlucHV0c1swXS50eXBlKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxuICBpZiAoaW5wdXRzWzFdLnR5cGUgIT09ICdpbnQzMicgJiYgaW5wdXRzWzFdLnR5cGUgIT09ICdpbnQxNicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVwZWF0IHR5cGUuJyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7R3JhcGh9IGZyb20gJy4uLy4uLy4uL2dyYXBoJztcbmltcG9ydCB7T3BlcmF0b3JJbXBsZW1lbnRhdGlvbiwgT3BlcmF0b3JJbml0aWFsaXphdGlvbn0gZnJvbSAnLi4vLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtXZWJHTEluZmVyZW5jZUhhbmRsZXJ9IGZyb20gJy4uL2luZmVyZW5jZS1oYW5kbGVyJztcblxuZXhwb3J0IGNvbnN0IHVuc3F1ZWV6ZTogT3BlcmF0b3JJbXBsZW1lbnRhdGlvbjxudW1iZXJbXT4gPVxuICAgIChpbmZlcmVuY2VIYW5kbGVyOiBXZWJHTEluZmVyZW5jZUhhbmRsZXIsIGlucHV0czogVGVuc29yW10sIGF4ZXM6IG51bWJlcltdKTogVGVuc29yW10gPT4ge1xuICAgICAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gU2hhcGVVdGlsLnVuc3F1ZWV6ZVNoYXBlKGlucHV0c1swXS5kaW1zLCBheGVzKTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGluZmVyZW5jZUhhbmRsZXIucmVzaGFwZVVucGFja2VkKGlucHV0c1swXSwgb3V0cHV0U2hhcGUpO1xuICAgICAgcmV0dXJuIFtvdXRwdXRdO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCB1bnNxdWVlemVWMTMgPSAoaW5mZXJlbmNlSGFuZGxlcjogV2ViR0xJbmZlcmVuY2VIYW5kbGVyLCBpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yW10gPT4ge1xuICB2YWxpZGF0ZUlucHV0c1YxMyhpbnB1dHMpO1xuICByZXR1cm4gdW5zcXVlZXplKGluZmVyZW5jZUhhbmRsZXIsIFtpbnB1dHNbMF1dLCBBcnJheS5mcm9tKGlucHV0c1sxXS5pbnRlZ2VyRGF0YSkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlVW5zcXVlZXplQXR0cmlidXRlczogT3BlcmF0b3JJbml0aWFsaXphdGlvbjxudW1iZXJbXT4gPSAobm9kZTogR3JhcGguTm9kZSk6IG51bWJlcltdID0+XG4gICAgbm9kZS5hdHRyaWJ1dGVzLmdldEludHMoJ2F4ZXMnKTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiBUZW5zb3JbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnNxdWVlemUgcmVxdWlyZXMgMSBpbnB1dC4nKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5wdXQgdGVuc29yIHR5cGVzLicpO1xuICB9XG59O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0c1YxMyA9IChpbnB1dHM6IFRlbnNvcltdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3F1ZWV6ZSByZXF1aXJlcyAyIGlucHV0cy4nKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMV0udHlwZSAhPT0gJ2ludDMyJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlLicpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge09wU2V0fSBmcm9tICcuLi8uLi9vcHNldCc7XG5cbmltcG9ydCB7YmF0Y2hOb3JtYWxpemF0aW9uLCBwYXJzZUJhdGNoTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXN9IGZyb20gJy4vb3BzL2JhdGNoLW5vcm1hbGl6YXRpb24nO1xuaW1wb3J0ICogYXMgYmluYXJ5T3BzIGZyb20gJy4vb3BzL2JpbmFyeS1vcCc7XG5pbXBvcnQge2Nhc3QsIHBhcnNlQ2FzdEF0dHJpYnV0ZXN9IGZyb20gJy4vb3BzL2Nhc3QnO1xuaW1wb3J0IHtjb25jYXQsIHBhcnNlQ29uY2F0QXR0cmlidXRlc30gZnJvbSAnLi9vcHMvY29uY2F0JztcbmltcG9ydCB7Y29udiwgcGFyc2VDb252QXR0cmlidXRlc30gZnJvbSAnLi9vcHMvY29udic7XG5pbXBvcnQge2NvbnZUcmFuc3Bvc2UsIHBhcnNlQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXN9IGZyb20gJy4vb3BzL2NvbnYtdHJhbnNwb3NlJztcbmltcG9ydCB7ZGVwdGhUb1NwYWNlLCBwYXJzZURlcHRoVG9TcGFjZUF0dHJpYnV0ZXN9IGZyb20gJy4vb3BzL2RlcHRoLXRvLXNwYWNlJztcbmltcG9ydCB7ZmxhdHRlbiwgcGFyc2VGbGF0dGVuQXR0cmlidXRlc30gZnJvbSAnLi9vcHMvZmxhdHRlbic7XG5pbXBvcnQge2dhdGhlciwgcGFyc2VHYXRoZXJBdHRyaWJ1dGVzfSBmcm9tICcuL29wcy9nYXRoZXInO1xuaW1wb3J0IHtnZW1tLCBwYXJzZUdlbW1BdHRyaWJ1dGVzVjExLCBwYXJzZUdlbW1BdHRyaWJ1dGVzVjd9IGZyb20gJy4vb3BzL2dlbW0nO1xuaW1wb3J0IHtpbWFnZVNjYWxlciwgcGFyc2VJbWFnZVNjYWxlckF0dHJpYnV0ZXN9IGZyb20gJy4vb3BzL2ltYWdlLXNjYWxlcic7XG5pbXBvcnQge2luc3RhbmNlTm9ybWFsaXphdGlvbiwgcGFyc2VJbnN0YW5jZU5vcm1hbGl6YXRpb25BdHRyaWJ1dGVzfSBmcm9tICcuL29wcy9pbnN0YW5jZS1ub3JtYWxpemF0aW9uJztcbmltcG9ydCB7bHJuLCBwYXJzZUxybkF0dHJpYnV0ZXN9IGZyb20gJy4vb3BzL2xybic7XG5pbXBvcnQge21hdE11bCwgcGFyc2VNYXRNdWxBdHRyaWJ1dGVzfSBmcm9tICcuL29wcy9tYXRtdWwnO1xuaW1wb3J0IHtwYWRWMTEsIHBhZFYyLCBwYXJzZVBhZEF0dHJpYnV0ZXNWMTEsIHBhcnNlUGFkQXR0cmlidXRlc1YyfSBmcm9tICcuL29wcy9wYWQnO1xuaW1wb3J0IHthdmVyYWdlUG9vbCwgZ2xvYmFsQXZlcmFnZVBvb2wsIGdsb2JhbE1heFBvb2wsIG1heFBvb2wsIHBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzLCBwYXJzZUdsb2JhbEF2ZXJhZ2VQb29sQXR0cmlidXRlcywgcGFyc2VNYXhQb29sQXR0cmlidXRlc30gZnJvbSAnLi9vcHMvcG9vbCc7XG5pbXBvcnQge3BhcnNlUmVkdWNlQXR0cmlidXRlcywgcmVkdWNlTG9nU3VtLCByZWR1Y2VMb2dTdW1TcXVhcmUsIHJlZHVjZU1heCwgcmVkdWNlTWVhbiwgcmVkdWNlTWluLCByZWR1Y2VQcm9kLCByZWR1Y2VTdW19IGZyb20gJy4vb3BzL3JlZHVjZSc7XG5pbXBvcnQge3Jlc2hhcGV9IGZyb20gJy4vb3BzL3Jlc2hhcGUnO1xuaW1wb3J0IHtwYXJzZVJlc2l6ZUF0dHJpYnV0ZXNWMTAsIHBhcnNlUmVzaXplQXR0cmlidXRlc1YxMSwgcmVzaXplfSBmcm9tICcuL29wcy9yZXNpemUtcGFja2VkJztcbmltcG9ydCB7c2hhcGV9IGZyb20gJy4vb3BzL3NoYXBlJztcbmltcG9ydCB7cGFyc2VTbGljZUF0dHJpYnV0ZXMsIHNsaWNlLCBzbGljZVYxMH0gZnJvbSAnLi9vcHMvc2xpY2UnO1xuaW1wb3J0IHtwYXJzZVNvZnRtYXhBdHRyaWJ1dGVzLCBwYXJzZVNvZnRtYXhBdHRyaWJ1dGVzVjEzLCBzb2Z0bWF4LCBzb2Z0bWF4VjEzfSBmcm9tICcuL29wcy9zb2Z0bWF4JztcbmltcG9ydCB7cGFyc2VTcGxpdEF0dHJpYnV0ZXMsIHNwbGl0fSBmcm9tICcuL29wcy9zcGxpdCc7XG5pbXBvcnQge3BhcnNlU3F1ZWV6ZUF0dHJpYnV0ZXMsIHNxdWVlemUsIHNxdWVlemVWMTN9IGZyb20gJy4vb3BzL3NxdWVlemUnO1xuaW1wb3J0IHtzdW19IGZyb20gJy4vb3BzL3N1bSc7XG5pbXBvcnQge3RpbGV9IGZyb20gJy4vb3BzL3RpbGUnO1xuaW1wb3J0IHtwYXJzZVRyYW5zcG9zZUF0dHJpYnV0ZXMsIHRyYW5zcG9zZX0gZnJvbSAnLi9vcHMvdHJhbnNwb3NlJztcbmltcG9ydCAqIGFzIHVuYXJ5T3BzIGZyb20gJy4vb3BzL3VuYXJ5LW9wJztcbmltcG9ydCB7cGFyc2VVbnNxdWVlemVBdHRyaWJ1dGVzLCB1bnNxdWVlemUsIHVuc3F1ZWV6ZVYxM30gZnJvbSAnLi9vcHMvdW5zcXVlZXplJztcbmltcG9ydCB7cGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWNywgcGFyc2VVcHNhbXBsZUF0dHJpYnV0ZXNWOSwgdXBzYW1wbGV9IGZyb20gJy4vb3BzL3Vwc2FtcGxlJztcblxuZXhwb3J0IGNvbnN0IFdFQkdMX09QX1JFU09MVkVfUlVMRVM6IHJlYWRvbmx5IE9wU2V0LlJlc29sdmVSdWxlW10gPSBbXG4gIFsnQWJzJywgJycsICc2KycsIHVuYXJ5T3BzLmFic10sXG4gIFsnQWNvcycsICcnLCAnNysnLCB1bmFyeU9wcy5hY29zXSxcbiAgWydBZGQnLCAnJywgJzcrJywgYmluYXJ5T3BzLmFkZF0sXG4gIFsnQW5kJywgJycsICc3KycsIGJpbmFyeU9wcy5hbmRdLFxuICBbJ0FzaW4nLCAnJywgJzcrJywgdW5hcnlPcHMuYXNpbl0sXG4gIFsnQXRhbicsICcnLCAnNysnLCB1bmFyeU9wcy5hdGFuXSxcbiAgLy8gVE9ETzogc3VwcG9ydCBuZXcgYXR0cmlidXRlcyBmb3IgQXZlcmFnZVBvb2wtMTBcbiAgWydBdmVyYWdlUG9vbCcsICcnLCAnNysnLCBhdmVyYWdlUG9vbCwgcGFyc2VBdmVyYWdlUG9vbEF0dHJpYnV0ZXNdLFxuICBbJ0JhdGNoTm9ybWFsaXphdGlvbicsICcnLCAnNysnLCBiYXRjaE5vcm1hbGl6YXRpb24sIHBhcnNlQmF0Y2hOb3JtYWxpemF0aW9uQXR0cmlidXRlc10sXG4gIFsnQ2FzdCcsICcnLCAnNisnLCBjYXN0LCBwYXJzZUNhc3RBdHRyaWJ1dGVzXSxcbiAgWydDZWlsJywgJycsICc2KycsIHVuYXJ5T3BzLmNlaWxdLFxuICBbJ0NsaXAnLCAnJywgJzYtMTAnLCB1bmFyeU9wcy5jbGlwLCB1bmFyeU9wcy5wYXJzZUNsaXBBdHRyaWJ1dGVzXSxcbiAgWydDbGlwJywgJycsICcxMSsnLCB1bmFyeU9wcy5jbGlwVjExXSxcbiAgWydDb25jYXQnLCAnJywgJzQrJywgY29uY2F0LCBwYXJzZUNvbmNhdEF0dHJpYnV0ZXNdLFxuICBbJ0NvbnYnLCAnJywgJzErJywgY29udiwgcGFyc2VDb252QXR0cmlidXRlc10sXG4gIFsnQ29udlRyYW5zcG9zZScsICcnLCAnMSsnLCBjb252VHJhbnNwb3NlLCBwYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzXSxcbiAgWydDb3MnLCAnJywgJzcrJywgdW5hcnlPcHMuY29zXSxcbiAgWydEaXYnLCAnJywgJzcrJywgYmluYXJ5T3BzLmRpdl0sXG4gIFsnRHJvcG91dCcsICcnLCAnNysnLCB1bmFyeU9wcy5pZGVudGl0eV0sXG4gIFsnRGVwdGhUb1NwYWNlJywgJycsICcxKycsIGRlcHRoVG9TcGFjZSwgcGFyc2VEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzXSxcbiAgWydFcXVhbCcsICcnLCAnNysnLCBiaW5hcnlPcHMuZXF1YWxdLFxuICBbJ0VsdScsICcnLCAnNisnLCB1bmFyeU9wcy5lbHUsIHVuYXJ5T3BzLnBhcnNlRWx1QXR0cmlidXRlc10sXG4gIFsnRXhwJywgJycsICc2KycsIHVuYXJ5T3BzLmV4cF0sXG4gIFsnRmxhdHRlbicsICcnLCAnMSsnLCBmbGF0dGVuLCBwYXJzZUZsYXR0ZW5BdHRyaWJ1dGVzXSxcbiAgWydGbG9vcicsICcnLCAnNisnLCB1bmFyeU9wcy5mbG9vcl0sXG4gIFsnRnVzZWRDb252JywgJ2NvbS5taWNyb3NvZnQnLCAnMSsnLCBjb252LCBwYXJzZUNvbnZBdHRyaWJ1dGVzXSxcbiAgWydHYXRoZXInLCAnJywgJzErJywgZ2F0aGVyLCBwYXJzZUdhdGhlckF0dHJpYnV0ZXNdLFxuICBbJ0dlbW0nLCAnJywgJzctMTAnLCBnZW1tLCBwYXJzZUdlbW1BdHRyaWJ1dGVzVjddLFxuICBbJ0dlbW0nLCAnJywgJzExKycsIGdlbW0sIHBhcnNlR2VtbUF0dHJpYnV0ZXNWMTFdLFxuICBbJ0dsb2JhbEF2ZXJhZ2VQb29sJywgJycsICcxKycsIGdsb2JhbEF2ZXJhZ2VQb29sLCBwYXJzZUdsb2JhbEF2ZXJhZ2VQb29sQXR0cmlidXRlc10sXG4gIFsnR2xvYmFsTWF4UG9vbCcsICcnLCAnMSsnLCBnbG9iYWxNYXhQb29sXSxcbiAgWydHcmVhdGVyJywgJycsICc3KycsIGJpbmFyeU9wcy5ncmVhdGVyXSxcbiAgWydJZGVudGl0eScsICcnLCAnMSsnLCB1bmFyeU9wcy5pZGVudGl0eV0sXG4gIFsnSW1hZ2VTY2FsZXInLCAnJywgJzErJywgaW1hZ2VTY2FsZXIsIHBhcnNlSW1hZ2VTY2FsZXJBdHRyaWJ1dGVzXSxcbiAgWydJbnN0YW5jZU5vcm1hbGl6YXRpb24nLCAnJywgJzYrJywgaW5zdGFuY2VOb3JtYWxpemF0aW9uLCBwYXJzZUluc3RhbmNlTm9ybWFsaXphdGlvbkF0dHJpYnV0ZXNdLFxuICBbJ0xlYWt5UmVsdScsICcnLCAnNisnLCB1bmFyeU9wcy5sZWFreVJlbHUsIHVuYXJ5T3BzLnBhcnNlTGVha3lSZWx1QXR0cmlidXRlc10sXG4gIFsnTGVzcycsICcnLCAnNysnLCBiaW5hcnlPcHMubGVzc10sXG4gIFsnTFJOJywgJycsICcxKycsIGxybiwgcGFyc2VMcm5BdHRyaWJ1dGVzXSxcbiAgWydMb2cnLCAnJywgJzYrJywgdW5hcnlPcHMubG9nXSxcbiAgWydNYXRNdWwnLCAnJywgJzErJywgbWF0TXVsLCBwYXJzZU1hdE11bEF0dHJpYnV0ZXNdLFxuICAvLyBUT0RPOiBzdXBwb3J0IG5ldyBhdHRyaWJ1dGVzIGZvciBNYXhQb29sLTggYW5kIE1heFBvb2wtMTBcbiAgWydNYXhQb29sJywgJycsICcxKycsIG1heFBvb2wsIHBhcnNlTWF4UG9vbEF0dHJpYnV0ZXNdLFxuICBbJ011bCcsICcnLCAnNysnLCBiaW5hcnlPcHMubXVsXSxcbiAgWydOZWcnLCAnJywgJzYrJywgdW5hcnlPcHMubmVnXSxcbiAgWydOb3QnLCAnJywgJzErJywgdW5hcnlPcHMubm90XSxcbiAgWydPcicsICcnLCAnNysnLCBiaW5hcnlPcHMub3JdLFxuICBbJ1BhZCcsICcnLCAnMi0xMCcsIHBhZFYyLCBwYXJzZVBhZEF0dHJpYnV0ZXNWMl0sXG4gIFsnUGFkJywgJycsICcxMSsnLCBwYWRWMTEsIHBhcnNlUGFkQXR0cmlidXRlc1YxMV0sXG4gIFsnUG93JywgJycsICc3KycsIGJpbmFyeU9wcy5wb3ddLFxuICBbJ1BSZWx1JywgJycsICc3KycsIGJpbmFyeU9wcy5wUmVsdV0sXG4gIFsnUmVkdWNlTG9nU3VtJywgJycsICcxKycsIHJlZHVjZUxvZ1N1bSwgcGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxcbiAgWydSZWR1Y2VNYXgnLCAnJywgJzErJywgcmVkdWNlTWF4LCBwYXJzZVJlZHVjZUF0dHJpYnV0ZXNdLFxuICBbJ1JlZHVjZU1lYW4nLCAnJywgJzErJywgcmVkdWNlTWVhbiwgcGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxcbiAgWydSZWR1Y2VNaW4nLCAnJywgJzErJywgcmVkdWNlTWluLCBwYXJzZVJlZHVjZUF0dHJpYnV0ZXNdLFxuICBbJ1JlZHVjZVByb2QnLCAnJywgJzErJywgcmVkdWNlUHJvZCwgcGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxcbiAgWydSZWR1Y2VTdW0nLCAnJywgJzEtMTInLCByZWR1Y2VTdW0sIHBhcnNlUmVkdWNlQXR0cmlidXRlc10sXG4gIFsnUmVkdWNlU3VtU3F1YXJlJywgJycsICcxKycsIHJlZHVjZUxvZ1N1bVNxdWFyZSwgcGFyc2VSZWR1Y2VBdHRyaWJ1dGVzXSxcbiAgWydSZWx1JywgJycsICc2KycsIHVuYXJ5T3BzLnJlbHVdLFxuICBbJ1Jlc2hhcGUnLCAnJywgJzUrJywgcmVzaGFwZV0sXG4gIFsnUmVzaXplJywgJycsICcxMCcsIHJlc2l6ZSwgcGFyc2VSZXNpemVBdHRyaWJ1dGVzVjEwXSxcbiAgWydSZXNpemUnLCAnJywgJzExKycsIHJlc2l6ZSwgcGFyc2VSZXNpemVBdHRyaWJ1dGVzVjExXSxcbiAgWydTaGFwZScsICcnLCAnMSsnLCBzaGFwZV0sXG4gIFsnU2lnbW9pZCcsICcnLCAnNisnLCB1bmFyeU9wcy5zaWdtb2lkXSxcbiAgWydTaW4nLCAnJywgJzcrJywgdW5hcnlPcHMuc2luXSxcbiAgWydTbGljZScsICcnLCAnMTArJywgc2xpY2VWMTBdLCAgLy8gVE9ETzogc3VwcG9ydCAnc3RlcHMnIGZvciBTbGljZS0xMFxuICBbJ1NsaWNlJywgJycsICcxLTknLCBzbGljZSwgcGFyc2VTbGljZUF0dHJpYnV0ZXNdLFxuICAvLyBUaGUgXCJzZW1hbnRpY1wiIG1lYW5pbmcgb2YgYXhpcyBoYXMgY2hhbmdlZCBpbiBvcHNldC0xMy5cbiAgWydTb2Z0bWF4JywgJycsICcxLTEyJywgc29mdG1heCwgcGFyc2VTb2Z0bWF4QXR0cmlidXRlc10sXG4gIFsnU29mdG1heCcsICcnLCAnMTMrJywgc29mdG1heFYxMywgcGFyc2VTb2Z0bWF4QXR0cmlidXRlc1YxM10sXG4gIC8vICdTcGxpdCcgb3BlcmF0b3IgaGFzIGFuIG9wdGlvbmFsIGF0dHJpYnV0ZSAnc3BsaXQnXG4gIC8vIHRoaXMgYXR0cmlidXRlIGRldGVybWluZXMgaG93IHRoZSBzcGVjaWZpZWQgYXhpcyBvZiBpbnB1dCBkYXRhIGlzIHNwbGl0LlxuICAvLyBXaGVuIHRoZSBhdHRyaWJ1dGUgaXMgbWlzc2luZywgd2UgbmVlZCB0aGUgY291bnQgb2YgbnVtYmVyIG9mIG91dHB1dHNcbiAgLy8gc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIHRoZSAnc3BsaXQnIGF0dHJpYnV0ZSBmcm9tIHRoZSBydW50aW1lIGlucHV0IHRvIHRoZSBPcGVyYXRvclxuICBbJ1NwbGl0JywgJycsICcyLTEyJywgc3BsaXQsIHBhcnNlU3BsaXRBdHRyaWJ1dGVzXSxcbiAgWydTcXJ0JywgJycsICc2KycsIHVuYXJ5T3BzLnNxcnRdLFxuICBbJ1NxdWVlemUnLCAnJywgJzEtMTInLCBzcXVlZXplLCBwYXJzZVNxdWVlemVBdHRyaWJ1dGVzXSxcbiAgWydTcXVlZXplJywgJycsICcxMysnLCBzcXVlZXplVjEzXSxcbiAgWydTdWInLCAnJywgJzcrJywgYmluYXJ5T3BzLnN1Yl0sXG4gIFsnU3VtJywgJycsICc2KycsIHN1bV0sXG4gIFsnVGFuJywgJycsICc3KycsIHVuYXJ5T3BzLnRhbl0sXG4gIFsnVGFuaCcsICcnLCAnNisnLCB1bmFyeU9wcy50YW5oXSxcbiAgWydUaWxlJywgJycsICc2KycsIHRpbGVdLFxuICBbJ1RyYW5zcG9zZScsICcnLCAnMSsnLCB0cmFuc3Bvc2UsIHBhcnNlVHJhbnNwb3NlQXR0cmlidXRlc10sXG4gIFsnVXBzYW1wbGUnLCAnJywgJzctOCcsIHVwc2FtcGxlLCBwYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y3XSxcbiAgWydVcHNhbXBsZScsICcnLCAnOScsIHVwc2FtcGxlLCBwYXJzZVVwc2FtcGxlQXR0cmlidXRlc1Y5XSxcbiAgWydVbnNxdWVlemUnLCAnJywgJzEtMTInLCB1bnNxdWVlemUsIHBhcnNlVW5zcXVlZXplQXR0cmlidXRlc10sXG4gIFsnVW5zcXVlZXplJywgJycsICcxMysnLCB1bnNxdWVlemVWMTNdLFxuICBbJ1hvcicsICcnLCAnNysnLCBiaW5hcnlPcHMueG9yXSxcbl07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmNvbnN0IElOTElORV9GVU5DX0RFRl9SRUdFWCA9IC9AaW5saW5lW1xcc1xcblxccl0rKFxcdyspW1xcc1xcblxccl0rKFswLTlhLXpBLVpfXSspXFxzKlxcKChbXildKilcXClcXHMqeygoW159XXxbXFxuXFxyXSkqKX0vZ207XG5jb25zdCBGVU5DX0NBTExfUkVHRVggPSAnKFxcXFx3Kyk/XFxcXHMrKFtfMC05YS16QS1aXSspXFxcXHMrPVxcXFxzK19fRlVOQ19fXFxcXCgoLiopXFxcXClcXFxccyo7Jztcbi8qKlxuICogR0xTTCBwcmVwcm9jZXNzb3IgcmVzcG9uc2libGUgZm9yIHJlc29sdmluZyBAaW5saW5lIGRpcmVjdGl2ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VJbmxpbmVzKHNjcmlwdDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgaW5saW5lRGVmczoge1tuYW1lOiBzdHJpbmddOiB7cGFyYW1zOiBBcnJheTx7dHlwZTogc3RyaW5nOyBuYW1lOiBzdHJpbmd9fG51bGw+OyBib2R5OiBzdHJpbmd9fSA9IHt9O1xuICBsZXQgbWF0Y2g7XG4gIHdoaWxlICgobWF0Y2ggPSBJTkxJTkVfRlVOQ19ERUZfUkVHRVguZXhlYyhzY3JpcHQpKSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IG1hdGNoWzNdXG4gICAgICAgICAgICAgICAgICAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAgICAgICAgICAgICAgICAgIC5tYXAocyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gcy50cmltKCkuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5zICYmIHRva2Vucy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogdG9rZW5zWzBdLCBuYW1lOiB0b2tlbnNbMV19O1xuICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcih2ID0+IHYgIT09IG51bGwpO1xuICAgIGlubGluZURlZnNbbWF0Y2hbMl1dID0ge3BhcmFtcywgYm9keTogbWF0Y2hbNF19O1xuICB9XG4gIGZvciAoY29uc3QgbmFtZSBpbiBpbmxpbmVEZWZzKSB7XG4gICAgY29uc3QgcmVnZXhTdHJpbmcgPSBGVU5DX0NBTExfUkVHRVgucmVwbGFjZSgnX19GVU5DX18nLCBuYW1lKTtcbiAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAocmVnZXhTdHJpbmcsICdnbScpO1xuICAgIHdoaWxlICgobWF0Y2ggPSByZWdleC5leGVjKHNjcmlwdCkpICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB0eXBlID0gbWF0Y2hbMV07XG4gICAgICBjb25zdCB2YXJpYWJsZSA9IG1hdGNoWzJdO1xuICAgICAgY29uc3QgcGFyYW1zID0gbWF0Y2hbM10uc3BsaXQoJywnKTtcbiAgICAgIGNvbnN0IGRlY2xMaW5lID0gKHR5cGUpID8gYCR7dHlwZX0gJHt2YXJpYWJsZX07YCA6ICcnO1xuICAgICAgbGV0IG5ld0JvZHk6IHN0cmluZyA9IGlubGluZURlZnNbbmFtZV0uYm9keTtcbiAgICAgIGxldCBwYXJhbVJlZGVjTGluZSA9ICcnO1xuICAgICAgaW5saW5lRGVmc1tuYW1lXS5wYXJhbXMuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgIHBhcmFtUmVkZWNMaW5lICs9IGAke3YudHlwZX0gJHt2Lm5hbWV9ID0gJHtwYXJhbXNbaV19O1xcbmA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbmV3Qm9keSA9IGAke3BhcmFtUmVkZWNMaW5lfVxcbiAke25ld0JvZHl9YDtcbiAgICAgIG5ld0JvZHkgPSBuZXdCb2R5LnJlcGxhY2UoJ3JldHVybicsIGAke3ZhcmlhYmxlfSA9IGApO1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBgXG4gICAgICAke2RlY2xMaW5lfVxuICAgICAge1xuICAgICAgICAke25ld0JvZHl9XG4gICAgICB9XG4gICAgICBgO1xuICAgICAgc2NyaXB0ID0gc2NyaXB0LnJlcGxhY2UobWF0Y2hbMF0sIHJlcGxhY2VtZW50KTtcbiAgICB9XG4gIH1cbiAgc2NyaXB0ID0gc2NyaXB0LnJlcGxhY2UoSU5MSU5FX0ZVTkNfREVGX1JFR0VYLCAnJyk7XG4gIHJldHVybiBzY3JpcHQ7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7TG9nZ2VyfSBmcm9tICcuLi8uLi9pbnN0cnVtZW50JztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICcuLi8uLi91dGlsJztcblxuLyoqIExheW91dCBwcmVmZXJlbmNlcyAqL1xuZXhwb3J0IGludGVyZmFjZSBXaWR0aEhlaWdodFByZWZzIHtcbiAgYnJlYWtBeGlzPzogbnVtYmVyO1xuICBpc1BhY2tlZD86IGJvb2xlYW47XG4gIHJldmVyc2VXSD86IGJvb2xlYW47XG59XG4vKipcbiAqIFRleHR1cmVMYXlvdXRTdHJhdGVneSBpcyBhbiBhYnN0cmFjdGlvbiBmb3IgZGlmZmVyZW50IHBsYW5zXG4gKiBmb3IgbWFwcGluZyBuLWRpbWVuc2lvbmFsIGFycmF5cyB0byAyRCB0ZXh0dXJlcyAoYW5kIGJhY2spXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dHVyZUxheW91dFN0cmF0ZWd5IHtcbiAgY29tcHV0ZVRleHR1cmVXSChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHByZWZzPzogV2lkdGhIZWlnaHRQcmVmcyk6IFtudW1iZXIsIG51bWJlcl07XG59XG5cbi8qKlxuICogVGhpcyBzdHJhdGVneSB0cnkgdG8gZmluZCB0aGUgbWluaW1hbCBtYXgoVyxIKSB0aGF0IGZ1bGZpbGxzIChXICogSCA9PSB0b3RhbFNpemUpXG4gKi9cbmV4cG9ydCBjbGFzcyBBbHdheXNLZWVwT3JpZ2luYWxTaXplU3RyYXRlZ3kgaW1wbGVtZW50cyBUZXh0dXJlTGF5b3V0U3RyYXRlZ3kge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgbWF4VGV4dHVyZVNpemU6IG51bWJlcikge31cbiAgY29tcHV0ZVRleHR1cmVXSChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHByZWZzPzogV2lkdGhIZWlnaHRQcmVmcyk6IFtudW1iZXIsIG51bWJlcl0ge1xuICAgIC8vIHNjYWxhciB0ZW5zb3JcbiAgICBpZiAoc2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gWzEsIDFdO1xuICAgIH1cbiAgICBjb25zdCBtYXhUZXh0dXJlU2l6ZSA9IHRoaXMubWF4VGV4dHVyZVNpemU7XG4gICAgaWYgKHByZWZzICYmIHByZWZzLmJyZWFrQXhpcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBjaGVjayB0byBzZWUgaWYgZGltcyBmaXRcbiAgICAgIGNvbnN0IHdzaXplID0gcHJlZnMuYnJlYWtBeGlzID49IHNoYXBlLmxlbmd0aCA/IDEgOiBzaGFwZS5zbGljZShwcmVmcy5icmVha0F4aXMpLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpO1xuICAgICAgY29uc3QgaHNpemUgPSBwcmVmcy5icmVha0F4aXMgPD0gMCA/IDEgOiBzaGFwZS5zbGljZSgwLCBwcmVmcy5icmVha0F4aXMpLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpO1xuICAgICAgaWYgKHdzaXplID4gbWF4VGV4dHVyZVNpemUgfHwgaHNpemUgPiBtYXhUZXh0dXJlU2l6ZSkge1xuICAgICAgICAvLyBpZ25vcmUgcHJlZmVyZW5jZXNcbiAgICAgICAgLy8gY29udGludWUgd2l0aCBkZWZhdWx0IGxheW91dFxuICAgICAgICBMb2dnZXIudmVyYm9zZShcbiAgICAgICAgICAgICdUZXh0dXJlTGF5b3V0JyxcbiAgICAgICAgICAgIGBHaXZlbiB3aWR0aC9oZWlnaHQgcHJlZmVyZW5jZXMgd2VyZSB1bmF0dGFpbmFibGU6IHNoYXBlOiR7c2hhcGV9LCBicmVha0F4aXM6JHtwcmVmcy5icmVha0F4aXN9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW3dzaXplLCBoc2l6ZV07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRvdGFsU2l6ZSA9IHNoYXBlLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpO1xuXG4gICAgbGV0IHdpZHRoID0gTWF0aC5mbG9vcihNYXRoLnNxcnQodG90YWxTaXplKSk7XG5cbiAgICBmb3IgKDsgd2lkdGggPCBtYXhUZXh0dXJlU2l6ZSAmJiB3aWR0aCA8IHRvdGFsU2l6ZTsgd2lkdGgrKykge1xuICAgICAgaWYgKHRvdGFsU2l6ZSAlIHdpZHRoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3aWR0aCA+PSBtYXhUZXh0dXJlU2l6ZSB8fCB0b3RhbFNpemUgJSB3aWR0aCAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZ2l2ZW4gZGltZW5zaW9ucyBhcmUgb3V0c2lkZSB0aGlzIEdQVSdzIGJvdW5kYXJpZXM6ICR7c2hhcGV9YCk7XG4gICAgfVxuICAgIHJldHVybiBbd2lkdGgsIHRvdGFsU2l6ZSAvIHdpZHRoXTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUHJlZmVyTG9naWNhbFN0cmF0ZWd5IGltcGxlbWVudHMgVGV4dHVyZUxheW91dFN0cmF0ZWd5IHtcbiAgY29uc3RydWN0b3IocHVibGljIG1heFRleHR1cmVTaXplOiBudW1iZXIpIHt9XG4gIGNvbXB1dGVUZXh0dXJlV0goc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBwcmVmcz86IFdpZHRoSGVpZ2h0UHJlZnMpOiBbbnVtYmVyLCBudW1iZXJdIHtcbiAgICBjb25zdCB3aCA9IHRoaXMuY29tcHV0ZVRleHR1cmUoc2hhcGUsIHByZWZzKTtcbiAgICBpZiAocHJlZnMgJiYgcHJlZnMuaXNQYWNrZWQpIHtcbiAgICAgIHdoWzBdIC89IDI7XG4gICAgICB3aFsxXSAvPSAyO1xuICAgIH1cbiAgICBpZiAocHJlZnMgJiYgcHJlZnMucmV2ZXJzZVdIKSB7XG4gICAgICByZXR1cm4gW3doWzFdLCB3aFswXV07XG4gICAgfVxuICAgIHJldHVybiB3aDtcbiAgfVxuXG4gIGNvbXB1dGVUZXh0dXJlKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgcHJlZnM/OiBXaWR0aEhlaWdodFByZWZzKTogW251bWJlciwgbnVtYmVyXSB7XG4gICAgY29uc3QgaXNQYWNrZWQgPSBwcmVmcyAmJiBwcmVmcy5pc1BhY2tlZDtcbiAgICAvLyBzY2FsYXIgdGVuc29yXG4gICAgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGlzUGFja2VkID8gWzIsIDJdIDogWzEsIDFdO1xuICAgIH1cbiAgICBsZXQgbWF4VGV4dHVyZVNpemUgPSB0aGlzLm1heFRleHR1cmVTaXplO1xuICAgIGlmIChwcmVmcyAmJiBwcmVmcy5icmVha0F4aXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIGRpbXMgZml0XG4gICAgICBjb25zdCB3c2l6ZSA9IHByZWZzLmJyZWFrQXhpcyA+PSBzaGFwZS5sZW5ndGggPyAxIDogc2hhcGUuc2xpY2UocHJlZnMuYnJlYWtBeGlzKS5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiKTtcbiAgICAgIGNvbnN0IGhzaXplID0gcHJlZnMuYnJlYWtBeGlzIDw9IDAgPyAxIDogc2hhcGUuc2xpY2UoMCwgcHJlZnMuYnJlYWtBeGlzKS5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiKTtcbiAgICAgIGlmICh3c2l6ZSA+IG1heFRleHR1cmVTaXplIHx8IGhzaXplID4gbWF4VGV4dHVyZVNpemUpIHtcbiAgICAgICAgLy8gaWdub3JlIHByZWZlcmVuY2VzXG4gICAgICAgIC8vIGNvbnRpbnVlIHdpdGggZGVmYXVsdCBsYXlvdXRcbiAgICAgICAgTG9nZ2VyLnZlcmJvc2UoXG4gICAgICAgICAgICAnVGV4dHVyZUxheW91dCcsXG4gICAgICAgICAgICBgR2l2ZW4gd2lkdGgvaGVpZ2h0IHByZWZlcmVuY2VzIHdlcmUgdW5hdHRhaW5hYmxlOiBzaGFwZToke3NoYXBlfSwgYnJlYWtBeGlzOiR7cHJlZnMuYnJlYWtBeGlzfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFt3c2l6ZSwgaHNpemVdO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbG9nU2hhcGUgPSBzaGFwZS5zbGljZSgwKTtcbiAgICBpZiAoaXNQYWNrZWQpIHtcbiAgICAgIG1heFRleHR1cmVTaXplID0gbWF4VGV4dHVyZVNpemUgKiAyO1xuXG4gICAgICAvLyBUaGlzIGxvZ2ljIGVuc3VyZXMgd2UgYWNjdXJhdGVseSBjb3VudCB0aGUgbnVtYmVyIG9mIHBhY2tlZCB0ZXhlbHMgbmVlZGVkXG4gICAgICAvLyB0byBhY2NvbW1vZGF0ZSB0aGUgdGVuc29yLiBXZSBjYW4gb25seSBwYWNrIHZhbHVlcyBpbiB0aGUgc2FtZSB0ZXhlbCBpZlxuICAgICAgLy8gdGhleSBhcmUgZnJvbSBhZGphY2VudCBwYWlycyBvZiByb3dzL2NvbHMgd2l0aGluIHRoZSBzYW1lIGJhdGNoLiBTbyBpZiBhXG4gICAgICAvLyB0ZW5zb3IgaGFzIDMgcm93cywgd2UgcHJldGVuZCBpdCBoYXMgNCByb3dzIGluIG9yZGVyIHRvIGFjY291bnQgZm9yIHRoZVxuICAgICAgLy8gZmFjdCB0aGF0IHRoZSB0ZXhlbHMgY29udGFpbmluZyB0aGUgdGhpcmQgcm93IGFyZSBoYWxmIGVtcHR5LlxuICAgICAgbG9nU2hhcGUgPSBsb2dTaGFwZS5tYXAoXG4gICAgICAgICAgKF9kLCBpKSA9PiBpID49IGxvZ1NoYXBlLmxlbmd0aCAtIDIgPyAobG9nU2hhcGVbaV0gJSAyID09PSAwID8gbG9nU2hhcGVbaV0gOiBsb2dTaGFwZVtpXSArIDEpIDogbG9nU2hhcGVbaV0pO1xuXG4gICAgICAvLyBQYWNrZWQgdGV4dHVyZSBoZWlnaHQgaXMgYXQgbGVhc3QgMiAodGhlIGNoYW5uZWwgaGVpZ2h0IG9mIGEgc2luZ2xlXG4gICAgICAvLyB0ZXhlbCkuXG4gICAgICBpZiAobG9nU2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGxvZ1NoYXBlID0gWzIsIGxvZ1NoYXBlWzBdXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBsb2dpY2FsIHNoYXBlIGlzIDIsIHdlIGRvbid0IHNxdWVlemUsIHNpbmNlIHdlIHdhbnQgdG8gbWF0Y2ggcGh5c2ljYWwuXG4gICAgaWYgKGxvZ1NoYXBlLmxlbmd0aCAhPT0gMikge1xuICAgICAgY29uc3Qgc3F1ZWV6ZVJlc3VsdCA9IHNxdWVlemVTaGFwZShsb2dTaGFwZSk7XG4gICAgICBsb2dTaGFwZSA9IHNxdWVlemVSZXN1bHQubmV3U2hhcGU7XG4gICAgfVxuXG4gICAgY29uc3Qgc2l6ZSA9IHNpemVGcm9tU2hhcGUobG9nU2hhcGUpO1xuICAgIGlmIChsb2dTaGFwZS5sZW5ndGggPD0gMSAmJiBzaXplIDw9IG1heFRleHR1cmVTaXplKSB7XG4gICAgICByZXR1cm4gWzEsIHNpemVdO1xuICAgIH0gZWxzZSBpZiAobG9nU2hhcGUubGVuZ3RoID09PSAyICYmIGxvZ1NoYXBlWzBdIDw9IG1heFRleHR1cmVTaXplICYmIGxvZ1NoYXBlWzFdIDw9IG1heFRleHR1cmVTaXplKSB7XG4gICAgICByZXR1cm4gbG9nU2hhcGUgYXMgW251bWJlciwgbnVtYmVyXTtcbiAgICB9IGVsc2UgaWYgKGxvZ1NoYXBlLmxlbmd0aCA9PT0gMyAmJiBsb2dTaGFwZVswXSAqIGxvZ1NoYXBlWzFdIDw9IG1heFRleHR1cmVTaXplICYmIGxvZ1NoYXBlWzJdIDw9IG1heFRleHR1cmVTaXplKSB7XG4gICAgICByZXR1cm4gW2xvZ1NoYXBlWzBdICogbG9nU2hhcGVbMV0sIGxvZ1NoYXBlWzJdXTtcbiAgICB9IGVsc2UgaWYgKGxvZ1NoYXBlLmxlbmd0aCA9PT0gMyAmJiBsb2dTaGFwZVswXSA8PSBtYXhUZXh0dXJlU2l6ZSAmJiBsb2dTaGFwZVsxXSAqIGxvZ1NoYXBlWzJdIDw9IG1heFRleHR1cmVTaXplKSB7XG4gICAgICByZXR1cm4gW2xvZ1NoYXBlWzBdLCBsb2dTaGFwZVsxXSAqIGxvZ1NoYXBlWzJdXTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICBsb2dTaGFwZS5sZW5ndGggPT09IDQgJiYgbG9nU2hhcGVbMF0gKiBsb2dTaGFwZVsxXSAqIGxvZ1NoYXBlWzJdIDw9IG1heFRleHR1cmVTaXplICYmXG4gICAgICAgIGxvZ1NoYXBlWzNdIDw9IG1heFRleHR1cmVTaXplKSB7XG4gICAgICByZXR1cm4gW2xvZ1NoYXBlWzBdICogbG9nU2hhcGVbMV0gKiBsb2dTaGFwZVsyXSwgbG9nU2hhcGVbM11dO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGxvZ1NoYXBlLmxlbmd0aCA9PT0gNCAmJiBsb2dTaGFwZVswXSA8PSBtYXhUZXh0dXJlU2l6ZSAmJlxuICAgICAgICBsb2dTaGFwZVsxXSAqIGxvZ1NoYXBlWzJdICogbG9nU2hhcGVbM10gPD0gbWF4VGV4dHVyZVNpemUpIHtcbiAgICAgIHJldHVybiBbbG9nU2hhcGVbMF0sIGxvZ1NoYXBlWzFdICogbG9nU2hhcGVbMl0gKiBsb2dTaGFwZVszXV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgICAvLyBGb3IgcGFja2VkIHRleHR1cmVzIHNpemUgZXF1YWxzIHRoZSBudW1iZXIgb2YgY2hhbm5lbHMgcmVxdWlyZWQgdG9cbiAgICAgICAgLy8gYWNjb21tb2RhdGUgdGhlIHRleHR1cmUgZGF0YS4gSG93ZXZlciBpbiBvcmRlciB0byBzcXVhcmlmeSBzdWNoIHRoYXRcbiAgICAgICAgLy8gaW5uZXIgZGltZW5zaW9ucyBzdGF5IGV2ZW4sIHdlIHJld3JpdGUgc2l6ZSB0byBlcXVhbCB0aGUgbnVtYmVyIG9mXG4gICAgICAgIC8vIHRleGVscy4gVGhlbiBpbiB0aGUgcmV0dXJuIHN0YXRlbWVudCB3ZSByZWh5ZHJhdGUgdGhlIHNxdWFyaWZpZWRcbiAgICAgICAgLy8gZGltZW5zaW9ucyB0byBjaGFubmVsIHVuaXRzLlxuICAgICAgICByZXR1cm4gc2l6ZVRvU3F1YXJpc2hTaGFwZShzaXplIC8gNCkubWFwKGQgPT4gZCAqIDIpIGFzIFtudW1iZXIsIG51bWJlcl07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2l6ZVRvU3F1YXJpc2hTaGFwZShzaXplKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWVlemVTaGFwZShzaGFwZTogbnVtYmVyW10sIGF4aXM/OiBudW1iZXJbXSk6IHtuZXdTaGFwZTogbnVtYmVyW107IGtlcHREaW1zOiBudW1iZXJbXX0ge1xuICBjb25zdCBuZXdTaGFwZTogbnVtYmVyW10gPSBbXTtcbiAgY29uc3Qga2VwdERpbXM6IG51bWJlcltdID0gW107XG4gIGNvbnN0IGlzRW1wdHlBcnJheSA9IGF4aXMgIT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KGF4aXMpICYmIGF4aXMubGVuZ3RoID09PSAwO1xuICBjb25zdCBheGVzID0gKGF4aXMgPT0gbnVsbCB8fCBpc0VtcHR5QXJyYXkpID8gbnVsbCA6IHBhcnNlQXhpc1BhcmFtKGF4aXMsIHNoYXBlKS5zb3J0KCk7XG4gIGxldCBqID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFwZS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChheGVzICE9IG51bGwpIHtcbiAgICAgIGlmIChheGVzW2pdID09PSBpICYmIHNoYXBlW2ldICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3Qgc3F1ZWV6ZSBheGlzICR7aX0gc2luY2UgaXRzIGRpbSAnJHtzaGFwZVtpXX0nIGlzIG5vdCAxYCk7XG4gICAgICB9XG4gICAgICBpZiAoKGF4ZXNbal0gPT0gbnVsbCB8fCBheGVzW2pdID4gaSkgJiYgc2hhcGVbaV0gPT09IDEpIHtcbiAgICAgICAgbmV3U2hhcGUucHVzaChzaGFwZVtpXSk7XG4gICAgICAgIGtlcHREaW1zLnB1c2goaSk7XG4gICAgICB9XG4gICAgICBpZiAoYXhlc1tqXSA8PSBpKSB7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNoYXBlW2ldICE9PSAxKSB7XG4gICAgICBuZXdTaGFwZS5wdXNoKHNoYXBlW2ldKTtcbiAgICAgIGtlcHREaW1zLnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7bmV3U2hhcGUsIGtlcHREaW1zfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQXhpc1BhcmFtKGF4aXM6IG51bWJlcnxudW1iZXJbXSwgc2hhcGU6IG51bWJlcltdKTogbnVtYmVyW10ge1xuICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuXG4gIC8vIE5vcm1hbGl6ZSBpbnB1dFxuICBheGlzID0gYXhpcyA9PSBudWxsID8gc2hhcGUubWFwKChfcywgaSkgPT4gaSkgOiAoW10gYXMgbnVtYmVyW10pLmNvbmNhdChheGlzKTtcblxuICAvLyBDaGVjayBmb3IgdmFsaWQgcmFuZ2VcbiAgYXNzZXJ0KFxuICAgICAgYXhpcy5ldmVyeShheCA9PiBheCA+PSAtcmFuayAmJiBheCA8IHJhbmspLFxuICAgICAgKCkgPT4gYEFsbCB2YWx1ZXMgaW4gYXhpcyBwYXJhbSBtdXN0IGJlIGluIHJhbmdlIFstJHtyYW5rfSwgJHtyYW5rfSkgYnV0IGAgK1xuICAgICAgICAgIGBnb3QgYXhpcyAke2F4aXN9YCk7XG5cbiAgLy8gQ2hlY2sgZm9yIG9ubHkgaW50ZWdlcnNcbiAgYXNzZXJ0KFxuICAgICAgYXhpcy5ldmVyeShpc0ludCksXG4gICAgICAoKSA9PiAnQWxsIHZhbHVlcyBpbiBheGlzIHBhcmFtIG11c3QgYmUgaW50ZWdlcnMgYnV0ICcgK1xuICAgICAgICAgIGBnb3QgYXhpcyAke2F4aXN9YCk7XG5cbiAgLy8gSGFuZGxlIG5lZ2F0aXZlIGF4aXMuXG4gIHJldHVybiBheGlzLm1hcChhID0+IGEgPCAwID8gcmFuayArIGEgOiBhKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0ludChhOiBudW1iZXIpOiBib29sZWFuIHtcbiAgcmV0dXJuIGEgJSAxID09PSAwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNpemVGcm9tU2hhcGUoc2hhcGU6IG51bWJlcltdKTogbnVtYmVyIHtcbiAgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIFNjYWxhci5cbiAgICByZXR1cm4gMTtcbiAgfVxuICBsZXQgc2l6ZSA9IHNoYXBlWzBdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgc2l6ZSAqPSBzaGFwZVtpXTtcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3dzQ29scyhzaGFwZTogbnVtYmVyW10pOiBbbnVtYmVyLCBudW1iZXJdIHtcbiAgaWYgKHNoYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IEVycm9yKCdDYW5ub3QgZ2V0IHJvd3MgYW5kIGNvbHVtbnMgb2YgYW4gZW1wdHkgc2hhcGUgYXJyYXkuJyk7XG4gIH1cblxuICByZXR1cm4gW3NoYXBlLmxlbmd0aCA+IDEgPyBzaGFwZVtzaGFwZS5sZW5ndGggLSAyXSA6IDEsIHNoYXBlW3NoYXBlLmxlbmd0aCAtIDFdXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaXplVG9TcXVhcmlzaFNoYXBlKHNpemU6IG51bWJlcik6IFtudW1iZXIsIG51bWJlcl0ge1xuICBjb25zdCB3aWR0aCA9IE1hdGguY2VpbChNYXRoLnNxcnQoc2l6ZSkpO1xuICByZXR1cm4gW3dpZHRoLCBNYXRoLmNlaWwoc2l6ZSAvIHdpZHRoKV07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QmF0Y2hEaW0oc2hhcGU6IG51bWJlcltdLCBkaW1zVG9Ta2lwID0gMik6IG51bWJlciB7XG4gIHJldHVybiBzaXplRnJvbVNoYXBlKHNoYXBlLnNsaWNlKDAsIHNoYXBlLmxlbmd0aCAtIGRpbXNUb1NraXApKTtcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtBcnJheVV0aWwsIEJyb2FkY2FzdFV0aWwsIFNoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5cbmltcG9ydCB7R2xzbENvbnRleHQsIEdsc2xMaWIsIEdsc2xMaWJSb3V0aW5lfSBmcm9tICcuL2dsc2wtZGVmaW5pdGlvbnMnO1xuaW1wb3J0IHtnZXRHbHNsfSBmcm9tICcuL2dsc2wtc291cmNlJztcbmltcG9ydCB7c3F1ZWV6ZVNoYXBlfSBmcm9tICcuL3RleHR1cmUtbGF5b3V0LXN0cmF0ZWd5JztcbmltcG9ydCB7VGV4dHVyZUxheW91dH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge2dlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZSwgZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lQXRPdXRDb29yZHMsIGdldENvb3Jkc0RhdGFUeXBlLCBnZXRHbENoYW5uZWxzLCBnZXRTcXVlZXplZFBhcmFtcywgc3F1ZWV6ZUlucHV0U2hhcGV9IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIEdMU0wgTGlicmFyeSByZXNwb25zaWJsZSBmb3IgZGF0YSB0eXBlcyBhbmQgcm91dGluZXMgZm9yIG1hbmlwdWxhdGluZ1xuICogY29vcmRpbmF0ZXMgYW5kIG1hcHBpbmcgdG8vZnJvbSB0ZW5zb3IgaW5kaWNlc1xuICovXG5leHBvcnQgY2xhc3MgQ29vcmRzR2xzbExpYiBleHRlbmRzIEdsc2xMaWIge1xuICByZXR1cm5UeXBlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoY29udGV4dDogR2xzbENvbnRleHQpIHtcbiAgICBzdXBlcihjb250ZXh0KTtcbiAgfVxuICBnZXRGdW5jdGlvbnMoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIHJldHVybiB7XG4gICAgICAuLi50aGlzLm9mZnNldFRvQ29vcmRzKCksXG4gICAgICAuLi50aGlzLmNvb3Jkc1RvT2Zmc2V0KCksXG4gICAgICAuLi50aGlzLnRvVmVjKCksXG4gICAgICAuLi50aGlzLnZhbHVlRnJvbSgpLFxuICAgICAgLy8gVE9ETyByZXR1cm4gdGhlc2Ugb25seSB3aGVuIHBhY2tpbmcgaXMgZW5hYmxlZC5cbiAgICAgIC4uLnRoaXMuZ2V0Q29tbW9uVXRpbEZ1bmNzKCksXG4gICAgICAuLi50aGlzLmdldElucHV0c1NhbXBsaW5nU25pcHBldHMoKSxcbiAgICAgIC4uLnRoaXMuZ2V0T3V0cHV0U2FtcGxpbmdTbmlwcGV0KClcbiAgICB9O1xuICB9XG4gIGdldEN1c3RvbVR5cGVzKCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICAvKipcbiAgICogUHJvZHVjZXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBtYXAgZnJvbVxuICAgKiAyRCBub3JtYWx6aWVkIGNvb3JkaW5hdGVzIChzLHQpIHRvIGEgZmxhdCBvZmZzZXRcbiAgICovXG4gIHByb3RlY3RlZCBvZmZzZXRUb0Nvb3JkcygpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgY29uc3QgZnVuY05hbWUgPSAnb2Zmc2V0VG9Db29yZHMnO1xuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXRUb0Nvb3JkczogbmV3IEdsc2xMaWJSb3V0aW5lKGBcbiAgICAgIHZlYzIgJHtmdW5jTmFtZX0oaW50IG9mZnNldCwgaW50IHdpZHRoLCBpbnQgaGVpZ2h0KSB7XG4gICAgICAgIGludCB0ID0gb2Zmc2V0IC8gd2lkdGg7XG4gICAgICAgIGludCBzID0gb2Zmc2V0IC0gdCp3aWR0aDtcbiAgICAgICAgdmVjMiBjb29yZHMgPSAodmVjMihzLHQpICsgdmVjMigwLjUsMC41KSkgLyB2ZWMyKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICByZXR1cm4gY29vcmRzO1xuICAgICAgfVxuICAgICAgYClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2R1Y2VzIGEgZnVuY3Rpb24gdGhhdCBjYW4gbWFwIGZyb21cbiAgICogMkQgbm9ybWFsemllZCBjb29yZGluYXRlcyAocyx0KSB0byBhIGZsYXQgb2Zmc2V0XG4gICAqL1xuICBwcm90ZWN0ZWQgY29vcmRzVG9PZmZzZXQoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IGZ1bmNOYW1lID0gJ2Nvb3Jkc1RvT2Zmc2V0JztcbiAgICByZXR1cm4ge1xuICAgICAgY29vcmRzVG9PZmZzZXQ6IG5ldyBHbHNsTGliUm91dGluZShgXG4gICAgICBpbnQgJHtmdW5jTmFtZX0odmVjMiBjb29yZHMsIGludCB3aWR0aCwgaW50IGhlaWdodCkge1xuICAgICAgICBmbG9hdCBzID0gY29vcmRzLnMgKiBmbG9hdCh3aWR0aCk7XG4gICAgICAgIGZsb2F0IHQgPSBjb29yZHMudCAqIGZsb2F0KGhlaWdodCk7XG4gICAgICAgIGludCBvZmZzZXQgPSBpbnQodCkgKiB3aWR0aCArIGludChzKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgIH1cbiAgICAgIGApXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgY29kZSBmb3Igb3V0cHV0IHNhbXBsZXIuXG4gICAqL1xuXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRTYW1wbGluZ1NuaXBwZXQoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IG91dHB1dExheW91dCA9IHRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0O1xuICAgIGlmIChvdXRwdXRMYXlvdXQuaXNQYWNrZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFBhY2tlZE91dHB1dFNhbXBsaW5nU25pcHBldChvdXRwdXRMYXlvdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZE91dHB1dFNhbXBsaW5nU25pcHBldChvdXRwdXRMYXlvdXQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgY29kZSBmb3IgcGFja2VkIG91dHB1dCBzYW1wbGVyLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFBhY2tlZE91dHB1dFNhbXBsaW5nU25pcHBldChvdXRwdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgY29uc3Qgb3V0U2hhcGUgPSBvdXRwdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCBvdXRUZXhTaGFwZSA9IFtvdXRwdXRMYXlvdXQud2lkdGgsIG91dHB1dExheW91dC5oZWlnaHRdO1xuICAgIGNvbnN0IHJlc3VsdDoge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0gPSB7fTtcbiAgICBjb25zdCBmdW5jTmFtZSA9ICdnZXRPdXRwdXRDb29yZHMnO1xuICAgIHN3aXRjaCAob3V0U2hhcGUubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSB0aGlzLmdldE91dHB1dFNjYWxhckNvb3JkcygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0T3V0cHV0UGFja2VkMURDb29yZHMob3V0U2hhcGUgYXMgW251bWJlcl0sIG91dFRleFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0T3V0cHV0UGFja2VkMkRDb29yZHMob3V0U2hhcGUgYXMgW251bWJlciwgbnVtYmVyXSwgb3V0VGV4U2hhcGUgYXMgW251bWJlciwgbnVtYmVyXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXN1bHRbZnVuY05hbWVdID1cbiAgICAgICAgICAgIHRoaXMuZ2V0T3V0cHV0UGFja2VkM0RDb29yZHMob3V0U2hhcGUgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBvdXRUZXhTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gdGhpcy5nZXRPdXRwdXRQYWNrZWRORENvb3JkcyhvdXRTaGFwZSwgb3V0VGV4U2hhcGUgYXMgW251bWJlciwgbnVtYmVyXSk7XG4gICAgfVxuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgLy8gVE9ETyB3ZSBuZWVkIHRoaXMgdG8gcHJvcGVybHkgcmV0dXJuIGEgcGFja2VkIHZlYzQgZnJvbSBrZXJuZWxzLlxuICAgIC8vIFJlcGxhY2UgYWxsICd7Z2xzbC5vdXRwdXR9ID0gcmVzdWx0JyB3aXRoICdzZXRPdXRwdXQocmVzdWx0KScgaW4gYWxsIGtlcm5lbHMuXG4gICAgY29uc3QgZmxvYXRUZXh0dXJlU2V0UkdCQVNvdXJjZSA9IGBcbiAgICAgIHZvaWQgc2V0T3V0cHV0KHZlYzQgdmFsKSB7XG4gICAgICAgICR7Z2xzbC5vdXRwdXR9ID0gdmFsO1xuICAgICAgfVxuICAgIGA7XG4gICAgY29uc3QgZmxvYXRUZXh0dXJlU2V0UkdCQUZ1bmNOYW1lID0gJ2Zsb2F0VGV4dHVyZVNldFJHQkEnO1xuICAgIHJlc3VsdFtmbG9hdFRleHR1cmVTZXRSR0JBRnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKGZsb2F0VGV4dHVyZVNldFJHQkFTb3VyY2UpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGNvZGUgZm9yIHVucGFja2VkIG91dHB1dCBzYW1wbGVyLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFVucGFja2VkT3V0cHV0U2FtcGxpbmdTbmlwcGV0KG91dHB1dExheW91dDogVGV4dHVyZUxheW91dCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCBvdXRTaGFwZSA9IG91dHB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IG91dFRleFNoYXBlID0gW291dHB1dExheW91dC53aWR0aCwgb3V0cHV0TGF5b3V0LmhlaWdodF07XG4gICAgY29uc3QgcmVzdWx0OiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSA9IHt9O1xuICAgIGNvbnN0IGZ1bmNOYW1lID0gJ2dldE91dHB1dENvb3Jkcyc7XG4gICAgc3dpdGNoIChvdXRTaGFwZS5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0T3V0cHV0U2NhbGFyQ29vcmRzKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gdGhpcy5nZXRPdXRwdXRVbnBhY2tlZDFEQ29vcmRzKG91dFNoYXBlIGFzIFtudW1iZXJdLCBvdXRUZXhTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPVxuICAgICAgICAgICAgdGhpcy5nZXRPdXRwdXRVbnBhY2tlZDJEQ29vcmRzKG91dFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0sIG91dFRleFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9XG4gICAgICAgICAgICB0aGlzLmdldE91dHB1dFVucGFja2VkM0RDb29yZHMob3V0U2hhcGUgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBvdXRUZXhTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSB0aGlzLmdldE91dHB1dFVucGFja2VkNERDb29yZHMoXG4gICAgICAgICAgICBvdXRTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgb3V0VGV4U2hhcGUgYXMgW251bWJlciwgbnVtYmVyXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA1OlxuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gdGhpcy5nZXRPdXRwdXRVbnBhY2tlZDVEQ29vcmRzKFxuICAgICAgICAgICAgb3V0U2hhcGUgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgb3V0VGV4U2hhcGUgYXMgW251bWJlciwgbnVtYmVyXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2OlxuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gdGhpcy5nZXRPdXRwdXRVbnBhY2tlZDZEQ29vcmRzKFxuICAgICAgICAgICAgb3V0U2hhcGUgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLCBvdXRUZXhTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG91dHB1dCBkaW1lbnNpb25hbGl0eTogJHtvdXRTaGFwZS5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgLy8gVE9ETyB3ZSBuZWVkIHRoaXMgdG8gcHJvcGVybHkgcmV0dXJuIGEgcGFja2VkIHZlYzQgZnJvbSBrZXJuZWxzLlxuICAgIC8vIFJlcGxhY2UgYWxsICd7Z2xzbC5vdXRwdXR9ID0gcmVzdWx0JyB3aXRoICdzZXRPdXRwdXQocmVzdWx0KScgaW4gYWxsIGtlcm5lbHMuXG4gICAgY29uc3QgZmxvYXRUZXh0dXJlU2V0UlNvdXJjZSA9IGBcbiAgICAgICAgdm9pZCBzZXRPdXRwdXQoZmxvYXQgdmFsKSB7XG4gICAgICAgICAgJHtnbHNsLm91dHB1dH0gPSB2ZWM0KHZhbCwgMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICBgO1xuICAgIGNvbnN0IGZsb2F0VGV4dHVyZVNldFJGdW5jTmFtZSA9ICdmbG9hdFRleHR1cmVTZXRSJztcbiAgICByZXN1bHRbZmxvYXRUZXh0dXJlU2V0UkZ1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShmbG9hdFRleHR1cmVTZXRSU291cmNlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNjYWxhciBvdXRwdXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0T3V0cHV0U2NhbGFyQ29vcmRzKCk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKGBcbiAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIGApO1xuICB9XG5cbiAgLyoqXG4gICAqIDFEIHBhY2tlZCBvdXRwdXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0T3V0cHV0UGFja2VkMURDb29yZHMoX3NoYXBlOiBbbnVtYmVyXSwgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3QgcGFja2VkVGV4U2hhcGUgPSB0ZXhTaGFwZTtcbiAgICBsZXQgc291cmNlID0gJyc7XG4gICAgaWYgKHBhY2tlZFRleFNoYXBlWzBdID09PSAxKSB7XG4gICAgICBzb3VyY2UgPSBgXG4gICAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICAgIHJldHVybiAyICogaW50KFRleENvb3Jkcy55ICogJHtwYWNrZWRUZXhTaGFwZVsxXX0uMCk7XG4gICAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICAgIH1cblxuICAgIGlmIChwYWNrZWRUZXhTaGFwZVsxXSA9PT0gMSkge1xuICAgICAgc291cmNlID0gYFxuICAgICAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gMiAqIGludChUZXhDb29yZHMueCAqICR7cGFja2VkVGV4U2hhcGVbMF19LjApO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgICB9XG5cbiAgICBzb3VyY2UgPSBgXG4gICAgICAgIGludCBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3BhY2tlZFRleFNoYXBlWzBdfSwgJHtwYWNrZWRUZXhTaGFwZVsxXX0pKTtcbiAgICAgICAgICByZXR1cm4gMiAqIChyZXNUZXhSQy55ICogJHtwYWNrZWRUZXhTaGFwZVswXX0gKyByZXNUZXhSQy54KTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogMkQgcGFja2VkIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRQYWNrZWQyRENvb3JkcyhzaGFwZTogW251bWJlciwgbnVtYmVyXSwgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOiBHbHNsTGliUm91dGluZSB7XG4gICAgbGV0IHNvdXJjZSA9ICcnO1xuICAgIGlmIChBcnJheVV0aWwuYXJyYXlzRXF1YWwoc2hhcGUsIHRleFNoYXBlKSkge1xuICAgICAgc291cmNlID0gYFxuICAgICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgICAgcmV0dXJuIDIgKiBpdmVjMihUZXhDb29yZHMueHkgKiB2ZWMyKCR7dGV4U2hhcGVbMF19LCAke3RleFNoYXBlWzFdfSkpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICAgIH1cblxuICAgIGNvbnN0IHBhY2tlZFRleFNoYXBlID0gdGV4U2hhcGU7XG4gICAgLy8gdGV4ZWxzIG5lZWRlZCB0byBhY2NvbW1vZGF0ZSBhIGxvZ2ljYWwgcm93XG4gICAgY29uc3QgdGV4ZWxzSW5Mb2dpY2FsUm93ID0gTWF0aC5jZWlsKHNoYXBlWzFdIC8gMik7XG5cbiAgICAvKipcbiAgICAgKiBnZXRPdXRwdXRDb29yZHNcbiAgICAgKlxuICAgICAqIHJlc1RleFJDOiBUaGUgcm93cyBhbmQgY29sdW1ucyBvZiB0aGUgdGV4ZWxzLiBJZiB5b3UgbW92ZSBvdmVyIG9uZVxuICAgICAqIHRleGVsIHRvIHRoZSByaWdodCBpbiB0aGUgcGFja2VkIHRleHR1cmUsIHlvdSBhcmUgbW92aW5nIG92ZXIgb25lIGNvbHVtblxuICAgICAqIChub3QgdHdvKS5cbiAgICAgKlxuICAgICAqIGluZGV4OiBUaGUgdGV4ZWwgaW5kZXhcbiAgICAgKi9cbiAgICBzb3VyY2UgPSBgXG4gICAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtwYWNrZWRUZXhTaGFwZVswXX0sICR7cGFja2VkVGV4U2hhcGVbMV19KSk7XG5cbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHtwYWNrZWRUZXhTaGFwZVswXX0gKyByZXNUZXhSQy54O1xuXG4gICAgICAgICAgLy8gcmV2ZXJzZSByIGFuZCBjIG9yZGVyIGZvciBwYWNrZWQgdGV4dHVyZVxuICAgICAgICAgIGludCByID0gaW1vZChpbmRleCwgJHt0ZXhlbHNJbkxvZ2ljYWxSb3d9KSAqIDI7XG4gICAgICAgICAgaW50IGMgPSAyICogKGluZGV4IC8gJHt0ZXhlbHNJbkxvZ2ljYWxSb3d9KTtcblxuICAgICAgICAgIHJldHVybiBpdmVjMihyLCBjKTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogM0QgcGFja2VkIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRQYWNrZWQzRENvb3JkcyhzaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCB0ZXhTaGFwZTogW251bWJlciwgbnVtYmVyXSk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBwYWNrZWRUZXhTaGFwZSA9IFt0ZXhTaGFwZVswXSwgdGV4U2hhcGVbMV1dO1xuICAgIGNvbnN0IHRleGVsc0luTG9naWNhbFJvdyA9IE1hdGguY2VpbChzaGFwZVsyXSAvIDIpO1xuICAgIGNvbnN0IHRleGVsc0luQmF0Y2ggPSB0ZXhlbHNJbkxvZ2ljYWxSb3cgKiBNYXRoLmNlaWwoc2hhcGVbMV0gLyAyKTtcbiAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgIGl2ZWMzIGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHtwYWNrZWRUZXhTaGFwZVswXX0sICR7cGFja2VkVGV4U2hhcGVbMV19KSk7XG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7cGFja2VkVGV4U2hhcGVbMF19ICsgcmVzVGV4UkMueDtcblxuICAgICAgICAgIGludCBiID0gaW5kZXggLyAke3RleGVsc0luQmF0Y2h9O1xuICAgICAgICAgIGluZGV4IC09IGIgKiAke3RleGVsc0luQmF0Y2h9O1xuXG4gICAgICAgICAgLy8gcmV2ZXJzZSByIGFuZCBjIG9yZGVyIGZvciBwYWNrZWQgdGV4dHVyZVxuICAgICAgICAgIGludCByID0gaW1vZChpbmRleCwgJHt0ZXhlbHNJbkxvZ2ljYWxSb3d9KSAqIDI7XG4gICAgICAgICAgaW50IGMgPSAyICogKGluZGV4IC8gJHt0ZXhlbHNJbkxvZ2ljYWxSb3d9KTtcblxuICAgICAgICAgIHJldHVybiBpdmVjMyhiLCByLCBjKTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogTkQgcGFja2VkIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRQYWNrZWRORENvb3JkcyhzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdKTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHBhY2tlZFRleFNoYXBlID0gW3RleFNoYXBlWzBdLCB0ZXhTaGFwZVsxXV07XG5cbiAgICBjb25zdCB0ZXhlbHNJbkxvZ2ljYWxSb3cgPSBNYXRoLmNlaWwoc2hhcGVbc2hhcGUubGVuZ3RoIC0gMV0gLyAyKTtcbiAgICBjb25zdCB0ZXhlbHNJbkJhdGNoID0gdGV4ZWxzSW5Mb2dpY2FsUm93ICogTWF0aC5jZWlsKHNoYXBlW3NoYXBlLmxlbmd0aCAtIDJdIC8gMik7XG4gICAgbGV0IHRleGVsc0luQmF0Y2hOID0gdGV4ZWxzSW5CYXRjaDtcbiAgICBsZXQgYmF0Y2hlcyA9ICcnO1xuICAgIGxldCBjb29yZHMgPSAnYiwgciwgYyc7XG5cbiAgICBmb3IgKGxldCBiID0gMjsgYiA8IHNoYXBlLmxlbmd0aCAtIDE7IGIrKykge1xuICAgICAgdGV4ZWxzSW5CYXRjaE4gKj0gc2hhcGVbc2hhcGUubGVuZ3RoIC0gYiAtIDFdO1xuICAgICAgYmF0Y2hlcyA9IGBcbiAgICAgIGludCBiJHtifSA9IGluZGV4IC8gJHt0ZXhlbHNJbkJhdGNoTn07XG4gICAgICBpbmRleCAtPSBiJHtifSAqICR7dGV4ZWxzSW5CYXRjaE59O1xuICAgIGAgKyBiYXRjaGVzO1xuICAgICAgY29vcmRzID0gYGIke2J9LCBgICsgY29vcmRzO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICBpdmVjJHtzaGFwZS5sZW5ndGh9IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3BhY2tlZFRleFNoYXBlWzBdfSwgJHtwYWNrZWRUZXhTaGFwZVsxXX0pKTtcbiAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7cGFja2VkVGV4U2hhcGVbMF19ICsgcmVzVGV4UkMueDtcblxuICAgICAgICAke2JhdGNoZXN9XG5cbiAgICAgICAgaW50IGIgPSBpbmRleCAvICR7dGV4ZWxzSW5CYXRjaH07XG4gICAgICAgIGluZGV4IC09IGIgKiAke3RleGVsc0luQmF0Y2h9O1xuXG4gICAgICAgIC8vIHJldmVyc2UgciBhbmQgYyBvcmRlciBmb3IgcGFja2VkIHRleHR1cmVcbiAgICAgICAgaW50IHIgPSBpbW9kKGluZGV4LCAke3RleGVsc0luTG9naWNhbFJvd30pICogMjtcbiAgICAgICAgaW50IGMgPSAyICogKGluZGV4IC8gJHt0ZXhlbHNJbkxvZ2ljYWxSb3d9KTtcblxuICAgICAgICByZXR1cm4gaXZlYyR7c2hhcGUubGVuZ3RofSgke2Nvb3Jkc30pO1xuICAgICAgfVxuICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDFEIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRVbnBhY2tlZDFEQ29vcmRzKF9zaGFwZTogW251bWJlcl0sIHRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdKTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgaW50IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0ZXhTaGFwZVswXX0sICR7dGV4U2hhcGVbMV19KSk7XG4gICAgICAgICAgcmV0dXJuIHJlc1RleFJDLnkgKiAke3RleFNoYXBlWzBdfSArIHJlc1RleFJDLng7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDJEIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRVbnBhY2tlZDJEQ29vcmRzKHNoYXBlOiBbbnVtYmVyLCBudW1iZXJdLCB0ZXhTaGFwZTogW251bWJlciwgbnVtYmVyXSk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0ZXhTaGFwZVswXX0sICR7dGV4U2hhcGVbMV19KSk7XG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7dGV4U2hhcGVbMF19ICsgcmVzVGV4UkMueDtcbiAgICAgICAgICBpbnQgciA9IGluZGV4IC8gJHtzaGFwZVsxXX07XG4gICAgICAgICAgaW50IGMgPSBpbmRleCAtIHIgKiAke3NoYXBlWzFdfTtcbiAgICAgICAgICByZXR1cm4gaXZlYzIociwgYyk7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDNEIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRVbnBhY2tlZDNEQ29vcmRzKHNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIHRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdKTogR2xzbExpYlJvdXRpbmUge1xuICAgIGxldCBzb3VyY2UgPSAnJztcbiAgICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuXG4gICAgbGV0IHN0cmlkZXMgPSBudWxsO1xuICAgIGlmIChyYW5rIDwgMikge1xuICAgICAgc3RyaWRlcyA9IFtdO1xuICAgIH1cblxuICAgIHN0cmlkZXMgPSBuZXcgQXJyYXkocmFuayAtIDEpO1xuICAgIHN0cmlkZXNbcmFuayAtIDJdID0gc2hhcGVbcmFuayAtIDFdO1xuICAgIGZvciAobGV0IGkgPSByYW5rIC0gMzsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHN0cmlkZXNbaV0gPSBzdHJpZGVzW2kgKyAxXSAqIHNoYXBlW2kgKyAxXTtcbiAgICB9XG4gICAgY29uc3QgY29vcmRzVG9Db21wdXRlID0gWydyJywgJ2MnLCAnZCddO1xuICAgIGNvbnN0IGNvb3Jkc0Zyb21JbmRleFNuaXBwZXQgPVxuICAgICAgICBzdHJpZGVzXG4gICAgICAgICAgICAubWFwKChzdHJpZGUsIGkpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbGluZTEgPSBgaW50ICR7Y29vcmRzVG9Db21wdXRlW2ldfSA9IGluZGV4IC8gJHtzdHJpZGV9YDtcbiAgICAgICAgICAgICAgY29uc3QgbGluZTIgPSBpID09PSBzdHJpZGVzLmxlbmd0aCAtIDEgP1xuICAgICAgICAgICAgICAgICAgYGludCAke2Nvb3Jkc1RvQ29tcHV0ZVtpICsgMV19ID0gaW5kZXggLSAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gKiAke3N0cmlkZX1gIDpcbiAgICAgICAgICAgICAgICAgIGBpbmRleCAtPSAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gKiAke3N0cmlkZX1gO1xuICAgICAgICAgICAgICByZXR1cm4gYCR7bGluZTF9OyAke2xpbmUyfTtgO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcnKTtcblxuICAgIHNvdXJjZSA9IGBcbiAgICAgICAgaXZlYzMgZ2V0T3V0cHV0Q29vcmRzKCkge1xuICAgICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIoVGV4Q29vcmRzLnh5ICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3RleFNoYXBlWzBdfSwgJHt0ZXhTaGFwZVsxXX0pKTtcbiAgICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy55ICogJHt0ZXhTaGFwZVswXX0gKyByZXNUZXhSQy54O1xuICAgICAgICAgICR7Y29vcmRzRnJvbUluZGV4U25pcHBldH1cbiAgICAgICAgICByZXR1cm4gaXZlYzMociwgYywgZCk7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDREIG91dHB1dCBjb29yZGluYXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRPdXRwdXRVbnBhY2tlZDREQ29vcmRzKHNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgdGV4U2hhcGU6IFtudW1iZXIsIG51bWJlcl0pOlxuICAgICAgR2xzbExpYlJvdXRpbmUge1xuICAgIGxldCBzb3VyY2UgPSAnJztcbiAgICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuXG4gICAgbGV0IHN0cmlkZXMgPSBudWxsO1xuICAgIGlmIChyYW5rIDwgMikge1xuICAgICAgc3RyaWRlcyA9IFtdO1xuICAgIH1cblxuICAgIHN0cmlkZXMgPSBuZXcgQXJyYXkocmFuayAtIDEpO1xuICAgIHN0cmlkZXNbcmFuayAtIDJdID0gc2hhcGVbcmFuayAtIDFdO1xuICAgIGZvciAobGV0IGkgPSByYW5rIC0gMzsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHN0cmlkZXNbaV0gPSBzdHJpZGVzW2kgKyAxXSAqIHNoYXBlW2kgKyAxXTtcbiAgICB9XG4gICAgY29uc3QgY29vcmRzVG9Db21wdXRlID0gWydyJywgJ2MnLCAnZCcsICdkMiddO1xuICAgIGNvbnN0IGNvb3Jkc0Zyb21JbmRleFNuaXBwZXQgPVxuICAgICAgICBzdHJpZGVzXG4gICAgICAgICAgICAubWFwKChzdHJpZGUsIGkpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbGluZTEgPSBgaW50ICR7Y29vcmRzVG9Db21wdXRlW2ldfSA9IGluZGV4IC8gJHtzdHJpZGV9YDtcbiAgICAgICAgICAgICAgY29uc3QgbGluZTIgPSBpID09PSBzdHJpZGVzLmxlbmd0aCAtIDEgP1xuICAgICAgICAgICAgICAgICAgYGludCAke2Nvb3Jkc1RvQ29tcHV0ZVtpICsgMV19ID0gaW5kZXggLSAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gKiAke3N0cmlkZX1gIDpcbiAgICAgICAgICAgICAgICAgIGBpbmRleCAtPSAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gKiAke3N0cmlkZX1gO1xuICAgICAgICAgICAgICByZXR1cm4gYCR7bGluZTF9OyAke2xpbmUyfTtgO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcnKTtcblxuICAgIHNvdXJjZSA9IGBcbiAgICAgIGl2ZWM0IGdldE91dHB1dENvb3JkcygpIHtcbiAgICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoJHt0ZXhTaGFwZVswXX0sICR7dGV4U2hhcGVbMV19KSk7XG4gICAgICAgICAgaW50IGluZGV4ID0gcmVzVGV4UkMueSAqICR7dGV4U2hhcGVbMF19ICsgcmVzVGV4UkMueDtcbiAgICAgICAgICAke2Nvb3Jkc0Zyb21JbmRleFNuaXBwZXR9XG4gICAgICAgICAgcmV0dXJuIGl2ZWM0KHIsIGMsIGQsIGQyKTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wYWNrZWQgNUQgb3V0cHV0IGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldE91dHB1dFVucGFja2VkNURDb29yZHMoc2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIHRleFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdKTpcbiAgICAgIEdsc2xMaWJSb3V0aW5lIHtcbiAgICBsZXQgc291cmNlID0gJyc7XG4gICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcblxuICAgIGxldCBzdHJpZGVzID0gbnVsbDtcbiAgICBpZiAocmFuayA8IDIpIHtcbiAgICAgIHN0cmlkZXMgPSBbXTtcbiAgICB9XG5cbiAgICBzdHJpZGVzID0gbmV3IEFycmF5KHJhbmsgLSAxKTtcbiAgICBzdHJpZGVzW3JhbmsgLSAyXSA9IHNoYXBlW3JhbmsgLSAxXTtcbiAgICBmb3IgKGxldCBpID0gcmFuayAtIDM7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBzdHJpZGVzW2ldID0gc3RyaWRlc1tpICsgMV0gKiBzaGFwZVtpICsgMV07XG4gICAgfVxuICAgIGNvbnN0IGNvb3Jkc1RvQ29tcHV0ZSA9IFsncicsICdjJywgJ2QnLCAnZDInLCAnZDMnXTtcbiAgICBjb25zdCBjb29yZHNGcm9tSW5kZXhTbmlwcGV0ID1cbiAgICAgICAgc3RyaWRlc1xuICAgICAgICAgICAgLm1hcCgoc3RyaWRlLCBpKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGxpbmUxID0gYGludCAke2Nvb3Jkc1RvQ29tcHV0ZVtpXX0gPSBpbmRleCAvICR7c3RyaWRlfWA7XG4gICAgICAgICAgICAgIGNvbnN0IGxpbmUyID0gaSA9PT0gc3RyaWRlcy5sZW5ndGggLSAxID9cbiAgICAgICAgICAgICAgICAgIGBpbnQgJHtjb29yZHNUb0NvbXB1dGVbaSArIDFdfSA9IGluZGV4IC0gJHtjb29yZHNUb0NvbXB1dGVbaV19ICogJHtzdHJpZGV9YCA6XG4gICAgICAgICAgICAgICAgICBgaW5kZXggLT0gJHtjb29yZHNUb0NvbXB1dGVbaV19ICogJHtzdHJpZGV9YDtcbiAgICAgICAgICAgICAgcmV0dXJuIGAke2xpbmUxfTsgJHtsaW5lMn07YDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignJyk7XG5cbiAgICBzb3VyY2UgPSBgXG4gICAgICBpdmVjNSBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgICAgaXZlYzIgcmVzVGV4UkMgPSBpdmVjMihUZXhDb29yZHMueHkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKCR7dGV4U2hhcGVbMF19LCAke3RleFNoYXBlWzFdfSkpO1xuICAgICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke3RleFNoYXBlWzBdfSArIHJlc1RleFJDLng7XG4gICAgICAgICAgJHtjb29yZHNGcm9tSW5kZXhTbmlwcGV0fVxuICAgICAgICAgIHJldHVybiBpdmVjNShyLCBjLCBkLCBkMiwgZDMpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBhY2tlZCA2RCBvdXRwdXQgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0T3V0cHV0VW5wYWNrZWQ2RENvb3JkcyhzaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLCB0ZXhTaGFwZTogW1xuICAgIG51bWJlciwgbnVtYmVyXG4gIF0pOiBHbHNsTGliUm91dGluZSB7XG4gICAgbGV0IHNvdXJjZSA9ICcnO1xuICAgIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG5cbiAgICBsZXQgc3RyaWRlcyA9IG51bGw7XG4gICAgaWYgKHJhbmsgPCAyKSB7XG4gICAgICBzdHJpZGVzID0gW107XG4gICAgfVxuXG4gICAgc3RyaWRlcyA9IG5ldyBBcnJheShyYW5rIC0gMSk7XG4gICAgc3RyaWRlc1tyYW5rIC0gMl0gPSBzaGFwZVtyYW5rIC0gMV07XG4gICAgZm9yIChsZXQgaSA9IHJhbmsgLSAzOyBpID49IDA7IC0taSkge1xuICAgICAgc3RyaWRlc1tpXSA9IHN0cmlkZXNbaSArIDFdICogc2hhcGVbaSArIDFdO1xuICAgIH1cbiAgICBjb25zdCBjb29yZHNUb0NvbXB1dGUgPSBbJ3InLCAnYycsICdkJywgJ2QyJywgJ2QzJywgJ2Q0J107XG4gICAgY29uc3QgY29vcmRzRnJvbUluZGV4U25pcHBldCA9XG4gICAgICAgIHN0cmlkZXNcbiAgICAgICAgICAgIC5tYXAoKHN0cmlkZSwgaSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBsaW5lMSA9IGBpbnQgJHtjb29yZHNUb0NvbXB1dGVbaV19ID0gaW5kZXggLyAke3N0cmlkZX1gO1xuICAgICAgICAgICAgICBjb25zdCBsaW5lMiA9IGkgPT09IHN0cmlkZXMubGVuZ3RoIC0gMSA/XG4gICAgICAgICAgICAgICAgICBgaW50ICR7Y29vcmRzVG9Db21wdXRlW2kgKyAxXX0gPSBpbmRleCAtICR7Y29vcmRzVG9Db21wdXRlW2ldfSAqICR7c3RyaWRlfWAgOlxuICAgICAgICAgICAgICAgICAgYGluZGV4IC09ICR7Y29vcmRzVG9Db21wdXRlW2ldfSAqICR7c3RyaWRlfWA7XG4gICAgICAgICAgICAgIHJldHVybiBgJHtsaW5lMX07ICR7bGluZTJ9O2A7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJycpO1xuXG4gICAgc291cmNlID0gYFxuICAgICBpdmVjNiBnZXRPdXRwdXRDb29yZHMoKSB7XG4gICAgICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKFRleENvb3Jkcy54eSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMigke3RleFNoYXBlWzBdfSwgJHt0ZXhTaGFwZVsxXX0pKTtcbiAgICAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnkgKiAke3RleFNoYXBlWzBdfSArIHJlc1RleFJDLng7XG4gICAgICAgICAke2Nvb3Jkc0Zyb21JbmRleFNuaXBwZXR9XG4gICAgICAgICByZXR1cm4gaXZlYzYociwgYywgZCwgZDIsIGQzLCBkNCk7XG4gICAgICAgfVxuICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgY29kZSBmb3IgY29tbW9uIFVWIGNvb3JkcyBjb21wdXRhdGlvbiB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRDb21tb25VdGlsRnVuY3MoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IHJlc3VsdDoge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0gPSB7fTtcbiAgICBsZXQgZnVuY05hbWUgPSAndXZGcm9tRmxhdCc7XG4gICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShgXG4gICAgdmVjMiB1dkZyb21GbGF0KGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IGluZGV4KSB7XG4gICAgICBpbnQgdGV4QyA9IGluZGV4IC8gdGV4TnVtUjtcbiAgICAgIGludCB0ZXhSID0gaW5kZXggLSB0ZXhDICogdGV4TnVtUjtcbiAgICAgIC8vIFRPRE86IHN3YXAgdGV4UiwgdGV4QyBvcmRlciBpbiBmb2xsb3dpbmcgZnVuY3Rpb24gc28gcm93IGlzIGNvcnJlc3BvbmRpbmcgdG8gdSBhbmQgY29sdW1uIGlzIGNvcnJlc3BvbmRpbmcgdG9cbiAgICAgIC8vICAgICAgIHYuXG4gICAgICByZXR1cm4gKHZlYzIodGV4UiwgdGV4QykgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1SLCB0ZXhOdW1DKTtcbiAgICB9XG4gICAgYCk7XG4gICAgZnVuY05hbWUgPSAncGFja2VkVVZmcm9tMUQnO1xuICAgIHJlc3VsdFtmdW5jTmFtZV0gPSBuZXcgR2xzbExpYlJvdXRpbmUoYFxuICAgICAgdmVjMiBwYWNrZWRVVmZyb20xRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBpbmRleCkge1xuICAgICAgICBpbnQgdGV4ZWxJbmRleCA9IGluZGV4IC8gMjtcbiAgICAgICAgaW50IHRleFIgPSB0ZXhlbEluZGV4IC8gdGV4TnVtQztcbiAgICAgICAgaW50IHRleEMgPSB0ZXhlbEluZGV4IC0gdGV4UiAqIHRleE51bUM7XG4gICAgICAgIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xuICAgICAgfVxuICAgICAgYCk7XG4gICAgZnVuY05hbWUgPSAncGFja2VkVVZmcm9tMkQnO1xuICAgIHJlc3VsdFtmdW5jTmFtZV0gPSBuZXcgR2xzbExpYlJvdXRpbmUoYFxuICAgICAgdmVjMiBwYWNrZWRVVmZyb20yRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCB0ZXhlbHNJbkxvZ2ljYWxSb3csIGludCByb3csIGludCBjb2wpIHtcbiAgICAgICAgaW50IHRleGVsSW5kZXggPSAocm93IC8gMikgKiB0ZXhlbHNJbkxvZ2ljYWxSb3cgKyAoY29sIC8gMik7XG4gICAgICAgIGludCB0ZXhSID0gdGV4ZWxJbmRleCAvIHRleE51bUM7XG4gICAgICAgIGludCB0ZXhDID0gdGV4ZWxJbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xuICAgICAgICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcbiAgICAgIH1cbiAgICAgIGApO1xuICAgIGZ1bmNOYW1lID0gJ3BhY2tlZFVWZnJvbTNEJztcbiAgICByZXN1bHRbZnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKGBcbiAgICAgIHZlYzIgcGFja2VkVVZmcm9tM0QoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLFxuICAgICAgICAgIGludCB0ZXhlbHNJbkJhdGNoLCBpbnQgdGV4ZWxzSW5Mb2dpY2FsUm93LCBpbnQgYixcbiAgICAgICAgICBpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgIGludCBpbmRleCA9IGIgKiB0ZXhlbHNJbkJhdGNoICsgKHJvdyAvIDIpICogdGV4ZWxzSW5Mb2dpY2FsUm93ICsgKGNvbCAvIDIpO1xuICAgICAgICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcbiAgICAgICAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xuICAgICAgICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcbiAgICAgIH1cbiAgICAgIGApO1xuICAgIGZ1bmNOYW1lID0gJ3NhbXBsZVRleHR1cmUnO1xuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShgXG4gICAgICAgIGZsb2F0IHNhbXBsZVRleHR1cmUoc2FtcGxlcjJEIHRleHR1cmVTYW1wbGVyLCB2ZWMyIHV2KSB7XG4gICAgICAgICAgICByZXR1cm4gJHtnbHNsLnRleHR1cmUyRH0odGV4dHVyZVNhbXBsZXIsIHV2KS5yO1xuICAgICAgICB9YCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Rpbmcgc25pcHBldHMgZm9yIGlucHV0c1xuICAgKi9cbiAgcHJvdGVjdGVkIGdldElucHV0c1NhbXBsaW5nU25pcHBldHMoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IHJlc3VsdDoge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0gPSB7fTtcbiAgICBjb25zdCBvdXRwdXRMYXlvdXQgPSB0aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dDtcbiAgICB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKChzYW1wbGVyTmFtZSwgaSkgPT4ge1xuICAgICAgY29uc3QgaW5wdXRMYXlvdXQgPSB0aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tpXTtcbiAgICAgIGNvbnN0IGZ1bmNOYW1lID0gZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lKHNhbXBsZXJOYW1lKTtcbiAgICAgIGlmIChpbnB1dExheW91dC5pc1BhY2tlZCkge1xuICAgICAgICByZXN1bHRbZnVuY05hbWVdID0gdGhpcy5nZXRQYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lLCBzYW1wbGVyTmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IHRoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lLCBzYW1wbGVyTmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvdXRDb29yZEZ1bmNOYW1lID0gZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lQXRPdXRDb29yZHMoc2FtcGxlck5hbWUpO1xuICAgICAgaWYgKGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGUubGVuZ3RoIDw9IG91dHB1dExheW91dC51bnBhY2tlZFNoYXBlLmxlbmd0aCkge1xuICAgICAgICBpZiAoaW5wdXRMYXlvdXQuaXNQYWNrZWQpIHtcbiAgICAgICAgICByZXN1bHRbb3V0Q29vcmRGdW5jTmFtZV0gPVxuICAgICAgICAgICAgICB0aGlzLmdldFBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3JkcyhvdXRDb29yZEZ1bmNOYW1lLCBpbnB1dExheW91dCwgb3V0cHV0TGF5b3V0LCBzYW1wbGVyTmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W291dENvb3JkRnVuY05hbWVdID1cbiAgICAgICAgICAgICAgdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3JkcyhvdXRDb29yZEZ1bmNOYW1lLCBpbnB1dExheW91dCwgb3V0cHV0TGF5b3V0LCBzYW1wbGVyTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0aW5nIHNuaXBwZXRzIGZvciBvdXRwdXQgY29vcmRpbmF0ZXMgb2Ygc2FtcGxlcnNcbiAgICovXG4gIHByb3RlY3RlZCBnZXRQYWNrZWRTYW1wbGVyQXRPdXRwdXRDb29yZHMoXG4gICAgICBmdW5jTmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCwgb3V0cHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0LCBuYW1lOiBzdHJpbmcpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3QgaW5TaGFwZSA9IGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGU7XG4gICAgY29uc3Qgb3V0U2hhcGUgPSBvdXRwdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCB0ZXhOYW1lID0gbmFtZTtcbiAgICBjb25zdCB0ZXhGdW5jU25pcHBldCA9IGdlbmVyYXRlU2hhZGVyRnVuY05hbWVGcm9tSW5wdXRTYW1wbGVyTmFtZSh0ZXhOYW1lKTtcblxuICAgIGNvbnN0IGluUmFuayA9IGluU2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IG91dFJhbmsgPSBvdXRTaGFwZS5sZW5ndGg7XG5cbiAgICBjb25zdCBicm9hZGNhc3REaW1zID0gQnJvYWRjYXN0VXRpbC5nZXRCcm9hZGNhc3REaW1zKGluU2hhcGUsIG91dFNoYXBlKTtcblxuICAgIGNvbnN0IHR5cGUgPSBnZXRDb29yZHNEYXRhVHlwZShvdXRSYW5rKTtcbiAgICBjb25zdCByYW5rRGlmZiA9IG91dFJhbmsgLSBpblJhbms7XG4gICAgbGV0IGNvb3Jkc1NuaXBwZXQ6IHN0cmluZztcbiAgICBjb25zdCBmaWVsZHMgPSBnZXRHbENoYW5uZWxzKCk7XG5cbiAgICBpZiAoaW5SYW5rID09PSAwKSB7XG4gICAgICBjb29yZHNTbmlwcGV0ID0gJyc7XG4gICAgfSBlbHNlIGlmIChvdXRSYW5rIDwgMiAmJiBicm9hZGNhc3REaW1zLmxlbmd0aCA+PSAxKSB7XG4gICAgICBjb29yZHNTbmlwcGV0ID0gJ2Nvb3JkcyA9IDA7JztcbiAgICB9IGVsc2Uge1xuICAgICAgY29vcmRzU25pcHBldCA9IGJyb2FkY2FzdERpbXMubWFwKGQgPT4gYGNvb3Jkcy4ke2ZpZWxkc1tkICsgcmFua0RpZmZdfSA9IDA7YCkuam9pbignXFxuJyk7XG4gICAgfVxuICAgIGxldCB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSAnJztcbiAgICBpZiAob3V0UmFuayA8IDIgJiYgaW5SYW5rID4gMCkge1xuICAgICAgdW5wYWNrZWRDb29yZHNTbmlwcGV0ID0gJ2Nvb3Jkcyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVucGFja2VkQ29vcmRzU25pcHBldCA9IGluU2hhcGUubWFwKChfcywgaSkgPT4gYGNvb3Jkcy4ke2ZpZWxkc1tpICsgcmFua0RpZmZdfWApLmpvaW4oJywgJyk7XG4gICAgfVxuXG4gICAgbGV0IG91dHB1dCA9ICdyZXR1cm4gb3V0cHV0VmFsdWU7JztcbiAgICBjb25zdCBpblNpemUgPSBTaGFwZVV0aWwuc2l6ZShpblNoYXBlKTtcbiAgICBjb25zdCBpc0lucHV0U2NhbGFyID0gaW5TaXplID09PSAxO1xuICAgIGNvbnN0IG91dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRTaGFwZSk7XG4gICAgY29uc3QgaXNPdXRwdXRTY2FsYXIgPSBvdXRTaXplID09PSAxO1xuXG4gICAgaWYgKGluUmFuayA9PT0gMSAmJiAhaXNJbnB1dFNjYWxhciAmJiAhaXNPdXRwdXRTY2FsYXIpIHtcbiAgICAgIG91dHB1dCA9IGBcbiAgICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueHksIG91dHB1dFZhbHVlLnh5KTtcbiAgICAgIGA7XG4gICAgfSBlbHNlIGlmIChpc0lucHV0U2NhbGFyICYmICFpc091dHB1dFNjYWxhcikge1xuICAgICAgaWYgKG91dFJhbmsgPT09IDEpIHtcbiAgICAgICAgb3V0cHV0ID0gYFxuICAgICAgICAgIHJldHVybiB2ZWM0KG91dHB1dFZhbHVlLngsIG91dHB1dFZhbHVlLngsIDAuLCAwLik7XG4gICAgICAgIGA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQgPSBgXG4gICAgICAgICAgcmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCk7XG4gICAgICAgIGA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChicm9hZGNhc3REaW1zLmxlbmd0aCkge1xuICAgICAgY29uc3Qgcm93cyA9IGluUmFuayAtIDI7XG4gICAgICBjb25zdCBjb2xzID0gaW5SYW5rIC0gMTtcblxuICAgICAgaWYgKGJyb2FkY2FzdERpbXMuaW5kZXhPZihyb3dzKSA+IC0xICYmIGJyb2FkY2FzdERpbXMuaW5kZXhPZihjb2xzKSA+IC0xKSB7XG4gICAgICAgIG91dHB1dCA9ICdyZXR1cm4gdmVjNChvdXRwdXRWYWx1ZS54KTsnO1xuICAgICAgfSBlbHNlIGlmIChicm9hZGNhc3REaW1zLmluZGV4T2Yocm93cykgPiAtMSkge1xuICAgICAgICBvdXRwdXQgPSAncmV0dXJuIHZlYzQob3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSwgJyArXG4gICAgICAgICAgICAnb3V0cHV0VmFsdWUueCwgb3V0cHV0VmFsdWUueSk7JztcbiAgICAgIH0gZWxzZSBpZiAoYnJvYWRjYXN0RGltcy5pbmRleE9mKGNvbHMpID4gLTEpIHtcbiAgICAgICAgb3V0cHV0ID0gJ3JldHVybiB2ZWM0KG91dHB1dFZhbHVlLnh4LCBvdXRwdXRWYWx1ZS56eik7JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzd2FwTGFzdERpbXNTbmlwcGV0ID0gYFxuICAgICAgICBpbnQgbGFzdERpbSA9IGNvb3Jkcy4ke2ZpZWxkc1tvdXRSYW5rIC0gMV19O1xuICAgICAgICBjb29yZHMuJHtmaWVsZHNbb3V0UmFuayAtIDFdfSA9IGNvb3Jkcy4ke2ZpZWxkc1tvdXRSYW5rIC0gMl19O1xuICAgICAgICBjb29yZHMuJHtmaWVsZHNbb3V0UmFuayAtIDJdfSA9IGxhc3REaW07XG4gICAgICBgO1xuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgIHZlYzQgJHtmdW5jTmFtZX0oKSB7XG4gICAgICAgICR7dHlwZX0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgICR7c3dhcExhc3REaW1zU25pcHBldH1cbiAgICAgICAgJHtjb29yZHNTbmlwcGV0fVxuICAgICAgICB2ZWM0IG91dHB1dFZhbHVlID0gJHt0ZXhGdW5jU25pcHBldH0oJHt1bnBhY2tlZENvb3Jkc1NuaXBwZXR9KTtcbiAgICAgICAgJHtvdXRwdXR9XG4gICAgICB9XG4gICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5nZXRPdXRwdXRDb29yZHMnXSk7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0aW5nIHNuaXBwZXRzIGZvciB1bnBhY2tlZCBvdXRwdXQgY29vcmRpbmF0ZXMgb2Ygc2FtcGxlcnNcbiAgICovXG4gIHByb3RlY3RlZCBnZXRVbnBhY2tlZFNhbXBsZXJBdE91dHB1dENvb3JkcyhcbiAgICAgIGZ1bmNOYW1lOiBzdHJpbmcsIGlucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0LCBvdXRwdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQsIG5hbWU6IHN0cmluZyk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBvdXRUZXhTaGFwZSA9IFtvdXRwdXRMYXlvdXQud2lkdGgsIG91dHB1dExheW91dC5oZWlnaHRdO1xuICAgIGNvbnN0IGluVGV4U2hhcGUgPSBbaW5wdXRMYXlvdXQud2lkdGgsIGlucHV0TGF5b3V0LmhlaWdodF07XG4gICAgY29uc3QgaW5SYW5rID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZS5sZW5ndGg7XG4gICAgY29uc3Qgb3V0UmFuayA9IG91dHB1dExheW91dC51bnBhY2tlZFNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBpblNoYXBlID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCBvdXRTaGFwZSA9IG91dHB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IHRleEZ1bmNTbmlwcGV0ID0gZ2VuZXJhdGVTaGFkZXJGdW5jTmFtZUZyb21JbnB1dFNhbXBsZXJOYW1lKG5hbWUpO1xuXG4gICAgaWYgKGluUmFuayA9PT0gb3V0UmFuayAmJiBBcnJheVV0aWwuYXJyYXlzRXF1YWwoaW5UZXhTaGFwZSwgb3V0VGV4U2hhcGUpKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oKSB7XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke25hbWV9LCBUZXhDb29yZHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnXSk7XG4gICAgfVxuXG4gICAgY29uc3QgdHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKG91dFJhbmspO1xuICAgIGNvbnN0IGJyb2FkY2FzdERpbXMgPSBCcm9hZGNhc3RVdGlsLmdldEJyb2FkY2FzdERpbXMoaW5TaGFwZSwgb3V0U2hhcGUpO1xuICAgIGNvbnN0IHJhbmtEaWZmID0gb3V0UmFuayAtIGluUmFuaztcbiAgICBsZXQgY29vcmRzU25pcHBldDogc3RyaW5nO1xuICAgIGNvbnN0IGZpZWxkcyA9IGdldEdsQ2hhbm5lbHMoKTtcblxuICAgIGlmIChpblJhbmsgPT09IDApIHtcbiAgICAgIGNvb3Jkc1NuaXBwZXQgPSAnJztcbiAgICB9IGVsc2UgaWYgKG91dFJhbmsgPCAyICYmIGJyb2FkY2FzdERpbXMubGVuZ3RoID49IDEpIHtcbiAgICAgIGNvb3Jkc1NuaXBwZXQgPSAnY29vcmRzID0gMDsnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb29yZHNTbmlwcGV0ID0gYnJvYWRjYXN0RGltcy5tYXAoZCA9PiBgY29vcmRzLiR7ZmllbGRzW2QgKyByYW5rRGlmZl19ID0gMDtgKS5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgbGV0IHVucGFja2VkQ29vcmRzU25pcHBldCA9ICcnO1xuICAgIGlmIChvdXRSYW5rIDwgMiAmJiBpblJhbmsgPiAwKSB7XG4gICAgICB1bnBhY2tlZENvb3Jkc1NuaXBwZXQgPSAnY29vcmRzJztcbiAgICB9IGVsc2Uge1xuICAgICAgdW5wYWNrZWRDb29yZHNTbmlwcGV0ID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZS5tYXAoKF9zLCBpKSA9PiBgY29vcmRzLiR7ZmllbGRzW2kgKyByYW5rRGlmZl19YCkuam9pbignLCAnKTtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfSgpIHtcbiAgICAgICAgICAke3R5cGV9IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICAgICR7Y29vcmRzU25pcHBldH1cbiAgICAgICAgICByZXR1cm4gJHt0ZXhGdW5jU25pcHBldH0oJHt1bnBhY2tlZENvb3Jkc1NuaXBwZXR9KTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5nZXRPdXRwdXRDb29yZHMnXSk7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0aW5nIHNuaXBwZXRzIGZvciBwYWNrZWQgb3BlcmF0aW9ucy5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRQYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgc3dpdGNoIChpbnB1dExheW91dC51bnBhY2tlZFNoYXBlLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyU2NhbGFyKGZ1bmNOYW1lLCBuYW1lKTtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFja2VkU2FtcGxlcjFEKGZ1bmNOYW1lLCBuYW1lLCBpbnB1dExheW91dCk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhY2tlZFNhbXBsZXIyRChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYWNrZWRTYW1wbGVyM0QoZnVuY05hbWUsIG5hbWUsIGlucHV0TGF5b3V0KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhY2tlZFNhbXBsZXJORChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3Rpbmcgc25pcHBldHMgZm9yIHVucGFja2VkIG9wZXJhdGlvbnMuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc2hhcGUgPSBpbnB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIHN3aXRjaCAoc2hhcGUubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiB0aGlzLmdldFVucGFja2VkU2FtcGxlclNjYWxhcihmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXIxRChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXIyRChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXIzRChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXI0RChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXI1RChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgY2FzZSA2OlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRVbnBhY2tlZFNhbXBsZXI2RChmdW5jTmFtZSwgbmFtZSwgaW5wdXRMYXlvdXQpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gVE9ETyBzdXBwb3J0IG1vcmUgZGltZW5zaW9uYWxpdGllc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRpbWVuc2lvbiAke3NoYXBlLmxlbmd0aH0tRGApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYWNrZWQgc2NhbGFyIHNuaXBwZXQuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0UGFja2VkU2FtcGxlclNjYWxhcihmdW5jTmFtZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2wodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgdmVjNCAke2Z1bmNOYW1lfSgpIHtcbiAgICAgICAgICAgIHJldHVybiAke2dsc2wudGV4dHVyZTJEfSgke25hbWV9LCBoYWxmQ1IpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogUGFja2VkIDFEIHNuaXBwZXQuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0UGFja2VkU2FtcGxlcjFEKGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3QgdGV4U2hhcGUgPSBbaW5wdXRMYXlvdXQud2lkdGgsIGlucHV0TGF5b3V0LmhlaWdodF07XG4gICAgY29uc3QgcGFja2VkVGV4U2hhcGUgPSBbdGV4U2hhcGVbMV0sIHRleFNoYXBlWzBdXTtcbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbCh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO1xuXG4gICAgY29uc3QgcGFja2VkU2FtcGxlciA9IGB2ZWM0ICR7ZnVuY05hbWV9KGludCBpbmRleCkge1xuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTFEKFxuICAgICAgJHtwYWNrZWRUZXhTaGFwZVswXX0sICR7cGFja2VkVGV4U2hhcGVbMV19LCBpbmRleCk7XG4gICAgICByZXR1cm4gJHtnbHNsLnRleHR1cmUyRH0oJHtuYW1lfSwgdXYpO1xuICAgIH1gO1xuICAgIGNvbnN0IHNvdXJjZSA9IHBhY2tlZFNhbXBsZXI7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMucGFja2VkVVZmcm9tMUQnXSk7XG4gIH1cblxuICAvKipcbiAgICogUGFja2VkIDJEIHNuaXBwZXQuXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0UGFja2VkU2FtcGxlcjJEKGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc2hhcGUgPSBpbnB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IHRleFNoYXBlID0gW2lucHV0TGF5b3V0LndpZHRoLCBpbnB1dExheW91dC5oZWlnaHRdO1xuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgY29uc3QgdGV4TnVtUiA9IHRleFNoYXBlWzBdO1xuICAgIGNvbnN0IHRleE51bUMgPSB0ZXhTaGFwZVsxXTtcblxuICAgIGlmICh0ZXhTaGFwZSAhPSBudWxsICYmIEFycmF5VXRpbC5hcnJheXNFcXVhbChzaGFwZSwgdGV4U2hhcGUpKSB7XG4gICAgICBjb25zdCBwYWNrZWRTYW1wbGVyID0gYHZlYzQgJHtmdW5jTmFtZX0oaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIoY29sLCByb3cpICsgaGFsZkNSKSAvIHZlYzIoJHt0ZXhOdW1DfS4wLCAke3RleE51bVJ9LjApO1xuICAgICAgICByZXR1cm4gJHtnbHNsLnRleHR1cmUyRH0oJHtuYW1lfSwgdXYpO1xuICAgICAgfWA7XG5cbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUocGFja2VkU2FtcGxlcik7XG4gICAgfVxuICAgIGNvbnN0IHBhY2tlZFRleFNoYXBlID0gdGV4U2hhcGU7XG4gICAgY29uc3QgdmFsdWVzUGVyUm93ID0gTWF0aC5jZWlsKHNoYXBlWzFdIC8gMik7XG4gICAgY29uc3QgcGFja2VkU2FtcGxlciA9IGB2ZWM0ICR7ZnVuY05hbWV9KGludCByb3csIGludCBjb2wpIHtcbiAgICAgIHZlYzIgdXYgPSBwYWNrZWRVVmZyb20yRCgke3BhY2tlZFRleFNoYXBlWzFdfSwgJHtwYWNrZWRUZXhTaGFwZVswXX0sICR7dmFsdWVzUGVyUm93fSwgcm93LCBjb2wpO1xuICAgICAgcmV0dXJuICR7Z2xzbC50ZXh0dXJlMkR9KCR7bmFtZX0sIHV2KTtcbiAgICB9YDtcbiAgICBjb25zdCBzb3VyY2UgPSBwYWNrZWRTYW1wbGVyO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnBhY2tlZFVWZnJvbTJEJ10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhY2tlZCAzRCBzbmlwcGV0LlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFBhY2tlZFNhbXBsZXIzRChmdW5jTmFtZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGlucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0KTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHNoYXBlID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCB0ZXhTaGFwZSA9IFtpbnB1dExheW91dC53aWR0aCwgaW5wdXRMYXlvdXQuaGVpZ2h0XTtcbiAgICBjb25zdCBwYWNrZWRUZXhTaGFwZSA9IFt0ZXhTaGFwZVswXSwgdGV4U2hhcGVbMV1dO1xuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbik7XG5cbiAgICBpZiAoc2hhcGVbMF0gPT09IDEpIHtcbiAgICAgIGNvbnN0IHNxdWVlemVkU2hhcGUgPSBzaGFwZS5zbGljZSgxKTtcbiAgICAgIGNvbnN0IGtlcHREaW1zID0gWzEsIDJdO1xuICAgICAgY29uc3QgbmV3SW5wdXRTaGFwZSA9IHNxdWVlemVJbnB1dFNoYXBlKHNoYXBlLCBzcXVlZXplZFNoYXBlKTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFsnYicsICdyb3cnLCAnY29sJ107XG4gICAgICAvLyBEZWVwIGNvcHkgb2YgaW5wdXQgdGV4dHVyZSBsYXlvdXQuXG4gICAgICBjb25zdCBuZXdJbnB1dExheW91dDogVGV4dHVyZUxheW91dCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXRMYXlvdXQpKTtcbiAgICAgIG5ld0lucHV0TGF5b3V0LnVucGFja2VkU2hhcGUgPSBuZXdJbnB1dFNoYXBlO1xuICAgICAgY29uc3Qgc2FtcGxlclJvdXRpbmUgPSB0aGlzLmdldFBhY2tlZFNhbXBsZXJGcm9tSW5wdXQoZnVuY05hbWUsIG5hbWUsIG5ld0lucHV0TGF5b3V0KTtcbiAgICAgIGNvbnN0IHBhY2tlZFNhbXBsZXIgPSBgJHtzYW1wbGVyUm91dGluZS5yb3V0aW5lQm9keX1cbiAgICAgIHZlYzQgJHtmdW5jTmFtZX0oaW50IGIsIGludCByb3csIGludCBjb2wpIHtcbiAgICAgICAgcmV0dXJuICR7ZnVuY05hbWV9KCR7Z2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcyl9KTtcbiAgICAgIH0gYDtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHBhY2tlZFNhbXBsZXI7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgc2FtcGxlclJvdXRpbmUuZGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gICAgY29uc3QgdGV4TnVtUiA9IHBhY2tlZFRleFNoYXBlWzBdO1xuICAgIGNvbnN0IHRleE51bUMgPSBwYWNrZWRUZXhTaGFwZVsxXTtcblxuICAgIGNvbnN0IHZhbHVlc1BlclJvdyA9IE1hdGguY2VpbChzaGFwZVsyXSAvIDIpO1xuICAgIGNvbnN0IHRleGVsc0luQmF0Y2ggPSB2YWx1ZXNQZXJSb3cgKiBNYXRoLmNlaWwoc2hhcGVbMV0gLyAyKTtcblxuICAgIGNvbnN0IHBhY2tlZFNhbXBsZXIgPSBgdmVjNCAke2Z1bmNOYW1lfShpbnQgYiwgaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgdmVjMiB1diA9IHBhY2tlZFVWZnJvbTNEKFxuICAgICAgICAke3RleE51bUN9LCAke3RleE51bVJ9LCAke3RleGVsc0luQmF0Y2h9LCAke3ZhbHVlc1BlclJvd30sIGIsIHJvdywgY29sKTtcbiAgICAgIHJldHVybiAke2dsc2wudGV4dHVyZTJEfSgke25hbWV9LCB1dik7fWA7XG4gICAgY29uc3Qgc291cmNlID0gcGFja2VkU2FtcGxlcjtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5wYWNrZWRVVmZyb20zRCddKTtcbiAgfVxuICAvKlxuICAgKiBQYWNrZWQgTkQgc25pcHBldC5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRQYWNrZWRTYW1wbGVyTkQoZnVuY05hbWU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBzaGFwZSA9IGlucHV0TGF5b3V0LnVucGFja2VkU2hhcGU7XG4gICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCB0ZXhTaGFwZSA9IFtpbnB1dExheW91dC53aWR0aCwgaW5wdXRMYXlvdXQuaGVpZ2h0XTtcbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbCh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO1xuXG4gICAgY29uc3QgcGFja2VkVGV4U2hhcGUgPSBbdGV4U2hhcGVbMF0sIHRleFNoYXBlWzFdXTtcbiAgICBjb25zdCB0ZXhOdW1SID0gcGFja2VkVGV4U2hhcGVbMV07XG4gICAgY29uc3QgdGV4TnVtQyA9IHBhY2tlZFRleFNoYXBlWzBdO1xuICAgIGNvbnN0IHZhbHVlc1BlclJvdyA9IE1hdGguY2VpbChzaGFwZVtyYW5rIC0gMV0gLyAyKTtcbiAgICBsZXQgdGV4ZWxzSW5CYXRjaCA9IHZhbHVlc1BlclJvdyAqIE1hdGguY2VpbChzaGFwZVtyYW5rIC0gMl0gLyAyKTtcbiAgICBsZXQgcGFyYW1zID0gJ2ludCBiLCBpbnQgcm93LCBpbnQgY29sJztcbiAgICBsZXQgaW5kZXggPSBgYiAqICR7dGV4ZWxzSW5CYXRjaH0gKyAocm93IC8gMikgKiAke3ZhbHVlc1BlclJvd30gKyAoY29sIC8gMilgO1xuICAgIGZvciAobGV0IGIgPSAyOyBiIDwgcmFuayAtIDE7IGIrKykge1xuICAgICAgcGFyYW1zID0gYGludCBiJHtifSwgYCArIHBhcmFtcztcbiAgICAgIHRleGVsc0luQmF0Y2ggKj0gc2hhcGVbcmFuayAtIGIgLSAxXTtcbiAgICAgIGluZGV4ID0gYGIke2J9ICogJHt0ZXhlbHNJbkJhdGNofSArIGAgKyBpbmRleDtcbiAgICB9XG4gICAgY29uc3QgcGFja2VkU2FtcGxlciA9IGB2ZWM0ICR7ZnVuY05hbWV9KCR7cGFyYW1zfSkge1xuICAgICAgaW50IGluZGV4ID0gJHtpbmRleH07XG4gICAgICBpbnQgdGV4UiA9IGluZGV4IC8gJHt0ZXhOdW1DfTtcbiAgICAgIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogJHt0ZXhOdW1DfTtcbiAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKCR7dGV4TnVtQ30sICR7dGV4TnVtUn0pO1xuICAgICAgcmV0dXJuICR7Z2xzbC50ZXh0dXJlMkR9KCR7bmFtZX0sIHV2KTtcbiAgICB9YDtcbiAgICBjb25zdCBzb3VyY2UgPSBwYWNrZWRTYW1wbGVyO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBhY2tlZCBzY2FsYXIgc25pcHBldC5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRVbnBhY2tlZFNhbXBsZXJTY2FsYXIoZnVuY05hbWU6IHN0cmluZywgbmFtZTogc3RyaW5nLCBpbnB1dExheW91dDogVGV4dHVyZUxheW91dCk6IEdsc2xMaWJSb3V0aW5lIHtcbiAgICBjb25zdCBbdGV4TnVtUiwgdGV4TnVtQ10gPSBbaW5wdXRMYXlvdXQud2lkdGgsIGlucHV0TGF5b3V0LmhlaWdodF07XG4gICAgaWYgKHRleE51bVIgPT09IDEgJiYgdGV4TnVtQyA9PT0gMSkge1xuICAgICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KCkge1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgaGFsZkNSKTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJ10pO1xuICAgIH1cblxuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oKSB7XG4gICAgICAgICAgaW50IG9mZnNldF8ke25hbWV9ID0gY29vcmRzVG9PZmZzZXQoVGV4Q29vcmRzLCAke3RleE51bVJ9LCAke3RleE51bUN9KTtcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke3RleE51bVJ9LCAke3RleE51bUN9LCBvZmZzZXRfJHtuYW1lfSk7XG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoXG4gICAgICAgIHNvdXJjZSwgWydjb29yZGluYXRlcy51dkZyb21GbGF0JywgJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLCAnY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXQnXSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wYWNrZWQgMUQgc25pcHBldC5cbiAgICovXG4gIHByb3RlY3RlZCBnZXRVbnBhY2tlZFNhbXBsZXIxRChmdW5jTmFtZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGlucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0KTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHROdW1SID0gaW5wdXRMYXlvdXQud2lkdGg7XG4gICAgY29uc3QgdE51bUMgPSBpbnB1dExheW91dC5oZWlnaHQ7XG5cbiAgICBpZiAodE51bUMgPT09IDEgJiYgdE51bVIgPT09IDEpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oaW50IGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgaGFsZkNSKTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnXSk7XG4gICAgfVxuXG4gICAgaWYgKHROdW1DID09PSAxKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oaW50IGluZGV4KSB7XG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigoZmxvYXQoaW5kZXgpICsgMC41KSAvICR7dE51bVJ9LjAsIDAuNSk7XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke25hbWV9LCB1dik7XG4gICAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZSddKTtcbiAgICB9XG4gICAgaWYgKHROdW1SID09PSAxKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oaW50IGluZGV4KSB7XG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChmbG9hdChpbmRleCkgKyAwLjUpIC8gJHt0TnVtQ30uMCk7XG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke25hbWV9LCB1dik7XG4gICAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZSddKTtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgaW5kZXgpIHtcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke3ROdW1SfSwgJHt0TnVtQ30sIGluZGV4KTtcbiAgICAgICAgICByZXR1cm4gc2FtcGxlVGV4dHVyZSgke25hbWV9LCB1dik7XG4gICAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMudXZGcm9tRmxhdCcsICdjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJ10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDJEIHNuaXBwZXQuXG4gICAqL1xuXG4gIHByb3RlY3RlZCBnZXRVbnBhY2tlZFNhbXBsZXIyRChmdW5jTmFtZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGlucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0KTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHNoYXBlID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcblxuICAgIC8vIFRPRE86IG1vZGlmeSByb3cvY29sIG9yZGVyIGZvciBvdGhlciBkaW1lbnNpb25zLlxuICAgIGNvbnN0IHRleFNoYXBlID0gW2lucHV0TGF5b3V0LmhlaWdodCwgaW5wdXRMYXlvdXQud2lkdGhdO1xuXG4gICAgaWYgKHRleFNoYXBlICE9IG51bGwgJiYgQXJyYXlVdGlsLmFycmF5c0VxdWFsKHNoYXBlLCB0ZXhTaGFwZSkpIHtcbiAgICAgIGNvbnN0IHRleE51bVIgPSB0ZXhTaGFwZVsxXTtcbiAgICAgIGNvbnN0IHRleE51bUMgPSB0ZXhTaGFwZVswXTtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgICAgICB2ZWMyIHV2ID0gKHZlYzIocm93LCBjb2wpICsgaGFsZkNSKSAvIHZlYzIoJHt0ZXhOdW1SfS4wLCAke3RleE51bUN9LjApO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnXSk7XG4gICAgfVxuXG4gICAgY29uc3Qge25ld1NoYXBlLCBrZXB0RGltc30gPSBzcXVlZXplU2hhcGUoc2hhcGUgYXMgbnVtYmVyW10pO1xuICAgIGNvbnN0IHNxdWVlemVkU2hhcGUgPSBuZXdTaGFwZTtcbiAgICBpZiAoc3F1ZWV6ZWRTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG5ld0lucHV0U2hhcGUgPSBzcXVlZXplSW5wdXRTaGFwZShzaGFwZSwgc3F1ZWV6ZWRTaGFwZSk7XG4gICAgICAvLyBEZWVwIGNvcHkgb2YgaW5wdXQgdGV4dHVyZSBsYXlvdXQuXG4gICAgICBjb25zdCBuZXdJbnB1dExheW91dDogVGV4dHVyZUxheW91dCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXRMYXlvdXQpKTtcbiAgICAgIG5ld0lucHV0TGF5b3V0LnVucGFja2VkU2hhcGUgPSBuZXdJbnB1dFNoYXBlO1xuXG4gICAgICBjb25zdCBwYXJhbXMgPSBbJ2NvbCcsICdyb3cnXTtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICAke3RoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lLCBuYW1lLCBuZXdJbnB1dExheW91dCkucm91dGluZUJvZHl9XG4gICAgICAgICAgZmxvYXQgJHtmdW5jTmFtZX0oaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICAgICAgcmV0dXJuICR7ZnVuY05hbWV9KCR7Z2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcyl9KTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJ10pO1xuICAgIH1cblxuICAgIGNvbnN0IHRleE51bVIgPSB0ZXhTaGFwZVsxXTtcbiAgICBjb25zdCB0ZXhOdW1DID0gdGV4U2hhcGVbMF07XG4gICAgaWYgKHRleE51bUMgPT09IDEpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgICAgICBpbnQgb2Zmc2V0XyR7bmFtZX0gPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7dGV4TnVtUn0sICR7dGV4TnVtQ30pO1xuICAgICAgICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgb2Zmc2V0XyR7bmFtZX0pLCB2ZWMzKCR7c2hhcGVbMV19LCAxLCAxKSk7XG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigwLjUsIChpbmRleCArIDAuNSkgLyAke3RleE51bVJ9LjApO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLCAnY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXQnXSk7XG4gICAgfVxuXG4gICAgaWYgKHRleE51bVIgPT09IDEpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgICAgICBpbnQgb2Zmc2V0XyR7bmFtZX0gPSBjb29yZHNUb09mZnNldChUZXhDb29yZHMsICR7dGV4TnVtUn0sICR7dGV4TnVtQ30pO1xuICAgICAgICAgICAgZmxvYXQgaW5kZXggPSBkb3QodmVjMyhyb3csIGNvbCwgb2Zmc2V0XyR7bmFtZX0pLCB2ZWMzKCR7c2hhcGVbMV19LCAxLCAxKSk7XG4gICAgICAgICAgICB2ZWMyIHV2ID0gdmVjMigoaW5kZXggKyAwLjUpIC8gJHt0ZXhOdW1DfS4wLCAwLjUpO1xuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLCAnY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXQnXSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sKSB7XG4gICAgICAgICAgaW50IGluZGV4ID0gY29sICogJHtzaGFwZVsxXX0gKyByb3c7XG4gICAgICAgICAgdmVjMiB1diA9IHV2RnJvbUZsYXQoJHt0ZXhOdW1SfSwgJHt0ZXhOdW1DfSwgaW5kZXgpO1xuICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bmFtZX0sIHV2KTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKFxuICAgICAgICBzb3VyY2UsIFsnY29vcmRpbmF0ZXMudXZGcm9tRmxhdCcsICdjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJywgJ2Nvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0J10pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGFja2VkIDNEIHNuaXBwZXQuXG4gICAqL1xuXG4gIHByb3RlY3RlZCBnZXRVbnBhY2tlZFNhbXBsZXIzRChmdW5jTmFtZTogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGlucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0KTogR2xzbExpYlJvdXRpbmUge1xuICAgIGNvbnN0IHNoYXBlID0gaW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZTtcbiAgICBjb25zdCBzdHJpZGUwID0gc2hhcGVbMV0gKiBzaGFwZVsyXTtcbiAgICBjb25zdCBzdHJpZGUxID0gc2hhcGVbMl07XG5cbiAgICBjb25zdCB7bmV3U2hhcGUsIGtlcHREaW1zfSA9IHNxdWVlemVTaGFwZShzaGFwZSBhcyBudW1iZXJbXSk7XG4gICAgY29uc3Qgc3F1ZWV6ZWRTaGFwZSA9IG5ld1NoYXBlO1xuICAgIGlmIChzcXVlZXplZFNoYXBlLmxlbmd0aCA8IHNoYXBlLmxlbmd0aCkge1xuICAgICAgY29uc3QgbmV3SW5wdXRTaGFwZSA9IHNxdWVlemVJbnB1dFNoYXBlKHNoYXBlLCBzcXVlZXplZFNoYXBlKTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFsnYmF0Y2gnLCAnY29sJywgJ3JvdyddO1xuICAgICAgLy8gRGVlcCBjb3B5IG9mIGlucHV0IHRleHR1cmUgbGF5b3V0LlxuICAgICAgY29uc3QgbmV3SW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGlucHV0TGF5b3V0KSk7XG4gICAgICBuZXdJbnB1dExheW91dC51bnBhY2tlZFNoYXBlID0gbmV3SW5wdXRTaGFwZTtcbiAgICAgIGNvbnN0IHJvdXRpbmUgPSB0aGlzLmdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChmdW5jTmFtZSwgbmFtZSwgbmV3SW5wdXRMYXlvdXQpO1xuICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGUgbG9naWMgaGVyZSB0byBtYWtlIGl0IHNpbXBsZXJcbiAgICAgIGNvbnN0IHJldkRpbXMgPSBrZXB0RGltcy5yZXZlcnNlKCk7XG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgJHtyb3V0aW5lLnJvdXRpbmVCb2R5fVxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCBiYXRjaCwgaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICAgICAgcmV0dXJuICR7ZnVuY05hbWV9KCR7Z2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCByZXZEaW1zKX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCByb3V0aW5lLmRlcGVuZGVuY2llcyk7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4TnVtUiA9IGlucHV0TGF5b3V0LndpZHRoO1xuICAgIGNvbnN0IHRleE51bUMgPSBpbnB1dExheW91dC5oZWlnaHQ7XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCBkZXB0aCwgaW50IHJvdywgaW50IGNvbCkge1xuICAgICAgICAgICAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxuICAgICAgICAgICAgaW50IGluZGV4ID0gZGVwdGggKiAke3N0cmlkZTB9ICsgY29sICogJHtzdHJpZGUxfSArIHJvdztcbiAgICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7dGV4TnVtUn0sICR7dGV4TnVtQ30sIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bmFtZX0sIHV2KTtcbiAgICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoXG4gICAgICAgIHNvdXJjZSwgWydjb29yZGluYXRlcy51dkZyb21GbGF0JywgJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLCAnY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXQnXSk7XG4gIH1cblxuICAvKipcbiAgICogVW5wYWNrZWQgNEQgc25pcHBldC5cbiAgICovXG5cbiAgcHJvdGVjdGVkIGdldFVucGFja2VkU2FtcGxlcjREKGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc2hhcGUgPSBpbnB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IHN0cmlkZTIgPSBzaGFwZVszXTtcbiAgICBjb25zdCBzdHJpZGUxID0gc2hhcGVbMl0gKiBzdHJpZGUyO1xuICAgIGNvbnN0IHN0cmlkZTAgPSBzaGFwZVsxXSAqIHN0cmlkZTE7XG5cbiAgICAvL1xuICAgIC8vIFRPRE86IHJlLWVuYWJsZSB0aGlzIHNob3J0Y3V0IG9uY2UgdGhlIGluZGV4IGNhbGN1bGF0aW9uIGJ1ZyBpcyBmaXhlZC5cbiAgICAvL1xuICAgIC8vIGNvbnN0IHtuZXdTaGFwZSwga2VwdERpbXN9ID0gc3F1ZWV6ZVNoYXBlKHNoYXBlIGFzIG51bWJlcltdKTtcbiAgICAvLyBpZiAobmV3U2hhcGUubGVuZ3RoIDwgc2hhcGUubGVuZ3RoKSB7XG4gICAgLy8gICBjb25zdCBuZXdJbnB1dFNoYXBlID0gc3F1ZWV6ZUlucHV0U2hhcGUoc2hhcGUsIG5ld1NoYXBlKTtcbiAgICAvLyAgIGNvbnN0IHBhcmFtcyA9IFsncm93JywgJ2NvbCcsICdkZXB0aCcsICdkZXB0aDInXTtcbiAgICAvLyAgIC8vIERlZXAgY29weSBvZiBpbnB1dCB0ZXh0dXJlIGxheW91dC5cbiAgICAvLyAgIGNvbnN0IG5ld0lucHV0TGF5b3V0OiBUZXh0dXJlTGF5b3V0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpbnB1dExheW91dCkpO1xuICAgIC8vICAgbmV3SW5wdXRMYXlvdXQudW5wYWNrZWRTaGFwZSA9IG5ld0lucHV0U2hhcGU7XG4gICAgLy8gICBjb25zdCBzb3VyY2UgPSBgXG4gICAgLy8gICAgICAgJHt0aGlzLmdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChmdW5jTmFtZSwgbmFtZSwgbmV3SW5wdXRMYXlvdXQpLnJvdXRpbmVCb2R5fVxuICAgIC8vICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xuICAgIC8vICAgICAgICAgcmV0dXJuICR7ZnVuY05hbWV9KCR7Z2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcyl9KTtcbiAgICAvLyAgICAgICB9XG4gICAgLy8gICAgIGA7XG4gICAgLy8gICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKFxuICAgIC8vICAgICAgIHNvdXJjZSwgWydjb29yZGluYXRlcy51dkZyb21GbGF0JywgJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLCAnY29vcmRpbmF0ZXMuY29vcmRzVG9PZmZzZXQnXSk7XG4gICAgLy8gfVxuXG4gICAgY29uc3QgdGV4TnVtUiA9IGlucHV0TGF5b3V0LndpZHRoO1xuICAgIGNvbnN0IHRleE51bUMgPSBpbnB1dExheW91dC5oZWlnaHQ7XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcbiAgICAgICAgICBpbnQgaW5kZXggPSByb3cgKiAke3N0cmlkZTB9ICsgY29sICogJHtzdHJpZGUxfSArXG4gICAgICAgICAgICAgIGRlcHRoMiAqICR7c3RyaWRlMn0gKyBkZXB0aDtcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke3RleE51bVJ9LCAke3RleE51bUN9LCBpbmRleCk7XG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnV2RnJvbUZsYXQnLCAnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZSddKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBhY2tlZCA1RCBzbmlwcGV0LlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFVucGFja2VkU2FtcGxlcjVEKGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc2hhcGUgPSBpbnB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IHN0cmlkZTMgPSBzaGFwZVs0XTtcbiAgICBjb25zdCBzdHJpZGUyID0gc2hhcGVbM10gKiBzdHJpZGUzO1xuICAgIGNvbnN0IHN0cmlkZTEgPSBzaGFwZVsyXSAqIHN0cmlkZTI7XG4gICAgY29uc3Qgc3RyaWRlMCA9IHNoYXBlWzFdICogc3RyaWRlMTtcblxuICAgIGNvbnN0IHtuZXdTaGFwZSwga2VwdERpbXN9ID0gc3F1ZWV6ZVNoYXBlKHNoYXBlIGFzIG51bWJlcltdKTtcbiAgICBpZiAobmV3U2hhcGUubGVuZ3RoIDwgc2hhcGUubGVuZ3RoKSB7XG4gICAgICBjb25zdCBuZXdJbnB1dFNoYXBlID0gc3F1ZWV6ZUlucHV0U2hhcGUoc2hhcGUsIG5ld1NoYXBlKTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFsncm93JywgJ2NvbCcsICdkZXB0aCcsICdkZXB0aDInLCAnZGVwdGgzJ107XG4gICAgICAvLyBEZWVwIGNvcHkgb2YgaW5wdXQgdGV4dHVyZSBsYXlvdXQuXG4gICAgICBjb25zdCBuZXdJbnB1dExheW91dDogVGV4dHVyZUxheW91dCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXRMYXlvdXQpKTtcbiAgICAgIG5ld0lucHV0TGF5b3V0LnVucGFja2VkU2hhcGUgPSBuZXdJbnB1dFNoYXBlO1xuXG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgJHt0aGlzLmdldFVucGFja2VkU2FtcGxlckZyb21JbnB1dChmdW5jTmFtZSwgbmFtZSwgbmV3SW5wdXRMYXlvdXQpLnJvdXRpbmVCb2R5fVxuICAgICAgICAgIGZsb2F0ICR7ZnVuY05hbWV9KGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMiwgaW50IGRlcHRoMykge1xuICAgICAgICAgICAgcmV0dXJuICR7ZnVuY05hbWV9KCR7Z2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcyl9KTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICByZXR1cm4gbmV3IEdsc2xMaWJSb3V0aW5lKHNvdXJjZSwgWydjb29yZGluYXRlcy5zYW1wbGVUZXh0dXJlJywgJ2Nvb3JkaW5hdGVzLnV2RnJvbUZsYXQnXSk7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4TnVtUiA9IGlucHV0TGF5b3V0LndpZHRoO1xuICAgIGNvbnN0IHRleE51bUMgPSBpbnB1dExheW91dC5oZWlnaHQ7XG4gICAgY29uc3Qgc291cmNlID0gYFxuICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIsIGludCBkZXB0aDMpIHtcbiAgICAgICAgICBpbnQgaW5kZXggPSByb3cgKiAke3N0cmlkZTB9ICsgY29sICogJHtzdHJpZGUxfSArIGRlcHRoICogJHtzdHJpZGUyfSArXG4gICAgICAgICAgZGVwdGgzICogJHtzdHJpZGUzfSArIGRlcHRoMjtcbiAgICAgICAgICB2ZWMyIHV2ID0gdXZGcm9tRmxhdCgke3RleE51bVJ9LCAke3RleE51bUN9LCBpbmRleCk7XG4gICAgICAgICAgcmV0dXJuIHNhbXBsZVRleHR1cmUoJHtuYW1lfSwgdXYpO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgIHJldHVybiBuZXcgR2xzbExpYlJvdXRpbmUoc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnNhbXBsZVRleHR1cmUnLCAnY29vcmRpbmF0ZXMudXZGcm9tRmxhdCddKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnBhY2tlZCA2RCBzbmlwcGV0LlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFVucGFja2VkU2FtcGxlcjZEKGZ1bmNOYW1lOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgaW5wdXRMYXlvdXQ6IFRleHR1cmVMYXlvdXQpOiBHbHNsTGliUm91dGluZSB7XG4gICAgY29uc3Qgc2hhcGUgPSBpbnB1dExheW91dC51bnBhY2tlZFNoYXBlO1xuICAgIGNvbnN0IHN0cmlkZTQgPSBzaGFwZVs1XTtcbiAgICBjb25zdCBzdHJpZGUzID0gc2hhcGVbNF0gKiBzdHJpZGU0O1xuICAgIGNvbnN0IHN0cmlkZTIgPSBzaGFwZVszXSAqIHN0cmlkZTM7XG4gICAgY29uc3Qgc3RyaWRlMSA9IHNoYXBlWzJdICogc3RyaWRlMjtcbiAgICBjb25zdCBzdHJpZGUwID0gc2hhcGVbMV0gKiBzdHJpZGUxO1xuXG4gICAgY29uc3Qge25ld1NoYXBlLCBrZXB0RGltc30gPSBzcXVlZXplU2hhcGUoc2hhcGUgYXMgbnVtYmVyW10pO1xuICAgIGlmIChuZXdTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG5ld0lucHV0U2hhcGUgPSBzcXVlZXplSW5wdXRTaGFwZShzaGFwZSwgbmV3U2hhcGUpO1xuICAgICAgY29uc3QgcGFyYW1zID0gWydyb3cnLCAnY29sJywgJ2RlcHRoJywgJ2RlcHRoMicsICdkZXB0aDMnLCAnZGVwdGg0J107XG4gICAgICAvLyBEZWVwIGNvcHkgb2YgaW5wdXQgdGV4dHVyZSBsYXlvdXQuXG4gICAgICBjb25zdCBuZXdJbnB1dExheW91dDogVGV4dHVyZUxheW91dCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXRMYXlvdXQpKTtcbiAgICAgIG5ld0lucHV0TGF5b3V0LnVucGFja2VkU2hhcGUgPSBuZXdJbnB1dFNoYXBlO1xuXG4gICAgICBjb25zdCBzb3VyY2UgPSBgXG4gICAgICAgICAgICAke3RoaXMuZ2V0VW5wYWNrZWRTYW1wbGVyRnJvbUlucHV0KGZ1bmNOYW1lLCBuYW1lLCBuZXdJbnB1dExheW91dCkucm91dGluZUJvZHl9XG4gICAgICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXG4gICAgICAgICAgICAgIGludCBkZXB0aDIsIGludCBkZXB0aDMsIGludCBkZXB0aDQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICR7ZnVuY05hbWV9KCR7Z2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcyl9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBgO1xuICAgICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShzb3VyY2UsIFsnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZScsICdjb29yZGluYXRlcy51dkZyb21GbGF0J10pO1xuICAgIH1cblxuICAgIGNvbnN0IHRleE51bVIgPSBpbnB1dExheW91dC53aWR0aDtcbiAgICBjb25zdCB0ZXhOdW1DID0gaW5wdXRMYXlvdXQuaGVpZ2h0O1xuICAgIGNvbnN0IHNvdXJjZSA9IGBcbiAgICAgICAgICBmbG9hdCAke2Z1bmNOYW1lfShpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsXG4gICAgICAgICAgICBpbnQgZGVwdGgyLCBpbnQgZGVwdGgzLCBpbnQgZGVwdGg0KSB7XG4gICAgICAgICAgICBpbnQgaW5kZXggPSByb3cgKiAke3N0cmlkZTB9ICsgY29sICogJHtzdHJpZGUxfSArIGRlcHRoICogJHtzdHJpZGUyfSArXG4gICAgICAgICAgICBkZXB0aDIgKiAke3N0cmlkZTN9ICsgZGVwdGgzICogJHtzdHJpZGU0fSArIGRlcHRoNDtcbiAgICAgICAgICAgIHZlYzIgdXYgPSB1dkZyb21GbGF0KCR7dGV4TnVtUn0sICR7dGV4TnVtQ30sIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVUZXh0dXJlKCR7bmFtZX0sIHV2KTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgcmV0dXJuIG5ldyBHbHNsTGliUm91dGluZShcbiAgICAgICAgc291cmNlLCBbJ2Nvb3JkaW5hdGVzLnV2RnJvbUZsYXQnLCAnY29vcmRpbmF0ZXMuc2FtcGxlVGV4dHVyZScsICdjb29yZGluYXRlcy5jb29yZHNUb09mZnNldCddKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBtYWluIGZ1bmN0aW9uIHRvIG1hcCBmcm9tIHRoZSBnaXZlbiB0ZXh0dXJlIGNvb3JkaWFudGVzIChzLHQpXG4gICAqIHRvIGxvZ2ljYWwgaW5kaWNlcyBmb3IgdGhlIG91dHB1dFxuICAgKiBUaGVyZSB3aWxsIG9ubHkgYmUgb25lIHNpbmdsZSB2YXJpYXRpb24gb2YgdGhpc1xuICAgKiBBbHNvIHNlZSBjb29yZHNUb09mZnNldCBhbmQgb2Zmc2V0VG9JbmRpY2VzIGZvciBpbnB1dC1zcGVjaWZpYyB2ZXJzaW9uc1xuICAgKi9cbiAgcHJvdGVjdGVkIHRvVmVjKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCBvdXRwdXQgPSB0aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dDtcbiAgICBjb25zdCByYW5rID0gb3V0cHV0LnNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBzdHJpZGVzID0gb3V0cHV0LnN0cmlkZXM7XG4gICAgY29uc3QgeFNjYWxlID0gb3V0cHV0LndpZHRoO1xuICAgIGNvbnN0IHlTY2FsZSA9IG91dHB1dC5oZWlnaHQ7XG5cbiAgICBjb25zdCBzdHJpZGVzQmxvY2sgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmsgLSAxOyArK2kpIHtcbiAgICAgIHN0cmlkZXNCbG9jay5wdXNoKGBcbiAgICAgICAgY1ske2l9XSA9IG9mZnNldCAvICR7c3RyaWRlc1tpXX07YCk7XG4gICAgICBzdHJpZGVzQmxvY2sucHVzaChgXG4gICAgICAgIG9mZnNldCAtPSBjWyR7aX1dICogJHtzdHJpZGVzW2ldfTtgKTtcbiAgICB9XG4gICAgc3RyaWRlc0Jsb2NrLnB1c2goYFxuICAgICAgICBjWyR7cmFuayAtIDF9XSA9IG9mZnNldDtgKTtcbiAgICBjb25zdCBib2R5ID0gYFxuICAgICAgdm9pZCB0b1ZlYyh2ZWMyIHRleENvb3Jkcywgb3V0IGludCBjWyR7cmFua31dKSB7XG4gICAgICAgIGludCBvZmZzZXQgPSBjb29yZHNUb09mZnNldCh0ZXhDb29yZHMsICR7eFNjYWxlfSwgJHt5U2NhbGV9KTtcbiAgICAgICAgJHtzdHJpZGVzQmxvY2suam9pbignJyl9XG4gICAgICB9XG4gICAgICB2b2lkIHRvVmVjKGludCBvZmZzZXQsIG91dCBpbnQgY1ske3Jhbmt9XSkge1xuICAgICAgICAke3N0cmlkZXNCbG9jay5qb2luKCcnKX1cbiAgICAgIH1cbiAgICBgO1xuICAgIHJldHVybiB7dG9WZWM6IG5ldyBHbHNsTGliUm91dGluZShib2R5LCBbJ2Nvb3JkaW5hdGVzLmNvb3Jkc1RvT2Zmc2V0J10pfTtcbiAgfVxuICAvKipcbiAgICogVGhlc2UgYXJlIHZhbHVlIGdldHRlciBmdW5jdGlvbnMgZ2VuZXJhdGVkIGZvciBlYWNoIGlucHV0XG4gICAqIEVhY2ggZnVuY3Rpb24gaXMgaGFyZHdpcmVkIHRvIHRoZSBuYW1lIGFuZCBkaW1lbnNpb25zIG9mIHRoZSBpbnB1dFxuICAgKiBBbiAnX1QnIHZhcmlhdGlvbiBpcyBhbHNvIHByb2R1Y2VkIHdoaWNoIGFjY2Vzc2VzIHZhbHVlcyBhcyBpZiB0aGVcbiAgICogaW5wdXQgd2FzIHRyYW5zcG9zZWRcbiAgICovXG4gIHByb3RlY3RlZCB2YWx1ZUZyb20oKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IHJlc3VsdDoge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0gPSB7fTtcbiAgICB0aGlzLmNvbnRleHQucHJvZ3JhbUluZm8uaW5wdXROYW1lcy5mb3JFYWNoKChuYW1lLCBpKSA9PiB7XG4gICAgICBjb25zdCBsYXlvdXQgPSB0aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tpXTtcbiAgICAgIGNvbnN0IHNoYXBlID0gbGF5b3V0LnVucGFja2VkU2hhcGUubGVuZ3RoID4gMCA/IGxheW91dC51bnBhY2tlZFNoYXBlIDogbGF5b3V0LnNoYXBlO1xuICAgICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICAgIGxldCBmdW5jTmFtZSA9IGBfJHtuYW1lfWA7XG4gICAgICByZXN1bHRbZnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKFxuICAgICAgICAgIHRoaXMuZ2V0VmFsdWVGcm9tU2luZ2xlKG5hbWUsIHJhbmssIGxheW91dC53aWR0aCwgbGF5b3V0LmhlaWdodCwgZmFsc2UpLFxuICAgICAgICAgIFtgc2hhcGVVdGlscy5pbmRpY2VzVG9PZmZzZXQke2Z1bmNOYW1lfWAsICdjb29yZGluYXRlcy5vZmZzZXRUb0Nvb3JkcycsICdmcmFnY29sb3IuZ2V0Q29sb3JBc0Zsb2F0J10pO1xuICAgICAgZnVuY05hbWUgPSBmdW5jTmFtZSArICdfVCc7XG4gICAgICByZXN1bHRbZnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKFxuICAgICAgICAgIHRoaXMuZ2V0VmFsdWVGcm9tU2luZ2xlKG5hbWUsIHJhbmssIGxheW91dC53aWR0aCwgbGF5b3V0LmhlaWdodCwgdHJ1ZSksXG4gICAgICAgICAgW2BzaGFwZVV0aWxzLmluZGljZXNUb09mZnNldCR7ZnVuY05hbWV9YCwgJ2Nvb3JkaW5hdGVzLm9mZnNldFRvQ29vcmRzJywgJ2ZyYWdjb2xvci5nZXRDb2xvckFzRmxvYXQnXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogUHJvZHVjZXMgb25lIHZhbHVlIGdldHRlciBmdW5jdGlvbiBmb3IgdGhlIG5hbWUgYW5kIHJhbmsgZ2l2ZW5cbiAgICogSWYgYSB0cmFuc3Bvc2UgaXMgc2V0IHByb3BlciBvZmZzZXRUb0Nvb3JkcyBtYXBwaW5nIHdpbGwgYmUgdXNlZFxuICAgKiBAcGFyYW0gbmFtZSBuYW1lIG9mIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0gcmFuayByYW5rIG9mIHRoZSBpbnB1dFxuICAgKiBAcGFyYW0gdHJhbnNwb3NlIHdoZXRoZXIgb3Igbm90IHNob3VsZCBnZW5lcmF0ZSBhIHRyYW5zcG9zZSB2YXJpYXRpb25cbiAgICovXG4gIHByb3RlY3RlZCBnZXRWYWx1ZUZyb21TaW5nbGUodmFyTmFtZTogc3RyaW5nLCByYW5rOiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCB0cmFuc3Bvc2U6IGJvb2xlYW4pOlxuICAgICAgc3RyaW5nIHtcbiAgICBsZXQgbmFtZSA9IGBfJHt2YXJOYW1lfWA7XG4gICAgaWYgKHRyYW5zcG9zZSkge1xuICAgICAgbmFtZSA9IG5hbWUgKyAnX1QnO1xuICAgIH1cbiAgICBjb25zdCBnbHNsID0gZ2V0R2xzbCh0aGlzLmNvbnRleHQuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgIHJldHVybiBgXG4gICAgICAgIGZsb2F0ICR7bmFtZX0oaW50IG1bJHtyYW5rfV0pIHtcbiAgICAgICAgICBpbnQgb2Zmc2V0ID0gaW5kaWNlc1RvT2Zmc2V0JHtuYW1lfShtKTtcbiAgICAgICAgICB2ZWMyIGNvb3JkcyA9IG9mZnNldFRvQ29vcmRzKG9mZnNldCwgJHt3aWR0aH0sICR7aGVpZ2h0fSk7XG4gICAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRDb2xvckFzRmxvYXQoJHtnbHNsLnRleHR1cmUyRH0oJHt2YXJOYW1lfSwgY29vcmRzKSk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGA7XG4gIH1cblxuICAvKipcbiAgICogUHJvZHVjZXMgYSBwYWNrZWQgdmFsdWUgZ2V0dGVyIGZ1bmN0aW9uIGZvciB0aGUgbmFtZSBhbmQgcmFuayBnaXZlblxuICAgKiBJZiBhIHRyYW5zcG9zZSBpcyBzZXQgcHJvcGVyIG9mZnNldFRvQ29vcmRzIG1hcHBpbmcgd2lsbCBiZSB1c2VkXG4gICAqIEBwYXJhbSBuYW1lIG5hbWUgb2YgdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSByYW5rIHJhbmsgb2YgdGhlIGlucHV0XG4gICAqIEBwYXJhbSB0cmFuc3Bvc2Ugd2hldGhlciBvciBub3Qgc2hvdWxkIGdlbmVyYXRlIGEgdHJhbnNwb3NlIHZhcmlhdGlvblxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFBhY2tlZFZhbHVlRnJvbSh2YXJOYW1lOiBzdHJpbmcsIHJhbms6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIHRyYW5zcG9zZTogYm9vbGVhbik6XG4gICAgICBzdHJpbmcge1xuICAgIGxldCBuYW1lID0gYF8ke3Zhck5hbWV9X1BhY2tgO1xuICAgIGlmICh0cmFuc3Bvc2UpIHtcbiAgICAgIG5hbWUgPSBuYW1lICsgJ19UJztcbiAgICB9XG4gICAgY29uc3QgZ2xzbCA9IGdldEdsc2wodGhpcy5jb250ZXh0LmdsQ29udGV4dC52ZXJzaW9uKTtcbiAgICByZXR1cm4gYFxuICAgICAgICB2ZWM0ICR7bmFtZX0oaW50IG1bJHtyYW5rfV0pIHtcbiAgICAgICAgICBpbnQgb2Zmc2V0ID0gaW5kaWNlc1RvT2Zmc2V0XyR7dmFyTmFtZX0obSk7XG4gICAgICAgICAgdmVjMiBjb29yZHMgPSBvZmZzZXRUb0Nvb3JkcyhvZmZzZXQsICR7d2lkdGh9LCAke2hlaWdodH0pO1xuICAgICAgICAgIHJldHVybiAke2dsc2wudGV4dHVyZTJEfSgke3Zhck5hbWV9LCBjb29yZHMpO1xuICAgICAgICB9XG4gICAgICAgIGA7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtHbHNsQ29udGV4dCwgR2xzbExpYiwgR2xzbExpYlJvdXRpbmV9IGZyb20gJy4vZ2xzbC1kZWZpbml0aW9ucyc7XG5cbi8qKlxuICogVGhpcyBHTFNMIGxpYnJhcnkgaGFuZGxlcyByb3V0aW5lcyBjb252ZXJ0aW5nXG4gKiBmbG9hdDMyIHRvL2Zyb20gVW5zaWduZWQgYnl0ZSBvciBmbG9hdCAxNlxuICovXG5leHBvcnQgY2xhc3MgRW5jb2RpbmdHbHNsTGliIGV4dGVuZHMgR2xzbExpYiB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IEdsc2xDb250ZXh0KSB7XG4gICAgc3VwZXIoY29udGV4dCk7XG4gIH1cbiAgZ2V0RnVuY3Rpb25zKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICByZXR1cm4gey4uLnRoaXMuZW5jb2RlRmxvYXQzMigpLCAuLi50aGlzLmRlY29kZUZsb2F0MzIoKX07XG4gIH1cbiAgZ2V0Q3VzdG9tVHlwZXMoKToge1tuYW1lOiBzdHJpbmddOiBzdHJpbmd9IHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcHJvdGVjdGVkIGVuY29kZUZsb2F0MzIoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIHJldHVybiB7XG4gICAgICBlbmNvZGU6IG5ldyBHbHNsTGliUm91dGluZShgaGlnaHAgdmVjNCBlbmNvZGUoaGlnaHAgZmxvYXQgZikge1xuICAgICAgICByZXR1cm4gdmVjNChmLCAwLjAsIDAuMCwgMC4wKTtcbiAgICAgIH1cbiAgICAgICAgYClcbiAgICB9O1xuICB9XG4gIHByb3RlY3RlZCBkZWNvZGVGbG9hdDMyKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICByZXR1cm4ge1xuICAgICAgZGVjb2RlOiBuZXcgR2xzbExpYlJvdXRpbmUoYGhpZ2hwIGZsb2F0IGRlY29kZShoaWdocCB2ZWM0IHJnYmEpIHtcbiAgICAgICAgcmV0dXJuIHJnYmEucjtcbiAgICAgIH1cbiAgICAgICAgYClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiByZXR1cm5zIHRoZSByb3V0aW5lIHRvIGVuY29kZSBlbmNvZGUgYSAzMmJpdCBmbG9hdCB0byBhIHZlYzQgKG9mIHVuc2lnbmVkIGJ5dGVzKVxuICAgKiBAY3JlZGl0OiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MDU5OTYyL2hvdy1kby1pLWNvbnZlcnQtYS12ZWM0LXJnYmEtdmFsdWUtdG8tYS1mbG9hdFxuICAgKi9cbiAgcHJvdGVjdGVkIGVuY29kZVVpbnQ4KCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCBlbmRpYW5uZXNzID0gRW5jb2RpbmdHbHNsTGliLmlzTGl0dGxlRW5kaWFuKCkgPyAncmdiYS5yZ2JhPXJnYmEuYWJncjsnIDogJyc7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuY29kZTogbmV3IEdsc2xMaWJSb3V0aW5lKGBcbiAgICAgIGhpZ2hwIHZlYzQgZW5jb2RlKGhpZ2hwIGZsb2F0IGYpIHtcbiAgICAgICAgaGlnaHAgZmxvYXQgRiA9IGFicyhmKTtcbiAgICAgICAgaGlnaHAgZmxvYXQgU2lnbiA9IHN0ZXAoMC4wLC1mKTtcbiAgICAgICAgaGlnaHAgZmxvYXQgRXhwb25lbnQgPSBmbG9vcihsb2cyKEYpKTtcbiAgICAgICAgaGlnaHAgZmxvYXQgTWFudGlzc2EgPSAoZXhwMigtIEV4cG9uZW50KSAqIEYpO1xuICAgICAgICBFeHBvbmVudCA9IGZsb29yKGxvZzIoRikgKyAxMjcuMCkgKyBmbG9vcihsb2cyKE1hbnRpc3NhKSk7XG4gICAgICAgIGhpZ2hwIHZlYzQgcmdiYTtcbiAgICAgICAgcmdiYVswXSA9IDEyOC4wICogU2lnbiAgKyBmbG9vcihFeHBvbmVudCpleHAyKC0xLjApKTtcbiAgICAgICAgcmdiYVsxXSA9IDEyOC4wICogbW9kKEV4cG9uZW50LDIuMCkgKyBtb2QoZmxvb3IoTWFudGlzc2EqMTI4LjApLDEyOC4wKTtcbiAgICAgICAgcmdiYVsyXSA9IGZsb29yKG1vZChmbG9vcihNYW50aXNzYSpleHAyKDIzLjAgLTguMCkpLGV4cDIoOC4wKSkpO1xuICAgICAgICByZ2JhWzNdID0gZmxvb3IoZXhwMigyMy4wKSptb2QoTWFudGlzc2EsZXhwMigtMTUuMCkpKTtcbiAgICAgICAgJHtlbmRpYW5uZXNzfVxuICAgICAgICByZ2JhID0gcmdiYSAvIDI1NS4wOyAvLyB2YWx1ZXMgbmVlZCB0byBiZSBub3JtYWxpemVkIHRvIFswLDFdXG4gICAgICAgIHJldHVybiByZ2JhO1xuICAgIH1cbiAgICAgICAgYClcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiByZXR1cm5zIHRoZSByb3V0aW5lIHRvIGVuY29kZSBhIHZlYzQgb2YgdW5zaWduZWQgYnl0ZXMgdG8gZmxvYXQzMlxuICAgKiBAY3JlZGl0OiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MDU5OTYyL2hvdy1kby1pLWNvbnZlcnQtYS12ZWM0LXJnYmEtdmFsdWUtdG8tYS1mbG9hdFxuICAgKi9cbiAgcHJvdGVjdGVkIGRlY29kZVVpbnQ4KCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCBlbmRpYW5uZXNzID0gRW5jb2RpbmdHbHNsTGliLmlzTGl0dGxlRW5kaWFuKCkgPyAncmdiYS5yZ2JhPXJnYmEuYWJncjsnIDogJyc7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlY29kZTogbmV3IEdsc2xMaWJSb3V0aW5lKGBcbiAgICAgICAgaGlnaHAgZmxvYXQgZGVjb2RlKGhpZ2hwIHZlYzQgcmdiYSkge1xuICAgICAgICAgIHJnYmEgPSByZ2JhICogMjU1LjA7IC8vIHZhbHVlcyBuZWVkIHRvIGJlIGRlLW5vcm1hbGl6ZWQgZnJvbSBbMCwxXSB0byBbMCwyNTVdXG4gICAgICAgICAgJHtlbmRpYW5uZXNzfVxuICAgICAgICAgIGhpZ2hwIGZsb2F0IFNpZ24gPSAxLjAgLSBzdGVwKDEyOC4wLHJnYmFbMF0pKjIuMDtcbiAgICAgICAgICBoaWdocCBmbG9hdCBFeHBvbmVudCA9IDIuMCAqIG1vZChyZ2JhWzBdLDEyOC4wKSArIHN0ZXAoMTI4LjAscmdiYVsxXSkgLSAxMjcuMDtcbiAgICAgICAgICBoaWdocCBmbG9hdCBNYW50aXNzYSA9IG1vZChyZ2JhWzFdLDEyOC4wKSo2NTUzNi4wICsgcmdiYVsyXSoyNTYuMCArcmdiYVszXSArIGZsb2F0KDB4ODAwMDAwKTtcbiAgICAgICAgICBoaWdocCBmbG9hdCBSZXN1bHQgPSAgU2lnbiAqIGV4cDIoRXhwb25lbnQpICogKE1hbnRpc3NhICogZXhwMigtMjMuMCApKTtcbiAgICAgICAgICByZXR1cm4gUmVzdWx0O1xuICAgICAgfVxuICAgICAgICBgKVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIG1hY2hpbmUgaXMgbGl0dGxlIGVuZGlhbiBvciBub3RcbiAgICogQGNyZWRpdDogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vVG9vVGFsbE5hdGUvNDc1MDk1M1xuICAgKi9cbiAgc3RhdGljIGlzTGl0dGxlRW5kaWFuKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGIgPSBuZXcgQXJyYXlCdWZmZXIoNCk7XG4gICAgY29uc3QgYSA9IG5ldyBVaW50MzJBcnJheShiKTtcbiAgICBjb25zdCBjID0gbmV3IFVpbnQ4QXJyYXkoYik7XG4gICAgYVswXSA9IDB4ZGVhZGJlZWY7XG4gICAgaWYgKGNbMF0gPT09IDB4ZWYpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY1swXSA9PT0gMHhkZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gZW5kaWFubmVzcycpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7R2xzbENvbnRleHQsIEdsc2xMaWIsIEdsc2xMaWJSb3V0aW5lfSBmcm9tICcuL2dsc2wtZGVmaW5pdGlvbnMnO1xuaW1wb3J0IHtnZXRHbHNsfSBmcm9tICcuL2dsc2wtc291cmNlJztcblxuLyoqXG4gKiBUaGlzIEdMU0wgbGlicmFyeSBoYW5kbGVzIHJvdXRpbmVzIGFyb3VuZCByZWFkaW5nIGEgdGV4bGV0IGFuZCB3cml0aW5nIHRvIGl0XG4gKiBSZWFkaW5nIGFuZCB3cml0aW5nIGNvdWxkIGJlIG1vcmUgdGhhbiBqdXN0IGRlYWxpbmcgd2l0aCBvbmUgY2hhbm5lbFxuICogSXQgbWF5IHJlcXVpcmUgZW5jb2RpbmcvZGVjb2RpbmcgdG8vZnJvbSA0IGNoYW5uZWxzIGludG8gb25lXG4gKi9cbmV4cG9ydCBjbGFzcyBGcmFnQ29sb3JHbHNsTGliIGV4dGVuZHMgR2xzbExpYiB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IEdsc2xDb250ZXh0KSB7XG4gICAgc3VwZXIoY29udGV4dCk7XG4gIH1cbiAgZ2V0RnVuY3Rpb25zKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICByZXR1cm4gey4uLnRoaXMuc2V0RnJhZ0NvbG9yKCksIC4uLnRoaXMuZ2V0Q29sb3JBc0Zsb2F0KCl9O1xuICB9XG4gIGdldEN1c3RvbVR5cGVzKCk6IHtbbmFtZTogc3RyaW5nXTogc3RyaW5nfSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHByb3RlY3RlZCBzZXRGcmFnQ29sb3IoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IGdsc2wgPSBnZXRHbHNsKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldEZyYWdDb2xvcjogbmV3IEdsc2xMaWJSb3V0aW5lKFxuICAgICAgICAgIGBcbiAgICAgICAgdm9pZCBzZXRGcmFnQ29sb3IoZmxvYXQgdmFsdWUpIHtcbiAgICAgICAgICAgICR7Z2xzbC5vdXRwdXR9ID0gZW5jb2RlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBgLFxuICAgICAgICAgIFsnZW5jb2RpbmcuZW5jb2RlJ10pXG4gICAgfTtcbiAgfVxuICBwcm90ZWN0ZWQgZ2V0Q29sb3JBc0Zsb2F0KCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0Q29sb3JBc0Zsb2F0OiBuZXcgR2xzbExpYlJvdXRpbmUoXG4gICAgICAgICAgYFxuICAgICAgICBmbG9hdCBnZXRDb2xvckFzRmxvYXQodmVjNCBjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZShjb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgYCxcbiAgICAgICAgICBbJ2VuY29kaW5nLmRlY29kZSddKVxuICAgIH07XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtHbHNsQ29udGV4dCwgR2xzbExpYiwgR2xzbExpYlJvdXRpbmV9IGZyb20gJy4vZ2xzbC1kZWZpbml0aW9ucyc7XG5cbi8qKlxuICogR0xTTCBMaWJyYXJ5IHJlc3BvbnNpYmxlIGZvciBkYXRhIHR5cGVzIGFuZCByb3V0aW5lcyBmb3IgbWFuaXB1bGF0aW5nXG4gKiBjb29yZGluYXRlcyBhbmQgbWFwcGluZyB0by9mcm9tIHRlbnNvciBpbmRpY2VzXG4gKi9cbmV4cG9ydCBjbGFzcyBTaGFwZVV0aWxzR2xzbExpYiBleHRlbmRzIEdsc2xMaWIge1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0OiBHbHNsQ29udGV4dCkge1xuICAgIHN1cGVyKGNvbnRleHQpO1xuICB9XG4gIGdldEZ1bmN0aW9ucygpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnRoaXMuYmNhc3RJbmRleCgpLFxuICAgICAgLi4udGhpcy5iY2FzdE1hdG11bEluZGV4KCksXG4gICAgICAuLi50aGlzLm9mZnNldFRvSW5kaWNlcygpLFxuICAgICAgLi4udGhpcy5pbmRpY2VzVG9PZmZzZXQoKSxcbiAgICAgIC4uLnRoaXMuaW5jcmVtZW50SW5kaWNlcygpXG4gICAgfTtcbiAgfVxuICBnZXRDdXN0b21UeXBlcygpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcHJvdGVjdGVkIGJjYXN0SW5kZXgoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IG91dHB1dFJhbmsgPSB0aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dC5zaGFwZS5sZW5ndGg7XG4gICAgY29uc3QgcmVzdWx0OiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSA9IHt9O1xuICAgIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLmZvckVhY2goKG5hbWUsIGkpID0+IHtcbiAgICAgIGNvbnN0IHNoYXBlID0gdGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbaV0udW5wYWNrZWRTaGFwZTtcbiAgICAgIGlmIChzaGFwZS5sZW5ndGggPD0gb3V0cHV0UmFuaykge1xuICAgICAgICBjb25zdCByYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgICAgICBjb25zdCBkaW1PZmZzZXQgPSBvdXRwdXRSYW5rIC0gcmFuaztcbiAgICAgICAgY29uc3QgZnVuY05hbWUgPSBgYmNhc3RJbmRpY2VzXyR7bmFtZX1gO1xuICAgICAgICBsZXQgYmxvY2sgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rOyArK2kpIHtcbiAgICAgICAgICBibG9jayArPSBgXG4gICAgICAgICAgcmVhbEluZGljZXNbJHtpfV0gPSBpbnQoIG1vZChmbG9hdChiY2FzdGVkSW5kaWNlc1ske2RpbU9mZnNldCArIGl9XSksICR7c2hhcGVbaV19LjApICk7XG4gICAgICAgICAgYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0gYFxuICAgICAgICB2b2lkICR7ZnVuY05hbWV9IChpbnQgYmNhc3RlZEluZGljZXNbJHtvdXRwdXRSYW5rfV0sIG91dCBpbnQgcmVhbEluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgICAke2Jsb2NrfVxuICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSBuZXcgR2xzbExpYlJvdXRpbmUoYm9keSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBwcm90ZWN0ZWQgYmNhc3RNYXRtdWxJbmRleCgpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgY29uc3Qgb3V0cHV0UmFuayA9IHRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0LnNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCByZXN1bHQ6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9ID0ge307XG4gICAgdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgobmFtZSwgaSkgPT4ge1xuICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tpXS5zaGFwZTtcbiAgICAgIGlmICghKHNoYXBlLmxlbmd0aCA8IDIgfHwgc2hhcGUubGVuZ3RoID4gb3V0cHV0UmFuaykpIHtcbiAgICAgICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZGltT2Zmc2V0ID0gb3V0cHV0UmFuayAtIHJhbms7XG4gICAgICAgIGNvbnN0IGZ1bmNOYW1lID0gYGJjYXN0TWF0bXVsSW5kaWNlc18ke25hbWV9YDtcbiAgICAgICAgbGV0IGJsb2NrID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuayAtIDI7ICsraSkge1xuICAgICAgICAgIGJsb2NrICs9IGBcbiAgICAgICAgICByZWFsSW5kaWNlc1ske2l9XSA9IGludCggbW9kKGZsb2F0KGJjYXN0ZWRJbmRpY2VzWyR7ZGltT2Zmc2V0ICsgaX1dKSwgJHtzaGFwZVtpXX0uMCkgKTtcbiAgICAgICAgICBgO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSBgXG4gICAgICAgIHZvaWQgJHtmdW5jTmFtZX0oaW50IGJjYXN0ZWRJbmRpY2VzWyR7b3V0cHV0UmFua31dLCBvdXQgaW50IHJlYWxJbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgICAgJHtibG9ja31cbiAgICAgICAgICByZWFsSW5kaWNlc1ske3JhbmsgLSAxfV0gPSBiY2FzdGVkSW5kaWNlc1ske291dHB1dFJhbmsgLSAxfV07XG4gICAgICAgICAgcmVhbEluZGljZXNbJHtyYW5rIC0gMn1dID0gYmNhc3RlZEluZGljZXNbJHtvdXRwdXRSYW5rIC0gMn1dO1xuICAgICAgICB9XG4gICAgICAgIGA7XG4gICAgICAgIHJlc3VsdFtmdW5jTmFtZV0gPSBuZXcgR2xzbExpYlJvdXRpbmUoYm9keSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBwcm90ZWN0ZWQgaW5kaWNlc1RvT2Zmc2V0KCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCByZXN1bHQ6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9ID0ge307XG4gICAgdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgobmFtZSwgaSkgPT4ge1xuICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tpXS5zaGFwZTtcbiAgICAgIGNvbnN0IHN0cmlkZXMgPSB0aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tpXS5zdHJpZGVzO1xuICAgICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICAgIGxldCBmdW5jTmFtZSA9IGBpbmRpY2VzVG9PZmZzZXRfJHtuYW1lfWA7XG4gICAgICByZXN1bHRbZnVuY05hbWVdID0gbmV3IEdsc2xMaWJSb3V0aW5lKFNoYXBlVXRpbHNHbHNsTGliLmluZGV4VG9PZmZzZXRTaW5nbGUoZnVuY05hbWUsIHJhbmssIHN0cmlkZXMpKTtcbiAgICAgIGZ1bmNOYW1lID0gYGluZGljZXNUb09mZnNldF8ke25hbWV9X1RgO1xuICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9XG4gICAgICAgICAgbmV3IEdsc2xMaWJSb3V0aW5lKFNoYXBlVXRpbHNHbHNsTGliLmluZGV4VG9PZmZzZXRTaW5nbGUoZnVuY05hbWUsIHJhbmssIHN0cmlkZXMuc2xpY2UoKS5yZXZlcnNlKCkpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHN0YXRpYyBpbmRleFRvT2Zmc2V0U2luZ2xlKG5hbWU6IHN0cmluZywgcmFuazogbnVtYmVyLCBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSk6IHN0cmluZyB7XG4gICAgbGV0IGJsb2NrID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IHJhbmsgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgYmxvY2sgKz0gYFxuICAgICAgICBvZmZzZXQgKz0gaW5kaWNlc1ske2l9XSAqICR7c3RyaWRlc1tpXX07XG4gICAgICAgIGA7XG4gICAgfVxuICAgIHJldHVybiBgXG4gICAgICBpbnQgJHtuYW1lfShpbnQgaW5kaWNlc1ske3Jhbmt9XSkge1xuICAgICAgICBpbnQgb2Zmc2V0ID0gMDtcbiAgICAgICAgJHtibG9ja31cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgIH1cbiAgICAgIGA7XG4gIH1cbiAgcHJvdGVjdGVkIG9mZnNldFRvSW5kaWNlcygpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgY29uc3QgcmVzdWx0OiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSA9IHt9O1xuICAgIHRoaXMuY29udGV4dC5wcm9ncmFtSW5mby5pbnB1dE5hbWVzLmZvckVhY2goKG5hbWUsIGkpID0+IHtcbiAgICAgIGNvbnN0IHNoYXBlID0gdGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbaV0uc2hhcGU7XG4gICAgICBjb25zdCBzdHJpZGVzID0gdGhpcy5jb250ZXh0LmlucHV0VGV4dHVyZUxheW91dHNbaV0uc3RyaWRlcztcbiAgICAgIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gICAgICBsZXQgZnVuY05hbWUgPSBgb2Zmc2V0VG9JbmRpY2VzXyR7bmFtZX1gO1xuICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShTaGFwZVV0aWxzR2xzbExpYi5vZmZzZXRUb0luZGljZXNTaW5nbGUoZnVuY05hbWUsIHJhbmssIHN0cmlkZXMpKTtcbiAgICAgIGZ1bmNOYW1lID0gYG9mZnNldFRvSW5kaWNlc18ke25hbWV9X1RgO1xuICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9XG4gICAgICAgICAgbmV3IEdsc2xMaWJSb3V0aW5lKFNoYXBlVXRpbHNHbHNsTGliLm9mZnNldFRvSW5kaWNlc1NpbmdsZShmdW5jTmFtZSwgcmFuaywgc3RyaWRlcy5zbGljZSgpLnJldmVyc2UoKSkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc3RhdGljIG9mZnNldFRvSW5kaWNlc1NpbmdsZShuYW1lOiBzdHJpbmcsIHJhbms6IG51bWJlciwgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10pOiBzdHJpbmcge1xuICAgIGNvbnN0IHN0cmlkZXNCbG9jayA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuayAtIDE7ICsraSkge1xuICAgICAgc3RyaWRlc0Jsb2NrLnB1c2goYFxuICAgICAgaW5kaWNlc1ske2l9XSA9IG9mZnNldCAvICR7c3RyaWRlc1tpXX07YCk7XG4gICAgICBzdHJpZGVzQmxvY2sucHVzaChgXG4gICAgICAgIG9mZnNldCAtPSBpbmRpY2VzWyR7aX1dICogJHtzdHJpZGVzW2ldfTtgKTtcbiAgICB9XG4gICAgc3RyaWRlc0Jsb2NrLnB1c2goYFxuICAgICAgaW5kaWNlc1ske3JhbmsgLSAxfV0gPSBvZmZzZXQ7YCk7XG4gICAgcmV0dXJuIGBcbiAgICAgIHZvaWQgJHtuYW1lfShpbnQgb2Zmc2V0LCBvdXQgaW50IGluZGljZXNbJHtyYW5rfV0pIHtcbiAgICAgICAgJHtzdHJpZGVzQmxvY2suam9pbignJyl9XG4gICAgICB9XG4gICAgICBgO1xuICB9XG4gIHByb3RlY3RlZCBpbmNyZW1lbnRJbmRpY2VzKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCByZXN1bHQ6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9ID0ge307XG4gICAgdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMuZm9yRWFjaCgobmFtZSwgaSkgPT4ge1xuICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLmNvbnRleHQuaW5wdXRUZXh0dXJlTGF5b3V0c1tpXS5zaGFwZTtcbiAgICAgIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gICAgICBjb25zdCBmdW5jTmFtZSA9IGBpbmNyZW1lbnRJbmRpY2VzXyR7bmFtZX1gO1xuICAgICAgbGV0IHNoYXBlSW5pdCA9ICcnO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rOyArK2kpIHtcbiAgICAgICAgc2hhcGVJbml0ICs9IGBcbiAgICAgICAgc2hhcGVbJHtpfV0gPSAke3NoYXBlW2ldfTtgO1xuICAgICAgfVxuICAgICAgY29uc3QgYm9keSA9IGBcbiAgICAgICAgdm9pZCAke2Z1bmNOYW1lfShpbnQgYXhpcywgb3V0IGludCBpbmRpY2VzWyR7cmFua31dKSB7XG4gICAgICAgICAgaW50IHNoYXBlWyR7cmFua31dO1xuICAgICAgICAgICR7c2hhcGVJbml0fTtcbiAgICAgICAgICBmb3IoaW50IGkgPSAke3Jhbmt9IC0xIDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGlmKGkgPiBheGlzKSBjb250aW51ZTtcbiAgICAgICAgICAgIGluZGljZXNbaV0gKz0gMTtcbiAgICAgICAgICAgIGlmKGluZGljZXNbaV0gPCBzaGFwZVtpXSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGljZXNbaV0gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgcmVzdWx0W2Z1bmNOYW1lXSA9IG5ldyBHbHNsTGliUm91dGluZShib2R5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7R2xzbENvbnRleHQsIEdsc2xMaWIsIEdsc2xMaWJSb3V0aW5lfSBmcm9tICcuL2dsc2wtZGVmaW5pdGlvbnMnO1xuXG4vKipcbiAqIEdMU0wgTGlicmFyeSByZXNwb25zaWJsZSBmb3IgdmVjIHJvdXRpbmVzXG4gKiBWZWMgaXMgYW4gdmFyaWJsZSBsZW5ndGggaW50IGFycmF5LiBUaGUgbGVuZ3RoIGlzIGZpeGVkIGF0IHRoZSB0aW1lIG9mXG4gKiBnZW5lcmF0aW5nIHRoZSBsaWJyYXJ5IGZ1bmN0aW9ucyBmcm9tIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBvdXRwdXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBWZWNHbHNsTGliIGV4dGVuZHMgR2xzbExpYiB7XG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IEdsc2xDb250ZXh0KSB7XG4gICAgc3VwZXIoY29udGV4dCk7XG4gIH1cbiAgZ2V0Q3VzdG9tVHlwZXMoKToge1tuYW1lOiBzdHJpbmddOiBzdHJpbmd9IHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgZ2V0RnVuY3Rpb25zKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICByZXR1cm4gey4uLnRoaXMuYmluYXJ5VmVjRnVuY3Rpb25zKCksIC4uLnRoaXMuY29weVZlYygpLCAuLi50aGlzLnNldFZlY0l0ZW0oKSwgLi4udGhpcy5nZXRWZWNJdGVtKCl9O1xuICB9XG4gIHByb3RlY3RlZCBiaW5hcnlWZWNGdW5jdGlvbnMoKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IG91dHB1dExheW91dCA9IHRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0O1xuICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRMYXlvdXQuc2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IG5hbWVPcDoge1tuYW1lOiBzdHJpbmddOiBzdHJpbmd9ID0ge2FkZDogJys9Jywgc3ViOiAnLT0nLCBtdWw6ICcqPScsIGRpdjogJy89J307XG4gICAgY29uc3QgcmVzdWx0OiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSA9IHt9O1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiBuYW1lT3ApIHtcbiAgICAgIGNvbnN0IGZuYW1lID0gYCR7bmFtZX1WZWNgO1xuICAgICAgbGV0IGFzc2lnbm1lbnRCbG9jayA9ICcnO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rOyArK2kpIHtcbiAgICAgICAgYXNzaWdubWVudEJsb2NrICs9IGBcbiAgICAgICAgICBkZXN0WyR7aX1dICR7bmFtZU9wW25hbWVdfSBzcmNbJHtpfV07XG4gICAgICAgICAgYDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJvZHkgPSBgXG4gICAgICAgIHZvaWQgJHtmbmFtZX0oaW50IHNyY1ske3Jhbmt9XSwgb3V0IGludCBkZXN0WyR7cmFua31dKSB7XG4gICAgICAgICAgJHthc3NpZ25tZW50QmxvY2t9XG4gICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIHJlc3VsdFtmbmFtZV0gPSBuZXcgR2xzbExpYlJvdXRpbmUoYm9keSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBwcm90ZWN0ZWQgY29weVZlYygpOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJSb3V0aW5lfSB7XG4gICAgY29uc3Qgb3V0cHV0TGF5b3V0ID0gdGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQ7XG4gICAgY29uc3QgcmFuayA9IG91dHB1dExheW91dC5zaGFwZS5sZW5ndGg7XG4gICAgbGV0IGFzc2lnbm1lbnRCbG9jayA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgICBhc3NpZ25tZW50QmxvY2sgKz0gYFxuICAgICAgICBkZXN0WyR7aX1dID0gc3JjWyR7aX1dO1xuICAgICAgICBgO1xuICAgIH1cbiAgICBjb25zdCBib2R5ID0gYFxuICAgICAgdm9pZCBjb3B5VmVjKGludCBzcmNbJHtyYW5rfV0sIG91dCBpbnQgZGVzdFske3Jhbmt9XSkge1xuICAgICAgICAke2Fzc2lnbm1lbnRCbG9ja31cbiAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIHtjb3B5VmVjOiBuZXcgR2xzbExpYlJvdXRpbmUoYm9keSl9O1xuICB9XG5cbiAgcHJvdGVjdGVkIHNldFZlY0l0ZW0oKToge1tuYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZX0ge1xuICAgIGNvbnN0IG91dHB1dExheW91dCA9IHRoaXMuY29udGV4dC5vdXRwdXRUZXh0dXJlTGF5b3V0O1xuICAgIGNvbnN0IHJhbmsgPSBvdXRwdXRMYXlvdXQuc2hhcGUubGVuZ3RoO1xuICAgIGxldCBibG9jayA9IGBcbiAgICAgICAgaWYoaW5kZXggPCAwKVxuICAgICAgICAgICAgaW5kZXggPSR7cmFua30gKyBpbmRleDtcbiAgICAgICAgaWYgKGluZGV4ID09IDApXG4gICAgICAgICAgICBtWzBdID0gdmFsdWU7XG4gICAgICAgIGA7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCByYW5rIC0gMTsgKytpKSB7XG4gICAgICBibG9jayArPSBgXG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09ICR7aX0pXG4gICAgICAgICAgICBtWyR7aX1dID0gdmFsdWU7XG4gICAgICAgICAgICBgO1xuICAgIH1cbiAgICBibG9jayArPSBgXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1bJHtyYW5rIC0gMX1dID0gdmFsdWU7XG4gICAgICAgIGA7XG4gICAgY29uc3QgYm9keSA9IGBcbiAgICAgIHZvaWQgc2V0VmVjSXRlbShvdXQgaW50IG1bJHtyYW5rfV0sIGludCBpbmRleCwgaW50IHZhbHVlKSB7XG4gICAgICAgICR7YmxvY2t9XG4gICAgICB9XG4gICAgICAgIGA7XG4gICAgcmV0dXJuIHtzZXRWZWNJdGVtOiBuZXcgR2xzbExpYlJvdXRpbmUoYm9keSl9O1xuICB9XG4gIHByb3RlY3RlZCBnZXRWZWNJdGVtKCk6IHtbbmFtZTogc3RyaW5nXTogR2xzbExpYlJvdXRpbmV9IHtcbiAgICBjb25zdCBvdXRwdXRMYXlvdXQgPSB0aGlzLmNvbnRleHQub3V0cHV0VGV4dHVyZUxheW91dDtcbiAgICBjb25zdCByYW5rID0gb3V0cHV0TGF5b3V0LnNoYXBlLmxlbmd0aDtcbiAgICBsZXQgYmxvY2sgPSBgXG4gICAgICAgIGlmKGluZGV4IDwgMClcbiAgICAgICAgICAgIGluZGV4ID0gJHtyYW5rfSArIGluZGV4O1xuICAgICAgICBpZiAoaW5kZXggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBtWzBdO1xuICAgICAgYDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHJhbmsgLSAxOyArK2kpIHtcbiAgICAgIGJsb2NrICs9IGBcbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPT0gJHtpfSlcbiAgICAgICAgICAgIHJldHVybiBtWyR7aX1dO1xuICAgICAgYDtcbiAgICB9XG4gICAgYmxvY2sgKz0gYFxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbVske3JhbmsgLSAxfV07XG4gICAgICAgIGA7XG4gICAgY29uc3QgYm9keSA9IGBcbiAgICAgIGludCBnZXRWZWNJdGVtKGludCBtWyR7cmFua31dLCBpbnQgaW5kZXgpIHtcbiAgICAgICAgJHtibG9ja31cbiAgICAgIH1cbiAgICBgO1xuICAgIHJldHVybiB7Z2V0VmVjSXRlbTogbmV3IEdsc2xMaWJSb3V0aW5lKGJvZHkpfTtcbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0Nvb3Jkc0dsc2xMaWJ9IGZyb20gJy4vZ2xzbC1jb29yZGluYXRlLWxpYic7XG5pbXBvcnQge0dsc2xDb250ZXh0LCBHbHNsTGlifSBmcm9tICcuL2dsc2wtZGVmaW5pdGlvbnMnO1xuaW1wb3J0IHtFbmNvZGluZ0dsc2xMaWJ9IGZyb20gJy4vZ2xzbC1lbmNvZGluZy1saWInO1xuaW1wb3J0IHtGcmFnQ29sb3JHbHNsTGlifSBmcm9tICcuL2dsc2wtZnJhZ2NvbG9yLWxpYic7XG5pbXBvcnQge1NoYXBlVXRpbHNHbHNsTGlifSBmcm9tICcuL2dsc2wtc2hhcGUtdXRpbHMtbGliJztcbmltcG9ydCB7VmVjR2xzbExpYn0gZnJvbSAnLi9nbHNsLXZlYy1saWInO1xuXG5leHBvcnQgY29uc3QgZ2xzbFJlZ2lzdHJ5OiB7W25hbWU6IHN0cmluZ106IG5ldyAoY29udGV4dDogR2xzbENvbnRleHQpID0+IEdsc2xMaWJ9ID0ge1xuICAnZW5jb2RpbmcnOiBFbmNvZGluZ0dsc2xMaWIsXG4gICdmcmFnY29sb3InOiBGcmFnQ29sb3JHbHNsTGliLFxuICAndmVjJzogVmVjR2xzbExpYixcbiAgJ3NoYXBlVXRpbHMnOiBTaGFwZVV0aWxzR2xzbExpYixcbiAgJ2Nvb3JkaW5hdGVzJzogQ29vcmRzR2xzbExpYixcbiAgLy8gICdhcnJheXMnOiBBcnJheUdsc2xTTGliXG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0dsc2xDb250ZXh0LCBHbHNsTGliLCBHbHNsTGliUm91dGluZU5vZGUsIFRvcG9sb2dpY2FsU29ydEdsc2xSb3V0aW5lc30gZnJvbSAnLi9nbHNsLWRlZmluaXRpb25zJztcbmltcG9ydCB7cmVwbGFjZUlubGluZXN9IGZyb20gJy4vZ2xzbC1mdW5jdGlvbi1pbmxpbmVyJztcbmltcG9ydCB7Z2xzbFJlZ2lzdHJ5fSBmcm9tICcuL2dsc2wtcmVnaXN0ZXJlZC1saWJzJztcbmltcG9ydCB7Z2V0RGVmYXVsdEZyYWdTaGFkZXJNYWluLCBnZXRGcmFnU2hhZGVyUHJlYW1ibGV9IGZyb20gJy4vZ2xzbC1zb3VyY2UnO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgVGV4dHVyZUxheW91dCwgVmFyaWFibGVJbmZvfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7V2ViR0xDb250ZXh0fSBmcm9tICcuL3dlYmdsLWNvbnRleHQnO1xuXG4vKipcbiAqIFByZXByb2Nlc3NvciBmb3IgdGhlIGFkZGl0aW9ucyB0byB0aGUgR0xTTCBsYW5ndWFnZVxuICogSXQgZGVhbHMgd2l0aDpcbiAqICBAaW5jbHVkZSBkaXJlY3RpdmVzXG4gKiAgQGlubGluZVxuICogIExvb3AgdW5yb2xsaW5nIChub3QgaW1wbGVtZW50ZWQpXG4gKiAgTWFjcm8gcmVzb2x1dGlvbiAobm90IGltcGxlbWVudGVkKVxuICovXG5leHBvcnQgY2xhc3MgR2xzbFByZXByb2Nlc3NvciB7XG4gIHJlYWRvbmx5IGNvbnRleHQ6IEdsc2xDb250ZXh0O1xuICByZWFkb25seSBsaWJzOiB7W25hbWU6IHN0cmluZ106IEdsc2xMaWJ9ID0ge307XG4gIHJlYWRvbmx5IGdsc2xMaWJSb3V0aW5lRGVwZW5kZW5jeUdyYXBoOiB7W3JvdXRpbmVOYW1lOiBzdHJpbmddOiBHbHNsTGliUm91dGluZU5vZGV9ID0ge307XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBnbENvbnRleHQ6IFdlYkdMQ29udGV4dCwgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dFRleHR1cmVMYXlvdXRzOiBUZXh0dXJlTGF5b3V0W10sXG4gICAgICBvdXRwdXRUZXh0dXJlTGF5b3V0OiBUZXh0dXJlTGF5b3V0KSB7XG4gICAgdGhpcy5jb250ZXh0ID0gbmV3IEdsc2xDb250ZXh0KGdsQ29udGV4dCwgcHJvZ3JhbUluZm8sIGlucHV0VGV4dHVyZUxheW91dHMsIG91dHB1dFRleHR1cmVMYXlvdXQpO1xuXG4gICAgLy8gY29uc3RydWN0IEdsc2xMaWJzXG4gICAgT2JqZWN0LmtleXMoZ2xzbFJlZ2lzdHJ5KS5mb3JFYWNoKChuYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IGxpYiA9IG5ldyBnbHNsUmVnaXN0cnlbbmFtZV0odGhpcy5jb250ZXh0KTtcbiAgICAgIHRoaXMubGlic1tuYW1lXSA9IGxpYjtcbiAgICB9KTtcblxuICAgIC8vIGNvbnN0cnVjdCBHbHNsUm91dGluZURlcGVuZGVuY3lHcmFwaFxuICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2xzbExpYlJvdXRpbmVEZXBlbmRlbmN5R3JhcGg7XG4gICAgZm9yIChjb25zdCBsaWJOYW1lIGluIHRoaXMubGlicykge1xuICAgICAgY29uc3QgbGliID0gdGhpcy5saWJzW2xpYk5hbWVdO1xuICAgICAgY29uc3Qgcm91dGluZXNJbkxpYiA9IGxpYi5nZXRGdW5jdGlvbnMoKTtcbiAgICAgIGZvciAoY29uc3Qgcm91dGluZSBpbiByb3V0aW5lc0luTGliKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGxpYk5hbWUgKyAnLicgKyByb3V0aW5lO1xuICAgICAgICBsZXQgY3VycmVudE5vZGU6IEdsc2xMaWJSb3V0aW5lTm9kZTtcbiAgICAgICAgaWYgKG1hcFtrZXldKSB7XG4gICAgICAgICAgY3VycmVudE5vZGUgPSBtYXBba2V5XTtcbiAgICAgICAgICBjdXJyZW50Tm9kZS5yb3V0aW5lQm9keSA9IHJvdXRpbmVzSW5MaWJbcm91dGluZV0ucm91dGluZUJvZHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudE5vZGUgPSBuZXcgR2xzbExpYlJvdXRpbmVOb2RlKGtleSwgcm91dGluZXNJbkxpYltyb3V0aW5lXS5yb3V0aW5lQm9keSk7XG4gICAgICAgICAgbWFwW2tleV0gPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSByb3V0aW5lc0luTGliW3JvdXRpbmVdLmRlcGVuZGVuY2llcztcbiAgICAgICAgaWYgKGRlcGVuZGVuY2llcykge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIW1hcFtkZXBlbmRlbmNpZXNbaV1dKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgR2xzbExpYlJvdXRpbmVOb2RlKGRlcGVuZGVuY2llc1tpXSk7XG4gICAgICAgICAgICAgIG1hcFtkZXBlbmRlbmNpZXNbaV1dID0gbm9kZTtcbiAgICAgICAgICAgICAgY3VycmVudE5vZGUuYWRkRGVwZW5kZW5jeShub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnJlbnROb2RlLmFkZERlcGVuZGVuY3kobWFwW2RlcGVuZGVuY2llc1tpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByZXByb2Nlc3MoKTogc3RyaW5nIHtcbiAgICBjb25zdCBwcm9ncmFtSW5mbyA9IHRoaXMuY29udGV4dC5wcm9ncmFtSW5mbztcbiAgICBsZXQgc291cmNlID0gcHJvZ3JhbUluZm8uc2hhZGVyU291cmNlO1xuXG4gICAgLy8gYXBwZW5kIG1haW4oKSBmdW5jdGlvblxuICAgIGlmICghdGhpcy5jb250ZXh0LnByb2dyYW1JbmZvLmhhc01haW4pIHtcbiAgICAgIHNvdXJjZSA9IGAke3NvdXJjZX1cbiAgICAgICR7Z2V0RGVmYXVsdEZyYWdTaGFkZXJNYWluKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbiwgdGhpcy5jb250ZXh0Lm91dHB1dFRleHR1cmVMYXlvdXQuc2hhcGUubGVuZ3RoKX1gO1xuICAgIH1cbiAgICAvLyByZXBsYWNlIGlubGluZXNcbiAgICBzb3VyY2UgPSByZXBsYWNlSW5saW5lcyhzb3VyY2UpO1xuXG4gICAgLy8gY29uY2F0IGZpbmFsIHNvdXJjZSBzdHJpbmdcbiAgICByZXR1cm4gYCR7Z2V0RnJhZ1NoYWRlclByZWFtYmxlKHRoaXMuY29udGV4dC5nbENvbnRleHQudmVyc2lvbil9XG4gICAgJHt0aGlzLmdldFVuaWZvcm1zKHByb2dyYW1JbmZvLmlucHV0TmFtZXMsIHByb2dyYW1JbmZvLnZhcmlhYmxlcyl9XG4gICAgJHt0aGlzLmdldEltcG9ydHMoc291cmNlKX1cbiAgICAke3NvdXJjZX1gO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldEltcG9ydHMoc2NyaXB0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IHJvdXRpbmVzSW5jbHVkZWQgPSB0aGlzLnNlbGVjdEdsc2xMaWJSb3V0aW5lc1RvQmVJbmNsdWRlZChzY3JpcHQpO1xuXG4gICAgaWYgKHJvdXRpbmVzSW5jbHVkZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgbGV0IHJvdXRpbmVzID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0aW5lc0luY2x1ZGVkLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAocm91dGluZXNJbmNsdWRlZFtpXS5yb3V0aW5lQm9keSkge1xuICAgICAgICByb3V0aW5lcyArPSByb3V0aW5lc0luY2x1ZGVkW2ldLnJvdXRpbmVCb2R5ICsgJ1xcbic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgYm9keSBmb3IgdGhlIEdsc2wgTGlicmFyeSByb3V0aW5lOiAke3JvdXRpbmVzSW5jbHVkZWRbaV0ubmFtZX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcm91dGluZXM7XG4gIH1cbiAgcHJpdmF0ZSBzZWxlY3RHbHNsTGliUm91dGluZXNUb0JlSW5jbHVkZWQoc2NyaXB0OiBzdHJpbmcpOiBHbHNsTGliUm91dGluZU5vZGVbXSB7XG4gICAgY29uc3Qgbm9kZXM6IEdsc2xMaWJSb3V0aW5lTm9kZVtdID0gW107XG5cbiAgICBPYmplY3Qua2V5cyh0aGlzLmdsc2xMaWJSb3V0aW5lRGVwZW5kZW5jeUdyYXBoKS5mb3JFYWNoKGNsYXNzQW5kUm91dGluZSA9PiB7XG4gICAgICBjb25zdCByb3V0aW5lID0gY2xhc3NBbmRSb3V0aW5lLnNwbGl0KCcuJylbMV07XG4gICAgICBpZiAoc2NyaXB0LmluZGV4T2Yocm91dGluZSkgIT09IC0xKSB7XG4gICAgICAgIG5vZGVzLnB1c2godGhpcy5nbHNsTGliUm91dGluZURlcGVuZGVuY3lHcmFwaFtjbGFzc0FuZFJvdXRpbmVdKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBUb3BvbG9naWNhbFNvcnRHbHNsUm91dGluZXMucmV0dXJuT3JkZXJlZE5vZGVzKG5vZGVzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRVbmlmb3JtcyhzYW1wbGVycz86IHN0cmluZ1tdLCB2YXJpYWJsZXM/OiBWYXJpYWJsZUluZm9bXSk6IHN0cmluZyB7XG4gICAgY29uc3QgdW5pZm9ybUxpbmVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGlmIChzYW1wbGVycykge1xuICAgICAgZm9yIChjb25zdCBzYW1wbGVyIG9mIHNhbXBsZXJzKSB7XG4gICAgICAgIHVuaWZvcm1MaW5lcy5wdXNoKGB1bmlmb3JtIHNhbXBsZXIyRCAke3NhbXBsZXJ9O2ApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFyaWFibGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IHZhcmlhYmxlIG9mIHZhcmlhYmxlcykge1xuICAgICAgICB1bmlmb3JtTGluZXMucHVzaChcbiAgICAgICAgICAgIGB1bmlmb3JtICR7dmFyaWFibGUudHlwZX0gJHt2YXJpYWJsZS5uYW1lfSR7dmFyaWFibGUuYXJyYXlMZW5ndGggPyBgWyR7dmFyaWFibGUuYXJyYXlMZW5ndGh9XWAgOiAnJ307YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmlmb3JtTGluZXMuam9pbignXFxuJyk7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtlbnZ9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7TG9nZ2VyLCBQcm9maWxlcn0gZnJvbSAnLi4vLi4vaW5zdHJ1bWVudCc7XG5cbmltcG9ydCB7R2xzbFByZXByb2Nlc3Nvcn0gZnJvbSAnLi9nbHNsLXByZXByb2Nlc3Nvcic7XG5pbXBvcnQge2dldFZlcnRleFNoYWRlclNvdXJjZX0gZnJvbSAnLi9nbHNsLXNvdXJjZSc7XG5pbXBvcnQge1RleHR1cmVMYXlvdXRTdHJhdGVneX0gZnJvbSAnLi90ZXh0dXJlLWxheW91dC1zdHJhdGVneSc7XG5pbXBvcnQge0FydGlmYWN0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVZhcmlhYmxlLCBUZXh0dXJlRGF0YSwgVGV4dHVyZUxheW91dCwgVmFyaWFibGVJbmZvfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7V2ViR0xDb250ZXh0fSBmcm9tICcuL3dlYmdsLWNvbnRleHQnO1xuXG4vKipcbiAqIFByb2dyYW1NYW5hZ2VyIGlzIHRoZSBtYWluIGNsYXNzIGJlaGluZCBydW5uaW5nIGNvbXB1dGF0aW9uc1xuICogSXQgYnVpbGRzIFByb2dyYW1JbmZvJ3MgaW50byBBcnRpZmFjdHNcbiAqIEl0IGNvbXBpbGVzIGdpdmVuIFByb2dyYW1JbmZvJ3MgaW50byBXZWJHTCBQcm9yYW1zIChjYWNoZWQgYXMgQXJ0aWZhY3RzKVxuICogVXNlcyB0aGUgYXJ0aWZhY3QgdG8gcnVuIHRoZSBjb21wdXRhdGlvbiBieSBjYWxsaW5nIERyYXcgb25cbiAqIHRoZSBXZWJHTCBkcmF3aW5nIGJ1ZmZlclxuICogUHJvZ3JhbU1hbmFnZXIgYXV0b21hdGljYWxseSBtYXBzIChiaW5kcykgaW5wdXQgdmFyaWFibGVzIHRvIHRoZWlyXG4gKiBjb3JyZXNwb25kaW5nIExvY2F0aW9uJ3MgaW4gdGhlIGJpbmFyeSBwcm9ncmFtXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9ncmFtTWFuYWdlciB7XG4gIHJlcG86IE1hcDx1bmtub3duLCBBcnRpZmFjdD47ICAvLyB0aGlzIHNob3VsZCBiZSBwZXItc2Vzc2lvbiBvYmplY3RcbiAgdmVydGV4U2hhZGVyOiBXZWJHTFNoYWRlcjtcbiAgYXR0cmlidXRlc0JvdW5kOiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHVibGljIHByb2ZpbGVyOiBSZWFkb25seTxQcm9maWxlcj4sIHB1YmxpYyBnbENvbnRleHQ6IFdlYkdMQ29udGV4dCxcbiAgICAgIHB1YmxpYyB0ZXh0dXJlTGF5b3V0U3RyYXRlZ3k6IFRleHR1cmVMYXlvdXRTdHJhdGVneSkge1xuICAgIHRoaXMucmVwbyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmF0dHJpYnV0ZXNCb3VuZCA9IGZhbHNlO1xuICB9XG4gIGdldEFydGlmYWN0KGtleTogdW5rbm93bik6IEFydGlmYWN0fHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMucmVwby5nZXQoa2V5KTtcbiAgfVxuICBzZXRBcnRpZmFjdChrZXk6IHVua25vd24sIGFydGlmYWN0OiBBcnRpZmFjdCk6IHZvaWQge1xuICAgIHRoaXMucmVwby5zZXQoa2V5LCBhcnRpZmFjdCk7XG4gIH1cbiAgcnVuKGJ1aWxkQXJ0aWZhY3Q6IEFydGlmYWN0LCBpbnB1dHM6IFRleHR1cmVEYXRhW10sIG91dHB1dDogVGV4dHVyZURhdGEpOiB2b2lkIHtcbiAgICB0aGlzLnByb2ZpbGVyLmV2ZW50KCdvcCcsIGBQcm9ncmFtTWFuYWdlci5ydW4gJHtidWlsZEFydGlmYWN0LnByb2dyYW1JbmZvLm5hbWUgPz8gJ3Vua25vd24ga2VybmVsJ31gLCAoKSA9PiB7XG4gICAgICBjb25zdCBnbCA9IHRoaXMuZ2xDb250ZXh0LmdsO1xuICAgICAgY29uc3QgcHJvZ3JhbSA9IGJ1aWxkQXJ0aWZhY3QucHJvZ3JhbTtcbiAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmJpbmRPdXRwdXQob3V0cHV0KTtcbiAgICAgICAgaWYgKCF0aGlzLmF0dHJpYnV0ZXNCb3VuZCkge1xuICAgICAgICAgIHRoaXMuYmluZEF0dHJpYnV0ZXMoYnVpbGRBcnRpZmFjdC5hdHRyaWJMb2NhdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmluZFVuaWZvcm1zKGJ1aWxkQXJ0aWZhY3QudW5pZm9ybUxvY2F0aW9ucywgYnVpbGRBcnRpZmFjdC5wcm9ncmFtSW5mby52YXJpYWJsZXMgPz8gW10sIGlucHV0cyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgTG9nZ2VyLmVycm9yKCdQcm9ncmFtTWFuYWdlcicsIGJ1aWxkQXJ0aWZhY3QucHJvZ3JhbUluZm8uc2hhZGVyU291cmNlKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgdGhpcy5wcm9maWxlci5ldmVudCgnYmFja2VuZCcsICdHbENvbnRleHQuZHJhdygpJywgKCkgPT4ge1xuICAgICAgICB0aGlzLmdsQ29udGV4dC5kcmF3KCk7XG4gICAgICB9KTtcbiAgICB9LCB0aGlzLmdsQ29udGV4dCk7XG4gIH1cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy52ZXJ0ZXhTaGFkZXIpIHtcbiAgICAgIHRoaXMuZ2xDb250ZXh0LmRlbGV0ZVNoYWRlcih0aGlzLnZlcnRleFNoYWRlcik7XG4gICAgfVxuICAgIHRoaXMucmVwby5mb3JFYWNoKGEgPT4gdGhpcy5nbENvbnRleHQuZGVsZXRlUHJvZ3JhbShhLnByb2dyYW0pKTtcbiAgfVxuICBidWlsZChwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIGlucHV0VGV4dHVyZUxheW91dHM6IFRleHR1cmVMYXlvdXRbXSwgb3V0cHV0VGV4dHVyZUxheW91dDogVGV4dHVyZUxheW91dCk6IEFydGlmYWN0IHtcbiAgICByZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudCgnYmFja2VuZCcsICdQcm9ncmFtTWFuYWdlci5idWlsZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHByZXByb2Nlc3NvciA9IG5ldyBHbHNsUHJlcHJvY2Vzc29yKHRoaXMuZ2xDb250ZXh0LCBwcm9ncmFtSW5mbywgaW5wdXRUZXh0dXJlTGF5b3V0cywgb3V0cHV0VGV4dHVyZUxheW91dCk7XG4gICAgICBjb25zdCBmcmFnU2NyaXB0ID0gcHJlcHJvY2Vzc29yLnByZXByb2Nlc3MoKTtcbiAgICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLmNvbXBpbGUoZnJhZ1NjcmlwdCk7XG4gICAgICBjb25zdCBhcnRpZmFjdCA9IHtcbiAgICAgICAgcHJvZ3JhbUluZm8sXG4gICAgICAgIHByb2dyYW0sXG4gICAgICAgIHVuaWZvcm1Mb2NhdGlvbnM6IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9ucyhcbiAgICAgICAgICAgIHByb2dyYW0sIHByZXByb2Nlc3Nvci5jb250ZXh0LnByb2dyYW1JbmZvLmlucHV0TmFtZXMsIHByZXByb2Nlc3Nvci5jb250ZXh0LnByb2dyYW1JbmZvLnZhcmlhYmxlcyksXG4gICAgICAgIGF0dHJpYkxvY2F0aW9uczogdGhpcy5nZXRBdHRyaWJMb2NhdGlvbnMocHJvZ3JhbSlcbiAgICAgIH07XG4gICAgICByZXR1cm4gYXJ0aWZhY3Q7XG4gICAgfSk7XG4gIH1cbiAgcHJvdGVjdGVkIGNvbXBpbGUoZnJhZ1NoYWRlclNjcmlwdDogc3RyaW5nKTogV2ViR0xQcm9ncmFtIHtcbiAgICBpZiAoIXRoaXMudmVydGV4U2hhZGVyKSB7XG4gICAgICBMb2dnZXIudmVyYm9zZSgnUHJvcmdyYW1NYW5hZ2VyJywgJ0NvbXBpbGluZyBhbmQgY2FjaGluZyBWZXJ0ZXggc2hhZGVyIGZvciB0aGUgZmlyc3QgdGltZScpO1xuICAgICAgY29uc3QgdmVydGV4U2hhZGVyU2NyaXB0ID0gZ2V0VmVydGV4U2hhZGVyU291cmNlKHRoaXMuZ2xDb250ZXh0LnZlcnNpb24pO1xuICAgICAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSB0aGlzLmdsQ29udGV4dC5jb21waWxlU2hhZGVyKHZlcnRleFNoYWRlclNjcmlwdCwgdGhpcy5nbENvbnRleHQuZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgfVxuICAgIGlmIChlbnYuZGVidWcpIHtcbiAgICAgIExvZ2dlci52ZXJib3NlKCdQcm9yZ3JhbU1hbmFnZXInLCBgRnJhZ1NoYWRlcjpcbiR7ZnJhZ1NoYWRlclNjcmlwdH1cbmApO1xuICAgIH1cbiAgICBjb25zdCBmcmFnU2hhZGVyID0gdGhpcy5nbENvbnRleHQuY29tcGlsZVNoYWRlcihmcmFnU2hhZGVyU2NyaXB0LCB0aGlzLmdsQ29udGV4dC5nbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLmdsQ29udGV4dC5jcmVhdGVQcm9ncmFtKHRoaXMudmVydGV4U2hhZGVyLCBmcmFnU2hhZGVyKTtcbiAgICB0aGlzLmdsQ29udGV4dC5kZWxldGVTaGFkZXIoZnJhZ1NoYWRlcik7XG4gICAgcmV0dXJuIHByb2dyYW07XG4gIH1cbiAgYmluZE91dHB1dCh0ZDogVGV4dHVyZURhdGEpOiB2b2lkIHtcbiAgICBjb25zdCB3aWR0aCA9IHRkLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRkLmhlaWdodDtcbiAgICBMb2dnZXIudmVyYm9zZShcbiAgICAgICAgJ1Byb3JncmFtTWFuYWdlcicsXG4gICAgICAgIGBCaW5kaW5nIG91dHB1dCB0ZXh0dXJlIHRvIEZyYW1lYnVmZmVyOiB3L2g9JHt3aWR0aH0vJHtoZWlnaHR9LCBzaGFwZT0ke3RkLnNoYXBlfSwgdHlwZT0ke3RkLnRlbnNvci50eXBlfWApO1xuICAgIHRoaXMuZ2xDb250ZXh0LmF0dGFjaEZyYW1lYnVmZmVyKHRkLnRleHR1cmUsIHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIGJpbmRBdHRyaWJ1dGVzKGF0dHJpYkxvY2F0aW9uczogQXJ0aWZhY3QuQXR0cmliTG9jYXRpb25zKTogdm9pZCB7XG4gICAgY29uc3QgcG9zaXRpb25IYW5kbGUgPSBhdHRyaWJMb2NhdGlvbnMucG9zaXRpb247XG4gICAgY29uc3QgdGV4dHVyZUNvb3JkSGFuZGxlID0gYXR0cmliTG9jYXRpb25zLnRleHR1cmVDb29yZDtcbiAgICB0aGlzLmdsQ29udGV4dC5zZXRWZXJ0ZXhBdHRyaWJ1dGVzKHBvc2l0aW9uSGFuZGxlLCB0ZXh0dXJlQ29vcmRIYW5kbGUpO1xuICAgIHRoaXMuYXR0cmlidXRlc0JvdW5kID0gdHJ1ZTtcbiAgfVxuICBiaW5kVW5pZm9ybXModW5pZm9ybUxvY2F0aW9uczogQXJ0aWZhY3QuVW5pZm9ybUxvY2F0aW9ucywgdmFyaWFibGVzOiBQcm9ncmFtVmFyaWFibGVbXSwgdGV4dHVyZXM6IFRleHR1cmVEYXRhW10pOlxuICAgICAgdm9pZCB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsQ29udGV4dC5nbDtcbiAgICBsZXQgdGV4dHVyZVBvc2l0aW9uID0gMDtcbiAgICBmb3IgKGNvbnN0IHtuYW1lLCB0eXBlLCBsb2NhdGlvbiwgYXJyYXlMZW5ndGh9IG9mIHVuaWZvcm1Mb2NhdGlvbnMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdmFyaWFibGVzLmZpbmQodiA9PiB2Lm5hbWUgPT09IG5hbWUpPy5kYXRhO1xuICAgICAgaWYgKHR5cGUgIT09ICdzYW1wbGVyMkQnICYmICF2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZhcmlhYmxlICcke25hbWV9JyBkb2VzIG5vdCBoYXZlIGRhdGEgZGVmaW5lZCBpbiBwcm9ncmFtIGluZm9gKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdzYW1wbGVyMkQnOlxuICAgICAgICAgIHRoaXMuYmluZFRleHR1cmUodGV4dHVyZXNbdGV4dHVyZVBvc2l0aW9uXSwgbG9jYXRpb24sIHRleHR1cmVQb3NpdGlvbik7XG4gICAgICAgICAgdGV4dHVyZVBvc2l0aW9uKys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgICBpZiAoYXJyYXlMZW5ndGgpIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xZnYobG9jYXRpb24sIHZhbHVlIGFzIG51bWJlcltdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKGxvY2F0aW9uLCB2YWx1ZSBhcyBudW1iZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW50JzpcbiAgICAgICAgICBpZiAoYXJyYXlMZW5ndGgpIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xaXYobG9jYXRpb24sIHZhbHVlIGFzIG51bWJlcltdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB2YWx1ZSBhcyBudW1iZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaWZvcm0gbm90IGltcGxlbWVudGVkOiAke3R5cGV9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGJpbmRUZXh0dXJlKHRkOiBUZXh0dXJlRGF0YSwgdW5pZm9ybUhhbmRsZTogV2ViR0xVbmlmb3JtTG9jYXRpb24sIHBvc2l0aW9uOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmdsQ29udGV4dC5iaW5kVGV4dHVyZVRvVW5pZm9ybSh0ZC50ZXh0dXJlLCBwb3NpdGlvbiwgdW5pZm9ybUhhbmRsZSk7XG4gIH1cbiAgZ2V0QXR0cmliTG9jYXRpb25zKHByb2dyYW06IFdlYkdMUHJvZ3JhbSk6IEFydGlmYWN0LkF0dHJpYkxvY2F0aW9ucyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc2l0aW9uOiB0aGlzLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdwb3NpdGlvbicpLFxuICAgICAgdGV4dHVyZUNvb3JkOiB0aGlzLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICd0ZXh0dXJlQ29vcmQnKVxuICAgIH07XG4gIH1cbiAgZ2V0VW5pZm9ybUxvY2F0aW9ucyhwcm9ncmFtOiBXZWJHTFByb2dyYW0sIHNhbXBsZXJzPzogc3RyaW5nW10sIHZhcmlhYmxlcz86IFZhcmlhYmxlSW5mb1tdKTpcbiAgICAgIEFydGlmYWN0LlVuaWZvcm1Mb2NhdGlvbnMge1xuICAgIGNvbnN0IHVuaWZvcm1Mb2NhdGlvbnM6IEFydGlmYWN0LlVuaWZvcm1Mb2NhdGlvbnMgPSBbXTtcbiAgICBpZiAoc2FtcGxlcnMpIHtcbiAgICAgIGZvciAoY29uc3Qgc2FtcGxlciBvZiBzYW1wbGVycykge1xuICAgICAgICB1bmlmb3JtTG9jYXRpb25zLnB1c2goe25hbWU6IHNhbXBsZXIsIHR5cGU6ICdzYW1wbGVyMkQnLCBsb2NhdGlvbjogdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgc2FtcGxlcil9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhcmlhYmxlcykge1xuICAgICAgZm9yIChjb25zdCB2YXJpYWJsZSBvZiB2YXJpYWJsZXMpIHtcbiAgICAgICAgdW5pZm9ybUxvY2F0aW9ucy5wdXNoKHsuLi52YXJpYWJsZSwgbG9jYXRpb246IHRoaXMuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIHZhcmlhYmxlLm5hbWUpfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmlmb3JtTG9jYXRpb25zO1xuICB9XG4gIGdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtOiBXZWJHTFByb2dyYW0sIG5hbWU6IHN0cmluZyk6IFdlYkdMVW5pZm9ybUxvY2F0aW9uIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2xDb250ZXh0LmdsO1xuICAgIGNvbnN0IHJlZmVyZW5jZSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBuYW1lKTtcbiAgICBpZiAocmVmZXJlbmNlID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaWZvcm0gJHtuYW1lfSBub3QgZm91bmQuYCk7XG4gICAgfVxuICAgIHJldHVybiByZWZlcmVuY2U7XG4gIH1cbiAgZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbTogV2ViR0xQcm9ncmFtLCBuYW1lOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbENvbnRleHQuZ2w7XG4gICAgY29uc3QgYXR0cmlidXRlTG9jYXRpb246IG51bWJlciA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIG5hbWUpO1xuICAgIHJldHVybiBhdHRyaWJ1dGVMb2NhdGlvbjtcbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0xvZ2dlciwgUHJvZmlsZXJ9IGZyb20gJy4uLy4uL2luc3RydW1lbnQnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uL3RlbnNvcic7XG5cbmltcG9ydCB7RW5jb2RlciwgRW5jb2RlclVzYWdlfSBmcm9tICcuL3RleHR1cmUtZGF0YS1lbmNvZGVyJztcbmltcG9ydCB7VGV4dHVyZUxheW91dFN0cmF0ZWd5fSBmcm9tICcuL3RleHR1cmUtbGF5b3V0LXN0cmF0ZWd5JztcbmltcG9ydCB7VGV4dHVyZURhdGEsIFRleHR1cmVMYXlvdXR9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHtXZWJHTENvbnRleHR9IGZyb20gJy4vd2ViZ2wtY29udGV4dCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dHVyZU1hbmFnZXJDb25maWcge1xuICByZXVzZVRleHR1cmVzPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBUZXh0dXJlTWFuYWdlciBpcyB0aGUgbWFpbmx5IHJlc3BvbnNpYmxlIGZvciBjYWNoaW5nIFRleHR1cmVzXG4gKiBUZXh0dXJlcyBhcmUgY2FjaGVkIGluIDIgbGV2ZWxzOlxuICogICAxLiB0aGUgdGV4dXJlcyB3aGljaCBhcmUgYXNzb2NpYXRlZCB3aXRoIGEgZGF0YUlkIChmcm9tIFRlbnNvcilcbiAqICAgIENhY2hpbmcgdGhlc2UgaXMgY3J1Y2lhbCB0byBwZXJmb3JtYW5jZS4gVGhlc2UgYXJlIEluLXVzZSBUZXh0dXJlc1xuICogICAyLiB0ZXh0dXJlcyB3aGljaCBhcmUgbm90IGluIHVzZSBieSBhbnkgY3VycmVudCBQcm9ncmFtSW5mby9UZW5zb3JcbiAqICAgICBUaGVzZSBhcmUgY2FsbGVkIEZyZWUgVGV4dHVyZXNcbiAqIFRleHR1cmVNYW5hZ2VyIGlzIGFsc28gdXNlZCB0byBoZWxwIGNyZWF0aW5nIHRleHR1cmVzLiBGb3IgdGhpcyBpdFxuICogdXNlcyBXZWJHTENvbnRleHQgYW5kIFRleHR1cmVMYXlvdXRTdHJhdGVneVxuICovXG5leHBvcnQgY2xhc3MgVGV4dHVyZU1hbmFnZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IGluVXNlVGV4dHVyZXM6IE1hcDxzdHJpbmcsIFdlYkdMVGV4dHVyZVtdPjtcbiAgcHJpdmF0ZSByZWFkb25seSBpZGxlVGV4dHVyZXM6IE1hcDxzdHJpbmcsIFdlYkdMVGV4dHVyZVtdPjtcbiAgcHJpdmF0ZSByZWFkb25seSB0ZXh0dXJlTG9va3VwOiBNYXA8V2ViR0xUZXh0dXJlLCBzdHJpbmc+O1xuICBwcml2YXRlIHJlYWRvbmx5IHBlbmRpbmdSZWFkOiBNYXA8VGVuc29yLklkLCBBcnJheTwoYXJyOiBUZW5zb3IuTnVtYmVyVHlwZSkgPT4gdm9pZD4+ID0gbmV3IE1hcCgpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHVibGljIGdsQ29udGV4dDogV2ViR0xDb250ZXh0LCBwdWJsaWMgbGF5b3V0U3RyYXRlZ3k6IFRleHR1cmVMYXlvdXRTdHJhdGVneSwgcHVibGljIHByb2ZpbGVyOiBSZWFkb25seTxQcm9maWxlcj4sXG4gICAgICBwcml2YXRlIGNvbmZpZzogVGV4dHVyZU1hbmFnZXJDb25maWcpIHtcbiAgICBpZiAoY29uZmlnLnJldXNlVGV4dHVyZXMpIHtcbiAgICAgIHRoaXMuaW5Vc2VUZXh0dXJlcyA9IG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuaWRsZVRleHR1cmVzID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy50ZXh0dXJlTG9va3VwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgfVxuICBjcmVhdGVUZXh0dXJlRnJvbUxheW91dChcbiAgICAgIGRhdGFUeXBlOiBUZW5zb3IuRGF0YVR5cGUsIGxheW91dDogVGV4dHVyZUxheW91dCwgZGF0YT86IFRlbnNvci5OdW1iZXJUeXBlLCB1c2FnZT86IEVuY29kZXJVc2FnZSkge1xuICAgIGNvbnN0IHRleHR1cmVEYXRhVHlwZSA9IHRoaXMudG9FbmNvZGVyVHlwZShkYXRhVHlwZSk7XG5cbiAgICBjb25zdCBlbmNvZGVyID0gdGhpcy5nbENvbnRleHQuZ2V0RW5jb2Rlcih0ZXh0dXJlRGF0YVR5cGUsIGxheW91dC5jaGFubmVscyB8fCAxLCB1c2FnZSk7XG4gICAgaWYgKGxheW91dC5pc1BhY2tlZCAmJiB1c2FnZSA9PT0gRW5jb2RlclVzYWdlLlVwbG9hZE9ubHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IHdpZHRoID0gbGF5b3V0LndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGxheW91dC5oZWlnaHQ7XG5cbiAgICBsZXQga2V5OiBzdHJpbmd8dW5kZWZpbmVkO1xuICAgIGxldCBpblVzZVRleHR1cmVzOiBXZWJHTFRleHR1cmVbXXx1bmRlZmluZWQ7XG4gICAgaWYgKHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMpIHtcbiAgICAgIGtleSA9IGAke3dpZHRofXgke2hlaWdodH1fJHtlbmNvZGVyLmZvcm1hdH1fJHtlbmNvZGVyLmludGVybmFsRm9ybWF0fV8ke2VuY29kZXIudGV4dHVyZVR5cGV9YDtcbiAgICAgIGluVXNlVGV4dHVyZXMgPSB0aGlzLmluVXNlVGV4dHVyZXMuZ2V0KGtleSk7XG4gICAgICBpZiAoIWluVXNlVGV4dHVyZXMpIHtcbiAgICAgICAgaW5Vc2VUZXh0dXJlcyA9IFtdO1xuICAgICAgICB0aGlzLmluVXNlVGV4dHVyZXMuc2V0KGtleSwgaW5Vc2VUZXh0dXJlcyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlkbGVUZXh0dXJlcyA9IHRoaXMuaWRsZVRleHR1cmVzLmdldChrZXkpO1xuICAgICAgaWYgKGlkbGVUZXh0dXJlcyAmJiBpZGxlVGV4dHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB0ZXh0dXJlID0gaWRsZVRleHR1cmVzLnBvcCgpITtcbiAgICAgICAgaW5Vc2VUZXh0dXJlcy5wdXNoKHRleHR1cmUpO1xuICAgICAgICBpZiAodXNhZ2UgPT09IEVuY29kZXJVc2FnZS5VcGxvYWRPbmx5KSB7XG4gICAgICAgICAgdGhpcy5nbENvbnRleHQudXBkYXRlVGV4dHVyZSh0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0LCBlbmNvZGVyLCB0aGlzLnRvVGV4dHVyZURhdGEoZGF0YVR5cGUsIGRhdGEpISk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgTG9nZ2VyLnZlcmJvc2UoJ1RleHR1cmVNYW5hZ2VyJywgYENyZWF0aW5nIG5ldyB0ZXh0dXJlIG9mIHNpemUgJHtsYXlvdXQud2lkdGh9eCR7bGF5b3V0LmhlaWdodH1gKTtcbiAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5nbENvbnRleHQuYWxsb2NhdGVUZXh0dXJlKHdpZHRoLCBoZWlnaHQsIGVuY29kZXIsIHRoaXMudG9UZXh0dXJlRGF0YShkYXRhVHlwZSwgZGF0YSkpO1xuXG4gICAgaWYgKHRoaXMuY29uZmlnLnJldXNlVGV4dHVyZXMpIHtcbiAgICAgIGluVXNlVGV4dHVyZXMhLnB1c2godGV4dHVyZSk7XG4gICAgICB0aGlzLnRleHR1cmVMb29rdXAuc2V0KHRleHR1cmUsIGtleSEpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfVxuICByZWFkVGV4dHVyZSh0ZDogVGV4dHVyZURhdGEsIGRhdGFUeXBlOiBUZW5zb3IuRGF0YVR5cGUsIGNoYW5uZWxzPzogbnVtYmVyKTogVGVuc29yLk51bWJlclR5cGUge1xuICAgIGlmICghY2hhbm5lbHMpIHtcbiAgICAgIGNoYW5uZWxzID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvZmlsZXIuZXZlbnQoJ2JhY2tlbmQnLCAnVGV4dHVyZU1hbmFnZXIucmVhZFRleHR1cmUnLCAoKSA9PiB7XG4gICAgICBjb25zdCBkYXRhU2l6ZSA9IHRkLnNoYXBlLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpICogY2hhbm5lbHMhO1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2xDb250ZXh0LnJlYWRUZXh0dXJlKFxuICAgICAgICAgIHRkLnRleHR1cmUsIHRkLndpZHRoLCB0ZC5oZWlnaHQsIGRhdGFTaXplLCB0aGlzLnRvRW5jb2RlclR5cGUoZGF0YVR5cGUpLCBjaGFubmVscyEpO1xuICAgICAgcmV0dXJuIHRoaXMudG9UZW5zb3JEYXRhKGRhdGFUeXBlLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyByZWFkVGV4dHVyZUFzeW5jKHRkOiBUZXh0dXJlRGF0YSwgZGF0YVR5cGU6IFRlbnNvci5EYXRhVHlwZSwgY2hhbm5lbHM/OiBudW1iZXIpOiBQcm9taXNlPFRlbnNvci5OdW1iZXJUeXBlPiB7XG4gICAgY29uc3QgZGF0YUlkID0gdGQudGVuc29yLmRhdGFJZDtcbiAgICBpZiAoIWNoYW5uZWxzKSB7XG4gICAgICBjaGFubmVscyA9IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLnBlbmRpbmdSZWFkLmhhcyhkYXRhSWQpKSB7XG4gICAgICBjb25zdCBzdWJzY3JpYmVycyA9IHRoaXMucGVuZGluZ1JlYWQuZ2V0KGRhdGFJZCk7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2U8VGVuc29yLk51bWJlclR5cGU+KHJlc29sdmUgPT4gc3Vic2NyaWJlcnM/LnB1c2gocmVzb2x2ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudCgnYmFja2VuZCcsICdUZXh0dXJlTWFuYWdlci5yZWFkVGV4dHVyZUFzeW5jJywgYXN5bmMgKCkgPT4ge1xuICAgICAgdGhpcy5wZW5kaW5nUmVhZC5zZXQoZGF0YUlkLCBbXSk7XG4gICAgICBjb25zdCBkYXRhU2l6ZSA9IHRkLnNoYXBlLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpICogY2hhbm5lbHMhO1xuICAgICAgLy8gYWRkIGEgZmVuY2Ugd2FpdGluZyBmb3IgdGhlIGRhdGEgdG8gYmUgcmVhZHlcbiAgICAgIGF3YWl0IHRoaXMuZ2xDb250ZXh0LmNyZWF0ZUFuZFdhaXRGb3JGZW5jZSgpO1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2xDb250ZXh0LnJlYWRUZXh0dXJlKFxuICAgICAgICAgIHRkLnRleHR1cmUsIHRkLndpZHRoLCB0ZC5oZWlnaHQsIGRhdGFTaXplLCB0aGlzLnRvRW5jb2RlclR5cGUoZGF0YVR5cGUpLCBjaGFubmVscyEpO1xuICAgICAgY29uc3QgdGVuc29yRGF0YSA9IHRoaXMudG9UZW5zb3JEYXRhKGRhdGFUeXBlLCBkYXRhKTtcbiAgICAgIGNvbnN0IHN1YnNjcmliZXJzID0gdGhpcy5wZW5kaW5nUmVhZC5nZXQoZGF0YUlkKTtcbiAgICAgIHRoaXMucGVuZGluZ1JlYWQuZGVsZXRlKGRhdGFJZCk7XG4gICAgICBzdWJzY3JpYmVycz8uZm9yRWFjaChyZXNvbHZlID0+IHJlc29sdmUodGVuc29yRGF0YSkpO1xuICAgICAgcmV0dXJuIHRlbnNvckRhdGE7XG4gICAgfSk7XG4gIH1cbiAgcmVhZFVpbnQ4VGV4dHVyZUFzRmxvYXQodGQ6IFRleHR1cmVEYXRhKTogRmxvYXQzMkFycmF5IHtcbiAgICByZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudCgnYmFja2VuZCcsICdUZXh0dXJlTWFuYWdlci5yZWFkVWludDhUZXh0dXJlQXNGbG9hdCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGRhdGFTaXplID0gdGQuc2hhcGUucmVkdWNlKChhLCBiKSA9PiBhICogYik7XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5nbENvbnRleHQucmVhZFRleHR1cmUodGQudGV4dHVyZSwgdGQud2lkdGgsIHRkLmhlaWdodCwgZGF0YVNpemUgKiA0LCAnYnl0ZScsIDQpO1xuICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YVNpemUpO1xuICAgIH0pO1xuICB9XG4gIHJlbGVhc2VUZXh0dXJlKHRleHR1cmVEYXRhOiBUZXh0dXJlRGF0YSwgZGVsZXRlVGV4dHVyZT86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBsZXQga2V5OiBzdHJpbmd8dW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLmNvbmZpZy5yZXVzZVRleHR1cmVzKSB7XG4gICAgICBrZXkgPSB0aGlzLnRleHR1cmVMb29rdXAuZ2V0KHRleHR1cmVEYXRhLnRleHR1cmUpO1xuICAgICAgaWYgKGtleSkge1xuICAgICAgICBpZiAoZGVsZXRlVGV4dHVyZSkge1xuICAgICAgICAgIHRoaXMudGV4dHVyZUxvb2t1cC5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpblVzZVRleHR1cmVzID0gdGhpcy5pblVzZVRleHR1cmVzLmdldChrZXkpO1xuICAgICAgICBpZiAoaW5Vc2VUZXh0dXJlcykge1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gaW5Vc2VUZXh0dXJlcy5pbmRleE9mKHRleHR1cmVEYXRhLnRleHR1cmUpO1xuICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGluVXNlVGV4dHVyZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGxldCBpZGxlVGV4dHVyZXMgPSB0aGlzLmlkbGVUZXh0dXJlcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICghaWRsZVRleHR1cmVzKSB7XG4gICAgICAgICAgICAgIGlkbGVUZXh0dXJlcyA9IFtdO1xuICAgICAgICAgICAgICB0aGlzLmlkbGVUZXh0dXJlcy5zZXQoa2V5LCBpZGxlVGV4dHVyZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWRsZVRleHR1cmVzLnB1c2godGV4dHVyZURhdGEudGV4dHVyZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFrZXkgfHwgZGVsZXRlVGV4dHVyZSkge1xuICAgICAgTG9nZ2VyLnZlcmJvc2UoJ1RleHR1cmVNYW5hZ2VyJywgYERlbGV0aW5nIHRleHR1cmUgb2Ygc2l6ZSAke3RleHR1cmVEYXRhLndpZHRofXgke3RleHR1cmVEYXRhLmhlaWdodH1gKTtcbiAgICAgIHRoaXMuZ2xDb250ZXh0LmRlbGV0ZVRleHR1cmUodGV4dHVyZURhdGEudGV4dHVyZSk7XG4gICAgfVxuICB9XG4gIHRvVGVuc29yRGF0YShkYXRhVHlwZTogVGVuc29yLkRhdGFUeXBlLCBkYXRhOiBFbmNvZGVyLkRhdGFBcnJheVR5cGUpOiBUZW5zb3IuTnVtYmVyVHlwZSB7XG4gICAgc3dpdGNoIChkYXRhVHlwZSkge1xuICAgICAgY2FzZSAnaW50MTYnOlxuICAgICAgICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIEludDE2QXJyYXkgPyBkYXRhIDogSW50MTZBcnJheS5mcm9tKGRhdGEpO1xuICAgICAgY2FzZSAnaW50MzInOlxuICAgICAgICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIEludDMyQXJyYXkgPyBkYXRhIDogSW50MzJBcnJheS5mcm9tKGRhdGEpO1xuICAgICAgY2FzZSAnaW50OCc6XG4gICAgICAgIHJldHVybiBkYXRhIGluc3RhbmNlb2YgSW50OEFycmF5ID8gZGF0YSA6IEludDhBcnJheS5mcm9tKGRhdGEpO1xuICAgICAgY2FzZSAndWludDE2JzpcbiAgICAgICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBVaW50MTZBcnJheSA/IGRhdGEgOiBVaW50MTZBcnJheS5mcm9tKGRhdGEpO1xuICAgICAgY2FzZSAndWludDMyJzpcbiAgICAgICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBVaW50MzJBcnJheSA/IGRhdGEgOiBVaW50MzJBcnJheS5mcm9tKGRhdGEpO1xuICAgICAgY2FzZSAndWludDgnOlxuICAgICAgY2FzZSAnYm9vbCc6XG4gICAgICAgIHJldHVybiBkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSA/IGRhdGEgOiBVaW50OEFycmF5LmZyb20oZGF0YSk7XG4gICAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgPyBkYXRhIDogRmxvYXQzMkFycmF5LmZyb20oZGF0YSk7XG4gICAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgICAgcmV0dXJuIGRhdGEgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkgPyBkYXRhIDogRmxvYXQ2NEFycmF5LmZyb20oZGF0YSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvckRhdGEgdHlwZSAke2RhdGFUeXBlfSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICB9XG4gIHRvVGV4dHVyZURhdGEoX2RhdGFUeXBlOiBUZW5zb3IuRGF0YVR5cGUsIGRhdGE6IFRlbnNvci5OdW1iZXJUeXBlfHVuZGVmaW5lZCk6IEVuY29kZXIuRGF0YUFycmF5VHlwZXx1bmRlZmluZWQge1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIChkYXRhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSA/IGRhdGEgOiBuZXcgRmxvYXQzMkFycmF5KGRhdGEpO1xuICAgIC8qXG4gICAgc3dpdGNoIChkYXRhVHlwZSkge1xuICAgICAgY2FzZSAnaW50MTYnOlxuICAgICAgY2FzZSAnaW50MzInOlxuICAgICAgY2FzZSAndWludDE2JzpcbiAgICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICAgIHJldHVybiAoZGF0YS5jb25zdHJ1Y3RvciA9PT0gVWludDMyQXJyYXkpID8gZGF0YSBhcyBVaW50MzJBcnJheSA6IG5ldyBVaW50MzJBcnJheShkYXRhKTtcbiAgICAgIGNhc2UgJ2ludDgnOlxuICAgICAgY2FzZSAndWludDgnOlxuICAgICAgY2FzZSAnYm9vbCc6XG4gICAgICAgIHJldHVybiAoZGF0YS5jb25zdHJ1Y3RvciA9PT0gVWludDhBcnJheSkgPyBkYXRhIGFzIFVpbnQ4QXJyYXkgOiBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgICAgIHJldHVybiAoZGF0YS5jb25zdHJ1Y3RvciA9PT0gRmxvYXQzMkFycmF5KSA/IGRhdGEgYXMgRmxvYXQzMkFycmF5IDogbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGVuc29yRGF0YSB0eXBlICR7ZGF0YVR5cGV9IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICB9XG4gICAgKi9cbiAgfVxuICB0b0VuY29kZXJUeXBlKF9kYXRhVHlwZTogVGVuc29yLkRhdGFUeXBlKTogRW5jb2Rlci5EYXRhVHlwZSB7XG4gICAgcmV0dXJuICdmbG9hdCc7XG4gICAgLy8gc3dpdGNoIChkYXRhVHlwZSkge1xuICAgIC8vICAgY2FzZSAnaW50MTYnOlxuICAgIC8vICAgY2FzZSAnaW50MzInOlxuICAgIC8vICAgY2FzZSAndWludDE2JzpcbiAgICAvLyAgIGNhc2UgJ3VpbnQzMic6XG4gICAgLy8gICAgIHJldHVybiAnaW50JztcbiAgICAvLyAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAvLyAgIGNhc2UgJ2Jvb2wnOlxuICAgIC8vICAgICByZXR1cm4gJ2J5dGUnO1xuICAgIC8vICAgY2FzZSAnZmxvYXQzMic6XG4gICAgLy8gICBjYXNlICdmbG9hdDY0JzpcbiAgICAvLyAgICAgcmV0dXJuICdmbG9hdCc7XG4gICAgLy8gICBkZWZhdWx0OlxuICAgIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvckRhdGEgdHlwZSAke2RhdGFUeXBlfSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgLy8gfVxuICB9XG4gIGNsZWFyQWN0aXZlVGV4dHVyZXMoKTogdm9pZCB7XG4gICAgdGhpcy5nbENvbnRleHQuY2xlYXJBY3RpdmVUZXh0dXJlcygpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7U2Vzc2lvbkhhbmRsZXJ9IGZyb20gJy4uLy4uL2JhY2tlbmQnO1xuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi4vLi4vZ3JhcGgnO1xuaW1wb3J0IHtMb2dnZXJ9IGZyb20gJy4uLy4uL2luc3RydW1lbnQnO1xuaW1wb3J0IHtPcGVyYXRvcn0gZnJvbSAnLi4vLi4vb3BlcmF0b3JzJztcbmltcG9ydCB7T3BTZXQsIHJlc29sdmVPcGVyYXRvcn0gZnJvbSAnLi4vLi4vb3BzZXQnO1xuaW1wb3J0IHtTZXNzaW9ufSBmcm9tICcuLi8uLi9zZXNzaW9uJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtXZWJHTEJhY2tlbmR9IGZyb20gJy4uL2JhY2tlbmQtd2ViZ2wnO1xuXG5pbXBvcnQge1dlYkdMSW5mZXJlbmNlSGFuZGxlcn0gZnJvbSAnLi9pbmZlcmVuY2UtaGFuZGxlcic7XG5pbXBvcnQge1dFQkdMX09QX1JFU09MVkVfUlVMRVN9IGZyb20gJy4vb3AtcmVzb2x2ZS1ydWxlcyc7XG5pbXBvcnQge1Byb2dyYW1NYW5hZ2VyfSBmcm9tICcuL3Byb2dyYW0tbWFuYWdlcic7XG5pbXBvcnQge1ByZWZlckxvZ2ljYWxTdHJhdGVneSwgVGV4dHVyZUxheW91dFN0cmF0ZWd5fSBmcm9tICcuL3RleHR1cmUtbGF5b3V0LXN0cmF0ZWd5JztcbmltcG9ydCB7VGV4dHVyZU1hbmFnZXJ9IGZyb20gJy4vdGV4dHVyZS1tYW5hZ2VyJztcbmltcG9ydCB7VGV4dHVyZURhdGF9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xTZXNzaW9uSGFuZGxlciBpbXBsZW1lbnRzIFNlc3Npb25IYW5kbGVyIHtcbiAgcHJvZ3JhbU1hbmFnZXI6IFByb2dyYW1NYW5hZ2VyO1xuICB0ZXh0dXJlTWFuYWdlcjogVGV4dHVyZU1hbmFnZXI7XG4gIGxheW91dFN0cmF0ZWd5OiBUZXh0dXJlTGF5b3V0U3RyYXRlZ3k7XG4gIHBhY2tlZFRleHR1cmVEYXRhQ2FjaGU6IE1hcDxUZW5zb3IuSWQsIFRleHR1cmVEYXRhPjtcbiAgdW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlOiBNYXA8VGVuc29yLklkLCBUZXh0dXJlRGF0YT47XG4gIHBhY2sydW5wYWNrTWFwOiBNYXA8VGVuc29yLklkLCBUZW5zb3IuSWQ+O1xuICB1bnBhY2sycGFja01hcDogTWFwPFRlbnNvci5JZCwgVGVuc29yLklkPjtcbiAgaW5pdGlhbGl6ZXJzOiBTZXQ8VGVuc29yLklkPjtcbiAgcGFjaz86IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGJhY2tlbmQ6IFdlYkdMQmFja2VuZCwgcHVibGljIHJlYWRvbmx5IGNvbnRleHQ6IFNlc3Npb24uQ29udGV4dCkge1xuICAgIHRoaXMubGF5b3V0U3RyYXRlZ3kgPSBuZXcgUHJlZmVyTG9naWNhbFN0cmF0ZWd5KGJhY2tlbmQuZ2xDb250ZXh0Lm1heFRleHR1cmVTaXplKTtcbiAgICB0aGlzLnByb2dyYW1NYW5hZ2VyID0gbmV3IFByb2dyYW1NYW5hZ2VyKHRoaXMuY29udGV4dC5wcm9maWxlciwgYmFja2VuZC5nbENvbnRleHQsIHRoaXMubGF5b3V0U3RyYXRlZ3kpO1xuICAgIHRoaXMudGV4dHVyZU1hbmFnZXIgPSBuZXcgVGV4dHVyZU1hbmFnZXIoXG4gICAgICAgIGJhY2tlbmQuZ2xDb250ZXh0LCB0aGlzLmxheW91dFN0cmF0ZWd5LCB0aGlzLmNvbnRleHQucHJvZmlsZXIsXG4gICAgICAgIHtyZXVzZVRleHR1cmVzOiBiYWNrZW5kLnRleHR1cmVDYWNoZU1vZGUgPT09ICdmdWxsJ30pO1xuICAgIHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnVucGFja2VkVGV4dHVyZURhdGFDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnBhY2sgPSBiYWNrZW5kLnBhY2s7XG4gICAgdGhpcy5wYWNrMnVucGFja01hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnVucGFjazJwYWNrTWFwID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgY3JlYXRlSW5mZXJlbmNlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gbmV3IFdlYkdMSW5mZXJlbmNlSGFuZGxlcih0aGlzKTtcbiAgfVxuICBvbkdyYXBoSW5pdGlhbGl6ZWQoZ3JhcGg6IEdyYXBoKTogdm9pZCB7XG4gICAgY29uc3QgaW5pdGlhbGl6ZXJzID0gZ3JhcGguZ2V0VmFsdWVzKCkuZmlsdGVyKHYgPT4gdi5mcm9tID09PSAtMSAmJiB2LnRlbnNvcikubWFwKHYgPT4gdi50ZW5zb3IhLmRhdGFJZCk7XG4gICAgdGhpcy5pbml0aWFsaXplcnMgPSBuZXcgU2V0KGluaXRpYWxpemVycyk7XG4gIH1cbiAgaXNJbml0aWFsaXplcih0ZW5zb3JJZDogVGVuc29yLklkKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdGlhbGl6ZXJzID8gdGhpcy5pbml0aWFsaXplcnMuaGFzKHRlbnNvcklkKSA6IGZhbHNlO1xuICB9XG4gIGFkZEluaXRpYWxpemVyKHRlbnNvcklkOiBUZW5zb3IuSWQpOiB2b2lkIHtcbiAgICB0aGlzLmluaXRpYWxpemVycy5hZGQodGVuc29ySWQpO1xuICB9XG4gIGdldFRleHR1cmVEYXRhKHRlbnNvcklkOiBUZW5zb3IuSWQsIGlzUGFja2VkOiBib29sZWFuKTogVGV4dHVyZURhdGF8dW5kZWZpbmVkIHtcbiAgICBpZiAoaXNQYWNrZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZ2V0KHRlbnNvcklkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLmdldCh0ZW5zb3JJZCk7XG4gICAgfVxuICB9XG4gIHNldFRleHR1cmVEYXRhKHRlbnNvcklkOiBUZW5zb3IuSWQsIHRleHR1cmVEYXRhOiBUZXh0dXJlRGF0YSwgaXNQYWNrZWQgPSBmYWxzZSk6IHZvaWQge1xuICAgIExvZ2dlci52ZXJib3NlKCdXZWJHTFNlc3Npb25IYW5kbGVyJywgJ1N0b3JpbmcgVGV4dHVyZSBkYXRhIGluIGNhY2hlJyk7XG4gICAgaWYgKGlzUGFja2VkKSB7XG4gICAgICB0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuc2V0KHRlbnNvcklkLCB0ZXh0dXJlRGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5wYWNrZWRUZXh0dXJlRGF0YUNhY2hlLnNldCh0ZW5zb3JJZCwgdGV4dHVyZURhdGEpO1xuICAgIH1cbiAgfVxuICBkaXNwb3NlKCk6IHZvaWQge1xuICAgIHRoaXMucHJvZ3JhbU1hbmFnZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMudGV4dHVyZU1hbmFnZXIuY2xlYXJBY3RpdmVUZXh0dXJlcygpO1xuICAgIHRoaXMucGFja2VkVGV4dHVyZURhdGFDYWNoZS5mb3JFYWNoKHRkID0+IHRoaXMudGV4dHVyZU1hbmFnZXIucmVsZWFzZVRleHR1cmUodGQsIHRydWUpKTtcbiAgICB0aGlzLnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUuZm9yRWFjaCh0ZCA9PiB0aGlzLnRleHR1cmVNYW5hZ2VyLnJlbGVhc2VUZXh0dXJlKHRkLCB0cnVlKSk7XG4gICAgdGhpcy51bnBhY2tlZFRleHR1cmVEYXRhQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIH1cbiAgcmVzb2x2ZShub2RlOiBHcmFwaC5Ob2RlLCBvcHNldHM6IHJlYWRvbmx5IE9wU2V0W10sIGdyYXBoOiBHcmFwaCk6IE9wZXJhdG9yIHtcbiAgICBjb25zdCBvcCA9IHJlc29sdmVPcGVyYXRvcihub2RlLCBvcHNldHMsIFdFQkdMX09QX1JFU09MVkVfUlVMRVMpO1xuICAgIHJldHVybiB7aW1wbDogb3Aub3BJbXBsLCBjb250ZXh0OiBvcC5vcEluaXQgPyBvcC5vcEluaXQobm9kZSwgZ3JhcGgpIDogbm9kZX07XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtlbnZ9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCAqIGFzIERhdGFFbmNvZGVycyBmcm9tICcuL3RleHR1cmUtZGF0YS1lbmNvZGVyJztcbmltcG9ydCB7RGF0YUVuY29kZXIsIEVuY29kZXIsIEVuY29kZXJVc2FnZX0gZnJvbSAnLi90ZXh0dXJlLWRhdGEtZW5jb2Rlcic7XG5pbXBvcnQge3JlcGVhdGVkVHJ5fSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGludGVyZmFjZSBGZW5jZUNvbnRleHQge1xuICBxdWVyeTogV2ViR0xTeW5jfG51bGw7XG4gIGlzRmVuY2VQYXNzZWQoKTogYm9vbGVhbjtcbn1cblxudHlwZSBQb2xsSXRlbSA9IHtcbiAgaXNEb25lRm46ICgpID0+IGJvb2xlYW47IHJlc29sdmVGbjogKCkgPT4gdm9pZDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJTZWFyY2hMYXN0VHJ1ZShhcnI6IEFycmF5PCgpID0+IGJvb2xlYW4+KTogbnVtYmVyIHtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGlzRG9uZSA9IGFycltpXSgpO1xuICAgIGlmICghaXNEb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGkgLSAxO1xufVxuXG4vKipcbiAqIEFic3RyYWN0aW9uIGFuZCB3cmFwcGVyIGFyb3VuZCBXZWJHTFJlbmRlcmluZ0NvbnRleHQgYW5kIGl0cyBvcGVyYXRpb25zXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJHTENvbnRleHQge1xuICBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuICB2ZXJzaW9uOiAxfDI7XG5cbiAgcHJpdmF0ZSB2ZXJ0ZXhidWZmZXI6IFdlYkdMQnVmZmVyO1xuICBwcml2YXRlIGZyYW1lYnVmZmVyOiBXZWJHTEZyYW1lYnVmZmVyO1xuXG4gIC8vIFdlYkdMIGZsYWdzIGFuZCB2aXRhbCBwYXJhbWV0ZXJzXG4gIHByaXZhdGUgaXNGbG9hdFRleHR1cmVBdHRhY2hhYmxlVG9GcmFtZUJ1ZmZlcjogYm9vbGVhbjtcbiAgaXNGbG9hdDMyRG93bmxvYWRTdXBwb3J0ZWQ6IGJvb2xlYW47XG4gIGlzUmVuZGVyRmxvYXQzMlN1cHBvcnRlZDogYm9vbGVhbjtcbiAgaXNCbGVuZFN1cHBvcnRlZDogYm9vbGVhbjtcbiAgbWF4VGV4dHVyZVNpemU6IG51bWJlcjtcbiAgLy8gcHJpdmF0ZSBtYXhDb21iaW5lZFRleHR1cmVJbWFnZVVuaXRzOiBudW1iZXI7XG4gIHByaXZhdGUgbWF4VGV4dHVyZUltYWdlVW5pdHM6IG51bWJlcjtcbiAgLy8gcHJpdmF0ZSBtYXhDdWJlTWFwVGV4dHVyZVNpemU6IG51bWJlcjtcbiAgLy8gcHJpdmF0ZSBzaGFkaW5nTGFuZ3VhZ2VWZXJzaW9uOiBzdHJpbmc7XG4gIC8vIHByaXZhdGUgd2ViZ2xWZW5kb3I6IHN0cmluZztcbiAgLy8gcHJpdmF0ZSB3ZWJnbFZlcnNpb246IHN0cmluZztcblxuICAvLyBXZWJHTDIgZmxhZ3MgYW5kIHZpdGFsIHBhcmFtZXRlcnNcbiAgLy8gcHJpdmF0ZSBtYXgzRFRleHR1cmVTaXplOiBudW1iZXI7XG4gIC8vIHByaXZhdGUgbWF4QXJyYXlUZXh0dXJlTGF5ZXJzOiBudW1iZXI7XG4gIC8vIHByaXZhdGUgbWF4Q29sb3JBdHRhY2htZW50czogbnVtYmVyO1xuICAvLyBwcml2YXRlIG1heERyYXdCdWZmZXJzOiBudW1iZXI7XG5cbiAgLy8gV2ViR0wgZXh0ZW5zaW9uc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gIHRleHR1cmVGbG9hdEV4dGVuc2lvbjogT0VTX3RleHR1cmVfZmxvYXR8bnVsbDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZVxuICB0ZXh0dXJlSGFsZkZsb2F0RXh0ZW5zaW9uOiBPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0fG51bGw7XG5cbiAgLy8gV2ViR0wyIGV4dGVuc2lvbnNcbiAgY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbjogdW5rbm93bnxudWxsO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gIGRpc2pvaW50VGltZXJRdWVyeVdlYmdsMkV4dGVuc2lvbjoge1RJTUVfRUxBUFNFRF9FWFQ6IEdMZW51bTsgR1BVX0RJU0pPSU5UX0VYVDogR0xlbnVtfXxudWxsO1xuXG4gIHByaXZhdGUgZGlzcG9zZWQ6IGJvb2xlYW47XG4gIHByaXZhdGUgZnJhbWVCdWZmZXJCb3VuZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKGdsOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQsIHZlcnNpb246IDF8Mikge1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuXG4gICAgdGhpcy5nZXRFeHRlbnNpb25zKCk7XG4gICAgdGhpcy52ZXJ0ZXhidWZmZXIgPSB0aGlzLmNyZWF0ZVZlcnRleGJ1ZmZlcigpO1xuICAgIHRoaXMuZnJhbWVidWZmZXIgPSB0aGlzLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgdGhpcy5xdWVyeVZpdGFsUGFyYW1ldGVycygpO1xuICB9XG5cbiAgYWxsb2NhdGVUZXh0dXJlKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBlbmNvZGVyOiBEYXRhRW5jb2RlciwgZGF0YT86IEVuY29kZXIuRGF0YUFycmF5VHlwZSk6IFdlYkdMVGV4dHVyZSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIC8vIGNyZWF0ZSB0aGUgdGV4dHVyZVxuICAgIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgLy8gYmluZCB0aGUgdGV4dHVyZSBzbyB0aGUgZm9sbG93aW5nIG1ldGhvZHMgZWZmZWN0IHRoaXMgdGV4dHVyZS5cbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IGRhdGEgPyBlbmNvZGVyLmVuY29kZShkYXRhLCB3aWR0aCAqIGhlaWdodCkgOiBudWxsO1xuICAgIGdsLnRleEltYWdlMkQoXG4gICAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICAgIDAsICAvLyBMZXZlbCBvZiBkZXRhaWwuXG4gICAgICAgIGVuY29kZXIuaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgIDAsICAvLyBBbHdheXMgMCBpbiBPcGVuR0wgRVMuXG4gICAgICAgIGVuY29kZXIuZm9ybWF0LCBlbmNvZGVyLnRleHR1cmVUeXBlLCBidWZmZXIpO1xuICAgIHRoaXMuY2hlY2tFcnJvcigpO1xuICAgIHJldHVybiB0ZXh0dXJlIGFzIFdlYkdMVGV4dHVyZTtcbiAgfVxuICB1cGRhdGVUZXh0dXJlKFxuICAgICAgdGV4dHVyZTogV2ViR0xUZXh0dXJlLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgZW5jb2RlcjogRGF0YUVuY29kZXIsIGRhdGE6IEVuY29kZXIuRGF0YUFycmF5VHlwZSk6IHZvaWQge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBjb25zdCBidWZmZXIgPSBlbmNvZGVyLmVuY29kZShkYXRhLCB3aWR0aCAqIGhlaWdodCk7XG4gICAgZ2wudGV4U3ViSW1hZ2UyRChcbiAgICAgICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAgICAgMCwgIC8vIGxldmVsXG4gICAgICAgIDAsICAvLyB4b2Zmc2V0XG4gICAgICAgIDAsICAvLyB5b2Zmc2V0XG4gICAgICAgIHdpZHRoLCBoZWlnaHQsIGVuY29kZXIuZm9ybWF0LCBlbmNvZGVyLnRleHR1cmVUeXBlLCBidWZmZXIpO1xuICAgIHRoaXMuY2hlY2tFcnJvcigpO1xuICB9XG4gIGF0dGFjaEZyYW1lYnVmZmVyKHRleHR1cmU6IFdlYkdMVGV4dHVyZSwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgLy8gTWFrZSBpdCB0aGUgdGFyZ2V0IGZvciBmcmFtZWJ1ZmZlciBvcGVyYXRpb25zIC0gaW5jbHVkaW5nIHJlbmRlcmluZy5cbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgICAgICBnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsXG4gICAgICAgIDApOyAgLy8gMCwgd2UgYXJlbid0IHVzaW5nIE1JUE1BUHNcbiAgICB0aGlzLmNoZWNrRXJyb3IoKTtcbiAgICBnbC52aWV3cG9ydCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBnbC5zY2lzc29yKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIHJlYWRUZXh0dXJlKFxuICAgICAgdGV4dHVyZTogV2ViR0xUZXh0dXJlLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgZGF0YVNpemU6IG51bWJlciwgZGF0YVR5cGU6IEVuY29kZXIuRGF0YVR5cGUsXG4gICAgICBjaGFubmVsczogbnVtYmVyKTogRW5jb2Rlci5EYXRhQXJyYXlUeXBlIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgaWYgKCFjaGFubmVscykge1xuICAgICAgY2hhbm5lbHMgPSAxO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZnJhbWVCdWZmZXJCb3VuZCkge1xuICAgICAgdGhpcy5hdHRhY2hGcmFtZWJ1ZmZlcih0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgY29uc3QgZW5jb2RlciA9IHRoaXMuZ2V0RW5jb2RlcihkYXRhVHlwZSwgY2hhbm5lbHMpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IGVuY29kZXIuYWxsb2NhdGUod2lkdGggKiBoZWlnaHQpO1xuICAgIC8vIGJpbmQgdGV4dHVyZSB0byBmcmFtZWJ1ZmZlclxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgICAgICBnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsXG4gICAgICAgIDApOyAgLy8gMCwgd2UgYXJlbid0IHVzaW5nIE1JUE1BUHNcbiAgICAvLyBUT0RPOiBDaGVjayBpZiBmcmFtZWJ1ZmZlciBpcyByZWFkeVxuICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZW5jb2Rlci50ZXh0dXJlVHlwZSwgYnVmZmVyKTtcbiAgICB0aGlzLmNoZWNrRXJyb3IoKTtcbiAgICAvLyB1bmJpbmQgRkJcbiAgICByZXR1cm4gZW5jb2Rlci5kZWNvZGUoYnVmZmVyLCBkYXRhU2l6ZSk7XG4gIH1cblxuICBpc0ZyYW1lYnVmZmVyUmVhZHkoKTogYm9vbGVhbiB7XG4gICAgLy8gVE9ETzogSW1wbGVtZW50IGxvZ2ljIHRvIGNoZWNrIGlmIHRoZSBmcmFtZWJ1ZmZlciBpcyByZWFkeVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldEFjdGl2ZVRleHR1cmUoKTogc3RyaW5nIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgY29uc3QgbiA9IGdsLmdldFBhcmFtZXRlcih0aGlzLmdsLkFDVElWRV9URVhUVVJFKTtcbiAgICByZXR1cm4gYFRFWFRVUkUkeyhuIC0gZ2wuVEVYVFVSRTApfWA7XG4gIH1cbiAgZ2V0VGV4dHVyZUJpbmRpbmcoKTogV2ViR0xUZXh0dXJlIHtcbiAgICByZXR1cm4gdGhpcy5nbC5nZXRQYXJhbWV0ZXIodGhpcy5nbC5URVhUVVJFX0JJTkRJTkdfMkQpO1xuICB9XG4gIGdldEZyYW1lYnVmZmVyQmluZGluZygpOiBXZWJHTEZyYW1lYnVmZmVyIHtcbiAgICByZXR1cm4gdGhpcy5nbC5nZXRQYXJhbWV0ZXIodGhpcy5nbC5GUkFNRUJVRkZFUl9CSU5ESU5HKTtcbiAgfVxuICBzZXRWZXJ0ZXhBdHRyaWJ1dGVzKHBvc2l0aW9uSGFuZGxlOiBudW1iZXIsIHRleHR1cmVDb29yZEhhbmRsZTogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25IYW5kbGUsIDMsIGdsLkZMT0FULCBmYWxzZSwgMjAsIDApO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uSGFuZGxlKTtcbiAgICBpZiAodGV4dHVyZUNvb3JkSGFuZGxlICE9PSAtMSkge1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0ZXh0dXJlQ29vcmRIYW5kbGUsIDIsIGdsLkZMT0FULCBmYWxzZSwgMjAsIDEyKTtcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRleHR1cmVDb29yZEhhbmRsZSk7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tFcnJvcigpO1xuICB9XG4gIGNyZWF0ZVByb2dyYW0oXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IFdlYkdMU2hhZGVyLFxuICAgICAgZnJhZ1NoYWRlcjogV2ViR0xTaGFkZXIsXG4gICAgICApOiBXZWJHTFByb2dyYW0ge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpITtcblxuICAgIC8vIHRoZSBwcm9ncmFtIGNvbnNpc3RzIG9mIG91ciBzaGFkZXJzXG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdTaGFkZXIpO1xuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgIHJldHVybiBwcm9ncmFtO1xuICB9XG4gIGNvbXBpbGVTaGFkZXIoc2hhZGVyU291cmNlOiBzdHJpbmcsIHNoYWRlclR5cGU6IG51bWJlcik6IFdlYkdMU2hhZGVyIHtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgY29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHNoYWRlclR5cGUpO1xuICAgIGlmICghc2hhZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGNyZWF0ZVNoYWRlcigpIHJldHVybmVkIG51bGwgd2l0aCB0eXBlICR7c2hhZGVyVHlwZX1gKTtcbiAgICB9XG5cbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzaGFkZXJTb3VyY2UpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICBpZiAoZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY29tcGlsZSBzaGFkZXI6ICR7Z2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpfVxuU2hhZGVyIHNvdXJjZTpcbiR7c2hhZGVyU291cmNlfWApO1xuICAgIH1cbiAgICByZXR1cm4gc2hhZGVyO1xuICB9XG4gIGRlbGV0ZVNoYWRlcihzaGFkZXI6IFdlYkdMU2hhZGVyKTogdm9pZCB7XG4gICAgdGhpcy5nbC5kZWxldGVTaGFkZXIoc2hhZGVyKTtcbiAgfVxuICBiaW5kVGV4dHVyZVRvVW5pZm9ybSh0ZXh0dXJlOiBXZWJHTFRleHR1cmUsIHBvc2l0aW9uOiBudW1iZXIsIHVuaWZvcm1IYW5kbGU6IFdlYkdMVW5pZm9ybUxvY2F0aW9uKTogdm9pZCB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyBwb3NpdGlvbik7XG4gICAgdGhpcy5jaGVja0Vycm9yKCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgdGhpcy5jaGVja0Vycm9yKCk7XG4gICAgZ2wudW5pZm9ybTFpKHVuaWZvcm1IYW5kbGUsIHBvc2l0aW9uKTtcbiAgICB0aGlzLmNoZWNrRXJyb3IoKTtcbiAgfVxuICBkcmF3KCk6IHZvaWQge1xuICAgIHRoaXMuZ2wuZHJhd0FycmF5cyh0aGlzLmdsLlRSSUFOR0xFX1NUUklQLCAwLCA0KTtcbiAgICB0aGlzLmNoZWNrRXJyb3IoKTtcbiAgfVxuICBjaGVja0Vycm9yKCk6IHZvaWQge1xuICAgIGlmIChlbnYuZGVidWcpIHtcbiAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICAgIGNvbnN0IGVycm9yID0gZ2wuZ2V0RXJyb3IoKTtcbiAgICAgIGxldCBsYWJlbCA9ICcnO1xuICAgICAgc3dpdGNoIChlcnJvcikge1xuICAgICAgICBjYXNlIChnbC5OT19FUlJPUik6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIChnbC5JTlZBTElEX0VOVU0pOlxuICAgICAgICAgIGxhYmVsID0gJ0lOVkFMSURfRU5VTSc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgKGdsLklOVkFMSURfVkFMVUUpOlxuICAgICAgICAgIGxhYmVsID0gJ0lOVkFMSURfVkFMVUUnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIChnbC5JTlZBTElEX09QRVJBVElPTik6XG4gICAgICAgICAgbGFiZWwgPSAnSU5WQUxJRF9PUEVSQVRJT04nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIChnbC5JTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTik6XG4gICAgICAgICAgbGFiZWwgPSAnSU5WQUxJRF9GUkFNRUJVRkZFUl9PUEVSQVRJT04nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIChnbC5PVVRfT0ZfTUVNT1JZKTpcbiAgICAgICAgICBsYWJlbCA9ICdPVVRfT0ZfTUVNT1JZJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAoZ2wuQ09OVEVYVF9MT1NUX1dFQkdMKTpcbiAgICAgICAgICBsYWJlbCA9ICdDT05URVhUX0xPU1RfV0VCR0wnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxhYmVsID0gYFVua25vd24gV2ViR0wgRXJyb3I6ICR7ZXJyb3IudG9TdHJpbmcoMTYpfWA7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobGFiZWwpO1xuICAgIH1cbiAgfVxuICBkZWxldGVUZXh0dXJlKHRleHR1cmU6IFdlYkdMVGV4dHVyZSk6IHZvaWQge1xuICAgIHRoaXMuZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgfVxuICBkZWxldGVQcm9ncmFtKHByb2dyYW06IFdlYkdMUHJvZ3JhbSk6IHZvaWQge1xuICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgfVxuICBnZXRFbmNvZGVyKGRhdGFUeXBlOiBFbmNvZGVyLkRhdGFUeXBlLCBjaGFubmVsczogbnVtYmVyLCB1c2FnZTogRW5jb2RlclVzYWdlID0gRW5jb2RlclVzYWdlLkRlZmF1bHQpOiBEYXRhRW5jb2RlciB7XG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMikge1xuICAgICAgcmV0dXJuIG5ldyBEYXRhRW5jb2RlcnMuUmVkRmxvYXQzMkRhdGFFbmNvZGVyKHRoaXMuZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCwgY2hhbm5lbHMpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZGF0YVR5cGUpIHtcbiAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgaWYgKHVzYWdlID09PSBFbmNvZGVyVXNhZ2UuVXBsb2FkT25seSB8fCB0aGlzLmlzUmVuZGVyRmxvYXQzMlN1cHBvcnRlZCkge1xuICAgICAgICAgIHJldHVybiBuZXcgRGF0YUVuY29kZXJzLlJHQkFGbG9hdERhdGFFbmNvZGVyKHRoaXMuZ2wsIGNoYW5uZWxzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGFFbmNvZGVycy5SR0JBRmxvYXREYXRhRW5jb2RlcihcbiAgICAgICAgICAgICAgdGhpcy5nbCwgY2hhbm5lbHMsIHRoaXMudGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbiEuSEFMRl9GTE9BVF9PRVMpO1xuICAgICAgICB9XG4gICAgICBjYXNlICdpbnQnOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgICAgY2FzZSAnYnl0ZSc6XG4gICAgICAgIHJldHVybiBuZXcgRGF0YUVuY29kZXJzLlVpbnQ4RGF0YUVuY29kZXIodGhpcy5nbCwgY2hhbm5lbHMpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGFUeXBlOiAke2RhdGFUeXBlfWApO1xuICAgIH1cbiAgfVxuICBjbGVhckFjdGl2ZVRleHR1cmVzKCk6IHZvaWQge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBmb3IgKGxldCB1bml0ID0gMDsgdW5pdCA8IHRoaXMubWF4VGV4dHVyZUltYWdlVW5pdHM7ICsrdW5pdCkge1xuICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHVuaXQpO1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgfVxuICB9XG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZGlzcG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpO1xuICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLnZlcnRleGJ1ZmZlcik7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbnVsbCk7XG4gICAgZ2wuZmluaXNoKCk7XG4gICAgdGhpcy5kaXNwb3NlZCA9IHRydWU7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZURlZmF1bHRHZW9tZXRyeSgpOiBGbG9hdDMyQXJyYXkge1xuICAgIC8vIFNldHMgb2YgeCx5LHooPTApLHMsdCBjb29yZGluYXRlcy5cbiAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAtMS4wLCAxLjAsICAwLjAsIDAuMCwgMS4wLCAgLy8gdXBwZXIgbGVmdFxuICAgICAgLTEuMCwgLTEuMCwgMC4wLCAwLjAsIDAuMCwgIC8vIGxvd2VyIGxlZnRcbiAgICAgIDEuMCwgIDEuMCwgIDAuMCwgMS4wLCAxLjAsICAvLyB1cHBlciByaWdodFxuICAgICAgMS4wLCAgLTEuMCwgMC4wLCAxLjAsIDAuMCAgIC8vIGxvd2VyIHJpZ2h0XG4gICAgXSk7XG4gIH1cbiAgcHJpdmF0ZSBjcmVhdGVWZXJ0ZXhidWZmZXIoKTogV2ViR0xCdWZmZXIge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBjb25zdCBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVCdWZmZXIoKSByZXR1cm5lZCBudWxsJyk7XG4gICAgfVxuICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5jcmVhdGVEZWZhdWx0R2VvbWV0cnkoKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnksIGdsLlNUQVRJQ19EUkFXKTtcbiAgICB0aGlzLmNoZWNrRXJyb3IoKTtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG4gIHByaXZhdGUgY3JlYXRlRnJhbWVidWZmZXIoKTogV2ViR0xGcmFtZWJ1ZmZlciB7XG4gICAgY29uc3QgZmIgPSB0aGlzLmdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgaWYgKCFmYikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVGcmFtZWJ1ZmZlciByZXR1cm5lZCBudWxsJyk7XG4gICAgfVxuICAgIHJldHVybiBmYjtcbiAgfVxuXG4gIHByaXZhdGUgcXVlcnlWaXRhbFBhcmFtZXRlcnMoKTogdm9pZCB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuXG4gICAgdGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyID0gdGhpcy5jaGVja0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyKCk7XG4gICAgdGhpcy5pc1JlbmRlckZsb2F0MzJTdXBwb3J0ZWQgPSB0aGlzLmNoZWNrUmVuZGVyRmxvYXQzMigpO1xuICAgIHRoaXMuaXNGbG9hdDMyRG93bmxvYWRTdXBwb3J0ZWQgPSB0aGlzLmNoZWNrRmxvYXQzMkRvd25sb2FkKCk7XG5cbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAxICYmICF0aGlzLnRleHR1cmVIYWxmRmxvYXRFeHRlbnNpb24gJiYgIXRoaXMuaXNSZW5kZXJGbG9hdDMyU3VwcG9ydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGggZmxvYXQzMiBhbmQgZmxvYXQxNiBUZXh0dXJlVHlwZSBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cblxuICAgIHRoaXMuaXNCbGVuZFN1cHBvcnRlZCA9ICF0aGlzLmlzUmVuZGVyRmxvYXQzMlN1cHBvcnRlZCB8fCB0aGlzLmNoZWNrRmxvYXQzMkJsZW5kKCk7XG5cbiAgICAvLyB0aGlzLm1heENvbWJpbmVkVGV4dHVyZUltYWdlVW5pdHMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMpO1xuICAgIHRoaXMubWF4VGV4dHVyZVNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfU0laRSk7XG4gICAgdGhpcy5tYXhUZXh0dXJlSW1hZ2VVbml0cyA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyk7XG4gICAgLy8gdGhpcy5tYXhDdWJlTWFwVGV4dHVyZVNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSk7XG4gICAgLy8gdGhpcy5zaGFkaW5nTGFuZ3VhZ2VWZXJzaW9uID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLlNIQURJTkdfTEFOR1VBR0VfVkVSU0lPTik7XG4gICAgLy8gdGhpcy53ZWJnbFZlbmRvciA9IGdsLmdldFBhcmFtZXRlcihnbC5WRU5ET1IpO1xuICAgIC8vIHRoaXMud2ViZ2xWZXJzaW9uID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLlZFUlNJT04pO1xuXG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMikge1xuICAgICAgLy8gdGhpcy5tYXgzRFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuTUFYXzNEX1RFWFRVUkVfU0laRSk7XG4gICAgICAvLyB0aGlzLm1heEFycmF5VGV4dHVyZUxheWVycyA9IGdsLmdldFBhcmFtZXRlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk1BWF9BUlJBWV9URVhUVVJFX0xBWUVSUyk7XG4gICAgICAvLyB0aGlzLm1heENvbG9yQXR0YWNobWVudHMgPSBnbC5nZXRQYXJhbWV0ZXIoV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5NQVhfQ09MT1JfQVRUQUNITUVOVFMpO1xuICAgICAgLy8gdGhpcy5tYXhEcmF3QnVmZmVycyA9IGdsLmdldFBhcmFtZXRlcihXZWJHTDJSZW5kZXJpbmdDb250ZXh0Lk1BWF9EUkFXX0JVRkZFUlMpO1xuICAgIH1cbiAgfVxuICBwcml2YXRlIGdldEV4dGVuc2lvbnMoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMikge1xuICAgICAgdGhpcy5jb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uID0gdGhpcy5nbC5nZXRFeHRlbnNpb24oJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnKTtcbiAgICAgIHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uID0gdGhpcy5nbC5nZXRFeHRlbnNpb24oJ0VYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50ZXh0dXJlRmxvYXRFeHRlbnNpb24gPSB0aGlzLmdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKTtcbiAgICAgIHRoaXMudGV4dHVyZUhhbGZGbG9hdEV4dGVuc2lvbiA9IHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0Jyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyKCk6IGJvb2xlYW4ge1xuICAgIC8vIHRlc3Qgd2hldGhlciBGbG9hdDMyIHRleHR1cmUgaXMgc3VwcG9ydGVkOlxuICAgIC8vIFNURVAuMSBjcmVhdGUgYSBmbG9hdCB0ZXh0dXJlXG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGNvbnN0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICAgIGNvbnN0IGludGVybmFsRm9ybWF0ID0gdGhpcy52ZXJzaW9uID09PSAyID8gKGdsIGFzIHVua25vd24gYXMge1JHQkEzMkY6IG51bWJlcn0pLlJHQkEzMkYgOiBnbC5SR0JBO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgaW50ZXJuYWxGb3JtYXQsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBudWxsKTtcbiAgICAvLyBTVEVQLjIgYmluZCBhIGZyYW1lIGJ1ZmZlclxuICAgIGNvbnN0IGZyYW1lQnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lQnVmZmVyKTtcbiAgICAvLyBTVEVQLjMgYXR0YWNoIHRleHR1cmUgdG8gZnJhbWVidWZmZXJcbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuICAgIC8vIFNURVAuNCB0ZXN0IHdoZXRoZXIgZnJhbWVidWZmZXIgaXMgY29tcGxldGVcbiAgICBjb25zdCBpc0NvbXBsZXRlID0gZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUikgPT09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcihmcmFtZUJ1ZmZlcik7XG4gICAgcmV0dXJuIGlzQ29tcGxldGU7XG4gIH1cblxuICBwcml2YXRlIGNoZWNrUmVuZGVyRmxvYXQzMigpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAyKSB7XG4gICAgICBpZiAoIXRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy50ZXh0dXJlRmxvYXRFeHRlbnNpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyO1xuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0Zsb2F0MzJEb3dubG9hZCgpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAyKSB7XG4gICAgICBpZiAoIXRoaXMuY29sb3JCdWZmZXJGbG9hdEV4dGVuc2lvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy50ZXh0dXJlRmxvYXRFeHRlbnNpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmdsLmdldEV4dGVuc2lvbignV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0JykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pc0Zsb2F0VGV4dHVyZUF0dGFjaGFibGVUb0ZyYW1lQnVmZmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgR0xfQkxFTkQgaXMgc3VwcG9ydGVkXG4gICAqL1xuICBwcml2YXRlIGNoZWNrRmxvYXQzMkJsZW5kKCk6IGJvb2xlYW4ge1xuICAgIC8vIGl0IGxvb2tzIGxpa2UgY3VycmVudGx5ICgyMDE5LTA1LTA4KSB0aGVyZSBpcyBubyBlYXN5IHdheSB0byBkZXRlY3Qgd2hldGhlciBCTEVORCBpcyBzdXBwb3J0ZWRcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhqcy9pc3N1ZXMvMTQ1XG5cbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG5cbiAgICBsZXQgdGV4dHVyZTogV2ViR0xUZXh0dXJlfG51bGx8dW5kZWZpbmVkO1xuICAgIGxldCBmcmFtZUJ1ZmZlcjogV2ViR0xGcmFtZWJ1ZmZlcnxudWxsfHVuZGVmaW5lZDtcbiAgICBsZXQgdmVydGV4U2hhZGVyOiBXZWJHTFNoYWRlcnxudWxsfHVuZGVmaW5lZDtcbiAgICBsZXQgZnJhZ21lbnRTaGFkZXI6IFdlYkdMU2hhZGVyfG51bGx8dW5kZWZpbmVkO1xuICAgIGxldCBwcm9ncmFtOiBXZWJHTFByb2dyYW18bnVsbHx1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIGZyYW1lQnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgICBjb25zdCBpbnRlcm5hbEZvcm1hdCA9IHRoaXMudmVyc2lvbiA9PT0gMiA/IChnbCBhcyB1bmtub3duIGFzIHtSR0JBMzJGOiBudW1iZXJ9KS5SR0JBMzJGIDogZ2wuUkdCQTtcbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgaW50ZXJuYWxGb3JtYXQsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBudWxsKTtcblxuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1ZmZlcik7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuXG4gICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuXG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgICBpZiAoIXZlcnRleFNoYWRlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBnbC5zaGFkZXJTb3VyY2UodmVydGV4U2hhZGVyLCAndm9pZCBtYWluKCl7fScpO1xuICAgICAgZ2wuY29tcGlsZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuXG4gICAgICBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgICAgaWYgKCFmcmFnbWVudFNoYWRlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBnbC5zaGFkZXJTb3VyY2UoZnJhZ21lbnRTaGFkZXIsICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7dm9pZCBtYWluKCl7Z2xfRnJhZ0NvbG9yPXZlYzQoMC41KTt9Jyk7XG4gICAgICBnbC5jb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcblxuICAgICAgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgIGlmICghcHJvZ3JhbSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gICAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG5cbiAgICAgIGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCAwLCAxKTtcbiAgICAgIHJldHVybiBnbC5nZXRFcnJvcigpID09PSBnbC5OT19FUlJPUjtcblxuICAgIH0gZmluYWxseSB7XG4gICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblxuICAgICAgaWYgKHByb2dyYW0pIHtcbiAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgIH1cbiAgICAgIGlmICh2ZXJ0ZXhTaGFkZXIpIHtcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHZlcnRleFNoYWRlcik7XG4gICAgICB9XG4gICAgICBpZiAoZnJhZ21lbnRTaGFkZXIpIHtcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChmcmFtZUJ1ZmZlcikge1xuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcihmcmFtZUJ1ZmZlcik7XG4gICAgICB9XG4gICAgICBpZiAodGV4dHVyZSkge1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICAgICAgZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBiZWdpblRpbWVyKCk6IFdlYkdMUXVlcnkge1xuICAgIGlmICh0aGlzLnZlcnNpb24gPT09IDIgJiYgdGhpcy5kaXNqb2ludFRpbWVyUXVlcnlXZWJnbDJFeHRlbnNpb24pIHtcbiAgICAgIGNvbnN0IGdsMiA9IHRoaXMuZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcbiAgICAgIGNvbnN0IGV4dCA9IHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uO1xuXG4gICAgICBjb25zdCBxdWVyeSA9IGdsMi5jcmVhdGVRdWVyeSgpIGFzIFdlYkdMUXVlcnk7XG4gICAgICBnbDIuYmVnaW5RdWVyeShleHQuVElNRV9FTEFQU0VEX0VYVCwgcXVlcnkpO1xuICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBhZGQgd2ViZ2wgMSBoYW5kbGluZy5cbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gIH1cblxuICBlbmRUaW1lcigpIHtcbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAyICYmIHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uKSB7XG4gICAgICBjb25zdCBnbDIgPSB0aGlzLmdsIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XG4gICAgICBjb25zdCBleHQgPSB0aGlzLmRpc2pvaW50VGltZXJRdWVyeVdlYmdsMkV4dGVuc2lvbjtcbiAgICAgIGdsMi5lbmRRdWVyeShleHQuVElNRV9FTEFQU0VEX0VYVCk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IGFkZCB3ZWJnbCAxIGhhbmRsaW5nLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJHTDEgcHJvZmlsaW5nIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9XG5cbiAgaXNUaW1lclJlc3VsdEF2YWlsYWJsZShxdWVyeTogV2ViR0xRdWVyeSk6IGJvb2xlYW4ge1xuICAgIGxldCBhdmFpbGFibGUgPSBmYWxzZSwgZGlzam9pbnQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy52ZXJzaW9uID09PSAyICYmIHRoaXMuZGlzam9pbnRUaW1lclF1ZXJ5V2ViZ2wyRXh0ZW5zaW9uKSB7XG4gICAgICBjb25zdCBnbDIgPSB0aGlzLmdsIGFzIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XG4gICAgICBjb25zdCBleHQgPSB0aGlzLmRpc2pvaW50VGltZXJRdWVyeVdlYmdsMkV4dGVuc2lvbjtcblxuICAgICAgYXZhaWxhYmxlID0gZ2wyLmdldFF1ZXJ5UGFyYW1ldGVyKHF1ZXJ5LCBnbDIuUVVFUllfUkVTVUxUX0FWQUlMQUJMRSk7XG4gICAgICBkaXNqb2ludCA9IGdsMi5nZXRQYXJhbWV0ZXIoZXh0LkdQVV9ESVNKT0lOVF9FWFQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBhZGQgd2ViZ2wgMSBoYW5kbGluZy5cbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViR0wxIHByb2ZpbGluZyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBhdmFpbGFibGUgJiYgIWRpc2pvaW50O1xuICB9XG5cbiAgZ2V0VGltZXJSZXN1bHQocXVlcnk6IFdlYkdMUXVlcnkpOiBudW1iZXIge1xuICAgIGxldCB0aW1lRWxhcHNlZCA9IDA7XG4gICAgaWYgKHRoaXMudmVyc2lvbiA9PT0gMikge1xuICAgICAgY29uc3QgZ2wyID0gdGhpcy5nbCBhcyBXZWJHTDJSZW5kZXJpbmdDb250ZXh0O1xuICAgICAgdGltZUVsYXBzZWQgPSBnbDIuZ2V0UXVlcnlQYXJhbWV0ZXIocXVlcnksIGdsMi5RVUVSWV9SRVNVTFQpO1xuICAgICAgZ2wyLmRlbGV0ZVF1ZXJ5KHF1ZXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogYWRkIHdlYmdsIDEgaGFuZGxpbmcuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdMMSBwcm9maWxpbmcgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIG1pbGlzZWNvbmRzXG4gICAgcmV0dXJuIHRpbWVFbGFwc2VkIC8gMTAwMDAwMDtcbiAgfVxuXG4gIGFzeW5jIHdhaXRGb3JRdWVyeUFuZEdldFRpbWUocXVlcnk6IFdlYkdMUXVlcnkpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGF3YWl0IHJlcGVhdGVkVHJ5KCgpID0+IHRoaXMuaXNUaW1lclJlc3VsdEF2YWlsYWJsZShxdWVyeSkpO1xuICAgIHJldHVybiB0aGlzLmdldFRpbWVyUmVzdWx0KHF1ZXJ5KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjcmVhdGVBbmRXYWl0Rm9yRmVuY2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgZmVuY2VDb250ZXh0ID0gdGhpcy5jcmVhdGVGZW5jZSh0aGlzLmdsKTtcbiAgICByZXR1cm4gdGhpcy5wb2xsRmVuY2UoZmVuY2VDb250ZXh0KTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlRmVuY2UoZ2w6IFdlYkdMUmVuZGVyaW5nQ29udGV4dCk6IEZlbmNlQ29udGV4dCB7XG4gICAgbGV0IGlzRmVuY2VQYXNzZWQ6ICgpID0+IGJvb2xlYW47XG4gICAgY29uc3QgZ2wyID0gZ2wgYXMgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcbiAgICBjb25zdCBxdWVyeSA9IGdsMi5mZW5jZVN5bmMoZ2wyLlNZTkNfR1BVX0NPTU1BTkRTX0NPTVBMRVRFLCAwKTtcbiAgICBnbC5mbHVzaCgpO1xuICAgIGlmIChxdWVyeSA9PT0gbnVsbCkge1xuICAgICAgaXNGZW5jZVBhc3NlZCA9ICgpID0+IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzRmVuY2VQYXNzZWQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IGdsMi5jbGllbnRXYWl0U3luYyhxdWVyeSwgMCwgMCk7XG4gICAgICAgIHJldHVybiBzdGF0dXMgPT09IGdsMi5BTFJFQURZX1NJR05BTEVEIHx8IHN0YXR1cyA9PT0gZ2wyLkNPTkRJVElPTl9TQVRJU0ZJRUQ7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge3F1ZXJ5LCBpc0ZlbmNlUGFzc2VkfTtcbiAgfVxuXG4gIGFzeW5jIHBvbGxGZW5jZShmZW5jZUNvbnRleHQ6IEZlbmNlQ29udGV4dCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPihyZXNvbHZlID0+IHtcbiAgICAgIHZvaWQgdGhpcy5hZGRJdGVtVG9Qb2xsKCgpID0+IGZlbmNlQ29udGV4dC5pc0ZlbmNlUGFzc2VkKCksICgpID0+IHJlc29sdmUoKSk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGl0ZW1zVG9Qb2xsOiBQb2xsSXRlbVtdID0gW107XG5cbiAgcG9sbEl0ZW1zKCk6IHZvaWQge1xuICAgIC8vIEZpbmQgdGhlIGxhc3QgcXVlcnkgdGhhdCBoYXMgZmluaXNoZWQuXG4gICAgY29uc3QgaW5kZXggPSBsaW5lYXJTZWFyY2hMYXN0VHJ1ZSh0aGlzLml0ZW1zVG9Qb2xsLm1hcCh4ID0+IHguaXNEb25lRm4pKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBpbmRleDsgKytpKSB7XG4gICAgICBjb25zdCB7cmVzb2x2ZUZufSA9IHRoaXMuaXRlbXNUb1BvbGxbaV07XG4gICAgICByZXNvbHZlRm4oKTtcbiAgICB9XG4gICAgdGhpcy5pdGVtc1RvUG9sbCA9IHRoaXMuaXRlbXNUb1BvbGwuc2xpY2UoaW5kZXggKyAxKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgYWRkSXRlbVRvUG9sbChpc0RvbmVGbjogKCkgPT4gYm9vbGVhbiwgcmVzb2x2ZUZuOiAoKSA9PiB2b2lkKSB7XG4gICAgdGhpcy5pdGVtc1RvUG9sbC5wdXNoKHtpc0RvbmVGbiwgcmVzb2x2ZUZufSk7XG4gICAgaWYgKHRoaXMuaXRlbXNUb1BvbGwubGVuZ3RoID4gMSkge1xuICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIGEgcnVubmluZyBsb29wIHRoYXQgcG9sbHMuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFN0YXJ0IGEgbmV3IGxvb3AgdGhhdCBwb2xscy5cbiAgICBhd2FpdCByZXBlYXRlZFRyeSgoKSA9PiB7XG4gICAgICB0aGlzLnBvbGxJdGVtcygpO1xuICAgICAgLy8gRW5kIHRoZSBsb29wIGlmIG5vIG1vcmUgaXRlbXMgdG8gcG9sbC5cbiAgICAgIHJldHVybiB0aGlzLml0ZW1zVG9Qb2xsLmxlbmd0aCA9PT0gMDtcbiAgICB9KTtcbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0xvZ2dlcn0gZnJvbSAnLi4vLi4vaW5zdHJ1bWVudCc7XG5cbmltcG9ydCB7V2ViR0xDb250ZXh0fSBmcm9tICcuL3dlYmdsLWNvbnRleHQnO1xuXG5jb25zdCBjYWNoZToge1tjb250ZXh0SWQ6IHN0cmluZ106IFdlYkdMQ29udGV4dH0gPSB7fTtcblxuLyoqXG4gKiBUaGlzIGZhY3RvcnkgZnVuY3Rpb24gY3JlYXRlcyBwcm9wZXIgV2ViR0xSZW5kZXJpbmdDb250ZXh0IGJhc2VkIG9uXG4gKiB0aGUgY3VycmVudCBicm93c2VycyBjYXBhYmlsaXRpZXNcbiAqIFRoZSBvcmRlciBpcyBmcm9tIGhpZ2hlci9tb3N0IHJlY2VudCB2ZXJzaW9ucyB0byBtb3N0IGJhc2ljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVXZWJHTENvbnRleHQoY29udGV4dElkPzogJ3dlYmdsJ3wnd2ViZ2wyJyk6IFdlYkdMQ29udGV4dCB7XG4gIGxldCBjb250ZXh0OiBXZWJHTENvbnRleHR8dW5kZWZpbmVkO1xuICBpZiAoKCFjb250ZXh0SWQgfHwgY29udGV4dElkID09PSAnd2ViZ2wyJykgJiYgJ3dlYmdsMicgaW4gY2FjaGUpIHtcbiAgICBjb250ZXh0ID0gY2FjaGUud2ViZ2wyO1xuICB9IGVsc2UgaWYgKCghY29udGV4dElkIHx8IGNvbnRleHRJZCA9PT0gJ3dlYmdsJykgJiYgJ3dlYmdsJyBpbiBjYWNoZSkge1xuICAgIGNvbnRleHQgPSBjYWNoZS53ZWJnbDtcbiAgfVxuXG4gIGlmICghY29udGV4dCkge1xuICAgIHRyeSB7XG4gICAgICAvLyB0cnkgdG8gY3JlYXRlIHdlYmdsIGNvbnRleHQgZnJvbSBhbiBvZmZzY3JlZW4gY2FudmFzXG4gICAgICBjb25zdCBvZmZzY3JlZW5DYW52YXMgPSBjcmVhdGVPZmZzY3JlZW5DYW52YXMoKTtcbiAgICAgIGNvbnRleHQgPSBjcmVhdGVOZXdXZWJHTENvbnRleHQob2Zmc2NyZWVuQ2FudmFzLCBjb250ZXh0SWQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGlmIGZhaWxlZCwgZmFsbGJhY2sgdG8gdHJ5IHRvIHVzZSBhIG5vcm1hbCBjYW52YXMgZWxlbWVudFxuICAgICAgY29uc3QgY2FudmFzID0gY3JlYXRlQ2FudmFzKCk7XG4gICAgICBjb250ZXh0ID0gY3JlYXRlTmV3V2ViR0xDb250ZXh0KGNhbnZhcywgY29udGV4dElkKTtcbiAgICB9XG4gIH1cblxuICBjb250ZXh0SWQgPSBjb250ZXh0SWQgfHwgY29udGV4dC52ZXJzaW9uID09PSAxID8gJ3dlYmdsJyA6ICd3ZWJnbDInO1xuICBjb25zdCBnbCA9IGNvbnRleHQuZ2w7XG5cbiAgY2FjaGVbY29udGV4dElkXSA9IGNvbnRleHQ7XG5cbiAgaWYgKGdsLmlzQ29udGV4dExvc3QoKSkge1xuICAgIGRlbGV0ZSBjYWNoZVtjb250ZXh0SWRdO1xuICAgIHJldHVybiBjcmVhdGVXZWJHTENvbnRleHQoY29udGV4dElkKTtcbiAgfVxuXG4gIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG4gIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG4gIGdsLmRpc2FibGUoZ2wuRElUSEVSKTtcbiAgZ2wuZGlzYWJsZShnbC5QT0xZR09OX09GRlNFVF9GSUxMKTtcbiAgZ2wuZGlzYWJsZShnbC5TQU1QTEVfQ09WRVJBR0UpO1xuICBnbC5lbmFibGUoZ2wuU0NJU1NPUl9URVNUKTtcbiAgZ2wuZW5hYmxlKGdsLkNVTExfRkFDRSk7XG4gIGdsLmN1bGxGYWNlKGdsLkJBQ0spO1xuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTmV3V2ViR0xDb250ZXh0KGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIGNvbnRleHRJZD86ICd3ZWJnbCd8J3dlYmdsMicpOiBXZWJHTENvbnRleHQge1xuICBjb25zdCBjb250ZXh0QXR0cmlidXRlczogV2ViR0xDb250ZXh0QXR0cmlidXRlcyA9IHtcbiAgICBhbHBoYTogZmFsc2UsXG4gICAgZGVwdGg6IGZhbHNlLFxuICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgc3RlbmNpbDogZmFsc2UsXG4gICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcbiAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlLFxuICAgIGZhaWxJZk1ham9yUGVyZm9ybWFuY2VDYXZlYXQ6IGZhbHNlXG4gIH07XG4gIGxldCBnbDogV2ViR0xSZW5kZXJpbmdDb250ZXh0fG51bGw7XG4gIGNvbnN0IGNhID0gY29udGV4dEF0dHJpYnV0ZXM7XG4gIGlmICghY29udGV4dElkIHx8IGNvbnRleHRJZCA9PT0gJ3dlYmdsMicpIHtcbiAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInLCBjYSk7XG4gICAgaWYgKGdsKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IFdlYkdMQ29udGV4dChnbCwgMik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgTG9nZ2VyLndhcm5pbmcoJ0dsQ29udGV4dEZhY3RvcnknLCBgZmFpbGVkIHRvIGNyZWF0ZSBXZWJHTENvbnRleHQgdXNpbmcgY29udGV4dElkICd3ZWJnbDInLiBFcnJvcjogJHtlcnJ9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghY29udGV4dElkIHx8IGNvbnRleHRJZCA9PT0gJ3dlYmdsJykge1xuICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgY2EpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBjYSkgYXMgV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuICAgIGlmIChnbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJHTENvbnRleHQoZ2wsIDEpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIExvZ2dlci53YXJuaW5nKFxuICAgICAgICAgICAgJ0dsQ29udGV4dEZhY3RvcnknLFxuICAgICAgICAgICAgYGZhaWxlZCB0byBjcmVhdGUgV2ViR0xDb250ZXh0IHVzaW5nIGNvbnRleHRJZCAnd2ViZ2wnIG9yICdleHBlcmltZW50YWwtd2ViZ2wnLiBFcnJvcjogJHtlcnJ9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdXZWJHTCBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmRlY2xhcmUgbGV0IE9mZnNjcmVlbkNhbnZhczoge25ldyAod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBIVE1MQ2FudmFzRWxlbWVudH07XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhcygpOiBIVE1MQ2FudmFzRWxlbWVudCB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZmFpbGVkIHRvIGNyZWF0ZSBjYW52YXM6IGRvY3VtZW50IGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuICBjb25zdCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIGNhbnZhcy53aWR0aCA9IDE7XG4gIGNhbnZhcy5oZWlnaHQgPSAxO1xuICByZXR1cm4gY2FudmFzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPZmZzY3JlZW5DYW52YXMoKTogSFRNTENhbnZhc0VsZW1lbnQge1xuICBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmYWlsZWQgdG8gY3JlYXRlIG9mZnNjcmVlbiBjYW52YXM6IE9mZnNjcmVlbkNhbnZhcyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSk7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7ZW52fSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQge0JhY2tlbmQsIFNlc3Npb25IYW5kbGVyfSBmcm9tICcuLi9iYWNrZW5kJztcbmltcG9ydCB7TG9nZ2VyfSBmcm9tICcuLi9pbnN0cnVtZW50JztcbmltcG9ydCB7U2Vzc2lvbn0gZnJvbSAnLi4vc2Vzc2lvbic7XG5cbmltcG9ydCB7V2ViR0xTZXNzaW9uSGFuZGxlcn0gZnJvbSAnLi93ZWJnbC9zZXNzaW9uLWhhbmRsZXInO1xuaW1wb3J0IHtXZWJHTENvbnRleHR9IGZyb20gJy4vd2ViZ2wvd2ViZ2wtY29udGV4dCc7XG5pbXBvcnQge2NyZWF0ZVdlYkdMQ29udGV4dH0gZnJvbSAnLi93ZWJnbC93ZWJnbC1jb250ZXh0LWZhY3RvcnknO1xuXG4vKipcbiAqIFdlYkdMQmFja2VuZCBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIGFsbCBXZWJHTCBvcGVhcnRpb25zXG4gKiBXaGVuIGl0IHN0YXJ0cyBpdCBjcmVhdGVkIHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHRcbiAqIGFuZCBvdGhlciBtYWluIGZyYW1ld29yayBjb21wb25lbnRzIHN1Y2ggYXMgUHJvZ3JhbSBhbmQgVGV4dHVyZSBNYW5hZ2Vyc1xuICovXG5leHBvcnQgY2xhc3MgV2ViR0xCYWNrZW5kIGltcGxlbWVudHMgQmFja2VuZCB7XG4gIGdsQ29udGV4dDogV2ViR0xDb250ZXh0O1xuXG4gIGdldCBjb250ZXh0SWQoKTogJ3dlYmdsJ3wnd2ViZ2wyJ3x1bmRlZmluZWQge1xuICAgIHJldHVybiBlbnYud2ViZ2wuY29udGV4dElkO1xuICB9XG4gIHNldCBjb250ZXh0SWQodmFsdWU6ICd3ZWJnbCd8J3dlYmdsMid8dW5kZWZpbmVkKSB7XG4gICAgZW52LndlYmdsLmNvbnRleHRJZCA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IG1hdG11bE1heEJhdGNoU2l6ZSgpOiBudW1iZXJ8dW5kZWZpbmVkIHtcbiAgICByZXR1cm4gZW52LndlYmdsLm1hdG11bE1heEJhdGNoU2l6ZTtcbiAgfVxuICBzZXQgbWF0bXVsTWF4QmF0Y2hTaXplKHZhbHVlOiBudW1iZXJ8dW5kZWZpbmVkKSB7XG4gICAgZW52LndlYmdsLm1hdG11bE1heEJhdGNoU2l6ZSA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IHRleHR1cmVDYWNoZU1vZGUoKTogJ2luaXRpYWxpemVyT25seSd8J2Z1bGwnfHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIGVudi53ZWJnbC50ZXh0dXJlQ2FjaGVNb2RlO1xuICB9XG4gIHNldCB0ZXh0dXJlQ2FjaGVNb2RlKHZhbHVlOiAnaW5pdGlhbGl6ZXJPbmx5J3wnZnVsbCd8dW5kZWZpbmVkKSB7XG4gICAgZW52LndlYmdsLnRleHR1cmVDYWNoZU1vZGUgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCBwYWNrKCk6IGJvb2xlYW58dW5kZWZpbmVkIHtcbiAgICByZXR1cm4gZW52LndlYmdsLnBhY2s7XG4gIH1cbiAgc2V0IHBhY2sodmFsdWU6IGJvb2xlYW58dW5kZWZpbmVkKSB7XG4gICAgZW52LndlYmdsLnBhY2sgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCBhc3luYygpOiBib29sZWFufHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIGVudi53ZWJnbC5hc3luYztcbiAgfVxuICBzZXQgYXN5bmModmFsdWU6IGJvb2xlYW58dW5kZWZpbmVkKSB7XG4gICAgZW52LndlYmdsLmFzeW5jID0gdmFsdWU7XG4gIH1cblxuICBpbml0aWFsaXplKCk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmdsQ29udGV4dCA9IGNyZWF0ZVdlYkdMQ29udGV4dCh0aGlzLmNvbnRleHRJZCk7XG4gICAgICBpZiAodHlwZW9mIHRoaXMubWF0bXVsTWF4QmF0Y2hTaXplICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLm1hdG11bE1heEJhdGNoU2l6ZSA9IDE2O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnRleHR1cmVDYWNoZU1vZGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZUNhY2hlTW9kZSA9ICdmdWxsJztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5wYWNrICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhpcy5wYWNrID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRoaXMuYXN5bmMgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aGlzLmFzeW5jID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIExvZ2dlci5zZXRXaXRoRW52KGVudik7XG5cbiAgICAgIGlmICghZW52LndlYmdsLmNvbnRleHQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVudi53ZWJnbCwgJ2NvbnRleHQnLCB7dmFsdWU6IHRoaXMuZ2xDb250ZXh0LmdsfSk7XG4gICAgICB9XG5cbiAgICAgIExvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICdXZWJHTEJhY2tlbmQnLFxuICAgICAgICAgIGBDcmVhdGVkIFdlYkdMQ29udGV4dDogJHt0eXBlb2YgdGhpcy5nbENvbnRleHR9IHdpdGggbWF0bXVsTWF4QmF0Y2hTaXplOiAke1xuICAgICAgICAgICAgICB0aGlzLm1hdG11bE1heEJhdGNoU2l6ZX07IHRleHR1cmVDYWNoZU1vZGU6ICR7dGhpcy50ZXh0dXJlQ2FjaGVNb2RlfTsgcGFjazogJHt0aGlzLnBhY2t9OyBhc3luYzogJHtcbiAgICAgICAgICAgICAgdGhpcy5hc3luY30uYCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBMb2dnZXIud2FybmluZygnV2ViR0xCYWNrZW5kJywgYFVuYWJsZSB0byBpbml0aWFsaXplIFdlYkdMQmFja2VuZC4gJHtlfWApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBjcmVhdGVTZXNzaW9uSGFuZGxlcihjb250ZXh0OiBTZXNzaW9uLkNvbnRleHQpOiBTZXNzaW9uSGFuZGxlciB7XG4gICAgcmV0dXJuIG5ldyBXZWJHTFNlc3Npb25IYW5kbGVyKHRoaXMsIGNvbnRleHQpO1xuICB9XG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5nbENvbnRleHQuZGlzcG9zZSgpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7V2ViR0xCYWNrZW5kfSBmcm9tICcuL2JhY2tlbmRzL2JhY2tlbmQtd2ViZ2wnO1xuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi9ncmFwaCc7XG5pbXBvcnQge09wZXJhdG9yfSBmcm9tICcuL29wZXJhdG9ycyc7XG5pbXBvcnQge09wU2V0fSBmcm9tICcuL29wc2V0JztcbmltcG9ydCB7U2Vzc2lvbn0gZnJvbSAnLi9zZXNzaW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBJbmZlcmVuY2VIYW5kbGVyIHtcbiAgLyoqXG4gICAqIGRpc3Bvc2UgdGhlIGluZmVyZW5jZSBoYW5kbGVyLiBpdCB3aWxsIGJlIGNhbGxlZCBhcyB0aGUgbGFzdCBzdGVwIGluIFNlc3Npb24ucnVuKClcbiAgICovXG4gIGRpc3Bvc2UoKTogdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uSGFuZGxlciB7XG4gIC8qKlxuICAgKiB0cmFuc2Zvcm0gdGhlIGdyYXBoIGF0IGluaXRpYWxpemF0aW9uIHRpbWVcbiAgICogQHBhcmFtIGdyYXBoVHJhbnNmb3JtZXIgdGhlIGdyYXBoIHRyYW5zZm9ybWVyIHRvIG1hbmlwdWxhdGUgdGhlIG1vZGVsIGdyYXBoXG4gICAqL1xuICB0cmFuc2Zvcm1HcmFwaD8oZ3JhcGhUcmFuc2Zvcm1lcjogR3JhcGguVHJhbnNmb3JtZXIpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgSW5mZXJlbmNlSGFuZGxlciB0byB1c2UgaW4gYSBTZXNzaW9uLnJ1bigpIGNhbGxcbiAgICovXG4gIGNyZWF0ZUluZmVyZW5jZUhhbmRsZXIoKTogSW5mZXJlbmNlSGFuZGxlcjtcblxuICAvKipcbiAgICogZGlzcG9zZSB0aGUgc2Vzc2lvbiBoYW5kbGVyLiBpdCB3aWxsIGJlIGNhbGxlZCB3aGVuIGEgc2Vzc2lvbiBpcyBiZWluZyBkaXNwb3NlZCBleHBsaWNpdGx5XG4gICAqL1xuICBkaXNwb3NlKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIHRoZSBvcGVyYXRvciBmcm9tIHRoZSBuYW1lIGFuZCBvcHNldCB2ZXJzaW9uOyBiYWNrZW5kIHNwZWNpZmljXG4gICAqIEBwYXJhbSBub2RlIHRoZSBub2RlIHRvIHJlc29sdmVcbiAgICogQHBhcmFtIG9wc2V0cyBhIGxpc3Qgb2Ygb3BzZXRzIHRoYXQgZXhwb3J0ZWQgZnJvbSB0aGUgbW9kZWxcbiAgICogQHBhcmFtIGdyYXBoIHRoZSBjb21wbGV0ZWx5IGluaXRpYWxpemVkIGdyYXBoXG4gICAqL1xuICByZXNvbHZlKG5vZGU6IEdyYXBoLk5vZGUsIG9wc2V0czogcmVhZG9ubHkgT3BTZXRbXSwgZ3JhcGg6IEdyYXBoKTogT3BlcmF0b3I7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGxldCdzIHRoZSBzZXNzaW9uSGFuZGxlciBrbm93IHRoYXQgdGhlIGdyYXBoIGluaXRpYWxpemF0aW9uIGlzIGNvbXBsZXRlXG4gICAqIEBwYXJhbSBncmFwaCB0aGUgY29tcGxldGVseSBpbml0aWFsaXplZCBncmFwaFxuICAgKi9cbiAgb25HcmFwaEluaXRpYWxpemVkPyhncmFwaDogR3JhcGgpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBhIHJlZmVyZW5jZSB0byB0aGUgY29ycmVzcG9uZGluZyBiYWNrZW5kXG4gICAqL1xuICByZWFkb25seSBiYWNrZW5kOiBCYWNrZW5kO1xuXG4gIC8qKlxuICAgKiBhIHJlZmVyZW5jZSB0byB0aGUgc2Vzc2lvbiBjb250ZXh0XG4gICAqL1xuICByZWFkb25seSBjb250ZXh0OiBTZXNzaW9uLkNvbnRleHQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFja2VuZCB7XG4gIC8qKlxuICAgKiBpbml0aWFsaXplIHRoZSBiYWNrZW5kLiB3aWxsIGJlIGNhbGxlZCBvbmx5IG9uY2UsIHdoZW4gdGhlIGZpcnN0IHRpbWUgdGhlXG4gICAqIGJhY2tlbmQgaXQgdG8gYmUgdXNlZFxuICAgKi9cbiAgaW5pdGlhbGl6ZSgpOiBib29sZWFufFByb21pc2U8Ym9vbGVhbj47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiBTZXNzaW9uSGFuZGxlciB0byB1c2UgaW4gYSBTZXNzaW9uIG9iamVjdCdzIGxpZmVjeWNsZVxuICAgKi9cbiAgY3JlYXRlU2Vzc2lvbkhhbmRsZXIoY29udGV4dDogU2Vzc2lvbi5Db250ZXh0KTogU2Vzc2lvbkhhbmRsZXI7XG5cbiAgLyoqXG4gICAqIGRpc3Bvc2UgdGhlIGJhY2tlbmQuIGN1cnJlbnRseSB0aGlzIHdpbGwgbm90IGJlIGNhbGxlZFxuICAgKi9cbiAgZGlzcG9zZSgpOiB2b2lkO1xufVxuXG4vLyBjYWNoZXMgYWxsIGluaXRpYWxpemVkIGJhY2tlbmQgaW5zdGFuY2VzXG5jb25zdCBiYWNrZW5kc0NhY2hlOiBNYXA8c3RyaW5nLCBCYWNrZW5kPiA9IG5ldyBNYXAoKTtcblxuZXhwb3J0IGNvbnN0IGJhY2tlbmQ6IHtbbmFtZTogc3RyaW5nXTogQmFja2VuZH0gPSB7XG4gIHdlYmdsOiBuZXcgV2ViR0xCYWNrZW5kKClcbn07XG5cbi8qKlxuICogUmVzb2x2ZSBhIHJlZmVyZW5jZSB0byB0aGUgYmFja2VuZC4gSWYgYSBoaW50IGlzIHNwZWNpZmllZCwgdGhlIGNvcnJlc3BvbmRpbmdcbiAqIGJhY2tlbmQgd2lsbCBiZSB1c2VkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUJhY2tlbmQoaGludD86IHN0cmluZ3xyZWFkb25seSBzdHJpbmdbXSk6IFByb21pc2U8QmFja2VuZD4ge1xuICBpZiAoIWhpbnQpIHtcbiAgICByZXR1cm4gcmVzb2x2ZUJhY2tlbmQoWyd3ZWJnbCddKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBoaW50cyA9IHR5cGVvZiBoaW50ID09PSAnc3RyaW5nJyA/IFtoaW50XSA6IGhpbnQ7XG5cbiAgICBmb3IgKGNvbnN0IGJhY2tlbmRIaW50IG9mIGhpbnRzKSB7XG4gICAgICBjb25zdCBjYWNoZSA9IGJhY2tlbmRzQ2FjaGUuZ2V0KGJhY2tlbmRIaW50KTtcbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJhY2tlbmQgPSBhd2FpdCB0cnlMb2FkQmFja2VuZChiYWNrZW5kSGludCk7XG4gICAgICBpZiAoYmFja2VuZCkge1xuICAgICAgICByZXR1cm4gYmFja2VuZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ25vIGF2YWlsYWJsZSBiYWNrZW5kIHRvIHVzZScpO1xufVxuXG5hc3luYyBmdW5jdGlvbiB0cnlMb2FkQmFja2VuZChiYWNrZW5kSGludDogc3RyaW5nKTogUHJvbWlzZTxCYWNrZW5kfHVuZGVmaW5lZD4ge1xuICBjb25zdCBiYWNrZW5kT2JqID0gYmFja2VuZDtcblxuICBpZiAodHlwZW9mIGJhY2tlbmRPYmpbYmFja2VuZEhpbnRdICE9PSAndW5kZWZpbmVkJyAmJiBpc0JhY2tlbmQoYmFja2VuZE9ialtiYWNrZW5kSGludF0pKSB7XG4gICAgY29uc3QgYmFja2VuZCA9IGJhY2tlbmRPYmpbYmFja2VuZEhpbnRdO1xuICAgIGxldCBpbml0ID0gYmFja2VuZC5pbml0aWFsaXplKCk7XG4gICAgaWYgKHR5cGVvZiBpbml0ID09PSAnb2JqZWN0JyAmJiAndGhlbicgaW4gaW5pdCkge1xuICAgICAgaW5pdCA9IGF3YWl0IGluaXQ7XG4gICAgfVxuICAgIGlmIChpbml0KSB7XG4gICAgICBiYWNrZW5kc0NhY2hlLnNldChiYWNrZW5kSGludCwgYmFja2VuZCk7XG4gICAgICByZXR1cm4gYmFja2VuZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0JhY2tlbmQob2JqOiB1bmtub3duKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGNvbnN0IG8gPSBvYmogYXMgYW55O1xuXG4gIC8vIGNoZWNrIGlmIGFuIG9iamVjdCBpcyBhIEJhY2tlbmQgaW5zdGFuY2VcbiAgaWYgKFxuICAgICAgJ2luaXRpYWxpemUnIGluIG8gJiYgdHlwZW9mIG8uaW5pdGlhbGl6ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAgICAgICAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXplKClcbiAgICAgICdjcmVhdGVTZXNzaW9uSGFuZGxlcicgaW4gbyAmJiB0eXBlb2Ygby5jcmVhdGVTZXNzaW9uSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJyAmJiAgLy8gY3JlYXRlU2Vzc2lvbkhhbmRsZXIoKVxuICAgICAgJ2Rpc3Bvc2UnIGluIG8gJiYgdHlwZW9mIG8uZGlzcG9zZSA9PT0gJ2Z1bmN0aW9uJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkaXNwb3NlKClcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCB0eXBlIEJhY2tlbmRUeXBlID0gQmFja2VuZDtcbmV4cG9ydCB0eXBlIFNlc3Npb25IYW5kbGVyVHlwZSA9IFJldHVyblR5cGU8QmFja2VuZFR5cGVbJ2NyZWF0ZVNlc3Npb25IYW5kbGVyJ10+O1xuZXhwb3J0IHR5cGUgSW5mZXJlbmNlSGFuZGxlclR5cGUgPSBSZXR1cm5UeXBlPFNlc3Npb25IYW5kbGVyVHlwZVsnY3JlYXRlSW5mZXJlbmNlSGFuZGxlciddPjtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtTZXNzaW9uSGFuZGxlcn0gZnJvbSAnLi9iYWNrZW5kJztcbmltcG9ydCB7R3JhcGh9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0IHtMb2dnZXIsIFByb2ZpbGVyfSBmcm9tICcuL2luc3RydW1lbnQnO1xuaW1wb3J0IHtPcGVyYXRvcn0gZnJvbSAnLi9vcGVyYXRvcnMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4vdGVuc29yJztcblxuY2xhc3MgS2VybmVsT3Age1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgb3A6IE9wZXJhdG9yLCBwdWJsaWMgbm9kZTogR3JhcGguTm9kZSkge31cbn1cblxuZXhwb3J0IGNsYXNzIEV4ZWN1dGlvblBsYW4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGdyYXBoOiBHcmFwaCwgb3BzOiBPcGVyYXRvcltdLCBwcml2YXRlIHByb2ZpbGVyOiBSZWFkb25seTxQcm9maWxlcj4pIHtcbiAgICB0aGlzLmluaXRpYWxpemUob3BzKTtcbiAgfVxuXG4gIGluaXRpYWxpemUob3BzOiBPcGVyYXRvcltdKSB7XG4gICAgdGhpcy5wcm9maWxlci5ldmVudCgnc2Vzc2lvbicsICdFeGVjdXRpb25QbGFuLmluaXRpYWxpemUnLCAoKSA9PiB7XG4gICAgICBjb25zdCBncmFwaE5vZGVzID0gdGhpcy5ncmFwaC5nZXROb2RlcygpO1xuICAgICAgaWYgKGdyYXBoTm9kZXMubGVuZ3RoICE9PSBvcHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNpemUgb2Ygbm9kZXMgYW5kIE9QcyBkbyBub3QgbWF0Y2guJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX29wcyA9IG9wcy5tYXAoKG9wLCBpKSA9PiBuZXcgS2VybmVsT3Aob3AsIGdyYXBoTm9kZXNbaV0pKTtcbiAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgLy8gbG9vayBmb3Igc3RhcnRlciBub2RlKHMpXG4gICAgICB0aGlzLl9zdGFydGVyID0gW107XG4gICAgICB0aGlzLl9vcHMuZm9yRWFjaCgob3AsIGkpID0+IHtcbiAgICAgICAgbGV0IHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBpbnB1dCBvZiBvcC5ub2RlLmlucHV0cykge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgIXRoaXMuX3ZhbHVlc1tpbnB1dF0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBhbiBpbml0aWFsaXplZCBpbnB1dFxuICAgICAgICAgICAgICAmJiB0aGlzLmdyYXBoLmdldElucHV0SW5kaWNlcygpLmluZGV4T2YoaW5wdXQpID09PSAtMSAgLy8gbm90IG1vZGVsIGlucHV0XG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXNvbHZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNvbHZlZCkge1xuICAgICAgICAgIHRoaXMuX3N0YXJ0ZXIucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICB0aGlzLl92YWx1ZXMgPSB0aGlzLmdyYXBoLmdldFZhbHVlcygpLm1hcChpID0+IGkudGVuc29yKTtcbiAgfVxuXG4gIGFzeW5jIGV4ZWN1dGUoc2Vzc2lvbkhhbmRsZXI6IFNlc3Npb25IYW5kbGVyLCBtb2RlbElucHV0czogVGVuc29yW10pOiBQcm9taXNlPFRlbnNvcltdPiB7XG4gICAgcmV0dXJuIHRoaXMucHJvZmlsZXIuZXZlbnQoJ3Nlc3Npb24nLCAnRXhlY3V0aW9uUGxhbi5leGVjdXRlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gcmVzZXQgbWVkaWVtIHJlc3VsdFxuICAgICAgdGhpcy5yZXNldCgpO1xuXG4gICAgICAvLyBjcmVhdGUgaW5mZXJlbmNlIGhhbmRsZXJcbiAgICAgIGNvbnN0IGluZmVyZW5jZUhhbmRsZXIgPSBzZXNzaW9uSGFuZGxlci5jcmVhdGVJbmZlcmVuY2VIYW5kbGVyKCk7XG5cbiAgICAgIC8vIHBvcHVsYXRlIGlucHV0cyB2YWx1ZVxuICAgICAgY29uc3QgZ3JhcGhJbnB1dHMgPSB0aGlzLmdyYXBoLmdldElucHV0SW5kaWNlcygpO1xuICAgICAgaWYgKG1vZGVsSW5wdXRzLmxlbmd0aCAhPT0gZ3JhcGhJbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbnVtYmVyIG9mIGlucHV0IHRlbnNvcnMgZG9uJ3QgbWF0Y2ggdGhlIG51bWJlciBvZiBpbnB1dHMgdG8gdGhlIG1vZGVsOiBhY3R1YWw6ICR7XG4gICAgICAgICAgICBtb2RlbElucHV0cy5sZW5ndGh9IGV4cGVjdGVkOiAke2dyYXBoSW5wdXRzLmxlbmd0aH1gKTtcbiAgICAgIH1cblxuICAgICAgbW9kZWxJbnB1dHMuZm9yRWFjaCgoaW5wdXQsIGkpID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBncmFwaElucHV0c1tpXTtcbiAgICAgICAgdGhpcy5fdmFsdWVzW2luZGV4XSA9IGlucHV0O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHByZXBhcmUgcnVubmluZyBzZXF1ZW5jZVxuICAgICAgY29uc3Qgc2VxdWVuY2U6IG51bWJlcltdID0gdGhpcy5fc3RhcnRlci5zbGljZSgwKTtcblxuICAgICAgLy8gZXhlY3V0aW9uIGl0ZXJhdGlvbnNcbiAgICAgIGNvbnN0IGdyYXBoVmFsdWVzID0gdGhpcy5ncmFwaC5nZXRWYWx1ZXMoKTtcbiAgICAgIGNvbnN0IGdyYXBoTm9kZXMgPSB0aGlzLmdyYXBoLmdldE5vZGVzKCk7XG5cbiAgICAgIGxldCByZWFyID0gMDtcbiAgICAgIHdoaWxlIChyZWFyIDwgc2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHRoaXNPcEluZGV4ID0gc2VxdWVuY2VbcmVhcisrXTtcbiAgICAgICAgY29uc3QgdGhpc09wID0gdGhpcy5fb3BzW3RoaXNPcEluZGV4XTtcblxuICAgICAgICAvLyBjaGVjayBpbnB1dFxuICAgICAgICBjb25zdCBpbnB1dExpc3QgPSB0aGlzT3Aubm9kZS5pbnB1dHMubWFwKGkgPT4gdGhpcy5fdmFsdWVzW2ldKTtcbiAgICAgICAgaWYgKGlucHV0TGlzdC5pbmRleE9mKHVuZGVmaW5lZCkgIT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnJlc29sdmVkIGlucHV0IGRldGVjdGVkOiBvcDogJHt0aGlzT3Aubm9kZX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJ1blxuICAgICAgICBjb25zdCBpbnB1dFRlbnNvcnMgPSBpbnB1dExpc3QgYXMgVGVuc29yW107XG4gICAgICAgIExvZ2dlci52ZXJib3NlKFxuICAgICAgICAgICAgJ0V4ZWNQbGFuJyxcbiAgICAgICAgICAgIGBSdW5pbmcgb3A6JHt0aGlzT3Aubm9kZS5uYW1lfSAoJHtcbiAgICAgICAgICAgICAgICBpbnB1dFRlbnNvcnMubWFwKCh0LCBpKSA9PiBgJyR7dGhpc09wLm5vZGUuaW5wdXRzW2ldfSc6ICR7dC50eXBlfVske3QuZGltcy5qb2luKCcsJyl9XWApLmpvaW4oJywgJyl9KWApO1xuXG4gICAgICAgIGNvbnN0IG91dHB1dExpc3QgPSBhd2FpdCB0aGlzLnByb2ZpbGVyLmV2ZW50KFxuICAgICAgICAgICAgJ25vZGUnLCB0aGlzT3Aubm9kZS5uYW1lLCBhc3luYyAoKSA9PiB0aGlzT3Aub3AuaW1wbChpbmZlcmVuY2VIYW5kbGVyLCBpbnB1dFRlbnNvcnMsIHRoaXNPcC5vcC5jb250ZXh0KSk7XG5cbiAgICAgICAgLy8gY2hlY2sgb3V0cHV0XG4gICAgICAgIGlmIChvdXRwdXRMaXN0Lmxlbmd0aCAhPT0gdGhpc09wLm5vZGUub3V0cHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZSBzaXplIG9mIG91dHB1dCBkb2VzIG5vdCBtYXRjaCBtb2RlbCBkZWZpbml0aW9uLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlsbCB2YWx1ZVxuICAgICAgICBvdXRwdXRMaXN0LmZvckVhY2goKG91dHB1dCwgaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGogPSB0aGlzT3Aubm9kZS5vdXRwdXRzW2ldO1xuICAgICAgICAgIGlmICh0aGlzLl92YWx1ZXNbal0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb3V0cHV0IFske2p9XSBhbHJlYWR5IGhhcyB2YWx1ZTogb3A6JHt0aGlzT3Aubm9kZS5uYW1lfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl92YWx1ZXNbal0gPSBvdXRwdXQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHJlc29sdmUgZG93bnN0cmVhbSBub2Rlc1xuICAgICAgICBjb25zdCBkb3duc3RyZWFtTm9kZXMgPSBuZXcgU2V0PG51bWJlcj4oKTtcbiAgICAgICAgb3V0cHV0TGlzdC5mb3JFYWNoKChfb3V0cHV0LCBpKSA9PiB7XG4gICAgICAgICAgY29uc3QgaiA9IHRoaXNPcC5ub2RlLm91dHB1dHNbaV07XG4gICAgICAgICAgZm9yIChjb25zdCBjdXJyZW50RG93bnN0cmVhbU5vZGVJbmRleCBvZiBncmFwaFZhbHVlc1tqXS50bykge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudERvd25zdHJlYW1Ob2RlID0gZ3JhcGhOb2Rlc1tjdXJyZW50RG93bnN0cmVhbU5vZGVJbmRleF07XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIGN1cnJlbnREb3duc3RyZWFtTm9kZS5pbnB1dHMpIHtcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLl92YWx1ZXNba10pIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgZG93bnN0cmVhbU5vZGVzLmFkZChjdXJyZW50RG93bnN0cmVhbU5vZGVJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2VxdWVuY2UucHVzaCguLi5kb3duc3RyZWFtTm9kZXMpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvdXRwdXQ6IFRlbnNvcltdID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZ3JhcGguZ2V0T3V0cHV0SW5kaWNlcygpLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dEluZGV4ID0gdGhpcy5ncmFwaC5nZXRPdXRwdXRJbmRpY2VzKClbaV07XG4gICAgICAgIGNvbnN0IG91dHB1dFRlbnNvciA9IHRoaXMuX3ZhbHVlc1tvdXRwdXRJbmRleF07XG4gICAgICAgIGlmIChvdXRwdXRUZW5zb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcmVxdWlyZWQgb3V0cHV0IFske291dHB1dEluZGV4fV0gZG9lcyBub3QgaGF2ZSB2YWx1ZWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdXRwdXRJbmRleCA9PT0gMCkge1xuICAgICAgICAgIGF3YWl0IG91dHB1dFRlbnNvci5nZXREYXRhKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgICAgICAgIG91dHB1dFRlbnNvci5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5wdXNoKG91dHB1dFRlbnNvcik7XG4gICAgICB9XG4gICAgICBMb2dnZXIudmVyYm9zZSgnRXhlY1BsYW4nLCAnZGlzcG9zaW5nIG9mIGluZmVyZW5jZUhhbmRsZXInKTtcbiAgICAgIGluZmVyZW5jZUhhbmRsZXIuZGlzcG9zZSgpO1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9KTtcbiAgfVxuXG4gIF92YWx1ZXM6IEFycmF5PFRlbnNvcnx1bmRlZmluZWQ+O1xuICBfb3BzOiBLZXJuZWxPcFtdO1xuICBfc3RhcnRlcjogbnVtYmVyW107XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCBMb25nIGZyb20gJ2xvbmcnO1xuXG5pbXBvcnQge29ubnhydW50aW1lfSBmcm9tICcuL29ydC1zY2hlbWEvZmxhdGJ1ZmZlcnMvb3J0LWdlbmVyYXRlZCc7XG5pbXBvcnQge29ubnh9IGZyb20gJy4vb3J0LXNjaGVtYS9wcm90b2J1Zi9vbm54JztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuL3RlbnNvcic7XG5pbXBvcnQge2RlY29kZVV0ZjhTdHJpbmcsIExvbmdVdGlsfSBmcm9tICcuL3V0aWwnO1xuXG5pbXBvcnQgb3J0RmJzID0gb25ueHJ1bnRpbWUuZXhwZXJpbWVudGFsLmZicztcblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEF0dHJpYnV0ZSB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgRGF0YVR5cGVNYXAge1xuICAgIGZsb2F0OiBudW1iZXI7XG4gICAgaW50OiBudW1iZXI7XG4gICAgc3RyaW5nOiBzdHJpbmc7XG4gICAgdGVuc29yOiBUZW5zb3I7XG4gICAgZmxvYXRzOiBudW1iZXJbXTtcbiAgICBpbnRzOiBudW1iZXJbXTtcbiAgICBzdHJpbmdzOiBzdHJpbmdbXTtcbiAgICB0ZW5zb3JzOiBUZW5zb3JbXTtcbiAgfVxuXG4gIGV4cG9ydCB0eXBlIERhdGFUeXBlID0ga2V5b2YgRGF0YVR5cGVNYXA7XG59XG5cbnR5cGUgVmFsdWVUeXBlcyA9IEF0dHJpYnV0ZS5EYXRhVHlwZU1hcFtBdHRyaWJ1dGUuRGF0YVR5cGVdO1xuXG50eXBlIFZhbHVlID0gW1ZhbHVlVHlwZXMsIEF0dHJpYnV0ZS5EYXRhVHlwZV07XG5cbmV4cG9ydCBjbGFzcyBBdHRyaWJ1dGUge1xuICBjb25zdHJ1Y3RvcihhdHRyaWJ1dGVzOiBvbm54LklBdHRyaWJ1dGVQcm90b1tdfG9ydEZicy5BdHRyaWJ1dGVbXXxudWxsfHVuZGVmaW5lZCkge1xuICAgIHRoaXMuX2F0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgaWYgKGF0dHJpYnV0ZXMgIT09IG51bGwgJiYgYXR0cmlidXRlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoYXR0ciBpbnN0YW5jZW9mIG9ubnguQXR0cmlidXRlUHJvdG8pIHtcbiAgICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzLnNldChhdHRyLm5hbWUsIFtBdHRyaWJ1dGUuZ2V0VmFsdWUoYXR0ciksIEF0dHJpYnV0ZS5nZXRUeXBlKGF0dHIpXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXR0ciBpbnN0YW5jZW9mIG9ydEZicy5BdHRyaWJ1dGUpIHtcbiAgICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzLnNldChhdHRyLm5hbWUoKSEsIFtBdHRyaWJ1dGUuZ2V0VmFsdWUoYXR0ciksIEF0dHJpYnV0ZS5nZXRUeXBlKGF0dHIpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9hdHRyaWJ1dGVzLnNpemUgPCBhdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2R1cGxpY2F0ZWQgYXR0cmlidXRlIG5hbWVzJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2V0KGtleTogc3RyaW5nLCB0eXBlOiBBdHRyaWJ1dGUuRGF0YVR5cGUsIHZhbHVlOiBWYWx1ZVR5cGVzKTogdm9pZCB7XG4gICAgdGhpcy5fYXR0cmlidXRlcy5zZXQoa2V5LCBbdmFsdWUsIHR5cGVdKTtcbiAgfVxuICBkZWxldGUoa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLl9hdHRyaWJ1dGVzLmRlbGV0ZShrZXkpO1xuICB9XG4gIGdldEZsb2F0KGtleTogc3RyaW5nLCBkZWZhdWx0VmFsdWU/OiBBdHRyaWJ1dGUuRGF0YVR5cGVNYXBbJ2Zsb2F0J10pIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoa2V5LCAnZmxvYXQnLCBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgZ2V0SW50KGtleTogc3RyaW5nLCBkZWZhdWx0VmFsdWU/OiBBdHRyaWJ1dGUuRGF0YVR5cGVNYXBbJ2ludCddKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGtleSwgJ2ludCcsIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICBnZXRTdHJpbmcoa2V5OiBzdHJpbmcsIGRlZmF1bHRWYWx1ZT86IEF0dHJpYnV0ZS5EYXRhVHlwZU1hcFsnc3RyaW5nJ10pIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoa2V5LCAnc3RyaW5nJywgZGVmYXVsdFZhbHVlKTtcbiAgfVxuXG4gIGdldFRlbnNvcihrZXk6IHN0cmluZywgZGVmYXVsdFZhbHVlPzogQXR0cmlidXRlLkRhdGFUeXBlTWFwWyd0ZW5zb3InXSkge1xuICAgIHJldHVybiB0aGlzLmdldChrZXksICd0ZW5zb3InLCBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgZ2V0RmxvYXRzKGtleTogc3RyaW5nLCBkZWZhdWx0VmFsdWU/OiBBdHRyaWJ1dGUuRGF0YVR5cGVNYXBbJ2Zsb2F0cyddKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGtleSwgJ2Zsb2F0cycsIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICBnZXRJbnRzKGtleTogc3RyaW5nLCBkZWZhdWx0VmFsdWU/OiBBdHRyaWJ1dGUuRGF0YVR5cGVNYXBbJ2ludHMnXSkge1xuICAgIHJldHVybiB0aGlzLmdldChrZXksICdpbnRzJywgZGVmYXVsdFZhbHVlKTtcbiAgfVxuXG4gIGdldFN0cmluZ3Moa2V5OiBzdHJpbmcsIGRlZmF1bHRWYWx1ZT86IEF0dHJpYnV0ZS5EYXRhVHlwZU1hcFsnc3RyaW5ncyddKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGtleSwgJ3N0cmluZ3MnLCBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgZ2V0VGVuc29ycyhrZXk6IHN0cmluZywgZGVmYXVsdFZhbHVlPzogQXR0cmlidXRlLkRhdGFUeXBlTWFwWyd0ZW5zb3JzJ10pIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoa2V5LCAndGVuc29ycycsIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICBwcml2YXRlIGdldDxWIGV4dGVuZHMgQXR0cmlidXRlLkRhdGFUeXBlTWFwW0F0dHJpYnV0ZS5EYXRhVHlwZV0+KFxuICAgICAga2V5OiBzdHJpbmcsIHR5cGU6IEF0dHJpYnV0ZS5EYXRhVHlwZSwgZGVmYXVsdFZhbHVlPzogVik6IFYge1xuICAgIGNvbnN0IHZhbHVlQW5kVHlwZSA9IHRoaXMuX2F0dHJpYnV0ZXMuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlQW5kVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgcmVxdWlyZWQgYXR0cmlidXRlIG5vdCBmb3VuZDogJHtrZXl9YCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZUFuZFR5cGVbMV0gIT09IHR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdHlwZSBtaXNtYXRjaDogZXhwZWN0ZWQgJHt0eXBlfSBidXQgZ290ICR7dmFsdWVBbmRUeXBlWzFdfWApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVBbmRUeXBlWzBdIGFzIFY7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZXRUeXBlKGF0dHI6IG9ubnguSUF0dHJpYnV0ZVByb3RvfG9ydEZicy5BdHRyaWJ1dGUpOiBBdHRyaWJ1dGUuRGF0YVR5cGUge1xuICAgIGNvbnN0IHR5cGUgPSBhdHRyIGluc3RhbmNlb2Ygb25ueC5BdHRyaWJ1dGVQcm90byA/IChhdHRyKS50eXBlIDogKGF0dHIgYXMgb3J0RmJzLkF0dHJpYnV0ZSkudHlwZSgpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuRkxPQVQ6XG4gICAgICAgIHJldHVybiAnZmxvYXQnO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuSU5UOlxuICAgICAgICByZXR1cm4gJ2ludCc7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5TVFJJTkc6XG4gICAgICAgIHJldHVybiAnc3RyaW5nJztcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUjpcbiAgICAgICAgcmV0dXJuICd0ZW5zb3InO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuRkxPQVRTOlxuICAgICAgICByZXR1cm4gJ2Zsb2F0cyc7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlRTOlxuICAgICAgICByZXR1cm4gJ2ludHMnO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuU1RSSU5HUzpcbiAgICAgICAgcmV0dXJuICdzdHJpbmdzJztcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUlM6XG4gICAgICAgIHJldHVybiAndGVuc29ycyc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGF0dHJpYnV0ZSB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQgeWV0OiAke29ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZVt0eXBlXX1gKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZXRWYWx1ZShhdHRyOiBvbm54LklBdHRyaWJ1dGVQcm90b3xvcnRGYnMuQXR0cmlidXRlKSB7XG4gICAgY29uc3QgYXR0clR5cGUgPSBhdHRyIGluc3RhbmNlb2Ygb25ueC5BdHRyaWJ1dGVQcm90byA/IGF0dHIudHlwZSA6IChhdHRyIGFzIG9ydEZicy5BdHRyaWJ1dGUpLnR5cGUoKTtcbiAgICBpZiAoYXR0clR5cGUgPT09IG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5HUkFQSCB8fCBhdHRyVHlwZSA9PT0gb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkdSQVBIUykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdncmFwaCBhdHRyaWJ1dGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWVOb0NoZWNrKGF0dHIpO1xuXG4gICAgLy8gY2FzdCBMT05HIHRvIG51bWJlclxuICAgIGlmIChhdHRyVHlwZSA9PT0gb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVCAmJiBMb25nVXRpbC5pc0xvbmcodmFsdWUpKSB7XG4gICAgICByZXR1cm4gTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKHZhbHVlIGFzIExvbmcgfCBmbGF0YnVmZmVycy5Mb25nKTtcbiAgICB9XG5cbiAgICAvLyBjYXN0IExPTkdbXSB0byBudW1iZXJbXVxuICAgIGlmIChhdHRyVHlwZSA9PT0gb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVFMpIHtcbiAgICAgIGNvbnN0IGFyciA9ICh2YWx1ZSBhcyBBcnJheTxudW1iZXJ8TG9uZ3xmbGF0YnVmZmVycy5Mb25nPik7XG4gICAgICBjb25zdCBudW1iZXJWYWx1ZTogbnVtYmVyW10gPSBuZXcgQXJyYXk8bnVtYmVyPihhcnIubGVuZ3RoKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbWF5YmVMb25nID0gYXJyW2ldO1xuICAgICAgICBudW1iZXJWYWx1ZVtpXSA9IExvbmdVdGlsLmxvbmdUb051bWJlcihtYXliZUxvbmcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVtYmVyVmFsdWU7XG4gICAgfVxuXG4gICAgLy8gY2FzdCBvbm54LlRlbnNvclByb3RvIHRvIG9ubnhqcy5UZW5zb3JcbiAgICBpZiAoYXR0clR5cGUgPT09IG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5URU5TT1IpIHtcbiAgICAgIHJldHVybiBhdHRyIGluc3RhbmNlb2Ygb25ueC5BdHRyaWJ1dGVQcm90byA/IFRlbnNvci5mcm9tUHJvdG8odmFsdWUgYXMgb25ueC5JVGVuc29yUHJvdG8pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRlbnNvci5mcm9tT3J0VGVuc29yKHZhbHVlIGFzIG9ydEZicy5UZW5zb3IpO1xuICAgIH1cblxuICAgIC8vIGNhc3Qgb25ueC5UZW5zb3JQcm90b1tdIHRvIG9ubnhqcy5UZW5zb3JbXVxuICAgIGlmIChhdHRyVHlwZSA9PT0gb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUlMpIHtcbiAgICAgIGlmIChhdHRyIGluc3RhbmNlb2Ygb25ueC5BdHRyaWJ1dGVQcm90bykge1xuICAgICAgICBjb25zdCB0ZW5zb3JQcm90b3MgPSB2YWx1ZSBhcyBvbm54LklUZW5zb3JQcm90b1tdO1xuICAgICAgICByZXR1cm4gdGVuc29yUHJvdG9zLm1hcCh2YWx1ZSA9PiBUZW5zb3IuZnJvbVByb3RvKHZhbHVlKSk7XG4gICAgICB9IGVsc2UgaWYgKGF0dHIgaW5zdGFuY2VvZiBvcnRGYnMuQXR0cmlidXRlKSB7XG4gICAgICAgIGNvbnN0IHRlbnNvclByb3RvcyA9IHZhbHVlIGFzIG9ydEZicy5UZW5zb3JbXTtcbiAgICAgICAgcmV0dXJuIHRlbnNvclByb3Rvcy5tYXAodmFsdWUgPT4gVGVuc29yLmZyb21PcnRUZW5zb3IodmFsdWUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjYXN0IFVpbnQ4QXJyYXkgdG8gc3RyaW5nXG4gICAgaWYgKGF0dHJUeXBlID09PSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuU1RSSU5HKSB7XG4gICAgICAvLyBzdHJpbmcgaW4gb25ueCBhdHRyaWJ1dGUgaXMgb2YgdWludDhhcnJheSB0eXBlLCBzbyB3ZSBuZWVkIHRvIGNvbnZlcnQgaXQgdG8gc3RyaW5nIGJlbG93LiBXaGlsZSBpbiBvcnQgZm9ybWF0LFxuICAgICAgLy8gc3RyaW5nIGF0dHJpYnV0ZXMgYXJlIHJldHVybmVkIGFzIHN0cmluZywgc28gbm8gY29udmVyc2lvbiBpcyBuZWVkZWQuXG4gICAgICBpZiAoYXR0ciBpbnN0YW5jZW9mIG9ubnguQXR0cmlidXRlUHJvdG8pIHtcbiAgICAgICAgY29uc3QgdXRmOFN0cmluZyA9IHZhbHVlIGFzIFVpbnQ4QXJyYXk7XG4gICAgICAgIHJldHVybiBkZWNvZGVVdGY4U3RyaW5nKHV0ZjhTdHJpbmcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNhc3QgVWludDhBcnJheVtdIHRvIHN0cmluZ1tdXG4gICAgaWYgKGF0dHJUeXBlID09PSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuU1RSSU5HUykge1xuICAgICAgLy8gc3RyaW5ncyBpbiBvbm54IGF0dHJpYnV0ZSBpcyByZXR1cm5lZCBhcyB1aW50OGFycmF5W10sIHNvIHdlIG5lZWQgdG8gY29udmVydCBpdCB0byBzdHJpbmdbXSBiZWxvdy4gV2hpbGUgaW4gb3J0XG4gICAgICAvLyBmb3JtYXQgc3RyaW5ncyBhdHRyaWJ1dGVzIGFyZSByZXR1cm5lZCBhcyBzdHJpbmdbXSwgc28gbm8gY29udmVyc2lvbiBpcyBuZWVkZWQuXG4gICAgICBpZiAoYXR0ciBpbnN0YW5jZW9mIG9ubnguQXR0cmlidXRlUHJvdG8pIHtcbiAgICAgICAgY29uc3QgdXRmOFN0cmluZ3MgPSB2YWx1ZSBhcyBVaW50OEFycmF5W107XG4gICAgICAgIHJldHVybiB1dGY4U3RyaW5ncy5tYXAoZGVjb2RlVXRmOFN0cmluZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlIGFzIFZhbHVlVHlwZXM7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZXRWYWx1ZU5vQ2hlY2soYXR0cjogb25ueC5JQXR0cmlidXRlUHJvdG98b3J0RmJzLkF0dHJpYnV0ZSkge1xuICAgIHJldHVybiBhdHRyIGluc3RhbmNlb2YgKG9ubnguQXR0cmlidXRlUHJvdG8pID8gdGhpcy5nZXRWYWx1ZU5vQ2hlY2tGcm9tT25ueEZvcm1hdChhdHRyKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFZhbHVlTm9DaGVja0Zyb21PcnRGb3JtYXQoYXR0ciBhcyBvcnRGYnMuQXR0cmlidXRlKTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGdldFZhbHVlTm9DaGVja0Zyb21Pbm54Rm9ybWF0KGF0dHI6IG9ubnguSUF0dHJpYnV0ZVByb3RvKSB7XG4gICAgc3dpdGNoIChhdHRyLnR5cGUhKSB7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5GTE9BVDpcbiAgICAgICAgcmV0dXJuIGF0dHIuZjtcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLklOVDpcbiAgICAgICAgcmV0dXJuIGF0dHIuaTtcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlNUUklORzpcbiAgICAgICAgcmV0dXJuIGF0dHIucztcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUjpcbiAgICAgICAgcmV0dXJuIGF0dHIudDtcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLkdSQVBIOlxuICAgICAgICByZXR1cm4gYXR0ci5nO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuRkxPQVRTOlxuICAgICAgICByZXR1cm4gYXR0ci5mbG9hdHM7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5JTlRTOlxuICAgICAgICByZXR1cm4gYXR0ci5pbnRzO1xuICAgICAgY2FzZSBvbm54LkF0dHJpYnV0ZVByb3RvLkF0dHJpYnV0ZVR5cGUuU1RSSU5HUzpcbiAgICAgICAgcmV0dXJuIGF0dHIuc3RyaW5ncztcbiAgICAgIGNhc2Ugb25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlLlRFTlNPUlM6XG4gICAgICAgIHJldHVybiBhdHRyLnRlbnNvcnM7XG4gICAgICBjYXNlIG9ubnguQXR0cmlidXRlUHJvdG8uQXR0cmlidXRlVHlwZS5HUkFQSFM6XG4gICAgICAgIHJldHVybiBhdHRyLmdyYXBocztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgYXR0cmlidXRlIHR5cGU6ICR7b25ueC5BdHRyaWJ1dGVQcm90by5BdHRyaWJ1dGVUeXBlW2F0dHIudHlwZSFdfWApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGdldFZhbHVlTm9DaGVja0Zyb21PcnRGb3JtYXQoYXR0cjogb3J0RmJzLkF0dHJpYnV0ZSkge1xuICAgIHN3aXRjaCAoYXR0ci50eXBlKCkpIHtcbiAgICAgIGNhc2Ugb3J0RmJzLkF0dHJpYnV0ZVR5cGUuRkxPQVQ6XG4gICAgICAgIHJldHVybiBhdHRyLmYoKTtcbiAgICAgIGNhc2Ugb3J0RmJzLkF0dHJpYnV0ZVR5cGUuSU5UOlxuICAgICAgICByZXR1cm4gYXR0ci5pKCk7XG4gICAgICBjYXNlIG9ydEZicy5BdHRyaWJ1dGVUeXBlLlNUUklORzpcbiAgICAgICAgcmV0dXJuIGF0dHIucygpO1xuICAgICAgY2FzZSBvcnRGYnMuQXR0cmlidXRlVHlwZS5URU5TT1I6XG4gICAgICAgIHJldHVybiBhdHRyLnQoKTtcbiAgICAgIGNhc2Ugb3J0RmJzLkF0dHJpYnV0ZVR5cGUuR1JBUEg6XG4gICAgICAgIHJldHVybiBhdHRyLmcoKTtcbiAgICAgIGNhc2Ugb3J0RmJzLkF0dHJpYnV0ZVR5cGUuRkxPQVRTOlxuICAgICAgICByZXR1cm4gYXR0ci5mbG9hdHNBcnJheSgpO1xuICAgICAgY2FzZSBvcnRGYnMuQXR0cmlidXRlVHlwZS5JTlRTOiB7XG4gICAgICAgIGNvbnN0IGludHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyLmludHNMZW5ndGgoKTsgaSsrKSB7XG4gICAgICAgICAgaW50cy5wdXNoKGF0dHIuaW50cyhpKSEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRzO1xuICAgICAgfVxuICAgICAgY2FzZSBvcnRGYnMuQXR0cmlidXRlVHlwZS5TVFJJTkdTOiB7XG4gICAgICAgIGNvbnN0IHN0cmluZ3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyLnN0cmluZ3NMZW5ndGgoKTsgaSsrKSB7XG4gICAgICAgICAgc3RyaW5ncy5wdXNoKGF0dHIuc3RyaW5ncyhpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ3M7XG4gICAgICB9XG4gICAgICBjYXNlIG9ydEZicy5BdHRyaWJ1dGVUeXBlLlRFTlNPUlM6IHtcbiAgICAgICAgY29uc3QgdGVuc29ycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHIudGVuc29yc0xlbmd0aCgpOyBpKyspIHtcbiAgICAgICAgICB0ZW5zb3JzLnB1c2goYXR0ci50ZW5zb3JzKGkpISk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcnM7XG4gICAgICB9XG4gICAgICAvLyBjYXNlIG9ydEZicy5BdHRyaWJ1dGVUeXBlLkdSQVBIUzpcbiAgICAgIC8vIFRPRE86IFN1YmdyYXBoIG5vdCBzdXBwb3J0ZWQgeWV0LlxuICAgICAgLy8gY29uc3QgZ3JhcGhzID0gW107XG4gICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHIuZ3JhcGhzTGVuZ3RoKCk7IGkrKykge1xuICAgICAgLy8gICBncmFwaHMucHVzaChhdHRyLmdyYXBocyhpKSEpO1xuICAgICAgLy8gfVxuICAgICAgLy8gcmV0dXJuIGdyYXBocztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgYXR0cmlidXRlIHR5cGU6ICR7b3J0RmJzLkF0dHJpYnV0ZVR5cGVbYXR0ci50eXBlKCldfWApO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfYXR0cmlidXRlczogTWFwPHN0cmluZywgVmFsdWU+O1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0F0dHJpYnV0ZX0gZnJvbSAnLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtvbm54cnVudGltZX0gZnJvbSAnLi9vcnQtc2NoZW1hL2ZsYXRidWZmZXJzL29ydC1nZW5lcmF0ZWQnO1xuaW1wb3J0IHtvbm54fSBmcm9tICcuL29ydC1zY2hlbWEvcHJvdG9idWYvb25ueCc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi90ZW5zb3InO1xuaW1wb3J0IHtMb25nVXRpbCwgTUFYX0NMSVAsIE1JTl9DTElQLCBQcm90b1V0aWx9IGZyb20gJy4vdXRpbCc7XG5cbmltcG9ydCBvcnRGYnMgPSBvbm54cnVudGltZS5leHBlcmltZW50YWwuZmJzO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgR3JhcGgge1xuICBleHBvcnQgaW50ZXJmYWNlIFNoYXBlIHtcbiAgICByZWFkb25seSBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFZhbHVlVHlwZSB7XG4gICAgcmVhZG9ubHkgdGVuc29yVHlwZTogVGVuc29yLkRhdGFUeXBlO1xuICAgIHJlYWRvbmx5IHNoYXBlOiBTaGFwZTtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFZhbHVlIHtcbiAgICAvLyB0aGUgdGVuc29yIGRhdGEuIGVtcHR5IGZvciBub24taW5pdGlhbGl6ZWQgaW5wdXRzXG4gICAgcmVhZG9ubHkgdGVuc29yPzogVGVuc29yO1xuXG4gICAgLy8gaW5kZXggdG8gdGhlIE5vZGUgd2hlcmUgdGhlIHZhbHVlIGNvbWVzIGZyb20uIC0xIGZvciBpbml0aWFsaXplci5cbiAgICByZWFkb25seSBmcm9tOiBudW1iZXI7XG5cbiAgICAvLyBpbmRpY2VzIHRvIHRoZSBOb2RlcyB3aGVyZSB0aGUgdmFsdWVzIGdvIHRvLlxuICAgIHJlYWRvbmx5IHRvOiByZWFkb25seSBudW1iZXJbXTtcblxuICAgIC8vIHZhbHVlIHR5cGUgc3BlY2lmaWNhdGlvbi4gZW1wdHkgZm9yIG5vbi1pbnB1dCB2YWx1ZXMuXG4gICAgcmVhZG9ubHkgdHlwZT86IFZhbHVlVHlwZTtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIE5vZGUge1xuICAgIC8vIG5hbWUgb2YgdGhlIG5vZGVcbiAgICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG5cbiAgICAvLyB0aGUgb3BlcmF0b3IgdHlwZVxuICAgIHJlYWRvbmx5IG9wVHlwZTogc3RyaW5nO1xuXG4gICAgLy8gaW5kaWNlcyB0byB0aGUgVmFsdWVzIHdoZXJlIHRoZSBpbnB1dHMgY29tZSBmcm9tLlxuICAgIHJlYWRvbmx5IGlucHV0czogcmVhZG9ubHkgbnVtYmVyW107XG5cbiAgICAvLyBpbmRpY2VzIHRvIHRoZSBWYWx1ZXMgd2hlcmUgdGhlIG91dHB1cyBnbyB0by5cbiAgICByZWFkb25seSBvdXRwdXRzOiByZWFkb25seSBudW1iZXJbXTtcblxuICAgIC8vIHRoZSBhdHRyaWJ1dGVzIHRoYXQgdXNlZCBieSB0aGUgb3BlcmF0b3JcbiAgICByZWFkb25seSBhdHRyaWJ1dGVzOiBBdHRyaWJ1dGU7XG4gIH1cblxuICAvKipcbiAgICogYSBUcmFuc2Zvcm1lciBpcyBhbiBpbnN0YW5jZSB0aGF0IGFsbG93cyBhbGwgcG9zc2libGUgdHJhbnNmb3JtYXRpb24gb3BlcmF0aW9ucyB0aGF0IGFwcGxpZWQgdG8gYSBncmFwaFxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBUcmFuc2Zvcm1lciB7XG4gICAgcmVtb3ZlQWxsSWRlbnRpdHlOb2RlcygpOiB2b2lkO1xuICAgIHJlbW92ZUFsbERyb3BvdXROb2RlcygpOiB2b2lkO1xuICAgIGZ1c2VDb252QWN0aXZhdGlvbk5vZGVzKCk6IHZvaWQ7XG4gICAgLy8gVE9ETzogYWRkIGdlbmVyaWMgZnVuY3Rpb25zIHRvIG1hbmlwdWxhdGUgdGhlIGdyYXBoXG4gIH1cblxuICAvLyBhbiBpbml0aWFsaXplciBjYW4gdXNlIHRyYW5zZm9ybWVyIHRvIHRyYW5zZm9ybSB0aGUgZ3JhcGhcbiAgZXhwb3J0IGludGVyZmFjZSBJbml0aWFsaXplciB7XG4gICAgdHJhbnNmb3JtR3JhcGgodHJhbnNmb3JtZXI6IFRyYW5zZm9ybWVyKTogdm9pZDtcbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZGVjbGFyZVxuZXhwb3J0IGludGVyZmFjZSBHcmFwaCB7XG4gIGdldElucHV0SW5kaWNlcygpOiByZWFkb25seSBudW1iZXJbXTtcbiAgZ2V0SW5wdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXTtcbiAgZ2V0T3V0cHV0SW5kaWNlcygpOiByZWFkb25seSBudW1iZXJbXTtcbiAgZ2V0T3V0cHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW107XG4gIGdldFZhbHVlcygpOiByZWFkb25seSBHcmFwaC5WYWx1ZVtdO1xuICBnZXROb2RlcygpOiByZWFkb25seSBHcmFwaC5Ob2RlW107XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWRlY2xhcmVcbmV4cG9ydCBjb25zdCBHcmFwaCA9IHtcbiAgLyoqXG4gICAqIGNvbnN0cnVjdCBhIGdyYXBoIGZyb20gYSBncmFwaCBwcm90b2J1ZiB0eXBlXG4gICAqL1xuICBmcm9tOiAoZ3JhcGhQcm90bzogb25ueC5JR3JhcGhQcm90b3xvcnRGYnMuR3JhcGgsIGluaXRpYWxpemVyPzogR3JhcGguSW5pdGlhbGl6ZXIpID0+XG4gICAgICBuZXcgR3JhcGhJbXBsKGdyYXBoUHJvdG8sIGluaXRpYWxpemVyKSxcbn07XG5cbmNsYXNzIFZhbHVlIGltcGxlbWVudHMgR3JhcGguVmFsdWUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZUluZm8/OiBvbm54LklWYWx1ZUluZm9Qcm90bykge1xuICAgIHRoaXMuX2Zyb20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdG8gPSBbXTtcbiAgICB0aGlzLnRlbnNvciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnR5cGUgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAodmFsdWVJbmZvKSB7XG4gICAgICB0aGlzLnR5cGUgPSBQcm90b1V0aWwudGVuc29yVmFsdWVUeXBlRnJvbVByb3RvKHZhbHVlSW5mby50eXBlIS50ZW5zb3JUeXBlISk7XG4gICAgfVxuICB9XG5cbiAgX2Zyb20/OiBudW1iZXI7ICAvLyAtMSByZXByZXNlbnQgZnJvbSBpbml0aWFsaXplclxuICBnZXQgZnJvbSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnJvbSE7XG4gIH1cbiAgX3RvOiBudW1iZXJbXTtcbiAgZ2V0IHRvKCkge1xuICAgIHJldHVybiB0aGlzLl90bztcbiAgfVxuICB0eXBlPzogR3JhcGguVmFsdWVUeXBlO1xuICB0ZW5zb3I/OiBUZW5zb3I7XG59XG5cbmNsYXNzIE5vZGUgaW1wbGVtZW50cyBHcmFwaC5Ob2RlIHtcbiAgY29uc3RydWN0b3IoX25vZGVQcm90bzogb25ueC5JTm9kZVByb3RvfG9ydEZicy5Ob2RlLCBuYW1lPzogc3RyaW5nKSB7XG4gICAgaWYgKF9ub2RlUHJvdG8gaW5zdGFuY2VvZiBvbm54Lk5vZGVQcm90bykge1xuICAgICAgdGhpcy5uYW1lID0gX25vZGVQcm90by5uYW1lO1xuICAgICAgdGhpcy5vcFR5cGUgPSBfbm9kZVByb3RvLm9wVHlwZTtcbiAgICAgIHRoaXMuYXR0cmlidXRlcyA9IG5ldyBBdHRyaWJ1dGUoX25vZGVQcm90by5hdHRyaWJ1dGUpO1xuICAgIH0gZWxzZSBpZiAoX25vZGVQcm90byBpbnN0YW5jZW9mIG9ydEZicy5Ob2RlKSB7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lID8/IF9ub2RlUHJvdG8ubmFtZSgpITtcbiAgICAgIHRoaXMub3BUeXBlID0gX25vZGVQcm90by5vcFR5cGUoKSE7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBuZXcgQXR0cmlidXRlKFByb3RvVXRpbC50ZW5zb3JBdHRyaWJ1dGVzRnJvbU9SVEZvcm1hdChfbm9kZVByb3RvKSk7XG4gICAgfVxuXG4gICAgdGhpcy5pbnB1dHMgPSBbXTtcbiAgICB0aGlzLm91dHB1dHMgPSBbXTtcbiAgICB0aGlzLmV4ZWN1dGVOb2RlID0gdHJ1ZTtcbiAgfVxuXG4gIG5hbWU6IHN0cmluZztcbiAgb3BUeXBlOiBzdHJpbmc7XG4gIGlucHV0czogbnVtYmVyW107XG4gIG91dHB1dHM6IG51bWJlcltdO1xuICBhdHRyaWJ1dGVzOiBBdHRyaWJ1dGU7XG4gIGV4ZWN1dGVOb2RlOiBib29sZWFuO1xufVxuXG5jbGFzcyBHcmFwaEltcGwgaW1wbGVtZW50cyBHcmFwaCwgR3JhcGguVHJhbnNmb3JtZXIge1xuICBwcml2YXRlIF9hbGxEYXRhOiBWYWx1ZVtdO1xuXG4gIHByaXZhdGUgX2FsbElucHV0SW5kaWNlczogbnVtYmVyW107XG4gIHByaXZhdGUgX2FsbElucHV0TmFtZXM6IHN0cmluZ1tdO1xuXG4gIHByaXZhdGUgX2FsbE91dHB1dEluZGljZXM6IG51bWJlcltdO1xuICBwcml2YXRlIF9hbGxPdXRwdXROYW1lczogc3RyaW5nW107XG5cbiAgcHJpdmF0ZSBfbm9kZXM6IE5vZGVbXTtcblxuICBjb25zdHJ1Y3RvcihncmFwaDogb25ueC5JR3JhcGhQcm90b3xvcnRGYnMuR3JhcGgsIGdyYXBoSW5pdGlhbGl6ZXI/OiBHcmFwaC5Jbml0aWFsaXplcikge1xuICAgIGlmICghZ3JhcGgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dyYXBoIGlzIGVtcHR5Jyk7XG4gICAgfVxuXG4gICAgLy8gYnVpbGQgdGhlIGdyYXBoIC0gd2lsbCB0aHJvdyBleGNlcHRpb25zIGlmIHNvbWV0aGluZyBmYXRhbCBpcyBkZXRlY3RlZFxuICAgIHRoaXMuYnVpbGRHcmFwaChncmFwaCk7XG5cbiAgICAvLyBleGVjdXRlIGFueSB0cmFuc2Zvcm1hdGlvbiBsb2dpYyBmb3IgdGhlIGdyYXBoIChpZiBhcHBsaWNhYmxlKVxuICAgIHRoaXMudHJhbnNmb3JtR3JhcGgoZ3JhcGhJbml0aWFsaXplcik7XG5cbiAgICAvLyBjaGVjayBmb3IgY3ljbGVzIGFuZCBvdGhlciBpbmNvbnNpc3RlbmNpZXMgLSB3aWxsIHRocm93IGV4Y2VwdGlvbnMgaWYgc29tZXRoaW5nIGZhdGFsIGlzIGRldGVjdGVkXG4gICAgdGhpcy5jaGVja0lzQWN5Y2xpYygpO1xuICB9XG5cbiAgZ2V0SW5wdXRJbmRpY2VzKCk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICByZXR1cm4gdGhpcy5fYWxsSW5wdXRJbmRpY2VzO1xuICB9XG5cbiAgZ2V0SW5wdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2FsbElucHV0TmFtZXM7XG4gIH1cblxuICBnZXRPdXRwdXRJbmRpY2VzKCk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICByZXR1cm4gdGhpcy5fYWxsT3V0cHV0SW5kaWNlcztcbiAgfVxuXG4gIGdldE91dHB1dE5hbWVzKCk6IHJlYWRvbmx5IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5fYWxsT3V0cHV0TmFtZXM7XG4gIH1cblxuICBnZXRWYWx1ZXMoKTogcmVhZG9ubHkgR3JhcGguVmFsdWVbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2FsbERhdGE7XG4gIH1cblxuICBnZXROb2RlcygpOiByZWFkb25seSBHcmFwaC5Ob2RlW10ge1xuICAgIHJldHVybiB0aGlzLl9ub2RlcztcbiAgfVxuXG4gIHByaXZhdGUgYnVpbGRHcmFwaChncmFwaDogb25ueC5JR3JhcGhQcm90b3xvcnRGYnMuR3JhcGgpIHtcbiAgICAvLyBidWlsZCB0aGUgZ3JhcGggLSB3aWxsIHRocm93IGV4Y2VwdGlvbnMgaWYgc29tZXRoaW5nIGZhdGFsIGlzIGRldGVjdGVkXG4gICAgaWYgKGdyYXBoIGluc3RhbmNlb2Ygb25ueC5HcmFwaFByb3RvKSB7XG4gICAgICB0aGlzLmJ1aWxkR3JhcGhGcm9tT25ueEZvcm1hdChncmFwaCk7XG4gICAgfSBlbHNlIGlmIChncmFwaCBpbnN0YW5jZW9mIG9ydEZicy5HcmFwaCkge1xuICAgICAgdGhpcy5idWlsZEdyYXBoRnJvbU9ydEZvcm1hdChncmFwaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dyYXBoIHR5cGUgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gIH1cbiAgcHJpdmF0ZSBidWlsZEdyYXBoRnJvbU9ubnhGb3JtYXQoZ3JhcGg6IG9ubnguSUdyYXBoUHJvdG8pIHtcbiAgICBjb25zdCBkYXRhSW5kaWNlcyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG4gICAgdGhpcy5fYWxsRGF0YSA9IFtdO1xuXG4gICAgdGhpcy5fYWxsSW5wdXRJbmRpY2VzID0gW107XG4gICAgdGhpcy5fYWxsSW5wdXROYW1lcyA9IFtdO1xuXG4gICAgdGhpcy5fYWxsT3V0cHV0SW5kaWNlcyA9IFtdO1xuICAgIHRoaXMuX2FsbE91dHB1dE5hbWVzID0gW107XG5cbiAgICB0aGlzLl9ub2RlcyA9IFtdO1xuXG4gICAgY29uc3Qgbm9kZXNJbmRpY2VzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcblxuICAgIC8vIHNjYW4gYWxsIGlucHV0c1xuICAgIGlmICghZ3JhcGguaW5wdXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBpbmZvcm1hdGlvbiBpbiBncmFwaDogaW5wdXQnKTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRWYWx1ZU5hbWVzID0gW107XG4gICAgZm9yIChjb25zdCBpIG9mIGdyYXBoLmlucHV0KSB7XG4gICAgICBpZiAoZGF0YUluZGljZXMuaGFzKGkubmFtZSEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlZCBpbnB1dCBuYW1lOiAke2kubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuX2FsbERhdGEucHVzaChuZXcgVmFsdWUoaSkpIC0gMTtcbiAgICAgIGRhdGFJbmRpY2VzLnNldChpLm5hbWUhLCBjdXJyZW50SW5kZXgpO1xuICAgICAgaW5wdXRWYWx1ZU5hbWVzLnB1c2goaS5uYW1lISk7XG4gICAgfVxuXG4gICAgLy8gc2NhbiBhbGwgaW5pdGlhbGl6ZXJzXG4gICAgaWYgKCFncmFwaC5pbml0aWFsaXplcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGluZm9ybWF0aW9uIGluIGdyYXBoOiBpbml0aWFsaXplcicpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGkgb2YgZ3JhcGguaW5pdGlhbGl6ZXIpIHtcbiAgICAgIGxldCBpbmRleCA9IGRhdGFJbmRpY2VzLmdldChpLm5hbWUhKTtcbiAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IFZhbHVlKCk7XG4gICAgICAgIHZhbHVlLnR5cGUgPSB7XG4gICAgICAgICAgc2hhcGU6IHtkaW1zOiBQcm90b1V0aWwudGVuc29yRGltc0Zyb21Qcm90byhpLmRpbXMhKX0sXG4gICAgICAgICAgdGVuc29yVHlwZTogUHJvdG9VdGlsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKGkuZGF0YVR5cGUhKVxuICAgICAgICB9O1xuICAgICAgICBpbmRleCA9IHRoaXMuX2FsbERhdGEucHVzaCh2YWx1ZSkgLSAxO1xuICAgICAgICBkYXRhSW5kaWNlcy5zZXQoaS5uYW1lISwgaW5kZXgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWxsRGF0YVtpbmRleF0uX2Zyb20gPSAtMTtcbiAgICAgIHRoaXMuX2FsbERhdGFbaW5kZXhdLnRlbnNvciA9IFRlbnNvci5mcm9tUHJvdG8oaSk7XG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCBpbnB1dCBpbmRpY2VzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hbGxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMuX2FsbERhdGFbaV0udGVuc29yKSB7XG4gICAgICAgIHRoaXMuX2FsbElucHV0SW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICB0aGlzLl9hbGxJbnB1dE5hbWVzLnB1c2goaW5wdXRWYWx1ZU5hbWVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzY2FuIGFsbCBvdXRwdXRzXG4gICAgaWYgKCFncmFwaC5vdXRwdXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBpbmZvcm1hdGlvbiBpbiBncmFwaDogb3V0cHV0Jyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaSBvZiBncmFwaC5vdXRwdXQpIHtcbiAgICAgIGlmIChkYXRhSW5kaWNlcy5oYXMoaS5uYW1lISkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG91dHB1dCBuYW1lOiAke2kubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuX2FsbERhdGEucHVzaChuZXcgVmFsdWUoaSkpIC0gMTtcbiAgICAgIGRhdGFJbmRpY2VzLnNldChpLm5hbWUhLCBjdXJyZW50SW5kZXgpO1xuICAgICAgdGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5wdXNoKGN1cnJlbnRJbmRleCk7XG4gICAgICB0aGlzLl9hbGxPdXRwdXROYW1lcy5wdXNoKGkubmFtZSEpO1xuICAgIH1cblxuICAgIC8vIHNjYW4gYWxsIG5vZGVzXG4gICAgaWYgKCFncmFwaC5ub2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgaW5mb3JtYXRpb24gaW4gZ3JhcGg6IG5vZGUnKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBub2RlUHJvdG8gb2YgZ3JhcGgubm9kZSkge1xuICAgICAgaWYgKCFub2RlUHJvdG8ubmFtZSkge1xuICAgICAgICAvLyBhc3NpZ24gYSBuYW1lIHRvIHRoZSBub2RlIGlmIGl0IGRvZXNuJ3QgaGF2ZSBvbmVcbiAgICAgICAgZm9yIChsZXQgcGljayA9IDA7OyBwaWNrKyspIHtcbiAgICAgICAgICBjb25zdCBuYW1lID0gYHVubmFtZWRfJHtub2RlUHJvdG8ub3BUeXBlfV8ke3BpY2t9YDtcbiAgICAgICAgICBpZiAoIW5vZGVzSW5kaWNlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIG5vZGVQcm90by5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobm9kZXNJbmRpY2VzLmhhcyhub2RlUHJvdG8ubmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG5vZGUgbmFtZTogJHtub2RlUHJvdG8ubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuX25vZGVzLnB1c2gobmV3IE5vZGUobm9kZVByb3RvKSkgLSAxO1xuICAgICAgbm9kZXNJbmRpY2VzLnNldChub2RlUHJvdG8ubmFtZSwgY3VycmVudEluZGV4KTtcbiAgICB9XG5cbiAgICAvLyBzY2FuIG5vZGUncyBvdXRwdXRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX25vZGVzW2ldO1xuICAgICAgY29uc3Qgbm9kZVByb3RvID0gZ3JhcGgubm9kZVtpXTtcbiAgICAgIGlmICghbm9kZVByb3RvLm91dHB1dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3Npbmcgb3V0cHV0IGZvciBub2RlOiAke25vZGVQcm90by5uYW1lfWApO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBvdXRwdXQgb2Ygbm9kZVByb3RvLm91dHB1dCkge1xuICAgICAgICBsZXQgZGF0YUluZGV4ID0gZGF0YUluZGljZXMuZ2V0KG91dHB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YUluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGRhdGFJbmRleCA9IHRoaXMuX2FsbERhdGEucHVzaChuZXcgVmFsdWUoKSkgLSAxO1xuICAgICAgICAgIGRhdGFJbmRpY2VzLnNldChvdXRwdXQsIGRhdGFJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5vdXRwdXRzLnB1c2goZGF0YUluZGV4KTtcblxuICAgICAgICBpZiAodGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLl9mcm9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG11bHRpcGxlIG5vZGVzIG91dHB1dCB0byBvbmUgZGF0YSB2YWx1ZTogJHtkYXRhSW5kZXh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLl9mcm9tID0gaTtcblxuICAgICAgICAvLyBmb3IgdGhlICdDb25zdGFudCcgb3BlcmF0b3IsIGp1c3QgY3JlYXRlIGEgbmV3IGVkZ2UgaW4gdGhlIGdyYXBoIGNvcnJlc3BvbmRpbmcgdG8gdGhlICdvdXRwdXQnIG9mIHRoZVxuICAgICAgICAvLyBvcGVyYXRvciBhbmQgaWdub3JlIHRoZSBub2RlIGZyb20gdGhlIGdyYXBoXG4gICAgICAgIGlmIChub2RlUHJvdG8ub3BUeXBlID09PSAnQ29uc3RhbnQnKSB7XG4gICAgICAgICAgaWYgKCFub2RlUHJvdG8uYXR0cmlidXRlIHx8IG5vZGVQcm90by5hdHRyaWJ1dGUubGVuZ3RoICE9PSAxIHx8ICFub2RlUHJvdG8uYXR0cmlidXRlWzBdLnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBhdHRyaWJ1dGVzIG9yIG1pc3NpbmcgdGVuc29yIHZhbHVlIGluIGF0dHJpYnV0ZXMgZm9yIHRoaXMgQ29uc3RhbnQgb3BlcmF0b3InKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFub2RlUHJvdG8ub3V0cHV0IHx8IG5vZGVQcm90by5vdXRwdXQubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3Npbmcgb3V0cHV0IG9yIGluY29ycmVjdCBudW1iZXIgb2Ygb3V0cHV0cyBmb3IgdGhpcyBDb25zdGFudCBvcGVyYXRvcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLm91dHB1dHMucG9wKCk7XG4gICAgICAgICAgbm9kZS5leGVjdXRlTm9kZSA9IGZhbHNlO1xuXG4gICAgICAgICAgdGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLl9mcm9tID0gLTE7XG4gICAgICAgICAgdGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLnRlbnNvciA9IFRlbnNvci5mcm9tUHJvdG8obm9kZVByb3RvLmF0dHJpYnV0ZVswXS50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNjYW4gbm9kZSdzIGlucHV0c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9ub2Rlc1tpXTtcbiAgICAgIGNvbnN0IG5vZGVQcm90byA9IGdyYXBoLm5vZGVbaV07XG5cbiAgICAgIGlmICghbm9kZVByb3RvLmlucHV0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyBpbnB1dCBmb3Igbm9kZTogJHtub2RlUHJvdG8ubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgaW5wdXQgb2Ygbm9kZVByb3RvLmlucHV0KSB7XG4gICAgICAgIGNvbnN0IGRhdGFJbmRleCA9IGRhdGFJbmRpY2VzLmdldChpbnB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YUluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIGhhbmRsZSBleGNlcHRpb24gd2hlbiBvcHNldCA+IDkgYW5kIHJvaSAvIHNjYWxlcyBub3QgZ2l2ZW5cbiAgICAgICAgICBpZiAoaW5wdXQgPT09ICcnICYmIChub2RlUHJvdG8uaW5wdXQubGVuZ3RoID09PSAzIHx8IG5vZGVQcm90by5pbnB1dC5sZW5ndGggPT09IDQpICYmXG4gICAgICAgICAgICAgIG5vZGVQcm90by5vcFR5cGUgPT09ICdSZXNpemUnKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnJlY29nbml6ZWQgaW5wdXQgJyR7aW5wdXR9JyBmb3Igbm9kZTogJHtub2RlUHJvdG8ubmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLmlucHV0cy5wdXNoKGRhdGFJbmRleCk7XG5cbiAgICAgICAgdGhpcy5fYWxsRGF0YVtkYXRhSW5kZXhdLl90by5wdXNoKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJpdmF0ZSBidWlsZEdyYXBoRnJvbU9ydEZvcm1hdChncmFwaDogb3J0RmJzLkdyYXBoKSB7XG4gICAgY29uc3QgZGF0YUluZGljZXMgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuICAgIHRoaXMuX2FsbERhdGEgPSBbXTtcblxuICAgIHRoaXMuX2FsbElucHV0SW5kaWNlcyA9IFtdO1xuICAgIHRoaXMuX2FsbElucHV0TmFtZXMgPSBbXTtcblxuICAgIHRoaXMuX2FsbE91dHB1dEluZGljZXMgPSBbXTtcbiAgICB0aGlzLl9hbGxPdXRwdXROYW1lcyA9IFtdO1xuXG4gICAgdGhpcy5fbm9kZXMgPSBbXTtcblxuICAgIGNvbnN0IG5vZGVzSW5kaWNlcyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG5cbiAgICAvLyBzY2FuIGFsbCBpbnB1dHNcbiAgICBjb25zdCBpbnB1dFZhbHVlTmFtZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyYXBoLmlucHV0c0xlbmd0aCgpOyBpKyspIHtcbiAgICAgIGNvbnN0IGlucHV0TmFtZSA9IGdyYXBoLmlucHV0cyhpKTtcbiAgICAgIGlmIChkYXRhSW5kaWNlcy5oYXMoaW5wdXROYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGR1cGxpY2F0ZWQgaW5wdXQgbmFtZTogJHtpbnB1dE5hbWV9YCk7XG4gICAgICB9XG4gICAgICAvLyBGaW5kIHRoZSBpbnB1dCB0eXBlSW5mbyBmcm9tIG5vZGVhcmdzXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGdyYXBoLm5vZGVBcmdzTGVuZ3RoKCk7IGorKykge1xuICAgICAgICBpZiAoZ3JhcGgubm9kZUFyZ3Moaik/Lm5hbWUoKSA9PT0gaW5wdXROYW1lKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBuZXcgVmFsdWUoKTtcbiAgICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSBncmFwaC5ub2RlQXJncyhqKT8udHlwZSgpPy52YWx1ZVR5cGUoKTtcbiAgICAgICAgICBpZiAodmFsdWVUeXBlICE9PSBvcnRGYnMuVHlwZUluZm9WYWx1ZS50ZW5zb3JfdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHZhbHVlIHR5cGUgZm9yIHRoZSBub2RlQXJnLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB2YWx1ZUluZm8gPSBncmFwaC5ub2RlQXJncyhqKSEudHlwZSgpIS52YWx1ZShuZXcgb3J0RmJzLlRlbnNvclR5cGVBbmRTaGFwZSgpKSE7XG4gICAgICAgICAgY29uc3QgdHlwZSA9IFByb3RvVXRpbC50ZW5zb3JEYXRhVHlwZUZyb21Qcm90byh2YWx1ZUluZm8uZWxlbVR5cGUoKSk7XG4gICAgICAgICAgY29uc3Qgc2hhcGUgPSB2YWx1ZUluZm8uc2hhcGUoKSE7XG4gICAgICAgICAgY29uc3QgZGltcyA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgc2hhcGUuZGltTGVuZ3RoKCkhOyBrKyspIHtcbiAgICAgICAgICAgIGRpbXMucHVzaChMb25nVXRpbC5sb25nVG9OdW1iZXIoc2hhcGUuZGltKGspIS52YWx1ZSgpIS5kaW1WYWx1ZSgpISkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZS50eXBlID0ge3NoYXBlOiB7ZGltc30sIHRlbnNvclR5cGU6IHR5cGV9O1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuX2FsbERhdGEucHVzaCh2YWx1ZSkgLSAxO1xuICAgICAgICAgIGRhdGFJbmRpY2VzLnNldChpbnB1dE5hbWUsIGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgaW5wdXRWYWx1ZU5hbWVzLnB1c2goaW5wdXROYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBjaGVjayBpbml0aWFsaXplcnNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyYXBoLmluaXRpYWxpemVyc0xlbmd0aCgpOyBpKyspIHtcbiAgICAgIGNvbnN0IGluaXRpYWxpemVyID0gZ3JhcGguaW5pdGlhbGl6ZXJzKGkpITtcbiAgICAgIGxldCBpbmRleCA9IGRhdGFJbmRpY2VzLmdldChpbml0aWFsaXplci5uYW1lKCkhKTtcbiAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IFZhbHVlKCk7XG4gICAgICAgIGNvbnN0IGRpbXMgPSBQcm90b1V0aWwudGVuc29yRGltc0Zyb21PUlRGb3JtYXQoaW5pdGlhbGl6ZXIpO1xuICAgICAgICBjb25zdCB0eXBlID0gUHJvdG9VdGlsLnRlbnNvckRhdGFUeXBlRnJvbVByb3RvKGluaXRpYWxpemVyLmRhdGFUeXBlKCkpO1xuICAgICAgICB2YWx1ZS50eXBlID0ge3NoYXBlOiB7ZGltc30sIHRlbnNvclR5cGU6IHR5cGV9O1xuICAgICAgICBpbmRleCA9IHRoaXMuX2FsbERhdGEucHVzaCh2YWx1ZSkgLSAxO1xuICAgICAgICBkYXRhSW5kaWNlcy5zZXQoaW5pdGlhbGl6ZXIubmFtZSgpISwgaW5kZXgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWxsRGF0YVtpbmRleF0uX2Zyb20gPSAtMTtcbiAgICAgIHRoaXMuX2FsbERhdGFbaW5kZXhdLnRlbnNvciA9IFRlbnNvci5mcm9tT3J0VGVuc29yKGluaXRpYWxpemVyKTtcbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IGlucHV0IGluZGljZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2FsbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5fYWxsRGF0YVtpXS50ZW5zb3IpIHtcbiAgICAgICAgdGhpcy5fYWxsSW5wdXRJbmRpY2VzLnB1c2goaSk7XG4gICAgICAgIHRoaXMuX2FsbElucHV0TmFtZXMucHVzaChpbnB1dFZhbHVlTmFtZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNjYW4gYWxsIG91dHB1dHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyYXBoLm91dHB1dHNMZW5ndGgoKTsgaSsrKSB7XG4gICAgICBjb25zdCBvdXRwdXROYW1lID0gZ3JhcGgub3V0cHV0cyhpKTtcbiAgICAgIGlmIChkYXRhSW5kaWNlcy5oYXMob3V0cHV0TmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG91dHB1dCBuYW1lOiAke291dHB1dE5hbWV9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLl9hbGxEYXRhLnB1c2gobmV3IFZhbHVlKCkpIC0gMTtcbiAgICAgIGRhdGFJbmRpY2VzLnNldChvdXRwdXROYW1lLCBjdXJyZW50SW5kZXgpO1xuICAgICAgdGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5wdXNoKGN1cnJlbnRJbmRleCk7XG4gICAgICB0aGlzLl9hbGxPdXRwdXROYW1lcy5wdXNoKG91dHB1dE5hbWUpO1xuICAgIH1cblxuICAgIC8vIHNjYW4gYWxsIG5vZGVzXG4gICAgaWYgKCFncmFwaC5ub2Rlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGluZm9ybWF0aW9uIGluIGdyYXBoOiBub2RlJyk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JhcGgubm9kZXNMZW5ndGgoKTsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlUHJvdG8gPSBncmFwaC5ub2RlcyhpKTtcbiAgICAgIGxldCBuYW1lID0gbm9kZVByb3RvIS5uYW1lKCk7XG4gICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgLy8gYXNzaWduIGEgbmFtZSB0byB0aGUgbm9kZSBpZiBpdCBkb2Vzbid0IGhhdmUgb25lXG4gICAgICAgIGZvciAobGV0IHBpY2sgPSAwOzsgcGljaysrKSB7XG4gICAgICAgICAgbmFtZSA9IGB1bm5hbWVkXyR7bm9kZVByb3RvIS5vcFR5cGUoKX1fJHtwaWNrfWA7XG4gICAgICAgICAgaWYgKCFub2Rlc0luZGljZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAvLyBhbiB1bmlxdWUgbmFtZSBpcyBmb3VuZC4gYnJlYWsuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGVzSW5kaWNlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGVkIG5vZGUgbmFtZTogJHtuYW1lfWApO1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gdGhpcy5fbm9kZXMucHVzaChuZXcgTm9kZShub2RlUHJvdG8hLCBuYW1lKSkgLSAxO1xuICAgICAgbm9kZXNJbmRpY2VzLnNldChuYW1lLCBjdXJyZW50SW5kZXgpO1xuICAgIH1cblxuICAgIC8vIHNjYW4gbm9kZSdzIG91dHB1dHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX25vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5fbm9kZXNbaV07XG4gICAgICBjb25zdCBub2RlUHJvdG8gPSBncmFwaC5ub2RlcyhpKTtcbiAgICAgIGlmIChub2RlUHJvdG8gPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG5vZGUgZXhpc3RzIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlUHJvdG8/Lm91dHB1dHNMZW5ndGgoKSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3Npbmcgb3V0cHV0IGZvciBub2RlOiAke25vZGVQcm90by5uYW1lfWApO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2RlUHJvdG8/Lm91dHB1dHNMZW5ndGgoKTsgaisrKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IG5vZGVQcm90bz8ub3V0cHV0cyhqKTtcbiAgICAgICAgbGV0IGRhdGFJbmRleCA9IGRhdGFJbmRpY2VzLmdldChvdXRwdXQpO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFJbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBkYXRhSW5kZXggPSB0aGlzLl9hbGxEYXRhLnB1c2gobmV3IFZhbHVlKCkpIC0gMTtcbiAgICAgICAgICBkYXRhSW5kaWNlcy5zZXQob3V0cHV0LCBkYXRhSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUub3V0cHV0cy5wdXNoKGRhdGFJbmRleCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2FsbERhdGFbZGF0YUluZGV4XS5fZnJvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtdWx0aXBsZSBub2RlcyBvdXRwdXQgdG8gb25lIGRhdGEgdmFsdWU6ICR7ZGF0YUluZGV4fWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FsbERhdGFbZGF0YUluZGV4XS5fZnJvbSA9IGk7XG5cbiAgICAgICAgLy8gZm9yIHRoZSAnQ29uc3RhbnQnIG9wZXJhdG9yLCBqdXN0IGNyZWF0ZSBhIG5ldyBlZGdlIGluIHRoZSBncmFwaCBjb3JyZXNwb25kaW5nIHRvIHRoZSAnb3V0cHV0JyBvZiB0aGVcbiAgICAgICAgLy8gb3BlcmF0b3IgYW5kIGlnbm9yZSB0aGUgbm9kZSBmcm9tIHRoZSBncmFwaFxuICAgICAgICBpZiAobm9kZVByb3RvLm9wVHlwZSgpID09PSAnQ29uc3RhbnQnKSB7XG4gICAgICAgICAgaWYgKG5vZGVQcm90by5hdHRyaWJ1dGVzTGVuZ3RoKCkgIT09IDEgfHwgIW5vZGVQcm90by5hdHRyaWJ1dGVzKDApIS50KCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBhdHRyaWJ1dGVzIG9yIG1pc3NpbmcgdGVuc29yIHZhbHVlIGluIGF0dHJpYnV0ZXMgZm9yIHRoaXMgQ29uc3RhbnQgb3BlcmF0b3InKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vZGVQcm90by5vdXRwdXRzTGVuZ3RoKCkgIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBvdXRwdXQgb3IgaW5jb3JyZWN0IG51bWJlciBvZiBvdXRwdXRzIGZvciB0aGlzIENvbnN0YW50IG9wZXJhdG9yJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUub3V0cHV0cy5wb3AoKTtcbiAgICAgICAgICBub2RlLmV4ZWN1dGVOb2RlID0gZmFsc2U7XG5cbiAgICAgICAgICB0aGlzLl9hbGxEYXRhW2RhdGFJbmRleF0uX2Zyb20gPSAtMTtcbiAgICAgICAgICB0aGlzLl9hbGxEYXRhW2RhdGFJbmRleF0udGVuc29yID0gVGVuc29yLmZyb21PcnRUZW5zb3Iobm9kZVByb3RvLmF0dHJpYnV0ZXMoMCkhLnQoKSEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2NhbiBub2RlJ3MgaW5wdXRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX25vZGVzW2ldO1xuICAgICAgY29uc3Qgbm9kZVByb3RvID0gZ3JhcGgubm9kZXMoaSkhO1xuXG4gICAgICBpZiAobm9kZVByb3RvLmlucHV0c0xlbmd0aCgpID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyBpbnB1dCBmb3Igbm9kZTogJHtub2RlUHJvdG8ubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9kZVByb3RvLmlucHV0c0xlbmd0aCgpITsgaisrKSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gbm9kZVByb3RvLmlucHV0cyhqKSE7XG4gICAgICAgIGNvbnN0IGRhdGFJbmRleCA9IGRhdGFJbmRpY2VzLmdldChpbnB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YUluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5yZWNvZ25pemVkIGlucHV0ICcke2lucHV0fScgZm9yIG5vZGU6ICR7bm9kZVByb3RvIS5uYW1lKCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5pbnB1dHMucHVzaChkYXRhSW5kZXgpO1xuXG4gICAgICAgIHRoaXMuX2FsbERhdGFbZGF0YUluZGV4XS5fdG8ucHVzaChpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNoZWNrSXNBY3ljbGljKCkge1xuICAgIC8vIGdvIHRocm91Z2ggdGhlIGdyYXBoIGFuZCBjaGVjayBmb3IgY3ljbGVzIG9yIG90aGVyIGZhdGFsIGluY29uc2lzdGVuY2llc1xuICAgIGNvbnN0IHN0YXJ0ZXJzOiBTZXQ8bnVtYmVyPiA9IG5ldyBTZXQ8bnVtYmVyPigpO1xuICAgIHRoaXMuX2FsbElucHV0SW5kaWNlcy5mb3JFYWNoKGkgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX2FsbERhdGFbaV07XG4gICAgICBkYXRhLl90by5mb3JFYWNoKGogPT4ge1xuICAgICAgICBzdGFydGVycy5hZGQoaik7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIEl0ZXJhdGl2ZSBERlMgdG8gY2hlY2sgZm9yIGN5Y2xlc1xuICAgIGNvbnN0IG5vZGVzU3RhY2sgPSBBcnJheS5mcm9tKHN0YXJ0ZXJzKTtcbiAgICBjb25zdCBub2Rlc1N0YXRlID0gbmV3IEFycmF5PHN0cmluZz4odGhpcy5fbm9kZXMubGVuZ3RoKS5maWxsKCd3aGl0ZScpO1xuXG4gICAgd2hpbGUgKG5vZGVzU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgbm9kZUluZGV4ID0gbm9kZXNTdGFjay5wb3AoKSE7XG4gICAgICAvLyB0aGlzIG5vZGUgaGFzIG5vdyBiZWVuIHByb2Nlc3NlZCBjb21wbGV0ZWx5LiBNYXJrIHRoaXMgbm9kZSAnYmxhY2snIHRvIGRlbm90ZSB0aGlzLlxuICAgICAgaWYgKG5vZGVzU3RhdGVbbm9kZUluZGV4XSA9PT0gJ2dyYXknKSB7XG4gICAgICAgIG5vZGVzU3RhdGVbbm9kZUluZGV4XSA9ICdibGFjayc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGlzIG5vZGUgaXMgdW5kZXIgcHJvY2Vzc2luZyBzdGFnZS4gbWFyayB0aGlzIG5vZGUgJ2dyYXknIHRvIGRlbm90ZSB0aGlzLlxuICAgICAgICBub2Rlc1N0YWNrLnB1c2gobm9kZUluZGV4KTtcbiAgICAgICAgbm9kZXNTdGF0ZVtub2RlSW5kZXhdID0gJ2dyYXknO1xuXG4gICAgICAgIHRoaXMuX25vZGVzW25vZGVJbmRleF0ub3V0cHV0cy5mb3JFYWNoKChvdXRnb2luZ0VkZ2VJbmRleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9hbGxEYXRhW291dGdvaW5nRWRnZUluZGV4XTtcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGEudGVuc29yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub2RlIG91dHB1dHMgc2hvdWxkIG5vdCBiZSBpbml0aWFsaXplZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGF0YS5fZnJvbSAhPT0gbm9kZUluZGV4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Zyb20gcHJvcGVydHkgb2YgdGhlIFZhbHVlIG9iamVjdCBkb2VzblxcJ3QgbWF0Y2ggaW5kZXggb2YgTm9kZSBiZWluZyBwcm9jZXNzZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YS5fdG8uZm9yRWFjaCgoZG93bnN0cmVhbU5vZGVJbmRleCkgPT4ge1xuICAgICAgICAgICAgLy8gYmFjayBlZGdlIGZvdW5kIC0gY3ljbGljXG4gICAgICAgICAgICBpZiAobm9kZXNTdGF0ZVtkb3duc3RyZWFtTm9kZUluZGV4XSA9PT0gJ2dyYXknKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbW9kZWwgZ3JhcGggaXMgY3ljbGljJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0cmVlIGVkZ2UgZm91bmQgLSBjb250aW51ZSBwcm9jZXNzaW5nIGJ5IGFkZGluZyBpdCB0byBzdGFja1xuICAgICAgICAgICAgZWxzZSBpZiAobm9kZXNTdGF0ZVtkb3duc3RyZWFtTm9kZUluZGV4XSA9PT0gJ3doaXRlJykge1xuICAgICAgICAgICAgICBub2Rlc1N0YWNrLnB1c2goZG93bnN0cmVhbU5vZGVJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdHJhbnNmb3JtR3JhcGgoZ3JhcGhJbml0aWFsaXplcj86IEdyYXBoLkluaXRpYWxpemVyKTogdm9pZCB7XG4gICAgLy8gYXBwbHkgY29tbW9uIHRyYW5zZm9ybVxuICAgIHRoaXMucmVtb3ZlQWxsSWRlbnRpdHlOb2RlcygpO1xuICAgIHRoaXMucmVtb3ZlQWxsRHJvcG91dE5vZGVzKCk7XG4gICAgdGhpcy5mdXNlQ29udkFjdGl2YXRpb25Ob2RlcygpO1xuICAgIC8vIGFwcGx5IGluaXRpYWxpemVyIHNwZWNpZmljIHRyYW5zZm9ybVxuICAgIGlmIChncmFwaEluaXRpYWxpemVyKSB7XG4gICAgICBncmFwaEluaXRpYWxpemVyLnRyYW5zZm9ybUdyYXBoKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIGZpbmFsaXplIGdyYXBoXG4gICAgdGhpcy5maW5hbGl6ZUdyYXBoKCk7XG4gIH1cblxuICAvKipcbiAgICogZmluYWxpemUgdGhlIGdyYXBoLlxuICAgKlxuICAgKiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgYWxsIHRoZSB0cmFuc2Zvcm1hdGlvbiBjb21wbGV0ZWQuXG4gICAqIHRoaXMgZnVuY3Rpb24gcmVtb3ZlcyBhbGwgdW5uZWNlc3Nhcnkgbm9kZXMgYW5kIHZhbHVlcyBmcm9tIHRoZSBncmFwaFxuICAgKi9cbiAgZmluYWxpemVHcmFwaCgpIHtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAvLyBkZWxldGUgYWxsIG5vZGVzIHRoYXQgYXJlIG5vdCBiZWluZyBleGVjdXRlZFxuICAgIC8vIFRoZSBncmFwaCBpcyByZXByZXNlbnRlZCB1c2luZyB0aGVzZSB0d28gYXJyYXlzXG4gICAgLy8gdGhpcy5fbm9kZXMgLSBBcnJheSBob2xkaW5nIHRoZSBrZXJuZWxzIHRvIGV4ZWN1dGUgLSBlYWNoIGVudHJ5IGlzIGEga2VybmVsIHBvaW50aW5nIHRvIHRoaXMuX2FsbERhdGFcbiAgICAvLyB0aGlzLl9hbGxEYXRhIC0gaG9sZCAyIGZpZWxkcyAtIHRvIFtdICYgZnJvbSAtIHRoZXNlIGZlaWxlZHMgaG9sZCB0aGUgZ3JhcGggbWFwIGZvciBpbnB1dHMgYW5kIG91dHB1dHMgcGVyIG5vZGVcbiAgICAvLyBuZXdJbmRpY2VzIC0gcmVtYXBwaW5nIHRoZSBncmFwaCBhZnRlciByZWFkaW5nIHRoZSBmbGFnICdleGVjdXRlTm9kZSdcbiAgICBjb25zdCBuZXdJbmRpY2VzID0gbmV3IEFycmF5PG51bWJlcj4odGhpcy5fbm9kZXMubGVuZ3RoLCAwKTtcbiAgICBsZXQgbm9kZVBvc3NpdGlvbiA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX25vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBnaXZpbmcgbmV3IGluZGV4ZXMgdG8gdGhlIG5vZGVzIGJhc2VkIG9uIGV4ZWN1dGlvbiBmbGFnXG4gICAgICBuZXdJbmRpY2VzW2ldID0gbm9kZVBvc3NpdGlvbjtcbiAgICAgIGlmICh0aGlzLl9ub2Rlc1tpXS5leGVjdXRlTm9kZSkge1xuICAgICAgICBpZiAobm9kZVBvc3NpdGlvbiAhPT0gaSkge1xuICAgICAgICAgIHRoaXMuX25vZGVzW25vZGVQb3NzaXRpb25dID0gdGhpcy5fbm9kZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgbm9kZVBvc3NpdGlvbisrO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWxldGUgYWxsIG91dHB1dCB2YWx1ZXNcbiAgICAgICAgdGhpcy5fbm9kZXNbaV0ub3V0cHV0cy5mb3JFYWNoKGluZCA9PiB7XG4gICAgICAgICAgdGhpcy5fYWxsRGF0YVtpbmRdLl9mcm9tID0gLTI7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlbW92aW5nIHRoZSB1bnVzZWQgbm9kZXNcbiAgICB0aGlzLl9ub2Rlcy5zcGxpY2Uobm9kZVBvc3NpdGlvbiwgdGhpcy5fbm9kZXMubGVuZ3RoIC0gbm9kZVBvc3NpdGlvbik7XG5cbiAgICAvLyBVcGRhdGluZyB0aGlzLl9hbGxEYXRhIGFjY29yZGluZyB0byB0aGUgbmV3IHRoaXMuX25vZGVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hbGxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjdXJyZW50RGF0YSA9IHRoaXMuX2FsbERhdGFbaV07XG4gICAgICBpZiAoY3VycmVudERhdGEuX2Zyb20gIT09IHVuZGVmaW5lZCAmJiBjdXJyZW50RGF0YS5fZnJvbSAhPT0gLTEgJiYgY3VycmVudERhdGEuX2Zyb20gIT09IC0yKSB7XG4gICAgICAgIGN1cnJlbnREYXRhLl9mcm9tID0gbmV3SW5kaWNlc1tjdXJyZW50RGF0YS5fZnJvbV07XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY3VycmVudERhdGEuX3RvLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChjdXJyZW50RGF0YS5fdG9bal0gPj0gMCkge1xuICAgICAgICAgIGN1cnJlbnREYXRhLl90b1tqXSA9IG5ld0luZGljZXNbY3VycmVudERhdGEuX3RvW2pdXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byB1cGRhdGUgYSByZW1vdmVkIG5vZGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG9mZnNldCA9IDA7XG4gICAgLy8gZGVsZXRlIGFsbCB2YWx1ZXMgdGhhdCBhcmUgbm90IGJlaW5nIHJlZmVyZW5jZWRcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2FsbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIGlmIGN1cnJlbnQgdmFsdWUgaXMgbmVpdGhlciBsaW5rZWQgdG8gbmV4dCBub2RlLCBub3IgYW4gb3V0cHV0IHZhbHVlLCByZW1vdmUgaXQuXG4gICAgICBpZiAodGhpcy5fYWxsRGF0YVtpXS5mcm9tID09PSAtMiAmJiB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzLmluZGV4T2YoaSArIG9mZnNldCkgPT09IC0xKSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICB0aGlzLl9hbGxEYXRhLnNwbGljZShpLCAxKTtcbiAgICAgICAgaS0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICAgIGxldCBpbmQgPSAtMTtcbiAgICAgICAgLy8gaWYgY3VycmVudCB2YWx1ZSBpcyBuZWl0aGVyIGFuIGlucHV0IHZhbHVlIG5vciBhbiBpbml0aWFsaXplciwgZmluZCB0aGUgbm9kZSBpdCdzXG4gICAgICAgIC8vIGNvbWluZyBmcm9tIGFuZCB1cGRhdGUgdGhlIGNvcnJlc3BvbmRpbmcgbm9kZSBvdXRwdXRcbiAgICAgICAgaWYgKHRoaXMuX2FsbERhdGFbaV0uZnJvbSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX2FsbERhdGFbaV0uZnJvbSAhPT0gLTEpIHtcbiAgICAgICAgICBpbmQgPSB0aGlzLl9ub2Rlc1t0aGlzLl9hbGxEYXRhW2ldLmZyb21dLm91dHB1dHMuaW5kZXhPZihpICsgb2Zmc2V0KTtcbiAgICAgICAgICBpZiAoaW5kICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fbm9kZXNbdGhpcy5fYWxsRGF0YVtpXS5mcm9tXS5vdXRwdXRzW2luZF0gPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiBjdXJyZW50IHZhbHVlIGlzIGFuIGlucHV0IHZhbHVlLCB1cGRhdGUgaXRzIHJlZmVyZW5jZSBpbiBpbnB1dEluZGljZXNcbiAgICAgICAgICBpbmQgPSB0aGlzLl9hbGxJbnB1dEluZGljZXMuaW5kZXhPZihpICsgb2Zmc2V0KTtcbiAgICAgICAgICBpZiAoaW5kICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fYWxsSW5wdXRJbmRpY2VzW2luZF0gPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmQgdGhlIG5vZGUgdGhhdCB0aGUgY3VycmVudCB2YWx1ZSBpcyBsaW5raW5nIHRvIGFuZCB1cGRhdGUgaXRzIGlucHV0IHJlZmVyZW5jZVxuICAgICAgICB0aGlzLl9hbGxEYXRhW2ldLnRvLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgaW5kID0gdGhpcy5fbm9kZXNbbm9kZV0uaW5wdXRzLmluZGV4T2YoaSArIG9mZnNldCk7XG4gICAgICAgICAgaWYgKGluZCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX25vZGVzW25vZGVdLmlucHV0c1tpbmRdID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fYWxsRGF0YVtpXS50by5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAvLyBpZiBjdXJyZW50IHZhbHVlIGlzIGEgZ3JhcGggb3V0cHV0LCB1cGRhdGUgaXRzIHJlZmVyZW5jZSBpbiBvdXRwdXRJbmRpY2VzXG4gICAgICAgICAgaW5kID0gdGhpcy5fYWxsT3V0cHV0SW5kaWNlcy5pbmRleE9mKGkgKyBvZmZzZXQpO1xuICAgICAgICAgIGlmIChpbmQgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzW2luZF0gPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgdGhlIHNwZWNpZmVkIG5vZGUuIEFzc3VtZSB0aGUgbm9kZSBoYXMgb25lIGluY29taW5nIGlucHV0IGFuZCB0aGUgZmlyc3Qgb3V0cHV0IGNvbm5lY3RlZCB0byBvdGhlciBub2Rlcy5cbiAgICogQW4gaW5wdXQgdmFsaWRhdGlvbiBtdXN0IGJlIGRvbmUgYmVmb3JlIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAgICogQHBhcmFtIG5vZGVJbmRleCBUaGUgaW5kZXggb2Ygbm9kZSB0byBiZSBkZWxldGVkXG4gICAqL1xuICBwcml2YXRlIGRlbGV0ZU5vZGUobm9kZUluZGV4OiBudW1iZXIpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5fbm9kZXNbbm9kZUluZGV4XTtcbiAgICBpZiAobm9kZS5vdXRwdXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbm9kZS5vdXRwdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9hbGxEYXRhW25vZGUub3V0cHV0c1tpXV0udG8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm9kZSBkZWxldGlvbiB3aXRoIG1vcmUgdGhhbiBvbmUgb3V0cHV0IGNvbm5lY3RlZCB0byBvdGhlciBub2RlcyBpcyBub3Qgc3VwcG9ydGVkLiAnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRoaXMgbm9kZSB3aWwgbm90IGJlIGV4ZWN1dGVkXG4gICAgbm9kZS5leGVjdXRlTm9kZSA9IGZhbHNlO1xuICAgIGNvbnN0IGlucHV0VmFsdWVJbmRleCA9IG5vZGUuaW5wdXRzWzBdO1xuICAgIGNvbnN0IG91dHB1dFZhbHVlSW5kZXggPSBub2RlLm91dHB1dHNbMF07XG4gICAgY29uc3Qgbm9kZXNDb25zdW1pbmdPdXRwdXQgPSB0aGlzLl9hbGxEYXRhW291dHB1dFZhbHVlSW5kZXhdLnRvO1xuXG4gICAgLy8gcmVtb3ZlIHRoaXMgbm9kZSBmcm9tIHRoZSB0byBwcm9wZXJ0eSBvZiB0aGUgaW5wdXQgVmFsdWVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkZWxJbmRleCA9IHRoaXMuX2FsbERhdGFbbm9kZS5pbnB1dHNbaV1dLnRvLmluZGV4T2Yobm9kZUluZGV4KTtcbiAgICAgIC8vIHNob3VsZCBub3QgaGFwcGVuXG4gICAgICBpZiAoZGVsSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIFZhbHVlIG9iamVjdCBkb2VzblxcJ3QgaGF2ZSB0aGUgY3VycmVudCBOb2RlIGluIGl0XFwncyBcXCd0b1xcJyBwcm9wZXJ0eSAnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FsbERhdGFbbm9kZS5pbnB1dHNbaV1dLnRvLnNwbGljZShkZWxJbmRleCwgMSk7XG4gICAgfVxuXG4gICAgLy8gY2xlYXIgbm9kZSBpbmRpY2VzIGNvbnN1bWluZyB0aGlzIG91dHB1dCBWYWx1ZVxuICAgIHRoaXMuX2FsbERhdGFbb3V0cHV0VmFsdWVJbmRleF0uX3RvID0gW107XG5cbiAgICAvLyBpZiB0aGUgb3V0cHV0IG9mIHRoaXMgbm9kZSBpcyBhIGdyYXBoIG91dHB1dCwgYWRqdXN0IHRoZSBpbmRleCBhcHByb3ByaWF0ZWx5XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl9hbGxPdXRwdXRJbmRpY2VzLmluZGV4T2Yob3V0cHV0VmFsdWVJbmRleCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgdGhpcy5fYWxsT3V0cHV0SW5kaWNlc1tpbmRleF0gPSBpbnB1dFZhbHVlSW5kZXg7XG4gICAgfVxuXG4gICAgLy8gb3ZlcnJpZGUgdGhlIGlucHV0cyBmb3Igbm9kZXMgY29uc3VtaW5nIHRoaXMgbm9kZSdzIG91dHB1dCB3aXRoIHRoZSBpbnB1dCB0byB0aGlzIG5vZGVcbiAgICBpZiAobm9kZXNDb25zdW1pbmdPdXRwdXQgJiYgbm9kZXNDb25zdW1pbmdPdXRwdXQubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChjb25zdCBub2RlSW5kZXggb2Ygbm9kZXNDb25zdW1pbmdPdXRwdXQpIHtcbiAgICAgICAgY29uc3QgcmVwbGFjZUluZGV4ID0gdGhpcy5fbm9kZXNbbm9kZUluZGV4XS5pbnB1dHMuaW5kZXhPZihvdXRwdXRWYWx1ZUluZGV4KTtcbiAgICAgICAgLy8gc2hvdWxkIG5vdCBoYXBwZW5cbiAgICAgICAgaWYgKHJlcGxhY2VJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBOb2RlIG9iamVjdCBkb2VzblxcJ3QgaGF2ZSB0aGUgb3V0cHV0IFZhbHVlIGluIGl0XFwncyBcXCdpbnB1dHNcXCcgcHJvcGVydHkgJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbm9kZXNbbm9kZUluZGV4XS5pbnB1dHNbcmVwbGFjZUluZGV4XSA9IGlucHV0VmFsdWVJbmRleDtcbiAgICAgICAgdGhpcy5fYWxsRGF0YVtpbnB1dFZhbHVlSW5kZXhdLnRvLnB1c2gobm9kZUluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZW1vdmVBbGxEcm9wb3V0Tm9kZXMoKSB7XG4gICAgbGV0IG5vZGVJbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMuX25vZGVzKSB7XG4gICAgICAvLyB3ZWVkIG91dCAnRHJvcG91dCcgbm9kZXMgc28gdGhhdCBubyB0aW1lIGlzIHdhc3RlZCBpbiBleGVjdXRpb25cbiAgICAgIGlmIChub2RlLm9wVHlwZSA9PT0gJ0Ryb3BvdXQnKSB7XG4gICAgICAgIC8vIHRoZSBub2RlIHNob3VsZCBoYXZlIGV4YWN0bHkgMSBpbnB1dCBhbmQgMSBvciAyIG91dHB1dHNcbiAgICAgICAgaWYgKG5vZGUuaW5wdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRHJvcG91dCBub2RlcyBzaG91bGQgb25seSBjb250YWluIG9uZSBpbnB1dC4gJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUub3V0cHV0cy5sZW5ndGggIT09IDEgJiYgbm9kZS5vdXRwdXRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRHJvcG91dCBub2RlcyBzaG91bGQgY29udGFpbiBlaXRoZXIgMSBvciAyIG91dHB1dChzKScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBzZWNvbmQgb3V0cHV0IHNob3VsZCBub3QgYmUgcmVmZXJlbmNlZCBieSBhbnkgb3RoZXIgbm9kZVxuICAgICAgICBpZiAobm9kZS5vdXRwdXRzLmxlbmd0aCA9PT0gMiAmJiB0aGlzLl9hbGxEYXRhW25vZGUub3V0cHV0c1sxXV0uX3RvLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRHJvcG91dCBub2Rlc1xcJ3Mgc2Vjb25kIG91dHB1dCBzaG91bGQgbm90IGJlIHJlZmVyZW5jZWQgYnkgb3RoZXIgbm9kZXMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlbGV0ZU5vZGUobm9kZUluZGV4KTtcbiAgICAgIH1cbiAgICAgIG5vZGVJbmRleCsrO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZUFsbElkZW50aXR5Tm9kZXMoKSB7XG4gICAgbGV0IG5vZGVJbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMuX25vZGVzKSB7XG4gICAgICAvLyB3ZWVkIG91dCAnSWRlbnRpdHknIG5vZGVzIHNvIHRoYXQgbm8gdGltZSBpcyB3YXN0ZWQgaW4gZXhlY3V0aW9uXG4gICAgICBpZiAobm9kZS5vcFR5cGUgPT09ICdJZGVudGl0eScpIHtcbiAgICAgICAgdGhpcy5kZWxldGVOb2RlKG5vZGVJbmRleCk7XG4gICAgICB9XG4gICAgICBub2RlSW5kZXgrKztcbiAgICB9XG4gIH1cblxuICBpc0FjdGl2YXRpb24objogTm9kZSk6IGJvb2xlYW4ge1xuICAgIHN3aXRjaCAobi5vcFR5cGUpIHtcbiAgICAgIC8vIFRPRE86IGFkZCBvdGhlciBhY3RpdmF0aW9uIG1ldGhvZHNcbiAgICAgIGNhc2UgJ1JlbHUnOlxuICAgICAgY2FzZSAnU2lnbW9pZCc6XG4gICAgICBjYXNlICdDbGlwJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVzZUNvbnZBY3RpdmF0aW9uTm9kZXMoKSB7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMuX25vZGVzKSB7XG4gICAgICBpZiAobm9kZS5vcFR5cGUgPT09ICdDb252Jykge1xuICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5fYWxsRGF0YVtub2RlLm91dHB1dHNbMF1dLl90bztcbiAgICAgICAgaWYgKG5leHQubGVuZ3RoID09PSAxICYmIHRoaXMuaXNBY3RpdmF0aW9uKHRoaXMuX25vZGVzW25leHRbMF1dKSkge1xuICAgICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5fbm9kZXNbbmV4dFswXV07XG4gICAgICAgICAgaWYgKGNoaWxkLm9wVHlwZSA9PT0gJ0NsaXAnKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQuaW5wdXRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5vZGUuYXR0cmlidXRlcy5zZXQoXG4gICAgICAgICAgICAgICAgICAgICdhY3RpdmF0aW9uX3BhcmFtcycsICdmbG9hdHMnLFxuICAgICAgICAgICAgICAgICAgICBbY2hpbGQuYXR0cmlidXRlcy5nZXRGbG9hdCgnbWluJyksIGNoaWxkLmF0dHJpYnV0ZXMuZ2V0RmxvYXQoJ21heCcpXSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLmF0dHJpYnV0ZXMuc2V0KCdhY3RpdmF0aW9uX3BhcmFtcycsICdmbG9hdHMnLCBbTUlOX0NMSVAsIE1BWF9DTElQXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgY2hpbGQuaW5wdXRzLmxlbmd0aCA+PSAzICYmIHRoaXMuX2FsbERhdGFbY2hpbGQuaW5wdXRzWzFdXS50ZW5zb3IgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX2FsbERhdGFbY2hpbGQuaW5wdXRzWzJdXS50ZW5zb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBub2RlLmF0dHJpYnV0ZXMuc2V0KCdhY3RpdmF0aW9uX3BhcmFtcycsICdmbG9hdHMnLCBbXG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsRGF0YVtjaGlsZC5pbnB1dHNbMV1dLnRlbnNvciEuZmxvYXREYXRhWzBdLCB0aGlzLl9hbGxEYXRhW2NoaWxkLmlucHV0c1syXV0udGVuc29yIS5mbG9hdERhdGFbMF1cbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBTa2lwIGZ1c2lvbiB3aXRoIGNsaXAgbm9kZSBzaW5jZSBjbGlwIG1pbiBhbmQgY2xpcCBtYXggYXJlIG5vdCBjb21pbmcgZnJvbSBpbml0aWFsaXplclxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5hdHRyaWJ1dGVzLnNldCgnYWN0aXZhdGlvbicsICdzdHJpbmcnLCAoY2hpbGQub3BUeXBlKSk7XG4gICAgICAgICAgdGhpcy5kZWxldGVOb2RlKG5leHRbMF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7ZmxhdGJ1ZmZlcnN9IGZyb20gJ2ZsYXRidWZmZXJzJztcblxuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi9ncmFwaCc7XG5pbXBvcnQge09wU2V0fSBmcm9tICcuL29wc2V0JztcbmltcG9ydCB7b25ueHJ1bnRpbWV9IGZyb20gJy4vb3J0LXNjaGVtYS9mbGF0YnVmZmVycy9vcnQtZ2VuZXJhdGVkJztcbmltcG9ydCB7b25ueH0gZnJvbSAnLi9vcnQtc2NoZW1hL3Byb3RvYnVmL29ubngnO1xuaW1wb3J0IHtMb25nVXRpbH0gZnJvbSAnLi91dGlsJztcblxuaW1wb3J0IG9ydEZicyA9IG9ubnhydW50aW1lLmV4cGVyaW1lbnRhbC5mYnM7XG5cbmV4cG9ydCBjbGFzcyBNb2RlbCB7XG4gIC8vIGVtcHR5IG1vZGVsXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICBsb2FkKGJ1ZjogVWludDhBcnJheSwgZ3JhcGhJbml0aWFsaXplcj86IEdyYXBoLkluaXRpYWxpemVyLCBpc09ydEZvcm1hdD86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBsZXQgb25ueEVycm9yOiBFcnJvcnx1bmRlZmluZWQ7XG4gICAgaWYgKCFpc09ydEZvcm1hdCkge1xuICAgICAgLy8gaXNPcnRGb3JtYXQgPT09IGZhbHNlIHx8IGlzT3J0Rm9ybWF0ID09PSB1bmRlZmluZWRcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMubG9hZEZyb21Pbm54Rm9ybWF0KGJ1ZiwgZ3JhcGhJbml0aWFsaXplcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGlzT3J0Rm9ybWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIG9ubnhFcnJvciA9IGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMubG9hZEZyb21PcnRGb3JtYXQoYnVmLCBncmFwaEluaXRpYWxpemVyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoaXNPcnRGb3JtYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgLy8gVHJpZWQgYm90aCBmb3JtYXRzIGFuZCBmYWlsZWQgKHdoZW4gaXNPcnRGb3JtYXQgPT09IHVuZGVmaW5lZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgbW9kZWwgYXMgT05OWCBmb3JtYXQ6ICR7b25ueEVycm9yfVxcbmFzIE9SVCBmb3JtYXQ6ICR7ZX1gKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGxvYWRGcm9tT25ueEZvcm1hdChidWY6IFVpbnQ4QXJyYXksIGdyYXBoSW5pdGlhbGl6ZXI/OiBHcmFwaC5Jbml0aWFsaXplcik6IHZvaWQge1xuICAgIGNvbnN0IG1vZGVsUHJvdG8gPSBvbm54Lk1vZGVsUHJvdG8uZGVjb2RlKGJ1Zik7XG4gICAgY29uc3QgaXJWZXJzaW9uID0gTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKG1vZGVsUHJvdG8uaXJWZXJzaW9uKTtcbiAgICBpZiAoaXJWZXJzaW9uIDwgMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbmx5IHN1cHBvcnQgT05OWCBtb2RlbCB3aXRoIElSX1ZFUlNJT04+PTMnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9vcHNldHMgPVxuICAgICAgICBtb2RlbFByb3RvLm9wc2V0SW1wb3J0Lm1hcChpID0+ICh7ZG9tYWluOiBpLmRvbWFpbiBhcyBzdHJpbmcsIHZlcnNpb246IExvbmdVdGlsLmxvbmdUb051bWJlcihpLnZlcnNpb24hKX0pKTtcblxuICAgIHRoaXMuX2dyYXBoID0gR3JhcGguZnJvbShtb2RlbFByb3RvLmdyYXBoISwgZ3JhcGhJbml0aWFsaXplcik7XG4gIH1cblxuICBwcml2YXRlIGxvYWRGcm9tT3J0Rm9ybWF0KGJ1ZjogVWludDhBcnJheSwgZ3JhcGhJbml0aWFsaXplcj86IEdyYXBoLkluaXRpYWxpemVyKTogdm9pZCB7XG4gICAgY29uc3QgZmIgPSBuZXcgZmxhdGJ1ZmZlcnMuQnl0ZUJ1ZmZlcihidWYpO1xuICAgIGNvbnN0IG9ydE1vZGVsID0gb3J0RmJzLkluZmVyZW5jZVNlc3Npb24uZ2V0Um9vdEFzSW5mZXJlbmNlU2Vzc2lvbihmYikubW9kZWwoKSE7XG4gICAgY29uc3QgaXJWZXJzaW9uID0gTG9uZ1V0aWwubG9uZ1RvTnVtYmVyKG9ydE1vZGVsLmlyVmVyc2lvbigpKTtcbiAgICBpZiAoaXJWZXJzaW9uIDwgMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbmx5IHN1cHBvcnQgT05OWCBtb2RlbCB3aXRoIElSX1ZFUlNJT04+PTMnKTtcbiAgICB9XG4gICAgdGhpcy5fb3BzZXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcnRNb2RlbC5vcHNldEltcG9ydExlbmd0aCgpOyBpKyspIHtcbiAgICAgIGNvbnN0IG9wc2V0SWQgPSBvcnRNb2RlbC5vcHNldEltcG9ydChpKSE7XG4gICAgICB0aGlzLl9vcHNldHMucHVzaCh7ZG9tYWluOiBvcHNldElkPy5kb21haW4oKSBhcyBzdHJpbmcsIHZlcnNpb246IExvbmdVdGlsLmxvbmdUb051bWJlcihvcHNldElkLnZlcnNpb24oKSEpfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZ3JhcGggPSBHcmFwaC5mcm9tKG9ydE1vZGVsLmdyYXBoKCkhLCBncmFwaEluaXRpYWxpemVyKTtcbiAgfVxuXG4gIHByaXZhdGUgX2dyYXBoOiBHcmFwaDtcbiAgZ2V0IGdyYXBoKCk6IEdyYXBoIHtcbiAgICByZXR1cm4gdGhpcy5fZ3JhcGg7XG4gIH1cblxuICBwcml2YXRlIF9vcHNldHM6IE9wU2V0W107XG4gIGdldCBvcHNldHMoKTogcmVhZG9ubHkgT3BTZXRbXSB7XG4gICAgcmV0dXJuIHRoaXMuX29wc2V0cztcbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge3Jlc29sdmVCYWNrZW5kLCBTZXNzaW9uSGFuZGxlclR5cGV9IGZyb20gJy4vYmFja2VuZCc7XG5pbXBvcnQge0V4ZWN1dGlvblBsYW59IGZyb20gJy4vZXhlY3V0aW9uLXBsYW4nO1xuaW1wb3J0IHtHcmFwaH0gZnJvbSAnLi9ncmFwaCc7XG5pbXBvcnQge1Byb2ZpbGVyfSBmcm9tICcuL2luc3RydW1lbnQnO1xuaW1wb3J0IHtNb2RlbH0gZnJvbSAnLi9tb2RlbCc7XG5pbXBvcnQge09wZXJhdG9yfSBmcm9tICcuL29wZXJhdG9ycyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi90ZW5zb3InO1xuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgU2Vzc2lvbiB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ29uZmlnIHtcbiAgICBiYWNrZW5kSGludD86IHN0cmluZztcbiAgICBwcm9maWxlcj86IFByb2ZpbGVyLkNvbmZpZztcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgQ29udGV4dCB7XG4gICAgcHJvZmlsZXI6IFJlYWRvbmx5PFByb2ZpbGVyPjtcbiAgICBncmFwaElucHV0VHlwZXM/OiBUZW5zb3IuRGF0YVR5cGVbXTtcbiAgICBncmFwaElucHV0RGltcz86IEFycmF5PHJlYWRvbmx5IG51bWJlcltdPjtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU2Vzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogU2Vzc2lvbi5Db25maWcgPSB7fSkge1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5iYWNrZW5kSGludCA9IGNvbmZpZy5iYWNrZW5kSGludDtcbiAgICB0aGlzLnByb2ZpbGVyID0gUHJvZmlsZXIuY3JlYXRlKGNvbmZpZy5wcm9maWxlcik7XG4gICAgdGhpcy5jb250ZXh0ID0ge3Byb2ZpbGVyOiB0aGlzLnByb2ZpbGVyLCBncmFwaElucHV0VHlwZXM6IFtdLCBncmFwaElucHV0RGltczogW119O1xuICB9XG5cbiAgZ2V0IGlucHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLl9tb2RlbC5ncmFwaC5nZXRJbnB1dE5hbWVzKCk7XG4gIH1cbiAgZ2V0IG91dHB1dE5hbWVzKCk6IHJlYWRvbmx5IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWwuZ3JhcGguZ2V0T3V0cHV0TmFtZXMoKTtcbiAgfVxuXG4gIHN0YXJ0UHJvZmlsaW5nKCkge1xuICAgIHRoaXMucHJvZmlsZXIuc3RhcnQoKTtcbiAgfVxuXG4gIGVuZFByb2ZpbGluZygpIHtcbiAgICB0aGlzLnByb2ZpbGVyLnN0b3AoKTtcbiAgfVxuXG4gIGFzeW5jIGxvYWRNb2RlbCh1cmk6IHN0cmluZyk6IFByb21pc2U8dm9pZD47XG4gIGFzeW5jIGxvYWRNb2RlbChidWZmZXI6IEFycmF5QnVmZmVyLCBieXRlT2Zmc2V0PzogbnVtYmVyLCBsZW5ndGg/OiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+O1xuICBhc3luYyBsb2FkTW9kZWwoYnVmZmVyOiBVaW50OEFycmF5KTogUHJvbWlzZTx2b2lkPjtcbiAgYXN5bmMgbG9hZE1vZGVsKGFyZzogc3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXksIGJ5dGVPZmZzZXQ/OiBudW1iZXIsIGxlbmd0aD86IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMucHJvZmlsZXIuZXZlbnQoJ3Nlc3Npb24nLCAnU2Vzc2lvbi5sb2FkTW9kZWwnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyByZXNvbHZlIGJhY2tlbmQgYW5kIHNlc3Npb24gaGFuZGxlclxuICAgICAgY29uc3QgYmFja2VuZCA9IGF3YWl0IHJlc29sdmVCYWNrZW5kKHRoaXMuYmFja2VuZEhpbnQpO1xuICAgICAgdGhpcy5zZXNzaW9uSGFuZGxlciA9IGJhY2tlbmQuY3JlYXRlU2Vzc2lvbkhhbmRsZXIodGhpcy5jb250ZXh0KTtcblxuICAgICAgdGhpcy5fbW9kZWwgPSBuZXcgTW9kZWwoKTtcbiAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBpc09ydEZvcm1hdCA9IGFyZy5lbmRzV2l0aCgnLm9ydCcpO1xuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlKSB7XG4gICAgICAgICAgLy8gbm9kZVxuICAgICAgICAgIGNvbnN0IHtyZWFkRmlsZX0gPSByZXF1aXJlKCdub2RlOmZzL3Byb21pc2VzJyk7XG4gICAgICAgICAgY29uc3QgYnVmID0gYXdhaXQgcmVhZEZpbGUoYXJnKTtcbiAgICAgICAgICB0aGlzLmluaXRpYWxpemUoYnVmLCBpc09ydEZvcm1hdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYnJvd3NlclxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYXJnKTtcbiAgICAgICAgICBjb25zdCBidWYgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZShuZXcgVWludDhBcnJheShidWYpLCBpc09ydEZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyhhcmcpKSB7XG4gICAgICAgIC8vIGxvYWQgbW9kZWwgZnJvbSBBcnJheUJ1ZmZlclxuICAgICAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShhcmcsIGJ5dGVPZmZzZXQgfHwgMCwgbGVuZ3RoIHx8IGFyZy5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKGFycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBsb2FkIG1vZGVsIGZyb20gVWludDhhcnJheVxuICAgICAgICB0aGlzLmluaXRpYWxpemUoYXJnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdGlhbGl6ZShtb2RlbFByb3RvQmxvYjogVWludDhBcnJheSwgaXNPcnRGb3JtYXQ/OiBib29sZWFuKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscmVhZHkgaW5pdGlhbGl6ZWQnKTtcbiAgICB9XG5cbiAgICB0aGlzLnByb2ZpbGVyLmV2ZW50KCdzZXNzaW9uJywgJ1Nlc3Npb24uaW5pdGlhbGl6ZScsICgpID0+IHtcbiAgICAgIC8vIGxvYWQgZ3JhcGhcbiAgICAgIGNvbnN0IGdyYXBoSW5pdGlhbGl6ZXIgPVxuICAgICAgICAgIHRoaXMuc2Vzc2lvbkhhbmRsZXIudHJhbnNmb3JtR3JhcGggPyB0aGlzLnNlc3Npb25IYW5kbGVyIGFzIEdyYXBoLkluaXRpYWxpemVyIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fbW9kZWwubG9hZChtb2RlbFByb3RvQmxvYiwgZ3JhcGhJbml0aWFsaXplciwgaXNPcnRGb3JtYXQpO1xuXG4gICAgICAvLyBncmFwaCBpcyBjb21wbGV0ZWx5IGluaXRpYWx6aWVkIGF0IHRoaXMgc3RhZ2UgLCBsZXQgdGhlIGludGVyZXN0ZWQgaGFuZGxlcnMga25vd1xuICAgICAgaWYgKHRoaXMuc2Vzc2lvbkhhbmRsZXIub25HcmFwaEluaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbkhhbmRsZXIub25HcmFwaEluaXRpYWxpemVkKHRoaXMuX21vZGVsLmdyYXBoKTtcbiAgICAgIH1cbiAgICAgIC8vIGluaXRpYWxpemUgZWFjaCBvcGVyYXRvciBpbiB0aGUgZ3JhcGhcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZU9wcyh0aGlzLl9tb2RlbC5ncmFwaCk7XG5cbiAgICAgIC8vIGluc3RhbnRpYXRlIGFuIEV4ZWN1dGlvblBsYW4gb2JqZWN0IHRvIGJlIHVzZWQgYnkgdGhlIFNlc3Npb24gb2JqZWN0XG4gICAgICB0aGlzLl9leGVjdXRpb25QbGFuID0gbmV3IEV4ZWN1dGlvblBsYW4odGhpcy5fbW9kZWwuZ3JhcGgsIHRoaXMuX29wcywgdGhpcy5wcm9maWxlcik7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gIH1cblxuICBhc3luYyBydW4oaW5wdXRzOiBNYXA8c3RyaW5nLCBUZW5zb3I+fFRlbnNvcltdKTogUHJvbWlzZTxNYXA8c3RyaW5nLCBUZW5zb3I+PiB7XG4gICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXNzaW9uIG5vdCBpbml0aWFsaXplZCB5ZXQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wcm9maWxlci5ldmVudCgnc2Vzc2lvbicsICdTZXNzaW9uLnJ1bicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGlucHV0VGVuc29ycyA9IHRoaXMubm9ybWFsaXplQW5kVmFsaWRhdGVJbnB1dHMoaW5wdXRzKTtcblxuICAgICAgY29uc3Qgb3V0cHV0VGVuc29ycyA9IGF3YWl0IHRoaXMuX2V4ZWN1dGlvblBsYW4uZXhlY3V0ZSh0aGlzLnNlc3Npb25IYW5kbGVyLCBpbnB1dFRlbnNvcnMpO1xuXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVPdXRwdXQob3V0cHV0VGVuc29ycyk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIG5vcm1hbGl6ZUFuZFZhbGlkYXRlSW5wdXRzKGlucHV0czogTWFwPHN0cmluZywgVGVuc29yPnxUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgICBjb25zdCBtb2RlbElucHV0TmFtZXMgPSB0aGlzLl9tb2RlbC5ncmFwaC5nZXRJbnB1dE5hbWVzKCk7XG5cbiAgICAvLyBub3JtYWxpemUgaW5wdXRzXG4gICAgLy8gaW5wdXRzOiBUZW5zb3JbXVxuICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0cykpIHtcbiAgICAgIGlmIChpbnB1dHMubGVuZ3RoICE9PSBtb2RlbElucHV0TmFtZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5jb3JyZWN0IGlucHV0IGFycmF5IGxlbmd0aDogZXhwZWN0ZWQgJHttb2RlbElucHV0TmFtZXMubGVuZ3RofSBidXQgZ290ICR7aW5wdXRzLmxlbmd0aH1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gY29udmVydCBtYXAgdG8gYXJyYXlcbiAgICAvLyBpbnB1dHM6IE1hcDxzdHJpbmcsIFRlbnNvcj5cbiAgICBlbHNlIHtcbiAgICAgIGlmIChpbnB1dHMuc2l6ZSAhPT0gbW9kZWxJbnB1dE5hbWVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGluY29ycmVjdCBpbnB1dCBtYXAgc2l6ZTogZXhwZWN0ZWQgJHttb2RlbElucHV0TmFtZXMubGVuZ3RofSBidXQgZ290ICR7aW5wdXRzLnNpemV9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNvcnRlZElucHV0cyA9IG5ldyBBcnJheTxUZW5zb3I+KGlucHV0cy5zaXplKTtcbiAgICAgIGxldCBzb3J0ZWRJbnB1dHNJbmRleCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGVsSW5wdXROYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCB0ZW5zb3IgPSBpbnB1dHMuZ2V0KG1vZGVsSW5wdXROYW1lc1tpXSk7XG4gICAgICAgIGlmICghdGVuc29yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIGlucHV0IHRlbnNvciBmb3I6ICcke25hbWV9J2ApO1xuICAgICAgICB9XG4gICAgICAgIHNvcnRlZElucHV0c1tzb3J0ZWRJbnB1dHNJbmRleCsrXSA9IHRlbnNvcjtcbiAgICAgIH1cblxuICAgICAgaW5wdXRzID0gc29ydGVkSW5wdXRzO1xuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIGRpbXMgcmVxdWlyZW1lbnRzXG4gICAgLy8gRmlyc3Qgc2Vzc2lvbiBydW4gLSBncmFwaCBpbnB1dCBkYXRhIGlzIG5vdCBjYWNoZWQgZm9yIHRoZSBzZXNzaW9uXG4gICAgaWYgKCF0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dFR5cGVzIHx8IHRoaXMuY29udGV4dC5ncmFwaElucHV0VHlwZXMubGVuZ3RoID09PSAwIHx8ICF0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dERpbXMgfHxcbiAgICAgICAgdGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3QgbW9kZWxJbnB1dEluZGljZXMgPSB0aGlzLl9tb2RlbC5ncmFwaC5nZXRJbnB1dEluZGljZXMoKTtcbiAgICAgIGNvbnN0IG1vZGVsVmFsdWVzID0gdGhpcy5fbW9kZWwuZ3JhcGguZ2V0VmFsdWVzKCk7XG5cbiAgICAgIGNvbnN0IGdyYXBoSW5wdXREaW1zID0gbmV3IEFycmF5PHJlYWRvbmx5IG51bWJlcltdPihtb2RlbElucHV0SW5kaWNlcy5sZW5ndGgpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGVsSW5wdXRJbmRpY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGdyYXBoSW5wdXQgPSBtb2RlbFZhbHVlc1ttb2RlbElucHV0SW5kaWNlc1tpXV07XG4gICAgICAgIGdyYXBoSW5wdXREaW1zW2ldID0gZ3JhcGhJbnB1dC50eXBlIS5zaGFwZS5kaW1zO1xuXG4gICAgICAgIC8vIGNhY2hlZCBmb3Igc2Vjb25kIGFuZCBzdWJzZXF1ZW50IHJ1bnMuXG4gICAgICAgIC8vIFNvbWUgcGFydHMgb2YgdGhlIGZyYW1ld29yayB3b3JrcyBvbiB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoZSBncmFwaCBhbmQgdHlwZXMgYW5kIHNoYXBlcyBhcmUgc3RhdGljXG4gICAgICAgIHRoaXMuY29udGV4dC5ncmFwaElucHV0VHlwZXMhLnB1c2goZ3JhcGhJbnB1dC50eXBlIS50ZW5zb3JUeXBlKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmdyYXBoSW5wdXREaW1zIS5wdXNoKGlucHV0c1tpXS5kaW1zKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy52YWxpZGF0ZUlucHV0VGVuc29yRGltcyhncmFwaElucHV0RGltcywgaW5wdXRzLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBTZWNvbmQgYW5kIHN1YnNlcXVlbnQgc2Vzc2lvbiBydW5zIC0gZ3JhcGggaW5wdXQgZGF0YSBpcyBjYWNoZWQgZm9yIHRoZSBzZXNzaW9uXG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnZhbGlkYXRlSW5wdXRUZW5zb3JEaW1zKHRoaXMuY29udGV4dC5ncmFwaElucHV0RGltcywgaW5wdXRzLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLy8gdmFsaWRhdGUgdHlwZXMgcmVxdWlyZW1lbnRcbiAgICB0aGlzLnZhbGlkYXRlSW5wdXRUZW5zb3JUeXBlcyh0aGlzLmNvbnRleHQuZ3JhcGhJbnB1dFR5cGVzISwgaW5wdXRzKTtcblxuICAgIHJldHVybiBpbnB1dHM7XG4gIH1cblxuICBwcml2YXRlIHZhbGlkYXRlSW5wdXRUZW5zb3JUeXBlcyhncmFwaElucHV0VHlwZXM6IFRlbnNvci5EYXRhVHlwZVtdLCBnaXZlbklucHV0czogVGVuc29yW10pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdpdmVuSW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBleHBlY3RlZFR5cGUgPSBncmFwaElucHV0VHlwZXNbaV07XG4gICAgICBjb25zdCBhY3R1YWxUeXBlID0gZ2l2ZW5JbnB1dHNbaV0udHlwZTtcbiAgICAgIGlmIChleHBlY3RlZFR5cGUgIT09IGFjdHVhbFR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnB1dCB0ZW5zb3JbJHtpfV0gY2hlY2sgZmFpbGVkOiBleHBlY3RlZCB0eXBlICcke2V4cGVjdGVkVHlwZX0nIGJ1dCBnb3QgJHthY3R1YWxUeXBlfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdmFsaWRhdGVJbnB1dFRlbnNvckRpbXMoXG4gICAgICBncmFwaElucHV0RGltczogQXJyYXk8cmVhZG9ubHkgbnVtYmVyW10+LCBnaXZlbklucHV0czogVGVuc29yW10sIG5vbmVEaW1TdXBwb3J0ZWQ6IGJvb2xlYW4pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdpdmVuSW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBleHBlY3RlZERpbXMgPSBncmFwaElucHV0RGltc1tpXTtcbiAgICAgIGNvbnN0IGFjdHVhbERpbXMgPSBnaXZlbklucHV0c1tpXS5kaW1zO1xuICAgICAgaWYgKCF0aGlzLmNvbXBhcmVUZW5zb3JEaW1zKGV4cGVjdGVkRGltcywgYWN0dWFsRGltcywgbm9uZURpbVN1cHBvcnRlZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnB1dCB0ZW5zb3JbJHtpfV0gY2hlY2sgZmFpbGVkOiBleHBlY3RlZCBzaGFwZSAnWyR7ZXhwZWN0ZWREaW1zLmpvaW4oJywnKX1dJyBidXQgZ290IFske1xuICAgICAgICAgICAgYWN0dWFsRGltcy5qb2luKCcsJyl9XWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY29tcGFyZVRlbnNvckRpbXMoZXhwZWN0ZWREaW1zOiByZWFkb25seSBudW1iZXJbXSwgYWN0dWFsRGltczogcmVhZG9ubHkgbnVtYmVyW10sIG5vbmVEaW1TdXBwb3J0ZWQ6IGJvb2xlYW4pOlxuICAgICAgYm9vbGVhbiB7XG4gICAgaWYgKGV4cGVjdGVkRGltcy5sZW5ndGggIT09IGFjdHVhbERpbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHBlY3RlZERpbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChleHBlY3RlZERpbXNbaV0gIT09IGFjdHVhbERpbXNbaV0gJiYgKCFub25lRGltU3VwcG9ydGVkIHx8IGV4cGVjdGVkRGltc1tpXSAhPT0gMCkpIHtcbiAgICAgICAgLy8gZGF0YSBzaGFwZSBtaXMtbWF0Y2ggQU5EIG5vdCBhICdOb25lJyBkaW1lbnNpb24uXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlT3V0cHV0KG91dHB1dFRlbnNvcnM6IFRlbnNvcltdKTogTWFwPHN0cmluZywgVGVuc29yPiB7XG4gICAgY29uc3QgbW9kZWxPdXRwdXROYW1lcyA9IHRoaXMuX21vZGVsLmdyYXBoLmdldE91dHB1dE5hbWVzKCk7XG4gICAgaWYgKG91dHB1dFRlbnNvcnMubGVuZ3RoICE9PSBtb2RlbE91dHB1dE5hbWVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBudW1iZXIgb2Ygb3V0cHV0cyBkbyBub3QgbWF0Y2ggbnVtYmVyIG9mIGdlbmVyYXRlZCBvdXRwdXRzJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0cHV0ID0gbmV3IE1hcDxzdHJpbmcsIFRlbnNvcj4oKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGVsT3V0cHV0TmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIG91dHB1dC5zZXQobW9kZWxPdXRwdXROYW1lc1tpXSwgb3V0cHV0VGVuc29yc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdGlhbGl6ZU9wcyhncmFwaDogR3JhcGgpOiB2b2lkIHtcbiAgICBjb25zdCBub2RlcyA9IGdyYXBoLmdldE5vZGVzKCk7XG4gICAgdGhpcy5fb3BzID0gbmV3IEFycmF5KG5vZGVzLmxlbmd0aCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9vcHNbaV0gPSB0aGlzLnNlc3Npb25IYW5kbGVyLnJlc29sdmUobm9kZXNbaV0sIHRoaXMuX21vZGVsLm9wc2V0cywgZ3JhcGgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX21vZGVsOiBNb2RlbDtcbiAgcHJpdmF0ZSBfaW5pdGlhbGl6ZWQ6IGJvb2xlYW47XG5cbiAgcHJpdmF0ZSBfb3BzOiBPcGVyYXRvcltdO1xuICBwcml2YXRlIF9leGVjdXRpb25QbGFuOiBFeGVjdXRpb25QbGFuO1xuXG4gIHByaXZhdGUgYmFja2VuZEhpbnQ/OiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSBzZXNzaW9uSGFuZGxlcjogU2Vzc2lvbkhhbmRsZXJUeXBlO1xuICBwcml2YXRlIGNvbnRleHQ6IFNlc3Npb24uQ29udGV4dDtcbiAgcHJpdmF0ZSBwcm9maWxlcjogUmVhZG9ubHk8UHJvZmlsZXI+O1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0luZmVyZW5jZVNlc3Npb24sIEluZmVyZW5jZVNlc3Npb25IYW5kbGVyLCBTZXNzaW9uSGFuZGxlciwgVGVuc29yfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQge1Nlc3Npb259IGZyb20gJy4vc2Vzc2lvbic7XG5pbXBvcnQge1RlbnNvciBhcyBPbm54anNUZW5zb3J9IGZyb20gJy4vdGVuc29yJztcblxuZXhwb3J0IGNsYXNzIE9ubnhqc1Nlc3Npb25IYW5kbGVyIGltcGxlbWVudHMgSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHNlc3Npb246IFNlc3Npb24pIHtcbiAgICB0aGlzLmlucHV0TmFtZXMgPSB0aGlzLnNlc3Npb24uaW5wdXROYW1lcztcbiAgICB0aGlzLm91dHB1dE5hbWVzID0gdGhpcy5zZXNzaW9uLm91dHB1dE5hbWVzO1xuICB9XG5cbiAgYXN5bmMgZGlzcG9zZSgpOiBQcm9taXNlPHZvaWQ+IHt9XG4gIGlucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuICBvdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG4gIGFzeW5jIHJ1bihcbiAgICAgIGZlZWRzOiBTZXNzaW9uSGFuZGxlci5GZWVkc1R5cGUsIF9mZXRjaGVzOiBTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSxcbiAgICAgIF9vcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPFNlc3Npb25IYW5kbGVyLlJldHVyblR5cGU+IHtcbiAgICBjb25zdCBpbnB1dE1hcCA9IG5ldyBNYXA8c3RyaW5nLCBPbm54anNUZW5zb3I+KCk7XG4gICAgZm9yIChjb25zdCBuYW1lIGluIGZlZWRzKSB7XG4gICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoZmVlZHMsIG5hbWUpKSB7XG4gICAgICAgIGNvbnN0IGZlZWQgPSBmZWVkc1tuYW1lXTtcbiAgICAgICAgaW5wdXRNYXAuc2V0KFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIG5ldyBPbm54anNUZW5zb3IoXG4gICAgICAgICAgICAgICAgZmVlZC5kaW1zLCBmZWVkLnR5cGUgYXMgT25ueGpzVGVuc29yLkRhdGFUeXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBmZWVkLmRhdGEgYXMgT25ueGpzVGVuc29yLk51bWJlclR5cGUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0TWFwID0gYXdhaXQgdGhpcy5zZXNzaW9uLnJ1bihpbnB1dE1hcCk7XG4gICAgY29uc3Qgb3V0cHV0OiBTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlID0ge307XG4gICAgb3V0cHV0TWFwLmZvckVhY2goKHRlbnNvciwgbmFtZSkgPT4ge1xuICAgICAgb3V0cHV0W25hbWVdID0gbmV3IFRlbnNvcih0ZW5zb3IudHlwZSwgdGVuc29yLmRhdGEsIHRlbnNvci5kaW1zKTtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIHN0YXJ0UHJvZmlsaW5nKCk6IHZvaWQge1xuICAgIHRoaXMuc2Vzc2lvbi5zdGFydFByb2ZpbGluZygpO1xuICB9XG4gIGVuZFByb2ZpbGluZygpOiB2b2lkIHtcbiAgICB0aGlzLnNlc3Npb24uZW5kUHJvZmlsaW5nKCk7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLWludGVybmFsLW1vZHVsZXMgKi9cbmltcG9ydCB7QmFja2VuZCwgSW5mZXJlbmNlU2Vzc2lvbiwgSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXJ9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7U2Vzc2lvbn0gZnJvbSAnLi9vbm54anMvc2Vzc2lvbic7XG5pbXBvcnQge09ubnhqc1Nlc3Npb25IYW5kbGVyfSBmcm9tICcuL29ubnhqcy9zZXNzaW9uLWhhbmRsZXItaW5mZXJlbmNlJztcblxuY2xhc3MgT25ueGpzQmFja2VuZCBpbXBsZW1lbnRzIEJhY2tlbmQge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gIGFzeW5jIGluaXQoKTogUHJvbWlzZTx2b2lkPiB7fVxuXG4gIGFzeW5jIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKHBhdGhPckJ1ZmZlcjogc3RyaW5nfFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTpcbiAgICAgIFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXI+IHtcbiAgICAvLyBOT1RFOiBTZXNzaW9uLkNvbmZpZyhmcm9tIG9ubnguanMpIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyhmcm9tXG4gICAgLy8gb25ueHJ1bnRpbWUtY29tbW9uKS5cbiAgICAvLyAgICAgICBJbiBmdXR1cmUgd2Ugc2hvdWxkIHJlbW92ZSBTZXNzaW9uLkNvbmZpZyBhbmQgdXNlIEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMuXG4gICAgLy8gICAgICAgQ3VycmVudGx5IHdlIGFsbG93IHRoaXMgdG8gaGFwcGVuIHRvIG1ha2UgdGVzdCBydW5uZXIgd29yay5cbiAgICBjb25zdCBzZXNzaW9uID0gbmV3IFNlc3Npb24ob3B0aW9ucyBhcyB1bmtub3duIGFzIFNlc3Npb24uQ29uZmlnKTtcblxuICAgIC8vIHR5cGVzY3JpcHQgY2Fubm90IG1lcmdlIG1ldGhvZCBvdmVycmlkZSBjb3JyZWN0bHkgKHNvIGZhciBpbiA0LjIuMykuIG5lZWQgaWYtZWxzZSB0byBjYWxsIHRoZSBtZXRob2QuXG4gICAgaWYgKHR5cGVvZiBwYXRoT3JCdWZmZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhd2FpdCBzZXNzaW9uLmxvYWRNb2RlbChwYXRoT3JCdWZmZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCBzZXNzaW9uLmxvYWRNb2RlbChwYXRoT3JCdWZmZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgT25ueGpzU2Vzc2lvbkhhbmRsZXIoc2Vzc2lvbik7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG9ubnhqc0JhY2tlbmQgPSBuZXcgT25ueGpzQmFja2VuZCgpO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5leHBvcnQgY29uc3QgaXNOb2RlID0gISEodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlKTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLy8vIDxyZWZlcmVuY2UgbGliPVwid2Vid29ya2VyXCIgLz5cblxuLy9cbi8vICogdHlwZSBoYWNrIGZvciBcIkhUTUxJbWFnZUVsZW1lbnRcIlxuLy9cbi8vIGluIHR5cGVzY3JpcHQsIHRoZSB0eXBlIG9mIFwiSFRNTEltYWdlRWxlbWVudFwiIGlzIGRlZmluZWQgaW4gbGliLmRvbS5kLnRzLCB3aGljaCBpcyBjb25mbGljdCB3aXRoIGxpYi53ZWJ3b3JrZXIuZC50cy5cbi8vIHdoZW4gd2UgdXNlIHdlYndvcmtlciwgdGhlIGxpYi53ZWJ3b3JrZXIuZC50cyB3aWxsIGJlIHVzZWQsIHdoaWNoIGRvZXMgbm90IGhhdmUgSFRNTEltYWdlRWxlbWVudCBkZWZpbmVkLlxuLy9cbi8vIHdlIHdpbGwgZ2V0IHRoZSBmb2xsb3dpbmcgZXJyb3JzIGNvbXBsYWluaW5nIHRoYXQgSFRNTEltYWdlRWxlbWVudCBpcyBub3QgZGVmaW5lZDpcbi8vXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy9cbi8vIC4uL2NvbW1vbi9kaXN0L2Nqcy90ZW5zb3ItZmFjdG9yeS5kLnRzOjE4NzoyOSAtIGVycm9yIFRTMjU1MjogQ2Fubm90IGZpbmQgbmFtZSAnSFRNTEltYWdlRWxlbWVudCcuIERpZCB5b3UgbWVhblxuLy8gJ0hUTUxMSUVsZW1lbnQnP1xuLy9cbi8vIDE4NyAgICAgZnJvbUltYWdlKGltYWdlRWxlbWVudDogSFRNTEltYWdlRWxlbWVudCwgb3B0aW9ucz86IFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zKTpcbi8vIFByb21pc2U8VHlwZWRUZW5zb3I8J2Zsb2F0MzInPiB8IFR5cGVkVGVuc29yPCd1aW50OCc+Pjtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfn5+fn5+fn5+fn5+fn5+flxuLy9cbi8vIG5vZGVfbW9kdWxlcy9Ad2ViZ3B1L3R5cGVzL2Rpc3QvaW5kZXguZC50czo4Mzo3IC0gZXJyb3IgVFMyNTUyOiBDYW5ub3QgZmluZCBuYW1lICdIVE1MSW1hZ2VFbGVtZW50Jy4gRGlkIHlvdSBtZWFuXG4vLyAnSFRNTExJRWxlbWVudCc/XG4vL1xuLy8gODMgICAgIHwgSFRNTEltYWdlRWxlbWVudFxuLy8gICAgICAgICAgfn5+fn5+fn5+fn5+fn5+flxuLy9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vL1xuLy8gYEhUTUxJbWFnZUVsZW1lbnRgIGlzIG9ubHkgdXNlZCBpbiB0eXBlIGRlY2xhcmF0aW9uIGFuZCBub3QgaW4gcmVhbCBjb2RlLiBTbyB3ZSBkZWZpbmUgaXQgYXMgYHVua25vd25gIGhlcmUgdG9cbi8vIGJ5cGFzcyB0aGUgdHlwZSBjaGVjay5cblxuLy9cbi8vICogdHlwZSBoYWNrIGZvciBcImRvY3VtZW50XCJcbi8vXG4vLyBpbiB0eXBlc2NyaXB0LCB0aGUgdHlwZSBvZiBcImRvY3VtZW50XCIgaXMgZGVmaW5lZCBpbiBsaWIuZG9tLmQudHMsIHNvIGl0J3Mgbm90IGF2YWlsYWJsZSBpbiB3ZWJ3b3JrZXIuXG4vL1xuLy8gd2Ugd2lsbCBnZXQgdGhlIGZvbGxvd2luZyBlcnJvcnMgY29tcGxhaW5pbmcgdGhhdCBkb2N1bWVudCBpcyBub3QgZGVmaW5lZDpcbi8vXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy9cbi8vIGxpYi93YXNtL3dhc20tdXRpbHMtaW1wb3J0LnRzOjc6MzMgLSBlcnJvciBUUzI1ODQ6IENhbm5vdCBmaW5kIG5hbWUgJ2RvY3VtZW50Jy4gRG8geW91IG5lZWQgdG8gY2hhbmdlIHlvdXIgdGFyZ2V0XG4vLyBsaWJyYXJ5PyBUcnkgY2hhbmdpbmcgdGhlICdsaWInIGNvbXBpbGVyIG9wdGlvbiB0byBpbmNsdWRlICdkb20nLlxuLy9cbi8vIDcgZXhwb3J0IGNvbnN0IHNjcmlwdFNyYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyAoZG9jdW1lbnQ/LmN1cnJlbnRTY3JpcHQgYXMgSFRNTFNjcmlwdEVsZW1lbnQpPy5zcmMgOlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH5+fn5+fn5+XG4vL1xuLy8gbGliL3dhc20vd2FzbS11dGlscy1pbXBvcnQudHM6Nzo2MSAtIGVycm9yIFRTMjU4NDogQ2Fubm90IGZpbmQgbmFtZSAnZG9jdW1lbnQnLiBEbyB5b3UgbmVlZCB0byBjaGFuZ2UgeW91ciB0YXJnZXRcbi8vIGxpYnJhcnk/IFRyeSBjaGFuZ2luZyB0aGUgJ2xpYicgY29tcGlsZXIgb3B0aW9uIHRvIGluY2x1ZGUgJ2RvbScuXG4vL1xuLy8gNyBleHBvcnQgY29uc3Qgc2NyaXB0U3JjID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IChkb2N1bWVudD8uY3VycmVudFNjcmlwdCBhcyBIVE1MU2NyaXB0RWxlbWVudCk/LnNyYyA6XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH5+fn5+fn5+XG4vL1xuLy8gbGliL3dhc20vd2FzbS11dGlscy1pbXBvcnQudHM6Nzo4OCAtIGVycm9yIFRTMjU1MjogQ2Fubm90IGZpbmQgbmFtZSAnSFRNTFNjcmlwdEVsZW1lbnQnLiBEaWQgeW91IG1lYW5cbi8vICdIVE1MTElFbGVtZW50Jz9cbi8vXG4vLyA3IGV4cG9ydCBjb25zdCBzY3JpcHRTcmMgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gKGRvY3VtZW50Py5jdXJyZW50U2NyaXB0IGFzIEhUTUxTY3JpcHRFbGVtZW50KT8uc3JjIDpcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfn5+fn5+fn5+fn5+fn5+fn5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vL1xuLy8gYGRvY3VtZW50YCBpcyB1c2VkIHRvIGdldCB0aGUgY3VycmVudCBzY3JpcHQgVVJMLCB3aGljaCBpcyBub3QgYXZhaWxhYmxlIGluIHdlYndvcmtlci4gVGhpcyBmaWxlIGlzIHNlcnZlZCBhcyBhXG4vLyBcImR1YWxcIiBmaWxlIGZvciBlbnRyaWVzIG9mIGJvdGggd2Vid29ya2VyIGFuZCB0aGUgZXNtIG1vZHVsZS5cbi8vXG5kZWNsYXJlIGdsb2JhbCB7XG4gIHR5cGUgSFRNTEltYWdlRWxlbWVudCA9IHVua25vd247XG4gIHR5cGUgSFRNTFNjcmlwdEVsZW1lbnQgPSB7c3JjPzogc3RyaW5nfTtcbiAgY29uc3QgZG9jdW1lbnQ6IHVuZGVmaW5lZHx7Y3VycmVudFNjcmlwdD86IEhUTUxTY3JpcHRFbGVtZW50fTtcbn1cblxuLyoqXG4gKiBAc3VtbWFyeVxuICpcbiAqIFRoaXMgZmlsZSBpcyBzZXJ2ZWQgYXMgYSBcImR1YWxcIiBmaWxlIGZvciBib3RoIGVudHJpZXMgb2YgdGhlIGZvbGxvd2luZzpcbiAqIC0gVGhlIHByb3h5IHdvcmtlciBpdHNlbGYuXG4gKiAgIC0gV2hlbiB1c2VkIGFzIGEgd29ya2VyLCBpdCBsaXN0ZW5zIHRvIHRoZSBtZXNzYWdlcyBmcm9tIHRoZSBtYWluIHRocmVhZCBhbmQgcGVyZm9ybXMgdGhlIGNvcnJlc3BvbmRpbmcgb3BlcmF0aW9ucy5cbiAqICAgLSBTaG91bGQgYmUgaW1wb3J0ZWQgZGlyZWN0bHkgdXNpbmcgYG5ldyBXb3JrZXIoKWAgaW4gdGhlIG1haW4gdGhyZWFkLlxuICpcbiAqIC0gVGhlIEVTTSBtb2R1bGUgdGhhdCBjcmVhdGVzIHRoZSBwcm94eSB3b3JrZXIgKGFzIGEgd29ya2VyIGxhdW5jaGVyKS5cbiAqICAgLSBXaGVuIHVzZWQgYXMgYSB3b3JrZXIgbGF1bmNoZXIsIGl0IGNyZWF0ZXMgdGhlIHByb3h5IHdvcmtlciBhbmQgcmV0dXJucyBpdC5cbiAqICAgLSBTaG91bGQgYmUgaW1wb3J0ZWQgdXNpbmcgYGltcG9ydCgpYCBpbiB0aGUgbWFpbiB0aHJlYWQsIHdpdGggdGhlIHF1ZXJ5IHBhcmFtZXRlciBgaW1wb3J0PTFgLlxuICpcbiAqIFRoaXMgZmlsZSB3aWxsIGJlIGFsd2F5cyBjb21waWxpbmcgaW50byBFU00gZm9ybWF0LlxuICovXG5cbmltcG9ydCB0eXBlIHtPcnRXYXNtTWVzc2FnZSwgU2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGF9IGZyb20gJy4uL3Byb3h5LW1lc3NhZ2VzLmpzJztcbmltcG9ydCB7Y3JlYXRlU2Vzc2lvbiwgY29weUZyb21FeHRlcm5hbEJ1ZmZlciwgZW5kUHJvZmlsaW5nLCBleHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycywgaW5pdEVwLCBpbml0UnVudGltZSwgcmVsZWFzZVNlc3Npb24sIHJ1bn0gZnJvbSAnLi4vd2FzbS1jb3JlLWltcGwuanMnO1xuaW1wb3J0IHtpbml0aWFsaXplV2ViQXNzZW1ibHl9IGZyb20gJy4uL3dhc20tZmFjdG9yeS5qcyc7XG5pbXBvcnQge3NjcmlwdFNyY30gZnJvbSAnLi4vd2FzbS11dGlscy1pbXBvcnQuanMnO1xuXG5jb25zdCBXT1JLRVJfTkFNRSA9ICdvcnQtd2FzbS1wcm94eS13b3JrZXInO1xuY29uc3QgaXNQcm94eVdvcmtlciA9IGdsb2JhbFRoaXMuc2VsZj8ubmFtZSA9PT0gV09SS0VSX05BTUU7XG5cbmlmIChpc1Byb3h5V29ya2VyKSB7XG4gIC8vIFdvcmtlciB0aHJlYWRcbiAgc2VsZi5vbm1lc3NhZ2UgPSAoZXY6IE1lc3NhZ2VFdmVudDxPcnRXYXNtTWVzc2FnZT4pOiB2b2lkID0+IHtcbiAgICBjb25zdCB7dHlwZSwgaW4gOiBtZXNzYWdlfSA9IGV2LmRhdGE7XG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdpbml0LXdhc20nOlxuICAgICAgICAgIGluaXRpYWxpemVXZWJBc3NlbWJseShtZXNzYWdlIS53YXNtKVxuICAgICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdFJ1bnRpbWUobWVzc2FnZSEpLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHt0eXBlfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2Uoe3R5cGUsIGVycn0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2Uoe3R5cGUsIGVycn0pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2luaXQtZXAnOiB7XG4gICAgICAgICAgY29uc3Qge2VwTmFtZSwgZW52fSA9IG1lc3NhZ2UhO1xuICAgICAgICAgIGluaXRFcChlbnYsIGVwTmFtZSlcbiAgICAgICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHt0eXBlfSk7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2Uoe3R5cGUsIGVycn0pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnY29weS1mcm9tJzoge1xuICAgICAgICAgIGNvbnN0IHtidWZmZXJ9ID0gbWVzc2FnZSE7XG4gICAgICAgICAgY29uc3QgYnVmZmVyRGF0YSA9IGNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIoYnVmZmVyKTtcbiAgICAgICAgICBwb3N0TWVzc2FnZSh7dHlwZSwgb3V0OiBidWZmZXJEYXRhfSBhcyBPcnRXYXNtTWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnY3JlYXRlJzoge1xuICAgICAgICAgIGNvbnN0IHttb2RlbCwgb3B0aW9uc30gPSBtZXNzYWdlITtcbiAgICAgICAgICBjcmVhdGVTZXNzaW9uKG1vZGVsLCBvcHRpb25zKVxuICAgICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgICAgIHNlc3Npb25NZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHt0eXBlLCBvdXQ6IHNlc3Npb25NZXRhZGF0YX0gYXMgT3J0V2FzbU1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHt0eXBlLCBlcnJ9KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3JlbGVhc2UnOlxuICAgICAgICAgIHJlbGVhc2VTZXNzaW9uKG1lc3NhZ2UhKTtcbiAgICAgICAgICBwb3N0TWVzc2FnZSh7dHlwZX0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdydW4nOiB7XG4gICAgICAgICAgY29uc3Qge3Nlc3Npb25JZCwgaW5wdXRJbmRpY2VzLCBpbnB1dHMsIG91dHB1dEluZGljZXMsIG9wdGlvbnN9ID0gbWVzc2FnZSE7XG4gICAgICAgICAgcnVuKHNlc3Npb25JZCwgaW5wdXRJbmRpY2VzLCBpbnB1dHMsIG91dHB1dEluZGljZXMsIG5ldyBBcnJheShvdXRwdXRJbmRpY2VzLmxlbmd0aCkuZmlsbChudWxsKSwgb3B0aW9ucylcbiAgICAgICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICAgICAgICBvdXRwdXRzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dHMuc29tZShvID0+IG9bM10gIT09ICdjcHUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHt0eXBlLCBlcnI6ICdQcm94eSBkb2VzIG5vdCBzdXBwb3J0IG5vbi1jcHUgdGVuc29yIGxvY2F0aW9uLid9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAge3R5cGUsIG91dDogb3V0cHV0c30gYXMgT3J0V2FzbU1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzKFsuLi5pbnB1dHMsIC4uLm91dHB1dHNdIGFzIFNlcmlhbGl6YWJsZVRlbnNvck1ldGFkYXRhW10pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHt0eXBlLCBlcnJ9KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2VuZC1wcm9maWxpbmcnOlxuICAgICAgICAgIGVuZFByb2ZpbGluZyhtZXNzYWdlISk7XG4gICAgICAgICAgcG9zdE1lc3NhZ2Uoe3R5cGV9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHBvc3RNZXNzYWdlKHt0eXBlLCBlcnJ9IGFzIE9ydFdhc21NZXNzYWdlKTtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzUHJveHlXb3JrZXIgP1xuICAgIG51bGwgOlxuICAgICh1cmxPdmVycmlkZT86IHN0cmluZykgPT5cbiAgICAgICAgbmV3IFdvcmtlcih1cmxPdmVycmlkZSA/PyBzY3JpcHRTcmMhLCB7dHlwZTogQlVJTERfREVGUy5JU19FU00gPyAnbW9kdWxlJyA6ICdjbGFzc2ljJywgbmFtZTogV09SS0VSX05BTUV9KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHR5cGUge09ydFdhc21Nb2R1bGV9IGZyb20gJy4vd2FzbS10eXBlcyc7XG5pbXBvcnQge2lzTm9kZX0gZnJvbSAnLi93YXNtLXV0aWxzLWVudic7XG5cbi8qKlxuICogVGhlIGNsYXNzaWMgc2NyaXB0IHNvdXJjZSBVUkwuIFRoaXMgaXMgbm90IGFsd2F5cyBhdmFpbGFibGUgaW4gbm9uIEVTTW9kdWxlIGVudmlyb25tZW50cy5cbiAqXG4gKiBJbiBOb2RlLmpzLCB0aGlzIGlzIHVuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHNjcmlwdFNyYyA9XG4gICAgLy8gaWYgTm9kZWpzLCByZXR1cm4gdW5kZWZpbmVkXG4gICAgaXNOb2RlID8gdW5kZWZpbmVkIDpcbiAgICAgICAgICAgICAvLyBpZiBJdCdzIEVTTSwgdXNlIGltcG9ydC5tZXRhLnVybFxuICAgICAgICAgICAgIEJVSUxEX0RFRlMuRVNNX0lNUE9SVF9NRVRBX1VSTCA/P1xuICAgICAgICAvLyB1c2UgYGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjYCBpZiBhdmFpbGFibGVcbiAgICAgICAgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCBhcyBIVE1MU2NyaXB0RWxlbWVudCk/LnNyYyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGBzZWxmLmxvY2F0aW9uLmhyZWZgIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmLmxvY2F0aW9uPy5ocmVmIDogdW5kZWZpbmVkKSk7XG5cbi8qKlxuICogVGhlIG9yaWdpbiBvZiB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqXG4gKiBJbiBOb2RlLmpzLCB0aGlzIGlzIHVuZGVmaW5lZC5cbiAqL1xuY29uc3Qgb3JpZ2luID0gaXNOb2RlIHx8IHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBsb2NhdGlvbi5vcmlnaW47XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGZpbGVuYW1lIHdpdGggcHJlZml4IGlzIGZyb20gdGhlIHNhbWUgb3JpZ2luLlxuICovXG5jb25zdCBpc1NhbWVPcmlnaW4gPSAoZmlsZW5hbWU6IHN0cmluZywgcHJlZml4T3ZlcnJpZGU/OiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBiYXNlVXJsID0gcHJlZml4T3ZlcnJpZGUgPz8gc2NyaXB0U3JjO1xuICAgIGNvbnN0IHVybCA9IGJhc2VVcmwgPyBuZXcgVVJMKGZpbGVuYW1lLCBiYXNlVXJsKSA6IG5ldyBVUkwoZmlsZW5hbWUpO1xuICAgIHJldHVybiB1cmwub3JpZ2luID09PSBvcmlnaW47XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGlucHV0cyB0byBhbiBhYnNvbHV0ZSBVUkwgd2l0aCB0aGUgZ2l2ZW4gcHJlZml4IG92ZXJyaWRlLiBJZiBmYWlsZWQsIHJldHVybiB1bmRlZmluZWQuXG4gKi9cbmNvbnN0IG5vcm1hbGl6ZVVybCA9IChmaWxlbmFtZTogc3RyaW5nLCBwcmVmaXhPdmVycmlkZT86IHN0cmluZykgPT4ge1xuICBjb25zdCBiYXNlVXJsID0gcHJlZml4T3ZlcnJpZGUgPz8gc2NyaXB0U3JjO1xuICB0cnkge1xuICAgIGNvbnN0IHVybCA9IGJhc2VVcmwgPyBuZXcgVVJMKGZpbGVuYW1lLCBiYXNlVXJsKSA6IG5ldyBVUkwoZmlsZW5hbWUpO1xuICAgIHJldHVybiB1cmwuaHJlZjtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBmYWxsYmFjayBVUkwgaWYgYW4gYWJzb2x1dGUgVVJMIGNhbm5vdCBiZSBjcmVhdGVkIGJ5IHRoZSBub3JtYWxpemVVcmwgZnVuY3Rpb24uXG4gKi9cbmNvbnN0IGZhbGxiYWNrVXJsID0gKGZpbGVuYW1lOiBzdHJpbmcsIHByZWZpeE92ZXJyaWRlPzogc3RyaW5nKSA9PiBgJHtwcmVmaXhPdmVycmlkZSA/PyAnLi8nfSR7ZmlsZW5hbWV9YDtcblxuLyoqXG4gKiBUaGlzIGhlbHBlciBmdW5jdGlvbiBpcyB1c2VkIHRvIHByZWxvYWQgYSBtb2R1bGUgZnJvbSBhIFVSTC5cbiAqXG4gKiBJZiB0aGUgb3JpZ2luIG9mIHRoZSB3b3JrZXIgVVJMIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IG9yaWdpbiwgdGhlIHdvcmtlciBjYW5ub3QgYmUgbG9hZGVkIGRpcmVjdGx5LlxuICogU2VlIGRpc2N1c3Npb25zIGluIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvd29ya2VyLWxvYWRlci9pc3N1ZXMvMTU0XG4gKlxuICogSW4gdGhpcyBjYXNlLCB3ZSB3aWxsIGZldGNoIHRoZSB3b3JrZXIgVVJMIGFuZCBjcmVhdGUgYSBuZXcgQmxvYiBVUkwgd2l0aCB0aGUgc2FtZSBvcmlnaW4gYXMgYSB3b3JrYXJvdW5kLlxuICpcbiAqIEBwYXJhbSBhYnNvbHV0ZVVybCAtIFRoZSBhYnNvbHV0ZSBVUkwgdG8gcHJlbG9hZC5cbiAqXG4gKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbmV3IEJsb2IgVVJMXG4gKi9cbmNvbnN0IHByZWxvYWQgPSBhc3luYyhhYnNvbHV0ZVVybDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhYnNvbHV0ZVVybCwge2NyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nfSk7XG4gIGNvbnN0IGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xufTtcblxuLyoqXG4gKiBUaGlzIGhlbHBlciBmdW5jdGlvbiBpcyB1c2VkIHRvIGR5bmFtaWNhbGx5IGltcG9ydCBhIG1vZHVsZSBmcm9tIGEgVVJMLlxuICpcbiAqIFRoZSBidWlsZCBzY3JpcHQgaGFzIHNwZWNpYWwgaGFuZGxpbmcgZm9yIHRoaXMgZnVuY3Rpb24gdG8gZW5zdXJlIHRoYXQgdGhlIFVSTCBpcyBub3QgYnVuZGxlZCBpbnRvIHRoZSBmaW5hbCBvdXRwdXQuXG4gKlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gaW1wb3J0LlxuICpcbiAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRlZmF1bHQgZXhwb3J0IG9mIHRoZSBtb2R1bGUuXG4gKi9cbmNvbnN0IGR5bmFtaWNJbXBvcnREZWZhdWx0ID0gYXN5bmM8VD4odXJsOiBzdHJpbmcpOiBQcm9taXNlPFQ+ID0+IChhd2FpdCBpbXBvcnQoLyogd2VicGFja0lnbm9yZTogdHJ1ZSAqLyB1cmwpKS5kZWZhdWx0O1xuXG4vKipcbiAqIFRoZSBwcm94eSB3b3JrZXIgZmFjdG9yeSBpbXBvcnRlZCBmcm9tIHRoZSBwcm94eSB3b3JrZXIgbW9kdWxlLlxuICpcbiAqIFRoaXMgaXMgb25seSBhdmFpbGFibGUgd2hlbiB0aGUgV2ViQXNzZW1ibHkgcHJveHkgaXMgbm90IGRpc2FibGVkLlxuICovXG5jb25zdCBjcmVhdGVQcm94eVdvcmtlcjogKCh1cmxPdmVycmlkZT86IHN0cmluZykgPT4gV29ya2VyKXx1bmRlZmluZWQgPVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG4gICAgQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgPyB1bmRlZmluZWQgOiByZXF1aXJlKCcuL3Byb3h5LXdvcmtlci9tYWluJykuZGVmYXVsdDtcblxuLyoqXG4gKiBJbXBvcnQgdGhlIHByb3h5IHdvcmtlci5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgcGVyZm9ybSB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuICogMS4gSWYgYSBwcmVsb2FkIGlzIG5lZWRlZCwgaXQgd2lsbCBwcmVsb2FkIHRoZSBtb2R1bGUgYW5kIHJldHVybiB0aGUgb2JqZWN0IFVSTC5cbiAqIDIuIFVzZSB0aGUgcHJveHkgd29ya2VyIGZhY3RvcnkgdG8gY3JlYXRlIHRoZSBwcm94eSB3b3JrZXIuXG4gKlxuICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHR1cGxlIG9mIDIgZWxlbWVudHM6XG4gKiAgICAgICAgICAgIC0gVGhlIG9iamVjdCBVUkwgb2YgdGhlIHByZWxvYWRlZCBtb2R1bGUsIG9yIHVuZGVmaW5lZCBpZiBubyBwcmVsb2FkIGlzIG5lZWRlZC5cbiAqICAgICAgICAgICAgLSBUaGUgcHJveHkgd29ya2VyLlxuICovXG5leHBvcnQgY29uc3QgaW1wb3J0UHJveHlXb3JrZXIgPSBhc3luYygpOiBQcm9taXNlPFt1bmRlZmluZWQgfCBzdHJpbmcsIFdvcmtlcl0+ID0+IHtcbiAgaWYgKCFzY3JpcHRTcmMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIHByb3h5IHdvcmtlcjogY2Fubm90IGRldGVybWluZSB0aGUgc2NyaXB0IHNvdXJjZSBVUkwuJyk7XG4gIH1cblxuICAvLyBJZiB0aGUgc2NyaXB0IHNvdXJjZSBpcyBmcm9tIHRoZSBzYW1lIG9yaWdpbiwgd2UgY2FuIHVzZSB0aGUgZW1iZWRkZWQgcHJveHkgbW9kdWxlIGRpcmVjdGx5LlxuICBpZiAoaXNTYW1lT3JpZ2luKHNjcmlwdFNyYykpIHtcbiAgICByZXR1cm4gW3VuZGVmaW5lZCwgY3JlYXRlUHJveHlXb3JrZXIhKCldO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCBuZWVkIHRvIHByZWxvYWRcbiAgY29uc3QgdXJsID0gYXdhaXQgcHJlbG9hZChzY3JpcHRTcmMpO1xuICByZXR1cm4gW3VybCwgY3JlYXRlUHJveHlXb3JrZXIhKHVybCldO1xufTtcblxuLyoqXG4gKiBJbXBvcnQgdGhlIFdlYkFzc2VtYmx5IG1vZHVsZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgcGVyZm9ybSB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuICogMS4gSWYgYSBwcmVsb2FkIGlzIG5lZWRlZCwgaXQgd2lsbCBwcmVsb2FkIHRoZSBtb2R1bGUgYW5kIHJldHVybiB0aGUgb2JqZWN0IFVSTC5cbiAqIDIuIE90aGVyd2lzZSwgaXQgd2lsbCBwZXJmb3JtIGEgZHluYW1pYyBpbXBvcnQgb2YgdGhlIG1vZHVsZS5cbiAqXG4gKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdHVwbGUgb2YgMiBlbGVtZW50czpcbiAqICAgICAgICAgICAgLSBUaGUgb2JqZWN0IFVSTCBvZiB0aGUgcHJlbG9hZGVkIG1vZHVsZSwgb3IgdW5kZWZpbmVkIGlmIG5vIHByZWxvYWQgaXMgbmVlZGVkLlxuICogICAgICAgICAgICAtIFRoZSBkZWZhdWx0IGV4cG9ydCBvZiB0aGUgbW9kdWxlLCB3aGljaCBpcyBhIGZhY3RvcnkgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBXZWJBc3NlbWJseSBtb2R1bGUuXG4gKi9cbmV4cG9ydCBjb25zdCBpbXBvcnRXYXNtTW9kdWxlID0gYXN5bmMoXG4gICAgdXJsT3ZlcnJpZGU6IHN0cmluZ3x1bmRlZmluZWQsIHByZWZpeE92ZXJyaWRlOiBzdHJpbmd8dW5kZWZpbmVkLFxuICAgIGlzTXVsdGlUaHJlYWRlZDogYm9vbGVhbik6IFByb21pc2U8W3VuZGVmaW5lZCB8IHN0cmluZywgRW1zY3JpcHRlbk1vZHVsZUZhY3Rvcnk8T3J0V2FzbU1vZHVsZT5dPiA9PiB7XG4gIGNvbnN0IHdhc21Nb2R1bGVGaWxlbmFtZSA9ICFCVUlMRF9ERUZTLkRJU0FCTEVfVFJBSU5JTkcgPyAnb3J0LXRyYWluaW5nLXdhc20tc2ltZC10aHJlYWRlZC5tanMnIDpcbiAgICAgICFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAubWpzJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb3J0LXdhc20tc2ltZC10aHJlYWRlZC5tanMnO1xuICBjb25zdCB3YXNtTW9kdWxlVXJsID0gdXJsT3ZlcnJpZGUgPz8gbm9ybWFsaXplVXJsKHdhc21Nb2R1bGVGaWxlbmFtZSwgcHJlZml4T3ZlcnJpZGUpO1xuICAvLyBuZWVkIHRvIHByZWxvYWQgaWYgYWxsIG9mIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICAvLyAxLiBub3QgaW4gTm9kZS5qcy5cbiAgLy8gICAgLSBOb2RlLmpzIGRvZXMgbm90IGhhdmUgdGhlIHNhbWUgb3JpZ2luIHBvbGljeSBmb3IgY3JlYXRpbmcgd29ya2Vycy5cbiAgLy8gMi4gbXVsdGktdGhyZWFkZWQgaXMgZW5hYmxlZC5cbiAgLy8gICAgLSBJZiBtdWx0aS10aHJlYWRlZCBpcyBkaXNhYmxlZCwgbm8gd29ya2VyIHdpbGwgYmUgY3JlYXRlZC4gU28gd2UgZG9uJ3QgbmVlZCB0byBwcmVsb2FkIHRoZSBtb2R1bGUuXG4gIC8vIDMuIHRoZSBhYnNvbHV0ZSBVUkwgaXMgYXZhaWxhYmxlLlxuICAvLyAgICAtIElmIHRoZSBhYnNvbHV0ZSBVUkwgaXMgZmFpbGVkIHRvIGJlIGNyZWF0ZWQsIHRoZSBvcmlnaW4gY2Fubm90IGJlIGRldGVybWluZWQuIEluIHRoaXMgY2FzZSwgd2Ugd2lsbCBub3RcbiAgLy8gICAgcHJlbG9hZCB0aGUgbW9kdWxlLlxuICAvLyA0LiB0aGUgd29ya2VyIFVSTCBpcyBub3QgZnJvbSB0aGUgc2FtZSBvcmlnaW4uXG4gIC8vICAgIC0gSWYgdGhlIHdvcmtlciBVUkwgaXMgZnJvbSB0aGUgc2FtZSBvcmlnaW4sIHdlIGNhbiBjcmVhdGUgdGhlIHdvcmtlciBkaXJlY3RseS5cbiAgY29uc3QgbmVlZFByZWxvYWQgPSAhaXNOb2RlICYmIGlzTXVsdGlUaHJlYWRlZCAmJiB3YXNtTW9kdWxlVXJsICYmICFpc1NhbWVPcmlnaW4od2FzbU1vZHVsZVVybCwgcHJlZml4T3ZlcnJpZGUpO1xuICBjb25zdCB1cmwgPVxuICAgICAgbmVlZFByZWxvYWQgPyAoYXdhaXQgcHJlbG9hZCh3YXNtTW9kdWxlVXJsKSkgOiAod2FzbU1vZHVsZVVybCA/PyBmYWxsYmFja1VybCh3YXNtTW9kdWxlRmlsZW5hbWUsIHByZWZpeE92ZXJyaWRlKSk7XG4gIHJldHVybiBbbmVlZFByZWxvYWQgPyB1cmwgOiB1bmRlZmluZWQsIGF3YWl0IGR5bmFtaWNJbXBvcnREZWZhdWx0PEVtc2NyaXB0ZW5Nb2R1bGVGYWN0b3J5PE9ydFdhc21Nb2R1bGU+Pih1cmwpXTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RW52fSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgdHlwZSB7T3J0V2FzbU1vZHVsZX0gZnJvbSAnLi93YXNtLXR5cGVzJztcbmltcG9ydCB7aW1wb3J0V2FzbU1vZHVsZX0gZnJvbSAnLi93YXNtLXV0aWxzLWltcG9ydCc7XG5cbmxldCB3YXNtOiBPcnRXYXNtTW9kdWxlfHVuZGVmaW5lZDtcbmxldCBpbml0aWFsaXplZCA9IGZhbHNlO1xubGV0IGluaXRpYWxpemluZyA9IGZhbHNlO1xubGV0IGFib3J0ZWQgPSBmYWxzZTtcblxuY29uc3QgaXNNdWx0aVRocmVhZFN1cHBvcnRlZCA9ICgpOiBib29sZWFuID0+IHtcbiAgLy8gSWYgJ1NoYXJlZEFycmF5QnVmZmVyJyBpcyBub3QgYXZhaWxhYmxlLCBXZWJBc3NlbWJseSB0aHJlYWRzIHdpbGwgbm90IHdvcmsuXG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUZXN0IGZvciB0cmFuc2ZlcmFiaWxpdHkgb2YgU0FCcyAoZm9yIGJyb3dzZXJzLiBuZWVkZWQgZm9yIEZpcmVmb3gpXG4gICAgLy8gaHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9mb3J1bS8jIW1zZy9tb3ppbGxhLmRldi5wbGF0Zm9ybS9JSGtCWmxIRVRwQS9kd3NNTmNoV0VRQUpcbiAgICBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbmV3IE1lc3NhZ2VDaGFubmVsKCkucG9ydDEucG9zdE1lc3NhZ2UobmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpKTtcbiAgICB9XG5cbiAgICAvLyBUZXN0IGZvciBXZWJBc3NlbWJseSB0aHJlYWRzIGNhcGFiaWxpdHkgKGZvciBib3RoIGJyb3dzZXJzIGFuZCBOb2RlLmpzKVxuICAgIC8vIFRoaXMgdHlwZWQgYXJyYXkgaXMgYSBXZWJBc3NlbWJseSBwcm9ncmFtIGNvbnRhaW5pbmcgdGhyZWFkZWQgaW5zdHJ1Y3Rpb25zLlxuICAgIHJldHVybiBXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbXG4gICAgICAwLCA5NywgMTE1LCAxMDksIDEsIDAsICAwLCAgMCwgMSwgNCwgMSwgIDk2LCAwLCAgIDAsICAzLCAyLCAxLCAgMCwgNSxcbiAgICAgIDQsIDEsICAzLCAgIDEsICAgMSwgMTAsIDExLCAxLCA5LCAwLCA2NSwgMCwgIDI1NCwgMTYsIDIsIDAsIDI2LCAxMVxuICAgIF0pKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuY29uc3QgaXNTaW1kU3VwcG9ydGVkID0gKCk6IGJvb2xlYW4gPT4ge1xuICB0cnkge1xuICAgIC8vIFRlc3QgZm9yIFdlYkFzc2VtYmx5IFNJTUQgY2FwYWJpbGl0eSAoZm9yIGJvdGggYnJvd3NlcnMgYW5kIE5vZGUuanMpXG4gICAgLy8gVGhpcyB0eXBlZCBhcnJheSBpcyBhIFdlYkFzc2VtYmx5IHByb2dyYW0gY29udGFpbmluZyBTSU1EIGluc3RydWN0aW9ucy5cblxuICAgIC8vIFRoZSBiaW5hcnkgZGF0YSBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgZm9sbG93aW5nIGNvZGUgYnkgd2F0Mndhc206XG4gICAgLy9cbiAgICAvLyAobW9kdWxlXG4gICAgLy8gICAodHlwZSAkdDAgKGZ1bmMpKVxuICAgIC8vICAgKGZ1bmMgJGYwICh0eXBlICR0MClcbiAgICAvLyAgICAgKGRyb3BcbiAgICAvLyAgICAgICAoaTMyeDQuZG90X2kxNng4X3NcbiAgICAvLyAgICAgICAgIChpOHgxNi5zcGxhdFxuICAgIC8vICAgICAgICAgICAoaTMyLmNvbnN0IDApKVxuICAgIC8vICAgICAgICAgKHYxMjguY29uc3QgaTMyeDQgMHgwMDAwMDAwMCAweDAwMDAwMDAwIDB4MDAwMDAwMDAgMHgwMDAwMDAwMCkpKSkpXG5cbiAgICByZXR1cm4gV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMCwgICA5NywgMTE1LCAxMDksIDEsIDAsIDAsIDAsIDEsIDQsIDEsIDk2LCAwLCAwLCAzLCAyLCAxLCAwLCAxMCwgMzAsIDEsICAgMjgsICAwLCA2NSwgMCxcbiAgICAgIDI1MywgMTUsIDI1MywgMTIsICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgIDAsICAyNTMsIDE4NiwgMSwgMjYsIDExXG4gICAgXSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5ID0gYXN5bmMoZmxhZ3M6IEVudi5XZWJBc3NlbWJseUZsYWdzKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGlmIChpbml0aWFsaXplZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICBpZiAoaW5pdGlhbGl6aW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aXBsZSBjYWxscyB0byBcXCdpbml0aWFsaXplV2ViQXNzZW1ibHkoKVxcJyBkZXRlY3RlZC4nKTtcbiAgfVxuICBpZiAoYWJvcnRlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJldmlvdXMgY2FsbCB0byBcXCdpbml0aWFsaXplV2ViQXNzZW1ibHkoKVxcJyBmYWlsZWQuJyk7XG4gIH1cblxuICBpbml0aWFsaXppbmcgPSB0cnVlO1xuXG4gIC8vIHdhc20gZmxhZ3MgYXJlIGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAgY29uc3QgdGltZW91dCA9IGZsYWdzLmluaXRUaW1lb3V0ITtcbiAgbGV0IG51bVRocmVhZHMgPSBmbGFncy5udW1UaHJlYWRzITtcblxuICAvLyBlbnN1cmUgU0lNRCBpcyBzdXBwb3J0ZWRcbiAgaWYgKCFpc1NpbWRTdXBwb3J0ZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignV2ViQXNzZW1ibHkgU0lNRCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LicpO1xuICB9XG5cbiAgLy8gY2hlY2sgaWYgbXVsdGktdGhyZWFkaW5nIGlzIHN1cHBvcnRlZFxuICBjb25zdCBtdWx0aVRocmVhZFN1cHBvcnRlZCA9IGlzTXVsdGlUaHJlYWRTdXBwb3J0ZWQoKTtcbiAgaWYgKG51bVRocmVhZHMgPiAxICYmICFtdWx0aVRocmVhZFN1cHBvcnRlZCkge1xuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgIXNlbGYuY3Jvc3NPcmlnaW5Jc29sYXRlZCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnZW52Lndhc20ubnVtVGhyZWFkcyBpcyBzZXQgdG8gJyArIG51bVRocmVhZHMgK1xuICAgICAgICAgICcsIGJ1dCB0aGlzIHdpbGwgbm90IHdvcmsgdW5sZXNzIHlvdSBlbmFibGUgY3Jvc3NPcmlnaW5Jc29sYXRlZCBtb2RlLiAnICtcbiAgICAgICAgICAnU2VlIGh0dHBzOi8vd2ViLmRldi9jcm9zcy1vcmlnaW4taXNvbGF0aW9uLWd1aWRlLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgICAnV2ViQXNzZW1ibHkgbXVsdGktdGhyZWFkaW5nIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuICcgK1xuICAgICAgICAnRmFsbGluZyBiYWNrIHRvIHNpbmdsZS10aHJlYWRpbmcuJyk7XG5cbiAgICAvLyBzZXQgZmxhZ3MubnVtVGhyZWFkcyB0byAxIHNvIHRoYXQgT3J0SW5pdCgpIHdpbGwgbm90IGNyZWF0ZSBhIGdsb2JhbCB0aHJlYWQgcG9vbC5cbiAgICBmbGFncy5udW1UaHJlYWRzID0gbnVtVGhyZWFkcyA9IDE7XG4gIH1cblxuICBjb25zdCB3YXNtUGF0aHMgPSBmbGFncy53YXNtUGF0aHM7XG4gIGNvbnN0IHdhc21QcmVmaXhPdmVycmlkZSA9IHR5cGVvZiB3YXNtUGF0aHMgPT09ICdzdHJpbmcnID8gd2FzbVBhdGhzIDogdW5kZWZpbmVkO1xuICBjb25zdCBtanNQYXRoT3ZlcnJpZGVGbGFnID0gKHdhc21QYXRocyBhcyBFbnYuV2FzbUZpbGVQYXRocyk/Lm1qcztcbiAgY29uc3QgbWpzUGF0aE92ZXJyaWRlID0gKG1qc1BhdGhPdmVycmlkZUZsYWcgYXMgVVJMKT8uaHJlZiA/PyBtanNQYXRoT3ZlcnJpZGVGbGFnO1xuICBjb25zdCB3YXNtUGF0aE92ZXJyaWRlRmxhZyA9ICh3YXNtUGF0aHMgYXMgRW52Lldhc21GaWxlUGF0aHMpPy53YXNtO1xuICBjb25zdCB3YXNtUGF0aE92ZXJyaWRlID0gKHdhc21QYXRoT3ZlcnJpZGVGbGFnIGFzIFVSTCk/LmhyZWYgPz8gd2FzbVBhdGhPdmVycmlkZUZsYWc7XG5cbiAgY29uc3QgW29iamVjdFVybCwgb3J0V2FzbUZhY3RvcnldID0gKGF3YWl0IGltcG9ydFdhc21Nb2R1bGUobWpzUGF0aE92ZXJyaWRlLCB3YXNtUHJlZml4T3ZlcnJpZGUsIG51bVRocmVhZHMgPiAxKSk7XG5cbiAgbGV0IGlzVGltZW91dCA9IGZhbHNlO1xuXG4gIGNvbnN0IHRhc2tzOiBBcnJheTxQcm9taXNlPHZvaWQ+PiA9IFtdO1xuXG4gIC8vIHByb21pc2UgZm9yIHRpbWVvdXRcbiAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgdGFza3MucHVzaChuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlzVGltZW91dCA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH0pKTtcbiAgfVxuXG4gIC8vIHByb21pc2UgZm9yIG1vZHVsZSBpbml0aWFsaXphdGlvblxuICB0YXNrcy5wdXNoKG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBjb25maWc6IFBhcnRpYWw8T3J0V2FzbU1vZHVsZT4gPSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBudW1iZXIgb2YgdGhyZWFkcy4gV2ViQXNzZW1ibHkgd2lsbCBjcmVhdGUgKE1vZHVsZS5udW1UaHJlYWRzIC0gMSkgd29ya2Vycy4gSWYgaXQgaXMgMSwgbm8gd29ya2VyIHdpbGwgYmVcbiAgICAgICAqIGNyZWF0ZWQuXG4gICAgICAgKi9cbiAgICAgIG51bVRocmVhZHMsXG4gICAgICAvKipcbiAgICAgICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gbG9jYXRlIHRoZSBXZWJBc3NlbWJseSBmaWxlLiBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiB0aGUgZnVsbCBwYXRoIG9mIHRoZSBmaWxlLlxuICAgICAgICpcbiAgICAgICAqIFNpbmNlIEVtc2NyaXB0ZW4gMy4xLjU4LCB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGZvciB0aGUgLndhc20gZmlsZS5cbiAgICAgICAqL1xuICAgICAgbG9jYXRlRmlsZTogKGZpbGVOYW1lLCBzY3JpcHREaXJlY3RvcnkpID0+IHdhc21QYXRoT3ZlcnJpZGUgPz8gKHdhc21QcmVmaXhPdmVycmlkZSA/PyBzY3JpcHREaXJlY3RvcnkpICsgZmlsZU5hbWVcbiAgICB9O1xuXG4gICAgb3J0V2FzbUZhY3RvcnkoY29uZmlnKS50aGVuKFxuICAgICAgICAvLyB3YXNtIG1vZHVsZSBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHlcbiAgICAgICAgbW9kdWxlID0+IHtcbiAgICAgICAgICBpbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgd2FzbSA9IG1vZHVsZTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgaWYgKG9iamVjdFVybCkge1xuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChvYmplY3RVcmwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gd2FzbSBtb2R1bGUgZmFpbGVkIHRvIGluaXRpYWxpemVcbiAgICAgICAgKHdoYXQpID0+IHtcbiAgICAgICAgICBpbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICByZWplY3Qod2hhdCk7XG4gICAgICAgIH0pO1xuICB9KSk7XG5cbiAgYXdhaXQgUHJvbWlzZS5yYWNlKHRhc2tzKTtcblxuICBpZiAoaXNUaW1lb3V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBXZWJBc3NlbWJseSBiYWNrZW5kIGluaXRpYWxpemluZyBmYWlsZWQgZHVlIHRvIHRpbWVvdXQ6ICR7dGltZW91dH1tc2ApO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0SW5zdGFuY2UgPSAoKTogT3J0V2FzbU1vZHVsZSA9PiB7XG4gIGlmIChpbml0aWFsaXplZCAmJiB3YXNtKSB7XG4gICAgcmV0dXJuIHdhc207XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkFzc2VtYmx5IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQuJyk7XG59O1xuXG5leHBvcnQgY29uc3QgZGlzcG9zZSA9ICgpOiB2b2lkID0+IHtcbiAgaWYgKGluaXRpYWxpemVkICYmICFpbml0aWFsaXppbmcgJiYgIWFib3J0ZWQpIHtcbiAgICAvLyBUT0RPOiBjdXJyZW50bHkgXCJQVGhyZWFkLnRlcm1pbmF0ZUFsbFRocmVhZHMoKVwiIGlzIG5vdCBleHBvc2VkIGluIHRoZSB3YXNtIG1vZHVsZS5cbiAgICAvLyAgICAgICBBbmQgdGhpcyBmdW5jdGlvbiBpcyBub3QgeWV0IGNhbGxlZCBieSBhbnkgY29kZS5cbiAgICAvLyAgICAgICBJZiBpdCBpcyBuZWVkZWQgaW4gdGhlIGZ1dHVyZSwgd2Ugc2hvdWxkIGV4cG9zZSBpdCBpbiB0aGUgd2FzbSBtb2R1bGUgYW5kIHVuY29tbWVudCB0aGUgZm9sbG93aW5nIGxpbmUuXG5cbiAgICAvLyB3YXNtPy5QVGhyZWFkPy50ZXJtaW5hdGVBbGxUaHJlYWRzKCk7XG4gICAgd2FzbSA9IHVuZGVmaW5lZDtcblxuICAgIGluaXRpYWxpemluZyA9IGZhbHNlO1xuICAgIGluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgYWJvcnRlZCA9IHRydWU7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7Z2V0SW5zdGFuY2V9IGZyb20gJy4vd2FzbS1mYWN0b3J5JztcblxuZXhwb3J0IGNvbnN0IGFsbG9jV2FzbVN0cmluZyA9IChkYXRhOiBzdHJpbmcsIGFsbG9jczogbnVtYmVyW10pOiBudW1iZXIgPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcblxuICBjb25zdCBkYXRhTGVuZ3RoID0gd2FzbS5sZW5ndGhCeXRlc1VURjgoZGF0YSkgKyAxO1xuICBjb25zdCBkYXRhT2Zmc2V0ID0gd2FzbS5fbWFsbG9jKGRhdGFMZW5ndGgpO1xuICB3YXNtLnN0cmluZ1RvVVRGOChkYXRhLCBkYXRhT2Zmc2V0LCBkYXRhTGVuZ3RoKTtcbiAgYWxsb2NzLnB1c2goZGF0YU9mZnNldCk7XG5cbiAgcmV0dXJuIGRhdGFPZmZzZXQ7XG59O1xuXG5pbnRlcmZhY2UgRXh0cmFPcHRpb25zSGFuZGxlciB7XG4gIChuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgaXRlcmF0ZUV4dHJhT3B0aW9ucyA9XG4gICAgKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LCBwcmVmaXg6IHN0cmluZywgc2VlbjogV2Vha1NldDxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4sXG4gICAgIGhhbmRsZXI6IEV4dHJhT3B0aW9uc0hhbmRsZXIpOiB2b2lkID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSAnb2JqZWN0JyAmJiBvcHRpb25zICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzZWVuLmhhcyhvcHRpb25zKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2lyY3VsYXIgcmVmZXJlbmNlIGluIG9wdGlvbnMnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWVuLmFkZChvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBPYmplY3QuZW50cmllcyhvcHRpb25zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgY29uc3QgbmFtZSA9IChwcmVmaXgpID8gcHJlZml4ICsga2V5IDoga2V5O1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGl0ZXJhdGVFeHRyYU9wdGlvbnModmFsdWUgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sIG5hbWUgKyAnLicsIHNlZW4sIGhhbmRsZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGhhbmRsZXIobmFtZSwgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBoYW5kbGVyKG5hbWUsICh2YWx1ZSkgPyAnMScgOiAnMCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgaGFuZGxlIGV4dHJhIGNvbmZpZyB0eXBlOiAke3R5cGVvZiB2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuLyoqXG4gKiBjaGVjayB3ZWIgYXNzZW1ibHkgQVBJJ3MgbGFzdCBlcnJvciBhbmQgdGhyb3cgZXJyb3IgaWYgYW55IGVycm9yIG9jY3VycmVkLlxuICogQHBhcmFtIG1lc3NhZ2UgYSBtZXNzYWdlIHVzZWQgd2hlbiBhbiBlcnJvciBvY2N1cnJlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNoZWNrTGFzdEVycm9yID0gKG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQgPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcblxuICBjb25zdCBzdGFjayA9IHdhc20uc3RhY2tTYXZlKCk7XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyYW1zT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKDgpO1xuICAgIHdhc20uX09ydEdldExhc3RFcnJvcihwYXJhbXNPZmZzZXQsIHBhcmFtc09mZnNldCArIDQpO1xuICAgIGNvbnN0IGVycm9yQ29kZSA9IHdhc20uSEVBUDMyW3BhcmFtc09mZnNldCAvIDRdO1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZVBvaW50ZXIgPSB3YXNtLkhFQVBVMzJbcGFyYW1zT2Zmc2V0IC8gNCArIDFdO1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZVBvaW50ZXIgPyB3YXNtLlVURjhUb1N0cmluZyhlcnJvck1lc3NhZ2VQb2ludGVyKSA6ICcnO1xuICAgIHRocm93IG5ldyBFcnJvcihgJHttZXNzYWdlfSBFUlJPUl9DT0RFOiAke2Vycm9yQ29kZX0sIEVSUk9SX01FU1NBR0U6ICR7ZXJyb3JNZXNzYWdlfWApO1xuICB9IGZpbmFsbHkge1xuICAgIHdhc20uc3RhY2tSZXN0b3JlKHN0YWNrKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtJbmZlcmVuY2VTZXNzaW9ufSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQge2dldEluc3RhbmNlfSBmcm9tICcuL3dhc20tZmFjdG9yeSc7XG5pbXBvcnQge2FsbG9jV2FzbVN0cmluZywgY2hlY2tMYXN0RXJyb3IsIGl0ZXJhdGVFeHRyYU9wdGlvbnN9IGZyb20gJy4vd2FzbS11dGlscyc7XG5cbmV4cG9ydCBjb25zdCBzZXRSdW5PcHRpb25zID0gKG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyk6IFtudW1iZXIsIG51bWJlcltdXSA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBsZXQgcnVuT3B0aW9uc0hhbmRsZSA9IDA7XG4gIGNvbnN0IGFsbG9jczogbnVtYmVyW10gPSBbXTtcblxuICBjb25zdCBydW5PcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRyeSB7XG4gICAgaWYgKG9wdGlvbnM/LmxvZ1NldmVyaXR5TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcnVuT3B0aW9ucy5sb2dTZXZlcml0eUxldmVsID0gMjsgIC8vIERlZmF1bHQgdG8gd2FybmluZ1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKG9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCkgfHxcbiAgICAgICAgb3B0aW9ucy5sb2dTZXZlcml0eUxldmVsIDwgMCB8fCBvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgPiA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGxvZyBzZXJ2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke29wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbH1gKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucz8ubG9nVmVyYm9zaXR5TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcnVuT3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbCA9IDA7ICAvLyBEZWZhdWx0IHRvIDBcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtvcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsfWApO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zPy50ZXJtaW5hdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcnVuT3B0aW9ucy50ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgdGFnRGF0YU9mZnNldCA9IDA7XG4gICAgaWYgKG9wdGlvbnM/LnRhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YWdEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKG9wdGlvbnMudGFnLCBhbGxvY3MpO1xuICAgIH1cblxuICAgIHJ1bk9wdGlvbnNIYW5kbGUgPSB3YXNtLl9PcnRDcmVhdGVSdW5PcHRpb25zKFxuICAgICAgICBydW5PcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwhLCBydW5PcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsISwgISFydW5PcHRpb25zLnRlcm1pbmF0ZSEsIHRhZ0RhdGFPZmZzZXQpO1xuICAgIGlmIChydW5PcHRpb25zSGFuZGxlID09PSAwKSB7XG4gICAgICBjaGVja0xhc3RFcnJvcignQ2FuXFwndCBjcmVhdGUgcnVuIG9wdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnM/LmV4dHJhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGl0ZXJhdGVFeHRyYU9wdGlvbnMob3B0aW9ucy5leHRyYSwgJycsIG5ldyBXZWFrU2V0PFJlY29yZDxzdHJpbmcsIHVua25vd24+PigpLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBrZXlEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKGtleSwgYWxsb2NzKTtcbiAgICAgICAgY29uc3QgdmFsdWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKHZhbHVlLCBhbGxvY3MpO1xuXG4gICAgICAgIGlmICh3YXNtLl9PcnRBZGRSdW5Db25maWdFbnRyeShydW5PcHRpb25zSGFuZGxlLCBrZXlEYXRhT2Zmc2V0LCB2YWx1ZURhdGFPZmZzZXQpICE9PSAwKSB7XG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7a2V5fSAtICR7dmFsdWV9LmApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3J1bk9wdGlvbnNIYW5kbGUsIGFsbG9jc107XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAocnVuT3B0aW9uc0hhbmRsZSAhPT0gMCkge1xuICAgICAgd2FzbS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMocnVuT3B0aW9uc0hhbmRsZSk7XG4gICAgfVxuICAgIGFsbG9jcy5mb3JFYWNoKGFsbG9jID0+IHdhc20uX2ZyZWUoYWxsb2MpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0luZmVyZW5jZVNlc3Npb259IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7Z2V0SW5zdGFuY2V9IGZyb20gJy4vd2FzbS1mYWN0b3J5JztcbmltcG9ydCB7YWxsb2NXYXNtU3RyaW5nLCBjaGVja0xhc3RFcnJvciwgaXRlcmF0ZUV4dHJhT3B0aW9uc30gZnJvbSAnLi93YXNtLXV0aWxzJztcblxuY29uc3QgZ2V0R3JhcGhPcHRpbXphdGlvbkxldmVsID0gKGdyYXBoT3B0aW1pemF0aW9uTGV2ZWw6IHN0cmluZ3x1bmtub3duKTogbnVtYmVyID0+IHtcbiAgc3dpdGNoIChncmFwaE9wdGltaXphdGlvbkxldmVsKSB7XG4gICAgY2FzZSAnZGlzYWJsZWQnOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSAnYmFzaWMnOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSAnZXh0ZW5kZWQnOlxuICAgICAgcmV0dXJuIDI7XG4gICAgY2FzZSAnYWxsJzpcbiAgICAgIHJldHVybiA5OTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBncmFwaCBvcHRpbWl6YXRpb24gbGV2ZWw6ICR7Z3JhcGhPcHRpbWl6YXRpb25MZXZlbH1gKTtcbiAgfVxufTtcblxuY29uc3QgZ2V0RXhlY3V0aW9uTW9kZSA9IChleGVjdXRpb25Nb2RlOiAnc2VxdWVudGlhbCd8J3BhcmFsbGVsJyk6IG51bWJlciA9PiB7XG4gIHN3aXRjaCAoZXhlY3V0aW9uTW9kZSkge1xuICAgIGNhc2UgJ3NlcXVlbnRpYWwnOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSAncGFyYWxsZWwnOlxuICAgICAgcmV0dXJuIDE7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXhlY3V0aW9uIG1vZGU6ICR7ZXhlY3V0aW9uTW9kZX1gKTtcbiAgfVxufTtcblxuY29uc3QgYXBwZW5kRGVmYXVsdE9wdGlvbnMgPSAob3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IHZvaWQgPT4ge1xuICBpZiAoIW9wdGlvbnMuZXh0cmEpIHtcbiAgICBvcHRpb25zLmV4dHJhID0ge307XG4gIH1cbiAgaWYgKCFvcHRpb25zLmV4dHJhLnNlc3Npb24pIHtcbiAgICBvcHRpb25zLmV4dHJhLnNlc3Npb24gPSB7fTtcbiAgfVxuICBjb25zdCBzZXNzaW9uID0gb3B0aW9ucy5leHRyYS5zZXNzaW9uIGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIGlmICghc2Vzc2lvbi51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZVxuICAgIHNlc3Npb24udXNlX29ydF9tb2RlbF9ieXRlc19kaXJlY3RseSA9ICcxJztcbiAgfVxuXG4gIC8vIGlmIHVzaW5nIEpTRVAgd2l0aCBXZWJHUFUsIGFsd2F5cyBkaXNhYmxlIG1lbW9yeSBwYXR0ZXJuXG4gIGlmIChvcHRpb25zLmV4ZWN1dGlvblByb3ZpZGVycyAmJlxuICAgICAgb3B0aW9ucy5leGVjdXRpb25Qcm92aWRlcnMuc29tZShlcCA9PiAodHlwZW9mIGVwID09PSAnc3RyaW5nJyA/IGVwIDogZXAubmFtZSkgPT09ICd3ZWJncHUnKSkge1xuICAgIG9wdGlvbnMuZW5hYmxlTWVtUGF0dGVybiA9IGZhbHNlO1xuICB9XG59O1xuXG5jb25zdCBzZXRFeGVjdXRpb25Qcm92aWRlcnMgPVxuICAgIChzZXNzaW9uT3B0aW9uc0hhbmRsZTogbnVtYmVyLCBleGVjdXRpb25Qcm92aWRlcnM6IHJlYWRvbmx5IEluZmVyZW5jZVNlc3Npb24uRXhlY3V0aW9uUHJvdmlkZXJDb25maWdbXSxcbiAgICAgYWxsb2NzOiBudW1iZXJbXSk6IHZvaWQgPT4ge1xuICAgICAgZm9yIChjb25zdCBlcCBvZiBleGVjdXRpb25Qcm92aWRlcnMpIHtcbiAgICAgICAgbGV0IGVwTmFtZSA9IHR5cGVvZiBlcCA9PT0gJ3N0cmluZycgPyBlcCA6IGVwLm5hbWU7XG5cbiAgICAgICAgLy8gY2hlY2sgRVAgbmFtZVxuICAgICAgICBzd2l0Y2ggKGVwTmFtZSkge1xuICAgICAgICAgIGNhc2UgJ3dlYm5uJzpcbiAgICAgICAgICAgIGVwTmFtZSA9ICdXRUJOTic7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVwICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb25zdCB3ZWJubk9wdGlvbnMgPSBlcCBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5ORXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgICAgICAgICAgIC8vIGNvbnN0IGNvbnRleHQgPSAod2Vibm5PcHRpb25zIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5PcHRpb25zV2l0aE1MQ29udGV4dCk/LmNvbnRleHQ7XG4gICAgICAgICAgICAgIGNvbnN0IGRldmljZVR5cGUgPSAod2Vibm5PcHRpb25zIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5Db250ZXh0T3B0aW9ucyk/LmRldmljZVR5cGU7XG4gICAgICAgICAgICAgIGNvbnN0IG51bVRocmVhZHMgPSAod2Vibm5PcHRpb25zIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5Db250ZXh0T3B0aW9ucyk/Lm51bVRocmVhZHM7XG4gICAgICAgICAgICAgIGNvbnN0IHBvd2VyUHJlZmVyZW5jZSA9ICh3ZWJubk9wdGlvbnMgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTkNvbnRleHRPcHRpb25zKT8ucG93ZXJQcmVmZXJlbmNlO1xuICAgICAgICAgICAgICBpZiAoZGV2aWNlVHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoJ2RldmljZVR5cGUnLCBhbGxvY3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhkZXZpY2VUeXBlLCBhbGxvY3MpO1xuICAgICAgICAgICAgICAgIGlmIChnZXRJbnN0YW5jZSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIGtleURhdGFPZmZzZXQsIHZhbHVlRGF0YU9mZnNldCkgIT09XG4gICAgICAgICAgICAgICAgICAgIDApIHtcbiAgICAgICAgICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ2RldmljZVR5cGUnIC0gJHtkZXZpY2VUeXBlfS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG51bVRocmVhZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIEp1c3QgaWdub3JlIGludmFsaWQgd2Vibm5PcHRpb25zLm51bVRocmVhZHMuXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVkTnVtVGhyZWFkcyA9XG4gICAgICAgICAgICAgICAgICAgICh0eXBlb2YgbnVtVGhyZWFkcyAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIobnVtVGhyZWFkcykgfHwgbnVtVGhyZWFkcyA8IDApID8gMCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtVGhyZWFkcztcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKCdudW1UaHJlYWRzJywgYWxsb2NzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcodmFsaWRhdGVkTnVtVGhyZWFkcy50b1N0cmluZygpLCBhbGxvY3MpO1xuICAgICAgICAgICAgICAgIGlmIChnZXRJbnN0YW5jZSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIGtleURhdGFPZmZzZXQsIHZhbHVlRGF0YU9mZnNldCkgIT09XG4gICAgICAgICAgICAgICAgICAgIDApIHtcbiAgICAgICAgICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ251bVRocmVhZHMnIC0gJHtudW1UaHJlYWRzfS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHBvd2VyUHJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoJ3Bvd2VyUHJlZmVyZW5jZScsIGFsbG9jcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKHBvd2VyUHJlZmVyZW5jZSwgYWxsb2NzKTtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0SW5zdGFuY2UoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KHNlc3Npb25PcHRpb25zSGFuZGxlLCBrZXlEYXRhT2Zmc2V0LCB2YWx1ZURhdGFPZmZzZXQpICE9PVxuICAgICAgICAgICAgICAgICAgICAwKSB7XG4gICAgICAgICAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdwb3dlclByZWZlcmVuY2UnIC0gJHtwb3dlclByZWZlcmVuY2V9LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnd2ViZ3B1JzpcbiAgICAgICAgICAgIGVwTmFtZSA9ICdKUyc7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVwICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb25zdCB3ZWJncHVPcHRpb25zID0gZXAgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJHcHVFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICAgICAgICAgICAgaWYgKHdlYmdwdU9wdGlvbnM/LnByZWZlcnJlZExheW91dCkge1xuICAgICAgICAgICAgICAgIGlmICh3ZWJncHVPcHRpb25zLnByZWZlcnJlZExheW91dCAhPT0gJ05DSFcnICYmIHdlYmdwdU9wdGlvbnMucHJlZmVycmVkTGF5b3V0ICE9PSAnTkhXQycpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJlZmVycmVkTGF5b3V0IG11c3QgYmUgZWl0aGVyICdOQ0hXJyBvciAnTkhXQyc6ICR7d2ViZ3B1T3B0aW9ucy5wcmVmZXJyZWRMYXlvdXR9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGtleURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoJ3ByZWZlcnJlZExheW91dCcsIGFsbG9jcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKHdlYmdwdU9wdGlvbnMucHJlZmVycmVkTGF5b3V0LCBhbGxvY3MpO1xuICAgICAgICAgICAgICAgIGlmIChnZXRJbnN0YW5jZSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIGtleURhdGFPZmZzZXQsIHZhbHVlRGF0YU9mZnNldCkgIT09XG4gICAgICAgICAgICAgICAgICAgIDApIHtcbiAgICAgICAgICAgICAgICAgIGNoZWNrTGFzdEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ3ByZWZlcnJlZExheW91dCcgLSAke3dlYmdwdU9wdGlvbnMucHJlZmVycmVkTGF5b3V0fS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3dhc20nOlxuICAgICAgICAgIGNhc2UgJ2NwdSc6XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtlcE5hbWV9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlcE5hbWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKGVwTmFtZSwgYWxsb2NzKTtcbiAgICAgICAgaWYgKGdldEluc3RhbmNlKCkuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyKHNlc3Npb25PcHRpb25zSGFuZGxlLCBlcE5hbWVEYXRhT2Zmc2V0KSAhPT0gMCkge1xuICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBhcHBlbmQgZXhlY3V0aW9uIHByb3ZpZGVyOiAke2VwTmFtZX0uYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG5leHBvcnQgY29uc3Qgc2V0U2Vzc2lvbk9wdGlvbnMgPSAob3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiBbbnVtYmVyLCBudW1iZXJbXV0gPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcbiAgbGV0IHNlc3Npb25PcHRpb25zSGFuZGxlID0gMDtcbiAgY29uc3QgYWxsb2NzOiBudW1iZXJbXSA9IFtdO1xuXG4gIGNvbnN0IHNlc3Npb25PcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgYXBwZW5kRGVmYXVsdE9wdGlvbnMoc2Vzc2lvbk9wdGlvbnMpO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCA9IGdldEdyYXBoT3B0aW16YXRpb25MZXZlbChzZXNzaW9uT3B0aW9ucy5ncmFwaE9wdGltaXphdGlvbkxldmVsID8/ICdhbGwnKTtcbiAgICBjb25zdCBleGVjdXRpb25Nb2RlID0gZ2V0RXhlY3V0aW9uTW9kZShzZXNzaW9uT3B0aW9ucy5leGVjdXRpb25Nb2RlID8/ICdzZXF1ZW50aWFsJyk7XG4gICAgY29uc3QgbG9nSWREYXRhT2Zmc2V0ID1cbiAgICAgICAgdHlwZW9mIHNlc3Npb25PcHRpb25zLmxvZ0lkID09PSAnc3RyaW5nJyA/IGFsbG9jV2FzbVN0cmluZyhzZXNzaW9uT3B0aW9ucy5sb2dJZCwgYWxsb2NzKSA6IDA7XG5cbiAgICBjb25zdCBsb2dTZXZlcml0eUxldmVsID0gc2Vzc2lvbk9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCA/PyAyOyAgLy8gRGVmYXVsdCB0byAyIC0gd2FybmluZ1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihsb2dTZXZlcml0eUxldmVsKSB8fCBsb2dTZXZlcml0eUxldmVsIDwgMCB8fCBsb2dTZXZlcml0eUxldmVsID4gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtsb2dTZXZlcml0eUxldmVsfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGxvZ1ZlcmJvc2l0eUxldmVsID0gc2Vzc2lvbk9wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWwgPz8gMDsgIC8vIERlZmF1bHQgdG8gMCAtIHZlcmJvc2VcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobG9nVmVyYm9zaXR5TGV2ZWwpIHx8IGxvZ1ZlcmJvc2l0eUxldmVsIDwgMCB8fCBsb2dWZXJib3NpdHlMZXZlbCA+IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7bG9nVmVyYm9zaXR5TGV2ZWx9YCk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW1pemVkTW9kZWxGaWxlUGF0aE9mZnNldCA9IHR5cGVvZiBzZXNzaW9uT3B0aW9ucy5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoID09PSAnc3RyaW5nJyA/XG4gICAgICAgIGFsbG9jV2FzbVN0cmluZyhzZXNzaW9uT3B0aW9ucy5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoLCBhbGxvY3MpIDpcbiAgICAgICAgMDtcblxuICAgIHNlc3Npb25PcHRpb25zSGFuZGxlID0gd2FzbS5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnMoXG4gICAgICAgIGdyYXBoT3B0aW1pemF0aW9uTGV2ZWwsICEhc2Vzc2lvbk9wdGlvbnMuZW5hYmxlQ3B1TWVtQXJlbmEsICEhc2Vzc2lvbk9wdGlvbnMuZW5hYmxlTWVtUGF0dGVybiwgZXhlY3V0aW9uTW9kZSxcbiAgICAgICAgISFzZXNzaW9uT3B0aW9ucy5lbmFibGVQcm9maWxpbmcsIDAsIGxvZ0lkRGF0YU9mZnNldCwgbG9nU2V2ZXJpdHlMZXZlbCwgbG9nVmVyYm9zaXR5TGV2ZWwsXG4gICAgICAgIG9wdGltaXplZE1vZGVsRmlsZVBhdGhPZmZzZXQpO1xuICAgIGlmIChzZXNzaW9uT3B0aW9uc0hhbmRsZSA9PT0gMCkge1xuICAgICAgY2hlY2tMYXN0RXJyb3IoJ0NhblxcJ3QgY3JlYXRlIHNlc3Npb24gb3B0aW9ucy4nKTtcbiAgICB9XG5cbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzKSB7XG4gICAgICBzZXRFeGVjdXRpb25Qcm92aWRlcnMoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIHNlc3Npb25PcHRpb25zLmV4ZWN1dGlvblByb3ZpZGVycywgYWxsb2NzKTtcbiAgICB9XG5cbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnMuZW5hYmxlR3JhcGhDYXB0dXJlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2Vzc2lvbk9wdGlvbnMuZW5hYmxlR3JhcGhDYXB0dXJlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlbmFibGVHcmFwaENhcHR1cmUgbXVzdCBiZSBhIGJvb2xlYW4gdmFsdWU6ICR7c2Vzc2lvbk9wdGlvbnMuZW5hYmxlR3JhcGhDYXB0dXJlfWApO1xuICAgICAgfVxuICAgICAgY29uc3Qga2V5RGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZygnZW5hYmxlR3JhcGhDYXB0dXJlJywgYWxsb2NzKTtcbiAgICAgIGNvbnN0IHZhbHVlRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhzZXNzaW9uT3B0aW9ucy5lbmFibGVHcmFwaENhcHR1cmUudG9TdHJpbmcoKSwgYWxsb2NzKTtcbiAgICAgIGlmICh3YXNtLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIGtleURhdGFPZmZzZXQsIHZhbHVlRGF0YU9mZnNldCkgIT09IDApIHtcbiAgICAgICAgY2hlY2tMYXN0RXJyb3IoXG4gICAgICAgICAgICBgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdlbmFibGVHcmFwaENhcHR1cmUnIC0gJHtzZXNzaW9uT3B0aW9ucy5lbmFibGVHcmFwaENhcHR1cmV9LmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZXNzaW9uT3B0aW9ucy5mcmVlRGltZW5zaW9uT3ZlcnJpZGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc2Vzc2lvbk9wdGlvbnMuZnJlZURpbWVuc2lvbk92ZXJyaWRlcykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgbmFtZSBtdXN0IGJlIGEgc3RyaW5nOiAke25hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIodmFsdWUpIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgdmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyOiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWVPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcobmFtZSwgYWxsb2NzKTtcbiAgICAgICAgaWYgKHdhc20uX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZShzZXNzaW9uT3B0aW9uc0hhbmRsZSwgbmFtZU9mZnNldCwgdmFsdWUpICE9PSAwKSB7XG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IHNldCBhIGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlOiAke25hbWV9IC0gJHt2YWx1ZX0uYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnMuZXh0cmEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaXRlcmF0ZUV4dHJhT3B0aW9ucyhzZXNzaW9uT3B0aW9ucy5leHRyYSwgJycsIG5ldyBXZWFrU2V0PFJlY29yZDxzdHJpbmcsIHVua25vd24+PigpLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBrZXlEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKGtleSwgYWxsb2NzKTtcbiAgICAgICAgY29uc3QgdmFsdWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKHZhbHVlLCBhbGxvY3MpO1xuXG4gICAgICAgIGlmICh3YXNtLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIGtleURhdGFPZmZzZXQsIHZhbHVlRGF0YU9mZnNldCkgIT09IDApIHtcbiAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICR7a2V5fSAtICR7dmFsdWV9LmApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3Nlc3Npb25PcHRpb25zSGFuZGxlLCBhbGxvY3NdO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHNlc3Npb25PcHRpb25zSGFuZGxlICE9PSAwKSB7XG4gICAgICB3YXNtLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMoc2Vzc2lvbk9wdGlvbnNIYW5kbGUpO1xuICAgIH1cbiAgICBhbGxvY3MuZm9yRWFjaChhbGxvYyA9PiB3YXNtLl9mcmVlKGFsbG9jKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbi8vIGEgZHVtbXkgdHlwZSBkZWNsYXJhdGlvbiBmb3IgRmxvYXQxNkFycmF5IGluIGNhc2UgYW55IHBvbHlmaWxsIGlzIGF2YWlsYWJsZS5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBjb25zdCBGbG9hdDE2QXJyYXk6IGFueTtcbn1cblxuLy8gVGhpcyBmaWxlIGluY2x1ZGVzIGNvbW1vbiBkZWZpbml0aW9ucy4gVGhleSBkbyBOT1QgaGF2ZSBkZXBlbmRlbmN5IG9uIHRoZSBXZWJBc3NlbWJseSBpbnN0YW5jZS5cblxuLyoqXG4gKiBDb3BpZWQgZnJvbSBPTk5YIGRlZmluaXRpb24uIFVzZSB0aGlzIHRvIGRyb3AgZGVwZW5kZW5jeSAnb25ueF9wcm90bycgdG8gZGVjcmVhc2UgY29tcGlsZWQgLmpzIGZpbGUgc2l6ZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gRGF0YVR5cGUge1xuICB1bmRlZmluZWQgPSAwLFxuICBmbG9hdCA9IDEsXG4gIHVpbnQ4ID0gMixcbiAgaW50OCA9IDMsXG4gIHVpbnQxNiA9IDQsXG4gIGludDE2ID0gNSxcbiAgaW50MzIgPSA2LFxuICBpbnQ2NCA9IDcsXG4gIHN0cmluZyA9IDgsXG4gIGJvb2wgPSA5LFxuICBmbG9hdDE2ID0gMTAsXG4gIGRvdWJsZSA9IDExLFxuICB1aW50MzIgPSAxMixcbiAgdWludDY0ID0gMTMsXG4gIGNvbXBsZXg2NCA9IDE0LFxuICBjb21wbGV4MTI4ID0gMTUsXG4gIGJmbG9hdDE2ID0gMTZcbn1cblxuLyoqXG4gKiBNYXAgc3RyaW5nIHRlbnNvciBkYXRhIHRvIGVudW0gdmFsdWVcbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtID0gKHR5cGU6IHN0cmluZyk6IERhdGFUeXBlID0+IHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnaW50OCc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuaW50ODtcbiAgICBjYXNlICd1aW50OCc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUudWludDg7XG4gICAgY2FzZSAnYm9vbCc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuYm9vbDtcbiAgICBjYXNlICdpbnQxNic6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuaW50MTY7XG4gICAgY2FzZSAndWludDE2JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS51aW50MTY7XG4gICAgY2FzZSAnaW50MzInOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLmludDMyO1xuICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICByZXR1cm4gRGF0YVR5cGUudWludDMyO1xuICAgIGNhc2UgJ2Zsb2F0MTYnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLmZsb2F0MTY7XG4gICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuZmxvYXQ7XG4gICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuZG91YmxlO1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuc3RyaW5nO1xuICAgIGNhc2UgJ2ludDY0JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5pbnQ2NDtcbiAgICBjYXNlICd1aW50NjQnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLnVpbnQ2NDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0eXBlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIE1hcCBlbnVtIHZhbHVlIHRvIHN0cmluZyB0ZW5zb3IgZGF0YVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcgPSAodHlwZVByb3RvOiBEYXRhVHlwZSk6IFRlbnNvci5UeXBlID0+IHtcbiAgc3dpdGNoICh0eXBlUHJvdG8pIHtcbiAgICBjYXNlIERhdGFUeXBlLmludDg6XG4gICAgICByZXR1cm4gJ2ludDgnO1xuICAgIGNhc2UgRGF0YVR5cGUudWludDg6XG4gICAgICByZXR1cm4gJ3VpbnQ4JztcbiAgICBjYXNlIERhdGFUeXBlLmJvb2w6XG4gICAgICByZXR1cm4gJ2Jvb2wnO1xuICAgIGNhc2UgRGF0YVR5cGUuaW50MTY6XG4gICAgICByZXR1cm4gJ2ludDE2JztcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQxNjpcbiAgICAgIHJldHVybiAndWludDE2JztcbiAgICBjYXNlIERhdGFUeXBlLmludDMyOlxuICAgICAgcmV0dXJuICdpbnQzMic7XG4gICAgY2FzZSBEYXRhVHlwZS51aW50MzI6XG4gICAgICByZXR1cm4gJ3VpbnQzMic7XG4gICAgY2FzZSBEYXRhVHlwZS5mbG9hdDE2OlxuICAgICAgcmV0dXJuICdmbG9hdDE2JztcbiAgICBjYXNlIERhdGFUeXBlLmZsb2F0OlxuICAgICAgcmV0dXJuICdmbG9hdDMyJztcbiAgICBjYXNlIERhdGFUeXBlLmRvdWJsZTpcbiAgICAgIHJldHVybiAnZmxvYXQ2NCc7XG4gICAgY2FzZSBEYXRhVHlwZS5zdHJpbmc6XG4gICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgY2FzZSBEYXRhVHlwZS5pbnQ2NDpcbiAgICAgIHJldHVybiAnaW50NjQnO1xuICAgIGNhc2UgRGF0YVR5cGUudWludDY0OlxuICAgICAgcmV0dXJuICd1aW50NjQnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R5cGVQcm90b31gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBnZXQgdGVuc29yIGVsZW1lbnQgc2l6ZSBpbiBieXRlcyBieSB0aGUgZ2l2ZW4gZGF0YSB0eXBlXG4gKiBAcmV0dXJucyBzaXplIGluIGludGVnZXIgb3IgdW5kZWZpbmVkIGlmIHRoZSBkYXRhIHR5cGUgaXMgbm90IHN1cHBvcnRlZFxuICovXG5leHBvcnQgY29uc3QgZ2V0VGVuc29yRWxlbWVudFNpemUgPSAoZGF0ZVR5cGU6IG51bWJlcik6IG51bWJlcnxcbiAgICB1bmRlZmluZWQgPT4gW3VuZGVmaW5lZCwgNCwgMSwgMSwgMiwgMiwgNCwgOCwgdW5kZWZpbmVkLCAxLCAyLCA4LCA0LCA4LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXVtkYXRlVHlwZV07XG5cbi8qKlxuICogZ2V0IHR5cGVkIGFycmF5IGNvbnN0cnVjdG9yIGJ5IHRoZSBnaXZlbiB0ZW5zb3IgdHlwZVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gKHR5cGU6IFRlbnNvci5UeXBlKTogRmxvYXQzMkFycmF5Q29uc3RydWN0b3J8VWludDhBcnJheUNvbnN0cnVjdG9yfFxuICAgIEludDhBcnJheUNvbnN0cnVjdG9yfFVpbnQxNkFycmF5Q29uc3RydWN0b3J8SW50MTZBcnJheUNvbnN0cnVjdG9yfEludDMyQXJyYXlDb25zdHJ1Y3RvcnxCaWdJbnQ2NEFycmF5Q29uc3RydWN0b3J8XG4gICAgVWludDhBcnJheUNvbnN0cnVjdG9yfEZsb2F0NjRBcnJheUNvbnN0cnVjdG9yfFVpbnQzMkFycmF5Q29uc3RydWN0b3J8QmlnVWludDY0QXJyYXlDb25zdHJ1Y3RvciA9PiB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnZmxvYXQxNic6XG4gICAgICAgICAgLy8gYWxsb3cgRmxvYXQxNkFycmF5IHBvbHlmaWxsLlxuICAgICAgICAgIHJldHVybiB0eXBlb2YgRmxvYXQxNkFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBGbG9hdDE2QXJyYXkuZnJvbSA/IEZsb2F0MTZBcnJheSA6IFVpbnQxNkFycmF5O1xuICAgICAgICBjYXNlICdmbG9hdDMyJzpcbiAgICAgICAgICByZXR1cm4gRmxvYXQzMkFycmF5O1xuICAgICAgICBjYXNlICd1aW50OCc6XG4gICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXk7XG4gICAgICAgIGNhc2UgJ2ludDgnOlxuICAgICAgICAgIHJldHVybiBJbnQ4QXJyYXk7XG4gICAgICAgIGNhc2UgJ3VpbnQxNic6XG4gICAgICAgICAgcmV0dXJuIFVpbnQxNkFycmF5O1xuICAgICAgICBjYXNlICdpbnQxNic6XG4gICAgICAgICAgcmV0dXJuIEludDE2QXJyYXk7XG4gICAgICAgIGNhc2UgJ2ludDMyJzpcbiAgICAgICAgICByZXR1cm4gSW50MzJBcnJheTtcbiAgICAgICAgY2FzZSAnYm9vbCc6XG4gICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXk7XG4gICAgICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgICAgIHJldHVybiBGbG9hdDY0QXJyYXk7XG4gICAgICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICAgICAgcmV0dXJuIFVpbnQzMkFycmF5O1xuICAgICAgICBjYXNlICdpbnQ2NCc6XG4gICAgICAgICAgcmV0dXJuIEJpZ0ludDY0QXJyYXk7XG4gICAgICAgIGNhc2UgJ3VpbnQ2NCc6XG4gICAgICAgICAgcmV0dXJuIEJpZ1VpbnQ2NEFycmF5O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZTogJHt0eXBlfWApO1xuICAgICAgfVxuICAgIH07XG5cbi8qKlxuICogTWFwIHN0cmluZyBsb2cgbGV2ZWwgdG8gaW50ZWdlciB2YWx1ZVxuICovXG5leHBvcnQgY29uc3QgbG9nTGV2ZWxTdHJpbmdUb0VudW0gPSAobG9nTGV2ZWw/OiAndmVyYm9zZSd8J2luZm8nfCd3YXJuaW5nJ3wnZXJyb3InfCdmYXRhbCcpOiBudW1iZXIgPT4ge1xuICBzd2l0Y2ggKGxvZ0xldmVsKSB7XG4gICAgY2FzZSAndmVyYm9zZSc6XG4gICAgICByZXR1cm4gMDtcbiAgICBjYXNlICdpbmZvJzpcbiAgICAgIHJldHVybiAxO1xuICAgIGNhc2UgJ3dhcm5pbmcnOlxuICAgICAgcmV0dXJuIDI7XG4gICAgY2FzZSAnZXJyb3InOlxuICAgICAgcmV0dXJuIDM7XG4gICAgY2FzZSAnZmF0YWwnOlxuICAgICAgcmV0dXJuIDQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHtsb2dMZXZlbH1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiB0ZW5zb3IgdHlwZSBpcyBzdXBwb3J0ZWQgYnkgR1BVIGJ1ZmZlclxuICovXG5leHBvcnQgY29uc3QgaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlID0gKHR5cGU6IFRlbnNvci5UeXBlKTogdHlwZSBpcyBUZW5zb3IuR3B1QnVmZmVyRGF0YVR5cGVzID0+IHR5cGUgPT09ICdmbG9hdDMyJyB8fFxuICAgIHR5cGUgPT09ICdmbG9hdDE2JyB8fCB0eXBlID09PSAnaW50MzInIHx8IHR5cGUgPT09ICdpbnQ2NCcgfHwgdHlwZSA9PT0gJ3VpbnQzMicgfHwgdHlwZSA9PT0gJ3VpbnQ4JyB8fFxuICAgIHR5cGUgPT09ICdib29sJztcblxuLyoqXG4gKiBNYXAgc3RyaW5nIGRhdGEgbG9jYXRpb24gdG8gaW50ZWdlciB2YWx1ZVxuICovXG5leHBvcnQgY29uc3QgZGF0YUxvY2F0aW9uU3RyaW5nVG9FbnVtID0gKGxvY2F0aW9uOiBUZW5zb3IuRGF0YUxvY2F0aW9uKTogbnVtYmVyID0+IHtcbiAgc3dpdGNoIChsb2NhdGlvbikge1xuICAgIGNhc2UgJ25vbmUnOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSAnY3B1JzpcbiAgICAgIHJldHVybiAxO1xuICAgIGNhc2UgJ2NwdS1waW5uZWQnOlxuICAgICAgcmV0dXJuIDI7XG4gICAgY2FzZSAndGV4dHVyZSc6XG4gICAgICByZXR1cm4gMztcbiAgICBjYXNlICdncHUtYnVmZmVyJzpcbiAgICAgIHJldHVybiA0O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgbG9jYXRpb246ICR7bG9jYXRpb259YCk7XG4gIH1cbn07XG5cbi8qKlxuICogTWFwIGludGVnZXIgZGF0YSBsb2NhdGlvbiB0byBzdHJpbmcgdmFsdWVcbiAqL1xuZXhwb3J0IGNvbnN0IGRhdGFMb2NhdGlvbkVudW1Ub1N0cmluZyA9IChsb2NhdGlvbjogbnVtYmVyKTogVGVuc29yLkRhdGFMb2NhdGlvbnx1bmRlZmluZWQgPT5cbiAgICAoWydub25lJywgJ2NwdScsICdjcHUtcGlubmVkJywgJ3RleHR1cmUnLCAnZ3B1LWJ1ZmZlciddIGFzIGNvbnN0KVtsb2NhdGlvbl07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7aXNOb2RlfSBmcm9tICcuL3dhc20tdXRpbHMtZW52JztcblxuLyoqXG4gKiBMb2FkIGEgZmlsZSBpbnRvIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gZmlsZSAtIHRoZSBmaWxlIHRvIGxvYWQuIENhbiBiZSBhIFVSTC9wYXRoLCBhIEJsb2IsIGFuIEFycmF5QnVmZmVyLCBvciBhIFVpbnQ4QXJyYXkuXG4gKiBAcmV0dXJucyBhIFVpbnQ4QXJyYXkgY29udGFpbmluZyB0aGUgZmlsZSBkYXRhLlxuICovXG5leHBvcnQgY29uc3QgbG9hZEZpbGUgPSBhc3luYyhmaWxlOiBzdHJpbmd8QmxvYnxBcnJheUJ1ZmZlckxpa2V8VWludDhBcnJheSk6IFByb21pc2U8VWludDhBcnJheT4gPT4ge1xuICBpZiAodHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgLy8gbG9hZCBmaWxlIGludG8gQXJyYXlCdWZmZXIgaW4gTm9kZS5qc1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qge3JlYWRGaWxlfSA9IHJlcXVpcmUoJ25vZGU6ZnMvcHJvbWlzZXMnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHJlYWRGaWxlKGZpbGUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUuY29kZSA9PT0gJ0VSUl9GU19GSUxFX1RPT19MQVJHRScpIHtcbiAgICAgICAgICAvLyBmaWxlIGlzIHRvbyBsYXJnZSwgdXNlIGZzLmNyZWF0ZVJlYWRTdHJlYW0gaW5zdGVhZFxuICAgICAgICAgIGNvbnN0IHtjcmVhdGVSZWFkU3RyZWFtfSA9IHJlcXVpcmUoJ25vZGU6ZnMnKTtcbiAgICAgICAgICBjb25zdCBzdHJlYW0gPSBjcmVhdGVSZWFkU3RyZWFtKGZpbGUpO1xuICAgICAgICAgIGNvbnN0IGNodW5rczogVWludDhBcnJheVtdID0gW107XG4gICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5jb25jYXQoY2h1bmtzKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbG9hZCBmaWxlIGludG8gQXJyYXlCdWZmZXIgaW4gYnJvd3NlcnNcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goZmlsZSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGxvYWQgZXh0ZXJuYWwgZGF0YSBmaWxlOiAke2ZpbGV9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb250ZW50TGVuZ3RoSGVhZGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ0NvbnRlbnQtTGVuZ3RoJyk7XG4gICAgICBjb25zdCBmaWxlU2l6ZSA9IGNvbnRlbnRMZW5ndGhIZWFkZXIgPyBwYXJzZUludChjb250ZW50TGVuZ3RoSGVhZGVyLCAxMCkgOiAwO1xuICAgICAgaWYgKGZpbGVTaXplIDwgMTA3Mzc0MTgyNCAvKiAxR0IgKi8pIHtcbiAgICAgICAgLy8gd2hlbiBDb250ZW50LUxlbmd0aCBoZWFkZXIgaXMgbm90IHNldCwgd2UgY2Fubm90IGRldGVybWluZSB0aGUgZmlsZSBzaXplLiBXZSBhc3N1bWUgaXQgaXMgc21hbGwgZW5vdWdoIHRvXG4gICAgICAgIC8vIGxvYWQgaW50byBtZW1vcnkuXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZpbGUgaXMgdG9vIGxhcmdlLCB1c2Ugc3RyZWFtIGluc3RlYWRcbiAgICAgICAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gbG9hZCBleHRlcm5hbCBkYXRhIGZpbGU6ICR7ZmlsZX0sIG5vIHJlc3BvbnNlIGJvZHkuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcblxuICAgICAgICBsZXQgYnVmZmVyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIHRyeSB0byBjcmVhdGUgQXJyYXlCdWZmZXIgZGlyZWN0bHlcbiAgICAgICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoZmlsZVNpemUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBSYW5nZUVycm9yKSB7XG4gICAgICAgICAgICAvLyB1c2UgV2ViQXNzZW1ibHkgTWVtb3J5IHRvIGFsbG9jYXRlIGxhcmdlciBBcnJheUJ1ZmZlclxuICAgICAgICAgICAgY29uc3QgcGFnZXMgPSBNYXRoLmNlaWwoZmlsZVNpemUgLyA2NTUzNik7XG4gICAgICAgICAgICBidWZmZXIgPSBuZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOiBwYWdlcywgbWF4aW11bTogcGFnZXN9KS5idWZmZXI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCB7ZG9uZSwgdmFsdWV9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgY29uc3QgY2h1bmsgPSBuZXcgVWludDhBcnJheShidWZmZXIsIG9mZnNldCwgY2h1bmtTaXplKTtcbiAgICAgICAgICBjaHVuay5zZXQodmFsdWUpO1xuICAgICAgICAgIG9mZnNldCArPSBjaHVua1NpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgMCwgZmlsZVNpemUpO1xuICAgICAgfVxuICAgIH1cblxuICB9IGVsc2UgaWYgKGZpbGUgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IGZpbGUuYXJyYXlCdWZmZXIoKSk7XG4gIH0gZWxzZSBpZiAoZmlsZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gZmlsZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZmlsZSk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RW52LCBJbmZlcmVuY2VTZXNzaW9uLCBUZW5zb3J9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7U2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXIsIFNlcmlhbGl6YWJsZVNlc3Npb25NZXRhZGF0YSwgU2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGEsIFRlbnNvck1ldGFkYXRhfSBmcm9tICcuL3Byb3h5LW1lc3NhZ2VzJztcbmltcG9ydCB7c2V0UnVuT3B0aW9uc30gZnJvbSAnLi9ydW4tb3B0aW9ucyc7XG5pbXBvcnQge3NldFNlc3Npb25PcHRpb25zfSBmcm9tICcuL3Nlc3Npb24tb3B0aW9ucyc7XG5pbXBvcnQge2RhdGFMb2NhdGlvblN0cmluZ1RvRW51bSwgZ2V0VGVuc29yRWxlbWVudFNpemUsIGlzR3B1QnVmZmVyU3VwcG9ydGVkVHlwZSwgbG9nTGV2ZWxTdHJpbmdUb0VudW0sIHRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nLCB0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bSwgdGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yfSBmcm9tICcuL3dhc20tY29tbW9uJztcbmltcG9ydCB7Z2V0SW5zdGFuY2V9IGZyb20gJy4vd2FzbS1mYWN0b3J5JztcbmltcG9ydCB7YWxsb2NXYXNtU3RyaW5nLCBjaGVja0xhc3RFcnJvcn0gZnJvbSAnLi93YXNtLXV0aWxzJztcbmltcG9ydCB7bG9hZEZpbGV9IGZyb20gJy4vd2FzbS11dGlscy1sb2FkLWZpbGUnO1xuXG4vLyAjcmVnaW9uIEluaXRpYWxpemF0aW9uc1xuXG4vKipcbiAqIFRoZXJlIGFyZSA0IGRpZmZlcmVudCBcImluaXRpYWxpemF0aW9uXCIgc3RlcHMgZm9yIE9SVC4gVGhleSBoYXBwZW4gaW4gZGlmZmVyZW50IHBsYWNlcyBhbmQgZGlmZmVyZW50IHRpbWUuXG4gKlxuICogMS4gSmF2YVNjcmlwdCBpbml0aWFsaXphdGlvbiBmb3Igb25ueHJ1bnRpbWUtY29tbW9uIGFuZCBvbm54cnVudGltZS13ZWIuXG4gKiAgICBUaGlzIGlzIHRoZSBmaXJzdCBpbml0aWFsaXphdGlvbiBzdGVwLiBJbiB0aGlzIHN0ZXAsIG9ubnhydW50aW1lLXdlYiBjYWxscyBvbm54cnVudGltZS1jb21tb24ncyByZWdpc3RlckJhY2tlbmQoKVxuICogZnVuY3Rpb24gbXVsdGlwbGUgdGltZXMgdG8gcmVnaXN0ZXIgYWxsIHRoZSBhdmFpbGFibGUgYmFja2VuZHMuIFRoZSBiYWNrZW5kIHJlZ2lzdHJhdGlvbiBpcyB2ZXJ5IGZhc3QuIEl0IG9ubHlcbiAqIHJlZ2lzdGVycyB0aGUgYmFja2VuZCBuYW1lIHdpdGggdGhlIHVuaW5pdGlhbGl6ZWQgYmFja2VuZCBvYmplY3QuIE5vIGhlYXZ5IGluaXRpYWxpemF0aW9uIGlzIGRvbmUgaW4gdGhpcyBzdGVwLlxuICogICAgUmVmZXIgdG8gd2ViL2xpYi9pbmRleC50cyBmb3IgdGhlIGJhY2tlbmQgcmVnaXN0cmF0aW9uLlxuICpcbiAqIDIuIFdlYkFzc2VtYmx5IGFydGlmYWN0IGluaXRpYWxpemF0aW9uLlxuICogICAgVGhpcyBoYXBwZW5zIHdoZW4gYW55IHJlZ2lzdGVyZWQgd2FzbSBiYWNrZW5kIGlzIHVzZWQgZm9yIHRoZSBmaXJzdCB0aW1lIChpZS4gYG9ydC5JbmZlcmVuY2VTZXNzaW9uLmNyZWF0ZSgpYCBvclxuICogYG9ydC5UcmFpbmluZ1Nlc3Npb24uY3JlYXRlKClgIGlzIGNhbGxlZCkuIEluIHRoaXMgc3RlcCwgb25ueHJ1bnRpbWUtd2ViIGRvZXMgdGhlIGZvbGxvd2luZ3M6XG4gKiAgICAgLSBjcmVhdGUgYSBwcm94eSB3b3JrZXIgYW5kIG1ha2Ugc3VyZSB0aGUgcHJveHkgd29ya2VyIGlzIHJlYWR5IHRvIHJlY2VpdmUgbWVzc2FnZXMsIGlmIHByb3h5IGlzIGVuYWJsZWQuXG4gKiAgICAgLSBwZXJmb3JtIGZlYXR1cmUgZGV0ZWN0aW9uLCBsb2NhdGUgY29ycmVjdCBXZWJBc3NlbWJseSBhcnRpZmFjdCBwYXRoIGFuZCBjYWxsIHRoZSBFbXNjcmlwdGVuIGdlbmVyYXRlZFxuICogSmF2YVNjcmlwdCBjb2RlIHRvIGluaXRpYWxpemUgdGhlIFdlYkFzc2VtYmx5IHJ1bnRpbWUuXG4gKiAgICAgICAgIC0gaWYgcHJveHkgaXMgZW5hYmxlZCwgdGhpcyBzdGVwIGhhcHBlbnMgaW4gdGhlIHByb3h5IHdvcmtlciB1c2luZyBtZXNzYWdlICdpbml0LXdhc20nLlxuICogICAgICAgICAtIGRvd25sb2FkaW5nIHRoZSAnb3J0LXdhc217Li4ufS53YXNtJyBmaWxlIGlzIGRvbmUgaW4gdGhpcyBzdGVwLlxuICogICAgICAgICAtIGlmIG11bHRpLXRocmVhZCBpcyBlbmFibGVkLCBvbmUgb3IgbW9yZSB3ZWJ3b3JrZXIgd2lsbCBiZSBjcmVhdGVkIHRvIGluaXRpYWxpemUgdGhlIFBUaHJlYWQgdGhyZWFkcG9vbC5cbiAqXG4gKiAzLiBPUlQgZW52aXJvbm1lbnQgaW5pdGlhbGl6YXRpb24uXG4gKiAgICBUaGlzIGhhcHBlbnMgYWZ0ZXIgc3RlcCAyLiBJbiB0aGlzIHN0ZXAsIG9ubnhydW50aW1lLXdlYiBwZXJmb3JtcyBPTk5YIFJ1bnRpbWUgZW52aXJvbm1lbnQgaW5pdGlhbGl6YXRpb24uXG4gKiBGdW5jdGlvbiBgX09ydEluaXQoKWAgaXMgY2FsbGVkIGluIHRoaXMgc3RlcC5cbiAqICAgICAtIGlmIHByb3h5IGlzIGVuYWJsZWQsIHRoaXMgc3RlcCBoYXBwZW5zIGluIHRoZSBwcm94eSB3b3JrZXIgdXNpbmcgbWVzc2FnZSAnaW5pdC1vcnQnLlxuICogICAgIC0gbG9nZ2luZyBsZXZlbCAob3J0LmVudi5sb2dMZXZlbCkgYW5kIHRocmVhZCBudW1iZXIgKG9ydC5lbnYud2FzbS5udW1UaHJlYWRzKSBhcmUgc2V0IGluIHRoaXMgc3RlcC5cbiAqXG4gKiA0LiBTZXNzaW9uIGluaXRpYWxpemF0aW9uLlxuICogICAgVGhpcyBoYXBwZW5zIHdoZW4gYG9ydC5JbmZlcmVuY2VTZXNzaW9uLmNyZWF0ZSgpYCBvciBgb3J0LlRyYWluaW5nU2Vzc2lvbi5jcmVhdGUoKWAgaXMgY2FsbGVkLiBVbmxpa2UgdGhlIGZpcnN0IDNcbiAqIHN0ZXBzICh0aGV5IG9ubHkgY2FsbGVkIG9uY2UpLCB0aGlzIHN0ZXAgd2lsbCBiZSBkb25lIGZvciBlYWNoIHNlc3Npb24uIEluIHRoaXMgc3RlcCwgb25ueHJ1bnRpbWUtd2ViIGRvZXMgdGhlXG4gKiBmb2xsb3dpbmdzOlxuICogICAgSWYgdGhlIHBhcmFtZXRlciBpcyBhIFVSTDpcbiAqICAgIC0gZG93bmxvYWQgdGhlIG1vZGVsIGRhdGEgZnJvbSB0aGUgVVJMLlxuICogICAgLSBjb3B5IHRoZSBtb2RlbCBkYXRhIHRvIHRoZSBXQVNNIGhlYXAuIChwcm94eTogJ2NvcHktZnJvbScpXG4gKiAgICAtIGRlcmVmZXJlbmNlIHRoZSBtb2RlbCBidWZmZXIuIFRoaXMgc3RlcCBhbGxvd3MgdGhlIG9yaWdpbmFsIEFycmF5QnVmZmVyIHRvIGJlIGdhcmJhZ2UgY29sbGVjdGVkLlxuICogICAgLSBjYWxsIGBfT3J0Q3JlYXRlU2Vzc2lvbigpYCB0byBjcmVhdGUgdGhlIHNlc3Npb24uIChwcm94eTogJ2NyZWF0ZScpXG4gKlxuICogICAgSWYgdGhlIHBhcmFtZXRlciBpcyBhIFVpbnQ4QXJyYXkgb2JqZWN0OlxuICogICAgLSBjb3B5IHRoZSBtb2RlbCBkYXRhIHRvIHRoZSBXQVNNIGhlYXAuIChwcm94eTogJ2NvcHktZnJvbScpXG4gKiAgICAtIGNhbGwgYF9PcnRDcmVhdGVTZXNzaW9uKClgIHRvIGNyZWF0ZSB0aGUgc2Vzc2lvbi4gKHByb3h5OiAnY3JlYXRlJylcbiAqXG4gKlxuICovXG5cbi8qKlxuICogaW5pdGlhbGl6ZSBPUlQgZW52aXJvbm1lbnQuXG4gKlxuICogQHBhcmFtIG51bVRocmVhZHMgU2V0R2xvYmFsSW50cmFPcE51bVRocmVhZHMobnVtVGhyZWFkcylcbiAqIEBwYXJhbSBsb2dnaW5nTGV2ZWwgQ3JlYXRlRW52KHN0YXRpY19jYXN0PE9ydExvZ2dpbmdMZXZlbD4obG9nZ2luZ19sZXZlbCkpXG4gKi9cbmNvbnN0IGluaXRPcnQgPSAobnVtVGhyZWFkczogbnVtYmVyLCBsb2dnaW5nTGV2ZWw6IG51bWJlcik6IHZvaWQgPT4ge1xuICBjb25zdCBlcnJvckNvZGUgPSBnZXRJbnN0YW5jZSgpLl9PcnRJbml0KG51bVRocmVhZHMsIGxvZ2dpbmdMZXZlbCk7XG4gIGlmIChlcnJvckNvZGUgIT09IDApIHtcbiAgICBjaGVja0xhc3RFcnJvcignQ2FuXFwndCBpbml0aWFsaXplIG9ubnhydW50aW1lLicpO1xuICB9XG59O1xuXG4vKipcbiAqIGludGlhbGl6ZSBydW50aW1lIGVudmlyb25tZW50LlxuICogQHBhcmFtIGVudiBwYXNzZWQgaW4gdGhlIGVudmlyb25tZW50IGNvbmZpZyBvYmplY3QuXG4gKi9cbmV4cG9ydCBjb25zdCBpbml0UnVudGltZSA9IGFzeW5jKGVudjogRW52KTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIC8vIGluaXQgT1JUXG4gIGluaXRPcnQoZW52Lndhc20ubnVtVGhyZWFkcyEsIGxvZ0xldmVsU3RyaW5nVG9FbnVtKGVudi5sb2dMZXZlbCkpO1xufTtcblxuLyoqXG4gKiBwZXJmb3JtIEVQIHNwZWNpZmljIGluaXRpYWxpemF0aW9uLlxuICpcbiAqIEBwYXJhbSBlbnZcbiAqIEBwYXJhbSBlcE5hbWVcbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRFcCA9IGFzeW5jKGVudjogRW52LCBlcE5hbWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMsIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcbiAgICBjb25zdCBpbml0SnNlcCA9IHJlcXVpcmUoJy4vanNlcC9pbml0JykuaW5pdDtcblxuICAgIGlmIChlcE5hbWUgPT09ICd3ZWJncHUnKSB7XG4gICAgICAvLyBwZXJmb3JtIFdlYkdQVSBhdmFpbGFiaWxpdHkgY2hlY2tcbiAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhbmF2aWdhdG9yLmdwdSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdQVSBpcyBub3Qgc3VwcG9ydGVkIGluIGN1cnJlbnQgZW52aXJvbm1lbnQnKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGFkYXB0ZXIgPSBlbnYud2ViZ3B1LmFkYXB0ZXIgYXMgR1BVQWRhcHRlciB8IG51bGw7XG4gICAgICBpZiAoIWFkYXB0ZXIpIHtcbiAgICAgICAgLy8gaWYgYWRhcHRlciBpcyBub3Qgc2V0LCByZXF1ZXN0IGEgbmV3IGFkYXB0ZXIuXG4gICAgICAgIGNvbnN0IHBvd2VyUHJlZmVyZW5jZSA9IGVudi53ZWJncHUucG93ZXJQcmVmZXJlbmNlO1xuICAgICAgICBpZiAocG93ZXJQcmVmZXJlbmNlICE9PSB1bmRlZmluZWQgJiYgcG93ZXJQcmVmZXJlbmNlICE9PSAnbG93LXBvd2VyJyAmJlxuICAgICAgICAgICAgcG93ZXJQcmVmZXJlbmNlICE9PSAnaGlnaC1wZXJmb3JtYW5jZScpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcG93ZXJQcmVmZXJlbmNlIHNldHRpbmc6IFwiJHtwb3dlclByZWZlcmVuY2V9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JjZUZhbGxiYWNrQWRhcHRlciA9IGVudi53ZWJncHUuZm9yY2VGYWxsYmFja0FkYXB0ZXI7XG4gICAgICAgIGlmIChmb3JjZUZhbGxiYWNrQWRhcHRlciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBmb3JjZUZhbGxiYWNrQWRhcHRlciAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZvcmNlRmFsbGJhY2tBZGFwdGVyIHNldHRpbmc6IFwiJHtmb3JjZUZhbGxiYWNrQWRhcHRlcn1cImApO1xuICAgICAgICB9XG4gICAgICAgIGFkYXB0ZXIgPSBhd2FpdCBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKHtwb3dlclByZWZlcmVuY2UsIGZvcmNlRmFsbGJhY2tBZGFwdGVyfSk7XG4gICAgICAgIGlmICghYWRhcHRlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgJ0ZhaWxlZCB0byBnZXQgR1BVIGFkYXB0ZXIuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBuZWVkIHRvIGVuYWJsZSBmbGFnIFwiLS1lbmFibGUtdW5zYWZlLXdlYmdwdVwiIGlmIHlvdSBhcmUgdXNpbmcgQ2hyb21lLicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBhZGFwdGVyIGlzIHNldCwgdmFsaWRhdGUgaXQuXG4gICAgICAgIGlmICh0eXBlb2YgYWRhcHRlci5saW1pdHMgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBhZGFwdGVyLmZlYXR1cmVzICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGFkYXB0ZXIucmVxdWVzdERldmljZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHUFUgYWRhcHRlciBzZXQgaW4gYGVudi53ZWJncHUuYWRhcHRlcmAuIEl0IG11c3QgYmUgYSBHUFVBZGFwdGVyIG9iamVjdC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhd2FpdCBpbml0SnNlcCgnd2ViZ3B1JywgZ2V0SW5zdGFuY2UoKSwgZW52LCBhZGFwdGVyKTtcbiAgICB9XG4gICAgaWYgKGVwTmFtZSA9PT0gJ3dlYm5uJykge1xuICAgICAgLy8gcGVyZm9ybSBXZWJOTiBhdmFpbGFiaWxpdHkgY2hlY2tcbiAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhKG5hdmlnYXRvciBhcyB1bmtub3duIGFzIHttbDogdW5rbm93bn0pLm1sKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViTk4gaXMgbm90IHN1cHBvcnRlZCBpbiBjdXJyZW50IGVudmlyb25tZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IGluaXRKc2VwKCd3ZWJubicsIGdldEluc3RhbmNlKCksIGVudik7XG4gICAgfVxuICB9XG59O1xuXG4vLyAjZW5kcmVnaW9uIEluaXRpYWxpemF0aW9uc1xuXG4vKipcbiAqIHZhbGlkIGRhdGEgbG9jYXRpb25zIGZvciBpbnB1dC9vdXRwdXQgdGVuc29ycy5cbiAqL1xudHlwZSBTdXBwb3J0ZWRUZW5zb3JEYXRhTG9jYXRpb25Gb3JJbnB1dE91dHB1dCA9ICdjcHUnfCdjcHUtcGlubmVkJ3wnZ3B1LWJ1ZmZlcic7XG5cbnR5cGUgSU9CaW5kaW5nU3RhdGUgPSB7XG4gIC8qKlxuICAgKiB0aGUgaGFuZGxlIG9mIElPIGJpbmRpbmcuXG4gICAqL1xuICByZWFkb25seSBoYW5kbGU6IG51bWJlcjtcblxuICAvKipcbiAgICogdGhlIHByZWZlcnJlZCBsb2NhdGlvbiBmb3IgZWFjaCBvdXRwdXQgdGVuc29yLlxuICAgKlxuICAgKiB2YWx1ZSBpcyBvbmUgb2YgJ2NwdScsICdjcHUtcGlubmVkJywgJ2dwdS1idWZmZXInLlxuICAgKi9cbiAgcmVhZG9ubHkgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zOiByZWFkb25seSBTdXBwb3J0ZWRUZW5zb3JEYXRhTG9jYXRpb25Gb3JJbnB1dE91dHB1dFtdO1xuXG4gIC8qKlxuICAgKiBlbnVtIHZhbHVlIG9mIHRoZSBwcmVmZXJyZWQgbG9jYXRpb24gZm9yIGVhY2ggb3V0cHV0IHRlbnNvci5cbiAgICovXG4gIHJlYWRvbmx5IG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6IHJlYWRvbmx5IG51bWJlcltdO1xufTtcblxuLyoqXG4gKiAgdHVwbGUgZWxlbWVudHMgYXJlOiBJbmZlcmVuY2VTZXNzaW9uIElEOyBpbnB1dE5hbWVzVVRGOEVuY29kZWQ7IG91dHB1dE5hbWVzVVRGOEVuY29kZWQ7IGJpbmRpbmdTdGF0ZVxuICovXG50eXBlIFNlc3Npb25NZXRhZGF0YSA9IFtcbiAgaW5mZXJlbmNlU2Vzc2lvbklkOiBudW1iZXIsIGlucHV0TmFtZXNVVEY4RW5jb2RlZDogbnVtYmVyW10sIG91dHB1dE5hbWVzVVRGOEVuY29kZWQ6IG51bWJlcltdLFxuICBiaW5kaW5nU3RhdGU6IElPQmluZGluZ1N0YXRlfG51bGwsIGVuYWJsZUdyYXBoQ2FwdHVyZTogYm9vbGVhbiwgaW5wdXRPdXRwdXRCb3VuZDogYm9vbGVhblxuXTtcblxuY29uc3QgYWN0aXZlU2Vzc2lvbnMgPSBuZXcgTWFwPG51bWJlciwgU2Vzc2lvbk1ldGFkYXRhPigpO1xuXG4vKipcbiAqIGdldCB0aGUgaW5wdXQvb3V0cHV0IGNvdW50IG9mIHRoZSBzZXNzaW9uLlxuICogQHBhcmFtIHNlc3Npb25IYW5kbGUgdGhlIGhhbmRsZSByZXByZXNlbnRpbmcgdGhlIHNlc3Npb24uIHNob3VsZCBiZSBub24temVyby5cbiAqIEByZXR1cm5zIGEgdHVwbGUgaW5jbHVkaW5nIDIgbnVtYmVycywgcmVwcmVzZW50aW5nIHRoZSBpbnB1dCBjb3VudCBhbmQgb3V0cHV0IGNvdW50LlxuICovXG5jb25zdCBnZXRTZXNzaW9uSW5wdXRPdXRwdXRDb3VudCA9IChzZXNzaW9uSGFuZGxlOiBudW1iZXIpOiBbbnVtYmVyLCBudW1iZXJdID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGNvbnN0IHN0YWNrID0gd2FzbS5zdGFja1NhdmUoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRhT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKDgpO1xuICAgIGNvbnN0IGVycm9yQ29kZSA9IHdhc20uX09ydEdldElucHV0T3V0cHV0Q291bnQoc2Vzc2lvbkhhbmRsZSwgZGF0YU9mZnNldCwgZGF0YU9mZnNldCArIDQpO1xuICAgIGlmIChlcnJvckNvZGUgIT09IDApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKCdDYW5cXCd0IGdldCBzZXNzaW9uIGlucHV0L291dHB1dCBjb3VudC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIFt3YXNtLkhFQVAzMltkYXRhT2Zmc2V0IC8gNF0sIHdhc20uSEVBUDMyW2RhdGFPZmZzZXQgLyA0ICsgMV1dO1xuICB9IGZpbmFsbHkge1xuICAgIHdhc20uc3RhY2tSZXN0b3JlKHN0YWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBhbGxvY2F0ZSB0aGUgbWVtb3J5IGFuZCBtZW1jcHkgdGhlIGV4dGVybmFsIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gbW9kZWwgLSB0aGUgZXh0ZXJuYWwgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIG1vZGVsIGRhdGEuIE11c3Qgbm90IGJlIHRoZSBzYW1lIGJ1ZmZlciBhcyB0aGUgV0FTTSBoZWFwLlxuICogQHJldHVybnMgYSAyLWVsZW1lbnRzIHR1cGxlIC0gdGhlIHBvaW50ZXIgYW5kIHNpemUgb2YgdGhlIGFsbG9jYXRlZCBidWZmZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIgPSAobW9kZWw6IFVpbnQ4QXJyYXkpOiBbbnVtYmVyLCBudW1iZXJdID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGNvbnN0IG1vZGVsRGF0YU9mZnNldCA9IHdhc20uX21hbGxvYyhtb2RlbC5ieXRlTGVuZ3RoKTtcbiAgaWYgKG1vZGVsRGF0YU9mZnNldCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgY3JlYXRlIGEgc2Vzc2lvbi4gZmFpbGVkIHRvIGFsbG9jYXRlIGEgYnVmZmVyIG9mIHNpemUgJHttb2RlbC5ieXRlTGVuZ3RofS5gKTtcbiAgfVxuICB3YXNtLkhFQVBVOC5zZXQobW9kZWwsIG1vZGVsRGF0YU9mZnNldCk7XG4gIHJldHVybiBbbW9kZWxEYXRhT2Zmc2V0LCBtb2RlbC5ieXRlTGVuZ3RoXTtcbn07XG5cbi8qKlxuICogY3JlYXRlIGFuIGluZmVyZW5jZSBzZXNzaW9uIGZyb20gYSBtb2RlbCBkYXRhIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gbW9kZWxEYXRhIC0gZWl0aGVyIGEgVWludDhBcnJheSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBtb2RlbCBkYXRhLCBvciBhIDItZWxlbWVudHMgdHVwbGUgY29udGFpbmluZyB0aGVcbiAqICAgICBwb2ludGVyIGFuZCBzaXplIG9mIHRoZSBtb2RlbCBkYXRhIGJ1ZmZlci5cbiAqIEBwYXJhbSBvcHRpb25zIGFuIG9wdGlvbmFsIHNlc3Npb24gb3B0aW9ucyBvYmplY3QuXG4gKiBAcmV0dXJucyBhIDMtZWxlbWVudHMgdHVwbGUgY29udGFpbmluZyBbc2Vzc2lvbiBoYW5kbGUsIGlucHV0IG5hbWVzLCBvdXRwdXQgbmFtZXNdXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVTZXNzaW9uID0gYXN5bmMoXG4gICAgbW9kZWxEYXRhOiBVaW50OEFycmF5fFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyLFxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxTZXJpYWxpemFibGVTZXNzaW9uTWV0YWRhdGE+ID0+IHtcbiAgbGV0IG1vZGVsRGF0YU9mZnNldDogbnVtYmVyLCBtb2RlbERhdGFMZW5ndGg6IG51bWJlcjtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobW9kZWxEYXRhKSkge1xuICAgIC8vIGlmIG1vZGVsIGRhdGEgaXMgYW4gYXJyYXksIGl0IG11c3QgYmUgYSAyLWVsZW1lbnRzIHR1cGxlIGNvbnRhaW5pbmcgdGhlIHBvaW50ZXIgYW5kIHNpemUgb2YgdGhlIG1vZGVsIGRhdGFcbiAgICBbbW9kZWxEYXRhT2Zmc2V0LCBtb2RlbERhdGFMZW5ndGhdID0gbW9kZWxEYXRhO1xuICB9IGVsc2UgaWYgKG1vZGVsRGF0YS5idWZmZXIgPT09IHdhc20uSEVBUFU4LmJ1ZmZlcikge1xuICAgIC8vIGlmIG1vZGVsIGRhdGEgdXNlcyB0aGUgc2FtZSBidWZmZXIgYXMgdGhlIFdBU00gaGVhcCwgd2UgZG9uJ3QgbmVlZCB0byBjb3B5IGl0LlxuICAgIFttb2RlbERhdGFPZmZzZXQsIG1vZGVsRGF0YUxlbmd0aF0gPSBbbW9kZWxEYXRhLmJ5dGVPZmZzZXQsIG1vZGVsRGF0YS5ieXRlTGVuZ3RoXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBvdGhlcndpc2UsIGNvcHkgdGhlIG1vZGVsIGRhdGEgdG8gdGhlIFdBU00gaGVhcC5cbiAgICBbbW9kZWxEYXRhT2Zmc2V0LCBtb2RlbERhdGFMZW5ndGhdID0gY29weUZyb21FeHRlcm5hbEJ1ZmZlcihtb2RlbERhdGEpO1xuICB9XG5cbiAgbGV0IHNlc3Npb25IYW5kbGUgPSAwO1xuICBsZXQgc2Vzc2lvbk9wdGlvbnNIYW5kbGUgPSAwO1xuICBsZXQgaW9CaW5kaW5nSGFuZGxlID0gMDtcbiAgbGV0IGFsbG9jczogbnVtYmVyW10gPSBbXTtcbiAgY29uc3QgaW5wdXROYW1lc1VURjhFbmNvZGVkID0gW107XG4gIGNvbnN0IG91dHB1dE5hbWVzVVRGOEVuY29kZWQgPSBbXTtcblxuICB0cnkge1xuICAgIFtzZXNzaW9uT3B0aW9uc0hhbmRsZSwgYWxsb2NzXSA9IHNldFNlc3Npb25PcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgaWYgKG9wdGlvbnM/LmV4dGVybmFsRGF0YSAmJiB3YXNtLm1vdW50RXh0ZXJuYWxEYXRhKSB7XG4gICAgICBjb25zdCBsb2FkaW5nUHJvbWlzZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBvcHRpb25zLmV4dGVybmFsRGF0YSkge1xuICAgICAgICBjb25zdCBwYXRoID0gdHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnID8gZmlsZSA6IGZpbGUucGF0aDtcbiAgICAgICAgbG9hZGluZ1Byb21pc2VzLnB1c2gobG9hZEZpbGUodHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnID8gZmlsZSA6IGZpbGUuZGF0YSkudGhlbihkYXRhID0+IHtcbiAgICAgICAgICB3YXNtLm1vdW50RXh0ZXJuYWxEYXRhIShwYXRoLCBkYXRhKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICAvLyB3YWl0IGZvciBhbGwgZXh0ZXJuYWwgZGF0YSBmaWxlcyB0byBiZSBsb2FkZWRcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGxvYWRpbmdQcm9taXNlcyk7XG4gICAgfVxuXG4gICAgc2Vzc2lvbkhhbmRsZSA9IGF3YWl0IHdhc20uX09ydENyZWF0ZVNlc3Npb24obW9kZWxEYXRhT2Zmc2V0LCBtb2RlbERhdGFMZW5ndGgsIHNlc3Npb25PcHRpb25zSGFuZGxlKTtcbiAgICBpZiAoc2Vzc2lvbkhhbmRsZSA9PT0gMCkge1xuICAgICAgY2hlY2tMYXN0RXJyb3IoJ0NhblxcJ3QgY3JlYXRlIGEgc2Vzc2lvbi4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBbaW5wdXRDb3VudCwgb3V0cHV0Q291bnRdID0gZ2V0U2Vzc2lvbklucHV0T3V0cHV0Q291bnQoc2Vzc2lvbkhhbmRsZSk7XG5cbiAgICBjb25zdCBlbmFibGVHcmFwaENhcHR1cmUgPSAhIW9wdGlvbnM/LmVuYWJsZUdyYXBoQ2FwdHVyZTtcblxuICAgIGNvbnN0IGlucHV0TmFtZXMgPSBbXTtcbiAgICBjb25zdCBvdXRwdXROYW1lcyA9IFtdO1xuICAgIGNvbnN0IG91dHB1dFByZWZlcnJlZExvY2F0aW9uczogU3VwcG9ydGVkVGVuc29yRGF0YUxvY2F0aW9uRm9ySW5wdXRPdXRwdXRbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBuYW1lID0gd2FzbS5fT3J0R2V0SW5wdXROYW1lKHNlc3Npb25IYW5kbGUsIGkpO1xuICAgICAgaWYgKG5hbWUgPT09IDApIHtcbiAgICAgICAgY2hlY2tMYXN0RXJyb3IoJ0NhblxcJ3QgZ2V0IGFuIGlucHV0IG5hbWUuJyk7XG4gICAgICB9XG4gICAgICBpbnB1dE5hbWVzVVRGOEVuY29kZWQucHVzaChuYW1lKTtcbiAgICAgIGlucHV0TmFtZXMucHVzaCh3YXNtLlVURjhUb1N0cmluZyhuYW1lKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Q291bnQ7IGkrKykge1xuICAgICAgY29uc3QgbmFtZSA9IHdhc20uX09ydEdldE91dHB1dE5hbWUoc2Vzc2lvbkhhbmRsZSwgaSk7XG4gICAgICBpZiAobmFtZSA9PT0gMCkge1xuICAgICAgICBjaGVja0xhc3RFcnJvcignQ2FuXFwndCBnZXQgYW4gb3V0cHV0IG5hbWUuJyk7XG4gICAgICB9XG4gICAgICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLnB1c2gobmFtZSk7XG4gICAgICBjb25zdCBuYW1lU3RyaW5nID0gd2FzbS5VVEY4VG9TdHJpbmcobmFtZSk7XG4gICAgICBvdXRwdXROYW1lcy5wdXNoKG5hbWVTdHJpbmcpO1xuXG4gICAgICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQKSB7XG4gICAgICAgIGlmIChlbmFibGVHcmFwaENhcHR1cmUgJiYgb3B0aW9ucz8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG91dHB1dFByZWZlcnJlZExvY2F0aW9ucy5wdXNoKCdncHUtYnVmZmVyJyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0eXBlb2Ygb3B0aW9ucz8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb24gPT09ICdzdHJpbmcnID9cbiAgICAgICAgICAgIG9wdGlvbnMucHJlZmVycmVkT3V0cHV0TG9jYXRpb24gOlxuICAgICAgICAgICAgb3B0aW9ucz8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb24/LltuYW1lU3RyaW5nXSA/PyAnY3B1JztcbiAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAnY3B1JyAmJiBsb2NhdGlvbiAhPT0gJ2NwdS1waW5uZWQnICYmIGxvY2F0aW9uICE9PSAnZ3B1LWJ1ZmZlcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgcHJlZmVycmVkIG91dHB1dCBsb2NhdGlvbjogJHtsb2NhdGlvbn0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuYWJsZUdyYXBoQ2FwdHVyZSAmJiBsb2NhdGlvbiAhPT0gJ2dwdS1idWZmZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3Qgc3VwcG9ydGVkIHByZWZlcnJlZCBvdXRwdXQgbG9jYXRpb246ICR7XG4gICAgICAgICAgICAgIGxvY2F0aW9ufS4gT25seSAnZ3B1LWJ1ZmZlcicgbG9jYXRpb24gaXMgc3VwcG9ydGVkIHdoZW4gZW5hYmxlR3JhcGhDYXB0dXJlIGlzIHRydWUuYCk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zLnB1c2gobG9jYXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHVzZSBJTyBiaW5kaW5nIG9ubHkgd2hlbiBhdCBsZWFzdCBvbmUgb3V0cHV0IGlzIHByZWZmZXJlZCB0byBiZSBvbiBHUFUuXG4gICAgbGV0IGJpbmRpbmdTdGF0ZTogSU9CaW5kaW5nU3RhdGV8bnVsbCA9IG51bGw7XG4gICAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCAmJiBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMuc29tZShsID0+IGwgPT09ICdncHUtYnVmZmVyJykpIHtcbiAgICAgIGlvQmluZGluZ0hhbmRsZSA9IHdhc20uX09ydENyZWF0ZUJpbmRpbmcoc2Vzc2lvbkhhbmRsZSk7XG4gICAgICBpZiAoaW9CaW5kaW5nSGFuZGxlID09PSAwKSB7XG4gICAgICAgIGNoZWNrTGFzdEVycm9yKCdDYW5cXCd0IGNyZWF0ZSBJTyBiaW5kaW5nLicpO1xuICAgICAgfVxuXG4gICAgICBiaW5kaW5nU3RhdGUgPSB7XG4gICAgICAgIGhhbmRsZTogaW9CaW5kaW5nSGFuZGxlLFxuICAgICAgICBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMsXG4gICAgICAgIG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6IG91dHB1dFByZWZlcnJlZExvY2F0aW9ucy5tYXAobCA9PiBkYXRhTG9jYXRpb25TdHJpbmdUb0VudW0obCkpLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBhY3RpdmVTZXNzaW9ucy5zZXQoXG4gICAgICAgIHNlc3Npb25IYW5kbGUsXG4gICAgICAgIFtzZXNzaW9uSGFuZGxlLCBpbnB1dE5hbWVzVVRGOEVuY29kZWQsIG91dHB1dE5hbWVzVVRGOEVuY29kZWQsIGJpbmRpbmdTdGF0ZSwgZW5hYmxlR3JhcGhDYXB0dXJlLCBmYWxzZV0pO1xuICAgIHJldHVybiBbc2Vzc2lvbkhhbmRsZSwgaW5wdXROYW1lcywgb3V0cHV0TmFtZXNdO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2goYnVmID0+IHdhc20uX09ydEZyZWUoYnVmKSk7XG4gICAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZC5mb3JFYWNoKGJ1ZiA9PiB3YXNtLl9PcnRGcmVlKGJ1ZikpO1xuXG4gICAgaWYgKGlvQmluZGluZ0hhbmRsZSAhPT0gMCkge1xuICAgICAgd2FzbS5fT3J0UmVsZWFzZUJpbmRpbmcoaW9CaW5kaW5nSGFuZGxlKTtcbiAgICB9XG5cbiAgICBpZiAoc2Vzc2lvbkhhbmRsZSAhPT0gMCkge1xuICAgICAgd2FzbS5fT3J0UmVsZWFzZVNlc3Npb24oc2Vzc2lvbkhhbmRsZSk7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH0gZmluYWxseSB7XG4gICAgd2FzbS5fZnJlZShtb2RlbERhdGFPZmZzZXQpO1xuICAgIGlmIChzZXNzaW9uT3B0aW9uc0hhbmRsZSAhPT0gMCkge1xuICAgICAgd2FzbS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKHNlc3Npb25PcHRpb25zSGFuZGxlKTtcbiAgICB9XG4gICAgYWxsb2NzLmZvckVhY2goYWxsb2MgPT4gd2FzbS5fZnJlZShhbGxvYykpO1xuXG4gICAgLy8gdW5tb3VudCBleHRlcm5hbCBkYXRhIGlmIG5lY2Vzc2FyeVxuICAgIHdhc20udW5tb3VudEV4dGVybmFsRGF0YT8uKCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWxlYXNlU2Vzc2lvbiA9IChzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQgPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcbiAgY29uc3Qgc2Vzc2lvbiA9IGFjdGl2ZVNlc3Npb25zLmdldChzZXNzaW9uSWQpO1xuICBpZiAoIXNlc3Npb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWxlYXNlIHNlc3Npb24uIGludmFsaWQgc2Vzc2lvbiBpZDogJHtzZXNzaW9uSWR9YCk7XG4gIH1cbiAgY29uc3QgW3Nlc3Npb25IYW5kbGUsIGlucHV0TmFtZXNVVEY4RW5jb2RlZCwgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCwgaW9CaW5kaW5nU3RhdGUsIGVuYWJsZUdyYXBoQ2FwdHVyZV0gPSBzZXNzaW9uO1xuXG4gIGlmIChpb0JpbmRpbmdTdGF0ZSkge1xuICAgIGlmIChlbmFibGVHcmFwaENhcHR1cmUpIHtcbiAgICAgIHdhc20uX09ydENsZWFyQm91bmRPdXRwdXRzKGlvQmluZGluZ1N0YXRlLmhhbmRsZSk7XG4gICAgfVxuICAgIHdhc20uX09ydFJlbGVhc2VCaW5kaW5nKGlvQmluZGluZ1N0YXRlLmhhbmRsZSk7XG4gIH1cblxuICB3YXNtLmpzZXBPblJlbGVhc2VTZXNzaW9uPy4oc2Vzc2lvbklkKTtcblxuICBpbnB1dE5hbWVzVVRGOEVuY29kZWQuZm9yRWFjaChidWYgPT4gd2FzbS5fT3J0RnJlZShidWYpKTtcbiAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZC5mb3JFYWNoKGJ1ZiA9PiB3YXNtLl9PcnRGcmVlKGJ1ZikpO1xuICB3YXNtLl9PcnRSZWxlYXNlU2Vzc2lvbihzZXNzaW9uSGFuZGxlKTtcbiAgYWN0aXZlU2Vzc2lvbnMuZGVsZXRlKHNlc3Npb25JZCk7XG59O1xuXG5leHBvcnQgY29uc3QgcHJlcGFyZUlucHV0T3V0cHV0VGVuc29yID1cbiAgICAodGVuc29yOiBUZW5zb3JNZXRhZGF0YXxudWxsLCB0ZW5zb3JIYW5kbGVzOiBudW1iZXJbXSwgYWxsb2NzOiBudW1iZXJbXSwgc2Vzc2lvbklkOiBudW1iZXIsIGluZGV4OiBudW1iZXIsXG4gICAgIGVuYWJsZUdyYXBoQ2FwdHVyZSA9IGZhbHNlKTogdm9pZCA9PiB7XG4gICAgICBpZiAoIXRlbnNvcikge1xuICAgICAgICB0ZW5zb3JIYW5kbGVzLnB1c2goMCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG5cbiAgICAgIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yWzBdO1xuICAgICAgY29uc3QgZGltcyA9IHRlbnNvclsxXTtcbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGVuc29yWzNdO1xuXG4gICAgICBsZXQgcmF3RGF0YTogbnVtYmVyO1xuICAgICAgbGV0IGRhdGFCeXRlTGVuZ3RoOiBudW1iZXI7XG5cbiAgICAgIGlmIChkYXRhVHlwZSA9PT0gJ3N0cmluZycgJiYgbG9jYXRpb24gPT09ICdncHUtYnVmZmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCBvbiBHUFUuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmFibGVHcmFwaENhcHR1cmUgJiYgbG9jYXRpb24gIT09ICdncHUtYnVmZmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgRXh0ZXJuYWwgYnVmZmVyIG11c3QgYmUgcHJvdmlkZWQgZm9yIGlucHV0L291dHB1dCBpbmRleCAke2luZGV4fSB3aGVuIGVuYWJsZUdyYXBoQ2FwdHVyZSBpcyB0cnVlLmApO1xuICAgICAgfVxuXG4gICAgICBpZiAobG9jYXRpb24gPT09ICdncHUtYnVmZmVyJykge1xuICAgICAgICBjb25zdCBncHVCdWZmZXIgPSB0ZW5zb3JbMl0uZ3B1QnVmZmVyIGFzIEdQVUJ1ZmZlcjtcbiAgICAgICAgY29uc3QgZWxlbWVudFNpemVJbkJ5dGVzID0gZ2V0VGVuc29yRWxlbWVudFNpemUodGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0oZGF0YVR5cGUpKSE7XG4gICAgICAgIGRhdGFCeXRlTGVuZ3RoID0gZGltcy5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiLCAxKSAqIGVsZW1lbnRTaXplSW5CeXRlcztcblxuICAgICAgICBjb25zdCByZWdpc3RlckJ1ZmZlciA9IHdhc20uanNlcFJlZ2lzdGVyQnVmZmVyO1xuICAgICAgICBpZiAoIXJlZ2lzdGVyQnVmZmVyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgbG9jYXRpb24gXCJncHUtYnVmZmVyXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYkdQVS4nKTtcbiAgICAgICAgfVxuICAgICAgICByYXdEYXRhID0gcmVnaXN0ZXJCdWZmZXIoc2Vzc2lvbklkLCBpbmRleCwgZ3B1QnVmZmVyLCBkYXRhQnl0ZUxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBkYXRhID0gdGVuc29yWzJdO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgLy8gc3RyaW5nIHRlbnNvclxuICAgICAgICAgIGRhdGFCeXRlTGVuZ3RoID0gNCAqIGRhdGEubGVuZ3RoO1xuICAgICAgICAgIHJhd0RhdGEgPSB3YXNtLl9tYWxsb2MoZGF0YUJ5dGVMZW5ndGgpO1xuICAgICAgICAgIGFsbG9jcy5wdXNoKHJhd0RhdGEpO1xuICAgICAgICAgIGxldCBkYXRhSW5kZXggPSByYXdEYXRhIC8gNDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdGVuc29yIGRhdGEgYXQgaW5kZXggJHtpfSBpcyBub3QgYSBzdHJpbmdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdhc20uSEVBUFUzMltkYXRhSW5kZXgrK10gPSBhbGxvY1dhc21TdHJpbmcoZGF0YVtpXSwgYWxsb2NzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YUJ5dGVMZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgcmF3RGF0YSA9IHdhc20uX21hbGxvYyhkYXRhQnl0ZUxlbmd0aCk7XG4gICAgICAgICAgYWxsb2NzLnB1c2gocmF3RGF0YSk7XG4gICAgICAgICAgd2FzbS5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGFCeXRlTGVuZ3RoKSwgcmF3RGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RhY2sgPSB3YXNtLnN0YWNrU2F2ZSgpO1xuICAgICAgY29uc3QgZGltc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYyg0ICogZGltcy5sZW5ndGgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGRpbUluZGV4ID0gZGltc09mZnNldCAvIDQ7XG4gICAgICAgIGRpbXMuZm9yRWFjaChkID0+IHdhc20uSEVBUDMyW2RpbUluZGV4KytdID0gZCk7XG4gICAgICAgIGNvbnN0IHRlbnNvciA9IHdhc20uX09ydENyZWF0ZVRlbnNvcihcbiAgICAgICAgICAgIHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtKGRhdGFUeXBlKSwgcmF3RGF0YSwgZGF0YUJ5dGVMZW5ndGgsIGRpbXNPZmZzZXQsIGRpbXMubGVuZ3RoLFxuICAgICAgICAgICAgZGF0YUxvY2F0aW9uU3RyaW5nVG9FbnVtKGxvY2F0aW9uKSk7XG4gICAgICAgIGlmICh0ZW5zb3IgPT09IDApIHtcbiAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3QgY3JlYXRlIHRlbnNvciBmb3IgaW5wdXQvb3V0cHV0LiBzZXNzaW9uPSR7c2Vzc2lvbklkfSwgaW5kZXg9JHtpbmRleH0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGVuc29ySGFuZGxlcy5wdXNoKHRlbnNvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLnN0YWNrUmVzdG9yZShzdGFjayk7XG4gICAgICB9XG4gICAgfTtcblxuLyoqXG4gKiBwZXJmb3JtIGluZmVyZW5jZSBydW5cbiAqL1xuZXhwb3J0IGNvbnN0IHJ1biA9IGFzeW5jKFxuICAgIHNlc3Npb25JZDogbnVtYmVyLCBpbnB1dEluZGljZXM6IG51bWJlcltdLCBpbnB1dFRlbnNvcnM6IFRlbnNvck1ldGFkYXRhW10sIG91dHB1dEluZGljZXM6IG51bWJlcltdLFxuICAgIG91dHB1dFRlbnNvcnM6IEFycmF5PFRlbnNvck1ldGFkYXRhfG51bGw+LCBvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPFRlbnNvck1ldGFkYXRhW10+ID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGNvbnN0IHNlc3Npb24gPSBhY3RpdmVTZXNzaW9ucy5nZXQoc2Vzc2lvbklkKTtcbiAgaWYgKCFzZXNzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcnVuIGluZmVyZW5jZS4gaW52YWxpZCBzZXNzaW9uIGlkOiAke3Nlc3Npb25JZH1gKTtcbiAgfVxuICBjb25zdCBzZXNzaW9uSGFuZGxlID0gc2Vzc2lvblswXTtcbiAgY29uc3QgaW5wdXROYW1lc1VURjhFbmNvZGVkID0gc2Vzc2lvblsxXTtcbiAgY29uc3Qgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCA9IHNlc3Npb25bMl07XG4gIGNvbnN0IGlvQmluZGluZ1N0YXRlID0gc2Vzc2lvblszXTtcbiAgY29uc3QgZW5hYmxlR3JhcGhDYXB0dXJlID0gc2Vzc2lvbls0XTtcbiAgY29uc3QgaW5wdXRPdXRwdXRCb3VuZCA9IHNlc3Npb25bNV07XG5cbiAgY29uc3QgaW5wdXRDb3VudCA9IGlucHV0SW5kaWNlcy5sZW5ndGg7XG4gIGNvbnN0IG91dHB1dENvdW50ID0gb3V0cHV0SW5kaWNlcy5sZW5ndGg7XG5cbiAgbGV0IHJ1bk9wdGlvbnNIYW5kbGUgPSAwO1xuICBsZXQgcnVuT3B0aW9uc0FsbG9jczogbnVtYmVyW10gPSBbXTtcblxuICBjb25zdCBpbnB1dFRlbnNvckhhbmRsZXM6IG51bWJlcltdID0gW107XG4gIGNvbnN0IG91dHB1dFRlbnNvckhhbmRsZXM6IG51bWJlcltdID0gW107XG4gIGNvbnN0IGlucHV0T3V0cHV0QWxsb2NzOiBudW1iZXJbXSA9IFtdO1xuXG4gIGNvbnN0IGJlZm9yZVJ1blN0YWNrID0gd2FzbS5zdGFja1NhdmUoKTtcbiAgY29uc3QgaW5wdXRWYWx1ZXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoaW5wdXRDb3VudCAqIDQpO1xuICBjb25zdCBpbnB1dE5hbWVzT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKGlucHV0Q291bnQgKiA0KTtcbiAgY29uc3Qgb3V0cHV0VmFsdWVzT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKG91dHB1dENvdW50ICogNCk7XG4gIGNvbnN0IG91dHB1dE5hbWVzT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKG91dHB1dENvdW50ICogNCk7XG5cbiAgdHJ5IHtcbiAgICBbcnVuT3B0aW9uc0hhbmRsZSwgcnVuT3B0aW9uc0FsbG9jc10gPSBzZXRSdW5PcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgLy8gY3JlYXRlIGlucHV0IHRlbnNvcnNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xuICAgICAgcHJlcGFyZUlucHV0T3V0cHV0VGVuc29yKFxuICAgICAgICAgIGlucHV0VGVuc29yc1tpXSwgaW5wdXRUZW5zb3JIYW5kbGVzLCBpbnB1dE91dHB1dEFsbG9jcywgc2Vzc2lvbklkLCBpbnB1dEluZGljZXNbaV0sIGVuYWJsZUdyYXBoQ2FwdHVyZSk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIG91dHB1dCB0ZW5zb3JzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRDb3VudDsgaSsrKSB7XG4gICAgICBwcmVwYXJlSW5wdXRPdXRwdXRUZW5zb3IoXG4gICAgICAgICAgb3V0cHV0VGVuc29yc1tpXSwgb3V0cHV0VGVuc29ySGFuZGxlcywgaW5wdXRPdXRwdXRBbGxvY3MsIHNlc3Npb25JZCwgaW5wdXRDb3VudCArIG91dHB1dEluZGljZXNbaV0sXG4gICAgICAgICAgZW5hYmxlR3JhcGhDYXB0dXJlKTtcbiAgICB9XG5cbiAgICBsZXQgaW5wdXRWYWx1ZXNJbmRleCA9IGlucHV0VmFsdWVzT2Zmc2V0IC8gNDtcbiAgICBsZXQgaW5wdXROYW1lc0luZGV4ID0gaW5wdXROYW1lc09mZnNldCAvIDQ7XG4gICAgbGV0IG91dHB1dFZhbHVlc0luZGV4ID0gb3V0cHV0VmFsdWVzT2Zmc2V0IC8gNDtcbiAgICBsZXQgb3V0cHV0TmFtZXNJbmRleCA9IG91dHB1dE5hbWVzT2Zmc2V0IC8gNDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xuICAgICAgd2FzbS5IRUFQVTMyW2lucHV0VmFsdWVzSW5kZXgrK10gPSBpbnB1dFRlbnNvckhhbmRsZXNbaV07XG4gICAgICB3YXNtLkhFQVBVMzJbaW5wdXROYW1lc0luZGV4KytdID0gaW5wdXROYW1lc1VURjhFbmNvZGVkW2lucHV0SW5kaWNlc1tpXV07XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Q291bnQ7IGkrKykge1xuICAgICAgd2FzbS5IRUFQVTMyW291dHB1dFZhbHVlc0luZGV4KytdID0gb3V0cHV0VGVuc29ySGFuZGxlc1tpXTtcbiAgICAgIHdhc20uSEVBUFUzMltvdXRwdXROYW1lc0luZGV4KytdID0gb3V0cHV0TmFtZXNVVEY4RW5jb2RlZFtvdXRwdXRJbmRpY2VzW2ldXTtcbiAgICB9XG5cbiAgICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQICYmIGlvQmluZGluZ1N0YXRlICYmICFpbnB1dE91dHB1dEJvdW5kKSB7XG4gICAgICBjb25zdCB7aGFuZGxlLCBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMsIG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWR9ID0gaW9CaW5kaW5nU3RhdGU7XG5cbiAgICAgIGlmIChpbnB1dE5hbWVzVVRGOEVuY29kZWQubGVuZ3RoICE9PSBpbnB1dENvdW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5wdXQgY291bnQgZnJvbSBmZWVkcyAoJHtcbiAgICAgICAgICAgIGlucHV0Q291bnR9KSBpcyBleHBlY3RlZCB0byBiZSBhbHdheXMgZXF1YWwgdG8gbW9kZWwncyBpbnB1dCBjb3VudCAoJHtpbnB1dE5hbWVzVVRGOEVuY29kZWQubGVuZ3RofSkuYCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHByb2Nlc3MgaW5wdXRzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBpbmRleCA9IGlucHV0SW5kaWNlc1tpXTtcbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gYXdhaXQgd2FzbS5fT3J0QmluZElucHV0KGhhbmRsZSwgaW5wdXROYW1lc1VURjhFbmNvZGVkW2luZGV4XSwgaW5wdXRUZW5zb3JIYW5kbGVzW2ldKTtcbiAgICAgICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBiaW5kIGlucHV0WyR7aX1dIGZvciBzZXNzaW9uPSR7c2Vzc2lvbklkfS5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBwcm9jZXNzIHByZS1hbGxvY2F0ZWQgb3V0cHV0c1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gb3V0cHV0SW5kaWNlc1tpXTtcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBvdXRwdXRUZW5zb3JzW2ldPy5bM107ICAvLyB1bmRlZmluZWQgbWVhbnMgb3V0cHV0IGlzIG5vdCBwcmUtYWxsb2NhdGVkLlxuXG4gICAgICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgICAgIC8vIG91dHB1dCBpcyBwcmUtYWxsb2NhdGVkLiBiaW5kIHRoZSB0ZW5zb3IuXG4gICAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gd2FzbS5fT3J0QmluZE91dHB1dChoYW5kbGUsIG91dHB1dE5hbWVzVVRGOEVuY29kZWRbaW5kZXhdLCBvdXRwdXRUZW5zb3JIYW5kbGVzW2ldLCAwKTtcbiAgICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XG4gICAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3QgYmluZCBwcmUtYWxsb2NhdGVkIG91dHB1dFske2l9XSBmb3Igc2Vzc2lvbj0ke3Nlc3Npb25JZH0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG91dHB1dCBpcyBub3QgcHJlLWFsbG9jYXRlZC4gcmVzZXQgcHJlZmVycmVkIGxvY2F0aW9uLlxuICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9XG4gICAgICAgICAgICAgIHdhc20uX09ydEJpbmRPdXRwdXQoaGFuZGxlLCBvdXRwdXROYW1lc1VURjhFbmNvZGVkW2luZGV4XSwgMCwgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zRW5jb2RlZFtpbmRleF0pO1xuICAgICAgICAgIGlmIChlcnJvckNvZGUgIT09IDApIHtcbiAgICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBiaW5kIG91dHB1dFske2l9XSB0byAke291dHB1dFByZWZlcnJlZExvY2F0aW9uc1tpXX0gZm9yIHNlc3Npb249JHtzZXNzaW9uSWR9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWN0aXZlU2Vzc2lvbnMuc2V0KFxuICAgICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgICBbc2Vzc2lvbkhhbmRsZSwgaW5wdXROYW1lc1VURjhFbmNvZGVkLCBvdXRwdXROYW1lc1VURjhFbmNvZGVkLCBpb0JpbmRpbmdTdGF0ZSwgZW5hYmxlR3JhcGhDYXB0dXJlLCB0cnVlXSk7XG4gICAgfVxuXG4gICAgd2FzbS5qc2VwT25SdW5TdGFydD8uKHNlc3Npb25IYW5kbGUpO1xuICAgIGxldCBlcnJvckNvZGU6IG51bWJlcjtcbiAgICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQICYmIGlvQmluZGluZ1N0YXRlKSB7XG4gICAgICBlcnJvckNvZGUgPSBhd2FpdCB3YXNtLl9PcnRSdW5XaXRoQmluZGluZyhcbiAgICAgICAgICBzZXNzaW9uSGFuZGxlLCBpb0JpbmRpbmdTdGF0ZS5oYW5kbGUsIG91dHB1dENvdW50LCBvdXRwdXRWYWx1ZXNPZmZzZXQsIHJ1bk9wdGlvbnNIYW5kbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvckNvZGUgPSBhd2FpdCB3YXNtLl9PcnRSdW4oXG4gICAgICAgICAgc2Vzc2lvbkhhbmRsZSwgaW5wdXROYW1lc09mZnNldCwgaW5wdXRWYWx1ZXNPZmZzZXQsIGlucHV0Q291bnQsIG91dHB1dE5hbWVzT2Zmc2V0LCBvdXRwdXRDb3VudCxcbiAgICAgICAgICBvdXRwdXRWYWx1ZXNPZmZzZXQsIHJ1bk9wdGlvbnNIYW5kbGUpO1xuICAgIH1cblxuICAgIGlmIChlcnJvckNvZGUgIT09IDApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKCdmYWlsZWQgdG8gY2FsbCBPcnRSdW4oKS4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBvdXRwdXQ6IFRlbnNvck1ldGFkYXRhW10gPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Q291bnQ7IGkrKykge1xuICAgICAgY29uc3QgdGVuc29yID0gd2FzbS5IRUFQVTMyW291dHB1dFZhbHVlc09mZnNldCAvIDQgKyBpXTtcbiAgICAgIGlmICh0ZW5zb3IgPT09IG91dHB1dFRlbnNvckhhbmRsZXNbaV0pIHtcbiAgICAgICAgLy8gb3V0cHV0IHRlbnNvciBpcyBwcmUtYWxsb2NhdGVkLiBubyBuZWVkIHRvIGNvcHkgZGF0YS5cbiAgICAgICAgb3V0cHV0LnB1c2gob3V0cHV0VGVuc29yc1tpXSEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYmVmb3JlR2V0VGVuc29yRGF0YVN0YWNrID0gd2FzbS5zdGFja1NhdmUoKTtcbiAgICAgIC8vIHN0YWNrIGFsbG9jYXRlIDQgcG9pbnRlciB2YWx1ZVxuICAgICAgY29uc3QgdGVuc29yRGF0YU9mZnNldCA9IHdhc20uc3RhY2tBbGxvYyg0ICogNCk7XG5cbiAgICAgIGxldCBrZWVwT3V0cHV0VGVuc29yID0gZmFsc2U7XG4gICAgICBsZXQgdHlwZTogVGVuc29yLlR5cGV8dW5kZWZpbmVkLCBkYXRhT2Zmc2V0ID0gMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHdhc20uX09ydEdldFRlbnNvckRhdGEoXG4gICAgICAgICAgICB0ZW5zb3IsIHRlbnNvckRhdGFPZmZzZXQsIHRlbnNvckRhdGFPZmZzZXQgKyA0LCB0ZW5zb3JEYXRhT2Zmc2V0ICsgOCwgdGVuc29yRGF0YU9mZnNldCArIDEyKTtcbiAgICAgICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBhY2Nlc3Mgb3V0cHV0IHRlbnNvciBkYXRhIG9uIGluZGV4ICR7aX0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRlbnNvckRhdGFJbmRleCA9IHRlbnNvckRhdGFPZmZzZXQgLyA0O1xuICAgICAgICBjb25zdCBkYXRhVHlwZSA9IHdhc20uSEVBUFUzMlt0ZW5zb3JEYXRhSW5kZXgrK107XG4gICAgICAgIGRhdGFPZmZzZXQgPSB3YXNtLkhFQVBVMzJbdGVuc29yRGF0YUluZGV4KytdO1xuICAgICAgICBjb25zdCBkaW1zT2Zmc2V0ID0gd2FzbS5IRUFQVTMyW3RlbnNvckRhdGFJbmRleCsrXTtcbiAgICAgICAgY29uc3QgZGltc0xlbmd0aCA9IHdhc20uSEVBUFUzMlt0ZW5zb3JEYXRhSW5kZXgrK107XG4gICAgICAgIGNvbnN0IGRpbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1zTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBkaW1zLnB1c2god2FzbS5IRUFQVTMyW2RpbXNPZmZzZXQgLyA0ICsgaV0pO1xuICAgICAgICB9XG4gICAgICAgIHdhc20uX09ydEZyZWUoZGltc09mZnNldCk7XG5cbiAgICAgICAgY29uc3Qgc2l6ZSA9IGRpbXMucmVkdWNlKChhLCBiKSA9PiBhICogYiwgMSk7XG4gICAgICAgIHR5cGUgPSB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyhkYXRhVHlwZSk7XG5cbiAgICAgICAgY29uc3QgcHJlZmVycmVkTG9jYXRpb24gPSBpb0JpbmRpbmdTdGF0ZT8ub3V0cHV0UHJlZmVycmVkTG9jYXRpb25zW291dHB1dEluZGljZXNbaV1dO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChwcmVmZXJyZWRMb2NhdGlvbiA9PT0gJ2dwdS1idWZmZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCBvbiBHUFUuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHN0cmluZ0RhdGE6IHN0cmluZ1tdID0gW107XG4gICAgICAgICAgbGV0IGRhdGFJbmRleCA9IGRhdGFPZmZzZXQgLyA0O1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3YXNtLkhFQVBVMzJbZGF0YUluZGV4KytdO1xuICAgICAgICAgICAgY29uc3QgbWF4Qnl0ZXNUb1JlYWQgPSBpID09PSBzaXplIC0gMSA/IHVuZGVmaW5lZCA6IHdhc20uSEVBUFUzMltkYXRhSW5kZXhdIC0gb2Zmc2V0O1xuICAgICAgICAgICAgc3RyaW5nRGF0YS5wdXNoKHdhc20uVVRGOFRvU3RyaW5nKG9mZnNldCwgbWF4Qnl0ZXNUb1JlYWQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0cHV0LnB1c2goW3R5cGUsIGRpbXMsIHN0cmluZ0RhdGEsICdjcHUnXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgYSBjZXJ0YWluIG91dHB1dCdzIHByZWZlcnJlZCBsb2NhdGlvbiBpcyBHUFUgYnV0IHRoZSB0ZW5zb3IgaXMgZW1wdHksIHdlIHN0aWxsIG5lZWQgdG8gY3JlYXRlIGEgQ1BVXG4gICAgICAgICAgLy8gdGVuc29yIGZvciBpdC4gVGhlcmUgaXMgbm8gbWFwcGluZyBHUFUgYnVmZmVyIGZvciBhbiBlbXB0eSB0ZW5zb3IuXG4gICAgICAgICAgaWYgKHByZWZlcnJlZExvY2F0aW9uID09PSAnZ3B1LWJ1ZmZlcicgJiYgc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGdldEJ1ZmZlciA9IHdhc20uanNlcEdldEJ1ZmZlcjtcbiAgICAgICAgICAgIGlmICghZ2V0QnVmZmVyKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJlZmVycmVkTG9jYXRpb24gXCJncHUtYnVmZmVyXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYkdQVS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGdwdUJ1ZmZlciA9IGdldEJ1ZmZlcihkYXRhT2Zmc2V0KTtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRTaXplID0gZ2V0VGVuc29yRWxlbWVudFNpemUoZGF0YVR5cGUpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRTaXplID09PSB1bmRlZmluZWQgfHwgIWlzR3B1QnVmZmVyU3VwcG9ydGVkVHlwZSh0eXBlKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0eXBlfWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkbyBub3QgcmVsZWFzZSB0aGUgdGVuc29yIHJpZ2h0IG5vdy4gaXQgd2lsbCBiZSByZWxlYXNlZCB3aGVuIHVzZXIgY2FsbHMgdGVuc29yLmRpc3Bvc2UoKS5cbiAgICAgICAgICAgIGtlZXBPdXRwdXRUZW5zb3IgPSB0cnVlO1xuXG4gICAgICAgICAgICBvdXRwdXQucHVzaChbXG4gICAgICAgICAgICAgIHR5cGUsIGRpbXMsIHtcbiAgICAgICAgICAgICAgICBncHVCdWZmZXIsXG4gICAgICAgICAgICAgICAgZG93bmxvYWQ6IHdhc20uanNlcENyZWF0ZURvd25sb2FkZXIhKGdwdUJ1ZmZlciwgc2l6ZSAqIGVsZW1lbnRTaXplLCB0eXBlKSxcbiAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICB3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHRlbnNvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAnZ3B1LWJ1ZmZlcidcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlZEFycmF5Q29uc3RydWN0b3IgPSB0ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3IodHlwZSk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gbmV3IHR5cGVkQXJyYXlDb25zdHJ1Y3RvcihzaXplKTtcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICAuc2V0KHdhc20uSEVBUFU4LnN1YmFycmF5KGRhdGFPZmZzZXQsIGRhdGFPZmZzZXQgKyBkYXRhLmJ5dGVMZW5ndGgpKTtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKFt0eXBlLCBkaW1zLCBkYXRhLCAnY3B1J10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5zdGFja1Jlc3RvcmUoYmVmb3JlR2V0VGVuc29yRGF0YVN0YWNrKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIGRhdGFPZmZzZXQpIHtcbiAgICAgICAgICB3YXNtLl9mcmVlKGRhdGFPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgha2VlcE91dHB1dFRlbnNvcikge1xuICAgICAgICAgIHdhc20uX09ydFJlbGVhc2VUZW5zb3IodGVuc29yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpb0JpbmRpbmdTdGF0ZSAmJiAhZW5hYmxlR3JhcGhDYXB0dXJlKSB7XG4gICAgICB3YXNtLl9PcnRDbGVhckJvdW5kT3V0cHV0cyhpb0JpbmRpbmdTdGF0ZS5oYW5kbGUpO1xuICAgICAgYWN0aXZlU2Vzc2lvbnMuc2V0KFxuICAgICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgICBbc2Vzc2lvbkhhbmRsZSwgaW5wdXROYW1lc1VURjhFbmNvZGVkLCBvdXRwdXROYW1lc1VURjhFbmNvZGVkLCBpb0JpbmRpbmdTdGF0ZSwgZW5hYmxlR3JhcGhDYXB0dXJlLCBmYWxzZV0pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9IGZpbmFsbHkge1xuICAgIHdhc20uc3RhY2tSZXN0b3JlKGJlZm9yZVJ1blN0YWNrKTtcblxuICAgIGlucHV0VGVuc29ySGFuZGxlcy5mb3JFYWNoKHYgPT4gd2FzbS5fT3J0UmVsZWFzZVRlbnNvcih2KSk7XG4gICAgb3V0cHV0VGVuc29ySGFuZGxlcy5mb3JFYWNoKHYgPT4gd2FzbS5fT3J0UmVsZWFzZVRlbnNvcih2KSk7XG4gICAgaW5wdXRPdXRwdXRBbGxvY3MuZm9yRWFjaChwID0+IHdhc20uX2ZyZWUocCkpO1xuXG4gICAgaWYgKHJ1bk9wdGlvbnNIYW5kbGUgIT09IDApIHtcbiAgICAgIHdhc20uX09ydFJlbGVhc2VSdW5PcHRpb25zKHJ1bk9wdGlvbnNIYW5kbGUpO1xuICAgIH1cbiAgICBydW5PcHRpb25zQWxsb2NzLmZvckVhY2gocCA9PiB3YXNtLl9mcmVlKHApKTtcbiAgfVxufTtcblxuLyoqXG4gKiBlbmQgcHJvZmlsaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBlbmRQcm9maWxpbmcgPSAoc2Vzc2lvbklkOiBudW1iZXIpOiB2b2lkID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGNvbnN0IHNlc3Npb24gPSBhY3RpdmVTZXNzaW9ucy5nZXQoc2Vzc2lvbklkKTtcbiAgaWYgKCFzZXNzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNlc3Npb24gaWQnKTtcbiAgfVxuICBjb25zdCBzZXNzaW9uSGFuZGxlID0gc2Vzc2lvblswXTtcblxuICAvLyBwcm9maWxlIGZpbGUgbmFtZSBpcyBub3QgdXNlZCB5ZXQsIGJ1dCBpdCBtdXN0IGJlIGZyZWVkLlxuICBjb25zdCBwcm9maWxlRmlsZU5hbWUgPSB3YXNtLl9PcnRFbmRQcm9maWxpbmcoc2Vzc2lvbkhhbmRsZSk7XG4gIGlmIChwcm9maWxlRmlsZU5hbWUgPT09IDApIHtcbiAgICBjaGVja0xhc3RFcnJvcignQ2FuXFwndCBnZXQgYW4gcHJvZmlsZSBmaWxlIG5hbWUuJyk7XG4gIH1cbiAgd2FzbS5fT3J0RnJlZShwcm9maWxlRmlsZU5hbWUpO1xufTtcblxuZXhwb3J0IGNvbnN0IGV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzID0gKHRlbnNvcnM6IHJlYWRvbmx5IFNlcmlhbGl6YWJsZVRlbnNvck1ldGFkYXRhW10pOiBBcnJheUJ1ZmZlckxpa2VbXSA9PiB7XG4gIGNvbnN0IGJ1ZmZlcnM6IEFycmF5QnVmZmVyTGlrZVtdID0gW107XG4gIGZvciAoY29uc3QgdGVuc29yIG9mIHRlbnNvcnMpIHtcbiAgICBjb25zdCBkYXRhID0gdGVuc29yWzJdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSAmJiAnYnVmZmVyJyBpbiBkYXRhKSB7XG4gICAgICBidWZmZXJzLnB1c2goZGF0YS5idWZmZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYnVmZmVycztcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7ZW52LCBJbmZlcmVuY2VTZXNzaW9ufSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQge09ydFdhc21NZXNzYWdlLCBTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlciwgU2VyaWFsaXphYmxlU2Vzc2lvbk1ldGFkYXRhLCBTZXJpYWxpemFibGVUZW5zb3JNZXRhZGF0YSwgVGVuc29yTWV0YWRhdGF9IGZyb20gJy4vcHJveHktbWVzc2FnZXMnO1xuaW1wb3J0ICogYXMgY29yZSBmcm9tICcuL3dhc20tY29yZS1pbXBsJztcbmltcG9ydCB7aW5pdGlhbGl6ZVdlYkFzc2VtYmx5fSBmcm9tICcuL3dhc20tZmFjdG9yeSc7XG5pbXBvcnQge2ltcG9ydFByb3h5V29ya2VyfSBmcm9tICcuL3dhc20tdXRpbHMtaW1wb3J0JztcblxuY29uc3QgaXNQcm94eSA9ICgpOiBib29sZWFuID0+ICEhZW52Lndhc20ucHJveHkgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbmxldCBwcm94eVdvcmtlcjogV29ya2VyfHVuZGVmaW5lZDtcbmxldCBpbml0aWFsaXppbmcgPSBmYWxzZTtcbmxldCBpbml0aWFsaXplZCA9IGZhbHNlO1xubGV0IGFib3J0ZWQgPSBmYWxzZTtcbmxldCB0ZW1wb3JhcnlPYmplY3RVcmw6IHN0cmluZ3x1bmRlZmluZWQ7XG5cbnR5cGUgUHJvbWlzZUNhbGxiYWNrczxUID0gdm9pZD4gPSBbcmVzb2x2ZTogKHJlc3VsdDogVCkgPT4gdm9pZCwgcmVqZWN0OiAocmVhc29uOiB1bmtub3duKSA9PiB2b2lkXTtcbmxldCBpbml0V2FzbUNhbGxiYWNrczogUHJvbWlzZUNhbGxiYWNrcztcbmNvbnN0IHF1ZXVlZENhbGxiYWNrczogTWFwPE9ydFdhc21NZXNzYWdlWyd0eXBlJ10sIEFycmF5PFByb21pc2VDYWxsYmFja3M8dW5rbm93bj4+PiA9IG5ldyBNYXAoKTtcblxuY29uc3QgZW5xdWV1ZUNhbGxiYWNrcyA9ICh0eXBlOiBPcnRXYXNtTWVzc2FnZVsndHlwZSddLCBjYWxsYmFja3M6IFByb21pc2VDYWxsYmFja3M8dW5rbm93bj4pOiB2b2lkID0+IHtcbiAgY29uc3QgcXVldWUgPSBxdWV1ZWRDYWxsYmFja3MuZ2V0KHR5cGUpO1xuICBpZiAocXVldWUpIHtcbiAgICBxdWV1ZS5wdXNoKGNhbGxiYWNrcyk7XG4gIH0gZWxzZSB7XG4gICAgcXVldWVkQ2FsbGJhY2tzLnNldCh0eXBlLCBbY2FsbGJhY2tzXSk7XG4gIH1cbn07XG5cbmNvbnN0IGVuc3VyZVdvcmtlciA9ICgpOiB2b2lkID0+IHtcbiAgaWYgKGluaXRpYWxpemluZyB8fCAhaW5pdGlhbGl6ZWQgfHwgYWJvcnRlZCB8fCAhcHJveHlXb3JrZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3dvcmtlciBub3QgcmVhZHknKTtcbiAgfVxufTtcblxuY29uc3Qgb25Qcm94eVdvcmtlck1lc3NhZ2UgPSAoZXY6IE1lc3NhZ2VFdmVudDxPcnRXYXNtTWVzc2FnZT4pOiB2b2lkID0+IHtcbiAgc3dpdGNoIChldi5kYXRhLnR5cGUpIHtcbiAgICBjYXNlICdpbml0LXdhc20nOlxuICAgICAgaW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgICBpZiAoZXYuZGF0YS5lcnIpIHtcbiAgICAgICAgYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIGluaXRXYXNtQ2FsbGJhY2tzWzFdKGV2LmRhdGEuZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgaW5pdFdhc21DYWxsYmFja3NbMF0oKTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZW1wb3JhcnlPYmplY3RVcmwpIHtcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh0ZW1wb3JhcnlPYmplY3RVcmwpO1xuICAgICAgICB0ZW1wb3JhcnlPYmplY3RVcmwgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbml0LWVwJzpcbiAgICBjYXNlICdjb3B5LWZyb20nOlxuICAgIGNhc2UgJ2NyZWF0ZSc6XG4gICAgY2FzZSAncmVsZWFzZSc6XG4gICAgY2FzZSAncnVuJzpcbiAgICBjYXNlICdlbmQtcHJvZmlsaW5nJzoge1xuICAgICAgY29uc3QgY2FsbGJhY2tzID0gcXVldWVkQ2FsbGJhY2tzLmdldChldi5kYXRhLnR5cGUpITtcbiAgICAgIGlmIChldi5kYXRhLmVycikge1xuICAgICAgICBjYWxsYmFja3Muc2hpZnQoKSFbMV0oZXYuZGF0YS5lcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2tzLnNoaWZ0KCkhWzBdKGV2LmRhdGEub3V0ISk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgfVxufTtcblxuXG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5QW5kT3J0UnVudGltZSA9IGFzeW5jKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoaW5pdGlhbGl6ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGluaXRpYWxpemluZykge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVsdGlwbGUgY2FsbHMgdG8gXFwnaW5pdFdhc20oKVxcJyBkZXRlY3RlZC4nKTtcbiAgfVxuICBpZiAoYWJvcnRlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJldmlvdXMgY2FsbCB0byBcXCdpbml0V2FzbSgpXFwnIGZhaWxlZC4nKTtcbiAgfVxuXG4gIGluaXRpYWxpemluZyA9IHRydWU7XG5cbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTV9QUk9YWSAmJiBpc1Byb3h5KCkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcHJveHlXb3JrZXI/LnRlcm1pbmF0ZSgpO1xuXG4gICAgICB2b2lkIGltcG9ydFByb3h5V29ya2VyKCkudGhlbigoW29iamVjdFVybCwgd29ya2VyXSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHByb3h5V29ya2VyID0gd29ya2VyO1xuICAgICAgICAgIHByb3h5V29ya2VyLm9uZXJyb3IgPSAoZXY6IEVycm9yRXZlbnQpID0+IHJlamVjdChldik7XG4gICAgICAgICAgcHJveHlXb3JrZXIub25tZXNzYWdlID0gb25Qcm94eVdvcmtlck1lc3NhZ2U7XG4gICAgICAgICAgaW5pdFdhc21DYWxsYmFja3MgPSBbcmVzb2x2ZSwgcmVqZWN0XTtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHt0eXBlOiAnaW5pdC13YXNtJywgaW4gOiBlbnZ9O1xuICAgICAgICAgIHByb3h5V29ya2VyLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgIHRlbXBvcmFyeU9iamVjdFVybCA9IG9iamVjdFVybDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfSwgcmVqZWN0KTtcbiAgICB9KTtcblxuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBpbml0aWFsaXplV2ViQXNzZW1ibHkoZW52Lndhc20pO1xuICAgICAgYXdhaXQgY29yZS5pbml0UnVudGltZShlbnYpO1xuICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZU9ydEVwID0gYXN5bmMoZXBOYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTV9QUk9YWSAmJiBpc1Byb3h5KCkpIHtcbiAgICBlbnN1cmVXb3JrZXIoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZW5xdWV1ZUNhbGxiYWNrcygnaW5pdC1lcCcsIFtyZXNvbHZlLCByZWplY3RdKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2U6IE9ydFdhc21NZXNzYWdlID0ge3R5cGU6ICdpbml0LWVwJywgaW4gOiB7ZXBOYW1lLCBlbnZ9fTtcbiAgICAgIHByb3h5V29ya2VyIS5wb3N0TWVzc2FnZShtZXNzYWdlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBhd2FpdCBjb3JlLmluaXRFcChlbnYsIGVwTmFtZSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBjb3B5RnJvbUV4dGVybmFsQnVmZmVyID0gYXN5bmMoYnVmZmVyOiBVaW50OEFycmF5KTogUHJvbWlzZTxTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlcj4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIGVuc3VyZVdvcmtlcigpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTxTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlcj4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZW5xdWV1ZUNhbGxiYWNrcygnY29weS1mcm9tJywgW3Jlc29sdmUsIHJlamVjdF0pO1xuICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPSB7dHlwZTogJ2NvcHktZnJvbScsIGluIDoge2J1ZmZlcn19O1xuICAgICAgcHJveHlXb3JrZXIhLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIFtidWZmZXIuYnVmZmVyXSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvcmUuY29weUZyb21FeHRlcm5hbEJ1ZmZlcihidWZmZXIpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlU2Vzc2lvbiA9XG4gICAgYXN5bmMobW9kZWw6IFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyfFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTpcbiAgICAgICAgUHJvbWlzZTxTZXJpYWxpemFibGVTZXNzaW9uTWV0YWRhdGE+ID0+IHtcbiAgICAgICAgICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgdW5zdXBwb3J0ZWQgb3B0aW9uc1xuICAgICAgICAgICAgaWYgKG9wdGlvbnM/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vzc2lvbiBvcHRpb24gXCJwcmVmZXJyZWRPdXRwdXRMb2NhdGlvblwiIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5zdXJlV29ya2VyKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8U2VyaWFsaXphYmxlU2Vzc2lvbk1ldGFkYXRhPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgIGVucXVldWVDYWxsYmFja3MoJ2NyZWF0ZScsIFtyZXNvbHZlLCByZWplY3RdKTtcbiAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPSB7dHlwZTogJ2NyZWF0ZScsIGluIDoge21vZGVsLCBvcHRpb25zOiB7Li4ub3B0aW9uc319fTtcbiAgICAgICAgICAgICAgY29uc3QgdHJhbnNmZXJhYmxlOiBUcmFuc2ZlcmFibGVbXSA9IFtdO1xuICAgICAgICAgICAgICBpZiAobW9kZWwgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmZXJhYmxlLnB1c2gobW9kZWwuYnVmZmVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwcm94eVdvcmtlciEucG9zdE1lc3NhZ2UobWVzc2FnZSwgdHJhbnNmZXJhYmxlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29yZS5jcmVhdGVTZXNzaW9uKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbmV4cG9ydCBjb25zdCByZWxlYXNlU2Vzc2lvbiA9IGFzeW5jKHNlc3Npb25JZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgJiYgaXNQcm94eSgpKSB7XG4gICAgZW5zdXJlV29ya2VyKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGVucXVldWVDYWxsYmFja3MoJ3JlbGVhc2UnLCBbcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHt0eXBlOiAncmVsZWFzZScsIGluIDogc2Vzc2lvbklkfTtcbiAgICAgIHByb3h5V29ya2VyIS5wb3N0TWVzc2FnZShtZXNzYWdlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb3JlLnJlbGVhc2VTZXNzaW9uKHNlc3Npb25JZCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBydW4gPSBhc3luYyhcbiAgICBzZXNzaW9uSWQ6IG51bWJlciwgaW5wdXRJbmRpY2VzOiBudW1iZXJbXSwgaW5wdXRzOiBUZW5zb3JNZXRhZGF0YVtdLCBvdXRwdXRJbmRpY2VzOiBudW1iZXJbXSxcbiAgICBvdXRwdXRzOiBBcnJheTxUZW5zb3JNZXRhZGF0YXxudWxsPiwgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTxUZW5zb3JNZXRhZGF0YVtdPiA9PiB7XG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgJiYgaXNQcm94eSgpKSB7XG4gICAgLy8gY2hlY2sgaW5wdXRzIGxvY2F0aW9uXG4gICAgaWYgKGlucHV0cy5zb21lKHQgPT4gdFszXSAhPT0gJ2NwdScpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHRlbnNvciBvbiBHUFUgaXMgbm90IHN1cHBvcnRlZCBmb3IgcHJveHkuJyk7XG4gICAgfVxuICAgIC8vIGNoZWNrIG91dHB1dHMgbG9jYXRpb25cbiAgICBpZiAob3V0cHV0cy5zb21lKHQgPT4gdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncHJlLWFsbG9jYXRlZCBvdXRwdXQgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LicpO1xuICAgIH1cbiAgICBlbnN1cmVXb3JrZXIoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8U2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGFbXT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZW5xdWV1ZUNhbGxiYWNrcygncnVuJywgW3Jlc29sdmUsIHJlamVjdF0pO1xuICAgICAgY29uc3Qgc2VyaWFsaXphYmxlSW5wdXRzID0gaW5wdXRzIGFzIFNlcmlhbGl6YWJsZVRlbnNvck1ldGFkYXRhW107ICAvLyBldmVyeSBpbnB1dCBpcyBvbiBDUFUuXG4gICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9XG4gICAgICAgICAge3R5cGU6ICdydW4nLCBpbiA6IHtzZXNzaW9uSWQsIGlucHV0SW5kaWNlcywgaW5wdXRzOiBzZXJpYWxpemFibGVJbnB1dHMsIG91dHB1dEluZGljZXMsIG9wdGlvbnN9fTtcbiAgICAgIHByb3h5V29ya2VyIS5wb3N0TWVzc2FnZShtZXNzYWdlLCBjb3JlLmV4dHJhY3RUcmFuc2ZlcmFibGVCdWZmZXJzKHNlcmlhbGl6YWJsZUlucHV0cykpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb3JlLnJ1bihzZXNzaW9uSWQsIGlucHV0SW5kaWNlcywgaW5wdXRzLCBvdXRwdXRJbmRpY2VzLCBvdXRwdXRzLCBvcHRpb25zKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGVuZFByb2ZpbGluZyA9IGFzeW5jKHNlc3Npb25JZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgJiYgaXNQcm94eSgpKSB7XG4gICAgZW5zdXJlV29ya2VyKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGVucXVldWVDYWxsYmFja3MoJ2VuZC1wcm9maWxpbmcnLCBbcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHt0eXBlOiAnZW5kLXByb2ZpbGluZycsIGluIDogc2Vzc2lvbklkfTtcbiAgICAgIHByb3h5V29ya2VyIS5wb3N0TWVzc2FnZShtZXNzYWdlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb3JlLmVuZFByb2ZpbGluZyhzZXNzaW9uSWQpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0luZmVyZW5jZVNlc3Npb24sIEluZmVyZW5jZVNlc3Npb25IYW5kbGVyLCBTZXNzaW9uSGFuZGxlciwgVGVuc29yLCBUUkFDRV9GVU5DX0JFR0lOLCBUUkFDRV9GVU5DX0VORH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHtTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlciwgVGVuc29yTWV0YWRhdGF9IGZyb20gJy4vcHJveHktbWVzc2FnZXMnO1xuaW1wb3J0IHtjb3B5RnJvbUV4dGVybmFsQnVmZmVyLCBjcmVhdGVTZXNzaW9uLCBlbmRQcm9maWxpbmcsIHJlbGVhc2VTZXNzaW9uLCBydW59IGZyb20gJy4vcHJveHktd3JhcHBlcic7XG5pbXBvcnQge2lzR3B1QnVmZmVyU3VwcG9ydGVkVHlwZX0gZnJvbSAnLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge2lzTm9kZX0gZnJvbSAnLi93YXNtLXV0aWxzLWVudic7XG5pbXBvcnQge2xvYWRGaWxlfSBmcm9tICcuL3dhc20tdXRpbHMtbG9hZC1maWxlJztcblxuZXhwb3J0IGNvbnN0IGVuY29kZVRlbnNvck1ldGFkYXRhID0gKHRlbnNvcjogVGVuc29yLCBnZXROYW1lOiAoKSA9PiBzdHJpbmcpOiBUZW5zb3JNZXRhZGF0YSA9PiB7XG4gIHN3aXRjaCAodGVuc29yLmxvY2F0aW9uKSB7XG4gICAgY2FzZSAnY3B1JzpcbiAgICAgIHJldHVybiBbdGVuc29yLnR5cGUsIHRlbnNvci5kaW1zLCB0ZW5zb3IuZGF0YSwgJ2NwdSddO1xuICAgIGNhc2UgJ2dwdS1idWZmZXInOlxuICAgICAgcmV0dXJuIFt0ZW5zb3IudHlwZSwgdGVuc29yLmRpbXMsIHtncHVCdWZmZXI6IHRlbnNvci5ncHVCdWZmZXJ9LCAnZ3B1LWJ1ZmZlciddO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGF0YSBsb2NhdGlvbjogJHt0ZW5zb3IubG9jYXRpb259IGZvciAke2dldE5hbWUoKX1gKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGRlY29kZVRlbnNvck1ldGFkYXRhID0gKHRlbnNvcjogVGVuc29yTWV0YWRhdGEpOiBUZW5zb3IgPT4ge1xuICBzd2l0Y2ggKHRlbnNvclszXSkge1xuICAgIGNhc2UgJ2NwdSc6XG4gICAgICByZXR1cm4gbmV3IFRlbnNvcih0ZW5zb3JbMF0sIHRlbnNvclsyXSwgdGVuc29yWzFdKTtcbiAgICBjYXNlICdncHUtYnVmZmVyJzoge1xuICAgICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JbMF07XG4gICAgICBpZiAoIWlzR3B1QnVmZmVyU3VwcG9ydGVkVHlwZShkYXRhVHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtkYXRhVHlwZX0gZm9yIGRlc2VyaWFsaXppbmcgR1BVIHRlbnNvcmApO1xuICAgICAgfVxuICAgICAgY29uc3Qge2dwdUJ1ZmZlciwgZG93bmxvYWQsIGRpc3Bvc2V9ID0gdGVuc29yWzJdO1xuICAgICAgcmV0dXJuIFRlbnNvci5mcm9tR3B1QnVmZmVyKGdwdUJ1ZmZlciwge2RhdGFUeXBlLCBkaW1zOiB0ZW5zb3JbMV0sIGRvd25sb2FkLCBkaXNwb3NlfSk7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGF0YSBsb2NhdGlvbjogJHt0ZW5zb3JbM119YCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjbGFzcyBPbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXIgaW1wbGVtZW50cyBJbmZlcmVuY2VTZXNzaW9uSGFuZGxlciB7XG4gIHByaXZhdGUgc2Vzc2lvbklkOiBudW1iZXI7XG5cbiAgaW5wdXROYW1lczogc3RyaW5nW107XG4gIG91dHB1dE5hbWVzOiBzdHJpbmdbXTtcblxuICBhc3luYyBmZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeShwYXRoOiBzdHJpbmcpOiBQcm9taXNlPFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyPiB7XG4gICAgLy8gZmV0Y2ggbW9kZWwgZnJvbSB1cmwgYW5kIG1vdmUgdG8gd2FzbSBoZWFwLlxuICAgIHJldHVybiBjb3B5RnJvbUV4dGVybmFsQnVmZmVyKGF3YWl0IGxvYWRGaWxlKHBhdGgpKTtcbiAgfVxuXG4gIGFzeW5jIGxvYWRNb2RlbChwYXRoT3JCdWZmZXI6IHN0cmluZ3xVaW50OEFycmF5LCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICAgIFRSQUNFX0ZVTkNfQkVHSU4oKTtcbiAgICBsZXQgbW9kZWw6IFBhcmFtZXRlcnM8dHlwZW9mIGNyZWF0ZVNlc3Npb24+WzBdO1xuXG4gICAgaWYgKHR5cGVvZiBwYXRoT3JCdWZmZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgIC8vIG5vZGVcbiAgICAgICAgbW9kZWwgPSBhd2FpdCBsb2FkRmlsZShwYXRoT3JCdWZmZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYnJvd3NlclxuICAgICAgICAvLyBmZXRjaCBtb2RlbCBhbmQgY29weSB0byB3YXNtIGhlYXAuXG4gICAgICAgIG1vZGVsID0gYXdhaXQgdGhpcy5mZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeShwYXRoT3JCdWZmZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtb2RlbCA9IHBhdGhPckJ1ZmZlcjtcbiAgICB9XG5cbiAgICBbdGhpcy5zZXNzaW9uSWQsIHRoaXMuaW5wdXROYW1lcywgdGhpcy5vdXRwdXROYW1lc10gPSBhd2FpdCBjcmVhdGVTZXNzaW9uKG1vZGVsLCBvcHRpb25zKTtcbiAgICBUUkFDRV9GVU5DX0VORCgpO1xuICB9XG5cbiAgYXN5bmMgZGlzcG9zZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gcmVsZWFzZVNlc3Npb24odGhpcy5zZXNzaW9uSWQpO1xuICB9XG5cbiAgYXN5bmMgcnVuKGZlZWRzOiBTZXNzaW9uSGFuZGxlci5GZWVkc1R5cGUsIGZldGNoZXM6IFNlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlLCBvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOlxuICAgICAgUHJvbWlzZTxTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlPiB7XG4gICAgVFJBQ0VfRlVOQ19CRUdJTigpO1xuICAgIGNvbnN0IGlucHV0QXJyYXk6IFRlbnNvcltdID0gW107XG4gICAgY29uc3QgaW5wdXRJbmRpY2VzOiBudW1iZXJbXSA9IFtdO1xuICAgIE9iamVjdC5lbnRyaWVzKGZlZWRzKS5mb3JFYWNoKGt2cCA9PiB7XG4gICAgICBjb25zdCBuYW1lID0ga3ZwWzBdO1xuICAgICAgY29uc3QgdGVuc29yID0ga3ZwWzFdO1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmlucHV0TmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGlucHV0ICcke25hbWV9J2ApO1xuICAgICAgfVxuICAgICAgaW5wdXRBcnJheS5wdXNoKHRlbnNvcik7XG4gICAgICBpbnB1dEluZGljZXMucHVzaChpbmRleCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBvdXRwdXRBcnJheTogQXJyYXk8VGVuc29yfG51bGw+ID0gW107XG4gICAgY29uc3Qgb3V0cHV0SW5kaWNlczogbnVtYmVyW10gPSBbXTtcbiAgICBPYmplY3QuZW50cmllcyhmZXRjaGVzKS5mb3JFYWNoKGt2cCA9PiB7XG4gICAgICBjb25zdCBuYW1lID0ga3ZwWzBdO1xuICAgICAgY29uc3QgdGVuc29yID0ga3ZwWzFdO1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm91dHB1dE5hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvdXRwdXQgJyR7bmFtZX0nYCk7XG4gICAgICB9XG4gICAgICBvdXRwdXRBcnJheS5wdXNoKHRlbnNvcik7XG4gICAgICBvdXRwdXRJbmRpY2VzLnB1c2goaW5kZXgpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgaW5wdXRzID1cbiAgICAgICAgaW5wdXRBcnJheS5tYXAoKHQsIGkpID0+IGVuY29kZVRlbnNvck1ldGFkYXRhKHQsICgpID0+IGBpbnB1dCBcIiR7dGhpcy5pbnB1dE5hbWVzW2lucHV0SW5kaWNlc1tpXV19XCJgKSk7XG4gICAgY29uc3Qgb3V0cHV0cyA9IG91dHB1dEFycmF5Lm1hcChcbiAgICAgICAgKHQsIGkpID0+IHQgPyBlbmNvZGVUZW5zb3JNZXRhZGF0YSh0LCAoKSA9PiBgb3V0cHV0IFwiJHt0aGlzLm91dHB1dE5hbWVzW291dHB1dEluZGljZXNbaV1dfVwiYCkgOiBudWxsKTtcblxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBydW4odGhpcy5zZXNzaW9uSWQsIGlucHV0SW5kaWNlcywgaW5wdXRzLCBvdXRwdXRJbmRpY2VzLCBvdXRwdXRzLCBvcHRpb25zKTtcblxuICAgIGNvbnN0IHJlc3VsdE1hcDogU2Vzc2lvbkhhbmRsZXIuUmV0dXJuVHlwZSA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0TWFwW3RoaXMub3V0cHV0TmFtZXNbb3V0cHV0SW5kaWNlc1tpXV1dID0gb3V0cHV0QXJyYXlbaV0gPz8gZGVjb2RlVGVuc29yTWV0YWRhdGEocmVzdWx0c1tpXSk7XG4gICAgfVxuICAgIFRSQUNFX0ZVTkNfRU5EKCk7XG4gICAgcmV0dXJuIHJlc3VsdE1hcDtcbiAgfVxuXG4gIHN0YXJ0UHJvZmlsaW5nKCk6IHZvaWQge1xuICAgIC8vIFRPRE86IGltcGxlbWVudCBwcm9maWxpbmdcbiAgfVxuXG4gIGVuZFByb2ZpbGluZygpOiB2b2lkIHtcbiAgICB2b2lkIGVuZFByb2ZpbGluZyh0aGlzLnNlc3Npb25JZCk7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtCYWNrZW5kLCBlbnYsIEluZmVyZW5jZVNlc3Npb24sIEluZmVyZW5jZVNlc3Npb25IYW5kbGVyfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQge2luaXRpYWxpemVPcnRFcCwgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5QW5kT3J0UnVudGltZX0gZnJvbSAnLi93YXNtL3Byb3h5LXdyYXBwZXInO1xuaW1wb3J0IHtPbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXJ9IGZyb20gJy4vd2FzbS9zZXNzaW9uLWhhbmRsZXItaW5mZXJlbmNlJztcbmltcG9ydCB7c2NyaXB0U3JjfSBmcm9tICcuL3dhc20vd2FzbS11dGlscy1pbXBvcnQnO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaW5pdGlhbGl6ZXMgYWxsIGZsYWdzIGZvciBXZWJBc3NlbWJseS5cbiAqXG4gKiBUaG9zZSBmbGFncyBhcmUgYWNjZXNzaWJsZSBmcm9tIGBvcnQuZW52Lndhc21gLiBVc2VycyBhcmUgYWxsb3cgdG8gc2V0IHRob3NlIGZsYWdzIGJlZm9yZSB0aGUgZmlyc3QgaW5mZXJlbmNlIHNlc3Npb25cbiAqIGJlaW5nIGNyZWF0ZWQsIHRvIG92ZXJyaWRlIGRlZmF1bHQgdmFsdWUuXG4gKi9cbmV4cG9ydCBjb25zdCBpbml0aWFsaXplRmxhZ3MgPSAoKTogdm9pZCA9PiB7XG4gIGlmICh0eXBlb2YgZW52Lndhc20uaW5pdFRpbWVvdXQgIT09ICdudW1iZXInIHx8IGVudi53YXNtLmluaXRUaW1lb3V0IDwgMCkge1xuICAgIGVudi53YXNtLmluaXRUaW1lb3V0ID0gMDtcbiAgfVxuXG4gIGlmIChlbnYud2FzbS5zaW1kID09PSBmYWxzZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgICAnRGVwcmVjYXRlZCBwcm9wZXJ0eSBcImVudi53YXNtLnNpbWRcIiBpcyBzZXQgdG8gZmFsc2UuICcgK1xuICAgICAgICAnbm9uLVNJTUQgYnVpbGQgaXMgbm8gbG9uZ2VyIHByb3ZpZGVkLCBhbmQgdGhpcyBzZXR0aW5nIHdpbGwgYmUgaWdub3JlZC4nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW52Lndhc20ucHJveHkgIT09ICdib29sZWFuJykge1xuICAgIGVudi53YXNtLnByb3h5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGVudi53YXNtLnRyYWNlICE9PSAnYm9vbGVhbicpIHtcbiAgICBlbnYud2FzbS50cmFjZSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbnYud2FzbS5udW1UaHJlYWRzICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcihlbnYud2FzbS5udW1UaHJlYWRzKSB8fCBlbnYud2FzbS5udW1UaHJlYWRzIDw9IDApIHtcbiAgICAvLyBUaGUgZm9sbG93aW5nIGxvZ2ljIG9ubHkgYXBwbGllcyB3aGVuIGBvcnQuZW52Lndhc20ubnVtVGhyZWFkc2AgaXMgbm90IHNldCBieSB1c2VyLiBXZSB3aWxsIGFsd2F5cyBob25vciB1c2VyJ3NcbiAgICAvLyBzZXR0aW5nIGlmIGl0IGlzIHByb3ZpZGVkLlxuXG4gICAgLy8gQnJvd3Nlcjogd2hlbiBjcm9zc09yaWdpbklzb2xhdGVkIGlzIGZhbHNlLCBTaGFyZWRBcnJheUJ1ZmZlciBpcyBub3QgYXZhaWxhYmxlIHNvIFdlYkFzc2VtYmx5IHRocmVhZHMgd2lsbCBub3RcbiAgICAvLyB3b3JrLiBJbiB0aGlzIGNhc2UsIHdlIHdpbGwgc2V0IG51bVRocmVhZHMgdG8gMS5cbiAgICAvL1xuICAgIC8vIFRoZXJlIGlzIGFuIGV4Y2VwdGlvbjogd2hlbiB0aGUgYnJvd3NlciBpcyBjb25maWd1cmVkIHRvIGZvcmNlLWVuYWJsZSBTaGFyZWRBcnJheUJ1ZmZlciAoZS5nLiBDaHJvbXVpbSB3aXRoXG4gICAgLy8gLS1lbmFibGUtZmVhdHVyZXM9U2hhcmVkQXJyYXlCdWZmZXIpLCBpdCBpcyBwb3NzaWJsZSB0aGF0IGBzZWxmLmNyb3NzT3JpZ2luSXNvbGF0ZWRgIGlzIGZhbHNlIGFuZFxuICAgIC8vIFNoYXJlZEFycmF5QnVmZmVyIGlzIGF2YWlsYWJsZSBhdCB0aGUgc2FtZSB0aW1lLiBUaGlzIGlzIHVzdWFsbHkgZm9yIHRlc3RpbmcuIEluIHRoaXMgY2FzZSwgIHdlIHdpbGwgc3RpbGwgc2V0XG4gICAgLy8gbnVtVGhyZWFkcyB0byAxIGhlcmUuIElmIHdlIHdhbnQgdG8gZW5hYmxlIG11bHRpLXRocmVhZGluZyBpbiB0ZXN0LCB3ZSBzaG91bGQgc2V0IGBvcnQuZW52Lndhc20ubnVtVGhyZWFkc2AgdG8gYVxuICAgIC8vIHZhbHVlIGdyZWF0ZXIgdGhhbiAxLlxuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgIXNlbGYuY3Jvc3NPcmlnaW5Jc29sYXRlZCkge1xuICAgICAgZW52Lndhc20ubnVtVGhyZWFkcyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG51bUNwdUxvZ2ljYWxDb3JlcyA9XG4gICAgICAgICAgdHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgPyByZXF1aXJlKCdub2RlOm9zJykuY3B1cygpLmxlbmd0aCA6IG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5O1xuICAgICAgZW52Lndhc20ubnVtVGhyZWFkcyA9IE1hdGgubWluKDQsIE1hdGguY2VpbCgobnVtQ3B1TG9naWNhbENvcmVzIHx8IDEpIC8gMikpO1xuICAgIH1cbiAgfVxuXG4gIC8vIG92ZXJ3cml0ZSB3YXNtIHBhdGhzIG92ZXJyaWRlIGlmIG5vdCBzZXRcbiAgaWYgKGVudi53YXNtLndhc21QYXRocyA9PT0gdW5kZWZpbmVkICYmIHNjcmlwdFNyYyAmJiBzY3JpcHRTcmMuaW5kZXhPZignYmxvYjonKSAhPT0gMCkge1xuICAgIGVudi53YXNtLndhc21QYXRocyA9IHNjcmlwdFNyYy5zdWJzdHJpbmcoMCwgc2NyaXB0U3JjLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgfVxufTtcblxuZXhwb3J0IGNsYXNzIE9ubnhydW50aW1lV2ViQXNzZW1ibHlCYWNrZW5kIGltcGxlbWVudHMgQmFja2VuZCB7XG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGluaXRpYWxpemVzIHRoZSBXZWJBc3NlbWJseSBiYWNrZW5kLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIG9ubHkgb25jZSBmb3IgZWFjaCBiYWNrZW5kIG5hbWUuIEl0IHdpbGwgYmUgY2FsbGVkIHRoZSBmaXJzdCB0aW1lIHdoZW5cbiAgICogYG9ydC5JbmZlcmVuY2VTZXNzaW9uLmNyZWF0ZSgpYCBpcyBjYWxsZWQgd2l0aCBhIHJlZ2lzdGVyZWQgYmFja2VuZCBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0gYmFja2VuZE5hbWUgLSB0aGUgcmVnaXN0ZXJlZCBiYWNrZW5kIG5hbWUuXG4gICAqL1xuICBhc3luYyBpbml0KGJhY2tlbmROYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBwb3B1bGF0ZSB3YXNtIGZsYWdzXG4gICAgaW5pdGlhbGl6ZUZsYWdzKCk7XG5cbiAgICAvLyBpbml0IHdhc21cbiAgICBhd2FpdCBpbml0aWFsaXplV2ViQXNzZW1ibHlBbmRPcnRSdW50aW1lKCk7XG5cbiAgICAvLyBwZXJmb3JtZSBFUCBzcGVjaWZpYyBpbml0aWFsaXphdGlvblxuICAgIGF3YWl0IGluaXRpYWxpemVPcnRFcChiYWNrZW5kTmFtZSk7XG4gIH1cbiAgY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIocGF0aDogc3RyaW5nLCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6XG4gICAgICBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25IYW5kbGVyPjtcbiAgY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIoYnVmZmVyOiBVaW50OEFycmF5LCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6XG4gICAgICBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25IYW5kbGVyPjtcbiAgYXN5bmMgY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIocGF0aE9yQnVmZmVyOiBzdHJpbmd8VWludDhBcnJheSwgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOlxuICAgICAgUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj4ge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBuZXcgT25ueHJ1bnRpbWVXZWJBc3NlbWJseVNlc3Npb25IYW5kbGVyKCk7XG4gICAgYXdhaXQgaGFuZGxlci5sb2FkTW9kZWwocGF0aE9yQnVmZmVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGhhbmRsZXIpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7T25ueHJ1bnRpbWVXZWJBc3NlbWJseUJhY2tlbmR9IGZyb20gJy4vYmFja2VuZC13YXNtJztcbmV4cG9ydCBjb25zdCB3YXNtQmFja2VuZCA9IG5ldyBPbm54cnVudGltZVdlYkFzc2VtYmx5QmFja2VuZCgpO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzICovXG5cbi8vIFdlIHVzZSBcInJlcXVpcmVcIiBpbnN0ZWFkIG9mIFwiaW1wb3J0XCIgaGVyZSBiZWNhdXNlIGltcG9ydCBzdGF0ZW1lbnQgbXVzdCBiZSBwdXQgaW4gdG9wIGxldmVsLiBPdXIgY3VycmVudCBjb2RlIGRvZXNcbi8vIG5vdCBhbGxvdyBidW5kbGVyIHRvIHRyZWUtc2hha2luZyBjb2RlIGFzIGV4cGVjdGVkIGJlY2F1c2Ugc29tZSBjb2RlcyBhcmUgdHJlYXRlZCBhcyBoYXZpbmcgc2lkZSBlZmZlY3RzLlxuLy8gU28gd2UgaW1wb3J0IGNvZGUgaW5zaWRlIHRoZSBpZi1jbGF1c2UgdG8gYWxsb3cgYnVuZGxlciByZW1vdmUgdGhlIGNvZGUgc2FmZWx5LlxuXG5leHBvcnQgKiBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuaW1wb3J0ICogYXMgb3J0IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5leHBvcnQgZGVmYXVsdCBvcnQ7XG5cbmltcG9ydCB7cmVnaXN0ZXJCYWNrZW5kLCBlbnZ9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5pbXBvcnQge3ZlcnNpb259IGZyb20gJy4vdmVyc2lvbic7XG5cbmlmICghQlVJTERfREVGUy5ESVNBQkxFX1dFQkdMKSB7XG4gIGNvbnN0IG9ubnhqc0JhY2tlbmQgPSByZXF1aXJlKCcuL2JhY2tlbmQtb25ueGpzJykub25ueGpzQmFja2VuZDtcbiAgcmVnaXN0ZXJCYWNrZW5kKCd3ZWJnbCcsIG9ubnhqc0JhY2tlbmQsIC0xMCk7XG59XG5cbmlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU00pIHtcbiAgY29uc3Qgd2FzbUJhY2tlbmQgPSBCVUlMRF9ERUZTLkRJU0FCTEVfVFJBSU5JTkcgPyByZXF1aXJlKCcuL2JhY2tlbmQtd2FzbS1pbmZlcmVuY2UnKS53YXNtQmFja2VuZCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9iYWNrZW5kLXdhc20tdHJhaW5pbmcnKS53YXNtQmFja2VuZDtcbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCkge1xuICAgIHJlZ2lzdGVyQmFja2VuZCgnd2ViZ3B1Jywgd2FzbUJhY2tlbmQsIDUpO1xuICAgIHJlZ2lzdGVyQmFja2VuZCgnd2Vibm4nLCB3YXNtQmFja2VuZCwgNSk7XG4gIH1cbiAgcmVnaXN0ZXJCYWNrZW5kKCdjcHUnLCB3YXNtQmFja2VuZCwgMTApO1xuICByZWdpc3RlckJhY2tlbmQoJ3dhc20nLCB3YXNtQmFja2VuZCwgMTApO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZW52LnZlcnNpb25zLCAnd2ViJywge3ZhbHVlOiB2ZXJzaW9uLCBlbnVtZXJhYmxlOiB0cnVlfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgL2pzL3NjcmlwdHMvdXBkYXRlLXZlcnNpb24udHNcbi8vIERvIG5vdCBtb2RpZnkgZmlsZSBjb250ZW50IG1hbnVhbGx5LlxuXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9ICcxLjE5LjAnO1xuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQWdCTSxVQUNBLDBCQVlPLGlCQXdDUCxnQ0F3Q087QUE3R2I7O0FBZ0JBLElBQU0sV0FBcUMsb0JBQUksSUFBRztBQUNsRCxJQUFNLDJCQUFxQyxDQUFBO0FBWXBDLElBQU0sa0JBQWtCLENBQUNBLE9BQWNDLFVBQWtCLGFBQTBCO0FBQ3hGLFVBQUlBLFlBQVcsT0FBT0EsU0FBUSxTQUFTLGNBQWMsT0FBT0EsU0FBUSxrQ0FBa0MsWUFBWTtBQUNoSCxjQUFNLGlCQUFpQixTQUFTLElBQUlELEtBQUk7QUFDeEMsWUFBSSxtQkFBbUIsUUFBVztBQUNoQyxtQkFBUyxJQUFJQSxPQUFNLEVBQUMsU0FBQUMsVUFBUyxTQUFRLENBQUM7bUJBQzdCLGVBQWUsV0FBVyxVQUFVO0FBRTdDO21CQUNTLGVBQWUsYUFBYSxVQUFVO0FBQy9DLGNBQUksZUFBZSxZQUFZQSxVQUFTO0FBQ3RDLGtCQUFNLElBQUksTUFBTSw0QkFBNEJELEtBQUksb0JBQW9CLFFBQVEsRUFBRTs7O0FBSWxGLFlBQUksWUFBWSxHQUFHO0FBQ2pCLGdCQUFNLElBQUkseUJBQXlCLFFBQVFBLEtBQUk7QUFDL0MsY0FBSSxNQUFNLElBQUk7QUFDWixxQ0FBeUIsT0FBTyxHQUFHLENBQUM7O0FBR3RDLG1CQUFTRSxLQUFJLEdBQUdBLEtBQUkseUJBQXlCLFFBQVFBLE1BQUs7QUFDeEQsZ0JBQUksU0FBUyxJQUFJLHlCQUF5QkEsRUFBQyxDQUFDLEVB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SztBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFLO0FBQUEsUUFBRztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUs7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBSztBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFLO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBSztBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUs7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBSztBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFJO0FBQUEsUUFBSztBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUk7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUk7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFJO0FBQUEsUUFBSztBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFJO0FBQUEsUUFBSTtBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFJO0FBQUEsUUFBSztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBSTtBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBSTtBQUFBLFFBQUk7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBSTtBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUk7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUk7QUFBQSxRQUFJO0FBQUEsUUFBSztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUc7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUk7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFJO0FBQUEsUUFBSztBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFJO0FBQUEsUUFBSTtBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFHO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFJO0FBQUEsUUFBSztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBRztBQUFBLFFBQUs7QUFBQSxRQUFJO0FBQUEsUUFBSTtBQUFBLFFBQUs7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBSTtBQUFBLFFBQUk7QUFBQSxRQUFLO0FBQUEsUUFBSztBQUFBLFFBQUk7QUFBQSxRQUFHO0FBQUEsUUFBSTtBQUFBLFFBQUc7QUFBQSxRQUFLO0FBQUEsTUFDNW5DLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxF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QUFBQSxNQUM1RTtBQUFBLElBQ0Y7QUFFTyxJQUFNLGdDQUFOLE1BQXVEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUzVELE1BQU0sS0FBSyxhQUFvQztBQUU3Qyx3QkFBZ0I7QUFHaEIsY0FBTSxtQ0FBbUM7QUFHekMsY0FBTSxnQkFBZ0IsV0FBVztBQUFBLE1BQ25DO0FBQUEsTUFLQSxNQUFNLDhCQUE4QixjQUFpQyxTQUNoQztBQUNuQyxjQUFNLFVBQVUsSUFBSSxxQ0FBcUM7QUFDekQsY0FBTSxRQUFRLFVBQVUsY0FBYyxPQUFPO0FBQzdDLGVBQU8sUUFBUSxRQUFRLE9BQU87QUFBQSxNQUNoQztBQUFBLElBQ0Y7QUFBQTtBQUFBOzs7QUMzRkE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUlhO0FBSmI7QUFBQTtBQUFBO0FBR0E7QUFDTyxJQUFNLGNBQWMsSUFBSSw4QkFBOEI7QUFBQTtBQUFBOzs7QUNLN0Q7QUFDQTtBQUdBOzs7QUNQTyxJQUFNQyxXQUFVOzs7QURLdkIsSUFBTyxjQUFRO0FBS2YsSUFBSSxNQUEyQjtBQUM3QixRQUFNQyxpQkFBZ0IsOERBQTRCO0FBQ2xELGtCQUFnQixTQUFTQSxnQkFBZSxHQUFHO0FBQzdDO0FBRUEsSUFBSSxNQUEwQjtBQUM1QixRQUFNQyxlQUFjLE9BQThCLDhFQUFvQyxjQUNwQyxLQUFtQztBQUNyRixNQUFJLE9BQTBCO0FBQzVCLG9CQUFnQixVQUFVQSxjQUFhLENBQUM7QUFDeEMsb0JBQWdCLFNBQVNBLGNBQWEsQ0FBQztBQUFBLEVBQ3pDO0FBQ0Esa0JBQWdCLE9BQU9BLGNBQWEsRUFBRTtBQUN0QyxrQkFBZ0IsUUFBUUEsY0FBYSxFQUFFO0FBQ3pDO0FBRUEsT0FBTyxlQUFlQyxLQUFJLFVBQVUsT0FBTyxFQUFDLE9BQU9DLFVBQVMsWUFBWSxLQUFJLENBQUM7IiwKICAibmFtZXMiOiBbIm5hbWUiLCAiYmFja2VuZCIsICJpIiwgImVudiIsICJjcmVhdGVDYW52YXMiLCAiVGVuc29yIiwgIlRlbnNvciIsICJuYW1lIiwgImJhY2tlbmQiLCAiSW5mZXJlbmNlU2Vzc2lvbiIsICJiYWNrZW5kIiwgIlRlbnNvciIsICJuYW1lIiwgIlRyYWluaW5nU2Vzc2lvbiIsICJJbmZlcmVuY2VTZXNzaW9uIiwgIlRlbnNvciIsICJUcmFpbmluZ1Nlc3Npb24iLCAiZW52IiwgImxvZyIsICJlbnYiLCAibmFtZSIsICJ2ZXJzaW9uIiwgImV4cG9ydHMiLCAiR3VpZCIsICJjYWNoZSIsICJkaXYiLCAibG9nMiIsICJvbm54cnVudGltZSIsICJleHBlcmltZW50YWwiLCAiZmJzIiwgIkF0dHJpYnV0ZVR5cGUiLCAiRGltZW5zaW9uVmFsdWVUeXBlIiwgIlRlbnNvckRhdGFUeXBlIiwgIk5vZGVUeXBlIiwgIlR5cGVJbmZvVmFsdWUiLCAiTm9kZSIsICJ2ZXJzaW9uIiwgIlRlbnNvciIsICJBdHRyaWJ1dGUiLCAiR3JhcGgiLCAiTW9kZWwiLCAiSW5mZXJlbmNlU2Vzc2lvbiIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJwYXJhbXMiLCAib2Zmc2V0IiwgImV4cG9ydHMiLCAiaSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgInNsaWNlIiwgInNpemUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZnJvbU51bWJlciIsICJ0b051bWJlciIsICJleHBvcnRzIiwgIkJ1ZmZlciIsICJuYW1lIiwgImkiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiY3JlYXRlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImNyZWF0ZV9hcnJheSIsICJjcmVhdGUiLCAiYnVmZmVyIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgInNlbGYiLCAiZXJyIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJyZXF1aXJlX21pbmltYWwiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAib25ueCIsICJUZW5zb3IiLCAiTWFwIiwgImluaXRfdGVuc29yIiwgIlRlbnNvciIsICJzaGFwZSIsICJzcGxpdCIsICJpbXBvcnRfb25ueCIsICJUZW5zb3IiLCAiaW5pdF90ZW5zb3IiLCAiY2FjaGUiLCAidmVyc2lvbiIsICJuYW1lIiwgInNoYXBlIiwgInNoYXBlIiwgInNoYXBlIiwgImluaXRfdGVuc29yIiwgInNoYXBlIiwgIlRlbnNvciIsICJuYW1lIiwgIm5hbWUiLCAibmFtZSIsICJhZGQiLCAiYW5kIiwgIm9yIiwgInhvciIsICJnbHNsIiwgInNoYWRlclNvdXJjZSIsICJ2YWxpZGF0ZUlucHV0cyIsICJzaGlmdCIsICJ2YWxpZGF0ZUlucHV0cyIsICJuYW1lIiwgImxvZyIsICJub3QiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAibmFtZSIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJzaGFwZSIsICJ2YWxpZGF0ZUlucHV0cyIsICJzdW0iLCAidmFsaWRhdGVJbnB1dHMiLCAibmFtZSIsICJpbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAiZGltIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgImluaXRfdGVuc29yIiwgIlRlbnNvciIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJzcGxpdCIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0c1YxMyIsICJhZGQiLCAiYW5kIiwgImxvZyIsICJub3QiLCAib3IiLCAieG9yIiwgIm5hbWUiLCAic2hhcGUiLCAic2hhcGUiLCAibmFtZSIsICJzb3VyY2UiLCAicGFja2VkU2FtcGxlciIsICJ0ZXhOdW1SIiwgInRleE51bUMiLCAidHJhbnNwb3NlIiwgIm5hbWUiLCAic2hhcGUiLCAiaSIsICJuYW1lIiwgIm5hbWUiLCAiZW52IiwgIm5hbWUiLCAibG9jYXRpb24iLCAidGV4dHVyZSIsICJiYWNrZW5kIiwgInZlcnNpb24iLCAiZW52IiwgImVudiIsICJjYWNoZSIsICJiYWNrZW5kIiwgImluaXRfYmFja2VuZCIsICJvdXRwdXQiLCAiaW1wb3J0X29ubngiLCAib3J0RmJzIiwgImluaXRfdGVuc29yIiwgIlRlbnNvciIsICJ2YWx1ZSIsICJpbXBvcnRfb25ueCIsICJvcnRGYnMiLCAiaW5pdF90ZW5zb3IiLCAibmFtZSIsICJUZW5zb3IiLCAic2hhcGUiLCAibm9kZUluZGV4IiwgImltcG9ydF9vbm54IiwgIm9ydEZicyIsICJpbml0X2JhY2tlbmQiLCAiYmFja2VuZCIsICJpbml0X3RlbnNvciIsICJuYW1lIiwgIlRlbnNvciIsICJlbnYiLCAid2FzbSIsICJtb2R1bGUiLCAid2FzbSIsICJuYW1lIiwgIndhc20iLCAid2FzbSIsICJuYW1lIiwgImxvY2F0aW9uIiwgImVudiIsICJ3YXNtIiwgIm5hbWUiLCAibG9jYXRpb24iLCAidGVuc29yIiwgImVycm9yQ29kZSIsICJpIiwgImluaXRpYWxpemluZyIsICJpbml0aWFsaXplZCIsICJhYm9ydGVkIiwgImNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIiLCAiY3JlYXRlU2Vzc2lvbiIsICJyZWxlYXNlU2Vzc2lvbiIsICJydW4iLCAiZW5kUHJvZmlsaW5nIiwgImVudiIsICJpbml0X3Nlc3Npb25faGFuZGxlcl9pbmZlcmVuY2UiLCAiVGVuc29yIiwgImNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIiLCAiY3JlYXRlU2Vzc2lvbiIsICJyZWxlYXNlU2Vzc2lvbiIsICJuYW1lIiwgInJ1biIsICJlbmRQcm9maWxpbmciLCAiaW5pdF9zZXNzaW9uX2hhbmRsZXJfaW5mZXJlbmNlIiwgImVudiIsICJ2ZXJzaW9uIiwgIm9ubnhqc0JhY2tlbmQiLCAid2FzbUJhY2tlbmQiLCAiZW52IiwgInZlcnNpb24iXQp9Cg==
