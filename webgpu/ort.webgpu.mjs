/*!
 * ONNX Runtime Web v1.19.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// web/node_modules/onnxruntime-common/dist/esm/backend-impl.js
var backends, backendsSortedByPriority, registerBackend, tryResolveAndInitializeBackend, resolveBackendAndExecutionProviders;
var init_backend_impl = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/backend-impl.js"() {
    backends = /* @__PURE__ */ new Map();
    backendsSortedByPriority = [];
    registerBackend = (name, backend, priority) => {
      if (backend && typeof backend.init === "function" && typeof backend.createInferenceSessionHandler === "function") {
        const currentBackend = backends.get(name);
        if (currentBackend === void 0) {
          backends.set(name, { backend, priority });
        } else if (currentBackend.priority > priority) {
          return;
        } else if (currentBackend.priority === priority) {
          if (currentBackend.backend !== backend) {
            throw new Error(`cannot register backend "${name}" using priority ${priority}`);
          }
        }
        if (priority >= 0) {
          const i = backendsSortedByPriority.indexOf(name);
          if (i !== -1) {
            backendsSortedByPriority.splice(i, 1);
          }
          for (let i2 = 0; i2 < backendsSortedByPriority.length; i2++) {
            if (backends.get(backendsSortedByPriority[i2]).priority <= priority) {
              backendsSortedByPriority.splice(i2, 0, name);
              return;
            }
          }
          backendsSortedByPriority.push(name);
        }
        return;
      }
      throw new TypeError("not a valid backend");
    };
    tryResolveAndInitializeBackend = async (backendName) => {
      const backendInfo = backends.get(backendName);
      if (!backendInfo) {
        return "backend not found.";
      }
      if (backendInfo.initialized) {
        return backendInfo.backend;
      } else if (backendInfo.aborted) {
        return backendInfo.error;
      } else {
        const isInitializing = !!backendInfo.initPromise;
        try {
          if (!isInitializing) {
            backendInfo.initPromise = backendInfo.backend.init(backendName);
          }
          await backendInfo.initPromise;
          backendInfo.initialized = true;
          return backendInfo.backend;
        } catch (e) {
          if (!isInitializing) {
            backendInfo.error = `${e}`;
            backendInfo.aborted = true;
          }
          return backendInfo.error;
        } finally {
          delete backendInfo.initPromise;
        }
      }
    };
    resolveBackendAndExecutionProviders = async (options) => {
      const eps = options.executionProviders || [];
      const backendHints = eps.map((i) => typeof i === "string" ? i : i.name);
      const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;
      let backend;
      const errors = [];
      const availableBackendNames = /* @__PURE__ */ new Set();
      for (const backendName of backendNames) {
        const resolveResult = await tryResolveAndInitializeBackend(backendName);
        if (typeof resolveResult === "string") {
          errors.push({ name: backendName, err: resolveResult });
        } else {
          if (!backend) {
            backend = resolveResult;
          }
          if (backend === resolveResult) {
            availableBackendNames.add(backendName);
          }
        }
      }
      if (!backend) {
        throw new Error(`no available backend found. ERR: ${errors.map((e) => `[${e.name}] ${e.err}`).join(", ")}`);
      }
      for (const { name, err } of errors) {
        if (backendHints.includes(name)) {
          console.warn(`removing requested execution provider "${name}" from session options because it is not available: ${err}`);
        }
      }
      const filteredEps = eps.filter((i) => availableBackendNames.has(typeof i === "string" ? i : i.name));
      return [
        backend,
        new Proxy(options, {
          get: (target, prop) => {
            if (prop === "executionProviders") {
              return filteredEps;
            }
            return Reflect.get(target, prop);
          }
        })
      ];
    };
  }
});

// web/node_modules/onnxruntime-common/dist/esm/backend.js
var init_backend = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/backend.js"() {
    init_backend_impl();
  }
});

// web/node_modules/onnxruntime-common/dist/esm/version.js
var version;
var init_version = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/version.js"() {
    version = "1.19.0";
  }
});

// web/node_modules/onnxruntime-common/dist/esm/env-impl.js
var logLevelValue, env;
var init_env_impl = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/env-impl.js"() {
    init_version();
    logLevelValue = "warning";
    env = {
      wasm: {},
      webgl: {},
      webgpu: {},
      versions: { common: version },
      set logLevel(value) {
        if (value === void 0) {
          return;
        }
        if (typeof value !== "string" || ["verbose", "info", "warning", "error", "fatal"].indexOf(value) === -1) {
          throw new Error(`Unsupported logging level: ${value}`);
        }
        logLevelValue = value;
      },
      get logLevel() {
        return logLevelValue;
      }
    };
    Object.defineProperty(env, "logLevel", { enumerable: true });
  }
});

// web/node_modules/onnxruntime-common/dist/esm/env.js
var env2;
var init_env = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/env.js"() {
    init_env_impl();
    env2 = env;
  }
});

// web/node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js
var tensorToDataURL, tensorToImageData;
var init_tensor_conversion_impl = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js"() {
    tensorToDataURL = (tensor, options) => {
      const canvas = typeof document !== "undefined" ? document.createElement("canvas") : new OffscreenCanvas(1, 1);
      canvas.width = tensor.dims[3];
      canvas.height = tensor.dims[2];
      const pixels2DContext = canvas.getContext("2d");
      if (pixels2DContext != null) {
        let width;
        let height;
        if (options?.tensorLayout !== void 0 && options.tensorLayout === "NHWC") {
          width = tensor.dims[2];
          height = tensor.dims[3];
        } else {
          width = tensor.dims[3];
          height = tensor.dims[2];
        }
        const inputformat = options?.format !== void 0 ? options.format : "RGB";
        const norm = options?.norm;
        let normMean;
        let normBias;
        if (norm === void 0 || norm.mean === void 0) {
          normMean = [255, 255, 255, 255];
        } else {
          if (typeof norm.mean === "number") {
            normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
          } else {
            normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 0];
            if (norm.mean[3] !== void 0) {
              normMean[3] = norm.mean[3];
            }
          }
        }
        if (norm === void 0 || norm.bias === void 0) {
          normBias = [0, 0, 0, 0];
        } else {
          if (typeof norm.bias === "number") {
            normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
          } else {
            normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
            if (norm.bias[3] !== void 0) {
              normBias[3] = norm.bias[3];
            }
          }
        }
        const stride = height * width;
        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
        if (inputformat === "RGBA") {
          rTensorPointer = 0;
          gTensorPointer = stride;
          bTensorPointer = stride * 2;
          aTensorPointer = stride * 3;
        } else if (inputformat === "RGB") {
          rTensorPointer = 0;
          gTensorPointer = stride;
          bTensorPointer = stride * 2;
        } else if (inputformat === "RBG") {
          rTensorPointer = 0;
          bTensorPointer = stride;
          gTensorPointer = stride * 2;
        }
        for (let i = 0; i < height; i++) {
          for (let j = 0; j < width; j++) {
            const R = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
            const G = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
            const B = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
            const A = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
            pixels2DContext.fillStyle = "rgba(" + R + "," + G + "," + B + "," + A + ")";
            pixels2DContext.fillRect(j, i, 1, 1);
          }
        }
        if ("toDataURL" in canvas) {
          return canvas.toDataURL();
        } else {
          throw new Error("toDataURL is not supported");
        }
      } else {
        throw new Error("Can not access image data");
      }
    };
    tensorToImageData = (tensor, options) => {
      const pixels2DContext = typeof document !== "undefined" ? document.createElement("canvas").getContext("2d") : new OffscreenCanvas(1, 1).getContext("2d");
      let image;
      if (pixels2DContext != null) {
        let width;
        let height;
        let channels;
        if (options?.tensorLayout !== void 0 && options.tensorLayout === "NHWC") {
          width = tensor.dims[2];
          height = tensor.dims[1];
          channels = tensor.dims[3];
        } else {
          width = tensor.dims[3];
          height = tensor.dims[2];
          channels = tensor.dims[1];
        }
        const inputformat = options !== void 0 ? options.format !== void 0 ? options.format : "RGB" : "RGB";
        const norm = options?.norm;
        let normMean;
        let normBias;
        if (norm === void 0 || norm.mean === void 0) {
          normMean = [255, 255, 255, 255];
        } else {
          if (typeof norm.mean === "number") {
            normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
          } else {
            normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 255];
            if (norm.mean[3] !== void 0) {
              normMean[3] = norm.mean[3];
            }
          }
        }
        if (norm === void 0 || norm.bias === void 0) {
          normBias = [0, 0, 0, 0];
        } else {
          if (typeof norm.bias === "number") {
            normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
          } else {
            normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
            if (norm.bias[3] !== void 0) {
              normBias[3] = norm.bias[3];
            }
          }
        }
        const stride = height * width;
        if (options !== void 0) {
          if (options.format !== void 0 && (channels === 4 && options.format !== "RGBA") || channels === 3 && (options.format !== "RGB" && options.format !== "BGR")) {
            throw new Error("Tensor format doesn't match input tensor dims");
          }
        }
        const step = 4;
        let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
        if (inputformat === "RGBA") {
          rTensorPointer = 0;
          gTensorPointer = stride;
          bTensorPointer = stride * 2;
          aTensorPointer = stride * 3;
        } else if (inputformat === "RGB") {
          rTensorPointer = 0;
          gTensorPointer = stride;
          bTensorPointer = stride * 2;
        } else if (inputformat === "RBG") {
          rTensorPointer = 0;
          bTensorPointer = stride;
          gTensorPointer = stride * 2;
        }
        image = pixels2DContext.createImageData(width, height);
        for (let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++) {
          image.data[rImagePointer] = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
          image.data[gImagePointer] = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
          image.data[bImagePointer] = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
          image.data[aImagePointer] = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
        }
      } else {
        throw new Error("Can not access image data");
      }
      return image;
    };
  }
});

// web/node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js
var bufferToTensor, tensorFromImage, tensorFromTexture, tensorFromGpuBuffer, tensorFromPinnedBuffer;
var init_tensor_factory_impl = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js"() {
    init_tensor_impl();
    bufferToTensor = (buffer, options) => {
      if (buffer === void 0) {
        throw new Error("Image buffer must be defined");
      }
      if (options.height === void 0 || options.width === void 0) {
        throw new Error("Image height and width must be defined");
      }
      if (options.tensorLayout === "NHWC") {
        throw new Error("NHWC Tensor layout is not supported yet");
      }
      const { height, width } = options;
      const norm = options.norm ?? { mean: 255, bias: 0 };
      let normMean;
      let normBias;
      if (typeof norm.mean === "number") {
        normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
      } else {
        normMean = [norm.mean[0], norm.mean[1], norm.mean[2], norm.mean[3] ?? 255];
      }
      if (typeof norm.bias === "number") {
        normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
      } else {
        normBias = [norm.bias[0], norm.bias[1], norm.bias[2], norm.bias[3] ?? 0];
      }
      const inputformat = options.format !== void 0 ? options.format : "RGBA";
      const outputformat = options.tensorFormat !== void 0 ? options.tensorFormat !== void 0 ? options.tensorFormat : "RGB" : "RGB";
      const stride = height * width;
      const float32Data = outputformat === "RGBA" ? new Float32Array(stride * 4) : new Float32Array(stride * 3);
      let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
      let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
      if (inputformat === "RGB") {
        step = 3;
        rImagePointer = 0;
        gImagePointer = 1;
        bImagePointer = 2;
        aImagePointer = -1;
      }
      if (outputformat === "RGBA") {
        aTensorPointer = stride * 3;
      } else if (outputformat === "RBG") {
        rTensorPointer = 0;
        bTensorPointer = stride;
        gTensorPointer = stride * 2;
      } else if (outputformat === "BGR") {
        bTensorPointer = 0;
        gTensorPointer = stride;
        rTensorPointer = stride * 2;
      }
      for (let i = 0; i < stride; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step) {
        float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias[0]) / normMean[0];
        float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias[1]) / normMean[1];
        float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias[2]) / normMean[2];
        if (aTensorPointer !== -1 && aImagePointer !== -1) {
          float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias[3]) / normMean[3];
        }
      }
      const outputTensor = outputformat === "RGBA" ? new Tensor("float32", float32Data, [1, 4, height, width]) : new Tensor("float32", float32Data, [1, 3, height, width]);
      return outputTensor;
    };
    tensorFromImage = async (image, options) => {
      const isHTMLImageEle = typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement;
      const isImageDataEle = typeof ImageData !== "undefined" && image instanceof ImageData;
      const isImageBitmap = typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap;
      const isString = typeof image === "string";
      let data;
      let bufferToTensorOptions = options ?? {};
      const createCanvas = () => {
        if (typeof document !== "undefined") {
          return document.createElement("canvas");
        } else if (typeof OffscreenCanvas !== "undefined") {
          return new OffscreenCanvas(1, 1);
        } else {
          throw new Error("Canvas is not supported");
        }
      };
      const createCanvasContext = (canvas) => {
        if (canvas instanceof HTMLCanvasElement) {
          return canvas.getContext("2d");
        } else if (canvas instanceof OffscreenCanvas) {
          return canvas.getContext("2d");
        } else {
          return null;
        }
      };
      if (isHTMLImageEle) {
        const canvas = createCanvas();
        canvas.width = image.width;
        canvas.height = image.height;
        const pixels2DContext = createCanvasContext(canvas);
        if (pixels2DContext != null) {
          let height = image.height;
          let width = image.width;
          if (options !== void 0 && options.resizedHeight !== void 0 && options.resizedWidth !== void 0) {
            height = options.resizedHeight;
            width = options.resizedWidth;
          }
          if (options !== void 0) {
            bufferToTensorOptions = options;
            if (options.tensorFormat !== void 0) {
              throw new Error("Image input config format must be RGBA for HTMLImageElement");
            } else {
              bufferToTensorOptions.tensorFormat = "RGBA";
            }
            bufferToTensorOptions.height = height;
            bufferToTensorOptions.width = width;
          } else {
            bufferToTensorOptions.tensorFormat = "RGBA";
            bufferToTensorOptions.height = height;
            bufferToTensorOptions.width = width;
          }
          pixels2DContext.drawImage(image, 0, 0);
          data = pixels2DContext.getImageData(0, 0, width, height).data;
        } else {
          throw new Error("Can not access image data");
        }
      } else if (isImageDataEle) {
        let height;
        let width;
        if (options !== void 0 && options.resizedWidth !== void 0 && options.resizedHeight !== void 0) {
          height = options.resizedHeight;
          width = options.resizedWidth;
        } else {
          height = image.height;
          width = image.width;
        }
        if (options !== void 0) {
          bufferToTensorOptions = options;
        }
        bufferToTensorOptions.format = "RGBA";
        bufferToTensorOptions.height = height;
        bufferToTensorOptions.width = width;
        if (options !== void 0) {
          const tempCanvas = createCanvas();
          tempCanvas.width = width;
          tempCanvas.height = height;
          const pixels2DContext = createCanvasContext(tempCanvas);
          if (pixels2DContext != null) {
            pixels2DContext.putImageData(image, 0, 0);
            data = pixels2DContext.getImageData(0, 0, width, height).data;
          } else {
            throw new Error("Can not access image data");
          }
        } else {
          data = image.data;
        }
      } else if (isImageBitmap) {
        if (options === void 0) {
          throw new Error("Please provide image config with format for Imagebitmap");
        }
        const canvas = createCanvas();
        canvas.width = image.width;
        canvas.height = image.height;
        const pixels2DContext = createCanvasContext(canvas);
        if (pixels2DContext != null) {
          const height = image.height;
          const width = image.width;
          pixels2DContext.drawImage(image, 0, 0, width, height);
          data = pixels2DContext.getImageData(0, 0, width, height).data;
          bufferToTensorOptions.height = height;
          bufferToTensorOptions.width = width;
          return bufferToTensor(data, bufferToTensorOptions);
        } else {
          throw new Error("Can not access image data");
        }
      } else if (isString) {
        return new Promise((resolve, reject) => {
          const canvas = createCanvas();
          const context = createCanvasContext(canvas);
          if (!image || !context) {
            return reject();
          }
          const newImage = new Image();
          newImage.crossOrigin = "Anonymous";
          newImage.src = image;
          newImage.onload = () => {
            canvas.width = newImage.width;
            canvas.height = newImage.height;
            context.drawImage(newImage, 0, 0, canvas.width, canvas.height);
            const img = context.getImageData(0, 0, canvas.width, canvas.height);
            bufferToTensorOptions.height = canvas.height;
            bufferToTensorOptions.width = canvas.width;
            resolve(bufferToTensor(img.data, bufferToTensorOptions));
          };
        });
      } else {
        throw new Error("Input data provided is not supported - aborted tensor creation");
      }
      if (data !== void 0) {
        return bufferToTensor(data, bufferToTensorOptions);
      } else {
        throw new Error("Input data provided is not supported - aborted tensor creation");
      }
    };
    tensorFromTexture = (texture, options) => {
      const { width, height, download, dispose } = options;
      const dims = [1, height, width, 4];
      return new Tensor({ location: "texture", type: "float32", texture, dims, download, dispose });
    };
    tensorFromGpuBuffer = (gpuBuffer, options) => {
      const { dataType, dims, download, dispose } = options;
      return new Tensor({ location: "gpu-buffer", type: dataType ?? "float32", gpuBuffer, dims, download, dispose });
    };
    tensorFromPinnedBuffer = (type, buffer, dims) => new Tensor({ location: "cpu-pinned", type, data: buffer, dims: dims ?? [buffer.length] });
  }
});

// web/node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js
var NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP, NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP, isTypedArrayChecked, checkTypedArray;
var init_tensor_impl_type_mapping = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js"() {
    NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = /* @__PURE__ */ new Map([
      ["float32", Float32Array],
      ["uint8", Uint8Array],
      ["int8", Int8Array],
      ["uint16", Uint16Array],
      ["int16", Int16Array],
      ["int32", Int32Array],
      ["bool", Uint8Array],
      ["float64", Float64Array],
      ["uint32", Uint32Array]
    ]);
    NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = /* @__PURE__ */ new Map([
      [Float32Array, "float32"],
      [Uint8Array, "uint8"],
      [Int8Array, "int8"],
      [Uint16Array, "uint16"],
      [Int16Array, "int16"],
      [Int32Array, "int32"],
      [Float64Array, "float64"],
      [Uint32Array, "uint32"]
    ]);
    isTypedArrayChecked = false;
    checkTypedArray = () => {
      if (!isTypedArrayChecked) {
        isTypedArrayChecked = true;
        const isBigInt64ArrayAvailable = typeof BigInt64Array !== "undefined" && BigInt64Array.from;
        const isBigUint64ArrayAvailable = typeof BigUint64Array !== "undefined" && BigUint64Array.from;
        const isFloat16ArrayAvailable = typeof Float16Array !== "undefined" && Float16Array.from;
        if (isBigInt64ArrayAvailable) {
          NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64", BigInt64Array);
          NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, "int64");
        }
        if (isBigUint64ArrayAvailable) {
          NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64", BigUint64Array);
          NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, "uint64");
        }
        if (isFloat16ArrayAvailable) {
          NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Float16Array);
          NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(Float16Array, "float16");
        } else {
          NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Uint16Array);
        }
      }
    };
  }
});

// web/node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js
var calculateSize, tensorReshape;
var init_tensor_utils_impl = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js"() {
    init_tensor_impl();
    calculateSize = (dims) => {
      let size = 1;
      for (let i = 0; i < dims.length; i++) {
        const dim = dims[i];
        if (typeof dim !== "number" || !Number.isSafeInteger(dim)) {
          throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);
        }
        if (dim < 0) {
          throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);
        }
        size *= dim;
      }
      return size;
    };
    tensorReshape = (tensor, dims) => {
      switch (tensor.location) {
        case "cpu":
          return new Tensor(tensor.type, tensor.data, dims);
        case "cpu-pinned":
          return new Tensor({
            location: "cpu-pinned",
            data: tensor.data,
            type: tensor.type,
            dims
          });
        case "texture":
          return new Tensor({
            location: "texture",
            texture: tensor.texture,
            type: tensor.type,
            dims
          });
        case "gpu-buffer":
          return new Tensor({
            location: "gpu-buffer",
            gpuBuffer: tensor.gpuBuffer,
            type: tensor.type,
            dims
          });
        default:
          throw new Error(`tensorReshape: tensor location ${tensor.location} is not supported`);
      }
    };
  }
});

// web/node_modules/onnxruntime-common/dist/esm/tensor-impl.js
var Tensor;
var init_tensor_impl = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/tensor-impl.js"() {
    init_tensor_conversion_impl();
    init_tensor_factory_impl();
    init_tensor_impl_type_mapping();
    init_tensor_utils_impl();
    Tensor = class {
      /**
       * implementation.
       */
      constructor(arg0, arg1, arg2) {
        checkTypedArray();
        let type;
        let dims;
        if (typeof arg0 === "object" && "location" in arg0) {
          this.dataLocation = arg0.location;
          type = arg0.type;
          dims = arg0.dims;
          switch (arg0.location) {
            case "cpu-pinned": {
              const expectedTypedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(type);
              if (!expectedTypedArrayConstructor) {
                throw new TypeError(`unsupported type "${type}" to create tensor from pinned buffer`);
              }
              if (!(arg0.data instanceof expectedTypedArrayConstructor)) {
                throw new TypeError(`buffer should be of type ${expectedTypedArrayConstructor.name}`);
              }
              this.cpuData = arg0.data;
              break;
            }
            case "texture": {
              if (type !== "float32") {
                throw new TypeError(`unsupported type "${type}" to create tensor from texture`);
              }
              this.gpuTextureData = arg0.texture;
              this.downloader = arg0.download;
              this.disposer = arg0.dispose;
              break;
            }
            case "gpu-buffer": {
              if (type !== "float32" && type !== "float16" && type !== "int32" && type !== "int64" && type !== "uint32" && type !== "uint8" && type !== "bool") {
                throw new TypeError(`unsupported type "${type}" to create tensor from gpu buffer`);
              }
              this.gpuBufferData = arg0.gpuBuffer;
              this.downloader = arg0.download;
              this.disposer = arg0.dispose;
              break;
            }
            default:
              throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`);
          }
        } else {
          let data;
          let maybeDims;
          if (typeof arg0 === "string") {
            type = arg0;
            maybeDims = arg2;
            if (arg0 === "string") {
              if (!Array.isArray(arg1)) {
                throw new TypeError("A string tensor's data must be a string array.");
              }
              data = arg1;
            } else {
              const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);
              if (typedArrayConstructor === void 0) {
                throw new TypeError(`Unsupported tensor type: ${arg0}.`);
              }
              if (Array.isArray(arg1)) {
                if (arg0 === "float16" && typedArrayConstructor === Uint16Array) {
                  throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");
                } else if (arg0 === "uint64" || arg0 === "int64") {
                  data = typedArrayConstructor.from(arg1, BigInt);
                } else {
                  data = typedArrayConstructor.from(arg1);
                }
              } else if (arg1 instanceof typedArrayConstructor) {
                data = arg1;
              } else {
                throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);
              }
            }
          } else {
            maybeDims = arg1;
            if (Array.isArray(arg0)) {
              if (arg0.length === 0) {
                throw new TypeError("Tensor type cannot be inferred from an empty array.");
              }
              const firstElementType = typeof arg0[0];
              if (firstElementType === "string") {
                type = "string";
                data = arg0;
              } else if (firstElementType === "boolean") {
                type = "bool";
                data = Uint8Array.from(arg0);
              } else {
                throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);
              }
            } else {
              const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);
              if (mappedType === void 0) {
                throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);
              }
              type = mappedType;
              data = arg0;
            }
          }
          if (maybeDims === void 0) {
            maybeDims = [data.length];
          } else if (!Array.isArray(maybeDims)) {
            throw new TypeError("A tensor's dims must be a number array");
          }
          dims = maybeDims;
          this.cpuData = data;
          this.dataLocation = "cpu";
        }
        const size = calculateSize(dims);
        if (this.cpuData && size !== this.cpuData.length) {
          throw new Error(`Tensor's size(${size}) does not match data length(${this.cpuData.length}).`);
        }
        this.type = type;
        this.dims = dims;
        this.size = size;
      }
      // #endregion
      // #region factory
      static async fromImage(image, options) {
        return tensorFromImage(image, options);
      }
      static fromTexture(texture, options) {
        return tensorFromTexture(texture, options);
      }
      static fromGpuBuffer(gpuBuffer, options) {
        return tensorFromGpuBuffer(gpuBuffer, options);
      }
      static fromPinnedBuffer(type, buffer, dims) {
        return tensorFromPinnedBuffer(type, buffer, dims);
      }
      // #endregion
      // #region conversions
      toDataURL(options) {
        return tensorToDataURL(this, options);
      }
      toImageData(options) {
        return tensorToImageData(this, options);
      }
      // #endregion
      // #region properties
      get data() {
        this.ensureValid();
        if (!this.cpuData) {
          throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");
        }
        return this.cpuData;
      }
      get location() {
        return this.dataLocation;
      }
      get texture() {
        this.ensureValid();
        if (!this.gpuTextureData) {
          throw new Error("The data is not stored as a WebGL texture.");
        }
        return this.gpuTextureData;
      }
      get gpuBuffer() {
        this.ensureValid();
        if (!this.gpuBufferData) {
          throw new Error("The data is not stored as a WebGPU buffer.");
        }
        return this.gpuBufferData;
      }
      // #endregion
      // #region methods
      async getData(releaseData) {
        this.ensureValid();
        switch (this.dataLocation) {
          case "cpu":
          case "cpu-pinned":
            return this.data;
          case "texture":
          case "gpu-buffer": {
            if (!this.downloader) {
              throw new Error("The current tensor is not created with a specified data downloader.");
            }
            if (this.isDownloading) {
              throw new Error("The current tensor is being downloaded.");
            }
            try {
              this.isDownloading = true;
              const data = await this.downloader();
              this.downloader = void 0;
              this.dataLocation = "cpu";
              this.cpuData = data;
              if (releaseData && this.disposer) {
                this.disposer();
                this.disposer = void 0;
              }
              return data;
            } finally {
              this.isDownloading = false;
            }
          }
          default:
            throw new Error(`cannot get data from location: ${this.dataLocation}`);
        }
      }
      dispose() {
        if (this.isDownloading) {
          throw new Error("The current tensor is being downloaded.");
        }
        if (this.disposer) {
          this.disposer();
          this.disposer = void 0;
        }
        this.cpuData = void 0;
        this.gpuTextureData = void 0;
        this.gpuBufferData = void 0;
        this.downloader = void 0;
        this.isDownloading = void 0;
        this.dataLocation = "none";
      }
      // #endregion
      // #region tensor utilities
      ensureValid() {
        if (this.dataLocation === "none") {
          throw new Error("The tensor is disposed.");
        }
      }
      reshape(dims) {
        this.ensureValid();
        if (this.downloader || this.disposer) {
          throw new Error("Cannot reshape a tensor that owns GPU resource.");
        }
        return tensorReshape(this, dims);
      }
    };
  }
});

// web/node_modules/onnxruntime-common/dist/esm/tensor.js
var Tensor2;
var init_tensor = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/tensor.js"() {
    init_tensor_impl();
    Tensor2 = Tensor;
  }
});

// web/node_modules/onnxruntime-common/dist/esm/trace.js
var TRACE, TRACE_FUNC, TRACE_FUNC_BEGIN, TRACE_FUNC_END;
var init_trace = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/trace.js"() {
    init_env_impl();
    TRACE = (deviceType, label) => {
      if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
        return;
      }
      console.timeStamp(`${deviceType}::ORT::${label}`);
    };
    TRACE_FUNC = (msg, extraMsg) => {
      const stack = new Error().stack?.split(/\r\n|\r|\n/g) || [];
      let hasTraceFunc = false;
      for (let i = 0; i < stack.length; i++) {
        if (hasTraceFunc && !stack[i].includes("TRACE_FUNC")) {
          let label = `FUNC_${msg}::${stack[i].trim().split(" ")[1]}`;
          if (extraMsg) {
            label += `::${extraMsg}`;
          }
          TRACE("CPU", label);
          return;
        }
        if (stack[i].includes("TRACE_FUNC")) {
          hasTraceFunc = true;
        }
      }
    };
    TRACE_FUNC_BEGIN = (extraMsg) => {
      if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
        return;
      }
      TRACE_FUNC("BEGIN", extraMsg);
    };
    TRACE_FUNC_END = (extraMsg) => {
      if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
        return;
      }
      TRACE_FUNC("END", extraMsg);
    };
  }
});

// web/node_modules/onnxruntime-common/dist/esm/inference-session-impl.js
var InferenceSession;
var init_inference_session_impl = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/inference-session-impl.js"() {
    init_backend_impl();
    init_tensor();
    init_trace();
    InferenceSession = class _InferenceSession {
      constructor(handler) {
        this.handler = handler;
      }
      async run(feeds, arg1, arg2) {
        TRACE_FUNC_BEGIN();
        const fetches = {};
        let options = {};
        if (typeof feeds !== "object" || feeds === null || feeds instanceof Tensor2 || Array.isArray(feeds)) {
          throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
        }
        let isFetchesEmpty = true;
        if (typeof arg1 === "object") {
          if (arg1 === null) {
            throw new TypeError("Unexpected argument[1]: cannot be null.");
          }
          if (arg1 instanceof Tensor2) {
            throw new TypeError("'fetches' cannot be a Tensor");
          }
          if (Array.isArray(arg1)) {
            if (arg1.length === 0) {
              throw new TypeError("'fetches' cannot be an empty array.");
            }
            isFetchesEmpty = false;
            for (const name of arg1) {
              if (typeof name !== "string") {
                throw new TypeError("'fetches' must be a string array or an object.");
              }
              if (this.outputNames.indexOf(name) === -1) {
                throw new RangeError(`'fetches' contains invalid output name: ${name}.`);
              }
              fetches[name] = null;
            }
            if (typeof arg2 === "object" && arg2 !== null) {
              options = arg2;
            } else if (typeof arg2 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
          } else {
            let isFetches = false;
            const arg1Keys = Object.getOwnPropertyNames(arg1);
            for (const name of this.outputNames) {
              if (arg1Keys.indexOf(name) !== -1) {
                const v = arg1[name];
                if (v === null || v instanceof Tensor2) {
                  isFetches = true;
                  isFetchesEmpty = false;
                  fetches[name] = v;
                }
              }
            }
            if (isFetches) {
              if (typeof arg2 === "object" && arg2 !== null) {
                options = arg2;
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else {
              options = arg1;
            }
          }
        } else if (typeof arg1 !== "undefined") {
          throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
        }
        for (const name of this.inputNames) {
          if (typeof feeds[name] === "undefined") {
            throw new Error(`input '${name}' is missing in 'feeds'.`);
          }
        }
        if (isFetchesEmpty) {
          for (const name of this.outputNames) {
            fetches[name] = null;
          }
        }
        const results = await this.handler.run(feeds, fetches, options);
        const returnValue = {};
        for (const key in results) {
          if (Object.hasOwnProperty.call(results, key)) {
            const result = results[key];
            if (result instanceof Tensor2) {
              returnValue[key] = result;
            } else {
              returnValue[key] = new Tensor2(result.type, result.data, result.dims);
            }
          }
        }
        TRACE_FUNC_END();
        return returnValue;
      }
      async release() {
        return this.handler.dispose();
      }
      static async create(arg0, arg1, arg2, arg3) {
        TRACE_FUNC_BEGIN();
        let filePathOrUint8Array;
        let options = {};
        if (typeof arg0 === "string") {
          filePathOrUint8Array = arg0;
          if (typeof arg1 === "object" && arg1 !== null) {
            options = arg1;
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
        } else if (arg0 instanceof Uint8Array) {
          filePathOrUint8Array = arg0;
          if (typeof arg1 === "object" && arg1 !== null) {
            options = arg1;
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
        } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && arg0 instanceof SharedArrayBuffer) {
          const buffer = arg0;
          let byteOffset = 0;
          let byteLength = arg0.byteLength;
          if (typeof arg1 === "object" && arg1 !== null) {
            options = arg1;
          } else if (typeof arg1 === "number") {
            byteOffset = arg1;
            if (!Number.isSafeInteger(byteOffset)) {
              throw new RangeError("'byteOffset' must be an integer.");
            }
            if (byteOffset < 0 || byteOffset >= buffer.byteLength) {
              throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);
            }
            byteLength = arg0.byteLength - byteOffset;
            if (typeof arg2 === "number") {
              byteLength = arg2;
              if (!Number.isSafeInteger(byteLength)) {
                throw new RangeError("'byteLength' must be an integer.");
              }
              if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {
                throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);
              }
              if (typeof arg3 === "object" && arg3 !== null) {
                options = arg3;
              } else if (typeof arg3 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else if (typeof arg2 !== "undefined") {
              throw new TypeError("'byteLength' must be a number.");
            }
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
          filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);
        } else {
          throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
        }
        const [backend, optionsWithValidatedEPs] = await resolveBackendAndExecutionProviders(options);
        const handler = await backend.createInferenceSessionHandler(filePathOrUint8Array, optionsWithValidatedEPs);
        TRACE_FUNC_END();
        return new _InferenceSession(handler);
      }
      startProfiling() {
        this.handler.startProfiling();
      }
      endProfiling() {
        this.handler.endProfiling();
      }
      get inputNames() {
        return this.handler.inputNames;
      }
      get outputNames() {
        return this.handler.outputNames;
      }
    };
  }
});

// web/node_modules/onnxruntime-common/dist/esm/inference-session.js
var InferenceSession2;
var init_inference_session = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/inference-session.js"() {
    init_inference_session_impl();
    InferenceSession2 = InferenceSession;
  }
});

// web/node_modules/onnxruntime-common/dist/esm/tensor-conversion.js
var init_tensor_conversion = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/tensor-conversion.js"() {
  }
});

// web/node_modules/onnxruntime-common/dist/esm/tensor-factory.js
var init_tensor_factory = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/tensor-factory.js"() {
  }
});

// web/node_modules/onnxruntime-common/dist/esm/onnx-model.js
var init_onnx_model = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/onnx-model.js"() {
  }
});

// web/node_modules/onnxruntime-common/dist/esm/onnx-value.js
var init_onnx_value = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/onnx-value.js"() {
  }
});

// web/node_modules/onnxruntime-common/dist/esm/training-session-impl.js
var noBackendErrMsg, TrainingSession;
var init_training_session_impl = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/training-session-impl.js"() {
    init_backend_impl();
    init_tensor();
    noBackendErrMsg = "Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.";
    TrainingSession = class _TrainingSession {
      constructor(handler, hasOptimizerModel, hasEvalModel) {
        this.handler = handler;
        this.hasOptimizerModel = hasOptimizerModel;
        this.hasEvalModel = hasEvalModel;
      }
      get trainingInputNames() {
        return this.handler.inputNames;
      }
      get trainingOutputNames() {
        return this.handler.outputNames;
      }
      get evalInputNames() {
        if (this.hasEvalModel) {
          return this.handler.evalInputNames;
        } else {
          throw new Error("This training session has no evalModel loaded.");
        }
      }
      get evalOutputNames() {
        if (this.hasEvalModel) {
          return this.handler.evalOutputNames;
        } else {
          throw new Error("This training session has no evalModel loaded.");
        }
      }
      static async create(trainingOptions, sessionOptions) {
        const evalModel = trainingOptions.evalModel || "";
        const optimizerModel = trainingOptions.optimizerModel || "";
        const options = sessionOptions || {};
        const [backend, optionsWithValidatedEPs] = await resolveBackendAndExecutionProviders(options);
        if (backend.createTrainingSessionHandler) {
          const handler = await backend.createTrainingSessionHandler(trainingOptions.checkpointState, trainingOptions.trainModel, evalModel, optimizerModel, optionsWithValidatedEPs);
          return new _TrainingSession(handler, !!trainingOptions.optimizerModel, !!trainingOptions.evalModel);
        } else {
          throw new Error(noBackendErrMsg);
        }
      }
      /**
       * Helper function for runTrainStep and future runStep methods that handles the type-narrowing conversion from
       * the given parameters to SessionHandler.FetchesType and RunOptions.
       *
       * @param inputNames the feeds object is checked that they contain all input names in the provided list of input
       * names.
       * @param outputNames the fetches object is checked that their keys match up with valid names in the list of output
       * names.
       * @param feeds the required input
       * @param arg1 narrowed & converted into the SessionHandler.FetchesType or RunOptions object
       * @param arg2 optional RunOptions object.
       * @returns
       */
      typeNarrowingForRunStep(inputNames, outputNames, feeds, arg1, arg2) {
        const fetches = {};
        let options = {};
        if (typeof feeds !== "object" || feeds === null || feeds instanceof Tensor2 || Array.isArray(feeds)) {
          throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
        }
        let isFetchesEmpty = true;
        if (typeof arg1 === "object") {
          if (arg1 === null) {
            throw new TypeError("Unexpected argument[1]: cannot be null.");
          }
          if (arg1 instanceof Tensor2) {
            throw new TypeError("'fetches' cannot be a Tensor");
          }
          if (Array.isArray(arg1)) {
            if (arg1.length === 0) {
              throw new TypeError("'fetches' cannot be an empty array.");
            }
            isFetchesEmpty = false;
            for (const name of arg1) {
              if (typeof name !== "string") {
                throw new TypeError("'fetches' must be a string array or an object.");
              }
              if (outputNames.indexOf(name) === -1) {
                throw new RangeError(`'fetches' contains invalid output name: ${name}.`);
              }
              fetches[name] = null;
            }
            if (typeof arg2 === "object" && arg2 !== null) {
              options = arg2;
            } else if (typeof arg2 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
          } else {
            let isFetches = false;
            const arg1Keys = Object.getOwnPropertyNames(arg1);
            for (const name of outputNames) {
              if (arg1Keys.indexOf(name) !== -1) {
                const v = arg1[name];
                if (v === null || v instanceof Tensor2) {
                  isFetches = true;
                  isFetchesEmpty = false;
                  fetches[name] = v;
                }
              }
            }
            if (isFetches) {
              if (typeof arg2 === "object" && arg2 !== null) {
                options = arg2;
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else {
              options = arg1;
            }
          }
        } else if (typeof arg1 !== "undefined") {
          throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
        }
        for (const name of inputNames) {
          if (typeof feeds[name] === "undefined") {
            throw new Error(`input '${name}' is missing in 'feeds'.`);
          }
        }
        if (isFetchesEmpty) {
          for (const name of outputNames) {
            fetches[name] = null;
          }
        }
        return [fetches, options];
      }
      /**
       * Helper method for runTrainStep and any other runStep methods. Takes the ReturnType result from the SessionHandler
       * and changes it into a map of Tensors.
       *
       * @param results
       * @returns
       */
      convertHandlerReturnTypeToMapOfTensors(results) {
        const returnValue = {};
        for (const key in results) {
          if (Object.hasOwnProperty.call(results, key)) {
            const result = results[key];
            if (result instanceof Tensor2) {
              returnValue[key] = result;
            } else {
              returnValue[key] = new Tensor2(result.type, result.data, result.dims);
            }
          }
        }
        return returnValue;
      }
      async lazyResetGrad() {
        await this.handler.lazyResetGrad();
      }
      async runTrainStep(feeds, arg1, arg2) {
        const [fetches, options] = this.typeNarrowingForRunStep(this.trainingInputNames, this.trainingOutputNames, feeds, arg1, arg2);
        const results = await this.handler.runTrainStep(feeds, fetches, options);
        return this.convertHandlerReturnTypeToMapOfTensors(results);
      }
      async runOptimizerStep(options) {
        if (this.hasOptimizerModel) {
          await this.handler.runOptimizerStep(options || {});
        } else {
          throw new Error("This TrainingSession has no OptimizerModel loaded.");
        }
      }
      async runEvalStep(feeds, arg1, arg2) {
        if (this.hasEvalModel) {
          const [fetches, options] = this.typeNarrowingForRunStep(this.evalInputNames, this.evalOutputNames, feeds, arg1, arg2);
          const results = await this.handler.runEvalStep(feeds, fetches, options);
          return this.convertHandlerReturnTypeToMapOfTensors(results);
        } else {
          throw new Error("This TrainingSession has no EvalModel loaded.");
        }
      }
      async getParametersSize(trainableOnly = true) {
        return this.handler.getParametersSize(trainableOnly);
      }
      async loadParametersBuffer(array, trainableOnly = true) {
        const paramsSize = await this.getParametersSize(trainableOnly);
        if (array.length !== 4 * paramsSize) {
          throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");
        }
        return this.handler.loadParametersBuffer(array, trainableOnly);
      }
      async getContiguousParameters(trainableOnly = true) {
        return this.handler.getContiguousParameters(trainableOnly);
      }
      async release() {
        return this.handler.dispose();
      }
    };
  }
});

// web/node_modules/onnxruntime-common/dist/esm/training-session.js
var TrainingSession2;
var init_training_session = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/training-session.js"() {
    init_training_session_impl();
    TrainingSession2 = TrainingSession;
  }
});

// web/node_modules/onnxruntime-common/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  InferenceSession: () => InferenceSession2,
  TRACE: () => TRACE,
  TRACE_FUNC_BEGIN: () => TRACE_FUNC_BEGIN,
  TRACE_FUNC_END: () => TRACE_FUNC_END,
  Tensor: () => Tensor2,
  TrainingSession: () => TrainingSession2,
  env: () => env2,
  registerBackend: () => registerBackend
});
var init_esm = __esm({
  "web/node_modules/onnxruntime-common/dist/esm/index.js"() {
    init_backend();
    init_env();
    init_inference_session();
    init_tensor();
    init_tensor_conversion();
    init_tensor_factory();
    init_trace();
    init_onnx_model();
    init_onnx_value();
    init_training_session();
  }
});

// web/lib/wasm/wasm-utils-env.ts
var isNode;
var init_wasm_utils_env = __esm({
  "web/lib/wasm/wasm-utils-env.ts"() {
    "use strict";
    isNode = false;
  }
});

// web/lib/wasm/proxy-worker/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => main_default
});
var WORKER_NAME, isProxyWorker, main_default;
var init_main = __esm({
  "web/lib/wasm/proxy-worker/main.ts"() {
    "use strict";
    init_wasm_core_impl();
    init_wasm_factory();
    init_wasm_utils_import();
    WORKER_NAME = "ort-wasm-proxy-worker";
    isProxyWorker = globalThis.self?.name === WORKER_NAME;
    if (isProxyWorker) {
      self.onmessage = (ev) => {
        const { type, in: message } = ev.data;
        try {
          switch (type) {
            case "init-wasm":
              initializeWebAssembly(message.wasm).then(
                () => {
                  initRuntime(message).then(
                    () => {
                      postMessage({ type });
                    },
                    (err) => {
                      postMessage({ type, err });
                    }
                  );
                },
                (err) => {
                  postMessage({ type, err });
                }
              );
              break;
            case "init-ep": {
              const { epName, env: env3 } = message;
              initEp(env3, epName).then(
                () => {
                  postMessage({ type });
                },
                (err) => {
                  postMessage({ type, err });
                }
              );
              break;
            }
            case "copy-from": {
              const { buffer } = message;
              const bufferData = copyFromExternalBuffer(buffer);
              postMessage({ type, out: bufferData });
              break;
            }
            case "create": {
              const { model, options } = message;
              createSession(model, options).then(
                (sessionMetadata) => {
                  postMessage({ type, out: sessionMetadata });
                },
                (err) => {
                  postMessage({ type, err });
                }
              );
              break;
            }
            case "release":
              releaseSession(message);
              postMessage({ type });
              break;
            case "run": {
              const { sessionId, inputIndices, inputs, outputIndices, options } = message;
              run(sessionId, inputIndices, inputs, outputIndices, new Array(outputIndices.length).fill(null), options).then(
                (outputs) => {
                  if (outputs.some((o) => o[3] !== "cpu")) {
                    postMessage({ type, err: "Proxy does not support non-cpu tensor location." });
                  } else {
                    postMessage(
                      { type, out: outputs },
                      extractTransferableBuffers([...inputs, ...outputs])
                    );
                  }
                },
                (err) => {
                  postMessage({ type, err });
                }
              );
              break;
            }
            case "end-profiling":
              endProfiling(message);
              postMessage({ type });
              break;
            default:
          }
        } catch (err) {
          postMessage({ type, err });
        }
      };
    }
    main_default = isProxyWorker ? null : (urlOverride) => new Worker(urlOverride ?? scriptSrc, { type: true ? "module" : "classic", name: WORKER_NAME });
  }
});

// web/lib/wasm/wasm-utils-import.ts
var scriptSrc, origin, isSameOrigin, normalizeUrl, fallbackUrl, preload, dynamicImportDefault, createProxyWorker, importProxyWorker, importWasmModule;
var init_wasm_utils_import = __esm({
  "web/lib/wasm/wasm-utils-import.ts"() {
    "use strict";
    init_wasm_utils_env();
    scriptSrc = // if Nodejs, return undefined
    isNode ? void 0 : (
      // if It's ESM, use import.meta.url
      import.meta.url ?? // use `document.currentScript.src` if available
      (typeof document !== "undefined" ? document.currentScript?.src : (
        // use `self.location.href` if available
        typeof self !== "undefined" ? self.location?.href : void 0
      ))
    );
    origin = isNode || typeof location === "undefined" ? void 0 : location.origin;
    isSameOrigin = (filename, prefixOverride) => {
      try {
        const baseUrl = prefixOverride ?? scriptSrc;
        const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);
        return url.origin === origin;
      } catch {
        return false;
      }
    };
    normalizeUrl = (filename, prefixOverride) => {
      const baseUrl = prefixOverride ?? scriptSrc;
      try {
        const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);
        return url.href;
      } catch {
        return void 0;
      }
    };
    fallbackUrl = (filename, prefixOverride) => `${prefixOverride ?? "./"}${filename}`;
    preload = async (absoluteUrl) => {
      const response = await fetch(absoluteUrl, { credentials: "same-origin" });
      const blob = await response.blob();
      return URL.createObjectURL(blob);
    };
    dynamicImportDefault = async (url) => (await import(
      /* webpackIgnore: true */
      url
    )).default;
    createProxyWorker = // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
    false ? void 0 : (init_main(), __toCommonJS(main_exports)).default;
    importProxyWorker = async () => {
      if (!scriptSrc) {
        throw new Error("Failed to load proxy worker: cannot determine the script source URL.");
      }
      if (isSameOrigin(scriptSrc)) {
        return [void 0, createProxyWorker()];
      }
      const url = await preload(scriptSrc);
      return [url, createProxyWorker(url)];
    };
    importWasmModule = async (urlOverride, prefixOverride, isMultiThreaded) => {
      const wasmModuleFilename = false ? "ort-training-wasm-simd-threaded.mjs" : true ? "ort-wasm-simd-threaded.jsep.mjs" : "ort-wasm-simd-threaded.mjs";
      const wasmModuleUrl = urlOverride ?? normalizeUrl(wasmModuleFilename, prefixOverride);
      const needPreload = !isNode && isMultiThreaded && wasmModuleUrl && !isSameOrigin(wasmModuleUrl, prefixOverride);
      const url = needPreload ? await preload(wasmModuleUrl) : wasmModuleUrl ?? fallbackUrl(wasmModuleFilename, prefixOverride);
      return [needPreload ? url : void 0, await dynamicImportDefault(url)];
    };
  }
});

// web/lib/wasm/wasm-factory.ts
var wasm, initialized, initializing, aborted, isMultiThreadSupported, isSimdSupported, initializeWebAssembly, getInstance;
var init_wasm_factory = __esm({
  "web/lib/wasm/wasm-factory.ts"() {
    "use strict";
    init_wasm_utils_import();
    initialized = false;
    initializing = false;
    aborted = false;
    isMultiThreadSupported = () => {
      if (typeof SharedArrayBuffer === "undefined") {
        return false;
      }
      try {
        if (typeof MessageChannel !== "undefined") {
          new MessageChannel().port1.postMessage(new SharedArrayBuffer(1));
        }
        return WebAssembly.validate(new Uint8Array([
          0,
          97,
          115,
          109,
          1,
          0,
          0,
          0,
          1,
          4,
          1,
          96,
          0,
          0,
          3,
          2,
          1,
          0,
          5,
          4,
          1,
          3,
          1,
          1,
          10,
          11,
          1,
          9,
          0,
          65,
          0,
          254,
          16,
          2,
          0,
          26,
          11
        ]));
      } catch (e) {
        return false;
      }
    };
    isSimdSupported = () => {
      try {
        return WebAssembly.validate(new Uint8Array([
          0,
          97,
          115,
          109,
          1,
          0,
          0,
          0,
          1,
          4,
          1,
          96,
          0,
          0,
          3,
          2,
          1,
          0,
          10,
          30,
          1,
          28,
          0,
          65,
          0,
          253,
          15,
          253,
          12,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          253,
          186,
          1,
          26,
          11
        ]));
      } catch (e) {
        return false;
      }
    };
    initializeWebAssembly = async (flags) => {
      if (initialized) {
        return Promise.resolve();
      }
      if (initializing) {
        throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
      }
      if (aborted) {
        throw new Error("previous call to 'initializeWebAssembly()' failed.");
      }
      initializing = true;
      const timeout = flags.initTimeout;
      let numThreads = flags.numThreads;
      if (!isSimdSupported()) {
        throw new Error("WebAssembly SIMD is not supported in the current environment.");
      }
      const multiThreadSupported = isMultiThreadSupported();
      if (numThreads > 1 && !multiThreadSupported) {
        if (typeof self !== "undefined" && !self.crossOriginIsolated) {
          console.warn(
            "env.wasm.numThreads is set to " + numThreads + ", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."
          );
        }
        console.warn(
          "WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."
        );
        flags.numThreads = numThreads = 1;
      }
      const wasmPaths = flags.wasmPaths;
      const wasmPrefixOverride = typeof wasmPaths === "string" ? wasmPaths : void 0;
      const mjsPathOverrideFlag = wasmPaths?.mjs;
      const mjsPathOverride = mjsPathOverrideFlag?.href ?? mjsPathOverrideFlag;
      const wasmPathOverrideFlag = wasmPaths?.wasm;
      const wasmPathOverride = wasmPathOverrideFlag?.href ?? wasmPathOverrideFlag;
      const [objectUrl, ortWasmFactory] = await importWasmModule(mjsPathOverride, wasmPrefixOverride, numThreads > 1);
      let isTimeout = false;
      const tasks = [];
      if (timeout > 0) {
        tasks.push(new Promise((resolve) => {
          setTimeout(() => {
            isTimeout = true;
            resolve();
          }, timeout);
        }));
      }
      tasks.push(new Promise((resolve, reject) => {
        const config = {
          /**
           * The number of threads. WebAssembly will create (Module.numThreads - 1) workers. If it is 1, no worker will be
           * created.
           */
          numThreads,
          /**
           * A callback function to locate the WebAssembly file. The function should return the full path of the file.
           *
           * Since Emscripten 3.1.58, this function is only called for the .wasm file.
           */
          locateFile: (fileName, scriptDirectory) => wasmPathOverride ?? (wasmPrefixOverride ?? scriptDirectory) + fileName
        };
        ortWasmFactory(config).then(
          // wasm module initialized successfully
          (module) => {
            initializing = false;
            initialized = true;
            wasm = module;
            resolve();
            if (objectUrl) {
              URL.revokeObjectURL(objectUrl);
            }
          },
          // wasm module failed to initialize
          (what) => {
            initializing = false;
            aborted = true;
            reject(what);
          }
        );
      }));
      await Promise.race(tasks);
      if (isTimeout) {
        throw new Error(`WebAssembly backend initializing failed due to timeout: ${timeout}ms`);
      }
    };
    getInstance = () => {
      if (initialized && wasm) {
        return wasm;
      }
      throw new Error("WebAssembly is not initialized yet.");
    };
  }
});

// web/lib/wasm/wasm-utils.ts
var allocWasmString, iterateExtraOptions, checkLastError;
var init_wasm_utils = __esm({
  "web/lib/wasm/wasm-utils.ts"() {
    "use strict";
    init_wasm_factory();
    allocWasmString = (data, allocs) => {
      const wasm2 = getInstance();
      const dataLength = wasm2.lengthBytesUTF8(data) + 1;
      const dataOffset = wasm2._malloc(dataLength);
      wasm2.stringToUTF8(data, dataOffset, dataLength);
      allocs.push(dataOffset);
      return dataOffset;
    };
    iterateExtraOptions = (options, prefix, seen, handler) => {
      if (typeof options == "object" && options !== null) {
        if (seen.has(options)) {
          throw new Error("Circular reference in options");
        } else {
          seen.add(options);
        }
      }
      Object.entries(options).forEach(([key, value]) => {
        const name = prefix ? prefix + key : key;
        if (typeof value === "object") {
          iterateExtraOptions(value, name + ".", seen, handler);
        } else if (typeof value === "string" || typeof value === "number") {
          handler(name, value.toString());
        } else if (typeof value === "boolean") {
          handler(name, value ? "1" : "0");
        } else {
          throw new Error(`Can't handle extra config type: ${typeof value}`);
        }
      });
    };
    checkLastError = (message) => {
      const wasm2 = getInstance();
      const stack = wasm2.stackSave();
      try {
        const paramsOffset = wasm2.stackAlloc(8);
        wasm2._OrtGetLastError(paramsOffset, paramsOffset + 4);
        const errorCode = wasm2.HEAP32[paramsOffset / 4];
        const errorMessagePointer = wasm2.HEAPU32[paramsOffset / 4 + 1];
        const errorMessage = errorMessagePointer ? wasm2.UTF8ToString(errorMessagePointer) : "";
        throw new Error(`${message} ERROR_CODE: ${errorCode}, ERROR_MESSAGE: ${errorMessage}`);
      } finally {
        wasm2.stackRestore(stack);
      }
    };
  }
});

// web/lib/wasm/run-options.ts
var setRunOptions;
var init_run_options = __esm({
  "web/lib/wasm/run-options.ts"() {
    "use strict";
    init_wasm_factory();
    init_wasm_utils();
    setRunOptions = (options) => {
      const wasm2 = getInstance();
      let runOptionsHandle = 0;
      const allocs = [];
      const runOptions = options || {};
      try {
        if (options?.logSeverityLevel === void 0) {
          runOptions.logSeverityLevel = 2;
        } else if (typeof options.logSeverityLevel !== "number" || !Number.isInteger(options.logSeverityLevel) || options.logSeverityLevel < 0 || options.logSeverityLevel > 4) {
          throw new Error(`log serverity level is not valid: ${options.logSeverityLevel}`);
        }
        if (options?.logVerbosityLevel === void 0) {
          runOptions.logVerbosityLevel = 0;
        } else if (typeof options.logVerbosityLevel !== "number" || !Number.isInteger(options.logVerbosityLevel)) {
          throw new Error(`log verbosity level is not valid: ${options.logVerbosityLevel}`);
        }
        if (options?.terminate === void 0) {
          runOptions.terminate = false;
        }
        let tagDataOffset = 0;
        if (options?.tag !== void 0) {
          tagDataOffset = allocWasmString(options.tag, allocs);
        }
        runOptionsHandle = wasm2._OrtCreateRunOptions(
          runOptions.logSeverityLevel,
          runOptions.logVerbosityLevel,
          !!runOptions.terminate,
          tagDataOffset
        );
        if (runOptionsHandle === 0) {
          checkLastError("Can't create run options.");
        }
        if (options?.extra !== void 0) {
          iterateExtraOptions(options.extra, "", /* @__PURE__ */ new WeakSet(), (key, value) => {
            const keyDataOffset = allocWasmString(key, allocs);
            const valueDataOffset = allocWasmString(value, allocs);
            if (wasm2._OrtAddRunConfigEntry(runOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
              checkLastError(`Can't set a run config entry: ${key} - ${value}.`);
            }
          });
        }
        return [runOptionsHandle, allocs];
      } catch (e) {
        if (runOptionsHandle !== 0) {
          wasm2._OrtReleaseRunOptions(runOptionsHandle);
        }
        allocs.forEach((alloc) => wasm2._free(alloc));
        throw e;
      }
    };
  }
});

// web/lib/wasm/session-options.ts
var getGraphOptimzationLevel, getExecutionMode, appendDefaultOptions, setExecutionProviders, setSessionOptions;
var init_session_options = __esm({
  "web/lib/wasm/session-options.ts"() {
    "use strict";
    init_wasm_factory();
    init_wasm_utils();
    getGraphOptimzationLevel = (graphOptimizationLevel) => {
      switch (graphOptimizationLevel) {
        case "disabled":
          return 0;
        case "basic":
          return 1;
        case "extended":
          return 2;
        case "all":
          return 99;
        default:
          throw new Error(`unsupported graph optimization level: ${graphOptimizationLevel}`);
      }
    };
    getExecutionMode = (executionMode) => {
      switch (executionMode) {
        case "sequential":
          return 0;
        case "parallel":
          return 1;
        default:
          throw new Error(`unsupported execution mode: ${executionMode}`);
      }
    };
    appendDefaultOptions = (options) => {
      if (!options.extra) {
        options.extra = {};
      }
      if (!options.extra.session) {
        options.extra.session = {};
      }
      const session = options.extra.session;
      if (!session.use_ort_model_bytes_directly) {
        session.use_ort_model_bytes_directly = "1";
      }
      if (options.executionProviders && options.executionProviders.some((ep) => (typeof ep === "string" ? ep : ep.name) === "webgpu")) {
        options.enableMemPattern = false;
      }
    };
    setExecutionProviders = (sessionOptionsHandle, executionProviders, allocs) => {
      for (const ep of executionProviders) {
        let epName = typeof ep === "string" ? ep : ep.name;
        switch (epName) {
          case "webnn":
            epName = "WEBNN";
            if (typeof ep !== "string") {
              const webnnOptions = ep;
              const deviceType = webnnOptions?.deviceType;
              const numThreads = webnnOptions?.numThreads;
              const powerPreference = webnnOptions?.powerPreference;
              if (deviceType) {
                const keyDataOffset = allocWasmString("deviceType", allocs);
                const valueDataOffset = allocWasmString(deviceType, allocs);
                if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                  checkLastError(`Can't set a session config entry: 'deviceType' - ${deviceType}.`);
                }
              }
              if (numThreads !== void 0) {
                const validatedNumThreads = typeof numThreads !== "number" || !Number.isInteger(numThreads) || numThreads < 0 ? 0 : numThreads;
                const keyDataOffset = allocWasmString("numThreads", allocs);
                const valueDataOffset = allocWasmString(validatedNumThreads.toString(), allocs);
                if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                  checkLastError(`Can't set a session config entry: 'numThreads' - ${numThreads}.`);
                }
              }
              if (powerPreference) {
                const keyDataOffset = allocWasmString("powerPreference", allocs);
                const valueDataOffset = allocWasmString(powerPreference, allocs);
                if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                  checkLastError(`Can't set a session config entry: 'powerPreference' - ${powerPreference}.`);
                }
              }
            }
            break;
          case "webgpu":
            epName = "JS";
            if (typeof ep !== "string") {
              const webgpuOptions = ep;
              if (webgpuOptions?.preferredLayout) {
                if (webgpuOptions.preferredLayout !== "NCHW" && webgpuOptions.preferredLayout !== "NHWC") {
                  throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${webgpuOptions.preferredLayout}`);
                }
                const keyDataOffset = allocWasmString("preferredLayout", allocs);
                const valueDataOffset = allocWasmString(webgpuOptions.preferredLayout, allocs);
                if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                  checkLastError(
                    `Can't set a session config entry: 'preferredLayout' - ${webgpuOptions.preferredLayout}.`
                  );
                }
              }
            }
            break;
          case "wasm":
          case "cpu":
            continue;
          default:
            throw new Error(`not supported execution provider: ${epName}`);
        }
        const epNameDataOffset = allocWasmString(epName, allocs);
        if (getInstance()._OrtAppendExecutionProvider(sessionOptionsHandle, epNameDataOffset) !== 0) {
          checkLastError(`Can't append execution provider: ${epName}.`);
        }
      }
    };
    setSessionOptions = (options) => {
      const wasm2 = getInstance();
      let sessionOptionsHandle = 0;
      const allocs = [];
      const sessionOptions = options || {};
      appendDefaultOptions(sessionOptions);
      try {
        const graphOptimizationLevel = getGraphOptimzationLevel(sessionOptions.graphOptimizationLevel ?? "all");
        const executionMode = getExecutionMode(sessionOptions.executionMode ?? "sequential");
        const logIdDataOffset = typeof sessionOptions.logId === "string" ? allocWasmString(sessionOptions.logId, allocs) : 0;
        const logSeverityLevel = sessionOptions.logSeverityLevel ?? 2;
        if (!Number.isInteger(logSeverityLevel) || logSeverityLevel < 0 || logSeverityLevel > 4) {
          throw new Error(`log serverity level is not valid: ${logSeverityLevel}`);
        }
        const logVerbosityLevel = sessionOptions.logVerbosityLevel ?? 0;
        if (!Number.isInteger(logVerbosityLevel) || logVerbosityLevel < 0 || logVerbosityLevel > 4) {
          throw new Error(`log verbosity level is not valid: ${logVerbosityLevel}`);
        }
        const optimizedModelFilePathOffset = typeof sessionOptions.optimizedModelFilePath === "string" ? allocWasmString(sessionOptions.optimizedModelFilePath, allocs) : 0;
        sessionOptionsHandle = wasm2._OrtCreateSessionOptions(
          graphOptimizationLevel,
          !!sessionOptions.enableCpuMemArena,
          !!sessionOptions.enableMemPattern,
          executionMode,
          !!sessionOptions.enableProfiling,
          0,
          logIdDataOffset,
          logSeverityLevel,
          logVerbosityLevel,
          optimizedModelFilePathOffset
        );
        if (sessionOptionsHandle === 0) {
          checkLastError("Can't create session options.");
        }
        if (sessionOptions.executionProviders) {
          setExecutionProviders(sessionOptionsHandle, sessionOptions.executionProviders, allocs);
        }
        if (sessionOptions.enableGraphCapture !== void 0) {
          if (typeof sessionOptions.enableGraphCapture !== "boolean") {
            throw new Error(`enableGraphCapture must be a boolean value: ${sessionOptions.enableGraphCapture}`);
          }
          const keyDataOffset = allocWasmString("enableGraphCapture", allocs);
          const valueDataOffset = allocWasmString(sessionOptions.enableGraphCapture.toString(), allocs);
          if (wasm2._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
            checkLastError(
              `Can't set a session config entry: 'enableGraphCapture' - ${sessionOptions.enableGraphCapture}.`
            );
          }
        }
        if (sessionOptions.freeDimensionOverrides) {
          for (const [name, value] of Object.entries(sessionOptions.freeDimensionOverrides)) {
            if (typeof name !== "string") {
              throw new Error(`free dimension override name must be a string: ${name}`);
            }
            if (typeof value !== "number" || !Number.isInteger(value) || value < 0) {
              throw new Error(`free dimension override value must be a non-negative integer: ${value}`);
            }
            const nameOffset = allocWasmString(name, allocs);
            if (wasm2._OrtAddFreeDimensionOverride(sessionOptionsHandle, nameOffset, value) !== 0) {
              checkLastError(`Can't set a free dimension override: ${name} - ${value}.`);
            }
          }
        }
        if (sessionOptions.extra !== void 0) {
          iterateExtraOptions(sessionOptions.extra, "", /* @__PURE__ */ new WeakSet(), (key, value) => {
            const keyDataOffset = allocWasmString(key, allocs);
            const valueDataOffset = allocWasmString(value, allocs);
            if (wasm2._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
              checkLastError(`Can't set a session config entry: ${key} - ${value}.`);
            }
          });
        }
        return [sessionOptionsHandle, allocs];
      } catch (e) {
        if (sessionOptionsHandle !== 0) {
          wasm2._OrtReleaseSessionOptions(sessionOptionsHandle);
        }
        allocs.forEach((alloc) => wasm2._free(alloc));
        throw e;
      }
    };
  }
});

// web/lib/wasm/wasm-common.ts
var tensorDataTypeStringToEnum, tensorDataTypeEnumToString, getTensorElementSize, tensorTypeToTypedArrayConstructor, logLevelStringToEnum, isGpuBufferSupportedType, dataLocationStringToEnum;
var init_wasm_common = __esm({
  "web/lib/wasm/wasm-common.ts"() {
    "use strict";
    tensorDataTypeStringToEnum = (type) => {
      switch (type) {
        case "int8":
          return 3 /* int8 */;
        case "uint8":
          return 2 /* uint8 */;
        case "bool":
          return 9 /* bool */;
        case "int16":
          return 5 /* int16 */;
        case "uint16":
          return 4 /* uint16 */;
        case "int32":
          return 6 /* int32 */;
        case "uint32":
          return 12 /* uint32 */;
        case "float16":
          return 10 /* float16 */;
        case "float32":
          return 1 /* float */;
        case "float64":
          return 11 /* double */;
        case "string":
          return 8 /* string */;
        case "int64":
          return 7 /* int64 */;
        case "uint64":
          return 13 /* uint64 */;
        default:
          throw new Error(`unsupported data type: ${type}`);
      }
    };
    tensorDataTypeEnumToString = (typeProto) => {
      switch (typeProto) {
        case 3 /* int8 */:
          return "int8";
        case 2 /* uint8 */:
          return "uint8";
        case 9 /* bool */:
          return "bool";
        case 5 /* int16 */:
          return "int16";
        case 4 /* uint16 */:
          return "uint16";
        case 6 /* int32 */:
          return "int32";
        case 12 /* uint32 */:
          return "uint32";
        case 10 /* float16 */:
          return "float16";
        case 1 /* float */:
          return "float32";
        case 11 /* double */:
          return "float64";
        case 8 /* string */:
          return "string";
        case 7 /* int64 */:
          return "int64";
        case 13 /* uint64 */:
          return "uint64";
        default:
          throw new Error(`unsupported data type: ${typeProto}`);
      }
    };
    getTensorElementSize = (dateType) => [void 0, 4, 1, 1, 2, 2, 4, 8, void 0, 1, 2, 8, 4, 8, void 0, void 0, void 0][dateType];
    tensorTypeToTypedArrayConstructor = (type) => {
      switch (type) {
        case "float16":
          return typeof Float16Array !== "undefined" && Float16Array.from ? Float16Array : Uint16Array;
        case "float32":
          return Float32Array;
        case "uint8":
          return Uint8Array;
        case "int8":
          return Int8Array;
        case "uint16":
          return Uint16Array;
        case "int16":
          return Int16Array;
        case "int32":
          return Int32Array;
        case "bool":
          return Uint8Array;
        case "float64":
          return Float64Array;
        case "uint32":
          return Uint32Array;
        case "int64":
          return BigInt64Array;
        case "uint64":
          return BigUint64Array;
        default:
          throw new Error(`unsupported type: ${type}`);
      }
    };
    logLevelStringToEnum = (logLevel) => {
      switch (logLevel) {
        case "verbose":
          return 0;
        case "info":
          return 1;
        case "warning":
          return 2;
        case "error":
          return 3;
        case "fatal":
          return 4;
        default:
          throw new Error(`unsupported logging level: ${logLevel}`);
      }
    };
    isGpuBufferSupportedType = (type) => type === "float32" || type === "float16" || type === "int32" || type === "int64" || type === "uint32" || type === "uint8" || type === "bool";
    dataLocationStringToEnum = (location2) => {
      switch (location2) {
        case "none":
          return 0;
        case "cpu":
          return 1;
        case "cpu-pinned":
          return 2;
        case "texture":
          return 3;
        case "gpu-buffer":
          return 4;
        default:
          throw new Error(`unsupported data location: ${location2}`);
      }
    };
  }
});

// web/lib/wasm/wasm-utils-load-file.ts
var loadFile;
var init_wasm_utils_load_file = __esm({
  "web/lib/wasm/wasm-utils-load-file.ts"() {
    "use strict";
    init_wasm_utils_env();
    loadFile = async (file) => {
      if (typeof file === "string") {
        if (isNode) {
          try {
            const { readFile } = __require("node:fs/promises");
            return new Uint8Array(await readFile(file));
          } catch (e) {
            if (e.code === "ERR_FS_FILE_TOO_LARGE") {
              const { createReadStream } = __require("node:fs");
              const stream = createReadStream(file);
              const chunks = [];
              for await (const chunk of stream) {
                chunks.push(chunk);
              }
              return new Uint8Array(Buffer.concat(chunks));
            }
            throw e;
          }
        } else {
          const response = await fetch(file);
          if (!response.ok) {
            throw new Error(`failed to load external data file: ${file}`);
          }
          const contentLengthHeader = response.headers.get("Content-Length");
          const fileSize = contentLengthHeader ? parseInt(contentLengthHeader, 10) : 0;
          if (fileSize < 1073741824) {
            return new Uint8Array(await response.arrayBuffer());
          } else {
            if (!response.body) {
              throw new Error(`failed to load external data file: ${file}, no response body.`);
            }
            const reader = response.body.getReader();
            let buffer;
            try {
              buffer = new ArrayBuffer(fileSize);
            } catch (e) {
              if (e instanceof RangeError) {
                const pages = Math.ceil(fileSize / 65536);
                buffer = new WebAssembly.Memory({ initial: pages, maximum: pages }).buffer;
              } else {
                throw e;
              }
            }
            let offset = 0;
            while (true) {
              const { done, value } = await reader.read();
              if (done) {
                break;
              }
              const chunkSize = value.byteLength;
              const chunk = new Uint8Array(buffer, offset, chunkSize);
              chunk.set(value);
              offset += chunkSize;
            }
            return new Uint8Array(buffer, 0, fileSize);
          }
        }
      } else if (file instanceof Blob) {
        return new Uint8Array(await file.arrayBuffer());
      } else if (file instanceof Uint8Array) {
        return file;
      } else {
        return new Uint8Array(file);
      }
    };
  }
});

// web/lib/wasm/jsep/log.ts
var logLevelPrefix, doLog, configLogLevel, debug, configureLogger, LOG, LOG_DEBUG;
var init_log = __esm({
  "web/lib/wasm/jsep/log.ts"() {
    "use strict";
    init_wasm_common();
    logLevelPrefix = ["V", "I", "W", "E", "F"];
    doLog = (level, message) => {
      console.log(`[${logLevelPrefix[level]},${(/* @__PURE__ */ new Date()).toISOString()}]${message}`);
    };
    configureLogger = ($configLogLevel, $debug) => {
      configLogLevel = $configLogLevel;
      debug = $debug;
    };
    LOG = (logLevel, msg) => {
      const messageLevel = logLevelStringToEnum(logLevel);
      const configLevel = logLevelStringToEnum(configLogLevel);
      if (messageLevel >= configLevel) {
        doLog(messageLevel, typeof msg === "function" ? msg() : msg);
      }
    };
    LOG_DEBUG = (...args) => {
      if (debug) {
        LOG(...args);
      }
    };
  }
});

// web/lib/wasm/jsep/tensor-view.ts
var createView;
var init_tensor_view = __esm({
  "web/lib/wasm/jsep/tensor-view.ts"() {
    "use strict";
    init_wasm_common();
    createView = (dataBuffer, type) => new (tensorTypeToTypedArrayConstructor(type))(dataBuffer);
  }
});

// web/lib/wasm/jsep/webgpu/types.ts
var init_types = __esm({
  "web/lib/wasm/jsep/webgpu/types.ts"() {
    "use strict";
  }
});

// web/lib/wasm/jsep/webgpu/gpu-data-manager.ts
var bucketFreelist, bucketArr, calcNormalizedBufferSize, calcBucketBufferSize, guid, createNewGpuDataId, downloadGpuData, GpuDataManagerImpl, createGpuDataManager;
var init_gpu_data_manager = __esm({
  "web/lib/wasm/jsep/webgpu/gpu-data-manager.ts"() {
    "use strict";
    init_log();
    init_types();
    bucketFreelist = /* @__PURE__ */ new Map([
      [64, 250],
      [128, 200],
      [256, 200],
      [512, 200],
      [2048, 230],
      [4096, 200],
      [8192, 50],
      [16384, 50],
      [32768, 50],
      [65536, 50],
      [131072, 50],
      [262144, 50],
      [524288, 50],
      [1048576, 50],
      [2097152, 30],
      [4194304, 20],
      [8388608, 10],
      [12582912, 10],
      [16777216, 10],
      [26214400, 15],
      [33554432, 22],
      [44236800, 2],
      [58982400, 6],
      // we don't want to cache the bucket sizes below but not caching them
      // results in some major performance hits for models like sd-turbo.
      [67108864, 6],
      [134217728, 6],
      [167772160, 6]
    ]);
    bucketArr = [];
    calcNormalizedBufferSize = (size) => Math.ceil(size / 16) * 16;
    calcBucketBufferSize = (size) => {
      for (let idx = 0; idx < bucketArr.length; idx++) {
        const sizeForBucket = bucketArr[idx];
        if (size <= sizeForBucket) {
          return sizeForBucket;
        }
      }
      return Math.ceil(size / 16) * 16;
    };
    guid = 1;
    createNewGpuDataId = () => guid++;
    downloadGpuData = async (backend, gpuBuffer, originalSize, getTargetBuffer) => {
      const bufferSize = calcNormalizedBufferSize(originalSize);
      const gpuReadBuffer = backend.device.createBuffer(
        // eslint-disable-next-line no-bitwise
        { size: bufferSize, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ }
      );
      try {
        const commandEncoder = backend.getCommandEncoder();
        backend.endComputePass();
        commandEncoder.copyBufferToBuffer(
          gpuBuffer,
          0,
          gpuReadBuffer,
          0,
          bufferSize
          /* size */
        );
        backend.flush();
        await gpuReadBuffer.mapAsync(GPUMapMode.READ);
        const arrayBuffer = gpuReadBuffer.getMappedRange();
        if (getTargetBuffer) {
          const targetBuffer = getTargetBuffer();
          targetBuffer.set(new Uint8Array(arrayBuffer, 0, originalSize));
          return targetBuffer;
        } else {
          return new Uint8Array(arrayBuffer.slice(0, originalSize));
        }
      } finally {
        gpuReadBuffer.destroy();
      }
    };
    GpuDataManagerImpl = class {
      constructor(backend) {
        this.backend = backend;
        this.storageCache = /* @__PURE__ */ new Map();
        this.freeBuffers = /* @__PURE__ */ new Map();
        this.freeUniformBuffers = /* @__PURE__ */ new Map();
        this.buffersForUploadingPending = [];
        this.buffersPending = [];
        this.externalBuffers = /* @__PURE__ */ new Map();
        this.capturedPendingBuffers = /* @__PURE__ */ new Map();
        for (const [key] of bucketFreelist) {
          bucketArr.push(key);
          this.freeBuffers.set(key, []);
          this.freeUniformBuffers.set(key, []);
        }
      }
      upload(id, data) {
        const srcArrayBuffer = data.buffer;
        const srcOffset = data.byteOffset;
        const srcLength = data.byteLength;
        const size = calcNormalizedBufferSize(srcLength);
        const gpuDataCache = this.storageCache.get(id);
        if (!gpuDataCache) {
          throw new Error("gpu data for uploading does not exist");
        }
        if (gpuDataCache.originalSize !== srcLength) {
          throw new Error(`inconsistent data size. gpu data size=${gpuDataCache.originalSize}, data size=${srcLength}`);
        }
        const gpuBufferForUploading = this.backend.device.createBuffer(
          // eslint-disable-next-line no-bitwise
          { mappedAtCreation: true, size, usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC }
        );
        const arrayBuffer = gpuBufferForUploading.getMappedRange();
        new Uint8Array(arrayBuffer).set(new Uint8Array(srcArrayBuffer, srcOffset, srcLength));
        gpuBufferForUploading.unmap();
        const commandEncoder = this.backend.getCommandEncoder();
        this.backend.endComputePass();
        commandEncoder.copyBufferToBuffer(gpuBufferForUploading, 0, gpuDataCache.gpuData.buffer, 0, size);
        LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.upload(id=${id})`);
        this.buffersForUploadingPending.push(gpuBufferForUploading);
      }
      memcpy(sourceId, destinationId) {
        const sourceGpuDataCache = this.storageCache.get(sourceId);
        if (!sourceGpuDataCache) {
          throw new Error("source gpu data for memcpy does not exist");
        }
        const destinationGpuDataCache = this.storageCache.get(destinationId);
        if (!destinationGpuDataCache) {
          throw new Error("destination gpu data for memcpy does not exist");
        }
        if (sourceGpuDataCache.originalSize !== destinationGpuDataCache.originalSize) {
          throw new Error("inconsistent source and destination gpu data size");
        }
        const size = calcNormalizedBufferSize(sourceGpuDataCache.originalSize);
        const commandEncoder = this.backend.getCommandEncoder();
        this.backend.endComputePass();
        commandEncoder.copyBufferToBuffer(
          sourceGpuDataCache.gpuData.buffer,
          0,
          destinationGpuDataCache.gpuData.buffer,
          0,
          size
        );
      }
      registerExternalBuffer(buffer, originalSize, previousBuffer) {
        let id;
        if (previousBuffer) {
          id = this.externalBuffers.get(previousBuffer);
          if (id === void 0) {
            throw new Error("previous buffer is not registered");
          }
          if (buffer === previousBuffer) {
            LOG_DEBUG(
              "verbose",
              () => `[WebGPU] GpuDataManager.registerExternalBuffer(size=${originalSize}) => id=${id}, buffer is the same, skip.`
            );
            return id;
          } else if (this.backend.capturedCommandList.has(this.backend.currentSessionId)) {
            throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`);
          }
          this.externalBuffers.delete(previousBuffer);
        } else {
          id = createNewGpuDataId();
        }
        this.storageCache.set(id, { gpuData: { id, type: 0 /* default */, buffer }, originalSize });
        this.externalBuffers.set(buffer, id);
        LOG_DEBUG(
          "verbose",
          () => `[WebGPU] GpuDataManager.registerExternalBuffer(size=${originalSize}) => id=${id}, registered.`
        );
        return id;
      }
      unregisterExternalBuffer(buffer) {
        const id = this.externalBuffers.get(buffer);
        if (id !== void 0) {
          this.storageCache.delete(id);
          this.externalBuffers.delete(buffer);
          LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${id}`);
        }
      }
      // eslint-disable-next-line no-bitwise
      create(size, usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST) {
        const bufferSize = calcBucketBufferSize(size);
        let gpuBuffer;
        const isStorage = (usage & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE;
        const isUniform = (usage & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM;
        if (isStorage || isUniform) {
          const freeBuffers = isStorage ? this.freeBuffers : this.freeUniformBuffers;
          const buffers = freeBuffers.get(bufferSize);
          if (!buffers) {
            gpuBuffer = this.backend.device.createBuffer({ size: bufferSize, usage });
          } else {
            if (buffers.length > 0) {
              gpuBuffer = buffers.pop();
            } else {
              gpuBuffer = this.backend.device.createBuffer({ size: bufferSize, usage });
            }
          }
        } else {
          gpuBuffer = this.backend.device.createBuffer({ size: bufferSize, usage });
        }
        const gpuData = { id: createNewGpuDataId(), type: 0 /* default */, buffer: gpuBuffer };
        this.storageCache.set(gpuData.id, { gpuData, originalSize: size });
        LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.create(size=${size}) => id=${gpuData.id}`);
        return gpuData;
      }
      get(id) {
        return this.storageCache.get(id)?.gpuData;
      }
      release(id) {
        const cachedData = this.storageCache.get(id);
        if (!cachedData) {
          throw new Error("releasing data does not exist");
        }
        LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.release(id=${id}), gpuDataId=${cachedData.gpuData.id}`);
        this.storageCache.delete(id);
        this.buffersPending.push(cachedData.gpuData.buffer);
        return cachedData.originalSize;
      }
      async download(id, getTargetBuffer) {
        const cachedData = this.storageCache.get(id);
        if (!cachedData) {
          throw new Error("data does not exist");
        }
        await downloadGpuData(this.backend, cachedData.gpuData.buffer, cachedData.originalSize, getTargetBuffer);
      }
      refreshPendingBuffers() {
        for (const buffer of this.buffersForUploadingPending) {
          buffer.destroy();
        }
        this.buffersForUploadingPending = [];
        if (this.buffersPending.length === 0) {
          return;
        }
        if (this.backend.sessionStatus === "default") {
          for (const buffer of this.buffersPending) {
            const maxInFreeList = bucketFreelist.get(buffer.size);
            if ((buffer.usage & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE) {
              const freelist = this.freeBuffers.get(buffer.size) || [];
              if (maxInFreeList === void 0 || freelist.length >= maxInFreeList) {
                buffer.destroy();
              } else {
                freelist.push(buffer);
              }
            } else if ((buffer.usage & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM) {
              const freelist = this.freeUniformBuffers.get(buffer.size) || [];
              if (maxInFreeList === void 0 || freelist.length >= maxInFreeList) {
                buffer.destroy();
              } else {
                freelist.push(buffer);
              }
            } else {
              buffer.destroy();
            }
          }
          this.buffersPending = [];
        } else {
          let capturedBuffers = this.capturedPendingBuffers.get(this.backend.currentSessionId);
          if (!capturedBuffers) {
            capturedBuffers = [];
            this.capturedPendingBuffers.set(this.backend.currentSessionId, capturedBuffers);
          }
          for (const buffer of this.buffersPending) {
            capturedBuffers.push(buffer);
          }
          this.buffersPending = [];
        }
      }
      dispose() {
        this.freeBuffers.forEach((buffers) => {
          buffers.forEach((buffer) => {
            buffer.destroy();
          });
        });
        this.freeUniformBuffers.forEach((buffers) => {
          buffers.forEach((buffer) => {
            buffer.destroy();
          });
        });
        this.storageCache.forEach((storage) => {
          storage.gpuData.buffer.destroy();
        });
        this.capturedPendingBuffers.forEach((buffers) => {
          buffers.forEach((buffer) => {
            buffer.destroy();
          });
        });
        this.storageCache = /* @__PURE__ */ new Map();
        this.freeBuffers = /* @__PURE__ */ new Map();
        this.freeUniformBuffers = /* @__PURE__ */ new Map();
        this.capturedPendingBuffers = /* @__PURE__ */ new Map();
      }
      onReleaseSession(sessionId) {
        const pendingBuffers = this.capturedPendingBuffers.get(sessionId);
        if (pendingBuffers) {
          pendingBuffers.forEach((buffer) => {
            buffer.destroy();
          });
          this.capturedPendingBuffers.delete(sessionId);
        }
      }
    };
    createGpuDataManager = (...args) => new GpuDataManagerImpl(...args);
  }
});

// web/lib/wasm/jsep/webgpu/attribute-with-cache-key.ts
var AttributeWithCacheKeyImpl, createAttributeWithCacheKey;
var init_attribute_with_cache_key = __esm({
  "web/lib/wasm/jsep/webgpu/attribute-with-cache-key.ts"() {
    "use strict";
    AttributeWithCacheKeyImpl = class {
      constructor(attribute) {
        Object.assign(this, attribute);
      }
      get cacheKey() {
        if (!this.key) {
          this.key = Object.getOwnPropertyNames(this).sort().map((name) => `${this[name]}`).join(";");
        }
        return this.key;
      }
    };
    createAttributeWithCacheKey = (attribute) => new AttributeWithCacheKeyImpl(attribute);
  }
});

// web/lib/wasm/jsep/util.ts
var MatMulUtil, BroadcastUtil, ShapeUtil, PoolConvUtil, GemmUtil, MIN_CLIP, MAX_CLIP;
var init_util = __esm({
  "web/lib/wasm/jsep/util.ts"() {
    "use strict";
    MatMulUtil = class {
      /**
       * Calculate the expected shape when matrix multiplication
       * @param a The shape of tensor A. Should be a tuple of 2 positive integers
       * @param b The shape of tensor B. Should be a tuple of 2 positive integers
       * @returns The expected shape of the result, or undefined if N/A
       */
      static calcMatMulShape(a, b) {
        return a[1] !== b[0] ? void 0 : [a[0], b[1]];
      }
    };
    BroadcastUtil = class {
      /**
       * Calculate the expected shape when broadcasting 2 tensors
       * @param a The shape of tensor A. Should be an array of positive integers
       * @param b The shape of tensor B. Should be an array of positive integers
       * @param isMatMul Whether the operation is MatMul
       * @returns The expected shape of the result, or undefined if N/A
       */
      static calcShape(adims, bdims, isMatMul = false) {
        const arank = adims.length;
        const brank = bdims.length;
        if (arank === 0) {
          return bdims;
        }
        if (brank === 0) {
          return adims;
        }
        const crank = Math.max(adims.length, bdims.length);
        const cdims = new Array(crank);
        if (isMatMul) {
          if (arank < 2 || brank < 2) {
            return void 0;
          }
          const cShapeMatMul = MatMulUtil.calcMatMulShape([adims[arank - 2], adims[arank - 1]], [bdims[brank - 2], bdims[brank - 1]]);
          if (cShapeMatMul === void 0) {
            return void 0;
          }
          [cdims[crank - 2], cdims[crank - 1]] = cShapeMatMul;
        }
        for (let i = isMatMul ? 3 : 1; i <= crank; i++) {
          const aLen = arank - i < 0 ? 1 : adims[arank - i];
          const bLen = brank - i < 0 ? 1 : bdims[brank - i];
          if (aLen !== bLen && aLen > 1 && bLen > 1) {
            return void 0;
          }
          const max = Math.max(aLen, bLen);
          if (aLen && bLen) {
            cdims[crank - i] = Math.max(aLen, bLen);
          } else {
            if (max > 1) {
              return void 0;
            }
            cdims[crank - i] = 0;
          }
        }
        return cdims;
      }
      /**
       * Determine if a shape is unidirectional broadcastable to another shape
       * @param shape The input shape
       * @param finalShape The desired shape after broadcasting
       */
      static isValidBroadcast(shape, finalShape) {
        const inputRank = shape.length;
        const finalRank = finalShape.length;
        if (inputRank > finalRank) {
          return false;
        }
        for (let i = 1; i <= inputRank; i++) {
          if (shape[inputRank - i] !== 1 && shape[inputRank - i] !== finalShape[finalRank - i]) {
            return false;
          }
        }
        return true;
      }
    };
    ShapeUtil = class _ShapeUtil {
      /**
       * calculate the size (number of elements)
       */
      static size(dims) {
        return _ShapeUtil.getSizeFromDimensionRange(dims, 0, dims.length);
      }
      /**
       * convert dims corresponding to type change to pack. ex. uint8 data to uint32
       */
      static convertShape(dims, size = 4) {
        const rank = dims.length;
        if (rank === 0) {
          return [];
        }
        const newDims = new Array(rank);
        let i = rank - 1;
        while (i >= 0) {
          if (dims[i] % size === 0) {
            newDims[i] = dims[i] / size;
            break;
          }
          if (size % dims[i] !== 0) {
            throw new Error("cannot convert shape");
          }
          newDims[i] = 1;
          size /= dims[i];
          i--;
        }
        for (i--; i >= 0; i--) {
          newDims[i] = dims[i];
        }
        return newDims;
      }
      /**
       * calculate the size (number of elements) from the given axis (inclusive)
       */
      static sizeFromDimension(dims, axis) {
        if (axis < 0 || axis > dims.length) {
          throw new Error(`invalid dimension of ${axis} for sizeFromDimension as Tensor has ${dims.length} dimensions.`);
        }
        return _ShapeUtil.getSizeFromDimensionRange(dims, axis, dims.length);
      }
      /**
       * calculate the size (number of elements) to the given axis (exclusive)
       */
      static sizeToDimension(dims, axis) {
        if (axis < 0 || axis > dims.length) {
          throw new Error(`invalid dimension of ${axis} for sizeToDimension as Tensor has ${dims.length} dimensions.`);
        }
        return _ShapeUtil.getSizeFromDimensionRange(dims, 0, axis);
      }
      /**
       * calculate the size (number of elements) from and to the given axis [start, end)
       */
      static getSizeFromDimensionRange(dims, start, end) {
        let size = 1;
        for (let i = start; i < end; i++) {
          if (dims[i] < 0) {
            throw new Error(
              // eslint-disable-next-line max-len
              "cannot get valid size from specified dimension range. Most likely the range contains negative values in them."
            );
          }
          size *= dims[i];
        }
        return size;
      }
      static computeStrides(dims) {
        const rank = dims.length;
        if (rank === 0) {
          return [];
        } else if (rank === 1) {
          return [1];
        }
        const strides = new Array(rank);
        strides[rank - 1] = 1;
        strides[rank - 2] = dims[rank - 1];
        for (let i = rank - 3; i >= 0; --i) {
          strides[i] = strides[i + 1] * dims[i + 1];
        }
        return strides;
      }
      /**
       * normailze axis of range [-r, r) into [0, r).
       */
      static normalizeAxis(axis, tensorRank) {
        if (axis < -tensorRank && axis >= tensorRank) {
          throw new Error("unsupported axis for this operation.");
        }
        return axis < 0 ? axis + tensorRank : axis;
      }
      static normalizeAxes(axes, tensorRank) {
        return axes.map((x) => this.normalizeAxis(x, tensorRank ?? axes.length));
      }
      /**
       * Sorts a given array based on the indices in the Perm array
       * Used in Transpose
       * @param a Array to be sorted such as dims or strides
       * @param perm Perm given; if null a will be reversed
       */
      static sortBasedOnPerm(a, perm) {
        if (perm) {
          return perm.map((v) => a[v]);
        } else {
          return a.slice().reverse();
        }
      }
      /**
       * Pads a given shape according to the padding values
       * @param dims shape of the Tensor to be padded
       * @param pad pad values
       */
      static padShape(dims, pad2) {
        const rank = dims.length;
        return dims.map((v, i) => v + pad2[i] + pad2[i + rank]);
      }
      /**
       * Determines if the two shapes are identical
       * @param shape1
       * @param shape2
       */
      static areEqual(shape1, shape2) {
        if (shape1.length !== shape2.length) {
          return false;
        }
        return shape1.every((v, i) => v === shape2[i]);
      }
    };
    PoolConvUtil = class _PoolConvUtil {
      /**
       * Adjust the kernel, strides, pads to correct rank. Set to default value if not present
       * @param isGlobalOperator If true, perform global pooling.
       * @param inputDims The input tensor dimension.
       * @param kernelShape The size of the kernel along each axis.
       * @param strides Stride along each axis.
       * @param dilations Dilation along each axis.
       * @param pads Padding for the beginning and ending along each axis.
       */
      static adjustPoolAttributes(isGlobalOperator, inputDims, kernelShape, strides, dilations, pads) {
        if (!isGlobalOperator && kernelShape.length !== inputDims.length - 2) {
          throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
        }
        if (isGlobalOperator) {
          for (let dim = 0; dim < inputDims.length - 2; dim++) {
            if (dim >= kernelShape.length) {
              kernelShape.push(inputDims[dim + 2]);
            } else {
              kernelShape[dim] = inputDims[dim + 2];
            }
          }
        }
        for (let dim = 0; dim < kernelShape.length; dim++) {
          if (dim < strides.length) {
            if (strides[dim] < 0) {
              throw new Error("strides should be greater than or equal to 1");
            }
          } else {
            strides.push(1);
          }
        }
        for (let dim = 0; dim < kernelShape.length; dim++) {
          if (dim < dilations.length) {
            if (dilations[dim] < 0) {
              throw new Error("dilations should be greater than or equal to 1");
            }
          } else {
            dilations.push(1);
          }
        }
        for (let dim = 0; dim < kernelShape.length * 2; dim++) {
          if (dim < pads.length) {
            if (pads[dim] < 0) {
              throw new Error("pad should be greater than or equal to 1");
            }
          } else {
            pads.push(0);
          }
        }
        for (let dim = 0; dim < kernelShape.length; dim++) {
          if (kernelShape[dim] <= 0) {
            throw new Error("kernel shapes need to be greater than 0");
          }
          if (pads[dim] >= kernelShape[dim] || pads[dim + kernelShape.length] >= kernelShape[dim]) {
            throw new Error("pads should be smaller than kernel");
          }
        }
      }
      // adjust pad values based on 'autoPad' attribute
      static adjustPadsBasedOnAutoPad(inputDims, strides, dilations, kernelShape, pads, isChannelLast, autoPad) {
        if (!autoPad) {
          return;
        }
        if (pads.length !== 2 * (inputDims.length - 2)) {
          throw new Error("length of pads should be twice the length of data dimensions");
        }
        if (strides.length !== inputDims.length - 2) {
          throw new Error("length of strides should be the length of data dimensions");
        }
        if (kernelShape.length !== inputDims.length - 2) {
          throw new Error("length of kernel shapes should be the length of data dimensions");
        }
        for (let dim = 0; dim < inputDims.length - 2; dim++) {
          _PoolConvUtil.adjustPadAndReturnShape(
            inputDims[dim + (isChannelLast ? 1 : 2)],
            strides[dim],
            dilations[dim],
            kernelShape[dim],
            pads,
            dim,
            dim + inputDims.length - 2,
            autoPad
          );
        }
      }
      /**
       * Calculate the output shape for Pool ops based on input attributes. (Should be used only for Pool ops)
       * @param isGlobalOperator If true, perform global pooling.
       * @param inputDims The input tensor dimension. (inputs[0].dims)
       * @param strides Stride along each axis.
       * @param dilations Dilation along each axis.
       * @param kernelShape The size of the kernel along each axis.
       * @param pads Padding for the beginning and ending along each axis.
       * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
       *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
       */
      static computePoolOutputShape(isGlobalOperator, inputDims, strides, dilations, kernelShape, pads, autoPad) {
        if (inputDims.length <= 0) {
          throw new Error("input shape must be of size greater than 0");
        }
        const outputDims = [inputDims[0], inputDims[1]];
        _PoolConvUtil.computeShapeHelper(
          isGlobalOperator,
          inputDims,
          outputDims,
          strides,
          dilations,
          kernelShape,
          pads,
          autoPad
        );
        return outputDims;
      }
      /**
       * Calculate the output shape for Conv op based on input attributes. (Should be used only for Conv op)
       * @param inputDims The input tensor dimension. (inputs[0].dims)
       * @param filterDims The filter tensor dimension. (inputs[1].dims)
       * @param strides Stride along each axis.
       * @param kernelShape The size of the kernel along each axis.
       * @param pads Padding for the beginning and ending along each axis.
       * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
       *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
       */
      static computeConvOutputShape(inputDims, filterDims, strides, dilations, kernelShape, pads, autoPad) {
        if (inputDims.length <= 0 || filterDims.length <= 0) {
          throw new Error("invalid input tensor dims or invalid filter tensor dims");
        }
        const outputDims = [inputDims[0], filterDims[0]];
        _PoolConvUtil.computeShapeHelper(false, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad);
        return outputDims;
      }
      // will compute output shapes for data dimensions ONLY (i.e.) no batch size and channels
      // called by computePoolOutputShape() and computeConvOutputShape()
      // adjust pads based on 'autoPad' attribute prior to shape computation
      static computeShapeHelper(isGlobalOperator, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad) {
        if (isGlobalOperator) {
          for (let dim = 0; dim < inputDims.length - 2; dim++) {
            outputDims.push(1);
          }
        } else {
          for (let dim = 0; dim < inputDims.length - 2; dim++) {
            outputDims.push(_PoolConvUtil.adjustPadAndReturnShape(
              inputDims[dim + 2],
              strides[dim],
              dilations[dim],
              kernelShape[dim],
              pads,
              dim,
              dim + inputDims.length - 2,
              autoPad
            ));
          }
        }
      }
      // helper for computeShapeHelper() and adjustPadsBasedOnAutoPad()
      // adjusts pad value for given 'autoPad' string and computes output shape along a particular dimension
      static adjustPadAndReturnShape(inSize, stride, dilation, kernel, pads, padHeadIndex, padTailIndex, autoPad) {
        const dkernel = dilation * (kernel - 1) + 1;
        if (autoPad && autoPad !== "NOTSET") {
          switch (autoPad) {
            case "VALID":
              pads[padHeadIndex] = 0;
              pads[padTailIndex] = 0;
              return Math.floor((inSize - dkernel) / stride + 1);
            case "SAME_LOWER":
            case "SAME_UPPER":
              if (dilation !== 1) {
                throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
              } else {
                const legacyTargetSize = (inSize + stride - 1) / stride;
                const padNeeded = (legacyTargetSize - 1) * stride + kernel - inSize;
                pads[padHeadIndex] = autoPad === "SAME_LOWER" ? Math.floor((padNeeded + 1) / 2) : Math.floor(padNeeded / 2);
                pads[padTailIndex] = padNeeded - pads[padHeadIndex];
                return Math.floor((inSize + padNeeded - kernel) / stride + 1);
              }
            default:
              throw new Error("Unsupported AutoPad type");
          }
        } else {
          return Math.floor((inSize + pads[padHeadIndex] + pads[padTailIndex] - dkernel) / stride + 1);
        }
      }
    };
    GemmUtil = class {
      // will make sure input shapes are compatible for this op
      // and return back the shape of the output in the form of a tuple
      // will throw exception if the input shapes are not compatible
      static getShapeOfGemmResult(leftShape, transLeft, rightShape, transRight, biasShape) {
        if (leftShape.length !== 2 || rightShape.length !== 2) {
          throw new Error("shape need to be of size 2");
        }
        let M;
        let K;
        let N;
        if (transLeft) {
          M = leftShape[1];
          K = leftShape[0];
        } else {
          M = leftShape[0];
          K = leftShape[1];
        }
        let kDim = -1;
        if (transRight) {
          N = rightShape[0];
          kDim = 1;
        } else {
          N = rightShape[1];
          kDim = 0;
        }
        if (rightShape[kDim] !== K) {
          throw new Error("dimension mismatch");
        }
        if (M <= 0 || N <= 0 || K <= 0) {
          throw new Error("invalid shape specified");
        }
        if (biasShape && !BroadcastUtil.isValidBroadcast(biasShape, [M, N])) {
          throw new Error("gemm: invalid bias shape for broadcast");
        }
        return [M, N, K];
      }
    };
    MIN_CLIP = -34028234663852886e22;
    MAX_CLIP = 34028234663852886e22;
  }
});

// web/lib/wasm/jsep/webgpu/ops/common.ts
var WORKGROUP_SIZE, getWgslMappedType, tensorTypeToWsglStorageType, tensorTypeToWsglValueType, createTensorShapeVariables, getMaxComponents, fillVector, castToF32, sumVector, getElementAt, createIndicesHelper, inputVariable, outputVariable, internalVariable, ShaderHelperImpl, createShaderHelper, getBroadcastDims;
var init_common = __esm({
  "web/lib/wasm/jsep/webgpu/ops/common.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    WORKGROUP_SIZE = 64;
    getWgslMappedType = (type, components) => {
      if (components === 3) {
        throw new Error("vec3 has same alignment as vec4, use vec4 instead");
      }
      switch (type) {
        case 10 /* float16 */:
          return components > 1 ? `vec${components}<f16>` : "f16";
        case 1 /* float */:
          return components > 1 ? `vec${components}<f32>` : "f32";
        case 6 /* int32 */:
          return components > 1 ? `vec${components}<i32>` : "i32";
        case 12 /* uint32 */:
          return components > 1 ? `vec${components}<u32>` : "u32";
        case 7 /* int64 */:
          if (components > 1) {
            throw new Error("currently not supported vecX of uint64 yet");
          }
          return ["vec2<u32>", "i32"];
        case 13 /* uint64 */:
          if (components > 1) {
            throw new Error("currently not supported vecX of uint64 yet");
          }
          return ["vec2<u32>", "u32"];
        case 9 /* bool */:
          if (components !== 4) {
            throw new Error("bool must be vec4");
          }
          return ["u32", "vec4<bool>"];
        default:
          throw new Error(`Unknown data type: ${type}`);
      }
    };
    tensorTypeToWsglStorageType = (type, components = 1) => {
      const mappedType = getWgslMappedType(type, components);
      return typeof mappedType === "string" ? mappedType : mappedType[0];
    };
    tensorTypeToWsglValueType = (type, components = 1) => {
      const mappedType = getWgslMappedType(type, components);
      return typeof mappedType === "string" ? mappedType : mappedType[1];
    };
    createTensorShapeVariables = (...dims) => {
      const programUniforms = [];
      dims.forEach((dim) => {
        if (dim.length !== 0) {
          programUniforms.push(
            { type: 12 /* uint32 */, data: dim },
            { type: 12 /* uint32 */, data: ShapeUtil.computeStrides(dim) }
          );
        }
      });
      return programUniforms;
    };
    getMaxComponents = (size) => {
      if (size % 4 === 0) {
        return 4;
      } else if (size % 2 === 0) {
        return 2;
      }
      return 1;
    };
    fillVector = (dataType = "f32", components, value = "0") => {
      if (!components || components === 1) {
        return `${dataType}(${value})`;
      }
      return `vec${components}<${dataType}>(${value})`;
    };
    castToF32 = (dataType, components, value) => {
      if (dataType === "f32") {
        return value;
      }
      if (components === 1) {
        return `f32(${value})`;
      }
      return `vec${components}<f32>(${value})`;
    };
    sumVector = (name, components) => {
      if (components === 4) {
        return `(${name}.x + ${name}.y + ${name}.z + ${name}.w)`;
      } else if (components === 2) {
        return `(${name}.x + ${name}.y)`;
      } else if (components === 3) {
        return `(${name}.x + ${name}.y + ${name}.z)`;
      }
      return name;
    };
    getElementAt = (name, index, length, type) => {
      if (name.startsWith("uniforms.") && length > 4) {
        if (typeof index === "string") {
          if (type === "f16") {
            return `${name}[(${index}) / 8][(${index}) % 8 / 4][(${index}) % 8 % 4]`;
          } else {
            return `${name}[(${index}) / 4][(${index}) % 4]`;
          }
        } else {
          if (type === "f16") {
            return `${name}[${Math.floor(index / 8)}][${Math.floor(index % 8 / 4)}][${index % 8 % 4}]`;
          } else {
            return `${name}[${Math.floor(index / 4)}][${index % 4}]`;
          }
        }
      } else {
        return length > 1 ? `${name}[${index}]` : name;
      }
    };
    createIndicesHelper = (name, tensorType, shapeOrRank, usage, components) => {
      const useUniform = typeof shapeOrRank === "number";
      const rank = useUniform ? shapeOrRank : shapeOrRank.length;
      const rankIdentity = [...new Array(rank).keys()];
      const indicesType = rank < 2 ? "u32" : rank <= 4 ? `vec${rank}<u32>` : `array<u32, ${rank}>`;
      const mappedType = getWgslMappedType(tensorType, components);
      const valueType = typeof mappedType === "string" ? mappedType : mappedType[1];
      const storageType = typeof mappedType === "string" ? mappedType : mappedType[0];
      const type = { indices: indicesType, value: valueType, storage: storageType, tensor: tensorType };
      const normalizeDim = (dim) => typeof dim === "string" ? dim : `${dim}u`;
      const implementationUsed = {
        offsetToIndices: false,
        indicesToOffset: false,
        broadcastedIndicesToOffset: false,
        set: false,
        setByIndices: false,
        get: false,
        getByIndices: false
      };
      const uniformPrefix = useUniform ? "uniforms." : "";
      const shape = `${uniformPrefix}${name}_shape`;
      const strides = `${uniformPrefix}${name}_strides`;
      let o2iSnippet = "";
      for (let i = 0; i < rank - 1; i++) {
        o2iSnippet += `
    let dim${i} = current / ${getElementAt(strides, i, rank)};
    let rest${i} = current % ${getElementAt(strides, i, rank)};
    indices[${i}] = dim${i};
    current = rest${i};
    `;
      }
      o2iSnippet += `indices[${rank - 1}] = current;`;
      const offsetToIndicesImplementation = rank < 2 ? "" : `
  fn o2i_${name}(offset: u32) -> ${type.indices} {
    var indices: ${type.indices};
    var current = offset;
    ${o2iSnippet}
    return indices;
  }`;
      const offsetToIndices = (varOffset) => {
        implementationUsed.offsetToIndices = true;
        return rank < 2 ? varOffset : `o2i_${name}(${varOffset})`;
      };
      const offsets = [];
      if (rank >= 2) {
        for (let i = rank - 1; i >= 0; i--) {
          offsets.push(`${getElementAt(strides, i, rank)} * (indices[${i}])`);
        }
      }
      const indicesToOffsetImplementation = rank < 2 ? "" : `
  fn i2o_${name}(indices: ${type.indices}) -> u32 {
    return ${offsets.join("+")};
  }`;
      const indicesToOffset = (varIndices) => {
        implementationUsed.indicesToOffset = true;
        return rank < 2 ? varIndices : `i2o_${name}(${varIndices})`;
      };
      const indices = (...init2) => rank === 0 ? "0u" : `${type.indices}(${init2.map(normalizeDim).join(",")})`;
      const indicesGet = (varIndices, idx) => {
        if (rank < 2) {
          return `${varIndices}`;
        } else {
          return `${getElementAt(varIndices, idx, rank)}`;
        }
      };
      const indicesSet = (varIndices, idx, value) => {
        if (rank < 2) {
          return `${varIndices}=${value};`;
        } else {
          return `${getElementAt(varIndices, idx, rank)}=${value};`;
        }
      };
      const broadcastedIndicesToOffsetImplementation = {};
      const broadcastedIndicesToOffset = (varIndices, output) => {
        implementationUsed.broadcastedIndicesToOffset = true;
        const implKey = `${output.name}broadcastedIndicesTo${name}Offset`;
        if (implKey in broadcastedIndicesToOffsetImplementation) {
          return `${implKey}(${varIndices})`;
        }
        const offsets2 = [];
        for (let i = rank - 1; i >= 0; i--) {
          const idx = output.indicesGet("outputIndices", i + output.rank - rank);
          offsets2.push(`${indicesGet(strides, i)} * (${idx} % ${indicesGet(shape, i)})`);
        }
        broadcastedIndicesToOffsetImplementation[implKey] = `fn ${implKey}(outputIndices: ${output.type.indices}) -> u32 {
             return ${offsets2.length > 0 ? offsets2.join("+") : "0u"};
           }`;
        return `${implKey}(${varIndices})`;
      };
      const setByOffset = (offset, value) => (() => {
        if (type.storage === type.value) {
          return `${name}[${offset}]=${value};`;
        } else if (type.storage === "vec2<u32>" && type.value === "i32") {
          return `${name}[${offset}]=vec2<u32>(u32(${value}), select(0u, 0xFFFFFFFFu, ${value} < 0));`;
        } else if (type.storage === "vec2<u32>" && type.value === "u32") {
          return `${name}[${offset}]=vec2<u32>(u32(${value}), 0u);`;
        } else if (type.storage === "u32" && type.value === "vec4<bool>") {
          return `${name}[${offset}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${value}));`;
        } else {
          throw new Error(`not supported combination of storage type ${type.storage} and value type ${type.value} yet`);
        }
      })();
      const getByOffset = (offset) => (() => {
        if (type.storage === type.value) {
          return `${name}[${offset}]`;
        } else if (type.storage === "vec2<u32>" && type.value === "i32") {
          return `i32(${name}[${offset}].x)`;
        } else if (type.storage === "vec2<u32>" && type.value === "u32") {
          return `u32(${name}[${offset}].x)`;
        } else if (type.storage === "u32" && type.value === "vec4<bool>") {
          return `vec4<bool>(bool(${name}[${offset}] & 0xFFu), bool(${name}[${offset}] & 0xFF00u), bool(${name}[${offset}] & 0xFF0000u), bool(${name}[${offset}] & 0xFF000000u))`;
        } else {
          throw new Error(`not supported combination of storage type ${type.storage} and value type ${type.value} yet`);
        }
      })();
      const getByIndicesImplementation = rank < 2 ? "" : `
  fn get_${name}ByIndices(indices: ${type.indices}) -> ${valueType} {
    return ${getByOffset(`i2o_${name}(indices)`)};
  }`;
      const getImplementation = rank < 2 ? "" : (() => {
        const functionParams = rankIdentity.map((i) => `d${i}: u32`).join(", ");
        const dimsParams = rankIdentity.map((i) => `d${i}`).join(", ");
        return `
  fn get_${name}(${functionParams}) -> ${valueType} {
    return get_${name}ByIndices(${indices(dimsParams)});
  }`;
      })();
      const get = (...indices2) => {
        if (indices2.length !== rank) {
          throw new Error(`indices length must be ${rank}`);
        }
        const normalizedIndices = indices2.map(normalizeDim).join(",");
        if (rank === 0) {
          return getByOffset("0u");
        } else if (rank === 1) {
          return getByOffset(normalizedIndices[0]);
        } else {
          implementationUsed.get = true;
          implementationUsed.getByIndices = true;
          implementationUsed.indicesToOffset = true;
          return `get_${name}(${normalizedIndices})`;
        }
      };
      const getByIndices = (varIndices) => {
        if (rank < 2) {
          return getByOffset(varIndices);
        } else {
          implementationUsed.getByIndices = true;
          implementationUsed.indicesToOffset = true;
          return `get_${name}ByIndices(${varIndices})`;
        }
      };
      const setByIndicesImplementation = rank < 2 ? "" : `
  fn set_${name}ByIndices(indices: ${type.indices}, value: ${valueType}) {
    ${setByOffset(`i2o_${name}(indices)`, "value")}
  }`;
      const setImplementation = rank < 2 ? "" : (() => {
        const functionParams = rankIdentity.map((i) => `d${i}: u32`).join(", ");
        const dimsParams = rankIdentity.map((i) => `d${i}`).join(", ");
        return `
  fn set_${name}(${functionParams}, value: ${valueType}) {
    set_${name}ByIndices(${indices(dimsParams)}, value);
  }`;
      })();
      const set = (...indicesAndValue) => {
        if (indicesAndValue.length !== rank + 1) {
          throw new Error(`indices length must be ${rank}`);
        }
        const value = indicesAndValue[rank];
        if (typeof value !== "string") {
          throw new Error("value must be string");
        }
        const normalizedIndices = indicesAndValue.slice(0, rank).map(normalizeDim).join(",");
        if (rank === 0) {
          return setByOffset("0u", value);
        } else if (rank === 1) {
          return setByOffset(normalizedIndices[0], value);
        } else {
          implementationUsed.set = true;
          implementationUsed.setByIndices = true;
          implementationUsed.indicesToOffset = true;
          return `set_${name}(${normalizedIndices}, ${value})`;
        }
      };
      const setByIndices = (varIndices, value) => {
        if (rank < 2) {
          return setByOffset(varIndices, value);
        } else {
          implementationUsed.setByIndices = true;
          implementationUsed.indicesToOffset = true;
          return `set_${name}ByIndices(${varIndices}, ${value});`;
        }
      };
      const impl = () => {
        const impls = [];
        let needShapeStrides = false;
        if (implementationUsed.offsetToIndices) {
          impls.push(offsetToIndicesImplementation);
          needShapeStrides = true;
        }
        if (implementationUsed.indicesToOffset) {
          impls.push(indicesToOffsetImplementation);
          needShapeStrides = true;
        }
        if (implementationUsed.broadcastedIndicesToOffset) {
          Object.values(broadcastedIndicesToOffsetImplementation).forEach((impl2) => impls.push(impl2));
          needShapeStrides = true;
        }
        if (implementationUsed.set) {
          impls.push(setImplementation);
          needShapeStrides = true;
        }
        if (implementationUsed.setByIndices) {
          impls.push(setByIndicesImplementation);
          needShapeStrides = true;
        }
        if (implementationUsed.get) {
          impls.push(getImplementation);
          needShapeStrides = true;
        }
        if (implementationUsed.getByIndices) {
          impls.push(getByIndicesImplementation);
          needShapeStrides = true;
        }
        if (!useUniform && needShapeStrides) {
          impls.unshift(
            `const ${shape} = ${type.indices}(${shapeOrRank.join(",")});`,
            `const ${strides} = ${type.indices}(${ShapeUtil.computeStrides(shapeOrRank).join(",")});`
          );
        }
        return impls.join("\n");
      };
      return {
        impl,
        type,
        offsetToIndices,
        indicesToOffset,
        broadcastedIndicesToOffset,
        indices,
        indicesGet,
        indicesSet,
        set,
        setByOffset,
        setByIndices,
        get,
        getByOffset,
        getByIndices,
        // isVec4,
        usage,
        name,
        strides,
        shape,
        rank
      };
    };
    inputVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "input", components);
    outputVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "output", components);
    internalVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "internal", components);
    ShaderHelperImpl = class {
      constructor(normalizedDispatchGroup, limits) {
        this.normalizedDispatchGroup = normalizedDispatchGroup;
        this.limits = limits;
        this.internalVariables = [];
        this.variables = [];
        this.uniforms = [];
        this.variableIndex = 0;
      }
      guardAgainstOutOfBoundsWorkgroupSizes(size) {
        const sizeInCode = typeof size === "number" ? `${size}u` : size;
        return `if (global_idx >= ${sizeInCode}) { return; }`;
      }
      mainStart(workgroupSize = WORKGROUP_SIZE) {
        const workgroupSizeX = typeof workgroupSize === "number" ? workgroupSize : workgroupSize[0];
        const workgroupSizeY = typeof workgroupSize === "number" ? 1 : workgroupSize[1];
        const workgroupSizeZ = typeof workgroupSize === "number" ? 1 : workgroupSize[2];
        if (workgroupSizeX > this.limits.maxComputeWorkgroupSizeX || workgroupSizeY > this.limits.maxComputeWorkgroupSizeY || workgroupSizeZ > this.limits.maxComputeWorkgroupSizeZ) {
          throw new Error(`workgroup size [${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);
        }
        if (workgroupSizeX * workgroupSizeY * workgroupSizeZ > this.limits.maxComputeInvocationsPerWorkgroup) {
          throw new Error(`workgroup size [${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);
        }
        const is1DimensionDispatch = this.normalizedDispatchGroup[1] === 1 && this.normalizedDispatchGroup[2] === 1;
        const paramList = is1DimensionDispatch ? `@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_id) local_id : vec3<u32>` : `@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`;
        const globalIdxDefinition = is1DimensionDispatch ? "let global_idx = global_id.x; let local_idx = local_id.x;" : `let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${workgroupSizeX * workgroupSizeY * workgroupSizeZ}u + local_idx;`;
        return `@compute @workgroup_size(${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ})
  fn main(${paramList}) {
    ${globalIdxDefinition}
  `;
      }
      appendVariableUniforms(variable) {
        if (variable.rank !== 0) {
          if (variable.shape.startsWith("uniforms.")) {
            this.uniforms.push({ name: variable.shape.replace("uniforms.", ""), type: "u32", length: variable.rank });
          }
          if (variable.strides.startsWith("uniforms.")) {
            this.uniforms.push({ name: variable.strides.replace("uniforms.", ""), type: "u32", length: variable.rank });
          }
        }
      }
      declareVariable(variable, bindingIndex) {
        if (variable.usage === "internal") {
          throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");
        }
        this.variables.push(variable);
        this.appendVariableUniforms(variable);
        const access = variable.usage === "input" ? "read" : "read_write";
        const storageType = variable.type.storage;
        return `@group(0) @binding(${bindingIndex}) var<storage, ${access}> ${variable.name}: array<${storageType}>;`;
      }
      declareVariables(...variables) {
        return variables.map((v) => this.declareVariable(v, this.variableIndex++)).join("\n");
      }
      registerInternalVariable(variable) {
        if (variable.usage !== "internal") {
          throw new Error(
            "cannot use input or output variable with registerInternalVariable(). use declareVariables() instead."
          );
        }
        this.internalVariables.push(variable);
        this.appendVariableUniforms(variable);
      }
      registerInternalVariables(...variables) {
        variables.forEach((v) => this.registerInternalVariable(v));
        return this;
      }
      registerUniform(name, type, length = 1) {
        this.uniforms.push({ name, type, length });
        return this;
      }
      registerUniforms(additionalUniforms) {
        this.uniforms = this.uniforms.concat(additionalUniforms);
        return this;
      }
      uniformDeclaration() {
        if (this.uniforms.length === 0) {
          return "";
        }
        const uniformSnippets = [];
        for (const { name, type, length } of this.uniforms) {
          if (length && length > 4) {
            if (type === "f16") {
              uniformSnippets.push(`@align(16) ${name}:array<mat2x4<${type}>, ${Math.ceil(length / 8)}>`);
            } else {
              uniformSnippets.push(`${name}:array<vec4<${type}>, ${Math.ceil(length / 4)}>`);
            }
          } else {
            const typeTemp = length == null || length === 1 ? type : `vec${length}<${type}>`;
            uniformSnippets.push(`${name}:${typeTemp}`);
          }
        }
        return `
      struct Uniforms { ${uniformSnippets.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`;
      }
      /**
       * Get additional implementation that needs to be added to the shader source.
       */
      get additionalImplementations() {
        return this.uniformDeclaration() + this.variables.map((i) => i.impl()).join("\n") + this.internalVariables.map((i) => i.impl()).join("\n");
      }
      /**
       * Get the variable info of the shader program.
       */
      get variablesInfo() {
        if (this.uniforms.length === 0) {
          return void 0;
        }
        const uniformWgslTypeToDataType = (type) => [
          12 /* uint32 */,
          10 /* float16 */,
          1 /* float */,
          6 /* int32 */
        ][["u32", "f16", "f32", "i32"].indexOf(type)];
        return this.uniforms.map((u) => [uniformWgslTypeToDataType(u.type), u.length ?? 1]);
      }
    };
    createShaderHelper = (dispatchGroup, limits) => new ShaderHelperImpl(dispatchGroup, limits);
    getBroadcastDims = (inShape, outShape) => {
      const inRank = inShape.length;
      const dims = [];
      for (let i = 0; i < inRank; i++) {
        const dim = inRank - 1 - i;
        const a = inShape[dim] || 1;
        const b = outShape[outShape.length - 1 - i] || 1;
        if (b > 1 && a === 1) {
          dims.unshift(dim);
        }
      }
      return dims;
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/transpose.ts
var validateInputs, getAdjustedPerm, getOutputShape, permFunctionBody, createTransposeProgramInfo, transpose, parseTransposeAttributes;
var init_transpose = __esm({
  "web/lib/wasm/jsep/webgpu/ops/transpose.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Transpose requires 1 input.");
      }
    };
    getAdjustedPerm = (inputRank, perm) => perm && perm.length !== inputRank ? [...new Array(inputRank).keys()].reverse() : perm;
    getOutputShape = (inputShape, perm) => ShapeUtil.sortBasedOnPerm(inputShape, getAdjustedPerm(inputShape.length, perm));
    permFunctionBody = (perm, rank, input, output) => {
      const reverseFunc = [];
      reverseFunc.push(`fn perm(i: ${output.type.indices}) -> ${input.type.indices} {
    var a: ${input.type.indices};`);
      for (let i = 0; i < rank; ++i) {
        reverseFunc.push(input.indicesSet("a", perm[i], `i[${i}]`));
      }
      reverseFunc.push("return a;}");
      return reverseFunc.join("\n");
    };
    createTransposeProgramInfo = (inputTensor, permAttr) => {
      const inputDataType = inputTensor.dataType;
      const inputRank = inputTensor.dims.length;
      const perm = getAdjustedPerm(inputRank, permAttr);
      const outputShape = getOutputShape(inputTensor.dims, perm);
      const output = outputVariable("output", inputDataType, outputShape.length);
      const input = inputVariable("a", inputDataType, inputRank);
      let getShaderSource;
      if (perm.length === 2 && perm[0] === 1 && perm[1] === 0) {
        const wgslType = output.type.value;
        const workgroupSize = [16, 16, 1];
        getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}
  var<workgroup> tile : array<array<${wgslType}, ${workgroupSize[0] + 1}>, ${workgroupSize[0]}>;
  ${shaderHelper.mainStart(workgroupSize)}
    var x = workgroup_id.x * ${workgroupSize[0]}u + local_id.x;
    var y = workgroup_id.y * ${workgroupSize[0]}u + local_id.y;
    let width = uniforms.output_shape[0];
    let height = uniforms.output_shape[1];
    if (x < width && y < height) {
      tile[local_id.y][local_id.x] = ${input.getByOffset("y * width + x")};
    }
    workgroupBarrier();
    x = workgroup_id.y * ${workgroupSize[0]}u + local_id.x;
    y = workgroup_id.x * ${workgroupSize[0]}u + local_id.y;
    if (x < height && y < width) {
      ${output.setByOffset("y * height + x", "tile[local_id.x][local_id.y]")}
    }
  }`;
      } else {
        getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}

  ${permFunctionBody(perm, inputRank, input, output)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${output.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${output.setByOffset("global_idx", input.getByIndices("aIndices"))}
  }`;
      }
      return {
        name: "Transpose",
        shaderCache: { hint: `${permAttr}`, inputDependencies: ["rank"] },
        getRunData: (inputs) => {
          const outputSize = ShapeUtil.size(outputShape);
          return {
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [{ type: 12 /* uint32 */, data: outputSize }, ...createTensorShapeVariables(inputs[0].dims, outputShape)]
          };
        },
        getShaderSource
      };
    };
    transpose = (context, attributes) => {
      validateInputs(context.inputs);
      context.compute(createTransposeProgramInfo(context.inputs[0], attributes.perm));
    };
    parseTransposeAttributes = (attributes) => createAttributeWithCacheKey({ perm: attributes.perm });
  }
});

// web/lib/wasm/jsep/webgpu/ops/reduce-shared.ts
var reduceOps, reduceSharedOps, reduceInitValues, reduceOutputValues, getInnerMostAxes, computeOutAndReduceShapes, expandShapeToKeepDim, areAxesInnerMostDims, getAxesPermutation, createReduceSharedProgramInfo, reduceCommon, reduceMeanShared, reduceL1Shared, reduceL2Shared, reduceLogSumExpShared, reduceMaxShared, reduceMinShared, reduceProdShared, reduceSumShared, reduceSumSquareShared, reduceLogSumShared;
var init_reduce_shared = __esm({
  "web/lib/wasm/jsep/webgpu/ops/reduce-shared.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    init_reduce();
    init_transpose();
    reduceOps = {
      max: "select(bestValue, candidate, candidate > bestValue)",
      min: "select(bestValue, candidate, candidate < bestValue)",
      mean: "bestValue + candidate",
      sum: "bestValue + candidate",
      prod: "bestValue * candidate",
      sumSquare: "bestValue + candidate * candidate",
      logSumExp: "bestValue + exp(candidate)",
      l1: "bestValue + abs(candidate)",
      l2: "bestValue + candidate * candidate",
      logSum: "bestValue + candidate"
    };
    reduceSharedOps = {
      max: "select(bestValue, candidate, candidate > bestValue)",
      min: "select(bestValue, candidate, candidate < bestValue)",
      mean: "bestValue + candidate",
      sum: "bestValue + candidate",
      prod: "bestValue * candidate",
      sumSquare: "bestValue + candidate",
      logSumExp: "bestValue + candidate",
      l1: "bestValue + candidate",
      l2: "bestValue + candidate",
      logSum: "bestValue + candidate"
    };
    reduceInitValues = {
      max: "_A[offset]",
      min: "_A[offset]",
      mean: "0",
      sum: "0",
      prod: "1",
      sumSquare: "0",
      logSumExp: "0",
      l1: "0",
      l2: "0",
      logSum: "0"
    };
    reduceOutputValues = {
      max: "bestValue",
      min: "bestValue",
      sum: "bestValue",
      prod: "bestValue",
      sumSquare: "bestValue",
      logSumExp: "log(bestValue)",
      l1: "bestValue",
      l2: "sqrt(bestValue)",
      logSum: "log(bestValue)"
    };
    getInnerMostAxes = (numInnerAxes, rank) => {
      const res = [];
      for (let i = rank - numInnerAxes; i < rank; ++i) {
        res.push(i);
      }
      return res;
    };
    computeOutAndReduceShapes = (shape, axes) => {
      const outputShape = [];
      const rank = shape.length;
      for (let dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
          outputShape.push(shape[dim]);
        }
      }
      const reduceShape = axes.map((dim) => shape[dim]);
      return [outputShape, reduceShape];
    };
    expandShapeToKeepDim = (shape, axes) => {
      const rank = shape.length + axes.length;
      const expandShape = [];
      let shapeIdx = 0;
      for (let dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
          expandShape.push(shape[shapeIdx++]);
        } else {
          expandShape.push(1);
        }
      }
      return expandShape;
    };
    areAxesInnerMostDims = (axes, rank) => {
      for (let i = 0; i < axes.length; ++i) {
        if (axes[axes.length - i - 1] !== rank - 1 - i) {
          return false;
        }
      }
      return true;
    };
    getAxesPermutation = (axes, rank) => {
      const res = [];
      if (!areAxesInnerMostDims(axes, rank)) {
        for (let i = 0; i < rank; ++i) {
          if (axes.indexOf(i) === -1) {
            res.push(i);
          }
        }
        axes.forEach((axis) => res.push(axis));
      }
      return res;
    };
    createReduceSharedProgramInfo = (name, shaderCache, inputs, reduceType, outputDataType, outputShape, reduceShape) => {
      const inputShape = inputs[0].dims;
      const outputSize = ShapeUtil.size(outputShape);
      const reduceSize = ShapeUtil.size(reduceShape);
      const input = inputVariable("_A", inputs[0].dataType, inputShape);
      const output = outputVariable("output", outputDataType, outputShape);
      const workgroupSize = 32;
      const sharedMemorySnippet = `
          var<workgroup> aBestValues : array<f32, ${workgroupSize}>;
       `;
      const getShaderSource = (shaderHelper) => `
        ${shaderHelper.registerUniform("reduceSize", "u32").declareVariables(input, output)}
        ${sharedMemorySnippet}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${shaderHelper.mainStart(workgroupSize)}

          let outputIndex = global_idx / ${workgroupSize};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${reduceInitValues[reduceType]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${workgroupSize}) {
           let candidate = f32(${input.getByOffset("offset + k")});
           bestValue = ${reduceOps[reduceType]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${workgroupSize}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${reduceSharedOps[reduceType]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${output.setByOffset(
        "outputIndex",
        `${reduceType === "mean" ? `${output.type.storage}(bestValue / f32(uniforms.reduceSize))` : `${output.type.storage}(${reduceOutputValues[reduceType]})`}`
      )};
         }
        }`;
      return {
        name,
        shaderCache,
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: outputDataType }],
          dispatchGroup: { x: outputSize },
          programUniforms: [{ type: 12 /* uint32 */, data: reduceSize }]
        })
      };
    };
    reduceCommon = (context, name, attributes, reduceType) => {
      const updatedAttributes = context.inputs.length === 1 ? attributes : createReduceAttributesFromInputs(context.inputs, attributes);
      let updatedAxes = updatedAttributes.axes;
      if (updatedAxes.length === 0 && !updatedAttributes.noopWithEmptyAxes) {
        updatedAxes = context.inputs[0].dims.map((_dim, i) => i);
      }
      const normalizeAxes = ShapeUtil.normalizeAxes(updatedAxes, context.inputs[0].dims.length);
      let axes = normalizeAxes;
      let input = context.inputs[0];
      const permutedAxes = getAxesPermutation(axes, context.inputs[0].dims.length);
      if (permutedAxes.length > 0) {
        input = context.compute(
          createTransposeProgramInfo(context.inputs[0], permutedAxes),
          { inputs: [0], outputs: [-1] }
        )[0];
        axes = getInnerMostAxes(axes.length, input.dims.length);
      }
      const [outputShape, reduceShape] = computeOutAndReduceShapes(input.dims, axes);
      let finalOutputShape = outputShape;
      if (updatedAttributes.keepDims) {
        finalOutputShape = expandShapeToKeepDim(outputShape, normalizeAxes);
      }
      context.compute(
        createReduceSharedProgramInfo(
          name,
          { hint: updatedAttributes.cacheKey, inputDependencies: ["type"] },
          [input],
          reduceType,
          context.inputs[0].dataType,
          finalOutputShape,
          reduceShape
        ),
        { inputs: [input] }
      );
    };
    reduceMeanShared = (context, attributes) => {
      reduceCommon(context, "ReduceMeanShared", attributes, "mean");
    };
    reduceL1Shared = (context, attributes) => {
      reduceCommon(context, "ReduceL1Shared", attributes, "l1");
    };
    reduceL2Shared = (context, attributes) => {
      reduceCommon(context, "ReduceL2Shared", attributes, "l2");
    };
    reduceLogSumExpShared = (context, attributes) => {
      reduceCommon(context, "ReduceLogSumExpShared", attributes, "logSumExp");
    };
    reduceMaxShared = (context, attributes) => {
      reduceCommon(context, "ReduceMaxShared", attributes, "max");
    };
    reduceMinShared = (context, attributes) => {
      reduceCommon(context, "ReduceMinShared", attributes, "min");
    };
    reduceProdShared = (context, attributes) => {
      reduceCommon(context, "ReduceProdShared", attributes, "prod");
    };
    reduceSumShared = (context, attributes) => {
      reduceCommon(context, "ReduceSumShared", attributes, "sum");
    };
    reduceSumSquareShared = (context, attributes) => {
      reduceCommon(context, "ReduceSumSquareShared", attributes, "sumSquare");
    };
    reduceLogSumShared = (context, attributes) => {
      reduceCommon(context, "ReduceLogSumShared", attributes, "logSum");
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/reduce.ts
var validateInputs2, noOp, createReduceProgramInfo, createReduceAttributesFromInputs, runReduceProgram, reduceLogSumNaive, reduceL1Naive, reduceL2Naive, reduceLogSumExpNaive, reduceMaxNaive, reduceMeanNaive, reduceMinNaive, reduceProdNaive, reduceSumNaive, reduceSumSquareNaive, useNaiveReduceMethod, reduceMean, reduceL1, reduceL2, reduceLogSumExp, reduceMax, reduceMin, reduceProd, reduceSum, reduceSumSquare, reduceLogSum;
var init_reduce = __esm({
  "web/lib/wasm/jsep/webgpu/ops/reduce.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    init_reduce_shared();
    validateInputs2 = (inputs) => {
      if (!inputs || inputs.length === 0 || inputs.length > 2) {
        throw new Error("Reduce op requires 1 or 2 inputs.");
      }
      if (inputs.length === 2 && inputs[1].dims.length !== 1) {
        throw new Error("Invalid axes input dims.");
      }
    };
    noOp = (input) => ["", "", `var value = ${input.getByIndices("input_indices")};`, ""];
    createReduceProgramInfo = (name, shaderCache, inputs, reduceOp, axesInput, outputDataType, keepDims = false, noopWithEmptyAxes = false) => {
      const outputShape = [];
      const inputShape = inputs[0].dims;
      const inputRank = inputShape.length;
      const axes = ShapeUtil.normalizeAxes(axesInput, inputRank);
      const reduceOnAllAxes = !noopWithEmptyAxes && axes.length === 0;
      inputShape.forEach((d, i) => {
        if (reduceOnAllAxes || axes.indexOf(i) >= 0) {
          if (keepDims) {
            outputShape.push(1);
          }
        } else {
          outputShape.push(d);
        }
      });
      const outputRank = outputShape.length;
      const outputSize = ShapeUtil.size(outputShape);
      const getShaderSource = (shaderHelper) => {
        const idxCopy = [];
        const input = inputVariable("_A", inputs[0].dataType, inputRank);
        const output = outputVariable("output", outputDataType, outputRank);
        const ops = reduceOp(input, output, axes);
        let reduceOps2 = ops[2];
        for (let k = 0, l = 0; k < inputRank; k++) {
          if (reduceOnAllAxes || axes.indexOf(k) >= 0) {
            if (keepDims) {
              l++;
            }
            reduceOps2 = `for(var j${k}: u32 = 0; j${k} < ${inputShape[k]}; j${k}++) {
                  ${ops[2].includes("last_index") ? `let last_index = j${k};` : ""}
                  ${input.indicesSet("input_indices", k, `j${k}`)}
                  ${reduceOps2}
                }`;
          } else {
            idxCopy.push(`${input.indicesSet("input_indices", k, output.indicesGet("output_indices", l))};`);
            l++;
          }
        }
        return `

        ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}

        ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${input.type.indices};
          let output_indices = ${output.offsetToIndices("global_idx")};

          ${idxCopy.join("\n")}
          ${ops[0]}       // init ops for reduce max/min
          ${ops[1]}
          ${reduceOps2}
          ${ops[3]}
          ${ops.length === 4 ? output.setByOffset("global_idx", "value") : ops.slice(4).join("\n")}
        }`;
      };
      return {
        name,
        shaderCache,
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: outputDataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms: [{ type: 12 /* uint32 */, data: outputSize }, ...createTensorShapeVariables(inputShape, outputShape)]
        })
      };
    };
    createReduceAttributesFromInputs = (inputs, attributes) => {
      const axes = [];
      if (inputs[1].dims[0] > 0) {
        inputs[1].getBigInt64Array().forEach((v) => axes.push(Number(v)));
      }
      return createAttributeWithCacheKey(
        { axes, keepDims: attributes.keepDims, noopWithEmptyAxes: attributes.noopWithEmptyAxes }
      );
    };
    runReduceProgram = (context, name, attributes, reduceOp) => {
      const inputs = context.inputs;
      const updatedAttributes = inputs.length === 1 ? attributes : createReduceAttributesFromInputs(inputs, attributes);
      context.compute(
        createReduceProgramInfo(
          name,
          { hint: updatedAttributes.cacheKey, inputDependencies: ["rank"] },
          [inputs[0]],
          updatedAttributes.noopWithEmptyAxes && updatedAttributes.axes.length === 0 ? noOp : reduceOp,
          updatedAttributes.axes,
          inputs[0].dataType,
          updatedAttributes.keepDims,
          updatedAttributes.noopWithEmptyAxes
        ),
        { inputs: [0] }
      );
    };
    reduceLogSumNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var value = ${output.type.storage}(0);`,
        "",
        `value += ${input.getByIndices("input_indices")};`,
        "value = log(value);"
      ];
      runReduceProgram(context, "ReduceLogSum", attributes, reduceOp);
    };
    reduceL1Naive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var value = ${output.type.storage}(0);`,
        "",
        `value += abs(${input.getByIndices("input_indices")});`,
        ""
      ];
      runReduceProgram(context, "ReduceL1", attributes, reduceOp);
    };
    reduceL2Naive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var t = ${output.type.value}(0); var value = ${output.type.value}(0);`,
        "",
        `t = ${input.getByIndices("input_indices")}; value += (t * t);`,
        "value = sqrt(value);"
      ];
      runReduceProgram(context, "ReduceL2", attributes, reduceOp);
    };
    reduceLogSumExpNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var value = ${output.type.storage}(0);`,
        "",
        `value += exp(${input.getByIndices("input_indices")});`,
        "value = log(value);"
      ];
      runReduceProgram(context, "ReduceLogSumExp", attributes, reduceOp);
    };
    reduceMaxNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, _output, axes) => {
        const idxZero = [];
        for (let k = 0; k < input.rank; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            idxZero.push(input.indicesSet("input_indices", k, 0));
          }
        }
        return [
          `${idxZero.join("\n")}`,
          `var value = ${input.getByIndices("input_indices")};`,
          `value = max(value, ${input.getByIndices("input_indices")});`,
          ""
        ];
      };
      runReduceProgram(context, "ReduceMax", attributes, reduceOp);
    };
    reduceMeanNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output, axes) => {
        let size = 1;
        for (let k = 0; k < input.rank; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            size *= context.inputs[0].dims[k];
          }
        }
        return [
          "var sum = f32(0);",
          "",
          `sum += f32(${input.getByIndices("input_indices")});`,
          `let value = ${output.type.value}(sum / ${size});`
        ];
      };
      runReduceProgram(context, "ReduceMean", attributes, reduceOp);
    };
    reduceMinNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, _output, axes) => {
        const idxZero = [];
        for (let k = 0; k < input.rank; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            idxZero.push(`input_indices[${k}] = 0;`);
          }
        }
        return [
          `${idxZero.join("\n")}`,
          `var value = ${input.getByIndices("input_indices")};`,
          `value = min(value, ${input.getByIndices("input_indices")});`,
          ""
        ];
      };
      runReduceProgram(context, "ReduceMin", attributes, reduceOp);
    };
    reduceProdNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var value = ${output.type.storage}(1);`,
        "",
        `value *= ${input.getByIndices("input_indices")};`,
        ""
      ];
      runReduceProgram(context, "ReduceProd", attributes, reduceOp);
    };
    reduceSumNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var value = ${output.type.storage}(0);`,
        "",
        `value += ${input.getByIndices("input_indices")};`,
        ""
      ];
      runReduceProgram(context, "ReduceSum", attributes, reduceOp);
    };
    reduceSumSquareNaive = (context, attributes) => {
      validateInputs2(context.inputs);
      const reduceOp = (input, output) => [
        `var t = ${output.type.value}(0); var value = ${output.type.value}(0);`,
        "",
        `t = ${input.getByIndices("input_indices")}; value += t * t;`,
        ""
      ];
      runReduceProgram(context, "ReduceSumSquare", attributes, reduceOp);
    };
    useNaiveReduceMethod = (shape, axes, noopWithEmptyAxes) => {
      if (axes.length === 0) {
        return noopWithEmptyAxes;
      }
      let outputSize = 1;
      let reduceSize = 1;
      for (let dim = 0; dim < axes.length; dim++) {
        if (axes.indexOf(dim) === -1) {
          outputSize *= shape[dim];
        } else {
          reduceSize *= shape[dim];
        }
      }
      return reduceSize < 32 && outputSize > 1024;
    };
    reduceMean = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceMeanNaive(context, attributes);
      } else {
        reduceMeanShared(context, attributes);
      }
    };
    reduceL1 = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceL1Naive(context, attributes);
      } else {
        reduceL1Shared(context, attributes);
      }
    };
    reduceL2 = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceL2Naive(context, attributes);
      } else {
        reduceL2Shared(context, attributes);
      }
    };
    reduceLogSumExp = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceLogSumExpNaive(context, attributes);
      } else {
        reduceLogSumExpShared(context, attributes);
      }
    };
    reduceMax = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceMaxNaive(context, attributes);
      } else {
        reduceMaxShared(context, attributes);
      }
    };
    reduceMin = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceMinNaive(context, attributes);
      } else {
        reduceMinShared(context, attributes);
      }
    };
    reduceProd = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceProdNaive(context, attributes);
      } else {
        reduceProdShared(context, attributes);
      }
    };
    reduceSum = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceSumNaive(context, attributes);
      } else {
        reduceSumShared(context, attributes);
      }
    };
    reduceSumSquare = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceSumSquareNaive(context, attributes);
      } else {
        reduceSumSquareShared(context, attributes);
      }
    };
    reduceLogSum = (context, attributes) => {
      if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
        reduceLogSumNaive(context, attributes);
      } else {
        reduceLogSumShared(context, attributes);
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/argminmax.ts
var validateInputs3, argMin, argMax, parseArgMinMaxAttributes;
var init_argminmax = __esm({
  "web/lib/wasm/jsep/webgpu/ops/argminmax.ts"() {
    "use strict";
    init_wasm_common();
    init_attribute_with_cache_key();
    init_reduce();
    validateInputs3 = (inputs) => {
      if (!inputs || inputs.length === 0 || inputs.length > 2) {
        throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");
      }
      if (inputs[0].dataType !== 1 /* float */) {
        throw new Error("Invalid input type.");
      }
    };
    argMin = (context, attributes) => {
      validateInputs3(context.inputs);
      const argMinMaxOp = (input, output, axes) => {
        const idxZero = [];
        for (let k = 0; k < input.rank; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            idxZero.push(`input_indices[${k}] = 0;`);
          }
        }
        return [
          `${idxZero.join("\n")}`,
          `var value = ${input.getByIndices("input_indices")};
var best_index : i32 = 0;`,
          `if (${input.getByIndices("input_indices")} ${attributes.selectLastIndex > 0 ? "<=" : "<"} value) {
         value = ${input.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,
          "",
          output.setByOffset("global_idx", "best_index")
        ];
      };
      context.compute(
        createReduceProgramInfo(
          "ArgMin",
          { hint: attributes.cacheKey, inputDependencies: ["rank"] },
          [context.inputs[0]],
          argMinMaxOp,
          [attributes.axis],
          7 /* int64 */,
          attributes.keepDims
        ),
        { inputs: [0] }
      );
    };
    argMax = (context, attributes) => {
      validateInputs3(context.inputs);
      const argMinMaxOp = (input, output, axes) => {
        const idxZero = [];
        for (let k = 0; k < input.rank; k++) {
          if (axes.indexOf(k) >= 0 || axes.length === 0) {
            idxZero.push(`input_indices[${k}] = 0;`);
          }
        }
        return [
          `${idxZero.join("\n")}`,
          `var value = ${input.getByIndices("input_indices")};
var best_index : i32 = 0;`,
          `if (${input.getByIndices("input_indices")} ${attributes.selectLastIndex > 0 ? ">=" : ">"} value) {
         value = ${input.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,
          "",
          output.setByOffset("global_idx", "best_index")
        ];
      };
      context.compute(
        createReduceProgramInfo(
          "argMax",
          { hint: attributes.cacheKey, inputDependencies: ["rank"] },
          [context.inputs[0]],
          argMinMaxOp,
          [attributes.axis],
          7 /* int64 */,
          attributes.keepDims
        ),
        { inputs: [0] }
      );
    };
    parseArgMinMaxAttributes = (attributes) => createAttributeWithCacheKey(attributes);
  }
});

// web/lib/wasm/jsep/webgpu/ops/attention.ts
var validateAttentionInputs, createInPlaceSoftmaxProgramInfo, createAttentionProbsProgramInfo, createVxAttentionScoreProgramInfo, applyAttention, prepare, attention;
var init_attention = __esm({
  "web/lib/wasm/jsep/webgpu/ops/attention.ts"() {
    "use strict";
    init_wasm_common();
    init_types();
    init_common();
    validateAttentionInputs = (inputs, attributes) => {
      const input = inputs[0];
      const weights = inputs[1];
      const bias = inputs[2];
      const maskIndex = inputs[3];
      const past = inputs[4];
      const relativePositionBias = inputs[5];
      if (past && relativePositionBias) {
        throw new Error("Attention cannot have both past and relative_position_bias");
      }
      if (input.dims.length !== 3) {
        throw new Error('Input "input" must have 3 dimensions');
      }
      const batchSize = input.dims[0];
      const sequenceLength = input.dims[1];
      const inputHiddenSize = input.dims[2];
      if (bias.dims.length !== 1) {
        throw new Error('Input "bias" is expected to have 1 dimensions');
      }
      if (weights.dims.length !== 2) {
        throw new Error('Input "weights" is expected to have 2 dimensions');
      }
      if (weights.dims[0] !== inputHiddenSize) {
        throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");
      }
      if (bias.dims[0] !== weights.dims[1]) {
        throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');
      }
      let qHiddenSize = bias.dims[0] / 3;
      let kHiddenSize = qHiddenSize;
      let vHiddenSize = kHiddenSize;
      if (attributes.qkvHiddenSizes.length > 0) {
        if (attributes.qkvHiddenSizes.length !== 3) {
          throw new Error("qkv_hidden_sizes attribute should have 3 elements");
        }
        for (const sz of attributes.qkvHiddenSizes) {
          if (sz % attributes.numHeads !== 0) {
            throw new Error("qkv_hidden_sizes should be divisible by num_heads");
          }
        }
        qHiddenSize = attributes.qkvHiddenSizes[0];
        kHiddenSize = attributes.qkvHiddenSizes[1];
        vHiddenSize = attributes.qkvHiddenSizes[2];
      }
      const kvSequenceLength = sequenceLength;
      if (qHiddenSize !== kHiddenSize) {
        throw new Error("qkv_hidden_sizes first element should be same as the second");
      }
      if (bias.dims[0] !== qHiddenSize + kHiddenSize + vHiddenSize) {
        throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');
      }
      let pastSequenceLength = 0;
      if (past) {
        if (kHiddenSize !== vHiddenSize) {
          throw new Error('Input "past" expect k_hidden_size == v_hidden_size');
        }
        if (past.dims.length !== 5) {
          throw new Error('Input "past" must have 5 dimensions');
        }
        if (past.dims[0] !== 2) {
          throw new Error('Input "past" first dimension must be 2');
        }
        if (past.dims[1] !== batchSize) {
          throw new Error('Input "past" second dimension must be batch_size');
        }
        if (past.dims[2] !== attributes.numHeads) {
          throw new Error('Input "past" third dimension must be num_heads');
        }
        if (past.dims[4] !== kHiddenSize / attributes.numHeads) {
          throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');
        }
        if (!attributes.pastPresentShareBuffer) {
          pastSequenceLength = past.dims[3];
        }
      }
      const totalSequenceLength = kvSequenceLength + pastSequenceLength;
      const maxSequenceLength = -1;
      const maskType = 0 /* none */;
      if (maskIndex) {
        throw new Error("Mask not supported");
      }
      if (past) {
        throw new Error("past is not supported");
      }
      return {
        batchSize,
        sequenceLength,
        pastSequenceLength,
        kvSequenceLength,
        totalSequenceLength,
        maxSequenceLength,
        inputHiddenSize,
        hiddenSize: qHiddenSize,
        vHiddenSize,
        headSize: Math.floor(qHiddenSize / attributes.numHeads),
        vHeadSize: Math.floor(vHiddenSize / attributes.numHeads),
        numHeads: attributes.numHeads,
        isUnidirectional: false,
        pastPresentShareBuffer: false,
        maskFilterValue: attributes.maskFilterValue,
        maskType,
        scale: attributes.scale,
        broadcastResPosBias: false,
        passPastInKv: false,
        qkvFormat: 1 /* qkvBNSH */
      };
    };
    createInPlaceSoftmaxProgramInfo = (_context, input, n, d) => {
      const components = getMaxComponents(d);
      let WG = 64;
      const dComp = d / components;
      if (dComp < WG) {
        WG = 1;
      } else if (dComp / 8 < 64) {
        WG = Math.ceil(dComp / 8);
      }
      const elementsPerThread = Math.ceil(d / components / WG);
      const programUniforms = [
        { type: input.dataType, data: 1 / d },
        { type: 12 /* uint32 */, data: dComp },
        { type: 12 /* uint32 */, data: elementsPerThread }
      ];
      const dataType = tensorTypeToWsglStorageType(input.dataType, components);
      const f32Type = tensorTypeToWsglValueType(1 /* float */, components);
      const getShaderSource = (shaderHelper) => {
        const inputHelper = outputVariable("x", input.dataType, input.dims, components);
        const elemValueType = tensorTypeToWsglValueType(input.dataType);
        const uniforms = [
          { name: "d_inv", type: elemValueType },
          { name: "d_comp", type: "u32" },
          { name: "elements_per_thread", type: "u32" }
        ];
        return `
  var<workgroup> thread_max: array<f32, ${WG}>;
  var<workgroup> thread_sum: array<f32, ${WG}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(inputHelper)}
  ${shaderHelper.mainStart([
          WG,
          1,
          1
        ])}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = workgroup_id.x * uniforms.d_comp + local_offset;

    var thread_max_vector = ${f32Type}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
      thread_max_vector = max(${f32Type}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(() => {
          switch (components) {
            case 1:
              return "thread_max_vector";
            case 2:
              return "max(thread_max_vector.x, thread_max_vector.y)";
            case 4:
              return "max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";
            default:
              throw new Error(`Unsupported components: ${components}`);
          }
        })()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${WG}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${f32Type}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
      sum_vector += exp(${f32Type}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(() => {
          switch (components) {
            case 1:
              return "sum_vector";
            case 2:
              return "sum_vector.x + sum_vector.y";
            case 4:
              return "sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";
            default:
              throw new Error(`Unsupported components: ${components}`);
          }
        })()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${WG}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
        x[offset + i] = ${inputHelper.type.value}(uniforms.d_inv);
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
        var f32input = ${f32Type}(x[offset + i]);
        x[offset + i] = ${inputHelper.type.value}(exp(f32input - max_value) / sum);
      }
    }
  }`;
      };
      return {
        name: "AttentionProbsSoftmax",
        shaderCache: { hint: `${WG};${dataType};${components}` },
        getShaderSource,
        getRunData: () => ({ outputs: [], dispatchGroup: { x: n }, programUniforms })
      };
    };
    createAttentionProbsProgramInfo = (context, q, key, pastKey, relativePositionBias, parameters, attributes, pastSequenceLength) => {
      const totalSequenceLength = pastSequenceLength + parameters.kvSequenceLength;
      const probsShape = [parameters.batchSize, parameters.numHeads, parameters.sequenceLength, totalSequenceLength];
      const presentKey = parameters.kvNumHeads === void 0 && context.outputCount > 1;
      const presentKeyShape = presentKey ? [parameters.batchSize, parameters.numHeads, totalSequenceLength, parameters.headSize] : void 0;
      const alpha = attributes.scale === 0 ? 1 / Math.sqrt(parameters.headSize) : attributes.scale;
      const components = getMaxComponents(parameters.headSize);
      const vectorizedHeadSize = parameters.headSize / components;
      const TILE_SIZE = 12;
      const dispatch = {
        x: Math.ceil(totalSequenceLength / TILE_SIZE),
        y: Math.ceil(parameters.sequenceLength / TILE_SIZE),
        z: parameters.batchSize * parameters.numHeads
      };
      const programUniforms = [
        { type: 12 /* uint32 */, data: parameters.sequenceLength },
        { type: 12 /* uint32 */, data: vectorizedHeadSize },
        { type: 12 /* uint32 */, data: totalSequenceLength },
        { type: 12 /* uint32 */, data: parameters.numHeads },
        { type: 1 /* float */, data: alpha },
        { type: 12 /* uint32 */, data: pastSequenceLength },
        { type: 12 /* uint32 */, data: parameters.kvSequenceLength }
      ];
      const inputDependencies = ["type", "type"];
      if (pastKey) {
        inputDependencies.push("type");
      }
      if (relativePositionBias) {
        inputDependencies.push("type");
      }
      const outputs = [{ dims: probsShape, dataType: q.dataType, gpuDataType: 0 /* default */ }];
      if (presentKey) {
        outputs.push({ dims: presentKeyShape, dataType: q.dataType, gpuDataType: 0 /* default */ });
      }
      const getShaderSource = (shaderHelper) => {
        const qInput = inputVariable("q", q.dataType, q.dims, components);
        const kInput = inputVariable("key", key.dataType, key.dims, components);
        const inputVars = [qInput, kInput];
        if (pastKey) {
          const pastKeyInput = inputVariable("past_key", pastKey.dataType, pastKey.dims, components);
          inputVars.push(pastKeyInput);
        }
        if (relativePositionBias) {
          inputVars.push(
            inputVariable("relative_position_bias", relativePositionBias.dataType, relativePositionBias.dims)
          );
        }
        const output = outputVariable("output", q.dataType, probsShape);
        const outputVars = [output];
        if (presentKey) {
          outputVars.push(outputVariable("present_key", q.dataType, presentKeyShape, components));
        }
        const f32Type = tensorTypeToWsglValueType(1 /* float */, components);
        const uniforms = [
          { name: "M", type: "u32" },
          { name: "K", type: "u32" },
          { name: "N", type: "u32" },
          { name: "num_heads", type: "u32" },
          { name: "alpha", type: "f32" },
          { name: "past_sequence_length", type: "u32" },
          { name: "kv_sequence_length", type: "u32" }
        ];
        return `
  const TILE_SIZE = ${TILE_SIZE}u;

  var<workgroup> tileQ: array<${qInput.type.storage}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileK: array<${qInput.type.storage}, ${TILE_SIZE * TILE_SIZE}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, ...outputVars)}
  ${shaderHelper.mainStart([
          TILE_SIZE,
          TILE_SIZE,
          1
        ])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let qOffset = uniforms.M * uniforms.K * headIdx + m * uniforms.K;
    ${(() => {
          if (pastKey && presentKey) {
            return `
    let kOffset = uniforms.kv_sequence_length * uniforms.K * headIdx;
    let pastKeyOffset = uniforms.past_sequence_length * uniforms.K * headIdx;`;
          } else {
            return `
    let kOffset = uniforms.N * uniforms.K * headIdx + n * uniforms.K;`;
          }
        })()}
    ${presentKey ? "let presentKeyOffset = headIdx * uniforms.N * uniforms.K;" : ""}
    var value = ${f32Type}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${(() => {
          if (pastKey && presentKey) {
            return `
              if (n + local_id.y < uniforms.past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else {
                tileK[idx] =
                         key[kOffset + (n + local_id.y - uniforms.past_sequence_length) * uniforms.K + w + local_id.x];
              }`;
          } else {
            return "tileK[idx] = key[kOffset + local_id.y * uniforms.K + w + local_id.x];";
          }
        })()}
      ${presentKey ? "present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];" : ""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
        value += ${f32Type}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    let headOffset = headIdx * uniforms.M * uniforms.N;
    if (global_id.y < uniforms.M && global_id.x < uniforms.N) {
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(() => {
          switch (components) {
            case 1:
              return "value";
            case 2:
              return "value.x + value.y";
            case 4:
              return "value.x + value.y + value.z + value.w";
            default:
              throw new Error(`Unsupported components: ${components}`);
          }
        })()};
        output[outputIdx] = ${output.type.value} (sum * uniforms.alpha) + ${relativePositionBias ? "relative_position_bias[outputIdx]" : "0.0"};
    }
  }`;
      };
      return {
        name: "AttentionProbs",
        shaderCache: {
          hint: `${components};${relativePositionBias !== void 0};${pastKey !== void 0};${context.outputCount}`,
          inputDependencies
        },
        getRunData: () => ({ outputs, dispatchGroup: dispatch, programUniforms }),
        getShaderSource
      };
    };
    createVxAttentionScoreProgramInfo = (context, probs, v, pastValue, params, pastSequenceLength) => {
      const totalSequenceLength = pastSequenceLength + params.kvSequenceLength;
      const nReps = params.nReps ? params.nReps : 1;
      const repeatedVHiddenSize = params.vHiddenSize * nReps;
      const presentValue = params.kvNumHeads == null && context.outputCount > 1;
      const presentValueShape = presentValue ? [params.batchSize, params.numHeads, totalSequenceLength, params.headSize] : void 0;
      const outputShape = [params.batchSize, params.sequenceLength, repeatedVHiddenSize];
      const TILE_SIZE = 12;
      const dispatch = {
        x: Math.ceil(params.vHeadSize / TILE_SIZE),
        y: Math.ceil(params.sequenceLength / TILE_SIZE),
        z: params.batchSize * params.numHeads
      };
      const programUniforms = [
        { type: 12 /* uint32 */, data: params.sequenceLength },
        { type: 12 /* uint32 */, data: totalSequenceLength },
        { type: 12 /* uint32 */, data: params.vHeadSize },
        { type: 12 /* uint32 */, data: params.numHeads },
        { type: 12 /* uint32 */, data: repeatedVHiddenSize },
        { type: 12 /* uint32 */, data: pastSequenceLength },
        { type: 12 /* uint32 */, data: params.kvSequenceLength }
      ];
      const inputDependencies = pastValue ? ["type", "type", "type"] : ["type", "type"];
      const outputs = [{ dims: outputShape, dataType: probs.dataType, gpuDataType: 0 /* default */ }];
      if (presentValue) {
        outputs.push({ dims: presentValueShape, dataType: probs.dataType, gpuDataType: 0 /* default */ });
      }
      const getShaderSource = (shaderHelper) => {
        const probsHelper = inputVariable("probs", probs.dataType, probs.dims);
        const vHelper = inputVariable("v", v.dataType, v.dims);
        const inputVars = [probsHelper, vHelper];
        if (pastValue) {
          inputVars.push(inputVariable("past_value", pastValue.dataType, pastValue.dims));
        }
        const output = outputVariable("output", probs.dataType, outputShape);
        const outputVars = [output];
        if (presentValue) {
          outputVars.push(outputVariable("present_value", probs.dataType, presentValueShape));
        }
        const uniforms = [
          { name: "M", type: "u32" },
          { name: "K", type: "u32" },
          { name: "N", type: "u32" },
          { name: "num_heads", type: "u32" },
          { name: "v_hidden_size", type: "u32" },
          { name: "past_sequence_length", type: "u32" },
          { name: "kv_sequence_length", type: "u32" }
        ];
        return `
  const TILE_SIZE = ${TILE_SIZE}u;
  var<workgroup> tileQ: array<${probsHelper.type.value}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileK: array<${probsHelper.type.value}, ${TILE_SIZE * TILE_SIZE}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, ...outputVars)}
  ${shaderHelper.mainStart([
          TILE_SIZE,
          TILE_SIZE,
          1
        ])}
   let headIdx = workgroup_id.z;
   let m = global_id.y;
   let n = global_id.x;

   let offsetA = headIdx * (uniforms.M * uniforms.K) + m * uniforms.K;
   ${(() => {
          if (pastValue && presentValue) {
            return `
    let pastValueOffset = headIdx * uniforms.N * uniforms.past_sequence_length + n;
    let vOffset = headIdx * uniforms.N * uniforms.kv_sequence_length + n;
      `;
          } else {
            return `
   let offsetB = headIdx * uniforms.N * uniforms.K + n;
            `;
          }
        })()}
    ${presentValue ? "let presentValueOffset = headIdx * uniforms.N * uniforms.K + n;" : ""}
   var value = ${probsHelper.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${(() => {
          if (pastValue && presentValue) {
            return `
        if (w + local_id.y < uniforms.past_sequence_length) {
          tileK[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else {
          tileK[idx] = v[vOffset + (w + local_id.y - uniforms.past_sequence_length) * uniforms.N];
        }
      `;
          } else {
            return `
        tileK[idx] = v[offsetB + (w + local_id.y) * uniforms.N];
      `;
          }
        })()}
        ${presentValue ? "present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileK[idx];" : ""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let currentBatchHeadNumber = workgroup_id.z % uniforms.num_heads;
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + currentBatchHeadNumber * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`;
      };
      return {
        name: "AttentionScore",
        shaderCache: { hint: `${pastValue !== void 0};${context.outputCount}`, inputDependencies },
        getRunData: () => ({ outputs, dispatchGroup: dispatch, programUniforms }),
        getShaderSource
      };
    };
    applyAttention = (context, q, k, v, _maskIndex, _past, pastKey, pastValue, relativePositionBias, parameters, attributes) => {
      const outputCount = context.outputCount;
      const pastSequenceLength = parameters.kvNumHeads !== void 0 || outputCount > 1 ? parameters.pastSequenceLength : 0;
      const totalSequenceLength = pastSequenceLength + parameters.kvSequenceLength;
      const inputsK = parameters.kvNumHeads === void 0 && outputCount > 1 && pastKey ? [q, k, pastKey] : [q, k];
      if (relativePositionBias) {
        inputsK.push(relativePositionBias);
      }
      const probs = context.compute(
        createAttentionProbsProgramInfo(
          context,
          q,
          k,
          outputCount > 1 ? pastKey : void 0,
          relativePositionBias,
          parameters,
          attributes,
          pastSequenceLength
        ),
        { inputs: inputsK, outputs: parameters.kvNumHeads === void 0 && outputCount > 1 ? [-1, 1] : [-1] }
      )[0];
      context.compute(
        createInPlaceSoftmaxProgramInfo(
          context,
          probs,
          parameters.batchSize * parameters.numHeads * parameters.sequenceLength,
          totalSequenceLength
        ),
        { inputs: [probs], outputs: [] }
      );
      const inputsV = parameters.kvNumHeads === void 0 && outputCount > 1 && pastValue ? [probs, v, pastValue] : [probs, v];
      context.compute(
        createVxAttentionScoreProgramInfo(
          context,
          probs,
          v,
          outputCount > 1 && pastValue ? pastValue : void 0,
          parameters,
          pastSequenceLength
        ),
        { inputs: inputsV, outputs: parameters.kvNumHeads === void 0 && outputCount > 1 ? [0, 2] : [0] }
      );
    };
    prepare = (context, parameters) => {
      const outputShape = [
        parameters.batchSize,
        parameters.numHeads,
        parameters.sequenceLength,
        parameters.headSize
      ];
      const M = parameters.sequenceLength;
      const K = parameters.inputHiddenSize;
      const N = parameters.headSize;
      const TILE_SIZE = 12;
      const dispatch = {
        x: Math.ceil(parameters.headSize / TILE_SIZE),
        y: Math.ceil(parameters.sequenceLength / TILE_SIZE),
        z: parameters.batchSize * parameters.numHeads
      };
      const inputs = [context.inputs[0], context.inputs[1], context.inputs[2]];
      const programUniforms = [
        { type: 12 /* uint32 */, data: M },
        { type: 12 /* uint32 */, data: K },
        { type: 12 /* uint32 */, data: N },
        { type: 12 /* uint32 */, data: parameters.numHeads },
        { type: 12 /* uint32 */, data: parameters.headSize },
        { type: 12 /* uint32 */, data: parameters.hiddenSize },
        { type: 12 /* uint32 */, data: parameters.hiddenSize + parameters.hiddenSize + parameters.vHiddenSize }
      ];
      const getShaderSource = (shaderHelper) => {
        const outputQ = outputVariable("output_q", inputs[0].dataType, outputShape);
        const outputK = outputVariable("output_k", inputs[0].dataType, outputShape);
        const outputV = outputVariable("output_v", inputs[0].dataType, outputShape);
        const input = inputVariable("input", inputs[0].dataType, inputs[0].dims);
        const weight = inputVariable("weight", inputs[1].dataType, inputs[1].dims);
        const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims);
        const dataType = input.type.storage;
        const uniforms = [
          { name: "M", type: "u32" },
          { name: "K", type: "u32" },
          { name: "N", type: "u32" },
          { name: "num_heads", type: "u32" },
          { name: "head_size", type: "u32" },
          { name: "hidden_size", type: "u32" },
          { name: "ldb", type: "u32" }
        ];
        return `
  const TILE_SIZE = ${TILE_SIZE}u;
  var<workgroup> tileInput: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileWeightQ: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileWeightK: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileWeightV: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(input, weight, bias, outputQ, outputK, outputV)}
  ${shaderHelper.mainStart([
          TILE_SIZE,
          TILE_SIZE,
          1
        ])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${dataType}(0);
    var valueK = ${dataType}(0);
    var valueV = ${dataType}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`;
      };
      return context.compute(
        {
          name: "AttentionPrepare",
          shaderCache: { inputDependencies: ["type", "type", "type"] },
          getRunData: () => ({
            outputs: [
              { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ },
              { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ },
              { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ }
            ],
            dispatchGroup: dispatch,
            programUniforms
          }),
          getShaderSource
        },
        { inputs, outputs: [-1, -1, -1] }
      );
    };
    attention = (context, attributes) => {
      const params = validateAttentionInputs(context.inputs, attributes);
      const [q, k, v] = prepare(context, params);
      return applyAttention(
        context,
        q,
        k,
        v,
        context.inputs[4],
        void 0,
        void 0,
        void 0,
        context.inputs[5],
        params,
        attributes
      );
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/batch-norm.ts
var validateInputs4, createBatchNormInferenceProgramInfo, parseBatchNormAttributes, batchNorm;
var init_batch_norm = __esm({
  "web/lib/wasm/jsep/webgpu/ops/batch-norm.ts"() {
    "use strict";
    init_esm();
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs4 = (inputs, attributes) => {
      if (!inputs || inputs.length !== 5) {
        throw new Error("BatchNormalization requires 5 inputs");
      }
      const checkShapeEqual = (actual, expected, message) => {
        const r = expected.length;
        if (r !== actual.length) {
          throw new Error(`${message}: num dimensions != ${r}`);
        }
        expected.forEach((v, i) => {
          if (v !== actual[i]) {
            throw new Error(`${message}: dim[${i}] do not match`);
          }
        });
      };
      if (inputs[0].dims.length > 1) {
        const shape = attributes.format === "NHWC" ? attributes.spatial ? inputs[0].dims.slice(-1) : inputs[0].dims.slice(-1).concat(inputs[0].dims.slice(1, inputs[0].dims.length - 1)) : inputs[0].dims.slice(1, attributes.spatial ? 2 : void 0);
        checkShapeEqual(inputs[1].dims, shape, "Invalid input scale");
        checkShapeEqual(inputs[2].dims, shape, "Invalid input B");
        checkShapeEqual(inputs[3].dims, shape, "Invalid input mean");
        checkShapeEqual(inputs[4].dims, shape, "Invalid input var");
      } else {
        checkShapeEqual(inputs[1].dims, [1], "Invalid input scale");
        checkShapeEqual(inputs[2].dims, [1], "Invalid input B");
        checkShapeEqual(inputs[3].dims, [1], "Invalid input mean");
        checkShapeEqual(inputs[4].dims, [1], "Invalid input var");
      }
    };
    createBatchNormInferenceProgramInfo = (inputs, attributes) => {
      const { epsilon, spatial, format } = attributes;
      const yShape = inputs[0].dims;
      const components = spatial ? getMaxComponents(yShape[yShape.length - 1]) : 1;
      const cComponents = format === "NHWC" && yShape.length > 1 ? components : 1;
      const outputSize = ShapeUtil.size(yShape) / components;
      const useShapesUniforms = spatial;
      const shapeOrRank = useShapesUniforms ? yShape.length : yShape;
      const x = inputVariable("x", inputs[0].dataType, inputs[0].dims, components);
      const scale = inputVariable("scale", inputs[1].dataType, inputs[1].dims, cComponents);
      const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims, cComponents);
      const inputMean = inputVariable("inputMean", inputs[3].dataType, inputs[3].dims, cComponents);
      const inputVar = inputVariable("inputVar", inputs[4].dataType, inputs[4].dims, cComponents);
      const y = outputVariable("y", inputs[0].dataType, shapeOrRank, components);
      const calcCOffset = () => {
        let cOffset = "";
        if (spatial) {
          cOffset = `let cOffset = ${yShape.length === 1 ? "0u" : format === "NHWC" ? `outputIndices[${yShape.length - 1}] / ${components}` : "outputIndices[1]"};`;
        } else {
          if (format === "NCHW") {
            cOffset = `
            ${y.indicesSet("outputIndices", "0", "0")}
            let cOffset = ${y.indicesToOffset("outputIndices")};`;
          } else {
            cOffset = `var cIndices = ${scale.type.indices}(0);
                       cIndices[0] = outputIndices[${yShape.length - 1}];`;
            for (let i = 1; i < scale.rank; i++) {
              cOffset += `cIndices[${i}] = outputIndices[${i}];`;
            }
            cOffset += `let cOffset = ${scale.indicesToOffset("cIndices")};`;
          }
        }
        return cOffset;
      };
      const getInferenceModeShaderSource = (helper) => `
  const epsilon = ${epsilon};
  ${helper.registerUniform("outputSize", "u32").declareVariables(x, scale, bias, inputMean, inputVar, y)}
  ${helper.mainStart()}
  ${helper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${y.offsetToIndices(`global_idx * ${components}`)};
    ${calcCOffset()}
    let scale = ${scale.getByOffset("cOffset")};
    let bias = ${bias.getByOffset("cOffset")};
    let inputMean = ${inputMean.getByOffset("cOffset")};
    let inputVar = ${inputVar.getByOffset("cOffset")};
    let x = ${x.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${y.setByOffset("global_idx", "value")}
  }`;
      return {
        name: "BatchNormalization",
        shaderCache: {
          hint: `${attributes.epsilon}_${attributes.format}_${spatial}_${components}`,
          inputDependencies: useShapesUniforms ? ["rank", "type", "type", "type", "type"] : void 0
        },
        getShaderSource: getInferenceModeShaderSource,
        getRunData: () => ({
          outputs: [{ dims: inputs[0].dims, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms: useShapesUniforms ? [
            { type: 12 /* uint32 */, data: outputSize },
            ...createTensorShapeVariables(yShape)
          ] : [
            { type: 12 /* uint32 */, data: outputSize }
          ]
        })
      };
    };
    parseBatchNormAttributes = (attributes) => createAttributeWithCacheKey(attributes);
    batchNorm = (context, attributes) => {
      const { inputs, outputCount } = context;
      const updatedAttributes = parseBatchNormAttributes({ ...attributes, outputCount });
      if (env2.webgpu.validateInputContent) {
        validateInputs4(inputs, updatedAttributes);
      }
      if (attributes.trainingMode) {
        throw new Error("BatchNormalization trainingMode is not supported yet.");
      } else {
        context.compute(createBatchNormInferenceProgramInfo(inputs, updatedAttributes));
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/bias-add.ts
var validateInputs5, createBiasAddProgramInfo, biasAdd;
var init_bias_add = __esm({
  "web/lib/wasm/jsep/webgpu/ops/bias-add.ts"() {
    "use strict";
    init_util();
    init_common();
    validateInputs5 = (inputs) => {
      if (inputs[0].dims.length !== 3) {
        throw new Error("input should have 3 dimensions");
      }
      if (![320, 640, 1280].includes(inputs[0].dims[2])) {
        throw new Error("number of channels should be 320, 640 or 1280");
      }
      if (inputs[1].dims.length !== 1) {
        throw new Error("bias is expected to have 1 dimensions");
      }
      if (inputs[0].dims[2] !== inputs[1].dims[0]) {
        throw new Error("last dimension of input and bias are not the same");
      }
    };
    createBiasAddProgramInfo = (inputs) => {
      const outputShape = inputs[0].dims;
      const channels = inputs[0].dims[2];
      const outputSize = ShapeUtil.size(outputShape) / 4;
      const dataType = inputs[0].dataType;
      const input = inputVariable("input", dataType, outputShape, 4);
      const bias = inputVariable("bias", dataType, [channels], 4);
      const residual = inputVariable("residual", dataType, outputShape, 4);
      const output = outputVariable("output", dataType, outputShape, 4);
      const getShaderSource = (shaderHelper) => `
  const channels = ${channels}u / 4;
  ${shaderHelper.declareVariables(input, bias, residual, output)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes(outputSize)}
    let value = ${input.getByOffset("global_idx")}
      + ${bias.getByOffset("global_idx % channels")} + ${residual.getByOffset("global_idx")};
    ${output.setByOffset("global_idx", "value")}
  }`;
      return {
        name: "BiasAdd",
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) }
        }),
        getShaderSource
      };
    };
    biasAdd = (context) => {
      validateInputs5(context.inputs);
      context.compute(createBiasAddProgramInfo(context.inputs));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/unary-op.ts
var createElementwiseProgramShader, createElementwiseProgramInfo, abs, acos, acosh, asin, asinh, atan, atanh, parseCastAttributes, cast, generateClipAttributesFromInputs, clip, ceil, cos, cosh, parseAlphaAttributes, elu, erfImpl, erf, exp, floor, gelu, leakyRelu, not, neg, reciprocal, relu, sigmoid, parseHardSigmoidAttributes, hardSigmoid, sin, sinh, sqrt, tan, tanhExpression, tanh, fastGeluImpl, fastGeluExpression, fastGelu, thresholdedRelu, log;
var init_unary_op = __esm({
  "web/lib/wasm/jsep/webgpu/ops/unary-op.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    createElementwiseProgramShader = (shaderHelper, datasize, inputDataType, outputDataType, funcCall, additionalImplementation) => {
      const vecSize = Math.ceil(datasize / 4);
      let expression = "";
      if (typeof funcCall === "string") {
        expression = `${funcCall}(a)`;
      } else {
        expression = funcCall("a");
      }
      const input = inputVariable("inputData", inputDataType, [vecSize], 4);
      const output = outputVariable("outputData", outputDataType, [vecSize], 4);
      return `
      ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(input, output)}

  ${additionalImplementation ?? ""}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${input.getByOffset("global_idx")};
    ${output.setByOffset("global_idx", expression)}
  }`;
    };
    createElementwiseProgramInfo = (input, name, funcCall, additionalImplementation, cacheKey, outputDataType = input.dataType) => ({
      name,
      shaderCache: { hint: cacheKey, inputDependencies: ["type"] },
      getShaderSource: (shaderHelper) => createElementwiseProgramShader(
        shaderHelper,
        ShapeUtil.size(input.dims),
        input.dataType,
        outputDataType,
        funcCall,
        additionalImplementation
      ),
      getRunData: (inputTensors) => ({
        outputs: [{ dims: input.dims, dataType: outputDataType }],
        dispatchGroup: { x: Math.ceil(
          ShapeUtil.size(inputTensors[0].dims) / 64 / 4
          /* vec size */
        ) },
        programUniforms: [
          { type: 12 /* uint32 */, data: Math.ceil(ShapeUtil.size(input.dims) / 4) }
        ]
      })
    });
    abs = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Abs", "abs"));
    };
    acos = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Acos", "acos"));
    };
    acosh = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Acosh", "acosh"));
    };
    asin = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Asin", "asin"));
    };
    asinh = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Asinh", "asinh"));
    };
    atan = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Atan", "atan"));
    };
    atanh = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Atanh", "atanh"));
    };
    parseCastAttributes = (attributes) => createAttributeWithCacheKey(attributes);
    cast = (context, attributes) => {
      let func;
      switch (attributes.to) {
        case 10 /* float16 */:
          func = "vec4<f16>";
          break;
        case 1 /* float */:
          func = "vec4<f32>";
          break;
        case 12 /* uint32 */:
          func = "vec4<u32>";
          break;
        case 6 /* int32 */:
          func = "vec4<i32>";
          break;
        case 9 /* bool */:
          func = "vec4<bool>";
          break;
        default:
          throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${attributes.to}`);
      }
      context.compute(
        createElementwiseProgramInfo(context.inputs[0], "Cast", func, void 0, attributes.cacheKey, attributes.to)
      );
    };
    generateClipAttributesFromInputs = (inputs) => {
      const min = inputs.length >= 2 && inputs[1].data !== 0 ? inputs[1].getFloat32Array()[0] : MIN_CLIP;
      const max = inputs.length >= 3 && inputs[2].data !== 0 ? inputs[2].getFloat32Array()[0] : MAX_CLIP;
      return createAttributeWithCacheKey({ min, max });
    };
    clip = (context, clipAttributes) => {
      const attributes = context.inputs.length === 1 ? clipAttributes : generateClipAttributesFromInputs(context.inputs);
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(
        createElementwiseProgramInfo(
          context.inputs[0],
          "Clip",
          (a) => `clamp(${a}, clip_min_, clip_max_)`,
          `
    const clip_min_: vec4<${dataType}> = vec4(${dataType}(${attributes.min}));
    const clip_max_: vec4<${dataType}> = vec4(${dataType}(${attributes.max}));
`,
          attributes.cacheKey
        ),
        { inputs: [0] }
      );
    };
    ceil = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Ceil", "ceil"));
    };
    cos = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Cos", "cos"));
    };
    cosh = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Cosh", "cosh"));
    };
    parseAlphaAttributes = (attributes) => createAttributeWithCacheKey(attributes);
    elu = (context, attributes) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(createElementwiseProgramInfo(
        context.inputs[0],
        "Elu",
        (a) => `elu_vf32(${a})`,
        `
  const elu_alpha_ = ${dataType}(${attributes.alpha});

  fn elu_f32(a: ${dataType}) -> ${dataType} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${dataType}>) -> vec4<${dataType}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,
        attributes.cacheKey
      ));
    };
    erfImpl = (varType = "f32") => `
const r0: ${varType} = 0.3275911;
const r1: ${varType} = 0.254829592;
const r2: ${varType} = -0.284496736;
const r3: ${varType} = 1.421413741;
const r4: ${varType} = -1.453152027;
const r5: ${varType} = 1.061405429;

fn erf_vf32(v: vec4<${varType}>) -> vec4<${varType}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`;
    erf = (context) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Erf", (a) => `erf_vf32(${a})`, erfImpl(dataType)));
    };
    exp = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Exp", "exp"));
    };
    floor = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Floor", "floor"));
    };
    gelu = (context) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(createElementwiseProgramInfo(
        context.inputs[0],
        "Gelu",
        (a) => `0.5 * ${a} * (1.0 + erf_vf32(${a} * 0.7071067811865475))`,
        erfImpl(dataType)
      ));
    };
    leakyRelu = (context, attributes) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(createElementwiseProgramInfo(
        context.inputs[0],
        "LeakyRelu",
        (a) => `select(leaky_relu_alpha_ * ${a}, ${a}, ${a} >= vec4<${dataType}>(0.0))`,
        `const leaky_relu_alpha_ = ${dataType}(${attributes.alpha});`,
        attributes.cacheKey
      ));
    };
    not = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Not", (a) => `!${a}`));
    };
    neg = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Neg", (a) => `-${a}`));
    };
    reciprocal = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Reciprocal", (a) => `1.0/${a}`));
    };
    relu = (context) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(createElementwiseProgramInfo(
        context.inputs[0],
        "Relu",
        (a) => `select(vec4<${dataType}>(0.0), ${a}, ${a} > vec4<${dataType}>(0.0))`
      ));
    };
    sigmoid = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Sigmoid", (a) => `(1.0 / (1.0 + exp(-${a})))`));
    };
    parseHardSigmoidAttributes = (attributes) => createAttributeWithCacheKey(attributes);
    hardSigmoid = (context, attributes) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(createElementwiseProgramInfo(
        context.inputs[0],
        "HardSigmoid",
        (a) => `max(vec4<${dataType}>(0.0), min(vec4<${dataType}>(1.0), ${attributes.alpha} * ${a} + vec4<${dataType}>(${attributes.beta})))`,
        void 0,
        attributes.cacheKey
      ));
    };
    sin = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Sin", "sin"));
    };
    sinh = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Sinh", "sinh"));
    };
    sqrt = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Sqrt", "sqrt"));
    };
    tan = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Tan", "tan"));
    };
    tanhExpression = (a) => `sign(${a}) * (1 - exp(-2 * abs(${a}))) / (1 + exp(-2 * abs(${a})))`;
    tanh = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Tanh", tanhExpression));
    };
    fastGeluImpl = (varType = "f32") => `
const fast_gelu_a: ${varType} = 0.5;
const fast_gelu_b: ${varType} = 0.7978845608028654;
const fast_gelu_c: ${varType} = 0.035677408136300125;

fn tanh_v(v: vec4<${varType}>) -> vec4<${varType}> {
  return ${tanhExpression("v")};
}
`;
    fastGeluExpression = (x) => `(fast_gelu_a + fast_gelu_a * tanh_v(${x} * (fast_gelu_c * ${x} * ${x} + fast_gelu_b))) * ${x}`;
    fastGelu = (context) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(createElementwiseProgramInfo(
        context.inputs[0],
        "FastGelu",
        fastGeluExpression,
        fastGeluImpl(dataType),
        void 0,
        context.inputs[0].dataType
      ));
    };
    thresholdedRelu = (context, attributes) => {
      const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
      context.compute(createElementwiseProgramInfo(
        context.inputs[0],
        "ThresholdedRelu",
        (a) => `select(vec4<${dataType}>(0.0), ${a}, ${a} > thresholded_relu_alpha_)`,
        `const thresholded_relu_alpha_ = vec4<${dataType}>(${attributes.alpha});`,
        attributes.cacheKey
      ));
      return 0;
    };
    log = (context) => {
      context.compute(createElementwiseProgramInfo(context.inputs[0], "Log", "log"));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/bias-split-gelu.ts
var validateInputs6, createBiasSplitGeluProgramInfo, biasSplitGelu;
var init_bias_split_gelu = __esm({
  "web/lib/wasm/jsep/webgpu/ops/bias-split-gelu.ts"() {
    "use strict";
    init_util();
    init_common();
    init_unary_op();
    validateInputs6 = (inputs) => {
      if (inputs[0].dims.length !== 3) {
        throw new Error("input should have 3 dimensions");
      }
      if (![2560, 5120, 10240].includes(inputs[0].dims[2])) {
        throw new Error("hidden state should be 2560, 5120 or 10240");
      }
      if (inputs[1].dims.length !== 1) {
        throw new Error("bias is expected to have 1 dimensions");
      }
      if (inputs[0].dims[2] !== inputs[1].dims[0]) {
        throw new Error("last dimension of input and bias are not the same");
      }
    };
    createBiasSplitGeluProgramInfo = (inputs) => {
      const outputShape = inputs[0].dims.slice();
      outputShape[2] = outputShape[2] / 2;
      const input = inputVariable("input", inputs[0].dataType, inputs[0].dims, 4);
      const bias = inputVariable("bias", inputs[0].dataType, [inputs[0].dims[2]], 4);
      const output = outputVariable("output", inputs[0].dataType, outputShape, 4);
      const outputSize = ShapeUtil.size(outputShape) / 4;
      const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
      const getShaderSource = (shaderHelper) => `
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${inputs[0].dims[2] / 4 / 2}u;

  ${shaderHelper.declareVariables(input, bias, output)}

  ${erfImpl(dataType)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes(outputSize)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${output.setByOffset("global_idx", "valueLeft * geluRight")}
  }`;
      return {
        name: "BiasSplitGelu",
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) }
        }),
        getShaderSource
      };
    };
    biasSplitGelu = (context) => {
      validateInputs6(context.inputs);
      context.compute(createBiasSplitGeluProgramInfo(context.inputs));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/binary-op.ts
var createBinaryOpProgramShader, createBinaryOpProgramInfo, runBinaryOp, add, div, equal, mul, pow, sub, greater, less, greaterOrEqual, lessOrEqual;
var init_binary_op = __esm({
  "web/lib/wasm/jsep/webgpu/ops/binary-op.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    createBinaryOpProgramShader = (shaderHelper, dimsA, dimsB, dimsOutput, vectorize, doBroadcast, sharedDimensionDivisibleBy4, funcCall, typeA, typeB, typeOutput, additionalImplementation) => {
      let expressionScalar;
      let expressionVector;
      if (typeof funcCall === "string") {
        expressionScalar = expressionVector = (a2, b2) => `${funcCall}((${a2}),(${b2}))`;
      } else if (typeof funcCall === "function") {
        expressionScalar = expressionVector = funcCall;
      } else {
        expressionScalar = funcCall.scalar;
        expressionVector = funcCall.vector;
      }
      const output = outputVariable("outputData", typeOutput, dimsOutput.length, 4);
      const a = inputVariable("aData", typeA, dimsA.length, 4);
      const b = inputVariable("bData", typeB, dimsB.length, 4);
      let assignment;
      if (vectorize) {
        if (doBroadcast) {
          const isAOneElement = ShapeUtil.size(dimsA) === 1;
          const isBOneElement = ShapeUtil.size(dimsB) === 1;
          const aLastDimDivisibleBy4 = dimsA.length > 0 && dimsA[dimsA.length - 1] % 4 === 0;
          const bLastDimDivisibleBy4 = dimsB.length > 0 && dimsB[dimsB.length - 1] % 4 === 0;
          if (isAOneElement || isBOneElement) {
            assignment = output.setByOffset(
              "global_idx",
              expressionVector(
                isAOneElement ? `${a.type.value}(${a.getByOffset("0")}.x)` : a.getByOffset("global_idx"),
                isBOneElement ? `${b.type.value}(${b.getByOffset("0")}.x)` : b.getByOffset("global_idx")
              )
            );
          } else {
            assignment = `
            let outputIndices = ${output.offsetToIndices("global_idx * 4u")};
            let offsetA = ${a.broadcastedIndicesToOffset("outputIndices", output)};
            let offsetB = ${b.broadcastedIndicesToOffset("outputIndices", output)};
            ${output.setByOffset(
              "global_idx",
              expressionVector(
                sharedDimensionDivisibleBy4 || aLastDimDivisibleBy4 ? a.getByOffset("offsetA / 4u") : `${a.type.value}(${a.getByOffset("offsetA / 4u")}[offsetA % 4u])`,
                sharedDimensionDivisibleBy4 || bLastDimDivisibleBy4 ? b.getByOffset("offsetB / 4u") : `${b.type.value}(${b.getByOffset("offsetB / 4u")}[offsetB % 4u])`
              )
            )}
          `;
          }
        } else {
          assignment = output.setByOffset(
            "global_idx",
            expressionVector(a.getByOffset("global_idx"), b.getByOffset("global_idx"))
          );
        }
      } else {
        if (!doBroadcast) {
          throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");
        }
        const singleAssignment = (resStr, x, typeCast = "") => {
          const expressionA = `aData[indexA${x}][componentA${x}]`;
          const expressionB = `bData[indexB${x}][componentB${x}]`;
          return `
            let outputIndices${x} = ${output.offsetToIndices(`global_idx * 4u + ${x}u`)};
            let offsetA${x} = ${a.broadcastedIndicesToOffset(`outputIndices${x}`, output)};
            let offsetB${x} = ${b.broadcastedIndicesToOffset(`outputIndices${x}`, output)};
            let indexA${x} = offsetA${x} / 4u;
            let indexB${x} = offsetB${x} / 4u;
            let componentA${x} = offsetA${x} % 4u;
            let componentB${x} = offsetB${x} % 4u;
            ${resStr}[${x}] = ${typeCast}(${expressionScalar(expressionA, expressionB)});
          `;
        };
        if (typeOutput === 9 /* bool */) {
          assignment = `
            var data = vec4<u32>(0);
            ${singleAssignment("data", 0, "u32")}
            ${singleAssignment("data", 1, "u32")}
            ${singleAssignment("data", 2, "u32")}
            ${singleAssignment("data", 3, "u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`;
        } else {
          assignment = `
            ${singleAssignment("outputData[global_idx]", 0)}
            ${singleAssignment("outputData[global_idx]", 1)}
            ${singleAssignment("outputData[global_idx]", 2)}
            ${singleAssignment("outputData[global_idx]", 3)}
          `;
        }
      }
      return `
        ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(a, b, output)}

        ${additionalImplementation ?? ""}

        ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${assignment}
      }`;
    };
    createBinaryOpProgramInfo = (name, cacheKey, a, b, funcCall, additionalImplementation, outputDataType = a.dataType) => {
      const isBroadcast = !ShapeUtil.areEqual(a.dims, b.dims);
      let outputShape = a.dims;
      let outputSize = ShapeUtil.size(a.dims);
      let vectorize = false;
      let sharedDimensionDivisibleBy4 = false;
      const cacheKeyAux = [isBroadcast];
      if (isBroadcast) {
        const calculatedShape = BroadcastUtil.calcShape(a.dims, b.dims, false);
        if (!calculatedShape) {
          throw new Error("Can't perform binary op on the given tensors");
        }
        outputShape = calculatedShape;
        outputSize = ShapeUtil.size(outputShape);
        const isAOneElement = ShapeUtil.size(a.dims) === 1;
        const isBOneElement = ShapeUtil.size(b.dims) === 1;
        const aLastDimDivisibleBy4 = a.dims.length > 0 && a.dims[a.dims.length - 1] % 4 === 0;
        const bLastDimDivisibleBy4 = b.dims.length > 0 && b.dims[b.dims.length - 1] % 4 === 0;
        cacheKeyAux.push(isAOneElement);
        cacheKeyAux.push(isBOneElement);
        cacheKeyAux.push(aLastDimDivisibleBy4);
        cacheKeyAux.push(bLastDimDivisibleBy4);
        let sharedDimension = 1;
        for (let i = 1; i < outputShape.length; i++) {
          const dimA = a.dims[a.dims.length - i] ?? 1;
          const dimB = b.dims[b.dims.length - i] ?? 1;
          if (dimA === dimB) {
            sharedDimension *= dimA;
          } else {
            break;
          }
        }
        if (sharedDimension % 4 === 0) {
          sharedDimensionDivisibleBy4 = true;
          vectorize = true;
        } else if (isAOneElement || isBOneElement || aLastDimDivisibleBy4 || bLastDimDivisibleBy4) {
          vectorize = true;
        }
      } else {
        vectorize = true;
      }
      cacheKeyAux.push(vectorize);
      return {
        name,
        shaderCache: {
          hint: cacheKey + cacheKeyAux.map((x) => x.toString()).join("_"),
          inputDependencies: ["rank", "rank"]
        },
        getShaderSource: (shaderHelper) => createBinaryOpProgramShader(
          shaderHelper,
          a.dims,
          b.dims,
          outputShape,
          vectorize,
          isBroadcast,
          sharedDimensionDivisibleBy4,
          funcCall,
          a.dataType,
          b.dataType,
          outputDataType,
          additionalImplementation
        ),
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: outputDataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64 / 4
            /* component size */
          ) },
          programUniforms: [
            { type: 12 /* uint32 */, data: Math.ceil(ShapeUtil.size(outputShape) / 4) },
            ...createTensorShapeVariables(a.dims, b.dims, outputShape)
          ]
        })
      };
    };
    runBinaryOp = (context, name, funcCall, additionalImplementation, cacheKey, outputDataType) => {
      context.compute(createBinaryOpProgramInfo(
        name,
        cacheKey ?? "",
        context.inputs[0],
        context.inputs[1],
        funcCall,
        additionalImplementation,
        outputDataType
      ));
    };
    add = (context) => {
      runBinaryOp(context, "Add", (a, b) => `${a}+${b}`);
    };
    div = (context) => {
      runBinaryOp(context, "Div", (a, b) => `${a}/${b}`);
    };
    equal = (context) => {
      runBinaryOp(
        context,
        "Equal",
        { scalar: (a, b) => `u32(${a}==${b})`, vector: (a, b) => `vec4<u32>(${a}==${b})` },
        void 0,
        void 0,
        9 /* bool */
      );
    };
    mul = (context) => {
      runBinaryOp(context, "Mul", (a, b) => `${a}*${b}`);
    };
    pow = (context) => {
      const type = inputVariable("input", context.inputs[0].dataType, context.inputs[0].dims).type.value;
      const roundStr = type === "i32" ? "round" : "";
      runBinaryOp(
        context,
        "Pow",
        { scalar: (a, b) => `pow_custom(${a},${b})`, vector: (a, b) => `pow_vector_custom(${a},${b})` },
        `
    fn pow_custom(a : ${type}, b : ${type}) -> ${type} {
      if (b == ${type}(0.0)) {
        return ${type}(1.0);
      } else if (a < ${type}(0.0) && f32(b) != floor(f32(b))) {
        return ${type}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${type}(1.0), round(f32(abs(b) % ${type}(2.0))) != 1.0) * ${type}(${roundStr}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${type}>, b : vec4<${type}>) -> vec4<${type}> {
      // TODO: implement vectorized pow
      return vec4<${type}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `
      );
    };
    sub = (context) => {
      runBinaryOp(context, "Sub", (a, b) => `${a}-${b}`);
    };
    greater = (context) => {
      runBinaryOp(
        context,
        "Greater",
        { scalar: (a, b) => `u32(${a}>${b})`, vector: (a, b) => `vec4<u32>(${a}>${b})` },
        void 0,
        void 0,
        9 /* bool */
      );
    };
    less = (context) => {
      runBinaryOp(
        context,
        "Less",
        { scalar: (a, b) => `u32(${a}<${b})`, vector: (a, b) => `vec4<u32>(${a}<${b})` },
        void 0,
        void 0,
        9 /* bool */
      );
    };
    greaterOrEqual = (context) => {
      runBinaryOp(
        context,
        "GreaterOrEqual",
        { scalar: (a, b) => `u32(${a}>=${b})`, vector: (a, b) => `vec4<u32>(${a}>=${b})` },
        void 0,
        void 0,
        9 /* bool */
      );
    };
    lessOrEqual = (context) => {
      runBinaryOp(
        context,
        "LessOrEqual",
        { scalar: (a, b) => `u32(${a}<=${b})`, vector: (a, b) => `vec4<u32>(${a}<=${b})` },
        void 0,
        void 0,
        9 /* bool */
      );
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/concat.ts
var validateInputs7, calculateInputIndexImpl, assignOutputData, createConcatProgramInfo, concat, parseConcatAttributes;
var init_concat = __esm({
  "web/lib/wasm/jsep/webgpu/ops/concat.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs7 = (inputs, axis) => {
      if (!inputs || inputs.length < 1) {
        throw new Error("too few inputs");
      }
      const referenceIndex = 0;
      const referenceInput = inputs[referenceIndex];
      const inputType = referenceInput.dataType;
      const inputRank = referenceInput.dims.length;
      inputs.forEach((input, i) => {
        if (i === referenceIndex) {
          return;
        }
        if (input.dataType !== inputType) {
          throw new Error("input tensors should be one type");
        }
        if (input.dims.length !== inputRank) {
          throw new Error("input tensors should have the same shape");
        }
        input.dims.forEach((dim, i2) => {
          if (i2 !== axis && dim !== referenceInput.dims[i2]) {
            throw new Error("non concat dimensions must match");
          }
        });
      });
    };
    calculateInputIndexImpl = (numberOfTensors, sizeInConcatAxisStr) => `
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${numberOfTensors}u>(${sizeInConcatAxisStr});
    for (var i: u32 = 0u; i < ${numberOfTensors}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${numberOfTensors}u;
  }`;
    assignOutputData = (inputs, output) => {
      const numberOfTensors = inputs.length;
      const codeLines = [];
      for (let i = 0; i < numberOfTensors; ++i) {
        const returnSnippet = output.setByOffset("global_idx", inputs[i].getByIndices("indices"));
        if (numberOfTensors === 1) {
          codeLines.push(returnSnippet);
        } else if (i === 0) {
          codeLines.push(`if (inputIndex == ${i}u) { ${returnSnippet} }`);
        } else if (i === numberOfTensors - 1) {
          codeLines.push(`else { ${returnSnippet} }`);
        } else {
          codeLines.push(`else if (inputIndex == ${i}) { ${returnSnippet} }`);
        }
      }
      return codeLines.join("\n");
    };
    createConcatProgramInfo = (inputs, adjustedAxis, outputShape, dataType) => {
      const outputSize = ShapeUtil.size(outputShape);
      const sizeInConcatAxis = new Array(inputs.length);
      const inputVars = new Array(inputs.length);
      let previousSum = 0;
      const inputDependencies = [];
      const inputRanks = [];
      const programUniforms = [{ type: 12 /* uint32 */, data: outputSize }];
      for (let i = 0; i < inputs.length; ++i) {
        previousSum += inputs[i].dims[adjustedAxis];
        sizeInConcatAxis[i] = previousSum;
        inputRanks.push(inputs[i].dims.length);
        inputVars[i] = inputVariable(`input${i}`, dataType, inputRanks[i]);
        inputDependencies.push("rank");
        programUniforms.push({ type: 12 /* uint32 */, data: sizeInConcatAxis[i] });
      }
      for (let i = 0; i < inputs.length; ++i) {
        programUniforms.push(...createTensorShapeVariables(inputs[i].dims));
      }
      programUniforms.push(...createTensorShapeVariables(outputShape));
      const output = outputVariable("output", dataType, outputShape.length);
      const indicesAxis = output.indicesGet("indices", adjustedAxis);
      const sizeInConcatAxisStr = Array.from(Array(sizeInConcatAxis.length).keys()).map((i) => `uniforms.sizeInConcatAxis${i}`).join(",");
      const getShaderSource = (shaderHelper) => `

  ${(() => {
        shaderHelper.registerUniform("outputSize", "u32");
        for (let i = 0; i < inputs.length; i++) {
          shaderHelper.registerUniform(`sizeInConcatAxis${i}`, "u32");
        }
        return shaderHelper.declareVariables(...inputVars, output);
      })()}

  ${calculateInputIndexImpl(sizeInConcatAxis.length, sizeInConcatAxisStr)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${output.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${indicesAxis});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${sizeInConcatAxis.length}u>(${sizeInConcatAxisStr});
      ${indicesAxis} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${assignOutputData(inputVars, output)}
  }`;
      return {
        name: "Concat",
        shaderCache: { hint: `${adjustedAxis}`, inputDependencies },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    concat = (context, attributes) => {
      const inputs = context.inputs;
      const inputShape = inputs[0].dims;
      const adjustedAxis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);
      validateInputs7(inputs, adjustedAxis);
      const outputShape = inputShape.slice();
      outputShape[adjustedAxis] = inputs.reduce((sum, input) => sum + (input.dims.length > adjustedAxis ? input.dims[adjustedAxis] : 0), 0);
      const nonEmptyInputs = inputs.filter((input) => ShapeUtil.size(input.dims) > 0);
      context.compute(
        createConcatProgramInfo(nonEmptyInputs, adjustedAxis, outputShape, inputs[0].dataType),
        { inputs: nonEmptyInputs }
      );
    };
    parseConcatAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
  }
});

// web/lib/wasm/jsep/webgpu/ops/fuse-utils.ts
var getActivationSnippet, appendActivationUniformsData, appendActivationUniforms, parseInternalActivationAttributes;
var init_fuse_utils = __esm({
  "web/lib/wasm/jsep/webgpu/ops/fuse-utils.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    getActivationSnippet = (attributes, valueType, baseType = "f32") => {
      switch (attributes.activation) {
        case "Relu":
          return `value = max(value, ${valueType}(0.0));`;
        case "Sigmoid":
          return `value = (${valueType}(1.0) / (${valueType}(1.0) + exp(-value)));`;
        case "Clip":
          return `value = clamp(value, ${valueType}(${baseType}(uniforms.clip_min)), ${valueType}(${baseType}(uniforms.clip_max)));`;
        case "HardSigmoid":
          return `value = max(${valueType}(0.0), min(${valueType}(1.0), ${baseType}(uniforms.alpha) * value + ${baseType}(uniforms.beta)));`;
        case "LeakyRelu":
          return `value = select(${baseType}(uniforms.alpha) * value, value, value >= ${valueType}(0.0));`;
        case "":
          return "";
        default:
          throw new Error(`Unsupported activation ${attributes.activation}`);
      }
    };
    appendActivationUniformsData = (attributes, programUniform) => {
      if (attributes.activation === "Clip") {
        programUniform.push(
          { type: 1 /* float */, data: attributes.clipMax },
          { type: 1 /* float */, data: attributes.clipMin }
        );
      } else if (attributes.activation === "HardSigmoid") {
        programUniform.push(
          { type: 1 /* float */, data: attributes.alpha },
          { type: 1 /* float */, data: attributes.beta }
        );
      } else if (attributes.activation === "LeakyRelu") {
        programUniform.push({ type: 1 /* float */, data: attributes.alpha });
      }
    };
    appendActivationUniforms = (attributes, uniforms) => {
      if (attributes.activation === "Clip") {
        uniforms.push({ name: "clip_max", type: "f32" }, { name: "clip_min", type: "f32" });
      } else if (attributes.activation === "HardSigmoid") {
        uniforms.push({ name: "alpha", type: "f32" }, { name: "beta", type: "f32" });
      } else if (attributes.activation === "LeakyRelu") {
        uniforms.push({ name: "alpha", type: "f32" });
      }
    };
    parseInternalActivationAttributes = (attributes) => {
      const activation = attributes?.activation || "";
      if (activation === "HardSigmoid") {
        const [alpha, beta] = attributes?.activation_params || [0.2, 0.5];
        return { activation, alpha, beta };
      } else if (activation === "Clip") {
        const [clipMin, clipMax] = attributes?.activation_params || [MIN_CLIP, MAX_CLIP];
        return { activation, clipMax, clipMin };
      } else if (activation === "LeakyRelu") {
        const [alpha] = attributes?.activation_params || [0.01];
        return { activation, alpha };
      }
      return { activation };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/3rd-party/activation_util.ts
var typeSnippet, biasSnippet;
var init_activation_util = __esm({
  "web/lib/wasm/jsep/webgpu/ops/3rd-party/activation_util.ts"() {
    "use strict";
    typeSnippet = (component, dataType) => {
      switch (component) {
        case 1:
          return dataType;
        case 2:
          return `vec2<${dataType}>`;
        case 3:
          return `vec3<${dataType}>`;
        case 4:
          return `vec4<${dataType}>`;
        default:
          throw new Error(`${component}-component is not supported.`);
      }
    };
    biasSnippet = (hasBias) => `
      ${hasBias ? "value = value + getBiasByOutputCoords(coords);" : ""}
      `;
  }
});

// web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_util.ts
var utilFunctions;
var init_conv_util = __esm({
  "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_util.ts"() {
    "use strict";
    utilFunctions = (strideStr) => `
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${strideStr}.x), i32(${strideStr}.y), i32(${strideStr}.z), 1));
}
`;
  }
});

// web/lib/wasm/jsep/webgpu/ops/3rd-party/matmul_packed_webgpu.ts
var writeDataToSubAVec4Snippet, calculateResultSnippet, makeMatMulPackedVec4Source, writeDataToSubASnippet, readDataFromSubASnippet, makeMatMulPackedSource, matMulReadWriteFnSource, createMatmulProgramInfo;
var init_matmul_packed_webgpu = __esm({
  "web/lib/wasm/jsep/webgpu/ops/3rd-party/matmul_packed_webgpu.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    init_fuse_utils();
    init_activation_util();
    writeDataToSubAVec4Snippet = (transpose2, batchDims) => {
      if (transpose2) {
        return `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${batchDims ? ", batchIndices" : ""});
        `;
      } else {
        return `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${batchDims ? ", batchIndices" : ""});
        `;
      }
    };
    calculateResultSnippet = (transposeA, innerElementSize) => {
      if (transposeA) {
        return `
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${innerElementSize === 3 ? "" : "let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${innerElementSize === 3 ? "" : "acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`;
      } else {
        return `
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${innerElementSize === 3 ? "" : "acc[i] = BCached3 * ACached.w + acc[i];"}
        }`;
      }
    };
    makeMatMulPackedVec4Source = (workPerThread, workgroupSize, type = "f32", batchDims, transposeA = false, tileInner = 32, splitK = false, splitedDimInner = 32) => {
      const tileAOuter = workgroupSize[1] * workPerThread[1];
      const tileBOuter = workgroupSize[0] * workPerThread[0];
      const tileAWidth = transposeA ? tileAOuter : tileInner;
      const tileAHight = transposeA ? tileInner : tileAOuter;
      const innerElementSize = tileAWidth / workgroupSize[0];
      const rowPerThreadB = tileInner / workgroupSize[1];
      if (!((transposeA && innerElementSize === 4 && workPerThread[1] === 4 || !transposeA && (innerElementSize === 3 || innerElementSize === 4)) && tileAWidth % workgroupSize[0] === 0 && tileInner % workgroupSize[1] === 0 && workPerThread[0] === 4)) {
        throw new Error(`If transposeA ${transposeA} is true, innerElementSize ${innerElementSize} and workPerThread[1] ${workPerThread[1]} must be 4.
      Otherwise, innerElementSize ${innerElementSize} must be 3 or 4.
  tileAWidth ${tileAWidth} must be divisible by workgroupSize[0]${workgroupSize[0]}. tileInner ${tileInner} must be divisible by workgroupSize[1] ${workgroupSize[1]}. colPerThread ${workPerThread[0]} must be 4.`);
      }
      return `
var<workgroup> mm_Asub: array<array<vec${innerElementSize}<${type}>, ${tileAWidth / innerElementSize}>, ${tileAHight}>;
var<workgroup> mm_Bsub: array<array<vec4<${type}>, ${tileBOuter / workPerThread[0]}>, ${tileInner}>;

const rowPerThread = ${workPerThread[1]};
const colPerThread = ${workPerThread[0]};
const innerElementSize = ${innerElementSize};
const tileInner = ${tileInner};

@compute @workgroup_size(${workgroupSize[0]}, ${workgroupSize[1]}, ${workgroupSize[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${splitK ? "0" : "i32(globalId.z)"};
  ${batchDims ? `let batchIndices = ${batchDims.offsetToIndices("u32(batch)")};` : ""}
  let globalRowStart = i32(workgroupId.y) * ${tileAOuter};

  let num_tiles = ${splitK ? `${Math.ceil(splitedDimInner / tileInner)}` : "(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${splitK ? `i32(globalId.z) * ${splitedDimInner}` : "0"};

  var acc: array<vec4<${type}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${rowPerThreadB};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${writeDataToSubAVec4Snippet(transposeA, batchDims)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${rowPerThreadB}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${batchDims ? ", batchIndices" : ""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${innerElementSize === 3 ? "" : "let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${calculateResultSnippet(transposeA, innerElementSize)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`;
    };
    writeDataToSubASnippet = (transpose2, batchDims) => {
      if (transpose2) {
        return `
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${batchDims ? ", batchIndices" : ""});
            `;
      } else {
        return `
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${batchDims ? ", batchIndices" : ""});
            `;
      }
    };
    readDataFromSubASnippet = (transposeA) => transposeA ? "let ACached = mm_Asub[k][tileRow + innerRow];" : "let ACached = mm_Asub[tileRow + innerRow][k];";
    makeMatMulPackedSource = (workPerThread, workgroupSize, type = "f32", batchDims, transposeA = false, tileInner = 32, splitK = false, splitedDimInner = 32, sequentialAccessByThreads = false) => {
      const tileAOuter = workPerThread[1] * workgroupSize[1];
      const tileBOuter = workPerThread[0] * workgroupSize[0];
      const tileAWidth = transposeA ? tileAOuter : tileInner;
      const tileAHight = transposeA ? tileInner : tileAOuter;
      if (!(tileAHight % workgroupSize[1] === 0 && tileAWidth % workgroupSize[0] === 0 && tileInner % workgroupSize[1] === 0)) {
        throw new Error(`tileAHight ${tileAHight} must be divisible by workgroupSize[1]${workgroupSize[1]}, tileAWidth ${tileAWidth} must be divisible by workgroupSize[0]${workgroupSize[0]}, tileInner ${tileInner} must be divisible by workgroupSize[1]${workgroupSize[1]}`);
      }
      const rowPerThreadA = tileAHight / workgroupSize[1];
      const colPerThreadA = tileAWidth / workgroupSize[0];
      const rowPerThreadB = tileInner / workgroupSize[1];
      const matmulSnippet = sequentialAccessByThreads ? `
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${tileAOuter};
    let globalColStart = i32(workgroupId.x) * ${tileBOuter};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${tileAHight}; inputRow = inputRow + ${workgroupSize[1]}) {
        for (var inputCol = localCol; inputCol < ${tileAWidth}; inputCol = inputCol + ${workgroupSize[0]}) {
          ${writeDataToSubASnippet(transposeA, batchDims)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${tileInner}; inputRow = inputRow + ${workgroupSize[1]}) {
            for (var inputCol = localCol; inputCol < ${tileBOuter}; inputCol = inputCol + ${workgroupSize[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${batchDims ? ", batchIndices" : ""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${type}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${workgroupSize[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${transposeA ? `mm_Asub[k][localRow + innerRow * ${workgroupSize[1]}];` : `mm_Asub[localRow + innerRow * ${workgroupSize[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${workgroupSize[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${workgroupSize[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    ` : `
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${tileAOuter};

let tileRowA = i32(localId.y) * ${rowPerThreadA};
let tileColA = i32(localId.x) * ${colPerThreadA};
let tileRowB = i32(localId.y) * ${rowPerThreadB};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${rowPerThreadA}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${colPerThreadA}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${writeDataToSubASnippet(transposeA, batchDims)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${rowPerThreadB}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${batchDims ? ", batchIndices" : ""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${type}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${readDataFromSubASnippet(transposeA)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;
      return `
  var<workgroup> mm_Asub : array<array<${type}, ${tileAWidth}>, ${tileAHight}>;
  var<workgroup> mm_Bsub : array<array<${type}, ${tileBOuter}>, ${tileInner}>;
  const rowPerThread = ${workPerThread[1]};
  const colPerThread = ${workPerThread[0]};
  const tileInner = ${tileInner};

@compute @workgroup_size(${workgroupSize[0]}, ${workgroupSize[1]}, ${workgroupSize[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${splitK ? "0" : "i32(globalId.z)"};
    ${batchDims ? `let batchIndices = ${batchDims.offsetToIndices("u32(batch)")};` : ""}
    let num_tiles = ${splitK ? `${Math.ceil(splitedDimInner / tileInner)}` : "(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${splitK ? `i32(globalId.z) * ${splitedDimInner}` : "0"};

    var acc : array<array<${type}, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${matmulSnippet}
  }
`;
    };
    matMulReadWriteFnSource = (component, hasBias, applyActivation, variables, batchShapes, isChannelsLast = false) => {
      const [batchAShape, batchBShape, batchShape] = batchShapes;
      const [batchVariable, aVariable, bVariable, outputVariable2] = variables;
      const broadCastADims = getBroadcastDims(batchAShape, batchShape);
      const broadCastBDims = getBroadcastDims(batchBShape, batchShape);
      const dataType = tensorTypeToWsglStorageType(variables[0].type.tensor);
      const getAIndices = () => {
        const aRank = aVariable.rank;
        const batchRank = batchVariable.rank;
        let resStr = `var aIndices: ${aVariable.type.indices};`;
        for (let i = aRank - 2 - 1, j = batchRank - 1; i >= 0; i--, j--) {
          resStr += `
aIndices[${i}] = ${batchRank > 1 ? `batchIndices[${j}]` : "batchIndices"};`;
        }
        broadCastADims.forEach((i) => {
          resStr += `
aIndices[${i}] = 0;`;
        });
        resStr += `
aIndices[${aRank - 2}] = u32(row);
                   aIndices[${aRank - 1}] = u32(colIn);`;
        return resStr;
      };
      const getBIndices = () => {
        const bRank = bVariable.rank;
        const batchRank = batchVariable.rank;
        let resStr = `var bIndices: ${bVariable.type.indices};`;
        for (let i = bRank - 2 - 1, j = batchRank - 1; i >= 0; i--, j--) {
          resStr += `
bIndices[${i}] = ${batchRank > 1 ? `batchIndices[${j}]` : "batchIndices"};`;
        }
        broadCastBDims.forEach((i) => {
          resStr += `
bIndices[${i}] = 0;`;
        });
        resStr += `
bIndices[${bRank - 2}] = u32(row);
                   bIndices[${bRank - 1}] = u32(colIn);`;
        return resStr;
      };
      const source = `
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${batchVariable.type.indices}) -> ${typeSnippet(component, dataType)} {
      var value = ${typeSnippet(component, dataType)}(0.0);
      let col = colIn * ${component};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        ${getAIndices()}
        value = ${aVariable.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${batchVariable.type.indices}) -> ${typeSnippet(component, dataType)} {
      var value = ${typeSnippet(component, dataType)}(0.0);
      let col = colIn * ${component};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        ${getBIndices()}
        value = ${bVariable.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${typeSnippet(component, dataType)}) {
      let col = colIn * ${component};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${hasBias ? `value = value + ${isChannelsLast ? "bias[colIn]" : `${typeSnippet(component, dataType)}(bias[row])`};` : ""}
        ${applyActivation}
        ${outputVariable2.setByIndices("vec3<u32>(coords)", "value")}
      }
    }
    `;
      return source;
    };
    createMatmulProgramInfo = (inputs, activationAttributes, outputShape, reshapedOutputShape, isChannelsLast = false) => {
      const aShape = inputs[0].dims;
      const bShape = inputs[1].dims;
      const outerDimsA = aShape.slice(0, -2);
      const outerDimsB = bShape.slice(0, -2);
      const outerDims = reshapedOutputShape ? reshapedOutputShape.slice(0, -2) : outputShape.slice(0, -2);
      const batchSize = ShapeUtil.size(outerDims);
      const dimAOuter = aShape[aShape.length - 2];
      const dimInner = aShape[aShape.length - 1];
      const dimBOuter = bShape[bShape.length - 1];
      const isVec4 = dimInner % 4 === 0 && dimBOuter % 4 === 0;
      const elementsPerThread = dimAOuter <= 8 ? [4, 1, 1] : [4, 4, 1];
      const workgroupSize = [8, 8, 1];
      const dispatch = [
        Math.ceil(dimBOuter / workgroupSize[0] / elementsPerThread[0]),
        Math.ceil(dimAOuter / workgroupSize[1] / elementsPerThread[1]),
        Math.ceil(batchSize / workgroupSize[2] / elementsPerThread[2])
      ];
      const components = isVec4 ? 4 : 1;
      const aShapeTemp = [...outerDimsA, dimAOuter, dimInner / components];
      const aRank = aShapeTemp.length;
      const bShapeTemp = [...outerDimsB, dimInner, dimBOuter / components];
      const bRank = bShapeTemp.length;
      const outputShapeTemp = [batchSize, dimAOuter, dimBOuter / components];
      const programUniforms = [
        { type: 6 /* int32 */, data: dimAOuter },
        { type: 6 /* int32 */, data: dimBOuter },
        { type: 6 /* int32 */, data: dimInner }
      ];
      appendActivationUniformsData(activationAttributes, programUniforms);
      programUniforms.push(...createTensorShapeVariables(outerDims, aShapeTemp, bShapeTemp));
      const inputDependencies = ["rank", "rank"];
      const hasBias = inputs.length > 2;
      if (hasBias) {
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        inputDependencies.push("rank");
      }
      programUniforms.push(...createTensorShapeVariables(outputShapeTemp));
      const getShaderSource = (shaderHelper) => {
        const batchRank = outerDims.length;
        const batchDims = internalVariable("batchDims", inputs[0].dataType, batchRank, 1);
        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
        const A = inputVariable("a", inputs[0].dataType, aRank, components);
        const B = inputVariable("b", inputs[1].dataType, bRank, components);
        const output = outputVariable("result", inputs[0].dataType, outputShapeTemp.length, components);
        const inputVariables = [A, B];
        if (hasBias) {
          const biasComponents = isChannelsLast ? components : 1;
          inputVariables.push(inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, biasComponents));
        }
        const uniforms = [{ name: "dim_a_outer", type: "i32" }, { name: "dim_b_outer", type: "i32" }, { name: "dim_inner", type: "i32" }];
        appendActivationUniforms(activationAttributes, uniforms);
        const baseType = tensorTypeToWsglStorageType(output.type.tensor);
        const applyActivation = getActivationSnippet(activationAttributes, output.type.value, baseType);
        const declareFunctions = matMulReadWriteFnSource(
          components,
          hasBias,
          applyActivation,
          [batchDims, A, B, output],
          [outerDimsA, outerDimsB, outerDims],
          isChannelsLast
        );
        return `
  ${shaderHelper.registerUniforms(uniforms).registerInternalVariables(batchDims).declareVariables(
          ...inputVariables,
          output
        )}
  ${declareFunctions}
  ${isVec4 ? makeMatMulPackedVec4Source(elementsPerThread, workgroupSize, dataType, batchDims) : makeMatMulPackedSource(elementsPerThread, workgroupSize, dataType, batchDims)}
                   `;
      };
      return {
        name: "MatMul",
        shaderCache: {
          hint: `${elementsPerThread};${activationAttributes.activation};${isVec4};${isChannelsLast}`,
          inputDependencies
        },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
          programUniforms
        }),
        getShaderSource
      };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/3rd-party/conv2d_mm_webgpu.ts
var conv2dCommonSnippet, createConv2DMatMulProgramInfo;
var init_conv2d_mm_webgpu = __esm({
  "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv2d_mm_webgpu.ts"() {
    "use strict";
    init_wasm_common();
    init_log();
    init_common();
    init_fuse_utils();
    init_activation_util();
    init_conv_util();
    init_matmul_packed_webgpu();
    conv2dCommonSnippet = (isChannelsLast, fitAOuter, fitBOuter, fitInner, addBias = false, attributes, innerElementSizeX = 4, innerElementSizeW = 4, innerElementSize = 4, dataType = "f32") => {
      const getXSnippet = (innerElementSize2) => {
        switch (innerElementSize2) {
          case 1:
            return "resData = x[xIndex];";
          case 3:
            return `resData = vec3<${dataType}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;
          case 4:
            return "resData = x[xIndex / 4];";
          default:
            throw new Error(`innerElementSize ${innerElementSize2} is not supported.`);
        }
      };
      const getWSnippet = (innerElementSize2) => {
        switch (innerElementSize2) {
          case 1:
            return "return w[row * i32(uniforms.w_shape[3]) + colIn];";
          case 4:
            return "return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";
          default:
            throw new Error(`innerElementSize ${innerElementSize2} is not supported.`);
        }
      };
      const coordASnippet = isChannelsLast ? `
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    ` : `
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `;
      const coordResSnippet = isChannelsLast ? `
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    ` : `
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `;
      const xHeight = isChannelsLast ? "i32(uniforms.x_shape[1])" : "i32(uniforms.x_shape[2])";
      const xWidth = isChannelsLast ? "i32(uniforms.x_shape[2])" : "i32(uniforms.x_shape[3])";
      const row = isChannelsLast ? "row" : "col";
      const col = isChannelsLast ? "col" : "row";
      const readXSnippet = `
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
    let outRow = ${row} / outWidth;
    let outCol = ${row} % outWidth;

    let WRow = ${col} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${col} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${col} % inChannels;
    var resData = ${typeSnippet(innerElementSizeX, dataType)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${xHeight} && xCol >= 0 && xCol < ${xWidth}) {
      ${coordASnippet}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${getXSnippet(innerElementSizeX)}
    }
    return resData;`;
      const sampleX = isChannelsLast ? fitAOuter && fitInner ? `
    let col = colIn * ${innerElementSizeX};
    ${readXSnippet}` : `
    let col = colIn * ${innerElementSizeX};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${readXSnippet}
    }
    return ${typeSnippet(innerElementSizeX, dataType)}(0.0);` : fitInner && fitBOuter ? `
    let col = colIn * ${innerElementSizeX};
    ${readXSnippet}` : `
    let col = colIn * ${innerElementSizeX};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${readXSnippet}
    }
    return ${typeSnippet(innerElementSizeX, dataType)}(0.0);`;
      const sampleW = `${getWSnippet(innerElementSizeW)}`;
      const resType = typeSnippet(innerElementSize, dataType);
      const aType = isChannelsLast ? typeSnippet(innerElementSizeX, dataType) : typeSnippet(innerElementSizeW, dataType);
      const bType = isChannelsLast ? typeSnippet(innerElementSizeW, dataType) : typeSnippet(innerElementSizeX, dataType);
      const applyActivation = getActivationSnippet(attributes, resType, dataType);
      const userCode = `
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${aType} {
      ${isChannelsLast ? sampleX : sampleW}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${bType} {
      ${isChannelsLast ? sampleW : sampleX}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${resType}) {
      let col = colIn * ${innerElementSize};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
      ${coordResSnippet}
      ${biasSnippet(addBias)}
      ${applyActivation}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`;
      return userCode;
    };
    createConv2DMatMulProgramInfo = (inputs, attributes, outputShape, dimAOuter, dimBOuter, dimInner, hasBias, sequentialAccessByThreads) => {
      const isChannelsLast = attributes.format === "NHWC";
      const inChannels = isChannelsLast ? inputs[0].dims[3] : inputs[0].dims[1];
      const batchSize = outputShape[0];
      const outWidth = isChannelsLast ? outputShape[2] : outputShape[3];
      const outHeight = isChannelsLast ? outputShape[1] : outputShape[2];
      const outChannels = isChannelsLast ? outputShape[3] : outputShape[1];
      const isVec4 = isChannelsLast && (inChannels % 4 === 0 || inChannels % 3 === 0) && outChannels % 4 === 0;
      const dispatchX = isChannelsLast ? outChannels : outWidth * outHeight;
      const dispatchY = isChannelsLast ? outWidth * outHeight : outChannels;
      const workGroupSize = [8, 8, 1];
      const elementsPerThread = dimAOuter <= 8 ? [4, 1, 1] : [4, 4, 1];
      const dispatch = [
        Math.ceil(dispatchX / workGroupSize[0] / elementsPerThread[0]),
        Math.ceil(dispatchY / workGroupSize[1] / elementsPerThread[1]),
        Math.ceil(batchSize / workGroupSize[2] / elementsPerThread[2])
      ];
      LOG_DEBUG("verbose", () => `[conv2d_mm_webgpu] dispatch = ${dispatch}`);
      const innerElementSize = isVec4 ? isChannelsLast && inChannels % 4 !== 0 ? 3 : 4 : 1;
      const tileAOuter = workGroupSize[1] * elementsPerThread[1];
      const tileBOuter = workGroupSize[0] * elementsPerThread[0];
      const tileInner = Math.max(workGroupSize[0] * innerElementSize, workGroupSize[1]);
      const fitAOuter = dimAOuter % tileAOuter === 0;
      const fitBOuter = dimBOuter % tileBOuter === 0;
      const fitInner = dimInner % tileInner === 0;
      const elementsSize = isVec4 ? [innerElementSize, 4, 4] : [1, 1, 1];
      const programUniforms = [
        { type: 6 /* int32 */, data: dimAOuter },
        { type: 6 /* int32 */, data: dimBOuter },
        { type: 6 /* int32 */, data: dimInner },
        { type: 6 /* int32 */, data: [attributes.pads[0], attributes.pads[1]] },
        { type: 6 /* int32 */, data: attributes.strides },
        { type: 6 /* int32 */, data: attributes.dilations }
      ];
      appendActivationUniformsData(attributes, programUniforms);
      programUniforms.push(...createTensorShapeVariables(inputs[0].dims, inputs[1].dims));
      const inputDependencies = ["rank", "rank"];
      if (hasBias) {
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        inputDependencies.push("rank");
      }
      programUniforms.push(...createTensorShapeVariables(outputShape));
      const getShaderSource = (shaderHelper) => {
        const uniforms = [
          { name: "dim_a_outer", type: "i32" },
          { name: "dim_b_outer", type: "i32" },
          { name: "dim_inner", type: "i32" },
          { name: "pad", type: "i32", length: 2 },
          { name: "stride", type: "i32", length: 2 },
          { name: "dilation", type: "i32", length: 2 }
        ];
        appendActivationUniforms(attributes, uniforms);
        const components = isVec4 ? 4 : 1;
        const t = tensorTypeToWsglStorageType(inputs[0].dataType);
        let declareFunctions = `
      fn setOutputAtIndex(flatIndex : i32, value : ${isVec4 ? `vec4<${t}>` : t}) {
        result[flatIndex] = ${isVec4 ? `vec4<${t}>` : t}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${isVec4 ? `vec4<${t}>` : t}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${isVec4 ? "/ 4" : ""}, value);
      }`;
        const x = inputVariable(
          "x",
          inputs[0].dataType,
          inputs[0].dims.length,
          innerElementSize === 3 ? 1 : innerElementSize
        );
        const w = inputVariable("w", inputs[1].dataType, inputs[1].dims.length, components);
        const inputVariables = [x, w];
        const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
        if (hasBias) {
          const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, components);
          inputVariables.push(bias);
          declareFunctions += `
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${isVec4 ? `vec4<${t}>` : t} {
          return bias[coords.${isChannelsLast ? "w" : "y"}${isVec4 ? "/ 4" : ""}];
        }`;
        }
        return `
        ${utilFunctions("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
        ${declareFunctions}
        ${conv2dCommonSnippet(
          isChannelsLast,
          fitAOuter,
          fitBOuter,
          fitInner,
          hasBias,
          attributes,
          elementsSize[0],
          elementsSize[1],
          elementsSize[2],
          t
        )}
        ${isVec4 ? makeMatMulPackedVec4Source(elementsPerThread, workGroupSize, t, void 0, !isChannelsLast, tileInner) : makeMatMulPackedSource(
          elementsPerThread,
          workGroupSize,
          t,
          void 0,
          !isChannelsLast,
          tileInner,
          false,
          void 0,
          sequentialAccessByThreads
        )}`;
      };
      return {
        name: "Conv2DMatMul",
        shaderCache: {
          hint: `${attributes.cacheKey};${innerElementSize};${isVec4};${fitAOuter};${fitBOuter};${fitInner};${tileAOuter};${tileBOuter};${tileInner}`,
          inputDependencies
        },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
          programUniforms
        }),
        getShaderSource
      };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/conv-grouped.ts
var createGroupedConvProgramInfo, createGroupedConvVectorizeProgramInfo;
var init_conv_grouped = __esm({
  "web/lib/wasm/jsep/webgpu/ops/conv-grouped.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    init_conv();
    init_fuse_utils();
    createGroupedConvProgramInfo = (inputs, attributes, squeezeOutputShapeFunction) => {
      const hasBias = inputs.length > 2;
      const processBias = hasBias ? "value += b[output_channel];" : "";
      const xShape = inputs[0].dims;
      const wShape = inputs[1].dims;
      const outputChannelsPerGroup = wShape[0] / attributes.group;
      const isChannelLast = attributes.format === "NHWC";
      const outputShape = calculateOutputShape(
        xShape,
        wShape,
        attributes.dilations,
        attributes.pads,
        attributes.strides,
        isChannelLast
      );
      const outputSize = ShapeUtil.size(outputShape);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: attributes.dilations },
        { type: 12 /* uint32 */, data: [attributes.strides[0], attributes.strides[1]] },
        { type: 12 /* uint32 */, data: [attributes.pads[0], attributes.pads[1]] },
        { type: 12 /* uint32 */, data: outputChannelsPerGroup }
      ];
      appendActivationUniformsData(attributes, programUniforms);
      programUniforms.push(...createTensorShapeVariables(xShape, wShape));
      const inputDependencies = ["rank", "rank"];
      if (hasBias) {
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        inputDependencies.push("rank");
      }
      programUniforms.push(...createTensorShapeVariables(outputShape));
      const getShaderSource = (shaderHelper) => {
        const output = outputVariable("output", inputs[0].dataType, outputShape.length);
        const baseType = tensorTypeToWsglStorageType(output.type.tensor);
        const applyActivation = getActivationSnippet(attributes, output.type.value, baseType);
        const x = inputVariable("x", inputs[0].dataType, xShape.length);
        const w = inputVariable("w", inputs[1].dataType, wShape.length);
        const inputVars = [x, w];
        if (hasBias) {
          inputVars.push(inputVariable("b", inputs[2].dataType, inputs[2].dims.length));
        }
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "dilations", type: "u32", length: attributes.dilations.length },
          { name: "strides", type: "u32", length: 2 },
          { name: "pads", type: "u32", length: 2 },
          { name: "output_channels_per_group", type: "u32" }
        ];
        appendActivationUniforms(attributes, uniforms);
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, output)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${output.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${isChannelLast ? 3 : 1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${isChannelLast ? 1 : 2}], outputIndices[${isChannelLast ? 2 : 3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel / uniforms.output_channels_per_group;

    var value: ${output.type.value} = ${output.type.value}(0);
    for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
      let input_channel = group_id * uniforms.w_shape[1] + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[${isChannelLast ? 1 : 2}]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[${isChannelLast ? 2 : 3}]) {
            continue;
          }

          let xVal = ${isChannelLast ? x.get("batch", "xHeight", "xWidth", "input_channel") : x.get("batch", "input_channel", "xHeight", "xWidth")};
          let wVal = ${w.get("output_channel", "wInChannel", "wHeight", "wWidth")};
          value += xVal*wVal;
        }
      }
    }
    ${processBias}
    ${applyActivation}
    ${output.setByOffset("global_idx", "value")}
  }`;
      };
      return {
        name: "GroupedConv",
        shaderCache: { hint: attributes.cacheKey, inputDependencies },
        getRunData: () => ({
          outputs: [{
            dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
            dataType: inputs[0].dataType
          }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    createGroupedConvVectorizeProgramInfo = (inputs, attributes, outputShape) => {
      const hasBias = inputs.length > 2;
      const components = getMaxComponents(outputShape[3]);
      const outputNumber = getMaxComponents(outputShape[2]);
      const outputSize = ShapeUtil.size(outputShape) / components / outputNumber;
      const xShape = [inputs[0].dims[0], inputs[0].dims[1], inputs[0].dims[2], inputs[0].dims[3] / components];
      const wShape = [inputs[1].dims[0], inputs[1].dims[1], inputs[1].dims[2], inputs[1].dims[3] / components];
      const outputShapeInShader = [outputShape[0], outputShape[1], outputShape[2], outputShape[3] / components];
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 6 /* int32 */, data: [attributes.strides[0], attributes.strides[1]] },
        { type: 6 /* int32 */, data: [attributes.pads[0], attributes.pads[1]] }
      ];
      appendActivationUniformsData(attributes, programUniforms);
      programUniforms.push(...createTensorShapeVariables(xShape, wShape, outputShapeInShader));
      const xNumber = (outputNumber - 1) * attributes.strides[1] + wShape[1];
      const getShaderSource = (shaderHelper) => {
        const output = outputVariable("output", inputs[0].dataType, outputShapeInShader.length, components);
        const baseType = tensorTypeToWsglStorageType(output.type.tensor);
        const applyActivation = getActivationSnippet(attributes, output.type.value, baseType);
        const x = inputVariable("x", inputs[0].dataType, xShape.length, components);
        const w = inputVariable("w", inputs[1].dataType, wShape.length, components);
        const inputVars = [x, w];
        if (hasBias) {
          inputVars.push(inputVariable("b", inputs[2].dataType, inputs[2].dims, components));
        }
        const processBias = hasBias ? "value += b[output_channel];" : "";
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "strides", type: "i32", length: 2 },
          { name: "pads", type: "i32", length: 2 }
        ];
        appendActivationUniforms(attributes, uniforms);
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, output)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${outputNumber}u;
    let col = (index1 % width1) * ${outputNumber}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${x.type.value}, ${xNumber}>;
    var values: array<${output.type.value}, ${outputNumber}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${wShape[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${xNumber}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${x.get("batch", "u32(x_height)", "u32(x_width)", "input_channel")};
          } else {
            x_vals[i] = ${x.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${wShape[1]}; w_width++) {
          let w_val = ${w.get("w_height", "w_width", "0", "output_channel")};
          for (var i = 0u; i < ${outputNumber}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${outputNumber}u; i++) {
      var value = values[i];
      ${processBias}
      ${applyActivation}
      ${output.set("batch", "row", "col + i", "output_channel", "value")};
    }
  }`;
      };
      return {
        name: "GroupedConv-Vectorize",
        shaderCache: {
          hint: `${attributes.cacheKey};${components};${outputNumber};${xNumber};${wShape[0]};${wShape[1]}`,
          inputDependencies: hasBias ? ["rank", "rank", "type"] : ["rank", "rank"]
        },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/matmul.ts
var createNaiveMatmulProgramInfo, validateInputs8, matMul;
var init_matmul = __esm({
  "web/lib/wasm/jsep/webgpu/ops/matmul.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_matmul_packed_webgpu();
    init_common();
    init_fuse_utils();
    createNaiveMatmulProgramInfo = (inputs, activationAttributes, outputShape, reshapedOutputShape, isChannelsLast = false) => {
      const aShape = inputs[0].dims;
      const bShape = inputs[1].dims;
      const M = aShape[aShape.length - 2];
      const N = bShape[bShape.length - 1];
      const K = aShape[aShape.length - 1];
      const components = getMaxComponents(N);
      const aComponents = getMaxComponents(K);
      const outputNumber = getMaxComponents(M);
      const outputSize = ShapeUtil.size(outputShape) / components / outputNumber;
      const hasBias = inputs.length > 2;
      const outerDims = reshapedOutputShape ? reshapedOutputShape.slice(0, -2) : outputShape.slice(0, -2);
      const batchSize = ShapeUtil.size(outerDims);
      const outputShapeInShader = [batchSize, M, N];
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: M },
        { type: 12 /* uint32 */, data: N },
        { type: 12 /* uint32 */, data: K }
      ];
      appendActivationUniformsData(activationAttributes, programUniforms);
      programUniforms.push(...createTensorShapeVariables(outerDims, aShape, bShape));
      if (hasBias) {
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
      }
      programUniforms.push(...createTensorShapeVariables(outputShapeInShader));
      const getShaderSource = (shaderHelper) => {
        const batchDims = internalVariable("batch_dims", inputs[0].dataType, outerDims.length);
        const a = inputVariable("a", inputs[0].dataType, aShape.length, aComponents);
        const b = inputVariable("b", inputs[1].dataType, bShape.length, components);
        const output = outputVariable("output", inputs[0].dataType, outputShapeInShader.length, components);
        const baseType = tensorTypeToWsglStorageType(output.type.tensor);
        const applyActivation = getActivationSnippet(activationAttributes, output.type.value, baseType);
        const inputVariables = [a, b];
        let processBias = "";
        if (hasBias) {
          const biasComponents = isChannelsLast ? components : 1;
          inputVariables.push(inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, biasComponents));
          processBias = `${isChannelsLast ? `value += bias[col / ${biasComponents}];` : `value += ${output.type.value}(bias[row + i]);`}`;
        }
        const outerDimsA = aShape.slice(0, -2);
        const outerDimsB = bShape.slice(0, -2);
        const broadCastADims = getBroadcastDims(outerDimsA, outerDims);
        const broadCastBDims = getBroadcastDims(outerDimsB, outerDims);
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "M", type: "u32" },
          { name: "N", type: "u32" },
          { name: "K", type: "u32" }
        ];
        appendActivationUniforms(activationAttributes, uniforms);
        const getIndices = (variable, broadCastDims) => {
          const rank = variable.rank;
          const name = variable.name;
          if (rank === 2) {
            return `var ${name}_indices = ${variable.type.indices}(0u, 0u);`;
          }
          const batchRank = batchDims.rank;
          let resStr = `var ${name}_indices: ${variable.type.indices};`;
          for (let i = rank - 2 - 1, j = batchRank - 1; i >= 0; i--, j--) {
            resStr += `
${name}_indices[${i}] = ${batchRank > 1 ? `batch_indices[${j}]` : "batch_indices"};`;
          }
          broadCastDims.forEach((i) => {
            resStr += `
${name}_indices[${i}] = 0;`;
          });
          resStr += `${name}_indices[${rank - 2}] = 0u;
                     ${name}_indices[${rank - 1}] = 0u;`;
          return resStr;
        };
        const calcResult = () => {
          let calcStr = `var a_data: ${a.type.value};`;
          for (let i = 0; i < aComponents; i++) {
            calcStr += `
              let b_data${i} = b[(b_offset + (k + ${i}) * uniforms.N + col) / ${components}];`;
          }
          for (let i = 0; i < outputNumber; i++) {
            calcStr += `a_data = a[(a_offset + (row + ${i}) * uniforms.K + k) / ${aComponents}];`;
            for (let j = 0; j < aComponents; j++) {
              calcStr += `
            values[${i}] = fma(${b.type.value}(a_data${aComponents === 1 ? "" : `[${j}]`}), b_data${j}, values[${i}]);
`;
            }
          }
          return calcStr;
        };
        return `
  ${shaderHelper.registerUniforms(uniforms).registerInternalVariables(batchDims).declareVariables(
          ...inputVariables,
          output
        )}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${components})) * ${components};
    var index1 = global_idx / (uniforms.N / ${components});
    let stride1 = uniforms.M / ${outputNumber};
    let row = (index1 % stride1) * ${outputNumber};
    let batch = index1 / stride1;

    ${outputShape.length === 2 ? "" : `let batch_indices = ${batchDims.offsetToIndices("batch")};`}
    ${getIndices(a, broadCastADims)}
    let a_offset = ${a.indicesToOffset("a_indices")};
    ${getIndices(b, broadCastBDims)}
    let b_offset = ${b.indicesToOffset("b_indices")};
    var values: array<${output.type.value}, ${outputNumber}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${aComponents}) {
      ${calcResult()}
    }
    for (var i = 0u; i < ${outputNumber}u; i++) {
      var value = values[i];
      ${processBias}
      ${applyActivation}
      let cur_indices = ${output.type.indices}(batch, row + i, col);
      let offset = ${output.indicesToOffset("cur_indices")};
      ${output.setByOffset(`offset / ${components}`, "value")};
    }
  }
  `;
      };
      return {
        name: "MatMulNaive",
        shaderCache: {
          hint: `${activationAttributes.activation};${components};${aComponents};${outputNumber};${isChannelsLast}`,
          inputDependencies: hasBias ? ["rank", "rank", "rank"] : ["rank", "rank"]
        },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    validateInputs8 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("MatMul requires 2 inputs.");
      }
      if (inputs[0].dims[inputs[0].dims.length - 1] !== inputs[1].dims[inputs[1].dims.length - 2]) {
        throw new Error("shared dimension does not match.");
      }
    };
    matMul = (context) => {
      validateInputs8(context.inputs);
      const outputShape = BroadcastUtil.calcShape(context.inputs[0].dims, context.inputs[1].dims, true);
      if (!outputShape) {
        throw new Error("Can't use matmul on the given tensors");
      }
      const N = outputShape[outputShape.length - 1];
      const K = context.inputs[0].dims[context.inputs[0].dims.length - 1];
      if (N < 8 && K < 8) {
        context.compute(createNaiveMatmulProgramInfo(context.inputs, { activation: "" }, outputShape));
      } else {
        context.compute(createMatmulProgramInfo(context.inputs, { activation: "" }, outputShape));
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/conv.ts
var calculateOutputShape, weightTransposeAttribute, validateInputs9, getAdjustedConvAttributes, parseConvAttributes, conv2d, conv1d, conv;
var init_conv = __esm({
  "web/lib/wasm/jsep/webgpu/ops/conv.ts"() {
    "use strict";
    init_util();
    init_conv2d_mm_webgpu();
    init_matmul_packed_webgpu();
    init_conv_grouped();
    init_fuse_utils();
    init_matmul();
    init_transpose();
    calculateOutputShape = (inputShape, kernelShape, dilations, adjustPads, strides, isChannelLast) => {
      const batchSize = inputShape[0];
      const inputSpatialShape = inputShape.slice(isChannelLast ? 1 : 2, isChannelLast ? 3 : 4);
      const spatialRank = inputSpatialShape.length;
      const outChannels = kernelShape[0];
      const kernelSpatialShape = kernelShape.slice(2);
      const dilatedKernelShape = kernelSpatialShape.map((v, i) => v + (v - 1) * (dilations[i] - 1));
      const inputSpatialShapeWithPad = inputSpatialShape.map((v, i) => v + adjustPads[i] + adjustPads[i + spatialRank]);
      const outputShape = inputSpatialShapeWithPad.map((v, i) => Math.floor((v - dilatedKernelShape[i] + strides[i]) / strides[i]));
      outputShape.splice(0, 0, batchSize);
      outputShape.splice(isChannelLast ? 3 : 1, 0, outChannels);
      return outputShape;
    };
    weightTransposeAttribute = [2, 3, 1, 0];
    validateInputs9 = (inputs, attributes) => {
      if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
        throw new Error("Conv requires 2 or 3 inputs");
      }
      if (inputs[0].dims.length !== 4 && inputs[0].dims.length !== 3) {
        throw new Error("currently only support conv 1D and 2D");
      }
      if (inputs[0].dims.length !== inputs[1].dims.length) {
        throw new Error("filter does not have same dimension as input");
      }
      const dataChannel = inputs[0].dims[attributes.format === "NHWC" ? inputs[0].dims.length - 1 : 1];
      const filterInChannel = inputs[1].dims[1] * attributes.group;
      if (dataChannel !== filterInChannel) {
        throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
      }
      if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[1].dims[0] !== inputs[2].dims[0])) {
        throw new Error("invalid bias");
      }
      const spatialRank = inputs[0].dims.length - 2;
      if (attributes.dilations.length !== spatialRank) {
        throw new Error(`dilations should be ${spatialRank}D`);
      }
      if (attributes.strides.length !== spatialRank) {
        throw new Error(`strides should be ${spatialRank}D`);
      }
      if (attributes.pads.length !== spatialRank * 2) {
        throw new Error(`pads should be ${spatialRank * 2}D`);
      }
      if (attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {
        throw new Error("invalid kernel shape");
      }
    };
    getAdjustedConvAttributes = (attributes, inputs) => {
      const kernelShape = attributes.kernelShape.slice();
      for (let i = 2; i < inputs[1].dims.length; ++i) {
        if (kernelShape[i - 2] === 0) {
          kernelShape[i - 2] = inputs[1].dims[i];
        }
      }
      const pads = attributes.pads.slice();
      PoolConvUtil.adjustPadsBasedOnAutoPad(
        inputs[0].dims,
        attributes.strides,
        attributes.dilations,
        kernelShape,
        pads,
        attributes.format === "NHWC",
        attributes.autoPad
      );
      const newAttributes = Object.assign({}, attributes);
      Object.assign(newAttributes, { kernelShape, pads });
      return newAttributes;
    };
    parseConvAttributes = (attributes) => {
      const activationAttributes = parseInternalActivationAttributes(attributes);
      const format = attributes.format;
      const autoPad = ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][attributes.auto_pad];
      const dilations = attributes.dilations;
      const group = attributes.group;
      const kernelShape = attributes.kernel_shape;
      const pads = attributes.pads;
      const strides = attributes.strides;
      const wIsConst = attributes.w_is_const();
      return {
        autoPad,
        format,
        dilations,
        group,
        kernelShape,
        pads,
        strides,
        wIsConst,
        ...activationAttributes,
        cacheKey: `${attributes.format};${activationAttributes.activation};`
      };
    };
    conv2d = (context, inputs, attributes) => {
      const adjustedAttributes = getAdjustedConvAttributes(attributes, inputs);
      const isChannelsLast = attributes.format === "NHWC";
      if (attributes.group !== 1) {
        const enableGroupedConvVectorize = !context.adapterInfo.isArchitecture("ampere");
        if (enableGroupedConvVectorize && isChannelsLast && inputs[1].dims[0] === attributes.group && inputs[1].dims[1] === 1 && attributes.dilations[0] === 1 && attributes.dilations[1] === 1) {
          const outputShape2 = calculateOutputShape(
            inputs[0].dims,
            inputs[1].dims,
            attributes.dilations,
            adjustedAttributes.pads,
            attributes.strides,
            isChannelsLast
          );
          const transposedWeight2 = context.kernelCustomData.wT ?? context.compute(
            createTransposeProgramInfo(inputs[1], weightTransposeAttribute),
            { inputs: [1], outputs: [attributes.wIsConst ? -2 : -1] }
          )[0];
          if (attributes.wIsConst && !context.kernelCustomData.wT) {
            context.kernelCustomData.wT = transposedWeight2;
          }
          const convInputs2 = [inputs[0], transposedWeight2];
          if (inputs.length === 3) {
            convInputs2.push(inputs[2]);
          }
          context.compute(
            createGroupedConvVectorizeProgramInfo(convInputs2, adjustedAttributes, outputShape2),
            { inputs: convInputs2 }
          );
        } else {
          context.compute(createGroupedConvProgramInfo(inputs, adjustedAttributes));
        }
        return;
      }
      const hasBias = inputs.length === 3;
      const inputHeight = inputs[0].dims[isChannelsLast ? 1 : 2];
      const inputWidth = inputs[0].dims[isChannelsLast ? 2 : 3];
      const inputChannels = inputs[0].dims[isChannelsLast ? 3 : 1];
      const weightHeight = inputs[1].dims[2];
      const weightWidth = inputs[1].dims[3];
      const outputShape = calculateOutputShape(
        inputs[0].dims,
        inputs[1].dims,
        attributes.dilations,
        adjustedAttributes.pads,
        attributes.strides,
        isChannelsLast
      );
      const outHeight = outputShape[isChannelsLast ? 1 : 2];
      const outWidth = outputShape[isChannelsLast ? 2 : 3];
      const outChannels = outputShape[isChannelsLast ? 3 : 1];
      const sameSize = isChannelsLast && weightHeight === inputHeight && weightWidth === inputWidth && attributes.pads[0] === 0 && attributes.pads[1] === 0;
      if (sameSize || weightHeight === 1 && weightWidth === 1 && attributes.dilations[0] === 1 && attributes.dilations[1] === 1 && attributes.strides[0] === 1 && attributes.strides[1] === 1 && attributes.pads[0] === 0 && attributes.pads[1] === 0) {
        const batch = outputShape[0];
        let xReshaped, wReshaped, matmulOutputShape;
        const matmulInputs = [];
        if (isChannelsLast) {
          const transposedWeight2 = context.kernelCustomData.wT ?? context.compute(
            createTransposeProgramInfo(inputs[1], weightTransposeAttribute),
            { inputs: [1], outputs: [attributes.wIsConst ? -2 : -1] }
          )[0];
          if (attributes.wIsConst && !context.kernelCustomData.wT) {
            context.kernelCustomData.wT = transposedWeight2;
          }
          if (sameSize) {
            const sharedDim = inputHeight * inputWidth * inputChannels;
            xReshaped = inputs[0].reshape([1, batch, sharedDim]);
            wReshaped = transposedWeight2.reshape([1, sharedDim, outChannels]);
            matmulOutputShape = [1, batch, outChannels];
          } else {
            xReshaped = inputs[0].reshape([batch, inputHeight * inputWidth, inputChannels]);
            wReshaped = transposedWeight2.reshape([1, inputChannels, outChannels]);
            matmulOutputShape = [batch, outHeight * outWidth, outChannels];
          }
          matmulInputs.push(xReshaped);
          matmulInputs.push(wReshaped);
        } else {
          xReshaped = inputs[0].reshape([batch, inputChannels, inputHeight * inputWidth]);
          wReshaped = inputs[1].reshape([1, outChannels, inputChannels]);
          matmulOutputShape = [batch, outChannels, outHeight * outWidth];
          matmulInputs.push(wReshaped);
          matmulInputs.push(xReshaped);
        }
        if (hasBias) {
          matmulInputs.push(inputs[2]);
        }
        const N = matmulOutputShape[2];
        const K = matmulInputs[0].dims[matmulInputs[0].dims.length - 1];
        if (N < 8 && K < 8) {
          context.compute(
            createNaiveMatmulProgramInfo(
              matmulInputs,
              adjustedAttributes,
              outputShape,
              matmulOutputShape,
              isChannelsLast
            ),
            { inputs: matmulInputs }
          );
        } else {
          context.compute(
            createMatmulProgramInfo(matmulInputs, adjustedAttributes, outputShape, matmulOutputShape, isChannelsLast),
            { inputs: matmulInputs }
          );
        }
        return;
      }
      const sequentialAccessByThreads = (
        /* backend.adapterInfo.isIntel() */
        true
      );
      const transposedWeight = context.kernelCustomData.wT ?? context.compute(
        createTransposeProgramInfo(inputs[1], weightTransposeAttribute),
        { inputs: [1], outputs: [attributes.wIsConst ? -2 : -1] }
      )[0];
      if (attributes.wIsConst && !context.kernelCustomData.wT) {
        context.kernelCustomData.wT = transposedWeight;
      }
      const convInputs = [inputs[0], transposedWeight];
      if (hasBias) {
        convInputs.push(inputs[2]);
      }
      const dimAOuter = isChannelsLast ? outHeight * outWidth : outChannels;
      const dimBOuter = isChannelsLast ? outChannels : outHeight * outWidth;
      const dimInner = weightHeight * weightWidth * inputChannels;
      context.compute(
        createConv2DMatMulProgramInfo(
          convInputs,
          adjustedAttributes,
          outputShape,
          dimAOuter,
          dimBOuter,
          dimInner,
          hasBias,
          sequentialAccessByThreads
        ),
        { inputs: convInputs }
      );
    };
    conv1d = (context, attributes) => {
      const isChannelLast = attributes.format === "NHWC";
      const inputs = [
        context.inputs[0].reshape(
          isChannelLast ? (
            // [N, W, C] -> [N, H=1, W, C]
            [context.inputs[0].dims[0], 1, context.inputs[0].dims[1], context.inputs[0].dims[2]]
          ) : (
            // [N, C, W] -> [N, C, H=1, W]
            [context.inputs[0].dims[0], context.inputs[0].dims[1], 1, context.inputs[0].dims[2]]
          )
        ),
        //[FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kW] -> [FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kH=1, kW]
        context.inputs[1].reshape([context.inputs[1].dims[0], context.inputs[1].dims[1], 1, context.inputs[1].dims[2]])
      ];
      if (context.inputs.length === 3) {
        inputs.push(context.inputs[2]);
      }
      const pads = [0, attributes.pads[0], 0, attributes.pads[1]];
      const strides = [1].concat(attributes.strides);
      const dilations = [1].concat(attributes.dilations);
      const kernelShape = [1].concat(attributes.kernelShape);
      const adjustedAttributes = getAdjustedConvAttributes({ ...attributes, pads, strides, dilations, kernelShape }, inputs);
      context.compute(createGroupedConvProgramInfo(
        inputs,
        adjustedAttributes,
        (outputShape) => isChannelLast ? [outputShape[0], outputShape[2], outputShape[3]] : []
      ));
    };
    conv = (context, attributes) => {
      validateInputs9(context.inputs, attributes);
      if (context.inputs[0].dims.length === 3) {
        conv1d(context, attributes);
      } else {
        conv2d(context, context.inputs, attributes);
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_mm_webgpu.ts
var conv2dTransposeCommonSnippet, createConv2DTransposeMatMulProgramInfo;
var init_conv_backprop_mm_webgpu = __esm({
  "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_mm_webgpu.ts"() {
    "use strict";
    init_wasm_common();
    init_log();
    init_common();
    init_fuse_utils();
    init_activation_util();
    init_conv_util();
    init_matmul_packed_webgpu();
    conv2dTransposeCommonSnippet = (isChannelsLast, addBias = false, attributes, type, innerElementSize = 4) => {
      const getWSnippet = (innerElementSize2) => {
        switch (innerElementSize2) {
          case 1:
            return "return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";
          case 4:
            return `
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];
            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];
            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];
            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];
            return ${type}(v0, v1, v2, v3);
            `;
          default:
            throw new Error(`innerElementSize ${innerElementSize2} is not supported.`);
        }
      };
      const coordASnippet = isChannelsLast ? `
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      ` : `
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `;
      const coordResSnippet = isChannelsLast ? `
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    ` : `
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `;
      const xHeight = isChannelsLast ? "i32(uniforms.x_shape[1])" : "i32(uniforms.x_shape[2])";
      const xWidth = isChannelsLast ? "i32(uniforms.x_shape[2])" : "i32(uniforms.x_shape[3])";
      const row = isChannelsLast ? "row" : "col";
      const col = isChannelsLast ? "col" : "row";
      const readASnippet = `
      let inChannels = ${isChannelsLast ? "i32(uniforms.x_shape[3])" : "i32(uniforms.x_shape[1])"};
      let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
      let outRow = ${row} / outWidth;
      let outCol = ${row} % outWidth;

      let WRow = ${col} / (uniforms.filter_dims[1] * inChannels);
      let WCol = ${col} / inChannels % uniforms.filter_dims[1];
      let xR = f32(outRow - uniforms.pads[0] + uniforms.dilations[0] * WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + uniforms.dilations[1] * WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(${xHeight}) || fract(xR) > 0.0) {
        return ${type}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${xWidth}) || fract(xC) > 0.0) {
        return ${type}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${col} % inChannels;
      ${coordASnippet}
      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${innerElementSize}];`;
      const sampleA = isChannelsLast ? `
      let col = colIn * ${innerElementSize};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
        ${readASnippet}
      }
      return ${type}(0.0);` : `
      let col = colIn * ${innerElementSize};
      if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
        ${readASnippet}
      }
      return ${type}(0.0);`;
      const sampleW = `
      let col = colIn * ${innerElementSize};
      let inChannels = ${isChannelsLast ? "i32(uniforms.x_shape[3])" : "i32(uniforms.x_shape[1])"};
      let coordX = uniforms.filter_dims[0] - 1 - row / (uniforms.filter_dims[1] * inChannels);
      let coordY = uniforms.filter_dims[1] - 1 - (row / inChannels) % uniforms.filter_dims[1];
      if (${isChannelsLast ? "row < uniforms.dim_inner && col < uniforms.dim_b_outer" : "row < uniforms.dim_inner && col < uniforms.dim_a_outer"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${getWSnippet(innerElementSize)}
      }
      return ${type}(0.0);
      `;
      const applyActivation = getActivationSnippet(attributes, type);
      const userCode = `
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${type} {
    ${isChannelsLast ? sampleA : sampleW}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${type} {
    ${isChannelsLast ? sampleW : sampleA}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${type}) {
    let col = colIn * ${innerElementSize};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
      var value = valueInput;
      let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
      ${coordResSnippet}
      ${biasSnippet(addBias)}
      ${applyActivation}
      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${innerElementSize}] = value;
    }
  }`;
      return userCode;
    };
    createConv2DTransposeMatMulProgramInfo = (inputs, attributes, outputShape, dimAOuter, dimBOuter, dimInner, hasBias, sequentialAccessByThreads) => {
      const isChannelsLast = attributes.format === "NHWC";
      const inChannels = isChannelsLast ? inputs[0].dims[3] : inputs[0].dims[1];
      const batchSize = outputShape[0];
      const outWidth = isChannelsLast ? outputShape[2] : outputShape[3];
      const outHeight = isChannelsLast ? outputShape[1] : outputShape[2];
      const outChannels = isChannelsLast ? outputShape[3] : outputShape[1];
      const isVec4 = isChannelsLast && (inChannels % 4 === 0 && inChannels % 3) && outChannels % 4 === 0;
      const dispatchX = isChannelsLast ? outChannels : outWidth * outHeight;
      const dispatchY = isChannelsLast ? outWidth * outHeight : outChannels;
      const workGroupSize = [8, 8, 1];
      const elementsPerThread = dimAOuter <= 8 ? [4, 1, 1] : [4, 4, 1];
      const dispatch = [
        Math.ceil(dispatchX / workGroupSize[0] / elementsPerThread[0]),
        Math.ceil(dispatchY / workGroupSize[1] / elementsPerThread[1]),
        Math.ceil(batchSize / workGroupSize[2] / elementsPerThread[2])
      ];
      LOG_DEBUG("verbose", () => `[conv_backprop_mm_webgpu] dispatch = ${dispatch}`);
      const innerElementSize = isVec4 ? 4 : 1;
      const tileInner = Math.max(workGroupSize[0] * innerElementSize, workGroupSize[1]);
      const components = isVec4 ? 4 : 1;
      const filterDims = [attributes.kernelShape[isChannelsLast ? 1 : 2], attributes.kernelShape[isChannelsLast ? 2 : 3]];
      const effectiveFilterDims = [
        filterDims[0] + (attributes.dilations[0] <= 1 ? 0 : (filterDims[0] - 1) * (attributes.dilations[0] - 1)),
        filterDims[1] + (attributes.dilations[1] <= 1 ? 0 : (filterDims[1] - 1) * (attributes.dilations[1] - 1))
      ];
      const pads = [
        effectiveFilterDims[0] - 1 - Math.floor((attributes.pads[0] + attributes.pads[2]) / 2),
        effectiveFilterDims[1] - 1 - Math.floor((attributes.pads[1] + attributes.pads[3]) / 2)
      ];
      const programUniforms = [
        { type: 6 /* int32 */, data: dimAOuter },
        { type: 6 /* int32 */, data: dimBOuter },
        { type: 6 /* int32 */, data: dimInner },
        { type: 6 /* int32 */, data: attributes.strides },
        { type: 6 /* int32 */, data: attributes.dilations },
        { type: 6 /* int32 */, data: filterDims },
        { type: 6 /* int32 */, data: pads }
      ];
      appendActivationUniformsData(attributes, programUniforms);
      programUniforms.push(...createTensorShapeVariables(inputs[0].dims, inputs[1].dims));
      const inputDependencies = ["rank", "rank"];
      if (hasBias) {
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        inputDependencies.push("rank");
      }
      programUniforms.push(...createTensorShapeVariables(outputShape));
      const getShaderSource = (shaderHelper) => {
        const x = inputVariable("x", inputs[0].dataType, inputs[0].dims.length, components);
        const w = inputVariable("w", inputs[1].dataType, inputs[1].dims.length, 1);
        const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
        const inputVariables = [x, w];
        let declareFunctions = "";
        if (hasBias) {
          const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, components);
          inputVariables.push(bias);
          declareFunctions += `
          fn getBiasByOutputCoords(coords : vec4<i32>) -> ${bias.type.value} {
            return bias[coords.${isChannelsLast ? "w" : "y"}${isVec4 ? "/ 4" : ""}];
          }`;
        }
        const uniforms = [
          { name: "dim_a_outer", type: "i32" },
          { name: "dim_b_outer", type: "i32" },
          { name: "dim_inner", type: "i32" },
          { name: "strides", type: "i32", length: 2 },
          { name: "dilations", type: "i32", length: 2 },
          { name: "filter_dims", type: "i32", length: filterDims.length },
          { name: "pads", type: "i32", length: pads.length }
        ];
        appendActivationUniforms(attributes, uniforms);
        const elemType = tensorTypeToWsglStorageType(inputs[0].dataType, 1);
        if (elemType !== "f16" && elemType !== "f32") {
          throw new Error(`elemType ${elemType} is not supported.`);
        }
        return `
        ${utilFunctions("uniforms.result_strides")}
        ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)};
        ${declareFunctions}
        ${conv2dTransposeCommonSnippet(isChannelsLast, hasBias, attributes, x.type.value, innerElementSize)}
        ${isVec4 ? makeMatMulPackedVec4Source(
          elementsPerThread,
          workGroupSize,
          elemType,
          void 0,
          !isChannelsLast,
          tileInner
        ) : makeMatMulPackedSource(
          elementsPerThread,
          workGroupSize,
          elemType,
          void 0,
          !isChannelsLast,
          tileInner,
          false,
          void 0,
          sequentialAccessByThreads
        )}`;
      };
      return {
        name: "Conv2DTransposeMatMul",
        shaderCache: { hint: `${attributes.cacheKey};${elementsPerThread};${workGroupSize};${isVec4}`, inputDependencies },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
          programUniforms
        }),
        getShaderSource
      };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_webgpu.ts
var createConvTranspose2DOpProgramShaderSource, createConvTranspose2DProgramInfo;
var init_conv_backprop_webgpu = __esm({
  "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_webgpu.ts"() {
    "use strict";
    init_wasm_common();
    init_log();
    init_util();
    init_common();
    createConvTranspose2DOpProgramShaderSource = (shaderHelper, inputs, outputShape, hasBias, is1DimensionDispatch, isVec4 = false, dataType, uniforms, isChannelsLast = false) => {
      const rowDim = isChannelsLast ? 1 : 2;
      const colDim = isChannelsLast ? 2 : 3;
      const channelDim = isChannelsLast ? 3 : 1;
      const workPerThread = isVec4 ? 2 : 1;
      let declareFunctions = `
  fn setOutputAtIndex(flatIndex : u32, value : ${isVec4 ? `vec4<${dataType}>` : dataType}) {
    result[flatIndex] = ${isVec4 ? `vec4<${dataType}>` : dataType}(value);
  }`;
      if (hasBias) {
        declareFunctions += `
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${isVec4 ? `vec4<${dataType}>` : dataType} {
      return bias[coords.${isChannelsLast ? "w" : "y"}${isVec4 ? "/ 4" : ""}];
    }`;
      }
      const components = isVec4 ? 4 : 1;
      const w = inputVariable("W", inputs[1].dataType, inputs[1].dims.length, components);
      const dy = inputVariable("Dy", inputs[0].dataType, inputs[0].dims.length, components);
      const inputVariables = [dy, w];
      if (hasBias) {
        inputVariables.push(inputVariable("bias", inputs[2].dataType, [outputShape[channelDim]].length, components));
      }
      const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
      const codeSnippet4 = `{
        let batch: u32 = ${is1DimensionDispatch ? "global_id.z" : "workgroup_id.z"} / uniforms.result_shape[1];
        let r = ${is1DimensionDispatch ? "global_id.z" : "workgroup_id.z"} % uniforms.result_shape[1];
        let c = ${is1DimensionDispatch ? "global_id.y" : "workgroup_id.y"} * ${workPerThread};
        let d1: u32 = ${is1DimensionDispatch ? "global_id.x" : "workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(uniforms.pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${dataType}>, ${workPerThread}>;
        for (var i = 0; i < ${workPerThread}; i++) {
          dotProd[i] = vec4<${dataType}>(0.0);
        }
        for (var wR: u32 = 0; wR < uniforms.filter_dims[0]; wR = wR + 1) {
          var dyR = (${dataType}(dyCorner.x) + ${dataType}(wR)) / ${dataType}(uniforms.strides.x);
          let wRPerm = uniforms.filter_dims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${dataType}(uniforms.Dy_shape[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < uniforms.filter_dims[1]; wC = wC + 1) {
            let dyC = (${dataType}(dyCorner.y) + ${dataType}(wC)) / ${dataType}(uniforms.strides.y);
            let dyC2 = (${dataType}(dyCorner.y) + 1.0 + ${dataType}(wC)) / ${dataType}(uniforms.strides.y);
            let wCPerm = uniforms.filter_dims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${dataType}(uniforms.Dy_shape[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${dataType}(uniforms.Dy_shape[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1", "d2")};
                let wValue1 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 1", "d2")};
                let wValue2 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 2", "d2")};
                let wValue3 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 3", "d2")};

                var xValue = ${dy.get("batch", "idyR", "idyC", "d2")};
                let tmpval = vec4<${dataType}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${dy.get("batch", "idyR", "idyC2", "d2")};

                dotProd[1] = dotProd[1] + vec4<${dataType}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = uniforms.Dy_shape[${channelDim}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1", "d2")};
                let wValue1 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 1", "d2")};
                let wValue2 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 2", "d2")};
                let wValue3 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 3", "d2")};

                var xValue = ${dy.get("batch", "idyR", "idyC", "d2")};
                let tmpval = vec4<${dataType}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1", "d2")};
                let wValue1 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 1", "d2")};
                let wValue2 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 2", "d2")};
                let wValue3 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 3", "d2")};

                var xValue = ${dy.get("batch", "idyR", "idyC2", "d2")};
                let tmpval = vec4<${dataType}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${workPerThread}; i = i + 1) {
          let value = dotProd[i] + ${hasBias ? "bias[c+i]" : `vec4<${dataType}>(0.0)`};
          ${output.set("batch", "r", "c + i", "d1", "value")};
        }
      }`;
      const codeSnippet = `
          let outputIndices = ${output.offsetToIndices("global_idx")};
          let batch = ${output.indicesGet("outputIndices", 0)};
          let d1 = ${output.indicesGet("outputIndices", channelDim)};
          let r = ${output.indicesGet("outputIndices", rowDim)};
          let c = ${output.indicesGet("outputIndices", colDim)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / uniforms.output_channels_per_group;
          let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = ${dataType}(0.0);
          for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
            if (wR % uniforms.dilations.x != 0) {
              continue;
            }
            let dyR = (${dataType}(dyRCorner) + ${dataType}(wR)) / ${dataType}(uniforms.strides[0]);
            let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
            if (dyR < 0.0 || dyR >= ${dataType}(uniforms.Dy_shape[${rowDim}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
              if (wC % uniforms.dilations.y != 0) {
                continue;
              }
              let dyC = (${dataType}(dyCCorner) + ${dataType}(wC)) / ${dataType}(uniforms.strides.y);
              let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
              if (dyC < 0.0 || dyC >= ${dataType}(uniforms.Dy_shape[${colDim}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * uniforms.input_channels_per_group;
              for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + 1) {
                let xValue = ${isChannelsLast ? dy.get("batch", "idyR", "idyC", "inputChannel") : dy.get("batch", "inputChannel", "idyR", "idyC")};
                let wValue = ${w.get("inputChannel", "wOutChannel", "u32(wRPerm)", "u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${hasBias ? "bias[d1]" : `${dataType}(0.0)`};
          ${output.setByOffset("global_idx", "value")};
        `;
      return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
  ${declareFunctions}

    ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
  ${isVec4 ? codeSnippet4 : codeSnippet}}`;
    };
    createConvTranspose2DProgramInfo = (inputs, attributes, squeezeOutputShapeFunction) => {
      const hasBias = inputs.length > 2;
      const outputShape = attributes.outputShape;
      const outputSize = ShapeUtil.size(outputShape);
      const dispatch = [
        Math.ceil(outputSize / 64),
        1,
        1
      ];
      LOG_DEBUG("verbose", () => `[conv2d_backprop_webgpu] dispatch = ${dispatch}`);
      const isChannelsLast = attributes.format === "NHWC";
      const inputDependencies = ["rank", "rank"];
      const strides = [attributes.strides[0], attributes.strides[1]];
      const filterDims = [attributes.kernelShape[isChannelsLast ? 1 : 2], attributes.kernelShape[isChannelsLast ? 2 : 3]];
      const dilations = [attributes.dilations[0], attributes.dilations[1]];
      const effectiveFilterDims = [
        filterDims[0] + (attributes.dilations[0] <= 1 ? 0 : (attributes.kernelShape[isChannelsLast ? 1 : 2] - 1) * (attributes.dilations[0] - 1)),
        filterDims[1] + (attributes.dilations[1] <= 1 ? 0 : (attributes.kernelShape[isChannelsLast ? 2 : 3] - 1) * (attributes.dilations[1] - 1))
      ];
      const pads = [
        effectiveFilterDims[0] - 1 - Math.floor((attributes.pads[0] + attributes.pads[2]) / 2),
        effectiveFilterDims[1] - 1 - Math.floor(attributes.pads[1] + attributes.pads[3]) / 2
      ];
      const isVec4 = false;
      const group = attributes.group;
      const wShape = inputs[1].dims;
      const inputChannelsPerGroup = wShape[0] / group;
      const outputChannelsPerGroup = wShape[1];
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: strides },
        { type: 12 /* uint32 */, data: filterDims },
        { type: 12 /* uint32 */, data: dilations },
        { type: 12 /* uint32 */, data: effectiveFilterDims },
        { type: 6 /* int32 */, data: pads },
        { type: 12 /* uint32 */, data: inputChannelsPerGroup },
        { type: 12 /* uint32 */, data: outputChannelsPerGroup },
        ...createTensorShapeVariables(inputs[0].dims, inputs[1].dims)
      ];
      if (hasBias) {
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        inputDependencies.push("rank");
      }
      programUniforms.push(...createTensorShapeVariables(outputShape));
      const is1DimensionDispatch = dispatch[1] === 1 && dispatch[2] === 1;
      const getShaderSource = (shaderHelper) => {
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "strides", type: "u32", length: strides.length },
          { name: "filter_dims", type: "u32", length: filterDims.length },
          { name: "dilations", type: "u32", length: filterDims.length },
          { name: "effective_filter_dims", type: "u32", length: effectiveFilterDims.length },
          { name: "pads", type: "i32", length: pads.length },
          { name: "input_channels_per_group", type: "u32" },
          { name: "output_channels_per_group", type: "u32" }
        ];
        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
        return `${createConvTranspose2DOpProgramShaderSource(
          shaderHelper,
          inputs,
          outputShape,
          hasBias,
          is1DimensionDispatch,
          isVec4,
          dataType,
          uniforms,
          isChannelsLast
        )}`;
      };
      return {
        name: "ConvTranspose2D",
        shaderCache: { hint: `${attributes.cacheKey};`, inputDependencies },
        getRunData: () => ({
          dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
          outputs: [{
            dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
            dataType: inputs[0].dataType
          }],
          programUniforms
        }),
        getShaderSource
      };
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/conv-transpose.ts
var computeTotalPad, distributePadding, calculateOutputShapeAndPads, getAdjustedConvTransposeAttributes, parseConvTransposeAttributes, validateInputs10, weightTransposePerm, convTranspose2d, convTranspose1d, convTranspose;
var init_conv_transpose = __esm({
  "web/lib/wasm/jsep/webgpu/ops/conv-transpose.ts"() {
    "use strict";
    init_conv_backprop_mm_webgpu();
    init_conv_backprop_webgpu();
    init_fuse_utils();
    init_transpose();
    computeTotalPad = (inDim, stride, adj, kernel, dilation, outSize) => (inDim - 1) * stride + adj + (kernel - 1) * dilation + 1 - outSize;
    distributePadding = (totalPad, autoPad, pads, head, tail) => {
      const smallPad = Math.floor(totalPad / 2);
      if (autoPad === "SAME_UPPER") {
        pads[head] = smallPad;
        pads[tail] = totalPad - smallPad;
      } else if (autoPad === "SAME_LOWER") {
        pads[head] = totalPad - smallPad;
        pads[tail] = smallPad;
      }
    };
    calculateOutputShapeAndPads = (inputShape, kernelShape, dilations, autoPad, group, pads, strides, isChannelLast, outputPadding, outputShape) => {
      const spatialRank = inputShape.length - 2;
      const updateOutputShape = outputShape.length === 0;
      if (outputPadding.length === 0) {
        for (let i = 0; i < spatialRank; ++i) {
          outputPadding.push(0);
        }
      }
      const batchSize = inputShape[0];
      const outChannels = kernelShape[isChannelLast ? 3 : 1] * group;
      for (let i = 0, j = inputShape.length - spatialRank - (isChannelLast ? 1 : 0); i < spatialRank; ++i, ++j) {
        const inSize = inputShape[j];
        const outSize = updateOutputShape ? inSize * strides[i] : outputShape[i];
        const totalPad = computeTotalPad(inSize, strides[i], pads[i], kernelShape[j], dilations[i], outSize);
        distributePadding(totalPad, autoPad, pads, i, i + spatialRank);
        if (updateOutputShape) {
          outputShape.push(
            strides[i] * (inSize - 1) + outputPadding[i] + (kernelShape[j] - 1) * dilations[i] + 1 - pads[i] - pads[i + spatialRank]
          );
        }
      }
      outputShape.splice(0, 0, batchSize);
      outputShape.splice(isChannelLast ? 3 : 1, 0, outChannels);
    };
    getAdjustedConvTransposeAttributes = (attributes, inputs) => {
      const kernelShape = attributes.kernelShape.slice();
      if (attributes.kernelShape.length === 0 || attributes.kernelShape.reduce((a, b) => a * b, 1) === 0) {
        kernelShape.length = 0;
        for (let i = 2; i < inputs[1].dims.length; ++i) {
          kernelShape.push(inputs[1].dims[i]);
        }
      }
      const isChannelsLast = attributes.format === "NHWC";
      kernelShape.splice(0, 0, inputs[1].dims[0]);
      kernelShape.splice(isChannelsLast ? 3 : 1, 0, inputs[1].dims[1]);
      const pads = attributes.pads.slice();
      const outputShape = attributes.outputShape.slice();
      const outputPadding = attributes.outputPadding.slice();
      const inputShape = inputs[0].dims;
      let dilations = attributes.dilations.slice();
      if (dilations.reduce((a, b) => a + b, 0) === 0) {
        const spatialRank = inputs[0].dims.length - 2;
        dilations = new Array(spatialRank).fill(1);
      }
      let strides = attributes.strides.slice();
      if (strides.reduce((a, b) => a + b, 0) === 0) {
        const spatialRank = inputs[0].dims.length - 2;
        strides = new Array(spatialRank).fill(1);
      }
      calculateOutputShapeAndPads(
        inputShape,
        kernelShape,
        dilations,
        attributes.autoPad,
        attributes.group,
        pads,
        strides,
        isChannelsLast,
        outputPadding,
        outputShape
      );
      const newAttributes = Object.assign({}, attributes);
      Object.assign(newAttributes, { kernelShape, pads, outputPadding, outputShape, dilations, strides });
      return newAttributes;
    };
    parseConvTransposeAttributes = (attributes) => {
      const activationAttributes = parseInternalActivationAttributes(attributes);
      const format = attributes.format;
      const autoPad = [
        "NOTSET",
        "VALID",
        "SAME_UPPER",
        "SAME_LOWER"
      ][typeof attributes.autoPad == "undefined" ? 0 : attributes.autoPad];
      const dilations = attributes.dilations;
      const group = attributes.group;
      const kernelShape = attributes.kernelShape;
      const pads = attributes.pads;
      const strides = attributes.strides;
      const wIsConst = attributes.wIsConst();
      const outputPadding = attributes.outputPadding;
      const outputShape = attributes.outputShape;
      return {
        autoPad,
        format,
        dilations,
        group,
        kernelShape,
        outputPadding,
        outputShape,
        pads,
        strides,
        wIsConst,
        ...activationAttributes,
        cacheKey: `${attributes.format};${activationAttributes.activation};`
      };
    };
    validateInputs10 = (inputs, attributes) => {
      if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
        throw new Error("Conv requires 2 or 3 inputs");
      }
      if (inputs[0].dims.length !== 4 && inputs[0].dims.length !== 3) {
        throw new Error("currently only support 2-dimensional conv");
      }
      if (inputs[0].dims.length !== inputs[1].dims.length) {
        throw new Error("filter does not have same dimension as input");
      }
      const dataChannel = inputs[0].dims[attributes.format === "NHWC" ? inputs[0].dims.length - 1 : 1];
      const filterInChannel = inputs[1].dims[0];
      if (dataChannel !== filterInChannel) {
        throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
      }
      const featureMaps = inputs[1].dims[1] * attributes.group;
      if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[2].dims[0] !== featureMaps)) {
        throw new Error("invalid bias");
      }
      const spatialRank = inputs[0].dims.length - 2;
      const dilationsSet = attributes.dilations.reduce((a, b) => a + b, 0) > 0;
      if (dilationsSet && attributes.dilations.length !== spatialRank) {
        throw new Error(`dilations should be ${spatialRank}D`);
      }
      const stridesSet = attributes.strides.reduce((a, b) => a + b, 0) > 0;
      if (stridesSet && attributes.strides.length !== spatialRank) {
        throw new Error(`strides should be ${spatialRank}D`);
      }
      const padsSet = attributes.pads.reduce((a, b) => a + b, 0) > 0;
      if (padsSet && attributes.pads.length !== spatialRank * 2) {
        throw new Error(`pads should be ${spatialRank * 2}D`);
      }
      if (attributes.outputPadding.length !== spatialRank && attributes.outputPadding.length !== 0) {
        throw new Error(`output_padding should be ${spatialRank}D`);
      }
      const kernelShapeSet = attributes.kernelShape.reduce((a, b) => a + b, 0) > 0;
      if (kernelShapeSet && attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {
        throw new Error("invalid kernel shape");
      }
      if (attributes.outputShape.length !== 0 && attributes.outputShape.length !== inputs[0].dims.length - 2) {
        throw new Error("invalid output shape");
      }
    };
    weightTransposePerm = [2, 3, 1, 0];
    convTranspose2d = (context, inputs, attributes) => {
      const adjustedAttributes = getAdjustedConvTransposeAttributes(attributes, inputs);
      const isChannelsLast = attributes.format === "NHWC";
      const outputShape = adjustedAttributes.outputShape;
      const outChannels = outputShape[isChannelsLast ? 3 : 1];
      const inputChannels = inputs[0].dims[isChannelsLast ? 3 : 1];
      if (adjustedAttributes.group !== 1 || outChannels === 1 && inputChannels === 1) {
        context.compute(createConvTranspose2DProgramInfo(inputs, adjustedAttributes));
        return;
      }
      const outHeight = outputShape[isChannelsLast ? 1 : 2];
      const outWidth = outputShape[isChannelsLast ? 2 : 3];
      const weightHeight = inputs[1].dims[2];
      const weightWidth = inputs[1].dims[3];
      const dimAOuter = isChannelsLast ? outHeight * outWidth : outChannels;
      const dimBOuter = isChannelsLast ? outChannels : outHeight * outWidth;
      const dimInner = weightHeight * weightWidth * inputChannels;
      const sequentialAccessByThreads = (
        /* backend.adapterInfo.isIntel() */
        true
      );
      const transposedWeight = context.kernelCustomData.wT ?? context.compute(
        createTransposeProgramInfo(inputs[1], weightTransposePerm),
        { inputs: [1], outputs: [attributes.wIsConst ? -2 : -1] }
      )[0];
      if (attributes.wIsConst && !context.kernelCustomData.wT) {
        context.kernelCustomData.wT = transposedWeight;
      }
      const convTransposeInputs = [inputs[0], transposedWeight];
      const hasBias = inputs.length === 3;
      if (hasBias) {
        if (!isChannelsLast && inputs[2].dims.length === 1) {
          convTransposeInputs.push(inputs[2].reshape([inputs[2].dims[0], 1, 1]));
        } else {
          convTransposeInputs.push(inputs[2]);
        }
      }
      context.compute(
        createConv2DTransposeMatMulProgramInfo(
          convTransposeInputs,
          adjustedAttributes,
          outputShape,
          dimAOuter,
          dimBOuter,
          dimInner,
          hasBias,
          sequentialAccessByThreads
        ),
        { inputs: convTransposeInputs }
      );
    };
    convTranspose1d = (context, attributes) => {
      const isChannelLast = attributes.format === "NHWC";
      const inputs = [
        context.inputs[0].reshape(
          isChannelLast ? (
            // [N, W, C] -> [N, H=1, W, C]
            [context.inputs[0].dims[0], 1, context.inputs[0].dims[1], context.inputs[0].dims[2]]
          ) : (
            // [N, C, W] -> [N, C, H=1, W]
            [context.inputs[0].dims[0], context.inputs[0].dims[1], 1, context.inputs[0].dims[2]]
          )
        ),
        //[FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kW] -> [FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kH=1, kW]
        context.inputs[1].reshape([context.inputs[1].dims[0], context.inputs[1].dims[1], 1, context.inputs[1].dims[2]])
      ];
      if (context.inputs.length === 3) {
        inputs.push(context.inputs[2]);
      }
      let kernelShape = attributes.kernelShape;
      if (kernelShape.length === 0 || kernelShape[0] === 0) {
        kernelShape = [context.inputs[1].dims[2]];
      }
      let dilations = attributes.dilations;
      if (dilations.length === 0 || dilations[0] === 0) {
        dilations = [1];
      }
      let strides = attributes.strides;
      if (strides.length === 0 || strides[0] === 0) {
        strides = [1];
      }
      let pads = attributes.pads;
      if (pads.length === 0) {
        pads = [0, 0];
      }
      pads = [0, pads[0], 0, pads[1]];
      strides = [1].concat(strides);
      dilations = [1].concat(dilations);
      kernelShape = [1].concat(kernelShape);
      const adjustedAttributes = getAdjustedConvTransposeAttributes({ ...attributes, pads, strides, dilations, kernelShape }, inputs);
      context.compute(createConvTranspose2DProgramInfo(
        inputs,
        adjustedAttributes,
        (outputShape) => isChannelLast ? [outputShape[0], outputShape[2], outputShape[3]] : [outputShape[0], outputShape[1], outputShape[3]]
      ));
    };
    convTranspose = (context, attributes) => {
      validateInputs10(context.inputs, attributes);
      if (context.inputs[0].dims.length === 3) {
        convTranspose1d(context, attributes);
      } else {
        convTranspose2d(context, context.inputs, attributes);
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/cumsum.ts
var createCumsumProgramInfo, cumsum, parseCumSumAttributes;
var init_cumsum = __esm({
  "web/lib/wasm/jsep/webgpu/ops/cumsum.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    createCumsumProgramInfo = (inputType, inputShape, axisInput, attributes) => {
      const outputSize = ShapeUtil.size(inputShape);
      const rank = inputShape.length;
      const input = inputVariable("input", inputType, rank);
      const output = outputVariable("output", inputType, rank);
      const axisValue = axisInput.dataType === 6 /* int32 */ ? axisInput.getInt32Array()[0] : Number(axisInput.getBigInt64Array()[0]);
      const axis = ShapeUtil.normalizeAxis(axisValue, rank);
      const getShaderSource = (shaderHelper) => {
        const index = ` i32(${input.indicesGet("inputIndices", "uniforms.axis")}) `;
        const max = getElementAt("uniforms.input_shape", "uniforms.axis", rank);
        const lowerLimit = attributes.reverse ? index + (attributes.exclusive ? " + 1" : "") : "0";
        const upperLimit = attributes.reverse ? max : index + (attributes.exclusive ? "" : " + 1");
        return `
                ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axis", "u32").declareVariables(input, output)}
                ${shaderHelper.mainStart()}
                  ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${output.offsetToIndices("global_idx")};
                  var sum = ${output.type.value}(0);
                  let first : i32 = ${lowerLimit};
                  let last : i32 = ${upperLimit};
                  for (var i : i32 = first; i < last; i++) {
                    ${input.indicesSet("inputIndices", "uniforms.axis", "u32(i)")};
                    sum = sum + ${input.getByIndices("inputIndices")};
                  }
                  ${output.setByOffset("global_idx", "sum")};
                }`;
      };
      return {
        name: "CumSum",
        shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank"] },
        getRunData: () => ({
          outputs: [{ dims: inputShape, dataType: inputType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms: [
            { type: 12 /* uint32 */, data: outputSize },
            { type: 12 /* uint32 */, data: axis },
            ...createTensorShapeVariables(inputShape, inputShape)
          ]
        }),
        getShaderSource
      };
    };
    cumsum = (context, attributes) => {
      const inputShape = context.inputs[0].dims;
      const inputType = context.inputs[0].dataType;
      const axis = context.inputs[1];
      context.compute(createCumsumProgramInfo(inputType, inputShape, axis, attributes), { inputs: [0] });
    };
    parseCumSumAttributes = (attributes) => {
      const exclusive = attributes.exclusive === 1;
      const reverse = attributes.reverse === 1;
      return createAttributeWithCacheKey({ exclusive, reverse });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/depth-to-space.ts
var validateInputs11, permFunctionBody2, createDepthToSpaceProgramInfo, depthToSpace, parseDepthToSpaceAttributes;
var init_depth_to_space = __esm({
  "web/lib/wasm/jsep/webgpu/ops/depth-to-space.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs11 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("DepthToSpace requires 1 input.");
      }
      if (inputs[0].dims.length !== 4) {
        throw new Error("DepthToSpace requires 4D input.");
      }
    };
    permFunctionBody2 = (perm, rank, input, output) => {
      const reverseFunc = [];
      reverseFunc.push(`fn perm(i: ${output.type.indices}) -> ${input.type.indices} {
    var a: ${input.type.indices};`);
      for (let i = 0; i < rank; ++i) {
        reverseFunc.push(input.indicesSet("a", perm[i], `i[${i}]`));
      }
      reverseFunc.push("return a;}");
      return reverseFunc.join("\n");
    };
    createDepthToSpaceProgramInfo = (inputTensor, attributes) => {
      let n, h, w, c;
      let shape;
      let perm;
      const isChannelLast = attributes.format === "NHWC";
      const blocksize = attributes.blocksize;
      const isDCRmode = attributes.mode === "DCR";
      if (isChannelLast) {
        [n, h, w, c] = inputTensor.dims;
        shape = isDCRmode ? [n, h, w, blocksize, blocksize, c / blocksize ** 2] : [n, h, w, c / blocksize ** 2, blocksize, blocksize];
        perm = isDCRmode ? [0, 1, 3, 2, 4, 5] : [0, 1, 4, 2, 5, 3];
      } else {
        [n, h, w, c] = [inputTensor.dims[0], inputTensor.dims[2], inputTensor.dims[3], inputTensor.dims[1]];
        shape = isDCRmode ? [n, blocksize, blocksize, c / blocksize ** 2, h, w] : [n, c / blocksize ** 2, blocksize, blocksize, h, w];
        perm = isDCRmode ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3];
      }
      const reshapedInputTensor = inputTensor.reshape(shape);
      const reshapedInputRank = reshapedInputTensor.dims.length;
      const inputDataType = inputTensor.dataType;
      const reshapedInput = inputVariable("a", inputDataType, reshapedInputRank);
      const permedOutput = outputVariable("output", inputDataType, reshapedInputRank);
      const getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(reshapedInput, permedOutput)}

  ${permFunctionBody2(perm, reshapedInputRank, reshapedInput, permedOutput)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${permedOutput.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${permedOutput.setByOffset("global_idx", reshapedInput.getByIndices("aIndices"))}
  }`;
      return {
        name: "DepthToSpace",
        shaderCache: { hint: `${inputTensor.dims};${attributes.blocksize};${attributes.mode}`, inputDependencies: ["rank"] },
        getRunData: (inputs) => {
          const outputShape = isChannelLast ? [n, h * blocksize, w * blocksize, c / blocksize ** 2] : [n, c / blocksize ** 2, h * blocksize, w * blocksize];
          const outputSize = ShapeUtil.size(outputShape);
          const shapeBeforePerm = reshapedInputTensor.dims;
          const shapeAfterPerm = ShapeUtil.sortBasedOnPerm(shapeBeforePerm, perm);
          return {
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [{ type: 12 /* uint32 */, data: outputSize }, ...createTensorShapeVariables(shapeBeforePerm, shapeAfterPerm)]
          };
        },
        getShaderSource
      };
    };
    depthToSpace = (context, attributes) => {
      validateInputs11(context.inputs);
      context.compute(createDepthToSpaceProgramInfo(context.inputs[0], attributes));
    };
    parseDepthToSpaceAttributes = (attributes) => createAttributeWithCacheKey({
      blocksize: attributes.blocksize,
      mode: attributes.mode,
      format: attributes.format
    });
  }
});

// web/lib/wasm/jsep/webgpu/ops/einsum.ts
var symbolPattern, termPattern, termPatternOnly, lhsPattern, lhsPatternOnly, EinsumTerm, EinsumEquation, appendMax, createEinsumProgramInfo, einsum, parseEinsumAttributes;
var init_einsum = __esm({
  "web/lib/wasm/jsep/webgpu/ops/einsum.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    symbolPattern = "[a-zA-Z]|\\.\\.\\.";
    termPattern = "(" + symbolPattern + ")+";
    termPatternOnly = "^" + termPattern + "$";
    lhsPattern = "(" + termPattern + ",)*" + termPattern;
    lhsPatternOnly = "^" + lhsPattern + "$";
    EinsumTerm = class {
      constructor(inputIndex = -1) {
        this.symbolToIndices = /* @__PURE__ */ new Map();
        this.inputIndex = inputIndex;
      }
      // Add a symbol to the term
      addSymbol(symbol, index) {
        let value = this.symbolToIndices.get(symbol);
        if (value === void 0) {
          value = [index];
        } else {
          value.push(index);
        }
        this.symbolToIndices.set(symbol, value);
      }
      // -1 for output and 0, 1, 2, ... for inputs
    };
    EinsumEquation = class {
      constructor(inputs, equation) {
        this.equation = equation;
        this.hasEllipsis = false;
        this.symbolToInfo = /* @__PURE__ */ new Map();
        this.lhs = new Array();
        this.outputDims = [];
        let [lhs, rhs] = equation.includes("->") ? equation.split("->", 2) : [equation, ""];
        if (!lhs.match(RegExp(lhsPatternOnly))) {
          throw new Error("Invalid LHS term");
        }
        const inputTerms = lhs.split(",");
        inputTerms.forEach((inputTerm, index) => {
          const dims = inputs[index].dims.slice();
          if (!inputTerm.match(RegExp(termPatternOnly))) {
            throw new Error("Invalid LHS term");
          }
          const einsumTerm = this.processTerm(inputTerm, true, dims, index);
          this.lhs.push(einsumTerm);
        });
        if (rhs === "") {
          rhs += [...this.symbolToInfo.entries()].filter(([sym, info]) => info.count === 1 || sym === "...").map(([sym]) => sym).join("");
        } else {
          if (!rhs.match(RegExp(termPattern))) {
            throw new Error("Invalid RHS");
          }
        }
        const rhsSymbols = rhs.match(RegExp(symbolPattern, "g"));
        rhsSymbols?.forEach((symbol) => {
          if (symbol === "...") {
            this.outputDims = this.outputDims.concat(this.ellipsisDims);
          } else {
            const info = this.symbolToInfo.get(symbol);
            if (info === void 0) {
              throw new Error("Invalid RHS symbol");
            }
            this.outputDims.push(info.dimValue);
          }
        });
        this.rhs = this.processTerm(rhs, false, this.outputDims);
      }
      // End of EinsumEqation constructor
      // Add a symbol to the equation
      addSymbol(symbol, dimValue, inputIndex) {
        let info = this.symbolToInfo.get(symbol);
        if (info !== void 0) {
          if (info.dimValue !== dimValue && info.count !== 1) {
            throw new Error("Dimension mismatch");
          } else {
            info.count++;
            info.inputIndices.push(inputIndex);
          }
        } else {
          info = { count: 1, dimValue, inputIndices: [inputIndex] };
        }
        this.symbolToInfo.set(symbol, info);
      }
      // Process one input/output term
      processTerm(term, isInput, dims, index = -1) {
        const rank = dims.length;
        let ellipsis = false;
        let ellipsisDims = [];
        let nextDim = 0;
        if (!term.match(RegExp(termPatternOnly)) && (!isInput && term !== "")) {
          throw new Error("Invalid LHS term");
        }
        const indexSymbols = term.match(RegExp(symbolPattern, "g"));
        const einsumTerm = new EinsumTerm(index);
        indexSymbols?.forEach((symbol, i) => {
          if (symbol === "...") {
            if (ellipsis) {
              throw new Error("Only one ellipsis is allowed per input term");
            }
            ellipsis = true;
            const ellipsisDimLength = rank - indexSymbols.length + 1;
            if (ellipsisDimLength < 0) {
              throw new Error("Ellipsis out of bounds");
            }
            ellipsisDims = dims.slice(nextDim, nextDim + ellipsisDimLength);
            if (this.hasEllipsis) {
              if (this.ellipsisDims.length !== ellipsisDims.length || this.ellipsisDims.toString() !== ellipsisDims.toString()) {
                throw new Error("Ellipsis dimensions mismatch");
              }
            } else if (isInput) {
              this.hasEllipsis = true;
              this.ellipsisDims = ellipsisDims;
            } else {
              throw new Error("Ellipsis must be specified in the LHS");
            }
            for (let j = 0; j < ellipsisDims.length; j++) {
              const symbol2 = String.fromCharCode("0".charCodeAt(0) + j);
              einsumTerm.addSymbol(symbol2, i + j);
              this.addSymbol(symbol2, dims[nextDim++], index);
            }
          } else {
            einsumTerm.addSymbol(symbol, i + (this.hasEllipsis ? this.ellipsisDims.length - 1 : 0));
            this.addSymbol(symbol, dims[nextDim++], index);
          }
        });
        return einsumTerm;
      }
      // Output dimensions of the equation
    };
    appendMax = (name) => name + "_max";
    createEinsumProgramInfo = (inputShapes, dataType, einsumEquation, outputShape) => {
      const ranks = inputShapes.map((dims) => dims.length);
      const inputVars = ranks.map((rank, index) => inputVariable(`input${index}`, dataType, rank));
      const outputSize = ShapeUtil.size(outputShape);
      const output = outputVariable("output", dataType, outputShape.length);
      const uniformsSymbols = [...einsumEquation.symbolToInfo.keys()].filter((symbol) => !einsumEquation.rhs.symbolToIndices.has(symbol));
      const getShaderSource = (shaderHelper) => {
        const idxCopy = [];
        const initProd = "var prod = 1.0;";
        const initSum = "var sum = 0.0;";
        const updateSum = "sum += prod;";
        const reduceOpsSetIndices = [];
        const reduceOpsLoopHeaders = [];
        const reduceOpsLoopFooters = [];
        const reduceOpCompute = [];
        const isReduceOpsWithoutLoop = einsumEquation.symbolToInfo.size === einsumEquation.rhs.symbolToIndices.size;
        einsumEquation.symbolToInfo.forEach((info, symbol) => {
          if (einsumEquation.rhs.symbolToIndices.has(symbol)) {
            const outputIndex = einsumEquation.rhs.symbolToIndices.get(symbol)?.[0];
            if (outputIndex !== void 0) {
              einsumEquation.lhs.forEach((term, i) => {
                if (info.inputIndices.includes(i)) {
                  const indices = term.symbolToIndices.get(symbol);
                  if (indices === void 0) {
                    throw new Error("Invalid symbol error");
                  }
                  indices.forEach((index) => {
                    idxCopy.push(`${inputVars[i].indicesSet(
                      `input${i}Indices`,
                      index,
                      output.indicesGet("outputIndices", outputIndex)
                    )}`);
                  });
                }
              });
            }
          } else {
            einsumEquation.lhs.forEach((term, i) => {
              if (info.inputIndices.includes(i)) {
                const indices = term.symbolToIndices.get(symbol);
                if (indices === void 0) {
                  throw new Error("Invalid symbol error");
                }
                indices.forEach((index) => {
                  reduceOpsSetIndices.push(`${inputVars[i].indicesSet(`input${i}Indices`, index, `${symbol}`)}`);
                });
                reduceOpCompute.push(`prod *= ${inputVars[i].getByIndices(`input${i}Indices`)};`);
              }
            });
            reduceOpsLoopHeaders.push(
              `for(var ${symbol}: u32 = 0; ${symbol} < uniforms.${appendMax(symbol)}; ${symbol}++) {`
            );
            reduceOpsLoopFooters.push("}");
          }
        });
        const reduceOps2 = isReduceOpsWithoutLoop ? [
          ...idxCopy,
          `let sum = ${inputVars.map((inputVar, i) => inputVar.getByIndices(`input${i}Indices`)).join(" * ")};`
        ] : [
          ...idxCopy,
          initSum,
          ...reduceOpsLoopHeaders,
          ...reduceOpsSetIndices,
          initProd,
          ...reduceOpCompute,
          updateSum,
          ...reduceOpsLoopFooters
        ];
        return `
            ${shaderHelper.registerUniforms(uniformsSymbols.map((symbol) => ({ name: `${appendMax(symbol)}`, type: "u32" }))).registerUniform("outputSize", "u32").declareVariables(...inputVars, output)}

            ${shaderHelper.mainStart()}
            ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${output.offsetToIndices("global_idx")};
            ${inputVars.map((_var, i) => `var input${i}Indices: ${inputVars[i].type.indices};`).join("\n")}
            ${reduceOps2.join("\n")};
            ${output.setByOffset("global_idx", "sum")};
          }`;
      };
      return {
        name: "Einsum",
        shaderCache: { hint: einsumEquation.equation, inputDependencies: inputShapes.map(() => "rank") },
        getRunData: () => {
          const programUniformsInit = uniformsSymbols.filter((symbol) => einsumEquation.symbolToInfo.has(symbol)).map(
            (symbol) => ({ type: 12 /* uint32 */, data: einsumEquation.symbolToInfo.get(symbol)?.dimValue || 0 })
          );
          programUniformsInit.push({ type: 12 /* uint32 */, data: outputSize });
          const programUniforms = inputShapes.map((dims, _) => [...createTensorShapeVariables(dims)]).reduce((acc, inputProgramUniforms) => acc.concat(inputProgramUniforms), programUniformsInit);
          programUniforms.push(...createTensorShapeVariables(outputShape));
          return {
            outputs: [{ dims: outputShape, dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          };
        },
        getShaderSource
      };
    };
    einsum = (context, attributes) => {
      const einsumEquation = new EinsumEquation(context.inputs, attributes.equation);
      const outputShape = einsumEquation.outputDims;
      const inputShapes = context.inputs.map((input, _) => input.dims);
      context.compute(createEinsumProgramInfo(inputShapes, context.inputs[0].dataType, einsumEquation, outputShape));
    };
    parseEinsumAttributes = (attributes) => {
      const equation = attributes.equation.replace(/\s+/g, "");
      return createAttributeWithCacheKey({ equation });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/expand.ts
var validateInputs12, getAdjustedShape, calculateOutputShape2, createExpandProgramInfo, expand;
var init_expand = __esm({
  "web/lib/wasm/jsep/webgpu/ops/expand.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    validateInputs12 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("Expand requires 2 input.");
      }
      const inputShape = inputs[0].dims;
      const shape = Array.from(inputs[1].getBigInt64Array(), Number);
      let shapeIndex = shape.length < inputShape.length ? 0 : shape.length - inputShape.length;
      let inputShapeIndex = inputShape.length < shape.length ? 0 : inputShape.length - shape.length;
      for (; shapeIndex < shape.length && inputShapeIndex < inputShape.length; ++shapeIndex, ++inputShapeIndex) {
        if (shape[shapeIndex] !== inputShape[inputShapeIndex] && shape[shapeIndex] !== 1 && inputShape[inputShapeIndex] !== 1) {
          throw new Error("Expand requires shape to be broadcastable to input");
        }
      }
    };
    getAdjustedShape = (shape1, shape2) => {
      const diff = shape1.length - shape2.length;
      const shape = [];
      for (let i = 0; i < diff; ++i) {
        shape.push(shape1[i]);
      }
      for (let i = 0; i < shape2.length; ++i) {
        shape.push(shape2[i] === 1 ? shape1[i + diff] : shape2[i]);
      }
      return shape;
    };
    calculateOutputShape2 = (inputShape, shape) => inputShape.length > shape.length ? getAdjustedShape(inputShape, shape) : getAdjustedShape(shape, inputShape);
    createExpandProgramInfo = (inputs) => {
      const inputShape = inputs[0].dims;
      const shape = Array.from(inputs[1].getBigInt64Array(), Number);
      const outputShape = calculateOutputShape2(inputShape, shape);
      const dataType = inputs[0].dataType;
      const components = dataType === 9 /* bool */ ? 4 : 1;
      const outputSize = Math.ceil(ShapeUtil.size(outputShape) / components);
      const getShaderSource = (shaderHelper) => {
        const input = inputVariable("input", dataType, inputShape.length, components);
        const output = outputVariable("output", dataType, outputShape.length, components);
        let assignment;
        if (dataType === 9 /* bool */) {
          const singleAssignment = (resStr, x, typeCast = "") => `
          let outputIndices${x} = ${output.offsetToIndices(`outputOffset + ${x}u`)};
          let offset${x} = ${input.broadcastedIndicesToOffset(`outputIndices${x}`, output)};
          let index${x} = offset${x} / 4u;
          let component${x} = offset${x} % 4u;
          ${resStr}[${x}] = ${typeCast}(${input.getByOffset(`index${x}`)}[component${x}]);
        `;
          assignment = `
        let outputOffset = global_idx * ${components};
        var data = vec4<u32>(0);
        ${singleAssignment("data", 0, "u32")}
        ${singleAssignment("data", 1, "u32")}
        ${singleAssignment("data", 2, "u32")}
        ${singleAssignment("data", 3, "u32")}
        ${output.setByOffset("global_idx", "data")}
      }`;
        } else {
          assignment = `
        let outputIndices = ${output.offsetToIndices("global_idx")};
        let inputOffset = ${input.broadcastedIndicesToOffset("outputIndices", output)};
        ${output.setByOffset("global_idx", input.getByOffset("inputOffset"))}
      }`;
        }
        return `
    ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(input, output)}
    ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${assignment}`;
      };
      const programUniforms = [{ type: 12 /* uint32 */, data: outputSize }, ...createTensorShapeVariables(inputShape, outputShape)];
      return {
        name: "Expand",
        shaderCache: { hint: `${outputShape.length}`, inputDependencies: ["rank"] },
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        })
      };
    };
    expand = (context) => {
      validateInputs12(context.inputs);
      context.compute(createExpandProgramInfo(context.inputs), { inputs: [0] });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/fast-gelu.ts
var createFastGeluProgramInfo, fastGelu2;
var init_fast_gelu = __esm({
  "web/lib/wasm/jsep/webgpu/ops/fast-gelu.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    init_unary_op();
    createFastGeluProgramInfo = (inputTensors) => {
      const dataType = inputTensors[0].dataType;
      const outputSize = ShapeUtil.size(inputTensors[0].dims);
      const biasLength = ShapeUtil.size(inputTensors[1].dims);
      const useVec4 = biasLength % 4 === 0;
      const getShaderSource = (shaderHelper) => {
        const x = inputVariable("x", dataType, [1], 4);
        const bias = inputVariable("bias", dataType, [1], 4);
        const y = outputVariable("y", dataType, [1], 4);
        const uniforms = [{ name: "output_vec_size", type: "u32" }, { name: "bias_size", type: "u32" }];
        const singleElementBias = (i) => `
      let bias${i}_offset: u32 = (global_idx * 4 + ${i}) % uniforms.bias_size;
      let bias${i} = ${bias.getByOffset(`bias${i}_offset / 4`)}[bias${i}_offset % 4];`;
        const biasGetExpression = useVec4 ? `
      let bias = ${bias.getByOffset("global_idx % (uniforms.bias_size / 4)")};` : `${singleElementBias(0)}${singleElementBias(1)}${singleElementBias(2)}${singleElementBias(3)}
      let bias = ${x.type.value}(bias0, bias1, bias2, bias3);`;
        return `${shaderHelper.registerUniforms(uniforms).declareVariables(x, bias, y)}

    ${fastGeluImpl(tensorTypeToWsglValueType(dataType))}

    ${shaderHelper.mainStart(WORKGROUP_SIZE)}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${x.getByOffset("global_idx")};
      ${biasGetExpression}
      let x_in = x + bias;
      ${y.setByOffset("global_idx", fastGeluExpression("x_in"))}
    }`;
      };
      return {
        name: "FastGeluWithBias",
        shaderCache: { hint: `${useVec4}`, inputDependencies: ["type", "type"] },
        getShaderSource,
        getRunData: (inputs) => ({
          outputs: [{ dims: inputs[0].dims, dataType: inputs[0].dataType }],
          programUniforms: [{ type: 12 /* uint32 */, data: Math.ceil(outputSize / 4) }, { type: 12 /* uint32 */, data: biasLength }],
          dispatchGroup: { x: Math.ceil(outputSize / WORKGROUP_SIZE / 4) }
        })
      };
    };
    fastGelu2 = (context) => {
      if (context.inputs.length < 2 || ShapeUtil.size(context.inputs[1].dims) === 0) {
        fastGelu(context);
      } else {
        context.compute(createFastGeluProgramInfo(context.inputs));
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/gather.ts
var validateInputs13, createGatherProgramInfo, parseGatherAttributes, gather;
var init_gather = __esm({
  "web/lib/wasm/jsep/webgpu/ops/gather.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs13 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("Gather requires 2 inputs.");
      }
    };
    createGatherProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const indicesShape = inputs[1].dims;
      const inputRank = inputShape.length;
      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputRank);
      const outputShape = inputShape.slice(0);
      outputShape.splice(axis, 1, ...indicesShape);
      const axisDimLimit = inputShape[axis];
      const components = inputs[0].dataType === 9 /* bool */ ? 4 : 1;
      const outputSize = Math.ceil(ShapeUtil.size(outputShape) / components);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 6 /* int32 */, data: axisDimLimit },
        { type: 12 /* uint32 */, data: axis },
        ...createTensorShapeVariables(inputs[0].dims, inputs[1].dims, outputShape)
      ];
      const getShaderSource = (shaderHelper) => {
        const data = inputVariable("data", inputs[0].dataType, inputs[0].dims.length, components);
        const indices = inputVariable("inputIndices", inputs[1].dataType, inputs[1].dims.length);
        const output = outputVariable("output", inputs[0].dataType, outputShape.length, components);
        const calcDataIndices = (x) => {
          const indicesRank = indicesShape.length;
          let calcStr = `var indicesIndices${x}  = ${indices.type.indices}(0);`;
          for (let i = 0; i < indicesRank; i++) {
            calcStr += `${indicesRank > 1 ? `indicesIndices${x}[${i}]` : `indicesIndices${x}`} = ${outputShape.length > 1 ? `outputIndices${x}[uniforms.axis + ${i}]` : `outputIndices${x}`};`;
          }
          calcStr += `
          var idx${x} = ${indices.getByIndices(`indicesIndices${x}`)};
          if (idx${x} < 0) {
            idx${x} = idx${x} + uniforms.axisDimLimit;
          }
          var dataIndices${x} : ${data.type.indices};
        `;
          for (let i = 0, j = 0; i < inputRank; i++) {
            if (i === axis) {
              calcStr += `${inputRank > 1 ? `dataIndices${x}[${i}]` : `dataIndices${x}`} = u32(idx${x});`;
              j += indicesRank;
            } else {
              calcStr += `${inputRank > 1 ? `dataIndices${x}[${i}]` : `dataIndices${x}`} = ${outputShape.length > 1 ? `outputIndices${x}[${j}]` : `outputIndices${x}`};`;
              j++;
            }
          }
          return calcStr;
        };
        let assignment;
        if (inputs[0].dataType === 9 /* bool */) {
          const singleAssignment = (resStr, x, typeCast = "") => `
          let outputIndices${x} = ${output.offsetToIndices(`outputOffset + ${x}u`)};
          ${calcDataIndices(x)};
          let offset${x} = ${data.indicesToOffset(`dataIndices${x}`)};
          let index${x} = offset${x} / 4u;
          let component${x} = offset${x} % 4u;
          ${resStr}[${x}] = ${typeCast}(${data.getByOffset(`index${x}`)}[component${x}]);
        `;
          assignment = `
        let outputOffset = global_idx * ${components};
        var value = vec4<u32>(0);
        ${singleAssignment("value", 0, "u32")}
        ${singleAssignment("value", 1, "u32")}
        ${singleAssignment("value", 2, "u32")}
        ${singleAssignment("value", 3, "u32")}
        ${output.setByOffset("global_idx", "value")}
      `;
        } else {
          assignment = `
      let outputIndices = ${output.offsetToIndices("global_idx")};
      ${calcDataIndices("")};
      let value = ${data.getByIndices("dataIndices")};
      ${output.setByOffset("global_idx", "value")};
      `;
        }
        return `
      ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axisDimLimit", "i32").registerUniform("axis", "u32").declareVariables(data, indices, output)}
      ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${assignment}
      }`;
      };
      return {
        name: "Gather",
        shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank", "rank"] },
        getRunData: () => ({
          outputs: [
            { dims: outputShape, dataType: inputs[0].dataType }
          ],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    parseGatherAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
    gather = (context, attributes) => {
      const inputs = context.inputs;
      validateInputs13(inputs);
      context.compute(createGatherProgramInfo(context.inputs, attributes));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/gather-elements.ts
var validateInputs14, createGatherElementsProgramInfo, parseGatherElementsAttributes, gatherElements;
var init_gather_elements = __esm({
  "web/lib/wasm/jsep/webgpu/ops/gather-elements.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs14 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("GatherElements requires 2 inputs.");
      }
      if (inputs[0].dims.length < 1) {
        throw new Error("GatherElements requires that the data input be rank >= 1.");
      }
      if (inputs[0].dims.length !== inputs[1].dims.length) {
        throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`);
      }
    };
    createGatherElementsProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const inputOutputDataType = inputs[0].dataType;
      const inputRank = inputShape.length;
      const indicesShape = inputs[1].dims;
      const indicesDataType = inputs[1].dataType;
      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputRank);
      const axisDimLimit = inputShape[axis];
      const outputShape = indicesShape.slice(0);
      const outputSize = ShapeUtil.size(outputShape);
      const input = inputVariable("input", inputOutputDataType, inputRank);
      const indices = inputVariable("indicesInput", indicesDataType, indicesShape.length);
      const output = outputVariable("output", inputOutputDataType, outputShape.length);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 6 /* int32 */, data: axisDimLimit },
        { type: 12 /* uint32 */, data: axis }
      ];
      programUniforms.push(...createTensorShapeVariables(inputShape, indicesShape, outputShape));
      const inputDependencies = ["rank", "rank"];
      const getShaderSource = (shaderHelper) => `
      ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axisDimLimit", "i32").registerUniform("axis", "u32").declareVariables(input, indices, output)}
      ${shaderHelper.mainStart()}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${output.offsetToIndices("global_idx")};

      var idx = ${indices.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${input.type.indices}(outputIndices);
      ${input.indicesSet("inputIndices", "uniforms.axis", "u32(idx)")};
      let value = ${input.getByIndices("inputIndices")};

      ${output.setByOffset("global_idx", "value")};
  }`;
      return {
        name: "GatherElements",
        shaderCache: { inputDependencies },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    parseGatherElementsAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
    gatherElements = (context, attributes) => {
      const inputs = context.inputs;
      validateInputs14(inputs);
      context.compute(createGatherElementsProgramInfo(context.inputs, attributes));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/gemm.ts
var validateInputs15, createGemmProgramInfo, parseGemmAttributes, gemm;
var init_gemm = __esm({
  "web/lib/wasm/jsep/webgpu/ops/gemm.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    validateInputs15 = (inputs) => {
      if (!inputs) {
        throw new Error("Input is missing");
      }
      if (inputs.length < 2 || inputs.length > 3) {
        throw new Error("Invaid input number.");
      }
      if (inputs.length === 3 && inputs[2].dims.length > 2) {
        throw new Error("Invalid input shape of C");
      }
      if (inputs[0].dataType !== inputs[1].dataType || inputs.length === 3 && inputs[0].dataType !== inputs[2].dataType) {
        throw new Error("Input types are mismatched");
      }
    };
    createGemmProgramInfo = (inputs, attributes) => {
      const aShape = inputs[0].dims.slice();
      const bShape = inputs[1].dims.slice();
      const [M, N, K] = GemmUtil.getShapeOfGemmResult(
        aShape,
        attributes.transA,
        bShape,
        attributes.transB,
        inputs.length === 3 ? inputs[2].dims : void 0
      );
      const outputShape = [M, N];
      if (!outputShape) {
        throw new Error("Can't use gemm on the given tensors");
      }
      const outputSize = ShapeUtil.size(outputShape);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: M },
        { type: 12 /* uint32 */, data: N },
        { type: 12 /* uint32 */, data: K },
        { type: 1 /* float */, data: attributes.alpha },
        { type: 1 /* float */, data: attributes.beta }
      ];
      const inputDependencies = ["type", "type"];
      if (inputs.length === 3) {
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        inputDependencies.push("rank");
      }
      programUniforms.push(...createTensorShapeVariables(outputShape));
      const getShaderSource = (shaderHelper) => {
        let line = "";
        if (attributes.transA && attributes.transB) {
          line = "value += a[k * uniforms.M + m] * b[n * uniforms.K + k];";
        } else if (attributes.transA && !attributes.transB) {
          line = "value += a[k * uniforms.M + m] * b[k * uniforms.N + n];";
        } else if (!attributes.transA && attributes.transB) {
          line = "value += a[m * uniforms.K + k] * b[n * uniforms.K + k];";
        } else if (!attributes.transA && !attributes.transB) {
          line = "value += a[m * uniforms.K + k] * b[k * uniforms.N + n];";
        }
        const calculateAlpha = attributes.alpha === 1 ? "" : "value *= uniforms.alpha;";
        const a = inputVariable("a", inputs[0].dataType, inputs[0].dims);
        const b = inputVariable("b", inputs[1].dataType, inputs[1].dims);
        const dataType = a.type.value;
        let c = null;
        const variables = [a, b];
        if (inputs.length === 3) {
          c = inputVariable("c", inputs[2].dataType, inputs[2].dims.length);
          variables.push(c);
        }
        const output = outputVariable("output", inputs[0].dataType, outputShape.length);
        variables.push(output);
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "M", type: "u32" },
          { name: "N", type: "u32" },
          { name: "K", type: "u32" },
          { name: "alpha", type: "f32" },
          { name: "beta", type: "f32" }
        ];
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${dataType}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${line}
    }

    ${calculateAlpha}
    ${(() => {
          if (c != null) {
            return `let cOffset = ${c.broadcastedIndicesToOffset("vec2(m, n)", output)}; value += ${dataType}(uniforms.beta) * ${c.getByOffset("cOffset")};`;
          }
          return "";
        })()}
    output[global_idx] = value;
  }`;
      };
      return {
        name: "Gemm",
        shaderCache: { hint: `${attributes.cacheKey}`, inputDependencies },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    parseGemmAttributes = (attributes) => {
      const transA = attributes.transA;
      const transB = attributes.transB;
      const alpha = attributes.alpha;
      const beta = attributes.beta;
      return { transA, transB, alpha, beta, cacheKey: `${attributes.transA};${attributes.transB};${attributes.alpha === 1}` };
    };
    gemm = (context, attributes) => {
      validateInputs15(context.inputs);
      context.compute(createGemmProgramInfo(context.inputs, attributes));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/multihead-attention.ts
var getInput, validateInputs16, parseMultiHeadAttentionAttributes, weightTransposeAttribute2, addBiasTranspose, maybeTransposeToBNSHAndAddBias, multiHeadAttention;
var init_multihead_attention = __esm({
  "web/lib/wasm/jsep/webgpu/ops/multihead-attention.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_types();
    init_attention();
    init_common();
    init_transpose();
    getInput = (inputs, i) => inputs.length > i && inputs[i].dims.length > 0 && ShapeUtil.size(inputs[i].dims) > 0 ? inputs[i] : void 0;
    validateInputs16 = (inputs, attributes) => {
      const query = inputs[0];
      const key = getInput(inputs, 1);
      const value = getInput(inputs, 2);
      const bias = getInput(inputs, 3);
      const keyPaddingMask = getInput(inputs, 4);
      const relativePositionBias = getInput(inputs, 5);
      const pastKey = getInput(inputs, 6);
      const pastValue = getInput(inputs, 7);
      if (query.dims.length !== 3 && query.dims.length !== 5) {
        throw new Error("Input query is expected to have 3 or 5 dimensions");
      }
      const dmmhaPacking = false;
      const batchSize = query.dims[0];
      const sequenceLength = query.dims[1];
      const hiddenSize = query.dims.length === 3 ? dmmhaPacking ? query.dims[2] / 3 : query.dims[2] : attributes.numHeads * query.dims[4];
      let kvSequenceLength = sequenceLength;
      let pastSequenceLength = 0;
      let maxSequenceLength = 0;
      const headSize = Math.floor(hiddenSize / attributes.numHeads);
      if (pastKey && pastValue) {
        if (pastKey.dims.length !== 4) {
          throw new Error('Input "past_key" is expected to have 4 dimensions');
        }
        if (pastKey.dims[0] !== batchSize || pastKey.dims[1] !== attributes.numHeads || pastKey.dims[3] !== headSize) {
          throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');
        }
        if (pastValue.dims[0] !== batchSize || pastValue.dims[1] !== attributes.numHeads || pastValue.dims[3] !== headSize) {
          throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');
        }
        if (pastKey.dims[2] !== pastValue.dims[2]) {
          throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');
        }
        if (pastValue.dims.length !== 4) {
          throw new Error('Input "past_value" is expected to have 4 dimensions');
        }
        pastSequenceLength = pastKey.dims[2];
        maxSequenceLength = pastKey.dims[2];
      } else if (pastKey || pastValue) {
        throw new Error('Input "past_key" and "past_value" shall be both present or both absent');
      }
      let qkvFormat;
      if (key) {
        if (query.dims.length !== 3) {
          throw new Error('Input "query" is expected to have 3 dimensions when key is given');
        }
        if (key.dims.length < 3 || key.dims.length > 5) {
          throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');
        }
        if (query.dims[0] !== key.dims[0]) {
          throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');
        }
        if (key.dims.length === 3) {
          if (key.dims[2] !== query.dims[2]) {
            throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');
          }
          qkvFormat = 2 /* qkvBSNH */;
          kvSequenceLength = key.dims[1];
        } else if (key.dims.length === 5) {
          if (key.dims[2] !== attributes.numHeads || key.dims[3] !== 2 || key.dims[4] !== headSize) {
            throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');
          }
          if (value) {
            throw new Error('Expect "value" be none when "key" has packed kv format.');
          }
          qkvFormat = 5 /* qKvBSNHxBSN2H */;
          kvSequenceLength = key.dims[1];
        } else {
          if (key.dims[1] !== attributes.numHeads || key.dims[3] !== headSize) {
            throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');
          }
          qkvFormat = 0 /* unknown */;
          kvSequenceLength = key.dims[2];
        }
      } else {
        if (query.dims.length !== 3 && query.dims.length !== 5) {
          throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');
        }
        if (query.dims.length === 5 && (query.dims[2] !== attributes.numHeads || query.dims[3] !== 3)) {
          throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');
        }
        qkvFormat = 3 /* qkvBSN3H */;
      }
      if (bias) {
        if (bias.dims.length !== 1) {
          throw new Error('Input "bias" is expected to have 1 dimension');
        }
        if (value) {
          if (query.dims.length === 5 && query.dims[3] === 2) {
            throw new Error("bias is not allowed for packed kv.");
          }
        }
      }
      let maskType = 0 /* none */;
      if (keyPaddingMask) {
        maskType = 8 /* maskUnknown */;
        const maskDims = keyPaddingMask.dims;
        if (maskDims.length === 1) {
          if (maskDims[0] === batchSize) {
            maskType = 1 /* mask1dKeySeqLen */;
          } else if (maskDims[0] === 3 * batchSize + 2) {
            maskType = 3 /* mask1DKeySeqLenStart */;
          }
        } else if (maskDims.length === 2 && maskDims[0] === batchSize && maskDims[1] === kvSequenceLength) {
          maskType = 5 /* mask2dKeyPadding */;
        }
        if (maskType === 8 /* maskUnknown */) {
          throw new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, kv_sequence_length)');
        }
        throw new Error("Mask not supported");
      }
      let passPastInKv = false;
      let vHiddenSize = hiddenSize;
      if (value) {
        if (value.dims.length !== 3 && value.dims.length !== 4) {
          throw new Error('Input "value" is expected to have 3 or 4 dimensions');
        }
        if (query.dims[0] !== value.dims[0]) {
          throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');
        }
        if (value.dims.length === 3) {
          if (kvSequenceLength !== value.dims[1]) {
            throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');
          }
          vHiddenSize = value.dims[2];
        } else {
          if (kvSequenceLength !== value.dims[2]) {
            throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');
          }
          vHiddenSize = value.dims[1] * value.dims[3];
          passPastInKv = true;
        }
      }
      const totalSequenceLength = pastSequenceLength + kvSequenceLength;
      const broadcastResPosBias = false;
      if (keyPaddingMask) {
        throw new Error("Key padding mask is not supported");
      }
      if (relativePositionBias) {
        if (relativePositionBias.dims.length !== 4) {
          throw new Error('Input "relative_position_bias" is expected to have 4 dimensions');
        }
        if (relativePositionBias.dims[0] !== batchSize && relativePositionBias.dims[0] !== 1 || relativePositionBias.dims[1] !== attributes.numHeads || relativePositionBias.dims[2] !== sequenceLength || relativePositionBias.dims[3] !== totalSequenceLength) {
          throw new Error('Input "relative_position_bias" shape (batch_size, 1, sequence_length, kv_sequence_length)');
        }
      }
      return {
        batchSize,
        sequenceLength,
        pastSequenceLength,
        kvSequenceLength,
        totalSequenceLength,
        maxSequenceLength,
        inputHiddenSize: 0,
        hiddenSize,
        vHiddenSize,
        headSize,
        vHeadSize: Math.floor(vHiddenSize / attributes.numHeads),
        numHeads: attributes.numHeads,
        isUnidirectional: false,
        pastPresentShareBuffer: false,
        maskFilterValue: attributes.maskFilterValue,
        maskType,
        scale: attributes.scale,
        broadcastResPosBias,
        passPastInKv,
        qkvFormat
      };
    };
    parseMultiHeadAttentionAttributes = (attributes) => createAttributeWithCacheKey({ ...attributes });
    weightTransposeAttribute2 = createAttributeWithCacheKey({ perm: [0, 2, 1, 3] });
    addBiasTranspose = (context, qkv, bias, batchSize, sequenceLength, hiddenSize, biasOffset) => {
      const outputShape = [batchSize, sequenceLength, hiddenSize];
      const outputSize = ShapeUtil.size(outputShape);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: biasOffset },
        { type: 12 /* uint32 */, data: hiddenSize }
      ];
      const getShaderSource = (shaderHelper) => {
        const output = outputVariable("qkv_with_bias", qkv.dataType, outputShape);
        const qkvInput = inputVariable("qkv", qkv.dataType, outputShape);
        const biasInput = inputVariable("bias", bias.dataType, outputShape);
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "bias_offset", type: "u32" },
          { name: "hidden_size", type: "u32" }
        ];
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(qkvInput, biasInput, output)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`;
      };
      return context.compute(
        {
          name: "MultiHeadAttentionAddBias",
          shaderCache: { inputDependencies: ["type", "type"] },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: qkv.dataType, gpuDataType: 0 /* default */ }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        },
        { inputs: [qkv, bias], outputs: [-1] }
      )[0];
    };
    maybeTransposeToBNSHAndAddBias = (context, batchSize, numHeads, sequenceLength, headSize, input, bias, biasOffset) => {
      let reshapedInput = input;
      if (!bias) {
        if (input.dims.length === 3) {
          reshapedInput = input.reshape([batchSize, sequenceLength, numHeads, headSize]);
        }
        return context.compute(
          createTransposeProgramInfo(reshapedInput, weightTransposeAttribute2.perm),
          { inputs: [reshapedInput], outputs: [-1] }
        )[0];
      } else {
        if (sequenceLength === 1) {
          throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");
        } else {
          reshapedInput = addBiasTranspose(context, input, bias, batchSize, sequenceLength, numHeads * headSize, biasOffset);
          reshapedInput = reshapedInput.reshape([batchSize, sequenceLength, numHeads, headSize]);
          return context.compute(
            createTransposeProgramInfo(reshapedInput, weightTransposeAttribute2.perm),
            { inputs: [reshapedInput], outputs: [-1] }
          )[0];
        }
      }
    };
    multiHeadAttention = (context, attributes) => {
      const params = validateInputs16(context.inputs, attributes);
      const query = context.inputs[0];
      const key = getInput(context.inputs, 1);
      const value = getInput(context.inputs, 2);
      const bias = getInput(context.inputs, 3);
      const keyPaddingMask = getInput(context.inputs, 4);
      const relativePositionBias = getInput(context.inputs, 5);
      const pastKey = getInput(context.inputs, 6);
      const pastValue = getInput(context.inputs, 7);
      if (query.dims.length === 5) {
        throw new Error("Packed QKV is not implemented");
      }
      if (key?.dims.length === 5) {
        throw new Error("Packed KV is not implemented");
      }
      const kvBNSH = key && value && key.dims.length === 4 && value.dims.length === 4;
      const Q = maybeTransposeToBNSHAndAddBias(
        context,
        params.batchSize,
        params.numHeads,
        params.sequenceLength,
        params.headSize,
        query,
        bias,
        0
      );
      if (kvBNSH) {
        return applyAttention(
          context,
          Q,
          key,
          value,
          keyPaddingMask,
          void 0,
          pastKey,
          pastValue,
          relativePositionBias,
          params,
          attributes
        );
      }
      if (!key || !value) {
        throw new Error("key and value must be provided");
      }
      const K = maybeTransposeToBNSHAndAddBias(
        context,
        params.batchSize,
        params.numHeads,
        params.kvSequenceLength,
        params.headSize,
        key,
        bias,
        params.hiddenSize
      );
      const V = maybeTransposeToBNSHAndAddBias(
        context,
        params.batchSize,
        params.numHeads,
        params.kvSequenceLength,
        params.vHeadSize,
        value,
        bias,
        2 * params.hiddenSize
      );
      applyAttention(
        context,
        Q,
        K,
        V,
        keyPaddingMask,
        void 0,
        pastKey,
        pastValue,
        relativePositionBias,
        params,
        attributes
      );
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/tile.ts
var getRepeats, validateInputs17, getOutputShape2, createTileProgramInfo, tile;
var init_tile = __esm({
  "web/lib/wasm/jsep/webgpu/ops/tile.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    getRepeats = (repeatsTensorView) => Array.from(repeatsTensorView.getBigInt64Array(), Number);
    validateInputs17 = (inputs) => {
      if (!inputs || inputs.length !== 2) {
        throw new Error("Tile requires 2 inputs.");
      }
      if (inputs[0].dataType !== 1 /* float */ && inputs[0].dataType !== 10 /* float16 */ && inputs[0].dataType !== 6 /* int32 */ && inputs[0].dataType !== 12 /* uint32 */) {
        throw new Error("Tile only support float, float16, int32, and uint32 data types");
      }
      if (inputs[1].dataType !== 7 /* int64 */) {
        throw new Error("Tile `repeats` input should be of int64 data type");
      }
      if (inputs[1].dims.length !== 1) {
        throw new Error("Tile `repeats` input should be 1-D");
      }
      const repeats = getRepeats(inputs[1]);
      if (repeats.length !== inputs[0].dims.length) {
        throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor");
      }
    };
    getOutputShape2 = (inputShape, repeats) => {
      const outputShape = [];
      for (let i = 0; i < inputShape.length; ++i) {
        outputShape.push(inputShape[i] * repeats[i]);
      }
      return outputShape;
    };
    createTileProgramInfo = (inputs, shape) => {
      const inputShape = inputs[0].dims;
      const repeats = shape == null ? getRepeats(inputs[1]) : shape;
      const outputShape = getOutputShape2(inputShape, repeats);
      const outputSize = ShapeUtil.size(outputShape);
      const dataType = inputs[0].dataType;
      const input = inputVariable("input", dataType, inputShape.length);
      const output = outputVariable("output", dataType, outputShape.length);
      const getShaderSource = (shaderHelper) => `
      const inputShape = ${input.indices(...inputShape)};
      ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}
      ${shaderHelper.mainStart()}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${output.offsetToIndices("global_idx")};
      var input_indices: ${input.type.indices};
      for (var i = 0; i < ${inputShape.length}; i++) {
        let input_dim_i = ${input.indicesGet("uniforms.input_shape", "i")};
        let input_dim_value = ${output.indicesGet("output_indices", "i")}  % input_dim_i;

        ${input.indicesSet("input_indices", "i", "input_dim_value")}
      }
      ${output.setByOffset("global_idx", input.getByIndices("input_indices"))}
    }`;
      return {
        name: "Tile",
        shaderCache: { hint: `${repeats}`, inputDependencies: ["rank"] },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms: [{ type: 12 /* uint32 */, data: outputSize }, ...createTensorShapeVariables(inputs[0].dims, outputShape)]
        }),
        getShaderSource
      };
    };
    tile = (context) => {
      validateInputs17(context.inputs);
      context.compute(createTileProgramInfo(context.inputs), { inputs: [0] });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/group-query-attention.ts
var validateInputs18, createConcatProgramInfo2, parseGroupQueryAttentionAttributes, weightTransposeAttribute3, maybeExpandAndTransposeToBNSH, groupQueryAttention;
var init_group_query_attention = __esm({
  "web/lib/wasm/jsep/webgpu/ops/group-query-attention.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_attention();
    init_common();
    init_multihead_attention();
    init_tile();
    init_transpose();
    validateInputs18 = (inputs, attributes) => {
      const query = inputs[0];
      const key = inputs[1];
      const value = inputs[2];
      const pastKey = inputs[3];
      const pastValue = inputs[4];
      if (query.dims.length !== 3 && query.dims.length !== 5) {
        throw new Error("Input query is expected to have 3 or 5 dimensions");
      }
      const dmmhaPacking = false;
      const batchSize = query.dims[0];
      const sequenceLength = query.dims[1];
      const hiddenSize = query.dims.length === 3 ? dmmhaPacking ? query.dims[2] / 3 : query.dims[2] : attributes.numHeads * query.dims[4];
      let kvSequenceLength = sequenceLength;
      let pastSequenceLength = 0;
      let maxSequenceLength = 0;
      const headSize = Math.floor(hiddenSize / attributes.numHeads);
      const hasPastKey = pastKey && pastKey.dims.length !== 0;
      const hasPastValue = pastValue && pastValue.dims.length !== 0;
      const isPastkvBSNH = true;
      if (hasPastKey && hasPastValue) {
        if (pastKey.dims.length !== 4) {
          throw new Error('Input "past_key" is expected to have 4 dimensions');
        }
        if (pastValue.dims.length !== 4) {
          throw new Error('Input "past_value" is expected to have 4 dimensions');
        }
        if (isPastkvBSNH) {
          pastSequenceLength = pastKey.dims[1];
          maxSequenceLength = pastKey.dims[1];
        } else {
          pastSequenceLength = pastKey.dims[2];
          maxSequenceLength = pastKey.dims[2];
        }
      } else if (hasPastKey || hasPastValue) {
        throw new Error('Input "past_key" and "past_value" shall be both present or both absent');
      }
      let qkvFormat;
      if (key) {
        if (query.dims.length !== 3) {
          throw new Error('Input "query" is expected to have 3 dimensions when key is given');
        }
        if (key.dims.length < 3 || key.dims.length > 5) {
          throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');
        }
        if (query.dims[0] !== key.dims[0]) {
          throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');
        }
        if (key.dims.length === 3) {
          if (query.dims[2] % key.dims[2] !== 0) {
            throw new Error('Dimension 2 of "query" should be a multiple of "key"');
          }
          qkvFormat = 2 /* qkvBSNH */;
          kvSequenceLength = key.dims[1];
        } else if (key.dims.length === 5) {
          if (key.dims[2] !== attributes.numHeads || key.dims[3] !== 2 || key.dims[4] !== headSize) {
            throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');
          }
          if (value) {
            throw new Error('Expect "value" be none when "key" has packed kv format.');
          }
          qkvFormat = 5 /* qKvBSNHxBSN2H */;
          kvSequenceLength = key.dims[1];
        } else {
          if (key.dims[1] !== attributes.numHeads || key.dims[3] !== headSize) {
            throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');
          }
          qkvFormat = 0 /* unknown */;
          kvSequenceLength = key.dims[2];
        }
      } else {
        if (query.dims.length !== 3 && query.dims.length !== 5) {
          throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');
        }
        if (query.dims.length === 5 && (query.dims[2] !== attributes.numHeads || query.dims[3] !== 3)) {
          throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');
        }
        qkvFormat = 3 /* qkvBSN3H */;
      }
      const maskType = 0 /* none */;
      let passPastInKv = false;
      let vHiddenSize = hiddenSize;
      if (value) {
        if (value.dims.length !== 3 && value.dims.length !== 4) {
          throw new Error('Input "value" is expected to have 3 or 4 dimensions');
        }
        if (query.dims[0] !== value.dims[0]) {
          throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');
        }
        if (value.dims.length === 3) {
          if (kvSequenceLength !== value.dims[1]) {
            throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');
          }
          vHiddenSize = value.dims[2];
        } else {
          if (kvSequenceLength !== value.dims[2]) {
            throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');
          }
          vHiddenSize = value.dims[1] * value.dims[3];
          passPastInKv = true;
        }
      }
      const totalSequenceLength = pastSequenceLength + kvSequenceLength;
      const broadcastResPosBias = false;
      return {
        batchSize,
        sequenceLength,
        pastSequenceLength,
        kvSequenceLength,
        totalSequenceLength,
        maxSequenceLength,
        inputHiddenSize: 0,
        hiddenSize,
        vHiddenSize,
        headSize,
        vHeadSize: Math.floor(vHiddenSize / attributes.kvNumHeads),
        numHeads: attributes.numHeads,
        kvNumHeads: attributes.kvNumHeads,
        nReps: attributes.numHeads / attributes.kvNumHeads,
        pastPresentShareBuffer: false,
        maskType,
        scale: attributes.scale,
        broadcastResPosBias,
        passPastInKv,
        qkvFormat,
        isPastkvBSNH
      };
    };
    createConcatProgramInfo2 = (a, b, dataType, params) => {
      const outputShape = [params.batchSize, params.totalSequenceLength, params.kvNumHeads, params.headSize];
      const component = 4;
      const outputSize = ShapeUtil.size(outputShape) / component;
      const presentSequenceLength = params.totalSequenceLength;
      const output = outputVariable("present_kv", dataType, outputShape.length, component);
      const inputA = inputVariable("new_kv", a.dataType, a.dims.length, component);
      const inputB = b ? inputVariable("past_kv", b.dataType, b.dims.length, component) : void 0;
      const H = Math.ceil(params.headSize / component);
      const dispatch = { x: presentSequenceLength, y: a.dims[0], z: 1 };
      const inputDependencies = b ? ["rank", "rank"] : ["rank"];
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: params.pastSequenceLength },
        { type: 12 /* uint32 */, data: params.kvSequenceLength },
        { type: 12 /* uint32 */, data: params.totalSequenceLength }
      ];
      const inputs = [inputA];
      if (inputB) {
        programUniforms.push(
          ...createTensorShapeVariables(a.dims),
          ...createTensorShapeVariables(b.dims),
          ...createTensorShapeVariables(outputShape)
        );
        inputs.push(inputB);
      } else {
        programUniforms.push(...createTensorShapeVariables(a.dims), ...createTensorShapeVariables(outputShape));
      }
      const uniforms = [
        { name: "output_size", type: "u32" },
        { name: "past_seqlen", type: "u32" },
        { name: "new_seqlen", type: "u32" },
        { name: "present_seqlen", type: "u32" }
      ];
      const pastStr = `      let past_batch_stride = uniforms.past_seqlen * num_heads * H;
        var past_head_stride = uniforms.past_seqlen * H;
        if (is_bsnh) {
          past_head_stride = H;
        }
        let in_offset = b * past_batch_stride + s * row_stride + n * past_head_stride + h;
        present_kv[out_offset] = past_kv[in_offset];`;
      const newStr = `      let new_batch_stride = uniforms.new_seqlen * num_heads * H;
        let new_row_stride = num_heads * H;
        let new_head_stride = H;
        let in_offset = b * new_batch_stride + (s - past_seqlen) * new_row_stride + n * new_head_stride + h;
        present_kv[out_offset] = new_kv[in_offset];`;
      const concatStr = b ? `if (s < past_seqlen) {
        ${pastStr}
        } else if (s < past_seqlen + uniforms.new_seqlen) {
        ${newStr}
        }` : `if (s < past_seqlen + uniforms.new_seqlen) {
          ${newStr}
        }`;
      const getShaderSource = (shaderHelper) => `

  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputs, output)}
  ${shaderHelper.mainStart([
        H,
        params.kvNumHeads,
        1
      ])}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    var indices = ${output.offsetToIndices("global_idx")};
    let h = local_id.x;
    let n = local_id.y;
    let s = workgroup_id.x;
    let b = workgroup_id.y;
    let num_heads = ${params.kvNumHeads}u;
    let H = ${H}u;

    let present_seqlen = uniforms.present_seqlen;
    let present_batch_stride = present_seqlen * num_heads * H;
    var row_stride = H;
    let is_bsnh = ${params.isPastkvBSNH};

    if (is_bsnh) {
      row_stride = num_heads * H;
    }
    var present_head_stride = present_seqlen * H;
    if (is_bsnh) {
      present_head_stride = H;
    }

    let past_seqlen = uniforms.past_seqlen;

    let out_offset = b * present_batch_stride + s * row_stride + n * present_head_stride + h;
    ${concatStr}
  }`;
      return {
        name: "ConcatPastNew",
        shaderCache: { hint: `${params.kvNumHeads}${H}${!!b}`, inputDependencies },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType }],
          dispatchGroup: dispatch,
          programUniforms
        }),
        getShaderSource
      };
    };
    parseGroupQueryAttentionAttributes = (attributes) => createAttributeWithCacheKey({ ...attributes });
    weightTransposeAttribute3 = createAttributeWithCacheKey({ perm: [0, 2, 1, 3] });
    maybeExpandAndTransposeToBNSH = (context, input, pastKV, params, outputIndex) => {
      let reshapedInput = input;
      const numHeads = params.kvNumHeads;
      const nReps = params.nReps;
      if (input.dims.length === 3 && params.kvSequenceLength !== 0) {
        reshapedInput = input.reshape([params.batchSize, params.kvSequenceLength, numHeads, params.headSize]);
      }
      if (pastKV) {
        reshapedInput = context.compute(
          createConcatProgramInfo2(reshapedInput, pastKV, reshapedInput.dataType, params),
          { inputs: [reshapedInput, pastKV], outputs: [params.isPastkvBSNH ? outputIndex : -1] }
        )[0];
      } else {
        reshapedInput = context.compute(
          createConcatProgramInfo2(reshapedInput, void 0, reshapedInput.dataType, params),
          { inputs: [reshapedInput], outputs: [params.isPastkvBSNH ? outputIndex : -1] }
        )[0];
      }
      if (nReps !== 1) {
        reshapedInput = context.compute(
          createTileProgramInfo([reshapedInput], [1, 1, 1, nReps]),
          { inputs: [reshapedInput], outputs: [-1] }
        )[0];
        reshapedInput = reshapedInput.reshape([params.batchSize, params.totalSequenceLength, numHeads * nReps, params.headSize]);
      }
      return context.compute(
        createTransposeProgramInfo(reshapedInput, weightTransposeAttribute3.perm),
        { inputs: [reshapedInput], outputs: [-1] }
      )[0];
    };
    groupQueryAttention = (context, attributes) => {
      const params = validateInputs18(context.inputs, attributes);
      if (context.inputs[0].dims.length === 5) {
        throw new Error("Packed QKV is not implemented");
      }
      if (context.inputs[1]?.dims.length === 5) {
        throw new Error("Packed KV is not implemented");
      }
      const Q = maybeTransposeToBNSHAndAddBias(
        context,
        params.batchSize,
        params.numHeads,
        params.sequenceLength,
        params.headSize,
        context.inputs[0],
        void 0,
        0
      );
      const pastKey = context.inputs[3] && context.inputs[3].dims.length !== 0 ? context.inputs[3] : void 0;
      const pastValue = context.inputs[4] && context.inputs[4].dims.length !== 0 ? context.inputs[4] : void 0;
      const K = maybeExpandAndTransposeToBNSH(context, context.inputs[1], pastKey, params, 1);
      const V = maybeExpandAndTransposeToBNSH(context, context.inputs[2], pastValue, params, 2);
      applyAttention(context, Q, K, V, void 0, void 0, void 0, void 0, void 0, params, attributes);
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/instance-norm.ts
var createInstanceNormProgramInfo, computeMean, createInstanceNormNHWCProgramInfo, instanceNorm;
var init_instance_norm = __esm({
  "web/lib/wasm/jsep/webgpu/ops/instance-norm.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    createInstanceNormProgramInfo = (inputs, attributes) => {
      const xShape = inputs[0].dims;
      const outputShape = xShape;
      const axis = 2;
      const normCount = ShapeUtil.sizeToDimension(xShape, axis);
      const normSize = ShapeUtil.sizeFromDimension(xShape, axis);
      const components = getMaxComponents(normSize);
      const normPackedSize = normSize / components;
      const inputShape = [xShape[0], xShape[1], normPackedSize];
      const inputDependencies = ["rank", "type", "type"];
      const programUniforms = [{ type: 12 /* uint32 */, data: normSize }, { type: 12 /* uint32 */, data: normPackedSize }];
      programUniforms.push(...createTensorShapeVariables(inputShape, inputShape));
      const getShaderSource = (shaderHelper) => {
        const x = inputVariable("x", inputs[0].dataType, inputShape.length, components);
        const scale = inputVariable("scale", inputs[1].dataType, inputs[1].dims);
        const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims);
        const output = outputVariable("output", inputs[0].dataType, inputShape.length, components);
        const variables = [x, scale, bias, output];
        const dataType = x.type.value;
        const f32Type = components === 1 ? "f32" : `vec${components}<f32>`;
        const workgroupSize = 64;
        const uniforms = [{ name: "normSize", type: "u32" }, { name: "normPackedSize", type: "u32" }];
        return `
  var<workgroup> meanShared : f32;
  var<workgroup> squaredNormShared : f32;
  var<workgroup> workgroupShared : array<${f32Type}, ${workgroupSize}>;
  const workgroupSize = ${workgroupSize}u;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}
  ${shaderHelper.mainStart(workgroupSize)}
    let norm = global_idx / workgroupSize;
    let batch = norm / uniforms.x_shape[1];
    let channel = norm % uniforms.x_shape[1];
    let localIndex = local_id.x;

    // initialize workgroup memory
    var initial = ${f32Type}(0);
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      initial = initial + ${f32Type}(${x.get("batch", "channel", "h")});
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the mean of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      meanShared = ${sumVector("workgroupShared[0]", components)} / f32(uniforms.normSize);
    }
    workgroupBarrier();

    // reinitialize workgroup memory.
    initial = ${f32Type}(0);
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      let deviation =  ${f32Type}(${x.get("batch", "channel", "h")}) - ${f32Type}(meanShared);
      initial = initial + deviation * deviation;
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the sum of square of deviation of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      squaredNormShared = ${sumVector("workgroupShared[0]", components)};
    }
    workgroupBarrier();

    let invStdDev = inverseSqrt(squaredNormShared / f32(uniforms.normSize) + f32(${attributes.epsilon}));
    let channelScale = invStdDev * f32(${scale.getByOffset("channel")});
    let channelShift = f32(${bias.getByOffset("channel")}) - meanShared * channelScale;
    for (var h = localIndex; h < uniforms.normPackedSize; h += workgroupSize) {
      let value = ${x.get("batch", "channel", "h")} * ${dataType}(${f32Type}(channelScale)) + ${dataType}(${f32Type}(channelShift));
      ${output.set("batch", "channel", "h", "value")};
    }
  }`;
      };
      return {
        ...{ name: "InstanceNormalization" },
        // TODO: use epsilon as uniform. Currently epsilon as uniform fails test_instancenorm_epsilon.
        shaderCache: { hint: `${attributes.epsilon};${components}`, inputDependencies },
        getRunData: () => ({
          outputs: [
            { dims: outputShape, dataType: inputs[0].dataType }
          ],
          dispatchGroup: { x: normCount },
          programUniforms
        }),
        getShaderSource
      };
    };
    computeMean = (context, input, scale, bias, n, h, c, epsilon) => {
      const components = getMaxComponents(c);
      const WG = 64;
      const outputType = components === 1 ? "vec2f" : `mat2x${components}f`;
      const sumCastType = components === 1 ? "f32" : `vec${components}f`;
      const setOutputValue = (var1, var2) => `${outputType}(${var1}, ${var2})`;
      const unitsOfWork = n * c / components;
      const wgSize = Math.ceil(h / WG);
      const meanInputDependencies = ["type"];
      const meanProgramUniforms = [
        { type: 12 /* uint32 */, data: wgSize },
        { type: 12 /* uint32 */, data: h },
        { type: 12 /* uint32 */, data: Math.floor(c / components) },
        { type: 12 /* uint32 */, data: Math.floor(h * c / components) }
      ];
      const getMeanShaderSource = (shaderHelper) => {
        const inputHelper = inputVariable("input", input.dataType, input.dims, components);
        return `
  ${shaderHelper.declareVariables(inputHelper)}
  @group(0) @binding(1) var<storage, read_write> output : array<${outputType}>;
  struct Uniforms {wg_size:u32, H:u32, C:u32, image_size:u32};
  @group(0) @binding(2) var<uniform> uniforms: Uniforms;

  ${shaderHelper.mainStart(WG)}
    let currentImageNumber = global_idx / ${WG} / uniforms.C;
    let currentChannelNumber = (global_idx / ${WG}) % uniforms.C;
    let wgOffset = local_id.x * uniforms.wg_size;
    if (wgOffset >= uniforms.H) {
        return;
    }
    let wgMax = min(wgOffset + uniforms.wg_size, uniforms.H);

    let offset = currentImageNumber * uniforms.image_size + currentChannelNumber;
    var sum = ${fillVector("f32", components)};
    var squaredSum = ${fillVector("f32", components)};
    for (var i: u32 = wgOffset; i < wgMax; i++) {
        let value = ${sumCastType}(input[offset + i * uniforms.C]);
        sum += value;
        squaredSum += value * value;
    }
    output[global_idx] = ${setOutputValue("sum", "squaredSum")};
  }`;
      };
      const meanValues = context.compute(
        {
          name: "InstanceNormComputeMean",
          shaderCache: { hint: `${components}`, inputDependencies: meanInputDependencies },
          getRunData: () => ({
            outputs: [
              { dims: [n, c, WG, 2], dataType: 1 /* float */ }
            ],
            dispatchGroup: { x: n * c / components },
            programUniforms: meanProgramUniforms
          }),
          getShaderSource: getMeanShaderSource
        },
        { inputs: [input], outputs: [-1] }
      )[0];
      const programUniforms = [
        { type: 12 /* uint32 */, data: unitsOfWork },
        { type: 12 /* uint32 */, data: h },
        { type: 12 /* uint32 */, data: Math.floor(c / components) },
        { type: 12 /* uint32 */, data: Math.floor(WG * c / components) }
      ];
      const inputDependencies = ["type", "type", "type"];
      const getShaderSource = (shaderHelper) => {
        const scaleHelper = inputVariable("scale", scale.dataType, scale.dims, components);
        const biasHelper = inputVariable("bias", bias.dataType, bias.dims, components);
        return `
  @group(0) @binding(0) var<storage, read> input : array<${outputType}>;
  @group(0) @binding(1) var<storage, read> scale : array<${scaleHelper.type.storage}>;
  @group(0) @binding(2) var<storage, read> bias : array<${biasHelper.type.storage}>;
  @group(0) @binding(3) var<storage, read_write> output : array<${outputType}>;
  struct Uniforms {units_of_work : u32, H: u32, C : u32, image_size : u32};
  @group(0) @binding(4) var<uniform> uniforms: Uniforms;

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.units_of_work")}
    let currentImageNumber = global_idx / uniforms.C;
    let currentChannelNumber = global_idx % uniforms.C;

    let offset = currentImageNumber * uniforms.image_size;
    var sum = ${fillVector("f32", components)};
    var squaredSum = ${fillVector("f32", components)};
    for (var i: u32 = 0; i < min(${WG}, uniforms.H); i++) {
        let value = input[offset + i + currentChannelNumber * ${WG}];
        sum += value[0];
        squaredSum += value[1];
    }
    sum = sum / f32(uniforms.H);
    squaredSum = squaredSum / f32(uniforms.H);
    let invStdDev = inverseSqrt(squaredSum - sum * sum + f32(${epsilon}));
    let channelScale = invStdDev * ${sumCastType}(scale[currentChannelNumber]);
    let channelShift = ${sumCastType}(bias[currentChannelNumber]) - sum * channelScale;

    output[global_idx] = ${setOutputValue("channelScale", "channelShift")};
  }`;
      };
      return context.compute(
        {
          name: "InstanceNormComputeChannelScaleShift",
          // TODO: use epsilon as uniform. Currently epsilon as uniform fails test_instancenorm_epsilon.
          shaderCache: { hint: `${components};${epsilon}`, inputDependencies },
          getRunData: () => ({
            outputs: [
              { dims: [n, c, 2], dataType: 1 /* float */ }
            ],
            dispatchGroup: { x: Math.ceil(
              unitsOfWork / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        },
        { inputs: [meanValues, scale, bias], outputs: [-1] }
      )[0];
    };
    createInstanceNormNHWCProgramInfo = (context, inputs, attributes) => {
      const xShape = inputs[0].dims;
      const outputShape = xShape;
      const N = xShape[0];
      const C = xShape[xShape.length - 1];
      const H = ShapeUtil.sizeFromDimension(xShape, 1) / C;
      const components = getMaxComponents(C);
      const outputSize = ShapeUtil.size(outputShape) / components;
      const programUniforms = [{ type: 12 /* uint32 */, data: H }, { type: 12 /* uint32 */, data: Math.floor(C / components) }];
      const inputDependencies = ["type", "type"];
      const channelScaleShift = computeMean(context, inputs[0], inputs[1], inputs[2], N, H, C, attributes.epsilon);
      const getShaderSource = (shaderHelper) => {
        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
        const scaleType = components === 1 ? "vec2f" : `mat2x${components}f`;
        const scaleCastType = components === 1 ? dataType : `vec${components}<${dataType}>`;
        const inputHelper = inputVariable("input", inputs[0].dataType, inputs[0].dims, components);
        const outputHelper = outputVariable("output", inputs[0].dataType, outputShape, components);
        return `
  @group(0) @binding(0) var<storage, read> input : array<${inputHelper.type.storage}>;
  @group(0) @binding(1) var<storage, read> scaleInput : array<${scaleType}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${outputHelper.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${shaderHelper.mainStart()}
    let currentImageNumber = global_idx / (uniforms.C * uniforms.H);
    let currentChannelNumber = global_idx % uniforms.C;

    let scaleOffset = currentImageNumber * uniforms.C + currentChannelNumber;
    let scale = scaleInput[scaleOffset];
    output[global_idx] = fma(input[global_idx], ${scaleCastType}(scale[0]), ${scaleCastType}(scale[1]));
  }`;
      };
      context.compute(
        {
          name: "InstanceNormalizationNHWC",
          shaderCache: { hint: `${components}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        },
        { inputs: [inputs[0], channelScaleShift] }
      );
    };
    instanceNorm = (context, attributes) => {
      if (attributes.format === "NHWC") {
        createInstanceNormNHWCProgramInfo(context, context.inputs, attributes);
      } else {
        context.compute(createInstanceNormProgramInfo(context.inputs, attributes));
      }
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/layer-norm.ts
var validateInputs19, createLayerNormProgramInfo, layerNorm;
var init_layer_norm = __esm({
  "web/lib/wasm/jsep/webgpu/ops/layer-norm.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    validateInputs19 = (inputs) => {
      if (!inputs || inputs.length < 2) {
        throw new Error("layerNorm requires at least 2 inputs.");
      }
    };
    createLayerNormProgramInfo = (inputs, attributes, outputCount) => {
      const simplified = attributes.simplified;
      const xShape = inputs[0].dims;
      const scale = inputs[1];
      const bias = !simplified && inputs[2];
      const outputShape = xShape;
      const axis = ShapeUtil.normalizeAxis(attributes.axis, xShape.length);
      const normCount = ShapeUtil.sizeToDimension(xShape, axis);
      const normSize = ShapeUtil.sizeFromDimension(xShape, axis);
      const scaleSize = ShapeUtil.size(scale.dims);
      const biasSize = bias ? ShapeUtil.size(bias.dims) : 0;
      if (scaleSize !== normSize || bias && biasSize !== normSize) {
        throw new Error(`Size of X.shape()[axis:] == ${normSize}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${scaleSize} and bias size of ${biasSize}`);
      }
      const meanInvStdDevDim = [];
      for (let i = 0; i < xShape.length; ++i) {
        if (i < axis) {
          meanInvStdDevDim.push(xShape[i]);
        } else {
          meanInvStdDevDim.push(1);
        }
      }
      const components = getMaxComponents(normSize);
      const inputDependencies = ["type", "type"];
      const programUniforms = [
        { type: 12 /* uint32 */, data: normCount },
        { type: 1 /* float */, data: normSize },
        { type: 12 /* uint32 */, data: Math.floor(normSize / components) },
        { type: 1 /* float */, data: attributes.epsilon }
      ];
      if (bias) {
        inputDependencies.push("type");
      }
      const hasMeanDataOutput = outputCount > 1;
      const hasInvStdOutput = outputCount > 2;
      const getShaderSource = (shaderHelper) => {
        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
        const variables = [
          inputVariable("x", inputs[0].dataType, inputs[0].dims, components),
          inputVariable("scale", scale.dataType, scale.dims, components)
        ];
        if (bias) {
          variables.push(inputVariable("bias", bias.dataType, bias.dims, components));
        }
        variables.push(outputVariable("output", inputs[0].dataType, outputShape, components));
        if (hasMeanDataOutput) {
          variables.push(outputVariable("mean_data_output", 1 /* float */, meanInvStdDevDim));
        }
        if (hasInvStdOutput) {
          variables.push(outputVariable("inv_std_output", 1 /* float */, meanInvStdDevDim));
        }
        const uniforms = [
          { name: "norm_count", type: "u32" },
          { name: "norm_size", type: "f32" },
          { name: "norm_size_vectorized", type: "u32" },
          { name: "epsilon", type: "f32" }
        ];
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${fillVector("f32", components)};
    var mean_square_vector = ${fillVector("f32", components)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${castToF32(dataType, components, "x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${sumVector("mean_vector", components)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${sumVector("mean_square_vector", components)} / uniforms.norm_size ${simplified ? "" : "- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${castToF32(dataType, components, "x[j + offset]")};
      let f32scale = ${castToF32(dataType, components, "scale[j]")};
      output[j + offset] = ${variables[0].type.value}((f32input ${simplified ? "" : "- mean"}) * inv_std_dev * f32scale
        ${bias ? `+ ${castToF32(dataType, components, "bias[j]")}` : ""}
      );
    }

    ${hasMeanDataOutput ? "mean_data_output[global_idx] = mean" : ""};
    ${hasInvStdOutput ? "inv_std_output[global_idx] = inv_std_dev" : ""};
  }`;
      };
      const outputs = [{ dims: outputShape, dataType: inputs[0].dataType }];
      if (hasMeanDataOutput) {
        outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
      }
      if (hasInvStdOutput) {
        outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
      }
      return {
        name: "LayerNormalization",
        shaderCache: { hint: `${components};${outputCount};${simplified}`, inputDependencies },
        getRunData: () => ({ outputs, dispatchGroup: { x: Math.ceil(
          normCount / 64
          /* workgroup size */
        ) }, programUniforms }),
        getShaderSource
      };
    };
    layerNorm = (context, attributes) => {
      validateInputs19(context.inputs);
      context.compute(createLayerNormProgramInfo(context.inputs, attributes, context.outputCount));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/matmulnbits.ts
var validateInputs20, createMatMulNBitsProgramInfo, matMulNBits, parseMatMulNBitsAttributes;
var init_matmulnbits = __esm({
  "web/lib/wasm/jsep/webgpu/ops/matmulnbits.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs20 = (inputs, attributes) => {
      if (inputs.length < 3 || inputs.length > 4) {
        throw new Error("MatMulNBits requires 3 or 4 inputs");
      }
      const a = inputs[0];
      const aRank = a.dims.length;
      if (a.dims[aRank - 1] !== attributes.k) {
        throw new Error("The last dim of input shape does not match the k value");
      }
      const nBlocksPerCol = Math.floor((attributes.k + attributes.blockSize - 1) / attributes.blockSize);
      const blobSize = attributes.blockSize / 8 * attributes.bits;
      const b = inputs[1];
      if (!ShapeUtil.areEqual(b.dims, [attributes.n, nBlocksPerCol, blobSize])) {
        throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");
      }
      const scales = inputs[2];
      const scalesShape = scales.dims;
      if (ShapeUtil.size(scalesShape) !== attributes.n * nBlocksPerCol) {
        throw new Error("scales input size error.");
      }
      if (inputs.length === 4) {
        const zeroPoints = inputs[3];
        const zeroPointsShape = zeroPoints.dims;
        const expectedZeroPointsSize = attributes.bits > 4 ? attributes.n * nBlocksPerCol : attributes.n * Math.floor((nBlocksPerCol + 1) / 2);
        if (ShapeUtil.size(zeroPointsShape) !== expectedZeroPointsSize) {
          throw new Error("zeroPoints input size error.");
        }
      }
    };
    createMatMulNBitsProgramInfo = (inputs, attributes, maxComputeWorkgroupSizes, maxComputeWorkgroupStorageSize) => {
      const inputShape = inputs[0].dims;
      const aRank = inputShape.length;
      const nBlocksPerCol = Math.floor((attributes.k + attributes.blockSize - 1) / attributes.blockSize);
      const dimAOuter = inputShape[aRank - 2];
      const dimInner = attributes.k;
      const dimBOuter = attributes.n;
      const batchDims = inputShape.slice(0, aRank - 2);
      const batchSize = ShapeUtil.size(batchDims);
      const blobSize = attributes.blockSize / 8 * attributes.bits;
      const blobSizeInWords = blobSize / 4;
      const dataType = inputs[0].dataType;
      const outputNumber = getMaxComponents(dimAOuter);
      const aComponents = getMaxComponents(attributes.k);
      const bComponents = getMaxComponents(blobSizeInWords);
      const elementSize = getTensorElementSize(dataType);
      const workgroupOutputSize = dimAOuter * nBlocksPerCol * elementSize;
      const maxNumberOfComponents = Math.floor(maxComputeWorkgroupStorageSize / workgroupOutputSize);
      const useBlockwiseMatMulNBits = nBlocksPerCol <= maxComputeWorkgroupSizes[0] && maxNumberOfComponents > 0;
      const components = !useBlockwiseMatMulNBits || maxNumberOfComponents >= 4 ? getMaxComponents(dimBOuter) : maxNumberOfComponents >= 2 && getMaxComponents(dimBOuter) >= 2 ? 2 : 1;
      const outputShape = batchDims.concat([dimAOuter, dimBOuter]);
      const outputSize = ShapeUtil.size(outputShape) / components / outputNumber;
      const programUniforms = useBlockwiseMatMulNBits ? [] : [{ type: 12 /* uint32 */, data: outputSize }, { type: 12 /* uint32 */, data: attributes.blockSize }];
      const inputShapeTemp = [batchSize, dimAOuter, dimInner / aComponents];
      const bShape = ShapeUtil.convertShape(inputs[1].dims).slice();
      bShape.splice(-1, 1, blobSizeInWords / bComponents);
      programUniforms.push(...createTensorShapeVariables(inputShapeTemp));
      programUniforms.push(...createTensorShapeVariables(bShape));
      programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
      if (inputs.length === 4) {
        programUniforms.push(...createTensorShapeVariables(ShapeUtil.convertShape(inputs[3].dims)));
      }
      const outputShapeTemp = [batchSize, dimAOuter, dimBOuter / components];
      programUniforms.push(...createTensorShapeVariables(outputShapeTemp));
      const getShaderSource = (shaderHelper) => {
        const inputRank = inputShapeTemp.length;
        const a = inputVariable("a", inputs[0].dataType, inputRank, aComponents);
        const b = inputVariable("b", 12 /* uint32 */, bShape.length, bComponents);
        const scales = inputVariable("scales", inputs[2].dataType, inputs[2].dims.length);
        const inputVariables = [a, b, scales];
        const zeroPoints = inputs.length === 4 ? inputVariable("zero_points", 12 /* uint32 */, inputs[3].dims.length) : void 0;
        if (zeroPoints) {
          inputVariables.push(zeroPoints);
        }
        const outputRank = outputShapeTemp.length;
        const output = outputVariable("output", inputs[0].dataType, outputRank, components);
        const uniforms = [{ name: "output_size", type: "u32" }, { name: "block_size", type: "u32" }];
        const dataType2 = tensorTypeToWsglStorageType(inputs[0].dataType);
        const qDqDataType = (() => {
          switch (aComponents) {
            case 1:
              return `array<${dataType2}, 8>`;
            case 2:
              return `mat4x2<${dataType2}>`;
            case 4:
              return `mat2x4<${dataType2}>`;
            default:
              throw new Error(`${aComponents}-component is not supported.`);
          }
        })();
        const processOneBlock = `
        for (var word: u32 = 0; word < ${blobSizeInWords}; word += ${bComponents}) {
          ${b.indicesSet("b_indices", "2", "word")};
          let b_data = ${b.getByIndices("b_indices")};
          for (var i: u32 = 0; i < ${bComponents}; i++) {
            let b_value: u32 = ${bComponents === 1 ? "b_data" : "b_data[word + i]"};
            let b_mask: u32 = 0x0F0F0F0Fu;
            let b_value_lower: vec4<u32> = unpack4xU8(b_value & b_mask);
            let b_value_upper: vec4<u32> = unpack4xU8((b_value >> 4) & b_mask);
            let b_quantized_values = ${qDqDataType}(${Array.from({ length: 4 }, (_, i) => `${dataType2}(b_value_lower[${i}]), ${dataType2}(b_value_upper[${i}])`).join(", ")});
            let b_dequantized_values = ${(() => {
          if (aComponents === 1) {
            return `${qDqDataType}(${Array.from({ length: 8 }, (_, i) => `(b_quantized_values[${i}] - zero_point) * scale`).join(", ")});`;
          } else {
            return `(b_quantized_values - ${qDqDataType}(${Array(8).fill("zero_point").join(",")})) * scale;`;
          }
        })()};
            // Number of B elements per 32-bit word is 32/bits = 32/4 = 8
            for (var m: u32 = 0; m < ${useBlockwiseMatMulNBits ? dimAOuter : outputNumber}u; m++) {
              ${a.indicesSet("a_indices", inputRank - 2, useBlockwiseMatMulNBits ? "m" : `row * ${outputNumber} + m`)};
              ${a.indicesSet("a_indices", inputRank - 1, "word_offset")};
              var input_offset = ${a.indicesToOffset("a_indices")};
              var a_data: ${qDqDataType};
              for (var j: u32 = 0; j < ${8 / aComponents}; j++) {
                a_data[j] = ${a.getByOffset("input_offset")};
                input_offset++;
              }
              ${useBlockwiseMatMulNBits ? "workgroup_shared[workgroup_shared_offset + m]" : "output_values[m]"}${components > 1 ? "[c]" : ""} += ${Array.from(
          { length: 8 / aComponents },
          (_, i) => `${aComponents === 1 ? `a_data[${i}] * b_dequantized_values[${i}]` : `dot(a_data[${i}], b_dequantized_values[${i}])`}`
        ).join(" + ")};
            }
            word_offset += ${8 / aComponents};
          }
        }`;
        const updateZeroPointIndex = zeroPoints ? `
          zero_point_offset += 4;
          if (zero_point_offset == 32) {
            zero_point_offset = 0;
            zero_point_index++;
            zero_point_word = ${zeroPoints.getByOffset("zero_point_index")};
          }` : "";
        return useBlockwiseMatMulNBits ? `
        var<workgroup> workgroup_shared: array<${output.type.value}, ${dimAOuter * nBlocksPerCol}>;
        ${shaderHelper.declareVariables(...inputVariables, output)}
        ${shaderHelper.mainStart([
          nBlocksPerCol,
          1,
          1
        ])}
          var a_indices: ${a.type.indices};
          var block = local_id.x;
          var col = workgroup_id.y;
          var batch = workgroup_id.z;
          ${a.indicesSet("a_indices", "0", "batch")};
          // Two zero points are packed into one byte when uniforms.bits is 4.
          for (var c: u32 = 0; c < ${components}; c++) {
            let col_times_components_plus_c = col * ${components} + c;
              ${zeroPoints ? `
            var zero_point_bytes_per_col: u32 = (${nBlocksPerCol} + 1) / 2;
            var zero_point_byte_count: u32 = col_times_components_plus_c * zero_point_bytes_per_col + (block >> 0x1u);
            var zero_point_word_index: u32 = zero_point_byte_count >> 0x2u;
            var zero_point_byte_offset: u32 = zero_point_byte_count & 0x3u;
            var zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32 = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            var zero_point_word: u32 = ${zeroPoints.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;` : ""}
            var b_indices: ${b.type.indices};
            ${b.indicesSet("b_indices", "0", "col_times_components_plus_c")};
            // The scale and zero points are computed per block.
            var scales_index = col_times_components_plus_c * ${nBlocksPerCol} + block;
            let scale = ${scales.getByOffset("scales_index")};
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${dataType2}(${zeroPoints ? "(zero_point_word) & 0xFu" : 8});
            ${b.indicesSet("b_indices", "1", "block")};
            var word_offset: u32 = block * ${attributes.blockSize / aComponents};
            var workgroup_shared_offset: u32 = block * ${dimAOuter};
            ${processOneBlock}
          }
          workgroupBarrier();
          var output_indices: ${output.type.indices};
          var elements_per_thread: u32 = ${Math.ceil(dimAOuter / nBlocksPerCol)};
          ${output.indicesSet("output_indices", "0", "batch")};
          ${output.indicesSet("output_indices", outputRank - 1, "col")};
          ${output.indicesSet("output_indices", outputRank - 2, "local_id.x * elements_per_thread")};
          var output_offset = ${output.indicesToOffset("output_indices")};
          for (var m: u32 = 0u; m < elements_per_thread; m++) {
            var row = m + local_id.x * elements_per_thread;
            if (row < ${dimAOuter}) {
              var output_value: ${output.type.value} = ${output.type.value}(0);
              var workgroup_shared_offset: u32 = row;
              for (var b: u32 = 0u; b < ${nBlocksPerCol}u; b++) {
                output_value += workgroup_shared[workgroup_shared_offset];
                workgroup_shared_offset += ${dimAOuter};
              }
              ${output.setByOffset("output_offset", "output_value")};
              output_offset += ${dimBOuter / components};
            }
          }
        }` : `
        ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
        ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var output_values: array<${output.type.value}, ${outputNumber}>;
          var output_indices = ${output.offsetToIndices("global_idx")};
          var col = ${output.indicesGet("output_indices", outputRank - 1)};
          var row = ${output.indicesGet("output_indices", outputRank - 2)};
          var a_indices: ${a.type.indices} = output_indices;
          // Two zero points are packed into one byte because uniforms.bits <= 4.
          // zero_point_offset is either 0 or 4. It is bit offset within one byte.
          // TODO support zero_point_offset for bits > 4
          ${zeroPoints ? `
          var zero_point_abs_offset = col * ${components} * ((${nBlocksPerCol} + 1) / 2);
          var zero_point_index: u32 = zero_point_abs_offset / 4;
          var zero_point_word: u32 = ${zeroPoints.getByOffset("zero_point_index")};
          var zero_point_offset: u32 = (zero_point_abs_offset % 4) * 8;` : ""}
          var scale_index = col * ${nBlocksPerCol * components};
          var b_indices: ${b.type.indices};
          for (var c: u32 = 0; c < ${components}; c++) {
            ${b.indicesSet("b_indices", "0", `col * ${components} + c`)};
            var block_offset: u32 = 0;
            for (var block: u32 = 0; block < ${nBlocksPerCol}; block++) {
              // The scale and zero points are computed per block.
              let scale = ${scales.getByOffset("scale_index")};
              // The default zero point is 8 for unsigned 4-bit quantization.
              let zero_point = ${dataType2}(${zeroPoints ? "extractBits(zero_point_word, zero_point_offset, 4)" : 8});
              ${b.indicesSet("b_indices", "1", "block")};
              var word_offset: u32 = block_offset;
              ${processOneBlock}
              scale_index++;
              ${updateZeroPointIndex}
              block_offset += uniforms.block_size / ${aComponents};
            }
            // Drop the trailing 4 bits if the zero_poit_offset is not a byte boundary to align with the next byte.
            ${zeroPoints ? `if (zero_point_offset % 8 > 0) {
                ${updateZeroPointIndex}
              }` : ""}
            }
            for (var k: u32 = 0u; k < ${outputNumber}u; k++) {
              ${output.indicesSet("output_indices", outputRank - 2, `${outputNumber} * row + k`)};
              ${output.setByIndices("output_indices", "output_values[k]")}
            }
        }`;
      };
      return {
        name: useBlockwiseMatMulNBits ? "BlockwiseMatMulNBits" : "MatMulNBits",
        shaderCache: {
          hint: `${attributes.cacheKey};${dimAOuter};${dataType};${inputs.length}`,
          inputDependencies: Array(inputs.length).fill("rank")
        },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType }],
          name: useBlockwiseMatMulNBits ? "BlockwiseMatMulNBits" : "MatMulNBits",
          dispatchGroup: useBlockwiseMatMulNBits ? { x: 1, y: Math.ceil(dimBOuter / components), z: batchSize } : { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    matMulNBits = (context, attributes) => {
      validateInputs20(context.inputs, attributes);
      const maxComputeWorkgroupSizes = context.getMaxComputeWorkgroupSizes();
      const maxComputeWorkgroupStorageSize = context.getMaxComputeWorkgroupStoragesize();
      context.compute(createMatMulNBitsProgramInfo(
        context.inputs,
        attributes,
        maxComputeWorkgroupSizes,
        maxComputeWorkgroupStorageSize
      ));
    };
    parseMatMulNBitsAttributes = (attributes) => createAttributeWithCacheKey(attributes);
  }
});

// web/lib/wasm/jsep/webgpu/ops/pad.ts
var validateInputs21, getPadConstant, getPadReflect, getPadEdge, getPadWrap, getPadSnippet, createPadProgramInfo, createPadAttributesFromInputs, pad;
var init_pad = __esm({
  "web/lib/wasm/jsep/webgpu/ops/pad.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    validateInputs21 = (inputs) => {
      if (!inputs || inputs.length < 1) {
        throw new Error("Too few inputs");
      }
      if (inputs[0].dataType !== 1 /* float */ && inputs[0].dataType !== 10 /* float16 */) {
        throw new Error("Input type must be float or float16.");
      }
      if (inputs.length >= 2) {
        let validPads = inputs[0].dims.length * 2 === inputs[1].dims[0];
        if (inputs.length === 4) {
          validPads = inputs[3].dims[0] * 2 === inputs[1].dims[0];
        }
        if (!validPads) {
          throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].");
        }
      }
    };
    getPadConstant = (output, inputRank, padsLength) => {
      let block = "";
      for (let i = inputRank - 1; i >= 0; --i) {
        block += `
            k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
              break;
            }
            offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
        `;
      }
      return `
          value = ${output.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${block}
            value = x[offset];
          }
      `;
    };
    getPadReflect = (output, inputRank, padsLength) => {
      let block = "";
      for (let i = inputRank - 1; i >= 0; --i) {
        block += `
                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${getElementAt("uniforms.x_shape", i, inputRank)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
            `;
      }
      return `
              var offset = 0;
              var k = 0;
              ${block}
              value = x[offset];
          `;
    };
    getPadEdge = (output, inputRank, padsLength) => {
      let block = "";
      for (let i = inputRank - 1; i >= 0; --i) {
        block += `
                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
                  k = i32(${getElementAt("uniforms.x_shape", i, inputRank)}) - 1;
                }
                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
            `;
      }
      return `
              var offset = 0;
              var k = 0;
              ${block}
              value = x[offset];
          `;
    };
    getPadWrap = (output, inputRank, padsLength) => {
      let block = "";
      for (let i = inputRank - 1; i >= 0; --i) {
        block += `
                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
                if (k < 0)  {
                  k += i32(${getElementAt("uniforms.x_shape", i, inputRank)}]);
                }
                if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
                  k -= i32(${getElementAt("uniforms.x_shape", i, inputRank)});
                }
                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
            `;
      }
      return `
              var offset = 0;
              var k = 0;
              ${block}
              value = x[offset];
          `;
    };
    getPadSnippet = (output, inputRank, attributes) => {
      switch (attributes.mode) {
        case 0:
          return getPadConstant(output, inputRank, attributes.pads.length);
        case 1:
          return getPadReflect(output, inputRank, attributes.pads.length);
        case 2:
          return getPadEdge(output, inputRank, attributes.pads.length);
        case 3:
          return getPadWrap(output, inputRank, attributes.pads.length);
        default:
          throw new Error("Invalid mode");
      }
    };
    createPadProgramInfo = (inputs, attributes) => {
      const outputShape = ShapeUtil.padShape(inputs[0].dims.slice(), attributes.pads);
      const inputDims = inputs[0].dims;
      const outputSize = ShapeUtil.size(outputShape);
      const programUniforms = [{ type: 12 /* uint32 */, data: outputSize }, { type: 6 /* int32 */, data: attributes.pads }];
      if (attributes.mode === 0) {
        programUniforms.push({ type: inputs[0].dataType, data: attributes.value });
      }
      programUniforms.push(...createTensorShapeVariables(inputs[0].dims, outputShape));
      const inputDependencies = ["rank"];
      const getShaderSource = (shaderHelper) => {
        const output = outputVariable("output", inputs[0].dataType, outputShape.length);
        const input = inputVariable("x", inputs[0].dataType, inputDims.length);
        const dataType = input.type.value;
        const padSnippet = getPadSnippet(output, inputDims.length, attributes);
        const uniforms = [{ name: "output_size", type: "u32" }, { name: "pads", type: "i32", length: attributes.pads.length }];
        if (attributes.mode === 0) {
          uniforms.push({ name: "constant_value", type: dataType });
        }
        return `
            ${shaderHelper.registerUniforms(uniforms).declareVariables(input, output)}
            ${shaderHelper.mainStart()}
            ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${output.offsetToIndices("global_idx")};

            var value = ${dataType}(0);
            ${padSnippet}
            output[global_idx] = value;
        }`;
      };
      return {
        name: "Pad",
        shaderCache: { hint: `${attributes.mode}`, inputDependencies },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(
            ShapeUtil.size(outputShape) / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource
      };
    };
    createPadAttributesFromInputs = (inputs, attributes) => {
      if (inputs.length > 1) {
        const bigInt64Pads = inputs[1].getBigInt64Array();
        const value = inputs.length >= 3 && inputs[2].data ? inputs[2].getFloat32Array()[0] : 0;
        const inputRank = inputs[0].dims.length;
        const updatePads = new Int32Array(2 * inputRank).fill(0);
        if (inputs.length >= 4) {
          const axes = inputs[3].getBigInt64Array();
          for (let i = 0; i < axes.length; i++) {
            updatePads[Number(axes[i])] = Number(bigInt64Pads[i]);
            updatePads[Number(axes[i]) + inputRank] = Number(bigInt64Pads[i + axes.length]);
          }
        } else {
          bigInt64Pads.forEach((v, i) => updatePads[Number(i)] = Number(v));
        }
        const pads = [];
        updatePads.forEach((v) => pads.push(v));
        return { mode: attributes.mode, value, pads };
      } else {
        return attributes;
      }
    };
    pad = (context, attributes) => {
      validateInputs21(context.inputs);
      const updatedAttributes = createPadAttributesFromInputs(context.inputs, attributes);
      context.compute(createPadProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/pool.ts
var validateInputs22, getAdjustedPoolAttributesAndOutputShape, getUniformAndPadInfo, generatePoolingCode, createShaderKeyFromAttributes, createAveragePoolShaderKeyFromAttributes, createMaxPoolShaderKeyFromAttributes, parsePoolCommonAttributes, createAveragePoolProgramInfo, parseAveragePoolAttributes, averagePool, globalPoolAttributes, parseGlobalAveragePoolAttributes, globalAveragePool, createMaxPoolProgramInfo, maxPool, parseMaxPoolAttributes, parseGlobalMaxPoolAttributes, globalMaxPool;
var init_pool = __esm({
  "web/lib/wasm/jsep/webgpu/ops/pool.ts"() {
    "use strict";
    init_esm();
    init_wasm_common();
    init_util();
    init_common();
    validateInputs22 = (inputs) => {
      if (env2.webgpu.validateInputContent && (!inputs || inputs.length !== 1)) {
        throw new Error("Pool ops requires 1 input.");
      }
    };
    getAdjustedPoolAttributesAndOutputShape = (input, attributes, isGlobalOperator) => {
      const isChannelsLast = attributes.format === "NHWC";
      const inputShapeAsChannelFirst = input.dims.slice();
      if (isChannelsLast) {
        inputShapeAsChannelFirst.splice(1, 0, inputShapeAsChannelFirst.pop());
      }
      const hasDilations = Object.hasOwnProperty.call(attributes, "dilations");
      const kernelShape = attributes.kernelShape.slice();
      const strides = attributes.strides.slice();
      const dilations = hasDilations ? attributes.dilations.slice() : [];
      const pads = attributes.pads.slice();
      PoolConvUtil.adjustPoolAttributes(isGlobalOperator, inputShapeAsChannelFirst, kernelShape, strides, dilations, pads);
      const outputShapeAsChannelFirst = PoolConvUtil.computePoolOutputShape(
        isGlobalOperator,
        inputShapeAsChannelFirst,
        strides,
        dilations,
        kernelShape,
        pads,
        attributes.autoPad
      );
      const newAttributes = Object.assign({}, attributes);
      if (hasDilations) {
        Object.assign(newAttributes, { kernelShape, strides, pads, dilations, cacheKey: attributes.cacheKey });
      } else {
        Object.assign(newAttributes, { kernelShape, strides, pads, cacheKey: attributes.cacheKey });
      }
      const outputShapeAsChannelLast = outputShapeAsChannelFirst.slice();
      outputShapeAsChannelLast.push(outputShapeAsChannelLast.splice(1, 1)[0]);
      return [newAttributes, isChannelsLast ? outputShapeAsChannelLast : outputShapeAsChannelFirst];
    };
    getUniformAndPadInfo = (outputShape, attributes) => {
      const isChannelsLast = attributes.format === "NHWC";
      const outputSize = ShapeUtil.size(outputShape);
      const kernelSize = ShapeUtil.size(attributes.kernelShape);
      const programUniforms = [{ type: 12 /* uint32 */, data: outputSize }, { type: 12 /* uint32 */, data: kernelSize }];
      const uniforms = [{ name: "outputSize", type: "u32" }, { name: "kernelSize", type: "u32" }];
      if (attributes.kernelShape.length <= 2) {
        const kw = attributes.kernelShape[attributes.kernelShape.length - 1];
        const sw = attributes.strides[attributes.strides.length - 1];
        const pwStart = attributes.pads[attributes.pads.length / 2 - 1];
        const pwEnd = attributes.pads[attributes.pads.length - 1];
        const pwStartEndNotZero = !!(pwStart + pwEnd);
        programUniforms.push(
          { type: 12 /* uint32 */, data: kw },
          { type: 12 /* uint32 */, data: sw },
          { type: 12 /* uint32 */, data: pwStart },
          { type: 12 /* uint32 */, data: pwEnd }
        );
        uniforms.push(
          { name: "kw", type: "u32" },
          { name: "sw", type: "u32" },
          { name: "pwStart", type: "u32" },
          { name: "pwEnd", type: "u32" }
        );
        let phStartEndNotZero = false;
        if (attributes.kernelShape.length === 2) {
          const kh = attributes.kernelShape[attributes.kernelShape.length - 2];
          const sh = attributes.strides[attributes.strides.length - 2];
          const phStart = attributes.pads[attributes.pads.length / 2 - 2];
          const phEnd = attributes.pads[attributes.pads.length - 2];
          phStartEndNotZero = !!(phStart + phEnd);
          programUniforms.push(
            { type: 12 /* uint32 */, data: kh },
            { type: 12 /* uint32 */, data: sh },
            { type: 12 /* uint32 */, data: phStart },
            { type: 12 /* uint32 */, data: phEnd }
          );
          uniforms.push(
            { name: "kh", type: "u32" },
            { name: "sh", type: "u32" },
            { name: "phStart", type: "u32" },
            { name: "phEnd", type: "u32" }
          );
        }
        return [programUniforms, uniforms, true, pwStartEndNotZero, phStartEndNotZero];
      } else {
        if (isChannelsLast) {
          throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");
        }
        const kernelStrides = ShapeUtil.computeStrides(attributes.kernelShape);
        programUniforms.push(
          { type: 12 /* uint32 */, data: kernelStrides },
          { type: 12 /* uint32 */, data: attributes.pads },
          { type: 12 /* uint32 */, data: attributes.strides }
        );
        uniforms.push(
          { name: "kernelStrides", type: "u32", length: kernelStrides.length },
          { name: "pads", type: "u32", length: attributes.pads.length },
          { name: "strides", type: "u32", length: attributes.strides.length }
        );
        const hasPads = attributes.pads.reduce((sum, cur) => sum + cur);
        return [programUniforms, uniforms, !!hasPads, false, false];
      }
    };
    generatePoolingCode = (shaderHelper, x, rank, outputShapeRank, attributes, op1, op2, start, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero) => {
      const isChannelsLast = attributes.format === "NHWC";
      const dataType = x.type.value;
      const output = outputVariable("output", x.type.tensor, outputShapeRank);
      if (attributes.kernelShape.length <= 2) {
        let codeW = "";
        let codeH = "";
        let codeHEnd = "";
        const dimIdxW = rank - (isChannelsLast ? 2 : 1);
        if (pwStartEndNotZero) {
          codeW = `
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${dimIdxW}] = indices[${dimIdxW}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${dimIdxW}] < 0 || xIndices[${dimIdxW}]
                      >= uniforms.x_shape[${dimIdxW}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${x.indicesToOffset("xIndices")}];
                  ${op1}
                }`;
        } else {
          codeW = `
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${dimIdxW}] = indices[${dimIdxW}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${x.indicesToOffset("xIndices")}];
                  ${op1}
                }`;
        }
        if (attributes.kernelShape.length === 2) {
          const dimIdxH = rank - (isChannelsLast ? 3 : 2);
          if (phStartEndNotZero) {
            codeH = `
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${dimIdxH}] = indices[${dimIdxH}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${dimIdxH}] < 0 || xIndices[${dimIdxH}] >= uniforms.x_shape[${dimIdxH}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `;
          } else {
            codeH = `
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${dimIdxH}] = indices[${dimIdxH}] * uniforms.sh - uniforms.phStart + j;
                `;
          }
          codeHEnd = `
              }
            `;
        }
        const poolingCode = `
            ${shaderHelper.registerUniforms(uniforms).declareVariables(x, output)}

            ${shaderHelper.mainStart()}
              ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${output.offsetToIndices("global_idx")};
              var xIndices = ${output.offsetToIndices("global_idx")};

              var value = ${dataType}(${start});
              var pad = 0;
              ${codeH}
              ${codeW}
              ${codeHEnd}
              ${op2}

              output[global_idx] = value;
            }`;
        return poolingCode;
      } else {
        if (isChannelsLast) {
          throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");
        }
        const stridesRank = attributes.kernelShape.length;
        const padsRank = attributes.pads.length;
        let padCode = "";
        if (hasPads) {
          padCode = `
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${x.indicesToOffset("xIndices")}];
                ${op1}
              }`;
        } else {
          padCode = `
              }
              let x_val = x[${x.indicesToOffset("xIndices")}];
              ${op1}
            `;
        }
        const poolingCode = `
            ${shaderHelper.registerUniforms(uniforms).declareVariables(x, output)}

            ${shaderHelper.mainStart()}
              ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${output.offsetToIndices("global_idx")};
              var xIndices = ${output.offsetToIndices("global_idx")};

              var offsets: array<u32, ${stridesRank}>;

              var value = ${dataType}(${start});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${stridesRank - 1}u; j++) {
                  offsets[j] = offset / ${getElementAt("uniforms.kernelStrides", "j", stridesRank)};
                  offset -= offsets[j] * ${getElementAt("uniforms.kernelStrides", "j", stridesRank)};
                }
                offsets[${stridesRank - 1}] = offset;

                isPad = false;
                for (var j = ${rank - stridesRank}u; j < ${rank}u; j++) {
                  xIndices[j] = indices[j] * ${getElementAt("uniforms.strides", `j - ${rank - stridesRank}u`, stridesRank)}
                    + offsets[j - ${rank - stridesRank}u] - ${getElementAt("uniforms.pads", "j - 2u", padsRank)};
                  ${padCode}
              }
              ${op2}

              output[global_idx] = value;
            }`;
        return poolingCode;
      }
    };
    createShaderKeyFromAttributes = (attributes) => `${attributes.format};${attributes.ceilMode};${attributes.autoPad};${attributes.kernelShape.length}`;
    createAveragePoolShaderKeyFromAttributes = (attributes) => `${createShaderKeyFromAttributes(attributes)};${attributes.countIncludePad}`;
    createMaxPoolShaderKeyFromAttributes = (attributes) => `${createShaderKeyFromAttributes(attributes)};${attributes.storageOrder};${attributes.dilations}`;
    parsePoolCommonAttributes = (attributes) => ({
      format: attributes.format,
      autoPad: ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][attributes.auto_pad],
      ceilMode: attributes.ceil_mode,
      kernelShape: attributes.kernel_shape,
      strides: attributes.strides,
      pads: attributes.pads
    });
    createAveragePoolProgramInfo = (name, input, isGlobalOperator, attributes) => {
      const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(input, attributes, isGlobalOperator);
      const x = inputVariable("x", input.dataType, input.dims.length);
      const dataType = x.type.value;
      const op1 = "value += x_val;";
      let op2 = "";
      if (adjustedAttributes.countIncludePad) {
        op2 += `value /= ${dataType}(uniforms.kernelSize);`;
      } else {
        op2 += `value /= ${dataType}(i32(uniforms.kernelSize) - pad);`;
      }
      const [programUniforms, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero] = getUniformAndPadInfo(outputShape, adjustedAttributes);
      programUniforms.push(...createTensorShapeVariables(input.dims, outputShape));
      const inputDependencies = ["rank"];
      return {
        name,
        shaderCache: { hint: `${attributes.cacheKey};${hasPads};${pwStartEndNotZero};${phStartEndNotZero}`, inputDependencies },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: input.dataType }],
          dispatchGroup: { x: Math.ceil(
            ShapeUtil.size(outputShape) / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource: (shaderHelper) => generatePoolingCode(
          shaderHelper,
          x,
          input.dims.length,
          outputShape.length,
          adjustedAttributes,
          op1,
          op2,
          0,
          uniforms,
          hasPads,
          pwStartEndNotZero,
          phStartEndNotZero
        )
      };
    };
    parseAveragePoolAttributes = (attributes) => {
      const countIncludePad = attributes.count_include_pad === 0 ? false : true;
      const attr = parsePoolCommonAttributes(attributes);
      if (attr.ceilMode !== 0) {
        throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
      }
      const averagePoolAttributes = { countIncludePad, ...attr, cacheKey: "" };
      return { ...averagePoolAttributes, cacheKey: createAveragePoolShaderKeyFromAttributes(averagePoolAttributes) };
    };
    averagePool = (context, attributes) => {
      validateInputs22(context.inputs);
      context.compute(createAveragePoolProgramInfo("AveragePool", context.inputs[0], false, attributes));
    };
    globalPoolAttributes = {
      autoPad: "",
      ceilMode: 0,
      countIncludePad: false,
      kernelShape: [],
      strides: [],
      pads: [],
      storageOrder: 0,
      dilations: []
    };
    parseGlobalAveragePoolAttributes = (attributes) => {
      const format = attributes.format;
      return { format, ...globalPoolAttributes, cacheKey: format };
    };
    globalAveragePool = (context, attributes) => {
      validateInputs22(context.inputs);
      context.compute(createAveragePoolProgramInfo("GlobalAveragePool", context.inputs[0], true, attributes));
    };
    createMaxPoolProgramInfo = (name, input, isGlobalOperator, attributes) => {
      const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(input, attributes, isGlobalOperator);
      const op1 = `
      value = max(x_val, value);
    `;
      const op2 = "";
      const x = inputVariable("x", input.dataType, input.dims.length);
      const inputDependencies = ["rank"];
      const [programUniforms, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero] = getUniformAndPadInfo(outputShape, adjustedAttributes);
      programUniforms.push(...createTensorShapeVariables(input.dims, outputShape));
      return {
        name,
        shaderCache: { hint: `${attributes.cacheKey};${hasPads};${pwStartEndNotZero};${phStartEndNotZero}`, inputDependencies },
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: input.dataType }],
          dispatchGroup: { x: Math.ceil(
            ShapeUtil.size(outputShape) / 64
            /* workgroup size */
          ) },
          programUniforms
        }),
        getShaderSource: (shaderHelper) => generatePoolingCode(
          shaderHelper,
          x,
          input.dims.length,
          outputShape.length,
          adjustedAttributes,
          op1,
          op2,
          input.dataType === 10 /* float16 */ ? -65504 : -1e5,
          uniforms,
          hasPads,
          pwStartEndNotZero,
          phStartEndNotZero
        )
      };
    };
    maxPool = (context, attributes) => {
      validateInputs22(context.inputs);
      context.compute(createMaxPoolProgramInfo("MaxPool", context.inputs[0], false, attributes));
    };
    parseMaxPoolAttributes = (attributes) => {
      const storageOrder = attributes.storage_order;
      const dilations = attributes.dilations;
      const attr = parsePoolCommonAttributes(attributes);
      if (storageOrder !== 0) {
        throw new Error("column major storage order is not yet supported for MaxPool");
      }
      if (attr.ceilMode !== 0) {
        throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
      }
      const maxPoolAttributes = { storageOrder, dilations, ...attr, cacheKey: "" };
      return { ...maxPoolAttributes, cacheKey: createMaxPoolShaderKeyFromAttributes(maxPoolAttributes) };
    };
    parseGlobalMaxPoolAttributes = (attributes) => {
      const format = attributes.format;
      return { format, ...globalPoolAttributes, cacheKey: format };
    };
    globalMaxPool = (context, attributes) => {
      validateInputs22(context.inputs);
      context.compute(createMaxPoolProgramInfo("GlobalMaxPool", context.inputs[0], true, attributes));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/range.ts
var validateInputsContent, createRangeProgramInfo, range;
var init_range = __esm({
  "web/lib/wasm/jsep/webgpu/ops/range.ts"() {
    "use strict";
    init_esm();
    init_wasm_common();
    init_common();
    validateInputsContent = (start, limit, delta) => {
      const sameStartLimit = start === limit;
      const increasingRangeNegativeStep = start < limit && delta < 0;
      const decreasingRangePositiveStep = start > limit && delta > 0;
      if (sameStartLimit || increasingRangeNegativeStep || decreasingRangePositiveStep) {
        throw new Error("Range these inputs' contents are invalid.");
      }
    };
    createRangeProgramInfo = (start, limit, delta, dataType) => {
      const numElements = Math.abs(Math.ceil((limit - start) / delta));
      const outputShape = [numElements];
      const outputSize = numElements;
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: dataType, data: start },
        { type: dataType, data: delta },
        ...createTensorShapeVariables(outputShape)
      ];
      const getShaderSource = (shaderHelper) => {
        const output = outputVariable("output", dataType, outputShape.length);
        const wgslType = output.type.value;
        const uniforms = [
          { name: "outputSize", type: "u32" },
          { name: "start", type: wgslType },
          { name: "delta", type: wgslType }
        ];
        return `
        ${shaderHelper.registerUniforms(uniforms).declareVariables(output)}
        ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${wgslType}(global_idx) * uniforms.delta;
      }`;
      };
      return {
        name: "Range",
        shaderCache: { hint: `${dataType}` },
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        })
      };
    };
    range = (context) => {
      let start = 0;
      let limit = 0;
      let delta = 0;
      if (context.inputs[0].dataType === 6 /* int32 */) {
        start = context.inputs[0].getInt32Array()[0];
        limit = context.inputs[1].getInt32Array()[0];
        delta = context.inputs[2].getInt32Array()[0];
      } else if (context.inputs[0].dataType === 1 /* float */) {
        start = context.inputs[0].getFloat32Array()[0];
        limit = context.inputs[1].getFloat32Array()[0];
        delta = context.inputs[2].getFloat32Array()[0];
      }
      if (env2.webgpu.validateInputContent) {
        validateInputsContent(start, limit, delta);
      }
      context.compute(createRangeProgramInfo(start, limit, delta, context.inputs[0].dataType), { inputs: [] });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/resize.ts
var validateScales, updateScales, validateInputs23, getOriginalCoordinateFromResizedCoordinate, getNearestPixelFromOriginal, updateRoI, initOutputShape, adjustOutputShape, calculateOriginalIndicesFromOutputIndices, calculateInputIndicesFromOutputIndices, checkInputIndices, setChannelAndBatchIndices, bilinearInterpolation, bicubicInterpolation, trilinearInterpolation, createResizeProgramInfo, getOpsetVersionFromCustomDataBuffer, resize, parseResizeAttributes;
var init_resize = __esm({
  "web/lib/wasm/jsep/webgpu/ops/resize.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateScales = (scales, attributes) => {
      scales.every((value) => value > 0 || (() => {
        throw new Error("Resize requires scales input values to be positive");
      }));
      if (scales.length > 0) {
        if (attributes.mode === "linear") {
          if (!(scales.length === 2 || scales.length === 3 || scales.length === 4 && scales[0] === 1 && scales[1] === 1 || scales.length === 4 && scales[0] === 1 && scales[3] === 1 || scales.length === 5 && scales[0] === 1 && scales[1] === 1)) {
            throw new Error(
              `For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`
            );
          }
        } else if (attributes.mode === "cubic") {
          if (!(scales.length === 2 || scales.length === 4 && scales[0] === 1 && scales[1] === 1 || scales.length === 4 && scales[0] === 1 && scales[3] === 1)) {
            throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode");
          }
        }
      }
    };
    updateScales = (scales, axes, rank) => {
      axes.every((value) => value >= 0 && value < rank || (() => {
        throw new Error("Resize requires axes input values to be positive and less than rank");
      }));
      const newScales = new Array(rank).fill(1);
      axes.forEach((value, index) => newScales[value] = scales[index]);
      return newScales;
    };
    validateInputs23 = (inputs, attributes, opsetVersion, scales, sizes, roi) => {
      const [roiInputIndex, scalesInputIndex, sizesInputIndex] = opsetVersion > 10 ? [1, 2, 3] : [-1, inputs.length > 1 ? 1 : -1, -1];
      const rank = inputs[0].dims.length;
      if (roiInputIndex > 0 && inputs.length > roiInputIndex && inputs[roiInputIndex].dims.length > 0) {
        inputs[roiInputIndex].getFloat32Array().forEach((value) => roi.push(value));
      } else if (attributes.coordinateTransformMode === "tf_crop_and_resize") {
        throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");
      }
      if (scalesInputIndex > 0 && inputs.length > scalesInputIndex && inputs[scalesInputIndex].dims.length > 0) {
        inputs[scalesInputIndex].getFloat32Array().forEach((value) => scales.push(value));
        if (scales.length !== 0 && (scales.length !== rank && (opsetVersion >= 18 && scales.length !== attributes.axes.length))) {
          throw new Error(
            "Resize requires scales input size to be same as input rank or axes size for opset 18 and up"
          );
        }
        validateScales(scales, attributes);
        if (attributes.axes.length > 0) {
          updateScales(scales, attributes.axes, rank).forEach((value, index) => scales[index] = value);
        }
      }
      if (sizesInputIndex > 0 && inputs.length > sizesInputIndex) {
        inputs[sizesInputIndex].getBigInt64Array().forEach((value) => sizes.push(Number(value)));
        if (sizes.length !== rank || opsetVersion >= 18 && sizes.length === attributes.axes.length) {
          throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");
        }
      }
      if (attributes.axes.length > 0) {
        if (scales.length !== attributes.axes.length) {
          throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');
        }
        if (sizes.length !== attributes.axes.length) {
          throw new Error(
            'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified'
          );
        }
      }
      if (typeof scales !== "undefined" && typeof sizes !== "undefined" && scales.length > 0 && sizes.length > rank) {
        throw new Error("Resize requires only of scales or sizes to be specified");
      }
    };
    getOriginalCoordinateFromResizedCoordinate = (coordinateTransferMode, dType) => `fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${dType} { ` + (() => {
      switch (coordinateTransferMode) {
        case "asymmetric":
          return `return ${dType}(xResized) / ${dType}(xScale);`;
        case "pytorch_half_pixel":
          return `if (lengthResized > 1) {
                    return (${dType}(xResized) + 0.5) / ${dType}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;
        case "tf_half_pixel_for_nn":
          return `return (${dType}(xResized) + 0.5) / ${dType}(xScale);`;
        case "align_corners":
          return `if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating
                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
                    // offset-by-one error later in floor().
                    let whole = ${dType}(xResized * (lengthOriginal - 1) / (lengthResized - 1));
                    let fract =
                        ${dType}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${dType}(lengthResized - 1);
                    return whole + fract;
                  }`;
        case "tf_crop_and_resize":
          return `if (lengthResized > 1) {
                    return ${dType}(roiStart) * ${dType}(lengthOriginal - 1) +
                        (${dType}(xResized) * ${dType}(roiEnd - roiStart) * ${dType}(lengthOriginal - 1)) /
                        ${dType}(lengthResized - 1);
                  } else {
                    return 0.5 * ${dType}(roiStart + roiEnd) * ${dType}(lengthOriginal - 1);
                  }`;
        case "half_pixel_symmetric":
          return `const outputWidth = ${dType}xScale * ${dType}(lengthResized);
                  const adjustment = ${dType}(lengthResized) / outputWidth;
                  const center = ${dType}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${dType}(xResized) + 0.5) / ${dType}(xScale)) - 0.5;`;
        case "half_pixel":
          return `return ((${dType}(xResized) + 0.5) / ${dType}(xScale)) - 0.5;`;
        default:
          throw new Error(`Coordinate transform mode ${coordinateTransferMode} is not supported`);
      }
    })() + "}";
    getNearestPixelFromOriginal = (nearestMode, opsetVersion, dType) => `fn getNearestPixelFromOriginal(xOriginal: ${dType}, isDownSample: bool) -> ${dType} {` + (() => {
      switch (nearestMode) {
        case "round_prefer_ceil":
          return "if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";
        case "floor":
          return "return floor(xOriginal);";
        case "ceil":
          return "return ceil(xOriginal);";
        case "round_prefer_floor":
          return "if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";
        case "simple":
        default:
          if (opsetVersion < 11) {
            return "if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";
          }
          throw new Error(`Nearest mode ${nearestMode} is not supported`);
      }
    })() + "}";
    updateRoI = (roi, axes, rank) => {
      const roiTmp = new Array(rank).fill(0).concat(new Array(rank).fill(1));
      const roiLocal = roi.length === 0 ? roiTmp : roi.slice();
      if (axes.length > 0) {
        axes.forEach((v, i) => {
          roiTmp[v] = roiLocal[i];
          roiTmp[i + rank] = roiLocal[axes.length + i];
        });
        return roiTmp;
      }
      return roiLocal;
    };
    initOutputShape = (inputShape, scales, sizes, axes) => {
      let outputShape = [];
      if (sizes.length > 0) {
        if (axes.length > 0) {
          inputShape.forEach((v) => outputShape.push(v));
          if (Math.max(...axes) > inputShape.length) {
            throw new Error("axes is out of bound");
          }
          axes.forEach((v, i) => outputShape[v] = sizes[i]);
        } else {
          sizes.forEach((v) => outputShape.push(v));
        }
      } else {
        if (scales.length === 0) {
          throw new Error("Resize requires either scales or sizes.");
        } else {
          outputShape = inputShape.map((value, index) => Math.round(value * scales[index]));
        }
      }
      return outputShape;
    };
    adjustOutputShape = (inputShape, scales, attributes) => {
      const scaleInPolicy = (() => {
        switch (attributes.keepAspectRatioPolicy) {
          case "not_larger":
            return attributes.axes.length > 0 ? Math.min(...attributes.axes.map((i) => scales[i]), Number.MAX_VALUE) : Math.min(...scales, Number.MAX_VALUE);
          case "not_smaller":
            return attributes.axes.length > 0 ? Math.max(...attributes.axes.map((i) => scales[i]), Number.MIN_VALUE) : Math.max(...scales, Number.MIN_VALUE);
          default:
            throw new Error(`Keep aspect ratio policy ${attributes.keepAspectRatioPolicy} is not supported`);
        }
      })();
      scales.fill(1, 0, scales.length);
      const adjustedOutputShape = inputShape.slice();
      if (attributes.axes.length > 0) {
        attributes.axes.forEach((v) => scales[v] = scaleInPolicy);
        attributes.axes.forEach((v) => adjustedOutputShape[v] = Math.round(inputShape[v] * scales[v]));
      } else {
        scales.fill(scaleInPolicy, 0, scales.length);
        adjustedOutputShape.forEach((v, i) => adjustedOutputShape[i] = Math.round(v * scales[i]));
      }
      return adjustedOutputShape;
    };
    calculateOriginalIndicesFromOutputIndices = (output, inputShape, outputShape, scalesLength, roiLength) => `
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${output.type.indices}) -> array<${output.type.value}, ${outputShape.length}> {
      var original_indices: array<${output.type.value}, ${outputShape.length}>;
      for (var i:u32 = 0; i < ${outputShape.length}; i++) {
        var output_index = ${output.indicesGet("output_indices", "i")};
        var scale = ${getElementAt("uniforms.scales", "i", scalesLength)};
        var roi_low = ${getElementAt("uniforms.roi", "i", roiLength)};
        var roi_hi = ${getElementAt("uniforms.roi", `i + ${inputShape.length}`, roiLength)};
        if (scale == 1.0) {
          original_indices[i] = ${output.type.value}(output_index);
        } else {
          var input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};
          var output_shape_i = ${getElementAt("uniforms.output_shape", "i", outputShape.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`;
    calculateInputIndicesFromOutputIndices = (input, output, inputShape, outputShape, scalesLength, roiLength, useExtrapolation) => `
    fn calculateInputIndicesFromOutputIndices(output_indices: ${output.type.indices}) -> ${input.type.indices} {
      var input_indices: ${input.type.indices};
      for (var i:u32 = 0; i < ${outputShape.length}; i++) {
        var output_index = ${output.indicesGet("output_indices", "i")};
        var input_index: u32;
        var scale = ${getElementAt("uniforms.scales", "i", scalesLength)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${getElementAt("uniforms.roi", "i", roiLength)};
          var roi_hi = ${getElementAt("uniforms.roi", `i + ${inputShape.length}`, roiLength)};
          var input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};
          var output_shape_i = ${getElementAt("uniforms.output_shape", "i", outputShape.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${useExtrapolation} || (original_idx >= 0 && original_idx < ${output.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${output.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${input.indicesSet("input_indices", "i", " input_index")}
      }
      return input_indices;
    }`;
    checkInputIndices = (input, inputShape) => `
    fn checkInputIndices(input_indices: ${input.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${inputShape.length}; i++) {
        var input_index = ${input.indicesGet("input_indices", "i")};
        if (input_index < 0 || input_index >= ${getElementAt("uniforms.input_shape", "i", inputShape.length)}) {
          return false;
        }
      }
      return true;
    }`;
    setChannelAndBatchIndices = (input, channelIdx, batchIdx, spacialDims) => input.rank > spacialDims ? `
    ${input.indicesSet("input_indices", channelIdx, "channel")};
    ${input.indicesSet("input_indices", batchIdx, "batch")};
` : "";
    bilinearInterpolation = (input, output, inputShape, useExtrapolation, extrapolationValue) => {
      const isNchw = true;
      const [batchIdx, heightIdx, widthIdx, channelIdx] = inputShape.length === 2 ? [-1, 0, 1, -1] : isNchw ? [0, 2, 3, 1] : [0, 1, 2, 3];
      const dType = input.type.value;
      return `
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${dType} {
      var input_indices: ${input.type.indices};
      ${input.indicesSet("input_indices", heightIdx, `max(0, min(row, ${inputShape[heightIdx]} - 1))`)};
      ${input.indicesSet("input_indices", widthIdx, `max(0, min(col, ${inputShape[widthIdx]} - 1))`)};
      ${setChannelAndBatchIndices(input, channelIdx, batchIdx, 2)}
      return ${input.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${output.type.indices}) -> ${dType} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${dType} = originalIndices[${heightIdx}];
      var col:${dType} = originalIndices[${widthIdx}];
      ${useExtrapolation ? `if (row < 0 || row > (${inputShape[heightIdx]} - 1) || col < 0 || col > (${inputShape[widthIdx]} - 1)) {
        return ${extrapolationValue};
      }` : ""};
      row = max(0, min(row, ${inputShape[heightIdx]} - 1));
      col = max(0, min(col, ${inputShape[widthIdx]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${inputShape.length > 2 ? `u32(originalIndices[${channelIdx}])` : "0"};
      var batch: u32 =  ${inputShape.length > 2 ? `u32(originalIndices[${batchIdx}])` : "0"};
      var x11: ${dType} = getInputValue(batch, channel, row1, col1);
      var x12: ${dType} = getInputValue(batch, channel, row1, col2);
      var x21: ${dType} = getInputValue(batch, channel, row2, col1);
      var x22: ${dType} = getInputValue(batch, channel, row2, col2);
      var dx1: ${dType} = abs(row - ${dType}(row1));
      var dx2: ${dType} = abs(${dType}(row2) - row);
      var dy1: ${dType} = abs(col - ${dType}(col1));
      var dy2: ${dType} = abs(${dType}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`;
    };
    bicubicInterpolation = (input, output, inputShape, outputShape, scales, roi, cubicCoeffA, useExtrapolation, extrapolationValue, excludeOutside) => {
      const is2D = inputShape.length === 2;
      const isNchw = true;
      const [heightIdx, widthIdx] = is2D ? [0, 1] : isNchw ? [2, 3] : [1, 2];
      const dType = input.type.value;
      const createCubicInterpolationFunction = (idx) => {
        const direction = idx === heightIdx ? "row" : "col";
        return `
      fn ${direction}CubicInterpolation(input_indices: ${input.type.indices}, output_indices: ${output.type.indices}) -> ${dType} {
        var output_index = ${output.indicesGet("output_indices", idx)};
        var originalIdx: ${dType} = getOriginalCoordinateFromResizedCoordinate(output_index, ${scales[idx]},
        ${outputShape[idx]}, ${inputShape[idx]}, ${roi[idx]}, ${roi[idx]} + ${inputShape.length});
        var fractOriginalIdx: ${dType} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${useExtrapolation} && (originalIdx < 0 || originalIdx > (${inputShape[idx]} - 1))) {
          return ${extrapolationValue};
        }
        var data: array<${dType}, 4> = array<${dType}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${direction}: ${dType} = originalIdx + ${dType}(i);
          if (${direction} < 0 || ${direction} >= ${inputShape[idx]}) {
            ${(() => {
          if (excludeOutside) {
            return `coefs[i + 1] = 0.0;
                        continue;`;
          } else if (useExtrapolation) {
            return `return ${extrapolationValue};`;
          } else {
            return `${direction} = max(0, min(${direction}, ${inputShape[idx]} - 1));`;
          }
        })()};
          }
        var input_indices_copy: ${input.type.indices} = input_indices;
          ${input.indicesSet("input_indices_copy", idx, `u32(${direction})`)};
          data[i + 1] = ${idx === heightIdx ? input.getByIndices("input_indices_copy") : "rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`;
      };
      return `
    ${createCubicInterpolationFunction(heightIdx)};
    ${createCubicInterpolationFunction(widthIdx)};
  fn getCubicInterpolationCoefs(s: ${dType}) -> array<${dType}, 4> {
    var absS = abs(s);
    var coeffs: array<${dType}, 4> = array<${dType}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${dType} = 1.0 - absS;
    var twoMinusAbsS: ${dType} = 2.0 - absS;
    var onePlusAbsS: ${dType} = 1.0 + absS;
    coeffs[0] = ((${cubicCoeffA} * onePlusAbsS - 5 * ${cubicCoeffA}) * onePlusAbsS + 8 * ${cubicCoeffA}) * onePlusAbsS - 4 * ${cubicCoeffA};
    coeffs[1] = ((${cubicCoeffA} + 2) * absS - (${cubicCoeffA} + 3)) * absS * absS + 1;
    coeffs[2] = ((${cubicCoeffA} + 2) * oneMinusAbsS - (${cubicCoeffA} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${cubicCoeffA} * twoMinusAbsS - 5 * ${cubicCoeffA}) * twoMinusAbsS + 8 * ${cubicCoeffA}) * twoMinusAbsS - 4 * ${cubicCoeffA};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${dType}, 4>, coefs: array<${dType}, 4>) -> ${dType} {
    var coefsSum: ${dType} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${output.type.indices}) -> ${dType} {
    var input_indices: ${input.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `;
    };
    trilinearInterpolation = (input, output, inputShape, useExtrapolation, extrapolationValue) => {
      const isNchw = true;
      const [batchIdx, depthIdx, heightIdx, widthIdx, channelIdx] = inputShape.length === 3 ? [-1, 0, 1, 2, -1] : isNchw ? [0, 2, 3, 4, 1] : [0, 1, 2, 3, 4];
      const dType = input.type.value;
      return `
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${dType} {
      var input_indices: ${input.type.indices};
      ${input.indicesSet("input_indices", depthIdx, `max(0, min(depth, ${inputShape[depthIdx]} - 1))`)};
      ${input.indicesSet("input_indices", heightIdx, `max(0, min(height, ${inputShape[heightIdx]} - 1))`)};
      ${input.indicesSet("input_indices", widthIdx, `max(0, min(width, ${inputShape[widthIdx]} - 1))`)};
      ${setChannelAndBatchIndices(input, channelIdx, batchIdx, 3)}
      return ${input.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${output.type.indices}) -> ${dType} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${dType} = originalIndices[${depthIdx}];
      var height:${dType} = originalIndices[${heightIdx}];
      var width:${dType} = originalIndices[${widthIdx}];
      ${useExtrapolation ? `if (depth < 0 || depth > (${inputShape[depthIdx]} - 1) || height < 0 || height > (${inputShape[heightIdx]} - 1) || width < 0 || (width > ${inputShape[widthIdx]} - 1)) {
      return ${extrapolationValue};
        }` : ""};

    depth = max(0, min(depth, ${inputShape[depthIdx]} - 1));
      height = max(0, min(height, ${inputShape[heightIdx]} - 1));
      width = max(0, min(width, ${inputShape[widthIdx]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${inputShape.length > 3 ? `u32(originalIndices[${channelIdx}])` : "0"};
      var batch: u32 =  ${inputShape.length > 3 ? `u32(originalIndices[${batchIdx}])` : "0"};

      var x111: ${dType} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${dType} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${dType} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${dType} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${dType} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${dType} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${dType} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${dType} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${dType} = abs(depth - ${dType}(depth1));
      var dx2: ${dType} = abs(${dType}(depth2) - depth);
      var dy1: ${dType} = abs(height - ${dType}(height1));
      var dy2: ${dType} = abs(${dType}(height2) - height);
      var dz1: ${dType} = abs(width - ${dType}(width1));
      var dz2: ${dType} = abs(${dType}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`;
    };
    createResizeProgramInfo = (inputTensor, attributes, opsetVersion, scalesInput, sizes, roiInput) => {
      const inputShape = inputTensor.dims;
      const roi = updateRoI(roiInput, attributes.axes, inputShape.length);
      let outputShape = initOutputShape(inputShape, scalesInput, sizes, attributes.axes);
      let scales = scalesInput.slice();
      if (scalesInput.length === 0) {
        scales = inputShape.map((value, index) => value === 0 ? 1 : outputShape[index] / value);
        if (attributes.keepAspectRatioPolicy !== "stretch") {
          outputShape = adjustOutputShape(inputShape, scales, attributes);
        }
      }
      const output = outputVariable("output", inputTensor.dataType, outputShape.length);
      const input = inputVariable("input", inputTensor.dataType, inputShape.length);
      const outputSize = ShapeUtil.size(outputShape);
      const noScale = inputShape.length === outputShape.length && inputShape.every((d, i) => d === outputShape[i]);
      const useExtrapolation = attributes.coordinateTransformMode === "tf_crop_and_resize";
      const extrapolationValue = attributes.extrapolationValue;
      const dataType = input.type.value;
      const getShaderSource = (shaderHelper) => `
      ${noScale ? "" : `
      ${getOriginalCoordinateFromResizedCoordinate(attributes.coordinateTransformMode, dataType)};
      ${(() => {
        switch (attributes.mode) {
          case "nearest":
            return `
              ${checkInputIndices(input, inputShape)};
              ${getNearestPixelFromOriginal(attributes.nearestMode, opsetVersion, dataType)};
              ${calculateInputIndicesFromOutputIndices(
              input,
              output,
              inputShape,
              outputShape,
              scales.length,
              roi.length,
              useExtrapolation
            )};
              `;
          case "linear":
            return `
              ${calculateOriginalIndicesFromOutputIndices(output, inputShape, outputShape, scales.length, roi.length)};
              ${(() => {
              if (inputShape.length === 2 || inputShape.length === 4) {
                return `${bilinearInterpolation(input, output, inputShape, useExtrapolation, extrapolationValue)}`;
              } else if (inputShape.length === 3 || inputShape.length === 5) {
                return `${trilinearInterpolation(input, output, inputShape, useExtrapolation, extrapolationValue)}`;
              } else {
                throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.");
              }
            })()};
            `;
          case "cubic":
            return `
            ${(() => {
              if (inputShape.length === 2 || inputShape.length === 4) {
                return `${bicubicInterpolation(
                  input,
                  output,
                  inputShape,
                  outputShape,
                  scales,
                  roi,
                  attributes.cubicCoeffA,
                  useExtrapolation,
                  attributes.extrapolationValue,
                  attributes.excludeOutside
                )}`;
              } else {
                throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.");
              }
            })()};
            `;
          default:
            throw Error("Invalid resize mode");
        }
      })()};
      `}
      ${shaderHelper.registerUniform("output_size", "u32").registerUniform("scales", "f32", scales.length).registerUniform("roi", "f32", roi.length).declareVariables(input, output)}
      ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${noScale ? "output[global_idx] = input[global_idx];" : `
        let output_indices = ${output.offsetToIndices("global_idx")};
        var input_indices: ${input.type.indices};
        ${(() => {
        switch (attributes.mode) {
          case "nearest":
            return `input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${input.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${attributes.extrapolationValue};
                }`;
          case "linear":
            return `output[global_idx] = ${inputShape.length === 2 || inputShape.length === 4 ? "bilinearInterpolation" : "trilinearInterpolation"}(output_indices);`;
          case "cubic":
            return "output[global_idx] = bicubicInterpolation(output_indices);";
          default:
            throw Error(`Unsupported resize mode: ${attributes.mode}`);
        }
      })()};
`}
      }`;
      return {
        name: "Resize",
        shaderCache: {
          hint: `${attributes.cacheKey}|${opsetVersion}|${scales.length > 0 ? scales : ""}|${sizes.length > 0 ? sizes : ""}|${roi.length > 0 ? roi : ""}|${noScale}|${inputShape}`,
          inputDependencies: ["rank"]
        },
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: inputTensor.dataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64
            /* workgroup size */
          ) },
          programUniforms: [
            { type: 12 /* uint32 */, data: outputSize },
            { type: 1 /* float */, data: scales },
            { type: 1 /* float */, data: roi },
            ...createTensorShapeVariables(inputShape, outputShape)
          ]
        })
      };
    };
    getOpsetVersionFromCustomDataBuffer = (context) => {
      const customDataBuffer = context.customDataBuffer;
      const customDataBuffer32 = new Uint32Array(customDataBuffer, customDataBuffer.byteOffset, 1);
      const opsetVersion = customDataBuffer32[0];
      return opsetVersion;
    };
    resize = (context, attributes) => {
      const scales = [];
      const sizes = [];
      const roi = [];
      const opsetVersion = getOpsetVersionFromCustomDataBuffer(context);
      if (attributes.antialias !== 0) {
        throw Error("Only default value (0) for Antialias attribute is supported");
      }
      validateInputs23(context.inputs, attributes, opsetVersion, scales, sizes, roi);
      context.compute(
        createResizeProgramInfo(context.inputs[0], attributes, opsetVersion, scales, sizes, roi),
        { inputs: [0] }
      );
    };
    parseResizeAttributes = (attributes) => {
      const antialias = attributes.antialias;
      const axes = attributes.axes;
      const coordinateTransformMode = attributes.coordinateTransformMode;
      const cubicCoeffA = attributes.cubicCoeffA;
      const excludeOutside = attributes.excludeOutside !== 0;
      const extrapolationValue = attributes.extrapolationValue;
      const keepAspectRatioPolicy = attributes.keepAspectRatioPolicy;
      const mode = attributes.mode;
      const nearestMode = attributes.nearestMode === "" ? "simple" : attributes.nearestMode;
      return createAttributeWithCacheKey({
        antialias,
        axes,
        coordinateTransformMode,
        cubicCoeffA,
        excludeOutside,
        extrapolationValue,
        keepAspectRatioPolicy,
        mode,
        nearestMode
      });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/rotary-embedding.ts
var validateInputs24, createRotaryEmbeddingProgramInfo, rotaryEmbedding;
var init_rotary_embedding = __esm({
  "web/lib/wasm/jsep/webgpu/ops/rotary-embedding.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs24 = (inputs, attributes) => {
      const [input, positionIds, cosCache, sinCache] = inputs;
      const { numHeads, rotaryEmbeddingDim } = attributes;
      if (input.dims.length !== 3 && input.dims.length !== 4) {
        throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${input.dims.length}`);
      }
      if (!ShapeUtil.areEqual(positionIds.dims, []) && !ShapeUtil.areEqual(positionIds.dims, [1]) && positionIds.dims.length !== 2) {
        throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${positionIds.dims.length}`);
      }
      if (cosCache.dims.length !== 2) {
        throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${cosCache.dims.length}`);
      }
      if (sinCache.dims.length !== 2) {
        throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${sinCache.dims.length}`);
      }
      if (!ShapeUtil.areEqual(cosCache.dims, sinCache.dims)) {
        throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");
      }
      if (rotaryEmbeddingDim > 0 && numHeads === 0) {
        throw new Error("num_heads must be provided if rotary_embedding_dim is specified");
      }
      const batchSize = input.dims[0];
      const sequenceLength = input.dims[input.dims.length - 2];
      const maxSequenceLength = cosCache.dims[0];
      const hiddenSize = ShapeUtil.sizeFromDimension(input.dims, 1) / sequenceLength;
      const headSize = rotaryEmbeddingDim === 0 ? cosCache.dims[1] * 2 : hiddenSize / numHeads;
      if (rotaryEmbeddingDim > headSize) {
        throw new Error("rotary_embedding_dim must be less than or equal to head_size");
      }
      if (positionIds.dims.length === 2) {
        if (batchSize !== positionIds.dims[0]) {
          throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${positionIds.dims[0]}`);
        }
        if (sequenceLength !== positionIds.dims[1]) {
          throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${positionIds.dims[1]}`);
        }
      }
      if (headSize / 2 !== cosCache.dims[1] && rotaryEmbeddingDim / 2 !== cosCache.dims[1]) {
        throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${cosCache.dims[1]}`);
      }
      if (sequenceLength > maxSequenceLength) {
        throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported");
      }
    };
    createRotaryEmbeddingProgramInfo = (inputs, attributes) => {
      const { interleaved, numHeads, rotaryEmbeddingDim, scale } = attributes;
      const batchSize = inputs[0].dims[0];
      const batchStride = ShapeUtil.sizeFromDimension(inputs[0].dims, 1);
      const sequenceLength = inputs[0].dims[inputs[0].dims.length - 2];
      const hiddenSize = batchStride / sequenceLength;
      const halfRotaryEmbeddingDim = inputs[2].dims[1];
      const headSize = rotaryEmbeddingDim === 0 ? halfRotaryEmbeddingDim * 2 : hiddenSize / numHeads;
      const globalShape = new Array(batchSize, sequenceLength, hiddenSize / headSize, headSize - halfRotaryEmbeddingDim);
      const globalStrides = ShapeUtil.computeStrides(globalShape);
      const programUniforms = [
        { type: 1 /* float */, data: scale },
        { type: 12 /* uint32 */, data: globalShape },
        { type: 12 /* uint32 */, data: globalStrides },
        // strides for addressing the input/output tensor, in permutated order to align with the unfolded global index,
        // i.e. BSNH
        ...inputs[0].dims.length === 3 ? new Array({ type: 12 /* uint32 */, data: [batchStride, hiddenSize, headSize, 1] }) : [],
        ...inputs[0].dims.length === 4 ? new Array(
          { type: 12 /* uint32 */, data: [batchStride, headSize, sequenceLength * headSize, 1] }
        ) : [],
        ...createTensorShapeVariables(inputs[0].dims, inputs[1].dims, inputs[2].dims, inputs[3].dims, inputs[0].dims)
      ];
      const getShaderSource = (shaderHelper) => {
        const input = inputVariable("input", inputs[0].dataType, inputs[0].dims.length);
        const positionIds = inputVariable("position_ids", inputs[1].dataType, inputs[1].dims.length);
        const cosCache = inputVariable("cos_cache", inputs[2].dataType, inputs[2].dims.length);
        const sinCache = inputVariable("sin_cache", inputs[3].dataType, inputs[3].dims.length);
        const output = outputVariable("output", inputs[0].dataType, inputs[0].dims.length);
        shaderHelper.registerUniforms([
          { name: "scale", type: "f32" },
          { name: "global_shape", type: "u32", length: globalShape.length },
          { name: "global_strides", type: "u32", length: globalStrides.length },
          { name: "input_output_strides", type: "u32", length: globalStrides.length }
        ]);
        return `
        ${shaderHelper.declareVariables(input, positionIds, cosCache, sinCache, output)}

        ${shaderHelper.mainStart(WORKGROUP_SIZE)}
          let half_rotary_emb_dim = uniforms.${cosCache.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${positionIds.broadcastedIndicesToOffset("bsnh.xy", outputVariable("", positionIds.type.tensor, 2))};
            let position_id =
                u32(${positionIds.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${interleaved});
            let j = i + select(half_rotary_emb_dim, 1, ${interleaved});
            let re = ${input.getByOffset("i")} * ${cosCache.get("position_id", "bsnh[3]")} -
                ${input.getByOffset("j")} * ${sinCache.get("position_id", "bsnh[3]")};
            ${output.setByOffset("i", "re")}
            let im = ${input.getByOffset("i")} * ${sinCache.get("position_id", "bsnh[3]")} +
                ${input.getByOffset("j")} * ${cosCache.get("position_id", "bsnh[3]")};
            ${output.setByOffset("j", "im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${output.setByOffset("k", input.getByOffset("k"))}
          }
        }`;
      };
      return {
        name: "RotaryEmbedding",
        shaderCache: {
          hint: createAttributeWithCacheKey({
            interleaved
          }).cacheKey,
          inputDependencies: ["rank", "rank", "rank", "rank"]
        },
        getShaderSource,
        getRunData: () => ({
          outputs: [{ dims: inputs[0].dims, dataType: inputs[0].dataType }],
          dispatchGroup: { x: Math.ceil(ShapeUtil.size(globalShape) / WORKGROUP_SIZE) },
          programUniforms
        })
      };
    };
    rotaryEmbedding = (context, attributes) => {
      validateInputs24(context.inputs, attributes);
      context.compute(createRotaryEmbeddingProgramInfo(context.inputs, attributes));
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/skip-layer-norm.ts
var validateInputs25, createSkipLayerNormProgramInfo, skipLayerNorm;
var init_skip_layer_norm = __esm({
  "web/lib/wasm/jsep/webgpu/ops/skip-layer-norm.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    validateInputs25 = (inputs) => {
      if (!inputs || inputs.length < 3) {
        throw new Error("layerNorm requires at least 3 inputs.");
      }
      const input = inputs[0];
      const skip = inputs[1];
      const gamma = inputs[2];
      if (input.dataType !== skip.dataType || input.dataType !== gamma.dataType) {
        throw new Error("All inputs must have the same data type");
      }
      if (input.dims.length !== 3 && input.dims.length !== 2) {
        throw new Error("Input must be 2D or 3D");
      }
      if (skip.dims.length !== 3 && skip.dims.length !== 2) {
        throw new Error("Skip must be 2D or 3D");
      }
      const hiddenSize = input.dims[input.dims.length - 1];
      const sequenceLength = input.dims[input.dims.length - 2];
      if (skip.dims[skip.dims.length - 1] !== hiddenSize) {
        throw new Error("Skip must have the same hidden size as input");
      }
      if (skip.dims[skip.dims.length - 2] !== sequenceLength) {
        throw new Error("Skip must have the same sequence length as input");
      }
      if (gamma.dims.length !== 1) {
        throw new Error("Gamma must be 1D");
      }
      if (gamma.dims[gamma.dims.length - 1] !== hiddenSize) {
        throw new Error("Gamma must have the same hidden size as input");
      }
      if (inputs.length > 3) {
        const beta = inputs[3];
        if (beta.dims.length !== 1) {
          throw new Error("Beta must be 1D");
        }
        if (beta.dims[beta.dims.length - 1] !== hiddenSize) {
          throw new Error("Beta must have the same hidden size as input");
        }
      }
      if (inputs.length > 4) {
        const bias = inputs[4];
        if (bias.dims.length !== 1) {
          throw new Error("Bias must be 1D");
        }
        if (bias.dims[bias.dims.length - 1] !== hiddenSize) {
          throw new Error("Bias must have the same hidden size as input");
        }
      }
    };
    createSkipLayerNormProgramInfo = (inputs, attributes, outputCount, isTraining) => {
      const simplified = attributes.simplified;
      const inputShape = inputs[0].dims;
      const inputSize = ShapeUtil.size(inputShape);
      const outputShape = inputShape;
      const outputSize = inputSize;
      const hiddenSize = inputShape.slice(-1)[0];
      const meanInvStdDevDim = isTraining ? inputShape.slice(0, -1).concat(1) : [];
      const hasBetaInput = !simplified && inputs.length > 3;
      const hasBiasInput = inputs.length > 4;
      const hasMeanOutput = isTraining && outputCount > 1;
      const hasInvStdDevOutput = isTraining && outputCount > 2;
      const hasInputSkipBiasSumOutput = outputCount > 3;
      const workgroupSize = 64;
      const components = getMaxComponents(hiddenSize);
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: components },
        { type: 12 /* uint32 */, data: hiddenSize },
        { type: 1 /* float */, data: attributes.epsilon }
      ];
      const getShaderSource = (shaderHelper) => {
        const uniformsArray = [
          { name: "output_size", type: "u32" },
          { name: "components", type: "u32" },
          { name: "hidden_size", type: "u32" },
          { name: "epsilon", type: "f32" }
        ];
        const variables = [
          inputVariable("x", inputs[0].dataType, inputs[0].dims, components),
          inputVariable("skip", inputs[1].dataType, inputs[1].dims, components),
          inputVariable("gamma", inputs[2].dataType, inputs[2].dims, components)
        ];
        if (hasBetaInput) {
          variables.push(inputVariable("beta", inputs[3].dataType, inputs[3].dims, components));
        }
        if (hasBiasInput) {
          variables.push(inputVariable("bias", inputs[4].dataType, inputs[4].dims, components));
        }
        variables.push(outputVariable("output", inputs[0].dataType, outputShape, components));
        if (hasMeanOutput) {
          variables.push(outputVariable("mean_output", 1 /* float */, meanInvStdDevDim));
        }
        if (hasInvStdDevOutput) {
          variables.push(outputVariable("inv_std_output", 1 /* float */, meanInvStdDevDim));
        }
        if (hasInputSkipBiasSumOutput) {
          variables.push(outputVariable("input_skip_bias_sum", inputs[0].dataType, outputShape, components));
        }
        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
        const vecDataType = tensorTypeToWsglStorageType(1 /* float */, components);
        return `

      ${shaderHelper.registerUniforms(uniformsArray).declareVariables(...variables)}
      var<workgroup> sum_shared : array<${vecDataType}, ${workgroupSize}>;
      var<workgroup> sum_squared_shared : array<${vecDataType}, ${workgroupSize}>;

      ${shaderHelper.mainStart([
          workgroupSize,
          1,
          1
        ])}
        let ix = local_id.x;
        let iy = global_id.x / ${workgroupSize};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${workgroupSize};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${workgroupSize - 1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${hasBiasInput ? "bias[offset1d + i]" : dataType + "(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${hasInputSkipBiasSumOutput ? "input_skip_bias_sum[offset + i] = value;" : ""}
          output[offset + i] = value;
          let f32_value = ${castToF32(dataType, components, "value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${workgroupSize};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${sumVector("sum", components)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${sumVector("square_sum", components)} / f32(uniforms.hidden_size) ${simplified ? "" : "- mean * mean"} + uniforms.epsilon);
        ${hasMeanOutput ? "mean_output[global_idx] = mean;" : ""}
        ${hasInvStdDevOutput ? "inv_std_output[global_idx] = inv_std_dev;" : ""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${simplified ? "" : `- ${dataType}(mean)`}) *
            ${dataType}(inv_std_dev) * gamma[offset1d + i]
            ${hasBetaInput ? "+ beta[offset1d + i]" : ""};
        }
      }`;
      };
      const outputs = [{ dims: outputShape, dataType: inputs[0].dataType }];
      if (outputCount > 1) {
        outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
      }
      if (outputCount > 2) {
        outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
      }
      if (outputCount > 3) {
        outputs.push({ dims: inputShape, dataType: inputs[0].dataType });
      }
      return {
        name: "SkipLayerNormalization",
        shaderCache: {
          hint: `${components};${hasMeanOutput};${hasInvStdDevOutput};${hasInputSkipBiasSumOutput}`,
          inputDependencies: inputs.map((_input, _index) => "type")
        },
        getShaderSource,
        getRunData: () => ({
          outputs,
          dispatchGroup: {
            x: Math.ceil(outputSize / hiddenSize)
          },
          programUniforms
        })
      };
    };
    skipLayerNorm = (context, attributes) => {
      const isTraining = false;
      validateInputs25(context.inputs);
      const outputs = [0];
      if (context.outputCount > 1) {
        outputs.push(isTraining ? 1 : -3);
      }
      if (context.outputCount > 2) {
        outputs.push(isTraining ? 2 : -3);
      }
      if (context.outputCount > 3) {
        outputs.push(3);
      }
      context.compute(
        createSkipLayerNormProgramInfo(context.inputs, attributes, context.outputCount, isTraining),
        { outputs }
      );
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/slice.ts
var validateInputs26, readInput, createSliceAttributesFromInputs, fixStartEndValues, calculateInputIndicesImpl, createSliceProgramInfo, slice, parseSliceAttributes;
var init_slice = __esm({
  "web/lib/wasm/jsep/webgpu/ops/slice.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs26 = (inputs, attributes) => {
      if (!inputs || inputs.length < 1) {
        throw new Error("too few inputs");
      }
      if (attributes.axes.length !== 0) {
        if (attributes.axes.length !== attributes.starts.length || attributes.axes.length !== attributes.ends.length) {
          throw new Error("axes, starts and ends must have the same length");
        }
      } else if (attributes.starts.length !== attributes.ends.length) {
        throw new Error("starts and ends must have the same length");
      }
      inputs.slice(1).forEach((_, idx) => {
        if (inputs[idx + 1].dataType !== 6 /* int32 */ && inputs[idx + 1].dataType !== 7 /* int64 */) {
          throw new Error(`Input ${idx} must be an array of int32 or int64`);
        }
      });
    };
    readInput = (inputs, idx) => {
      const input = [];
      if (inputs.length > idx) {
        if (inputs[idx].dataType === 7 /* int64 */) {
          inputs[idx].getBigInt64Array().forEach((v) => input.push(Number(v)));
        } else if (inputs[idx].dataType === 6 /* int32 */) {
          inputs[idx].getInt32Array().forEach((v) => input.push(Number(v)));
        } else {
          throw new Error(`Input ${idx} must be an array of int32 or int64`);
        }
      }
      return input;
    };
    createSliceAttributesFromInputs = (inputs, attributes) => {
      if (inputs.length > 1) {
        const starts = readInput(inputs, 1);
        const ends = readInput(inputs, 2);
        let axes = readInput(inputs, 3);
        if (axes.length === 0) {
          axes = [...Array(inputs[0].dims.length).keys()];
        }
        return createAttributeWithCacheKey({ starts, ends, axes });
      } else {
        return attributes;
      }
    };
    fixStartEndValues = (value, index, inputShape, axes, steps) => {
      let newValue = value;
      if (value < 0) {
        newValue += inputShape[axes[index]];
      }
      if (steps[index] < 0) {
        return Math.max(0, Math.min(newValue, inputShape[axes[index]] - 1));
      } else {
        return Math.max(0, Math.min(newValue, inputShape[axes[index]]));
      }
    };
    calculateInputIndicesImpl = (input, output, inputShape) => `fn calculateInputIndices(output_indices: ${output.type.indices}) -> ${input.type.indices} {
          var input_indices: ${input.type.indices};
          var carry = 0u;
          for (var i = ${inputShape.length}; i >= 0; i--) {
            let input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};
            let steps_i = ${getElementAt("uniforms.steps", "i", inputShape.length)};
            let signs_i = ${getElementAt("uniforms.signs", "i", inputShape.length)};
            let starts_i = ${getElementAt("uniforms.starts", "i", inputShape.length)};
            var output_index = ${output.indicesGet("output_indices", "i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${input.indicesSet("input_indices", "i", "input_index")};
          }
          return input_indices;
      }`;
    createSliceProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const inputSize = ShapeUtil.size(inputShape);
      const axes = attributes.axes.length > 0 ? ShapeUtil.normalizeAxes(attributes.axes, inputShape.length) : [...Array(inputShape.length).keys()];
      let steps = readInput(inputs, 4);
      steps.forEach((step) => step !== 0 || (() => {
        throw new Error("step cannot be 0");
      }));
      if (steps.length === 0) {
        steps = Array(axes.length).fill(1);
      }
      const starts = attributes.starts.map((start, i) => fixStartEndValues(start, i, inputShape, axes, steps));
      const ends = attributes.ends.map((end, i) => fixStartEndValues(end, i, inputShape, axes, steps));
      if (axes.length !== starts.length || axes.length !== ends.length) {
        throw new Error("start, ends and axes should have the same number of elements");
      }
      if (axes.length !== inputShape.length) {
        for (let i = 0; i < inputShape.length; ++i) {
          if (!axes.includes(i)) {
            starts.splice(i, 0, 0);
            ends.splice(i, 0, inputShape[i]);
            steps.splice(i, 0, 1);
          }
        }
      }
      const signs = steps.map((step) => Math.sign(step));
      steps.forEach((step, i, array) => {
        if (step < 0) {
          const numSteps = (ends[i] - starts[i]) / step;
          const newEnd = starts[i];
          const newStart = newEnd + numSteps * steps[i];
          starts[i] = newStart;
          ends[i] = newEnd;
          array[i] = -step;
        }
      });
      const outputShape = inputShape.slice(0);
      axes.forEach((axis, _) => {
        outputShape[axis] = Math.ceil((ends[axis] - starts[axis]) / steps[axis]);
      });
      const outputTensorInfo = { dims: outputShape, dataType: inputs[0].dataType };
      const output = outputVariable("output", inputs[0].dataType, outputShape.length);
      const input = inputVariable("input", inputs[0].dataType, inputs[0].dims.length);
      const outputSize = ShapeUtil.size(outputShape);
      const uniforms = [
        { name: "outputSize", type: "u32" },
        { name: "starts", type: "u32", length: starts.length },
        { name: "signs", type: "i32", length: signs.length },
        { name: "steps", type: "u32", length: steps.length }
      ];
      const programUniforms = [
        { type: 12 /* uint32 */, data: outputSize },
        { type: 12 /* uint32 */, data: starts },
        { type: 6 /* int32 */, data: signs },
        { type: 12 /* uint32 */, data: steps },
        ...createTensorShapeVariables(inputs[0].dims, outputShape)
      ];
      const getShaderSource = (shaderHelper) => `
      ${shaderHelper.registerUniforms(uniforms).declareVariables(input, output)}
        ${calculateInputIndicesImpl(input, output, inputShape)}
        ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${output.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${output.setByOffset("global_idx", input.getByIndices("input_indices"))}
      }`;
      return {
        name: "Slice",
        shaderCache: { hint: `${signs.length}_${starts.length}_${steps.length}`, inputDependencies: ["rank"] },
        getShaderSource,
        getRunData: () => ({
          outputs: [outputTensorInfo],
          dispatchGroup: { x: Math.ceil(
            inputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        })
      };
    };
    slice = (context, attributes) => {
      validateInputs26(context.inputs, attributes);
      const updatedAttributes = createSliceAttributesFromInputs(context.inputs, attributes);
      context.compute(createSliceProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });
    };
    parseSliceAttributes = (attributes) => {
      const starts = attributes.starts;
      const ends = attributes.ends;
      const axes = attributes.axes;
      return createAttributeWithCacheKey({ starts, ends, axes });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/softmax.ts
var validateInputs27, createSoftmaxProgramInfo, softmax, parseSoftmaxAttributes;
var init_softmax = __esm({
  "web/lib/wasm/jsep/webgpu/ops/softmax.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs27 = (inputs) => {
      if (!inputs || inputs.length !== 1) {
        throw new Error("Softmax op requires 1 input.");
      }
    };
    createSoftmaxProgramInfo = (input, attributes) => {
      const shape = input.dims;
      const outputSize = ShapeUtil.size(shape);
      const WG = 64;
      let axis = attributes.axis;
      if (axis < 0) {
        axis = shape.length + axis;
      }
      if (axis < shape.length - 1) {
        throw new Error("softmax only supports last axis for now.");
      }
      const cols = shape[axis];
      const rows = outputSize / cols;
      const components = getMaxComponents(cols);
      const packedCols = cols / components;
      const maxVector = (name, components2) => {
        if (components2 === 4) {
          return `max(max(${name}.x, ${name}.y), max(${name}.z, ${name}.w))`;
        } else if (components2 === 2) {
          return `max(${name}.x, ${name}.y)`;
        } else if (components2 === 3) {
          return `max(max(${name}.x, ${name}.y), ${name}.z)`;
        }
        return name;
      };
      const x = inputVariable("x", input.dataType, input.dims, components);
      const output = outputVariable("result", input.dataType, input.dims, components);
      const valueType = x.type.value;
      const threadMaxDecl = tensorTypeToWsglStorageType(input.dataType) === "f32" ? `var threadMax = ${valueType}(-3.402823e+38f);` : `var threadMax = ${valueType}(-65504.0h);`;
      const getShaderSource = (shaderHelper) => `
      var<workgroup> rowMaxShared : ${valueType};
      var<workgroup> rowSumShared : ${valueType};
      var<workgroup> threadShared : array<${valueType}, ${WG}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${valueType} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${valueType}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${shaderHelper.registerUniform("packedCols", "i32").declareVariables(x, output)}
      ${shaderHelper.mainStart()}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${WG};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${threadMaxDecl}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${valueType}(${maxVector("threadShared[0]", components)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${valueType}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${valueType}(${sumVector("threadShared[0]", components)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`;
      return {
        name: "Softmax",
        shaderCache: { hint: `${components}`, inputDependencies: ["type"] },
        getRunData: () => ({
          outputs: [{ dims: shape, dataType: input.dataType }],
          dispatchGroup: { x: rows },
          programUniforms: [{ type: 6 /* int32 */, data: packedCols }]
        }),
        getShaderSource
      };
    };
    softmax = (context, attributes) => {
      validateInputs27(context.inputs);
      context.compute(createSoftmaxProgramInfo(context.inputs[0], attributes));
    };
    parseSoftmaxAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
  }
});

// web/lib/wasm/jsep/webgpu/ops/split.ts
var validateInputs28, createSplitAttributesFromInputs, calculateOutputIndexImpl, writeBufferDataImpl, createSplitProgramInfo, split, parseSplitAttributes;
var init_split = __esm({
  "web/lib/wasm/jsep/webgpu/ops/split.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_attribute_with_cache_key();
    init_common();
    validateInputs28 = (inputs) => {
      if (!inputs || inputs.length < 1) {
        throw new Error("too few inputs");
      }
    };
    createSplitAttributesFromInputs = (inputs, attributes) => {
      const splitSizes = [];
      let numOutputs = attributes.numOutputs;
      if (inputs[1].dims[0] > 0) {
        inputs[1].getBigInt64Array().forEach((v) => splitSizes.push(Number(v)));
        numOutputs = splitSizes.length;
      }
      return createAttributeWithCacheKey({ numOutputs, axis: attributes.axis, splitSizes });
    };
    calculateOutputIndexImpl = (numberOfTensors) => `
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${numberOfTensors}u; i += 1u ) {
    if (index < ${getElementAt("uniforms.size_in_split_axis", "i", numberOfTensors)}) {
        return i;
    }
    }
    return ${numberOfTensors}u;
}`;
    writeBufferDataImpl = (outputs) => {
      const numberOfTensors = outputs.length;
      const codeLines = [];
      for (let i = 0; i < numberOfTensors; ++i) {
        const returnSnippet = outputs[i].setByIndices("indices", "input[global_idx]");
        if (numberOfTensors === 1) {
          codeLines.push(returnSnippet);
        } else if (i === 0) {
          codeLines.push(`if (output_number == ${i}u) { ${returnSnippet} }`);
        } else if (i === numberOfTensors - 1) {
          codeLines.push(`else { ${returnSnippet} }`);
        } else {
          codeLines.push(`else if (output_number == ${i}) { ${returnSnippet} }`);
        }
      }
      return `
      fn writeBufferData(output_number: u32, indices: ${outputs[0].type.indices}, global_idx: u32) {
        ${codeLines.join("\n")}
      }`;
    };
    createSplitProgramInfo = (inputs, attributes) => {
      const inputShape = inputs[0].dims;
      const inputSize = ShapeUtil.size(inputShape);
      const dataType = inputs[0].dataType;
      const axis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);
      const outputs = new Array(attributes.numOutputs);
      const input = inputVariable("input", dataType, inputShape.length);
      const sizeInSplitAxis = new Array(attributes.numOutputs);
      const outputsTensorInfo = [];
      const outputShapes = [];
      let previousSum = 0;
      const programUniforms = [{ type: 12 /* uint32 */, data: inputSize }];
      for (let i = 0; i < attributes.numOutputs; i++) {
        previousSum += attributes.splitSizes[i];
        sizeInSplitAxis[i] = previousSum;
        const outputShape = inputShape.slice();
        outputShape[attributes.axis] = attributes.splitSizes[i];
        outputShapes.push(outputShape);
        outputs[i] = outputVariable(`output${i}`, dataType, outputShape.length);
        outputsTensorInfo.push({ dims: outputShapes[i], dataType: inputs[0].dataType });
      }
      programUniforms.push(
        { type: 12 /* uint32 */, data: sizeInSplitAxis },
        ...createTensorShapeVariables(inputShape, ...outputShapes)
      );
      const getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("input_size", "u32").registerUniform("size_in_split_axis", "u32", sizeInSplitAxis.length).declareVariables(input, ...outputs)}
  ${calculateOutputIndexImpl(sizeInSplitAxis.length)}
  ${writeBufferDataImpl(outputs)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${input.offsetToIndices("global_idx")};
    var index = ${input.indicesGet("indices", axis)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${getElementAt("uniforms.size_in_split_axis", "output_number - 1u", sizeInSplitAxis.length)};
      ${input.indicesSet("indices", axis, "index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;
      return {
        name: "Split",
        shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank"] },
        getShaderSource,
        getRunData: () => ({
          outputs: outputsTensorInfo,
          dispatchGroup: { x: Math.ceil(
            inputSize / 64
            /* workgroup size */
          ) },
          programUniforms
        })
      };
    };
    split = (context, attributes) => {
      validateInputs28(context.inputs);
      const updatedAttributes = context.inputs.length === 1 ? attributes : createSplitAttributesFromInputs(context.inputs, attributes);
      context.compute(createSplitProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });
    };
    parseSplitAttributes = (attributes) => {
      const axis = attributes.axis;
      const splitSizes = attributes.splitSizes;
      const numOutputs = attributes.numOutputs < 0 ? splitSizes.length : attributes.numOutputs;
      if (numOutputs !== splitSizes.length) {
        throw new Error("numOutputs and splitSizes lengh must be equal");
      }
      return createAttributeWithCacheKey({ axis, numOutputs, splitSizes });
    };
  }
});

// web/lib/wasm/jsep/webgpu/ops/where.ts
var createWhereOpProgramShader, createWhereOpProgramInfo, where;
var init_where = __esm({
  "web/lib/wasm/jsep/webgpu/ops/where.ts"() {
    "use strict";
    init_wasm_common();
    init_util();
    init_common();
    createWhereOpProgramShader = (shaderHelper, inputs, dimsOutput, isBroadcast, typeOutput) => {
      const output = outputVariable("output_data", typeOutput, dimsOutput.length, 4);
      const a = inputVariable("a_data", inputs[1].dataType, inputs[1].dims.length, 4);
      const b = inputVariable("b_data", inputs[2].dataType, inputs[2].dims.length, 4);
      const c = inputVariable("c_data", inputs[0].dataType, inputs[0].dims.length, 4);
      let assignment;
      const expression = (a2, b2, c2) => `select(${b2}, ${a2}, ${c2})`;
      if (!isBroadcast) {
        assignment = output.setByOffset(
          "global_idx",
          expression(a.getByOffset("global_idx"), b.getByOffset("global_idx"), c.getByOffset("global_idx"))
        );
      } else {
        const singleAssignment = (resStr, x, typeCast = "") => {
          const expressionA = `a_data[index_a${x}][component_a${x}]`;
          const expressionB = `b_data[index_b${x}][component_b${x}]`;
          const expressionC = `bool(c_data[index_c${x}] & (0xffu << (component_c${x} * 8)))`;
          return `
            let output_indices${x} = ${output.offsetToIndices(`global_idx * 4u + ${x}u`)};
            let offset_a${x} = ${a.broadcastedIndicesToOffset(`output_indices${x}`, output)};
            let offset_b${x} = ${b.broadcastedIndicesToOffset(`output_indices${x}`, output)};
            let offset_c${x} = ${c.broadcastedIndicesToOffset(`output_indices${x}`, output)};
            let index_a${x} = offset_a${x} / 4u;
            let index_b${x} = offset_b${x} / 4u;
            let index_c${x} = offset_c${x} / 4u;
            let component_a${x} = offset_a${x} % 4u;
            let component_b${x} = offset_b${x} % 4u;
            let component_c${x} = offset_c${x} % 4u;
            ${resStr}[${x}] = ${typeCast}(${expression(expressionA, expressionB, expressionC)});
          `;
        };
        if (typeOutput === 9 /* bool */) {
          assignment = `
            var data = vec4<u32>(0);
            ${singleAssignment("data", 0, "u32")}
            ${singleAssignment("data", 1, "u32")}
            ${singleAssignment("data", 2, "u32")}
            ${singleAssignment("data", 3, "u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`;
        } else {
          assignment = `
            ${singleAssignment("output_data[global_idx]", 0)}
            ${singleAssignment("output_data[global_idx]", 1)}
            ${singleAssignment("output_data[global_idx]", 2)}
            ${singleAssignment("output_data[global_idx]", 3)}
          `;
        }
      }
      return `
        ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(c, a, b, output)}
        ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${assignment}
      }`;
    };
    createWhereOpProgramInfo = (inputs) => {
      const dimsA = inputs[1].dims;
      const dimsB = inputs[2].dims;
      const dimsC = inputs[0].dims;
      const outputDataType = inputs[1].dataType;
      const isBroadcast = !(ShapeUtil.areEqual(dimsA, dimsB) && ShapeUtil.areEqual(dimsB, dimsC));
      let outputShape = dimsA;
      let outputSize = ShapeUtil.size(dimsA);
      if (isBroadcast) {
        const calculatedShape = BroadcastUtil.calcShape(BroadcastUtil.calcShape(dimsA, dimsB, false), dimsC, false);
        if (!calculatedShape) {
          throw new Error("Can't perform where op on the given tensors");
        }
        outputShape = calculatedShape;
        outputSize = ShapeUtil.size(outputShape);
      }
      const vecSize = Math.ceil(outputSize / 4);
      return {
        name: "Where",
        shaderCache: { inputDependencies: ["rank", "rank", "rank"] },
        getShaderSource: (shaderHelper) => createWhereOpProgramShader(shaderHelper, inputs, outputShape, isBroadcast, outputDataType),
        getRunData: () => ({
          outputs: [{ dims: outputShape, dataType: outputDataType }],
          dispatchGroup: { x: Math.ceil(
            outputSize / 64 / 4
            /* vec size */
          ) },
          programUniforms: [{ type: 12 /* uint32 */, data: vecSize }, ...createTensorShapeVariables(dimsC, dimsA, dimsB, outputShape)]
        })
      };
    };
    where = (context) => {
      context.compute(createWhereOpProgramInfo(context.inputs));
    };
  }
});

// web/lib/wasm/jsep/webgpu/op-resolve-rules.ts
var WEBGPU_OP_RESOLVE_RULES;
var init_op_resolve_rules = __esm({
  "web/lib/wasm/jsep/webgpu/op-resolve-rules.ts"() {
    "use strict";
    init_argminmax();
    init_attention();
    init_batch_norm();
    init_bias_add();
    init_bias_split_gelu();
    init_binary_op();
    init_concat();
    init_conv();
    init_conv_transpose();
    init_cumsum();
    init_depth_to_space();
    init_einsum();
    init_expand();
    init_fast_gelu();
    init_gather();
    init_gather_elements();
    init_gemm();
    init_group_query_attention();
    init_instance_norm();
    init_layer_norm();
    init_matmul();
    init_matmulnbits();
    init_multihead_attention();
    init_pad();
    init_pool();
    init_range();
    init_reduce();
    init_resize();
    init_rotary_embedding();
    init_skip_layer_norm();
    init_slice();
    init_softmax();
    init_split();
    init_tile();
    init_transpose();
    init_unary_op();
    init_where();
    WEBGPU_OP_RESOLVE_RULES = /* @__PURE__ */ new Map([
      ["Abs", [abs]],
      ["Acos", [acos]],
      ["Acosh", [acosh]],
      ["Add", [add]],
      ["ArgMax", [argMax, parseArgMinMaxAttributes]],
      ["ArgMin", [argMin, parseArgMinMaxAttributes]],
      ["Asin", [asin]],
      ["Asinh", [asinh]],
      ["Atan", [atan]],
      ["Atanh", [atanh]],
      ["Attention", [attention]],
      // TODO: support new attributes for AveragePool-10
      ["AveragePool", [averagePool, parseAveragePoolAttributes]],
      ["BatchNormalization", [batchNorm]],
      ["BiasAdd", [biasAdd]],
      ["BiasSplitGelu", [biasSplitGelu]],
      ["Cast", [cast, parseCastAttributes]],
      ["Ceil", [ceil]],
      ["Clip", [clip]],
      ["Concat", [concat, parseConcatAttributes]],
      ["Conv", [conv, parseConvAttributes]],
      ["ConvTranspose", [convTranspose, parseConvTransposeAttributes]],
      ["Cos", [cos]],
      ["Cosh", [cosh]],
      ["CumSum", [cumsum, parseCumSumAttributes]],
      ["DepthToSpace", [depthToSpace, parseDepthToSpaceAttributes]],
      ["Div", [div]],
      ["Einsum", [einsum, parseEinsumAttributes]],
      ["Elu", [elu, parseAlphaAttributes]],
      ["Equal", [equal]],
      ["Erf", [erf]],
      ["Exp", [exp]],
      ["Expand", [expand]],
      ["FastGelu", [fastGelu2]],
      ["Floor", [floor]],
      ["FusedConv", [conv, parseConvAttributes]],
      ["Gather", [gather, parseGatherAttributes]],
      ["GatherElements", [gatherElements, parseGatherElementsAttributes]],
      ["Gelu", [gelu]],
      ["Gemm", [gemm, parseGemmAttributes]],
      ["GlobalAveragePool", [globalAveragePool, parseGlobalAveragePoolAttributes]],
      ["GlobalMaxPool", [globalMaxPool, parseGlobalMaxPoolAttributes]],
      ["Greater", [greater]],
      ["GreaterOrEqual", [greaterOrEqual]],
      ["GroupQueryAttention", [groupQueryAttention, parseGroupQueryAttentionAttributes]],
      ["HardSigmoid", [hardSigmoid, parseHardSigmoidAttributes]],
      ["InstanceNormalization", [instanceNorm]],
      ["LayerNormalization", [layerNorm]],
      ["LeakyRelu", [leakyRelu, parseAlphaAttributes]],
      ["Less", [less]],
      ["LessOrEqual", [lessOrEqual]],
      ["Log", [log]],
      ["MatMul", [matMul]],
      ["MatMulNBits", [matMulNBits, parseMatMulNBitsAttributes]],
      // TODO: support new attributes for MaxPool-8 and MaxPool-10
      ["MaxPool", [maxPool, parseMaxPoolAttributes]],
      ["Mul", [mul]],
      ["MultiHeadAttention", [multiHeadAttention, parseMultiHeadAttentionAttributes]],
      ["Neg", [neg]],
      ["Not", [not]],
      ["Pad", [pad]],
      ["Pow", [pow]],
      ["Range", [range]],
      ["Reciprocal", [reciprocal]],
      ["ReduceMin", [reduceMin]],
      ["ReduceMean", [reduceMean]],
      ["ReduceMax", [reduceMax]],
      ["ReduceSum", [reduceSum]],
      ["ReduceProd", [reduceProd]],
      ["ReduceL1", [reduceL1]],
      ["ReduceL2", [reduceL2]],
      ["ReduceLogSum", [reduceLogSum]],
      ["ReduceLogSumExp", [reduceLogSumExp]],
      ["ReduceSumSquare", [reduceSumSquare]],
      ["Relu", [relu]],
      ["Resize", [resize, parseResizeAttributes]],
      ["RotaryEmbedding", [rotaryEmbedding]],
      ["Sigmoid", [sigmoid]],
      ["Sin", [sin]],
      ["Sinh", [sinh]],
      ["Slice", [slice, parseSliceAttributes]],
      ["SkipLayerNormalization", [skipLayerNorm]],
      ["Split", [split, parseSplitAttributes]],
      ["Sqrt", [sqrt]],
      ["Softmax", [softmax, parseSoftmaxAttributes]],
      ["Sub", [sub]],
      ["Tan", [tan]],
      ["Tanh", [tanh]],
      ["ThresholdedRelu", [thresholdedRelu, parseAlphaAttributes]],
      ["Tile", [tile]],
      ["Transpose", [transpose, parseTransposeAttributes]],
      ["Where", [where]]
    ]);
  }
});

// web/lib/wasm/jsep/webgpu/program-manager.ts
var ProgramManager;
var init_program_manager = __esm({
  "web/lib/wasm/jsep/webgpu/program-manager.ts"() {
    "use strict";
    init_esm();
    init_log();
    init_common();
    ProgramManager = class {
      constructor(backend) {
        this.backend = backend;
        this.repo = /* @__PURE__ */ new Map();
        this.attributesBound = false;
      }
      getArtifact(key) {
        return this.repo.get(key);
      }
      setArtifact(key, artifact) {
        this.repo.set(key, artifact);
      }
      run(buildArtifact, inputs, outputs, dispatchGroup, uniformBufferBinding) {
        TRACE_FUNC_BEGIN(buildArtifact.programInfo.name);
        const device = this.backend.device;
        const computePassEncoder = this.backend.getComputePassEncoder();
        this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2);
        const entries = [];
        for (const input of inputs) {
          entries.push({ binding: entries.length, resource: { buffer: input.buffer } });
        }
        for (const output of outputs) {
          entries.push({ binding: entries.length, resource: { buffer: output.buffer } });
        }
        if (uniformBufferBinding) {
          entries.push({ binding: entries.length, resource: uniformBufferBinding });
        }
        const bindGroup = device.createBindGroup(
          { layout: buildArtifact.computePipeline.getBindGroupLayout(0), entries, label: buildArtifact.programInfo.name }
        );
        if (this.backend.sessionStatus === "capturing") {
          const commandInfo = {
            kernelId: this.backend.currentKernelId,
            computePipeline: buildArtifact.computePipeline,
            bindGroup,
            dispatchGroup
          };
          const sessionCommandList = this.backend.capturedCommandList.get(this.backend.currentSessionId);
          sessionCommandList.push(commandInfo);
        }
        computePassEncoder.setPipeline(buildArtifact.computePipeline);
        computePassEncoder.setBindGroup(0, bindGroup);
        computePassEncoder.dispatchWorkgroups(...dispatchGroup);
        this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2 + 1);
        this.backend.pendingDispatchNumber++;
        if (this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber || this.backend.queryType === "at-passes") {
          this.backend.endComputePass();
        }
        if (this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber) {
          this.backend.flush();
        }
        TRACE_FUNC_END(buildArtifact.programInfo.name);
      }
      dispose() {
      }
      build(programInfo, normalizedDispatchGroupSize) {
        TRACE_FUNC_BEGIN(programInfo.name);
        const device = this.backend.device;
        const extensions = [];
        if (device.features.has("shader-f16")) {
          extensions.push("enable f16;");
        }
        const shaderHelper = createShaderHelper(normalizedDispatchGroupSize, this.backend.device.limits);
        const userCode = programInfo.getShaderSource(shaderHelper);
        const code = `${extensions.join("\n")}
${shaderHelper.additionalImplementations}
${userCode}`;
        const shaderModule = device.createShaderModule({ code, label: programInfo.name });
        LOG_DEBUG("verbose", () => `[WebGPU] ${programInfo.name} shader code: ${code}`);
        const computePipeline = device.createComputePipeline(
          { compute: { module: shaderModule, entryPoint: "main" }, layout: "auto", label: programInfo.name }
        );
        TRACE_FUNC_END(programInfo.name);
        return { programInfo, computePipeline, uniformVariablesInfo: shaderHelper.variablesInfo };
      }
      normalizeDispatchGroupSize(dispatchGroup) {
        const x = typeof dispatchGroup === "number" ? dispatchGroup : dispatchGroup.x;
        const y = typeof dispatchGroup === "number" ? 1 : dispatchGroup.y || 1;
        const z = typeof dispatchGroup === "number" ? 1 : dispatchGroup.z || 1;
        const limitPerDimension = this.backend.device.limits.maxComputeWorkgroupsPerDimension;
        if (x <= limitPerDimension && y <= limitPerDimension && z <= limitPerDimension) {
          return [x, y, z];
        }
        const size = x * y * z;
        let dispatchAverage = Math.ceil(Math.sqrt(size));
        if (dispatchAverage > limitPerDimension) {
          dispatchAverage = Math.ceil(Math.cbrt(size));
          if (dispatchAverage > limitPerDimension) {
            throw new Error("Total dispatch size exceeds WebGPU maximum.");
          }
          return [dispatchAverage, dispatchAverage, dispatchAverage];
        } else {
          return [dispatchAverage, dispatchAverage, 1];
        }
      }
    };
  }
});

// web/lib/wasm/jsep/backend-webgpu.ts
var getProgramInputTensorInfoDependencyKey, getProgramInfoUniqueKey, AdapterInfoImpl, WebGpuBackend;
var init_backend_webgpu = __esm({
  "web/lib/wasm/jsep/backend-webgpu.ts"() {
    "use strict";
    init_esm();
    init_wasm_common();
    init_log();
    init_tensor_view();
    init_gpu_data_manager();
    init_op_resolve_rules();
    init_program_manager();
    getProgramInputTensorInfoDependencyKey = (inputTensors, inputDependencies) => {
      if (inputDependencies.length !== inputTensors.length) {
        throw new Error(`inputDependencies length ${inputDependencies.length} is not equal to inputTensors length ${inputTensors.length}.`);
      }
      const inputInfos = [];
      for (let i = 0; i < inputTensors.length; ++i) {
        const type = inputTensors[i].dataType;
        switch (inputDependencies[i]) {
          case "none": {
            inputInfos.push("");
            break;
          }
          case "type": {
            inputInfos.push(`${type}`);
            break;
          }
          case "rank": {
            const rank = inputTensors[i].dims.length;
            inputInfos.push(`${type};${rank}`);
            break;
          }
          case "dims": {
            const dims = inputTensors[i].dims.join(",");
            inputInfos.push(`${type};${dims}`);
            break;
          }
          default:
            throw new Error(`unsupported input dependency: ${inputDependencies[i]}`);
        }
      }
      return inputInfos.join("|");
    };
    getProgramInfoUniqueKey = (programInfo, inputTensors, is1DimensionDispatch) => {
      let key = programInfo.name;
      if (programInfo.shaderCache?.hint) {
        key += "[" + programInfo.shaderCache.hint + "]";
      }
      key += ":" + is1DimensionDispatch + `:${getProgramInputTensorInfoDependencyKey(
        inputTensors,
        programInfo.shaderCache?.inputDependencies ?? new Array(inputTensors.length).fill("dims")
      )}`;
      return key;
    };
    AdapterInfoImpl = class {
      constructor(adapterInfo) {
        if (adapterInfo) {
          this.architecture = adapterInfo.architecture;
          this.vendor = adapterInfo.vendor;
        }
      }
      isArchitecture(architecture) {
        return this.architecture === architecture;
      }
      isVendor(vendor) {
        return this.vendor === vendor;
      }
    };
    WebGpuBackend = class {
      constructor() {
        /**
         * representing the session ID of which is currently being run.
         * `null` means no session is being run.
         * only valid when session.run is executed.
         */
        this.currentSessionId = null;
        /**
         * representing the kernel ID of which is currently being computed (CPU code perspective).
         * `null` means no kernel is being computed.
         * only one kernel can be computed at a moment.
         */
        this.currentKernelId = null;
        this.commandEncoder = null;
        this.computePassEncoder = null;
        this.maxDispatchNumber = 16;
        this.pendingDispatchNumber = 0;
        // info of kernels pending submission for a single batch
        this.pendingKernels = [];
        // queryReadBuffer -> pendingKernels mapping for all the batches
        this.pendingQueries = /* @__PURE__ */ new Map();
        this.sessionStatus = "default";
        /**
         * a SessionID -> CommandInfo[] mapping. It's used to record all GPU commands for corresponding session.
         */
        this.capturedCommandList = /* @__PURE__ */ new Map();
        /**
         * a SessionID -> PendingKernelInfo[] mapping for profiling.
         */
        this.capturedPendingKernels = /* @__PURE__ */ new Map();
        /**
         * a SessionID -> a Map of (InputOutputIndex -> [ID, GPUBuffer]) mapping.
         */
        this.sessionExternalDataMapping = /* @__PURE__ */ new Map();
      }
      /**
       * get the custom data of the current kernel
       */
      get currentKernelCustomData() {
        if (this.currentKernelId === null) {
          throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");
        }
        let data = this.kernelCustomData.get(this.currentKernelId);
        if (!data) {
          data = {};
          this.kernelCustomData.set(this.currentKernelId, data);
        }
        return data;
      }
      async initialize(env3, adapter) {
        this.env = env3;
        const requiredFeatures = [];
        const deviceDescriptor = {
          requiredLimits: {
            maxComputeWorkgroupStorageSize: adapter.limits.maxComputeWorkgroupStorageSize,
            maxComputeWorkgroupsPerDimension: adapter.limits.maxComputeWorkgroupsPerDimension,
            maxStorageBufferBindingSize: adapter.limits.maxStorageBufferBindingSize,
            maxBufferSize: adapter.limits.maxBufferSize,
            maxComputeInvocationsPerWorkgroup: adapter.limits.maxComputeInvocationsPerWorkgroup,
            maxComputeWorkgroupSizeX: adapter.limits.maxComputeWorkgroupSizeX,
            maxComputeWorkgroupSizeY: adapter.limits.maxComputeWorkgroupSizeY,
            maxComputeWorkgroupSizeZ: adapter.limits.maxComputeWorkgroupSizeZ
          },
          requiredFeatures
        };
        if (adapter.features.has("chromium-experimental-timestamp-query-inside-passes")) {
          requiredFeatures.push("chromium-experimental-timestamp-query-inside-passes");
        } else if (adapter.features.has("timestamp-query")) {
          requiredFeatures.push("timestamp-query");
        }
        if (adapter.features.has("shader-f16")) {
          requiredFeatures.push("shader-f16");
        }
        this.device = await adapter.requestDevice(deviceDescriptor);
        this.adapterInfo = new AdapterInfoImpl(await adapter.requestAdapterInfo());
        this.gpuDataManager = createGpuDataManager(this);
        this.programManager = new ProgramManager(this);
        this.kernels = /* @__PURE__ */ new Map();
        this.kernelPersistentData = /* @__PURE__ */ new Map();
        this.kernelCustomData = /* @__PURE__ */ new Map();
        configureLogger(env3.logLevel, !!env3.debug);
        this.device.onuncapturederror = (ev) => {
          if (ev.error instanceof GPUValidationError) {
            console.error(`An uncaught WebGPU validation error was raised: ${ev.error.message}`);
          }
        };
        Object.defineProperty(
          this.env.webgpu,
          "device",
          { value: this.device, writable: false, enumerable: true, configurable: false }
        );
        Object.defineProperty(
          this.env.webgpu,
          "adapter",
          { value: adapter, writable: false, enumerable: true, configurable: false }
        );
        this.setQueryType();
      }
      dispose() {
        if (typeof this.querySet !== "undefined") {
          this.querySet.destroy();
        }
        this.gpuDataManager.dispose();
      }
      getCommandEncoder() {
        if (!this.commandEncoder) {
          this.commandEncoder = this.device.createCommandEncoder();
        }
        return this.commandEncoder;
      }
      getComputePassEncoder() {
        if (!this.computePassEncoder) {
          const commandEncoder = this.getCommandEncoder();
          const computePassDescriptor = {};
          if (this.queryType === "at-passes") {
            computePassDescriptor.timestampWrites = {
              querySet: this.querySet,
              beginningOfPassWriteIndex: this.pendingDispatchNumber * 2,
              endOfPassWriteIndex: this.pendingDispatchNumber * 2 + 1
            };
          }
          this.computePassEncoder = commandEncoder.beginComputePass(computePassDescriptor);
        }
        return this.computePassEncoder;
      }
      endComputePass() {
        if (this.computePassEncoder) {
          this.computePassEncoder.end();
          this.computePassEncoder = null;
        }
      }
      flush() {
        if (!this.commandEncoder) {
          return;
        }
        TRACE_FUNC_BEGIN();
        this.endComputePass();
        let queryReadBuffer;
        if (this.queryType !== "none") {
          this.commandEncoder.resolveQuerySet(
            this.querySet,
            0,
            this.pendingDispatchNumber * 2,
            this.queryResolveBuffer,
            0
          );
          queryReadBuffer = this.device.createBuffer(
            // eslint-disable-next-line no-bitwise
            { size: this.pendingDispatchNumber * 2 * 8, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST }
          );
          this.pendingQueries.set(queryReadBuffer, this.pendingKernels);
          this.pendingKernels = [];
          this.commandEncoder.copyBufferToBuffer(
            this.queryResolveBuffer,
            0,
            queryReadBuffer,
            0,
            this.pendingDispatchNumber * 2 * 8
          );
        }
        this.device.queue.submit([this.commandEncoder.finish()]);
        this.gpuDataManager.refreshPendingBuffers();
        this.commandEncoder = null;
        this.pendingDispatchNumber = 0;
        if (this.queryType !== "none") {
          void queryReadBuffer.mapAsync(GPUMapMode.READ).then(() => {
            const mappedData = new BigUint64Array(queryReadBuffer.getMappedRange());
            const pendingKernels = this.pendingQueries.get(queryReadBuffer);
            for (let i = 0; i < mappedData.length / 2; i++) {
              const pendingKernelInfo = pendingKernels[i];
              const kernelId = pendingKernelInfo.kernelId;
              const kernelInfo = this.kernels.get(kernelId);
              const kernelType = kernelInfo.kernelType;
              const kernelName = kernelInfo.kernelName;
              const programName = pendingKernelInfo.programName;
              const inputTensorViews = pendingKernelInfo.inputTensorViews;
              const outputTensorViews = pendingKernelInfo.outputTensorViews;
              const startTimeU64 = mappedData[i * 2];
              const endTimeU64 = mappedData[i * 2 + 1];
              if (typeof this.queryTimeBase === "undefined") {
                this.queryTimeBase = startTimeU64;
              }
              const startTime = Number(startTimeU64 - this.queryTimeBase);
              const endTime = Number(endTimeU64 - this.queryTimeBase);
              if (!Number.isSafeInteger(startTime) || !Number.isSafeInteger(endTime)) {
                throw new RangeError("incorrect timestamp range");
              }
              if (this.env.webgpu.profiling?.ondata) {
                this.env.webgpu.profiling.ondata({
                  version: 1,
                  inputsMetadata: inputTensorViews.map(
                    (value) => ({ dims: value.dims, dataType: tensorDataTypeEnumToString(value.dataType) })
                  ),
                  outputsMetadata: outputTensorViews.map(
                    (value) => ({ dims: value.dims, dataType: tensorDataTypeEnumToString(value.dataType) })
                  ),
                  kernelId,
                  kernelType,
                  kernelName,
                  programName,
                  startTime,
                  endTime
                });
              } else {
                let inputShapes = "";
                inputTensorViews.forEach((value, i2) => {
                  inputShapes += `input[${i2}]: [${value.dims}] | ${tensorDataTypeEnumToString(value.dataType)}, `;
                });
                let outputShapes = "";
                outputTensorViews.forEach((value, i2) => {
                  outputShapes += `output[${i2}]: [${value.dims}] | ${tensorDataTypeEnumToString(value.dataType)}, `;
                });
                console.log(`[profiling] kernel "${kernelId}|${kernelType}|${kernelName}|${programName}" ${inputShapes}${outputShapes}execution time: ${endTime - startTime} ns`);
              }
              TRACE("GPU", `${programName}::${startTimeU64}::${endTimeU64}`);
            }
            queryReadBuffer.unmap();
            this.pendingQueries.delete(queryReadBuffer);
          });
        }
        TRACE_FUNC_END();
      }
      /**
       * run a WebGPU program.
       * @param program a ProgramInfo instance
       * @param inputTensorViews a TensorView array. each element represents a value already exists in GPU.
       * @param outputIndices an indices array. each element can be either -1 (temporary data), -2 (persistent data) or an
       * index to the kernel's output.
       * @param createKernelOutput a callback function that create a value to kernel's output with the given index
       * @param createIntermediateOutput a callback function that create a value as a intermediate value, either temporary
       * or persistent (owned by the current kernel)
       * @returns a TensorView array representing the result.
       */
      run(program, inputTensorViews, outputIndices, createKernelOutput, createIntermediateOutput, outputCount) {
        TRACE_FUNC_BEGIN(program.name);
        const inputDatas = [];
        for (let i = 0; i < inputTensorViews.length; ++i) {
          const data = inputTensorViews[i].data;
          if (data === 0) {
            continue;
          }
          const gpuData = this.gpuDataManager.get(data);
          if (!gpuData) {
            throw new Error(`no GPU data for input: ${data}`);
          }
          inputDatas.push(gpuData);
        }
        const { outputs, dispatchGroup, programUniforms } = program.getRunData(inputTensorViews);
        const validatedOutputIndices = outputIndices.length === 0 ? outputs.map((_, i) => i) : outputIndices;
        if (validatedOutputIndices.length !== outputs.length) {
          throw new Error(`Output size ${validatedOutputIndices.length} must be equal to ${outputs.length}.`);
        }
        const outputTensorViews = [];
        const outputDatas = [];
        for (let i = 0; i < outputs.length; ++i) {
          if (!Number.isInteger(validatedOutputIndices[i]) || validatedOutputIndices[i] < -3 || validatedOutputIndices[i] >= outputCount) {
            throw new Error(`Invalid output index: ${validatedOutputIndices[i]}`);
          }
          if (validatedOutputIndices[i] === -3) {
            continue;
          }
          const isTemporary = validatedOutputIndices[i] === -1;
          const isPersistent = validatedOutputIndices[i] === -2;
          const tensorView = isTemporary || isPersistent ? createIntermediateOutput(outputs[i].dataType, outputs[i].dims) : createKernelOutput(validatedOutputIndices[i], outputs[i].dataType, outputs[i].dims);
          outputTensorViews.push(tensorView);
          if (tensorView.data === 0) {
            continue;
          }
          const gpuData = this.gpuDataManager.get(tensorView.data);
          if (!gpuData) {
            throw new Error(`no GPU data for output: ${tensorView.data}`);
          }
          if (isTemporary) {
            this.temporaryData.push(gpuData);
          }
          if (isPersistent) {
            let persistentData = this.kernelPersistentData.get(this.currentKernelId);
            if (!persistentData) {
              persistentData = [];
              this.kernelPersistentData.set(this.currentKernelId, persistentData);
            }
            persistentData.push(gpuData);
          }
          outputDatas.push(gpuData);
        }
        if (inputDatas.length !== inputTensorViews.length || outputDatas.length !== outputTensorViews.length) {
          if (outputDatas.length === 0) {
            TRACE_FUNC_END(program.name);
            return outputTensorViews;
          }
          throw new Error(
            `Program ${program.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`
          );
        }
        let uniformBufferBinding;
        if (programUniforms) {
          let currentOffset = 0;
          const offsets = [];
          programUniforms.forEach((v) => {
            const data = typeof v.data === "number" ? [v.data] : v.data;
            if (data.length === 0) {
              return;
            }
            const sizeOfElement = v.type === 10 /* float16 */ ? 2 : 4;
            let sizeOfVecOrMat;
            let baseAlignment;
            if (v.type === 10 /* float16 */) {
              baseAlignment = data.length > 4 ? 16 : data.length > 2 ? 8 : data.length * sizeOfElement;
              sizeOfVecOrMat = data.length > 4 ? 16 : sizeOfElement * data.length;
            } else {
              baseAlignment = data.length <= 2 ? data.length * sizeOfElement : 16;
              sizeOfVecOrMat = 16;
            }
            currentOffset = Math.ceil(currentOffset / baseAlignment) * baseAlignment;
            offsets.push(currentOffset);
            const elementPerVecOrMat = v.type === 10 /* float16 */ ? 8 : 4;
            currentOffset += data.length > 4 ? Math.ceil(data.length / elementPerVecOrMat) * sizeOfVecOrMat : data.length * sizeOfElement;
          });
          const maxAlignmentOfField = 16;
          currentOffset = Math.ceil(currentOffset / maxAlignmentOfField) * maxAlignmentOfField;
          const arrayBuffer = new ArrayBuffer(currentOffset);
          programUniforms.forEach((v, i) => {
            const offset = offsets[i];
            const data = typeof v.data === "number" ? [v.data] : v.data;
            if (v.type === 6 /* int32 */) {
              new Int32Array(arrayBuffer, offset, data.length).set(data);
            } else if (v.type === 12 /* uint32 */) {
              new Uint32Array(arrayBuffer, offset, data.length).set(data);
            } else if (v.type === 10 /* float16 */) {
              new Uint16Array(arrayBuffer, offset, data.length).set(data);
            } else if (v.type === 1 /* float */) {
              new Float32Array(arrayBuffer, offset, data.length).set(data);
            } else {
              throw new Error(`Unsupported uniform type: ${tensorDataTypeEnumToString(v.type)}`);
            }
          });
          const uniformBufferData = (
            // eslint-disable-next-line no-bitwise
            this.gpuDataManager.create(currentOffset, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM)
          );
          this.device.queue.writeBuffer(uniformBufferData.buffer, 0, arrayBuffer, 0, currentOffset);
          this.gpuDataManager.release(uniformBufferData.id);
          uniformBufferBinding = { offset: 0, size: currentOffset, buffer: uniformBufferData.buffer };
        }
        const normalizedDispatchGroup = this.programManager.normalizeDispatchGroupSize(dispatchGroup);
        const is1DimensionDispatch = normalizedDispatchGroup[1] === 1 && normalizedDispatchGroup[2] === 1;
        const key = getProgramInfoUniqueKey(program, inputTensorViews, is1DimensionDispatch);
        let artifact = this.programManager.getArtifact(key);
        if (!artifact) {
          artifact = this.programManager.build(program, normalizedDispatchGroup);
          this.programManager.setArtifact(key, artifact);
          LOG_DEBUG("info", () => `[artifact] key: ${key}, programName: ${program.name}`);
        }
        if (programUniforms && artifact.uniformVariablesInfo) {
          if (programUniforms.length !== artifact.uniformVariablesInfo.length) {
            throw new Error(`Uniform variables count mismatch: expect ${artifact.uniformVariablesInfo.length}, got ${programUniforms.length} in program "${artifact.programInfo.name}".`);
          }
          for (let i = 0; i < programUniforms.length; i++) {
            const uniform = programUniforms[i];
            const actualType = uniform.type;
            const actualLength = typeof uniform.data === "number" ? 1 : uniform.data.length;
            const [type, length] = artifact.uniformVariablesInfo[i];
            if (actualType !== type || actualLength !== length) {
              throw new Error(`Uniform variable ${i} mismatch: expect type ${type} with size ${length}, got type ${actualType} with size ${actualLength} in program "${artifact.programInfo.name}".`);
            }
          }
        }
        LOG_DEBUG(
          "info",
          () => `[ProgramManager] run "${program.name}" (key=${key}) with ${normalizedDispatchGroup[0]}x${normalizedDispatchGroup[1]}x${normalizedDispatchGroup[2]}`
        );
        if (this.queryType !== "none" || this.sessionStatus === "capturing") {
          const pendingKernelInfo = {
            kernelId: this.currentKernelId,
            programName: artifact.programInfo.name,
            inputTensorViews,
            outputTensorViews
          };
          this.pendingKernels.push(pendingKernelInfo);
          if (this.sessionStatus === "capturing") {
            const sessionPendingKernels = this.capturedPendingKernels.get(this.currentSessionId);
            sessionPendingKernels.push(pendingKernelInfo);
          }
        }
        this.programManager.run(artifact, inputDatas, outputDatas, normalizedDispatchGroup, uniformBufferBinding);
        TRACE_FUNC_END(program.name);
        return outputTensorViews;
      }
      upload(gpuDataId, data) {
        this.gpuDataManager.upload(gpuDataId, data);
      }
      memcpy(src, dst) {
        this.gpuDataManager.memcpy(src, dst);
      }
      async download(gpuDataId, getTargetBuffer) {
        await this.gpuDataManager.download(gpuDataId, getTargetBuffer);
      }
      alloc(size) {
        return this.gpuDataManager.create(size).id;
      }
      free(ptr) {
        return this.gpuDataManager.release(ptr);
      }
      createKernel(kernelType, kernelId, attribute, kernelName) {
        const op = WEBGPU_OP_RESOLVE_RULES.get(kernelType);
        if (!op) {
          throw new Error(`kernel not implemented: ${kernelType}`);
        }
        const kernelInfo = {
          kernelType,
          kernelName,
          kernelEntry: op[0],
          attributes: [op[1], attribute]
        };
        this.kernels.set(kernelId, kernelInfo);
      }
      releaseKernel(kernelId) {
        const persistentData = this.kernelPersistentData.get(kernelId);
        if (persistentData) {
          for (const data of persistentData) {
            this.gpuDataManager.release(data.id);
          }
          this.kernelPersistentData.delete(kernelId);
        }
        this.kernelCustomData.delete(kernelId);
        this.kernels.delete(kernelId);
      }
      computeKernel(kernelId, context, errors) {
        const kernel = this.kernels.get(kernelId);
        if (!kernel) {
          throw new Error(`kernel not created: ${kernelId}`);
        }
        const kernelType = kernel.kernelType;
        const kernelName = kernel.kernelName;
        const kernelEntry = kernel.kernelEntry;
        const attributes = kernel.attributes;
        if (this.currentKernelId !== null) {
          throw new Error(`kernel "[${kernelType}] ${kernelName}" is not allowed to be called recursively`);
        }
        this.currentKernelId = kernelId;
        if (attributes[0]) {
          attributes[1] = attributes[0](attributes[1]);
          attributes[0] = void 0;
        }
        LOG_DEBUG("info", () => `[WebGPU] Start to run kernel "[${kernelType}] ${kernelName}"...`);
        const useErrorScope = this.env.debug;
        this.temporaryData = [];
        try {
          if (useErrorScope) {
            this.device.pushErrorScope("validation");
          }
          kernelEntry(context, attributes[1]);
          return 0;
        } catch (e) {
          errors.push(Promise.resolve(`[WebGPU] Kernel "[${kernelType}] ${kernelName}" failed. ${e}`));
          return 1;
        } finally {
          if (useErrorScope) {
            errors.push(this.device.popErrorScope().then(
              (err) => err ? `GPU validation error for kernel "[${kernelType}] ${kernelName}": ${err.message}` : null
            ));
          }
          for (const data of this.temporaryData) {
            this.gpuDataManager.release(data.id);
          }
          this.temporaryData = [];
          this.currentKernelId = null;
        }
      }
      // #region external buffer
      registerBuffer(sessionId, index, buffer, size) {
        let sessionInputOutputMapping = this.sessionExternalDataMapping.get(sessionId);
        if (!sessionInputOutputMapping) {
          sessionInputOutputMapping = /* @__PURE__ */ new Map();
          this.sessionExternalDataMapping.set(sessionId, sessionInputOutputMapping);
        }
        const previousBuffer = sessionInputOutputMapping.get(index);
        const id = this.gpuDataManager.registerExternalBuffer(buffer, size, previousBuffer?.[1]);
        sessionInputOutputMapping.set(index, [id, buffer]);
        return id;
      }
      unregisterBuffers(sessionId) {
        const sessionInputOutputMapping = this.sessionExternalDataMapping.get(sessionId);
        if (sessionInputOutputMapping) {
          sessionInputOutputMapping.forEach((bufferInfo) => this.gpuDataManager.unregisterExternalBuffer(bufferInfo[1]));
          this.sessionExternalDataMapping.delete(sessionId);
        }
      }
      getBuffer(gpuDataId) {
        const gpuData = this.gpuDataManager.get(gpuDataId);
        if (!gpuData) {
          throw new Error(`no GPU data for buffer: ${gpuDataId}`);
        }
        return gpuData.buffer;
      }
      createDownloader(gpuBuffer, size, type) {
        return async () => {
          const data = await downloadGpuData(this, gpuBuffer, size);
          return createView(data.buffer, type);
        };
      }
      // #endregion
      writeTimestamp(index) {
        if (this.queryType !== "inside-passes") {
          return;
        }
        this.computePassEncoder.writeTimestamp(this.querySet, index);
      }
      setQueryType() {
        this.queryType = "none";
        if (this.env.webgpu.profiling?.mode === "default" || (typeof this.env.trace === "undefined" ? this.env.wasm.trace : this.env.trace)) {
          if (this.device.features.has("chromium-experimental-timestamp-query-inside-passes")) {
            this.queryType = "inside-passes";
          } else if (this.device.features.has("timestamp-query")) {
            this.queryType = "at-passes";
          }
          if (this.queryType !== "none" && typeof this.querySet === "undefined") {
            this.querySet = this.device.createQuerySet({
              type: "timestamp",
              count: this.maxDispatchNumber * 2
            });
            this.queryResolveBuffer = this.device.createBuffer(
              // eslint-disable-next-line no-bitwise
              { size: this.maxDispatchNumber * 2 * 8, usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE }
            );
          }
        }
      }
      captureBegin() {
        LOG_DEBUG("info", "captureBegin");
        if (!this.capturedCommandList.get(this.currentSessionId)) {
          this.capturedCommandList.set(this.currentSessionId, []);
        }
        if (!this.capturedPendingKernels.get(this.currentSessionId)) {
          this.capturedPendingKernels.set(this.currentSessionId, []);
        }
        this.flush();
        this.sessionStatus = "capturing";
      }
      captureEnd() {
        LOG_DEBUG("info", "captureEnd");
        this.flush();
        this.sessionStatus = "default";
      }
      replay() {
        LOG_DEBUG("info", "replay");
        this.sessionStatus = "replaying";
        const sessionCommandList = this.capturedCommandList.get(this.currentSessionId);
        const sessionPendingKernels = this.capturedPendingKernels.get(this.currentSessionId);
        const length = sessionCommandList.length;
        this.pendingKernels = [];
        for (let i = 0; i < length; i++) {
          const computePassEncoder = this.getComputePassEncoder();
          const command = sessionCommandList[i];
          this.writeTimestamp(this.pendingDispatchNumber * 2);
          computePassEncoder.setPipeline(command.computePipeline);
          computePassEncoder.setBindGroup(0, command.bindGroup);
          computePassEncoder.dispatchWorkgroups(...command.dispatchGroup);
          this.writeTimestamp(this.pendingDispatchNumber * 2 + 1);
          this.pendingDispatchNumber++;
          if (this.queryType !== "none") {
            this.pendingKernels.push(sessionPendingKernels[i]);
          }
          if (this.pendingDispatchNumber >= this.maxDispatchNumber || this.queryType === "at-passes") {
            this.endComputePass();
          }
          if (this.pendingDispatchNumber >= this.maxDispatchNumber) {
            this.flush();
          }
        }
        this.flush();
        this.sessionStatus = "default";
      }
      onReleaseSession(sessionId) {
        this.unregisterBuffers(sessionId);
        if (this.capturedCommandList.has(sessionId)) {
          this.capturedCommandList.delete(sessionId);
        }
        if (this.capturedPendingKernels.has(sessionId)) {
          this.capturedPendingKernels.delete(sessionId);
        }
        this.gpuDataManager.onReleaseSession(sessionId);
      }
      onRunStart(sessionId) {
        this.currentSessionId = sessionId;
        this.setQueryType();
      }
    };
  }
});

// web/lib/wasm/jsep/init.ts
var init_exports = {};
__export(init_exports, {
  init: () => init
});
var TensorViewImpl, ComputeContextImpl, init;
var init_init = __esm({
  "web/lib/wasm/jsep/init.ts"() {
    "use strict";
    init_wasm_common();
    init_backend_webgpu();
    init_log();
    init_util();
    TensorViewImpl = class _TensorViewImpl {
      constructor(module, dataType, data, dims) {
        this.module = module;
        this.dataType = dataType;
        this.data = data;
        this.dims = dims;
      }
      getFloat32Array() {
        if (this.dataType !== 1 /* float */) {
          throw new Error("Invalid data type");
        }
        const elementCount = ShapeUtil.size(this.dims);
        return elementCount === 0 ? new Float32Array() : new Float32Array(this.module.HEAP8.buffer, this.data, elementCount);
      }
      getBigInt64Array() {
        if (this.dataType !== 7 /* int64 */) {
          throw new Error("Invalid data type");
        }
        const elementCount = ShapeUtil.size(this.dims);
        return elementCount === 0 ? new BigInt64Array() : new BigInt64Array(this.module.HEAP8.buffer, this.data, elementCount);
      }
      getInt32Array() {
        if (this.dataType !== 6 /* int32 */) {
          throw new Error("Invalid data type");
        }
        const elementCount = ShapeUtil.size(this.dims);
        return elementCount === 0 ? new Int32Array() : new Int32Array(this.module.HEAP8.buffer, this.data, elementCount);
      }
      reshape(newDims) {
        if (ShapeUtil.size(newDims) !== ShapeUtil.size(this.dims)) {
          throw new Error("Invalid new shape");
        }
        return new _TensorViewImpl(this.module, this.dataType, this.data, newDims);
      }
    };
    ComputeContextImpl = class {
      constructor(module, backend, contextDataOffset) {
        this.module = module;
        this.backend = backend;
        this.customDataOffset = 0;
        this.customDataSize = 0;
        this.adapterInfo = backend.adapterInfo;
        const heapU32 = module.HEAPU32;
        let dataIndex = contextDataOffset >>> 2;
        this.opKernelContext = heapU32[dataIndex++];
        const inputCount = heapU32[dataIndex++];
        this.outputCount = heapU32[dataIndex++];
        this.customDataOffset = heapU32[dataIndex++];
        this.customDataSize = heapU32[dataIndex++];
        const inputs = [];
        for (let i = 0; i < inputCount; i++) {
          const dataType = heapU32[dataIndex++];
          const data = heapU32[dataIndex++];
          const dim = heapU32[dataIndex++];
          const dims = [];
          for (let d = 0; d < dim; d++) {
            dims.push(heapU32[dataIndex++]);
          }
          inputs.push(new TensorViewImpl(module, dataType, data, dims));
        }
        this.inputs = inputs;
      }
      get kernelCustomData() {
        return this.backend.currentKernelCustomData;
      }
      get customDataBuffer() {
        return this.module.HEAPU8.subarray(this.customDataOffset, this.customDataOffset + this.customDataSize);
      }
      getMaxComputeWorkgroupSizes() {
        return [
          this.backend.device.limits.maxComputeWorkgroupSizeX,
          this.backend.device.limits.maxComputeWorkgroupSizeY,
          this.backend.device.limits.maxComputeWorkgroupSizeZ
        ];
      }
      getMaxComputeWorkgroupStoragesize() {
        return this.backend.device.limits.maxComputeWorkgroupStorageSize;
      }
      compute(program, inputsOutputsMapping) {
        const mappedInputs = inputsOutputsMapping?.inputs?.map((i) => typeof i === "number" ? this.inputs[i] : i) ?? this.inputs;
        const outputIndices = inputsOutputsMapping?.outputs ?? [];
        const createKernelOutput = (index, dataType, dims) => new TensorViewImpl(this.module, dataType, this.output(index, dims), dims);
        const createTemporaryOutput = (dataType, dims) => {
          const elementSize = getTensorElementSize(dataType);
          if (!elementSize) {
            throw new Error(`Unsupported data type: ${dataType}`);
          }
          const bufferSize = elementSize * ShapeUtil.size(dims);
          const gpuDataId = bufferSize > 0 ? this.backend.gpuDataManager.create(bufferSize).id : 0;
          return new TensorViewImpl(this.module, dataType, gpuDataId, dims);
        };
        return this.backend.run(
          program,
          mappedInputs,
          outputIndices,
          createKernelOutput,
          createTemporaryOutput,
          this.outputCount
        );
      }
      output(index, dims) {
        const stack = this.module.stackSave();
        try {
          const data = this.module.stackAlloc(
            (1 + dims.length) * 4
            /* sizeof(size_t) */
          );
          let offset = data >> 2;
          this.module.HEAPU32[offset++] = dims.length;
          for (let i = 0; i < dims.length; i++) {
            this.module.HEAPU32[offset++] = dims[i];
          }
          return this.module._JsepOutput(this.opKernelContext, index, data);
        } catch (e) {
          throw new Error(
            `Failed to generate kernel's output[${index}] with dims [${dims}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${e}`
          );
        } finally {
          this.module.stackRestore(stack);
        }
      }
    };
    init = async (name, module, env3, gpuAdapter) => {
      const jsepInit = module.jsepInit;
      if (!jsepInit) {
        throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");
      }
      if (name === "webgpu") {
        const backend = new WebGpuBackend();
        await backend.initialize(env3, gpuAdapter);
        jsepInit("webgpu", [
          // backend
          backend,
          // jsepAlloc()
          (size) => backend.alloc(size),
          // jsepFree()
          (ptr) => backend.free(ptr),
          // jsepCopy(src, dst, size, isSourceGpu)
          (src, dst, size, isSourceGpu = false) => {
            if (isSourceGpu) {
              LOG_DEBUG("verbose", () => `[WebGPU] jsepCopyGpuToGpu: src=${src}, dst=${dst}, size=${size}`);
              backend.memcpy(src, dst);
            } else {
              LOG_DEBUG("verbose", () => `[WebGPU] jsepCopyCpuToGpu: dataOffset=${src}, gpuDataId=${dst}, size=${size}`);
              const data = module.HEAPU8.subarray(src >>> 0, (src >>> 0) + size);
              backend.upload(dst, data);
            }
          },
          // jsepCopyAsync(src, dst, size)
          async (gpuDataId, dataOffset, size) => {
            LOG_DEBUG(
              "verbose",
              () => `[WebGPU] jsepCopyGpuToCpu: gpuDataId=${gpuDataId}, dataOffset=${dataOffset}, size=${size}`
            );
            await backend.download(
              gpuDataId,
              () => module.HEAPU8.subarray(dataOffset >>> 0, (dataOffset >>> 0) + size)
            );
          },
          // jsepCreateKernel
          (kernelType, kernelId, attribute) => backend.createKernel(
            kernelType,
            kernelId,
            attribute,
            module.UTF8ToString(module._JsepGetNodeName(kernelId))
          ),
          // jsepReleaseKernel
          (kernel) => backend.releaseKernel(kernel),
          // jsepRun
          (kernel, contextDataOffset, sessionHandle, errors) => {
            LOG_DEBUG(
              "verbose",
              () => `[WebGPU] jsepRun: sessionHandle=${sessionHandle}, kernel=${kernel}, contextDataOffset=${contextDataOffset}`
            );
            const context = new ComputeContextImpl(module, backend, contextDataOffset);
            return backend.computeKernel(kernel, context, errors);
          },
          // jsepCaptureBegin
          () => backend.captureBegin(),
          // jsepCaptureEnd
          () => backend.captureEnd(),
          // jsepReplay
          () => backend.replay()
        ]);
      } else {
        jsepInit("webnn");
      }
    };
  }
});

// web/lib/wasm/wasm-core-impl.ts
var initOrt, initRuntime, initEp, activeSessions, getSessionInputOutputCount, copyFromExternalBuffer, createSession, releaseSession, prepareInputOutputTensor, run, endProfiling, extractTransferableBuffers;
var init_wasm_core_impl = __esm({
  "web/lib/wasm/wasm-core-impl.ts"() {
    "use strict";
    init_run_options();
    init_session_options();
    init_wasm_common();
    init_wasm_factory();
    init_wasm_utils();
    init_wasm_utils_load_file();
    initOrt = (numThreads, loggingLevel) => {
      const errorCode = getInstance()._OrtInit(numThreads, loggingLevel);
      if (errorCode !== 0) {
        checkLastError("Can't initialize onnxruntime.");
      }
    };
    initRuntime = async (env3) => {
      initOrt(env3.wasm.numThreads, logLevelStringToEnum(env3.logLevel));
    };
    initEp = async (env3, epName) => {
      if (true) {
        const initJsep = (init_init(), __toCommonJS(init_exports)).init;
        if (epName === "webgpu") {
          if (typeof navigator === "undefined" || !navigator.gpu) {
            throw new Error("WebGPU is not supported in current environment");
          }
          let adapter = env3.webgpu.adapter;
          if (!adapter) {
            const powerPreference = env3.webgpu.powerPreference;
            if (powerPreference !== void 0 && powerPreference !== "low-power" && powerPreference !== "high-performance") {
              throw new Error(`Invalid powerPreference setting: "${powerPreference}"`);
            }
            const forceFallbackAdapter = env3.webgpu.forceFallbackAdapter;
            if (forceFallbackAdapter !== void 0 && typeof forceFallbackAdapter !== "boolean") {
              throw new Error(`Invalid forceFallbackAdapter setting: "${forceFallbackAdapter}"`);
            }
            adapter = await navigator.gpu.requestAdapter({ powerPreference, forceFallbackAdapter });
            if (!adapter) {
              throw new Error(
                'Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.'
              );
            }
          } else {
            if (typeof adapter.limits !== "object" || typeof adapter.features !== "object" || typeof adapter.requestDevice !== "function") {
              throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.");
            }
          }
          await initJsep("webgpu", getInstance(), env3, adapter);
        }
        if (epName === "webnn") {
          if (typeof navigator === "undefined" || !navigator.ml) {
            throw new Error("WebNN is not supported in current environment");
          }
          await initJsep("webnn", getInstance(), env3);
        }
      }
    };
    activeSessions = /* @__PURE__ */ new Map();
    getSessionInputOutputCount = (sessionHandle) => {
      const wasm2 = getInstance();
      const stack = wasm2.stackSave();
      try {
        const dataOffset = wasm2.stackAlloc(8);
        const errorCode = wasm2._OrtGetInputOutputCount(sessionHandle, dataOffset, dataOffset + 4);
        if (errorCode !== 0) {
          checkLastError("Can't get session input/output count.");
        }
        return [wasm2.HEAP32[dataOffset / 4], wasm2.HEAP32[dataOffset / 4 + 1]];
      } finally {
        wasm2.stackRestore(stack);
      }
    };
    copyFromExternalBuffer = (model) => {
      const wasm2 = getInstance();
      const modelDataOffset = wasm2._malloc(model.byteLength);
      if (modelDataOffset === 0) {
        throw new Error(`Can't create a session. failed to allocate a buffer of size ${model.byteLength}.`);
      }
      wasm2.HEAPU8.set(model, modelDataOffset);
      return [modelDataOffset, model.byteLength];
    };
    createSession = async (modelData, options) => {
      let modelDataOffset, modelDataLength;
      const wasm2 = getInstance();
      if (Array.isArray(modelData)) {
        [modelDataOffset, modelDataLength] = modelData;
      } else if (modelData.buffer === wasm2.HEAPU8.buffer) {
        [modelDataOffset, modelDataLength] = [modelData.byteOffset, modelData.byteLength];
      } else {
        [modelDataOffset, modelDataLength] = copyFromExternalBuffer(modelData);
      }
      let sessionHandle = 0;
      let sessionOptionsHandle = 0;
      let ioBindingHandle = 0;
      let allocs = [];
      const inputNamesUTF8Encoded = [];
      const outputNamesUTF8Encoded = [];
      try {
        [sessionOptionsHandle, allocs] = setSessionOptions(options);
        if (options?.externalData && wasm2.mountExternalData) {
          const loadingPromises = [];
          for (const file of options.externalData) {
            const path = typeof file === "string" ? file : file.path;
            loadingPromises.push(loadFile(typeof file === "string" ? file : file.data).then((data) => {
              wasm2.mountExternalData(path, data);
            }));
          }
          await Promise.all(loadingPromises);
        }
        sessionHandle = await wasm2._OrtCreateSession(modelDataOffset, modelDataLength, sessionOptionsHandle);
        if (sessionHandle === 0) {
          checkLastError("Can't create a session.");
        }
        const [inputCount, outputCount] = getSessionInputOutputCount(sessionHandle);
        const enableGraphCapture = !!options?.enableGraphCapture;
        const inputNames = [];
        const outputNames = [];
        const outputPreferredLocations = [];
        for (let i = 0; i < inputCount; i++) {
          const name = wasm2._OrtGetInputName(sessionHandle, i);
          if (name === 0) {
            checkLastError("Can't get an input name.");
          }
          inputNamesUTF8Encoded.push(name);
          inputNames.push(wasm2.UTF8ToString(name));
        }
        for (let i = 0; i < outputCount; i++) {
          const name = wasm2._OrtGetOutputName(sessionHandle, i);
          if (name === 0) {
            checkLastError("Can't get an output name.");
          }
          outputNamesUTF8Encoded.push(name);
          const nameString = wasm2.UTF8ToString(name);
          outputNames.push(nameString);
          if (true) {
            if (enableGraphCapture && options?.preferredOutputLocation === void 0) {
              outputPreferredLocations.push("gpu-buffer");
              continue;
            }
            const location2 = typeof options?.preferredOutputLocation === "string" ? options.preferredOutputLocation : options?.preferredOutputLocation?.[nameString] ?? "cpu";
            if (location2 !== "cpu" && location2 !== "cpu-pinned" && location2 !== "gpu-buffer") {
              throw new Error(`Not supported preferred output location: ${location2}.`);
            }
            if (enableGraphCapture && location2 !== "gpu-buffer") {
              throw new Error(`Not supported preferred output location: ${location2}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);
            }
            outputPreferredLocations.push(location2);
          }
        }
        let bindingState = null;
        if (outputPreferredLocations.some((l) => l === "gpu-buffer")) {
          ioBindingHandle = wasm2._OrtCreateBinding(sessionHandle);
          if (ioBindingHandle === 0) {
            checkLastError("Can't create IO binding.");
          }
          bindingState = {
            handle: ioBindingHandle,
            outputPreferredLocations,
            outputPreferredLocationsEncoded: outputPreferredLocations.map((l) => dataLocationStringToEnum(l))
          };
        }
        activeSessions.set(
          sessionHandle,
          [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded, bindingState, enableGraphCapture, false]
        );
        return [sessionHandle, inputNames, outputNames];
      } catch (e) {
        inputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
        outputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
        if (ioBindingHandle !== 0) {
          wasm2._OrtReleaseBinding(ioBindingHandle);
        }
        if (sessionHandle !== 0) {
          wasm2._OrtReleaseSession(sessionHandle);
        }
        throw e;
      } finally {
        wasm2._free(modelDataOffset);
        if (sessionOptionsHandle !== 0) {
          wasm2._OrtReleaseSessionOptions(sessionOptionsHandle);
        }
        allocs.forEach((alloc) => wasm2._free(alloc));
        wasm2.unmountExternalData?.();
      }
    };
    releaseSession = (sessionId) => {
      const wasm2 = getInstance();
      const session = activeSessions.get(sessionId);
      if (!session) {
        throw new Error(`cannot release session. invalid session id: ${sessionId}`);
      }
      const [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded, ioBindingState, enableGraphCapture] = session;
      if (ioBindingState) {
        if (enableGraphCapture) {
          wasm2._OrtClearBoundOutputs(ioBindingState.handle);
        }
        wasm2._OrtReleaseBinding(ioBindingState.handle);
      }
      wasm2.jsepOnReleaseSession?.(sessionId);
      inputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
      outputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
      wasm2._OrtReleaseSession(sessionHandle);
      activeSessions.delete(sessionId);
    };
    prepareInputOutputTensor = (tensor, tensorHandles, allocs, sessionId, index, enableGraphCapture = false) => {
      if (!tensor) {
        tensorHandles.push(0);
        return;
      }
      const wasm2 = getInstance();
      const dataType = tensor[0];
      const dims = tensor[1];
      const location2 = tensor[3];
      let rawData;
      let dataByteLength;
      if (dataType === "string" && location2 === "gpu-buffer") {
        throw new Error("String tensor is not supported on GPU.");
      }
      if (enableGraphCapture && location2 !== "gpu-buffer") {
        throw new Error(
          `External buffer must be provided for input/output index ${index} when enableGraphCapture is true.`
        );
      }
      if (location2 === "gpu-buffer") {
        const gpuBuffer = tensor[2].gpuBuffer;
        const elementSizeInBytes = getTensorElementSize(tensorDataTypeStringToEnum(dataType));
        dataByteLength = dims.reduce((a, b) => a * b, 1) * elementSizeInBytes;
        const registerBuffer = wasm2.jsepRegisterBuffer;
        if (!registerBuffer) {
          throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');
        }
        rawData = registerBuffer(sessionId, index, gpuBuffer, dataByteLength);
      } else {
        const data = tensor[2];
        if (Array.isArray(data)) {
          dataByteLength = 4 * data.length;
          rawData = wasm2._malloc(dataByteLength);
          allocs.push(rawData);
          let dataIndex = rawData / 4;
          for (let i = 0; i < data.length; i++) {
            if (typeof data[i] !== "string") {
              throw new TypeError(`tensor data at index ${i} is not a string`);
            }
            wasm2.HEAPU32[dataIndex++] = allocWasmString(data[i], allocs);
          }
        } else {
          dataByteLength = data.byteLength;
          rawData = wasm2._malloc(dataByteLength);
          allocs.push(rawData);
          wasm2.HEAPU8.set(new Uint8Array(data.buffer, data.byteOffset, dataByteLength), rawData);
        }
      }
      const stack = wasm2.stackSave();
      const dimsOffset = wasm2.stackAlloc(4 * dims.length);
      try {
        let dimIndex = dimsOffset / 4;
        dims.forEach((d) => wasm2.HEAP32[dimIndex++] = d);
        const tensor2 = wasm2._OrtCreateTensor(
          tensorDataTypeStringToEnum(dataType),
          rawData,
          dataByteLength,
          dimsOffset,
          dims.length,
          dataLocationStringToEnum(location2)
        );
        if (tensor2 === 0) {
          checkLastError(`Can't create tensor for input/output. session=${sessionId}, index=${index}.`);
        }
        tensorHandles.push(tensor2);
      } finally {
        wasm2.stackRestore(stack);
      }
    };
    run = async (sessionId, inputIndices, inputTensors, outputIndices, outputTensors, options) => {
      const wasm2 = getInstance();
      const session = activeSessions.get(sessionId);
      if (!session) {
        throw new Error(`cannot run inference. invalid session id: ${sessionId}`);
      }
      const sessionHandle = session[0];
      const inputNamesUTF8Encoded = session[1];
      const outputNamesUTF8Encoded = session[2];
      const ioBindingState = session[3];
      const enableGraphCapture = session[4];
      const inputOutputBound = session[5];
      const inputCount = inputIndices.length;
      const outputCount = outputIndices.length;
      let runOptionsHandle = 0;
      let runOptionsAllocs = [];
      const inputTensorHandles = [];
      const outputTensorHandles = [];
      const inputOutputAllocs = [];
      const beforeRunStack = wasm2.stackSave();
      const inputValuesOffset = wasm2.stackAlloc(inputCount * 4);
      const inputNamesOffset = wasm2.stackAlloc(inputCount * 4);
      const outputValuesOffset = wasm2.stackAlloc(outputCount * 4);
      const outputNamesOffset = wasm2.stackAlloc(outputCount * 4);
      try {
        [runOptionsHandle, runOptionsAllocs] = setRunOptions(options);
        for (let i = 0; i < inputCount; i++) {
          prepareInputOutputTensor(
            inputTensors[i],
            inputTensorHandles,
            inputOutputAllocs,
            sessionId,
            inputIndices[i],
            enableGraphCapture
          );
        }
        for (let i = 0; i < outputCount; i++) {
          prepareInputOutputTensor(
            outputTensors[i],
            outputTensorHandles,
            inputOutputAllocs,
            sessionId,
            inputCount + outputIndices[i],
            enableGraphCapture
          );
        }
        let inputValuesIndex = inputValuesOffset / 4;
        let inputNamesIndex = inputNamesOffset / 4;
        let outputValuesIndex = outputValuesOffset / 4;
        let outputNamesIndex = outputNamesOffset / 4;
        for (let i = 0; i < inputCount; i++) {
          wasm2.HEAPU32[inputValuesIndex++] = inputTensorHandles[i];
          wasm2.HEAPU32[inputNamesIndex++] = inputNamesUTF8Encoded[inputIndices[i]];
        }
        for (let i = 0; i < outputCount; i++) {
          wasm2.HEAPU32[outputValuesIndex++] = outputTensorHandles[i];
          wasm2.HEAPU32[outputNamesIndex++] = outputNamesUTF8Encoded[outputIndices[i]];
        }
        if (ioBindingState && !inputOutputBound) {
          const { handle, outputPreferredLocations, outputPreferredLocationsEncoded } = ioBindingState;
          if (inputNamesUTF8Encoded.length !== inputCount) {
            throw new Error(`input count from feeds (${inputCount}) is expected to be always equal to model's input count (${inputNamesUTF8Encoded.length}).`);
          }
          for (let i = 0; i < inputCount; i++) {
            const index = inputIndices[i];
            const errorCode2 = await wasm2._OrtBindInput(handle, inputNamesUTF8Encoded[index], inputTensorHandles[i]);
            if (errorCode2 !== 0) {
              checkLastError(`Can't bind input[${i}] for session=${sessionId}.`);
            }
          }
          for (let i = 0; i < outputCount; i++) {
            const index = outputIndices[i];
            const location2 = outputTensors[i]?.[3];
            if (location2) {
              const errorCode2 = wasm2._OrtBindOutput(handle, outputNamesUTF8Encoded[index], outputTensorHandles[i], 0);
              if (errorCode2 !== 0) {
                checkLastError(`Can't bind pre-allocated output[${i}] for session=${sessionId}.`);
              }
            } else {
              const errorCode2 = wasm2._OrtBindOutput(handle, outputNamesUTF8Encoded[index], 0, outputPreferredLocationsEncoded[index]);
              if (errorCode2 !== 0) {
                checkLastError(`Can't bind output[${i}] to ${outputPreferredLocations[i]} for session=${sessionId}.`);
              }
            }
          }
          activeSessions.set(
            sessionId,
            [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded, ioBindingState, enableGraphCapture, true]
          );
        }
        wasm2.jsepOnRunStart?.(sessionHandle);
        let errorCode;
        if (ioBindingState) {
          errorCode = await wasm2._OrtRunWithBinding(
            sessionHandle,
            ioBindingState.handle,
            outputCount,
            outputValuesOffset,
            runOptionsHandle
          );
        } else {
          errorCode = await wasm2._OrtRun(
            sessionHandle,
            inputNamesOffset,
            inputValuesOffset,
            inputCount,
            outputNamesOffset,
            outputCount,
            outputValuesOffset,
            runOptionsHandle
          );
        }
        if (errorCode !== 0) {
          checkLastError("failed to call OrtRun().");
        }
        const output = [];
        for (let i = 0; i < outputCount; i++) {
          const tensor = wasm2.HEAPU32[outputValuesOffset / 4 + i];
          if (tensor === outputTensorHandles[i]) {
            output.push(outputTensors[i]);
            continue;
          }
          const beforeGetTensorDataStack = wasm2.stackSave();
          const tensorDataOffset = wasm2.stackAlloc(4 * 4);
          let keepOutputTensor = false;
          let type, dataOffset = 0;
          try {
            const errorCode2 = wasm2._OrtGetTensorData(
              tensor,
              tensorDataOffset,
              tensorDataOffset + 4,
              tensorDataOffset + 8,
              tensorDataOffset + 12
            );
            if (errorCode2 !== 0) {
              checkLastError(`Can't access output tensor data on index ${i}.`);
            }
            let tensorDataIndex = tensorDataOffset / 4;
            const dataType = wasm2.HEAPU32[tensorDataIndex++];
            dataOffset = wasm2.HEAPU32[tensorDataIndex++];
            const dimsOffset = wasm2.HEAPU32[tensorDataIndex++];
            const dimsLength = wasm2.HEAPU32[tensorDataIndex++];
            const dims = [];
            for (let i2 = 0; i2 < dimsLength; i2++) {
              dims.push(wasm2.HEAPU32[dimsOffset / 4 + i2]);
            }
            wasm2._OrtFree(dimsOffset);
            const size = dims.reduce((a, b) => a * b, 1);
            type = tensorDataTypeEnumToString(dataType);
            const preferredLocation = ioBindingState?.outputPreferredLocations[outputIndices[i]];
            if (type === "string") {
              if (preferredLocation === "gpu-buffer") {
                throw new Error("String tensor is not supported on GPU.");
              }
              const stringData = [];
              let dataIndex = dataOffset / 4;
              for (let i2 = 0; i2 < size; i2++) {
                const offset = wasm2.HEAPU32[dataIndex++];
                const maxBytesToRead = i2 === size - 1 ? void 0 : wasm2.HEAPU32[dataIndex] - offset;
                stringData.push(wasm2.UTF8ToString(offset, maxBytesToRead));
              }
              output.push([type, dims, stringData, "cpu"]);
            } else {
              if (preferredLocation === "gpu-buffer" && size > 0) {
                const getBuffer = wasm2.jsepGetBuffer;
                if (!getBuffer) {
                  throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');
                }
                const gpuBuffer = getBuffer(dataOffset);
                const elementSize = getTensorElementSize(dataType);
                if (elementSize === void 0 || !isGpuBufferSupportedType(type)) {
                  throw new Error(`Unsupported data type: ${type}`);
                }
                keepOutputTensor = true;
                output.push([
                  type,
                  dims,
                  {
                    gpuBuffer,
                    download: wasm2.jsepCreateDownloader(gpuBuffer, size * elementSize, type),
                    dispose: () => {
                      wasm2._OrtReleaseTensor(tensor);
                    }
                  },
                  "gpu-buffer"
                ]);
              } else {
                const typedArrayConstructor = tensorTypeToTypedArrayConstructor(type);
                const data = new typedArrayConstructor(size);
                new Uint8Array(data.buffer, data.byteOffset, data.byteLength).set(wasm2.HEAPU8.subarray(dataOffset, dataOffset + data.byteLength));
                output.push([type, dims, data, "cpu"]);
              }
            }
          } finally {
            wasm2.stackRestore(beforeGetTensorDataStack);
            if (type === "string" && dataOffset) {
              wasm2._free(dataOffset);
            }
            if (!keepOutputTensor) {
              wasm2._OrtReleaseTensor(tensor);
            }
          }
        }
        if (ioBindingState && !enableGraphCapture) {
          wasm2._OrtClearBoundOutputs(ioBindingState.handle);
          activeSessions.set(
            sessionId,
            [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded, ioBindingState, enableGraphCapture, false]
          );
        }
        return output;
      } finally {
        wasm2.stackRestore(beforeRunStack);
        inputTensorHandles.forEach((v) => wasm2._OrtReleaseTensor(v));
        outputTensorHandles.forEach((v) => wasm2._OrtReleaseTensor(v));
        inputOutputAllocs.forEach((p) => wasm2._free(p));
        if (runOptionsHandle !== 0) {
          wasm2._OrtReleaseRunOptions(runOptionsHandle);
        }
        runOptionsAllocs.forEach((p) => wasm2._free(p));
      }
    };
    endProfiling = (sessionId) => {
      const wasm2 = getInstance();
      const session = activeSessions.get(sessionId);
      if (!session) {
        throw new Error("invalid session id");
      }
      const sessionHandle = session[0];
      const profileFileName = wasm2._OrtEndProfiling(sessionHandle);
      if (profileFileName === 0) {
        checkLastError("Can't get an profile file name.");
      }
      wasm2._OrtFree(profileFileName);
    };
    extractTransferableBuffers = (tensors) => {
      const buffers = [];
      for (const tensor of tensors) {
        const data = tensor[2];
        if (!Array.isArray(data) && "buffer" in data) {
          buffers.push(data.buffer);
        }
      }
      return buffers;
    };
  }
});

// web/lib/wasm/proxy-wrapper.ts
var isProxy, proxyWorker, initializing2, initialized2, aborted2, temporaryObjectUrl, initWasmCallbacks, queuedCallbacks, enqueueCallbacks, ensureWorker, onProxyWorkerMessage, initializeWebAssemblyAndOrtRuntime, initializeOrtEp, copyFromExternalBuffer2, createSession2, releaseSession2, run2, endProfiling2;
var init_proxy_wrapper = __esm({
  "web/lib/wasm/proxy-wrapper.ts"() {
    "use strict";
    init_esm();
    init_wasm_core_impl();
    init_wasm_factory();
    init_wasm_utils_import();
    isProxy = () => !!env2.wasm.proxy && typeof document !== "undefined";
    initializing2 = false;
    initialized2 = false;
    aborted2 = false;
    queuedCallbacks = /* @__PURE__ */ new Map();
    enqueueCallbacks = (type, callbacks) => {
      const queue = queuedCallbacks.get(type);
      if (queue) {
        queue.push(callbacks);
      } else {
        queuedCallbacks.set(type, [callbacks]);
      }
    };
    ensureWorker = () => {
      if (initializing2 || !initialized2 || aborted2 || !proxyWorker) {
        throw new Error("worker not ready");
      }
    };
    onProxyWorkerMessage = (ev) => {
      switch (ev.data.type) {
        case "init-wasm":
          initializing2 = false;
          if (ev.data.err) {
            aborted2 = true;
            initWasmCallbacks[1](ev.data.err);
          } else {
            initialized2 = true;
            initWasmCallbacks[0]();
          }
          if (temporaryObjectUrl) {
            URL.revokeObjectURL(temporaryObjectUrl);
            temporaryObjectUrl = void 0;
          }
          break;
        case "init-ep":
        case "copy-from":
        case "create":
        case "release":
        case "run":
        case "end-profiling": {
          const callbacks = queuedCallbacks.get(ev.data.type);
          if (ev.data.err) {
            callbacks.shift()[1](ev.data.err);
          } else {
            callbacks.shift()[0](ev.data.out);
          }
          break;
        }
        default:
      }
    };
    initializeWebAssemblyAndOrtRuntime = async () => {
      if (initialized2) {
        return;
      }
      if (initializing2) {
        throw new Error("multiple calls to 'initWasm()' detected.");
      }
      if (aborted2) {
        throw new Error("previous call to 'initWasm()' failed.");
      }
      initializing2 = true;
      if (isProxy()) {
        return new Promise((resolve, reject) => {
          proxyWorker?.terminate();
          void importProxyWorker().then(([objectUrl, worker]) => {
            try {
              proxyWorker = worker;
              proxyWorker.onerror = (ev) => reject(ev);
              proxyWorker.onmessage = onProxyWorkerMessage;
              initWasmCallbacks = [resolve, reject];
              const message = { type: "init-wasm", in: env2 };
              proxyWorker.postMessage(message);
              temporaryObjectUrl = objectUrl;
            } catch (e) {
              reject(e);
            }
          }, reject);
        });
      } else {
        try {
          await initializeWebAssembly(env2.wasm);
          await initRuntime(env2);
          initialized2 = true;
        } catch (e) {
          aborted2 = true;
          throw e;
        } finally {
          initializing2 = false;
        }
      }
    };
    initializeOrtEp = async (epName) => {
      if (isProxy()) {
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("init-ep", [resolve, reject]);
          const message = { type: "init-ep", in: { epName, env: env2 } };
          proxyWorker.postMessage(message);
        });
      } else {
        await initEp(env2, epName);
      }
    };
    copyFromExternalBuffer2 = async (buffer) => {
      if (isProxy()) {
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("copy-from", [resolve, reject]);
          const message = { type: "copy-from", in: { buffer } };
          proxyWorker.postMessage(message, [buffer.buffer]);
        });
      } else {
        return copyFromExternalBuffer(buffer);
      }
    };
    createSession2 = async (model, options) => {
      if (isProxy()) {
        if (options?.preferredOutputLocation) {
          throw new Error('session option "preferredOutputLocation" is not supported for proxy.');
        }
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("create", [resolve, reject]);
          const message = { type: "create", in: { model, options: { ...options } } };
          const transferable = [];
          if (model instanceof Uint8Array) {
            transferable.push(model.buffer);
          }
          proxyWorker.postMessage(message, transferable);
        });
      } else {
        return createSession(model, options);
      }
    };
    releaseSession2 = async (sessionId) => {
      if (isProxy()) {
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("release", [resolve, reject]);
          const message = { type: "release", in: sessionId };
          proxyWorker.postMessage(message);
        });
      } else {
        releaseSession(sessionId);
      }
    };
    run2 = async (sessionId, inputIndices, inputs, outputIndices, outputs, options) => {
      if (isProxy()) {
        if (inputs.some((t) => t[3] !== "cpu")) {
          throw new Error("input tensor on GPU is not supported for proxy.");
        }
        if (outputs.some((t) => t)) {
          throw new Error("pre-allocated output tensor is not supported for proxy.");
        }
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("run", [resolve, reject]);
          const serializableInputs = inputs;
          const message = { type: "run", in: { sessionId, inputIndices, inputs: serializableInputs, outputIndices, options } };
          proxyWorker.postMessage(message, extractTransferableBuffers(serializableInputs));
        });
      } else {
        return run(sessionId, inputIndices, inputs, outputIndices, outputs, options);
      }
    };
    endProfiling2 = async (sessionId) => {
      if (isProxy()) {
        ensureWorker();
        return new Promise((resolve, reject) => {
          enqueueCallbacks("end-profiling", [resolve, reject]);
          const message = { type: "end-profiling", in: sessionId };
          proxyWorker.postMessage(message);
        });
      } else {
        endProfiling(sessionId);
      }
    };
  }
});

// web/lib/wasm/session-handler-inference.ts
var encodeTensorMetadata, decodeTensorMetadata, OnnxruntimeWebAssemblySessionHandler;
var init_session_handler_inference = __esm({
  "web/lib/wasm/session-handler-inference.ts"() {
    "use strict";
    init_esm();
    init_proxy_wrapper();
    init_wasm_common();
    init_wasm_utils_env();
    init_wasm_utils_load_file();
    encodeTensorMetadata = (tensor, getName) => {
      switch (tensor.location) {
        case "cpu":
          return [tensor.type, tensor.dims, tensor.data, "cpu"];
        case "gpu-buffer":
          return [tensor.type, tensor.dims, { gpuBuffer: tensor.gpuBuffer }, "gpu-buffer"];
        default:
          throw new Error(`invalid data location: ${tensor.location} for ${getName()}`);
      }
    };
    decodeTensorMetadata = (tensor) => {
      switch (tensor[3]) {
        case "cpu":
          return new Tensor2(tensor[0], tensor[2], tensor[1]);
        case "gpu-buffer": {
          const dataType = tensor[0];
          if (!isGpuBufferSupportedType(dataType)) {
            throw new Error(`not supported data type: ${dataType} for deserializing GPU tensor`);
          }
          const { gpuBuffer, download, dispose } = tensor[2];
          return Tensor2.fromGpuBuffer(gpuBuffer, { dataType, dims: tensor[1], download, dispose });
        }
        default:
          throw new Error(`invalid data location: ${tensor[3]}`);
      }
    };
    OnnxruntimeWebAssemblySessionHandler = class {
      async fetchModelAndCopyToWasmMemory(path) {
        return copyFromExternalBuffer2(await loadFile(path));
      }
      async loadModel(pathOrBuffer, options) {
        TRACE_FUNC_BEGIN();
        let model;
        if (typeof pathOrBuffer === "string") {
          if (isNode) {
            model = await loadFile(pathOrBuffer);
          } else {
            model = await this.fetchModelAndCopyToWasmMemory(pathOrBuffer);
          }
        } else {
          model = pathOrBuffer;
        }
        [this.sessionId, this.inputNames, this.outputNames] = await createSession2(model, options);
        TRACE_FUNC_END();
      }
      async dispose() {
        return releaseSession2(this.sessionId);
      }
      async run(feeds, fetches, options) {
        TRACE_FUNC_BEGIN();
        const inputArray = [];
        const inputIndices = [];
        Object.entries(feeds).forEach((kvp) => {
          const name = kvp[0];
          const tensor = kvp[1];
          const index = this.inputNames.indexOf(name);
          if (index === -1) {
            throw new Error(`invalid input '${name}'`);
          }
          inputArray.push(tensor);
          inputIndices.push(index);
        });
        const outputArray = [];
        const outputIndices = [];
        Object.entries(fetches).forEach((kvp) => {
          const name = kvp[0];
          const tensor = kvp[1];
          const index = this.outputNames.indexOf(name);
          if (index === -1) {
            throw new Error(`invalid output '${name}'`);
          }
          outputArray.push(tensor);
          outputIndices.push(index);
        });
        const inputs = inputArray.map((t, i) => encodeTensorMetadata(t, () => `input "${this.inputNames[inputIndices[i]]}"`));
        const outputs = outputArray.map(
          (t, i) => t ? encodeTensorMetadata(t, () => `output "${this.outputNames[outputIndices[i]]}"`) : null
        );
        const results = await run2(this.sessionId, inputIndices, inputs, outputIndices, outputs, options);
        const resultMap = {};
        for (let i = 0; i < results.length; i++) {
          resultMap[this.outputNames[outputIndices[i]]] = outputArray[i] ?? decodeTensorMetadata(results[i]);
        }
        TRACE_FUNC_END();
        return resultMap;
      }
      startProfiling() {
      }
      endProfiling() {
        void endProfiling2(this.sessionId);
      }
    };
  }
});

// web/lib/backend-wasm.ts
var initializeFlags, OnnxruntimeWebAssemblyBackend;
var init_backend_wasm = __esm({
  "web/lib/backend-wasm.ts"() {
    "use strict";
    init_esm();
    init_proxy_wrapper();
    init_session_handler_inference();
    init_wasm_utils_import();
    initializeFlags = () => {
      if (typeof env2.wasm.initTimeout !== "number" || env2.wasm.initTimeout < 0) {
        env2.wasm.initTimeout = 0;
      }
      if (env2.wasm.simd === false) {
        console.warn(
          'Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'
        );
      }
      if (typeof env2.wasm.proxy !== "boolean") {
        env2.wasm.proxy = false;
      }
      if (typeof env2.wasm.trace !== "boolean") {
        env2.wasm.trace = false;
      }
      if (typeof env2.wasm.numThreads !== "number" || !Number.isInteger(env2.wasm.numThreads) || env2.wasm.numThreads <= 0) {
        if (typeof self !== "undefined" && !self.crossOriginIsolated) {
          env2.wasm.numThreads = 1;
        } else {
          const numCpuLogicalCores = typeof navigator === "undefined" ? __require("node:os").cpus().length : navigator.hardwareConcurrency;
          env2.wasm.numThreads = Math.min(4, Math.ceil((numCpuLogicalCores || 1) / 2));
        }
      }
      if (env2.wasm.wasmPaths === void 0 && scriptSrc && scriptSrc.indexOf("blob:") !== 0) {
        env2.wasm.wasmPaths = scriptSrc.substring(0, scriptSrc.lastIndexOf("/") + 1);
      }
    };
    OnnxruntimeWebAssemblyBackend = class {
      /**
       * This function initializes the WebAssembly backend.
       *
       * This function will be called only once for each backend name. It will be called the first time when
       * `ort.InferenceSession.create()` is called with a registered backend name.
       *
       * @param backendName - the registered backend name.
       */
      async init(backendName) {
        initializeFlags();
        await initializeWebAssemblyAndOrtRuntime();
        await initializeOrtEp(backendName);
      }
      async createInferenceSessionHandler(pathOrBuffer, options) {
        const handler = new OnnxruntimeWebAssemblySessionHandler();
        await handler.loadModel(pathOrBuffer, options);
        return Promise.resolve(handler);
      }
    };
  }
});

// web/lib/backend-wasm-inference.ts
var backend_wasm_inference_exports = {};
__export(backend_wasm_inference_exports, {
  wasmBackend: () => wasmBackend
});
var wasmBackend;
var init_backend_wasm_inference = __esm({
  "web/lib/backend-wasm-inference.ts"() {
    "use strict";
    init_backend_wasm();
    wasmBackend = new OnnxruntimeWebAssemblyBackend();
  }
});

// web/lib/index.ts
init_esm();
init_esm();
init_esm();

// web/lib/version.ts
var version2 = "1.19.0";

// web/lib/index.ts
var lib_default = esm_exports;
if (false) {
  const onnxjsBackend = null.onnxjsBackend;
  registerBackend("webgl", onnxjsBackend, -10);
}
if (true) {
  const wasmBackend2 = true ? (init_backend_wasm_inference(), __toCommonJS(backend_wasm_inference_exports)).wasmBackend : null.wasmBackend;
  if (true) {
    registerBackend("webgpu", wasmBackend2, 5);
    registerBackend("webnn", wasmBackend2, 5);
  }
  registerBackend("cpu", wasmBackend2, 10);
  registerBackend("wasm", wasmBackend2, 10);
}
Object.defineProperty(env2.versions, "web", { value: version2, enumerable: true });
export {
  InferenceSession2 as InferenceSession,
  TRACE,
  TRACE_FUNC_BEGIN,
  TRACE_FUNC_END,
  Tensor2 as Tensor,
  TrainingSession2 as TrainingSession,
  lib_default as default,
  env2 as env,
  registerBackend
};
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9saWIvYmFja2VuZC1pbXBsLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vbGliL2JhY2tlbmQudHMiLCAiLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9saWIvdmVyc2lvbi50cyIsICIuLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2xpYi9lbnYtaW1wbC50cyIsICIuLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2xpYi9lbnYudHMiLCAiLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9saWIvdGVuc29yLWNvbnZlcnNpb24taW1wbC50cyIsICIuLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2xpYi90ZW5zb3ItZmFjdG9yeS1pbXBsLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vbGliL3RlbnNvci1pbXBsLXR5cGUtbWFwcGluZy50cyIsICIuLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2xpYi90ZW5zb3ItdXRpbHMtaW1wbC50cyIsICIuLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2xpYi90ZW5zb3ItaW1wbC50cyIsICIuLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2xpYi90ZW5zb3IudHMiLCAiLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9saWIvdHJhY2UudHMiLCAiLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9saWIvaW5mZXJlbmNlLXNlc3Npb24taW1wbC50cyIsICIuLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2xpYi9pbmZlcmVuY2Utc2Vzc2lvbi50cyIsICIuLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2xpYi90ZW5zb3ItY29udmVyc2lvbi50cyIsICIuLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2xpYi90ZW5zb3ItZmFjdG9yeS50cyIsICIuLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2xpYi9vbm54LW1vZGVsLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vbGliL29ubngtdmFsdWUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9saWIvdHJhaW5pbmctc2Vzc2lvbi1pbXBsLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vbGliL3RyYWluaW5nLXNlc3Npb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9saWIvaW5kZXgudHMiLCAiLi4vbGliL3dhc20vd2FzbS11dGlscy1lbnYudHMiLCAiLi4vbGliL3dhc20vcHJveHktd29ya2VyL21haW4udHMiLCAiLi4vbGliL3dhc20vd2FzbS11dGlscy1pbXBvcnQudHMiLCAiLi4vbGliL3dhc20vd2FzbS1mYWN0b3J5LnRzIiwgIi4uL2xpYi93YXNtL3dhc20tdXRpbHMudHMiLCAiLi4vbGliL3dhc20vcnVuLW9wdGlvbnMudHMiLCAiLi4vbGliL3dhc20vc2Vzc2lvbi1vcHRpb25zLnRzIiwgIi4uL2xpYi93YXNtL3dhc20tY29tbW9uLnRzIiwgIi4uL2xpYi93YXNtL3dhc20tdXRpbHMtbG9hZC1maWxlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvbG9nLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvdGVuc29yLXZpZXcudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvdHlwZXMudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvZ3B1LWRhdGEtbWFuYWdlci50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXkudHMiLCAiLi4vbGliL3dhc20vanNlcC91dGlsLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9jb21tb24udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3RyYW5zcG9zZS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvcmVkdWNlLXNoYXJlZC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvcmVkdWNlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9hcmdtaW5tYXgudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2F0dGVudGlvbi50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvYmF0Y2gtbm9ybS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvYmlhcy1hZGQudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3VuYXJ5LW9wLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9iaWFzLXNwbGl0LWdlbHUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2JpbmFyeS1vcC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvY29uY2F0LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9mdXNlLXV0aWxzLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvYWN0aXZhdGlvbl91dGlsLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvY29udl91dGlsLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvbWF0bXVsX3BhY2tlZF93ZWJncHUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzLzNyZC1wYXJ0eS9jb252MmRfbW1fd2ViZ3B1LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9jb252LWdyb3VwZWQudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL21hdG11bC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvY29udi50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvM3JkLXBhcnR5L2NvbnZfYmFja3Byb3BfbW1fd2ViZ3B1LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvY29udl9iYWNrcHJvcF93ZWJncHUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2NvbnYtdHJhbnNwb3NlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9jdW1zdW0udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2RlcHRoLXRvLXNwYWNlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9laW5zdW0udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2V4cGFuZC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvZmFzdC1nZWx1LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9nYXRoZXIudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2dhdGhlci1lbGVtZW50cy50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvZ2VtbS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvbXVsdGloZWFkLWF0dGVudGlvbi50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvdGlsZS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvZ3JvdXAtcXVlcnktYXR0ZW50aW9uLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9pbnN0YW5jZS1ub3JtLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9sYXllci1ub3JtLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9tYXRtdWxuYml0cy50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvcGFkLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9wb29sLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9yYW5nZS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvcmVzaXplLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9yb3RhcnktZW1iZWRkaW5nLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9za2lwLWxheWVyLW5vcm0udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3NsaWNlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9zb2Z0bWF4LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9zcGxpdC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvd2hlcmUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3AtcmVzb2x2ZS1ydWxlcy50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9wcm9ncmFtLW1hbmFnZXIudHMiLCAiLi4vbGliL3dhc20vanNlcC9iYWNrZW5kLXdlYmdwdS50cyIsICIuLi9saWIvd2FzbS9qc2VwL2luaXQudHMiLCAiLi4vbGliL3dhc20vd2FzbS1jb3JlLWltcGwudHMiLCAiLi4vbGliL3dhc20vcHJveHktd3JhcHBlci50cyIsICIuLi9saWIvd2FzbS9zZXNzaW9uLWhhbmRsZXItaW5mZXJlbmNlLnRzIiwgIi4uL2xpYi9iYWNrZW5kLXdhc20udHMiLCAiLi4vbGliL2JhY2tlbmQtd2FzbS1pbmZlcmVuY2UudHMiLCAiLi4vbGliL2luZGV4LnRzIiwgIi4uL2xpYi92ZXJzaW9uLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtCYWNrZW5kfSBmcm9tICcuL2JhY2tlbmQuanMnO1xuaW1wb3J0IHtJbmZlcmVuY2VTZXNzaW9ufSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcblxuaW50ZXJmYWNlIEJhY2tlbmRJbmZvIHtcbiAgYmFja2VuZDogQmFja2VuZDtcbiAgcHJpb3JpdHk6IG51bWJlcjtcblxuICBpbml0UHJvbWlzZT86IFByb21pc2U8dm9pZD47XG4gIGluaXRpYWxpemVkPzogYm9vbGVhbjtcbiAgYWJvcnRlZD86IGJvb2xlYW47XG4gIGVycm9yPzogc3RyaW5nO1xufVxuXG5jb25zdCBiYWNrZW5kczogTWFwPHN0cmluZywgQmFja2VuZEluZm8+ID0gbmV3IE1hcCgpO1xuY29uc3QgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5OiBzdHJpbmdbXSA9IFtdO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgYmFja2VuZC5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIGFzIGEga2V5IHRvIGxvb2t1cCBhcyBhbiBleGVjdXRpb24gcHJvdmlkZXIuXG4gKiBAcGFyYW0gYmFja2VuZCAtIHRoZSBiYWNrZW5kIG9iamVjdC5cbiAqIEBwYXJhbSBwcmlvcml0eSAtIGFuIGludGVnZXIgaW5kaWNhdGluZyB0aGUgcHJpb3JpdHkgb2YgdGhlIGJhY2tlbmQuIEhpZ2hlciBudW1iZXIgbWVhbnMgaGlnaGVyIHByaW9yaXR5LiBpZiBwcmlvcml0eVxuICogPCAwLCBpdCB3aWxsIGJlIGNvbnNpZGVyZWQgYXMgYSAnYmV0YScgdmVyc2lvbiBhbmQgd2lsbCBub3QgYmUgdXNlZCBhcyBhIGZhbGxiYWNrIGJhY2tlbmQgYnkgZGVmYXVsdC5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBjb25zdCByZWdpc3RlckJhY2tlbmQgPSAobmFtZTogc3RyaW5nLCBiYWNrZW5kOiBCYWNrZW5kLCBwcmlvcml0eTogbnVtYmVyKTogdm9pZCA9PiB7XG4gIGlmIChiYWNrZW5kICYmIHR5cGVvZiBiYWNrZW5kLmluaXQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGJhY2tlbmQuY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCBjdXJyZW50QmFja2VuZCA9IGJhY2tlbmRzLmdldChuYW1lKTtcbiAgICBpZiAoY3VycmVudEJhY2tlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYmFja2VuZHMuc2V0KG5hbWUsIHtiYWNrZW5kLCBwcmlvcml0eX0pO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudEJhY2tlbmQucHJpb3JpdHkgPiBwcmlvcml0eSkge1xuICAgICAgLy8gc2FtZSBuYW1lIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCB3aXRoIGEgaGlnaGVyIHByaW9yaXR5LiBza2lwIHJlZ2lzdGVyYXRpb24uXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChjdXJyZW50QmFja2VuZC5wcmlvcml0eSA9PT0gcHJpb3JpdHkpIHtcbiAgICAgIGlmIChjdXJyZW50QmFja2VuZC5iYWNrZW5kICE9PSBiYWNrZW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlZ2lzdGVyIGJhY2tlbmQgXCIke25hbWV9XCIgdXNpbmcgcHJpb3JpdHkgJHtwcmlvcml0eX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJpb3JpdHkgPj0gMCkge1xuICAgICAgY29uc3QgaSA9IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5pbmRleE9mKG5hbWUpO1xuICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgIGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChiYWNrZW5kcy5nZXQoYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5W2ldKSEucHJpb3JpdHkgPD0gcHJpb3JpdHkpIHtcbiAgICAgICAgICBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkuc3BsaWNlKGksIDAsIG5hbWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5LnB1c2gobmFtZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vdCBhIHZhbGlkIGJhY2tlbmQnKTtcbn07XG5cbi8qKlxuICogVHJ5IHRvIHJlc29sdmUgYW5kIGluaXRpYWxpemUgYSBiYWNrZW5kLlxuICpcbiAqIEBwYXJhbSBiYWNrZW5kTmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBiYWNrZW5kLlxuICogQHJldHVybnMgdGhlIGJhY2tlbmQgaW5zdGFuY2UgaWYgcmVzb2x2ZWQgYW5kIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseSwgb3IgYW4gZXJyb3IgbWVzc2FnZSBpZiBmYWlsZWQuXG4gKi9cbmNvbnN0IHRyeVJlc29sdmVBbmRJbml0aWFsaXplQmFja2VuZCA9IGFzeW5jKGJhY2tlbmROYW1lOiBzdHJpbmcpOiBQcm9taXNlPEJhY2tlbmR8c3RyaW5nPiA9PiB7XG4gIGNvbnN0IGJhY2tlbmRJbmZvID0gYmFja2VuZHMuZ2V0KGJhY2tlbmROYW1lKTtcbiAgaWYgKCFiYWNrZW5kSW5mbykge1xuICAgIHJldHVybiAnYmFja2VuZCBub3QgZm91bmQuJztcbiAgfVxuXG4gIGlmIChiYWNrZW5kSW5mby5pbml0aWFsaXplZCkge1xuICAgIHJldHVybiBiYWNrZW5kSW5mby5iYWNrZW5kO1xuICB9IGVsc2UgaWYgKGJhY2tlbmRJbmZvLmFib3J0ZWQpIHtcbiAgICByZXR1cm4gYmFja2VuZEluZm8uZXJyb3IhO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGlzSW5pdGlhbGl6aW5nID0gISFiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICB0cnkge1xuICAgICAgaWYgKCFpc0luaXRpYWxpemluZykge1xuICAgICAgICBiYWNrZW5kSW5mby5pbml0UHJvbWlzZSA9IGJhY2tlbmRJbmZvLmJhY2tlbmQuaW5pdChiYWNrZW5kTmFtZSk7XG4gICAgICB9XG4gICAgICBhd2FpdCBiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICAgIGJhY2tlbmRJbmZvLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBiYWNrZW5kSW5mby5iYWNrZW5kO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghaXNJbml0aWFsaXppbmcpIHtcbiAgICAgICAgYmFja2VuZEluZm8uZXJyb3IgPSBgJHtlfWA7XG4gICAgICAgIGJhY2tlbmRJbmZvLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhY2tlbmRJbmZvLmVycm9yITtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZGVsZXRlIGJhY2tlbmRJbmZvLmluaXRQcm9taXNlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZXNvbHZlIGV4ZWN1dGlvbiBwcm92aWRlcnMgZnJvbSB0aGUgc3BlY2lmaWMgc2Vzc2lvbiBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gdGhlIHNlc3Npb24gb3B0aW9ucyBvYmplY3QuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHR1cGxlIG9mIGFuIGluaXRpYWxpemVkIGJhY2tlbmQgaW5zdGFuY2UgYW5kIGEgc2Vzc2lvbiBvcHRpb25zIG9iamVjdCB3aXRoXG4gKiBmaWx0ZXJlZCBFUCBsaXN0LlxuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGNvbnN0IHJlc29sdmVCYWNrZW5kQW5kRXhlY3V0aW9uUHJvdmlkZXJzID0gYXN5bmMob3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6XG4gICAgUHJvbWlzZTxbYmFja2VuZDogQmFja2VuZCwgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9uc10+ID0+IHtcbiAgICAgIC8vIGV4dHJhY3QgYmFja2VuZCBoaW50cyBmcm9tIHNlc3Npb24gb3B0aW9uc1xuICAgICAgY29uc3QgZXBzID0gb3B0aW9ucy5leGVjdXRpb25Qcm92aWRlcnMgfHwgW107XG4gICAgICBjb25zdCBiYWNrZW5kSGludHMgPSBlcHMubWFwKGkgPT4gdHlwZW9mIGkgPT09ICdzdHJpbmcnID8gaSA6IGkubmFtZSk7XG4gICAgICBjb25zdCBiYWNrZW5kTmFtZXMgPSBiYWNrZW5kSGludHMubGVuZ3RoID09PSAwID8gYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5IDogYmFja2VuZEhpbnRzO1xuXG4gICAgICAvLyB0cnkgdG8gcmVzb2x2ZSBhbmQgaW5pdGlhbGl6ZSBhbGwgcmVxdWVzdGVkIGJhY2tlbmRzXG4gICAgICBsZXQgYmFja2VuZDogQmFja2VuZHx1bmRlZmluZWQ7XG4gICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgIGNvbnN0IGF2YWlsYWJsZUJhY2tlbmROYW1lcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgZm9yIChjb25zdCBiYWNrZW5kTmFtZSBvZiBiYWNrZW5kTmFtZXMpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZVJlc3VsdCA9IGF3YWl0IHRyeVJlc29sdmVBbmRJbml0aWFsaXplQmFja2VuZChiYWNrZW5kTmFtZSk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZVJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaCh7bmFtZTogYmFja2VuZE5hbWUsIGVycjogcmVzb2x2ZVJlc3VsdH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghYmFja2VuZCkge1xuICAgICAgICAgICAgYmFja2VuZCA9IHJlc29sdmVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiYWNrZW5kID09PSByZXNvbHZlUmVzdWx0KSB7XG4gICAgICAgICAgICBhdmFpbGFibGVCYWNrZW5kTmFtZXMuYWRkKGJhY2tlbmROYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gaWYgbm8gYmFja2VuZCBpcyBhdmFpbGFibGUsIHRocm93IGVycm9yLlxuICAgICAgaWYgKCFiYWNrZW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gYXZhaWxhYmxlIGJhY2tlbmQgZm91bmQuIEVSUjogJHtlcnJvcnMubWFwKGUgPT4gYFske2UubmFtZX1dICR7ZS5lcnJ9YCkuam9pbignLCAnKX1gKTtcbiAgICAgIH1cblxuICAgICAgLy8gZm9yIGVhY2ggZXhwbGljaXRseSByZXF1ZXN0ZWQgYmFja2VuZCwgaWYgaXQncyBub3QgYXZhaWxhYmxlLCBvdXRwdXQgd2FybmluZyBtZXNzYWdlLlxuICAgICAgZm9yIChjb25zdCB7bmFtZSwgZXJyfSBvZiBlcnJvcnMpIHtcbiAgICAgICAgaWYgKGJhY2tlbmRIaW50cy5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgY29uc29sZS53YXJuKGByZW1vdmluZyByZXF1ZXN0ZWQgZXhlY3V0aW9uIHByb3ZpZGVyIFwiJHtcbiAgICAgICAgICAgICAgbmFtZX1cIiBmcm9tIHNlc3Npb24gb3B0aW9ucyBiZWNhdXNlIGl0IGlzIG5vdCBhdmFpbGFibGU6ICR7ZXJyfWApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZpbHRlcmVkRXBzID0gZXBzLmZpbHRlcihpID0+IGF2YWlsYWJsZUJhY2tlbmROYW1lcy5oYXModHlwZW9mIGkgPT09ICdzdHJpbmcnID8gaSA6IGkubmFtZSkpO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBiYWNrZW5kLCBuZXcgUHJveHkob3B0aW9ucywge1xuICAgICAgICAgIGdldDogKHRhcmdldCwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdleGVjdXRpb25Qcm92aWRlcnMnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZEVwcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIF07XG4gICAgfTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtJbmZlcmVuY2VTZXNzaW9ufSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcbmltcG9ydCB7T25ueFZhbHVlfSBmcm9tICcuL29ubngtdmFsdWUuanMnO1xuaW1wb3J0IHtUcmFpbmluZ1Nlc3Npb259IGZyb20gJy4vdHJhaW5pbmctc2Vzc2lvbi5qcyc7XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgU2Vzc2lvbkhhbmRsZXIge1xuICB0eXBlIEZlZWRzVHlwZSA9IHtbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlfTtcbiAgdHlwZSBGZXRjaGVzVHlwZSA9IHtbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlIHwgbnVsbH07XG4gIHR5cGUgUmV0dXJuVHlwZSA9IHtbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlfTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHNoYXJlZCBTZXNzaW9uSGFuZGxlciBmdW5jdGlvbmFsaXR5XG4gKlxuICogQGlnbm9yZVxuICovXG5pbnRlcmZhY2UgU2Vzc2lvbkhhbmRsZXIge1xuICBkaXNwb3NlKCk6IFByb21pc2U8dm9pZD47XG5cbiAgcmVhZG9ubHkgaW5wdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG4gIHJlYWRvbmx5IG91dHB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBoYW5kbGVyIGluc3RhbmNlIG9mIGFuIGluZmVyZW5jZSBzZXNzaW9uLlxuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbmZlcmVuY2VTZXNzaW9uSGFuZGxlciBleHRlbmRzIFNlc3Npb25IYW5kbGVyIHtcbiAgc3RhcnRQcm9maWxpbmcoKTogdm9pZDtcbiAgZW5kUHJvZmlsaW5nKCk6IHZvaWQ7XG5cbiAgcnVuKGZlZWRzOiBTZXNzaW9uSGFuZGxlci5GZWVkc1R5cGUsIGZldGNoZXM6IFNlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlLFxuICAgICAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTxTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlPjtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBoYW5kbGVyIGluc3RhbmNlIG9mIGEgdHJhaW5pbmcgaW5mZXJlbmNlIHNlc3Npb24uXG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYWluaW5nU2Vzc2lvbkhhbmRsZXIgZXh0ZW5kcyBTZXNzaW9uSGFuZGxlciB7XG4gIHJlYWRvbmx5IGV2YWxJbnB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcbiAgcmVhZG9ubHkgZXZhbE91dHB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICBsYXp5UmVzZXRHcmFkKCk6IFByb21pc2U8dm9pZD47XG4gIHJ1blRyYWluU3RlcChcbiAgICAgIGZlZWRzOiBTZXNzaW9uSGFuZGxlci5GZWVkc1R5cGUsIGZldGNoZXM6IFNlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlLFxuICAgICAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTxTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlPjtcbiAgcnVuT3B0aW1pemVyU3RlcChvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+O1xuICBydW5FdmFsU3RlcChcbiAgICAgIGZlZWRzOiBTZXNzaW9uSGFuZGxlci5GZWVkc1R5cGUsIGZldGNoZXM6IFNlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlLFxuICAgICAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTxTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlPjtcblxuICBnZXRQYXJhbWV0ZXJzU2l6ZSh0cmFpbmFibGVPbmx5OiBib29sZWFuKTogUHJvbWlzZTxudW1iZXI+O1xuICBsb2FkUGFyYW1ldGVyc0J1ZmZlcihidWZmZXI6IFVpbnQ4QXJyYXksIHRyYWluYWJsZU9ubHk6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+O1xuICBnZXRDb250aWd1b3VzUGFyYW1ldGVycyh0cmFpbmFibGVPbmx5OiBib29sZWFuKTogUHJvbWlzZTxPbm54VmFsdWU+O1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIGJhY2tlbmQgdGhhdCBwcm92aWRlcyBpbXBsZW1lbnRhdGlvbiBvZiBtb2RlbCBpbmZlcmVuY2luZy5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmFja2VuZCB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBiYWNrZW5kIGFzeW5jaHJvbm91c2x5LiBTaG91bGQgdGhyb3cgd2hlbiBmYWlsZWQuXG4gICAqL1xuICBpbml0KGJhY2tlbmROYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKHVyaU9yQnVmZmVyOiBzdHJpbmd8VWludDhBcnJheSwgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOlxuICAgICAgUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj47XG5cbiAgY3JlYXRlVHJhaW5pbmdTZXNzaW9uSGFuZGxlcj9cbiAgICAgIChjaGVja3BvaW50U3RhdGVVcmlPckJ1ZmZlcjogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyLCB0cmFpbk1vZGVsVXJpT3JCdWZmZXI6IFRyYWluaW5nU2Vzc2lvbi5VcmlPckJ1ZmZlcixcbiAgICAgICBldmFsTW9kZWxVcmlPckJ1ZmZlcjogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyLCBvcHRpbWl6ZXJNb2RlbFVyaU9yQnVmZmVyOiBUcmFpbmluZ1Nlc3Npb24uVXJpT3JCdWZmZXIsXG4gICAgICAgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8VHJhaW5pbmdTZXNzaW9uSGFuZGxlcj47XG59XG5cbmV4cG9ydCB7cmVnaXN0ZXJCYWNrZW5kfSBmcm9tICcuL2JhY2tlbmQtaW1wbC5qcyc7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgL2pzL3NjcmlwdHMvdXBkYXRlLXZlcnNpb24udHNcbi8vIERvIG5vdCBtb2RpZnkgZmlsZSBjb250ZW50IG1hbnVhbGx5LlxuXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9ICcxLjE5LjAnO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0Vudn0gZnJvbSAnLi9lbnYuanMnO1xuaW1wb3J0IHt2ZXJzaW9ufSBmcm9tICcuL3ZlcnNpb24uanMnO1xuXG50eXBlIExvZ0xldmVsVHlwZSA9IEVudlsnbG9nTGV2ZWwnXTtcblxubGV0IGxvZ0xldmVsVmFsdWU6IFJlcXVpcmVkPExvZ0xldmVsVHlwZT4gPSAnd2FybmluZyc7XG5cbmV4cG9ydCBjb25zdCBlbnY6IEVudiA9IHtcbiAgd2FzbToge30gYXMgRW52LldlYkFzc2VtYmx5RmxhZ3MsXG4gIHdlYmdsOiB7fSBhcyBFbnYuV2ViR0xGbGFncyxcbiAgd2ViZ3B1OiB7fSBhcyBFbnYuV2ViR3B1RmxhZ3MsXG4gIHZlcnNpb25zOiB7Y29tbW9uOiB2ZXJzaW9ufSxcblxuICBzZXQgbG9nTGV2ZWwodmFsdWU6IExvZ0xldmVsVHlwZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8IFsndmVyYm9zZScsICdpbmZvJywgJ3dhcm5pbmcnLCAnZXJyb3InLCAnZmF0YWwnXS5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHt2YWx1ZX1gKTtcbiAgICB9XG4gICAgbG9nTGV2ZWxWYWx1ZSA9IHZhbHVlO1xuICB9LFxuICBnZXQgbG9nTGV2ZWwoKTogUmVxdWlyZWQ8TG9nTGV2ZWxUeXBlPiB7XG4gICAgcmV0dXJuIGxvZ0xldmVsVmFsdWU7XG4gIH0sXG59O1xuXG4vLyBzZXQgcHJvcGVydHkgJ2xvZ0xldmVsJyBzbyB0aGF0IHRoZXkgY2FuIGJlIGNvcnJlY3RseSB0cmFuc2ZlcnJlZCB0byB3b3JrZXIgYnkgYHBvc3RNZXNzYWdlKClgLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGVudiwgJ2xvZ0xldmVsJywge2VudW1lcmFibGU6IHRydWV9KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtlbnYgYXMgZW52SW1wbH0gZnJvbSAnLi9lbnYtaW1wbC5qcyc7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBFbnYge1xuICBleHBvcnQgdHlwZSBXYXNtUGF0aFByZWZpeCA9IHN0cmluZztcbiAgZXhwb3J0IGludGVyZmFjZSBXYXNtRmlsZVBhdGhzIHtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHRoZSBvdmVycmlkZSBwYXRoIGZvciB0aGUgbWFpbiAud2FzbSBmaWxlLlxuICAgICAqXG4gICAgICogVGhpcyBwYXRoIHNob3VsZCBiZSBhbiBhYnNvbHV0ZSBwYXRoLlxuICAgICAqXG4gICAgICogSWYgbm90IG1vZGlmaWVkLCB0aGUgZmlsZW5hbWUgb2YgdGhlIC53YXNtIGZpbGUgaXM6XG4gICAgICogLSBgb3J0LXdhc20tc2ltZC10aHJlYWRlZC53YXNtYCBmb3IgZGVmYXVsdCBidWlsZFxuICAgICAqIC0gYG9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtYCBmb3IgSlNFUCBidWlsZCAod2l0aCBXZWJHUFUgYW5kIFdlYk5OKVxuICAgICAqIC0gYG9ydC10cmFpbmluZy13YXNtLXNpbWQtdGhyZWFkZWQud2FzbWAgZm9yIHRyYWluaW5nIGJ1aWxkXG4gICAgICovXG4gICAgd2FzbT86IFVSTHxzdHJpbmc7XG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB0aGUgb3ZlcnJpZGUgcGF0aCBmb3IgdGhlIG1haW4gLm1qcyBmaWxlLlxuICAgICAqXG4gICAgICogVGhpcyBwYXRoIHNob3VsZCBiZSBhbiBhYnNvbHV0ZSBwYXRoLlxuICAgICAqXG4gICAgICogSWYgbm90IG1vZGlmaWVkLCB0aGUgZmlsZW5hbWUgb2YgdGhlIC5tanMgZmlsZSBpczpcbiAgICAgKiAtIGBvcnQtd2FzbS1zaW1kLXRocmVhZGVkLm1qc2AgZm9yIGRlZmF1bHQgYnVpbGRcbiAgICAgKiAtIGBvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAubWpzYCBmb3IgSlNFUCBidWlsZCAod2l0aCBXZWJHUFUgYW5kIFdlYk5OKVxuICAgICAqIC0gYG9ydC10cmFpbmluZy13YXNtLXNpbWQtdGhyZWFkZWQubWpzYCBmb3IgdHJhaW5pbmcgYnVpbGRcbiAgICAgKi9cbiAgICBtanM/OiBVUkx8c3RyaW5nO1xuICB9XG4gIGV4cG9ydCB0eXBlIFdhc21QcmVmaXhPckZpbGVQYXRocyA9IFdhc21QYXRoUHJlZml4fFdhc21GaWxlUGF0aHM7XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViQXNzZW1ibHlGbGFncyB7XG4gICAgLyoqXG4gICAgICogc2V0IG9yIGdldCBudW1iZXIgb2YgdGhyZWFkKHMpLiBJZiBvbWl0dGVkIG9yIHNldCB0byAwLCBudW1iZXIgb2YgdGhyZWFkKHMpIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSBzeXN0ZW0uIElmIHNldFxuICAgICAqIHRvIDEsIG5vIHdvcmtlciB0aHJlYWQgd2lsbCBiZSBzcGF3bmVkLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IHdoZW4gV2ViQXNzZW1ibHkgbXVsdGl0aHJlYWQgZmVhdHVyZSBpcyBhdmFpbGFibGUgaW4gY3VycmVudCBjb250ZXh0LlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgMGBcbiAgICAgKi9cbiAgICBudW1UaHJlYWRzPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogc2V0IG9yIGdldCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRvIGVuYWJsZSBTSU1ELiBJZiBzZXQgdG8gZmFsc2UsIFNJTUQgd2lsbCBiZSBmb3JjZWx5IGRpc2FibGVkLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IHdoZW4gV2ViQXNzZW1ibHkgU0lNRCBmZWF0dXJlIGlzIGF2YWlsYWJsZSBpbiBjdXJyZW50IGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQuIFNpbmNlIFNJTUQgaXMgc3VwcG9ydGVkIGJ5IGFsbCBtYWpvciBKYXZhU2NyaXB0IGVuZ2luZXMsIG5vbi1TSU1EXG4gICAgICogYnVpbGQgaXMgbm8gbG9uZ2VyIHByb3ZpZGVkLiBUaGlzIHByb3BlcnR5IHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZS5cbiAgICAgKiBAZGVmYXVsdFZhbHVlIGB0cnVlYFxuICAgICAqL1xuICAgIHNpbWQ/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogc2V0IG9yIGdldCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRvIGVuYWJsZSB0cmFjZS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgZW52LnRyYWNlYCBpbnN0ZWFkLiBJZiBgZW52LnRyYWNlYCBpcyBzZXQsIHRoaXMgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgICAqL1xuICAgIHRyYWNlPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgYSBudW1iZXIgc3BlY2lmeWluZyB0aGUgdGltZW91dCBmb3IgaW5pdGlhbGl6YXRpb24gb2YgV2ViQXNzZW1ibHkgYmFja2VuZCwgaW4gbWlsbGlzZWNvbmRzLiBBIHplcm9cbiAgICAgKiB2YWx1ZSBpbmRpY2F0ZXMgbm8gdGltZW91dCBpcyBzZXQuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGAwYFxuICAgICAqL1xuICAgIGluaXRUaW1lb3V0PzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogU2V0IGEgY3VzdG9tIFVSTCBwcmVmaXggdG8gdGhlIC53YXNtLy5tanMgZmlsZXMsIG9yIGFuIG9iamVjdCBvZiBvdmVycmlkZXMgZm9yIGJvdGggLndhc20vLm1qcyBmaWxlLiBUaGUgb3ZlcnJpZGVcbiAgICAgKiBwYXRoIHNob3VsZCBiZSBhbiBhYnNvbHV0ZSBwYXRoLlxuICAgICAqL1xuICAgIHdhc21QYXRocz86IFdhc21QcmVmaXhPckZpbGVQYXRocztcblxuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgYSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0byBwcm94eSB0aGUgZXhlY3V0aW9uIG9mIG1haW4gdGhyZWFkIHRvIGEgd29ya2VyIHRocmVhZC5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgICAqL1xuICAgIHByb3h5PzogYm9vbGVhbjtcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR0xGbGFncyB7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgV2ViR0wgQ29udGV4dCBJRCAod2ViZ2wgb3Igd2ViZ2wyKS5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYCd3ZWJnbDInYFxuICAgICAqL1xuICAgIGNvbnRleHRJZD86ICd3ZWJnbCd8J3dlYmdsMic7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBXZWJHTCByZW5kZXJpbmcgY29udGV4dC5cbiAgICAgKi9cbiAgICByZWFkb25seSBjb250ZXh0OiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgbWF4aW11bSBiYXRjaCBzaXplIGZvciBtYXRtdWwuIDAgbWVhbnMgdG8gZGlzYWJsZSBiYXRjaGluZy5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgbWF0bXVsTWF4QmF0Y2hTaXplPzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIHRleHR1cmUgY2FjaGUgbW9kZS5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYCdmdWxsJ2BcbiAgICAgKi9cbiAgICB0ZXh0dXJlQ2FjaGVNb2RlPzogJ2luaXRpYWxpemVyT25seSd8J2Z1bGwnO1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIHBhY2tlZCB0ZXh0dXJlIG1vZGVcbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgICAqL1xuICAgIHBhY2s/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgd2hldGhlciBlbmFibGUgYXN5bmMgZG93bmxvYWQuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICAgKi9cbiAgICBhc3luYz86IGJvb2xlYW47XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkdwdVByb2ZpbGluZ0RhdGFWMVRlbnNvck1ldGFkYXRhIHtcbiAgICBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcbiAgICBkYXRhVHlwZTogc3RyaW5nO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR3B1UHJvZmlsaW5nRGF0YVYxIHtcbiAgICB2ZXJzaW9uOiAxO1xuICAgIGlucHV0c01ldGFkYXRhOiByZWFkb25seSBXZWJHcHVQcm9maWxpbmdEYXRhVjFUZW5zb3JNZXRhZGF0YVtdO1xuICAgIG91dHB1dHNNZXRhZGF0YTogcmVhZG9ubHkgV2ViR3B1UHJvZmlsaW5nRGF0YVYxVGVuc29yTWV0YWRhdGFbXTtcbiAgICBrZXJuZWxJZDogbnVtYmVyO1xuICAgIGtlcm5lbFR5cGU6IHN0cmluZztcbiAgICBrZXJuZWxOYW1lOiBzdHJpbmc7XG4gICAgcHJvZ3JhbU5hbWU6IHN0cmluZztcbiAgICBzdGFydFRpbWU6IG51bWJlcjtcbiAgICBlbmRUaW1lOiBudW1iZXI7XG4gIH1cblxuICBleHBvcnQgdHlwZSBXZWJHcHVQcm9maWxpbmdEYXRhID0gV2ViR3B1UHJvZmlsaW5nRGF0YVYxO1xuXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR3B1RmxhZ3Mge1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIHByb2ZpbGluZyBtb2RlLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGBlbnYud2ViZ3B1LnByb2ZpbGluZy5tb2RlYCBpbnN0ZWFkLiBJZiBgZW52LndlYmdwdS5wcm9maWxpbmcubW9kZWAgaXMgc2V0LCB0aGlzIHByb3BlcnR5IHdpbGwgYmVcbiAgICAgKiBpZ25vcmVkLlxuICAgICAqL1xuICAgIHByb2ZpbGluZ01vZGU/OiAnb2ZmJ3wnZGVmYXVsdCc7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgcHJvZmlsaW5nIGNvbmZpZ3VyYXRpb24uXG4gICAgICovXG4gICAgcHJvZmlsaW5nPzoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgb3IgZ2V0IHRoZSBwcm9maWxpbmcgbW9kZS5cbiAgICAgICAqXG4gICAgICAgKiBAZGVmYXVsdFZhbHVlIGAnb2ZmJ2BcbiAgICAgICAqL1xuICAgICAgbW9kZT86ICdvZmYnfCdkZWZhdWx0JztcblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgb3IgZ2V0IGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBhIHByb2ZpbGluZyBkYXRhIGlzIHJlY2VpdmVkLiBJZiBub3Qgc2V0LCB0aGUgcHJvZmlsaW5nIGRhdGEgd2lsbCBiZVxuICAgICAgICogcHJpbnRlZCB0byBjb25zb2xlLlxuICAgICAgICovXG4gICAgICBvbmRhdGE/OiAoZGF0YTogV2ViR3B1UHJvZmlsaW5nRGF0YSkgPT4gdm9pZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIHBvd2VyIHByZWZlcmVuY2UuXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgb25seSBoYXMgZWZmZWN0IGJlZm9yZSB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuIFRoZSB2YWx1ZSB3aWxsIGJlXG4gICAgICogdXNlZCBhcyBvcHRpb25zIGZvciBgbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcigpYC5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9ncHV3ZWIuZ2l0aHViLmlvL2dwdXdlYi8jZGljdGRlZi1ncHVyZXF1ZXN0YWRhcHRlcm9wdGlvbnN9IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGB1bmRlZmluZWRgXG4gICAgICovXG4gICAgcG93ZXJQcmVmZXJlbmNlPzogJ2xvdy1wb3dlcid8J2hpZ2gtcGVyZm9ybWFuY2UnO1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIGZvcmNlIGZhbGxiYWNrIGFkYXB0ZXIgZmxhZy5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSBvbmx5IGhhcyBlZmZlY3QgYmVmb3JlIHRoZSBmaXJzdCBXZWJHUFUgaW5mZXJlbmNlIHNlc3Npb24gaXMgY3JlYXRlZC4gVGhlIHZhbHVlIHdpbGwgYmVcbiAgICAgKiB1c2VkIGFzIG9wdGlvbnMgZm9yIGBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKClgLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBodHRwczovL2dwdXdlYi5naXRodWIuaW8vZ3B1d2ViLyNkaWN0ZGVmLWdwdXJlcXVlc3RhZGFwdGVyb3B0aW9uc30gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYHVuZGVmaW5lZGBcbiAgICAgKi9cbiAgICBmb3JjZUZhbGxiYWNrQWRhcHRlcj86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgYWRhcHRlciBmb3IgV2ViR1BVLlxuICAgICAqXG4gICAgICogU2V0dGluZyB0aGlzIHByb3BlcnR5IG9ubHkgaGFzIGVmZmVjdCBiZWZvcmUgdGhlIGZpcnN0IFdlYkdQVSBpbmZlcmVuY2Ugc2Vzc2lvbiBpcyBjcmVhdGVkLiBUaGUgdmFsdWUgd2lsbCBiZVxuICAgICAqIHVzZWQgYXMgdGhlIEdQVSBhZGFwdGVyIGZvciB0aGUgdW5kZXJseWluZyBXZWJHUFUgYmFja2VuZCB0byBjcmVhdGUgR1BVIGRldmljZS5cbiAgICAgKlxuICAgICAqIElmIHRoaXMgcHJvcGVydHkgaXMgbm90IHNldCwgaXQgd2lsbCBiZSBhdmFpbGFibGUgdG8gZ2V0IGFmdGVyIHRoZSBmaXJzdCBXZWJHUFUgaW5mZXJlbmNlIHNlc3Npb24gaXMgY3JlYXRlZC4gVGhlXG4gICAgICogdmFsdWUgd2lsbCBiZSB0aGUgR1BVIGFkYXB0ZXIgdGhhdCBjcmVhdGVkIGJ5IHRoZSB1bmRlcmx5aW5nIFdlYkdQVSBiYWNrZW5kLlxuICAgICAqXG4gICAgICogV2hlbiB1c2Ugd2l0aCBUeXBlU2NyaXB0LCB0aGUgdHlwZSBvZiB0aGlzIHByb3BlcnR5IGlzIGBHUFVBZGFwdGVyYCBkZWZpbmVkIGluIFwiQHdlYmdwdS90eXBlc1wiLlxuICAgICAqIFVzZSBgY29uc3QgYWRhcHRlciA9IGVudi53ZWJncHUuYWRhcHRlciBhcyBHUFVBZGFwdGVyO2AgaW4gVHlwZVNjcmlwdCB0byBhY2Nlc3MgdGhpcyBwcm9wZXJ0eSB3aXRoIGNvcnJlY3QgdHlwZS5cbiAgICAgKlxuICAgICAqIHNlZSBjb21tZW50cyBvbiB7QGxpbmsgVGVuc29yLkdwdUJ1ZmZlclR5cGV9XG4gICAgICovXG4gICAgYWRhcHRlcjogdW5rbm93bjtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRldmljZSBmb3IgV2ViR1BVLlxuICAgICAqXG4gICAgICogVGhpcyBwcm9wZXJ0eSBpcyBvbmx5IGF2YWlsYWJsZSBhZnRlciB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBXaGVuIHVzZSB3aXRoIFR5cGVTY3JpcHQsIHRoZSB0eXBlIG9mIHRoaXMgcHJvcGVydHkgaXMgYEdQVURldmljZWAgZGVmaW5lZCBpbiBcIkB3ZWJncHUvdHlwZXNcIi5cbiAgICAgKiBVc2UgYGNvbnN0IGRldmljZSA9IGVudi53ZWJncHUuZGV2aWNlIGFzIEdQVURldmljZTtgIGluIFR5cGVTY3JpcHQgdG8gYWNjZXNzIHRoaXMgcHJvcGVydHkgd2l0aCBjb3JyZWN0IHR5cGUuXG4gICAgICpcbiAgICAgKiBzZWUgY29tbWVudHMgb24ge0BsaW5rIFRlbnNvci5HcHVCdWZmZXJUeXBlfSBmb3IgbW9yZSBkZXRhaWxzIGFib3V0IHdoeSBub3QgdXNlIHR5cGVzIGRlZmluZWQgaW4gXCJAd2ViZ3B1L3R5cGVzXCIuXG4gICAgICovXG4gICAgcmVhZG9ubHkgZGV2aWNlOiB1bmtub3duO1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgd2hldGhlciB2YWxpZGF0ZSBpbnB1dCBjb250ZW50LlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAgICovXG4gICAgdmFsaWRhdGVJbnB1dENvbnRlbnQ/OiBib29sZWFuO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRW52IHtcbiAgLyoqXG4gICAqIHNldCB0aGUgc2V2ZXJpdHkgbGV2ZWwgZm9yIGxvZ2dpbmcuXG4gICAqXG4gICAqIEBkZWZhdWx0VmFsdWUgYCd3YXJuaW5nJ2BcbiAgICovXG4gIGxvZ0xldmVsPzogJ3ZlcmJvc2UnfCdpbmZvJ3wnd2FybmluZyd8J2Vycm9yJ3wnZmF0YWwnO1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZSB3aGV0aGVyIHJ1biBpbiBkZWJ1ZyBtb2RlLlxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICovXG4gIGRlYnVnPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogc2V0IG9yIGdldCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRvIGVuYWJsZSB0cmFjZS5cbiAgICpcbiAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAqL1xuICB0cmFjZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEdldCB2ZXJzaW9uIG9mIHRoZSBjdXJyZW50IHBhY2thZ2UuXG4gICAqL1xuICByZWFkb25seSB2ZXJzaW9uczoge1xuICAgIHJlYWRvbmx5IGNvbW1vbjogc3RyaW5nO1xuICAgIHJlYWRvbmx5IHdlYj86IHN0cmluZztcbiAgICByZWFkb25seSBub2RlPzogc3RyaW5nO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICByZWFkb25seSAncmVhY3QtbmF0aXZlJz86IHN0cmluZztcbiAgfTtcblxuICAvKipcbiAgICogUmVwcmVzZW50IGEgc2V0IG9mIGZsYWdzIGZvciBXZWJBc3NlbWJseVxuICAgKi9cbiAgcmVhZG9ubHkgd2FzbTogRW52LldlYkFzc2VtYmx5RmxhZ3M7XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudCBhIHNldCBvZiBmbGFncyBmb3IgV2ViR0xcbiAgICovXG4gIHJlYWRvbmx5IHdlYmdsOiBFbnYuV2ViR0xGbGFncztcblxuICAvKipcbiAgICogUmVwcmVzZW50IGEgc2V0IG9mIGZsYWdzIGZvciBXZWJHUFVcbiAgICovXG4gIHJlYWRvbmx5IHdlYmdwdTogRW52LldlYkdwdUZsYWdzO1xuXG4gIFtuYW1lOiBzdHJpbmddOiB1bmtub3duO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIHNldCBvZiBmbGFncyBhcyBhIGdsb2JhbCBzaW5nbGV0b24uXG4gKi9cbmV4cG9ydCBjb25zdCBlbnY6IEVudiA9IGVudkltcGw7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yVG9EYXRhVXJsT3B0aW9ucywgVGVuc29yVG9JbWFnZURhdGFPcHRpb25zfSBmcm9tICcuL3RlbnNvci1jb252ZXJzaW9uLmpzJztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuL3RlbnNvci5qcyc7XG5cbi8qKlxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLnRvRGF0YVVSTCgpXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JUb0RhdGFVUkwgPSAodGVuc29yOiBUZW5zb3IsIG9wdGlvbnM/OiBUZW5zb3JUb0RhdGFVcmxPcHRpb25zKTogc3RyaW5nID0+IHtcbiAgY29uc3QgY2FudmFzID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpIDogKG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSkpO1xuICBjYW52YXMud2lkdGggPSB0ZW5zb3IuZGltc1szXTtcbiAgY2FudmFzLmhlaWdodCA9IHRlbnNvci5kaW1zWzJdO1xuICBjb25zdCBwaXhlbHMyRENvbnRleHQgPVxuICAgICAgY2FudmFzLmdldENvbnRleHQoJzJkJykgYXMgKENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB8IE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB8IG51bGwpO1xuXG4gIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgIC8vIERlZmF1bHQgdmFsdWVzIGZvciBoZWlnaHQgYW5kIHdpZHRoICYgZm9ybWF0XG4gICAgbGV0IHdpZHRoOiBudW1iZXI7XG4gICAgbGV0IGhlaWdodDogbnVtYmVyO1xuICAgIGlmIChvcHRpb25zPy50ZW5zb3JMYXlvdXQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnRlbnNvckxheW91dCA9PT0gJ05IV0MnKSB7XG4gICAgICB3aWR0aCA9IHRlbnNvci5kaW1zWzJdO1xuICAgICAgaGVpZ2h0ID0gdGVuc29yLmRpbXNbM107XG4gICAgfSBlbHNlIHsgIC8vIERlZmF1bHQgbGF5b3V0IGlzIE5DV0hcbiAgICAgIHdpZHRoID0gdGVuc29yLmRpbXNbM107XG4gICAgICBoZWlnaHQgPSB0ZW5zb3IuZGltc1syXTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnB1dGZvcm1hdCA9IG9wdGlvbnM/LmZvcm1hdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mb3JtYXQgOiAnUkdCJztcblxuICAgIGNvbnN0IG5vcm0gPSBvcHRpb25zPy5ub3JtO1xuICAgIGxldCBub3JtTWVhbjogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gICAgbGV0IG5vcm1CaWFzOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgICBpZiAobm9ybSA9PT0gdW5kZWZpbmVkIHx8IG5vcm0ubWVhbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBub3JtTWVhbiA9IFsyNTUsIDI1NSwgMjU1LCAyNTVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIChub3JtLm1lYW4pID09PSAnbnVtYmVyJykge1xuICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW5dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybU1lYW4gPSBbbm9ybS5tZWFuWzBdLCBub3JtLm1lYW5bMV0sIG5vcm0ubWVhblsyXSwgMF07XG4gICAgICAgIGlmIChub3JtLm1lYW5bM10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vcm1NZWFuWzNdID0gbm9ybS5tZWFuWzNdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub3JtID09PSB1bmRlZmluZWQgfHwgbm9ybS5iaWFzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5vcm1CaWFzID0gWzAsIDAsIDAsIDBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIChub3JtLmJpYXMpID09PSAnbnVtYmVyJykge1xuICAgICAgICBub3JtQmlhcyA9IFtub3JtLmJpYXMsIG5vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzWzBdLCBub3JtLmJpYXNbMV0sIG5vcm0uYmlhc1syXSwgMF07XG4gICAgICAgIGlmIChub3JtLmJpYXNbM10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vcm1CaWFzWzNdID0gbm9ybS5iaWFzWzNdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyaWRlID0gaGVpZ2h0ICogd2lkdGg7XG4gICAgLy8gRGVmYXVsdCBwb2ludGVyIGFzc2lnbm1lbnRzXG4gICAgbGV0IHJUZW5zb3JQb2ludGVyID0gMCwgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUsIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMiwgYVRlbnNvclBvaW50ZXIgPSAtMTtcblxuICAgIC8vIFVwZGF0aW5nIHRoZSBwb2ludGVyIGFzc2lnbm1lbnRzIGJhc2VkIG9uIHRoZSBpbnB1dCBpbWFnZSBmb3JtYXRcbiAgICBpZiAoaW5wdXRmb3JtYXQgPT09ICdSR0JBJykge1xuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgICBhVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDM7XG4gICAgfSBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQicpIHtcbiAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRmb3JtYXQgPT09ICdSQkcnKSB7XG4gICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICAgICAgY29uc3QgUiA9ICgodGVuc29yLmRhdGFbclRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzBdKSAqIG5vcm1NZWFuWzBdOyAgLy8gUiB2YWx1ZVxuICAgICAgICBjb25zdCBHID0gKCh0ZW5zb3IuZGF0YVtnVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbMV0pICogbm9ybU1lYW5bMV07ICAvLyBHIHZhbHVlXG4gICAgICAgIGNvbnN0IEIgPSAoKHRlbnNvci5kYXRhW2JUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1syXSkgKiBub3JtTWVhblsyXTsgIC8vIEIgdmFsdWVcbiAgICAgICAgY29uc3QgQSA9IGFUZW5zb3JQb2ludGVyID09PSAtMSA/XG4gICAgICAgICAgICAyNTUgOlxuICAgICAgICAgICAgKCh0ZW5zb3IuZGF0YVthVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbM10pICogbm9ybU1lYW5bM107ICAvLyBBIHZhbHVlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kc1xuICAgICAgICBwaXhlbHMyRENvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIFIgKyAnLCcgKyBHICsgJywnICsgQiArICcsJyArIEEgKyAnKSc7XG4gICAgICAgIHBpeGVsczJEQ29udGV4dC5maWxsUmVjdChqLCBpLCAxLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCd0b0RhdGFVUkwnIGluIGNhbnZhcykge1xuICAgICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b0RhdGFVUkwgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IudG9JbWFnZURhdGEoKVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yVG9JbWFnZURhdGEgPSAodGVuc29yOiBUZW5zb3IsIG9wdGlvbnM/OiBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnMpOiBJbWFnZURhdGEgPT4ge1xuICBjb25zdCBwaXhlbHMyRENvbnRleHQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID9cbiAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJykgOlxuICAgICAgbmV3IE9mZnNjcmVlbkNhbnZhcygxLCAxKS5nZXRDb250ZXh0KCcyZCcpIGFzIE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgbGV0IGltYWdlOiBJbWFnZURhdGE7XG4gIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgIC8vIERlZmF1bHQgdmFsdWVzIGZvciBoZWlnaHQgYW5kIHdpZHRoICYgZm9ybWF0XG4gICAgbGV0IHdpZHRoOiBudW1iZXI7XG4gICAgbGV0IGhlaWdodDogbnVtYmVyO1xuICAgIGxldCBjaGFubmVsczogbnVtYmVyO1xuICAgIGlmIChvcHRpb25zPy50ZW5zb3JMYXlvdXQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnRlbnNvckxheW91dCA9PT0gJ05IV0MnKSB7XG4gICAgICB3aWR0aCA9IHRlbnNvci5kaW1zWzJdO1xuICAgICAgaGVpZ2h0ID0gdGVuc29yLmRpbXNbMV07XG4gICAgICBjaGFubmVscyA9IHRlbnNvci5kaW1zWzNdO1xuICAgIH0gZWxzZSB7ICAvLyBEZWZhdWx0IGxheW91dCBpcyBOQ1dIXG4gICAgICB3aWR0aCA9IHRlbnNvci5kaW1zWzNdO1xuICAgICAgaGVpZ2h0ID0gdGVuc29yLmRpbXNbMl07XG4gICAgICBjaGFubmVscyA9IHRlbnNvci5kaW1zWzFdO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dGZvcm1hdCA9IG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IChvcHRpb25zLmZvcm1hdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mb3JtYXQgOiAnUkdCJykgOiAnUkdCJztcblxuICAgIGNvbnN0IG5vcm0gPSBvcHRpb25zPy5ub3JtO1xuICAgIGxldCBub3JtTWVhbjogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gICAgbGV0IG5vcm1CaWFzOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgICBpZiAobm9ybSA9PT0gdW5kZWZpbmVkIHx8IG5vcm0ubWVhbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBub3JtTWVhbiA9IFsyNTUsIDI1NSwgMjU1LCAyNTVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIChub3JtLm1lYW4pID09PSAnbnVtYmVyJykge1xuICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW5dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybU1lYW4gPSBbbm9ybS5tZWFuWzBdLCBub3JtLm1lYW5bMV0sIG5vcm0ubWVhblsyXSwgMjU1XTtcbiAgICAgICAgaWYgKG5vcm0ubWVhblszXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9ybU1lYW5bM10gPSBub3JtLm1lYW5bM107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vcm0gPT09IHVuZGVmaW5lZCB8fCBub3JtLmJpYXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9ybUJpYXMgPSBbMCwgMCwgMCwgMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgKG5vcm0uYmlhcykgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5vcm1CaWFzID0gW25vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhc107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtQmlhcyA9IFtub3JtLmJpYXNbMF0sIG5vcm0uYmlhc1sxXSwgbm9ybS5iaWFzWzJdLCAwXTtcbiAgICAgICAgaWYgKG5vcm0uYmlhc1szXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9ybUJpYXNbM10gPSBub3JtLmJpYXNbM107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzdHJpZGUgPSBoZWlnaHQgKiB3aWR0aDtcbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAob3B0aW9ucy5mb3JtYXQgIT09IHVuZGVmaW5lZCAmJiAoY2hhbm5lbHMgPT09IDQgJiYgb3B0aW9ucy5mb3JtYXQgIT09ICdSR0JBJykgfHxcbiAgICAgICAgICAoY2hhbm5lbHMgPT09IDMgJiYgKG9wdGlvbnMuZm9ybWF0ICE9PSAnUkdCJyAmJiBvcHRpb25zLmZvcm1hdCAhPT0gJ0JHUicpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBmb3JtYXQgZG9lc25cXCd0IG1hdGNoIGlucHV0IHRlbnNvciBkaW1zJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCBwb2ludGVyIGFzc2lnbm1lbnRzXG4gICAgY29uc3Qgc3RlcCA9IDQ7XG4gICAgbGV0IHJJbWFnZVBvaW50ZXIgPSAwLCBnSW1hZ2VQb2ludGVyID0gMSwgYkltYWdlUG9pbnRlciA9IDIsIGFJbWFnZVBvaW50ZXIgPSAzO1xuICAgIGxldCByVGVuc29yUG9pbnRlciA9IDAsIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlLCBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDIsIGFUZW5zb3JQb2ludGVyID0gLTE7XG5cbiAgICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgaW5wdXQgaW1hZ2UgZm9ybWF0XG4gICAgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkdCQScpIHtcbiAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgICAgYVRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAzO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRmb3JtYXQgPT09ICdSR0InKSB7XG4gICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICB9IGVsc2UgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkJHJykge1xuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgfVxuXG4gICAgaW1hZ2UgPSBwaXhlbHMyRENvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWlnaHQgKiB3aWR0aDtcbiAgICAgICAgIHJJbWFnZVBvaW50ZXIgKz0gc3RlcCwgZ0ltYWdlUG9pbnRlciArPSBzdGVwLCBiSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGFJbWFnZVBvaW50ZXIgKz0gc3RlcCwgaSsrKSB7XG4gICAgICBpbWFnZS5kYXRhW3JJbWFnZVBvaW50ZXJdID0gKCh0ZW5zb3IuZGF0YVtyVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbMF0pICogbm9ybU1lYW5bMF07ICAvLyBSIHZhbHVlXG4gICAgICBpbWFnZS5kYXRhW2dJbWFnZVBvaW50ZXJdID0gKCh0ZW5zb3IuZGF0YVtnVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbMV0pICogbm9ybU1lYW5bMV07ICAvLyBHIHZhbHVlXG4gICAgICBpbWFnZS5kYXRhW2JJbWFnZVBvaW50ZXJdID0gKCh0ZW5zb3IuZGF0YVtiVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbMl0pICogbm9ybU1lYW5bMl07ICAvLyBCIHZhbHVlXG4gICAgICBpbWFnZS5kYXRhW2FJbWFnZVBvaW50ZXJdID0gYVRlbnNvclBvaW50ZXIgPT09IC0xID9cbiAgICAgICAgICAyNTUgOlxuICAgICAgICAgICgodGVuc29yLmRhdGFbYVRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzNdKSAqIG5vcm1NZWFuWzNdOyAgLy8gQSB2YWx1ZVxuICAgIH1cblxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICB9XG4gIHJldHVybiBpbWFnZTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7T3B0aW9uc0RpbWVuc2lvbnMsIE9wdGlvbnNGb3JtYXQsIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycywgT3B0aW9uc1RlbnNvckZvcm1hdCwgT3B0aW9uc1RlbnNvckxheW91dCwgVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnMsIFRlbnNvckZyb21JbWFnZUJpdG1hcE9wdGlvbnMsIFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zLCBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9ucywgVGVuc29yRnJvbVRleHR1cmVPcHRpb25zLCBUZW5zb3JGcm9tVXJsT3B0aW9uc30gZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi90ZW5zb3ItaW1wbC5qcyc7XG5pbXBvcnQge1RlbnNvciBhcyBUZW5zb3JJbnRlcmZhY2V9IGZyb20gJy4vdGVuc29yLmpzJztcblxuaW50ZXJmYWNlIEJ1ZmZlclRvVGVuc29yT3B0aW9ucyBleHRlbmRzIE9wdGlvbnNEaW1lbnNpb25zLCBPcHRpb25zVGVuc29yTGF5b3V0LCBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3B0aW9uc0Zvcm1hdCwgT3B0aW9uc1RlbnNvckZvcm1hdCB7fVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gaW1hZ2Ugb2JqZWN0XG4gKlxuICogQHBhcmFtIGJ1ZmZlciAtIEV4dHJhY3RlZCBpbWFnZSBidWZmZXIgZGF0YSAtIGFzc3VtaW5nIFJHQkEgZm9ybWF0XG4gKiBAcGFyYW0gaW1hZ2VGb3JtYXQgLSBpbnB1dCBpbWFnZSBjb25maWd1cmF0aW9uIC0gcmVxdWlyZWQgY29uZmlndXJhdGlvbnMgaGVpZ2h0LCB3aWR0aCwgZm9ybWF0XG4gKiBAcGFyYW0gdGVuc29yRm9ybWF0IC0gb3V0cHV0IHRlbnNvciBjb25maWd1cmF0aW9uIC0gRGVmYXVsdCBpcyBSR0IgZm9ybWF0XG4gKi9cbmV4cG9ydCBjb25zdCBidWZmZXJUb1RlbnNvciA9IChidWZmZXI6IFVpbnQ4Q2xhbXBlZEFycmF5fHVuZGVmaW5lZCwgb3B0aW9uczogQnVmZmVyVG9UZW5zb3JPcHRpb25zKTogVGVuc29yID0+IHtcbiAgaWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBidWZmZXIgbXVzdCBiZSBkZWZpbmVkJyk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuaGVpZ2h0ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy53aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSBoZWlnaHQgYW5kIHdpZHRoIG11c3QgYmUgZGVmaW5lZCcpO1xuICB9XG4gIGlmIChvcHRpb25zLnRlbnNvckxheW91dCA9PT0gJ05IV0MnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOSFdDIFRlbnNvciBsYXlvdXQgaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgfVxuXG4gIGNvbnN0IHtoZWlnaHQsIHdpZHRofSA9IG9wdGlvbnM7XG5cbiAgY29uc3Qgbm9ybSA9IG9wdGlvbnMubm9ybSA/PyB7bWVhbjogMjU1LCBiaWFzOiAwfTtcbiAgbGV0IG5vcm1NZWFuOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgbGV0IG5vcm1CaWFzOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcblxuICBpZiAodHlwZW9mIChub3JtLm1lYW4pID09PSAnbnVtYmVyJykge1xuICAgIG5vcm1NZWFuID0gW25vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbl07XG4gIH0gZWxzZSB7XG4gICAgbm9ybU1lYW4gPSBbbm9ybS5tZWFuIVswXSwgbm9ybS5tZWFuIVsxXSwgbm9ybS5tZWFuIVsyXSwgbm9ybS5tZWFuIVszXSA/PyAyNTVdO1xuICB9XG5cbiAgaWYgKHR5cGVvZiAobm9ybS5iaWFzKSA9PT0gJ251bWJlcicpIHtcbiAgICBub3JtQmlhcyA9IFtub3JtLmJpYXMsIG5vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXNdO1xuICB9IGVsc2Uge1xuICAgIG5vcm1CaWFzID0gW25vcm0uYmlhcyFbMF0sIG5vcm0uYmlhcyFbMV0sIG5vcm0uYmlhcyFbMl0sIG5vcm0uYmlhcyFbM10gPz8gMF07XG4gIH1cblxuICBjb25zdCBpbnB1dGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZvcm1hdCA6ICdSR0JBJztcbiAgLy8gZGVmYXVsdCB2YWx1ZSBpcyBSR0JBIHNpbmNlIGltYWdlZGF0YSBhbmQgSFRNTEltYWdlRWxlbWVudCB1c2VzIGl0XG5cbiAgY29uc3Qgb3V0cHV0Zm9ybWF0ID1cbiAgICAgIG9wdGlvbnMudGVuc29yRm9ybWF0ICE9PSB1bmRlZmluZWQgPyAob3B0aW9ucy50ZW5zb3JGb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGVuc29yRm9ybWF0IDogJ1JHQicpIDogJ1JHQic7XG4gIGNvbnN0IHN0cmlkZSA9IGhlaWdodCAqIHdpZHRoO1xuICBjb25zdCBmbG9hdDMyRGF0YSA9IG91dHB1dGZvcm1hdCA9PT0gJ1JHQkEnID8gbmV3IEZsb2F0MzJBcnJheShzdHJpZGUgKiA0KSA6IG5ldyBGbG9hdDMyQXJyYXkoc3RyaWRlICogMyk7XG5cbiAgLy8gRGVmYXVsdCBwb2ludGVyIGFzc2lnbm1lbnRzXG4gIGxldCBzdGVwID0gNCwgckltYWdlUG9pbnRlciA9IDAsIGdJbWFnZVBvaW50ZXIgPSAxLCBiSW1hZ2VQb2ludGVyID0gMiwgYUltYWdlUG9pbnRlciA9IDM7XG4gIGxldCByVGVuc29yUG9pbnRlciA9IDAsIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlLCBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDIsIGFUZW5zb3JQb2ludGVyID0gLTE7XG5cbiAgLy8gVXBkYXRpbmcgdGhlIHBvaW50ZXIgYXNzaWdubWVudHMgYmFzZWQgb24gdGhlIGlucHV0IGltYWdlIGZvcm1hdFxuICBpZiAoaW5wdXRmb3JtYXQgPT09ICdSR0InKSB7XG4gICAgc3RlcCA9IDM7XG4gICAgckltYWdlUG9pbnRlciA9IDA7XG4gICAgZ0ltYWdlUG9pbnRlciA9IDE7XG4gICAgYkltYWdlUG9pbnRlciA9IDI7XG4gICAgYUltYWdlUG9pbnRlciA9IC0xO1xuICB9XG5cbiAgLy8gVXBkYXRpbmcgdGhlIHBvaW50ZXIgYXNzaWdubWVudHMgYmFzZWQgb24gdGhlIG91dHB1dCB0ZW5zb3IgZm9ybWF0XG4gIGlmIChvdXRwdXRmb3JtYXQgPT09ICdSR0JBJykge1xuICAgIGFUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMztcbiAgfSBlbHNlIGlmIChvdXRwdXRmb3JtYXQgPT09ICdSQkcnKSB7XG4gICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgfSBlbHNlIGlmIChvdXRwdXRmb3JtYXQgPT09ICdCR1InKSB7XG4gICAgYlRlbnNvclBvaW50ZXIgPSAwO1xuICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgIHJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaWRlO1xuICAgICAgIGkrKywgckltYWdlUG9pbnRlciArPSBzdGVwLCBiSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGdJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYUltYWdlUG9pbnRlciArPSBzdGVwKSB7XG4gICAgZmxvYXQzMkRhdGFbclRlbnNvclBvaW50ZXIrK10gPSAoYnVmZmVyW3JJbWFnZVBvaW50ZXJdICsgbm9ybUJpYXNbMF0pIC8gbm9ybU1lYW5bMF07XG4gICAgZmxvYXQzMkRhdGFbZ1RlbnNvclBvaW50ZXIrK10gPSAoYnVmZmVyW2dJbWFnZVBvaW50ZXJdICsgbm9ybUJpYXNbMV0pIC8gbm9ybU1lYW5bMV07XG4gICAgZmxvYXQzMkRhdGFbYlRlbnNvclBvaW50ZXIrK10gPSAoYnVmZmVyW2JJbWFnZVBvaW50ZXJdICsgbm9ybUJpYXNbMl0pIC8gbm9ybU1lYW5bMl07XG4gICAgaWYgKGFUZW5zb3JQb2ludGVyICE9PSAtMSAmJiBhSW1hZ2VQb2ludGVyICE9PSAtMSkge1xuICAgICAgZmxvYXQzMkRhdGFbYVRlbnNvclBvaW50ZXIrK10gPSAoYnVmZmVyW2FJbWFnZVBvaW50ZXJdICsgbm9ybUJpYXNbM10pIC8gbm9ybU1lYW5bM107XG4gICAgfVxuICB9XG5cbiAgLy8gRmxvYXQzMkFycmF5IC0+IG9ydC5UZW5zb3JcbiAgY29uc3Qgb3V0cHV0VGVuc29yID0gb3V0cHV0Zm9ybWF0ID09PSAnUkdCQScgPyBuZXcgVGVuc29yKCdmbG9hdDMyJywgZmxvYXQzMkRhdGEsIFsxLCA0LCBoZWlnaHQsIHdpZHRoXSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBUZW5zb3IoJ2Zsb2F0MzInLCBmbG9hdDMyRGF0YSwgWzEsIDMsIGhlaWdodCwgd2lkdGhdKTtcbiAgcmV0dXJuIG91dHB1dFRlbnNvcjtcbn07XG5cbi8qKlxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLmZyb21JbWFnZSgpLlxuICovXG5leHBvcnQgY29uc3QgdGVuc29yRnJvbUltYWdlID0gYXN5bmMoXG4gICAgaW1hZ2U6IEltYWdlRGF0YXxIVE1MSW1hZ2VFbGVtZW50fEltYWdlQml0bWFwfHN0cmluZyxcbiAgICBvcHRpb25zPzogVGVuc29yRnJvbUltYWdlRGF0YU9wdGlvbnN8VGVuc29yRnJvbUltYWdlRWxlbWVudE9wdGlvbnN8VGVuc29yRnJvbUltYWdlQml0bWFwT3B0aW9uc3xcbiAgICBUZW5zb3JGcm9tVXJsT3B0aW9ucyk6IFByb21pc2U8VGVuc29yPiA9PiB7XG4gIC8vIGNoZWNraW5nIHRoZSB0eXBlIG9mIGltYWdlIG9iamVjdFxuICBjb25zdCBpc0hUTUxJbWFnZUVsZSA9IHR5cGVvZiAoSFRNTEltYWdlRWxlbWVudCkgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudDtcbiAgY29uc3QgaXNJbWFnZURhdGFFbGUgPSB0eXBlb2YgKEltYWdlRGF0YSkgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSW1hZ2VEYXRhO1xuICBjb25zdCBpc0ltYWdlQml0bWFwID0gdHlwZW9mIChJbWFnZUJpdG1hcCkgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXA7XG4gIGNvbnN0IGlzU3RyaW5nID0gdHlwZW9mIGltYWdlID09PSAnc3RyaW5nJztcblxuICBsZXQgZGF0YTogVWludDhDbGFtcGVkQXJyYXl8dW5kZWZpbmVkO1xuICBsZXQgYnVmZmVyVG9UZW5zb3JPcHRpb25zOiBCdWZmZXJUb1RlbnNvck9wdGlvbnMgPSBvcHRpb25zID8/IHt9O1xuXG4gIGNvbnN0IGNyZWF0ZUNhbnZhcyA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbnZhcyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9O1xuICBjb25zdCBjcmVhdGVDYW52YXNDb250ZXh0ID0gKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnR8T2Zmc2NyZWVuQ2FudmFzKSA9PiB7XG4gICAgaWYgKGNhbnZhcyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgICByZXR1cm4gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgfSBlbHNlIGlmIChjYW52YXMgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXMpIHtcbiAgICAgIHJldHVybiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSBhcyBPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcbiAgLy8gZmlsbGluZyBhbmQgY2hlY2tpbmcgaW1hZ2UgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gIGlmIChpc0hUTUxJbWFnZUVsZSkge1xuICAgIC8vIEhUTUxJbWFnZUVsZW1lbnQgLSBpbWFnZSBvYmplY3QgLSBmb3JtYXQgaXMgUkdCQSBieSBkZWZhdWx0XG4gICAgY29uc3QgY2FudmFzID0gY3JlYXRlQ2FudmFzKCk7XG4gICAgY2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICBjb25zdCBwaXhlbHMyRENvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0KGNhbnZhcyk7XG5cbiAgICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgIGxldCBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgICBsZXQgd2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZXNpemVkSGVpZ2h0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZXNpemVkV2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBoZWlnaHQgPSBvcHRpb25zLnJlc2l6ZWRIZWlnaHQ7XG4gICAgICAgIHdpZHRoID0gb3B0aW9ucy5yZXNpemVkV2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGlvbnMudGVuc29yRm9ybWF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGlucHV0IGNvbmZpZyBmb3JtYXQgbXVzdCBiZSBSR0JBIGZvciBIVE1MSW1hZ2VFbGVtZW50Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLnRlbnNvckZvcm1hdCA9ICdSR0JBJztcbiAgICAgICAgfVxuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMud2lkdGggPSB3aWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy50ZW5zb3JGb3JtYXQgPSAnUkdCQSc7XG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy53aWR0aCA9IHdpZHRoO1xuICAgICAgfVxuXG4gICAgICBwaXhlbHMyRENvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwKTtcbiAgICAgIGRhdGEgPSBwaXhlbHMyRENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0ltYWdlRGF0YUVsZSkge1xuICAgIGxldCBoZWlnaHQ6IG51bWJlcjtcbiAgICBsZXQgd2lkdGg6IG51bWJlcjtcblxuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZXNpemVkV2lkdGggIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRIZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5yZXNpemVkSGVpZ2h0O1xuICAgICAgd2lkdGggPSBvcHRpb25zLnJlc2l6ZWRXaWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgd2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuZm9ybWF0ID0gJ1JHQkEnO1xuICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gd2lkdGg7XG5cbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCB0ZW1wQ2FudmFzID0gY3JlYXRlQ2FudmFzKCk7XG5cbiAgICAgIHRlbXBDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHRlbXBDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICBjb25zdCBwaXhlbHMyRENvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0KHRlbXBDYW52YXMpO1xuXG4gICAgICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgcGl4ZWxzMkRDb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZSwgMCwgMCk7XG4gICAgICAgIGRhdGEgPSBwaXhlbHMyRENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IGltYWdlLmRhdGE7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzSW1hZ2VCaXRtYXApIHtcbiAgICAvLyBJbWFnZUJpdG1hcCAtIGltYWdlIG9iamVjdCAtIGZvcm1hdCBtdXN0IGJlIHByb3ZpZGVkIGJ5IHVzZXJcbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGltYWdlIGNvbmZpZyB3aXRoIGZvcm1hdCBmb3IgSW1hZ2ViaXRtYXAnKTtcbiAgICB9XG5cbiAgICBjb25zdCBjYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcbiAgICBjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQoY2FudmFzKTtcblxuICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgIHBpeGVsczJEQ29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgZGF0YSA9IHBpeGVsczJEQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMud2lkdGggPSB3aWR0aDtcbiAgICAgIHJldHVybiBidWZmZXJUb1RlbnNvcihkYXRhLCBidWZmZXJUb1RlbnNvck9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgY2FudmFzID0gY3JlYXRlQ2FudmFzKCk7XG4gICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dChjYW52YXMpO1xuICAgICAgaWYgKCFpbWFnZSB8fCAhY29udGV4dCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KCk7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgbmV3SW1hZ2UuY3Jvc3NPcmlnaW4gPSAnQW5vbnltb3VzJztcbiAgICAgIG5ld0ltYWdlLnNyYyA9IGltYWdlO1xuICAgICAgbmV3SW1hZ2Uub25sb2FkID0gKCkgPT4ge1xuICAgICAgICBjYW52YXMud2lkdGggPSBuZXdJbWFnZS53aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IG5ld0ltYWdlLmhlaWdodDtcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UobmV3SW1hZ2UsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIGNvbnN0IGltZyA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICAgICAgcmVzb2x2ZShidWZmZXJUb1RlbnNvcihpbWcuZGF0YSwgYnVmZmVyVG9UZW5zb3JPcHRpb25zKSk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb24nKTtcbiAgfVxuXG4gIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYnVmZmVyVG9UZW5zb3IoZGF0YSwgYnVmZmVyVG9UZW5zb3JPcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uJyk7XG4gIH1cbn07XG5cbi8qKlxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLmZyb21UZXh0dXJlKCkuXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JGcm9tVGV4dHVyZSA9IDxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLlRleHR1cmVEYXRhVHlwZXM+KFxuICAgIHRleHR1cmU6IFRlbnNvckludGVyZmFjZS5UZXh0dXJlVHlwZSwgb3B0aW9uczogVGVuc29yRnJvbVRleHR1cmVPcHRpb25zPFQ+KTogVGVuc29yID0+IHtcbiAgY29uc3Qge3dpZHRoLCBoZWlnaHQsIGRvd25sb2FkLCBkaXNwb3NlfSA9IG9wdGlvbnM7XG4gIC8vIEFsd2F5cyBhc3N1bWUgUkdCQUYzMi4gVE9ETzogc3VwcG9ydCBkaWZmZXJlbnQgdGV4dHVyZSBmb3JtYXRcbiAgY29uc3QgZGltcyA9IFsxLCBoZWlnaHQsIHdpZHRoLCA0XTtcbiAgcmV0dXJuIG5ldyBUZW5zb3Ioe2xvY2F0aW9uOiAndGV4dHVyZScsIHR5cGU6ICdmbG9hdDMyJywgdGV4dHVyZSwgZGltcywgZG93bmxvYWQsIGRpc3Bvc2V9KTtcbn07XG5cbi8qKlxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLmZyb21HcHVCdWZmZXIoKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21HcHVCdWZmZXIgPSA8VCBleHRlbmRzIFRlbnNvckludGVyZmFjZS5HcHVCdWZmZXJEYXRhVHlwZXM+KFxuICAgIGdwdUJ1ZmZlcjogVGVuc29ySW50ZXJmYWNlLkdwdUJ1ZmZlclR5cGUsIG9wdGlvbnM6IFRlbnNvckZyb21HcHVCdWZmZXJPcHRpb25zPFQ+KTogVGVuc29yID0+IHtcbiAgY29uc3Qge2RhdGFUeXBlLCBkaW1zLCBkb3dubG9hZCwgZGlzcG9zZX0gPSBvcHRpb25zO1xuICByZXR1cm4gbmV3IFRlbnNvcih7bG9jYXRpb246ICdncHUtYnVmZmVyJywgdHlwZTogZGF0YVR5cGUgPz8gJ2Zsb2F0MzInLCBncHVCdWZmZXIsIGRpbXMsIGRvd25sb2FkLCBkaXNwb3NlfSk7XG59O1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5mcm9tUGlubmVkQnVmZmVyKCkuXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JGcm9tUGlubmVkQnVmZmVyID0gPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuQ3B1UGlubmVkRGF0YVR5cGVzPihcbiAgICB0eXBlOiBULCBidWZmZXI6IFRlbnNvckludGVyZmFjZS5EYXRhVHlwZU1hcFtUXSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29yID0+XG4gICAgbmV3IFRlbnNvcih7bG9jYXRpb246ICdjcHUtcGlubmVkJywgdHlwZSwgZGF0YTogYnVmZmVyLCBkaW1zOiBkaW1zID8/IFtidWZmZXIubGVuZ3RoXX0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi90ZW5zb3IuanMnO1xuXG5leHBvcnQgdHlwZSBTdXBwb3J0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3JzID0gRmxvYXQzMkFycmF5Q29uc3RydWN0b3J8VWludDhBcnJheUNvbnN0cnVjdG9yfEludDhBcnJheUNvbnN0cnVjdG9yfFxuICAgIFVpbnQxNkFycmF5Q29uc3RydWN0b3J8SW50MTZBcnJheUNvbnN0cnVjdG9yfEludDMyQXJyYXlDb25zdHJ1Y3RvcnxCaWdJbnQ2NEFycmF5Q29uc3RydWN0b3J8VWludDhBcnJheUNvbnN0cnVjdG9yfFxuICAgIEZsb2F0NjRBcnJheUNvbnN0cnVjdG9yfFVpbnQzMkFycmF5Q29uc3RydWN0b3J8QmlnVWludDY0QXJyYXlDb25zdHJ1Y3RvcjtcbmV4cG9ydCB0eXBlIFN1cHBvcnRlZFR5cGVkQXJyYXkgPSBJbnN0YW5jZVR5cGU8U3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycz47XG5cbi8vIGEgcnVudGltZSBtYXAgdGhhdCBtYXBzIHR5cGUgc3RyaW5nIHRvIFR5cGVkQXJyYXkgY29uc3RydWN0b3IuIFNob3VsZCBtYXRjaCBUZW5zb3IuRGF0YVR5cGVNYXAuXG5leHBvcnQgY29uc3QgTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUCA9IG5ldyBNYXA8c3RyaW5nLCBTdXBwb3J0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3JzPihbXG4gIFsnZmxvYXQzMicsIEZsb2F0MzJBcnJheV0sXG4gIFsndWludDgnLCBVaW50OEFycmF5XSxcbiAgWydpbnQ4JywgSW50OEFycmF5XSxcbiAgWyd1aW50MTYnLCBVaW50MTZBcnJheV0sXG4gIFsnaW50MTYnLCBJbnQxNkFycmF5XSxcbiAgWydpbnQzMicsIEludDMyQXJyYXldLFxuICBbJ2Jvb2wnLCBVaW50OEFycmF5XSxcbiAgWydmbG9hdDY0JywgRmxvYXQ2NEFycmF5XSxcbiAgWyd1aW50MzInLCBVaW50MzJBcnJheV0sXG5dKTtcblxuLy8gYSBydW50aW1lIG1hcCB0aGF0IG1hcHMgdHlwZSBzdHJpbmcgdG8gVHlwZWRBcnJheSBjb25zdHJ1Y3Rvci4gU2hvdWxkIG1hdGNoIFRlbnNvci5EYXRhVHlwZU1hcC5cbmV4cG9ydCBjb25zdCBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQID0gbmV3IE1hcDxTdXBwb3J0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3JzLCBUZW5zb3IuVHlwZT4oW1xuICBbRmxvYXQzMkFycmF5LCAnZmxvYXQzMiddLFxuICBbVWludDhBcnJheSwgJ3VpbnQ4J10sXG4gIFtJbnQ4QXJyYXksICdpbnQ4J10sXG4gIFtVaW50MTZBcnJheSwgJ3VpbnQxNiddLFxuICBbSW50MTZBcnJheSwgJ2ludDE2J10sXG4gIFtJbnQzMkFycmF5LCAnaW50MzInXSxcbiAgW0Zsb2F0NjRBcnJheSwgJ2Zsb2F0NjQnXSxcbiAgW1VpbnQzMkFycmF5LCAndWludDMyJ10sXG5dKTtcblxuLy8gYSBkdW1teSB0eXBlIGRlY2xhcmF0aW9uIGZvciBGbG9hdDE2QXJyYXkgaW4gY2FzZSBhbnkgcG9seWZpbGwgaXMgYXZhaWxhYmxlLlxuZGVjbGFyZSBnbG9iYWwge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGNvbnN0IEZsb2F0MTZBcnJheTogYW55O1xufVxuXG4vLyB0aGUgZm9sbG93aW5nIGNvZGUgYWxsb3dzIGRlbGF5aW5nIGV4ZWN1dGlvbiBvZiBCaWdJbnQvRmxvYXQxNkFycmF5IGNoZWNraW5nLiBUaGlzIGFsbG93cyBsYXp5IGluaXRpYWxpemF0aW9uIGZvclxuLy8gTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUCBhbmQgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUCwgd2hpY2ggYWxsb3dzIEJpZ0ludC9GbG9hdDE2QXJyYXlcbi8vIHBvbHlmaWxsIGlmIGF2YWlsYWJsZS5cbmxldCBpc1R5cGVkQXJyYXlDaGVja2VkID0gZmFsc2U7XG5leHBvcnQgY29uc3QgY2hlY2tUeXBlZEFycmF5ID0gKCkgPT4ge1xuICBpZiAoIWlzVHlwZWRBcnJheUNoZWNrZWQpIHtcbiAgICBpc1R5cGVkQXJyYXlDaGVja2VkID0gdHJ1ZTtcbiAgICBjb25zdCBpc0JpZ0ludDY0QXJyYXlBdmFpbGFibGUgPSB0eXBlb2YgQmlnSW50NjRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgQmlnSW50NjRBcnJheS5mcm9tO1xuICAgIGNvbnN0IGlzQmlnVWludDY0QXJyYXlBdmFpbGFibGUgPSB0eXBlb2YgQmlnVWludDY0QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIEJpZ1VpbnQ2NEFycmF5LmZyb207XG4gICAgY29uc3QgaXNGbG9hdDE2QXJyYXlBdmFpbGFibGUgPSB0eXBlb2YgRmxvYXQxNkFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBGbG9hdDE2QXJyYXkuZnJvbTtcblxuICAgIGlmIChpc0JpZ0ludDY0QXJyYXlBdmFpbGFibGUpIHtcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCdpbnQ2NCcsIEJpZ0ludDY0QXJyYXkpO1xuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUC5zZXQoQmlnSW50NjRBcnJheSwgJ2ludDY0Jyk7XG4gICAgfVxuICAgIGlmIChpc0JpZ1VpbnQ2NEFycmF5QXZhaWxhYmxlKSB7XG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLnNldCgndWludDY0JywgQmlnVWludDY0QXJyYXkpO1xuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUC5zZXQoQmlnVWludDY0QXJyYXksICd1aW50NjQnKTtcbiAgICB9XG4gICAgaWYgKGlzRmxvYXQxNkFycmF5QXZhaWxhYmxlKSB7XG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLnNldCgnZmxvYXQxNicsIEZsb2F0MTZBcnJheSk7XG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLnNldChGbG9hdDE2QXJyYXksICdmbG9hdDE2Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIEZsb2F0MTZBcnJheSBpcyBub3QgYXZhaWxhYmxlLCB1c2UgJ1VpbnQxNkFycmF5JyB0byBzdG9yZSB0aGUgZGF0YS5cbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCdmbG9hdDE2JywgVWludDE2QXJyYXkpO1xuICAgIH1cbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnMsIEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVycywgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVyc30gZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi90ZW5zb3ItaW1wbC5qcyc7XG5cbi8qKlxuICogY2FsY3VsYXRlIHNpemUgZnJvbSBkaW1zLlxuICpcbiAqIEBwYXJhbSBkaW1zIHRoZSBkaW1zIGFycmF5LiBNYXkgYmUgYW4gaWxsZWdhbCBpbnB1dC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZVNpemUgPSAoZGltczogcmVhZG9ubHkgdW5rbm93bltdKTogbnVtYmVyID0+IHtcbiAgbGV0IHNpemUgPSAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBkaW0gPSBkaW1zW2ldO1xuICAgIGlmICh0eXBlb2YgZGltICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzU2FmZUludGVnZXIoZGltKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZGltc1ske2l9XSBtdXN0IGJlIGFuIGludGVnZXIsIGdvdDogJHtkaW19YCk7XG4gICAgfVxuICAgIGlmIChkaW0gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgZGltc1ske2l9XSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIsIGdvdDogJHtkaW19YCk7XG4gICAgfVxuICAgIHNpemUgKj0gZGltO1xuICB9XG4gIHJldHVybiBzaXplO1xufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IucmVzaGFwZSgpXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JSZXNoYXBlID0gKHRlbnNvcjogVGVuc29yLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvciA9PiB7XG4gIHN3aXRjaCAodGVuc29yLmxvY2F0aW9uKSB7XG4gICAgY2FzZSAnY3B1JzpcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKHRlbnNvci50eXBlLCB0ZW5zb3IuZGF0YSwgZGltcyk7XG4gICAgY2FzZSAnY3B1LXBpbm5lZCc6XG4gICAgICByZXR1cm4gbmV3IFRlbnNvcih7XG4gICAgICAgIGxvY2F0aW9uOiAnY3B1LXBpbm5lZCcsXG4gICAgICAgIGRhdGE6IHRlbnNvci5kYXRhIGFzIENwdVBpbm5lZENvbnN0cnVjdG9yUGFyYW1ldGVyc1snZGF0YSddLFxuICAgICAgICB0eXBlOiB0ZW5zb3IudHlwZSBhcyBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnNbJ3R5cGUnXSxcbiAgICAgICAgZGltcyxcbiAgICAgIH0pO1xuICAgIGNhc2UgJ3RleHR1cmUnOlxuICAgICAgcmV0dXJuIG5ldyBUZW5zb3Ioe1xuICAgICAgICBsb2NhdGlvbjogJ3RleHR1cmUnLFxuICAgICAgICB0ZXh0dXJlOiB0ZW5zb3IudGV4dHVyZSxcbiAgICAgICAgdHlwZTogdGVuc29yLnR5cGUgYXMgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVyc1sndHlwZSddLFxuICAgICAgICBkaW1zLFxuICAgICAgfSk7XG4gICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XG4gICAgICByZXR1cm4gbmV3IFRlbnNvcih7XG4gICAgICAgIGxvY2F0aW9uOiAnZ3B1LWJ1ZmZlcicsXG4gICAgICAgIGdwdUJ1ZmZlcjogdGVuc29yLmdwdUJ1ZmZlcixcbiAgICAgICAgdHlwZTogdGVuc29yLnR5cGUgYXMgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzWyd0eXBlJ10sXG4gICAgICAgIGRpbXMsXG4gICAgICB9KTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0ZW5zb3JSZXNoYXBlOiB0ZW5zb3IgbG9jYXRpb24gJHt0ZW5zb3IubG9jYXRpb259IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHt0ZW5zb3JUb0RhdGFVUkwsIHRlbnNvclRvSW1hZ2VEYXRhfSBmcm9tICcuL3RlbnNvci1jb252ZXJzaW9uLWltcGwuanMnO1xuaW1wb3J0IHtUZW5zb3JUb0RhdGFVcmxPcHRpb25zLCBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnN9IGZyb20gJy4vdGVuc29yLWNvbnZlcnNpb24uanMnO1xuaW1wb3J0IHt0ZW5zb3JGcm9tR3B1QnVmZmVyLCB0ZW5zb3JGcm9tSW1hZ2UsIHRlbnNvckZyb21QaW5uZWRCdWZmZXIsIHRlbnNvckZyb21UZXh0dXJlfSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LWltcGwuanMnO1xuaW1wb3J0IHtDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnMsIEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVycywgVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnMsIFRlbnNvckZyb21JbWFnZUJpdG1hcE9wdGlvbnMsIFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zLCBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9ucywgVGVuc29yRnJvbVRleHR1cmVPcHRpb25zLCBUZW5zb3JGcm9tVXJsT3B0aW9ucywgVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVyc30gZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XG5pbXBvcnQge2NoZWNrVHlwZWRBcnJheSwgTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUCwgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUCwgU3VwcG9ydGVkVHlwZWRBcnJheSwgU3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9yc30gZnJvbSAnLi90ZW5zb3ItaW1wbC10eXBlLW1hcHBpbmcuanMnO1xuaW1wb3J0IHtjYWxjdWxhdGVTaXplLCB0ZW5zb3JSZXNoYXBlfSBmcm9tICcuL3RlbnNvci11dGlscy1pbXBsLmpzJztcbmltcG9ydCB7VGVuc29yIGFzIFRlbnNvckludGVyZmFjZX0gZnJvbSAnLi90ZW5zb3IuanMnO1xuXG4vLyB0eXBlIGFsaWFzZXMgZm9yIHRob3NlIGV4cG9ydGVkIGZyb20gVGVuc29yIGludGVyZmFjZVxuXG50eXBlIFRlbnNvclR5cGUgPSBUZW5zb3JJbnRlcmZhY2UuVHlwZTtcbnR5cGUgVGVuc29yRGF0YVR5cGUgPSBUZW5zb3JJbnRlcmZhY2UuRGF0YVR5cGU7XG50eXBlIFRlbnNvckRhdGFMb2NhdGlvbiA9IFRlbnNvckludGVyZmFjZS5EYXRhTG9jYXRpb247XG50eXBlIFRlbnNvclRleHR1cmVUeXBlID0gVGVuc29ySW50ZXJmYWNlLlRleHR1cmVUeXBlO1xudHlwZSBUZW5zb3JHcHVCdWZmZXJUeXBlID0gVGVuc29ySW50ZXJmYWNlLkdwdUJ1ZmZlclR5cGU7XG5cbi8qKlxuICogdGhlIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvciBpbnRlcmZhY2UuXG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgVGVuc29yIGltcGxlbWVudHMgVGVuc29ySW50ZXJmYWNlIHtcbiAgLy8gI3JlZ2lvbiBjb25zdHJ1Y3RvcnNcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IENQVSB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIHR5cGUsIGRhdGEgYW5kIGRpbXMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIHR5cGU6IFRlbnNvclR5cGUsIGRhdGE6IFRlbnNvckRhdGFUeXBlfHJlYWRvbmx5IHN0cmluZ1tdfHJlYWRvbmx5IG51bWJlcltdfHJlYWRvbmx5IGJvb2xlYW5bXSxcbiAgICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgQ1BVIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy4gVHlwZSBpcyBpbmZlcnJlZCBmcm9tIGRhdGEuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkYXRhOiBUZW5zb3JEYXRhVHlwZXxyZWFkb25seSBzdHJpbmdbXXxyZWFkb25seSBib29sZWFuW10sIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBwaW5uZWQgQ1BVIGRhdGEgd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgZGltcy5cbiAgICpcbiAgICogVGVuc29yJ3MgbG9jYXRpb24gd2lsbCBiZSBzZXQgdG8gJ2NwdS1waW5uZWQnLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gU3BlY2lmeSB0aGUgcGFyYW1ldGVycyB0byBjb25zdHJ1Y3QgdGhlIHRlbnNvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtczogQ3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzKTtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIFdlYkdMIHRleHR1cmUgd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgZGltcy5cbiAgICpcbiAgICogVGVuc29yJ3MgbG9jYXRpb24gd2lsbCBiZSBzZXQgdG8gJ3RleHR1cmUnLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gU3BlY2lmeSB0aGUgcGFyYW1ldGVycyB0byBjb25zdHJ1Y3QgdGhlIHRlbnNvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtczogVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVycyk7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBXZWJHUFUgYnVmZmVyIHdpdGggdGhlIGdpdmVuIHR5cGUgYW5kIGRpbXMuXG4gICAqXG4gICAqIFRlbnNvcidzIGxvY2F0aW9uIHdpbGwgYmUgc2V0IHRvICdncHUtYnVmZmVyJy5cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyAtIFNwZWNpZnkgdGhlIHBhcmFtZXRlcnMgdG8gY29uc3RydWN0IHRoZSB0ZW5zb3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJhbXM6IEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVycyk7XG5cbiAgLyoqXG4gICAqIGltcGxlbWVudGF0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgICBhcmcwOiBUZW5zb3JUeXBlfFRlbnNvckRhdGFUeXBlfHJlYWRvbmx5IHN0cmluZ1tdfHJlYWRvbmx5IGJvb2xlYW5bXXxDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnN8XG4gICAgICBUZXh0dXJlQ29uc3RydWN0b3JQYXJhbWV0ZXJzfEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVycyxcbiAgICAgIGFyZzE/OiBUZW5zb3JEYXRhVHlwZXxyZWFkb25seSBudW1iZXJbXXxyZWFkb25seSBzdHJpbmdbXXxyZWFkb25seSBib29sZWFuW10sIGFyZzI/OiByZWFkb25seSBudW1iZXJbXSkge1xuICAgIC8vIHBlcmZvcm0gb25lLXRpbWUgY2hlY2sgZm9yIEJpZ0ludC9GbG9hdDE2QXJyYXkgc3VwcG9ydFxuICAgIGNoZWNrVHlwZWRBcnJheSgpO1xuXG4gICAgbGV0IHR5cGU6IFRlbnNvclR5cGU7XG4gICAgbGV0IGRpbXM6IHJlYWRvbmx5IG51bWJlcltdO1xuXG4gICAgaWYgKHR5cGVvZiBhcmcwID09PSAnb2JqZWN0JyAmJiAnbG9jYXRpb24nIGluIGFyZzApIHtcbiAgICAgIC8vXG4gICAgICAvLyBjb25zdHJ1Y3RpbmcgdGVuc29yIGZyb20gc3BlY2lmaWMgbG9jYXRpb25cbiAgICAgIC8vXG4gICAgICB0aGlzLmRhdGFMb2NhdGlvbiA9IGFyZzAubG9jYXRpb247XG4gICAgICB0eXBlID0gYXJnMC50eXBlO1xuICAgICAgZGltcyA9IGFyZzAuZGltcztcbiAgICAgIHN3aXRjaCAoYXJnMC5sb2NhdGlvbikge1xuICAgICAgICBjYXNlICdjcHUtcGlubmVkJzoge1xuICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5nZXQodHlwZSk7XG4gICAgICAgICAgaWYgKCFleHBlY3RlZFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7dHlwZX1cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gcGlubmVkIGJ1ZmZlcmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShhcmcwLmRhdGEgaW5zdGFuY2VvZiBleHBlY3RlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGJ1ZmZlciBzaG91bGQgYmUgb2YgdHlwZSAke2V4cGVjdGVkVHlwZWRBcnJheUNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY3B1RGF0YSA9IGFyZzAuZGF0YTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd0ZXh0dXJlJzoge1xuICAgICAgICAgIGlmICh0eXBlICE9PSAnZmxvYXQzMicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke3R5cGV9XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIHRleHR1cmVgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5ncHVUZXh0dXJlRGF0YSA9IGFyZzAudGV4dHVyZTtcbiAgICAgICAgICB0aGlzLmRvd25sb2FkZXIgPSBhcmcwLmRvd25sb2FkO1xuICAgICAgICAgIHRoaXMuZGlzcG9zZXIgPSBhcmcwLmRpc3Bvc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZ3B1LWJ1ZmZlcic6IHtcbiAgICAgICAgICBpZiAoKHR5cGUgIT09ICdmbG9hdDMyJyAmJiB0eXBlICE9PSAnZmxvYXQxNicgJiYgdHlwZSAhPT0gJ2ludDMyJyAmJiB0eXBlICE9PSAnaW50NjQnICYmIHR5cGUgIT09ICd1aW50MzInICYmXG4gICAgICAgICAgICAgICB0eXBlICE9PSAndWludDgnICYmIHR5cGUgIT09ICdib29sJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke3R5cGV9XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIGdwdSBidWZmZXJgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5ncHVCdWZmZXJEYXRhID0gYXJnMC5ncHVCdWZmZXI7XG4gICAgICAgICAgdGhpcy5kb3dubG9hZGVyID0gYXJnMC5kb3dubG9hZDtcbiAgICAgICAgICB0aGlzLmRpc3Bvc2VyID0gYXJnMC5kaXNwb3NlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZW5zb3IgY29uc3RydWN0b3I6IHVuc3VwcG9ydGVkIGxvY2F0aW9uICcke3RoaXMuZGF0YUxvY2F0aW9ufSdgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy9cbiAgICAgIC8vIGNvbnN0cnVjdGluZyB0ZW5zb3Igb2YgbG9jYXRpb24gJ2NwdSdcbiAgICAgIC8vXG4gICAgICBsZXQgZGF0YTogVGVuc29yRGF0YVR5cGU7XG4gICAgICBsZXQgbWF5YmVEaW1zOiB0eXBlb2YgYXJnMXx0eXBlb2YgYXJnMjtcbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgYXJnMCBpcyB0eXBlIG9yIGRhdGFcbiAgICAgIGlmICh0eXBlb2YgYXJnMCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gT3ZlcnJpZGU6IGNvbnN0cnVjdG9yKHR5cGUsIGRhdGEsIC4uLilcbiAgICAgICAgLy9cbiAgICAgICAgdHlwZSA9IGFyZzA7XG4gICAgICAgIG1heWJlRGltcyA9IGFyZzI7XG4gICAgICAgIGlmIChhcmcwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIHN0cmluZyB0ZW5zb3JcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnMSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Egc3RyaW5nIHRlbnNvclxcJ3MgZGF0YSBtdXN0IGJlIGEgc3RyaW5nIGFycmF5LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSBkb24ndCBjaGVjayB3aGV0aGVyIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIGFycmF5IGlzIHN0cmluZzsgdGhpcyBpcyB0b28gc2xvdy4gd2UgYXNzdW1lIGl0J3MgY29ycmVjdCBhbmRcbiAgICAgICAgICAvLyBlcnJvciB3aWxsIGJlIHBvcHVsYXRlZCBhdCBpbmZlcmVuY2VcbiAgICAgICAgICBkYXRhID0gYXJnMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBudW1lcmljIHRlbnNvclxuICAgICAgICAgIGNvbnN0IHR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuZ2V0KGFyZzApO1xuICAgICAgICAgIGlmICh0eXBlZEFycmF5Q29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdGVuc29yIHR5cGU6ICR7YXJnMH0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgICAgICBpZiAoYXJnMCA9PT0gJ2Zsb2F0MTYnICYmIHR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9PT0gVWludDE2QXJyYXkpIHtcbiAgICAgICAgICAgICAgLy8gV2hlbiBubyBGbG9hdDE2QXJyYXkgcG9seWZpbGwgaXMgdXNlZCwgd2UgY2Fubm90IGNyZWF0ZSAnZmxvYXQxNicgdGVuc29yIGZyb20gbnVtYmVyIGFycmF5LlxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyBUaHJvdyBlcnJvciBoZXJlIGJlY2F1c2Ugd2hlbiB1c2VyIHRyeSB0byB1c2UgbnVtYmVyIGFycmF5IGFzIGRhdGEsXG4gICAgICAgICAgICAgIC8vIGUuZy4gbmV3IFRlbnNvcignZmxvYXQxNicsIFsxLCAyLCAzLCA0XSwgZGltcykpLCBpdCB3aWxsIGFjdHVhbGx5IGNhbGxcbiAgICAgICAgICAgICAgLy8gVWludDE2QXJyYXkuZnJvbShhcmcxKSB3aGljaCBnZW5lcmF0ZXMgd3JvbmcgZGF0YS5cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICAgICdDcmVhdGluZyBhIGZsb2F0MTYgdGVuc29yIGZyb20gbnVtYmVyIGFycmF5IGlzIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgVWludDE2QXJyYXkgYXMgZGF0YS4nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnMCA9PT0gJ3VpbnQ2NCcgfHwgYXJnMCA9PT0gJ2ludDY0Jykge1xuICAgICAgICAgICAgICAvLyB1c2UgJ2FzIGFueScgaGVyZSBiZWNhdXNlOlxuICAgICAgICAgICAgICAvLyAxLiBUeXBlU2NyaXB0J3MgY2hlY2sgb24gdHlwZSBvZiAnQXJyYXkuaXNBcnJheSgpJyBkb2VzIG5vdCB3b3JrIHdpdGggcmVhZG9ubHkgYXJyYXlzLlxuICAgICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xNzAwMlxuICAgICAgICAgICAgICAvLyAyLiBUeXBlU2NyaXB0J3MgY2hlY2sgb24gdW5pb24gdHlwZSBvZiAnKEJpZ0ludDY0QXJyYXlDb25zdHJ1Y3RvcnxCaWdVaW50NjRBcnJheUNvbnN0cnVjdG9yKS5mcm9tKCknXG4gICAgICAgICAgICAgIC8vIGRvZXMgbm90IGFjY2VwdCBwYXJhbWV0ZXIgbWFwRm4uXG4gICAgICAgICAgICAgIC8vIDMuIHBhcmFtZXRlcnMgb2YgJ1N1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnMuZnJvbSgpJyBkb2VzIG5vdCBtYXRjaCB0aGUgcmVxdWlyZW1lbnQgb2YgdGhlIHVuaW9uXG4gICAgICAgICAgICAgIC8vIHR5cGUuXG5cbiAgICAgICAgICAgICAgLy8gYXNzdW1lICdhcmcxJyBpcyBvZiB0eXBlIFwicmVhZG9ubHkgbnVtYmVyW118cmVhZG9ubHkgYmlnaW50W11cIiBoZXJlLlxuXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgIGRhdGEgPSAodHlwZWRBcnJheUNvbnN0cnVjdG9yIGFzIGFueSkuZnJvbShhcmcxLCBCaWdJbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gYXNzdW1lICdhcmcxJyBpcyBvZiB0eXBlIFwicmVhZG9ubHkgbnVtYmVyW11cIiBoZXJlLlxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICBkYXRhID0gKHR5cGVkQXJyYXlDb25zdHJ1Y3RvciBhcyBhbnkpLmZyb20oYXJnMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChhcmcxIGluc3RhbmNlb2YgdHlwZWRBcnJheUNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBkYXRhID0gYXJnMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSAke3R5cGV9IHRlbnNvcidzIGRhdGEgbXVzdCBiZSB0eXBlIG9mICR7dHlwZWRBcnJheUNvbnN0cnVjdG9yfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gT3ZlcnJpZGU6IGNvbnN0cnVjdG9yKGRhdGEsIC4uLilcbiAgICAgICAgLy9cbiAgICAgICAgbWF5YmVEaW1zID0gYXJnMTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcbiAgICAgICAgICAvLyBvbmx5IGJvb2xlYW5bXSBhbmQgc3RyaW5nW10gaXMgc3VwcG9ydGVkXG4gICAgICAgICAgaWYgKGFyZzAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUZW5zb3IgdHlwZSBjYW5ub3QgYmUgaW5mZXJyZWQgZnJvbSBhbiBlbXB0eSBhcnJheS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZmlyc3RFbGVtZW50VHlwZSA9IHR5cGVvZiBhcmcwWzBdO1xuICAgICAgICAgIGlmIChmaXJzdEVsZW1lbnRUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdHlwZSA9ICdzdHJpbmcnO1xuICAgICAgICAgICAgZGF0YSA9IGFyZzA7XG4gICAgICAgICAgfSBlbHNlIGlmIChmaXJzdEVsZW1lbnRUeXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHR5cGUgPSAnYm9vbCc7XG4gICAgICAgICAgICAvLyAnYXJnMCcgaXMgb2YgdHlwZSAnYm9vbGVhbltdJy4gVWludDhBcnJheS5mcm9tKGJvb2xlYW5bXSkgYWN0dWFsbHkgd29ya3MsIGJ1dCB0eXBlc2NyaXB0IHRoaW5rcyB0aGlzIGlzXG4gICAgICAgICAgICAvLyB3cm9uZyB0eXBlLiBXZSB1c2UgJ2FzIGFueScgdG8gbWFrZSBpdCBoYXBweS5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBkYXRhID0gVWludDhBcnJheS5mcm9tKGFyZzAgYXMgYW55W10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGVsZW1lbnQgdHlwZSBvZiBkYXRhIGFycmF5OiAke2ZpcnN0RWxlbWVudFR5cGV9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBnZXQgdGVuc29yIHR5cGUgZnJvbSBUeXBlZEFycmF5XG4gICAgICAgICAgY29uc3QgbWFwcGVkVHlwZSA9XG4gICAgICAgICAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAuZ2V0KGFyZzAuY29uc3RydWN0b3IgYXMgU3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycyk7XG4gICAgICAgICAgaWYgKG1hcHBlZFR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZSBmb3IgdGVuc29yIGRhdGE6ICR7YXJnMC5jb25zdHJ1Y3Rvcn0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHR5cGUgPSBtYXBwZWRUeXBlO1xuICAgICAgICAgIGRhdGEgPSBhcmcwIGFzIFN1cHBvcnRlZFR5cGVkQXJyYXk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdHlwZSBhbmQgZGF0YSBpcyBwcm9jZXNzZWQsIG5vdyBwcm9jZXNzaW5nIGRpbXNcbiAgICAgIGlmIChtYXliZURpbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBhc3N1bWUgMS1EIHRlbnNvciBpZiBkaW1zIG9taXR0ZWRcbiAgICAgICAgbWF5YmVEaW1zID0gW2RhdGEubGVuZ3RoXTtcbiAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkobWF5YmVEaW1zKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHRlbnNvclxcJ3MgZGltcyBtdXN0IGJlIGEgbnVtYmVyIGFycmF5Jyk7XG4gICAgICB9XG4gICAgICBkaW1zID0gbWF5YmVEaW1zIGFzIHJlYWRvbmx5IG51bWJlcltdO1xuXG4gICAgICB0aGlzLmNwdURhdGEgPSBkYXRhO1xuICAgICAgdGhpcy5kYXRhTG9jYXRpb24gPSAnY3B1JztcbiAgICB9XG5cbiAgICAvLyBwZXJmb3JtIGNoZWNrIG9uIGRpbXNcbiAgICBjb25zdCBzaXplID0gY2FsY3VsYXRlU2l6ZShkaW1zKTtcbiAgICAvLyBpZiBkYXRhIGlzIG9uIENQVSwgY2hlY2sgd2hldGhlciBkYXRhIGxlbmd0aCBtYXRjaGVzIHRlbnNvciBzaXplXG4gICAgaWYgKHRoaXMuY3B1RGF0YSAmJiBzaXplICE9PSB0aGlzLmNwdURhdGEubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvcidzIHNpemUoJHtzaXplfSkgZG9lcyBub3QgbWF0Y2ggZGF0YSBsZW5ndGgoJHt0aGlzLmNwdURhdGEubGVuZ3RofSkuYCk7XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmRpbXMgPSBkaW1zO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gIH1cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gZmFjdG9yeVxuICBzdGF0aWMgYXN5bmMgZnJvbUltYWdlKFxuICAgICAgaW1hZ2U6IEltYWdlRGF0YXxIVE1MSW1hZ2VFbGVtZW50fEltYWdlQml0bWFwfHN0cmluZyxcbiAgICAgIG9wdGlvbnM/OiBUZW5zb3JGcm9tSW1hZ2VEYXRhT3B0aW9uc3xUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9uc3xUZW5zb3JGcm9tSW1hZ2VCaXRtYXBPcHRpb25zfFxuICAgICAgVGVuc29yRnJvbVVybE9wdGlvbnMpOiBQcm9taXNlPFRlbnNvckludGVyZmFjZT4ge1xuICAgIHJldHVybiB0ZW5zb3JGcm9tSW1hZ2UoaW1hZ2UsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21UZXh0dXJlPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuVGV4dHVyZURhdGFUeXBlcz4oXG4gICAgICB0ZXh0dXJlOiBUZW5zb3JUZXh0dXJlVHlwZSwgb3B0aW9uczogVGVuc29yRnJvbVRleHR1cmVPcHRpb25zPFQ+KTogVGVuc29ySW50ZXJmYWNlIHtcbiAgICByZXR1cm4gdGVuc29yRnJvbVRleHR1cmUodGV4dHVyZSwgb3B0aW9ucyk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUdwdUJ1ZmZlcjxUIGV4dGVuZHMgVGVuc29ySW50ZXJmYWNlLkdwdUJ1ZmZlckRhdGFUeXBlcz4oXG4gICAgICBncHVCdWZmZXI6IFRlbnNvckdwdUJ1ZmZlclR5cGUsIG9wdGlvbnM6IFRlbnNvckZyb21HcHVCdWZmZXJPcHRpb25zPFQ+KTogVGVuc29ySW50ZXJmYWNlIHtcbiAgICByZXR1cm4gdGVuc29yRnJvbUdwdUJ1ZmZlcihncHVCdWZmZXIsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21QaW5uZWRCdWZmZXI8VCBleHRlbmRzIFRlbnNvckludGVyZmFjZS5DcHVQaW5uZWREYXRhVHlwZXM+KFxuICAgICAgdHlwZTogVCwgYnVmZmVyOiBUZW5zb3JJbnRlcmZhY2UuRGF0YVR5cGVNYXBbVF0sIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRlbnNvckZyb21QaW5uZWRCdWZmZXIodHlwZSwgYnVmZmVyLCBkaW1zKTtcbiAgfVxuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIGNvbnZlcnNpb25zXG4gIHRvRGF0YVVSTChvcHRpb25zPzogVGVuc29yVG9EYXRhVXJsT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRlbnNvclRvRGF0YVVSTCh0aGlzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHRvSW1hZ2VEYXRhKG9wdGlvbnM/OiBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnMpOiBJbWFnZURhdGEge1xuICAgIHJldHVybiB0ZW5zb3JUb0ltYWdlRGF0YSh0aGlzLCBvcHRpb25zKTtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBwdWJsaWMgZmllbGRzXG4gIHJlYWRvbmx5IGRpbXM6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSB0eXBlOiBUZW5zb3JUeXBlO1xuICByZWFkb25seSBzaXplOiBudW1iZXI7XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHByaXZhdGUgZmllbGRzXG5cbiAgLyoqXG4gICAqIHN0b3JlcyB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEuXG4gICAqL1xuICBwcml2YXRlIGRhdGFMb2NhdGlvbjogVGVuc29yRGF0YUxvY2F0aW9uO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgdGhlIGRhdGEgb24gQ1BVLCBpZiBsb2NhdGlvbiBpcyAnY3B1JyBvciAnY3B1LXBpbm5lZCcuIG90aGVyd2lzZSBlbXB0eS5cbiAgICovXG4gIHByaXZhdGUgY3B1RGF0YT86IFRlbnNvckRhdGFUeXBlO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgdGhlIHVuZGVybHlpbmcgdGV4dHVyZSB3aGVuIGxvY2F0aW9uIGlzICd0ZXh0dXJlJy4gb3RoZXJ3aXNlIGVtcHR5LlxuICAgKi9cbiAgcHJpdmF0ZSBncHVUZXh0dXJlRGF0YT86IFRlbnNvclRleHR1cmVUeXBlO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgdGhlIHVuZGVybHlpbmcgR1BVIGJ1ZmZlciB3aGVuIGxvY2F0aW9uIGlzICdncHUtYnVmZmVyJy4gb3RoZXJ3aXNlIGVtcHR5LlxuICAgKi9cbiAgcHJpdmF0ZSBncHVCdWZmZXJEYXRhPzogVGVuc29yR3B1QnVmZmVyVHlwZTtcblxuICAvKipcbiAgICogc3RvcmVzIGFuIG9wdGlvbmFsIGRvd25sb2FkZXIgZnVuY3Rpb24gdG8gZG93bmxvYWQgZGF0YSBmcm9tIEdQVSB0byBDUFUuXG4gICAqL1xuICBwcml2YXRlIGRvd25sb2FkZXI/KCk6IFByb21pc2U8VGVuc29yRGF0YVR5cGU+O1xuXG4gIC8qKlxuICAgKiBhIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBkYXRhIGlzIGJlaW5nIGRvd25sb2FkZWQgZnJvbSBHUFUgdG8gQ1BVLlxuICAgKi9cbiAgcHJpdmF0ZSBpc0Rvd25sb2FkaW5nPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogc3RvcmVzIGFuIG9wdGlvbmFsIGRpc3Bvc2VyIGZ1bmN0aW9uIHRvIGRpc3Bvc2UgdGhlIHVuZGVybHlpbmcgZGF0YS5cbiAgICovXG4gIHByaXZhdGUgZGlzcG9zZXI/KCk6IHZvaWQ7XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHByb3BlcnRpZXNcbiAgZ2V0IGRhdGEoKTogVGVuc29yRGF0YVR5cGUge1xuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcbiAgICBpZiAoIXRoaXMuY3B1RGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdUaGUgZGF0YSBpcyBub3Qgb24gQ1BVLiBVc2UgYGdldERhdGEoKWAgdG8gZG93bmxvYWQgR1BVIGRhdGEgdG8gQ1BVLCAnICtcbiAgICAgICAgICAnb3IgdXNlIGB0ZXh0dXJlYCBvciBgZ3B1QnVmZmVyYCBwcm9wZXJ0eSB0byBhY2Nlc3MgdGhlIEdQVSBkYXRhIGRpcmVjdGx5LicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jcHVEYXRhO1xuICB9XG5cbiAgZ2V0IGxvY2F0aW9uKCk6IFRlbnNvckRhdGFMb2NhdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YUxvY2F0aW9uO1xuICB9XG5cbiAgZ2V0IHRleHR1cmUoKTogVGVuc29yVGV4dHVyZVR5cGUge1xuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcbiAgICBpZiAoIXRoaXMuZ3B1VGV4dHVyZURhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYkdMIHRleHR1cmUuJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdwdVRleHR1cmVEYXRhO1xuICB9XG5cbiAgZ2V0IGdwdUJ1ZmZlcigpOiBUZW5zb3JHcHVCdWZmZXJUeXBlIHtcbiAgICB0aGlzLmVuc3VyZVZhbGlkKCk7XG4gICAgaWYgKCF0aGlzLmdwdUJ1ZmZlckRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYkdQVSBidWZmZXIuJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdwdUJ1ZmZlckRhdGE7XG4gIH1cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gbWV0aG9kc1xuXG4gIGFzeW5jIGdldERhdGEocmVsZWFzZURhdGE/OiBib29sZWFuKTogUHJvbWlzZTxUZW5zb3JEYXRhVHlwZT4ge1xuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcbiAgICBzd2l0Y2ggKHRoaXMuZGF0YUxvY2F0aW9uKSB7XG4gICAgICBjYXNlICdjcHUnOlxuICAgICAgY2FzZSAnY3B1LXBpbm5lZCc6XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgICBjYXNlICd0ZXh0dXJlJzpcbiAgICAgIGNhc2UgJ2dwdS1idWZmZXInOiB7XG4gICAgICAgIGlmICghdGhpcy5kb3dubG9hZGVyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3VycmVudCB0ZW5zb3IgaXMgbm90IGNyZWF0ZWQgd2l0aCBhIHNwZWNpZmllZCBkYXRhIGRvd25sb2FkZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNEb3dubG9hZGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmlzRG93bmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmRvd25sb2FkZXIoKTtcbiAgICAgICAgICB0aGlzLmRvd25sb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy5kYXRhTG9jYXRpb24gPSAnY3B1JztcbiAgICAgICAgICB0aGlzLmNwdURhdGEgPSBkYXRhO1xuXG4gICAgICAgICAgaWYgKHJlbGVhc2VEYXRhICYmIHRoaXMuZGlzcG9zZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG5cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aGlzLmlzRG93bmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZ2V0IGRhdGEgZnJvbSBsb2NhdGlvbjogJHt0aGlzLmRhdGFMb2NhdGlvbn1gKTtcbiAgICB9XG4gIH1cblxuICBkaXNwb3NlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzRG93bmxvYWRpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGlzcG9zZXIpIHtcbiAgICAgIHRoaXMuZGlzcG9zZXIoKTtcbiAgICAgIHRoaXMuZGlzcG9zZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMuY3B1RGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmdwdVRleHR1cmVEYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZ3B1QnVmZmVyRGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmRvd25sb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pc0Rvd25sb2FkaW5nID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5kYXRhTG9jYXRpb24gPSAnbm9uZSc7XG4gIH1cblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiB0ZW5zb3IgdXRpbGl0aWVzXG4gIHByaXZhdGUgZW5zdXJlVmFsaWQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZGF0YUxvY2F0aW9uID09PSAnbm9uZScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHRlbnNvciBpcyBkaXNwb3NlZC4nKTtcbiAgICB9XG4gIH1cblxuICByZXNoYXBlKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29ySW50ZXJmYWNlIHtcbiAgICB0aGlzLmVuc3VyZVZhbGlkKCk7XG4gICAgaWYgKHRoaXMuZG93bmxvYWRlciB8fCB0aGlzLmRpc3Bvc2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZXNoYXBlIGEgdGVuc29yIHRoYXQgb3ducyBHUFUgcmVzb3VyY2UuJyk7XG4gICAgfVxuICAgIHJldHVybiB0ZW5zb3JSZXNoYXBlKHRoaXMsIGRpbXMpO1xuICB9XG4gIC8vICNlbmRyZWdpb25cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3JGYWN0b3J5fSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LmpzJztcbmltcG9ydCB7VGVuc29yIGFzIFRlbnNvckltcGx9IGZyb20gJy4vdGVuc29yLWltcGwuanMnO1xuaW1wb3J0IHtUeXBlZFRlbnNvclV0aWxzfSBmcm9tICcuL3RlbnNvci11dGlscy5qcyc7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWRlY2xhcmUgKi9cblxuLyoqXG4gKiByZXByZXNlbnQgYSBiYXNpYyB0ZW5zb3Igd2l0aCBzcGVjaWZpZWQgZGltZW5zaW9ucyBhbmQgZGF0YSB0eXBlLlxuICovXG5pbnRlcmZhY2UgVHlwZWRUZW5zb3JCYXNlPFQgZXh0ZW5kcyBUZW5zb3IuVHlwZT4ge1xuICAvKipcbiAgICogR2V0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSB0ZW5zb3IuXG4gICAqL1xuICByZWFkb25seSBkaW1zOiByZWFkb25seSBudW1iZXJbXTtcbiAgLyoqXG4gICAqIEdldCB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuXG4gICAqL1xuICByZWFkb25seSB0eXBlOiBUO1xuICAvKipcbiAgICogR2V0IHRoZSBidWZmZXIgZGF0YSBvZiB0aGUgdGVuc29yLlxuICAgKlxuICAgKiBJZiB0aGUgZGF0YSBpcyBub3Qgb24gQ1BVIChlZy4gaXQncyBpbiB0aGUgZm9ybSBvZiBXZWJHTCB0ZXh0dXJlIG9yIFdlYkdQVSBidWZmZXIpLCB0aHJvdyBlcnJvci5cbiAgICovXG4gIHJlYWRvbmx5IGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFtUXTtcbiAgLyoqXG4gICAqIEdldCB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEuXG4gICAqL1xuICByZWFkb25seSBsb2NhdGlvbjogVGVuc29yLkRhdGFMb2NhdGlvbjtcbiAgLyoqXG4gICAqIEdldCB0aGUgV2ViR0wgdGV4dHVyZSB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICpcbiAgICogSWYgdGhlIGRhdGEgaXMgbm90IG9uIEdQVSBhcyBXZWJHTCB0ZXh0dXJlLCB0aHJvdyBlcnJvci5cbiAgICovXG4gIHJlYWRvbmx5IHRleHR1cmU6IFRlbnNvci5UZXh0dXJlVHlwZTtcbiAgLyoqXG4gICAqIEdldCB0aGUgV2ViR1BVIGJ1ZmZlciB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICpcbiAgICogSWYgdGhlIGRhdGEgaXMgbm90IG9uIEdQVSBhcyBXZWJHUFUgYnVmZmVyLCB0aHJvdyBlcnJvci5cbiAgICovXG4gIHJlYWRvbmx5IGdwdUJ1ZmZlcjogVGVuc29yLkdwdUJ1ZmZlclR5cGU7XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYnVmZmVyIGRhdGEgb2YgdGhlIHRlbnNvci5cbiAgICpcbiAgICogSWYgdGhlIGRhdGEgaXMgb24gQ1BVLCByZXR1cm5zIHRoZSBkYXRhIGltbWVkaWF0ZWx5LlxuICAgKiBJZiB0aGUgZGF0YSBpcyBvbiBHUFUsIGRvd25sb2FkcyB0aGUgZGF0YSBhbmQgcmV0dXJucyB0aGUgcHJvbWlzZS5cbiAgICpcbiAgICogQHBhcmFtIHJlbGVhc2VEYXRhIC0gd2hldGhlciByZWxlYXNlIHRoZSBkYXRhIG9uIEdQVS4gSWdub3JlIGlmIGRhdGEgaXMgYWxyZWFkeSBvbiBDUFUuXG4gICAqL1xuICBnZXREYXRhKHJlbGVhc2VEYXRhPzogYm9vbGVhbik6IFByb21pc2U8VGVuc29yLkRhdGFUeXBlTWFwW1RdPjtcblxuICAvKipcbiAgICogRGlzcG9zZSB0aGUgdGVuc29yIGRhdGEuXG4gICAqXG4gICAqIElmIHRoZSBkYXRhIGlzIG9uIENQVSwgcmVtb3ZlIGl0cyBpbnRlcm5hbCByZWZlcmVuY2UgdG8gdGhlIHVuZGVybHlpbmcgZGF0YS5cbiAgICogSWYgdGhlIGRhdGEgaXMgb24gR1BVLCByZWxlYXNlIHRoZSBkYXRhIG9uIEdQVS5cbiAgICpcbiAgICogQWZ0ZXIgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLCB0aGUgdGVuc29yIGlzIGNvbnNpZGVyZWQgbm8gbG9uZ2VyIHZhbGlkLiBJdHMgbG9jYXRpb24gd2lsbCBiZSBzZXQgdG8gJ25vbmUnLlxuICAgKi9cbiAgZGlzcG9zZSgpOiB2b2lkO1xufVxuXG5leHBvcnQgZGVjbGFyZSBuYW1lc3BhY2UgVGVuc29yIHtcbiAgaW50ZXJmYWNlIERhdGFUeXBlTWFwIHtcbiAgICBmbG9hdDMyOiBGbG9hdDMyQXJyYXk7XG4gICAgdWludDg6IFVpbnQ4QXJyYXk7XG4gICAgaW50ODogSW50OEFycmF5O1xuICAgIHVpbnQxNjogVWludDE2QXJyYXk7XG4gICAgaW50MTY6IEludDE2QXJyYXk7XG4gICAgaW50MzI6IEludDMyQXJyYXk7XG4gICAgaW50NjQ6IEJpZ0ludDY0QXJyYXk7XG4gICAgc3RyaW5nOiBzdHJpbmdbXTtcbiAgICBib29sOiBVaW50OEFycmF5O1xuICAgIGZsb2F0MTY6IFVpbnQxNkFycmF5OyAgLy8gS2VlcCB1c2luZyBVaW50MTZBcnJheSB1bnRpbCB3ZSBoYXZlIGEgY29uY3JldGUgc29sdXRpb24gZm9yIGZsb2F0IDE2LlxuICAgIGZsb2F0NjQ6IEZsb2F0NjRBcnJheTtcbiAgICB1aW50MzI6IFVpbnQzMkFycmF5O1xuICAgIHVpbnQ2NDogQmlnVWludDY0QXJyYXk7XG4gICAgLy8gY29tcGxleDY0OiBuZXZlcjtcbiAgICAvLyBjb21wbGV4MTI4OiBuZXZlcjtcbiAgICAvLyBiZmxvYXQxNjogbmV2ZXI7XG4gIH1cblxuICBpbnRlcmZhY2UgRWxlbWVudFR5cGVNYXAge1xuICAgIGZsb2F0MzI6IG51bWJlcjtcbiAgICB1aW50ODogbnVtYmVyO1xuICAgIGludDg6IG51bWJlcjtcbiAgICB1aW50MTY6IG51bWJlcjtcbiAgICBpbnQxNjogbnVtYmVyO1xuICAgIGludDMyOiBudW1iZXI7XG4gICAgaW50NjQ6IGJpZ2ludDtcbiAgICBzdHJpbmc6IHN0cmluZztcbiAgICBib29sOiBib29sZWFuO1xuICAgIGZsb2F0MTY6IG51bWJlcjsgIC8vIEtlZXAgdXNpbmcgVWludDE2QXJyYXkgdW50aWwgd2UgaGF2ZSBhIGNvbmNyZXRlIHNvbHV0aW9uIGZvciBmbG9hdCAxNi5cbiAgICBmbG9hdDY0OiBudW1iZXI7XG4gICAgdWludDMyOiBudW1iZXI7XG4gICAgdWludDY0OiBiaWdpbnQ7XG4gICAgLy8gY29tcGxleDY0OiBuZXZlcjtcbiAgICAvLyBjb21wbGV4MTI4OiBuZXZlcjtcbiAgICAvLyBiZmxvYXQxNjogbmV2ZXI7XG4gIH1cblxuICB0eXBlIERhdGFUeXBlID0gRGF0YVR5cGVNYXBbVHlwZV07XG4gIHR5cGUgRWxlbWVudFR5cGUgPSBFbGVtZW50VHlwZU1hcFtUeXBlXTtcblxuICAvKipcbiAgICogc3VwcG9ydGVkIGRhdGEgdHlwZXMgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgcGlubmVkIENQVSBidWZmZXJcbiAgICovXG4gIGV4cG9ydCB0eXBlIENwdVBpbm5lZERhdGFUeXBlcyA9IEV4Y2x1ZGU8VGVuc29yLlR5cGUsICdzdHJpbmcnPjtcblxuICAvKipcbiAgICogdHlwZSBhbGlhcyBmb3IgV2ViR0wgdGV4dHVyZVxuICAgKi9cbiAgZXhwb3J0IHR5cGUgVGV4dHVyZVR5cGUgPSBXZWJHTFRleHR1cmU7XG5cbiAgLyoqXG4gICAqIHN1cHBvcnRlZCBkYXRhIHR5cGVzIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIFdlYkdMIHRleHR1cmVcbiAgICovXG4gIGV4cG9ydCB0eXBlIFRleHR1cmVEYXRhVHlwZXMgPSAnZmxvYXQzMic7XG5cbiAgLyoqXG4gICAqIHR5cGUgYWxpYXMgZm9yIFdlYkdQVSBidWZmZXJcbiAgICpcbiAgICogVGhlIHJlYXNvbiB3aHkgd2UgZG9uJ3QgdXNlIHR5cGUgXCJHUFVCdWZmZXJcIiBkZWZpbmVkIGluIHdlYmdwdS5kLnRzIGZyb20gQHdlYmdwdS90eXBlcyBpcyBiZWNhdXNlIFwiQHdlYmdwdS90eXBlc1wiXG4gICAqIHJlcXVpcmVzIFwiQHR5cGVzL2RvbS13ZWJjb2RlY3NcIiBhcyBwZWVyIGRlcGVuZGVuY3kgd2hlbiB1c2luZyBUeXBlU2NyaXB0IDwgdjUuMSBhbmQgaXRzIHZlcnNpb24gbmVlZCB0byBiZSBjaG9zZW5cbiAgICogY2FyZWZ1bGx5IGFjY29yZGluZyB0byB0aGUgVHlwZVNjcmlwdCB2ZXJzaW9uIGJlaW5nIHVzZWQuIFRoaXMgbWVhbnMgc28gZmFyIHRoZXJlIGlzIG5vdCBhIHdheSB0byBrZWVwIGV2ZXJ5XG4gICAqIFR5cGVTY3JpcHQgdmVyc2lvbiBoYXBweS4gSXQgdHVybnMgb3V0IHRoYXQgd2Ugd2lsbCBlYXNpbHkgYnJva2UgdXNlcnMgb24gc29tZSBUeXBlU2NyaXB0IHZlcnNpb24uXG4gICAqXG4gICAqIGZvciBtb3JlIGluZm8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncHV3ZWIvdHlwZXMvaXNzdWVzLzEyN1xuICAgKi9cbiAgZXhwb3J0IHR5cGUgR3B1QnVmZmVyVHlwZSA9IHtzaXplOiBudW1iZXI7IG1hcFN0YXRlOiAndW5tYXBwZWQnIHwgJ3BlbmRpbmcnIHwgJ21hcHBlZCd9O1xuXG4gIC8qKlxuICAgKiBzdXBwb3J0ZWQgZGF0YSB0eXBlcyBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBXZWJHUFUgYnVmZmVyXG4gICAqL1xuICBleHBvcnQgdHlwZSBHcHVCdWZmZXJEYXRhVHlwZXMgPSAnZmxvYXQzMid8J2Zsb2F0MTYnfCdpbnQzMid8J2ludDY0J3wndWludDMyJ3wndWludDgnfCdib29sJztcblxuICAvKipcbiAgICogcmVwcmVzZW50IHdoZXJlIHRoZSB0ZW5zb3IgZGF0YSBpcyBzdG9yZWRcbiAgICovXG4gIGV4cG9ydCB0eXBlIERhdGFMb2NhdGlvbiA9ICdub25lJ3wnY3B1J3wnY3B1LXBpbm5lZCd8J3RleHR1cmUnfCdncHUtYnVmZmVyJztcblxuICAvKipcbiAgICogcmVwcmVzZW50IHRoZSBkYXRhIHR5cGUgb2YgYSB0ZW5zb3JcbiAgICovXG4gIGV4cG9ydCB0eXBlIFR5cGUgPSBrZXlvZiBEYXRhVHlwZU1hcDtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgbXVsdGktZGltZW5zaW9uYWwgYXJyYXlzIHRvIGZlZWQgdG8gb3IgZmV0Y2ggZnJvbSBtb2RlbCBpbmZlcmVuY2luZy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUeXBlZFRlbnNvcjxUIGV4dGVuZHMgVGVuc29yLlR5cGU+IGV4dGVuZHMgVHlwZWRUZW5zb3JCYXNlPFQ+LCBUeXBlZFRlbnNvclV0aWxzPFQ+IHt9XG4vKipcbiAqIFJlcHJlc2VudCBtdWx0aS1kaW1lbnNpb25hbCBhcnJheXMgdG8gZmVlZCB0byBvciBmZXRjaCBmcm9tIG1vZGVsIGluZmVyZW5jaW5nLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvciBleHRlbmRzIFR5cGVkVGVuc29yQmFzZTxUZW5zb3IuVHlwZT4sIFR5cGVkVGVuc29yVXRpbHM8VGVuc29yLlR5cGU+IHt9XG5cbi8qKlxuICogdHlwZSBUZW5zb3JDb25zdHJ1Y3RvciBkZWZpbmVzIHRoZSBjb25zdHJ1Y3RvcnMgb2YgJ1RlbnNvcicgdG8gY3JlYXRlIENQVSB0ZW5zb3IgaW5zdGFuY2VzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckNvbnN0cnVjdG9yIGV4dGVuZHMgVGVuc29yRmFjdG9yeSB7XG4gIC8vICNyZWdpb24gQ1BVIHRlbnNvciAtIHNwZWNpZnkgZWxlbWVudCB0eXBlXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgc3RyaW5nIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyh0eXBlOiAnc3RyaW5nJywgZGF0YTogVGVuc29yLkRhdGFUeXBlTWFwWydzdHJpbmcnXXxyZWFkb25seSBzdHJpbmdbXSxcbiAgICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdzdHJpbmcnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGJvb2wgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB0eXBlLCBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIFNwZWNpZnkgdGhlIGVsZW1lbnQgdHlwZS5cbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KHR5cGU6ICdib29sJywgZGF0YTogVGVuc29yLkRhdGFUeXBlTWFwWydib29sJ118cmVhZG9ubHkgYm9vbGVhbltdLCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnYm9vbCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgNjQtYml0IGludGVnZXIgdHlwZWQgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB0eXBlLCBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIFNwZWNpZnkgdGhlIGVsZW1lbnQgdHlwZS5cbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3PFQgZXh0ZW5kcyAndWludDY0J3wnaW50NjQnPihcbiAgICAgIHR5cGU6IFQsIGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFtUXXxyZWFkb25seSBiaWdpbnRbXXxyZWFkb25seSBudW1iZXJbXSxcbiAgICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPFQ+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgbnVtZXJpYyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIHR5cGUsIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gU3BlY2lmeSB0aGUgZWxlbWVudCB0eXBlLlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXc8VCBleHRlbmRzIEV4Y2x1ZGU8VGVuc29yLlR5cGUsICdzdHJpbmcnfCdib29sJ3wndWludDY0J3wnaW50NjQnPj4oXG4gICAgICB0eXBlOiBULCBkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbVF18cmVhZG9ubHkgbnVtYmVyW10sIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPFQ+O1xuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBDUFUgdGVuc29yIC0gaW5mZXIgZWxlbWVudCB0eXBlc1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgZmxvYXQzMiB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyhkYXRhOiBGbG9hdDMyQXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdmbG9hdDMyJz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBpbnQ4IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KGRhdGE6IEludDhBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2ludDgnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHVpbnQ4IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KGRhdGE6IFVpbnQ4QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50OCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdWludDE2IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KGRhdGE6IFVpbnQxNkFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwndWludDE2Jz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBpbnQxNiB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyhkYXRhOiBJbnQxNkFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnaW50MTYnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGludDMyIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KGRhdGE6IEludDMyQXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdpbnQzMic+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgaW50NjQgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcoZGF0YTogQmlnSW50NjRBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2ludDY0Jz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBzdHJpbmcgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcoZGF0YTogcmVhZG9ubHkgc3RyaW5nW10sIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdzdHJpbmcnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGJvb2wgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcoZGF0YTogcmVhZG9ubHkgYm9vbGVhbltdLCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnYm9vbCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgZmxvYXQ2NCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyhkYXRhOiBGbG9hdDY0QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdmbG9hdDY0Jz47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB1aW50MzIgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcoZGF0YTogVWludDMyQXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50MzInPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHVpbnQ2NCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyhkYXRhOiBCaWdVaW50NjRBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J3VpbnQ2NCc+O1xuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIENQVSB0ZW5zb3IgLSBmYWxsIGJhY2sgdG8gbm9uLWdlbmVyaWMgdGVuc29yIHR5cGUgZGVjbGFyYXRpb25cblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyh0eXBlOiBUZW5zb3IuVHlwZSwgZGF0YTogVGVuc29yLkRhdGFUeXBlfHJlYWRvbmx5IG51bWJlcltdfHJlYWRvbmx5IHN0cmluZ1tdfHJlYWRvbmx5IGJpZ2ludFtdfHJlYWRvbmx5IGJvb2xlYW5bXSxcbiAgICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvcjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3KGRhdGE6IFRlbnNvci5EYXRhVHlwZSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29yO1xuICAvLyAjZW5kcmVnaW9uXG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmV4cG9ydCBjb25zdCBUZW5zb3IgPSBUZW5zb3JJbXBsIGFzIFRlbnNvckNvbnN0cnVjdG9yO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge2Vudn0gZnJvbSAnLi9lbnYtaW1wbC5qcyc7XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY29uc3QgVFJBQ0UgPSAoZGV2aWNlVHlwZTogc3RyaW5nLCBsYWJlbDogc3RyaW5nKSA9PiB7XG4gIGlmICh0eXBlb2YgZW52LnRyYWNlID09PSAndW5kZWZpbmVkJyA/ICFlbnYud2FzbS50cmFjZSA6ICFlbnYudHJhY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgY29uc29sZS50aW1lU3RhbXAoYCR7ZGV2aWNlVHlwZX06Ok9SVDo6JHtsYWJlbH1gKTtcbn07XG5cbmNvbnN0IFRSQUNFX0ZVTkMgPSAobXNnOiBzdHJpbmcsIGV4dHJhTXNnPzogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s/LnNwbGl0KC9cXHJcXG58XFxyfFxcbi9nKSB8fCBbXTtcbiAgbGV0IGhhc1RyYWNlRnVuYyA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGhhc1RyYWNlRnVuYyAmJiAhc3RhY2tbaV0uaW5jbHVkZXMoJ1RSQUNFX0ZVTkMnKSkge1xuICAgICAgbGV0IGxhYmVsID0gYEZVTkNfJHttc2d9Ojoke3N0YWNrW2ldLnRyaW0oKS5zcGxpdCgnICcpWzFdfWA7XG4gICAgICBpZiAoZXh0cmFNc2cpIHtcbiAgICAgICAgbGFiZWwgKz0gYDo6JHtleHRyYU1zZ31gO1xuICAgICAgfVxuICAgICAgVFJBQ0UoJ0NQVScsIGxhYmVsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN0YWNrW2ldLmluY2x1ZGVzKCdUUkFDRV9GVU5DJykpIHtcbiAgICAgIGhhc1RyYWNlRnVuYyA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGNvbnN0IFRSQUNFX0ZVTkNfQkVHSU4gPSAoZXh0cmFNc2c/OiBzdHJpbmcpID0+IHtcbiAgaWYgKHR5cGVvZiBlbnYudHJhY2UgPT09ICd1bmRlZmluZWQnID8gIWVudi53YXNtLnRyYWNlIDogIWVudi50cmFjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBUUkFDRV9GVU5DKCdCRUdJTicsIGV4dHJhTXNnKTtcbn07XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY29uc3QgVFJBQ0VfRlVOQ19FTkQgPSAoZXh0cmFNc2c/OiBzdHJpbmcpID0+IHtcbiAgaWYgKHR5cGVvZiBlbnYudHJhY2UgPT09ICd1bmRlZmluZWQnID8gIWVudi53YXNtLnRyYWNlIDogIWVudi50cmFjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBUUkFDRV9GVU5DKCdFTkQnLCBleHRyYU1zZyk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge3Jlc29sdmVCYWNrZW5kQW5kRXhlY3V0aW9uUHJvdmlkZXJzfSBmcm9tICcuL2JhY2tlbmQtaW1wbC5qcyc7XG5pbXBvcnQge0luZmVyZW5jZVNlc3Npb25IYW5kbGVyfSBmcm9tICcuL2JhY2tlbmQuanMnO1xuaW1wb3J0IHtJbmZlcmVuY2VTZXNzaW9uIGFzIEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2V9IGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24uanMnO1xuaW1wb3J0IHtPbm54VmFsdWV9IGZyb20gJy4vb25ueC12YWx1ZS5qcyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi90ZW5zb3IuanMnO1xuaW1wb3J0IHtUUkFDRV9GVU5DX0JFR0lOLCBUUkFDRV9GVU5DX0VORH0gZnJvbSAnLi90cmFjZS5qcyc7XG5cbnR5cGUgU2Vzc2lvbk9wdGlvbnMgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLlNlc3Npb25PcHRpb25zO1xudHlwZSBSdW5PcHRpb25zID0gSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5SdW5PcHRpb25zO1xudHlwZSBGZWVkc1R5cGUgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLkZlZWRzVHlwZTtcbnR5cGUgRmV0Y2hlc1R5cGUgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLkZldGNoZXNUeXBlO1xudHlwZSBSZXR1cm5UeXBlID0gSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5SZXR1cm5UeXBlO1xuXG5leHBvcnQgY2xhc3MgSW5mZXJlbmNlU2Vzc2lvbiBpbXBsZW1lbnRzIEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2Uge1xuICBwcml2YXRlIGNvbnN0cnVjdG9yKGhhbmRsZXI6IEluZmVyZW5jZVNlc3Npb25IYW5kbGVyKSB7XG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgfVxuICBydW4oZmVlZHM6IEZlZWRzVHlwZSwgb3B0aW9ucz86IFJ1bk9wdGlvbnMpOiBQcm9taXNlPFJldHVyblR5cGU+O1xuICBydW4oZmVlZHM6IEZlZWRzVHlwZSwgZmV0Y2hlczogRmV0Y2hlc1R5cGUsIG9wdGlvbnM/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPjtcbiAgYXN5bmMgcnVuKGZlZWRzOiBGZWVkc1R5cGUsIGFyZzE/OiBGZXRjaGVzVHlwZXxSdW5PcHRpb25zLCBhcmcyPzogUnVuT3B0aW9ucyk6IFByb21pc2U8UmV0dXJuVHlwZT4ge1xuICAgIFRSQUNFX0ZVTkNfQkVHSU4oKTtcbiAgICBjb25zdCBmZXRjaGVzOiB7W25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZXxudWxsfSA9IHt9O1xuICAgIGxldCBvcHRpb25zOiBSdW5PcHRpb25zID0ge307XG4gICAgLy8gY2hlY2sgaW5wdXRzXG4gICAgaWYgKHR5cGVvZiBmZWVkcyAhPT0gJ29iamVjdCcgfHwgZmVlZHMgPT09IG51bGwgfHwgZmVlZHMgaW5zdGFuY2VvZiBUZW5zb3IgfHwgQXJyYXkuaXNBcnJheShmZWVkcykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ1xcJ2ZlZWRzXFwnIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgdXNlIGlucHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy4nKTtcbiAgICB9XG5cbiAgICBsZXQgaXNGZXRjaGVzRW1wdHkgPSB0cnVlO1xuICAgIC8vIGRldGVybWluZSB3aGljaCBvdmVycmlkZSBpcyBiZWluZyB1c2VkXG4gICAgaWYgKHR5cGVvZiBhcmcxID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGFyZzEgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5leHBlY3RlZCBhcmd1bWVudFsxXTogY2Fubm90IGJlIG51bGwuJyk7XG4gICAgICB9XG4gICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdmZXRjaGVzXFwnIGNhbm5vdCBiZSBhIFRlbnNvcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcxKSkge1xuICAgICAgICBpZiAoYXJnMS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdmZXRjaGVzXFwnIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpc0ZldGNoZXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICAvLyBvdXRwdXQgbmFtZXNcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIGFyZzEpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdmZXRjaGVzXFwnIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkgb3IgYW4gb2JqZWN0LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdmZXRjaGVzJyBjb250YWlucyBpbnZhbGlkIG91dHB1dCBuYW1lOiAke25hbWV9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmZXRjaGVzW25hbWVdID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ29iamVjdCcgJiYgYXJnMiAhPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ29wdGlvbnNcXCcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlY2lkZSB3aGV0aGVyIGFyZzEgaXMgZmV0Y2hlcyBvciBvcHRpb25zXG4gICAgICAgIC8vIGlmIGFueSBvdXRwdXQgbmFtZSBpcyBwcmVzZW50IGFuZCBpdHMgdmFsdWUgaXMgdmFsaWQgT25ueFZhbHVlLCB3ZSBjb25zaWRlciBpdCBmZXRjaGVzXG4gICAgICAgIGxldCBpc0ZldGNoZXMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgYXJnMUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcmcxKTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMub3V0cHV0TmFtZXMpIHtcbiAgICAgICAgICBpZiAoYXJnMUtleXMuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSAoYXJnMSBhcyBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLk51bGxhYmxlT25ueFZhbHVlTWFwVHlwZSlbbmFtZV07XG4gICAgICAgICAgICBpZiAodiA9PT0gbnVsbCB8fCB2IGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgICAgICAgIGlzRmV0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0ZldGNoZXMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zID0gYXJnMSBhcyBSdW5PcHRpb25zO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VuZXhwZWN0ZWQgYXJndW1lbnRbMV06IG11c3QgYmUgXFwnZmV0Y2hlc1xcJyBvciBcXCdvcHRpb25zXFwnLicpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIGFsbCBpbnB1dHMgYXJlIGluIGZlZWRcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5pbnB1dE5hbWVzKSB7XG4gICAgICBpZiAodHlwZW9mIGZlZWRzW25hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGlucHV0ICcke25hbWV9JyBpcyBtaXNzaW5nIGluICdmZWVkcycuYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgbm8gZmV0Y2hlcyBpcyBzcGVjaWZpZWQsIHdlIHVzZSB0aGUgZnVsbCBvdXRwdXQgbmFtZXMgbGlzdFxuICAgIGlmIChpc0ZldGNoZXNFbXB0eSkge1xuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMub3V0cHV0TmFtZXMpIHtcbiAgICAgICAgZmV0Y2hlc1tuYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmVlZHMsIGZldGNoZXMgYW5kIG9wdGlvbnMgYXJlIHByZXBhcmVkXG5cbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5oYW5kbGVyLnJ1bihmZWVkcywgZmV0Y2hlcywgb3B0aW9ucyk7XG4gICAgY29uc3QgcmV0dXJuVmFsdWU6IHtbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlfSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdHMpIHtcbiAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHRzLCBrZXkpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdHNba2V5XTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICAgIHJldHVyblZhbHVlW2tleV0gPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuVmFsdWVba2V5XSA9IG5ldyBUZW5zb3IocmVzdWx0LnR5cGUsIHJlc3VsdC5kYXRhLCByZXN1bHQuZGltcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgVFJBQ0VfRlVOQ19FTkQoKTtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH1cblxuICBhc3luYyByZWxlYXNlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZShwYXRoOiBzdHJpbmcsIG9wdGlvbnM/OiBTZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZT47XG4gIHN0YXRpYyBjcmVhdGUoYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2UsIG9wdGlvbnM/OiBTZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZT47XG4gIHN0YXRpYyBjcmVhdGUoYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2UsIGJ5dGVPZmZzZXQ6IG51bWJlciwgYnl0ZUxlbmd0aD86IG51bWJlciwgb3B0aW9ucz86IFNlc3Npb25PcHRpb25zKTpcbiAgICAgIFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZT47XG4gIHN0YXRpYyBjcmVhdGUoYnVmZmVyOiBVaW50OEFycmF5LCBvcHRpb25zPzogU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2U+O1xuICBzdGF0aWMgYXN5bmMgY3JlYXRlKFxuICAgICAgYXJnMDogc3RyaW5nfEFycmF5QnVmZmVyTGlrZXxVaW50OEFycmF5LCBhcmcxPzogU2Vzc2lvbk9wdGlvbnN8bnVtYmVyLCBhcmcyPzogbnVtYmVyLFxuICAgICAgYXJnMz86IFNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlPiB7XG4gICAgVFJBQ0VfRlVOQ19CRUdJTigpO1xuICAgIC8vIGVpdGhlciBsb2FkIGZyb20gYSBmaWxlIG9yIGJ1ZmZlclxuICAgIGxldCBmaWxlUGF0aE9yVWludDhBcnJheTogc3RyaW5nfFVpbnQ4QXJyYXk7XG4gICAgbGV0IG9wdGlvbnM6IFNlc3Npb25PcHRpb25zID0ge307XG5cbiAgICBpZiAodHlwZW9mIGFyZzAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBmaWxlUGF0aE9yVWludDhBcnJheSA9IGFyZzA7XG4gICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnICYmIGFyZzEgIT09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IGFyZzE7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJnMCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIGZpbGVQYXRoT3JVaW50OEFycmF5ID0gYXJnMDtcbiAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcgJiYgYXJnMSAhPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ29wdGlvbnNcXCcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgICAgYXJnMCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgICAgICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGFyZzAgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcikpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGFyZzA7XG4gICAgICBsZXQgYnl0ZU9mZnNldCA9IDA7XG4gICAgICBsZXQgYnl0ZUxlbmd0aCA9IGFyZzAuYnl0ZUxlbmd0aDtcbiAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcgJiYgYXJnMSAhPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGJ5dGVPZmZzZXQgPSBhcmcxO1xuICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGJ5dGVPZmZzZXQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2J5dGVPZmZzZXRcXCcgbXVzdCBiZSBhbiBpbnRlZ2VyLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBieXRlT2Zmc2V0ID49IGJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdieXRlT2Zmc2V0JyBpcyBvdXQgb2YgcmFuZ2UgWzAsICR7YnVmZmVyLmJ5dGVMZW5ndGh9KS5gKTtcbiAgICAgICAgfVxuICAgICAgICBieXRlTGVuZ3RoID0gYXJnMC5ieXRlTGVuZ3RoIC0gYnl0ZU9mZnNldDtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcyID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGJ5dGVMZW5ndGggPSBhcmcyO1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoYnl0ZUxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdieXRlTGVuZ3RoXFwnIG11c3QgYmUgYW4gaW50ZWdlci4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJ5dGVMZW5ndGggPD0gMCB8fCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCA+IGJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVMZW5ndGgnIGlzIG91dCBvZiByYW5nZSAoMCwgJHtidWZmZXIuYnl0ZUxlbmd0aCAtIGJ5dGVPZmZzZXR9XS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBhcmczID09PSAnb2JqZWN0JyAmJiBhcmczICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gYXJnMztcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmczICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnb3B0aW9uc1xcJyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnYnl0ZUxlbmd0aFxcJyBtdXN0IGJlIGEgbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcxICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXCdvcHRpb25zXFwnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgfVxuICAgICAgZmlsZVBhdGhPclVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIGFyZ3VtZW50WzBdOiBtdXN0IGJlIFxcJ3BhdGhcXCcgb3IgXFwnYnVmZmVyXFwnLicpO1xuICAgIH1cblxuICAgIC8vIHJlc29sdmUgYmFja2VuZCwgdXBkYXRlIHNlc3Npb24gb3B0aW9ucyB3aXRoIHZhbGlkYXRlZCBFUHMsIGFuZCBjcmVhdGUgc2Vzc2lvbiBoYW5kbGVyXG4gICAgY29uc3QgW2JhY2tlbmQsIG9wdGlvbnNXaXRoVmFsaWRhdGVkRVBzXSA9IGF3YWl0IHJlc29sdmVCYWNrZW5kQW5kRXhlY3V0aW9uUHJvdmlkZXJzKG9wdGlvbnMpO1xuICAgIGNvbnN0IGhhbmRsZXIgPSBhd2FpdCBiYWNrZW5kLmNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKGZpbGVQYXRoT3JVaW50OEFycmF5LCBvcHRpb25zV2l0aFZhbGlkYXRlZEVQcyk7XG4gICAgVFJBQ0VfRlVOQ19FTkQoKTtcbiAgICByZXR1cm4gbmV3IEluZmVyZW5jZVNlc3Npb24oaGFuZGxlcik7XG4gIH1cblxuICBzdGFydFByb2ZpbGluZygpOiB2b2lkIHtcbiAgICB0aGlzLmhhbmRsZXIuc3RhcnRQcm9maWxpbmcoKTtcbiAgfVxuICBlbmRQcm9maWxpbmcoKTogdm9pZCB7XG4gICAgdGhpcy5oYW5kbGVyLmVuZFByb2ZpbGluZygpO1xuICB9XG5cbiAgZ2V0IGlucHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuaW5wdXROYW1lcztcbiAgfVxuICBnZXQgb3V0cHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIub3V0cHV0TmFtZXM7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZXI6IEluZmVyZW5jZVNlc3Npb25IYW5kbGVyO1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0luZmVyZW5jZVNlc3Npb24gYXMgSW5mZXJlbmNlU2Vzc2lvbkltcGx9IGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24taW1wbC5qcyc7XG5pbXBvcnQge09ubnhNb2RlbE9wdGlvbnN9IGZyb20gJy4vb25ueC1tb2RlbC5qcyc7XG5pbXBvcnQge09ubnhWYWx1ZSwgT25ueFZhbHVlRGF0YUxvY2F0aW9ufSBmcm9tICcuL29ubngtdmFsdWUuanMnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkZWNsYXJlICovXG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBJbmZlcmVuY2VTZXNzaW9uIHtcbiAgLy8gI3JlZ2lvbiBpbnB1dC9vdXRwdXQgdHlwZXNcblxuICB0eXBlIE9ubnhWYWx1ZU1hcFR5cGUgPSB7cmVhZG9ubHkgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZX07XG4gIHR5cGUgTnVsbGFibGVPbm54VmFsdWVNYXBUeXBlID0ge3JlYWRvbmx5IFtuYW1lOiBzdHJpbmddOiBPbm54VmFsdWUgfCBudWxsfTtcblxuICAvKipcbiAgICogQSBmZWVkcyAobW9kZWwgaW5wdXRzKSBpcyBhbiBvYmplY3QgdGhhdCB1c2VzIGlucHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICovXG4gIHR5cGUgRmVlZHNUeXBlID0gT25ueFZhbHVlTWFwVHlwZTtcblxuICAvKipcbiAgICogQSBmZXRjaGVzIChtb2RlbCBvdXRwdXRzKSBjb3VsZCBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAgICpcbiAgICogLSBPbWl0dGVkLiBVc2UgbW9kZWwncyBvdXRwdXQgbmFtZXMgZGVmaW5pdGlvbi5cbiAgICogLSBBbiBhcnJheSBvZiBzdHJpbmcgaW5kaWNhdGluZyB0aGUgb3V0cHV0IG5hbWVzLlxuICAgKiAtIEFuIG9iamVjdCB0aGF0IHVzZSBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIG9yIG51bGwgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAqXG4gICAqIEByZW1hcmtcbiAgICogZGlmZmVyZW50IGZyb20gaW5wdXQgYXJndW1lbnQsIGluIG91dHB1dCwgT25ueFZhbHVlIGlzIG9wdGlvbmFsLiBJZiBhbiBPbm54VmFsdWUgaXMgcHJlc2VudCBpdCB3aWxsIGJlXG4gICAqIHVzZWQgYXMgYSBwcmUtYWxsb2NhdGVkIHZhbHVlIGJ5IHRoZSBpbmZlcmVuY2UgZW5naW5lOyBpZiBvbWl0dGVkLCBpbmZlcmVuY2UgZW5naW5lIHdpbGwgYWxsb2NhdGUgYnVmZmVyXG4gICAqIGludGVybmFsbHkuXG4gICAqL1xuICB0eXBlIEZldGNoZXNUeXBlID0gcmVhZG9ubHkgc3RyaW5nW118TnVsbGFibGVPbm54VmFsdWVNYXBUeXBlO1xuXG4gIC8qKlxuICAgKiBBIGluZmVyZW5jaW5nIHJldHVybiB0eXBlIGlzIGFuIG9iamVjdCB0aGF0IHVzZXMgb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICovXG4gIHR5cGUgUmV0dXJuVHlwZSA9IE9ubnhWYWx1ZU1hcFR5cGU7XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gc2Vzc2lvbiBvcHRpb25zXG5cbiAgLyoqXG4gICAqIEEgc2V0IG9mIGNvbmZpZ3VyYXRpb25zIGZvciBzZXNzaW9uIGJlaGF2aW9yLlxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uT3B0aW9ucyBleHRlbmRzIE9ubnhNb2RlbE9wdGlvbnMge1xuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIGV4ZWN1dGlvbiBwcm92aWRlciBvcHRpb25zLlxuICAgICAqXG4gICAgICogQW4gZXhlY3V0aW9uIHByb3ZpZGVyIG9wdGlvbiBjYW4gYmUgYSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgbmFtZSBvZiB0aGUgZXhlY3V0aW9uIHByb3ZpZGVyLFxuICAgICAqIG9yIGFuIG9iamVjdCBvZiBjb3JyZXNwb25kaW5nIHR5cGUuXG4gICAgICovXG4gICAgZXhlY3V0aW9uUHJvdmlkZXJzPzogcmVhZG9ubHkgRXhlY3V0aW9uUHJvdmlkZXJDb25maWdbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRyYSBPUCB0aHJlYWRzIG51bWJlci5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpLlxuICAgICAqL1xuICAgIGludHJhT3BOdW1UaHJlYWRzPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVyIE9QIHRocmVhZHMgbnVtYmVyLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkuXG4gICAgICovXG4gICAgaW50ZXJPcE51bVRocmVhZHM/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgZnJlZURpbWVuc2lvbk92ZXJyaWRlcz86IHtyZWFkb25seSBbZGltZW5zaW9uTmFtZTogc3RyaW5nXTogbnVtYmVyfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHRpbWl6YXRpb24gbGV2ZWwuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgZ3JhcGhPcHRpbWl6YXRpb25MZXZlbD86ICdkaXNhYmxlZCd8J2Jhc2ljJ3wnZXh0ZW5kZWQnfCdhbGwnO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBlbmFibGUgQ1BVIG1lbW9yeSBhcmVuYS5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBlbmFibGVDcHVNZW1BcmVuYT86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGVuYWJsZSBtZW1vcnkgcGF0dGVybi5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBlbmFibGVNZW1QYXR0ZXJuPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGlvbiBtb2RlLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGV4ZWN1dGlvbk1vZGU/OiAnc2VxdWVudGlhbCd8J3BhcmFsbGVsJztcblxuICAgIC8qKlxuICAgICAqIE9wdGltaXplZCBtb2RlbCBmaWxlIHBhdGguXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIHNldHRpbmcgaXMgc3BlY2lmaWVkLCB0aGUgb3B0aW1pemVkIG1vZGVsIHdpbGwgYmUgZHVtcGVkLiBJbiBicm93c2VyLCBhIGJsb2Igd2lsbCBiZSBjcmVhdGVkXG4gICAgICogd2l0aCBhIHBvcC11cCB3aW5kb3cuXG4gICAgICovXG4gICAgb3B0aW1pemVkTW9kZWxGaWxlUGF0aD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgZW5hYmxlIHByb2ZpbGluZy5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhIHBsYWNlaG9sZGVyIGZvciBhIGZ1dHVyZSB1c2UuXG4gICAgICovXG4gICAgZW5hYmxlUHJvZmlsaW5nPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEZpbGUgcHJlZml4IGZvciBwcm9maWxpbmcuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYSBwbGFjZWhvbGRlciBmb3IgYSBmdXR1cmUgdXNlLlxuICAgICAqL1xuICAgIHByb2ZpbGVGaWxlUHJlZml4Pzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogTG9nIElELlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGxvZ0lkPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogTG9nIHNldmVyaXR5IGxldmVsLiBTZWVcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhydW50aW1lL2Jsb2IvbWFpbi9pbmNsdWRlL29ubnhydW50aW1lL2NvcmUvY29tbW9uL2xvZ2dpbmcvc2V2ZXJpdHkuaFxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGxvZ1NldmVyaXR5TGV2ZWw/OiAwfDF8MnwzfDQ7XG5cbiAgICAvKipcbiAgICAgKiBMb2cgdmVyYm9zaXR5IGxldmVsLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIFdlYkFzc2VtYmx5IGJhY2tlbmQuIFdpbGwgc3VwcG9ydCBOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSBsYXRlclxuICAgICAqL1xuICAgIGxvZ1ZlcmJvc2l0eUxldmVsPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSBzdHJpbmcgYXMgYSBwcmVmZXJyZWQgZGF0YSBsb2NhdGlvbiBmb3IgYWxsIG91dHB1dHMsIG9yIGFuIG9iamVjdCB0aGF0IHVzZSBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgYVxuICAgICAqIHByZWZlcnJlZCBkYXRhIGxvY2F0aW9uIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIFdlYiBmb3IgV2ViR0wgYW5kIFdlYkdQVSBFUC5cbiAgICAgKi9cbiAgICBwcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj86IE9ubnhWYWx1ZURhdGFMb2NhdGlvbnx7cmVhZG9ubHkgW291dHB1dE5hbWU6IHN0cmluZ106IE9ubnhWYWx1ZURhdGFMb2NhdGlvbn07XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGVuYWJsZSBncmFwaCBjYXB0dXJlLlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSBXZWIgZm9yIFdlYkdQVSBFUC5cbiAgICAgKi9cbiAgICBlbmFibGVHcmFwaENhcHR1cmU/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogU3RvcmUgY29uZmlndXJhdGlvbnMgZm9yIGEgc2Vzc2lvbi4gU2VlXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS9ibG9iL21haW4vaW5jbHVkZS9vbm54cnVudGltZS9jb3JlL3Nlc3Npb24vXG4gICAgICogb25ueHJ1bnRpbWVfc2Vzc2lvbl9vcHRpb25zX2NvbmZpZ19rZXlzLmhcbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBXZWJBc3NlbWJseSBiYWNrZW5kLiBXaWxsIHN1cHBvcnQgTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUgbGF0ZXJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBleHRyYToge1xuICAgICAqICAgc2Vzc2lvbjoge1xuICAgICAqICAgICBzZXRfZGVub3JtYWxfYXNfemVybzogXCIxXCIsXG4gICAgICogICAgIGRpc2FibGVfcHJlcGFja2luZzogXCIxXCJcbiAgICAgKiAgIH0sXG4gICAgICogICBvcHRpbWl6YXRpb246IHtcbiAgICAgKiAgICAgZW5hYmxlX2dlbHVfYXBwcm94aW1hdGlvbjogXCIxXCJcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZXh0cmE/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgfVxuXG4gIC8vICNyZWdpb24gZXhlY3V0aW9uIHByb3ZpZGVyc1xuXG4gIC8vIEN1cnJlbnRseSwgd2UgaGF2ZSB0aGUgZm9sbG93aW5nIGJhY2tlbmRzIHRvIHN1cHBvcnQgZXhlY3V0aW9uIHByb3ZpZGVyczpcbiAgLy8gQmFja2VuZCBOb2RlLmpzIGJpbmRpbmc6IHN1cHBvcnRzICdjcHUnLCAnZG1sJyAod2luMzIpLCAnY29yZW1sJyAobWFjT1MpIGFuZCAnY3VkYScgKGxpbnV4KS5cbiAgLy8gQmFja2VuZCBXZWJBc3NlbWJseTogc3VwcG9ydHMgJ2NwdScsICd3YXNtJywgJ3dlYmdwdScgYW5kICd3ZWJubicuXG4gIC8vIEJhY2tlbmQgT05OWC5qczogc3VwcG9ydHMgJ3dlYmdsJy5cbiAgLy8gQmFja2VuZCBSZWFjdCBOYXRpdmU6IHN1cHBvcnRzICdjcHUnLCAneG5ucGFjaycsICdjb3JlbWwnIChpT1MpLCAnbm5hcGknIChBbmRyb2lkKS5cbiAgaW50ZXJmYWNlIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uTWFwIHtcbiAgICBjb3JlbWw6IENvcmVNTEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIGNwdTogQ3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgY3VkYTogQ3VkYUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIGRtbDogRG1sRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgbm5hcGk6IE5uYXBpRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgdGVuc29ycnQ6IFRlbnNvclJ0RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgd2FzbTogV2ViQXNzZW1ibHlFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICB3ZWJnbDogV2ViR0xFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICB3ZWJncHU6IFdlYkdwdUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHdlYm5uOiBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHFubjogUW5uRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgeG5ucGFjazogWG5ucGFja0V4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICB9XG5cbiAgdHlwZSBFeGVjdXRpb25Qcm92aWRlck5hbWUgPSBrZXlvZiBFeGVjdXRpb25Qcm92aWRlck9wdGlvbk1hcDtcbiAgdHlwZSBFeGVjdXRpb25Qcm92aWRlckNvbmZpZyA9XG4gICAgICBFeGVjdXRpb25Qcm92aWRlck9wdGlvbk1hcFtFeGVjdXRpb25Qcm92aWRlck5hbWVdfEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9ufEV4ZWN1dGlvblByb3ZpZGVyTmFtZXxzdHJpbmc7XG5cbiAgZXhwb3J0IGludGVyZmFjZSBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ2NwdSc7XG4gICAgdXNlQXJlbmE/OiBib29sZWFuO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ3VkYUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICdjdWRhJztcbiAgICBkZXZpY2VJZD86IG51bWJlcjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIERtbEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICdkbWwnO1xuICAgIGRldmljZUlkPzogbnVtYmVyO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgVGVuc29yUnRFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAndGVuc29ycnQnO1xuICAgIGRldmljZUlkPzogbnVtYmVyO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViQXNzZW1ibHlFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnd2FzbSc7XG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJHTEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICd3ZWJnbCc7XG4gICAgLy8gVE9ETzogYWRkIGZsYWdzXG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBYbm5wYWNrRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3hubnBhY2snO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3dlYmdwdSc7XG4gICAgcHJlZmVycmVkTGF5b3V0PzogJ05DSFcnfCdOSFdDJztcbiAgfVxuXG4gIC8vICNyZWdpb24gV2ViTk4gb3B0aW9uc1xuXG4gIGludGVyZmFjZSBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyTmFtZSBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnd2Vibm4nO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBzZXQgb2Ygb3B0aW9ucyBmb3IgY3JlYXRpbmcgYSBXZWJOTiBNTENvbnRleHQuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYm5uLyNkaWN0ZGVmLW1sY29udGV4dG9wdGlvbnNcbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViTk5Db250ZXh0T3B0aW9ucyB7XG4gICAgZGV2aWNlVHlwZT86ICdjcHUnfCdncHUnfCducHUnO1xuICAgIG51bVRocmVhZHM/OiBudW1iZXI7XG4gICAgcG93ZXJQcmVmZXJlbmNlPzogJ2RlZmF1bHQnfCdsb3ctcG93ZXInfCdoaWdoLXBlcmZvcm1hbmNlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgc2V0IG9mIG9wdGlvbnMgZm9yIFdlYk5OIGV4ZWN1dGlvbiBwcm92aWRlciB3aXRob3V0IE1MQ29udGV4dC5cbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViTk5PcHRpb25zV2l0aG91dE1MQ29udGV4dCBleHRlbmRzIFdlYk5ORXhlY3V0aW9uUHJvdmlkZXJOYW1lLCBXZWJOTkNvbnRleHRPcHRpb25zIHtcbiAgICBjb250ZXh0PzogbmV2ZXI7XG4gIH1cblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHNldCBvZiBvcHRpb25zIGZvciBXZWJOTiBleGVjdXRpb24gcHJvdmlkZXIgd2l0aCBNTENvbnRleHQuXG4gICAqXG4gICAqIFdoZW4gTUxDb250ZXh0IGlzIHByb3ZpZGVkLCB0aGUgZGV2aWNlVHlwZSBpcyBhbHNvIHJlcXVpcmVkIHNvIHRoYXQgdGhlIFdlYk5OIEVQIGNhbiBkZXRlcm1pbmUgdGhlIHByZWZlcnJlZFxuICAgKiBjaGFubmVsIGxheW91dC5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvd2Vibm4vI2RvbS1tbC1jcmVhdGVjb250ZXh0XG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFdlYk5OT3B0aW9uc1dpdGhNTENvbnRleHQgZXh0ZW5kcyBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT21pdDxXZWJOTkNvbnRleHRPcHRpb25zLCAnZGV2aWNlVHlwZSc+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZXF1aXJlZDxQaWNrPFdlYk5OQ29udGV4dE9wdGlvbnMsICdkZXZpY2VUeXBlJz4+IHtcbiAgICBjb250ZXh0OiB1bmtub3duIC8qIE1MQ29udGV4dCAqLztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgc2V0IG9mIG9wdGlvbnMgZm9yIFdlYk5OIGV4ZWN1dGlvbiBwcm92aWRlciB3aXRoIE1MQ29udGV4dCB3aGljaCBpcyBjcmVhdGVkIGZyb20gR1BVRGV2aWNlLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJubi8jZG9tLW1sLWNyZWF0ZWNvbnRleHQtZ3B1ZGV2aWNlXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFdlYk5OT3B0aW9uc1dlYkdwdSBleHRlbmRzIFdlYk5ORXhlY3V0aW9uUHJvdmlkZXJOYW1lIHtcbiAgICBjb250ZXh0OiB1bmtub3duIC8qIE1MQ29udGV4dCAqLztcbiAgICBncHVEZXZpY2U6IHVua25vd24gLyogR1BVRGV2aWNlICovO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wdGlvbnMgZm9yIFdlYk5OIGV4ZWN1dGlvbiBwcm92aWRlci5cbiAgICovXG4gIGV4cG9ydCB0eXBlIFdlYk5ORXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gPSBXZWJOTk9wdGlvbnNXaXRob3V0TUxDb250ZXh0fFdlYk5OT3B0aW9uc1dpdGhNTENvbnRleHR8V2ViTk5PcHRpb25zV2ViR3B1O1xuXG4gIC8vICNlbmRyZWdpb25cblxuICBleHBvcnQgaW50ZXJmYWNlIFFubkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICdxbm4nO1xuICAgIC8vIFRPRE8gYWRkIGZsYWdzXG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBDb3JlTUxFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnY29yZW1sJztcbiAgICAvKipcbiAgICAgKiBUaGUgYml0IGZsYWdzIGZvciBDb3JlTUwgZXhlY3V0aW9uIHByb3ZpZGVyLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogQ09SRU1MX0ZMQUdfVVNFX0NQVV9PTkxZID0gMHgwMDFcbiAgICAgKiBDT1JFTUxfRkxBR19FTkFCTEVfT05fU1VCR1JBUEggPSAweDAwMlxuICAgICAqIENPUkVNTF9GTEFHX09OTFlfRU5BQkxFX0RFVklDRV9XSVRIX0FORSA9IDB4MDA0XG4gICAgICogQ09SRU1MX0ZMQUdfT05MWV9BTExPV19TVEFUSUNfSU5QVVRfU0hBUEVTID0gMHgwMDhcbiAgICAgKiBDT1JFTUxfRkxBR19DUkVBVEVfTUxQUk9HUkFNID0gMHgwMTBcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFNlZSBpbmNsdWRlL29ubnhydW50aW1lL2NvcmUvcHJvdmlkZXJzL2NvcmVtbC9jb3JlbWxfcHJvdmlkZXJfZmFjdG9yeS5oIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBUaGlzIGZsYWcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZykuXG4gICAgICovXG4gICAgY29yZU1sRmxhZ3M/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB3aGV0aGVyIHRvIHVzZSBDUFUgb25seSBpbiBDb3JlTUwgRVAuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKHJlYWN0LW5hdGl2ZSkuXG4gICAgICovXG4gICAgdXNlQ1BVT25seT86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB3aGV0aGVyIHRvIGVuYWJsZSBDb3JlTUwgRVAgb24gc3ViZ3JhcGguXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKHJlYWN0LW5hdGl2ZSkuXG4gICAgICovXG4gICAgZW5hYmxlT25TdWJncmFwaD86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB3aGV0aGVyIHRvIG9ubHkgZW5hYmxlIENvcmVNTCBFUCBmb3IgQXBwbGUgZGV2aWNlcyB3aXRoIEFORSAoQXBwbGUgTmV1cmFsIEVuZ2luZSkuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKHJlYWN0LW5hdGl2ZSkuXG4gICAgICovXG4gICAgb25seUVuYWJsZURldmljZVdpdGhBTkU/OiBib29sZWFuO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgTm5hcGlFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnbm5hcGknO1xuICAgIHVzZUZQMTY/OiBib29sZWFuO1xuICAgIHVzZU5DSFc/OiBib29sZWFuO1xuICAgIGNwdURpc2FibGVkPzogYm9vbGVhbjtcbiAgICBjcHVPbmx5PzogYm9vbGVhbjtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gcnVuIG9wdGlvbnNcblxuICAvKipcbiAgICogQSBzZXQgb2YgY29uZmlndXJhdGlvbnMgZm9yIGluZmVyZW5jZSBydW4gYmVoYXZpb3JcbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgUnVuT3B0aW9ucyB7XG4gICAgLyoqXG4gICAgICogTG9nIHNldmVyaXR5IGxldmVsLiBTZWVcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhydW50aW1lL2Jsb2IvbWFpbi9pbmNsdWRlL29ubnhydW50aW1lL2NvcmUvY29tbW9uL2xvZ2dpbmcvc2V2ZXJpdHkuaFxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGxvZ1NldmVyaXR5TGV2ZWw/OiAwfDF8MnwzfDQ7XG5cbiAgICAvKipcbiAgICAgKiBMb2cgdmVyYm9zaXR5IGxldmVsLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIFdlYkFzc2VtYmx5IGJhY2tlbmQuIFdpbGwgc3VwcG9ydCBOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSBsYXRlclxuICAgICAqL1xuICAgIGxvZ1ZlcmJvc2l0eUxldmVsPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGVybWluYXRlIGFsbCBpbmNvbXBsZXRlIE9ydFJ1biBjYWxscyBhcyBzb29uIGFzIHBvc3NpYmxlIGlmIHRydWVcbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBXZWJBc3NlbWJseSBiYWNrZW5kLiBXaWxsIHN1cHBvcnQgTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUgbGF0ZXJcbiAgICAgKi9cbiAgICB0ZXJtaW5hdGU/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogQSB0YWcgZm9yIHRoZSBSdW4oKSBjYWxscyB1c2luZyB0aGlzXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgdGFnPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogU2V0IGEgc2luZ2xlIHJ1biBjb25maWd1cmF0aW9uIGVudHJ5LiBTZWVcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhydW50aW1lL2Jsb2IvbWFpbi9pbmNsdWRlL29ubnhydW50aW1lL2NvcmUvc2Vzc2lvbi9cbiAgICAgKiBvbm54cnVudGltZV9ydW5fb3B0aW9uc19jb25maWdfa2V5cy5oXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gV2ViQXNzZW1ibHkgYmFja2VuZC4gV2lsbCBzdXBwb3J0IE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlIGxhdGVyXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBleHRyYToge1xuICAgICAqICAgbWVtb3J5OiB7XG4gICAgICogICAgIGVuYWJsZV9tZW1vcnlfYXJlbmFfc2hyaW5rYWdlOiBcIjFcIixcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZXh0cmE/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgfVxuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHZhbHVlIG1ldGFkYXRhXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1pbnRlcmZhY2VcbiAgaW50ZXJmYWNlIFZhbHVlTWV0YWRhdGEge1xuICAgIC8vIFRCRFxuICB9XG5cbiAgLy8gI2VuZHJlZ2lvblxufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIHJ1bnRpbWUgaW5zdGFuY2Ugb2YgYW4gT05OWCBtb2RlbC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbmZlcmVuY2VTZXNzaW9uIHtcbiAgLy8gI3JlZ2lvbiBydW4oKVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIHRoZSBtb2RlbCBhc3luY2hyb25vdXNseSB3aXRoIHRoZSBnaXZlbiBmZWVkcyBhbmQgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIGZlZWRzIC0gUmVwcmVzZW50YXRpb24gb2YgdGhlIG1vZGVsIGlucHV0LiBTZWUgdHlwZSBkZXNjcmlwdGlvbiBvZiBgSW5mZXJlbmNlU2Vzc2lvbi5JbnB1dFR5cGVgIGZvciBkZXRhaWwuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwuIEEgc2V0IG9mIG9wdGlvbnMgdGhhdCBjb250cm9scyB0aGUgYmVoYXZpb3Igb2YgbW9kZWwgaW5mZXJlbmNlLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIG1hcCwgd2hpY2ggdXNlcyBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgKi9cbiAgcnVuKGZlZWRzOiBJbmZlcmVuY2VTZXNzaW9uLkZlZWRzVHlwZSwgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbi5SZXR1cm5UeXBlPjtcblxuICAvKipcbiAgICogRXhlY3V0ZSB0aGUgbW9kZWwgYXN5bmNocm9ub3VzbHkgd2l0aCB0aGUgZ2l2ZW4gZmVlZHMsIGZldGNoZXMgYW5kIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBmZWVkcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBpbnB1dC4gU2VlIHR5cGUgZGVzY3JpcHRpb24gb2YgYEluZmVyZW5jZVNlc3Npb24uSW5wdXRUeXBlYCBmb3IgZGV0YWlsLlxuICAgKiBAcGFyYW0gZmV0Y2hlcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBvdXRwdXQuIFNlZSB0eXBlIGRlc2NyaXB0aW9uIG9mIGBJbmZlcmVuY2VTZXNzaW9uLk91dHB1dFR5cGVgIGZvclxuICAgKiBkZXRhaWwuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwuIEEgc2V0IG9mIG9wdGlvbnMgdGhhdCBjb250cm9scyB0aGUgYmVoYXZpb3Igb2YgbW9kZWwgaW5mZXJlbmNlLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIG1hcCwgd2hpY2ggdXNlcyBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgKi9cbiAgcnVuKGZlZWRzOiBJbmZlcmVuY2VTZXNzaW9uLkZlZWRzVHlwZSwgZmV0Y2hlczogSW5mZXJlbmNlU2Vzc2lvbi5GZXRjaGVzVHlwZSxcbiAgICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24uUmV0dXJuVHlwZT47XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gcmVsZWFzZSgpXG5cbiAgLyoqXG4gICAqIFJlbGVhc2UgdGhlIGluZmVyZW5jZSBzZXNzaW9uIGFuZCB0aGUgdW5kZXJseWluZyByZXNvdXJjZXMuXG4gICAqL1xuICByZWxlYXNlKCk6IFByb21pc2U8dm9pZD47XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gcHJvZmlsaW5nXG5cbiAgLyoqXG4gICAqIFN0YXJ0IHByb2ZpbGluZy5cbiAgICovXG4gIHN0YXJ0UHJvZmlsaW5nKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEVuZCBwcm9maWxpbmcuXG4gICAqL1xuICBlbmRQcm9maWxpbmcoKTogdm9pZDtcblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBtZXRhZGF0YVxuXG4gIC8qKlxuICAgKiBHZXQgaW5wdXQgbmFtZXMgb2YgdGhlIGxvYWRlZCBtb2RlbC5cbiAgICovXG4gIHJlYWRvbmx5IGlucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBHZXQgb3V0cHV0IG5hbWVzIG9mIHRoZSBsb2FkZWQgbW9kZWwuXG4gICAqL1xuICByZWFkb25seSBvdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG5cbiAgLy8gLyoqXG4gIC8vICAqIEdldCBpbnB1dCBtZXRhZGF0YSBvZiB0aGUgbG9hZGVkIG1vZGVsLlxuICAvLyAgKi9cbiAgLy8gcmVhZG9ubHkgaW5wdXRNZXRhZGF0YTogUmVhZG9ubHlBcnJheTxSZWFkb25seTxJbmZlcmVuY2VTZXNzaW9uLlZhbHVlTWV0YWRhdGE+PjtcblxuICAvLyAvKipcbiAgLy8gICogR2V0IG91dHB1dCBtZXRhZGF0YSBvZiB0aGUgbG9hZGVkIG1vZGVsLlxuICAvLyAgKi9cbiAgLy8gcmVhZG9ubHkgb3V0cHV0TWV0YWRhdGE6IFJlYWRvbmx5QXJyYXk8UmVhZG9ubHk8SW5mZXJlbmNlU2Vzc2lvbi5WYWx1ZU1ldGFkYXRhPj47XG5cbiAgLy8gI2VuZHJlZ2lvblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluZmVyZW5jZVNlc3Npb25GYWN0b3J5IHtcbiAgLy8gI3JlZ2lvbiBjcmVhdGUoKVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24gYW5kIGxvYWQgbW9kZWwgYXN5bmNocm9ub3VzbHkgZnJvbSBhbiBPTk5YIG1vZGVsIGZpbGUuXG4gICAqXG4gICAqIEBwYXJhbSB1cmkgLSBUaGUgVVJJIG9yIGZpbGUgcGF0aCBvZiB0aGUgbW9kZWwgdG8gbG9hZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBzcGVjaWZ5IGNvbmZpZ3VyYXRpb24gZm9yIGNyZWF0aW5nIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBJbmZlcmVuY2VTZXNzaW9uIG9iamVjdC5cbiAgICovXG4gIGNyZWF0ZSh1cmk6IHN0cmluZywgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24+O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24gYW5kIGxvYWQgbW9kZWwgYXN5bmNocm9ub3VzbHkgZnJvbSBhbiBhcnJheSBidWZlci5cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciAtIEFuIEFycmF5QnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIGFuIE9OTlggbW9kZWwuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gc3BlY2lmeSBjb25maWd1cmF0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbi5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gSW5mZXJlbmNlU2Vzc2lvbiBvYmplY3QuXG4gICAqL1xuICBjcmVhdGUoYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2UsIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uPjtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uIGFuZCBsb2FkIG1vZGVsIGFzeW5jaHJvbm91c2x5IGZyb20gc2VnbWVudCBvZiBhbiBhcnJheSBidWZlci5cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciAtIEFuIEFycmF5QnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIGFuIE9OTlggbW9kZWwuXG4gICAqIEBwYXJhbSBieXRlT2Zmc2V0IC0gVGhlIGJlZ2lubmluZyBvZiB0aGUgc3BlY2lmaWVkIHBvcnRpb24gb2YgdGhlIGFycmF5IGJ1ZmZlci5cbiAgICogQHBhcmFtIGJ5dGVMZW5ndGggLSBUaGUgbGVuZ3RoIGluIGJ5dGVzIG9mIHRoZSBhcnJheSBidWZmZXIuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gc3BlY2lmeSBjb25maWd1cmF0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbi5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gSW5mZXJlbmNlU2Vzc2lvbiBvYmplY3QuXG4gICAqL1xuICBjcmVhdGUoYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2UsIGJ5dGVPZmZzZXQ6IG51bWJlciwgYnl0ZUxlbmd0aD86IG51bWJlciwgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOlxuICAgICAgUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uPjtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uIGFuZCBsb2FkIG1vZGVsIGFzeW5jaHJvbm91c2x5IGZyb20gYSBVaW50OEFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIC0gQSBVaW50OEFycmF5IHJlcHJlc2VudGF0aW9uIG9mIGFuIE9OTlggbW9kZWwuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gc3BlY2lmeSBjb25maWd1cmF0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbi5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gSW5mZXJlbmNlU2Vzc2lvbiBvYmplY3QuXG4gICAqL1xuICBjcmVhdGUoYnVmZmVyOiBVaW50OEFycmF5LCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbj47XG5cbiAgLy8gI2VuZHJlZ2lvblxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY29uc3QgSW5mZXJlbmNlU2Vzc2lvbjogSW5mZXJlbmNlU2Vzc2lvbkZhY3RvcnkgPSBJbmZlcmVuY2VTZXNzaW9uSW1wbDtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtPcHRpb25zRm9ybWF0LCBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMsIE9wdGlvbnNUZW5zb3JMYXlvdXR9IGZyb20gJy4vdGVuc29yLWZhY3RvcnkuanMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvclRvRGF0YVVybE9wdGlvbnMgZXh0ZW5kcyBPcHRpb25zVGVuc29yTGF5b3V0LCBPcHRpb25zRm9ybWF0LCBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge31cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnMgZXh0ZW5kcyBPcHRpb25zVGVuc29yTGF5b3V0LCBPcHRpb25zRm9ybWF0LCBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge31cblxuZXhwb3J0IGludGVyZmFjZSBDb252ZXJzaW9uVXRpbHMge1xuICAvKipcbiAgICogY3JlYXRlcyBhIERhdGFVUkwgaW5zdGFuY2UgZnJvbSB0ZW5zb3JcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIGEgRGF0YVVSTCBpbnN0YW5jZSBmcm9tIHRoZSB0ZW5zb3IuXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XG4gICAqIC0gYGZvcm1hdGA6IGAnUkdCJ2BcbiAgICogLSBgdGVuc29yTGF5b3V0YDogYCdOQ0hXJ2BcbiAgICogQHJldHVybnMgYSBEYXRhVVJMIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGltYWdlIGNvbnZlcnRlZCBmcm9tIHRlbnNvciBkYXRhXG4gICAqL1xuICB0b0RhdGFVUkwob3B0aW9ucz86IFRlbnNvclRvRGF0YVVybE9wdGlvbnMpOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGNyZWF0ZXMgYW4gSW1hZ2VEYXRhIGluc3RhbmNlIGZyb20gdGVuc29yXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyBhbiBJbWFnZURhdGEgaW5zdGFuY2UgZnJvbSB0aGUgdGVuc29yLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGRlZmF1bHQgc2V0dGluZ3Mgd2lsbCBiZSBhcHBsaWVkOlxuICAgKiAtIGBmb3JtYXRgOiBgJ1JHQidgXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXG4gICAqIEByZXR1cm5zIGFuIEltYWdlRGF0YSBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhlIGltYWdlIGNvbnZlcnRlZCBmcm9tIHRlbnNvciBkYXRhXG4gICAqL1xuICB0b0ltYWdlRGF0YShvcHRpb25zPzogVGVuc29yVG9JbWFnZURhdGFPcHRpb25zKTogSW1hZ2VEYXRhO1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RlbnNvciwgVHlwZWRUZW5zb3J9IGZyb20gJy4vdGVuc29yLmpzJztcblxuZXhwb3J0IHR5cGUgSW1hZ2VGb3JtYXQgPSAnUkdCJ3wnUkdCQSd8J0JHUid8J1JCRyc7XG5leHBvcnQgdHlwZSBJbWFnZVRlbnNvckxheW91dCA9ICdOSFdDJ3wnTkNIVyc7XG5cbi8vIHRoZSBmb2xsb3dpbmcgcmVnaW9uIGNvbnRhaW5zIHR5cGUgZGVmaW5pdGlvbnMgZm9yIGNvbnN0cnVjdGluZyB0ZW5zb3IgZnJvbSBhIHNwZWNpZmljIGxvY2F0aW9uLlxuXG4vLyAjcmVnaW9uIHR5cGVzIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIHNwZWNpZmljIGxvY2F0aW9uXG5cbi8qKlxuICogcmVwcmVzZW50IGNvbW1vbiBwcm9wZXJ0aWVzIG9mIHRoZSBwYXJhbWV0ZXIgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgc3BlY2lmaWMgbG9jYXRpb24uXG4gKi9cbmludGVyZmFjZSBDb21tb25Db25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4gZXh0ZW5kcyBQaWNrPFRlbnNvciwgJ2RpbXMnPiB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBkYXRhIHR5cGUgb2YgdGhlIHRlbnNvci5cbiAgICovXG4gIHJlYWRvbmx5IHR5cGU6IFQ7XG59XG5cbi8qKlxuICogcmVwcmVzZW50IHRoZSBwYXJhbWV0ZXIgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgR1BVIHJlc291cmNlLlxuICovXG5pbnRlcmZhY2UgR3B1UmVzb3VyY2VDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VCBleHRlbmRzIFRlbnNvci5UeXBlPiB7XG4gIC8qKlxuICAgKiBhbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBkb3dubG9hZCBkYXRhIGZyb20gR1BVIHRvIENQVS5cbiAgICpcbiAgICogSWYgbm90IHByb3ZpZGVkLCB0aGUgdGVuc29yIHRyZWF0IHRoZSBHUFUgZGF0YSBhcyBleHRlcm5hbCByZXNvdXJjZS5cbiAgICovXG4gIGRvd25sb2FkPygpOiBQcm9taXNlPFRlbnNvci5EYXRhVHlwZU1hcFtUXT47XG5cbiAgLyoqXG4gICAqIGFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgdGVuc29yIGlzIGRpc3Bvc2VkLlxuICAgKlxuICAgKiBJZiBub3QgcHJvdmlkZWQsIHRoZSB0ZW5zb3IgdHJlYXQgdGhlIEdQVSBkYXRhIGFzIGV4dGVybmFsIHJlc291cmNlLlxuICAgKi9cbiAgZGlzcG9zZT8oKTogdm9pZDtcbn1cblxuLyoqXG4gKiByZXByZXNlbnQgdGhlIHBhcmFtZXRlciBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBwaW5uZWQgQ1BVIGJ1ZmZlclxuICovXG5leHBvcnQgaW50ZXJmYWNlIENwdVBpbm5lZENvbnN0cnVjdG9yUGFyYW1ldGVyczxUIGV4dGVuZHMgVGVuc29yLkNwdVBpbm5lZERhdGFUeXBlcyA9IFRlbnNvci5DcHVQaW5uZWREYXRhVHlwZXM+IGV4dGVuZHNcbiAgICBDb21tb25Db25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4ge1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEgdG8gYmUgJ2NwdS1waW5uZWQnLlxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYXRpb246ICdjcHUtcGlubmVkJztcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIENQVSBwaW5uZWQgYnVmZmVyIHRoYXQgaG9sZHMgdGhlIHRlbnNvciBkYXRhLlxuICAgKi9cbiAgcmVhZG9ubHkgZGF0YTogVGVuc29yLkRhdGFUeXBlTWFwW1RdO1xufVxuXG4vKipcbiAqIHJlcHJlc2VudCB0aGUgcGFyYW1ldGVyIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIFdlYkdMIHRleHR1cmVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZXh0dXJlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBUZW5zb3IuVGV4dHVyZURhdGFUeXBlcyA9IFRlbnNvci5UZXh0dXJlRGF0YVR5cGVzPiBleHRlbmRzXG4gICAgQ29tbW9uQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+LCBHcHVSZXNvdXJjZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBsb2NhdGlvbiBvZiB0aGUgZGF0YSB0byBiZSAndGV4dHVyZScuXG4gICAqL1xuICByZWFkb25seSBsb2NhdGlvbjogJ3RleHR1cmUnO1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgV2ViR0wgdGV4dHVyZSB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICovXG4gIHJlYWRvbmx5IHRleHR1cmU6IFRlbnNvci5UZXh0dXJlVHlwZTtcbn1cblxuLyoqXG4gKiByZXByZXNlbnQgdGhlIHBhcmFtZXRlciBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBXZWJHUFUgYnVmZmVyXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBUZW5zb3IuR3B1QnVmZmVyRGF0YVR5cGVzID0gVGVuc29yLkdwdUJ1ZmZlckRhdGFUeXBlcz4gZXh0ZW5kc1xuICAgIENvbW1vbkNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiwgR3B1UmVzb3VyY2VDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4ge1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEgdG8gYmUgJ2dwdS1idWZmZXInLlxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYXRpb246ICdncHUtYnVmZmVyJztcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIFdlYkdQVSBidWZmZXIgdGhhdCBob2xkcyB0aGUgdGVuc29yIGRhdGEuXG4gICAqL1xuICByZWFkb25seSBncHVCdWZmZXI6IFRlbnNvci5HcHVCdWZmZXJUeXBlO1xufVxuXG4vLyAjZW5kcmVnaW9uXG5cbi8vIHRoZSBmb2xsb3dpbmcgcmVnaW9uIGNvbnRhaW5zIHR5cGUgZGVmaW5pdGlvbnMgb2YgZWFjaCBpbmRpdmlkdWFsIG9wdGlvbnMuXG4vLyB0aGUgdGVuc29yIGZhY3RvcnkgZnVuY3Rpb25zIHVzZSBhIGNvbXBvc2l0aW9uIG9mIHRob3NlIG9wdGlvbnMgYXMgdGhlIHBhcmFtZXRlciB0eXBlLlxuXG4vLyAjcmVnaW9uIE9wdGlvbnMgZmllbGRzXG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uc0Zvcm1hdCB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGltYWdlIGZvcm1hdCByZXByZXNlbnRlZCBpbiBSR0JBIGNvbG9yIHNwYWNlLlxuICAgKi9cbiAgZm9ybWF0PzogSW1hZ2VGb3JtYXQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uc1RlbnNvckZvcm1hdCB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGltYWdlIGZvcm1hdCBvZiB0aGUgdGVuc29yLlxuICAgKlxuICAgKiBOT1RFOiB0aGlzIGlzIGRpZmZlcmVudCBmcm9tIG9wdGlvbiAnZm9ybWF0Jy4gV2hpbGUgb3B0aW9uICdmb3JtYXQnIHJlcHJlc2VudHMgdGhlIG9yaWdpbmFsIGltYWdlLCAndGVuc29yRm9ybWF0J1xuICAgKiByZXByZXNlbnRzIHRoZSB0YXJnZXQgZm9ybWF0IG9mIHRoZSB0ZW5zb3IuIEEgdHJhbnNwb3NlIHdpbGwgYmUgcGVyZm9ybWVkIGlmIHRoZXkgYXJlIGRpZmZlcmVudC5cbiAgICovXG4gIHRlbnNvckZvcm1hdD86IEltYWdlRm9ybWF0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNUZW5zb3JEYXRhVHlwZSB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yLlxuICAgKi9cbiAgZGF0YVR5cGU/OiAnZmxvYXQzMid8J3VpbnQ4Jztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zVGVuc29yTGF5b3V0IHtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyB0aGUgdGVuc29yIGxheW91dCB3aGVuIHJlcHJlc2VudGluZyBkYXRhIG9mIG9uZSBvciBtb3JlIGltYWdlKHMpLlxuICAgKi9cbiAgdGVuc29yTGF5b3V0PzogSW1hZ2VUZW5zb3JMYXlvdXQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uc0RpbWVuc2lvbnMge1xuICAvKipcbiAgICogRGVzY3JpYmVzIHRoZSBpbWFnZSBoZWlnaHQgaW4gcGl4ZWxcbiAgICovXG4gIGhlaWdodD86IG51bWJlcjtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyB0aGUgaW1hZ2Ugd2lkdGggaW4gcGl4ZWxcbiAgICovXG4gIHdpZHRoPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvblJlc2l6ZWREaW1lbnNpb25zIHtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyB0aGUgcmVzaXplZCBoZWlnaHQuIElmIG9taXR0ZWQsIG9yaWdpbmFsIGhlaWdodCB3aWxsIGJlIHVzZWQuXG4gICAqL1xuICByZXNpemVkSGVpZ2h0PzogbnVtYmVyO1xuICAvKipcbiAgICogRGVzY3JpYmVzIHJlc2l6ZWQgd2lkdGggLSBjYW4gYmUgYWNjZXNzZWQgdmlhIHRlbnNvciBkaW1lbnNpb25zIGFzIHdlbGxcbiAgICovXG4gIHJlc2l6ZWRXaWR0aD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge1xuICAvKipcbiAgICogRGVzY3JpYmVzIG5vcm1hbGl6YXRpb24gcGFyYW1ldGVycyB3aGVuIHByZXByb2Nlc3NpbmcgdGhlIGltYWdlIGFzIG1vZGVsIGlucHV0LlxuICAgKlxuICAgKiBEYXRhIGVsZW1lbnQgYXJlIHJhbmdlZCBmcm9tIDAgdG8gMjU1LlxuICAgKi9cbiAgbm9ybT86IHtcbiAgICAvKipcbiAgICAgKiBUaGUgJ2JpYXMnIHZhbHVlIGZvciBpbWFnZSBub3JtYWxpemF0aW9uLlxuICAgICAqIC0gSWYgb21pdHRlZCwgdXNlIGRlZmF1bHQgdmFsdWUgMC5cbiAgICAgKiAtIElmIGl0J3MgYSBzaW5nbGUgbnVtYmVyLCBhcHBseSB0byBlYWNoIGNoYW5uZWxcbiAgICAgKiAtIElmIGl0J3MgYW4gYXJyYXkgb2YgMyBvciA0IG51bWJlcnMsIGFwcGx5IGVsZW1lbnQtd2lzZS4gTnVtYmVyIG9mIGVsZW1lbnRzIG5lZWQgdG8gbWF0Y2ggdGhlIG51bWJlciBvZiBjaGFubmVsc1xuICAgICAqIGZvciB0aGUgY29ycmVzcG9uZGluZyBpbWFnZSBmb3JtYXRcbiAgICAgKi9cbiAgICBiaWFzPzogbnVtYmVyfFtudW1iZXIsIG51bWJlciwgbnVtYmVyXXxbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgICAvKipcbiAgICAgKiBUaGUgJ21lYW4nIHZhbHVlIGZvciBpbWFnZSBub3JtYWxpemF0aW9uLlxuICAgICAqIC0gSWYgb21pdHRlZCwgdXNlIGRlZmF1bHQgdmFsdWUgMjU1LlxuICAgICAqIC0gSWYgaXQncyBhIHNpbmdsZSBudW1iZXIsIGFwcGx5IHRvIGVhY2ggY2hhbm5lbFxuICAgICAqIC0gSWYgaXQncyBhbiBhcnJheSBvZiAzIG9yIDQgbnVtYmVycywgYXBwbHkgZWxlbWVudC13aXNlLiBOdW1iZXIgb2YgZWxlbWVudHMgbmVlZCB0byBtYXRjaCB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzXG4gICAgICogZm9yIHRoZSBjb3JyZXNwb25kaW5nIGltYWdlIGZvcm1hdFxuICAgICAqL1xuICAgIG1lYW4/OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgfTtcbn1cblxuLy8gI2VuZHJlZ2lvblxuXG4vLyAjcmVnaW9uIE9wdGlvbnMgY29tcG9zaXRpb25cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tSW1hZ2VEYXRhT3B0aW9ucyBleHRlbmRzIE9wdGlvblJlc2l6ZWREaW1lbnNpb25zLCBPcHRpb25zVGVuc29yRm9ybWF0LCBPcHRpb25zVGVuc29yTGF5b3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnNUZW5zb3JEYXRhVHlwZSwgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbUltYWdlRWxlbWVudE9wdGlvbnMgZXh0ZW5kcyBPcHRpb25SZXNpemVkRGltZW5zaW9ucywgT3B0aW9uc1RlbnNvckZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcHRpb25zVGVuc29yTGF5b3V0LCBPcHRpb25zVGVuc29yRGF0YVR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbVVybE9wdGlvbnMgZXh0ZW5kcyBPcHRpb25zRGltZW5zaW9ucywgT3B0aW9uUmVzaXplZERpbWVuc2lvbnMsIE9wdGlvbnNUZW5zb3JGb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3B0aW9uc1RlbnNvckxheW91dCwgT3B0aW9uc1RlbnNvckRhdGFUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZyb21JbWFnZUJpdG1hcE9wdGlvbnMgZXh0ZW5kcyBPcHRpb25SZXNpemVkRGltZW5zaW9ucywgT3B0aW9uc1RlbnNvckZvcm1hdCwgT3B0aW9uc1RlbnNvckxheW91dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9wdGlvbnNUZW5zb3JEYXRhVHlwZSwgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbVRleHR1cmVPcHRpb25zPFQgZXh0ZW5kcyBUZW5zb3IuVGV4dHVyZURhdGFUeXBlcz4gZXh0ZW5kc1xuICAgIFJlcXVpcmVkPE9wdGlvbnNEaW1lbnNpb25zPiwgT3B0aW9uc0Zvcm1hdCwgR3B1UmVzb3VyY2VDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4vKiBUT0RPOiBhZGQgbW9yZSAqLyB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZyb21HcHVCdWZmZXJPcHRpb25zPFQgZXh0ZW5kcyBUZW5zb3IuR3B1QnVmZmVyRGF0YVR5cGVzPiBleHRlbmRzXG4gICAgUGljazxUZW5zb3IsICdkaW1zJz4sIEdwdVJlc291cmNlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IHtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuXG4gICAqL1xuICBkYXRhVHlwZT86IFQ7XG59XG5cbi8vICNlbmRyZWdpb25cblxuLyoqXG4gKiB0eXBlIFRlbnNvckZhY3RvcnkgZGVmaW5lcyB0aGUgZmFjdG9yeSBmdW5jdGlvbnMgb2YgJ1RlbnNvcicgdG8gY3JlYXRlIHRlbnNvciBpbnN0YW5jZXMgZnJvbSBleGlzdGluZyBkYXRhIG9yXG4gKiByZXNvdXJjZXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRmFjdG9yeSB7XG4gIC8qKlxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhbiBJbWFnZURhdGEgb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSBpbWFnZURhdGEgLSB0aGUgSW1hZ2VEYXRhIG9iamVjdCB0byBjcmVhdGUgdGVuc29yIGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIEltYWdlRGF0YS5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBkZWZhdWx0IHNldHRpbmdzIHdpbGwgYmUgYXBwbGllZDpcbiAgICogLSBgdGVuc29yRm9ybWF0YDogYCdSR0InYFxuICAgKiAtIGB0ZW5zb3JMYXlvdXRgOiBgJ05DSFcnYFxuICAgKiAtIGBkYXRhVHlwZWA6IGAnZmxvYXQzMidgXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdGVuc29yIG9iamVjdFxuICAgKi9cbiAgZnJvbUltYWdlKGltYWdlRGF0YTogSW1hZ2VEYXRhLCBvcHRpb25zPzogVGVuc29yRnJvbUltYWdlRGF0YU9wdGlvbnMpOlxuICAgICAgUHJvbWlzZTxUeXBlZFRlbnNvcjwnZmxvYXQzMic+fFR5cGVkVGVuc29yPCd1aW50OCc+PjtcblxuICAvKipcbiAgICogY3JlYXRlIGEgdGVuc29yIGZyb20gYSBIVE1MSW1hZ2VFbGVtZW50IG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0gaW1hZ2VFbGVtZW50IC0gdGhlIEhUTUxJbWFnZUVsZW1lbnQgb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gSFRNTEltYWdlRWxlbWVudC5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBkZWZhdWx0IHNldHRpbmdzIHdpbGwgYmUgYXBwbGllZDpcbiAgICogLSBgdGVuc29yRm9ybWF0YDogYCdSR0InYFxuICAgKiAtIGB0ZW5zb3JMYXlvdXRgOiBgJ05DSFcnYFxuICAgKiAtIGBkYXRhVHlwZWA6IGAnZmxvYXQzMidgXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdGVuc29yIG9iamVjdFxuICAgKi9cbiAgZnJvbUltYWdlKGltYWdlRWxlbWVudDogSFRNTEltYWdlRWxlbWVudCwgb3B0aW9ucz86IFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zKTpcbiAgICAgIFByb21pc2U8VHlwZWRUZW5zb3I8J2Zsb2F0MzInPnxUeXBlZFRlbnNvcjwndWludDgnPj47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIFVSTFxuICAgKlxuICAgKiBAcGFyYW0gdXJsU291cmNlIC0gYSBzdHJpbmcgYXMgYSBVUkwgdG8gdGhlIGltYWdlIG9yIGEgZGF0YSBVUkwgY29udGFpbmluZyB0aGUgaW1hZ2UgZGF0YS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRlbnNvciBmcm9tIFVSTC5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBkZWZhdWx0IHNldHRpbmdzIHdpbGwgYmUgYXBwbGllZDpcbiAgICogLSBgdGVuc29yRm9ybWF0YDogYCdSR0InYFxuICAgKiAtIGB0ZW5zb3JMYXlvdXRgOiBgJ05DSFcnYFxuICAgKiAtIGBkYXRhVHlwZWA6IGAnZmxvYXQzMidgXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdGVuc29yIG9iamVjdFxuICAgKi9cbiAgZnJvbUltYWdlKHVybFNvdXJjZTogc3RyaW5nLCBvcHRpb25zPzogVGVuc29yRnJvbVVybE9wdGlvbnMpOiBQcm9taXNlPFR5cGVkVGVuc29yPCdmbG9hdDMyJz58VHlwZWRUZW5zb3I8J3VpbnQ4Jz4+O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhbiBJbWFnZUJpdG1hcCBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIGJpdG1hcCAtIHRoZSBJbWFnZUJpdG1hcCBvYmplY3QgdG8gY3JlYXRlIHRlbnNvciBmcm9tXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyB0ZW5zb3IgZnJvbSBVUkwuXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XG4gICAqIC0gYHRlbnNvckZvcm1hdGA6IGAnUkdCJ2BcbiAgICogLSBgdGVuc29yTGF5b3V0YDogYCdOQ0hXJ2BcbiAgICogLSBgZGF0YVR5cGVgOiBgJ2Zsb2F0MzInYFxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHRlbnNvciBvYmplY3RcbiAgICovXG4gIGZyb21JbWFnZShiaXRtYXA6IEltYWdlQml0bWFwLCBvcHRpb25zOiBUZW5zb3JGcm9tSW1hZ2VCaXRtYXBPcHRpb25zKTpcbiAgICAgIFByb21pc2U8VHlwZWRUZW5zb3I8J2Zsb2F0MzInPnxUeXBlZFRlbnNvcjwndWludDgnPj47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIGEgV2ViR0wgdGV4dHVyZVxuICAgKlxuICAgKiBAcGFyYW0gdGV4dHVyZSAtIHRoZSBXZWJHTFRleHR1cmUgb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gV2ViR0wgdGV4dHVyZS5cbiAgICpcbiAgICogVGhlIG9wdGlvbnMgaW5jbHVkZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogLSBgd2lkdGhgOiB0aGUgd2lkdGggb2YgdGhlIHRleHR1cmUuIFJlcXVpcmVkLlxuICAgKiAtIGBoZWlnaHRgOiB0aGUgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlLiBSZXF1aXJlZC5cbiAgICogLSBgZm9ybWF0YDogdGhlIGZvcm1hdCBvZiB0aGUgdGV4dHVyZS4gSWYgb21pdHRlZCwgYXNzdW1lICdSR0JBJy5cbiAgICogLSBgZG93bmxvYWRgOiBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBkb3dubG9hZCB0aGUgdGVuc29yIGRhdGEgZnJvbSBHUFUgdG8gQ1BVLiBJZiBvbWl0dGVkLCB0aGUgR1BVIGRhdGFcbiAgICogd2lsbCBub3QgYmUgYWJsZSB0byBkb3dubG9hZC4gVXN1YWxseSwgdGhpcyBpcyBwcm92aWRlZCBieSBhIEdQVSBiYWNrZW5kIGZvciB0aGUgaW5mZXJlbmNlIG91dHB1dHMuIFVzZXJzIGRvbid0XG4gICAqIG5lZWQgdG8gcHJvdmlkZSB0aGlzIGZ1bmN0aW9uLlxuICAgKiAtIGBkaXNwb3NlYDogYW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZGlzcG9zZSB0aGUgdGVuc29yIGRhdGEgb24gR1BVLiBJZiBvbWl0dGVkLCB0aGUgR1BVIGRhdGEgd2lsbCBub3QgYmUgZGlzcG9zZWQuXG4gICAqIFVzdWFsbHksIHRoaXMgaXMgcHJvdmlkZWQgYnkgYSBHUFUgYmFja2VuZCBmb3IgdGhlIGluZmVyZW5jZSBvdXRwdXRzLiBVc2VycyBkb24ndCBuZWVkIHRvIHByb3ZpZGUgdGhpcyBmdW5jdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMgYSB0ZW5zb3Igb2JqZWN0XG4gICAqL1xuICBmcm9tVGV4dHVyZTxUIGV4dGVuZHMgVGVuc29yLlRleHR1cmVEYXRhVHlwZXMgPSAnZmxvYXQzMic+KFxuICAgICAgdGV4dHVyZTogVGVuc29yLlRleHR1cmVUeXBlLCBvcHRpb25zOiBUZW5zb3JGcm9tVGV4dHVyZU9wdGlvbnM8VD4pOiBUeXBlZFRlbnNvcjwnZmxvYXQzMic+O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSB0ZW5zb3IgZnJvbSBhIFdlYkdQVSBidWZmZXJcbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciAtIHRoZSBHUFVCdWZmZXIgb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gV2ViR1BVIGJ1ZmZlci5cbiAgICpcbiAgICogVGhlIG9wdGlvbnMgaW5jbHVkZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogLSBgZGF0YVR5cGVgOiB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGFzc3VtZSAnZmxvYXQzMicuXG4gICAqIC0gYGRpbXNgOiB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIFJlcXVpcmVkLlxuICAgKiAtIGBkb3dubG9hZGA6IGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGRvd25sb2FkIHRoZSB0ZW5zb3IgZGF0YSBmcm9tIEdQVSB0byBDUFUuIElmIG9taXR0ZWQsIHRoZSBHUFUgZGF0YVxuICAgKiB3aWxsIG5vdCBiZSBhYmxlIHRvIGRvd25sb2FkLiBVc3VhbGx5LCB0aGlzIGlzIHByb3ZpZGVkIGJ5IGEgR1BVIGJhY2tlbmQgZm9yIHRoZSBpbmZlcmVuY2Ugb3V0cHV0cy4gVXNlcnMgZG9uJ3RcbiAgICogbmVlZCB0byBwcm92aWRlIHRoaXMgZnVuY3Rpb24uXG4gICAqIC0gYGRpc3Bvc2VgOiBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBkaXNwb3NlIHRoZSB0ZW5zb3IgZGF0YSBvbiBHUFUuIElmIG9taXR0ZWQsIHRoZSBHUFUgZGF0YSB3aWxsIG5vdCBiZSBkaXNwb3NlZC5cbiAgICogVXN1YWxseSwgdGhpcyBpcyBwcm92aWRlZCBieSBhIEdQVSBiYWNrZW5kIGZvciB0aGUgaW5mZXJlbmNlIG91dHB1dHMuIFVzZXJzIGRvbid0IG5lZWQgdG8gcHJvdmlkZSB0aGlzIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHRlbnNvciBvYmplY3RcbiAgICovXG4gIGZyb21HcHVCdWZmZXI8VCBleHRlbmRzIFRlbnNvci5HcHVCdWZmZXJEYXRhVHlwZXM+KFxuICAgICAgYnVmZmVyOiBUZW5zb3IuR3B1QnVmZmVyVHlwZSwgb3B0aW9uczogVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnM8VD4pOiBUeXBlZFRlbnNvcjxUPjtcblxuICAvKipcbiAgICogY3JlYXRlIGEgdGVuc29yIGZyb20gYSBwcmUtYWxsb2NhdGVkIGJ1ZmZlci4gVGhlIGJ1ZmZlciB3aWxsIGJlIHVzZWQgYXMgYSBwaW5uZWQgYnVmZmVyLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIHRoZSB0ZW5zb3IgZWxlbWVudCB0eXBlLlxuICAgKiBAcGFyYW0gYnVmZmVyIC0gYSBUeXBlZEFycmF5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHR5cGUuXG4gICAqIEBwYXJhbSBkaW1zIC0gc3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHRlbnNvciBvYmplY3RcbiAgICovXG4gIGZyb21QaW5uZWRCdWZmZXI8VCBleHRlbmRzIEV4Y2x1ZGU8VGVuc29yLlR5cGUsICdzdHJpbmcnPj4oXG4gICAgICB0eXBlOiBULCBidWZmZXI6IFRlbnNvci5EYXRhVHlwZU1hcFtUXSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8VD47XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8qKlxuICogQSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgZmlsZSdzIFVSTCBvciBwYXRoLlxuICpcbiAqIFBhdGggaXMgdmFpbGFibGUgb25seSBpbiBvbm54cnVudGltZS1ub2RlIG9yIG9ubnhydW50aW1lLXdlYiBydW5uaW5nIGluIE5vZGUuanMuXG4gKi9cbmV4cG9ydCB0eXBlIEZpbGVVcmxPclBhdGggPSBzdHJpbmc7XG5cbi8qKlxuICogQSBCbG9iIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYSBmaWxlLlxuICovXG5leHBvcnQgdHlwZSBGaWxlQmxvYiA9IEJsb2I7XG5cbi8qKlxuICogQSBVaW50OEFycmF5LCBBcnJheUJ1ZmZlciBvciBTaGFyZWRBcnJheUJ1ZmZlciBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgZmlsZSBjb250ZW50LlxuICpcbiAqIFdoZW4gaXQgaXMgYW4gQXJyYXlCdWZmZXIgb3IgU2hhcmVkQXJyYXlCdWZmZXIsIHRoZSB3aG9sZSBidWZmZXIgaXMgYXNzdW1lZCB0byBiZSB0aGUgZmlsZSBjb250ZW50LlxuICovXG5leHBvcnQgdHlwZSBGaWxlRGF0YSA9IFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJMaWtlO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBmaWxlIHRoYXQgY2FuIGJlIGxvYWRlZCBieSB0aGUgT05OWCBSdW50aW1lIEphdmFTY3JpcHQgQVBJLlxuICovXG5leHBvcnQgdHlwZSBGaWxlVHlwZSA9IEZpbGVVcmxPclBhdGh8RmlsZUJsb2J8RmlsZURhdGE7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBleHRlcm5hbCBkYXRhIGZpbGUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXh0ZXJuYWxEYXRhRmlsZURlc2NyaXB0aW9uIHtcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGV4dGVybmFsIGRhdGEgZmlsZS5cbiAgICovXG4gIGRhdGE6IEZpbGVUeXBlO1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgZmlsZSBwYXRoLlxuICAgKi9cbiAgcGF0aDogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZXh0ZXJuYWwgZGF0YSBmaWxlLlxuICpcbiAqIFdoZW4gdXNpbmcgYSBzdHJpbmcsIGl0IHNob3VsZCBiZSBhIGZpbGUgVVJMIG9yIHBhdGggdGhhdCBpbiB0aGUgc2FtZSBkaXJlY3RvcnkgYXMgdGhlIG1vZGVsIGZpbGUuXG4gKi9cbmV4cG9ydCB0eXBlIEV4dGVybmFsRGF0YUZpbGVUeXBlID0gRXh0ZXJuYWxEYXRhRmlsZURlc2NyaXB0aW9ufEZpbGVVcmxPclBhdGg7XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgbW9kZWwgbG9hZGluZy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBPbm54TW9kZWxPcHRpb25zIHtcbiAgLyoqXG4gICAqIFNwZWNpZnlpbmcgYSBsaXN0IG9mIGZpbGVzIHRoYXQgcmVwcmVzZW50cyB0aGUgZXh0ZXJuYWwgZGF0YS5cbiAgICovXG4gIGV4dGVybmFsRGF0YT86IHJlYWRvbmx5IEV4dGVybmFsRGF0YUZpbGVUeXBlW107XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICcuL3RlbnNvci5qcyc7XG5cbmV4cG9ydCB0eXBlIE5vblRlbnNvclR5cGUgPSBuZXZlcjtcblxuLyoqXG4gKiBUeXBlIE9ubnhWYWx1ZSBSZXByZXNlbnRzIGJvdGggdGVuc29ycyBhbmQgbm9uLXRlbnNvcnMgdmFsdWUgZm9yIG1vZGVsJ3MgaW5wdXRzL291dHB1dHMuXG4gKlxuICogTk9URTogY3VycmVudGx5IG5vdCBzdXBwb3J0IG5vbi10ZW5zb3JcbiAqL1xuZXhwb3J0IHR5cGUgT25ueFZhbHVlID0gVGVuc29yfE5vblRlbnNvclR5cGU7XG5cbi8qKlxuICogVHlwZSBPbm54VmFsdWVEYXRhTG9jYXRpb24gcmVwcmVzZW50cyB0aGUgbG9jYXRpb24gb2YgdGhlIGRhdGEgb2YgYW4gT25ueFZhbHVlLlxuICovXG5leHBvcnQgdHlwZSBPbm54VmFsdWVEYXRhTG9jYXRpb24gPSBUZW5zb3IuRGF0YUxvY2F0aW9uO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge3Jlc29sdmVCYWNrZW5kQW5kRXhlY3V0aW9uUHJvdmlkZXJzfSBmcm9tICcuL2JhY2tlbmQtaW1wbC5qcyc7XG5pbXBvcnQge1Nlc3Npb25IYW5kbGVyLCBUcmFpbmluZ1Nlc3Npb25IYW5kbGVyfSBmcm9tICcuL2JhY2tlbmQuanMnO1xuaW1wb3J0IHtJbmZlcmVuY2VTZXNzaW9uIGFzIEluZmVyZW5jZVNlc3Npb259IGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24uanMnO1xuaW1wb3J0IHtPbm54VmFsdWV9IGZyb20gJy4vb25ueC12YWx1ZS5qcyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi90ZW5zb3IuanMnO1xuaW1wb3J0IHtUcmFpbmluZ1Nlc3Npb24gYXMgVHJhaW5pbmdTZXNzaW9uSW50ZXJmYWNlLCBUcmFpbmluZ1Nlc3Npb25DcmVhdGVPcHRpb25zfSBmcm9tICcuL3RyYWluaW5nLXNlc3Npb24uanMnO1xuXG50eXBlIFNlc3Npb25PcHRpb25zID0gSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucztcbnR5cGUgRmVlZHNUeXBlID0gSW5mZXJlbmNlU2Vzc2lvbi5GZWVkc1R5cGU7XG50eXBlIEZldGNoZXNUeXBlID0gSW5mZXJlbmNlU2Vzc2lvbi5GZXRjaGVzVHlwZTtcbnR5cGUgUmV0dXJuVHlwZSA9IEluZmVyZW5jZVNlc3Npb24uUmV0dXJuVHlwZTtcbnR5cGUgUnVuT3B0aW9ucyA9IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucztcblxuY29uc3Qgbm9CYWNrZW5kRXJyTXNnOiBzdHJpbmcgPSAnVHJhaW5pbmcgYmFja2VuZCBjb3VsZCBub3QgYmUgcmVzb2x2ZWQuICcgK1xuICAgICdNYWtlIHN1cmUgeW91XFwncmUgdXNpbmcgdGhlIGNvcnJlY3QgY29uZmlndXJhdGlvbiAmIFdlYkFzc2VtYmx5IGZpbGVzLic7XG5cbmV4cG9ydCBjbGFzcyBUcmFpbmluZ1Nlc3Npb24gaW1wbGVtZW50cyBUcmFpbmluZ1Nlc3Npb25JbnRlcmZhY2Uge1xuICBwcml2YXRlIGNvbnN0cnVjdG9yKGhhbmRsZXI6IFRyYWluaW5nU2Vzc2lvbkhhbmRsZXIsIGhhc09wdGltaXplck1vZGVsOiBib29sZWFuLCBoYXNFdmFsTW9kZWw6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIHRoaXMuaGFzT3B0aW1pemVyTW9kZWwgPSBoYXNPcHRpbWl6ZXJNb2RlbDtcbiAgICB0aGlzLmhhc0V2YWxNb2RlbCA9IGhhc0V2YWxNb2RlbDtcbiAgfVxuICBwcml2YXRlIGhhbmRsZXI6IFRyYWluaW5nU2Vzc2lvbkhhbmRsZXI7XG4gIHByaXZhdGUgaGFzT3B0aW1pemVyTW9kZWw6IGJvb2xlYW47XG4gIHByaXZhdGUgaGFzRXZhbE1vZGVsOiBib29sZWFuO1xuXG4gIGdldCB0cmFpbmluZ0lucHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuaW5wdXROYW1lcztcbiAgfVxuICBnZXQgdHJhaW5pbmdPdXRwdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vdXRwdXROYW1lcztcbiAgfVxuXG4gIGdldCBldmFsSW5wdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgaWYgKHRoaXMuaGFzRXZhbE1vZGVsKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmV2YWxJbnB1dE5hbWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdHJhaW5pbmcgc2Vzc2lvbiBoYXMgbm8gZXZhbE1vZGVsIGxvYWRlZC4nKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGV2YWxPdXRwdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgaWYgKHRoaXMuaGFzRXZhbE1vZGVsKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmV2YWxPdXRwdXROYW1lcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHRyYWluaW5nIHNlc3Npb24gaGFzIG5vIGV2YWxNb2RlbCBsb2FkZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZSh0cmFpbmluZ09wdGlvbnM6IFRyYWluaW5nU2Vzc2lvbkNyZWF0ZU9wdGlvbnMsIHNlc3Npb25PcHRpb25zPzogU2Vzc2lvbk9wdGlvbnMpOlxuICAgICAgUHJvbWlzZTxUcmFpbmluZ1Nlc3Npb24+IHtcbiAgICBjb25zdCBldmFsTW9kZWw6IHN0cmluZ3xVaW50OEFycmF5ID0gdHJhaW5pbmdPcHRpb25zLmV2YWxNb2RlbCB8fCAnJztcbiAgICBjb25zdCBvcHRpbWl6ZXJNb2RlbDogc3RyaW5nfFVpbnQ4QXJyYXkgPSB0cmFpbmluZ09wdGlvbnMub3B0aW1pemVyTW9kZWwgfHwgJyc7XG4gICAgY29uc3Qgb3B0aW9uczogU2Vzc2lvbk9wdGlvbnMgPSBzZXNzaW9uT3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIHJlc29sdmUgYmFja2VuZCwgdXBkYXRlIHNlc3Npb24gb3B0aW9ucyB3aXRoIHZhbGlkYXRlZCBFUHMsIGFuZCBjcmVhdGUgc2Vzc2lvbiBoYW5kbGVyXG4gICAgY29uc3QgW2JhY2tlbmQsIG9wdGlvbnNXaXRoVmFsaWRhdGVkRVBzXSA9IGF3YWl0IHJlc29sdmVCYWNrZW5kQW5kRXhlY3V0aW9uUHJvdmlkZXJzKG9wdGlvbnMpO1xuICAgIGlmIChiYWNrZW5kLmNyZWF0ZVRyYWluaW5nU2Vzc2lvbkhhbmRsZXIpIHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBhd2FpdCBiYWNrZW5kLmNyZWF0ZVRyYWluaW5nU2Vzc2lvbkhhbmRsZXIoXG4gICAgICAgICAgdHJhaW5pbmdPcHRpb25zLmNoZWNrcG9pbnRTdGF0ZSwgdHJhaW5pbmdPcHRpb25zLnRyYWluTW9kZWwsIGV2YWxNb2RlbCwgb3B0aW1pemVyTW9kZWwsXG4gICAgICAgICAgb3B0aW9uc1dpdGhWYWxpZGF0ZWRFUHMpO1xuICAgICAgcmV0dXJuIG5ldyBUcmFpbmluZ1Nlc3Npb24oaGFuZGxlciwgISF0cmFpbmluZ09wdGlvbnMub3B0aW1pemVyTW9kZWwsICEhdHJhaW5pbmdPcHRpb25zLmV2YWxNb2RlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihub0JhY2tlbmRFcnJNc2cpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIHJ1blRyYWluU3RlcCBhbmQgZnV0dXJlIHJ1blN0ZXAgbWV0aG9kcyB0aGF0IGhhbmRsZXMgdGhlIHR5cGUtbmFycm93aW5nIGNvbnZlcnNpb24gZnJvbVxuICAgKiB0aGUgZ2l2ZW4gcGFyYW1ldGVycyB0byBTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSBhbmQgUnVuT3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0TmFtZXMgdGhlIGZlZWRzIG9iamVjdCBpcyBjaGVja2VkIHRoYXQgdGhleSBjb250YWluIGFsbCBpbnB1dCBuYW1lcyBpbiB0aGUgcHJvdmlkZWQgbGlzdCBvZiBpbnB1dFxuICAgKiBuYW1lcy5cbiAgICogQHBhcmFtIG91dHB1dE5hbWVzIHRoZSBmZXRjaGVzIG9iamVjdCBpcyBjaGVja2VkIHRoYXQgdGhlaXIga2V5cyBtYXRjaCB1cCB3aXRoIHZhbGlkIG5hbWVzIGluIHRoZSBsaXN0IG9mIG91dHB1dFxuICAgKiBuYW1lcy5cbiAgICogQHBhcmFtIGZlZWRzIHRoZSByZXF1aXJlZCBpbnB1dFxuICAgKiBAcGFyYW0gYXJnMSBuYXJyb3dlZCAmIGNvbnZlcnRlZCBpbnRvIHRoZSBTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSBvciBSdW5PcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0gYXJnMiBvcHRpb25hbCBSdW5PcHRpb25zIG9iamVjdC5cbiAgICogQHJldHVybnNcbiAgICovXG4gIHR5cGVOYXJyb3dpbmdGb3JSdW5TdGVwKFxuICAgICAgaW5wdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW10sIG91dHB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXSwgZmVlZHM6IEZlZWRzVHlwZSwgYXJnMT86IEZldGNoZXNUeXBlfFJ1bk9wdGlvbnMsXG4gICAgICBhcmcyPzogUnVuT3B0aW9ucyk6IFtTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSwgUnVuT3B0aW9uc10ge1xuICAgIGNvbnN0IGZldGNoZXM6IHtbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlfG51bGx9ID0ge307XG4gICAgbGV0IG9wdGlvbnM6IFJ1bk9wdGlvbnMgPSB7fTtcbiAgICAvLyBjaGVjayBpbnB1dHNcbiAgICBpZiAodHlwZW9mIGZlZWRzICE9PSAnb2JqZWN0JyB8fCBmZWVkcyA9PT0gbnVsbCB8fCBmZWVkcyBpbnN0YW5jZW9mIFRlbnNvciB8fCBBcnJheS5pc0FycmF5KGZlZWRzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnXFwnZmVlZHNcXCcgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCB1c2UgaW5wdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLicpO1xuICAgIH1cblxuICAgIGxldCBpc0ZldGNoZXNFbXB0eSA9IHRydWU7XG4gICAgLy8gZGV0ZXJtaW5lIHdoaWNoIG92ZXJyaWRlIGlzIGJlaW5nIHVzZWRcbiAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoYXJnMSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBjYW5ub3QgYmUgbnVsbC4nKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmcxIGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ2ZldGNoZXNcXCcgY2Fubm90IGJlIGEgVGVuc29yJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgIGlmIChhcmcxLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ2ZldGNoZXNcXCcgY2Fubm90IGJlIGFuIGVtcHR5IGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgIC8vIG91dHB1dCBuYW1lc1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgYXJnMSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ2ZldGNoZXNcXCcgbXVzdCBiZSBhIHN0cmluZyBhcnJheSBvciBhbiBvYmplY3QuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvdXRwdXROYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdmZXRjaGVzJyBjb250YWlucyBpbnZhbGlkIG91dHB1dCBuYW1lOiAke25hbWV9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmZXRjaGVzW25hbWVdID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ29iamVjdCcgJiYgYXJnMiAhPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcJ29wdGlvbnNcXCcgbXVzdCBiZSBhbiBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlY2lkZSB3aGV0aGVyIGFyZzEgaXMgZmV0Y2hlcyBvciBvcHRpb25zXG4gICAgICAgIC8vIGlmIGFueSBvdXRwdXQgbmFtZSBpcyBwcmVzZW50IGFuZCBpdHMgdmFsdWUgaXMgdmFsaWQgT25ueFZhbHVlLCB3ZSBjb25zaWRlciBpdCBmZXRjaGVzXG4gICAgICAgIGxldCBpc0ZldGNoZXMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgYXJnMUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcmcxKTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIG91dHB1dE5hbWVzKSB7XG4gICAgICAgICAgaWYgKGFyZzFLZXlzLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gKGFyZzEgYXMgSW5mZXJlbmNlU2Vzc2lvbi5OdWxsYWJsZU9ubnhWYWx1ZU1hcFR5cGUpW25hbWVdO1xuICAgICAgICAgICAgaWYgKHYgPT09IG51bGwgfHwgdiBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICAgICAgICBpc0ZldGNoZXMgPSB0cnVlO1xuICAgICAgICAgICAgICBpc0ZldGNoZXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICBmZXRjaGVzW25hbWVdID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNGZXRjaGVzKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBhcmcyID09PSAnb2JqZWN0JyAmJiBhcmcyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gYXJnMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFwnb3B0aW9uc1xcJyBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucyA9IGFyZzEgYXMgUnVuT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBtdXN0IGJlIFxcJ2ZldGNoZXNcXCcgb3IgXFwnb3B0aW9uc1xcJy4nKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBhbGwgaW5wdXRzIGFyZSBpbiBmZWVkXG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGlucHV0TmFtZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgZmVlZHNbbmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5wdXQgJyR7bmFtZX0nIGlzIG1pc3NpbmcgaW4gJ2ZlZWRzJy5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBubyBmZXRjaGVzIGlzIHNwZWNpZmllZCwgd2UgdXNlIHRoZSBmdWxsIG91dHB1dCBuYW1lcyBsaXN0XG4gICAgaWYgKGlzRmV0Y2hlc0VtcHR5KSB7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygb3V0cHV0TmFtZXMpIHtcbiAgICAgICAgZmV0Y2hlc1tuYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtmZXRjaGVzLCBvcHRpb25zXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgbWV0aG9kIGZvciBydW5UcmFpblN0ZXAgYW5kIGFueSBvdGhlciBydW5TdGVwIG1ldGhvZHMuIFRha2VzIHRoZSBSZXR1cm5UeXBlIHJlc3VsdCBmcm9tIHRoZSBTZXNzaW9uSGFuZGxlclxuICAgKiBhbmQgY2hhbmdlcyBpdCBpbnRvIGEgbWFwIG9mIFRlbnNvcnMuXG4gICAqXG4gICAqIEBwYXJhbSByZXN1bHRzXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBjb252ZXJ0SGFuZGxlclJldHVyblR5cGVUb01hcE9mVGVuc29ycyhyZXN1bHRzOiBTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlKTogUmV0dXJuVHlwZSB7XG4gICAgY29uc3QgcmV0dXJuVmFsdWU6IHtbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlfSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdHMpIHtcbiAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHRzLCBrZXkpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdHNba2V5XTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICAgIHJldHVyblZhbHVlW2tleV0gPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuVmFsdWVba2V5XSA9IG5ldyBUZW5zb3IocmVzdWx0LnR5cGUsIHJlc3VsdC5kYXRhLCByZXN1bHQuZGltcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9XG5cbiAgYXN5bmMgbGF6eVJlc2V0R3JhZCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLmhhbmRsZXIubGF6eVJlc2V0R3JhZCgpO1xuICB9XG5cbiAgcnVuVHJhaW5TdGVwKGZlZWRzOiBGZWVkc1R5cGUsIG9wdGlvbnM/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPjtcbiAgcnVuVHJhaW5TdGVwKGZlZWRzOiBGZWVkc1R5cGUsIGZldGNoZXM6IEZldGNoZXNUeXBlLCBvcHRpb25zPzogUnVuT3B0aW9ucyk6IFByb21pc2U8UmV0dXJuVHlwZT47XG4gIGFzeW5jIHJ1blRyYWluU3RlcChmZWVkczogRmVlZHNUeXBlLCBhcmcxPzogRmV0Y2hlc1R5cGV8UnVuT3B0aW9ucywgYXJnMj86IFJ1bk9wdGlvbnMpOiBQcm9taXNlPFJldHVyblR5cGU+IHtcbiAgICBjb25zdCBbZmV0Y2hlcywgb3B0aW9uc10gPVxuICAgICAgICB0aGlzLnR5cGVOYXJyb3dpbmdGb3JSdW5TdGVwKHRoaXMudHJhaW5pbmdJbnB1dE5hbWVzLCB0aGlzLnRyYWluaW5nT3V0cHV0TmFtZXMsIGZlZWRzLCBhcmcxLCBhcmcyKTtcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5oYW5kbGVyLnJ1blRyYWluU3RlcChmZWVkcywgZmV0Y2hlcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuY29udmVydEhhbmRsZXJSZXR1cm5UeXBlVG9NYXBPZlRlbnNvcnMocmVzdWx0cyk7XG4gIH1cblxuICBhc3luYyBydW5PcHRpbWl6ZXJTdGVwKG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnN8dW5kZWZpbmVkKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuaGFzT3B0aW1pemVyTW9kZWwpIHtcbiAgICAgIGF3YWl0IHRoaXMuaGFuZGxlci5ydW5PcHRpbWl6ZXJTdGVwKG9wdGlvbnMgfHwge30pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgVHJhaW5pbmdTZXNzaW9uIGhhcyBubyBPcHRpbWl6ZXJNb2RlbCBsb2FkZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgcnVuRXZhbFN0ZXAoZmVlZHM6IEZlZWRzVHlwZSwgb3B0aW9ucz86IFJ1bk9wdGlvbnN8dW5kZWZpbmVkKTogUHJvbWlzZTxSZXR1cm5UeXBlPjtcbiAgcnVuRXZhbFN0ZXAoZmVlZHM6IEZlZWRzVHlwZSwgZmV0Y2hlczogRmV0Y2hlc1R5cGUsIG9wdGlvbnM/OiBSdW5PcHRpb25zfHVuZGVmaW5lZCk6IFByb21pc2U8UmV0dXJuVHlwZT47XG4gIGFzeW5jIHJ1bkV2YWxTdGVwKGZlZWRzOiBGZWVkc1R5cGUsIGFyZzE/OiBGZXRjaGVzVHlwZXxSdW5PcHRpb25zLCBhcmcyPzogUnVuT3B0aW9ucyk6IFByb21pc2U8UmV0dXJuVHlwZT4ge1xuICAgIGlmICh0aGlzLmhhc0V2YWxNb2RlbCkge1xuICAgICAgY29uc3QgW2ZldGNoZXMsIG9wdGlvbnNdID1cbiAgICAgICAgICB0aGlzLnR5cGVOYXJyb3dpbmdGb3JSdW5TdGVwKHRoaXMuZXZhbElucHV0TmFtZXMsIHRoaXMuZXZhbE91dHB1dE5hbWVzLCBmZWVkcywgYXJnMSwgYXJnMik7XG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5oYW5kbGVyLnJ1bkV2YWxTdGVwKGZlZWRzLCBmZXRjaGVzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRIYW5kbGVyUmV0dXJuVHlwZVRvTWFwT2ZUZW5zb3JzKHJlc3VsdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgVHJhaW5pbmdTZXNzaW9uIGhhcyBubyBFdmFsTW9kZWwgbG9hZGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFBhcmFtZXRlcnNTaXplKHRyYWluYWJsZU9ubHkgPSB0cnVlKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmdldFBhcmFtZXRlcnNTaXplKHRyYWluYWJsZU9ubHkpO1xuICB9XG5cbiAgYXN5bmMgbG9hZFBhcmFtZXRlcnNCdWZmZXIoYXJyYXk6IFVpbnQ4QXJyYXksIHRyYWluYWJsZU9ubHkgPSB0cnVlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcGFyYW1zU2l6ZSA9IGF3YWl0IHRoaXMuZ2V0UGFyYW1ldGVyc1NpemUodHJhaW5hYmxlT25seSk7XG4gICAgLy8gY2hlY2tpbmcgdGhhdCB0aGUgc2l6ZSBvZiB0aGUgVWludDhBcnJheSBpcyBlcXVpdmFsZW50IHRvIHRoZSBieXRlIGxlbmd0aCBvZiBhIEZsb2F0MzJBcnJheSBvZiB0aGUgbnVtYmVyXG4gICAgLy8gb2YgcGFyYW1ldGVyc1xuICAgIGlmIChhcnJheS5sZW5ndGggIT09IDQgKiBwYXJhbXNTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1NpemUgb2YgdGhlIGJ1ZmZlciBwYXNzZWQgaW50byBsb2FkUGFyYW1ldGVyc0J1ZmZlciBtdXN0IG1hdGNoIHRoZSBudW1iZXIgb2YgcGFyYW1ldGVycyBpbiAnICtcbiAgICAgICAgICAndGhlIG1vZGVsLiBQbGVhc2UgdXNlIGdldFBhcmFtZXRlcnNTaXplIG1ldGhvZCB0byBjaGVjay4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5sb2FkUGFyYW1ldGVyc0J1ZmZlcihhcnJheSwgdHJhaW5hYmxlT25seSk7XG4gIH1cblxuICBhc3luYyBnZXRDb250aWd1b3VzUGFyYW1ldGVycyh0cmFpbmFibGVPbmx5ID0gdHJ1ZSk6IFByb21pc2U8T25ueFZhbHVlPiB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5nZXRDb250aWd1b3VzUGFyYW1ldGVycyh0cmFpbmFibGVPbmx5KTtcbiAgfVxuXG4gIGFzeW5jIHJlbGVhc2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5kaXNwb3NlKCk7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtJbmZlcmVuY2VTZXNzaW9ufSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcbmltcG9ydCB7T25ueFZhbHVlfSBmcm9tICcuL29ubngtdmFsdWUuanMnO1xuaW1wb3J0IHtUcmFpbmluZ1Nlc3Npb24gYXMgVHJhaW5pbmdTZXNzaW9uSW1wbH0gZnJvbSAnLi90cmFpbmluZy1zZXNzaW9uLWltcGwuanMnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkZWNsYXJlICovXG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBUcmFpbmluZ1Nlc3Npb24ge1xuICAvKipcbiAgICogRWl0aGVyIFVSSSBmaWxlIHBhdGggKHN0cmluZykgb3IgVWludDhBcnJheSBjb250YWluaW5nIG1vZGVsIG9yIGNoZWNrcG9pbnQgaW5mb3JtYXRpb24uXG4gICAqL1xuICB0eXBlIFVyaU9yQnVmZmVyID0gc3RyaW5nfFVpbnQ4QXJyYXk7XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgcnVudGltZSBpbnN0YW5jZSBvZiBhbiBPTk5YIHRyYWluaW5nIHNlc3Npb24sXG4gKiB3aGljaCBjb250YWlucyBhIG1vZGVsIHRoYXQgY2FuIGJlIHRyYWluZWQsIGFuZCwgb3B0aW9uYWxseSxcbiAqIGFuIGV2YWwgYW5kIG9wdGltaXplciBtb2RlbC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFpbmluZ1Nlc3Npb24ge1xuICAvLyAjcmVnaW9uIHJ1bigpXG5cbiAgLyoqXG4gICAqIExhemlseSByZXNldHMgdGhlIGdyYWRpZW50cyBvZiBhbGwgdHJhaW5hYmxlIHBhcmFtZXRlcnMgdG8gemVyby4gU2hvdWxkIGhhcHBlbiBhZnRlciB0aGUgaW52b2NhdGlvbiBvZlxuICAgKiBydW5PcHRpbWl6ZXJTdGVwLlxuICAgKi9cbiAgbGF6eVJlc2V0R3JhZCgpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBSdW4gVHJhaW5TdGVwIGFzeW5jaHJvbm91c2x5IHdpdGggdGhlIGdpdmVuIGZlZWRzIGFuZCBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gZmVlZHMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgaW5wdXQuIFNlZSB0eXBlIGRlc2NyaXB0aW9uIG9mIGBJbmZlcmVuY2VTZXNzaW9uLklucHV0VHlwZWAgZm9yXG4gICBkZXRhaWwuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwuIEEgc2V0IG9mIG9wdGlvbnMgdGhhdCBjb250cm9scyB0aGUgYmVoYXZpb3Igb2YgbW9kZWwgdHJhaW5pbmcuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbWFwLCB3aGljaCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAqL1xuICBydW5UcmFpblN0ZXAoZmVlZHM6IEluZmVyZW5jZVNlc3Npb24uRmVlZHNUeXBlLCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTpcbiAgICAgIFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbi5SZXR1cm5UeXBlPjtcblxuICAvKipcbiAgICogUnVuIGEgc2luZ2xlIHRyYWluIHN0ZXAgd2l0aCB0aGUgZ2l2ZW4gaW5wdXRzIGFuZCBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gZmVlZHMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgaW5wdXQuXG4gICAqIEBwYXJhbSBmZXRjaGVzIC0gUmVwcmVzZW50YXRpb24gb2YgdGhlIG1vZGVsIG91dHB1dC5cbiAgICogZGV0YWlsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBBIHNldCBvZiBvcHRpb25zIHRoYXQgY29udHJvbHMgdGhlIGJlaGF2aW9yIG9mIG1vZGVsIHRyYWluaW5nLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIG1hcCwgd2hpY2ggdXNlcyBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmdcbiAgIHZhbHVlcy5cbiAgICovXG4gIHJ1blRyYWluU3RlcChcbiAgICAgIGZlZWRzOiBJbmZlcmVuY2VTZXNzaW9uLkZlZWRzVHlwZSwgZmV0Y2hlczogSW5mZXJlbmNlU2Vzc2lvbi5GZXRjaGVzVHlwZSxcbiAgICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24uUmV0dXJuVHlwZT47XG5cbiAgLyoqXG4gICAqIFJ1bnMgYSBzaW5nbGUgb3B0aW1pemVyIHN0ZXAsIHdoaWNoIHBlcmZvcm1zIHdlaWdodCB1cGRhdGVzIGZvciB0aGUgdHJhaW5hYmxlIHBhcmFtZXRlcnMgdXNpbmcgdGhlIG9wdGltaXplciBtb2RlbC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gQSBzZXQgb2Ygb3B0aW9ucyB0aGF0IGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBtb2RlbCBvcHRpbWl6aW5nLlxuICAgKi9cbiAgcnVuT3B0aW1pemVyU3RlcChvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogUnVuIGEgc2luZ2xlIGV2YWwgc3RlcCB3aXRoIHRoZSBnaXZlbiBpbnB1dHMgYW5kIG9wdGlvbnMgdXNpbmcgdGhlIGV2YWwgbW9kZWwuXG4gICAqXG4gICAqIEBwYXJhbSBmZWVkcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBpbnB1dC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gQSBzZXQgb2Ygb3B0aW9ucyB0aGF0IGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBtb2RlbCBldmFsIHN0ZXAuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbWFwLCB3aGljaCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZ1xuICAgdmFsdWVzLlxuICAgKi9cbiAgcnVuRXZhbFN0ZXAoZmVlZHM6IEluZmVyZW5jZVNlc3Npb24uRmVlZHNUeXBlLCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zKTpcbiAgICAgIFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbi5SZXR1cm5UeXBlPjtcblxuICAvKipcbiAgICogUnVuIGEgc2luZ2xlIGV2YWwgc3RlcCB3aXRoIHRoZSBnaXZlbiBpbnB1dHMgYW5kIG9wdGlvbnMgdXNpbmcgdGhlIGV2YWwgbW9kZWwuXG4gICAqXG4gICAqIEBwYXJhbSBmZWVkcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBpbnB1dC5cbiAgICogQHBhcmFtIGZldGNoZXMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgb3V0cHV0LlxuICAgKiBkZXRhaWwuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwuIEEgc2V0IG9mIG9wdGlvbnMgdGhhdCBjb250cm9scyB0aGUgYmVoYXZpb3Igb2YgbW9kZWwgZXZhbCBzdGVwLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIG1hcCwgd2hpY2ggdXNlcyBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmdcbiAgIHZhbHVlcy5cbiAgICovXG4gIHJ1bkV2YWxTdGVwKFxuICAgICAgZmVlZHM6IEluZmVyZW5jZVNlc3Npb24uRmVlZHNUeXBlLCBmZXRjaGVzOiBJbmZlcmVuY2VTZXNzaW9uLkZldGNoZXNUeXBlLFxuICAgICAgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbi5SZXR1cm5UeXBlPjtcblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBjb3B5IHBhcmFtZXRlcnNcblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBzaXplIG9mIGFsbCBwYXJhbWV0ZXJzIGZvciB0aGUgdHJhaW5pbmcgc3RhdGUuIENhbGN1bGF0ZXMgdGhlIHRvdGFsIG51bWJlciBvZiBwcmltaXRpdmUgKGRhdGF0eXBlIG9mXG4gICAqIHRoZSBwYXJhbWV0ZXJzKSBlbGVtZW50cyBvZiBhbGwgdGhlIHBhcmFtZXRlcnMgaW4gdGhlIHRyYWluaW5nIHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0gdHJhaW5hYmxlT25seSAtIFdoZW4gc2V0IHRvIHRydWUsIHRoZSBzaXplIGlzIGNhbGN1bGF0ZWQgZm9yIHRyYWluYWJsZSBwYXJhbXMgb25seS4gRGVmYXVsdCB2YWx1ZSBpcyB0cnVlLlxuICAgKi9cbiAgZ2V0UGFyYW1ldGVyc1NpemUodHJhaW5hYmxlT25seTogYm9vbGVhbik6IFByb21pc2U8bnVtYmVyPjtcblxuICAvKipcbiAgICogQ29waWVzIHBhcmFtZXRlciB2YWx1ZXMgZnJvbSB0aGUgZ2l2ZW4gYnVmZmVyIHRvIHRoZSB0cmFpbmluZyBzdGF0ZS4gQ3VycmVudGx5LCBvbmx5IHN1cHBvcnRpbmcgbW9kZWxzIHdpdGhcbiAgICogcGFyYW1ldGVycyBvZiB0eXBlIEZsb2F0MzIuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgLSBBIFVpbnQ4QXJyYXkgcmVwcmVzZW50YXRpb24gb2YgRmxvYXQzMiBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0gdHJhaW5hYmxlT25seSAtIFRydWUgaWYgdHJhaW5hYmxlIHBhcmFtZXRlcnMgb25seSB0byBiZSBtb2RpZmllZCwgZmFsc2Ugb3RoZXJ3aXNlLiBEZWZhdWx0IHZhbHVlIGlzIHRydWUuXG4gICAqL1xuICBsb2FkUGFyYW1ldGVyc0J1ZmZlcihidWZmZXI6IFVpbnQ4QXJyYXksIHRyYWluYWJsZU9ubHk6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIG1vZGVsIHBhcmFtZXRlcnMgdG8gYSBjb250aWd1b3VzIGJ1ZmZlci4gVXN1YWxseSB1c2VkIGluIHRoZSBjb250ZXh0IG9mIEZlZGVyYXRlZCBMZWFybmluZy5cbiAgICogQ3VycmVudGx5LCBvbmx5IHN1cHBvcnRpbmcgbW9kZWxzIHdpdGggcGFyYW1ldGVycyBvZiB0eXBlIEZsb2F0MzIuXG4gICAqXG4gICAqIEBwYXJhbSB0cmFpbmFibGVPbmx5IC0gV2hlbiBzZXQgdG8gdHJ1ZSwgb25seSB0cmFpbmFibGUgcGFyYW1ldGVycyBhcmUgY29waWVkLiBUcmFpbmFibGUgcGFyYW1ldGVycyBhcmUgcGFyYW1ldGVyc1xuICAgKiBmb3Igd2hpY2ggcmVxdWlyZXNfZ3JhZCBpcyBzZXQgdG8gdHJ1ZS4gRGVmYXVsdCB2YWx1ZSBpcyB0cnVlLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIEZsb2F0MzIgT25ueFZhbHVlIG9mIHRoZSByZXF1ZXN0ZWQgcGFyYW1ldGVycy5cbiAgICovXG4gIGdldENvbnRpZ3VvdXNQYXJhbWV0ZXJzKHRyYWluYWJsZU9ubHk6IGJvb2xlYW4pOiBQcm9taXNlPE9ubnhWYWx1ZT47XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHJlbGVhc2UoKVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlIHRoZSBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgdGhlIHVuZGVybHlpbmcgcmVzb3VyY2VzLlxuICAgKi9cbiAgcmVsZWFzZSgpOiBQcm9taXNlPHZvaWQ+O1xuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBtZXRhZGF0YVxuXG4gIC8qKlxuICAgKiBHZXQgaW5wdXQgbmFtZXMgb2YgdGhlIGxvYWRlZCB0cmFpbmluZyBtb2RlbC5cbiAgICovXG4gIHJlYWRvbmx5IHRyYWluaW5nSW5wdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIEdldCBvdXRwdXQgbmFtZXMgb2YgdGhlIGxvYWRlZCB0cmFpbmluZyBtb2RlbC5cbiAgICovXG4gIHJlYWRvbmx5IHRyYWluaW5nT3V0cHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBHZXQgaW5wdXQgbmFtZXMgb2YgdGhlIGxvYWRlZCBldmFsIG1vZGVsLiBJcyBhbiBlbXB0eSBhcnJheSBpZiBubyBldmFsIG1vZGVsIGlzIGxvYWRlZC5cbiAgICovXG4gIHJlYWRvbmx5IGV2YWxJbnB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICAvKipcbiAgICogR2V0IG91dHB1dCBuYW1lcyBvZiB0aGUgbG9hZGVkIGV2YWwgbW9kZWwuIElzIGFuIGVtcHR5IGFycmF5IGlmIG5vIGV2YWwgbW9kZWwgaXMgbG9hZGVkLlxuICAgKi9cbiAgcmVhZG9ubHkgZXZhbE91dHB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICAvLyAjZW5kcmVnaW9uXG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgb3B0aW9uYWwgcGFyYW1ldGVycyB0aGF0IGNhbiBiZSBwYXNzZWQgaW50byB0aGUgVHJhaW5pbmdTZXNzaW9uRmFjdG9yeS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFpbmluZ1Nlc3Npb25DcmVhdGVPcHRpb25zIHtcbiAgLyoqXG4gICAqIFVSSSBvciBidWZmZXIgZm9yIGEgLmNrcHQgZmlsZSB0aGF0IGNvbnRhaW5zIHRoZSBjaGVja3BvaW50IGZvciB0aGUgdHJhaW5pbmcgbW9kZWwuXG4gICAqL1xuICBjaGVja3BvaW50U3RhdGU6IFRyYWluaW5nU2Vzc2lvbi5VcmlPckJ1ZmZlcjtcbiAgLyoqXG4gICAqIFVSSSBvciBidWZmZXIgZm9yIHRoZSAub25ueCB0cmFpbmluZyBmaWxlLlxuICAgKi9cbiAgdHJhaW5Nb2RlbDogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyO1xuICAvKipcbiAgICogT3B0aW9uYWwuIFVSSSBvciBidWZmZXIgZm9yIHRoZSAub25ueCBvcHRpbWl6ZXIgbW9kZWwgZmlsZS5cbiAgICovXG4gIG9wdGltaXplck1vZGVsPzogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyO1xuICAvKipcbiAgICogT3B0aW9uYWwuIFVSSSBvciBidWZmZXIgZm9yIHRoZSAub25ueCBldmFsIG1vZGVsIGZpbGUuXG4gICAqL1xuICBldmFsTW9kZWw/OiBUcmFpbmluZ1Nlc3Npb24uVXJpT3JCdWZmZXI7XG59XG5cbi8qKlxuICogRGVmaW5lcyBtZXRob2Qgb3ZlcmxvYWQgcG9zc2liaWxpdGllcyBmb3IgY3JlYXRpbmcgYSBUcmFpbmluZ1Nlc3Npb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhaW5pbmdTZXNzaW9uRmFjdG9yeSB7XG4gIC8vICNyZWdpb24gY3JlYXRlKClcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBUcmFpbmluZ1Nlc3Npb24gYW5kIGFzeW5jaHJvbm91c2x5IGxvYWRzIGFueSBtb2RlbHMgcGFzc2VkIGluIHRocm91Z2ggdHJhaW5pbmdPcHRpb25zXG4gICAqXG4gICAqIEBwYXJhbSB0cmFpbmluZ09wdGlvbnMgc3BlY2lmeSBtb2RlbHMgYW5kIGNoZWNrcG9pbnRzIHRvIGxvYWQgaW50byB0aGUgVHJhaW5pbmcgU2Vzc2lvblxuICAgKiBAcGFyYW0gc2Vzc2lvbk9wdGlvbnMgc3BlY2lmeSBjb25maWd1cmF0aW9uIGZvciB0cmFpbmluZyBzZXNzaW9uIGJlaGF2aW9yXG4gICAqXG4gICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIFRyYWluaW5nU2Vzc2lvbiBvYmplY3RcbiAgICovXG4gIGNyZWF0ZSh0cmFpbmluZ09wdGlvbnM6IFRyYWluaW5nU2Vzc2lvbkNyZWF0ZU9wdGlvbnMsIHNlc3Npb25PcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6XG4gICAgICBQcm9taXNlPFRyYWluaW5nU2Vzc2lvbj47XG5cbiAgLy8gI2VuZHJlZ2lvblxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY29uc3QgVHJhaW5pbmdTZXNzaW9uOiBUcmFpbmluZ1Nlc3Npb25GYWN0b3J5ID0gVHJhaW5pbmdTZXNzaW9uSW1wbDtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLyoqXG4gKiAjIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSVxuICpcbiAqIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSSBpcyBhIHVuaWZpZWQgQVBJIGZvciBhbGwgSmF2YVNjcmlwdCB1c2FnZXMsIGluY2x1ZGluZyB0aGUgZm9sbG93aW5nIE5QTSBwYWNrYWdlczpcbiAqXG4gKiAtIFtvbm54cnVudGltZS1ub2RlXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS1ub2RlKVxuICogLSBbb25ueHJ1bnRpbWUtd2ViXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS13ZWIpXG4gKiAtIFtvbm54cnVudGltZS1yZWFjdC1uYXRpdmVdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL29ubnhydW50aW1lLXJlYWN0LW5hdGl2ZSlcbiAqXG4gKiBTZWUgYWxzbzpcbiAqIC0gW0dldCBTdGFydGVkXShodHRwczovL29ubnhydW50aW1lLmFpL2RvY3MvZ2V0LXN0YXJ0ZWQvd2l0aC1qYXZhc2NyaXB0LylcbiAqIC0gW0luZmVyZW5jZSBleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS1pbmZlcmVuY2UtZXhhbXBsZXMvdHJlZS9tYWluL2pzKVxuICpcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5cbmV4cG9ydCAqIGZyb20gJy4vYmFja2VuZC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2Vudi5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdGVuc29yLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdGVuc29yLWNvbnZlcnNpb24uanMnO1xuZXhwb3J0ICogZnJvbSAnLi90ZW5zb3ItZmFjdG9yeS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3RyYWNlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vb25ueC1tb2RlbC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL29ubngtdmFsdWUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi90cmFpbmluZy1zZXNzaW9uLmpzJztcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuZXhwb3J0IGNvbnN0IGlzTm9kZSA9ICEhKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8vLyA8cmVmZXJlbmNlIGxpYj1cIndlYndvcmtlclwiIC8+XG5cbi8vXG4vLyAqIHR5cGUgaGFjayBmb3IgXCJIVE1MSW1hZ2VFbGVtZW50XCJcbi8vXG4vLyBpbiB0eXBlc2NyaXB0LCB0aGUgdHlwZSBvZiBcIkhUTUxJbWFnZUVsZW1lbnRcIiBpcyBkZWZpbmVkIGluIGxpYi5kb20uZC50cywgd2hpY2ggaXMgY29uZmxpY3Qgd2l0aCBsaWIud2Vid29ya2VyLmQudHMuXG4vLyB3aGVuIHdlIHVzZSB3ZWJ3b3JrZXIsIHRoZSBsaWIud2Vid29ya2VyLmQudHMgd2lsbCBiZSB1c2VkLCB3aGljaCBkb2VzIG5vdCBoYXZlIEhUTUxJbWFnZUVsZW1lbnQgZGVmaW5lZC5cbi8vXG4vLyB3ZSB3aWxsIGdldCB0aGUgZm9sbG93aW5nIGVycm9ycyBjb21wbGFpbmluZyB0aGF0IEhUTUxJbWFnZUVsZW1lbnQgaXMgbm90IGRlZmluZWQ6XG4vL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vXG4vLyAuLi9jb21tb24vZGlzdC9janMvdGVuc29yLWZhY3RvcnkuZC50czoxODc6MjkgLSBlcnJvciBUUzI1NTI6IENhbm5vdCBmaW5kIG5hbWUgJ0hUTUxJbWFnZUVsZW1lbnQnLiBEaWQgeW91IG1lYW5cbi8vICdIVE1MTElFbGVtZW50Jz9cbi8vXG4vLyAxODcgICAgIGZyb21JbWFnZShpbWFnZUVsZW1lbnQ6IEhUTUxJbWFnZUVsZW1lbnQsIG9wdGlvbnM/OiBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9ucyk6XG4vLyBQcm9taXNlPFR5cGVkVGVuc29yPCdmbG9hdDMyJz4gfCBUeXBlZFRlbnNvcjwndWludDgnPj47XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH5+fn5+fn5+fn5+fn5+fn5cbi8vXG4vLyBub2RlX21vZHVsZXMvQHdlYmdwdS90eXBlcy9kaXN0L2luZGV4LmQudHM6ODM6NyAtIGVycm9yIFRTMjU1MjogQ2Fubm90IGZpbmQgbmFtZSAnSFRNTEltYWdlRWxlbWVudCcuIERpZCB5b3UgbWVhblxuLy8gJ0hUTUxMSUVsZW1lbnQnP1xuLy9cbi8vIDgzICAgICB8IEhUTUxJbWFnZUVsZW1lbnRcbi8vICAgICAgICAgIH5+fn5+fn5+fn5+fn5+fn5cbi8vXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy9cbi8vIGBIVE1MSW1hZ2VFbGVtZW50YCBpcyBvbmx5IHVzZWQgaW4gdHlwZSBkZWNsYXJhdGlvbiBhbmQgbm90IGluIHJlYWwgY29kZS4gU28gd2UgZGVmaW5lIGl0IGFzIGB1bmtub3duYCBoZXJlIHRvXG4vLyBieXBhc3MgdGhlIHR5cGUgY2hlY2suXG5cbi8vXG4vLyAqIHR5cGUgaGFjayBmb3IgXCJkb2N1bWVudFwiXG4vL1xuLy8gaW4gdHlwZXNjcmlwdCwgdGhlIHR5cGUgb2YgXCJkb2N1bWVudFwiIGlzIGRlZmluZWQgaW4gbGliLmRvbS5kLnRzLCBzbyBpdCdzIG5vdCBhdmFpbGFibGUgaW4gd2Vid29ya2VyLlxuLy9cbi8vIHdlIHdpbGwgZ2V0IHRoZSBmb2xsb3dpbmcgZXJyb3JzIGNvbXBsYWluaW5nIHRoYXQgZG9jdW1lbnQgaXMgbm90IGRlZmluZWQ6XG4vL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vXG4vLyBsaWIvd2FzbS93YXNtLXV0aWxzLWltcG9ydC50czo3OjMzIC0gZXJyb3IgVFMyNTg0OiBDYW5ub3QgZmluZCBuYW1lICdkb2N1bWVudCcuIERvIHlvdSBuZWVkIHRvIGNoYW5nZSB5b3VyIHRhcmdldFxuLy8gbGlicmFyeT8gVHJ5IGNoYW5naW5nIHRoZSAnbGliJyBjb21waWxlciBvcHRpb24gdG8gaW5jbHVkZSAnZG9tJy5cbi8vXG4vLyA3IGV4cG9ydCBjb25zdCBzY3JpcHRTcmMgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gKGRvY3VtZW50Py5jdXJyZW50U2NyaXB0IGFzIEhUTUxTY3JpcHRFbGVtZW50KT8uc3JjIDpcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB+fn5+fn5+flxuLy9cbi8vIGxpYi93YXNtL3dhc20tdXRpbHMtaW1wb3J0LnRzOjc6NjEgLSBlcnJvciBUUzI1ODQ6IENhbm5vdCBmaW5kIG5hbWUgJ2RvY3VtZW50Jy4gRG8geW91IG5lZWQgdG8gY2hhbmdlIHlvdXIgdGFyZ2V0XG4vLyBsaWJyYXJ5PyBUcnkgY2hhbmdpbmcgdGhlICdsaWInIGNvbXBpbGVyIG9wdGlvbiB0byBpbmNsdWRlICdkb20nLlxuLy9cbi8vIDcgZXhwb3J0IGNvbnN0IHNjcmlwdFNyYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyAoZG9jdW1lbnQ/LmN1cnJlbnRTY3JpcHQgYXMgSFRNTFNjcmlwdEVsZW1lbnQpPy5zcmMgOlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB+fn5+fn5+flxuLy9cbi8vIGxpYi93YXNtL3dhc20tdXRpbHMtaW1wb3J0LnRzOjc6ODggLSBlcnJvciBUUzI1NTI6IENhbm5vdCBmaW5kIG5hbWUgJ0hUTUxTY3JpcHRFbGVtZW50Jy4gRGlkIHlvdSBtZWFuXG4vLyAnSFRNTExJRWxlbWVudCc/XG4vL1xuLy8gNyBleHBvcnQgY29uc3Qgc2NyaXB0U3JjID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IChkb2N1bWVudD8uY3VycmVudFNjcmlwdCBhcyBIVE1MU2NyaXB0RWxlbWVudCk/LnNyYyA6XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH5+fn5+fn5+fn5+fn5+fn5+XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy9cbi8vIGBkb2N1bWVudGAgaXMgdXNlZCB0byBnZXQgdGhlIGN1cnJlbnQgc2NyaXB0IFVSTCwgd2hpY2ggaXMgbm90IGF2YWlsYWJsZSBpbiB3ZWJ3b3JrZXIuIFRoaXMgZmlsZSBpcyBzZXJ2ZWQgYXMgYVxuLy8gXCJkdWFsXCIgZmlsZSBmb3IgZW50cmllcyBvZiBib3RoIHdlYndvcmtlciBhbmQgdGhlIGVzbSBtb2R1bGUuXG4vL1xuZGVjbGFyZSBnbG9iYWwge1xuICB0eXBlIEhUTUxJbWFnZUVsZW1lbnQgPSB1bmtub3duO1xuICB0eXBlIEhUTUxTY3JpcHRFbGVtZW50ID0ge3NyYz86IHN0cmluZ307XG4gIGNvbnN0IGRvY3VtZW50OiB1bmRlZmluZWR8e2N1cnJlbnRTY3JpcHQ/OiBIVE1MU2NyaXB0RWxlbWVudH07XG59XG5cbi8qKlxuICogQHN1bW1hcnlcbiAqXG4gKiBUaGlzIGZpbGUgaXMgc2VydmVkIGFzIGEgXCJkdWFsXCIgZmlsZSBmb3IgYm90aCBlbnRyaWVzIG9mIHRoZSBmb2xsb3dpbmc6XG4gKiAtIFRoZSBwcm94eSB3b3JrZXIgaXRzZWxmLlxuICogICAtIFdoZW4gdXNlZCBhcyBhIHdvcmtlciwgaXQgbGlzdGVucyB0byB0aGUgbWVzc2FnZXMgZnJvbSB0aGUgbWFpbiB0aHJlYWQgYW5kIHBlcmZvcm1zIHRoZSBjb3JyZXNwb25kaW5nIG9wZXJhdGlvbnMuXG4gKiAgIC0gU2hvdWxkIGJlIGltcG9ydGVkIGRpcmVjdGx5IHVzaW5nIGBuZXcgV29ya2VyKClgIGluIHRoZSBtYWluIHRocmVhZC5cbiAqXG4gKiAtIFRoZSBFU00gbW9kdWxlIHRoYXQgY3JlYXRlcyB0aGUgcHJveHkgd29ya2VyIChhcyBhIHdvcmtlciBsYXVuY2hlcikuXG4gKiAgIC0gV2hlbiB1c2VkIGFzIGEgd29ya2VyIGxhdW5jaGVyLCBpdCBjcmVhdGVzIHRoZSBwcm94eSB3b3JrZXIgYW5kIHJldHVybnMgaXQuXG4gKiAgIC0gU2hvdWxkIGJlIGltcG9ydGVkIHVzaW5nIGBpbXBvcnQoKWAgaW4gdGhlIG1haW4gdGhyZWFkLCB3aXRoIHRoZSBxdWVyeSBwYXJhbWV0ZXIgYGltcG9ydD0xYC5cbiAqXG4gKiBUaGlzIGZpbGUgd2lsbCBiZSBhbHdheXMgY29tcGlsaW5nIGludG8gRVNNIGZvcm1hdC5cbiAqL1xuXG5pbXBvcnQgdHlwZSB7T3J0V2FzbU1lc3NhZ2UsIFNlcmlhbGl6YWJsZVRlbnNvck1ldGFkYXRhfSBmcm9tICcuLi9wcm94eS1tZXNzYWdlcy5qcyc7XG5pbXBvcnQge2NyZWF0ZVNlc3Npb24sIGNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIsIGVuZFByb2ZpbGluZywgZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnMsIGluaXRFcCwgaW5pdFJ1bnRpbWUsIHJlbGVhc2VTZXNzaW9uLCBydW59IGZyb20gJy4uL3dhc20tY29yZS1pbXBsLmpzJztcbmltcG9ydCB7aW5pdGlhbGl6ZVdlYkFzc2VtYmx5fSBmcm9tICcuLi93YXNtLWZhY3RvcnkuanMnO1xuaW1wb3J0IHtzY3JpcHRTcmN9IGZyb20gJy4uL3dhc20tdXRpbHMtaW1wb3J0LmpzJztcblxuY29uc3QgV09SS0VSX05BTUUgPSAnb3J0LXdhc20tcHJveHktd29ya2VyJztcbmNvbnN0IGlzUHJveHlXb3JrZXIgPSBnbG9iYWxUaGlzLnNlbGY/Lm5hbWUgPT09IFdPUktFUl9OQU1FO1xuXG5pZiAoaXNQcm94eVdvcmtlcikge1xuICAvLyBXb3JrZXIgdGhyZWFkXG4gIHNlbGYub25tZXNzYWdlID0gKGV2OiBNZXNzYWdlRXZlbnQ8T3J0V2FzbU1lc3NhZ2U+KTogdm9pZCA9PiB7XG4gICAgY29uc3Qge3R5cGUsIGluIDogbWVzc2FnZX0gPSBldi5kYXRhO1xuICAgIHRyeSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnaW5pdC13YXNtJzpcbiAgICAgICAgICBpbml0aWFsaXplV2ViQXNzZW1ibHkobWVzc2FnZSEud2FzbSlcbiAgICAgICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRSdW50aW1lKG1lc3NhZ2UhKS50aGVuKFxuICAgICAgICAgICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7dHlwZX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHt0eXBlLCBlcnJ9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHt0eXBlLCBlcnJ9KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpbml0LWVwJzoge1xuICAgICAgICAgIGNvbnN0IHtlcE5hbWUsIGVudn0gPSBtZXNzYWdlITtcbiAgICAgICAgICBpbml0RXAoZW52LCBlcE5hbWUpXG4gICAgICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7dHlwZX0pO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHt0eXBlLCBlcnJ9KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2NvcHktZnJvbSc6IHtcbiAgICAgICAgICBjb25zdCB7YnVmZmVyfSA9IG1lc3NhZ2UhO1xuICAgICAgICAgIGNvbnN0IGJ1ZmZlckRhdGEgPSBjb3B5RnJvbUV4dGVybmFsQnVmZmVyKGJ1ZmZlcik7XG4gICAgICAgICAgcG9zdE1lc3NhZ2Uoe3R5cGUsIG91dDogYnVmZmVyRGF0YX0gYXMgT3J0V2FzbU1lc3NhZ2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2NyZWF0ZSc6IHtcbiAgICAgICAgICBjb25zdCB7bW9kZWwsIG9wdGlvbnN9ID0gbWVzc2FnZSE7XG4gICAgICAgICAgY3JlYXRlU2Vzc2lvbihtb2RlbCwgb3B0aW9ucylcbiAgICAgICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICAgICAgICBzZXNzaW9uTWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7dHlwZSwgb3V0OiBzZXNzaW9uTWV0YWRhdGF9IGFzIE9ydFdhc21NZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7dHlwZSwgZXJyfSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdyZWxlYXNlJzpcbiAgICAgICAgICByZWxlYXNlU2Vzc2lvbihtZXNzYWdlISk7XG4gICAgICAgICAgcG9zdE1lc3NhZ2Uoe3R5cGV9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncnVuJzoge1xuICAgICAgICAgIGNvbnN0IHtzZXNzaW9uSWQsIGlucHV0SW5kaWNlcywgaW5wdXRzLCBvdXRwdXRJbmRpY2VzLCBvcHRpb25zfSA9IG1lc3NhZ2UhO1xuICAgICAgICAgIHJ1bihzZXNzaW9uSWQsIGlucHV0SW5kaWNlcywgaW5wdXRzLCBvdXRwdXRJbmRpY2VzLCBuZXcgQXJyYXkob3V0cHV0SW5kaWNlcy5sZW5ndGgpLmZpbGwobnVsbCksIG9wdGlvbnMpXG4gICAgICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgICAgICAgb3V0cHV0cyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXRzLnNvbWUobyA9PiBvWzNdICE9PSAnY3B1JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7dHlwZSwgZXJyOiAnUHJveHkgZG9lcyBub3Qgc3VwcG9ydCBub24tY3B1IHRlbnNvciBsb2NhdGlvbi4nfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHt0eXBlLCBvdXQ6IG91dHB1dHN9IGFzIE9ydFdhc21NZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycyhbLi4uaW5wdXRzLCAuLi5vdXRwdXRzXSBhcyBTZXJpYWxpemFibGVUZW5zb3JNZXRhZGF0YVtdKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7dHlwZSwgZXJyfSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdlbmQtcHJvZmlsaW5nJzpcbiAgICAgICAgICBlbmRQcm9maWxpbmcobWVzc2FnZSEpO1xuICAgICAgICAgIHBvc3RNZXNzYWdlKHt0eXBlfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBwb3N0TWVzc2FnZSh7dHlwZSwgZXJyfSBhcyBPcnRXYXNtTWVzc2FnZSk7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1Byb3h5V29ya2VyID9cbiAgICBudWxsIDpcbiAgICAodXJsT3ZlcnJpZGU/OiBzdHJpbmcpID0+XG4gICAgICAgIG5ldyBXb3JrZXIodXJsT3ZlcnJpZGUgPz8gc2NyaXB0U3JjISwge3R5cGU6IEJVSUxEX0RFRlMuSVNfRVNNID8gJ21vZHVsZScgOiAnY2xhc3NpYycsIG5hbWU6IFdPUktFUl9OQU1FfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB0eXBlIHtPcnRXYXNtTW9kdWxlfSBmcm9tICcuL3dhc20tdHlwZXMnO1xuaW1wb3J0IHtpc05vZGV9IGZyb20gJy4vd2FzbS11dGlscy1lbnYnO1xuXG4vKipcbiAqIFRoZSBjbGFzc2ljIHNjcmlwdCBzb3VyY2UgVVJMLiBUaGlzIGlzIG5vdCBhbHdheXMgYXZhaWxhYmxlIGluIG5vbiBFU01vZHVsZSBlbnZpcm9ubWVudHMuXG4gKlxuICogSW4gTm9kZS5qcywgdGhpcyBpcyB1bmRlZmluZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBzY3JpcHRTcmMgPVxuICAgIC8vIGlmIE5vZGVqcywgcmV0dXJuIHVuZGVmaW5lZFxuICAgIGlzTm9kZSA/IHVuZGVmaW5lZCA6XG4gICAgICAgICAgICAgLy8gaWYgSXQncyBFU00sIHVzZSBpbXBvcnQubWV0YS51cmxcbiAgICAgICAgICAgICBCVUlMRF9ERUZTLkVTTV9JTVBPUlRfTUVUQV9VUkwgPz9cbiAgICAgICAgLy8gdXNlIGBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyY2AgaWYgYXZhaWxhYmxlXG4gICAgICAgICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgYXMgSFRNTFNjcmlwdEVsZW1lbnQpPy5zcmMgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSBgc2VsZi5sb2NhdGlvbi5ocmVmYCBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZi5sb2NhdGlvbj8uaHJlZiA6IHVuZGVmaW5lZCkpO1xuXG4vKipcbiAqIFRoZSBvcmlnaW4gb2YgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gKlxuICogSW4gTm9kZS5qcywgdGhpcyBpcyB1bmRlZmluZWQuXG4gKi9cbmNvbnN0IG9yaWdpbiA9IGlzTm9kZSB8fCB0eXBlb2YgbG9jYXRpb24gPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogbG9jYXRpb24ub3JpZ2luO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBmaWxlbmFtZSB3aXRoIHByZWZpeCBpcyBmcm9tIHRoZSBzYW1lIG9yaWdpbi5cbiAqL1xuY29uc3QgaXNTYW1lT3JpZ2luID0gKGZpbGVuYW1lOiBzdHJpbmcsIHByZWZpeE92ZXJyaWRlPzogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgYmFzZVVybCA9IHByZWZpeE92ZXJyaWRlID8/IHNjcmlwdFNyYztcbiAgICBjb25zdCB1cmwgPSBiYXNlVXJsID8gbmV3IFVSTChmaWxlbmFtZSwgYmFzZVVybCkgOiBuZXcgVVJMKGZpbGVuYW1lKTtcbiAgICByZXR1cm4gdXJsLm9yaWdpbiA9PT0gb3JpZ2luO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBpbnB1dHMgdG8gYW4gYWJzb2x1dGUgVVJMIHdpdGggdGhlIGdpdmVuIHByZWZpeCBvdmVycmlkZS4gSWYgZmFpbGVkLCByZXR1cm4gdW5kZWZpbmVkLlxuICovXG5jb25zdCBub3JtYWxpemVVcmwgPSAoZmlsZW5hbWU6IHN0cmluZywgcHJlZml4T3ZlcnJpZGU/OiBzdHJpbmcpID0+IHtcbiAgY29uc3QgYmFzZVVybCA9IHByZWZpeE92ZXJyaWRlID8/IHNjcmlwdFNyYztcbiAgdHJ5IHtcbiAgICBjb25zdCB1cmwgPSBiYXNlVXJsID8gbmV3IFVSTChmaWxlbmFtZSwgYmFzZVVybCkgOiBuZXcgVVJMKGZpbGVuYW1lKTtcbiAgICByZXR1cm4gdXJsLmhyZWY7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgZmFsbGJhY2sgVVJMIGlmIGFuIGFic29sdXRlIFVSTCBjYW5ub3QgYmUgY3JlYXRlZCBieSB0aGUgbm9ybWFsaXplVXJsIGZ1bmN0aW9uLlxuICovXG5jb25zdCBmYWxsYmFja1VybCA9IChmaWxlbmFtZTogc3RyaW5nLCBwcmVmaXhPdmVycmlkZT86IHN0cmluZykgPT4gYCR7cHJlZml4T3ZlcnJpZGUgPz8gJy4vJ30ke2ZpbGVuYW1lfWA7XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdXNlZCB0byBwcmVsb2FkIGEgbW9kdWxlIGZyb20gYSBVUkwuXG4gKlxuICogSWYgdGhlIG9yaWdpbiBvZiB0aGUgd29ya2VyIFVSTCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCBvcmlnaW4sIHRoZSB3b3JrZXIgY2Fubm90IGJlIGxvYWRlZCBkaXJlY3RseS5cbiAqIFNlZSBkaXNjdXNzaW9ucyBpbiBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3dvcmtlci1sb2FkZXIvaXNzdWVzLzE1NFxuICpcbiAqIEluIHRoaXMgY2FzZSwgd2Ugd2lsbCBmZXRjaCB0aGUgd29ya2VyIFVSTCBhbmQgY3JlYXRlIGEgbmV3IEJsb2IgVVJMIHdpdGggdGhlIHNhbWUgb3JpZ2luIGFzIGEgd29ya2Fyb3VuZC5cbiAqXG4gKiBAcGFyYW0gYWJzb2x1dGVVcmwgLSBUaGUgYWJzb2x1dGUgVVJMIHRvIHByZWxvYWQuXG4gKlxuICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIG5ldyBCbG9iIFVSTFxuICovXG5jb25zdCBwcmVsb2FkID0gYXN5bmMoYWJzb2x1dGVVcmw6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYWJzb2x1dGVVcmwsIHtjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJ30pO1xuICBjb25zdCBibG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbn07XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdXNlZCB0byBkeW5hbWljYWxseSBpbXBvcnQgYSBtb2R1bGUgZnJvbSBhIFVSTC5cbiAqXG4gKiBUaGUgYnVpbGQgc2NyaXB0IGhhcyBzcGVjaWFsIGhhbmRsaW5nIGZvciB0aGlzIGZ1bmN0aW9uIHRvIGVuc3VyZSB0aGF0IHRoZSBVUkwgaXMgbm90IGJ1bmRsZWQgaW50byB0aGUgZmluYWwgb3V0cHV0LlxuICpcbiAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRvIGltcG9ydC5cbiAqXG4gKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBkZWZhdWx0IGV4cG9ydCBvZiB0aGUgbW9kdWxlLlxuICovXG5jb25zdCBkeW5hbWljSW1wb3J0RGVmYXVsdCA9IGFzeW5jPFQ+KHVybDogc3RyaW5nKTogUHJvbWlzZTxUPiA9PiAoYXdhaXQgaW1wb3J0KC8qIHdlYnBhY2tJZ25vcmU6IHRydWUgKi8gdXJsKSkuZGVmYXVsdDtcblxuLyoqXG4gKiBUaGUgcHJveHkgd29ya2VyIGZhY3RvcnkgaW1wb3J0ZWQgZnJvbSB0aGUgcHJveHkgd29ya2VyIG1vZHVsZS5cbiAqXG4gKiBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIHdoZW4gdGhlIFdlYkFzc2VtYmx5IHByb3h5IGlzIG5vdCBkaXNhYmxlZC5cbiAqL1xuY29uc3QgY3JlYXRlUHJveHlXb3JrZXI6ICgodXJsT3ZlcnJpZGU/OiBzdHJpbmcpID0+IFdvcmtlcil8dW5kZWZpbmVkID1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuICAgIEJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZID8gdW5kZWZpbmVkIDogcmVxdWlyZSgnLi9wcm94eS13b3JrZXIvbWFpbicpLmRlZmF1bHQ7XG5cbi8qKlxuICogSW1wb3J0IHRoZSBwcm94eSB3b3JrZXIuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIHBlcmZvcm0gdGhlIGZvbGxvd2luZyBzdGVwczpcbiAqIDEuIElmIGEgcHJlbG9hZCBpcyBuZWVkZWQsIGl0IHdpbGwgcHJlbG9hZCB0aGUgbW9kdWxlIGFuZCByZXR1cm4gdGhlIG9iamVjdCBVUkwuXG4gKiAyLiBVc2UgdGhlIHByb3h5IHdvcmtlciBmYWN0b3J5IHRvIGNyZWF0ZSB0aGUgcHJveHkgd29ya2VyLlxuICpcbiAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSB0dXBsZSBvZiAyIGVsZW1lbnRzOlxuICogICAgICAgICAgICAtIFRoZSBvYmplY3QgVVJMIG9mIHRoZSBwcmVsb2FkZWQgbW9kdWxlLCBvciB1bmRlZmluZWQgaWYgbm8gcHJlbG9hZCBpcyBuZWVkZWQuXG4gKiAgICAgICAgICAgIC0gVGhlIHByb3h5IHdvcmtlci5cbiAqL1xuZXhwb3J0IGNvbnN0IGltcG9ydFByb3h5V29ya2VyID0gYXN5bmMoKTogUHJvbWlzZTxbdW5kZWZpbmVkIHwgc3RyaW5nLCBXb3JrZXJdPiA9PiB7XG4gIGlmICghc2NyaXB0U3JjKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBwcm94eSB3b3JrZXI6IGNhbm5vdCBkZXRlcm1pbmUgdGhlIHNjcmlwdCBzb3VyY2UgVVJMLicpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHNjcmlwdCBzb3VyY2UgaXMgZnJvbSB0aGUgc2FtZSBvcmlnaW4sIHdlIGNhbiB1c2UgdGhlIGVtYmVkZGVkIHByb3h5IG1vZHVsZSBkaXJlY3RseS5cbiAgaWYgKGlzU2FtZU9yaWdpbihzY3JpcHRTcmMpKSB7XG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIGNyZWF0ZVByb3h5V29ya2VyISgpXTtcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgbmVlZCB0byBwcmVsb2FkXG4gIGNvbnN0IHVybCA9IGF3YWl0IHByZWxvYWQoc2NyaXB0U3JjKTtcbiAgcmV0dXJuIFt1cmwsIGNyZWF0ZVByb3h5V29ya2VyISh1cmwpXTtcbn07XG5cbi8qKlxuICogSW1wb3J0IHRoZSBXZWJBc3NlbWJseSBtb2R1bGUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIHBlcmZvcm0gdGhlIGZvbGxvd2luZyBzdGVwczpcbiAqIDEuIElmIGEgcHJlbG9hZCBpcyBuZWVkZWQsIGl0IHdpbGwgcHJlbG9hZCB0aGUgbW9kdWxlIGFuZCByZXR1cm4gdGhlIG9iamVjdCBVUkwuXG4gKiAyLiBPdGhlcndpc2UsIGl0IHdpbGwgcGVyZm9ybSBhIGR5bmFtaWMgaW1wb3J0IG9mIHRoZSBtb2R1bGUuXG4gKlxuICogQHJldHVybnMgLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHR1cGxlIG9mIDIgZWxlbWVudHM6XG4gKiAgICAgICAgICAgIC0gVGhlIG9iamVjdCBVUkwgb2YgdGhlIHByZWxvYWRlZCBtb2R1bGUsIG9yIHVuZGVmaW5lZCBpZiBubyBwcmVsb2FkIGlzIG5lZWRlZC5cbiAqICAgICAgICAgICAgLSBUaGUgZGVmYXVsdCBleHBvcnQgb2YgdGhlIG1vZHVsZSwgd2hpY2ggaXMgYSBmYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgV2ViQXNzZW1ibHkgbW9kdWxlLlxuICovXG5leHBvcnQgY29uc3QgaW1wb3J0V2FzbU1vZHVsZSA9IGFzeW5jKFxuICAgIHVybE92ZXJyaWRlOiBzdHJpbmd8dW5kZWZpbmVkLCBwcmVmaXhPdmVycmlkZTogc3RyaW5nfHVuZGVmaW5lZCxcbiAgICBpc011bHRpVGhyZWFkZWQ6IGJvb2xlYW4pOiBQcm9taXNlPFt1bmRlZmluZWQgfCBzdHJpbmcsIEVtc2NyaXB0ZW5Nb2R1bGVGYWN0b3J5PE9ydFdhc21Nb2R1bGU+XT4gPT4ge1xuICBjb25zdCB3YXNtTW9kdWxlRmlsZW5hbWUgPSAhQlVJTERfREVGUy5ESVNBQkxFX1RSQUlOSU5HID8gJ29ydC10cmFpbmluZy13YXNtLXNpbWQtdGhyZWFkZWQubWpzJyA6XG4gICAgICAhQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnb3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLm1qcycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29ydC13YXNtLXNpbWQtdGhyZWFkZWQubWpzJztcbiAgY29uc3Qgd2FzbU1vZHVsZVVybCA9IHVybE92ZXJyaWRlID8/IG5vcm1hbGl6ZVVybCh3YXNtTW9kdWxlRmlsZW5hbWUsIHByZWZpeE92ZXJyaWRlKTtcbiAgLy8gbmVlZCB0byBwcmVsb2FkIGlmIGFsbCBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAgLy8gMS4gbm90IGluIE5vZGUuanMuXG4gIC8vICAgIC0gTm9kZS5qcyBkb2VzIG5vdCBoYXZlIHRoZSBzYW1lIG9yaWdpbiBwb2xpY3kgZm9yIGNyZWF0aW5nIHdvcmtlcnMuXG4gIC8vIDIuIG11bHRpLXRocmVhZGVkIGlzIGVuYWJsZWQuXG4gIC8vICAgIC0gSWYgbXVsdGktdGhyZWFkZWQgaXMgZGlzYWJsZWQsIG5vIHdvcmtlciB3aWxsIGJlIGNyZWF0ZWQuIFNvIHdlIGRvbid0IG5lZWQgdG8gcHJlbG9hZCB0aGUgbW9kdWxlLlxuICAvLyAzLiB0aGUgYWJzb2x1dGUgVVJMIGlzIGF2YWlsYWJsZS5cbiAgLy8gICAgLSBJZiB0aGUgYWJzb2x1dGUgVVJMIGlzIGZhaWxlZCB0byBiZSBjcmVhdGVkLCB0aGUgb3JpZ2luIGNhbm5vdCBiZSBkZXRlcm1pbmVkLiBJbiB0aGlzIGNhc2UsIHdlIHdpbGwgbm90XG4gIC8vICAgIHByZWxvYWQgdGhlIG1vZHVsZS5cbiAgLy8gNC4gdGhlIHdvcmtlciBVUkwgaXMgbm90IGZyb20gdGhlIHNhbWUgb3JpZ2luLlxuICAvLyAgICAtIElmIHRoZSB3b3JrZXIgVVJMIGlzIGZyb20gdGhlIHNhbWUgb3JpZ2luLCB3ZSBjYW4gY3JlYXRlIHRoZSB3b3JrZXIgZGlyZWN0bHkuXG4gIGNvbnN0IG5lZWRQcmVsb2FkID0gIWlzTm9kZSAmJiBpc011bHRpVGhyZWFkZWQgJiYgd2FzbU1vZHVsZVVybCAmJiAhaXNTYW1lT3JpZ2luKHdhc21Nb2R1bGVVcmwsIHByZWZpeE92ZXJyaWRlKTtcbiAgY29uc3QgdXJsID1cbiAgICAgIG5lZWRQcmVsb2FkID8gKGF3YWl0IHByZWxvYWQod2FzbU1vZHVsZVVybCkpIDogKHdhc21Nb2R1bGVVcmwgPz8gZmFsbGJhY2tVcmwod2FzbU1vZHVsZUZpbGVuYW1lLCBwcmVmaXhPdmVycmlkZSkpO1xuICByZXR1cm4gW25lZWRQcmVsb2FkID8gdXJsIDogdW5kZWZpbmVkLCBhd2FpdCBkeW5hbWljSW1wb3J0RGVmYXVsdDxFbXNjcmlwdGVuTW9kdWxlRmFjdG9yeTxPcnRXYXNtTW9kdWxlPj4odXJsKV07XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0Vudn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHR5cGUge09ydFdhc21Nb2R1bGV9IGZyb20gJy4vd2FzbS10eXBlcyc7XG5pbXBvcnQge2ltcG9ydFdhc21Nb2R1bGV9IGZyb20gJy4vd2FzbS11dGlscy1pbXBvcnQnO1xuXG5sZXQgd2FzbTogT3J0V2FzbU1vZHVsZXx1bmRlZmluZWQ7XG5sZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbmxldCBpbml0aWFsaXppbmcgPSBmYWxzZTtcbmxldCBhYm9ydGVkID0gZmFsc2U7XG5cbmNvbnN0IGlzTXVsdGlUaHJlYWRTdXBwb3J0ZWQgPSAoKTogYm9vbGVhbiA9PiB7XG4gIC8vIElmICdTaGFyZWRBcnJheUJ1ZmZlcicgaXMgbm90IGF2YWlsYWJsZSwgV2ViQXNzZW1ibHkgdGhyZWFkcyB3aWxsIG5vdCB3b3JrLlxuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGVzdCBmb3IgdHJhbnNmZXJhYmlsaXR5IG9mIFNBQnMgKGZvciBicm93c2Vycy4gbmVlZGVkIGZvciBGaXJlZm94KVxuICAgIC8vIGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vZm9ydW0vIyFtc2cvbW96aWxsYS5kZXYucGxhdGZvcm0vSUhrQlpsSEVUcEEvZHdzTU5jaFdFUUFKXG4gICAgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG5ldyBNZXNzYWdlQ2hhbm5lbCgpLnBvcnQxLnBvc3RNZXNzYWdlKG5ldyBTaGFyZWRBcnJheUJ1ZmZlcigxKSk7XG4gICAgfVxuXG4gICAgLy8gVGVzdCBmb3IgV2ViQXNzZW1ibHkgdGhyZWFkcyBjYXBhYmlsaXR5IChmb3IgYm90aCBicm93c2VycyBhbmQgTm9kZS5qcylcbiAgICAvLyBUaGlzIHR5cGVkIGFycmF5IGlzIGEgV2ViQXNzZW1ibHkgcHJvZ3JhbSBjb250YWluaW5nIHRocmVhZGVkIGluc3RydWN0aW9ucy5cbiAgICByZXR1cm4gV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMCwgOTcsIDExNSwgMTA5LCAxLCAwLCAgMCwgIDAsIDEsIDQsIDEsICA5NiwgMCwgICAwLCAgMywgMiwgMSwgIDAsIDUsXG4gICAgICA0LCAxLCAgMywgICAxLCAgIDEsIDEwLCAxMSwgMSwgOSwgMCwgNjUsIDAsICAyNTQsIDE2LCAyLCAwLCAyNiwgMTFcbiAgICBdKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmNvbnN0IGlzU2ltZFN1cHBvcnRlZCA9ICgpOiBib29sZWFuID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBUZXN0IGZvciBXZWJBc3NlbWJseSBTSU1EIGNhcGFiaWxpdHkgKGZvciBib3RoIGJyb3dzZXJzIGFuZCBOb2RlLmpzKVxuICAgIC8vIFRoaXMgdHlwZWQgYXJyYXkgaXMgYSBXZWJBc3NlbWJseSBwcm9ncmFtIGNvbnRhaW5pbmcgU0lNRCBpbnN0cnVjdGlvbnMuXG5cbiAgICAvLyBUaGUgYmluYXJ5IGRhdGEgaXMgZ2VuZXJhdGVkIGZyb20gdGhlIGZvbGxvd2luZyBjb2RlIGJ5IHdhdDJ3YXNtOlxuICAgIC8vXG4gICAgLy8gKG1vZHVsZVxuICAgIC8vICAgKHR5cGUgJHQwIChmdW5jKSlcbiAgICAvLyAgIChmdW5jICRmMCAodHlwZSAkdDApXG4gICAgLy8gICAgIChkcm9wXG4gICAgLy8gICAgICAgKGkzMng0LmRvdF9pMTZ4OF9zXG4gICAgLy8gICAgICAgICAoaTh4MTYuc3BsYXRcbiAgICAvLyAgICAgICAgICAgKGkzMi5jb25zdCAwKSlcbiAgICAvLyAgICAgICAgICh2MTI4LmNvbnN0IGkzMng0IDB4MDAwMDAwMDAgMHgwMDAwMDAwMCAweDAwMDAwMDAwIDB4MDAwMDAwMDApKSkpKVxuXG4gICAgcmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDAsICAgOTcsIDExNSwgMTA5LCAxLCAwLCAwLCAwLCAxLCA0LCAxLCA5NiwgMCwgMCwgMywgMiwgMSwgMCwgMTAsIDMwLCAxLCAgIDI4LCAgMCwgNjUsIDAsXG4gICAgICAyNTMsIDE1LCAyNTMsIDEyLCAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgIDAsIDAsIDAsIDAsIDAsIDAsIDAsICAwLCAgMjUzLCAxODYsIDEsIDI2LCAxMVxuICAgIF0pKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGluaXRpYWxpemVXZWJBc3NlbWJseSA9IGFzeW5jKGZsYWdzOiBFbnYuV2ViQXNzZW1ibHlGbGFncyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoaW5pdGlhbGl6ZWQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbiAgaWYgKGluaXRpYWxpemluZykge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVsdGlwbGUgY2FsbHMgdG8gXFwnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KClcXCcgZGV0ZWN0ZWQuJyk7XG4gIH1cbiAgaWYgKGFib3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZXZpb3VzIGNhbGwgdG8gXFwnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KClcXCcgZmFpbGVkLicpO1xuICB9XG5cbiAgaW5pdGlhbGl6aW5nID0gdHJ1ZTtcblxuICAvLyB3YXNtIGZsYWdzIGFyZSBhbHJlYWR5IGluaXRpYWxpemVkXG4gIGNvbnN0IHRpbWVvdXQgPSBmbGFncy5pbml0VGltZW91dCE7XG4gIGxldCBudW1UaHJlYWRzID0gZmxhZ3MubnVtVGhyZWFkcyE7XG5cbiAgLy8gZW5zdXJlIFNJTUQgaXMgc3VwcG9ydGVkXG4gIGlmICghaXNTaW1kU3VwcG9ydGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkFzc2VtYmx5IFNJTUQgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4nKTtcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIG11bHRpLXRocmVhZGluZyBpcyBzdXBwb3J0ZWRcbiAgY29uc3QgbXVsdGlUaHJlYWRTdXBwb3J0ZWQgPSBpc011bHRpVGhyZWFkU3VwcG9ydGVkKCk7XG4gIGlmIChudW1UaHJlYWRzID4gMSAmJiAhbXVsdGlUaHJlYWRTdXBwb3J0ZWQpIHtcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICFzZWxmLmNyb3NzT3JpZ2luSXNvbGF0ZWQpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ2Vudi53YXNtLm51bVRocmVhZHMgaXMgc2V0IHRvICcgKyBudW1UaHJlYWRzICtcbiAgICAgICAgICAnLCBidXQgdGhpcyB3aWxsIG5vdCB3b3JrIHVubGVzcyB5b3UgZW5hYmxlIGNyb3NzT3JpZ2luSXNvbGF0ZWQgbW9kZS4gJyArXG4gICAgICAgICAgJ1NlZSBodHRwczovL3dlYi5kZXYvY3Jvc3Mtb3JpZ2luLWlzb2xhdGlvbi1ndWlkZS8gZm9yIG1vcmUgaW5mby4nKTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ1dlYkFzc2VtYmx5IG11bHRpLXRocmVhZGluZyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LiAnICtcbiAgICAgICAgJ0ZhbGxpbmcgYmFjayB0byBzaW5nbGUtdGhyZWFkaW5nLicpO1xuXG4gICAgLy8gc2V0IGZsYWdzLm51bVRocmVhZHMgdG8gMSBzbyB0aGF0IE9ydEluaXQoKSB3aWxsIG5vdCBjcmVhdGUgYSBnbG9iYWwgdGhyZWFkIHBvb2wuXG4gICAgZmxhZ3MubnVtVGhyZWFkcyA9IG51bVRocmVhZHMgPSAxO1xuICB9XG5cbiAgY29uc3Qgd2FzbVBhdGhzID0gZmxhZ3Mud2FzbVBhdGhzO1xuICBjb25zdCB3YXNtUHJlZml4T3ZlcnJpZGUgPSB0eXBlb2Ygd2FzbVBhdGhzID09PSAnc3RyaW5nJyA/IHdhc21QYXRocyA6IHVuZGVmaW5lZDtcbiAgY29uc3QgbWpzUGF0aE92ZXJyaWRlRmxhZyA9ICh3YXNtUGF0aHMgYXMgRW52Lldhc21GaWxlUGF0aHMpPy5tanM7XG4gIGNvbnN0IG1qc1BhdGhPdmVycmlkZSA9IChtanNQYXRoT3ZlcnJpZGVGbGFnIGFzIFVSTCk/LmhyZWYgPz8gbWpzUGF0aE92ZXJyaWRlRmxhZztcbiAgY29uc3Qgd2FzbVBhdGhPdmVycmlkZUZsYWcgPSAod2FzbVBhdGhzIGFzIEVudi5XYXNtRmlsZVBhdGhzKT8ud2FzbTtcbiAgY29uc3Qgd2FzbVBhdGhPdmVycmlkZSA9ICh3YXNtUGF0aE92ZXJyaWRlRmxhZyBhcyBVUkwpPy5ocmVmID8/IHdhc21QYXRoT3ZlcnJpZGVGbGFnO1xuXG4gIGNvbnN0IFtvYmplY3RVcmwsIG9ydFdhc21GYWN0b3J5XSA9IChhd2FpdCBpbXBvcnRXYXNtTW9kdWxlKG1qc1BhdGhPdmVycmlkZSwgd2FzbVByZWZpeE92ZXJyaWRlLCBudW1UaHJlYWRzID4gMSkpO1xuXG4gIGxldCBpc1RpbWVvdXQgPSBmYWxzZTtcblxuICBjb25zdCB0YXNrczogQXJyYXk8UHJvbWlzZTx2b2lkPj4gPSBbXTtcblxuICAvLyBwcm9taXNlIGZvciB0aW1lb3V0XG4gIGlmICh0aW1lb3V0ID4gMCkge1xuICAgIHRhc2tzLnB1c2gobmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpc1RpbWVvdXQgPSB0cnVlO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9LCB0aW1lb3V0KTtcbiAgICB9KSk7XG4gIH1cblxuICAvLyBwcm9taXNlIGZvciBtb2R1bGUgaW5pdGlhbGl6YXRpb25cbiAgdGFza3MucHVzaChuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgY29uZmlnOiBQYXJ0aWFsPE9ydFdhc21Nb2R1bGU+ID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbnVtYmVyIG9mIHRocmVhZHMuIFdlYkFzc2VtYmx5IHdpbGwgY3JlYXRlIChNb2R1bGUubnVtVGhyZWFkcyAtIDEpIHdvcmtlcnMuIElmIGl0IGlzIDEsIG5vIHdvcmtlciB3aWxsIGJlXG4gICAgICAgKiBjcmVhdGVkLlxuICAgICAgICovXG4gICAgICBudW1UaHJlYWRzLFxuICAgICAgLyoqXG4gICAgICAgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGxvY2F0ZSB0aGUgV2ViQXNzZW1ibHkgZmlsZS4gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gdGhlIGZ1bGwgcGF0aCBvZiB0aGUgZmlsZS5cbiAgICAgICAqXG4gICAgICAgKiBTaW5jZSBFbXNjcmlwdGVuIDMuMS41OCwgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBmb3IgdGhlIC53YXNtIGZpbGUuXG4gICAgICAgKi9cbiAgICAgIGxvY2F0ZUZpbGU6IChmaWxlTmFtZSwgc2NyaXB0RGlyZWN0b3J5KSA9PiB3YXNtUGF0aE92ZXJyaWRlID8/ICh3YXNtUHJlZml4T3ZlcnJpZGUgPz8gc2NyaXB0RGlyZWN0b3J5KSArIGZpbGVOYW1lXG4gICAgfTtcblxuICAgIG9ydFdhc21GYWN0b3J5KGNvbmZpZykudGhlbihcbiAgICAgICAgLy8gd2FzbSBtb2R1bGUgaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5XG4gICAgICAgIG1vZHVsZSA9PiB7XG4gICAgICAgICAgaW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgIHdhc20gPSBtb2R1bGU7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIGlmIChvYmplY3RVcmwpIHtcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwob2JqZWN0VXJsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHdhc20gbW9kdWxlIGZhaWxlZCB0byBpbml0aWFsaXplXG4gICAgICAgICh3aGF0KSA9PiB7XG4gICAgICAgICAgaW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgICAgICAgYWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgcmVqZWN0KHdoYXQpO1xuICAgICAgICB9KTtcbiAgfSkpO1xuXG4gIGF3YWl0IFByb21pc2UucmFjZSh0YXNrcyk7XG5cbiAgaWYgKGlzVGltZW91dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgV2ViQXNzZW1ibHkgYmFja2VuZCBpbml0aWFsaXppbmcgZmFpbGVkIGR1ZSB0byB0aW1lb3V0OiAke3RpbWVvdXR9bXNgKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldEluc3RhbmNlID0gKCk6IE9ydFdhc21Nb2R1bGUgPT4ge1xuICBpZiAoaW5pdGlhbGl6ZWQgJiYgd2FzbSkge1xuICAgIHJldHVybiB3YXNtO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdXZWJBc3NlbWJseSBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0LicpO1xufTtcblxuZXhwb3J0IGNvbnN0IGRpc3Bvc2UgPSAoKTogdm9pZCA9PiB7XG4gIGlmIChpbml0aWFsaXplZCAmJiAhaW5pdGlhbGl6aW5nICYmICFhYm9ydGVkKSB7XG4gICAgLy8gVE9ETzogY3VycmVudGx5IFwiUFRocmVhZC50ZXJtaW5hdGVBbGxUaHJlYWRzKClcIiBpcyBub3QgZXhwb3NlZCBpbiB0aGUgd2FzbSBtb2R1bGUuXG4gICAgLy8gICAgICAgQW5kIHRoaXMgZnVuY3Rpb24gaXMgbm90IHlldCBjYWxsZWQgYnkgYW55IGNvZGUuXG4gICAgLy8gICAgICAgSWYgaXQgaXMgbmVlZGVkIGluIHRoZSBmdXR1cmUsIHdlIHNob3VsZCBleHBvc2UgaXQgaW4gdGhlIHdhc20gbW9kdWxlIGFuZCB1bmNvbW1lbnQgdGhlIGZvbGxvd2luZyBsaW5lLlxuXG4gICAgLy8gd2FzbT8uUFRocmVhZD8udGVybWluYXRlQWxsVGhyZWFkcygpO1xuICAgIHdhc20gPSB1bmRlZmluZWQ7XG5cbiAgICBpbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICBpbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIGFib3J0ZWQgPSB0cnVlO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge2dldEluc3RhbmNlfSBmcm9tICcuL3dhc20tZmFjdG9yeSc7XG5cbmV4cG9ydCBjb25zdCBhbGxvY1dhc21TdHJpbmcgPSAoZGF0YTogc3RyaW5nLCBhbGxvY3M6IG51bWJlcltdKTogbnVtYmVyID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG5cbiAgY29uc3QgZGF0YUxlbmd0aCA9IHdhc20ubGVuZ3RoQnl0ZXNVVEY4KGRhdGEpICsgMTtcbiAgY29uc3QgZGF0YU9mZnNldCA9IHdhc20uX21hbGxvYyhkYXRhTGVuZ3RoKTtcbiAgd2FzbS5zdHJpbmdUb1VURjgoZGF0YSwgZGF0YU9mZnNldCwgZGF0YUxlbmd0aCk7XG4gIGFsbG9jcy5wdXNoKGRhdGFPZmZzZXQpO1xuXG4gIHJldHVybiBkYXRhT2Zmc2V0O1xufTtcblxuaW50ZXJmYWNlIEV4dHJhT3B0aW9uc0hhbmRsZXIge1xuICAobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogdm9pZDtcbn1cblxuZXhwb3J0IGNvbnN0IGl0ZXJhdGVFeHRyYU9wdGlvbnMgPVxuICAgIChvcHRpb25zOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiwgcHJlZml4OiBzdHJpbmcsIHNlZW46IFdlYWtTZXQ8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+LFxuICAgICBoYW5kbGVyOiBFeHRyYU9wdGlvbnNIYW5kbGVyKTogdm9pZCA9PiB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2Vlbi5oYXMob3B0aW9ucykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NpcmN1bGFyIHJlZmVyZW5jZSBpbiBvcHRpb25zJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2Vlbi5hZGQob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmVudHJpZXMob3B0aW9ucykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSAocHJlZml4KSA/IHByZWZpeCArIGtleSA6IGtleTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBpdGVyYXRlRXh0cmFPcHRpb25zKHZhbHVlIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LCBuYW1lICsgJy4nLCBzZWVuLCBoYW5kbGVyKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBoYW5kbGVyKG5hbWUsIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgaGFuZGxlcihuYW1lLCAodmFsdWUpID8gJzEnIDogJzAnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGhhbmRsZSBleHRyYSBjb25maWcgdHlwZTogJHt0eXBlb2YgdmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbi8qKlxuICogY2hlY2sgd2ViIGFzc2VtYmx5IEFQSSdzIGxhc3QgZXJyb3IgYW5kIHRocm93IGVycm9yIGlmIGFueSBlcnJvciBvY2N1cnJlZC5cbiAqIEBwYXJhbSBtZXNzYWdlIGEgbWVzc2FnZSB1c2VkIHdoZW4gYW4gZXJyb3Igb2NjdXJyZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBjaGVja0xhc3RFcnJvciA9IChtZXNzYWdlOiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG5cbiAgY29uc3Qgc3RhY2sgPSB3YXNtLnN0YWNrU2F2ZSgpO1xuICB0cnkge1xuICAgIGNvbnN0IHBhcmFtc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYyg4KTtcbiAgICB3YXNtLl9PcnRHZXRMYXN0RXJyb3IocGFyYW1zT2Zmc2V0LCBwYXJhbXNPZmZzZXQgKyA0KTtcbiAgICBjb25zdCBlcnJvckNvZGUgPSB3YXNtLkhFQVAzMltwYXJhbXNPZmZzZXQgLyA0XTtcbiAgICBjb25zdCBlcnJvck1lc3NhZ2VQb2ludGVyID0gd2FzbS5IRUFQVTMyW3BhcmFtc09mZnNldCAvIDQgKyAxXTtcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvck1lc3NhZ2VQb2ludGVyID8gd2FzbS5VVEY4VG9TdHJpbmcoZXJyb3JNZXNzYWdlUG9pbnRlcikgOiAnJztcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bWVzc2FnZX0gRVJST1JfQ09ERTogJHtlcnJvckNvZGV9LCBFUlJPUl9NRVNTQUdFOiAke2Vycm9yTWVzc2FnZX1gKTtcbiAgfSBmaW5hbGx5IHtcbiAgICB3YXNtLnN0YWNrUmVzdG9yZShzdGFjayk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7SW5mZXJlbmNlU2Vzc2lvbn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHtnZXRJbnN0YW5jZX0gZnJvbSAnLi93YXNtLWZhY3RvcnknO1xuaW1wb3J0IHthbGxvY1dhc21TdHJpbmcsIGNoZWNrTGFzdEVycm9yLCBpdGVyYXRlRXh0cmFPcHRpb25zfSBmcm9tICcuL3dhc20tdXRpbHMnO1xuXG5leHBvcnQgY29uc3Qgc2V0UnVuT3B0aW9ucyA9IChvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBbbnVtYmVyLCBudW1iZXJbXV0gPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcbiAgbGV0IHJ1bk9wdGlvbnNIYW5kbGUgPSAwO1xuICBjb25zdCBhbGxvY3M6IG51bWJlcltdID0gW107XG5cbiAgY29uc3QgcnVuT3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB0cnkge1xuICAgIGlmIChvcHRpb25zPy5sb2dTZXZlcml0eUxldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJ1bk9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCA9IDI7ICAvLyBEZWZhdWx0IHRvIHdhcm5pbmdcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5sb2dTZXZlcml0eUxldmVsICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwpIHx8XG4gICAgICAgIG9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCA8IDAgfHwgb3B0aW9ucy5sb2dTZXZlcml0eUxldmVsID4gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWx9YCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnM/LmxvZ1ZlcmJvc2l0eUxldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJ1bk9wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWwgPSAwOyAgLy8gRGVmYXVsdCB0byAwXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbCAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIob3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7b3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbH1gKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucz8udGVybWluYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJ1bk9wdGlvbnMudGVybWluYXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHRhZ0RhdGFPZmZzZXQgPSAwO1xuICAgIGlmIChvcHRpb25zPy50YWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFnRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhvcHRpb25zLnRhZywgYWxsb2NzKTtcbiAgICB9XG5cbiAgICBydW5PcHRpb25zSGFuZGxlID0gd2FzbS5fT3J0Q3JlYXRlUnVuT3B0aW9ucyhcbiAgICAgICAgcnVuT3B0aW9ucy5sb2dTZXZlcml0eUxldmVsISwgcnVuT3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbCEsICEhcnVuT3B0aW9ucy50ZXJtaW5hdGUhLCB0YWdEYXRhT2Zmc2V0KTtcbiAgICBpZiAocnVuT3B0aW9uc0hhbmRsZSA9PT0gMCkge1xuICAgICAgY2hlY2tMYXN0RXJyb3IoJ0NhblxcJ3QgY3JlYXRlIHJ1biBvcHRpb25zLicpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zPy5leHRyYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpdGVyYXRlRXh0cmFPcHRpb25zKG9wdGlvbnMuZXh0cmEsICcnLCBuZXcgV2Vha1NldDxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oKSwgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3Qga2V5RGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhrZXksIGFsbG9jcyk7XG4gICAgICAgIGNvbnN0IHZhbHVlRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyh2YWx1ZSwgYWxsb2NzKTtcblxuICAgICAgICBpZiAod2FzbS5fT3J0QWRkUnVuQ29uZmlnRW50cnkocnVuT3B0aW9uc0hhbmRsZSwga2V5RGF0YU9mZnNldCwgdmFsdWVEYXRhT2Zmc2V0KSAhPT0gMCkge1xuICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBzZXQgYSBydW4gY29uZmlnIGVudHJ5OiAke2tleX0gLSAke3ZhbHVlfS5gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtydW5PcHRpb25zSGFuZGxlLCBhbGxvY3NdO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHJ1bk9wdGlvbnNIYW5kbGUgIT09IDApIHtcbiAgICAgIHdhc20uX09ydFJlbGVhc2VSdW5PcHRpb25zKHJ1bk9wdGlvbnNIYW5kbGUpO1xuICAgIH1cbiAgICBhbGxvY3MuZm9yRWFjaChhbGxvYyA9PiB3YXNtLl9mcmVlKGFsbG9jKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtJbmZlcmVuY2VTZXNzaW9ufSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQge2dldEluc3RhbmNlfSBmcm9tICcuL3dhc20tZmFjdG9yeSc7XG5pbXBvcnQge2FsbG9jV2FzbVN0cmluZywgY2hlY2tMYXN0RXJyb3IsIGl0ZXJhdGVFeHRyYU9wdGlvbnN9IGZyb20gJy4vd2FzbS11dGlscyc7XG5cbmNvbnN0IGdldEdyYXBoT3B0aW16YXRpb25MZXZlbCA9IChncmFwaE9wdGltaXphdGlvbkxldmVsOiBzdHJpbmd8dW5rbm93bik6IG51bWJlciA9PiB7XG4gIHN3aXRjaCAoZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCkge1xuICAgIGNhc2UgJ2Rpc2FibGVkJzpcbiAgICAgIHJldHVybiAwO1xuICAgIGNhc2UgJ2Jhc2ljJzpcbiAgICAgIHJldHVybiAxO1xuICAgIGNhc2UgJ2V4dGVuZGVkJzpcbiAgICAgIHJldHVybiAyO1xuICAgIGNhc2UgJ2FsbCc6XG4gICAgICByZXR1cm4gOTk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZ3JhcGggb3B0aW1pemF0aW9uIGxldmVsOiAke2dyYXBoT3B0aW1pemF0aW9uTGV2ZWx9YCk7XG4gIH1cbn07XG5cbmNvbnN0IGdldEV4ZWN1dGlvbk1vZGUgPSAoZXhlY3V0aW9uTW9kZTogJ3NlcXVlbnRpYWwnfCdwYXJhbGxlbCcpOiBudW1iZXIgPT4ge1xuICBzd2l0Y2ggKGV4ZWN1dGlvbk1vZGUpIHtcbiAgICBjYXNlICdzZXF1ZW50aWFsJzpcbiAgICAgIHJldHVybiAwO1xuICAgIGNhc2UgJ3BhcmFsbGVsJzpcbiAgICAgIHJldHVybiAxO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGV4ZWN1dGlvbiBtb2RlOiAke2V4ZWN1dGlvbk1vZGV9YCk7XG4gIH1cbn07XG5cbmNvbnN0IGFwcGVuZERlZmF1bHRPcHRpb25zID0gKG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiB2b2lkID0+IHtcbiAgaWYgKCFvcHRpb25zLmV4dHJhKSB7XG4gICAgb3B0aW9ucy5leHRyYSA9IHt9O1xuICB9XG4gIGlmICghb3B0aW9ucy5leHRyYS5zZXNzaW9uKSB7XG4gICAgb3B0aW9ucy5leHRyYS5zZXNzaW9uID0ge307XG4gIH1cbiAgY29uc3Qgc2Vzc2lvbiA9IG9wdGlvbnMuZXh0cmEuc2Vzc2lvbiBhcyBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICBpZiAoIXNlc3Npb24udXNlX29ydF9tb2RlbF9ieXRlc19kaXJlY3RseSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcbiAgICBzZXNzaW9uLnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHkgPSAnMSc7XG4gIH1cblxuICAvLyBpZiB1c2luZyBKU0VQIHdpdGggV2ViR1BVLCBhbHdheXMgZGlzYWJsZSBtZW1vcnkgcGF0dGVyblxuICBpZiAob3B0aW9ucy5leGVjdXRpb25Qcm92aWRlcnMgJiZcbiAgICAgIG9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzLnNvbWUoZXAgPT4gKHR5cGVvZiBlcCA9PT0gJ3N0cmluZycgPyBlcCA6IGVwLm5hbWUpID09PSAnd2ViZ3B1JykpIHtcbiAgICBvcHRpb25zLmVuYWJsZU1lbVBhdHRlcm4gPSBmYWxzZTtcbiAgfVxufTtcblxuY29uc3Qgc2V0RXhlY3V0aW9uUHJvdmlkZXJzID1cbiAgICAoc2Vzc2lvbk9wdGlvbnNIYW5kbGU6IG51bWJlciwgZXhlY3V0aW9uUHJvdmlkZXJzOiByZWFkb25seSBJbmZlcmVuY2VTZXNzaW9uLkV4ZWN1dGlvblByb3ZpZGVyQ29uZmlnW10sXG4gICAgIGFsbG9jczogbnVtYmVyW10pOiB2b2lkID0+IHtcbiAgICAgIGZvciAoY29uc3QgZXAgb2YgZXhlY3V0aW9uUHJvdmlkZXJzKSB7XG4gICAgICAgIGxldCBlcE5hbWUgPSB0eXBlb2YgZXAgPT09ICdzdHJpbmcnID8gZXAgOiBlcC5uYW1lO1xuXG4gICAgICAgIC8vIGNoZWNrIEVQIG5hbWVcbiAgICAgICAgc3dpdGNoIChlcE5hbWUpIHtcbiAgICAgICAgICBjYXNlICd3ZWJubic6XG4gICAgICAgICAgICBlcE5hbWUgPSAnV0VCTk4nO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29uc3Qgd2Vibm5PcHRpb25zID0gZXAgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgICAgICAgICAgICAvLyBjb25zdCBjb250ZXh0ID0gKHdlYm5uT3B0aW9ucyBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5OT3B0aW9uc1dpdGhNTENvbnRleHQpPy5jb250ZXh0O1xuICAgICAgICAgICAgICBjb25zdCBkZXZpY2VUeXBlID0gKHdlYm5uT3B0aW9ucyBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5OQ29udGV4dE9wdGlvbnMpPy5kZXZpY2VUeXBlO1xuICAgICAgICAgICAgICBjb25zdCBudW1UaHJlYWRzID0gKHdlYm5uT3B0aW9ucyBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5OQ29udGV4dE9wdGlvbnMpPy5udW1UaHJlYWRzO1xuICAgICAgICAgICAgICBjb25zdCBwb3dlclByZWZlcmVuY2UgPSAod2Vibm5PcHRpb25zIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5Db250ZXh0T3B0aW9ucyk/LnBvd2VyUHJlZmVyZW5jZTtcbiAgICAgICAgICAgICAgaWYgKGRldmljZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKCdkZXZpY2VUeXBlJywgYWxsb2NzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoZGV2aWNlVHlwZSwgYWxsb2NzKTtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0SW5zdGFuY2UoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KHNlc3Npb25PcHRpb25zSGFuZGxlLCBrZXlEYXRhT2Zmc2V0LCB2YWx1ZURhdGFPZmZzZXQpICE9PVxuICAgICAgICAgICAgICAgICAgICAwKSB7XG4gICAgICAgICAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdkZXZpY2VUeXBlJyAtICR7ZGV2aWNlVHlwZX0uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChudW1UaHJlYWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBKdXN0IGlnbm9yZSBpbnZhbGlkIHdlYm5uT3B0aW9ucy5udW1UaHJlYWRzLlxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRlZE51bVRocmVhZHMgPVxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIG51bVRocmVhZHMgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKG51bVRocmVhZHMpIHx8IG51bVRocmVhZHMgPCAwKSA/IDAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bVRocmVhZHM7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5RGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZygnbnVtVGhyZWFkcycsIGFsbG9jcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKHZhbGlkYXRlZE51bVRocmVhZHMudG9TdHJpbmcoKSwgYWxsb2NzKTtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0SW5zdGFuY2UoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KHNlc3Npb25PcHRpb25zSGFuZGxlLCBrZXlEYXRhT2Zmc2V0LCB2YWx1ZURhdGFPZmZzZXQpICE9PVxuICAgICAgICAgICAgICAgICAgICAwKSB7XG4gICAgICAgICAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdudW1UaHJlYWRzJyAtICR7bnVtVGhyZWFkc30uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChwb3dlclByZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKCdwb3dlclByZWZlcmVuY2UnLCBhbGxvY3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhwb3dlclByZWZlcmVuY2UsIGFsbG9jcyk7XG4gICAgICAgICAgICAgICAgaWYgKGdldEluc3RhbmNlKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShzZXNzaW9uT3B0aW9uc0hhbmRsZSwga2V5RGF0YU9mZnNldCwgdmFsdWVEYXRhT2Zmc2V0KSAhPT1cbiAgICAgICAgICAgICAgICAgICAgMCkge1xuICAgICAgICAgICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAncG93ZXJQcmVmZXJlbmNlJyAtICR7cG93ZXJQcmVmZXJlbmNlfS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3dlYmdwdSc6XG4gICAgICAgICAgICBlcE5hbWUgPSAnSlMnO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29uc3Qgd2ViZ3B1T3B0aW9ucyA9IGVwIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViR3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgICAgICAgICAgIGlmICh3ZWJncHVPcHRpb25zPy5wcmVmZXJyZWRMYXlvdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAod2ViZ3B1T3B0aW9ucy5wcmVmZXJyZWRMYXlvdXQgIT09ICdOQ0hXJyAmJiB3ZWJncHVPcHRpb25zLnByZWZlcnJlZExheW91dCAhPT0gJ05IV0MnKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByZWZlcnJlZExheW91dCBtdXN0IGJlIGVpdGhlciAnTkNIVycgb3IgJ05IV0MnOiAke3dlYmdwdU9wdGlvbnMucHJlZmVycmVkTGF5b3V0fWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBrZXlEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKCdwcmVmZXJyZWRMYXlvdXQnLCBhbGxvY3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyh3ZWJncHVPcHRpb25zLnByZWZlcnJlZExheW91dCwgYWxsb2NzKTtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0SW5zdGFuY2UoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KHNlc3Npb25PcHRpb25zSGFuZGxlLCBrZXlEYXRhT2Zmc2V0LCB2YWx1ZURhdGFPZmZzZXQpICE9PVxuICAgICAgICAgICAgICAgICAgICAwKSB7XG4gICAgICAgICAgICAgICAgICBjaGVja0xhc3RFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdwcmVmZXJyZWRMYXlvdXQnIC0gJHt3ZWJncHVPcHRpb25zLnByZWZlcnJlZExheW91dH0uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd3YXNtJzpcbiAgICAgICAgICBjYXNlICdjcHUnOlxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7ZXBOYW1lfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXBOYW1lRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhlcE5hbWUsIGFsbG9jcyk7XG4gICAgICAgIGlmIChnZXRJbnN0YW5jZSgpLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcihzZXNzaW9uT3B0aW9uc0hhbmRsZSwgZXBOYW1lRGF0YU9mZnNldCkgIT09IDApIHtcbiAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3QgYXBwZW5kIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtlcE5hbWV9LmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHNldFNlc3Npb25PcHRpb25zID0gKG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogW251bWJlciwgbnVtYmVyW11dID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGxldCBzZXNzaW9uT3B0aW9uc0hhbmRsZSA9IDA7XG4gIGNvbnN0IGFsbG9jczogbnVtYmVyW10gPSBbXTtcblxuICBjb25zdCBzZXNzaW9uT3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGFwcGVuZERlZmF1bHRPcHRpb25zKHNlc3Npb25PcHRpb25zKTtcblxuICB0cnkge1xuICAgIGNvbnN0IGdyYXBoT3B0aW1pemF0aW9uTGV2ZWwgPSBnZXRHcmFwaE9wdGltemF0aW9uTGV2ZWwoc2Vzc2lvbk9wdGlvbnMuZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCA/PyAnYWxsJyk7XG4gICAgY29uc3QgZXhlY3V0aW9uTW9kZSA9IGdldEV4ZWN1dGlvbk1vZGUoc2Vzc2lvbk9wdGlvbnMuZXhlY3V0aW9uTW9kZSA/PyAnc2VxdWVudGlhbCcpO1xuICAgIGNvbnN0IGxvZ0lkRGF0YU9mZnNldCA9XG4gICAgICAgIHR5cGVvZiBzZXNzaW9uT3B0aW9ucy5sb2dJZCA9PT0gJ3N0cmluZycgPyBhbGxvY1dhc21TdHJpbmcoc2Vzc2lvbk9wdGlvbnMubG9nSWQsIGFsbG9jcykgOiAwO1xuXG4gICAgY29uc3QgbG9nU2V2ZXJpdHlMZXZlbCA9IHNlc3Npb25PcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgPz8gMjsgIC8vIERlZmF1bHQgdG8gMiAtIHdhcm5pbmdcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobG9nU2V2ZXJpdHlMZXZlbCkgfHwgbG9nU2V2ZXJpdHlMZXZlbCA8IDAgfHwgbG9nU2V2ZXJpdHlMZXZlbCA+IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7bG9nU2V2ZXJpdHlMZXZlbH1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBsb2dWZXJib3NpdHlMZXZlbCA9IHNlc3Npb25PcHRpb25zLmxvZ1ZlcmJvc2l0eUxldmVsID8/IDA7ICAvLyBEZWZhdWx0IHRvIDAgLSB2ZXJib3NlXG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGxvZ1ZlcmJvc2l0eUxldmVsKSB8fCBsb2dWZXJib3NpdHlMZXZlbCA8IDAgfHwgbG9nVmVyYm9zaXR5TGV2ZWwgPiA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2xvZ1ZlcmJvc2l0eUxldmVsfWApO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGltaXplZE1vZGVsRmlsZVBhdGhPZmZzZXQgPSB0eXBlb2Ygc2Vzc2lvbk9wdGlvbnMub3B0aW1pemVkTW9kZWxGaWxlUGF0aCA9PT0gJ3N0cmluZycgP1xuICAgICAgICBhbGxvY1dhc21TdHJpbmcoc2Vzc2lvbk9wdGlvbnMub3B0aW1pemVkTW9kZWxGaWxlUGF0aCwgYWxsb2NzKSA6XG4gICAgICAgIDA7XG5cbiAgICBzZXNzaW9uT3B0aW9uc0hhbmRsZSA9IHdhc20uX09ydENyZWF0ZVNlc3Npb25PcHRpb25zKFxuICAgICAgICBncmFwaE9wdGltaXphdGlvbkxldmVsLCAhIXNlc3Npb25PcHRpb25zLmVuYWJsZUNwdU1lbUFyZW5hLCAhIXNlc3Npb25PcHRpb25zLmVuYWJsZU1lbVBhdHRlcm4sIGV4ZWN1dGlvbk1vZGUsXG4gICAgICAgICEhc2Vzc2lvbk9wdGlvbnMuZW5hYmxlUHJvZmlsaW5nLCAwLCBsb2dJZERhdGFPZmZzZXQsIGxvZ1NldmVyaXR5TGV2ZWwsIGxvZ1ZlcmJvc2l0eUxldmVsLFxuICAgICAgICBvcHRpbWl6ZWRNb2RlbEZpbGVQYXRoT2Zmc2V0KTtcbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnNIYW5kbGUgPT09IDApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKCdDYW5cXCd0IGNyZWF0ZSBzZXNzaW9uIG9wdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgaWYgKHNlc3Npb25PcHRpb25zLmV4ZWN1dGlvblByb3ZpZGVycykge1xuICAgICAgc2V0RXhlY3V0aW9uUHJvdmlkZXJzKHNlc3Npb25PcHRpb25zSGFuZGxlLCBzZXNzaW9uT3B0aW9ucy5leGVjdXRpb25Qcm92aWRlcnMsIGFsbG9jcyk7XG4gICAgfVxuXG4gICAgaWYgKHNlc3Npb25PcHRpb25zLmVuYWJsZUdyYXBoQ2FwdHVyZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIHNlc3Npb25PcHRpb25zLmVuYWJsZUdyYXBoQ2FwdHVyZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZW5hYmxlR3JhcGhDYXB0dXJlIG11c3QgYmUgYSBib29sZWFuIHZhbHVlOiAke3Nlc3Npb25PcHRpb25zLmVuYWJsZUdyYXBoQ2FwdHVyZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoJ2VuYWJsZUdyYXBoQ2FwdHVyZScsIGFsbG9jcyk7XG4gICAgICBjb25zdCB2YWx1ZURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoc2Vzc2lvbk9wdGlvbnMuZW5hYmxlR3JhcGhDYXB0dXJlLnRvU3RyaW5nKCksIGFsbG9jcyk7XG4gICAgICBpZiAod2FzbS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KHNlc3Npb25PcHRpb25zSGFuZGxlLCBrZXlEYXRhT2Zmc2V0LCB2YWx1ZURhdGFPZmZzZXQpICE9PSAwKSB7XG4gICAgICAgIGNoZWNrTGFzdEVycm9yKFxuICAgICAgICAgICAgYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAnZW5hYmxlR3JhcGhDYXB0dXJlJyAtICR7c2Vzc2lvbk9wdGlvbnMuZW5hYmxlR3JhcGhDYXB0dXJlfS5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnMuZnJlZURpbWVuc2lvbk92ZXJyaWRlcykge1xuICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHNlc3Npb25PcHRpb25zLmZyZWVEaW1lbnNpb25PdmVycmlkZXMpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlIG5hbWUgbXVzdCBiZSBhIHN0cmluZzogJHtuYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlIHZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcjogJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKG5hbWUsIGFsbG9jcyk7XG4gICAgICAgIGlmICh3YXNtLl9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGUoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIG5hbWVPZmZzZXQsIHZhbHVlKSAhPT0gMCkge1xuICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBzZXQgYSBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZTogJHtuYW1lfSAtICR7dmFsdWV9LmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNlc3Npb25PcHRpb25zLmV4dHJhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGl0ZXJhdGVFeHRyYU9wdGlvbnMoc2Vzc2lvbk9wdGlvbnMuZXh0cmEsICcnLCBuZXcgV2Vha1NldDxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oKSwgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3Qga2V5RGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhrZXksIGFsbG9jcyk7XG4gICAgICAgIGNvbnN0IHZhbHVlRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyh2YWx1ZSwgYWxsb2NzKTtcblxuICAgICAgICBpZiAod2FzbS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KHNlc3Npb25PcHRpb25zSGFuZGxlLCBrZXlEYXRhT2Zmc2V0LCB2YWx1ZURhdGFPZmZzZXQpICE9PSAwKSB7XG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAke2tleX0gLSAke3ZhbHVlfS5gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtzZXNzaW9uT3B0aW9uc0hhbmRsZSwgYWxsb2NzXTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChzZXNzaW9uT3B0aW9uc0hhbmRsZSAhPT0gMCkge1xuICAgICAgd2FzbS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKHNlc3Npb25PcHRpb25zSGFuZGxlKTtcbiAgICB9XG4gICAgYWxsb2NzLmZvckVhY2goYWxsb2MgPT4gd2FzbS5fZnJlZShhbGxvYykpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG4vLyBhIGR1bW15IHR5cGUgZGVjbGFyYXRpb24gZm9yIEZsb2F0MTZBcnJheSBpbiBjYXNlIGFueSBwb2x5ZmlsbCBpcyBhdmFpbGFibGUuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24sIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgY29uc3QgRmxvYXQxNkFycmF5OiBhbnk7XG59XG5cbi8vIFRoaXMgZmlsZSBpbmNsdWRlcyBjb21tb24gZGVmaW5pdGlvbnMuIFRoZXkgZG8gTk9UIGhhdmUgZGVwZW5kZW5jeSBvbiB0aGUgV2ViQXNzZW1ibHkgaW5zdGFuY2UuXG5cbi8qKlxuICogQ29waWVkIGZyb20gT05OWCBkZWZpbml0aW9uLiBVc2UgdGhpcyB0byBkcm9wIGRlcGVuZGVuY3kgJ29ubnhfcHJvdG8nIHRvIGRlY3JlYXNlIGNvbXBpbGVkIC5qcyBmaWxlIHNpemUuXG4gKi9cbmV4cG9ydCBjb25zdCBlbnVtIERhdGFUeXBlIHtcbiAgdW5kZWZpbmVkID0gMCxcbiAgZmxvYXQgPSAxLFxuICB1aW50OCA9IDIsXG4gIGludDggPSAzLFxuICB1aW50MTYgPSA0LFxuICBpbnQxNiA9IDUsXG4gIGludDMyID0gNixcbiAgaW50NjQgPSA3LFxuICBzdHJpbmcgPSA4LFxuICBib29sID0gOSxcbiAgZmxvYXQxNiA9IDEwLFxuICBkb3VibGUgPSAxMSxcbiAgdWludDMyID0gMTIsXG4gIHVpbnQ2NCA9IDEzLFxuICBjb21wbGV4NjQgPSAxNCxcbiAgY29tcGxleDEyOCA9IDE1LFxuICBiZmxvYXQxNiA9IDE2XG59XG5cbi8qKlxuICogTWFwIHN0cmluZyB0ZW5zb3IgZGF0YSB0byBlbnVtIHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bSA9ICh0eXBlOiBzdHJpbmcpOiBEYXRhVHlwZSA9PiB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2ludDgnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLmludDg7XG4gICAgY2FzZSAndWludDgnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLnVpbnQ4O1xuICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLmJvb2w7XG4gICAgY2FzZSAnaW50MTYnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLmludDE2O1xuICAgIGNhc2UgJ3VpbnQxNic6XG4gICAgICByZXR1cm4gRGF0YVR5cGUudWludDE2O1xuICAgIGNhc2UgJ2ludDMyJzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5pbnQzMjtcbiAgICBjYXNlICd1aW50MzInOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLnVpbnQzMjtcbiAgICBjYXNlICdmbG9hdDE2JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5mbG9hdDE2O1xuICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLmZsb2F0O1xuICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLmRvdWJsZTtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLnN0cmluZztcbiAgICBjYXNlICdpbnQ2NCc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuaW50NjQ7XG4gICAgY2FzZSAndWludDY0JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS51aW50NjQ7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBNYXAgZW51bSB2YWx1ZSB0byBzdHJpbmcgdGVuc29yIGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nID0gKHR5cGVQcm90bzogRGF0YVR5cGUpOiBUZW5zb3IuVHlwZSA9PiB7XG4gIHN3aXRjaCAodHlwZVByb3RvKSB7XG4gICAgY2FzZSBEYXRhVHlwZS5pbnQ4OlxuICAgICAgcmV0dXJuICdpbnQ4JztcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQ4OlxuICAgICAgcmV0dXJuICd1aW50OCc7XG4gICAgY2FzZSBEYXRhVHlwZS5ib29sOlxuICAgICAgcmV0dXJuICdib29sJztcbiAgICBjYXNlIERhdGFUeXBlLmludDE2OlxuICAgICAgcmV0dXJuICdpbnQxNic7XG4gICAgY2FzZSBEYXRhVHlwZS51aW50MTY6XG4gICAgICByZXR1cm4gJ3VpbnQxNic7XG4gICAgY2FzZSBEYXRhVHlwZS5pbnQzMjpcbiAgICAgIHJldHVybiAnaW50MzInO1xuICAgIGNhc2UgRGF0YVR5cGUudWludDMyOlxuICAgICAgcmV0dXJuICd1aW50MzInO1xuICAgIGNhc2UgRGF0YVR5cGUuZmxvYXQxNjpcbiAgICAgIHJldHVybiAnZmxvYXQxNic7XG4gICAgY2FzZSBEYXRhVHlwZS5mbG9hdDpcbiAgICAgIHJldHVybiAnZmxvYXQzMic7XG4gICAgY2FzZSBEYXRhVHlwZS5kb3VibGU6XG4gICAgICByZXR1cm4gJ2Zsb2F0NjQnO1xuICAgIGNhc2UgRGF0YVR5cGUuc3RyaW5nOlxuICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgIGNhc2UgRGF0YVR5cGUuaW50NjQ6XG4gICAgICByZXR1cm4gJ2ludDY0JztcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQ2NDpcbiAgICAgIHJldHVybiAndWludDY0JztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0eXBlUHJvdG99YCk7XG4gIH1cbn07XG5cbi8qKlxuICogZ2V0IHRlbnNvciBlbGVtZW50IHNpemUgaW4gYnl0ZXMgYnkgdGhlIGdpdmVuIGRhdGEgdHlwZVxuICogQHJldHVybnMgc2l6ZSBpbiBpbnRlZ2VyIG9yIHVuZGVmaW5lZCBpZiB0aGUgZGF0YSB0eXBlIGlzIG5vdCBzdXBwb3J0ZWRcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFRlbnNvckVsZW1lbnRTaXplID0gKGRhdGVUeXBlOiBudW1iZXIpOiBudW1iZXJ8XG4gICAgdW5kZWZpbmVkID0+IFt1bmRlZmluZWQsIDQsIDEsIDEsIDIsIDIsIDQsIDgsIHVuZGVmaW5lZCwgMSwgMiwgOCwgNCwgOCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZF1bZGF0ZVR5cGVdO1xuXG4vKipcbiAqIGdldCB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvciBieSB0aGUgZ2l2ZW4gdGVuc29yIHR5cGVcbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3RvciA9ICh0eXBlOiBUZW5zb3IuVHlwZSk6IEZsb2F0MzJBcnJheUNvbnN0cnVjdG9yfFVpbnQ4QXJyYXlDb25zdHJ1Y3RvcnxcbiAgICBJbnQ4QXJyYXlDb25zdHJ1Y3RvcnxVaW50MTZBcnJheUNvbnN0cnVjdG9yfEludDE2QXJyYXlDb25zdHJ1Y3RvcnxJbnQzMkFycmF5Q29uc3RydWN0b3J8QmlnSW50NjRBcnJheUNvbnN0cnVjdG9yfFxuICAgIFVpbnQ4QXJyYXlDb25zdHJ1Y3RvcnxGbG9hdDY0QXJyYXlDb25zdHJ1Y3RvcnxVaW50MzJBcnJheUNvbnN0cnVjdG9yfEJpZ1VpbnQ2NEFycmF5Q29uc3RydWN0b3IgPT4ge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2Zsb2F0MTYnOlxuICAgICAgICAgIC8vIGFsbG93IEZsb2F0MTZBcnJheSBwb2x5ZmlsbC5cbiAgICAgICAgICByZXR1cm4gdHlwZW9mIEZsb2F0MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgRmxvYXQxNkFycmF5LmZyb20gPyBGbG9hdDE2QXJyYXkgOiBVaW50MTZBcnJheTtcbiAgICAgICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICAgICAgcmV0dXJuIEZsb2F0MzJBcnJheTtcbiAgICAgICAgY2FzZSAndWludDgnOlxuICAgICAgICAgIHJldHVybiBVaW50OEFycmF5O1xuICAgICAgICBjYXNlICdpbnQ4JzpcbiAgICAgICAgICByZXR1cm4gSW50OEFycmF5O1xuICAgICAgICBjYXNlICd1aW50MTYnOlxuICAgICAgICAgIHJldHVybiBVaW50MTZBcnJheTtcbiAgICAgICAgY2FzZSAnaW50MTYnOlxuICAgICAgICAgIHJldHVybiBJbnQxNkFycmF5O1xuICAgICAgICBjYXNlICdpbnQzMic6XG4gICAgICAgICAgcmV0dXJuIEludDMyQXJyYXk7XG4gICAgICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgICAgIHJldHVybiBVaW50OEFycmF5O1xuICAgICAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgICAgICByZXR1cm4gRmxvYXQ2NEFycmF5O1xuICAgICAgICBjYXNlICd1aW50MzInOlxuICAgICAgICAgIHJldHVybiBVaW50MzJBcnJheTtcbiAgICAgICAgY2FzZSAnaW50NjQnOlxuICAgICAgICAgIHJldHVybiBCaWdJbnQ2NEFycmF5O1xuICAgICAgICBjYXNlICd1aW50NjQnOlxuICAgICAgICAgIHJldHVybiBCaWdVaW50NjRBcnJheTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGU6ICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICB9O1xuXG4vKipcbiAqIE1hcCBzdHJpbmcgbG9nIGxldmVsIHRvIGludGVnZXIgdmFsdWVcbiAqL1xuZXhwb3J0IGNvbnN0IGxvZ0xldmVsU3RyaW5nVG9FbnVtID0gKGxvZ0xldmVsPzogJ3ZlcmJvc2UnfCdpbmZvJ3wnd2FybmluZyd8J2Vycm9yJ3wnZmF0YWwnKTogbnVtYmVyID0+IHtcbiAgc3dpdGNoIChsb2dMZXZlbCkge1xuICAgIGNhc2UgJ3ZlcmJvc2UnOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSAnaW5mbyc6XG4gICAgICByZXR1cm4gMTtcbiAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgIHJldHVybiAyO1xuICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgIHJldHVybiAzO1xuICAgIGNhc2UgJ2ZhdGFsJzpcbiAgICAgIHJldHVybiA0O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7bG9nTGV2ZWx9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gdGVuc29yIHR5cGUgaXMgc3VwcG9ydGVkIGJ5IEdQVSBidWZmZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGlzR3B1QnVmZmVyU3VwcG9ydGVkVHlwZSA9ICh0eXBlOiBUZW5zb3IuVHlwZSk6IHR5cGUgaXMgVGVuc29yLkdwdUJ1ZmZlckRhdGFUeXBlcyA9PiB0eXBlID09PSAnZmxvYXQzMicgfHxcbiAgICB0eXBlID09PSAnZmxvYXQxNicgfHwgdHlwZSA9PT0gJ2ludDMyJyB8fCB0eXBlID09PSAnaW50NjQnIHx8IHR5cGUgPT09ICd1aW50MzInIHx8IHR5cGUgPT09ICd1aW50OCcgfHxcbiAgICB0eXBlID09PSAnYm9vbCc7XG5cbi8qKlxuICogTWFwIHN0cmluZyBkYXRhIGxvY2F0aW9uIHRvIGludGVnZXIgdmFsdWVcbiAqL1xuZXhwb3J0IGNvbnN0IGRhdGFMb2NhdGlvblN0cmluZ1RvRW51bSA9IChsb2NhdGlvbjogVGVuc29yLkRhdGFMb2NhdGlvbik6IG51bWJlciA9PiB7XG4gIHN3aXRjaCAobG9jYXRpb24pIHtcbiAgICBjYXNlICdub25lJzpcbiAgICAgIHJldHVybiAwO1xuICAgIGNhc2UgJ2NwdSc6XG4gICAgICByZXR1cm4gMTtcbiAgICBjYXNlICdjcHUtcGlubmVkJzpcbiAgICAgIHJldHVybiAyO1xuICAgIGNhc2UgJ3RleHR1cmUnOlxuICAgICAgcmV0dXJuIDM7XG4gICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XG4gICAgICByZXR1cm4gNDtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIGxvY2F0aW9uOiAke2xvY2F0aW9ufWApO1xuICB9XG59O1xuXG4vKipcbiAqIE1hcCBpbnRlZ2VyIGRhdGEgbG9jYXRpb24gdG8gc3RyaW5nIHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCBkYXRhTG9jYXRpb25FbnVtVG9TdHJpbmcgPSAobG9jYXRpb246IG51bWJlcik6IFRlbnNvci5EYXRhTG9jYXRpb258dW5kZWZpbmVkID0+XG4gICAgKFsnbm9uZScsICdjcHUnLCAnY3B1LXBpbm5lZCcsICd0ZXh0dXJlJywgJ2dwdS1idWZmZXInXSBhcyBjb25zdClbbG9jYXRpb25dO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge2lzTm9kZX0gZnJvbSAnLi93YXNtLXV0aWxzLWVudic7XG5cbi8qKlxuICogTG9hZCBhIGZpbGUgaW50byBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIGZpbGUgLSB0aGUgZmlsZSB0byBsb2FkLiBDYW4gYmUgYSBVUkwvcGF0aCwgYSBCbG9iLCBhbiBBcnJheUJ1ZmZlciwgb3IgYSBVaW50OEFycmF5LlxuICogQHJldHVybnMgYSBVaW50OEFycmF5IGNvbnRhaW5pbmcgdGhlIGZpbGUgZGF0YS5cbiAqL1xuZXhwb3J0IGNvbnN0IGxvYWRGaWxlID0gYXN5bmMoZmlsZTogc3RyaW5nfEJsb2J8QXJyYXlCdWZmZXJMaWtlfFVpbnQ4QXJyYXkpOiBQcm9taXNlPFVpbnQ4QXJyYXk+ID0+IHtcbiAgaWYgKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChpc05vZGUpIHtcbiAgICAgIC8vIGxvYWQgZmlsZSBpbnRvIEFycmF5QnVmZmVyIGluIE5vZGUuanNcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHtyZWFkRmlsZX0gPSByZXF1aXJlKCdub2RlOmZzL3Byb21pc2VzJyk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShhd2FpdCByZWFkRmlsZShmaWxlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLmNvZGUgPT09ICdFUlJfRlNfRklMRV9UT09fTEFSR0UnKSB7XG4gICAgICAgICAgLy8gZmlsZSBpcyB0b28gbGFyZ2UsIHVzZSBmcy5jcmVhdGVSZWFkU3RyZWFtIGluc3RlYWRcbiAgICAgICAgICBjb25zdCB7Y3JlYXRlUmVhZFN0cmVhbX0gPSByZXF1aXJlKCdub2RlOmZzJyk7XG4gICAgICAgICAgY29uc3Qgc3RyZWFtID0gY3JlYXRlUmVhZFN0cmVhbShmaWxlKTtcbiAgICAgICAgICBjb25zdCBjaHVua3M6IFVpbnQ4QXJyYXlbXSA9IFtdO1xuICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShCdWZmZXIuY29uY2F0KGNodW5rcykpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxvYWQgZmlsZSBpbnRvIEFycmF5QnVmZmVyIGluIGJyb3dzZXJzXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGZpbGUpO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBsb2FkIGV4dGVybmFsIGRhdGEgZmlsZTogJHtmaWxlfWApO1xuICAgICAgfVxuICAgICAgY29uc3QgY29udGVudExlbmd0aEhlYWRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LUxlbmd0aCcpO1xuICAgICAgY29uc3QgZmlsZVNpemUgPSBjb250ZW50TGVuZ3RoSGVhZGVyID8gcGFyc2VJbnQoY29udGVudExlbmd0aEhlYWRlciwgMTApIDogMDtcbiAgICAgIGlmIChmaWxlU2l6ZSA8IDEwNzM3NDE4MjQgLyogMUdCICovKSB7XG4gICAgICAgIC8vIHdoZW4gQ29udGVudC1MZW5ndGggaGVhZGVyIGlzIG5vdCBzZXQsIHdlIGNhbm5vdCBkZXRlcm1pbmUgdGhlIGZpbGUgc2l6ZS4gV2UgYXNzdW1lIGl0IGlzIHNtYWxsIGVub3VnaCB0b1xuICAgICAgICAvLyBsb2FkIGludG8gbWVtb3J5LlxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmaWxlIGlzIHRvbyBsYXJnZSwgdXNlIHN0cmVhbSBpbnN0ZWFkXG4gICAgICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGxvYWQgZXh0ZXJuYWwgZGF0YSBmaWxlOiAke2ZpbGV9LCBubyByZXNwb25zZSBib2R5LmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG5cbiAgICAgICAgbGV0IGJ1ZmZlcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyB0cnkgdG8gY3JlYXRlIEFycmF5QnVmZmVyIGRpcmVjdGx5XG4gICAgICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGZpbGVTaXplKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUmFuZ2VFcnJvcikge1xuICAgICAgICAgICAgLy8gdXNlIFdlYkFzc2VtYmx5IE1lbW9yeSB0byBhbGxvY2F0ZSBsYXJnZXIgQXJyYXlCdWZmZXJcbiAgICAgICAgICAgIGNvbnN0IHBhZ2VzID0gTWF0aC5jZWlsKGZpbGVTaXplIC8gNjU1MzYpO1xuICAgICAgICAgICAgYnVmZmVyID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDogcGFnZXMsIG1heGltdW06IHBhZ2VzfSkuYnVmZmVyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3Qge2RvbmUsIHZhbHVlfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjaHVua1NpemUgPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBvZmZzZXQsIGNodW5rU2l6ZSk7XG4gICAgICAgICAgY2h1bmsuc2V0KHZhbHVlKTtcbiAgICAgICAgICBvZmZzZXQgKz0gY2h1bmtTaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIsIDAsIGZpbGVTaXplKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSBlbHNlIGlmIChmaWxlIGluc3RhbmNlb2YgQmxvYikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShhd2FpdCBmaWxlLmFycmF5QnVmZmVyKCkpO1xuICB9IGVsc2UgaWYgKGZpbGUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGZpbGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGZpbGUpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0Vudn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHtsb2dMZXZlbFN0cmluZ1RvRW51bX0gZnJvbSAnLi4vd2FzbS1jb21tb24nO1xuXG50eXBlIExvZ0xldmVsID0gTm9uTnVsbGFibGU8RW52Wydsb2dMZXZlbCddPjtcbnR5cGUgTWVzc2FnZVN0cmluZyA9IHN0cmluZztcbnR5cGUgTWVzc2FnZUZ1bmN0aW9uID0gKCkgPT4gc3RyaW5nO1xudHlwZSBNZXNzYWdlID0gTWVzc2FnZVN0cmluZ3xNZXNzYWdlRnVuY3Rpb247XG5cbmNvbnN0IGxvZ0xldmVsUHJlZml4ID0gWydWJywgJ0knLCAnVycsICdFJywgJ0YnXTtcblxuY29uc3QgZG9Mb2cgPSAobGV2ZWw6IG51bWJlciwgbWVzc2FnZTogc3RyaW5nKTogdm9pZCA9PiB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gIGNvbnNvbGUubG9nKGBbJHtsb2dMZXZlbFByZWZpeFtsZXZlbF19LCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfV0ke21lc3NhZ2V9YCk7XG59O1xuXG5sZXQgY29uZmlnTG9nTGV2ZWw6IExvZ0xldmVsfHVuZGVmaW5lZDtcbmxldCBkZWJ1ZzogYm9vbGVhbnx1bmRlZmluZWQ7XG5cbmV4cG9ydCBjb25zdCBjb25maWd1cmVMb2dnZXIgPSAoJGNvbmZpZ0xvZ0xldmVsOiBMb2dMZXZlbCwgJGRlYnVnOiBib29sZWFuKTogdm9pZCA9PiB7XG4gIGNvbmZpZ0xvZ0xldmVsID0gJGNvbmZpZ0xvZ0xldmVsO1xuICBkZWJ1ZyA9ICRkZWJ1Zztcbn07XG5cbi8qKlxuICogQSBzaW1wbGUgbG9nZ2luZyB1dGlsaXR5IHRvIGxvZyBtZXNzYWdlcyB0byB0aGUgY29uc29sZS5cbiAqL1xuZXhwb3J0IGNvbnN0IExPRyA9IChsb2dMZXZlbDogTG9nTGV2ZWwsIG1zZzogTWVzc2FnZSk6IHZvaWQgPT4ge1xuICBjb25zdCBtZXNzYWdlTGV2ZWwgPSBsb2dMZXZlbFN0cmluZ1RvRW51bShsb2dMZXZlbCk7XG4gIGNvbnN0IGNvbmZpZ0xldmVsID0gbG9nTGV2ZWxTdHJpbmdUb0VudW0oY29uZmlnTG9nTGV2ZWwpO1xuICBpZiAobWVzc2FnZUxldmVsID49IGNvbmZpZ0xldmVsKSB7XG4gICAgZG9Mb2cobWVzc2FnZUxldmVsLCB0eXBlb2YgbXNnID09PSAnZnVuY3Rpb24nID8gbXNnKCkgOiBtc2cpO1xuICB9XG59O1xuXG4vKipcbiAqIEEgc2ltcGxlIGxvZ2dpbmcgdXRpbGl0eSB0byBsb2cgbWVzc2FnZXMgdG8gdGhlIGNvbnNvbGUuIE9ubHkgbG9ncyB3aGVuIGRlYnVnIGlzIGVuYWJsZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBMT0dfREVCVUc6IHR5cGVvZiBMT0cgPSAoLi4uYXJnczogUGFyYW1ldGVyczx0eXBlb2YgTE9HPikgPT4ge1xuICBpZiAoZGVidWcpIHtcbiAgICBMT0coLi4uYXJncyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQge3RlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3Rvcn0gZnJvbSAnLi4vd2FzbS1jb21tb24nO1xuXG5leHBvcnQgY29uc3QgY3JlYXRlVmlldyA9IChkYXRhQnVmZmVyOiBBcnJheUJ1ZmZlciwgdHlwZTogVGVuc29yLlR5cGUpOiBJbnQzMkFycmF5fFVpbnQzMkFycmF5fEJpZ0ludDY0QXJyYXl8XG4gICAgQmlnVWludDY0QXJyYXl8VWludDhBcnJheXxGbG9hdDMyQXJyYXl8RmxvYXQ2NEFycmF5fEludDhBcnJheXxJbnQxNkFycmF5fFVpbnQxNkFycmF5ID0+XG4gICAgICAgIG5ldyAodGVuc29yVHlwZVRvVHlwZWRBcnJheUNvbnN0cnVjdG9yKHR5cGUpKShkYXRhQnVmZmVyKTtcblxuLyoqXG4gKiBhIFRlbnNvclZpZXcgZG9lcyBub3Qgb3duIHRoZSBkYXRhLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvclZpZXcge1xuICByZWFkb25seSBkYXRhOiBudW1iZXI7XG4gIHJlYWRvbmx5IGRhdGFUeXBlOiBudW1iZXI7XG4gIHJlYWRvbmx5IGRpbXM6IHJlYWRvbmx5IG51bWJlcltdO1xuXG4gIC8qKlxuICAgKiBnZXQgYSBGbG9hdDMyQXJyYXkgZGF0YSB2aWV3IG9mIHRoZSB0ZW5zb3IgZGF0YS4gdGVuc29yIGRhdGEgbXVzdCBiZSBvbiBDUFUuXG4gICAqL1xuICBnZXRGbG9hdDMyQXJyYXkoKTogRmxvYXQzMkFycmF5O1xuXG4gIC8qKlxuICAgKiBnZXQgYSBCaWdJbnQ2NEFycmF5IGRhdGEgdmlldyBvZiB0aGUgdGVuc29yIGRhdGEuIHRlbnNvciBkYXRhIG11c3QgYmUgb24gQ1BVLlxuICAgKi9cbiAgZ2V0QmlnSW50NjRBcnJheSgpOiBCaWdJbnQ2NEFycmF5O1xuXG4gIC8qKlxuICAgKiBnZXQgYSBJbnQzMkFycmF5IGRhdGEgdmlldyBvZiB0aGUgdGVuc29yIGRhdGEuIHRlbnNvciBkYXRhIG11c3QgYmUgb24gQ1BVLlxuICAgKi9cbiAgZ2V0SW50MzJBcnJheSgpOiBJbnQzMkFycmF5O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSBuZXcgdGVuc29yIHZpZXcgd2l0aCB0aGUgc2FtZSBkYXRhIGJ1dCBkaWZmZXJlbnQgZGltZW5zaW9ucy5cbiAgICovXG4gIHJlc2hhcGUobmV3RGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBUZW5zb3JWaWV3O1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uL3RlbnNvci12aWV3JztcblxuaW1wb3J0IHtTaGFkZXJIZWxwZXJ9IGZyb20gJy4vb3BzL2NvbW1vbic7XG5cbmV4cG9ydCB0eXBlIFNlc3Npb25TdGF0ZSA9ICdkZWZhdWx0J3wnY2FwdHVyaW5nJ3wncmVwbGF5aW5nJztcblxuZXhwb3J0IGVudW0gR3B1RGF0YVR5cGUge1xuICBkZWZhdWx0ID0gMCxcbiAgdXBsb2FkID0gMSxcbiAgcHJvZmlsZSA9IDJcbn1cbmV4cG9ydCB0eXBlIEdwdURhdGFJZCA9IG51bWJlcjtcblxuZXhwb3J0IHR5cGUgR3B1QXJjaGl0ZWN0dXJlID0gJ2FtcGVyZSc7XG5leHBvcnQgdHlwZSBHcHVWZW5kb3IgPSAnYW1kJ3wnaW50ZWwnfCdudmlkaWEnO1xuZXhwb3J0IGludGVyZmFjZSBBZGFwdGVySW5mbyB7XG4gIGlzQXJjaGl0ZWN0dXJlOiAoYXJjaGl0ZWN0dXJlOiBHcHVBcmNoaXRlY3R1cmUpID0+IGJvb2xlYW47XG4gIGlzVmVuZG9yOiAodmVuZG9yOiBHcHVWZW5kb3IpID0+IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3B1RGF0YSB7XG4gIHR5cGU6IEdwdURhdGFUeXBlO1xuICBpZDogR3B1RGF0YUlkO1xuICBidWZmZXI6IEdQVUJ1ZmZlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JJbmZvIHtcbiAgZGltczogcmVhZG9ubHkgbnVtYmVyW107XG4gIGRhdGFUeXBlOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvZ3JhbVVuaWZvcm0ge1xuICB0eXBlOiBEYXRhVHlwZTtcbiAgZGF0YTogbnVtYmVyfHJlYWRvbmx5IG51bWJlcltdO1xufVxuXG5leHBvcnQgdHlwZSBQcm9ncmFtVW5pZm9ybVZhcmlhYmxlSW5mbyA9IFt0eXBlOiBEYXRhVHlwZSwgbGVuZ3RoOiBudW1iZXJdO1xuXG4vKipcbiAqIFJlcHJlc2VudCB0aGUgZGVwZW5kZW5jeSBvZiBhIHByb2dyYW0gb24gYSBzcGVjaWZpYyBpbnB1dCB0ZW5zb3IuXG4gKlxuICogLSAnbm9uZSc6IHRoZSBzaGFkZXIvdW5pZm9ybSBkb2VzIG5vdCBkZXBlbmQgb24gdGhpcyBpbnB1dCdzIGluZm9cbiAqIC0gJ3R5cGUnOiB0aGUgc2hhZGVyL3VuaWZvcm0gZGVwZW5kcyBvbiBkYXRhIHR5cGUgb2YgdGhpcyBpbnB1dFxuICogLSAncmFuayc6IHRoZSBzaGFkZXIvdW5pZm9ybSBkZXBlbmRzIG9uIGRhdGEgdHlwZSBhbmQgdGhlIHJhbmsgb2YgdGhpcyBpbnB1dFxuICogLSAnZGltcyc6IHRoZSBzaGFkZXIvdW5pZm9ybSBkZXBlbmRzIG9uIGRhdGEgdHlwZSBhbmQgdGhlIGRpbXMgb2YgdGhpcyBpbnB1dFxuICogLSAnZGF0YSc6IHRoZSBzaGFkZXIvdW5pZm9ybSBkZXBlbmRzIG9uIGRhdGEgdHlwZSwgdGhlIGRpbXMgYW5kIHRoZSBkYXRhIG9mIHRoaXMgaW5wdXRcbiAqL1xuZXhwb3J0IHR5cGUgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3kgPSAnbm9uZSd8J3R5cGUnfCdyYW5rJ3wnZGltcyd8J2RhdGEnO1xuXG4vKipcbiAqIFJlcHJlc2VudCBpbmZvcm1hdGlvbiBhYm91dCBhIHByb2dyYW0ncyBjYWNoZSBmb3Igc2hhZGVyLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFByb2dyYW1TaGFkZXJDYWNoZUluZm8ge1xuICAvKipcbiAgICogYW4gb3B0aW9uYWwgc3RyaW5nIGFzIGEgY2FjaGUgaGludCBpbiB0aGUgYXJ0aWZhY3QgY2FjaGUuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCwgdGhlIGNhY2hlIGhpbnQgd2lsbCBiZSBlbXB0eS5cbiAgICpcbiAgICogVGhpcyBoaW50IHN0cmluZyBzaG91bGQgb25seSBjb250YWlucyBpbml0aWFsaXppbmctdGltZSBpbmZvcm1hdGlvbiwgc3VjaCBhcyB0aGUgYXR0cmlidXRlcyBvciBhbnkgaW5mb3JtYXRpb24gb2ZcbiAgICogaW5pdGlhbGl6ZXJzLiBJdCBzaG91bGQgTk9UIGNvbnRhaW4gYW55IHJ1bnRpbWUgaW5mb3JtYXRpb24sIHN1Y2ggYXMgdGhlIHNoYXBlIG9mIGlucHV0cy5cbiAgICovXG4gIGhpbnQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGFuIG9wdGlvbmFsIGxpc3Qgb2YgZGVwZW5kZW5jaWVzIG9mIHRoZSBwcm9ncmFtIG9uIHRoZSBpbnB1dCB0ZW5zb3JzLiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBwcm9ncmFtIGRlcGVuZHNcbiAgICogb24gJ2RpbXMnIG9mIGFsbCBpbnB1dHMuXG4gICAqL1xuICBpbnB1dERlcGVuZGVuY2llcz86IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W107XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGluZm9ybWF0aW9uIGFib3V0IGEgcHJvZ3JhbSdzIGNhY2hlIGZvciB1bmlmb3JtLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFByb2dyYW1Vbmlmb3JtQ2FjaGVJbmZvIHtcbiAgLyoqXG4gICAqIGFuIG9wdGlvbmFsIHN0cmluZyBhcyBhIGNhY2hlIGhpbnQgaW4gdGhlIHVuaWZvcm0gY2FjaGUuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCwgdGhlIGNhY2hlIGhpbnQgd2lsbCBiZSBlbXB0eS5cbiAgICpcbiAgICogVGhpcyBoaW50IHN0cmluZyBzaG91bGQgb25seSBjb250YWlucyBydW50aW1lIGluZm9ybWF0aW9uLCBzdWNoIGFzIHRoZSBzaGFwZSBvZiBpbnB1dHMuXG4gICAqL1xuICBoaW50Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBhbiBvcHRpb25hbCBsaXN0IG9mIGRlcGVuZGVuY2llcyBvZiB0aGUgcHJvZ3JhbSBvbiB0aGUgaW5wdXQgdGVuc29ycy4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgcHJvZ3JhbSBkZXBlbmRzXG4gICAqIG9uICdub25lJyBvZiBhbGwgaW5wdXRzLlxuICAgKi9cbiAgaW5wdXREZXBlbmRlbmNpZXM/OiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdO1xufVxuXG5cbi8qKlxuICogQSBzZXQgb2YgZGF0YSB0aGF0IHJlcHJlc2VudCBhIHNoYWRlciBwcm9ncmFtXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJvZ3JhbUluZm8ge1xuICAvKipcbiAgICogdGhlIG5hbWUgb2YgdGhlIHByb2dyYW0uIHVzZWQgZm9yIGRlYnVnZ2luZyBhbmQgcHJvZmlsaW5nXG4gICAqL1xuICBuYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGFuIG9wdGlvbmFsIG9iamVjdCBkZXNjcmliaW5nIHRoZSBjYWNoZSBpbmZvcm1hdGlvbiBvZiB0aGUgcHJvZ3JhbSBzaGFkZXIuXG4gICAqXG4gICAqIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCwgYXNzdW1lIGhpbnQgaXMgZW1wdHkgYW5kIGlucHV0RGVwZW5kZW5jaWVzIGFyZSBbJ2RpbXMnXSBmb3IgYWxsIGlucHV0cy5cbiAgICovXG4gIHNoYWRlckNhY2hlPzogUHJvZ3JhbVNoYWRlckNhY2hlSW5mbztcblxuICAvKipcbiAgICogdGhlIHNoYWRlcidzIHByb2Nlc3Npbmcgc291cmNlIGNvZGUuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbiBzaGFkZXIgY2FjaGUgbWlzc2VkLlxuICAgKi9cbiAgZ2V0U2hhZGVyU291cmNlOiAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHN0cmluZztcblxuICAvKipcbiAgICogQSBmdW5jdGlvbiB0byBnZXQgcnVuIGRhdGEgcmVxdWlyZWQgdG8gcnVuIHRoZSBwcm9ncmFtLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIHByb2dyYW0gaXMgZXhlY3V0ZWQuIFNob3VsZCBrZWVwIHRoaXMgZnVuY3Rpb24gYXMgc2ltcGxlIGFzIHBvc3NpYmxlLlxuICAgKi9cbiAgZ2V0UnVuRGF0YTogKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKSA9PiB7XG4gICAgb3V0cHV0czogcmVhZG9ubHkgVGVuc29ySW5mb1tdO1xuICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBudW1iZXI7IHk/OiBudW1iZXI7IHo/OiBudW1iZXJ9O1xuICAgIHByb2dyYW1Vbmlmb3Jtcz86IHJlYWRvbmx5IFByb2dyYW1Vbmlmb3JtW107XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXJ0aWZhY3Qge1xuICBwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm87XG4gIGNvbXB1dGVQaXBlbGluZTogR1BVQ29tcHV0ZVBpcGVsaW5lO1xuICB1bmlmb3JtVmFyaWFibGVzSW5mbzogcmVhZG9ubHkgUHJvZ3JhbVVuaWZvcm1WYXJpYWJsZUluZm9bXXx1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcHV0ZUNvbnRleHRJbnB1dHNPdXRwdXRzTWFwcGluZyB7XG4gIC8qKlxuICAgKiBzcGVjaWZ5IHRoZSBtYXBwaW5nIHRvIHRoZSBwcm9ncmFtJ3MgaW5wdXRzLiB0aGUgdmFsdWUgY2FuIGJlIGEgbnVtYmVyIG9yIGEgdGVuc29yIHZpZXcuXG4gICAqIC0gaWYgaXQncyBhIG51bWJlciwgaXQncyB0aGUgaW5kZXggb2YgdGhlIGtlcm5lbCdzIGlucHV0XG4gICAqIC0gaWYgaXQncyBhIHRlbnNvciB2aWV3LCBpdCdzIGFuIGV4aXN0aW5nIHRlbnNvciB2aWV3IHRoYXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbnB1dFxuICAgKlxuICAgKiBpZiBpbnB1dHMgaXMgbm90IHNwZWNpZmllZCwgdGhlIG1hcHBpbmcgd2lsbCBiZSB0aGUga2VybmVsJ3MgaW5wdXRzIGluIG9yZGVyLlxuICAgKi9cbiAgcmVhZG9ubHkgaW5wdXRzPzogUmVhZG9ubHlBcnJheTxUZW5zb3JWaWV3fG51bWJlcj47XG4gIC8qKlxuICAgKiBzcGVjaWZ5IHRoZSBtYXBwaW5nIHRvIHRoZSBwcm9ncmFtJ3Mgb3V0cHV0cy4gdGhlIHZhbHVlIG11c3QgYmUgYSBudW1iZXIuXG4gICAqIC0gaWYgaXQncyBhIG5vbi1uZWdhdGl2ZSBudW1iZXIsIGl0J3MgdGhlIGluZGV4IG9mIHRoZSBrZXJuZWwncyBvdXRwdXRcbiAgICogLSBpZiBpdCdzIC0xLCBpdCdzIGFuIG91dHB1dCB0aGF0IHdpbGwgYmUgY3JlYXRlZCBhcyBhIHRlbXBvcmFyeSB2YWx1ZS4gdGhpcyB2YWx1ZSB3aWxsIGJlIHJlbGVhc2VkIGFmdGVyXG4gICAqIHRoZSBrZXJuZWwgaXMgZXhlY3V0ZWQuXG4gICAqIC0gaWYgaXQncyAtMiwgaXQncyBhbiBvdXRwdXQgdGhhdCB3aWxsIGJlIGNyZWF0ZWQgYXMgYSBwZXJzaXN0ZW50IHZhbHVlLiB0aGlzIHZhbHVlIHdpbGwgYmUgcmVsZWFzZWQgd2hlbiB0aGVcbiAgICoga2VybmVsIGlzIHJlbGVhc2VkLlxuICAgKlxuICAgKiBpZiBvdXRwdXRzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBtYXBwaW5nIHdpbGwgYmUgdGhlIGtlcm5lbCdzIG91dHB1dHMgaW4gb3JkZXIuXG4gICAqL1xuICByZWFkb25seSBvdXRwdXRzPzogcmVhZG9ubHkgbnVtYmVyW107XG59XG5cbi8qKlxuICogQSBDb21wdXRlQ29udGV4dCBpbnN0YW5jZSBjYXJyaWVzIHRoZSBzdGF0ZXMgdGhhdCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgcnVubmluZyBvZiBhIGtlcm5lbC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb21wdXRlQ29udGV4dCB7XG4gIC8qKlxuICAgKiBncHUgYWRhcHRlciBpbmZvXG4gICAqL1xuICByZWFkb25seSBhZGFwdGVySW5mbzogQWRhcHRlckluZm87XG5cbiAgLyoqXG4gICAqIHN0b3JlcyB0aGUgcG9pbnRlciB0byBPcEtlcm5lbENvbnRleHRcbiAgICovXG4gIHJlYWRvbmx5IG9wS2VybmVsQ29udGV4dDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBhIGxpc3Qgb2YgaW5wdXRzLCBlYWNoIGlucHV0IGlzIGFuIGluc3RhbmNlIG9mIFRlbnNvclZpZXdcbiAgICovXG4gIHJlYWRvbmx5IGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdO1xuXG4gIC8qKlxuICAgKiBhIGN1c3RvbSBkYXRhIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFueSBkYXRhIHRoYXQgaXMgbmVlZGVkIGJ5IHRoZSBrZXJuZWxcbiAgICovXG4gIHJlYWRvbmx5IGtlcm5lbEN1c3RvbURhdGE6IHtba2V5OiBzdHJpbmddOiB1bmtub3dufTtcblxuICAvKipcbiAgICogYSBidWZmZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBhY2Nlc3MgY3VzdG9tIGRhdGEgY3JlYXRlZCBlYWNoIHRpbWUgdGhlIGtlcm5lbCBpcyBleGVjdXRlZFxuICAgKi9cbiAgcmVhZG9ubHkgY3VzdG9tRGF0YUJ1ZmZlcjogVWludDhBcnJheTtcblxuICAvKipcbiAgICogYSBudW1iZXIgb2Ygb3V0cHV0cyBmb3IgdGhlIG5vZGVcbiAgICovXG4gIHJlYWRvbmx5IG91dHB1dENvdW50OiBudW1iZXI7XG5cbiAgY29tcHV0ZShwcm9ncmFtOiBQcm9ncmFtSW5mbywgaW5wdXRzT3V0cHV0c01hcHBpbmc/OiBDb21wdXRlQ29udGV4dElucHV0c091dHB1dHNNYXBwaW5nKTogVGVuc29yVmlld1tdO1xuICBvdXRwdXQoaW5kZXg6IG51bWJlciwgZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXI7XG4gIGdldE1heENvbXB1dGVXb3JrZ3JvdXBTaXplcygpOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIGdldE1heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlc2l6ZSgpOiBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIFRpbWVzdGFtcFF1ZXJ5ID0gJ25vbmUnfCdpbnNpZGUtcGFzc2VzJ3wnYXQtcGFzc2VzJztcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtXZWJHcHVCYWNrZW5kfSBmcm9tICcuLi9iYWNrZW5kLXdlYmdwdSc7XG5pbXBvcnQge0xPR19ERUJVR30gZnJvbSAnLi4vbG9nJztcblxuaW1wb3J0IHtHcHVEYXRhLCBHcHVEYXRhSWQsIEdwdURhdGFUeXBlfSBmcm9tICcuL3R5cGVzJztcblxuLyoqXG4gKiBtYW5hZ2VzIEdwdURhdGFJZCAtPiBHcHVCdWZmZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHcHVEYXRhTWFuYWdlciB7XG4gIC8qKlxuICAgKiBjb3B5IGRhdGEgZnJvbSBDUFUgdG8gR1BVLlxuICAgKi9cbiAgdXBsb2FkKGlkOiBHcHVEYXRhSWQsIGRhdGE6IFVpbnQ4QXJyYXkpOiB2b2lkO1xuICAvKipcbiAgICogY29weSBkYXRhIGZyb20gR1BVIHRvIEdQVS5cbiAgICovXG4gIG1lbWNweShzb3VyY2VJZDogR3B1RGF0YUlkLCBkZXN0aW5hdGlvbklkOiBHcHVEYXRhSWQpOiB2b2lkO1xuICAvKipcbiAgICogY3JlYXRlIG5ldyBkYXRhIG9uIEdQVS5cbiAgICovXG4gIGNyZWF0ZShzaXplOiBudW1iZXIsIHVzYWdlPzogbnVtYmVyKTogR3B1RGF0YTtcbiAgLyoqXG4gICAqIGdldCBHUFUgZGF0YSBieSBJRC5cbiAgICovXG4gIGdldChpZDogR3B1RGF0YUlkKTogR3B1RGF0YXx1bmRlZmluZWQ7XG4gIC8qKlxuICAgKiByZWxlYXNlIHRoZSBkYXRhIG9uIEdQVSBieSBJRC5cbiAgICpcbiAgICogQHJldHVybiBzaXplIG9mIHRoZSBkYXRhIHJlbGVhc2VkXG4gICAqL1xuICByZWxlYXNlKGlkOiBHcHVEYXRhSWQpOiBudW1iZXI7XG4gIC8qKlxuICAgKiBjb3B5IGRhdGEgZnJvbSBHUFUgdG8gQ1BVLlxuICAgKi9cbiAgZG93bmxvYWQoaWQ6IEdwdURhdGFJZCwgZ2V0VGFyZ2V0QnVmZmVyOiAoKSA9PiBVaW50OEFycmF5KTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogcmVmcmVzaCB0aGUgYnVmZmVycyB0aGF0IG1hcmtlZCBmb3IgcmVsZWFzZS5cbiAgICpcbiAgICogd2hlbiByZWxlYXNlKCkgaXMgY2FsbGVkLCB0aGUgYnVmZmVyIGlzIG5vdCByZWxlYXNlZCBpbW1lZGlhdGVseS4gdGhpcyBpcyBiZWNhdXNlIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIGNvbW1hbmRzXG4gICAqIHRvIGJlIHN1Ym1pdHRlZCB0byB0aGUgR1BVLiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhZnRlciB0aGUgY29tbWFuZHMgYXJlIHN1Ym1pdHRlZCBzbyB0aGF0IHRoZSBidWZmZXJzIGNhbiBiZVxuICAgKiBhY3R1YWxseSByZWxlYXNlZC5cbiAgICovXG4gIHJlZnJlc2hQZW5kaW5nQnVmZmVycygpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiByZWdpc3RlciBhbiBleHRlcm5hbCBidWZmZXIgZm9yIElPIEJpbmRpbmcuIElmIHRoZSBidWZmZXIgaXMgYWxyZWFkeSByZWdpc3RlcmVkLCByZXR1cm4gdGhlIGV4aXN0aW5nIEdQVSBkYXRhIElELlxuICAgKlxuICAgKiBHUFUgZGF0YSBtYW5hZ2VyIG9ubHkgbWFuYWdlcyBhIG1hcHBpbmcgYmV0d2VlbiB0aGUgYnVmZmVyIGFuZCB0aGUgR1BVIGRhdGEgSUQuIEl0IHdpbGwgbm90IG1hbmFnZSB0aGUgbGlmZWN5Y2xlIG9mXG4gICAqIHRoZSBleHRlcm5hbCBidWZmZXIuXG4gICAqL1xuICByZWdpc3RlckV4dGVybmFsQnVmZmVyKGJ1ZmZlcjogR1BVQnVmZmVyLCBvcmlnaW5hbFNpemU6IG51bWJlciwgcHJldmlvdXNCdWZmZXI/OiBHUFVCdWZmZXIpOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIHVucmVnaXN0ZXIgYW4gZXh0ZXJuYWwgYnVmZmVyIGZvciBJTyBCaW5kaW5nLlxuICAgKi9cbiAgdW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKGJ1ZmZlcjogR1BVQnVmZmVyKTogdm9pZDtcblxuICAvKipcbiAgICogZGVzdHJveSBhbGwgZ3B1IGJ1ZmZlcnMuXG4gICAqL1xuICBkaXNwb3NlKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIHJlbGVhc2Ugc2Vzc2lvbiByZWxhdGVkIGRhdGEuXG4gICAqIEBwYXJhbSBzZXNzaW9uSWQgLSBzcGVjaWZ5IHRoZSBzZXNzaW9uIElELlxuICAgKi9cbiAgb25SZWxlYXNlU2Vzc2lvbihzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQ7XG59XG5cbmludGVyZmFjZSBTdG9yYWdlQ2FjaGVWYWx1ZSB7XG4gIGdwdURhdGE6IEdwdURhdGE7XG4gIG9yaWdpbmFsU2l6ZTogbnVtYmVyO1xufVxuXG5jb25zdCBidWNrZXRGcmVlbGlzdDogTWFwPG51bWJlciwgbnVtYmVyPiA9IG5ldyBNYXAoW1xuICBbNjQsIDI1MF0sXG4gIFsxMjgsIDIwMF0sXG4gIFsyNTYsIDIwMF0sXG4gIFs1MTIsIDIwMF0sXG4gIFsyMDQ4LCAyMzBdLFxuICBbNDA5NiwgMjAwXSxcbiAgWzgxOTIsIDUwXSxcbiAgWzE2Mzg0LCA1MF0sXG4gIFszMjc2OCwgNTBdLFxuICBbNjU1MzYsIDUwXSxcbiAgWzEzMTA3MiwgNTBdLFxuICBbMjYyMTQ0LCA1MF0sXG4gIFs1MjQyODgsIDUwXSxcbiAgWzEwNDg1NzYsIDUwXSxcbiAgWzIwOTcxNTIsIDMwXSxcbiAgWzQxOTQzMDQsIDIwXSxcbiAgWzgzODg2MDgsIDEwXSxcbiAgWzEyNTgyOTEyLCAxMF0sXG4gIFsxNjc3NzIxNiwgMTBdLFxuICBbMjYyMTQ0MDAsIDE1XSxcbiAgWzMzNTU0NDMyLCAyMl0sXG4gIFs0NDIzNjgwMCwgMl0sXG4gIFs1ODk4MjQwMCwgNl0sXG4gIC8vIHdlIGRvbid0IHdhbnQgdG8gY2FjaGUgdGhlIGJ1Y2tldCBzaXplcyBiZWxvdyBidXQgbm90IGNhY2hpbmcgdGhlbVxuICAvLyByZXN1bHRzIGluIHNvbWUgbWFqb3IgcGVyZm9ybWFuY2UgaGl0cyBmb3IgbW9kZWxzIGxpa2Ugc2QtdHVyYm8uXG4gIFs2NzEwODg2NCwgNl0sXG4gIFsxMzQyMTc3MjgsIDZdLFxuICBbMTY3NzcyMTYwLCA2XSxcbl0pO1xuXG5jb25zdCBidWNrZXRBcnI6IG51bWJlcltdID0gW107XG5cbi8qKlxuICogbm9ybWFsaXplIHRoZSBidWZmZXIgc2l6ZSBzbyB0aGF0IGl0IGZpdHMgdGhlIDEyOC1iaXRzICgxNiBieXRlcykgYWxpZ25tZW50LlxuICovXG5jb25zdCBjYWxjTm9ybWFsaXplZEJ1ZmZlclNpemUgPSAoc2l6ZTogbnVtYmVyKSA9PiBNYXRoLmNlaWwoc2l6ZSAvIDE2KSAqIDE2O1xuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgYnVmZmVyIHNpemUgc28gdGhhdCBpdCBmaXRzIGludG8gYnVja2V0cy5cbiAqL1xuY29uc3QgY2FsY0J1Y2tldEJ1ZmZlclNpemUgPSAoc2l6ZTogbnVtYmVyKSA9PiB7XG4gIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGJ1Y2tldEFyci5sZW5ndGg7IGlkeCsrKSB7XG4gICAgY29uc3Qgc2l6ZUZvckJ1Y2tldCA9IGJ1Y2tldEFycltpZHhdO1xuICAgIGlmIChzaXplIDw9IHNpemVGb3JCdWNrZXQpIHtcbiAgICAgIHJldHVybiBzaXplRm9yQnVja2V0O1xuICAgIH1cbiAgfVxuICAvLyBub3QgaW4gYnVja2V0IGxpc3QgLT4gY2FsbGVyIHdpbGwgbm90IGNhY2hlLCByb3VuZCB1cCB0byAxNi5cbiAgcmV0dXJuIE1hdGguY2VpbChzaXplIC8gMTYpICogMTY7XG59O1xuXG5sZXQgZ3VpZCA9IDE7XG5jb25zdCBjcmVhdGVOZXdHcHVEYXRhSWQgPSAoKSA9PiBndWlkKys7XG5cbi8qKlxuICogZXhwb3J0ZWQgc3RhbmRhcmQgZG93bmxvYWQgZnVuY3Rpb24uIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBieSB0aGUgc2Vzc2lvbiB0byBkb3dubG9hZCB0aGUgZGF0YSBmcm9tIEdQVSwgYW5kIGFsc28gYnlcbiAqIGZhY3RvcnkgdG8gY3JlYXRlIEdQVSB0ZW5zb3JzIHdpdGggdGhlIGNhcGFjaXR5IG9mIGRvd25sb2FkaW5nIGRhdGEgZnJvbSBHUFUuXG4gKlxuICogQHBhcmFtIGJhY2tlbmQgLSB0aGUgV2ViR1BVIGJhY2tlbmRcbiAqIEBwYXJhbSBncHVCdWZmZXIgLSB0aGUgR1BVIGJ1ZmZlciB0byBkb3dubG9hZFxuICogQHBhcmFtIG9yaWdpbmFsU2l6ZSAtIHRoZSBvcmlnaW5hbCBzaXplIG9mIHRoZSBkYXRhXG4gKiBAcGFyYW0gZ2V0VGFyZ2V0QnVmZmVyIC0gb3B0aW9uYWwuIElmIHByb3ZpZGVkLCB0aGUgZGF0YSB3aWxsIGJlIGNvcGllZCB0byB0aGUgdGFyZ2V0IGJ1ZmZlci4gT3RoZXJ3aXNlLCBhIG5ldyBidWZmZXJcbiAqIHdpbGwgYmUgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBkb3dubG9hZEdwdURhdGEgPVxuICAgIGFzeW5jKGJhY2tlbmQ6IFdlYkdwdUJhY2tlbmQsIGdwdUJ1ZmZlcjogR1BVQnVmZmVyLCBvcmlnaW5hbFNpemU6IG51bWJlciwgZ2V0VGFyZ2V0QnVmZmVyPzogKCkgPT4gVWludDhBcnJheSk6XG4gICAgICAgIFByb21pc2U8VWludDhBcnJheT4gPT4ge1xuICAgICAgICAgIGNvbnN0IGJ1ZmZlclNpemUgPSBjYWxjTm9ybWFsaXplZEJ1ZmZlclNpemUob3JpZ2luYWxTaXplKTtcbiAgICAgICAgICBjb25zdCBncHVSZWFkQnVmZmVyID0gYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKFxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICAgICAgICB7c2l6ZTogYnVmZmVyU2l6ZSwgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUIHwgR1BVQnVmZmVyVXNhZ2UuTUFQX1JFQUR9KTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29tbWFuZEVuY29kZXIgPSBiYWNrZW5kLmdldENvbW1hbmRFbmNvZGVyKCk7XG4gICAgICAgICAgICBiYWNrZW5kLmVuZENvbXB1dGVQYXNzKCk7XG4gICAgICAgICAgICBjb21tYW5kRW5jb2Rlci5jb3B5QnVmZmVyVG9CdWZmZXIoXG4gICAgICAgICAgICAgICAgZ3B1QnVmZmVyIC8qIHNvdXJjZSBidWZmZXIgKi8sIDAgLyogc291cmNlIG9mZnNldCAqLywgZ3B1UmVhZEJ1ZmZlciAvKiBkZXN0aW5hdGlvbiBidWZmZXIgKi8sXG4gICAgICAgICAgICAgICAgMCAvKiBkZXN0aW5hdGlvbiBvZmZzZXQgKi8sIGJ1ZmZlclNpemUgLyogc2l6ZSAqL1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJhY2tlbmQuZmx1c2goKTtcblxuICAgICAgICAgICAgYXdhaXQgZ3B1UmVhZEJ1ZmZlci5tYXBBc3luYyhHUFVNYXBNb2RlLlJFQUQpO1xuXG4gICAgICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGdwdVJlYWRCdWZmZXIuZ2V0TWFwcGVkUmFuZ2UoKTtcbiAgICAgICAgICAgIGlmIChnZXRUYXJnZXRCdWZmZXIpIHtcbiAgICAgICAgICAgICAgLy8gaWYgd2UgYWxyZWFkeSBoYXZlIGEgQ1BVIGJ1ZmZlciB0byBhY2NlcHQgdGhlIGRhdGEsIG5vIG5lZWQgdG8gY2xvbmUgdGhlIEFycmF5QnVmZmVyLlxuICAgICAgICAgICAgICBjb25zdCB0YXJnZXRCdWZmZXIgPSBnZXRUYXJnZXRCdWZmZXIoKTtcbiAgICAgICAgICAgICAgdGFyZ2V0QnVmZmVyLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlciwgMCwgb3JpZ2luYWxTaXplKSk7XG4gICAgICAgICAgICAgIHJldHVybiB0YXJnZXRCdWZmZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyB0aGUgbWFwcGVkIEFycmF5QnVmZmVyIHdpbGwgYmUgcmVsZWFzZWQgd2hlbiB0aGUgR1BVIGJ1ZmZlciBpcyBkZXN0cm95ZWQuIE5lZWQgdG8gY2xvbmUgdGhlXG4gICAgICAgICAgICAgIC8vIEFycmF5QnVmZmVyLlxuICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIuc2xpY2UoMCwgb3JpZ2luYWxTaXplKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGdwdVJlYWRCdWZmZXIuZGVzdHJveSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuY2xhc3MgR3B1RGF0YU1hbmFnZXJJbXBsIGltcGxlbWVudHMgR3B1RGF0YU1hbmFnZXIge1xuICAvLyBHUFUgRGF0YSBJRCA9PiBHUFUgRGF0YSAoIHN0b3JhZ2UgYnVmZmVyIClcbiAgcHJpdmF0ZSBzdG9yYWdlQ2FjaGU6IE1hcDxHcHVEYXRhSWQsIFN0b3JhZ2VDYWNoZVZhbHVlPjtcblxuICAvLyBwZW5kaW5nIGJ1ZmZlcnMgZm9yIHVwbG9hZGluZyAoIGRhdGEgaXMgdW5tYXBwZWQgKVxuICBwcml2YXRlIGJ1ZmZlcnNGb3JVcGxvYWRpbmdQZW5kaW5nOiBHUFVCdWZmZXJbXTtcbiAgLy8gcGVuZGluZyBidWZmZXJzIGZvciBjb21wdXRpbmdcbiAgcHJpdmF0ZSBidWZmZXJzUGVuZGluZzogR1BVQnVmZmVyW107XG5cbiAgLy8gVGhlIHJldXNhYmxlIHN0b3JhZ2UgYnVmZmVycyBmb3IgY29tcHV0aW5nLlxuICBwcml2YXRlIGZyZWVCdWZmZXJzOiBNYXA8bnVtYmVyLCBHUFVCdWZmZXJbXT47XG4gIC8vIFRoZSByZXVzYWJsZSB1bmlmb3JtIGJ1ZmZlcnNcbiAgcHJpdmF0ZSBmcmVlVW5pZm9ybUJ1ZmZlcnM6IE1hcDxudW1iZXIsIEdQVUJ1ZmZlcltdPjtcblxuICAvLyBUaGUgZXh0ZXJuYWwgYnVmZmVycyByZWdpc3RlcmVkIHVzZXJzIGZvciBJTyBCaW5kaW5nLlxuICBwcml2YXRlIGV4dGVybmFsQnVmZmVyczogTWFwPEdQVUJ1ZmZlciwgR3B1RGF0YUlkPjtcblxuICAvLyBUaGUgcGVuZGluZ0J1ZmZlcnMgZm9yIGNhcHR1cmUgZ3JhcGguXG4gIC8vIGEgU2Vzc2lvbklEIC0+IEdQVUJ1ZmZlcltdIG1hcHBpbmcuXG4gIHByaXZhdGUgY2FwdHVyZWRQZW5kaW5nQnVmZmVyczogTWFwPG51bWJlciwgR1BVQnVmZmVyW10+O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgYmFja2VuZDogV2ViR3B1QmFja2VuZCkge1xuICAgIHRoaXMuc3RvcmFnZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZnJlZUJ1ZmZlcnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5idWZmZXJzRm9yVXBsb2FkaW5nUGVuZGluZyA9IFtdO1xuICAgIHRoaXMuYnVmZmVyc1BlbmRpbmcgPSBbXTtcbiAgICB0aGlzLmV4dGVybmFsQnVmZmVycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMgPSBuZXcgTWFwKCk7XG5cbiAgICBmb3IgKGNvbnN0IFtrZXksIF0gb2YgYnVja2V0RnJlZWxpc3QpIHtcbiAgICAgIGJ1Y2tldEFyci5wdXNoKGtleSk7XG4gICAgICB0aGlzLmZyZWVCdWZmZXJzLnNldChrZXksIFtdKTtcbiAgICAgIHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLnNldChrZXksIFtdKTtcbiAgICB9XG4gIH1cblxuICB1cGxvYWQoaWQ6IEdwdURhdGFJZCwgZGF0YTogVWludDhBcnJheSk6IHZvaWQge1xuICAgIGNvbnN0IHNyY0FycmF5QnVmZmVyID0gZGF0YS5idWZmZXI7XG4gICAgY29uc3Qgc3JjT2Zmc2V0ID0gZGF0YS5ieXRlT2Zmc2V0O1xuICAgIGNvbnN0IHNyY0xlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCBzaXplID0gY2FsY05vcm1hbGl6ZWRCdWZmZXJTaXplKHNyY0xlbmd0aCk7XG5cbiAgICAvLyBnZXQgZGVzdGluYXRpb24gZ3B1IGJ1ZmZlclxuICAgIGNvbnN0IGdwdURhdGFDYWNoZSA9IHRoaXMuc3RvcmFnZUNhY2hlLmdldChpZCk7XG4gICAgaWYgKCFncHVEYXRhQ2FjaGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ3B1IGRhdGEgZm9yIHVwbG9hZGluZyBkb2VzIG5vdCBleGlzdCcpO1xuICAgIH1cbiAgICBpZiAoZ3B1RGF0YUNhY2hlLm9yaWdpbmFsU2l6ZSAhPT0gc3JjTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGluY29uc2lzdGVudCBkYXRhIHNpemUuIGdwdSBkYXRhIHNpemU9JHtncHVEYXRhQ2FjaGUub3JpZ2luYWxTaXplfSwgZGF0YSBzaXplPSR7c3JjTGVuZ3RofWApO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBncHUgYnVmZmVyXG4gICAgY29uc3QgZ3B1QnVmZmVyRm9yVXBsb2FkaW5nID0gdGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgIHttYXBwZWRBdENyZWF0aW9uOiB0cnVlLCBzaXplLCB1c2FnZTogR1BVQnVmZmVyVXNhZ2UuTUFQX1dSSVRFIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkN9KTtcblxuICAgIC8vIGNvcHkgKHVwbG9hZCkgZGF0YVxuICAgIGNvbnN0IGFycmF5QnVmZmVyID0gZ3B1QnVmZmVyRm9yVXBsb2FkaW5nLmdldE1hcHBlZFJhbmdlKCk7XG4gICAgbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpLnNldChuZXcgVWludDhBcnJheShzcmNBcnJheUJ1ZmZlciwgc3JjT2Zmc2V0LCBzcmNMZW5ndGgpKTtcbiAgICBncHVCdWZmZXJGb3JVcGxvYWRpbmcudW5tYXAoKTtcblxuXG4gICAgLy8gR1BVIGNvcHlcbiAgICBjb25zdCBjb21tYW5kRW5jb2RlciA9IHRoaXMuYmFja2VuZC5nZXRDb21tYW5kRW5jb2RlcigpO1xuICAgIHRoaXMuYmFja2VuZC5lbmRDb21wdXRlUGFzcygpO1xuICAgIGNvbW1hbmRFbmNvZGVyLmNvcHlCdWZmZXJUb0J1ZmZlcihncHVCdWZmZXJGb3JVcGxvYWRpbmcsIDAsIGdwdURhdGFDYWNoZS5ncHVEYXRhLmJ1ZmZlciwgMCwgc2l6ZSk7XG5cbiAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIudXBsb2FkKGlkPSR7aWR9KWApO1xuXG4gICAgdGhpcy5idWZmZXJzRm9yVXBsb2FkaW5nUGVuZGluZy5wdXNoKGdwdUJ1ZmZlckZvclVwbG9hZGluZyk7XG4gIH1cblxuICBtZW1jcHkoc291cmNlSWQ6IEdwdURhdGFJZCwgZGVzdGluYXRpb25JZDogR3B1RGF0YUlkKTogdm9pZCB7XG4gICAgLy8gZ2V0IHNvdXJjZSBncHUgYnVmZmVyXG4gICAgY29uc3Qgc291cmNlR3B1RGF0YUNhY2hlID0gdGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHNvdXJjZUlkKTtcbiAgICBpZiAoIXNvdXJjZUdwdURhdGFDYWNoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2UgZ3B1IGRhdGEgZm9yIG1lbWNweSBkb2VzIG5vdCBleGlzdCcpO1xuICAgIH1cbiAgICAvLyBnZXQgZGVzdGluYXRpb24gZ3B1IGJ1ZmZlclxuICAgIGNvbnN0IGRlc3RpbmF0aW9uR3B1RGF0YUNhY2hlID0gdGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KGRlc3RpbmF0aW9uSWQpO1xuICAgIGlmICghZGVzdGluYXRpb25HcHVEYXRhQ2FjaGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZGVzdGluYXRpb24gZ3B1IGRhdGEgZm9yIG1lbWNweSBkb2VzIG5vdCBleGlzdCcpO1xuICAgIH1cbiAgICBpZiAoc291cmNlR3B1RGF0YUNhY2hlLm9yaWdpbmFsU2l6ZSAhPT0gZGVzdGluYXRpb25HcHVEYXRhQ2FjaGUub3JpZ2luYWxTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luY29uc2lzdGVudCBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGdwdSBkYXRhIHNpemUnKTtcbiAgICB9XG5cbiAgICBjb25zdCBzaXplID0gY2FsY05vcm1hbGl6ZWRCdWZmZXJTaXplKHNvdXJjZUdwdURhdGFDYWNoZS5vcmlnaW5hbFNpemUpO1xuXG4gICAgLy8gR1BVIGNvcHlcbiAgICBjb25zdCBjb21tYW5kRW5jb2RlciA9IHRoaXMuYmFja2VuZC5nZXRDb21tYW5kRW5jb2RlcigpO1xuICAgIHRoaXMuYmFja2VuZC5lbmRDb21wdXRlUGFzcygpO1xuICAgIGNvbW1hbmRFbmNvZGVyLmNvcHlCdWZmZXJUb0J1ZmZlcihcbiAgICAgICAgc291cmNlR3B1RGF0YUNhY2hlLmdwdURhdGEuYnVmZmVyLCAwLCBkZXN0aW5hdGlvbkdwdURhdGFDYWNoZS5ncHVEYXRhLmJ1ZmZlciwgMCwgc2l6ZSk7XG4gIH1cblxuICByZWdpc3RlckV4dGVybmFsQnVmZmVyKGJ1ZmZlcjogR1BVQnVmZmVyLCBvcmlnaW5hbFNpemU6IG51bWJlciwgcHJldmlvdXNCdWZmZXI/OiBHUFVCdWZmZXIpOiBudW1iZXIge1xuICAgIGxldCBpZDogbnVtYmVyfHVuZGVmaW5lZDtcbiAgICBpZiAocHJldmlvdXNCdWZmZXIpIHtcbiAgICAgIGlkID0gdGhpcy5leHRlcm5hbEJ1ZmZlcnMuZ2V0KHByZXZpb3VzQnVmZmVyKTtcbiAgICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHJldmlvdXMgYnVmZmVyIGlzIG5vdCByZWdpc3RlcmVkJyk7XG4gICAgICB9XG4gICAgICBpZiAoYnVmZmVyID09PSBwcmV2aW91c0J1ZmZlcikge1xuICAgICAgICBMT0dfREVCVUcoXG4gICAgICAgICAgICAndmVyYm9zZScsXG4gICAgICAgICAgICAoKSA9PiBgW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihzaXplPSR7b3JpZ2luYWxTaXplfSkgPT4gaWQ9JHtcbiAgICAgICAgICAgICAgICBpZH0sIGJ1ZmZlciBpcyB0aGUgc2FtZSwgc2tpcC5gKTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmJhY2tlbmQuY2FwdHVyZWRDb21tYW5kTGlzdC5oYXModGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlZ2lzdGVyaW5nIGEgZGlmZmVyZW50IGV4dGVybmFsIGJ1ZmZlciB1bmRlciBncmFwaCBjYXB0dXJlIG1vZGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQuXG4gICAgICAgICAgICAgUGxlYXNlIHVzZSB0aGUgcHJldmlvdXMgZXh0ZXJuYWwgYnVmZmVyIWApO1xuICAgICAgfVxuICAgICAgdGhpcy5leHRlcm5hbEJ1ZmZlcnMuZGVsZXRlKHByZXZpb3VzQnVmZmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWQgPSBjcmVhdGVOZXdHcHVEYXRhSWQoKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0b3JhZ2VDYWNoZS5zZXQoaWQsIHtncHVEYXRhOiB7aWQsIHR5cGU6IEdwdURhdGFUeXBlLmRlZmF1bHQsIGJ1ZmZlcn0sIG9yaWdpbmFsU2l6ZX0pO1xuICAgIHRoaXMuZXh0ZXJuYWxCdWZmZXJzLnNldChidWZmZXIsIGlkKTtcbiAgICBMT0dfREVCVUcoXG4gICAgICAgICd2ZXJib3NlJyxcbiAgICAgICAgKCkgPT4gYFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoc2l6ZT0ke29yaWdpbmFsU2l6ZX0pID0+IGlkPSR7aWR9LCByZWdpc3RlcmVkLmApO1xuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIHVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihidWZmZXI6IEdQVUJ1ZmZlcik6IHZvaWQge1xuICAgIGNvbnN0IGlkID0gdGhpcy5leHRlcm5hbEJ1ZmZlcnMuZ2V0KGJ1ZmZlcik7XG4gICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc3RvcmFnZUNhY2hlLmRlbGV0ZShpZCk7XG4gICAgICB0aGlzLmV4dGVybmFsQnVmZmVycy5kZWxldGUoYnVmZmVyKTtcbiAgICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci51bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoKSA9PiBpZD0ke2lkfWApO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gIGNyZWF0ZShzaXplOiBudW1iZXIsIHVzYWdlID0gR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QpOiBHcHVEYXRhIHtcbiAgICBjb25zdCBidWZmZXJTaXplID0gY2FsY0J1Y2tldEJ1ZmZlclNpemUoc2l6ZSk7XG5cbiAgICBsZXQgZ3B1QnVmZmVyO1xuICAgIC8vIEN1cnJlbnRseSwgb25seSBzdG9yYWdlIGJ1ZmZlcnMgYXJlIHJldXNlZC5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgIGNvbnN0IGlzU3RvcmFnZSA9ICh1c2FnZSAmIEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UpID09PSBHUFVCdWZmZXJVc2FnZS5TVE9SQUdFO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgY29uc3QgaXNVbmlmb3JtID0gKHVzYWdlICYgR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSkgPT09IEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk07XG4gICAgaWYgKGlzU3RvcmFnZSB8fCBpc1VuaWZvcm0pIHtcbiAgICAgIGNvbnN0IGZyZWVCdWZmZXJzID0gaXNTdG9yYWdlID8gdGhpcy5mcmVlQnVmZmVycyA6IHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzO1xuICAgICAgY29uc3QgYnVmZmVycyA9IGZyZWVCdWZmZXJzLmdldChidWZmZXJTaXplKTtcbiAgICAgIGlmICghYnVmZmVycykge1xuICAgICAgICAvLyBubyBzdWNoIGJ1Y2tldC9mcmVlbGlzdCAtIGNyZWF0ZSBncHUgYnVmZmVyXG4gICAgICAgIGdwdUJ1ZmZlciA9IHRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOiBidWZmZXJTaXplLCB1c2FnZX0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGJ1ZmZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIGluIGZyZWVsaXN0LCB1c2UgaXRcbiAgICAgICAgICBncHVCdWZmZXIgPSBidWZmZXJzLnBvcCgpIGFzIEdQVUJ1ZmZlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBidWNrZXQgZW1wdHksIGNyZWF0ZSBncHUgYnVmZmVyXG4gICAgICAgICAgZ3B1QnVmZmVyID0gdGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6IGJ1ZmZlclNpemUsIHVzYWdlfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY3JlYXRlIGdwdSBidWZmZXJcbiAgICAgIGdwdUJ1ZmZlciA9IHRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOiBidWZmZXJTaXplLCB1c2FnZX0pO1xuICAgIH1cblxuICAgIGNvbnN0IGdwdURhdGEgPSB7aWQ6IGNyZWF0ZU5ld0dwdURhdGFJZCgpLCB0eXBlOiBHcHVEYXRhVHlwZS5kZWZhdWx0LCBidWZmZXI6IGdwdUJ1ZmZlcn07XG4gICAgdGhpcy5zdG9yYWdlQ2FjaGUuc2V0KGdwdURhdGEuaWQsIHtncHVEYXRhLCBvcmlnaW5hbFNpemU6IHNpemV9KTtcblxuICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5jcmVhdGUoc2l6ZT0ke3NpemV9KSA9PiBpZD0ke2dwdURhdGEuaWR9YCk7XG4gICAgcmV0dXJuIGdwdURhdGE7XG4gIH1cblxuICBnZXQoaWQ6IEdwdURhdGFJZCk6IEdwdURhdGF8dW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KGlkKT8uZ3B1RGF0YTtcbiAgfVxuXG4gIHJlbGVhc2UoaWQ6IEdwdURhdGFJZCk6IG51bWJlciB7XG4gICAgY29uc3QgY2FjaGVkRGF0YSA9IHRoaXMuc3RvcmFnZUNhY2hlLmdldChpZCk7XG4gICAgaWYgKCFjYWNoZWREYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbGVhc2luZyBkYXRhIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgfVxuXG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoaWQ9JHtpZH0pLCBncHVEYXRhSWQ9JHtjYWNoZWREYXRhLmdwdURhdGEuaWR9YCk7XG5cbiAgICB0aGlzLnN0b3JhZ2VDYWNoZS5kZWxldGUoaWQpO1xuICAgIHRoaXMuYnVmZmVyc1BlbmRpbmcucHVzaChjYWNoZWREYXRhLmdwdURhdGEuYnVmZmVyKTtcbiAgICAvLyBjYWNoZWREYXRhLmdwdURhdGEuYnVmZmVyLmRlc3Ryb3koKTtcblxuICAgIHJldHVybiBjYWNoZWREYXRhLm9yaWdpbmFsU2l6ZTtcbiAgfVxuXG4gIGFzeW5jIGRvd25sb2FkKGlkOiBHcHVEYXRhSWQsIGdldFRhcmdldEJ1ZmZlcjogKCkgPT4gVWludDhBcnJheSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGNhY2hlZERhdGEgPSB0aGlzLnN0b3JhZ2VDYWNoZS5nZXQoaWQpO1xuICAgIGlmICghY2FjaGVkRGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdkYXRhIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgfVxuICAgIGF3YWl0IGRvd25sb2FkR3B1RGF0YSh0aGlzLmJhY2tlbmQsIGNhY2hlZERhdGEuZ3B1RGF0YS5idWZmZXIsIGNhY2hlZERhdGEub3JpZ2luYWxTaXplLCBnZXRUYXJnZXRCdWZmZXIpO1xuICB9XG5cbiAgcmVmcmVzaFBlbmRpbmdCdWZmZXJzKCk6IHZvaWQge1xuICAgIGZvciAoY29uc3QgYnVmZmVyIG9mIHRoaXMuYnVmZmVyc0ZvclVwbG9hZGluZ1BlbmRpbmcpIHtcbiAgICAgIC8vIHVwbG9hZCBidWZmZXIgaXMgb25seSB1c2VmdWwgaW4gdGhlIHNlc3Npb24gY3JlYXRpb24gdGltZS4gU28gd2UgZG9uJ3QgbmVlZCB0byByZXVzZSB0aGVtIGluIHNlc3Npb24gcnVubmluZy5cbiAgICAgIGJ1ZmZlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuYnVmZmVyc0ZvclVwbG9hZGluZ1BlbmRpbmcgPSBbXTtcblxuICAgIGlmICh0aGlzLmJ1ZmZlcnNQZW5kaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmJhY2tlbmQuc2Vzc2lvblN0YXR1cyA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICBmb3IgKGNvbnN0IGJ1ZmZlciBvZiB0aGlzLmJ1ZmZlcnNQZW5kaW5nKSB7XG4gICAgICAgIGNvbnN0IG1heEluRnJlZUxpc3QgPSBidWNrZXRGcmVlbGlzdC5nZXQoYnVmZmVyLnNpemUpO1xuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgIGlmICgoYnVmZmVyLnVzYWdlICYgR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSkgPT09IEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UpIHtcbiAgICAgICAgICAvLyBQdXQgdGhlIHBlbmRpbmcgYnVmZmVyIHRvIGZyZWVCdWZmZXJzIGxpc3QgaW5zdGVhZCBvZiByZWFsbHkgZGVzdHJveWluZyBpdCBmb3IgYnVmZmVyIHJldXNpbmcuXG4gICAgICAgICAgY29uc3QgZnJlZWxpc3QgPSB0aGlzLmZyZWVCdWZmZXJzLmdldChidWZmZXIuc2l6ZSkgfHwgW107XG4gICAgICAgICAgaWYgKG1heEluRnJlZUxpc3QgPT09IHVuZGVmaW5lZCB8fCBmcmVlbGlzdC5sZW5ndGggPj0gbWF4SW5GcmVlTGlzdCkge1xuICAgICAgICAgICAgYnVmZmVyLmRlc3Ryb3koKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJlZWxpc3QucHVzaChidWZmZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICB9IGVsc2UgaWYgKChidWZmZXIudXNhZ2UgJiBHUFVCdWZmZXJVc2FnZS5VTklGT1JNKSA9PT0gR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSkge1xuICAgICAgICAgIC8vIFB1dCB0aGUgcGVuZGluZyBidWZmZXIgdG8gZnJlZVVuaWZvcm1CdWZmZXJzIGxpc3QgaW5zdGVhZCBvZiByZWFsbHkgZGVzdHJveWluZyBpdCBmb3IgYnVmZmVyIHJldXNpbmcuXG4gICAgICAgICAgY29uc3QgZnJlZWxpc3QgPSB0aGlzLmZyZWVVbmlmb3JtQnVmZmVycy5nZXQoYnVmZmVyLnNpemUpIHx8IFtdO1xuICAgICAgICAgIGlmIChtYXhJbkZyZWVMaXN0ID09PSB1bmRlZmluZWQgfHwgZnJlZWxpc3QubGVuZ3RoID49IG1heEluRnJlZUxpc3QpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyZWVsaXN0LnB1c2goYnVmZmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVmZmVyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5idWZmZXJzUGVuZGluZyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEb24ndCByZWxlYXNlIGludGVybWVkaWF0ZSB0ZW5zb3JzIGluIG5vbi1kZWZhdWx0IG1vZGUuXG4gICAgICAvLyBUT0RPOiByZXVzZSB0aGUgc3RvcmFnZSBidWZmZXJzIGluIG5vbi1kZWZhdWx0IG1vZGUuXG4gICAgICBsZXQgY2FwdHVyZWRCdWZmZXJzID0gdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmdldCh0aGlzLmJhY2tlbmQuY3VycmVudFNlc3Npb25JZCEpO1xuICAgICAgaWYgKCFjYXB0dXJlZEJ1ZmZlcnMpIHtcbiAgICAgICAgY2FwdHVyZWRCdWZmZXJzID0gW107XG4gICAgICAgIHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5zZXQodGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQhLCBjYXB0dXJlZEJ1ZmZlcnMpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBidWZmZXIgb2YgdGhpcy5idWZmZXJzUGVuZGluZykge1xuICAgICAgICBjYXB0dXJlZEJ1ZmZlcnMucHVzaChidWZmZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5idWZmZXJzUGVuZGluZyA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5mcmVlQnVmZmVycy5mb3JFYWNoKChidWZmZXJzKSA9PiB7XG4gICAgICBidWZmZXJzLmZvckVhY2goYnVmZmVyID0+IHtcbiAgICAgICAgYnVmZmVyLmRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLmZvckVhY2goKGJ1ZmZlcnMpID0+IHtcbiAgICAgIGJ1ZmZlcnMuZm9yRWFjaChidWZmZXIgPT4ge1xuICAgICAgICBidWZmZXIuZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnN0b3JhZ2VDYWNoZS5mb3JFYWNoKChzdG9yYWdlKSA9PiB7XG4gICAgICBzdG9yYWdlLmdwdURhdGEuYnVmZmVyLmRlc3Ryb3koKTtcbiAgICB9KTtcblxuICAgIHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5mb3JFYWNoKChidWZmZXJzKSA9PiB7XG4gICAgICBidWZmZXJzLmZvckVhY2goYnVmZmVyID0+IHtcbiAgICAgICAgYnVmZmVyLmRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuc3RvcmFnZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZnJlZUJ1ZmZlcnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgb25SZWxlYXNlU2Vzc2lvbihzZXNzaW9uSWQ6IG51bWJlcikge1xuICAgIC8vIHJlbGVhc2UgdGhlIGNhcHR1cmVkIHBlbmRpbmcgYnVmZmVycy5cbiAgICBjb25zdCBwZW5kaW5nQnVmZmVycyA9IHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5nZXQoc2Vzc2lvbklkKTtcbiAgICBpZiAocGVuZGluZ0J1ZmZlcnMpIHtcbiAgICAgIHBlbmRpbmdCdWZmZXJzLmZvckVhY2goYnVmZmVyID0+IHtcbiAgICAgICAgYnVmZmVyLmRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmRlbGV0ZShzZXNzaW9uSWQpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlR3B1RGF0YU1hbmFnZXIgPSAoLi4uYXJnczogQ29uc3RydWN0b3JQYXJhbWV0ZXJzPHR5cGVvZiBHcHVEYXRhTWFuYWdlckltcGw+KTogR3B1RGF0YU1hbmFnZXIgPT5cbiAgICBuZXcgR3B1RGF0YU1hbmFnZXJJbXBsKC4uLmFyZ3MpO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5jbGFzcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXlJbXBsIHtcbiAgY29uc3RydWN0b3IoYXR0cmlidXRlOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgYXR0cmlidXRlKTtcbiAgfVxuXG4gIHByaXZhdGUga2V5OiBzdHJpbmc7XG4gIHB1YmxpYyBnZXQgY2FjaGVLZXkoKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMua2V5KSB7XG4gICAgICB0aGlzLmtleSA9XG4gICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykuc29ydCgpLm1hcChuYW1lID0+IGAkeyh0aGlzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVtuYW1lXX1gKS5qb2luKCc7Jyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmtleTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGNhY2hlS2V5OiBzdHJpbmc7XG59XG5cbi8qKlxuICogY3JlYXRlIGEgbmV3IG9iamVjdCBmcm9tIHRoZSBnaXZlbiBhdHRyaWJ1dGUsIGFuZCBhZGQgYSBjYWNoZUtleSBwcm9wZXJ0eSB0byBpdFxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5ID0gPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oYXR0cmlidXRlOiBUKTogVCZBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgPT5cbiAgICBuZXcgQXR0cmlidXRlV2l0aENhY2hlS2V5SW1wbChhdHRyaWJ1dGUpIGFzIHVua25vd24gYXMgVCAmIEF0dHJpYnV0ZVdpdGhDYWNoZUtleTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cblxuZXhwb3J0IGNsYXNzIE1hdE11bFV0aWwge1xuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBleHBlY3RlZCBzaGFwZSB3aGVuIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgKiBAcGFyYW0gYSBUaGUgc2hhcGUgb2YgdGVuc29yIEEuIFNob3VsZCBiZSBhIHR1cGxlIG9mIDIgcG9zaXRpdmUgaW50ZWdlcnNcbiAgICogQHBhcmFtIGIgVGhlIHNoYXBlIG9mIHRlbnNvciBCLiBTaG91bGQgYmUgYSB0dXBsZSBvZiAyIHBvc2l0aXZlIGludGVnZXJzXG4gICAqIEByZXR1cm5zIFRoZSBleHBlY3RlZCBzaGFwZSBvZiB0aGUgcmVzdWx0LCBvciB1bmRlZmluZWQgaWYgTi9BXG4gICAqL1xuICBzdGF0aWMgY2FsY01hdE11bFNoYXBlKGE6IFtudW1iZXIsIG51bWJlcl0sIGI6IFtudW1iZXIsIG51bWJlcl0pOiBbbnVtYmVyLCBudW1iZXJdfHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIChhWzFdICE9PSBiWzBdKSA/IHVuZGVmaW5lZCA6IFthWzBdLCBiWzFdXTtcbiAgfVxufVxuXG5cbmV4cG9ydCBjbGFzcyBCcm9hZGNhc3RVdGlsIHtcbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZXhwZWN0ZWQgc2hhcGUgd2hlbiBicm9hZGNhc3RpbmcgMiB0ZW5zb3JzXG4gICAqIEBwYXJhbSBhIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQS4gU2hvdWxkIGJlIGFuIGFycmF5IG9mIHBvc2l0aXZlIGludGVnZXJzXG4gICAqIEBwYXJhbSBiIFRoZSBzaGFwZSBvZiB0ZW5zb3IgQi4gU2hvdWxkIGJlIGFuIGFycmF5IG9mIHBvc2l0aXZlIGludGVnZXJzXG4gICAqIEBwYXJhbSBpc01hdE11bCBXaGV0aGVyIHRoZSBvcGVyYXRpb24gaXMgTWF0TXVsXG4gICAqIEByZXR1cm5zIFRoZSBleHBlY3RlZCBzaGFwZSBvZiB0aGUgcmVzdWx0LCBvciB1bmRlZmluZWQgaWYgTi9BXG4gICAqL1xuICBzdGF0aWMgY2FsY1NoYXBlKGFkaW1zOiByZWFkb25seSBudW1iZXJbXSwgYmRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBpc01hdE11bCA9IGZhbHNlKTogcmVhZG9ubHkgbnVtYmVyW118dW5kZWZpbmVkIHtcbiAgICBjb25zdCBhcmFuayA9IGFkaW1zLmxlbmd0aDtcbiAgICBjb25zdCBicmFuayA9IGJkaW1zLmxlbmd0aDtcbiAgICBpZiAoYXJhbmsgPT09IDApIHtcbiAgICAgIHJldHVybiBiZGltcztcbiAgICB9XG4gICAgaWYgKGJyYW5rID09PSAwKSB7XG4gICAgICByZXR1cm4gYWRpbXM7XG4gICAgfVxuICAgIGNvbnN0IGNyYW5rID0gTWF0aC5tYXgoYWRpbXMubGVuZ3RoLCBiZGltcy5sZW5ndGgpO1xuICAgIGNvbnN0IGNkaW1zID0gbmV3IEFycmF5PG51bWJlcj4oY3JhbmspO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBsYXN0IDIgZGltZW5zaW9uIGlmIGl0IGlzIE1hdE11bFxuICAgIGlmIChpc01hdE11bCkge1xuICAgICAgaWYgKGFyYW5rIDwgMiB8fCBicmFuayA8IDIpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNTaGFwZU1hdE11bCA9XG4gICAgICAgICAgTWF0TXVsVXRpbC5jYWxjTWF0TXVsU2hhcGUoW2FkaW1zW2FyYW5rIC0gMl0sIGFkaW1zW2FyYW5rIC0gMV1dLCBbYmRpbXNbYnJhbmsgLSAyXSwgYmRpbXNbYnJhbmsgLSAxXV0pO1xuICAgICAgaWYgKGNTaGFwZU1hdE11bCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBbY2RpbXNbY3JhbmsgLSAyXSwgY2RpbXNbY3JhbmsgLSAxXV0gPSBjU2hhcGVNYXRNdWw7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IGlzTWF0TXVsID8gMyA6IDE7IGkgPD0gY3Jhbms7IGkrKykge1xuICAgICAgY29uc3QgYUxlbiA9IGFyYW5rIC0gaSA8IDAgPyAxIDogYWRpbXNbYXJhbmsgLSBpXTtcbiAgICAgIGNvbnN0IGJMZW4gPSBicmFuayAtIGkgPCAwID8gMSA6IGJkaW1zW2JyYW5rIC0gaV07XG5cbiAgICAgIGlmIChhTGVuICE9PSBiTGVuICYmIGFMZW4gPiAxICYmIGJMZW4gPiAxKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBjb25zdCBtYXggPSBNYXRoLm1heChhTGVuLCBiTGVuKTtcbiAgICAgIGlmIChhTGVuICYmIGJMZW4pIHtcbiAgICAgICAgY2RpbXNbY3JhbmsgLSBpXSA9IE1hdGgubWF4KGFMZW4sIGJMZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2hlbiBlaXRoZXIgYUxlbiBvciBiTGVuIGlzIDAsIHRoZSBvdGhlciBzaG91bGQgYmUgZWl0aGVyIDAgb3IgMSwgb3RoZXJ3aXNlIGl0IGlzIG5vdCBicm9hZGNhc3RhYmxlLlxuICAgICAgICBpZiAobWF4ID4gMSkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2RpbXNbY3JhbmsgLSBpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNkaW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiBhIHNoYXBlIGlzIHVuaWRpcmVjdGlvbmFsIGJyb2FkY2FzdGFibGUgdG8gYW5vdGhlciBzaGFwZVxuICAgKiBAcGFyYW0gc2hhcGUgVGhlIGlucHV0IHNoYXBlXG4gICAqIEBwYXJhbSBmaW5hbFNoYXBlIFRoZSBkZXNpcmVkIHNoYXBlIGFmdGVyIGJyb2FkY2FzdGluZ1xuICAgKi9cbiAgc3RhdGljIGlzVmFsaWRCcm9hZGNhc3Qoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBmaW5hbFNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IGJvb2xlYW4ge1xuICAgIC8vIGFsaWduIHNoYXBlIHRvIHRoZSByaWdodFxuICAgIGNvbnN0IGlucHV0UmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBmaW5hbFJhbmsgPSBmaW5hbFNoYXBlLmxlbmd0aDtcbiAgICBpZiAoaW5wdXRSYW5rID4gZmluYWxSYW5rKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGlucHV0UmFuazsgaSsrKSB7XG4gICAgICBpZiAoc2hhcGVbaW5wdXRSYW5rIC0gaV0gIT09IDEgJiYgc2hhcGVbaW5wdXRSYW5rIC0gaV0gIT09IGZpbmFsU2hhcGVbZmluYWxSYW5rIC0gaV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5cbmV4cG9ydCBjbGFzcyBTaGFwZVV0aWwge1xuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBzaXplIChudW1iZXIgb2YgZWxlbWVudHMpXG4gICAqL1xuICBzdGF0aWMgc2l6ZShkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlciB7XG4gICAgcmV0dXJuIFNoYXBlVXRpbC5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGRpbXMsIDAsIGRpbXMubGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjb252ZXJ0IGRpbXMgY29ycmVzcG9uZGluZyB0byB0eXBlIGNoYW5nZSB0byBwYWNrLiBleC4gdWludDggZGF0YSB0byB1aW50MzJcbiAgICovXG4gIHN0YXRpYyBjb252ZXJ0U2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIHNpemUgPSA0KTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGNvbnN0IHJhbmsgPSBkaW1zLmxlbmd0aDtcbiAgICBpZiAocmFuayA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBuZXdEaW1zID0gbmV3IEFycmF5KHJhbmspO1xuICAgIGxldCBpID0gcmFuayAtIDE7XG4gICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgaWYgKGRpbXNbaV0gJSBzaXplID09PSAwKSB7XG4gICAgICAgIG5ld0RpbXNbaV0gPSBkaW1zW2ldIC8gc2l6ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc2l6ZSAlIGRpbXNbaV0gIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY29udmVydCBzaGFwZScpO1xuICAgICAgfVxuICAgICAgbmV3RGltc1tpXSA9IDE7XG4gICAgICBzaXplIC89IGRpbXNbaV07XG4gICAgICBpLS07XG4gICAgfVxuICAgIGZvciAoaS0tOyBpID49IDA7IGktLSkge1xuICAgICAgbmV3RGltc1tpXSA9IGRpbXNbaV07XG4gICAgfVxuICAgIHJldHVybiBuZXdEaW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgc2l6ZSAobnVtYmVyIG9mIGVsZW1lbnRzKSBmcm9tIHRoZSBnaXZlbiBheGlzIChpbmNsdXNpdmUpXG4gICAqL1xuICBzdGF0aWMgc2l6ZUZyb21EaW1lbnNpb24oZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4aXM6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKGF4aXMgPCAwIHx8IGF4aXMgPiBkaW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke2F4aXN9IGZvciBzaXplRnJvbURpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7ZGltcy5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7XG4gICAgfVxuICAgIHJldHVybiBTaGFwZVV0aWwuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZShkaW1zLCBheGlzLCBkaW1zLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBzaXplIChudW1iZXIgb2YgZWxlbWVudHMpIHRvIHRoZSBnaXZlbiBheGlzIChleGNsdXNpdmUpXG4gICAqL1xuICBzdGF0aWMgc2l6ZVRvRGltZW5zaW9uKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGlzOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChheGlzIDwgMCB8fCBheGlzID4gZGltcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaW1lbnNpb24gb2YgJHtheGlzfSBmb3Igc2l6ZVRvRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHtkaW1zLmxlbmd0aH0gZGltZW5zaW9ucy5gKTtcbiAgICB9XG4gICAgcmV0dXJuIFNoYXBlVXRpbC5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGRpbXMsIDAsIGF4aXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgc2l6ZSAobnVtYmVyIG9mIGVsZW1lbnRzKSBmcm9tIGFuZCB0byB0aGUgZ2l2ZW4gYXhpcyBbc3RhcnQsIGVuZClcbiAgICovXG4gIHN0YXRpYyBnZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcik6IG51bWJlciB7XG4gICAgbGV0IHNpemUgPSAxO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAvLyBzYWZldHkgY2hlY2sgYXMgdGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IG11bHRpcGxlIG90aGVyIG1ldGhvZHMgcmVxdWlyaW5nIHNpemUuXG4gICAgICAvLyBzaXplIGNhbm5vdCBiZSBuZWdhdGl2ZS5cbiAgICAgIGlmIChkaW1zW2ldIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgICAgICAgICAgJ2Nhbm5vdCBnZXQgdmFsaWQgc2l6ZSBmcm9tIHNwZWNpZmllZCBkaW1lbnNpb24gcmFuZ2UuIE1vc3QgbGlrZWx5IHRoZSByYW5nZSBjb250YWlucyBuZWdhdGl2ZSB2YWx1ZXMgaW4gdGhlbS4nKTtcbiAgICAgIH1cbiAgICAgIHNpemUgKj0gZGltc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG4gIH1cblxuICBzdGF0aWMgY29tcHV0ZVN0cmlkZXMoZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgY29uc3QgcmFuayA9IGRpbXMubGVuZ3RoO1xuICAgIGlmIChyYW5rID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIGlmIChyYW5rID09PSAxKSB7XG4gICAgICByZXR1cm4gWzFdO1xuICAgIH1cbiAgICBjb25zdCBzdHJpZGVzID0gbmV3IEFycmF5KHJhbmspO1xuICAgIHN0cmlkZXNbcmFuayAtIDFdID0gMTtcbiAgICBzdHJpZGVzW3JhbmsgLSAyXSA9IGRpbXNbcmFuayAtIDFdO1xuICAgIGZvciAobGV0IGkgPSByYW5rIC0gMzsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHN0cmlkZXNbaV0gPSBzdHJpZGVzW2kgKyAxXSAqIGRpbXNbaSArIDFdO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaWRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBub3JtYWlsemUgYXhpcyBvZiByYW5nZSBbLXIsIHIpIGludG8gWzAsIHIpLlxuICAgKi9cbiAgc3RhdGljIG5vcm1hbGl6ZUF4aXMoYXhpczogbnVtYmVyLCB0ZW5zb3JSYW5rOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChheGlzIDwgLXRlbnNvclJhbmsgJiYgYXhpcyA+PSB0ZW5zb3JSYW5rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIGF4aXMgZm9yIHRoaXMgb3BlcmF0aW9uLicpO1xuICAgIH1cbiAgICByZXR1cm4gYXhpcyA8IDAgPyBheGlzICsgdGVuc29yUmFuayA6IGF4aXM7XG4gIH1cblxuICBzdGF0aWMgbm9ybWFsaXplQXhlcyhheGVzOiByZWFkb25seSBudW1iZXJbXSwgdGVuc29yUmFuaz86IG51bWJlcik6IG51bWJlcltdIHtcbiAgICByZXR1cm4gYXhlcy5tYXAoeCA9PiB0aGlzLm5vcm1hbGl6ZUF4aXMoeCwgdGVuc29yUmFuayA/PyBheGVzLmxlbmd0aCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNvcnRzIGEgZ2l2ZW4gYXJyYXkgYmFzZWQgb24gdGhlIGluZGljZXMgaW4gdGhlIFBlcm0gYXJyYXlcbiAgICogVXNlZCBpbiBUcmFuc3Bvc2VcbiAgICogQHBhcmFtIGEgQXJyYXkgdG8gYmUgc29ydGVkIHN1Y2ggYXMgZGltcyBvciBzdHJpZGVzXG4gICAqIEBwYXJhbSBwZXJtIFBlcm0gZ2l2ZW47IGlmIG51bGwgYSB3aWxsIGJlIHJldmVyc2VkXG4gICAqL1xuICBzdGF0aWMgc29ydEJhc2VkT25QZXJtKGE6IHJlYWRvbmx5IG51bWJlcltdLCBwZXJtPzogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgaWYgKHBlcm0pIHtcbiAgICAgIHJldHVybiBwZXJtLm1hcCgodikgPT4gYVt2XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYWRzIGEgZ2l2ZW4gc2hhcGUgYWNjb3JkaW5nIHRvIHRoZSBwYWRkaW5nIHZhbHVlc1xuICAgKiBAcGFyYW0gZGltcyBzaGFwZSBvZiB0aGUgVGVuc29yIHRvIGJlIHBhZGRlZFxuICAgKiBAcGFyYW0gcGFkIHBhZCB2YWx1ZXNcbiAgICovXG4gIHN0YXRpYyBwYWRTaGFwZShkaW1zOiByZWFkb25seSBudW1iZXJbXSwgcGFkOiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBjb25zdCByYW5rID0gZGltcy5sZW5ndGg7XG4gICAgcmV0dXJuIGRpbXMubWFwKCh2LCBpKSA9PiB2ICsgcGFkW2ldICsgcGFkW2kgKyByYW5rXSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgdHdvIHNoYXBlcyBhcmUgaWRlbnRpY2FsXG4gICAqIEBwYXJhbSBzaGFwZTFcbiAgICogQHBhcmFtIHNoYXBlMlxuICAgKi9cbiAgc3RhdGljIGFyZUVxdWFsKHNoYXBlMTogcmVhZG9ubHkgbnVtYmVyW10sIHNoYXBlMjogcmVhZG9ubHkgbnVtYmVyW10pOiBib29sZWFuIHtcbiAgICBpZiAoc2hhcGUxLmxlbmd0aCAhPT0gc2hhcGUyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc2hhcGUxLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBzaGFwZTJbaV0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQb29sQ29udlV0aWwge1xuICAvKipcbiAgICogQWRqdXN0IHRoZSBrZXJuZWwsIHN0cmlkZXMsIHBhZHMgdG8gY29ycmVjdCByYW5rLiBTZXQgdG8gZGVmYXVsdCB2YWx1ZSBpZiBub3QgcHJlc2VudFxuICAgKiBAcGFyYW0gaXNHbG9iYWxPcGVyYXRvciBJZiB0cnVlLCBwZXJmb3JtIGdsb2JhbCBwb29saW5nLlxuICAgKiBAcGFyYW0gaW5wdXREaW1zIFRoZSBpbnB1dCB0ZW5zb3IgZGltZW5zaW9uLlxuICAgKiBAcGFyYW0ga2VybmVsU2hhcGUgVGhlIHNpemUgb2YgdGhlIGtlcm5lbCBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBzdHJpZGVzIFN0cmlkZSBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBkaWxhdGlvbnMgRGlsYXRpb24gYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gcGFkcyBQYWRkaW5nIGZvciB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgYWxvbmcgZWFjaCBheGlzLlxuICAgKi9cbiAgc3RhdGljIGFkanVzdFBvb2xBdHRyaWJ1dGVzKFxuICAgICAgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbiwgaW5wdXREaW1zOiByZWFkb25seSBudW1iZXJbXSwga2VybmVsU2hhcGU6IG51bWJlcltdLCBzdHJpZGVzOiBudW1iZXJbXSxcbiAgICAgIGRpbGF0aW9uczogbnVtYmVyW10sIHBhZHM6IG51bWJlcltdKTogdm9pZCB7XG4gICAgaWYgKCFpc0dsb2JhbE9wZXJhdG9yICYmIGtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gaW5wdXREaW1zLmxlbmd0aCAtIDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIG9mIHNwZWNpZmllZCBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSAyIGxlc3MgdGhhbiBsZW5ndGggb2YgaW5wdXQgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGlmIChpc0dsb2JhbE9wZXJhdG9yKSB7XG4gICAgICAvLyBhZGp1c3Qga2VybmVsIHNoYXBlIHRvIGNvdmVyIHRoZSBpbnB1dCBkaW1zXG4gICAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBpbnB1dERpbXMubGVuZ3RoIC0gMjsgZGltKyspIHtcbiAgICAgICAgaWYgKGRpbSA+PSBrZXJuZWxTaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgICBrZXJuZWxTaGFwZS5wdXNoKGlucHV0RGltc1tkaW0gKyAyXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2VybmVsU2hhcGVbZGltXSA9IGlucHV0RGltc1tkaW0gKyAyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkanVzdCBzdHJpZGVzIGxlbmd0aCB0byBtYXRjaCBrZXJuZWwgc2hhcGUgbGVuZ3RoXG4gICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwga2VybmVsU2hhcGUubGVuZ3RoOyBkaW0rKykge1xuICAgICAgaWYgKGRpbSA8IHN0cmlkZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzdHJpZGVzW2RpbV0gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpZGVzIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJpZGVzLnB1c2goMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IGRpbGF0aW9uIHZhbHVlXG4gICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwga2VybmVsU2hhcGUubGVuZ3RoOyBkaW0rKykge1xuICAgICAgaWYgKGRpbSA8IGRpbGF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGRpbGF0aW9uc1tkaW1dIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlsYXRpb25zIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWxhdGlvbnMucHVzaCgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGp1c3QgcGFkcyBsZW5ndGggdG8gbWF0Y2ggMiAqIGtlcm5lbCBzaGFwZSBsZW5ndGhcbiAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBrZXJuZWxTaGFwZS5sZW5ndGggKiAyOyBkaW0rKykge1xuICAgICAgaWYgKGRpbSA8IHBhZHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChwYWRzW2RpbV0gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhZHMucHVzaCgwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzYW5pdHkgY2hlY2tzIGZvciB2YWx1ZXMgaW4ga2VybmVsIHNoYXBlcyBhbmQgcGFkc1xuICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGtlcm5lbFNoYXBlLmxlbmd0aDsgZGltKyspIHtcbiAgICAgIGlmIChrZXJuZWxTaGFwZVtkaW1dIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXJuZWwgc2hhcGVzIG5lZWQgdG8gYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhZHNbZGltXSA+PSBrZXJuZWxTaGFwZVtkaW1dIHx8IHBhZHNbZGltICsga2VybmVsU2hhcGUubGVuZ3RoXSA+PSBrZXJuZWxTaGFwZVtkaW1dKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkcyBzaG91bGQgYmUgc21hbGxlciB0aGFuIGtlcm5lbCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkanVzdCBwYWQgdmFsdWVzIGJhc2VkIG9uICdhdXRvUGFkJyBhdHRyaWJ1dGVcbiAgc3RhdGljIGFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZChcbiAgICAgIGlucHV0RGltczogcmVhZG9ubHkgbnVtYmVyW10sIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdLCBkaWxhdGlvbnM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgICAga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBwYWRzOiBudW1iZXJbXSwgaXNDaGFubmVsTGFzdDogYm9vbGVhbiwgYXV0b1BhZD86IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICghYXV0b1BhZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwYWRzLmxlbmd0aCAhPT0gMiAqIChpbnB1dERpbXMubGVuZ3RoIC0gMikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIG9mIHBhZHMgc2hvdWxkIGJlIHR3aWNlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zJyk7XG4gICAgfVxuXG4gICAgaWYgKHN0cmlkZXMubGVuZ3RoICE9PSAoaW5wdXREaW1zLmxlbmd0aCAtIDIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiBzdHJpZGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGlmIChrZXJuZWxTaGFwZS5sZW5ndGggIT09IChpbnB1dERpbXMubGVuZ3RoIC0gMikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIG9mIGtlcm5lbCBzaGFwZXMgc2hvdWxkIGJlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zJyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgaW5wdXREaW1zLmxlbmd0aCAtIDI7IGRpbSsrKSB7XG4gICAgICBQb29sQ29udlV0aWwuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoXG4gICAgICAgICAgaW5wdXREaW1zW2RpbSArIChpc0NoYW5uZWxMYXN0ID8gMSA6IDIpXSwgc3RyaWRlc1tkaW1dLCBkaWxhdGlvbnNbZGltXSwga2VybmVsU2hhcGVbZGltXSwgcGFkcywgZGltLFxuICAgICAgICAgIGRpbSArIGlucHV0RGltcy5sZW5ndGggLSAyLCBhdXRvUGFkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBvdXRwdXQgc2hhcGUgZm9yIFBvb2wgb3BzIGJhc2VkIG9uIGlucHV0IGF0dHJpYnV0ZXMuIChTaG91bGQgYmUgdXNlZCBvbmx5IGZvciBQb29sIG9wcylcbiAgICogQHBhcmFtIGlzR2xvYmFsT3BlcmF0b3IgSWYgdHJ1ZSwgcGVyZm9ybSBnbG9iYWwgcG9vbGluZy5cbiAgICogQHBhcmFtIGlucHV0RGltcyBUaGUgaW5wdXQgdGVuc29yIGRpbWVuc2lvbi4gKGlucHV0c1swXS5kaW1zKVxuICAgKiBAcGFyYW0gc3RyaWRlcyBTdHJpZGUgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gZGlsYXRpb25zIERpbGF0aW9uIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIGtlcm5lbFNoYXBlIFRoZSBzaXplIG9mIHRoZSBrZXJuZWwgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gcGFkcyBQYWRkaW5nIGZvciB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gYXV0b1BhZCBERVBSRUNBVEVEIGF0dHJpYnV0ZSBzdXBwb3J0ZWQgZm9yIGxlZ2FjeSBtb2RlbHMuIFNwZWNpZmllcyBob3cgdG8gaW1wbGljaXRseSBjYWxjdWxhdGUgcGFkcyBpbiBlYWNoXG4gICAqICAgICBkaW1lbnNpb24uIENhbiB0YWtlIHZhbHVlcyBOT1RTRVQsIFNBTUVfVVBQRVIsIFNBTUVfTE9XRVIsIG9yIFZBTElELlxuICAgKi9cbiAgc3RhdGljIGNvbXB1dGVQb29sT3V0cHV0U2hhcGUoXG4gICAgICBpc0dsb2JhbE9wZXJhdG9yOiBib29sZWFuLCBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBzdHJpZGVzOiBudW1iZXJbXSwgZGlsYXRpb25zOiBudW1iZXJbXSxcbiAgICAgIGtlcm5lbFNoYXBlOiBudW1iZXJbXSwgcGFkczogbnVtYmVyW10sIGF1dG9QYWQ/OiBzdHJpbmcpOiBudW1iZXJbXSB7XG4gICAgaWYgKGlucHV0RGltcy5sZW5ndGggPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBzaGFwZSBtdXN0IGJlIG9mIHNpemUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgYmF0Y2ggc2l6ZSBhbmQgbnVtYmVyIG9mIGNoYW5uZWxzIG9mIG91dHB1dFxuICAgIGNvbnN0IG91dHB1dERpbXMgPSBbaW5wdXREaW1zWzBdLCBpbnB1dERpbXNbMV1dO1xuXG4gICAgUG9vbENvbnZVdGlsLmNvbXB1dGVTaGFwZUhlbHBlcihcbiAgICAgICAgaXNHbG9iYWxPcGVyYXRvciwgaW5wdXREaW1zLCBvdXRwdXREaW1zLCBzdHJpZGVzLCBkaWxhdGlvbnMsIGtlcm5lbFNoYXBlLCBwYWRzLCBhdXRvUGFkKTtcbiAgICByZXR1cm4gb3V0cHV0RGltcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIG91dHB1dCBzaGFwZSBmb3IgQ29udiBvcCBiYXNlZCBvbiBpbnB1dCBhdHRyaWJ1dGVzLiAoU2hvdWxkIGJlIHVzZWQgb25seSBmb3IgQ29udiBvcClcbiAgICogQHBhcmFtIGlucHV0RGltcyBUaGUgaW5wdXQgdGVuc29yIGRpbWVuc2lvbi4gKGlucHV0c1swXS5kaW1zKVxuICAgKiBAcGFyYW0gZmlsdGVyRGltcyBUaGUgZmlsdGVyIHRlbnNvciBkaW1lbnNpb24uIChpbnB1dHNbMV0uZGltcylcbiAgICogQHBhcmFtIHN0cmlkZXMgU3RyaWRlIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIGtlcm5lbFNoYXBlIFRoZSBzaXplIG9mIHRoZSBrZXJuZWwgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gcGFkcyBQYWRkaW5nIGZvciB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gYXV0b1BhZCBERVBSRUNBVEVEIGF0dHJpYnV0ZSBzdXBwb3J0ZWQgZm9yIGxlZ2FjeSBtb2RlbHMuIFNwZWNpZmllcyBob3cgdG8gaW1wbGljaXRseSBjYWxjdWxhdGUgcGFkcyBpbiBlYWNoXG4gICAqICAgICBkaW1lbnNpb24uIENhbiB0YWtlIHZhbHVlcyBOT1RTRVQsIFNBTUVfVVBQRVIsIFNBTUVfTE9XRVIsIG9yIFZBTElELlxuICAgKi9cbiAgc3RhdGljIGNvbXB1dGVDb252T3V0cHV0U2hhcGUoXG4gICAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBmaWx0ZXJEaW1zOiByZWFkb25seSBudW1iZXJbXSwgc3RyaWRlczogbnVtYmVyW10sIGRpbGF0aW9uczogbnVtYmVyW10sXG4gICAgICBrZXJuZWxTaGFwZTogbnVtYmVyW10sIHBhZHM6IG51bWJlcltdLCBhdXRvUGFkPzogc3RyaW5nKTogbnVtYmVyW10ge1xuICAgIGlmIChpbnB1dERpbXMubGVuZ3RoIDw9IDAgfHwgZmlsdGVyRGltcy5sZW5ndGggPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGlucHV0IHRlbnNvciBkaW1zIG9yIGludmFsaWQgZmlsdGVyIHRlbnNvciBkaW1zJyk7XG4gICAgfVxuXG4gICAgLy8gQWRkIGJhdGNoIHNpemUgYW5kIG51bWJlciBvZiBjaGFubmVscyBvZiBvdXRwdXRcbiAgICBjb25zdCBvdXRwdXREaW1zID0gW2lucHV0RGltc1swXSwgZmlsdGVyRGltc1swXV07XG5cbiAgICBQb29sQ29udlV0aWwuY29tcHV0ZVNoYXBlSGVscGVyKGZhbHNlLCBpbnB1dERpbXMsIG91dHB1dERpbXMsIHN0cmlkZXMsIGRpbGF0aW9ucywga2VybmVsU2hhcGUsIHBhZHMsIGF1dG9QYWQpO1xuICAgIHJldHVybiBvdXRwdXREaW1zO1xuICB9XG5cbiAgLy8gd2lsbCBjb21wdXRlIG91dHB1dCBzaGFwZXMgZm9yIGRhdGEgZGltZW5zaW9ucyBPTkxZIChpLmUuKSBubyBiYXRjaCBzaXplIGFuZCBjaGFubmVsc1xuICAvLyBjYWxsZWQgYnkgY29tcHV0ZVBvb2xPdXRwdXRTaGFwZSgpIGFuZCBjb21wdXRlQ29udk91dHB1dFNoYXBlKClcbiAgLy8gYWRqdXN0IHBhZHMgYmFzZWQgb24gJ2F1dG9QYWQnIGF0dHJpYnV0ZSBwcmlvciB0byBzaGFwZSBjb21wdXRhdGlvblxuICBwcml2YXRlIHN0YXRpYyBjb21wdXRlU2hhcGVIZWxwZXIoXG4gICAgICBpc0dsb2JhbE9wZXJhdG9yOiBib29sZWFuLCBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBvdXRwdXREaW1zOiBudW1iZXJbXSwgc3RyaWRlczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgICBkaWxhdGlvbnM6IHJlYWRvbmx5IG51bWJlcltdLCBrZXJuZWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHBhZHM6IG51bWJlcltdLCBhdXRvUGFkPzogc3RyaW5nKSB7XG4gICAgaWYgKGlzR2xvYmFsT3BlcmF0b3IpIHtcbiAgICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGlucHV0RGltcy5sZW5ndGggLSAyOyBkaW0rKykge1xuICAgICAgICBvdXRwdXREaW1zLnB1c2goMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGlucHV0RGltcy5sZW5ndGggLSAyOyBkaW0rKykge1xuICAgICAgICBvdXRwdXREaW1zLnB1c2goUG9vbENvbnZVdGlsLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKFxuICAgICAgICAgICAgaW5wdXREaW1zW2RpbSArIDJdLCBzdHJpZGVzW2RpbV0sIGRpbGF0aW9uc1tkaW1dLCBrZXJuZWxTaGFwZVtkaW1dLCBwYWRzLCBkaW0sIGRpbSArIGlucHV0RGltcy5sZW5ndGggLSAyLFxuICAgICAgICAgICAgYXV0b1BhZCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGhlbHBlciBmb3IgY29tcHV0ZVNoYXBlSGVscGVyKCkgYW5kIGFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCgpXG4gIC8vIGFkanVzdHMgcGFkIHZhbHVlIGZvciBnaXZlbiAnYXV0b1BhZCcgc3RyaW5nIGFuZCBjb21wdXRlcyBvdXRwdXQgc2hhcGUgYWxvbmcgYSBwYXJ0aWN1bGFyIGRpbWVuc2lvblxuICBwcml2YXRlIHN0YXRpYyBhZGp1c3RQYWRBbmRSZXR1cm5TaGFwZShcbiAgICAgIGluU2l6ZTogbnVtYmVyLCBzdHJpZGU6IG51bWJlciwgZGlsYXRpb246IG51bWJlciwga2VybmVsOiBudW1iZXIsIHBhZHM6IG51bWJlcltdLCBwYWRIZWFkSW5kZXg6IG51bWJlcixcbiAgICAgIHBhZFRhaWxJbmRleDogbnVtYmVyLCBhdXRvUGFkPzogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBjb25zdCBka2VybmVsID0gZGlsYXRpb24gKiAoa2VybmVsIC0gMSkgKyAxO1xuICAgIGlmIChhdXRvUGFkICYmIGF1dG9QYWQgIT09ICdOT1RTRVQnKSB7XG4gICAgICBzd2l0Y2ggKGF1dG9QYWQpIHtcbiAgICAgICAgY2FzZSAnVkFMSUQnOlxuICAgICAgICAgIHBhZHNbcGFkSGVhZEluZGV4XSA9IDA7XG4gICAgICAgICAgcGFkc1twYWRUYWlsSW5kZXhdID0gMDtcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoKGluU2l6ZSAtIGRrZXJuZWwpIC8gc3RyaWRlKSArIDEpO1xuICAgICAgICBjYXNlICdTQU1FX0xPV0VSJzpcbiAgICAgICAgY2FzZSAnU0FNRV9VUFBFUic6XG4gICAgICAgICAgaWYgKGRpbGF0aW9uICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpbGF0aW9uIG5vdCBzdXBwb3J0ZWQgZm9yIFNBTUVfVVBQRVIgb3IgU0FNRV9MT1dFUicpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBsZWdhY3lUYXJnZXRTaXplID0gKGluU2l6ZSArIHN0cmlkZSAtIDEpIC8gc3RyaWRlO1xuICAgICAgICAgICAgY29uc3QgcGFkTmVlZGVkID0gKGxlZ2FjeVRhcmdldFNpemUgLSAxKSAqIHN0cmlkZSArIGtlcm5lbCAtIGluU2l6ZTtcbiAgICAgICAgICAgIHBhZHNbcGFkSGVhZEluZGV4XSA9XG4gICAgICAgICAgICAgICAgKGF1dG9QYWQgPT09ICdTQU1FX0xPV0VSJykgPyBNYXRoLmZsb29yKChwYWROZWVkZWQgKyAxKSAvIDIpIDogTWF0aC5mbG9vcihwYWROZWVkZWQgLyAyKTtcbiAgICAgICAgICAgIHBhZHNbcGFkVGFpbEluZGV4XSA9IHBhZE5lZWRlZCAtIHBhZHNbcGFkSGVhZEluZGV4XTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKCgoaW5TaXplICsgcGFkTmVlZGVkIC0ga2VybmVsKSAvIHN0cmlkZSkgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBBdXRvUGFkIHR5cGUnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKChpblNpemUgKyBwYWRzW3BhZEhlYWRJbmRleF0gKyBwYWRzW3BhZFRhaWxJbmRleF0gLSBka2VybmVsKSAvIHN0cmlkZSkgKyAxKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEdlbW1VdGlsIHtcbiAgLy8gd2lsbCBtYWtlIHN1cmUgaW5wdXQgc2hhcGVzIGFyZSBjb21wYXRpYmxlIGZvciB0aGlzIG9wXG4gIC8vIGFuZCByZXR1cm4gYmFjayB0aGUgc2hhcGUgb2YgdGhlIG91dHB1dCBpbiB0aGUgZm9ybSBvZiBhIHR1cGxlXG4gIC8vIHdpbGwgdGhyb3cgZXhjZXB0aW9uIGlmIHRoZSBpbnB1dCBzaGFwZXMgYXJlIG5vdCBjb21wYXRpYmxlXG4gIHN0YXRpYyBnZXRTaGFwZU9mR2VtbVJlc3VsdChcbiAgICAgIGxlZnRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHRyYW5zTGVmdDogYm9vbGVhbiwgcmlnaHRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHRyYW5zUmlnaHQ6IGJvb2xlYW4sXG4gICAgICBiaWFzU2hhcGU/OiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBpZiAobGVmdFNoYXBlLmxlbmd0aCAhPT0gMiB8fCByaWdodFNoYXBlLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaGFwZSBuZWVkIHRvIGJlIG9mIHNpemUgMicpO1xuICAgIH1cblxuICAgIGxldCBNOiBudW1iZXI7XG4gICAgbGV0IEs6IG51bWJlcjtcbiAgICBsZXQgTjogbnVtYmVyO1xuXG4gICAgaWYgKHRyYW5zTGVmdCkge1xuICAgICAgTSA9IGxlZnRTaGFwZVsxXTtcbiAgICAgIEsgPSBsZWZ0U2hhcGVbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIE0gPSBsZWZ0U2hhcGVbMF07XG4gICAgICBLID0gbGVmdFNoYXBlWzFdO1xuICAgIH1cblxuICAgIGxldCBrRGltID0gLTE7XG5cbiAgICBpZiAodHJhbnNSaWdodCkge1xuICAgICAgTiA9IHJpZ2h0U2hhcGVbMF07XG4gICAgICBrRGltID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgTiA9IHJpZ2h0U2hhcGVbMV07XG4gICAgICBrRGltID0gMDtcbiAgICB9XG5cbiAgICBpZiAocmlnaHRTaGFwZVtrRGltXSAhPT0gSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaW1lbnNpb24gbWlzbWF0Y2gnKTtcbiAgICB9XG5cbiAgICBpZiAoTSA8PSAwIHx8IE4gPD0gMCB8fCBLIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzaGFwZSBzcGVjaWZpZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoYmlhc1NoYXBlICYmICFCcm9hZGNhc3RVdGlsLmlzVmFsaWRCcm9hZGNhc3QoYmlhc1NoYXBlLCBbTSwgTl0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlbW06IGludmFsaWQgYmlhcyBzaGFwZSBmb3IgYnJvYWRjYXN0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtNLCBOLCBLXTtcbiAgfVxufVxuXG5cbmV4cG9ydCBjb25zdCBNSU5fQ0xJUCA9IC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4O1xuZXhwb3J0IGNvbnN0IE1BWF9DTElQID0gMy40MDI4MjM0NjYzODUyODg2ZSszODtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtQcm9ncmFtVW5pZm9ybSwgUHJvZ3JhbVVuaWZvcm1WYXJpYWJsZUluZm99IGZyb20gJy4uL3R5cGVzJztcblxuLyoqXG4gKiBjb25zdGFudCB2YWx1ZSBmb3IgYSB3b3JrZ3JvdXAgc2l6ZS5cbiAqXG4gKiBXZSBkZWZpbml0ZWx5IGNhbiBkbyBmdXJ0aGVyIG9wdGltaXphdGlvbiBpbiBmdXR1cmUsIGJ1dCBmb3Igbm93IHdlIHVzZSA2NC5cbiAqXG4gKiBydWxlIG9mIHRodW1iOiBVc2UgW2Egd29ya2dyb3VwIHNpemUgb2ZdIDY0IHVubGVzcyB5b3Uga25vdyB3aGF0IEdQVSB5b3UgYXJlIHRhcmdldGluZyBvciB0aGF0IHlvdXIgd29ya2xvYWRcbiAqICAgICAgICAgICAgICAgIG5lZWRzIHNvbWV0aGluZyBkaWZmZXJlbnQuXG4gKlxuICogZnJvbTogaHR0cHM6Ly9zdXJtYS5kZXYvdGhpbmdzL3dlYmdwdS9cbiAqKi9cbmV4cG9ydCBjb25zdCBXT1JLR1JPVVBfU0laRSA9IDY0O1xuXG5pbnRlcmZhY2UgSW5kaWNlc0hlbHBlclR5cGVzIHtcbiAgLyoqXG4gICAqIFdHU0wgdHlwZSBvZiBpbmRpY2VzIGV4cHJlc3Npb25cbiAgICovXG4gIHJlYWRvbmx5IGluZGljZXM6IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCB0eXBlIG9mIGEgdmFsdWVcbiAgICovXG4gIHJlYWRvbmx5IHZhbHVlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgdHlwZSBvZiBzdG9yYWdlIHR5cGUgcmVwcmVzZW50aW5nIGEgdmFsdWVcbiAgICpcbiAgICogVGhpcyBpcyB1c3VhbGx5IHRoZSBzYW1lIHRvIGB2YWx1ZWAsIGJ1dCBmb3Igc29tZSB0eXBlIChlZy4gYm9vbCksIHdlIG5lZWQgdG8gdXNlIGB1MzJgIGFzIHN0b3JhZ2UgdHlwZSBmb3JcbiAgICogdmFsdWUgdHlwZSBgdmVjNDxib29sPmBcbiAgICovXG4gIHJlYWRvbmx5IHN0b3JhZ2U6IHN0cmluZztcblxuICAvKipcbiAgICogdGVuc29yIHR5cGUgYXMgcmVwcmVzZW50ZWQgaW4gVGVuc29yVmlld1xuICAgKi9cbiAgcmVhZG9ubHkgdGVuc29yOiBudW1iZXI7XG59XG5cbi8qKlxuICogQSBoZWxwZXIgY2xhc3MgZm9yIGdlbmVyYXRpbmcgV0dTTCBjb2RlIGZvciBtYW5pcHVsYXRpbmcgaW5kaWNlcyBhbmQgZGF0YSBmb3IgYSBzaGFkZXIncyBpbnB1dCBvciBvdXRwdXQuXG4gKlxuICogVGhpcyBjbGFzcyBpcyBkZXNpZ25lZCB0byBvZmZlciBhIHVuaWZpZWQgd2F5IHRvIGdlbmVyYXRlIFdHU0wgY29kZSBmb3IgbWFuaXB1bGF0aW5nIGluZGljZXMgYW5kIGRhdGEgZm9yIGEgc2hhZGVyJ3NcbiAqIGlucHV0IG9yIG91dHB1dC5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIGlzIGEgbGlzdCBvZiB0ZXJtaW5vbG9naWVzIHVzZWQgaW4gdGhpcyBjbGFzczpcbiAqIC0gYG9mZnNldGA6IGEgdWludDMyIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgb2Zmc2V0IG9mIGFuIGVsZW1lbnQgaW4gdGhlIGRhdGEgYnVmZmVyLlxuICogLSBgaW5kaWNlc2A6IGFuIGFic3RyYWN0aW9uIG9mIGEgbXVsdGktZGltZW5zaW9uYWwgYXJyYXkncyBpbmRpY2VzIHJlcHJlc2VudGluZyB0aGUgZGF0YSdzIGluZGV4IG9uIGVhY2ggZGltZW5zaW9uLlxuICogLSBgdmFsdWVgOiBhIHZhbHVlIG9mIGEgZGF0YSBlbGVtZW50LlxuICpcbiAqIFVzZXJzIGFyZSBleHBlY3RlZCB0byBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBmb3IgZWFjaCBzaGFkZXIncyBpbnB1dCBvciBvdXRwdXQsIGFuZCB1c2UgdGhlIGluc3RhbmNlIHRvXG4gKiBnZW5lcmF0ZSBXR1NMIGNvZGUgZm9yIG1hbmlwdWxhdGluZyBpbmRpY2VzIGFuZCBkYXRhLiBUaGUgZm9sbG93aW5nIDIgZXhwb3J0ZWQgZnVuY3Rpb25zIGFyZSBmb3IgdXNlcnMgdG8gY2FsbCB0b1xuICogY3JlYXRlIGFuIGluc3RhbmNlIG9mIGFuIGluZGljZXMgaGVscGVyOlxuICogLSBgaW5wdXRWYXJpYWJsZSgpYDogY3JlYXRlIGFuIGluZGljZXMgaGVscGVyIGluc3RhbmNlIGZvciBhbiBpbnB1dC5cbiAqIC0gYG91dHB1dFZhcmlhYmxlKClgOiBjcmVhdGUgYW4gaW5kaWNlcyBoZWxwZXIgaW5zdGFuY2UgZm9yIGFuIG91dHB1dC5cbiAqIC0gYGludGVybmFsVmFyaWFibGUoKWA6IGNyZWF0ZSBhbiBpbmRpY2VzIGhlbHBlciBpbnN0YW5jZSBmb3IgYW4gaW50ZXJuYWwgdmFyaWFibGUuXG4gKlxuICogQW4gaW5kaWNlcyBoZWxwZXIgaW5zdGFuY2UgY29udGFpbnMgaGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIGZvbGxvd2luZyBvcGVyYXRpb25zOlxuICogLSBhY2Nlc3MgcmVhZG9ubHkgYmFzaWMgaW5mb3JtYXRpb24sIGluY2x1ZGluZzogYG5hbWVgKHRoZSBuYW1lIG9mIHRoZSBpbnB1dCBvciBvdXRwdXQpLCBgdXNhZ2VgKHdoZXRoZXIgaXQncyBhblxuICogaW5wdXQsIGFuIG91dHB1dCBvciBhbiBpbnRlcm5hbCB2YXJpYWJsZSkgYW5kIGBzaGFwZWAodGhlIHBhc3NlZCBpbiBzaGFwZSkuXG4gKiAtIGB0eXBlYDogYWNjZXNzIHJlYWRvbmx5IHR5cGUgaW5mb3JtYXRpb24sIGluY2x1ZGluZzogYGluZGljZXNgKHRoZSB0eXBlIG9mIGluZGljZXMpLCBgdmFsdWVgKHRoZSB0eXBlIG9mIHZhbHVlIGF0XG4gKiBydW50aW1lKSwgYHN0b3JhZ2VgKHRoZSB0eXBlIG9mIHZhbHVlIGF0IHN0b3JhZ2UpIGFuZCBgdGVuc29yYCh0aGUgdGVuc29yIHR5cGUgYXMgcmVwcmVzZW50ZWQgaW4gVGVuc29yVmlldykuXG4gKiAtIGdlbmVyYXRlIFdHU0wgY29kZSBmb3IgZ2V0dGluZyBpbmRpY2VzIGZyb20gb2Zmc2V0LiBVc2UgYG9mZnNldFRvSW5kaWNlcygpYCBmb3IgV0dTTCBjb2RlIHNuaXBwZXQgdG8gY2FsY3VsYXRlXG4gKiBpbmRpY2VzIGZyb20gb2Zmc2V0LCBhbmQgdXNlIGBpbmRpY2VzVG9PZmZzZXQoKWAgZm9yIFdHU0wgY29kZSBzbmlwcGV0IHRvIGNhbGN1bGF0ZSBvZmZzZXQgZnJvbSBpbmRpY2VzLlxuICogLSB0byBtYW5pcHVsYXRlIGFuIGluc3RhbmNlIG9mIGluZGljZXMsIHVzZSBgc2V0SW5kaWNlcygpYCBhbmQgYGdldEluZGljZXMoKWAgdG8gc2V0IGFuZCBnZXQgdGhlIGluZGljZXMgb24gYW5cbiAqIGluZGljZXMgdmFyaWFibGUuXG4gKiAtIHRvIG1hbmlwdWxhdGUgZGF0YSwgdXNlIGBzZXQoKWAvYGdldCgpYCB0byBhY2Nlc3MgZGF0YSBhdCB0aGUgZ2l2ZW4gaW5kaWNlcyBmcm9tIHBhcmFtZXRlciBsaXN0LCB1c2VcbiAqIGBzZXRCeUluZGljZXMoKWAvYGdldEJ5SW5kaWNlcygpYCB0byBhY2Nlc3MgZGF0YSBhdCB0aGUgZ2l2ZW4gaW5kaWNlcyBmcm9tIGFuIGluZGljZXMgdmFyaWFibGUsIGFuZCB1c2VcbiAqIGBzZXRCeU9mZnNldCgpYC9gZ2V0QnlPZmZzZXQoKWAgdG8gYWNjZXNzIGRhdGEgYXQgdGhlIGdpdmVuIG9mZnNldC5cbiAqIC0gYGltcGxgOiBnZXQgV0dTTCBjb2RlIG9mIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uIGZvciB0aGUgdXRpbCBmdW5jdGlvbnMgbWVudGlvbmVkIGFib3ZlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEluZGljZXNIZWxwZXIge1xuICAvKipcbiAgICogZ2V0IFdHU0wgY29kZSBvZiBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHV0aWwgZnVuY3Rpb25zLlxuICAgKlxuICAgKi9cbiAgcmVhZG9ubHkgaW1wbDogKCkgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBnZXQgdHlwZSBpbmZvXG4gICAqL1xuICByZWFkb25seSB0eXBlOiBJbmRpY2VzSGVscGVyVHlwZXM7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBvZiBhIGV4cHJlc3Npb24gZm9yIGdldHRpbmcgaW5kaWNlcyBmcm9tIG9mZnNldC5cbiAgICpcbiAgICogQHBhcmFtIHZhck9mZnNldCAtIGEgdTMyIGV4cHJlc3Npb24gcmVwcmVzZW50aW5nIHRoZSBvZmZzZXQuXG4gICAqXG4gICAqIEByZXR1cm5zIGFuIGB0eXBlLmluZGljZXNgIGV4cHJlc3Npb25cbiAgICovXG4gIHJlYWRvbmx5IG9mZnNldFRvSW5kaWNlczogKHZhck9mZnNldDogc3RyaW5nKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBvZiBhbiBgdTMyYCBleHByZXNzaW9uIGZvciBnZXR0aW5nIG9mZnNldCBmcm9tIGluZGljZXMuXG4gICAqXG4gICAqIEBwYXJhbSB2YXJJbmRpY2VzIC0gYSBgdHlwZS5pbmRpY2VzYCBleHByZXNzaW9uIHJlcHJlc2VudGluZyB0aGUgaW5kaWNlcy5cbiAgICpcbiAgICogQHJldHVybnMgYW4gYHUzMmAgZXhwcmVzc2lvblxuICAgKi9cbiAgcmVhZG9ubHkgaW5kaWNlc1RvT2Zmc2V0OiAodmFySW5kaWNlczogc3RyaW5nKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBvZiBhbiBgdTMyYCBleHByZXNzaW9uIGZvciBnZXR0aW5nIG9yaWdpbmFsIG9mZnNldCBmcm9tIGJyb2FkY2FzdGVkIGluZGljZXMuXG4gICAqXG4gICAqIEBwYXJhbSB2YXJJbmRpY2VzIC0gYSBgdHlwZS5pbmRpY2VzYCBleHByZXNzaW9uIHJlcHJlc2VudGluZyB0aGUgb3V0cHV0IGluZGljZXMuXG4gICAqIEBwYXJhbSBvdXRwdXQgLSBvdXRwdXQgSW5kaWNlc0hlbHBlci5cbiAgICpcbiAgICogQHJldHVybnMgYW4gYHUzMmAgZXhwcmVzc2lvblxuICAgKi9cbiAgcmVhZG9ubHkgYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQ6ICh2YXJJbmRpY2VzOiBzdHJpbmcsIG91dHB1dDogSW5kaWNlc0hlbHBlcikgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgb2YgZ2VuZXJhdGluZyBhbiBpbmRpY2VzIGxpdGVyYWxcbiAgICpcbiAgICogQHBhcmFtIGluaXQgLSBpbml0aWFsIHZhbHVlLlxuICAgKi9cbiAgcmVhZG9ubHkgaW5kaWNlczogKC4uLmluaXQ6IFJlYWRvbmx5QXJyYXk8bnVtYmVyfHN0cmluZz4pID0+IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCBjb2RlIG9mIGEgc3RhdGVtZW50IGZvciBzZXR0aW5nIGluZGljZXMuXG4gICAqXG4gICAqIEBwYXJhbSB2YXJJbmRpY2VzIC0gYSB2YXJpYWJsZSBuYW1lIGZvciB0aGUgaW5kaWNlcy5cbiAgICogQHBhcmFtIGlkeCAtIHRoZSBpbmRleCBvZiB0aGUgaW5kaWNlcyB0byBzZXQuIGNhbiBiZSBhIG51bWJlciBvciBhIHN0cmluZyAoV0dTTCBgdTMyYCBleHByZXNzaW9uKS5cbiAgICogQHBhcmFtIHZhbHVlIC0gdGhlIHZhbHVlIHRvIHNldC4gY2FuIGJlIGEgbnVtYmVyIG9yIGEgc3RyaW5nIChXR1NMIGB1MzJgIGV4cHJlc3Npb24pLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIFdHU0wgc3RhdGVtZW50XG4gICAqL1xuICByZWFkb25seSBpbmRpY2VzU2V0OiAodmFySW5kaWNlczogc3RyaW5nLCBpZHg6IG51bWJlcnxzdHJpbmcsIHZhbHVlOiBudW1iZXJ8c3RyaW5nKSA9PiB2b2lkO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgb2YgYW4gYHUzMmAgZXhwcmVzc2lvbiBmb3IgZ2V0dGluZyBpbmRpY2VzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFySW5kaWNlcyAtIGEgdmFyaWFibGUgbmFtZSBmb3IgdGhlIGluZGljZXMuXG4gICAqIEBwYXJhbSBpZHggLSB0aGUgaW5kZXggb2YgdGhlIGluZGljZXMgdG8gZ2V0LiBjYW4gYmUgYSBudW1iZXIgb3IgYSBzdHJpbmcgKFdHU0wgYHUzMmAgZXhwcmVzc2lvbikuXG4gICAqXG4gICAqIEByZXR1cm5zIGFuIGB1MzJgIGV4cHJlc3Npb25cbiAgICovXG4gIHJlYWRvbmx5IGluZGljZXNHZXQ6ICh2YXJJbmRpY2VzOiBzdHJpbmcsIGlkeDogbnVtYmVyfHN0cmluZykgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgZm9yIGEgc3RhdGVtZW50IGZvciBzZXR0aW5nIGRhdGEgYXQgdGhlIGdpdmVuIGluZGljZXMuXG4gICAqXG4gICAqIEBwYXJhbSBpbmRpY2VzQW5kVmFsdWUgLSBhbiBhcnJheSBvZiBudW1iZXJzIG9yIHN0cmluZ3MgKFdHU0wgYHUzMmAgZXhwcmVzc2lvbikgcmVwcmVzZW50aW5nIHRoZSBpbmRpY2VzLCBmb2xsb3dlZFxuICAgKiAgICAgYnkgdGhlIHZhbHVlIHRvIHNldC4gVGhpcyBhcnJheSBzaG91bGQgaGF2ZSBleGFjdGx5IGBzaGFwZS5sZW5ndGggKyAxYCBlbGVtZW50cy5cbiAgICovXG4gIHJlYWRvbmx5IHNldDogKC4uLmluZGljZXNBbmRWYWx1ZTogUmVhZG9ubHlBcnJheTxudW1iZXJ8c3RyaW5nPikgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgZm9yIGEgc3RhdGVtZW50IGZvciBzZXR0aW5nIGRhdGEgYXQgdGhlIGdpdmVuIGluZGljZXMgdmFyaWFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB2YXJJbmRpY2VzIC0gYSB2YXJpYWJsZSBuYW1lIGZvciB0aGUgaW5kaWNlcy5cbiAgICogQHBhcmFtIHZhbHVlIC0gdGhlIHZhbHVlIHRvIHNldC4gc2hvdWxkIGJlIGEgV0dTTCBleHByZXNzaW9uLlxuICAgKi9cbiAgcmVhZG9ubHkgc2V0QnlJbmRpY2VzOiAodmFySW5kaWNlczogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBmb3IgYSBzdGF0ZW1lbnQgZm9yIHNldHRpbmcgZGF0YSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0LlxuICAgKlxuICAgKiBAcGFyYW0gb2Zmc2V0IC0gYSBudW1iZXIgb3IgYSBzdHJpbmcgKFdHU0wgYHUzMmAgZXhwcmVzc2lvbikgcmVwcmVzZW50aW5nIHRoZSBvZmZzZXQuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBzZXQuIHNob3VsZCBiZSBhIFdHU0wgZXhwcmVzc2lvbi5cbiAgICovXG4gIHJlYWRvbmx5IHNldEJ5T2Zmc2V0OiAob2Zmc2V0OiBudW1iZXJ8c3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBmb3IgYW4gZXhwcmVzc2lvbiBmb3IgZ2V0dGluZyBkYXRhIGF0IHRoZSBnaXZlbiBpbmRpY2VzLlxuICAgKlxuICAgKiBAcGFyYW0gaW5kaWNlcyAtIGFuIGFycmF5IG9mIG51bWJlcnMgb3Igc3RyaW5ncyAoV0dTTCBgdTMyYCBleHByZXNzaW9uKSByZXByZXNlbnRpbmcgdGhlIGluZGljZXMuXG4gICAqL1xuICByZWFkb25seSBnZXQ6ICguLi5pbmRpY2VzOiBSZWFkb25seUFycmF5PG51bWJlcnxzdHJpbmc+KSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBmb3IgYW4gZXhwcmVzc2lvbiBmb3IgZ2V0dGluZyBkYXRhIGF0IHRoZSBnaXZlbiBpbmRpY2VzIHZhcmlhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gdmFySW5kaWNlcyAtIGEgdmFyaWFibGUgbmFtZSBmb3IgdGhlIGluZGljZXMuXG4gICAqL1xuICByZWFkb25seSBnZXRCeUluZGljZXM6ICh2YXJJbmRpY2VzOiBzdHJpbmcpID0+IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCBjb2RlIGZvciBhbiBleHByZXNzaW9uIGZvciBnZXR0aW5nIGRhdGEgYXQgdGhlIGdpdmVuIG9mZnNldC5cbiAgICpcbiAgICogQHBhcmFtIG9mZnNldCAtIGEgbnVtYmVyIG9yIGEgc3RyaW5nIChXR1NMIGB1MzJgIGV4cHJlc3Npb24pIHJlcHJlc2VudGluZyB0aGUgb2Zmc2V0LlxuICAgKi9cbiAgcmVhZG9ubHkgZ2V0QnlPZmZzZXQ6IChvZmZzZXQ6IG51bWJlcnxzdHJpbmcpID0+IHN0cmluZztcblxuICAvKipcbiAgICogbmFtZSBvZiB0aGUgZGF0YSB2YXJpYWJsZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiB3aGV0aGVyIHRoZSBoZWxwZXIgaXMgZm9yIGFuIGlucHV0LCBhbiBvdXRwdXQgb3IgYW4gaW50ZXJuYWwgdmFyaWFibGUuXG4gICAqL1xuICByZWFkb25seSB1c2FnZTogJ2lucHV0J3wnb3V0cHV0J3wnaW50ZXJuYWwnO1xuXG4gIC8qKlxuICAgKiB0aGUgcmFuayBvZiB0aGUgaW5wdXQgb3Igb3V0cHV0LlxuICAgKi9cbiAgcmVhZG9ubHkgcmFuazogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhcmlhYmxlIG5hbWUgZm9yIHRoZSBzaGFwZSBvZiB0aGUgaW5wdXQgb3Igb3V0cHV0LlxuICAgKi9cbiAgcmVhZG9ubHkgc2hhcGU6IHN0cmluZztcblxuICAvKipcbiAgICogYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YXJpYWJsZSBuYW1lIGZvciB0aGUgc3RyaWRlcyBvZiB0aGUgaW5wdXQgb3Igb3V0cHV0LlxuICAgKi9cbiAgcmVhZG9ubHkgc3RyaWRlczogc3RyaW5nO1xufVxuXG5jb25zdCBnZXRXZ3NsTWFwcGVkVHlwZSA9ICh0eXBlOiBudW1iZXIsIGNvbXBvbmVudHM6IDF8MnwzfDQpOiBzdHJpbmd8W3N0cmluZywgc3RyaW5nXSA9PiB7XG4gIGlmIChjb21wb25lbnRzID09PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd2ZWMzIGhhcyBzYW1lIGFsaWdubWVudCBhcyB2ZWM0LCB1c2UgdmVjNCBpbnN0ZWFkJyk7XG4gIH1cblxuICAvLyByZXR1cm4gdHlwZSBpcyBbIHN0b3JhZ2UgdHlwZSwgcnVudGltZSB0eXBlIF0gb3IgYSBzaW5nbGUgc3RyaW5nIGZvciBib3RoXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgRGF0YVR5cGUuZmxvYXQxNjpcbiAgICAgIHJldHVybiBjb21wb25lbnRzID4gMSA/IGB2ZWMke2NvbXBvbmVudHN9PGYxNj5gIDogJ2YxNic7XG4gICAgY2FzZSBEYXRhVHlwZS5mbG9hdDpcbiAgICAgIHJldHVybiBjb21wb25lbnRzID4gMSA/IGB2ZWMke2NvbXBvbmVudHN9PGYzMj5gIDogJ2YzMic7XG4gICAgY2FzZSBEYXRhVHlwZS5pbnQzMjpcbiAgICAgIHJldHVybiBjb21wb25lbnRzID4gMSA/IGB2ZWMke2NvbXBvbmVudHN9PGkzMj5gIDogJ2kzMic7XG4gICAgY2FzZSBEYXRhVHlwZS51aW50MzI6XG4gICAgICByZXR1cm4gY29tcG9uZW50cyA+IDEgPyBgdmVjJHtjb21wb25lbnRzfTx1MzI+YCA6ICd1MzInO1xuICAgIGNhc2UgRGF0YVR5cGUuaW50NjQ6XG4gICAgICBpZiAoY29tcG9uZW50cyA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjdXJyZW50bHkgbm90IHN1cHBvcnRlZCB2ZWNYIG9mIHVpbnQ2NCB5ZXQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbJ3ZlYzI8dTMyPicsICdpMzInXTtcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQ2NDpcbiAgICAgIGlmIChjb21wb25lbnRzID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnRseSBub3Qgc3VwcG9ydGVkIHZlY1ggb2YgdWludDY0IHlldCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFsndmVjMjx1MzI+JywgJ3UzMiddO1xuICAgIGNhc2UgRGF0YVR5cGUuYm9vbDpcbiAgICAgIGlmIChjb21wb25lbnRzICE9PSA0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYm9vbCBtdXN0IGJlIHZlYzQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbJ3UzMicsICd2ZWM0PGJvb2w+J107XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRhdGEgdHlwZTogJHt0eXBlfWApO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlID0gKHR5cGU6IERhdGFUeXBlLCBjb21wb25lbnRzOiAxfDJ8M3w0ID0gMSkgPT4ge1xuICBjb25zdCBtYXBwZWRUeXBlID0gZ2V0V2dzbE1hcHBlZFR5cGUodHlwZSwgY29tcG9uZW50cyk7XG4gIHJldHVybiB0eXBlb2YgbWFwcGVkVHlwZSA9PT0gJ3N0cmluZycgPyBtYXBwZWRUeXBlIDogbWFwcGVkVHlwZVswXTtcbn07XG5cbmV4cG9ydCBjb25zdCB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlID0gKHR5cGU6IERhdGFUeXBlLCBjb21wb25lbnRzOiAxfDJ8M3w0ID0gMSkgPT4ge1xuICBjb25zdCBtYXBwZWRUeXBlID0gZ2V0V2dzbE1hcHBlZFR5cGUodHlwZSwgY29tcG9uZW50cyk7XG4gIHJldHVybiB0eXBlb2YgbWFwcGVkVHlwZSA9PT0gJ3N0cmluZycgPyBtYXBwZWRUeXBlIDogbWFwcGVkVHlwZVsxXTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyA9ICguLi5kaW1zOiBSZWFkb25seUFycmF5PHJlYWRvbmx5IG51bWJlcltdPik6IFByb2dyYW1Vbmlmb3JtW10gPT4ge1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXTtcbiAgZGltcy5mb3JFYWNoKGRpbSA9PiB7XG4gICAgaWYgKGRpbS5sZW5ndGggIT09IDApIHtcbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKFxuICAgICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGRpbX0sIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IFNoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhkaW0pfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHByb2dyYW1Vbmlmb3Jtcztcbn07XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IG1heGltdW0gdmVjdG9yIHNpemUgZm9yIHNwZWNpZmllZCBkYXRhIGxlbmd0aFxuICogQHBhcmFtIHNpemVcbiAqL1xuZXhwb3J0IGNvbnN0IGdldE1heENvbXBvbmVudHMgPSAoc2l6ZTogbnVtYmVyKSA9PiB7XG4gIC8vIHdlIGNhbm5vdCB1c2UgdmVjMyB0eXBlIHNpbmNlIGl0IGhhcyBhbGlnbm1lbnQgb2YgMTYgYnl0ZXNcbiAgaWYgKHNpemUgJSA0ID09PSAwKSB7XG4gICAgcmV0dXJuIDQ7XG4gIH0gZWxzZSBpZiAoc2l6ZSAlIDIgPT09IDApIHtcbiAgICByZXR1cm4gMjtcbiAgfVxuXG4gIHJldHVybiAxO1xufTtcblxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IGluaXRpYWxpemVzIHZhcmlhYmxlIGFzIGEgc2NhbGFyIG9yIHZlY3Rvci4gZS5nLiBmMzIoMCkgb3IgdmVjNGYoMCwwLDAsMClcbiAqIEBwYXJhbSBkYXRhVHlwZVxuICogQHBhcmFtIGNvbXBvbmVudHNcbiAqIEBwYXJhbSB2YWx1ZVxuICovXG5leHBvcnQgY29uc3QgZmlsbFZlY3RvciA9IChkYXRhVHlwZSA9ICdmMzInLCBjb21wb25lbnRzPzogbnVtYmVyLCB2YWx1ZSA9ICcwJykgPT4ge1xuICBpZiAoIWNvbXBvbmVudHMgfHwgY29tcG9uZW50cyA9PT0gMSkge1xuICAgIHJldHVybiBgJHtkYXRhVHlwZX0oJHt2YWx1ZX0pYDtcbiAgfVxuXG4gIHJldHVybiBgdmVjJHtjb21wb25lbnRzfTwke2RhdGFUeXBlfT4oJHt2YWx1ZX0pYDtcbn07XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdGhhdCBjYXN0cyB2YWx1ZSBvciB2ZWN0b3IgdG8gZjMyXG4gKiBAcGFyYW0gZGF0YVR5cGVcbiAqIEBwYXJhbSBjb21wb25lbnRzXG4gKiBAcGFyYW0gdmFsdWVcbiAqL1xuZXhwb3J0IGNvbnN0IGNhc3RUb0YzMiA9IChkYXRhVHlwZTogc3RyaW5nLCBjb21wb25lbnRzOiBudW1iZXIsIHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgaWYgKGRhdGFUeXBlID09PSAnZjMyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoY29tcG9uZW50cyA9PT0gMSkge1xuICAgIHJldHVybiBgZjMyKCR7dmFsdWV9KWA7XG4gIH1cblxuICByZXR1cm4gYHZlYyR7Y29tcG9uZW50c308ZjMyPigke3ZhbHVlfSlgO1xufTtcblxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgc2NhbGFyIG9yIHN1bXMgYWxsIGNvbXBvbmVudHMgb2YgYSB2ZWN0b3JcbiAqIEBwYXJhbSBuYW1lXG4gKiBAcGFyYW0gY29tcG9uZW50c1xuICovXG5leHBvcnQgY29uc3Qgc3VtVmVjdG9yID0gKG5hbWU6IHN0cmluZywgY29tcG9uZW50czogbnVtYmVyKSA9PiB7XG4gIGlmIChjb21wb25lbnRzID09PSA0KSB7XG4gICAgcmV0dXJuIGAoJHtuYW1lfS54ICsgJHtuYW1lfS55ICsgJHtuYW1lfS56ICsgJHtuYW1lfS53KWA7XG4gIH0gZWxzZSBpZiAoY29tcG9uZW50cyA9PT0gMikge1xuICAgIHJldHVybiBgKCR7bmFtZX0ueCArICR7bmFtZX0ueSlgO1xuICB9IGVsc2UgaWYgKGNvbXBvbmVudHMgPT09IDMpIHtcbiAgICByZXR1cm4gYCgke25hbWV9LnggKyAke25hbWV9LnkgKyAke25hbWV9LnopYDtcbiAgfVxuXG4gIHJldHVybiBuYW1lO1xufTtcblxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdmFyaWFibGUgZWxlbWVudCBhdCBpbmRleC5cbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdmFyaWFibGUuXG4gKiBAcGFyYW0gaW5kZXggLSB0aGUgaW5kZXggb2YgdmFyaWFibGUgZWxlbWVudC5cbiAqIEBwYXJhbSBsZW5ndGggLSB0aGUgbGVuZ3RoIG9mIHZhcmlhYmxlLlxuICogQHBhcmFtIHR5cGUgLSB0aGUgdHlwZSBvZiB2YXJpYWJsZSwgb3B0aW9uYWwuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRFbGVtZW50QXQgPVxuICAgIChuYW1lOiBzdHJpbmcsIGluZGV4OiBudW1iZXJ8c3RyaW5nLCBsZW5ndGg6IG51bWJlciwgdHlwZT86IFVuaWZvcm1EYXRhRWxlbWVudFR5cGUpOiBzdHJpbmcgPT4ge1xuICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgndW5pZm9ybXMuJykgJiYgbGVuZ3RoID4gNCkge1xuICAgICAgICBpZiAodHlwZW9mIChpbmRleCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdmMTYnKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7bmFtZX1bKCR7aW5kZXh9KSAvIDhdWygke2luZGV4fSkgJSA4IC8gNF1bKCR7aW5kZXh9KSAlIDggJSA0XWA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtuYW1lfVsoJHtpbmRleH0pIC8gNF1bKCR7aW5kZXh9KSAlIDRdYDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdmMTYnKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7bmFtZX1bJHtNYXRoLmZsb29yKGluZGV4IC8gOCl9XVske01hdGguZmxvb3IoaW5kZXggJSA4IC8gNCl9XVske2luZGV4ICUgOCAlIDR9XWA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtuYW1lfVske01hdGguZmxvb3IoaW5kZXggLyA0KX1dWyR7aW5kZXggJSA0fV1gO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCA+IDEgPyBgJHtuYW1lfVske2luZGV4fV1gIDogbmFtZTtcbiAgICAgIH1cbiAgICB9O1xuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGdldCBhIEluZGljZXNIZWxwZXIgZm9yIGEgZ2l2ZW4gaW5wdXQgb3Igb3V0cHV0LlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cbiAqIEBwYXJhbSB0ZW5zb3JUeXBlIC0gdGhlIHRlbnNvciB0eXBlIG9mIHRoZSBpbnB1dCBvciBvdXRwdXQuXG4gKiBAcGFyYW0gc2hhcGVPclJhbmsgLSB0aGUgdGVuc29yIHNoYXBlIG9yIHRoZSByYW5rIG9mIHRoZSBpbnB1dCBvciBvdXRwdXQuXG4gKiBAcGFyYW0gdXNhZ2UgLSB0aGUgdXNhZ2Ugb2YgdGhlIGluZGljZXMgaGVscGVyLlxuICogQHBhcmFtIGNvbXBvbmVudHMgLSBpbmRpY2F0ZXMgdGhlIG51bWJlciBvZiBjb21wb25lbnRzIG9mIGVhY2ggZWxlbWVudC4gMSBmb3Igc2NhbGFyLCAyIGZvciB2ZWMyLCAzIGZvciB2ZWMzLCA0IGZvclxuICogICAgdmVjNC5cbiAqL1xuY29uc3QgY3JlYXRlSW5kaWNlc0hlbHBlciA9XG4gICAgKG5hbWU6IHN0cmluZywgdGVuc29yVHlwZTogbnVtYmVyLCBzaGFwZU9yUmFuazogbnVtYmVyfHJlYWRvbmx5IG51bWJlcltdLCB1c2FnZTogSW5kaWNlc0hlbHBlclsndXNhZ2UnXSxcbiAgICAgY29tcG9uZW50czogMXwyfDN8NCk6IEluZGljZXNIZWxwZXIgPT4ge1xuICAgICAgY29uc3QgdXNlVW5pZm9ybSA9IHR5cGVvZiBzaGFwZU9yUmFuayA9PT0gJ251bWJlcic7XG4gICAgICBjb25zdCByYW5rID0gdXNlVW5pZm9ybSA/IHNoYXBlT3JSYW5rIDogc2hhcGVPclJhbmsubGVuZ3RoO1xuICAgICAgY29uc3QgcmFua0lkZW50aXR5ID0gWy4uLm5ldyBBcnJheShyYW5rKS5rZXlzKCldO1xuICAgICAgY29uc3QgaW5kaWNlc1R5cGUgPSByYW5rIDwgMiA/ICd1MzInIDogcmFuayA8PSA0ID8gYHZlYyR7cmFua308dTMyPmAgOiBgYXJyYXk8dTMyLCAke3Jhbmt9PmA7XG4gICAgICBjb25zdCBtYXBwZWRUeXBlID0gZ2V0V2dzbE1hcHBlZFR5cGUodGVuc29yVHlwZSwgY29tcG9uZW50cyk7XG4gICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0eXBlb2YgbWFwcGVkVHlwZSA9PT0gJ3N0cmluZycgPyBtYXBwZWRUeXBlIDogbWFwcGVkVHlwZVsxXTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VUeXBlID0gdHlwZW9mIG1hcHBlZFR5cGUgPT09ICdzdHJpbmcnID8gbWFwcGVkVHlwZSA6IG1hcHBlZFR5cGVbMF07XG4gICAgICBjb25zdCB0eXBlID0ge2luZGljZXM6IGluZGljZXNUeXBlLCB2YWx1ZTogdmFsdWVUeXBlLCBzdG9yYWdlOiBzdG9yYWdlVHlwZSwgdGVuc29yOiB0ZW5zb3JUeXBlfTtcblxuICAgICAgY29uc3Qgbm9ybWFsaXplRGltID0gKGRpbTogbnVtYmVyfHN0cmluZyk6IHN0cmluZyA9PiB0eXBlb2YgZGltID09PSAnc3RyaW5nJyA/IGRpbSA6IGAke2RpbX11YDtcblxuICAgICAgY29uc3QgaW1wbGVtZW50YXRpb25Vc2VkID0ge1xuICAgICAgICBvZmZzZXRUb0luZGljZXM6IGZhbHNlLFxuICAgICAgICBpbmRpY2VzVG9PZmZzZXQ6IGZhbHNlLFxuICAgICAgICBicm9hZGNhc3RlZEluZGljZXNUb09mZnNldDogZmFsc2UsXG4gICAgICAgIHNldDogZmFsc2UsXG4gICAgICAgIHNldEJ5SW5kaWNlczogZmFsc2UsXG4gICAgICAgIGdldDogZmFsc2UsXG4gICAgICAgIGdldEJ5SW5kaWNlczogZmFsc2UsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB1bmlmb3JtUHJlZml4ID0gdXNlVW5pZm9ybSA/ICd1bmlmb3Jtcy4nIDogJyc7XG4gICAgICBjb25zdCBzaGFwZSA9IGAke3VuaWZvcm1QcmVmaXh9JHtuYW1lfV9zaGFwZWA7XG4gICAgICBjb25zdCBzdHJpZGVzID0gYCR7dW5pZm9ybVByZWZpeH0ke25hbWV9X3N0cmlkZXNgO1xuXG4gICAgICBsZXQgbzJpU25pcHBldCA9ICcnO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rIC0gMTsgaSsrKSB7XG4gICAgICAgIG8yaVNuaXBwZXQgKz0gYFxuICAgIGxldCBkaW0ke2l9ID0gY3VycmVudCAvICR7Z2V0RWxlbWVudEF0KHN0cmlkZXMsIGksIHJhbmspfTtcbiAgICBsZXQgcmVzdCR7aX0gPSBjdXJyZW50ICUgJHtnZXRFbGVtZW50QXQoc3RyaWRlcywgaSwgcmFuayl9O1xuICAgIGluZGljZXNbJHtpfV0gPSBkaW0ke2l9O1xuICAgIGN1cnJlbnQgPSByZXN0JHtpfTtcbiAgICBgO1xuICAgICAgfVxuICAgICAgbzJpU25pcHBldCArPSBgaW5kaWNlc1ske3JhbmsgLSAxfV0gPSBjdXJyZW50O2A7XG5cbiAgICAgIGNvbnN0IG9mZnNldFRvSW5kaWNlc0ltcGxlbWVudGF0aW9uID0gcmFuayA8IDIgPyAnJyA6IGBcbiAgZm4gbzJpXyR7bmFtZX0ob2Zmc2V0OiB1MzIpIC0+ICR7dHlwZS5pbmRpY2VzfSB7XG4gICAgdmFyIGluZGljZXM6ICR7dHlwZS5pbmRpY2VzfTtcbiAgICB2YXIgY3VycmVudCA9IG9mZnNldDtcbiAgICAke28yaVNuaXBwZXR9XG4gICAgcmV0dXJuIGluZGljZXM7XG4gIH1gO1xuXG4gICAgICBjb25zdCBvZmZzZXRUb0luZGljZXMgPSAodmFyT2Zmc2V0OiBzdHJpbmcpID0+IHtcbiAgICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLm9mZnNldFRvSW5kaWNlcyA9IHRydWU7XG4gICAgICAgIHJldHVybiByYW5rIDwgMiA/IHZhck9mZnNldCA6IGBvMmlfJHtuYW1lfSgke3Zhck9mZnNldH0pYDtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG9mZnNldHM6IHN0cmluZ1tdID0gW107XG4gICAgICBpZiAocmFuayA+PSAyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSByYW5rIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBvZmZzZXRzLnB1c2goYCR7Z2V0RWxlbWVudEF0KHN0cmlkZXMsIGksIHJhbmspfSAqIChpbmRpY2VzWyR7aX1dKWApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGluZGljZXNUb09mZnNldEltcGxlbWVudGF0aW9uID0gcmFuayA8IDIgPyAnJyA6IGBcbiAgZm4gaTJvXyR7bmFtZX0oaW5kaWNlczogJHt0eXBlLmluZGljZXN9KSAtPiB1MzIge1xuICAgIHJldHVybiAke29mZnNldHMuam9pbignKycpfTtcbiAgfWA7XG5cbiAgICAgIGNvbnN0IGluZGljZXNUb09mZnNldCA9ICh2YXJJbmRpY2VzOiBzdHJpbmcpID0+IHtcbiAgICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLmluZGljZXNUb09mZnNldCA9IHRydWU7XG4gICAgICAgIHJldHVybiByYW5rIDwgMiA/IHZhckluZGljZXMgOiBgaTJvXyR7bmFtZX0oJHt2YXJJbmRpY2VzfSlgO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgaW5kaWNlcyA9ICguLi5pbml0OiBSZWFkb25seUFycmF5PG51bWJlcnxzdHJpbmc+KSA9PlxuICAgICAgICAgIHJhbmsgPT09IDAgPyAnMHUnIDogYCR7dHlwZS5pbmRpY2VzfSgke2luaXQubWFwKG5vcm1hbGl6ZURpbSkuam9pbignLCcpfSlgO1xuXG4gICAgICBjb25zdCBpbmRpY2VzR2V0ID0gKHZhckluZGljZXM6IHN0cmluZywgaWR4OiBudW1iZXJ8c3RyaW5nKSA9PiB7XG4gICAgICAgIGlmIChyYW5rIDwgMikge1xuICAgICAgICAgIHJldHVybiBgJHt2YXJJbmRpY2VzfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGAke2dldEVsZW1lbnRBdCh2YXJJbmRpY2VzLCBpZHgsIHJhbmspfWA7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGluZGljZXNTZXQgPSAodmFySW5kaWNlczogc3RyaW5nLCBpZHg6IG51bWJlcnxzdHJpbmcsIHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKHJhbmsgPCAyKSB7XG4gICAgICAgICAgcmV0dXJuIGAke3ZhckluZGljZXN9PSR7dmFsdWV9O2A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGAke2dldEVsZW1lbnRBdCh2YXJJbmRpY2VzLCBpZHgsIHJhbmspfT0ke3ZhbHVlfTtgO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBicm9hZGNhc3RlZEluZGljZXNUb09mZnNldEltcGxlbWVudGF0aW9uOiB7W2tleTogc3RyaW5nXTogc3RyaW5nfSA9IHt9O1xuICAgICAgY29uc3QgYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQgPSAodmFySW5kaWNlczogc3RyaW5nLCBvdXRwdXQ6IEluZGljZXNIZWxwZXIpID0+IHtcbiAgICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0ID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgaW1wbEtleSA9IGAke291dHB1dC5uYW1lfWJyb2FkY2FzdGVkSW5kaWNlc1RvJHtuYW1lfU9mZnNldGA7XG4gICAgICAgIGlmIChpbXBsS2V5IGluIGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0SW1wbGVtZW50YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gYCR7aW1wbEtleX0oJHt2YXJJbmRpY2VzfSlgO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZnNldHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHJhbmsgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IGlkeCA9IG91dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRJbmRpY2VzJywgaSArIG91dHB1dC5yYW5rIC0gcmFuayk7XG4gICAgICAgICAgb2Zmc2V0cy5wdXNoKGAke2luZGljZXNHZXQoc3RyaWRlcywgaSl9ICogKCR7aWR4fSAlICR7aW5kaWNlc0dldChzaGFwZSwgaSl9KWApO1xuICAgICAgICB9XG4gICAgICAgIGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0SW1wbGVtZW50YXRpb25baW1wbEtleV0gPVxuICAgICAgICAgICAgYGZuICR7aW1wbEtleX0ob3V0cHV0SW5kaWNlczogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gdTMyIHtcbiAgICAgICAgICAgICByZXR1cm4gJHtvZmZzZXRzLmxlbmd0aCA+IDAgPyBvZmZzZXRzLmpvaW4oJysnKSA6ICcwdSd9O1xuICAgICAgICAgICB9YDtcblxuICAgICAgICByZXR1cm4gYCR7aW1wbEtleX0oJHt2YXJJbmRpY2VzfSlgO1xuICAgICAgfTtcblxuICAgICAgY29uc3Qgc2V0QnlPZmZzZXQgPSAob2Zmc2V0OiBudW1iZXJ8c3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiAoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZS5zdG9yYWdlID09PSB0eXBlLnZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGAke25hbWV9WyR7b2Zmc2V0fV09JHt2YWx1ZX07YDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlLnN0b3JhZ2UgPT09ICd2ZWMyPHUzMj4nICYmIHR5cGUudmFsdWUgPT09ICdpMzInKSB7XG4gICAgICAgICAgLy8gaW50NjQsIGNvbXBvbmVudHMgPT09IDFcbiAgICAgICAgICByZXR1cm4gYCR7bmFtZX1bJHtvZmZzZXR9XT12ZWMyPHUzMj4odTMyKCR7dmFsdWV9KSwgc2VsZWN0KDB1LCAweEZGRkZGRkZGdSwgJHt2YWx1ZX0gPCAwKSk7YDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlLnN0b3JhZ2UgPT09ICd2ZWMyPHUzMj4nICYmIHR5cGUudmFsdWUgPT09ICd1MzInKSB7XG4gICAgICAgICAgLy8gdWludDY0LCBjb21wb25lbnRzID09PSAxXG4gICAgICAgICAgcmV0dXJuIGAke25hbWV9WyR7b2Zmc2V0fV09dmVjMjx1MzI+KHUzMigke3ZhbHVlfSksIDB1KTtgO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUuc3RvcmFnZSA9PT0gJ3UzMicgJiYgdHlwZS52YWx1ZSA9PT0gJ3ZlYzQ8Ym9vbD4nKSB7XG4gICAgICAgICAgLy8gYm9vbCwgY29tcG9uZW50cyA9PT0gNFxuICAgICAgICAgIHJldHVybiBgJHtuYW1lfVske29mZnNldH1dPWRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KCR7dmFsdWV9KSk7YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgY29tYmluYXRpb24gb2Ygc3RvcmFnZSB0eXBlICR7dHlwZS5zdG9yYWdlfSBhbmQgdmFsdWUgdHlwZSAke3R5cGUudmFsdWV9IHlldGApO1xuICAgICAgICB9XG4gICAgICB9KSgpO1xuXG4gICAgICBjb25zdCBnZXRCeU9mZnNldCA9IChvZmZzZXQ6IG51bWJlcnxzdHJpbmcpID0+ICgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlLnN0b3JhZ2UgPT09IHR5cGUudmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gYCR7bmFtZX1bJHtvZmZzZXR9XWA7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZS5zdG9yYWdlID09PSAndmVjMjx1MzI+JyAmJiB0eXBlLnZhbHVlID09PSAnaTMyJykge1xuICAgICAgICAgIC8vIGludDY0LCBjb21wb25lbnRzID09PSAxXG4gICAgICAgICAgcmV0dXJuIGBpMzIoJHtuYW1lfVske29mZnNldH1dLngpYDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlLnN0b3JhZ2UgPT09ICd2ZWMyPHUzMj4nICYmIHR5cGUudmFsdWUgPT09ICd1MzInKSB7XG4gICAgICAgICAgLy8gdWludDY0LCBjb21wb25lbnRzID09PSAxXG4gICAgICAgICAgcmV0dXJuIGB1MzIoJHtuYW1lfVske29mZnNldH1dLngpYDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlLnN0b3JhZ2UgPT09ICd1MzInICYmIHR5cGUudmFsdWUgPT09ICd2ZWM0PGJvb2w+Jykge1xuICAgICAgICAgIC8vIGJvb2wsIGNvbXBvbmVudHMgPT09IDRcbiAgICAgICAgICByZXR1cm4gYHZlYzQ8Ym9vbD4oYm9vbCgke25hbWV9WyR7b2Zmc2V0fV0gJiAweEZGdSksIGJvb2woJHtuYW1lfVske29mZnNldH1dICYgMHhGRjAwdSksIGJvb2woJHtuYW1lfVske1xuICAgICAgICAgICAgICBvZmZzZXR9XSAmIDB4RkYwMDAwdSksIGJvb2woJHtuYW1lfVske29mZnNldH1dICYgMHhGRjAwMDAwMHUpKWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGNvbWJpbmF0aW9uIG9mIHN0b3JhZ2UgdHlwZSAke3R5cGUuc3RvcmFnZX0gYW5kIHZhbHVlIHR5cGUgJHt0eXBlLnZhbHVlfSB5ZXRgKTtcbiAgICAgICAgfVxuICAgICAgfSkoKTtcblxuICAgICAgY29uc3QgZ2V0QnlJbmRpY2VzSW1wbGVtZW50YXRpb24gPSByYW5rIDwgMiA/ICcnIDogYFxuICBmbiBnZXRfJHtuYW1lfUJ5SW5kaWNlcyhpbmRpY2VzOiAke3R5cGUuaW5kaWNlc30pIC0+ICR7dmFsdWVUeXBlfSB7XG4gICAgcmV0dXJuICR7Z2V0QnlPZmZzZXQoYGkyb18ke25hbWV9KGluZGljZXMpYCl9O1xuICB9YDtcblxuICAgICAgY29uc3QgZ2V0SW1wbGVtZW50YXRpb24gPSByYW5rIDwgMiA/ICcnIDogKCgpID0+IHtcbiAgICAgICAgY29uc3QgZnVuY3Rpb25QYXJhbXMgPSByYW5rSWRlbnRpdHkubWFwKGkgPT4gYGQke2l9OiB1MzJgKS5qb2luKCcsICcpO1xuICAgICAgICBjb25zdCBkaW1zUGFyYW1zID0gcmFua0lkZW50aXR5Lm1hcChpID0+IGBkJHtpfWApLmpvaW4oJywgJyk7XG4gICAgICAgIHJldHVybiBgXG4gIGZuIGdldF8ke25hbWV9KCR7ZnVuY3Rpb25QYXJhbXN9KSAtPiAke3ZhbHVlVHlwZX0ge1xuICAgIHJldHVybiBnZXRfJHtuYW1lfUJ5SW5kaWNlcygke2luZGljZXMoZGltc1BhcmFtcyl9KTtcbiAgfWA7XG4gICAgICB9KSgpO1xuXG4gICAgICBjb25zdCBnZXQgPSAoLi4uaW5kaWNlczogUmVhZG9ubHlBcnJheTxudW1iZXJ8c3RyaW5nPikgPT4ge1xuICAgICAgICBpZiAoaW5kaWNlcy5sZW5ndGggIT09IHJhbmspIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGluZGljZXMgbGVuZ3RoIG11c3QgYmUgJHtyYW5rfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEluZGljZXMgPSBpbmRpY2VzLm1hcChub3JtYWxpemVEaW0pLmpvaW4oJywnKTtcblxuICAgICAgICBpZiAocmFuayA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBnZXRCeU9mZnNldCgnMHUnKTtcbiAgICAgICAgfSBlbHNlIGlmIChyYW5rID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIGdldEJ5T2Zmc2V0KG5vcm1hbGl6ZWRJbmRpY2VzWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbXBsZW1lbnRhdGlvblVzZWQuZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICBpbXBsZW1lbnRhdGlvblVzZWQuZ2V0QnlJbmRpY2VzID0gdHJ1ZTtcbiAgICAgICAgICBpbXBsZW1lbnRhdGlvblVzZWQuaW5kaWNlc1RvT2Zmc2V0ID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gYGdldF8ke25hbWV9KCR7bm9ybWFsaXplZEluZGljZXN9KWA7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGdldEJ5SW5kaWNlcyA9ICh2YXJJbmRpY2VzOiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKHJhbmsgPCAyKSB7XG4gICAgICAgICAgcmV0dXJuIGdldEJ5T2Zmc2V0KHZhckluZGljZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5nZXRCeUluZGljZXMgPSB0cnVlO1xuICAgICAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5pbmRpY2VzVG9PZmZzZXQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBgZ2V0XyR7bmFtZX1CeUluZGljZXMoJHt2YXJJbmRpY2VzfSlgO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzZXRCeUluZGljZXNJbXBsZW1lbnRhdGlvbiA9IHJhbmsgPCAyID8gJycgOiBgXG4gIGZuIHNldF8ke25hbWV9QnlJbmRpY2VzKGluZGljZXM6ICR7dHlwZS5pbmRpY2VzfSwgdmFsdWU6ICR7dmFsdWVUeXBlfSkge1xuICAgICR7c2V0QnlPZmZzZXQoYGkyb18ke25hbWV9KGluZGljZXMpYCwgJ3ZhbHVlJyl9XG4gIH1gO1xuXG4gICAgICBjb25zdCBzZXRJbXBsZW1lbnRhdGlvbiA9IHJhbmsgPCAyID8gJycgOiAoKCkgPT4ge1xuICAgICAgICBjb25zdCBmdW5jdGlvblBhcmFtcyA9IHJhbmtJZGVudGl0eS5tYXAoaSA9PiBgZCR7aX06IHUzMmApLmpvaW4oJywgJyk7XG4gICAgICAgIGNvbnN0IGRpbXNQYXJhbXMgPSByYW5rSWRlbnRpdHkubWFwKGkgPT4gYGQke2l9YCkuam9pbignLCAnKTtcbiAgICAgICAgcmV0dXJuIGBcbiAgZm4gc2V0XyR7bmFtZX0oJHtmdW5jdGlvblBhcmFtc30sIHZhbHVlOiAke3ZhbHVlVHlwZX0pIHtcbiAgICBzZXRfJHtuYW1lfUJ5SW5kaWNlcygke2luZGljZXMoZGltc1BhcmFtcyl9LCB2YWx1ZSk7XG4gIH1gO1xuICAgICAgfSkoKTtcblxuICAgICAgY29uc3Qgc2V0ID0gKC4uLmluZGljZXNBbmRWYWx1ZTogUmVhZG9ubHlBcnJheTxudW1iZXJ8c3RyaW5nPikgPT4ge1xuICAgICAgICBpZiAoaW5kaWNlc0FuZFZhbHVlLmxlbmd0aCAhPT0gcmFuayArIDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGluZGljZXMgbGVuZ3RoIG11c3QgYmUgJHtyYW5rfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaW5kaWNlc0FuZFZhbHVlW3JhbmtdO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgbXVzdCBiZSBzdHJpbmcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJbmRpY2VzID0gaW5kaWNlc0FuZFZhbHVlLnNsaWNlKDAsIHJhbmspLm1hcChub3JtYWxpemVEaW0pLmpvaW4oJywnKTtcblxuICAgICAgICBpZiAocmFuayA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBzZXRCeU9mZnNldCgnMHUnLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmFuayA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBzZXRCeU9mZnNldChub3JtYWxpemVkSW5kaWNlc1swXSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5zZXQgPSB0cnVlO1xuICAgICAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5zZXRCeUluZGljZXMgPSB0cnVlO1xuICAgICAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5pbmRpY2VzVG9PZmZzZXQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBgc2V0XyR7bmFtZX0oJHtub3JtYWxpemVkSW5kaWNlc30sICR7dmFsdWV9KWA7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHNldEJ5SW5kaWNlcyA9ICh2YXJJbmRpY2VzOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKHJhbmsgPCAyKSB7XG4gICAgICAgICAgcmV0dXJuIHNldEJ5T2Zmc2V0KHZhckluZGljZXMsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbXBsZW1lbnRhdGlvblVzZWQuc2V0QnlJbmRpY2VzID0gdHJ1ZTtcbiAgICAgICAgICBpbXBsZW1lbnRhdGlvblVzZWQuaW5kaWNlc1RvT2Zmc2V0ID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gYHNldF8ke25hbWV9QnlJbmRpY2VzKCR7dmFySW5kaWNlc30sICR7dmFsdWV9KTtgO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBpbXBsID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBpbXBscyA9IFtdO1xuICAgICAgICBsZXQgbmVlZFNoYXBlU3RyaWRlcyA9IGZhbHNlO1xuICAgICAgICBpZiAoaW1wbGVtZW50YXRpb25Vc2VkLm9mZnNldFRvSW5kaWNlcykge1xuICAgICAgICAgIGltcGxzLnB1c2gob2Zmc2V0VG9JbmRpY2VzSW1wbGVtZW50YXRpb24pO1xuICAgICAgICAgIG5lZWRTaGFwZVN0cmlkZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbXBsZW1lbnRhdGlvblVzZWQuaW5kaWNlc1RvT2Zmc2V0KSB7XG4gICAgICAgICAgaW1wbHMucHVzaChpbmRpY2VzVG9PZmZzZXRJbXBsZW1lbnRhdGlvbik7XG4gICAgICAgICAgbmVlZFNoYXBlU3RyaWRlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltcGxlbWVudGF0aW9uVXNlZC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCkge1xuICAgICAgICAgIE9iamVjdC52YWx1ZXMoYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXRJbXBsZW1lbnRhdGlvbikuZm9yRWFjaChpbXBsID0+IGltcGxzLnB1c2goaW1wbCkpO1xuICAgICAgICAgIG5lZWRTaGFwZVN0cmlkZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbXBsZW1lbnRhdGlvblVzZWQuc2V0KSB7XG4gICAgICAgICAgaW1wbHMucHVzaChzZXRJbXBsZW1lbnRhdGlvbik7XG4gICAgICAgICAgbmVlZFNoYXBlU3RyaWRlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltcGxlbWVudGF0aW9uVXNlZC5zZXRCeUluZGljZXMpIHtcbiAgICAgICAgICBpbXBscy5wdXNoKHNldEJ5SW5kaWNlc0ltcGxlbWVudGF0aW9uKTtcbiAgICAgICAgICBuZWVkU2hhcGVTdHJpZGVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1wbGVtZW50YXRpb25Vc2VkLmdldCkge1xuICAgICAgICAgIGltcGxzLnB1c2goZ2V0SW1wbGVtZW50YXRpb24pO1xuICAgICAgICAgIG5lZWRTaGFwZVN0cmlkZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbXBsZW1lbnRhdGlvblVzZWQuZ2V0QnlJbmRpY2VzKSB7XG4gICAgICAgICAgaW1wbHMucHVzaChnZXRCeUluZGljZXNJbXBsZW1lbnRhdGlvbik7XG4gICAgICAgICAgbmVlZFNoYXBlU3RyaWRlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF1c2VVbmlmb3JtICYmIG5lZWRTaGFwZVN0cmlkZXMpIHtcbiAgICAgICAgICBpbXBscy51bnNoaWZ0KFxuICAgICAgICAgICAgICBgY29uc3QgJHtzaGFwZX0gPSAke3R5cGUuaW5kaWNlc30oJHtzaGFwZU9yUmFuay5qb2luKCcsJyl9KTtgLFxuICAgICAgICAgICAgICBgY29uc3QgJHtzdHJpZGVzfSA9ICR7dHlwZS5pbmRpY2VzfSgke1NoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhzaGFwZU9yUmFuaykuam9pbignLCcpfSk7YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGltcGxzLmpvaW4oJ1xcbicpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW1wbCxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgb2Zmc2V0VG9JbmRpY2VzLFxuICAgICAgICBpbmRpY2VzVG9PZmZzZXQsXG4gICAgICAgIGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0LFxuICAgICAgICBpbmRpY2VzLFxuICAgICAgICBpbmRpY2VzR2V0LFxuICAgICAgICBpbmRpY2VzU2V0LFxuICAgICAgICBzZXQsXG4gICAgICAgIHNldEJ5T2Zmc2V0LFxuICAgICAgICBzZXRCeUluZGljZXMsXG4gICAgICAgIGdldCxcbiAgICAgICAgZ2V0QnlPZmZzZXQsXG4gICAgICAgIGdldEJ5SW5kaWNlcyxcbiAgICAgICAgLy8gaXNWZWM0LFxuICAgICAgICB1c2FnZSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgc3RyaWRlcyxcbiAgICAgICAgc2hhcGUsXG4gICAgICAgIHJhbmtcbiAgICAgIH07XG4gICAgfTtcblxuLyoqXG4gKiBDcmVhdGUgYSBJbmRpY2VzSGVscGVyIGZvciBhbiBpbnB1dC5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBpbnB1dC5cbiAqIEBwYXJhbSB0eXBlIC0gdGhlIHRlbnNvciB0eXBlIG9mIHRoZSBpbnB1dC5cbiAqIEBwYXJhbSBzaGFwZU9yUmFuayAtIHRoZSB0ZW5zb3Igc2hhcGUgb3IgdGhlIHJhbmsgb2YgdGhlIGlucHV0LlxuICogQHBhcmFtIGNvbXBvbmVudHMgLSB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgb2YgdGhlIGlucHV0LiBhdmFpbGFibGUgdmFsdWVzIGFyZSAxLCAyLCAzLCA0LiBkZWZhdWx0IGlzIDEuXG4gKiBAcmV0dXJucyBhbiBJbmRpY2VzSGVscGVyIGZvciB0aGUgaW5wdXQuXG4gKi9cbmV4cG9ydCBjb25zdCBpbnB1dFZhcmlhYmxlID1cbiAgICAobmFtZTogc3RyaW5nLCB0eXBlOiBudW1iZXIsIHNoYXBlT3JSYW5rOiBudW1iZXJ8cmVhZG9ubHkgbnVtYmVyW10sIGNvbXBvbmVudHM6IDF8MnwzfDQgPSAxKTogSW5kaWNlc0hlbHBlciA9PlxuICAgICAgICBjcmVhdGVJbmRpY2VzSGVscGVyKG5hbWUsIHR5cGUsIHNoYXBlT3JSYW5rLCAnaW5wdXQnLCBjb21wb25lbnRzKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBJbmRpY2VzSGVscGVyIGZvciBhbiBvdXRwdXQuXG4gKlxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgb3V0cHV0LlxuICogQHBhcmFtIHR5cGUgLSB0aGUgdGVuc29yIHR5cGUgb2YgdGhlIG91dHB1dC5cbiAqIEBwYXJhbSBzaGFwZU9yUmFuayAtIHRoZSB0ZW5zb3Igc2hhcGUgb3IgdGhlIHJhbmsgb2YgdGhlIG91dHB1dC5cbiAqIEBwYXJhbSBjb21wb25lbnRzIC0gdGhlIG51bWJlciBvZiBjb21wb25lbnRzIG9mIHRoZSBvdXRwdXQuIGF2YWlsYWJsZSB2YWx1ZXMgYXJlIDEsIDIsIDMsIDQuIGRlZmF1bHQgaXMgMS5cbiAqIEByZXR1cm5zIGFuIEluZGljZXNIZWxwZXIgZm9yIHRoZSBvdXRwdXQuXG4gKi9cbmV4cG9ydCBjb25zdCBvdXRwdXRWYXJpYWJsZSA9XG4gICAgKG5hbWU6IHN0cmluZywgdHlwZTogbnVtYmVyLCBzaGFwZU9yUmFuazogbnVtYmVyfHJlYWRvbmx5IG51bWJlcltdLCBjb21wb25lbnRzOiAxfDJ8M3w0ID0gMSk6IEluZGljZXNIZWxwZXIgPT5cbiAgICAgICAgY3JlYXRlSW5kaWNlc0hlbHBlcihuYW1lLCB0eXBlLCBzaGFwZU9yUmFuaywgJ291dHB1dCcsIGNvbXBvbmVudHMpO1xuXG4vKipcbiAqIENyZWF0ZSBhIEluZGljZXNIZWxwZXIgZm9yIGFuIGludGVybmFsIHZhcmlhYmxlLlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlLlxuICogQHBhcmFtIHR5cGUgLSB0aGUgdGVuc29yIHR5cGUgb2YgdGhlIHZhcmlhYmxlLlxuICogQHBhcmFtIHNoYXBlT3JSYW5rIC0gdGhlIHRlbnNvciBzaGFwZSBvciB0aGUgcmFuayBvZiB0aGUgdmFyaWFibGUuXG4gKiBAcGFyYW0gY29tcG9uZW50cyAtIHRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBvZiB0aGUgdmFyaWFibGUuIGF2YWlsYWJsZSB2YWx1ZXMgYXJlIDEsIDIsIDMsIDQuIGRlZmF1bHQgaXMgMS5cbiAqIEByZXR1cm5zIGFuIEluZGljZXNIZWxwZXIgZm9yIHRoZSB2YXJpYWJsZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGludGVybmFsVmFyaWFibGUgPVxuICAgIChuYW1lOiBzdHJpbmcsIHR5cGU6IG51bWJlciwgc2hhcGVPclJhbms6IG51bWJlcnxyZWFkb25seSBudW1iZXJbXSwgY29tcG9uZW50czogMXwyfDN8NCA9IDEpOiBJbmRpY2VzSGVscGVyID0+XG4gICAgICAgIGNyZWF0ZUluZGljZXNIZWxwZXIobmFtZSwgdHlwZSwgc2hhcGVPclJhbmssICdpbnRlcm5hbCcsIGNvbXBvbmVudHMpO1xuXG5leHBvcnQgdHlwZSBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlID0gJ3UzMid8J2YxNid8J2YzMid8J2kzMic7XG5leHBvcnQgdHlwZSBVbmlmb3Jtc0FycmF5VHlwZSA9IEFycmF5PHtuYW1lOiBzdHJpbmc7IHR5cGU6IFVuaWZvcm1EYXRhRWxlbWVudFR5cGU7IGxlbmd0aD86IG51bWJlcn0+O1xuXG4vKipcbiAqIEEgU2hhZGVySGVscGVyIGlzIGEgaGVscGVyIGNsYXNzIGZvciBnZW5lcmF0aW5nIFdHU0wgY29kZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTaGFkZXJIZWxwZXIge1xuICAvKipcbiAgICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgdGhlIHN0YXJ0IG9mIG1haW4gZnVuY3Rpb24gaW4gV0dTTCBzb3VyY2UgY29kZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICAqICAuLi5cbiAgICpcbiAgICogICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgKiAgICAvLyB5b3VyIGNvZGUgaGVyZSBpbnNpZGUgbWFpbigpIGZ1bmN0aW9uXG4gICAqICAgIC4uLlxuICAgKiAgfVxuICAgKiBgO1xuICAgKlxuICAgKiBAcGFyYW0gd29ya2dyb3VwU2l6ZSAtIGFuIG9wdGlvbmFsIHdvcmtncm91cCBzaXplLiBkZWZhdWx0IGlzIFdPUktHUk9VUF9TSVpFLlxuICAgKi9cbiAgbWFpblN0YXJ0KHdvcmtncm91cFNpemU/OiBudW1iZXJ8W251bWJlciwgbnVtYmVyLCBudW1iZXJdKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSB0aGUgY29kZSBzbmlwcGV0IGZvciBndWFyZGluZyBhZ2FpbnN0IG91dC1vZi1ib3VuZHMgc2l6ZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICAqICAuLi5cbiAgICpcbiAgICogICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgKiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKG91dHB1dFNpemUpfVxuICAgKlxuICAgKiAgICAvLyB5b3VyIGNvZGUgaGVyZSBpbnNpZGUgbWFpbigpIGZ1bmN0aW9uXG4gICAqICAgIC4uLlxuICAgKiAgfVxuICAgKiBgO1xuICAgKlxuICAgKiBAcGFyYW0gc2l6ZSAtIHRoZSBzaXplIG9mIHRoZSBkYXRhIHRvIGd1YXJkIGFnYWluc3QuIGNhbiBiZSBhIG51bWJlciBvciBhIHN0cmluZyAoV0dTTCBgdTMyYCBleHByZXNzaW9uKS5cbiAgICovXG4gIGd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoc2l6ZTogdW5rbm93bik6IHN0cmluZztcblxuICAvKipcbiAgICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgdGhlIGNvZGUgc25pcHBldCBmb3IgZGVjbGFyaW5nIG11bHRpcGxlIGlucHV0cyBvciBvdXRwdXRzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFyaWFibGVzIC0gYW4gYXJyYXkgb2YgSW5kaWNlc0hlbHBlciBmb3IgdGhlIHZhcmlhYmxlcy5cbiAgICovXG4gIGRlY2xhcmVWYXJpYWJsZXMoLi4udmFyaWFibGVzOiBJbmRpY2VzSGVscGVyW10pOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIHJlZ2lzdGVyIG9uZSB1bmlmb3JtLiBDYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHRvIHJlZ2lzdGVyIG11bHRpcGxlIHVuaWZvcm1zLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSB1bmlmb3JtLlxuICAgKiBAcGFyYW0gdHlwZSAtIHRoZSB0eXBlIG9mIHRoZSB1bmlmb3JtLlxuICAgKiBAcGFyYW0gbGVuZ3RoIC0gdGhlIGxlbmd0aCBvZiB0aGUgdW5pZm9ybSwgZGVmYXVsdCB0byAxIHdoZW4gaXQgaXMgbm90IHByb3ZpZGVkLlxuICAgKi9cbiAgcmVnaXN0ZXJVbmlmb3JtKG5hbWU6IHN0cmluZywgdHlwZTogc3RyaW5nLCBsZW5ndGg/OiBudW1iZXIpOiBTaGFkZXJIZWxwZXI7XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIHJlZ2lzdGVyIG11bHRpcGxlIHVuaWZvcm1zLiBDYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHRvIHJlZ2lzdGVyIG11bHRpcGxlIHVuaWZvcm1zLlxuICAgKlxuICAgKiBAcGFyYW0gdW5pZm9ybXMgLSBhbiBhcnJheSBvZiB1bmlmb3Jtcy4gRWFjaCBlbGVtZW50IG9mIHRoZSBhcnJheSBpcyBhbiBvYmplY3Qgd2l0aCAyIHByb3BlcnRpZXM6IGBuYW1lYCBhbmRcbiAgICogICAgIGB0eXBlYC5cbiAgICovXG4gIHJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlKTogU2hhZGVySGVscGVyO1xuXG4gIC8qKlxuICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byByZWdpc3RlciBtdWx0aXBsZSBpbnRlcm5hbCB2YXJpYWJsZXMuIENhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgdG8gcmVnaXN0ZXIgbXVsdGlwbGVcbiAgICogaW50ZXJuYWwgdmFyaWFibGVzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFyaWFibGVzIC0gYW4gYXJyYXkgb2YgSW5kaWNlc0hlbHBlciBmb3IgdGhlIHZhcmlhYmxlcy5cbiAgICovXG4gIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoLi4udmFyaWFibGVzOiBJbmRpY2VzSGVscGVyW10pOiBTaGFkZXJIZWxwZXI7XG59XG5cbmNsYXNzIFNoYWRlckhlbHBlckltcGwgaW1wbGVtZW50cyBTaGFkZXJIZWxwZXIge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIHByaXZhdGUgbGltaXRzOiBHUFVTdXBwb3J0ZWRMaW1pdHMpIHt9XG5cbiAgZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhzaXplOiBudW1iZXJ8c3RyaW5nKTogc3RyaW5nIHtcbiAgICAvLyBHdWFyZCBhZ2FpbnN0IG91dC1vZi1ib3VuZHMgd29yayBncm91cCBzaXplc1xuICAgIGNvbnN0IHNpemVJbkNvZGUgPSB0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicgPyBgJHtzaXplfXVgIDogc2l6ZTtcbiAgICByZXR1cm4gYGlmIChnbG9iYWxfaWR4ID49ICR7c2l6ZUluQ29kZX0pIHsgcmV0dXJuOyB9YDtcbiAgfVxuXG4gIG1haW5TdGFydCh3b3JrZ3JvdXBTaXplOiBudW1iZXJ8W251bWJlciwgbnVtYmVyLCBudW1iZXJdID0gV09SS0dST1VQX1NJWkUpIHtcbiAgICBjb25zdCB3b3JrZ3JvdXBTaXplWCA9IHR5cGVvZiB3b3JrZ3JvdXBTaXplID09PSAnbnVtYmVyJyA/IHdvcmtncm91cFNpemUgOiB3b3JrZ3JvdXBTaXplWzBdO1xuICAgIGNvbnN0IHdvcmtncm91cFNpemVZID0gdHlwZW9mIHdvcmtncm91cFNpemUgPT09ICdudW1iZXInID8gMSA6IHdvcmtncm91cFNpemVbMV07XG4gICAgY29uc3Qgd29ya2dyb3VwU2l6ZVogPSB0eXBlb2Ygd29ya2dyb3VwU2l6ZSA9PT0gJ251bWJlcicgPyAxIDogd29ya2dyb3VwU2l6ZVsyXTtcblxuICAgIGlmICh3b3JrZ3JvdXBTaXplWCA+IHRoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWCB8fFxuICAgICAgICB3b3JrZ3JvdXBTaXplWSA+IHRoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWSB8fFxuICAgICAgICB3b3JrZ3JvdXBTaXplWiA+IHRoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB3b3JrZ3JvdXAgc2l6ZSBbJHt3b3JrZ3JvdXBTaXplWH0sICR7d29ya2dyb3VwU2l6ZVl9LCAke1xuICAgICAgICAgIHdvcmtncm91cFNpemVafV0gZXhjZWVkcyB0aGUgbWF4aW11bSB3b3JrZ3JvdXAgc2l6ZSBbJHt0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVh9LCAke1xuICAgICAgICAgIHRoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWX0sICR7dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVafV0uYCk7XG4gICAgfVxuXG4gICAgaWYgKHdvcmtncm91cFNpemVYICogd29ya2dyb3VwU2l6ZVkgKiB3b3JrZ3JvdXBTaXplWiA+IHRoaXMubGltaXRzLm1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB3b3JrZ3JvdXAgc2l6ZSBbJHt3b3JrZ3JvdXBTaXplWH0sICR7d29ya2dyb3VwU2l6ZVl9LCAke1xuICAgICAgICAgIHdvcmtncm91cFNpemVafV0gZXhjZWVkcyB0aGUgbWF4aW11bSB3b3JrZ3JvdXAgaW52b2NhdGlvbnMgJHtcbiAgICAgICAgICB0aGlzLmxpbWl0cy5tYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXB9LmApO1xuICAgIH1cblxuICAgIGNvbnN0IGlzMURpbWVuc2lvbkRpc3BhdGNoID0gdGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsxXSA9PT0gMSAmJiB0aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzJdID09PSAxO1xuICAgIGNvbnN0IHBhcmFtTGlzdCA9IGlzMURpbWVuc2lvbkRpc3BhdGNoID8gYEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxfaWQgOiB2ZWMzPHUzMj4sXG4gICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBfaWQgOiB2ZWMzPHUzMj4sXG4gICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxfaWQgOiB2ZWMzPHUzMj5gIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsX2lkIDogdmVjMzx1MzI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxfaWQgOiB2ZWMzPHUzMj4sXG4gICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pbmRleCkgbG9jYWxfaWR4IDogdTMyLFxuICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKG51bV93b3JrZ3JvdXBzKSBudW1fd29ya2dyb3VwcyA6IHZlYzM8dTMyPmA7XG4gICAgY29uc3QgZ2xvYmFsSWR4RGVmaW5pdGlvbiA9IGlzMURpbWVuc2lvbkRpc3BhdGNoID9cbiAgICAgICAgJ2xldCBnbG9iYWxfaWR4ID0gZ2xvYmFsX2lkLng7IGxldCBsb2NhbF9pZHggPSBsb2NhbF9pZC54OycgOlxuICAgICAgICBgbGV0IGdsb2JhbF9pZHggPSAod29ya2dyb3VwX2lkLnogKiBudW1fd29ya2dyb3Vwc1swXSAqIG51bV93b3JrZ3JvdXBzWzFdICtcbiAgICAgICAgICB3b3JrZ3JvdXBfaWQueSAqIG51bV93b3JrZ3JvdXBzWzBdICsgd29ya2dyb3VwX2lkLngpICogJHtcbiAgICAgICAgICAgIHdvcmtncm91cFNpemVYICogd29ya2dyb3VwU2l6ZVkgKiB3b3JrZ3JvdXBTaXplWn11ICsgbG9jYWxfaWR4O2A7XG5cbiAgICByZXR1cm4gYEBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3dvcmtncm91cFNpemVYfSwgJHt3b3JrZ3JvdXBTaXplWX0sICR7d29ya2dyb3VwU2l6ZVp9KVxuICBmbiBtYWluKCR7cGFyYW1MaXN0fSkge1xuICAgICR7Z2xvYmFsSWR4RGVmaW5pdGlvbn1cbiAgYDtcbiAgfVxuXG4gIHByaXZhdGUgYXBwZW5kVmFyaWFibGVVbmlmb3Jtcyh2YXJpYWJsZTogSW5kaWNlc0hlbHBlcik6IHZvaWQge1xuICAgIGlmICh2YXJpYWJsZS5yYW5rICE9PSAwKSB7XG4gICAgICBpZiAodmFyaWFibGUuc2hhcGUuc3RhcnRzV2l0aCgndW5pZm9ybXMuJykpIHtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5wdXNoKHtuYW1lOiB2YXJpYWJsZS5zaGFwZS5yZXBsYWNlKCd1bmlmb3Jtcy4nLCAnJyksIHR5cGU6ICd1MzInLCBsZW5ndGg6IHZhcmlhYmxlLnJhbmt9KTtcbiAgICAgIH1cbiAgICAgIGlmICh2YXJpYWJsZS5zdHJpZGVzLnN0YXJ0c1dpdGgoJ3VuaWZvcm1zLicpKSB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMucHVzaCh7bmFtZTogdmFyaWFibGUuc3RyaWRlcy5yZXBsYWNlKCd1bmlmb3Jtcy4nLCAnJyksIHR5cGU6ICd1MzInLCBsZW5ndGg6IHZhcmlhYmxlLnJhbmt9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGRlY2xhcmVWYXJpYWJsZSh2YXJpYWJsZTogSW5kaWNlc0hlbHBlciwgYmluZGluZ0luZGV4OiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGlmICh2YXJpYWJsZS51c2FnZSA9PT0gJ2ludGVybmFsJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgdXNlIGludGVybmFsIHZhcmlhYmxlIHdpdGggZGVjbGFyZVZhcmlhYmxlKCkuIHVzZSByZWdpc3RlckludGVybmFsVmFyaWFibGVzKCkgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgdGhpcy52YXJpYWJsZXMucHVzaCh2YXJpYWJsZSk7XG4gICAgdGhpcy5hcHBlbmRWYXJpYWJsZVVuaWZvcm1zKHZhcmlhYmxlKTtcblxuICAgIGNvbnN0IGFjY2VzcyA9IHZhcmlhYmxlLnVzYWdlID09PSAnaW5wdXQnID8gJ3JlYWQnIDogJ3JlYWRfd3JpdGUnO1xuICAgIGNvbnN0IHN0b3JhZ2VUeXBlID0gdmFyaWFibGUudHlwZS5zdG9yYWdlO1xuICAgIHJldHVybiBgQGdyb3VwKDApIEBiaW5kaW5nKCR7YmluZGluZ0luZGV4fSkgdmFyPHN0b3JhZ2UsICR7YWNjZXNzfT4gJHt2YXJpYWJsZS5uYW1lfTogYXJyYXk8JHtzdG9yYWdlVHlwZX0+O2A7XG4gIH1cblxuICBkZWNsYXJlVmFyaWFibGVzKC4uLnZhcmlhYmxlczogSW5kaWNlc0hlbHBlcltdKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdmFyaWFibGVzLm1hcCh2ID0+IHRoaXMuZGVjbGFyZVZhcmlhYmxlKHYsIHRoaXMudmFyaWFibGVJbmRleCsrKSkuam9pbignXFxuJyk7XG4gIH1cblxuICBwcml2YXRlIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZSh2YXJpYWJsZTogSW5kaWNlc0hlbHBlcik6IHZvaWQge1xuICAgIGlmICh2YXJpYWJsZS51c2FnZSAhPT0gJ2ludGVybmFsJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdjYW5ub3QgdXNlIGlucHV0IG9yIG91dHB1dCB2YXJpYWJsZSB3aXRoIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZSgpLiB1c2UgZGVjbGFyZVZhcmlhYmxlcygpIGluc3RlYWQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5pbnRlcm5hbFZhcmlhYmxlcy5wdXNoKHZhcmlhYmxlKTtcbiAgICB0aGlzLmFwcGVuZFZhcmlhYmxlVW5pZm9ybXModmFyaWFibGUpO1xuICB9XG5cbiAgcmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcyguLi52YXJpYWJsZXM6IEluZGljZXNIZWxwZXJbXSk6IFNoYWRlckhlbHBlciB7XG4gICAgdmFyaWFibGVzLmZvckVhY2godiA9PiB0aGlzLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZSh2KSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZWdpc3RlclVuaWZvcm0obmFtZTogc3RyaW5nLCB0eXBlOiBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlLCBsZW5ndGggPSAxKTogU2hhZGVySGVscGVyIHtcbiAgICB0aGlzLnVuaWZvcm1zLnB1c2goe25hbWUsIHR5cGUsIGxlbmd0aH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmVnaXN0ZXJVbmlmb3JtcyhhZGRpdGlvbmFsVW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlKTogU2hhZGVySGVscGVyIHtcbiAgICB0aGlzLnVuaWZvcm1zID0gdGhpcy51bmlmb3Jtcy5jb25jYXQoYWRkaXRpb25hbFVuaWZvcm1zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHByaXZhdGUgaW50ZXJuYWxWYXJpYWJsZXM6IEluZGljZXNIZWxwZXJbXSA9IFtdO1xuICBwcml2YXRlIHZhcmlhYmxlczogSW5kaWNlc0hlbHBlcltdID0gW107XG4gIHByaXZhdGUgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW107XG4gIHByaXZhdGUgdW5pZm9ybURlY2xhcmF0aW9uKCk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMudW5pZm9ybXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgY29uc3QgdW5pZm9ybVNuaXBwZXRzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGZvciAoY29uc3Qge25hbWUsIHR5cGUsIGxlbmd0aH0gb2YgdGhpcy51bmlmb3Jtcykge1xuICAgICAgaWYgKGxlbmd0aCAmJiBsZW5ndGggPiA0KSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnZjE2Jykge1xuICAgICAgICAgIHVuaWZvcm1TbmlwcGV0cy5wdXNoKGBAYWxpZ24oMTYpICR7bmFtZX06YXJyYXk8bWF0Mng0PCR7dHlwZX0+LCAke01hdGguY2VpbChsZW5ndGggLyA4KX0+YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW5pZm9ybVNuaXBwZXRzLnB1c2goYCR7bmFtZX06YXJyYXk8dmVjNDwke3R5cGV9PiwgJHtNYXRoLmNlaWwobGVuZ3RoIC8gNCl9PmApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0eXBlVGVtcCA9IGxlbmd0aCA9PSBudWxsIHx8IGxlbmd0aCA9PT0gMSA/IHR5cGUgOiBgdmVjJHtsZW5ndGh9PCR7dHlwZX0+YDtcbiAgICAgICAgdW5pZm9ybVNuaXBwZXRzLnB1c2goYCR7bmFtZX06JHt0eXBlVGVtcH1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYFxuICAgICAgc3RydWN0IFVuaWZvcm1zIHsgJHt1bmlmb3JtU25pcHBldHMuam9pbignLCAnKX0gfTtcbiAgICAgIEBncm91cCgwKSBAYmluZGluZygke3RoaXMudmFyaWFibGVJbmRleH0pIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7YDtcbiAgfVxuICBwcml2YXRlIHZhcmlhYmxlSW5kZXggPSAwO1xuXG4gIC8qKlxuICAgKiBHZXQgYWRkaXRpb25hbCBpbXBsZW1lbnRhdGlvbiB0aGF0IG5lZWRzIHRvIGJlIGFkZGVkIHRvIHRoZSBzaGFkZXIgc291cmNlLlxuICAgKi9cbiAgZ2V0IGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy51bmlmb3JtRGVjbGFyYXRpb24oKSArIHRoaXMudmFyaWFibGVzLm1hcChpID0+IGkuaW1wbCgpKS5qb2luKCdcXG4nKSArXG4gICAgICAgIHRoaXMuaW50ZXJuYWxWYXJpYWJsZXMubWFwKGkgPT4gaS5pbXBsKCkpLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFyaWFibGUgaW5mbyBvZiB0aGUgc2hhZGVyIHByb2dyYW0uXG4gICAqL1xuICBnZXQgdmFyaWFibGVzSW5mbygpOiBQcm9ncmFtVW5pZm9ybVZhcmlhYmxlSW5mb1tdfHVuZGVmaW5lZCB7XG4gICAgaWYgKHRoaXMudW5pZm9ybXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IHVuaWZvcm1XZ3NsVHlwZVRvRGF0YVR5cGUgPSAodHlwZTogVW5pZm9ybURhdGFFbGVtZW50VHlwZSkgPT5cbiAgICAgICAgKFtEYXRhVHlwZS51aW50MzIsIERhdGFUeXBlLmZsb2F0MTYsIERhdGFUeXBlLmZsb2F0LFxuICAgICAgICAgIERhdGFUeXBlLmludDMyXVtbJ3UzMicsICdmMTYnLCAnZjMyJywgJ2kzMiddLmluZGV4T2YodHlwZSldKTtcbiAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5tYXAodSA9PiAoW3VuaWZvcm1XZ3NsVHlwZVRvRGF0YVR5cGUodS50eXBlKSwgdS5sZW5ndGggPz8gMV0pKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlU2hhZGVySGVscGVyID0gKGRpc3BhdGNoR3JvdXA6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgbGltaXRzOiBHUFVTdXBwb3J0ZWRMaW1pdHMpID0+XG4gICAgbmV3IFNoYWRlckhlbHBlckltcGwoZGlzcGF0Y2hHcm91cCwgbGltaXRzKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNvbWVzIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGZqcy9ibG9iL21hc3Rlci90ZmpzLWNvcmUvc3JjL29wcy9icm9hZGNhc3RfdXRpbC50cyNMMTgtTDQwXG4gKiBSZXR1cm5zIHRoZSBkaW1lbnNpb25zIGluIHRoZSBpbnB1dCBzaGFwZSB0aGF0IGFyZSBicm9hZGNhc3RlZCB0b1xuICogcHJvZHVjZSB0aGUgcHJvdmlkZWQgb3V0cHV0IHNoYXBlLlxuICpcbiAqIFRoZSByZXR1cm5lZCBkaW1lbnNpb25zIGFyZSAwLWluZGV4ZWQgYW5kIHNvcnRlZC4gQW4gZXhhbXBsZTpcbiAqIGluU2hhcGUgPSBbNCwgMSwgM11cbiAqIG91dFNoYXBlID0gWzUsIDQsIDMsIDNdXG4gKiByZXN1bHQgPSBbMV0uIERpbWVuc2lvbiAxICgybmQgZGltZW5zaW9uIG9mIGlucHV0KSBnZXRzIGJyb2FkY2FzdGVkIDEgPT4gMy5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEJyb2FkY2FzdERpbXMgPSAoaW5TaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIG91dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcbiAgY29uc3QgaW5SYW5rID0gaW5TaGFwZS5sZW5ndGg7XG4gIGNvbnN0IGRpbXM6IG51bWJlcltdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5SYW5rOyBpKyspIHtcbiAgICBjb25zdCBkaW0gPSBpblJhbmsgLSAxIC0gaTtcbiAgICBjb25zdCBhID0gaW5TaGFwZVtkaW1dIHx8IDE7XG4gICAgY29uc3QgYiA9IG91dFNoYXBlW291dFNoYXBlLmxlbmd0aCAtIDEgLSBpXSB8fCAxO1xuICAgIGlmIChiID4gMSAmJiBhID09PSAxKSB7XG4gICAgICBkaW1zLnVuc2hpZnQoZGltKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpbXM7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mb30gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBJbmRpY2VzSGVscGVyLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyfSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNwb3NlQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IHBlcm06IG51bWJlcltdO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3Bvc2UgcmVxdWlyZXMgMSBpbnB1dC4nKTtcbiAgfVxufTtcblxuY29uc3QgZ2V0QWRqdXN0ZWRQZXJtID0gKGlucHV0UmFuazogbnVtYmVyLCBwZXJtOiBudW1iZXJbXSk6IG51bWJlcltdID0+XG4gICAgKHBlcm0gJiYgcGVybS5sZW5ndGggIT09IGlucHV0UmFuaykgPyBbLi4uKG5ldyBBcnJheShpbnB1dFJhbmspLmtleXMoKSldLnJldmVyc2UoKSA6IHBlcm07XG5cbmNvbnN0IGdldE91dHB1dFNoYXBlID0gKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBwZXJtOiBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdID0+XG4gICAgU2hhcGVVdGlsLnNvcnRCYXNlZE9uUGVybShpbnB1dFNoYXBlLCBnZXRBZGp1c3RlZFBlcm0oaW5wdXRTaGFwZS5sZW5ndGgsIHBlcm0pKTtcblxuY29uc3QgcGVybUZ1bmN0aW9uQm9keSA9IChwZXJtOiBudW1iZXJbXSwgcmFuazogbnVtYmVyLCBpbnB1dDogSW5kaWNlc0hlbHBlciwgb3V0cHV0OiBJbmRpY2VzSGVscGVyKTogc3RyaW5nID0+IHtcbiAgY29uc3QgcmV2ZXJzZUZ1bmMgPSBbXTtcbiAgcmV2ZXJzZUZ1bmMucHVzaChgZm4gcGVybShpOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiAke2lucHV0LnR5cGUuaW5kaWNlc30ge1xuICAgIHZhciBhOiAke2lucHV0LnR5cGUuaW5kaWNlc307YCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgcmV2ZXJzZUZ1bmMucHVzaChpbnB1dC5pbmRpY2VzU2V0KCdhJywgcGVybVtpXSwgYGlbJHtpfV1gKSk7XG4gIH1cbiAgcmV2ZXJzZUZ1bmMucHVzaCgncmV0dXJuIGE7fScpO1xuICByZXR1cm4gcmV2ZXJzZUZ1bmMuam9pbignXFxuJyk7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8gPSAoaW5wdXRUZW5zb3I6IFRlbnNvclZpZXcsIHBlcm1BdHRyOiBudW1iZXJbXSk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaW5wdXREYXRhVHlwZSA9IGlucHV0VGVuc29yLmRhdGFUeXBlO1xuICBjb25zdCBpbnB1dFJhbmsgPSBpbnB1dFRlbnNvci5kaW1zLmxlbmd0aDtcbiAgY29uc3QgcGVybSA9IGdldEFkanVzdGVkUGVybShpbnB1dFJhbmssIHBlcm1BdHRyKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBnZXRPdXRwdXRTaGFwZShpbnB1dFRlbnNvci5kaW1zLCBwZXJtKTtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0RGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnYScsIGlucHV0RGF0YVR5cGUsIGlucHV0UmFuayk7XG4gIGxldCBnZXRTaGFkZXJTb3VyY2U7XG4gIGlmIChwZXJtLmxlbmd0aCA9PT0gMiAmJiBwZXJtWzBdID09PSAxICYmIHBlcm1bMV0gPT09IDApIHtcbiAgICBjb25zdCB3Z3NsVHlwZSA9IG91dHB1dC50eXBlLnZhbHVlO1xuICAgIGNvbnN0IHdvcmtncm91cFNpemU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFsxNiwgMTYsIDFdO1xuICAgIGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dF9zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGUgOiBhcnJheTxhcnJheTwke3dnc2xUeXBlfSwgJHt3b3JrZ3JvdXBTaXplWzBdICsgMX0+LCAke3dvcmtncm91cFNpemVbMF19PjtcbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KHdvcmtncm91cFNpemUpfVxuICAgIHZhciB4ID0gd29ya2dyb3VwX2lkLnggKiAke3dvcmtncm91cFNpemVbMF19dSArIGxvY2FsX2lkLng7XG4gICAgdmFyIHkgPSB3b3JrZ3JvdXBfaWQueSAqICR7d29ya2dyb3VwU2l6ZVswXX11ICsgbG9jYWxfaWQueTtcbiAgICBsZXQgd2lkdGggPSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMF07XG4gICAgbGV0IGhlaWdodCA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZVsxXTtcbiAgICBpZiAoeCA8IHdpZHRoICYmIHkgPCBoZWlnaHQpIHtcbiAgICAgIHRpbGVbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke2lucHV0LmdldEJ5T2Zmc2V0KCd5ICogd2lkdGggKyB4Jyl9O1xuICAgIH1cbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgeCA9IHdvcmtncm91cF9pZC55ICogJHt3b3JrZ3JvdXBTaXplWzBdfXUgKyBsb2NhbF9pZC54O1xuICAgIHkgPSB3b3JrZ3JvdXBfaWQueCAqICR7d29ya2dyb3VwU2l6ZVswXX11ICsgbG9jYWxfaWQueTtcbiAgICBpZiAoeCA8IGhlaWdodCAmJiB5IDwgd2lkdGgpIHtcbiAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCd5ICogaGVpZ2h0ICsgeCcsICd0aWxlW2xvY2FsX2lkLnhdW2xvY2FsX2lkLnldJyl9XG4gICAgfVxuICB9YDtcbiAgfSBlbHNlIHtcbiAgICBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxuXG4gICR7cGVybUZ1bmN0aW9uQm9keShwZXJtLCBpbnB1dFJhbmssIGlucHV0LCBvdXRwdXQpfVxuXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG5cbiAgICBsZXQgaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICBsZXQgYUluZGljZXMgPSBwZXJtKGluZGljZXMpO1xuXG4gICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCBpbnB1dC5nZXRCeUluZGljZXMoJ2FJbmRpY2VzJykpfVxuICB9YDtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdUcmFuc3Bvc2UnLFxuICAgIHNoYWRlckNhY2hlOiB7aGludDogYCR7cGVybUF0dHJ9YCwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddfSxcbiAgICBnZXRSdW5EYXRhOiAoaW5wdXRzKSA9PiB7XG4gICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX1dLFxuICAgICAgICBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgICBwcm9ncmFtVW5pZm9ybXM6XG4gICAgICAgICAgICBbe3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZX0sIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1swXS5kaW1zLCBvdXRwdXRTaGFwZSldLFxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCB0cmFuc3Bvc2UgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFRyYW5zcG9zZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sIGF0dHJpYnV0ZXMucGVybSkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlVHJhbnNwb3NlQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFRyYW5zcG9zZUF0dHJpYnV0ZXMgPT5cbiAgICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe3Blcm06IGF0dHJpYnV0ZXMucGVybSBhcyBudW1iZXJbXX0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtU2hhZGVyQ2FjaGVJbmZvfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7aW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlcn0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IHtjcmVhdGVSZWR1Y2VBdHRyaWJ1dGVzRnJvbUlucHV0cywgUmVkdWNlQXR0cmlidXRlc30gZnJvbSAnLi9yZWR1Y2UnO1xuaW1wb3J0IHtjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mb30gZnJvbSAnLi90cmFuc3Bvc2UnO1xuXG5jb25zdCByZWR1Y2VPcHM6IHtba2V5OiBzdHJpbmddOiBzdHJpbmd9ID0ge1xuICBtYXg6ICdzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA+IGJlc3RWYWx1ZSknLFxuICBtaW46ICdzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA8IGJlc3RWYWx1ZSknLFxuICBtZWFuOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJyxcbiAgc3VtOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJyxcbiAgcHJvZDogJ2Jlc3RWYWx1ZSAqIGNhbmRpZGF0ZScsXG4gIHN1bVNxdWFyZTogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZSAqIGNhbmRpZGF0ZScsXG4gIGxvZ1N1bUV4cDogJ2Jlc3RWYWx1ZSArIGV4cChjYW5kaWRhdGUpJyxcbiAgbDE6ICdiZXN0VmFsdWUgKyBhYnMoY2FuZGlkYXRlKScsXG4gIGwyOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlICogY2FuZGlkYXRlJyxcbiAgbG9nU3VtOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJ1xufTtcblxuY29uc3QgcmVkdWNlU2hhcmVkT3BzOiB7W2tleTogc3RyaW5nXTogc3RyaW5nfSA9IHtcbiAgbWF4OiAnc2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPiBiZXN0VmFsdWUpJyxcbiAgbWluOiAnc2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPCBiZXN0VmFsdWUpJyxcbiAgbWVhbjogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXG4gIHN1bTogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXG4gIHByb2Q6ICdiZXN0VmFsdWUgKiBjYW5kaWRhdGUnLFxuICBzdW1TcXVhcmU6ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxuICBsb2dTdW1FeHA6ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxuICBsMTogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXG4gIGwyOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJyxcbiAgbG9nU3VtOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJ1xufTtcblxuY29uc3QgcmVkdWNlSW5pdFZhbHVlczoge1trZXk6IHN0cmluZ106IHN0cmluZ30gPSB7XG4gIG1heDogJ19BW29mZnNldF0nLFxuICBtaW46ICdfQVtvZmZzZXRdJyxcbiAgbWVhbjogJzAnLFxuICBzdW06ICcwJyxcbiAgcHJvZDogJzEnLFxuICBzdW1TcXVhcmU6ICcwJyxcbiAgbG9nU3VtRXhwOiAnMCcsXG4gIGwxOiAnMCcsXG4gIGwyOiAnMCcsXG4gIGxvZ1N1bTogJzAnXG59O1xuXG5jb25zdCByZWR1Y2VPdXRwdXRWYWx1ZXM6IHtba2V5OiBzdHJpbmddOiBzdHJpbmd9ID0ge1xuICBtYXg6ICdiZXN0VmFsdWUnLFxuICBtaW46ICdiZXN0VmFsdWUnLFxuICBzdW06ICdiZXN0VmFsdWUnLFxuICBwcm9kOiAnYmVzdFZhbHVlJyxcbiAgc3VtU3F1YXJlOiAnYmVzdFZhbHVlJyxcbiAgbG9nU3VtRXhwOiAnbG9nKGJlc3RWYWx1ZSknLFxuICBsMTogJ2Jlc3RWYWx1ZScsXG4gIGwyOiAnc3FydChiZXN0VmFsdWUpJyxcbiAgbG9nU3VtOiAnbG9nKGJlc3RWYWx1ZSknXG59O1xuXG5jb25zdCBnZXRJbm5lck1vc3RBeGVzID0gKG51bUlubmVyQXhlczogbnVtYmVyLCByYW5rOiBudW1iZXIpOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gcmFuayAtIG51bUlubmVyQXhlczsgaSA8IHJhbms7ICsraSkge1xuICAgIHJlcy5wdXNoKGkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5jb25zdCBjb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzID0gKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgYXhlczogcmVhZG9ubHkgbnVtYmVyW10pOiBbbnVtYmVyW10sIG51bWJlcltdXSA9PiB7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gW107XG4gIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IHJhbms7IGRpbSsrKSB7XG4gICAgaWYgKGF4ZXMuaW5kZXhPZihkaW0pID09PSAtMSkge1xuICAgICAgb3V0cHV0U2hhcGUucHVzaChzaGFwZVtkaW1dKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVkdWNlU2hhcGUgPSBheGVzLm1hcChkaW0gPT4gc2hhcGVbZGltXSk7XG4gIHJldHVybiBbb3V0cHV0U2hhcGUsIHJlZHVjZVNoYXBlXTtcbn07XG5cbmNvbnN0IGV4cGFuZFNoYXBlVG9LZWVwRGltID0gKHNoYXBlOiBudW1iZXJbXSwgYXhlczogbnVtYmVyW10pOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGggKyBheGVzLmxlbmd0aDtcbiAgY29uc3QgZXhwYW5kU2hhcGUgPSBbXTtcbiAgbGV0IHNoYXBlSWR4ID0gMDtcbiAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgcmFuazsgZGltKyspIHtcbiAgICBpZiAoYXhlcy5pbmRleE9mKGRpbSkgPT09IC0xKSB7XG4gICAgICBleHBhbmRTaGFwZS5wdXNoKHNoYXBlW3NoYXBlSWR4KytdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwYW5kU2hhcGUucHVzaCgxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV4cGFuZFNoYXBlO1xufTtcblxuY29uc3QgYXJlQXhlc0lubmVyTW9zdERpbXMgPSAoYXhlczogbnVtYmVyW10sIHJhbms6IG51bWJlcik6IGJvb2xlYW4gPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXhlc1theGVzLmxlbmd0aCAtIGkgLSAxXSAhPT0gcmFuayAtIDEgLSBpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgZ2V0QXhlc1Blcm11dGF0aW9uID0gKGF4ZXM6IG51bWJlcltdLCByYW5rOiBudW1iZXIpOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBpZiAoIWFyZUF4ZXNJbm5lck1vc3REaW1zKGF4ZXMsIHJhbmspKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rOyArK2kpIHtcbiAgICAgIGlmIChheGVzLmluZGV4T2YoaSkgPT09IC0xKSB7XG4gICAgICAgIHJlcy5wdXNoKGkpO1xuICAgICAgfVxuICAgIH1cbiAgICBheGVzLmZvckVhY2goYXhpcyA9PiByZXMucHVzaChheGlzKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVSZWR1Y2VTaGFyZWRQcm9ncmFtSW5mbyA9XG4gICAgKG5hbWU6IHN0cmluZywgc2hhZGVyQ2FjaGU6IFByb2dyYW1TaGFkZXJDYWNoZUluZm8sIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCByZWR1Y2VUeXBlOiBzdHJpbmcsXG4gICAgIG91dHB1dERhdGFUeXBlOiBEYXRhVHlwZSwgb3V0cHV0U2hhcGU6IG51bWJlcltdLCByZWR1Y2VTaGFwZTogbnVtYmVyW10pOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG5cbiAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gICAgICBjb25zdCByZWR1Y2VTaXplID0gU2hhcGVVdGlsLnNpemUocmVkdWNlU2hhcGUpO1xuXG4gICAgICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ19BJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dFNoYXBlKTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBvdXRwdXREYXRhVHlwZSwgb3V0cHV0U2hhcGUpO1xuXG4gICAgICBjb25zdCB3b3JrZ3JvdXBTaXplID0gMzI7XG5cbiAgICAgIGNvbnN0IHNoYXJlZE1lbW9yeVNuaXBwZXQgPSBgXG4gICAgICAgICAgdmFyPHdvcmtncm91cD4gYUJlc3RWYWx1ZXMgOiBhcnJheTxmMzIsICR7d29ya2dyb3VwU2l6ZX0+O1xuICAgICAgIGA7XG5cbiAgICAgIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICAgICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ3JlZHVjZVNpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cbiAgICAgICAgJHtzaGFyZWRNZW1vcnlTbmlwcGV0fVxuICAgICAgICBmbiBESVZfQ0VJTChhIDogdTMyLCBiIDogdTMyKSAtPiB1MzIge1xuICAgICAgICAgIHJldHVybiAoKGEgLSAxdSkgLyBiICsgMXUpO1xuICAgICAgICAgfVxuICAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KHdvcmtncm91cFNpemUpfVxuXG4gICAgICAgICAgbGV0IG91dHB1dEluZGV4ID0gZ2xvYmFsX2lkeCAvICR7d29ya2dyb3VwU2l6ZX07XG4gICAgICAgICAgbGV0IG9mZnNldCA9IG91dHB1dEluZGV4ICogdW5pZm9ybXMucmVkdWNlU2l6ZTtcblxuICAgICAgICAgIHZhciBiZXN0VmFsdWUgPSBmMzIoJHtyZWR1Y2VJbml0VmFsdWVzW3JlZHVjZVR5cGVdfSk7XG4gICAgICAgICAgbGV0IExlbmd0aCA9IHVuaWZvcm1zLnJlZHVjZVNpemU7XG4gICAgICAgICAgZm9yICh2YXIgayA9IGxvY2FsX2lkeDsgayA8IExlbmd0aDsgayA9IGsgKyAke3dvcmtncm91cFNpemV9KSB7XG4gICAgICAgICAgIGxldCBjYW5kaWRhdGUgPSBmMzIoJHtpbnB1dC5nZXRCeU9mZnNldCgnb2Zmc2V0ICsgaycpfSk7XG4gICAgICAgICAgIGJlc3RWYWx1ZSA9ICR7cmVkdWNlT3BzW3JlZHVjZVR5cGVdfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYUJlc3RWYWx1ZXNbbG9jYWxfaWR4XSA9IGJlc3RWYWx1ZTtcbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgIHZhciByZWR1Y2VTaXplID0gbWluKExlbmd0aCwgJHt3b3JrZ3JvdXBTaXplfXUpO1xuICAgICAgICAgZm9yICh2YXIgY3VycmVudFNpemUgPSByZWR1Y2VTaXplIC8gMnU7IHJlZHVjZVNpemUgPiAxdTtcbiAgICAgICAgICAgICBjdXJyZW50U2l6ZSA9IHJlZHVjZVNpemUgLyAydSkge1xuICAgICAgICAgICBsZXQgaW50ZXJ2YWwgPSBESVZfQ0VJTChyZWR1Y2VTaXplLCAydSk7XG4gICAgICAgICAgIGlmIChsb2NhbF9pZHggPCBjdXJyZW50U2l6ZSkge1xuICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IGFCZXN0VmFsdWVzW2xvY2FsX2lkeCArIGludGVydmFsXTtcbiAgICAgICAgICAgIGJlc3RWYWx1ZSA9ICR7cmVkdWNlU2hhcmVkT3BzW3JlZHVjZVR5cGVdfTtcbiAgICAgICAgICAgIGFCZXN0VmFsdWVzW2xvY2FsX2lkeF0gPSBiZXN0VmFsdWU7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgcmVkdWNlU2l6ZSA9IGludGVydmFsO1xuICAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmIChsb2NhbF9pZHggPT0gMHUpIHtcbiAgICAgICAgICAke1xuICAgICAgICAgIG91dHB1dC5zZXRCeU9mZnNldChcbiAgICAgICAgICAgICAgJ291dHB1dEluZGV4JyxcbiAgICAgICAgICAgICAgYCR7XG4gICAgICAgICAgICAgICAgICByZWR1Y2VUeXBlID09PSAnbWVhbicgPyBgJHtvdXRwdXQudHlwZS5zdG9yYWdlfShiZXN0VmFsdWUgLyBmMzIodW5pZm9ybXMucmVkdWNlU2l6ZSkpYCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHtvdXRwdXQudHlwZS5zdG9yYWdlfSgke3JlZHVjZU91dHB1dFZhbHVlc1tyZWR1Y2VUeXBlXX0pYH1gKX07XG4gICAgICAgICB9XG4gICAgICAgIH1gO1xuXG4gICAgICAvLyBPbmUgd29yayBncm91cCBpcyByZXNwb25zaWJsZSBmb3Igb25seSBvbmUgZWxlbWVudCBvZiBvdXRwdXQuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lLFxuICAgICAgICBzaGFkZXJDYWNoZSxcbiAgICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICAgIG91dHB1dHM6IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBvdXRwdXREYXRhVHlwZX1dLFxuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBvdXRwdXRTaXplfSxcbiAgICAgICAgICBwcm9ncmFtVW5pZm9ybXM6IFt7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiByZWR1Y2VTaXplfV1cbiAgICAgICAgfSksXG4gICAgICB9O1xuICAgIH07XG5cbmNvbnN0IHJlZHVjZUNvbW1vbiA9XG4gICAgKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBuYW1lOiBzdHJpbmcsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMsXG4gICAgIHJlZHVjZVR5cGU6ICdzdW0nfCdzdW1TcXVhcmUnfCdwcm9kJ3wnbWluJ3wnbWF4J3wnbWVhbid8J2xvZ1N1bUV4cCd8J2wxJ3wnbDInfCdsb2dTdW0nKTogdm9pZCA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkQXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyA9XG4gICAgICAgICAgY29udGV4dC5pbnB1dHMubGVuZ3RoID09PSAxID8gYXR0cmlidXRlcyA6IGNyZWF0ZVJlZHVjZUF0dHJpYnV0ZXNGcm9tSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcblxuICAgICAgbGV0IHVwZGF0ZWRBeGVzID0gdXBkYXRlZEF0dHJpYnV0ZXMuYXhlcztcbiAgICAgIGlmICh1cGRhdGVkQXhlcy5sZW5ndGggPT09IDAgJiYgIXVwZGF0ZWRBdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSB7XG4gICAgICAgIHVwZGF0ZWRBeGVzID0gY29udGV4dC5pbnB1dHNbMF0uZGltcy5tYXAoKF9kaW0sIGkpID0+IGkpO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9ybWFsaXplQXhlcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKHVwZGF0ZWRBeGVzLCBjb250ZXh0LmlucHV0c1swXS5kaW1zLmxlbmd0aCk7XG5cbiAgICAgIGxldCBheGVzID0gbm9ybWFsaXplQXhlcztcbiAgICAgIGxldCBpbnB1dCA9IGNvbnRleHQuaW5wdXRzWzBdO1xuICAgICAgY29uc3QgcGVybXV0ZWRBeGVzID0gZ2V0QXhlc1Blcm11dGF0aW9uKGF4ZXMsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtcbiAgICAgIGlmIChwZXJtdXRlZEF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpbnB1dCA9IGNvbnRleHQuY29tcHV0ZShcbiAgICAgICAgICAgIGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCBwZXJtdXRlZEF4ZXMpLCB7aW5wdXRzOiBbMF0sIG91dHB1dHM6IFstMV19KVswXTtcbiAgICAgICAgYXhlcyA9IGdldElubmVyTW9zdEF4ZXMoYXhlcy5sZW5ndGgsIGlucHV0LmRpbXMubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgW291dHB1dFNoYXBlLCByZWR1Y2VTaGFwZV0gPSBjb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKGlucHV0LmRpbXMsIGF4ZXMpO1xuICAgICAgbGV0IGZpbmFsT3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZTtcbiAgICAgIGlmICh1cGRhdGVkQXR0cmlidXRlcy5rZWVwRGltcykge1xuICAgICAgICBmaW5hbE91dHB1dFNoYXBlID0gZXhwYW5kU2hhcGVUb0tlZXBEaW0ob3V0cHV0U2hhcGUsIG5vcm1hbGl6ZUF4ZXMpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgICAgY3JlYXRlUmVkdWNlU2hhcmVkUHJvZ3JhbUluZm8oXG4gICAgICAgICAgICAgIG5hbWUsIHtoaW50OiB1cGRhdGVkQXR0cmlidXRlcy5jYWNoZUtleSwgaW5wdXREZXBlbmRlbmNpZXM6IFsndHlwZSddfSwgW2lucHV0XSwgcmVkdWNlVHlwZSxcbiAgICAgICAgICAgICAgY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsIGZpbmFsT3V0cHV0U2hhcGUsIHJlZHVjZVNoYXBlKSxcbiAgICAgICAgICB7aW5wdXRzOiBbaW5wdXRdfSk7XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZU1lYW5TaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VNZWFuU2hhcmVkJywgYXR0cmlidXRlcywgJ21lYW4nKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VMMVNoYXJlZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZUwxU2hhcmVkJywgYXR0cmlidXRlcywgJ2wxJyk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlTDJTaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VMMlNoYXJlZCcsIGF0dHJpYnV0ZXMsICdsMicpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUxvZ1N1bUV4cFNoYXJlZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZUxvZ1N1bUV4cFNoYXJlZCcsIGF0dHJpYnV0ZXMsICdsb2dTdW1FeHAnKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VNYXhTaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VNYXhTaGFyZWQnLCBhdHRyaWJ1dGVzLCAnbWF4Jyk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlTWluU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlTWluU2hhcmVkJywgYXR0cmlidXRlcywgJ21pbicpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZVByb2RTaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VQcm9kU2hhcmVkJywgYXR0cmlidXRlcywgJ3Byb2QnKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VTdW1TaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VTdW1TaGFyZWQnLCBhdHRyaWJ1dGVzLCAnc3VtJyk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlU3VtU3F1YXJlU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlU3VtU3F1YXJlU2hhcmVkJywgYXR0cmlidXRlcywgJ3N1bVNxdWFyZScpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUxvZ1N1bVNoYXJlZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZUxvZ1N1bVNoYXJlZCcsIGF0dHJpYnV0ZXMsICdsb2dTdW0nKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtU2hhZGVyQ2FjaGVJbmZvfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIEluZGljZXNIZWxwZXIsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXJ9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7cmVkdWNlTDFTaGFyZWQsIHJlZHVjZUwyU2hhcmVkLCByZWR1Y2VMb2dTdW1FeHBTaGFyZWQsIHJlZHVjZUxvZ1N1bVNoYXJlZCwgcmVkdWNlTWF4U2hhcmVkLCByZWR1Y2VNZWFuU2hhcmVkLCByZWR1Y2VNaW5TaGFyZWQsIHJlZHVjZVByb2RTaGFyZWQsIHJlZHVjZVN1bVNoYXJlZCwgcmVkdWNlU3VtU3F1YXJlU2hhcmVkfSBmcm9tICcuL3JlZHVjZS1zaGFyZWQnO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoID09PSAwIHx8IGlucHV0cy5sZW5ndGggPiAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2Ugb3AgcmVxdWlyZXMgMSBvciAyIGlucHV0cy4nKTtcbiAgfVxuXG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSAyICYmIGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBheGVzIGlucHV0IGRpbXMuJyk7XG4gIH1cbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVkdWNlQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIGtlZXBEaW1zOiBib29sZWFuO1xuICBub29wV2l0aEVtcHR5QXhlczogYm9vbGVhbjtcbiAgYXhlczogbnVtYmVyW107XG59XG5cbmV4cG9ydCB0eXBlIFJlZHVjZU9wID1cbiAgICAoaW5wdXQ6IEluZGljZXNIZWxwZXIsIG91dHB1dDogSW5kaWNlc0hlbHBlcixcbiAgICAgYXhlczogcmVhZG9ubHkgbnVtYmVyW10pID0+IFtzdHJpbmcsIHN0cmluZywgc3RyaW5nLCBzdHJpbmcsIC4uLnN0cmluZ1tdXTtcblxuY29uc3Qgbm9PcDogUmVkdWNlT3AgPSAoaW5wdXQpID0+IFsnJywgJycsIGB2YXIgdmFsdWUgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtgLCAnJ107XG5leHBvcnQgY29uc3QgY3JlYXRlUmVkdWNlUHJvZ3JhbUluZm8gPVxuICAgIChuYW1lOiBzdHJpbmcsIHNoYWRlckNhY2hlOiBQcm9ncmFtU2hhZGVyQ2FjaGVJbmZvLCBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgcmVkdWNlT3A6IFJlZHVjZU9wLFxuICAgICBheGVzSW5wdXQ6IG51bWJlcltdLCBvdXRwdXREYXRhVHlwZTogRGF0YVR5cGUsIGtlZXBEaW1zID0gZmFsc2UsIG5vb3BXaXRoRW1wdHlBeGVzID0gZmFsc2UpOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZTogbnVtYmVyW10gPSBbXTtcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICAgIGNvbnN0IGlucHV0UmFuayA9IGlucHV0U2hhcGUubGVuZ3RoO1xuICAgICAgY29uc3QgYXhlcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGVzKGF4ZXNJbnB1dCwgaW5wdXRSYW5rKTtcbiAgICAgIGNvbnN0IHJlZHVjZU9uQWxsQXhlcyA9ICFub29wV2l0aEVtcHR5QXhlcyAmJiBheGVzLmxlbmd0aCA9PT0gMDtcbiAgICAgIGlucHV0U2hhcGUuZm9yRWFjaCgoZCwgaSkgPT4ge1xuICAgICAgICBpZiAocmVkdWNlT25BbGxBeGVzIHx8IGF4ZXMuaW5kZXhPZihpKSA+PSAwKSB7XG4gICAgICAgICAgaWYgKGtlZXBEaW1zKSB7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZS5wdXNoKDEpO1xuICAgICAgICAgIH0gIC8vIGVsc2UgeyAvLyBza2lwIHRoaXMgYXhpc31cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXRTaGFwZS5wdXNoKGQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG91dHB1dFJhbmsgPSBvdXRwdXRTaGFwZS5sZW5ndGg7XG4gICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICAgICAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGlkeENvcHk6IHN0cmluZ1tdID0gW107ICAvLyBjb3B5IG91dHB1dCBpbmRleGVzIHRvIGlucHV0IGluZGV4ZXNcblxuICAgICAgICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ19BJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dFJhbmspO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0Jywgb3V0cHV0RGF0YVR5cGUsIG91dHB1dFJhbmspO1xuICAgICAgICBjb25zdCBvcHMgPSByZWR1Y2VPcChpbnB1dCwgb3V0cHV0LCBheGVzKTtcbiAgICAgICAgbGV0IHJlZHVjZU9wcyA9IG9wc1syXTtcblxuICAgICAgICBmb3IgKGxldCBrID0gMCwgbCA9IDA7IGsgPCBpbnB1dFJhbms7IGsrKykge1xuICAgICAgICAgIC8vIGlmIHRoaXMgYXhpcyBpcyByZWR1Y2VkXG4gICAgICAgICAgaWYgKHJlZHVjZU9uQWxsQXhlcyB8fCBheGVzLmluZGV4T2YoaykgPj0gMCkge1xuICAgICAgICAgICAgaWYgKGtlZXBEaW1zKSB7XG4gICAgICAgICAgICAgIGwrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxvb3Agb3ZlciB0aGUgZC10aCBheGlzXG4gICAgICAgICAgICByZWR1Y2VPcHMgPSBgZm9yKHZhciBqJHtrfTogdTMyID0gMDsgaiR7a30gPCAke2lucHV0U2hhcGVba119OyBqJHtrfSsrKSB7XG4gICAgICAgICAgICAgICAgICAke29wc1syXS5pbmNsdWRlcygnbGFzdF9pbmRleCcpID8gYGxldCBsYXN0X2luZGV4ID0gaiR7a307YCA6ICcnfVxuICAgICAgICAgICAgICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgaywgYGoke2t9YCl9XG4gICAgICAgICAgICAgICAgICAke3JlZHVjZU9wc31cbiAgICAgICAgICAgICAgICB9YDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWR4Q29weS5wdXNoKGAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCBrLCBvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCBsKSl9O2ApO1xuICAgICAgICAgICAgbCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFxuXG4gICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0X3NpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cblxuICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICAgICAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc307XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuXG4gICAgICAgICAgJHtpZHhDb3B5LmpvaW4oJ1xcbicpfVxuICAgICAgICAgICR7b3BzWzBdfSAgICAgICAvLyBpbml0IG9wcyBmb3IgcmVkdWNlIG1heC9taW5cbiAgICAgICAgICAke29wc1sxXX1cbiAgICAgICAgICAke3JlZHVjZU9wc31cbiAgICAgICAgICAke29wc1szXX1cbiAgICAgICAgICAke29wcy5sZW5ndGggPT09IDQgPyBvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWUnKSA6IG9wcy5zbGljZSg0KS5qb2luKCdcXG4nKX1cbiAgICAgICAgfWA7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lLFxuICAgICAgICBzaGFkZXJDYWNoZSxcbiAgICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICAgIG91dHB1dHM6IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBvdXRwdXREYXRhVHlwZX1dLFxuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKX0sXG4gICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zOlxuICAgICAgICAgICAgICBbe3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZX0sIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0U2hhcGUsIG91dHB1dFNoYXBlKV1cbiAgICAgICAgfSksXG4gICAgICB9O1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVSZWR1Y2VBdHRyaWJ1dGVzRnJvbUlucHV0cyA9XG4gICAgKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogUmVkdWNlQXR0cmlidXRlcyA9PiB7XG4gICAgICBjb25zdCBheGVzOiBudW1iZXJbXSA9IFtdO1xuICAgICAgaWYgKGlucHV0c1sxXS5kaW1zWzBdID4gMCkge1xuICAgICAgICBpbnB1dHNbMV0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2godiA9PiBheGVzLnB1c2goTnVtYmVyKHYpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KFxuICAgICAgICAgIHtheGVzLCBrZWVwRGltczogYXR0cmlidXRlcy5rZWVwRGltcywgbm9vcFdpdGhFbXB0eUF4ZXM6IGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXN9KTtcbiAgICB9O1xuXG5jb25zdCBydW5SZWR1Y2VQcm9ncmFtID1cbiAgICAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIG5hbWU6IHN0cmluZywgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcywgcmVkdWNlT3A6IFJlZHVjZU9wKTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBpbnB1dHMgPSBjb250ZXh0LmlucHV0cztcbiAgICAgIGNvbnN0IHVwZGF0ZWRBdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzID1cbiAgICAgICAgICBpbnB1dHMubGVuZ3RoID09PSAxID8gYXR0cmlidXRlcyA6IGNyZWF0ZVJlZHVjZUF0dHJpYnV0ZXNGcm9tSW5wdXRzKGlucHV0cywgYXR0cmlidXRlcyk7XG5cbiAgICAgIGNvbnRleHQuY29tcHV0ZShcbiAgICAgICAgICBjcmVhdGVSZWR1Y2VQcm9ncmFtSW5mbyhcbiAgICAgICAgICAgICAgbmFtZSwge2hpbnQ6IHVwZGF0ZWRBdHRyaWJ1dGVzLmNhY2hlS2V5LCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ119LCBbaW5wdXRzWzBdXSxcbiAgICAgICAgICAgICAgdXBkYXRlZEF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMgJiYgdXBkYXRlZEF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggPT09IDAgPyBub09wIDogcmVkdWNlT3AsXG4gICAgICAgICAgICAgIHVwZGF0ZWRBdHRyaWJ1dGVzLmF4ZXMsIGlucHV0c1swXS5kYXRhVHlwZSwgdXBkYXRlZEF0dHJpYnV0ZXMua2VlcERpbXMsXG4gICAgICAgICAgICAgIHVwZGF0ZWRBdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSxcbiAgICAgICAgICB7aW5wdXRzOiBbMF19KTtcbiAgICB9O1xuXG5jb25zdCByZWR1Y2VMb2dTdW1OYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0KSA9PlxuICAgICAgW2B2YXIgdmFsdWUgPSAke291dHB1dC50eXBlLnN0b3JhZ2V9KDApO2AsXG4gICAgICAgJycsXG4gICAgICAgYHZhbHVlICs9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O2AsXG4gICAgICAgJ3ZhbHVlID0gbG9nKHZhbHVlKTsnLFxuICBdO1xuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VMb2dTdW0nLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XG59O1xuXG5jb25zdCByZWR1Y2VMMU5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQpID0+XG4gICAgICBbYHZhciB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUuc3RvcmFnZX0oMCk7YCxcbiAgICAgICAnJyxcbiAgICAgICBgdmFsdWUgKz0gYWJzKCR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9KTtgLFxuICAgICAgICcnLFxuICBdO1xuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VMMScsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcbn07XG5cbmNvbnN0IHJlZHVjZUwyTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCkgPT5cbiAgICAgIFtgdmFyIHQgPSAke291dHB1dC50eXBlLnZhbHVlfSgwKTsgdmFyIHZhbHVlID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMCk7YCxcbiAgICAgICAnJyxcbiAgICAgICBgdCA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9OyB2YWx1ZSArPSAodCAqIHQpO2AsXG4gICAgICAgJ3ZhbHVlID0gc3FydCh2YWx1ZSk7JyxcbiAgXTtcbiAgcnVuUmVkdWNlUHJvZ3JhbShjb250ZXh0LCAnUmVkdWNlTDInLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XG59O1xuXG5jb25zdCByZWR1Y2VMb2dTdW1FeHBOYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0KSA9PlxuICAgICAgW2B2YXIgdmFsdWUgPSAke291dHB1dC50eXBlLnN0b3JhZ2V9KDApO2AsXG4gICAgICAgJycsXG4gICAgICAgYHZhbHVlICs9IGV4cCgke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfSk7YCxcbiAgICAgICAndmFsdWUgPSBsb2codmFsdWUpOycsXG4gIF07XG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZUxvZ1N1bUV4cCcsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcbn07XG5cbmNvbnN0IHJlZHVjZU1heE5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBfb3V0cHV0LCBheGVzKSA9PiB7XG4gICAgY29uc3QgaWR4WmVybyA9IFtdO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXQucmFuazsgaysrKSB7XG4gICAgICBpZiAoYXhlcy5pbmRleE9mKGspID49IDAgfHwgYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWR4WmVyby5wdXNoKGlucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCBrLCAwKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtcbiAgICAgIGAke2lkeFplcm8uam9pbignXFxuJyl9YCxcbiAgICAgIGB2YXIgdmFsdWUgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtgLFxuICAgICAgYHZhbHVlID0gbWF4KHZhbHVlLCAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfSk7YCxcbiAgICAgICcnLFxuICAgIF07XG4gIH07XG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZU1heCcsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcbn07XG5cbmNvbnN0IHJlZHVjZU1lYW5OYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0LCBheGVzKSA9PiB7XG4gICAgbGV0IHNpemUgPSAxLjA7XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBpbnB1dC5yYW5rOyBrKyspIHtcbiAgICAgIGlmIChheGVzLmluZGV4T2YoaykgPj0gMCB8fCBheGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBUT0RPOiB0aGlzIGRlcGVuZHMgb24gdGhlIGlucHV0IGRpbXMuIElmIHdlIHdhbnQgdG8gdXNlIHVuaWZvcm0sIHRoaXMgbmVlZCB0byBiZSB1cGRhdGVkLlxuICAgICAgICBzaXplICo9IGNvbnRleHQuaW5wdXRzWzBdLmRpbXNba107XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtcbiAgICAgICd2YXIgc3VtID0gZjMyKDApOycsXG4gICAgICAnJyxcbiAgICAgIGBzdW0gKz0gZjMyKCR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9KTtgLFxuICAgICAgYGxldCB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KHN1bSAvICR7c2l6ZX0pO2AsXG4gICAgXTtcbiAgfTtcbiAgcnVuUmVkdWNlUHJvZ3JhbShjb250ZXh0LCAnUmVkdWNlTWVhbicsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcbn07XG5cbmNvbnN0IHJlZHVjZU1pbk5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBfb3V0cHV0LCBheGVzKSA9PiB7XG4gICAgY29uc3QgaWR4WmVybyA9IFtdO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXQucmFuazsgaysrKSB7XG4gICAgICBpZiAoYXhlcy5pbmRleE9mKGspID49IDAgfHwgYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWR4WmVyby5wdXNoKGBpbnB1dF9pbmRpY2VzWyR7a31dID0gMDtgKTsgIC8vIGZpcnN0IGVsZW1lbnRcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgYCR7aWR4WmVyby5qb2luKCdcXG4nKX1gLFxuICAgICAgYHZhciB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O2AsXG4gICAgICBgdmFsdWUgPSBtaW4odmFsdWUsICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9KTtgLFxuICAgICAgJycsXG4gICAgXTtcbiAgfTtcbiAgcnVuUmVkdWNlUHJvZ3JhbShjb250ZXh0LCAnUmVkdWNlTWluJywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xufTtcblxuY29uc3QgcmVkdWNlUHJvZE5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQpID0+XG4gICAgICBbYHZhciB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUuc3RvcmFnZX0oMSk7YCxcbiAgICAgICAnJyxcbiAgICAgICBgdmFsdWUgKj0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07YCxcbiAgICAgICAnJyxcbiAgXTtcbiAgcnVuUmVkdWNlUHJvZ3JhbShjb250ZXh0LCAnUmVkdWNlUHJvZCcsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcbn07XG5cbmNvbnN0IHJlZHVjZVN1bU5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQpID0+XG4gICAgICBbYHZhciB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUuc3RvcmFnZX0oMCk7YCxcbiAgICAgICAnJyxcbiAgICAgICBgdmFsdWUgKz0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07YCxcbiAgICAgICAnJyxcbiAgXTtcbiAgcnVuUmVkdWNlUHJvZ3JhbShjb250ZXh0LCAnUmVkdWNlU3VtJywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xufTtcblxuY29uc3QgcmVkdWNlU3VtU3F1YXJlTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCkgPT5cbiAgICAgIFtgdmFyIHQgPSAke291dHB1dC50eXBlLnZhbHVlfSgwKTsgdmFyIHZhbHVlID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMCk7YCxcbiAgICAgICAnJyxcbiAgICAgICBgdCA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9OyB2YWx1ZSArPSB0ICogdDtgLFxuICAgICAgICcnLFxuICBdO1xuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VTdW1TcXVhcmUnLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XG59O1xuXG5jb25zdCB1c2VOYWl2ZVJlZHVjZU1ldGhvZCA9XG4gICAgKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgYXhlczogcmVhZG9ubHkgbnVtYmVyW10sIG5vb3BXaXRoRW1wdHlBeGVzOiBib29sZWFuKTogYm9vbGVhbiA9PiB7XG4gICAgICBpZiAoYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5vb3BXaXRoRW1wdHlBeGVzO1xuICAgICAgfVxuXG4gICAgICBsZXQgb3V0cHV0U2l6ZSA9IDE7XG4gICAgICBsZXQgcmVkdWNlU2l6ZSA9IDE7XG4gICAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBheGVzLmxlbmd0aDsgZGltKyspIHtcbiAgICAgICAgaWYgKGF4ZXMuaW5kZXhPZihkaW0pID09PSAtMSkge1xuICAgICAgICAgIG91dHB1dFNpemUgKj0gc2hhcGVbZGltXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWR1Y2VTaXplICo9IHNoYXBlW2RpbV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbmRpdGlvbiBkYXRhIGlzIHZlcnkgcm91Z2gsIGFsdGhvdWdoIGNvbnNpZGVyaW5nIHRoZSBjb3VudCBvZiBFeGVjdXRpb24gVW5pdCAoRVUpLCB0aGUgcG90ZW50aWFsXG4gICAgICAvLyB3b3JrIGdyb3VwcyBpbiBhIEVVIGFuZCB0aGUgY291bnRzIG9mIGxvb3BzIGluIHRoZSBuYWl2ZSBhbmQgc2hhcmVkIG1ldGhvZHMsIGFsc28gZG9pbmcgZXhwZXJpbWVudHNcbiAgICAgIC8vIG9uIHNvbWUgbWFjaGluZXMuXG4gICAgICByZXR1cm4gcmVkdWNlU2l6ZSA8IDMyICYmIG91dHB1dFNpemUgPiAxMDI0O1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VNZWFuID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmICh1c2VOYWl2ZVJlZHVjZU1ldGhvZChjb250ZXh0LmlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLmF4ZXMsIGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpKSB7XG4gICAgcmVkdWNlTWVhbk5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlZHVjZU1lYW5TaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VMMSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xuICAgIHJlZHVjZUwxTmFpdmUoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVkdWNlTDFTaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VMMiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xuICAgIHJlZHVjZUwyTmFpdmUoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVkdWNlTDJTaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VMb2dTdW1FeHAgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcbiAgICByZWR1Y2VMb2dTdW1FeHBOYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWR1Y2VMb2dTdW1FeHBTaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VNYXggPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcbiAgICByZWR1Y2VNYXhOYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWR1Y2VNYXhTaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VNaW4gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcbiAgICByZWR1Y2VNaW5OYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWR1Y2VNaW5TaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VQcm9kID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmICh1c2VOYWl2ZVJlZHVjZU1ldGhvZChjb250ZXh0LmlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLmF4ZXMsIGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpKSB7XG4gICAgcmVkdWNlUHJvZE5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlZHVjZVByb2RTaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VTdW0gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcbiAgICByZWR1Y2VTdW1OYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWR1Y2VTdW1TaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VTdW1TcXVhcmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcbiAgICByZWR1Y2VTdW1TcXVhcmVOYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWR1Y2VTdW1TcXVhcmVTaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VMb2dTdW0gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcbiAgICByZWR1Y2VMb2dTdW1OYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWR1Y2VMb2dTdW1TaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8vIFRPRE86IHRoaXMgaXMgdGhlIHNhbWUgbmFpdmUgaW1wbGVtZW50YXRpb24gd2UgdXNlIGZvciByZWR1Y2UgdGhhdCBoYXNcbi8vIHBlcmZvcm1hbmNlIGxpbWl0YXRpb25zIHdoZW4gdGhlIHJlZHVjZWQgYXhpcyBpcyBsb25nLiBOZWVkIHRvIGFkZFxuLy8gYSBvcHRpbWl6ZWQgY29kZXBhdGggZm9yIHRoaXMuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHR9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVSZWR1Y2VQcm9ncmFtSW5mbywgUmVkdWNlT3B9IGZyb20gJy4vcmVkdWNlJztcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCA9PT0gMCB8fCBpbnB1dHMubGVuZ3RoID4gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignQXJnTWluTWF4T3Agb3AgcmVxdWlyZXMgMSBvciAyIGlucHV0cy4nKTtcbiAgfVxuICBpZiAoaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5mbG9hdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0eXBlLicpO1xuICB9XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEFyZ01pbk1heEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBrZWVwRGltczogYm9vbGVhbjtcbiAgYXhpczogbnVtYmVyO1xuICBzZWxlY3RMYXN0SW5kZXg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IGFyZ01pbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQXJnTWluTWF4QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IGFyZ01pbk1heE9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0LCBheGVzKSA9PiB7XG4gICAgY29uc3QgaWR4WmVybyA9IFtdO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXQucmFuazsgaysrKSB7XG4gICAgICBpZiAoYXhlcy5pbmRleE9mKGspID49IDAgfHwgYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWR4WmVyby5wdXNoKGBpbnB1dF9pbmRpY2VzWyR7a31dID0gMDtgKTsgIC8vIGZpcnN0IGVsZW1lbnRcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIGAke2lkeFplcm8uam9pbignXFxuJyl9YCwgYHZhciB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O1xcbnZhciBiZXN0X2luZGV4IDogaTMyID0gMDtgLFxuICAgICAgYGlmICgke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfSAke2F0dHJpYnV0ZXMuc2VsZWN0TGFzdEluZGV4ID4gMCA/ICc8PScgOiAnPCd9IHZhbHVlKSB7XG4gICAgICAgICB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O1xuICAgICAgICAgYmVzdF9pbmRleCA9IGkzMihsYXN0X2luZGV4KTtcbiAgICAgICB9YCxcbiAgICAgICcnLCBvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAnYmVzdF9pbmRleCcpXG4gICAgXTtcbiAgfTtcblxuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgICBjcmVhdGVSZWR1Y2VQcm9ncmFtSW5mbyhcbiAgICAgICAgICAnQXJnTWluJywge2hpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXX0sIFtjb250ZXh0LmlucHV0c1swXV0sIGFyZ01pbk1heE9wLFxuICAgICAgICAgIFthdHRyaWJ1dGVzLmF4aXNdLCBEYXRhVHlwZS5pbnQ2NCwgYXR0cmlidXRlcy5rZWVwRGltcyksXG4gICAgICB7aW5wdXRzOiBbMF19KTtcbn07XG5cbmV4cG9ydCBjb25zdCBhcmdNYXggPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEFyZ01pbk1heEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCBhcmdNaW5NYXhPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCwgYXhlcykgPT4ge1xuICAgIGNvbnN0IGlkeFplcm8gPSBbXTtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IGlucHV0LnJhbms7IGsrKykge1xuICAgICAgaWYgKGF4ZXMuaW5kZXhPZihrKSA+PSAwIHx8IGF4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlkeFplcm8ucHVzaChgaW5wdXRfaW5kaWNlc1ske2t9XSA9IDA7YCk7ICAvLyBmaXJzdCBlbGVtZW50XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICBgJHtpZHhaZXJvLmpvaW4oJ1xcbicpfWAsIGB2YXIgdmFsdWUgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcXG52YXIgYmVzdF9pbmRleCA6IGkzMiA9IDA7YCxcbiAgICAgIGBpZiAoJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX0gJHthdHRyaWJ1dGVzLnNlbGVjdExhc3RJbmRleCA+IDAgPyAnPj0nIDogJz4nfSB2YWx1ZSkge1xuICAgICAgICAgdmFsdWUgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcbiAgICAgICAgIGJlc3RfaW5kZXggPSBpMzIobGFzdF9pbmRleCk7XG4gICAgICAgfWAsXG4gICAgICAnJywgb3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ2Jlc3RfaW5kZXgnKVxuICAgIF07XG4gIH07XG5cbiAgY29udGV4dC5jb21wdXRlKFxuICAgICAgY3JlYXRlUmVkdWNlUHJvZ3JhbUluZm8oXG4gICAgICAgICAgJ2FyZ01heCcsIHtoaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ119LCBbY29udGV4dC5pbnB1dHNbMF1dLCBhcmdNaW5NYXhPcCxcbiAgICAgICAgICBbYXR0cmlidXRlcy5heGlzXSwgRGF0YVR5cGUuaW50NjQsIGF0dHJpYnV0ZXMua2VlcERpbXMpLFxuICAgICAge2lucHV0czogWzBdfSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VBcmdNaW5NYXhBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQXJnTWluTWF4QXR0cmlidXRlcyA9PlxuICAgIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShhdHRyaWJ1dGVzIGFzIE9taXQ8QXJnTWluTWF4QXR0cmlidXRlcywga2V5b2YgQXR0cmlidXRlV2l0aENhY2hlS2V5Pik7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgR3B1RGF0YVR5cGUsIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2dldE1heENvbXBvbmVudHMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSwgdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZSwgVW5pZm9ybURhdGFFbGVtZW50VHlwZSwgVW5pZm9ybXNBcnJheVR5cGV9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGNvbnN0IGVudW0gQXR0ZW50aW9uUWt2Rm9ybWF0IHtcbiAgdW5rbm93biwgICAgICAgICAgLy8gZW51bSB2YWx1ZSBub3Qgc2V0LCBvciBkZXBlbmRzIG9uIHFrdiBwcm9qZWN0aW9uIGltcGxlbWVudGF0aW9uIGRldGFpbHNcbiAgcWt2Qk5TSCwgICAgICAgICAgLy8gZm9yIG5vbi1wYWNrZWQgcWt2LCBwZXJtdXRlZFxuICBxa3ZCU05ILCAgICAgICAgICAvLyBmb3Igbm9uLXBhY2tlZCBxa3YsIG5vdCBwZXJtdXRlZCwgdXNlZCBieSBtZW1vcnkgZWZmaWNpZW50IGF0dGVudGlvbiBvciBNdWx0aUhlYWRBdHRlbnRpb25cbiAgcWt2QlNOM0gsICAgICAgICAgLy8gZm9yIFRSVCBmdXNlZCBhdHRlbnRpb24sIHFrdiBhcmUgcGFja2VkXG4gIHFrdkJOU0hxa3ZCUzNOSCwgIC8vIGZvciBUUlQgZnVzZWQgY2F1c2FsIGF0dGVudGlvbiwgZGF0YSBoYXMgdHdvIGZvcm1hdHMgKHFrdiBpcyAzQk5TSCwgZ2VtbV9idWZmZXIgaXMgQlMzTkgpXG4gIHFLdkJTTkh4QlNOMkgsICAgIC8vIGZvciBUUlQgZnVzZWQgY3Jvc3MgYXR0ZW50aW9uLCBrdiBhcmUgcGFja2VkXG4gIHFrdlROSCwgICAgICAgICAgIC8vIGZvciBtZW1vcnkgZWZmaWNpZW50IGF0dGVudGlvbiwgcWt2IGFyZSBub3QgcGFja2VkLCBhbmQgcGFkZGluZ3MgYXJlIHJlbW92ZWQuXG4gIHFrdlROM0gsICAgICAgICAgIC8vIGZvciBUUlQgZnVzZWQgYXR0ZW50aW9uLCBxa3YgYXJlIHBhY2tlZCBhbmQgcGFkZGluZ3MgYXJlIHJlbW92ZWRcbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gQXR0ZW50aW9uTWFza1R5cGUge1xuICBub25lLCAgICAgICAgICAgICAgICAgIC8vIE5vIG1hc2tcbiAgbWFzazFkS2V5U2VxTGVuLCAgICAgICAvLyBbYmF0Y2hfc2l6ZV0sIGtleSBzZXF1ZW5jZSBsZW5ndGhcbiAgbWFzazFkRW5kU3RhcnQsICAgICAgICAvLyBbMiAqIGJhdGNoX3NpemVdIHdpdGggZW5kIHBvc2l0aW9ucyBhbmQgc3RhcnQgcG9zaXRpb25zXG4gIG1hc2sxREtleVNlcUxlblN0YXJ0LCAgLy8gWzMgKiBiYXRjaF9zaXplICsgMl0gd2l0aCBba2V5X2xlblswXSwgLi4uLCBrZXlfbGVuW2JhdGNoX3NpemUgLSAxXSwgcXVlcnlfc3RhcnRbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uLCBxdWVyeV9zdGFydFtiYXRjaF9zaXplIC0gMV0sIHF1ZXJ5X2VuZFtiYXRjaF9zaXplIC0gMV0sIGtleV9zdGFydFswXSwgLi4uLFxuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtleV9zdGFydFtiYXRjaF9zaXplIC0gMV0sIGtleV9lbmRbYmF0Y2hfc2l6ZSAtIDFdXVxuICBtYXNrMmREdW1teSwgICAgICAgICAgIC8vIGR1bW15IG1hc2sgd2l0aCBzaGFwZSBbMSwgMV0gb3IgW2JhdGNoX3NpemUsIDFdLiBJdCBoYXMgc2FtZSBlZmZlY3QgYXMgbm8gbWFzay5cbiAgbWFzazJkS2V5UGFkZGluZywgICAgICAvLyBbYmF0Y2hfc2l6ZSwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoXVxuICBtYXNrM2RBdHRlbnRpb24sICAgICAgIC8vIFtiYXRjaF9zaXplLCBzZXF1ZW5jZV9sZW5ndGgsIHRvdGFsX3NlcXVlbmNlX2xlbmd0aF1cbiAgbWFzazRkTWVnYXRyb24sICAgICAgICAvLyBNZWdhdHJvbiBjYXVzYWwgbWFzayB3aXRoIHNoYXBlIFtiYXRjaF9zaXplLCAxLCBtYXhfc2VxdWVuY2VfbGVuZ3RoLCBtYXhfc2VxdWVuY2VfbGVuZ3RoXVxuICBtYXNrVW5rbm93blxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF0dGVudGlvblBhcmFtZXRlcnMge1xuICBiYXRjaFNpemU6IG51bWJlcjtcbiAgc2VxdWVuY2VMZW5ndGg6IG51bWJlcjtcbiAgcGFzdFNlcXVlbmNlTGVuZ3RoOiBudW1iZXI7XG4gIGt2U2VxdWVuY2VMZW5ndGg6IG51bWJlcjtcbiAgdG90YWxTZXF1ZW5jZUxlbmd0aDogbnVtYmVyO1xuICBtYXhTZXF1ZW5jZUxlbmd0aDogbnVtYmVyO1xuICBpbnB1dEhpZGRlblNpemU6IG51bWJlcjtcbiAgaGlkZGVuU2l6ZTogbnVtYmVyO1xuICB2SGlkZGVuU2l6ZTogbnVtYmVyO1xuICBoZWFkU2l6ZTogbnVtYmVyO1xuICB2SGVhZFNpemU6IG51bWJlcjtcbiAgbnVtSGVhZHM6IG51bWJlcjtcbiAga3ZOdW1IZWFkcz86IG51bWJlcjtcbiAgblJlcHM/OiBudW1iZXI7XG4gIGlzVW5pZGlyZWN0aW9uYWw/OiBib29sZWFuO1xuICBwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiBib29sZWFuO1xuICBtYXNrRmlsdGVyVmFsdWU/OiBudW1iZXI7XG4gIG1hc2tUeXBlOiBBdHRlbnRpb25NYXNrVHlwZTtcbiAgc2NhbGU6IG51bWJlcjtcbiAgYnJvYWRjYXN0UmVzUG9zQmlhczogYm9vbGVhbjtcbiAgcGFzc1Bhc3RJbkt2OiBib29sZWFuO1xuICBxa3ZGb3JtYXQ6IEF0dGVudGlvblFrdkZvcm1hdDtcbiAgaXNQYXN0a3ZCU05IPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdHRlbnRpb25BdHRycyB7XG4gIG51bUhlYWRzOiBudW1iZXI7XG4gIGt2TnVtSGVhZHM/OiBudW1iZXI7XG4gIGlzVW5pZGlyZWN0aW9uYWw/OiBudW1iZXI7XG4gIG1hc2tGaWx0ZXJWYWx1ZT86IG51bWJlcjtcbiAgc2NhbGU6IG51bWJlcjtcbiAgZG9Sb3Rhcnk6IG51bWJlcjtcbiAgcWt2SGlkZGVuU2l6ZXM6IG51bWJlcltdO1xuICBwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiBib29sZWFuO1xufVxuXG5jb25zdCB2YWxpZGF0ZUF0dGVudGlvbklucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogQXR0ZW50aW9uQXR0cnMpOiBBdHRlbnRpb25QYXJhbWV0ZXJzID0+IHtcbiAgLy8gQWJicmV2aWF0aW9uIGFuZCBNZWFuaW5nczpcbiAgLy8gICBCOiAgICBiYXRjaF9zaXplXG4gIC8vICAgUzogICAgc2VxdWVuY2VfbGVuZ3RoIChpbnB1dCBzZXF1ZW5jZSBsZW5ndGggb2YgcXVlcnkpXG4gIC8vICAgUDogICAgcGFzdF9zZXF1ZW5jZV9sZW5ndGggKHBhc3Qgc2VxdWVuY2UgbGVuZ3RoIG9mIGtleSBvciB2YWx1ZSlcbiAgLy8gICBMOiAgICBrdl9zZXF1ZW5jZV9sZW5ndGggKGlucHV0IHNlcXVlbmNlIGxlbmd0aCBvZiBrZXkgb3IgdmFsdWUpXG4gIC8vICAgTTogICAgbWF4X3NlcXVlbmNlX2xlbmd0aFxuICAvLyAgIFQ6ICAgIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoICsga3Zfc2VxdWVuY2VfbGVuZ3RoXG4gIC8vICAgTjogICAgbnVtX2hlYWRzXG4gIC8vICAgSDogICAgaGVhZCBzaXplIGZvciBRIGFuZCBLLCBha2EgcV9oZWFkX3NpemUgb3Iga19oZWFkX3NpemUgb3IgcWtfaGVhZF9zaXplXG4gIC8vICAgSF92OiAgdl9oZWFkX3NpemVcbiAgLy8gICBEX2k6ICBpbnB1dCBoaWRkZW4gc2l6ZVxuICAvLyAgIEQ6ICAgIGhpZGRlbiBzaXplIGZvciBRIGFuZCBLIChEID0gTiAqIEgpLCBha2EgcV9oaWRkZW5fc2l6ZSBvciBrX2hpZGRlbl9zaXplIG9yIHFrX2hpZGRlbl9zaXplXG4gIC8vICAgRF92OiAgdl9oaWRkZW5fc2l6ZSA9IG51bV9oZWFkcyAqIHZfaGVhZF9zaXplXG5cbiAgLy8gV2hlbiBwYXN0IHN0YXRlIGlzIHVzZWQsIFEsIEsgYW5kIFYgc2hvdWxkIGhhdmUgc2FtZSBoaWRkZW4gc2l6ZSAodW5sZXNzIHdlIHNwbGl0IGl0IGludG8gcGFzdF9rZXkgYW5kIHBhc3RfdmFsdWUpLlxuXG4gIC8vIElucHV0IHNoYXBlczpcbiAgLy8gICBpbnB1dCAgICAgICAgKFEvSy9WKSAgICA6IChCLCBTLCBEX2kpXG4gIC8vICAgd2VpZ2h0cyAgICAgIChRL0svVikgICAgOiAoRF9pLCBEICsgRCArIERfdilcbiAgLy8gICBiaWFzICAgICAgICAgKFEvSy9WKSAgICA6IChEICsgRCArIERfdilcbiAgLy8gICBtYXNrX2luZGV4ICAgICAgICAgICAgICA6IHNlZSBiZWxvd1xuICAvLyAgIHBhc3QgICAgICAgICAoSy9WKSAgICAgIDogKDIsIEIsIE4sIFAsIEgpIG9yIE5VTExcbiAgLy8gICByZWxhdGl2ZV9wb3NpdGlvbl9iaWFzICAgICAgICAgICAgOiAoQiwgTiwgUywgVCkgb3IgTlVMTFxuXG4gIC8vIEZvciBtYXNrX2luZGV4LCB0aGUgZm9sbG93aW5nIHNoYXBlcyBhcmUgc3VwcG9ydGVkOlxuICAvLyAgICAgTlVMTCwgKEIsIDEpLCAoMSwgMSlcbiAgLy8gICAgIChCKSwgKDIgKiBCKSwgKDMgKiBCICsgMilcbiAgLy8gICAgIChCLCBUKVxuICAvLyAgICAgKEIsIFMsIFQpXG4gIC8vICAgICAoQiwgMSwgTSwgTSlcbiAgLy9cbiAgLy8gV2hlbiBhIG1vZGVsIGlzIHBydW5lZCAobGlrZSBzb21lIGF0dGVudGlvbiBoZWFkcyBhcmUgcmVtb3ZlZCBpbiBRL0svViksIGlucHV0X2hpZGRlbl9zaXplIGNvdWxkIGJlIGxhcmdlclxuICAvLyB0aGFuIGhpZGRlbiBkaW1lbnNpb24gb2YgUSwgSyBhbmQgVi5cblxuICBjb25zdCBpbnB1dCA9IGlucHV0c1swXTtcbiAgY29uc3Qgd2VpZ2h0cyA9IGlucHV0c1sxXTtcbiAgY29uc3QgYmlhcyA9IGlucHV0c1syXTtcbiAgY29uc3QgbWFza0luZGV4ID0gaW5wdXRzWzNdO1xuICBjb25zdCBwYXN0ID0gaW5wdXRzWzRdO1xuICBjb25zdCByZWxhdGl2ZVBvc2l0aW9uQmlhcyA9IGlucHV0c1s1XTtcblxuICBpZiAocGFzdCAmJiByZWxhdGl2ZVBvc2l0aW9uQmlhcykge1xuICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW50aW9uIGNhbm5vdCBoYXZlIGJvdGggcGFzdCBhbmQgcmVsYXRpdmVfcG9zaXRpb25fYmlhcycpO1xuICB9XG5cbiAgaWYgKGlucHV0LmRpbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImlucHV0XCIgbXVzdCBoYXZlIDMgZGltZW5zaW9ucycpO1xuICB9XG5cbiAgY29uc3QgYmF0Y2hTaXplID0gaW5wdXQuZGltc1swXTtcbiAgY29uc3Qgc2VxdWVuY2VMZW5ndGggPSBpbnB1dC5kaW1zWzFdO1xuICBjb25zdCBpbnB1dEhpZGRlblNpemUgPSBpbnB1dC5kaW1zWzJdO1xuXG4gIGlmIChiaWFzLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9ucycpO1xuICB9XG5cbiAgaWYgKHdlaWdodHMuZGltcy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwid2VpZ2h0c1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMiBkaW1lbnNpb25zJyk7XG4gIH1cblxuICBpZiAod2VpZ2h0cy5kaW1zWzBdICE9PSBpbnB1dEhpZGRlblNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IDEgZGltZW5zaW9uIDAgc2hvdWxkIGhhdmUgc2FtZSBsZW5ndGggYXMgZGltZW5zaW9uIDIgb2YgaW5wdXQgMCcpO1xuICB9XG5cbiAgaWYgKGJpYXMuZGltc1swXSAhPT0gd2VpZ2h0cy5kaW1zWzFdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBkaW1lbnNpb24gMCBzaG91bGQgaGF2ZSBzYW1lIGxlbmd0aCBhcyBkaW1lbnNpb24gMSBvZiBpbnB1dCBcIndlaWdodHNcIicpO1xuICB9XG5cbiAgbGV0IHFIaWRkZW5TaXplID0gYmlhcy5kaW1zWzBdIC8gMztcbiAgbGV0IGtIaWRkZW5TaXplID0gcUhpZGRlblNpemU7XG4gIGxldCB2SGlkZGVuU2l6ZSA9IGtIaWRkZW5TaXplO1xuICBpZiAoYXR0cmlidXRlcy5xa3ZIaWRkZW5TaXplcy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKGF0dHJpYnV0ZXMucWt2SGlkZGVuU2l6ZXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Frdl9oaWRkZW5fc2l6ZXMgYXR0cmlidXRlIHNob3VsZCBoYXZlIDMgZWxlbWVudHMnKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBzeiBvZiBhdHRyaWJ1dGVzLnFrdkhpZGRlblNpemVzKSB7XG4gICAgICBpZiAoc3ogJSBhdHRyaWJ1dGVzLm51bUhlYWRzICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncWt2X2hpZGRlbl9zaXplcyBzaG91bGQgYmUgZGl2aXNpYmxlIGJ5IG51bV9oZWFkcycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHFIaWRkZW5TaXplID0gYXR0cmlidXRlcy5xa3ZIaWRkZW5TaXplc1swXTtcbiAgICBrSGlkZGVuU2l6ZSA9IGF0dHJpYnV0ZXMucWt2SGlkZGVuU2l6ZXNbMV07XG4gICAgdkhpZGRlblNpemUgPSBhdHRyaWJ1dGVzLnFrdkhpZGRlblNpemVzWzJdO1xuICB9XG5cbiAgY29uc3Qga3ZTZXF1ZW5jZUxlbmd0aCA9IHNlcXVlbmNlTGVuZ3RoO1xuXG4gIGlmIChxSGlkZGVuU2l6ZSAhPT0ga0hpZGRlblNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Frdl9oaWRkZW5fc2l6ZXMgZmlyc3QgZWxlbWVudCBzaG91bGQgYmUgc2FtZSBhcyB0aGUgc2Vjb25kJyk7XG4gIH1cblxuICBpZiAoYmlhcy5kaW1zWzBdICE9PSBxSGlkZGVuU2l6ZSArIGtIaWRkZW5TaXplICsgdkhpZGRlblNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYmlhc1wiIGRpbWVuc2lvbiAwIHNob3VsZCBoYXZlIHNhbWUgbGVuZ3RoIGFzIHN1bSBvZiBRL0svViBoaWRkZW4gc2l6ZXMnKTtcbiAgfVxuXG4gIGxldCBwYXN0U2VxdWVuY2VMZW5ndGggPSAwO1xuICBpZiAocGFzdCkge1xuICAgIGlmIChrSGlkZGVuU2l6ZSAhPT0gdkhpZGRlblNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgZXhwZWN0IGtfaGlkZGVuX3NpemUgPT0gdl9oaWRkZW5fc2l6ZScpO1xuICAgIH1cbiAgICBpZiAocGFzdC5kaW1zLmxlbmd0aCAhPT0gNSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBtdXN0IGhhdmUgNSBkaW1lbnNpb25zJyk7XG4gICAgfVxuICAgIGlmIChwYXN0LmRpbXNbMF0gIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgZmlyc3QgZGltZW5zaW9uIG11c3QgYmUgMicpO1xuICAgIH1cbiAgICBpZiAocGFzdC5kaW1zWzFdICE9PSBiYXRjaFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgc2Vjb25kIGRpbWVuc2lvbiBtdXN0IGJlIGJhdGNoX3NpemUnKTtcbiAgICB9XG4gICAgaWYgKHBhc3QuZGltc1syXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiB0aGlyZCBkaW1lbnNpb24gbXVzdCBiZSBudW1faGVhZHMnKTtcbiAgICB9XG4gICAgaWYgKHBhc3QuZGltc1s0XSAhPT0ga0hpZGRlblNpemUgLyBhdHRyaWJ1dGVzLm51bUhlYWRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIGZpZnRoIGRpbWVuc2lvbiBtdXN0IGJlIGtfaGlkZGVuX3NpemUgLyBudW1faGVhZHMnKTtcbiAgICB9XG5cbiAgICBpZiAoIWF0dHJpYnV0ZXMucGFzdFByZXNlbnRTaGFyZUJ1ZmZlcikge1xuICAgICAgcGFzdFNlcXVlbmNlTGVuZ3RoID0gcGFzdC5kaW1zWzNdO1xuICAgIH1cbiAgICAvLyBUT0RPOiBoYW5kbGUgcGFzdF9zZXFfbGVuXG4gIH1cblxuICBjb25zdCB0b3RhbFNlcXVlbmNlTGVuZ3RoID0ga3ZTZXF1ZW5jZUxlbmd0aCArIHBhc3RTZXF1ZW5jZUxlbmd0aDtcbiAgY29uc3QgbWF4U2VxdWVuY2VMZW5ndGggPSAtMTtcblxuICBjb25zdCBtYXNrVHlwZSA9IEF0dGVudGlvbk1hc2tUeXBlLm5vbmU7XG4gIGlmIChtYXNrSW5kZXgpIHtcbiAgICAvLyBtYXNrVHlwZSA9IEF0dGVudGlvbk1hc2tUeXBlLk1BU0tfVU5LTk9XTjtcbiAgICAvLyBUT0RPOiBoYW5kbGUgbWFza1xuICAgIHRocm93IG5ldyBFcnJvcignTWFzayBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cblxuICBpZiAocGFzdCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncGFzdCBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJhdGNoU2l6ZSxcbiAgICBzZXF1ZW5jZUxlbmd0aCxcbiAgICBwYXN0U2VxdWVuY2VMZW5ndGgsXG4gICAga3ZTZXF1ZW5jZUxlbmd0aCxcbiAgICB0b3RhbFNlcXVlbmNlTGVuZ3RoLFxuICAgIG1heFNlcXVlbmNlTGVuZ3RoLFxuICAgIGlucHV0SGlkZGVuU2l6ZSxcbiAgICBoaWRkZW5TaXplOiBxSGlkZGVuU2l6ZSxcbiAgICB2SGlkZGVuU2l6ZSxcbiAgICBoZWFkU2l6ZTogTWF0aC5mbG9vcihxSGlkZGVuU2l6ZSAvIGF0dHJpYnV0ZXMubnVtSGVhZHMpLFxuICAgIHZIZWFkU2l6ZTogTWF0aC5mbG9vcih2SGlkZGVuU2l6ZSAvIGF0dHJpYnV0ZXMubnVtSGVhZHMpLFxuICAgIG51bUhlYWRzOiBhdHRyaWJ1dGVzLm51bUhlYWRzLFxuICAgIGlzVW5pZGlyZWN0aW9uYWw6IGZhbHNlLFxuICAgIHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6IGZhbHNlLFxuICAgIG1hc2tGaWx0ZXJWYWx1ZTogYXR0cmlidXRlcy5tYXNrRmlsdGVyVmFsdWUsXG4gICAgbWFza1R5cGUsXG4gICAgc2NhbGU6IGF0dHJpYnV0ZXMuc2NhbGUsXG4gICAgYnJvYWRjYXN0UmVzUG9zQmlhczogZmFsc2UsXG4gICAgcGFzc1Bhc3RJbkt2OiBmYWxzZSxcbiAgICBxa3ZGb3JtYXQ6IEF0dGVudGlvblFrdkZvcm1hdC5xa3ZCTlNILFxuICB9O1xufTtcblxuY29uc3QgY3JlYXRlSW5QbGFjZVNvZnRtYXhQcm9ncmFtSW5mbyA9IChfY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGlucHV0OiBUZW5zb3JWaWV3LCBuOiBudW1iZXIsIGQ6IG51bWJlcikgPT4ge1xuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhkKTtcbiAgbGV0IFdHID0gNjQ7XG4gIGNvbnN0IGRDb21wID0gZCAvIGNvbXBvbmVudHM7XG4gIGlmIChkQ29tcCA8IFdHKSB7XG4gICAgV0cgPSAxO1xuICB9IGVsc2UgaWYgKGRDb21wIC8gOCA8IDY0KSB7XG4gICAgV0cgPSBNYXRoLmNlaWwoZENvbXAgLyA4KTtcbiAgfVxuICBjb25zdCBlbGVtZW50c1BlclRocmVhZCA9IE1hdGguY2VpbChkIC8gY29tcG9uZW50cyAvIFdHKTtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHt0eXBlOiBpbnB1dC5kYXRhVHlwZSwgZGF0YTogMSAvIGR9LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBkQ29tcH0sXG4gICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZWxlbWVudHNQZXJUaHJlYWR9XG4gIF07XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0LmRhdGFUeXBlLCBjb21wb25lbnRzKTtcbiAgY29uc3QgZjMyVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoRGF0YVR5cGUuZmxvYXQsIGNvbXBvbmVudHMpO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IGlucHV0SGVscGVyID0gb3V0cHV0VmFyaWFibGUoJ3gnLCBpbnB1dC5kYXRhVHlwZSwgaW5wdXQuZGltcywgY29tcG9uZW50cyk7XG4gICAgY29uc3QgZWxlbVZhbHVlVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoaW5wdXQuZGF0YVR5cGUpO1xuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgIHtuYW1lOiAnZF9pbnYnLCB0eXBlOiBlbGVtVmFsdWVUeXBlIGFzIFVuaWZvcm1EYXRhRWxlbWVudFR5cGV9LCB7bmFtZTogJ2RfY29tcCcsIHR5cGU6ICd1MzInfSxcbiAgICAgIHtuYW1lOiAnZWxlbWVudHNfcGVyX3RocmVhZCcsIHR5cGU6ICd1MzInfVxuICAgIF07XG5cbiAgICByZXR1cm4gYFxuICB2YXI8d29ya2dyb3VwPiB0aHJlYWRfbWF4OiBhcnJheTxmMzIsICR7V0d9PjtcbiAgdmFyPHdvcmtncm91cD4gdGhyZWFkX3N1bTogYXJyYXk8ZjMyLCAke1dHfT47XG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXRIZWxwZXIpfVxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoW1xuICAgICAgV0csIDEsIDFcbiAgICBdKX1cbiAgICBsZXQgbG9jYWxfb2Zmc2V0ID0gbG9jYWxfaWR4ICogdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZDtcbiAgICBsZXQgb2Zmc2V0ID0gd29ya2dyb3VwX2lkLnggKiB1bmlmb3Jtcy5kX2NvbXAgKyBsb2NhbF9vZmZzZXQ7XG5cbiAgICB2YXIgdGhyZWFkX21heF92ZWN0b3IgPSAke2YzMlR5cGV9KC0zLjQwMjgyM2UrMzhmKTtcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZCAmJiBpICsgbG9jYWxfb2Zmc2V0IDwgdW5pZm9ybXMuZF9jb21wOyBpKyspIHtcbiAgICAgIHRocmVhZF9tYXhfdmVjdG9yID0gbWF4KCR7ZjMyVHlwZX0oeFtvZmZzZXQgKyBpXSksIHRocmVhZF9tYXhfdmVjdG9yKTtcbiAgICB9XG4gICAgdGhyZWFkX21heFtsb2NhbF9pZHhdID0gJHsoKCkgPT4ge1xuICAgICAgc3dpdGNoIChjb21wb25lbnRzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gJ3RocmVhZF9tYXhfdmVjdG9yJztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiAnbWF4KHRocmVhZF9tYXhfdmVjdG9yLngsIHRocmVhZF9tYXhfdmVjdG9yLnkpJztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiAnbWF4KG1heCh0aHJlYWRfbWF4X3ZlY3Rvci54LCB0aHJlYWRfbWF4X3ZlY3Rvci55KSwgbWF4KHRocmVhZF9tYXhfdmVjdG9yLnosIHRocmVhZF9tYXhfdmVjdG9yLncpKSc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb21wb25lbnRzOiAke2NvbXBvbmVudHN9YCk7XG4gICAgICB9XG4gICAgfSkoKX07XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgdmFyIG1heF92YWx1ZSA9ICBmMzIoLTMuNDAyODIzZSszOGYpO1xuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7V0d9OyBpKyspIHtcbiAgICAgIG1heF92YWx1ZSA9IG1heCh0aHJlYWRfbWF4W2ldLCBtYXhfdmFsdWUpO1xuICAgIH1cblxuICAgIHZhciBzdW1fdmVjdG9yID0gJHtmMzJUeXBlfSgwKTtcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZCAmJiBpICsgbG9jYWxfb2Zmc2V0IDwgdW5pZm9ybXMuZF9jb21wOyBpKyspIHtcbiAgICAgIHN1bV92ZWN0b3IgKz0gZXhwKCR7ZjMyVHlwZX0oeFtvZmZzZXQgKyBpXSkgLSBtYXhfdmFsdWUpO1xuICAgIH1cbiAgICB0aHJlYWRfc3VtW2xvY2FsX2lkeF0gPSAkeygoKSA9PiB7XG4gICAgICBzd2l0Y2ggKGNvbXBvbmVudHMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiAnc3VtX3ZlY3Rvcic7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gJ3N1bV92ZWN0b3IueCArIHN1bV92ZWN0b3IueSc7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gJ3N1bV92ZWN0b3IueCArIHN1bV92ZWN0b3IueSArIHN1bV92ZWN0b3IueiArIHN1bV92ZWN0b3Iudyc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb21wb25lbnRzOiAke2NvbXBvbmVudHN9YCk7XG4gICAgICB9XG4gICAgfSkoKX07XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgdmFyIHN1bTogZjMyID0gMDtcbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke1dHfTsgaSsrKSB7XG4gICAgICBzdW0gKz0gdGhyZWFkX3N1bVtpXTtcbiAgICB9XG5cbiAgICBpZiAoc3VtID09IDApIHtcbiAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCB1bmlmb3Jtcy5kX2NvbXA7IGkrKykge1xuICAgICAgICB4W29mZnNldCArIGldID0gJHtpbnB1dEhlbHBlci50eXBlLnZhbHVlfSh1bmlmb3Jtcy5kX2ludik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCB1bmlmb3Jtcy5kX2NvbXA7IGkrKykge1xuICAgICAgICB2YXIgZjMyaW5wdXQgPSAke2YzMlR5cGV9KHhbb2Zmc2V0ICsgaV0pO1xuICAgICAgICB4W29mZnNldCArIGldID0gJHtpbnB1dEhlbHBlci50eXBlLnZhbHVlfShleHAoZjMyaW5wdXQgLSBtYXhfdmFsdWUpIC8gc3VtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1gO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0F0dGVudGlvblByb2JzU29mdG1heCcsXG4gICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBgJHtXR307JHtkYXRhVHlwZX07JHtjb21wb25lbnRzfWB9LFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe291dHB1dHM6IFtdLCBkaXNwYXRjaEdyb3VwOiB7eDogbn0sIHByb2dyYW1Vbmlmb3Jtc30pLFxuICB9O1xufTtcblxuY29uc3QgY3JlYXRlQXR0ZW50aW9uUHJvYnNQcm9ncmFtSW5mbyA9XG4gICAgKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBxOiBUZW5zb3JWaWV3LCBrZXk6IFRlbnNvclZpZXcsIHBhc3RLZXk6IFRlbnNvclZpZXd8dW5kZWZpbmVkLFxuICAgICByZWxhdGl2ZVBvc2l0aW9uQmlhczogVGVuc29yVmlld3x1bmRlZmluZWQsIHBhcmFtZXRlcnM6IEF0dGVudGlvblBhcmFtZXRlcnMsIGF0dHJpYnV0ZXM6IEF0dGVudGlvbkF0dHJzLFxuICAgICBwYXN0U2VxdWVuY2VMZW5ndGg6IG51bWJlcikgPT4ge1xuICAgICAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aCA9IHBhc3RTZXF1ZW5jZUxlbmd0aCArIHBhcmFtZXRlcnMua3ZTZXF1ZW5jZUxlbmd0aDtcbiAgICAgIGNvbnN0IHByb2JzU2hhcGUgPSBbcGFyYW1ldGVycy5iYXRjaFNpemUsIHBhcmFtZXRlcnMubnVtSGVhZHMsIHBhcmFtZXRlcnMuc2VxdWVuY2VMZW5ndGgsIHRvdGFsU2VxdWVuY2VMZW5ndGhdO1xuICAgICAgY29uc3QgcHJlc2VudEtleSA9IHBhcmFtZXRlcnMua3ZOdW1IZWFkcyA9PT0gdW5kZWZpbmVkICYmIGNvbnRleHQub3V0cHV0Q291bnQgPiAxO1xuICAgICAgY29uc3QgcHJlc2VudEtleVNoYXBlID0gcHJlc2VudEtleSA/XG4gICAgICAgICAgW3BhcmFtZXRlcnMuYmF0Y2hTaXplLCBwYXJhbWV0ZXJzLm51bUhlYWRzLCB0b3RhbFNlcXVlbmNlTGVuZ3RoLCBwYXJhbWV0ZXJzLmhlYWRTaXplXSA6XG4gICAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgICAvLyBUT0RPOiBoYW5kbGUgbWFza1xuXG4gICAgICBjb25zdCBhbHBoYSA9IGF0dHJpYnV0ZXMuc2NhbGUgPT09IDAgPyAxLjAgLyBNYXRoLnNxcnQocGFyYW1ldGVycy5oZWFkU2l6ZSkgOiBhdHRyaWJ1dGVzLnNjYWxlO1xuICAgICAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMocGFyYW1ldGVycy5oZWFkU2l6ZSk7XG4gICAgICBjb25zdCB2ZWN0b3JpemVkSGVhZFNpemUgPSBwYXJhbWV0ZXJzLmhlYWRTaXplIC8gY29tcG9uZW50cztcbiAgICAgIGNvbnN0IFRJTEVfU0laRSA9IDEyO1xuICAgICAgY29uc3QgZGlzcGF0Y2ggPSB7XG4gICAgICAgIHg6IE1hdGguY2VpbCh0b3RhbFNlcXVlbmNlTGVuZ3RoIC8gVElMRV9TSVpFKSxcbiAgICAgICAgeTogTWF0aC5jZWlsKHBhcmFtZXRlcnMuc2VxdWVuY2VMZW5ndGggLyBUSUxFX1NJWkUpLFxuICAgICAgICB6OiBwYXJhbWV0ZXJzLmJhdGNoU2l6ZSAqIHBhcmFtZXRlcnMubnVtSGVhZHNcbiAgICAgIH07XG4gICAgICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtZXRlcnMuc2VxdWVuY2VMZW5ndGh9LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiB2ZWN0b3JpemVkSGVhZFNpemV9LFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiB0b3RhbFNlcXVlbmNlTGVuZ3RofSwge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1ldGVycy5udW1IZWFkc30sXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYWxwaGF9LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXN0U2VxdWVuY2VMZW5ndGh9LFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbWV0ZXJzLmt2U2VxdWVuY2VMZW5ndGh9XG4gICAgICBdO1xuXG4gICAgICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsndHlwZScsICd0eXBlJ107XG4gICAgICBpZiAocGFzdEtleSkge1xuICAgICAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCd0eXBlJyk7XG4gICAgICB9XG4gICAgICBpZiAocmVsYXRpdmVQb3NpdGlvbkJpYXMpIHtcbiAgICAgICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgndHlwZScpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3V0cHV0cyA9IFt7ZGltczogcHJvYnNTaGFwZSwgZGF0YVR5cGU6IHEuZGF0YVR5cGUsIGdwdURhdGFUeXBlOiBHcHVEYXRhVHlwZS5kZWZhdWx0fV07XG4gICAgICBpZiAocHJlc2VudEtleSkge1xuICAgICAgICBvdXRwdXRzLnB1c2goe2RpbXM6IHByZXNlbnRLZXlTaGFwZSEsIGRhdGFUeXBlOiBxLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHFJbnB1dCA9IGlucHV0VmFyaWFibGUoJ3EnLCBxLmRhdGFUeXBlLCBxLmRpbXMsIGNvbXBvbmVudHMpO1xuICAgICAgICBjb25zdCBrSW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdrZXknLCBrZXkuZGF0YVR5cGUsIGtleS5kaW1zLCBjb21wb25lbnRzKTtcbiAgICAgICAgY29uc3QgaW5wdXRWYXJzID0gW3FJbnB1dCwga0lucHV0XTtcbiAgICAgICAgaWYgKHBhc3RLZXkpIHtcbiAgICAgICAgICBjb25zdCBwYXN0S2V5SW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdwYXN0X2tleScsIHBhc3RLZXkuZGF0YVR5cGUsIHBhc3RLZXkuZGltcywgY29tcG9uZW50cyk7XG4gICAgICAgICAgaW5wdXRWYXJzLnB1c2gocGFzdEtleUlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVsYXRpdmVQb3NpdGlvbkJpYXMpIHtcbiAgICAgICAgICBpbnB1dFZhcnMucHVzaChcbiAgICAgICAgICAgICAgaW5wdXRWYXJpYWJsZSgncmVsYXRpdmVfcG9zaXRpb25fYmlhcycsIHJlbGF0aXZlUG9zaXRpb25CaWFzLmRhdGFUeXBlLCByZWxhdGl2ZVBvc2l0aW9uQmlhcy5kaW1zKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIHEuZGF0YVR5cGUsIHByb2JzU2hhcGUpO1xuICAgICAgICBjb25zdCBvdXRwdXRWYXJzID0gW291dHB1dF07XG4gICAgICAgIGlmIChwcmVzZW50S2V5KSB7XG4gICAgICAgICAgb3V0cHV0VmFycy5wdXNoKG91dHB1dFZhcmlhYmxlKCdwcmVzZW50X2tleScsIHEuZGF0YVR5cGUsIHByZXNlbnRLZXlTaGFwZSEsIGNvbXBvbmVudHMpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmMzJUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShEYXRhVHlwZS5mbG9hdCwgY29tcG9uZW50cyk7XG5cbiAgICAgICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgICAgIHtuYW1lOiAnTScsIHR5cGU6ICd1MzInfSwge25hbWU6ICdLJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ04nLCB0eXBlOiAndTMyJ30sXG4gICAgICAgICAge25hbWU6ICdudW1faGVhZHMnLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnYWxwaGEnLCB0eXBlOiAnZjMyJyBhcyBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlfSxcbiAgICAgICAgICB7bmFtZTogJ3Bhc3Rfc2VxdWVuY2VfbGVuZ3RoJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ2t2X3NlcXVlbmNlX2xlbmd0aCcsIHR5cGU6ICd1MzInfVxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke1RJTEVfU0laRX11O1xuXG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVROiBhcnJheTwke3FJbnB1dC50eXBlLnN0b3JhZ2V9LCAke1RJTEVfU0laRSAqIFRJTEVfU0laRX0+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlSzogYXJyYXk8JHtxSW5wdXQudHlwZS5zdG9yYWdlfSwgJHtUSUxFX1NJWkUgKiBUSUxFX1NJWkV9PjtcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcnMsIC4uLm91dHB1dFZhcnMpfVxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoW1xuICAgICAgICAgIFRJTEVfU0laRSwgVElMRV9TSVpFLCAxXG4gICAgICAgIF0pfVxuICAgIC8vIHggaG9sZHMgdGhlIE4gYW5kIHkgaG9sZHMgdGhlIE1cbiAgICBsZXQgaGVhZElkeCA9IHdvcmtncm91cF9pZC56O1xuICAgIGxldCBtID0gd29ya2dyb3VwX2lkLnkgKiBUSUxFX1NJWkU7XG4gICAgbGV0IG4gPSB3b3JrZ3JvdXBfaWQueCAqIFRJTEVfU0laRTtcbiAgICBsZXQgcU9mZnNldCA9IHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5LICogaGVhZElkeCArIG0gKiB1bmlmb3Jtcy5LO1xuICAgICR7KCgpID0+IHtcbiAgICAgICAgICBpZiAocGFzdEtleSAmJiBwcmVzZW50S2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gYFxuICAgIGxldCBrT2Zmc2V0ID0gdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoICogdW5pZm9ybXMuSyAqIGhlYWRJZHg7XG4gICAgbGV0IHBhc3RLZXlPZmZzZXQgPSB1bmlmb3Jtcy5wYXN0X3NlcXVlbmNlX2xlbmd0aCAqIHVuaWZvcm1zLksgKiBoZWFkSWR4O2A7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgXG4gICAgbGV0IGtPZmZzZXQgPSB1bmlmb3Jtcy5OICogdW5pZm9ybXMuSyAqIGhlYWRJZHggKyBuICogdW5pZm9ybXMuSztgO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKX1cbiAgICAke3ByZXNlbnRLZXkgPyAnbGV0IHByZXNlbnRLZXlPZmZzZXQgPSBoZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLks7JyA6ICcnfVxuICAgIHZhciB2YWx1ZSA9ICR7ZjMyVHlwZX0oMCk7XG4gICAgZm9yICh2YXIgdzogdTMyID0gMHU7IHcgPCB1bmlmb3Jtcy5LOyB3ICs9IFRJTEVfU0laRSkge1xuICAgICAgaWYgKGdsb2JhbF9pZC55IDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gcVtxT2Zmc2V0ICsgbG9jYWxfaWQueSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICB9XG4gICAgICBpZiAobiArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB2YXIgaWR4ID0gVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLng7XG4gICAgICAkeygoKSA9PiB7XG4gICAgICAgICAgaWYgKHBhc3RLZXkgJiYgcHJlc2VudEtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgaWYgKG4gKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aWxlS1tpZHhdID0gcGFzdF9rZXlbcGFzdEtleU9mZnNldCArIChuICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5LICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpbGVLW2lkeF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgIGtleVtrT2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55IC0gdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGgpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgICAgICAgICAgfWA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAndGlsZUtbaWR4XSA9IGtleVtrT2Zmc2V0ICsgbG9jYWxfaWQueSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07JztcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCl9XG4gICAgICAke1xuICAgICAgICAgICAgcHJlc2VudEtleSA/XG4gICAgICAgICAgICAgICAgJ3ByZXNlbnRfa2V5W3ByZXNlbnRLZXlPZmZzZXQgKyAobiArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XSA9IHRpbGVLW2lkeF07JyA6XG4gICAgICAgICAgICAgICAgJyd9XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgVElMRV9TSVpFICYmIHcrayA8IHVuaWZvcm1zLks7IGsrKykge1xuICAgICAgICB2YWx1ZSArPSAke2YzMlR5cGV9KHRpbGVRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBrXSAqIHRpbGVLW1RJTEVfU0laRSAqIGxvY2FsX2lkLnggKyBrXSk7XG4gICAgICB9XG5cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG5cbiAgICBsZXQgaGVhZE9mZnNldCA9IGhlYWRJZHggKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuTjtcbiAgICBpZiAoZ2xvYmFsX2lkLnkgPCB1bmlmb3Jtcy5NICYmIGdsb2JhbF9pZC54IDwgdW5pZm9ybXMuTikge1xuICAgICAgbGV0IG91dHB1dElkeCA9IGhlYWRPZmZzZXQgKyBnbG9iYWxfaWQueSAqIHVuaWZvcm1zLk4gKyBnbG9iYWxfaWQueDtcbiAgICAgIHZhciBzdW06IGYzMiA9ICR7KCgpID0+IHtcbiAgICAgICAgICBzd2l0Y2ggKGNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgcmV0dXJuICd2YWx1ZSc7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHJldHVybiAndmFsdWUueCArIHZhbHVlLnknO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICByZXR1cm4gJ3ZhbHVlLnggKyB2YWx1ZS55ICsgdmFsdWUueiArIHZhbHVlLncnO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb21wb25lbnRzOiAke2NvbXBvbmVudHN9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpfTtcbiAgICAgICAgb3V0cHV0W291dHB1dElkeF0gPSAke291dHB1dC50eXBlLnZhbHVlfSAoc3VtICogdW5pZm9ybXMuYWxwaGEpICsgJHtcbiAgICAgICAgICAgIHJlbGF0aXZlUG9zaXRpb25CaWFzID8gJ3JlbGF0aXZlX3Bvc2l0aW9uX2JpYXNbb3V0cHV0SWR4XScgOiAnMC4wJ307XG4gICAgfVxuICB9YDtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnQXR0ZW50aW9uUHJvYnMnLFxuICAgICAgICBzaGFkZXJDYWNoZToge1xuICAgICAgICAgIGhpbnQ6IGAke2NvbXBvbmVudHN9OyR7cmVsYXRpdmVQb3NpdGlvbkJpYXMgIT09IHVuZGVmaW5lZH07JHtwYXN0S2V5ICE9PSB1bmRlZmluZWR9OyR7Y29udGV4dC5vdXRwdXRDb3VudH1gLFxuICAgICAgICAgIGlucHV0RGVwZW5kZW5jaWVzXG4gICAgICAgIH0sXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7b3V0cHV0cywgZGlzcGF0Y2hHcm91cDogZGlzcGF0Y2gsIHByb2dyYW1Vbmlmb3Jtc30pLFxuICAgICAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgICB9O1xuICAgIH07XG5cblxuY29uc3QgY3JlYXRlVnhBdHRlbnRpb25TY29yZVByb2dyYW1JbmZvID1cbiAgICAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIHByb2JzOiBUZW5zb3JWaWV3LCB2OiBUZW5zb3JWaWV3LCBwYXN0VmFsdWU6IFRlbnNvclZpZXd8dW5kZWZpbmVkLFxuICAgICBwYXJhbXM6IEF0dGVudGlvblBhcmFtZXRlcnMsIHBhc3RTZXF1ZW5jZUxlbmd0aDogbnVtYmVyKSA9PiB7XG4gICAgICBjb25zdCB0b3RhbFNlcXVlbmNlTGVuZ3RoID0gcGFzdFNlcXVlbmNlTGVuZ3RoICsgcGFyYW1zLmt2U2VxdWVuY2VMZW5ndGg7XG4gICAgICBjb25zdCBuUmVwcyA9IHBhcmFtcy5uUmVwcyA/IHBhcmFtcy5uUmVwcyA6IDE7XG4gICAgICBjb25zdCByZXBlYXRlZFZIaWRkZW5TaXplID0gcGFyYW1zLnZIaWRkZW5TaXplICogblJlcHM7XG4gICAgICBjb25zdCBwcmVzZW50VmFsdWUgPSBwYXJhbXMua3ZOdW1IZWFkcyA9PSBudWxsICYmIGNvbnRleHQub3V0cHV0Q291bnQgPiAxO1xuICAgICAgY29uc3QgcHJlc2VudFZhbHVlU2hhcGUgPVxuICAgICAgICAgIHByZXNlbnRWYWx1ZSA/IFtwYXJhbXMuYmF0Y2hTaXplLCBwYXJhbXMubnVtSGVhZHMsIHRvdGFsU2VxdWVuY2VMZW5ndGgsIHBhcmFtcy5oZWFkU2l6ZV0gOiB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IFtwYXJhbXMuYmF0Y2hTaXplLCBwYXJhbXMuc2VxdWVuY2VMZW5ndGgsIHJlcGVhdGVkVkhpZGRlblNpemVdO1xuICAgICAgY29uc3QgVElMRV9TSVpFID0gMTI7XG4gICAgICBjb25zdCBkaXNwYXRjaCA9IHtcbiAgICAgICAgeDogTWF0aC5jZWlsKHBhcmFtcy52SGVhZFNpemUgLyBUSUxFX1NJWkUpLFxuICAgICAgICB5OiBNYXRoLmNlaWwocGFyYW1zLnNlcXVlbmNlTGVuZ3RoIC8gVElMRV9TSVpFKSxcbiAgICAgICAgejogcGFyYW1zLmJhdGNoU2l6ZSAqIHBhcmFtcy5udW1IZWFkc1xuICAgICAgfTtcblxuICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbXMuc2VxdWVuY2VMZW5ndGh9LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiB0b3RhbFNlcXVlbmNlTGVuZ3RofSxcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1zLnZIZWFkU2l6ZX0sIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtcy5udW1IZWFkc30sXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHJlcGVhdGVkVkhpZGRlblNpemV9LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXN0U2VxdWVuY2VMZW5ndGh9LFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbXMua3ZTZXF1ZW5jZUxlbmd0aH1cbiAgICAgIF07XG4gICAgICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9XG4gICAgICAgICAgcGFzdFZhbHVlID8gWyd0eXBlJywgJ3R5cGUnLCAndHlwZSddIDogWyd0eXBlJywgJ3R5cGUnXTtcbiAgICAgIGNvbnN0IG91dHB1dHMgPSBbe2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogcHJvYnMuZGF0YVR5cGUsIGdwdURhdGFUeXBlOiBHcHVEYXRhVHlwZS5kZWZhdWx0fV07XG4gICAgICBpZiAocHJlc2VudFZhbHVlKSB7XG4gICAgICAgIG91dHB1dHMucHVzaCh7ZGltczogcHJlc2VudFZhbHVlU2hhcGUhLCBkYXRhVHlwZTogcHJvYnMuZGF0YVR5cGUsIGdwdURhdGFUeXBlOiBHcHVEYXRhVHlwZS5kZWZhdWx0fSk7XG4gICAgICB9XG4gICAgICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICAgICAgY29uc3QgcHJvYnNIZWxwZXIgPSBpbnB1dFZhcmlhYmxlKCdwcm9icycsIHByb2JzLmRhdGFUeXBlLCBwcm9icy5kaW1zKTtcbiAgICAgICAgY29uc3QgdkhlbHBlciA9IGlucHV0VmFyaWFibGUoJ3YnLCB2LmRhdGFUeXBlLCB2LmRpbXMpO1xuICAgICAgICBjb25zdCBpbnB1dFZhcnMgPSBbcHJvYnNIZWxwZXIsIHZIZWxwZXJdO1xuICAgICAgICBpZiAocGFzdFZhbHVlKSB7XG4gICAgICAgICAgaW5wdXRWYXJzLnB1c2goaW5wdXRWYXJpYWJsZSgncGFzdF92YWx1ZScsIHBhc3RWYWx1ZS5kYXRhVHlwZSwgcGFzdFZhbHVlLmRpbXMpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgcHJvYnMuZGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0VmFycyA9IFtvdXRwdXRdO1xuICAgICAgICBpZiAocHJlc2VudFZhbHVlKSB7XG4gICAgICAgICAgb3V0cHV0VmFycy5wdXNoKG91dHB1dFZhcmlhYmxlKCdwcmVzZW50X3ZhbHVlJywgcHJvYnMuZGF0YVR5cGUsIHByZXNlbnRWYWx1ZVNoYXBlISkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgICAgICB7bmFtZTogJ00nLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnSycsIHR5cGU6ICd1MzInfSwge25hbWU6ICdOJywgdHlwZTogJ3UzMid9LFxuICAgICAgICAgIHtuYW1lOiAnbnVtX2hlYWRzJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ3ZfaGlkZGVuX3NpemUnLCB0eXBlOiAndTMyJ30sXG4gICAgICAgICAge25hbWU6ICdwYXN0X3NlcXVlbmNlX2xlbmd0aCcsIHR5cGU6ICd1MzInfSwge25hbWU6ICdrdl9zZXF1ZW5jZV9sZW5ndGgnLCB0eXBlOiAndTMyJ31cbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGBcbiAgY29uc3QgVElMRV9TSVpFID0gJHtUSUxFX1NJWkV9dTtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVE6IGFycmF5PCR7cHJvYnNIZWxwZXIudHlwZS52YWx1ZX0sICR7VElMRV9TSVpFICogVElMRV9TSVpFfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVLOiBhcnJheTwke3Byb2JzSGVscGVyLnR5cGUudmFsdWV9LCAke1RJTEVfU0laRSAqIFRJTEVfU0laRX0+O1xuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFycywgLi4ub3V0cHV0VmFycyl9XG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydChbXG4gICAgICAgICAgVElMRV9TSVpFLCBUSUxFX1NJWkUsIDFcbiAgICAgICAgXSl9XG4gICBsZXQgaGVhZElkeCA9IHdvcmtncm91cF9pZC56O1xuICAgbGV0IG0gPSBnbG9iYWxfaWQueTtcbiAgIGxldCBuID0gZ2xvYmFsX2lkLng7XG5cbiAgIGxldCBvZmZzZXRBID0gaGVhZElkeCAqICh1bmlmb3Jtcy5NICogdW5pZm9ybXMuSykgKyBtICogdW5pZm9ybXMuSztcbiAgICR7KCgpID0+IHtcbiAgICAgICAgICBpZiAocGFzdFZhbHVlICYmIHByZXNlbnRWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICBsZXQgcGFzdFZhbHVlT2Zmc2V0ID0gaGVhZElkeCAqIHVuaWZvcm1zLk4gKiB1bmlmb3Jtcy5wYXN0X3NlcXVlbmNlX2xlbmd0aCArIG47XG4gICAgbGV0IHZPZmZzZXQgPSBoZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCArIG47XG4gICAgICBgO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYFxuICAgbGV0IG9mZnNldEIgPSBoZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLksgKyBuO1xuICAgICAgICAgICAgYDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCl9XG4gICAgJHtwcmVzZW50VmFsdWUgPyAnbGV0IHByZXNlbnRWYWx1ZU9mZnNldCA9IGhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMuSyArIG47JyA6ICcnfVxuICAgdmFyIHZhbHVlID0gJHtwcm9ic0hlbHBlci50eXBlLnN0b3JhZ2V9KDApO1xuICAgZm9yICh2YXIgdzogdTMyID0gMHU7IHcgPCB1bmlmb3Jtcy5LOyB3ICs9IFRJTEVfU0laRSkge1xuICAgICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSBwcm9ic1tvZmZzZXRBICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgfVxuICAgICAgaWYgKG4gPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB2YXIgaWR4ID0gVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLng7XG4gICAgICAgICR7KCgpID0+IHtcbiAgICAgICAgICBpZiAocGFzdFZhbHVlICYmIHByZXNlbnRWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgaWYgKHcgKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICB0aWxlS1tpZHhdID0gcGFzdF92YWx1ZVtwYXN0VmFsdWVPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuTl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGlsZUtbaWR4XSA9IHZbdk9mZnNldCArICh3ICsgbG9jYWxfaWQueSAtIHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSAqIHVuaWZvcm1zLk5dO1xuICAgICAgICB9XG4gICAgICBgO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICB0aWxlS1tpZHhdID0gdltvZmZzZXRCICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLk5dO1xuICAgICAgYDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCl9XG4gICAgICAgICR7cHJlc2VudFZhbHVlID8gJ3ByZXNlbnRfdmFsdWVbcHJlc2VudFZhbHVlT2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLk5dID0gdGlsZUtbaWR4XTsnIDogJyd9XG4gICAgICB9XG4gICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCBUSUxFX1NJWkUgJiYgdytrIDwgdW5pZm9ybXMuSzsgaysrKSB7XG4gICAgICAgdmFsdWUgKz0gdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGtdICogdGlsZUtbVElMRV9TSVpFICogayArIGxvY2FsX2lkLnhdO1xuICAgICB9XG4gICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgIH1cblxuICAgLy8gd2UgbmVlZCB0byB0cmFuc3Bvc2Ugb3V0cHV0IGZyb20gQk5TSF92IHRvIEJTTkRfdlxuICAgbGV0IGJhdGNoSWR4ID0gd29ya2dyb3VwX2lkLnogLyB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICBsZXQgY3VycmVudEJhdGNoSGVhZE51bWJlciA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIG4gPCB1bmlmb3Jtcy5OKSB7XG4gICAgIGxldCBvdXRwdXRJZHggPSBiYXRjaElkeCAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy52X2hpZGRlbl9zaXplICsgbSAqIHVuaWZvcm1zLnZfaGlkZGVuX3NpemVcbiAgICAgICArIGN1cnJlbnRCYXRjaEhlYWROdW1iZXIgKiB1bmlmb3Jtcy5OICsgbjtcbiAgICAgb3V0cHV0W291dHB1dElkeF0gPSB2YWx1ZTtcbiAgIH1cbiAgfWA7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnQXR0ZW50aW9uU2NvcmUnLFxuICAgICAgICBzaGFkZXJDYWNoZToge2hpbnQ6IGAke3Bhc3RWYWx1ZSAhPT0gdW5kZWZpbmVkfTske2NvbnRleHQub3V0cHV0Q291bnR9YCwgaW5wdXREZXBlbmRlbmNpZXN9LFxuICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe291dHB1dHMsIGRpc3BhdGNoR3JvdXA6IGRpc3BhdGNoLCBwcm9ncmFtVW5pZm9ybXN9KSxcbiAgICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgICAgfTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgYXBwbHlBdHRlbnRpb24gPVxuICAgIChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgcTogVGVuc29yVmlldywgazogVGVuc29yVmlldywgdjogVGVuc29yVmlldywgX21hc2tJbmRleDogVGVuc29yVmlld3x1bmRlZmluZWQsXG4gICAgIF9wYXN0OiBUZW5zb3JWaWV3fHVuZGVmaW5lZCwgcGFzdEtleTogVGVuc29yVmlld3x1bmRlZmluZWQsIHBhc3RWYWx1ZTogVGVuc29yVmlld3x1bmRlZmluZWQsXG4gICAgIHJlbGF0aXZlUG9zaXRpb25CaWFzOiBUZW5zb3JWaWV3fHVuZGVmaW5lZCwgcGFyYW1ldGVyczogQXR0ZW50aW9uUGFyYW1ldGVycywgYXR0cmlidXRlczogQXR0ZW50aW9uQXR0cnMpID0+IHtcbiAgICAgIGNvbnN0IG91dHB1dENvdW50ID0gY29udGV4dC5vdXRwdXRDb3VudDtcbiAgICAgIGNvbnN0IHBhc3RTZXF1ZW5jZUxlbmd0aCA9XG4gICAgICAgICAgcGFyYW1ldGVycy5rdk51bUhlYWRzICE9PSB1bmRlZmluZWQgfHwgb3V0cHV0Q291bnQgPiAxID8gcGFyYW1ldGVycy5wYXN0U2VxdWVuY2VMZW5ndGggOiAwO1xuICAgICAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aCA9IHBhc3RTZXF1ZW5jZUxlbmd0aCArIHBhcmFtZXRlcnMua3ZTZXF1ZW5jZUxlbmd0aDtcblxuICAgICAgY29uc3QgaW5wdXRzSyA9IChwYXJhbWV0ZXJzLmt2TnVtSGVhZHMgPT09IHVuZGVmaW5lZCAmJiBvdXRwdXRDb3VudCA+IDEgJiYgcGFzdEtleSkgPyBbcSwgaywgcGFzdEtleV0gOiBbcSwga107XG4gICAgICBpZiAocmVsYXRpdmVQb3NpdGlvbkJpYXMpIHtcbiAgICAgICAgaW5wdXRzSy5wdXNoKHJlbGF0aXZlUG9zaXRpb25CaWFzKTtcbiAgICAgIH1cblxuICAgICAgLy8gUnVuIEF0dGVudGlvblByb2JzXG4gICAgICBjb25zdCBwcm9icyA9IGNvbnRleHQuY29tcHV0ZShcbiAgICAgICAgICBjcmVhdGVBdHRlbnRpb25Qcm9ic1Byb2dyYW1JbmZvKFxuICAgICAgICAgICAgICBjb250ZXh0LCBxLCBrLCBvdXRwdXRDb3VudCA+IDEgPyBwYXN0S2V5IDogdW5kZWZpbmVkLCByZWxhdGl2ZVBvc2l0aW9uQmlhcywgcGFyYW1ldGVycywgYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgcGFzdFNlcXVlbmNlTGVuZ3RoKSxcbiAgICAgICAgICB7aW5wdXRzOiBpbnB1dHNLLCBvdXRwdXRzOiAocGFyYW1ldGVycy5rdk51bUhlYWRzID09PSB1bmRlZmluZWQgJiYgb3V0cHV0Q291bnQgPiAxKSA/IFstMSwgMV0gOiBbLTFdfSlbMF07XG5cbiAgICAgIC8vIFJ1biBTb2Z0bWF4XG4gICAgICBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgICAgY3JlYXRlSW5QbGFjZVNvZnRtYXhQcm9ncmFtSW5mbyhcbiAgICAgICAgICAgICAgY29udGV4dCwgcHJvYnMsIHBhcmFtZXRlcnMuYmF0Y2hTaXplICogcGFyYW1ldGVycy5udW1IZWFkcyAqIHBhcmFtZXRlcnMuc2VxdWVuY2VMZW5ndGgsXG4gICAgICAgICAgICAgIHRvdGFsU2VxdWVuY2VMZW5ndGgpLFxuICAgICAgICAgIHtpbnB1dHM6IFtwcm9ic10sIG91dHB1dHM6IFtdfSk7XG5cbiAgICAgIC8vIFJ1biBBdHRyaW9uU2NvcmVcbiAgICAgIGNvbnN0IGlucHV0c1YgPVxuICAgICAgICAgIChwYXJhbWV0ZXJzLmt2TnVtSGVhZHMgPT09IHVuZGVmaW5lZCAmJiBvdXRwdXRDb3VudCA+IDEgJiYgcGFzdFZhbHVlKSA/IFtwcm9icywgdiwgcGFzdFZhbHVlXSA6IFtwcm9icywgdl07XG4gICAgICBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgICAgY3JlYXRlVnhBdHRlbnRpb25TY29yZVByb2dyYW1JbmZvKFxuICAgICAgICAgICAgICBjb250ZXh0LCBwcm9icywgdiwgb3V0cHV0Q291bnQgPiAxICYmIHBhc3RWYWx1ZSA/IHBhc3RWYWx1ZSA6IHVuZGVmaW5lZCwgcGFyYW1ldGVycywgcGFzdFNlcXVlbmNlTGVuZ3RoKSxcbiAgICAgICAgICB7aW5wdXRzOiBpbnB1dHNWLCBvdXRwdXRzOiAocGFyYW1ldGVycy5rdk51bUhlYWRzID09PSB1bmRlZmluZWQgJiYgb3V0cHV0Q291bnQgPiAxKSA/IFswLCAyXSA6IFswXX0pO1xuICAgIH07XG5cbmNvbnN0IHByZXBhcmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIHBhcmFtZXRlcnM6IEF0dGVudGlvblBhcmFtZXRlcnMpID0+IHtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbXG4gICAgcGFyYW1ldGVycy5iYXRjaFNpemUsXG4gICAgcGFyYW1ldGVycy5udW1IZWFkcyxcbiAgICBwYXJhbWV0ZXJzLnNlcXVlbmNlTGVuZ3RoLFxuICAgIHBhcmFtZXRlcnMuaGVhZFNpemUsXG4gIF07XG4gIGNvbnN0IE0gPSBwYXJhbWV0ZXJzLnNlcXVlbmNlTGVuZ3RoO1xuICBjb25zdCBLID0gcGFyYW1ldGVycy5pbnB1dEhpZGRlblNpemU7XG4gIGNvbnN0IE4gPSBwYXJhbWV0ZXJzLmhlYWRTaXplO1xuICBjb25zdCBUSUxFX1NJWkUgPSAxMjtcbiAgY29uc3QgZGlzcGF0Y2ggPSB7XG4gICAgeDogTWF0aC5jZWlsKHBhcmFtZXRlcnMuaGVhZFNpemUgLyBUSUxFX1NJWkUpLFxuICAgIHk6IE1hdGguY2VpbChwYXJhbWV0ZXJzLnNlcXVlbmNlTGVuZ3RoIC8gVElMRV9TSVpFKSxcbiAgICB6OiBwYXJhbWV0ZXJzLmJhdGNoU2l6ZSAqIHBhcmFtZXRlcnMubnVtSGVhZHNcbiAgfTtcbiAgY29uc3QgaW5wdXRzID0gW2NvbnRleHQuaW5wdXRzWzBdLCBjb250ZXh0LmlucHV0c1sxXSwgY29udGV4dC5pbnB1dHNbMl1dO1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTX0sIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IEt9LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBOfSxcbiAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbWV0ZXJzLm51bUhlYWRzfSwge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1ldGVycy5oZWFkU2l6ZX0sXG4gICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1ldGVycy5oaWRkZW5TaXplfSxcbiAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbWV0ZXJzLmhpZGRlblNpemUgKyBwYXJhbWV0ZXJzLmhpZGRlblNpemUgKyBwYXJhbWV0ZXJzLnZIaWRkZW5TaXplfVxuICBdO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IG91dHB1dFEgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0X3EnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcbiAgICBjb25zdCBvdXRwdXRLID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dF9rJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XG4gICAgY29uc3Qgb3V0cHV0ViA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXRfdicsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUpO1xuICAgIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zKTtcbiAgICBjb25zdCB3ZWlnaHQgPSBpbnB1dFZhcmlhYmxlKCd3ZWlnaHQnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zKTtcbiAgICBjb25zdCBiaWFzID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMpO1xuICAgIGNvbnN0IGRhdGFUeXBlID0gaW5wdXQudHlwZS5zdG9yYWdlO1xuXG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAge25hbWU6ICdNJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ0snLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnTicsIHR5cGU6ICd1MzInfSwge25hbWU6ICdudW1faGVhZHMnLCB0eXBlOiAndTMyJ30sXG4gICAgICB7bmFtZTogJ2hlYWRfc2l6ZScsIHR5cGU6ICd1MzInfSwge25hbWU6ICdoaWRkZW5fc2l6ZScsIHR5cGU6ICd1MzInfSwge25hbWU6ICdsZGInLCB0eXBlOiAndTMyJ31cbiAgICBdO1xuICAgIHJldHVybiBgXG4gIGNvbnN0IFRJTEVfU0laRSA9ICR7VElMRV9TSVpFfXU7XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVJbnB1dDogYXJyYXk8JHtkYXRhVHlwZX0sICR7VElMRV9TSVpFICogVElMRV9TSVpFfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVXZWlnaHRROiBhcnJheTwke2RhdGFUeXBlfSwgJHtUSUxFX1NJWkUgKiBUSUxFX1NJWkV9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVdlaWdodEs6IGFycmF5PCR7ZGF0YVR5cGV9LCAke1RJTEVfU0laRSAqIFRJTEVfU0laRX0+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlV2VpZ2h0VjogYXJyYXk8JHtkYXRhVHlwZX0sICR7VElMRV9TSVpFICogVElMRV9TSVpFfT47XG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIHdlaWdodCwgYmlhcywgb3V0cHV0USwgb3V0cHV0Sywgb3V0cHV0Vil9XG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydChbXG4gICAgICBUSUxFX1NJWkUsIFRJTEVfU0laRSwgMVxuICAgIF0pfVxuICAgIGxldCBiYXRjaEluZGV4ID0gd29ya2dyb3VwX2lkLnogLyB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IGhlYWROdW1iZXIgPSB3b3JrZ3JvdXBfaWQueiAlIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgICBsZXQgbSA9IGdsb2JhbF9pZC55O1xuICAgIGxldCBuID0gZ2xvYmFsX2lkLng7XG5cbiAgICBsZXQgaW5wdXRPZmZzZXQgPSBiYXRjaEluZGV4ICogKHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5LKSArIG0gKiB1bmlmb3Jtcy5LO1xuICAgIGxldCBiaWFzT2Zmc2V0USA9IGhlYWROdW1iZXIgKiB1bmlmb3Jtcy5oZWFkX3NpemU7XG4gICAgbGV0IGJpYXNPZmZzZXRLID0gdW5pZm9ybXMuaGlkZGVuX3NpemUgKyBiaWFzT2Zmc2V0UTtcbiAgICBsZXQgYmlhc09mZnNldFYgPSB1bmlmb3Jtcy5oaWRkZW5fc2l6ZSArIGJpYXNPZmZzZXRLO1xuXG4gICAgdmFyIHZhbHVlUSA9ICR7ZGF0YVR5cGV9KDApO1xuICAgIHZhciB2YWx1ZUsgPSAke2RhdGFUeXBlfSgwKTtcbiAgICB2YXIgdmFsdWVWID0gJHtkYXRhVHlwZX0oMCk7XG4gICAgZm9yICh2YXIgdzogdTMyID0gMHU7IHcgPCB1bmlmb3Jtcy5LOyB3ICs9IFRJTEVfU0laRSkge1xuICAgICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlSW5wdXRbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gaW5wdXRbaW5wdXRPZmZzZXQgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICB9XG4gICAgICBpZiAobiA8IHVuaWZvcm1zLk4gJiYgdyArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSBuICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLmxkYjtcbiAgICAgICAgdGlsZVdlaWdodFFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gd2VpZ2h0W2JpYXNPZmZzZXRRICsgb2Zmc2V0XTtcbiAgICAgICAgdGlsZVdlaWdodEtbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gd2VpZ2h0W2JpYXNPZmZzZXRLICsgb2Zmc2V0XTtcbiAgICAgICAgdGlsZVdlaWdodFZbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gd2VpZ2h0W2JpYXNPZmZzZXRWICsgb2Zmc2V0XTtcbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrPFRJTEVfU0laRSAmJiB3K2sgPCB1bmlmb3Jtcy5LOyBrKyspIHtcbiAgICAgICAgbGV0IGlucHV0VGlsZU9mZnNldCA9IFRJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBrO1xuICAgICAgICBsZXQgd2VpZ2h0VGlsZU9mZnNldCA9IFRJTEVfU0laRSAqIGsgKyBsb2NhbF9pZC54O1xuICAgICAgICB2YWx1ZVEgKz0gdGlsZUlucHV0W2lucHV0VGlsZU9mZnNldF0gKiB0aWxlV2VpZ2h0UVt3ZWlnaHRUaWxlT2Zmc2V0XTtcbiAgICAgICAgdmFsdWVLICs9IHRpbGVJbnB1dFtpbnB1dFRpbGVPZmZzZXRdICogdGlsZVdlaWdodEtbd2VpZ2h0VGlsZU9mZnNldF07XG4gICAgICAgIHZhbHVlViArPSB0aWxlSW5wdXRbaW5wdXRUaWxlT2Zmc2V0XSAqIHRpbGVXZWlnaHRWW3dlaWdodFRpbGVPZmZzZXRdO1xuICAgICAgfVxuXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuXG4gICAgbGV0IGhlYWRPZmZzZXQgPSAobSAqIHVuaWZvcm1zLk4gKyBuKSAlIHVuaWZvcm1zLmhlYWRfc2l6ZTtcbiAgICB2YWx1ZVEgKz0gYmlhc1toZWFkT2Zmc2V0ICsgYmlhc09mZnNldFFdO1xuICAgIHZhbHVlSyArPSBiaWFzW2hlYWRPZmZzZXQgKyBiaWFzT2Zmc2V0S107XG4gICAgdmFsdWVWICs9IGJpYXNbaGVhZE9mZnNldCArIGJpYXNPZmZzZXRWXTtcblxuICAgIGxldCBvZmZzZXQgPSB3b3JrZ3JvdXBfaWQueiAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5OO1xuICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiBuIDwgdW5pZm9ybXMuTikge1xuICAgICAgbGV0IG91dHB1dElkeCA9IG9mZnNldCArIG0gKiB1bmlmb3Jtcy5OICsgbjtcbiAgICAgIG91dHB1dF9xW291dHB1dElkeF0gPSB2YWx1ZVE7XG4gICAgICBvdXRwdXRfa1tvdXRwdXRJZHhdID0gdmFsdWVLO1xuICAgICAgb3V0cHV0X3Zbb3V0cHV0SWR4XSA9IHZhbHVlVjtcbiAgICB9XG4gIH1gO1xuICB9O1xuXG4gIHJldHVybiBjb250ZXh0LmNvbXB1dGUoXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdBdHRlbnRpb25QcmVwYXJlJyxcbiAgICAgICAgc2hhZGVyQ2FjaGU6IHtpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJywgJ3R5cGUnLCAndHlwZSddfSxcbiAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgICB7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSwgZ3B1RGF0YVR5cGU6IEdwdURhdGFUeXBlLmRlZmF1bHR9LFxuICAgICAgICAgICAge2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsIGdwdURhdGFUeXBlOiBHcHVEYXRhVHlwZS5kZWZhdWx0fSxcbiAgICAgICAgICAgIHtkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgICBkaXNwYXRjaEdyb3VwOiBkaXNwYXRjaCxcbiAgICAgICAgICBwcm9ncmFtVW5pZm9ybXNcbiAgICAgICAgfSksXG4gICAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICAgIH0sXG4gICAgICB7aW5wdXRzLCBvdXRwdXRzOiBbLTEsIC0xLCAtMV19KTtcbn07XG5cbmV4cG9ydCBjb25zdCBhdHRlbnRpb24gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEF0dGVudGlvbkF0dHJzKTogdm9pZCA9PiB7XG4gIGNvbnN0IHBhcmFtcyA9IHZhbGlkYXRlQXR0ZW50aW9uSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcblxuICBjb25zdCBbcSwgaywgdl0gPSBwcmVwYXJlKGNvbnRleHQsIHBhcmFtcyk7XG5cbiAgcmV0dXJuIGFwcGx5QXR0ZW50aW9uKFxuICAgICAgY29udGV4dCwgcSwgaywgdiwgY29udGV4dC5pbnB1dHNbNF0sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQuaW5wdXRzWzVdLCBwYXJhbXMsIGF0dHJpYnV0ZXMpO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtlbnZ9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGdldE1heENvbXBvbmVudHMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXJ9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBCYXRjaE5vcm1BdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgZXBzaWxvbjogbnVtYmVyO1xuICByZWFkb25seSBtb21lbnR1bTogbnVtYmVyO1xuICByZWFkb25seSBzcGF0aWFsOiBib29sZWFuO1xuICByZWFkb25seSB0cmFpbmluZ01vZGU6IGJvb2xlYW47XG4gIHJlYWRvbmx5IGZvcm1hdDogJ05IV0MnfCdOQ0hXJztcbiAgcmVhZG9ubHkgb3V0cHV0Q291bnQ6IG51bWJlcjtcbn1cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IEJhdGNoTm9ybUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmF0Y2hOb3JtYWxpemF0aW9uIHJlcXVpcmVzIDUgaW5wdXRzJyk7XG4gIH1cblxuICBjb25zdCBjaGVja1NoYXBlRXF1YWwgPSAoYWN0dWFsOiByZWFkb25seSBudW1iZXJbXSwgZXhwZWN0ZWQ6IHJlYWRvbmx5IG51bWJlcltdLCBtZXNzYWdlOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCByID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgIGlmIChyICE9PSBhY3R1YWwubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bWVzc2FnZX06IG51bSBkaW1lbnNpb25zICE9ICR7cn1gKTtcbiAgICB9XG4gICAgZXhwZWN0ZWQuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgaWYgKHYgIT09IGFjdHVhbFtpXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bWVzc2FnZX06IGRpbVske2l9XSBkbyBub3QgbWF0Y2hgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IHNoYXBlID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJyA/XG4gICAgICAgIChhdHRyaWJ1dGVzLnNwYXRpYWwgPyBpbnB1dHNbMF0uZGltcy5zbGljZSgtMSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRzWzBdLmRpbXMuc2xpY2UoLTEpLmNvbmNhdChpbnB1dHNbMF0uZGltcy5zbGljZSgxLCBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAxKSkpIDpcbiAgICAgICAgaW5wdXRzWzBdLmRpbXMuc2xpY2UoMSwgYXR0cmlidXRlcy5zcGF0aWFsID8gMiA6IHVuZGVmaW5lZCk7XG4gICAgY2hlY2tTaGFwZUVxdWFsKGlucHV0c1sxXS5kaW1zLCBzaGFwZSwgJ0ludmFsaWQgaW5wdXQgc2NhbGUnKTtcbiAgICBjaGVja1NoYXBlRXF1YWwoaW5wdXRzWzJdLmRpbXMsIHNoYXBlLCAnSW52YWxpZCBpbnB1dCBCJyk7XG4gICAgY2hlY2tTaGFwZUVxdWFsKGlucHV0c1szXS5kaW1zLCBzaGFwZSwgJ0ludmFsaWQgaW5wdXQgbWVhbicpO1xuICAgIGNoZWNrU2hhcGVFcXVhbChpbnB1dHNbNF0uZGltcywgc2hhcGUsICdJbnZhbGlkIGlucHV0IHZhcicpO1xuICB9IGVsc2Uge1xuICAgIGNoZWNrU2hhcGVFcXVhbChpbnB1dHNbMV0uZGltcywgWzFdLCAnSW52YWxpZCBpbnB1dCBzY2FsZScpO1xuICAgIGNoZWNrU2hhcGVFcXVhbChpbnB1dHNbMl0uZGltcywgWzFdLCAnSW52YWxpZCBpbnB1dCBCJyk7XG4gICAgY2hlY2tTaGFwZUVxdWFsKGlucHV0c1szXS5kaW1zLCBbMV0sICdJbnZhbGlkIGlucHV0IG1lYW4nKTtcbiAgICBjaGVja1NoYXBlRXF1YWwoaW5wdXRzWzRdLmRpbXMsIFsxXSwgJ0ludmFsaWQgaW5wdXQgdmFyJyk7XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZUJhdGNoTm9ybUluZmVyZW5jZVByb2dyYW1JbmZvID1cbiAgICAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IEJhdGNoTm9ybUF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCB7ZXBzaWxvbiwgc3BhdGlhbCwgZm9ybWF0fSA9IGF0dHJpYnV0ZXM7XG4gICAgICBjb25zdCB5U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBzcGF0aWFsID8gZ2V0TWF4Q29tcG9uZW50cyh5U2hhcGVbeVNoYXBlLmxlbmd0aCAtIDFdKSA6IDE7XG4gICAgICBjb25zdCBjQ29tcG9uZW50cyA9IGZvcm1hdCA9PT0gJ05IV0MnICYmIHlTaGFwZS5sZW5ndGggPiAxID8gY29tcG9uZW50cyA6IDE7XG4gICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUoeVNoYXBlKSAvIGNvbXBvbmVudHM7XG4gICAgICAvLyBPbmx5IHN1cHBvcnQgdW5pZm9ybXMgZm9yIG9wc2V0IHZlcnNpb24gPj0gOSAoc3BhdGlhbCA9IHRydWUpLlxuICAgICAgY29uc3QgdXNlU2hhcGVzVW5pZm9ybXMgPSBzcGF0aWFsO1xuICAgICAgY29uc3Qgc2hhcGVPclJhbmsgPSB1c2VTaGFwZXNVbmlmb3JtcyA/IHlTaGFwZS5sZW5ndGggOiB5U2hhcGU7XG4gICAgICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMsIGNvbXBvbmVudHMpO1xuICAgICAgY29uc3Qgc2NhbGUgPSBpbnB1dFZhcmlhYmxlKCdzY2FsZScsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMsIGNDb21wb25lbnRzKTtcbiAgICAgIGNvbnN0IGJpYXMgPSBpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcywgY0NvbXBvbmVudHMpO1xuICAgICAgY29uc3QgaW5wdXRNZWFuID0gaW5wdXRWYXJpYWJsZSgnaW5wdXRNZWFuJywgaW5wdXRzWzNdLmRhdGFUeXBlLCBpbnB1dHNbM10uZGltcywgY0NvbXBvbmVudHMpO1xuICAgICAgY29uc3QgaW5wdXRWYXIgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dFZhcicsIGlucHV0c1s0XS5kYXRhVHlwZSwgaW5wdXRzWzRdLmRpbXMsIGNDb21wb25lbnRzKTtcbiAgICAgIGNvbnN0IHkgPSBvdXRwdXRWYXJpYWJsZSgneScsIGlucHV0c1swXS5kYXRhVHlwZSwgc2hhcGVPclJhbmssIGNvbXBvbmVudHMpO1xuICAgICAgLy8gVE9ETzogc3VwcG9ydCBpbnB1dHMgd2l0aCBkaWZmZXJlbnQgZGF0YSB0eXBlLiBDdXJyZW50IHdlIG5lZWQgdG8gbWFrZSBzdXJlIGFsbCBpbnB1dHMgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGUuXG4gICAgICAvLyBPdGhlcndpc2UsIHRoZSBzaGFkZXIgY29tcGlsYXRpb24gd2lsbCBmYWlsLlxuICAgICAgY29uc3QgY2FsY0NPZmZzZXQgPSAoKTogc3RyaW5nID0+IHtcbiAgICAgICAgbGV0IGNPZmZzZXQgPSAnJztcbiAgICAgICAgaWYgKHNwYXRpYWwpIHtcbiAgICAgICAgICBjT2Zmc2V0ID0gYGxldCBjT2Zmc2V0ID0gJHtcbiAgICAgICAgICAgICAgeVNoYXBlLmxlbmd0aCA9PT0gMSAgID8gJzB1JyA6XG4gICAgICAgICAgICAgICAgICBmb3JtYXQgPT09ICdOSFdDJyA/IGBvdXRwdXRJbmRpY2VzWyR7eVNoYXBlLmxlbmd0aCAtIDF9XSAvICR7Y29tcG9uZW50c31gIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ291dHB1dEluZGljZXNbMV0nfTtgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdOQ0hXJykge1xuICAgICAgICAgICAgY09mZnNldCA9IGBcbiAgICAgICAgICAgICR7eS5pbmRpY2VzU2V0KCdvdXRwdXRJbmRpY2VzJywgJzAnLCAnMCcpfVxuICAgICAgICAgICAgbGV0IGNPZmZzZXQgPSAke3kuaW5kaWNlc1RvT2Zmc2V0KCdvdXRwdXRJbmRpY2VzJyl9O2A7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBDIGNoYW5uZWwuXG4gICAgICAgICAgICBjT2Zmc2V0ID0gYHZhciBjSW5kaWNlcyA9ICR7c2NhbGUudHlwZS5pbmRpY2VzfSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgY0luZGljZXNbMF0gPSBvdXRwdXRJbmRpY2VzWyR7eVNoYXBlLmxlbmd0aCAtIDF9XTtgO1xuICAgICAgICAgICAgLy8gdXBkYXRlIEQxIHggLi4uIHggRG4gY2hhbm5lbHMuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNjYWxlLnJhbms7IGkrKykge1xuICAgICAgICAgICAgICBjT2Zmc2V0ICs9IGBjSW5kaWNlc1ske2l9XSA9IG91dHB1dEluZGljZXNbJHtpfV07YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNPZmZzZXQgKz0gYGxldCBjT2Zmc2V0ID0gJHtzY2FsZS5pbmRpY2VzVG9PZmZzZXQoJ2NJbmRpY2VzJyl9O2A7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjT2Zmc2V0O1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldEluZmVyZW5jZU1vZGVTaGFkZXJTb3VyY2UgPSAoaGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgY29uc3QgZXBzaWxvbiA9ICR7ZXBzaWxvbn07XG4gICR7aGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0U2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKHgsIHNjYWxlLCBiaWFzLCBpbnB1dE1lYW4sIGlucHV0VmFyLCB5KX1cbiAgJHtoZWxwZXIubWFpblN0YXJ0KCl9XG4gICR7aGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cbiAgICB2YXIgb3V0cHV0SW5kaWNlcyA9ICR7eS5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiAke2NvbXBvbmVudHN9YCl9O1xuICAgICR7Y2FsY0NPZmZzZXQoKX1cbiAgICBsZXQgc2NhbGUgPSAke3NjYWxlLmdldEJ5T2Zmc2V0KCdjT2Zmc2V0Jyl9O1xuICAgIGxldCBiaWFzID0gJHtiaWFzLmdldEJ5T2Zmc2V0KCdjT2Zmc2V0Jyl9O1xuICAgIGxldCBpbnB1dE1lYW4gPSAke2lucHV0TWVhbi5nZXRCeU9mZnNldCgnY09mZnNldCcpfTtcbiAgICBsZXQgaW5wdXRWYXIgPSAke2lucHV0VmFyLmdldEJ5T2Zmc2V0KCdjT2Zmc2V0Jyl9O1xuICAgIGxldCB4ID0gJHt4LmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4Jyl9O1xuICAgIGxldCB2YWx1ZSA9ICh4IC0gaW5wdXRNZWFuKSAqIGludmVyc2VTcXJ0KGlucHV0VmFyICsgZXBzaWxvbikgKiBzY2FsZSArIGJpYXM7XG4gICAgJHt5LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlJyl9XG4gIH1gO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ0JhdGNoTm9ybWFsaXphdGlvbicsXG4gICAgICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICAgICAgaGludDogYCR7YXR0cmlidXRlcy5lcHNpbG9ufV8ke2F0dHJpYnV0ZXMuZm9ybWF0fV8ke3NwYXRpYWx9XyR7Y29tcG9uZW50c31gLFxuICAgICAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiB1c2VTaGFwZXNVbmlmb3JtcyA/IFsncmFuaycsICd0eXBlJywgJ3R5cGUnLCAndHlwZScsICd0eXBlJ10gOiB1bmRlZmluZWQsXG4gICAgICAgIH0sXG4gICAgICAgIGdldFNoYWRlclNvdXJjZTogZ2V0SW5mZXJlbmNlTW9kZVNoYWRlclNvdXJjZSxcbiAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgICBvdXRwdXRzOiBbe2RpbXM6IGlucHV0c1swXS5kaW1zLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlfV0sXG4gICAgICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfSxcbiAgICAgICAgICBwcm9ncmFtVW5pZm9ybXM6IHVzZVNoYXBlc1VuaWZvcm1zID9cbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemV9LFxuICAgICAgICAgICAgICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKHlTaGFwZSksXG4gICAgICAgICAgICAgIF0gOlxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZX0sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgIH0pLFxuICAgICAgfTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgcGFyc2VCYXRjaE5vcm1BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQmF0Y2hOb3JtQXR0cmlidXRlcyA9PlxuICAgIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShhdHRyaWJ1dGVzIGFzIE9taXQ8QmF0Y2hOb3JtQXR0cmlidXRlcywga2V5b2YgQXR0cmlidXRlV2l0aENhY2hlS2V5Pik7XG5cbmV4cG9ydCBjb25zdCBiYXRjaE5vcm0gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdm9pZCA9PiB7XG4gIGNvbnN0IHtpbnB1dHMsIG91dHB1dENvdW50fSA9IGNvbnRleHQ7XG4gIGNvbnN0IHVwZGF0ZWRBdHRyaWJ1dGVzID0gcGFyc2VCYXRjaE5vcm1BdHRyaWJ1dGVzKHsuLi5hdHRyaWJ1dGVzLCBvdXRwdXRDb3VudH0pO1xuICBpZiAoZW52LndlYmdwdS52YWxpZGF0ZUlucHV0Q29udGVudCkge1xuICAgIHZhbGlkYXRlSW5wdXRzKGlucHV0cywgdXBkYXRlZEF0dHJpYnV0ZXMpO1xuICB9XG4gIGlmIChhdHRyaWJ1dGVzLnRyYWluaW5nTW9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmF0Y2hOb3JtYWxpemF0aW9uIHRyYWluaW5nTW9kZSBpcyBub3Qgc3VwcG9ydGVkIHlldC4nKTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQmF0Y2hOb3JtSW5mZXJlbmNlUHJvZ3JhbUluZm8oaW5wdXRzLCB1cGRhdGVkQXR0cmlidXRlcykpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7aW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlcn0gZnJvbSAnLi9jb21tb24nO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBzaG91bGQgaGF2ZSAzIGRpbWVuc2lvbnMnKTtcbiAgfVxuXG4gIGlmICghWzMyMCwgNjQwLCAxMjgwXS5pbmNsdWRlcyhpbnB1dHNbMF0uZGltc1syXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBvZiBjaGFubmVscyBzaG91bGQgYmUgMzIwLCA2NDAgb3IgMTI4MCcpO1xuICB9XG5cbiAgaWYgKGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignYmlhcyBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9ucycpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zWzJdICE9PSBpbnB1dHNbMV0uZGltc1swXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbGFzdCBkaW1lbnNpb24gb2YgaW5wdXQgYW5kIGJpYXMgYXJlIG5vdCB0aGUgc2FtZScpO1xuICB9XG59O1xuXG5jb25zdCBjcmVhdGVCaWFzQWRkUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG5cbiAgY29uc3QgY2hhbm5lbHMgPSBpbnB1dHNbMF0uZGltc1syXTtcbiAgLy8gc2luY2UgY2hhbm5lbCBudW1iZXIgY2FuIGJlIG9ubHkgMzIwLzY0MC8xMjgwLCBpdCdzIGFsd2F5cyBkaXZpc2FibGUgYnkgNFxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gNDtcblxuICBjb25zdCBkYXRhVHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgNCk7XG4gIGNvbnN0IGJpYXMgPSBpbnB1dFZhcmlhYmxlKCdiaWFzJywgZGF0YVR5cGUsIFtjaGFubmVsc10sIDQpO1xuICBjb25zdCByZXNpZHVhbCA9IGlucHV0VmFyaWFibGUoJ3Jlc2lkdWFsJywgZGF0YVR5cGUsIG91dHB1dFNoYXBlLCA0KTtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgNCk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gIGNvbnN0IGNoYW5uZWxzID0gJHtjaGFubmVsc311IC8gNDtcbiAgJHtzaGFkZXJIZWxwZXIuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgYmlhcywgcmVzaWR1YWwsIG91dHB1dCl9XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhvdXRwdXRTaXplKX1cbiAgICBsZXQgdmFsdWUgPSAke2lucHV0LmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4Jyl9XG4gICAgICArICR7Ymlhcy5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCAlIGNoYW5uZWxzJyl9ICsgJHtyZXNpZHVhbC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfTtcbiAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpfVxuICB9YDtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdCaWFzQWRkJyxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfVxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBiaWFzQWRkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUJpYXNBZGRQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cykpO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge01BWF9DTElQLCBNSU5fQ0xJUCwgU2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mb30gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2lucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGV9IGZyb20gJy4vY29tbW9uJztcblxudHlwZSBCdWlsdGluRnVuY3Rpb25OYW1lID0gc3RyaW5nO1xudHlwZSBFbGVtZW50d2lzZUN1c3RvbUV4cHJlc3Npb24gPSAoZXhwcmVzc2lvbjogc3RyaW5nKSA9PiBzdHJpbmc7XG50eXBlIEVsZW1lbnR3aXNlRnVuY3Rpb25DYWxsID0gQnVpbHRpbkZ1bmN0aW9uTmFtZXxFbGVtZW50d2lzZUN1c3RvbUV4cHJlc3Npb247XG5cbmNvbnN0IGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbVNoYWRlciA9XG4gICAgKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyLCBkYXRhc2l6ZTogbnVtYmVyLCBpbnB1dERhdGFUeXBlOiBudW1iZXIsIG91dHB1dERhdGFUeXBlOiBudW1iZXIsXG4gICAgIGZ1bmNDYWxsOiBFbGVtZW50d2lzZUZ1bmN0aW9uQ2FsbCwgYWRkaXRpb25hbEltcGxlbWVudGF0aW9uPzogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICAgIGNvbnN0IHZlY1NpemUgPSBNYXRoLmNlaWwoZGF0YXNpemUgLyA0KTtcblxuICAgICAgbGV0IGV4cHJlc3Npb24gPSAnJztcbiAgICAgIGlmICh0eXBlb2YgZnVuY0NhbGwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGV4cHJlc3Npb24gPSBgJHtmdW5jQ2FsbH0oYSlgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGZ1bmNDYWxsKCdhJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXREYXRhJywgaW5wdXREYXRhVHlwZSwgW3ZlY1NpemVdLCA0KTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXREYXRhJywgb3V0cHV0RGF0YVR5cGUsIFt2ZWNTaXplXSwgNCk7XG5cbiAgICAgIHJldHVybiBgXG4gICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ3ZlY19zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG5cbiAgJHthZGRpdGlvbmFsSW1wbGVtZW50YXRpb24gPz8gJyd9XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMudmVjX3NpemUnKX1cblxuICAgIGxldCBhID0gJHtpbnB1dC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfTtcbiAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsIGV4cHJlc3Npb24pfVxuICB9YDtcbiAgICB9O1xuXG5jb25zdCBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvID1cbiAgICAoaW5wdXQ6IFRlbnNvclZpZXcsIG5hbWU6IHN0cmluZywgZnVuY0NhbGw6IEVsZW1lbnR3aXNlRnVuY3Rpb25DYWxsLCBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb24/OiBzdHJpbmcsXG4gICAgIGNhY2hlS2V5Pzogc3RyaW5nLCBvdXRwdXREYXRhVHlwZTogbnVtYmVyID0gaW5wdXQuZGF0YVR5cGUpOiBQcm9ncmFtSW5mbyA9PiAoe1xuICAgICAgbmFtZSxcbiAgICAgIHNoYWRlckNhY2hlOiB7aGludDogY2FjaGVLZXksIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3R5cGUnXX0sXG4gICAgICBnZXRTaGFkZXJTb3VyY2U6IHNoYWRlckhlbHBlciA9PiBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1TaGFkZXIoXG4gICAgICAgICAgc2hhZGVySGVscGVyLCBTaGFwZVV0aWwuc2l6ZShpbnB1dC5kaW1zKSwgaW5wdXQuZGF0YVR5cGUsIG91dHB1dERhdGFUeXBlLCBmdW5jQ2FsbCwgYWRkaXRpb25hbEltcGxlbWVudGF0aW9uKSxcbiAgICAgIGdldFJ1bkRhdGE6IChpbnB1dFRlbnNvcnMpID0+ICh7XG4gICAgICAgIG91dHB1dHM6IFt7ZGltczogaW5wdXQuZGltcywgZGF0YVR5cGU6IG91dHB1dERhdGFUeXBlfV0sXG4gICAgICAgIGRpc3BhdGNoR3JvdXA6XG4gICAgICAgICAgICB7eDogTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKGlucHV0VGVuc29yc1swXS5kaW1zKSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovIC8gNCAvKiB2ZWMgc2l6ZSAqLyl9LFxuICAgICAgICBwcm9ncmFtVW5pZm9ybXM6IFtcbiAgICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUoaW5wdXQuZGltcykgLyA0KX0sXG4gICAgICAgIF0sXG4gICAgICB9KVxuICAgIH0pO1xuXG5leHBvcnQgY29uc3QgYWJzID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQWJzJywgJ2FicycpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBhY29zID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQWNvcycsICdhY29zJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGFjb3NoID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQWNvc2gnLCAnYWNvc2gnKSk7XG59O1xuXG5leHBvcnQgY29uc3QgYXNpbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0FzaW4nLCAnYXNpbicpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBhc2luaCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0FzaW5oJywgJ2FzaW5oJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGF0YW4gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdBdGFuJywgJ2F0YW4nKSk7XG59O1xuZXhwb3J0IGNvbnN0IGF0YW5oID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQXRhbmgnLCAnYXRhbmgnKSk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIENhc3RBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgdG86IG51bWJlcjtcbiAgcmVhZG9ubHkgc2F0dXJhdGU/OiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgcGFyc2VDYXN0QXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IENhc3RBdHRyaWJ1dGVzID0+XG4gICAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KGF0dHJpYnV0ZXMgYXMge3RvOiBudW1iZXJ9KTtcblxuXG5leHBvcnQgY29uc3QgY2FzdCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQ2FzdEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgbGV0IGZ1bmM6IEVsZW1lbnR3aXNlRnVuY3Rpb25DYWxsO1xuICBzd2l0Y2ggKGF0dHJpYnV0ZXMudG8pIHtcbiAgICBjYXNlIERhdGFUeXBlLmZsb2F0MTY6XG4gICAgICBmdW5jID0gJ3ZlYzQ8ZjE2Pic7XG4gICAgICBicmVhaztcbiAgICBjYXNlIERhdGFUeXBlLmZsb2F0OlxuICAgICAgZnVuYyA9ICd2ZWM0PGYzMj4nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBEYXRhVHlwZS51aW50MzI6XG4gICAgICBmdW5jID0gJ3ZlYzQ8dTMyPic7XG4gICAgICBicmVhaztcbiAgICBjYXNlIERhdGFUeXBlLmludDMyOlxuICAgICAgZnVuYyA9ICd2ZWM0PGkzMj4nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBEYXRhVHlwZS5ib29sOlxuICAgICAgZnVuYyA9ICd2ZWM0PGJvb2w+JztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgbm90IHN1cHBvcnRlZCB0eXBlIChzcGVjaWZpZWQgaW4gYXR0cmlidXRlICd0bycgZnJvbSAnQ2FzdCcgb3BlcmF0b3IpOiAke2F0dHJpYnV0ZXMudG99YCk7XG4gIH1cbiAgY29udGV4dC5jb21wdXRlKFxuICAgICAgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0Nhc3QnLCBmdW5jLCB1bmRlZmluZWQsIGF0dHJpYnV0ZXMuY2FjaGVLZXksIGF0dHJpYnV0ZXMudG8pKTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2xpcEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBtaW46IG51bWJlcjtcbiAgcmVhZG9ubHkgbWF4OiBudW1iZXI7XG59XG5cbmNvbnN0IGdlbmVyYXRlQ2xpcEF0dHJpYnV0ZXNGcm9tSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogQ2xpcEF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBtaW4gPSAoaW5wdXRzLmxlbmd0aCA+PSAyICYmIGlucHV0c1sxXS5kYXRhICE9PSAwKSA/IGlucHV0c1sxXS5nZXRGbG9hdDMyQXJyYXkoKVswXSA6IE1JTl9DTElQO1xuICBjb25zdCBtYXggPSAoaW5wdXRzLmxlbmd0aCA+PSAzICYmIGlucHV0c1syXS5kYXRhICE9PSAwKSA/IGlucHV0c1syXS5nZXRGbG9hdDMyQXJyYXkoKVswXSA6IE1BWF9DTElQO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHttaW4sIG1heH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGNsaXAgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGNsaXBBdHRyaWJ1dGVzOiBDbGlwQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gY29udGV4dC5pbnB1dHMubGVuZ3RoID09PSAxID8gY2xpcEF0dHJpYnV0ZXMgOiBnZW5lcmF0ZUNsaXBBdHRyaWJ1dGVzRnJvbUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXG4gICAgICAgICAgY29udGV4dC5pbnB1dHNbMF0sICdDbGlwJywgYSA9PiBgY2xhbXAoJHthfSwgY2xpcF9taW5fLCBjbGlwX21heF8pYCwgYFxuICAgIGNvbnN0IGNsaXBfbWluXzogdmVjNDwke2RhdGFUeXBlfT4gPSB2ZWM0KCR7ZGF0YVR5cGV9KCR7YXR0cmlidXRlcy5taW59KSk7XG4gICAgY29uc3QgY2xpcF9tYXhfOiB2ZWM0PCR7ZGF0YVR5cGV9PiA9IHZlYzQoJHtkYXRhVHlwZX0oJHthdHRyaWJ1dGVzLm1heH0pKTtcbmAsXG4gICAgICAgICAgYXR0cmlidXRlcy5jYWNoZUtleSksXG4gICAgICB7aW5wdXRzOiBbMF19KTtcbn07XG5cbmV4cG9ydCBjb25zdCBjZWlsID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQ2VpbCcsICdjZWlsJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvcyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0NvcycsICdjb3MnKSk7XG59O1xuXG5leHBvcnQgY29uc3QgY29zaCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0Nvc2gnLCAnY29zaCcpKTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWxwaGFBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgYWxwaGE6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IHBhcnNlQWxwaGFBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQWxwaGFBdHRyaWJ1dGVzID0+XG4gICAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KGF0dHJpYnV0ZXMgYXMge2FscGhhOiBudW1iZXJ9KTtcblxuZXhwb3J0IGNvbnN0IGVsdSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQWxwaGFBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0sICdFbHUnLCBhID0+IGBlbHVfdmYzMigke2F9KWAsIGBcbiAgY29uc3QgZWx1X2FscGhhXyA9ICR7ZGF0YVR5cGV9KCR7YXR0cmlidXRlcy5hbHBoYX0pO1xuXG4gIGZuIGVsdV9mMzIoYTogJHtkYXRhVHlwZX0pIC0+ICR7ZGF0YVR5cGV9IHtcbiAgcmV0dXJuIHNlbGVjdCgoZXhwKGEpIC0gMS4wKSAqIGVsdV9hbHBoYV8sIGEsIGEgPj0gMC4wKTtcbiAgfVxuXG4gIGZuIGVsdV92ZjMyKHY6IHZlYzQ8JHtkYXRhVHlwZX0+KSAtPiB2ZWM0PCR7ZGF0YVR5cGV9PiB7XG4gIHJldHVybiB2ZWM0KGVsdV9mMzIodi54KSwgZWx1X2YzMih2LnkpLCBlbHVfZjMyKHYueiksIGVsdV9mMzIodi53KSk7XG4gIH1gLFxuICAgICAgYXR0cmlidXRlcy5jYWNoZUtleSkpO1xufTtcblxuZXhwb3J0IGNvbnN0IGVyZkltcGwgPSAodmFyVHlwZSA9ICdmMzInKSA9PiBgXG5jb25zdCByMDogJHt2YXJUeXBlfSA9IDAuMzI3NTkxMTtcbmNvbnN0IHIxOiAke3ZhclR5cGV9ID0gMC4yNTQ4Mjk1OTI7XG5jb25zdCByMjogJHt2YXJUeXBlfSA9IC0wLjI4NDQ5NjczNjtcbmNvbnN0IHIzOiAke3ZhclR5cGV9ID0gMS40MjE0MTM3NDE7XG5jb25zdCByNDogJHt2YXJUeXBlfSA9IC0xLjQ1MzE1MjAyNztcbmNvbnN0IHI1OiAke3ZhclR5cGV9ID0gMS4wNjE0MDU0Mjk7XG5cbmZuIGVyZl92ZjMyKHY6IHZlYzQ8JHt2YXJUeXBlfT4pIC0+IHZlYzQ8JHt2YXJUeXBlfT4ge1xuICBsZXQgYWJzdiA9IGFicyh2KTtcbiAgbGV0IHggPSAxLjAgLyAoMS4wICsgcjAgKiBhYnN2KTtcbiAgcmV0dXJuIHNpZ24odikgKiAoMS4wIC0gKCgoKHI1ICogeCArIHI0KSAqIHggKyByMykgKiB4ICsgcjIpICogeCArIHIxKSAqIHggKiBleHAoLWFic3YgKiBhYnN2KSk7XG59YDtcblxuZXhwb3J0IGNvbnN0IGVyZiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0VyZicsIGEgPT4gYGVyZl92ZjMyKCR7YX0pYCwgZXJmSW1wbChkYXRhVHlwZSkpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBleHAgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdFeHAnLCAnZXhwJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGZsb29yID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnRmxvb3InLCAnZmxvb3InKSk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2VsdSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLCAnR2VsdScsIGEgPT4gYDAuNSAqICR7YX0gKiAoMS4wICsgZXJmX3ZmMzIoJHthfSAqIDAuNzA3MTA2NzgxMTg2NTQ3NSkpYCwgZXJmSW1wbChkYXRhVHlwZSkpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBsZWFreVJlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEFscGhhQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLCAnTGVha3lSZWx1JywgYSA9PiBgc2VsZWN0KGxlYWt5X3JlbHVfYWxwaGFfICogJHthfSwgJHthfSwgJHthfSA+PSB2ZWM0PCR7ZGF0YVR5cGV9PigwLjApKWAsXG4gICAgICBgY29uc3QgbGVha3lfcmVsdV9hbHBoYV8gPSAke2RhdGFUeXBlfSgke2F0dHJpYnV0ZXMuYWxwaGF9KTtgLCBhdHRyaWJ1dGVzLmNhY2hlS2V5KSk7XG59O1xuXG5leHBvcnQgY29uc3Qgbm90ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnTm90JywgYSA9PiBgISR7YX1gKSk7XG59O1xuXG5leHBvcnQgY29uc3QgbmVnID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnTmVnJywgYSA9PiBgLSR7YX1gKSk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVjaXByb2NhbCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1JlY2lwcm9jYWwnLCBhID0+IGAxLjAvJHthfWApKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWx1ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0sICdSZWx1JywgYSA9PiBgc2VsZWN0KHZlYzQ8JHtkYXRhVHlwZX0+KDAuMCksICR7YX0sICR7YX0gPiB2ZWM0PCR7ZGF0YVR5cGV9PigwLjApKWApKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzaWdtb2lkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnU2lnbW9pZCcsIGEgPT4gYCgxLjAgLyAoMS4wICsgZXhwKC0ke2F9KSkpYCkpO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBIYXJkU2lnbW9pZEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBhbHBoYTogbnVtYmVyO1xuICByZWFkb25seSBiZXRhOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBwYXJzZUhhcmRTaWdtb2lkQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEhhcmRTaWdtb2lkQXR0cmlidXRlcyA9PlxuICAgIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShhdHRyaWJ1dGVzIGFzIHtcbiAgICAgIGFscGhhOiBudW1iZXI7XG4gICAgICBiZXRhOiBudW1iZXI7XG4gICAgfSk7XG5cbmV4cG9ydCBjb25zdCBoYXJkU2lnbW9pZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogSGFyZFNpZ21vaWRBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0sICdIYXJkU2lnbW9pZCcsXG4gICAgICBhID0+IGBtYXgodmVjNDwke2RhdGFUeXBlfT4oMC4wKSwgbWluKHZlYzQ8JHtkYXRhVHlwZX0+KDEuMCksICR7YXR0cmlidXRlcy5hbHBoYX0gKiAke2F9ICsgdmVjNDwke2RhdGFUeXBlfT4oJHtcbiAgICAgICAgICBhdHRyaWJ1dGVzLmJldGF9KSkpYCxcbiAgICAgIHVuZGVmaW5lZCwgYXR0cmlidXRlcy5jYWNoZUtleSkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHNpbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1NpbicsICdzaW4nKSk7XG59O1xuXG5leHBvcnQgY29uc3Qgc2luaCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1NpbmgnLCAnc2luaCcpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzcXJ0ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnU3FydCcsICdzcXJ0JykpO1xufTtcblxuZXhwb3J0IGNvbnN0IHRhbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1RhbicsICd0YW4nKSk7XG59O1xuXG5leHBvcnQgY29uc3QgdGFuaEV4cHJlc3Npb24gPSAoYTogc3RyaW5nKSA9PiBgc2lnbigke2F9KSAqICgxIC0gZXhwKC0yICogYWJzKCR7YX0pKSkgLyAoMSArIGV4cCgtMiAqIGFicygke2F9KSkpYDtcblxuZXhwb3J0IGNvbnN0IHRhbmggPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgLy8gVE9ETzogcmV2aXNpdCBhZnRlciBodHRwczovL2dpdGh1Yi5jb20vZ3B1d2ViL2dwdXdlYi9pc3N1ZXMvNDQ1OCBpcyByZXNvbHZlZFxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1RhbmgnLCB0YW5oRXhwcmVzc2lvbikpO1xufTtcblxuZXhwb3J0IGNvbnN0IGZhc3RHZWx1SW1wbCA9ICh2YXJUeXBlID0gJ2YzMicpID0+IGBcbmNvbnN0IGZhc3RfZ2VsdV9hOiAke3ZhclR5cGV9ID0gMC41O1xuY29uc3QgZmFzdF9nZWx1X2I6ICR7dmFyVHlwZX0gPSAwLjc5Nzg4NDU2MDgwMjg2NTQ7XG5jb25zdCBmYXN0X2dlbHVfYzogJHt2YXJUeXBlfSA9IDAuMDM1Njc3NDA4MTM2MzAwMTI1O1xuXG5mbiB0YW5oX3YodjogdmVjNDwke3ZhclR5cGV9PikgLT4gdmVjNDwke3ZhclR5cGV9PiB7XG4gIHJldHVybiAke3RhbmhFeHByZXNzaW9uKCd2Jyl9O1xufVxuYDtcblxuZXhwb3J0IGNvbnN0IGZhc3RHZWx1RXhwcmVzc2lvbiA9ICh4OiBzdHJpbmcpID0+XG4gICAgYChmYXN0X2dlbHVfYSArIGZhc3RfZ2VsdV9hICogdGFuaF92KCR7eH0gKiAoZmFzdF9nZWx1X2MgKiAke3h9ICogJHt4fSArIGZhc3RfZ2VsdV9iKSkpICogJHt4fWA7XG5cbmV4cG9ydCBjb25zdCBmYXN0R2VsdSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLCAnRmFzdEdlbHUnLCBmYXN0R2VsdUV4cHJlc3Npb24sIGZhc3RHZWx1SW1wbChkYXRhVHlwZSksIHVuZGVmaW5lZCxcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKSk7XG59O1xuXG5leHBvcnQgY29uc3QgdGhyZXNob2xkZWRSZWx1ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBBbHBoYUF0dHJpYnV0ZXMpOiBudW1iZXIgPT4ge1xuICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLCAnVGhyZXNob2xkZWRSZWx1JywgYSA9PiBgc2VsZWN0KHZlYzQ8JHtkYXRhVHlwZX0+KDAuMCksICR7YX0sICR7YX0gPiB0aHJlc2hvbGRlZF9yZWx1X2FscGhhXylgLFxuICAgICAgYGNvbnN0IHRocmVzaG9sZGVkX3JlbHVfYWxwaGFfID0gdmVjNDwke2RhdGFUeXBlfT4oJHthdHRyaWJ1dGVzLmFscGhhfSk7YCwgYXR0cmlidXRlcy5jYWNoZUtleSkpO1xuICByZXR1cm4gMDtcbn07XG5cbmV4cG9ydCBjb25zdCBsb2cgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdMb2cnLCAnbG9nJykpO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mb30gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2lucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZX0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IHtlcmZJbXBsfSBmcm9tICcuL3VuYXJ5LW9wJztcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgc2hvdWxkIGhhdmUgMyBkaW1lbnNpb25zJyk7XG4gIH1cblxuICBpZiAoIVsyNTYwLCA1MTIwLCAxMDI0MF0uaW5jbHVkZXMoaW5wdXRzWzBdLmRpbXNbMl0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdoaWRkZW4gc3RhdGUgc2hvdWxkIGJlIDI1NjAsIDUxMjAgb3IgMTAyNDAnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpYXMgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbnMnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0uZGltc1syXSAhPT0gaW5wdXRzWzFdLmRpbXNbMF0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhc3QgZGltZW5zaW9uIG9mIGlucHV0IGFuZCBiaWFzIGFyZSBub3QgdGhlIHNhbWUnKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlQmlhc1NwbGl0R2VsdVByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gIG91dHB1dFNoYXBlWzJdID0gb3V0cHV0U2hhcGVbMl0gLyAyO1xuXG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLCA0KTtcbiAgY29uc3QgYmlhcyA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIFtpbnB1dHNbMF0uZGltc1syXV0sIDQpO1xuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgNCk7XG5cbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIDQ7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0c1swXS5kYXRhVHlwZSk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gIGNvbnN0IE1fU1FSVDIgPSBzcXJ0KDIuMCk7XG4gIGNvbnN0IGhhbGZDaGFubmVscyA9ICR7aW5wdXRzWzBdLmRpbXNbMl0gLyA0IC8gMn11O1xuXG4gICR7c2hhZGVySGVscGVyLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIGJpYXMsIG91dHB1dCl9XG5cbiAgJHtlcmZJbXBsKGRhdGFUeXBlKX1cblxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKG91dHB1dFNpemUpfVxuICAgIGxldCBiaWFzSWR4ID0gZ2xvYmFsX2lkeCAlIGhhbGZDaGFubmVscztcbiAgICBsZXQgYmF0Y2hJbmRleCA9IGdsb2JhbF9pZHggLyBoYWxmQ2hhbm5lbHM7XG4gICAgbGV0IGlucHV0T2Zmc2V0ID0gYmlhc0lkeCArIGJhdGNoSW5kZXggKiBoYWxmQ2hhbm5lbHMgKiAyO1xuICAgIGxldCB2YWx1ZUxlZnQgPSBpbnB1dFtpbnB1dE9mZnNldF0gKyBiaWFzW2JpYXNJZHhdO1xuICAgIGxldCB2YWx1ZVJpZ2h0ID0gaW5wdXRbaW5wdXRPZmZzZXQgKyBoYWxmQ2hhbm5lbHNdICsgYmlhc1tiaWFzSWR4ICsgaGFsZkNoYW5uZWxzXTtcbiAgICBsZXQgZ2VsdVJpZ2h0ID0gdmFsdWVSaWdodCAqIDAuNSAqIChlcmZfdmYzMih2YWx1ZVJpZ2h0IC8gTV9TUVJUMikgKyAxKTtcblxuICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlTGVmdCAqIGdlbHVSaWdodCcpfVxuICB9YDtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdCaWFzU3BsaXRHZWx1JyxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfVxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBiaWFzU3BsaXRHZWx1ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUJpYXNTcGxpdEdlbHVQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cykpO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge0Jyb2FkY2FzdFV0aWwsIFNoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mb30gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyfSBmcm9tICcuL2NvbW1vbic7XG5cbnR5cGUgQnVpbHRpbkZ1bmN0aW9uTmFtZSA9IHN0cmluZztcbnR5cGUgQmluYXJ5Q3VzdG9tRXhwcmVzc2lvbiA9IChleHByZXNzaW9uQTogc3RyaW5nLCBleHByZXNzaW9uQjogc3RyaW5nKSA9PiBzdHJpbmc7XG50eXBlIEJpbmFyeUZ1bmN0aW9uQ2FsbCA9IEJ1aWx0aW5GdW5jdGlvbk5hbWV8QmluYXJ5Q3VzdG9tRXhwcmVzc2lvbnx7XG4gIHNjYWxhcjogQmluYXJ5Q3VzdG9tRXhwcmVzc2lvbjtcbiAgdmVjdG9yOiBCaW5hcnlDdXN0b21FeHByZXNzaW9uO1xufTtcblxuY29uc3QgY3JlYXRlQmluYXJ5T3BQcm9ncmFtU2hhZGVyID1cbiAgICAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIsIGRpbXNBOiByZWFkb25seSBudW1iZXJbXSwgZGltc0I6IHJlYWRvbmx5IG51bWJlcltdLCBkaW1zT3V0cHV0OiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgdmVjdG9yaXplOiBib29sZWFuLCBkb0Jyb2FkY2FzdDogYm9vbGVhbiwgc2hhcmVkRGltZW5zaW9uRGl2aXNpYmxlQnk0OiBib29sZWFuLCBmdW5jQ2FsbDogQmluYXJ5RnVuY3Rpb25DYWxsLFxuICAgICB0eXBlQTogbnVtYmVyLCB0eXBlQjogbnVtYmVyLCB0eXBlT3V0cHV0OiBudW1iZXIsIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbj86IHN0cmluZykgPT4ge1xuICAgICAgbGV0IGV4cHJlc3Npb25TY2FsYXI6IEJpbmFyeUN1c3RvbUV4cHJlc3Npb247XG4gICAgICBsZXQgZXhwcmVzc2lvblZlY3RvcjogQmluYXJ5Q3VzdG9tRXhwcmVzc2lvbjtcbiAgICAgIGlmICh0eXBlb2YgZnVuY0NhbGwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGV4cHJlc3Npb25TY2FsYXIgPSBleHByZXNzaW9uVmVjdG9yID0gKGEsIGIpID0+IGAke2Z1bmNDYWxsfSgoJHthfSksKCR7Yn0pKWA7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmdW5jQ2FsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBleHByZXNzaW9uU2NhbGFyID0gZXhwcmVzc2lvblZlY3RvciA9IGZ1bmNDYWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhwcmVzc2lvblNjYWxhciA9IGZ1bmNDYWxsLnNjYWxhcjtcbiAgICAgICAgZXhwcmVzc2lvblZlY3RvciA9IGZ1bmNDYWxsLnZlY3RvcjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dERhdGEnLCB0eXBlT3V0cHV0LCBkaW1zT3V0cHV0Lmxlbmd0aCwgNCk7XG4gICAgICBjb25zdCBhID0gaW5wdXRWYXJpYWJsZSgnYURhdGEnLCB0eXBlQSwgZGltc0EubGVuZ3RoLCA0KTtcbiAgICAgIGNvbnN0IGIgPSBpbnB1dFZhcmlhYmxlKCdiRGF0YScsIHR5cGVCLCBkaW1zQi5sZW5ndGgsIDQpO1xuXG4gICAgICBsZXQgYXNzaWdubWVudDogc3RyaW5nO1xuICAgICAgaWYgKHZlY3Rvcml6ZSkge1xuICAgICAgICBpZiAoZG9Ccm9hZGNhc3QpIHtcbiAgICAgICAgICBjb25zdCBpc0FPbmVFbGVtZW50ID0gU2hhcGVVdGlsLnNpemUoZGltc0EpID09PSAxO1xuICAgICAgICAgIGNvbnN0IGlzQk9uZUVsZW1lbnQgPSBTaGFwZVV0aWwuc2l6ZShkaW1zQikgPT09IDE7XG4gICAgICAgICAgY29uc3QgYUxhc3REaW1EaXZpc2libGVCeTQgPSBkaW1zQS5sZW5ndGggPiAwICYmIGRpbXNBW2RpbXNBLmxlbmd0aCAtIDFdICUgNCA9PT0gMDtcbiAgICAgICAgICBjb25zdCBiTGFzdERpbURpdmlzaWJsZUJ5NCA9IGRpbXNCLmxlbmd0aCA+IDAgJiYgZGltc0JbZGltc0IubGVuZ3RoIC0gMV0gJSA0ID09PSAwO1xuICAgICAgICAgIGlmIChpc0FPbmVFbGVtZW50IHx8IGlzQk9uZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGFzc2lnbm1lbnQgPSBvdXRwdXQuc2V0QnlPZmZzZXQoXG4gICAgICAgICAgICAgICAgJ2dsb2JhbF9pZHgnLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25WZWN0b3IoXG4gICAgICAgICAgICAgICAgICAgIGlzQU9uZUVsZW1lbnQgPyBgJHthLnR5cGUudmFsdWV9KCR7YS5nZXRCeU9mZnNldCgnMCcpfS54KWAgOiBhLmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JyksXG4gICAgICAgICAgICAgICAgICAgIGlzQk9uZUVsZW1lbnQgPyBgJHtiLnR5cGUudmFsdWV9KCR7Yi5nZXRCeU9mZnNldCgnMCcpfS54KWAgOiBiLmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JykpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXNzaWdubWVudCA9IGBcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4ICogNHUnKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSA9ICR7YS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCgnb3V0cHV0SW5kaWNlcycsIG91dHB1dCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEIgPSAke2IuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoJ291dHB1dEluZGljZXMnLCBvdXRwdXQpfTtcbiAgICAgICAgICAgICR7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNldEJ5T2Zmc2V0KFxuICAgICAgICAgICAgICAgICAgICAnZ2xvYmFsX2lkeCcsXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25WZWN0b3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWREaW1lbnNpb25EaXZpc2libGVCeTQgfHwgYUxhc3REaW1EaXZpc2libGVCeTQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuZ2V0QnlPZmZzZXQoJ29mZnNldEEgLyA0dScpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHthLnR5cGUudmFsdWV9KCR7YS5nZXRCeU9mZnNldCgnb2Zmc2V0QSAvIDR1Jyl9W29mZnNldEEgJSA0dV0pYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXJlZERpbWVuc2lvbkRpdmlzaWJsZUJ5NCB8fCBiTGFzdERpbURpdmlzaWJsZUJ5NCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5nZXRCeU9mZnNldCgnb2Zmc2V0QiAvIDR1JykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke2IudHlwZS52YWx1ZX0oJHtiLmdldEJ5T2Zmc2V0KCdvZmZzZXRCIC8gNHUnKX1bb2Zmc2V0QiAlIDR1XSlgKSl9XG4gICAgICAgICAgYDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXNzaWdubWVudCA9IG91dHB1dC5zZXRCeU9mZnNldChcbiAgICAgICAgICAgICAgJ2dsb2JhbF9pZHgnLCBleHByZXNzaW9uVmVjdG9yKGEuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKSwgYi5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghZG9Ccm9hZGNhc3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIG5lY2Vzc2FyeSB0byB1c2Ugc2NhbGFyIGltcGxlbWVudGF0aW9uIGZvciBlbGVtZW50LXdpc2UgYmluYXJ5IG9wIGltcGxlbWVudGF0aW9uLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2luZ2xlQXNzaWdubWVudCA9IChyZXNTdHI6IHN0cmluZywgeDogbnVtYmVyLCB0eXBlQ2FzdCA9ICcnKSA9PiB7XG4gICAgICAgICAgY29uc3QgZXhwcmVzc2lvbkEgPSBgYURhdGFbaW5kZXhBJHt4fV1bY29tcG9uZW50QSR7eH1dYDtcbiAgICAgICAgICBjb25zdCBleHByZXNzaW9uQiA9IGBiRGF0YVtpbmRleEIke3h9XVtjb21wb25lbnRCJHt4fV1gO1xuICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7eH0gPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiA0dSArICR7eH11YCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEEke3h9ID0gJHthLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRJbmRpY2VzJHt4fWAsIG91dHB1dCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEIke3h9ID0gJHtiLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRJbmRpY2VzJHt4fWAsIG91dHB1dCl9O1xuICAgICAgICAgICAgbGV0IGluZGV4QSR7eH0gPSBvZmZzZXRBJHt4fSAvIDR1O1xuICAgICAgICAgICAgbGV0IGluZGV4QiR7eH0gPSBvZmZzZXRCJHt4fSAvIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudEEke3h9ID0gb2Zmc2V0QSR7eH0gJSA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRCJHt4fSA9IG9mZnNldEIke3h9ICUgNHU7XG4gICAgICAgICAgICAke3Jlc1N0cn1bJHt4fV0gPSAke3R5cGVDYXN0fSgke2V4cHJlc3Npb25TY2FsYXIoZXhwcmVzc2lvbkEsIGV4cHJlc3Npb25CKX0pO1xuICAgICAgICAgIGA7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlT3V0cHV0ID09PSBEYXRhVHlwZS5ib29sKSB7XG4gICAgICAgICAgYXNzaWdubWVudCA9IGBcbiAgICAgICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMCwgJ3UzMicpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMSwgJ3UzMicpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMiwgJ3UzMicpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMywgJ3UzMicpfVxuICAgICAgICAgICAgb3V0cHV0RGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2lnbm1lbnQgPSBgXG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ291dHB1dERhdGFbZ2xvYmFsX2lkeF0nLCAwKX1cbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnb3V0cHV0RGF0YVtnbG9iYWxfaWR4XScsIDEpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXREYXRhW2dsb2JhbF9pZHhdJywgMil9XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ291dHB1dERhdGFbZ2xvYmFsX2lkeF0nLCAzKX1cbiAgICAgICAgICBgO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBgXG4gICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgndmVjX3NpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyhhLCBiLCBvdXRwdXQpfVxuXG4gICAgICAgICR7YWRkaXRpb25hbEltcGxlbWVudGF0aW9uID8/ICcnfVxuXG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy52ZWNfc2l6ZScpfVxuICAgICAgICAke2Fzc2lnbm1lbnR9XG4gICAgICB9YDtcbiAgICB9O1xuXG5jb25zdCBjcmVhdGVCaW5hcnlPcFByb2dyYW1JbmZvID1cbiAgICAobmFtZTogc3RyaW5nLCBjYWNoZUtleTogc3RyaW5nLCBhOiBUZW5zb3JWaWV3LCBiOiBUZW5zb3JWaWV3LCBmdW5jQ2FsbDogQmluYXJ5RnVuY3Rpb25DYWxsLFxuICAgICBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb24/OiBzdHJpbmcsIG91dHB1dERhdGFUeXBlOiBudW1iZXIgPSBhLmRhdGFUeXBlKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgaXNCcm9hZGNhc3QgPSAhU2hhcGVVdGlsLmFyZUVxdWFsKGEuZGltcywgYi5kaW1zKTtcbiAgICAgIGxldCBvdXRwdXRTaGFwZSA9IGEuZGltcztcbiAgICAgIGxldCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUoYS5kaW1zKTtcblxuICAgICAgbGV0IHZlY3Rvcml6ZSA9IGZhbHNlO1xuICAgICAgbGV0IHNoYXJlZERpbWVuc2lvbkRpdmlzaWJsZUJ5NCA9IGZhbHNlO1xuXG4gICAgICAvLyBUT0RPOiBkZWFsIHdpdGggemVyby1zaXplZCB0ZW5zb3JzIChlZy4gZGltcz1bMSwwXSlcbiAgICAgIGNvbnN0IGNhY2hlS2V5QXV4ID0gW2lzQnJvYWRjYXN0XTtcbiAgICAgIGlmIChpc0Jyb2FkY2FzdCkge1xuICAgICAgICBjb25zdCBjYWxjdWxhdGVkU2hhcGUgPSBCcm9hZGNhc3RVdGlsLmNhbGNTaGFwZShhLmRpbXMsIGIuZGltcywgZmFsc2UpO1xuICAgICAgICBpZiAoIWNhbGN1bGF0ZWRTaGFwZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBwZXJmb3JtIGJpbmFyeSBvcCBvbiB0aGUgZ2l2ZW4gdGVuc29ycycpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dFNoYXBlID0gY2FsY3VsYXRlZFNoYXBlO1xuICAgICAgICBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICAgICAgICBjb25zdCBpc0FPbmVFbGVtZW50ID0gU2hhcGVVdGlsLnNpemUoYS5kaW1zKSA9PT0gMTtcbiAgICAgICAgY29uc3QgaXNCT25lRWxlbWVudCA9IFNoYXBlVXRpbC5zaXplKGIuZGltcykgPT09IDE7XG4gICAgICAgIGNvbnN0IGFMYXN0RGltRGl2aXNpYmxlQnk0ID0gYS5kaW1zLmxlbmd0aCA+IDAgJiYgYS5kaW1zW2EuZGltcy5sZW5ndGggLSAxXSAlIDQgPT09IDA7XG4gICAgICAgIGNvbnN0IGJMYXN0RGltRGl2aXNpYmxlQnk0ID0gYi5kaW1zLmxlbmd0aCA+IDAgJiYgYi5kaW1zW2IuZGltcy5sZW5ndGggLSAxXSAlIDQgPT09IDA7XG4gICAgICAgIGNhY2hlS2V5QXV4LnB1c2goaXNBT25lRWxlbWVudCk7XG4gICAgICAgIGNhY2hlS2V5QXV4LnB1c2goaXNCT25lRWxlbWVudCk7XG4gICAgICAgIGNhY2hlS2V5QXV4LnB1c2goYUxhc3REaW1EaXZpc2libGVCeTQpO1xuICAgICAgICBjYWNoZUtleUF1eC5wdXNoKGJMYXN0RGltRGl2aXNpYmxlQnk0KTtcbiAgICAgICAgLy8gY2hlY2sgd2hldGhlciB2ZWN0b3JpemUgY2FuIGJlIGVuYWJsZWRcbiAgICAgICAgbGV0IHNoYXJlZERpbWVuc2lvbiA9IDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgb3V0cHV0U2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBkaW1BID0gYS5kaW1zW2EuZGltcy5sZW5ndGggLSBpXSA/PyAxO1xuICAgICAgICAgIGNvbnN0IGRpbUIgPSBiLmRpbXNbYi5kaW1zLmxlbmd0aCAtIGldID8/IDE7XG4gICAgICAgICAgaWYgKGRpbUEgPT09IGRpbUIpIHtcbiAgICAgICAgICAgIHNoYXJlZERpbWVuc2lvbiAqPSBkaW1BO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXJlZERpbWVuc2lvbiAlIDQgPT09IDApIHtcbiAgICAgICAgICBzaGFyZWREaW1lbnNpb25EaXZpc2libGVCeTQgPSB0cnVlO1xuICAgICAgICAgIHZlY3Rvcml6ZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBT25lRWxlbWVudCB8fCBpc0JPbmVFbGVtZW50IHx8IGFMYXN0RGltRGl2aXNpYmxlQnk0IHx8IGJMYXN0RGltRGl2aXNpYmxlQnk0KSB7XG4gICAgICAgICAgdmVjdG9yaXplID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZWxlbWVudC13aXNlXG4gICAgICAgIHZlY3Rvcml6ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBjYWNoZUtleUF1eC5wdXNoKHZlY3Rvcml6ZSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICAgICAgaGludDogY2FjaGVLZXkgKyBjYWNoZUtleUF1eC5tYXAoKHgpID0+IHgudG9TdHJpbmcoKSkuam9pbignXycpLFxuICAgICAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnLCAncmFuayddLFxuICAgICAgICB9LFxuICAgICAgICBnZXRTaGFkZXJTb3VyY2U6IChzaGFkZXJIZWxwZXIpID0+IGNyZWF0ZUJpbmFyeU9wUHJvZ3JhbVNoYWRlcihcbiAgICAgICAgICAgIHNoYWRlckhlbHBlciwgYS5kaW1zLCBiLmRpbXMsIG91dHB1dFNoYXBlLCB2ZWN0b3JpemUsIGlzQnJvYWRjYXN0LCBzaGFyZWREaW1lbnNpb25EaXZpc2libGVCeTQsIGZ1bmNDYWxsLFxuICAgICAgICAgICAgYS5kYXRhVHlwZSwgYi5kYXRhVHlwZSwgb3V0cHV0RGF0YVR5cGUsIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbiksXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IG91dHB1dERhdGFUeXBlfV0sXG4gICAgICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8gLyA0IC8qIGNvbXBvbmVudCBzaXplICovKX0sXG4gICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbXG4gICAgICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gNCl9LFxuICAgICAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoYS5kaW1zLCBiLmRpbXMsIG91dHB1dFNoYXBlKVxuICAgICAgICAgIF0sXG4gICAgICAgIH0pLFxuICAgICAgfTtcbiAgICB9O1xuXG5jb25zdCBydW5CaW5hcnlPcCA9XG4gICAgKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBuYW1lOiBzdHJpbmcsIGZ1bmNDYWxsOiBCaW5hcnlGdW5jdGlvbkNhbGwsIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbj86IHN0cmluZyxcbiAgICAgY2FjaGVLZXk/OiBzdHJpbmcsIG91dHB1dERhdGFUeXBlPzogbnVtYmVyKTogdm9pZCA9PiB7XG4gICAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQmluYXJ5T3BQcm9ncmFtSW5mbyhcbiAgICAgICAgICBuYW1lLCBjYWNoZUtleSA/PyAnJywgY29udGV4dC5pbnB1dHNbMF0sIGNvbnRleHQuaW5wdXRzWzFdLCBmdW5jQ2FsbCwgYWRkaXRpb25hbEltcGxlbWVudGF0aW9uLFxuICAgICAgICAgIG91dHB1dERhdGFUeXBlKSk7XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IGFkZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBydW5CaW5hcnlPcChjb250ZXh0LCAnQWRkJywgKGEsIGIpID0+IGAke2F9KyR7Yn1gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBkaXYgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoY29udGV4dCwgJ0RpdicsIChhLCBiKSA9PiBgJHthfS8ke2J9YCk7XG59O1xuXG5leHBvcnQgY29uc3QgZXF1YWwgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoXG4gICAgICBjb250ZXh0LCAnRXF1YWwnLCAoe3NjYWxhcjogKGEsIGIpID0+IGB1MzIoJHthfT09JHtifSlgLCB2ZWN0b3I6IChhLCBiKSA9PiBgdmVjNDx1MzI+KCR7YX09PSR7Yn0pYH0pLCB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsIERhdGFUeXBlLmJvb2wpO1xufTtcblxuZXhwb3J0IGNvbnN0IG11bCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBydW5CaW5hcnlPcChjb250ZXh0LCAnTXVsJywgKGEsIGIpID0+IGAke2F9KiR7Yn1gKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwb3cgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29uc3QgdHlwZSA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXMpLnR5cGUudmFsdWU7XG4gIGNvbnN0IHJvdW5kU3RyID0gdHlwZSA9PT0gJ2kzMicgPyAncm91bmQnIDogJyc7XG4gIHJ1bkJpbmFyeU9wKFxuICAgICAgY29udGV4dCwgJ1BvdycsICh7c2NhbGFyOiAoYSwgYikgPT4gYHBvd19jdXN0b20oJHthfSwke2J9KWAsIHZlY3RvcjogKGEsIGIpID0+IGBwb3dfdmVjdG9yX2N1c3RvbSgke2F9LCR7Yn0pYH0pLFxuICAgICAgYFxuICAgIGZuIHBvd19jdXN0b20oYSA6ICR7dHlwZX0sIGIgOiAke3R5cGV9KSAtPiAke3R5cGV9IHtcbiAgICAgIGlmIChiID09ICR7dHlwZX0oMC4wKSkge1xuICAgICAgICByZXR1cm4gJHt0eXBlfSgxLjApO1xuICAgICAgfSBlbHNlIGlmIChhIDwgJHt0eXBlfSgwLjApICYmIGYzMihiKSAhPSBmbG9vcihmMzIoYikpKSB7XG4gICAgICAgIHJldHVybiAke3R5cGV9KHBvdyhmMzIoYSksIGYzMihiKSkpOyAvLyBOYU5cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3Qoc2lnbihhKSwgJHt0eXBlfSgxLjApLCByb3VuZChmMzIoYWJzKGIpICUgJHt0eXBlfSgyLjApKSkgIT0gMS4wKSAqICR7dHlwZX0oJHtcbiAgICAgICAgICByb3VuZFN0cn0ocG93KGYzMihhYnMoYSkpLCBmMzIoYikpKSk7XG4gICAgfVxuICAgIGZuIHBvd192ZWN0b3JfY3VzdG9tKGEgOiB2ZWM0PCR7dHlwZX0+LCBiIDogdmVjNDwke3R5cGV9PikgLT4gdmVjNDwke3R5cGV9PiB7XG4gICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgdmVjdG9yaXplZCBwb3dcbiAgICAgIHJldHVybiB2ZWM0PCR7dHlwZX0+KHBvd19jdXN0b20oYS54LCBiLngpLCBwb3dfY3VzdG9tKGEueSwgYi55KSwgcG93X2N1c3RvbShhLnosIGIueiksIHBvd19jdXN0b20oYS53LCBiLncpKTtcbiAgICB9XG4gICAgICBgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzdWIgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoY29udGV4dCwgJ1N1YicsIChhLCBiKSA9PiBgJHthfS0ke2J9YCk7XG59O1xuXG5leHBvcnQgY29uc3QgZ3JlYXRlciA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBydW5CaW5hcnlPcChcbiAgICAgIGNvbnRleHQsICdHcmVhdGVyJywgKHtzY2FsYXI6IChhLCBiKSA9PiBgdTMyKCR7YX0+JHtifSlgLCB2ZWN0b3I6IChhLCBiKSA9PiBgdmVjNDx1MzI+KCR7YX0+JHtifSlgfSksIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZCwgRGF0YVR5cGUuYm9vbCk7XG59O1xuXG5leHBvcnQgY29uc3QgbGVzcyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBydW5CaW5hcnlPcChcbiAgICAgIGNvbnRleHQsICdMZXNzJywgKHtzY2FsYXI6IChhLCBiKSA9PiBgdTMyKCR7YX08JHtifSlgLCB2ZWN0b3I6IChhLCBiKSA9PiBgdmVjNDx1MzI+KCR7YX08JHtifSlgfSksIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZCwgRGF0YVR5cGUuYm9vbCk7XG59O1xuXG5leHBvcnQgY29uc3QgZ3JlYXRlck9yRXF1YWwgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoXG4gICAgICBjb250ZXh0LCAnR3JlYXRlck9yRXF1YWwnLCAoe3NjYWxhcjogKGEsIGIpID0+IGB1MzIoJHthfT49JHtifSlgLCB2ZWN0b3I6IChhLCBiKSA9PiBgdmVjNDx1MzI+KCR7YX0+PSR7Yn0pYH0pLFxuICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIERhdGFUeXBlLmJvb2wpO1xufTtcblxuZXhwb3J0IGNvbnN0IGxlc3NPckVxdWFsID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIHJ1bkJpbmFyeU9wKFxuICAgICAgY29udGV4dCwgJ0xlc3NPckVxdWFsJywgKHtzY2FsYXI6IChhLCBiKSA9PiBgdTMyKCR7YX08PSR7Yn0pYCwgdmVjdG9yOiAoYSwgYikgPT4gYHZlYzQ8dTMyPigke2F9PD0ke2J9KWB9KSxcbiAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBEYXRhVHlwZS5ib29sKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm19IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgSW5kaWNlc0hlbHBlciwgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlcn0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbmNhdEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBheGlzOiBudW1iZXI7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBheGlzOiBudW1iZXIpOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvbyBmZXcgaW5wdXRzJyk7XG4gIH1cbiAgY29uc3QgcmVmZXJlbmNlSW5kZXggPSAwO1xuICBjb25zdCByZWZlcmVuY2VJbnB1dCA9IGlucHV0c1tyZWZlcmVuY2VJbmRleF07XG4gIGNvbnN0IGlucHV0VHlwZSA9IHJlZmVyZW5jZUlucHV0LmRhdGFUeXBlO1xuICBjb25zdCBpbnB1dFJhbmsgPSByZWZlcmVuY2VJbnB1dC5kaW1zLmxlbmd0aDtcbiAgaW5wdXRzLmZvckVhY2goKGlucHV0LCBpKSA9PiB7XG4gICAgaWYgKGkgPT09IHJlZmVyZW5jZUluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSB0eXBlcyBvZiBhbGwgaW5wdXRzIG1hdGNoXG4gICAgaWYgKGlucHV0LmRhdGFUeXBlICE9PSBpbnB1dFR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgdGVuc29ycyBzaG91bGQgYmUgb25lIHR5cGUnKTtcbiAgICB9XG4gICAgLy8gbWFrZSBzdXJlIHRoZSBkaW1lbnNpb25hbGl0eSBvZiBhbGwgaW5wdXRzIGFyZSB0aGUgc2FtZVxuICAgIGlmIChpbnB1dC5kaW1zLmxlbmd0aCAhPT0gaW5wdXRSYW5rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHRlbnNvcnMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgc2hhcGUnKTtcbiAgICB9XG4gICAgaW5wdXQuZGltcy5mb3JFYWNoKChkaW0sIGkpID0+IHtcbiAgICAgIGlmIChpICE9PSBheGlzICYmIGRpbSAhPT0gcmVmZXJlbmNlSW5wdXQuZGltc1tpXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vbiBjb25jYXQgZGltZW5zaW9ucyBtdXN0IG1hdGNoJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuY29uc3QgY2FsY3VsYXRlSW5wdXRJbmRleEltcGwgPSAobnVtYmVyT2ZUZW5zb3JzOiBudW1iZXIsIHNpemVJbkNvbmNhdEF4aXNTdHI6IHN0cmluZyk6IHN0cmluZyA9PiBgXG4gIGZuIGNhbGN1bGF0ZUlucHV0SW5kZXgoaW5kZXg6IHUzMikgLT4gdTMyIHtcbiAgICBsZXQgc2l6ZUluQ29uY2F0QXhpcyA9IGFycmF5PHUzMiwgJHtudW1iZXJPZlRlbnNvcnN9dT4oJHtzaXplSW5Db25jYXRBeGlzU3RyfSk7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke251bWJlck9mVGVuc29yc307IGkgKz0gMXUgKSB7XG4gICAgICBpZiAoaW5kZXggPCBzaXplSW5Db25jYXRBeGlzW2ldKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJHtudW1iZXJPZlRlbnNvcnN9dTtcbiAgfWA7XG5cbmNvbnN0IGFzc2lnbk91dHB1dERhdGEgPSAoaW5wdXRzOiByZWFkb25seSBJbmRpY2VzSGVscGVyW10sIG91dHB1dDogSW5kaWNlc0hlbHBlcikgPT4ge1xuICBjb25zdCBudW1iZXJPZlRlbnNvcnMgPSBpbnB1dHMubGVuZ3RoO1xuXG4gIGNvbnN0IGNvZGVMaW5lczogc3RyaW5nW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlRlbnNvcnM7ICsraSkge1xuICAgIGNvbnN0IHJldHVyblNuaXBwZXQgPSBvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCBpbnB1dHNbaV0uZ2V0QnlJbmRpY2VzKCdpbmRpY2VzJykpO1xuICAgIGlmIChudW1iZXJPZlRlbnNvcnMgPT09IDEpIHtcbiAgICAgIGNvZGVMaW5lcy5wdXNoKHJldHVyblNuaXBwZXQpO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgY29kZUxpbmVzLnB1c2goYGlmIChpbnB1dEluZGV4ID09ICR7aX11KSB7ICR7cmV0dXJuU25pcHBldH0gfWApO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gbnVtYmVyT2ZUZW5zb3JzIC0gMSkge1xuICAgICAgY29kZUxpbmVzLnB1c2goYGVsc2UgeyAke3JldHVyblNuaXBwZXR9IH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZUxpbmVzLnB1c2goYGVsc2UgaWYgKGlucHV0SW5kZXggPT0gJHtpfSkgeyAke3JldHVyblNuaXBwZXR9IH1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvZGVMaW5lcy5qb2luKCdcXG4nKTtcbn07XG5cbmNvbnN0IGNyZWF0ZUNvbmNhdFByb2dyYW1JbmZvID1cbiAgICAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGFkanVzdGVkQXhpczogbnVtYmVyLCBvdXRwdXRTaGFwZTogbnVtYmVyW10sIGRhdGFUeXBlOiBEYXRhVHlwZSk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG5cbiAgICAgIGNvbnN0IHNpemVJbkNvbmNhdEF4aXMgPSBuZXcgQXJyYXk8bnVtYmVyPihpbnB1dHMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGlucHV0VmFycyA9IG5ldyBBcnJheTxJbmRpY2VzSGVscGVyPihpbnB1dHMubGVuZ3RoKTtcblxuICAgICAgbGV0IHByZXZpb3VzU3VtID0gMDtcbiAgICAgIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gW107XG4gICAgICBjb25zdCBpbnB1dFJhbmtzID0gW107XG4gICAgICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbe3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZX1dO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcHJldmlvdXNTdW0gKz0gaW5wdXRzW2ldLmRpbXNbYWRqdXN0ZWRBeGlzXTtcbiAgICAgICAgc2l6ZUluQ29uY2F0QXhpc1tpXSA9IHByZXZpb3VzU3VtO1xuICAgICAgICBpbnB1dFJhbmtzLnB1c2goaW5wdXRzW2ldLmRpbXMubGVuZ3RoKTtcbiAgICAgICAgaW5wdXRWYXJzW2ldID0gaW5wdXRWYXJpYWJsZShgaW5wdXQke2l9YCwgZGF0YVR5cGUsIGlucHV0UmFua3NbaV0pO1xuICAgICAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCdyYW5rJyk7XG4gICAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHNpemVJbkNvbmNhdEF4aXNbaV19KTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1tpXS5kaW1zKSk7XG4gICAgICB9XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSkpO1xuXG4gICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gICAgICBjb25zdCBpbmRpY2VzQXhpcyA9IG91dHB1dC5pbmRpY2VzR2V0KCdpbmRpY2VzJywgYWRqdXN0ZWRBeGlzKTtcbiAgICAgIGNvbnN0IHNpemVJbkNvbmNhdEF4aXNTdHIgPVxuICAgICAgICAgIEFycmF5LmZyb20oQXJyYXkoc2l6ZUluQ29uY2F0QXhpcy5sZW5ndGgpLmtleXMoKSkubWFwKGkgPT4gYHVuaWZvcm1zLnNpemVJbkNvbmNhdEF4aXMke2l9YCkuam9pbignLCcpO1xuICAgICAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG5cbiAgJHsoKCkgPT4ge1xuICAgICAgICBzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRTaXplJywgJ3UzMicpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHNoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oYHNpemVJbkNvbmNhdEF4aXMke2l9YCwgJ3UzMicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaGFkZXJIZWxwZXIuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcnMsIG91dHB1dCk7XG4gICAgICB9KSgpfVxuXG4gICR7Y2FsY3VsYXRlSW5wdXRJbmRleEltcGwoc2l6ZUluQ29uY2F0QXhpcy5sZW5ndGgsIHNpemVJbkNvbmNhdEF4aXNTdHIpfVxuXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cblxuICAgIHZhciBpbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuXG4gICAgbGV0IGlucHV0SW5kZXggPSBjYWxjdWxhdGVJbnB1dEluZGV4KCR7aW5kaWNlc0F4aXN9KTtcbiAgICBpZiAoaW5wdXRJbmRleCAhPSAwdSkge1xuICAgICAgbGV0IHNpemVJbkNvbmNhdEF4aXMgPSBhcnJheTx1MzIsICR7c2l6ZUluQ29uY2F0QXhpcy5sZW5ndGh9dT4oJHtzaXplSW5Db25jYXRBeGlzU3RyfSk7XG4gICAgICAke2luZGljZXNBeGlzfSAtPSBzaXplSW5Db25jYXRBeGlzW2lucHV0SW5kZXggLSAxdV07XG4gICAgfVxuXG4gICAgJHthc3NpZ25PdXRwdXREYXRhKGlucHV0VmFycywgb3V0cHV0KX1cbiAgfWA7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdDb25jYXQnLFxuICAgICAgICBzaGFkZXJDYWNoZToge2hpbnQ6IGAke2FkanVzdGVkQXhpc31gLCBpbnB1dERlcGVuZGVuY2llc30sXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGV9XSxcbiAgICAgICAgICBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICAgICAgfSksXG4gICAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICAgIH07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IGNvbmNhdCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQ29uY2F0QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBpbnB1dHMgPSBjb250ZXh0LmlucHV0cztcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBhZGp1c3RlZEF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhhdHRyaWJ1dGVzLmF4aXMsIGlucHV0U2hhcGUubGVuZ3RoKTtcbiAgdmFsaWRhdGVJbnB1dHMoaW5wdXRzLCBhZGp1c3RlZEF4aXMpO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoKTtcbiAgb3V0cHV0U2hhcGVbYWRqdXN0ZWRBeGlzXSA9XG4gICAgICBpbnB1dHMucmVkdWNlKChzdW0sIGlucHV0KSA9PiBzdW0gKyAoaW5wdXQuZGltcy5sZW5ndGggPiBhZGp1c3RlZEF4aXMgPyBpbnB1dC5kaW1zW2FkanVzdGVkQXhpc10gOiAwKSwgMCk7XG4gIC8vIDAgbGVuZ3RoIHRlbnNvcnMgYXJlIHZhbGlkIGZvciBjb25jYXQsIHJlbW92ZSB0aGVtXG4gIGNvbnN0IG5vbkVtcHR5SW5wdXRzID0gaW5wdXRzLmZpbHRlcihpbnB1dCA9PiBTaGFwZVV0aWwuc2l6ZShpbnB1dC5kaW1zKSA+IDApO1xuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgICBjcmVhdGVDb25jYXRQcm9ncmFtSW5mbyhub25FbXB0eUlucHV0cywgYWRqdXN0ZWRBeGlzLCBvdXRwdXRTaGFwZSwgaW5wdXRzWzBdLmRhdGFUeXBlKSwge2lucHV0czogbm9uRW1wdHlJbnB1dHN9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUNvbmNhdEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBDb25jYXRBdHRyaWJ1dGVzID0+XG4gICAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtheGlzOiBhdHRyaWJ1dGVzLmF4aXMgYXMgbnVtYmVyfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7TUFYX0NMSVAsIE1JTl9DTElQfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7UHJvZ3JhbVVuaWZvcm19IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtVbmlmb3Jtc0FycmF5VHlwZX0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMge1xuICByZWFkb25seSBhY3RpdmF0aW9uOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGNsaXBNaW4/OiBudW1iZXI7XG4gIHJlYWRvbmx5IGNsaXBNYXg/OiBudW1iZXI7XG4gIHJlYWRvbmx5IGFscGhhPzogbnVtYmVyO1xuICByZWFkb25seSBiZXRhPzogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgZ2V0QWN0aXZhdGlvblNuaXBwZXQgPVxuICAgIChhdHRyaWJ1dGVzOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLCB2YWx1ZVR5cGU6IHN0cmluZywgYmFzZVR5cGUgPSAnZjMyJyk6IHN0cmluZyA9PiB7XG4gICAgICBzd2l0Y2ggKGF0dHJpYnV0ZXMuYWN0aXZhdGlvbikge1xuICAgICAgICBjYXNlICdSZWx1JzpcbiAgICAgICAgICByZXR1cm4gYHZhbHVlID0gbWF4KHZhbHVlLCAke3ZhbHVlVHlwZX0oMC4wKSk7YDtcbiAgICAgICAgY2FzZSAnU2lnbW9pZCc6XG4gICAgICAgICAgcmV0dXJuIGB2YWx1ZSA9ICgke3ZhbHVlVHlwZX0oMS4wKSAvICgke3ZhbHVlVHlwZX0oMS4wKSArIGV4cCgtdmFsdWUpKSk7YDtcbiAgICAgICAgY2FzZSAnQ2xpcCc6XG4gICAgICAgICAgcmV0dXJuIGB2YWx1ZSA9IGNsYW1wKHZhbHVlLCAke3ZhbHVlVHlwZX0oJHtiYXNlVHlwZX0odW5pZm9ybXMuY2xpcF9taW4pKSwgJHt2YWx1ZVR5cGV9KCR7XG4gICAgICAgICAgICAgIGJhc2VUeXBlfSh1bmlmb3Jtcy5jbGlwX21heCkpKTtgO1xuICAgICAgICBjYXNlICdIYXJkU2lnbW9pZCc6XG4gICAgICAgICAgcmV0dXJuIGB2YWx1ZSA9IG1heCgke3ZhbHVlVHlwZX0oMC4wKSwgbWluKCR7dmFsdWVUeXBlfSgxLjApLCAke2Jhc2VUeXBlfSh1bmlmb3Jtcy5hbHBoYSkgKiB2YWx1ZSArICR7XG4gICAgICAgICAgICAgIGJhc2VUeXBlfSh1bmlmb3Jtcy5iZXRhKSkpO2A7XG4gICAgICAgIGNhc2UgJ0xlYWt5UmVsdSc6XG4gICAgICAgICAgcmV0dXJuIGB2YWx1ZSA9IHNlbGVjdCgke2Jhc2VUeXBlfSh1bmlmb3Jtcy5hbHBoYSkgKiB2YWx1ZSwgdmFsdWUsIHZhbHVlID49ICR7dmFsdWVUeXBlfSgwLjApKTtgO1xuICAgICAgICBjYXNlICcnOlxuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgLy8gVE9ETzogYWRkaW5nIG90aGVyIGFjdGl2YXRpb25zIHRoYXQgY2FuIGJlIGZ1c2VkLlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgYWN0aXZhdGlvbiAke2F0dHJpYnV0ZXMuYWN0aXZhdGlvbn1gKTtcbiAgICAgIH1cbiAgICB9O1xuXG5leHBvcnQgY29uc3QgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YSA9XG4gICAgKGF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsIHByb2dyYW1Vbmlmb3JtOiBQcm9ncmFtVW5pZm9ybVtdKSA9PiB7XG4gICAgICBpZiAoYXR0cmlidXRlcy5hY3RpdmF0aW9uID09PSAnQ2xpcCcpIHtcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm0ucHVzaChcbiAgICAgICAgICAgIHt0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5jbGlwTWF4IX0sIHt0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5jbGlwTWluIX0pO1xuICAgICAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLmFjdGl2YXRpb24gPT09ICdIYXJkU2lnbW9pZCcpIHtcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm0ucHVzaChcbiAgICAgICAgICAgIHt0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5hbHBoYSF9LCB7dHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IGF0dHJpYnV0ZXMuYmV0YSF9KTtcbiAgICAgIH0gZWxzZSBpZiAoYXR0cmlidXRlcy5hY3RpdmF0aW9uID09PSAnTGVha3lSZWx1Jykge1xuICAgICAgICBwcm9ncmFtVW5pZm9ybS5wdXNoKHt0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5hbHBoYSF9KTtcbiAgICAgIH1cbiAgICB9O1xuXG5leHBvcnQgY29uc3QgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zID0gKGF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsIHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSkgPT4ge1xuICBpZiAoYXR0cmlidXRlcy5hY3RpdmF0aW9uID09PSAnQ2xpcCcpIHtcbiAgICB1bmlmb3Jtcy5wdXNoKHtuYW1lOiAnY2xpcF9tYXgnLCB0eXBlOiAnZjMyJ30sIHtuYW1lOiAnY2xpcF9taW4nLCB0eXBlOiAnZjMyJ30pO1xuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXMuYWN0aXZhdGlvbiA9PT0gJ0hhcmRTaWdtb2lkJykge1xuICAgIHVuaWZvcm1zLnB1c2goe25hbWU6ICdhbHBoYScsIHR5cGU6ICdmMzInfSwge25hbWU6ICdiZXRhJywgdHlwZTogJ2YzMid9KTtcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLmFjdGl2YXRpb24gPT09ICdMZWFreVJlbHUnKSB7XG4gICAgdW5pZm9ybXMucHVzaCh7bmFtZTogJ2FscGhhJywgdHlwZTogJ2YzMid9KTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyA9XG4gICAgKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+fHVuZGVmaW5lZCk6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMgPT4ge1xuICAgICAgY29uc3QgYWN0aXZhdGlvbiA9IGF0dHJpYnV0ZXM/LmFjdGl2YXRpb24gYXMgc3RyaW5nIHx8ICcnO1xuICAgICAgaWYgKGFjdGl2YXRpb24gPT09ICdIYXJkU2lnbW9pZCcpIHtcbiAgICAgICAgY29uc3QgW2FscGhhLCBiZXRhXSA9IGF0dHJpYnV0ZXM/LmFjdGl2YXRpb25fcGFyYW1zIGFzIFtudW1iZXIsIG51bWJlcl0gfHwgWzAuMiwgMC41XTtcbiAgICAgICAgcmV0dXJuIHthY3RpdmF0aW9uLCBhbHBoYSwgYmV0YX07XG4gICAgICB9IGVsc2UgaWYgKGFjdGl2YXRpb24gPT09ICdDbGlwJykge1xuICAgICAgICBjb25zdCBbY2xpcE1pbiwgY2xpcE1heF0gPSBhdHRyaWJ1dGVzPy5hY3RpdmF0aW9uX3BhcmFtcyBhcyBbbnVtYmVyLCBudW1iZXJdIHx8IFtNSU5fQ0xJUCwgTUFYX0NMSVBdO1xuICAgICAgICByZXR1cm4ge2FjdGl2YXRpb24sIGNsaXBNYXgsIGNsaXBNaW59O1xuICAgICAgfSBlbHNlIGlmIChhY3RpdmF0aW9uID09PSAnTGVha3lSZWx1Jykge1xuICAgICAgICBjb25zdCBbYWxwaGFdID0gYXR0cmlidXRlcz8uYWN0aXZhdGlvbl9wYXJhbXMgYXMgW251bWJlcl0gfHwgWzAuMDFdO1xuICAgICAgICByZXR1cm4ge2FjdGl2YXRpb24sIGFscGhhfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7YWN0aXZhdGlvbn07XG4gICAgfTtcbiIsICIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1iYWNrZW5kLXdlYmdwdS9zcmMvYWN0aXZhdGlvbl91dGlsLnRzXG4vL1xuLy8gbW9kaWZpZWQgdG8gZml0IHRoZSBuZWVkcyBvZiB0aGUgcHJvamVjdFxuXG5leHBvcnQgY29uc3QgdHlwZVNuaXBwZXQgPSAoY29tcG9uZW50OiBudW1iZXIsIGRhdGFUeXBlOiBzdHJpbmcpID0+IHtcbiAgc3dpdGNoIChjb21wb25lbnQpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZGF0YVR5cGU7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGB2ZWMyPCR7ZGF0YVR5cGV9PmA7XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIGB2ZWMzPCR7ZGF0YVR5cGV9PmA7XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIGB2ZWM0PCR7ZGF0YVR5cGV9PmA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb21wb25lbnR9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgYmlhc1NuaXBwZXQgPSAoaGFzQmlhczogYm9vbGVhbik6IHN0cmluZyA9PiBgXG4gICAgICAke2hhc0JpYXMgPyAndmFsdWUgPSB2YWx1ZSArIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMpOycgOiAnJ31cbiAgICAgIGA7XG4iLCAiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vLyBzYW1wbGVkIGZyb20gW0B0ZW5zb3JmbG93L3RmanNdIHRmanMtY29yZS9zcmMvb3BzL2NvbnZfdXRpbC50c1xuLy9cbi8vIG1vZGlmaWVkIHRvIGZpdCB0aGUgbmVlZHMgb2YgdGhlIHByb2plY3RcblxuZXhwb3J0IGNvbnN0IHV0aWxGdW5jdGlvbnMgPSAoc3RyaWRlU3RyOiBzdHJpbmcpID0+IChgXG5mbiBnZXRJbmRleEZyb21Db29yZHM0RChjb29yZHMgOiB2ZWM0PGkzMj4sIHNoYXBlIDogdmVjNDxpMzI+KSAtPiBpMzIge1xuICByZXR1cm4gZG90KGNvb3JkcywgdmVjNDxpMzI+KFxuICAgICAgc2hhcGUueSAqIHNoYXBlLnogKiBzaGFwZS53LCBzaGFwZS56ICogc2hhcGUudywgc2hhcGUudywgMSkpO1xufVxuZm4gZ2V0T3V0cHV0SW5kZXhGcm9tQ29vcmRzKGNvb3JkcyA6IHZlYzQ8aTMyPikgLT4gaTMyIHtcbiAgcmV0dXJuIGRvdChjb29yZHMsIHZlYzQ8aTMyPihcbiAgICBpMzIoJHtzdHJpZGVTdHJ9LngpLCBpMzIoJHtzdHJpZGVTdHJ9LnkpLCBpMzIoJHtzdHJpZGVTdHJ9LnopLCAxKSk7XG59XG5gKTtcbiIsICIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1iYWNrZW5kLXdlYmdwdS9zcmMvbWF0bXVsX3BhY2tlZF93ZWJncHUudHNcbi8vXG4vLyBtb2RpZmllZCB0byBmaXQgdGhlIG5lZWRzIG9mIHRoZSBwcm9qZWN0XG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBnZXRCcm9hZGNhc3REaW1zLCBJbmRpY2VzSGVscGVyLCBpbnB1dFZhcmlhYmxlLCBpbnRlcm5hbFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsIFVuaWZvcm1zQXJyYXlUeXBlfSBmcm9tICcuLi9jb21tb24nO1xuaW1wb3J0IHthcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMsIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEsIGdldEFjdGl2YXRpb25TbmlwcGV0LCBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzfSBmcm9tICcuLi9mdXNlLXV0aWxzJztcblxuaW1wb3J0IHt0eXBlU25pcHBldH0gZnJvbSAnLi9hY3RpdmF0aW9uX3V0aWwnO1xuXG5jb25zdCB3cml0ZURhdGFUb1N1YkFWZWM0U25pcHBldCA9ICh0cmFuc3Bvc2U6IGJvb2xlYW4sIGJhdGNoRGltcz86IEluZGljZXNIZWxwZXIpID0+IHtcbiAgaWYgKHRyYW5zcG9zZSkge1xuICAgIHJldHVybiBgXG4gICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0IC8gaW5uZXJFbGVtZW50U2l6ZSArIGlucHV0Q29sJHtiYXRjaERpbXMgPyAnLCBiYXRjaEluZGljZXMnIDogJyd9KTtcbiAgICAgICAgYDtcblxuICB9IGVsc2Uge1xuICAgIHJldHVybiBgXG4gICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgIGdsb2JhbFJvdyArIGlubmVyUm93LFxuICAgICAgICAgIGtTdGFydCAvIGlubmVyRWxlbWVudFNpemUgKyBpbnB1dENvbCR7YmF0Y2hEaW1zID8gJywgYmF0Y2hJbmRpY2VzJyA6ICcnfSk7XG4gICAgICAgIGA7XG4gIH1cbn07XG5cbmNvbnN0IGNhbGN1bGF0ZVJlc3VsdFNuaXBwZXQgPSAodHJhbnNwb3NlQTogYm9vbGVhbiwgaW5uZXJFbGVtZW50U2l6ZTogbnVtYmVyKSA9PiB7XG4gIGlmICh0cmFuc3Bvc2VBKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgICAgbGV0IEFDYWNoZWQwID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZV1bbG9jYWxSb3ddO1xuICAgICAgICBsZXQgQUNhY2hlZDEgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMV1bbG9jYWxSb3ddO1xuICAgICAgICBsZXQgQUNhY2hlZDIgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMl1bbG9jYWxSb3ddO1xuICAgICAgICAke2lubmVyRWxlbWVudFNpemUgPT09IDMgPyAnJyA6ICdsZXQgQUNhY2hlZDMgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgM11bbG9jYWxSb3ddOyd9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93UGVyVGhyZWFkOyBpID0gaSArIDEpIHtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMCAqIEFDYWNoZWQwW2ldICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQxICogQUNhY2hlZDFbaV0gKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDIgKiBBQ2FjaGVkMltpXSArIGFjY1tpXTtcbiAgICAgICAgICAke2lubmVyRWxlbWVudFNpemUgPT09IDMgPyAnJyA6ICdhY2NbaV0gPSBCQ2FjaGVkMyAqIEFDYWNoZWQzW2ldICsgYWNjW2ldOyd9XG4gICAgICAgIH1gO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93UGVyVGhyZWFkOyBpID0gaSArIDEpIHtcbiAgICAgICAgICBsZXQgQUNhY2hlZCA9IG1tX0FzdWJbdGlsZVJvdyArIGldW2tdO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQwICogQUNhY2hlZC54ICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQxICogQUNhY2hlZC55ICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQyICogQUNhY2hlZC56ICsgYWNjW2ldO1xuICAgICAgICAgICR7aW5uZXJFbGVtZW50U2l6ZSA9PT0gMyA/ICcnIDogJ2FjY1tpXSA9IEJDYWNoZWQzICogQUNhY2hlZC53ICsgYWNjW2ldOyd9XG4gICAgICAgIH1gO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgbWFrZU1hdE11bFBhY2tlZFZlYzRTb3VyY2UgPVxuICAgICh3b3JrUGVyVGhyZWFkOiBudW1iZXJbXSwgd29ya2dyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCB0eXBlID0gJ2YzMicsIGJhdGNoRGltcz86IEluZGljZXNIZWxwZXIsXG4gICAgIHRyYW5zcG9zZUEgPSBmYWxzZSwgdGlsZUlubmVyID0gMzIsIHNwbGl0SyA9IGZhbHNlLCBzcGxpdGVkRGltSW5uZXIgPSAzMik6IHN0cmluZyA9PiB7XG4gICAgICBjb25zdCB0aWxlQU91dGVyID0gd29ya2dyb3VwU2l6ZVsxXSAqIHdvcmtQZXJUaHJlYWRbMV07XG4gICAgICBjb25zdCB0aWxlQk91dGVyID0gd29ya2dyb3VwU2l6ZVswXSAqIHdvcmtQZXJUaHJlYWRbMF07XG4gICAgICBjb25zdCB0aWxlQVdpZHRoID0gdHJhbnNwb3NlQSA/IHRpbGVBT3V0ZXIgOiB0aWxlSW5uZXI7XG4gICAgICBjb25zdCB0aWxlQUhpZ2h0ID0gdHJhbnNwb3NlQSA/IHRpbGVJbm5lciA6IHRpbGVBT3V0ZXI7XG4gICAgICBjb25zdCBpbm5lckVsZW1lbnRTaXplID0gdGlsZUFXaWR0aCAvIHdvcmtncm91cFNpemVbMF07XG4gICAgICBjb25zdCByb3dQZXJUaHJlYWRCID0gdGlsZUlubmVyIC8gd29ya2dyb3VwU2l6ZVsxXTtcblxuICAgICAgaWYgKCEoKCh0cmFuc3Bvc2VBICYmIGlubmVyRWxlbWVudFNpemUgPT09IDQgJiYgd29ya1BlclRocmVhZFsxXSA9PT0gNCkgfHxcbiAgICAgICAgICAgICAoIXRyYW5zcG9zZUEgJiYgKGlubmVyRWxlbWVudFNpemUgPT09IDMgfHwgaW5uZXJFbGVtZW50U2l6ZSA9PT0gNCkpKSAmJlxuICAgICAgICAgICAgdGlsZUFXaWR0aCAlIHdvcmtncm91cFNpemVbMF0gPT09IDAgJiYgdGlsZUlubmVyICUgd29ya2dyb3VwU2l6ZVsxXSA9PT0gMCAmJiB3b3JrUGVyVGhyZWFkWzBdID09PSA0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElmIHRyYW5zcG9zZUEgJHt0cmFuc3Bvc2VBfSBpcyB0cnVlLCBpbm5lckVsZW1lbnRTaXplICR7XG4gICAgICAgICAgICBpbm5lckVsZW1lbnRTaXplfSBhbmQgd29ya1BlclRocmVhZFsxXSAke3dvcmtQZXJUaHJlYWRbMV19IG11c3QgYmUgNC5cbiAgICAgIE90aGVyd2lzZSwgaW5uZXJFbGVtZW50U2l6ZSAke2lubmVyRWxlbWVudFNpemV9IG11c3QgYmUgMyBvciA0LlxuICB0aWxlQVdpZHRoICR7dGlsZUFXaWR0aH0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVswXSR7d29ya2dyb3VwU2l6ZVswXX0uIHRpbGVJbm5lciAke1xuICAgICAgICAgICAgdGlsZUlubmVyfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdICR7d29ya2dyb3VwU2l6ZVsxXX0uIGNvbFBlclRocmVhZCAke1xuICAgICAgICAgICAgd29ya1BlclRocmVhZFswXX0gbXVzdCBiZSA0LmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGBcbnZhcjx3b3JrZ3JvdXA+IG1tX0FzdWI6IGFycmF5PGFycmF5PHZlYyR7aW5uZXJFbGVtZW50U2l6ZX08JHt0eXBlfT4sICR7dGlsZUFXaWR0aCAvIGlubmVyRWxlbWVudFNpemV9PiwgJHt0aWxlQUhpZ2h0fT47XG52YXI8d29ya2dyb3VwPiBtbV9Cc3ViOiBhcnJheTxhcnJheTx2ZWM0PCR7dHlwZX0+LCAke3RpbGVCT3V0ZXIgLyB3b3JrUGVyVGhyZWFkWzBdfT4sICR7dGlsZUlubmVyfT47XG5cbmNvbnN0IHJvd1BlclRocmVhZCA9ICR7d29ya1BlclRocmVhZFsxXX07XG5jb25zdCBjb2xQZXJUaHJlYWQgPSAke3dvcmtQZXJUaHJlYWRbMF19O1xuY29uc3QgaW5uZXJFbGVtZW50U2l6ZSA9ICR7aW5uZXJFbGVtZW50U2l6ZX07XG5jb25zdCB0aWxlSW5uZXIgPSAke3RpbGVJbm5lcn07XG5cbkBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3dvcmtncm91cFNpemVbMF19LCAke3dvcmtncm91cFNpemVbMV19LCAke3dvcmtncm91cFNpemVbMl19KVxuZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwSWQgOiB2ZWMzPHUzMj4pIHtcbiAgbGV0IGxvY2FsUm93ID0gaTMyKGxvY2FsSWQueSk7XG4gIGxldCB0aWxlUm93ID0gbG9jYWxSb3cgKiByb3dQZXJUaHJlYWQ7XG4gIGxldCB0aWxlQ29sID0gaTMyKGxvY2FsSWQueCk7XG5cbiAgbGV0IGdsb2JhbFJvdyA9aTMyKGdsb2JhbElkLnkpICogcm93UGVyVGhyZWFkO1xuICBsZXQgZ2xvYmFsQ29sID0gaTMyKGdsb2JhbElkLngpO1xuICBsZXQgYmF0Y2ggPSAke3NwbGl0SyA/ICcwJyA6ICdpMzIoZ2xvYmFsSWQueiknfTtcbiAgJHtiYXRjaERpbXMgPyBgbGV0IGJhdGNoSW5kaWNlcyA9ICR7YmF0Y2hEaW1zLm9mZnNldFRvSW5kaWNlcygndTMyKGJhdGNoKScpfTtgIDogJyd9XG4gIGxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7dGlsZUFPdXRlcn07XG5cbiAgbGV0IG51bV90aWxlcyA9ICR7c3BsaXRLID8gYCR7TWF0aC5jZWlsKHNwbGl0ZWREaW1Jbm5lciAvIHRpbGVJbm5lcil9YCA6ICcodW5pZm9ybXMuZGltX2lubmVyIC0gMSkgLyB0aWxlSW5uZXIgKyAxJ307XG4gIHZhciBrU3RhcnQgPSAke3NwbGl0SyA/IGBpMzIoZ2xvYmFsSWQueikgKiAke3NwbGl0ZWREaW1Jbm5lcn1gIDogJzAnfTtcblxuICB2YXIgYWNjOiBhcnJheTx2ZWM0PCR7dHlwZX0+LCByb3dQZXJUaHJlYWQ+O1xuXG4gIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuICBsZXQgdGlsZVJvd0IgPSBsb2NhbFJvdyAqICR7cm93UGVyVGhyZWFkQn07XG4gIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtX3RpbGVzOyB0ID0gdCArIDEpIHtcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvdyArIGlubmVyUm93O1xuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XG4gICAgICAgICAgJHt3cml0ZURhdGFUb1N1YkFWZWM0U25pcHBldCh0cmFuc3Bvc2VBLCBiYXRjaERpbXMpfVxuICAgICAgfVxuXG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHtyb3dQZXJUaHJlYWRCfTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QiArIGlubmVyUm93O1xuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XG4gICAgICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsIGtTdGFydCArIGlucHV0Um93LCBnbG9iYWxDb2wke1xuICAgICAgICAgIGJhdGNoRGltcyA/ICcsIGJhdGNoSW5kaWNlcycgOiAnJ30pO1xuICAgICAgfVxuICAgICAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyIC8gaW5uZXJFbGVtZW50U2l6ZTsgayA9IGsgKyAxKSB7XG4gICAgICAgICAgbGV0IEJDYWNoZWQwID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZV1bdGlsZUNvbF07XG4gICAgICAgICAgbGV0IEJDYWNoZWQxID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDFdW3RpbGVDb2xdO1xuICAgICAgICAgIGxldCBCQ2FjaGVkMiA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAyXVt0aWxlQ29sXTtcbiAgICAgICAgICAke2lubmVyRWxlbWVudFNpemUgPT09IDMgPyAnJyA6ICdsZXQgQkNhY2hlZDMgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgM11bdGlsZUNvbF07J31cblxuICAgICAgICAgICR7Y2FsY3VsYXRlUmVzdWx0U25pcHBldCh0cmFuc3Bvc2VBLCBpbm5lckVsZW1lbnRTaXplKX1cbiAgICAgIH1cblxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICB9XG5cbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgIG1tX3dyaXRlKGJhdGNoLCBnbG9iYWxSb3cgKyBpbm5lclJvdywgZ2xvYmFsQ29sLCBhY2NbaW5uZXJSb3ddKTtcbiAgfVxufWA7XG4gICAgfTtcblxuY29uc3Qgd3JpdGVEYXRhVG9TdWJBU25pcHBldCA9ICh0cmFuc3Bvc2U6IGJvb2xlYW4sIGJhdGNoRGltcz86IEluZGljZXNIZWxwZXIpID0+IHtcbiAgaWYgKHRyYW5zcG9zZSkge1xuICAgIHJldHVybiBgXG4gICAgICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0ICsgaW5wdXRDb2wke2JhdGNoRGltcyA/ICcsIGJhdGNoSW5kaWNlcycgOiAnJ30pO1xuICAgICAgICAgICAgYDtcblxuICB9IGVsc2Uge1xuICAgIHJldHVybiBgXG4gICAgICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICAgICAgZ2xvYmFsUm93U3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRDb2wke2JhdGNoRGltcyA/ICcsIGJhdGNoSW5kaWNlcycgOiAnJ30pO1xuICAgICAgICAgICAgYDtcbiAgfVxufTtcblxuY29uc3QgcmVhZERhdGFGcm9tU3ViQVNuaXBwZXQgPSAodHJhbnNwb3NlQTogYm9vbGVhbikgPT5cbiAgICB0cmFuc3Bvc2VBID8gJ2xldCBBQ2FjaGVkID0gbW1fQXN1YltrXVt0aWxlUm93ICsgaW5uZXJSb3ddOycgOiAnbGV0IEFDYWNoZWQgPSBtbV9Bc3ViW3RpbGVSb3cgKyBpbm5lclJvd11ba107JztcblxuLy8gc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkcyBtZWFucyBzZXF1ZW50aWFsIGRhdGEgaW4gbWVtb3J5IGlzIGFjY2Vzc2VkIGJ5XG4vLyB0aHJlYWRzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHRocmVhZCAoZGVmYXVsdCBiZWhhdmlvcikuXG5leHBvcnQgY29uc3QgbWFrZU1hdE11bFBhY2tlZFNvdXJjZSA9XG4gICAgKHdvcmtQZXJUaHJlYWQ6IG51bWJlcltdLCB3b3JrZ3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIHR5cGUgPSAnZjMyJywgYmF0Y2hEaW1zPzogSW5kaWNlc0hlbHBlcixcbiAgICAgdHJhbnNwb3NlQSA9IGZhbHNlLCB0aWxlSW5uZXIgPSAzMiwgc3BsaXRLID0gZmFsc2UsIHNwbGl0ZWREaW1Jbm5lciA9IDMyLFxuICAgICBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzID0gZmFsc2UpOiBzdHJpbmcgPT4ge1xuICAgICAgY29uc3QgdGlsZUFPdXRlciA9IHdvcmtQZXJUaHJlYWRbMV0gKiB3b3JrZ3JvdXBTaXplWzFdO1xuICAgICAgY29uc3QgdGlsZUJPdXRlciA9IHdvcmtQZXJUaHJlYWRbMF0gKiB3b3JrZ3JvdXBTaXplWzBdO1xuICAgICAgY29uc3QgdGlsZUFXaWR0aCA9IHRyYW5zcG9zZUEgPyB0aWxlQU91dGVyIDogdGlsZUlubmVyO1xuICAgICAgY29uc3QgdGlsZUFIaWdodCA9IHRyYW5zcG9zZUEgPyB0aWxlSW5uZXIgOiB0aWxlQU91dGVyO1xuXG4gICAgICBpZiAoISh0aWxlQUhpZ2h0ICUgd29ya2dyb3VwU2l6ZVsxXSA9PT0gMCAmJiB0aWxlQVdpZHRoICUgd29ya2dyb3VwU2l6ZVswXSA9PT0gMCAmJlxuICAgICAgICAgICAgdGlsZUlubmVyICUgd29ya2dyb3VwU2l6ZVsxXSA9PT0gMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0aWxlQUhpZ2h0ICR7dGlsZUFIaWdodH0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSR7XG4gICAgICAgICAgICB3b3JrZ3JvdXBTaXplWzFdfSwgdGlsZUFXaWR0aCAke3RpbGVBV2lkdGh9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMF0ke1xuICAgICAgICAgICAgd29ya2dyb3VwU2l6ZVswXX0sIHRpbGVJbm5lciAke3RpbGVJbm5lcn0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSR7d29ya2dyb3VwU2l6ZVsxXX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJvd1BlclRocmVhZEEgPSB0aWxlQUhpZ2h0IC8gd29ya2dyb3VwU2l6ZVsxXTtcbiAgICAgIGNvbnN0IGNvbFBlclRocmVhZEEgPSB0aWxlQVdpZHRoIC8gd29ya2dyb3VwU2l6ZVswXTtcbiAgICAgIGNvbnN0IHJvd1BlclRocmVhZEIgPSB0aWxlSW5uZXIgLyB3b3JrZ3JvdXBTaXplWzFdO1xuICAgICAgY29uc3QgbWF0bXVsU25pcHBldCA9IHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHMgP1xuICAgICAgICAgIGBcbiAgICBsZXQgbG9jYWxSb3cgPSBpMzIobG9jYWxJZC55KTtcbiAgICBsZXQgbG9jYWxDb2wgPSBpMzIobG9jYWxJZC54KTtcbiAgICBsZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke3RpbGVBT3V0ZXJ9O1xuICAgIGxldCBnbG9iYWxDb2xTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC54KSAqICR7dGlsZUJPdXRlcn07XG5cbiAgICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bV90aWxlczsgdCA9IHQgKyAxKSB7XG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbnB1dFJvdyA9IGxvY2FsUm93OyBpbnB1dFJvdyA8ICR7dGlsZUFIaWdodH07IGlucHV0Um93ID0gaW5wdXRSb3cgKyAke3dvcmtncm91cFNpemVbMV19KSB7XG4gICAgICAgIGZvciAodmFyIGlucHV0Q29sID0gbG9jYWxDb2w7IGlucHV0Q29sIDwgJHt0aWxlQVdpZHRofTsgaW5wdXRDb2wgPSBpbnB1dENvbCArICR7d29ya2dyb3VwU2l6ZVswXX0pIHtcbiAgICAgICAgICAke3dyaXRlRGF0YVRvU3ViQVNuaXBwZXQodHJhbnNwb3NlQSwgYmF0Y2hEaW1zKX1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgZm9yICh2YXIgaW5wdXRSb3cgPSBsb2NhbFJvdzsgaW5wdXRSb3cgPCAke3RpbGVJbm5lcn07IGlucHV0Um93ID0gaW5wdXRSb3cgKyAke3dvcmtncm91cFNpemVbMV19KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpbnB1dENvbCA9IGxvY2FsQ29sOyBpbnB1dENvbCA8ICR7dGlsZUJPdXRlcn07IGlucHV0Q29sID0gaW5wdXRDb2wgKyAke3dvcmtncm91cFNpemVbMF19KSB7XG4gICAgICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsXG4gICAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICAgIGdsb2JhbENvbFN0YXJ0ICsgaW5wdXRDb2wke2JhdGNoRGltcyA/ICcsIGJhdGNoSW5kaWNlcycgOiAnJ30pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxuICAgICAgdmFyIEJDYWNoZWQgOiBhcnJheTwke3R5cGV9LCBjb2xQZXJUaHJlYWQ+O1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXI7IGsgPSBrICsgMSkge1xuICAgICAgICBmb3IgKHZhciBpbm5lciA9IDA7IGlubmVyIDwgY29sUGVyVGhyZWFkOyBpbm5lciA9IGlubmVyICsgMSkge1xuICAgICAgICAgIEJDYWNoZWRbaW5uZXJdID0gbW1fQnN1YltrXVtsb2NhbENvbCArIGlubmVyICogJHt3b3JrZ3JvdXBTaXplWzBdfV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgICBsZXQgQUNhY2hlZCA9ICR7XG4gICAgICAgICAgICAgIHRyYW5zcG9zZUEgPyBgbW1fQXN1YltrXVtsb2NhbFJvdyArIGlubmVyUm93ICogJHt3b3JrZ3JvdXBTaXplWzFdfV07YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBgbW1fQXN1Yltsb2NhbFJvdyArIGlubmVyUm93ICogJHt3b3JrZ3JvdXBTaXplWzFdfV1ba107YH1cbiAgICAgICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0gPSBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSArXG4gICAgICAgICAgICAgICAgQUNhY2hlZCAqIEJDYWNoZWRbaW5uZXJDb2xdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgbGV0IGdSb3cgPSBnbG9iYWxSb3dTdGFydCArIGxvY2FsUm93ICsgaW5uZXJSb3cgKiAke3dvcmtncm91cFNpemVbMV19O1xuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgICAgbGV0IGdDb2wgPSBnbG9iYWxDb2xTdGFydCArIGxvY2FsQ29sICsgaW5uZXJDb2wgKiAke3dvcmtncm91cFNpemVbMF19O1xuICAgICAgICBtbV93cml0ZShiYXRjaCwgZ1JvdywgZ0NvbCwgYWNjW2lubmVyUm93XVtpbm5lckNvbF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBgIDpcbiAgICAgICAgICBgXG5sZXQgdGlsZVJvdyA9IGkzMihsb2NhbElkLnkpICogcm93UGVyVGhyZWFkO1xubGV0IHRpbGVDb2wgPSBpMzIobG9jYWxJZC54KSAqIGNvbFBlclRocmVhZDtcblxubGV0IGdsb2JhbFJvdyA9IGkzMihnbG9iYWxJZC55KSAqIHJvd1BlclRocmVhZDtcbmxldCBnbG9iYWxDb2wgPSBpMzIoZ2xvYmFsSWQueCkgKiBjb2xQZXJUaHJlYWQ7XG5sZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke3RpbGVBT3V0ZXJ9O1xuXG5sZXQgdGlsZVJvd0EgPSBpMzIobG9jYWxJZC55KSAqICR7cm93UGVyVGhyZWFkQX07XG5sZXQgdGlsZUNvbEEgPSBpMzIobG9jYWxJZC54KSAqICR7Y29sUGVyVGhyZWFkQX07XG5sZXQgdGlsZVJvd0IgPSBpMzIobG9jYWxJZC55KSAqICR7cm93UGVyVGhyZWFkQn07XG4vLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbmZvciAodmFyIHQgPSAwOyB0IDwgbnVtX3RpbGVzOyB0ID0gdCArIDEpIHtcbiAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHtyb3dQZXJUaHJlYWRBfTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgJHtjb2xQZXJUaHJlYWRBfTsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dBICsgaW5uZXJSb3c7XG4gICAgICBsZXQgaW5wdXRDb2wgPSB0aWxlQ29sQSArIGlubmVyQ29sO1xuICAgICAgJHt3cml0ZURhdGFUb1N1YkFTbmlwcGV0KHRyYW5zcG9zZUEsIGJhdGNoRGltcyl9XG4gICAgfVxuICB9XG5cbiAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHtyb3dQZXJUaHJlYWRCfTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0IgKyBpbm5lclJvdztcbiAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2wgKyBpbm5lckNvbDtcbiAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLFxuICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgZ2xvYmFsQ29sICsgaW5uZXJDb2wke2JhdGNoRGltcyA/ICcsIGJhdGNoSW5kaWNlcycgOiAnJ30pO1xuICAgIH1cbiAgfVxuICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XG4gIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cbiAgdmFyIEJDYWNoZWQgOiBhcnJheTwke3R5cGV9LCBjb2xQZXJUaHJlYWQ+O1xuICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lcjsgayA9IGsgKyAxKSB7XG4gICAgZm9yICh2YXIgaW5uZXIgPSAwOyBpbm5lciA8IGNvbFBlclRocmVhZDsgaW5uZXIgPSBpbm5lciArIDEpIHtcbiAgICAgIEJDYWNoZWRbaW5uZXJdID0gbW1fQnN1YltrXVt0aWxlQ29sICsgaW5uZXJdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAke3JlYWREYXRhRnJvbVN1YkFTbmlwcGV0KHRyYW5zcG9zZUEpfVxuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0gPSBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSArIEFDYWNoZWQgKiBCQ2FjaGVkW2lubmVyQ29sXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG59XG5cbmZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgbW1fd3JpdGUoYmF0Y2gsIGdsb2JhbFJvdyArIGlubmVyUm93LCBnbG9iYWxDb2wgKyBpbm5lckNvbCxcbiAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0pO1xuICB9XG59XG5gO1xuXG4gICAgICByZXR1cm4gYFxuICB2YXI8d29ya2dyb3VwPiBtbV9Bc3ViIDogYXJyYXk8YXJyYXk8JHt0eXBlfSwgJHt0aWxlQVdpZHRofT4sICR7dGlsZUFIaWdodH0+O1xuICB2YXI8d29ya2dyb3VwPiBtbV9Cc3ViIDogYXJyYXk8YXJyYXk8JHt0eXBlfSwgJHt0aWxlQk91dGVyfT4sICR7dGlsZUlubmVyfT47XG4gIGNvbnN0IHJvd1BlclRocmVhZCA9ICR7d29ya1BlclRocmVhZFsxXX07XG4gIGNvbnN0IGNvbFBlclRocmVhZCA9ICR7d29ya1BlclRocmVhZFswXX07XG4gIGNvbnN0IHRpbGVJbm5lciA9ICR7dGlsZUlubmVyfTtcblxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7d29ya2dyb3VwU2l6ZVswXX0sICR7d29ya2dyb3VwU2l6ZVsxXX0sICR7d29ya2dyb3VwU2l6ZVsyXX0pXG5mbiBtYWluKEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBJZCA6IHZlYzM8dTMyPikge1xuICAgIGxldCBiYXRjaCA9ICR7c3BsaXRLID8gJzAnIDogJ2kzMihnbG9iYWxJZC56KSd9O1xuICAgICR7YmF0Y2hEaW1zID8gYGxldCBiYXRjaEluZGljZXMgPSAke2JhdGNoRGltcy5vZmZzZXRUb0luZGljZXMoJ3UzMihiYXRjaCknKX07YCA6ICcnfVxuICAgIGxldCBudW1fdGlsZXMgPSAke1xuICAgICAgICAgIHNwbGl0SyA/IGAke01hdGguY2VpbChzcGxpdGVkRGltSW5uZXIgLyB0aWxlSW5uZXIpfWAgOiAnKHVuaWZvcm1zLmRpbV9pbm5lciAtIDEpIC8gdGlsZUlubmVyICsgMSd9O1xuICAgIHZhciBrU3RhcnQgPSAke3NwbGl0SyA/IGBpMzIoZ2xvYmFsSWQueikgKiAke3NwbGl0ZWREaW1Jbm5lcn1gIDogJzAnfTtcblxuICAgIHZhciBhY2MgOiBhcnJheTxhcnJheTwke3R5cGV9LCBjb2xQZXJUaHJlYWQ+LCByb3dQZXJUaHJlYWQ+O1xuXG4gICAgLy8gV2l0aG91dCB0aGlzIGluaXRpYWxpemF0aW9uIHN0cmFuZ2UgdmFsdWVzIHNob3cgdXAgaW4gYWNjLlxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IDAuMDtcbiAgICAgIH1cbiAgICB9XG4gICAgJHttYXRtdWxTbmlwcGV0fVxuICB9XG5gO1xuICAgIH07XG5cbmNvbnN0IG1hdE11bFJlYWRXcml0ZUZuU291cmNlID1cbiAgICAoY29tcG9uZW50OiBudW1iZXIsIGhhc0JpYXM6IGJvb2xlYW4sIGFwcGx5QWN0aXZhdGlvbjogc3RyaW5nLCB2YXJpYWJsZXM6IEluZGljZXNIZWxwZXJbXSxcbiAgICAgYmF0Y2hTaGFwZXM6IEFycmF5PHJlYWRvbmx5IG51bWJlcltdPiwgaXNDaGFubmVsc0xhc3QgPSBmYWxzZSk6IHN0cmluZyA9PiB7XG4gICAgICBjb25zdCBbYmF0Y2hBU2hhcGUsIGJhdGNoQlNoYXBlLCBiYXRjaFNoYXBlXSA9IGJhdGNoU2hhcGVzO1xuICAgICAgY29uc3QgW2JhdGNoVmFyaWFibGUsIGFWYXJpYWJsZSwgYlZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZV0gPSB2YXJpYWJsZXM7XG4gICAgICBjb25zdCBicm9hZENhc3RBRGltcyA9IGdldEJyb2FkY2FzdERpbXMoYmF0Y2hBU2hhcGUsIGJhdGNoU2hhcGUpO1xuICAgICAgY29uc3QgYnJvYWRDYXN0QkRpbXMgPSBnZXRCcm9hZGNhc3REaW1zKGJhdGNoQlNoYXBlLCBiYXRjaFNoYXBlKTtcbiAgICAgIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKHZhcmlhYmxlc1swXS50eXBlLnRlbnNvcik7XG4gICAgICBjb25zdCBnZXRBSW5kaWNlcyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgYVJhbmsgPSBhVmFyaWFibGUucmFuaztcbiAgICAgICAgY29uc3QgYmF0Y2hSYW5rID0gYmF0Y2hWYXJpYWJsZS5yYW5rO1xuICAgICAgICBsZXQgcmVzU3RyID0gYHZhciBhSW5kaWNlczogJHthVmFyaWFibGUudHlwZS5pbmRpY2VzfTtgO1xuICAgICAgICBmb3IgKGxldCBpID0gYVJhbmsgLSAyIC0gMSwgaiA9IGJhdGNoUmFuayAtIDE7IGkgPj0gMDsgaS0tLCBqLS0pIHtcbiAgICAgICAgICByZXNTdHIgKz0gYFxcbmFJbmRpY2VzWyR7aX1dID0gJHtiYXRjaFJhbmsgPiAxID8gYGJhdGNoSW5kaWNlc1ske2p9XWAgOiAnYmF0Y2hJbmRpY2VzJ307YDtcbiAgICAgICAgfVxuICAgICAgICBicm9hZENhc3RBRGltcy5mb3JFYWNoKGkgPT4ge1xuICAgICAgICAgIHJlc1N0ciArPSBgXFxuYUluZGljZXNbJHtpfV0gPSAwO2A7XG4gICAgICAgIH0pO1xuICAgICAgICByZXNTdHIgKz0gYFxcbmFJbmRpY2VzWyR7YVJhbmsgLSAyfV0gPSB1MzIocm93KTtcbiAgICAgICAgICAgICAgICAgICBhSW5kaWNlc1ske2FSYW5rIC0gMX1dID0gdTMyKGNvbEluKTtgO1xuICAgICAgICByZXR1cm4gcmVzU3RyO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGdldEJJbmRpY2VzID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBiUmFuayA9IGJWYXJpYWJsZS5yYW5rO1xuICAgICAgICBjb25zdCBiYXRjaFJhbmsgPSBiYXRjaFZhcmlhYmxlLnJhbms7XG4gICAgICAgIGxldCByZXNTdHIgPSBgdmFyIGJJbmRpY2VzOiAke2JWYXJpYWJsZS50eXBlLmluZGljZXN9O2A7XG4gICAgICAgIGZvciAobGV0IGkgPSBiUmFuayAtIDIgLSAxLCBqID0gYmF0Y2hSYW5rIC0gMTsgaSA+PSAwOyBpLS0sIGotLSkge1xuICAgICAgICAgIHJlc1N0ciArPSBgXFxuYkluZGljZXNbJHtpfV0gPSAke2JhdGNoUmFuayA+IDEgPyBgYmF0Y2hJbmRpY2VzWyR7an1dYCA6ICdiYXRjaEluZGljZXMnfTtgO1xuICAgICAgICB9XG4gICAgICAgIGJyb2FkQ2FzdEJEaW1zLmZvckVhY2goaSA9PiB7XG4gICAgICAgICAgcmVzU3RyICs9IGBcXG5iSW5kaWNlc1ske2l9XSA9IDA7YDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc1N0ciArPSBgXFxuYkluZGljZXNbJHtiUmFuayAtIDJ9XSA9IHUzMihyb3cpO1xuICAgICAgICAgICAgICAgICAgIGJJbmRpY2VzWyR7YlJhbmsgLSAxfV0gPSB1MzIoY29sSW4pO2A7XG4gICAgICAgIHJldHVybiByZXNTdHI7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc291cmNlID0gYFxuICAgIGZuIG1tX3JlYWRBKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCBiYXRjaEluZGljZXM6ICR7YmF0Y2hWYXJpYWJsZS50eXBlLmluZGljZXN9KSAtPiAke1xuICAgICAgICAgIHR5cGVTbmlwcGV0KGNvbXBvbmVudCwgZGF0YVR5cGUpfSB7XG4gICAgICB2YXIgdmFsdWUgPSAke3R5cGVTbmlwcGV0KGNvbXBvbmVudCwgZGF0YVR5cGUpfSgwLjApO1xuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtjb21wb25lbnR9O1xuICAgICAgaWYocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2lubmVyKVxuICAgICAge1xuICAgICAgICAke2dldEFJbmRpY2VzKCl9XG4gICAgICAgIHZhbHVlID0gJHthVmFyaWFibGUuZ2V0QnlJbmRpY2VzKCdhSW5kaWNlcycpfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmbiBtbV9yZWFkQihiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgYmF0Y2hJbmRpY2VzOiAke2JhdGNoVmFyaWFibGUudHlwZS5pbmRpY2VzfSkgLT4gJHtcbiAgICAgICAgICB0eXBlU25pcHBldChjb21wb25lbnQsIGRhdGFUeXBlKX0ge1xuICAgICAgdmFyIHZhbHVlID0gJHt0eXBlU25pcHBldChjb21wb25lbnQsIGRhdGFUeXBlKX0oMC4wKTtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7Y29tcG9uZW50fTtcbiAgICAgIGlmKHJvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcilcbiAgICAgIHtcbiAgICAgICAgJHtnZXRCSW5kaWNlcygpfVxuICAgICAgICB2YWx1ZSA9ICR7YlZhcmlhYmxlLmdldEJ5SW5kaWNlcygnYkluZGljZXMnKX07XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIHZhbHVlSW46ICR7dHlwZVNuaXBwZXQoY29tcG9uZW50LCBkYXRhVHlwZSl9KSB7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2NvbXBvbmVudH07XG4gICAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbjtcbiAgICAgICAgbGV0IGNvb3JkcyA9IHZlYzM8aTMyPihiYXRjaCwgcm93LCBjb2xJbik7XG4gICAgICAgICR7XG4gICAgICAgICAgaGFzQmlhcyA/XG4gICAgICAgICAgICAgIGB2YWx1ZSA9IHZhbHVlICsgJHtpc0NoYW5uZWxzTGFzdCA/ICdiaWFzW2NvbEluXScgOiBgJHt0eXBlU25pcHBldChjb21wb25lbnQsIGRhdGFUeXBlKX0oYmlhc1tyb3ddKWB9O2AgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgJHthcHBseUFjdGl2YXRpb259XG4gICAgICAgICR7b3V0cHV0VmFyaWFibGUuc2V0QnlJbmRpY2VzKCd2ZWMzPHUzMj4oY29vcmRzKScsICd2YWx1ZScpfVxuICAgICAgfVxuICAgIH1cbiAgICBgO1xuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm8gPVxuICAgIChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYWN0aXZhdGlvbkF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgcmVzaGFwZWRPdXRwdXRTaGFwZT86IHJlYWRvbmx5IG51bWJlcltdLFxuICAgICBpc0NoYW5uZWxzTGFzdCA9IGZhbHNlIC8qIG9ubHkgdXNlZCBmb3IgY29udjJkQnlNYXRNdWwqLyk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGFTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICAgICAgY29uc3QgYlNoYXBlID0gaW5wdXRzWzFdLmRpbXM7XG4gICAgICBjb25zdCBvdXRlckRpbXNBID0gYVNoYXBlLnNsaWNlKDAsIC0yKTtcbiAgICAgIGNvbnN0IG91dGVyRGltc0IgPSBiU2hhcGUuc2xpY2UoMCwgLTIpO1xuICAgICAgY29uc3Qgb3V0ZXJEaW1zID0gcmVzaGFwZWRPdXRwdXRTaGFwZSA/IHJlc2hhcGVkT3V0cHV0U2hhcGUuc2xpY2UoMCwgLTIpIDogb3V0cHV0U2hhcGUuc2xpY2UoMCwgLTIpO1xuICAgICAgY29uc3QgYmF0Y2hTaXplID0gU2hhcGVVdGlsLnNpemUob3V0ZXJEaW1zKTtcbiAgICAgIGNvbnN0IGRpbUFPdXRlciA9IGFTaGFwZVthU2hhcGUubGVuZ3RoIC0gMl07XG4gICAgICBjb25zdCBkaW1Jbm5lciA9IGFTaGFwZVthU2hhcGUubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCBkaW1CT3V0ZXIgPSBiU2hhcGVbYlNoYXBlLmxlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgaXNWZWM0ID0gZGltSW5uZXIgJSA0ID09PSAwICYmIGRpbUJPdXRlciAlIDQgPT09IDA7XG5cbiAgICAgIC8vIFRPRE86IGZpbmUgdHVuZSBzaXplXG4gICAgICBjb25zdCBlbGVtZW50c1BlclRocmVhZCA9IGRpbUFPdXRlciA8PSA4ID8gWzQsIDEsIDFdIDogWzQsIDQsIDFdO1xuICAgICAgY29uc3Qgd29ya2dyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzgsIDgsIDFdO1xuICAgICAgY29uc3QgZGlzcGF0Y2ggPSBbXG4gICAgICAgIE1hdGguY2VpbChkaW1CT3V0ZXIgLyB3b3JrZ3JvdXBTaXplWzBdIC8gZWxlbWVudHNQZXJUaHJlYWRbMF0pLFxuICAgICAgICBNYXRoLmNlaWwoZGltQU91dGVyIC8gd29ya2dyb3VwU2l6ZVsxXSAvIGVsZW1lbnRzUGVyVGhyZWFkWzFdKSxcbiAgICAgICAgTWF0aC5jZWlsKGJhdGNoU2l6ZSAvIHdvcmtncm91cFNpemVbMl0gLyBlbGVtZW50c1BlclRocmVhZFsyXSlcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBpc1ZlYzQgPyA0IDogMTtcbiAgICAgIGNvbnN0IGFTaGFwZVRlbXAgPSBbLi4ub3V0ZXJEaW1zQSwgZGltQU91dGVyLCBkaW1Jbm5lciAvIGNvbXBvbmVudHNdO1xuICAgICAgY29uc3QgYVJhbmsgPSBhU2hhcGVUZW1wLmxlbmd0aDtcbiAgICAgIGNvbnN0IGJTaGFwZVRlbXAgPSBbLi4ub3V0ZXJEaW1zQiwgZGltSW5uZXIsIGRpbUJPdXRlciAvIGNvbXBvbmVudHNdO1xuICAgICAgY29uc3QgYlJhbmsgPSBiU2hhcGVUZW1wLmxlbmd0aDtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlVGVtcCA9IFtiYXRjaFNpemUsIGRpbUFPdXRlciwgZGltQk91dGVyIC8gY29tcG9uZW50c107XG4gICAgICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZGltQU91dGVyfSwge3R5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBkaW1CT3V0ZXJ9LFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGRpbUlubmVyfVxuICAgICAgXTtcbiAgICAgIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEoYWN0aXZhdGlvbkF0dHJpYnV0ZXMsIHByb2dyYW1Vbmlmb3Jtcyk7XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRlckRpbXMsIGFTaGFwZVRlbXAsIGJTaGFwZVRlbXApKTtcbiAgICAgIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWydyYW5rJywgJ3JhbmsnXTtcblxuICAgICAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPiAyO1xuICAgICAgaWYgKGhhc0JpYXMpIHtcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzJdLmRpbXMpKTtcbiAgICAgICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgncmFuaycpO1xuICAgICAgfVxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGVUZW1wKSk7XG5cbiAgICAgIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgICAgICBjb25zdCBiYXRjaFJhbmsgPSBvdXRlckRpbXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBiYXRjaERpbXMgPSBpbnRlcm5hbFZhcmlhYmxlKCdiYXRjaERpbXMnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGJhdGNoUmFuaywgMSk7XG4gICAgICAgIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0c1swXS5kYXRhVHlwZSk7XG5cbiAgICAgICAgY29uc3QgQSA9IGlucHV0VmFyaWFibGUoJ2EnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGFSYW5rLCBjb21wb25lbnRzKTtcbiAgICAgICAgY29uc3QgQiA9IGlucHV0VmFyaWFibGUoJ2InLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGJSYW5rLCBjb21wb25lbnRzKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ3Jlc3VsdCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGVUZW1wLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgICAgIGNvbnN0IGlucHV0VmFyaWFibGVzID0gW0EsIEJdO1xuICAgICAgICBpZiAoaGFzQmlhcykge1xuICAgICAgICAgIGNvbnN0IGJpYXNDb21wb25lbnRzID0gaXNDaGFubmVsc0xhc3QgPyBjb21wb25lbnRzIDogMTtcbiAgICAgICAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCwgYmlhc0NvbXBvbmVudHMpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPVxuICAgICAgICAgICAgW3tuYW1lOiAnZGltX2Ffb3V0ZXInLCB0eXBlOiAnaTMyJ30sIHtuYW1lOiAnZGltX2Jfb3V0ZXInLCB0eXBlOiAnaTMyJ30sIHtuYW1lOiAnZGltX2lubmVyJywgdHlwZTogJ2kzMid9XTtcbiAgICAgICAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zKGFjdGl2YXRpb25BdHRyaWJ1dGVzLCB1bmlmb3Jtcyk7XG4gICAgICAgIGNvbnN0IGJhc2VUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKG91dHB1dC50eXBlLnRlbnNvcik7XG4gICAgICAgIGNvbnN0IGFwcGx5QWN0aXZhdGlvbiA9IGdldEFjdGl2YXRpb25TbmlwcGV0KGFjdGl2YXRpb25BdHRyaWJ1dGVzLCBvdXRwdXQudHlwZS52YWx1ZSwgYmFzZVR5cGUpO1xuICAgICAgICBjb25zdCBkZWNsYXJlRnVuY3Rpb25zID0gbWF0TXVsUmVhZFdyaXRlRm5Tb3VyY2UoXG4gICAgICAgICAgICBjb21wb25lbnRzLCBoYXNCaWFzLCBhcHBseUFjdGl2YXRpb24sIFtiYXRjaERpbXMsIEEsIEIsIG91dHB1dF0sIFtvdXRlckRpbXNBLCBvdXRlckRpbXNCLCBvdXRlckRpbXNdLFxuICAgICAgICAgICAgaXNDaGFubmVsc0xhc3QpO1xuICAgICAgICByZXR1cm4gYFxuICAke1xuICAgICAgICAgICAgc2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoYmF0Y2hEaW1zKS5kZWNsYXJlVmFyaWFibGVzKFxuICAgICAgICAgICAgICAgIC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfVxuICAke2RlY2xhcmVGdW5jdGlvbnN9XG4gICR7XG4gICAgICAgICAgICBpc1ZlYzQgPyBtYWtlTWF0TXVsUGFja2VkVmVjNFNvdXJjZShlbGVtZW50c1BlclRocmVhZCwgd29ya2dyb3VwU2l6ZSwgZGF0YVR5cGUsIGJhdGNoRGltcykgOlxuICAgICAgICAgICAgICAgICAgICAgbWFrZU1hdE11bFBhY2tlZFNvdXJjZShlbGVtZW50c1BlclRocmVhZCwgd29ya2dyb3VwU2l6ZSwgZGF0YVR5cGUsIGJhdGNoRGltcyl9XG4gICAgICAgICAgICAgICAgICAgYDtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnTWF0TXVsJyxcbiAgICAgICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgICAgICBoaW50OiBgJHtlbGVtZW50c1BlclRocmVhZH07JHthY3RpdmF0aW9uQXR0cmlidXRlcy5hY3RpdmF0aW9ufTske2lzVmVjNH07JHtpc0NoYW5uZWxzTGFzdH1gLFxuICAgICAgICAgIGlucHV0RGVwZW5kZW5jaWVzXG4gICAgICAgIH0sXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX1dLFxuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBkaXNwYXRjaFswXSwgeTogZGlzcGF0Y2hbMV0sIHo6IGRpc3BhdGNoWzJdfSxcbiAgICAgICAgICBwcm9ncmFtVW5pZm9ybXNcbiAgICAgICAgfSksXG4gICAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICAgIH07XG4gICAgfTtcbiIsICIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1iYWNrZW5kLXdlYmdwdS9zcmMvY29udjJkX21tX3dlYmdwdS50c1xuLy9cbi8vIG1vZGlmaWVkIHRvIGZpdCB0aGUgbmVlZHMgb2YgdGhlIHByb2plY3RcblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtMT0dfREVCVUd9IGZyb20gJy4uLy4uLy4uL2xvZyc7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybX0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciwgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLCBVbmlmb3Jtc0FycmF5VHlwZX0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7Q29udkF0dHJpYnV0ZXN9IGZyb20gJy4uL2NvbnYnO1xuaW1wb3J0IHthcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMsIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEsIGdldEFjdGl2YXRpb25TbmlwcGV0fSBmcm9tICcuLi9mdXNlLXV0aWxzJztcblxuaW1wb3J0IHtiaWFzU25pcHBldCwgdHlwZVNuaXBwZXR9IGZyb20gJy4vYWN0aXZhdGlvbl91dGlsJztcbmltcG9ydCB7dXRpbEZ1bmN0aW9uc30gZnJvbSAnLi9jb252X3V0aWwnO1xuaW1wb3J0IHttYWtlTWF0TXVsUGFja2VkU291cmNlLCBtYWtlTWF0TXVsUGFja2VkVmVjNFNvdXJjZX0gZnJvbSAnLi9tYXRtdWxfcGFja2VkX3dlYmdwdSc7XG5cbmNvbnN0IGNvbnYyZENvbW1vblNuaXBwZXQgPVxuICAgIChpc0NoYW5uZWxzTGFzdDogYm9vbGVhbiwgZml0QU91dGVyOiBib29sZWFuLCBmaXRCT3V0ZXI6IGJvb2xlYW4sIGZpdElubmVyOiBib29sZWFuLCBhZGRCaWFzID0gZmFsc2UsXG4gICAgIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLCBpbm5lckVsZW1lbnRTaXplWCA9IDQsIGlubmVyRWxlbWVudFNpemVXID0gNCwgaW5uZXJFbGVtZW50U2l6ZSA9IDQsXG4gICAgIGRhdGFUeXBlID0gJ2YzMicpOiBzdHJpbmcgPT4ge1xuICAgICAgY29uc3QgZ2V0WFNuaXBwZXQgPSAoaW5uZXJFbGVtZW50U2l6ZTogbnVtYmVyKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoaW5uZXJFbGVtZW50U2l6ZSkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiAncmVzRGF0YSA9IHhbeEluZGV4XTsnO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBgcmVzRGF0YSA9IHZlYzM8JHtkYXRhVHlwZX0+KHhbeEluZGV4XSwgeFt4SW5kZXggKyAxXSwgeFt4SW5kZXggKyAyXSk7YDtcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gJ3Jlc0RhdGEgPSB4W3hJbmRleCAvIDRdOyc7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke2lubmVyRWxlbWVudFNpemV9IGlzIG5vdCBzdXBwb3J0ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBnZXRXU25pcHBldCA9IChpbm5lckVsZW1lbnRTaXplOiBudW1iZXIpID0+IHtcbiAgICAgICAgc3dpdGNoIChpbm5lckVsZW1lbnRTaXplKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuICdyZXR1cm4gd1tyb3cgKiBpMzIodW5pZm9ybXMud19zaGFwZVszXSkgKyBjb2xJbl07JztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gJ3JldHVybiB3W3JvdyAqIGkzMih1bmlmb3Jtcy53X3NoYXBlWzNdKSAvIDQgKyBjb2xJbl07JztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7aW5uZXJFbGVtZW50U2l6ZX0gaXMgbm90IHN1cHBvcnRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNvb3JkQVNuaXBwZXQgPSBpc0NoYW5uZWxzTGFzdCA/IGBcbiAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhSb3csIHhDb2wsIHhDaCk7XG4gICAgYCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXG4gICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCB4Q2gsIHhSb3csIHhDb2wpO1xuICAgIGA7XG5cbiAgICAgIGNvbnN0IGNvb3JkUmVzU25pcHBldCA9IGlzQ2hhbm5lbHNMYXN0ID8gYFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXG4gICAgICBiYXRjaCxcbiAgICAgIHJvdyAvIG91dFdpZHRoLFxuICAgICAgcm93ICUgb3V0V2lkdGgsXG4gICAgICBjb2wpO1xuICAgIGAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcbiAgICAgIGJhdGNoLFxuICAgICAgcm93LFxuICAgICAgY29sIC8gb3V0V2lkdGgsXG4gICAgICBjb2wgJSBvdXRXaWR0aCk7XG4gICAgYDtcblxuICAgICAgY29uc3QgeEhlaWdodCA9IGlzQ2hhbm5lbHNMYXN0ID8gJ2kzMih1bmlmb3Jtcy54X3NoYXBlWzFdKScgOiAnaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pJztcbiAgICAgIGNvbnN0IHhXaWR0aCA9IGlzQ2hhbm5lbHNMYXN0ID8gJ2kzMih1bmlmb3Jtcy54X3NoYXBlWzJdKScgOiAnaTMyKHVuaWZvcm1zLnhfc2hhcGVbM10pJztcbiAgICAgIGNvbnN0IHJvdyA9IGlzQ2hhbm5lbHNMYXN0ID8gJ3JvdycgOiAnY29sJztcbiAgICAgIGNvbnN0IGNvbCA9IGlzQ2hhbm5lbHNMYXN0ID8gJ2NvbCcgOiAncm93JztcbiAgICAgIGNvbnN0IHJlYWRYU25pcHBldCA9IGBcbiAgICBsZXQgaW5DaGFubmVscyA9IGkzMih1bmlmb3Jtcy53X3NoYXBlWzJdKTtcbiAgICBsZXQgb3V0V2lkdGggPSAke2lzQ2hhbm5lbHNMYXN0ID8gJ2kzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbMl0pJyA6ICdpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzNdKSd9O1xuICAgIGxldCBvdXRSb3cgPSAke3Jvd30gLyBvdXRXaWR0aDtcbiAgICBsZXQgb3V0Q29sID0gJHtyb3d9ICUgb3V0V2lkdGg7XG5cbiAgICBsZXQgV1JvdyA9ICR7Y29sfSAvIChpMzIodW5pZm9ybXMud19zaGFwZVsxXSkgKiBpbkNoYW5uZWxzKTtcbiAgICBsZXQgV0NvbCA9ICR7Y29sfSAvIGluQ2hhbm5lbHMgJSBpMzIodW5pZm9ybXMud19zaGFwZVsxXSk7XG4gICAgbGV0IHhSb3cgPSBvdXRSb3cgKiB1bmlmb3Jtcy5zdHJpZGVbMF0gKyB1bmlmb3Jtcy5kaWxhdGlvblswXSAqIFdSb3cgLSB1bmlmb3Jtcy5wYWRbMF07XG4gICAgbGV0IHhDb2wgPSBvdXRDb2wgKiB1bmlmb3Jtcy5zdHJpZGVbMV0gKyB1bmlmb3Jtcy5kaWxhdGlvblsxXSAqIFdDb2wgLSB1bmlmb3Jtcy5wYWRbMV07XG4gICAgbGV0IHhDaCA9ICR7Y29sfSAlIGluQ2hhbm5lbHM7XG4gICAgdmFyIHJlc0RhdGEgPSAke3R5cGVTbmlwcGV0KGlubmVyRWxlbWVudFNpemVYLCBkYXRhVHlwZSl9KDAuMCk7XG4gICAgLy8gVGhlIGJvdW5kcyBjaGVja2luZyBpcyBhbHdheXMgbmVlZGVkIHNpbmNlIHdlIHVzZSBpdCB0byBwYWQgemVybyBmb3JcbiAgICAvLyB0aGUgJ3NhbWUnIHBhZGRpbmcgdHlwZS5cbiAgICBpZiAoeFJvdyA+PSAwICYmIHhSb3cgPCAke3hIZWlnaHR9ICYmIHhDb2wgPj0gMCAmJiB4Q29sIDwgJHt4V2lkdGh9KSB7XG4gICAgICAke2Nvb3JkQVNuaXBwZXR9XG4gICAgICBsZXQgeEluZGV4ID0gZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQsIHZlYzQ8aTMyPih1bmlmb3Jtcy54X3NoYXBlKSk7XG4gICAgICAke2dldFhTbmlwcGV0KGlubmVyRWxlbWVudFNpemVYKX1cbiAgICB9XG4gICAgcmV0dXJuIHJlc0RhdGE7YDtcblxuICAgICAgY29uc3Qgc2FtcGxlWCA9IGlzQ2hhbm5lbHNMYXN0ID8gKGZpdEFPdXRlciAmJiBmaXRJbm5lciA/IGBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2lubmVyRWxlbWVudFNpemVYfTtcbiAgICAke3JlYWRYU25pcHBldH1gIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtpbm5lckVsZW1lbnRTaXplWH07XG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9pbm5lcikge1xuICAgICAgJHtyZWFkWFNuaXBwZXR9XG4gICAgfVxuICAgIHJldHVybiAke3R5cGVTbmlwcGV0KGlubmVyRWxlbWVudFNpemVYLCBkYXRhVHlwZSl9KDAuMCk7YCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZpdElubmVyICYmIGZpdEJPdXRlciA/IGBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2lubmVyRWxlbWVudFNpemVYfTtcbiAgICAke3JlYWRYU25pcHBldH1gIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtpbm5lckVsZW1lbnRTaXplWH07XG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcikge1xuICAgICAgJHtyZWFkWFNuaXBwZXR9XG4gICAgfVxuICAgIHJldHVybiAke3R5cGVTbmlwcGV0KGlubmVyRWxlbWVudFNpemVYLCBkYXRhVHlwZSl9KDAuMCk7YCk7XG5cbiAgICAgIGNvbnN0IHNhbXBsZVcgPSBgJHtnZXRXU25pcHBldChpbm5lckVsZW1lbnRTaXplVyl9YDtcblxuICAgICAgY29uc3QgcmVzVHlwZSA9IHR5cGVTbmlwcGV0KGlubmVyRWxlbWVudFNpemUsIGRhdGFUeXBlKTtcbiAgICAgIGNvbnN0IGFUeXBlID1cbiAgICAgICAgICBpc0NoYW5uZWxzTGFzdCA/IHR5cGVTbmlwcGV0KGlubmVyRWxlbWVudFNpemVYLCBkYXRhVHlwZSkgOiB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplVywgZGF0YVR5cGUpO1xuICAgICAgY29uc3QgYlR5cGUgPVxuICAgICAgICAgIGlzQ2hhbm5lbHNMYXN0ID8gdHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVcsIGRhdGFUeXBlKSA6IHR5cGVTbmlwcGV0KGlubmVyRWxlbWVudFNpemVYLCBkYXRhVHlwZSk7XG4gICAgICBjb25zdCBhcHBseUFjdGl2YXRpb24gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhdHRyaWJ1dGVzLCByZXNUeXBlLCBkYXRhVHlwZSk7XG4gICAgICBjb25zdCB1c2VyQ29kZSA9IGBcbiAgICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke2FUeXBlfSB7XG4gICAgICAke2lzQ2hhbm5lbHNMYXN0ID8gc2FtcGxlWCA6IHNhbXBsZVd9XG4gICAgfVxuXG4gICAgZm4gbW1fcmVhZEIoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMikgLT4gJHtiVHlwZX0ge1xuICAgICAgJHtpc0NoYW5uZWxzTGFzdCA/IHNhbXBsZVcgOiBzYW1wbGVYfVxuICAgIH1cblxuICAgIGZuIG1tX3dyaXRlKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIsIHZhbHVlSW4gOiAke3Jlc1R5cGV9KSB7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2lubmVyRWxlbWVudFNpemV9O1xuICAgICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKVxuICAgICAge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbjtcbiAgICAgIGxldCBvdXRXaWR0aCA9ICR7aXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsyXSknIDogJ2kzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbM10pJ307XG4gICAgICAke2Nvb3JkUmVzU25pcHBldH1cbiAgICAgICR7Ymlhc1NuaXBwZXQoYWRkQmlhcyl9XG4gICAgICAke2FwcGx5QWN0aXZhdGlvbn1cbiAgICAgIHNldE91dHB1dEF0Q29vcmRzKGNvb3Jkc1swXSwgY29vcmRzWzFdLCBjb29yZHNbMl0sIGNvb3Jkc1szXSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1gO1xuICAgICAgcmV0dXJuIHVzZXJDb2RlO1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVDb252MkRNYXRNdWxQcm9ncmFtSW5mbyA9XG4gICAgKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcywgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBkaW1BT3V0ZXI6IG51bWJlcixcbiAgICAgZGltQk91dGVyOiBudW1iZXIsIGRpbUlubmVyOiBudW1iZXIsIGhhc0JpYXM6IGJvb2xlYW4sIHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHM6IGJvb2xlYW4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gICAgICBjb25zdCBpbkNoYW5uZWxzID0gaXNDaGFubmVsc0xhc3QgPyBpbnB1dHNbMF0uZGltc1szXSA6IGlucHV0c1swXS5kaW1zWzFdO1xuICAgICAgY29uc3QgYmF0Y2hTaXplID0gb3V0cHV0U2hhcGVbMF07XG4gICAgICBjb25zdCBvdXRXaWR0aCA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0cHV0U2hhcGVbMl0gOiBvdXRwdXRTaGFwZVszXTtcbiAgICAgIGNvbnN0IG91dEhlaWdodCA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0cHV0U2hhcGVbMV0gOiBvdXRwdXRTaGFwZVsyXTtcbiAgICAgIGNvbnN0IG91dENoYW5uZWxzID0gaXNDaGFubmVsc0xhc3QgPyBvdXRwdXRTaGFwZVszXSA6IG91dHB1dFNoYXBlWzFdO1xuICAgICAgLy8gVE9ETzogZW5hYmxlIHZlYzQgZm9yIE5DSFdcbiAgICAgIGNvbnN0IGlzVmVjNCA9IGlzQ2hhbm5lbHNMYXN0ICYmIChpbkNoYW5uZWxzICUgNCA9PT0gMCB8fCBpbkNoYW5uZWxzICUgMyA9PT0gMCkgJiYgb3V0Q2hhbm5lbHMgJSA0ID09PSAwO1xuXG4gICAgICAvLyBUT0RPOiBmaW5lIHR1bmUgc2l6ZVxuICAgICAgY29uc3QgZGlzcGF0Y2hYID0gaXNDaGFubmVsc0xhc3QgPyBvdXRDaGFubmVscyA6IG91dFdpZHRoICogb3V0SGVpZ2h0O1xuICAgICAgY29uc3QgZGlzcGF0Y2hZID0gaXNDaGFubmVsc0xhc3QgPyBvdXRXaWR0aCAqIG91dEhlaWdodCA6IG91dENoYW5uZWxzO1xuICAgICAgY29uc3Qgd29ya0dyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzgsIDgsIDFdO1xuICAgICAgY29uc3QgZWxlbWVudHNQZXJUaHJlYWQgPSBkaW1BT3V0ZXIgPD0gOCA/IFs0LCAxLCAxXSA6IFs0LCA0LCAxXTtcbiAgICAgIGNvbnN0IGRpc3BhdGNoID0gW1xuICAgICAgICBNYXRoLmNlaWwoZGlzcGF0Y2hYIC8gd29ya0dyb3VwU2l6ZVswXSAvIGVsZW1lbnRzUGVyVGhyZWFkWzBdKSxcbiAgICAgICAgTWF0aC5jZWlsKGRpc3BhdGNoWSAvIHdvcmtHcm91cFNpemVbMV0gLyBlbGVtZW50c1BlclRocmVhZFsxXSksXG4gICAgICAgIE1hdGguY2VpbChiYXRjaFNpemUgLyB3b3JrR3JvdXBTaXplWzJdIC8gZWxlbWVudHNQZXJUaHJlYWRbMl0pXG4gICAgICBdO1xuXG4gICAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW2NvbnYyZF9tbV93ZWJncHVdIGRpc3BhdGNoID0gJHtkaXNwYXRjaH1gKTtcblxuICAgICAgY29uc3QgaW5uZXJFbGVtZW50U2l6ZSA9IGlzVmVjNCA/IChpc0NoYW5uZWxzTGFzdCAmJiBpbkNoYW5uZWxzICUgNCAhPT0gMCA/IDMgOiA0KSA6IDE7XG4gICAgICBjb25zdCB0aWxlQU91dGVyID0gd29ya0dyb3VwU2l6ZVsxXSAqIGVsZW1lbnRzUGVyVGhyZWFkWzFdO1xuICAgICAgY29uc3QgdGlsZUJPdXRlciA9IHdvcmtHcm91cFNpemVbMF0gKiBlbGVtZW50c1BlclRocmVhZFswXTtcbiAgICAgIGNvbnN0IHRpbGVJbm5lciA9IE1hdGgubWF4KHdvcmtHcm91cFNpemVbMF0gKiBpbm5lckVsZW1lbnRTaXplLCB3b3JrR3JvdXBTaXplWzFdKTtcbiAgICAgIGNvbnN0IGZpdEFPdXRlciA9IGRpbUFPdXRlciAlIHRpbGVBT3V0ZXIgPT09IDA7XG4gICAgICBjb25zdCBmaXRCT3V0ZXIgPSBkaW1CT3V0ZXIgJSB0aWxlQk91dGVyID09PSAwO1xuICAgICAgY29uc3QgZml0SW5uZXIgPSBkaW1Jbm5lciAlIHRpbGVJbm5lciA9PT0gMDtcbiAgICAgIGNvbnN0IGVsZW1lbnRzU2l6ZSA9IGlzVmVjNCA/IFtpbm5lckVsZW1lbnRTaXplLCA0LCA0XSA6IFsxLCAxLCAxXTtcblxuICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgICAgICB7dHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGRpbUFPdXRlcn0sIHt0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZGltQk91dGVyfSxcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBkaW1Jbm5lcn0sIHt0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogW2F0dHJpYnV0ZXMucGFkc1swXSwgYXR0cmlidXRlcy5wYWRzWzFdXX0sXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogYXR0cmlidXRlcy5zdHJpZGVzfSwge3R5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBhdHRyaWJ1dGVzLmRpbGF0aW9uc31cbiAgICAgIF07XG4gICAgICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhKGF0dHJpYnV0ZXMsIHByb2dyYW1Vbmlmb3Jtcyk7XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgaW5wdXRzWzFdLmRpbXMpKTtcbiAgICAgIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWydyYW5rJywgJ3JhbmsnXTtcbiAgICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1syXS5kaW1zKSk7XG4gICAgICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3JhbmsnKTtcbiAgICAgIH1cbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSk7XG5cbiAgICAgIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgICAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICAgICAge25hbWU6ICdkaW1fYV9vdXRlcicsIHR5cGU6ICdpMzInfSwge25hbWU6ICdkaW1fYl9vdXRlcicsIHR5cGU6ICdpMzInfSwge25hbWU6ICdkaW1faW5uZXInLCB0eXBlOiAnaTMyJ30sXG4gICAgICAgICAge25hbWU6ICdwYWQnLCB0eXBlOiAnaTMyJywgbGVuZ3RoOiAyfSwge25hbWU6ICdzdHJpZGUnLCB0eXBlOiAnaTMyJywgbGVuZ3RoOiAyfSxcbiAgICAgICAgICB7bmFtZTogJ2RpbGF0aW9uJywgdHlwZTogJ2kzMicsIGxlbmd0aDogMn1cbiAgICAgICAgXTtcbiAgICAgICAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zKGF0dHJpYnV0ZXMsIHVuaWZvcm1zKTtcblxuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGNvbXBvbmVudCAyLCAzLlxuICAgICAgICBjb25zdCBjb21wb25lbnRzID0gaXNWZWM0ID8gNCA6IDE7XG4gICAgICAgIGNvbnN0IHQgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgICAgICAgbGV0IGRlY2xhcmVGdW5jdGlvbnMgPSBgXG4gICAgICBmbiBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCA6IGkzMiwgdmFsdWUgOiAke2lzVmVjNCA/IGB2ZWM0PCR7dH0+YCA6IHR9KSB7XG4gICAgICAgIHJlc3VsdFtmbGF0SW5kZXhdID0gJHtpc1ZlYzQgPyBgdmVjNDwke3R9PmAgOiB0fSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBmbiBzZXRPdXRwdXRBdENvb3JkcyhkMCA6IGkzMiwgZDEgOiBpMzIsIGQyIDogaTMyLCBkMyA6IGkzMiwgdmFsdWUgOiAke2lzVmVjNCA/IGB2ZWM0PCR7dH0+YCA6IHR9KSB7XG4gICAgICAgIGxldCBmbGF0SW5kZXggPSBnZXRPdXRwdXRJbmRleEZyb21Db29yZHModmVjNDxpMzI+KGQwLCBkMSwgZDIsIGQzKSk7XG4gICAgICAgIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4ICR7aXNWZWM0ID8gJy8gNCcgOiAnJ30sIHZhbHVlKTtcbiAgICAgIH1gO1xuICAgICAgICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZShcbiAgICAgICAgICAgICd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgsIGlubmVyRWxlbWVudFNpemUgPT09IDMgPyAxIDogaW5uZXJFbGVtZW50U2l6ZSk7XG4gICAgICAgIGNvbnN0IHcgPSBpbnB1dFZhcmlhYmxlKCd3JywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcy5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgICAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFt4LCB3XTtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ3Jlc3VsdCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICAgICAgaWYgKGhhc0JpYXMpIHtcbiAgICAgICAgICBjb25zdCBiaWFzID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICAgICAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKGJpYXMpO1xuICAgICAgICAgIGRlY2xhcmVGdW5jdGlvbnMgKz0gYFxuICAgICAgICBmbiBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiAke2lzVmVjNCA/IGB2ZWM0PCR7dH0+YCA6IHR9IHtcbiAgICAgICAgICByZXR1cm4gYmlhc1tjb29yZHMuJHtpc0NoYW5uZWxzTGFzdCA/ICd3JyA6ICd5J30ke2lzVmVjNCA/ICcvIDQnIDogJyd9XTtcbiAgICAgICAgfWA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYFxuICAgICAgICAke3V0aWxGdW5jdGlvbnMoJ3VuaWZvcm1zLnJlc3VsdF9zdHJpZGVzJyl9XG4gICAgICAgIC8vc3RydWN0IFVuaWZvcm1zIHsgeFNoYXBlIDogdmVjNDxpMzI+LCB3U2hhcGUgOiB2ZWM0PGkzMj4sIG91dFNoYXBlIDogdmVjNDxpMzI+LFxuICAgICAgICAvLyAgb3V0U2hhcGVTdHJpZGVzOiB2ZWMzPGkzMj4sIGZpbHRlckRpbXMgOiB2ZWMyPGkzMj4sIHBhZCA6IHZlYzI8aTMyPiwgc3RyaWRlIDogdmVjMjxpMzI+LFxuICAgICAgICAvLyAgZGlsYXRpb24gOiB2ZWMyPGkzMj4sIGRpbUFPdXRlciA6IGkzMiwgZGltQk91dGVyIDogaTMyLCBkaW1Jbm5lciA6IGkzMiB9O1xuICAgICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfVxuICAgICAgICAke2RlY2xhcmVGdW5jdGlvbnN9XG4gICAgICAgICR7XG4gICAgICAgICAgICBjb252MmRDb21tb25TbmlwcGV0KFxuICAgICAgICAgICAgICAgIGlzQ2hhbm5lbHNMYXN0LCBmaXRBT3V0ZXIsIGZpdEJPdXRlciwgZml0SW5uZXIsIGhhc0JpYXMsIGF0dHJpYnV0ZXMsIGVsZW1lbnRzU2l6ZVswXSwgZWxlbWVudHNTaXplWzFdLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzU2l6ZVsyXSwgdCl9XG4gICAgICAgICR7XG4gICAgICAgICAgICBpc1ZlYzQgP1xuICAgICAgICAgICAgICAgIG1ha2VNYXRNdWxQYWNrZWRWZWM0U291cmNlKGVsZW1lbnRzUGVyVGhyZWFkLCB3b3JrR3JvdXBTaXplLCB0LCB1bmRlZmluZWQsICFpc0NoYW5uZWxzTGFzdCwgdGlsZUlubmVyKSA6XG4gICAgICAgICAgICAgICAgbWFrZU1hdE11bFBhY2tlZFNvdXJjZShcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNQZXJUaHJlYWQsIHdvcmtHcm91cFNpemUsIHQsIHVuZGVmaW5lZCwgIWlzQ2hhbm5lbHNMYXN0LCB0aWxlSW5uZXIsIGZhbHNlLCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHMpfWA7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ0NvbnYyRE1hdE11bCcsXG4gICAgICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICAgICAgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX07JHtpbm5lckVsZW1lbnRTaXplfTske2lzVmVjNH07JHtmaXRBT3V0ZXJ9OyR7Zml0Qk91dGVyfTske2ZpdElubmVyfTske1xuICAgICAgICAgICAgICB0aWxlQU91dGVyfTske3RpbGVCT3V0ZXJ9OyR7dGlsZUlubmVyfWAsXG4gICAgICAgICAgaW5wdXREZXBlbmRlbmNpZXNcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgICBvdXRwdXRzOiBbe2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlfV0sXG4gICAgICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IGRpc3BhdGNoWzBdLCB5OiBkaXNwYXRjaFsxXSwgejogZGlzcGF0Y2hbMl19LFxuICAgICAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICAgICAgfSksXG4gICAgICAgIGdldFNoYWRlclNvdXJjZVxuICAgICAgfTtcbiAgICB9O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7UHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBnZXRNYXhDb21wb25lbnRzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsIFVuaWZvcm1zQXJyYXlUeXBlfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQge2NhbGN1bGF0ZU91dHB1dFNoYXBlLCBDb252QXR0cmlidXRlc30gZnJvbSAnLi9jb252JztcbmltcG9ydCB7YXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zLCBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhLCBnZXRBY3RpdmF0aW9uU25pcHBldH0gZnJvbSAnLi9mdXNlLXV0aWxzJztcblxuLyoqXG4gKiBuYWl2ZSBncm91cGVkIGNvbnYgaW1wbGVtZW50YXRpb24sIHN1cHBvcnRzIDFkLzJkIGNvbnZcbiAqIEBwYXJhbSBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbiAtIGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIHNxdWVlemUgdGhlIG91dHB1dCBzaGFwZSwgb25seSB1c2VkIGluIGNvbnYxZFxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlR3JvdXBlZENvbnZQcm9ncmFtSW5mbyA9XG4gICAgKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyxcbiAgICAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24/OiAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBudW1iZXJbXSk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID4gMjtcbiAgICAgIGNvbnN0IHByb2Nlc3NCaWFzID0gaGFzQmlhcyA/ICd2YWx1ZSArPSBiW291dHB1dF9jaGFubmVsXTsnIDogJyc7XG4gICAgICBjb25zdCB4U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICAgIGNvbnN0IHdTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuICAgICAgY29uc3Qgb3V0cHV0Q2hhbm5lbHNQZXJHcm91cCA9IHdTaGFwZVswXSAvIGF0dHJpYnV0ZXMuZ3JvdXA7XG5cbiAgICAgIGNvbnN0IGlzQ2hhbm5lbExhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBjYWxjdWxhdGVPdXRwdXRTaGFwZShcbiAgICAgICAgICB4U2hhcGUsIHdTaGFwZSwgYXR0cmlidXRlcy5kaWxhdGlvbnMsIGF0dHJpYnV0ZXMucGFkcywgYXR0cmlidXRlcy5zdHJpZGVzLCBpc0NoYW5uZWxMYXN0KTtcbiAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG5cbiAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZX0sIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuZGlsYXRpb25zfSxcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogW2F0dHJpYnV0ZXMuc3RyaWRlc1swXSwgYXR0cmlidXRlcy5zdHJpZGVzWzFdXX0sXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IFthdHRyaWJ1dGVzLnBhZHNbMF0sIGF0dHJpYnV0ZXMucGFkc1sxXV19LFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRDaGFubmVsc1Blckdyb3VwfVxuICAgICAgXTtcbiAgICAgIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEoYXR0cmlidXRlcywgcHJvZ3JhbVVuaWZvcm1zKTtcbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKHhTaGFwZSwgd1NoYXBlKSk7XG4gICAgICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuaycsICdyYW5rJ107XG4gICAgICBpZiAoaGFzQmlhcykge1xuICAgICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMl0uZGltcykpO1xuICAgICAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCdyYW5rJyk7XG4gICAgICB9XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSkpO1xuXG4gICAgICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgYmFzZVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUob3V0cHV0LnR5cGUudGVuc29yKTtcbiAgICAgICAgY29uc3QgYXBwbHlBY3RpdmF0aW9uID0gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYXR0cmlidXRlcywgb3V0cHV0LnR5cGUudmFsdWUsIGJhc2VUeXBlKTtcbiAgICAgICAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoJ3gnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIHhTaGFwZS5sZW5ndGgpO1xuICAgICAgICBjb25zdCB3ID0gaW5wdXRWYXJpYWJsZSgndycsIGlucHV0c1sxXS5kYXRhVHlwZSwgd1NoYXBlLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGlucHV0VmFycyA9IFt4LCB3XTtcbiAgICAgICAgaWYgKGhhc0JpYXMpIHtcbiAgICAgICAgICBpbnB1dFZhcnMucHVzaChpbnB1dFZhcmlhYmxlKCdiJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgICAgICB7bmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ2RpbGF0aW9ucycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGF0dHJpYnV0ZXMuZGlsYXRpb25zLmxlbmd0aH0sXG4gICAgICAgICAge25hbWU6ICdzdHJpZGVzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogMn0sIHtuYW1lOiAncGFkcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IDJ9LFxuICAgICAgICAgIHtuYW1lOiAnb3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cCcsIHR5cGU6ICd1MzInfVxuICAgICAgICBdO1xuICAgICAgICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMoYXR0cmlidXRlcywgdW5pZm9ybXMpO1xuICAgICAgICByZXR1cm4gYFxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFycywgb3V0cHV0KX1cblxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuXG4gICAgbGV0IG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgbGV0IGJhdGNoOiB1MzIgPSBvdXRwdXRJbmRpY2VzWzBdO1xuICAgIGxldCBvdXRwdXRfY2hhbm5lbDogdTMyID0gb3V0cHV0SW5kaWNlc1ske2lzQ2hhbm5lbExhc3QgPyAzIDogMX1dO1xuICAgIGxldCB4UkNDb3JuZXI6IHZlYzI8dTMyPiA9IHZlYzI8dTMyPihvdXRwdXRJbmRpY2VzWyR7aXNDaGFubmVsTGFzdCA/IDEgOiAyfV0sIG91dHB1dEluZGljZXNbJHtcbiAgICAgICAgICAgIGlzQ2hhbm5lbExhc3QgPyAyIDogM31dKSAqIHVuaWZvcm1zLnN0cmlkZXMgLSB1bmlmb3Jtcy5wYWRzO1xuICAgIGxldCBncm91cF9pZDogdTMyID0gb3V0cHV0X2NoYW5uZWwgLyB1bmlmb3Jtcy5vdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xuXG4gICAgdmFyIHZhbHVlOiAke291dHB1dC50eXBlLnZhbHVlfSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDApO1xuICAgIGZvciAodmFyIHdJbkNoYW5uZWw6IHUzMiA9IDB1OyB3SW5DaGFubmVsIDwgdW5pZm9ybXMud19zaGFwZVsxXTsgd0luQ2hhbm5lbCsrKSB7XG4gICAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IGdyb3VwX2lkICogdW5pZm9ybXMud19zaGFwZVsxXSArIHdJbkNoYW5uZWw7XG4gICAgICBmb3IgKHZhciB3SGVpZ2h0OiB1MzIgPSAwdTsgd0hlaWdodCA8IHVuaWZvcm1zLndfc2hhcGVbMl07IHdIZWlnaHQrKykge1xuICAgICAgICBsZXQgeEhlaWdodCA9IHhSQ0Nvcm5lci54ICsgd0hlaWdodCAqIHVuaWZvcm1zLmRpbGF0aW9uc1swXTtcblxuICAgICAgICBpZiAoeEhlaWdodCA8IDB1IHx8IHhIZWlnaHQgPj0gdW5pZm9ybXMueF9zaGFwZVske2lzQ2hhbm5lbExhc3QgPyAxIDogMn1dKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciB3V2lkdGg6IHUzMiA9IDB1OyB3V2lkdGggPCB1bmlmb3Jtcy53X3NoYXBlWzNdOyB3V2lkdGgrKykge1xuICAgICAgICAgIGxldCB4V2lkdGggPSB4UkNDb3JuZXIueSArIHdXaWR0aCAqIHVuaWZvcm1zLmRpbGF0aW9uc1sxXTtcbiAgICAgICAgICBpZiAoeFdpZHRoIDwgMHUgfHwgeFdpZHRoID49IHVuaWZvcm1zLnhfc2hhcGVbJHtpc0NoYW5uZWxMYXN0ID8gMiA6IDN9XSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHhWYWwgPSAke1xuICAgICAgICAgICAgaXNDaGFubmVsTGFzdCA/IHguZ2V0KCdiYXRjaCcsICd4SGVpZ2h0JywgJ3hXaWR0aCcsICdpbnB1dF9jaGFubmVsJykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHguZ2V0KCdiYXRjaCcsICdpbnB1dF9jaGFubmVsJywgJ3hIZWlnaHQnLCAneFdpZHRoJyl9O1xuICAgICAgICAgIGxldCB3VmFsID0gJHt3LmdldCgnb3V0cHV0X2NoYW5uZWwnLCAnd0luQ2hhbm5lbCcsICd3SGVpZ2h0JywgJ3dXaWR0aCcpfTtcbiAgICAgICAgICB2YWx1ZSArPSB4VmFsKndWYWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgJHtwcm9jZXNzQmlhc31cbiAgICAke2FwcGx5QWN0aXZhdGlvbn1cbiAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpfVxuICB9YDtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnR3JvdXBlZENvbnYnLFxuICAgICAgICBzaGFkZXJDYWNoZToge2hpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksIGlucHV0RGVwZW5kZW5jaWVzfSxcbiAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgICBvdXRwdXRzOiBbe1xuICAgICAgICAgICAgZGltczogc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24gPyBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbihvdXRwdXRTaGFwZSkgOiBvdXRwdXRTaGFwZSxcbiAgICAgICAgICAgIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGVcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgICAgIHByb2dyYW1Vbmlmb3Jtc1xuICAgICAgICB9KSxcbiAgICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgICAgfTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlR3JvdXBlZENvbnZWZWN0b3JpemVQcm9ncmFtSW5mbyA9XG4gICAgKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcywgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPiAyO1xuICAgICAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMob3V0cHV0U2hhcGVbM10pO1xuICAgICAgY29uc3Qgb3V0cHV0TnVtYmVyID0gZ2V0TWF4Q29tcG9uZW50cyhvdXRwdXRTaGFwZVsyXSk7XG4gICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gY29tcG9uZW50cyAvIG91dHB1dE51bWJlcjtcbiAgICAgIGNvbnN0IHhTaGFwZSA9IFtpbnB1dHNbMF0uZGltc1swXSwgaW5wdXRzWzBdLmRpbXNbMV0sIGlucHV0c1swXS5kaW1zWzJdLCBpbnB1dHNbMF0uZGltc1szXSAvIGNvbXBvbmVudHNdO1xuICAgICAgY29uc3Qgd1NoYXBlID0gW2lucHV0c1sxXS5kaW1zWzBdLCBpbnB1dHNbMV0uZGltc1sxXSwgaW5wdXRzWzFdLmRpbXNbMl0sIGlucHV0c1sxXS5kaW1zWzNdIC8gY29tcG9uZW50c107XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZUluU2hhZGVyID0gW291dHB1dFNoYXBlWzBdLCBvdXRwdXRTaGFwZVsxXSwgb3V0cHV0U2hhcGVbMl0sIG91dHB1dFNoYXBlWzNdIC8gY29tcG9uZW50c107XG5cbiAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZX0sXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogW2F0dHJpYnV0ZXMuc3RyaWRlc1swXSwgYXR0cmlidXRlcy5zdHJpZGVzWzFdXX0sXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogW2F0dHJpYnV0ZXMucGFkc1swXSwgYXR0cmlidXRlcy5wYWRzWzFdXX1cbiAgICAgIF07XG4gICAgICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhKGF0dHJpYnV0ZXMsIHByb2dyYW1Vbmlmb3Jtcyk7XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyh4U2hhcGUsIHdTaGFwZSwgb3V0cHV0U2hhcGVJblNoYWRlcikpO1xuICAgICAgY29uc3QgeE51bWJlciA9IChvdXRwdXROdW1iZXIgLSAxKSAqIGF0dHJpYnV0ZXMuc3RyaWRlc1sxXSArIHdTaGFwZVsxXTtcbiAgICAgIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZUluU2hhZGVyLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgICAgIGNvbnN0IGJhc2VUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKG91dHB1dC50eXBlLnRlbnNvcik7XG4gICAgICAgIGNvbnN0IGFwcGx5QWN0aXZhdGlvbiA9IGdldEFjdGl2YXRpb25TbmlwcGV0KGF0dHJpYnV0ZXMsIG91dHB1dC50eXBlLnZhbHVlLCBiYXNlVHlwZSk7XG4gICAgICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCB4U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICAgICAgY29uc3QgdyA9IGlucHV0VmFyaWFibGUoJ3cnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIHdTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgICAgICBjb25zdCBpbnB1dFZhcnMgPSBbeCwgd107XG4gICAgICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICAgICAgaW5wdXRWYXJzLnB1c2goaW5wdXRWYXJpYWJsZSgnYicsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMsIGNvbXBvbmVudHMpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9jZXNzQmlhcyA9IGhhc0JpYXMgPyAndmFsdWUgKz0gYltvdXRwdXRfY2hhbm5lbF07JyA6ICcnO1xuICAgICAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICAgICAge25hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInfSxcbiAgICAgICAgICB7bmFtZTogJ3N0cmlkZXMnLCB0eXBlOiAnaTMyJywgbGVuZ3RoOiAyfSxcbiAgICAgICAgICB7bmFtZTogJ3BhZHMnLCB0eXBlOiAnaTMyJywgbGVuZ3RoOiAyfSxcbiAgICAgICAgXTtcbiAgICAgICAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zKGF0dHJpYnV0ZXMsIHVuaWZvcm1zKTtcbiAgICAgICAgcmV0dXJuIGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcnMsIG91dHB1dCl9XG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG4gICAgbGV0IHdpZHRoMCA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZVszXTtcbiAgICBsZXQgb3V0cHV0X2NoYW5uZWwgPSBnbG9iYWxfaWR4ICUgd2lkdGgwO1xuICAgIHZhciBpbmRleDEgPSBnbG9iYWxfaWR4IC8gd2lkdGgwO1xuICAgIGxldCB3aWR0aDEgPSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMl0gLyAke291dHB1dE51bWJlcn11O1xuICAgIGxldCBjb2wgPSAoaW5kZXgxICUgd2lkdGgxKSAqICR7b3V0cHV0TnVtYmVyfXU7XG4gICAgaW5kZXgxID0gaW5kZXgxIC8gd2lkdGgxO1xuICAgIGxldCByb3cgPSBpbmRleDEgJSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV07XG4gICAgbGV0IGJhdGNoID0gaW5kZXgxIC8gdW5pZm9ybXMub3V0cHV0X3NoYXBlWzFdO1xuXG4gICAgbGV0IHhfY29ybmVyID0gdmVjMjxpMzI+KGkzMihyb3cpLCBpMzIoY29sKSkgKiB1bmlmb3Jtcy5zdHJpZGVzIC0gdW5pZm9ybXMucGFkcztcblxuICAgIHZhciB4X3ZhbHM6IGFycmF5PCR7eC50eXBlLnZhbHVlfSwgJHt4TnVtYmVyfT47XG4gICAgdmFyIHZhbHVlczogYXJyYXk8JHtvdXRwdXQudHlwZS52YWx1ZX0sICR7b3V0cHV0TnVtYmVyfT47XG4gICAgbGV0IGlucHV0X2NoYW5uZWwgPSBvdXRwdXRfY2hhbm5lbDtcbiAgICAvLyBVc2UgY29uc3RhbnQgaW5zdGVhZCBvZiB1bmlmb3JtIGNhbiBnaXZlIGJldHRlciBwZXJmb3JtYW5jZSBmb3IgdydzIGhlaWdodC93aWR0aC5cbiAgICBmb3IgKHZhciB3X2hlaWdodDogdTMyID0gMHU7IHdfaGVpZ2h0IDwgJHt3U2hhcGVbMF19OyB3X2hlaWdodCsrKSB7XG4gICAgICBsZXQgeF9oZWlnaHQgPSB4X2Nvcm5lci54ICsgaTMyKHdfaGVpZ2h0KTtcbiAgICAgIGlmICh4X2hlaWdodCA+PSAwICYmIHUzMih4X2hlaWdodCkgPCB1bmlmb3Jtcy54X3NoYXBlWzFdKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHt4TnVtYmVyfTsgaSsrKSB7XG4gICAgICAgICAgbGV0IHhfd2lkdGggPSB4X2Nvcm5lci55ICsgaTtcbiAgICAgICAgICBpZiAoeF93aWR0aCA+PSAwICYmIHUzMih4X3dpZHRoKSA8IHVuaWZvcm1zLnhfc2hhcGVbMl0pIHtcbiAgICAgICAgICAgIHhfdmFsc1tpXSA9ICR7eC5nZXQoJ2JhdGNoJywgJ3UzMih4X2hlaWdodCknLCAndTMyKHhfd2lkdGgpJywgJ2lucHV0X2NoYW5uZWwnKX07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHhfdmFsc1tpXSA9ICR7eC50eXBlLnZhbHVlfSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgd193aWR0aDogdTMyID0gMHU7IHdfd2lkdGggPCAke3dTaGFwZVsxXX07IHdfd2lkdGgrKykge1xuICAgICAgICAgIGxldCB3X3ZhbCA9ICR7dy5nZXQoJ3dfaGVpZ2h0JywgJ3dfd2lkdGgnLCAnMCcsICdvdXRwdXRfY2hhbm5lbCcpfTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke291dHB1dE51bWJlcn11OyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlc1tpXSA9IGZtYSh4X3ZhbHNbaSAqIHUzMih1bmlmb3Jtcy5zdHJpZGVzWzFdKSArIHdfd2lkdGhdLCB3X3ZhbCwgdmFsdWVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke291dHB1dE51bWJlcn11OyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICR7cHJvY2Vzc0JpYXN9XG4gICAgICAke2FwcGx5QWN0aXZhdGlvbn1cbiAgICAgICR7b3V0cHV0LnNldCgnYmF0Y2gnLCAncm93JywgJ2NvbCArIGknLCAnb3V0cHV0X2NoYW5uZWwnLCAndmFsdWUnKX07XG4gICAgfVxuICB9YDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdHcm91cGVkQ29udi1WZWN0b3JpemUnLFxuICAgICAgICBzaGFkZXJDYWNoZToge1xuICAgICAgICAgIGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9OyR7Y29tcG9uZW50c307JHtvdXRwdXROdW1iZXJ9OyR7eE51bWJlcn07JHt3U2hhcGVbMF19OyR7d1NoYXBlWzFdfWAsXG4gICAgICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IGhhc0JpYXMgPyBbJ3JhbmsnLCAncmFuaycsICd0eXBlJ10gOiBbJ3JhbmsnLCAncmFuayddXG4gICAgICAgIH0sXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX1dLFxuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKX0sXG4gICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zXG4gICAgICAgIH0pLFxuICAgICAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgICB9O1xuICAgIH07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtCcm9hZGNhc3RVdGlsLCBTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y3JlYXRlTWF0bXVsUHJvZ3JhbUluZm99IGZyb20gJy4vM3JkLXBhcnR5L21hdG11bF9wYWNrZWRfd2ViZ3B1JztcbmltcG9ydCB7Y3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGdldEJyb2FkY2FzdERpbXMsIGdldE1heENvbXBvbmVudHMsIEluZGljZXNIZWxwZXIsIGlucHV0VmFyaWFibGUsIGludGVybmFsVmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSwgVW5pZm9ybXNBcnJheVR5cGV9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7YXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zLCBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhLCBnZXRBY3RpdmF0aW9uU25pcHBldCwgSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlc30gZnJvbSAnLi9mdXNlLXV0aWxzJztcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZU5haXZlTWF0bXVsUHJvZ3JhbUluZm8gPVxuICAgIChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYWN0aXZhdGlvbkF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgcmVzaGFwZWRPdXRwdXRTaGFwZT86IHJlYWRvbmx5IG51bWJlcltdLFxuICAgICBpc0NoYW5uZWxzTGFzdCA9IGZhbHNlIC8qIG9ubHkgdXNlZCBmb3IgY29udjJkQnlNYXRNdWwqLyk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGFTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICAgICAgY29uc3QgYlNoYXBlID0gaW5wdXRzWzFdLmRpbXM7XG5cbiAgICAgIGNvbnN0IE0gPSBhU2hhcGVbYVNoYXBlLmxlbmd0aCAtIDJdO1xuICAgICAgY29uc3QgTiA9IGJTaGFwZVtiU2hhcGUubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCBLID0gYVNoYXBlW2FTaGFwZS5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKE4pO1xuICAgICAgY29uc3QgYUNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKEspO1xuICAgICAgY29uc3Qgb3V0cHV0TnVtYmVyID0gZ2V0TWF4Q29tcG9uZW50cyhNKTtcbiAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyBjb21wb25lbnRzIC8gb3V0cHV0TnVtYmVyO1xuICAgICAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPiAyO1xuICAgICAgY29uc3Qgb3V0ZXJEaW1zID0gcmVzaGFwZWRPdXRwdXRTaGFwZSA/IHJlc2hhcGVkT3V0cHV0U2hhcGUuc2xpY2UoMCwgLTIpIDogb3V0cHV0U2hhcGUuc2xpY2UoMCwgLTIpO1xuICAgICAgY29uc3QgYmF0Y2hTaXplID0gU2hhcGVVdGlsLnNpemUob3V0ZXJEaW1zKTtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlSW5TaGFkZXIgPSBbYmF0Y2hTaXplLCBNLCBOXTtcblxuICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplfSwge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTX0sIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE59LFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBLfVxuICAgICAgXTtcbiAgICAgIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEoYWN0aXZhdGlvbkF0dHJpYnV0ZXMsIHByb2dyYW1Vbmlmb3Jtcyk7XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRlckRpbXMsIGFTaGFwZSwgYlNoYXBlKSk7XG4gICAgICBpZiAoaGFzQmlhcykge1xuICAgICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMl0uZGltcykpO1xuICAgICAgfVxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGVJblNoYWRlcikpO1xuXG4gICAgICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICAgICAgY29uc3QgYmF0Y2hEaW1zID0gaW50ZXJuYWxWYXJpYWJsZSgnYmF0Y2hfZGltcycsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0ZXJEaW1zLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGEgPSBpbnB1dFZhcmlhYmxlKCdhJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBhU2hhcGUubGVuZ3RoLCBhQ29tcG9uZW50cyk7XG4gICAgICAgIGNvbnN0IGIgPSBpbnB1dFZhcmlhYmxlKCdiJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBiU2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGVJblNoYWRlci5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgICAgICBjb25zdCBiYXNlVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShvdXRwdXQudHlwZS50ZW5zb3IpO1xuICAgICAgICBjb25zdCBhcHBseUFjdGl2YXRpb24gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhY3RpdmF0aW9uQXR0cmlidXRlcywgb3V0cHV0LnR5cGUudmFsdWUsIGJhc2VUeXBlKTtcbiAgICAgICAgY29uc3QgaW5wdXRWYXJpYWJsZXMgPSBbYSwgYl07XG4gICAgICAgIGxldCBwcm9jZXNzQmlhcyA9ICcnO1xuICAgICAgICBpZiAoaGFzQmlhcykge1xuICAgICAgICAgIGNvbnN0IGJpYXNDb21wb25lbnRzID0gaXNDaGFubmVsc0xhc3QgPyBjb21wb25lbnRzIDogMTtcbiAgICAgICAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCwgYmlhc0NvbXBvbmVudHMpKTtcbiAgICAgICAgICBwcm9jZXNzQmlhcyA9IGAke1xuICAgICAgICAgICAgICBpc0NoYW5uZWxzTGFzdCA/IGB2YWx1ZSArPSBiaWFzW2NvbCAvICR7Ymlhc0NvbXBvbmVudHN9XTtgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgdmFsdWUgKz0gJHtvdXRwdXQudHlwZS52YWx1ZX0oYmlhc1tyb3cgKyBpXSk7YH1gO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb3V0ZXJEaW1zQSA9IGFTaGFwZS5zbGljZSgwLCAtMik7XG4gICAgICAgIGNvbnN0IG91dGVyRGltc0IgPSBiU2hhcGUuc2xpY2UoMCwgLTIpO1xuICAgICAgICBjb25zdCBicm9hZENhc3RBRGltcyA9IGdldEJyb2FkY2FzdERpbXMob3V0ZXJEaW1zQSwgb3V0ZXJEaW1zKTtcbiAgICAgICAgY29uc3QgYnJvYWRDYXN0QkRpbXMgPSBnZXRCcm9hZGNhc3REaW1zKG91dGVyRGltc0IsIG91dGVyRGltcyk7XG4gICAgICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgICAgICB7bmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ00nLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnTicsIHR5cGU6ICd1MzInfSxcbiAgICAgICAgICB7bmFtZTogJ0snLCB0eXBlOiAndTMyJ31cbiAgICAgICAgXTtcbiAgICAgICAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zKGFjdGl2YXRpb25BdHRyaWJ1dGVzLCB1bmlmb3Jtcyk7XG5cbiAgICAgICAgY29uc3QgZ2V0SW5kaWNlcyA9ICh2YXJpYWJsZTogSW5kaWNlc0hlbHBlciwgYnJvYWRDYXN0RGltczogbnVtYmVyW10pID0+IHtcbiAgICAgICAgICBjb25zdCByYW5rID0gdmFyaWFibGUucmFuaztcbiAgICAgICAgICBjb25zdCBuYW1lID0gdmFyaWFibGUubmFtZTtcbiAgICAgICAgICBpZiAocmFuayA9PT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIGB2YXIgJHtuYW1lfV9pbmRpY2VzID0gJHt2YXJpYWJsZS50eXBlLmluZGljZXN9KDB1LCAwdSk7YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYmF0Y2hSYW5rID0gYmF0Y2hEaW1zLnJhbms7XG4gICAgICAgICAgbGV0IHJlc1N0ciA9IGB2YXIgJHtuYW1lfV9pbmRpY2VzOiAke3ZhcmlhYmxlLnR5cGUuaW5kaWNlc307YDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gcmFuayAtIDIgLSAxLCBqID0gYmF0Y2hSYW5rIC0gMTsgaSA+PSAwOyBpLS0sIGotLSkge1xuICAgICAgICAgICAgcmVzU3RyICs9IGBcXG4ke25hbWV9X2luZGljZXNbJHtpfV0gPSAke2JhdGNoUmFuayA+IDEgPyBgYmF0Y2hfaW5kaWNlc1ske2p9XWAgOiAnYmF0Y2hfaW5kaWNlcyd9O2A7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyb2FkQ2FzdERpbXMuZm9yRWFjaChpID0+IHtcbiAgICAgICAgICAgIHJlc1N0ciArPSBgXFxuJHtuYW1lfV9pbmRpY2VzWyR7aX1dID0gMDtgO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlc1N0ciArPSBgJHtuYW1lfV9pbmRpY2VzWyR7cmFuayAtIDJ9XSA9IDB1O1xuICAgICAgICAgICAgICAgICAgICAgJHtuYW1lfV9pbmRpY2VzWyR7cmFuayAtIDF9XSA9IDB1O2A7XG4gICAgICAgICAgcmV0dXJuIHJlc1N0cjtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBjYWxjUmVzdWx0ID0gKCk6IHN0cmluZyA9PiB7XG4gICAgICAgICAgbGV0IGNhbGNTdHIgPSBgdmFyIGFfZGF0YTogJHthLnR5cGUudmFsdWV9O2A7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhQ29tcG9uZW50czsgaSsrKSB7XG4gICAgICAgICAgICBjYWxjU3RyICs9IGBcbiAgICAgICAgICAgICAgbGV0IGJfZGF0YSR7aX0gPSBiWyhiX29mZnNldCArIChrICsgJHtpfSkgKiB1bmlmb3Jtcy5OICsgY29sKSAvICR7Y29tcG9uZW50c31dO2A7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0TnVtYmVyOyBpKyspIHtcbiAgICAgICAgICAgIGNhbGNTdHIgKz0gYGFfZGF0YSA9IGFbKGFfb2Zmc2V0ICsgKHJvdyArICR7aX0pICogdW5pZm9ybXMuSyArIGspIC8gJHthQ29tcG9uZW50c31dO2A7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYUNvbXBvbmVudHM7IGorKykge1xuICAgICAgICAgICAgICBjYWxjU3RyICs9IGBcbiAgICAgICAgICAgIHZhbHVlc1ske2l9XSA9IGZtYSgke2IudHlwZS52YWx1ZX0oYV9kYXRhJHthQ29tcG9uZW50cyA9PT0gMSA/ICcnIDogYFske2p9XWB9KSwgYl9kYXRhJHtqfSwgdmFsdWVzWyR7XG4gICAgICAgICAgICAgICAgICBpfV0pO1xcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxjU3RyO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBgXG4gICR7XG4gICAgICAgICAgICBzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykucmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcyhiYXRjaERpbXMpLmRlY2xhcmVWYXJpYWJsZXMoXG4gICAgICAgICAgICAgICAgLi4uaW5wdXRWYXJpYWJsZXMsIG91dHB1dCl9XG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG4gICAgbGV0IGNvbCA9IChnbG9iYWxfaWR4ICUgKHVuaWZvcm1zLk4gLyAke2NvbXBvbmVudHN9KSkgKiAke2NvbXBvbmVudHN9O1xuICAgIHZhciBpbmRleDEgPSBnbG9iYWxfaWR4IC8gKHVuaWZvcm1zLk4gLyAke2NvbXBvbmVudHN9KTtcbiAgICBsZXQgc3RyaWRlMSA9IHVuaWZvcm1zLk0gLyAke291dHB1dE51bWJlcn07XG4gICAgbGV0IHJvdyA9IChpbmRleDEgJSBzdHJpZGUxKSAqICR7b3V0cHV0TnVtYmVyfTtcbiAgICBsZXQgYmF0Y2ggPSBpbmRleDEgLyBzdHJpZGUxO1xuXG4gICAgJHtvdXRwdXRTaGFwZS5sZW5ndGggPT09IDIgPyAnJyA6IGBsZXQgYmF0Y2hfaW5kaWNlcyA9ICR7YmF0Y2hEaW1zLm9mZnNldFRvSW5kaWNlcygnYmF0Y2gnKX07YH1cbiAgICAke2dldEluZGljZXMoYSwgYnJvYWRDYXN0QURpbXMpfVxuICAgIGxldCBhX29mZnNldCA9ICR7YS5pbmRpY2VzVG9PZmZzZXQoJ2FfaW5kaWNlcycpfTtcbiAgICAke2dldEluZGljZXMoYiwgYnJvYWRDYXN0QkRpbXMpfVxuICAgIGxldCBiX29mZnNldCA9ICR7Yi5pbmRpY2VzVG9PZmZzZXQoJ2JfaW5kaWNlcycpfTtcbiAgICB2YXIgdmFsdWVzOiBhcnJheTwke291dHB1dC50eXBlLnZhbHVlfSwgJHtvdXRwdXROdW1iZXJ9PjtcbiAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8IHVuaWZvcm1zLks7IGsgPSBrICsgJHthQ29tcG9uZW50c30pIHtcbiAgICAgICR7Y2FsY1Jlc3VsdCgpfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke291dHB1dE51bWJlcn11OyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICR7cHJvY2Vzc0JpYXN9XG4gICAgICAke2FwcGx5QWN0aXZhdGlvbn1cbiAgICAgIGxldCBjdXJfaW5kaWNlcyA9ICR7b3V0cHV0LnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdyArIGksIGNvbCk7XG4gICAgICBsZXQgb2Zmc2V0ID0gJHtvdXRwdXQuaW5kaWNlc1RvT2Zmc2V0KCdjdXJfaW5kaWNlcycpfTtcbiAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KGBvZmZzZXQgLyAke2NvbXBvbmVudHN9YCwgJ3ZhbHVlJyl9O1xuICAgIH1cbiAgfVxuICBgO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdNYXRNdWxOYWl2ZScsXG4gICAgICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICAgICAgaGludDogYCR7YWN0aXZhdGlvbkF0dHJpYnV0ZXMuYWN0aXZhdGlvbn07JHtjb21wb25lbnRzfTske2FDb21wb25lbnRzfTske291dHB1dE51bWJlcn07JHtpc0NoYW5uZWxzTGFzdH1gLFxuICAgICAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiBoYXNCaWFzID8gWydyYW5rJywgJ3JhbmsnLCAncmFuayddIDogWydyYW5rJywgJ3JhbmsnXVxuICAgICAgICB9LFxuICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICAgIG91dHB1dHM6IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGV9XSxcbiAgICAgICAgICBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgICAgIHByb2dyYW1Vbmlmb3Jtc1xuICAgICAgICB9KSxcbiAgICAgICAgZ2V0U2hhZGVyU291cmNlXG4gICAgICB9O1xuICAgIH07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdE11bCByZXF1aXJlcyAyIGlucHV0cy4nKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0uZGltc1tpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAxXSAhPT0gaW5wdXRzWzFdLmRpbXNbaW5wdXRzWzFdLmRpbXMubGVuZ3RoIC0gMl0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NoYXJlZCBkaW1lbnNpb24gZG9lcyBub3QgbWF0Y2guJyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBtYXRNdWwgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IEJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGNvbnRleHQuaW5wdXRzWzFdLmRpbXMsIHRydWUpO1xuICBpZiAoIW91dHB1dFNoYXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IHVzZSBtYXRtdWwgb24gdGhlIGdpdmVuIHRlbnNvcnMnKTtcbiAgfVxuICBjb25zdCBOID0gb3V0cHV0U2hhcGVbb3V0cHV0U2hhcGUubGVuZ3RoIC0gMV07XG4gIGNvbnN0IEsgPSBjb250ZXh0LmlucHV0c1swXS5kaW1zW2NvbnRleHQuaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMV07XG4gIGlmIChOIDwgOCAmJiBLIDwgOCkge1xuICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVOYWl2ZU1hdG11bFByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCB7YWN0aXZhdGlvbjogJyd9LCBvdXRwdXRTaGFwZSkpO1xuICB9IGVsc2Uge1xuICAgIGNvbnRleHQuY29tcHV0ZShjcmVhdGVNYXRtdWxQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywge2FjdGl2YXRpb246ICcnfSwgb3V0cHV0U2hhcGUpKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1Bvb2xDb252VXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0F0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHR9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVDb252MkRNYXRNdWxQcm9ncmFtSW5mb30gZnJvbSAnLi8zcmQtcGFydHkvY29udjJkX21tX3dlYmdwdSc7XG5pbXBvcnQge2NyZWF0ZU1hdG11bFByb2dyYW1JbmZvfSBmcm9tICcuLzNyZC1wYXJ0eS9tYXRtdWxfcGFja2VkX3dlYmdwdSc7XG5pbXBvcnQge2NyZWF0ZUdyb3VwZWRDb252UHJvZ3JhbUluZm8sIGNyZWF0ZUdyb3VwZWRDb252VmVjdG9yaXplUHJvZ3JhbUluZm99IGZyb20gJy4vY29udi1ncm91cGVkJztcbmltcG9ydCB7SW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcywgcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzfSBmcm9tICcuL2Z1c2UtdXRpbHMnO1xuaW1wb3J0IHtjcmVhdGVOYWl2ZU1hdG11bFByb2dyYW1JbmZvfSBmcm9tICcuL21hdG11bCc7XG5pbXBvcnQge2NyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvfSBmcm9tICcuL3RyYW5zcG9zZSc7XG5cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVPdXRwdXRTaGFwZSA9XG4gICAgKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBrZXJuZWxTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIGRpbGF0aW9uczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgIGFkanVzdFBhZHM6IHJlYWRvbmx5IG51bWJlcltdLCBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSwgaXNDaGFubmVsTGFzdDogYm9vbGVhbik6IG51bWJlcltdID0+IHtcbiAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IGlucHV0U2hhcGVbMF07XG4gICAgICBjb25zdCBpbnB1dFNwYXRpYWxTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoaXNDaGFubmVsTGFzdCA/IDEgOiAyLCBpc0NoYW5uZWxMYXN0ID8gMyA6IDQpO1xuICAgICAgY29uc3Qgc3BhdGlhbFJhbmsgPSBpbnB1dFNwYXRpYWxTaGFwZS5sZW5ndGg7XG4gICAgICBjb25zdCBvdXRDaGFubmVscyA9IGtlcm5lbFNoYXBlWzBdO1xuICAgICAgY29uc3Qga2VybmVsU3BhdGlhbFNoYXBlID0ga2VybmVsU2hhcGUuc2xpY2UoMik7XG4gICAgICBjb25zdCBkaWxhdGVkS2VybmVsU2hhcGUgPSBrZXJuZWxTcGF0aWFsU2hhcGUubWFwKCh2LCBpKSA9PiB2ICsgKHYgLSAxKSAqIChkaWxhdGlvbnNbaV0gLSAxKSk7XG4gICAgICBjb25zdCBpbnB1dFNwYXRpYWxTaGFwZVdpdGhQYWQgPSBpbnB1dFNwYXRpYWxTaGFwZS5tYXAoKHYsIGkpID0+IHYgKyBhZGp1c3RQYWRzW2ldICsgYWRqdXN0UGFkc1tpICsgc3BhdGlhbFJhbmtdKTtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID1cbiAgICAgICAgICBpbnB1dFNwYXRpYWxTaGFwZVdpdGhQYWQubWFwKCh2LCBpKSA9PiBNYXRoLmZsb29yKCh2IC0gZGlsYXRlZEtlcm5lbFNoYXBlW2ldICsgc3RyaWRlc1tpXSkgLyBzdHJpZGVzW2ldKSk7XG4gICAgICBvdXRwdXRTaGFwZS5zcGxpY2UoMCwgMCwgYmF0Y2hTaXplKTtcbiAgICAgIG91dHB1dFNoYXBlLnNwbGljZShpc0NoYW5uZWxMYXN0ID8gMyA6IDEsIDAsIG91dENoYW5uZWxzKTtcbiAgICAgIHJldHVybiBvdXRwdXRTaGFwZTtcbiAgICB9O1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbnZBdHRyaWJ1dGVzIGV4dGVuZHMgSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcywgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgYXV0b1BhZDogc3RyaW5nO1xuICByZWFkb25seSBkaWxhdGlvbnM6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSBmb3JtYXQ6ICdOSFdDJ3wnTkNIVyc7XG4gIHJlYWRvbmx5IGdyb3VwOiBudW1iZXI7XG4gIHJlYWRvbmx5IGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcbiAgcmVhZG9ubHkgcGFkczogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSB3SXNDb25zdDogYm9vbGVhbjtcbn1cblxuLy8gZm9yIHRyYW5zcG9zaW5nIHdlaWdodCB0ZW5zb3IgZnJvbSBbTSwgQy9ncm91cCwgS0gsIEtXXSB0byBbS0gsIEtXLCBDL2dyb3VwLCBNXVxuY29uc3Qgd2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlID0gWzIsIDMsIDEsIDBdO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgLy8gUmVmZXIgdG8gdGhlIGJlbG93IGxpbmsgZm9yIGFsbCBpbnB1dCBjaGVja3NcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL29ubngvb25ueC9ibG9iL21hc3Rlci9kb2NzL09wZXJhdG9ycy5tZCNDb252XG4gIGlmICghaW5wdXRzIHx8IChpbnB1dHMubGVuZ3RoICE9PSAyICYmIGlucHV0cy5sZW5ndGggIT09IDMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb252IHJlcXVpcmVzIDIgb3IgMyBpbnB1dHMnKTtcbiAgfVxuXG4gIC8vIFRPRE8gOiBOZWVkIHRvIGFkZCBzdXBwb3J0IGZvciBtdWx0aS1kaW1lbnNpb25hbCBjb252XG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDQgJiYgaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjdXJyZW50bHkgb25seSBzdXBwb3J0IGNvbnYgMUQgYW5kIDJEJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSBpbnB1dHNbMV0uZGltcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbHRlciBkb2VzIG5vdCBoYXZlIHNhbWUgZGltZW5zaW9uIGFzIGlucHV0Jyk7XG4gIH1cblxuICAvLyBGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXG4gIGNvbnN0IGRhdGFDaGFubmVsID0gaW5wdXRzWzBdLmRpbXNbYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJyA/IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDEgOiAxXTtcbiAgY29uc3QgZmlsdGVySW5DaGFubmVsID0gaW5wdXRzWzFdLmRpbXNbMV0gKiBhdHRyaWJ1dGVzLmdyb3VwO1xuICBpZiAoZGF0YUNoYW5uZWwgIT09IGZpbHRlckluQ2hhbm5lbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTCcpO1xuICB9XG5cbiAgLy8gaWYgYmlhcyBpcyBwcm92aWRlZCBpdCBzaG91bGQgYmUgMUQgYW5kIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgc2hvdWxkIGJlIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgZmVhdHVyZSBtYXBzXG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSAzICYmIChpbnB1dHNbMl0uZGltcy5sZW5ndGggIT09IDEgfHwgaW5wdXRzWzFdLmRpbXNbMF0gIT09IGlucHV0c1syXS5kaW1zWzBdKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBiaWFzJyk7XG4gIH1cblxuICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDI7XG4gIC8vIHdyb25nIGRpbGF0aW9ucyBkaW1lbnNpb25cbiAgaWYgKGF0dHJpYnV0ZXMuZGlsYXRpb25zLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGRpbGF0aW9ucyBzaG91bGQgYmUgJHtzcGF0aWFsUmFua31EYCk7XG4gIH1cblxuICAvLyBXcm9uZyBzdHJpZGVzIGRpbWVuc2lvblxuICBpZiAoYXR0cmlidXRlcy5zdHJpZGVzLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xuICB9XG5cbiAgLy8gV3JvbmcgcGFkcyBkaW1lbnNpb25cbiAgaWYgKGF0dHJpYnV0ZXMucGFkcy5sZW5ndGggIT09IHNwYXRpYWxSYW5rICogMikge1xuICAgIHRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHtzcGF0aWFsUmFuayAqIDJ9RGApO1xuICB9XG5cbiAgLy8gaWYga2VybmVsU2hhcGUgaXMgc3BlY2lmaWVkLCBpdCdzIGRhdGEgbGVuZ3RoIG11c3QgYmUgMiBsZXNzIHRoYW4gZGltcyBsZW5ndGggb2YgdGhlIHdlaWdodHMgdGVuc29yXG4gIC8vICh0aGUgZmlyc3QgMiBkaW1zIGFyZSBiYXRjaF9zaXplIGFuZCBjaGFubmVscylcbiAgaWYgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoICE9PSAwICYmIGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoICE9PSBpbnB1dHNbMV0uZGltcy5sZW5ndGggLSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGtlcm5lbCBzaGFwZScpO1xuICB9XG59O1xuXG5jb25zdCBnZXRBZGp1c3RlZENvbnZBdHRyaWJ1dGVzID0gPFQgZXh0ZW5kcyBDb252QXR0cmlidXRlcz4oYXR0cmlidXRlczogVCwgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiBUID0+IHtcbiAgY29uc3Qga2VybmVsU2hhcGUgPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLnNsaWNlKCk7XG4gIC8vIGlmIGtlcm5lbFNoYXBlIGlzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIGF0dHJpYnV0ZXMgb2YgdGhpcyBvcCwgaW5mZXIgaXQgZnJvbSB0aGUgd2VpZ2h0IHRlbnNvciBkaW1zXG4gIGZvciAobGV0IGkgPSAyOyBpIDwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoa2VybmVsU2hhcGVbaSAtIDJdID09PSAwKSB7XG4gICAgICBrZXJuZWxTaGFwZVtpIC0gMl0gPSBpbnB1dHNbMV0uZGltc1tpXTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMucGFkcy5zbGljZSgpO1xuICBQb29sQ29udlV0aWwuYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKFxuICAgICAgaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuc3RyaWRlcywgYXR0cmlidXRlcy5kaWxhdGlvbnMsIGtlcm5lbFNoYXBlLCBwYWRzLCBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnLFxuICAgICAgYXR0cmlidXRlcy5hdXRvUGFkKTtcblxuICAvLyBhbHdheXMgcmV0dXJuIGEgbmV3IG9iamVjdCBzbyBkb2VzIG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsIGF0dHJpYnV0ZXNcbiAgY29uc3QgbmV3QXR0cmlidXRlczogVCA9IE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXMpO1xuICBPYmplY3QuYXNzaWduKG5ld0F0dHJpYnV0ZXMsIHtrZXJuZWxTaGFwZSwgcGFkc30pO1xuICByZXR1cm4gbmV3QXR0cmlidXRlcztcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUNvbnZBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQ29udkF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBhY3RpdmF0aW9uQXR0cmlidXRlcyA9IHBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgLy8gVE9ETyA6IE1ha2UgdGhpcyBnZW5lcmljIGVub3VnaCB0byBjb21wdXRlIGRlZmF1bHQgYXR0cmlidXRlcyBmb3IgbXVsdGktZGltZW5zaW9uYWwgY29udlxuICBjb25zdCBmb3JtYXQgPSBhdHRyaWJ1dGVzLmZvcm1hdCBhcyAnTkhXQycgfCAnTkNIVyc7XG4gIGNvbnN0IGF1dG9QYWQgPSBbJ05PVFNFVCcsICdWQUxJRCcsICdTQU1FX1VQUEVSJywgJ1NBTUVfTE9XRVInXVthdHRyaWJ1dGVzLmF1dG9fcGFkIGFzIG51bWJlcl07XG4gIGNvbnN0IGRpbGF0aW9ucyA9IGF0dHJpYnV0ZXMuZGlsYXRpb25zIGFzIFtudW1iZXIsIG51bWJlcl07XG4gIGNvbnN0IGdyb3VwID0gYXR0cmlidXRlcy5ncm91cCBhcyBudW1iZXI7XG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxfc2hhcGUgYXMgW251bWJlciwgbnVtYmVyXTtcbiAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMucGFkcyBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgY29uc3Qgc3RyaWRlcyA9IGF0dHJpYnV0ZXMuc3RyaWRlcyBhcyBbbnVtYmVyLCBudW1iZXJdO1xuICBjb25zdCB3SXNDb25zdCA9IChhdHRyaWJ1dGVzLndfaXNfY29uc3QgYXMgKCkgPT4gYm9vbGVhbikoKTtcblxuICByZXR1cm4ge1xuICAgIGF1dG9QYWQsXG4gICAgZm9ybWF0LFxuICAgIGRpbGF0aW9ucyxcbiAgICBncm91cCxcbiAgICBrZXJuZWxTaGFwZSxcbiAgICBwYWRzLFxuICAgIHN0cmlkZXMsXG4gICAgd0lzQ29uc3QsXG4gICAgLi4uYWN0aXZhdGlvbkF0dHJpYnV0ZXMsXG4gICAgY2FjaGVLZXk6IGAke2F0dHJpYnV0ZXMuZm9ybWF0fTske2FjdGl2YXRpb25BdHRyaWJ1dGVzLmFjdGl2YXRpb259O2BcbiAgfTtcbn07XG5cbmNvbnN0IGNvbnYyZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGFkanVzdGVkQXR0cmlidXRlcyA9IGdldEFkanVzdGVkQ29udkF0dHJpYnV0ZXMoYXR0cmlidXRlcywgaW5wdXRzKTtcblxuICAvLyBjaGVjayBhdHRyaWJ1dGVzXG5cbiAgLy8gY29uc3QgaGFzUHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyA9IGZhbHNlOyAvKiBUT0RPOiBhZGQgc3VwcG9ydCBmb3IgcHJlbHUgYWN0aXZhdGlvbiB3ZWlnaHRzICovXG4gIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcbiAgaWYgKGF0dHJpYnV0ZXMuZ3JvdXAgIT09IDEpIHtcbiAgICAvLyBOVklESUEgR1BVIHdpdGggYW1wZXJlIGFyY2hpdGVjdHVyZSBmYWlscyB3aXRoIGJlbG93IDIgY2FzZXMsIGJ1dCB3ZSBjb3VsZG4ndCByZXBybyB0aGVtIHdpdGggYW55IG90aGVyXG4gICAgLy8gR1BVcy4gU28ganVzdCBkaXNhYmxlIHZlY3Rvcml6ZSBvbiBOVklESUEgYW1wZXJlIHRvIGVuc3VyZSBhbHdheXMgY29ycmVjdCBvdXRwdXRzLlxuICAgIC8vIFt3ZWJncHVdQ29udiAtIGNvbnYgLSB2ZWN0b3JpemUgZ3JvdXAgLSBCXG4gICAgLy8gW3dlYmdwdV1Db252IC0gY29udiAtIHZlY3Rvcml6ZSBncm91cCAtIERcbiAgICBjb25zdCBlbmFibGVHcm91cGVkQ29udlZlY3Rvcml6ZSA9ICFjb250ZXh0LmFkYXB0ZXJJbmZvLmlzQXJjaGl0ZWN0dXJlKCdhbXBlcmUnKTtcbiAgICBpZiAoZW5hYmxlR3JvdXBlZENvbnZWZWN0b3JpemUgJiYgaXNDaGFubmVsc0xhc3QgJiYgaW5wdXRzWzFdLmRpbXNbMF0gPT09IGF0dHJpYnV0ZXMuZ3JvdXAgJiZcbiAgICAgICAgaW5wdXRzWzFdLmRpbXNbMV0gPT09IDEgJiYgYXR0cmlidXRlcy5kaWxhdGlvbnNbMF0gPT09IDEgJiYgYXR0cmlidXRlcy5kaWxhdGlvbnNbMV0gPT09IDEpIHtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gY2FsY3VsYXRlT3V0cHV0U2hhcGUoXG4gICAgICAgICAgaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zLCBhdHRyaWJ1dGVzLmRpbGF0aW9ucywgYWRqdXN0ZWRBdHRyaWJ1dGVzLnBhZHMsIGF0dHJpYnV0ZXMuc3RyaWRlcyxcbiAgICAgICAgICBpc0NoYW5uZWxzTGFzdCk7XG4gICAgICBjb25zdCB0cmFuc3Bvc2VkV2VpZ2h0ID0gKGNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCBhcyBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkKSA/P1xuICAgICAgICAgIGNvbnRleHQuY29tcHV0ZShcbiAgICAgICAgICAgICAgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8oaW5wdXRzWzFdLCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUpLFxuICAgICAgICAgICAgICB7aW5wdXRzOiBbMV0sIG91dHB1dHM6IFthdHRyaWJ1dGVzLndJc0NvbnN0ID8gLTIgOiAtMV19KVswXTtcbiAgICAgIGlmIChhdHRyaWJ1dGVzLndJc0NvbnN0ICYmICFjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QpIHtcbiAgICAgICAgY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUID0gdHJhbnNwb3NlZFdlaWdodDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnZJbnB1dHMgPSBbaW5wdXRzWzBdLCB0cmFuc3Bvc2VkV2VpZ2h0XTtcbiAgICAgIGlmIChpbnB1dHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIGNvbnZJbnB1dHMucHVzaChpbnB1dHNbMl0pO1xuICAgICAgfVxuICAgICAgY29udGV4dC5jb21wdXRlKFxuICAgICAgICAgIGNyZWF0ZUdyb3VwZWRDb252VmVjdG9yaXplUHJvZ3JhbUluZm8oY29udklucHV0cywgYWRqdXN0ZWRBdHRyaWJ1dGVzLCBvdXRwdXRTaGFwZSksIHtpbnB1dHM6IGNvbnZJbnB1dHN9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUdyb3VwZWRDb252UHJvZ3JhbUluZm8oaW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPT09IDM7XG4gIGNvbnN0IGlucHV0SGVpZ2h0ID0gaW5wdXRzWzBdLmRpbXNbaXNDaGFubmVsc0xhc3QgPyAxIDogMl07XG4gIGNvbnN0IGlucHV0V2lkdGggPSBpbnB1dHNbMF0uZGltc1tpc0NoYW5uZWxzTGFzdCA/IDIgOiAzXTtcbiAgY29uc3QgaW5wdXRDaGFubmVscyA9IGlucHV0c1swXS5kaW1zW2lzQ2hhbm5lbHNMYXN0ID8gMyA6IDFdO1xuICBjb25zdCB3ZWlnaHRIZWlnaHQgPSBpbnB1dHNbMV0uZGltc1syXTtcbiAgY29uc3Qgd2VpZ2h0V2lkdGggPSBpbnB1dHNbMV0uZGltc1szXTtcblxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGNhbGN1bGF0ZU91dHB1dFNoYXBlKFxuICAgICAgaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zLCBhdHRyaWJ1dGVzLmRpbGF0aW9ucywgYWRqdXN0ZWRBdHRyaWJ1dGVzLnBhZHMsIGF0dHJpYnV0ZXMuc3RyaWRlcyxcbiAgICAgIGlzQ2hhbm5lbHNMYXN0KTtcbiAgY29uc3Qgb3V0SGVpZ2h0ID0gb3V0cHV0U2hhcGVbaXNDaGFubmVsc0xhc3QgPyAxIDogMl07XG4gIGNvbnN0IG91dFdpZHRoID0gb3V0cHV0U2hhcGVbaXNDaGFubmVsc0xhc3QgPyAyIDogM107XG4gIGNvbnN0IG91dENoYW5uZWxzID0gb3V0cHV0U2hhcGVbaXNDaGFubmVsc0xhc3QgPyAzIDogMV07XG5cbiAgY29uc3Qgc2FtZVNpemUgPSBpc0NoYW5uZWxzTGFzdCAmJiB3ZWlnaHRIZWlnaHQgPT09IGlucHV0SGVpZ2h0ICYmIHdlaWdodFdpZHRoID09PSBpbnB1dFdpZHRoICYmXG4gICAgICBhdHRyaWJ1dGVzLnBhZHNbMF0gPT09IDAgJiYgYXR0cmlidXRlcy5wYWRzWzFdID09PSAwO1xuICBpZiAoc2FtZVNpemUgfHxcbiAgICAgICh3ZWlnaHRIZWlnaHQgPT09IDEgJiYgd2VpZ2h0V2lkdGggPT09IDEgJiYgYXR0cmlidXRlcy5kaWxhdGlvbnNbMF0gPT09IDEgJiYgYXR0cmlidXRlcy5kaWxhdGlvbnNbMV0gPT09IDEgJiZcbiAgICAgICBhdHRyaWJ1dGVzLnN0cmlkZXNbMF0gPT09IDEgJiYgYXR0cmlidXRlcy5zdHJpZGVzWzFdID09PSAxICYmIGF0dHJpYnV0ZXMucGFkc1swXSA9PT0gMCAmJlxuICAgICAgIGF0dHJpYnV0ZXMucGFkc1sxXSA9PT0gMCkpIHtcbiAgICAvLyBjb252MmRCeU1hdE11bFxuICAgIGNvbnN0IGJhdGNoID0gb3V0cHV0U2hhcGVbMF07XG4gICAgbGV0IHhSZXNoYXBlZCwgd1Jlc2hhcGVkLCBtYXRtdWxPdXRwdXRTaGFwZTtcbiAgICBjb25zdCBtYXRtdWxJbnB1dHMgPSBbXTtcbiAgICBpZiAoaXNDaGFubmVsc0xhc3QpIHtcbiAgICAgIGNvbnN0IHRyYW5zcG9zZWRXZWlnaHQgPSAoY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUIGFzIFRlbnNvclZpZXcgfCB1bmRlZmluZWQpID8/XG4gICAgICAgICAgY29udGV4dC5jb21wdXRlKFxuICAgICAgICAgICAgICBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhpbnB1dHNbMV0sIHdlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZSksXG4gICAgICAgICAgICAgIHtpbnB1dHM6IFsxXSwgb3V0cHV0czogW2F0dHJpYnV0ZXMud0lzQ29uc3QgPyAtMiA6IC0xXX0pWzBdO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMud0lzQ29uc3QgJiYgIWNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCkge1xuICAgICAgICBjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QgPSB0cmFuc3Bvc2VkV2VpZ2h0O1xuICAgICAgfVxuICAgICAgaWYgKHNhbWVTaXplKSB7XG4gICAgICAgIGNvbnN0IHNoYXJlZERpbSA9IGlucHV0SGVpZ2h0ICogaW5wdXRXaWR0aCAqIGlucHV0Q2hhbm5lbHM7XG4gICAgICAgIHhSZXNoYXBlZCA9IGlucHV0c1swXS5yZXNoYXBlKFsxLCBiYXRjaCwgc2hhcmVkRGltXSk7XG4gICAgICAgIHdSZXNoYXBlZCA9IHRyYW5zcG9zZWRXZWlnaHQucmVzaGFwZShbMSwgc2hhcmVkRGltLCBvdXRDaGFubmVsc10pO1xuICAgICAgICBtYXRtdWxPdXRwdXRTaGFwZSA9IFsxLCBiYXRjaCwgb3V0Q2hhbm5lbHNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeFJlc2hhcGVkID0gaW5wdXRzWzBdLnJlc2hhcGUoW2JhdGNoLCBpbnB1dEhlaWdodCAqIGlucHV0V2lkdGgsIGlucHV0Q2hhbm5lbHNdKTtcbiAgICAgICAgd1Jlc2hhcGVkID0gdHJhbnNwb3NlZFdlaWdodC5yZXNoYXBlKFsxLCBpbnB1dENoYW5uZWxzLCBvdXRDaGFubmVsc10pO1xuICAgICAgICBtYXRtdWxPdXRwdXRTaGFwZSA9IFtiYXRjaCwgb3V0SGVpZ2h0ICogb3V0V2lkdGgsIG91dENoYW5uZWxzXTtcbiAgICAgIH1cbiAgICAgIG1hdG11bElucHV0cy5wdXNoKHhSZXNoYXBlZCk7XG4gICAgICBtYXRtdWxJbnB1dHMucHVzaCh3UmVzaGFwZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB4UmVzaGFwZWQgPSBpbnB1dHNbMF0ucmVzaGFwZShbYmF0Y2gsIGlucHV0Q2hhbm5lbHMsIGlucHV0SGVpZ2h0ICogaW5wdXRXaWR0aF0pO1xuICAgICAgd1Jlc2hhcGVkID0gaW5wdXRzWzFdLnJlc2hhcGUoWzEsIG91dENoYW5uZWxzLCBpbnB1dENoYW5uZWxzXSk7XG4gICAgICBtYXRtdWxPdXRwdXRTaGFwZSA9IFtiYXRjaCwgb3V0Q2hhbm5lbHMsIG91dEhlaWdodCAqIG91dFdpZHRoXTtcbiAgICAgIG1hdG11bElucHV0cy5wdXNoKHdSZXNoYXBlZCk7XG4gICAgICBtYXRtdWxJbnB1dHMucHVzaCh4UmVzaGFwZWQpO1xuICAgIH1cbiAgICBpZiAoaGFzQmlhcykge1xuICAgICAgbWF0bXVsSW5wdXRzLnB1c2goaW5wdXRzWzJdKTtcbiAgICB9XG4gICAgY29uc3QgTiA9IG1hdG11bE91dHB1dFNoYXBlWzJdO1xuICAgIGNvbnN0IEsgPSBtYXRtdWxJbnB1dHNbMF0uZGltc1ttYXRtdWxJbnB1dHNbMF0uZGltcy5sZW5ndGggLSAxXTtcbiAgICAvLyBUdW5lIHRoZSB0aHJlc2hvbGQuXG4gICAgaWYgKE4gPCA4ICYmIEsgPCA4KSB7XG4gICAgICBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgICAgY3JlYXRlTmFpdmVNYXRtdWxQcm9ncmFtSW5mbyhcbiAgICAgICAgICAgICAgbWF0bXVsSW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMsIG91dHB1dFNoYXBlLCBtYXRtdWxPdXRwdXRTaGFwZSwgaXNDaGFubmVsc0xhc3QpLFxuICAgICAgICAgIHtpbnB1dHM6IG1hdG11bElucHV0c30pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgICAgY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm8obWF0bXVsSW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMsIG91dHB1dFNoYXBlLCBtYXRtdWxPdXRwdXRTaGFwZSwgaXNDaGFubmVsc0xhc3QpLFxuICAgICAgICAgIHtpbnB1dHM6IG1hdG11bElucHV0c30pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUT0RPOiBpbXBsZW1lbnQgY29udjJkV2l0aEltMkNvbCgpXG5cbiAgY29uc3Qgc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkcyA9IC8qIGJhY2tlbmQuYWRhcHRlckluZm8uaXNJbnRlbCgpICovIHRydWU7XG5cbiAgLy8gU1RFUC4xOiB0cmFuc3Bvc2Ugd2VpZ2h0XG4gIGNvbnN0IHRyYW5zcG9zZWRXZWlnaHQgPSAoY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUIGFzIFRlbnNvclZpZXcgfCB1bmRlZmluZWQpID8/XG4gICAgICBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgICAgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8oaW5wdXRzWzFdLCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUpLFxuICAgICAgICAgIHtpbnB1dHM6IFsxXSwgb3V0cHV0czogW2F0dHJpYnV0ZXMud0lzQ29uc3QgPyAtMiA6IC0xXX0pWzBdO1xuICBpZiAoYXR0cmlidXRlcy53SXNDb25zdCAmJiAhY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUKSB7XG4gICAgY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUID0gdHJhbnNwb3NlZFdlaWdodDtcbiAgfVxuXG4gIC8vIFNURVAuMjogcHJlcGFyZSByZXNoYXBlZCBpbnB1dHNcbiAgY29uc3QgY29udklucHV0cyA9IFtpbnB1dHNbMF0sIHRyYW5zcG9zZWRXZWlnaHRdO1xuICBpZiAoaGFzQmlhcykge1xuICAgIGNvbnZJbnB1dHMucHVzaChpbnB1dHNbMl0pO1xuICB9XG5cbiAgLy8gU1RFUC4zOiBjb21wdXRlIG1hdG11bFxuICBjb25zdCBkaW1BT3V0ZXIgPSBpc0NoYW5uZWxzTGFzdCA/IG91dEhlaWdodCAqIG91dFdpZHRoIDogb3V0Q2hhbm5lbHM7XG4gIGNvbnN0IGRpbUJPdXRlciA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0Q2hhbm5lbHMgOiBvdXRIZWlnaHQgKiBvdXRXaWR0aDtcbiAgY29uc3QgZGltSW5uZXIgPSB3ZWlnaHRIZWlnaHQgKiB3ZWlnaHRXaWR0aCAqIGlucHV0Q2hhbm5lbHM7XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICAgIGNyZWF0ZUNvbnYyRE1hdE11bFByb2dyYW1JbmZvKFxuICAgICAgICAgIGNvbnZJbnB1dHMsIGFkanVzdGVkQXR0cmlidXRlcywgb3V0cHV0U2hhcGUsIGRpbUFPdXRlciwgZGltQk91dGVyLCBkaW1Jbm5lciwgaGFzQmlhcyxcbiAgICAgICAgICBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzKSxcbiAgICAgIHtpbnB1dHM6IGNvbnZJbnB1dHN9KTtcbn07XG5cbmNvbnN0IGNvbnYxZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgLy8gZXh0ZW5kIHRoZSBpbnB1dCB0byAyRCBieSBhZGRpbmcgSCBkaW1lbnNpb25cbiAgY29uc3QgaXNDaGFubmVsTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gIGNvbnN0IGlucHV0cyA9IFtcbiAgICBjb250ZXh0LmlucHV0c1swXS5yZXNoYXBlKFxuICAgICAgICBpc0NoYW5uZWxMYXN0ID9cbiAgICAgICAgICAgIC8vIFtOLCBXLCBDXSAtPiBbTiwgSD0xLCBXLCBDXVxuICAgICAgICAgICAgW2NvbnRleHQuaW5wdXRzWzBdLmRpbXNbMF0sIDEsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMV0sIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMl1dIDpcbiAgICAgICAgICAgIC8vIFtOLCBDLCBXXSAtPiBbTiwgQywgSD0xLCBXXVxuICAgICAgICAgICAgW2NvbnRleHQuaW5wdXRzWzBdLmRpbXNbMF0sIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMV0sIDEsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMl1dKSxcbiAgICAvL1tGSUxURVJfT1VUX0NIQU5ORUwsIEZJTFRFUl9JTl9DSEFOTkVMLCBrV10gLT4gW0ZJTFRFUl9PVVRfQ0hBTk5FTCwgRklMVEVSX0lOX0NIQU5ORUwsIGtIPTEsIGtXXVxuICAgIGNvbnRleHQuaW5wdXRzWzFdLnJlc2hhcGUoW2NvbnRleHQuaW5wdXRzWzFdLmRpbXNbMF0sIGNvbnRleHQuaW5wdXRzWzFdLmRpbXNbMV0sIDEsIGNvbnRleHQuaW5wdXRzWzFdLmRpbXNbMl1dKVxuICBdO1xuICBpZiAoY29udGV4dC5pbnB1dHMubGVuZ3RoID09PSAzKSB7XG4gICAgaW5wdXRzLnB1c2goY29udGV4dC5pbnB1dHNbMl0pO1xuICB9XG4gIGNvbnN0IHBhZHMgPSBbMCwgYXR0cmlidXRlcy5wYWRzWzBdLCAwLCBhdHRyaWJ1dGVzLnBhZHNbMV1dO1xuICBjb25zdCBzdHJpZGVzID0gWzFdLmNvbmNhdChhdHRyaWJ1dGVzLnN0cmlkZXMpO1xuICBjb25zdCBkaWxhdGlvbnMgPSBbMV0uY29uY2F0KGF0dHJpYnV0ZXMuZGlsYXRpb25zKTtcbiAgY29uc3Qga2VybmVsU2hhcGUgPSBbMV0uY29uY2F0KGF0dHJpYnV0ZXMua2VybmVsU2hhcGUpO1xuICBjb25zdCBhZGp1c3RlZEF0dHJpYnV0ZXMgPSBnZXRBZGp1c3RlZENvbnZBdHRyaWJ1dGVzKHsuLi5hdHRyaWJ1dGVzLCBwYWRzLCBzdHJpZGVzLCBkaWxhdGlvbnMsIGtlcm5lbFNoYXBlfSwgaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUdyb3VwZWRDb252UHJvZ3JhbUluZm8oXG4gICAgICBpbnB1dHMsIGFkanVzdGVkQXR0cmlidXRlcyxcbiAgICAgIG91dHB1dFNoYXBlID0+IGlzQ2hhbm5lbExhc3QgPyBbb3V0cHV0U2hhcGVbMF0sIG91dHB1dFNoYXBlWzJdLCBvdXRwdXRTaGFwZVszXV0gOiBbXSkpO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvbnYgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTsgIC8vIGN1cnJlbnRseSB3aWxsIGZhaWwgaWYgbm90IGNvbnYxRC8yRFxuICBpZiAoY29udGV4dC5pbnB1dHNbMF0uZGltcy5sZW5ndGggPT09IDMpIHtcbiAgICBjb252MWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgY29udjJkKGNvbnRleHQsIGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcbiIsICIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1iYWNrZW5kLXdlYmdwdS9zcmMvY29udl9iYWNrcHJvcF9tbV93ZWJncHUudHNcbi8vXG4vLyBtb2RpZmllZCB0byBmaXQgdGhlIG5lZWRzIG9mIHRoZSBwcm9qZWN0XG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7TE9HX0RFQlVHfSBmcm9tICcuLi8uLi8uLi9sb2cnO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1Byb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm19IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7Y3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSwgVW5pZm9ybXNBcnJheVR5cGV9IGZyb20gJy4uL2NvbW1vbic7XG5pbXBvcnQge0NvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzfSBmcm9tICcuLi9jb252LXRyYW5zcG9zZSc7XG5pbXBvcnQge2FwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcywgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YSwgZ2V0QWN0aXZhdGlvblNuaXBwZXR9IGZyb20gJy4uL2Z1c2UtdXRpbHMnO1xuXG5pbXBvcnQge2JpYXNTbmlwcGV0fSBmcm9tICcuL2FjdGl2YXRpb25fdXRpbCc7XG5pbXBvcnQge3V0aWxGdW5jdGlvbnN9IGZyb20gJy4vY29udl91dGlsJztcbmltcG9ydCB7bWFrZU1hdE11bFBhY2tlZFNvdXJjZSwgbWFrZU1hdE11bFBhY2tlZFZlYzRTb3VyY2V9IGZyb20gJy4vbWF0bXVsX3BhY2tlZF93ZWJncHUnO1xuXG5jb25zdCBjb252MmRUcmFuc3Bvc2VDb21tb25TbmlwcGV0ID1cbiAgICAoaXNDaGFubmVsc0xhc3Q6IGJvb2xlYW4sIGFkZEJpYXMgPSBmYWxzZSwgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMsIHR5cGU6IHN0cmluZyxcbiAgICAgaW5uZXJFbGVtZW50U2l6ZSA9IDQpOiBzdHJpbmcgPT4ge1xuICAgICAgY29uc3QgZ2V0V1NuaXBwZXQgPSAoaW5uZXJFbGVtZW50U2l6ZTogbnVtYmVyKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoaW5uZXJFbGVtZW50U2l6ZSkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiAncmV0dXJuIHdbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQsIHZlYzQ8aTMyPih1bmlmb3Jtcy53X3NoYXBlKSldOyc7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgIGxldCBjb29yZDEgPSB2ZWM0PGkzMj4oY29vcmRYLCBjb29yZFksIGNvbCArIDEsIHJvd0lubmVyKTtcbiAgICAgICAgICAgIGxldCBjb29yZDIgPSB2ZWM0PGkzMj4oY29vcmRYLCBjb29yZFksIGNvbCArIDIsIHJvd0lubmVyKTtcbiAgICAgICAgICAgIGxldCBjb29yZDMgPSB2ZWM0PGkzMj4oY29vcmRYLCBjb29yZFksIGNvbCArIDMsIHJvd0lubmVyKTtcbiAgICAgICAgICAgIGxldCB2MCA9IHdbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQsIHZlYzQ8aTMyPih1bmlmb3Jtcy53X3NoYXBlKSldO1xuICAgICAgICAgICAgbGV0IHYxID0gd1tnZXRJbmRleEZyb21Db29yZHM0RChjb29yZDEsIHZlYzQ8aTMyPih1bmlmb3Jtcy53X3NoYXBlKSldO1xuICAgICAgICAgICAgbGV0IHYyID0gd1tnZXRJbmRleEZyb21Db29yZHM0RChjb29yZDIsIHZlYzQ8aTMyPih1bmlmb3Jtcy53X3NoYXBlKSldO1xuICAgICAgICAgICAgbGV0IHYzID0gd1tnZXRJbmRleEZyb21Db29yZHM0RChjb29yZDMsIHZlYzQ8aTMyPih1bmlmb3Jtcy53X3NoYXBlKSldO1xuICAgICAgICAgICAgcmV0dXJuICR7dHlwZX0odjAsIHYxLCB2MiwgdjMpO1xuICAgICAgICAgICAgYDtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7aW5uZXJFbGVtZW50U2l6ZX0gaXMgbm90IHN1cHBvcnRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNvb3JkQVNuaXBwZXQgPSBpc0NoYW5uZWxzTGFzdCA/IGBcbiAgICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgaVhSLCBpWEMsIHhDaCk7XG4gICAgICBgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcbiAgICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgeENoLCBpWFIsIGlYQyk7XG4gICAgICBgO1xuXG4gICAgICBjb25zdCBjb29yZFJlc1NuaXBwZXQgPSBpc0NoYW5uZWxzTGFzdCA/IGBcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxuICAgICAgYmF0Y2gsXG4gICAgICByb3cgLyBvdXRXaWR0aCxcbiAgICAgIHJvdyAlIG91dFdpZHRoLFxuICAgICAgY29sKTtcbiAgICBgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXG4gICAgICBiYXRjaCxcbiAgICAgIHJvdyxcbiAgICAgIGNvbCAvIG91dFdpZHRoLFxuICAgICAgY29sICUgb3V0V2lkdGgpO1xuICAgIGA7XG5cbiAgICAgIGNvbnN0IHhIZWlnaHQgPSBpc0NoYW5uZWxzTGFzdCA/ICdpMzIodW5pZm9ybXMueF9zaGFwZVsxXSknIDogJ2kzMih1bmlmb3Jtcy54X3NoYXBlWzJdKSc7XG4gICAgICBjb25zdCB4V2lkdGggPSBpc0NoYW5uZWxzTGFzdCA/ICdpMzIodW5pZm9ybXMueF9zaGFwZVsyXSknIDogJ2kzMih1bmlmb3Jtcy54X3NoYXBlWzNdKSc7XG4gICAgICBjb25zdCByb3cgPSBpc0NoYW5uZWxzTGFzdCA/ICdyb3cnIDogJ2NvbCc7XG4gICAgICBjb25zdCBjb2wgPSBpc0NoYW5uZWxzTGFzdCA/ICdjb2wnIDogJ3Jvdyc7XG5cbiAgICAgIGNvbnN0IHJlYWRBU25pcHBldCA9IGBcbiAgICAgIGxldCBpbkNoYW5uZWxzID0gJHtpc0NoYW5uZWxzTGFzdCA/ICdpMzIodW5pZm9ybXMueF9zaGFwZVszXSknIDogJ2kzMih1bmlmb3Jtcy54X3NoYXBlWzFdKSd9O1xuICAgICAgbGV0IG91dFdpZHRoID0gJHtpc0NoYW5uZWxzTGFzdCA/ICdpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzJdKScgOiAnaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVszXSknfTtcbiAgICAgIGxldCBvdXRSb3cgPSAke3Jvd30gLyBvdXRXaWR0aDtcbiAgICAgIGxldCBvdXRDb2wgPSAke3Jvd30gJSBvdXRXaWR0aDtcblxuICAgICAgbGV0IFdSb3cgPSAke2NvbH0gLyAodW5pZm9ybXMuZmlsdGVyX2RpbXNbMV0gKiBpbkNoYW5uZWxzKTtcbiAgICAgIGxldCBXQ29sID0gJHtjb2x9IC8gaW5DaGFubmVscyAlIHVuaWZvcm1zLmZpbHRlcl9kaW1zWzFdO1xuICAgICAgbGV0IHhSID0gZjMyKG91dFJvdyAtIHVuaWZvcm1zLnBhZHNbMF0gKyB1bmlmb3Jtcy5kaWxhdGlvbnNbMF0gKiBXUm93KSAvIGYzMih1bmlmb3Jtcy5zdHJpZGVzWzBdKTtcbiAgICAgIGxldCB4QyA9IGYzMihvdXRDb2wgLSB1bmlmb3Jtcy5wYWRzWzFdICsgdW5pZm9ybXMuZGlsYXRpb25zWzFdICogV0NvbCkgLyBmMzIodW5pZm9ybXMuc3RyaWRlc1sxXSk7XG4gICAgICBpZiAoeFIgPCAwLjAgfHwgeFIgPj0gZjMyKCR7eEhlaWdodH0pIHx8IGZyYWN0KHhSKSA+IDAuMCkge1xuICAgICAgICByZXR1cm4gJHt0eXBlfSgwLjApO1xuICAgICAgfVxuICAgICAgaWYgKHhDIDwgMC4wIHx8IHhDID49IGYzMigke3hXaWR0aH0pIHx8IGZyYWN0KHhDKSA+IDAuMCkge1xuICAgICAgICByZXR1cm4gJHt0eXBlfSgwLjApO1xuICAgICAgfVxuICAgICAgbGV0IGlYUiA9IGkzMih4Uik7XG4gICAgICBsZXQgaVhDID0gaTMyKHhDKTtcbiAgICAgIGxldCB4Q2ggPSAke2NvbH0gJSBpbkNoYW5uZWxzO1xuICAgICAgJHtjb29yZEFTbmlwcGV0fVxuICAgICAgcmV0dXJuIHhbZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQsIHZlYzQ8aTMyPih1bmlmb3Jtcy54X3NoYXBlKSkvJHtpbm5lckVsZW1lbnRTaXplfV07YDtcblxuICAgICAgY29uc3Qgc2FtcGxlQSA9IGlzQ2hhbm5lbHNMYXN0ID8gYFxuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtpbm5lckVsZW1lbnRTaXplfTtcbiAgICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1faW5uZXIpIHtcbiAgICAgICAgJHtyZWFkQVNuaXBwZXR9XG4gICAgICB9XG4gICAgICByZXR1cm4gJHt0eXBlfSgwLjApO2AgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtpbm5lckVsZW1lbnRTaXplfTtcbiAgICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcbiAgICAgICAgJHtyZWFkQVNuaXBwZXR9XG4gICAgICB9XG4gICAgICByZXR1cm4gJHt0eXBlfSgwLjApO2A7XG5cbiAgICAgIGNvbnN0IHNhbXBsZVcgPSBgXG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2lubmVyRWxlbWVudFNpemV9O1xuICAgICAgbGV0IGluQ2hhbm5lbHMgPSAke2lzQ2hhbm5lbHNMYXN0ID8gJ2kzMih1bmlmb3Jtcy54X3NoYXBlWzNdKScgOiAnaTMyKHVuaWZvcm1zLnhfc2hhcGVbMV0pJ307XG4gICAgICBsZXQgY29vcmRYID0gdW5pZm9ybXMuZmlsdGVyX2RpbXNbMF0gLSAxIC0gcm93IC8gKHVuaWZvcm1zLmZpbHRlcl9kaW1zWzFdICogaW5DaGFubmVscyk7XG4gICAgICBsZXQgY29vcmRZID0gdW5pZm9ybXMuZmlsdGVyX2RpbXNbMV0gLSAxIC0gKHJvdyAvIGluQ2hhbm5lbHMpICUgdW5pZm9ybXMuZmlsdGVyX2RpbXNbMV07XG4gICAgICBpZiAoJHtcbiAgICAgICAgICBpc0NoYW5uZWxzTGFzdCA/ICdyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXInIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICdyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXInfSAgJiYgY29vcmRYID49IDAgJiYgY29vcmRZID49IDApIHtcbiAgICAgICAgbGV0IHJvd0lubmVyID0gcm93ICUgaW5DaGFubmVscztcbiAgICAgICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGNvb3JkWCwgY29vcmRZLCBjb2wsIHJvd0lubmVyKTtcbiAgICAgICAgJHtnZXRXU25pcHBldChpbm5lckVsZW1lbnRTaXplKX1cbiAgICAgIH1cbiAgICAgIHJldHVybiAke3R5cGV9KDAuMCk7XG4gICAgICBgO1xuXG4gICAgICBjb25zdCBhcHBseUFjdGl2YXRpb24gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhdHRyaWJ1dGVzLCB0eXBlKTtcbiAgICAgIGNvbnN0IHVzZXJDb2RlID0gYFxuICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke3R5cGV9IHtcbiAgICAke2lzQ2hhbm5lbHNMYXN0ID8gc2FtcGxlQSA6IHNhbXBsZVd9XG4gIH1cblxuICBmbiBtbV9yZWFkQihiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke3R5cGV9IHtcbiAgICAke2lzQ2hhbm5lbHNMYXN0ID8gc2FtcGxlVyA6IHNhbXBsZUF9XG4gIH1cblxuICBmbiBtbV93cml0ZShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyLCB2YWx1ZUlucHV0IDogJHt0eXBlfSkge1xuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZX07XG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKSB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZUlucHV0O1xuICAgICAgbGV0IG91dFdpZHRoID0gJHtpc0NoYW5uZWxzTGFzdCA/ICdpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzJdKScgOiAnaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVszXSknfTtcbiAgICAgICR7Y29vcmRSZXNTbmlwcGV0fVxuICAgICAgJHtiaWFzU25pcHBldChhZGRCaWFzKX1cbiAgICAgICR7YXBwbHlBY3RpdmF0aW9ufVxuICAgICAgcmVzdWx0W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkcywgdmVjNDxpMzI+KHVuaWZvcm1zLnJlc3VsdF9zaGFwZSkpLyR7aW5uZXJFbGVtZW50U2l6ZX1dID0gdmFsdWU7XG4gICAgfVxuICB9YDtcbiAgICAgIHJldHVybiB1c2VyQ29kZTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlQ29udjJEVHJhbnNwb3NlTWF0TXVsUHJvZ3JhbUluZm8gPVxuICAgIChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMsIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgICAgZGltQU91dGVyOiBudW1iZXIsIGRpbUJPdXRlcjogbnVtYmVyLCBkaW1Jbm5lcjogbnVtYmVyLCBoYXNCaWFzOiBib29sZWFuLFxuICAgICBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzOiBib29sZWFuKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICAgICAgY29uc3QgaW5DaGFubmVscyA9IGlzQ2hhbm5lbHNMYXN0ID8gaW5wdXRzWzBdLmRpbXNbM10gOiBpbnB1dHNbMF0uZGltc1sxXTtcbiAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IG91dHB1dFNoYXBlWzBdO1xuICAgICAgY29uc3Qgb3V0V2lkdGggPSBpc0NoYW5uZWxzTGFzdCA/IG91dHB1dFNoYXBlWzJdIDogb3V0cHV0U2hhcGVbM107XG4gICAgICBjb25zdCBvdXRIZWlnaHQgPSBpc0NoYW5uZWxzTGFzdCA/IG91dHB1dFNoYXBlWzFdIDogb3V0cHV0U2hhcGVbMl07XG4gICAgICBjb25zdCBvdXRDaGFubmVscyA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0cHV0U2hhcGVbM10gOiBvdXRwdXRTaGFwZVsxXTtcbiAgICAgIC8vIFRPRE86IGVuYWJsZSB2ZWM0IGZvciBOQ0hXXG4gICAgICBjb25zdCBpc1ZlYzQgPSBpc0NoYW5uZWxzTGFzdCAmJiAoaW5DaGFubmVscyAlIDQgPT09IDAgJiYgaW5DaGFubmVscyAlIDMpICYmIG91dENoYW5uZWxzICUgNCA9PT0gMDtcblxuICAgICAgLy8gVE9ETzogZmluZSB0dW5lIHNpemVcbiAgICAgIGNvbnN0IGRpc3BhdGNoWCA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0Q2hhbm5lbHMgOiBvdXRXaWR0aCAqIG91dEhlaWdodDtcbiAgICAgIGNvbnN0IGRpc3BhdGNoWSA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0V2lkdGggKiBvdXRIZWlnaHQgOiBvdXRDaGFubmVscztcbiAgICAgIGNvbnN0IHdvcmtHcm91cFNpemU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFs4LCA4LCAxXTtcbiAgICAgIGNvbnN0IGVsZW1lbnRzUGVyVGhyZWFkID0gZGltQU91dGVyIDw9IDggPyBbNCwgMSwgMV0gOiBbNCwgNCwgMV07XG4gICAgICBjb25zdCBkaXNwYXRjaCA9IFtcbiAgICAgICAgTWF0aC5jZWlsKGRpc3BhdGNoWCAvIHdvcmtHcm91cFNpemVbMF0gLyBlbGVtZW50c1BlclRocmVhZFswXSksXG4gICAgICAgIE1hdGguY2VpbChkaXNwYXRjaFkgLyB3b3JrR3JvdXBTaXplWzFdIC8gZWxlbWVudHNQZXJUaHJlYWRbMV0pLFxuICAgICAgICBNYXRoLmNlaWwoYmF0Y2hTaXplIC8gd29ya0dyb3VwU2l6ZVsyXSAvIGVsZW1lbnRzUGVyVGhyZWFkWzJdKVxuICAgICAgXTtcblxuICAgICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtjb252X2JhY2twcm9wX21tX3dlYmdwdV0gZGlzcGF0Y2ggPSAke2Rpc3BhdGNofWApO1xuXG4gICAgICBjb25zdCBpbm5lckVsZW1lbnRTaXplID0gaXNWZWM0ID8gNCA6IDE7XG4gICAgICBjb25zdCB0aWxlSW5uZXIgPSBNYXRoLm1heCh3b3JrR3JvdXBTaXplWzBdICogaW5uZXJFbGVtZW50U2l6ZSwgd29ya0dyb3VwU2l6ZVsxXSk7XG4gICAgICBjb25zdCBjb21wb25lbnRzID0gaXNWZWM0ID8gNCA6IDE7XG4gICAgICBjb25zdCBmaWx0ZXJEaW1zID1cbiAgICAgICAgICBbYXR0cmlidXRlcy5rZXJuZWxTaGFwZVtpc0NoYW5uZWxzTGFzdCA/IDEgOiAyXSwgYXR0cmlidXRlcy5rZXJuZWxTaGFwZVtpc0NoYW5uZWxzTGFzdCA/IDIgOiAzXV07XG4gICAgICBjb25zdCBlZmZlY3RpdmVGaWx0ZXJEaW1zID0gW1xuICAgICAgICBmaWx0ZXJEaW1zWzBdICsgKGF0dHJpYnV0ZXMuZGlsYXRpb25zWzBdIDw9IDEgPyAwIDogKGZpbHRlckRpbXNbMF0gLSAxKSAqIChhdHRyaWJ1dGVzLmRpbGF0aW9uc1swXSAtIDEpKSxcbiAgICAgICAgZmlsdGVyRGltc1sxXSArIChhdHRyaWJ1dGVzLmRpbGF0aW9uc1sxXSA8PSAxID8gMCA6IChmaWx0ZXJEaW1zWzFdIC0gMSkgKiAoYXR0cmlidXRlcy5kaWxhdGlvbnNbMV0gLSAxKSlcbiAgICAgIF07XG4gICAgICBjb25zdCBwYWRzID0gW1xuICAgICAgICBlZmZlY3RpdmVGaWx0ZXJEaW1zWzBdIC0gMSAtIE1hdGguZmxvb3IoKGF0dHJpYnV0ZXMucGFkc1swXSArIGF0dHJpYnV0ZXMucGFkc1syXSkgLyAyKSxcbiAgICAgICAgZWZmZWN0aXZlRmlsdGVyRGltc1sxXSAtIDEgLSBNYXRoLmZsb29yKChhdHRyaWJ1dGVzLnBhZHNbMV0gKyBhdHRyaWJ1dGVzLnBhZHNbM10pIC8gMilcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBkaW1BT3V0ZXJ9LCB7dHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGRpbUJPdXRlcn0sXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZGltSW5uZXJ9LCB7dHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuc3RyaWRlc30sXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogYXR0cmlidXRlcy5kaWxhdGlvbnN9LCB7dHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGZpbHRlckRpbXN9LFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IHBhZHN9XG4gICAgICBdO1xuICAgICAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YShhdHRyaWJ1dGVzLCBwcm9ncmFtVW5pZm9ybXMpO1xuICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zKSk7XG5cbiAgICAgIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWydyYW5rJywgJ3JhbmsnXTtcbiAgICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1syXS5kaW1zKSk7XG4gICAgICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3JhbmsnKTtcbiAgICAgIH1cbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSk7XG5cbiAgICAgIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgICAgICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICAgICAgY29uc3QgdyA9IGlucHV0VmFyaWFibGUoJ3cnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zLmxlbmd0aCwgMSk7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdyZXN1bHQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgICAgIGNvbnN0IGlucHV0VmFyaWFibGVzID0gW3gsIHddO1xuXG4gICAgICAgIGxldCBkZWNsYXJlRnVuY3Rpb25zID0gJyc7XG4gICAgICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICAgICAgY29uc3QgYmlhcyA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgICAgICAgaW5wdXRWYXJpYWJsZXMucHVzaChiaWFzKTtcbiAgICAgICAgICBkZWNsYXJlRnVuY3Rpb25zICs9IGBcbiAgICAgICAgICBmbiBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiAke2JpYXMudHlwZS52YWx1ZX0ge1xuICAgICAgICAgICAgcmV0dXJuIGJpYXNbY29vcmRzLiR7aXNDaGFubmVsc0xhc3QgPyAndycgOiAneSd9JHtpc1ZlYzQgPyAnLyA0JyA6ICcnfV07XG4gICAgICAgICAgfWA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICAgICAge25hbWU6ICdkaW1fYV9vdXRlcicsIHR5cGU6ICdpMzInfSwge25hbWU6ICdkaW1fYl9vdXRlcicsIHR5cGU6ICdpMzInfSwge25hbWU6ICdkaW1faW5uZXInLCB0eXBlOiAnaTMyJ30sXG4gICAgICAgICAge25hbWU6ICdzdHJpZGVzJywgdHlwZTogJ2kzMicsIGxlbmd0aDogMn0sIHtuYW1lOiAnZGlsYXRpb25zJywgdHlwZTogJ2kzMicsIGxlbmd0aDogMn0sXG4gICAgICAgICAge25hbWU6ICdmaWx0ZXJfZGltcycsIHR5cGU6ICdpMzInLCBsZW5ndGg6IGZpbHRlckRpbXMubGVuZ3RofSxcbiAgICAgICAgICB7bmFtZTogJ3BhZHMnLCB0eXBlOiAnaTMyJywgbGVuZ3RoOiBwYWRzLmxlbmd0aH1cbiAgICAgICAgXTtcbiAgICAgICAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zKGF0dHJpYnV0ZXMsIHVuaWZvcm1zKTtcbiAgICAgICAgY29uc3QgZWxlbVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlLCAxKTtcbiAgICAgICAgaWYgKGVsZW1UeXBlICE9PSAnZjE2JyAmJiBlbGVtVHlwZSAhPT0gJ2YzMicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGVsZW1UeXBlICR7ZWxlbVR5cGV9IGlzIG5vdCBzdXBwb3J0ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgJHt1dGlsRnVuY3Rpb25zKCd1bmlmb3Jtcy5yZXN1bHRfc3RyaWRlcycpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfTtcbiAgICAgICAgJHtkZWNsYXJlRnVuY3Rpb25zfVxuICAgICAgICAke2NvbnYyZFRyYW5zcG9zZUNvbW1vblNuaXBwZXQoaXNDaGFubmVsc0xhc3QsIGhhc0JpYXMsIGF0dHJpYnV0ZXMsIHgudHlwZS52YWx1ZSwgaW5uZXJFbGVtZW50U2l6ZSl9XG4gICAgICAgICR7XG4gICAgICAgICAgICBpc1ZlYzQgPyBtYWtlTWF0TXVsUGFja2VkVmVjNFNvdXJjZShcbiAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1BlclRocmVhZCwgd29ya0dyb3VwU2l6ZSwgZWxlbVR5cGUsIHVuZGVmaW5lZCwgIWlzQ2hhbm5lbHNMYXN0LCB0aWxlSW5uZXIpIDpcbiAgICAgICAgICAgICAgICAgICAgIG1ha2VNYXRNdWxQYWNrZWRTb3VyY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNQZXJUaHJlYWQsIHdvcmtHcm91cFNpemUsIGVsZW1UeXBlLCB1bmRlZmluZWQsICFpc0NoYW5uZWxzTGFzdCwgdGlsZUlubmVyLCBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHMpfWA7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnQ29udjJEVHJhbnNwb3NlTWF0TXVsJyxcbiAgICAgICAgc2hhZGVyQ2FjaGU6XG4gICAgICAgICAgICB7aGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX07JHtlbGVtZW50c1BlclRocmVhZH07JHt3b3JrR3JvdXBTaXplfTske2lzVmVjNH1gLCBpbnB1dERlcGVuZGVuY2llc30sXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX1dLFxuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBkaXNwYXRjaFswXSwgeTogZGlzcGF0Y2hbMV0sIHo6IGRpc3BhdGNoWzJdfSxcbiAgICAgICAgICBwcm9ncmFtVW5pZm9ybXNcbiAgICAgICAgfSksXG4gICAgICAgIGdldFNoYWRlclNvdXJjZVxuICAgICAgfTtcbiAgICB9O1xuIiwgIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLy8gc2FtcGxlZCBmcm9tIFtAdGVuc29yZmxvdy90ZmpzXSB0ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9jb252X2JhY2twcm9wX3dlYmdwdS50c1xuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge0xPR19ERUJVR30gZnJvbSAnLi4vLi4vLi4vbG9nJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsIFVuaWZvcm1zQXJyYXlUeXBlfSBmcm9tICcuLi9jb21tb24nO1xuaW1wb3J0IHtDb252VHJhbnNwb3NlQXR0cmlidXRlc30gZnJvbSAnLi4vY29udi10cmFuc3Bvc2UnO1xuXG5jb25zdCBjcmVhdGVDb252VHJhbnNwb3NlMkRPcFByb2dyYW1TaGFkZXJTb3VyY2UgPVxuICAgIChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlciwgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgaGFzQmlhczogYm9vbGVhbixcbiAgICAgaXMxRGltZW5zaW9uRGlzcGF0Y2g6IGJvb2xlYW4sIGlzVmVjNCA9IGZhbHNlLCBkYXRhVHlwZTogc3RyaW5nLCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUsXG4gICAgIGlzQ2hhbm5lbHNMYXN0ID0gZmFsc2UpOiBzdHJpbmcgPT4ge1xuICAgICAgY29uc3Qgcm93RGltID0gaXNDaGFubmVsc0xhc3QgPyAxIDogMjtcbiAgICAgIGNvbnN0IGNvbERpbSA9IGlzQ2hhbm5lbHNMYXN0ID8gMiA6IDM7XG4gICAgICBjb25zdCBjaGFubmVsRGltID0gaXNDaGFubmVsc0xhc3QgPyAzIDogMTtcbiAgICAgIGNvbnN0IHdvcmtQZXJUaHJlYWQgPSBpc1ZlYzQgPyAyIDogMTtcblxuICAgICAgbGV0IGRlY2xhcmVGdW5jdGlvbnMgPSBgXG4gIGZuIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4IDogdTMyLCB2YWx1ZSA6ICR7aXNWZWM0ID8gYHZlYzQ8JHtkYXRhVHlwZX0+YCA6IGRhdGFUeXBlfSkge1xuICAgIHJlc3VsdFtmbGF0SW5kZXhdID0gJHtpc1ZlYzQgPyBgdmVjNDwke2RhdGFUeXBlfT5gIDogZGF0YVR5cGV9KHZhbHVlKTtcbiAgfWA7XG4gICAgICBpZiAoaGFzQmlhcykge1xuICAgICAgICBkZWNsYXJlRnVuY3Rpb25zICs9IGBcbiAgICBmbiBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzIDogdmVjNDx1MzI+KSAtPiAke2lzVmVjNCA/IGB2ZWM0PCR7ZGF0YVR5cGV9PmAgOiBkYXRhVHlwZX0ge1xuICAgICAgcmV0dXJuIGJpYXNbY29vcmRzLiR7aXNDaGFubmVsc0xhc3QgPyAndycgOiAneSd9JHtpc1ZlYzQgPyAnLyA0JyA6ICcnfV07XG4gICAgfWA7XG4gICAgICB9XG4gICAgICBjb25zdCBjb21wb25lbnRzID0gaXNWZWM0ID8gNCA6IDE7XG4gICAgICBjb25zdCB3ID0gaW5wdXRWYXJpYWJsZSgnVycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICAgIGNvbnN0IGR5ID0gaW5wdXRWYXJpYWJsZSgnRHknLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFtkeSwgd107XG4gICAgICBpZiAoaGFzQmlhcykge1xuICAgICAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIFtvdXRwdXRTaGFwZVtjaGFubmVsRGltXV0ubGVuZ3RoLCBjb21wb25lbnRzKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgncmVzdWx0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuXG4gICAgICBjb25zdCBjb2RlU25pcHBldDQgPSBge1xuICAgICAgICBsZXQgYmF0Y2g6IHUzMiA9ICR7aXMxRGltZW5zaW9uRGlzcGF0Y2ggPyAnZ2xvYmFsX2lkLnonIDogJ3dvcmtncm91cF9pZC56J30gLyB1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbMV07XG4gICAgICAgIGxldCByID0gJHtpczFEaW1lbnNpb25EaXNwYXRjaCA/ICdnbG9iYWxfaWQueicgOiAnd29ya2dyb3VwX2lkLnonfSAlIHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsxXTtcbiAgICAgICAgbGV0IGMgPSAke2lzMURpbWVuc2lvbkRpc3BhdGNoID8gJ2dsb2JhbF9pZC55JyA6ICd3b3JrZ3JvdXBfaWQueSd9ICogJHt3b3JrUGVyVGhyZWFkfTtcbiAgICAgICAgbGV0IGQxOiB1MzIgPSAke2lzMURpbWVuc2lvbkRpc3BhdGNoID8gJ2dsb2JhbF9pZC54JyA6ICd3b3JrZ3JvdXBfaWQueCd9ICogNDtcblxuICAgICAgICBsZXQgZHlDb3JuZXIgPSB2ZWMyPGkzMj4oaTMyKHIpLCBpMzIoYykpIC0gdmVjMjxpMzI+KHVuaWZvcm1zLnBhZHMpO1xuXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQyKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBjb21wdXRlIGR4KHhSLCB4QywgZDEpLlxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgICAgdmFyIGRvdFByb2Q6IGFycmF5PHZlYzQ8JHtkYXRhVHlwZX0+LCAke3dvcmtQZXJUaHJlYWR9PjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke3dvcmtQZXJUaHJlYWR9OyBpKyspIHtcbiAgICAgICAgICBkb3RQcm9kW2ldID0gdmVjNDwke2RhdGFUeXBlfT4oMC4wKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB3UjogdTMyID0gMDsgd1IgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1swXTsgd1IgPSB3UiArIDEpIHtcbiAgICAgICAgICB2YXIgZHlSID0gKCR7ZGF0YVR5cGV9KGR5Q29ybmVyLngpICsgJHtkYXRhVHlwZX0od1IpKSAvICR7ZGF0YVR5cGV9KHVuaWZvcm1zLnN0cmlkZXMueCk7XG4gICAgICAgICAgbGV0IHdSUGVybSA9IHVuaWZvcm1zLmZpbHRlcl9kaW1zWzBdIC0gMSAtIHdSO1xuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49ICR7ZGF0YVR5cGV9KHVuaWZvcm1zLkR5X3NoYXBlWzFdKSB8fFxuICAgICAgICAgICAgICBmcmFjdChkeVIpID4gMC4wIHx8IHdSUGVybSA8IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgaWR5UjogdTMyID0gdTMyKGR5Uik7XG5cbiAgICAgICAgICBmb3IgKHZhciB3QzogdTMyID0gMDsgd0MgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1sxXTsgd0MgPSB3QyArIDEpIHtcbiAgICAgICAgICAgIGxldCBkeUMgPSAoJHtkYXRhVHlwZX0oZHlDb3JuZXIueSkgKyAke2RhdGFUeXBlfSh3QykpIC8gJHtkYXRhVHlwZX0odW5pZm9ybXMuc3RyaWRlcy55KTtcbiAgICAgICAgICAgIGxldCBkeUMyID0gKCR7ZGF0YVR5cGV9KGR5Q29ybmVyLnkpICsgMS4wICsgJHtkYXRhVHlwZX0od0MpKSAvICR7ZGF0YVR5cGV9KHVuaWZvcm1zLnN0cmlkZXMueSk7XG4gICAgICAgICAgICBsZXQgd0NQZXJtID0gdW5pZm9ybXMuZmlsdGVyX2RpbXNbMV0gLSAxIC0gd0M7XG4gICAgICAgICAgICBpZiAod0NQZXJtIDwgMCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiRHlDVmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBiRHlDVmFsMiA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSAke2RhdGFUeXBlfSh1bmlmb3Jtcy5EeV9zaGFwZVsyXSkgfHxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XG4gICAgICAgICAgICAgIGJEeUNWYWwgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkeUMyIDwgMC4wIHx8IGR5QzIgPj0gJHtkYXRhVHlwZX0odW5pZm9ybXMuRHlfc2hhcGVbMl0pIHx8XG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDMikgPiAwLjApIHtcbiAgICAgICAgICAgICAgYkR5Q1ZhbDIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGlkeUM6IHUzMiA9IHUzMihkeUMpO1xuICAgICAgICAgICAgbGV0IGlkeUMyOiB1MzIgPSB1MzIoZHlDMik7XG4gICAgICAgICAgICBpZiAoYkR5Q1ZhbCAmJiBiRHlDVmFsMikge1xuICAgICAgICAgICAgICBsZXQgZDJMZW5ndGggPSB1bmlmb3Jtcy5EeV9zaGFwZVszXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgZDIgOnUzMiA9IDA7IGQyIDwgZDJMZW5ndGg7IGQyID0gZDIgKyA0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTAgPSAke3cuZ2V0KCd1MzIod1JQZXJtKScsICd1MzIod0NQZXJtKScsICdkMScsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMSA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxICsgMScsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMiA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxICsgMicsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMyA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxICsgMycsICdkMicpfTtcblxuICAgICAgICAgICAgICAgIHZhciB4VmFsdWUgPSAke2R5LmdldCgnYmF0Y2gnLCAnaWR5UicsICdpZHlDJywgJ2QyJyl9O1xuICAgICAgICAgICAgICAgIGxldCB0bXB2YWwgPSB2ZWM0PCR7ZGF0YVR5cGV9Pihkb3QoeFZhbHVlLCB3VmFsdWUwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUzKSk7XG4gICAgICAgICAgICAgICAgZG90UHJvZFswXSA9IGRvdFByb2RbMF0gKyB0bXB2YWw7XG5cbiAgICAgICAgICAgICAgICB4VmFsdWUgPSAgJHtkeS5nZXQoJ2JhdGNoJywgJ2lkeVInLCAnaWR5QzInLCAnZDInKX07XG5cbiAgICAgICAgICAgICAgICBkb3RQcm9kWzFdID0gZG90UHJvZFsxXSArIHZlYzQ8JHtkYXRhVHlwZX0+KGRvdCh4VmFsdWUsIHdWYWx1ZTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChiRHlDVmFsKSB7XG4gICAgICAgICAgICAgIGxldCBkMkxlbmd0aCA9IHVuaWZvcm1zLkR5X3NoYXBlWyR7Y2hhbm5lbERpbX1dO1xuICAgICAgICAgICAgICBmb3IgKHZhciBkMjogdTMyID0gMDsgZDIgPCBkMkxlbmd0aDsgZDIgPSBkMiArIDQpIHtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMCA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxJywgJ2QyJyl9O1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUxID0gJHt3LmdldCgndTMyKHdSUGVybSknLCAndTMyKHdDUGVybSknLCAnZDEgKyAxJywgJ2QyJyl9O1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUyID0gJHt3LmdldCgndTMyKHdSUGVybSknLCAndTMyKHdDUGVybSknLCAnZDEgKyAyJywgJ2QyJyl9O1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUzID0gJHt3LmdldCgndTMyKHdSUGVybSknLCAndTMyKHdDUGVybSknLCAnZDEgKyAzJywgJ2QyJyl9O1xuXG4gICAgICAgICAgICAgICAgdmFyIHhWYWx1ZSA9ICR7ZHkuZ2V0KCdiYXRjaCcsICdpZHlSJywgJ2lkeUMnLCAnZDInKX07XG4gICAgICAgICAgICAgICAgbGV0IHRtcHZhbCA9IHZlYzQ8JHtkYXRhVHlwZX0+KGRvdCh4VmFsdWUsIHdWYWx1ZTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTMpKTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kWzBdID0gZG90UHJvZFswXSArIHRtcHZhbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChiRHlDVmFsMikge1xuICAgICAgICAgICAgICBsZXQgZDJMZW5ndGggPSB1bmlmb3Jtcy5EeV9zaGFwZVszXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgZDI6IHUzMiA9IDA7IGQyIDwgZDJMZW5ndGg7IGQyID0gZDIgKyA0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTAgPSAke3cuZ2V0KCd1MzIod1JQZXJtKScsICd1MzIod0NQZXJtKScsICdkMScsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMSA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxICsgMScsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMiA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxICsgMicsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMyA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxICsgMycsICdkMicpfTtcblxuICAgICAgICAgICAgICAgIHZhciB4VmFsdWUgPSAke2R5LmdldCgnYmF0Y2gnLCAnaWR5UicsICdpZHlDMicsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgdG1wdmFsID0gdmVjNDwke2RhdGFUeXBlfT4oZG90KHhWYWx1ZSwgd1ZhbHVlMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMykpO1xuICAgICAgICAgICAgICAgIGRvdFByb2RbMV0gPSBkb3RQcm9kWzFdICsgdG1wdmFsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7d29ya1BlclRocmVhZH07IGkgPSBpICsgMSkge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGRvdFByb2RbaV0gKyAke2hhc0JpYXMgPyAnYmlhc1tjK2ldJyA6IGB2ZWM0PCR7ZGF0YVR5cGV9PigwLjApYH07XG4gICAgICAgICAgJHtvdXRwdXQuc2V0KCdiYXRjaCcsICdyJywgJ2MgKyBpJywgJ2QxJywgJ3ZhbHVlJyl9O1xuICAgICAgICB9XG4gICAgICB9YDtcbiAgICAgIGNvbnN0IGNvZGVTbmlwcGV0ID0gYFxuICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgICAgICAgIGxldCBiYXRjaCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dEluZGljZXMnLCAwKX07XG4gICAgICAgICAgbGV0IGQxID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0SW5kaWNlcycsIGNoYW5uZWxEaW0pfTtcbiAgICAgICAgICBsZXQgciA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dEluZGljZXMnLCByb3dEaW0pfTtcbiAgICAgICAgICBsZXQgYyA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dEluZGljZXMnLCBjb2xEaW0pfTtcbiAgICAgICAgICBsZXQgZHlDb3JuZXIgPSB2ZWMyPGkzMj4oaTMyKHIpLCBpMzIoYykpIC0gdW5pZm9ybXMucGFkcztcbiAgICAgICAgICBsZXQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcbiAgICAgICAgICBsZXQgZHlDQ29ybmVyID0gZHlDb3JuZXIueTtcbiAgICAgICAgICBsZXQgZ3JvdXBJZCA9IGQxIC8gdW5pZm9ybXMub3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cDtcbiAgICAgICAgICBsZXQgd091dENoYW5uZWwgPSBkMSAtIGdyb3VwSWQgKiB1bmlmb3Jtcy5vdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xuICAgICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQyKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBjb21wdXRlIGR4KHhSLCB4QywgZDEpLlxuICAgICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxuICAgICAgICAgIHZhciBkb3RQcm9kID0gJHtkYXRhVHlwZX0oMC4wKTtcbiAgICAgICAgICBmb3IgKHZhciB3UjogdTMyID0gMDsgd1IgPCB1bmlmb3Jtcy5lZmZlY3RpdmVfZmlsdGVyX2RpbXMueDsgd1IgPSB3UiArIDEpIHtcbiAgICAgICAgICAgIGlmICh3UiAlIHVuaWZvcm1zLmRpbGF0aW9ucy54ICE9IDApIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZHlSID0gKCR7ZGF0YVR5cGV9KGR5UkNvcm5lcikgKyAke2RhdGFUeXBlfSh3UikpIC8gJHtkYXRhVHlwZX0odW5pZm9ybXMuc3RyaWRlc1swXSk7XG4gICAgICAgICAgICBsZXQgd1JQZXJtID0gdW5pZm9ybXMuZmlsdGVyX2RpbXMueCAtIDEgLSB3UiAvIHVuaWZvcm1zLmRpbGF0aW9ucy54O1xuICAgICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gJHtkYXRhVHlwZX0odW5pZm9ybXMuRHlfc2hhcGVbJHtyb3dEaW19XSkgfHwgZnJhY3QoZHlSKSA+IDAuMCB8fFxuICAgICAgICAgICAgICAgIHdSUGVybSA8IDApIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaWR5UjogdTMyID0gdTMyKGR5Uik7XG5cbiAgICAgICAgICAgIGZvciAodmFyIHdDOiB1MzIgPSAwOyB3QyA8IHVuaWZvcm1zLmVmZmVjdGl2ZV9maWx0ZXJfZGltcy55OyB3QyA9IHdDICsgMSkge1xuICAgICAgICAgICAgICBpZiAod0MgJSB1bmlmb3Jtcy5kaWxhdGlvbnMueSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IGR5QyA9ICgke2RhdGFUeXBlfShkeUNDb3JuZXIpICsgJHtkYXRhVHlwZX0od0MpKSAvICR7ZGF0YVR5cGV9KHVuaWZvcm1zLnN0cmlkZXMueSk7XG4gICAgICAgICAgICAgIGxldCB3Q1Blcm0gPSB1bmlmb3Jtcy5maWx0ZXJfZGltcy55IC0gMSAtIHdDIC8gdW5pZm9ybXMuZGlsYXRpb25zLnk7XG4gICAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49ICR7ZGF0YVR5cGV9KHVuaWZvcm1zLkR5X3NoYXBlWyR7Y29sRGltfV0pIHx8XG4gICAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wIHx8IHdDUGVybSA8IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgaWR5QzogdTMyID0gdTMyKGR5Qyk7XG4gICAgICAgICAgICAgIHZhciBpbnB1dENoYW5uZWwgPSBncm91cElkICogdW5pZm9ybXMuaW5wdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xuICAgICAgICAgICAgICBmb3IgKHZhciBkMjogdTMyID0gMDsgZDIgPCB1bmlmb3Jtcy5pbnB1dF9jaGFubmVsc19wZXJfZ3JvdXA7IGQyID0gZDIgKyAxKSB7XG4gICAgICAgICAgICAgICAgbGV0IHhWYWx1ZSA9ICR7XG4gICAgICAgICAgaXNDaGFubmVsc0xhc3QgPyBkeS5nZXQoJ2JhdGNoJywgJ2lkeVInLCAnaWR5QycsICdpbnB1dENoYW5uZWwnKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBkeS5nZXQoJ2JhdGNoJywgJ2lucHV0Q2hhbm5lbCcsICdpZHlSJywgJ2lkeUMnKX07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZSA9ICR7dy5nZXQoJ2lucHV0Q2hhbm5lbCcsICd3T3V0Q2hhbm5lbCcsICd1MzIod1JQZXJtKScsICd1MzIod0NQZXJtKScpfTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIHhWYWx1ZSAqIHdWYWx1ZTtcbiAgICAgICAgICAgICAgICBpbnB1dENoYW5uZWwgPSBpbnB1dENoYW5uZWwgKyAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCB2YWx1ZSA9IGRvdFByb2QgKyAke2hhc0JpYXMgPyAnYmlhc1tkMV0nIDogYCR7ZGF0YVR5cGV9KDAuMClgfTtcbiAgICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpfTtcbiAgICAgICAgYDtcblxuICAgICAgcmV0dXJuIGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcmlhYmxlcywgb3V0cHV0KX1cbiAgJHtkZWNsYXJlRnVuY3Rpb25zfVxuXG4gICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX07XG4gICR7aXNWZWM0ID8gY29kZVNuaXBwZXQ0IDogY29kZVNuaXBwZXR9fWA7XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUNvbnZUcmFuc3Bvc2UyRFByb2dyYW1JbmZvID1cbiAgICAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzLFxuICAgICBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbj86IChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pID0+IG51bWJlcltdKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPiAyO1xuICAgICAgLy8gY29uc3QgaXNDaGFubmVsc0xhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBhdHRyaWJ1dGVzLm91dHB1dFNoYXBlO1xuICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcblxuICAgICAgLy8gY29uc3QgaW5DaGFubmVscyA9IGlucHV0c1swXS5kaW1zW2lzQ2hhbm5lbHNMYXN0ID8gMyA6IDFdO1xuICAgICAgLy8gVE9ETyBFbmFibGUgaXNWZWM0IGZvciBwZXJmb3JtYW5jZVxuICAgICAgLy8gRGlzYWJsZWQgZHVlIHRvIHdlaWdodCBtYXRyaXggbGF5b3V0IGlzc3VlXG4gICAgICAvLyBjb25zdCBpc1ZlYzQgPSBhdHRyaWJ1dGVzLmdyb3VwID09PSAxICYmIGlzQ2hhbm5lbHNMYXN0ICYmIGluQ2hhbm5lbHMgJSA0ID09PSAwICYmIG91dENoYW5uZWxzICUgNCA9PT0gMDtcbiAgICAgIGNvbnN0IGRpc3BhdGNoID0gW1xuICAgICAgICBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0KSxcbiAgICAgICAgMSxcbiAgICAgICAgMSxcbiAgICAgIF07XG4gICAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW2NvbnYyZF9iYWNrcHJvcF93ZWJncHVdIGRpc3BhdGNoID0gJHtkaXNwYXRjaH1gKTtcblxuICAgICAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICAgICAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3JhbmsnLCAncmFuayddO1xuICAgICAgY29uc3Qgc3RyaWRlcyA9IFthdHRyaWJ1dGVzLnN0cmlkZXNbMF0sIGF0dHJpYnV0ZXMuc3RyaWRlc1sxXV07XG4gICAgICBjb25zdCBmaWx0ZXJEaW1zID1cbiAgICAgICAgICBbYXR0cmlidXRlcy5rZXJuZWxTaGFwZVtpc0NoYW5uZWxzTGFzdCA/IDEgOiAyXSwgYXR0cmlidXRlcy5rZXJuZWxTaGFwZVtpc0NoYW5uZWxzTGFzdCA/IDIgOiAzXV07XG4gICAgICBjb25zdCBkaWxhdGlvbnMgPSBbYXR0cmlidXRlcy5kaWxhdGlvbnNbMF0sIGF0dHJpYnV0ZXMuZGlsYXRpb25zWzFdXTtcbiAgICAgIGNvbnN0IGVmZmVjdGl2ZUZpbHRlckRpbXMgPSBbXG4gICAgICAgIGZpbHRlckRpbXNbMF0gK1xuICAgICAgICAgICAgKGF0dHJpYnV0ZXMuZGlsYXRpb25zWzBdIDw9IDEgP1xuICAgICAgICAgICAgICAgICAwIDpcbiAgICAgICAgICAgICAgICAgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGVbaXNDaGFubmVsc0xhc3QgPyAxIDogMl0gLSAxKSAqIChhdHRyaWJ1dGVzLmRpbGF0aW9uc1swXSAtIDEpKSxcbiAgICAgICAgZmlsdGVyRGltc1sxXSArXG4gICAgICAgICAgICAoYXR0cmlidXRlcy5kaWxhdGlvbnNbMV0gPD0gMSA/XG4gICAgICAgICAgICAgICAgIDAgOlxuICAgICAgICAgICAgICAgICAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZVtpc0NoYW5uZWxzTGFzdCA/IDIgOiAzXSAtIDEpICogKGF0dHJpYnV0ZXMuZGlsYXRpb25zWzFdIC0gMSkpXG4gICAgICBdO1xuICAgICAgY29uc3QgcGFkcyA9IFtcbiAgICAgICAgZWZmZWN0aXZlRmlsdGVyRGltc1swXSAtIDEgLSBNYXRoLmZsb29yKChhdHRyaWJ1dGVzLnBhZHNbMF0gKyBhdHRyaWJ1dGVzLnBhZHNbMl0pIC8gMiksXG4gICAgICAgIGVmZmVjdGl2ZUZpbHRlckRpbXNbMV0gLSAxIC0gTWF0aC5mbG9vcihhdHRyaWJ1dGVzLnBhZHNbMV0gKyBhdHRyaWJ1dGVzLnBhZHNbM10pIC8gMlxuICAgICAgXTtcblxuICAgICAgY29uc3QgaXNWZWM0ID0gZmFsc2U7XG4gICAgICBjb25zdCBncm91cCA9IGF0dHJpYnV0ZXMuZ3JvdXA7XG4gICAgICBjb25zdCB3U2hhcGUgPSBpbnB1dHNbMV0uZGltcztcbiAgICAgIGNvbnN0IGlucHV0Q2hhbm5lbHNQZXJHcm91cCA9IHdTaGFwZVswXSAvIGdyb3VwO1xuICAgICAgY29uc3Qgb3V0cHV0Q2hhbm5lbHNQZXJHcm91cCA9IHdTaGFwZVsxXTtcblxuICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplfSwge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogc3RyaWRlc30sXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGZpbHRlckRpbXN9LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBkaWxhdGlvbnN9LFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBlZmZlY3RpdmVGaWx0ZXJEaW1zfSwge3R5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBwYWRzfSxcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogaW5wdXRDaGFubmVsc1Blckdyb3VwfSwge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0Q2hhbm5lbHNQZXJHcm91cH0sXG4gICAgICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1swXS5kaW1zLCBpbnB1dHNbMV0uZGltcylcbiAgICAgIF07XG4gICAgICBpZiAoaGFzQmlhcykge1xuICAgICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMl0uZGltcykpO1xuICAgICAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCdyYW5rJyk7XG4gICAgICB9XG4gICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSkpO1xuXG4gICAgICBjb25zdCBpczFEaW1lbnNpb25EaXNwYXRjaCA9IGRpc3BhdGNoWzFdID09PSAxICYmIGRpc3BhdGNoWzJdID09PSAxO1xuICAgICAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgICAgICB7bmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ3N0cmlkZXMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBzdHJpZGVzLmxlbmd0aH0sXG4gICAgICAgICAge25hbWU6ICdmaWx0ZXJfZGltcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGZpbHRlckRpbXMubGVuZ3RofSxcbiAgICAgICAgICB7bmFtZTogJ2RpbGF0aW9ucycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGZpbHRlckRpbXMubGVuZ3RofSxcbiAgICAgICAgICB7bmFtZTogJ2VmZmVjdGl2ZV9maWx0ZXJfZGltcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGVmZmVjdGl2ZUZpbHRlckRpbXMubGVuZ3RofSxcbiAgICAgICAgICB7bmFtZTogJ3BhZHMnLCB0eXBlOiAnaTMyJywgbGVuZ3RoOiBwYWRzLmxlbmd0aH0sIHtuYW1lOiAnaW5wdXRfY2hhbm5lbHNfcGVyX2dyb3VwJywgdHlwZTogJ3UzMid9LFxuICAgICAgICAgIHtuYW1lOiAnb3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cCcsIHR5cGU6ICd1MzInfVxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xuICAgICAgICByZXR1cm4gYCR7XG4gICAgICAgICAgICBjcmVhdGVDb252VHJhbnNwb3NlMkRPcFByb2dyYW1TaGFkZXJTb3VyY2UoXG4gICAgICAgICAgICAgICAgc2hhZGVySGVscGVyLCBpbnB1dHMsIG91dHB1dFNoYXBlLCBoYXNCaWFzLCBpczFEaW1lbnNpb25EaXNwYXRjaCwgaXNWZWM0LCBkYXRhVHlwZSwgdW5pZm9ybXMsXG4gICAgICAgICAgICAgICAgaXNDaGFubmVsc0xhc3QpfWA7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ0NvbnZUcmFuc3Bvc2UyRCcsXG4gICAgICAgIHNoYWRlckNhY2hlOiB7aGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX07YCwgaW5wdXREZXBlbmRlbmNpZXN9LFxuICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBkaXNwYXRjaFswXSwgeTogZGlzcGF0Y2hbMV0sIHo6IGRpc3BhdGNoWzJdfSxcbiAgICAgICAgICBvdXRwdXRzOiBbe1xuICAgICAgICAgICAgZGltczogc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24gPyBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbihvdXRwdXRTaGFwZSkgOiBvdXRwdXRTaGFwZSxcbiAgICAgICAgICAgIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGVcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBwcm9ncmFtVW5pZm9ybXNcbiAgICAgICAgfSksXG4gICAgICAgIGdldFNoYWRlclNvdXJjZVxuICAgICAgfTtcbiAgICB9O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHR9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVDb252MkRUcmFuc3Bvc2VNYXRNdWxQcm9ncmFtSW5mb30gZnJvbSAnLi8zcmQtcGFydHkvY29udl9iYWNrcHJvcF9tbV93ZWJncHUnO1xuaW1wb3J0IHtjcmVhdGVDb252VHJhbnNwb3NlMkRQcm9ncmFtSW5mb30gZnJvbSAnLi8zcmQtcGFydHkvY29udl9iYWNrcHJvcF93ZWJncHUnO1xuaW1wb3J0IHtDb252QXR0cmlidXRlc30gZnJvbSAnLi9jb252JztcbmltcG9ydCB7cGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzfSBmcm9tICcuL2Z1c2UtdXRpbHMnO1xuaW1wb3J0IHtjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mb30gZnJvbSAnLi90cmFuc3Bvc2UnO1xuXG5jb25zdCBjb21wdXRlVG90YWxQYWQgPVxuICAgIChpbkRpbTogbnVtYmVyLCBzdHJpZGU6IG51bWJlciwgYWRqOiBudW1iZXIsIGtlcm5lbDogbnVtYmVyLCBkaWxhdGlvbjogbnVtYmVyLCBvdXRTaXplOiBudW1iZXIpID0+XG4gICAgICAgIChpbkRpbSAtIDEpICogc3RyaWRlICsgYWRqICsgKGtlcm5lbCAtIDEpICogZGlsYXRpb24gKyAxIC0gb3V0U2l6ZTtcblxuY29uc3QgZGlzdHJpYnV0ZVBhZGRpbmcgPSAodG90YWxQYWQ6IG51bWJlciwgYXV0b1BhZDogc3RyaW5nLCBwYWRzOiBudW1iZXJbXSwgaGVhZDogbnVtYmVyLCB0YWlsOiBudW1iZXIpID0+IHtcbiAgY29uc3Qgc21hbGxQYWQgPSBNYXRoLmZsb29yKHRvdGFsUGFkIC8gMik7XG4gIGlmIChhdXRvUGFkID09PSAnU0FNRV9VUFBFUicpIHtcbiAgICBwYWRzW2hlYWRdID0gc21hbGxQYWQ7XG4gICAgcGFkc1t0YWlsXSA9IHRvdGFsUGFkIC0gc21hbGxQYWQ7XG4gIH0gZWxzZSBpZiAoYXV0b1BhZCA9PT0gJ1NBTUVfTE9XRVInKSB7XG4gICAgcGFkc1toZWFkXSA9IHRvdGFsUGFkIC0gc21hbGxQYWQ7XG4gICAgcGFkc1t0YWlsXSA9IHNtYWxsUGFkO1xuICB9XG59O1xuXG5jb25zdCBjYWxjdWxhdGVPdXRwdXRTaGFwZUFuZFBhZHMgPVxuICAgIChpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBkaWxhdGlvbnM6IHJlYWRvbmx5IG51bWJlcltdLCBhdXRvUGFkOiBzdHJpbmcsXG4gICAgIGdyb3VwOiBudW1iZXIsIHBhZHM6IG51bWJlcltdLCBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSwgaXNDaGFubmVsTGFzdDogYm9vbGVhbiwgb3V0cHV0UGFkZGluZzogbnVtYmVyW10sXG4gICAgIG91dHB1dFNoYXBlOiBudW1iZXJbXSkgPT4ge1xuICAgICAgY29uc3Qgc3BhdGlhbFJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aCAtIDI7XG4gICAgICBjb25zdCB1cGRhdGVPdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlLmxlbmd0aCA9PT0gMDtcbiAgICAgIGlmIChvdXRwdXRQYWRkaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYXRpYWxSYW5rOyArK2kpIHtcbiAgICAgICAgICBvdXRwdXRQYWRkaW5nLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IGlucHV0U2hhcGVbMF07XG4gICAgICBjb25zdCBvdXRDaGFubmVscyA9IGtlcm5lbFNoYXBlW2lzQ2hhbm5lbExhc3QgPyAzIDogMV0gKiBncm91cDtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gaW5wdXRTaGFwZS5sZW5ndGggLSBzcGF0aWFsUmFuayAtIChpc0NoYW5uZWxMYXN0ID8gMSA6IDApOyBpIDwgc3BhdGlhbFJhbms7ICsraSwgKytqKSB7XG4gICAgICAgIGNvbnN0IGluU2l6ZSA9IGlucHV0U2hhcGVbal07XG4gICAgICAgIGNvbnN0IG91dFNpemUgPSB1cGRhdGVPdXRwdXRTaGFwZSA/IGluU2l6ZSAqIHN0cmlkZXNbaV0gOiBvdXRwdXRTaGFwZVtpXTtcbiAgICAgICAgY29uc3QgdG90YWxQYWQgPSBjb21wdXRlVG90YWxQYWQoaW5TaXplLCBzdHJpZGVzW2ldLCBwYWRzW2ldLCBrZXJuZWxTaGFwZVtqXSwgZGlsYXRpb25zW2ldLCBvdXRTaXplKTtcbiAgICAgICAgZGlzdHJpYnV0ZVBhZGRpbmcodG90YWxQYWQsIGF1dG9QYWQsIHBhZHMsIGksIGkgKyBzcGF0aWFsUmFuayk7XG4gICAgICAgIGlmICh1cGRhdGVPdXRwdXRTaGFwZSkge1xuICAgICAgICAgIG91dHB1dFNoYXBlLnB1c2goXG4gICAgICAgICAgICAgIHN0cmlkZXNbaV0gKiAoaW5TaXplIC0gMSkgKyBvdXRwdXRQYWRkaW5nW2ldICsgKGtlcm5lbFNoYXBlW2pdIC0gMSkgKiBkaWxhdGlvbnNbaV0gKyAxIC0gcGFkc1tpXSAtXG4gICAgICAgICAgICAgIHBhZHNbaSArIHNwYXRpYWxSYW5rXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG91dHB1dFNoYXBlLnNwbGljZSgwLCAwLCBiYXRjaFNpemUpO1xuICAgICAgb3V0cHV0U2hhcGUuc3BsaWNlKGlzQ2hhbm5lbExhc3QgPyAzIDogMSwgMCwgb3V0Q2hhbm5lbHMpO1xuICAgIH07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgZXh0ZW5kcyBDb252QXR0cmlidXRlcyB7XG4gIHJlYWRvbmx5IG91dHB1dFBhZGRpbmc6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW107XG59XG5cbmNvbnN0IGdldEFkanVzdGVkQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgPVxuICAgIDxUIGV4dGVuZHMgQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXM+KGF0dHJpYnV0ZXM6IFQsIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogVCA9PiB7XG4gICAgICBjb25zdCBrZXJuZWxTaGFwZSA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUuc2xpY2UoKTtcbiAgICAgIC8vIGlmIGtlcm5lbFNoYXBlIGlzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIGF0dHJpYnV0ZXMgb2YgdGhpcyBvcCwgaW5mZXIgaXQgZnJvbSB0aGUgd2VpZ2h0IHRlbnNvciBkaW1zXG4gICAgICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggPT09IDAgfHwgYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiLCAxKSA9PT0gMCkge1xuICAgICAgICBrZXJuZWxTaGFwZS5sZW5ndGggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IGlucHV0c1sxXS5kaW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2VybmVsU2hhcGUucHVzaChpbnB1dHNbMV0uZGltc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcbiAgICAgIGtlcm5lbFNoYXBlLnNwbGljZSgwLCAwLCBpbnB1dHNbMV0uZGltc1swXSk7XG4gICAgICBrZXJuZWxTaGFwZS5zcGxpY2UoaXNDaGFubmVsc0xhc3QgPyAzIDogMSwgMCwgaW5wdXRzWzFdLmRpbXNbMV0pO1xuXG4gICAgICBjb25zdCBwYWRzID0gYXR0cmlidXRlcy5wYWRzLnNsaWNlKCk7XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGF0dHJpYnV0ZXMub3V0cHV0U2hhcGUuc2xpY2UoKTtcbiAgICAgIGNvbnN0IG91dHB1dFBhZGRpbmcgPSBhdHRyaWJ1dGVzLm91dHB1dFBhZGRpbmcuc2xpY2UoKTtcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICAgIGxldCBkaWxhdGlvbnMgPSBhdHRyaWJ1dGVzLmRpbGF0aW9ucy5zbGljZSgpO1xuICAgICAgaWYgKGRpbGF0aW9ucy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSA9PT0gMCkge1xuICAgICAgICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDI7XG4gICAgICAgIGRpbGF0aW9ucyA9IG5ldyBBcnJheShzcGF0aWFsUmFuaykuZmlsbCgxKTtcbiAgICAgIH1cbiAgICAgIGxldCBzdHJpZGVzID0gYXR0cmlidXRlcy5zdHJpZGVzLnNsaWNlKCk7XG4gICAgICBpZiAoc3RyaWRlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSA9PT0gMCkge1xuICAgICAgICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDI7XG4gICAgICAgIHN0cmlkZXMgPSBuZXcgQXJyYXkoc3BhdGlhbFJhbmspLmZpbGwoMSk7XG4gICAgICB9XG4gICAgICAvLyBJZiBvdXRwdXRTaGFwZSBpcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBhdHRyaWJ1dGVzIG9mIHRoaXMgb3AsIGluZmVyIGl0IGZyb20gdGhlIHBhcmFtZXRlcnNcbiAgICAgIC8vIFNpbWlsYXJseSwgYXV0b21hdGljYWxseSBpbmZlciBwYWRzIGlmIG5vdCBzcGVjaWZpZWRcbiAgICAgIGNhbGN1bGF0ZU91dHB1dFNoYXBlQW5kUGFkcyhcbiAgICAgICAgICBpbnB1dFNoYXBlLCBrZXJuZWxTaGFwZSwgZGlsYXRpb25zLCBhdHRyaWJ1dGVzLmF1dG9QYWQsIGF0dHJpYnV0ZXMuZ3JvdXAsIHBhZHMsIHN0cmlkZXMsIGlzQ2hhbm5lbHNMYXN0LFxuICAgICAgICAgIG91dHB1dFBhZGRpbmcsIG91dHB1dFNoYXBlKTtcblxuICAgICAgLy8gYWx3YXlzIHJldHVybiBhIG5ldyBvYmplY3Qgc28gZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCBhdHRyaWJ1dGVzXG4gICAgICBjb25zdCBuZXdBdHRyaWJ1dGVzOiBUID0gT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlcyk7XG4gICAgICBPYmplY3QuYXNzaWduKG5ld0F0dHJpYnV0ZXMsIHtrZXJuZWxTaGFwZSwgcGFkcywgb3V0cHV0UGFkZGluZywgb3V0cHV0U2hhcGUsIGRpbGF0aW9ucywgc3RyaWRlc30pO1xuICAgICAgcmV0dXJuIG5ld0F0dHJpYnV0ZXM7XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBDb252VHJhbnNwb3NlQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGFjdGl2YXRpb25BdHRyaWJ1dGVzID0gcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xuICAvLyBUT0RPIDogTWFrZSB0aGlzIGdlbmVyaWMgZW5vdWdoIHRvIGNvbXB1dGUgZGVmYXVsdCBhdHRyaWJ1dGVzIGZvciBtdWx0aS1kaW1lbnNpb25hbCBjb252XG4gIGNvbnN0IGZvcm1hdCA9IGF0dHJpYnV0ZXMuZm9ybWF0IGFzICdOSFdDJyB8ICdOQ0hXJztcbiAgY29uc3QgYXV0b1BhZCA9XG4gICAgICBbJ05PVFNFVCcsICdWQUxJRCcsICdTQU1FX1VQUEVSJyxcbiAgICAgICAnU0FNRV9MT1dFUiddW3R5cGVvZiBhdHRyaWJ1dGVzLmF1dG9QYWQgPT0gJ3VuZGVmaW5lZCcgPyAwIDogYXR0cmlidXRlcy5hdXRvUGFkIGFzIG51bWJlcl07XG4gIGNvbnN0IGRpbGF0aW9ucyA9IGF0dHJpYnV0ZXMuZGlsYXRpb25zIGFzIFtudW1iZXIsIG51bWJlcl07XG4gIGNvbnN0IGdyb3VwID0gYXR0cmlidXRlcy5ncm91cCBhcyBudW1iZXI7XG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdO1xuICBjb25zdCBwYWRzID0gYXR0cmlidXRlcy5wYWRzIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICBjb25zdCBzdHJpZGVzID0gYXR0cmlidXRlcy5zdHJpZGVzIGFzIFtudW1iZXIsIG51bWJlcl07XG4gIGNvbnN0IHdJc0NvbnN0ID0gKGF0dHJpYnV0ZXMud0lzQ29uc3QgYXMgKCkgPT4gYm9vbGVhbikoKTtcbiAgY29uc3Qgb3V0cHV0UGFkZGluZyA9IGF0dHJpYnV0ZXMub3V0cHV0UGFkZGluZyBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBhdHRyaWJ1dGVzLm91dHB1dFNoYXBlIGFzIFtudW1iZXIsIG51bWJlcl07XG4gIHJldHVybiB7XG4gICAgYXV0b1BhZCxcbiAgICBmb3JtYXQsXG4gICAgZGlsYXRpb25zLFxuICAgIGdyb3VwLFxuICAgIGtlcm5lbFNoYXBlLFxuICAgIG91dHB1dFBhZGRpbmcsXG4gICAgb3V0cHV0U2hhcGUsXG4gICAgcGFkcyxcbiAgICBzdHJpZGVzLFxuICAgIHdJc0NvbnN0LFxuICAgIC4uLmFjdGl2YXRpb25BdHRyaWJ1dGVzLFxuICAgIGNhY2hlS2V5OiBgJHthdHRyaWJ1dGVzLmZvcm1hdH07JHthY3RpdmF0aW9uQXR0cmlidXRlcy5hY3RpdmF0aW9ufTtgXG4gIH07XG59O1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgLy8gUmVmZXIgdG8gdGhlIGJlbG93IGxpbmsgZm9yIGFsbCBpbnB1dCBjaGVja3NcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL29ubngvb25ueC9ibG9iL21haW4vZG9jcy9PcGVyYXRvcnMubWQjQ29udlRyYW5zcG9zZVxuICBpZiAoIWlucHV0cyB8fCAoaW5wdXRzLmxlbmd0aCAhPT0gMiAmJiBpbnB1dHMubGVuZ3RoICE9PSAzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzJyk7XG4gIH1cblxuICAvLyBUT0RPIDogTmVlZCB0byBhZGQgc3VwcG9ydCBmb3IgbXVsdGktZGltZW5zaW9uYWwgY29udlxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSA0ICYmIGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcignY3VycmVudGx5IG9ubHkgc3VwcG9ydCAyLWRpbWVuc2lvbmFsIGNvbnYnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IGlucHV0c1sxXS5kaW1zLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZmlsdGVyIGRvZXMgbm90IGhhdmUgc2FtZSBkaW1lbnNpb24gYXMgaW5wdXQnKTtcbiAgfVxuXG4gIC8vIEZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUxcbiAgY29uc3QgZGF0YUNoYW5uZWwgPSBpbnB1dHNbMF0uZGltc1thdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnID8gaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMSA6IDFdO1xuICBjb25zdCBmaWx0ZXJJbkNoYW5uZWwgPSBpbnB1dHNbMV0uZGltc1swXTtcbiAgaWYgKGRhdGFDaGFubmVsICE9PSBmaWx0ZXJJbkNoYW5uZWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUwnKTtcbiAgfVxuXG4gIGNvbnN0IGZlYXR1cmVNYXBzID0gaW5wdXRzWzFdLmRpbXNbMV0gKiBhdHRyaWJ1dGVzLmdyb3VwO1xuXG4gIC8vIGlmIGJpYXMgaXMgcHJvdmlkZWQgaXQgc2hvdWxkIGJlIDFEIGFuZCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHNob3VsZCBiZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGZlYXR1cmUgbWFwc1xuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiAoaW5wdXRzWzJdLmRpbXMubGVuZ3RoICE9PSAxIHx8IGlucHV0c1syXS5kaW1zWzBdICE9PSBmZWF0dXJlTWFwcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYmlhcycpO1xuICB9XG5cbiAgY29uc3Qgc3BhdGlhbFJhbmsgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAyO1xuICBjb25zdCBkaWxhdGlvbnNTZXQgPSBhdHRyaWJ1dGVzLmRpbGF0aW9ucy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSA+IDA7XG4gIC8vIHdyb25nIGRpbGF0aW9ucyBkaW1lbnNpb25cbiAgaWYgKGRpbGF0aW9uc1NldCAmJiBhdHRyaWJ1dGVzLmRpbGF0aW9ucy5sZW5ndGggIT09IHNwYXRpYWxSYW5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xuICB9XG5cbiAgY29uc3Qgc3RyaWRlc1NldCA9IGF0dHJpYnV0ZXMuc3RyaWRlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSA+IDA7XG4gIC8vIFdyb25nIHN0cmlkZXMgZGltZW5zaW9uXG4gIGlmIChzdHJpZGVzU2V0ICYmIGF0dHJpYnV0ZXMuc3RyaWRlcy5sZW5ndGggIT09IHNwYXRpYWxSYW5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke3NwYXRpYWxSYW5rfURgKTtcbiAgfVxuXG4gIC8vIFdyb25nIHBhZHMgZGltZW5zaW9uXG4gIGNvbnN0IHBhZHNTZXQgPSBhdHRyaWJ1dGVzLnBhZHMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgPiAwO1xuICBpZiAocGFkc1NldCAmJiBhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoICE9PSBzcGF0aWFsUmFuayAqIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZHMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmsgKiAyfURgKTtcbiAgfVxuXG4gIC8vIFdyb25nIG91dHB1dCBwYWRkaW5nIGRpbWVuc2lvblxuICBpZiAoYXR0cmlidXRlcy5vdXRwdXRQYWRkaW5nLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmsgJiYgYXR0cmlidXRlcy5vdXRwdXRQYWRkaW5nLmxlbmd0aCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgb3V0cHV0X3BhZGRpbmcgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xuICB9XG5cbiAgLy8gaWYga2VybmVsU2hhcGUgaXMgc3BlY2lmaWVkLCBpdCdzIGRhdGEgbGVuZ3RoIG11c3QgYmUgMiBsZXNzIHRoYW4gZGltcyBsZW5ndGggb2YgdGhlIHdlaWdodHMgdGVuc29yXG4gIC8vICh0aGUgZmlyc3QgMiBkaW1zIGFyZSBiYXRjaF9zaXplIGFuZCBjaGFubmVscylcbiAgY29uc3Qga2VybmVsU2hhcGVTZXQgPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApID4gMDtcbiAgaWYgKGtlcm5lbFNoYXBlU2V0ICYmIGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoICE9PSAwICYmXG4gICAgICBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoIC0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBrZXJuZWwgc2hhcGUnKTtcbiAgfVxuXG4gIC8vIGFzIHdpdGgga2VybmVsU2hhcGUsIG11c3QgaGF2ZSBzYW1lIG51bWJlciBvZiBzcGF0aWFsIGRpbXMgYXMgaW5wdXRcbiAgaWYgKGF0dHJpYnV0ZXMub3V0cHV0U2hhcGUubGVuZ3RoICE9PSAwICYmIGF0dHJpYnV0ZXMub3V0cHV0U2hhcGUubGVuZ3RoICE9PSBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG91dHB1dCBzaGFwZScpO1xuICB9XG59O1xuXG4vLyBmb3IgdHJhbnNwb3Npbmcgd2VpZ2h0IHRlbnNvciBmcm9tIFtDLCBNL2dyb3VwLCBLSCwgS1ddIHRvIFtLSCwgS1csIE0vZ3JvdXAsIENdXG5jb25zdCB3ZWlnaHRUcmFuc3Bvc2VQZXJtID0gWzIsIDMsIDEsIDBdO1xuXG5jb25zdCBjb252VHJhbnNwb3NlMmQgPVxuICAgIChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBhZGp1c3RlZEF0dHJpYnV0ZXMgPSBnZXRBZGp1c3RlZENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIGlucHV0cyk7XG4gICAgICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGFkanVzdGVkQXR0cmlidXRlcy5vdXRwdXRTaGFwZTtcbiAgICAgIGNvbnN0IG91dENoYW5uZWxzID0gb3V0cHV0U2hhcGVbaXNDaGFubmVsc0xhc3QgPyAzIDogMV07XG4gICAgICBjb25zdCBpbnB1dENoYW5uZWxzID0gaW5wdXRzWzBdLmRpbXNbaXNDaGFubmVsc0xhc3QgPyAzIDogMV07XG4gICAgICAvLyBTd2l0Y2ggdG8gbmFpdmUgbWV0aG9kIHdoZW4gb3V0Q2hhbm5lbHMgYW5kIGlucHV0Q2hhbm5lbHMgYXJlIHZlcnkgc21hbGwuIEl0J3MgYmVjYXVzZSB0aGF0IGluIHRoaXMgY2FzZSBpdCdzXG4gICAgICAvLyBub3Qgc3VpdGFibGUgZm9yIG1hdG11bCB2ZXJzaW9uIHNpbmNlIG1hdG11bCB1c2VzIHRpbGUgc2l6ZSAzMngzMiByZXN1bHRpbmcgdGhlIHVuZGVybHlpbmcgZXhlY3V0aW9uIHVuaXRcbiAgICAgIC8vIHV0aWxpemF0aW9uIHJhdGUgaXMgdmVyeSBsb3cuXG4gICAgICBpZiAoYWRqdXN0ZWRBdHRyaWJ1dGVzLmdyb3VwICE9PSAxIHx8IChvdXRDaGFubmVscyA9PT0gMSAmJiBpbnB1dENoYW5uZWxzID09PSAxKSkge1xuICAgICAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQ29udlRyYW5zcG9zZTJEUHJvZ3JhbUluZm8oaW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3V0SGVpZ2h0ID0gb3V0cHV0U2hhcGVbaXNDaGFubmVsc0xhc3QgPyAxIDogMl07XG4gICAgICBjb25zdCBvdXRXaWR0aCA9IG91dHB1dFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMiA6IDNdO1xuICAgICAgY29uc3Qgd2VpZ2h0SGVpZ2h0ID0gaW5wdXRzWzFdLmRpbXNbMl07XG4gICAgICBjb25zdCB3ZWlnaHRXaWR0aCA9IGlucHV0c1sxXS5kaW1zWzNdO1xuXG4gICAgICBjb25zdCBkaW1BT3V0ZXIgPSBpc0NoYW5uZWxzTGFzdCA/IG91dEhlaWdodCAqIG91dFdpZHRoIDogb3V0Q2hhbm5lbHM7XG4gICAgICBjb25zdCBkaW1CT3V0ZXIgPSBpc0NoYW5uZWxzTGFzdCA/IG91dENoYW5uZWxzIDogb3V0SGVpZ2h0ICogb3V0V2lkdGg7XG4gICAgICBjb25zdCBkaW1Jbm5lciA9IHdlaWdodEhlaWdodCAqIHdlaWdodFdpZHRoICogaW5wdXRDaGFubmVscztcblxuICAgICAgY29uc3Qgc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkcyA9IC8qIGJhY2tlbmQuYWRhcHRlckluZm8uaXNJbnRlbCgpICovIHRydWU7XG5cblxuICAgICAgLy8gU1RFUC4xOiB0cmFuc3Bvc2Ugd2VpZ2h0XG4gICAgICBjb25zdCB0cmFuc3Bvc2VkV2VpZ2h0ID0gKGNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCBhcyBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkKSA/P1xuICAgICAgICAgIGNvbnRleHQuY29tcHV0ZShcbiAgICAgICAgICAgICAgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8oaW5wdXRzWzFdLCB3ZWlnaHRUcmFuc3Bvc2VQZXJtKSxcbiAgICAgICAgICAgICAge2lucHV0czogWzFdLCBvdXRwdXRzOiBbYXR0cmlidXRlcy53SXNDb25zdCA/IC0yIDogLTFdfSlbMF07XG4gICAgICBpZiAoYXR0cmlidXRlcy53SXNDb25zdCAmJiAhY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUKSB7XG4gICAgICAgIGNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCA9IHRyYW5zcG9zZWRXZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFNURVAuMjogcHJlcGFyZSByZXNoYXBlZCBpbnB1dHNcbiAgICAgIGNvbnN0IGNvbnZUcmFuc3Bvc2VJbnB1dHMgPSBbaW5wdXRzWzBdLCB0cmFuc3Bvc2VkV2VpZ2h0XTtcbiAgICAgIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID09PSAzO1xuICAgICAgaWYgKGhhc0JpYXMpIHtcbiAgICAgICAgaWYgKCFpc0NoYW5uZWxzTGFzdCAmJiBpbnB1dHNbMl0uZGltcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBjb252VHJhbnNwb3NlSW5wdXRzLnB1c2goaW5wdXRzWzJdLnJlc2hhcGUoW2lucHV0c1syXS5kaW1zWzBdLCAxLCAxXSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnZUcmFuc3Bvc2VJbnB1dHMucHVzaChpbnB1dHNbMl0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFNURVAuMzogY29tcHV0ZSBtYXRtdWxcbiAgICAgIGNvbnRleHQuY29tcHV0ZShcbiAgICAgICAgICBjcmVhdGVDb252MkRUcmFuc3Bvc2VNYXRNdWxQcm9ncmFtSW5mbyhcbiAgICAgICAgICAgICAgY29udlRyYW5zcG9zZUlucHV0cywgYWRqdXN0ZWRBdHRyaWJ1dGVzLCBvdXRwdXRTaGFwZSwgZGltQU91dGVyLCBkaW1CT3V0ZXIsIGRpbUlubmVyLCBoYXNCaWFzLFxuICAgICAgICAgICAgICBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzKSxcbiAgICAgICAgICB7aW5wdXRzOiBjb252VHJhbnNwb3NlSW5wdXRzfSk7XG4gICAgfTtcblxuY29uc3QgY29udlRyYW5zcG9zZTFkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBDb252VHJhbnNwb3NlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICAvLyBleHRlbmQgdGhlIGlucHV0IHRvIDJEIGJ5IGFkZGluZyBIIGRpbWVuc2lvblxuICBjb25zdCBpc0NoYW5uZWxMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcblxuICBjb25zdCBpbnB1dHMgPSBbXG4gICAgY29udGV4dC5pbnB1dHNbMF0ucmVzaGFwZShcbiAgICAgICAgaXNDaGFubmVsTGFzdCA/XG4gICAgICAgICAgICAvLyBbTiwgVywgQ10gLT4gW04sIEg9MSwgVywgQ11cbiAgICAgICAgICAgIFtjb250ZXh0LmlucHV0c1swXS5kaW1zWzBdLCAxLCBjb250ZXh0LmlucHV0c1swXS5kaW1zWzFdLCBjb250ZXh0LmlucHV0c1swXS5kaW1zWzJdXSA6XG4gICAgICAgICAgICAvLyBbTiwgQywgV10gLT4gW04sIEMsIEg9MSwgV11cbiAgICAgICAgICAgIFtjb250ZXh0LmlucHV0c1swXS5kaW1zWzBdLCBjb250ZXh0LmlucHV0c1swXS5kaW1zWzFdLCAxLCBjb250ZXh0LmlucHV0c1swXS5kaW1zWzJdXSksXG4gICAgLy9bRklMVEVSX09VVF9DSEFOTkVMLCBGSUxURVJfSU5fQ0hBTk5FTCwga1ddIC0+IFtGSUxURVJfT1VUX0NIQU5ORUwsIEZJTFRFUl9JTl9DSEFOTkVMLCBrSD0xLCBrV11cbiAgICBjb250ZXh0LmlucHV0c1sxXS5yZXNoYXBlKFtjb250ZXh0LmlucHV0c1sxXS5kaW1zWzBdLCBjb250ZXh0LmlucHV0c1sxXS5kaW1zWzFdLCAxLCBjb250ZXh0LmlucHV0c1sxXS5kaW1zWzJdXSlcbiAgXTtcbiAgaWYgKGNvbnRleHQuaW5wdXRzLmxlbmd0aCA9PT0gMykge1xuICAgIGlucHV0cy5wdXNoKGNvbnRleHQuaW5wdXRzWzJdKTtcbiAgfVxuICBsZXQga2VybmVsU2hhcGUgPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlO1xuICBpZiAoa2VybmVsU2hhcGUubGVuZ3RoID09PSAwIHx8IGtlcm5lbFNoYXBlWzBdID09PSAwKSB7XG4gICAga2VybmVsU2hhcGUgPSBbY29udGV4dC5pbnB1dHNbMV0uZGltc1syXV07XG4gIH1cbiAgbGV0IGRpbGF0aW9ucyA9IGF0dHJpYnV0ZXMuZGlsYXRpb25zO1xuICBpZiAoZGlsYXRpb25zLmxlbmd0aCA9PT0gMCB8fCBkaWxhdGlvbnNbMF0gPT09IDApIHtcbiAgICBkaWxhdGlvbnMgPSBbMV07XG4gIH1cbiAgbGV0IHN0cmlkZXMgPSBhdHRyaWJ1dGVzLnN0cmlkZXM7XG4gIGlmIChzdHJpZGVzLmxlbmd0aCA9PT0gMCB8fCBzdHJpZGVzWzBdID09PSAwKSB7XG4gICAgc3RyaWRlcyA9IFsxXTtcbiAgfVxuICBsZXQgcGFkcyA9IGF0dHJpYnV0ZXMucGFkcztcbiAgaWYgKHBhZHMubGVuZ3RoID09PSAwKSB7XG4gICAgcGFkcyA9IFswLCAwXTtcbiAgfVxuICBwYWRzID0gWzAsIHBhZHNbMF0sIDAsIHBhZHNbMV1dO1xuICBzdHJpZGVzID0gWzFdLmNvbmNhdChzdHJpZGVzKTtcbiAgZGlsYXRpb25zID0gWzFdLmNvbmNhdChkaWxhdGlvbnMpO1xuICBrZXJuZWxTaGFwZSA9IFsxXS5jb25jYXQoa2VybmVsU2hhcGUpO1xuICBjb25zdCBhZGp1c3RlZEF0dHJpYnV0ZXMgPVxuICAgICAgZ2V0QWRqdXN0ZWRDb252VHJhbnNwb3NlQXR0cmlidXRlcyh7Li4uYXR0cmlidXRlcywgcGFkcywgc3RyaWRlcywgZGlsYXRpb25zLCBrZXJuZWxTaGFwZX0sIGlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVDb252VHJhbnNwb3NlMkRQcm9ncmFtSW5mbyhcbiAgICAgIGlucHV0cywgYWRqdXN0ZWRBdHRyaWJ1dGVzLFxuICAgICAgb3V0cHV0U2hhcGUgPT4gaXNDaGFubmVsTGFzdCA/IFtvdXRwdXRTaGFwZVswXSwgb3V0cHV0U2hhcGVbMl0sIG91dHB1dFNoYXBlWzNdXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW291dHB1dFNoYXBlWzBdLCBvdXRwdXRTaGFwZVsxXSwgb3V0cHV0U2hhcGVbM11dKSk7XG59O1xuXG5leHBvcnQgY29uc3QgY29udlRyYW5zcG9zZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBpZiAoY29udGV4dC5pbnB1dHNbMF0uZGltcy5sZW5ndGggPT09IDMpIHtcbiAgICBjb252VHJhbnNwb3NlMWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgY29udlRyYW5zcG9zZTJkKGNvbnRleHQsIGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0F0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm99IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgZ2V0RWxlbWVudEF0LCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyfSBmcm9tICcuL2NvbW1vbic7XG5cblxuZXhwb3J0IGludGVyZmFjZSBDdW1TdW1BdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgZXhjbHVzaXZlOiBib29sZWFuO1xuICByZWFkb25seSByZXZlcnNlOiBib29sZWFuO1xufVxuY29uc3QgY3JlYXRlQ3Vtc3VtUHJvZ3JhbUluZm8gPVxuICAgIChpbnB1dFR5cGU6IG51bWJlciwgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIGF4aXNJbnB1dDogVGVuc29yVmlldywgYXR0cmlidXRlczogQ3VtU3VtQXR0cmlidXRlcyk6XG4gICAgICAgIFByb2dyYW1JbmZvID0+IHtcbiAgICAgICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUoaW5wdXRTaGFwZSk7ICAvLyBvdXRwdXRTaGFwZSBpcyBzYW1lIGFzIGlucHV0U2hhcGUuXG4gICAgICAgICAgY29uc3QgcmFuayA9IGlucHV0U2hhcGUubGVuZ3RoOyAgICAgICAgICAgICAgICAgLy8gaW5wdXQvb3V0cHV0IHJhbmtcbiAgICAgICAgICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaW5wdXRUeXBlLCByYW5rKTtcbiAgICAgICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRUeXBlLCByYW5rKTtcbiAgICAgICAgICBjb25zdCBheGlzVmFsdWUgPSBheGlzSW5wdXQuZGF0YVR5cGUgPT09IERhdGFUeXBlLmludDMyID8gYXhpc0lucHV0LmdldEludDMyQXJyYXkoKVswXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE51bWJlcihheGlzSW5wdXQuZ2V0QmlnSW50NjRBcnJheSgpWzBdKTtcbiAgICAgICAgICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXhpc1ZhbHVlLCByYW5rKTtcbiAgICAgICAgICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gYCBpMzIoJHtpbnB1dC5pbmRpY2VzR2V0KCdpbnB1dEluZGljZXMnLCAndW5pZm9ybXMuYXhpcycpfSkgYDtcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IGdldEVsZW1lbnRBdCgndW5pZm9ybXMuaW5wdXRfc2hhcGUnLCAndW5pZm9ybXMuYXhpcycsIHJhbmspO1xuICAgICAgICAgICAgY29uc3QgbG93ZXJMaW1pdCA9IGF0dHJpYnV0ZXMucmV2ZXJzZSA/IGluZGV4ICsgKGF0dHJpYnV0ZXMuZXhjbHVzaXZlID8gJyArIDEnIDogJycpIDogJzAnO1xuICAgICAgICAgICAgY29uc3QgdXBwZXJMaW1pdCA9IGF0dHJpYnV0ZXMucmV2ZXJzZSA/IG1heCA6IGluZGV4ICsgKGF0dHJpYnV0ZXMuZXhjbHVzaXZlID8gJycgOiAnICsgMScpO1xuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgICAke1xuICAgICAgICAgICAgICAgIHNoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dFNpemUnLCAndTMyJylcbiAgICAgICAgICAgICAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnYXhpcycsICd1MzInKVxuICAgICAgICAgICAgICAgICAgICAuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cbiAgICAgICAgICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cbiAgICAgICAgICAgICAgICAgIHZhciBpbnB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICAgICAgICAgICAgICB2YXIgc3VtID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMCk7XG4gICAgICAgICAgICAgICAgICBsZXQgZmlyc3QgOiBpMzIgPSAke2xvd2VyTGltaXR9O1xuICAgICAgICAgICAgICAgICAgbGV0IGxhc3QgOiBpMzIgPSAke3VwcGVyTGltaXR9O1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA6IGkzMiA9IGZpcnN0OyBpIDwgbGFzdDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRJbmRpY2VzJywgJ3VuaWZvcm1zLmF4aXMnLCAndTMyKGkpJyl9O1xuICAgICAgICAgICAgICAgICAgICBzdW0gPSBzdW0gKyAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRJbmRpY2VzJyl9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAnc3VtJyl9O1xuICAgICAgICAgICAgICAgIH1gO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6ICdDdW1TdW0nLFxuICAgICAgICAgICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBhdHRyaWJ1dGVzLmNhY2hlS2V5LCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ119LFxuICAgICAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBpbnB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRUeXBlfV0sXG4gICAgICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKX0sXG4gICAgICAgICAgICAgIHByb2dyYW1Vbmlmb3JtczogW1xuICAgICAgICAgICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemV9LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBheGlzfSxcbiAgICAgICAgICAgICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlLCBpbnB1dFNoYXBlKVxuICAgICAgICAgICAgICBdXG5cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ2V0U2hhZGVyU291cmNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuXG5leHBvcnQgY29uc3QgY3Vtc3VtID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBDdW1TdW1BdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBjb250ZXh0LmlucHV0c1swXS5kaW1zO1xuICBjb25zdCBpbnB1dFR5cGUgPSBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZTtcbiAgY29uc3QgYXhpcyA9IGNvbnRleHQuaW5wdXRzWzFdO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQ3Vtc3VtUHJvZ3JhbUluZm8oaW5wdXRUeXBlLCBpbnB1dFNoYXBlLCBheGlzLCBhdHRyaWJ1dGVzKSwge2lucHV0czogWzBdfSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VDdW1TdW1BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQ3VtU3VtQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGV4Y2x1c2l2ZSA9IGF0dHJpYnV0ZXMuZXhjbHVzaXZlIGFzIG51bWJlciA9PT0gMTtcbiAgY29uc3QgcmV2ZXJzZSA9IGF0dHJpYnV0ZXMucmV2ZXJzZSBhcyBudW1iZXIgPT09IDE7XG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe2V4Y2x1c2l2ZSwgcmV2ZXJzZX0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0F0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm99IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgSW5kaWNlc0hlbHBlciwgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlcn0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEZvcm1hdEF0dHJpYnV0ZXMge1xuICByZWFkb25seSBmb3JtYXQ6ICdOSFdDJ3wnTkNIVyc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVwdGhUb1NwYWNlQXR0cmlidXRlcyBleHRlbmRzIEZvcm1hdEF0dHJpYnV0ZXMsIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGJsb2Nrc2l6ZTogbnVtYmVyO1xuICByZWFkb25seSBtb2RlOiBzdHJpbmc7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlcHRoVG9TcGFjZSByZXF1aXJlcyAxIGlucHV0LicpO1xuICB9XG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlcHRoVG9TcGFjZSByZXF1aXJlcyA0RCBpbnB1dC4nKTtcbiAgfVxufTtcblxuY29uc3QgcGVybUZ1bmN0aW9uQm9keSA9IChwZXJtOiBudW1iZXJbXSwgcmFuazogbnVtYmVyLCBpbnB1dDogSW5kaWNlc0hlbHBlciwgb3V0cHV0OiBJbmRpY2VzSGVscGVyKTogc3RyaW5nID0+IHtcbiAgY29uc3QgcmV2ZXJzZUZ1bmMgPSBbXTtcbiAgcmV2ZXJzZUZ1bmMucHVzaChgZm4gcGVybShpOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiAke2lucHV0LnR5cGUuaW5kaWNlc30ge1xuICAgIHZhciBhOiAke2lucHV0LnR5cGUuaW5kaWNlc307YCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgcmV2ZXJzZUZ1bmMucHVzaChpbnB1dC5pbmRpY2VzU2V0KCdhJywgcGVybVtpXSwgYGlbJHtpfV1gKSk7XG4gIH1cbiAgcmV2ZXJzZUZ1bmMucHVzaCgncmV0dXJuIGE7fScpO1xuICByZXR1cm4gcmV2ZXJzZUZ1bmMuam9pbignXFxuJyk7XG59O1xuXG5jb25zdCBjcmVhdGVEZXB0aFRvU3BhY2VQcm9ncmFtSW5mbyA9IChpbnB1dFRlbnNvcjogVGVuc29yVmlldywgYXR0cmlidXRlczogRGVwdGhUb1NwYWNlQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgbGV0IG46IG51bWJlciwgaDogbnVtYmVyLCB3OiBudW1iZXIsIGM6IG51bWJlcjtcbiAgbGV0IHNoYXBlOiBudW1iZXJbXTtcbiAgbGV0IHBlcm06IG51bWJlcltdO1xuICBjb25zdCBpc0NoYW5uZWxMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcbiAgY29uc3QgYmxvY2tzaXplID0gYXR0cmlidXRlcy5ibG9ja3NpemU7XG4gIGNvbnN0IGlzRENSbW9kZSA9IGF0dHJpYnV0ZXMubW9kZSA9PT0gJ0RDUic7XG4gIGlmIChpc0NoYW5uZWxMYXN0KSB7XG4gICAgW24sIGgsIHcsIGNdID0gaW5wdXRUZW5zb3IuZGltcztcbiAgICBzaGFwZSA9IGlzRENSbW9kZSA/IFtuLCBoLCB3LCBibG9ja3NpemUsIGJsb2Nrc2l6ZSwgYyAvIChibG9ja3NpemUgKiogMildIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIFtuLCBoLCB3LCBjIC8gKGJsb2Nrc2l6ZSAqKiAyKSwgYmxvY2tzaXplLCBibG9ja3NpemVdO1xuICAgIHBlcm0gPSBpc0RDUm1vZGUgPyBbMCwgMSwgMywgMiwgNCwgNV0gOiBbMCwgMSwgNCwgMiwgNSwgM107XG4gIH0gZWxzZSB7XG4gICAgW24sIGgsIHcsIGNdID0gW2lucHV0VGVuc29yLmRpbXNbMF0sIGlucHV0VGVuc29yLmRpbXNbMl0sIGlucHV0VGVuc29yLmRpbXNbM10sIGlucHV0VGVuc29yLmRpbXNbMV1dO1xuICAgIHNoYXBlID0gaXNEQ1Jtb2RlID8gW24sIGJsb2Nrc2l6ZSwgYmxvY2tzaXplLCBjIC8gKGJsb2Nrc2l6ZSAqKiAyKSwgaCwgd10gOlxuICAgICAgICAgICAgICAgICAgICAgICAgW24sIGMgLyAoYmxvY2tzaXplICoqIDIpLCBibG9ja3NpemUsIGJsb2Nrc2l6ZSwgaCwgd107XG4gICAgcGVybSA9IGlzRENSbW9kZSA/IFswLCAzLCA0LCAxLCA1LCAyXSA6IFswLCAxLCA0LCAyLCA1LCAzXTtcbiAgfVxuICBjb25zdCByZXNoYXBlZElucHV0VGVuc29yID0gaW5wdXRUZW5zb3IucmVzaGFwZShzaGFwZSk7XG4gIGNvbnN0IHJlc2hhcGVkSW5wdXRSYW5rID0gcmVzaGFwZWRJbnB1dFRlbnNvci5kaW1zLmxlbmd0aDtcbiAgY29uc3QgaW5wdXREYXRhVHlwZSA9IGlucHV0VGVuc29yLmRhdGFUeXBlO1xuXG4gIGNvbnN0IHJlc2hhcGVkSW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdhJywgaW5wdXREYXRhVHlwZSwgcmVzaGFwZWRJbnB1dFJhbmspO1xuICBjb25zdCBwZXJtZWRPdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXREYXRhVHlwZSwgcmVzaGFwZWRJbnB1dFJhbmspO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dF9zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMocmVzaGFwZWRJbnB1dCwgcGVybWVkT3V0cHV0KX1cblxuICAke3Blcm1GdW5jdGlvbkJvZHkocGVybSwgcmVzaGFwZWRJbnB1dFJhbmssIHJlc2hhcGVkSW5wdXQsIHBlcm1lZE91dHB1dCl9XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cblxuICAgIGxldCBpbmRpY2VzID0gJHtwZXJtZWRPdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgIGxldCBhSW5kaWNlcyA9IHBlcm0oaW5kaWNlcyk7XG5cbiAgICAke3Blcm1lZE91dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsIHJlc2hhcGVkSW5wdXQuZ2V0QnlJbmRpY2VzKCdhSW5kaWNlcycpKX1cbiAgfWA7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnRGVwdGhUb1NwYWNlJyxcbiAgICBzaGFkZXJDYWNoZToge2hpbnQ6IGAke2lucHV0VGVuc29yLmRpbXN9OyR7YXR0cmlidXRlcy5ibG9ja3NpemV9OyR7YXR0cmlidXRlcy5tb2RlfWAsIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXX0sXG4gICAgZ2V0UnVuRGF0YTogKGlucHV0cykgPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpc0NoYW5uZWxMYXN0ID8gW24sIGggKiBibG9ja3NpemUsIHcgKiBibG9ja3NpemUsIGMgLyAoYmxvY2tzaXplICoqIDIpXSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbiwgYyAvIChibG9ja3NpemUgKiogMiksIGggKiBibG9ja3NpemUsIHcgKiBibG9ja3NpemVdO1xuICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgICAgIGNvbnN0IHNoYXBlQmVmb3JlUGVybSA9IHJlc2hhcGVkSW5wdXRUZW5zb3IuZGltcztcbiAgICAgIGNvbnN0IHNoYXBlQWZ0ZXJQZXJtID0gU2hhcGVVdGlsLnNvcnRCYXNlZE9uUGVybShzaGFwZUJlZm9yZVBlcm0sIHBlcm0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX1dLFxuICAgICAgICBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgICBwcm9ncmFtVW5pZm9ybXM6XG4gICAgICAgICAgICBbe3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZX0sIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKHNoYXBlQmVmb3JlUGVybSwgc2hhcGVBZnRlclBlcm0pXSxcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZGVwdGhUb1NwYWNlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZURlcHRoVG9TcGFjZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCBhdHRyaWJ1dGVzKSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogRGVwdGhUb1NwYWNlQXR0cmlidXRlcyA9PlxuICAgIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7XG4gICAgICBibG9ja3NpemU6IGF0dHJpYnV0ZXMuYmxvY2tzaXplIGFzIG51bWJlcixcbiAgICAgIG1vZGU6IGF0dHJpYnV0ZXMubW9kZSBhcyBzdHJpbmcsXG4gICAgICBmb3JtYXQ6IGF0dHJpYnV0ZXMuZm9ybWF0IGFzICdOSFdDJyB8ICdOQ0hXJ1xuICAgIH0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm19IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlcn0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEVpbnN1bUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBlcXVhdGlvbjogc3RyaW5nO1xufVxuLy8gVGhlIGVxdWF0aW9uIGF0dHJpYnV0ZSB2YWx1ZSBpcyBhIHN0cmluZyB3aGljaCBjb25zaXN0cyBvZiBsZWZ0IGhhbmQgc2lkZSAoTEhTKSBhbmQgb3B0aW9uYWxseSByaWdodCBoYW5kIHNpZGUgKFJIUylcbi8vIHNlcGFyYXRlZCBieSAnLT4nLiBFeC4gXCJpaixqayAtPiBpa1wiIGV4cHJlc3NlcyBtYXRyaXggbXVsdGlwbGljYXRpb25cbi8vICAgICBcImlqLT5qaVwiIGV4cHJlc3NlcyBtYXRyaXggdHJhbnNwb3NlXG4vLyAgICAgIFwiaWktPmlcIiBkaWFnb25hbCBlbGVtZW50cyBvZiBhIHNxdWFyZSBtYXRyaXhcbi8vIExIUyBjb25zaXN0cyBvZiBhIHNlcXVlbmNlIG9mIHRlcm1zIHNlcGFyYXRlZCBieSBjb21tYXMuIEVhY2ggdGVybSBjb3JyZXNwb25kcyB0byBhbiBpbnB1dCB2YXJpYWJsZS5cbi8vIEVhY2ggc3ltYm9sIGNvcnJlc3BvbmRzIHRvIGEgZGltZW5zaW9uIGluIHRoZSBpbnB1dCB2YXJpYWJsZS4gVGhlIHN5bWJvbCBjYW4gYmUgZWl0aGVyIGEgbGV0dGVyLCAnYScgdG8gJ3onIG9yICdBJyB0b1xuLy8gJ1onIG9yICcuLi4nIHRvIHJlcHJlc2VudCBhcmJpdHJhcnkgZGltZW5zaW9ucy5cblxuY29uc3Qgc3ltYm9sUGF0dGVybiA9XG4gICAgJ1thLXpBLVpdfFxcXFwuXFxcXC5cXFxcLic7ICAvLyBUaGUgcGF0dGVybiBlYWNoIHN5bWJvbCBpbiBlYWNoIHRlcm0gaW4gdGhlIHN5bWJvbGljIGVxdWF0aW9uIHNob3VsZCBtYXRjaFxuY29uc3QgdGVybVBhdHRlcm4gPSAnKCcgKyBzeW1ib2xQYXR0ZXJuICsgJykrJzsgICAvLyBUaGUgcGF0dGVybiBlYWNoIHRlcm0gaW4gdGhlIHN5bWJvbGljIGVxdWF0aW9uIHNob3VsZCBtYXRjaFxuY29uc3QgdGVybVBhdHRlcm5Pbmx5ID0gJ14nICsgdGVybVBhdHRlcm4gKyAnJCc7ICAvLyBUaGUgcGF0dGVybnMgb25seSBtYXRjaHMgYSB0ZXJtIGJlZ2luIHRvIGVuZC5cbmNvbnN0IGxoc1BhdHRlcm4gPSAnKCcgKyB0ZXJtUGF0dGVybiArICcsKSonICsgdGVybVBhdHRlcm47ICAvLyBUaGUgcGF0dGVybiB0aGUgTEhTIHNob3VsZCBtYXRjaFxuY29uc3QgbGhzUGF0dGVybk9ubHkgPSAnXicgKyBsaHNQYXR0ZXJuICsgJyQnOyAgICAgICAgICAgICAgIC8vIFRoZSBwYXR0ZXJucyBvbmx5IG1hdGNocyBhIExIUyBiZWdpbiB0byBlbmQuXG5cbmludGVyZmFjZSBTeW1ib2xJbmZvIHtcbiAgY291bnQ6IG51bWJlcjsgICAgICAgICAgIC8vIFN5bWJvbCBjb3JyZXNwb25kaW5nIHRvIGEgZGltbWVuc2lvbiBvZiBhbiBpbnB1dFxuICBpbnB1dEluZGljZXM6IG51bWJlcltdOyAgLy8gTnVtYmVyIG9mIGlucHV0IHZhcmlhYmxlcyB0aGUgc3ltYm9sIGNvcnJlc3BvbmRzIHRvXG4gIGRpbVZhbHVlOiBudW1iZXI7ICAgICAgICAvLyBOdW1iZXIgb2YgZGltZW5zaW9ucyB0aGUgc3ltYm9sIGNvcnJlc3BvbmRzIHRvXG59XG5cbmNsYXNzIEVpbnN1bVRlcm0ge1xuICBjb25zdHJ1Y3RvcihpbnB1dEluZGV4ID0gLTEpIHtcbiAgICB0aGlzLnN5bWJvbFRvSW5kaWNlcyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXJbXT4oKTtcbiAgICB0aGlzLmlucHV0SW5kZXggPSBpbnB1dEluZGV4O1xuICB9XG5cbiAgLy8gQWRkIGEgc3ltYm9sIHRvIHRoZSB0ZXJtXG4gIGFkZFN5bWJvbChzeW1ib2w6IHN0cmluZywgaW5kZXg6IG51bWJlcikge1xuICAgIGxldCB2YWx1ZSA9IHRoaXMuc3ltYm9sVG9JbmRpY2VzLmdldChzeW1ib2wpO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWx1ZSA9IFtpbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlLnB1c2goaW5kZXgpO1xuICAgIH1cbiAgICB0aGlzLnN5bWJvbFRvSW5kaWNlcy5zZXQoc3ltYm9sLCB2YWx1ZSk7XG4gIH1cblxuICBzeW1ib2xUb0luZGljZXM6IE1hcDxzdHJpbmcsIG51bWJlcltdPjsgIC8vIE1hcCBmcm9tIHN5bWJvbCB0byBkaW1lbnNpb25zIG9mIHRoZSBpbnB1dCBjb3JyZXNwb25kaW5nIHRvIHRoZSB0ZXJtXG4gIGlucHV0SW5kZXg6IG51bWJlcjsgICAgICAgICAgICAgICAgICAgICAgLy8gLTEgZm9yIG91dHB1dCBhbmQgMCwgMSwgMiwgLi4uIGZvciBpbnB1dHNcbn1cblxuY2xhc3MgRWluc3VtRXF1YXRpb24ge1xuICBjb25zdHJ1Y3RvcihpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgcHVibGljIHJlYWRvbmx5IGVxdWF0aW9uOiBzdHJpbmcpIHtcbiAgICB0aGlzLmhhc0VsbGlwc2lzID0gZmFsc2U7XG4gICAgdGhpcy5zeW1ib2xUb0luZm8gPSBuZXcgTWFwPHN0cmluZywgU3ltYm9sSW5mbz4oKTtcbiAgICB0aGlzLmxocyA9IG5ldyBBcnJheTxFaW5zdW1UZXJtPigpO1xuICAgIHRoaXMub3V0cHV0RGltcyA9IFtdO1xuICAgIC8vIEFzIHJocyBuZWVkcyB0byBiZSB1cGRhdGVkIGFsbG93IHVzaW5nIGxldCBpbnN0ZWFkIG9mIGNvbnN0IGZvciBib3RoIGxocyBhbmQgcmhzLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICBsZXQgW2xocywgcmhzXSA9IGVxdWF0aW9uLmluY2x1ZGVzKCctPicpID8gZXF1YXRpb24uc3BsaXQoJy0+JywgMikgOiBbZXF1YXRpb24sICcnXTtcbiAgICBpZiAoIWxocy5tYXRjaChSZWdFeHAobGhzUGF0dGVybk9ubHkpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExIUyB0ZXJtJyk7XG4gICAgfVxuICAgIGNvbnN0IGlucHV0VGVybXMgPSBsaHMuc3BsaXQoJywnKTtcbiAgICBpbnB1dFRlcm1zLmZvckVhY2goKGlucHV0VGVybSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGRpbXMgPSBpbnB1dHNbaW5kZXhdLmRpbXMuc2xpY2UoKTtcbiAgICAgIGlmICghaW5wdXRUZXJtLm1hdGNoKFJlZ0V4cCh0ZXJtUGF0dGVybk9ubHkpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTEhTIHRlcm0nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVpbnN1bVRlcm0gPSB0aGlzLnByb2Nlc3NUZXJtKGlucHV0VGVybSwgdHJ1ZSwgZGltcywgaW5kZXgpO1xuICAgICAgdGhpcy5saHMucHVzaChlaW5zdW1UZXJtKTtcbiAgICB9KTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIFJIUyBpZiBub3Qgc3BlY2lmaWVkXG4gICAgaWYgKHJocyA9PT0gJycpIHtcbiAgICAgIC8vIENvbnN0cnVjdCBSSFMgZnJvbSBMSFMgdGVybXMvc3ltYm9sc1xuICAgICAgcmhzICs9IFsuLi50aGlzLnN5bWJvbFRvSW5mby5lbnRyaWVzKCldXG4gICAgICAgICAgICAgICAgIC5maWx0ZXIoKFtzeW0sIGluZm9dKSA9PiAoaW5mby5jb3VudCA9PT0gMSB8fCBzeW0gPT09ICcuLi4nKSlcbiAgICAgICAgICAgICAgICAgLm1hcCgoW3N5bV0pID0+IHN5bSlcbiAgICAgICAgICAgICAgICAgLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXJocy5tYXRjaChSZWdFeHAodGVybVBhdHRlcm4pKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUkhTJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBvdXRwdXQgZGltc1xuICAgIGNvbnN0IHJoc1N5bWJvbHMgPSByaHMubWF0Y2goUmVnRXhwKHN5bWJvbFBhdHRlcm4sICdnJykpO1xuICAgIHJoc1N5bWJvbHM/LmZvckVhY2goKHN5bWJvbCkgPT4ge1xuICAgICAgaWYgKHN5bWJvbCA9PT0gJy4uLicpIHtcbiAgICAgICAgdGhpcy5vdXRwdXREaW1zID0gdGhpcy5vdXRwdXREaW1zLmNvbmNhdCh0aGlzLmVsbGlwc2lzRGltcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpbmZvID0gdGhpcy5zeW1ib2xUb0luZm8uZ2V0KHN5bWJvbCk7XG4gICAgICAgIGlmIChpbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUkhTIHN5bWJvbCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0RGltcy5wdXNoKGluZm8uZGltVmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucmhzID0gdGhpcy5wcm9jZXNzVGVybShyaHMsIGZhbHNlLCB0aGlzLm91dHB1dERpbXMpO1xuICB9ICAvLyBFbmQgb2YgRWluc3VtRXFhdGlvbiBjb25zdHJ1Y3RvclxuXG4gIC8vIEFkZCBhIHN5bWJvbCB0byB0aGUgZXF1YXRpb25cbiAgYWRkU3ltYm9sKHN5bWJvbDogc3RyaW5nLCBkaW1WYWx1ZTogbnVtYmVyLCBpbnB1dEluZGV4OiBudW1iZXIpIHtcbiAgICBsZXQgaW5mbyA9IHRoaXMuc3ltYm9sVG9JbmZvLmdldChzeW1ib2wpO1xuICAgIGlmIChpbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChpbmZvLmRpbVZhbHVlICE9PSBkaW1WYWx1ZSAmJiBpbmZvLmNvdW50ICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGltZW5zaW9uIG1pc21hdGNoJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvLmNvdW50Kys7XG4gICAgICAgIGluZm8uaW5wdXRJbmRpY2VzLnB1c2goaW5wdXRJbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gPSB7Y291bnQ6IDEsIGRpbVZhbHVlLCBpbnB1dEluZGljZXM6IFtpbnB1dEluZGV4XX07XG4gICAgfVxuICAgIHRoaXMuc3ltYm9sVG9JbmZvLnNldChzeW1ib2wsIGluZm8pO1xuICB9XG5cbiAgLy8gUHJvY2VzcyBvbmUgaW5wdXQvb3V0cHV0IHRlcm1cbiAgcHJvY2Vzc1Rlcm0odGVybTogc3RyaW5nLCBpc0lucHV0OiBib29sZWFuLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSwgaW5kZXggPSAtMSk6IEVpbnN1bVRlcm0ge1xuICAgIGNvbnN0IHJhbmsgPSBkaW1zLmxlbmd0aDtcbiAgICBsZXQgZWxsaXBzaXMgPSBmYWxzZTtcbiAgICBsZXQgZWxsaXBzaXNEaW1zID0gW107XG4gICAgbGV0IG5leHREaW0gPSAwO1xuICAgIC8vIEZvciBvdXRwdXQgZW1wdHkgc3RyaW5nIGlzIGFsbG93ZWQgYmVjYXVzZSB0aGUgb3V0cHV0IG1heSBiZSByZWR1Y2VkIHRvIGEgc2NhbGFyIHZhbHVlXG4gICAgaWYgKCF0ZXJtLm1hdGNoKFJlZ0V4cCh0ZXJtUGF0dGVybk9ubHkpKSAmJiAoIWlzSW5wdXQgJiYgdGVybSAhPT0gJycpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTEhTIHRlcm0nKTtcbiAgICB9XG4gICAgY29uc3QgaW5kZXhTeW1ib2xzID0gdGVybS5tYXRjaChSZWdFeHAoc3ltYm9sUGF0dGVybiwgJ2cnKSk7XG4gICAgY29uc3QgZWluc3VtVGVybSA9IG5ldyBFaW5zdW1UZXJtKGluZGV4KTtcbiAgICAvLyBzeW1ib2wgY2FuIGJlIGVpdGhlciBhIGxldHRyZSwgJ2EnIHRvICd6JyBvciAnQScgdG8gJ1onLCBvciAnLi4uJ1xuICAgIGluZGV4U3ltYm9scz8uZm9yRWFjaCgoc3ltYm9sOiBzdHJpbmcsIGk6IG51bWJlcikgPT4ge1xuICAgICAgaWYgKHN5bWJvbCA9PT0gJy4uLicpIHtcbiAgICAgICAgaWYgKGVsbGlwc2lzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG9uZSBlbGxpcHNpcyBpcyBhbGxvd2VkIHBlciBpbnB1dCB0ZXJtJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxsaXBzaXMgPSB0cnVlO1xuICAgICAgICBjb25zdCBlbGxpcHNpc0RpbUxlbmd0aCA9IHJhbmsgLSBpbmRleFN5bWJvbHMubGVuZ3RoICsgMTtcbiAgICAgICAgaWYgKGVsbGlwc2lzRGltTGVuZ3RoIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRWxsaXBzaXMgb3V0IG9mIGJvdW5kcycpO1xuICAgICAgICB9XG4gICAgICAgIGVsbGlwc2lzRGltcyA9IGRpbXMuc2xpY2UobmV4dERpbSwgbmV4dERpbSArIGVsbGlwc2lzRGltTGVuZ3RoKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzRWxsaXBzaXMpIHtcbiAgICAgICAgICBpZiAodGhpcy5lbGxpcHNpc0RpbXMubGVuZ3RoICE9PSBlbGxpcHNpc0RpbXMubGVuZ3RoIHx8XG4gICAgICAgICAgICAgIHRoaXMuZWxsaXBzaXNEaW1zLnRvU3RyaW5nKCkgIT09IGVsbGlwc2lzRGltcy50b1N0cmluZygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VsbGlwc2lzIGRpbWVuc2lvbnMgbWlzbWF0Y2gnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNJbnB1dCkge1xuICAgICAgICAgIHRoaXMuaGFzRWxsaXBzaXMgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZWxsaXBzaXNEaW1zID0gZWxsaXBzaXNEaW1zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRWxsaXBzaXMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gdGhlIExIUycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCAnMCcsICcxJywgJzInLCAnMycsICc0JywgZXRjIHRvIHJlcHJlc2VudCBlbGxpcHNpcyBkaW1lbnNpb25zIHRvIGF2b2lkIHNwZWNpYWwgaGFuZGxpbmdcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBlbGxpcHNpc0RpbXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBzeW1ib2wgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCcwJy5jaGFyQ29kZUF0KDApICsgaik7XG4gICAgICAgICAgZWluc3VtVGVybS5hZGRTeW1ib2woc3ltYm9sLCBpICsgaik7XG4gICAgICAgICAgdGhpcy5hZGRTeW1ib2woc3ltYm9sLCBkaW1zW25leHREaW0rK10sIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWluc3VtVGVybS5hZGRTeW1ib2woc3ltYm9sLCBpICsgKHRoaXMuaGFzRWxsaXBzaXMgPyB0aGlzLmVsbGlwc2lzRGltcy5sZW5ndGggLSAxIDogMCkpO1xuICAgICAgICB0aGlzLmFkZFN5bWJvbChzeW1ib2wsIGRpbXNbbmV4dERpbSsrXSwgaW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBlaW5zdW1UZXJtO1xuICB9XG5cbiAgc3ltYm9sVG9JbmZvOiBNYXA8c3RyaW5nLCBTeW1ib2xJbmZvPjsgIC8vIEFsbCBzeW1ib2xzIGluIHRoZSBlcXVhdGlvblxuICBoYXNFbGxpcHNpczogYm9vbGVhbjsgICAgICAgICAgICAgICAgICAgLy8gVGhlIGVxdWF0aW9uIGhhcyBlbGxpcHNpcyBvciBub3RcbiAgZWxsaXBzaXNEaW1zOiBudW1iZXJbXTsgICAgICAgICAgICAgICAgIC8vIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBlcXVhdGlvbiBlbGxpcHNpcyBjb3JyZXNwb25kcyB0by5cbiAgbGhzOiBFaW5zdW1UZXJtW107ICAgICAgICAgICAgICAgICAgICAgIC8vIFRlcm1zIG9uIHRoZSBsZWZ0LWhhbmQgc2lkZSBvZiB0aGUgZXF1YXRpb25cbiAgcmhzOiBFaW5zdW1UZXJtOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRlcm0gb24gdGhlIHJpZ2h0LWhhbmQgc2lkZSBvZiB0aGUgZXF1YXRpb25cbiAgb3V0cHV0RGltczogbnVtYmVyW107ICAgICAgICAgICAgICAgICAgIC8vIE91dHB1dCBkaW1lbnNpb25zIG9mIHRoZSBlcXVhdGlvblxufSAgLy8gRW5kIG9mIGNsYXNzIEVpbnN1bUVxdWF0aW9uXG5cbmNvbnN0IGFwcGVuZE1heCA9IChuYW1lOiBzdHJpbmcpOiBzdHJpbmcgPT4gbmFtZSArICdfbWF4JztcblxuY29uc3QgY3JlYXRlRWluc3VtUHJvZ3JhbUluZm8gPVxuICAgIChpbnB1dFNoYXBlczogQXJyYXk8cmVhZG9ubHkgbnVtYmVyW10+LCBkYXRhVHlwZTogbnVtYmVyLCBlaW5zdW1FcXVhdGlvbjogRWluc3VtRXF1YXRpb24sXG4gICAgIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IHJhbmtzID0gaW5wdXRTaGFwZXMubWFwKChkaW1zKSA9PiBkaW1zLmxlbmd0aCk7XG4gICAgICBjb25zdCBpbnB1dFZhcnMgPSByYW5rcy5tYXAoKHJhbmssIGluZGV4KSA9PiBpbnB1dFZhcmlhYmxlKGBpbnB1dCR7aW5kZXh9YCwgZGF0YVR5cGUsIHJhbmspKTtcbiAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gICAgICBjb25zdCB1bmlmb3Jtc1N5bWJvbHMgPVxuICAgICAgICAgIFsuLi5laW5zdW1FcXVhdGlvbi5zeW1ib2xUb0luZm8ua2V5cygpXS5maWx0ZXIoKHN5bWJvbCkgPT4gIWVpbnN1bUVxdWF0aW9uLnJocy5zeW1ib2xUb0luZGljZXMuaGFzKHN5bWJvbCkpO1xuICAgICAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGlkeENvcHk6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGNvbnN0IGluaXRQcm9kID0gJ3ZhciBwcm9kID0gMS4wOyc7XG4gICAgICAgIGNvbnN0IGluaXRTdW0gPSAndmFyIHN1bSA9IDAuMDsnO1xuICAgICAgICBjb25zdCB1cGRhdGVTdW0gPSAnc3VtICs9IHByb2Q7JztcbiAgICAgICAgY29uc3QgcmVkdWNlT3BzU2V0SW5kaWNlczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgY29uc3QgcmVkdWNlT3BzTG9vcEhlYWRlcnM6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGNvbnN0IHJlZHVjZU9wc0xvb3BGb290ZXJzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBjb25zdCByZWR1Y2VPcENvbXB1dGU6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGNvbnN0IGlzUmVkdWNlT3BzV2l0aG91dExvb3AgPSBlaW5zdW1FcXVhdGlvbi5zeW1ib2xUb0luZm8uc2l6ZSA9PT0gZWluc3VtRXF1YXRpb24ucmhzLnN5bWJvbFRvSW5kaWNlcy5zaXplO1xuICAgICAgICBlaW5zdW1FcXVhdGlvbi5zeW1ib2xUb0luZm8uZm9yRWFjaCgoaW5mbywgc3ltYm9sKSA9PiB7XG4gICAgICAgICAgaWYgKGVpbnN1bUVxdWF0aW9uLnJocy5zeW1ib2xUb0luZGljZXMuaGFzKHN5bWJvbCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dEluZGV4ID0gZWluc3VtRXF1YXRpb24ucmhzLnN5bWJvbFRvSW5kaWNlcy5nZXQoc3ltYm9sKT8uWzBdO1xuICAgICAgICAgICAgaWYgKG91dHB1dEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZWluc3VtRXF1YXRpb24ubGhzLmZvckVhY2goKHRlcm0sIGkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5pbnB1dEluZGljZXMuaW5jbHVkZXMoaSkpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGljZXMgPSB0ZXJtLnN5bWJvbFRvSW5kaWNlcy5nZXQoc3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgIGlmIChpbmRpY2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN5bWJvbCBlcnJvcicpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaW5kaWNlcy5mb3JFYWNoKChpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZHhDb3B5LnB1c2goYCR7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhcnNbaV0uaW5kaWNlc1NldChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgaW5wdXQke2l9SW5kaWNlc2AsIGluZGV4LCBvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0SW5kaWNlcycsIG91dHB1dEluZGV4KSl9YCk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlaW5zdW1FcXVhdGlvbi5saHMuZm9yRWFjaCgodGVybSwgaSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoaW5mby5pbnB1dEluZGljZXMuaW5jbHVkZXMoaSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gdGVybS5zeW1ib2xUb0luZGljZXMuZ2V0KHN5bWJvbCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGljZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN5bWJvbCBlcnJvcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRpY2VzLmZvckVhY2goKGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICByZWR1Y2VPcHNTZXRJbmRpY2VzLnB1c2goYCR7aW5wdXRWYXJzW2ldLmluZGljZXNTZXQoYGlucHV0JHtpfUluZGljZXNgLCBpbmRleCwgYCR7c3ltYm9sfWApfWApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlZHVjZU9wQ29tcHV0ZS5wdXNoKGBwcm9kICo9ICR7aW5wdXRWYXJzW2ldLmdldEJ5SW5kaWNlcyhgaW5wdXQke2l9SW5kaWNlc2ApfTtgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZWR1Y2VPcHNMb29wSGVhZGVycy5wdXNoKFxuICAgICAgICAgICAgICAgIGBmb3IodmFyICR7c3ltYm9sfTogdTMyID0gMDsgJHtzeW1ib2x9IDwgdW5pZm9ybXMuJHthcHBlbmRNYXgoc3ltYm9sKX07ICR7c3ltYm9sfSsrKSB7YCk7XG4gICAgICAgICAgICByZWR1Y2VPcHNMb29wRm9vdGVycy5wdXNoKCd9Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVkdWNlT3BzID0gaXNSZWR1Y2VPcHNXaXRob3V0TG9vcCA/XG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIC4uLmlkeENvcHksXG4gICAgICAgICAgICAgIGBsZXQgc3VtID0gJHtpbnB1dFZhcnMubWFwKChpbnB1dFZhciwgaSkgPT4gaW5wdXRWYXIuZ2V0QnlJbmRpY2VzKGBpbnB1dCR7aX1JbmRpY2VzYCkpLmpvaW4oJyAqICcpfTtgXG4gICAgICAgICAgICBdIDpcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgLi4uaWR4Q29weSxcbiAgICAgICAgICAgICAgaW5pdFN1bSxcbiAgICAgICAgICAgICAgLi4ucmVkdWNlT3BzTG9vcEhlYWRlcnMsXG4gICAgICAgICAgICAgIC4uLnJlZHVjZU9wc1NldEluZGljZXMsXG4gICAgICAgICAgICAgIGluaXRQcm9kLFxuICAgICAgICAgICAgICAuLi5yZWR1Y2VPcENvbXB1dGUsXG4gICAgICAgICAgICAgIHVwZGF0ZVN1bSxcbiAgICAgICAgICAgICAgLi4ucmVkdWNlT3BzTG9vcEZvb3RlcnMsXG4gICAgICAgICAgICBdO1xuICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgJHtcbiAgICAgICAgICAgIHNoYWRlckhlbHBlclxuICAgICAgICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zU3ltYm9scy5tYXAoKHN5bWJvbCkgPT4gKHtuYW1lOiBgJHthcHBlbmRNYXgoc3ltYm9sKX1gLCB0eXBlOiAndTMyJ30pKSlcbiAgICAgICAgICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRTaXplJywgJ3UzMicpXG4gICAgICAgICAgICAgICAgLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJzLCBvdXRwdXQpfVxuXG4gICAgICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cbiAgICAgICAgICAgIHZhciBvdXRwdXRJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgICAgICAgICAgJHtpbnB1dFZhcnMubWFwKChfdmFyLCBpKSA9PiBgdmFyIGlucHV0JHtpfUluZGljZXM6ICR7aW5wdXRWYXJzW2ldLnR5cGUuaW5kaWNlc307YCkuam9pbignXFxuJyl9XG4gICAgICAgICAgICAke3JlZHVjZU9wcy5qb2luKCdcXG4nKX07XG4gICAgICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICdzdW0nKX07XG4gICAgICAgICAgfWA7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ0VpbnN1bScsXG4gICAgICAgIHNoYWRlckNhY2hlOiB7aGludDogZWluc3VtRXF1YXRpb24uZXF1YXRpb24sIGlucHV0RGVwZW5kZW5jaWVzOiBpbnB1dFNoYXBlcy5tYXAoKCkgPT4gJ3JhbmsnKX0sXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+IHtcbiAgICAgICAgICAvLyBUaGUgc3ltYm9scyBmcm9tIHVuaWZvcm1TeW1ib2xzIGFycmF5IGFyZSBndWFyYW50ZWVkIHRvIGV4aXN0IGluIGVpbnN1bUVxdWF0aW9ucy5zeW1ib2xUb0luZm8gbWFwLiBUaGVcbiAgICAgICAgICAvLyBmaWx0ZXIgaXMgYWRkZWQgdG8gbWFrZSBzdXJlIHRoYXQgZGltVmFsdWUgaXMgbmV2ZXIgMC5cbiAgICAgICAgICBjb25zdCBwcm9ncmFtVW5pZm9ybXNJbml0OiBQcm9ncmFtVW5pZm9ybVtdID1cbiAgICAgICAgICAgICAgdW5pZm9ybXNTeW1ib2xzLmZpbHRlcigoc3ltYm9sKSA9PiBlaW5zdW1FcXVhdGlvbi5zeW1ib2xUb0luZm8uaGFzKHN5bWJvbCkpXG4gICAgICAgICAgICAgICAgICAubWFwKFxuICAgICAgICAgICAgICAgICAgICAgIChzeW1ib2wpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICh7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBlaW5zdW1FcXVhdGlvbi5zeW1ib2xUb0luZm8uZ2V0KHN5bWJvbCk/LmRpbVZhbHVlIHx8IDB9KSk7XG4gICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zSW5pdC5wdXNoKHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemV9KTtcbiAgICAgICAgICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPVxuICAgICAgICAgICAgICBpbnB1dFNoYXBlcy5tYXAoKGRpbXMsIF8pID0+IFsuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhkaW1zKV0pXG4gICAgICAgICAgICAgICAgICAucmVkdWNlKChhY2MsIGlucHV0UHJvZ3JhbVVuaWZvcm1zKSA9PiBhY2MuY29uY2F0KGlucHV0UHJvZ3JhbVVuaWZvcm1zKSwgcHJvZ3JhbVVuaWZvcm1zSW5pdCk7XG4gICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpKTtcbiAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgIG91dHB1dHM6IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlfV0sXG4gICAgICAgICAgICBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICAgIH07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IGVpbnN1bSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogRWluc3VtQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBlaW5zdW1FcXVhdGlvbiA9IG5ldyBFaW5zdW1FcXVhdGlvbihjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcy5lcXVhdGlvbik7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gZWluc3VtRXF1YXRpb24ub3V0cHV0RGltcztcbiAgY29uc3QgaW5wdXRTaGFwZXMgPSBjb250ZXh0LmlucHV0cy5tYXAoKGlucHV0LCBfKSA9PiBpbnB1dC5kaW1zKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVpbnN1bVByb2dyYW1JbmZvKGlucHV0U2hhcGVzLCBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSwgZWluc3VtRXF1YXRpb24sIG91dHB1dFNoYXBlKSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VFaW5zdW1BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogRWluc3VtQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGVxdWF0aW9uID0gKGF0dHJpYnV0ZXMuZXF1YXRpb24gYXMgc3RyaW5nKS5yZXBsYWNlKC9cXHMrL2csICcnKTtcbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7ZXF1YXRpb259KTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXJ9IGZyb20gJy4vY29tbW9uJztcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwYW5kIHJlcXVpcmVzIDIgaW5wdXQuJyk7XG4gIH1cbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBzaGFwZSA9IEFycmF5LmZyb20oaW5wdXRzWzFdLmdldEJpZ0ludDY0QXJyYXkoKSwgTnVtYmVyKTtcblxuICBsZXQgc2hhcGVJbmRleCA9IHNoYXBlLmxlbmd0aCA8IGlucHV0U2hhcGUubGVuZ3RoID8gMCA6IHNoYXBlLmxlbmd0aCAtIGlucHV0U2hhcGUubGVuZ3RoO1xuICBsZXQgaW5wdXRTaGFwZUluZGV4ID0gaW5wdXRTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGggPyAwIDogaW5wdXRTaGFwZS5sZW5ndGggLSBzaGFwZS5sZW5ndGg7XG4gIGZvciAoOyBzaGFwZUluZGV4IDwgc2hhcGUubGVuZ3RoICYmIGlucHV0U2hhcGVJbmRleCA8IGlucHV0U2hhcGUubGVuZ3RoOyArK3NoYXBlSW5kZXgsICsraW5wdXRTaGFwZUluZGV4KSB7XG4gICAgaWYgKHNoYXBlW3NoYXBlSW5kZXhdICE9PSBpbnB1dFNoYXBlW2lucHV0U2hhcGVJbmRleF0gJiYgc2hhcGVbc2hhcGVJbmRleF0gIT09IDEgJiZcbiAgICAgICAgaW5wdXRTaGFwZVtpbnB1dFNoYXBlSW5kZXhdICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGFuZCByZXF1aXJlcyBzaGFwZSB0byBiZSBicm9hZGNhc3RhYmxlIHRvIGlucHV0Jyk7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBnZXRBZGp1c3RlZFNoYXBlID0gKHNoYXBlMTogcmVhZG9ubHkgbnVtYmVyW10sIHNoYXBlMjogcmVhZG9ubHkgbnVtYmVyW10pOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IGRpZmYgPSBzaGFwZTEubGVuZ3RoIC0gc2hhcGUyLmxlbmd0aDtcbiAgY29uc3Qgc2hhcGU6IG51bWJlcltdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZjsgKytpKSB7XG4gICAgc2hhcGUucHVzaChzaGFwZTFbaV0pO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2hhcGUyLmxlbmd0aDsgKytpKSB7XG4gICAgc2hhcGUucHVzaChzaGFwZTJbaV0gPT09IDEgPyBzaGFwZTFbaSArIGRpZmZdIDogc2hhcGUyW2ldKTtcbiAgfVxuICByZXR1cm4gc2hhcGU7XG59O1xuXG5jb25zdCBjYWxjdWxhdGVPdXRwdXRTaGFwZSA9IChpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKTogbnVtYmVyW10gPT5cbiAgICAoaW5wdXRTaGFwZS5sZW5ndGggPiBzaGFwZS5sZW5ndGgpID8gZ2V0QWRqdXN0ZWRTaGFwZShpbnB1dFNoYXBlLCBzaGFwZSkgOiBnZXRBZGp1c3RlZFNoYXBlKHNoYXBlLCBpbnB1dFNoYXBlKTtcblxuXG5jb25zdCBjcmVhdGVFeHBhbmRQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBzaGFwZSA9IEFycmF5LmZyb20oaW5wdXRzWzFdLmdldEJpZ0ludDY0QXJyYXkoKSwgTnVtYmVyKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gY2FsY3VsYXRlT3V0cHV0U2hhcGUoaW5wdXRTaGFwZSwgc2hhcGUpO1xuICBjb25zdCBkYXRhVHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcbiAgY29uc3QgY29tcG9uZW50cyA9IGRhdGFUeXBlID09PSBEYXRhVHlwZS5ib29sID8gNCA6IDE7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gY29tcG9uZW50cyk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGRhdGFUeXBlLCBpbnB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGxldCBhc3NpZ25tZW50OiBzdHJpbmc7XG4gICAgaWYgKGRhdGFUeXBlID09PSBEYXRhVHlwZS5ib29sKSB7XG4gICAgICBjb25zdCBzaW5nbGVBc3NpZ25tZW50ID0gKHJlc1N0cjogc3RyaW5nLCB4OiBudW1iZXIsIHR5cGVDYXN0ID0gJycpID0+IGBcbiAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7eH0gPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoYG91dHB1dE9mZnNldCArICR7eH11YCl9O1xuICAgICAgICAgIGxldCBvZmZzZXQke3h9ID0gJHtpbnB1dC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0SW5kaWNlcyR7eH1gLCBvdXRwdXQpfTtcbiAgICAgICAgICBsZXQgaW5kZXgke3h9ID0gb2Zmc2V0JHt4fSAvIDR1O1xuICAgICAgICAgIGxldCBjb21wb25lbnQke3h9ID0gb2Zmc2V0JHt4fSAlIDR1O1xuICAgICAgICAgICR7cmVzU3RyfVske3h9XSA9ICR7dHlwZUNhc3R9KCR7aW5wdXQuZ2V0QnlPZmZzZXQoYGluZGV4JHt4fWApfVtjb21wb25lbnQke3h9XSk7XG4gICAgICAgIGA7XG4gICAgICBhc3NpZ25tZW50ID0gYFxuICAgICAgICBsZXQgb3V0cHV0T2Zmc2V0ID0gZ2xvYmFsX2lkeCAqICR7Y29tcG9uZW50c307XG4gICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xuICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAwLCAndTMyJyl9XG4gICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnZGF0YScsIDEsICd1MzInKX1cbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMiwgJ3UzMicpfVxuICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAzLCAndTMyJyl9XG4gICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ2RhdGEnKX1cbiAgICAgIH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25tZW50ID0gYFxuICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICAgbGV0IGlucHV0T2Zmc2V0ID0gJHtpbnB1dC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCgnb3V0cHV0SW5kaWNlcycsIG91dHB1dCl9O1xuICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsIGlucHV0LmdldEJ5T2Zmc2V0KCdpbnB1dE9mZnNldCcpKX1cbiAgICAgIH1gO1xuICAgIH1cbiAgICByZXR1cm4gYFxuICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgndmVjX3NpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cbiAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy52ZWNfc2l6ZScpfVxuICAgICR7YXNzaWdubWVudH1gO1xuICB9O1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9XG4gICAgICBbe3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZX0sIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0U2hhcGUsIG91dHB1dFNoYXBlKV07XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0V4cGFuZCcsXG4gICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBgJHtvdXRwdXRTaGFwZS5sZW5ndGh9YCwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddfSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGV9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKX0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXNcbiAgICB9KVxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGV4cGFuZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFeHBhbmRQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cyksIHtpbnB1dHM6IFswXX0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mb30gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2lucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUsIFVuaWZvcm1zQXJyYXlUeXBlLCBXT1JLR1JPVVBfU0laRX0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0ICogYXMgdW5hcnkgZnJvbSAnLi91bmFyeS1vcCc7XG5cbi8vIEdFTFUgaXMgZGVmaW5lZCBhcyBZPTAuNSpYKigxK3RhbmgoMC43OTc4ODUqWCswLjAzNTY3NypYKlgqWCkpLCB3aGVyZSBYIG1heSBwcmUtYWRkIGEgYmlhcy5cblxuY29uc3QgY3JlYXRlRmFzdEdlbHVQcm9ncmFtSW5mbyA9IChpbnB1dFRlbnNvcnM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dFRlbnNvcnNbMF0uZGF0YVR5cGU7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShpbnB1dFRlbnNvcnNbMF0uZGltcyk7XG4gIGNvbnN0IGJpYXNMZW5ndGggPSBTaGFwZVV0aWwuc2l6ZShpbnB1dFRlbnNvcnNbMV0uZGltcyk7XG4gIC8vIGNhbiBvbmx5IHVzZSB2ZWM0IHdoZW4gYmlhcyBsZW5ndGggaXMgbXVsdGlwbGUgb2YgNFxuICBjb25zdCB1c2VWZWM0ID0gYmlhc0xlbmd0aCAlIDQgPT09IDA7XG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcik6IHN0cmluZyA9PiB7XG4gICAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoJ3gnLCBkYXRhVHlwZSwgWzFdLCA0KTtcbiAgICBjb25zdCBiaWFzID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGRhdGFUeXBlLCBbMV0sIDQpO1xuICAgIGNvbnN0IHkgPSBvdXRwdXRWYXJpYWJsZSgneScsIGRhdGFUeXBlLCBbMV0sIDQpO1xuXG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW3tuYW1lOiAnb3V0cHV0X3ZlY19zaXplJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ2JpYXNfc2l6ZScsIHR5cGU6ICd1MzInfV07XG5cbiAgICBjb25zdCBzaW5nbGVFbGVtZW50QmlhcyA9IChpOiAwfDF8MnwzKSA9PiBgXG4gICAgICBsZXQgYmlhcyR7aX1fb2Zmc2V0OiB1MzIgPSAoZ2xvYmFsX2lkeCAqIDQgKyAke2l9KSAlIHVuaWZvcm1zLmJpYXNfc2l6ZTtcbiAgICAgIGxldCBiaWFzJHtpfSA9ICR7Ymlhcy5nZXRCeU9mZnNldChgYmlhcyR7aX1fb2Zmc2V0IC8gNGApfVtiaWFzJHtpfV9vZmZzZXQgJSA0XTtgO1xuICAgIGNvbnN0IGJpYXNHZXRFeHByZXNzaW9uID0gdXNlVmVjNCA/XG4gICAgICAgIGBcbiAgICAgIGxldCBiaWFzID0gJHtiaWFzLmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4ICUgKHVuaWZvcm1zLmJpYXNfc2l6ZSAvIDQpJyl9O2AgOlxuICAgICAgICBgJHtzaW5nbGVFbGVtZW50QmlhcygwKX0ke3NpbmdsZUVsZW1lbnRCaWFzKDEpfSR7c2luZ2xlRWxlbWVudEJpYXMoMil9JHtzaW5nbGVFbGVtZW50QmlhcygzKX1cbiAgICAgIGxldCBiaWFzID0gJHt4LnR5cGUudmFsdWV9KGJpYXMwLCBiaWFzMSwgYmlhczIsIGJpYXMzKTtgO1xuXG4gICAgcmV0dXJuIGAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKHgsIGJpYXMsIHkpfVxuXG4gICAgJHt1bmFyeS5mYXN0R2VsdUltcGwodGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShkYXRhVHlwZSkpfVxuXG4gICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFdPUktHUk9VUF9TSVpFKX1cbiAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF92ZWNfc2l6ZScpfVxuXG4gICAgICBsZXQgeCA9ICR7eC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICR7Ymlhc0dldEV4cHJlc3Npb259XG4gICAgICBsZXQgeF9pbiA9IHggKyBiaWFzO1xuICAgICAgJHt5LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgdW5hcnkuZmFzdEdlbHVFeHByZXNzaW9uKCd4X2luJykpfVxuICAgIH1gO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0Zhc3RHZWx1V2l0aEJpYXMnLFxuICAgIHNoYWRlckNhY2hlOiB7aGludDogYCR7dXNlVmVjNH1gLCBpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJywgJ3R5cGUnXX0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIGdldFJ1bkRhdGE6IChpbnB1dHMpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbe2RpbXM6IGlucHV0c1swXS5kaW1zLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlfV0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXM6XG4gICAgICAgICAgW3t0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNCl9LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBiaWFzTGVuZ3RofV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyBXT1JLR1JPVVBfU0laRSAvIDQpfVxuICAgIH0pXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZmFzdEdlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgaWYgKGNvbnRleHQuaW5wdXRzLmxlbmd0aCA8IDIgfHwgU2hhcGVVdGlsLnNpemUoY29udGV4dC5pbnB1dHNbMV0uZGltcykgPT09IDApIHtcbiAgICB1bmFyeS5mYXN0R2VsdShjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRmFzdEdlbHVQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cykpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm19IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlcn0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEdhdGhlckF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBheGlzOiBudW1iZXI7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dhdGhlciByZXF1aXJlcyAyIGlucHV0cy4nKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlR2F0aGVyUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IEdhdGhlckF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgaW5kaWNlc1NoYXBlID0gaW5wdXRzWzFdLmRpbXM7XG5cbiAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXRTaGFwZS5sZW5ndGg7XG4gIGNvbnN0IGF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhhdHRyaWJ1dGVzLmF4aXMsIGlucHV0UmFuayk7XG5cbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlLnNsaWNlKDApO1xuICBvdXRwdXRTaGFwZS5zcGxpY2UoYXhpcywgMSwgLi4uaW5kaWNlc1NoYXBlKTtcblxuICBjb25zdCBheGlzRGltTGltaXQgPSBpbnB1dFNoYXBlW2F4aXNdO1xuICBjb25zdCBjb21wb25lbnRzID0gaW5wdXRzWzBdLmRhdGFUeXBlID09PSBEYXRhVHlwZS5ib29sID8gNCA6IDE7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gY29tcG9uZW50cyk7XG5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemV9LCB7dHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGF4aXNEaW1MaW1pdH0sXG4gICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXhpc30sIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1swXS5kaW1zLCBpbnB1dHNbMV0uZGltcywgb3V0cHV0U2hhcGUpXG4gIF07XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IGlucHV0VmFyaWFibGUoJ2RhdGEnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3QgaW5kaWNlcyA9IGlucHV0VmFyaWFibGUoJ2lucHV0SW5kaWNlcycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoKTtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuXG4gICAgY29uc3QgY2FsY0RhdGFJbmRpY2VzID0gKHg6IG51bWJlcnxzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgICAgY29uc3QgaW5kaWNlc1JhbmsgPSBpbmRpY2VzU2hhcGUubGVuZ3RoO1xuICAgICAgbGV0IGNhbGNTdHIgPSBgdmFyIGluZGljZXNJbmRpY2VzJHt4fSAgPSAke2luZGljZXMudHlwZS5pbmRpY2VzfSgwKTtgO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRpY2VzUmFuazsgaSsrKSB7XG4gICAgICAgIGNhbGNTdHIgKz0gYCR7aW5kaWNlc1JhbmsgPiAxID8gYGluZGljZXNJbmRpY2VzJHt4fVske2l9XWAgOiBgaW5kaWNlc0luZGljZXMke3h9YH0gPSAke1xuICAgICAgICAgICAgb3V0cHV0U2hhcGUubGVuZ3RoID4gMSA/IGBvdXRwdXRJbmRpY2VzJHt4fVt1bmlmb3Jtcy5heGlzICsgJHtpfV1gIDogYG91dHB1dEluZGljZXMke3h9YH07YDtcbiAgICAgIH1cbiAgICAgIGNhbGNTdHIgKz0gYFxuICAgICAgICAgIHZhciBpZHgke3h9ID0gJHtpbmRpY2VzLmdldEJ5SW5kaWNlcyhgaW5kaWNlc0luZGljZXMke3h9YCl9O1xuICAgICAgICAgIGlmIChpZHgke3h9IDwgMCkge1xuICAgICAgICAgICAgaWR4JHt4fSA9IGlkeCR7eH0gKyB1bmlmb3Jtcy5heGlzRGltTGltaXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkYXRhSW5kaWNlcyR7eH0gOiAke2RhdGEudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgYDtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IGlucHV0UmFuazsgaSsrKSB7XG4gICAgICAgIGlmIChpID09PSBheGlzKSB7XG4gICAgICAgICAgY2FsY1N0ciArPSBgJHtpbnB1dFJhbmsgPiAxID8gYGRhdGFJbmRpY2VzJHt4fVske2l9XWAgOiBgZGF0YUluZGljZXMke3h9YH0gPSB1MzIoaWR4JHt4fSk7YDtcbiAgICAgICAgICBqICs9IGluZGljZXNSYW5rO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGNTdHIgKz0gYCR7aW5wdXRSYW5rID4gMSA/IGBkYXRhSW5kaWNlcyR7eH1bJHtpfV1gIDogYGRhdGFJbmRpY2VzJHt4fWB9ID0gJHtcbiAgICAgICAgICAgICAgb3V0cHV0U2hhcGUubGVuZ3RoID4gMSA/IGBvdXRwdXRJbmRpY2VzJHt4fVske2p9XWAgOiBgb3V0cHV0SW5kaWNlcyR7eH1gfTtgO1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbGNTdHI7XG4gICAgfTtcbiAgICBsZXQgYXNzaWdubWVudDogc3RyaW5nO1xuICAgIGlmIChpbnB1dHNbMF0uZGF0YVR5cGUgPT09IERhdGFUeXBlLmJvb2wpIHtcbiAgICAgIGNvbnN0IHNpbmdsZUFzc2lnbm1lbnQgPSAocmVzU3RyOiBzdHJpbmcsIHg6IG51bWJlciwgdHlwZUNhc3QgPSAnJykgPT4gYFxuICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzJHt4fSA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcyhgb3V0cHV0T2Zmc2V0ICsgJHt4fXVgKX07XG4gICAgICAgICAgJHtjYWxjRGF0YUluZGljZXMoeCl9O1xuICAgICAgICAgIGxldCBvZmZzZXQke3h9ID0gJHtkYXRhLmluZGljZXNUb09mZnNldChgZGF0YUluZGljZXMke3h9YCl9O1xuICAgICAgICAgIGxldCBpbmRleCR7eH0gPSBvZmZzZXQke3h9IC8gNHU7XG4gICAgICAgICAgbGV0IGNvbXBvbmVudCR7eH0gPSBvZmZzZXQke3h9ICUgNHU7XG4gICAgICAgICAgJHtyZXNTdHJ9WyR7eH1dID0gJHt0eXBlQ2FzdH0oJHtkYXRhLmdldEJ5T2Zmc2V0KGBpbmRleCR7eH1gKX1bY29tcG9uZW50JHt4fV0pO1xuICAgICAgICBgO1xuICAgICAgYXNzaWdubWVudCA9IGBcbiAgICAgICAgbGV0IG91dHB1dE9mZnNldCA9IGdsb2JhbF9pZHggKiAke2NvbXBvbmVudHN9O1xuICAgICAgICB2YXIgdmFsdWUgPSB2ZWM0PHUzMj4oMCk7XG4gICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgndmFsdWUnLCAwLCAndTMyJyl9XG4gICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgndmFsdWUnLCAxLCAndTMyJyl9XG4gICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgndmFsdWUnLCAyLCAndTMyJyl9XG4gICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgndmFsdWUnLCAzLCAndTMyJyl9XG4gICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlJyl9XG4gICAgICBgO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25tZW50ID0gYFxuICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICAke2NhbGNEYXRhSW5kaWNlcygnJyl9O1xuICAgICAgbGV0IHZhbHVlID0gJHtkYXRhLmdldEJ5SW5kaWNlcygnZGF0YUluZGljZXMnKX07XG4gICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpfTtcbiAgICAgIGA7XG4gICAgfVxuICAgIHJldHVybiBgXG4gICAgICAke1xuICAgICAgICBzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRTaXplJywgJ3UzMicpXG4gICAgICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdheGlzRGltTGltaXQnLCAnaTMyJylcbiAgICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ2F4aXMnLCAndTMyJylcbiAgICAgICAgICAgIC5kZWNsYXJlVmFyaWFibGVzKGRhdGEsIGluZGljZXMsIG91dHB1dCl9XG4gICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxuICAgICAgICAke2Fzc2lnbm1lbnR9XG4gICAgICB9YDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnR2F0aGVyJyxcbiAgICBzaGFkZXJDYWNoZToge2hpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnLCAncmFuayddfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW1xuICAgICAgICB7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGV9LFxuICAgICAgXSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKX0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXNcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VHYXRoZXJBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogR2F0aGVyQXR0cmlidXRlcyA9PlxuICAgIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7YXhpczogYXR0cmlidXRlcy5heGlzIGFzIG51bWJlcn0pO1xuXG5leHBvcnQgY29uc3QgZ2F0aGVyID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBHYXRoZXJBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGlucHV0cyA9IGNvbnRleHQuaW5wdXRzO1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlR2F0aGVyUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm19IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlcn0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEdhdGhlckVsZW1lbnRzQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIGF4aXM6IG51bWJlcjtcbn1cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignR2F0aGVyRWxlbWVudHMgcmVxdWlyZXMgMiBpbnB1dHMuJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignR2F0aGVyRWxlbWVudHMgcmVxdWlyZXMgdGhhdCB0aGUgZGF0YSBpbnB1dCBiZSByYW5rID49IDEuJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSBpbnB1dHNbMV0uZGltcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEdhdGhlckVsZW1lbnRzIHJlcXVpcmVzIHRoYXQgdGhlIGRhdGEgaW5wdXQgYW5kXG4gICAgICAgICAgICAgICAgICAgICBpbmRpY2VzIGlucHV0IHRlbnNvcnMgYmUgb2Ygc2FtZSByYW5rLmApO1xuICB9XG59O1xuXG5jb25zdCBjcmVhdGVHYXRoZXJFbGVtZW50c1Byb2dyYW1JbmZvID1cbiAgICAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IEdhdGhlckVsZW1lbnRzQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICAgIGNvbnN0IGlucHV0T3V0cHV0RGF0YVR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XG4gICAgICBjb25zdCBpbnB1dFJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcblxuICAgICAgY29uc3QgaW5kaWNlc1NoYXBlID0gaW5wdXRzWzFdLmRpbXM7XG4gICAgICBjb25zdCBpbmRpY2VzRGF0YVR5cGUgPSBpbnB1dHNbMV0uZGF0YVR5cGU7XG4gICAgICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dFJhbmspO1xuICAgICAgY29uc3QgYXhpc0RpbUxpbWl0ID0gaW5wdXRTaGFwZVtheGlzXTtcblxuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbmRpY2VzU2hhcGUuc2xpY2UoMCk7XG4gICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuXG4gICAgICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaW5wdXRPdXRwdXREYXRhVHlwZSwgaW5wdXRSYW5rKTtcbiAgICAgIGNvbnN0IGluZGljZXMgPSBpbnB1dFZhcmlhYmxlKCdpbmRpY2VzSW5wdXQnLCBpbmRpY2VzRGF0YVR5cGUsIGluZGljZXNTaGFwZS5sZW5ndGgpO1xuICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0T3V0cHV0RGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG5cblxuICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplfSwge3R5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBheGlzRGltTGltaXR9LFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBheGlzfVxuICAgICAgXTtcbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0U2hhcGUsIGluZGljZXNTaGFwZSwgb3V0cHV0U2hhcGUpKTtcbiAgICAgIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWydyYW5rJywgJ3JhbmsnXTtcblxuICAgICAgLy8gaW50NjQgaW5kaWNlcyB3b3VsZCBiZSB0cmVhdGVkIGFzIGxpdHRsZSBlbmRpYW4gaTMyIHdpdGggYXNzdW1wdGlvbiB0aGV5IGZhbGwgaW4gaTMyIGxpbWl0c1xuICAgICAgLy8gVGhhdCBhc3N1bXB0aW9uIGlzIHNhZmUgYXMgaXQncyBub3QgcG9zc2libGUgdG8gYWxsb2NhdGUgPjJnYiBidWZmZXIgZm9yIGlucHV0IHRlbnNvclxuICAgICAgLy8gSW5wdXQgZGF0YSB3aWxsIGJlIHRyZWF0ZWQgYXMgdTMyIG9yIHR3byB1MzIgZm9yIDgtYnl0ZSB0ZW5zb3JzXG4gICAgICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgICAgICR7XG4gICAgICAgICAgc2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0U2l6ZScsICd1MzInKVxuICAgICAgICAgICAgICAucmVnaXN0ZXJVbmlmb3JtKCdheGlzRGltTGltaXQnLCAnaTMyJylcbiAgICAgICAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnYXhpcycsICd1MzInKVxuICAgICAgICAgICAgICAuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgaW5kaWNlcywgb3V0cHV0KX1cbiAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxuXG4gICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcblxuICAgICAgdmFyIGlkeCA9ICR7aW5kaWNlcy5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfTtcbiAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgIGlkeCA9IGlkeCArIHVuaWZvcm1zLmF4aXNEaW1MaW1pdDtcbiAgICAgIH1cbiAgICAgIHZhciBpbnB1dEluZGljZXMgPSAke2lucHV0LnR5cGUuaW5kaWNlc30ob3V0cHV0SW5kaWNlcyk7XG4gICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0SW5kaWNlcycsICd1bmlmb3Jtcy5heGlzJywgJ3UzMihpZHgpJyl9O1xuICAgICAgbGV0IHZhbHVlID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0SW5kaWNlcycpfTtcblxuICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWUnKX07XG4gIH1gO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnR2F0aGVyRWxlbWVudHMnLFxuICAgICAgICBzaGFkZXJDYWNoZToge2lucHV0RGVwZW5kZW5jaWVzfSxcbiAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgICBvdXRwdXRzOiBbe2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlfV0sXG4gICAgICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfSxcbiAgICAgICAgICBwcm9ncmFtVW5pZm9ybXNcbiAgICAgICAgfSksXG4gICAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICAgIH07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlR2F0aGVyRWxlbWVudHNBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogR2F0aGVyRWxlbWVudHNBdHRyaWJ1dGVzID0+XG4gICAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtheGlzOiBhdHRyaWJ1dGVzLmF4aXMgYXMgbnVtYmVyfSk7XG5cbmV4cG9ydCBjb25zdCBnYXRoZXJFbGVtZW50cyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogR2F0aGVyRWxlbWVudHNBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGlucHV0cyA9IGNvbnRleHQuaW5wdXRzO1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlR2F0aGVyRWxlbWVudHNQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcykpO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge0dlbW1VdGlsLCBTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIEluZGljZXNIZWxwZXIsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIFVuaWZvcm1zQXJyYXlUeXBlfSBmcm9tICcuL2NvbW1vbic7XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBpcyBtaXNzaW5nJyk7XG4gIH1cbiAgaWYgKGlucHV0cy5sZW5ndGggPCAyIHx8IGlucHV0cy5sZW5ndGggPiAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhaWQgaW5wdXQgbnVtYmVyLicpO1xuICB9XG5cbiAgLy8gJ0MnIGNhbiBiZSBvZiBkaW1lbnNpb25hbGl0eSAwLCAxIG9yIDIgb25seVxuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiBpbnB1dHNbMl0uZGltcy5sZW5ndGggPiAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHNoYXBlIG9mIEMnKTtcbiAgfVxuXG4gIGlmICgoaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBpbnB1dHNbMV0uZGF0YVR5cGUpIHx8XG4gICAgICAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiBpbnB1dHNbMF0uZGF0YVR5cGUgIT09IGlucHV0c1syXS5kYXRhVHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHR5cGVzIGFyZSBtaXNtYXRjaGVkJyk7XG4gIH1cbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2VtbUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICB0cmFuc0E6IGJvb2xlYW47XG4gIHRyYW5zQjogYm9vbGVhbjtcbiAgYWxwaGE6IG51bWJlcjtcbiAgYmV0YTogbnVtYmVyO1xufVxuXG5jb25zdCBjcmVhdGVHZW1tUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IEdlbW1BdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBhU2hhcGUgPSBpbnB1dHNbMF0uZGltcy5zbGljZSgpO1xuICBjb25zdCBiU2hhcGUgPSBpbnB1dHNbMV0uZGltcy5zbGljZSgpO1xuICBjb25zdCBbTSwgTiwgS10gPSBHZW1tVXRpbC5nZXRTaGFwZU9mR2VtbVJlc3VsdChcbiAgICAgIGFTaGFwZSwgYXR0cmlidXRlcy50cmFuc0EsIGJTaGFwZSwgYXR0cmlidXRlcy50cmFuc0IsIGlucHV0cy5sZW5ndGggPT09IDMgPyBpbnB1dHNbMl0uZGltcyA6IHVuZGVmaW5lZCk7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gW00sIE5dO1xuICBpZiAoIW91dHB1dFNoYXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IHVzZSBnZW1tIG9uIHRoZSBnaXZlbiB0ZW5zb3JzJyk7XG4gIH1cbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemV9LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNfSwge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTn0sXG4gICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogS30sIHt0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5hbHBoYX0sXG4gICAge3R5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBhdHRyaWJ1dGVzLmJldGF9XG4gIF07XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWyd0eXBlJywgJ3R5cGUnXTtcbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMpIHtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMl0uZGltcykpO1xuICAgIGlucHV0RGVwZW5kZW5jaWVzLnB1c2goJ3JhbmsnKTtcbiAgfVxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSkpO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGxldCBsaW5lID0gJyc7XG4gICAgaWYgKGF0dHJpYnV0ZXMudHJhbnNBICYmIGF0dHJpYnV0ZXMudHJhbnNCKSB7XG4gICAgICBsaW5lID0gJ3ZhbHVlICs9IGFbayAqIHVuaWZvcm1zLk0gKyBtXSAqIGJbbiAqIHVuaWZvcm1zLksgKyBrXTsnO1xuICAgIH0gZWxzZSBpZiAoYXR0cmlidXRlcy50cmFuc0EgJiYgIWF0dHJpYnV0ZXMudHJhbnNCKSB7XG4gICAgICBsaW5lID0gJ3ZhbHVlICs9IGFbayAqIHVuaWZvcm1zLk0gKyBtXSAqIGJbayAqIHVuaWZvcm1zLk4gKyBuXTsnO1xuICAgIH0gZWxzZSBpZiAoIWF0dHJpYnV0ZXMudHJhbnNBICYmIGF0dHJpYnV0ZXMudHJhbnNCKSB7XG4gICAgICBsaW5lID0gJ3ZhbHVlICs9IGFbbSAqIHVuaWZvcm1zLksgKyBrXSAqIGJbbiAqIHVuaWZvcm1zLksgKyBrXTsnO1xuICAgIH0gZWxzZSBpZiAoIWF0dHJpYnV0ZXMudHJhbnNBICYmICFhdHRyaWJ1dGVzLnRyYW5zQikge1xuICAgICAgbGluZSA9ICd2YWx1ZSArPSBhW20gKiB1bmlmb3Jtcy5LICsga10gKiBiW2sgKiB1bmlmb3Jtcy5OICsgbl07JztcbiAgICB9XG5cbiAgICBjb25zdCBjYWxjdWxhdGVBbHBoYSA9IGF0dHJpYnV0ZXMuYWxwaGEgPT09IDEgPyAnJyA6ICd2YWx1ZSAqPSB1bmlmb3Jtcy5hbHBoYTsnO1xuICAgIGNvbnN0IGEgPSBpbnB1dFZhcmlhYmxlKCdhJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcyk7XG4gICAgY29uc3QgYiA9IGlucHV0VmFyaWFibGUoJ2InLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zKTtcbiAgICBjb25zdCBkYXRhVHlwZSA9IGEudHlwZS52YWx1ZTtcbiAgICBsZXQgYzogSW5kaWNlc0hlbHBlcnxudWxsID0gbnVsbDtcbiAgICBjb25zdCB2YXJpYWJsZXMgPSBbYSwgYl07XG4gICAgaWYgKGlucHV0cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGMgPSBpbnB1dFZhcmlhYmxlKCdjJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgpO1xuICAgICAgdmFyaWFibGVzLnB1c2goYyk7XG4gICAgfVxuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gICAgdmFyaWFibGVzLnB1c2gob3V0cHV0KTtcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7bmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ00nLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnTicsIHR5cGU6ICd1MzInfSwge25hbWU6ICdLJywgdHlwZTogJ3UzMid9LFxuICAgICAge25hbWU6ICdhbHBoYScsIHR5cGU6ICdmMzInfSwge25hbWU6ICdiZXRhJywgdHlwZTogJ2YzMid9XG4gICAgXTtcbiAgICByZXR1cm4gYFxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLnZhcmlhYmxlcyl9XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cblxuICAgIGxldCBtID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLk47XG4gICAgbGV0IG4gPSBnbG9iYWxfaWR4ICUgdW5pZm9ybXMuTjtcblxuICAgIHZhciB2YWx1ZSA9ICR7ZGF0YVR5cGV9KDApO1xuICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgdW5pZm9ybXMuSzsgaysrKSB7XG4gICAgICAke2xpbmV9XG4gICAgfVxuXG4gICAgJHtjYWxjdWxhdGVBbHBoYX1cbiAgICAkeygoKSA9PiB7XG4gICAgICBpZiAoYyAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBgbGV0IGNPZmZzZXQgPSAke2MuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoJ3ZlYzIobSwgbiknLCBvdXRwdXQpfTsgdmFsdWUgKz0gJHtcbiAgICAgICAgICAgIGRhdGFUeXBlfSh1bmlmb3Jtcy5iZXRhKSAqICR7Yy5nZXRCeU9mZnNldCgnY09mZnNldCcpfTtgO1xuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICAgIH0pKCl9XG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gIH1gO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0dlbW0nLFxuICAgIHNoYWRlckNhY2hlOiB7aGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX1gLCBpbnB1dERlcGVuZGVuY2llc30sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGV9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKX0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXNcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VHZW1tQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEdlbW1BdHRyaWJ1dGVzID0+IHtcbiAgY29uc3QgdHJhbnNBID0gYXR0cmlidXRlcy50cmFuc0EgYXMgYm9vbGVhbjtcbiAgY29uc3QgdHJhbnNCID0gYXR0cmlidXRlcy50cmFuc0IgYXMgYm9vbGVhbjtcbiAgY29uc3QgYWxwaGEgPSBhdHRyaWJ1dGVzLmFscGhhIGFzIG51bWJlcjtcbiAgY29uc3QgYmV0YSA9IGF0dHJpYnV0ZXMuYmV0YSBhcyBudW1iZXI7XG4gIHJldHVybiB7dHJhbnNBLCB0cmFuc0IsIGFscGhhLCBiZXRhLCBjYWNoZUtleTogYCR7YXR0cmlidXRlcy50cmFuc0F9OyR7YXR0cmlidXRlcy50cmFuc0J9OyR7YXR0cmlidXRlcy5hbHBoYSA9PT0gMX1gfTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZW1tID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBHZW1tQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVHZW1tUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBHcHVEYXRhVHlwZSwgUHJvZ3JhbVVuaWZvcm19IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHthcHBseUF0dGVudGlvbiwgQXR0ZW50aW9uQXR0cnMsIEF0dGVudGlvbk1hc2tUeXBlLCBBdHRlbnRpb25QYXJhbWV0ZXJzLCBBdHRlbnRpb25Ra3ZGb3JtYXR9IGZyb20gJy4vYXR0ZW50aW9uJztcbmltcG9ydCB7aW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciwgVW5pZm9ybXNBcnJheVR5cGV9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7Y3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8sIFRyYW5zcG9zZUF0dHJpYnV0ZXN9IGZyb20gJy4vdHJhbnNwb3NlJztcblxuY29uc3QgZ2V0SW5wdXQgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGk6IG51bWJlcikgPT5cbiAgICAoaW5wdXRzLmxlbmd0aCA+IGkpICYmIChpbnB1dHNbaV0uZGltcy5sZW5ndGggPiAwKSAmJiAoU2hhcGVVdGlsLnNpemUoaW5wdXRzW2ldLmRpbXMpKSA+IDAgPyBpbnB1dHNbaV0gOiB1bmRlZmluZWQ7XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBBdHRlbnRpb25BdHRycyk6IEF0dGVudGlvblBhcmFtZXRlcnMgPT4ge1xuICBjb25zdCBxdWVyeSA9IGlucHV0c1swXTtcbiAgY29uc3Qga2V5ID0gZ2V0SW5wdXQoaW5wdXRzLCAxKTtcbiAgY29uc3QgdmFsdWUgPSBnZXRJbnB1dChpbnB1dHMsIDIpO1xuICBjb25zdCBiaWFzID0gZ2V0SW5wdXQoaW5wdXRzLCAzKTtcbiAgY29uc3Qga2V5UGFkZGluZ01hc2sgPSBnZXRJbnB1dChpbnB1dHMsIDQpO1xuICBjb25zdCByZWxhdGl2ZVBvc2l0aW9uQmlhcyA9IGdldElucHV0KGlucHV0cywgNSk7XG4gIGNvbnN0IHBhc3RLZXkgPSBnZXRJbnB1dChpbnB1dHMsIDYpO1xuICBjb25zdCBwYXN0VmFsdWUgPSBnZXRJbnB1dChpbnB1dHMsIDcpO1xuXG4gIC8vIEFiYnJldmlhdGlvbiBhbmQgTWVhbmluZ3M6XG4gIC8vICAgQjogICAgYmF0Y2hfc2l6ZVxuICAvLyAgIFM6ICAgIHNlcXVlbmNlX2xlbmd0aCAoaW5wdXQgc2VxdWVuY2UgbGVuZ3RoIG9mIHF1ZXJ5KVxuICAvLyAgIFA6ICAgIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoIChwYXN0IHNlcXVlbmNlIGxlbmd0aCBvZiBrZXkgb3IgdmFsdWUpXG4gIC8vICAgTDogICAga3Zfc2VxdWVuY2VfbGVuZ3RoIChpbnB1dCBzZXF1ZW5jZSBsZW5ndGggb2Yga2V5IG9yIHZhbHVlKVxuICAvLyAgIE06ICAgIG1heF9zZXF1ZW5jZV9sZW5ndGhcbiAgLy8gICBUOiAgICB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSBwYXN0X3NlcXVlbmNlX2xlbmd0aCArIGt2X3NlcXVlbmNlX2xlbmd0aFxuICAvLyAgIE46ICAgIG51bV9oZWFkc1xuICAvLyAgIEg6ICAgIGhlYWQgc2l6ZSBmb3IgUSBhbmQgSywgYWthIHFfaGVhZF9zaXplIG9yIGtfaGVhZF9zaXplIG9yIHFrX2hlYWRfc2l6ZVxuICAvLyAgIEhfdjogIHZfaGVhZF9zaXplXG4gIC8vICAgRF9pOiAgaW5wdXQgaGlkZGVuIHNpemVcbiAgLy8gICBEOiAgICBoaWRkZW4gc2l6ZSBmb3IgUSBhbmQgSyAoRCA9IE4gKiBIKSwgYWthIHFfaGlkZGVuX3NpemUgb3Iga19oaWRkZW5fc2l6ZSBvciBxa19oaWRkZW5fc2l6ZVxuICAvLyAgIERfdjogIHZfaGlkZGVuX3NpemUgPSBudW1faGVhZHMgKiB2X2hlYWRfc2l6ZVxuXG4gIC8vICAgICBrZXlfcGFkZGluZ19tYXNrIChLL1YpICAgICA6IChCKSBvciAoMipCICsgMSkgb3IgKEIsIEwpIG9yIE5vbmVcbiAgLy8gICAgIHJlbGF0aXZlX3Bvc2l0aW9uX2JpYXMgICAgIDogKEIsIDEsIFMsIEwpXG4gIC8vICAgICBwYXN0X2tleSAgICAgICAgICAgICAgICAgICA6IChCLCBOLCBTKiwgSClcbiAgLy8gICAgIHBhc3RfdmFsdWUgICAgICAgICAgICAgICAgIDogKEIsIE4sIFMqLCBIKVxuICAvLyBXaGVuIG5vIHBhY2tpbmcgZm9yIHEvay92OlxuICAvLyAgICAgcXVlcnkgICAgICAgICAgICAoUSkgICAgICAgOiAoQiwgUywgRClcbiAgLy8gICAgIGtleSAgICAgICAgICAgICAgKEspICAgICAgIDogKEIsIEwsIEQpIG9yIChCLCBOLCBTKiwgSClcbiAgLy8gICAgIHZhbHVlICAgICAgICAgICAgKFYpICAgICAgIDogKEIsIEwsIERfdikgb3IgKEIsIE4sIFMqLCBIKVxuICAvLyAgICAgYmlhcyAgICAgICAgICAgICAoUS9LL1YpICAgOiAoRCArIEQgKyBEX3YpXG4gIC8vIFdoZW4gcGFja2VkIGt2IGlzIHVzZWQ6XG4gIC8vICAgICBxdWVyeSAgICAgICAgICAgIChRKSAgICAgICA6IChCLCBTLCBEKVxuICAvLyAgICAga2V5ICAgICAgICAgICAgICAoSykgICAgICAgOiAoQiwgTCwgTiwgMiwgSClcbiAgLy8gICAgIHZhbHVlICAgICAgICAgICAgKFYpICAgICAgIDogTm9uZVxuICAvLyAgICAgYmlhcyAgICAgICAgICAgICAoUS9LL1YpICAgOiBOb25lXG4gIC8vIFdoZW4gcGFja2VkIHFrdiBpcyB1c2VkOlxuICAvLyAgICAgcXVlcnkgICAgICAgICAgICAoUSkgICAgICAgOiAoQiwgTCwgTiwgMywgSCkgb3IgKEIsIFMsIDMqRClcbiAgLy8gICAgIGtleSAgICAgICAgICAgICAgKEspICAgICAgIDogTm9uZVxuICAvLyAgICAgdmFsdWUgICAgICAgICAgICAoVikgICAgICAgOiBOb25lXG4gIC8vICAgICBiaWFzICAgICAgICAgICAgIChRL0svVikgICA6IE5vbmUgb3IgKEQgKyBEICsgRF92KVxuXG4gIGlmIChxdWVyeS5kaW1zLmxlbmd0aCAhPT0gMyAmJiBxdWVyeS5kaW1zLmxlbmd0aCAhPT0gNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgcXVlcnkgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDUgZGltZW5zaW9ucycpO1xuICB9XG5cbiAgY29uc3QgZG1taGFQYWNraW5nID0gZmFsc2U7XG4gIGNvbnN0IGJhdGNoU2l6ZSA9IHF1ZXJ5LmRpbXNbMF07XG4gIGNvbnN0IHNlcXVlbmNlTGVuZ3RoID0gcXVlcnkuZGltc1sxXTtcbiAgY29uc3QgaGlkZGVuU2l6ZSA9IHF1ZXJ5LmRpbXMubGVuZ3RoID09PSAzID8gKGRtbWhhUGFja2luZyA/IHF1ZXJ5LmRpbXNbMl0gLyAzIDogcXVlcnkuZGltc1syXSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLm51bUhlYWRzICogcXVlcnkuZGltc1s0XTtcbiAgbGV0IGt2U2VxdWVuY2VMZW5ndGggPSBzZXF1ZW5jZUxlbmd0aDtcblxuICBsZXQgcGFzdFNlcXVlbmNlTGVuZ3RoID0gMDtcbiAgbGV0IG1heFNlcXVlbmNlTGVuZ3RoID0gMDtcbiAgY29uc3QgaGVhZFNpemUgPSBNYXRoLmZsb29yKGhpZGRlblNpemUgLyBhdHRyaWJ1dGVzLm51bUhlYWRzKTtcbiAgaWYgKHBhc3RLZXkgJiYgcGFzdFZhbHVlKSB7XG4gICAgaWYgKHBhc3RLZXkuZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7XG4gICAgfVxuICAgIGlmIChwYXN0S2V5LmRpbXNbMF0gIT09IGJhdGNoU2l6ZSB8fCBwYXN0S2V5LmRpbXNbMV0gIT09IGF0dHJpYnV0ZXMubnVtSGVhZHMgfHwgcGFzdEtleS5kaW1zWzNdICE9PSBoZWFkU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywgcGFzdF9zZXF1ZW5jZV9sZW5ndGgsIGhlYWRfc2l6ZSknKTtcbiAgICB9XG4gICAgaWYgKHBhc3RWYWx1ZS5kaW1zWzBdICE9PSBiYXRjaFNpemUgfHwgcGFzdFZhbHVlLmRpbXNbMV0gIT09IGF0dHJpYnV0ZXMubnVtSGVhZHMgfHxcbiAgICAgICAgcGFzdFZhbHVlLmRpbXNbM10gIT09IGhlYWRTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF92YWx1ZVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpJyk7XG4gICAgfVxuICAgIGlmIChwYXN0S2V5LmRpbXNbMl0gIT09IHBhc3RWYWx1ZS5kaW1zWzJdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAyIChwYXN0X3NlcXVlbmNlX2xlbmd0aCknKTtcbiAgICB9XG4gICAgaWYgKHBhc3RWYWx1ZS5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RfdmFsdWVcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO1xuICAgIH1cbiAgICBwYXN0U2VxdWVuY2VMZW5ndGggPSBwYXN0S2V5LmRpbXNbMl07XG4gICAgbWF4U2VxdWVuY2VMZW5ndGggPSBwYXN0S2V5LmRpbXNbMl07XG4gIH0gZWxzZSBpZiAocGFzdEtleSB8fCBwYXN0VmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgYmUgYm90aCBwcmVzZW50IG9yIGJvdGggYWJzZW50Jyk7XG4gIH1cblxuICBsZXQgcWt2Rm9ybWF0OiBBdHRlbnRpb25Ra3ZGb3JtYXQ7XG4gIGlmIChrZXkpIHtcbiAgICBpZiAocXVlcnkuZGltcy5sZW5ndGggIT09IDMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBkaW1lbnNpb25zIHdoZW4ga2V5IGlzIGdpdmVuJyk7XG4gICAgfVxuICAgIGlmIChrZXkuZGltcy5sZW5ndGggPCAzIHx8IGtleS5kaW1zLmxlbmd0aCA+IDUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMsIDQsIG9yIDUgZGltZW5zaW9ucycpO1xuICAgIH1cbiAgICBpZiAocXVlcnkuZGltc1swXSAhPT0ga2V5LmRpbXNbMF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcImtleVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2ggc2l6ZSknKTtcbiAgICB9XG5cbiAgICBpZiAoa2V5LmRpbXMubGVuZ3RoID09PSAzKSB7XG4gICAgICBpZiAoa2V5LmRpbXNbMl0gIT09IHF1ZXJ5LmRpbXNbMl0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwia2V5XCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAyIChoaWRkZW5fc2l6ZSknKTtcbiAgICAgIH1cbiAgICAgIHFrdkZvcm1hdCA9IEF0dGVudGlvblFrdkZvcm1hdC5xa3ZCU05IO1xuICAgICAga3ZTZXF1ZW5jZUxlbmd0aCA9IGtleS5kaW1zWzFdO1xuICAgIH0gZWxzZSBpZiAoa2V5LmRpbXMubGVuZ3RoID09PSA1KSB7XG4gICAgICBpZiAoa2V5LmRpbXNbMl0gIT09IGF0dHJpYnV0ZXMubnVtSGVhZHMgfHwga2V5LmRpbXNbM10gIT09IDIgfHwga2V5LmRpbXNbNF0gIT09IGhlYWRTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwia2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIGt2X3NlcXVlbmNlX2xlbmd0aCwgbnVtX2hlYWRzLCAyLCBoZWFkX3NpemUpIGZvciBwYWNrZWQga3YnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcInZhbHVlXCIgYmUgbm9uZSB3aGVuIFwia2V5XCIgaGFzIHBhY2tlZCBrdiBmb3JtYXQuJyk7XG4gICAgICB9XG4gICAgICBxa3ZGb3JtYXQgPSBBdHRlbnRpb25Ra3ZGb3JtYXQucUt2QlNOSHhCU04ySDtcbiAgICAgIGt2U2VxdWVuY2VMZW5ndGggPSBrZXkuZGltc1sxXTtcbiAgICB9IGVsc2UgeyAgLy8ga2V5X2RpbXMuc2l6ZSgpID09IDQgKGNyb3NzLWF0dGVudGlvbiB3aXRoIHBhc3Rfa2V5KVxuICAgICAgaWYgKGtleS5kaW1zWzFdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8IGtleS5kaW1zWzNdICE9PSBoZWFkU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIGt2X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKSBmb3IgcGFzdF9rZXknKTtcbiAgICAgIH1cblxuICAgICAgcWt2Rm9ybWF0ID0gQXR0ZW50aW9uUWt2Rm9ybWF0LnVua25vd247XG4gICAgICBrdlNlcXVlbmNlTGVuZ3RoID0ga2V5LmRpbXNbMl07XG4gICAgfVxuICB9IGVsc2UgeyAgLy8gcGFja2VkIFFLVlxuICAgIGlmIChxdWVyeS5kaW1zLmxlbmd0aCAhPT0gMyAmJiBxdWVyeS5kaW1zLmxlbmd0aCAhPT0gNSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDUgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBlbXB0eScpO1xuICAgIH1cbiAgICBpZiAocXVlcnkuZGltcy5sZW5ndGggPT09IDUgJiYgKHF1ZXJ5LmRpbXNbMl0gIT09IGF0dHJpYnV0ZXMubnVtSGVhZHMgfHwgcXVlcnkuZGltc1szXSAhPT0gMykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwicXVlcnlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDMsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpO1xuICAgIH1cblxuICAgIHFrdkZvcm1hdCA9IEF0dGVudGlvblFrdkZvcm1hdC5xa3ZCU04zSDtcbiAgfVxuXG4gIGlmIChiaWFzKSB7XG4gICAgaWYgKGJpYXMuZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbicpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoID09PSA1ICYmIHF1ZXJ5LmRpbXNbM10gPT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiaWFzIGlzIG5vdCBhbGxvd2VkIGZvciBwYWNrZWQga3YuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IG1hc2tUeXBlOiBBdHRlbnRpb25NYXNrVHlwZSA9IEF0dGVudGlvbk1hc2tUeXBlLm5vbmU7XG4gIGlmIChrZXlQYWRkaW5nTWFzaykge1xuICAgIG1hc2tUeXBlID0gQXR0ZW50aW9uTWFza1R5cGUubWFza1Vua25vd247XG4gICAgY29uc3QgbWFza0RpbXMgPSBrZXlQYWRkaW5nTWFzay5kaW1zO1xuICAgIGlmIChtYXNrRGltcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChtYXNrRGltc1swXSA9PT0gYmF0Y2hTaXplKSB7XG4gICAgICAgIG1hc2tUeXBlID0gQXR0ZW50aW9uTWFza1R5cGUubWFzazFkS2V5U2VxTGVuO1xuICAgICAgfSBlbHNlIGlmIChtYXNrRGltc1swXSA9PT0gMyAqIGJhdGNoU2l6ZSArIDIpIHtcbiAgICAgICAgbWFza1R5cGUgPSBBdHRlbnRpb25NYXNrVHlwZS5tYXNrMURLZXlTZXFMZW5TdGFydDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1hc2tEaW1zLmxlbmd0aCA9PT0gMiAmJiBtYXNrRGltc1swXSA9PT0gYmF0Y2hTaXplICYmIG1hc2tEaW1zWzFdID09PSBrdlNlcXVlbmNlTGVuZ3RoKSB7XG4gICAgICBtYXNrVHlwZSA9IEF0dGVudGlvbk1hc2tUeXBlLm1hc2syZEtleVBhZGRpbmc7XG4gICAgfVxuICAgIGlmIChtYXNrVHlwZSA9PT0gQXR0ZW50aW9uTWFza1R5cGUubWFza1Vua25vd24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlfcGFkZGluZ19tYXNrXCIgc2hhcGUgc2hhbGwgYmUgKGJhdGNoX3NpemUpIG9yIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTWFzayBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cblxuICBsZXQgcGFzc1Bhc3RJbkt2ID0gZmFsc2U7XG4gIGxldCB2SGlkZGVuU2l6ZSA9IGhpZGRlblNpemU7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5kaW1zLmxlbmd0aCAhPT0gMyAmJiB2YWx1ZS5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDQgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGlmIChxdWVyeS5kaW1zWzBdICE9PSB2YWx1ZS5kaW1zWzBdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2hfc2l6ZSknKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUuZGltcy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGlmIChrdlNlcXVlbmNlTGVuZ3RoICE9PSB2YWx1ZS5kaW1zWzFdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDEgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTtcbiAgICAgIH1cbiAgICAgIHZIaWRkZW5TaXplID0gdmFsdWUuZGltc1syXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGt2U2VxdWVuY2VMZW5ndGggIT09IHZhbHVlLmRpbXNbMl0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgYW5kIFwicGFzdF92YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDIgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTtcbiAgICAgIH1cbiAgICAgIHZIaWRkZW5TaXplID0gdmFsdWUuZGltc1sxXSAqIHZhbHVlLmRpbXNbM107XG4gICAgICBwYXNzUGFzdEluS3YgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHRvdGFsU2VxdWVuY2VMZW5ndGggPSBwYXN0U2VxdWVuY2VMZW5ndGggKyBrdlNlcXVlbmNlTGVuZ3RoO1xuICBjb25zdCBicm9hZGNhc3RSZXNQb3NCaWFzID0gZmFsc2U7XG5cbiAgaWYgKGtleVBhZGRpbmdNYXNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdLZXkgcGFkZGluZyBtYXNrIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZVBvc2l0aW9uQmlhcykge1xuICAgIGlmIChyZWxhdGl2ZVBvc2l0aW9uQmlhcy5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInJlbGF0aXZlX3Bvc2l0aW9uX2JpYXNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO1xuICAgIH1cbiAgICBpZiAoKHJlbGF0aXZlUG9zaXRpb25CaWFzLmRpbXNbMF0gIT09IGJhdGNoU2l6ZSAmJiByZWxhdGl2ZVBvc2l0aW9uQmlhcy5kaW1zWzBdICE9PSAxKSB8fFxuICAgICAgICByZWxhdGl2ZVBvc2l0aW9uQmlhcy5kaW1zWzFdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8IHJlbGF0aXZlUG9zaXRpb25CaWFzLmRpbXNbMl0gIT09IHNlcXVlbmNlTGVuZ3RoIHx8XG4gICAgICAgIHJlbGF0aXZlUG9zaXRpb25CaWFzLmRpbXNbM10gIT09IHRvdGFsU2VxdWVuY2VMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJyZWxhdGl2ZV9wb3NpdGlvbl9iaWFzXCIgc2hhcGUgKGJhdGNoX3NpemUsIDEsIHNlcXVlbmNlX2xlbmd0aCwga3Zfc2VxdWVuY2VfbGVuZ3RoKScpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmF0Y2hTaXplLFxuICAgIHNlcXVlbmNlTGVuZ3RoLFxuICAgIHBhc3RTZXF1ZW5jZUxlbmd0aCxcbiAgICBrdlNlcXVlbmNlTGVuZ3RoLFxuICAgIHRvdGFsU2VxdWVuY2VMZW5ndGgsXG4gICAgbWF4U2VxdWVuY2VMZW5ndGgsXG4gICAgaW5wdXRIaWRkZW5TaXplOiAwLFxuICAgIGhpZGRlblNpemUsXG4gICAgdkhpZGRlblNpemUsXG4gICAgaGVhZFNpemUsXG4gICAgdkhlYWRTaXplOiBNYXRoLmZsb29yKHZIaWRkZW5TaXplIC8gYXR0cmlidXRlcy5udW1IZWFkcyksXG4gICAgbnVtSGVhZHM6IGF0dHJpYnV0ZXMubnVtSGVhZHMsXG4gICAgaXNVbmlkaXJlY3Rpb25hbDogZmFsc2UsXG4gICAgcGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjogZmFsc2UsXG4gICAgbWFza0ZpbHRlclZhbHVlOiBhdHRyaWJ1dGVzLm1hc2tGaWx0ZXJWYWx1ZSxcbiAgICBtYXNrVHlwZSxcbiAgICBzY2FsZTogYXR0cmlidXRlcy5zY2FsZSxcbiAgICBicm9hZGNhc3RSZXNQb3NCaWFzLFxuICAgIHBhc3NQYXN0SW5LdixcbiAgICBxa3ZGb3JtYXQsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VNdWx0aUhlYWRBdHRlbnRpb25BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IEF0dGVudGlvbkF0dHJzKTogQXR0ZW50aW9uQXR0cnMgPT5cbiAgICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoey4uLmF0dHJpYnV0ZXN9KTtcblxuY29uc3Qgd2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlOiBUcmFuc3Bvc2VBdHRyaWJ1dGVzID0gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtwZXJtOiBbMCwgMiwgMSwgM119KTtcblxuY29uc3QgYWRkQmlhc1RyYW5zcG9zZSA9XG4gICAgKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBxa3Y6IFRlbnNvclZpZXcsIGJpYXM6IFRlbnNvclZpZXcsIGJhdGNoU2l6ZTogbnVtYmVyLCBzZXF1ZW5jZUxlbmd0aDogbnVtYmVyLFxuICAgICBoaWRkZW5TaXplOiBudW1iZXIsIGJpYXNPZmZzZXQ6IG51bWJlcikgPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbYmF0Y2hTaXplLCBzZXF1ZW5jZUxlbmd0aCwgaGlkZGVuU2l6ZV07XG4gICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplfSwge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYmlhc09mZnNldH0sXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGhpZGRlblNpemV9XG4gICAgICBdO1xuXG4gICAgICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ3Frdl93aXRoX2JpYXMnLCBxa3YuZGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcbiAgICAgICAgY29uc3QgcWt2SW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdxa3YnLCBxa3YuZGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcbiAgICAgICAgY29uc3QgYmlhc0lucHV0ID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGJpYXMuZGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcblxuICAgICAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICAgICAge25hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInfSwge25hbWU6ICdiaWFzX29mZnNldCcsIHR5cGU6ICd1MzInfSwge25hbWU6ICdoaWRkZW5fc2l6ZScsIHR5cGU6ICd1MzInfVxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gYFxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKHFrdklucHV0LCBiaWFzSW5wdXQsIG91dHB1dCl9XG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG4gICAgbGV0IGJpYXNfb2Zmc2V0X2lkeCA9IChnbG9iYWxfaWR4ICUgdW5pZm9ybXMuaGlkZGVuX3NpemUpICsgdW5pZm9ybXMuYmlhc19vZmZzZXQ7XG5cbiAgICBxa3Zfd2l0aF9iaWFzW2dsb2JhbF9pZHhdID0gcWt2W2dsb2JhbF9pZHhdICsgYmlhc1tiaWFzX29mZnNldF9pZHhdO1xuICB9YDtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ011bHRpSGVhZEF0dGVudGlvbkFkZEJpYXMnLFxuICAgICAgICAgICAgc2hhZGVyQ2FjaGU6IHtpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJywgJ3R5cGUnXX0sXG4gICAgICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICAgICAgICBvdXRwdXRzOiBbe2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogcWt2LmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdH1dLFxuICAgICAgICAgICAgICBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgICAgICAgICBwcm9ncmFtVW5pZm9ybXNcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge2lucHV0czogW3FrdiwgYmlhc10sIG91dHB1dHM6IFstMV19KVswXTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgbWF5YmVUcmFuc3Bvc2VUb0JOU0hBbmRBZGRCaWFzID1cbiAgICAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGJhdGNoU2l6ZTogbnVtYmVyLCBudW1IZWFkczogbnVtYmVyLCBzZXF1ZW5jZUxlbmd0aDogbnVtYmVyLCBoZWFkU2l6ZTogbnVtYmVyLFxuICAgICBpbnB1dDogVGVuc29yVmlldywgYmlhcz86IFRlbnNvclZpZXcsIGJpYXNPZmZzZXQ/OiBudW1iZXIpID0+IHtcbiAgICAgIC8vIGNvbnN0IG5ld0RpbXMgPSBbXTtcblxuICAgICAgbGV0IHJlc2hhcGVkSW5wdXQgPSBpbnB1dDtcbiAgICAgIGlmICghYmlhcykge1xuICAgICAgICBpZiAoaW5wdXQuZGltcy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICByZXNoYXBlZElucHV0ID0gaW5wdXQucmVzaGFwZShbYmF0Y2hTaXplLCBzZXF1ZW5jZUxlbmd0aCwgbnVtSGVhZHMsIGhlYWRTaXplXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRleHQuY29tcHV0ZShcbiAgICAgICAgICAgIGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKHJlc2hhcGVkSW5wdXQsIHdlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZS5wZXJtKSxcbiAgICAgICAgICAgIHtpbnB1dHM6IFtyZXNoYXBlZElucHV0XSwgb3V0cHV0czogWy0xXX0pWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNlcXVlbmNlTGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBZGRCaWFzUmVzaGFwZSBpcyBub3QgaW1wbGVtZW50ZWQuIFBsZWFzZSBleHBvcnQgeW91ciBtb2RlbCB3aXRoIHBhY2tlZCBRS1Ygb3IgS1YnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNoYXBlZElucHV0ID1cbiAgICAgICAgICAgICAgYWRkQmlhc1RyYW5zcG9zZShjb250ZXh0LCBpbnB1dCwgYmlhcywgYmF0Y2hTaXplLCBzZXF1ZW5jZUxlbmd0aCwgbnVtSGVhZHMgKiBoZWFkU2l6ZSwgYmlhc09mZnNldCEpO1xuICAgICAgICAgIHJlc2hhcGVkSW5wdXQgPSByZXNoYXBlZElucHV0LnJlc2hhcGUoW2JhdGNoU2l6ZSwgc2VxdWVuY2VMZW5ndGgsIG51bUhlYWRzLCBoZWFkU2l6ZV0pO1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgICAgICAgIGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKHJlc2hhcGVkSW5wdXQsIHdlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZS5wZXJtKSxcbiAgICAgICAgICAgICAge2lucHV0czogW3Jlc2hhcGVkSW5wdXRdLCBvdXRwdXRzOiBbLTFdfSlbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG5leHBvcnQgY29uc3QgbXVsdGlIZWFkQXR0ZW50aW9uID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBBdHRlbnRpb25BdHRycyk6IHZvaWQgPT4ge1xuICBjb25zdCBwYXJhbXMgPSB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIGNvbnN0IHF1ZXJ5ID0gY29udGV4dC5pbnB1dHNbMF07XG4gIGNvbnN0IGtleSA9IGdldElucHV0KGNvbnRleHQuaW5wdXRzLCAxKTtcbiAgY29uc3QgdmFsdWUgPSBnZXRJbnB1dChjb250ZXh0LmlucHV0cywgMik7XG4gIGNvbnN0IGJpYXMgPSBnZXRJbnB1dChjb250ZXh0LmlucHV0cywgMyk7XG4gIGNvbnN0IGtleVBhZGRpbmdNYXNrID0gZ2V0SW5wdXQoY29udGV4dC5pbnB1dHMsIDQpO1xuICBjb25zdCByZWxhdGl2ZVBvc2l0aW9uQmlhcyA9IGdldElucHV0KGNvbnRleHQuaW5wdXRzLCA1KTtcbiAgY29uc3QgcGFzdEtleSA9IGdldElucHV0KGNvbnRleHQuaW5wdXRzLCA2KTtcbiAgY29uc3QgcGFzdFZhbHVlID0gZ2V0SW5wdXQoY29udGV4dC5pbnB1dHMsIDcpO1xuICBpZiAocXVlcnkuZGltcy5sZW5ndGggPT09IDUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhY2tlZCBRS1YgaXMgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICBpZiAoa2V5Py5kaW1zLmxlbmd0aCA9PT0gNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFja2VkIEtWIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgLy8gYXBwbHlBdHRlbnRpb24gZXhwZWN0cyBCTlNIIGlucHV0c1xuICBjb25zdCBrdkJOU0ggPSBrZXkgJiYgdmFsdWUgJiYga2V5LmRpbXMubGVuZ3RoID09PSA0ICYmIHZhbHVlLmRpbXMubGVuZ3RoID09PSA0O1xuXG4gIGNvbnN0IFEgPSBtYXliZVRyYW5zcG9zZVRvQk5TSEFuZEFkZEJpYXMoXG4gICAgICBjb250ZXh0LCBwYXJhbXMuYmF0Y2hTaXplLCBwYXJhbXMubnVtSGVhZHMsIHBhcmFtcy5zZXF1ZW5jZUxlbmd0aCwgcGFyYW1zLmhlYWRTaXplLCBxdWVyeSwgYmlhcywgMCk7XG5cbiAgaWYgKGt2Qk5TSCkge1xuICAgIHJldHVybiBhcHBseUF0dGVudGlvbihcbiAgICAgICAgY29udGV4dCwgUSwga2V5LCB2YWx1ZSwga2V5UGFkZGluZ01hc2ssIHVuZGVmaW5lZCwgcGFzdEtleSwgcGFzdFZhbHVlLCByZWxhdGl2ZVBvc2l0aW9uQmlhcywgcGFyYW1zLFxuICAgICAgICBhdHRyaWJ1dGVzKTtcbiAgfVxuICBpZiAoIWtleSB8fCAhdmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2tleSBhbmQgdmFsdWUgbXVzdCBiZSBwcm92aWRlZCcpO1xuICB9XG4gIGNvbnN0IEsgPSBtYXliZVRyYW5zcG9zZVRvQk5TSEFuZEFkZEJpYXMoXG4gICAgICBjb250ZXh0LCBwYXJhbXMuYmF0Y2hTaXplLCBwYXJhbXMubnVtSGVhZHMsIHBhcmFtcy5rdlNlcXVlbmNlTGVuZ3RoLCBwYXJhbXMuaGVhZFNpemUsIGtleSwgYmlhcyxcbiAgICAgIHBhcmFtcy5oaWRkZW5TaXplKTtcblxuICBjb25zdCBWID0gbWF5YmVUcmFuc3Bvc2VUb0JOU0hBbmRBZGRCaWFzKFxuICAgICAgY29udGV4dCwgcGFyYW1zLmJhdGNoU2l6ZSwgcGFyYW1zLm51bUhlYWRzLCBwYXJhbXMua3ZTZXF1ZW5jZUxlbmd0aCwgcGFyYW1zLnZIZWFkU2l6ZSwgdmFsdWUsIGJpYXMsXG4gICAgICAyICogcGFyYW1zLmhpZGRlblNpemUpO1xuXG4gIGFwcGx5QXR0ZW50aW9uKFxuICAgICAgY29udGV4dCwgUSwgSywgViwga2V5UGFkZGluZ01hc2ssIHVuZGVmaW5lZCwgcGFzdEtleSwgcGFzdFZhbHVlLCByZWxhdGl2ZVBvc2l0aW9uQmlhcywgcGFyYW1zLCBhdHRyaWJ1dGVzKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm99IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlcn0gZnJvbSAnLi9jb21tb24nO1xuXG5jb25zdCBnZXRSZXBlYXRzID0gKHJlcGVhdHNUZW5zb3JWaWV3OiBUZW5zb3JWaWV3KTogcmVhZG9ubHkgbnVtYmVyW10gPT5cbiAgICBBcnJheS5mcm9tKHJlcGVhdHNUZW5zb3JWaWV3LmdldEJpZ0ludDY0QXJyYXkoKSwgTnVtYmVyKTtcblxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaWxlIHJlcXVpcmVzIDIgaW5wdXRzLicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuZmxvYXQgJiYgaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5mbG9hdDE2ICYmXG4gICAgICBpbnB1dHNbMF0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmludDMyICYmIGlucHV0c1swXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUudWludDMyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaWxlIG9ubHkgc3VwcG9ydCBmbG9hdCwgZmxvYXQxNiwgaW50MzIsIGFuZCB1aW50MzIgZGF0YSB0eXBlcycpO1xuICB9XG5cbiAgaWYgKGlucHV0c1sxXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuaW50NjQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBiZSBvZiBpbnQ2NCBkYXRhIHR5cGUnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBiZSAxLUQnKTtcbiAgfVxuXG4gIGNvbnN0IHJlcGVhdHM6IHJlYWRvbmx5IG51bWJlcltdID0gZ2V0UmVwZWF0cyhpbnB1dHNbMV0pO1xuXG4gIGlmIChyZXBlYXRzLmxlbmd0aCAhPT0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgaGF2ZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cyBhcyByYW5rIG9mIGlucHV0IGRhdGEgdGVuc29yJyk7XG4gIH1cbn07XG5cbmNvbnN0IGdldE91dHB1dFNoYXBlID0gKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCByZXBlYXRzOiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdID0+IHtcbiAgY29uc3Qgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgb3V0cHV0U2hhcGUucHVzaChpbnB1dFNoYXBlW2ldICogcmVwZWF0c1tpXSk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0U2hhcGU7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlVGlsZVByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBzaGFwZT86IG51bWJlcltdKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IHJlcGVhdHM6IHJlYWRvbmx5IG51bWJlcltdID0gc2hhcGUgPT0gbnVsbCA/IGdldFJlcGVhdHMoaW5wdXRzWzFdKSA6IHNoYXBlO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGdldE91dHB1dFNoYXBlKGlucHV0U2hhcGUsIHJlcGVhdHMpO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuXG4gIGNvbnN0IGRhdGFUeXBlID0gaW5wdXRzWzBdLmRhdGFUeXBlO1xuICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgZGF0YVR5cGUsIGlucHV0U2hhcGUubGVuZ3RoKTtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9ICR7aW5wdXQuaW5kaWNlcyguLi5pbnB1dFNoYXBlKX07XG4gICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dF9zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG4gICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG4gICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke2lucHV0U2hhcGUubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIGxldCBpbnB1dF9kaW1faSA9ICR7aW5wdXQuaW5kaWNlc0dldCgndW5pZm9ybXMuaW5wdXRfc2hhcGUnLCAnaScpfTtcbiAgICAgICAgbGV0IGlucHV0X2RpbV92YWx1ZSA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgJ2knKX0gICUgaW5wdXRfZGltX2k7XG5cbiAgICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgJ2knLCAnaW5wdXRfZGltX3ZhbHVlJyl9XG4gICAgICB9XG4gICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsIGlucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpKX1cbiAgICB9YDtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdUaWxlJyxcbiAgICBzaGFkZXJDYWNoZToge2hpbnQ6IGAke3JlcGVhdHN9YCwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtczpcbiAgICAgICAgICBbe3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZX0sIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1swXS5kaW1zLCBvdXRwdXRTaGFwZSldLFxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCB0aWxlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVRpbGVQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cyksIHtpbnB1dHM6IFswXX0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge2NyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm19IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHthcHBseUF0dGVudGlvbiwgQXR0ZW50aW9uQXR0cnMsIEF0dGVudGlvbk1hc2tUeXBlLCBBdHRlbnRpb25QYXJhbWV0ZXJzLCBBdHRlbnRpb25Ra3ZGb3JtYXR9IGZyb20gJy4vYXR0ZW50aW9uJztcbmltcG9ydCB7Y3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIFVuaWZvcm1zQXJyYXlUeXBlfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQge21heWJlVHJhbnNwb3NlVG9CTlNIQW5kQWRkQmlhc30gZnJvbSAnLi9tdWx0aWhlYWQtYXR0ZW50aW9uJztcbmltcG9ydCB7Y3JlYXRlVGlsZVByb2dyYW1JbmZvfSBmcm9tICcuL3RpbGUnO1xuaW1wb3J0IHtjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbywgVHJhbnNwb3NlQXR0cmlidXRlc30gZnJvbSAnLi90cmFuc3Bvc2UnO1xuXG5leHBvcnQgY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IEF0dGVudGlvbkF0dHJzKTogQXR0ZW50aW9uUGFyYW1ldGVycyA9PiB7XG4gIGNvbnN0IHF1ZXJ5ID0gaW5wdXRzWzBdO1xuICBjb25zdCBrZXkgPSBpbnB1dHNbMV07XG4gIGNvbnN0IHZhbHVlID0gaW5wdXRzWzJdO1xuICBjb25zdCBwYXN0S2V5ID0gaW5wdXRzWzNdO1xuICBjb25zdCBwYXN0VmFsdWUgPSBpbnB1dHNbNF07XG5cbiAgLy8gQWJicmV2aWF0aW9uIGFuZCBNZWFuaW5nczpcbiAgLy8gICBCOiAgICBiYXRjaF9zaXplXG4gIC8vICAgUzogICAgc2VxdWVuY2VfbGVuZ3RoIChpbnB1dCBzZXF1ZW5jZSBsZW5ndGggb2YgcXVlcnkpXG4gIC8vICAgUDogICAgcGFzdF9zZXF1ZW5jZV9sZW5ndGggKHBhc3Qgc2VxdWVuY2UgbGVuZ3RoIG9mIGtleSBvciB2YWx1ZSlcbiAgLy8gICBMOiAgICBrdl9zZXF1ZW5jZV9sZW5ndGggKGlucHV0IHNlcXVlbmNlIGxlbmd0aCBvZiBrZXkgb3IgdmFsdWUpXG4gIC8vICAgTTogICAgbWF4X3NlcXVlbmNlX2xlbmd0aFxuICAvLyAgIFQ6ICAgIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoICsga3Zfc2VxdWVuY2VfbGVuZ3RoXG4gIC8vICAgTjogICAgbnVtX2hlYWRzXG4gIC8vICAgSDogICAgaGVhZCBzaXplIGZvciBRIGFuZCBLLCBha2EgcV9oZWFkX3NpemUgb3Iga19oZWFkX3NpemUgb3IgcWtfaGVhZF9zaXplXG4gIC8vICAgSF92OiAgdl9oZWFkX3NpemVcbiAgLy8gICBEX2k6ICBpbnB1dCBoaWRkZW4gc2l6ZVxuICAvLyAgIEQ6ICAgIGhpZGRlbiBzaXplIGZvciBRIGFuZCBLIChEID0gTiAqIEgpLCBha2EgcV9oaWRkZW5fc2l6ZSBvciBrX2hpZGRlbl9zaXplIG9yIHFrX2hpZGRlbl9zaXplXG4gIC8vICAgRF92OiAgdl9oaWRkZW5fc2l6ZSA9IG51bV9oZWFkcyAqIHZfaGVhZF9zaXplXG5cbiAgLy8gICAgIHBhc3Rfa2V5ICAgICAgICAgICAgICAgICAgIDogKEIsIE4sIFMqLCBIKVxuICAvLyAgICAgcGFzdF92YWx1ZSAgICAgICAgICAgICAgICAgOiAoQiwgTiwgUyosIEgpXG4gIC8vIFdoZW4gbm8gcGFja2luZyBmb3IgcS9rL3Y6XG4gIC8vICAgICBxdWVyeSAgICAgICAgICAgIChRKSAgICAgICA6IChCLCBTLCBEKVxuICAvLyAgICAga2V5ICAgICAgICAgICAgICAoSykgICAgICAgOiAoQiwgTCwgRCkgb3IgKEIsIE4sIFMqLCBIKVxuICAvLyAgICAgdmFsdWUgICAgICAgICAgICAoVikgICAgICAgOiAoQiwgTCwgRF92KSBvciAoQiwgTiwgUyosIEgpXG4gIC8vIFdoZW4gcGFja2VkIGt2IGlzIHVzZWQ6XG4gIC8vICAgICBxdWVyeSAgICAgICAgICAgIChRKSAgICAgICA6IChCLCBTLCBEKVxuICAvLyAgICAga2V5ICAgICAgICAgICAgICAoSykgICAgICAgOiAoQiwgTCwgTiwgMiwgSClcbiAgLy8gICAgIHZhbHVlICAgICAgICAgICAgKFYpICAgICAgIDogTm9uZVxuICAvLyBXaGVuIHBhY2tlZCBxa3YgaXMgdXNlZDpcbiAgLy8gICAgIHF1ZXJ5ICAgICAgICAgICAgKFEpICAgICAgIDogKEIsIEwsIE4sIDMsIEgpIG9yIChCLCBTLCAzKkQpXG4gIC8vICAgICBrZXkgICAgICAgICAgICAgIChLKSAgICAgICA6IE5vbmVcbiAgLy8gICAgIHZhbHVlICAgICAgICAgICAgKFYpICAgICAgIDogTm9uZVxuXG4gIGlmIChxdWVyeS5kaW1zLmxlbmd0aCAhPT0gMyAmJiBxdWVyeS5kaW1zLmxlbmd0aCAhPT0gNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgcXVlcnkgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDUgZGltZW5zaW9ucycpO1xuICB9XG5cbiAgY29uc3QgZG1taGFQYWNraW5nID0gZmFsc2U7XG4gIGNvbnN0IGJhdGNoU2l6ZSA9IHF1ZXJ5LmRpbXNbMF07XG4gIGNvbnN0IHNlcXVlbmNlTGVuZ3RoID0gcXVlcnkuZGltc1sxXTtcbiAgY29uc3QgaGlkZGVuU2l6ZSA9IHF1ZXJ5LmRpbXMubGVuZ3RoID09PSAzID8gKGRtbWhhUGFja2luZyA/IHF1ZXJ5LmRpbXNbMl0gLyAzIDogcXVlcnkuZGltc1syXSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLm51bUhlYWRzICogcXVlcnkuZGltc1s0XTtcbiAgbGV0IGt2U2VxdWVuY2VMZW5ndGggPSBzZXF1ZW5jZUxlbmd0aDtcblxuICBsZXQgcGFzdFNlcXVlbmNlTGVuZ3RoID0gMDtcbiAgbGV0IG1heFNlcXVlbmNlTGVuZ3RoID0gMDtcbiAgY29uc3QgaGVhZFNpemUgPSBNYXRoLmZsb29yKGhpZGRlblNpemUgLyBhdHRyaWJ1dGVzLm51bUhlYWRzKTtcbiAgY29uc3QgaGFzUGFzdEtleSA9IHBhc3RLZXkgJiYgcGFzdEtleS5kaW1zLmxlbmd0aCAhPT0gMDtcbiAgY29uc3QgaGFzUGFzdFZhbHVlID0gcGFzdFZhbHVlICYmIHBhc3RWYWx1ZS5kaW1zLmxlbmd0aCAhPT0gMDtcbiAgLy8gVE9ETyA6IHRoaXMgc2hvdWxkIGJlIGZyb20gYXR0cmlidXRlcy5cbiAgY29uc3QgaXNQYXN0a3ZCU05IID0gdHJ1ZTtcbiAgaWYgKGhhc1Bhc3RLZXkgJiYgaGFzUGFzdFZhbHVlKSB7XG4gICAgaWYgKHBhc3RLZXkuZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7XG4gICAgfVxuICAgIGlmIChwYXN0VmFsdWUuZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X3ZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtcbiAgICB9XG4gICAgaWYgKGlzUGFzdGt2QlNOSCkge1xuICAgICAgLy8gRm9yIEJTTkhcbiAgICAgIHBhc3RTZXF1ZW5jZUxlbmd0aCA9IHBhc3RLZXkuZGltc1sxXTtcbiAgICAgIG1heFNlcXVlbmNlTGVuZ3RoID0gcGFzdEtleS5kaW1zWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgQk5TSFxuICAgICAgcGFzdFNlcXVlbmNlTGVuZ3RoID0gcGFzdEtleS5kaW1zWzJdO1xuICAgICAgbWF4U2VxdWVuY2VMZW5ndGggPSBwYXN0S2V5LmRpbXNbMl07XG4gICAgfVxuICB9IGVsc2UgaWYgKGhhc1Bhc3RLZXkgfHwgaGFzUGFzdFZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgYW5kIFwicGFzdF92YWx1ZVwiIHNoYWxsIGJlIGJvdGggcHJlc2VudCBvciBib3RoIGFic2VudCcpO1xuICB9XG5cbiAgbGV0IHFrdkZvcm1hdDogQXR0ZW50aW9uUWt2Rm9ybWF0O1xuICBpZiAoa2V5KSB7XG4gICAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBnaXZlbicpO1xuICAgIH1cbiAgICBpZiAoa2V5LmRpbXMubGVuZ3RoIDwgMyB8fCBrZXkuZGltcy5sZW5ndGggPiA1KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzLCA0LCBvciA1IGRpbWVuc2lvbnMnKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmRpbXNbMF0gIT09IGtleS5kaW1zWzBdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJrZXlcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoIHNpemUpJyk7XG4gICAgfVxuXG4gICAgaWYgKGtleS5kaW1zLmxlbmd0aCA9PT0gMykge1xuICAgICAgaWYgKHF1ZXJ5LmRpbXNbMl0gJSBrZXkuZGltc1syXSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpbWVuc2lvbiAyIG9mIFwicXVlcnlcIiBzaG91bGQgYmUgYSBtdWx0aXBsZSBvZiBcImtleVwiJyk7XG4gICAgICB9XG4gICAgICBxa3ZGb3JtYXQgPSBBdHRlbnRpb25Ra3ZGb3JtYXQucWt2QlNOSDtcbiAgICAgIGt2U2VxdWVuY2VMZW5ndGggPSBrZXkuZGltc1sxXTtcbiAgICB9IGVsc2UgaWYgKGtleS5kaW1zLmxlbmd0aCA9PT0gNSkge1xuICAgICAgaWYgKGtleS5kaW1zWzJdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8IGtleS5kaW1zWzNdICE9PSAyIHx8IGtleS5kaW1zWzRdICE9PSBoZWFkU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMiwgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJ2YWx1ZVwiIGJlIG5vbmUgd2hlbiBcImtleVwiIGhhcyBwYWNrZWQga3YgZm9ybWF0LicpO1xuICAgICAgfVxuICAgICAgcWt2Rm9ybWF0ID0gQXR0ZW50aW9uUWt2Rm9ybWF0LnFLdkJTTkh4QlNOMkg7XG4gICAgICBrdlNlcXVlbmNlTGVuZ3RoID0ga2V5LmRpbXNbMV07XG4gICAgfSBlbHNlIHsgIC8vIGtleV9kaW1zLnNpemUoKSA9PSA0IChjcm9zcy1hdHRlbnRpb24gd2l0aCBwYXN0X2tleSlcbiAgICAgIGlmIChrZXkuZGltc1sxXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fCBrZXkuZGltc1szXSAhPT0gaGVhZFNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJrZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIGhlYWRfc2l6ZSkgZm9yIHBhc3Rfa2V5Jyk7XG4gICAgICB9XG5cbiAgICAgIHFrdkZvcm1hdCA9IEF0dGVudGlvblFrdkZvcm1hdC51bmtub3duO1xuICAgICAga3ZTZXF1ZW5jZUxlbmd0aCA9IGtleS5kaW1zWzJdO1xuICAgIH1cbiAgfSBlbHNlIHsgIC8vIHBhY2tlZCBRS1ZcbiAgICBpZiAocXVlcnkuZGltcy5sZW5ndGggIT09IDMgJiYgcXVlcnkuZGltcy5sZW5ndGggIT09IDUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA1IGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZW1wdHknKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoID09PSA1ICYmIChxdWVyeS5kaW1zWzJdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8IHF1ZXJ5LmRpbXNbM10gIT09IDMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcInF1ZXJ5XCIgc2hhcGUgKGJhdGNoX3NpemUsIGt2X3NlcXVlbmNlX2xlbmd0aCwgbnVtX2hlYWRzLCAzLCBoZWFkX3NpemUpIGZvciBwYWNrZWQga3YnKTtcbiAgICB9XG5cbiAgICBxa3ZGb3JtYXQgPSBBdHRlbnRpb25Ra3ZGb3JtYXQucWt2QlNOM0g7XG4gIH1cblxuICBjb25zdCBtYXNrVHlwZTogQXR0ZW50aW9uTWFza1R5cGUgPSBBdHRlbnRpb25NYXNrVHlwZS5ub25lO1xuICBsZXQgcGFzc1Bhc3RJbkt2ID0gZmFsc2U7XG4gIGxldCB2SGlkZGVuU2l6ZSA9IGhpZGRlblNpemU7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5kaW1zLmxlbmd0aCAhPT0gMyAmJiB2YWx1ZS5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDQgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGlmIChxdWVyeS5kaW1zWzBdICE9PSB2YWx1ZS5kaW1zWzBdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2hfc2l6ZSknKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUuZGltcy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGlmIChrdlNlcXVlbmNlTGVuZ3RoICE9PSB2YWx1ZS5kaW1zWzFdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDEgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTtcbiAgICAgIH1cbiAgICAgIHZIaWRkZW5TaXplID0gdmFsdWUuZGltc1syXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGt2U2VxdWVuY2VMZW5ndGggIT09IHZhbHVlLmRpbXNbMl0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgYW5kIFwicGFzdF92YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDIgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTtcbiAgICAgIH1cbiAgICAgIHZIaWRkZW5TaXplID0gdmFsdWUuZGltc1sxXSAqIHZhbHVlLmRpbXNbM107XG4gICAgICBwYXNzUGFzdEluS3YgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBjb25zdCB0b3RhbFNlcXVlbmNlTGVuZ3RoID0gcGFzdFNlcXVlbmNlTGVuZ3RoICsga3ZTZXF1ZW5jZUxlbmd0aDtcbiAgY29uc3QgYnJvYWRjYXN0UmVzUG9zQmlhcyA9IGZhbHNlO1xuXG4gIHJldHVybiB7XG4gICAgYmF0Y2hTaXplLFxuICAgIHNlcXVlbmNlTGVuZ3RoLFxuICAgIHBhc3RTZXF1ZW5jZUxlbmd0aCxcbiAgICBrdlNlcXVlbmNlTGVuZ3RoLFxuICAgIHRvdGFsU2VxdWVuY2VMZW5ndGgsXG4gICAgbWF4U2VxdWVuY2VMZW5ndGgsXG4gICAgaW5wdXRIaWRkZW5TaXplOiAwLFxuICAgIGhpZGRlblNpemUsXG4gICAgdkhpZGRlblNpemUsXG4gICAgaGVhZFNpemUsXG4gICAgdkhlYWRTaXplOiBNYXRoLmZsb29yKHZIaWRkZW5TaXplIC8gYXR0cmlidXRlcy5rdk51bUhlYWRzISksXG4gICAgbnVtSGVhZHM6IGF0dHJpYnV0ZXMubnVtSGVhZHMsXG4gICAga3ZOdW1IZWFkczogYXR0cmlidXRlcy5rdk51bUhlYWRzLFxuICAgIG5SZXBzOiBhdHRyaWJ1dGVzLm51bUhlYWRzIC8gYXR0cmlidXRlcy5rdk51bUhlYWRzISxcbiAgICBwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiBmYWxzZSxcbiAgICBtYXNrVHlwZSxcbiAgICBzY2FsZTogYXR0cmlidXRlcy5zY2FsZSxcbiAgICBicm9hZGNhc3RSZXNQb3NCaWFzLFxuICAgIHBhc3NQYXN0SW5LdixcbiAgICBxa3ZGb3JtYXQsXG4gICAgaXNQYXN0a3ZCU05ILFxuICB9O1xufTtcblxuY29uc3QgY3JlYXRlQ29uY2F0UHJvZ3JhbUluZm8gPVxuICAgIChhOiBUZW5zb3JWaWV3LCBiOiBUZW5zb3JWaWV3fHVuZGVmaW5lZCwgZGF0YVR5cGU6IERhdGFUeXBlLCBwYXJhbXM6IEF0dGVudGlvblBhcmFtZXRlcnMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IFtwYXJhbXMuYmF0Y2hTaXplLCBwYXJhbXMudG90YWxTZXF1ZW5jZUxlbmd0aCwgcGFyYW1zLmt2TnVtSGVhZHMhLCBwYXJhbXMuaGVhZFNpemVdO1xuICAgICAgY29uc3QgY29tcG9uZW50ID0gNDtcbiAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyBjb21wb25lbnQ7XG4gICAgICBjb25zdCBwcmVzZW50U2VxdWVuY2VMZW5ndGggPSBwYXJhbXMudG90YWxTZXF1ZW5jZUxlbmd0aDtcbiAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdwcmVzZW50X2t2JywgZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50KTtcbiAgICAgIGNvbnN0IGlucHV0QSA9IGlucHV0VmFyaWFibGUoJ25ld19rdicsIGEuZGF0YVR5cGUsIGEuZGltcy5sZW5ndGgsIGNvbXBvbmVudCk7XG4gICAgICBjb25zdCBpbnB1dEIgPSBiID8gaW5wdXRWYXJpYWJsZSgncGFzdF9rdicsIGIuZGF0YVR5cGUsIGIuZGltcy5sZW5ndGgsIGNvbXBvbmVudCkgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGNvbnN0IEggPSBNYXRoLmNlaWwocGFyYW1zLmhlYWRTaXplIC8gY29tcG9uZW50KTtcbiAgICAgIGNvbnN0IGRpc3BhdGNoID0ge3g6IHByZXNlbnRTZXF1ZW5jZUxlbmd0aCwgeTogYS5kaW1zWzBdLCB6OiAxfTtcblxuICAgICAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBiID8gWydyYW5rJywgJ3JhbmsnXSA6IFsncmFuayddO1xuXG4gICAgICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemV9LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbXMucGFzdFNlcXVlbmNlTGVuZ3RofSxcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1zLmt2U2VxdWVuY2VMZW5ndGh9LFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbXMudG90YWxTZXF1ZW5jZUxlbmd0aH1cbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IGlucHV0cyA9IFtpbnB1dEFdO1xuICAgICAgaWYgKGlucHV0Qikge1xuICAgICAgICBwcm9ncmFtVW5pZm9ybXMucHVzaChcbiAgICAgICAgICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGEuZGltcyksIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGIhLmRpbXMpLFxuICAgICAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpKTtcbiAgICAgICAgaW5wdXRzLnB1c2goaW5wdXRCKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGEuZGltcyksIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSk7XG4gICAgICB9XG4gICAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICAgIHtuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAncGFzdF9zZXFsZW4nLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnbmV3X3NlcWxlbicsIHR5cGU6ICd1MzInfSxcbiAgICAgICAge25hbWU6ICdwcmVzZW50X3NlcWxlbicsIHR5cGU6ICd1MzInfVxuICAgICAgXTtcblxuICAgICAgY29uc3QgcGFzdFN0ciA9IGAgICAgICBsZXQgcGFzdF9iYXRjaF9zdHJpZGUgPSB1bmlmb3Jtcy5wYXN0X3NlcWxlbiAqIG51bV9oZWFkcyAqIEg7XG4gICAgICAgIHZhciBwYXN0X2hlYWRfc3RyaWRlID0gdW5pZm9ybXMucGFzdF9zZXFsZW4gKiBIO1xuICAgICAgICBpZiAoaXNfYnNuaCkge1xuICAgICAgICAgIHBhc3RfaGVhZF9zdHJpZGUgPSBIO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbl9vZmZzZXQgPSBiICogcGFzdF9iYXRjaF9zdHJpZGUgKyBzICogcm93X3N0cmlkZSArIG4gKiBwYXN0X2hlYWRfc3RyaWRlICsgaDtcbiAgICAgICAgcHJlc2VudF9rdltvdXRfb2Zmc2V0XSA9IHBhc3Rfa3ZbaW5fb2Zmc2V0XTtgO1xuICAgICAgY29uc3QgbmV3U3RyID0gYCAgICAgIGxldCBuZXdfYmF0Y2hfc3RyaWRlID0gdW5pZm9ybXMubmV3X3NlcWxlbiAqIG51bV9oZWFkcyAqIEg7XG4gICAgICAgIGxldCBuZXdfcm93X3N0cmlkZSA9IG51bV9oZWFkcyAqIEg7XG4gICAgICAgIGxldCBuZXdfaGVhZF9zdHJpZGUgPSBIO1xuICAgICAgICBsZXQgaW5fb2Zmc2V0ID0gYiAqIG5ld19iYXRjaF9zdHJpZGUgKyAocyAtIHBhc3Rfc2VxbGVuKSAqIG5ld19yb3dfc3RyaWRlICsgbiAqIG5ld19oZWFkX3N0cmlkZSArIGg7XG4gICAgICAgIHByZXNlbnRfa3Zbb3V0X29mZnNldF0gPSBuZXdfa3ZbaW5fb2Zmc2V0XTtgO1xuICAgICAgY29uc3QgY29uY2F0U3RyID0gYiA/IGBpZiAocyA8IHBhc3Rfc2VxbGVuKSB7XG4gICAgICAgICR7cGFzdFN0cn1cbiAgICAgICAgfSBlbHNlIGlmIChzIDwgcGFzdF9zZXFsZW4gKyB1bmlmb3Jtcy5uZXdfc2VxbGVuKSB7XG4gICAgICAgICR7bmV3U3RyfVxuICAgICAgICB9YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYGlmIChzIDwgcGFzdF9zZXFsZW4gKyB1bmlmb3Jtcy5uZXdfc2VxbGVuKSB7XG4gICAgICAgICAgJHtuZXdTdHJ9XG4gICAgICAgIH1gO1xuXG4gICAgICAvLyBUT0RPOiBoYW5kbGUgSCAqIHBhcmFtcy5rdk51bUhlYWRzIGdyZWF0ZXIgdGhhbiBtYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXAgbGltaXQuXG4gICAgICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcblxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0cywgb3V0cHV0KX1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFtcbiAgICAgICAgSCwgcGFyYW1zLmt2TnVtSGVhZHMhLCAxXG4gICAgICBdKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICAgIHZhciBpbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgIGxldCBoID0gbG9jYWxfaWQueDtcbiAgICBsZXQgbiA9IGxvY2FsX2lkLnk7XG4gICAgbGV0IHMgPSB3b3JrZ3JvdXBfaWQueDtcbiAgICBsZXQgYiA9IHdvcmtncm91cF9pZC55O1xuICAgIGxldCBudW1faGVhZHMgPSAke3BhcmFtcy5rdk51bUhlYWRzIX11O1xuICAgIGxldCBIID0gJHtIfXU7XG5cbiAgICBsZXQgcHJlc2VudF9zZXFsZW4gPSB1bmlmb3Jtcy5wcmVzZW50X3NlcWxlbjtcbiAgICBsZXQgcHJlc2VudF9iYXRjaF9zdHJpZGUgPSBwcmVzZW50X3NlcWxlbiAqIG51bV9oZWFkcyAqIEg7XG4gICAgdmFyIHJvd19zdHJpZGUgPSBIO1xuICAgIGxldCBpc19ic25oID0gJHtwYXJhbXMuaXNQYXN0a3ZCU05IfTtcblxuICAgIGlmIChpc19ic25oKSB7XG4gICAgICByb3dfc3RyaWRlID0gbnVtX2hlYWRzICogSDtcbiAgICB9XG4gICAgdmFyIHByZXNlbnRfaGVhZF9zdHJpZGUgPSBwcmVzZW50X3NlcWxlbiAqIEg7XG4gICAgaWYgKGlzX2JzbmgpIHtcbiAgICAgIHByZXNlbnRfaGVhZF9zdHJpZGUgPSBIO1xuICAgIH1cblxuICAgIGxldCBwYXN0X3NlcWxlbiA9IHVuaWZvcm1zLnBhc3Rfc2VxbGVuO1xuXG4gICAgbGV0IG91dF9vZmZzZXQgPSBiICogcHJlc2VudF9iYXRjaF9zdHJpZGUgKyBzICogcm93X3N0cmlkZSArIG4gKiBwcmVzZW50X2hlYWRfc3RyaWRlICsgaDtcbiAgICAke2NvbmNhdFN0cn1cbiAgfWA7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6ICdDb25jYXRQYXN0TmV3JyxcbiAgICAgICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBgJHtwYXJhbXMua3ZOdW1IZWFkcyF9JHtIfSR7ISFifWAsIGlucHV0RGVwZW5kZW5jaWVzfSxcbiAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgICBvdXRwdXRzOiBbe2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZX1dLFxuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IGRpc3BhdGNoLFxuICAgICAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICAgICAgfSksXG4gICAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICAgIH07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlR3JvdXBRdWVyeUF0dGVudGlvbkF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogQXR0ZW50aW9uQXR0cnMpOiBBdHRlbnRpb25BdHRycyA9PlxuICAgIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7Li4uYXR0cmlidXRlc30pO1xuXG5jb25zdCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGU6IFRyYW5zcG9zZUF0dHJpYnV0ZXMgPSBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe3Blcm06IFswLCAyLCAxLCAzXX0pO1xuXG5jb25zdCBtYXliZUV4cGFuZEFuZFRyYW5zcG9zZVRvQk5TSCA9XG4gICAgKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBpbnB1dDogVGVuc29yVmlldywgcGFzdEtWOiBUZW5zb3JWaWV3fHVuZGVmaW5lZCwgcGFyYW1zOiBBdHRlbnRpb25QYXJhbWV0ZXJzLFxuICAgICBvdXRwdXRJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICBsZXQgcmVzaGFwZWRJbnB1dCA9IGlucHV0O1xuICAgICAgY29uc3QgbnVtSGVhZHMgPSBwYXJhbXMua3ZOdW1IZWFkcyE7XG4gICAgICBjb25zdCBuUmVwcyA9IHBhcmFtcy5uUmVwcyE7XG4gICAgICBpZiAoaW5wdXQuZGltcy5sZW5ndGggPT09IDMgJiYgcGFyYW1zLmt2U2VxdWVuY2VMZW5ndGggIT09IDApIHtcbiAgICAgICAgcmVzaGFwZWRJbnB1dCA9IGlucHV0LnJlc2hhcGUoW3BhcmFtcy5iYXRjaFNpemUsIHBhcmFtcy5rdlNlcXVlbmNlTGVuZ3RoLCBudW1IZWFkcywgcGFyYW1zLmhlYWRTaXplXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXN0S1YpIHtcbiAgICAgICAgcmVzaGFwZWRJbnB1dCA9IGNvbnRleHQuY29tcHV0ZShcbiAgICAgICAgICAgIGNyZWF0ZUNvbmNhdFByb2dyYW1JbmZvKHJlc2hhcGVkSW5wdXQsIHBhc3RLViwgcmVzaGFwZWRJbnB1dC5kYXRhVHlwZSwgcGFyYW1zKSxcbiAgICAgICAgICAgIHtpbnB1dHM6IFtyZXNoYXBlZElucHV0LCBwYXN0S1ZdLCBvdXRwdXRzOiBbcGFyYW1zLmlzUGFzdGt2QlNOSCA/IG91dHB1dEluZGV4IDogLTFdfSlbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNoYXBlZElucHV0ID0gY29udGV4dC5jb21wdXRlKFxuICAgICAgICAgICAgY3JlYXRlQ29uY2F0UHJvZ3JhbUluZm8ocmVzaGFwZWRJbnB1dCwgdW5kZWZpbmVkLCByZXNoYXBlZElucHV0LmRhdGFUeXBlLCBwYXJhbXMpLFxuICAgICAgICAgICAge2lucHV0czogW3Jlc2hhcGVkSW5wdXRdLCBvdXRwdXRzOiBbcGFyYW1zLmlzUGFzdGt2QlNOSCA/IG91dHB1dEluZGV4IDogLTFdfSlbMF07XG4gICAgICB9XG4gICAgICBpZiAoblJlcHMgIT09IDEpIHtcbiAgICAgICAgcmVzaGFwZWRJbnB1dCA9IGNvbnRleHQuY29tcHV0ZShcbiAgICAgICAgICAgIGNyZWF0ZVRpbGVQcm9ncmFtSW5mbyhbcmVzaGFwZWRJbnB1dF0sIFsxLCAxLCAxLCBuUmVwc10pLCB7aW5wdXRzOiBbcmVzaGFwZWRJbnB1dF0sIG91dHB1dHM6IFstMV19KVswXTtcbiAgICAgICAgcmVzaGFwZWRJbnB1dCA9XG4gICAgICAgICAgICByZXNoYXBlZElucHV0LnJlc2hhcGUoW3BhcmFtcy5iYXRjaFNpemUsIHBhcmFtcy50b3RhbFNlcXVlbmNlTGVuZ3RoLCBudW1IZWFkcyAqIG5SZXBzLCBwYXJhbXMuaGVhZFNpemVdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRleHQuY29tcHV0ZShcbiAgICAgICAgICBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhyZXNoYXBlZElucHV0LCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUucGVybSksXG4gICAgICAgICAge2lucHV0czogW3Jlc2hhcGVkSW5wdXRdLCBvdXRwdXRzOiBbLTFdfSlbMF07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IGdyb3VwUXVlcnlBdHRlbnRpb24gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEF0dGVudGlvbkF0dHJzKTogdm9pZCA9PiB7XG4gIGNvbnN0IHBhcmFtcyA9IHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgaWYgKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMubGVuZ3RoID09PSA1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYWNrZWQgUUtWIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgaWYgKGNvbnRleHQuaW5wdXRzWzFdPy5kaW1zLmxlbmd0aCA9PT0gNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFja2VkIEtWIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgY29uc3QgUSA9IG1heWJlVHJhbnNwb3NlVG9CTlNIQW5kQWRkQmlhcyhcbiAgICAgIGNvbnRleHQsIHBhcmFtcy5iYXRjaFNpemUsIHBhcmFtcy5udW1IZWFkcywgcGFyYW1zLnNlcXVlbmNlTGVuZ3RoLCBwYXJhbXMuaGVhZFNpemUsIGNvbnRleHQuaW5wdXRzWzBdLCB1bmRlZmluZWQsXG4gICAgICAwKTtcbiAgY29uc3QgcGFzdEtleSA9IGNvbnRleHQuaW5wdXRzWzNdICYmIGNvbnRleHQuaW5wdXRzWzNdLmRpbXMubGVuZ3RoICE9PSAwID8gY29udGV4dC5pbnB1dHNbM10gOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHBhc3RWYWx1ZSA9IGNvbnRleHQuaW5wdXRzWzRdICYmIGNvbnRleHQuaW5wdXRzWzRdLmRpbXMubGVuZ3RoICE9PSAwID8gY29udGV4dC5pbnB1dHNbNF0gOiB1bmRlZmluZWQ7XG4gIGNvbnN0IEsgPSBtYXliZUV4cGFuZEFuZFRyYW5zcG9zZVRvQk5TSChjb250ZXh0LCBjb250ZXh0LmlucHV0c1sxXSwgcGFzdEtleSwgcGFyYW1zLCAxKTtcbiAgY29uc3QgViA9IG1heWJlRXhwYW5kQW5kVHJhbnNwb3NlVG9CTlNIKGNvbnRleHQsIGNvbnRleHQuaW5wdXRzWzJdLCBwYXN0VmFsdWUsIHBhcmFtcywgMik7XG4gIGFwcGx5QXR0ZW50aW9uKGNvbnRleHQsIFEsIEssIFYsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBwYXJhbXMsIGF0dHJpYnV0ZXMpO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGZpbGxWZWN0b3IsIGdldE1heENvbXBvbmVudHMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIHN1bVZlY3RvciwgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLCBVbmlmb3Jtc0FycmF5VHlwZX0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEluc3RhbmNlTm9ybUF0dHJpYnV0ZXMge1xuICBlcHNpbG9uOiBudW1iZXI7XG4gIGZvcm1hdDogJ05IV0MnfCdOQ0hXJztcbn1cblxuY29uc3QgY3JlYXRlSW5zdGFuY2VOb3JtUHJvZ3JhbUluZm8gPVxuICAgIChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogSW5zdGFuY2VOb3JtQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IHhTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSB4U2hhcGU7XG4gICAgICBjb25zdCBheGlzID0gMjtcbiAgICAgIGNvbnN0IG5vcm1Db3VudCA9IFNoYXBlVXRpbC5zaXplVG9EaW1lbnNpb24oeFNoYXBlLCBheGlzKTtcbiAgICAgIGNvbnN0IG5vcm1TaXplID0gU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKHhTaGFwZSwgYXhpcyk7XG4gICAgICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhub3JtU2l6ZSk7XG4gICAgICBjb25zdCBub3JtUGFja2VkU2l6ZSA9IG5vcm1TaXplIC8gY29tcG9uZW50cztcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSBbeFNoYXBlWzBdLCB4U2hhcGVbMV0sIG5vcm1QYWNrZWRTaXplXTtcbiAgICAgIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWydyYW5rJywgJ3R5cGUnLCAndHlwZSddO1xuICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID1cbiAgICAgICAgICBbe3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogbm9ybVNpemV9LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBub3JtUGFja2VkU2l6ZX1dO1xuICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSwgaW5wdXRTaGFwZSkpO1xuXG4gICAgICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICAgICAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoJ3gnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSBpbnB1dFZhcmlhYmxlKCdzY2FsZScsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMpO1xuICAgICAgICBjb25zdCBiaWFzID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMpO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IFt4LCBzY2FsZSwgYmlhcywgb3V0cHV0XTtcbiAgICAgICAgY29uc3QgZGF0YVR5cGUgPSB4LnR5cGUudmFsdWU7XG4gICAgICAgIGNvbnN0IGYzMlR5cGUgPSBjb21wb25lbnRzID09PSAxID8gJ2YzMicgOiBgdmVjJHtjb21wb25lbnRzfTxmMzI+YDtcbiAgICAgICAgY29uc3Qgd29ya2dyb3VwU2l6ZSA9IDY0O1xuXG4gICAgICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFt7bmFtZTogJ25vcm1TaXplJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ25vcm1QYWNrZWRTaXplJywgdHlwZTogJ3UzMid9XTtcbiAgICAgICAgcmV0dXJuIGBcbiAgdmFyPHdvcmtncm91cD4gbWVhblNoYXJlZCA6IGYzMjtcbiAgdmFyPHdvcmtncm91cD4gc3F1YXJlZE5vcm1TaGFyZWQgOiBmMzI7XG4gIHZhcjx3b3JrZ3JvdXA+IHdvcmtncm91cFNoYXJlZCA6IGFycmF5PCR7ZjMyVHlwZX0sICR7d29ya2dyb3VwU2l6ZX0+O1xuICBjb25zdCB3b3JrZ3JvdXBTaXplID0gJHt3b3JrZ3JvdXBTaXplfXU7XG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4udmFyaWFibGVzKX1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KHdvcmtncm91cFNpemUpfVxuICAgIGxldCBub3JtID0gZ2xvYmFsX2lkeCAvIHdvcmtncm91cFNpemU7XG4gICAgbGV0IGJhdGNoID0gbm9ybSAvIHVuaWZvcm1zLnhfc2hhcGVbMV07XG4gICAgbGV0IGNoYW5uZWwgPSBub3JtICUgdW5pZm9ybXMueF9zaGFwZVsxXTtcbiAgICBsZXQgbG9jYWxJbmRleCA9IGxvY2FsX2lkLng7XG5cbiAgICAvLyBpbml0aWFsaXplIHdvcmtncm91cCBtZW1vcnlcbiAgICB2YXIgaW5pdGlhbCA9ICR7ZjMyVHlwZX0oMCk7XG4gICAgZm9yICh2YXIgaCA9IGxvY2FsSW5kZXg7IGggPCB1bmlmb3Jtcy5ub3JtUGFja2VkU2l6ZTsgaCArPSB3b3JrZ3JvdXBTaXplKSB7XG4gICAgICBpbml0aWFsID0gaW5pdGlhbCArICR7ZjMyVHlwZX0oJHt4LmdldCgnYmF0Y2gnLCAnY2hhbm5lbCcsICdoJyl9KTtcbiAgICB9XG4gICAgd29ya2dyb3VwU2hhcmVkW2xvY2FsSW5kZXhdID0gaW5pdGlhbDtcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIG1lYW4gb2YgY3VycmVudCBjaGFubmVsIGRhdGEuXG4gICAgZm9yICh2YXIgY3VyclNpemUgPSB3b3JrZ3JvdXBTaXplID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gY3VyclNpemUgPj4gMSkge1xuICAgICAgaWYgKGxvY2FsSW5kZXggPCBjdXJyU2l6ZSkge1xuICAgICAgICB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleF0gPSB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleF0gKyB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleCArIGN1cnJTaXplXTtcbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG4gICAgaWYgKGxvY2FsSW5kZXggPT0gMCkge1xuICAgICAgbWVhblNoYXJlZCA9ICR7c3VtVmVjdG9yKCd3b3JrZ3JvdXBTaGFyZWRbMF0nLCBjb21wb25lbnRzKX0gLyBmMzIodW5pZm9ybXMubm9ybVNpemUpO1xuICAgIH1cbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAvLyByZWluaXRpYWxpemUgd29ya2dyb3VwIG1lbW9yeS5cbiAgICBpbml0aWFsID0gJHtmMzJUeXBlfSgwKTtcbiAgICBmb3IgKHZhciBoID0gbG9jYWxJbmRleDsgaCA8IHVuaWZvcm1zLm5vcm1QYWNrZWRTaXplOyBoICs9IHdvcmtncm91cFNpemUpIHtcbiAgICAgIGxldCBkZXZpYXRpb24gPSAgJHtmMzJUeXBlfSgke3guZ2V0KCdiYXRjaCcsICdjaGFubmVsJywgJ2gnKX0pIC0gJHtmMzJUeXBlfShtZWFuU2hhcmVkKTtcbiAgICAgIGluaXRpYWwgPSBpbml0aWFsICsgZGV2aWF0aW9uICogZGV2aWF0aW9uO1xuICAgIH1cbiAgICB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleF0gPSBpbml0aWFsO1xuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgc3VtIG9mIHNxdWFyZSBvZiBkZXZpYXRpb24gb2YgY3VycmVudCBjaGFubmVsIGRhdGEuXG4gICAgZm9yICh2YXIgY3VyclNpemUgPSB3b3JrZ3JvdXBTaXplID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gY3VyclNpemUgPj4gMSkge1xuICAgICAgaWYgKGxvY2FsSW5kZXggPCBjdXJyU2l6ZSkge1xuICAgICAgICB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleF0gPSB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleF0gKyB3b3JrZ3JvdXBTaGFyZWRbbG9jYWxJbmRleCArIGN1cnJTaXplXTtcbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG4gICAgaWYgKGxvY2FsSW5kZXggPT0gMCkge1xuICAgICAgc3F1YXJlZE5vcm1TaGFyZWQgPSAke3N1bVZlY3Rvcignd29ya2dyb3VwU2hhcmVkWzBdJywgY29tcG9uZW50cyl9O1xuICAgIH1cbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICBsZXQgaW52U3RkRGV2ID0gaW52ZXJzZVNxcnQoc3F1YXJlZE5vcm1TaGFyZWQgLyBmMzIodW5pZm9ybXMubm9ybVNpemUpICsgZjMyKCR7YXR0cmlidXRlcy5lcHNpbG9ufSkpO1xuICAgIGxldCBjaGFubmVsU2NhbGUgPSBpbnZTdGREZXYgKiBmMzIoJHtzY2FsZS5nZXRCeU9mZnNldCgnY2hhbm5lbCcpfSk7XG4gICAgbGV0IGNoYW5uZWxTaGlmdCA9IGYzMigke2JpYXMuZ2V0QnlPZmZzZXQoJ2NoYW5uZWwnKX0pIC0gbWVhblNoYXJlZCAqIGNoYW5uZWxTY2FsZTtcbiAgICBmb3IgKHZhciBoID0gbG9jYWxJbmRleDsgaCA8IHVuaWZvcm1zLm5vcm1QYWNrZWRTaXplOyBoICs9IHdvcmtncm91cFNpemUpIHtcbiAgICAgIGxldCB2YWx1ZSA9ICR7eC5nZXQoJ2JhdGNoJywgJ2NoYW5uZWwnLCAnaCcpfSAqICR7ZGF0YVR5cGV9KCR7ZjMyVHlwZX0oY2hhbm5lbFNjYWxlKSkgKyAke2RhdGFUeXBlfSgke1xuICAgICAgICAgICAgZjMyVHlwZX0oY2hhbm5lbFNoaWZ0KSk7XG4gICAgICAke291dHB1dC5zZXQoJ2JhdGNoJywgJ2NoYW5uZWwnLCAnaCcsICd2YWx1ZScpfTtcbiAgICB9XG4gIH1gO1xuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLntuYW1lOiAnSW5zdGFuY2VOb3JtYWxpemF0aW9uJ30sXG4gICAgICAgIC8vIFRPRE86IHVzZSBlcHNpbG9uIGFzIHVuaWZvcm0uIEN1cnJlbnRseSBlcHNpbG9uIGFzIHVuaWZvcm0gZmFpbHMgdGVzdF9pbnN0YW5jZW5vcm1fZXBzaWxvbi5cbiAgICAgICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBgJHthdHRyaWJ1dGVzLmVwc2lsb259OyR7Y29tcG9uZW50c31gLCBpbnB1dERlcGVuZGVuY2llc30sXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAge2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlfSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBub3JtQ291bnR9LFxuICAgICAgICAgIHByb2dyYW1Vbmlmb3Jtc1xuICAgICAgICB9KSxcbiAgICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgICAgfTtcbiAgICB9O1xuXG5jb25zdCBjb21wdXRlTWVhbiA9XG4gICAgKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBpbnB1dDogVGVuc29yVmlldywgc2NhbGU6IFRlbnNvclZpZXcsIGJpYXM6IFRlbnNvclZpZXcsIG46IG51bWJlciwgaDogbnVtYmVyLCBjOiBudW1iZXIsXG4gICAgIGVwc2lsb246IG51bWJlcikgPT4ge1xuICAgICAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoYyk7XG4gICAgICBjb25zdCBXRyA9IDY0O1xuICAgICAgLy8gd2Ugd2lsbCBzdG9yZSBjaGFubmVsIHNjYWxlIGFuZCBjaGFubmVsIHNoaWZ0IGluIFsyLCBjb21wb25lbnRzXSBtYXRyaXhcbiAgICAgIC8vIG9yIGluIHZlYzIgd2hlbiBjb21wb25lbnRzID09IDFcbiAgICAgIGNvbnN0IG91dHB1dFR5cGUgPSBjb21wb25lbnRzID09PSAxID8gJ3ZlYzJmJyA6IGBtYXQyeCR7Y29tcG9uZW50c31mYDtcbiAgICAgIGNvbnN0IHN1bUNhc3RUeXBlID0gY29tcG9uZW50cyA9PT0gMSA/ICdmMzInIDogYHZlYyR7Y29tcG9uZW50c31mYDtcbiAgICAgIGNvbnN0IHNldE91dHB1dFZhbHVlID0gKHZhcjE6IHN0cmluZywgdmFyMjogc3RyaW5nKSA9PiBgJHtvdXRwdXRUeXBlfSgke3ZhcjF9LCAke3ZhcjJ9KWA7XG4gICAgICBjb25zdCB1bml0c09mV29yayA9IG4gKiBjIC8gY29tcG9uZW50cztcbiAgICAgIGNvbnN0IHdnU2l6ZSA9IE1hdGguY2VpbChoIC8gV0cpO1xuXG4gICAgICBjb25zdCBtZWFuSW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnXTtcbiAgICAgIGNvbnN0IG1lYW5Qcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHdnU2l6ZX0sIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGh9LFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNYXRoLmZsb29yKGMgLyBjb21wb25lbnRzKX0sXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE1hdGguZmxvb3IoaCAqIGMgLyBjb21wb25lbnRzKX1cbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IGdldE1lYW5TaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXRIZWxwZXIgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0LmRhdGFUeXBlLCBpbnB1dC5kaW1zLCBjb21wb25lbnRzKTtcbiAgICAgICAgcmV0dXJuIGBcbiAgJHtzaGFkZXJIZWxwZXIuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dEhlbHBlcil9XG4gIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gb3V0cHV0IDogYXJyYXk8JHtvdXRwdXRUeXBlfT47XG4gIHN0cnVjdCBVbmlmb3JtcyB7d2dfc2l6ZTp1MzIsIEg6dTMyLCBDOnUzMiwgaW1hZ2Vfc2l6ZTp1MzJ9O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHVuaWZvcm0+IHVuaWZvcm1zOiBVbmlmb3JtcztcblxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoV0cpfVxuICAgIGxldCBjdXJyZW50SW1hZ2VOdW1iZXIgPSBnbG9iYWxfaWR4IC8gJHtXR30gLyB1bmlmb3Jtcy5DO1xuICAgIGxldCBjdXJyZW50Q2hhbm5lbE51bWJlciA9IChnbG9iYWxfaWR4IC8gJHtXR30pICUgdW5pZm9ybXMuQztcbiAgICBsZXQgd2dPZmZzZXQgPSBsb2NhbF9pZC54ICogdW5pZm9ybXMud2dfc2l6ZTtcbiAgICBpZiAod2dPZmZzZXQgPj0gdW5pZm9ybXMuSCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB3Z01heCA9IG1pbih3Z09mZnNldCArIHVuaWZvcm1zLndnX3NpemUsIHVuaWZvcm1zLkgpO1xuXG4gICAgbGV0IG9mZnNldCA9IGN1cnJlbnRJbWFnZU51bWJlciAqIHVuaWZvcm1zLmltYWdlX3NpemUgKyBjdXJyZW50Q2hhbm5lbE51bWJlcjtcbiAgICB2YXIgc3VtID0gJHtmaWxsVmVjdG9yKCdmMzInLCBjb21wb25lbnRzKX07XG4gICAgdmFyIHNxdWFyZWRTdW0gPSAke2ZpbGxWZWN0b3IoJ2YzMicsIGNvbXBvbmVudHMpfTtcbiAgICBmb3IgKHZhciBpOiB1MzIgPSB3Z09mZnNldDsgaSA8IHdnTWF4OyBpKyspIHtcbiAgICAgICAgbGV0IHZhbHVlID0gJHtzdW1DYXN0VHlwZX0oaW5wdXRbb2Zmc2V0ICsgaSAqIHVuaWZvcm1zLkNdKTtcbiAgICAgICAgc3VtICs9IHZhbHVlO1xuICAgICAgICBzcXVhcmVkU3VtICs9IHZhbHVlICogdmFsdWU7XG4gICAgfVxuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7c2V0T3V0cHV0VmFsdWUoJ3N1bScsICdzcXVhcmVkU3VtJyl9O1xuICB9YDtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG1lYW5WYWx1ZXMgPSBjb250ZXh0LmNvbXB1dGUoXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogJ0luc3RhbmNlTm9ybUNvbXB1dGVNZWFuJyxcbiAgICAgICAgICAgIHNoYWRlckNhY2hlOiB7aGludDogYCR7Y29tcG9uZW50c31gLCBpbnB1dERlcGVuZGVuY2llczogbWVhbklucHV0RGVwZW5kZW5jaWVzfSxcbiAgICAgICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAgICAgICB7ZGltczogW24sIGMsIFdHLCAyXSwgZGF0YVR5cGU6IERhdGFUeXBlLmZsb2F0fSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IG4gKiBjIC8gY29tcG9uZW50c30sXG4gICAgICAgICAgICAgIHByb2dyYW1Vbmlmb3JtczogbWVhblByb2dyYW1Vbmlmb3Jtc1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBnZXRTaGFkZXJTb3VyY2U6IGdldE1lYW5TaGFkZXJTb3VyY2UsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7aW5wdXRzOiBbaW5wdXRdLCBvdXRwdXRzOiBbLTFdfSlbMF07XG5cbiAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogdW5pdHNPZldvcmt9LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBofSxcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTWF0aC5mbG9vcihjIC8gY29tcG9uZW50cyl9LFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNYXRoLmZsb29yKFdHICogYyAvIGNvbXBvbmVudHMpfVxuICAgICAgXTtcbiAgICAgIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWyd0eXBlJywgJ3R5cGUnLCAndHlwZSddO1xuICAgICAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHNjYWxlSGVscGVyID0gaW5wdXRWYXJpYWJsZSgnc2NhbGUnLCBzY2FsZS5kYXRhVHlwZSwgc2NhbGUuZGltcywgY29tcG9uZW50cyk7XG4gICAgICAgIGNvbnN0IGJpYXNIZWxwZXIgPSBpbnB1dFZhcmlhYmxlKCdiaWFzJywgYmlhcy5kYXRhVHlwZSwgYmlhcy5kaW1zLCBjb21wb25lbnRzKTtcbiAgICAgICAgcmV0dXJuIGBcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiBpbnB1dCA6IGFycmF5PCR7b3V0cHV0VHlwZX0+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMSkgdmFyPHN0b3JhZ2UsIHJlYWQ+IHNjYWxlIDogYXJyYXk8JHtzY2FsZUhlbHBlci50eXBlLnN0b3JhZ2V9PjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLCByZWFkPiBiaWFzIDogYXJyYXk8JHtiaWFzSGVscGVyLnR5cGUuc3RvcmFnZX0+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMykgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG91dHB1dCA6IGFycmF5PCR7b3V0cHV0VHlwZX0+O1xuICBzdHJ1Y3QgVW5pZm9ybXMge3VuaXRzX29mX3dvcmsgOiB1MzIsIEg6IHUzMiwgQyA6IHUzMiwgaW1hZ2Vfc2l6ZSA6IHUzMn07XG4gIEBncm91cCgwKSBAYmluZGluZyg0KSB2YXI8dW5pZm9ybT4gdW5pZm9ybXM6IFVuaWZvcm1zO1xuXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLnVuaXRzX29mX3dvcmsnKX1cbiAgICBsZXQgY3VycmVudEltYWdlTnVtYmVyID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLkM7XG4gICAgbGV0IGN1cnJlbnRDaGFubmVsTnVtYmVyID0gZ2xvYmFsX2lkeCAlIHVuaWZvcm1zLkM7XG5cbiAgICBsZXQgb2Zmc2V0ID0gY3VycmVudEltYWdlTnVtYmVyICogdW5pZm9ybXMuaW1hZ2Vfc2l6ZTtcbiAgICB2YXIgc3VtID0gJHtmaWxsVmVjdG9yKCdmMzInLCBjb21wb25lbnRzKX07XG4gICAgdmFyIHNxdWFyZWRTdW0gPSAke2ZpbGxWZWN0b3IoJ2YzMicsIGNvbXBvbmVudHMpfTtcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgbWluKCR7V0d9LCB1bmlmb3Jtcy5IKTsgaSsrKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGlucHV0W29mZnNldCArIGkgKyBjdXJyZW50Q2hhbm5lbE51bWJlciAqICR7V0d9XTtcbiAgICAgICAgc3VtICs9IHZhbHVlWzBdO1xuICAgICAgICBzcXVhcmVkU3VtICs9IHZhbHVlWzFdO1xuICAgIH1cbiAgICBzdW0gPSBzdW0gLyBmMzIodW5pZm9ybXMuSCk7XG4gICAgc3F1YXJlZFN1bSA9IHNxdWFyZWRTdW0gLyBmMzIodW5pZm9ybXMuSCk7XG4gICAgbGV0IGludlN0ZERldiA9IGludmVyc2VTcXJ0KHNxdWFyZWRTdW0gLSBzdW0gKiBzdW0gKyBmMzIoJHtlcHNpbG9ufSkpO1xuICAgIGxldCBjaGFubmVsU2NhbGUgPSBpbnZTdGREZXYgKiAke3N1bUNhc3RUeXBlfShzY2FsZVtjdXJyZW50Q2hhbm5lbE51bWJlcl0pO1xuICAgIGxldCBjaGFubmVsU2hpZnQgPSAke3N1bUNhc3RUeXBlfShiaWFzW2N1cnJlbnRDaGFubmVsTnVtYmVyXSkgLSBzdW0gKiBjaGFubmVsU2NhbGU7XG5cbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke3NldE91dHB1dFZhbHVlKCdjaGFubmVsU2NhbGUnLCAnY2hhbm5lbFNoaWZ0Jyl9O1xuICB9YDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gY29udGV4dC5jb21wdXRlKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbnN0YW5jZU5vcm1Db21wdXRlQ2hhbm5lbFNjYWxlU2hpZnQnLFxuICAgICAgICAgICAgLy8gVE9ETzogdXNlIGVwc2lsb24gYXMgdW5pZm9ybS4gQ3VycmVudGx5IGVwc2lsb24gYXMgdW5pZm9ybSBmYWlscyB0ZXN0X2luc3RhbmNlbm9ybV9lcHNpbG9uLlxuICAgICAgICAgICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBgJHtjb21wb25lbnRzfTske2Vwc2lsb259YCwgaW5wdXREZXBlbmRlbmNpZXN9LFxuICAgICAgICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgICAgICAgb3V0cHV0czogW1xuICAgICAgICAgICAgICAgIHtkaW1zOiBbbiwgYywgMl0sIGRhdGFUeXBlOiBEYXRhVHlwZS5mbG9hdH0sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwodW5pdHNPZldvcmsgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgICAgICAgICBwcm9ncmFtVW5pZm9ybXNcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge2lucHV0czogW21lYW5WYWx1ZXMsIHNjYWxlLCBiaWFzXSwgb3V0cHV0czogWy0xXX0pWzBdO1xuICAgIH07XG5cbmNvbnN0IGNyZWF0ZUluc3RhbmNlTm9ybU5IV0NQcm9ncmFtSW5mbyA9XG4gICAgKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogSW5zdGFuY2VOb3JtQXR0cmlidXRlcykgPT4ge1xuICAgICAgY29uc3QgeFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IHhTaGFwZTtcbiAgICAgIGNvbnN0IE4gPSB4U2hhcGVbMF07XG4gICAgICBjb25zdCBDID0geFNoYXBlW3hTaGFwZS5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IEggPSBTaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24oeFNoYXBlLCAxKSAvIEM7XG4gICAgICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhDKTtcbiAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyBjb21wb25lbnRzO1xuICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID1cbiAgICAgICAgICBbe3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogSH0sIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE1hdGguZmxvb3IoQyAvIGNvbXBvbmVudHMpfV07XG4gICAgICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsndHlwZScsICd0eXBlJ107XG4gICAgICAvLyBmaXJzdCBjb21wdXRlIG1lYW5cbiAgICAgIGNvbnN0IGNoYW5uZWxTY2FsZVNoaWZ0ID0gY29tcHV0ZU1lYW4oY29udGV4dCwgaW5wdXRzWzBdLCBpbnB1dHNbMV0sIGlucHV0c1syXSwgTiwgSCwgQywgYXR0cmlidXRlcy5lcHNpbG9uKTtcbiAgICAgIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgICAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xuICAgICAgICBjb25zdCBzY2FsZVR5cGUgPSBjb21wb25lbnRzID09PSAxID8gJ3ZlYzJmJyA6IGBtYXQyeCR7Y29tcG9uZW50c31mYDtcbiAgICAgICAgY29uc3Qgc2NhbGVDYXN0VHlwZSA9IGNvbXBvbmVudHMgPT09IDEgPyBkYXRhVHlwZSA6IGB2ZWMke2NvbXBvbmVudHN9PCR7ZGF0YVR5cGV9PmA7XG5cbiAgICAgICAgY29uc3QgaW5wdXRIZWxwZXIgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMsIGNvbXBvbmVudHMpO1xuICAgICAgICBjb25zdCBvdXRwdXRIZWxwZXIgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgY29tcG9uZW50cyk7XG5cbiAgICAgICAgcmV0dXJuIGBcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiBpbnB1dCA6IGFycmF5PCR7aW5wdXRIZWxwZXIudHlwZS5zdG9yYWdlfT47XG4gIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZD4gc2NhbGVJbnB1dCA6IGFycmF5PCR7c2NhbGVUeXBlfT47XG4gIEBncm91cCgwKSBAYmluZGluZygyKSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gb3V0cHV0IDogYXJyYXk8JHtvdXRwdXRIZWxwZXIudHlwZS5zdG9yYWdlfT47XG4gIHN0cnVjdCBVbmlmb3JtcyB7SDogdTMyLCBDIDogdTMyfTtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDMpIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgbGV0IGN1cnJlbnRJbWFnZU51bWJlciA9IGdsb2JhbF9pZHggLyAodW5pZm9ybXMuQyAqIHVuaWZvcm1zLkgpO1xuICAgIGxldCBjdXJyZW50Q2hhbm5lbE51bWJlciA9IGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5DO1xuXG4gICAgbGV0IHNjYWxlT2Zmc2V0ID0gY3VycmVudEltYWdlTnVtYmVyICogdW5pZm9ybXMuQyArIGN1cnJlbnRDaGFubmVsTnVtYmVyO1xuICAgIGxldCBzY2FsZSA9IHNjYWxlSW5wdXRbc2NhbGVPZmZzZXRdO1xuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGZtYShpbnB1dFtnbG9iYWxfaWR4XSwgJHtzY2FsZUNhc3RUeXBlfShzY2FsZVswXSksICR7c2NhbGVDYXN0VHlwZX0oc2NhbGVbMV0pKTtcbiAgfWA7XG4gICAgICB9O1xuICAgICAgY29udGV4dC5jb21wdXRlKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICdJbnN0YW5jZU5vcm1hbGl6YXRpb25OSFdDJyxcbiAgICAgICAgICAgIHNoYWRlckNhY2hlOiB7aGludDogYCR7Y29tcG9uZW50c31gLCBpbnB1dERlcGVuZGVuY2llc30sXG4gICAgICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICAgICAgICBvdXRwdXRzOiBbe2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlfV0sXG4gICAgICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKX0sXG4gICAgICAgICAgICAgIHByb2dyYW1Vbmlmb3Jtc1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7aW5wdXRzOiBbaW5wdXRzWzBdLCBjaGFubmVsU2NhbGVTaGlmdF19KTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgaW5zdGFuY2VOb3JtID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBJbnN0YW5jZU5vcm1BdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmIChhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnKSB7XG4gICAgY3JlYXRlSW5zdGFuY2VOb3JtTkhXQ1Byb2dyYW1JbmZvKGNvbnRleHQsIGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlSW5zdGFuY2VOb3JtUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y2FzdFRvRjMyLCBmaWxsVmVjdG9yLCBnZXRNYXhDb21wb25lbnRzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCBzdW1WZWN0b3IsIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSwgVW5pZm9ybXNBcnJheVR5cGUsfSBmcm9tICcuL2NvbW1vbic7XG5cbmludGVyZmFjZSBMYXllck5vcm1BdHRyaWJ1dGVzIHtcbiAgc2ltcGxpZmllZDogYm9vbGVhbjtcbiAgYXhpczogbnVtYmVyO1xuICBlcHNpbG9uOiBudW1iZXI7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdsYXllck5vcm0gcmVxdWlyZXMgYXQgbGVhc3QgMiBpbnB1dHMuJyk7XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZUxheWVyTm9ybVByb2dyYW1JbmZvID1cbiAgICAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IExheWVyTm9ybUF0dHJpYnV0ZXMsIG91dHB1dENvdW50OiBudW1iZXIpOiBQcm9ncmFtSW5mbyA9PiB7XG4gICAgICBjb25zdCBzaW1wbGlmaWVkID0gYXR0cmlidXRlcy5zaW1wbGlmaWVkO1xuXG4gICAgICBjb25zdCB4U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgICAgIGNvbnN0IHNjYWxlID0gaW5wdXRzWzFdO1xuICAgICAgY29uc3QgYmlhcyA9ICFzaW1wbGlmaWVkICYmIGlucHV0c1syXTtcblxuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSB4U2hhcGU7XG4gICAgICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCB4U2hhcGUubGVuZ3RoKTtcbiAgICAgIGNvbnN0IG5vcm1Db3VudCA9IFNoYXBlVXRpbC5zaXplVG9EaW1lbnNpb24oeFNoYXBlLCBheGlzKTtcbiAgICAgIGNvbnN0IG5vcm1TaXplID0gU2hhcGVVdGlsLnNpemVGcm9tRGltZW5zaW9uKHhTaGFwZSwgYXhpcyk7XG5cbiAgICAgIGNvbnN0IHNjYWxlU2l6ZSA9IFNoYXBlVXRpbC5zaXplKHNjYWxlLmRpbXMpO1xuICAgICAgY29uc3QgYmlhc1NpemUgPSBiaWFzID8gU2hhcGVVdGlsLnNpemUoYmlhcy5kaW1zKSA6IDA7XG4gICAgICBpZiAoc2NhbGVTaXplICE9PSBub3JtU2l6ZSB8fCAoYmlhcyAmJiBiaWFzU2l6ZSAhPT0gbm9ybVNpemUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2l6ZSBvZiBYLnNoYXBlKClbYXhpczpdID09ICR7bm9ybVNpemV9LlxuICAgICAgIFNpemUgb2Ygc2NhbGUgYW5kIGJpYXMgKGlmIHByb3ZpZGVkKSBtdXN0IG1hdGNoIHRoaXMuXG4gICAgICAgR290IHNjYWxlIHNpemUgb2YgJHtzY2FsZVNpemV9IGFuZCBiaWFzIHNpemUgb2YgJHtiaWFzU2l6ZX1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbWVhbkludlN0ZERldkRpbTogbnVtYmVyW10gPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgeFNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChpIDwgYXhpcykge1xuICAgICAgICAgIG1lYW5JbnZTdGREZXZEaW0ucHVzaCh4U2hhcGVbaV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lYW5JbnZTdGREZXZEaW0ucHVzaCgxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMobm9ybVNpemUpO1xuICAgICAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnLCAndHlwZSddO1xuICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBub3JtQ291bnR9LCB7dHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IG5vcm1TaXplfSxcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTWF0aC5mbG9vcihub3JtU2l6ZSAvIGNvbXBvbmVudHMpfSxcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBhdHRyaWJ1dGVzLmVwc2lsb259XG4gICAgICBdO1xuICAgICAgaWYgKGJpYXMpIHtcbiAgICAgICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgndHlwZScpO1xuICAgICAgfVxuICAgICAgY29uc3QgaGFzTWVhbkRhdGFPdXRwdXQgPSBvdXRwdXRDb3VudCA+IDE7XG4gICAgICBjb25zdCBoYXNJbnZTdGRPdXRwdXQgPSBvdXRwdXRDb3VudCA+IDI7XG5cbiAgICAgIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgICAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xuICAgICAgICBjb25zdCB2YXJpYWJsZXMgPSBbXG4gICAgICAgICAgaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMsIGNvbXBvbmVudHMpLFxuICAgICAgICAgIGlucHV0VmFyaWFibGUoJ3NjYWxlJywgc2NhbGUuZGF0YVR5cGUsIHNjYWxlLmRpbXMsIGNvbXBvbmVudHMpLFxuICAgICAgICBdO1xuICAgICAgICBpZiAoYmlhcykge1xuICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKGlucHV0VmFyaWFibGUoJ2JpYXMnLCBiaWFzLmRhdGFUeXBlLCBiaWFzLmRpbXMsIGNvbXBvbmVudHMpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgY29tcG9uZW50cykpO1xuICAgICAgICBpZiAoaGFzTWVhbkRhdGFPdXRwdXQpIHtcbiAgICAgICAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnbWVhbl9kYXRhX291dHB1dCcsIERhdGFUeXBlLmZsb2F0LCBtZWFuSW52U3RkRGV2RGltKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0ludlN0ZE91dHB1dCkge1xuICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKG91dHB1dFZhcmlhYmxlKCdpbnZfc3RkX291dHB1dCcsIERhdGFUeXBlLmZsb2F0LCBtZWFuSW52U3RkRGV2RGltKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICAgICAge25hbWU6ICdub3JtX2NvdW50JywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ25vcm1fc2l6ZScsIHR5cGU6ICdmMzInfSxcbiAgICAgICAgICB7bmFtZTogJ25vcm1fc2l6ZV92ZWN0b3JpemVkJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ2Vwc2lsb24nLCB0eXBlOiAnZjMyJ31cbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi52YXJpYWJsZXMpfVxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5ub3JtX2NvdW50Jyl9XG4gICAgbGV0IG9mZnNldCA9IGdsb2JhbF9pZHggKiB1bmlmb3Jtcy5ub3JtX3NpemVfdmVjdG9yaXplZDtcbiAgICB2YXIgbWVhbl92ZWN0b3IgPSAke2ZpbGxWZWN0b3IoJ2YzMicsIGNvbXBvbmVudHMpfTtcbiAgICB2YXIgbWVhbl9zcXVhcmVfdmVjdG9yID0gJHtmaWxsVmVjdG9yKCdmMzInLCBjb21wb25lbnRzKX07XG5cbiAgICBmb3IgKHZhciBoOiB1MzIgPSAwdTsgaCA8IHVuaWZvcm1zLm5vcm1fc2l6ZV92ZWN0b3JpemVkOyBoKyspIHtcbiAgICAgIGxldCB2YWx1ZSA9ICR7Y2FzdFRvRjMyKGRhdGFUeXBlLCBjb21wb25lbnRzLCAneFtoICsgb2Zmc2V0XScpfTtcbiAgICAgIG1lYW5fdmVjdG9yICs9IHZhbHVlO1xuICAgICAgbWVhbl9zcXVhcmVfdmVjdG9yICs9IHZhbHVlICogdmFsdWU7XG4gICAgfVxuICAgIGxldCBtZWFuID0gJHtzdW1WZWN0b3IoJ21lYW5fdmVjdG9yJywgY29tcG9uZW50cyl9IC8gdW5pZm9ybXMubm9ybV9zaXplO1xuICAgIGxldCBpbnZfc3RkX2RldiA9IGludmVyc2VTcXJ0KCR7c3VtVmVjdG9yKCdtZWFuX3NxdWFyZV92ZWN0b3InLCBjb21wb25lbnRzKX0gLyB1bmlmb3Jtcy5ub3JtX3NpemUgJHtcbiAgICAgICAgICAgIHNpbXBsaWZpZWQgPyAnJyA6ICctIG1lYW4gKiBtZWFuJ30gKyB1bmlmb3Jtcy5lcHNpbG9uKTtcblxuICAgIGZvciAodmFyIGo6IHUzMiA9IDA7IGogPCB1bmlmb3Jtcy5ub3JtX3NpemVfdmVjdG9yaXplZDsgaisrKSB7XG4gICAgICBsZXQgZjMyaW5wdXQgPSAke2Nhc3RUb0YzMihkYXRhVHlwZSwgY29tcG9uZW50cywgJ3hbaiArIG9mZnNldF0nKX07XG4gICAgICBsZXQgZjMyc2NhbGUgPSAke2Nhc3RUb0YzMihkYXRhVHlwZSwgY29tcG9uZW50cywgJ3NjYWxlW2pdJyl9O1xuICAgICAgb3V0cHV0W2ogKyBvZmZzZXRdID0gJHt2YXJpYWJsZXNbMF0udHlwZS52YWx1ZX0oKGYzMmlucHV0ICR7c2ltcGxpZmllZCA/ICcnIDogJy0gbWVhbid9KSAqIGludl9zdGRfZGV2ICogZjMyc2NhbGVcbiAgICAgICAgJHtiaWFzID8gYCsgJHtjYXN0VG9GMzIoZGF0YVR5cGUsIGNvbXBvbmVudHMsICdiaWFzW2pdJyl9YCA6ICcnfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAke2hhc01lYW5EYXRhT3V0cHV0ID8gJ21lYW5fZGF0YV9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBtZWFuJyA6ICcnfTtcbiAgICAke2hhc0ludlN0ZE91dHB1dCA/ICdpbnZfc3RkX291dHB1dFtnbG9iYWxfaWR4XSA9IGludl9zdGRfZGV2JyA6ICcnfTtcbiAgfWA7XG4gICAgICB9O1xuICAgICAgY29uc3Qgb3V0cHV0cyA9IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGV9XTtcbiAgICAgIGlmIChoYXNNZWFuRGF0YU91dHB1dCkge1xuICAgICAgICBvdXRwdXRzLnB1c2goe2RpbXM6IG1lYW5JbnZTdGREZXZEaW0sIGRhdGFUeXBlOiBEYXRhVHlwZS5mbG9hdH0pO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0ludlN0ZE91dHB1dCkge1xuICAgICAgICBvdXRwdXRzLnB1c2goe2RpbXM6IG1lYW5JbnZTdGREZXZEaW0sIGRhdGFUeXBlOiBEYXRhVHlwZS5mbG9hdH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnTGF5ZXJOb3JtYWxpemF0aW9uJyxcbiAgICAgICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBgJHtjb21wb25lbnRzfTske291dHB1dENvdW50fTske3NpbXBsaWZpZWR9YCwgaW5wdXREZXBlbmRlbmNpZXN9LFxuICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PlxuICAgICAgICAgICAgKHtvdXRwdXRzLCBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKG5vcm1Db3VudCAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKX0sIHByb2dyYW1Vbmlmb3Jtc30pLFxuICAgICAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgICB9O1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBsYXllck5vcm0gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IExheWVyTm9ybUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlTGF5ZXJOb3JtUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMsIGNvbnRleHQub3V0cHV0Q291bnQpKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGUsIGdldFRlbnNvckVsZW1lbnRTaXplfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm19IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgZ2V0TWF4Q29tcG9uZW50cywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciwgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLCBVbmlmb3Jtc0FycmF5VHlwZX0gZnJvbSAnLi9jb21tb24nO1xuXG4vLyAgVE9ETyBzdXBwb3J0IHF1YW50aXphdGlvbiBiaXRzIG5vdCBlcXVhbCB0byA0XG5leHBvcnQgaW50ZXJmYWNlIE1hdE11bE5CaXRzQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIGs6IG51bWJlcjtcbiAgbjogbnVtYmVyO1xuICBhY2N1cmFjeUxldmVsOiBudW1iZXI7XG4gIGJpdHM6IG51bWJlcjtcbiAgYmxvY2tTaXplOiBudW1iZXI7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBNYXRNdWxOQml0c0F0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKGlucHV0cy5sZW5ndGggPCAzIHx8IGlucHV0cy5sZW5ndGggPiA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXRNdWxOQml0cyByZXF1aXJlcyAzIG9yIDQgaW5wdXRzJyk7XG4gIH1cbiAgY29uc3QgYSA9IGlucHV0c1swXTtcbiAgY29uc3QgYVJhbmsgPSBhLmRpbXMubGVuZ3RoO1xuICBpZiAoYS5kaW1zW2FSYW5rIC0gMV0gIT09IGF0dHJpYnV0ZXMuaykge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGxhc3QgZGltIG9mIGlucHV0IHNoYXBlIGRvZXMgbm90IG1hdGNoIHRoZSBrIHZhbHVlJyk7XG4gIH1cbiAgY29uc3QgbkJsb2Nrc1BlckNvbCA9IE1hdGguZmxvb3IoKGF0dHJpYnV0ZXMuayArIGF0dHJpYnV0ZXMuYmxvY2tTaXplIC0gMSkgLyBhdHRyaWJ1dGVzLmJsb2NrU2l6ZSk7XG4gIGNvbnN0IGJsb2JTaXplID0gYXR0cmlidXRlcy5ibG9ja1NpemUgLyA4ICogYXR0cmlidXRlcy5iaXRzO1xuICBjb25zdCBiID0gaW5wdXRzWzFdO1xuICBpZiAoIVNoYXBlVXRpbC5hcmVFcXVhbChiLmRpbXMsIFthdHRyaWJ1dGVzLm4sIG5CbG9ja3NQZXJDb2wsIGJsb2JTaXplXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzZWNvbmQgaW5wdXRzIG11c3QgYmUgM0QgdGVuc29yIHdpdGggc2hhcGUgTiBYIG5CbG9ja3NQZXJDb2wgWCBibG9iU2l6ZScpO1xuICB9XG4gIGNvbnN0IHNjYWxlcyA9IGlucHV0c1syXTtcbiAgY29uc3Qgc2NhbGVzU2hhcGUgPSBzY2FsZXMuZGltcztcbiAgaWYgKFNoYXBlVXRpbC5zaXplKHNjYWxlc1NoYXBlKSAhPT0gYXR0cmlidXRlcy5uICogbkJsb2Nrc1BlckNvbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2NhbGVzIGlucHV0IHNpemUgZXJyb3IuJyk7XG4gIH1cbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDQpIHtcbiAgICBjb25zdCB6ZXJvUG9pbnRzID0gaW5wdXRzWzNdO1xuICAgIGNvbnN0IHplcm9Qb2ludHNTaGFwZSA9IHplcm9Qb2ludHMuZGltcztcbiAgICBjb25zdCBleHBlY3RlZFplcm9Qb2ludHNTaXplID1cbiAgICAgICAgYXR0cmlidXRlcy5iaXRzID4gNCA/IChhdHRyaWJ1dGVzLm4gKiBuQmxvY2tzUGVyQ29sKSA6IGF0dHJpYnV0ZXMubiAqIE1hdGguZmxvb3IoKG5CbG9ja3NQZXJDb2wgKyAxKSAvIDIpO1xuICAgIGlmIChTaGFwZVV0aWwuc2l6ZSh6ZXJvUG9pbnRzU2hhcGUpICE9PSBleHBlY3RlZFplcm9Qb2ludHNTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3plcm9Qb2ludHMgaW5wdXQgc2l6ZSBlcnJvci4nKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVNYXRNdWxOQml0c1Byb2dyYW1JbmZvID1cbiAgICAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IE1hdE11bE5CaXRzQXR0cmlidXRlcyxcbiAgICAgbWF4Q29tcHV0ZVdvcmtncm91cFNpemVzOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIG1heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZTogbnVtYmVyKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICAgICAgY29uc3QgYVJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcbiAgICAgIGNvbnN0IG5CbG9ja3NQZXJDb2wgPSBNYXRoLmZsb29yKChhdHRyaWJ1dGVzLmsgKyBhdHRyaWJ1dGVzLmJsb2NrU2l6ZSAtIDEpIC8gYXR0cmlidXRlcy5ibG9ja1NpemUpO1xuICAgICAgY29uc3QgZGltQU91dGVyID0gaW5wdXRTaGFwZVthUmFuayAtIDJdO1xuICAgICAgY29uc3QgZGltSW5uZXIgPSBhdHRyaWJ1dGVzLms7XG4gICAgICBjb25zdCBkaW1CT3V0ZXIgPSBhdHRyaWJ1dGVzLm47XG4gICAgICBjb25zdCBiYXRjaERpbXMgPSBpbnB1dFNoYXBlLnNsaWNlKDAsIGFSYW5rIC0gMik7XG4gICAgICBjb25zdCBiYXRjaFNpemUgPSBTaGFwZVV0aWwuc2l6ZShiYXRjaERpbXMpO1xuICAgICAgY29uc3QgYmxvYlNpemUgPSBhdHRyaWJ1dGVzLmJsb2NrU2l6ZSAvIDggKiBhdHRyaWJ1dGVzLmJpdHM7XG4gICAgICBjb25zdCBibG9iU2l6ZUluV29yZHMgPSBibG9iU2l6ZSAvIDQ7XG4gICAgICBjb25zdCBkYXRhVHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcbiAgICAgIGNvbnN0IG91dHB1dE51bWJlciA9IGdldE1heENvbXBvbmVudHMoZGltQU91dGVyKTtcbiAgICAgIGNvbnN0IGFDb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhhdHRyaWJ1dGVzLmspO1xuICAgICAgY29uc3QgYkNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKGJsb2JTaXplSW5Xb3Jkcyk7XG4gICAgICBjb25zdCBlbGVtZW50U2l6ZSA9IGdldFRlbnNvckVsZW1lbnRTaXplKGRhdGFUeXBlKSE7XG4gICAgICBjb25zdCB3b3JrZ3JvdXBPdXRwdXRTaXplID0gZGltQU91dGVyICogbkJsb2Nrc1BlckNvbCAqIGVsZW1lbnRTaXplO1xuICAgICAgY29uc3QgbWF4TnVtYmVyT2ZDb21wb25lbnRzID0gTWF0aC5mbG9vcihtYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemUgLyB3b3JrZ3JvdXBPdXRwdXRTaXplKTtcbiAgICAgIGNvbnN0IHVzZUJsb2Nrd2lzZU1hdE11bE5CaXRzID0gbkJsb2Nrc1BlckNvbCA8PSBtYXhDb21wdXRlV29ya2dyb3VwU2l6ZXNbMF0gJiYgbWF4TnVtYmVyT2ZDb21wb25lbnRzID4gMDtcbiAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSAoIXVzZUJsb2Nrd2lzZU1hdE11bE5CaXRzIHx8IG1heE51bWJlck9mQ29tcG9uZW50cyA+PSA0KSA/IGdldE1heENvbXBvbmVudHMoZGltQk91dGVyKSA6XG4gICAgICAgICAgKChtYXhOdW1iZXJPZkNvbXBvbmVudHMgPj0gMikgJiYgZ2V0TWF4Q29tcG9uZW50cyhkaW1CT3V0ZXIpID49IDIpICAgICAgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE7XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGJhdGNoRGltcy5jb25jYXQoW2RpbUFPdXRlciwgZGltQk91dGVyXSk7XG4gICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gY29tcG9uZW50cyAvIG91dHB1dE51bWJlcjtcblxuICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gdXNlQmxvY2t3aXNlTWF0TXVsTkJpdHMgP1xuICAgICAgICAgIFtdIDpcbiAgICAgICAgICBbe3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZX0sIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuYmxvY2tTaXplfV07XG4gICAgICBjb25zdCBpbnB1dFNoYXBlVGVtcCA9IFtiYXRjaFNpemUsIGRpbUFPdXRlciwgZGltSW5uZXIgLyBhQ29tcG9uZW50c107XG4gICAgICBjb25zdCBiU2hhcGUgPSBTaGFwZVV0aWwuY29udmVydFNoYXBlKGlucHV0c1sxXS5kaW1zKS5zbGljZSgpO1xuICAgICAgYlNoYXBlLnNwbGljZSgtMSwgMSwgYmxvYlNpemVJbldvcmRzIC8gYkNvbXBvbmVudHMpO1xuICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZVRlbXApKTtcbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGJTaGFwZSkpO1xuICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzJdLmRpbXMpKTtcbiAgICAgIGlmIChpbnB1dHMubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKFNoYXBlVXRpbC5jb252ZXJ0U2hhcGUoaW5wdXRzWzNdLmRpbXMpKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBvdXRwdXRTaGFwZVRlbXAgPSBbYmF0Y2hTaXplLCBkaW1BT3V0ZXIsIGRpbUJPdXRlciAvIGNvbXBvbmVudHNdO1xuICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGVUZW1wKSk7XG4gICAgICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXRTaGFwZVRlbXAubGVuZ3RoO1xuICAgICAgICBjb25zdCBhID0gaW5wdXRWYXJpYWJsZSgnYScsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRSYW5rLCBhQ29tcG9uZW50cyk7XG4gICAgICAgIGNvbnN0IGIgPSBpbnB1dFZhcmlhYmxlKCdiJywgRGF0YVR5cGUudWludDMyLCBiU2hhcGUubGVuZ3RoLCBiQ29tcG9uZW50cyk7XG4gICAgICAgIGNvbnN0IHNjYWxlcyA9IGlucHV0VmFyaWFibGUoJ3NjYWxlcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgaW5wdXRWYXJpYWJsZXMgPSBbYSwgYiwgc2NhbGVzXTtcbiAgICAgICAgY29uc3QgemVyb1BvaW50cyA9XG4gICAgICAgICAgICBpbnB1dHMubGVuZ3RoID09PSA0ID8gaW5wdXRWYXJpYWJsZSgnemVyb19wb2ludHMnLCBEYXRhVHlwZS51aW50MzIsIGlucHV0c1szXS5kaW1zLmxlbmd0aCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh6ZXJvUG9pbnRzKSB7XG4gICAgICAgICAgaW5wdXRWYXJpYWJsZXMucHVzaCh6ZXJvUG9pbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdXRwdXRSYW5rID0gb3V0cHV0U2hhcGVUZW1wLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0UmFuaywgY29tcG9uZW50cyk7XG4gICAgICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFt7bmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMid9LCB7bmFtZTogJ2Jsb2NrX3NpemUnLCB0eXBlOiAndTMyJ31dO1xuICAgICAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xuXG4gICAgICAgIGNvbnN0IHFEcURhdGFUeXBlID0gKCgpID0+IHtcbiAgICAgICAgICBzd2l0Y2ggKGFDb21wb25lbnRzKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHJldHVybiBgYXJyYXk8JHtkYXRhVHlwZX0sIDg+YDtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgcmV0dXJuIGBtYXQ0eDI8JHtkYXRhVHlwZX0+YDtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgcmV0dXJuIGBtYXQyeDQ8JHtkYXRhVHlwZX0+YDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHthQ29tcG9uZW50c30tY29tcG9uZW50IGlzIG5vdCBzdXBwb3J0ZWQuYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuXG4gICAgICAgIGNvbnN0IHByb2Nlc3NPbmVCbG9jayA9IGBcbiAgICAgICAgZm9yICh2YXIgd29yZDogdTMyID0gMDsgd29yZCA8ICR7YmxvYlNpemVJbldvcmRzfTsgd29yZCArPSAke2JDb21wb25lbnRzfSkge1xuICAgICAgICAgICR7Yi5pbmRpY2VzU2V0KCdiX2luZGljZXMnLCAnMicsICd3b3JkJyl9O1xuICAgICAgICAgIGxldCBiX2RhdGEgPSAke2IuZ2V0QnlJbmRpY2VzKCdiX2luZGljZXMnKX07XG4gICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7YkNvbXBvbmVudHN9OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBiX3ZhbHVlOiB1MzIgPSAke2JDb21wb25lbnRzID09PSAxID8gJ2JfZGF0YScgOiAnYl9kYXRhW3dvcmQgKyBpXSd9O1xuICAgICAgICAgICAgbGV0IGJfbWFzazogdTMyID0gMHgwRjBGMEYwRnU7XG4gICAgICAgICAgICBsZXQgYl92YWx1ZV9sb3dlcjogdmVjNDx1MzI+ID0gdW5wYWNrNHhVOChiX3ZhbHVlICYgYl9tYXNrKTtcbiAgICAgICAgICAgIGxldCBiX3ZhbHVlX3VwcGVyOiB2ZWM0PHUzMj4gPSB1bnBhY2s0eFU4KChiX3ZhbHVlID4+IDQpICYgYl9tYXNrKTtcbiAgICAgICAgICAgIGxldCBiX3F1YW50aXplZF92YWx1ZXMgPSAke3FEcURhdGFUeXBlfSgke1xuICAgICAgICAgICAgQXJyYXkuZnJvbSh7bGVuZ3RoOiA0fSwgKF8sIGkpID0+IGAke2RhdGFUeXBlfShiX3ZhbHVlX2xvd2VyWyR7aX1dKSwgJHtkYXRhVHlwZX0oYl92YWx1ZV91cHBlclske2l9XSlgKVxuICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfSk7XG4gICAgICAgICAgICBsZXQgYl9kZXF1YW50aXplZF92YWx1ZXMgPSAkeygoKSA9PiB7XG4gICAgICAgICAgaWYgKGFDb21wb25lbnRzID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7cURxRGF0YVR5cGV9KCR7XG4gICAgICAgICAgICAgICAgQXJyYXkuZnJvbSh7bGVuZ3RoOiA4fSwgKF8sIGkpID0+IGAoYl9xdWFudGl6ZWRfdmFsdWVzWyR7aX1dIC0gemVyb19wb2ludCkgKiBzY2FsZWApLmpvaW4oJywgJyl9KTtgO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYChiX3F1YW50aXplZF92YWx1ZXMgLSAke3FEcURhdGFUeXBlfSgke0FycmF5KDgpLmZpbGwoJ3plcm9fcG9pbnQnKS5qb2luKCcsJyl9KSkgKiBzY2FsZTtgO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKX07XG4gICAgICAgICAgICAvLyBOdW1iZXIgb2YgQiBlbGVtZW50cyBwZXIgMzItYml0IHdvcmQgaXMgMzIvYml0cyA9IDMyLzQgPSA4XG4gICAgICAgICAgICBmb3IgKHZhciBtOiB1MzIgPSAwOyBtIDwgJHt1c2VCbG9ja3dpc2VNYXRNdWxOQml0cyA/IGRpbUFPdXRlciA6IG91dHB1dE51bWJlcn11OyBtKyspIHtcbiAgICAgICAgICAgICAgJHthLmluZGljZXNTZXQoJ2FfaW5kaWNlcycsIGlucHV0UmFuayAtIDIsIHVzZUJsb2Nrd2lzZU1hdE11bE5CaXRzID8gJ20nIDogYHJvdyAqICR7b3V0cHV0TnVtYmVyfSArIG1gKX07XG4gICAgICAgICAgICAgICR7YS5pbmRpY2VzU2V0KCdhX2luZGljZXMnLCBpbnB1dFJhbmsgLSAxLCAnd29yZF9vZmZzZXQnKX07XG4gICAgICAgICAgICAgIHZhciBpbnB1dF9vZmZzZXQgPSAke2EuaW5kaWNlc1RvT2Zmc2V0KCdhX2luZGljZXMnKX07XG4gICAgICAgICAgICAgIHZhciBhX2RhdGE6ICR7cURxRGF0YVR5cGV9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwOyBqIDwgJHs4IC8gYUNvbXBvbmVudHN9OyBqKyspIHtcbiAgICAgICAgICAgICAgICBhX2RhdGFbal0gPSAke2EuZ2V0QnlPZmZzZXQoJ2lucHV0X29mZnNldCcpfTtcbiAgICAgICAgICAgICAgICBpbnB1dF9vZmZzZXQrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAke3VzZUJsb2Nrd2lzZU1hdE11bE5CaXRzID8gJ3dvcmtncm91cF9zaGFyZWRbd29ya2dyb3VwX3NoYXJlZF9vZmZzZXQgKyBtXScgOiAnb3V0cHV0X3ZhbHVlc1ttXSd9JHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMgPiAxID8gJ1tjXScgOiAnJ30gKz0gJHtcbiAgICAgICAgICAgIEFycmF5XG4gICAgICAgICAgICAgICAgLmZyb20oXG4gICAgICAgICAgICAgICAgICAgIHtsZW5ndGg6IDggLyBhQ29tcG9uZW50c30sXG4gICAgICAgICAgICAgICAgICAgIChfLCBpKSA9PiBgJHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFDb21wb25lbnRzID09PSAxID8gYGFfZGF0YVske2l9XSAqIGJfZGVxdWFudGl6ZWRfdmFsdWVzWyR7aX1dYCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBkb3QoYV9kYXRhWyR7aX1dLCBiX2RlcXVhbnRpemVkX3ZhbHVlc1ske2l9XSlgfWApXG4gICAgICAgICAgICAgICAgLmpvaW4oJyArICcpfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmRfb2Zmc2V0ICs9ICR7OCAvIGFDb21wb25lbnRzfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1gO1xuICAgICAgICBjb25zdCB1cGRhdGVaZXJvUG9pbnRJbmRleCA9IHplcm9Qb2ludHMgPyBgXG4gICAgICAgICAgemVyb19wb2ludF9vZmZzZXQgKz0gNDtcbiAgICAgICAgICBpZiAoemVyb19wb2ludF9vZmZzZXQgPT0gMzIpIHtcbiAgICAgICAgICAgIHplcm9fcG9pbnRfb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHplcm9fcG9pbnRfaW5kZXgrKztcbiAgICAgICAgICAgIHplcm9fcG9pbnRfd29yZCA9ICR7emVyb1BvaW50cy5nZXRCeU9mZnNldCgnemVyb19wb2ludF9pbmRleCcpfTtcbiAgICAgICAgICB9YCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcnO1xuXG4gICAgICAgIHJldHVybiB1c2VCbG9ja3dpc2VNYXRNdWxOQml0cyA/IGBcbiAgICAgICAgdmFyPHdvcmtncm91cD4gd29ya2dyb3VwX3NoYXJlZDogYXJyYXk8JHtvdXRwdXQudHlwZS52YWx1ZX0sICR7ZGltQU91dGVyICogbkJsb2Nrc1BlckNvbH0+O1xuICAgICAgICAke3NoYWRlckhlbHBlci5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoW1xuICAgICAgICAgIG5CbG9ja3NQZXJDb2wsIDEsIDFcbiAgICAgICAgXSl9XG4gICAgICAgICAgdmFyIGFfaW5kaWNlczogJHthLnR5cGUuaW5kaWNlc307XG4gICAgICAgICAgdmFyIGJsb2NrID0gbG9jYWxfaWQueDtcbiAgICAgICAgICB2YXIgY29sID0gd29ya2dyb3VwX2lkLnk7XG4gICAgICAgICAgdmFyIGJhdGNoID0gd29ya2dyb3VwX2lkLno7XG4gICAgICAgICAgJHthLmluZGljZXNTZXQoJ2FfaW5kaWNlcycsICcwJywgJ2JhdGNoJyl9O1xuICAgICAgICAgIC8vIFR3byB6ZXJvIHBvaW50cyBhcmUgcGFja2VkIGludG8gb25lIGJ5dGUgd2hlbiB1bmlmb3Jtcy5iaXRzIGlzIDQuXG4gICAgICAgICAgZm9yICh2YXIgYzogdTMyID0gMDsgYyA8ICR7Y29tcG9uZW50c307IGMrKykge1xuICAgICAgICAgICAgbGV0IGNvbF90aW1lc19jb21wb25lbnRzX3BsdXNfYyA9IGNvbCAqICR7Y29tcG9uZW50c30gKyBjO1xuICAgICAgICAgICAgICAke1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgemVyb1BvaW50cyA/IGBcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X2J5dGVzX3Blcl9jb2w6IHUzMiA9ICgke25CbG9ja3NQZXJDb2x9ICsgMSkgLyAyO1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfYnl0ZV9jb3VudDogdTMyID0gY29sX3RpbWVzX2NvbXBvbmVudHNfcGx1c19jICogemVyb19wb2ludF9ieXRlc19wZXJfY29sICsgKGJsb2NrID4+IDB4MXUpO1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfd29yZF9pbmRleDogdTMyID0gemVyb19wb2ludF9ieXRlX2NvdW50ID4+IDB4MnU7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF9ieXRlX29mZnNldDogdTMyID0gemVyb19wb2ludF9ieXRlX2NvdW50ICYgMHgzdTtcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X25pYmJsZV9vZmZzZXQ6IHUzMiA9IGJsb2NrICYgMHgxdTtcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0OiB1MzIgPSAoemVyb19wb2ludF9ieXRlX29mZnNldCA8PCAzKSArICh6ZXJvX3BvaW50X25pYmJsZV9vZmZzZXQgPDwgMik7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF93b3JkOiB1MzIgPSAke3plcm9Qb2ludHMuZ2V0QnlPZmZzZXQoJ3plcm9fcG9pbnRfd29yZF9pbmRleCcpfSA+PiB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0O2AgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcnfVxuICAgICAgICAgICAgdmFyIGJfaW5kaWNlczogJHtiLnR5cGUuaW5kaWNlc307XG4gICAgICAgICAgICAke2IuaW5kaWNlc1NldCgnYl9pbmRpY2VzJywgJzAnLCAnY29sX3RpbWVzX2NvbXBvbmVudHNfcGx1c19jJyl9O1xuICAgICAgICAgICAgLy8gVGhlIHNjYWxlIGFuZCB6ZXJvIHBvaW50cyBhcmUgY29tcHV0ZWQgcGVyIGJsb2NrLlxuICAgICAgICAgICAgdmFyIHNjYWxlc19pbmRleCA9IGNvbF90aW1lc19jb21wb25lbnRzX3BsdXNfYyAqICR7bkJsb2Nrc1BlckNvbH0gKyBibG9jaztcbiAgICAgICAgICAgIGxldCBzY2FsZSA9ICR7c2NhbGVzLmdldEJ5T2Zmc2V0KCdzY2FsZXNfaW5kZXgnKX07XG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB6ZXJvIHBvaW50IGlzIDggZm9yIHVuc2lnbmVkIDQtYml0IHF1YW50aXphdGlvbi5cbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gJHtkYXRhVHlwZX0oJHt6ZXJvUG9pbnRzID8gJyh6ZXJvX3BvaW50X3dvcmQpICYgMHhGdScgOiA4LjB9KTtcbiAgICAgICAgICAgICR7Yi5pbmRpY2VzU2V0KCdiX2luZGljZXMnLCAnMScsICdibG9jaycpfTtcbiAgICAgICAgICAgIHZhciB3b3JkX29mZnNldDogdTMyID0gYmxvY2sgKiAke2F0dHJpYnV0ZXMuYmxvY2tTaXplIC8gYUNvbXBvbmVudHN9O1xuICAgICAgICAgICAgdmFyIHdvcmtncm91cF9zaGFyZWRfb2Zmc2V0OiB1MzIgPSBibG9jayAqICR7ZGltQU91dGVyfTtcbiAgICAgICAgICAgICR7cHJvY2Vzc09uZUJsb2NrfVxuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgICAgdmFyIG91dHB1dF9pbmRpY2VzOiAke291dHB1dC50eXBlLmluZGljZXN9O1xuICAgICAgICAgIHZhciBlbGVtZW50c19wZXJfdGhyZWFkOiB1MzIgPSAke01hdGguY2VpbChkaW1BT3V0ZXIgLyBuQmxvY2tzUGVyQ29sKX07XG4gICAgICAgICAgJHtvdXRwdXQuaW5kaWNlc1NldCgnb3V0cHV0X2luZGljZXMnLCAnMCcsICdiYXRjaCcpfTtcbiAgICAgICAgICAke291dHB1dC5pbmRpY2VzU2V0KCdvdXRwdXRfaW5kaWNlcycsIG91dHB1dFJhbmsgLSAxLCAnY29sJyl9O1xuICAgICAgICAgICR7b3V0cHV0LmluZGljZXNTZXQoJ291dHB1dF9pbmRpY2VzJywgb3V0cHV0UmFuayAtIDIsICdsb2NhbF9pZC54ICogZWxlbWVudHNfcGVyX3RocmVhZCcpfTtcbiAgICAgICAgICB2YXIgb3V0cHV0X29mZnNldCA9ICR7b3V0cHV0LmluZGljZXNUb09mZnNldCgnb3V0cHV0X2luZGljZXMnKX07XG4gICAgICAgICAgZm9yICh2YXIgbTogdTMyID0gMHU7IG0gPCBlbGVtZW50c19wZXJfdGhyZWFkOyBtKyspIHtcbiAgICAgICAgICAgIHZhciByb3cgPSBtICsgbG9jYWxfaWQueCAqIGVsZW1lbnRzX3Blcl90aHJlYWQ7XG4gICAgICAgICAgICBpZiAocm93IDwgJHtkaW1BT3V0ZXJ9KSB7XG4gICAgICAgICAgICAgIHZhciBvdXRwdXRfdmFsdWU6ICR7b3V0cHV0LnR5cGUudmFsdWV9ID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMCk7XG4gICAgICAgICAgICAgIHZhciB3b3JrZ3JvdXBfc2hhcmVkX29mZnNldDogdTMyID0gcm93O1xuICAgICAgICAgICAgICBmb3IgKHZhciBiOiB1MzIgPSAwdTsgYiA8ICR7bkJsb2Nrc1BlckNvbH11OyBiKyspIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRfdmFsdWUgKz0gd29ya2dyb3VwX3NoYXJlZFt3b3JrZ3JvdXBfc2hhcmVkX29mZnNldF07XG4gICAgICAgICAgICAgICAgd29ya2dyb3VwX3NoYXJlZF9vZmZzZXQgKz0gJHtkaW1BT3V0ZXJ9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdvdXRwdXRfb2Zmc2V0JywgJ291dHB1dF92YWx1ZScpfTtcbiAgICAgICAgICAgICAgb3V0cHV0X29mZnNldCArPSAke2RpbUJPdXRlciAvIGNvbXBvbmVudHN9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfWAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXG4gICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJpYWJsZXMsIG91dHB1dCl9XG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG4gICAgICAgICAgdmFyIG91dHB1dF92YWx1ZXM6IGFycmF5PCR7b3V0cHV0LnR5cGUudmFsdWV9LCAke291dHB1dE51bWJlcn0+O1xuICAgICAgICAgIHZhciBvdXRwdXRfaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICAgICB2YXIgY29sID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCBvdXRwdXRSYW5rIC0gMSl9O1xuICAgICAgICAgIHZhciByb3cgPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsIG91dHB1dFJhbmsgLSAyKX07XG4gICAgICAgICAgdmFyIGFfaW5kaWNlczogJHthLnR5cGUuaW5kaWNlc30gPSBvdXRwdXRfaW5kaWNlcztcbiAgICAgICAgICAvLyBUd28gemVybyBwb2ludHMgYXJlIHBhY2tlZCBpbnRvIG9uZSBieXRlIGJlY2F1c2UgdW5pZm9ybXMuYml0cyA8PSA0LlxuICAgICAgICAgIC8vIHplcm9fcG9pbnRfb2Zmc2V0IGlzIGVpdGhlciAwIG9yIDQuIEl0IGlzIGJpdCBvZmZzZXQgd2l0aGluIG9uZSBieXRlLlxuICAgICAgICAgIC8vIFRPRE8gc3VwcG9ydCB6ZXJvX3BvaW50X29mZnNldCBmb3IgYml0cyA+IDRcbiAgICAgICAgICAke1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgemVyb1BvaW50cyA/IGBcbiAgICAgICAgICB2YXIgemVyb19wb2ludF9hYnNfb2Zmc2V0ID0gY29sICogJHtjb21wb25lbnRzfSAqICgoJHtuQmxvY2tzUGVyQ29sfSArIDEpIC8gMik7XG4gICAgICAgICAgdmFyIHplcm9fcG9pbnRfaW5kZXg6IHUzMiA9IHplcm9fcG9pbnRfYWJzX29mZnNldCAvIDQ7XG4gICAgICAgICAgdmFyIHplcm9fcG9pbnRfd29yZDogdTMyID0gJHt6ZXJvUG9pbnRzLmdldEJ5T2Zmc2V0KCd6ZXJvX3BvaW50X2luZGV4Jyl9O1xuICAgICAgICAgIHZhciB6ZXJvX3BvaW50X29mZnNldDogdTMyID0gKHplcm9fcG9pbnRfYWJzX29mZnNldCAlIDQpICogODtgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJ31cbiAgICAgICAgICB2YXIgc2NhbGVfaW5kZXggPSBjb2wgKiAke25CbG9ja3NQZXJDb2wgKiBjb21wb25lbnRzfTtcbiAgICAgICAgICB2YXIgYl9pbmRpY2VzOiAke2IudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgICBmb3IgKHZhciBjOiB1MzIgPSAwOyBjIDwgJHtjb21wb25lbnRzfTsgYysrKSB7XG4gICAgICAgICAgICAke2IuaW5kaWNlc1NldCgnYl9pbmRpY2VzJywgJzAnLCBgY29sICogJHtjb21wb25lbnRzfSArIGNgKX07XG4gICAgICAgICAgICB2YXIgYmxvY2tfb2Zmc2V0OiB1MzIgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgYmxvY2s6IHUzMiA9IDA7IGJsb2NrIDwgJHtuQmxvY2tzUGVyQ29sfTsgYmxvY2srKykge1xuICAgICAgICAgICAgICAvLyBUaGUgc2NhbGUgYW5kIHplcm8gcG9pbnRzIGFyZSBjb21wdXRlZCBwZXIgYmxvY2suXG4gICAgICAgICAgICAgIGxldCBzY2FsZSA9ICR7c2NhbGVzLmdldEJ5T2Zmc2V0KCdzY2FsZV9pbmRleCcpfTtcbiAgICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgemVybyBwb2ludCBpcyA4IGZvciB1bnNpZ25lZCA0LWJpdCBxdWFudGl6YXRpb24uXG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gJHtkYXRhVHlwZX0oJHt6ZXJvUG9pbnRzID8gJ2V4dHJhY3RCaXRzKHplcm9fcG9pbnRfd29yZCwgemVyb19wb2ludF9vZmZzZXQsIDQpJyA6IDguMH0pO1xuICAgICAgICAgICAgICAke2IuaW5kaWNlc1NldCgnYl9pbmRpY2VzJywgJzEnLCAnYmxvY2snKX07XG4gICAgICAgICAgICAgIHZhciB3b3JkX29mZnNldDogdTMyID0gYmxvY2tfb2Zmc2V0O1xuICAgICAgICAgICAgICAke3Byb2Nlc3NPbmVCbG9ja31cbiAgICAgICAgICAgICAgc2NhbGVfaW5kZXgrKztcbiAgICAgICAgICAgICAgJHt1cGRhdGVaZXJvUG9pbnRJbmRleH1cbiAgICAgICAgICAgICAgYmxvY2tfb2Zmc2V0ICs9IHVuaWZvcm1zLmJsb2NrX3NpemUgLyAke2FDb21wb25lbnRzfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERyb3AgdGhlIHRyYWlsaW5nIDQgYml0cyBpZiB0aGUgemVyb19wb2l0X29mZnNldCBpcyBub3QgYSBieXRlIGJvdW5kYXJ5IHRvIGFsaWduIHdpdGggdGhlIG5leHQgYnl0ZS5cbiAgICAgICAgICAgICR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6ZXJvUG9pbnRzID8gYGlmICh6ZXJvX3BvaW50X29mZnNldCAlIDggPiAwKSB7XG4gICAgICAgICAgICAgICAgJHt1cGRhdGVaZXJvUG9pbnRJbmRleH1cbiAgICAgICAgICAgICAgfWAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcnfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCAke291dHB1dE51bWJlcn11OyBrKyspIHtcbiAgICAgICAgICAgICAgJHtvdXRwdXQuaW5kaWNlc1NldCgnb3V0cHV0X2luZGljZXMnLCBvdXRwdXRSYW5rIC0gMiwgYCR7b3V0cHV0TnVtYmVyfSAqIHJvdyArIGtgKX07XG4gICAgICAgICAgICAgICR7b3V0cHV0LnNldEJ5SW5kaWNlcygnb3V0cHV0X2luZGljZXMnLCAnb3V0cHV0X3ZhbHVlc1trXScpfVxuICAgICAgICAgICAgfVxuICAgICAgICB9YDtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiB1c2VCbG9ja3dpc2VNYXRNdWxOQml0cyA/ICdCbG9ja3dpc2VNYXRNdWxOQml0cycgOiAnTWF0TXVsTkJpdHMnLFxuICAgICAgICBzaGFkZXJDYWNoZToge1xuICAgICAgICAgIGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9OyR7ZGltQU91dGVyfTske2RhdGFUeXBlfTske2lucHV0cy5sZW5ndGh9YCxcbiAgICAgICAgICBpbnB1dERlcGVuZGVuY2llczogQXJyYXkoaW5wdXRzLmxlbmd0aCkuZmlsbCgncmFuaycpXG4gICAgICAgIH0sXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGV9XSxcbiAgICAgICAgICBuYW1lOiB1c2VCbG9ja3dpc2VNYXRNdWxOQml0cyA/ICdCbG9ja3dpc2VNYXRNdWxOQml0cycgOiAnTWF0TXVsTkJpdHMnLFxuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHVzZUJsb2Nrd2lzZU1hdE11bE5CaXRzID8ge3g6IDEsIHk6IE1hdGguY2VpbChkaW1CT3V0ZXIgLyBjb21wb25lbnRzKSwgejogYmF0Y2hTaXplfSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgICAgIHByb2dyYW1Vbmlmb3Jtc1xuICAgICAgICB9KSxcbiAgICAgICAgZ2V0U2hhZGVyU291cmNlXG4gICAgICB9O1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBtYXRNdWxOQml0cyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogTWF0TXVsTkJpdHNBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgY29uc3QgbWF4Q29tcHV0ZVdvcmtncm91cFNpemVzOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBjb250ZXh0LmdldE1heENvbXB1dGVXb3JrZ3JvdXBTaXplcygpO1xuICBjb25zdCBtYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemUgPSBjb250ZXh0LmdldE1heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlc2l6ZSgpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlTWF0TXVsTkJpdHNQcm9ncmFtSW5mbyhcbiAgICAgIGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzLCBtYXhDb21wdXRlV29ya2dyb3VwU2l6ZXMsIG1heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZSkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlTWF0TXVsTkJpdHNBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogTWF0TXVsTkJpdHNBdHRyaWJ1dGVzID0+XG4gICAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KGF0dHJpYnV0ZXMgYXMgT21pdDxNYXRNdWxOQml0c0F0dHJpYnV0ZXMsIGtleW9mIEF0dHJpYnV0ZVdpdGhDYWNoZUtleT4pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge1RlbnNvclZpZXd9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7U2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm19IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgZ2V0RWxlbWVudEF0LCBJbmRpY2VzSGVscGVyLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlLCBVbmlmb3Jtc0FycmF5VHlwZX0gZnJvbSAnLi9jb21tb24nO1xuXG5pbnRlcmZhY2UgUGFkQXR0cmlidXRlcyB7XG4gIC8vIDAtY29uc3RhbnQsIDEtcmVmbGVjdCwgMi1lZGdlLCAzLXdyYXBcbiAgcmVhZG9ubHkgbW9kZTogbnVtYmVyO1xuICByZWFkb25seSB2YWx1ZTogbnVtYmVyO1xuICByZWFkb25seSBwYWRzOiBudW1iZXJbXTtcbn1cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbyBmZXcgaW5wdXRzJyk7XG4gIH1cbiAgaWYgKGlucHV0c1swXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuZmxvYXQgJiYgaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5mbG9hdDE2KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCB0eXBlIG11c3QgYmUgZmxvYXQgb3IgZmxvYXQxNi4nKTtcbiAgfVxuXG4gIGlmIChpbnB1dHMubGVuZ3RoID49IDIpIHtcbiAgICBsZXQgdmFsaWRQYWRzID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoICogMiA9PT0gaW5wdXRzWzFdLmRpbXNbMF07XG4gICAgaWYgKGlucHV0cy5sZW5ndGggPT09IDQpIHtcbiAgICAgIHZhbGlkUGFkcyA9IGlucHV0c1szXS5kaW1zWzBdICogMiA9PT0gaW5wdXRzWzFdLmRpbXNbMF07XG4gICAgfVxuICAgIGlmICghdmFsaWRQYWRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwYWRzIHNob3VsZCBiZSBhIDFEIHRlbnNvciBvZiBzaGFwZSBbMiAqIGlucHV0X3JhbmtdIG9yIFsyICogbnVtX2F4ZXNdLicpO1xuICAgIH1cbiAgfVxufTtcblxuY29uc3QgZ2V0UGFkQ29uc3RhbnQgPSAob3V0cHV0OiBJbmRpY2VzSGVscGVyLCBpbnB1dFJhbms6IG51bWJlciwgcGFkc0xlbmd0aDogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgbGV0IGJsb2NrID0gJyc7XG4gIGZvciAobGV0IGkgPSBpbnB1dFJhbmsgLSAxOyBpID49IDA7IC0taSkge1xuICAgIGJsb2NrICs9IGBcbiAgICAgICAgICAgIGsgPSBpMzIoJHtvdXRwdXQuaW5kaWNlc0dldCgnaW5kaWNlcycsIGkpfSkgLSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucGFkcycsIGksIHBhZHNMZW5ndGgpfTtcbiAgICAgICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID49IGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIGksIGlucHV0UmFuayl9KSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3N0cmlkZXMnLCBpLCBpbnB1dFJhbmspfSk7XG4gICAgICAgIGA7XG4gIH1cblxuICByZXR1cm4gYFxuICAgICAgICAgIHZhbHVlID0gJHtvdXRwdXQudHlwZS52YWx1ZX0odW5pZm9ybXMuY29uc3RhbnRfdmFsdWUpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgICR7YmxvY2t9XG4gICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcbiAgICAgICAgICB9XG4gICAgICBgO1xufTtcblxuY29uc3QgZ2V0UGFkUmVmbGVjdCA9IChvdXRwdXQ6IEluZGljZXNIZWxwZXIsIGlucHV0UmFuazogbnVtYmVyLCBwYWRzTGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICBsZXQgYmxvY2sgPSAnJztcbiAgZm9yIChsZXQgaSA9IGlucHV0UmFuayAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgYmxvY2sgKz0gYFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtvdXRwdXQuaW5kaWNlc0dldCgnaW5kaWNlcycsIGkpfSkgLSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucGFkcycsIGksIHBhZHNMZW5ndGgpfTtcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgICAgICAgIGsgPSAtaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgbGV0IF8ybl8xID0gMiAqIChpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCBpLCBpbnB1dFJhbmspfSkgLSAxKTtcbiAgICAgICAgICAgICAgICAgIGsgPSBrICUgXzJuXzE7XG4gICAgICAgICAgICAgICAgICBpZihrID49IGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIGksIGlucHV0UmFuayl9KSkge1xuICAgICAgICAgICAgICAgICAgICBrID0gXzJuXzEgLSBrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gayAqIGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zdHJpZGVzJywgaSwgaW5wdXRSYW5rKX0pO1xuICAgICAgICAgICAgYDtcbiAgfVxuXG4gIHJldHVybiBgXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAgICR7YmxvY2t9XG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIGA7XG59O1xuXG5jb25zdCBnZXRQYWRFZGdlID0gKG91dHB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRSYW5rOiBudW1iZXIsIHBhZHNMZW5ndGg6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gIGxldCBibG9jayA9ICcnO1xuICBmb3IgKGxldCBpID0gaW5wdXRSYW5rIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBibG9jayArPSBgXG4gICAgICAgICAgICAgICAgayA9IGkzMigke291dHB1dC5pbmRpY2VzR2V0KCdpbmRpY2VzJywgaSl9KSAtICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5wYWRzJywgaSwgcGFkc0xlbmd0aCl9O1xuICAgICAgICAgICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgICAgICAgayA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrID49IGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIGksIGlucHV0UmFuayl9KSkge1xuICAgICAgICAgICAgICAgICAgayA9IGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIGksIGlucHV0UmFuayl9KSAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3N0cmlkZXMnLCBpLCBpbnB1dFJhbmspfSk7XG4gICAgICAgICAgICBgO1xuICB9XG5cbiAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgICAgJHtibG9ja31cbiAgICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgYDtcbn07XG5cbmNvbnN0IGdldFBhZFdyYXAgPSAob3V0cHV0OiBJbmRpY2VzSGVscGVyLCBpbnB1dFJhbms6IG51bWJlciwgcGFkc0xlbmd0aDogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgbGV0IGJsb2NrID0gJyc7XG4gIGZvciAobGV0IGkgPSBpbnB1dFJhbmsgLSAxOyBpID49IDA7IC0taSkge1xuICAgIGJsb2NrICs9IGBcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7b3V0cHV0LmluZGljZXNHZXQoJ2luZGljZXMnLCBpKX0pIC0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnBhZHMnLCBpLCBwYWRzTGVuZ3RoKX07XG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSAge1xuICAgICAgICAgICAgICAgICAgayArPSBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCBpLCBpbnB1dFJhbmspfV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoayA+PSBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCBpLCBpbnB1dFJhbmspfSkpIHtcbiAgICAgICAgICAgICAgICAgIGsgLT0gaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gayAqIGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zdHJpZGVzJywgaSwgaW5wdXRSYW5rKX0pO1xuICAgICAgICAgICAgYDtcbiAgfVxuXG4gIHJldHVybiBgXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAgICR7YmxvY2t9XG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIGA7XG59O1xuXG5jb25zdCBnZXRQYWRTbmlwcGV0ID0gKG91dHB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRSYW5rOiBudW1iZXIsIGF0dHJpYnV0ZXM6IFBhZEF0dHJpYnV0ZXMpOiBzdHJpbmcgPT4ge1xuICBzd2l0Y2ggKGF0dHJpYnV0ZXMubW9kZSkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiBnZXRQYWRDb25zdGFudChvdXRwdXQsIGlucHV0UmFuaywgYXR0cmlidXRlcy5wYWRzLmxlbmd0aCk7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGdldFBhZFJlZmxlY3Qob3V0cHV0LCBpbnB1dFJhbmssIGF0dHJpYnV0ZXMucGFkcy5sZW5ndGgpO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBnZXRQYWRFZGdlKG91dHB1dCwgaW5wdXRSYW5rLCBhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoKTtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gZ2V0UGFkV3JhcChvdXRwdXQsIGlucHV0UmFuaywgYXR0cmlidXRlcy5wYWRzLmxlbmd0aCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtb2RlJyk7XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZVBhZFByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBQYWRBdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IFNoYXBlVXRpbC5wYWRTaGFwZShpbnB1dHNbMF0uZGltcy5zbGljZSgpLCBhdHRyaWJ1dGVzLnBhZHMpO1xuICBjb25zdCBpbnB1dERpbXMgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID1cbiAgICAgIFt7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplfSwge3R5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBhdHRyaWJ1dGVzLnBhZHN9XTtcbiAgaWYgKGF0dHJpYnV0ZXMubW9kZSA9PT0gMCkge1xuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKHt0eXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUsIGRhdGE6IGF0dHJpYnV0ZXMudmFsdWV9KTtcbiAgfVxuXG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1swXS5kaW1zLCBvdXRwdXRTaGFwZSkpO1xuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuayddO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gICAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dERpbXMubGVuZ3RoKTtcbiAgICBjb25zdCBkYXRhVHlwZSA9IGlucHV0LnR5cGUudmFsdWU7XG4gICAgY29uc3QgcGFkU25pcHBldCA9IGdldFBhZFNuaXBwZXQob3V0cHV0LCBpbnB1dERpbXMubGVuZ3RoLCBhdHRyaWJ1dGVzKTtcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPVxuICAgICAgICBbe25hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInfSwge25hbWU6ICdwYWRzJywgdHlwZTogJ2kzMicsIGxlbmd0aDogYXR0cmlidXRlcy5wYWRzLmxlbmd0aH1dO1xuICAgIGlmIChhdHRyaWJ1dGVzLm1vZGUgPT09IDApIHtcbiAgICAgIHVuaWZvcm1zLnB1c2goe25hbWU6ICdjb25zdGFudF92YWx1ZScsIHR5cGU6IGRhdGFUeXBlIGFzIFVuaWZvcm1EYXRhRWxlbWVudFR5cGV9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYFxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cblxuICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG5cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR7ZGF0YVR5cGV9KDApO1xuICAgICAgICAgICAgJHtwYWRTbmlwcGV0fVxuICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gICAgICAgIH1gO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1BhZCcsXG4gICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBgJHthdHRyaWJ1dGVzLm1vZGV9YCwgaW5wdXREZXBlbmRlbmNpZXN9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbe2RpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKX0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXNcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5jb25zdCBjcmVhdGVQYWRBdHRyaWJ1dGVzRnJvbUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogUGFkQXR0cmlidXRlcyk6IFBhZEF0dHJpYnV0ZXMgPT4ge1xuICBpZiAoaW5wdXRzLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBiaWdJbnQ2NFBhZHMgPSBpbnB1dHNbMV0uZ2V0QmlnSW50NjRBcnJheSgpO1xuICAgIGNvbnN0IHZhbHVlID0gKGlucHV0cy5sZW5ndGggPj0gMyAmJiBpbnB1dHNbMl0uZGF0YSkgPyBpbnB1dHNbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF0gOiAwLjA7XG5cbiAgICBjb25zdCBpbnB1dFJhbmsgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGg7XG4gICAgY29uc3QgdXBkYXRlUGFkcyA9IG5ldyBJbnQzMkFycmF5KDIgKiBpbnB1dFJhbmspLmZpbGwoMCk7XG4gICAgaWYgKGlucHV0cy5sZW5ndGggPj0gNCkge1xuICAgICAgY29uc3QgYXhlcyA9IGlucHV0c1szXS5nZXRCaWdJbnQ2NEFycmF5KCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdXBkYXRlUGFkc1tOdW1iZXIoYXhlc1tpXSldID0gTnVtYmVyKGJpZ0ludDY0UGFkc1tpXSk7XG4gICAgICAgIHVwZGF0ZVBhZHNbTnVtYmVyKGF4ZXNbaV0pICsgaW5wdXRSYW5rXSA9IE51bWJlcihiaWdJbnQ2NFBhZHNbaSArIGF4ZXMubGVuZ3RoXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGJpZ0ludDY0UGFkcy5mb3JFYWNoKCh2LCBpKSA9PiB1cGRhdGVQYWRzW051bWJlcihpKV0gPSAoTnVtYmVyKHYpKSk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFkczogbnVtYmVyW10gPSBbXTtcbiAgICB1cGRhdGVQYWRzLmZvckVhY2godiA9PiBwYWRzLnB1c2godikpO1xuXG4gICAgcmV0dXJuIHttb2RlOiBhdHRyaWJ1dGVzLm1vZGUsIHZhbHVlLCBwYWRzfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHBhZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUGFkQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHVwZGF0ZWRBdHRyaWJ1dGVzID0gY3JlYXRlUGFkQXR0cmlidXRlc0Zyb21JbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlUGFkUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIHVwZGF0ZWRBdHRyaWJ1dGVzKSwge2lucHV0czogWzBdfSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge2Vudn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1Bvb2xDb252VXRpbCwgU2hhcGVVdGlsfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7QXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybX0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBnZXRFbGVtZW50QXQsIEluZGljZXNIZWxwZXIsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIFVuaWZvcm1zQXJyYXlUeXBlfSBmcm9tICcuL2NvbW1vbic7XG5cbi8vIFRPRE86IHN1cHBvcnQ6XG4vLyAtIGNlaWxfbW9kZSAgICAgICAgICAgICAgICAgXCJ0ZXN0X21heHBvb2xfMmRfY2VpbFwiXG4vLyAtIHN0b3JhZ2Vfb3JkZXIgICAgICAgICAgICAgXCJ0ZXN0X21heHBvb2xfd2l0aF9hcmdtYXhfMmRfcHJlY29tcHV0ZWRfc3RyaWRlc1wiXG4vLyAtIFtNYXhQb29sXSBkaWxhdGlvbnMgICAgICAgXCJ0ZXN0X21heHBvb2xfMmRfZGlsYXRpb25zXCJcbi8vIC0gW01heFBvb2xdIG91dHB1dFsxXSAgICAgICBcInRlc3RfbWF4cG9vbF93aXRoX2FyZ21heF8yZF9wcmVjb21wdXRlZF9wYWRzXCJcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKGVudi53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQgJiYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvb2wgb3BzIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cbn07XG5cbmNvbnN0IGdldEFkanVzdGVkUG9vbEF0dHJpYnV0ZXNBbmRPdXRwdXRTaGFwZSA9IDxBdHRyaWJ1dGVUeXBlIGV4dGVuZHMgQXZlcmFnZVBvb2xBdHRyaWJ1dGVzfE1heFBvb2xBdHRyaWJ1dGVzPihcbiAgICBpbnB1dDogVGVuc29yVmlldywgYXR0cmlidXRlczogQXR0cmlidXRlVHlwZSwgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbik6IFtBdHRyaWJ1dGVUeXBlLCBudW1iZXJbXV0gPT4ge1xuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gIGNvbnN0IGlucHV0U2hhcGVBc0NoYW5uZWxGaXJzdCA9IGlucHV0LmRpbXMuc2xpY2UoKTtcbiAgaWYgKGlzQ2hhbm5lbHNMYXN0KSB7XG4gICAgaW5wdXRTaGFwZUFzQ2hhbm5lbEZpcnN0LnNwbGljZSgxLCAwLCBpbnB1dFNoYXBlQXNDaGFubmVsRmlyc3QucG9wKCkhKTsgIC8vIE1vdmUgY2hhbm5lbCB0byB0aGUgc2Vjb25kIHBvc2l0aW9uLlxuICB9XG4gIGNvbnN0IGhhc0RpbGF0aW9ucyA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJpYnV0ZXMsICdkaWxhdGlvbnMnKTtcbiAgY29uc3Qga2VybmVsU2hhcGUgPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLnNsaWNlKCk7XG4gIGNvbnN0IHN0cmlkZXMgPSBhdHRyaWJ1dGVzLnN0cmlkZXMuc2xpY2UoKTtcbiAgY29uc3QgZGlsYXRpb25zOiBudW1iZXJbXSA9IGhhc0RpbGF0aW9ucyA/IChhdHRyaWJ1dGVzIGFzIE1heFBvb2xBdHRyaWJ1dGVzKS5kaWxhdGlvbnMuc2xpY2UoKSA6IFtdO1xuICBjb25zdCBwYWRzID0gYXR0cmlidXRlcy5wYWRzLnNsaWNlKCk7XG4gIFBvb2xDb252VXRpbC5hZGp1c3RQb29sQXR0cmlidXRlcyhpc0dsb2JhbE9wZXJhdG9yLCBpbnB1dFNoYXBlQXNDaGFubmVsRmlyc3QsIGtlcm5lbFNoYXBlLCBzdHJpZGVzLCBkaWxhdGlvbnMsIHBhZHMpO1xuXG4gIGNvbnN0IG91dHB1dFNoYXBlQXNDaGFubmVsRmlyc3QgPSBQb29sQ29udlV0aWwuY29tcHV0ZVBvb2xPdXRwdXRTaGFwZShcbiAgICAgIGlzR2xvYmFsT3BlcmF0b3IsIGlucHV0U2hhcGVBc0NoYW5uZWxGaXJzdCwgc3RyaWRlcywgZGlsYXRpb25zLCBrZXJuZWxTaGFwZSwgcGFkcywgYXR0cmlidXRlcy5hdXRvUGFkKTtcblxuICBjb25zdCBuZXdBdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlcyk7XG4gIGlmIChoYXNEaWxhdGlvbnMpIHtcbiAgICBPYmplY3QuYXNzaWduKG5ld0F0dHJpYnV0ZXMsIHtrZXJuZWxTaGFwZSwgc3RyaWRlcywgcGFkcywgZGlsYXRpb25zLCBjYWNoZUtleTogYXR0cmlidXRlcy5jYWNoZUtleX0pO1xuICB9IGVsc2Uge1xuICAgIE9iamVjdC5hc3NpZ24obmV3QXR0cmlidXRlcywge2tlcm5lbFNoYXBlLCBzdHJpZGVzLCBwYWRzLCBjYWNoZUtleTogYXR0cmlidXRlcy5jYWNoZUtleX0pO1xuICB9XG4gIGNvbnN0IG91dHB1dFNoYXBlQXNDaGFubmVsTGFzdCA9IG91dHB1dFNoYXBlQXNDaGFubmVsRmlyc3Quc2xpY2UoKTtcbiAgb3V0cHV0U2hhcGVBc0NoYW5uZWxMYXN0LnB1c2gob3V0cHV0U2hhcGVBc0NoYW5uZWxMYXN0LnNwbGljZSgxLCAxKVswXSk7XG4gIHJldHVybiBbbmV3QXR0cmlidXRlcywgaXNDaGFubmVsc0xhc3QgPyBvdXRwdXRTaGFwZUFzQ2hhbm5lbExhc3QgOiBvdXRwdXRTaGFwZUFzQ2hhbm5lbEZpcnN0XTtcbn07XG5cbmNvbnN0IGdldFVuaWZvcm1BbmRQYWRJbmZvID0gPEF0dHJpYnV0ZVR5cGUgZXh0ZW5kcyBBdmVyYWdlUG9vbEF0dHJpYnV0ZXN8TWF4UG9vbEF0dHJpYnV0ZXM+KFxuICAgIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBhdHRyaWJ1dGVzOiBBdHRyaWJ1dGVUeXBlKTogW1Byb2dyYW1Vbmlmb3JtW10sIFVuaWZvcm1zQXJyYXlUeXBlLCBib29sZWFuLCBib29sZWFuLCBib29sZWFuXSA9PiB7XG4gIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgY29uc3Qga2VybmVsU2l6ZSA9IFNoYXBlVXRpbC5zaXplKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUpO1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPVxuICAgICAgW3t0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemV9LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBrZXJuZWxTaXplfV07XG4gIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFt7bmFtZTogJ291dHB1dFNpemUnLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAna2VybmVsU2l6ZScsIHR5cGU6ICd1MzInfV07XG4gIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCA8PSAyKSB7XG4gICAgY29uc3Qga3cgPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlW2F0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoIC0gMV07XG4gICAgY29uc3Qgc3cgPSBhdHRyaWJ1dGVzLnN0cmlkZXNbYXR0cmlidXRlcy5zdHJpZGVzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHB3U3RhcnQgPSBhdHRyaWJ1dGVzLnBhZHNbYXR0cmlidXRlcy5wYWRzLmxlbmd0aCAvIDIgLSAxXTtcbiAgICBjb25zdCBwd0VuZCA9IGF0dHJpYnV0ZXMucGFkc1thdHRyaWJ1dGVzLnBhZHMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgcHdTdGFydEVuZE5vdFplcm8gPSAhIShwd1N0YXJ0ICsgcHdFbmQpO1xuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBrd30sXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHN3fSxcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcHdTdGFydH0sXG4gICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHB3RW5kfSxcbiAgICApO1xuICAgIHVuaWZvcm1zLnB1c2goXG4gICAgICAgIHtuYW1lOiAna3cnLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnc3cnLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAncHdTdGFydCcsIHR5cGU6ICd1MzInfSxcbiAgICAgICAge25hbWU6ICdwd0VuZCcsIHR5cGU6ICd1MzInfSk7XG5cbiAgICBsZXQgcGhTdGFydEVuZE5vdFplcm8gPSBmYWxzZTtcbiAgICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggPT09IDIpIHtcbiAgICAgIGNvbnN0IGtoID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZVthdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAtIDJdO1xuICAgICAgY29uc3Qgc2ggPSBhdHRyaWJ1dGVzLnN0cmlkZXNbYXR0cmlidXRlcy5zdHJpZGVzLmxlbmd0aCAtIDJdO1xuICAgICAgY29uc3QgcGhTdGFydCA9IGF0dHJpYnV0ZXMucGFkc1thdHRyaWJ1dGVzLnBhZHMubGVuZ3RoIC8gMiAtIDJdO1xuICAgICAgY29uc3QgcGhFbmQgPSBhdHRyaWJ1dGVzLnBhZHNbYXR0cmlidXRlcy5wYWRzLmxlbmd0aCAtIDJdO1xuICAgICAgcGhTdGFydEVuZE5vdFplcm8gPSAhIShwaFN0YXJ0ICsgcGhFbmQpO1xuICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goXG4gICAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YToga2h9LCB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBzaH0sIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBoU3RhcnR9LFxuICAgICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBoRW5kfSk7XG5cbiAgICAgIHVuaWZvcm1zLnB1c2goXG4gICAgICAgICAge25hbWU6ICdraCcsIHR5cGU6ICd1MzInfSwge25hbWU6ICdzaCcsIHR5cGU6ICd1MzInfSwge25hbWU6ICdwaFN0YXJ0JywgdHlwZTogJ3UzMid9LFxuICAgICAgICAgIHtuYW1lOiAncGhFbmQnLCB0eXBlOiAndTMyJ30pO1xuICAgIH1cbiAgICByZXR1cm4gW3Byb2dyYW1Vbmlmb3JtcywgdW5pZm9ybXMsIHRydWUsIHB3U3RhcnRFbmROb3RaZXJvLCBwaFN0YXJ0RW5kTm90WmVyb107XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzQ2hhbm5lbHNMYXN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvb2xpbmcgd2l0aCBrZXJuZWxTaGFwZS5sZW5ndGggPiAyIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIE5IV0MgZm9ybWF0LicpO1xuICAgIH1cbiAgICBjb25zdCBrZXJuZWxTdHJpZGVzID0gU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUpO1xuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBrZXJuZWxTdHJpZGVzfSwge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXR0cmlidXRlcy5wYWRzfSxcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXR0cmlidXRlcy5zdHJpZGVzfSk7XG4gICAgdW5pZm9ybXMucHVzaChcbiAgICAgICAge25hbWU6ICdrZXJuZWxTdHJpZGVzJywgdHlwZTogJ3UzMicsIGxlbmd0aDoga2VybmVsU3RyaWRlcy5sZW5ndGh9LFxuICAgICAgICB7bmFtZTogJ3BhZHMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBhdHRyaWJ1dGVzLnBhZHMubGVuZ3RofSxcbiAgICAgICAge25hbWU6ICdzdHJpZGVzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogYXR0cmlidXRlcy5zdHJpZGVzLmxlbmd0aH0pO1xuXG4gICAgY29uc3QgaGFzUGFkcyA9IGF0dHJpYnV0ZXMucGFkcy5yZWR1Y2UoKHN1bSwgY3VyKSA9PiBzdW0gKyBjdXIpO1xuICAgIHJldHVybiBbcHJvZ3JhbVVuaWZvcm1zLCB1bmlmb3JtcywgISFoYXNQYWRzLCBmYWxzZSwgZmFsc2VdO1xuICB9XG59O1xuXG5jb25zdCBnZW5lcmF0ZVBvb2xpbmdDb2RlID0gPEF0dHJpYnV0ZVR5cGUgZXh0ZW5kcyBBdmVyYWdlUG9vbEF0dHJpYnV0ZXN8TWF4UG9vbEF0dHJpYnV0ZXM+KFxuICAgIHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyLCB4OiBJbmRpY2VzSGVscGVyLCByYW5rOiBudW1iZXIsIG91dHB1dFNoYXBlUmFuazogbnVtYmVyLCBhdHRyaWJ1dGVzOiBBdHRyaWJ1dGVUeXBlLFxuICAgIG9wMTogc3RyaW5nLCBvcDI6IHN0cmluZywgc3RhcnQ6IG51bWJlciwgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlLCBoYXNQYWRzOiBib29sZWFuLCBwd1N0YXJ0RW5kTm90WmVybzogYm9vbGVhbixcbiAgICBwaFN0YXJ0RW5kTm90WmVybzogYm9vbGVhbik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcbiAgY29uc3QgZGF0YVR5cGUgPSB4LnR5cGUudmFsdWU7XG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCB4LnR5cGUudGVuc29yLCBvdXRwdXRTaGFwZVJhbmspO1xuXG4gIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCA8PSAyKSB7XG4gICAgbGV0IGNvZGVXID0gJyc7XG4gICAgbGV0IGNvZGVIID0gJyc7XG4gICAgbGV0IGNvZGVIRW5kID0gJyc7XG4gICAgY29uc3QgZGltSWR4VyA9IHJhbmsgLSAoaXNDaGFubmVsc0xhc3QgPyAyIDogMSk7XG4gICAgaWYgKHB3U3RhcnRFbmROb3RaZXJvKSB7XG4gICAgICBjb2RlVyA9IGBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8IHVuaWZvcm1zLmt3OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7ZGltSWR4V31dID0gaW5kaWNlc1ske2RpbUlkeFd9XSAqIHVuaWZvcm1zLnN3IC0gdW5pZm9ybXMucHdTdGFydCArIGk7XG4gICAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbJHtkaW1JZHhXfV0gPCAwIHx8IHhJbmRpY2VzWyR7ZGltSWR4V31dXG4gICAgICAgICAgICAgICAgICAgICAgPj0gdW5pZm9ybXMueF9zaGFwZVske2RpbUlkeFd9XSkge1xuICAgICAgICAgICAgICAgICAgICBwYWQrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7eC5pbmRpY2VzVG9PZmZzZXQoJ3hJbmRpY2VzJyl9XTtcbiAgICAgICAgICAgICAgICAgICR7b3AxfVxuICAgICAgICAgICAgICAgIH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlVyA9IGBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8IHVuaWZvcm1zLmt3OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7ZGltSWR4V31dID0gaW5kaWNlc1ske2RpbUlkeFd9XSAqIHVuaWZvcm1zLnN3IC0gdW5pZm9ybXMucHdTdGFydCArIGk7XG4gICAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7eC5pbmRpY2VzVG9PZmZzZXQoJ3hJbmRpY2VzJyl9XTtcbiAgICAgICAgICAgICAgICAgICR7b3AxfVxuICAgICAgICAgICAgICAgIH1gO1xuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgICAgY29uc3QgZGltSWR4SCA9IHJhbmsgLSAoaXNDaGFubmVsc0xhc3QgPyAzIDogMik7XG4gICAgICBpZiAocGhTdGFydEVuZE5vdFplcm8pIHtcbiAgICAgICAgY29kZUggPSBgXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgajogdTMyID0gMHU7IGogPCB1bmlmb3Jtcy5raDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske2RpbUlkeEh9XSA9IGluZGljZXNbJHtkaW1JZHhIfV0gKiB1bmlmb3Jtcy5zaCAtIHVuaWZvcm1zLnBoU3RhcnQgKyBqO1xuICAgICAgICAgICAgICAgICAgaWYgKHhJbmRpY2VzWyR7ZGltSWR4SH1dIDwgMCB8fCB4SW5kaWNlc1ske2RpbUlkeEh9XSA+PSB1bmlmb3Jtcy54X3NoYXBlWyR7ZGltSWR4SH1dKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZCArPSBpMzIodW5pZm9ybXMua3cpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvZGVIID0gYFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGo6IHUzMiA9IDB1OyBqIDwgdW5pZm9ybXMua2g7IGorKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtkaW1JZHhIfV0gPSBpbmRpY2VzWyR7ZGltSWR4SH1dICogdW5pZm9ybXMuc2ggLSB1bmlmb3Jtcy5waFN0YXJ0ICsgajtcbiAgICAgICAgICAgICAgICBgO1xuICAgICAgfVxuICAgICAgY29kZUhFbmQgPSBgXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGA7XG4gICAgfVxuXG4gICAgY29uc3QgcG9vbGluZ0NvZGUgPSBgXG4gICAgICAgICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKHgsIG91dHB1dCl9XG5cbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRTaXplJyl9XG5cbiAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICAgICAgICAgIHZhciB4SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcblxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAke2RhdGFUeXBlfSgke3N0YXJ0fSk7XG4gICAgICAgICAgICAgIHZhciBwYWQgPSAwO1xuICAgICAgICAgICAgICAke2NvZGVIfVxuICAgICAgICAgICAgICAke2NvZGVXfVxuICAgICAgICAgICAgICAke2NvZGVIRW5kfVxuICAgICAgICAgICAgICAke29wMn1cblxuICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1gO1xuICAgIHJldHVybiBwb29saW5nQ29kZTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNDaGFubmVsc0xhc3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUG9vbGluZyB3aXRoIGtlcm5lbFNoYXBlLmxlbmd0aCA+IDIgaXMgbm90IHN1cHBvcnRlZCBmb3IgTkhXQyBmb3JtYXQuJyk7XG4gICAgfVxuICAgIGNvbnN0IHN0cmlkZXNSYW5rID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGg7XG4gICAgY29uc3QgcGFkc1JhbmsgPSBhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoO1xuICAgIGxldCBwYWRDb2RlID0gJyc7XG4gICAgaWYgKGhhc1BhZHMpIHtcbiAgICAgIHBhZENvZGUgPSBgXG4gICAgICAgICAgICAgICAgaWYgKHhJbmRpY2VzW2pdID49IHVuaWZvcm1zLnhfc2hhcGVbal0pIHtcbiAgICAgICAgICAgICAgICAgIHBhZCsrO1xuICAgICAgICAgICAgICAgICAgaXNQYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghaXNQYWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7eC5pbmRpY2VzVG9PZmZzZXQoJ3hJbmRpY2VzJyl9XTtcbiAgICAgICAgICAgICAgICAke29wMX1cbiAgICAgICAgICAgICAgfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhZENvZGUgPSBgXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3guaW5kaWNlc1RvT2Zmc2V0KCd4SW5kaWNlcycpfV07XG4gICAgICAgICAgICAgICR7b3AxfVxuICAgICAgICAgICAgYDtcbiAgICB9XG4gICAgY29uc3QgcG9vbGluZ0NvZGUgPSBgXG4gICAgICAgICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKHgsIG91dHB1dCl9XG5cbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRTaXplJyl9XG4gICAgICAgICAgICAgIGxldCBpbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgICAgICAgICAgICB2YXIgeEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG5cbiAgICAgICAgICAgICAgdmFyIG9mZnNldHM6IGFycmF5PHUzMiwgJHtzdHJpZGVzUmFua30+O1xuXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR7ZGF0YVR5cGV9KCR7c3RhcnR9KTtcbiAgICAgICAgICAgICAgdmFyIHBhZCA9IDA7XG4gICAgICAgICAgICAgIHZhciBpc1BhZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgdW5pZm9ybXMua2VybmVsU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDB1OyBqIDwgJHtzdHJpZGVzUmFuayAtIDF9dTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICBvZmZzZXRzW2pdID0gb2Zmc2V0IC8gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLmtlcm5lbFN0cmlkZXMnLCAnaicsIHN0cmlkZXNSYW5rKX07XG4gICAgICAgICAgICAgICAgICBvZmZzZXQgLT0gb2Zmc2V0c1tqXSAqICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5rZXJuZWxTdHJpZGVzJywgJ2onLCBzdHJpZGVzUmFuayl9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXRzWyR7c3RyaWRlc1JhbmsgLSAxfV0gPSBvZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICBpc1BhZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAke3JhbmsgLSBzdHJpZGVzUmFua311OyBqIDwgJHtyYW5rfXU7IGorKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbal0gPSBpbmRpY2VzW2pdICogJHtcbiAgICAgICAgZ2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5zdHJpZGVzJywgYGogLSAke3JhbmsgLSBzdHJpZGVzUmFua311YCwgc3RyaWRlc1JhbmspfVxuICAgICAgICAgICAgICAgICAgICArIG9mZnNldHNbaiAtICR7cmFuayAtIHN0cmlkZXNSYW5rfXVdIC0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnBhZHMnLCAnaiAtIDJ1JywgcGFkc1JhbmspfTtcbiAgICAgICAgICAgICAgICAgICR7cGFkQ29kZX1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAke29wMn1cblxuICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1gO1xuICAgIHJldHVybiBwb29saW5nQ29kZTtcbiAgfVxufTtcblxuZXhwb3J0IGludGVyZmFjZSBGb3JtYXRBdHRyaWJ1dGVzIHtcbiAgcmVhZG9ubHkgZm9ybWF0OiAnTkhXQyd8J05DSFcnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBvb2xDb21tb25BdHRyaWJ1dGVzIGV4dGVuZHMgRm9ybWF0QXR0cmlidXRlcyB7XG4gIHJlYWRvbmx5IGF1dG9QYWQ6IHN0cmluZztcbiAgcmVhZG9ubHkgY2VpbE1vZGU6IG51bWJlcjtcbiAgcmVhZG9ubHkga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXTtcbiAgcmVhZG9ubHkgcGFkczogcmVhZG9ubHkgbnVtYmVyW107XG59XG5cbmNvbnN0IGNyZWF0ZVNoYWRlcktleUZyb21BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFBvb2xDb21tb25BdHRyaWJ1dGVzKTogc3RyaW5nID0+XG4gICAgKGAke2F0dHJpYnV0ZXMuZm9ybWF0fTske2F0dHJpYnV0ZXMuY2VpbE1vZGV9OyR7YXR0cmlidXRlcy5hdXRvUGFkfTske2F0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RofWApO1xuXG5jb25zdCBjcmVhdGVBdmVyYWdlUG9vbFNoYWRlcktleUZyb21BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IEF2ZXJhZ2VQb29sQXR0cmlidXRlcyk6IHN0cmluZyA9PlxuICAgIChgJHtjcmVhdGVTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyhhdHRyaWJ1dGVzKX07JHthdHRyaWJ1dGVzLmNvdW50SW5jbHVkZVBhZH1gKTtcblxuY29uc3QgY3JlYXRlTWF4UG9vbFNoYWRlcktleUZyb21BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IE1heFBvb2xBdHRyaWJ1dGVzKTogc3RyaW5nID0+XG4gICAgKGAke2NyZWF0ZVNoYWRlcktleUZyb21BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpfTske2F0dHJpYnV0ZXMuc3RvcmFnZU9yZGVyfTske2F0dHJpYnV0ZXMuZGlsYXRpb25zfWApO1xuXG5jb25zdCBwYXJzZVBvb2xDb21tb25BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogUG9vbENvbW1vbkF0dHJpYnV0ZXMgPT4gKHtcbiAgZm9ybWF0OiBhdHRyaWJ1dGVzLmZvcm1hdCBhcyBGb3JtYXRBdHRyaWJ1dGVzWydmb3JtYXQnXSxcbiAgYXV0b1BhZDogWydOT1RTRVQnLCAnVkFMSUQnLCAnU0FNRV9VUFBFUicsICdTQU1FX0xPV0VSJ11bYXR0cmlidXRlcy5hdXRvX3BhZCBhcyBudW1iZXJdLFxuICBjZWlsTW9kZTogYXR0cmlidXRlcy5jZWlsX21vZGUgYXMgbnVtYmVyLFxuICBrZXJuZWxTaGFwZTogYXR0cmlidXRlcy5rZXJuZWxfc2hhcGUgYXMgW251bWJlciwgbnVtYmVyXSxcbiAgc3RyaWRlczogYXR0cmlidXRlcy5zdHJpZGVzIGFzIFtudW1iZXIsIG51bWJlcl0sXG4gIHBhZHM6IGF0dHJpYnV0ZXMucGFkcyBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXVxufSk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXZlcmFnZVBvb2xBdHRyaWJ1dGVzIGV4dGVuZHMgUG9vbENvbW1vbkF0dHJpYnV0ZXMsIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGNvdW50SW5jbHVkZVBhZDogYm9vbGVhbjtcbn1cblxuY29uc3QgY3JlYXRlQXZlcmFnZVBvb2xQcm9ncmFtSW5mbyA9XG4gICAgKG5hbWU6IHN0cmluZywgaW5wdXQ6IFRlbnNvclZpZXcsIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sIGF0dHJpYnV0ZXM6IEF2ZXJhZ2VQb29sQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgICAgIGNvbnN0IFthZGp1c3RlZEF0dHJpYnV0ZXMsIG91dHB1dFNoYXBlXSA9XG4gICAgICAgICAgZ2V0QWRqdXN0ZWRQb29sQXR0cmlidXRlc0FuZE91dHB1dFNoYXBlKGlucHV0LCBhdHRyaWJ1dGVzLCBpc0dsb2JhbE9wZXJhdG9yKTtcbiAgICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXQuZGF0YVR5cGUsIGlucHV0LmRpbXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGRhdGFUeXBlID0geC50eXBlLnZhbHVlO1xuXG4gICAgICBjb25zdCBvcDEgPSAndmFsdWUgKz0geF92YWw7JztcbiAgICAgIGxldCBvcDIgPSAnJztcbiAgICAgIGlmIChhZGp1c3RlZEF0dHJpYnV0ZXMuY291bnRJbmNsdWRlUGFkKSB7XG4gICAgICAgIG9wMiArPSBgdmFsdWUgLz0gJHtkYXRhVHlwZX0odW5pZm9ybXMua2VybmVsU2l6ZSk7YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wMiArPSBgdmFsdWUgLz0gJHtkYXRhVHlwZX0oaTMyKHVuaWZvcm1zLmtlcm5lbFNpemUpIC0gcGFkKTtgO1xuICAgICAgfVxuICAgICAgY29uc3QgW3Byb2dyYW1Vbmlmb3JtcywgdW5pZm9ybXMsIGhhc1BhZHMsIHB3U3RhcnRFbmROb3RaZXJvLCBwaFN0YXJ0RW5kTm90WmVyb10gPVxuICAgICAgICAgIGdldFVuaWZvcm1BbmRQYWRJbmZvKG91dHB1dFNoYXBlLCBhZGp1c3RlZEF0dHJpYnV0ZXMpO1xuICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXQuZGltcywgb3V0cHV0U2hhcGUpKTtcbiAgICAgIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWydyYW5rJ107XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lLFxuICAgICAgICBzaGFkZXJDYWNoZTpcbiAgICAgICAgICAgIHtoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fTske2hhc1BhZHN9OyR7cHdTdGFydEVuZE5vdFplcm99OyR7cGhTdGFydEVuZE5vdFplcm99YCwgaW5wdXREZXBlbmRlbmNpZXN9LFxuICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICAgIG91dHB1dHM6IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dC5kYXRhVHlwZX1dLFxuICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHt4OiBNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfSxcbiAgICAgICAgICBwcm9ncmFtVW5pZm9ybXNcbiAgICAgICAgfSksXG4gICAgICAgIGdldFNoYWRlclNvdXJjZTogc2hhZGVySGVscGVyID0+IGdlbmVyYXRlUG9vbGluZ0NvZGUoXG4gICAgICAgICAgICBzaGFkZXJIZWxwZXIsIHgsIGlucHV0LmRpbXMubGVuZ3RoLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGFkanVzdGVkQXR0cmlidXRlcywgb3AxLCBvcDIsIDAuMCwgdW5pZm9ybXMsXG4gICAgICAgICAgICBoYXNQYWRzLCBwd1N0YXJ0RW5kTm90WmVybywgcGhTdGFydEVuZE5vdFplcm8pLFxuICAgICAgfTtcbiAgICB9O1xuXG5leHBvcnQgY29uc3QgcGFyc2VBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBjb3VudEluY2x1ZGVQYWQgPSAoYXR0cmlidXRlcy5jb3VudF9pbmNsdWRlX3BhZCBhcyBudW1iZXIpID09PSAwID8gZmFsc2UgOiB0cnVlO1xuXG4gIGNvbnN0IGF0dHIgPSBwYXJzZVBvb2xDb21tb25BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xuICAvLyBUT0RPOiBzdXBwb3J0IGF0dHJpYnV0ZSAnY2VpbF9tb2RlJ1xuICBpZiAoYXR0ci5jZWlsTW9kZSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNpbmcgY2VpbCgpIGluIHNoYXBlIGNvbXB1dGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBBdmVyYWdlUG9vbCcpO1xuICB9XG4gIGNvbnN0IGF2ZXJhZ2VQb29sQXR0cmlidXRlcyA9IHtjb3VudEluY2x1ZGVQYWQsIC4uLmF0dHIsIGNhY2hlS2V5OiAnJ307XG4gIHJldHVybiB7Li4uYXZlcmFnZVBvb2xBdHRyaWJ1dGVzLCBjYWNoZUtleTogY3JlYXRlQXZlcmFnZVBvb2xTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyhhdmVyYWdlUG9vbEF0dHJpYnV0ZXMpfTtcbn07XG5cbmV4cG9ydCBjb25zdCBhdmVyYWdlUG9vbCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQXZlcmFnZVBvb2xBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUF2ZXJhZ2VQb29sUHJvZ3JhbUluZm8oJ0F2ZXJhZ2VQb29sJywgY29udGV4dC5pbnB1dHNbMF0sIGZhbHNlLCBhdHRyaWJ1dGVzKSk7XG59O1xuXG5jb25zdCBnbG9iYWxQb29sQXR0cmlidXRlcyA9IHtcbiAgYXV0b1BhZDogJycsXG4gIGNlaWxNb2RlOiAwLFxuICBjb3VudEluY2x1ZGVQYWQ6IGZhbHNlLFxuICBrZXJuZWxTaGFwZTogW10sXG4gIHN0cmlkZXM6IFtdLFxuICBwYWRzOiBbXSxcbiAgc3RvcmFnZU9yZGVyOiAwLFxuICBkaWxhdGlvbnM6IFtdXG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VHbG9iYWxBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBmb3JtYXQgPSBhdHRyaWJ1dGVzLmZvcm1hdCBhcyBGb3JtYXRBdHRyaWJ1dGVzWydmb3JtYXQnXTtcbiAgcmV0dXJuIHtmb3JtYXQsIC4uLmdsb2JhbFBvb2xBdHRyaWJ1dGVzLCBjYWNoZUtleTogZm9ybWF0fTtcbn07XG5cbmV4cG9ydCBjb25zdCBnbG9iYWxBdmVyYWdlUG9vbCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQXZlcmFnZVBvb2xBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUF2ZXJhZ2VQb29sUHJvZ3JhbUluZm8oJ0dsb2JhbEF2ZXJhZ2VQb29sJywgY29udGV4dC5pbnB1dHNbMF0sIHRydWUsIGF0dHJpYnV0ZXMpKTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWF4UG9vbEF0dHJpYnV0ZXMgZXh0ZW5kcyBQb29sQ29tbW9uQXR0cmlidXRlcywgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgc3RvcmFnZU9yZGVyOiBudW1iZXI7XG4gIHJlYWRvbmx5IGRpbGF0aW9uczogbnVtYmVyW107XG59XG5cbmNvbnN0IGNyZWF0ZU1heFBvb2xQcm9ncmFtSW5mbyA9XG4gICAgKG5hbWU6IHN0cmluZywgaW5wdXQ6IFRlbnNvclZpZXcsIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sIGF0dHJpYnV0ZXM6IE1heFBvb2xBdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgW2FkanVzdGVkQXR0cmlidXRlcywgb3V0cHV0U2hhcGVdID1cbiAgICAgICAgICBnZXRBZGp1c3RlZFBvb2xBdHRyaWJ1dGVzQW5kT3V0cHV0U2hhcGUoaW5wdXQsIGF0dHJpYnV0ZXMsIGlzR2xvYmFsT3BlcmF0b3IpO1xuICAgICAgY29uc3Qgb3AxID0gYFxuICAgICAgdmFsdWUgPSBtYXgoeF92YWwsIHZhbHVlKTtcbiAgICBgO1xuICAgICAgY29uc3Qgb3AyID0gJyc7XG4gICAgICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0LmRhdGFUeXBlLCBpbnB1dC5kaW1zLmxlbmd0aCk7XG4gICAgICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuayddO1xuICAgICAgY29uc3QgW3Byb2dyYW1Vbmlmb3JtcywgdW5pZm9ybXMsIGhhc1BhZHMsIHB3U3RhcnRFbmROb3RaZXJvLCBwaFN0YXJ0RW5kTm90WmVyb10gPVxuICAgICAgICAgIGdldFVuaWZvcm1BbmRQYWRJbmZvKG91dHB1dFNoYXBlLCBhZGp1c3RlZEF0dHJpYnV0ZXMpO1xuICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXQuZGltcywgb3V0cHV0U2hhcGUpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHNoYWRlckNhY2hlOlxuICAgICAgICAgICAge2hpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9OyR7aGFzUGFkc307JHtwd1N0YXJ0RW5kTm90WmVyb307JHtwaFN0YXJ0RW5kTm90WmVyb31gLCBpbnB1dERlcGVuZGVuY2llc30sXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0LmRhdGFUeXBlfV0sXG4gICAgICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgICAgIHByb2dyYW1Vbmlmb3Jtc1xuICAgICAgICB9KSxcbiAgICAgICAgZ2V0U2hhZGVyU291cmNlOiBzaGFkZXJIZWxwZXIgPT4gZ2VuZXJhdGVQb29saW5nQ29kZShcbiAgICAgICAgICAgIHNoYWRlckhlbHBlciwgeCwgaW5wdXQuZGltcy5sZW5ndGgsIG91dHB1dFNoYXBlLmxlbmd0aCwgYWRqdXN0ZWRBdHRyaWJ1dGVzLCBvcDEsIG9wMixcbiAgICAgICAgICAgIChpbnB1dC5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuZmxvYXQxNikgPyAtNjU1MDQgOiAtMWU1LCB1bmlmb3JtcywgaGFzUGFkcywgcHdTdGFydEVuZE5vdFplcm8sXG4gICAgICAgICAgICBwaFN0YXJ0RW5kTm90WmVybyksXG4gICAgICB9O1xuICAgIH07XG5cbmV4cG9ydCBjb25zdCBtYXhQb29sID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBNYXhQb29sQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVNYXhQb29sUHJvZ3JhbUluZm8oJ01heFBvb2wnLCBjb250ZXh0LmlucHV0c1swXSwgZmFsc2UsIGF0dHJpYnV0ZXMpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZU1heFBvb2xBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogTWF4UG9vbEF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBzdG9yYWdlT3JkZXIgPSBhdHRyaWJ1dGVzLnN0b3JhZ2Vfb3JkZXIgYXMgbnVtYmVyO1xuICBjb25zdCBkaWxhdGlvbnMgPSBhdHRyaWJ1dGVzLmRpbGF0aW9ucyBhcyBbbnVtYmVyLCBudW1iZXJdO1xuXG4gIGNvbnN0IGF0dHIgPSBwYXJzZVBvb2xDb21tb25BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xuICAvLyBUT0RPOiBzdXBwb3J0IGF0dHJpYnV0ZSAnY2VpbF9tb2RlJyBhbmQgJ3N0b3JhZ2Vfb3JkZXInXG4gIGlmIChzdG9yYWdlT3JkZXIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbHVtbiBtYWpvciBzdG9yYWdlIG9yZGVyIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sJyk7XG4gIH1cbiAgaWYgKGF0dHIuY2VpbE1vZGUgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbCcpO1xuICB9XG4gIGNvbnN0IG1heFBvb2xBdHRyaWJ1dGVzID0ge3N0b3JhZ2VPcmRlciwgZGlsYXRpb25zLCAuLi5hdHRyLCBjYWNoZUtleTogJyd9O1xuICByZXR1cm4gey4uLm1heFBvb2xBdHRyaWJ1dGVzLCBjYWNoZUtleTogY3JlYXRlTWF4UG9vbFNoYWRlcktleUZyb21BdHRyaWJ1dGVzKG1heFBvb2xBdHRyaWJ1dGVzKX07XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VHbG9iYWxNYXhQb29sQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IE1heFBvb2xBdHRyaWJ1dGVzID0+IHtcbiAgY29uc3QgZm9ybWF0ID0gYXR0cmlidXRlcy5mb3JtYXQgYXMgRm9ybWF0QXR0cmlidXRlc1snZm9ybWF0J107XG4gIHJldHVybiB7Zm9ybWF0LCAuLi5nbG9iYWxQb29sQXR0cmlidXRlcywgY2FjaGVLZXk6IGZvcm1hdH07XG59O1xuXG5leHBvcnQgY29uc3QgZ2xvYmFsTWF4UG9vbCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogTWF4UG9vbEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlTWF4UG9vbFByb2dyYW1JbmZvKCdHbG9iYWxNYXhQb29sJywgY29udGV4dC5pbnB1dHNbMF0sIHRydWUsIGF0dHJpYnV0ZXMpKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7ZW52fSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQge0RhdGFUeXBlfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm19IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciwgVW5pZm9ybURhdGFFbGVtZW50VHlwZSwgVW5pZm9ybXNBcnJheVR5cGV9IGZyb20gJy4vY29tbW9uJztcblxuY29uc3QgdmFsaWRhdGVJbnB1dHNDb250ZW50ID0gKHN0YXJ0OiBudW1iZXIsIGxpbWl0OiBudW1iZXIsIGRlbHRhOiBudW1iZXIpOiB2b2lkID0+IHtcbiAgY29uc3Qgc2FtZVN0YXJ0TGltaXQgPSBzdGFydCA9PT0gbGltaXQ7XG4gIGNvbnN0IGluY3JlYXNpbmdSYW5nZU5lZ2F0aXZlU3RlcCA9IHN0YXJ0IDwgbGltaXQgJiYgZGVsdGEgPCAwO1xuICBjb25zdCBkZWNyZWFzaW5nUmFuZ2VQb3NpdGl2ZVN0ZXAgPSBzdGFydCA+IGxpbWl0ICYmIGRlbHRhID4gMDtcblxuICBpZiAoc2FtZVN0YXJ0TGltaXQgfHwgaW5jcmVhc2luZ1JhbmdlTmVnYXRpdmVTdGVwIHx8IGRlY3JlYXNpbmdSYW5nZVBvc2l0aXZlU3RlcCkge1xuICAgIHRocm93IG5ldyBFcnJvcignUmFuZ2UgdGhlc2UgaW5wdXRzXFwnIGNvbnRlbnRzIGFyZSBpbnZhbGlkLicpO1xuICB9XG59O1xuXG5jb25zdCBjcmVhdGVSYW5nZVByb2dyYW1JbmZvID0gKHN0YXJ0OiBudW1iZXIsIGxpbWl0OiBudW1iZXIsIGRlbHRhOiBudW1iZXIsIGRhdGFUeXBlOiBEYXRhVHlwZSk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgbnVtRWxlbWVudHMgPSBNYXRoLmFicyhNYXRoLmNlaWwoKGxpbWl0IC0gc3RhcnQpIC8gZGVsdGEpKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gW251bUVsZW1lbnRzXTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IG51bUVsZW1lbnRzO1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZX0sIHt0eXBlOiBkYXRhVHlwZSwgZGF0YTogc3RhcnR9LCB7dHlwZTogZGF0YVR5cGUsIGRhdGE6IGRlbHRhfSxcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZSlcbiAgXTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gICAgY29uc3Qgd2dzbFR5cGUgPSBvdXRwdXQudHlwZS52YWx1ZTtcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7bmFtZTogJ291dHB1dFNpemUnLCB0eXBlOiAndTMyJ30sIHtuYW1lOiAnc3RhcnQnLCB0eXBlOiB3Z3NsVHlwZSBhcyBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlfSxcbiAgICAgIHtuYW1lOiAnZGVsdGEnLCB0eXBlOiB3Z3NsVHlwZSBhcyBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlfVxuICAgIF07XG4gICAgcmV0dXJuIGBcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyhvdXRwdXQpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxuICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB1bmlmb3Jtcy5zdGFydCArICR7d2dzbFR5cGV9KGdsb2JhbF9pZHgpICogdW5pZm9ybXMuZGVsdGE7XG4gICAgICB9YDtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdSYW5nZScsXG4gICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBgJHtkYXRhVHlwZX1gfSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7ZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zXG4gICAgfSlcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCByYW5nZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgbGltaXQgPSAwO1xuICBsZXQgZGVsdGEgPSAwO1xuICBpZiAoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUgPT09IERhdGFUeXBlLmludDMyKSB7XG4gICAgc3RhcnQgPSBjb250ZXh0LmlucHV0c1swXS5nZXRJbnQzMkFycmF5KClbMF07XG4gICAgbGltaXQgPSBjb250ZXh0LmlucHV0c1sxXS5nZXRJbnQzMkFycmF5KClbMF07XG4gICAgZGVsdGEgPSBjb250ZXh0LmlucHV0c1syXS5nZXRJbnQzMkFycmF5KClbMF07XG4gIH0gZWxzZSBpZiAoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUgPT09IERhdGFUeXBlLmZsb2F0KSB7XG4gICAgc3RhcnQgPSBjb250ZXh0LmlucHV0c1swXS5nZXRGbG9hdDMyQXJyYXkoKVswXTtcbiAgICBsaW1pdCA9IGNvbnRleHQuaW5wdXRzWzFdLmdldEZsb2F0MzJBcnJheSgpWzBdO1xuICAgIGRlbHRhID0gY29udGV4dC5pbnB1dHNbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF07XG4gIH1cbiAgaWYgKGVudi53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQpIHtcbiAgICB2YWxpZGF0ZUlucHV0c0NvbnRlbnQoc3RhcnQsIGxpbWl0LCBkZWx0YSk7XG4gIH1cblxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlUmFuZ2VQcm9ncmFtSW5mbyhzdGFydCwgbGltaXQsIGRlbHRhLCBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSksIHtpbnB1dHM6IFtdfSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7Y3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGdldEVsZW1lbnRBdCwgSW5kaWNlc0hlbHBlciwgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlcn0gZnJvbSAnLi9jb21tb24nO1xuXG50eXBlIENvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlID0gJ2hhbGZfcGl4ZWwnfCdhc3ltbWV0cmljJ3wncHl0b3JjaF9oYWxmX3BpeGVsJ3wndGZfaGFsZl9waXhlbF9mb3Jfbm4nfCdhbGlnbl9jb3JuZXJzJ3xcbiAgICAndGZfY3JvcF9hbmRfcmVzaXplJ3wnaGFsZl9waXhlbF9zeW1tZXRyaWMnO1xuXG50eXBlIEtlZXBBc3BlY3RSYXRpb1BvbGljeSA9ICdzdHJldGNoJ3wnbm90X3NtYWxsZXInfCdub3RfbGFyZ2VyJztcblxudHlwZSBNb2RlID0gJ25lYXJlc3QnfCdsaW5lYXInfCdjdWJpYyc7XG5cbnR5cGUgTmVhcmVzdE1vZGUgPSAncm91bmRfcHJlZmVyX2Zsb29yJ3wncm91bmRfcHJlZmVyX2NlaWwnfCdmbG9vcid8J2NlaWwnfCdzaW1wbGUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlc2l6ZUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBhbnRpYWxpYXM6IG51bWJlcjtcbiAgYXhlczogbnVtYmVyW107XG4gIGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOiBDb29yZGluYXRlVHJhbnNmb3JtTW9kZTtcbiAgY3ViaWNDb2VmZkE6IG51bWJlcjtcbiAgZXhjbHVkZU91dHNpZGU6IGJvb2xlYW47XG4gIGV4dHJhcG9sYXRpb25WYWx1ZTogbnVtYmVyO1xuICBrZWVwQXNwZWN0UmF0aW9Qb2xpY3k6IEtlZXBBc3BlY3RSYXRpb1BvbGljeTtcbiAgbW9kZTogTW9kZTtcbiAgbmVhcmVzdE1vZGU6IE5lYXJlc3RNb2RlO1xufVxuXG5jb25zdCB2YWxpZGF0ZVNjYWxlcyA9IChzY2FsZXM6IG51bWJlcltdLCBhdHRyaWJ1dGVzOiBSZXNpemVBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHNjYWxlcy5ldmVyeSgodmFsdWUpID0+IHZhbHVlID4gMCB8fCAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCB2YWx1ZXMgdG8gYmUgcG9zaXRpdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAvLyBDaGVjayBzY2FsZXMgZGltcyBiYXNlZCBvbiBtb2RlOiBMSU5FQVIsIENVQklDXG4gIGlmIChzY2FsZXMubGVuZ3RoID4gMCkge1xuICAgIGlmIChhdHRyaWJ1dGVzLm1vZGUgPT09ICdsaW5lYXInKSB7XG4gICAgICBpZiAoIShzY2FsZXMubGVuZ3RoID09PSAyIHx8IHNjYWxlcy5sZW5ndGggPT09IDMgfHwgKHNjYWxlcy5sZW5ndGggPT09IDQgJiYgc2NhbGVzWzBdID09PSAxICYmIHNjYWxlc1sxXSA9PT0gMSkgfHxcbiAgICAgICAgICAgIChzY2FsZXMubGVuZ3RoID09PSA0ICYmIHNjYWxlc1swXSA9PT0gMSAmJiBzY2FsZXNbM10gPT09IDEpIHx8XG4gICAgICAgICAgICAoc2NhbGVzLmxlbmd0aCA9PT0gNSAmJiBzY2FsZXNbMF0gPT09IDEgJiYgc2NhbGVzWzFdID09PSAxKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEZvciBsaW5lYXIgbW9kZSwgUmVzaXplIHJlcXVpcmVzIHNjYWxlcyB0byBiZSAyRCwgM0QsIDREIHdpdGggZWl0aGVyIHR3byBvdXRlcm1vc3Qgb3Igb25lIGlubmVybW9zdCBhbmRcbiAgICAgICAgICAgIG9uZSBvdXRlcm1vc3Qgc2NhbGUgdmFsdWVzIGVxdWFsIHRvIDEsIG9yIDVEIHdpdGggdHdvIG91dGVybW9zdCBzY2FsZSB2YWx1ZXMgZXF1YWwgdG8gMWApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXR0cmlidXRlcy5tb2RlID09PSAnY3ViaWMnKSB7XG4gICAgICBpZiAoIShzY2FsZXMubGVuZ3RoID09PSAyIHx8IChzY2FsZXMubGVuZ3RoID09PSA0ICYmIHNjYWxlc1swXSA9PT0gMSAmJiBzY2FsZXNbMV0gPT09IDEpIHx8XG4gICAgICAgICAgICAoc2NhbGVzLmxlbmd0aCA9PT0gNCAmJiBzY2FsZXNbMF0gPT09IDEgJiYgc2NhbGVzWzNdID09PSAxKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgc2NhbGVzIGlucHV0IHNpemUgdG8gYmUgMiBvciA0IGZvciBjdWJpYyBtb2RlJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCB1cGRhdGVTY2FsZXMgPSAoc2NhbGVzOiByZWFkb25seSBudW1iZXJbXSwgYXhlczogcmVhZG9ubHkgbnVtYmVyW10sIHJhbms6IG51bWJlcik6IG51bWJlcltdID0+IHtcbiAgYXhlcy5ldmVyeSgodmFsdWUpID0+IHZhbHVlID49IDAgJiYgdmFsdWUgPCByYW5rIHx8ICgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIGF4ZXMgaW5wdXQgdmFsdWVzIHRvIGJlIHBvc2l0aXZlIGFuZCBsZXNzIHRoYW4gcmFuaycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICBjb25zdCBuZXdTY2FsZXMgPSBuZXcgQXJyYXkocmFuaykuZmlsbCgxLjApO1xuICBheGVzLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4gbmV3U2NhbGVzW3ZhbHVlXSA9IHNjYWxlc1tpbmRleF0pO1xuICByZXR1cm4gbmV3U2NhbGVzO1xufTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPVxuICAgIChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogUmVzaXplQXR0cmlidXRlcywgb3BzZXRWZXJzaW9uOiBudW1iZXIsIHNjYWxlczogbnVtYmVyW10sXG4gICAgIHNpemVzOiBudW1iZXJbXSwgcm9pOiBudW1iZXJbXSk6IHZvaWQgPT4ge1xuICAgICAgY29uc3QgW3JvaUlucHV0SW5kZXgsIHNjYWxlc0lucHV0SW5kZXgsIHNpemVzSW5wdXRJbmRleF0gPVxuICAgICAgICAgIChvcHNldFZlcnNpb24gPiAxMCkgPyBbMSwgMiwgM10gOiBbLTEsIChpbnB1dHMubGVuZ3RoID4gMSkgPyAxIDogLTEsIC0xXTtcbiAgICAgIGNvbnN0IHJhbmsgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGg7XG4gICAgICBpZiAocm9pSW5wdXRJbmRleCA+IDAgJiYgaW5wdXRzLmxlbmd0aCA+IHJvaUlucHV0SW5kZXggJiYgaW5wdXRzW3JvaUlucHV0SW5kZXhdLmRpbXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpbnB1dHNbcm9pSW5wdXRJbmRleF0uZ2V0RmxvYXQzMkFycmF5KCkuZm9yRWFjaCgodmFsdWUpID0+IHJvaS5wdXNoKHZhbHVlKSk7XG4gICAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXMuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUgPT09ICd0Zl9jcm9wX2FuZF9yZXNpemUnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIFJvSSBpbnB1dCB0byBiZSBzcGVjaWZpZWQgd2hlbiBjb29yZGluYXRlVHJhbnNmb3JtTW9kZSBpcyB0ZkNyb3BBbmRSZXNpemUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNjYWxlc0lucHV0SW5kZXggPiAwICYmIGlucHV0cy5sZW5ndGggPiBzY2FsZXNJbnB1dEluZGV4ICYmIGlucHV0c1tzY2FsZXNJbnB1dEluZGV4XS5kaW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaW5wdXRzW3NjYWxlc0lucHV0SW5kZXhdLmdldEZsb2F0MzJBcnJheSgpLmZvckVhY2goKHZhbHVlKSA9PiBzY2FsZXMucHVzaCh2YWx1ZSkpO1xuICAgICAgICBpZiAoc2NhbGVzLmxlbmd0aCAhPT0gMCAmJlxuICAgICAgICAgICAgKHNjYWxlcy5sZW5ndGggIT09IHJhbmsgJiYgKG9wc2V0VmVyc2lvbiA+PSAxOCAmJiBzY2FsZXMubGVuZ3RoICE9PSBhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoKSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICdSZXNpemUgcmVxdWlyZXMgc2NhbGVzIGlucHV0IHNpemUgdG8gYmUgc2FtZSBhcyBpbnB1dCByYW5rIG9yIGF4ZXMgc2l6ZSBmb3Igb3BzZXQgMTggYW5kIHVwJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVTY2FsZXMoc2NhbGVzLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdXBkYXRlU2NhbGVzKHNjYWxlcywgYXR0cmlidXRlcy5heGVzLCByYW5rKS5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHNjYWxlc1tpbmRleF0gPSB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzaXplc0lucHV0SW5kZXggPiAwICYmIGlucHV0cy5sZW5ndGggPiBzaXplc0lucHV0SW5kZXgpIHtcbiAgICAgICAgaW5wdXRzW3NpemVzSW5wdXRJbmRleF0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2goKHZhbHVlKSA9PiBzaXplcy5wdXNoKE51bWJlcih2YWx1ZSkpKTtcbiAgICAgICAgaWYgKHNpemVzLmxlbmd0aCAhPT0gcmFuayB8fCAob3BzZXRWZXJzaW9uID49IDE4ICYmIHNpemVzLmxlbmd0aCA9PT0gYXR0cmlidXRlcy5heGVzLmxlbmd0aCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBzaXplcyBpbnB1dCBzaXplIHRvIGJlIHNhbWUgYXMgaW5wdXQgcmFuayBvciBheGVzIHNpemUgZm9yIG9wc2V0IDE4IGFuZCB1cCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoc2NhbGVzLmxlbmd0aCAhPT0gYXR0cmlidXRlcy5heGVzLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIFwic2NhbGVzXCIgaW5wdXQgc2l6ZSB0byBiZSBvZiBheGVzIHJhbmsgd2hlbiBheGVzIGF0dHJpYnV0ZXMgaXMgc3BlY2lmaWVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpemVzLmxlbmd0aCAhPT0gYXR0cmlidXRlcy5heGVzLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgJ1Jlc2l6ZSByZXF1aXJlcyBcInNpemVzXCIgaW5wdXQgc2l6ZSB0byBiZSBvZiByYW5rIGF4ZXMgcmFuayB3aGVuIGF4ZXMgYXR0cmlidXRlcyBpcyBzcGVjaWZpZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzY2FsZXMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBzaXplcyAhPT0gJ3VuZGVmaW5lZCcgJiYgc2NhbGVzLmxlbmd0aCA+IDAgJiYgc2l6ZXMubGVuZ3RoID4gcmFuaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBvbmx5IG9mIHNjYWxlcyBvciBzaXplcyB0byBiZSBzcGVjaWZpZWQnKTtcbiAgICAgIH1cbiAgICB9O1xuXG5jb25zdCBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUgPVxuICAgIChjb29yZGluYXRlVHJhbnNmZXJNb2RlOiBDb29yZGluYXRlVHJhbnNmb3JtTW9kZSwgZFR5cGU6IHN0cmluZyk6IHN0cmluZyA9PlxuICAgICAgICBgZm4gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKHhSZXNpemVkOiB1MzIsIHhTY2FsZTogZjMyLCBsZW5ndGhSZXNpemVkOiB1MzIsXG4gICAgIGxlbmd0aE9yaWdpbmFsOiB1MzIsIHJvaVN0YXJ0OiBmMzIsIHJvaUVuZDogZjMyKSAtPiAke2RUeXBlfSB7IGAgK1xuICAgICgoKSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChjb29yZGluYXRlVHJhbnNmZXJNb2RlKSB7XG4gICAgICAgICAgICBjYXNlICdhc3ltbWV0cmljJzpcbiAgICAgICAgICAgICAgcmV0dXJuIGByZXR1cm4gJHtkVHlwZX0oeFJlc2l6ZWQpIC8gJHtkVHlwZX0oeFNjYWxlKTtgO1xuICAgICAgICAgICAgY2FzZSAncHl0b3JjaF9oYWxmX3BpeGVsJzpcbiAgICAgICAgICAgICAgcmV0dXJuIGBpZiAobGVuZ3RoUmVzaXplZCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgke2RUeXBlfSh4UmVzaXplZCkgKyAwLjUpIC8gJHtkVHlwZX0oeFNjYWxlKSAtIDAuNTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgICAgICAgICAgICB9YDtcbiAgICAgICAgICAgIGNhc2UgJ3RmX2hhbGZfcGl4ZWxfZm9yX25uJzpcbiAgICAgICAgICAgICAgcmV0dXJuIGByZXR1cm4gKCR7ZFR5cGV9KHhSZXNpemVkKSArIDAuNSkgLyAke2RUeXBlfSh4U2NhbGUpO2A7XG4gICAgICAgICAgICBjYXNlICdhbGlnbl9jb3JuZXJzJzpcbiAgICAgICAgICAgICAgcmV0dXJuIGBpZiAobGVuZ3RoUmVzaXplZCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgd2hvbGUgcGFydCBhbmQgdGhlIGZyYWN0aW9uYWwgcGFydCBhcmUgY2FsY3VsYXRlZCBzZXBhcmF0ZWx5IGR1ZSB0byBpbmFjY3VyYWN5IG9mIGZsb2F0aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIHBvaW50IGRpdmlzaW9uLiBBcyBhbiBleGFtcGxlLCBmMzIoMjEpIC8gZjMyKDcpIG1heSBldmFsdWF0ZSB0byAyLjk5Li4uIGluc3RlYWQgb2YgMywgY2F1c2luZyBhblxuICAgICAgICAgICAgICAgICAgICAvLyBvZmZzZXQtYnktb25lIGVycm9yIGxhdGVyIGluIGZsb29yKCkuXG4gICAgICAgICAgICAgICAgICAgIGxldCB3aG9sZSA9ICR7ZFR5cGV9KHhSZXNpemVkICogKGxlbmd0aE9yaWdpbmFsIC0gMSkgLyAobGVuZ3RoUmVzaXplZCAtIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZyYWN0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICR7ZFR5cGV9KHhSZXNpemVkICogKGxlbmd0aE9yaWdpbmFsIC0gMSkgJSAobGVuZ3RoUmVzaXplZCAtIDEpKSAvICR7ZFR5cGV9KGxlbmd0aFJlc2l6ZWQgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdob2xlICsgZnJhY3Q7XG4gICAgICAgICAgICAgICAgICB9YDtcbiAgICAgICAgICAgIGNhc2UgJ3RmX2Nyb3BfYW5kX3Jlc2l6ZSc6XG4gICAgICAgICAgICAgIHJldHVybiBgaWYgKGxlbmd0aFJlc2l6ZWQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAke2RUeXBlfShyb2lTdGFydCkgKiAke2RUeXBlfShsZW5ndGhPcmlnaW5hbCAtIDEpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICgke2RUeXBlfSh4UmVzaXplZCkgKiAke2RUeXBlfShyb2lFbmQgLSByb2lTdGFydCkgKiAke2RUeXBlfShsZW5ndGhPcmlnaW5hbCAtIDEpKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAke2RUeXBlfShsZW5ndGhSZXNpemVkIC0gMSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogJHtkVHlwZX0ocm9pU3RhcnQgKyByb2lFbmQpICogJHtkVHlwZX0obGVuZ3RoT3JpZ2luYWwgLSAxKTtcbiAgICAgICAgICAgICAgICAgIH1gO1xuICAgICAgICAgICAgY2FzZSAnaGFsZl9waXhlbF9zeW1tZXRyaWMnOlxuICAgICAgICAgICAgICByZXR1cm4gYGNvbnN0IG91dHB1dFdpZHRoID0gJHtkVHlwZX14U2NhbGUgKiAke2RUeXBlfShsZW5ndGhSZXNpemVkKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGFkanVzdG1lbnQgPSAke2RUeXBlfShsZW5ndGhSZXNpemVkKSAvIG91dHB1dFdpZHRoO1xuICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyID0gJHtkVHlwZX0obGVuZ3RoT3JpZ2luYWwpIC8gMjtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGNlbnRlciAqICgxIC0gYWRqdXN0bWVudCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0ICsgKCgke2RUeXBlfSh4UmVzaXplZCkgKyAwLjUpIC8gJHtkVHlwZX0oeFNjYWxlKSkgLSAwLjU7YDtcbiAgICAgICAgICAgIGNhc2UgJ2hhbGZfcGl4ZWwnOlxuICAgICAgICAgICAgICByZXR1cm4gYHJldHVybiAoKCR7ZFR5cGV9KHhSZXNpemVkKSArIDAuNSkgLyAke2RUeXBlfSh4U2NhbGUpKSAtIDAuNTtgO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb29yZGluYXRlIHRyYW5zZm9ybSBtb2RlICR7Y29vcmRpbmF0ZVRyYW5zZmVyTW9kZX0gaXMgbm90IHN1cHBvcnRlZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKSArXG4gICAgJ30nO1xuXG5jb25zdCBnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwgPSAobmVhcmVzdE1vZGU6IE5lYXJlc3RNb2RlLCBvcHNldFZlcnNpb246IG51bWJlciwgZFR5cGU6IHN0cmluZyk6IHN0cmluZyA9PlxuICAgIGBmbiBnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwoeE9yaWdpbmFsOiAke2RUeXBlfSwgaXNEb3duU2FtcGxlOiBib29sKSAtPiAke2RUeXBlfSB7YCArICgoKSA9PiB7XG4gICAgICBzd2l0Y2ggKG5lYXJlc3RNb2RlKSB7XG4gICAgICAgIGNhc2UgJ3JvdW5kX3ByZWZlcl9jZWlsJzpcbiAgICAgICAgICByZXR1cm4gJ2lmIChmcmFjdCh4T3JpZ2luYWwpID09IDAuNSkgeyBcXFxuICAgICAgICAgICAgcmV0dXJuIGNlaWwoeE9yaWdpbmFsKTsgXFxcbiAgICAgICAgICB9IGVsc2UgeyBcXFxuICAgICAgICAgICAgcmV0dXJuIHJvdW5kKHhPcmlnaW5hbCk7IFxcXG4gICAgICAgICAgfSc7XG4gICAgICAgIGNhc2UgJ2Zsb29yJzpcbiAgICAgICAgICByZXR1cm4gJ3JldHVybiBmbG9vcih4T3JpZ2luYWwpOyc7XG4gICAgICAgIGNhc2UgJ2NlaWwnOlxuICAgICAgICAgIHJldHVybiAncmV0dXJuIGNlaWwoeE9yaWdpbmFsKTsnO1xuICAgICAgICBjYXNlICdyb3VuZF9wcmVmZXJfZmxvb3InOlxuICAgICAgICAgIHJldHVybiAnaWYgKGZyYWN0KHhPcmlnaW5hbCkgPT0gMC41KSB7IFxcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbG9vcih4T3JpZ2luYWwpOyBcXFxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvdW5kKHhPcmlnaW5hbCk7IFxcXG4gICAgICAgICAgICAgICAgICB9JztcbiAgICAgICAgY2FzZSAnc2ltcGxlJzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAob3BzZXRWZXJzaW9uIDwgMTEpIHtcbiAgICAgICAgICAgIHJldHVybiAnaWYgKGlzRG93blNhbXBsZSkgXFxcbiAgICAgICAgICAgICAgICAgICAgeyBcXFxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjZWlsKHhPcmlnaW5hbCk7IFxcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IFxcXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhPcmlnaW5hbDsgXFxcbiAgICAgICAgICAgICAgICAgICAgfSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTmVhcmVzdCBtb2RlICR7bmVhcmVzdE1vZGV9IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgIH1cbiAgICB9KSgpICtcbiAgICAnfSc7XG5cbmNvbnN0IHVwZGF0ZVJvSSA9IChyb2k6IHJlYWRvbmx5IG51bWJlcltdLCBheGVzOiByZWFkb25seSBudW1iZXJbXSwgcmFuazogbnVtYmVyKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCByb2lUbXAgPSBuZXcgQXJyYXkocmFuaykuZmlsbCgwKS5jb25jYXQobmV3IEFycmF5KHJhbmspLmZpbGwoMSkpO1xuICBjb25zdCByb2lMb2NhbCA9IHJvaS5sZW5ndGggPT09IDAgPyByb2lUbXAgOiByb2kuc2xpY2UoKTtcbiAgaWYgKGF4ZXMubGVuZ3RoID4gMCkge1xuICAgIGF4ZXMuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgcm9pVG1wW3ZdID0gcm9pTG9jYWxbaV07XG4gICAgICByb2lUbXBbaSArIHJhbmtdID0gcm9pTG9jYWxbYXhlcy5sZW5ndGggKyBpXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcm9pVG1wO1xuICB9XG4gIHJldHVybiByb2lMb2NhbDtcbn07XG5cbmNvbnN0IGluaXRPdXRwdXRTaGFwZSA9XG4gICAgKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBzY2FsZXM6IHJlYWRvbmx5IG51bWJlcltdLCBzaXplczogcmVhZG9ubHkgbnVtYmVyW10sIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdKTpcbiAgICAgICAgbnVtYmVyW10gPT4ge1xuICAgICAgICAgIGxldCBvdXRwdXRTaGFwZTogbnVtYmVyW10gPSBbXTtcbiAgICAgICAgICBpZiAoc2l6ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKGF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBpbnB1dFNoYXBlLmZvckVhY2goKHYpID0+IG91dHB1dFNoYXBlLnB1c2godikpO1xuICAgICAgICAgICAgICBpZiAoTWF0aC5tYXgoLi4uYXhlcykgPiBpbnB1dFNoYXBlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXhlcyBpcyBvdXQgb2YgYm91bmQnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBheGVzLmZvckVhY2goKHYsIGkpID0+IG91dHB1dFNoYXBlW3ZdID0gc2l6ZXNbaV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2l6ZXMuZm9yRWFjaCgodikgPT4gb3V0cHV0U2hhcGUucHVzaCh2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzY2FsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIGVpdGhlciBzY2FsZXMgb3Igc2l6ZXMuJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUubWFwKCh2YWx1ZSwgaW5kZXgpID0+IE1hdGgucm91bmQodmFsdWUgKiBzY2FsZXNbaW5kZXhdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvdXRwdXRTaGFwZTtcbiAgICAgICAgfTtcblxuY29uc3QgYWRqdXN0T3V0cHV0U2hhcGUgPSAoaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHNjYWxlczogbnVtYmVyW10sIGF0dHJpYnV0ZXM6IFJlc2l6ZUF0dHJpYnV0ZXMpID0+IHtcbiAgY29uc3Qgc2NhbGVJblBvbGljeSA9ICgoKSA9PiB7XG4gICAgc3dpdGNoIChhdHRyaWJ1dGVzLmtlZXBBc3BlY3RSYXRpb1BvbGljeSkge1xuICAgICAgY2FzZSAnbm90X2xhcmdlcic6XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoID4gMCA/IE1hdGgubWluKC4uLmF0dHJpYnV0ZXMuYXhlcy5tYXAoaSA9PiBzY2FsZXNbaV0pLCBOdW1iZXIuTUFYX1ZBTFVFKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKC4uLnNjYWxlcywgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgICBjYXNlICdub3Rfc21hbGxlcic6XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoID4gMCA/IE1hdGgubWF4KC4uLmF0dHJpYnV0ZXMuYXhlcy5tYXAoaSA9PiBzY2FsZXNbaV0pLCBOdW1iZXIuTUlOX1ZBTFVFKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KC4uLnNjYWxlcywgTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtlZXAgYXNwZWN0IHJhdGlvIHBvbGljeSAke2F0dHJpYnV0ZXMua2VlcEFzcGVjdFJhdGlvUG9saWN5fSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICB9KSgpO1xuICBzY2FsZXMuZmlsbCgxLjAsIDAsIHNjYWxlcy5sZW5ndGgpO1xuICBjb25zdCBhZGp1c3RlZE91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgpO1xuICBpZiAoYXR0cmlidXRlcy5heGVzLmxlbmd0aCA+IDApIHtcbiAgICBhdHRyaWJ1dGVzLmF4ZXMuZm9yRWFjaCgodikgPT4gc2NhbGVzW3ZdID0gc2NhbGVJblBvbGljeSk7XG4gICAgYXR0cmlidXRlcy5heGVzLmZvckVhY2goKHYpID0+IGFkanVzdGVkT3V0cHV0U2hhcGVbdl0gPSBNYXRoLnJvdW5kKGlucHV0U2hhcGVbdl0gKiBzY2FsZXNbdl0pKTtcbiAgfSBlbHNlIHtcbiAgICBzY2FsZXMuZmlsbChzY2FsZUluUG9saWN5LCAwLCBzY2FsZXMubGVuZ3RoKTtcbiAgICBhZGp1c3RlZE91dHB1dFNoYXBlLmZvckVhY2goKHYsIGkpID0+IGFkanVzdGVkT3V0cHV0U2hhcGVbaV0gPSBNYXRoLnJvdW5kKHYgKiBzY2FsZXNbaV0pKTtcbiAgfVxuICByZXR1cm4gYWRqdXN0ZWRPdXRwdXRTaGFwZTtcbn07XG5cbmNvbnN0IGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzID1cbiAgICAob3V0cHV0OiBJbmRpY2VzSGVscGVyLCBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBzY2FsZXNMZW5ndGg6IG51bWJlcixcbiAgICAgcm9pTGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcgPT4gYFxuICAgIGZuIGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiBhcnJheTwke1xuICAgICAgICBvdXRwdXQudHlwZS52YWx1ZX0sICR7b3V0cHV0U2hhcGUubGVuZ3RofT4ge1xuICAgICAgdmFyIG9yaWdpbmFsX2luZGljZXM6IGFycmF5PCR7b3V0cHV0LnR5cGUudmFsdWV9LCAke291dHB1dFNoYXBlLmxlbmd0aH0+O1xuICAgICAgZm9yICh2YXIgaTp1MzIgPSAwOyBpIDwgJHtvdXRwdXRTaGFwZS5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgJ2knKX07XG4gICAgICAgIHZhciBzY2FsZSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5zY2FsZXMnLCAnaScsIHNjYWxlc0xlbmd0aCl9O1xuICAgICAgICB2YXIgcm9pX2xvdyA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5yb2knLCAnaScsIHJvaUxlbmd0aCl9O1xuICAgICAgICB2YXIgcm9pX2hpID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnJvaScsIGBpICsgJHtpbnB1dFNoYXBlLmxlbmd0aH1gLCByb2lMZW5ndGgpfTtcbiAgICAgICAgaWYgKHNjYWxlID09IDEuMCkge1xuICAgICAgICAgIG9yaWdpbmFsX2luZGljZXNbaV0gPSAke291dHB1dC50eXBlLnZhbHVlfShvdXRwdXRfaW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpbnB1dF9zaGFwZV9pID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLmlucHV0X3NoYXBlJywgJ2knLCBpbnB1dFNoYXBlLmxlbmd0aCl9O1xuICAgICAgICAgIHZhciBvdXRwdXRfc2hhcGVfaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5vdXRwdXRfc2hhcGUnLCAnaScsIG91dHB1dFNoYXBlLmxlbmd0aCl9O1xuICAgICAgICAgIG9yaWdpbmFsX2luZGljZXNbaV0gPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCBzY2FsZSwgb3V0cHV0X3NoYXBlX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9zaGFwZV9pLCByb2lfbG93LCByb2lfaGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luYWxfaW5kaWNlcztcbiAgICB9YDtcblxuY29uc3QgY2FsY3VsYXRlSW5wdXRJbmRpY2VzRnJvbU91dHB1dEluZGljZXMgPVxuICAgIChpbnB1dDogSW5kaWNlc0hlbHBlciwgb3V0cHV0OiBJbmRpY2VzSGVscGVyLCBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgICBzY2FsZXNMZW5ndGg6IG51bWJlciwgcm9pTGVuZ3RoOiBudW1iZXIsIHVzZUV4dHJhcG9sYXRpb246IGJvb2xlYW4pOiBzdHJpbmcgPT4gYFxuICAgIGZuIGNhbGN1bGF0ZUlucHV0SW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiAke2lucHV0LnR5cGUuaW5kaWNlc30ge1xuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfTtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7b3V0cHV0U2hhcGUubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICdpJyl9O1xuICAgICAgICB2YXIgaW5wdXRfaW5kZXg6IHUzMjtcbiAgICAgICAgdmFyIHNjYWxlID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnNjYWxlcycsICdpJywgc2NhbGVzTGVuZ3RoKX07XG4gICAgICAgIGlmIChzY2FsZSA9PSAxLjApIHtcbiAgICAgICAgICBpbnB1dF9pbmRleCA9IG91dHB1dF9pbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcm9pX2xvdyA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5yb2knLCAnaScsIHJvaUxlbmd0aCl9O1xuICAgICAgICAgIHZhciByb2lfaGkgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucm9pJywgYGkgKyAke2lucHV0U2hhcGUubGVuZ3RofWAsIHJvaUxlbmd0aCl9O1xuICAgICAgICAgIHZhciBpbnB1dF9zaGFwZV9pID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLmlucHV0X3NoYXBlJywgJ2knLCBpbnB1dFNoYXBlLmxlbmd0aCl9O1xuICAgICAgICAgIHZhciBvdXRwdXRfc2hhcGVfaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5vdXRwdXRfc2hhcGUnLCAnaScsIG91dHB1dFNoYXBlLmxlbmd0aCl9O1xuICAgICAgICAgIHZhciBvcmlnaW5hbF9pZHggPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCBzY2FsZSwgb3V0cHV0X3NoYXBlX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9zaGFwZV9pLCByb2lfbG93LCByb2lfaGkpO1xuICAgICAgICAgIGlmICghJHt1c2VFeHRyYXBvbGF0aW9ufSB8fCAob3JpZ2luYWxfaWR4ID49IDAgJiYgb3JpZ2luYWxfaWR4IDwgJHtvdXRwdXQudHlwZS52YWx1ZX0oaW5wdXRfc2hhcGVfaSkpKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxfaWR4IDwgMCkge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbmFsX2lkeCA+ICR7b3V0cHV0LnR5cGUudmFsdWV9KGlucHV0X3NoYXBlX2kgLSAxKSkge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IGlucHV0X3NoYXBlX2kgLSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSB1MzIoZ2V0TmVhcmVzdFBpeGVsRnJvbU9yaWdpbmFsKG9yaWdpbmFsX2lkeCwgc2NhbGUgPCAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0X2luZGV4ID0gdTMyKG9yaWdpbmFsX2lkeCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsICdpJywgJyBpbnB1dF9pbmRleCcpfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGlucHV0X2luZGljZXM7XG4gICAgfWA7XG5jb25zdCBjaGVja0lucHV0SW5kaWNlcyA9IChpbnB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pOiBzdHJpbmcgPT4gYFxuICAgIGZuIGNoZWNrSW5wdXRJbmRpY2VzKGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfSkgLT4gYm9vbCB7XG4gICAgICBmb3IgKHZhciBpOnUzMiA9IDA7IGkgPCAke2lucHV0U2hhcGUubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIHZhciBpbnB1dF9pbmRleCA9ICR7aW5wdXQuaW5kaWNlc0dldCgnaW5wdXRfaW5kaWNlcycsICdpJyl9O1xuICAgICAgICBpZiAoaW5wdXRfaW5kZXggPCAwIHx8IGlucHV0X2luZGV4ID49ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5pbnB1dF9zaGFwZScsICdpJywgaW5wdXRTaGFwZS5sZW5ndGgpfSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfWA7XG5cbmNvbnN0IHNldENoYW5uZWxBbmRCYXRjaEluZGljZXMgPVxuICAgIChpbnB1dDogSW5kaWNlc0hlbHBlciwgY2hhbm5lbElkeDogbnVtYmVyLCBiYXRjaElkeDogbnVtYmVyLCBzcGFjaWFsRGltczogbnVtYmVyKTogc3RyaW5nID0+XG4gICAgICAgIGlucHV0LnJhbmsgPiBzcGFjaWFsRGltcyA/IGBcbiAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCBjaGFubmVsSWR4LCAnY2hhbm5lbCcpfTtcbiAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCBiYXRjaElkeCwgJ2JhdGNoJyl9O1xuYCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcnO1xuXG5jb25zdCBiaWxpbmVhckludGVycG9sYXRpb24gPVxuICAgIChpbnB1dDogSW5kaWNlc0hlbHBlciwgb3V0cHV0OiBJbmRpY2VzSGVscGVyLCBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgdXNlRXh0cmFwb2xhdGlvbjogYm9vbGVhbixcbiAgICAgZXh0cmFwb2xhdGlvblZhbHVlOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICAgICAgY29uc3QgaXNOY2h3ID0gdHJ1ZTtcbiAgICAgIGNvbnN0IFtiYXRjaElkeCwgaGVpZ2h0SWR4LCB3aWR0aElkeCwgY2hhbm5lbElkeF0gPVxuICAgICAgICAgIGlucHV0U2hhcGUubGVuZ3RoID09PSAyID8gWy0xLCAwLCAxLCAtMV0gOiAoaXNOY2h3ID8gWzAsIDIsIDMsIDFdIDogWzAsIDEsIDIsIDNdKTtcbiAgICAgIGNvbnN0IGRUeXBlID0gaW5wdXQudHlwZS52YWx1ZTtcbiAgICAgIHJldHVybiBgXG4gICAgZm4gZ2V0SW5wdXRWYWx1ZShiYXRjaDogdTMyLCBjaGFubmVsOiB1MzIsIHJvdzogdTMyLCBjb2w6IHUzMikgLT4gJHtkVHlwZX0ge1xuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfTtcbiAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsIGhlaWdodElkeCwgYG1heCgwLCBtaW4ocm93LCAke2lucHV0U2hhcGVbaGVpZ2h0SWR4XX0gLSAxKSlgKX07XG4gICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCB3aWR0aElkeCwgYG1heCgwLCBtaW4oY29sLCAke2lucHV0U2hhcGVbd2lkdGhJZHhdfSAtIDEpKWApfTtcbiAgICAgICR7c2V0Q2hhbm5lbEFuZEJhdGNoSW5kaWNlcyhpbnB1dCwgY2hhbm5lbElkeCwgYmF0Y2hJZHgsIDIpfVxuICAgICAgcmV0dXJuICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O1xuICAgIH1cblxuICAgIGZuIGJpbGluZWFySW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlczogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gJHtkVHlwZX0ge1xuICAgICAgdmFyIG9yaWdpbmFsSW5kaWNlcyA9IGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcbiAgICAgIHZhciByb3c6JHtkVHlwZX0gPSBvcmlnaW5hbEluZGljZXNbJHtoZWlnaHRJZHh9XTtcbiAgICAgIHZhciBjb2w6JHtkVHlwZX0gPSBvcmlnaW5hbEluZGljZXNbJHt3aWR0aElkeH1dO1xuICAgICAgJHtcbiAgICAgICAgICB1c2VFeHRyYXBvbGF0aW9uID9cbiAgICAgICAgICAgICAgYGlmIChyb3cgPCAwIHx8IHJvdyA+ICgke2lucHV0U2hhcGVbaGVpZ2h0SWR4XX0gLSAxKSB8fCBjb2wgPCAwIHx8IGNvbCA+ICgke2lucHV0U2hhcGVbd2lkdGhJZHhdfSAtIDEpKSB7XG4gICAgICAgIHJldHVybiAke2V4dHJhcG9sYXRpb25WYWx1ZX07XG4gICAgICB9YCA6XG4gICAgICAgICAgICAgICcnfTtcbiAgICAgIHJvdyA9IG1heCgwLCBtaW4ocm93LCAke2lucHV0U2hhcGVbaGVpZ2h0SWR4XX0gLSAxKSk7XG4gICAgICBjb2wgPSBtYXgoMCwgbWluKGNvbCwgJHtpbnB1dFNoYXBlW3dpZHRoSWR4XX0gLSAxKSk7XG4gICAgICB2YXIgcm93MTogdTMyID0gdTMyKHJvdyk7XG4gICAgICB2YXIgY29sMTogdTMyID0gdTMyKGNvbCk7XG4gICAgICB2YXIgcm93MjogdTMyID0gdTMyKHJvdyArIDEpO1xuICAgICAgdmFyIGNvbDI6IHUzMiA9IHUzMihjb2wgKyAxKTtcbiAgICAgIHZhciBjaGFubmVsOiB1MzIgPSAke2lucHV0U2hhcGUubGVuZ3RoID4gMiA/IGB1MzIob3JpZ2luYWxJbmRpY2VzWyR7Y2hhbm5lbElkeH1dKWAgOiAnMCd9O1xuICAgICAgdmFyIGJhdGNoOiB1MzIgPSAgJHtpbnB1dFNoYXBlLmxlbmd0aCA+IDIgPyBgdTMyKG9yaWdpbmFsSW5kaWNlc1ske2JhdGNoSWR4fV0pYCA6ICcwJ307XG4gICAgICB2YXIgeDExOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzEsIGNvbDEpO1xuICAgICAgdmFyIHgxMjogJHtkVHlwZX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cxLCBjb2wyKTtcbiAgICAgIHZhciB4MjE6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MiwgY29sMSk7XG4gICAgICB2YXIgeDIyOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzIsIGNvbDIpO1xuICAgICAgdmFyIGR4MTogJHtkVHlwZX0gPSBhYnMocm93IC0gJHtkVHlwZX0ocm93MSkpO1xuICAgICAgdmFyIGR4MjogJHtkVHlwZX0gPSBhYnMoJHtkVHlwZX0ocm93MikgLSByb3cpO1xuICAgICAgdmFyIGR5MTogJHtkVHlwZX0gPSBhYnMoY29sIC0gJHtkVHlwZX0oY29sMSkpO1xuICAgICAgdmFyIGR5MjogJHtkVHlwZX0gPSBhYnMoJHtkVHlwZX0oY29sMikgLSBjb2wpO1xuICAgICAgaWYgKHJvdzEgPT0gcm93Mikge1xuICAgICAgICBkeDEgPSAwLjU7XG4gICAgICAgIGR4MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2wxID09IGNvbDIpIHtcbiAgICAgICAgZHkxID0gMC41O1xuICAgICAgICBkeTIgPSAwLjU7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHgxMSAqIGR4MiAqIGR5MiArIHgxMiAqIGR4MiAqIGR5MSArIHgyMSAqIGR4MSAqIGR5MiArIHgyMiAqIGR4MSAqIGR5MSk7XG4gICAgfWA7XG4gICAgfTtcblxuY29uc3QgYmljdWJpY0ludGVycG9sYXRpb24gPVxuICAgIChpbnB1dDogSW5kaWNlc0hlbHBlciwgb3V0cHV0OiBJbmRpY2VzSGVscGVyLCBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgICBzY2FsZXM6IHJlYWRvbmx5IG51bWJlcltdLCByb2k6IHJlYWRvbmx5IG51bWJlcltdLCBjdWJpY0NvZWZmQTogbnVtYmVyLCB1c2VFeHRyYXBvbGF0aW9uOiBib29sZWFuLFxuICAgICBleHRyYXBvbGF0aW9uVmFsdWU6IG51bWJlciwgZXhjbHVkZU91dHNpZGU6IGJvb2xlYW4pOiBzdHJpbmcgPT4ge1xuICAgICAgY29uc3QgaXMyRCA9IGlucHV0U2hhcGUubGVuZ3RoID09PSAyO1xuICAgICAgY29uc3QgaXNOY2h3ID0gdHJ1ZTtcbiAgICAgIGNvbnN0IFtoZWlnaHRJZHgsIHdpZHRoSWR4XSA9IGlzMkQgPyBbMCwgMV0gOiBpc05jaHcgPyBbMiwgM10gOiBbMSwgMl07XG4gICAgICBjb25zdCBkVHlwZSA9IGlucHV0LnR5cGUudmFsdWU7XG4gICAgICBjb25zdCBjcmVhdGVDdWJpY0ludGVycG9sYXRpb25GdW5jdGlvbiA9IChpZHg6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGlkeCA9PT0gaGVpZ2h0SWR4ID8gJ3JvdycgOiAnY29sJztcbiAgICAgICAgcmV0dXJuIGBcbiAgICAgIGZuICR7ZGlyZWN0aW9ufUN1YmljSW50ZXJwb2xhdGlvbihpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc30sIG91dHB1dF9pbmRpY2VzOiAke1xuICAgICAgICAgICAgb3V0cHV0LnR5cGUuaW5kaWNlc30pIC0+ICR7ZFR5cGV9IHtcbiAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgaWR4KX07XG4gICAgICAgIHZhciBvcmlnaW5hbElkeDogJHtkVHlwZX0gPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCAke3NjYWxlc1tpZHhdfSxcbiAgICAgICAgJHtvdXRwdXRTaGFwZVtpZHhdfSwgJHtpbnB1dFNoYXBlW2lkeF19LCAke3JvaVtpZHhdfSwgJHtyb2lbaWR4XX0gKyAke2lucHV0U2hhcGUubGVuZ3RofSk7XG4gICAgICAgIHZhciBmcmFjdE9yaWdpbmFsSWR4OiAke2RUeXBlfSA9IG9yaWdpbmFsSWR4IC0gZmxvb3Iob3JpZ2luYWxJZHgpO1xuICAgICAgICB2YXIgY29lZnMgPSBnZXRDdWJpY0ludGVycG9sYXRpb25Db2VmcyhmcmFjdE9yaWdpbmFsSWR4KTtcblxuICAgICAgICBpZiAoJHt1c2VFeHRyYXBvbGF0aW9ufSAmJiAob3JpZ2luYWxJZHggPCAwIHx8IG9yaWdpbmFsSWR4ID4gKCR7aW5wdXRTaGFwZVtpZHhdfSAtIDEpKSkge1xuICAgICAgICAgIHJldHVybiAke2V4dHJhcG9sYXRpb25WYWx1ZX07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGE6IGFycmF5PCR7ZFR5cGV9LCA0PiA9IGFycmF5PCR7ZFR5cGV9LCA0PigwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgICAgICBmb3IgKHZhciBpOiBpMzIgPSAtMTsgaSA8IDM7IGkrKykge1xuICAgICAgICAgIHZhciAke2RpcmVjdGlvbn06ICR7ZFR5cGV9ID0gb3JpZ2luYWxJZHggKyAke2RUeXBlfShpKTtcbiAgICAgICAgICBpZiAoJHtkaXJlY3Rpb259IDwgMCB8fCAke2RpcmVjdGlvbn0gPj0gJHtpbnB1dFNoYXBlW2lkeF19KSB7XG4gICAgICAgICAgICAkeygoKSA9PiB7XG4gICAgICAgICAgaWYgKGV4Y2x1ZGVPdXRzaWRlKSB7XG4gICAgICAgICAgICByZXR1cm4gYGNvZWZzW2kgKyAxXSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO2A7XG4gICAgICAgICAgfSBlbHNlIGlmICh1c2VFeHRyYXBvbGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gYHJldHVybiAke2V4dHJhcG9sYXRpb25WYWx1ZX07YDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGAke2RpcmVjdGlvbn0gPSBtYXgoMCwgbWluKCR7ZGlyZWN0aW9ufSwgJHtpbnB1dFNoYXBlW2lkeF19IC0gMSkpO2A7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpfTtcbiAgICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dF9pbmRpY2VzX2NvcHk6ICR7aW5wdXQudHlwZS5pbmRpY2VzfSA9IGlucHV0X2luZGljZXM7XG4gICAgICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzX2NvcHknLCBpZHgsIGB1MzIoJHtkaXJlY3Rpb259KWApfTtcbiAgICAgICAgICBkYXRhW2kgKyAxXSA9ICR7XG4gICAgICAgICAgICBpZHggPT09IGhlaWdodElkeCA/IGlucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlc19jb3B5JykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncm93Q3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0X2luZGljZXNfY29weSwgb3V0cHV0X2luZGljZXMpJ307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1YmljSW50ZXJwb2xhdGlvbjFEKGRhdGEsIGNvZWZzKTtcbiAgICAgIH1gO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGBcbiAgICAke2NyZWF0ZUN1YmljSW50ZXJwb2xhdGlvbkZ1bmN0aW9uKGhlaWdodElkeCl9O1xuICAgICR7Y3JlYXRlQ3ViaWNJbnRlcnBvbGF0aW9uRnVuY3Rpb24od2lkdGhJZHgpfTtcbiAgZm4gZ2V0Q3ViaWNJbnRlcnBvbGF0aW9uQ29lZnMoczogJHtkVHlwZX0pIC0+IGFycmF5PCR7ZFR5cGV9LCA0PiB7XG4gICAgdmFyIGFic1MgPSBhYnMocyk7XG4gICAgdmFyIGNvZWZmczogYXJyYXk8JHtkVHlwZX0sIDQ+ID0gYXJyYXk8JHtkVHlwZX0sIDQ+KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gICAgdmFyIG9uZU1pbnVzQWJzUzogJHtkVHlwZX0gPSAxLjAgLSBhYnNTO1xuICAgIHZhciB0d29NaW51c0Fic1M6ICR7ZFR5cGV9ID0gMi4wIC0gYWJzUztcbiAgICB2YXIgb25lUGx1c0Fic1M6ICR7ZFR5cGV9ID0gMS4wICsgYWJzUztcbiAgICBjb2VmZnNbMF0gPSAoKCR7Y3ViaWNDb2VmZkF9ICogb25lUGx1c0Fic1MgLSA1ICogJHtjdWJpY0NvZWZmQX0pICogb25lUGx1c0Fic1MgKyA4ICogJHtcbiAgICAgICAgICBjdWJpY0NvZWZmQX0pICogb25lUGx1c0Fic1MgLSA0ICogJHtjdWJpY0NvZWZmQX07XG4gICAgY29lZmZzWzFdID0gKCgke2N1YmljQ29lZmZBfSArIDIpICogYWJzUyAtICgke2N1YmljQ29lZmZBfSArIDMpKSAqIGFic1MgKiBhYnNTICsgMTtcbiAgICBjb2VmZnNbMl0gPSAoKCR7Y3ViaWNDb2VmZkF9ICsgMikgKiBvbmVNaW51c0Fic1MgLSAoJHtjdWJpY0NvZWZmQX0gKyAzKSkgKiBvbmVNaW51c0Fic1MgKiBvbmVNaW51c0Fic1MgKyAxO1xuICAgIGNvZWZmc1szXSA9ICgoJHtjdWJpY0NvZWZmQX0gKiB0d29NaW51c0Fic1MgLSA1ICogJHtjdWJpY0NvZWZmQX0pICogdHdvTWludXNBYnNTICsgOCAqICR7XG4gICAgICAgICAgY3ViaWNDb2VmZkF9KSAqIHR3b01pbnVzQWJzUyAtIDQgKiAke2N1YmljQ29lZmZBfTtcbiAgICByZXR1cm4gY29lZmZzO1xuICB9XG5cbiAgZm4gY3ViaWNJbnRlcnBvbGF0aW9uMUQoeDogYXJyYXk8JHtkVHlwZX0sIDQ+LCBjb2VmczogYXJyYXk8JHtkVHlwZX0sIDQ+KSAtPiAke2RUeXBlfSB7XG4gICAgdmFyIGNvZWZzU3VtOiAke2RUeXBlfSA9IGNvZWZzWzBdICsgY29lZnNbMV0gKyBjb2Vmc1syXSArIGNvZWZzWzNdO1xuICAgIHJldHVybiAoeFswXSAqIGNvZWZzWzBdICsgeFsxXSAqIGNvZWZzWzFdKyB4WzJdICogY29lZnNbMl0rIHhbM10gKiBjb2Vmc1szXSkgLyBjb2Vmc1N1bTtcbiAgfVxuXG4gIGZuIGJpY3ViaWNJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiAke2RUeXBlfSB7XG4gICAgdmFyIGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfSA9IG91dHB1dF9pbmRpY2VzO1xuICAgIHJldHVybiBjb2xDdWJpY0ludGVycG9sYXRpb24oaW5wdXRfaW5kaWNlcywgb3V0cHV0X2luZGljZXMpO1xuICB9XG4gICAgYDtcbiAgICB9O1xuXG5jb25zdCB0cmlsaW5lYXJJbnRlcnBvbGF0aW9uID1cbiAgICAoaW5wdXQ6IEluZGljZXNIZWxwZXIsIG91dHB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHVzZUV4dHJhcG9sYXRpb246IGJvb2xlYW4sXG4gICAgIGV4dHJhcG9sYXRpb25WYWx1ZTogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgICAgIGNvbnN0IGlzTmNodyA9IHRydWU7XG4gICAgICBjb25zdCBbYmF0Y2hJZHgsIGRlcHRoSWR4LCBoZWlnaHRJZHgsIHdpZHRoSWR4LCBjaGFubmVsSWR4XSA9XG4gICAgICAgICAgaW5wdXRTaGFwZS5sZW5ndGggPT09IDMgPyBbLTEsIDAsIDEsIDIsIC0xXSA6IChpc05jaHcgPyBbMCwgMiwgMywgNCwgMV0gOiBbMCwgMSwgMiwgMywgNF0pO1xuICAgICAgY29uc3QgZFR5cGUgPSBpbnB1dC50eXBlLnZhbHVlO1xuICAgICAgcmV0dXJuIGBcbiAgICBmbiBnZXRJbnB1dFZhbHVlKGJhdGNoOiB1MzIsIGNoYW5uZWw6IHUzMiwgZGVwdGg6dTMyLCBoZWlnaHQ6IHUzMiwgd2lkdGg6IHUzMikgLT4gJHtkVHlwZX0ge1xuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfTtcbiAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsIGRlcHRoSWR4LCBgbWF4KDAsIG1pbihkZXB0aCwgJHtpbnB1dFNoYXBlW2RlcHRoSWR4XX0gLSAxKSlgKX07XG4gICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCBoZWlnaHRJZHgsIGBtYXgoMCwgbWluKGhlaWdodCwgJHtpbnB1dFNoYXBlW2hlaWdodElkeF19IC0gMSkpYCl9O1xuICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgd2lkdGhJZHgsIGBtYXgoMCwgbWluKHdpZHRoLCAke2lucHV0U2hhcGVbd2lkdGhJZHhdfSAtIDEpKWApfTtcbiAgICAgICR7c2V0Q2hhbm5lbEFuZEJhdGNoSW5kaWNlcyhpbnB1dCwgY2hhbm5lbElkeCwgYmF0Y2hJZHgsIDMpfVxuICAgICAgcmV0dXJuICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O1xuICAgIH1cblxuICAgIGZuIHRyaWxpbmVhckludGVycG9sYXRpb24ob3V0cHV0X2luZGljZXM6ICR7b3V0cHV0LnR5cGUuaW5kaWNlc30pIC0+ICR7ZFR5cGV9IHtcbiAgICAgIHZhciBvcmlnaW5hbEluZGljZXMgPSBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICB2YXIgZGVwdGg6JHtkVHlwZX0gPSBvcmlnaW5hbEluZGljZXNbJHtkZXB0aElkeH1dO1xuICAgICAgdmFyIGhlaWdodDoke2RUeXBlfSA9IG9yaWdpbmFsSW5kaWNlc1ske2hlaWdodElkeH1dO1xuICAgICAgdmFyIHdpZHRoOiR7ZFR5cGV9ID0gb3JpZ2luYWxJbmRpY2VzWyR7d2lkdGhJZHh9XTtcbiAgICAgICR7XG4gICAgICAgICAgdXNlRXh0cmFwb2xhdGlvbiA/IGBpZiAoZGVwdGggPCAwIHx8IGRlcHRoID4gKCR7aW5wdXRTaGFwZVtkZXB0aElkeF19IC0gMSkgfHwgaGVpZ2h0IDwgMCB8fCBoZWlnaHQgPiAoJHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0U2hhcGVbaGVpZ2h0SWR4XX0gLSAxKSB8fCB3aWR0aCA8IDAgfHwgKHdpZHRoID4gJHtpbnB1dFNoYXBlW3dpZHRoSWR4XX0gLSAxKSkge1xuICAgICAgcmV0dXJuICR7ZXh0cmFwb2xhdGlvblZhbHVlfTtcbiAgICAgICAgfWAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJ307XG5cbiAgICBkZXB0aCA9IG1heCgwLCBtaW4oZGVwdGgsICR7aW5wdXRTaGFwZVtkZXB0aElkeF19IC0gMSkpO1xuICAgICAgaGVpZ2h0ID0gbWF4KDAsIG1pbihoZWlnaHQsICR7aW5wdXRTaGFwZVtoZWlnaHRJZHhdfSAtIDEpKTtcbiAgICAgIHdpZHRoID0gbWF4KDAsIG1pbih3aWR0aCwgJHtpbnB1dFNoYXBlW3dpZHRoSWR4XX0gLSAxKSk7XG4gICAgICB2YXIgZGVwdGgxOiB1MzIgPSB1MzIoZGVwdGgpO1xuICAgICAgdmFyIGhlaWdodDE6IHUzMiA9IHUzMihoZWlnaHQpO1xuICAgICAgdmFyIHdpZHRoMTogdTMyID0gdTMyKHdpZHRoKTtcbiAgICAgIHZhciBkZXB0aDI6IHUzMiA9IHUzMihkZXB0aCArIDEpO1xuICAgICAgdmFyIGhlaWdodDI6IHUzMiA9IHUzMihoZWlnaHQgKyAxKTtcbiAgICAgIHZhciB3aWR0aDI6IHUzMiA9IHUzMih3aWR0aCArIDEpO1xuICAgICAgdmFyIGNoYW5uZWw6IHUzMiA9ICR7aW5wdXRTaGFwZS5sZW5ndGggPiAzID8gYHUzMihvcmlnaW5hbEluZGljZXNbJHtjaGFubmVsSWR4fV0pYCA6ICcwJ307XG4gICAgICB2YXIgYmF0Y2g6IHUzMiA9ICAke2lucHV0U2hhcGUubGVuZ3RoID4gMyA/IGB1MzIob3JpZ2luYWxJbmRpY2VzWyR7YmF0Y2hJZHh9XSlgIDogJzAnfTtcblxuICAgICAgdmFyIHgxMTE6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQxLCB3aWR0aDEpO1xuICAgICAgdmFyIHgxMTI6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQxLCB3aWR0aDIpO1xuICAgICAgdmFyIHgxMjE6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQyLCB3aWR0aDEpO1xuICAgICAgdmFyIHgxMjI6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQyLCB3aWR0aDIpO1xuICAgICAgdmFyIHgyMTE6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQxLCB3aWR0aDEpO1xuICAgICAgdmFyIHgyMTI6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQxLCB3aWR0aDIpO1xuICAgICAgdmFyIHgyMjE6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQyLCB3aWR0aDEpO1xuICAgICAgdmFyIHgyMjI6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQyLCB3aWR0aDIpO1xuICAgICAgdmFyIGR4MTogJHtkVHlwZX0gPSBhYnMoZGVwdGggLSAke2RUeXBlfShkZXB0aDEpKTtcbiAgICAgIHZhciBkeDI6ICR7ZFR5cGV9ID0gYWJzKCR7ZFR5cGV9KGRlcHRoMikgLSBkZXB0aCk7XG4gICAgICB2YXIgZHkxOiAke2RUeXBlfSA9IGFicyhoZWlnaHQgLSAke2RUeXBlfShoZWlnaHQxKSk7XG4gICAgICB2YXIgZHkyOiAke2RUeXBlfSA9IGFicygke2RUeXBlfShoZWlnaHQyKSAtIGhlaWdodCk7XG4gICAgICB2YXIgZHoxOiAke2RUeXBlfSA9IGFicyh3aWR0aCAtICR7ZFR5cGV9KHdpZHRoMSkpO1xuICAgICAgdmFyIGR6MjogJHtkVHlwZX0gPSBhYnMoJHtkVHlwZX0od2lkdGgyKSAtIHdpZHRoKTtcbiAgICAgIGlmIChkZXB0aDEgPT0gZGVwdGgyKSB7XG4gICAgICAgIGR4MSA9IDAuNTtcbiAgICAgICAgZHgyID0gMC41O1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodDEgPT0gaGVpZ2h0Mikge1xuICAgICAgICBkeTEgPSAwLjU7XG4gICAgICAgIGR5MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIGlmICh3aWR0aDEgPT0gd2lkdGgyKSB7XG4gICAgICAgIGR6MSA9IDAuNTtcbiAgICAgICAgZHoyID0gMC41O1xuICAgICAgfVxuICAgICAgcmV0dXJuICh4MTExICogZHgyICogZHkyICogZHoyICsgeDExMiAqIGR4MiAqIGR5MiAqIGR6MSArIHgxMjEgKiBkeDIgKiBkeTEgKmR6MiArIHgxMjIgKiBkeDIgKiBkeTEgKiBkejEgK1xuICAgICAgICAgICAgICB4MjExICogZHgxICogZHkyICogZHoyICsgeDIxMiAqIGR4MSAqIGR5MiAqIGR6MSArIHgyMjEgKiBkeDEgKiBkeTEgKmR6MiArIHgyMjIgKiBkeDEgKiBkeTEgKiBkejEpO1xuICAgIH1gO1xuICAgIH07XG5cbmNvbnN0IGNyZWF0ZVJlc2l6ZVByb2dyYW1JbmZvID1cbiAgICAoaW5wdXRUZW5zb3I6IFRlbnNvclZpZXcsIGF0dHJpYnV0ZXM6IFJlc2l6ZUF0dHJpYnV0ZXMsIG9wc2V0VmVyc2lvbjogbnVtYmVyLCBzY2FsZXNJbnB1dDogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgIHNpemVzOiByZWFkb25seSBudW1iZXJbXSwgcm9pSW5wdXQ6IHJlYWRvbmx5IG51bWJlcltdKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0VGVuc29yLmRpbXM7XG4gICAgICBjb25zdCByb2kgPSB1cGRhdGVSb0kocm9pSW5wdXQsIGF0dHJpYnV0ZXMuYXhlcywgaW5wdXRTaGFwZS5sZW5ndGgpO1xuXG4gICAgICBsZXQgb3V0cHV0U2hhcGUgPSBpbml0T3V0cHV0U2hhcGUoaW5wdXRTaGFwZSwgc2NhbGVzSW5wdXQsIHNpemVzLCBhdHRyaWJ1dGVzLmF4ZXMpO1xuICAgICAgbGV0IHNjYWxlcyA9IHNjYWxlc0lucHV0LnNsaWNlKCk7XG4gICAgICBpZiAoc2NhbGVzSW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNjYWxlcyA9IGlucHV0U2hhcGUubWFwKCh2YWx1ZSwgaW5kZXgpID0+IHZhbHVlID09PSAwID8gMS4wIDogb3V0cHV0U2hhcGVbaW5kZXhdIC8gdmFsdWUpO1xuICAgICAgICBpZiAoYXR0cmlidXRlcy5rZWVwQXNwZWN0UmF0aW9Qb2xpY3kgIT09ICdzdHJldGNoJykge1xuICAgICAgICAgIG91dHB1dFNoYXBlID0gYWRqdXN0T3V0cHV0U2hhcGUoaW5wdXRTaGFwZSwgc2NhbGVzLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0VGVuc29yLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgICAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0VGVuc29yLmRhdGFUeXBlLCBpbnB1dFNoYXBlLmxlbmd0aCk7XG4gICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICAgICAgY29uc3Qgbm9TY2FsZSA9IGlucHV0U2hhcGUubGVuZ3RoID09PSBvdXRwdXRTaGFwZS5sZW5ndGggJiYgaW5wdXRTaGFwZS5ldmVyeSgoZCwgaSkgPT4gZCA9PT0gb3V0cHV0U2hhcGVbaV0pO1xuICAgICAgY29uc3QgdXNlRXh0cmFwb2xhdGlvbiA9IGF0dHJpYnV0ZXMuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUgPT09ICd0Zl9jcm9wX2FuZF9yZXNpemUnO1xuICAgICAgY29uc3QgZXh0cmFwb2xhdGlvblZhbHVlID0gYXR0cmlidXRlcy5leHRyYXBvbGF0aW9uVmFsdWU7XG4gICAgICBjb25zdCBkYXRhVHlwZSA9IGlucHV0LnR5cGUudmFsdWU7XG4gICAgICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgICAgICR7bm9TY2FsZSA/ICcnIDogYFxuICAgICAgJHtnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUoYXR0cmlidXRlcy5jb29yZGluYXRlVHJhbnNmb3JtTW9kZSwgZGF0YVR5cGUpfTtcbiAgICAgICR7KCgpID0+IHtcbiAgICAgICAgc3dpdGNoIChhdHRyaWJ1dGVzLm1vZGUpIHtcbiAgICAgICAgICBjYXNlICduZWFyZXN0JzpcbiAgICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICAgICR7Y2hlY2tJbnB1dEluZGljZXMoaW5wdXQsIGlucHV0U2hhcGUpfTtcbiAgICAgICAgICAgICAgJHtnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwoYXR0cmlidXRlcy5uZWFyZXN0TW9kZSwgb3BzZXRWZXJzaW9uLCBkYXRhVHlwZSl9O1xuICAgICAgICAgICAgICAke1xuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZUlucHV0SW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKFxuICAgICAgICAgICAgICAgICAgICBpbnB1dCwgb3V0cHV0LCBpbnB1dFNoYXBlLCBvdXRwdXRTaGFwZSwgc2NhbGVzLmxlbmd0aCwgcm9pLmxlbmd0aCwgdXNlRXh0cmFwb2xhdGlvbil9O1xuICAgICAgICAgICAgICBgO1xuICAgICAgICAgIGNhc2UgJ2xpbmVhcic6XG4gICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgICAke2NhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dCwgaW5wdXRTaGFwZSwgb3V0cHV0U2hhcGUsIHNjYWxlcy5sZW5ndGgsIHJvaS5sZW5ndGgpfTtcbiAgICAgICAgICAgICAgJHsoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoaW5wdXRTaGFwZS5sZW5ndGggPT09IDIgfHwgaW5wdXRTaGFwZS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7YmlsaW5lYXJJbnRlcnBvbGF0aW9uKGlucHV0LCBvdXRwdXQsIGlucHV0U2hhcGUsIHVzZUV4dHJhcG9sYXRpb24sIGV4dHJhcG9sYXRpb25WYWx1ZSl9YDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dFNoYXBlLmxlbmd0aCA9PT0gMyB8fCBpbnB1dFNoYXBlLmxlbmd0aCA9PT0gNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0cmlsaW5lYXJJbnRlcnBvbGF0aW9uKGlucHV0LCBvdXRwdXQsIGlucHV0U2hhcGUsIHVzZUV4dHJhcG9sYXRpb24sIGV4dHJhcG9sYXRpb25WYWx1ZSl9YDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignTGluZWFyIG1vZGUgb25seSBzdXBwb3J0cyBpbnB1dCBkaW1zIDIsIDMsIDQgYW5kIDUgYXJlIHN1cHBvcnRlZCBpbiBsaW5lYXIgbW9kZS4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKX07XG4gICAgICAgICAgICBgO1xuICAgICAgICAgIGNhc2UgJ2N1YmljJzpcbiAgICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICAkeygoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChpbnB1dFNoYXBlLmxlbmd0aCA9PT0gMiB8fCBpbnB1dFNoYXBlLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtcbiAgICAgICAgICAgICAgICAgICAgYmljdWJpY0ludGVycG9sYXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dCwgb3V0cHV0LCBpbnB1dFNoYXBlLCBvdXRwdXRTaGFwZSwgc2NhbGVzLCByb2ksIGF0dHJpYnV0ZXMuY3ViaWNDb2VmZkEsIHVzZUV4dHJhcG9sYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLmV4dHJhcG9sYXRpb25WYWx1ZSwgYXR0cmlidXRlcy5leGNsdWRlT3V0c2lkZSl9YDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignQ3ViaWMgbW9kZSBvbmx5IHN1cHBvcnRzIGlucHV0IGRpbXMgMiBhbmQgNCBhcmUgc3VwcG9ydGVkIGluIGxpbmVhciBtb2RlLicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpfTtcbiAgICAgICAgICAgIGA7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIHJlc2l6ZSBtb2RlJyk7XG4gICAgICAgIH1cbiAgICAgIH0pKCl9O1xuICAgICAgYH1cbiAgICAgICR7XG4gICAgICAgICAgc2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0X3NpemUnLCAndTMyJylcbiAgICAgICAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnc2NhbGVzJywgJ2YzMicsIHNjYWxlcy5sZW5ndGgpXG4gICAgICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ3JvaScsICdmMzInLCByb2kubGVuZ3RoKVxuICAgICAgICAgICAgICAuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cbiAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICAgICAgICAke25vU2NhbGUgPyAnb3V0cHV0W2dsb2JhbF9pZHhdID0gaW5wdXRbZ2xvYmFsX2lkeF07JyA6IGBcbiAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9O1xuICAgICAgICAkeygoKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoYXR0cmlidXRlcy5tb2RlKSB7XG4gICAgICAgICAgY2FzZSAnbmVhcmVzdCc6XG4gICAgICAgICAgICByZXR1cm4gYGlucHV0X2luZGljZXMgPSBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrSW5wdXRJbmRpY2VzKGlucHV0X2luZGljZXMpKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHthdHRyaWJ1dGVzLmV4dHJhcG9sYXRpb25WYWx1ZX07XG4gICAgICAgICAgICAgICAgfWA7XG4gICAgICAgICAgY2FzZSAnbGluZWFyJzpcbiAgICAgICAgICAgIHJldHVybiBgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHtcbiAgICAgICAgICAgICAgICAoaW5wdXRTaGFwZS5sZW5ndGggPT09IDIgfHwgaW5wdXRTaGFwZS5sZW5ndGggPT09IDQpID8gJ2JpbGluZWFySW50ZXJwb2xhdGlvbicgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHJpbGluZWFySW50ZXJwb2xhdGlvbid9KG91dHB1dF9pbmRpY2VzKTtgO1xuICAgICAgICAgIGNhc2UgJ2N1YmljJzpcbiAgICAgICAgICAgIHJldHVybiAnb3V0cHV0W2dsb2JhbF9pZHhdID0gYmljdWJpY0ludGVycG9sYXRpb24ob3V0cHV0X2luZGljZXMpOyc7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBVbnN1cHBvcnRlZCByZXNpemUgbW9kZTogJHthdHRyaWJ1dGVzLm1vZGV9YCk7XG4gICAgICAgIH1cbiAgICAgIH0pKCl9O1xuYH1cbiAgICAgIH1gO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnUmVzaXplJyxcbiAgICAgICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgICAgICBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fXwke29wc2V0VmVyc2lvbn18JHtzY2FsZXMubGVuZ3RoID4gMCA/IHNjYWxlcyA6ICcnfXwke1xuICAgICAgICAgICAgICBzaXplcy5sZW5ndGggPiAwID8gc2l6ZXMgOiAnJ318JHtyb2kubGVuZ3RoID4gMCA/IHJvaSA6ICcnfXwke25vU2NhbGV9fCR7aW5wdXRTaGFwZX1gLFxuICAgICAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXVxuICAgICAgICB9LFxuICAgICAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0VGVuc29yLmRhdGFUeXBlfV0sXG4gICAgICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pfSxcbiAgICAgICAgICBwcm9ncmFtVW5pZm9ybXM6IFtcbiAgICAgICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemV9LCB7dHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IHNjYWxlc30sXG4gICAgICAgICAgICB7dHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IHJvaX0sIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0U2hhcGUsIG91dHB1dFNoYXBlKVxuICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfTtcblxuY29uc3QgZ2V0T3BzZXRWZXJzaW9uRnJvbUN1c3RvbURhdGFCdWZmZXIgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiBudW1iZXIgPT4ge1xuICBjb25zdCBjdXN0b21EYXRhQnVmZmVyID0gY29udGV4dC5jdXN0b21EYXRhQnVmZmVyO1xuICBjb25zdCBjdXN0b21EYXRhQnVmZmVyMzIgPSBuZXcgVWludDMyQXJyYXkoY3VzdG9tRGF0YUJ1ZmZlciwgY3VzdG9tRGF0YUJ1ZmZlci5ieXRlT2Zmc2V0LCAxKTtcbiAgY29uc3Qgb3BzZXRWZXJzaW9uID0gY3VzdG9tRGF0YUJ1ZmZlcjMyWzBdO1xuICByZXR1cm4gb3BzZXRWZXJzaW9uO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlc2l6ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVzaXplQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBzY2FsZXM6IG51bWJlcltdID0gW107XG4gIGNvbnN0IHNpemVzOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCByb2k6IG51bWJlcltdID0gW107XG5cbiAgLy8gTm90ZSB0aGF0IHNjYWxlcyBpbiByZXNpemUgYXJlIGFsd2F5cyBmMzIuIHJvaSBjYW4gYmUgZjMyIG9yIGYxNi5cbiAgLy8gVE9ETzogQ3VycmVudGx5IHRoaXMgY29kZSBkb2VzIG5vdCBzdXBwb3J0IGYxNiBmb3Igcm9pIHdoZW4gcGFzc2VkIGFzIG9wdGlvbmFsIGlucHV0LlxuXG4gIGNvbnN0IG9wc2V0VmVyc2lvbiA9IGdldE9wc2V0VmVyc2lvbkZyb21DdXN0b21EYXRhQnVmZmVyKGNvbnRleHQpO1xuICBpZiAoYXR0cmlidXRlcy5hbnRpYWxpYXMgIT09IDApIHtcbiAgICB0aHJvdyBFcnJvcignT25seSBkZWZhdWx0IHZhbHVlICgwKSBmb3IgQW50aWFsaWFzIGF0dHJpYnV0ZSBpcyBzdXBwb3J0ZWQnKTtcbiAgfVxuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcywgb3BzZXRWZXJzaW9uLCBzY2FsZXMsIHNpemVzLCByb2kpO1xuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgICBjcmVhdGVSZXNpemVQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgYXR0cmlidXRlcywgb3BzZXRWZXJzaW9uLCBzY2FsZXMsIHNpemVzLCByb2kpLCB7aW5wdXRzOiBbMF19KTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVJlc2l6ZUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBSZXNpemVBdHRyaWJ1dGVzID0+IHtcbiAgY29uc3QgYW50aWFsaWFzID0gYXR0cmlidXRlcy5hbnRpYWxpYXMgYXMgbnVtYmVyO1xuICBjb25zdCBheGVzID0gYXR0cmlidXRlcy5heGVzIGFzIG51bWJlcltdO1xuICBjb25zdCBjb29yZGluYXRlVHJhbnNmb3JtTW9kZTogQ29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUgPVxuICAgICAgYXR0cmlidXRlcy5jb29yZGluYXRlVHJhbnNmb3JtTW9kZSBhcyBDb29yZGluYXRlVHJhbnNmb3JtTW9kZTtcbiAgY29uc3QgY3ViaWNDb2VmZkEgPSBhdHRyaWJ1dGVzLmN1YmljQ29lZmZBIGFzIG51bWJlcjtcbiAgY29uc3QgZXhjbHVkZU91dHNpZGUgPSBhdHRyaWJ1dGVzLmV4Y2x1ZGVPdXRzaWRlIGFzIG51bWJlciAhPT0gMDtcbiAgY29uc3QgZXh0cmFwb2xhdGlvblZhbHVlID0gYXR0cmlidXRlcy5leHRyYXBvbGF0aW9uVmFsdWUgYXMgbnVtYmVyO1xuICBjb25zdCBrZWVwQXNwZWN0UmF0aW9Qb2xpY3k6IEtlZXBBc3BlY3RSYXRpb1BvbGljeSA9IGF0dHJpYnV0ZXMua2VlcEFzcGVjdFJhdGlvUG9saWN5IGFzIEtlZXBBc3BlY3RSYXRpb1BvbGljeTtcbiAgY29uc3QgbW9kZTogTW9kZSA9IGF0dHJpYnV0ZXMubW9kZSBhcyBNb2RlO1xuICAvLyBJZiBuZWFyZXN0TW9kZSBpcyBub3Qgc3BlY2lmaWVkLCB1c2Ugc2ltcGxlIG1vZGUuXG4gIGNvbnN0IG5lYXJlc3RNb2RlOiBOZWFyZXN0TW9kZSA9IChhdHRyaWJ1dGVzLm5lYXJlc3RNb2RlID09PSAnJyA/ICdzaW1wbGUnIDogYXR0cmlidXRlcy5uZWFyZXN0TW9kZSkgYXMgTmVhcmVzdE1vZGU7XG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xuICAgIGFudGlhbGlhcyxcbiAgICBheGVzLFxuICAgIGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlLFxuICAgIGN1YmljQ29lZmZBLFxuICAgIGV4Y2x1ZGVPdXRzaWRlLFxuICAgIGV4dHJhcG9sYXRpb25WYWx1ZSxcbiAgICBrZWVwQXNwZWN0UmF0aW9Qb2xpY3ksXG4gICAgbW9kZSxcbiAgICBuZWFyZXN0TW9kZVxuICB9KTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXl9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm19IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciwgV09SS0dST1VQX1NJWkV9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBSb3RhcnlFbWJlZGRpbmdBdHRyaWJ1dGVzIHtcbiAgcmVhZG9ubHkgaW50ZXJsZWF2ZWQ6IGJvb2xlYW47XG4gIHJlYWRvbmx5IG51bUhlYWRzOiBudW1iZXI7XG4gIHJlYWRvbmx5IHJvdGFyeUVtYmVkZGluZ0RpbTogbnVtYmVyO1xuICByZWFkb25seSBzY2FsZTogbnVtYmVyO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogUm90YXJ5RW1iZWRkaW5nQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBbaW5wdXQsIHBvc2l0aW9uSWRzLCBjb3NDYWNoZSwgc2luQ2FjaGVdID0gaW5wdXRzO1xuICBjb25zdCB7bnVtSGVhZHMsIHJvdGFyeUVtYmVkZGluZ0RpbX0gPSBhdHRyaWJ1dGVzO1xuXG4gIGlmIChpbnB1dC5kaW1zLmxlbmd0aCAhPT0gMyAmJiBpbnB1dC5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3gnIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA0IGRpbWVuc2lvbnMsIGdvdCAke2lucHV0LmRpbXMubGVuZ3RofWApO1xuICB9XG4gIGlmICghU2hhcGVVdGlsLmFyZUVxdWFsKHBvc2l0aW9uSWRzLmRpbXMsIFtdKSAmJiAhU2hhcGVVdGlsLmFyZUVxdWFsKHBvc2l0aW9uSWRzLmRpbXMsIFsxXSkgJiZcbiAgICAgIHBvc2l0aW9uSWRzLmRpbXMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAncG9zaXRpb25faWRzJyBpcyBleHBlY3RlZCB0byBoYXZlIDAsIDEsIG9yIDIgZGltZW5zaW9ucywgZ290ICR7cG9zaXRpb25JZHMuZGltcy5sZW5ndGh9YCk7XG4gIH1cbiAgaWYgKGNvc0NhY2hlLmRpbXMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAnY29zX2NhY2hlJyBpcyBleHBlY3RlZCB0byBoYXZlIDIgZGltZW5zaW9ucywgZ290ICR7Y29zQ2FjaGUuZGltcy5sZW5ndGh9YCk7XG4gIH1cbiAgaWYgKHNpbkNhY2hlLmRpbXMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAnc2luX2NhY2hlJyBpcyBleHBlY3RlZCB0byBoYXZlIDIgZGltZW5zaW9ucywgZ290ICR7c2luQ2FjaGUuZGltcy5sZW5ndGh9YCk7XG4gIH1cbiAgaWYgKCFTaGFwZVV0aWwuYXJlRXF1YWwoY29zQ2FjaGUuZGltcywgc2luQ2FjaGUuZGltcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0cyBcXCdjb3NfY2FjaGVcXCcgYW5kIFxcJ3Npbl9jYWNoZVxcJyBhcmUgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgc2FtZSBzaGFwZScpO1xuICB9XG5cbiAgaWYgKHJvdGFyeUVtYmVkZGluZ0RpbSA+IDAgJiYgbnVtSGVhZHMgPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ251bV9oZWFkcyBtdXN0IGJlIHByb3ZpZGVkIGlmIHJvdGFyeV9lbWJlZGRpbmdfZGltIGlzIHNwZWNpZmllZCcpO1xuICB9XG5cbiAgY29uc3QgYmF0Y2hTaXplID0gaW5wdXQuZGltc1swXTtcbiAgY29uc3Qgc2VxdWVuY2VMZW5ndGggPSBpbnB1dC5kaW1zW2lucHV0LmRpbXMubGVuZ3RoIC0gMl07XG4gIGNvbnN0IG1heFNlcXVlbmNlTGVuZ3RoID0gY29zQ2FjaGUuZGltc1swXTtcbiAgY29uc3QgaGlkZGVuU2l6ZSA9IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbihpbnB1dC5kaW1zLCAxKSAvIHNlcXVlbmNlTGVuZ3RoO1xuICBjb25zdCBoZWFkU2l6ZSA9IHJvdGFyeUVtYmVkZGluZ0RpbSA9PT0gMCA/IGNvc0NhY2hlLmRpbXNbMV0gKiAyIDogaGlkZGVuU2l6ZSAvIG51bUhlYWRzO1xuICBpZiAocm90YXJ5RW1iZWRkaW5nRGltID4gaGVhZFNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JvdGFyeV9lbWJlZGRpbmdfZGltIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGhlYWRfc2l6ZScpO1xuICB9XG5cbiAgaWYgKHBvc2l0aW9uSWRzLmRpbXMubGVuZ3RoID09PSAyKSB7XG4gICAgaWYgKGJhdGNoU2l6ZSAhPT0gcG9zaXRpb25JZHMuZGltc1swXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAncG9zaXRpb25faWRzJyBkaW1lbnNpb24gMCBzaG91bGQgYmUgb2Ygc2l6ZSBiYXRjaF9zaXplLCBnb3QgJHtwb3NpdGlvbklkcy5kaW1zWzBdfWApO1xuICAgIH1cbiAgICBpZiAoc2VxdWVuY2VMZW5ndGggIT09IHBvc2l0aW9uSWRzLmRpbXNbMV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Bvc2l0aW9uX2lkcycgZGltZW5zaW9uIDEgc2hvdWxkIGJlIG9mIHNpemUgc2VxdWVuY2VfbGVuZ3RoLCBnb3QgJHtwb3NpdGlvbklkcy5kaW1zWzFdfWApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChoZWFkU2l6ZSAvIDIgIT09IGNvc0NhY2hlLmRpbXNbMV0gJiYgcm90YXJ5RW1iZWRkaW5nRGltIC8gMiAhPT0gY29zQ2FjaGUuZGltc1sxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJ2Nvc19jYWNoZScgZGltZW5zaW9uIDEgc2hvdWxkIGJlIHNhbWUgYXMgaGVhZF9zaXplIC8gMiBvciByb3RhcnlfZW1iZWRkaW5nX2RpbSAvIDIsIGdvdCAke1xuICAgICAgICBjb3NDYWNoZS5kaW1zWzFdfWApO1xuICB9XG5cbiAgaWYgKHNlcXVlbmNlTGVuZ3RoID4gbWF4U2VxdWVuY2VMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VwZGF0aW5nIGNvc19jYWNoZSBhbmQgc2luX2NhY2hlIGluIFJvdGFyeUVtYmVkZGluZyBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZCcpO1xuICB9XG59O1xuXG5jb25zdCBjcmVhdGVSb3RhcnlFbWJlZGRpbmdQcm9ncmFtSW5mbyA9XG4gICAgKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBSb3RhcnlFbWJlZGRpbmdBdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICAgICAgY29uc3Qge2ludGVybGVhdmVkLCBudW1IZWFkcywgcm90YXJ5RW1iZWRkaW5nRGltLCBzY2FsZX0gPSBhdHRyaWJ1dGVzO1xuICAgICAgY29uc3QgYmF0Y2hTaXplID0gaW5wdXRzWzBdLmRpbXNbMF07XG4gICAgICBjb25zdCBiYXRjaFN0cmlkZSA9IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbihpbnB1dHNbMF0uZGltcywgMSk7XG4gICAgICBjb25zdCBzZXF1ZW5jZUxlbmd0aCA9IGlucHV0c1swXS5kaW1zW2lucHV0c1swXS5kaW1zLmxlbmd0aCAtIDJdO1xuICAgICAgY29uc3QgaGlkZGVuU2l6ZSA9IGJhdGNoU3RyaWRlIC8gc2VxdWVuY2VMZW5ndGg7XG4gICAgICBjb25zdCBoYWxmUm90YXJ5RW1iZWRkaW5nRGltID0gaW5wdXRzWzJdLmRpbXNbMV07XG4gICAgICBjb25zdCBoZWFkU2l6ZSA9IHJvdGFyeUVtYmVkZGluZ0RpbSA9PT0gMCA/IGhhbGZSb3RhcnlFbWJlZGRpbmdEaW0gKiAyIDogaGlkZGVuU2l6ZSAvIG51bUhlYWRzO1xuXG4gICAgICAvLyBSb3RhcnkgZW1iZWRkaW5ncyB3aWxsIGJlIGNhbGN1bGF0ZWQgaW4gYSBwYWlyLXdpc2UgZmFzaGlvbi4gSW4gYWNjb3JkYW5jZSwgdXNlIHRoZSBzaGFwZVxuICAgICAgLy8gW2JhdGNoIHNpemUsIHNlcXVlbmNlIGxlbmd0aCwgbnVtIG9mIGhlYWRzLCBudW0gb2YgcGFpcnMgdG8gcm90YXRlICsgbnVtIG9mIGRpbXMgdG8gY29weV1cbiAgICAgIC8vIHRvIHVuZm9sZCB0aGUgZ2xvYmFsIGluZGV4IGluIHNoYWRlci5cbiAgICAgIGNvbnN0IGdsb2JhbFNoYXBlID1cbiAgICAgICAgICBuZXcgQXJyYXk8bnVtYmVyPihiYXRjaFNpemUsIHNlcXVlbmNlTGVuZ3RoLCBoaWRkZW5TaXplIC8gaGVhZFNpemUsIGhlYWRTaXplIC0gaGFsZlJvdGFyeUVtYmVkZGluZ0RpbSk7XG4gICAgICBjb25zdCBnbG9iYWxTdHJpZGVzID0gU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGdsb2JhbFNoYXBlKTtcblxuICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgICAgICB7dHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IHNjYWxlfSxcbiAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZ2xvYmFsU2hhcGV9LFxuICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBnbG9iYWxTdHJpZGVzfSxcblxuICAgICAgICAvLyBzdHJpZGVzIGZvciBhZGRyZXNzaW5nIHRoZSBpbnB1dC9vdXRwdXQgdGVuc29yLCBpbiBwZXJtdXRhdGVkIG9yZGVyIHRvIGFsaWduIHdpdGggdGhlIHVuZm9sZGVkIGdsb2JhbCBpbmRleCxcbiAgICAgICAgLy8gaS5lLiBCU05IXG4gICAgICAgIC4uLihpbnB1dHNbMF0uZGltcy5sZW5ndGggPT09IDMgP1xuICAgICAgICAgICAgICAgIG5ldyBBcnJheTxQcm9ncmFtVW5pZm9ybT4oe3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogW2JhdGNoU3RyaWRlLCBoaWRkZW5TaXplLCBoZWFkU2l6ZSwgMV19KSA6XG4gICAgICAgICAgICAgICAgW10pLFxuICAgICAgICAuLi4oaW5wdXRzWzBdLmRpbXMubGVuZ3RoID09PSA0ID9cbiAgICAgICAgICAgICAgICBuZXcgQXJyYXk8UHJvZ3JhbVVuaWZvcm0+KFxuICAgICAgICAgICAgICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBbYmF0Y2hTdHJpZGUsIGhlYWRTaXplLCBzZXF1ZW5jZUxlbmd0aCAqIGhlYWRTaXplLCAxXX0pIDpcbiAgICAgICAgICAgICAgICBbXSksXG5cbiAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zLCBpbnB1dHNbMl0uZGltcywgaW5wdXRzWzNdLmRpbXMsIGlucHV0c1swXS5kaW1zKSxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBwb3NpdGlvbklkcyA9IGlucHV0VmFyaWFibGUoJ3Bvc2l0aW9uX2lkcycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgY29zQ2FjaGUgPSBpbnB1dFZhcmlhYmxlKCdjb3NfY2FjaGUnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHNpbkNhY2hlID0gaW5wdXRWYXJpYWJsZSgnc2luX2NhY2hlJywgaW5wdXRzWzNdLmRhdGFUeXBlLCBpbnB1dHNbM10uZGltcy5sZW5ndGgpO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuXG4gICAgICAgIHNoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKFtcbiAgICAgICAgICB7bmFtZTogJ3NjYWxlJywgdHlwZTogJ2YzMid9LFxuICAgICAgICAgIHtuYW1lOiAnZ2xvYmFsX3NoYXBlJywgdHlwZTogJ3UzMicsIGxlbmd0aDogZ2xvYmFsU2hhcGUubGVuZ3RofSxcbiAgICAgICAgICB7bmFtZTogJ2dsb2JhbF9zdHJpZGVzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogZ2xvYmFsU3RyaWRlcy5sZW5ndGh9LFxuICAgICAgICAgIHtuYW1lOiAnaW5wdXRfb3V0cHV0X3N0cmlkZXMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBnbG9iYWxTdHJpZGVzLmxlbmd0aH0sXG4gICAgICAgIF0pO1xuXG4gICAgICAgIHJldHVybiBgXG4gICAgICAgICR7c2hhZGVySGVscGVyLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIHBvc2l0aW9uSWRzLCBjb3NDYWNoZSwgc2luQ2FjaGUsIG91dHB1dCl9XG5cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFdPUktHUk9VUF9TSVpFKX1cbiAgICAgICAgICBsZXQgaGFsZl9yb3RhcnlfZW1iX2RpbSA9IHVuaWZvcm1zLiR7Y29zQ2FjaGUubmFtZX1fc2hhcGVbMV07XG4gICAgICAgICAgbGV0IGJzbmggPSBnbG9iYWxfaWR4IC8gdW5pZm9ybXMuZ2xvYmFsX3N0cmlkZXMgJSB1bmlmb3Jtcy5nbG9iYWxfc2hhcGU7XG4gICAgICAgICAgbGV0IHNpemUgPSB1bmlmb3Jtcy5nbG9iYWxfc2hhcGVbMF0gKiB1bmlmb3Jtcy5nbG9iYWxfc3RyaWRlc1swXTtcbiAgICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCdzaXplJyl9XG5cbiAgICAgICAgICBpZiAoYnNuaFszXSA8IGhhbGZfcm90YXJ5X2VtYl9kaW0pIHtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbl9pZHNfaWR4ID1cbiAgICAgICAgICAgICAgICAke3Bvc2l0aW9uSWRzLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KCdic25oLnh5Jywgb3V0cHV0VmFyaWFibGUoJycsIHBvc2l0aW9uSWRzLnR5cGUudGVuc29yLCAyKSl9O1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uX2lkID1cbiAgICAgICAgICAgICAgICB1MzIoJHtwb3NpdGlvbklkcy5nZXRCeU9mZnNldCgncG9zaXRpb25faWRzX2lkeCcpfSkgKyBzZWxlY3QoMCwgYnNuaFsxXSwgcG9zaXRpb25faWRzX2lkeCA9PSAwKTtcbiAgICAgICAgICAgIGxldCBpID0gZG90KGJzbmgsIHVuaWZvcm1zLmlucHV0X291dHB1dF9zdHJpZGVzKSArIHNlbGVjdCgwLCBic25oWzNdLCAke2ludGVybGVhdmVkfSk7XG4gICAgICAgICAgICBsZXQgaiA9IGkgKyBzZWxlY3QoaGFsZl9yb3RhcnlfZW1iX2RpbSwgMSwgJHtpbnRlcmxlYXZlZH0pO1xuICAgICAgICAgICAgbGV0IHJlID0gJHtpbnB1dC5nZXRCeU9mZnNldCgnaScpfSAqICR7Y29zQ2FjaGUuZ2V0KCdwb3NpdGlvbl9pZCcsICdic25oWzNdJyl9IC1cbiAgICAgICAgICAgICAgICAke2lucHV0LmdldEJ5T2Zmc2V0KCdqJyl9ICogJHtzaW5DYWNoZS5nZXQoJ3Bvc2l0aW9uX2lkJywgJ2JzbmhbM10nKX07XG4gICAgICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnaScsICdyZScpfVxuICAgICAgICAgICAgbGV0IGltID0gJHtpbnB1dC5nZXRCeU9mZnNldCgnaScpfSAqICR7c2luQ2FjaGUuZ2V0KCdwb3NpdGlvbl9pZCcsICdic25oWzNdJyl9ICtcbiAgICAgICAgICAgICAgICAke2lucHV0LmdldEJ5T2Zmc2V0KCdqJyl9ICogJHtjb3NDYWNoZS5nZXQoJ3Bvc2l0aW9uX2lkJywgJ2JzbmhbM10nKX07XG4gICAgICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnaicsICdpbScpfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgayA9IGRvdChic25oLCB1bmlmb3Jtcy5pbnB1dF9vdXRwdXRfc3RyaWRlcykgKyBoYWxmX3JvdGFyeV9lbWJfZGltO1xuICAgICAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2snLCBpbnB1dC5nZXRCeU9mZnNldCgnaycpKX1cbiAgICAgICAgICB9XG4gICAgICAgIH1gO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ1JvdGFyeUVtYmVkZGluZycsXG4gICAgICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICAgICAgaGludDogY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtcbiAgICAgICAgICAgICAgICAgIGludGVybGVhdmVkLFxuICAgICAgICAgICAgICAgIH0pLmNhY2hlS2V5LFxuICAgICAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnLCAncmFuaycsICdyYW5rJywgJ3JhbmsnXSxcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICAgIG91dHB1dHM6IFt7ZGltczogaW5wdXRzWzBdLmRpbXMsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGV9XSxcbiAgICAgICAgICBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKGdsb2JhbFNoYXBlKSAvIFdPUktHUk9VUF9TSVpFKX0sXG4gICAgICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgICAgICB9KSxcbiAgICAgIH07XG4gICAgfTtcblxuZXhwb3J0IGNvbnN0IHJvdGFyeUVtYmVkZGluZyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUm90YXJ5RW1iZWRkaW5nQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVSb3RhcnlFbWJlZGRpbmdQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcykpO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm19IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjYXN0VG9GMzIsIGdldE1heENvbXBvbmVudHMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIHN1bVZlY3RvciwgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLCBVbmlmb3Jtc0FycmF5VHlwZX0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNraXBMYXllck5vcm1BdHRyaWJ1dGVzIHtcbiAgc2ltcGxpZmllZDogYm9vbGVhbjtcbiAgZXBzaWxvbjogbnVtYmVyO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMykge1xuICAgIHRocm93IG5ldyBFcnJvcignbGF5ZXJOb3JtIHJlcXVpcmVzIGF0IGxlYXN0IDMgaW5wdXRzLicpO1xuICB9XG5cbiAgY29uc3QgaW5wdXQ6IFRlbnNvclZpZXcgPSBpbnB1dHNbMF07XG4gIGNvbnN0IHNraXA6IFRlbnNvclZpZXcgPSBpbnB1dHNbMV07XG4gIGNvbnN0IGdhbW1hOiBUZW5zb3JWaWV3ID0gaW5wdXRzWzJdO1xuXG4gIGlmIChpbnB1dC5kYXRhVHlwZSAhPT0gc2tpcC5kYXRhVHlwZSB8fCBpbnB1dC5kYXRhVHlwZSAhPT0gZ2FtbWEuZGF0YVR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsbCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZScpO1xuICB9XG5cbiAgaWYgKGlucHV0LmRpbXMubGVuZ3RoICE9PSAzICYmIGlucHV0LmRpbXMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBtdXN0IGJlIDJEIG9yIDNEJyk7XG4gIH1cblxuICBpZiAoc2tpcC5kaW1zLmxlbmd0aCAhPT0gMyAmJiBza2lwLmRpbXMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTa2lwIG11c3QgYmUgMkQgb3IgM0QnKTtcbiAgfVxuXG4gIGNvbnN0IGhpZGRlblNpemUgPSBpbnB1dC5kaW1zW2lucHV0LmRpbXMubGVuZ3RoIC0gMV07XG4gIGNvbnN0IHNlcXVlbmNlTGVuZ3RoID0gaW5wdXQuZGltc1tpbnB1dC5kaW1zLmxlbmd0aCAtIDJdO1xuICBpZiAoc2tpcC5kaW1zW3NraXAuZGltcy5sZW5ndGggLSAxXSAhPT0gaGlkZGVuU2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2tpcCBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXQnKTtcbiAgfVxuICBpZiAoc2tpcC5kaW1zW3NraXAuZGltcy5sZW5ndGggLSAyXSAhPT0gc2VxdWVuY2VMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NraXAgbXVzdCBoYXZlIHRoZSBzYW1lIHNlcXVlbmNlIGxlbmd0aCBhcyBpbnB1dCcpO1xuICB9XG5cbiAgaWYgKGdhbW1hLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHYW1tYSBtdXN0IGJlIDFEJyk7XG4gIH1cbiAgaWYgKGdhbW1hLmRpbXNbZ2FtbWEuZGltcy5sZW5ndGggLSAxXSAhPT0gaGlkZGVuU2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignR2FtbWEgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0Jyk7XG4gIH1cbiAgaWYgKGlucHV0cy5sZW5ndGggPiAzKSB7XG4gICAgY29uc3QgYmV0YTogVGVuc29yVmlldyA9IGlucHV0c1szXTtcbiAgICBpZiAoYmV0YS5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCZXRhIG11c3QgYmUgMUQnKTtcbiAgICB9XG4gICAgaWYgKGJldGEuZGltc1tiZXRhLmRpbXMubGVuZ3RoIC0gMV0gIT09IGhpZGRlblNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmV0YSBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXQnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlucHV0cy5sZW5ndGggPiA0KSB7XG4gICAgY29uc3QgYmlhczogVGVuc29yVmlldyA9IGlucHV0c1s0XTtcbiAgICBpZiAoYmlhcy5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCaWFzIG11c3QgYmUgMUQnKTtcbiAgICB9XG4gICAgaWYgKGJpYXMuZGltc1tiaWFzLmRpbXMubGVuZ3RoIC0gMV0gIT09IGhpZGRlblNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmlhcyBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXQnKTtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZVNraXBMYXllck5vcm1Qcm9ncmFtSW5mbyA9XG4gICAgKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBTa2lwTGF5ZXJOb3JtQXR0cmlidXRlcywgb3V0cHV0Q291bnQ6IG51bWJlciwgaXNUcmFpbmluZzogYm9vbGVhbik6XG4gICAgICAgIFByb2dyYW1JbmZvID0+IHtcbiAgICAgICAgICBjb25zdCBzaW1wbGlmaWVkID0gYXR0cmlidXRlcy5zaW1wbGlmaWVkO1xuXG4gICAgICAgICAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICAgICAgICAgIGNvbnN0IGlucHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKGlucHV0U2hhcGUpO1xuICAgICAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZTtcbiAgICAgICAgICBjb25zdCBvdXRwdXRTaXplID0gaW5wdXRTaXplO1xuICAgICAgICAgIGNvbnN0IGhpZGRlblNpemUgPSBpbnB1dFNoYXBlLnNsaWNlKC0xKVswXTtcbiAgICAgICAgICBjb25zdCBtZWFuSW52U3RkRGV2RGltID0gaXNUcmFpbmluZyA/IGlucHV0U2hhcGUuc2xpY2UoMCwgLTEpLmNvbmNhdCgxKSA6IFtdO1xuICAgICAgICAgIGNvbnN0IGhhc0JldGFJbnB1dCA9ICFzaW1wbGlmaWVkICYmIGlucHV0cy5sZW5ndGggPiAzO1xuICAgICAgICAgIGNvbnN0IGhhc0JpYXNJbnB1dCA9IGlucHV0cy5sZW5ndGggPiA0O1xuICAgICAgICAgIGNvbnN0IGhhc01lYW5PdXRwdXQgPSBpc1RyYWluaW5nICYmIG91dHB1dENvdW50ID4gMTtcbiAgICAgICAgICBjb25zdCBoYXNJbnZTdGREZXZPdXRwdXQgPSBpc1RyYWluaW5nICYmIG91dHB1dENvdW50ID4gMjtcbiAgICAgICAgICBjb25zdCBoYXNJbnB1dFNraXBCaWFzU3VtT3V0cHV0ID0gb3V0cHV0Q291bnQgPiAzO1xuICAgICAgICAgIGNvbnN0IHdvcmtncm91cFNpemUgPSA2NDtcblxuICAgICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKGhpZGRlblNpemUpO1xuXG4gICAgICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgICAgICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZX0sXG4gICAgICAgICAgICB7dHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBjb21wb25lbnRzfSxcbiAgICAgICAgICAgIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGhpZGRlblNpemV9LFxuICAgICAgICAgICAge3R5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBhdHRyaWJ1dGVzLmVwc2lsb259LFxuICAgICAgICAgIF07XG4gICAgICAgICAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB1bmlmb3Jtc0FycmF5OiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgICAgICAgICAge25hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInfSxcbiAgICAgICAgICAgICAge25hbWU6ICdjb21wb25lbnRzJywgdHlwZTogJ3UzMid9LFxuICAgICAgICAgICAgICB7bmFtZTogJ2hpZGRlbl9zaXplJywgdHlwZTogJ3UzMid9LFxuICAgICAgICAgICAgICB7bmFtZTogJ2Vwc2lsb24nLCB0eXBlOiAnZjMyJ30sXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29uc3QgdmFyaWFibGVzID0gW1xuICAgICAgICAgICAgICBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcywgY29tcG9uZW50cyksXG4gICAgICAgICAgICAgIGlucHV0VmFyaWFibGUoJ3NraXAnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zLCBjb21wb25lbnRzKSxcbiAgICAgICAgICAgICAgaW5wdXRWYXJpYWJsZSgnZ2FtbWEnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLCBjb21wb25lbnRzKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBpZiAoaGFzQmV0YUlucHV0KSB7XG4gICAgICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKGlucHV0VmFyaWFibGUoJ2JldGEnLCBpbnB1dHNbM10uZGF0YVR5cGUsIGlucHV0c1szXS5kaW1zLCBjb21wb25lbnRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzQmlhc0lucHV0KSB7XG4gICAgICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbNF0uZGF0YVR5cGUsIGlucHV0c1s0XS5kaW1zLCBjb21wb25lbnRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgY29tcG9uZW50cykpO1xuICAgICAgICAgICAgaWYgKGhhc01lYW5PdXRwdXQpIHtcbiAgICAgICAgICAgICAgdmFyaWFibGVzLnB1c2gob3V0cHV0VmFyaWFibGUoJ21lYW5fb3V0cHV0JywgRGF0YVR5cGUuZmxvYXQsIG1lYW5JbnZTdGREZXZEaW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNJbnZTdGREZXZPdXRwdXQpIHtcbiAgICAgICAgICAgICAgdmFyaWFibGVzLnB1c2gob3V0cHV0VmFyaWFibGUoJ2ludl9zdGRfb3V0cHV0JywgRGF0YVR5cGUuZmxvYXQsIG1lYW5JbnZTdGREZXZEaW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNJbnB1dFNraXBCaWFzU3VtT3V0cHV0KSB7XG4gICAgICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKG91dHB1dFZhcmlhYmxlKCdpbnB1dF9za2lwX2JpYXNfc3VtJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgY29tcG9uZW50cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgICAgICAgICAgIGNvbnN0IHZlY0RhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKERhdGFUeXBlLmZsb2F0LCBjb21wb25lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBgXG5cbiAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXNBcnJheSkuZGVjbGFyZVZhcmlhYmxlcyguLi52YXJpYWJsZXMpfVxuICAgICAgdmFyPHdvcmtncm91cD4gc3VtX3NoYXJlZCA6IGFycmF5PCR7dmVjRGF0YVR5cGV9LCAke3dvcmtncm91cFNpemV9PjtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHN1bV9zcXVhcmVkX3NoYXJlZCA6IGFycmF5PCR7dmVjRGF0YVR5cGV9LCAke3dvcmtncm91cFNpemV9PjtcblxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFtcbiAgICAgICAgICAgICAgd29ya2dyb3VwU2l6ZSwgMSwgMVxuICAgICAgICAgICAgXSl9XG4gICAgICAgIGxldCBpeCA9IGxvY2FsX2lkLng7XG4gICAgICAgIGxldCBpeSA9IGdsb2JhbF9pZC54IC8gJHt3b3JrZ3JvdXBTaXplfTtcblxuICAgICAgICBsZXQgaGlkZGVuX3NpemVfdmVjdG9yaXplZDogdTMyID0gdW5pZm9ybXMuaGlkZGVuX3NpemUgLyB1bmlmb3Jtcy5jb21wb25lbnRzO1xuICAgICAgICB2YXIgc3RyaWRlID0gaGlkZGVuX3NpemVfdmVjdG9yaXplZCAvICR7d29ya2dyb3VwU2l6ZX07XG4gICAgICAgIGxldCBvZmZzZXQgPSBpeCAqIHN0cmlkZSArIGl5ICogaGlkZGVuX3NpemVfdmVjdG9yaXplZDtcbiAgICAgICAgbGV0IG9mZnNldDFkID0gc3RyaWRlICogaXg7XG4gICAgICAgIGlmIChpeCA9PSAke3dvcmtncm91cFNpemUgLSAxfSkge1xuICAgICAgICAgIHN0cmlkZSA9IGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQgLSBzdHJpZGUgKiBpeDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgc3RyaWRlOyBpKyspIHtcbiAgICAgICAgICBsZXQgc2tpcF92YWx1ZSA9IHNraXBbb2Zmc2V0ICsgaV07XG4gICAgICAgICAgbGV0IGJpYXNfdmFsdWUgPSAke2hhc0JpYXNJbnB1dCA/ICdiaWFzW29mZnNldDFkICsgaV0nIDogZGF0YVR5cGUgKyAnKDAuMCknfTtcbiAgICAgICAgICBsZXQgaW5wdXRfdmFsdWUgPSB4W29mZnNldCArIGldO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGlucHV0X3ZhbHVlICsgc2tpcF92YWx1ZSArIGJpYXNfdmFsdWU7XG4gICAgICAgICAgJHtoYXNJbnB1dFNraXBCaWFzU3VtT3V0cHV0ID8gJ2lucHV0X3NraXBfYmlhc19zdW1bb2Zmc2V0ICsgaV0gPSB2YWx1ZTsnIDogJyd9XG4gICAgICAgICAgb3V0cHV0W29mZnNldCArIGldID0gdmFsdWU7XG4gICAgICAgICAgbGV0IGYzMl92YWx1ZSA9ICR7Y2FzdFRvRjMyKGRhdGFUeXBlLCBjb21wb25lbnRzLCAndmFsdWUnKX07XG4gICAgICAgICAgc3VtX3NoYXJlZFtpeF0gKz0gZjMyX3ZhbHVlO1xuICAgICAgICAgIHN1bV9zcXVhcmVkX3NoYXJlZFtpeF0gKz0gZjMyX3ZhbHVlICogZjMyX3ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICB2YXIgcmVkdWNlX3NpemUgOiB1MzIgPSAke3dvcmtncm91cFNpemV9O1xuICAgICAgICBmb3IgKHZhciBjdXJyX3NpemUgPSByZWR1Y2Vfc2l6ZSA+PiAxOyAgY3Vycl9zaXplID4gMDsgY3Vycl9zaXplID0gcmVkdWNlX3NpemUgPj4gMSkge1xuICAgICAgICAgIHJlZHVjZV9zaXplID0gY3Vycl9zaXplICsgKHJlZHVjZV9zaXplICYgMSk7XG4gICAgICAgICAgaWYgKGl4IDwgY3Vycl9zaXplKSB7XG4gICAgICAgICAgICBzdW1fc2hhcmVkW2l4XSArPSBzdW1fc2hhcmVkW2l4ICsgcmVkdWNlX3NpemVdO1xuICAgICAgICAgICAgc3VtX3NxdWFyZWRfc2hhcmVkW2l4XSArPSBzdW1fc3F1YXJlZF9zaGFyZWRbaXggKyByZWR1Y2Vfc2l6ZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdW0gPSBzdW1fc2hhcmVkWzBdO1xuICAgICAgICBsZXQgc3F1YXJlX3N1bSA9IHN1bV9zcXVhcmVkX3NoYXJlZFswXTtcbiAgICAgICAgbGV0IG1lYW4gPSAke3N1bVZlY3Rvcignc3VtJywgY29tcG9uZW50cyl9IC8gZjMyKHVuaWZvcm1zLmhpZGRlbl9zaXplKTtcbiAgICAgICAgbGV0IGludl9zdGRfZGV2ID0gaW52ZXJzZVNxcnQoJHtzdW1WZWN0b3IoJ3NxdWFyZV9zdW0nLCBjb21wb25lbnRzKX0gLyBmMzIodW5pZm9ybXMuaGlkZGVuX3NpemUpICR7XG4gICAgICAgICAgICAgICAgc2ltcGxpZmllZCA/ICcnIDogJy0gbWVhbiAqIG1lYW4nfSArIHVuaWZvcm1zLmVwc2lsb24pO1xuICAgICAgICAke2hhc01lYW5PdXRwdXQgPyAnbWVhbl9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBtZWFuOycgOiAnJ31cbiAgICAgICAgJHtoYXNJbnZTdGREZXZPdXRwdXQgPyAnaW52X3N0ZF9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnZfc3RkX2RldjsnIDogJyd9XG5cbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHN0cmlkZTsgaSsrKSB7XG4gICAgICAgICAgb3V0cHV0W29mZnNldCArIGldID0gKG91dHB1dFtvZmZzZXQgKyBpXSAke3NpbXBsaWZpZWQgPyAnJyA6IGAtICR7ZGF0YVR5cGV9KG1lYW4pYH0pICpcbiAgICAgICAgICAgICR7ZGF0YVR5cGV9KGludl9zdGRfZGV2KSAqIGdhbW1hW29mZnNldDFkICsgaV1cbiAgICAgICAgICAgICR7aGFzQmV0YUlucHV0ID8gJysgYmV0YVtvZmZzZXQxZCArIGldJyA6ICcnfTtcbiAgICAgICAgfVxuICAgICAgfWA7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBvdXRwdXRzID0gW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX1dO1xuICAgICAgICAgIGlmIChvdXRwdXRDb3VudCA+IDEpIHtcbiAgICAgICAgICAgIG91dHB1dHMucHVzaCh7ZGltczogbWVhbkludlN0ZERldkRpbSwgZGF0YVR5cGU6IERhdGFUeXBlLmZsb2F0fSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvdXRwdXRDb3VudCA+IDIpIHtcbiAgICAgICAgICAgIG91dHB1dHMucHVzaCh7ZGltczogbWVhbkludlN0ZERldkRpbSwgZGF0YVR5cGU6IERhdGFUeXBlLmZsb2F0fSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvdXRwdXRDb3VudCA+IDMpIHtcbiAgICAgICAgICAgIG91dHB1dHMucHVzaCh7ZGltczogaW5wdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogJ1NraXBMYXllck5vcm1hbGl6YXRpb24nLFxuICAgICAgICAgICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgICAgICAgICAgaGludDogYCR7Y29tcG9uZW50c307JHtoYXNNZWFuT3V0cHV0fTske2hhc0ludlN0ZERldk91dHB1dH07JHtoYXNJbnB1dFNraXBCaWFzU3VtT3V0cHV0fWAsXG4gICAgICAgICAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiBpbnB1dHMubWFwKChfaW5wdXQsIF9pbmRleCkgPT4gJ3R5cGUnKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICAgICAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgICAgICAgIG91dHB1dHMsXG4gICAgICAgICAgICAgIGRpc3BhdGNoR3JvdXA6IHtcbiAgICAgICAgICAgICAgICB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIGhpZGRlblNpemUpLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBwcm9ncmFtVW5pZm9ybXNcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbmV4cG9ydCBjb25zdCBza2lwTGF5ZXJOb3JtID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBTa2lwTGF5ZXJOb3JtQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICAvLyBUT0RPOiBpbml0aWFsaXplIGlzVHJhaW5pbmcgZnJvbSBDb21wdXRlQ29udGV4dFxuICBjb25zdCBpc1RyYWluaW5nID0gZmFsc2U7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgLy8gTWVhbiBhbmQgSW52U3RkRGV2IGFyZSBvbmx5IHVzZWQgaW4gdHJhaW5pbmcgbW9kZSBhbmQgYXJlIG5vdCByZXF1aXJlZCBmb3IgaW5mZXJlbmNlLlxuICAvLyBUaGV5IGFyZSBhZGRlZCBoZXJlIGZvciBjb21wbGV0ZW5lc3Mgb25seS5cbiAgY29uc3Qgb3V0cHV0cyA9IFswXTtcbiAgaWYgKGNvbnRleHQub3V0cHV0Q291bnQgPiAxKSB7XG4gICAgb3V0cHV0cy5wdXNoKGlzVHJhaW5pbmcgPyAxIDogLTMpO1xuICB9XG4gIGlmIChjb250ZXh0Lm91dHB1dENvdW50ID4gMikge1xuICAgIG91dHB1dHMucHVzaChpc1RyYWluaW5nID8gMiA6IC0zKTtcbiAgfVxuICBpZiAoY29udGV4dC5vdXRwdXRDb3VudCA+IDMpIHtcbiAgICBvdXRwdXRzLnB1c2goMyk7XG4gIH1cbiAgY29udGV4dC5jb21wdXRlKFxuICAgICAgY3JlYXRlU2tpcExheWVyTm9ybVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzLCBjb250ZXh0Lm91dHB1dENvdW50LCBpc1RyYWluaW5nKSwge291dHB1dHN9KTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybSwgVGVuc29ySW5mb30gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBnZXRFbGVtZW50QXQsIEluZGljZXNIZWxwZXIsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIFVuaWZvcm1zQXJyYXlUeXBlfSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpY2VBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgc3RhcnRzOiBudW1iZXJbXTtcbiAgcmVhZG9ubHkgZW5kczogbnVtYmVyW107XG4gIHJlYWRvbmx5IGF4ZXM6IG51bWJlcltdO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogU2xpY2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0b28gZmV3IGlucHV0cycpO1xuICB9XG4gIGlmIChhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgaWYgKGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggIT09IGF0dHJpYnV0ZXMuc3RhcnRzLmxlbmd0aCB8fCBhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoICE9PSBhdHRyaWJ1dGVzLmVuZHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F4ZXMsIHN0YXJ0cyBhbmQgZW5kcyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXMuc3RhcnRzLmxlbmd0aCAhPT0gYXR0cmlidXRlcy5lbmRzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc3RhcnRzIGFuZCBlbmRzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGgnKTtcbiAgfVxuICBpbnB1dHMuc2xpY2UoMSkuZm9yRWFjaCgoXywgaWR4KSA9PiB7XG4gICAgaWYgKGlucHV0c1tpZHggKyAxXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuaW50MzIgJiYgaW5wdXRzW2lkeCArIDFdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5pbnQ2NCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAke2lkeH0gbXVzdCBiZSBhbiBhcnJheSBvZiBpbnQzMiBvciBpbnQ2NGApO1xuICAgIH1cbiAgfSk7XG59O1xuXG5jb25zdCByZWFkSW5wdXQgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGlkeDogbnVtYmVyKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCBpbnB1dDogbnVtYmVyW10gPSBbXTtcbiAgaWYgKGlucHV0cy5sZW5ndGggPiBpZHgpIHtcbiAgICBpZiAoaW5wdXRzW2lkeF0uZGF0YVR5cGUgPT09IERhdGFUeXBlLmludDY0KSB7XG4gICAgICBpbnB1dHNbaWR4XS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaCh2ID0+IGlucHV0LnB1c2goTnVtYmVyKHYpKSk7XG4gICAgfSBlbHNlIGlmIChpbnB1dHNbaWR4XS5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuaW50MzIpIHtcbiAgICAgIGlucHV0c1tpZHhdLmdldEludDMyQXJyYXkoKS5mb3JFYWNoKHYgPT4gaW5wdXQucHVzaChOdW1iZXIodikpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAke2lkeH0gbXVzdCBiZSBhbiBhcnJheSBvZiBpbnQzMiBvciBpbnQ2NGApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5jb25zdCBjcmVhdGVTbGljZUF0dHJpYnV0ZXNGcm9tSW5wdXRzID1cbiAgICAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFNsaWNlQXR0cmlidXRlcyk6IFNsaWNlQXR0cmlidXRlcyA9PiB7XG4gICAgICBpZiAoaW5wdXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRzOiBudW1iZXJbXSA9IHJlYWRJbnB1dChpbnB1dHMsIDEpO1xuICAgICAgICBjb25zdCBlbmRzOiBudW1iZXJbXSA9IHJlYWRJbnB1dChpbnB1dHMsIDIpO1xuICAgICAgICBsZXQgYXhlczogbnVtYmVyW10gPSByZWFkSW5wdXQoaW5wdXRzLCAzKTtcbiAgICAgICAgaWYgKGF4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgYXhlcyA9IFsuLi5BcnJheShpbnB1dHNbMF0uZGltcy5sZW5ndGgpLmtleXMoKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7c3RhcnRzLCBlbmRzLCBheGVzfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICAgIH1cbiAgICB9O1xuXG5jb25zdCBmaXhTdGFydEVuZFZhbHVlcyA9XG4gICAgKHZhbHVlOiBudW1iZXIsIGluZGV4OiBudW1iZXIsIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCBheGVzOiByZWFkb25seSBudW1iZXJbXSwgc3RlcHM6IHJlYWRvbmx5IG51bWJlcltdKTpcbiAgICAgICAgbnVtYmVyID0+IHtcbiAgICAgICAgICBsZXQgbmV3VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSArPSBpbnB1dFNoYXBlW2F4ZXNbaW5kZXhdXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0ZXBzW2luZGV4XSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihuZXdWYWx1ZSwgaW5wdXRTaGFwZVtheGVzW2luZGV4XV0gLSAxKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihuZXdWYWx1ZSwgaW5wdXRTaGFwZVtheGVzW2luZGV4XV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbmNvbnN0IGNhbGN1bGF0ZUlucHV0SW5kaWNlc0ltcGwgPVxuICAgIChpbnB1dDogSW5kaWNlc0hlbHBlciwgb3V0cHV0OiBJbmRpY2VzSGVscGVyLCBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IHN0cmluZyA9PlxuICAgICAgICBgZm4gY2FsY3VsYXRlSW5wdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiAke2lucHV0LnR5cGUuaW5kaWNlc30ge1xuICAgICAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc307XG4gICAgICAgICAgdmFyIGNhcnJ5ID0gMHU7XG4gICAgICAgICAgZm9yICh2YXIgaSA9ICR7aW5wdXRTaGFwZS5sZW5ndGh9OyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGlucHV0X3NoYXBlX2kgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuaW5wdXRfc2hhcGUnLCAnaScsIGlucHV0U2hhcGUubGVuZ3RoKX07XG4gICAgICAgICAgICBsZXQgc3RlcHNfaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5zdGVwcycsICdpJywgaW5wdXRTaGFwZS5sZW5ndGgpfTtcbiAgICAgICAgICAgIGxldCBzaWduc19pID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnNpZ25zJywgJ2knLCBpbnB1dFNoYXBlLmxlbmd0aCl9O1xuICAgICAgICAgICAgbGV0IHN0YXJ0c19pID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnN0YXJ0cycsICdpJywgaW5wdXRTaGFwZS5sZW5ndGgpfTtcbiAgICAgICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICdpJyl9O1xuICAgICAgICAgICAgdmFyIGlucHV0X2luZGV4ID0gb3V0cHV0X2luZGV4ICogc3RlcHNfaSArIHN0YXJ0c19pICsgY2Fycnk7XG4gICAgICAgICAgICBjYXJyeSA9IGlucHV0X2luZGV4IC8gaW5wdXRfc2hhcGVfaTtcbiAgICAgICAgICAgIGlucHV0X2luZGV4ID0gaW5wdXRfaW5kZXggJSBpbnB1dF9zaGFwZV9pO1xuICAgICAgICAgICAgaWYgKHNpZ25zX2kgPCAwKSB7XG4gICAgICAgICAgICAgIGlucHV0X2luZGV4ID0gaW5wdXRfc2hhcGVfaSAtIGlucHV0X2luZGV4IC0gMXUgKyBzdGFydHNfaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsICdpJywgJ2lucHV0X2luZGV4Jyl9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaW5wdXRfaW5kaWNlcztcbiAgICAgIH1gO1xuXG5jb25zdCBjcmVhdGVTbGljZVByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBTbGljZUF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgaW5wdXRTaXplID0gU2hhcGVVdGlsLnNpemUoaW5wdXRTaGFwZSk7XG4gIGNvbnN0IGF4ZXMgPSAoYXR0cmlidXRlcy5heGVzLmxlbmd0aCA+IDApID8gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4ZXMoYXR0cmlidXRlcy5heGVzLCBpbnB1dFNoYXBlLmxlbmd0aCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsuLi5BcnJheShpbnB1dFNoYXBlLmxlbmd0aCkua2V5cygpXTtcbiAgbGV0IHN0ZXBzID0gcmVhZElucHV0KGlucHV0cywgNCk7XG4gIHN0ZXBzLmZvckVhY2goKHN0ZXApID0+IHN0ZXAgIT09IDAgfHwgKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0ZXAgY2Fubm90IGJlIDAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICBpZiAoc3RlcHMubGVuZ3RoID09PSAwKSB7XG4gICAgc3RlcHMgPSBBcnJheShheGVzLmxlbmd0aCkuZmlsbCgxKTtcbiAgfVxuICBjb25zdCBzdGFydHMgPSBhdHRyaWJ1dGVzLnN0YXJ0cy5tYXAoKHN0YXJ0LCBpKSA9PiBmaXhTdGFydEVuZFZhbHVlcyhzdGFydCwgaSwgaW5wdXRTaGFwZSwgYXhlcywgc3RlcHMpKTtcblxuICBjb25zdCBlbmRzID0gYXR0cmlidXRlcy5lbmRzLm1hcCgoZW5kLCBpKSA9PiBmaXhTdGFydEVuZFZhbHVlcyhlbmQsIGksIGlucHV0U2hhcGUsIGF4ZXMsIHN0ZXBzKSk7XG5cbiAgaWYgKGF4ZXMubGVuZ3RoICE9PSBzdGFydHMubGVuZ3RoIHx8IGF4ZXMubGVuZ3RoICE9PSBlbmRzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQsIGVuZHMgYW5kIGF4ZXMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzJyk7XG4gIH1cblxuICBpZiAoYXhlcy5sZW5ndGggIT09IGlucHV0U2hhcGUubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoIWF4ZXMuaW5jbHVkZXMoaSkpIHtcbiAgICAgICAgc3RhcnRzLnNwbGljZShpLCAwLCAwKTtcbiAgICAgICAgZW5kcy5zcGxpY2UoaSwgMCwgaW5wdXRTaGFwZVtpXSk7XG4gICAgICAgIHN0ZXBzLnNwbGljZShpLCAwLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3Qgc2lnbnMgPSBzdGVwcy5tYXAoc3RlcCA9PiBNYXRoLnNpZ24oc3RlcCkpO1xuICAvLyBDb252ZXJ0IG5lZ2F0aXZlIHN0ZXBzIHRvIHBvc2l0aXZlIHN0ZXBzIGFuZCByZXZlcnNlIHN0YXJ0cyBhbmQgZW5kc1xuICBzdGVwcy5mb3JFYWNoKChzdGVwLCBpLCBhcnJheSkgPT4ge1xuICAgIGlmIChzdGVwIDwgMCkge1xuICAgICAgY29uc3QgbnVtU3RlcHMgPSAoZW5kc1tpXSAtIHN0YXJ0c1tpXSkgLyBzdGVwO1xuICAgICAgY29uc3QgbmV3RW5kID0gc3RhcnRzW2ldO1xuICAgICAgY29uc3QgbmV3U3RhcnQgPSBuZXdFbmQgKyBudW1TdGVwcyAqIHN0ZXBzW2ldO1xuICAgICAgc3RhcnRzW2ldID0gbmV3U3RhcnQ7XG4gICAgICBlbmRzW2ldID0gbmV3RW5kO1xuICAgICAgYXJyYXlbaV0gPSAtc3RlcDtcbiAgICB9XG4gIH0pO1xuICAvLyBPdXRwdXQgcmFuayBpcyBleHBlY3RlZCB0byBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGlucHV0IHJhbmsuXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgwKTtcbiAgYXhlcy5mb3JFYWNoKChheGlzLCBfKSA9PiB7XG4gICAgb3V0cHV0U2hhcGVbYXhpc10gPSBNYXRoLmNlaWwoKGVuZHNbYXhpc10gLSBzdGFydHNbYXhpc10pIC8gc3RlcHNbYXhpc10pO1xuICB9KTtcbiAgY29uc3Qgb3V0cHV0VGVuc29ySW5mbzogVGVuc29ySW5mbyA9IHtkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX07XG5cbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoKTtcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgIHtuYW1lOiAnb3V0cHV0U2l6ZScsIHR5cGU6ICd1MzInfSwge25hbWU6ICdzdGFydHMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBzdGFydHMubGVuZ3RofSxcbiAgICB7bmFtZTogJ3NpZ25zJywgdHlwZTogJ2kzMicsIGxlbmd0aDogc2lnbnMubGVuZ3RofSwge25hbWU6ICdzdGVwcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IHN0ZXBzLmxlbmd0aH1cbiAgXTtcblxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZX0sIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHN0YXJ0c30sXG4gICAge3R5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBzaWduc30sIHt0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHN0ZXBzfSxcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgb3V0cHV0U2hhcGUpXG4gIF07XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxuICAgICAgICAke2NhbGN1bGF0ZUlucHV0SW5kaWNlc0ltcGwoaW5wdXQsIG91dHB1dCwgaW5wdXRTaGFwZSl9XG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICAgICAgbGV0IGlucHV0X2luZGljZXMgPSBjYWxjdWxhdGVJbnB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xuICAgICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgaW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJykpfVxuICAgICAgfWA7XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1NsaWNlJyxcbiAgICBzaGFkZXJDYWNoZToge2hpbnQ6IGAke3NpZ25zLmxlbmd0aH1fJHtzdGFydHMubGVuZ3RofV8ke3N0ZXBzLmxlbmd0aH1gLCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ119LFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW291dHB1dFRlbnNvckluZm9dLFxuICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChpbnB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zXG4gICAgfSlcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBzbGljZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogU2xpY2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgY29uc3QgdXBkYXRlZEF0dHJpYnV0ZXMgPSBjcmVhdGVTbGljZUF0dHJpYnV0ZXNGcm9tSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVNsaWNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIHVwZGF0ZWRBdHRyaWJ1dGVzKSwge2lucHV0czogWzBdfSk7XG4gIC8vIGlmIChTaGFwZVV0aWwuc2l6ZShwcm9ncmFtLm91dHB1dHNbMF0uZGltcykgPiAwKSB7XG4gIC8vICAgY29udGV4dC5jb21wdXRlKHByb2dyYW1JbmZvTG9hZGVyLCB7aW5wdXRzOiBbMF19KTtcbiAgLy8gfSBlbHNlIHtcbiAgLy8gICAvLyBUT0RPOiBzdXBwb3J0IGVtcHR5IG91dHB1dFxuICAvLyAgIHRocm93IG5ldyBFcnJvcignc2xpY2U6IG91dHB1dCBzaXplIGlzIDAnKTtcbiAgLy8gfVxufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlU2xpY2VBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogU2xpY2VBdHRyaWJ1dGVzID0+IHtcbiAgY29uc3Qgc3RhcnRzID0gYXR0cmlidXRlcy5zdGFydHMgYXMgbnVtYmVyW107XG4gIGNvbnN0IGVuZHMgPSBhdHRyaWJ1dGVzLmVuZHMgYXMgbnVtYmVyW107XG4gIGNvbnN0IGF4ZXMgPSBhdHRyaWJ1dGVzLmF4ZXMgYXMgbnVtYmVyW107XG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe3N0YXJ0cywgZW5kcywgYXhlc30pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLy8gVE9ETzogdGhpcyBpcyB0aGUgc2FtZSBuYWl2ZSBpbXBsZW1lbnRhdGlvbiB3ZSB1c2UgZm9yIHJlZHVjZSB0aGF0IGhhc1xuLy8gcGVyZm9ybWFuY2UgbGltaXRhdGlvbnMgd2hlbiB0aGUgcmVkdWNlZCBheGlzIGlzIGxvbmcuIE5lZWQgdG8gYWRkXG4vLyBhIG9wdGltaXplZCBjb2RlcGF0aCBmb3IgdGhpcy5cblxuaW1wb3J0IHtEYXRhVHlwZX0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtUZW5zb3JWaWV3fSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge0F0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5fSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm99IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtnZXRNYXhDb21wb25lbnRzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCBzdW1WZWN0b3IsIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZX0gZnJvbSAnLi9jb21tb24nO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTb2Z0bWF4IG9wIHJlcXVpcmVzIDEgaW5wdXQuJyk7XG4gIH1cbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgU29mdG1heEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBheGlzOiBudW1iZXI7XG59XG5cbmNvbnN0IGNyZWF0ZVNvZnRtYXhQcm9ncmFtSW5mbyA9IChpbnB1dDogVGVuc29yVmlldywgYXR0cmlidXRlczogU29mdG1heEF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IHNoYXBlID0gaW5wdXQuZGltcztcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKHNoYXBlKTtcbiAgY29uc3QgV0cgPSA2NDtcbiAgbGV0IGF4aXMgPSBhdHRyaWJ1dGVzLmF4aXM7XG4gIGlmIChheGlzIDwgMCkge1xuICAgIGF4aXMgPSBzaGFwZS5sZW5ndGggKyBheGlzO1xuICB9XG4gIGlmIChheGlzIDwgc2hhcGUubGVuZ3RoIC0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignc29mdG1heCBvbmx5IHN1cHBvcnRzIGxhc3QgYXhpcyBmb3Igbm93LicpO1xuICB9XG5cbiAgY29uc3QgY29scyA9IHNoYXBlW2F4aXNdO1xuICBjb25zdCByb3dzID0gb3V0cHV0U2l6ZSAvIGNvbHM7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKGNvbHMpO1xuICBjb25zdCBwYWNrZWRDb2xzID0gY29scyAvIGNvbXBvbmVudHM7XG5cbiAgY29uc3QgbWF4VmVjdG9yID0gKG5hbWU6IHN0cmluZywgY29tcG9uZW50czogbnVtYmVyKSA9PiB7XG4gICAgaWYgKGNvbXBvbmVudHMgPT09IDQpIHtcbiAgICAgIHJldHVybiBgbWF4KG1heCgke25hbWV9LngsICR7bmFtZX0ueSksIG1heCgke25hbWV9LnosICR7bmFtZX0udykpYDtcbiAgICB9IGVsc2UgaWYgKGNvbXBvbmVudHMgPT09IDIpIHtcbiAgICAgIHJldHVybiBgbWF4KCR7bmFtZX0ueCwgJHtuYW1lfS55KWA7XG4gICAgfSBlbHNlIGlmIChjb21wb25lbnRzID09PSAzKSB7XG4gICAgICByZXR1cm4gYG1heChtYXgoJHtuYW1lfS54LCAke25hbWV9LnkpLCAke25hbWV9LnopYDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZTtcbiAgfTtcbiAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoJ3gnLCBpbnB1dC5kYXRhVHlwZSwgaW5wdXQuZGltcywgY29tcG9uZW50cyk7XG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdyZXN1bHQnLCBpbnB1dC5kYXRhVHlwZSwgaW5wdXQuZGltcywgY29tcG9uZW50cyk7XG4gIGNvbnN0IHZhbHVlVHlwZSA9IHgudHlwZS52YWx1ZTtcbiAgLy8gNi4yLjQgaW4gd2dzbCBzcGVjXG4gIGNvbnN0IHRocmVhZE1heERlY2wgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXQuZGF0YVR5cGUpID09PSAnZjMyJyA/XG4gICAgICBgdmFyIHRocmVhZE1heCA9ICR7dmFsdWVUeXBlfSgtMy40MDI4MjNlKzM4Zik7YCA6XG4gICAgICBgdmFyIHRocmVhZE1heCA9ICR7dmFsdWVUeXBlfSgtNjU1MDQuMGgpO2A7XG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICAgICAgdmFyPHdvcmtncm91cD4gcm93TWF4U2hhcmVkIDogJHt2YWx1ZVR5cGV9O1xuICAgICAgdmFyPHdvcmtncm91cD4gcm93U3VtU2hhcmVkIDogJHt2YWx1ZVR5cGV9O1xuICAgICAgdmFyPHdvcmtncm91cD4gdGhyZWFkU2hhcmVkIDogYXJyYXk8JHt2YWx1ZVR5cGV9LCAke1dHfT47XG5cbiAgICAgIGZuIGdldFZhbHVlKHJvdzogaTMyLCBjb2w6IGkzMiwgcm93X3N0cmlkZTogaTMyKSAtPiAke3ZhbHVlVHlwZX0ge1xuICAgICAgICBsZXQgaW5kZXggPSByb3cgKiByb3dfc3RyaWRlICsgY29sO1xuICAgICAgICByZXR1cm4geFtpbmRleF07XG4gICAgICB9XG5cbiAgICAgIGZuIHNldFZhbHVlKHJvdzogaTMyLCBjb2w6IGkzMiwgcm93X3N0cmlkZTogaTMyLCB2YWx1ZTogJHt2YWx1ZVR5cGV9KSB7XG4gICAgICAgIGxldCBpbmRleCA9IHJvdyAqIHJvd19zdHJpZGUgKyBjb2w7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgncGFja2VkQ29scycsICdpMzInKS5kZWNsYXJlVmFyaWFibGVzKHgsIG91dHB1dCl9XG4gICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgbGV0IGdpbmRleCA9IGkzMihnbG9iYWxfaWR4KTtcbiAgICAgICAgbGV0IGxpbmRleCA9IGkzMihsb2NhbF9pZHgpO1xuICAgICAgICBjb25zdCB3ZyA9ICR7V0d9O1xuICAgICAgICBsZXQgcm93ID0gZ2luZGV4IC8gd2c7XG4gICAgICAgIGxldCBjb2xzID0gdW5pZm9ybXMucGFja2VkQ29scztcbiAgICAgICAgbGV0IHJvd19zdHJpZGUgOiBpMzIgPSB1bmlmb3Jtcy5wYWNrZWRDb2xzO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIHJvd3MgbWF4XG4gICAgICAgICR7dGhyZWFkTWF4RGVjbH1cbiAgICAgICAgZm9yICh2YXIgY29sID0gbGluZGV4OyBjb2wgPCBjb2xzOyBjb2wgKz0gd2cpIHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBnZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSk7XG4gICAgICAgICAgdGhyZWFkTWF4ID0gbWF4KHRocmVhZE1heCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5kZXggPCBjb2xzKSB7XG4gICAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRNYXg7XG4gICAgICAgIH1cbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIHZhciByZWR1Y2VTaXplID0gbWluKGNvbHMsIHdnKTtcbiAgICAgICAgZm9yICh2YXIgY3VyclNpemUgPSByZWR1Y2VTaXplID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gcmVkdWNlU2l6ZSA+PiAxKSB7XG4gICAgICAgICAgcmVkdWNlU2l6ZSA9IGN1cnJTaXplICsgKHJlZHVjZVNpemUgJiAxKTtcbiAgICAgICAgICBpZiAobGluZGV4IDwgY3VyclNpemUpIHtcbiAgICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gbWF4KHRocmVhZFNoYXJlZFtsaW5kZXhdLCB0aHJlYWRTaGFyZWRbbGluZGV4ICsgcmVkdWNlU2l6ZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmRleCA9PSAwKSB7XG4gICAgICAgICAgcm93TWF4U2hhcmVkID0gJHt2YWx1ZVR5cGV9KCR7bWF4VmVjdG9yKCd0aHJlYWRTaGFyZWRbMF0nLCBjb21wb25lbnRzKX0pO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAvLyBmaW5kIHRoZSByb3dzIHN1bVxuICAgICAgICB2YXIgdGhyZWFkU3VtID0gJHt2YWx1ZVR5cGV9KDAuMCk7XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHN1YkV4cCA9IGV4cChnZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSkgLSByb3dNYXhTaGFyZWQpO1xuICAgICAgICAgIHRocmVhZFN1bSArPSBzdWJFeHA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRTdW07XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHdnID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gY3VyclNpemUgPj4gMSkge1xuICAgICAgICAgIGlmIChsaW5kZXggPCBjdXJyU2l6ZSkge1xuICAgICAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRTaGFyZWRbbGluZGV4XSArIHRocmVhZFNoYXJlZFtsaW5kZXggKyBjdXJyU2l6ZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZGV4ID09IDApIHtcbiAgICAgICAgICByb3dTdW1TaGFyZWQgPSAke3ZhbHVlVHlwZX0oJHtzdW1WZWN0b3IoJ3RocmVhZFNoYXJlZFswXScsIGNvbXBvbmVudHMpfSk7XG4gICAgICAgIH1cbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSByb3dcbiAgICAgICAgZm9yICh2YXIgY29sID0gbGluZGV4OyBjb2wgPCBjb2xzOyBjb2wgKz0gd2cpIHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBleHAoZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpIC0gcm93TWF4U2hhcmVkKSAvIHJvd1N1bVNoYXJlZDtcbiAgICAgICAgICBzZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9YDtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnU29mdG1heCcsXG4gICAgc2hhZGVyQ2FjaGU6IHtoaW50OiBgJHtjb21wb25lbnRzfWAsIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3R5cGUnXX0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7ZGltczogc2hhcGUsIGRhdGFUeXBlOiBpbnB1dC5kYXRhVHlwZX1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IHJvd3N9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zOiBbe3R5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBwYWNrZWRDb2xzfV1cbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3Qgc29mdG1heCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogU29mdG1heEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlU29mdG1heFByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCBhdHRyaWJ1dGVzKSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VTb2Z0bWF4QXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFNvZnRtYXhBdHRyaWJ1dGVzID0+XG4gICAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtheGlzOiBhdHRyaWJ1dGVzLmF4aXMgYXMgbnVtYmVyfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleX0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7Q29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybSwgVGVuc29ySW5mb30gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge2NyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBnZXRFbGVtZW50QXQsIEluZGljZXNIZWxwZXIsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXJ9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBTcGxpdEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBheGlzOiBudW1iZXI7XG4gIHJlYWRvbmx5IG51bU91dHB1dHM6IG51bWJlcjtcbiAgcmVhZG9ubHkgc3BsaXRTaXplczogbnVtYmVyW107XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0b28gZmV3IGlucHV0cycpO1xuICB9XG59O1xuXG5jb25zdCBjcmVhdGVTcGxpdEF0dHJpYnV0ZXNGcm9tSW5wdXRzID1cbiAgICAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFNwbGl0QXR0cmlidXRlcyk6IFNwbGl0QXR0cmlidXRlcyA9PiB7XG4gICAgICBjb25zdCBzcGxpdFNpemVzOiBudW1iZXJbXSA9IFtdO1xuICAgICAgbGV0IG51bU91dHB1dHM6IG51bWJlciA9IGF0dHJpYnV0ZXMubnVtT3V0cHV0cztcbiAgICAgIGlmIChpbnB1dHNbMV0uZGltc1swXSA+IDApIHtcbiAgICAgICAgaW5wdXRzWzFdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKHYgPT4gc3BsaXRTaXplcy5wdXNoKE51bWJlcih2KSkpO1xuICAgICAgICBudW1PdXRwdXRzID0gc3BsaXRTaXplcy5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHtudW1PdXRwdXRzLCBheGlzOiBhdHRyaWJ1dGVzLmF4aXMsIHNwbGl0U2l6ZXN9KTtcbiAgICB9O1xuXG5jb25zdCBjYWxjdWxhdGVPdXRwdXRJbmRleEltcGwgPSAobnVtYmVyT2ZUZW5zb3JzOiBudW1iZXIpOiBzdHJpbmcgPT4gYFxuZm4gY2FsY3VsYXRlT3V0cHV0SW5kZXgoaW5kZXg6IHUzMikgLT4gdTMyIHtcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8ICR7bnVtYmVyT2ZUZW5zb3JzfXU7IGkgKz0gMXUgKSB7XG4gICAgaWYgKGluZGV4IDwgJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnNpemVfaW5fc3BsaXRfYXhpcycsICdpJywgbnVtYmVyT2ZUZW5zb3JzKX0pIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIH1cbiAgICByZXR1cm4gJHtudW1iZXJPZlRlbnNvcnN9dTtcbn1gO1xuY29uc3Qgd3JpdGVCdWZmZXJEYXRhSW1wbCA9IChvdXRwdXRzOiByZWFkb25seSBJbmRpY2VzSGVscGVyW10pID0+IHtcbiAgY29uc3QgbnVtYmVyT2ZUZW5zb3JzID0gb3V0cHV0cy5sZW5ndGg7XG4gIGNvbnN0IGNvZGVMaW5lczogc3RyaW5nW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlRlbnNvcnM7ICsraSkge1xuICAgIGNvbnN0IHJldHVyblNuaXBwZXQgPSBvdXRwdXRzW2ldLnNldEJ5SW5kaWNlcygnaW5kaWNlcycsICdpbnB1dFtnbG9iYWxfaWR4XScpO1xuICAgIGlmIChudW1iZXJPZlRlbnNvcnMgPT09IDEpIHtcbiAgICAgIGNvZGVMaW5lcy5wdXNoKHJldHVyblNuaXBwZXQpO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgY29kZUxpbmVzLnB1c2goYGlmIChvdXRwdXRfbnVtYmVyID09ICR7aX11KSB7ICR7cmV0dXJuU25pcHBldH0gfWApO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gbnVtYmVyT2ZUZW5zb3JzIC0gMSkge1xuICAgICAgY29kZUxpbmVzLnB1c2goYGVsc2UgeyAke3JldHVyblNuaXBwZXR9IH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZUxpbmVzLnB1c2goYGVsc2UgaWYgKG91dHB1dF9udW1iZXIgPT0gJHtpfSkgeyAke3JldHVyblNuaXBwZXR9IH1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGBcbiAgICAgIGZuIHdyaXRlQnVmZmVyRGF0YShvdXRwdXRfbnVtYmVyOiB1MzIsIGluZGljZXM6ICR7b3V0cHV0c1swXS50eXBlLmluZGljZXN9LCBnbG9iYWxfaWR4OiB1MzIpIHtcbiAgICAgICAgJHtjb2RlTGluZXMuam9pbignXFxuJyl9XG4gICAgICB9YDtcbn07XG5cbmNvbnN0IGNyZWF0ZVNwbGl0UHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFNwbGl0QXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBpbnB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShpbnB1dFNoYXBlKTtcbiAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XG4gIGNvbnN0IGF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhhdHRyaWJ1dGVzLmF4aXMsIGlucHV0U2hhcGUubGVuZ3RoKTtcbiAgY29uc3Qgb3V0cHV0cyA9IG5ldyBBcnJheTxJbmRpY2VzSGVscGVyPihhdHRyaWJ1dGVzLm51bU91dHB1dHMpO1xuICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgZGF0YVR5cGUsIGlucHV0U2hhcGUubGVuZ3RoKTtcbiAgY29uc3Qgc2l6ZUluU3BsaXRBeGlzID0gbmV3IEFycmF5PG51bWJlcj4oYXR0cmlidXRlcy5udW1PdXRwdXRzKTtcbiAgY29uc3Qgb3V0cHV0c1RlbnNvckluZm86IFRlbnNvckluZm9bXSA9IFtdO1xuICBjb25zdCBvdXRwdXRTaGFwZXM6IG51bWJlcltdW10gPSBbXTtcbiAgbGV0IHByZXZpb3VzU3VtID0gMDtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW3t0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGlucHV0U2l6ZX1dO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubnVtT3V0cHV0czsgaSsrKSB7XG4gICAgcHJldmlvdXNTdW0gKz0gYXR0cmlidXRlcy5zcGxpdFNpemVzW2ldO1xuICAgIHNpemVJblNwbGl0QXhpc1tpXSA9IHByZXZpb3VzU3VtO1xuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgpO1xuICAgIG91dHB1dFNoYXBlW2F0dHJpYnV0ZXMuYXhpc10gPSBhdHRyaWJ1dGVzLnNwbGl0U2l6ZXNbaV07XG4gICAgb3V0cHV0U2hhcGVzLnB1c2gob3V0cHV0U2hhcGUpO1xuICAgIG91dHB1dHNbaV0gPSBvdXRwdXRWYXJpYWJsZShgb3V0cHV0JHtpfWAsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgIG91dHB1dHNUZW5zb3JJbmZvLnB1c2goe2RpbXM6IG91dHB1dFNoYXBlc1tpXSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZX0pO1xuICB9XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKFxuICAgICAge3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogc2l6ZUluU3BsaXRBeGlzfSwgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSwgLi4ub3V0cHV0U2hhcGVzKSk7XG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICAke1xuICAgICAgc2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgnaW5wdXRfc2l6ZScsICd1MzInKVxuICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ3NpemVfaW5fc3BsaXRfYXhpcycsICd1MzInLCBzaXplSW5TcGxpdEF4aXMubGVuZ3RoKVxuICAgICAgICAgIC5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCAuLi5vdXRwdXRzKX1cbiAgJHtjYWxjdWxhdGVPdXRwdXRJbmRleEltcGwoc2l6ZUluU3BsaXRBeGlzLmxlbmd0aCl9XG4gICR7d3JpdGVCdWZmZXJEYXRhSW1wbChvdXRwdXRzKX1cblxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5pbnB1dF9zaXplJyl9XG5cbiAgICB2YXIgaW5kaWNlcyA9ICR7aW5wdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgIHZhciBpbmRleCA9ICR7aW5wdXQuaW5kaWNlc0dldCgnaW5kaWNlcycsIGF4aXMpfTtcbiAgICBsZXQgb3V0cHV0X251bWJlciA9IGNhbGN1bGF0ZU91dHB1dEluZGV4KGluZGV4KTtcbiAgICBpZiAob3V0cHV0X251bWJlciAhPSAwKSB7XG4gICAgICBpbmRleCAtPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuc2l6ZV9pbl9zcGxpdF9heGlzJywgJ291dHB1dF9udW1iZXIgLSAxdScsIHNpemVJblNwbGl0QXhpcy5sZW5ndGgpfTtcbiAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5kaWNlcycsIGF4aXMsICdpbmRleCcpfTtcbiAgICB9XG4gICAgd3JpdGVCdWZmZXJEYXRhKG91dHB1dF9udW1iZXIsIGluZGljZXMsIGdsb2JhbF9pZHgpO1xuICB9YDtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnU3BsaXQnLFxuICAgIHNoYWRlckNhY2hlOiB7aGludDogYXR0cmlidXRlcy5jYWNoZUtleSwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddfSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IG91dHB1dHNUZW5zb3JJbmZvLFxuICAgICAgZGlzcGF0Y2hHcm91cDoge3g6IE1hdGguY2VpbChpbnB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyl9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zXG4gICAgfSlcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBzcGxpdCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogU3BsaXRBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgdXBkYXRlZEF0dHJpYnV0ZXMgPVxuICAgICAgY29udGV4dC5pbnB1dHMubGVuZ3RoID09PSAxID8gYXR0cmlidXRlcyA6IGNyZWF0ZVNwbGl0QXR0cmlidXRlc0Zyb21JbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlU3BsaXRQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgdXBkYXRlZEF0dHJpYnV0ZXMpLCB7aW5wdXRzOiBbMF19KTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVNwbGl0QXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFNwbGl0QXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGF4aXMgPSBhdHRyaWJ1dGVzLmF4aXMgYXMgbnVtYmVyO1xuICBjb25zdCBzcGxpdFNpemVzOiBudW1iZXJbXSA9IGF0dHJpYnV0ZXMuc3BsaXRTaXplcyBhcyBudW1iZXJbXTtcbiAgY29uc3QgbnVtT3V0cHV0cyA9IGF0dHJpYnV0ZXMubnVtT3V0cHV0cyBhcyBudW1iZXIgPCAwID8gc3BsaXRTaXplcy5sZW5ndGggOiBhdHRyaWJ1dGVzLm51bU91dHB1dHMgYXMgbnVtYmVyO1xuICBpZiAobnVtT3V0cHV0cyAhPT0gc3BsaXRTaXplcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ251bU91dHB1dHMgYW5kIHNwbGl0U2l6ZXMgbGVuZ2ggbXVzdCBiZSBlcXVhbCcpO1xuICB9XG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe2F4aXMsIG51bU91dHB1dHMsIHNwbGl0U2l6ZXN9KTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHtCcm9hZGNhc3RVdGlsLCBTaGFwZVV0aWx9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm99IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlcn0gZnJvbSAnLi9jb21tb24nO1xuXG5jb25zdCBjcmVhdGVXaGVyZU9wUHJvZ3JhbVNoYWRlciA9XG4gICAgKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyLCBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgZGltc091dHB1dDogcmVhZG9ubHkgbnVtYmVyW10sIGlzQnJvYWRjYXN0OiBib29sZWFuLFxuICAgICB0eXBlT3V0cHV0OiBudW1iZXIpID0+IHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXRfZGF0YScsIHR5cGVPdXRwdXQsIGRpbXNPdXRwdXQubGVuZ3RoLCA0KTtcbiAgICAgIGNvbnN0IGEgPSBpbnB1dFZhcmlhYmxlKCdhX2RhdGEnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zLmxlbmd0aCwgNCk7XG4gICAgICBjb25zdCBiID0gaW5wdXRWYXJpYWJsZSgnYl9kYXRhJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgsIDQpO1xuICAgICAgY29uc3QgYyA9IGlucHV0VmFyaWFibGUoJ2NfZGF0YScsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoLCA0KTtcblxuICAgICAgbGV0IGFzc2lnbm1lbnQ6IHN0cmluZztcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSAoYTogc3RyaW5nLCBiOiBzdHJpbmcsIGM6IHN0cmluZykgPT4gYHNlbGVjdCgke2J9LCAke2F9LCAke2N9KWA7XG4gICAgICBpZiAoIWlzQnJvYWRjYXN0KSB7XG4gICAgICAgIGFzc2lnbm1lbnQgPSBvdXRwdXQuc2V0QnlPZmZzZXQoXG4gICAgICAgICAgICAnZ2xvYmFsX2lkeCcsXG4gICAgICAgICAgICBleHByZXNzaW9uKGEuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKSwgYi5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpLCBjLmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JykpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNpbmdsZUFzc2lnbm1lbnQgPSAocmVzU3RyOiBzdHJpbmcsIHg6IG51bWJlciwgdHlwZUNhc3QgPSAnJykgPT4ge1xuICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb25BID0gYGFfZGF0YVtpbmRleF9hJHt4fV1bY29tcG9uZW50X2Eke3h9XWA7XG4gICAgICAgICAgY29uc3QgZXhwcmVzc2lvbkIgPSBgYl9kYXRhW2luZGV4X2Ike3h9XVtjb21wb25lbnRfYiR7eH1dYDtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb25DID0gYGJvb2woY19kYXRhW2luZGV4X2Mke3h9XSAmICgweGZmdSA8PCAoY29tcG9uZW50X2Mke3h9ICogOCkpKWA7XG4gICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyR7eH0gPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiA0dSArICR7eH11YCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldF9hJHt4fSA9ICR7YS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0X2luZGljZXMke3h9YCwgb3V0cHV0KX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0X2Ike3h9ID0gJHtiLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRfaW5kaWNlcyR7eH1gLCBvdXRwdXQpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRfYyR7eH0gPSAke2MuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dF9pbmRpY2VzJHt4fWAsIG91dHB1dCl9O1xuICAgICAgICAgICAgbGV0IGluZGV4X2Eke3h9ID0gb2Zmc2V0X2Eke3h9IC8gNHU7XG4gICAgICAgICAgICBsZXQgaW5kZXhfYiR7eH0gPSBvZmZzZXRfYiR7eH0gLyA0dTtcbiAgICAgICAgICAgIGxldCBpbmRleF9jJHt4fSA9IG9mZnNldF9jJHt4fSAvIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudF9hJHt4fSA9IG9mZnNldF9hJHt4fSAlIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudF9iJHt4fSA9IG9mZnNldF9iJHt4fSAlIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudF9jJHt4fSA9IG9mZnNldF9jJHt4fSAlIDR1O1xuICAgICAgICAgICAgJHtyZXNTdHJ9WyR7eH1dID0gJHt0eXBlQ2FzdH0oJHtleHByZXNzaW9uKGV4cHJlc3Npb25BLCBleHByZXNzaW9uQiwgZXhwcmVzc2lvbkMpfSk7XG4gICAgICAgICAgYDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVPdXRwdXQgPT09IERhdGFUeXBlLmJvb2wpIHtcbiAgICAgICAgICBhc3NpZ25tZW50ID0gYFxuICAgICAgICAgICAgdmFyIGRhdGEgPSB2ZWM0PHUzMj4oMCk7XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAwLCAndTMyJyl9XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAxLCAndTMyJyl9XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAyLCAndTMyJyl9XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAzLCAndTMyJyl9XG4gICAgICAgICAgICBvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2lnbm1lbnQgPSBgXG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ291dHB1dF9kYXRhW2dsb2JhbF9pZHhdJywgMCl9XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ291dHB1dF9kYXRhW2dsb2JhbF9pZHhdJywgMSl9XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ291dHB1dF9kYXRhW2dsb2JhbF9pZHhdJywgMil9XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ291dHB1dF9kYXRhW2dsb2JhbF9pZHhdJywgMyl9XG4gICAgICAgICAgYDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYFxuICAgICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ3ZlY19zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoYywgYSwgYiwgb3V0cHV0KX1cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLnZlY19zaXplJyl9XG4gICAgICAgICR7YXNzaWdubWVudH1cbiAgICAgIH1gO1xuICAgIH07XG5cbmNvbnN0IGNyZWF0ZVdoZXJlT3BQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgZGltc0EgPSBpbnB1dHNbMV0uZGltcztcbiAgY29uc3QgZGltc0IgPSBpbnB1dHNbMl0uZGltcztcbiAgY29uc3QgZGltc0MgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3Qgb3V0cHV0RGF0YVR5cGUgPSBpbnB1dHNbMV0uZGF0YVR5cGU7XG5cbiAgY29uc3QgaXNCcm9hZGNhc3QgPSAhKFNoYXBlVXRpbC5hcmVFcXVhbChkaW1zQSwgZGltc0IpICYmIFNoYXBlVXRpbC5hcmVFcXVhbChkaW1zQiwgZGltc0MpKTtcbiAgbGV0IG91dHB1dFNoYXBlID0gZGltc0E7XG4gIGxldCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUoZGltc0EpO1xuICAvLyBUT0RPOiBkZWFsIHdpdGggemVyby1zaXplZCB0ZW5zb3JzIChlZy4gZGltcz1bMSwwXSlcblxuICBpZiAoaXNCcm9hZGNhc3QpIHtcbiAgICBjb25zdCBjYWxjdWxhdGVkU2hhcGUgPSBCcm9hZGNhc3RVdGlsLmNhbGNTaGFwZShCcm9hZGNhc3RVdGlsLmNhbGNTaGFwZShkaW1zQSwgZGltc0IsIGZhbHNlKSEsIGRpbXNDLCBmYWxzZSk7XG4gICAgaWYgKCFjYWxjdWxhdGVkU2hhcGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBwZXJmb3JtIHdoZXJlIG9wIG9uIHRoZSBnaXZlbiB0ZW5zb3JzJyk7XG4gICAgfVxuICAgIG91dHB1dFNoYXBlID0gY2FsY3VsYXRlZFNoYXBlO1xuICAgIG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIH1cblxuICBjb25zdCB2ZWNTaXplID0gTWF0aC5jZWlsKG91dHB1dFNpemUgLyA0KTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdXaGVyZScsXG4gICAgc2hhZGVyQ2FjaGU6IHtpbnB1dERlcGVuZGVuY2llczogWydyYW5rJywgJ3JhbmsnLCAncmFuayddfSxcbiAgICBnZXRTaGFkZXJTb3VyY2U6IChzaGFkZXJIZWxwZXIpID0+XG4gICAgICAgIGNyZWF0ZVdoZXJlT3BQcm9ncmFtU2hhZGVyKHNoYWRlckhlbHBlciwgaW5wdXRzLCBvdXRwdXRTaGFwZSwgaXNCcm9hZGNhc3QsIG91dHB1dERhdGFUeXBlKSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3tkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IG91dHB1dERhdGFUeXBlfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7eDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyAvIDQgLyogdmVjIHNpemUgKi8pfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtczpcbiAgICAgICAgICBbe3R5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogdmVjU2l6ZX0sIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGRpbXNDLCBkaW1zQSwgZGltc0IsIG91dHB1dFNoYXBlKV0sXG4gICAgfSksXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3Qgd2hlcmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVdoZXJlT3BQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cykpO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHthcmdNYXgsIGFyZ01pbiwgcGFyc2VBcmdNaW5NYXhBdHRyaWJ1dGVzfSBmcm9tICcuL29wcy9hcmdtaW5tYXgnO1xuaW1wb3J0IHthdHRlbnRpb259IGZyb20gJy4vb3BzL2F0dGVudGlvbic7XG5pbXBvcnQge2JhdGNoTm9ybX0gZnJvbSAnLi9vcHMvYmF0Y2gtbm9ybSc7XG5pbXBvcnQge2JpYXNBZGR9IGZyb20gJy4vb3BzL2JpYXMtYWRkJztcbmltcG9ydCB7Ymlhc1NwbGl0R2VsdX0gZnJvbSAnLi9vcHMvYmlhcy1zcGxpdC1nZWx1JztcbmltcG9ydCAqIGFzIGJpbmFyeU9wcyBmcm9tICcuL29wcy9iaW5hcnktb3AnO1xuaW1wb3J0IHtjb25jYXQsIHBhcnNlQ29uY2F0QXR0cmlidXRlc30gZnJvbSAnLi9vcHMvY29uY2F0JztcbmltcG9ydCB7Y29udiwgcGFyc2VDb252QXR0cmlidXRlc30gZnJvbSAnLi9vcHMvY29udic7XG5pbXBvcnQge2NvbnZUcmFuc3Bvc2UsIHBhcnNlQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXN9IGZyb20gJy4vb3BzL2NvbnYtdHJhbnNwb3NlJztcbmltcG9ydCB7Y3Vtc3VtLCBwYXJzZUN1bVN1bUF0dHJpYnV0ZXN9IGZyb20gJy4vb3BzL2N1bXN1bSc7XG5pbXBvcnQge2RlcHRoVG9TcGFjZSwgcGFyc2VEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzfSBmcm9tICcuL29wcy9kZXB0aC10by1zcGFjZSc7XG5pbXBvcnQge2VpbnN1bSwgcGFyc2VFaW5zdW1BdHRyaWJ1dGVzfSBmcm9tICcuL29wcy9laW5zdW0nO1xuaW1wb3J0IHtleHBhbmR9IGZyb20gJy4vb3BzL2V4cGFuZCc7XG5pbXBvcnQge2Zhc3RHZWx1fSBmcm9tICcuL29wcy9mYXN0LWdlbHUnO1xuaW1wb3J0IHtnYXRoZXIsIHBhcnNlR2F0aGVyQXR0cmlidXRlc30gZnJvbSAnLi9vcHMvZ2F0aGVyJztcbmltcG9ydCB7Z2F0aGVyRWxlbWVudHMsIHBhcnNlR2F0aGVyRWxlbWVudHNBdHRyaWJ1dGVzfSBmcm9tICcuL29wcy9nYXRoZXItZWxlbWVudHMnO1xuaW1wb3J0IHtnZW1tLCBwYXJzZUdlbW1BdHRyaWJ1dGVzfSBmcm9tICcuL29wcy9nZW1tJztcbmltcG9ydCB7Z3JvdXBRdWVyeUF0dGVudGlvbiwgcGFyc2VHcm91cFF1ZXJ5QXR0ZW50aW9uQXR0cmlidXRlc30gZnJvbSAnLi9vcHMvZ3JvdXAtcXVlcnktYXR0ZW50aW9uJztcbmltcG9ydCB7aW5zdGFuY2VOb3JtfSBmcm9tICcuL29wcy9pbnN0YW5jZS1ub3JtJztcbmltcG9ydCB7bGF5ZXJOb3JtfSBmcm9tICcuL29wcy9sYXllci1ub3JtJztcbmltcG9ydCB7bWF0TXVsfSBmcm9tICcuL29wcy9tYXRtdWwnO1xuaW1wb3J0IHttYXRNdWxOQml0cywgcGFyc2VNYXRNdWxOQml0c0F0dHJpYnV0ZXN9IGZyb20gJy4vb3BzL21hdG11bG5iaXRzJztcbmltcG9ydCB7bXVsdGlIZWFkQXR0ZW50aW9uLCBwYXJzZU11bHRpSGVhZEF0dGVudGlvbkF0dHJpYnV0ZXN9IGZyb20gJy4vb3BzL211bHRpaGVhZC1hdHRlbnRpb24nO1xuaW1wb3J0IHtwYWR9IGZyb20gJy4vb3BzL3BhZCc7XG5pbXBvcnQgKiBhcyBwb29sIGZyb20gJy4vb3BzL3Bvb2wnO1xuaW1wb3J0IHtyYW5nZX0gZnJvbSAnLi9vcHMvcmFuZ2UnO1xuaW1wb3J0IHtyZWR1Y2VMMSwgcmVkdWNlTDIsIHJlZHVjZUxvZ1N1bSwgcmVkdWNlTG9nU3VtRXhwLCByZWR1Y2VNYXgsIHJlZHVjZU1lYW4sIHJlZHVjZU1pbiwgcmVkdWNlUHJvZCwgcmVkdWNlU3VtLCByZWR1Y2VTdW1TcXVhcmV9IGZyb20gJy4vb3BzL3JlZHVjZSc7XG5pbXBvcnQge3BhcnNlUmVzaXplQXR0cmlidXRlcywgcmVzaXplfSBmcm9tICcuL29wcy9yZXNpemUnO1xuaW1wb3J0IHtyb3RhcnlFbWJlZGRpbmd9IGZyb20gJy4vb3BzL3JvdGFyeS1lbWJlZGRpbmcnO1xuaW1wb3J0IHtza2lwTGF5ZXJOb3JtfSBmcm9tICcuL29wcy9za2lwLWxheWVyLW5vcm0nO1xuaW1wb3J0IHtwYXJzZVNsaWNlQXR0cmlidXRlcywgc2xpY2V9IGZyb20gJy4vb3BzL3NsaWNlJztcbmltcG9ydCB7cGFyc2VTb2Z0bWF4QXR0cmlidXRlcywgc29mdG1heH0gZnJvbSAnLi9vcHMvc29mdG1heCc7XG5pbXBvcnQge3BhcnNlU3BsaXRBdHRyaWJ1dGVzLCBzcGxpdH0gZnJvbSAnLi9vcHMvc3BsaXQnO1xuaW1wb3J0IHt0aWxlfSBmcm9tICcuL29wcy90aWxlJztcbmltcG9ydCB7cGFyc2VUcmFuc3Bvc2VBdHRyaWJ1dGVzLCB0cmFuc3Bvc2V9IGZyb20gJy4vb3BzL3RyYW5zcG9zZSc7XG5pbXBvcnQgKiBhcyB1bmFyeU9wcyBmcm9tICcuL29wcy91bmFyeS1vcCc7XG5pbXBvcnQge3doZXJlfSBmcm9tICcuL29wcy93aGVyZSc7XG5pbXBvcnQge0NvbXB1dGVDb250ZXh0fSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IHR5cGUgUnVuRnVuY3Rpb24gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZT86IHVua25vd24pID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBQYXJzZUF0dHJpYnV0ZUZ1bmN0aW9uID0gKGF0dHJpYnV0ZVJhdzogdW5rbm93bikgPT4gdW5rbm93bjtcbmV4cG9ydCB0eXBlIE9wZXJhdG9ySW1wbGVtZW50YXRpb24gPSBbUnVuRnVuY3Rpb25dfFtSdW5GdW5jdGlvbiwgUGFyc2VBdHRyaWJ1dGVGdW5jdGlvbl07XG5cbmV4cG9ydCBjb25zdCBXRUJHUFVfT1BfUkVTT0xWRV9SVUxFUzogTWFwPHN0cmluZywgT3BlcmF0b3JJbXBsZW1lbnRhdGlvbj4gPSBuZXcgTWFwKFtcbiAgWydBYnMnLCBbdW5hcnlPcHMuYWJzXV0sXG4gIFsnQWNvcycsIFt1bmFyeU9wcy5hY29zXV0sXG4gIFsnQWNvc2gnLCBbdW5hcnlPcHMuYWNvc2hdXSxcbiAgWydBZGQnLCBbYmluYXJ5T3BzLmFkZF1dLFxuICBbJ0FyZ01heCcsIFthcmdNYXgsIHBhcnNlQXJnTWluTWF4QXR0cmlidXRlc11dLFxuICBbJ0FyZ01pbicsIFthcmdNaW4sIHBhcnNlQXJnTWluTWF4QXR0cmlidXRlc11dLFxuICBbJ0FzaW4nLCBbdW5hcnlPcHMuYXNpbl1dLFxuICBbJ0FzaW5oJywgW3VuYXJ5T3BzLmFzaW5oXV0sXG4gIFsnQXRhbicsIFt1bmFyeU9wcy5hdGFuXV0sXG4gIFsnQXRhbmgnLCBbdW5hcnlPcHMuYXRhbmhdXSxcbiAgWydBdHRlbnRpb24nLCBbYXR0ZW50aW9uXV0sXG4gIC8vIFRPRE86IHN1cHBvcnQgbmV3IGF0dHJpYnV0ZXMgZm9yIEF2ZXJhZ2VQb29sLTEwXG4gIFsnQXZlcmFnZVBvb2wnLCBbcG9vbC5hdmVyYWdlUG9vbCwgcG9vbC5wYXJzZUF2ZXJhZ2VQb29sQXR0cmlidXRlc11dLFxuICBbJ0JhdGNoTm9ybWFsaXphdGlvbicsIFtiYXRjaE5vcm1dXSxcbiAgWydCaWFzQWRkJywgW2JpYXNBZGRdXSxcbiAgWydCaWFzU3BsaXRHZWx1JywgW2JpYXNTcGxpdEdlbHVdXSxcbiAgWydDYXN0JywgW3VuYXJ5T3BzLmNhc3QsIHVuYXJ5T3BzLnBhcnNlQ2FzdEF0dHJpYnV0ZXNdXSxcbiAgWydDZWlsJywgW3VuYXJ5T3BzLmNlaWxdXSxcbiAgWydDbGlwJywgW3VuYXJ5T3BzLmNsaXBdXSxcbiAgWydDb25jYXQnLCBbY29uY2F0LCBwYXJzZUNvbmNhdEF0dHJpYnV0ZXNdXSxcbiAgWydDb252JywgW2NvbnYsIHBhcnNlQ29udkF0dHJpYnV0ZXNdXSxcbiAgWydDb252VHJhbnNwb3NlJywgW2NvbnZUcmFuc3Bvc2UsIHBhcnNlQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXNdXSxcbiAgWydDb3MnLCBbdW5hcnlPcHMuY29zXV0sXG4gIFsnQ29zaCcsIFt1bmFyeU9wcy5jb3NoXV0sXG4gIFsnQ3VtU3VtJywgW2N1bXN1bSwgcGFyc2VDdW1TdW1BdHRyaWJ1dGVzXV0sXG4gIFsnRGVwdGhUb1NwYWNlJywgW2RlcHRoVG9TcGFjZSwgcGFyc2VEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzXV0sXG4gIFsnRGl2JywgW2JpbmFyeU9wcy5kaXZdXSxcbiAgWydFaW5zdW0nLCBbZWluc3VtLCBwYXJzZUVpbnN1bUF0dHJpYnV0ZXNdXSxcbiAgWydFbHUnLCBbdW5hcnlPcHMuZWx1LCB1bmFyeU9wcy5wYXJzZUFscGhhQXR0cmlidXRlc11dLFxuICBbJ0VxdWFsJywgW2JpbmFyeU9wcy5lcXVhbF1dLFxuICBbJ0VyZicsIFt1bmFyeU9wcy5lcmZdXSxcbiAgWydFeHAnLCBbdW5hcnlPcHMuZXhwXV0sXG4gIFsnRXhwYW5kJywgW2V4cGFuZF1dLFxuICBbJ0Zhc3RHZWx1JywgW2Zhc3RHZWx1XV0sXG4gIFsnRmxvb3InLCBbdW5hcnlPcHMuZmxvb3JdXSxcbiAgWydGdXNlZENvbnYnLCBbY29udiwgcGFyc2VDb252QXR0cmlidXRlc11dLFxuICBbJ0dhdGhlcicsIFtnYXRoZXIsIHBhcnNlR2F0aGVyQXR0cmlidXRlc11dLFxuICBbJ0dhdGhlckVsZW1lbnRzJywgW2dhdGhlckVsZW1lbnRzLCBwYXJzZUdhdGhlckVsZW1lbnRzQXR0cmlidXRlc11dLFxuICBbJ0dlbHUnLCBbdW5hcnlPcHMuZ2VsdV1dLFxuICBbJ0dlbW0nLCBbZ2VtbSwgcGFyc2VHZW1tQXR0cmlidXRlc11dLFxuICBbJ0dsb2JhbEF2ZXJhZ2VQb29sJywgW3Bvb2wuZ2xvYmFsQXZlcmFnZVBvb2wsIHBvb2wucGFyc2VHbG9iYWxBdmVyYWdlUG9vbEF0dHJpYnV0ZXNdXSxcbiAgWydHbG9iYWxNYXhQb29sJywgW3Bvb2wuZ2xvYmFsTWF4UG9vbCwgcG9vbC5wYXJzZUdsb2JhbE1heFBvb2xBdHRyaWJ1dGVzXV0sXG4gIFsnR3JlYXRlcicsIFtiaW5hcnlPcHMuZ3JlYXRlcl1dLFxuICBbJ0dyZWF0ZXJPckVxdWFsJywgW2JpbmFyeU9wcy5ncmVhdGVyT3JFcXVhbF1dLFxuICBbJ0dyb3VwUXVlcnlBdHRlbnRpb24nLCBbZ3JvdXBRdWVyeUF0dGVudGlvbiwgcGFyc2VHcm91cFF1ZXJ5QXR0ZW50aW9uQXR0cmlidXRlc11dLFxuICBbJ0hhcmRTaWdtb2lkJywgW3VuYXJ5T3BzLmhhcmRTaWdtb2lkLCB1bmFyeU9wcy5wYXJzZUhhcmRTaWdtb2lkQXR0cmlidXRlc11dLFxuICBbJ0luc3RhbmNlTm9ybWFsaXphdGlvbicsIFtpbnN0YW5jZU5vcm1dXSxcbiAgWydMYXllck5vcm1hbGl6YXRpb24nLCBbbGF5ZXJOb3JtXV0sXG4gIFsnTGVha3lSZWx1JywgW3VuYXJ5T3BzLmxlYWt5UmVsdSwgdW5hcnlPcHMucGFyc2VBbHBoYUF0dHJpYnV0ZXNdXSxcbiAgWydMZXNzJywgW2JpbmFyeU9wcy5sZXNzXV0sXG4gIFsnTGVzc09yRXF1YWwnLCBbYmluYXJ5T3BzLmxlc3NPckVxdWFsXV0sXG4gIFsnTG9nJywgW3VuYXJ5T3BzLmxvZ11dLFxuICBbJ01hdE11bCcsIFttYXRNdWxdXSxcbiAgWydNYXRNdWxOQml0cycsIFttYXRNdWxOQml0cywgcGFyc2VNYXRNdWxOQml0c0F0dHJpYnV0ZXNdXSxcbiAgLy8gVE9ETzogc3VwcG9ydCBuZXcgYXR0cmlidXRlcyBmb3IgTWF4UG9vbC04IGFuZCBNYXhQb29sLTEwXG4gIFsnTWF4UG9vbCcsIFtwb29sLm1heFBvb2wsIHBvb2wucGFyc2VNYXhQb29sQXR0cmlidXRlc11dLFxuICBbJ011bCcsIFtiaW5hcnlPcHMubXVsXV0sXG4gIFsnTXVsdGlIZWFkQXR0ZW50aW9uJywgW211bHRpSGVhZEF0dGVudGlvbiwgcGFyc2VNdWx0aUhlYWRBdHRlbnRpb25BdHRyaWJ1dGVzXV0sXG4gIFsnTmVnJywgW3VuYXJ5T3BzLm5lZ11dLFxuICBbJ05vdCcsIFt1bmFyeU9wcy5ub3RdXSxcbiAgWydQYWQnLCBbcGFkXV0sXG4gIFsnUG93JywgW2JpbmFyeU9wcy5wb3ddXSxcbiAgWydSYW5nZScsIFtyYW5nZV1dLFxuICBbJ1JlY2lwcm9jYWwnLCBbdW5hcnlPcHMucmVjaXByb2NhbF1dLFxuICBbJ1JlZHVjZU1pbicsIFtyZWR1Y2VNaW5dXSxcbiAgWydSZWR1Y2VNZWFuJywgW3JlZHVjZU1lYW5dXSxcbiAgWydSZWR1Y2VNYXgnLCBbcmVkdWNlTWF4XV0sXG4gIFsnUmVkdWNlU3VtJywgW3JlZHVjZVN1bV1dLFxuICBbJ1JlZHVjZVByb2QnLCBbcmVkdWNlUHJvZF1dLFxuICBbJ1JlZHVjZUwxJywgW3JlZHVjZUwxXV0sXG4gIFsnUmVkdWNlTDInLCBbcmVkdWNlTDJdXSxcbiAgWydSZWR1Y2VMb2dTdW0nLCBbcmVkdWNlTG9nU3VtXV0sXG4gIFsnUmVkdWNlTG9nU3VtRXhwJywgW3JlZHVjZUxvZ1N1bUV4cF1dLFxuICBbJ1JlZHVjZVN1bVNxdWFyZScsIFtyZWR1Y2VTdW1TcXVhcmVdXSxcbiAgWydSZWx1JywgW3VuYXJ5T3BzLnJlbHVdXSxcbiAgWydSZXNpemUnLCBbcmVzaXplLCBwYXJzZVJlc2l6ZUF0dHJpYnV0ZXNdXSxcbiAgWydSb3RhcnlFbWJlZGRpbmcnLCBbcm90YXJ5RW1iZWRkaW5nXV0sXG4gIFsnU2lnbW9pZCcsIFt1bmFyeU9wcy5zaWdtb2lkXV0sXG4gIFsnU2luJywgW3VuYXJ5T3BzLnNpbl1dLFxuICBbJ1NpbmgnLCBbdW5hcnlPcHMuc2luaF1dLFxuICBbJ1NsaWNlJywgW3NsaWNlLCBwYXJzZVNsaWNlQXR0cmlidXRlc11dLFxuICBbJ1NraXBMYXllck5vcm1hbGl6YXRpb24nLCBbc2tpcExheWVyTm9ybV1dLFxuICBbJ1NwbGl0JywgW3NwbGl0LCBwYXJzZVNwbGl0QXR0cmlidXRlc11dLFxuICBbJ1NxcnQnLCBbdW5hcnlPcHMuc3FydF1dLFxuICBbJ1NvZnRtYXgnLCBbc29mdG1heCwgcGFyc2VTb2Z0bWF4QXR0cmlidXRlc11dLFxuICBbJ1N1YicsIFtiaW5hcnlPcHMuc3ViXV0sXG4gIFsnVGFuJywgW3VuYXJ5T3BzLnRhbl1dLFxuICBbJ1RhbmgnLCBbdW5hcnlPcHMudGFuaF1dLFxuICBbJ1RocmVzaG9sZGVkUmVsdScsIFt1bmFyeU9wcy50aHJlc2hvbGRlZFJlbHUsIHVuYXJ5T3BzLnBhcnNlQWxwaGFBdHRyaWJ1dGVzXV0sXG4gIFsnVGlsZScsIFt0aWxlXV0sXG4gIFsnVHJhbnNwb3NlJywgW3RyYW5zcG9zZSwgcGFyc2VUcmFuc3Bvc2VBdHRyaWJ1dGVzXV0sXG4gIFsnV2hlcmUnLCBbd2hlcmVdXSxcbl0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1RSQUNFX0ZVTkNfQkVHSU4sIFRSQUNFX0ZVTkNfRU5EfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQge1dlYkdwdUJhY2tlbmR9IGZyb20gJy4uL2JhY2tlbmQtd2ViZ3B1JztcbmltcG9ydCB7TE9HX0RFQlVHfSBmcm9tICcuLi9sb2cnO1xuXG5pbXBvcnQge2NyZWF0ZVNoYWRlckhlbHBlcn0gZnJvbSAnLi9vcHMvY29tbW9uJztcbmltcG9ydCB7QXJ0aWZhY3QsIEdwdURhdGEsIFByb2dyYW1JbmZvfSBmcm9tICcuL3R5cGVzJztcblxuLyoqXG4gKiBQcm9ncmFtTWFuYWdlciBpcyB0aGUgbWFpbiBjbGFzcyBiZWhpbmQgcnVubmluZyBjb21wdXRhdGlvbnNcbiAqIEl0IGJ1aWxkcyBQcm9ncmFtSW5mbydzIGludG8gQXJ0aWZhY3RzXG4gKiBJdCBjb21waWxlcyBnaXZlbiBQcm9ncmFtSW5mbydzIGludG8gV2ViR0wgUHJvcmFtcyAoY2FjaGVkIGFzIEFydGlmYWN0cylcbiAqIFVzZXMgdGhlIGFydGlmYWN0IHRvIHJ1biB0aGUgY29tcHV0YXRpb24gYnkgY2FsbGluZyBEcmF3IG9uXG4gKiB0aGUgV2ViR0wgZHJhd2luZyBidWZmZXJcbiAqIFByb2dyYW1NYW5hZ2VyIGF1dG9tYXRpY2FsbHkgbWFwcyAoYmluZHMpIGlucHV0IHZhcmlhYmxlcyB0byB0aGVpclxuICogY29ycmVzcG9uZGluZyBMb2NhdGlvbidzIGluIHRoZSBiaW5hcnkgcHJvZ3JhbVxuICovXG5leHBvcnQgY2xhc3MgUHJvZ3JhbU1hbmFnZXIge1xuICByZXBvOiBNYXA8dW5rbm93biwgQXJ0aWZhY3Q+OyAgLy8gdGhpcyBzaG91bGQgYmUgcGVyLXNlc3Npb24gb2JqZWN0XG4gIGF0dHJpYnV0ZXNCb3VuZDogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGJhY2tlbmQ6IFdlYkdwdUJhY2tlbmQpIHtcbiAgICB0aGlzLnJlcG8gPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5hdHRyaWJ1dGVzQm91bmQgPSBmYWxzZTtcbiAgfVxuICBnZXRBcnRpZmFjdChrZXk6IHVua25vd24pOiBBcnRpZmFjdHx1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnJlcG8uZ2V0KGtleSk7XG4gIH1cbiAgc2V0QXJ0aWZhY3Qoa2V5OiB1bmtub3duLCBhcnRpZmFjdDogQXJ0aWZhY3QpOiB2b2lkIHtcbiAgICB0aGlzLnJlcG8uc2V0KGtleSwgYXJ0aWZhY3QpO1xuICB9XG4gIHJ1bihidWlsZEFydGlmYWN0OiBBcnRpZmFjdCwgaW5wdXRzOiBHcHVEYXRhW10sIG91dHB1dHM6IEdwdURhdGFbXSwgZGlzcGF0Y2hHcm91cDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgICAgdW5pZm9ybUJ1ZmZlckJpbmRpbmc6IEdQVUJpbmRpbmdSZXNvdXJjZXx1bmRlZmluZWQpOiB2b2lkIHtcbiAgICBUUkFDRV9GVU5DX0JFR0lOKGJ1aWxkQXJ0aWZhY3QucHJvZ3JhbUluZm8ubmFtZSk7XG4gICAgY29uc3QgZGV2aWNlID0gdGhpcy5iYWNrZW5kLmRldmljZTtcbiAgICBjb25zdCBjb21wdXRlUGFzc0VuY29kZXIgPSB0aGlzLmJhY2tlbmQuZ2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCk7XG4gICAgdGhpcy5iYWNrZW5kLndyaXRlVGltZXN0YW1wKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyKTtcbiAgICBjb25zdCBlbnRyaWVzID0gW107XG4gICAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICAgIGVudHJpZXMucHVzaCh7YmluZGluZzogZW50cmllcy5sZW5ndGgsIHJlc291cmNlOiB7YnVmZmVyOiBpbnB1dC5idWZmZXJ9fSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgb3V0cHV0IG9mIG91dHB1dHMpIHtcbiAgICAgIGVudHJpZXMucHVzaCh7YmluZGluZzogZW50cmllcy5sZW5ndGgsIHJlc291cmNlOiB7YnVmZmVyOiBvdXRwdXQuYnVmZmVyfX0pO1xuICAgIH1cbiAgICBpZiAodW5pZm9ybUJ1ZmZlckJpbmRpbmcpIHtcbiAgICAgIGVudHJpZXMucHVzaCh7YmluZGluZzogZW50cmllcy5sZW5ndGgsIHJlc291cmNlOiB1bmlmb3JtQnVmZmVyQmluZGluZ30pO1xuICAgIH1cbiAgICBjb25zdCBiaW5kR3JvdXAgPSBkZXZpY2UuY3JlYXRlQmluZEdyb3VwKFxuICAgICAgICB7bGF5b3V0OiBidWlsZEFydGlmYWN0LmNvbXB1dGVQaXBlbGluZS5nZXRCaW5kR3JvdXBMYXlvdXQoMCksIGVudHJpZXMsIGxhYmVsOiBidWlsZEFydGlmYWN0LnByb2dyYW1JbmZvLm5hbWV9KTtcblxuICAgIGlmICh0aGlzLmJhY2tlbmQuc2Vzc2lvblN0YXR1cyA9PT0gJ2NhcHR1cmluZycpIHtcbiAgICAgIGNvbnN0IGNvbW1hbmRJbmZvID0ge1xuICAgICAgICBrZXJuZWxJZDogdGhpcy5iYWNrZW5kLmN1cnJlbnRLZXJuZWxJZCEsXG4gICAgICAgIGNvbXB1dGVQaXBlbGluZTogYnVpbGRBcnRpZmFjdC5jb21wdXRlUGlwZWxpbmUsXG4gICAgICAgIGJpbmRHcm91cCxcbiAgICAgICAgZGlzcGF0Y2hHcm91cFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNlc3Npb25Db21tYW5kTGlzdCA9IHRoaXMuYmFja2VuZC5jYXB0dXJlZENvbW1hbmRMaXN0LmdldCh0aGlzLmJhY2tlbmQuY3VycmVudFNlc3Npb25JZCEpO1xuICAgICAgc2Vzc2lvbkNvbW1hbmRMaXN0IS5wdXNoKGNvbW1hbmRJbmZvKTtcbiAgICB9XG5cbiAgICBjb21wdXRlUGFzc0VuY29kZXIuc2V0UGlwZWxpbmUoYnVpbGRBcnRpZmFjdC5jb21wdXRlUGlwZWxpbmUpO1xuICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5zZXRCaW5kR3JvdXAoMCwgYmluZEdyb3VwKTtcbiAgICBjb21wdXRlUGFzc0VuY29kZXIuZGlzcGF0Y2hXb3JrZ3JvdXBzKC4uLmRpc3BhdGNoR3JvdXApO1xuICAgIHRoaXMuYmFja2VuZC53cml0ZVRpbWVzdGFtcCh0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyICogMiArIDEpO1xuICAgIHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIrKztcblxuICAgIGlmICh0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyID49IHRoaXMuYmFja2VuZC5tYXhEaXNwYXRjaE51bWJlciB8fFxuICAgICAgICB0aGlzLmJhY2tlbmQucXVlcnlUeXBlID09PSAnYXQtcGFzc2VzJykge1xuICAgICAgdGhpcy5iYWNrZW5kLmVuZENvbXB1dGVQYXNzKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyID49IHRoaXMuYmFja2VuZC5tYXhEaXNwYXRjaE51bWJlcikge1xuICAgICAgdGhpcy5iYWNrZW5kLmZsdXNoKCk7XG4gICAgfVxuICAgIFRSQUNFX0ZVTkNfRU5EKGJ1aWxkQXJ0aWZhY3QucHJvZ3JhbUluZm8ubmFtZSk7XG4gIH1cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICAvLyB0aGlzLnJlcG8uZm9yRWFjaChhID0+IHRoaXMuZ2xDb250ZXh0LmRlbGV0ZVByb2dyYW0oYS5wcm9ncmFtKSk7XG4gIH1cbiAgYnVpbGQocHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBub3JtYWxpemVkRGlzcGF0Y2hHcm91cFNpemU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSk6IEFydGlmYWN0IHtcbiAgICBUUkFDRV9GVU5DX0JFR0lOKHByb2dyYW1JbmZvLm5hbWUpO1xuICAgIGNvbnN0IGRldmljZSA9IHRoaXMuYmFja2VuZC5kZXZpY2U7XG4gICAgY29uc3QgZXh0ZW5zaW9uczogc3RyaW5nW10gPSBbXTtcbiAgICBpZiAoZGV2aWNlLmZlYXR1cmVzLmhhcygnc2hhZGVyLWYxNicpKSB7XG4gICAgICBleHRlbnNpb25zLnB1c2goJ2VuYWJsZSBmMTY7Jyk7XG4gICAgfVxuICAgIGNvbnN0IHNoYWRlckhlbHBlciA9IGNyZWF0ZVNoYWRlckhlbHBlcihub3JtYWxpemVkRGlzcGF0Y2hHcm91cFNpemUsIHRoaXMuYmFja2VuZC5kZXZpY2UubGltaXRzKTtcbiAgICBjb25zdCB1c2VyQ29kZSA9IHByb2dyYW1JbmZvLmdldFNoYWRlclNvdXJjZShzaGFkZXJIZWxwZXIpO1xuICAgIGNvbnN0IGNvZGUgPSBgJHtleHRlbnNpb25zLmpvaW4oJ1xcbicpfVxcbiR7c2hhZGVySGVscGVyLmFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnN9XFxuJHt1c2VyQ29kZX1gO1xuICAgIGNvbnN0IHNoYWRlck1vZHVsZSA9IGRldmljZS5jcmVhdGVTaGFkZXJNb2R1bGUoe2NvZGUsIGxhYmVsOiBwcm9ncmFtSW5mby5uYW1lfSk7XG4gICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJHUFVdICR7cHJvZ3JhbUluZm8ubmFtZX0gc2hhZGVyIGNvZGU6ICR7Y29kZX1gKTtcblxuICAgIGNvbnN0IGNvbXB1dGVQaXBlbGluZSA9IGRldmljZS5jcmVhdGVDb21wdXRlUGlwZWxpbmUoXG4gICAgICAgIHtjb21wdXRlOiB7bW9kdWxlOiBzaGFkZXJNb2R1bGUsIGVudHJ5UG9pbnQ6ICdtYWluJ30sIGxheW91dDogJ2F1dG8nLCBsYWJlbDogcHJvZ3JhbUluZm8ubmFtZX0pO1xuXG4gICAgVFJBQ0VfRlVOQ19FTkQocHJvZ3JhbUluZm8ubmFtZSk7XG4gICAgcmV0dXJuIHtwcm9ncmFtSW5mbywgY29tcHV0ZVBpcGVsaW5lLCB1bmlmb3JtVmFyaWFibGVzSW5mbzogc2hhZGVySGVscGVyLnZhcmlhYmxlc0luZm99O1xuICB9XG5cbiAgbm9ybWFsaXplRGlzcGF0Y2hHcm91cFNpemUoZGlzcGF0Y2hHcm91cDogUmV0dXJuVHlwZTxQcm9ncmFtSW5mb1snZ2V0UnVuRGF0YSddPlsnZGlzcGF0Y2hHcm91cCddKTpcbiAgICAgIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSB7XG4gICAgY29uc3QgeCA9IHR5cGVvZiBkaXNwYXRjaEdyb3VwID09PSAnbnVtYmVyJyA/IGRpc3BhdGNoR3JvdXAgOiBkaXNwYXRjaEdyb3VwLng7XG4gICAgY29uc3QgeSA9IHR5cGVvZiBkaXNwYXRjaEdyb3VwID09PSAnbnVtYmVyJyA/IDEgOiAoZGlzcGF0Y2hHcm91cC55IHx8IDEpO1xuICAgIGNvbnN0IHogPSB0eXBlb2YgZGlzcGF0Y2hHcm91cCA9PT0gJ251bWJlcicgPyAxIDogKGRpc3BhdGNoR3JvdXAueiB8fCAxKTtcbiAgICBjb25zdCBsaW1pdFBlckRpbWVuc2lvbiA9IHRoaXMuYmFja2VuZC5kZXZpY2UubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uO1xuICAgIGlmICh4IDw9IGxpbWl0UGVyRGltZW5zaW9uICYmIHkgPD0gbGltaXRQZXJEaW1lbnNpb24gJiYgeiA8PSBsaW1pdFBlckRpbWVuc2lvbikge1xuICAgICAgcmV0dXJuIFt4LCB5LCB6XTtcbiAgICB9XG4gICAgY29uc3Qgc2l6ZSA9IHggKiB5ICogejtcbiAgICBsZXQgZGlzcGF0Y2hBdmVyYWdlID0gTWF0aC5jZWlsKE1hdGguc3FydChzaXplKSk7XG4gICAgaWYgKGRpc3BhdGNoQXZlcmFnZSA+IGxpbWl0UGVyRGltZW5zaW9uKSB7XG4gICAgICBkaXNwYXRjaEF2ZXJhZ2UgPSBNYXRoLmNlaWwoTWF0aC5jYnJ0KHNpemUpKTtcbiAgICAgIGlmIChkaXNwYXRjaEF2ZXJhZ2UgPiBsaW1pdFBlckRpbWVuc2lvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvdGFsIGRpc3BhdGNoIHNpemUgZXhjZWVkcyBXZWJHUFUgbWF4aW11bS4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbZGlzcGF0Y2hBdmVyYWdlLCBkaXNwYXRjaEF2ZXJhZ2UsIGRpc3BhdGNoQXZlcmFnZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbZGlzcGF0Y2hBdmVyYWdlLCBkaXNwYXRjaEF2ZXJhZ2UsIDFdO1xuICAgIH1cbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0VudiwgVGVuc29yLCBUUkFDRSwgVFJBQ0VfRlVOQ19CRUdJTiwgVFJBQ0VfRlVOQ19FTkR9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7RGF0YVR5cGUsIHRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nfSBmcm9tICcuLi93YXNtLWNvbW1vbic7XG5cbmltcG9ydCB7Y29uZmlndXJlTG9nZ2VyLCBMT0dfREVCVUd9IGZyb20gJy4vbG9nJztcbmltcG9ydCB7Y3JlYXRlVmlldywgVGVuc29yVmlld30gZnJvbSAnLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge2NyZWF0ZUdwdURhdGFNYW5hZ2VyLCBkb3dubG9hZEdwdURhdGEsIEdwdURhdGFNYW5hZ2VyfSBmcm9tICcuL3dlYmdwdS9ncHUtZGF0YS1tYW5hZ2VyJztcbmltcG9ydCB7UnVuRnVuY3Rpb24sIFdFQkdQVV9PUF9SRVNPTFZFX1JVTEVTfSBmcm9tICcuL3dlYmdwdS9vcC1yZXNvbHZlLXJ1bGVzJztcbmltcG9ydCB7UHJvZ3JhbU1hbmFnZXJ9IGZyb20gJy4vd2ViZ3B1L3Byb2dyYW0tbWFuYWdlcic7XG5pbXBvcnQge0FkYXB0ZXJJbmZvLCBDb21wdXRlQ29udGV4dCwgR3B1QXJjaGl0ZWN0dXJlLCBHcHVEYXRhLCBHcHVWZW5kb3IsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgU2Vzc2lvblN0YXRlLCBUaW1lc3RhbXBRdWVyeX0gZnJvbSAnLi93ZWJncHUvdHlwZXMnO1xuXG5pbnRlcmZhY2UgQ29tbWFuZEluZm8ge1xuICByZWFkb25seSBrZXJuZWxJZDogbnVtYmVyO1xuICByZWFkb25seSBjb21wdXRlUGlwZWxpbmU6IEdQVUNvbXB1dGVQaXBlbGluZTtcbiAgcmVhZG9ubHkgYmluZEdyb3VwOiBHUFVCaW5kR3JvdXA7XG4gIHJlYWRvbmx5IGRpc3BhdGNoR3JvdXA6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbn1cblxuaW50ZXJmYWNlIEtlcm5lbEluZm8ge1xuICByZWFkb25seSBrZXJuZWxUeXBlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGtlcm5lbE5hbWU6IHN0cmluZztcbiAgcmVhZG9ubHkga2VybmVsRW50cnk6IFJ1bkZ1bmN0aW9uO1xuICByZWFkb25seSBhdHRyaWJ1dGVzOiBbKChhdHRyaWJ1dGU6IHVua25vd24pID0+IHVua25vd24pfHVuZGVmaW5lZCwgdW5rbm93bl07XG59XG5cbmludGVyZmFjZSBQZW5kaW5nS2VybmVsSW5mbyB7XG4gIHJlYWRvbmx5IGtlcm5lbElkOiBudW1iZXI7XG4gIHJlYWRvbmx5IHByb2dyYW1OYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGlucHV0VGVuc29yVmlld3M6IHJlYWRvbmx5IFRlbnNvclZpZXdbXTtcbiAgcmVhZG9ubHkgb3V0cHV0VGVuc29yVmlld3M6IHJlYWRvbmx5IFRlbnNvclZpZXdbXTtcbn1cblxuY29uc3QgZ2V0UHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lLZXkgPVxuICAgIChpbnB1dFRlbnNvcnM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgaW5wdXREZXBlbmRlbmNpZXM6IHJlYWRvbmx5IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10pOiBzdHJpbmcgPT4ge1xuICAgICAgaWYgKGlucHV0RGVwZW5kZW5jaWVzLmxlbmd0aCAhPT0gaW5wdXRUZW5zb3JzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGlucHV0RGVwZW5kZW5jaWVzIGxlbmd0aCAke2lucHV0RGVwZW5kZW5jaWVzLmxlbmd0aH0gaXMgbm90IGVxdWFsIHRvIGlucHV0VGVuc29ycyBsZW5ndGggJHtcbiAgICAgICAgICAgIGlucHV0VGVuc29ycy5sZW5ndGh9LmApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbnB1dEluZm9zOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFRlbnNvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGlucHV0VGVuc29yc1tpXS5kYXRhVHlwZTtcbiAgICAgICAgc3dpdGNoIChpbnB1dERlcGVuZGVuY2llc1tpXSkge1xuICAgICAgICAgIGNhc2UgJ25vbmUnOiB7XG4gICAgICAgICAgICBpbnB1dEluZm9zLnB1c2goJycpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ3R5cGUnOiB7XG4gICAgICAgICAgICBpbnB1dEluZm9zLnB1c2goYCR7dHlwZX1gKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdyYW5rJzoge1xuICAgICAgICAgICAgY29uc3QgcmFuayA9IGlucHV0VGVuc29yc1tpXS5kaW1zLmxlbmd0aDtcbiAgICAgICAgICAgIGlucHV0SW5mb3MucHVzaChgJHt0eXBlfTske3Jhbmt9YCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnZGltcyc6IHtcbiAgICAgICAgICAgIGNvbnN0IGRpbXMgPSBpbnB1dFRlbnNvcnNbaV0uZGltcy5qb2luKCcsJyk7XG4gICAgICAgICAgICBpbnB1dEluZm9zLnB1c2goYCR7dHlwZX07JHtkaW1zfWApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGlucHV0IGRlcGVuZGVuY3k6ICR7aW5wdXREZXBlbmRlbmNpZXNbaV19YCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlucHV0SW5mb3Muam9pbignfCcpO1xuICAgIH07XG5cbi8qKlxuICogZ2V0IGEgdW5pcXVlIGtleSByZXByZXNlbnRpbmcgdGhlIHByb2dyYW0gZnJvbSB0aGUgcHJvZ3JhbSBpbmZvLCBpbnB1dCBzaGFwZXMgYW5kIHR5cGVzLlxuICpcbiAqIEByZXR1cm5zIGEgdW5pcXVlIGtleSBpcyBhIHNob3J0ZXIgc3RyaW5nIHRoYW4gdGhlIHNoYWRlciBzb3VyY2UsIHdoaWNoIGNvbnRhaW5zIGFsbCB0aGUgaW5mb3JtYXRpb24gdG8gaWRlbnRpZnkgYVxuICogcHJvZ3JhbS4gaWYgdGhlIGtleSBpcyB0aGUgc2FtZSwgdGhlIHByb2dyYW0gc2hhZGVyIHNvdXJjZSBzaG91bGQgYmUgdGhlIHNhbWUsIHNvIHdlIGNhbiByZXVzZSB0aGUgcHJvZ3JhbS5cbiAqXG4gKi9cbmNvbnN0IGdldFByb2dyYW1JbmZvVW5pcXVlS2V5ID1cbiAgICAocHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLCBpbnB1dFRlbnNvcnM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgaXMxRGltZW5zaW9uRGlzcGF0Y2g6IGJvb2xlYW4pOiBzdHJpbmcgPT4ge1xuICAgICAgLy8gZmluYWwga2V5IGZvcm1hdDpcbiAgICAgIC8vIDxQUk9HUkFNX05BTUU+WzxQUk9HUkFNX0NVU1RPTV9DQUNIRV9ISU5UPl06aXMxRGltZW5zaW9uRGlzcGF0Y2g6PElOUFVUU19JTkZPXzA+fDxJTlBVVFNfSU5GT18xPnwuLi5cbiAgICAgIGxldCBrZXkgPSBwcm9ncmFtSW5mby5uYW1lO1xuICAgICAgaWYgKHByb2dyYW1JbmZvLnNoYWRlckNhY2hlPy5oaW50KSB7XG4gICAgICAgIGtleSArPSAnWycgKyBwcm9ncmFtSW5mby5zaGFkZXJDYWNoZS5oaW50ICsgJ10nO1xuICAgICAgfVxuICAgICAga2V5ICs9ICc6JyArIGlzMURpbWVuc2lvbkRpc3BhdGNoICtcbiAgICAgICAgICBgOiR7XG4gICAgICAgICAgICAgICAgIGdldFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5S2V5KFxuICAgICAgICAgICAgICAgICAgICAgaW5wdXRUZW5zb3JzLFxuICAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbUluZm8uc2hhZGVyQ2FjaGU/LmlucHV0RGVwZW5kZW5jaWVzID8/XG4gICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEFycmF5PFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5PihpbnB1dFRlbnNvcnMubGVuZ3RoKS5maWxsKCdkaW1zJykpfWA7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH07XG5cbmNsYXNzIEFkYXB0ZXJJbmZvSW1wbCBpbXBsZW1lbnRzIEFkYXB0ZXJJbmZvIHtcbiAgcmVhZG9ubHkgYXJjaGl0ZWN0dXJlPzogc3RyaW5nO1xuICByZWFkb25seSB2ZW5kb3I/OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlckluZm86IEdQVUFkYXB0ZXJJbmZvKSB7XG4gICAgaWYgKGFkYXB0ZXJJbmZvKSB7XG4gICAgICB0aGlzLmFyY2hpdGVjdHVyZSA9IGFkYXB0ZXJJbmZvLmFyY2hpdGVjdHVyZTtcbiAgICAgIHRoaXMudmVuZG9yID0gYWRhcHRlckluZm8udmVuZG9yO1xuICAgIH1cbiAgfVxuXG4gIGlzQXJjaGl0ZWN0dXJlKGFyY2hpdGVjdHVyZTogR3B1QXJjaGl0ZWN0dXJlKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYXJjaGl0ZWN0dXJlID09PSBhcmNoaXRlY3R1cmU7XG4gIH1cblxuICBpc1ZlbmRvcih2ZW5kb3I6IEdwdVZlbmRvcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnZlbmRvciA9PT0gdmVuZG9yO1xuICB9XG59XG5cbi8qKlxuICogdGhpcyBjbGFzcyBpcyBkZXNpZ25lZCB0byBzdG9yZSBzdGF0dXMgYW5kIGJlaW5nIHVzZWQgYXMgYSBzaW5nbGV0b24gZm9yIEpTRVAuIEl0IHdpbGwgYmUgcGFzc2VkIHRvIGpzZXBJbml0KCkgYXNcbiAqIHRoZSBmaXJzdCBwYXJhbWV0ZXIgc28gdGhhdCBpdCBpcyBzdG9yZWQgZm9yIGZ1dHVyZSB1c2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJHcHVCYWNrZW5kIHtcbiAgYWRhcHRlckluZm86IEFkYXB0ZXJJbmZvSW1wbDtcbiAgZGV2aWNlOiBHUFVEZXZpY2U7XG4gIC8qKlxuICAgKiBhbiBpbnN0YW5jZSBvZiBHcHVEYXRhTWFuYWdlciB0byBtYW5hZ2UgYSBHcHVEYXRhSWQgLT4gR3B1QnVmZmVyIG1hcHBpbmdcbiAgICovXG4gIGdwdURhdGFNYW5hZ2VyOiBHcHVEYXRhTWFuYWdlcjtcbiAgLyoqXG4gICAqIGFuIGluc3RhbmNlIG9mIFByb2dyYW1NYW5hZ2VyIHRvIGJ1aWxkIGFuZCBydW4gV2ViR1BVIGNvbXB1dGUgc2hhZGVyIHByb2dyYW0sIGFuZCBtYW5hZ2UgYSBQcm9ncmFtS2V5IC0+IFByb2dyYW1cbiAgICogYXJ0aWZhY3RzIG1hcHBpbmdcbiAgICovXG4gIHByb2dyYW1NYW5hZ2VyOiBQcm9ncmFtTWFuYWdlcjtcblxuICAvKipcbiAgICogcmVwcmVzZW50aW5nIHRoZSBzZXNzaW9uIElEIG9mIHdoaWNoIGlzIGN1cnJlbnRseSBiZWluZyBydW4uXG4gICAqIGBudWxsYCBtZWFucyBubyBzZXNzaW9uIGlzIGJlaW5nIHJ1bi5cbiAgICogb25seSB2YWxpZCB3aGVuIHNlc3Npb24ucnVuIGlzIGV4ZWN1dGVkLlxuICAgKi9cbiAgY3VycmVudFNlc3Npb25JZDogbnVtYmVyfG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiByZXByZXNlbnRpbmcgdGhlIGtlcm5lbCBJRCBvZiB3aGljaCBpcyBjdXJyZW50bHkgYmVpbmcgY29tcHV0ZWQgKENQVSBjb2RlIHBlcnNwZWN0aXZlKS5cbiAgICogYG51bGxgIG1lYW5zIG5vIGtlcm5lbCBpcyBiZWluZyBjb21wdXRlZC5cbiAgICogb25seSBvbmUga2VybmVsIGNhbiBiZSBjb21wdXRlZCBhdCBhIG1vbWVudC5cbiAgICovXG4gIGN1cnJlbnRLZXJuZWxJZDogbnVtYmVyfG51bGwgPSBudWxsO1xuICAvKipcbiAgICogYSBsaXN0IG9mIHRlbXBvcmFyeSBHUFUgZGF0YSBmb3IgdGhlIGN1cnJlbnQga2VybmVsLiBzaG91bGQgcmVsZWFzZSB3aGVuIHRoZSBrZXJuZWwgZG9uZSBjb21wdXRhdGlvbi5cbiAgICovXG4gIHByaXZhdGUgdGVtcG9yYXJ5RGF0YTogR3B1RGF0YVtdO1xuICAvKipcbiAgICogYSBLZXJuZWxJRCAtPiBhIEdQVSBkYXRhIGxpc3QsIHdoaWNoIHN0b3JlcyBwZXJzaXN0ZW50IEdQVSBkYXRhIG93bmVkIGJ5IHRoZSBzcGVjaWZpYyBrZXJuZWwuXG4gICAqL1xuICBwcml2YXRlIGtlcm5lbFBlcnNpc3RlbnREYXRhOiBNYXA8bnVtYmVyLCBHcHVEYXRhW10+O1xuICAvKipcbiAgICogYSBLZXJuZWxJRCAtPiBhIGN1c3RvbSBkYXRhLCB3aGljaCBzdG9yZXMgY3VzdG9tIGRhdGEgb3duZWQgYnkgdGhlIHNwZWNpZmljIGtlcm5lbC5cbiAgICovXG4gIHByaXZhdGUga2VybmVsQ3VzdG9tRGF0YTogTWFwPG51bWJlciwge1trZXk6IHN0cmluZ106IHVua25vd259PjtcbiAgLyoqXG4gICAqIGdldCB0aGUgY3VzdG9tIGRhdGEgb2YgdGhlIGN1cnJlbnQga2VybmVsXG4gICAqL1xuICBnZXQgY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKToge1trZXk6IHN0cmluZ106IHVua25vd259IHtcbiAgICBpZiAodGhpcy5jdXJyZW50S2VybmVsSWQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKTogY3VycmVudEtlcm5lbElkIGlzIG51bGwuIChzaG91bGQgbm90IGhhcHBlbiknKTtcbiAgICB9XG5cbiAgICBsZXQgZGF0YSA9IHRoaXMua2VybmVsQ3VzdG9tRGF0YS5nZXQodGhpcy5jdXJyZW50S2VybmVsSWQpO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgZGF0YSA9IHt9O1xuICAgICAgdGhpcy5rZXJuZWxDdXN0b21EYXRhLnNldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCwgZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICAvLyBLZXJuZWxJRCAtPiBrZXJuZWxJbmZvIG1hcHBpbmdcbiAga2VybmVsczogTWFwPG51bWJlciwgS2VybmVsSW5mbz47XG4gIHByaXZhdGUgY29tbWFuZEVuY29kZXI6IEdQVUNvbW1hbmRFbmNvZGVyfG51bGwgPSBudWxsO1xuICBwcml2YXRlIGNvbXB1dGVQYXNzRW5jb2RlcjogR1BVQ29tcHV0ZVBhc3NFbmNvZGVyfG51bGwgPSBudWxsO1xuICBtYXhEaXNwYXRjaE51bWJlciA9IDE2O1xuICBwZW5kaW5nRGlzcGF0Y2hOdW1iZXIgPSAwO1xuXG4gIC8vIGluZm8gb2Yga2VybmVscyBwZW5kaW5nIHN1Ym1pc3Npb24gZm9yIGEgc2luZ2xlIGJhdGNoXG4gIHByaXZhdGUgcGVuZGluZ0tlcm5lbHM6IFBlbmRpbmdLZXJuZWxJbmZvW10gPSBbXTtcbiAgLy8gcXVlcnlSZWFkQnVmZmVyIC0+IHBlbmRpbmdLZXJuZWxzIG1hcHBpbmcgZm9yIGFsbCB0aGUgYmF0Y2hlc1xuICBwcml2YXRlIHBlbmRpbmdRdWVyaWVzOiBNYXA8R1BVQnVmZmVyLCBQZW5kaW5nS2VybmVsSW5mb1tdPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBxdWVyeVJlc29sdmVCdWZmZXI/OiBHUFVCdWZmZXI7XG4gIHByaXZhdGUgcXVlcnlTZXQ/OiBHUFVRdWVyeVNldDtcbiAgcHJpdmF0ZSBxdWVyeVRpbWVCYXNlPzogYmlnaW50O1xuICBxdWVyeVR5cGU6IFRpbWVzdGFtcFF1ZXJ5O1xuXG4gIGVudjogRW52O1xuICBzZXNzaW9uU3RhdHVzOiBTZXNzaW9uU3RhdGUgPSAnZGVmYXVsdCc7XG4gIC8qKlxuICAgKiBhIFNlc3Npb25JRCAtPiBDb21tYW5kSW5mb1tdIG1hcHBpbmcuIEl0J3MgdXNlZCB0byByZWNvcmQgYWxsIEdQVSBjb21tYW5kcyBmb3IgY29ycmVzcG9uZGluZyBzZXNzaW9uLlxuICAgKi9cbiAgY2FwdHVyZWRDb21tYW5kTGlzdDogTWFwPG51bWJlciwgQ29tbWFuZEluZm9bXT4gPSBuZXcgTWFwKCk7XG5cbiAgLyoqXG4gICAqIGEgU2Vzc2lvbklEIC0+IFBlbmRpbmdLZXJuZWxJbmZvW10gbWFwcGluZyBmb3IgcHJvZmlsaW5nLlxuICAgKi9cbiAgcHJpdmF0ZSBjYXB0dXJlZFBlbmRpbmdLZXJuZWxzOiBNYXA8bnVtYmVyLCBQZW5kaW5nS2VybmVsSW5mb1tdPiA9IG5ldyBNYXAoKTtcblxuICAvKipcbiAgICogYSBTZXNzaW9uSUQgLT4gYSBNYXAgb2YgKElucHV0T3V0cHV0SW5kZXggLT4gW0lELCBHUFVCdWZmZXJdKSBtYXBwaW5nLlxuICAgKi9cbiAgc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmc6IE1hcDxudW1iZXIsIE1hcDxudW1iZXIsIFtudW1iZXIsIEdQVUJ1ZmZlcl0+PiA9IG5ldyBNYXAoKTtcblxuICBhc3luYyBpbml0aWFsaXplKGVudjogRW52LCBhZGFwdGVyOiBHUFVBZGFwdGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgY29uc3QgcmVxdWlyZWRGZWF0dXJlczogR1BVRmVhdHVyZU5hbWVbXSA9IFtdO1xuICAgIGNvbnN0IGRldmljZURlc2NyaXB0b3I6IEdQVURldmljZURlc2NyaXB0b3IgPSB7XG4gICAgICByZXF1aXJlZExpbWl0czoge1xuICAgICAgICBtYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemU6IGFkYXB0ZXIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZSxcbiAgICAgICAgbWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb246IGFkYXB0ZXIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uLFxuICAgICAgICBtYXhTdG9yYWdlQnVmZmVyQmluZGluZ1NpemU6IGFkYXB0ZXIubGltaXRzLm1heFN0b3JhZ2VCdWZmZXJCaW5kaW5nU2l6ZSxcbiAgICAgICAgbWF4QnVmZmVyU2l6ZTogYWRhcHRlci5saW1pdHMubWF4QnVmZmVyU2l6ZSxcbiAgICAgICAgbWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwOiBhZGFwdGVyLmxpbWl0cy5tYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXAsXG4gICAgICAgIG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWDogYWRhcHRlci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYLFxuICAgICAgICBtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVk6IGFkYXB0ZXIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWSxcbiAgICAgICAgbWF4Q29tcHV0ZVdvcmtncm91cFNpemVaOiBhZGFwdGVyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVosXG4gICAgICB9LFxuICAgICAgcmVxdWlyZWRGZWF0dXJlcyxcbiAgICB9O1xuXG4gICAgaWYgKGFkYXB0ZXIuZmVhdHVyZXMuaGFzKCdjaHJvbWl1bS1leHBlcmltZW50YWwtdGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXMnKSkge1xuICAgICAgcmVxdWlyZWRGZWF0dXJlcy5wdXNoKCdjaHJvbWl1bS1leHBlcmltZW50YWwtdGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXMnIGFzIEdQVUZlYXR1cmVOYW1lKTtcbiAgICB9IGVsc2UgaWYgKGFkYXB0ZXIuZmVhdHVyZXMuaGFzKCd0aW1lc3RhbXAtcXVlcnknKSkge1xuICAgICAgcmVxdWlyZWRGZWF0dXJlcy5wdXNoKCd0aW1lc3RhbXAtcXVlcnknKTtcbiAgICB9XG4gICAgaWYgKGFkYXB0ZXIuZmVhdHVyZXMuaGFzKCdzaGFkZXItZjE2JykpIHtcbiAgICAgIHJlcXVpcmVkRmVhdHVyZXMucHVzaCgnc2hhZGVyLWYxNicpO1xuICAgIH1cblxuICAgIHRoaXMuZGV2aWNlID0gYXdhaXQgYWRhcHRlci5yZXF1ZXN0RGV2aWNlKGRldmljZURlc2NyaXB0b3IpO1xuICAgIHRoaXMuYWRhcHRlckluZm8gPSBuZXcgQWRhcHRlckluZm9JbXBsKGF3YWl0IGFkYXB0ZXIucmVxdWVzdEFkYXB0ZXJJbmZvKCkpO1xuICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIgPSBjcmVhdGVHcHVEYXRhTWFuYWdlcih0aGlzKTtcbiAgICB0aGlzLnByb2dyYW1NYW5hZ2VyID0gbmV3IFByb2dyYW1NYW5hZ2VyKHRoaXMpO1xuICAgIHRoaXMua2VybmVscyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhID0gbmV3IE1hcCgpO1xuICAgIHRoaXMua2VybmVsQ3VzdG9tRGF0YSA9IG5ldyBNYXAoKTtcblxuICAgIC8vIHNldCB1cCBmbGFncyBmb3IgbG9nZ2VyXG4gICAgY29uZmlndXJlTG9nZ2VyKGVudi5sb2dMZXZlbCEsICEhZW52LmRlYnVnKTtcblxuICAgIC8vIFRPRE86IHNldCB1cCBmbGFnc1xuXG4gICAgdGhpcy5kZXZpY2Uub251bmNhcHR1cmVkZXJyb3IgPSBldiA9PiB7XG4gICAgICBpZiAoZXYuZXJyb3IgaW5zdGFuY2VvZiBHUFVWYWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5lcnJvcihgQW4gdW5jYXVnaHQgV2ViR1BVIHZhbGlkYXRpb24gZXJyb3Igd2FzIHJhaXNlZDogJHtldi5lcnJvci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICAgIHRoaXMuZW52LndlYmdwdSwgJ2RldmljZScsIHt2YWx1ZTogdGhpcy5kZXZpY2UsIHdyaXRhYmxlOiBmYWxzZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiBmYWxzZX0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgdGhpcy5lbnYud2ViZ3B1LCAnYWRhcHRlcicsIHt2YWx1ZTogYWRhcHRlciwgd3JpdGFibGU6IGZhbHNlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IGZhbHNlfSk7XG5cbiAgICAvLyBpbml0IHF1ZXJ5VHlwZSwgd2hpY2ggaXMgbmVjZXNzYXJ5IGZvciBJbmZlcmVuY2VTZXNzaW9uLmNyZWF0ZVxuICAgIHRoaXMuc2V0UXVlcnlUeXBlKCk7XG4gIH1cblxuICBkaXNwb3NlKCk6IHZvaWQge1xuICAgIGlmICh0eXBlb2YgdGhpcy5xdWVyeVNldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMucXVlcnlTZXQuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIGdldENvbW1hbmRFbmNvZGVyKCk6IEdQVUNvbW1hbmRFbmNvZGVyIHtcbiAgICBpZiAoIXRoaXMuY29tbWFuZEVuY29kZXIpIHtcbiAgICAgIHRoaXMuY29tbWFuZEVuY29kZXIgPSB0aGlzLmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb21tYW5kRW5jb2RlcjtcbiAgfVxuXG4gIGdldENvbXB1dGVQYXNzRW5jb2RlcigpOiBHUFVDb21wdXRlUGFzc0VuY29kZXIge1xuICAgIGlmICghdGhpcy5jb21wdXRlUGFzc0VuY29kZXIpIHtcbiAgICAgIGNvbnN0IGNvbW1hbmRFbmNvZGVyID0gdGhpcy5nZXRDb21tYW5kRW5jb2RlcigpO1xuICAgICAgY29uc3QgY29tcHV0ZVBhc3NEZXNjcmlwdG9yOiBHUFVDb21wdXRlUGFzc0Rlc2NyaXB0b3IgPSB7fTtcblxuICAgICAgaWYgKHRoaXMucXVlcnlUeXBlID09PSAnYXQtcGFzc2VzJykge1xuICAgICAgICBjb21wdXRlUGFzc0Rlc2NyaXB0b3IudGltZXN0YW1wV3JpdGVzID0ge1xuICAgICAgICAgIHF1ZXJ5U2V0OiB0aGlzLnF1ZXJ5U2V0ISxcbiAgICAgICAgICBiZWdpbm5pbmdPZlBhc3NXcml0ZUluZGV4OiB0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIsXG4gICAgICAgICAgZW5kT2ZQYXNzV3JpdGVJbmRleDogdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyICsgMSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb21wdXRlUGFzc0VuY29kZXIgPSBjb21tYW5kRW5jb2Rlci5iZWdpbkNvbXB1dGVQYXNzKGNvbXB1dGVQYXNzRGVzY3JpcHRvcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbXB1dGVQYXNzRW5jb2RlcjtcbiAgfVxuXG4gIGVuZENvbXB1dGVQYXNzKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcikge1xuICAgICAgdGhpcy5jb21wdXRlUGFzc0VuY29kZXIuZW5kKCk7XG4gICAgICB0aGlzLmNvbXB1dGVQYXNzRW5jb2RlciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgZmx1c2goKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmNvbW1hbmRFbmNvZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgVFJBQ0VfRlVOQ19CRUdJTigpO1xuXG4gICAgdGhpcy5lbmRDb21wdXRlUGFzcygpO1xuICAgIGxldCBxdWVyeVJlYWRCdWZmZXI6IEdQVUJ1ZmZlcjtcbiAgICBpZiAodGhpcy5xdWVyeVR5cGUgIT09ICdub25lJykge1xuICAgICAgdGhpcy5jb21tYW5kRW5jb2Rlci5yZXNvbHZlUXVlcnlTZXQoXG4gICAgICAgICAgdGhpcy5xdWVyeVNldCEsIDAsIHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyICogMiwgdGhpcy5xdWVyeVJlc29sdmVCdWZmZXIhLCAwKTtcblxuICAgICAgcXVlcnlSZWFkQnVmZmVyID0gdGhpcy5kZXZpY2UuY3JlYXRlQnVmZmVyKFxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgICAge3NpemU6IHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyICogMiAqIDgsIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5NQVBfUkVBRCB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUfSk7XG5cbiAgICAgIHRoaXMucGVuZGluZ1F1ZXJpZXMuc2V0KHF1ZXJ5UmVhZEJ1ZmZlciwgdGhpcy5wZW5kaW5nS2VybmVscyk7XG4gICAgICB0aGlzLnBlbmRpbmdLZXJuZWxzID0gW107XG4gICAgICB0aGlzLmNvbW1hbmRFbmNvZGVyLmNvcHlCdWZmZXJUb0J1ZmZlcihcbiAgICAgICAgICB0aGlzLnF1ZXJ5UmVzb2x2ZUJ1ZmZlciEsIDAsIHF1ZXJ5UmVhZEJ1ZmZlciwgMCwgdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyICogOCk7XG4gICAgfVxuXG4gICAgdGhpcy5kZXZpY2UucXVldWUuc3VibWl0KFt0aGlzLmNvbW1hbmRFbmNvZGVyLmZpbmlzaCgpXSk7XG4gICAgdGhpcy5ncHVEYXRhTWFuYWdlci5yZWZyZXNoUGVuZGluZ0J1ZmZlcnMoKTtcbiAgICB0aGlzLmNvbW1hbmRFbmNvZGVyID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciA9IDA7XG5cbiAgICBpZiAodGhpcy5xdWVyeVR5cGUgIT09ICdub25lJykge1xuICAgICAgdm9pZCBxdWVyeVJlYWRCdWZmZXIhLm1hcEFzeW5jKEdQVU1hcE1vZGUuUkVBRCkudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hcHBlZERhdGEgPSBuZXcgQmlnVWludDY0QXJyYXkocXVlcnlSZWFkQnVmZmVyLmdldE1hcHBlZFJhbmdlKCkpO1xuICAgICAgICBjb25zdCBwZW5kaW5nS2VybmVscyA9IHRoaXMucGVuZGluZ1F1ZXJpZXMuZ2V0KHF1ZXJ5UmVhZEJ1ZmZlcikhO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcHBlZERhdGEubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgcGVuZGluZ0tlcm5lbEluZm8gPSBwZW5kaW5nS2VybmVsc1tpXTtcbiAgICAgICAgICBjb25zdCBrZXJuZWxJZCA9IHBlbmRpbmdLZXJuZWxJbmZvLmtlcm5lbElkO1xuICAgICAgICAgIGNvbnN0IGtlcm5lbEluZm8gPSB0aGlzLmtlcm5lbHMuZ2V0KGtlcm5lbElkKSE7XG4gICAgICAgICAgY29uc3Qga2VybmVsVHlwZSA9IGtlcm5lbEluZm8ua2VybmVsVHlwZTtcbiAgICAgICAgICBjb25zdCBrZXJuZWxOYW1lID0ga2VybmVsSW5mby5rZXJuZWxOYW1lO1xuICAgICAgICAgIGNvbnN0IHByb2dyYW1OYW1lID0gcGVuZGluZ0tlcm5lbEluZm8ucHJvZ3JhbU5hbWU7XG4gICAgICAgICAgY29uc3QgaW5wdXRUZW5zb3JWaWV3cyA9IHBlbmRpbmdLZXJuZWxJbmZvLmlucHV0VGVuc29yVmlld3M7XG4gICAgICAgICAgY29uc3Qgb3V0cHV0VGVuc29yVmlld3MgPSBwZW5kaW5nS2VybmVsSW5mby5vdXRwdXRUZW5zb3JWaWV3cztcbiAgICAgICAgICBjb25zdCBzdGFydFRpbWVVNjQgPSBtYXBwZWREYXRhW2kgKiAyXTtcbiAgICAgICAgICBjb25zdCBlbmRUaW1lVTY0ID0gbWFwcGVkRGF0YVtpICogMiArIDFdO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnF1ZXJ5VGltZUJhc2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5VGltZUJhc2UgPSBzdGFydFRpbWVVNjQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gTnVtYmVyKHN0YXJ0VGltZVU2NCAtIHRoaXMucXVlcnlUaW1lQmFzZSk7XG4gICAgICAgICAgY29uc3QgZW5kVGltZSA9IE51bWJlcihlbmRUaW1lVTY0IC0gdGhpcy5xdWVyeVRpbWVCYXNlKTtcblxuICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoc3RhcnRUaW1lKSB8fCAhTnVtYmVyLmlzU2FmZUludGVnZXIoZW5kVGltZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmNvcnJlY3QgdGltZXN0YW1wIHJhbmdlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuZW52LndlYmdwdS5wcm9maWxpbmc/Lm9uZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5lbnYud2ViZ3B1LnByb2ZpbGluZy5vbmRhdGEoe1xuICAgICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgICAgICBpbnB1dHNNZXRhZGF0YTogaW5wdXRUZW5zb3JWaWV3cy5tYXAoXG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9PiAoe2RpbXM6IHZhbHVlLmRpbXMsIGRhdGFUeXBlOiB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyh2YWx1ZS5kYXRhVHlwZSl9KSksXG4gICAgICAgICAgICAgIG91dHB1dHNNZXRhZGF0YTogb3V0cHV0VGVuc29yVmlld3MubWFwKFxuICAgICAgICAgICAgICAgICAgdmFsdWUgPT4gKHtkaW1zOiB2YWx1ZS5kaW1zLCBkYXRhVHlwZTogdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcodmFsdWUuZGF0YVR5cGUpfSkpLFxuICAgICAgICAgICAgICBrZXJuZWxJZCxcbiAgICAgICAgICAgICAga2VybmVsVHlwZSxcbiAgICAgICAgICAgICAga2VybmVsTmFtZSxcbiAgICAgICAgICAgICAgcHJvZ3JhbU5hbWUsXG4gICAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgZW5kVGltZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBubyBjYWxsYmFjayBpcyBwcm92aWRlZCwgcHJpbnQgdGhlIHByb2ZpbGluZyBtZXNzYWdlIHRvIGNvbnNvbGVcbiAgICAgICAgICAgIGxldCBpbnB1dFNoYXBlcyA9ICcnO1xuICAgICAgICAgICAgaW5wdXRUZW5zb3JWaWV3cy5mb3JFYWNoKCh2YWx1ZSwgaSkgPT4ge1xuICAgICAgICAgICAgICBpbnB1dFNoYXBlcyArPSBgaW5wdXRbJHtpfV06IFske3ZhbHVlLmRpbXN9XSB8ICR7dGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcodmFsdWUuZGF0YVR5cGUpfSwgYDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IG91dHB1dFNoYXBlcyA9ICcnO1xuICAgICAgICAgICAgb3V0cHV0VGVuc29yVmlld3MuZm9yRWFjaCgodmFsdWUsIGkpID0+IHtcbiAgICAgICAgICAgICAgb3V0cHV0U2hhcGVzICs9IGBvdXRwdXRbJHtpfV06IFske3ZhbHVlLmRpbXN9XSB8ICR7dGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcodmFsdWUuZGF0YVR5cGUpfSwgYDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbcHJvZmlsaW5nXSBrZXJuZWwgXCIke2tlcm5lbElkfXwke2tlcm5lbFR5cGV9fCR7a2VybmVsTmFtZX18JHtwcm9ncmFtTmFtZX1cIiAke2lucHV0U2hhcGVzfSR7XG4gICAgICAgICAgICAgICAgb3V0cHV0U2hhcGVzfWV4ZWN1dGlvbiB0aW1lOiAke2VuZFRpbWUgLSBzdGFydFRpbWV9IG5zYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFRSQUNFKCdHUFUnLCBgJHtwcm9ncmFtTmFtZX06OiR7c3RhcnRUaW1lVTY0fTo6JHtlbmRUaW1lVTY0fWApO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXJ5UmVhZEJ1ZmZlci51bm1hcCgpO1xuICAgICAgICB0aGlzLnBlbmRpbmdRdWVyaWVzLmRlbGV0ZShxdWVyeVJlYWRCdWZmZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIFRSQUNFX0ZVTkNfRU5EKCk7XG4gIH1cblxuICAvKipcbiAgICogcnVuIGEgV2ViR1BVIHByb2dyYW0uXG4gICAqIEBwYXJhbSBwcm9ncmFtIGEgUHJvZ3JhbUluZm8gaW5zdGFuY2VcbiAgICogQHBhcmFtIGlucHV0VGVuc29yVmlld3MgYSBUZW5zb3JWaWV3IGFycmF5LiBlYWNoIGVsZW1lbnQgcmVwcmVzZW50cyBhIHZhbHVlIGFscmVhZHkgZXhpc3RzIGluIEdQVS5cbiAgICogQHBhcmFtIG91dHB1dEluZGljZXMgYW4gaW5kaWNlcyBhcnJheS4gZWFjaCBlbGVtZW50IGNhbiBiZSBlaXRoZXIgLTEgKHRlbXBvcmFyeSBkYXRhKSwgLTIgKHBlcnNpc3RlbnQgZGF0YSkgb3IgYW5cbiAgICogaW5kZXggdG8gdGhlIGtlcm5lbCdzIG91dHB1dC5cbiAgICogQHBhcmFtIGNyZWF0ZUtlcm5lbE91dHB1dCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgY3JlYXRlIGEgdmFsdWUgdG8ga2VybmVsJ3Mgb3V0cHV0IHdpdGggdGhlIGdpdmVuIGluZGV4XG4gICAqIEBwYXJhbSBjcmVhdGVJbnRlcm1lZGlhdGVPdXRwdXQgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGNyZWF0ZSBhIHZhbHVlIGFzIGEgaW50ZXJtZWRpYXRlIHZhbHVlLCBlaXRoZXIgdGVtcG9yYXJ5XG4gICAqIG9yIHBlcnNpc3RlbnQgKG93bmVkIGJ5IHRoZSBjdXJyZW50IGtlcm5lbClcbiAgICogQHJldHVybnMgYSBUZW5zb3JWaWV3IGFycmF5IHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICAgKi9cbiAgcnVuKHByb2dyYW06IFByb2dyYW1JbmZvLCBpbnB1dFRlbnNvclZpZXdzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIG91dHB1dEluZGljZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgICAgY3JlYXRlS2VybmVsT3V0cHV0OiAoaW5kZXg6IG51bWJlciwgZGF0YVR5cGU6IG51bWJlciwgZGltczogcmVhZG9ubHkgbnVtYmVyW10pID0+IFRlbnNvclZpZXcsXG4gICAgICBjcmVhdGVJbnRlcm1lZGlhdGVPdXRwdXQ6IChkYXRhVHlwZTogbnVtYmVyLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSkgPT4gVGVuc29yVmlldyxcbiAgICAgIG91dHB1dENvdW50OiBudW1iZXIpOiBUZW5zb3JWaWV3W10ge1xuICAgIFRSQUNFX0ZVTkNfQkVHSU4ocHJvZ3JhbS5uYW1lKTtcbiAgICAvLyBjcmVhdGUgaW5mbyBmb3IgaW5wdXRzXG4gICAgY29uc3QgaW5wdXREYXRhczogR3B1RGF0YVtdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFRlbnNvclZpZXdzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBkYXRhID0gaW5wdXRUZW5zb3JWaWV3c1tpXS5kYXRhO1xuICAgICAgLy8gaWYgdGVuc29yIHZpZXcgZGF0YSBpcyAwLCBpdCBtZWFucyB0aGUgb3V0cHV0IGlzIHplcm8tc2l6ZWQgdGVuc29yLCBhbmQgdGhlcmUgaXMgbm8gR1BVIGRhdGEgZm9yIGl0LlxuICAgICAgaWYgKGRhdGEgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBncHVEYXRhID0gdGhpcy5ncHVEYXRhTWFuYWdlci5nZXQoZGF0YSk7XG4gICAgICBpZiAoIWdwdURhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3IgaW5wdXQ6ICR7ZGF0YX1gKTtcbiAgICAgIH1cbiAgICAgIGlucHV0RGF0YXMucHVzaChncHVEYXRhKTtcbiAgICB9XG5cbiAgICBjb25zdCB7b3V0cHV0cywgZGlzcGF0Y2hHcm91cCwgcHJvZ3JhbVVuaWZvcm1zfSA9IHByb2dyYW0uZ2V0UnVuRGF0YShpbnB1dFRlbnNvclZpZXdzKTtcblxuICAgIC8vIGNoZWNrIG91dHB1dCBpbmRpY2VzXG4gICAgY29uc3QgdmFsaWRhdGVkT3V0cHV0SW5kaWNlcyA9IG91dHB1dEluZGljZXMubGVuZ3RoID09PSAwID8gb3V0cHV0cy5tYXAoKF8sIGkpID0+IGkpIDogb3V0cHV0SW5kaWNlcztcbiAgICBpZiAodmFsaWRhdGVkT3V0cHV0SW5kaWNlcy5sZW5ndGggIT09IG91dHB1dHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE91dHB1dCBzaXplICR7dmFsaWRhdGVkT3V0cHV0SW5kaWNlcy5sZW5ndGh9IG11c3QgYmUgZXF1YWwgdG8gJHtvdXRwdXRzLmxlbmd0aH0uYCk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGluZm8gZm9yIG91dHB1dHNcbiAgICBjb25zdCBvdXRwdXRUZW5zb3JWaWV3czogVGVuc29yVmlld1tdID0gW107XG4gICAgY29uc3Qgb3V0cHV0RGF0YXM6IEdwdURhdGFbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgLy8gdmFsdWUgLTEgYW5kIC0yIGFyZSB1c2VkIGZvciBjcmVhdGluZyB0ZW1wb3JhcnkgYW5kIHBlcnNpc3RlbnQgb3V0cHV0cy5cbiAgICAgIC8vIHZhbHVlIC0zIGlzIHVzZWQgZm9yIHBsYWNlaG9sZGVyIG91dHB1dC4gU28gLTMsIC0yLCAtMSBhbmQgMCwgMSwgMiwgLi4uIGFyZSB2YWxpZFxuICAgICAgLy8gb3V0cHV0IGluZGljZXMuIHNlZSB0eXBlIGRlZmluaXRpb24gb2YgQ29tcHV0ZUNvbnRleHRJbnB1dHNPdXRwdXRzTWFwcGluZyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHZhbGlkYXRlZE91dHB1dEluZGljZXNbaV0pIHx8IHZhbGlkYXRlZE91dHB1dEluZGljZXNbaV0gPCAtMyB8fFxuICAgICAgICAgIHZhbGlkYXRlZE91dHB1dEluZGljZXNbaV0gPj0gb3V0cHV0Q291bnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG91dHB1dCBpbmRleDogJHt2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzW2ldfWApO1xuICAgICAgfVxuICAgICAgaWYgKHZhbGlkYXRlZE91dHB1dEluZGljZXNbaV0gPT09IC0zKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNUZW1wb3JhcnkgPSB2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzW2ldID09PSAtMTtcbiAgICAgIGNvbnN0IGlzUGVyc2lzdGVudCA9IHZhbGlkYXRlZE91dHB1dEluZGljZXNbaV0gPT09IC0yO1xuICAgICAgY29uc3QgdGVuc29yVmlldyA9IChpc1RlbXBvcmFyeSB8fCBpc1BlcnNpc3RlbnQpID9cbiAgICAgICAgICBjcmVhdGVJbnRlcm1lZGlhdGVPdXRwdXQob3V0cHV0c1tpXS5kYXRhVHlwZSwgb3V0cHV0c1tpXS5kaW1zKSA6XG4gICAgICAgICAgY3JlYXRlS2VybmVsT3V0cHV0KHZhbGlkYXRlZE91dHB1dEluZGljZXNbaV0sIG91dHB1dHNbaV0uZGF0YVR5cGUsIG91dHB1dHNbaV0uZGltcyk7XG4gICAgICBvdXRwdXRUZW5zb3JWaWV3cy5wdXNoKHRlbnNvclZpZXcpO1xuICAgICAgLy8gaWYgdGVuc29yIHZpZXcgZGF0YSBpcyAwLCBpdCBtZWFucyB0aGUgb3V0cHV0IGlzIHplcm8tc2l6ZWQgdGVuc29yLCBhbmQgdGhlcmUgaXMgbm8gR1BVIGRhdGEgZm9yIGl0LlxuICAgICAgaWYgKHRlbnNvclZpZXcuZGF0YSA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGdwdURhdGEgPSB0aGlzLmdwdURhdGFNYW5hZ2VyLmdldCh0ZW5zb3JWaWV3LmRhdGEpO1xuICAgICAgaWYgKCFncHVEYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIG91dHB1dDogJHt0ZW5zb3JWaWV3LmRhdGF9YCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNUZW1wb3JhcnkpIHtcbiAgICAgICAgdGhpcy50ZW1wb3JhcnlEYXRhLnB1c2goZ3B1RGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNQZXJzaXN0ZW50KSB7XG4gICAgICAgIGxldCBwZXJzaXN0ZW50RGF0YSA9IHRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZ2V0KHRoaXMuY3VycmVudEtlcm5lbElkISk7XG4gICAgICAgIGlmICghcGVyc2lzdGVudERhdGEpIHtcbiAgICAgICAgICBwZXJzaXN0ZW50RGF0YSA9IFtdO1xuICAgICAgICAgIHRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuc2V0KHRoaXMuY3VycmVudEtlcm5lbElkISwgcGVyc2lzdGVudERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHBlcnNpc3RlbnREYXRhLnB1c2goZ3B1RGF0YSk7XG4gICAgICB9XG4gICAgICBvdXRwdXREYXRhcy5wdXNoKGdwdURhdGEpO1xuICAgIH1cblxuICAgIC8vIHdoZW4gdGhlcmUgYXJlIGFueSB6ZXJvLXNpemVkIHRlbnNvciBpbiB0aGUgaW5wdXRzIG9yIG91dHB1dHMsIHdlIHNob3VsZCByZXBvcnQgZXJyb3IgdW5sZXNzIGFsbCBvdXRwdXRzIGFyZVxuICAgIC8vIHplcm8tc2l6ZWQgdGVuc29ycy5cbiAgICBpZiAoaW5wdXREYXRhcy5sZW5ndGggIT09IGlucHV0VGVuc29yVmlld3MubGVuZ3RoIHx8IG91dHB1dERhdGFzLmxlbmd0aCAhPT0gb3V0cHV0VGVuc29yVmlld3MubGVuZ3RoKSB7XG4gICAgICAvLyBpZiBhbGwgb3V0cHV0cyBhcmUgemVyby1zaXplZCB0ZW5zb3JzLCB0aGVyZSBpcyBubyBuZWVkIHRvIHJ1biB0aGUgcHJvZ3JhbS5cbiAgICAgIGlmIChvdXRwdXREYXRhcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgVFJBQ0VfRlVOQ19FTkQocHJvZ3JhbS5uYW1lKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dFRlbnNvclZpZXdzO1xuICAgICAgfVxuICAgICAgLy8gaWYgc29tZSBvdXRwdXRzIGFyZSB6ZXJvLXNpemVkIHRlbnNvcnMsIHJlcG9ydCBhbiBlcnJvci5cbiAgICAgIC8vXG4gICAgICAvLyBUT0RPOiBzbyBmYXIgd2UgZG9uJ3Qgc2VlIGFueSB1c2UgY2FzZSB0aGF0IG91dHB1dHMgaW5jbHVkZSBib3RoIHplcm8tc2l6ZWQgdGVuc29ycyBhbmQgbm9uLXplcm8tc2l6ZWQgdGVuc29ycy5cbiAgICAgIC8vIElmIHdlIHNlZSBzdWNoIHVzZSBjYXNlLCB3ZSBuZWVkIHRvIG1ha2UgYSBjaGFuZ2UgaGVyZSB0byBzdXBwb3J0IGl0LlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBQcm9ncmFtICR7cHJvZ3JhbS5uYW1lfSBoYXMgemVyby1zaXplZCB0ZW5zb3IocykgaW4gaW5wdXRzIG9yIG91dHB1dHMuIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBub3cuYCk7XG4gICAgfVxuXG4gICAgLy8gbG9hZCB1bmlmb3Jtc1xuICAgIC8vIFRPRE86IGFkZCBjYWNoZSBmb3IgdW5pZm9ybSAoaXMgaXQgbmVjZXNzYXJ5PylcbiAgICAvL1xuICAgIGxldCB1bmlmb3JtQnVmZmVyQmluZGluZzogR1BVQmluZGluZ1Jlc291cmNlfHVuZGVmaW5lZDtcbiAgICBpZiAocHJvZ3JhbVVuaWZvcm1zKSB7XG4gICAgICBsZXQgY3VycmVudE9mZnNldCA9IDA7XG4gICAgICBjb25zdCBvZmZzZXRzOiBudW1iZXJbXSA9IFtdO1xuXG4gICAgICBwcm9ncmFtVW5pZm9ybXMuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiB2LmRhdGEgPT09ICdudW1iZXInID8gW3YuZGF0YV0gOiB2LmRhdGE7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvV0dTTC8jYWxpZ25vZlxuICAgICAgICBjb25zdCBzaXplT2ZFbGVtZW50ID0gdi50eXBlID09PSBEYXRhVHlwZS5mbG9hdDE2ID8gMiA6IDQ7XG4gICAgICAgIGxldCBzaXplT2ZWZWNPck1hdDtcbiAgICAgICAgbGV0IGJhc2VBbGlnbm1lbnQ7XG4gICAgICAgIGlmICh2LnR5cGUgPT09IERhdGFUeXBlLmZsb2F0MTYpIHtcbiAgICAgICAgICBiYXNlQWxpZ25tZW50ID0gZGF0YS5sZW5ndGggPiA0ID8gMTYgOiAoZGF0YS5sZW5ndGggPiAyID8gOCA6IGRhdGEubGVuZ3RoICogc2l6ZU9mRWxlbWVudCk7XG4gICAgICAgICAgc2l6ZU9mVmVjT3JNYXQgPSBkYXRhLmxlbmd0aCA+IDQgPyAxNiA6IHNpemVPZkVsZW1lbnQgKiBkYXRhLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiYXNlQWxpZ25tZW50ID0gZGF0YS5sZW5ndGggPD0gMiA/IGRhdGEubGVuZ3RoICogc2l6ZU9mRWxlbWVudCA6IDE2O1xuICAgICAgICAgIHNpemVPZlZlY09yTWF0ID0gMTY7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudE9mZnNldCA9IE1hdGguY2VpbChjdXJyZW50T2Zmc2V0IC8gYmFzZUFsaWdubWVudCkgKiBiYXNlQWxpZ25tZW50O1xuICAgICAgICBvZmZzZXRzLnB1c2goY3VycmVudE9mZnNldCk7XG4gICAgICAgIC8vIEZvciBub24tZmxvYXQxNiB0eXBlLCB3aGVuIGRhdGEubGVuZ3RoID4gNCwgdGhlIHVuaWZvcm0gdmFyaWFibGUgaXMgb2YgdHlwZSBhcnJheTx2ZWM0PGkzMnx1MzJ8ZjMyPixOPiwgd2hlcmVcbiAgICAgICAgLy8gTiA9IE1hdGguY2VpbChkYXRhLmxlbmd0aCAvIDQpIGFuZCBTaXplT2YodmVjNDxpMzJ8dTMyfGYzMj4pID0gMTYuIFRoZSB0b3RhbCBieXRlIGxlbmd0aCBpcyBOICpcbiAgICAgICAgLy8gU2l6ZU9mKHZlYzQ8aTMyfHUzMnxmMzI+KS4gRm9yIGZsb2F0MTYgdHlwZSwgd2hlbiBkYXRhLmxlbmd0aCA+IDQsIHRoZSB1bmlmb3JtIHZhcmlhYmxlIGlzIG9mIHR5cGVcbiAgICAgICAgLy8gYXJyYXk8bWF0Mng0PGYxNj4sTj4sIHdoZXJlIE4gPSBNYXRoLmNlaWwoZGF0YS5sZW5ndGggLyA4KSBhbmQgU2l6ZU9mKG1hdDJ4NDxmMTY+KSA9IDE2LiBUaGUgdG90YWwgYnl0ZVxuICAgICAgICAvLyBsZW5ndGggaXMgTiAqIFNpemVPZihtYXQyeDQ8ZjE2PikuXG4gICAgICAgIGNvbnN0IGVsZW1lbnRQZXJWZWNPck1hdCA9IHYudHlwZSA9PT0gRGF0YVR5cGUuZmxvYXQxNiA/IDggOiA0O1xuICAgICAgICBjdXJyZW50T2Zmc2V0ICs9IGRhdGEubGVuZ3RoID4gNCA/IE1hdGguY2VpbChkYXRhLmxlbmd0aCAvIGVsZW1lbnRQZXJWZWNPck1hdCkgKiBzaXplT2ZWZWNPck1hdCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5sZW5ndGggKiBzaXplT2ZFbGVtZW50O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIE1lZXQgYWxpZ25tZW50IG9mIHN0cnVjdCBoZXJlOiBodHRwczovL3d3dy53My5vcmcvVFIvV0dTTC8jYWxpZ25tZW50LWFuZC1zaXplLiBGb3Igc2ltcGxpY2l0eSwgc2V0XG4gICAgICAvLyBtYXhBbGlnbm1lbnRPZkZpZWxkIHRvIDE2IHNpbmNlIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlciBoYXMgYmVlbiByb3VuZGVkIHVwIHRvIDE2LlxuICAgICAgY29uc3QgbWF4QWxpZ25tZW50T2ZGaWVsZCA9IDE2O1xuICAgICAgY3VycmVudE9mZnNldCA9IE1hdGguY2VpbChjdXJyZW50T2Zmc2V0IC8gbWF4QWxpZ25tZW50T2ZGaWVsZCkgKiBtYXhBbGlnbm1lbnRPZkZpZWxkO1xuICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoY3VycmVudE9mZnNldCk7XG4gICAgICBwcm9ncmFtVW5pZm9ybXMuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBvZmZzZXRzW2ldO1xuICAgICAgICBjb25zdCBkYXRhID0gdHlwZW9mIHYuZGF0YSA9PT0gJ251bWJlcicgPyBbdi5kYXRhXSA6IHYuZGF0YTtcbiAgICAgICAgaWYgKHYudHlwZSA9PT0gRGF0YVR5cGUuaW50MzIpIHtcbiAgICAgICAgICBuZXcgSW50MzJBcnJheShhcnJheUJ1ZmZlciwgb2Zmc2V0LCBkYXRhLmxlbmd0aCkuc2V0KGRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKHYudHlwZSA9PT0gRGF0YVR5cGUudWludDMyKSB7XG4gICAgICAgICAgbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmZmVyLCBvZmZzZXQsIGRhdGEubGVuZ3RoKS5zZXQoZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAodi50eXBlID09PSBEYXRhVHlwZS5mbG9hdDE2KSB7XG4gICAgICAgICAgLy8gVE9ETzogdXNlIEZsb2F0MTZBcnJheS5cbiAgICAgICAgICBuZXcgVWludDE2QXJyYXkoYXJyYXlCdWZmZXIsIG9mZnNldCwgZGF0YS5sZW5ndGgpLnNldChkYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmICh2LnR5cGUgPT09IERhdGFUeXBlLmZsb2F0KSB7XG4gICAgICAgICAgbmV3IEZsb2F0MzJBcnJheShhcnJheUJ1ZmZlciwgb2Zmc2V0LCBkYXRhLmxlbmd0aCkuc2V0KGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdW5pZm9ybSB0eXBlOiAke3RlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nKHYudHlwZSl9YCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB1bmlmb3JtQnVmZmVyRGF0YSA9XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZShjdXJyZW50T2Zmc2V0LCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCB8IEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pO1xuICAgICAgdGhpcy5kZXZpY2UucXVldWUud3JpdGVCdWZmZXIodW5pZm9ybUJ1ZmZlckRhdGEuYnVmZmVyLCAwLCBhcnJheUJ1ZmZlciwgMCwgY3VycmVudE9mZnNldCk7XG4gICAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UodW5pZm9ybUJ1ZmZlckRhdGEuaWQpO1xuICAgICAgdW5pZm9ybUJ1ZmZlckJpbmRpbmcgPSB7b2Zmc2V0OiAwLCBzaXplOiBjdXJyZW50T2Zmc2V0LCBidWZmZXI6IHVuaWZvcm1CdWZmZXJEYXRhLmJ1ZmZlcn07XG4gICAgfVxuXG4gICAgY29uc3Qgbm9ybWFsaXplZERpc3BhdGNoR3JvdXAgPSB0aGlzLnByb2dyYW1NYW5hZ2VyLm5vcm1hbGl6ZURpc3BhdGNoR3JvdXBTaXplKGRpc3BhdGNoR3JvdXApO1xuICAgIGNvbnN0IGlzMURpbWVuc2lvbkRpc3BhdGNoID0gbm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMV0gPT09IDEgJiYgbm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMl0gPT09IDE7XG4gICAgLy8gZ2V0IHByb2dyYW0gaW5mb1xuICAgIGNvbnN0IGtleSA9IGdldFByb2dyYW1JbmZvVW5pcXVlS2V5KHByb2dyYW0sIGlucHV0VGVuc29yVmlld3MsIGlzMURpbWVuc2lvbkRpc3BhdGNoKTtcbiAgICBsZXQgYXJ0aWZhY3QgPSB0aGlzLnByb2dyYW1NYW5hZ2VyLmdldEFydGlmYWN0KGtleSk7XG4gICAgaWYgKCFhcnRpZmFjdCkge1xuICAgICAgYXJ0aWZhY3QgPSB0aGlzLnByb2dyYW1NYW5hZ2VyLmJ1aWxkKHByb2dyYW0sIG5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwKTtcbiAgICAgIHRoaXMucHJvZ3JhbU1hbmFnZXIuc2V0QXJ0aWZhY3Qoa2V5LCBhcnRpZmFjdCk7XG4gICAgICBMT0dfREVCVUcoJ2luZm8nLCAoKSA9PiBgW2FydGlmYWN0XSBrZXk6ICR7a2V5fSwgcHJvZ3JhbU5hbWU6ICR7cHJvZ3JhbS5uYW1lfWApO1xuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIHVuaWZvcm0gdmFyaWFibGVzXG4gICAgaWYgKHByb2dyYW1Vbmlmb3JtcyAmJiBhcnRpZmFjdC51bmlmb3JtVmFyaWFibGVzSW5mbykge1xuICAgICAgaWYgKHByb2dyYW1Vbmlmb3Jtcy5sZW5ndGggIT09IGFydGlmYWN0LnVuaWZvcm1WYXJpYWJsZXNJbmZvLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaWZvcm0gdmFyaWFibGVzIGNvdW50IG1pc21hdGNoOiBleHBlY3QgJHthcnRpZmFjdC51bmlmb3JtVmFyaWFibGVzSW5mby5sZW5ndGh9LCBnb3QgJHtcbiAgICAgICAgICAgIHByb2dyYW1Vbmlmb3Jtcy5sZW5ndGh9IGluIHByb2dyYW0gXCIke2FydGlmYWN0LnByb2dyYW1JbmZvLm5hbWV9XCIuYCk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb2dyYW1Vbmlmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB1bmlmb3JtID0gcHJvZ3JhbVVuaWZvcm1zW2ldO1xuICAgICAgICBjb25zdCBhY3R1YWxUeXBlID0gdW5pZm9ybS50eXBlO1xuICAgICAgICBjb25zdCBhY3R1YWxMZW5ndGggPSB0eXBlb2YgdW5pZm9ybS5kYXRhID09PSAnbnVtYmVyJyA/IDEgOiB1bmlmb3JtLmRhdGEubGVuZ3RoO1xuICAgICAgICBjb25zdCBbdHlwZSwgbGVuZ3RoXSA9IGFydGlmYWN0LnVuaWZvcm1WYXJpYWJsZXNJbmZvW2ldO1xuICAgICAgICBpZiAoYWN0dWFsVHlwZSAhPT0gdHlwZSB8fCBhY3R1YWxMZW5ndGggIT09IGxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5pZm9ybSB2YXJpYWJsZSAke2l9IG1pc21hdGNoOiBleHBlY3QgdHlwZSAke3R5cGV9IHdpdGggc2l6ZSAke2xlbmd0aH0sIGdvdCB0eXBlICR7XG4gICAgICAgICAgICAgIGFjdHVhbFR5cGV9IHdpdGggc2l6ZSAke2FjdHVhbExlbmd0aH0gaW4gcHJvZ3JhbSBcIiR7YXJ0aWZhY3QucHJvZ3JhbUluZm8ubmFtZX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIExPR19ERUJVRyhcbiAgICAgICAgJ2luZm8nLFxuICAgICAgICAoKSA9PiBgW1Byb2dyYW1NYW5hZ2VyXSBydW4gXCIke3Byb2dyYW0ubmFtZX1cIiAoa2V5PSR7a2V5fSkgd2l0aCAke25vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzBdfXgke1xuICAgICAgICAgICAgbm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMV19eCR7bm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMl19YCk7XG5cbiAgICBpZiAodGhpcy5xdWVyeVR5cGUgIT09ICdub25lJyB8fCB0aGlzLnNlc3Npb25TdGF0dXMgPT09ICdjYXB0dXJpbmcnKSB7XG4gICAgICBjb25zdCBwZW5kaW5nS2VybmVsSW5mbzogUGVuZGluZ0tlcm5lbEluZm8gPSB7XG4gICAgICAgIGtlcm5lbElkOiB0aGlzLmN1cnJlbnRLZXJuZWxJZCEsXG4gICAgICAgIHByb2dyYW1OYW1lOiBhcnRpZmFjdC5wcm9ncmFtSW5mby5uYW1lLFxuICAgICAgICBpbnB1dFRlbnNvclZpZXdzLFxuICAgICAgICBvdXRwdXRUZW5zb3JWaWV3cyxcbiAgICAgIH07XG4gICAgICB0aGlzLnBlbmRpbmdLZXJuZWxzLnB1c2gocGVuZGluZ0tlcm5lbEluZm8pO1xuXG4gICAgICBpZiAodGhpcy5zZXNzaW9uU3RhdHVzID09PSAnY2FwdHVyaW5nJykge1xuICAgICAgICBjb25zdCBzZXNzaW9uUGVuZGluZ0tlcm5lbHMgPSB0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCEpO1xuICAgICAgICBzZXNzaW9uUGVuZGluZ0tlcm5lbHMhLnB1c2gocGVuZGluZ0tlcm5lbEluZm8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucHJvZ3JhbU1hbmFnZXIucnVuKGFydGlmYWN0LCBpbnB1dERhdGFzLCBvdXRwdXREYXRhcywgbm9ybWFsaXplZERpc3BhdGNoR3JvdXAsIHVuaWZvcm1CdWZmZXJCaW5kaW5nKTtcblxuICAgIFRSQUNFX0ZVTkNfRU5EKHByb2dyYW0ubmFtZSk7XG4gICAgcmV0dXJuIG91dHB1dFRlbnNvclZpZXdzO1xuICB9XG5cbiAgdXBsb2FkKGdwdURhdGFJZDogbnVtYmVyLCBkYXRhOiBVaW50OEFycmF5KTogdm9pZCB7XG4gICAgdGhpcy5ncHVEYXRhTWFuYWdlci51cGxvYWQoZ3B1RGF0YUlkLCBkYXRhKTtcbiAgfVxuXG4gIG1lbWNweShzcmM6IG51bWJlciwgZHN0OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLm1lbWNweShzcmMsIGRzdCk7XG4gIH1cblxuICBhc3luYyBkb3dubG9hZChncHVEYXRhSWQ6IG51bWJlciwgZ2V0VGFyZ2V0QnVmZmVyOiAoKSA9PiBVaW50OEFycmF5KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gdGhlIHVuZGVybHlpbmcgYnVmZmVyIG1heSBiZSBjaGFuZ2VkIGFmdGVyIHRoZSBhc3luYyBmdW5jdGlvbiBpcyBjYWxsZWQuIHNvIHdlIHVzZSBhIGdldHRlciBmdW5jdGlvbiB0byBtYWtlIHN1cmVcbiAgICAvLyB0aGUgYnVmZmVyIGlzIHVwLXRvLWRhdGUuXG4gICAgYXdhaXQgdGhpcy5ncHVEYXRhTWFuYWdlci5kb3dubG9hZChncHVEYXRhSWQsIGdldFRhcmdldEJ1ZmZlcik7XG4gIH1cblxuICBhbGxvYyhzaXplOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZShzaXplKS5pZDtcbiAgfVxuXG4gIGZyZWUocHRyOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UocHRyKTtcbiAgfVxuXG4gIGNyZWF0ZUtlcm5lbChrZXJuZWxUeXBlOiBzdHJpbmcsIGtlcm5lbElkOiBudW1iZXIsIGF0dHJpYnV0ZTogdW5rbm93biwga2VybmVsTmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3Qgb3AgPSBXRUJHUFVfT1BfUkVTT0xWRV9SVUxFUy5nZXQoa2VybmVsVHlwZSk7XG4gICAgaWYgKCFvcCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBrZXJuZWwgbm90IGltcGxlbWVudGVkOiAke2tlcm5lbFR5cGV9YCk7XG4gICAgfVxuXG4gICAgY29uc3Qga2VybmVsSW5mbzogS2VybmVsSW5mbyA9IHtcbiAgICAgIGtlcm5lbFR5cGUsXG4gICAgICBrZXJuZWxOYW1lLFxuICAgICAga2VybmVsRW50cnk6IG9wWzBdLFxuICAgICAgYXR0cmlidXRlczogW29wWzFdLCBhdHRyaWJ1dGVdLFxuICAgIH07XG4gICAgdGhpcy5rZXJuZWxzLnNldChrZXJuZWxJZCwga2VybmVsSW5mbyk7XG4gIH1cblxuICByZWxlYXNlS2VybmVsKGtlcm5lbElkOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBwZXJzaXN0ZW50RGF0YSA9IHRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZ2V0KGtlcm5lbElkKTtcbiAgICBpZiAocGVyc2lzdGVudERhdGEpIHtcbiAgICAgIGZvciAoY29uc3QgZGF0YSBvZiBwZXJzaXN0ZW50RGF0YSkge1xuICAgICAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoZGF0YS5pZCk7XG4gICAgICB9XG4gICAgICB0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmRlbGV0ZShrZXJuZWxJZCk7XG4gICAgfVxuXG4gICAgdGhpcy5rZXJuZWxDdXN0b21EYXRhLmRlbGV0ZShrZXJuZWxJZCk7XG4gICAgdGhpcy5rZXJuZWxzLmRlbGV0ZShrZXJuZWxJZCk7XG4gIH1cblxuICBjb21wdXRlS2VybmVsKGtlcm5lbElkOiBudW1iZXIsIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBlcnJvcnM6IEFycmF5PFByb21pc2U8c3RyaW5nfG51bGw+Pik6IG51bWJlciB7XG4gICAgY29uc3Qga2VybmVsID0gdGhpcy5rZXJuZWxzLmdldChrZXJuZWxJZCk7XG4gICAgaWYgKCFrZXJuZWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihga2VybmVsIG5vdCBjcmVhdGVkOiAke2tlcm5lbElkfWApO1xuICAgIH1cbiAgICBjb25zdCBrZXJuZWxUeXBlID0ga2VybmVsLmtlcm5lbFR5cGU7XG4gICAgY29uc3Qga2VybmVsTmFtZSA9IGtlcm5lbC5rZXJuZWxOYW1lO1xuICAgIGNvbnN0IGtlcm5lbEVudHJ5ID0ga2VybmVsLmtlcm5lbEVudHJ5O1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBrZXJuZWwuYXR0cmlidXRlcztcbiAgICBpZiAodGhpcy5jdXJyZW50S2VybmVsSWQgIT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihga2VybmVsIFwiWyR7a2VybmVsVHlwZX1dICR7a2VybmVsTmFtZX1cIiBpcyBub3QgYWxsb3dlZCB0byBiZSBjYWxsZWQgcmVjdXJzaXZlbHlgKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50S2VybmVsSWQgPSBrZXJuZWxJZDtcblxuICAgIC8vIHBhcnNlIGF0dHJpYnV0ZXMgaWYgbmVjZXNzYXJ5XG4gICAgaWYgKGF0dHJpYnV0ZXNbMF0pIHtcbiAgICAgIGF0dHJpYnV0ZXNbMV0gPSBhdHRyaWJ1dGVzWzBdKGF0dHJpYnV0ZXNbMV0pO1xuICAgICAgYXR0cmlidXRlc1swXSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBMT0dfREVCVUcoJ2luZm8nLCAoKSA9PiBgW1dlYkdQVV0gU3RhcnQgdG8gcnVuIGtlcm5lbCBcIlske2tlcm5lbFR5cGV9XSAke2tlcm5lbE5hbWV9XCIuLi5gKTtcblxuICAgIGNvbnN0IHVzZUVycm9yU2NvcGUgPSB0aGlzLmVudi5kZWJ1ZztcblxuICAgIHRoaXMudGVtcG9yYXJ5RGF0YSA9IFtdO1xuICAgIHRyeSB7XG4gICAgICBpZiAodXNlRXJyb3JTY29wZSkge1xuICAgICAgICB0aGlzLmRldmljZS5wdXNoRXJyb3JTY29wZSgndmFsaWRhdGlvbicpO1xuICAgICAgfVxuXG4gICAgICBrZXJuZWxFbnRyeShjb250ZXh0LCBhdHRyaWJ1dGVzWzFdKTtcbiAgICAgIHJldHVybiAwOyAgLy8gT1JUX09LXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3JzLnB1c2goUHJvbWlzZS5yZXNvbHZlKGBbV2ViR1BVXSBLZXJuZWwgXCJbJHtrZXJuZWxUeXBlfV0gJHtrZXJuZWxOYW1lfVwiIGZhaWxlZC4gJHtlfWApKTtcbiAgICAgIHJldHVybiAxOyAgLy8gT1JUX0ZBSUxcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHVzZUVycm9yU2NvcGUpIHtcbiAgICAgICAgZXJyb3JzLnB1c2godGhpcy5kZXZpY2UucG9wRXJyb3JTY29wZSgpLnRoZW4oXG4gICAgICAgICAgICBlcnIgPT4gZXJyID8gYEdQVSB2YWxpZGF0aW9uIGVycm9yIGZvciBrZXJuZWwgXCJbJHtrZXJuZWxUeXBlfV0gJHtrZXJuZWxOYW1lfVwiOiAke2Vyci5tZXNzYWdlfWAgOiBudWxsKSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgZGF0YSBvZiB0aGlzLnRlbXBvcmFyeURhdGEpIHtcbiAgICAgICAgdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKGRhdGEuaWQpO1xuICAgICAgfVxuICAgICAgdGhpcy50ZW1wb3JhcnlEYXRhID0gW107XG4gICAgICB0aGlzLmN1cnJlbnRLZXJuZWxJZCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gI3JlZ2lvbiBleHRlcm5hbCBidWZmZXJcbiAgcmVnaXN0ZXJCdWZmZXIoc2Vzc2lvbklkOiBudW1iZXIsIGluZGV4OiBudW1iZXIsIGJ1ZmZlcjogR1BVQnVmZmVyLCBzaXplOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGxldCBzZXNzaW9uSW5wdXRPdXRwdXRNYXBwaW5nID0gdGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5nZXQoc2Vzc2lvbklkKTtcbiAgICBpZiAoIXNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcpIHtcbiAgICAgIHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLnNldChzZXNzaW9uSWQsIHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcpO1xuICAgIH1cblxuICAgIGNvbnN0IHByZXZpb3VzQnVmZmVyID0gc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZy5nZXQoaW5kZXgpO1xuICAgIGNvbnN0IGlkID0gdGhpcy5ncHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKGJ1ZmZlciwgc2l6ZSwgcHJldmlvdXNCdWZmZXI/LlsxXSk7XG4gICAgc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZy5zZXQoaW5kZXgsIFtpZCwgYnVmZmVyXSk7XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIHVucmVnaXN0ZXJCdWZmZXJzKHNlc3Npb25JZDogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3Qgc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZyA9IHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZ2V0KHNlc3Npb25JZCk7XG4gICAgaWYgKHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcpIHtcbiAgICAgIHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcuZm9yRWFjaChidWZmZXJJbmZvID0+IHRoaXMuZ3B1RGF0YU1hbmFnZXIudW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKGJ1ZmZlckluZm9bMV0pKTtcbiAgICAgIHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZGVsZXRlKHNlc3Npb25JZCk7XG4gICAgfVxuICB9XG4gIGdldEJ1ZmZlcihncHVEYXRhSWQ6IG51bWJlcik6IEdQVUJ1ZmZlciB7XG4gICAgY29uc3QgZ3B1RGF0YSA9IHRoaXMuZ3B1RGF0YU1hbmFnZXIuZ2V0KGdwdURhdGFJZCk7XG4gICAgaWYgKCFncHVEYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBidWZmZXI6ICR7Z3B1RGF0YUlkfWApO1xuICAgIH1cbiAgICByZXR1cm4gZ3B1RGF0YS5idWZmZXI7XG4gIH1cbiAgY3JlYXRlRG93bmxvYWRlcihncHVCdWZmZXI6IEdQVUJ1ZmZlciwgc2l6ZTogbnVtYmVyLCB0eXBlOiBUZW5zb3IuR3B1QnVmZmVyRGF0YVR5cGVzKTpcbiAgICAgICgpID0+IFByb21pc2U8VGVuc29yLkRhdGFUeXBlPiB7XG4gICAgcmV0dXJuIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBkb3dubG9hZEdwdURhdGEodGhpcywgZ3B1QnVmZmVyLCBzaXplKTtcbiAgICAgIHJldHVybiBjcmVhdGVWaWV3KGRhdGEuYnVmZmVyLCB0eXBlKTtcbiAgICB9O1xuICB9XG4gIC8vICNlbmRyZWdpb25cbiAgd3JpdGVUaW1lc3RhbXAoaW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgIGlmICh0aGlzLnF1ZXJ5VHlwZSAhPT0gJ2luc2lkZS1wYXNzZXMnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAodGhpcy5jb21wdXRlUGFzc0VuY29kZXIgYXMgYW55KS53cml0ZVRpbWVzdGFtcCh0aGlzLnF1ZXJ5U2V0LCBpbmRleCk7XG4gIH1cbiAgc2V0UXVlcnlUeXBlKCk6IHZvaWQge1xuICAgIHRoaXMucXVlcnlUeXBlID0gJ25vbmUnO1xuICAgIGlmICh0aGlzLmVudi53ZWJncHUucHJvZmlsaW5nPy5tb2RlID09PSAnZGVmYXVsdCcgfHxcbiAgICAgICAgKHR5cGVvZiB0aGlzLmVudi50cmFjZSA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLmVudi53YXNtLnRyYWNlIDogdGhpcy5lbnYudHJhY2UpKSB7XG4gICAgICBpZiAodGhpcy5kZXZpY2UuZmVhdHVyZXMuaGFzKCdjaHJvbWl1bS1leHBlcmltZW50YWwtdGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXMnKSkge1xuICAgICAgICB0aGlzLnF1ZXJ5VHlwZSA9ICdpbnNpZGUtcGFzc2VzJztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kZXZpY2UuZmVhdHVyZXMuaGFzKCd0aW1lc3RhbXAtcXVlcnknKSkge1xuICAgICAgICB0aGlzLnF1ZXJ5VHlwZSA9ICdhdC1wYXNzZXMnO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5xdWVyeVR5cGUgIT09ICdub25lJyAmJiB0eXBlb2YgdGhpcy5xdWVyeVNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5xdWVyeVNldCA9IHRoaXMuZGV2aWNlLmNyZWF0ZVF1ZXJ5U2V0KHtcbiAgICAgICAgICB0eXBlOiAndGltZXN0YW1wJyxcbiAgICAgICAgICBjb3VudDogdGhpcy5tYXhEaXNwYXRjaE51bWJlciAqIDIsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnF1ZXJ5UmVzb2x2ZUJ1ZmZlciA9IHRoaXMuZGV2aWNlLmNyZWF0ZUJ1ZmZlcihcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgICAgICB7c2l6ZTogdGhpcy5tYXhEaXNwYXRjaE51bWJlciAqIDIgKiA4LCB1c2FnZTogR1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkMgfCBHUFVCdWZmZXJVc2FnZS5RVUVSWV9SRVNPTFZFfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2FwdHVyZUJlZ2luKCk6IHZvaWQge1xuICAgIExPR19ERUJVRygnaW5mbycsICdjYXB0dXJlQmVnaW4nKTtcbiAgICBpZiAoIXRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkISkpIHtcbiAgICAgIHRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5zZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkISwgW10pO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkISkpIHtcbiAgICAgIHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5zZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkISwgW10pO1xuICAgIH1cbiAgICAvLyBmbHVzaCB0aGUgbGVmdCBjb21tYW5kcyBiZWZvcmUgd2UgY2hhbmdlIHRoZSBzdGF0dXMuXG4gICAgdGhpcy5mbHVzaCgpO1xuICAgIHRoaXMuc2Vzc2lvblN0YXR1cyA9ICdjYXB0dXJpbmcnO1xuICB9XG4gIGNhcHR1cmVFbmQoKTogdm9pZCB7XG4gICAgTE9HX0RFQlVHKCdpbmZvJywgJ2NhcHR1cmVFbmQnKTtcbiAgICAvLyBmbHVzaCB0aGUgbGVmdCBjb21tYW5kcyBiZWZvcmUgd2UgY2hhbmdlIHRoZSBzdGF0dXMuXG4gICAgdGhpcy5mbHVzaCgpO1xuICAgIHRoaXMuc2Vzc2lvblN0YXR1cyA9ICdkZWZhdWx0JztcbiAgfVxuICByZXBsYXkoKTogdm9pZCB7XG4gICAgTE9HX0RFQlVHKCdpbmZvJywgJ3JlcGxheScpO1xuICAgIHRoaXMuc2Vzc2lvblN0YXR1cyA9ICdyZXBsYXlpbmcnO1xuICAgIGNvbnN0IHNlc3Npb25Db21tYW5kTGlzdCA9IHRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkISk7XG4gICAgY29uc3Qgc2Vzc2lvblBlbmRpbmdLZXJuZWxzID0gdGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQhKTtcbiAgICBjb25zdCBsZW5ndGggPSBzZXNzaW9uQ29tbWFuZExpc3QhLmxlbmd0aDtcbiAgICB0aGlzLnBlbmRpbmdLZXJuZWxzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY29tcHV0ZVBhc3NFbmNvZGVyID0gdGhpcy5nZXRDb21wdXRlUGFzc0VuY29kZXIoKTtcbiAgICAgIGNvbnN0IGNvbW1hbmQgPSBzZXNzaW9uQ29tbWFuZExpc3QhW2ldO1xuICAgICAgdGhpcy53cml0ZVRpbWVzdGFtcCh0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIpO1xuICAgICAgY29tcHV0ZVBhc3NFbmNvZGVyLnNldFBpcGVsaW5lKGNvbW1hbmQuY29tcHV0ZVBpcGVsaW5lKTtcbiAgICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5zZXRCaW5kR3JvdXAoMCwgY29tbWFuZC5iaW5kR3JvdXApO1xuICAgICAgY29tcHV0ZVBhc3NFbmNvZGVyLmRpc3BhdGNoV29ya2dyb3VwcyguLi5jb21tYW5kLmRpc3BhdGNoR3JvdXApO1xuICAgICAgdGhpcy53cml0ZVRpbWVzdGFtcCh0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIgKyAxKTtcbiAgICAgIHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKys7XG4gICAgICBpZiAodGhpcy5xdWVyeVR5cGUgIT09ICdub25lJykge1xuICAgICAgICB0aGlzLnBlbmRpbmdLZXJuZWxzLnB1c2goc2Vzc2lvblBlbmRpbmdLZXJuZWxzIVtpXSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgPj0gdGhpcy5tYXhEaXNwYXRjaE51bWJlciB8fCB0aGlzLnF1ZXJ5VHlwZSA9PT0gJ2F0LXBhc3NlcycpIHtcbiAgICAgICAgdGhpcy5lbmRDb21wdXRlUGFzcygpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyID49IHRoaXMubWF4RGlzcGF0Y2hOdW1iZXIpIHtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBmbHVzaCB0aGUgbGVmdCBjb21tYW5kcyBiZWZvcmUgd2UgY2hhbmdlIHRoZSBzdGF0dXMuXG4gICAgdGhpcy5mbHVzaCgpO1xuICAgIHRoaXMuc2Vzc2lvblN0YXR1cyA9ICdkZWZhdWx0JztcbiAgfVxuXG4gIG9uUmVsZWFzZVNlc3Npb24oc2Vzc2lvbklkOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJCdWZmZXJzKHNlc3Npb25JZCk7XG4gICAgaWYgKHRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5oYXMoc2Vzc2lvbklkKSkge1xuICAgICAgdGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0LmRlbGV0ZShzZXNzaW9uSWQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmhhcyhzZXNzaW9uSWQpKSB7XG4gICAgICB0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuZGVsZXRlKHNlc3Npb25JZCk7XG4gICAgfVxuICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIub25SZWxlYXNlU2Vzc2lvbihzZXNzaW9uSWQpO1xuICB9XG5cbiAgb25SdW5TdGFydChzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFNlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgICB0aGlzLnNldFF1ZXJ5VHlwZSgpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7RW52fSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgdHlwZSB7T3J0V2FzbU1vZHVsZX0gZnJvbSAnLi4vd2FzbS10eXBlcyc7XG5pbXBvcnQge0RhdGFUeXBlLCBnZXRUZW5zb3JFbGVtZW50U2l6ZX0gZnJvbSAnLi4vd2FzbS1jb21tb24nO1xuXG5pbXBvcnQge1dlYkdwdUJhY2tlbmR9IGZyb20gJy4vYmFja2VuZC13ZWJncHUnO1xuaW1wb3J0IHtMT0dfREVCVUd9IGZyb20gJy4vbG9nJztcbmltcG9ydCB7VGVuc29yVmlld30gZnJvbSAnLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQge1NoYXBlVXRpbH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7QWRhcHRlckluZm8sIENvbXB1dGVDb250ZXh0LCBDb21wdXRlQ29udGV4dElucHV0c091dHB1dHNNYXBwaW5nLCBQcm9ncmFtSW5mb30gZnJvbSAnLi93ZWJncHUvdHlwZXMnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbmNsYXNzIFRlbnNvclZpZXdJbXBsIGltcGxlbWVudHMgVGVuc29yVmlldyB7XG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHJpdmF0ZSBtb2R1bGU6IE9ydFdhc21Nb2R1bGUsIHB1YmxpYyByZWFkb25seSBkYXRhVHlwZTogbnVtYmVyLCBwdWJsaWMgcmVhZG9ubHkgZGF0YTogbnVtYmVyLFxuICAgICAgcHVibGljIHJlYWRvbmx5IGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKSB7fVxuXG4gIGdldEZsb2F0MzJBcnJheSgpOiBGbG9hdDMyQXJyYXkge1xuICAgIGlmICh0aGlzLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5mbG9hdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRhdGEgdHlwZScpO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50Q291bnQgPSBTaGFwZVV0aWwuc2l6ZSh0aGlzLmRpbXMpO1xuICAgIHJldHVybiBlbGVtZW50Q291bnQgPT09IDAgPyBuZXcgRmxvYXQzMkFycmF5KCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRmxvYXQzMkFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlciwgdGhpcy5kYXRhLCBlbGVtZW50Q291bnQpO1xuICB9XG5cbiAgZ2V0QmlnSW50NjRBcnJheSgpOiBCaWdJbnQ2NEFycmF5IHtcbiAgICBpZiAodGhpcy5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuaW50NjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIHR5cGUnKTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudENvdW50ID0gU2hhcGVVdGlsLnNpemUodGhpcy5kaW1zKTtcbiAgICByZXR1cm4gZWxlbWVudENvdW50ID09PSAwID8gbmV3IEJpZ0ludDY0QXJyYXkoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBCaWdJbnQ2NEFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlciwgdGhpcy5kYXRhLCBlbGVtZW50Q291bnQpO1xuICB9XG5cbiAgZ2V0SW50MzJBcnJheSgpOiBJbnQzMkFycmF5IHtcbiAgICBpZiAodGhpcy5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuaW50MzIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIHR5cGUnKTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudENvdW50ID0gU2hhcGVVdGlsLnNpemUodGhpcy5kaW1zKTtcbiAgICByZXR1cm4gZWxlbWVudENvdW50ID09PSAwID8gbmV3IEludDMyQXJyYXkoKSA6IG5ldyBJbnQzMkFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlciwgdGhpcy5kYXRhLCBlbGVtZW50Q291bnQpO1xuICB9XG5cbiAgcmVzaGFwZShuZXdEaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvclZpZXcge1xuICAgIGlmIChTaGFwZVV0aWwuc2l6ZShuZXdEaW1zKSAhPT0gU2hhcGVVdGlsLnNpemUodGhpcy5kaW1zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG5ldyBzaGFwZScpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlbnNvclZpZXdJbXBsKHRoaXMubW9kdWxlLCB0aGlzLmRhdGFUeXBlLCB0aGlzLmRhdGEsIG5ld0RpbXMpO1xuICB9XG59XG5cbmNsYXNzIENvbXB1dGVDb250ZXh0SW1wbCBpbXBsZW1lbnRzIENvbXB1dGVDb250ZXh0IHtcbiAgcmVhZG9ubHkgYWRhcHRlckluZm86IEFkYXB0ZXJJbmZvO1xuICByZWFkb25seSBvcEtlcm5lbENvbnRleHQ6IG51bWJlcjtcbiAgcmVhZG9ubHkgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W107XG4gIHJlYWRvbmx5IG91dHB1dENvdW50OiBudW1iZXI7XG4gIGdldCBrZXJuZWxDdXN0b21EYXRhKCk6IHtba2V5OiBzdHJpbmddOiB1bmtub3dufSB7XG4gICAgcmV0dXJuIHRoaXMuYmFja2VuZC5jdXJyZW50S2VybmVsQ3VzdG9tRGF0YTtcbiAgfVxuICBnZXQgY3VzdG9tRGF0YUJ1ZmZlcigpOiBVaW50OEFycmF5IHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGUuSEVBUFU4LnN1YmFycmF5KHRoaXMuY3VzdG9tRGF0YU9mZnNldCwgdGhpcy5jdXN0b21EYXRhT2Zmc2V0ICsgdGhpcy5jdXN0b21EYXRhU2l6ZSk7XG4gIH1cbiAgcHJpdmF0ZSBjdXN0b21EYXRhT2Zmc2V0ID0gMDtcbiAgcHJpdmF0ZSBjdXN0b21EYXRhU2l6ZSA9IDA7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgbW9kdWxlOiBPcnRXYXNtTW9kdWxlLCBwcml2YXRlIGJhY2tlbmQ6IFdlYkdwdUJhY2tlbmQsIGNvbnRleHREYXRhT2Zmc2V0OiBudW1iZXIpIHtcbiAgICB0aGlzLmFkYXB0ZXJJbmZvID0gYmFja2VuZC5hZGFwdGVySW5mbztcbiAgICBjb25zdCBoZWFwVTMyID0gbW9kdWxlLkhFQVBVMzI7XG5cbiAgICAvLyBleHRyYWN0IGNvbnRleHQgZGF0YVxuICAgIGxldCBkYXRhSW5kZXggPSAoY29udGV4dERhdGFPZmZzZXQgPj4+IDIpO1xuICAgIHRoaXMub3BLZXJuZWxDb250ZXh0ID0gaGVhcFUzMltkYXRhSW5kZXgrK107XG4gICAgY29uc3QgaW5wdXRDb3VudCA9IGhlYXBVMzJbZGF0YUluZGV4KytdO1xuICAgIHRoaXMub3V0cHV0Q291bnQgPSBoZWFwVTMyW2RhdGFJbmRleCsrXTtcbiAgICB0aGlzLmN1c3RvbURhdGFPZmZzZXQgPSBoZWFwVTMyW2RhdGFJbmRleCsrXTtcbiAgICB0aGlzLmN1c3RvbURhdGFTaXplID0gaGVhcFUzMltkYXRhSW5kZXgrK107XG5cbiAgICBjb25zdCBpbnB1dHM6IFRlbnNvclZpZXdbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRhVHlwZSA9IGhlYXBVMzJbZGF0YUluZGV4KytdO1xuICAgICAgY29uc3QgZGF0YSA9IGhlYXBVMzJbZGF0YUluZGV4KytdO1xuICAgICAgY29uc3QgZGltID0gaGVhcFUzMltkYXRhSW5kZXgrK107XG4gICAgICBjb25zdCBkaW1zOiBudW1iZXJbXSA9IFtdO1xuICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBkaW07IGQrKykge1xuICAgICAgICBkaW1zLnB1c2goaGVhcFUzMltkYXRhSW5kZXgrK10pO1xuICAgICAgfVxuICAgICAgaW5wdXRzLnB1c2gobmV3IFRlbnNvclZpZXdJbXBsKG1vZHVsZSwgZGF0YVR5cGUsIGRhdGEsIGRpbXMpKTtcbiAgICB9XG4gICAgdGhpcy5pbnB1dHMgPSBpbnB1dHM7XG4gIH1cblxuICBnZXRNYXhDb21wdXRlV29ya2dyb3VwU2l6ZXMoKTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdIHtcbiAgICByZXR1cm4gW1xuICAgICAgdGhpcy5iYWNrZW5kLmRldmljZS5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYLCB0aGlzLmJhY2tlbmQuZGV2aWNlLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVksXG4gICAgICB0aGlzLmJhY2tlbmQuZGV2aWNlLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVpcbiAgICBdO1xuICB9XG5cbiAgZ2V0TWF4Q29tcHV0ZVdvcmtncm91cFN0b3JhZ2VzaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuYmFja2VuZC5kZXZpY2UubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZTtcbiAgfVxuXG4gIGNvbXB1dGUocHJvZ3JhbTogUHJvZ3JhbUluZm8sIGlucHV0c091dHB1dHNNYXBwaW5nPzogQ29tcHV0ZUNvbnRleHRJbnB1dHNPdXRwdXRzTWFwcGluZyk6IFRlbnNvclZpZXdbXSB7XG4gICAgLy8gcHJlcGFyZSBpbnB1dHMuIGlucHV0cyBzaG91bGQgYWx3YXlzIGJlIHZhbGlkIGRhdGEuXG4gICAgY29uc3QgbWFwcGVkSW5wdXRzID1cbiAgICAgICAgaW5wdXRzT3V0cHV0c01hcHBpbmc/LmlucHV0cz8ubWFwKGkgPT4gdHlwZW9mIGkgPT09ICdudW1iZXInID8gdGhpcy5pbnB1dHNbaV0gOiBpKSA/PyB0aGlzLmlucHV0cztcbiAgICAvLyBwcmVwYXJlIG91dHB1dHMuXG4gICAgY29uc3Qgb3V0cHV0SW5kaWNlcyA9IGlucHV0c091dHB1dHNNYXBwaW5nPy5vdXRwdXRzID8/IFtdO1xuICAgIGNvbnN0IGNyZWF0ZUtlcm5lbE91dHB1dCA9IChpbmRleDogbnVtYmVyLCBkYXRhVHlwZTogbnVtYmVyLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvclZpZXcgPT5cbiAgICAgICAgbmV3IFRlbnNvclZpZXdJbXBsKHRoaXMubW9kdWxlLCBkYXRhVHlwZSwgdGhpcy5vdXRwdXQoaW5kZXgsIGRpbXMpLCBkaW1zKTtcbiAgICBjb25zdCBjcmVhdGVUZW1wb3JhcnlPdXRwdXQgPSAoZGF0YVR5cGU6IG51bWJlciwgZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBUZW5zb3JWaWV3ID0+IHtcbiAgICAgIGNvbnN0IGVsZW1lbnRTaXplID0gZ2V0VGVuc29yRWxlbWVudFNpemUoZGF0YVR5cGUpO1xuICAgICAgaWYgKCFlbGVtZW50U2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtkYXRhVHlwZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJ1ZmZlclNpemUgPSBlbGVtZW50U2l6ZSAqIFNoYXBlVXRpbC5zaXplKGRpbXMpO1xuICAgICAgY29uc3QgZ3B1RGF0YUlkID0gYnVmZmVyU2l6ZSA+IDAgPyB0aGlzLmJhY2tlbmQuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKGJ1ZmZlclNpemUpLmlkIDogMDtcbiAgICAgIHJldHVybiBuZXcgVGVuc29yVmlld0ltcGwodGhpcy5tb2R1bGUsIGRhdGFUeXBlLCBncHVEYXRhSWQsIGRpbXMpO1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuYmFja2VuZC5ydW4oXG4gICAgICAgIHByb2dyYW0sIG1hcHBlZElucHV0cywgb3V0cHV0SW5kaWNlcywgY3JlYXRlS2VybmVsT3V0cHV0LCBjcmVhdGVUZW1wb3JhcnlPdXRwdXQsIHRoaXMub3V0cHV0Q291bnQpO1xuICB9XG5cbiAgb3V0cHV0KGluZGV4OiBudW1iZXIsIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogbnVtYmVyIHtcbiAgICBjb25zdCBzdGFjayA9IHRoaXMubW9kdWxlLnN0YWNrU2F2ZSgpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5tb2R1bGUuc3RhY2tBbGxvYygoMSArIGRpbXMubGVuZ3RoKSAqIDQgLyogc2l6ZW9mKHNpemVfdCkgKi8pO1xuICAgICAgbGV0IG9mZnNldCA9IGRhdGEgPj4gMjtcbiAgICAgIHRoaXMubW9kdWxlLkhFQVBVMzJbb2Zmc2V0KytdID0gZGltcy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5tb2R1bGUuSEVBUFUzMltvZmZzZXQrK10gPSBkaW1zW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubW9kdWxlLl9Kc2VwT3V0cHV0ISh0aGlzLm9wS2VybmVsQ29udGV4dCwgaW5kZXgsIGRhdGEpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRmFpbGVkIHRvIGdlbmVyYXRlIGtlcm5lbCdzIG91dHB1dFske2luZGV4fV0gd2l0aCBkaW1zIFske2RpbXN9XS4gYCArXG4gICAgICAgICAgJ0lmIHlvdSBhcmUgcnVubmluZyB3aXRoIHByZS1hbGxvY2F0ZWQgb3V0cHV0LCBwbGVhc2UgbWFrZSBzdXJlIHRoZSBvdXRwdXQgdHlwZS9kaW1zIGFyZSBjb3JyZWN0LiAnICtcbiAgICAgICAgICBgRXJyb3I6ICR7ZX1gKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5tb2R1bGUuc3RhY2tSZXN0b3JlKHN0YWNrKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIEpTRVAgd2l0aCBXZWJHUFUgYmFja2VuZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSBXZWJBc3NlbWJseSBtb2R1bGUgaXMgbG9hZGVkIGFuZCBpbml0aWFsaXplZCAoXCJfT3J0SW5pdFwiIGlzIGNhbGxlZCksIG9uY2UgZm9yXG4gKiBlYWNoIG9mIHRoZSBmb2xsb3dpbmcgRVBzIGlmIHRoZXkgYXJlIHNwZWNpZmllZDpcbiAqIC0gXCJ3ZWJncHVcIlxuICogLSBcIndlYm5uXCJcbiAqXG4gKiBGb3IgV2ViR1BVLCB0aGlzIGZ1bmN0aW9uIGV4cGVjdHM6XG4gKiAgLSBXZWJHUFUgaXMgZW5hYmxlZCBpbiBidWlsZCAoQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgPT09IGZhbHNlKS5cbiAqICAtIFdlYkdQVSBpcyBhdmFpbGFibGUgaW4gY3VycmVudCBlbnZpcm9ubWVudC4gKGEgdmFsaWQgR1BVQWRhcHRlciBpcyBwYXNzZWQgaW4pXG4gKlxuICogRm9yIFdlYk5OLCB0aGlzIGZ1bmN0aW9uIGV4cGVjdHM6XG4gKiAtIFdlYk5OIGlzIGVuYWJsZWQgaW4gYnVpbGQgKEJVSUxEX0RFRlMuRElTQUJMRV9KU0VQID09PSBmYWxzZSkuXG4gKiAtIFdlYk5OIGlzIGF2YWlsYWJsZSBpbiBjdXJyZW50IGVudmlyb25tZW50LiAobmF2aWdhdG9yLm1sIGlzIG5vdCB1bmRlZmluZWQpXG4gKlxuICogSWYgdGhlIFdlYkFzc2VtYmx5IG1vZHVsZSBpcyBub3QgYnVpbHQgd2l0aCBKU0VQIHN1cHBvcnQsIHRoaXMgZnVuY3Rpb24gd2lsbCB0aHJvdyBhbiBlcnJvci4gVGhpcyB3aWxsIGludmFsaWRhdGVcbiAqICd3ZWJncHUnLyd3ZWJubicgYmFja2VuZC5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBFUCwgZWl0aGVyIFwid2ViZ3B1XCIgb3IgXCJ3ZWJublwiXG4gKiBAcGFyYW0gbW9kdWxlIC0gdGhlIE9SVCBXZWJBc3NlbWJseSBtb2R1bGVcbiAqIEBwYXJhbSBlbnYgLSB0aGUgT1JUIGVudmlyb25tZW50IHZhcmlhYmxlIChvcnQuZW52KVxuICogQHBhcmFtIGdwdUFkYXB0ZXIgLSB0aGUgcHJlLWNyZWF0ZWQgR1BVIGFkYXB0ZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGluaXQgPVxuICAgIGFzeW5jKG5hbWU6ICd3ZWJncHUnfCd3ZWJubicsIG1vZHVsZTogT3J0V2FzbU1vZHVsZSwgZW52OiBFbnYsIGdwdUFkYXB0ZXI/OiBHUFVBZGFwdGVyKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGNvbnN0IGpzZXBJbml0ID0gbW9kdWxlLmpzZXBJbml0O1xuICBpZiAoIWpzZXBJbml0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBKU0VQLiBUaGUgV2ViQXNzZW1ibHkgbW9kdWxlIGlzIG5vdCBidWlsdCB3aXRoIEpTRVAgc3VwcG9ydC4nKTtcbiAgfVxuXG4gIGlmIChuYW1lID09PSAnd2ViZ3B1Jykge1xuICAgIGNvbnN0IGJhY2tlbmQgPSBuZXcgV2ViR3B1QmFja2VuZCgpO1xuICAgIGF3YWl0IGJhY2tlbmQuaW5pdGlhbGl6ZShlbnYsIGdwdUFkYXB0ZXIhKTtcblxuICAgIGpzZXBJbml0KCd3ZWJncHUnLCBbXG4gICAgICAvLyBiYWNrZW5kXG4gICAgICBiYWNrZW5kLFxuXG4gICAgICAvLyBqc2VwQWxsb2MoKVxuICAgICAgKHNpemU6IG51bWJlcikgPT4gYmFja2VuZC5hbGxvYyhzaXplKSxcblxuICAgICAgLy8ganNlcEZyZWUoKVxuICAgICAgKHB0cjogbnVtYmVyKSA9PiBiYWNrZW5kLmZyZWUocHRyKSxcblxuICAgICAgLy8ganNlcENvcHkoc3JjLCBkc3QsIHNpemUsIGlzU291cmNlR3B1KVxuICAgICAgKHNyYzogbnVtYmVyLCBkc3Q6IG51bWJlciwgc2l6ZTogbnVtYmVyLCBpc1NvdXJjZUdwdSA9IGZhbHNlKSA9PiB7XG4gICAgICAgIGlmIChpc1NvdXJjZUdwdSkge1xuICAgICAgICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbV2ViR1BVXSBqc2VwQ29weUdwdVRvR3B1OiBzcmM9JHtzcmN9LCBkc3Q9JHtkc3R9LCBzaXplPSR7c2l6ZX1gKTtcbiAgICAgICAgICBiYWNrZW5kLm1lbWNweShzcmMsIGRzdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJHUFVdIGpzZXBDb3B5Q3B1VG9HcHU6IGRhdGFPZmZzZXQ9JHtzcmN9LCBncHVEYXRhSWQ9JHtkc3R9LCBzaXplPSR7c2l6ZX1gKTtcbiAgICAgICAgICBjb25zdCBkYXRhID0gbW9kdWxlLkhFQVBVOC5zdWJhcnJheShzcmMgPj4+IDAsIChzcmMgPj4+IDApICsgc2l6ZSk7XG4gICAgICAgICAgYmFja2VuZC51cGxvYWQoZHN0LCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLy8ganNlcENvcHlBc3luYyhzcmMsIGRzdCwgc2l6ZSlcbiAgICAgIGFzeW5jKGdwdURhdGFJZDogbnVtYmVyLCBkYXRhT2Zmc2V0OiBudW1iZXIsIHNpemU6IG51bWJlcik6XG4gICAgICAgICAgUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgICAgICAgICBMT0dfREVCVUcoXG4gICAgICAgICAgICAgICAgJ3ZlcmJvc2UnLFxuICAgICAgICAgICAgICAgICgpID0+IGBbV2ViR1BVXSBqc2VwQ29weUdwdVRvQ3B1OiBncHVEYXRhSWQ9JHtncHVEYXRhSWR9LCBkYXRhT2Zmc2V0PSR7ZGF0YU9mZnNldH0sIHNpemU9JHtzaXplfWApO1xuXG4gICAgICAgICAgICBhd2FpdCBiYWNrZW5kLmRvd25sb2FkKFxuICAgICAgICAgICAgICAgIGdwdURhdGFJZCwgKCkgPT4gbW9kdWxlLkhFQVBVOC5zdWJhcnJheShkYXRhT2Zmc2V0ID4+PiAwLCAoZGF0YU9mZnNldCA+Pj4gMCkgKyBzaXplKSk7XG4gICAgICAgICAgfSxcblxuICAgICAgLy8ganNlcENyZWF0ZUtlcm5lbFxuICAgICAgKGtlcm5lbFR5cGU6IHN0cmluZywga2VybmVsSWQ6IG51bWJlciwgYXR0cmlidXRlOiB1bmtub3duKSA9PiBiYWNrZW5kLmNyZWF0ZUtlcm5lbChcbiAgICAgICAgICBrZXJuZWxUeXBlLCBrZXJuZWxJZCwgYXR0cmlidXRlLCBtb2R1bGUuVVRGOFRvU3RyaW5nKG1vZHVsZS5fSnNlcEdldE5vZGVOYW1lIShrZXJuZWxJZCkpKSxcblxuICAgICAgLy8ganNlcFJlbGVhc2VLZXJuZWxcbiAgICAgIChrZXJuZWw6IG51bWJlcikgPT4gYmFja2VuZC5yZWxlYXNlS2VybmVsKGtlcm5lbCksXG5cbiAgICAgIC8vIGpzZXBSdW5cbiAgICAgIChrZXJuZWw6IG51bWJlciwgY29udGV4dERhdGFPZmZzZXQ6IG51bWJlciwgc2Vzc2lvbkhhbmRsZTogbnVtYmVyLCBlcnJvcnM6IEFycmF5PFByb21pc2U8c3RyaW5nfG51bGw+PikgPT4ge1xuICAgICAgICBMT0dfREVCVUcoXG4gICAgICAgICAgICAndmVyYm9zZScsXG4gICAgICAgICAgICAoKSA9PiBgW1dlYkdQVV0ganNlcFJ1bjogc2Vzc2lvbkhhbmRsZT0ke3Nlc3Npb25IYW5kbGV9LCBrZXJuZWw9JHtrZXJuZWx9LCBjb250ZXh0RGF0YU9mZnNldD0ke1xuICAgICAgICAgICAgICAgIGNvbnRleHREYXRhT2Zmc2V0fWApO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gbmV3IENvbXB1dGVDb250ZXh0SW1wbChtb2R1bGUsIGJhY2tlbmQsIGNvbnRleHREYXRhT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQuY29tcHV0ZUtlcm5lbChrZXJuZWwsIGNvbnRleHQsIGVycm9ycyk7XG4gICAgICB9LFxuICAgICAgLy8ganNlcENhcHR1cmVCZWdpblxuICAgICAgKCkgPT4gYmFja2VuZC5jYXB0dXJlQmVnaW4oKSxcbiAgICAgIC8vIGpzZXBDYXB0dXJlRW5kXG4gICAgICAoKSA9PiBiYWNrZW5kLmNhcHR1cmVFbmQoKSxcbiAgICAgIC8vIGpzZXBSZXBsYXlcbiAgICAgICgpID0+IGJhY2tlbmQucmVwbGF5KClcbiAgICBdKTtcbiAgfSBlbHNlIHtcbiAgICBqc2VwSW5pdCgnd2Vibm4nKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtFbnYsIEluZmVyZW5jZVNlc3Npb24sIFRlbnNvcn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHtTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlciwgU2VyaWFsaXphYmxlU2Vzc2lvbk1ldGFkYXRhLCBTZXJpYWxpemFibGVUZW5zb3JNZXRhZGF0YSwgVGVuc29yTWV0YWRhdGF9IGZyb20gJy4vcHJveHktbWVzc2FnZXMnO1xuaW1wb3J0IHtzZXRSdW5PcHRpb25zfSBmcm9tICcuL3J1bi1vcHRpb25zJztcbmltcG9ydCB7c2V0U2Vzc2lvbk9wdGlvbnN9IGZyb20gJy4vc2Vzc2lvbi1vcHRpb25zJztcbmltcG9ydCB7ZGF0YUxvY2F0aW9uU3RyaW5nVG9FbnVtLCBnZXRUZW5zb3JFbGVtZW50U2l6ZSwgaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlLCBsb2dMZXZlbFN0cmluZ1RvRW51bSwgdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcsIHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtLCB0ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3J9IGZyb20gJy4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHtnZXRJbnN0YW5jZX0gZnJvbSAnLi93YXNtLWZhY3RvcnknO1xuaW1wb3J0IHthbGxvY1dhc21TdHJpbmcsIGNoZWNrTGFzdEVycm9yfSBmcm9tICcuL3dhc20tdXRpbHMnO1xuaW1wb3J0IHtsb2FkRmlsZX0gZnJvbSAnLi93YXNtLXV0aWxzLWxvYWQtZmlsZSc7XG5cbi8vICNyZWdpb24gSW5pdGlhbGl6YXRpb25zXG5cbi8qKlxuICogVGhlcmUgYXJlIDQgZGlmZmVyZW50IFwiaW5pdGlhbGl6YXRpb25cIiBzdGVwcyBmb3IgT1JULiBUaGV5IGhhcHBlbiBpbiBkaWZmZXJlbnQgcGxhY2VzIGFuZCBkaWZmZXJlbnQgdGltZS5cbiAqXG4gKiAxLiBKYXZhU2NyaXB0IGluaXRpYWxpemF0aW9uIGZvciBvbm54cnVudGltZS1jb21tb24gYW5kIG9ubnhydW50aW1lLXdlYi5cbiAqICAgIFRoaXMgaXMgdGhlIGZpcnN0IGluaXRpYWxpemF0aW9uIHN0ZXAuIEluIHRoaXMgc3RlcCwgb25ueHJ1bnRpbWUtd2ViIGNhbGxzIG9ubnhydW50aW1lLWNvbW1vbidzIHJlZ2lzdGVyQmFja2VuZCgpXG4gKiBmdW5jdGlvbiBtdWx0aXBsZSB0aW1lcyB0byByZWdpc3RlciBhbGwgdGhlIGF2YWlsYWJsZSBiYWNrZW5kcy4gVGhlIGJhY2tlbmQgcmVnaXN0cmF0aW9uIGlzIHZlcnkgZmFzdC4gSXQgb25seVxuICogcmVnaXN0ZXJzIHRoZSBiYWNrZW5kIG5hbWUgd2l0aCB0aGUgdW5pbml0aWFsaXplZCBiYWNrZW5kIG9iamVjdC4gTm8gaGVhdnkgaW5pdGlhbGl6YXRpb24gaXMgZG9uZSBpbiB0aGlzIHN0ZXAuXG4gKiAgICBSZWZlciB0byB3ZWIvbGliL2luZGV4LnRzIGZvciB0aGUgYmFja2VuZCByZWdpc3RyYXRpb24uXG4gKlxuICogMi4gV2ViQXNzZW1ibHkgYXJ0aWZhY3QgaW5pdGlhbGl6YXRpb24uXG4gKiAgICBUaGlzIGhhcHBlbnMgd2hlbiBhbnkgcmVnaXN0ZXJlZCB3YXNtIGJhY2tlbmQgaXMgdXNlZCBmb3IgdGhlIGZpcnN0IHRpbWUgKGllLiBgb3J0LkluZmVyZW5jZVNlc3Npb24uY3JlYXRlKClgIG9yXG4gKiBgb3J0LlRyYWluaW5nU2Vzc2lvbi5jcmVhdGUoKWAgaXMgY2FsbGVkKS4gSW4gdGhpcyBzdGVwLCBvbm54cnVudGltZS13ZWIgZG9lcyB0aGUgZm9sbG93aW5nczpcbiAqICAgICAtIGNyZWF0ZSBhIHByb3h5IHdvcmtlciBhbmQgbWFrZSBzdXJlIHRoZSBwcm94eSB3b3JrZXIgaXMgcmVhZHkgdG8gcmVjZWl2ZSBtZXNzYWdlcywgaWYgcHJveHkgaXMgZW5hYmxlZC5cbiAqICAgICAtIHBlcmZvcm0gZmVhdHVyZSBkZXRlY3Rpb24sIGxvY2F0ZSBjb3JyZWN0IFdlYkFzc2VtYmx5IGFydGlmYWN0IHBhdGggYW5kIGNhbGwgdGhlIEVtc2NyaXB0ZW4gZ2VuZXJhdGVkXG4gKiBKYXZhU2NyaXB0IGNvZGUgdG8gaW5pdGlhbGl6ZSB0aGUgV2ViQXNzZW1ibHkgcnVudGltZS5cbiAqICAgICAgICAgLSBpZiBwcm94eSBpcyBlbmFibGVkLCB0aGlzIHN0ZXAgaGFwcGVucyBpbiB0aGUgcHJveHkgd29ya2VyIHVzaW5nIG1lc3NhZ2UgJ2luaXQtd2FzbScuXG4gKiAgICAgICAgIC0gZG93bmxvYWRpbmcgdGhlICdvcnQtd2FzbXsuLi59Lndhc20nIGZpbGUgaXMgZG9uZSBpbiB0aGlzIHN0ZXAuXG4gKiAgICAgICAgIC0gaWYgbXVsdGktdGhyZWFkIGlzIGVuYWJsZWQsIG9uZSBvciBtb3JlIHdlYndvcmtlciB3aWxsIGJlIGNyZWF0ZWQgdG8gaW5pdGlhbGl6ZSB0aGUgUFRocmVhZCB0aHJlYWRwb29sLlxuICpcbiAqIDMuIE9SVCBlbnZpcm9ubWVudCBpbml0aWFsaXphdGlvbi5cbiAqICAgIFRoaXMgaGFwcGVucyBhZnRlciBzdGVwIDIuIEluIHRoaXMgc3RlcCwgb25ueHJ1bnRpbWUtd2ViIHBlcmZvcm1zIE9OTlggUnVudGltZSBlbnZpcm9ubWVudCBpbml0aWFsaXphdGlvbi5cbiAqIEZ1bmN0aW9uIGBfT3J0SW5pdCgpYCBpcyBjYWxsZWQgaW4gdGhpcyBzdGVwLlxuICogICAgIC0gaWYgcHJveHkgaXMgZW5hYmxlZCwgdGhpcyBzdGVwIGhhcHBlbnMgaW4gdGhlIHByb3h5IHdvcmtlciB1c2luZyBtZXNzYWdlICdpbml0LW9ydCcuXG4gKiAgICAgLSBsb2dnaW5nIGxldmVsIChvcnQuZW52LmxvZ0xldmVsKSBhbmQgdGhyZWFkIG51bWJlciAob3J0LmVudi53YXNtLm51bVRocmVhZHMpIGFyZSBzZXQgaW4gdGhpcyBzdGVwLlxuICpcbiAqIDQuIFNlc3Npb24gaW5pdGlhbGl6YXRpb24uXG4gKiAgICBUaGlzIGhhcHBlbnMgd2hlbiBgb3J0LkluZmVyZW5jZVNlc3Npb24uY3JlYXRlKClgIG9yIGBvcnQuVHJhaW5pbmdTZXNzaW9uLmNyZWF0ZSgpYCBpcyBjYWxsZWQuIFVubGlrZSB0aGUgZmlyc3QgM1xuICogc3RlcHMgKHRoZXkgb25seSBjYWxsZWQgb25jZSksIHRoaXMgc3RlcCB3aWxsIGJlIGRvbmUgZm9yIGVhY2ggc2Vzc2lvbi4gSW4gdGhpcyBzdGVwLCBvbm54cnVudGltZS13ZWIgZG9lcyB0aGVcbiAqIGZvbGxvd2luZ3M6XG4gKiAgICBJZiB0aGUgcGFyYW1ldGVyIGlzIGEgVVJMOlxuICogICAgLSBkb3dubG9hZCB0aGUgbW9kZWwgZGF0YSBmcm9tIHRoZSBVUkwuXG4gKiAgICAtIGNvcHkgdGhlIG1vZGVsIGRhdGEgdG8gdGhlIFdBU00gaGVhcC4gKHByb3h5OiAnY29weS1mcm9tJylcbiAqICAgIC0gZGVyZWZlcmVuY2UgdGhlIG1vZGVsIGJ1ZmZlci4gVGhpcyBzdGVwIGFsbG93cyB0aGUgb3JpZ2luYWwgQXJyYXlCdWZmZXIgdG8gYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gKiAgICAtIGNhbGwgYF9PcnRDcmVhdGVTZXNzaW9uKClgIHRvIGNyZWF0ZSB0aGUgc2Vzc2lvbi4gKHByb3h5OiAnY3JlYXRlJylcbiAqXG4gKiAgICBJZiB0aGUgcGFyYW1ldGVyIGlzIGEgVWludDhBcnJheSBvYmplY3Q6XG4gKiAgICAtIGNvcHkgdGhlIG1vZGVsIGRhdGEgdG8gdGhlIFdBU00gaGVhcC4gKHByb3h5OiAnY29weS1mcm9tJylcbiAqICAgIC0gY2FsbCBgX09ydENyZWF0ZVNlc3Npb24oKWAgdG8gY3JlYXRlIHRoZSBzZXNzaW9uLiAocHJveHk6ICdjcmVhdGUnKVxuICpcbiAqXG4gKi9cblxuLyoqXG4gKiBpbml0aWFsaXplIE9SVCBlbnZpcm9ubWVudC5cbiAqXG4gKiBAcGFyYW0gbnVtVGhyZWFkcyBTZXRHbG9iYWxJbnRyYU9wTnVtVGhyZWFkcyhudW1UaHJlYWRzKVxuICogQHBhcmFtIGxvZ2dpbmdMZXZlbCBDcmVhdGVFbnYoc3RhdGljX2Nhc3Q8T3J0TG9nZ2luZ0xldmVsPihsb2dnaW5nX2xldmVsKSlcbiAqL1xuY29uc3QgaW5pdE9ydCA9IChudW1UaHJlYWRzOiBudW1iZXIsIGxvZ2dpbmdMZXZlbDogbnVtYmVyKTogdm9pZCA9PiB7XG4gIGNvbnN0IGVycm9yQ29kZSA9IGdldEluc3RhbmNlKCkuX09ydEluaXQobnVtVGhyZWFkcywgbG9nZ2luZ0xldmVsKTtcbiAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgIGNoZWNrTGFzdEVycm9yKCdDYW5cXCd0IGluaXRpYWxpemUgb25ueHJ1bnRpbWUuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogaW50aWFsaXplIHJ1bnRpbWUgZW52aXJvbm1lbnQuXG4gKiBAcGFyYW0gZW52IHBhc3NlZCBpbiB0aGUgZW52aXJvbm1lbnQgY29uZmlnIG9iamVjdC5cbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRSdW50aW1lID0gYXN5bmMoZW52OiBFbnYpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgLy8gaW5pdCBPUlRcbiAgaW5pdE9ydChlbnYud2FzbS5udW1UaHJlYWRzISwgbG9nTGV2ZWxTdHJpbmdUb0VudW0oZW52LmxvZ0xldmVsKSk7XG59O1xuXG4vKipcbiAqIHBlcmZvcm0gRVAgc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24uXG4gKlxuICogQHBhcmFtIGVudlxuICogQHBhcmFtIGVwTmFtZVxuICovXG5leHBvcnQgY29uc3QgaW5pdEVwID0gYXN5bmMoZW52OiBFbnYsIGVwTmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX0pTRVApIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuICAgIGNvbnN0IGluaXRKc2VwID0gcmVxdWlyZSgnLi9qc2VwL2luaXQnKS5pbml0O1xuXG4gICAgaWYgKGVwTmFtZSA9PT0gJ3dlYmdwdScpIHtcbiAgICAgIC8vIHBlcmZvcm0gV2ViR1BVIGF2YWlsYWJpbGl0eSBjaGVja1xuICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnIHx8ICFuYXZpZ2F0b3IuZ3B1KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViR1BVIGlzIG5vdCBzdXBwb3J0ZWQgaW4gY3VycmVudCBlbnZpcm9ubWVudCcpO1xuICAgICAgfVxuXG4gICAgICBsZXQgYWRhcHRlciA9IGVudi53ZWJncHUuYWRhcHRlciBhcyBHUFVBZGFwdGVyIHwgbnVsbDtcbiAgICAgIGlmICghYWRhcHRlcikge1xuICAgICAgICAvLyBpZiBhZGFwdGVyIGlzIG5vdCBzZXQsIHJlcXVlc3QgYSBuZXcgYWRhcHRlci5cbiAgICAgICAgY29uc3QgcG93ZXJQcmVmZXJlbmNlID0gZW52LndlYmdwdS5wb3dlclByZWZlcmVuY2U7XG4gICAgICAgIGlmIChwb3dlclByZWZlcmVuY2UgIT09IHVuZGVmaW5lZCAmJiBwb3dlclByZWZlcmVuY2UgIT09ICdsb3ctcG93ZXInICYmXG4gICAgICAgICAgICBwb3dlclByZWZlcmVuY2UgIT09ICdoaWdoLXBlcmZvcm1hbmNlJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwb3dlclByZWZlcmVuY2Ugc2V0dGluZzogXCIke3Bvd2VyUHJlZmVyZW5jZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcmNlRmFsbGJhY2tBZGFwdGVyID0gZW52LndlYmdwdS5mb3JjZUZhbGxiYWNrQWRhcHRlcjtcbiAgICAgICAgaWYgKGZvcmNlRmFsbGJhY2tBZGFwdGVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGZvcmNlRmFsbGJhY2tBZGFwdGVyICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZm9yY2VGYWxsYmFja0FkYXB0ZXIgc2V0dGluZzogXCIke2ZvcmNlRmFsbGJhY2tBZGFwdGVyfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRhcHRlciA9IGF3YWl0IG5hdmlnYXRvci5ncHUucmVxdWVzdEFkYXB0ZXIoe3Bvd2VyUHJlZmVyZW5jZSwgZm9yY2VGYWxsYmFja0FkYXB0ZXJ9KTtcbiAgICAgICAgaWYgKCFhZGFwdGVyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAnRmFpbGVkIHRvIGdldCBHUFUgYWRhcHRlci4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IG5lZWQgdG8gZW5hYmxlIGZsYWcgXCItLWVuYWJsZS11bnNhZmUtd2ViZ3B1XCIgaWYgeW91IGFyZSB1c2luZyBDaHJvbWUuJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIGFkYXB0ZXIgaXMgc2V0LCB2YWxpZGF0ZSBpdC5cbiAgICAgICAgaWYgKHR5cGVvZiBhZGFwdGVyLmxpbWl0cyAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIGFkYXB0ZXIuZmVhdHVyZXMgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICB0eXBlb2YgYWRhcHRlci5yZXF1ZXN0RGV2aWNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEdQVSBhZGFwdGVyIHNldCBpbiBgZW52LndlYmdwdS5hZGFwdGVyYC4gSXQgbXVzdCBiZSBhIEdQVUFkYXB0ZXIgb2JqZWN0LicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IGluaXRKc2VwKCd3ZWJncHUnLCBnZXRJbnN0YW5jZSgpLCBlbnYsIGFkYXB0ZXIpO1xuICAgIH1cbiAgICBpZiAoZXBOYW1lID09PSAnd2Vibm4nKSB7XG4gICAgICAvLyBwZXJmb3JtIFdlYk5OIGF2YWlsYWJpbGl0eSBjaGVja1xuICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnIHx8ICEobmF2aWdhdG9yIGFzIHVua25vd24gYXMge21sOiB1bmtub3dufSkubWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJOTiBpcyBub3Qgc3VwcG9ydGVkIGluIGN1cnJlbnQgZW52aXJvbm1lbnQnKTtcbiAgICAgIH1cblxuICAgICAgYXdhaXQgaW5pdEpzZXAoJ3dlYm5uJywgZ2V0SW5zdGFuY2UoKSwgZW52KTtcbiAgICB9XG4gIH1cbn07XG5cbi8vICNlbmRyZWdpb24gSW5pdGlhbGl6YXRpb25zXG5cbi8qKlxuICogdmFsaWQgZGF0YSBsb2NhdGlvbnMgZm9yIGlucHV0L291dHB1dCB0ZW5zb3JzLlxuICovXG50eXBlIFN1cHBvcnRlZFRlbnNvckRhdGFMb2NhdGlvbkZvcklucHV0T3V0cHV0ID0gJ2NwdSd8J2NwdS1waW5uZWQnfCdncHUtYnVmZmVyJztcblxudHlwZSBJT0JpbmRpbmdTdGF0ZSA9IHtcbiAgLyoqXG4gICAqIHRoZSBoYW5kbGUgb2YgSU8gYmluZGluZy5cbiAgICovXG4gIHJlYWRvbmx5IGhhbmRsZTogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiB0aGUgcHJlZmVycmVkIGxvY2F0aW9uIGZvciBlYWNoIG91dHB1dCB0ZW5zb3IuXG4gICAqXG4gICAqIHZhbHVlIGlzIG9uZSBvZiAnY3B1JywgJ2NwdS1waW5uZWQnLCAnZ3B1LWJ1ZmZlcicuXG4gICAqL1xuICByZWFkb25seSBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnM6IHJlYWRvbmx5IFN1cHBvcnRlZFRlbnNvckRhdGFMb2NhdGlvbkZvcklucHV0T3V0cHV0W107XG5cbiAgLyoqXG4gICAqIGVudW0gdmFsdWUgb2YgdGhlIHByZWZlcnJlZCBsb2NhdGlvbiBmb3IgZWFjaCBvdXRwdXQgdGVuc29yLlxuICAgKi9cbiAgcmVhZG9ubHkgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zRW5jb2RlZDogcmVhZG9ubHkgbnVtYmVyW107XG59O1xuXG4vKipcbiAqICB0dXBsZSBlbGVtZW50cyBhcmU6IEluZmVyZW5jZVNlc3Npb24gSUQ7IGlucHV0TmFtZXNVVEY4RW5jb2RlZDsgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZDsgYmluZGluZ1N0YXRlXG4gKi9cbnR5cGUgU2Vzc2lvbk1ldGFkYXRhID0gW1xuICBpbmZlcmVuY2VTZXNzaW9uSWQ6IG51bWJlciwgaW5wdXROYW1lc1VURjhFbmNvZGVkOiBudW1iZXJbXSwgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZDogbnVtYmVyW10sXG4gIGJpbmRpbmdTdGF0ZTogSU9CaW5kaW5nU3RhdGV8bnVsbCwgZW5hYmxlR3JhcGhDYXB0dXJlOiBib29sZWFuLCBpbnB1dE91dHB1dEJvdW5kOiBib29sZWFuXG5dO1xuXG5jb25zdCBhY3RpdmVTZXNzaW9ucyA9IG5ldyBNYXA8bnVtYmVyLCBTZXNzaW9uTWV0YWRhdGE+KCk7XG5cbi8qKlxuICogZ2V0IHRoZSBpbnB1dC9vdXRwdXQgY291bnQgb2YgdGhlIHNlc3Npb24uXG4gKiBAcGFyYW0gc2Vzc2lvbkhhbmRsZSB0aGUgaGFuZGxlIHJlcHJlc2VudGluZyB0aGUgc2Vzc2lvbi4gc2hvdWxkIGJlIG5vbi16ZXJvLlxuICogQHJldHVybnMgYSB0dXBsZSBpbmNsdWRpbmcgMiBudW1iZXJzLCByZXByZXNlbnRpbmcgdGhlIGlucHV0IGNvdW50IGFuZCBvdXRwdXQgY291bnQuXG4gKi9cbmNvbnN0IGdldFNlc3Npb25JbnB1dE91dHB1dENvdW50ID0gKHNlc3Npb25IYW5kbGU6IG51bWJlcik6IFtudW1iZXIsIG51bWJlcl0gPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcbiAgY29uc3Qgc3RhY2sgPSB3YXNtLnN0YWNrU2F2ZSgpO1xuICB0cnkge1xuICAgIGNvbnN0IGRhdGFPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoOCk7XG4gICAgY29uc3QgZXJyb3JDb2RlID0gd2FzbS5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudChzZXNzaW9uSGFuZGxlLCBkYXRhT2Zmc2V0LCBkYXRhT2Zmc2V0ICsgNCk7XG4gICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgICAgY2hlY2tMYXN0RXJyb3IoJ0NhblxcJ3QgZ2V0IHNlc3Npb24gaW5wdXQvb3V0cHV0IGNvdW50LicpO1xuICAgIH1cbiAgICByZXR1cm4gW3dhc20uSEVBUDMyW2RhdGFPZmZzZXQgLyA0XSwgd2FzbS5IRUFQMzJbZGF0YU9mZnNldCAvIDQgKyAxXV07XG4gIH0gZmluYWxseSB7XG4gICAgd2FzbS5zdGFja1Jlc3RvcmUoc3RhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIGFsbG9jYXRlIHRoZSBtZW1vcnkgYW5kIG1lbWNweSB0aGUgZXh0ZXJuYWwgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBtb2RlbCAtIHRoZSBleHRlcm5hbCBidWZmZXIgY29udGFpbmluZyB0aGUgbW9kZWwgZGF0YS4gTXVzdCBub3QgYmUgdGhlIHNhbWUgYnVmZmVyIGFzIHRoZSBXQVNNIGhlYXAuXG4gKiBAcmV0dXJucyBhIDItZWxlbWVudHMgdHVwbGUgLSB0aGUgcG9pbnRlciBhbmQgc2l6ZSBvZiB0aGUgYWxsb2NhdGVkIGJ1ZmZlclxuICovXG5leHBvcnQgY29uc3QgY29weUZyb21FeHRlcm5hbEJ1ZmZlciA9IChtb2RlbDogVWludDhBcnJheSk6IFtudW1iZXIsIG51bWJlcl0gPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcbiAgY29uc3QgbW9kZWxEYXRhT2Zmc2V0ID0gd2FzbS5fbWFsbG9jKG1vZGVsLmJ5dGVMZW5ndGgpO1xuICBpZiAobW9kZWxEYXRhT2Zmc2V0ID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBjcmVhdGUgYSBzZXNzaW9uLiBmYWlsZWQgdG8gYWxsb2NhdGUgYSBidWZmZXIgb2Ygc2l6ZSAke21vZGVsLmJ5dGVMZW5ndGh9LmApO1xuICB9XG4gIHdhc20uSEVBUFU4LnNldChtb2RlbCwgbW9kZWxEYXRhT2Zmc2V0KTtcbiAgcmV0dXJuIFttb2RlbERhdGFPZmZzZXQsIG1vZGVsLmJ5dGVMZW5ndGhdO1xufTtcblxuLyoqXG4gKiBjcmVhdGUgYW4gaW5mZXJlbmNlIHNlc3Npb24gZnJvbSBhIG1vZGVsIGRhdGEgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBtb2RlbERhdGEgLSBlaXRoZXIgYSBVaW50OEFycmF5IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIG1vZGVsIGRhdGEsIG9yIGEgMi1lbGVtZW50cyB0dXBsZSBjb250YWluaW5nIHRoZVxuICogICAgIHBvaW50ZXIgYW5kIHNpemUgb2YgdGhlIG1vZGVsIGRhdGEgYnVmZmVyLlxuICogQHBhcmFtIG9wdGlvbnMgYW4gb3B0aW9uYWwgc2Vzc2lvbiBvcHRpb25zIG9iamVjdC5cbiAqIEByZXR1cm5zIGEgMy1lbGVtZW50cyB0dXBsZSBjb250YWluaW5nIFtzZXNzaW9uIGhhbmRsZSwgaW5wdXQgbmFtZXMsIG91dHB1dCBuYW1lc11cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVNlc3Npb24gPSBhc3luYyhcbiAgICBtb2RlbERhdGE6IFVpbnQ4QXJyYXl8U2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXIsXG4gICAgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPFNlcmlhbGl6YWJsZVNlc3Npb25NZXRhZGF0YT4gPT4ge1xuICBsZXQgbW9kZWxEYXRhT2Zmc2V0OiBudW1iZXIsIG1vZGVsRGF0YUxlbmd0aDogbnVtYmVyO1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShtb2RlbERhdGEpKSB7XG4gICAgLy8gaWYgbW9kZWwgZGF0YSBpcyBhbiBhcnJheSwgaXQgbXVzdCBiZSBhIDItZWxlbWVudHMgdHVwbGUgY29udGFpbmluZyB0aGUgcG9pbnRlciBhbmQgc2l6ZSBvZiB0aGUgbW9kZWwgZGF0YVxuICAgIFttb2RlbERhdGFPZmZzZXQsIG1vZGVsRGF0YUxlbmd0aF0gPSBtb2RlbERhdGE7XG4gIH0gZWxzZSBpZiAobW9kZWxEYXRhLmJ1ZmZlciA9PT0gd2FzbS5IRUFQVTguYnVmZmVyKSB7XG4gICAgLy8gaWYgbW9kZWwgZGF0YSB1c2VzIHRoZSBzYW1lIGJ1ZmZlciBhcyB0aGUgV0FTTSBoZWFwLCB3ZSBkb24ndCBuZWVkIHRvIGNvcHkgaXQuXG4gICAgW21vZGVsRGF0YU9mZnNldCwgbW9kZWxEYXRhTGVuZ3RoXSA9IFttb2RlbERhdGEuYnl0ZU9mZnNldCwgbW9kZWxEYXRhLmJ5dGVMZW5ndGhdO1xuICB9IGVsc2Uge1xuICAgIC8vIG90aGVyd2lzZSwgY29weSB0aGUgbW9kZWwgZGF0YSB0byB0aGUgV0FTTSBoZWFwLlxuICAgIFttb2RlbERhdGFPZmZzZXQsIG1vZGVsRGF0YUxlbmd0aF0gPSBjb3B5RnJvbUV4dGVybmFsQnVmZmVyKG1vZGVsRGF0YSk7XG4gIH1cblxuICBsZXQgc2Vzc2lvbkhhbmRsZSA9IDA7XG4gIGxldCBzZXNzaW9uT3B0aW9uc0hhbmRsZSA9IDA7XG4gIGxldCBpb0JpbmRpbmdIYW5kbGUgPSAwO1xuICBsZXQgYWxsb2NzOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBpbnB1dE5hbWVzVVRGOEVuY29kZWQgPSBbXTtcbiAgY29uc3Qgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCA9IFtdO1xuXG4gIHRyeSB7XG4gICAgW3Nlc3Npb25PcHRpb25zSGFuZGxlLCBhbGxvY3NdID0gc2V0U2Vzc2lvbk9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICBpZiAob3B0aW9ucz8uZXh0ZXJuYWxEYXRhICYmIHdhc20ubW91bnRFeHRlcm5hbERhdGEpIHtcbiAgICAgIGNvbnN0IGxvYWRpbmdQcm9taXNlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBmaWxlIG9mIG9wdGlvbnMuZXh0ZXJuYWxEYXRhKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSB0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycgPyBmaWxlIDogZmlsZS5wYXRoO1xuICAgICAgICBsb2FkaW5nUHJvbWlzZXMucHVzaChsb2FkRmlsZSh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycgPyBmaWxlIDogZmlsZS5kYXRhKS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgIHdhc20ubW91bnRFeHRlcm5hbERhdGEhKHBhdGgsIGRhdGEpO1xuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHdhaXQgZm9yIGFsbCBleHRlcm5hbCBkYXRhIGZpbGVzIHRvIGJlIGxvYWRlZFxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwobG9hZGluZ1Byb21pc2VzKTtcbiAgICB9XG5cbiAgICBzZXNzaW9uSGFuZGxlID0gYXdhaXQgd2FzbS5fT3J0Q3JlYXRlU2Vzc2lvbihtb2RlbERhdGFPZmZzZXQsIG1vZGVsRGF0YUxlbmd0aCwgc2Vzc2lvbk9wdGlvbnNIYW5kbGUpO1xuICAgIGlmIChzZXNzaW9uSGFuZGxlID09PSAwKSB7XG4gICAgICBjaGVja0xhc3RFcnJvcignQ2FuXFwndCBjcmVhdGUgYSBzZXNzaW9uLicpO1xuICAgIH1cblxuICAgIGNvbnN0IFtpbnB1dENvdW50LCBvdXRwdXRDb3VudF0gPSBnZXRTZXNzaW9uSW5wdXRPdXRwdXRDb3VudChzZXNzaW9uSGFuZGxlKTtcblxuICAgIGNvbnN0IGVuYWJsZUdyYXBoQ2FwdHVyZSA9ICEhb3B0aW9ucz8uZW5hYmxlR3JhcGhDYXB0dXJlO1xuXG4gICAgY29uc3QgaW5wdXROYW1lcyA9IFtdO1xuICAgIGNvbnN0IG91dHB1dE5hbWVzID0gW107XG4gICAgY29uc3Qgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zOiBTdXBwb3J0ZWRUZW5zb3JEYXRhTG9jYXRpb25Gb3JJbnB1dE91dHB1dFtdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IG5hbWUgPSB3YXNtLl9PcnRHZXRJbnB1dE5hbWUoc2Vzc2lvbkhhbmRsZSwgaSk7XG4gICAgICBpZiAobmFtZSA9PT0gMCkge1xuICAgICAgICBjaGVja0xhc3RFcnJvcignQ2FuXFwndCBnZXQgYW4gaW5wdXQgbmFtZS4nKTtcbiAgICAgIH1cbiAgICAgIGlucHV0TmFtZXNVVEY4RW5jb2RlZC5wdXNoKG5hbWUpO1xuICAgICAgaW5wdXROYW1lcy5wdXNoKHdhc20uVVRGOFRvU3RyaW5nKG5hbWUpKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBuYW1lID0gd2FzbS5fT3J0R2V0T3V0cHV0TmFtZShzZXNzaW9uSGFuZGxlLCBpKTtcbiAgICAgIGlmIChuYW1lID09PSAwKSB7XG4gICAgICAgIGNoZWNrTGFzdEVycm9yKCdDYW5cXCd0IGdldCBhbiBvdXRwdXQgbmFtZS4nKTtcbiAgICAgIH1cbiAgICAgIG91dHB1dE5hbWVzVVRGOEVuY29kZWQucHVzaChuYW1lKTtcbiAgICAgIGNvbnN0IG5hbWVTdHJpbmcgPSB3YXNtLlVURjhUb1N0cmluZyhuYW1lKTtcbiAgICAgIG91dHB1dE5hbWVzLnB1c2gobmFtZVN0cmluZyk7XG5cbiAgICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX0pTRVApIHtcbiAgICAgICAgaWYgKGVuYWJsZUdyYXBoQ2FwdHVyZSAmJiBvcHRpb25zPy5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zLnB1c2goJ2dwdS1idWZmZXInKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHR5cGVvZiBvcHRpb25zPy5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbiA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgICAgb3B0aW9ucy5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbiA6XG4gICAgICAgICAgICBvcHRpb25zPy5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj8uW25hbWVTdHJpbmddID8/ICdjcHUnO1xuICAgICAgICBpZiAobG9jYXRpb24gIT09ICdjcHUnICYmIGxvY2F0aW9uICE9PSAnY3B1LXBpbm5lZCcgJiYgbG9jYXRpb24gIT09ICdncHUtYnVmZmVyJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IHN1cHBvcnRlZCBwcmVmZXJyZWQgb3V0cHV0IGxvY2F0aW9uOiAke2xvY2F0aW9ufS5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5hYmxlR3JhcGhDYXB0dXJlICYmIGxvY2F0aW9uICE9PSAnZ3B1LWJ1ZmZlcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgcHJlZmVycmVkIG91dHB1dCBsb2NhdGlvbjogJHtcbiAgICAgICAgICAgICAgbG9jYXRpb259LiBPbmx5ICdncHUtYnVmZmVyJyBsb2NhdGlvbiBpcyBzdXBwb3J0ZWQgd2hlbiBlbmFibGVHcmFwaENhcHR1cmUgaXMgdHJ1ZS5gKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMucHVzaChsb2NhdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdXNlIElPIGJpbmRpbmcgb25seSB3aGVuIGF0IGxlYXN0IG9uZSBvdXRwdXQgaXMgcHJlZmZlcmVkIHRvIGJlIG9uIEdQVS5cbiAgICBsZXQgYmluZGluZ1N0YXRlOiBJT0JpbmRpbmdTdGF0ZXxudWxsID0gbnVsbDtcbiAgICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQICYmIG91dHB1dFByZWZlcnJlZExvY2F0aW9ucy5zb21lKGwgPT4gbCA9PT0gJ2dwdS1idWZmZXInKSkge1xuICAgICAgaW9CaW5kaW5nSGFuZGxlID0gd2FzbS5fT3J0Q3JlYXRlQmluZGluZyhzZXNzaW9uSGFuZGxlKTtcbiAgICAgIGlmIChpb0JpbmRpbmdIYW5kbGUgPT09IDApIHtcbiAgICAgICAgY2hlY2tMYXN0RXJyb3IoJ0NhblxcJ3QgY3JlYXRlIElPIGJpbmRpbmcuJyk7XG4gICAgICB9XG5cbiAgICAgIGJpbmRpbmdTdGF0ZSA9IHtcbiAgICAgICAgaGFuZGxlOiBpb0JpbmRpbmdIYW5kbGUsXG4gICAgICAgIG91dHB1dFByZWZlcnJlZExvY2F0aW9ucyxcbiAgICAgICAgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zRW5jb2RlZDogb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zLm1hcChsID0+IGRhdGFMb2NhdGlvblN0cmluZ1RvRW51bShsKSksXG4gICAgICB9O1xuICAgIH1cblxuICAgIGFjdGl2ZVNlc3Npb25zLnNldChcbiAgICAgICAgc2Vzc2lvbkhhbmRsZSxcbiAgICAgICAgW3Nlc3Npb25IYW5kbGUsIGlucHV0TmFtZXNVVEY4RW5jb2RlZCwgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCwgYmluZGluZ1N0YXRlLCBlbmFibGVHcmFwaENhcHR1cmUsIGZhbHNlXSk7XG4gICAgcmV0dXJuIFtzZXNzaW9uSGFuZGxlLCBpbnB1dE5hbWVzLCBvdXRwdXROYW1lc107XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpbnB1dE5hbWVzVVRGOEVuY29kZWQuZm9yRWFjaChidWYgPT4gd2FzbS5fT3J0RnJlZShidWYpKTtcbiAgICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2goYnVmID0+IHdhc20uX09ydEZyZWUoYnVmKSk7XG5cbiAgICBpZiAoaW9CaW5kaW5nSGFuZGxlICE9PSAwKSB7XG4gICAgICB3YXNtLl9PcnRSZWxlYXNlQmluZGluZyhpb0JpbmRpbmdIYW5kbGUpO1xuICAgIH1cblxuICAgIGlmIChzZXNzaW9uSGFuZGxlICE9PSAwKSB7XG4gICAgICB3YXNtLl9PcnRSZWxlYXNlU2Vzc2lvbihzZXNzaW9uSGFuZGxlKTtcbiAgICB9XG4gICAgdGhyb3cgZTtcbiAgfSBmaW5hbGx5IHtcbiAgICB3YXNtLl9mcmVlKG1vZGVsRGF0YU9mZnNldCk7XG4gICAgaWYgKHNlc3Npb25PcHRpb25zSGFuZGxlICE9PSAwKSB7XG4gICAgICB3YXNtLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMoc2Vzc2lvbk9wdGlvbnNIYW5kbGUpO1xuICAgIH1cbiAgICBhbGxvY3MuZm9yRWFjaChhbGxvYyA9PiB3YXNtLl9mcmVlKGFsbG9jKSk7XG5cbiAgICAvLyB1bm1vdW50IGV4dGVybmFsIGRhdGEgaWYgbmVjZXNzYXJ5XG4gICAgd2FzbS51bm1vdW50RXh0ZXJuYWxEYXRhPy4oKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlbGVhc2VTZXNzaW9uID0gKHNlc3Npb25JZDogbnVtYmVyKTogdm9pZCA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBjb25zdCBzZXNzaW9uID0gYWN0aXZlU2Vzc2lvbnMuZ2V0KHNlc3Npb25JZCk7XG4gIGlmICghc2Vzc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlbGVhc2Ugc2Vzc2lvbi4gaW52YWxpZCBzZXNzaW9uIGlkOiAke3Nlc3Npb25JZH1gKTtcbiAgfVxuICBjb25zdCBbc2Vzc2lvbkhhbmRsZSwgaW5wdXROYW1lc1VURjhFbmNvZGVkLCBvdXRwdXROYW1lc1VURjhFbmNvZGVkLCBpb0JpbmRpbmdTdGF0ZSwgZW5hYmxlR3JhcGhDYXB0dXJlXSA9IHNlc3Npb247XG5cbiAgaWYgKGlvQmluZGluZ1N0YXRlKSB7XG4gICAgaWYgKGVuYWJsZUdyYXBoQ2FwdHVyZSkge1xuICAgICAgd2FzbS5fT3J0Q2xlYXJCb3VuZE91dHB1dHMoaW9CaW5kaW5nU3RhdGUuaGFuZGxlKTtcbiAgICB9XG4gICAgd2FzbS5fT3J0UmVsZWFzZUJpbmRpbmcoaW9CaW5kaW5nU3RhdGUuaGFuZGxlKTtcbiAgfVxuXG4gIHdhc20uanNlcE9uUmVsZWFzZVNlc3Npb24/LihzZXNzaW9uSWQpO1xuXG4gIGlucHV0TmFtZXNVVEY4RW5jb2RlZC5mb3JFYWNoKGJ1ZiA9PiB3YXNtLl9PcnRGcmVlKGJ1ZikpO1xuICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2goYnVmID0+IHdhc20uX09ydEZyZWUoYnVmKSk7XG4gIHdhc20uX09ydFJlbGVhc2VTZXNzaW9uKHNlc3Npb25IYW5kbGUpO1xuICBhY3RpdmVTZXNzaW9ucy5kZWxldGUoc2Vzc2lvbklkKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwcmVwYXJlSW5wdXRPdXRwdXRUZW5zb3IgPVxuICAgICh0ZW5zb3I6IFRlbnNvck1ldGFkYXRhfG51bGwsIHRlbnNvckhhbmRsZXM6IG51bWJlcltdLCBhbGxvY3M6IG51bWJlcltdLCBzZXNzaW9uSWQ6IG51bWJlciwgaW5kZXg6IG51bWJlcixcbiAgICAgZW5hYmxlR3JhcGhDYXB0dXJlID0gZmFsc2UpOiB2b2lkID0+IHtcbiAgICAgIGlmICghdGVuc29yKSB7XG4gICAgICAgIHRlbnNvckhhbmRsZXMucHVzaCgwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcblxuICAgICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JbMF07XG4gICAgICBjb25zdCBkaW1zID0gdGVuc29yWzFdO1xuICAgICAgY29uc3QgbG9jYXRpb24gPSB0ZW5zb3JbM107XG5cbiAgICAgIGxldCByYXdEYXRhOiBudW1iZXI7XG4gICAgICBsZXQgZGF0YUJ5dGVMZW5ndGg6IG51bWJlcjtcblxuICAgICAgaWYgKGRhdGFUeXBlID09PSAnc3RyaW5nJyAmJiBsb2NhdGlvbiA9PT0gJ2dwdS1idWZmZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIG9uIEdQVS4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuYWJsZUdyYXBoQ2FwdHVyZSAmJiBsb2NhdGlvbiAhPT0gJ2dwdS1idWZmZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBFeHRlcm5hbCBidWZmZXIgbXVzdCBiZSBwcm92aWRlZCBmb3IgaW5wdXQvb3V0cHV0IGluZGV4ICR7aW5kZXh9IHdoZW4gZW5hYmxlR3JhcGhDYXB0dXJlIGlzIHRydWUuYCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsb2NhdGlvbiA9PT0gJ2dwdS1idWZmZXInKSB7XG4gICAgICAgIGNvbnN0IGdwdUJ1ZmZlciA9IHRlbnNvclsyXS5ncHVCdWZmZXIgYXMgR1BVQnVmZmVyO1xuICAgICAgICBjb25zdCBlbGVtZW50U2l6ZUluQnl0ZXMgPSBnZXRUZW5zb3JFbGVtZW50U2l6ZSh0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bShkYXRhVHlwZSkpITtcbiAgICAgICAgZGF0YUJ5dGVMZW5ndGggPSBkaW1zLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIsIDEpICogZWxlbWVudFNpemVJbkJ5dGVzO1xuXG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyQnVmZmVyID0gd2FzbS5qc2VwUmVnaXN0ZXJCdWZmZXI7XG4gICAgICAgIGlmICghcmVnaXN0ZXJCdWZmZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBsb2NhdGlvbiBcImdwdS1idWZmZXJcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViR1BVLicpO1xuICAgICAgICB9XG4gICAgICAgIHJhd0RhdGEgPSByZWdpc3RlckJ1ZmZlcihzZXNzaW9uSWQsIGluZGV4LCBncHVCdWZmZXIsIGRhdGFCeXRlTGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0ZW5zb3JbMl07XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAvLyBzdHJpbmcgdGVuc29yXG4gICAgICAgICAgZGF0YUJ5dGVMZW5ndGggPSA0ICogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgcmF3RGF0YSA9IHdhc20uX21hbGxvYyhkYXRhQnl0ZUxlbmd0aCk7XG4gICAgICAgICAgYWxsb2NzLnB1c2gocmF3RGF0YSk7XG4gICAgICAgICAgbGV0IGRhdGFJbmRleCA9IHJhd0RhdGEgLyA0O1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0ZW5zb3IgZGF0YSBhdCBpbmRleCAke2l9IGlzIG5vdCBhIHN0cmluZ2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2FzbS5IRUFQVTMyW2RhdGFJbmRleCsrXSA9IGFsbG9jV2FzbVN0cmluZyhkYXRhW2ldLCBhbGxvY3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhQnl0ZUxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICByYXdEYXRhID0gd2FzbS5fbWFsbG9jKGRhdGFCeXRlTGVuZ3RoKTtcbiAgICAgICAgICBhbGxvY3MucHVzaChyYXdEYXRhKTtcbiAgICAgICAgICB3YXNtLkhFQVBVOC5zZXQobmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YUJ5dGVMZW5ndGgpLCByYXdEYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzdGFjayA9IHdhc20uc3RhY2tTYXZlKCk7XG4gICAgICBjb25zdCBkaW1zT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKDQgKiBkaW1zLmxlbmd0aCk7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgZGltSW5kZXggPSBkaW1zT2Zmc2V0IC8gNDtcbiAgICAgICAgZGltcy5mb3JFYWNoKGQgPT4gd2FzbS5IRUFQMzJbZGltSW5kZXgrK10gPSBkKTtcbiAgICAgICAgY29uc3QgdGVuc29yID0gd2FzbS5fT3J0Q3JlYXRlVGVuc29yKFxuICAgICAgICAgICAgdGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0oZGF0YVR5cGUpLCByYXdEYXRhLCBkYXRhQnl0ZUxlbmd0aCwgZGltc09mZnNldCwgZGltcy5sZW5ndGgsXG4gICAgICAgICAgICBkYXRhTG9jYXRpb25TdHJpbmdUb0VudW0obG9jYXRpb24pKTtcbiAgICAgICAgaWYgKHRlbnNvciA9PT0gMCkge1xuICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBjcmVhdGUgdGVuc29yIGZvciBpbnB1dC9vdXRwdXQuIHNlc3Npb249JHtzZXNzaW9uSWR9LCBpbmRleD0ke2luZGV4fS5gKTtcbiAgICAgICAgfVxuICAgICAgICB0ZW5zb3JIYW5kbGVzLnB1c2godGVuc29yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHdhc20uc3RhY2tSZXN0b3JlKHN0YWNrKTtcbiAgICAgIH1cbiAgICB9O1xuXG4vKipcbiAqIHBlcmZvcm0gaW5mZXJlbmNlIHJ1blxuICovXG5leHBvcnQgY29uc3QgcnVuID0gYXN5bmMoXG4gICAgc2Vzc2lvbklkOiBudW1iZXIsIGlucHV0SW5kaWNlczogbnVtYmVyW10sIGlucHV0VGVuc29yczogVGVuc29yTWV0YWRhdGFbXSwgb3V0cHV0SW5kaWNlczogbnVtYmVyW10sXG4gICAgb3V0cHV0VGVuc29yczogQXJyYXk8VGVuc29yTWV0YWRhdGF8bnVsbD4sIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyk6IFByb21pc2U8VGVuc29yTWV0YWRhdGFbXT4gPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcbiAgY29uc3Qgc2Vzc2lvbiA9IGFjdGl2ZVNlc3Npb25zLmdldChzZXNzaW9uSWQpO1xuICBpZiAoIXNlc3Npb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBydW4gaW5mZXJlbmNlLiBpbnZhbGlkIHNlc3Npb24gaWQ6ICR7c2Vzc2lvbklkfWApO1xuICB9XG4gIGNvbnN0IHNlc3Npb25IYW5kbGUgPSBzZXNzaW9uWzBdO1xuICBjb25zdCBpbnB1dE5hbWVzVVRGOEVuY29kZWQgPSBzZXNzaW9uWzFdO1xuICBjb25zdCBvdXRwdXROYW1lc1VURjhFbmNvZGVkID0gc2Vzc2lvblsyXTtcbiAgY29uc3QgaW9CaW5kaW5nU3RhdGUgPSBzZXNzaW9uWzNdO1xuICBjb25zdCBlbmFibGVHcmFwaENhcHR1cmUgPSBzZXNzaW9uWzRdO1xuICBjb25zdCBpbnB1dE91dHB1dEJvdW5kID0gc2Vzc2lvbls1XTtcblxuICBjb25zdCBpbnB1dENvdW50ID0gaW5wdXRJbmRpY2VzLmxlbmd0aDtcbiAgY29uc3Qgb3V0cHV0Q291bnQgPSBvdXRwdXRJbmRpY2VzLmxlbmd0aDtcblxuICBsZXQgcnVuT3B0aW9uc0hhbmRsZSA9IDA7XG4gIGxldCBydW5PcHRpb25zQWxsb2NzOiBudW1iZXJbXSA9IFtdO1xuXG4gIGNvbnN0IGlucHV0VGVuc29ySGFuZGxlczogbnVtYmVyW10gPSBbXTtcbiAgY29uc3Qgb3V0cHV0VGVuc29ySGFuZGxlczogbnVtYmVyW10gPSBbXTtcbiAgY29uc3QgaW5wdXRPdXRwdXRBbGxvY3M6IG51bWJlcltdID0gW107XG5cbiAgY29uc3QgYmVmb3JlUnVuU3RhY2sgPSB3YXNtLnN0YWNrU2F2ZSgpO1xuICBjb25zdCBpbnB1dFZhbHVlc09mZnNldCA9IHdhc20uc3RhY2tBbGxvYyhpbnB1dENvdW50ICogNCk7XG4gIGNvbnN0IGlucHV0TmFtZXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoaW5wdXRDb3VudCAqIDQpO1xuICBjb25zdCBvdXRwdXRWYWx1ZXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2Mob3V0cHV0Q291bnQgKiA0KTtcbiAgY29uc3Qgb3V0cHV0TmFtZXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2Mob3V0cHV0Q291bnQgKiA0KTtcblxuICB0cnkge1xuICAgIFtydW5PcHRpb25zSGFuZGxlLCBydW5PcHRpb25zQWxsb2NzXSA9IHNldFJ1bk9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAvLyBjcmVhdGUgaW5wdXQgdGVuc29yc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDb3VudDsgaSsrKSB7XG4gICAgICBwcmVwYXJlSW5wdXRPdXRwdXRUZW5zb3IoXG4gICAgICAgICAgaW5wdXRUZW5zb3JzW2ldLCBpbnB1dFRlbnNvckhhbmRsZXMsIGlucHV0T3V0cHV0QWxsb2NzLCBzZXNzaW9uSWQsIGlucHV0SW5kaWNlc1tpXSwgZW5hYmxlR3JhcGhDYXB0dXJlKTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgb3V0cHV0IHRlbnNvcnNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dENvdW50OyBpKyspIHtcbiAgICAgIHByZXBhcmVJbnB1dE91dHB1dFRlbnNvcihcbiAgICAgICAgICBvdXRwdXRUZW5zb3JzW2ldLCBvdXRwdXRUZW5zb3JIYW5kbGVzLCBpbnB1dE91dHB1dEFsbG9jcywgc2Vzc2lvbklkLCBpbnB1dENvdW50ICsgb3V0cHV0SW5kaWNlc1tpXSxcbiAgICAgICAgICBlbmFibGVHcmFwaENhcHR1cmUpO1xuICAgIH1cblxuICAgIGxldCBpbnB1dFZhbHVlc0luZGV4ID0gaW5wdXRWYWx1ZXNPZmZzZXQgLyA0O1xuICAgIGxldCBpbnB1dE5hbWVzSW5kZXggPSBpbnB1dE5hbWVzT2Zmc2V0IC8gNDtcbiAgICBsZXQgb3V0cHV0VmFsdWVzSW5kZXggPSBvdXRwdXRWYWx1ZXNPZmZzZXQgLyA0O1xuICAgIGxldCBvdXRwdXROYW1lc0luZGV4ID0gb3V0cHV0TmFtZXNPZmZzZXQgLyA0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDb3VudDsgaSsrKSB7XG4gICAgICB3YXNtLkhFQVBVMzJbaW5wdXRWYWx1ZXNJbmRleCsrXSA9IGlucHV0VGVuc29ySGFuZGxlc1tpXTtcbiAgICAgIHdhc20uSEVBUFUzMltpbnB1dE5hbWVzSW5kZXgrK10gPSBpbnB1dE5hbWVzVVRGOEVuY29kZWRbaW5wdXRJbmRpY2VzW2ldXTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRDb3VudDsgaSsrKSB7XG4gICAgICB3YXNtLkhFQVBVMzJbb3V0cHV0VmFsdWVzSW5kZXgrK10gPSBvdXRwdXRUZW5zb3JIYW5kbGVzW2ldO1xuICAgICAgd2FzbS5IRUFQVTMyW291dHB1dE5hbWVzSW5kZXgrK10gPSBvdXRwdXROYW1lc1VURjhFbmNvZGVkW291dHB1dEluZGljZXNbaV1dO1xuICAgIH1cblxuICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgJiYgaW9CaW5kaW5nU3RhdGUgJiYgIWlucHV0T3V0cHV0Qm91bmQpIHtcbiAgICAgIGNvbnN0IHtoYW5kbGUsIG91dHB1dFByZWZlcnJlZExvY2F0aW9ucywgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zRW5jb2RlZH0gPSBpb0JpbmRpbmdTdGF0ZTtcblxuICAgICAgaWYgKGlucHV0TmFtZXNVVEY4RW5jb2RlZC5sZW5ndGggIT09IGlucHV0Q291bnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnB1dCBjb3VudCBmcm9tIGZlZWRzICgke1xuICAgICAgICAgICAgaW5wdXRDb3VudH0pIGlzIGV4cGVjdGVkIHRvIGJlIGFsd2F5cyBlcXVhbCB0byBtb2RlbCdzIGlucHV0IGNvdW50ICgke2lucHV0TmFtZXNVVEY4RW5jb2RlZC5sZW5ndGh9KS5gKTtcbiAgICAgIH1cblxuICAgICAgLy8gcHJvY2VzcyBpbnB1dHNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaW5wdXRJbmRpY2VzW2ldO1xuICAgICAgICBjb25zdCBlcnJvckNvZGUgPSBhd2FpdCB3YXNtLl9PcnRCaW5kSW5wdXQoaGFuZGxlLCBpbnB1dE5hbWVzVVRGOEVuY29kZWRbaW5kZXhdLCBpbnB1dFRlbnNvckhhbmRsZXNbaV0pO1xuICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGJpbmQgaW5wdXRbJHtpfV0gZm9yIHNlc3Npb249JHtzZXNzaW9uSWR9LmApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHByb2Nlc3MgcHJlLWFsbG9jYXRlZCBvdXRwdXRzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dENvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBvdXRwdXRJbmRpY2VzW2ldO1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IG91dHB1dFRlbnNvcnNbaV0/LlszXTsgIC8vIHVuZGVmaW5lZCBtZWFucyBvdXRwdXQgaXMgbm90IHByZS1hbGxvY2F0ZWQuXG5cbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICAgICAgLy8gb3V0cHV0IGlzIHByZS1hbGxvY2F0ZWQuIGJpbmQgdGhlIHRlbnNvci5cbiAgICAgICAgICBjb25zdCBlcnJvckNvZGUgPSB3YXNtLl9PcnRCaW5kT3V0cHV0KGhhbmRsZSwgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZFtpbmRleF0sIG91dHB1dFRlbnNvckhhbmRsZXNbaV0sIDApO1xuICAgICAgICAgIGlmIChlcnJvckNvZGUgIT09IDApIHtcbiAgICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBiaW5kIHByZS1hbGxvY2F0ZWQgb3V0cHV0WyR7aX1dIGZvciBzZXNzaW9uPSR7c2Vzc2lvbklkfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb3V0cHV0IGlzIG5vdCBwcmUtYWxsb2NhdGVkLiByZXNldCBwcmVmZXJyZWQgbG9jYXRpb24uXG4gICAgICAgICAgY29uc3QgZXJyb3JDb2RlID1cbiAgICAgICAgICAgICAgd2FzbS5fT3J0QmluZE91dHB1dChoYW5kbGUsIG91dHB1dE5hbWVzVVRGOEVuY29kZWRbaW5kZXhdLCAwLCBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkW2luZGV4XSk7XG4gICAgICAgICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGJpbmQgb3V0cHV0WyR7aX1dIHRvICR7b3V0cHV0UHJlZmVycmVkTG9jYXRpb25zW2ldfSBmb3Igc2Vzc2lvbj0ke3Nlc3Npb25JZH0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhY3RpdmVTZXNzaW9ucy5zZXQoXG4gICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgIFtzZXNzaW9uSGFuZGxlLCBpbnB1dE5hbWVzVVRGOEVuY29kZWQsIG91dHB1dE5hbWVzVVRGOEVuY29kZWQsIGlvQmluZGluZ1N0YXRlLCBlbmFibGVHcmFwaENhcHR1cmUsIHRydWVdKTtcbiAgICB9XG5cbiAgICB3YXNtLmpzZXBPblJ1blN0YXJ0Py4oc2Vzc2lvbkhhbmRsZSk7XG4gICAgbGV0IGVycm9yQ29kZTogbnVtYmVyO1xuICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgJiYgaW9CaW5kaW5nU3RhdGUpIHtcbiAgICAgIGVycm9yQ29kZSA9IGF3YWl0IHdhc20uX09ydFJ1bldpdGhCaW5kaW5nKFxuICAgICAgICAgIHNlc3Npb25IYW5kbGUsIGlvQmluZGluZ1N0YXRlLmhhbmRsZSwgb3V0cHV0Q291bnQsIG91dHB1dFZhbHVlc09mZnNldCwgcnVuT3B0aW9uc0hhbmRsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yQ29kZSA9IGF3YWl0IHdhc20uX09ydFJ1bihcbiAgICAgICAgICBzZXNzaW9uSGFuZGxlLCBpbnB1dE5hbWVzT2Zmc2V0LCBpbnB1dFZhbHVlc09mZnNldCwgaW5wdXRDb3VudCwgb3V0cHV0TmFtZXNPZmZzZXQsIG91dHB1dENvdW50LFxuICAgICAgICAgIG91dHB1dFZhbHVlc09mZnNldCwgcnVuT3B0aW9uc0hhbmRsZSk7XG4gICAgfVxuXG4gICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgICAgY2hlY2tMYXN0RXJyb3IoJ2ZhaWxlZCB0byBjYWxsIE9ydFJ1bigpLicpO1xuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dDogVGVuc29yTWV0YWRhdGFbXSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZW5zb3IgPSB3YXNtLkhFQVBVMzJbb3V0cHV0VmFsdWVzT2Zmc2V0IC8gNCArIGldO1xuICAgICAgaWYgKHRlbnNvciA9PT0gb3V0cHV0VGVuc29ySGFuZGxlc1tpXSkge1xuICAgICAgICAvLyBvdXRwdXQgdGVuc29yIGlzIHByZS1hbGxvY2F0ZWQuIG5vIG5lZWQgdG8gY29weSBkYXRhLlxuICAgICAgICBvdXRwdXQucHVzaChvdXRwdXRUZW5zb3JzW2ldISk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBiZWZvcmVHZXRUZW5zb3JEYXRhU3RhY2sgPSB3YXNtLnN0YWNrU2F2ZSgpO1xuICAgICAgLy8gc3RhY2sgYWxsb2NhdGUgNCBwb2ludGVyIHZhbHVlXG4gICAgICBjb25zdCB0ZW5zb3JEYXRhT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKDQgKiA0KTtcblxuICAgICAgbGV0IGtlZXBPdXRwdXRUZW5zb3IgPSBmYWxzZTtcbiAgICAgIGxldCB0eXBlOiBUZW5zb3IuVHlwZXx1bmRlZmluZWQsIGRhdGFPZmZzZXQgPSAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gd2FzbS5fT3J0R2V0VGVuc29yRGF0YShcbiAgICAgICAgICAgIHRlbnNvciwgdGVuc29yRGF0YU9mZnNldCwgdGVuc29yRGF0YU9mZnNldCArIDQsIHRlbnNvckRhdGFPZmZzZXQgKyA4LCB0ZW5zb3JEYXRhT2Zmc2V0ICsgMTIpO1xuICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGFjY2VzcyBvdXRwdXQgdGVuc29yIGRhdGEgb24gaW5kZXggJHtpfS5gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGVuc29yRGF0YUluZGV4ID0gdGVuc29yRGF0YU9mZnNldCAvIDQ7XG4gICAgICAgIGNvbnN0IGRhdGFUeXBlID0gd2FzbS5IRUFQVTMyW3RlbnNvckRhdGFJbmRleCsrXTtcbiAgICAgICAgZGF0YU9mZnNldCA9IHdhc20uSEVBUFUzMlt0ZW5zb3JEYXRhSW5kZXgrK107XG4gICAgICAgIGNvbnN0IGRpbXNPZmZzZXQgPSB3YXNtLkhFQVBVMzJbdGVuc29yRGF0YUluZGV4KytdO1xuICAgICAgICBjb25zdCBkaW1zTGVuZ3RoID0gd2FzbS5IRUFQVTMyW3RlbnNvckRhdGFJbmRleCsrXTtcbiAgICAgICAgY29uc3QgZGltcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgIGRpbXMucHVzaCh3YXNtLkhFQVBVMzJbZGltc09mZnNldCAvIDQgKyBpXSk7XG4gICAgICAgIH1cbiAgICAgICAgd2FzbS5fT3J0RnJlZShkaW1zT2Zmc2V0KTtcblxuICAgICAgICBjb25zdCBzaXplID0gZGltcy5yZWR1Y2UoKGEsIGIpID0+IGEgKiBiLCAxKTtcbiAgICAgICAgdHlwZSA9IHRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nKGRhdGFUeXBlKTtcblxuICAgICAgICBjb25zdCBwcmVmZXJyZWRMb2NhdGlvbiA9IGlvQmluZGluZ1N0YXRlPy5vdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNbb3V0cHV0SW5kaWNlc1tpXV07XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKHByZWZlcnJlZExvY2F0aW9uID09PSAnZ3B1LWJ1ZmZlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIG9uIEdQVS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc3RyaW5nRGF0YTogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgICBsZXQgZGF0YUluZGV4ID0gZGF0YU9mZnNldCAvIDQ7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHdhc20uSEVBUFUzMltkYXRhSW5kZXgrK107XG4gICAgICAgICAgICBjb25zdCBtYXhCeXRlc1RvUmVhZCA9IGkgPT09IHNpemUgLSAxID8gdW5kZWZpbmVkIDogd2FzbS5IRUFQVTMyW2RhdGFJbmRleF0gLSBvZmZzZXQ7XG4gICAgICAgICAgICBzdHJpbmdEYXRhLnB1c2god2FzbS5VVEY4VG9TdHJpbmcob2Zmc2V0LCBtYXhCeXRlc1RvUmVhZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXQucHVzaChbdHlwZSwgZGltcywgc3RyaW5nRGF0YSwgJ2NwdSddKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiBhIGNlcnRhaW4gb3V0cHV0J3MgcHJlZmVycmVkIGxvY2F0aW9uIGlzIEdQVSBidXQgdGhlIHRlbnNvciBpcyBlbXB0eSwgd2Ugc3RpbGwgbmVlZCB0byBjcmVhdGUgYSBDUFVcbiAgICAgICAgICAvLyB0ZW5zb3IgZm9yIGl0LiBUaGVyZSBpcyBubyBtYXBwaW5nIEdQVSBidWZmZXIgZm9yIGFuIGVtcHR5IHRlbnNvci5cbiAgICAgICAgICBpZiAocHJlZmVycmVkTG9jYXRpb24gPT09ICdncHUtYnVmZmVyJyAmJiBzaXplID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZ2V0QnVmZmVyID0gd2FzbS5qc2VwR2V0QnVmZmVyO1xuICAgICAgICAgICAgaWYgKCFnZXRCdWZmZXIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcmVmZXJyZWRMb2NhdGlvbiBcImdwdS1idWZmZXJcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViR1BVLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZ3B1QnVmZmVyID0gZ2V0QnVmZmVyKGRhdGFPZmZzZXQpO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudFNpemUgPSBnZXRUZW5zb3JFbGVtZW50U2l6ZShkYXRhVHlwZSk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudFNpemUgPT09IHVuZGVmaW5lZCB8fCAhaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R5cGV9YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRvIG5vdCByZWxlYXNlIHRoZSB0ZW5zb3IgcmlnaHQgbm93LiBpdCB3aWxsIGJlIHJlbGVhc2VkIHdoZW4gdXNlciBjYWxscyB0ZW5zb3IuZGlzcG9zZSgpLlxuICAgICAgICAgICAga2VlcE91dHB1dFRlbnNvciA9IHRydWU7XG5cbiAgICAgICAgICAgIG91dHB1dC5wdXNoKFtcbiAgICAgICAgICAgICAgdHlwZSwgZGltcywge1xuICAgICAgICAgICAgICAgIGdwdUJ1ZmZlcixcbiAgICAgICAgICAgICAgICBkb3dubG9hZDogd2FzbS5qc2VwQ3JlYXRlRG93bmxvYWRlciEoZ3B1QnVmZmVyLCBzaXplICogZWxlbWVudFNpemUsIHR5cGUpLFxuICAgICAgICAgICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIHdhc20uX09ydFJlbGVhc2VUZW5zb3IodGVuc29yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICdncHUtYnVmZmVyJ1xuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IHRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3Rvcih0eXBlKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgdHlwZWRBcnJheUNvbnN0cnVjdG9yKHNpemUpO1xuICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKVxuICAgICAgICAgICAgICAgIC5zZXQod2FzbS5IRUFQVTguc3ViYXJyYXkoZGF0YU9mZnNldCwgZGF0YU9mZnNldCArIGRhdGEuYnl0ZUxlbmd0aCkpO1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goW3R5cGUsIGRpbXMsIGRhdGEsICdjcHUnXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB3YXNtLnN0YWNrUmVzdG9yZShiZWZvcmVHZXRUZW5zb3JEYXRhU3RhY2spO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgZGF0YU9mZnNldCkge1xuICAgICAgICAgIHdhc20uX2ZyZWUoZGF0YU9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFrZWVwT3V0cHV0VGVuc29yKSB7XG4gICAgICAgICAgd2FzbS5fT3J0UmVsZWFzZVRlbnNvcih0ZW5zb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlvQmluZGluZ1N0YXRlICYmICFlbmFibGVHcmFwaENhcHR1cmUpIHtcbiAgICAgIHdhc20uX09ydENsZWFyQm91bmRPdXRwdXRzKGlvQmluZGluZ1N0YXRlLmhhbmRsZSk7XG4gICAgICBhY3RpdmVTZXNzaW9ucy5zZXQoXG4gICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgIFtzZXNzaW9uSGFuZGxlLCBpbnB1dE5hbWVzVVRGOEVuY29kZWQsIG91dHB1dE5hbWVzVVRGOEVuY29kZWQsIGlvQmluZGluZ1N0YXRlLCBlbmFibGVHcmFwaENhcHR1cmUsIGZhbHNlXSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH0gZmluYWxseSB7XG4gICAgd2FzbS5zdGFja1Jlc3RvcmUoYmVmb3JlUnVuU3RhY2spO1xuXG4gICAgaW5wdXRUZW5zb3JIYW5kbGVzLmZvckVhY2godiA9PiB3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHYpKTtcbiAgICBvdXRwdXRUZW5zb3JIYW5kbGVzLmZvckVhY2godiA9PiB3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHYpKTtcbiAgICBpbnB1dE91dHB1dEFsbG9jcy5mb3JFYWNoKHAgPT4gd2FzbS5fZnJlZShwKSk7XG5cbiAgICBpZiAocnVuT3B0aW9uc0hhbmRsZSAhPT0gMCkge1xuICAgICAgd2FzbS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMocnVuT3B0aW9uc0hhbmRsZSk7XG4gICAgfVxuICAgIHJ1bk9wdGlvbnNBbGxvY3MuZm9yRWFjaChwID0+IHdhc20uX2ZyZWUocCkpO1xuICB9XG59O1xuXG4vKipcbiAqIGVuZCBwcm9maWxpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGVuZFByb2ZpbGluZyA9IChzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQgPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcbiAgY29uc3Qgc2Vzc2lvbiA9IGFjdGl2ZVNlc3Npb25zLmdldChzZXNzaW9uSWQpO1xuICBpZiAoIXNlc3Npb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2Vzc2lvbiBpZCcpO1xuICB9XG4gIGNvbnN0IHNlc3Npb25IYW5kbGUgPSBzZXNzaW9uWzBdO1xuXG4gIC8vIHByb2ZpbGUgZmlsZSBuYW1lIGlzIG5vdCB1c2VkIHlldCwgYnV0IGl0IG11c3QgYmUgZnJlZWQuXG4gIGNvbnN0IHByb2ZpbGVGaWxlTmFtZSA9IHdhc20uX09ydEVuZFByb2ZpbGluZyhzZXNzaW9uSGFuZGxlKTtcbiAgaWYgKHByb2ZpbGVGaWxlTmFtZSA9PT0gMCkge1xuICAgIGNoZWNrTGFzdEVycm9yKCdDYW5cXCd0IGdldCBhbiBwcm9maWxlIGZpbGUgbmFtZS4nKTtcbiAgfVxuICB3YXNtLl9PcnRGcmVlKHByb2ZpbGVGaWxlTmFtZSk7XG59O1xuXG5leHBvcnQgY29uc3QgZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnMgPSAodGVuc29yczogcmVhZG9ubHkgU2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGFbXSk6IEFycmF5QnVmZmVyTGlrZVtdID0+IHtcbiAgY29uc3QgYnVmZmVyczogQXJyYXlCdWZmZXJMaWtlW10gPSBbXTtcbiAgZm9yIChjb25zdCB0ZW5zb3Igb2YgdGVuc29ycykge1xuICAgIGNvbnN0IGRhdGEgPSB0ZW5zb3JbMl07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpICYmICdidWZmZXInIGluIGRhdGEpIHtcbiAgICAgIGJ1ZmZlcnMucHVzaChkYXRhLmJ1ZmZlcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBidWZmZXJzO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtlbnYsIEluZmVyZW5jZVNlc3Npb259IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7T3J0V2FzbU1lc3NhZ2UsIFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyLCBTZXJpYWxpemFibGVTZXNzaW9uTWV0YWRhdGEsIFNlcmlhbGl6YWJsZVRlbnNvck1ldGFkYXRhLCBUZW5zb3JNZXRhZGF0YX0gZnJvbSAnLi9wcm94eS1tZXNzYWdlcyc7XG5pbXBvcnQgKiBhcyBjb3JlIGZyb20gJy4vd2FzbS1jb3JlLWltcGwnO1xuaW1wb3J0IHtpbml0aWFsaXplV2ViQXNzZW1ibHl9IGZyb20gJy4vd2FzbS1mYWN0b3J5JztcbmltcG9ydCB7aW1wb3J0UHJveHlXb3JrZXJ9IGZyb20gJy4vd2FzbS11dGlscy1pbXBvcnQnO1xuXG5jb25zdCBpc1Byb3h5ID0gKCk6IGJvb2xlYW4gPT4gISFlbnYud2FzbS5wcm94eSAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xubGV0IHByb3h5V29ya2VyOiBXb3JrZXJ8dW5kZWZpbmVkO1xubGV0IGluaXRpYWxpemluZyA9IGZhbHNlO1xubGV0IGluaXRpYWxpemVkID0gZmFsc2U7XG5sZXQgYWJvcnRlZCA9IGZhbHNlO1xubGV0IHRlbXBvcmFyeU9iamVjdFVybDogc3RyaW5nfHVuZGVmaW5lZDtcblxudHlwZSBQcm9taXNlQ2FsbGJhY2tzPFQgPSB2b2lkPiA9IFtyZXNvbHZlOiAocmVzdWx0OiBUKSA9PiB2b2lkLCByZWplY3Q6IChyZWFzb246IHVua25vd24pID0+IHZvaWRdO1xubGV0IGluaXRXYXNtQ2FsbGJhY2tzOiBQcm9taXNlQ2FsbGJhY2tzO1xuY29uc3QgcXVldWVkQ2FsbGJhY2tzOiBNYXA8T3J0V2FzbU1lc3NhZ2VbJ3R5cGUnXSwgQXJyYXk8UHJvbWlzZUNhbGxiYWNrczx1bmtub3duPj4+ID0gbmV3IE1hcCgpO1xuXG5jb25zdCBlbnF1ZXVlQ2FsbGJhY2tzID0gKHR5cGU6IE9ydFdhc21NZXNzYWdlWyd0eXBlJ10sIGNhbGxiYWNrczogUHJvbWlzZUNhbGxiYWNrczx1bmtub3duPik6IHZvaWQgPT4ge1xuICBjb25zdCBxdWV1ZSA9IHF1ZXVlZENhbGxiYWNrcy5nZXQodHlwZSk7XG4gIGlmIChxdWV1ZSkge1xuICAgIHF1ZXVlLnB1c2goY2FsbGJhY2tzKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZWRDYWxsYmFja3Muc2V0KHR5cGUsIFtjYWxsYmFja3NdKTtcbiAgfVxufTtcblxuY29uc3QgZW5zdXJlV29ya2VyID0gKCk6IHZvaWQgPT4ge1xuICBpZiAoaW5pdGlhbGl6aW5nIHx8ICFpbml0aWFsaXplZCB8fCBhYm9ydGVkIHx8ICFwcm94eVdvcmtlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignd29ya2VyIG5vdCByZWFkeScpO1xuICB9XG59O1xuXG5jb25zdCBvblByb3h5V29ya2VyTWVzc2FnZSA9IChldjogTWVzc2FnZUV2ZW50PE9ydFdhc21NZXNzYWdlPik6IHZvaWQgPT4ge1xuICBzd2l0Y2ggKGV2LmRhdGEudHlwZSkge1xuICAgIGNhc2UgJ2luaXQtd2FzbSc6XG4gICAgICBpbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICAgIGlmIChldi5kYXRhLmVycikge1xuICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgaW5pdFdhc21DYWxsYmFja3NbMV0oZXYuZGF0YS5lcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICBpbml0V2FzbUNhbGxiYWNrc1swXSgpO1xuICAgICAgfVxuICAgICAgaWYgKHRlbXBvcmFyeU9iamVjdFVybCkge1xuICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHRlbXBvcmFyeU9iamVjdFVybCk7XG4gICAgICAgIHRlbXBvcmFyeU9iamVjdFVybCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2luaXQtZXAnOlxuICAgIGNhc2UgJ2NvcHktZnJvbSc6XG4gICAgY2FzZSAnY3JlYXRlJzpcbiAgICBjYXNlICdyZWxlYXNlJzpcbiAgICBjYXNlICdydW4nOlxuICAgIGNhc2UgJ2VuZC1wcm9maWxpbmcnOiB7XG4gICAgICBjb25zdCBjYWxsYmFja3MgPSBxdWV1ZWRDYWxsYmFja3MuZ2V0KGV2LmRhdGEudHlwZSkhO1xuICAgICAgaWYgKGV2LmRhdGEuZXJyKSB7XG4gICAgICAgIGNhbGxiYWNrcy5zaGlmdCgpIVsxXShldi5kYXRhLmVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFja3Muc2hpZnQoKSFbMF0oZXYuZGF0YS5vdXQhKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICB9XG59O1xuXG5cbmV4cG9ydCBjb25zdCBpbml0aWFsaXplV2ViQXNzZW1ibHlBbmRPcnRSdW50aW1lID0gYXN5bmMoKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGlmIChpbml0aWFsaXplZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaW5pdGlhbGl6aW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aXBsZSBjYWxscyB0byBcXCdpbml0V2FzbSgpXFwnIGRldGVjdGVkLicpO1xuICB9XG4gIGlmIChhYm9ydGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcmV2aW91cyBjYWxsIHRvIFxcJ2luaXRXYXNtKClcXCcgZmFpbGVkLicpO1xuICB9XG5cbiAgaW5pdGlhbGl6aW5nID0gdHJ1ZTtcblxuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBwcm94eVdvcmtlcj8udGVybWluYXRlKCk7XG5cbiAgICAgIHZvaWQgaW1wb3J0UHJveHlXb3JrZXIoKS50aGVuKChbb2JqZWN0VXJsLCB3b3JrZXJdKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcHJveHlXb3JrZXIgPSB3b3JrZXI7XG4gICAgICAgICAgcHJveHlXb3JrZXIub25lcnJvciA9IChldjogRXJyb3JFdmVudCkgPT4gcmVqZWN0KGV2KTtcbiAgICAgICAgICBwcm94eVdvcmtlci5vbm1lc3NhZ2UgPSBvblByb3h5V29ya2VyTWVzc2FnZTtcbiAgICAgICAgICBpbml0V2FzbUNhbGxiYWNrcyA9IFtyZXNvbHZlLCByZWplY3RdO1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2U6IE9ydFdhc21NZXNzYWdlID0ge3R5cGU6ICdpbml0LXdhc20nLCBpbiA6IGVudn07XG4gICAgICAgICAgcHJveHlXb3JrZXIucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgdGVtcG9yYXJ5T2JqZWN0VXJsID0gb2JqZWN0VXJsO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICB9LCByZWplY3QpO1xuICAgIH0pO1xuXG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGluaXRpYWxpemVXZWJBc3NlbWJseShlbnYud2FzbSk7XG4gICAgICBhd2FpdCBjb3JlLmluaXRSdW50aW1lKGVudik7XG4gICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgYWJvcnRlZCA9IHRydWU7XG4gICAgICB0aHJvdyBlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBpbml0aWFsaXplT3J0RXAgPSBhc3luYyhlcE5hbWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNX1BST1hZICYmIGlzUHJveHkoKSkge1xuICAgIGVuc3VyZVdvcmtlcigpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBlbnF1ZXVlQ2FsbGJhY2tzKCdpbml0LWVwJywgW3Jlc29sdmUsIHJlamVjdF0pO1xuICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPSB7dHlwZTogJ2luaXQtZXAnLCBpbiA6IHtlcE5hbWUsIGVudn19O1xuICAgICAgcHJveHlXb3JrZXIhLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGF3YWl0IGNvcmUuaW5pdEVwKGVudiwgZXBOYW1lKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIgPSBhc3luYyhidWZmZXI6IFVpbnQ4QXJyYXkpOiBQcm9taXNlPFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyPiA9PiB7XG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgJiYgaXNQcm94eSgpKSB7XG4gICAgZW5zdXJlV29ya2VyKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBlbnF1ZXVlQ2FsbGJhY2tzKCdjb3B5LWZyb20nLCBbcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHt0eXBlOiAnY29weS1mcm9tJywgaW4gOiB7YnVmZmVyfX07XG4gICAgICBwcm94eVdvcmtlciEucG9zdE1lc3NhZ2UobWVzc2FnZSwgW2J1ZmZlci5idWZmZXJdKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29yZS5jb3B5RnJvbUV4dGVybmFsQnVmZmVyKGJ1ZmZlcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVTZXNzaW9uID1cbiAgICBhc3luYyhtb2RlbDogU2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXJ8VWludDhBcnJheSwgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOlxuICAgICAgICBQcm9taXNlPFNlcmlhbGl6YWJsZVNlc3Npb25NZXRhZGF0YT4gPT4ge1xuICAgICAgICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgJiYgaXNQcm94eSgpKSB7XG4gICAgICAgICAgICAvLyBjaGVjayB1bnN1cHBvcnRlZCBvcHRpb25zXG4gICAgICAgICAgICBpZiAob3B0aW9ucz8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXNzaW9uIG9wdGlvbiBcInByZWZlcnJlZE91dHB1dExvY2F0aW9uXCIgaXMgbm90IHN1cHBvcnRlZCBmb3IgcHJveHkuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnN1cmVXb3JrZXIoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxTZXJpYWxpemFibGVTZXNzaW9uTWV0YWRhdGE+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgZW5xdWV1ZUNhbGxiYWNrcygnY3JlYXRlJywgW3Jlc29sdmUsIHJlamVjdF0pO1xuICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHt0eXBlOiAnY3JlYXRlJywgaW4gOiB7bW9kZWwsIG9wdGlvbnM6IHsuLi5vcHRpb25zfX19O1xuICAgICAgICAgICAgICBjb25zdCB0cmFuc2ZlcmFibGU6IFRyYW5zZmVyYWJsZVtdID0gW107XG4gICAgICAgICAgICAgIGlmIChtb2RlbCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2ZlcmFibGUucHVzaChtb2RlbC5idWZmZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHByb3h5V29ya2VyIS5wb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2ZlcmFibGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb3JlLmNyZWF0ZVNlc3Npb24obW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuZXhwb3J0IGNvbnN0IHJlbGVhc2VTZXNzaW9uID0gYXN5bmMoc2Vzc2lvbklkOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTV9QUk9YWSAmJiBpc1Byb3h5KCkpIHtcbiAgICBlbnN1cmVXb3JrZXIoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZW5xdWV1ZUNhbGxiYWNrcygncmVsZWFzZScsIFtyZXNvbHZlLCByZWplY3RdKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2U6IE9ydFdhc21NZXNzYWdlID0ge3R5cGU6ICdyZWxlYXNlJywgaW4gOiBzZXNzaW9uSWR9O1xuICAgICAgcHJveHlXb3JrZXIhLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvcmUucmVsZWFzZVNlc3Npb24oc2Vzc2lvbklkKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJ1biA9IGFzeW5jKFxuICAgIHNlc3Npb25JZDogbnVtYmVyLCBpbnB1dEluZGljZXM6IG51bWJlcltdLCBpbnB1dHM6IFRlbnNvck1ldGFkYXRhW10sIG91dHB1dEluZGljZXM6IG51bWJlcltdLFxuICAgIG91dHB1dHM6IEFycmF5PFRlbnNvck1ldGFkYXRhfG51bGw+LCBvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPFRlbnNvck1ldGFkYXRhW10+ID0+IHtcbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTV9QUk9YWSAmJiBpc1Byb3h5KCkpIHtcbiAgICAvLyBjaGVjayBpbnB1dHMgbG9jYXRpb25cbiAgICBpZiAoaW5wdXRzLnNvbWUodCA9PiB0WzNdICE9PSAnY3B1JykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgdGVuc29yIG9uIEdQVSBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS4nKTtcbiAgICB9XG4gICAgLy8gY2hlY2sgb3V0cHV0cyBsb2NhdGlvblxuICAgIGlmIChvdXRwdXRzLnNvbWUodCA9PiB0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcmUtYWxsb2NhdGVkIG91dHB1dCB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCBmb3IgcHJveHkuJyk7XG4gICAgfVxuICAgIGVuc3VyZVdvcmtlcigpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTxTZXJpYWxpemFibGVUZW5zb3JNZXRhZGF0YVtdPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBlbnF1ZXVlQ2FsbGJhY2tzKCdydW4nLCBbcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICBjb25zdCBzZXJpYWxpemFibGVJbnB1dHMgPSBpbnB1dHMgYXMgU2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGFbXTsgIC8vIGV2ZXJ5IGlucHV0IGlzIG9uIENQVS5cbiAgICAgIGNvbnN0IG1lc3NhZ2U6IE9ydFdhc21NZXNzYWdlID1cbiAgICAgICAgICB7dHlwZTogJ3J1bicsIGluIDoge3Nlc3Npb25JZCwgaW5wdXRJbmRpY2VzLCBpbnB1dHM6IHNlcmlhbGl6YWJsZUlucHV0cywgb3V0cHV0SW5kaWNlcywgb3B0aW9uc319O1xuICAgICAgcHJveHlXb3JrZXIhLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIGNvcmUuZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnMoc2VyaWFsaXphYmxlSW5wdXRzKSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvcmUucnVuKHNlc3Npb25JZCwgaW5wdXRJbmRpY2VzLCBpbnB1dHMsIG91dHB1dEluZGljZXMsIG91dHB1dHMsIG9wdGlvbnMpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZW5kUHJvZmlsaW5nID0gYXN5bmMoc2Vzc2lvbklkOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTV9QUk9YWSAmJiBpc1Byb3h5KCkpIHtcbiAgICBlbnN1cmVXb3JrZXIoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZW5xdWV1ZUNhbGxiYWNrcygnZW5kLXByb2ZpbGluZycsIFtyZXNvbHZlLCByZWplY3RdKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2U6IE9ydFdhc21NZXNzYWdlID0ge3R5cGU6ICdlbmQtcHJvZmlsaW5nJywgaW4gOiBzZXNzaW9uSWR9O1xuICAgICAgcHJveHlXb3JrZXIhLnBvc3RNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvcmUuZW5kUHJvZmlsaW5nKHNlc3Npb25JZCk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7SW5mZXJlbmNlU2Vzc2lvbiwgSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIsIFNlc3Npb25IYW5kbGVyLCBUZW5zb3IsIFRSQUNFX0ZVTkNfQkVHSU4sIFRSQUNFX0ZVTkNfRU5EfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQge1NlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyLCBUZW5zb3JNZXRhZGF0YX0gZnJvbSAnLi9wcm94eS1tZXNzYWdlcyc7XG5pbXBvcnQge2NvcHlGcm9tRXh0ZXJuYWxCdWZmZXIsIGNyZWF0ZVNlc3Npb24sIGVuZFByb2ZpbGluZywgcmVsZWFzZVNlc3Npb24sIHJ1bn0gZnJvbSAnLi9wcm94eS13cmFwcGVyJztcbmltcG9ydCB7aXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlfSBmcm9tICcuL3dhc20tY29tbW9uJztcbmltcG9ydCB7aXNOb2RlfSBmcm9tICcuL3dhc20tdXRpbHMtZW52JztcbmltcG9ydCB7bG9hZEZpbGV9IGZyb20gJy4vd2FzbS11dGlscy1sb2FkLWZpbGUnO1xuXG5leHBvcnQgY29uc3QgZW5jb2RlVGVuc29yTWV0YWRhdGEgPSAodGVuc29yOiBUZW5zb3IsIGdldE5hbWU6ICgpID0+IHN0cmluZyk6IFRlbnNvck1ldGFkYXRhID0+IHtcbiAgc3dpdGNoICh0ZW5zb3IubG9jYXRpb24pIHtcbiAgICBjYXNlICdjcHUnOlxuICAgICAgcmV0dXJuIFt0ZW5zb3IudHlwZSwgdGVuc29yLmRpbXMsIHRlbnNvci5kYXRhLCAnY3B1J107XG4gICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XG4gICAgICByZXR1cm4gW3RlbnNvci50eXBlLCB0ZW5zb3IuZGltcywge2dwdUJ1ZmZlcjogdGVuc29yLmdwdUJ1ZmZlcn0sICdncHUtYnVmZmVyJ107XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkYXRhIGxvY2F0aW9uOiAke3RlbnNvci5sb2NhdGlvbn0gZm9yICR7Z2V0TmFtZSgpfWApO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZGVjb2RlVGVuc29yTWV0YWRhdGEgPSAodGVuc29yOiBUZW5zb3JNZXRhZGF0YSk6IFRlbnNvciA9PiB7XG4gIHN3aXRjaCAodGVuc29yWzNdKSB7XG4gICAgY2FzZSAnY3B1JzpcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKHRlbnNvclswXSwgdGVuc29yWzJdLCB0ZW5zb3JbMV0pO1xuICAgIGNhc2UgJ2dwdS1idWZmZXInOiB7XG4gICAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclswXTtcbiAgICAgIGlmICghaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlKGRhdGFUeXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2RhdGFUeXBlfSBmb3IgZGVzZXJpYWxpemluZyBHUFUgdGVuc29yYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7Z3B1QnVmZmVyLCBkb3dubG9hZCwgZGlzcG9zZX0gPSB0ZW5zb3JbMl07XG4gICAgICByZXR1cm4gVGVuc29yLmZyb21HcHVCdWZmZXIoZ3B1QnVmZmVyLCB7ZGF0YVR5cGUsIGRpbXM6IHRlbnNvclsxXSwgZG93bmxvYWQsIGRpc3Bvc2V9KTtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkYXRhIGxvY2F0aW9uOiAke3RlbnNvclszXX1gKTtcbiAgfVxufTtcblxuZXhwb3J0IGNsYXNzIE9ubnhydW50aW1lV2ViQXNzZW1ibHlTZXNzaW9uSGFuZGxlciBpbXBsZW1lbnRzIEluZmVyZW5jZVNlc3Npb25IYW5kbGVyIHtcbiAgcHJpdmF0ZSBzZXNzaW9uSWQ6IG51bWJlcjtcblxuICBpbnB1dE5hbWVzOiBzdHJpbmdbXTtcbiAgb3V0cHV0TmFtZXM6IHN0cmluZ1tdO1xuXG4gIGFzeW5jIGZldGNoTW9kZWxBbmRDb3B5VG9XYXNtTWVtb3J5KHBhdGg6IHN0cmluZyk6IFByb21pc2U8U2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXI+IHtcbiAgICAvLyBmZXRjaCBtb2RlbCBmcm9tIHVybCBhbmQgbW92ZSB0byB3YXNtIGhlYXAuXG4gICAgcmV0dXJuIGNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIoYXdhaXQgbG9hZEZpbGUocGF0aCkpO1xuICB9XG5cbiAgYXN5bmMgbG9hZE1vZGVsKHBhdGhPckJ1ZmZlcjogc3RyaW5nfFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgVFJBQ0VfRlVOQ19CRUdJTigpO1xuICAgIGxldCBtb2RlbDogUGFyYW1ldGVyczx0eXBlb2YgY3JlYXRlU2Vzc2lvbj5bMF07XG5cbiAgICBpZiAodHlwZW9mIHBhdGhPckJ1ZmZlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgLy8gbm9kZVxuICAgICAgICBtb2RlbCA9IGF3YWl0IGxvYWRGaWxlKHBhdGhPckJ1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBicm93c2VyXG4gICAgICAgIC8vIGZldGNoIG1vZGVsIGFuZCBjb3B5IHRvIHdhc20gaGVhcC5cbiAgICAgICAgbW9kZWwgPSBhd2FpdCB0aGlzLmZldGNoTW9kZWxBbmRDb3B5VG9XYXNtTWVtb3J5KHBhdGhPckJ1ZmZlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGVsID0gcGF0aE9yQnVmZmVyO1xuICAgIH1cblxuICAgIFt0aGlzLnNlc3Npb25JZCwgdGhpcy5pbnB1dE5hbWVzLCB0aGlzLm91dHB1dE5hbWVzXSA9IGF3YWl0IGNyZWF0ZVNlc3Npb24obW9kZWwsIG9wdGlvbnMpO1xuICAgIFRSQUNFX0ZVTkNfRU5EKCk7XG4gIH1cblxuICBhc3luYyBkaXNwb3NlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiByZWxlYXNlU2Vzc2lvbih0aGlzLnNlc3Npb25JZCk7XG4gIH1cblxuICBhc3luYyBydW4oZmVlZHM6IFNlc3Npb25IYW5kbGVyLkZlZWRzVHlwZSwgZmV0Y2hlczogU2Vzc2lvbkhhbmRsZXIuRmV0Y2hlc1R5cGUsIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyk6XG4gICAgICBQcm9taXNlPFNlc3Npb25IYW5kbGVyLlJldHVyblR5cGU+IHtcbiAgICBUUkFDRV9GVU5DX0JFR0lOKCk7XG4gICAgY29uc3QgaW5wdXRBcnJheTogVGVuc29yW10gPSBbXTtcbiAgICBjb25zdCBpbnB1dEluZGljZXM6IG51bWJlcltdID0gW107XG4gICAgT2JqZWN0LmVudHJpZXMoZmVlZHMpLmZvckVhY2goa3ZwID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSBrdnBbMF07XG4gICAgICBjb25zdCB0ZW5zb3IgPSBrdnBbMV07XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5wdXROYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5wdXQgJyR7bmFtZX0nYCk7XG4gICAgICB9XG4gICAgICBpbnB1dEFycmF5LnB1c2godGVuc29yKTtcbiAgICAgIGlucHV0SW5kaWNlcy5wdXNoKGluZGV4KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IG91dHB1dEFycmF5OiBBcnJheTxUZW5zb3J8bnVsbD4gPSBbXTtcbiAgICBjb25zdCBvdXRwdXRJbmRpY2VzOiBudW1iZXJbXSA9IFtdO1xuICAgIE9iamVjdC5lbnRyaWVzKGZldGNoZXMpLmZvckVhY2goa3ZwID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSBrdnBbMF07XG4gICAgICBjb25zdCB0ZW5zb3IgPSBrdnBbMV07XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMub3V0cHV0TmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG91dHB1dCAnJHtuYW1lfSdgKTtcbiAgICAgIH1cbiAgICAgIG91dHB1dEFycmF5LnB1c2godGVuc29yKTtcbiAgICAgIG91dHB1dEluZGljZXMucHVzaChpbmRleCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBpbnB1dHMgPVxuICAgICAgICBpbnB1dEFycmF5Lm1hcCgodCwgaSkgPT4gZW5jb2RlVGVuc29yTWV0YWRhdGEodCwgKCkgPT4gYGlucHV0IFwiJHt0aGlzLmlucHV0TmFtZXNbaW5wdXRJbmRpY2VzW2ldXX1cImApKTtcbiAgICBjb25zdCBvdXRwdXRzID0gb3V0cHV0QXJyYXkubWFwKFxuICAgICAgICAodCwgaSkgPT4gdCA/IGVuY29kZVRlbnNvck1ldGFkYXRhKHQsICgpID0+IGBvdXRwdXQgXCIke3RoaXMub3V0cHV0TmFtZXNbb3V0cHV0SW5kaWNlc1tpXV19XCJgKSA6IG51bGwpO1xuXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHJ1bih0aGlzLnNlc3Npb25JZCwgaW5wdXRJbmRpY2VzLCBpbnB1dHMsIG91dHB1dEluZGljZXMsIG91dHB1dHMsIG9wdGlvbnMpO1xuXG4gICAgY29uc3QgcmVzdWx0TWFwOiBTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRNYXBbdGhpcy5vdXRwdXROYW1lc1tvdXRwdXRJbmRpY2VzW2ldXV0gPSBvdXRwdXRBcnJheVtpXSA/PyBkZWNvZGVUZW5zb3JNZXRhZGF0YShyZXN1bHRzW2ldKTtcbiAgICB9XG4gICAgVFJBQ0VfRlVOQ19FTkQoKTtcbiAgICByZXR1cm4gcmVzdWx0TWFwO1xuICB9XG5cbiAgc3RhcnRQcm9maWxpbmcoKTogdm9pZCB7XG4gICAgLy8gVE9ETzogaW1wbGVtZW50IHByb2ZpbGluZ1xuICB9XG5cbiAgZW5kUHJvZmlsaW5nKCk6IHZvaWQge1xuICAgIHZvaWQgZW5kUHJvZmlsaW5nKHRoaXMuc2Vzc2lvbklkKTtcbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge0JhY2tlbmQsIGVudiwgSW5mZXJlbmNlU2Vzc2lvbiwgSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXJ9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7aW5pdGlhbGl6ZU9ydEVwLCBpbml0aWFsaXplV2ViQXNzZW1ibHlBbmRPcnRSdW50aW1lfSBmcm9tICcuL3dhc20vcHJveHktd3JhcHBlcic7XG5pbXBvcnQge09ubnhydW50aW1lV2ViQXNzZW1ibHlTZXNzaW9uSGFuZGxlcn0gZnJvbSAnLi93YXNtL3Nlc3Npb24taGFuZGxlci1pbmZlcmVuY2UnO1xuaW1wb3J0IHtzY3JpcHRTcmN9IGZyb20gJy4vd2FzbS93YXNtLXV0aWxzLWltcG9ydCc7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpbml0aWFsaXplcyBhbGwgZmxhZ3MgZm9yIFdlYkFzc2VtYmx5LlxuICpcbiAqIFRob3NlIGZsYWdzIGFyZSBhY2Nlc3NpYmxlIGZyb20gYG9ydC5lbnYud2FzbWAuIFVzZXJzIGFyZSBhbGxvdyB0byBzZXQgdGhvc2UgZmxhZ3MgYmVmb3JlIHRoZSBmaXJzdCBpbmZlcmVuY2Ugc2Vzc2lvblxuICogYmVpbmcgY3JlYXRlZCwgdG8gb3ZlcnJpZGUgZGVmYXVsdCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRpYWxpemVGbGFncyA9ICgpOiB2b2lkID0+IHtcbiAgaWYgKHR5cGVvZiBlbnYud2FzbS5pbml0VGltZW91dCAhPT0gJ251bWJlcicgfHwgZW52Lndhc20uaW5pdFRpbWVvdXQgPCAwKSB7XG4gICAgZW52Lndhc20uaW5pdFRpbWVvdXQgPSAwO1xuICB9XG5cbiAgaWYgKGVudi53YXNtLnNpbWQgPT09IGZhbHNlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdEZXByZWNhdGVkIHByb3BlcnR5IFwiZW52Lndhc20uc2ltZFwiIGlzIHNldCB0byBmYWxzZS4gJyArXG4gICAgICAgICdub24tU0lNRCBidWlsZCBpcyBubyBsb25nZXIgcHJvdmlkZWQsIGFuZCB0aGlzIHNldHRpbmcgd2lsbCBiZSBpZ25vcmVkLicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbnYud2FzbS5wcm94eSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgZW52Lndhc20ucHJveHkgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW52Lndhc20udHJhY2UgIT09ICdib29sZWFuJykge1xuICAgIGVudi53YXNtLnRyYWNlID0gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGVudi53YXNtLm51bVRocmVhZHMgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKGVudi53YXNtLm51bVRocmVhZHMpIHx8IGVudi53YXNtLm51bVRocmVhZHMgPD0gMCkge1xuICAgIC8vIFRoZSBmb2xsb3dpbmcgbG9naWMgb25seSBhcHBsaWVzIHdoZW4gYG9ydC5lbnYud2FzbS5udW1UaHJlYWRzYCBpcyBub3Qgc2V0IGJ5IHVzZXIuIFdlIHdpbGwgYWx3YXlzIGhvbm9yIHVzZXInc1xuICAgIC8vIHNldHRpbmcgaWYgaXQgaXMgcHJvdmlkZWQuXG5cbiAgICAvLyBCcm93c2VyOiB3aGVuIGNyb3NzT3JpZ2luSXNvbGF0ZWQgaXMgZmFsc2UsIFNoYXJlZEFycmF5QnVmZmVyIGlzIG5vdCBhdmFpbGFibGUgc28gV2ViQXNzZW1ibHkgdGhyZWFkcyB3aWxsIG5vdFxuICAgIC8vIHdvcmsuIEluIHRoaXMgY2FzZSwgd2Ugd2lsbCBzZXQgbnVtVGhyZWFkcyB0byAxLlxuICAgIC8vXG4gICAgLy8gVGhlcmUgaXMgYW4gZXhjZXB0aW9uOiB3aGVuIHRoZSBicm93c2VyIGlzIGNvbmZpZ3VyZWQgdG8gZm9yY2UtZW5hYmxlIFNoYXJlZEFycmF5QnVmZmVyIChlLmcuIENocm9tdWltIHdpdGhcbiAgICAvLyAtLWVuYWJsZS1mZWF0dXJlcz1TaGFyZWRBcnJheUJ1ZmZlciksIGl0IGlzIHBvc3NpYmxlIHRoYXQgYHNlbGYuY3Jvc3NPcmlnaW5Jc29sYXRlZGAgaXMgZmFsc2UgYW5kXG4gICAgLy8gU2hhcmVkQXJyYXlCdWZmZXIgaXMgYXZhaWxhYmxlIGF0IHRoZSBzYW1lIHRpbWUuIFRoaXMgaXMgdXN1YWxseSBmb3IgdGVzdGluZy4gSW4gdGhpcyBjYXNlLCAgd2Ugd2lsbCBzdGlsbCBzZXRcbiAgICAvLyBudW1UaHJlYWRzIHRvIDEgaGVyZS4gSWYgd2Ugd2FudCB0byBlbmFibGUgbXVsdGktdGhyZWFkaW5nIGluIHRlc3QsIHdlIHNob3VsZCBzZXQgYG9ydC5lbnYud2FzbS5udW1UaHJlYWRzYCB0byBhXG4gICAgLy8gdmFsdWUgZ3JlYXRlciB0aGFuIDEuXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAhc2VsZi5jcm9zc09yaWdpbklzb2xhdGVkKSB7XG4gICAgICBlbnYud2FzbS5udW1UaHJlYWRzID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbnVtQ3B1TG9naWNhbENvcmVzID1cbiAgICAgICAgICB0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyA/IHJlcXVpcmUoJ25vZGU6b3MnKS5jcHVzKCkubGVuZ3RoIDogbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7XG4gICAgICBlbnYud2FzbS5udW1UaHJlYWRzID0gTWF0aC5taW4oNCwgTWF0aC5jZWlsKChudW1DcHVMb2dpY2FsQ29yZXMgfHwgMSkgLyAyKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gb3ZlcndyaXRlIHdhc20gcGF0aHMgb3ZlcnJpZGUgaWYgbm90IHNldFxuICBpZiAoZW52Lndhc20ud2FzbVBhdGhzID09PSB1bmRlZmluZWQgJiYgc2NyaXB0U3JjICYmIHNjcmlwdFNyYy5pbmRleE9mKCdibG9iOicpICE9PSAwKSB7XG4gICAgZW52Lndhc20ud2FzbVBhdGhzID0gc2NyaXB0U3JjLnN1YnN0cmluZygwLCBzY3JpcHRTcmMubGFzdEluZGV4T2YoJy8nKSArIDEpO1xuICB9XG59O1xuXG5leHBvcnQgY2xhc3MgT25ueHJ1bnRpbWVXZWJBc3NlbWJseUJhY2tlbmQgaW1wbGVtZW50cyBCYWNrZW5kIHtcbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaW5pdGlhbGl6ZXMgdGhlIFdlYkFzc2VtYmx5IGJhY2tlbmQuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgb25seSBvbmNlIGZvciBlYWNoIGJhY2tlbmQgbmFtZS4gSXQgd2lsbCBiZSBjYWxsZWQgdGhlIGZpcnN0IHRpbWUgd2hlblxuICAgKiBgb3J0LkluZmVyZW5jZVNlc3Npb24uY3JlYXRlKClgIGlzIGNhbGxlZCB3aXRoIGEgcmVnaXN0ZXJlZCBiYWNrZW5kIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSBiYWNrZW5kTmFtZSAtIHRoZSByZWdpc3RlcmVkIGJhY2tlbmQgbmFtZS5cbiAgICovXG4gIGFzeW5jIGluaXQoYmFja2VuZE5hbWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIHBvcHVsYXRlIHdhc20gZmxhZ3NcbiAgICBpbml0aWFsaXplRmxhZ3MoKTtcblxuICAgIC8vIGluaXQgd2FzbVxuICAgIGF3YWl0IGluaXRpYWxpemVXZWJBc3NlbWJseUFuZE9ydFJ1bnRpbWUoKTtcblxuICAgIC8vIHBlcmZvcm1lIEVQIHNwZWNpZmljIGluaXRpYWxpemF0aW9uXG4gICAgYXdhaXQgaW5pdGlhbGl6ZU9ydEVwKGJhY2tlbmROYW1lKTtcbiAgfVxuICBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcihwYXRoOiBzdHJpbmcsIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTpcbiAgICAgIFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXI+O1xuICBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcihidWZmZXI6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTpcbiAgICAgIFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXI+O1xuICBhc3luYyBjcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcihwYXRoT3JCdWZmZXI6IHN0cmluZ3xVaW50OEFycmF5LCBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6XG4gICAgICBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25IYW5kbGVyPiB7XG4gICAgY29uc3QgaGFuZGxlciA9IG5ldyBPbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXIoKTtcbiAgICBhd2FpdCBoYW5kbGVyLmxvYWRNb2RlbChwYXRoT3JCdWZmZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaGFuZGxlcik7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtPbm54cnVudGltZVdlYkFzc2VtYmx5QmFja2VuZH0gZnJvbSAnLi9iYWNrZW5kLXdhc20nO1xuZXhwb3J0IGNvbnN0IHdhc21CYWNrZW5kID0gbmV3IE9ubnhydW50aW1lV2ViQXNzZW1ibHlCYWNrZW5kKCk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXMsIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMgKi9cblxuLy8gV2UgdXNlIFwicmVxdWlyZVwiIGluc3RlYWQgb2YgXCJpbXBvcnRcIiBoZXJlIGJlY2F1c2UgaW1wb3J0IHN0YXRlbWVudCBtdXN0IGJlIHB1dCBpbiB0b3AgbGV2ZWwuIE91ciBjdXJyZW50IGNvZGUgZG9lc1xuLy8gbm90IGFsbG93IGJ1bmRsZXIgdG8gdHJlZS1zaGFraW5nIGNvZGUgYXMgZXhwZWN0ZWQgYmVjYXVzZSBzb21lIGNvZGVzIGFyZSB0cmVhdGVkIGFzIGhhdmluZyBzaWRlIGVmZmVjdHMuXG4vLyBTbyB3ZSBpbXBvcnQgY29kZSBpbnNpZGUgdGhlIGlmLWNsYXVzZSB0byBhbGxvdyBidW5kbGVyIHJlbW92ZSB0aGUgY29kZSBzYWZlbHkuXG5cbmV4cG9ydCAqIGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5pbXBvcnQgKiBhcyBvcnQgZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcbmV4cG9ydCBkZWZhdWx0IG9ydDtcblxuaW1wb3J0IHtyZWdpc3RlckJhY2tlbmQsIGVudn0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcbmltcG9ydCB7dmVyc2lvbn0gZnJvbSAnLi92ZXJzaW9uJztcblxuaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0VCR0wpIHtcbiAgY29uc3Qgb25ueGpzQmFja2VuZCA9IHJlcXVpcmUoJy4vYmFja2VuZC1vbm54anMnKS5vbm54anNCYWNrZW5kO1xuICByZWdpc3RlckJhY2tlbmQoJ3dlYmdsJywgb25ueGpzQmFja2VuZCwgLTEwKTtcbn1cblxuaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTSkge1xuICBjb25zdCB3YXNtQmFja2VuZCA9IEJVSUxEX0RFRlMuRElTQUJMRV9UUkFJTklORyA/IHJlcXVpcmUoJy4vYmFja2VuZC13YXNtLWluZmVyZW5jZScpLndhc21CYWNrZW5kIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2JhY2tlbmQtd2FzbS10cmFpbmluZycpLndhc21CYWNrZW5kO1xuICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQKSB7XG4gICAgcmVnaXN0ZXJCYWNrZW5kKCd3ZWJncHUnLCB3YXNtQmFja2VuZCwgNSk7XG4gICAgcmVnaXN0ZXJCYWNrZW5kKCd3ZWJubicsIHdhc21CYWNrZW5kLCA1KTtcbiAgfVxuICByZWdpc3RlckJhY2tlbmQoJ2NwdScsIHdhc21CYWNrZW5kLCAxMCk7XG4gIHJlZ2lzdGVyQmFja2VuZCgnd2FzbScsIHdhc21CYWNrZW5kLCAxMCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbnYudmVyc2lvbnMsICd3ZWInLCB7dmFsdWU6IHZlcnNpb24sIGVudW1lcmFibGU6IHRydWV9KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSAvanMvc2NyaXB0cy91cGRhdGUtdmVyc2lvbi50c1xuLy8gRG8gbm90IG1vZGlmeSBmaWxlIGNvbnRlbnQgbWFudWFsbHkuXG5cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzEuMTkuMCc7XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7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QW9DLGNBQ3BDLEtBQW1DO0FBQ3JGLE1BQUksTUFBMEI7QUFDNUIsb0JBQWdCLFVBQVVBLGNBQWEsQ0FBQztBQUN4QyxvQkFBZ0IsU0FBU0EsY0FBYSxDQUFDO0FBQUEsRUFDekM7QUFDQSxrQkFBZ0IsT0FBT0EsY0FBYSxFQUFFO0FBQ3RDLGtCQUFnQixRQUFRQSxjQUFhLEVBQUU7QUFDekM7QUFFQSxPQUFPLGVBQWVDLEtBQUksVUFBVSxPQUFPLEVBQUMsT0FBT0MsVUFBUyxZQUFZLEtBQUksQ0FBQzsiLAogICJuYW1lcyI6IFsiaSIsICJlbnYiLCAiVGVuc29yIiwgIlRlbnNvciIsICJJbmZlcmVuY2VTZXNzaW9uIiwgIlRlbnNvciIsICJUcmFpbmluZ1Nlc3Npb24iLCAiSW5mZXJlbmNlU2Vzc2lvbiIsICJUZW5zb3IiLCAiVHJhaW5pbmdTZXNzaW9uIiwgImVudiIsICJlbnYiLCAid2FzbSIsICJ3YXNtIiwgIndhc20iLCAibG9jYXRpb24iLCAicGFkIiwgImluaXQiLCAib2Zmc2V0cyIsICJpbmRpY2VzIiwgImltcGwiLCAidmFsaWRhdGVJbnB1dHMiLCAicmVkdWNlT3BzIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgImVudiIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJhIiwgImIiLCAidmFsaWRhdGVJbnB1dHMiLCAiaSIsICJ0cmFuc3Bvc2UiLCAib3V0cHV0VmFyaWFibGUiLCAiaW5uZXJFbGVtZW50U2l6ZSIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJvdXRwdXRTaGFwZSIsICJ0cmFuc3Bvc2VkV2VpZ2h0IiwgImNvbnZJbnB1dHMiLCAiaW5uZXJFbGVtZW50U2l6ZSIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJwZXJtRnVuY3Rpb25Cb2R5IiwgInN5bWJvbCIsICJyZWR1Y2VPcHMiLCAidmFsaWRhdGVJbnB1dHMiLCAiY2FsY3VsYXRlT3V0cHV0U2hhcGUiLCAiZmFzdEdlbHUiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAid2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlIiwgInZhbGlkYXRlSW5wdXRzIiwgImdldE91dHB1dFNoYXBlIiwgInZhbGlkYXRlSW5wdXRzIiwgImNyZWF0ZUNvbmNhdFByb2dyYW1JbmZvIiwgIndlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZSIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJkYXRhVHlwZSIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJlbnYiLCAiZW52IiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgImNvbXBvbmVudHMiLCAidmFsaWRhdGVJbnB1dHMiLCAiYSIsICJiIiwgImMiLCAiZmFzdEdlbHUiLCAiZW52IiwgImkiLCAiZW52IiwgImVudiIsICJ3YXNtIiwgImxvY2F0aW9uIiwgInRlbnNvciIsICJlcnJvckNvZGUiLCAiaSIsICJpbml0aWFsaXppbmciLCAiaW5pdGlhbGl6ZWQiLCAiYWJvcnRlZCIsICJjb3B5RnJvbUV4dGVybmFsQnVmZmVyIiwgImNyZWF0ZVNlc3Npb24iLCAicmVsZWFzZVNlc3Npb24iLCAicnVuIiwgImVuZFByb2ZpbGluZyIsICJlbnYiLCAiVGVuc29yIiwgImNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIiLCAiY3JlYXRlU2Vzc2lvbiIsICJyZWxlYXNlU2Vzc2lvbiIsICJydW4iLCAiZW5kUHJvZmlsaW5nIiwgImVudiIsICJ2ZXJzaW9uIiwgIndhc21CYWNrZW5kIiwgImVudiIsICJ2ZXJzaW9uIl0KfQo=
