/*!
 * ONNX Runtime Web v1.20.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
"use strict";
var ort = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // common/dist/esm/backend-impl.js
  var backends, backendsSortedByPriority, registerBackend, tryResolveAndInitializeBackend, resolveBackendAndExecutionProviders;
  var init_backend_impl = __esm({
    "common/dist/esm/backend-impl.js"() {
      "use strict";
      backends = /* @__PURE__ */ new Map();
      backendsSortedByPriority = [];
      registerBackend = (name, backend, priority) => {
        if (backend && typeof backend.init === "function" && typeof backend.createInferenceSessionHandler === "function") {
          const currentBackend = backends.get(name);
          if (currentBackend === void 0) {
            backends.set(name, { backend, priority });
          } else if (currentBackend.priority > priority) {
            return;
          } else if (currentBackend.priority === priority) {
            if (currentBackend.backend !== backend) {
              throw new Error(`cannot register backend "${name}" using priority ${priority}`);
            }
          }
          if (priority >= 0) {
            const i = backendsSortedByPriority.indexOf(name);
            if (i !== -1) {
              backendsSortedByPriority.splice(i, 1);
            }
            for (let i2 = 0; i2 < backendsSortedByPriority.length; i2++) {
              if (backends.get(backendsSortedByPriority[i2]).priority <= priority) {
                backendsSortedByPriority.splice(i2, 0, name);
                return;
              }
            }
            backendsSortedByPriority.push(name);
          }
          return;
        }
        throw new TypeError("not a valid backend");
      };
      tryResolveAndInitializeBackend = async (backendName) => {
        const backendInfo = backends.get(backendName);
        if (!backendInfo) {
          return "backend not found.";
        }
        if (backendInfo.initialized) {
          return backendInfo.backend;
        } else if (backendInfo.aborted) {
          return backendInfo.error;
        } else {
          const isInitializing = !!backendInfo.initPromise;
          try {
            if (!isInitializing) {
              backendInfo.initPromise = backendInfo.backend.init(backendName);
            }
            await backendInfo.initPromise;
            backendInfo.initialized = true;
            return backendInfo.backend;
          } catch (e) {
            if (!isInitializing) {
              backendInfo.error = `${e}`;
              backendInfo.aborted = true;
            }
            return backendInfo.error;
          } finally {
            delete backendInfo.initPromise;
          }
        }
      };
      resolveBackendAndExecutionProviders = async (options) => {
        const eps = options.executionProviders || [];
        const backendHints = eps.map((i) => typeof i === "string" ? i : i.name);
        const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;
        let backend;
        const errors = [];
        const availableBackendNames = /* @__PURE__ */ new Set();
        for (const backendName of backendNames) {
          const resolveResult = await tryResolveAndInitializeBackend(backendName);
          if (typeof resolveResult === "string") {
            errors.push({ name: backendName, err: resolveResult });
          } else {
            if (!backend) {
              backend = resolveResult;
            }
            if (backend === resolveResult) {
              availableBackendNames.add(backendName);
            }
          }
        }
        if (!backend) {
          throw new Error(`no available backend found. ERR: ${errors.map((e) => `[${e.name}] ${e.err}`).join(", ")}`);
        }
        for (const { name, err } of errors) {
          if (backendHints.includes(name)) {
            console.warn(`removing requested execution provider "${name}" from session options because it is not available: ${err}`);
          }
        }
        const filteredEps = eps.filter((i) => availableBackendNames.has(typeof i === "string" ? i : i.name));
        return [
          backend,
          new Proxy(options, {
            get: (target, prop) => {
              if (prop === "executionProviders") {
                return filteredEps;
              }
              return Reflect.get(target, prop);
            }
          })
        ];
      };
    }
  });

  // common/dist/esm/backend.js
  var init_backend = __esm({
    "common/dist/esm/backend.js"() {
      "use strict";
      init_backend_impl();
    }
  });

  // common/dist/esm/version.js
  var version;
  var init_version = __esm({
    "common/dist/esm/version.js"() {
      "use strict";
      version = "1.20.0";
    }
  });

  // common/dist/esm/env-impl.js
  var logLevelValue, env;
  var init_env_impl = __esm({
    "common/dist/esm/env-impl.js"() {
      "use strict";
      init_version();
      logLevelValue = "warning";
      env = {
        wasm: {},
        webgl: {},
        webgpu: {},
        versions: { common: version },
        set logLevel(value) {
          if (value === void 0) {
            return;
          }
          if (typeof value !== "string" || ["verbose", "info", "warning", "error", "fatal"].indexOf(value) === -1) {
            throw new Error(`Unsupported logging level: ${value}`);
          }
          logLevelValue = value;
        },
        get logLevel() {
          return logLevelValue;
        }
      };
      Object.defineProperty(env, "logLevel", { enumerable: true });
    }
  });

  // common/dist/esm/env.js
  var env2;
  var init_env = __esm({
    "common/dist/esm/env.js"() {
      "use strict";
      init_env_impl();
      env2 = env;
    }
  });

  // common/dist/esm/tensor-conversion-impl.js
  var tensorToDataURL, tensorToImageData;
  var init_tensor_conversion_impl = __esm({
    "common/dist/esm/tensor-conversion-impl.js"() {
      "use strict";
      tensorToDataURL = (tensor, options) => {
        const canvas = typeof document !== "undefined" ? document.createElement("canvas") : new OffscreenCanvas(1, 1);
        canvas.width = tensor.dims[3];
        canvas.height = tensor.dims[2];
        const pixels2DContext = canvas.getContext("2d");
        if (pixels2DContext != null) {
          let width;
          let height;
          if (options?.tensorLayout !== void 0 && options.tensorLayout === "NHWC") {
            width = tensor.dims[2];
            height = tensor.dims[3];
          } else {
            width = tensor.dims[3];
            height = tensor.dims[2];
          }
          const inputformat = options?.format !== void 0 ? options.format : "RGB";
          const norm = options?.norm;
          let normMean;
          let normBias;
          if (norm === void 0 || norm.mean === void 0) {
            normMean = [255, 255, 255, 255];
          } else {
            if (typeof norm.mean === "number") {
              normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
            } else {
              normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 0];
              if (norm.mean[3] !== void 0) {
                normMean[3] = norm.mean[3];
              }
            }
          }
          if (norm === void 0 || norm.bias === void 0) {
            normBias = [0, 0, 0, 0];
          } else {
            if (typeof norm.bias === "number") {
              normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
            } else {
              normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
              if (norm.bias[3] !== void 0) {
                normBias[3] = norm.bias[3];
              }
            }
          }
          const stride = height * width;
          let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
          if (inputformat === "RGBA") {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
            aTensorPointer = stride * 3;
          } else if (inputformat === "RGB") {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
          } else if (inputformat === "RBG") {
            rTensorPointer = 0;
            bTensorPointer = stride;
            gTensorPointer = stride * 2;
          }
          for (let i = 0; i < height; i++) {
            for (let j = 0; j < width; j++) {
              const R = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
              const G = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
              const B = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
              const A = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
              pixels2DContext.fillStyle = "rgba(" + R + "," + G + "," + B + "," + A + ")";
              pixels2DContext.fillRect(j, i, 1, 1);
            }
          }
          if ("toDataURL" in canvas) {
            return canvas.toDataURL();
          } else {
            throw new Error("toDataURL is not supported");
          }
        } else {
          throw new Error("Can not access image data");
        }
      };
      tensorToImageData = (tensor, options) => {
        const pixels2DContext = typeof document !== "undefined" ? document.createElement("canvas").getContext("2d") : new OffscreenCanvas(1, 1).getContext("2d");
        let image;
        if (pixels2DContext != null) {
          let width;
          let height;
          let channels;
          if (options?.tensorLayout !== void 0 && options.tensorLayout === "NHWC") {
            width = tensor.dims[2];
            height = tensor.dims[1];
            channels = tensor.dims[3];
          } else {
            width = tensor.dims[3];
            height = tensor.dims[2];
            channels = tensor.dims[1];
          }
          const inputformat = options !== void 0 ? options.format !== void 0 ? options.format : "RGB" : "RGB";
          const norm = options?.norm;
          let normMean;
          let normBias;
          if (norm === void 0 || norm.mean === void 0) {
            normMean = [255, 255, 255, 255];
          } else {
            if (typeof norm.mean === "number") {
              normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
            } else {
              normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 255];
              if (norm.mean[3] !== void 0) {
                normMean[3] = norm.mean[3];
              }
            }
          }
          if (norm === void 0 || norm.bias === void 0) {
            normBias = [0, 0, 0, 0];
          } else {
            if (typeof norm.bias === "number") {
              normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
            } else {
              normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];
              if (norm.bias[3] !== void 0) {
                normBias[3] = norm.bias[3];
              }
            }
          }
          const stride = height * width;
          if (options !== void 0) {
            if (options.format !== void 0 && channels === 4 && options.format !== "RGBA" || channels === 3 && options.format !== "RGB" && options.format !== "BGR") {
              throw new Error("Tensor format doesn't match input tensor dims");
            }
          }
          const step = 4;
          let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
          let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
          if (inputformat === "RGBA") {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
            aTensorPointer = stride * 3;
          } else if (inputformat === "RGB") {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
          } else if (inputformat === "RBG") {
            rTensorPointer = 0;
            bTensorPointer = stride;
            gTensorPointer = stride * 2;
          }
          image = pixels2DContext.createImageData(width, height);
          for (let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++) {
            image.data[rImagePointer] = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0];
            image.data[gImagePointer] = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1];
            image.data[bImagePointer] = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2];
            image.data[aImagePointer] = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3];
          }
        } else {
          throw new Error("Can not access image data");
        }
        return image;
      };
    }
  });

  // common/dist/esm/tensor-factory-impl.js
  var bufferToTensor, tensorFromImage, tensorFromTexture, tensorFromGpuBuffer, tensorFromPinnedBuffer;
  var init_tensor_factory_impl = __esm({
    "common/dist/esm/tensor-factory-impl.js"() {
      "use strict";
      init_tensor_impl();
      bufferToTensor = (buffer, options) => {
        if (buffer === void 0) {
          throw new Error("Image buffer must be defined");
        }
        if (options.height === void 0 || options.width === void 0) {
          throw new Error("Image height and width must be defined");
        }
        if (options.tensorLayout === "NHWC") {
          throw new Error("NHWC Tensor layout is not supported yet");
        }
        const { height, width } = options;
        const norm = options.norm ?? { mean: 255, bias: 0 };
        let normMean;
        let normBias;
        if (typeof norm.mean === "number") {
          normMean = [norm.mean, norm.mean, norm.mean, norm.mean];
        } else {
          normMean = [norm.mean[0], norm.mean[1], norm.mean[2], norm.mean[3] ?? 255];
        }
        if (typeof norm.bias === "number") {
          normBias = [norm.bias, norm.bias, norm.bias, norm.bias];
        } else {
          normBias = [norm.bias[0], norm.bias[1], norm.bias[2], norm.bias[3] ?? 0];
        }
        const inputformat = options.format !== void 0 ? options.format : "RGBA";
        const outputformat = options.tensorFormat !== void 0 ? options.tensorFormat !== void 0 ? options.tensorFormat : "RGB" : "RGB";
        const stride = height * width;
        const float32Data = outputformat === "RGBA" ? new Float32Array(stride * 4) : new Float32Array(stride * 3);
        let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
        if (inputformat === "RGB") {
          step = 3;
          rImagePointer = 0;
          gImagePointer = 1;
          bImagePointer = 2;
          aImagePointer = -1;
        }
        if (outputformat === "RGBA") {
          aTensorPointer = stride * 3;
        } else if (outputformat === "RBG") {
          rTensorPointer = 0;
          bTensorPointer = stride;
          gTensorPointer = stride * 2;
        } else if (outputformat === "BGR") {
          bTensorPointer = 0;
          gTensorPointer = stride;
          rTensorPointer = stride * 2;
        }
        for (let i = 0; i < stride; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step) {
          float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias[0]) / normMean[0];
          float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias[1]) / normMean[1];
          float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias[2]) / normMean[2];
          if (aTensorPointer !== -1 && aImagePointer !== -1) {
            float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias[3]) / normMean[3];
          }
        }
        const outputTensor = outputformat === "RGBA" ? new Tensor("float32", float32Data, [1, 4, height, width]) : new Tensor("float32", float32Data, [1, 3, height, width]);
        return outputTensor;
      };
      tensorFromImage = async (image, options) => {
        const isHTMLImageEle = typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement;
        const isImageDataEle = typeof ImageData !== "undefined" && image instanceof ImageData;
        const isImageBitmap = typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap;
        const isString = typeof image === "string";
        let data;
        let bufferToTensorOptions = options ?? {};
        const createCanvas = () => {
          if (typeof document !== "undefined") {
            return document.createElement("canvas");
          } else if (typeof OffscreenCanvas !== "undefined") {
            return new OffscreenCanvas(1, 1);
          } else {
            throw new Error("Canvas is not supported");
          }
        };
        const createCanvasContext = (canvas) => {
          if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
            return canvas.getContext("2d");
          } else if (canvas instanceof OffscreenCanvas) {
            return canvas.getContext("2d");
          } else {
            return null;
          }
        };
        if (isHTMLImageEle) {
          const canvas = createCanvas();
          canvas.width = image.width;
          canvas.height = image.height;
          const pixels2DContext = createCanvasContext(canvas);
          if (pixels2DContext != null) {
            let height = image.height;
            let width = image.width;
            if (options !== void 0 && options.resizedHeight !== void 0 && options.resizedWidth !== void 0) {
              height = options.resizedHeight;
              width = options.resizedWidth;
            }
            if (options !== void 0) {
              bufferToTensorOptions = options;
              if (options.tensorFormat !== void 0) {
                throw new Error("Image input config format must be RGBA for HTMLImageElement");
              } else {
                bufferToTensorOptions.tensorFormat = "RGBA";
              }
              bufferToTensorOptions.height = height;
              bufferToTensorOptions.width = width;
            } else {
              bufferToTensorOptions.tensorFormat = "RGBA";
              bufferToTensorOptions.height = height;
              bufferToTensorOptions.width = width;
            }
            pixels2DContext.drawImage(image, 0, 0);
            data = pixels2DContext.getImageData(0, 0, width, height).data;
          } else {
            throw new Error("Can not access image data");
          }
        } else if (isImageDataEle) {
          let height;
          let width;
          if (options !== void 0 && options.resizedWidth !== void 0 && options.resizedHeight !== void 0) {
            height = options.resizedHeight;
            width = options.resizedWidth;
          } else {
            height = image.height;
            width = image.width;
          }
          if (options !== void 0) {
            bufferToTensorOptions = options;
          }
          bufferToTensorOptions.format = "RGBA";
          bufferToTensorOptions.height = height;
          bufferToTensorOptions.width = width;
          if (options !== void 0) {
            const tempCanvas = createCanvas();
            tempCanvas.width = width;
            tempCanvas.height = height;
            const pixels2DContext = createCanvasContext(tempCanvas);
            if (pixels2DContext != null) {
              pixels2DContext.putImageData(image, 0, 0);
              data = pixels2DContext.getImageData(0, 0, width, height).data;
            } else {
              throw new Error("Can not access image data");
            }
          } else {
            data = image.data;
          }
        } else if (isImageBitmap) {
          if (options === void 0) {
            throw new Error("Please provide image config with format for Imagebitmap");
          }
          const canvas = createCanvas();
          canvas.width = image.width;
          canvas.height = image.height;
          const pixels2DContext = createCanvasContext(canvas);
          if (pixels2DContext != null) {
            const height = image.height;
            const width = image.width;
            pixels2DContext.drawImage(image, 0, 0, width, height);
            data = pixels2DContext.getImageData(0, 0, width, height).data;
            bufferToTensorOptions.height = height;
            bufferToTensorOptions.width = width;
            return bufferToTensor(data, bufferToTensorOptions);
          } else {
            throw new Error("Can not access image data");
          }
        } else if (isString) {
          return new Promise((resolve, reject) => {
            const canvas = createCanvas();
            const context = createCanvasContext(canvas);
            if (!image || !context) {
              return reject();
            }
            const newImage = new Image();
            newImage.crossOrigin = "Anonymous";
            newImage.src = image;
            newImage.onload = () => {
              canvas.width = newImage.width;
              canvas.height = newImage.height;
              context.drawImage(newImage, 0, 0, canvas.width, canvas.height);
              const img = context.getImageData(0, 0, canvas.width, canvas.height);
              bufferToTensorOptions.height = canvas.height;
              bufferToTensorOptions.width = canvas.width;
              resolve(bufferToTensor(img.data, bufferToTensorOptions));
            };
          });
        } else {
          throw new Error("Input data provided is not supported - aborted tensor creation");
        }
        if (data !== void 0) {
          return bufferToTensor(data, bufferToTensorOptions);
        } else {
          throw new Error("Input data provided is not supported - aborted tensor creation");
        }
      };
      tensorFromTexture = (texture, options) => {
        const { width, height, download, dispose } = options;
        const dims = [1, height, width, 4];
        return new Tensor({ location: "texture", type: "float32", texture, dims, download, dispose });
      };
      tensorFromGpuBuffer = (gpuBuffer, options) => {
        const { dataType, dims, download, dispose } = options;
        return new Tensor({ location: "gpu-buffer", type: dataType ?? "float32", gpuBuffer, dims, download, dispose });
      };
      tensorFromPinnedBuffer = (type, buffer, dims) => new Tensor({ location: "cpu-pinned", type, data: buffer, dims: dims ?? [buffer.length] });
    }
  });

  // common/dist/esm/tensor-impl-type-mapping.js
  var NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP, NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP, isTypedArrayChecked, checkTypedArray;
  var init_tensor_impl_type_mapping = __esm({
    "common/dist/esm/tensor-impl-type-mapping.js"() {
      "use strict";
      NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = /* @__PURE__ */ new Map([
        ["float32", Float32Array],
        ["uint8", Uint8Array],
        ["int8", Int8Array],
        ["uint16", Uint16Array],
        ["int16", Int16Array],
        ["int32", Int32Array],
        ["bool", Uint8Array],
        ["float64", Float64Array],
        ["uint32", Uint32Array],
        ["int4", Uint8Array],
        ["uint4", Uint8Array]
      ]);
      NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = /* @__PURE__ */ new Map([
        [Float32Array, "float32"],
        [Uint8Array, "uint8"],
        [Int8Array, "int8"],
        [Uint16Array, "uint16"],
        [Int16Array, "int16"],
        [Int32Array, "int32"],
        [Float64Array, "float64"],
        [Uint32Array, "uint32"]
      ]);
      isTypedArrayChecked = false;
      checkTypedArray = () => {
        if (!isTypedArrayChecked) {
          isTypedArrayChecked = true;
          const isBigInt64ArrayAvailable = typeof BigInt64Array !== "undefined" && BigInt64Array.from;
          const isBigUint64ArrayAvailable = typeof BigUint64Array !== "undefined" && BigUint64Array.from;
          const isFloat16ArrayAvailable = typeof Float16Array !== "undefined" && Float16Array.from;
          if (isBigInt64ArrayAvailable) {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64", BigInt64Array);
            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, "int64");
          }
          if (isBigUint64ArrayAvailable) {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64", BigUint64Array);
            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, "uint64");
          }
          if (isFloat16ArrayAvailable) {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Float16Array);
            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(Float16Array, "float16");
          } else {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16", Uint16Array);
          }
        }
      };
    }
  });

  // common/dist/esm/tensor-utils-impl.js
  var calculateSize, tensorReshape;
  var init_tensor_utils_impl = __esm({
    "common/dist/esm/tensor-utils-impl.js"() {
      "use strict";
      init_tensor_impl();
      calculateSize = (dims) => {
        let size = 1;
        for (let i = 0; i < dims.length; i++) {
          const dim = dims[i];
          if (typeof dim !== "number" || !Number.isSafeInteger(dim)) {
            throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);
          }
          if (dim < 0) {
            throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);
          }
          size *= dim;
        }
        return size;
      };
      tensorReshape = (tensor, dims) => {
        switch (tensor.location) {
          case "cpu":
            return new Tensor(tensor.type, tensor.data, dims);
          case "cpu-pinned":
            return new Tensor({
              location: "cpu-pinned",
              data: tensor.data,
              type: tensor.type,
              dims
            });
          case "texture":
            return new Tensor({
              location: "texture",
              texture: tensor.texture,
              type: tensor.type,
              dims
            });
          case "gpu-buffer":
            return new Tensor({
              location: "gpu-buffer",
              gpuBuffer: tensor.gpuBuffer,
              type: tensor.type,
              dims
            });
          default:
            throw new Error(`tensorReshape: tensor location ${tensor.location} is not supported`);
        }
      };
    }
  });

  // common/dist/esm/tensor-impl.js
  var Tensor;
  var init_tensor_impl = __esm({
    "common/dist/esm/tensor-impl.js"() {
      "use strict";
      init_tensor_conversion_impl();
      init_tensor_factory_impl();
      init_tensor_impl_type_mapping();
      init_tensor_utils_impl();
      Tensor = class {
        /**
         * implementation.
         */
        constructor(arg0, arg1, arg2) {
          checkTypedArray();
          let type;
          let dims;
          if (typeof arg0 === "object" && "location" in arg0) {
            this.dataLocation = arg0.location;
            type = arg0.type;
            dims = arg0.dims;
            switch (arg0.location) {
              case "cpu-pinned": {
                const expectedTypedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(type);
                if (!expectedTypedArrayConstructor) {
                  throw new TypeError(`unsupported type "${type}" to create tensor from pinned buffer`);
                }
                if (!(arg0.data instanceof expectedTypedArrayConstructor)) {
                  throw new TypeError(`buffer should be of type ${expectedTypedArrayConstructor.name}`);
                }
                this.cpuData = arg0.data;
                break;
              }
              case "texture": {
                if (type !== "float32") {
                  throw new TypeError(`unsupported type "${type}" to create tensor from texture`);
                }
                this.gpuTextureData = arg0.texture;
                this.downloader = arg0.download;
                this.disposer = arg0.dispose;
                break;
              }
              case "gpu-buffer": {
                if (type !== "float32" && type !== "float16" && type !== "int32" && type !== "int64" && type !== "uint32" && type !== "uint8" && type !== "bool" && type !== "uint4" && type !== "int4") {
                  throw new TypeError(`unsupported type "${type}" to create tensor from gpu buffer`);
                }
                this.gpuBufferData = arg0.gpuBuffer;
                this.downloader = arg0.download;
                this.disposer = arg0.dispose;
                break;
              }
              default:
                throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`);
            }
          } else {
            let data;
            let maybeDims;
            if (typeof arg0 === "string") {
              type = arg0;
              maybeDims = arg2;
              if (arg0 === "string") {
                if (!Array.isArray(arg1)) {
                  throw new TypeError("A string tensor's data must be a string array.");
                }
                data = arg1;
              } else {
                const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);
                if (typedArrayConstructor === void 0) {
                  throw new TypeError(`Unsupported tensor type: ${arg0}.`);
                }
                if (Array.isArray(arg1)) {
                  if (arg0 === "float16" && typedArrayConstructor === Uint16Array || arg0 === "uint4" || arg0 === "int4") {
                    throw new TypeError(`Creating a ${arg0} tensor from number array is not supported. Please use ${typedArrayConstructor.name} as data.`);
                  } else if (arg0 === "uint64" || arg0 === "int64") {
                    data = typedArrayConstructor.from(arg1, BigInt);
                  } else {
                    data = typedArrayConstructor.from(arg1);
                  }
                } else if (arg1 instanceof typedArrayConstructor) {
                  data = arg1;
                } else if (arg1 instanceof Uint8ClampedArray) {
                  if (arg0 === "uint8") {
                    data = Uint8Array.from(arg1);
                  } else {
                    throw new TypeError(`A Uint8ClampedArray tensor's data must be type of uint8`);
                  }
                } else {
                  throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);
                }
              }
            } else {
              maybeDims = arg1;
              if (Array.isArray(arg0)) {
                if (arg0.length === 0) {
                  throw new TypeError("Tensor type cannot be inferred from an empty array.");
                }
                const firstElementType = typeof arg0[0];
                if (firstElementType === "string") {
                  type = "string";
                  data = arg0;
                } else if (firstElementType === "boolean") {
                  type = "bool";
                  data = Uint8Array.from(arg0);
                } else {
                  throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);
                }
              } else if (arg0 instanceof Uint8ClampedArray) {
                type = "uint8";
                data = Uint8Array.from(arg0);
              } else {
                const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);
                if (mappedType === void 0) {
                  throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);
                }
                type = mappedType;
                data = arg0;
              }
            }
            if (maybeDims === void 0) {
              maybeDims = [data.length];
            } else if (!Array.isArray(maybeDims)) {
              throw new TypeError("A tensor's dims must be a number array");
            }
            dims = maybeDims;
            this.cpuData = data;
            this.dataLocation = "cpu";
          }
          const size = calculateSize(dims);
          if (this.cpuData && size !== this.cpuData.length) {
            if ((type === "uint4" || type === "int4") && Math.ceil(size / 2) === this.cpuData.length) {
            } else {
              throw new Error(`Tensor's size(${size}) does not match data length(${this.cpuData.length}).`);
            }
          }
          this.type = type;
          this.dims = dims;
          this.size = size;
        }
        // #endregion
        // #region factory
        static async fromImage(image, options) {
          return tensorFromImage(image, options);
        }
        static fromTexture(texture, options) {
          return tensorFromTexture(texture, options);
        }
        static fromGpuBuffer(gpuBuffer, options) {
          return tensorFromGpuBuffer(gpuBuffer, options);
        }
        static fromPinnedBuffer(type, buffer, dims) {
          return tensorFromPinnedBuffer(type, buffer, dims);
        }
        // #endregion
        // #region conversions
        toDataURL(options) {
          return tensorToDataURL(this, options);
        }
        toImageData(options) {
          return tensorToImageData(this, options);
        }
        // #endregion
        // #region properties
        get data() {
          this.ensureValid();
          if (!this.cpuData) {
            throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");
          }
          return this.cpuData;
        }
        get location() {
          return this.dataLocation;
        }
        get texture() {
          this.ensureValid();
          if (!this.gpuTextureData) {
            throw new Error("The data is not stored as a WebGL texture.");
          }
          return this.gpuTextureData;
        }
        get gpuBuffer() {
          this.ensureValid();
          if (!this.gpuBufferData) {
            throw new Error("The data is not stored as a WebGPU buffer.");
          }
          return this.gpuBufferData;
        }
        // #endregion
        // #region methods
        async getData(releaseData) {
          this.ensureValid();
          switch (this.dataLocation) {
            case "cpu":
            case "cpu-pinned":
              return this.data;
            case "texture":
            case "gpu-buffer": {
              if (!this.downloader) {
                throw new Error("The current tensor is not created with a specified data downloader.");
              }
              if (this.isDownloading) {
                throw new Error("The current tensor is being downloaded.");
              }
              try {
                this.isDownloading = true;
                const data = await this.downloader();
                this.downloader = void 0;
                this.dataLocation = "cpu";
                this.cpuData = data;
                if (releaseData && this.disposer) {
                  this.disposer();
                  this.disposer = void 0;
                }
                return data;
              } finally {
                this.isDownloading = false;
              }
            }
            default:
              throw new Error(`cannot get data from location: ${this.dataLocation}`);
          }
        }
        dispose() {
          if (this.isDownloading) {
            throw new Error("The current tensor is being downloaded.");
          }
          if (this.disposer) {
            this.disposer();
            this.disposer = void 0;
          }
          this.cpuData = void 0;
          this.gpuTextureData = void 0;
          this.gpuBufferData = void 0;
          this.downloader = void 0;
          this.isDownloading = void 0;
          this.dataLocation = "none";
        }
        // #endregion
        // #region tensor utilities
        ensureValid() {
          if (this.dataLocation === "none") {
            throw new Error("The tensor is disposed.");
          }
        }
        reshape(dims) {
          this.ensureValid();
          if (this.downloader || this.disposer) {
            throw new Error("Cannot reshape a tensor that owns GPU resource.");
          }
          return tensorReshape(this, dims);
        }
      };
    }
  });

  // common/dist/esm/tensor.js
  var Tensor2;
  var init_tensor = __esm({
    "common/dist/esm/tensor.js"() {
      "use strict";
      init_tensor_impl();
      Tensor2 = Tensor;
    }
  });

  // common/dist/esm/trace.js
  var TRACE, TRACE_FUNC, TRACE_FUNC_BEGIN, TRACE_FUNC_END;
  var init_trace = __esm({
    "common/dist/esm/trace.js"() {
      "use strict";
      init_env_impl();
      TRACE = (deviceType, label) => {
        if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
          return;
        }
        console.timeStamp(`${deviceType}::ORT::${label}`);
      };
      TRACE_FUNC = (msg, extraMsg) => {
        const stack = new Error().stack?.split(/\r\n|\r|\n/g) || [];
        let hasTraceFunc = false;
        for (let i = 0; i < stack.length; i++) {
          if (hasTraceFunc && !stack[i].includes("TRACE_FUNC")) {
            let label = `FUNC_${msg}::${stack[i].trim().split(" ")[1]}`;
            if (extraMsg) {
              label += `::${extraMsg}`;
            }
            TRACE("CPU", label);
            return;
          }
          if (stack[i].includes("TRACE_FUNC")) {
            hasTraceFunc = true;
          }
        }
      };
      TRACE_FUNC_BEGIN = (extraMsg) => {
        if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
          return;
        }
        TRACE_FUNC("BEGIN", extraMsg);
      };
      TRACE_FUNC_END = (extraMsg) => {
        if (typeof env.trace === "undefined" ? !env.wasm.trace : !env.trace) {
          return;
        }
        TRACE_FUNC("END", extraMsg);
      };
    }
  });

  // common/dist/esm/inference-session-impl.js
  var InferenceSession;
  var init_inference_session_impl = __esm({
    "common/dist/esm/inference-session-impl.js"() {
      "use strict";
      init_backend_impl();
      init_tensor();
      init_trace();
      InferenceSession = class _InferenceSession {
        constructor(handler) {
          this.handler = handler;
        }
        async run(feeds, arg1, arg2) {
          TRACE_FUNC_BEGIN();
          const fetches = {};
          let options = {};
          if (typeof feeds !== "object" || feeds === null || feeds instanceof Tensor2 || Array.isArray(feeds)) {
            throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
          }
          let isFetchesEmpty = true;
          if (typeof arg1 === "object") {
            if (arg1 === null) {
              throw new TypeError("Unexpected argument[1]: cannot be null.");
            }
            if (arg1 instanceof Tensor2) {
              throw new TypeError("'fetches' cannot be a Tensor");
            }
            if (Array.isArray(arg1)) {
              if (arg1.length === 0) {
                throw new TypeError("'fetches' cannot be an empty array.");
              }
              isFetchesEmpty = false;
              for (const name of arg1) {
                if (typeof name !== "string") {
                  throw new TypeError("'fetches' must be a string array or an object.");
                }
                if (this.outputNames.indexOf(name) === -1) {
                  throw new RangeError(`'fetches' contains invalid output name: ${name}.`);
                }
                fetches[name] = null;
              }
              if (typeof arg2 === "object" && arg2 !== null) {
                options = arg2;
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else {
              let isFetches = false;
              const arg1Keys = Object.getOwnPropertyNames(arg1);
              for (const name of this.outputNames) {
                if (arg1Keys.indexOf(name) !== -1) {
                  const v = arg1[name];
                  if (v === null || v instanceof Tensor2) {
                    isFetches = true;
                    isFetchesEmpty = false;
                    fetches[name] = v;
                  }
                }
              }
              if (isFetches) {
                if (typeof arg2 === "object" && arg2 !== null) {
                  options = arg2;
                } else if (typeof arg2 !== "undefined") {
                  throw new TypeError("'options' must be an object.");
                }
              } else {
                options = arg1;
              }
            }
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
          }
          for (const name of this.inputNames) {
            if (typeof feeds[name] === "undefined") {
              throw new Error(`input '${name}' is missing in 'feeds'.`);
            }
          }
          if (isFetchesEmpty) {
            for (const name of this.outputNames) {
              fetches[name] = null;
            }
          }
          const results = await this.handler.run(feeds, fetches, options);
          const returnValue = {};
          for (const key in results) {
            if (Object.hasOwnProperty.call(results, key)) {
              const result = results[key];
              if (result instanceof Tensor2) {
                returnValue[key] = result;
              } else {
                returnValue[key] = new Tensor2(result.type, result.data, result.dims);
              }
            }
          }
          TRACE_FUNC_END();
          return returnValue;
        }
        async release() {
          return this.handler.dispose();
        }
        static async create(arg0, arg1, arg2, arg3) {
          TRACE_FUNC_BEGIN();
          let filePathOrUint8Array;
          let options = {};
          if (typeof arg0 === "string") {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === "object" && arg1 !== null) {
              options = arg1;
            } else if (typeof arg1 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
          } else if (arg0 instanceof Uint8Array) {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === "object" && arg1 !== null) {
              options = arg1;
            } else if (typeof arg1 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
          } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && arg0 instanceof SharedArrayBuffer) {
            const buffer = arg0;
            let byteOffset = 0;
            let byteLength = arg0.byteLength;
            if (typeof arg1 === "object" && arg1 !== null) {
              options = arg1;
            } else if (typeof arg1 === "number") {
              byteOffset = arg1;
              if (!Number.isSafeInteger(byteOffset)) {
                throw new RangeError("'byteOffset' must be an integer.");
              }
              if (byteOffset < 0 || byteOffset >= buffer.byteLength) {
                throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);
              }
              byteLength = arg0.byteLength - byteOffset;
              if (typeof arg2 === "number") {
                byteLength = arg2;
                if (!Number.isSafeInteger(byteLength)) {
                  throw new RangeError("'byteLength' must be an integer.");
                }
                if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {
                  throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);
                }
                if (typeof arg3 === "object" && arg3 !== null) {
                  options = arg3;
                } else if (typeof arg3 !== "undefined") {
                  throw new TypeError("'options' must be an object.");
                }
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'byteLength' must be a number.");
              }
            } else if (typeof arg1 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
            filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);
          } else {
            throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
          }
          const [backend, optionsWithValidatedEPs] = await resolveBackendAndExecutionProviders(options);
          const handler = await backend.createInferenceSessionHandler(filePathOrUint8Array, optionsWithValidatedEPs);
          TRACE_FUNC_END();
          return new _InferenceSession(handler);
        }
        startProfiling() {
          this.handler.startProfiling();
        }
        endProfiling() {
          this.handler.endProfiling();
        }
        get inputNames() {
          return this.handler.inputNames;
        }
        get outputNames() {
          return this.handler.outputNames;
        }
      };
    }
  });

  // common/dist/esm/inference-session.js
  var InferenceSession2;
  var init_inference_session = __esm({
    "common/dist/esm/inference-session.js"() {
      "use strict";
      init_inference_session_impl();
      InferenceSession2 = InferenceSession;
    }
  });

  // common/dist/esm/tensor-conversion.js
  var init_tensor_conversion = __esm({
    "common/dist/esm/tensor-conversion.js"() {
      "use strict";
    }
  });

  // common/dist/esm/tensor-factory.js
  var init_tensor_factory = __esm({
    "common/dist/esm/tensor-factory.js"() {
      "use strict";
    }
  });

  // common/dist/esm/onnx-model.js
  var init_onnx_model = __esm({
    "common/dist/esm/onnx-model.js"() {
      "use strict";
    }
  });

  // common/dist/esm/onnx-value.js
  var init_onnx_value = __esm({
    "common/dist/esm/onnx-value.js"() {
      "use strict";
    }
  });

  // common/dist/esm/training-session-impl.js
  var noBackendErrMsg, TrainingSession;
  var init_training_session_impl = __esm({
    "common/dist/esm/training-session-impl.js"() {
      "use strict";
      init_backend_impl();
      init_tensor();
      noBackendErrMsg = "Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.";
      TrainingSession = class _TrainingSession {
        constructor(handler, hasOptimizerModel, hasEvalModel) {
          this.handler = handler;
          this.hasOptimizerModel = hasOptimizerModel;
          this.hasEvalModel = hasEvalModel;
        }
        get trainingInputNames() {
          return this.handler.inputNames;
        }
        get trainingOutputNames() {
          return this.handler.outputNames;
        }
        get evalInputNames() {
          if (this.hasEvalModel) {
            return this.handler.evalInputNames;
          } else {
            throw new Error("This training session has no evalModel loaded.");
          }
        }
        get evalOutputNames() {
          if (this.hasEvalModel) {
            return this.handler.evalOutputNames;
          } else {
            throw new Error("This training session has no evalModel loaded.");
          }
        }
        static async create(trainingOptions, sessionOptions) {
          const evalModel = trainingOptions.evalModel || "";
          const optimizerModel = trainingOptions.optimizerModel || "";
          const options = sessionOptions || {};
          const [backend, optionsWithValidatedEPs] = await resolveBackendAndExecutionProviders(options);
          if (backend.createTrainingSessionHandler) {
            const handler = await backend.createTrainingSessionHandler(trainingOptions.checkpointState, trainingOptions.trainModel, evalModel, optimizerModel, optionsWithValidatedEPs);
            return new _TrainingSession(handler, !!trainingOptions.optimizerModel, !!trainingOptions.evalModel);
          } else {
            throw new Error(noBackendErrMsg);
          }
        }
        /**
         * Helper function for runTrainStep and future runStep methods that handles the type-narrowing conversion from
         * the given parameters to SessionHandler.FetchesType and RunOptions.
         *
         * @param inputNames the feeds object is checked that they contain all input names in the provided list of input
         * names.
         * @param outputNames the fetches object is checked that their keys match up with valid names in the list of output
         * names.
         * @param feeds the required input
         * @param arg1 narrowed & converted into the SessionHandler.FetchesType or RunOptions object
         * @param arg2 optional RunOptions object.
         * @returns
         */
        typeNarrowingForRunStep(inputNames, outputNames, feeds, arg1, arg2) {
          const fetches = {};
          let options = {};
          if (typeof feeds !== "object" || feeds === null || feeds instanceof Tensor2 || Array.isArray(feeds)) {
            throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
          }
          let isFetchesEmpty = true;
          if (typeof arg1 === "object") {
            if (arg1 === null) {
              throw new TypeError("Unexpected argument[1]: cannot be null.");
            }
            if (arg1 instanceof Tensor2) {
              throw new TypeError("'fetches' cannot be a Tensor");
            }
            if (Array.isArray(arg1)) {
              if (arg1.length === 0) {
                throw new TypeError("'fetches' cannot be an empty array.");
              }
              isFetchesEmpty = false;
              for (const name of arg1) {
                if (typeof name !== "string") {
                  throw new TypeError("'fetches' must be a string array or an object.");
                }
                if (outputNames.indexOf(name) === -1) {
                  throw new RangeError(`'fetches' contains invalid output name: ${name}.`);
                }
                fetches[name] = null;
              }
              if (typeof arg2 === "object" && arg2 !== null) {
                options = arg2;
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else {
              let isFetches = false;
              const arg1Keys = Object.getOwnPropertyNames(arg1);
              for (const name of outputNames) {
                if (arg1Keys.indexOf(name) !== -1) {
                  const v = arg1[name];
                  if (v === null || v instanceof Tensor2) {
                    isFetches = true;
                    isFetchesEmpty = false;
                    fetches[name] = v;
                  }
                }
              }
              if (isFetches) {
                if (typeof arg2 === "object" && arg2 !== null) {
                  options = arg2;
                } else if (typeof arg2 !== "undefined") {
                  throw new TypeError("'options' must be an object.");
                }
              } else {
                options = arg1;
              }
            }
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
          }
          for (const name of inputNames) {
            if (typeof feeds[name] === "undefined") {
              throw new Error(`input '${name}' is missing in 'feeds'.`);
            }
          }
          if (isFetchesEmpty) {
            for (const name of outputNames) {
              fetches[name] = null;
            }
          }
          return [fetches, options];
        }
        /**
         * Helper method for runTrainStep and any other runStep methods. Takes the ReturnType result from the SessionHandler
         * and changes it into a map of Tensors.
         *
         * @param results
         * @returns
         */
        convertHandlerReturnTypeToMapOfTensors(results) {
          const returnValue = {};
          for (const key in results) {
            if (Object.hasOwnProperty.call(results, key)) {
              const result = results[key];
              if (result instanceof Tensor2) {
                returnValue[key] = result;
              } else {
                returnValue[key] = new Tensor2(result.type, result.data, result.dims);
              }
            }
          }
          return returnValue;
        }
        async lazyResetGrad() {
          await this.handler.lazyResetGrad();
        }
        async runTrainStep(feeds, arg1, arg2) {
          const [fetches, options] = this.typeNarrowingForRunStep(this.trainingInputNames, this.trainingOutputNames, feeds, arg1, arg2);
          const results = await this.handler.runTrainStep(feeds, fetches, options);
          return this.convertHandlerReturnTypeToMapOfTensors(results);
        }
        async runOptimizerStep(options) {
          if (this.hasOptimizerModel) {
            await this.handler.runOptimizerStep(options || {});
          } else {
            throw new Error("This TrainingSession has no OptimizerModel loaded.");
          }
        }
        async runEvalStep(feeds, arg1, arg2) {
          if (this.hasEvalModel) {
            const [fetches, options] = this.typeNarrowingForRunStep(this.evalInputNames, this.evalOutputNames, feeds, arg1, arg2);
            const results = await this.handler.runEvalStep(feeds, fetches, options);
            return this.convertHandlerReturnTypeToMapOfTensors(results);
          } else {
            throw new Error("This TrainingSession has no EvalModel loaded.");
          }
        }
        async getParametersSize(trainableOnly = true) {
          return this.handler.getParametersSize(trainableOnly);
        }
        async loadParametersBuffer(array, trainableOnly = true) {
          const paramsSize = await this.getParametersSize(trainableOnly);
          if (array.length !== 4 * paramsSize) {
            throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");
          }
          return this.handler.loadParametersBuffer(array, trainableOnly);
        }
        async getContiguousParameters(trainableOnly = true) {
          return this.handler.getContiguousParameters(trainableOnly);
        }
        async release() {
          return this.handler.dispose();
        }
      };
    }
  });

  // common/dist/esm/training-session.js
  var TrainingSession2;
  var init_training_session = __esm({
    "common/dist/esm/training-session.js"() {
      "use strict";
      init_training_session_impl();
      TrainingSession2 = TrainingSession;
    }
  });

  // common/dist/esm/index.js
  var esm_exports = {};
  __export(esm_exports, {
    InferenceSession: () => InferenceSession2,
    TRACE: () => TRACE,
    TRACE_FUNC_BEGIN: () => TRACE_FUNC_BEGIN,
    TRACE_FUNC_END: () => TRACE_FUNC_END,
    Tensor: () => Tensor2,
    TrainingSession: () => TrainingSession2,
    env: () => env2,
    registerBackend: () => registerBackend
  });
  var init_esm = __esm({
    "common/dist/esm/index.js"() {
      "use strict";
      init_backend();
      init_env();
      init_inference_session();
      init_tensor();
      init_tensor_conversion();
      init_tensor_factory();
      init_trace();
      init_onnx_model();
      init_onnx_value();
      init_training_session();
    }
  });

  // web/lib/wasm/wasm-utils-env.ts
  var isNode;
  var init_wasm_utils_env = __esm({
    "web/lib/wasm/wasm-utils-env.ts"() {
      "use strict";
      isNode = false;
    }
  });

  // web/lib/wasm/proxy-worker/main.ts
  var main_exports = {};
  __export(main_exports, {
    default: () => main_default
  });
  var WORKER_NAME, isProxyWorker, main_default;
  var init_main = __esm({
    "web/lib/wasm/proxy-worker/main.ts"() {
      "use strict";
      init_wasm_core_impl();
      init_wasm_factory();
      init_wasm_utils_import();
      WORKER_NAME = "ort-wasm-proxy-worker";
      isProxyWorker = globalThis.self?.name === WORKER_NAME;
      if (isProxyWorker) {
        self.onmessage = (ev) => {
          const { type, in: message } = ev.data;
          try {
            switch (type) {
              case "init-wasm":
                initializeWebAssembly(message.wasm).then(
                  () => {
                    initRuntime(message).then(
                      () => {
                        postMessage({ type });
                      },
                      (err) => {
                        postMessage({ type, err });
                      }
                    );
                  },
                  (err) => {
                    postMessage({ type, err });
                  }
                );
                break;
              case "init-ep": {
                const { epName, env: env3 } = message;
                initEp(env3, epName).then(
                  () => {
                    postMessage({ type });
                  },
                  (err) => {
                    postMessage({ type, err });
                  }
                );
                break;
              }
              case "copy-from": {
                const { buffer } = message;
                const bufferData = copyFromExternalBuffer(buffer);
                postMessage({ type, out: bufferData });
                break;
              }
              case "create": {
                const { model, options } = message;
                createSession(model, options).then(
                  (sessionMetadata) => {
                    postMessage({ type, out: sessionMetadata });
                  },
                  (err) => {
                    postMessage({ type, err });
                  }
                );
                break;
              }
              case "release":
                releaseSession(message);
                postMessage({ type });
                break;
              case "run": {
                const { sessionId, inputIndices, inputs, outputIndices, options } = message;
                run(sessionId, inputIndices, inputs, outputIndices, new Array(outputIndices.length).fill(null), options).then(
                  (outputs) => {
                    if (outputs.some((o) => o[3] !== "cpu")) {
                      postMessage({ type, err: "Proxy does not support non-cpu tensor location." });
                    } else {
                      postMessage(
                        { type, out: outputs },
                        extractTransferableBuffers([...inputs, ...outputs])
                      );
                    }
                  },
                  (err) => {
                    postMessage({ type, err });
                  }
                );
                break;
              }
              case "end-profiling":
                endProfiling(message);
                postMessage({ type });
                break;
              default:
            }
          } catch (err) {
            postMessage({ type, err });
          }
        };
      }
      main_default = isProxyWorker ? null : (urlOverride) => new Worker(urlOverride ?? scriptSrc, { type: false ? "module" : "classic", name: WORKER_NAME });
    }
  });

  // web/lib/wasm/wasm-utils-import.ts
  var scriptSrc, origin, isSameOrigin, normalizeUrl, fallbackUrl, preload, dynamicImportDefault, createProxyWorker, importProxyWorker, embeddedWasmModule, importWasmModule;
  var init_wasm_utils_import = __esm({
    "web/lib/wasm/wasm-utils-import.ts"() {
      "use strict";
      init_wasm_utils_env();
      scriptSrc = // if Nodejs, return undefined
      isNode ? void 0 : (
        // use `document.currentScript.src` if available
        typeof document !== "undefined" ? document.currentScript?.src : (
          // use `self.location.href` if available
          typeof self !== "undefined" ? self.location?.href : void 0
        )
      );
      origin = isNode || typeof location === "undefined" ? void 0 : location.origin;
      isSameOrigin = (filename, prefixOverride) => {
        try {
          const baseUrl = prefixOverride ?? scriptSrc;
          const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);
          return url.origin === origin;
        } catch {
          return false;
        }
      };
      normalizeUrl = (filename, prefixOverride) => {
        const baseUrl = prefixOverride ?? scriptSrc;
        try {
          const url = baseUrl ? new URL(filename, baseUrl) : new URL(filename);
          return url.href;
        } catch {
          return void 0;
        }
      };
      fallbackUrl = (filename, prefixOverride) => `${prefixOverride ?? "./"}${filename}`;
      preload = async (absoluteUrl) => {
        const response = await fetch(absoluteUrl, { credentials: "same-origin" });
        const blob = await response.blob();
        return URL.createObjectURL(blob);
      };
      dynamicImportDefault = async (url) => (await import(
        /* webpackIgnore: true */
        url
      )).default;
      createProxyWorker = // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
      false ? void 0 : (init_main(), __toCommonJS(main_exports)).default;
      importProxyWorker = async () => {
        if (!scriptSrc) {
          throw new Error("Failed to load proxy worker: cannot determine the script source URL.");
        }
        if (isSameOrigin(scriptSrc)) {
          return [void 0, createProxyWorker()];
        }
        const url = await preload(scriptSrc);
        return [url, createProxyWorker(url)];
      };
      embeddedWasmModule = false ? (
        // eslint-disable-next-line @typescript-eslint/no-require-imports, @typescript-eslint/no-var-requires
        (true ? null : null).default
      ) : void 0;
      importWasmModule = async (urlOverride, prefixOverride, isMultiThreaded) => {
        if (false) {
          return [void 0, embeddedWasmModule];
        } else {
          const wasmModuleFilename = true ? "ort-wasm-simd-threaded.jsep.mjs" : "ort-wasm-simd-threaded.mjs";
          const wasmModuleUrl = urlOverride ?? normalizeUrl(wasmModuleFilename, prefixOverride);
          const needPreload = !isNode && isMultiThreaded && wasmModuleUrl && !isSameOrigin(wasmModuleUrl, prefixOverride);
          const url = needPreload ? await preload(wasmModuleUrl) : wasmModuleUrl ?? fallbackUrl(wasmModuleFilename, prefixOverride);
          return [needPreload ? url : void 0, await dynamicImportDefault(url)];
        }
      };
    }
  });

  // web/lib/wasm/wasm-factory.ts
  var wasm, initialized, initializing, aborted, isMultiThreadSupported, isSimdSupported, initializeWebAssembly, getInstance;
  var init_wasm_factory = __esm({
    "web/lib/wasm/wasm-factory.ts"() {
      "use strict";
      init_wasm_utils_import();
      initialized = false;
      initializing = false;
      aborted = false;
      isMultiThreadSupported = () => {
        if (typeof SharedArrayBuffer === "undefined") {
          return false;
        }
        try {
          if (typeof MessageChannel !== "undefined") {
            new MessageChannel().port1.postMessage(new SharedArrayBuffer(1));
          }
          return WebAssembly.validate(
            new Uint8Array([
              0,
              97,
              115,
              109,
              1,
              0,
              0,
              0,
              1,
              4,
              1,
              96,
              0,
              0,
              3,
              2,
              1,
              0,
              5,
              4,
              1,
              3,
              1,
              1,
              10,
              11,
              1,
              9,
              0,
              65,
              0,
              254,
              16,
              2,
              0,
              26,
              11
            ])
          );
        } catch (e) {
          return false;
        }
      };
      isSimdSupported = () => {
        try {
          return WebAssembly.validate(
            new Uint8Array([
              0,
              97,
              115,
              109,
              1,
              0,
              0,
              0,
              1,
              4,
              1,
              96,
              0,
              0,
              3,
              2,
              1,
              0,
              10,
              30,
              1,
              28,
              0,
              65,
              0,
              253,
              15,
              253,
              12,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              253,
              186,
              1,
              26,
              11
            ])
          );
        } catch (e) {
          return false;
        }
      };
      initializeWebAssembly = async (flags) => {
        if (initialized) {
          return Promise.resolve();
        }
        if (initializing) {
          throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
        }
        if (aborted) {
          throw new Error("previous call to 'initializeWebAssembly()' failed.");
        }
        initializing = true;
        const timeout = flags.initTimeout;
        let numThreads = flags.numThreads;
        if (!isSimdSupported()) {
          throw new Error("WebAssembly SIMD is not supported in the current environment.");
        }
        const multiThreadSupported = isMultiThreadSupported();
        if (numThreads > 1 && !multiThreadSupported) {
          if (typeof self !== "undefined" && !self.crossOriginIsolated) {
            console.warn(
              "env.wasm.numThreads is set to " + numThreads + ", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."
            );
          }
          console.warn(
            "WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."
          );
          flags.numThreads = numThreads = 1;
        }
        const wasmPaths = flags.wasmPaths;
        const wasmPrefixOverride = typeof wasmPaths === "string" ? wasmPaths : void 0;
        const mjsPathOverrideFlag = wasmPaths?.mjs;
        const mjsPathOverride = mjsPathOverrideFlag?.href ?? mjsPathOverrideFlag;
        const wasmPathOverrideFlag = wasmPaths?.wasm;
        const wasmPathOverride = wasmPathOverrideFlag?.href ?? wasmPathOverrideFlag;
        const wasmBinaryOverride = flags.wasmBinary;
        const [objectUrl, ortWasmFactory] = await importWasmModule(mjsPathOverride, wasmPrefixOverride, numThreads > 1);
        let isTimeout = false;
        const tasks = [];
        if (timeout > 0) {
          tasks.push(
            new Promise((resolve) => {
              setTimeout(() => {
                isTimeout = true;
                resolve();
              }, timeout);
            })
          );
        }
        tasks.push(
          new Promise((resolve, reject) => {
            const config = {
              /**
               * The number of threads. WebAssembly will create (Module.numThreads - 1) workers. If it is 1, no worker will be
               * created.
               */
              numThreads
            };
            if (wasmBinaryOverride) {
              config.wasmBinary = wasmBinaryOverride;
            } else if (wasmPathOverride || wasmPrefixOverride) {
              config.locateFile = (fileName, scriptDirectory) => wasmPathOverride ?? (wasmPrefixOverride ?? scriptDirectory) + fileName;
            }
            ortWasmFactory(config).then(
              // wasm module initialized successfully
              (module) => {
                initializing = false;
                initialized = true;
                wasm = module;
                resolve();
                if (objectUrl) {
                  URL.revokeObjectURL(objectUrl);
                }
              },
              // wasm module failed to initialize
              (what) => {
                initializing = false;
                aborted = true;
                reject(what);
              }
            );
          })
        );
        await Promise.race(tasks);
        if (isTimeout) {
          throw new Error(`WebAssembly backend initializing failed due to timeout: ${timeout}ms`);
        }
      };
      getInstance = () => {
        if (initialized && wasm) {
          return wasm;
        }
        throw new Error("WebAssembly is not initialized yet.");
      };
    }
  });

  // web/lib/wasm/wasm-utils.ts
  var allocWasmString, iterateExtraOptions, checkLastError;
  var init_wasm_utils = __esm({
    "web/lib/wasm/wasm-utils.ts"() {
      "use strict";
      init_wasm_factory();
      allocWasmString = (data, allocs) => {
        const wasm2 = getInstance();
        const dataLength = wasm2.lengthBytesUTF8(data) + 1;
        const dataOffset = wasm2._malloc(dataLength);
        wasm2.stringToUTF8(data, dataOffset, dataLength);
        allocs.push(dataOffset);
        return dataOffset;
      };
      iterateExtraOptions = (options, prefix, seen, handler) => {
        if (typeof options == "object" && options !== null) {
          if (seen.has(options)) {
            throw new Error("Circular reference in options");
          } else {
            seen.add(options);
          }
        }
        Object.entries(options).forEach(([key, value]) => {
          const name = prefix ? prefix + key : key;
          if (typeof value === "object") {
            iterateExtraOptions(value, name + ".", seen, handler);
          } else if (typeof value === "string" || typeof value === "number") {
            handler(name, value.toString());
          } else if (typeof value === "boolean") {
            handler(name, value ? "1" : "0");
          } else {
            throw new Error(`Can't handle extra config type: ${typeof value}`);
          }
        });
      };
      checkLastError = (message) => {
        const wasm2 = getInstance();
        const stack = wasm2.stackSave();
        try {
          const paramsOffset = wasm2.stackAlloc(8);
          wasm2._OrtGetLastError(paramsOffset, paramsOffset + 4);
          const errorCode = wasm2.HEAP32[paramsOffset / 4];
          const errorMessagePointer = wasm2.HEAPU32[paramsOffset / 4 + 1];
          const errorMessage = errorMessagePointer ? wasm2.UTF8ToString(errorMessagePointer) : "";
          throw new Error(`${message} ERROR_CODE: ${errorCode}, ERROR_MESSAGE: ${errorMessage}`);
        } finally {
          wasm2.stackRestore(stack);
        }
      };
    }
  });

  // web/lib/wasm/run-options.ts
  var setRunOptions;
  var init_run_options = __esm({
    "web/lib/wasm/run-options.ts"() {
      "use strict";
      init_wasm_factory();
      init_wasm_utils();
      setRunOptions = (options) => {
        const wasm2 = getInstance();
        let runOptionsHandle = 0;
        const allocs = [];
        const runOptions = options || {};
        try {
          if (options?.logSeverityLevel === void 0) {
            runOptions.logSeverityLevel = 2;
          } else if (typeof options.logSeverityLevel !== "number" || !Number.isInteger(options.logSeverityLevel) || options.logSeverityLevel < 0 || options.logSeverityLevel > 4) {
            throw new Error(`log serverity level is not valid: ${options.logSeverityLevel}`);
          }
          if (options?.logVerbosityLevel === void 0) {
            runOptions.logVerbosityLevel = 0;
          } else if (typeof options.logVerbosityLevel !== "number" || !Number.isInteger(options.logVerbosityLevel)) {
            throw new Error(`log verbosity level is not valid: ${options.logVerbosityLevel}`);
          }
          if (options?.terminate === void 0) {
            runOptions.terminate = false;
          }
          let tagDataOffset = 0;
          if (options?.tag !== void 0) {
            tagDataOffset = allocWasmString(options.tag, allocs);
          }
          runOptionsHandle = wasm2._OrtCreateRunOptions(
            runOptions.logSeverityLevel,
            runOptions.logVerbosityLevel,
            !!runOptions.terminate,
            tagDataOffset
          );
          if (runOptionsHandle === 0) {
            checkLastError("Can't create run options.");
          }
          if (options?.extra !== void 0) {
            iterateExtraOptions(options.extra, "", /* @__PURE__ */ new WeakSet(), (key, value) => {
              const keyDataOffset = allocWasmString(key, allocs);
              const valueDataOffset = allocWasmString(value, allocs);
              if (wasm2._OrtAddRunConfigEntry(runOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                checkLastError(`Can't set a run config entry: ${key} - ${value}.`);
              }
            });
          }
          return [runOptionsHandle, allocs];
        } catch (e) {
          if (runOptionsHandle !== 0) {
            wasm2._OrtReleaseRunOptions(runOptionsHandle);
          }
          allocs.forEach((alloc) => wasm2._free(alloc));
          throw e;
        }
      };
    }
  });

  // web/lib/wasm/session-options.ts
  var getGraphOptimzationLevel, getExecutionMode, appendDefaultOptions, setExecutionProviders, setSessionOptions;
  var init_session_options = __esm({
    "web/lib/wasm/session-options.ts"() {
      "use strict";
      init_wasm_factory();
      init_wasm_utils();
      getGraphOptimzationLevel = (graphOptimizationLevel) => {
        switch (graphOptimizationLevel) {
          case "disabled":
            return 0;
          case "basic":
            return 1;
          case "extended":
            return 2;
          case "all":
            return 99;
          default:
            throw new Error(`unsupported graph optimization level: ${graphOptimizationLevel}`);
        }
      };
      getExecutionMode = (executionMode) => {
        switch (executionMode) {
          case "sequential":
            return 0;
          case "parallel":
            return 1;
          default:
            throw new Error(`unsupported execution mode: ${executionMode}`);
        }
      };
      appendDefaultOptions = (options) => {
        if (!options.extra) {
          options.extra = {};
        }
        if (!options.extra.session) {
          options.extra.session = {};
        }
        const session = options.extra.session;
        if (!session.use_ort_model_bytes_directly) {
          session.use_ort_model_bytes_directly = "1";
        }
        if (options.executionProviders && options.executionProviders.some((ep) => (typeof ep === "string" ? ep : ep.name) === "webgpu")) {
          options.enableMemPattern = false;
        }
      };
      setExecutionProviders = (sessionOptionsHandle, executionProviders, allocs) => {
        for (const ep of executionProviders) {
          let epName = typeof ep === "string" ? ep : ep.name;
          switch (epName) {
            case "webnn":
              epName = "WEBNN";
              if (typeof ep !== "string") {
                const webnnOptions = ep;
                const deviceType = webnnOptions?.deviceType;
                if (deviceType) {
                  const keyDataOffset = allocWasmString("deviceType", allocs);
                  const valueDataOffset = allocWasmString(deviceType, allocs);
                  if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                    checkLastError(`Can't set a session config entry: 'deviceType' - ${deviceType}.`);
                  }
                }
              }
              break;
            case "webgpu":
              epName = "JS";
              if (typeof ep !== "string") {
                const webgpuOptions = ep;
                if (webgpuOptions?.preferredLayout) {
                  if (webgpuOptions.preferredLayout !== "NCHW" && webgpuOptions.preferredLayout !== "NHWC") {
                    throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${webgpuOptions.preferredLayout}`);
                  }
                  const keyDataOffset = allocWasmString("preferredLayout", allocs);
                  const valueDataOffset = allocWasmString(webgpuOptions.preferredLayout, allocs);
                  if (getInstance()._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                    checkLastError(`Can't set a session config entry: 'preferredLayout' - ${webgpuOptions.preferredLayout}.`);
                  }
                }
              }
              break;
            case "wasm":
            case "cpu":
              continue;
            default:
              throw new Error(`not supported execution provider: ${epName}`);
          }
          const epNameDataOffset = allocWasmString(epName, allocs);
          if (getInstance()._OrtAppendExecutionProvider(sessionOptionsHandle, epNameDataOffset) !== 0) {
            checkLastError(`Can't append execution provider: ${epName}.`);
          }
        }
      };
      setSessionOptions = (options) => {
        const wasm2 = getInstance();
        let sessionOptionsHandle = 0;
        const allocs = [];
        const sessionOptions = options || {};
        appendDefaultOptions(sessionOptions);
        try {
          const graphOptimizationLevel = getGraphOptimzationLevel(sessionOptions.graphOptimizationLevel ?? "all");
          const executionMode = getExecutionMode(sessionOptions.executionMode ?? "sequential");
          const logIdDataOffset = typeof sessionOptions.logId === "string" ? allocWasmString(sessionOptions.logId, allocs) : 0;
          const logSeverityLevel = sessionOptions.logSeverityLevel ?? 2;
          if (!Number.isInteger(logSeverityLevel) || logSeverityLevel < 0 || logSeverityLevel > 4) {
            throw new Error(`log serverity level is not valid: ${logSeverityLevel}`);
          }
          const logVerbosityLevel = sessionOptions.logVerbosityLevel ?? 0;
          if (!Number.isInteger(logVerbosityLevel) || logVerbosityLevel < 0 || logVerbosityLevel > 4) {
            throw new Error(`log verbosity level is not valid: ${logVerbosityLevel}`);
          }
          const optimizedModelFilePathOffset = typeof sessionOptions.optimizedModelFilePath === "string" ? allocWasmString(sessionOptions.optimizedModelFilePath, allocs) : 0;
          sessionOptionsHandle = wasm2._OrtCreateSessionOptions(
            graphOptimizationLevel,
            !!sessionOptions.enableCpuMemArena,
            !!sessionOptions.enableMemPattern,
            executionMode,
            !!sessionOptions.enableProfiling,
            0,
            logIdDataOffset,
            logSeverityLevel,
            logVerbosityLevel,
            optimizedModelFilePathOffset
          );
          if (sessionOptionsHandle === 0) {
            checkLastError("Can't create session options.");
          }
          if (sessionOptions.executionProviders) {
            setExecutionProviders(sessionOptionsHandle, sessionOptions.executionProviders, allocs);
          }
          if (sessionOptions.enableGraphCapture !== void 0) {
            if (typeof sessionOptions.enableGraphCapture !== "boolean") {
              throw new Error(`enableGraphCapture must be a boolean value: ${sessionOptions.enableGraphCapture}`);
            }
            const keyDataOffset = allocWasmString("enableGraphCapture", allocs);
            const valueDataOffset = allocWasmString(sessionOptions.enableGraphCapture.toString(), allocs);
            if (wasm2._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
              checkLastError(
                `Can't set a session config entry: 'enableGraphCapture' - ${sessionOptions.enableGraphCapture}.`
              );
            }
          }
          if (sessionOptions.freeDimensionOverrides) {
            for (const [name, value] of Object.entries(sessionOptions.freeDimensionOverrides)) {
              if (typeof name !== "string") {
                throw new Error(`free dimension override name must be a string: ${name}`);
              }
              if (typeof value !== "number" || !Number.isInteger(value) || value < 0) {
                throw new Error(`free dimension override value must be a non-negative integer: ${value}`);
              }
              const nameOffset = allocWasmString(name, allocs);
              if (wasm2._OrtAddFreeDimensionOverride(sessionOptionsHandle, nameOffset, value) !== 0) {
                checkLastError(`Can't set a free dimension override: ${name} - ${value}.`);
              }
            }
          }
          if (sessionOptions.extra !== void 0) {
            iterateExtraOptions(sessionOptions.extra, "", /* @__PURE__ */ new WeakSet(), (key, value) => {
              const keyDataOffset = allocWasmString(key, allocs);
              const valueDataOffset = allocWasmString(value, allocs);
              if (wasm2._OrtAddSessionConfigEntry(sessionOptionsHandle, keyDataOffset, valueDataOffset) !== 0) {
                checkLastError(`Can't set a session config entry: ${key} - ${value}.`);
              }
            });
          }
          return [sessionOptionsHandle, allocs];
        } catch (e) {
          if (sessionOptionsHandle !== 0) {
            wasm2._OrtReleaseSessionOptions(sessionOptionsHandle);
          }
          allocs.forEach((alloc) => wasm2._free(alloc));
          throw e;
        }
      };
    }
  });

  // web/lib/wasm/wasm-common.ts
  var tensorDataTypeStringToEnum, tensorDataTypeEnumToString, calculateTensorSizeInBytes, tensorTypeToTypedArrayConstructor, logLevelStringToEnum, isGpuBufferSupportedType, dataLocationStringToEnum;
  var init_wasm_common = __esm({
    "web/lib/wasm/wasm-common.ts"() {
      "use strict";
      tensorDataTypeStringToEnum = (type) => {
        switch (type) {
          case "int8":
            return 3 /* int8 */;
          case "uint8":
            return 2 /* uint8 */;
          case "bool":
            return 9 /* bool */;
          case "int16":
            return 5 /* int16 */;
          case "uint16":
            return 4 /* uint16 */;
          case "int32":
            return 6 /* int32 */;
          case "uint32":
            return 12 /* uint32 */;
          case "float16":
            return 10 /* float16 */;
          case "float32":
            return 1 /* float */;
          case "float64":
            return 11 /* double */;
          case "string":
            return 8 /* string */;
          case "int64":
            return 7 /* int64 */;
          case "uint64":
            return 13 /* uint64 */;
          case "int4":
            return 22 /* int4 */;
          case "uint4":
            return 21 /* uint4 */;
          default:
            throw new Error(`unsupported data type: ${type}`);
        }
      };
      tensorDataTypeEnumToString = (typeProto) => {
        switch (typeProto) {
          case 3 /* int8 */:
            return "int8";
          case 2 /* uint8 */:
            return "uint8";
          case 9 /* bool */:
            return "bool";
          case 5 /* int16 */:
            return "int16";
          case 4 /* uint16 */:
            return "uint16";
          case 6 /* int32 */:
            return "int32";
          case 12 /* uint32 */:
            return "uint32";
          case 10 /* float16 */:
            return "float16";
          case 1 /* float */:
            return "float32";
          case 11 /* double */:
            return "float64";
          case 8 /* string */:
            return "string";
          case 7 /* int64 */:
            return "int64";
          case 13 /* uint64 */:
            return "uint64";
          case 22 /* int4 */:
            return "int4";
          case 21 /* uint4 */:
            return "uint4";
          default:
            throw new Error(`unsupported data type: ${typeProto}`);
        }
      };
      calculateTensorSizeInBytes = (dateType, dimsOrSize) => {
        const elementSize = [
          -1,
          // undefined = 0
          4,
          // float = 1
          1,
          // uint8 = 2
          1,
          // int8 = 3
          2,
          // uint16 = 4
          2,
          // int16 = 5
          4,
          // int32 = 6
          8,
          // int64 = 7
          -1,
          // string = 8
          1,
          // bool = 9
          2,
          // float16 = 10
          8,
          // double = 11
          4,
          // uint32 = 12
          8,
          // uint64 = 13
          -1,
          // complex64 = 14
          -1,
          // complex128 = 15
          -1,
          // bfloat16 = 16
          -1,
          // FLOAT8E4M3FN = 17
          -1,
          // FLOAT8E4M3FNUZ = 18
          -1,
          // FLOAT8E5M2 = 19
          -1,
          // FLOAT8E5M2FNUZ = 20
          0.5,
          // uint4 = 21
          0.5
          // int4 = 22
        ][dateType];
        const size = typeof dimsOrSize === "number" ? dimsOrSize : dimsOrSize.reduce((a, b) => a * b, 1);
        return elementSize > 0 ? Math.ceil(size * elementSize) : void 0;
      };
      tensorTypeToTypedArrayConstructor = (type) => {
        switch (type) {
          case "float16":
            return typeof Float16Array !== "undefined" && Float16Array.from ? Float16Array : Uint16Array;
          case "float32":
            return Float32Array;
          case "uint8":
            return Uint8Array;
          case "int8":
            return Int8Array;
          case "uint16":
            return Uint16Array;
          case "int16":
            return Int16Array;
          case "int32":
            return Int32Array;
          case "bool":
            return Uint8Array;
          case "float64":
            return Float64Array;
          case "uint32":
            return Uint32Array;
          case "int64":
            return BigInt64Array;
          case "uint64":
            return BigUint64Array;
          default:
            throw new Error(`unsupported type: ${type}`);
        }
      };
      logLevelStringToEnum = (logLevel) => {
        switch (logLevel) {
          case "verbose":
            return 0;
          case "info":
            return 1;
          case "warning":
            return 2;
          case "error":
            return 3;
          case "fatal":
            return 4;
          default:
            throw new Error(`unsupported logging level: ${logLevel}`);
        }
      };
      isGpuBufferSupportedType = (type) => type === "float32" || type === "float16" || type === "int32" || type === "int64" || type === "uint32" || type === "uint8" || type === "bool" || type === "uint4" || type === "int4";
      dataLocationStringToEnum = (location2) => {
        switch (location2) {
          case "none":
            return 0;
          case "cpu":
            return 1;
          case "cpu-pinned":
            return 2;
          case "texture":
            return 3;
          case "gpu-buffer":
            return 4;
          default:
            throw new Error(`unsupported data location: ${location2}`);
        }
      };
    }
  });

  // web/lib/wasm/wasm-utils-load-file.ts
  var loadFile;
  var init_wasm_utils_load_file = __esm({
    "web/lib/wasm/wasm-utils-load-file.ts"() {
      "use strict";
      init_wasm_utils_env();
      loadFile = async (file) => {
        if (typeof file === "string") {
          if (isNode) {
            try {
              const { readFile } = __require("node:fs/promises");
              return new Uint8Array(await readFile(file));
            } catch (e) {
              if (e.code === "ERR_FS_FILE_TOO_LARGE") {
                const { createReadStream } = __require("node:fs");
                const stream = createReadStream(file);
                const chunks = [];
                for await (const chunk of stream) {
                  chunks.push(chunk);
                }
                return new Uint8Array(Buffer.concat(chunks));
              }
              throw e;
            }
          } else {
            const response = await fetch(file);
            if (!response.ok) {
              throw new Error(`failed to load external data file: ${file}`);
            }
            const contentLengthHeader = response.headers.get("Content-Length");
            const fileSize = contentLengthHeader ? parseInt(contentLengthHeader, 10) : 0;
            if (fileSize < 1073741824) {
              return new Uint8Array(await response.arrayBuffer());
            } else {
              if (!response.body) {
                throw new Error(`failed to load external data file: ${file}, no response body.`);
              }
              const reader = response.body.getReader();
              let buffer;
              try {
                buffer = new ArrayBuffer(fileSize);
              } catch (e) {
                if (e instanceof RangeError) {
                  const pages = Math.ceil(fileSize / 65536);
                  buffer = new WebAssembly.Memory({ initial: pages, maximum: pages }).buffer;
                } else {
                  throw e;
                }
              }
              let offset = 0;
              while (true) {
                const { done, value } = await reader.read();
                if (done) {
                  break;
                }
                const chunkSize = value.byteLength;
                const chunk = new Uint8Array(buffer, offset, chunkSize);
                chunk.set(value);
                offset += chunkSize;
              }
              return new Uint8Array(buffer, 0, fileSize);
            }
          }
        } else if (file instanceof Blob) {
          return new Uint8Array(await file.arrayBuffer());
        } else if (file instanceof Uint8Array) {
          return file;
        } else {
          return new Uint8Array(file);
        }
      };
    }
  });

  // web/lib/wasm/jsep/log.ts
  var logLevelPrefix, doLog, configLogLevel, debug, configureLogger, LOG, LOG_DEBUG;
  var init_log = __esm({
    "web/lib/wasm/jsep/log.ts"() {
      "use strict";
      init_wasm_common();
      logLevelPrefix = ["V", "I", "W", "E", "F"];
      doLog = (level, message) => {
        console.log(`[${logLevelPrefix[level]},${(/* @__PURE__ */ new Date()).toISOString()}]${message}`);
      };
      configureLogger = ($configLogLevel, $debug) => {
        configLogLevel = $configLogLevel;
        debug = $debug;
      };
      LOG = (logLevel, msg) => {
        const messageLevel = logLevelStringToEnum(logLevel);
        const configLevel = logLevelStringToEnum(configLogLevel);
        if (messageLevel >= configLevel) {
          doLog(messageLevel, typeof msg === "function" ? msg() : msg);
        }
      };
      LOG_DEBUG = (...args) => {
        if (debug) {
          LOG(...args);
        }
      };
    }
  });

  // web/lib/wasm/jsep/tensor-view.ts
  var createView;
  var init_tensor_view = __esm({
    "web/lib/wasm/jsep/tensor-view.ts"() {
      "use strict";
      init_wasm_common();
      createView = (dataBuffer, type) => new (tensorTypeToTypedArrayConstructor(type))(dataBuffer);
    }
  });

  // web/lib/wasm/jsep/webgpu/types.ts
  var init_types = __esm({
    "web/lib/wasm/jsep/webgpu/types.ts"() {
      "use strict";
    }
  });

  // web/lib/wasm/jsep/webgpu/gpu-data-manager.ts
  var bucketFreelist, bucketArr, calcNormalizedBufferSize, calcBucketBufferSize, guid, createNewGpuDataId, downloadGpuData, GpuDataManagerImpl, createGpuDataManager;
  var init_gpu_data_manager = __esm({
    "web/lib/wasm/jsep/webgpu/gpu-data-manager.ts"() {
      "use strict";
      init_log();
      init_types();
      bucketFreelist = /* @__PURE__ */ new Map([
        [64, 250],
        [128, 200],
        [256, 200],
        [512, 200],
        [2048, 230],
        [4096, 200],
        [8192, 50],
        [16384, 50],
        [32768, 50],
        [65536, 50],
        [131072, 50],
        [262144, 50],
        [524288, 50],
        [1048576, 50],
        [2097152, 30],
        [4194304, 20],
        [8388608, 10],
        [12582912, 10],
        [16777216, 10],
        [26214400, 15],
        [33554432, 22],
        [44236800, 2],
        [58982400, 6],
        // we don't want to cache the bucket sizes below but not caching them
        // results in some major performance hits for models like sd-turbo.
        [67108864, 6],
        [134217728, 6],
        [167772160, 6]
      ]);
      bucketArr = [];
      calcNormalizedBufferSize = (size) => Math.ceil(size / 16) * 16;
      calcBucketBufferSize = (size) => {
        for (let idx = 0; idx < bucketArr.length; idx++) {
          const sizeForBucket = bucketArr[idx];
          if (size <= sizeForBucket) {
            return sizeForBucket;
          }
        }
        return Math.ceil(size / 16) * 16;
      };
      guid = 1;
      createNewGpuDataId = () => guid++;
      downloadGpuData = async (backend, gpuBuffer, originalSize, getTargetBuffer) => {
        const bufferSize = calcNormalizedBufferSize(originalSize);
        const gpuReadBuffer = backend.device.createBuffer(
          // eslint-disable-next-line no-bitwise
          { size: bufferSize, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ }
        );
        try {
          const commandEncoder = backend.getCommandEncoder();
          backend.endComputePass();
          commandEncoder.copyBufferToBuffer(
            gpuBuffer,
            0,
            gpuReadBuffer,
            0,
            bufferSize
          );
          backend.flush();
          await gpuReadBuffer.mapAsync(GPUMapMode.READ);
          const arrayBuffer = gpuReadBuffer.getMappedRange();
          if (getTargetBuffer) {
            const targetBuffer = getTargetBuffer();
            targetBuffer.set(new Uint8Array(arrayBuffer, 0, originalSize));
            return targetBuffer;
          } else {
            return new Uint8Array(arrayBuffer.slice(0, originalSize));
          }
        } finally {
          gpuReadBuffer.destroy();
        }
      };
      GpuDataManagerImpl = class {
        constructor(backend) {
          this.backend = backend;
          this.storageCache = /* @__PURE__ */ new Map();
          this.freeBuffers = /* @__PURE__ */ new Map();
          this.freeUniformBuffers = /* @__PURE__ */ new Map();
          this.buffersForUploadingPending = [];
          this.buffersPending = [];
          this.externalBuffers = /* @__PURE__ */ new Map();
          this.capturedPendingBuffers = /* @__PURE__ */ new Map();
          for (const [key] of bucketFreelist) {
            bucketArr.push(key);
            this.freeBuffers.set(key, []);
            this.freeUniformBuffers.set(key, []);
          }
        }
        upload(id, data) {
          const srcArrayBuffer = data.buffer;
          const srcOffset = data.byteOffset;
          const srcLength = data.byteLength;
          const size = calcNormalizedBufferSize(srcLength);
          const gpuDataCache = this.storageCache.get(id);
          if (!gpuDataCache) {
            throw new Error("gpu data for uploading does not exist");
          }
          if (gpuDataCache.originalSize !== srcLength) {
            throw new Error(`inconsistent data size. gpu data size=${gpuDataCache.originalSize}, data size=${srcLength}`);
          }
          const gpuBufferForUploading = this.backend.device.createBuffer(
            // eslint-disable-next-line no-bitwise
            { mappedAtCreation: true, size, usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC }
          );
          const arrayBuffer = gpuBufferForUploading.getMappedRange();
          new Uint8Array(arrayBuffer).set(new Uint8Array(srcArrayBuffer, srcOffset, srcLength));
          gpuBufferForUploading.unmap();
          const commandEncoder = this.backend.getCommandEncoder();
          this.backend.endComputePass();
          commandEncoder.copyBufferToBuffer(gpuBufferForUploading, 0, gpuDataCache.gpuData.buffer, 0, size);
          LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.upload(id=${id})`);
          this.buffersForUploadingPending.push(gpuBufferForUploading);
        }
        memcpy(sourceId, destinationId) {
          const sourceGpuDataCache = this.storageCache.get(sourceId);
          if (!sourceGpuDataCache) {
            throw new Error("source gpu data for memcpy does not exist");
          }
          const destinationGpuDataCache = this.storageCache.get(destinationId);
          if (!destinationGpuDataCache) {
            throw new Error("destination gpu data for memcpy does not exist");
          }
          if (sourceGpuDataCache.originalSize !== destinationGpuDataCache.originalSize) {
            throw new Error("inconsistent source and destination gpu data size");
          }
          const size = calcNormalizedBufferSize(sourceGpuDataCache.originalSize);
          const commandEncoder = this.backend.getCommandEncoder();
          this.backend.endComputePass();
          commandEncoder.copyBufferToBuffer(
            sourceGpuDataCache.gpuData.buffer,
            0,
            destinationGpuDataCache.gpuData.buffer,
            0,
            size
          );
        }
        registerExternalBuffer(buffer, originalSize, previousBuffer) {
          let id;
          if (previousBuffer) {
            id = this.externalBuffers.get(previousBuffer);
            if (id === void 0) {
              throw new Error("previous buffer is not registered");
            }
            if (buffer === previousBuffer) {
              LOG_DEBUG(
                "verbose",
                () => `[WebGPU] GpuDataManager.registerExternalBuffer(size=${originalSize}) => id=${id}, buffer is the same, skip.`
              );
              return id;
            } else if (this.backend.capturedCommandList.has(this.backend.currentSessionId)) {
              throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`);
            }
            this.externalBuffers.delete(previousBuffer);
          } else {
            id = createNewGpuDataId();
          }
          this.storageCache.set(id, { gpuData: { id, type: 0 /* default */, buffer }, originalSize });
          this.externalBuffers.set(buffer, id);
          LOG_DEBUG(
            "verbose",
            () => `[WebGPU] GpuDataManager.registerExternalBuffer(size=${originalSize}) => id=${id}, registered.`
          );
          return id;
        }
        unregisterExternalBuffer(buffer) {
          const id = this.externalBuffers.get(buffer);
          if (id !== void 0) {
            this.storageCache.delete(id);
            this.externalBuffers.delete(buffer);
            LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${id}`);
          }
        }
        // eslint-disable-next-line no-bitwise
        create(size, usage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST) {
          const bufferSize = calcBucketBufferSize(size);
          let gpuBuffer;
          const isStorage = (usage & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE;
          const isUniform = (usage & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM;
          if (isStorage || isUniform) {
            const freeBuffers = isStorage ? this.freeBuffers : this.freeUniformBuffers;
            const buffers = freeBuffers.get(bufferSize);
            if (!buffers) {
              gpuBuffer = this.backend.device.createBuffer({ size: bufferSize, usage });
            } else {
              if (buffers.length > 0) {
                gpuBuffer = buffers.pop();
              } else {
                gpuBuffer = this.backend.device.createBuffer({ size: bufferSize, usage });
              }
            }
          } else {
            gpuBuffer = this.backend.device.createBuffer({ size: bufferSize, usage });
          }
          const gpuData = { id: createNewGpuDataId(), type: 0 /* default */, buffer: gpuBuffer };
          this.storageCache.set(gpuData.id, { gpuData, originalSize: size });
          LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.create(size=${size}) => id=${gpuData.id}`);
          return gpuData;
        }
        get(id) {
          return this.storageCache.get(id)?.gpuData;
        }
        release(id) {
          const cachedData = this.storageCache.get(id);
          if (!cachedData) {
            throw new Error("releasing data does not exist");
          }
          LOG_DEBUG("verbose", () => `[WebGPU] GpuDataManager.release(id=${id}), gpuDataId=${cachedData.gpuData.id}`);
          this.storageCache.delete(id);
          this.buffersPending.push(cachedData.gpuData.buffer);
          return cachedData.originalSize;
        }
        async download(id, getTargetBuffer) {
          const cachedData = this.storageCache.get(id);
          if (!cachedData) {
            throw new Error("data does not exist");
          }
          await downloadGpuData(this.backend, cachedData.gpuData.buffer, cachedData.originalSize, getTargetBuffer);
        }
        refreshPendingBuffers() {
          for (const buffer of this.buffersForUploadingPending) {
            buffer.destroy();
          }
          this.buffersForUploadingPending = [];
          if (this.buffersPending.length === 0) {
            return;
          }
          if (this.backend.sessionStatus === "default") {
            for (const buffer of this.buffersPending) {
              const maxInFreeList = bucketFreelist.get(buffer.size);
              if ((buffer.usage & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE) {
                const freelist = this.freeBuffers.get(buffer.size) || [];
                if (maxInFreeList === void 0 || freelist.length >= maxInFreeList) {
                  buffer.destroy();
                } else {
                  freelist.push(buffer);
                }
              } else if ((buffer.usage & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM) {
                const freelist = this.freeUniformBuffers.get(buffer.size) || [];
                if (maxInFreeList === void 0 || freelist.length >= maxInFreeList) {
                  buffer.destroy();
                } else {
                  freelist.push(buffer);
                }
              } else {
                buffer.destroy();
              }
            }
            this.buffersPending = [];
          } else {
            let capturedBuffers = this.capturedPendingBuffers.get(this.backend.currentSessionId);
            if (!capturedBuffers) {
              capturedBuffers = [];
              this.capturedPendingBuffers.set(this.backend.currentSessionId, capturedBuffers);
            }
            for (const buffer of this.buffersPending) {
              capturedBuffers.push(buffer);
            }
            this.buffersPending = [];
          }
        }
        dispose() {
          this.freeBuffers.forEach((buffers) => {
            buffers.forEach((buffer) => {
              buffer.destroy();
            });
          });
          this.freeUniformBuffers.forEach((buffers) => {
            buffers.forEach((buffer) => {
              buffer.destroy();
            });
          });
          this.storageCache.forEach((storage) => {
            storage.gpuData.buffer.destroy();
          });
          this.capturedPendingBuffers.forEach((buffers) => {
            buffers.forEach((buffer) => {
              buffer.destroy();
            });
          });
          this.storageCache = /* @__PURE__ */ new Map();
          this.freeBuffers = /* @__PURE__ */ new Map();
          this.freeUniformBuffers = /* @__PURE__ */ new Map();
          this.capturedPendingBuffers = /* @__PURE__ */ new Map();
        }
        onReleaseSession(sessionId) {
          const pendingBuffers = this.capturedPendingBuffers.get(sessionId);
          if (pendingBuffers) {
            pendingBuffers.forEach((buffer) => {
              buffer.destroy();
            });
            this.capturedPendingBuffers.delete(sessionId);
          }
        }
      };
      createGpuDataManager = (...args) => new GpuDataManagerImpl(...args);
    }
  });

  // web/lib/wasm/jsep/webgpu/attribute-with-cache-key.ts
  var AttributeWithCacheKeyImpl, createAttributeWithCacheKey;
  var init_attribute_with_cache_key = __esm({
    "web/lib/wasm/jsep/webgpu/attribute-with-cache-key.ts"() {
      "use strict";
      AttributeWithCacheKeyImpl = class {
        constructor(attribute) {
          Object.assign(this, attribute);
        }
        get cacheKey() {
          if (!this.key) {
            this.key = Object.getOwnPropertyNames(this).sort().map((name) => `${this[name]}`).join(";");
          }
          return this.key;
        }
      };
      createAttributeWithCacheKey = (attribute) => new AttributeWithCacheKeyImpl(attribute);
    }
  });

  // web/lib/wasm/jsep/util.ts
  var MatMulUtil, BroadcastUtil, ShapeUtil, PoolConvUtil, GemmUtil, MIN_CLIP, MAX_CLIP;
  var init_util = __esm({
    "web/lib/wasm/jsep/util.ts"() {
      "use strict";
      MatMulUtil = class {
        /**
         * Calculate the expected shape when matrix multiplication
         * @param a The shape of tensor A. Should be a tuple of 2 positive integers
         * @param b The shape of tensor B. Should be a tuple of 2 positive integers
         * @returns The expected shape of the result, or undefined if N/A
         */
        static calcMatMulShape(a, b) {
          return a[1] !== b[0] ? void 0 : [a[0], b[1]];
        }
      };
      BroadcastUtil = class {
        /**
         * Calculate the expected shape when broadcasting 2 tensors
         * @param a The shape of tensor A. Should be an array of positive integers
         * @param b The shape of tensor B. Should be an array of positive integers
         * @param isMatMul Whether the operation is MatMul
         * @returns The expected shape of the result, or undefined if N/A
         */
        static calcShape(adims, bdims, isMatMul = false) {
          const arank = adims.length;
          const brank = bdims.length;
          if (arank === 0) {
            return bdims;
          }
          if (brank === 0) {
            return adims;
          }
          const crank = Math.max(adims.length, bdims.length);
          const cdims = new Array(crank);
          if (isMatMul) {
            if (arank < 2 || brank < 2) {
              return void 0;
            }
            const cShapeMatMul = MatMulUtil.calcMatMulShape(
              [adims[arank - 2], adims[arank - 1]],
              [bdims[brank - 2], bdims[brank - 1]]
            );
            if (cShapeMatMul === void 0) {
              return void 0;
            }
            [cdims[crank - 2], cdims[crank - 1]] = cShapeMatMul;
          }
          for (let i = isMatMul ? 3 : 1; i <= crank; i++) {
            const aLen = arank - i < 0 ? 1 : adims[arank - i];
            const bLen = brank - i < 0 ? 1 : bdims[brank - i];
            if (aLen !== bLen && aLen > 1 && bLen > 1) {
              return void 0;
            }
            const max = Math.max(aLen, bLen);
            if (aLen && bLen) {
              cdims[crank - i] = Math.max(aLen, bLen);
            } else {
              if (max > 1) {
                return void 0;
              }
              cdims[crank - i] = 0;
            }
          }
          return cdims;
        }
        /**
         * Determine if a shape is unidirectional broadcastable to another shape
         * @param shape The input shape
         * @param finalShape The desired shape after broadcasting
         */
        static isValidBroadcast(shape, finalShape) {
          const inputRank = shape.length;
          const finalRank = finalShape.length;
          if (inputRank > finalRank) {
            return false;
          }
          for (let i = 1; i <= inputRank; i++) {
            if (shape[inputRank - i] !== 1 && shape[inputRank - i] !== finalShape[finalRank - i]) {
              return false;
            }
          }
          return true;
        }
      };
      ShapeUtil = class _ShapeUtil {
        /**
         * calculate the size (number of elements)
         */
        static size(dims) {
          return _ShapeUtil.getSizeFromDimensionRange(dims, 0, dims.length);
        }
        /**
         * convert dims corresponding to type change to pack. ex. uint8 data to uint32
         */
        static convertShape(dims, size = 4) {
          const rank = dims.length;
          if (rank === 0) {
            return [];
          }
          const newDims = new Array(rank);
          let i = rank - 1;
          while (i >= 0) {
            if (dims[i] % size === 0) {
              newDims[i] = dims[i] / size;
              break;
            }
            if (size % dims[i] !== 0) {
              throw new Error("cannot convert shape");
            }
            newDims[i] = 1;
            size /= dims[i];
            i--;
          }
          for (i--; i >= 0; i--) {
            newDims[i] = dims[i];
          }
          return newDims;
        }
        /**
         * calculate the size (number of elements) from the given axis (inclusive)
         */
        static sizeFromDimension(dims, axis) {
          if (axis < 0 || axis > dims.length) {
            throw new Error(`invalid dimension of ${axis} for sizeFromDimension as Tensor has ${dims.length} dimensions.`);
          }
          return _ShapeUtil.getSizeFromDimensionRange(dims, axis, dims.length);
        }
        /**
         * calculate the size (number of elements) to the given axis (exclusive)
         */
        static sizeToDimension(dims, axis) {
          if (axis < 0 || axis > dims.length) {
            throw new Error(`invalid dimension of ${axis} for sizeToDimension as Tensor has ${dims.length} dimensions.`);
          }
          return _ShapeUtil.getSizeFromDimensionRange(dims, 0, axis);
        }
        /**
         * calculate the size (number of elements) from and to the given axis [start, end)
         */
        static getSizeFromDimensionRange(dims, start, end) {
          let size = 1;
          for (let i = start; i < end; i++) {
            if (dims[i] < 0) {
              throw new Error(
                // eslint-disable-next-line max-len
                "cannot get valid size from specified dimension range. Most likely the range contains negative values in them."
              );
            }
            size *= dims[i];
          }
          return size;
        }
        static computeStrides(dims) {
          const rank = dims.length;
          if (rank === 0) {
            return [];
          } else if (rank === 1) {
            return [1];
          }
          const strides = new Array(rank);
          strides[rank - 1] = 1;
          strides[rank - 2] = dims[rank - 1];
          for (let i = rank - 3; i >= 0; --i) {
            strides[i] = strides[i + 1] * dims[i + 1];
          }
          return strides;
        }
        /**
         * normailze axis of range [-r, r) into [0, r).
         */
        static normalizeAxis(axis, tensorRank) {
          if (axis < -tensorRank && axis >= tensorRank) {
            throw new Error("unsupported axis for this operation.");
          }
          return axis < 0 ? axis + tensorRank : axis;
        }
        static normalizeAxes(axes, tensorRank) {
          return axes.map((x) => this.normalizeAxis(x, tensorRank ?? axes.length));
        }
        /**
         * Sorts a given array based on the indices in the Perm array
         * Used in Transpose
         * @param a Array to be sorted such as dims or strides
         * @param perm Perm given; if null a will be reversed
         */
        static sortBasedOnPerm(a, perm) {
          if (perm) {
            return perm.map((v) => a[v]);
          } else {
            return a.slice().reverse();
          }
        }
        /**
         * Pads a given shape according to the padding values
         * @param dims shape of the Tensor to be padded
         * @param pad pad values
         */
        static padShape(dims, pad2) {
          const rank = dims.length;
          return dims.map((v, i) => v + pad2[i] + pad2[i + rank]);
        }
        /**
         * Determines if the two shapes are identical
         * @param shape1
         * @param shape2
         */
        static areEqual(shape1, shape2) {
          if (shape1.length !== shape2.length) {
            return false;
          }
          return shape1.every((v, i) => v === shape2[i]);
        }
      };
      PoolConvUtil = class _PoolConvUtil {
        /**
         * Adjust the kernel, strides, pads to correct rank. Set to default value if not present
         * @param isGlobalOperator If true, perform global pooling.
         * @param inputDims The input tensor dimension.
         * @param kernelShape The size of the kernel along each axis.
         * @param strides Stride along each axis.
         * @param dilations Dilation along each axis.
         * @param pads Padding for the beginning and ending along each axis.
         */
        static adjustPoolAttributes(isGlobalOperator, inputDims, kernelShape, strides, dilations, pads) {
          if (!isGlobalOperator && kernelShape.length !== inputDims.length - 2) {
            throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
          }
          if (isGlobalOperator) {
            for (let dim = 0; dim < inputDims.length - 2; dim++) {
              if (dim >= kernelShape.length) {
                kernelShape.push(inputDims[dim + 2]);
              } else {
                kernelShape[dim] = inputDims[dim + 2];
              }
            }
          }
          for (let dim = 0; dim < kernelShape.length; dim++) {
            if (dim < strides.length) {
              if (strides[dim] < 0) {
                throw new Error("strides should be greater than or equal to 1");
              }
            } else {
              strides.push(1);
            }
          }
          for (let dim = 0; dim < kernelShape.length; dim++) {
            if (dim < dilations.length) {
              if (dilations[dim] < 0) {
                throw new Error("dilations should be greater than or equal to 1");
              }
            } else {
              dilations.push(1);
            }
          }
          for (let dim = 0; dim < kernelShape.length * 2; dim++) {
            if (dim < pads.length) {
              if (pads[dim] < 0) {
                throw new Error("pad should be greater than or equal to 1");
              }
            } else {
              pads.push(0);
            }
          }
          for (let dim = 0; dim < kernelShape.length; dim++) {
            if (kernelShape[dim] <= 0) {
              throw new Error("kernel shapes need to be greater than 0");
            }
            if (pads[dim] >= kernelShape[dim] || pads[dim + kernelShape.length] >= kernelShape[dim]) {
              throw new Error("pads should be smaller than kernel");
            }
          }
        }
        // adjust pad values based on 'autoPad' attribute
        static adjustPadsBasedOnAutoPad(inputDims, strides, dilations, kernelShape, pads, isChannelLast, autoPad) {
          if (!autoPad) {
            return;
          }
          if (pads.length !== 2 * (inputDims.length - 2)) {
            throw new Error("length of pads should be twice the length of data dimensions");
          }
          if (strides.length !== inputDims.length - 2) {
            throw new Error("length of strides should be the length of data dimensions");
          }
          if (kernelShape.length !== inputDims.length - 2) {
            throw new Error("length of kernel shapes should be the length of data dimensions");
          }
          for (let dim = 0; dim < inputDims.length - 2; dim++) {
            _PoolConvUtil.adjustPadAndReturnShape(
              inputDims[dim + (isChannelLast ? 1 : 2)],
              strides[dim],
              dilations[dim],
              kernelShape[dim],
              pads,
              dim,
              dim + inputDims.length - 2,
              autoPad
            );
          }
        }
        /**
         * Calculate the output shape for Pool ops based on input attributes. (Should be used only for Pool ops)
         * @param isGlobalOperator If true, perform global pooling.
         * @param inputDims The input tensor dimension. (inputs[0].dims)
         * @param strides Stride along each axis.
         * @param dilations Dilation along each axis.
         * @param kernelShape The size of the kernel along each axis.
         * @param pads Padding for the beginning and ending along each axis.
         * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
         *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
         */
        static computePoolOutputShape(isGlobalOperator, inputDims, strides, dilations, kernelShape, pads, autoPad) {
          if (inputDims.length <= 0) {
            throw new Error("input shape must be of size greater than 0");
          }
          const outputDims = [inputDims[0], inputDims[1]];
          _PoolConvUtil.computeShapeHelper(
            isGlobalOperator,
            inputDims,
            outputDims,
            strides,
            dilations,
            kernelShape,
            pads,
            autoPad
          );
          return outputDims;
        }
        /**
         * Calculate the output shape for Conv op based on input attributes. (Should be used only for Conv op)
         * @param inputDims The input tensor dimension. (inputs[0].dims)
         * @param filterDims The filter tensor dimension. (inputs[1].dims)
         * @param strides Stride along each axis.
         * @param kernelShape The size of the kernel along each axis.
         * @param pads Padding for the beginning and ending along each axis.
         * @param autoPad DEPRECATED attribute supported for legacy models. Specifies how to implicitly calculate pads in each
         *     dimension. Can take values NOTSET, SAME_UPPER, SAME_LOWER, or VALID.
         */
        static computeConvOutputShape(inputDims, filterDims, strides, dilations, kernelShape, pads, autoPad) {
          if (inputDims.length <= 0 || filterDims.length <= 0) {
            throw new Error("invalid input tensor dims or invalid filter tensor dims");
          }
          const outputDims = [inputDims[0], filterDims[0]];
          _PoolConvUtil.computeShapeHelper(false, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad);
          return outputDims;
        }
        // will compute output shapes for data dimensions ONLY (i.e.) no batch size and channels
        // called by computePoolOutputShape() and computeConvOutputShape()
        // adjust pads based on 'autoPad' attribute prior to shape computation
        static computeShapeHelper(isGlobalOperator, inputDims, outputDims, strides, dilations, kernelShape, pads, autoPad) {
          if (isGlobalOperator) {
            for (let dim = 0; dim < inputDims.length - 2; dim++) {
              outputDims.push(1);
            }
          } else {
            for (let dim = 0; dim < inputDims.length - 2; dim++) {
              outputDims.push(
                _PoolConvUtil.adjustPadAndReturnShape(
                  inputDims[dim + 2],
                  strides[dim],
                  dilations[dim],
                  kernelShape[dim],
                  pads,
                  dim,
                  dim + inputDims.length - 2,
                  autoPad
                )
              );
            }
          }
        }
        // helper for computeShapeHelper() and adjustPadsBasedOnAutoPad()
        // adjusts pad value for given 'autoPad' string and computes output shape along a particular dimension
        static adjustPadAndReturnShape(inSize, stride, dilation, kernel, pads, padHeadIndex, padTailIndex, autoPad) {
          const dkernel = dilation * (kernel - 1) + 1;
          if (autoPad && autoPad !== "NOTSET") {
            switch (autoPad) {
              case "VALID":
                pads[padHeadIndex] = 0;
                pads[padTailIndex] = 0;
                return Math.floor((inSize - dkernel) / stride + 1);
              case "SAME_LOWER":
              case "SAME_UPPER":
                if (dilation !== 1) {
                  throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
                } else {
                  const legacyTargetSize = (inSize + stride - 1) / stride;
                  const padNeeded = (legacyTargetSize - 1) * stride + kernel - inSize;
                  pads[padHeadIndex] = autoPad === "SAME_LOWER" ? Math.floor((padNeeded + 1) / 2) : Math.floor(padNeeded / 2);
                  pads[padTailIndex] = padNeeded - pads[padHeadIndex];
                  return Math.floor((inSize + padNeeded - kernel) / stride + 1);
                }
              default:
                throw new Error("Unsupported AutoPad type");
            }
          } else {
            return Math.floor((inSize + pads[padHeadIndex] + pads[padTailIndex] - dkernel) / stride + 1);
          }
        }
      };
      GemmUtil = class {
        // will make sure input shapes are compatible for this op
        // and return back the shape of the output in the form of a tuple
        // will throw exception if the input shapes are not compatible
        static getShapeOfGemmResult(leftShape, transLeft, rightShape, transRight, biasShape) {
          if (leftShape.length !== 2 || rightShape.length !== 2) {
            throw new Error("shape need to be of size 2");
          }
          let M;
          let K;
          let N;
          if (transLeft) {
            M = leftShape[1];
            K = leftShape[0];
          } else {
            M = leftShape[0];
            K = leftShape[1];
          }
          let kDim = -1;
          if (transRight) {
            N = rightShape[0];
            kDim = 1;
          } else {
            N = rightShape[1];
            kDim = 0;
          }
          if (rightShape[kDim] !== K) {
            throw new Error("dimension mismatch");
          }
          if (M <= 0 || N <= 0 || K <= 0) {
            throw new Error("invalid shape specified");
          }
          if (biasShape && !BroadcastUtil.isValidBroadcast(biasShape, [M, N])) {
            throw new Error("gemm: invalid bias shape for broadcast");
          }
          return [M, N, K];
        }
      };
      MIN_CLIP = -34028234663852886e22;
      MAX_CLIP = 34028234663852886e22;
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/common.ts
  var WORKGROUP_SIZE, getWgslMappedType, tensorTypeToWsglStorageType, tensorTypeToWsglValueType, createTensorShapeVariables, getMaxComponents, fillVector, castToF32, sumVector, getElementAt, createIndicesHelper, inputVariable, outputVariable, internalVariable, ShaderHelperImpl, createShaderHelper, getBroadcastDims;
  var init_common = __esm({
    "web/lib/wasm/jsep/webgpu/ops/common.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      WORKGROUP_SIZE = 64;
      getWgslMappedType = (type, components) => {
        if (components === 3) {
          throw new Error("vec3 has same alignment as vec4, use vec4 instead");
        }
        switch (type) {
          case 10 /* float16 */:
            return components > 1 ? `vec${components}<f16>` : "f16";
          case 1 /* float */:
            return components > 1 ? `vec${components}<f32>` : "f32";
          case 6 /* int32 */:
            return components > 1 ? `vec${components}<i32>` : "i32";
          case 12 /* uint32 */:
            return components > 1 ? `vec${components}<u32>` : "u32";
          case 7 /* int64 */:
            if (components > 1) {
              throw new Error("currently not supported vecX of uint64 yet");
            }
            return ["vec2<u32>", "i32"];
          case 13 /* uint64 */:
            if (components > 1) {
              throw new Error("currently not supported vecX of uint64 yet");
            }
            return ["vec2<u32>", "u32"];
          case 9 /* bool */:
            if (components !== 4) {
              throw new Error("bool must be vec4");
            }
            return ["u32", "vec4<bool>"];
          case 22 /* int4 */:
            return "i32";
          case 21 /* uint4 */:
            return "u32";
          default:
            throw new Error(`Unknown data type: ${type}`);
        }
      };
      tensorTypeToWsglStorageType = (type, components = 1) => {
        const mappedType = getWgslMappedType(type, components);
        return typeof mappedType === "string" ? mappedType : mappedType[0];
      };
      tensorTypeToWsglValueType = (type, components = 1) => {
        const mappedType = getWgslMappedType(type, components);
        return typeof mappedType === "string" ? mappedType : mappedType[1];
      };
      createTensorShapeVariables = (...dims) => {
        const programUniforms = [];
        dims.forEach((dim) => {
          if (dim.length !== 0) {
            programUniforms.push(
              { type: 12 /* uint32 */, data: dim },
              { type: 12 /* uint32 */, data: ShapeUtil.computeStrides(dim) }
            );
          }
        });
        return programUniforms;
      };
      getMaxComponents = (size) => {
        if (size % 4 === 0) {
          return 4;
        } else if (size % 2 === 0) {
          return 2;
        }
        return 1;
      };
      fillVector = (dataType = "f32", components, value = "0") => {
        if (!components || components === 1) {
          return `${dataType}(${value})`;
        }
        return `vec${components}<${dataType}>(${value})`;
      };
      castToF32 = (dataType, components, value) => {
        if (dataType === "f32") {
          return value;
        }
        if (components === 1) {
          return `f32(${value})`;
        }
        return `vec${components}<f32>(${value})`;
      };
      sumVector = (name, components) => {
        if (components === 4) {
          return `(${name}.x + ${name}.y + ${name}.z + ${name}.w)`;
        } else if (components === 2) {
          return `(${name}.x + ${name}.y)`;
        } else if (components === 3) {
          return `(${name}.x + ${name}.y + ${name}.z)`;
        }
        return name;
      };
      getElementAt = (name, index, length, type) => {
        if (name.startsWith("uniforms.") && length > 4) {
          if (typeof index === "string") {
            if (type === "f16") {
              return `${name}[(${index}) / 8][(${index}) % 8 / 4][(${index}) % 8 % 4]`;
            } else {
              return `${name}[(${index}) / 4][(${index}) % 4]`;
            }
          } else {
            if (type === "f16") {
              return `${name}[${Math.floor(index / 8)}][${Math.floor(index % 8 / 4)}][${index % 8 % 4}]`;
            } else {
              return `${name}[${Math.floor(index / 4)}][${index % 4}]`;
            }
          }
        } else {
          return length > 1 ? `${name}[${index}]` : name;
        }
      };
      createIndicesHelper = (name, tensorType, shapeOrRank, usage, components) => {
        const useUniform = typeof shapeOrRank === "number";
        const rank = useUniform ? shapeOrRank : shapeOrRank.length;
        const rankIdentity = [...new Array(rank).keys()];
        const indicesType = rank < 2 ? "u32" : rank <= 4 ? `vec${rank}<u32>` : `array<u32, ${rank}>`;
        const mappedType = getWgslMappedType(tensorType, components);
        const valueType = typeof mappedType === "string" ? mappedType : mappedType[1];
        const storageType = typeof mappedType === "string" ? mappedType : mappedType[0];
        const type = { indices: indicesType, value: valueType, storage: storageType, tensor: tensorType };
        const normalizeDim = (dim) => typeof dim === "string" ? dim : `${dim}u`;
        const implementationUsed = {
          offsetToIndices: false,
          indicesToOffset: false,
          broadcastedIndicesToOffset: false,
          set: false,
          setByIndices: false,
          get: false,
          getByIndices: false
        };
        const uniformPrefix = useUniform ? "uniforms." : "";
        const shape = `${uniformPrefix}${name}_shape`;
        const strides = `${uniformPrefix}${name}_strides`;
        let o2iSnippet = "";
        for (let i = 0; i < rank - 1; i++) {
          o2iSnippet += `
    let dim${i} = current / ${getElementAt(strides, i, rank)};
    let rest${i} = current % ${getElementAt(strides, i, rank)};
    indices[${i}] = dim${i};
    current = rest${i};
    `;
        }
        o2iSnippet += `indices[${rank - 1}] = current;`;
        const offsetToIndicesImplementation = rank < 2 ? "" : `
  fn o2i_${name}(offset: u32) -> ${type.indices} {
    var indices: ${type.indices};
    var current = offset;
    ${o2iSnippet}
    return indices;
  }`;
        const offsetToIndices = (varOffset) => {
          implementationUsed.offsetToIndices = true;
          return rank < 2 ? varOffset : `o2i_${name}(${varOffset})`;
        };
        const offsets = [];
        if (rank >= 2) {
          for (let i = rank - 1; i >= 0; i--) {
            offsets.push(`${getElementAt(strides, i, rank)} * (indices[${i}])`);
          }
        }
        const indicesToOffsetImplementation = rank < 2 ? "" : `
  fn i2o_${name}(indices: ${type.indices}) -> u32 {
    return ${offsets.join("+")};
  }`;
        const indicesToOffset = (varIndices) => {
          implementationUsed.indicesToOffset = true;
          return rank < 2 ? varIndices : `i2o_${name}(${varIndices})`;
        };
        const indices = (...init2) => rank === 0 ? "0u" : `${type.indices}(${init2.map(normalizeDim).join(",")})`;
        const indicesGet = (varIndices, idx) => {
          if (rank < 2) {
            return `${varIndices}`;
          } else {
            return `${getElementAt(varIndices, idx, rank)}`;
          }
        };
        const indicesSet = (varIndices, idx, value) => {
          if (rank < 2) {
            return `${varIndices}=${value};`;
          } else {
            return `${getElementAt(varIndices, idx, rank)}=${value};`;
          }
        };
        const broadcastedIndicesToOffsetImplementation = {};
        const broadcastedIndicesToOffset = (varIndices, output) => {
          implementationUsed.broadcastedIndicesToOffset = true;
          const implKey = `${output.name}broadcastedIndicesTo${name}Offset`;
          if (implKey in broadcastedIndicesToOffsetImplementation) {
            return `${implKey}(${varIndices})`;
          }
          const offsets2 = [];
          for (let i = rank - 1; i >= 0; i--) {
            const idx = output.indicesGet("outputIndices", i + output.rank - rank);
            offsets2.push(`${indicesGet(strides, i)} * (${idx} % ${indicesGet(shape, i)})`);
          }
          broadcastedIndicesToOffsetImplementation[implKey] = `fn ${implKey}(outputIndices: ${output.type.indices}) -> u32 {
             return ${offsets2.length > 0 ? offsets2.join("+") : "0u"};
           }`;
          return `${implKey}(${varIndices})`;
        };
        const setByOffset = (offset, value) => (() => {
          if (type.storage === type.value) {
            return `${name}[${offset}]=${value};`;
          } else if (type.storage === "vec2<u32>" && type.value === "i32") {
            return `${name}[${offset}]=vec2<u32>(u32(${value}), select(0u, 0xFFFFFFFFu, ${value} < 0));`;
          } else if (type.storage === "vec2<u32>" && type.value === "u32") {
            return `${name}[${offset}]=vec2<u32>(u32(${value}), 0u);`;
          } else if (type.storage === "u32" && type.value === "vec4<bool>") {
            return `${name}[${offset}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${value}));`;
          } else {
            throw new Error(`not supported combination of storage type ${type.storage} and value type ${type.value} yet`);
          }
        })();
        const getByOffset = (offset) => (() => {
          if (type.storage === type.value) {
            return `${name}[${offset}]`;
          } else if (type.storage === "vec2<u32>" && type.value === "i32") {
            return `i32(${name}[${offset}].x)`;
          } else if (type.storage === "vec2<u32>" && type.value === "u32") {
            return `u32(${name}[${offset}].x)`;
          } else if (type.storage === "u32" && type.value === "vec4<bool>") {
            return `vec4<bool>(bool(${name}[${offset}] & 0xFFu), bool(${name}[${offset}] & 0xFF00u), bool(${name}[${offset}] & 0xFF0000u), bool(${name}[${offset}] & 0xFF000000u))`;
          } else {
            throw new Error(`not supported combination of storage type ${type.storage} and value type ${type.value} yet`);
          }
        })();
        const getByIndicesImplementation = rank < 2 ? "" : `
  fn get_${name}ByIndices(indices: ${type.indices}) -> ${valueType} {
    return ${getByOffset(`i2o_${name}(indices)`)};
  }`;
        const getImplementation = rank < 2 ? "" : (() => {
          const functionParams = rankIdentity.map((i) => `d${i}: u32`).join(", ");
          const dimsParams = rankIdentity.map((i) => `d${i}`).join(", ");
          return `
  fn get_${name}(${functionParams}) -> ${valueType} {
    return get_${name}ByIndices(${indices(dimsParams)});
  }`;
        })();
        const get = (...indices2) => {
          if (indices2.length !== rank) {
            throw new Error(`indices length must be ${rank}`);
          }
          const normalizedIndices = indices2.map(normalizeDim).join(",");
          if (rank === 0) {
            return getByOffset("0u");
          } else if (rank === 1) {
            return getByOffset(normalizedIndices[0]);
          } else {
            implementationUsed.get = true;
            implementationUsed.getByIndices = true;
            implementationUsed.indicesToOffset = true;
            return `get_${name}(${normalizedIndices})`;
          }
        };
        const getByIndices = (varIndices) => {
          if (rank < 2) {
            return getByOffset(varIndices);
          } else {
            implementationUsed.getByIndices = true;
            implementationUsed.indicesToOffset = true;
            return `get_${name}ByIndices(${varIndices})`;
          }
        };
        const setByIndicesImplementation = rank < 2 ? "" : `
  fn set_${name}ByIndices(indices: ${type.indices}, value: ${valueType}) {
    ${setByOffset(`i2o_${name}(indices)`, "value")}
  }`;
        const setImplementation = rank < 2 ? "" : (() => {
          const functionParams = rankIdentity.map((i) => `d${i}: u32`).join(", ");
          const dimsParams = rankIdentity.map((i) => `d${i}`).join(", ");
          return `
  fn set_${name}(${functionParams}, value: ${valueType}) {
    set_${name}ByIndices(${indices(dimsParams)}, value);
  }`;
        })();
        const set = (...indicesAndValue) => {
          if (indicesAndValue.length !== rank + 1) {
            throw new Error(`indices length must be ${rank}`);
          }
          const value = indicesAndValue[rank];
          if (typeof value !== "string") {
            throw new Error("value must be string");
          }
          const normalizedIndices = indicesAndValue.slice(0, rank).map(normalizeDim).join(",");
          if (rank === 0) {
            return setByOffset("0u", value);
          } else if (rank === 1) {
            return setByOffset(normalizedIndices[0], value);
          } else {
            implementationUsed.set = true;
            implementationUsed.setByIndices = true;
            implementationUsed.indicesToOffset = true;
            return `set_${name}(${normalizedIndices}, ${value})`;
          }
        };
        const setByIndices = (varIndices, value) => {
          if (rank < 2) {
            return setByOffset(varIndices, value);
          } else {
            implementationUsed.setByIndices = true;
            implementationUsed.indicesToOffset = true;
            return `set_${name}ByIndices(${varIndices}, ${value});`;
          }
        };
        const impl = () => {
          const impls = [];
          let needShapeStrides = false;
          if (implementationUsed.offsetToIndices) {
            impls.push(offsetToIndicesImplementation);
            needShapeStrides = true;
          }
          if (implementationUsed.indicesToOffset) {
            impls.push(indicesToOffsetImplementation);
            needShapeStrides = true;
          }
          if (implementationUsed.broadcastedIndicesToOffset) {
            Object.values(broadcastedIndicesToOffsetImplementation).forEach((impl2) => impls.push(impl2));
            needShapeStrides = true;
          }
          if (implementationUsed.set) {
            impls.push(setImplementation);
            needShapeStrides = true;
          }
          if (implementationUsed.setByIndices) {
            impls.push(setByIndicesImplementation);
            needShapeStrides = true;
          }
          if (implementationUsed.get) {
            impls.push(getImplementation);
            needShapeStrides = true;
          }
          if (implementationUsed.getByIndices) {
            impls.push(getByIndicesImplementation);
            needShapeStrides = true;
          }
          if (!useUniform && needShapeStrides) {
            impls.unshift(
              `const ${shape} = ${type.indices}(${shapeOrRank.join(",")});`,
              `const ${strides} = ${type.indices}(${ShapeUtil.computeStrides(shapeOrRank).join(",")});`
            );
          }
          return impls.join("\n");
        };
        return {
          impl,
          type,
          offsetToIndices,
          indicesToOffset,
          broadcastedIndicesToOffset,
          indices,
          indicesGet,
          indicesSet,
          set,
          setByOffset,
          setByIndices,
          get,
          getByOffset,
          getByIndices,
          // isVec4,
          usage,
          name,
          strides,
          shape,
          rank
        };
      };
      inputVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "input", components);
      outputVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "output", components);
      internalVariable = (name, type, shapeOrRank, components = 1) => createIndicesHelper(name, type, shapeOrRank, "internal", components);
      ShaderHelperImpl = class {
        constructor(normalizedDispatchGroup, limits) {
          this.normalizedDispatchGroup = normalizedDispatchGroup;
          this.limits = limits;
          this.internalVariables = [];
          this.variables = [];
          this.uniforms = [];
          this.variableIndex = 0;
        }
        guardAgainstOutOfBoundsWorkgroupSizes(size) {
          const sizeInCode = typeof size === "number" ? `${size}u` : size;
          return `if (global_idx >= ${sizeInCode}) { return; }`;
        }
        mainStart(workgroupSize = WORKGROUP_SIZE) {
          const workgroupSizeX = typeof workgroupSize === "number" ? workgroupSize : workgroupSize[0];
          const workgroupSizeY = typeof workgroupSize === "number" ? 1 : workgroupSize[1];
          const workgroupSizeZ = typeof workgroupSize === "number" ? 1 : workgroupSize[2];
          if (workgroupSizeX > this.limits.maxComputeWorkgroupSizeX || workgroupSizeY > this.limits.maxComputeWorkgroupSizeY || workgroupSizeZ > this.limits.maxComputeWorkgroupSizeZ) {
            throw new Error(
              `workgroup size [${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`
            );
          }
          if (workgroupSizeX * workgroupSizeY * workgroupSizeZ > this.limits.maxComputeInvocationsPerWorkgroup) {
            throw new Error(
              `workgroup size [${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`
            );
          }
          const is1DimensionDispatch = this.normalizedDispatchGroup[1] === 1 && this.normalizedDispatchGroup[2] === 1;
          const paramList = is1DimensionDispatch ? `@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_id) local_id : vec3<u32>` : `@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`;
          const globalIdxDefinition = is1DimensionDispatch ? `let global_idx = global_id.x;
         let local_idx = local_id.x;
         let workgroup_index = workgroup_id.x;` : `let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${workgroupSizeX * workgroupSizeY * workgroupSizeZ}u + local_idx;`;
          return `@compute @workgroup_size(${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ})
  fn main(${paramList}) {
    ${globalIdxDefinition}
  `;
        }
        appendVariableUniforms(variable) {
          if (variable.rank !== 0) {
            if (variable.shape.startsWith("uniforms.")) {
              this.uniforms.push({ name: variable.shape.replace("uniforms.", ""), type: "u32", length: variable.rank });
            }
            if (variable.strides.startsWith("uniforms.")) {
              this.uniforms.push({ name: variable.strides.replace("uniforms.", ""), type: "u32", length: variable.rank });
            }
          }
        }
        declareVariable(variable, bindingIndex) {
          if (variable.usage === "internal") {
            throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");
          }
          this.variables.push(variable);
          this.appendVariableUniforms(variable);
          const access = variable.usage === "input" ? "read" : "read_write";
          const storageType = variable.type.storage;
          return `@group(0) @binding(${bindingIndex}) var<storage, ${access}> ${variable.name}: array<${storageType}>;`;
        }
        declareVariables(...variables) {
          return variables.map((v) => this.declareVariable(v, this.variableIndex++)).join("\n");
        }
        registerInternalVariable(variable) {
          if (variable.usage !== "internal") {
            throw new Error(
              "cannot use input or output variable with registerInternalVariable(). use declareVariables() instead."
            );
          }
          this.internalVariables.push(variable);
          this.appendVariableUniforms(variable);
        }
        registerInternalVariables(...variables) {
          variables.forEach((v) => this.registerInternalVariable(v));
          return this;
        }
        registerUniform(name, type, length = 1) {
          this.uniforms.push({ name, type, length });
          return this;
        }
        registerUniforms(additionalUniforms) {
          this.uniforms = this.uniforms.concat(additionalUniforms);
          return this;
        }
        uniformDeclaration() {
          if (this.uniforms.length === 0) {
            return "";
          }
          const uniformSnippets = [];
          for (const { name, type, length } of this.uniforms) {
            if (length && length > 4) {
              if (type === "f16") {
                uniformSnippets.push(`@align(16) ${name}:array<mat2x4<${type}>, ${Math.ceil(length / 8)}>`);
              } else {
                uniformSnippets.push(`${name}:array<vec4<${type}>, ${Math.ceil(length / 4)}>`);
              }
            } else {
              const typeTemp = length == null || length === 1 ? type : `vec${length}<${type}>`;
              uniformSnippets.push(`${name}:${typeTemp}`);
            }
          }
          return `
      struct Uniforms { ${uniformSnippets.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`;
        }
        /**
         * Get additional implementation that needs to be added to the shader source.
         */
        get additionalImplementations() {
          return this.uniformDeclaration() + this.variables.map((i) => i.impl()).join("\n") + this.internalVariables.map((i) => i.impl()).join("\n");
        }
        /**
         * Get the variable info of the shader program.
         */
        get variablesInfo() {
          if (this.uniforms.length === 0) {
            return void 0;
          }
          const uniformWgslTypeToDataType = (type) => [12 /* uint32 */, 10 /* float16 */, 1 /* float */, 6 /* int32 */][["u32", "f16", "f32", "i32"].indexOf(type)];
          return this.uniforms.map((u) => [uniformWgslTypeToDataType(u.type), u.length ?? 1]);
        }
      };
      createShaderHelper = (dispatchGroup, limits) => new ShaderHelperImpl(dispatchGroup, limits);
      getBroadcastDims = (inShape, outShape) => {
        const inRank = inShape.length;
        const dims = [];
        for (let i = 0; i < inRank; i++) {
          const dim = inRank - 1 - i;
          const a = inShape[dim] || 1;
          const b = outShape[outShape.length - 1 - i] || 1;
          if (b > 1 && a === 1) {
            dims.unshift(dim);
          }
        }
        return dims;
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/transpose.ts
  var validateInputs, getAdjustedPerm, getOutputShape, permFunctionBody, squeezeShape, createTransposeProgramInfo, transpose, parseTransposeAttributes;
  var init_transpose = __esm({
    "web/lib/wasm/jsep/webgpu/ops/transpose.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Transpose requires 1 input.");
        }
      };
      getAdjustedPerm = (inputRank, perm) => perm && perm.length !== inputRank ? [...new Array(inputRank).keys()].reverse() : perm;
      getOutputShape = (inputShape, perm) => ShapeUtil.sortBasedOnPerm(inputShape, getAdjustedPerm(inputShape.length, perm));
      permFunctionBody = (perm, rank, input, output) => {
        let reverseFunc = `fn perm(i: ${output.type.indices}) -> ${input.type.indices} {
    var a: ${input.type.indices};`;
        for (let i = 0; i < rank; ++i) {
          reverseFunc += input.indicesSet("a", perm[i], `i[${i}]`);
        }
        return reverseFunc += "return a;}";
      };
      squeezeShape = (shape, adjustedPerm) => {
        const newShape = [];
        const newPerm = [];
        for (let i = 0; i < shape.length; ++i) {
          if (shape[i] !== 1) {
            newShape.push(shape[i]);
          }
          if (shape[adjustedPerm[i]] !== 1) {
            newPerm.push(adjustedPerm[i]);
          }
        }
        return { newShape, newPerm };
      };
      createTransposeProgramInfo = (inputTensor, permAttr) => {
        const inputDataType = inputTensor.dataType;
        const inputRank = inputTensor.dims.length;
        const perm = getAdjustedPerm(inputRank, permAttr);
        const outputShape = getOutputShape(inputTensor.dims, perm);
        const { newShape, newPerm } = squeezeShape(inputTensor.dims, perm);
        const channelsLast = ShapeUtil.areEqual(newPerm, [2, 3, 1]);
        const channelsFirst = ShapeUtil.areEqual(newPerm, [3, 1, 2]);
        const useShared = newShape.length === 2 && newPerm[0] > newPerm[1] || channelsLast || channelsFirst;
        let newInputShape = useShared ? newShape : inputTensor.dims;
        let newOutputShape = outputShape;
        if (useShared) {
          newInputShape = channelsLast ? [newShape[0], newShape[1] * newShape[2]] : channelsFirst ? [newShape[0] * newShape[1], newShape[2]] : newShape;
          newOutputShape = [newInputShape[1], newInputShape[0]];
        }
        const input = inputVariable("a", inputDataType, newInputShape.length);
        const output = outputVariable("output", inputDataType, newOutputShape.length);
        const tileSize = 16;
        let getShaderSource;
        if (useShared) {
          getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}
  var<workgroup> tile : array<array<${output.type.value}, ${tileSize + 1}>, ${tileSize}>;
  ${shaderHelper.mainStart([tileSize, tileSize, 1])}
    let stride = (uniforms.output_shape[1] - 1) / ${tileSize} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${tileSize}u + local_id.x;
    let input_row = workgroup_id_x * ${tileSize}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${input.getByIndices(`${input.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${tileSize}u + local_id.x;
    let output_row = workgroup_id_y * ${tileSize}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${output.setByIndices(`${output.type.indices}(output_row, output_col)`, "tile[local_id.x][local_id.y]")}
    }
  }`;
        } else {
          getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}

  ${permFunctionBody(perm, inputRank, input, output)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${output.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${output.setByOffset("global_idx", input.getByIndices("aIndices"))}
  }`;
        }
        return {
          name: useShared ? "TransposeShared" : "Transpose",
          shaderCache: { hint: `${permAttr}`, inputDependencies: ["rank"] },
          getRunData: () => {
            const outputSize = ShapeUtil.size(outputShape);
            return {
              outputs: [{ dims: outputShape, dataType: inputTensor.dataType }],
              dispatchGroup: useShared ? { x: Math.ceil(newOutputShape[1] / tileSize), y: Math.ceil(newOutputShape[0] / tileSize) } : { x: Math.ceil(
                outputSize / 64
                /* workgroup size */
              ) },
              programUniforms: [
                { type: 12 /* uint32 */, data: outputSize },
                ...createTensorShapeVariables(newInputShape, newOutputShape)
              ]
            };
          },
          getShaderSource
        };
      };
      transpose = (context, attributes) => {
        validateInputs(context.inputs);
        context.compute(createTransposeProgramInfo(context.inputs[0], attributes.perm));
      };
      parseTransposeAttributes = (attributes) => createAttributeWithCacheKey({ perm: attributes.perm });
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/reduce-shared.ts
  var reduceOps, reduceSharedOps, reduceInitValues, reduceOutputValues, getInnerMostAxes, computeOutAndReduceShapes, expandShapeToKeepDim, areAxesInnerMostDims, getAxesPermutation, createReduceSharedProgramInfo, reduceCommon, reduceMeanShared, reduceL1Shared, reduceL2Shared, reduceLogSumExpShared, reduceMaxShared, reduceMinShared, reduceProdShared, reduceSumShared, reduceSumSquareShared, reduceLogSumShared;
  var init_reduce_shared = __esm({
    "web/lib/wasm/jsep/webgpu/ops/reduce-shared.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      init_reduce();
      init_transpose();
      reduceOps = {
        max: "select(bestValue, candidate, candidate > bestValue)",
        min: "select(bestValue, candidate, candidate < bestValue)",
        mean: "bestValue + candidate",
        sum: "bestValue + candidate",
        prod: "bestValue * candidate",
        sumSquare: "bestValue + candidate * candidate",
        logSumExp: "bestValue + exp(candidate)",
        l1: "bestValue + abs(candidate)",
        l2: "bestValue + candidate * candidate",
        logSum: "bestValue + candidate"
      };
      reduceSharedOps = {
        max: "select(bestValue, candidate, candidate > bestValue)",
        min: "select(bestValue, candidate, candidate < bestValue)",
        mean: "bestValue + candidate",
        sum: "bestValue + candidate",
        prod: "bestValue * candidate",
        sumSquare: "bestValue + candidate",
        logSumExp: "bestValue + candidate",
        l1: "bestValue + candidate",
        l2: "bestValue + candidate",
        logSum: "bestValue + candidate"
      };
      reduceInitValues = {
        max: "_A[offset]",
        min: "_A[offset]",
        mean: "0",
        sum: "0",
        prod: "1",
        sumSquare: "0",
        logSumExp: "0",
        l1: "0",
        l2: "0",
        logSum: "0"
      };
      reduceOutputValues = {
        max: "bestValue",
        min: "bestValue",
        sum: "bestValue",
        prod: "bestValue",
        sumSquare: "bestValue",
        logSumExp: "log(bestValue)",
        l1: "bestValue",
        l2: "sqrt(bestValue)",
        logSum: "log(bestValue)"
      };
      getInnerMostAxes = (numInnerAxes, rank) => {
        const res = [];
        for (let i = rank - numInnerAxes; i < rank; ++i) {
          res.push(i);
        }
        return res;
      };
      computeOutAndReduceShapes = (shape, axes) => {
        const outputShape = [];
        const rank = shape.length;
        for (let dim = 0; dim < rank; dim++) {
          if (axes.indexOf(dim) === -1) {
            outputShape.push(shape[dim]);
          }
        }
        const reduceShape = axes.map((dim) => shape[dim]);
        return [outputShape, reduceShape];
      };
      expandShapeToKeepDim = (shape, axes) => {
        const rank = shape.length + axes.length;
        const expandShape = [];
        let shapeIdx = 0;
        for (let dim = 0; dim < rank; dim++) {
          if (axes.indexOf(dim) === -1) {
            expandShape.push(shape[shapeIdx++]);
          } else {
            expandShape.push(1);
          }
        }
        return expandShape;
      };
      areAxesInnerMostDims = (axes, rank) => {
        for (let i = 0; i < axes.length; ++i) {
          if (axes[axes.length - i - 1] !== rank - 1 - i) {
            return false;
          }
        }
        return true;
      };
      getAxesPermutation = (axes, rank) => {
        const res = [];
        if (!areAxesInnerMostDims(axes, rank)) {
          for (let i = 0; i < rank; ++i) {
            if (axes.indexOf(i) === -1) {
              res.push(i);
            }
          }
          axes.forEach((axis) => res.push(axis));
        }
        return res;
      };
      createReduceSharedProgramInfo = (name, shaderCache, inputs, reduceType, outputDataType, outputShape, reduceShape) => {
        const inputShape = inputs[0].dims;
        const outputSize = ShapeUtil.size(outputShape);
        const reduceSize = ShapeUtil.size(reduceShape);
        const input = inputVariable("_A", inputs[0].dataType, inputShape);
        const output = outputVariable("output", outputDataType, outputShape);
        const workgroupSize = 32;
        const sharedMemorySnippet = `
          var<workgroup> aBestValues : array<f32, ${workgroupSize}>;
       `;
        const getShaderSource = (shaderHelper) => `
        ${shaderHelper.registerUniform("reduceSize", "u32").declareVariables(input, output)}
        ${sharedMemorySnippet}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${shaderHelper.mainStart(workgroupSize)}

          let outputIndex = global_idx / ${workgroupSize};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${reduceInitValues[reduceType]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${workgroupSize}) {
           let candidate = f32(${input.getByOffset("offset + k")});
           bestValue = ${reduceOps[reduceType]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${workgroupSize}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${reduceSharedOps[reduceType]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${output.setByOffset(
          "outputIndex",
          `${reduceType === "mean" ? `${output.type.storage}(bestValue / f32(uniforms.reduceSize))` : `${output.type.storage}(${reduceOutputValues[reduceType]})`}`
        )};
         }
        }`;
        return {
          name,
          shaderCache,
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: outputDataType }],
            dispatchGroup: { x: outputSize },
            programUniforms: [{ type: 12 /* uint32 */, data: reduceSize }]
          })
        };
      };
      reduceCommon = (context, name, attributes, reduceType) => {
        const updatedAttributes = context.inputs.length === 1 ? attributes : createReduceAttributesFromInputs(context.inputs, attributes);
        let updatedAxes = updatedAttributes.axes;
        if (updatedAxes.length === 0 && !updatedAttributes.noopWithEmptyAxes) {
          updatedAxes = context.inputs[0].dims.map((_dim, i) => i);
        }
        const normalizeAxes = ShapeUtil.normalizeAxes(updatedAxes, context.inputs[0].dims.length);
        let axes = normalizeAxes;
        let input = context.inputs[0];
        const permutedAxes = getAxesPermutation(axes, context.inputs[0].dims.length);
        if (permutedAxes.length > 0) {
          input = context.compute(createTransposeProgramInfo(context.inputs[0], permutedAxes), {
            inputs: [0],
            outputs: [-1]
          })[0];
          axes = getInnerMostAxes(axes.length, input.dims.length);
        }
        const [outputShape, reduceShape] = computeOutAndReduceShapes(input.dims, axes);
        let finalOutputShape = outputShape;
        if (updatedAttributes.keepDims) {
          finalOutputShape = expandShapeToKeepDim(outputShape, normalizeAxes);
        }
        context.compute(
          createReduceSharedProgramInfo(
            name,
            { hint: updatedAttributes.cacheKey, inputDependencies: ["type"] },
            [input],
            reduceType,
            context.inputs[0].dataType,
            finalOutputShape,
            reduceShape
          ),
          { inputs: [input] }
        );
      };
      reduceMeanShared = (context, attributes) => {
        reduceCommon(context, "ReduceMeanShared", attributes, "mean");
      };
      reduceL1Shared = (context, attributes) => {
        reduceCommon(context, "ReduceL1Shared", attributes, "l1");
      };
      reduceL2Shared = (context, attributes) => {
        reduceCommon(context, "ReduceL2Shared", attributes, "l2");
      };
      reduceLogSumExpShared = (context, attributes) => {
        reduceCommon(context, "ReduceLogSumExpShared", attributes, "logSumExp");
      };
      reduceMaxShared = (context, attributes) => {
        reduceCommon(context, "ReduceMaxShared", attributes, "max");
      };
      reduceMinShared = (context, attributes) => {
        reduceCommon(context, "ReduceMinShared", attributes, "min");
      };
      reduceProdShared = (context, attributes) => {
        reduceCommon(context, "ReduceProdShared", attributes, "prod");
      };
      reduceSumShared = (context, attributes) => {
        reduceCommon(context, "ReduceSumShared", attributes, "sum");
      };
      reduceSumSquareShared = (context, attributes) => {
        reduceCommon(context, "ReduceSumSquareShared", attributes, "sumSquare");
      };
      reduceLogSumShared = (context, attributes) => {
        reduceCommon(context, "ReduceLogSumShared", attributes, "logSum");
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/reduce.ts
  var validateInputs2, noOp, createReduceProgramInfo, createReduceAttributesFromInputs, runReduceProgram, reduceLogSumNaive, reduceL1Naive, reduceL2Naive, reduceLogSumExpNaive, reduceMaxNaive, reduceMeanNaive, reduceMinNaive, reduceProdNaive, reduceSumNaive, reduceSumSquareNaive, useNaiveReduceMethod, reduceMean, reduceL1, reduceL2, reduceLogSumExp, reduceMax, reduceMin, reduceProd, reduceSum, reduceSumSquare, reduceLogSum;
  var init_reduce = __esm({
    "web/lib/wasm/jsep/webgpu/ops/reduce.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      init_reduce_shared();
      validateInputs2 = (inputs) => {
        if (!inputs || inputs.length === 0 || inputs.length > 2) {
          throw new Error("Reduce op requires 1 or 2 inputs.");
        }
        if (inputs.length === 2 && inputs[1].dims.length !== 1) {
          throw new Error("Invalid axes input dims.");
        }
      };
      noOp = (input) => ["", "", `var value = ${input.getByIndices("input_indices")};`, ""];
      createReduceProgramInfo = (name, shaderCache, inputs, reduceOp, axesInput, outputDataType, keepDims = false, noopWithEmptyAxes = false) => {
        const outputShape = [];
        const inputShape = inputs[0].dims;
        const inputRank = inputShape.length;
        const axes = ShapeUtil.normalizeAxes(axesInput, inputRank);
        const reduceOnAllAxes = !noopWithEmptyAxes && axes.length === 0;
        inputShape.forEach((d, i) => {
          if (reduceOnAllAxes || axes.indexOf(i) >= 0) {
            if (keepDims) {
              outputShape.push(1);
            }
          } else {
            outputShape.push(d);
          }
        });
        const outputRank = outputShape.length;
        const outputSize = ShapeUtil.size(outputShape);
        const getShaderSource = (shaderHelper) => {
          const idxCopy = [];
          const input = inputVariable("_A", inputs[0].dataType, inputRank);
          const output = outputVariable("output", outputDataType, outputRank);
          const ops = reduceOp(input, output, axes);
          let reduceOps2 = ops[2];
          for (let k = 0, l = 0; k < inputRank; k++) {
            if (reduceOnAllAxes || axes.indexOf(k) >= 0) {
              if (keepDims) {
                l++;
              }
              reduceOps2 = `for(var j${k}: u32 = 0; j${k} < ${inputShape[k]}; j${k}++) {
                  ${ops[2].includes("last_index") ? `let last_index = j${k};` : ""}
                  ${input.indicesSet("input_indices", k, `j${k}`)}
                  ${reduceOps2}
                }`;
            } else {
              idxCopy.push(`${input.indicesSet("input_indices", k, output.indicesGet("output_indices", l))};`);
              l++;
            }
          }
          return `

        ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}

        ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${input.type.indices};
          let output_indices = ${output.offsetToIndices("global_idx")};

          ${idxCopy.join("\n")}
          ${ops[0]}       // init ops for reduce max/min
          ${ops[1]}
          ${reduceOps2}
          ${ops[3]}
          ${ops.length === 4 ? output.setByOffset("global_idx", "value") : ops.slice(4).join("\n")}
        }`;
        };
        return {
          name,
          shaderCache,
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: outputDataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: outputSize },
              ...createTensorShapeVariables(inputShape, outputShape)
            ]
          })
        };
      };
      createReduceAttributesFromInputs = (inputs, attributes) => {
        const axes = [];
        if (inputs[1].dims[0] > 0) {
          inputs[1].getBigInt64Array().forEach((v) => axes.push(Number(v)));
        }
        return createAttributeWithCacheKey({
          axes,
          keepDims: attributes.keepDims,
          noopWithEmptyAxes: attributes.noopWithEmptyAxes
        });
      };
      runReduceProgram = (context, name, attributes, reduceOp) => {
        const inputs = context.inputs;
        const updatedAttributes = inputs.length === 1 ? attributes : createReduceAttributesFromInputs(inputs, attributes);
        context.compute(
          createReduceProgramInfo(
            name,
            { hint: updatedAttributes.cacheKey, inputDependencies: ["rank"] },
            [inputs[0]],
            updatedAttributes.noopWithEmptyAxes && updatedAttributes.axes.length === 0 ? noOp : reduceOp,
            updatedAttributes.axes,
            inputs[0].dataType,
            updatedAttributes.keepDims,
            updatedAttributes.noopWithEmptyAxes
          ),
          { inputs: [0] }
        );
      };
      reduceLogSumNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var value = ${output.type.storage}(0);`,
          "",
          `value += ${input.getByIndices("input_indices")};`,
          "value = log(value);"
        ];
        runReduceProgram(context, "ReduceLogSum", attributes, reduceOp);
      };
      reduceL1Naive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var value = ${output.type.storage}(0);`,
          "",
          `value += abs(${input.getByIndices("input_indices")});`,
          ""
        ];
        runReduceProgram(context, "ReduceL1", attributes, reduceOp);
      };
      reduceL2Naive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var t = ${output.type.value}(0); var value = ${output.type.value}(0);`,
          "",
          `t = ${input.getByIndices("input_indices")}; value += (t * t);`,
          "value = sqrt(value);"
        ];
        runReduceProgram(context, "ReduceL2", attributes, reduceOp);
      };
      reduceLogSumExpNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var value = ${output.type.storage}(0);`,
          "",
          `value += exp(${input.getByIndices("input_indices")});`,
          "value = log(value);"
        ];
        runReduceProgram(context, "ReduceLogSumExp", attributes, reduceOp);
      };
      reduceMaxNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, _output, axes) => {
          const idxZero = [];
          for (let k = 0; k < input.rank; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
              idxZero.push(input.indicesSet("input_indices", k, 0));
            }
          }
          return [
            `${idxZero.join("\n")}`,
            `var value = ${input.getByIndices("input_indices")};`,
            `value = max(value, ${input.getByIndices("input_indices")});`,
            ""
          ];
        };
        runReduceProgram(context, "ReduceMax", attributes, reduceOp);
      };
      reduceMeanNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output, axes) => {
          let size = 1;
          for (let k = 0; k < input.rank; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
              size *= context.inputs[0].dims[k];
            }
          }
          return [
            "var sum = f32(0);",
            "",
            `sum += f32(${input.getByIndices("input_indices")});`,
            `let value = ${output.type.value}(sum / ${size});`
          ];
        };
        runReduceProgram(context, "ReduceMean", attributes, reduceOp);
      };
      reduceMinNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, _output, axes) => {
          const idxZero = [];
          for (let k = 0; k < input.rank; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
              idxZero.push(`input_indices[${k}] = 0;`);
            }
          }
          return [
            `${idxZero.join("\n")}`,
            `var value = ${input.getByIndices("input_indices")};`,
            `value = min(value, ${input.getByIndices("input_indices")});`,
            ""
          ];
        };
        runReduceProgram(context, "ReduceMin", attributes, reduceOp);
      };
      reduceProdNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var value = ${output.type.storage}(1);`,
          "",
          `value *= ${input.getByIndices("input_indices")};`,
          ""
        ];
        runReduceProgram(context, "ReduceProd", attributes, reduceOp);
      };
      reduceSumNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var value = ${output.type.storage}(0);`,
          "",
          `value += ${input.getByIndices("input_indices")};`,
          ""
        ];
        runReduceProgram(context, "ReduceSum", attributes, reduceOp);
      };
      reduceSumSquareNaive = (context, attributes) => {
        validateInputs2(context.inputs);
        const reduceOp = (input, output) => [
          `var t = ${output.type.value}(0); var value = ${output.type.value}(0);`,
          "",
          `t = ${input.getByIndices("input_indices")}; value += t * t;`,
          ""
        ];
        runReduceProgram(context, "ReduceSumSquare", attributes, reduceOp);
      };
      useNaiveReduceMethod = (shape, axes, noopWithEmptyAxes) => {
        if (axes.length === 0) {
          return noopWithEmptyAxes;
        }
        let outputSize = 1;
        let reduceSize = 1;
        for (let dim = 0; dim < axes.length; dim++) {
          if (axes.indexOf(dim) === -1) {
            outputSize *= shape[dim];
          } else {
            reduceSize *= shape[dim];
          }
        }
        return reduceSize < 32 && outputSize > 1024;
      };
      reduceMean = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceMeanNaive(context, attributes);
        } else {
          reduceMeanShared(context, attributes);
        }
      };
      reduceL1 = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceL1Naive(context, attributes);
        } else {
          reduceL1Shared(context, attributes);
        }
      };
      reduceL2 = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceL2Naive(context, attributes);
        } else {
          reduceL2Shared(context, attributes);
        }
      };
      reduceLogSumExp = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceLogSumExpNaive(context, attributes);
        } else {
          reduceLogSumExpShared(context, attributes);
        }
      };
      reduceMax = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceMaxNaive(context, attributes);
        } else {
          reduceMaxShared(context, attributes);
        }
      };
      reduceMin = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceMinNaive(context, attributes);
        } else {
          reduceMinShared(context, attributes);
        }
      };
      reduceProd = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceProdNaive(context, attributes);
        } else {
          reduceProdShared(context, attributes);
        }
      };
      reduceSum = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceSumNaive(context, attributes);
        } else {
          reduceSumShared(context, attributes);
        }
      };
      reduceSumSquare = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceSumSquareNaive(context, attributes);
        } else {
          reduceSumSquareShared(context, attributes);
        }
      };
      reduceLogSum = (context, attributes) => {
        if (useNaiveReduceMethod(context.inputs[0].dims, attributes.axes, attributes.noopWithEmptyAxes)) {
          reduceLogSumNaive(context, attributes);
        } else {
          reduceLogSumShared(context, attributes);
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/argminmax.ts
  var validateInputs3, argMin, argMax, parseArgMinMaxAttributes;
  var init_argminmax = __esm({
    "web/lib/wasm/jsep/webgpu/ops/argminmax.ts"() {
      "use strict";
      init_wasm_common();
      init_attribute_with_cache_key();
      init_reduce();
      validateInputs3 = (inputs) => {
        if (!inputs || inputs.length === 0 || inputs.length > 2) {
          throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");
        }
        if (inputs[0].dataType !== 1 /* float */) {
          throw new Error("Invalid input type.");
        }
      };
      argMin = (context, attributes) => {
        validateInputs3(context.inputs);
        const argMinMaxOp = (input, output, axes) => {
          const idxZero = [];
          for (let k = 0; k < input.rank; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
              idxZero.push(`input_indices[${k}] = 0;`);
            }
          }
          return [
            `${idxZero.join("\n")}`,
            `var value = ${input.getByIndices("input_indices")};
var best_index : i32 = 0;`,
            `if (${input.getByIndices("input_indices")} ${attributes.selectLastIndex > 0 ? "<=" : "<"} value) {
         value = ${input.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,
            "",
            output.setByOffset("global_idx", "best_index")
          ];
        };
        context.compute(
          createReduceProgramInfo(
            "ArgMin",
            { hint: attributes.cacheKey, inputDependencies: ["rank"] },
            [context.inputs[0]],
            argMinMaxOp,
            [attributes.axis],
            7 /* int64 */,
            attributes.keepDims
          ),
          { inputs: [0] }
        );
      };
      argMax = (context, attributes) => {
        validateInputs3(context.inputs);
        const argMinMaxOp = (input, output, axes) => {
          const idxZero = [];
          for (let k = 0; k < input.rank; k++) {
            if (axes.indexOf(k) >= 0 || axes.length === 0) {
              idxZero.push(`input_indices[${k}] = 0;`);
            }
          }
          return [
            `${idxZero.join("\n")}`,
            `var value = ${input.getByIndices("input_indices")};
var best_index : i32 = 0;`,
            `if (${input.getByIndices("input_indices")} ${attributes.selectLastIndex > 0 ? ">=" : ">"} value) {
         value = ${input.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,
            "",
            output.setByOffset("global_idx", "best_index")
          ];
        };
        context.compute(
          createReduceProgramInfo(
            "argMax",
            { hint: attributes.cacheKey, inputDependencies: ["rank"] },
            [context.inputs[0]],
            argMinMaxOp,
            [attributes.axis],
            7 /* int64 */,
            attributes.keepDims
          ),
          { inputs: [0] }
        );
      };
      parseArgMinMaxAttributes = (attributes) => createAttributeWithCacheKey(attributes);
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/attention.ts
  var validateAttentionInputs, createInPlaceSoftmaxProgramInfo, createAttentionProbsProgramInfo, createVxAttentionScoreProgramInfo, applyAttention, prepare, attention;
  var init_attention = __esm({
    "web/lib/wasm/jsep/webgpu/ops/attention.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_types();
      init_common();
      validateAttentionInputs = (inputs, attributes) => {
        const input = inputs[0];
        const weights = inputs[1];
        const bias = inputs[2];
        const maskIndex = inputs[3];
        const past = inputs[4];
        const attentionBias = inputs[5];
        if (past && attentionBias) {
          throw new Error("Attention cannot have both past and attention_bias");
        }
        if (input.dims.length !== 3) {
          throw new Error('Input "input" must have 3 dimensions');
        }
        const batchSize = input.dims[0];
        const sequenceLength = input.dims[1];
        const inputHiddenSize = input.dims[2];
        if (bias.dims.length !== 1) {
          throw new Error('Input "bias" is expected to have 1 dimensions');
        }
        if (weights.dims.length !== 2) {
          throw new Error('Input "weights" is expected to have 2 dimensions');
        }
        if (weights.dims[0] !== inputHiddenSize) {
          throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");
        }
        if (bias.dims[0] !== weights.dims[1]) {
          throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');
        }
        let qHiddenSize = bias.dims[0] / 3;
        let kHiddenSize = qHiddenSize;
        let vHiddenSize = kHiddenSize;
        if (attributes.qkvHiddenSizes.length > 0) {
          if (attributes.qkvHiddenSizes.length !== 3) {
            throw new Error("qkv_hidden_sizes attribute should have 3 elements");
          }
          for (const sz of attributes.qkvHiddenSizes) {
            if (sz % attributes.numHeads !== 0) {
              throw new Error("qkv_hidden_sizes should be divisible by num_heads");
            }
          }
          qHiddenSize = attributes.qkvHiddenSizes[0];
          kHiddenSize = attributes.qkvHiddenSizes[1];
          vHiddenSize = attributes.qkvHiddenSizes[2];
        }
        const kvSequenceLength = sequenceLength;
        if (qHiddenSize !== kHiddenSize) {
          throw new Error("qkv_hidden_sizes first element should be same as the second");
        }
        if (bias.dims[0] !== qHiddenSize + kHiddenSize + vHiddenSize) {
          throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');
        }
        let pastSequenceLength = 0;
        if (past) {
          if (kHiddenSize !== vHiddenSize) {
            throw new Error('Input "past" expect k_hidden_size == v_hidden_size');
          }
          if (past.dims.length !== 5) {
            throw new Error('Input "past" must have 5 dimensions');
          }
          if (past.dims[0] !== 2) {
            throw new Error('Input "past" first dimension must be 2');
          }
          if (past.dims[1] !== batchSize) {
            throw new Error('Input "past" second dimension must be batch_size');
          }
          if (past.dims[2] !== attributes.numHeads) {
            throw new Error('Input "past" third dimension must be num_heads');
          }
          if (past.dims[4] !== kHiddenSize / attributes.numHeads) {
            throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');
          }
          if (!attributes.pastPresentShareBuffer) {
            pastSequenceLength = past.dims[3];
          }
        }
        const totalSequenceLength = kvSequenceLength + pastSequenceLength;
        const maxSequenceLength = -1;
        const maskType = 0 /* none */;
        if (maskIndex) {
          throw new Error("Mask not supported");
        }
        if (past) {
          throw new Error("past is not supported");
        }
        if (attentionBias) {
          if (attentionBias.dims.length !== 4) {
            throw new Error('Input "attention_bias" must have 4 dimensions');
          }
          if (attentionBias.dims[0] !== batchSize || attentionBias.dims[1] !== attributes.numHeads || attentionBias.dims[2] !== sequenceLength || attentionBias.dims[3] !== totalSequenceLength) {
            throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)');
          }
        }
        return {
          batchSize,
          sequenceLength,
          pastSequenceLength,
          kvSequenceLength,
          totalSequenceLength,
          maxSequenceLength,
          inputHiddenSize,
          hiddenSize: qHiddenSize,
          vHiddenSize,
          headSize: Math.floor(qHiddenSize / attributes.numHeads),
          vHeadSize: Math.floor(vHiddenSize / attributes.numHeads),
          numHeads: attributes.numHeads,
          isUnidirectional: false,
          pastPresentShareBuffer: false,
          maskFilterValue: attributes.maskFilterValue,
          maskType,
          scale: attributes.scale,
          broadcastResPosBias: false,
          passPastInKv: false,
          qkvFormat: 1 /* qkvBNSH */
        };
      };
      createInPlaceSoftmaxProgramInfo = (input, n, d) => {
        const components = getMaxComponents(d);
        let WG = 64;
        const dComp = d / components;
        if (dComp < WG) {
          WG = 32;
        }
        const elementsPerThread = Math.ceil(d / components / WG);
        const programUniforms = [
          { type: 1 /* float */, data: 1 / d },
          { type: 12 /* uint32 */, data: dComp },
          { type: 12 /* uint32 */, data: elementsPerThread }
        ];
        const dataType = tensorTypeToWsglStorageType(input.dataType, components);
        const f32Type = tensorTypeToWsglValueType(1 /* float */, components);
        const inputDependencies = ["type"];
        const getShaderSource = (shaderHelper) => {
          const inputHelper = outputVariable("x", input.dataType, input.dims, components);
          const elemValueType = tensorTypeToWsglValueType(input.dataType);
          const uniforms = [
            { name: "d_inv", type: "f32" },
            { name: "d_comp", type: "u32" },
            { name: "elements_per_thread", type: "u32" }
          ];
          return `
  var<workgroup> thread_max: array<f32, ${WG}>;
  var<workgroup> thread_sum: array<f32, ${WG}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(inputHelper)}
  ${shaderHelper.mainStart([WG, 1, 1])}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${WG}) * uniforms.d_comp + local_offset;

    var thread_max_vector = ${f32Type}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
      thread_max_vector = max(${f32Type}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(() => {
            switch (components) {
              case 1:
                return "thread_max_vector";
              case 2:
                return "max(thread_max_vector.x, thread_max_vector.y)";
              case 4:
                return "max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";
              default:
                throw new Error(`Unsupported components: ${components}`);
            }
          })()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${WG}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${f32Type}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
      sum_vector += exp(${f32Type}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(() => {
            switch (components) {
              case 1:
                return "sum_vector";
              case 2:
                return "sum_vector.x + sum_vector.y";
              case 4:
                return "sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";
              default:
                throw new Error(`Unsupported components: ${components}`);
            }
          })()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${WG}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
        x[offset + i] = ${inputHelper.type.value}(${elemValueType}(uniforms.d_inv));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < uniforms.d_comp; i++) {
        var f32input = ${f32Type}(x[offset + i]);
        x[offset + i] = ${inputHelper.type.value}(exp(f32input - max_value) / sum);
      }
    }
  }`;
        };
        return {
          name: "AttentionProbsSoftmax",
          shaderCache: { hint: `${WG};${dataType};${components}`, inputDependencies },
          getShaderSource,
          getRunData: () => ({ outputs: [], dispatchGroup: { x: n }, programUniforms })
        };
      };
      createAttentionProbsProgramInfo = (outputCount, q, key, pastKey, attentionBias, parameters, attributes, pastSequenceLength) => {
        const totalSequenceLength = pastSequenceLength + parameters.kvSequenceLength;
        const probsShape = [parameters.batchSize, parameters.numHeads, parameters.sequenceLength, totalSequenceLength];
        const presentKey = parameters.kvNumHeads === void 0 && outputCount > 1 && pastKey;
        const presentKeyShape = presentKey ? [parameters.batchSize, parameters.numHeads, totalSequenceLength, parameters.headSize] : void 0;
        const alpha = attributes.scale === 0 ? 1 / Math.sqrt(parameters.headSize) : attributes.scale;
        const components = getMaxComponents(parameters.headSize);
        const vectorizedHeadSize = parameters.headSize / components;
        const TILE_SIZE = 12;
        const dispatch = {
          x: Math.ceil(totalSequenceLength / TILE_SIZE),
          y: Math.ceil(parameters.sequenceLength / TILE_SIZE),
          z: parameters.batchSize * parameters.numHeads
        };
        const programUniforms = [
          { type: 12 /* uint32 */, data: parameters.sequenceLength },
          { type: 12 /* uint32 */, data: vectorizedHeadSize },
          { type: 12 /* uint32 */, data: totalSequenceLength },
          { type: 12 /* uint32 */, data: parameters.numHeads },
          { type: 1 /* float */, data: alpha },
          { type: 12 /* uint32 */, data: pastSequenceLength },
          { type: 12 /* uint32 */, data: parameters.kvSequenceLength }
        ];
        const feedPastKey = presentKey && pastKey && ShapeUtil.size(pastKey.dims) > 0;
        const inputDependencies = ["type", "type"];
        if (feedPastKey) {
          inputDependencies.push("type");
        }
        if (attentionBias) {
          inputDependencies.push("type");
        }
        const outputs = [{ dims: probsShape, dataType: q.dataType, gpuDataType: 0 /* default */ }];
        if (presentKey) {
          outputs.push({ dims: presentKeyShape, dataType: q.dataType, gpuDataType: 0 /* default */ });
        }
        const getShaderSource = (shaderHelper) => {
          const qInput = inputVariable("q", q.dataType, q.dims, components);
          const kInput = inputVariable("key", key.dataType, key.dims, components);
          const inputVars = [qInput, kInput];
          if (feedPastKey) {
            const pastKeyInput = inputVariable("past_key", pastKey.dataType, pastKey.dims, components);
            inputVars.push(pastKeyInput);
          }
          if (attentionBias) {
            inputVars.push(inputVariable("attention_bias", attentionBias.dataType, attentionBias.dims));
          }
          const output = outputVariable("output", q.dataType, probsShape);
          const outputVars = [output];
          if (presentKey) {
            outputVars.push(outputVariable("present_key", q.dataType, presentKeyShape, components));
          }
          const f32Type = tensorTypeToWsglValueType(1 /* float */, components);
          const uniforms = [
            { name: "M", type: "u32" },
            { name: "K", type: "u32" },
            { name: "N", type: "u32" },
            { name: "num_heads", type: "u32" },
            { name: "alpha", type: "f32" },
            { name: "past_sequence_length", type: "u32" },
            { name: "kv_sequence_length", type: "u32" }
          ];
          return `
  const TILE_SIZE = ${TILE_SIZE}u;

  var<workgroup> tileQ: array<${qInput.type.storage}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileK: array<${qInput.type.storage}, ${TILE_SIZE * TILE_SIZE}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, ...outputVars)}
  ${shaderHelper.mainStart([TILE_SIZE, TILE_SIZE, 1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let qOffset = uniforms.M * uniforms.K * headIdx + m * uniforms.K;
    ${(() => {
            if (feedPastKey && presentKey) {
              return `
    let kOffset = uniforms.kv_sequence_length * uniforms.K * headIdx;
    let pastKeyOffset = uniforms.past_sequence_length * uniforms.K * headIdx;`;
            } else {
              return `
    let kOffset = uniforms.N * uniforms.K * headIdx + n * uniforms.K;`;
            }
          })()}
    ${presentKey ? "let presentKeyOffset = headIdx * uniforms.N * uniforms.K;" : ""}
    var value = ${f32Type}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${(() => {
            if (feedPastKey && presentKey) {
              return `
              if (n + local_id.y < uniforms.past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else {
                tileK[idx] =
                         key[kOffset + (n + local_id.y - uniforms.past_sequence_length) * uniforms.K + w + local_id.x];
              }`;
            } else {
              return "tileK[idx] = key[kOffset + local_id.y * uniforms.K + w + local_id.x];";
            }
          })()}
      ${presentKey ? "present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];" : ""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
        value += ${f32Type}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    let headOffset = headIdx * uniforms.M * uniforms.N;
    if (global_id.y < uniforms.M && global_id.x < uniforms.N) {
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(() => {
            switch (components) {
              case 1:
                return "value";
              case 2:
                return "value.x + value.y";
              case 4:
                return "value.x + value.y + value.z + value.w";
              default:
                throw new Error(`Unsupported components: ${components}`);
            }
          })()};
        output[outputIdx] = ${output.type.value} (sum * uniforms.alpha) + ${attentionBias ? "attention_bias[outputIdx]" : "0.0"};
    }
  }`;
        };
        return {
          name: "AttentionProbs",
          shaderCache: {
            hint: `${components};${attentionBias !== void 0};${pastKey !== void 0};${outputCount}`,
            inputDependencies
          },
          getRunData: () => ({ outputs, dispatchGroup: dispatch, programUniforms }),
          getShaderSource
        };
      };
      createVxAttentionScoreProgramInfo = (outputCount, probs, v, pastValue, params, pastSequenceLength) => {
        const totalSequenceLength = pastSequenceLength + params.kvSequenceLength;
        const nReps = params.nReps ? params.nReps : 1;
        const repeatedVHiddenSize = params.vHiddenSize * nReps;
        const presentValue = params.kvNumHeads == null && outputCount > 1 && pastValue;
        const presentValueShape = presentValue ? [params.batchSize, params.numHeads, totalSequenceLength, params.headSize] : void 0;
        const outputShape = [params.batchSize, params.sequenceLength, repeatedVHiddenSize];
        const TILE_SIZE = 12;
        const dispatch = {
          x: Math.ceil(params.vHeadSize / TILE_SIZE),
          y: Math.ceil(params.sequenceLength / TILE_SIZE),
          z: params.batchSize * params.numHeads
        };
        const programUniforms = [
          { type: 12 /* uint32 */, data: params.sequenceLength },
          { type: 12 /* uint32 */, data: totalSequenceLength },
          { type: 12 /* uint32 */, data: params.vHeadSize },
          { type: 12 /* uint32 */, data: params.numHeads },
          { type: 12 /* uint32 */, data: repeatedVHiddenSize },
          { type: 12 /* uint32 */, data: pastSequenceLength },
          { type: 12 /* uint32 */, data: params.kvSequenceLength }
        ];
        const feedPastValue = presentValue && pastValue && ShapeUtil.size(pastValue.dims) > 0;
        const inputDependencies = ["type", "type"];
        if (feedPastValue) {
          inputDependencies.push("type");
        }
        const outputs = [{ dims: outputShape, dataType: probs.dataType, gpuDataType: 0 /* default */ }];
        if (presentValue) {
          outputs.push({ dims: presentValueShape, dataType: probs.dataType, gpuDataType: 0 /* default */ });
        }
        const getShaderSource = (shaderHelper) => {
          const probsHelper = inputVariable("probs", probs.dataType, probs.dims);
          const vHelper = inputVariable("v", v.dataType, v.dims);
          const inputVars = [probsHelper, vHelper];
          if (feedPastValue) {
            inputVars.push(inputVariable("past_value", pastValue.dataType, pastValue.dims));
          }
          const output = outputVariable("output", probs.dataType, outputShape);
          const outputVars = [output];
          if (presentValue) {
            outputVars.push(outputVariable("present_value", probs.dataType, presentValueShape));
          }
          const uniforms = [
            { name: "M", type: "u32" },
            { name: "K", type: "u32" },
            { name: "N", type: "u32" },
            { name: "num_heads", type: "u32" },
            { name: "v_hidden_size", type: "u32" },
            { name: "past_sequence_length", type: "u32" },
            { name: "kv_sequence_length", type: "u32" }
          ];
          return `
  const TILE_SIZE = ${TILE_SIZE}u;
  var<workgroup> tileQ: array<${probsHelper.type.value}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileK: array<${probsHelper.type.value}, ${TILE_SIZE * TILE_SIZE}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, ...outputVars)}
  ${shaderHelper.mainStart([TILE_SIZE, TILE_SIZE, 1])}
   let headIdx = workgroup_id.z;
   let m = global_id.y;
   let n = global_id.x;

   let offsetA = headIdx * (uniforms.M * uniforms.K) + m * uniforms.K;
   ${(() => {
            if (feedPastValue && presentValue) {
              return `
    let pastValueOffset = headIdx * uniforms.N * uniforms.past_sequence_length + n;
    let vOffset = headIdx * uniforms.N * uniforms.kv_sequence_length + n;
      `;
            } else {
              return `
   let offsetB = headIdx * uniforms.N * uniforms.K + n;
            `;
            }
          })()}
    ${presentValue ? "let presentValueOffset = headIdx * uniforms.N * uniforms.K + n;" : ""}
   var value = ${probsHelper.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${(() => {
            if (feedPastValue && presentValue) {
              return `
        if (w + local_id.y < uniforms.past_sequence_length) {
          tileK[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else {
          tileK[idx] = v[vOffset + (w + local_id.y - uniforms.past_sequence_length) * uniforms.N];
        }
      `;
            } else {
              return `
        tileK[idx] = v[offsetB + (w + local_id.y) * uniforms.N];
      `;
            }
          })()}
        ${presentValue ? "present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileK[idx];" : ""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let currentBatchHeadNumber = workgroup_id.z % uniforms.num_heads;
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + currentBatchHeadNumber * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`;
        };
        return {
          name: "AttentionScore",
          shaderCache: { hint: `${pastValue !== void 0};${outputCount}`, inputDependencies },
          getRunData: () => ({ outputs, dispatchGroup: dispatch, programUniforms }),
          getShaderSource
        };
      };
      applyAttention = (context, q, k, v, _maskIndex, _past, pastKey, pastValue, attentionBiasInput, parameters, attributes) => {
        const outputCount = Math.min(context.outputCount, 1 + (pastKey ? 1 : 0) + (pastValue ? 1 : 0));
        const pastSequenceLength = parameters.kvNumHeads !== void 0 || outputCount > 1 ? parameters.pastSequenceLength : 0;
        const totalSequenceLength = pastSequenceLength + parameters.kvSequenceLength;
        const attentionBias = attentionBiasInput && ShapeUtil.size(attentionBiasInput.dims) > 0 ? attentionBiasInput : void 0;
        const inputsK = [q, k];
        if (parameters.kvNumHeads === void 0 && outputCount > 1 && pastKey && ShapeUtil.size(pastKey.dims) > 0) {
          inputsK.push(pastKey);
        }
        if (attentionBias) {
          inputsK.push(attentionBias);
        }
        const probs = context.compute(
          createAttentionProbsProgramInfo(
            outputCount,
            q,
            k,
            pastKey,
            attentionBias,
            parameters,
            attributes,
            pastSequenceLength
          ),
          { inputs: inputsK, outputs: parameters.kvNumHeads === void 0 && outputCount > 1 ? [-1, 1] : [-1] }
        )[0];
        context.compute(
          createInPlaceSoftmaxProgramInfo(
            probs,
            parameters.batchSize * parameters.numHeads * parameters.sequenceLength,
            totalSequenceLength
          ),
          { inputs: [probs], outputs: [] }
        );
        const inputsV = [probs, v];
        if (parameters.kvNumHeads === void 0 && outputCount > 1 && pastValue && ShapeUtil.size(pastValue.dims) > 0) {
          inputsV.push(pastValue);
        }
        context.compute(createVxAttentionScoreProgramInfo(outputCount, probs, v, pastValue, parameters, pastSequenceLength), {
          inputs: inputsV,
          outputs: parameters.kvNumHeads === void 0 && outputCount > 1 ? [0, 2] : [0]
        });
      };
      prepare = (context, parameters) => {
        const outputShape = [parameters.batchSize, parameters.numHeads, parameters.sequenceLength, parameters.headSize];
        const M = parameters.sequenceLength;
        const K = parameters.inputHiddenSize;
        const N = parameters.headSize;
        const TILE_SIZE = 12;
        const dispatch = {
          x: Math.ceil(parameters.headSize / TILE_SIZE),
          y: Math.ceil(parameters.sequenceLength / TILE_SIZE),
          z: parameters.batchSize * parameters.numHeads
        };
        const inputs = [context.inputs[0], context.inputs[1], context.inputs[2]];
        const programUniforms = [
          { type: 12 /* uint32 */, data: M },
          { type: 12 /* uint32 */, data: K },
          { type: 12 /* uint32 */, data: N },
          { type: 12 /* uint32 */, data: parameters.numHeads },
          { type: 12 /* uint32 */, data: parameters.headSize },
          { type: 12 /* uint32 */, data: parameters.hiddenSize },
          { type: 12 /* uint32 */, data: parameters.hiddenSize + parameters.hiddenSize + parameters.vHiddenSize }
        ];
        const getShaderSource = (shaderHelper) => {
          const outputQ = outputVariable("output_q", inputs[0].dataType, outputShape);
          const outputK = outputVariable("output_k", inputs[0].dataType, outputShape);
          const outputV = outputVariable("output_v", inputs[0].dataType, outputShape);
          const input = inputVariable("input", inputs[0].dataType, inputs[0].dims);
          const weight = inputVariable("weight", inputs[1].dataType, inputs[1].dims);
          const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims);
          const dataType = input.type.storage;
          const uniforms = [
            { name: "M", type: "u32" },
            { name: "K", type: "u32" },
            { name: "N", type: "u32" },
            { name: "num_heads", type: "u32" },
            { name: "head_size", type: "u32" },
            { name: "hidden_size", type: "u32" },
            { name: "ldb", type: "u32" }
          ];
          return `
  const TILE_SIZE = ${TILE_SIZE}u;
  var<workgroup> tileInput: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileWeightQ: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileWeightK: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  var<workgroup> tileWeightV: array<${dataType}, ${TILE_SIZE * TILE_SIZE}>;
  ${shaderHelper.registerUniforms(uniforms).declareVariables(input, weight, bias, outputQ, outputK, outputV)}
  ${shaderHelper.mainStart([TILE_SIZE, TILE_SIZE, 1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${dataType}(0);
    var valueK = ${dataType}(0);
    var valueV = ${dataType}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`;
        };
        return context.compute(
          {
            name: "AttentionPrepare",
            shaderCache: { inputDependencies: ["type", "type", "type"] },
            getRunData: () => ({
              outputs: [
                { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ },
                { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ },
                { dims: outputShape, dataType: context.inputs[0].dataType, gpuDataType: 0 /* default */ }
              ],
              dispatchGroup: dispatch,
              programUniforms
            }),
            getShaderSource
          },
          { inputs, outputs: [-1, -1, -1] }
        );
      };
      attention = (context, attributes) => {
        const params = validateAttentionInputs(context.inputs, attributes);
        const [q, k, v] = prepare(context, params);
        return applyAttention(
          context,
          q,
          k,
          v,
          context.inputs[4],
          void 0,
          void 0,
          void 0,
          context.inputs[5],
          params,
          attributes
        );
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/batch-norm.ts
  var validateInputs4, createBatchNormInferenceProgramInfo, parseBatchNormAttributes, batchNorm;
  var init_batch_norm = __esm({
    "web/lib/wasm/jsep/webgpu/ops/batch-norm.ts"() {
      "use strict";
      init_esm();
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs4 = (inputs, attributes) => {
        if (!inputs || inputs.length !== 5) {
          throw new Error("BatchNormalization requires 5 inputs");
        }
        const checkShapeEqual = (actual, expected, message) => {
          const r = expected.length;
          if (r !== actual.length) {
            throw new Error(`${message}: num dimensions != ${r}`);
          }
          expected.forEach((v, i) => {
            if (v !== actual[i]) {
              throw new Error(`${message}: dim[${i}] do not match`);
            }
          });
        };
        if (inputs[0].dims.length > 1) {
          const shape = attributes.format === "NHWC" ? attributes.spatial ? inputs[0].dims.slice(-1) : inputs[0].dims.slice(-1).concat(inputs[0].dims.slice(1, inputs[0].dims.length - 1)) : inputs[0].dims.slice(1, attributes.spatial ? 2 : void 0);
          checkShapeEqual(inputs[1].dims, shape, "Invalid input scale");
          checkShapeEqual(inputs[2].dims, shape, "Invalid input B");
          checkShapeEqual(inputs[3].dims, shape, "Invalid input mean");
          checkShapeEqual(inputs[4].dims, shape, "Invalid input var");
        } else {
          checkShapeEqual(inputs[1].dims, [1], "Invalid input scale");
          checkShapeEqual(inputs[2].dims, [1], "Invalid input B");
          checkShapeEqual(inputs[3].dims, [1], "Invalid input mean");
          checkShapeEqual(inputs[4].dims, [1], "Invalid input var");
        }
      };
      createBatchNormInferenceProgramInfo = (inputs, attributes) => {
        const { epsilon, spatial, format } = attributes;
        const yShape = inputs[0].dims;
        const components = spatial ? getMaxComponents(yShape[yShape.length - 1]) : 1;
        const cComponents = format === "NHWC" && yShape.length > 1 ? components : 1;
        const outputSize = ShapeUtil.size(yShape) / components;
        const useShapesUniforms = spatial;
        const shapeOrRank = useShapesUniforms ? yShape.length : yShape;
        const x = inputVariable("x", inputs[0].dataType, inputs[0].dims, components);
        const scale = inputVariable("scale", inputs[1].dataType, inputs[1].dims, cComponents);
        const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims, cComponents);
        const inputMean = inputVariable("inputMean", inputs[3].dataType, inputs[3].dims, cComponents);
        const inputVar = inputVariable("inputVar", inputs[4].dataType, inputs[4].dims, cComponents);
        const y = outputVariable("y", inputs[0].dataType, shapeOrRank, components);
        const calcCOffset = () => {
          let cOffset = "";
          if (spatial) {
            cOffset = `let cOffset = ${yShape.length === 1 ? "0u" : format === "NHWC" ? `outputIndices[${yShape.length - 1}] / ${components}` : "outputIndices[1]"};`;
          } else {
            if (format === "NCHW") {
              cOffset = `
            ${y.indicesSet("outputIndices", "0", "0")}
            let cOffset = ${y.indicesToOffset("outputIndices")};`;
            } else {
              cOffset = `var cIndices = ${scale.type.indices}(0);
                       cIndices[0] = outputIndices[${yShape.length - 1}];`;
              for (let i = 1; i < scale.rank; i++) {
                cOffset += `cIndices[${i}] = outputIndices[${i}];`;
              }
              cOffset += `let cOffset = ${scale.indicesToOffset("cIndices")};`;
            }
          }
          return cOffset;
        };
        const getInferenceModeShaderSource = (helper) => `
  const epsilon = ${epsilon};
  ${helper.registerUniform("outputSize", "u32").declareVariables(x, scale, bias, inputMean, inputVar, y)}
  ${helper.mainStart()}
  ${helper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${y.offsetToIndices(`global_idx * ${components}`)};
    ${calcCOffset()}
    let scale = ${scale.getByOffset("cOffset")};
    let bias = ${bias.getByOffset("cOffset")};
    let inputMean = ${inputMean.getByOffset("cOffset")};
    let inputVar = ${inputVar.getByOffset("cOffset")};
    let x = ${x.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${y.setByOffset("global_idx", "value")}
  }`;
        return {
          name: "BatchNormalization",
          shaderCache: {
            hint: `${attributes.epsilon}_${attributes.format}_${spatial}_${components}`,
            inputDependencies: useShapesUniforms ? ["rank", "type", "type", "type", "type"] : void 0
          },
          getShaderSource: getInferenceModeShaderSource,
          getRunData: () => ({
            outputs: [{ dims: inputs[0].dims, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: useShapesUniforms ? [{ type: 12 /* uint32 */, data: outputSize }, ...createTensorShapeVariables(yShape)] : [{ type: 12 /* uint32 */, data: outputSize }]
          })
        };
      };
      parseBatchNormAttributes = (attributes) => createAttributeWithCacheKey(attributes);
      batchNorm = (context, attributes) => {
        const { inputs, outputCount } = context;
        const updatedAttributes = parseBatchNormAttributes({ ...attributes, outputCount });
        if (env2.webgpu.validateInputContent) {
          validateInputs4(inputs, updatedAttributes);
        }
        if (attributes.trainingMode) {
          throw new Error("BatchNormalization trainingMode is not supported yet.");
        } else {
          context.compute(createBatchNormInferenceProgramInfo(inputs, updatedAttributes));
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/bias-add.ts
  var validateInputs5, createBiasAddProgramInfo, biasAdd;
  var init_bias_add = __esm({
    "web/lib/wasm/jsep/webgpu/ops/bias-add.ts"() {
      "use strict";
      init_util();
      init_common();
      validateInputs5 = (inputs) => {
        if (inputs[0].dims.length !== 3) {
          throw new Error("input should have 3 dimensions");
        }
        if (![320, 640, 1280].includes(inputs[0].dims[2])) {
          throw new Error("number of channels should be 320, 640 or 1280");
        }
        if (inputs[1].dims.length !== 1) {
          throw new Error("bias is expected to have 1 dimensions");
        }
        if (inputs[0].dims[2] !== inputs[1].dims[0]) {
          throw new Error("last dimension of input and bias are not the same");
        }
      };
      createBiasAddProgramInfo = (inputs) => {
        const outputShape = inputs[0].dims;
        const channels = inputs[0].dims[2];
        const outputSize = ShapeUtil.size(outputShape) / 4;
        const dataType = inputs[0].dataType;
        const input = inputVariable("input", dataType, outputShape, 4);
        const bias = inputVariable("bias", dataType, [channels], 4);
        const residual = inputVariable("residual", dataType, outputShape, 4);
        const output = outputVariable("output", dataType, outputShape, 4);
        const getShaderSource = (shaderHelper) => `
  const channels = ${channels}u / 4;
  ${shaderHelper.declareVariables(input, bias, residual, output)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes(outputSize)}
    let value = ${input.getByOffset("global_idx")}
      + ${bias.getByOffset("global_idx % channels")} + ${residual.getByOffset("global_idx")};
    ${output.setByOffset("global_idx", "value")}
  }`;
        return {
          name: "BiasAdd",
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) }
          }),
          getShaderSource
        };
      };
      biasAdd = (context) => {
        validateInputs5(context.inputs);
        context.compute(createBiasAddProgramInfo(context.inputs));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/unary-op.ts
  var createElementwiseProgramShader, createElementwiseProgramInfo, abs, acos, acosh, asin, asinh, atan, atanh, parseCastAttributes, cast, generateClipAttributesFromInputs, clip, ceil, cos, cosh, parseAlphaAttributes, elu, erfImpl, erf, exp, floor, gelu, leakyRelu, not, neg, reciprocal, relu, sigmoid, parseHardSigmoidAttributes, hardSigmoid, sin, sinh, sqrt, tan, tanhExpression, tanh, fastGeluImpl, fastGeluExpression, fastGelu, thresholdedRelu, log, quickGeluImpl, quickGeluExpression, quickgelu;
  var init_unary_op = __esm({
    "web/lib/wasm/jsep/webgpu/ops/unary-op.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      createElementwiseProgramShader = (shaderHelper, datasize, inputDataType, outputDataType, funcCall, additionalImplementation, additionalUniformsType) => {
        const vecSize = Math.ceil(datasize / 4);
        let expression = "";
        if (typeof funcCall === "string") {
          expression = `${funcCall}(a)`;
        } else {
          expression = funcCall("a");
        }
        const input = inputVariable("inputData", inputDataType, [vecSize], 4);
        const output = outputVariable("outputData", outputDataType, [vecSize], 4);
        const uniforms = [{ name: "vec_size", type: "u32" }];
        if (additionalUniformsType) {
          uniforms.push(...additionalUniformsType);
        }
        return `
      ${shaderHelper.registerUniforms(uniforms).declareVariables(input, output)}

  ${additionalImplementation ?? ""}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${input.getByOffset("global_idx")};
    ${output.setByOffset("global_idx", expression)}
  }`;
      };
      createElementwiseProgramInfo = (input, name, funcCall, additionalImplementation, cacheKey, outputDataType = input.dataType, additionalUniforms, additionalUniformsType) => {
        const programUniforms = [
          { type: 12 /* uint32 */, data: Math.ceil(ShapeUtil.size(input.dims) / 4) }
        ];
        if (additionalUniforms) {
          programUniforms.push(...additionalUniforms);
        }
        return {
          name,
          shaderCache: { hint: cacheKey, inputDependencies: ["type"] },
          getShaderSource: (shaderHelper) => createElementwiseProgramShader(
            shaderHelper,
            ShapeUtil.size(input.dims),
            input.dataType,
            outputDataType,
            funcCall,
            additionalImplementation,
            additionalUniformsType
          ),
          getRunData: (inputTensors) => ({
            outputs: [{ dims: input.dims, dataType: outputDataType }],
            dispatchGroup: {
              x: Math.ceil(
                ShapeUtil.size(inputTensors[0].dims) / 64 / 4
                /* vec size */
              )
            },
            programUniforms
          })
        };
      };
      abs = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Abs", "abs"));
      };
      acos = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Acos", "acos"));
      };
      acosh = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Acosh", "acosh"));
      };
      asin = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Asin", "asin"));
      };
      asinh = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Asinh", "asinh"));
      };
      atan = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Atan", "atan"));
      };
      atanh = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Atanh", "atanh"));
      };
      parseCastAttributes = (attributes) => createAttributeWithCacheKey(attributes);
      cast = (context, attributes) => {
        let func;
        switch (attributes.to) {
          case 10 /* float16 */:
            func = "vec4<f16>";
            break;
          case 1 /* float */:
            func = "vec4<f32>";
            break;
          case 12 /* uint32 */:
            func = "vec4<u32>";
            break;
          case 6 /* int32 */:
            func = "vec4<i32>";
            break;
          case 9 /* bool */:
            func = "vec4<bool>";
            break;
          default:
            throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${attributes.to}`);
        }
        context.compute(
          createElementwiseProgramInfo(context.inputs[0], "Cast", func, void 0, attributes.cacheKey, attributes.to)
        );
      };
      generateClipAttributesFromInputs = (inputs) => {
        let min;
        let max;
        const hasMin = inputs.length >= 2 && inputs[1].data !== 0;
        const hasMax = inputs.length >= 3 && inputs[2].data !== 0;
        switch (inputs[0].dataType) {
          case 1 /* float */:
            min = hasMin ? inputs[1].getFloat32Array()[0] : -34028234663852886e22;
            max = hasMax ? inputs[2].getFloat32Array()[0] : 34028234663852886e22;
            break;
          case 10 /* float16 */:
            min = hasMin ? inputs[1].getUint16Array()[0] : 64511;
            max = hasMax ? inputs[2].getUint16Array()[0] : 31743;
            break;
          default:
            throw new Error("Unsupport data type");
        }
        return createAttributeWithCacheKey({ min, max });
      };
      clip = (context, clipAttributes) => {
        const attributes = clipAttributes ? clipAttributes : generateClipAttributesFromInputs(context.inputs);
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "Clip",
            (a) => `clamp(${a}, vec4<${dataType}>(uniforms.min), vec4<${dataType}>(uniforms.max))`,
            void 0,
            attributes.cacheKey,
            void 0,
            [
              { type: context.inputs[0].dataType, data: attributes.min },
              { type: context.inputs[0].dataType, data: attributes.max }
            ],
            [
              { name: "min", type: dataType },
              { name: "max", type: dataType }
            ]
          ),
          { inputs: [0] }
        );
      };
      ceil = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Ceil", "ceil"));
      };
      cos = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Cos", "cos"));
      };
      cosh = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Cosh", "cosh"));
      };
      parseAlphaAttributes = (attributes) => createAttributeWithCacheKey(attributes);
      elu = (context, attributes) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "Elu",
            (a) => `elu_vf32(${a})`,
            `
  const elu_alpha_ = ${dataType}(${attributes.alpha});

  fn elu_f32(a: ${dataType}) -> ${dataType} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${dataType}>) -> vec4<${dataType}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,
            attributes.cacheKey
          )
        );
      };
      erfImpl = (varType = "f32") => `
const r0: ${varType} = 0.3275911;
const r1: ${varType} = 0.254829592;
const r2: ${varType} = -0.284496736;
const r3: ${varType} = 1.421413741;
const r4: ${varType} = -1.453152027;
const r5: ${varType} = 1.061405429;

fn erf_vf32(v: vec4<${varType}>) -> vec4<${varType}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`;
      erf = (context) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Erf", (a) => `erf_vf32(${a})`, erfImpl(dataType)));
      };
      exp = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Exp", "exp"));
      };
      floor = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Floor", "floor"));
      };
      gelu = (context) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "Gelu",
            (a) => `0.5 * ${a} * (1.0 + erf_vf32(${a} * 0.7071067811865475))`,
            erfImpl(dataType)
          )
        );
      };
      leakyRelu = (context, attributes) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "LeakyRelu",
            (a) => `select(leaky_relu_alpha_ * ${a}, ${a}, ${a} >= vec4<${dataType}>(0.0))`,
            `const leaky_relu_alpha_ = ${dataType}(${attributes.alpha});`,
            attributes.cacheKey
          )
        );
      };
      not = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Not", (a) => `!${a}`));
      };
      neg = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Neg", (a) => `-${a}`));
      };
      reciprocal = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Reciprocal", (a) => `1.0/${a}`));
      };
      relu = (context) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "Relu",
            (a) => `select(vec4<${dataType}>(0.0), ${a}, ${a} > vec4<${dataType}>(0.0))`
          )
        );
      };
      sigmoid = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Sigmoid", (a) => `(1.0 / (1.0 + exp(-${a})))`));
      };
      parseHardSigmoidAttributes = (attributes) => createAttributeWithCacheKey(
        attributes
      );
      hardSigmoid = (context, attributes) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "HardSigmoid",
            (a) => `max(vec4<${dataType}>(0.0), min(vec4<${dataType}>(1.0), ${attributes.alpha} * ${a} + vec4<${dataType}>(${attributes.beta})))`,
            void 0,
            attributes.cacheKey
          )
        );
      };
      sin = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Sin", "sin"));
      };
      sinh = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Sinh", "sinh"));
      };
      sqrt = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Sqrt", "sqrt"));
      };
      tan = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Tan", "tan"));
      };
      tanhExpression = (a) => `sign(${a}) * (1 - exp(-2 * abs(${a}))) / (1 + exp(-2 * abs(${a})))`;
      tanh = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Tanh", tanhExpression));
      };
      fastGeluImpl = (varType = "f32") => `
const fast_gelu_a: ${varType} = 0.5;
const fast_gelu_b: ${varType} = 0.7978845608028654;
const fast_gelu_c: ${varType} = 0.035677408136300125;

fn tanh_v(v: vec4<${varType}>) -> vec4<${varType}> {
  return ${tanhExpression("v")};
}
`;
      fastGeluExpression = (x) => `(fast_gelu_a + fast_gelu_a * tanh_v(${x} * (fast_gelu_c * ${x} * ${x} + fast_gelu_b))) * ${x}`;
      fastGelu = (context) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "FastGelu",
            fastGeluExpression,
            fastGeluImpl(dataType),
            void 0,
            context.inputs[0].dataType
          )
        );
      };
      thresholdedRelu = (context, attributes) => {
        const dataType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "ThresholdedRelu",
            (a) => `select(vec4<${dataType}>(0.0), ${a}, ${a} > thresholded_relu_alpha_)`,
            `const thresholded_relu_alpha_ = vec4<${dataType}>(${attributes.alpha});`,
            attributes.cacheKey
          )
        );
        return 0;
      };
      log = (context) => {
        context.compute(createElementwiseProgramInfo(context.inputs[0], "Log", "log"));
      };
      quickGeluImpl = (varType, alpha) => `
const alpha = vec4<${varType}>(${alpha});
const one = ${varType}(1.0);
const zero = ${varType}(0.0);

fn quick_gelu_impl(x: vec4<${varType}>) -> vec4<${varType}> {
  let v = x *alpha;
  var x1 : vec4<${varType}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`;
      quickGeluExpression = (x) => `quick_gelu_impl(${x})`;
      quickgelu = (context, attributes) => {
        const dType = tensorTypeToWsglValueType(context.inputs[0].dataType);
        context.compute(
          createElementwiseProgramInfo(
            context.inputs[0],
            "QuickGelu",
            quickGeluExpression,
            quickGeluImpl(dType, attributes.alpha),
            attributes.cacheKey,
            context.inputs[0].dataType
          )
        );
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/bias-split-gelu.ts
  var validateInputs6, createBiasSplitGeluProgramInfo, biasSplitGelu;
  var init_bias_split_gelu = __esm({
    "web/lib/wasm/jsep/webgpu/ops/bias-split-gelu.ts"() {
      "use strict";
      init_util();
      init_common();
      init_unary_op();
      validateInputs6 = (inputs) => {
        if (inputs[0].dims.length !== 3) {
          throw new Error("input should have 3 dimensions");
        }
        if (![2560, 5120, 10240].includes(inputs[0].dims[2])) {
          throw new Error("hidden state should be 2560, 5120 or 10240");
        }
        if (inputs[1].dims.length !== 1) {
          throw new Error("bias is expected to have 1 dimensions");
        }
        if (inputs[0].dims[2] !== inputs[1].dims[0]) {
          throw new Error("last dimension of input and bias are not the same");
        }
      };
      createBiasSplitGeluProgramInfo = (inputs) => {
        const outputShape = inputs[0].dims.slice();
        outputShape[2] = outputShape[2] / 2;
        const input = inputVariable("input", inputs[0].dataType, inputs[0].dims, 4);
        const bias = inputVariable("bias", inputs[0].dataType, [inputs[0].dims[2]], 4);
        const output = outputVariable("output", inputs[0].dataType, outputShape, 4);
        const outputSize = ShapeUtil.size(outputShape) / 4;
        const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
        const getShaderSource = (shaderHelper) => `
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${inputs[0].dims[2] / 4 / 2}u;

  ${shaderHelper.declareVariables(input, bias, output)}

  ${erfImpl(dataType)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes(outputSize)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${output.setByOffset("global_idx", "valueLeft * geluRight")}
  }`;
        return {
          name: "BiasSplitGelu",
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) }
          }),
          getShaderSource
        };
      };
      biasSplitGelu = (context) => {
        validateInputs6(context.inputs);
        context.compute(createBiasSplitGeluProgramInfo(context.inputs));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/binary-op.ts
  var createBinaryOpProgramShader, createBinaryOpProgramInfo, runBinaryOp, add, div, equal, mul, pow, sub, greater, less, greaterOrEqual, lessOrEqual;
  var init_binary_op = __esm({
    "web/lib/wasm/jsep/webgpu/ops/binary-op.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      createBinaryOpProgramShader = (shaderHelper, dimsA, dimsB, dimsOutput, vectorize, doBroadcast, sharedDimensionDivisibleBy4, funcCall, typeA, typeB, typeOutput, additionalImplementation) => {
        let expressionScalar;
        let expressionVector;
        if (typeof funcCall === "string") {
          expressionScalar = expressionVector = (a2, b2) => `${funcCall}((${a2}),(${b2}))`;
        } else if (typeof funcCall === "function") {
          expressionScalar = expressionVector = funcCall;
        } else {
          expressionScalar = funcCall.scalar;
          expressionVector = funcCall.vector;
        }
        const output = outputVariable("outputData", typeOutput, dimsOutput.length, 4);
        const a = inputVariable("aData", typeA, dimsA.length, 4);
        const b = inputVariable("bData", typeB, dimsB.length, 4);
        let assignment;
        if (vectorize) {
          if (doBroadcast) {
            const isAOneElement = ShapeUtil.size(dimsA) === 1;
            const isBOneElement = ShapeUtil.size(dimsB) === 1;
            const aLastDimDivisibleBy4 = dimsA.length > 0 && dimsA[dimsA.length - 1] % 4 === 0;
            const bLastDimDivisibleBy4 = dimsB.length > 0 && dimsB[dimsB.length - 1] % 4 === 0;
            if (isAOneElement || isBOneElement) {
              assignment = output.setByOffset(
                "global_idx",
                expressionVector(
                  isAOneElement ? `${a.type.value}(${a.getByOffset("0")}.x)` : a.getByOffset("global_idx"),
                  isBOneElement ? `${b.type.value}(${b.getByOffset("0")}.x)` : b.getByOffset("global_idx")
                )
              );
            } else {
              assignment = `
            let outputIndices = ${output.offsetToIndices("global_idx * 4u")};
            let offsetA = ${a.broadcastedIndicesToOffset("outputIndices", output)};
            let offsetB = ${b.broadcastedIndicesToOffset("outputIndices", output)};
            ${output.setByOffset(
                "global_idx",
                expressionVector(
                  sharedDimensionDivisibleBy4 || aLastDimDivisibleBy4 ? a.getByOffset("offsetA / 4u") : `${a.type.value}(${a.getByOffset("offsetA / 4u")}[offsetA % 4u])`,
                  sharedDimensionDivisibleBy4 || bLastDimDivisibleBy4 ? b.getByOffset("offsetB / 4u") : `${b.type.value}(${b.getByOffset("offsetB / 4u")}[offsetB % 4u])`
                )
              )}
          `;
            }
          } else {
            assignment = output.setByOffset(
              "global_idx",
              expressionVector(a.getByOffset("global_idx"), b.getByOffset("global_idx"))
            );
          }
        } else {
          if (!doBroadcast) {
            throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");
          }
          const singleAssignment = (resStr, x, typeCast = "") => {
            const expressionA = `aData[indexA${x}][componentA${x}]`;
            const expressionB = `bData[indexB${x}][componentB${x}]`;
            return `
            let outputIndices${x} = ${output.offsetToIndices(`global_idx * 4u + ${x}u`)};
            let offsetA${x} = ${a.broadcastedIndicesToOffset(`outputIndices${x}`, output)};
            let offsetB${x} = ${b.broadcastedIndicesToOffset(`outputIndices${x}`, output)};
            let indexA${x} = offsetA${x} / 4u;
            let indexB${x} = offsetB${x} / 4u;
            let componentA${x} = offsetA${x} % 4u;
            let componentB${x} = offsetB${x} % 4u;
            ${resStr}[${x}] = ${typeCast}(${expressionScalar(expressionA, expressionB)});
          `;
          };
          if (typeOutput === 9 /* bool */) {
            assignment = `
            var data = vec4<u32>(0);
            ${singleAssignment("data", 0, "u32")}
            ${singleAssignment("data", 1, "u32")}
            ${singleAssignment("data", 2, "u32")}
            ${singleAssignment("data", 3, "u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`;
          } else {
            assignment = `
            ${singleAssignment("outputData[global_idx]", 0)}
            ${singleAssignment("outputData[global_idx]", 1)}
            ${singleAssignment("outputData[global_idx]", 2)}
            ${singleAssignment("outputData[global_idx]", 3)}
          `;
          }
        }
        return `
        ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(a, b, output)}

        ${additionalImplementation ?? ""}

        ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${assignment}
      }`;
      };
      createBinaryOpProgramInfo = (name, cacheKey, a, b, funcCall, additionalImplementation, outputDataType = a.dataType) => {
        const isBroadcast = !ShapeUtil.areEqual(a.dims, b.dims);
        let outputShape = a.dims;
        let outputSize = ShapeUtil.size(a.dims);
        let vectorize = false;
        let sharedDimensionDivisibleBy4 = false;
        const cacheKeyAux = [isBroadcast];
        if (isBroadcast) {
          const calculatedShape = BroadcastUtil.calcShape(a.dims, b.dims, false);
          if (!calculatedShape) {
            throw new Error("Can't perform binary op on the given tensors");
          }
          outputShape = calculatedShape;
          outputSize = ShapeUtil.size(outputShape);
          const isAOneElement = ShapeUtil.size(a.dims) === 1;
          const isBOneElement = ShapeUtil.size(b.dims) === 1;
          const aLastDimDivisibleBy4 = a.dims.length > 0 && a.dims[a.dims.length - 1] % 4 === 0;
          const bLastDimDivisibleBy4 = b.dims.length > 0 && b.dims[b.dims.length - 1] % 4 === 0;
          cacheKeyAux.push(isAOneElement);
          cacheKeyAux.push(isBOneElement);
          cacheKeyAux.push(aLastDimDivisibleBy4);
          cacheKeyAux.push(bLastDimDivisibleBy4);
          let sharedDimension = 1;
          for (let i = 1; i < outputShape.length; i++) {
            const dimA = a.dims[a.dims.length - i] ?? 1;
            const dimB = b.dims[b.dims.length - i] ?? 1;
            if (dimA === dimB) {
              sharedDimension *= dimA;
            } else {
              break;
            }
          }
          if (sharedDimension % 4 === 0) {
            sharedDimensionDivisibleBy4 = true;
            vectorize = true;
          } else if (isAOneElement || isBOneElement || aLastDimDivisibleBy4 || bLastDimDivisibleBy4) {
            vectorize = true;
          }
        } else {
          vectorize = true;
        }
        cacheKeyAux.push(vectorize);
        return {
          name,
          shaderCache: {
            hint: cacheKey + cacheKeyAux.map((x) => x.toString()).join("_"),
            inputDependencies: ["rank", "rank"]
          },
          getShaderSource: (shaderHelper) => createBinaryOpProgramShader(
            shaderHelper,
            a.dims,
            b.dims,
            outputShape,
            vectorize,
            isBroadcast,
            sharedDimensionDivisibleBy4,
            funcCall,
            a.dataType,
            b.dataType,
            outputDataType,
            additionalImplementation
          ),
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: outputDataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64 / 4
              /* component size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: Math.ceil(ShapeUtil.size(outputShape) / 4) },
              ...createTensorShapeVariables(a.dims, b.dims, outputShape)
            ]
          })
        };
      };
      runBinaryOp = (context, name, funcCall, additionalImplementation, cacheKey, outputDataType) => {
        context.compute(
          createBinaryOpProgramInfo(
            name,
            cacheKey ?? "",
            context.inputs[0],
            context.inputs[1],
            funcCall,
            additionalImplementation,
            outputDataType
          )
        );
      };
      add = (context) => {
        runBinaryOp(context, "Add", (a, b) => `${a}+${b}`);
      };
      div = (context) => {
        runBinaryOp(context, "Div", (a, b) => `${a}/${b}`);
      };
      equal = (context) => {
        runBinaryOp(
          context,
          "Equal",
          { scalar: (a, b) => `u32(${a}==${b})`, vector: (a, b) => `vec4<u32>(${a}==${b})` },
          void 0,
          void 0,
          9 /* bool */
        );
      };
      mul = (context) => {
        runBinaryOp(context, "Mul", (a, b) => `${a}*${b}`);
      };
      pow = (context) => {
        const type = inputVariable("input", context.inputs[0].dataType, context.inputs[0].dims).type.value;
        const roundStr = type === "i32" ? "round" : "";
        runBinaryOp(
          context,
          "Pow",
          { scalar: (a, b) => `pow_custom(${a},${b})`, vector: (a, b) => `pow_vector_custom(${a},${b})` },
          `
    fn pow_custom(a : ${type}, b : ${type}) -> ${type} {
      if (b == ${type}(0.0)) {
        return ${type}(1.0);
      } else if (a < ${type}(0.0) && f32(b) != floor(f32(b))) {
        return ${type}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${type}(1.0), round(f32(abs(b) % ${type}(2.0))) != 1.0) * ${type}(${roundStr}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${type}>, b : vec4<${type}>) -> vec4<${type}> {
      // TODO: implement vectorized pow
      return vec4<${type}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `
        );
      };
      sub = (context) => {
        runBinaryOp(context, "Sub", (a, b) => `${a}-${b}`);
      };
      greater = (context) => {
        runBinaryOp(
          context,
          "Greater",
          { scalar: (a, b) => `u32(${a}>${b})`, vector: (a, b) => `vec4<u32>(${a}>${b})` },
          void 0,
          void 0,
          9 /* bool */
        );
      };
      less = (context) => {
        runBinaryOp(
          context,
          "Less",
          { scalar: (a, b) => `u32(${a}<${b})`, vector: (a, b) => `vec4<u32>(${a}<${b})` },
          void 0,
          void 0,
          9 /* bool */
        );
      };
      greaterOrEqual = (context) => {
        runBinaryOp(
          context,
          "GreaterOrEqual",
          { scalar: (a, b) => `u32(${a}>=${b})`, vector: (a, b) => `vec4<u32>(${a}>=${b})` },
          void 0,
          void 0,
          9 /* bool */
        );
      };
      lessOrEqual = (context) => {
        runBinaryOp(
          context,
          "LessOrEqual",
          { scalar: (a, b) => `u32(${a}<=${b})`, vector: (a, b) => `vec4<u32>(${a}<=${b})` },
          void 0,
          void 0,
          9 /* bool */
        );
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/concat.ts
  var validateInputs7, calculateInputIndexImpl, assignOutputData, createConcatProgramInfo, concat, parseConcatAttributes;
  var init_concat = __esm({
    "web/lib/wasm/jsep/webgpu/ops/concat.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs7 = (inputs, axis) => {
        if (!inputs || inputs.length < 1) {
          throw new Error("too few inputs");
        }
        const referenceIndex = 0;
        const referenceInput = inputs[referenceIndex];
        const inputType = referenceInput.dataType;
        const inputRank = referenceInput.dims.length;
        inputs.forEach((input, i) => {
          if (i === referenceIndex) {
            return;
          }
          if (input.dataType !== inputType) {
            throw new Error("input tensors should be one type");
          }
          if (input.dims.length !== inputRank) {
            throw new Error("input tensors should have the same shape");
          }
          input.dims.forEach((dim, i2) => {
            if (i2 !== axis && dim !== referenceInput.dims[i2]) {
              throw new Error("non concat dimensions must match");
            }
          });
        });
      };
      calculateInputIndexImpl = (numberOfTensors, sizeInConcatAxisStr) => `
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${numberOfTensors}u>(${sizeInConcatAxisStr});
    for (var i: u32 = 0u; i < ${numberOfTensors}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${numberOfTensors}u;
  }`;
      assignOutputData = (inputs, output) => {
        const numberOfTensors = inputs.length;
        const codeLines = [];
        for (let i = 0; i < numberOfTensors; ++i) {
          const returnSnippet = output.setByOffset("global_idx", inputs[i].getByIndices("indices"));
          if (numberOfTensors === 1) {
            codeLines.push(returnSnippet);
          } else if (i === 0) {
            codeLines.push(`if (inputIndex == ${i}u) { ${returnSnippet} }`);
          } else if (i === numberOfTensors - 1) {
            codeLines.push(`else { ${returnSnippet} }`);
          } else {
            codeLines.push(`else if (inputIndex == ${i}) { ${returnSnippet} }`);
          }
        }
        return codeLines.join("\n");
      };
      createConcatProgramInfo = (inputs, adjustedAxis, outputShape, dataType) => {
        const outputSize = ShapeUtil.size(outputShape);
        const sizeInConcatAxis = new Array(inputs.length);
        const inputVars = new Array(inputs.length);
        let previousSum = 0;
        const inputDependencies = [];
        const inputRanks = [];
        const programUniforms = [{ type: 12 /* uint32 */, data: outputSize }];
        for (let i = 0; i < inputs.length; ++i) {
          previousSum += inputs[i].dims[adjustedAxis];
          sizeInConcatAxis[i] = previousSum;
          inputRanks.push(inputs[i].dims.length);
          inputVars[i] = inputVariable(`input${i}`, dataType, inputRanks[i]);
          inputDependencies.push("rank");
          programUniforms.push({ type: 12 /* uint32 */, data: sizeInConcatAxis[i] });
        }
        for (let i = 0; i < inputs.length; ++i) {
          programUniforms.push(...createTensorShapeVariables(inputs[i].dims));
        }
        programUniforms.push(...createTensorShapeVariables(outputShape));
        const output = outputVariable("output", dataType, outputShape.length);
        const indicesAxis = output.indicesGet("indices", adjustedAxis);
        const sizeInConcatAxisStr = Array.from(Array(sizeInConcatAxis.length).keys()).map((i) => `uniforms.sizeInConcatAxis${i}`).join(",");
        const getShaderSource = (shaderHelper) => `

  ${(() => {
          shaderHelper.registerUniform("outputSize", "u32");
          for (let i = 0; i < inputs.length; i++) {
            shaderHelper.registerUniform(`sizeInConcatAxis${i}`, "u32");
          }
          return shaderHelper.declareVariables(...inputVars, output);
        })()}

  ${calculateInputIndexImpl(sizeInConcatAxis.length, sizeInConcatAxisStr)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${output.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${indicesAxis});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${sizeInConcatAxis.length}u>(${sizeInConcatAxisStr});
      ${indicesAxis} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${assignOutputData(inputVars, output)}
  }`;
        return {
          name: "Concat",
          shaderCache: { hint: `${adjustedAxis}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      concat = (context, attributes) => {
        const inputs = context.inputs;
        const inputShape = inputs[0].dims;
        const adjustedAxis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);
        validateInputs7(inputs, adjustedAxis);
        const outputShape = inputShape.slice();
        outputShape[adjustedAxis] = inputs.reduce(
          (sum, input) => sum + (input.dims.length > adjustedAxis ? input.dims[adjustedAxis] : 0),
          0
        );
        const nonEmptyInputs = inputs.filter((input) => ShapeUtil.size(input.dims) > 0);
        context.compute(createConcatProgramInfo(nonEmptyInputs, adjustedAxis, outputShape, inputs[0].dataType), {
          inputs: nonEmptyInputs
        });
      };
      parseConcatAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/fuse-utils.ts
  var getActivationSnippet, appendActivationUniformsData, appendActivationUniforms, parseInternalActivationAttributes;
  var init_fuse_utils = __esm({
    "web/lib/wasm/jsep/webgpu/ops/fuse-utils.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      getActivationSnippet = (attributes, valueType, baseType = "f32") => {
        switch (attributes.activation) {
          case "Relu":
            return `value = max(value, ${valueType}(0.0));`;
          case "Sigmoid":
            return `value = (${valueType}(1.0) / (${valueType}(1.0) + exp(-value)));`;
          case "Clip":
            return `value = clamp(value, ${valueType}(${baseType}(uniforms.clip_min)), ${valueType}(${baseType}(uniforms.clip_max)));`;
          case "HardSigmoid":
            return `value = max(${valueType}(0.0), min(${valueType}(1.0), ${baseType}(uniforms.alpha) * value + ${baseType}(uniforms.beta)));`;
          case "LeakyRelu":
            return `value = select(${baseType}(uniforms.alpha) * value, value, value >= ${valueType}(0.0));`;
          case "Tanh":
            return `let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;
          case "":
            return "";
          default:
            throw new Error(`Unsupported activation ${attributes.activation}`);
        }
      };
      appendActivationUniformsData = (attributes, programUniform) => {
        if (attributes.activation === "Clip") {
          programUniform.push(
            { type: 1 /* float */, data: attributes.clipMax },
            { type: 1 /* float */, data: attributes.clipMin }
          );
        } else if (attributes.activation === "HardSigmoid") {
          programUniform.push(
            { type: 1 /* float */, data: attributes.alpha },
            { type: 1 /* float */, data: attributes.beta }
          );
        } else if (attributes.activation === "LeakyRelu") {
          programUniform.push({ type: 1 /* float */, data: attributes.alpha });
        }
      };
      appendActivationUniforms = (attributes, uniforms) => {
        if (attributes.activation === "Clip") {
          uniforms.push({ name: "clip_max", type: "f32" }, { name: "clip_min", type: "f32" });
        } else if (attributes.activation === "HardSigmoid") {
          uniforms.push({ name: "alpha", type: "f32" }, { name: "beta", type: "f32" });
        } else if (attributes.activation === "LeakyRelu") {
          uniforms.push({ name: "alpha", type: "f32" });
        }
      };
      parseInternalActivationAttributes = (attributes) => {
        const activation = attributes?.activation || "";
        if (activation === "HardSigmoid") {
          const [alpha, beta] = attributes?.activation_params || [0.2, 0.5];
          return { activation, alpha, beta };
        } else if (activation === "Clip") {
          const [clipMin, clipMax] = attributes?.activation_params || [MIN_CLIP, MAX_CLIP];
          return { activation, clipMax, clipMin };
        } else if (activation === "LeakyRelu") {
          const [alpha] = attributes?.activation_params || [0.01];
          return { activation, alpha };
        }
        return { activation };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/3rd-party/activation_util.ts
  var typeSnippet, biasSnippet;
  var init_activation_util = __esm({
    "web/lib/wasm/jsep/webgpu/ops/3rd-party/activation_util.ts"() {
      "use strict";
      typeSnippet = (component, dataType) => {
        switch (component) {
          case 1:
            return dataType;
          case 2:
            return `vec2<${dataType}>`;
          case 3:
            return `vec3<${dataType}>`;
          case 4:
            return `vec4<${dataType}>`;
          default:
            throw new Error(`${component}-component is not supported.`);
        }
      };
      biasSnippet = (hasBias) => `
      ${hasBias ? "value = value + getBiasByOutputCoords(coords);" : ""}
      `;
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_util.ts
  var utilFunctions;
  var init_conv_util = __esm({
    "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_util.ts"() {
      "use strict";
      utilFunctions = (strideStr) => `
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${strideStr}.x), i32(${strideStr}.y), i32(${strideStr}.z), 1));
}
`;
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/3rd-party/matmul_packed_webgpu.ts
  var writeDataToSubAVec4Snippet, calculateResultSnippet, makeMatMulPackedVec4Source, writeDataToSubASnippet, readDataFromSubASnippet, makeMatMulPackedSource, matMulReadWriteFnSource, createMatmulProgramInfo;
  var init_matmul_packed_webgpu = __esm({
    "web/lib/wasm/jsep/webgpu/ops/3rd-party/matmul_packed_webgpu.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      init_fuse_utils();
      init_activation_util();
      writeDataToSubAVec4Snippet = (transpose2, batchDims) => {
        if (transpose2) {
          return `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${batchDims ? ", batchIndices" : ""});
        `;
        } else {
          return `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${batchDims ? ", batchIndices" : ""});
        `;
        }
      };
      calculateResultSnippet = (transposeA, innerElementSize) => {
        if (transposeA) {
          return `
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${innerElementSize === 3 ? "" : "let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${innerElementSize === 3 ? "" : "acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`;
        } else {
          return `
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${innerElementSize === 3 ? "" : "acc[i] = BCached3 * ACached.w + acc[i];"}
        }`;
        }
      };
      makeMatMulPackedVec4Source = (workPerThread, workgroupSize, type = "f32", batchDims, transposeA = false, tileInner = 32, splitK = false, splitedDimInner = 32) => {
        const tileAOuter = workgroupSize[1] * workPerThread[1];
        const tileBOuter = workgroupSize[0] * workPerThread[0];
        const tileAWidth = transposeA ? tileAOuter : tileInner;
        const tileAHight = transposeA ? tileInner : tileAOuter;
        const innerElementSize = tileAWidth / workgroupSize[0];
        const rowPerThreadB = tileInner / workgroupSize[1];
        if (!((transposeA && innerElementSize === 4 && workPerThread[1] === 4 || !transposeA && (innerElementSize === 3 || innerElementSize === 4)) && tileAWidth % workgroupSize[0] === 0 && tileInner % workgroupSize[1] === 0 && workPerThread[0] === 4)) {
          throw new Error(`If transposeA ${transposeA} is true, innerElementSize ${innerElementSize} and workPerThread[1] ${workPerThread[1]} must be 4.
      Otherwise, innerElementSize ${innerElementSize} must be 3 or 4.
  tileAWidth ${tileAWidth} must be divisible by workgroupSize[0]${workgroupSize[0]}. tileInner ${tileInner} must be divisible by workgroupSize[1] ${workgroupSize[1]}. colPerThread ${workPerThread[0]} must be 4.`);
        }
        return `
var<workgroup> mm_Asub: array<array<vec${innerElementSize}<${type}>, ${tileAWidth / innerElementSize}>, ${tileAHight}>;
var<workgroup> mm_Bsub: array<array<vec4<${type}>, ${tileBOuter / workPerThread[0]}>, ${tileInner}>;

const rowPerThread = ${workPerThread[1]};
const colPerThread = ${workPerThread[0]};
const innerElementSize = ${innerElementSize};
const tileInner = ${tileInner};

@compute @workgroup_size(${workgroupSize[0]}, ${workgroupSize[1]}, ${workgroupSize[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${splitK ? "0" : "i32(globalId.z)"};
  ${batchDims ? `let batchIndices = ${batchDims.offsetToIndices("u32(batch)")};` : ""}
  let globalRowStart = i32(workgroupId.y) * ${tileAOuter};

  let num_tiles = ${splitK ? `${Math.ceil(splitedDimInner / tileInner)}` : "(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${splitK ? `i32(globalId.z) * ${splitedDimInner}` : "0"};

  var acc: array<vec4<${type}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${rowPerThreadB};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${writeDataToSubAVec4Snippet(transposeA, batchDims)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${rowPerThreadB}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${batchDims ? ", batchIndices" : ""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${innerElementSize === 3 ? "" : "let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${calculateResultSnippet(transposeA, innerElementSize)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`;
      };
      writeDataToSubASnippet = (transpose2, batchDims) => {
        if (transpose2) {
          return `
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${batchDims ? ", batchIndices" : ""});
            `;
        } else {
          return `
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${batchDims ? ", batchIndices" : ""});
            `;
        }
      };
      readDataFromSubASnippet = (transposeA) => transposeA ? "let ACached = mm_Asub[k][tileRow + innerRow];" : "let ACached = mm_Asub[tileRow + innerRow][k];";
      makeMatMulPackedSource = (workPerThread, workgroupSize, type = "f32", batchDims, transposeA = false, tileInner = 32, splitK = false, splitedDimInner = 32, sequentialAccessByThreads = false) => {
        const tileAOuter = workPerThread[1] * workgroupSize[1];
        const tileBOuter = workPerThread[0] * workgroupSize[0];
        const tileAWidth = transposeA ? tileAOuter : tileInner;
        const tileAHight = transposeA ? tileInner : tileAOuter;
        if (!(tileAHight % workgroupSize[1] === 0 && tileAWidth % workgroupSize[0] === 0 && tileInner % workgroupSize[1] === 0)) {
          throw new Error(
            `tileAHight ${tileAHight} must be divisible by workgroupSize[1]${workgroupSize[1]}, tileAWidth ${tileAWidth} must be divisible by workgroupSize[0]${workgroupSize[0]}, tileInner ${tileInner} must be divisible by workgroupSize[1]${workgroupSize[1]}`
          );
        }
        const rowPerThreadA = tileAHight / workgroupSize[1];
        const colPerThreadA = tileAWidth / workgroupSize[0];
        const rowPerThreadB = tileInner / workgroupSize[1];
        const matmulSnippet = sequentialAccessByThreads ? `
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${tileAOuter};
    let globalColStart = i32(workgroupId.x) * ${tileBOuter};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${tileAHight}; inputRow = inputRow + ${workgroupSize[1]}) {
        for (var inputCol = localCol; inputCol < ${tileAWidth}; inputCol = inputCol + ${workgroupSize[0]}) {
          ${writeDataToSubASnippet(transposeA, batchDims)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${tileInner}; inputRow = inputRow + ${workgroupSize[1]}) {
            for (var inputCol = localCol; inputCol < ${tileBOuter}; inputCol = inputCol + ${workgroupSize[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${batchDims ? ", batchIndices" : ""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${type}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${workgroupSize[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${transposeA ? `mm_Asub[k][localRow + innerRow * ${workgroupSize[1]}];` : `mm_Asub[localRow + innerRow * ${workgroupSize[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${workgroupSize[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${workgroupSize[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    ` : `
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${tileAOuter};

let tileRowA = i32(localId.y) * ${rowPerThreadA};
let tileColA = i32(localId.x) * ${colPerThreadA};
let tileRowB = i32(localId.y) * ${rowPerThreadB};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${rowPerThreadA}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${colPerThreadA}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${writeDataToSubASnippet(transposeA, batchDims)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${rowPerThreadB}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${batchDims ? ", batchIndices" : ""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${type}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${readDataFromSubASnippet(transposeA)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;
        return `
  var<workgroup> mm_Asub : array<array<${type}, ${tileAWidth}>, ${tileAHight}>;
  var<workgroup> mm_Bsub : array<array<${type}, ${tileBOuter}>, ${tileInner}>;
  const rowPerThread = ${workPerThread[1]};
  const colPerThread = ${workPerThread[0]};
  const tileInner = ${tileInner};

@compute @workgroup_size(${workgroupSize[0]}, ${workgroupSize[1]}, ${workgroupSize[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${splitK ? "0" : "i32(globalId.z)"};
    ${batchDims ? `let batchIndices = ${batchDims.offsetToIndices("u32(batch)")};` : ""}
    let num_tiles = ${splitK ? `${Math.ceil(splitedDimInner / tileInner)}` : "(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${splitK ? `i32(globalId.z) * ${splitedDimInner}` : "0"};

    var acc : array<array<${type}, colPerThread>, rowPerThread>;
    ${matmulSnippet}
  }
`;
      };
      matMulReadWriteFnSource = (component, hasBias, applyActivation, variables, batchShapes, isChannelsLast = false) => {
        const [batchAShape, batchBShape, batchShape] = batchShapes;
        const [batchVariable, aVariable, bVariable, outputVariable2] = variables;
        const broadCastADims = getBroadcastDims(batchAShape, batchShape);
        const broadCastBDims = getBroadcastDims(batchBShape, batchShape);
        const dataType = tensorTypeToWsglStorageType(variables[0].type.tensor);
        const getAIndices = () => {
          const aRank = aVariable.rank;
          const batchRank = batchVariable.rank;
          let resStr = `var aIndices: ${aVariable.type.indices};`;
          for (let i = aRank - 2 - 1, j = batchRank - 1; i >= 0; i--, j--) {
            resStr += `
aIndices[${i}] = ${batchRank > 1 ? `batchIndices[${j}]` : "batchIndices"};`;
          }
          broadCastADims.forEach((i) => {
            resStr += `
aIndices[${i}] = 0;`;
          });
          resStr += `
aIndices[${aRank - 2}] = u32(row);
                   aIndices[${aRank - 1}] = u32(colIn);`;
          return resStr;
        };
        const getBIndices = () => {
          const bRank = bVariable.rank;
          const batchRank = batchVariable.rank;
          let resStr = `var bIndices: ${bVariable.type.indices};`;
          for (let i = bRank - 2 - 1, j = batchRank - 1; i >= 0; i--, j--) {
            resStr += `
bIndices[${i}] = ${batchRank > 1 ? `batchIndices[${j}]` : "batchIndices"};`;
          }
          broadCastBDims.forEach((i) => {
            resStr += `
bIndices[${i}] = 0;`;
          });
          resStr += `
bIndices[${bRank - 2}] = u32(row);
                   bIndices[${bRank - 1}] = u32(colIn);`;
          return resStr;
        };
        const source = `
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${batchVariable.type.indices}) -> ${typeSnippet(
          component,
          dataType
        )} {
      var value = ${typeSnippet(component, dataType)}(0.0);
      let col = colIn * ${component};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        ${getAIndices()}
        value = ${aVariable.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${batchVariable.type.indices}) -> ${typeSnippet(
          component,
          dataType
        )} {
      var value = ${typeSnippet(component, dataType)}(0.0);
      let col = colIn * ${component};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        ${getBIndices()}
        value = ${bVariable.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${typeSnippet(component, dataType)}) {
      let col = colIn * ${component};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${hasBias ? `value = value + ${isChannelsLast ? "bias[colIn]" : `${typeSnippet(component, dataType)}(bias[row])`};` : ""}
        ${applyActivation}
        ${outputVariable2.setByIndices("vec3<u32>(coords)", "value")}
      }
    }
    `;
        return source;
      };
      createMatmulProgramInfo = (inputs, activationAttributes, outputShape, reshapedOutputShape, isChannelsLast = false, squeezeOutputShapeFunction) => {
        const aShape = inputs[0].dims;
        const bShape = inputs[1].dims;
        const outerDimsA = aShape.slice(0, -2);
        const outerDimsB = bShape.slice(0, -2);
        const outerDims = reshapedOutputShape ? reshapedOutputShape.slice(0, -2) : outputShape.slice(0, -2);
        const batchSize = ShapeUtil.size(outerDims);
        const dimAOuter = aShape[aShape.length - 2];
        const dimInner = aShape[aShape.length - 1];
        const dimBOuter = bShape[bShape.length - 1];
        const isVec4 = dimInner % 4 === 0 && dimBOuter % 4 === 0;
        const elementsPerThread = dimAOuter <= 8 ? [4, 1, 1] : [4, 4, 1];
        const workgroupSize = [8, 8, 1];
        const dispatch = [
          Math.ceil(dimBOuter / workgroupSize[0] / elementsPerThread[0]),
          Math.ceil(dimAOuter / workgroupSize[1] / elementsPerThread[1]),
          Math.ceil(batchSize / workgroupSize[2] / elementsPerThread[2])
        ];
        const components = isVec4 ? 4 : 1;
        const aShapeTemp = [...outerDimsA, dimAOuter, dimInner / components];
        const aRank = aShapeTemp.length;
        const bShapeTemp = [...outerDimsB, dimInner, dimBOuter / components];
        const bRank = bShapeTemp.length;
        const outputShapeTemp = [batchSize, dimAOuter, dimBOuter / components];
        const programUniforms = [
          { type: 6 /* int32 */, data: dimAOuter },
          { type: 6 /* int32 */, data: dimBOuter },
          { type: 6 /* int32 */, data: dimInner }
        ];
        appendActivationUniformsData(activationAttributes, programUniforms);
        programUniforms.push(...createTensorShapeVariables(outerDims, aShapeTemp, bShapeTemp));
        const inputDependencies = ["rank", "rank"];
        const hasBias = inputs.length > 2;
        if (hasBias) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
          inputDependencies.push("rank");
        }
        programUniforms.push(...createTensorShapeVariables(outputShapeTemp));
        const getShaderSource = (shaderHelper) => {
          const batchRank = outerDims.length;
          const batchDims = internalVariable("batchDims", inputs[0].dataType, batchRank, 1);
          const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
          const A = inputVariable("a", inputs[0].dataType, aRank, components);
          const B = inputVariable("b", inputs[1].dataType, bRank, components);
          const output = outputVariable("result", inputs[0].dataType, outputShapeTemp.length, components);
          const inputVariables = [A, B];
          if (hasBias) {
            const biasComponents = isChannelsLast ? components : 1;
            inputVariables.push(inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, biasComponents));
          }
          const uniforms = [
            { name: "dim_a_outer", type: "i32" },
            { name: "dim_b_outer", type: "i32" },
            { name: "dim_inner", type: "i32" }
          ];
          appendActivationUniforms(activationAttributes, uniforms);
          const baseType = tensorTypeToWsglStorageType(output.type.tensor);
          const applyActivation = getActivationSnippet(activationAttributes, output.type.value, baseType);
          const declareFunctions = matMulReadWriteFnSource(
            components,
            hasBias,
            applyActivation,
            [batchDims, A, B, output],
            [outerDimsA, outerDimsB, outerDims],
            isChannelsLast
          );
          return `
  ${shaderHelper.registerUniforms(uniforms).registerInternalVariables(batchDims).declareVariables(...inputVariables, output)}
  ${declareFunctions}
  ${isVec4 ? makeMatMulPackedVec4Source(elementsPerThread, workgroupSize, dataType, batchDims) : makeMatMulPackedSource(elementsPerThread, workgroupSize, dataType, batchDims)}
                   `;
        };
        return {
          name: "MatMul",
          shaderCache: {
            hint: `${elementsPerThread};${activationAttributes.activation};${isVec4};${isChannelsLast}`,
            inputDependencies
          },
          getRunData: () => ({
            outputs: [
              {
                dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
                dataType: inputs[0].dataType
              }
            ],
            dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
            programUniforms
          }),
          getShaderSource
        };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/3rd-party/conv2d_mm_webgpu.ts
  var conv2dCommonSnippet, createConv2DMatMulProgramInfo;
  var init_conv2d_mm_webgpu = __esm({
    "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv2d_mm_webgpu.ts"() {
      "use strict";
      init_wasm_common();
      init_log();
      init_common();
      init_fuse_utils();
      init_activation_util();
      init_conv_util();
      init_matmul_packed_webgpu();
      conv2dCommonSnippet = (isChannelsLast, fitAOuter, fitBOuter, fitInner, addBias = false, attributes, innerElementSizeX = 4, innerElementSizeW = 4, innerElementSize = 4, dataType = "f32") => {
        const getXSnippet = (innerElementSize2) => {
          switch (innerElementSize2) {
            case 1:
              return "resData = x[xIndex];";
            case 3:
              return `resData = vec3<${dataType}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;
            case 4:
              return "resData = x[xIndex / 4];";
            default:
              throw new Error(`innerElementSize ${innerElementSize2} is not supported.`);
          }
        };
        const getWSnippet = (innerElementSize2) => {
          switch (innerElementSize2) {
            case 1:
              return "return w[row * i32(uniforms.w_shape[3]) + colIn];";
            case 4:
              return "return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";
            default:
              throw new Error(`innerElementSize ${innerElementSize2} is not supported.`);
          }
        };
        const coordASnippet = isChannelsLast ? `
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    ` : `
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `;
        const coordResSnippet = isChannelsLast ? `
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    ` : `
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `;
        const xHeight = isChannelsLast ? "i32(uniforms.x_shape[1])" : "i32(uniforms.x_shape[2])";
        const xWidth = isChannelsLast ? "i32(uniforms.x_shape[2])" : "i32(uniforms.x_shape[3])";
        const row = isChannelsLast ? "row" : "col";
        const col = isChannelsLast ? "col" : "row";
        const readXSnippet = `
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
    let outRow = ${row} / outWidth;
    let outCol = ${row} % outWidth;

    let WRow = ${col} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${col} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${col} % inChannels;
    var resData = ${typeSnippet(innerElementSizeX, dataType)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${xHeight} && xCol >= 0 && xCol < ${xWidth}) {
      ${coordASnippet}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${getXSnippet(innerElementSizeX)}
    }
    return resData;`;
        const sampleX = isChannelsLast ? fitAOuter && fitInner ? `
    let col = colIn * ${innerElementSizeX};
    ${readXSnippet}` : `
    let col = colIn * ${innerElementSizeX};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${readXSnippet}
    }
    return ${typeSnippet(innerElementSizeX, dataType)}(0.0);` : fitInner && fitBOuter ? `
    let col = colIn * ${innerElementSizeX};
    ${readXSnippet}` : `
    let col = colIn * ${innerElementSizeX};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${readXSnippet}
    }
    return ${typeSnippet(innerElementSizeX, dataType)}(0.0);`;
        const sampleW = `${getWSnippet(innerElementSizeW)}`;
        const resType = typeSnippet(innerElementSize, dataType);
        const aType = isChannelsLast ? typeSnippet(innerElementSizeX, dataType) : typeSnippet(innerElementSizeW, dataType);
        const bType = isChannelsLast ? typeSnippet(innerElementSizeW, dataType) : typeSnippet(innerElementSizeX, dataType);
        const applyActivation = getActivationSnippet(attributes, resType, dataType);
        const userCode = `
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${aType} {
      ${isChannelsLast ? sampleX : sampleW}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${bType} {
      ${isChannelsLast ? sampleW : sampleX}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${resType}) {
      let col = colIn * ${innerElementSize};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
      ${coordResSnippet}
      ${biasSnippet(addBias)}
      ${applyActivation}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`;
        return userCode;
      };
      createConv2DMatMulProgramInfo = (inputs, attributes, outputShape, dimAOuter, dimBOuter, dimInner, hasBias, sequentialAccessByThreads, squeezeOutputShapeFunction) => {
        const isChannelsLast = attributes.format === "NHWC";
        const inChannels = isChannelsLast ? inputs[0].dims[3] : inputs[0].dims[1];
        const batchSize = outputShape[0];
        const outWidth = isChannelsLast ? outputShape[2] : outputShape[3];
        const outHeight = isChannelsLast ? outputShape[1] : outputShape[2];
        const outChannels = isChannelsLast ? outputShape[3] : outputShape[1];
        const isVec4 = isChannelsLast && (inChannels % 4 === 0 || inChannels % 3 === 0) && outChannels % 4 === 0;
        const dispatchX = isChannelsLast ? outChannels : outWidth * outHeight;
        const dispatchY = isChannelsLast ? outWidth * outHeight : outChannels;
        const workGroupSize = [8, 8, 1];
        const elementsPerThread = dimAOuter <= 8 ? [4, 1, 1] : [4, 4, 1];
        const dispatch = [
          Math.ceil(dispatchX / workGroupSize[0] / elementsPerThread[0]),
          Math.ceil(dispatchY / workGroupSize[1] / elementsPerThread[1]),
          Math.ceil(batchSize / workGroupSize[2] / elementsPerThread[2])
        ];
        LOG_DEBUG("verbose", () => `[conv2d_mm_webgpu] dispatch = ${dispatch}`);
        const innerElementSize = isVec4 ? isChannelsLast && inChannels % 4 !== 0 ? 3 : 4 : 1;
        const tileAOuter = workGroupSize[1] * elementsPerThread[1];
        const tileBOuter = workGroupSize[0] * elementsPerThread[0];
        const tileInner = Math.max(workGroupSize[0] * innerElementSize, workGroupSize[1]);
        const fitAOuter = dimAOuter % tileAOuter === 0;
        const fitBOuter = dimBOuter % tileBOuter === 0;
        const fitInner = dimInner % tileInner === 0;
        const elementsSize = isVec4 ? [innerElementSize, 4, 4] : [1, 1, 1];
        const programUniforms = [
          { type: 6 /* int32 */, data: dimAOuter },
          { type: 6 /* int32 */, data: dimBOuter },
          { type: 6 /* int32 */, data: dimInner },
          { type: 6 /* int32 */, data: [attributes.pads[0], attributes.pads[1]] },
          { type: 6 /* int32 */, data: attributes.strides },
          { type: 6 /* int32 */, data: attributes.dilations }
        ];
        appendActivationUniformsData(attributes, programUniforms);
        programUniforms.push(...createTensorShapeVariables(inputs[0].dims, inputs[1].dims));
        const inputDependencies = ["rank", "rank"];
        if (hasBias) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
          inputDependencies.push("rank");
        }
        programUniforms.push(...createTensorShapeVariables(outputShape));
        const getShaderSource = (shaderHelper) => {
          const uniforms = [
            { name: "dim_a_outer", type: "i32" },
            { name: "dim_b_outer", type: "i32" },
            { name: "dim_inner", type: "i32" },
            { name: "pad", type: "i32", length: 2 },
            { name: "stride", type: "i32", length: 2 },
            { name: "dilation", type: "i32", length: 2 }
          ];
          appendActivationUniforms(attributes, uniforms);
          const components = isVec4 ? 4 : 1;
          const t = tensorTypeToWsglStorageType(inputs[0].dataType);
          let declareFunctions = `
      fn setOutputAtIndex(flatIndex : i32, value : ${isVec4 ? `vec4<${t}>` : t}) {
        result[flatIndex] = ${isVec4 ? `vec4<${t}>` : t}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${isVec4 ? `vec4<${t}>` : t}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${isVec4 ? "/ 4" : ""}, value);
      }`;
          const x = inputVariable(
            "x",
            inputs[0].dataType,
            inputs[0].dims.length,
            innerElementSize === 3 ? 1 : innerElementSize
          );
          const w = inputVariable("w", inputs[1].dataType, inputs[1].dims.length, components);
          const inputVariables = [x, w];
          const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
          if (hasBias) {
            const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, components);
            inputVariables.push(bias);
            declareFunctions += `
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${isVec4 ? `vec4<${t}>` : t} {
          return bias[coords.${isChannelsLast ? "w" : "y"}${isVec4 ? "/ 4" : ""}];
        }`;
          }
          return `
        ${utilFunctions("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
        ${declareFunctions}
        ${conv2dCommonSnippet(
            isChannelsLast,
            fitAOuter,
            fitBOuter,
            fitInner,
            hasBias,
            attributes,
            elementsSize[0],
            elementsSize[1],
            elementsSize[2],
            t
          )}
        ${isVec4 ? makeMatMulPackedVec4Source(elementsPerThread, workGroupSize, t, void 0, !isChannelsLast, tileInner) : makeMatMulPackedSource(
            elementsPerThread,
            workGroupSize,
            t,
            void 0,
            !isChannelsLast,
            tileInner,
            false,
            void 0,
            sequentialAccessByThreads
          )}`;
        };
        return {
          name: "Conv2DMatMul",
          shaderCache: {
            hint: `${attributes.cacheKey};${innerElementSize};${isVec4};${fitAOuter};${fitBOuter};${fitInner};${tileAOuter};${tileBOuter};${tileInner}`,
            inputDependencies
          },
          getRunData: () => ({
            outputs: [
              {
                dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
                dataType: inputs[0].dataType
              }
            ],
            dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
            programUniforms
          }),
          getShaderSource
        };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/3rd-party/conv3d_naive_webgpu.ts
  var arrayProduct, parse3TupleParam, getEffectiveFilterSize, computeDefaultPad, computeOutputShape4D, get3DPadAndOutInfo, computeConv3DInfo, createConv3DNaiveProgramInfo;
  var init_conv3d_naive_webgpu = __esm({
    "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv3d_naive_webgpu.ts"() {
      "use strict";
      init_wasm_common();
      init_log();
      init_util();
      init_common();
      init_fuse_utils();
      init_activation_util();
      arrayProduct = (arr) => {
        let product = 1;
        for (let i = 0; i < arr.length; i++) {
          product *= arr[i];
        }
        return product;
      };
      parse3TupleParam = (param) => typeof param === "number" ? [param, param, param] : param;
      getEffectiveFilterSize = (filterSize, dilation) => {
        if (dilation <= 1) {
          return filterSize;
        }
        return filterSize + (filterSize - 1) * (dilation - 1);
      };
      computeDefaultPad = (inputShape, fieldSize, stride, dilation = 1) => {
        const effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);
        return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);
      };
      computeOutputShape4D = (inShape, filterShape, outChannels, strides, zeroPad) => {
        if (zeroPad == null) {
          zeroPad = computeDefaultPad(inShape, filterShape[0], strides[0]);
        }
        const outShape = [0, 0, 0, outChannels];
        for (let index = 0; index < 3; index++) {
          if (inShape[index] + 2 * zeroPad >= filterShape[index]) {
            outShape[index] = Math.trunc((inShape[index] - filterShape[index] + 2 * zeroPad) / strides[index] + 1);
          }
        }
        return outShape;
      };
      get3DPadAndOutInfo = (pad2, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth) => {
        let padInfo;
        let outDepth;
        let outHeight;
        let outWidth;
        if (pad2 === "VALID") {
          pad2 = 0;
        }
        if (typeof pad2 === "number") {
          padInfo = { top: pad2, bottom: pad2, left: pad2, right: pad2, front: pad2, back: pad2 };
          const outShape = computeOutputShape4D(
            [inDepth, inHeight, inWidth, 1],
            [filterDepth, filterHeight, filterWidth],
            1,
            [strideDepth, strideHeight, strideWidth],
            pad2
          );
          outDepth = outShape[0];
          outHeight = outShape[1];
          outWidth = outShape[2];
        } else if (Array.isArray(pad2)) {
          if (!pad2.every((val, _, arr) => val === arr[0])) {
            throw Error(`Unsupported padding parameter: ${pad2}`);
          }
          padInfo = { top: pad2[0], bottom: pad2[1], left: pad2[2], right: pad2[3], front: pad2[4], back: pad2[5] };
          const outShape = computeOutputShape4D(
            [inDepth, inHeight, inWidth, 1],
            [filterDepth, filterHeight, filterWidth],
            1,
            [strideDepth, strideHeight, strideWidth],
            pad2[0]
          );
          outDepth = outShape[0];
          outHeight = outShape[1];
          outWidth = outShape[2];
        } else if (pad2 === "SAME_UPPER") {
          outDepth = Math.ceil(inDepth / strideDepth);
          outHeight = Math.ceil(inHeight / strideHeight);
          outWidth = Math.ceil(inWidth / strideWidth);
          const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;
          const padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
          const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
          const front = Math.floor(padAlongDepth / 2);
          const back = padAlongDepth - front;
          const top = Math.floor(padAlongHeight / 2);
          const bottom = padAlongHeight - top;
          const left = Math.floor(padAlongWidth / 2);
          const right = padAlongWidth - left;
          padInfo = { top, bottom, left, right, front, back };
        } else {
          throw Error(`Unknown padding parameter: ${pad2}`);
        }
        return { padInfo, outDepth, outHeight, outWidth };
      };
      computeConv3DInfo = (inShape, filterShape, strides, dilations, pad2, depthwise = false, dataFormat = "channelsLast") => {
        let batchSize, inDepth, inHeight, inWidth, inChannels;
        if (dataFormat === "channelsLast") {
          [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;
        } else if (dataFormat === "channelsFirst") {
          [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;
        } else {
          throw new Error(`Unknown dataFormat ${dataFormat}`);
        }
        const [filterChannels, , filterDepth, filterHeight, filterWidth] = filterShape;
        const [strideDepth, strideHeight, strideWidth] = parse3TupleParam(strides);
        const [dilationDepth, dilationHeight, dilationWidth] = parse3TupleParam(dilations);
        const effectiveFilterDepth = getEffectiveFilterSize(filterDepth, dilationDepth);
        const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
        const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
        const { padInfo, outDepth, outHeight, outWidth } = get3DPadAndOutInfo(
          pad2,
          inDepth,
          inHeight,
          inWidth,
          strideDepth,
          strideHeight,
          strideWidth,
          effectiveFilterDepth,
          effectiveFilterHeight,
          effectiveFilterWidth
        );
        const outChannels = depthwise ? filterChannels * inChannels : filterChannels;
        let outShape = [0, 0, 0, 0, 0];
        if (dataFormat === "channelsFirst") {
          outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];
        } else if (dataFormat === "channelsLast") {
          outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];
        }
        return {
          batchSize,
          dataFormat,
          inDepth,
          inHeight,
          inWidth,
          inChannels,
          outDepth,
          outHeight,
          outWidth,
          outChannels,
          padInfo,
          strideDepth,
          strideHeight,
          strideWidth,
          filterDepth,
          filterHeight,
          filterWidth,
          effectiveFilterDepth,
          effectiveFilterHeight,
          effectiveFilterWidth,
          dilationDepth,
          dilationHeight,
          dilationWidth,
          inShape,
          outShape,
          filterShape
        };
      };
      createConv3DNaiveProgramInfo = (inputs, attributes, outputShape, filterDims, pads, dataFormat) => {
        const isChannelLast = dataFormat === "channelsLast";
        const inChannels = isChannelLast ? inputs[0].dims[3] : inputs[0].dims[1];
        const isVec4 = false;
        const workGroupSize = [64, 1, 1];
        const dispatchLayout = { x: outputShape.map((_, i) => i) };
        const dispatch = [Math.ceil(arrayProduct(dispatchLayout.x.map((d) => outputShape[d])) / workGroupSize[0]), 1, 1];
        LOG_DEBUG("verbose", () => `[conv3d_naive_webgpu] dispatch = ${dispatch}`);
        const innerElementSize = isVec4 ? isChannelLast && inChannels % 4 !== 0 ? 3 : 4 : 1;
        const outputSize = ShapeUtil.size(outputShape);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: filterDims },
          { type: 12 /* uint32 */, data: pads },
          { type: 12 /* uint32 */, data: attributes.strides },
          { type: 12 /* uint32 */, data: attributes.dilations }
        ];
        appendActivationUniformsData(attributes, programUniforms);
        programUniforms.push(...createTensorShapeVariables(inputs[0].dims, inputs[1].dims));
        const inputDependencies = ["rank", "rank"];
        const hasBias = inputs.length === 3;
        if (hasBias) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
          inputDependencies.push("rank");
        }
        programUniforms.push(...createTensorShapeVariables(outputShape));
        const getShaderSource = (shaderHelper) => {
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "filter_dims", type: "u32", length: filterDims.length },
            { name: "pads", type: "u32", length: pads.length },
            { name: "strides", type: "u32", length: attributes.strides.length },
            { name: "dilations", type: "u32", length: attributes.dilations.length }
          ];
          appendActivationUniforms(attributes, uniforms);
          const components = isVec4 ? 4 : 1;
          const t = tensorTypeToWsglStorageType(inputs[0].dataType);
          const x = inputVariable(
            "x",
            inputs[0].dataType,
            inputs[0].dims.length,
            innerElementSize === 3 ? 1 : innerElementSize
          );
          const w = inputVariable("W", inputs[1].dataType, inputs[1].dims.length, components);
          const inputVariables = [x, w];
          const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
          let declareFunctions = "";
          if (hasBias) {
            const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, components);
            inputVariables.push(bias);
            declareFunctions += `
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${isVec4 ? `vec4<${t}>` : t} {
          return bias[${isChannelLast ? getElementAt("coords", 4, 5) : getElementAt("coords", 1, 5)}${isVec4 ? "/ 4" : ""}];
        }`;
          }
          const resType = typeSnippet(innerElementSize, t);
          const applyActivation = getActivationSnippet(attributes, resType, t);
          return `
            ${declareFunctions}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${x.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${w.getByIndices("aIndices")};
            }
          ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
          ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${output.offsetToIndices("global_idx")};
              let batch = ${getElementAt("coords", 0, x.rank)};
              let d2 = ${isChannelLast ? getElementAt("coords", x.rank - 1, x.rank) : getElementAt("coords", 1, x.rank)};
              let xFRCCorner = vec3<u32>(${isChannelLast ? getElementAt("coords", 1, x.rank) : getElementAt("coords", 2, x.rank)},
              ${isChannelLast ? getElementAt("coords", 2, x.rank) : getElementAt("coords", 3, x.rank)},
              ${isChannelLast ? getElementAt("coords", 3, x.rank) : getElementAt("coords", 4, x.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${isChannelLast ? getElementAt("uniforms.x_shape", 1, x.rank) : getElementAt("uniforms.x_shape", 2, x.rank)};
              let xShapeZ = ${isChannelLast ? getElementAt("uniforms.x_shape", 2, x.rank) : getElementAt("uniforms.x_shape", 3, x.rank)};
              let xShapeW = ${isChannelLast ? getElementAt("uniforms.x_shape", 3, x.rank) : getElementAt("uniforms.x_shape", 4, x.rank)};
              let xShapeU = ${isChannelLast ? getElementAt("uniforms.x_shape", 4, x.rank) : getElementAt("uniforms.x_shape", 1, x.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${isChannelLast ? `let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            ` : `let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${isChannelLast ? `value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);` : `value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${isChannelLast ? `let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      ` : `let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${isChannelLast ? `let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      ` : `let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${hasBias ? "value = value + getBiasByOutputCoords(coords)" : ""};
              ${applyActivation}
              result[global_idx] = f32(value);
          }`;
        };
        return {
          name: "Conv3DNaive",
          shaderCache: { hint: `${attributes.cacheKey};${isChannelLast};${innerElementSize};${hasBias}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
            programUniforms
          }),
          getShaderSource
        };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/conv-grouped.ts
  var createGroupedConvProgramInfo, createGroupedConvVectorizeProgramInfo;
  var init_conv_grouped = __esm({
    "web/lib/wasm/jsep/webgpu/ops/conv-grouped.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      init_fuse_utils();
      createGroupedConvProgramInfo = (inputs, attributes, outputShape, squeezeOutputShapeFunction) => {
        const hasBias = inputs.length > 2;
        const processBias = hasBias ? "value += b[output_channel];" : "";
        const xShape = inputs[0].dims;
        const wShape = inputs[1].dims;
        const isChannelLast = attributes.format === "NHWC";
        const outputChannels = isChannelLast ? outputShape[3] : outputShape[1];
        const outputChannelsPerGroup = outputChannels / attributes.group;
        const components = isChannelLast && outputChannelsPerGroup >= 4 ? getMaxComponents(outputChannels) : 1;
        const outputSize = ShapeUtil.size(outputShape) / components;
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: attributes.dilations },
          { type: 12 /* uint32 */, data: [attributes.strides[0], attributes.strides[1]] },
          { type: 12 /* uint32 */, data: [attributes.pads[0], attributes.pads[1]] },
          { type: 12 /* uint32 */, data: outputChannelsPerGroup }
        ];
        appendActivationUniformsData(attributes, programUniforms);
        programUniforms.push(
          ...createTensorShapeVariables(xShape, [wShape[0], wShape[1], wShape[2], wShape[3] / components])
        );
        const inputDependencies = hasBias ? ["rank", "rank", "rank"] : ["rank", "rank"];
        programUniforms.push(
          ...createTensorShapeVariables([outputShape[0], outputShape[1], outputShape[2], outputShape[3] / components])
        );
        const getShaderSource = (shaderHelper) => {
          const output = outputVariable("output", inputs[0].dataType, outputShape.length, components);
          const baseType = tensorTypeToWsglStorageType(output.type.tensor);
          const applyActivation = getActivationSnippet(attributes, output.type.value, baseType);
          const x = inputVariable("x", inputs[0].dataType, xShape.length);
          const w = inputVariable("w", inputs[1].dataType, wShape.length, components);
          const inputVars = [x, w];
          if (hasBias) {
            inputVars.push(inputVariable("b", inputs[2].dataType, inputs[2].dims, components));
          }
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "dilations", type: "u32", length: attributes.dilations.length },
            { name: "strides", type: "u32", length: 2 },
            { name: "pads", type: "u32", length: 2 },
            { name: "output_channels_per_group", type: "u32" }
          ];
          appendActivationUniforms(attributes, uniforms);
          const calculateResult = isChannelLast ? `
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${x.get("batch", "xHeight", "xWidth", "input_channel")};
            let wVal = ${w.get("wHeight", "wWidth", "wInChannel", "output_channel")};
            value += xVal * wVal;
          }
        }
      }
      ` : `
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${x.get("batch", "input_channel", "xHeight", "xWidth")};
            let wVal = ${w.get("output_channel", "wInChannel", "wHeight", "wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;
          return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, output)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${output.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${isChannelLast ? 3 : 1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${isChannelLast ? 1 : 2}], outputIndices[${isChannelLast ? 2 : 3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${components} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${isChannelLast ? 2 : 1}];

    var value: ${output.type.value} = ${output.type.value}(0);
    ${calculateResult}
    ${processBias}
    ${applyActivation}
    ${output.setByOffset("global_idx", "value")}
  }`;
        };
        return {
          name: "GroupedConv",
          shaderCache: { hint: `${attributes.cacheKey}_${components}`, inputDependencies },
          getRunData: () => ({
            outputs: [
              {
                dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
                dataType: inputs[0].dataType
              }
            ],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      createGroupedConvVectorizeProgramInfo = (inputs, attributes, outputShape, squeezeOutputShapeFunction) => {
        const hasBias = inputs.length > 2;
        const components = getMaxComponents(outputShape[3]);
        const outputNumber = getMaxComponents(outputShape[2]);
        const outputSize = ShapeUtil.size(outputShape) / components / outputNumber;
        const xShape = [inputs[0].dims[0], inputs[0].dims[1], inputs[0].dims[2], inputs[0].dims[3] / components];
        const wShape = [inputs[1].dims[0], inputs[1].dims[1], inputs[1].dims[2], inputs[1].dims[3] / components];
        const outputShapeInShader = [outputShape[0], outputShape[1], outputShape[2], outputShape[3] / components];
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 6 /* int32 */, data: [attributes.strides[0], attributes.strides[1]] },
          { type: 6 /* int32 */, data: [attributes.pads[0], attributes.pads[1]] }
        ];
        appendActivationUniformsData(attributes, programUniforms);
        programUniforms.push(...createTensorShapeVariables(xShape, wShape, outputShapeInShader));
        const xNumber = (outputNumber - 1) * attributes.strides[1] + wShape[1];
        const getShaderSource = (shaderHelper) => {
          const output = outputVariable("output", inputs[0].dataType, outputShapeInShader.length, components);
          const baseType = tensorTypeToWsglStorageType(output.type.tensor);
          const applyActivation = getActivationSnippet(attributes, output.type.value, baseType);
          const x = inputVariable("x", inputs[0].dataType, xShape.length, components);
          const w = inputVariable("w", inputs[1].dataType, wShape.length, components);
          const inputVars = [x, w];
          if (hasBias) {
            inputVars.push(inputVariable("b", inputs[2].dataType, inputs[2].dims, components));
          }
          const processBias = hasBias ? "value += b[output_channel];" : "";
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "strides", type: "i32", length: 2 },
            { name: "pads", type: "i32", length: 2 }
          ];
          appendActivationUniforms(attributes, uniforms);
          return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVars, output)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${outputNumber}u;
    let col = (index1 % width1) * ${outputNumber}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${x.type.value}, ${xNumber}>;
    var values: array<${output.type.value}, ${outputNumber}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${wShape[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${xNumber}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${x.get("batch", "u32(x_height)", "u32(x_width)", "input_channel")};
          } else {
            x_vals[i] = ${x.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${wShape[1]}; w_width++) {
          let w_val = ${w.get("w_height", "w_width", "0", "output_channel")};
          for (var i = 0u; i < ${outputNumber}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${outputNumber}u; i++) {
      var value = values[i];
      ${processBias}
      ${applyActivation}
      ${output.set("batch", "row", "col + i", "output_channel", "value")};
    }
  }`;
        };
        return {
          name: "GroupedConv-Vectorize",
          shaderCache: {
            hint: `${attributes.cacheKey};${components};${outputNumber};${xNumber};${wShape[0]};${wShape[1]}`,
            inputDependencies: hasBias ? ["rank", "rank", "type"] : ["rank", "rank"]
          },
          getRunData: () => ({
            outputs: [
              {
                dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
                dataType: inputs[0].dataType
              }
            ],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/matmul.ts
  var createNaiveMatmulProgramInfo, validateInputs8, matMul;
  var init_matmul = __esm({
    "web/lib/wasm/jsep/webgpu/ops/matmul.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_matmul_packed_webgpu();
      init_common();
      init_fuse_utils();
      createNaiveMatmulProgramInfo = (inputs, activationAttributes, outputShape, reshapedOutputShape, isChannelsLast = false, squeezeOutputShapeFunction) => {
        const aShape = inputs[0].dims;
        const bShape = inputs[1].dims;
        const M = aShape[aShape.length - 2];
        const N = bShape[bShape.length - 1];
        const K = aShape[aShape.length - 1];
        const components = getMaxComponents(N);
        const aComponents = getMaxComponents(K);
        const outputNumber = getMaxComponents(M);
        const outputSize = ShapeUtil.size(outputShape) / components / outputNumber;
        const hasBias = inputs.length > 2;
        const outerDims = reshapedOutputShape ? reshapedOutputShape.slice(0, -2) : outputShape.slice(0, -2);
        const batchSize = ShapeUtil.size(outerDims);
        const outputShapeInShader = [batchSize, M, N];
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: M },
          { type: 12 /* uint32 */, data: N },
          { type: 12 /* uint32 */, data: K }
        ];
        appendActivationUniformsData(activationAttributes, programUniforms);
        programUniforms.push(...createTensorShapeVariables(outerDims, aShape, bShape));
        if (hasBias) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        }
        programUniforms.push(...createTensorShapeVariables(outputShapeInShader));
        const getShaderSource = (shaderHelper) => {
          const batchDims = internalVariable("batch_dims", inputs[0].dataType, outerDims.length);
          const a = inputVariable("a", inputs[0].dataType, aShape.length, aComponents);
          const b = inputVariable("b", inputs[1].dataType, bShape.length, components);
          const output = outputVariable("output", inputs[0].dataType, outputShapeInShader.length, components);
          const baseType = tensorTypeToWsglStorageType(output.type.tensor);
          const applyActivation = getActivationSnippet(activationAttributes, output.type.value, baseType);
          const inputVariables = [a, b];
          let processBias = "";
          if (hasBias) {
            const biasComponents = isChannelsLast ? components : 1;
            inputVariables.push(inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, biasComponents));
            processBias = `${isChannelsLast ? `value += bias[col / ${biasComponents}];` : `value += ${output.type.value}(bias[row + i]);`}`;
          }
          const outerDimsA = aShape.slice(0, -2);
          const outerDimsB = bShape.slice(0, -2);
          const broadCastADims = getBroadcastDims(outerDimsA, outerDims);
          const broadCastBDims = getBroadcastDims(outerDimsB, outerDims);
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "M", type: "u32" },
            { name: "N", type: "u32" },
            { name: "K", type: "u32" }
          ];
          appendActivationUniforms(activationAttributes, uniforms);
          const getIndices = (variable, broadCastDims) => {
            const rank = variable.rank;
            const name = variable.name;
            if (rank === 2) {
              return `var ${name}_indices = ${variable.type.indices}(0u, 0u);`;
            }
            const batchRank = batchDims.rank;
            let resStr = `var ${name}_indices: ${variable.type.indices};`;
            for (let i = rank - 2 - 1, j = batchRank - 1; i >= 0; i--, j--) {
              resStr += `
${name}_indices[${i}] = ${batchRank > 1 ? `batch_indices[${j}]` : "batch_indices"};`;
            }
            broadCastDims.forEach((i) => {
              resStr += `
${name}_indices[${i}] = 0;`;
            });
            resStr += `${name}_indices[${rank - 2}] = 0u;
                     ${name}_indices[${rank - 1}] = 0u;`;
            return resStr;
          };
          const calcResult = () => {
            let calcStr = `var a_data: ${a.type.value};`;
            for (let i = 0; i < aComponents; i++) {
              calcStr += `
              let b_data${i} = b[(b_offset + (k + ${i}) * uniforms.N + col) / ${components}];`;
            }
            for (let i = 0; i < outputNumber; i++) {
              calcStr += `a_data = a[(a_offset + (row + ${i}) * uniforms.K + k) / ${aComponents}];`;
              for (let j = 0; j < aComponents; j++) {
                calcStr += `
            values[${i}] = fma(${b.type.value}(a_data${aComponents === 1 ? "" : `[${j}]`}), b_data${j}, values[${i}]);
`;
              }
            }
            return calcStr;
          };
          return `
  ${shaderHelper.registerUniforms(uniforms).registerInternalVariables(batchDims).declareVariables(...inputVariables, output)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${components})) * ${components};
    var index1 = global_idx / (uniforms.N / ${components});
    let stride1 = uniforms.M / ${outputNumber};
    let row = (index1 % stride1) * ${outputNumber};
    let batch = index1 / stride1;

    ${outputShape.length === 2 ? "" : `let batch_indices = ${batchDims.offsetToIndices("batch")};`}
    ${getIndices(a, broadCastADims)}
    let a_offset = ${a.indicesToOffset("a_indices")};
    ${getIndices(b, broadCastBDims)}
    let b_offset = ${b.indicesToOffset("b_indices")};
    var values: array<${output.type.value}, ${outputNumber}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${aComponents}) {
      ${calcResult()}
    }
    for (var i = 0u; i < ${outputNumber}u; i++) {
      var value = values[i];
      ${processBias}
      ${applyActivation}
      let cur_indices = ${output.type.indices}(batch, row + i, col);
      let offset = ${output.indicesToOffset("cur_indices")};
      ${output.setByOffset(`offset / ${components}`, "value")};
    }
  }
  `;
        };
        return {
          name: "MatMulNaive",
          shaderCache: {
            hint: `${activationAttributes.activation};${components};${aComponents};${outputNumber};${isChannelsLast}`,
            inputDependencies: hasBias ? ["rank", "rank", "rank"] : ["rank", "rank"]
          },
          getRunData: () => ({
            outputs: [
              {
                dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
                dataType: inputs[0].dataType
              }
            ],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      validateInputs8 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("MatMul requires 2 inputs.");
        }
        if (inputs[0].dims[inputs[0].dims.length - 1] !== inputs[1].dims[inputs[1].dims.length - 2]) {
          throw new Error("shared dimension does not match.");
        }
      };
      matMul = (context) => {
        validateInputs8(context.inputs);
        const outputShape = BroadcastUtil.calcShape(context.inputs[0].dims, context.inputs[1].dims, true);
        if (!outputShape) {
          throw new Error("Can't use matmul on the given tensors");
        }
        const N = outputShape[outputShape.length - 1];
        const K = context.inputs[0].dims[context.inputs[0].dims.length - 1];
        if (N < 8 && K < 8) {
          context.compute(createNaiveMatmulProgramInfo(context.inputs, { activation: "" }, outputShape));
        } else {
          context.compute(createMatmulProgramInfo(context.inputs, { activation: "" }, outputShape));
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/conv.ts
  var calculateOutputShape, weightTransposeAttribute, validateInputs9, getAdjustedConvAttributes, parseConvAttributes, conv2d, conv1d, conv3d, conv;
  var init_conv = __esm({
    "web/lib/wasm/jsep/webgpu/ops/conv.ts"() {
      "use strict";
      init_util();
      init_conv2d_mm_webgpu();
      init_conv3d_naive_webgpu();
      init_matmul_packed_webgpu();
      init_conv_grouped();
      init_fuse_utils();
      init_matmul();
      init_transpose();
      calculateOutputShape = (inputShape, kernelShape, dilations, adjustPads, strides, isChannelLast) => {
        const batchSize = inputShape[0];
        const inputSpatialShape = inputShape.slice(isChannelLast ? 1 : 2, isChannelLast ? 3 : 4);
        const spatialRank = inputSpatialShape.length;
        const outChannels = kernelShape[0];
        const kernelSpatialShape = kernelShape.slice(2);
        const dilatedKernelShape = kernelSpatialShape.map((v, i) => v + (v - 1) * (dilations[i] - 1));
        const inputSpatialShapeWithPad = inputSpatialShape.map((v, i) => v + adjustPads[i] + adjustPads[i + spatialRank]);
        const outputShape = inputSpatialShapeWithPad.map(
          (v, i) => Math.floor((v - dilatedKernelShape[i] + strides[i]) / strides[i])
        );
        outputShape.splice(0, 0, batchSize);
        outputShape.splice(isChannelLast ? 3 : 1, 0, outChannels);
        return outputShape;
      };
      weightTransposeAttribute = [2, 3, 1, 0];
      validateInputs9 = (inputs, attributes) => {
        if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
          throw new Error("Conv requires 2 or 3 inputs");
        }
        if (inputs[0].dims.length > 5) {
          throw new Error("greater than 5D is not supported");
        }
        if (inputs[0].dims.length !== inputs[1].dims.length) {
          throw new Error("filter does not have same dimension as input");
        }
        const dataChannel = inputs[0].dims[attributes.format === "NHWC" ? inputs[0].dims.length - 1 : 1];
        const filterInChannel = inputs[1].dims[1] * attributes.group;
        if (dataChannel !== filterInChannel) {
          throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
        }
        if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[1].dims[0] !== inputs[2].dims[0])) {
          throw new Error("invalid bias");
        }
        const spatialRank = inputs[0].dims.length - 2;
        if (attributes.dilations.length !== spatialRank) {
          throw new Error(`dilations should be ${spatialRank}D`);
        }
        if (attributes.strides.length !== spatialRank) {
          throw new Error(`strides should be ${spatialRank}D`);
        }
        if (attributes.pads.length !== spatialRank * 2) {
          throw new Error(`pads should be ${spatialRank * 2}D`);
        }
        if (attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {
          throw new Error("invalid kernel shape");
        }
      };
      getAdjustedConvAttributes = (attributes, inputs) => {
        const kernelShape = attributes.kernelShape.slice();
        if (kernelShape.length < inputs[1].dims.length - 2) {
          kernelShape.push(...Array(inputs[1].dims.length - 2 - kernelShape.length).fill(0));
        }
        for (let i = 2; i < inputs[1].dims.length; ++i) {
          if (kernelShape[i - 2] === 0) {
            kernelShape[i - 2] = inputs[1].dims[i];
          }
        }
        const pads = attributes.pads.slice();
        PoolConvUtil.adjustPadsBasedOnAutoPad(
          inputs[0].dims,
          attributes.strides,
          attributes.dilations,
          kernelShape,
          pads,
          attributes.format === "NHWC",
          attributes.autoPad
        );
        const newAttributes = Object.assign({}, attributes);
        Object.assign(newAttributes, { kernelShape, pads });
        return newAttributes;
      };
      parseConvAttributes = (attributes) => {
        const activationAttributes = parseInternalActivationAttributes(attributes);
        const format = attributes.format;
        const autoPad = ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][attributes.auto_pad];
        const dilations = attributes.dilations;
        const group = attributes.group;
        const kernelShape = attributes.kernel_shape;
        const pads = attributes.pads;
        const strides = attributes.strides;
        const wIsConst = attributes.w_is_const();
        return {
          autoPad,
          format,
          dilations,
          group,
          kernelShape,
          pads,
          strides,
          wIsConst,
          ...activationAttributes,
          cacheKey: `${attributes.format};${activationAttributes.activation};`
        };
      };
      conv2d = (context, inputs, attributes, squeezeOutputShapeFunction) => {
        const isChannelsLast = attributes.format === "NHWC";
        const outputShape = calculateOutputShape(
          inputs[0].dims,
          inputs[1].dims,
          attributes.dilations,
          attributes.pads,
          attributes.strides,
          isChannelsLast
        );
        if (attributes.group !== 1) {
          const convInputs2 = [inputs[0]];
          if (isChannelsLast) {
            const transposedWeight2 = context.kernelCustomData.wT ?? context.compute(createTransposeProgramInfo(inputs[1], weightTransposeAttribute), {
              inputs: [1],
              outputs: [attributes.wIsConst ? -2 : -1]
            })[0];
            if (attributes.wIsConst && !context.kernelCustomData.wT) {
              context.kernelCustomData.wT = transposedWeight2;
            }
            convInputs2.push(transposedWeight2);
          } else {
            convInputs2.push(inputs[1]);
          }
          if (inputs.length === 3) {
            convInputs2.push(inputs[2]);
          }
          const enableGroupedConvVectorize = !context.adapterInfo.isArchitecture("ampere");
          if (enableGroupedConvVectorize && isChannelsLast && inputs[1].dims[0] === attributes.group && inputs[1].dims[1] === 1 && attributes.dilations[0] === 1 && attributes.dilations[1] === 1) {
            context.compute(
              createGroupedConvVectorizeProgramInfo(convInputs2, attributes, outputShape, squeezeOutputShapeFunction),
              { inputs: convInputs2 }
            );
          } else {
            context.compute(createGroupedConvProgramInfo(convInputs2, attributes, outputShape, squeezeOutputShapeFunction), {
              inputs: convInputs2
            });
          }
          return;
        }
        const hasBias = inputs.length === 3;
        const inputHeight = inputs[0].dims[isChannelsLast ? 1 : 2];
        const inputWidth = inputs[0].dims[isChannelsLast ? 2 : 3];
        const inputChannels = inputs[0].dims[isChannelsLast ? 3 : 1];
        const weightHeight = inputs[1].dims[2];
        const weightWidth = inputs[1].dims[3];
        const outHeight = outputShape[isChannelsLast ? 1 : 2];
        const outWidth = outputShape[isChannelsLast ? 2 : 3];
        const outChannels = outputShape[isChannelsLast ? 3 : 1];
        const sameSize = isChannelsLast && weightHeight === inputHeight && weightWidth === inputWidth && attributes.pads[0] === 0 && attributes.pads[1] === 0;
        if (sameSize || weightHeight === 1 && weightWidth === 1 && attributes.dilations[0] === 1 && attributes.dilations[1] === 1 && attributes.strides[0] === 1 && attributes.strides[1] === 1 && attributes.pads[0] === 0 && attributes.pads[1] === 0) {
          const batch = outputShape[0];
          let xReshaped, wReshaped, matmulOutputShape;
          const matmulInputs = [];
          if (isChannelsLast) {
            const transposedWeight2 = context.kernelCustomData.wT ?? context.compute(createTransposeProgramInfo(inputs[1], weightTransposeAttribute), {
              inputs: [1],
              outputs: [attributes.wIsConst ? -2 : -1]
            })[0];
            if (attributes.wIsConst && !context.kernelCustomData.wT) {
              context.kernelCustomData.wT = transposedWeight2;
            }
            if (sameSize) {
              const sharedDim = inputHeight * inputWidth * inputChannels;
              xReshaped = inputs[0].reshape([1, batch, sharedDim]);
              wReshaped = transposedWeight2.reshape([1, sharedDim, outChannels]);
              matmulOutputShape = [1, batch, outChannels];
            } else {
              xReshaped = inputs[0].reshape([batch, inputHeight * inputWidth, inputChannels]);
              wReshaped = transposedWeight2.reshape([1, inputChannels, outChannels]);
              matmulOutputShape = [batch, outHeight * outWidth, outChannels];
            }
            matmulInputs.push(xReshaped);
            matmulInputs.push(wReshaped);
          } else {
            xReshaped = inputs[0].reshape([batch, inputChannels, inputHeight * inputWidth]);
            wReshaped = inputs[1].reshape([1, outChannels, inputChannels]);
            matmulOutputShape = [batch, outChannels, outHeight * outWidth];
            matmulInputs.push(wReshaped);
            matmulInputs.push(xReshaped);
          }
          if (hasBias) {
            matmulInputs.push(inputs[2]);
          }
          const N = matmulOutputShape[2];
          const K = matmulInputs[0].dims[matmulInputs[0].dims.length - 1];
          if (N < 8 && K < 8) {
            context.compute(
              createNaiveMatmulProgramInfo(
                matmulInputs,
                attributes,
                outputShape,
                matmulOutputShape,
                isChannelsLast,
                squeezeOutputShapeFunction
              ),
              { inputs: matmulInputs }
            );
          } else {
            context.compute(
              createMatmulProgramInfo(
                matmulInputs,
                attributes,
                outputShape,
                matmulOutputShape,
                isChannelsLast,
                squeezeOutputShapeFunction
              ),
              { inputs: matmulInputs }
            );
          }
          return;
        }
        const sequentialAccessByThreads = (
          /* backend.adapterInfo.isIntel() */
          true
        );
        const transposedWeight = context.kernelCustomData.wT ?? context.compute(createTransposeProgramInfo(inputs[1], weightTransposeAttribute), {
          inputs: [1],
          outputs: [attributes.wIsConst ? -2 : -1]
        })[0];
        if (attributes.wIsConst && !context.kernelCustomData.wT) {
          context.kernelCustomData.wT = transposedWeight;
        }
        const convInputs = [inputs[0], transposedWeight];
        if (hasBias) {
          convInputs.push(inputs[2]);
        }
        const dimAOuter = isChannelsLast ? outHeight * outWidth : outChannels;
        const dimBOuter = isChannelsLast ? outChannels : outHeight * outWidth;
        const dimInner = weightHeight * weightWidth * inputChannels;
        context.compute(
          createConv2DMatMulProgramInfo(
            convInputs,
            attributes,
            outputShape,
            dimAOuter,
            dimBOuter,
            dimInner,
            hasBias,
            sequentialAccessByThreads,
            squeezeOutputShapeFunction
          ),
          { inputs: convInputs }
        );
      };
      conv1d = (context, attributes) => {
        const isChannelLast = attributes.format === "NHWC";
        const inputs = [
          context.inputs[0].reshape(
            isChannelLast ? (
              // [N, W, C] -> [N, H=1, W, C]
              [context.inputs[0].dims[0], 1, context.inputs[0].dims[1], context.inputs[0].dims[2]]
            ) : (
              // [N, C, W] -> [N, C, H=1, W]
              [context.inputs[0].dims[0], context.inputs[0].dims[1], 1, context.inputs[0].dims[2]]
            )
          ),
          //[FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kW] -> [FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kH=1, kW]
          context.inputs[1].reshape([context.inputs[1].dims[0], context.inputs[1].dims[1], 1, context.inputs[1].dims[2]])
        ];
        if (context.inputs.length === 3) {
          inputs.push(context.inputs[2]);
        }
        const pads = [0, attributes.pads[0], 0, attributes.pads[1]];
        const strides = [1].concat(attributes.strides);
        const dilations = [1].concat(attributes.dilations);
        const kernelShape = [1].concat(attributes.kernelShape);
        const adjustedAttributes = getAdjustedConvAttributes(
          { ...attributes, pads, strides, dilations, kernelShape },
          inputs
        );
        conv2d(
          context,
          inputs,
          adjustedAttributes,
          (outputShape) => isChannelLast ? [outputShape[0], outputShape[2], outputShape[3]] : [outputShape[0], outputShape[1], outputShape[3]]
        );
      };
      conv3d = (context, inputs, attributes) => {
        const format = attributes.format === "NHWC" ? "channelsLast" : "channelsFirst";
        const adjustedAttributes = getAdjustedConvAttributes(attributes, inputs);
        const pads = attributes.autoPad === "NOTSET" ? attributes.pads : attributes.autoPad;
        const convInfo = computeConv3DInfo(
          inputs[0].dims,
          inputs[1].dims,
          attributes.strides,
          attributes.dilations,
          pads,
          false,
          format
        );
        context.compute(
          createConv3DNaiveProgramInfo(
            inputs,
            adjustedAttributes,
            convInfo.outShape,
            [convInfo.filterDepth, convInfo.filterHeight, convInfo.filterWidth],
            [convInfo.padInfo.front, convInfo.padInfo.top, convInfo.padInfo.left],
            format
          )
        );
      };
      conv = (context, attributes) => {
        validateInputs9(context.inputs, attributes);
        if (context.inputs[0].dims.length === 3) {
          conv1d(context, attributes);
        } else if (context.inputs[0].dims.length === 5) {
          conv3d(context, context.inputs, attributes);
        } else {
          const adjustedAttributes = getAdjustedConvAttributes(attributes, context.inputs);
          conv2d(context, context.inputs, adjustedAttributes);
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_mm_webgpu.ts
  var conv2dTransposeCommonSnippet, createConv2DTransposeMatMulProgramInfo;
  var init_conv_backprop_mm_webgpu = __esm({
    "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_mm_webgpu.ts"() {
      "use strict";
      init_wasm_common();
      init_log();
      init_common();
      init_fuse_utils();
      init_activation_util();
      init_conv_util();
      init_matmul_packed_webgpu();
      conv2dTransposeCommonSnippet = (isChannelsLast, addBias = false, attributes, type, innerElementSize = 4) => {
        const getWSnippet = (innerElementSize2) => {
          switch (innerElementSize2) {
            case 1:
              return "return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";
            case 4:
              return `
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];
            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];
            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];
            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];
            return ${type}(v0, v1, v2, v3);
            `;
            default:
              throw new Error(`innerElementSize ${innerElementSize2} is not supported.`);
          }
        };
        const coordASnippet = isChannelsLast ? `
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      ` : `
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `;
        const coordResSnippet = isChannelsLast ? `
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    ` : `
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `;
        const xHeight = isChannelsLast ? "i32(uniforms.x_shape[1])" : "i32(uniforms.x_shape[2])";
        const xWidth = isChannelsLast ? "i32(uniforms.x_shape[2])" : "i32(uniforms.x_shape[3])";
        const row = isChannelsLast ? "row" : "col";
        const col = isChannelsLast ? "col" : "row";
        const readASnippet = `
      let inChannels = ${isChannelsLast ? "i32(uniforms.x_shape[3])" : "i32(uniforms.x_shape[1])"};
      let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
      let outRow = ${row} / outWidth;
      let outCol = ${row} % outWidth;

      let WRow = ${col} / (uniforms.filter_dims[1] * inChannels);
      let WCol = ${col} / inChannels % uniforms.filter_dims[1];
      let xR = f32(outRow - uniforms.pads[0] + uniforms.dilations[0] * WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + uniforms.dilations[1] * WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(${xHeight}) || fract(xR) > 0.0) {
        return ${type}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${xWidth}) || fract(xC) > 0.0) {
        return ${type}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${col} % inChannels;
      ${coordASnippet}
      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${innerElementSize}];`;
        const sampleA = isChannelsLast ? `
      let col = colIn * ${innerElementSize};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
        ${readASnippet}
      }
      return ${type}(0.0);` : `
      let col = colIn * ${innerElementSize};
      if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
        ${readASnippet}
      }
      return ${type}(0.0);`;
        const sampleW = `
      let col = colIn * ${innerElementSize};
      let inChannels = ${isChannelsLast ? "i32(uniforms.x_shape[3])" : "i32(uniforms.x_shape[1])"};
      let coordX = uniforms.filter_dims[0] - 1 - row / (uniforms.filter_dims[1] * inChannels);
      let coordY = uniforms.filter_dims[1] - 1 - (row / inChannels) % uniforms.filter_dims[1];
      if (${isChannelsLast ? "row < uniforms.dim_inner && col < uniforms.dim_b_outer" : "row < uniforms.dim_inner && col < uniforms.dim_a_outer"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${getWSnippet(innerElementSize)}
      }
      return ${type}(0.0);
      `;
        const applyActivation = getActivationSnippet(attributes, type);
        const userCode = `
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${type} {
    ${isChannelsLast ? sampleA : sampleW}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${type} {
    ${isChannelsLast ? sampleW : sampleA}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${type}) {
    let col = colIn * ${innerElementSize};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
      var value = valueInput;
      let outWidth = ${isChannelsLast ? "i32(uniforms.result_shape[2])" : "i32(uniforms.result_shape[3])"};
      ${coordResSnippet}
      ${biasSnippet(addBias)}
      ${applyActivation}
      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${innerElementSize}] = value;
    }
  }`;
        return userCode;
      };
      createConv2DTransposeMatMulProgramInfo = (inputs, attributes, outputShape, dimAOuter, dimBOuter, dimInner, hasBias, sequentialAccessByThreads) => {
        const isChannelsLast = attributes.format === "NHWC";
        const inChannels = isChannelsLast ? inputs[0].dims[3] : inputs[0].dims[1];
        const batchSize = outputShape[0];
        const outWidth = isChannelsLast ? outputShape[2] : outputShape[3];
        const outHeight = isChannelsLast ? outputShape[1] : outputShape[2];
        const outChannels = isChannelsLast ? outputShape[3] : outputShape[1];
        const isVec4 = isChannelsLast && inChannels % 4 === 0 && inChannels % 3 && outChannels % 4 === 0;
        const dispatchX = isChannelsLast ? outChannels : outWidth * outHeight;
        const dispatchY = isChannelsLast ? outWidth * outHeight : outChannels;
        const workGroupSize = [8, 8, 1];
        const elementsPerThread = dimAOuter <= 8 ? [4, 1, 1] : [4, 4, 1];
        const dispatch = [
          Math.ceil(dispatchX / workGroupSize[0] / elementsPerThread[0]),
          Math.ceil(dispatchY / workGroupSize[1] / elementsPerThread[1]),
          Math.ceil(batchSize / workGroupSize[2] / elementsPerThread[2])
        ];
        LOG_DEBUG("verbose", () => `[conv_backprop_mm_webgpu] dispatch = ${dispatch}`);
        const innerElementSize = isVec4 ? 4 : 1;
        const tileInner = Math.max(workGroupSize[0] * innerElementSize, workGroupSize[1]);
        const components = isVec4 ? 4 : 1;
        const filterDims = [attributes.kernelShape[isChannelsLast ? 1 : 2], attributes.kernelShape[isChannelsLast ? 2 : 3]];
        const effectiveFilterDims = [
          filterDims[0] + (attributes.dilations[0] <= 1 ? 0 : (filterDims[0] - 1) * (attributes.dilations[0] - 1)),
          filterDims[1] + (attributes.dilations[1] <= 1 ? 0 : (filterDims[1] - 1) * (attributes.dilations[1] - 1))
        ];
        const pads = [
          effectiveFilterDims[0] - 1 - Math.floor((attributes.pads[0] + attributes.pads[2]) / 2),
          effectiveFilterDims[1] - 1 - Math.floor((attributes.pads[1] + attributes.pads[3]) / 2)
        ];
        const programUniforms = [
          { type: 6 /* int32 */, data: dimAOuter },
          { type: 6 /* int32 */, data: dimBOuter },
          { type: 6 /* int32 */, data: dimInner },
          { type: 6 /* int32 */, data: attributes.strides },
          { type: 6 /* int32 */, data: attributes.dilations },
          { type: 6 /* int32 */, data: filterDims },
          { type: 6 /* int32 */, data: pads }
        ];
        appendActivationUniformsData(attributes, programUniforms);
        programUniforms.push(...createTensorShapeVariables(inputs[0].dims, inputs[1].dims));
        const inputDependencies = ["rank", "rank"];
        if (hasBias) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
          inputDependencies.push("rank");
        }
        programUniforms.push(...createTensorShapeVariables(outputShape));
        const getShaderSource = (shaderHelper) => {
          const x = inputVariable("x", inputs[0].dataType, inputs[0].dims.length, components);
          const w = inputVariable("w", inputs[1].dataType, inputs[1].dims.length, 1);
          const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
          const inputVariables = [x, w];
          let declareFunctions = "";
          if (hasBias) {
            const bias = inputVariable("bias", inputs[2].dataType, inputs[2].dims.length, components);
            inputVariables.push(bias);
            declareFunctions += `
          fn getBiasByOutputCoords(coords : vec4<i32>) -> ${bias.type.value} {
            return bias[coords.${isChannelsLast ? "w" : "y"}${isVec4 ? "/ 4" : ""}];
          }`;
          }
          const uniforms = [
            { name: "dim_a_outer", type: "i32" },
            { name: "dim_b_outer", type: "i32" },
            { name: "dim_inner", type: "i32" },
            { name: "strides", type: "i32", length: 2 },
            { name: "dilations", type: "i32", length: 2 },
            { name: "filter_dims", type: "i32", length: filterDims.length },
            { name: "pads", type: "i32", length: pads.length }
          ];
          appendActivationUniforms(attributes, uniforms);
          const elemType = tensorTypeToWsglStorageType(inputs[0].dataType, 1);
          if (elemType !== "f16" && elemType !== "f32") {
            throw new Error(`elemType ${elemType} is not supported.`);
          }
          return `
        ${utilFunctions("uniforms.result_strides")}
        ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)};
        ${declareFunctions}
        ${conv2dTransposeCommonSnippet(isChannelsLast, hasBias, attributes, x.type.value, innerElementSize)}
        ${isVec4 ? makeMatMulPackedVec4Source(
            elementsPerThread,
            workGroupSize,
            elemType,
            void 0,
            !isChannelsLast,
            tileInner
          ) : makeMatMulPackedSource(
            elementsPerThread,
            workGroupSize,
            elemType,
            void 0,
            !isChannelsLast,
            tileInner,
            false,
            void 0,
            sequentialAccessByThreads
          )}`;
        };
        return {
          name: "Conv2DTransposeMatMul",
          shaderCache: { hint: `${attributes.cacheKey};${elementsPerThread};${workGroupSize};${isVec4}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
            programUniforms
          }),
          getShaderSource
        };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_webgpu.ts
  var createConvTranspose2DOpProgramShaderSource, createConvTranspose2DProgramInfo;
  var init_conv_backprop_webgpu = __esm({
    "web/lib/wasm/jsep/webgpu/ops/3rd-party/conv_backprop_webgpu.ts"() {
      "use strict";
      init_wasm_common();
      init_log();
      init_util();
      init_common();
      createConvTranspose2DOpProgramShaderSource = (shaderHelper, inputs, outputShape, hasBias, is1DimensionDispatch, isVec4 = false, dataType, uniforms, isChannelsLast = false) => {
        const rowDim = isChannelsLast ? 1 : 2;
        const colDim = isChannelsLast ? 2 : 3;
        const channelDim = isChannelsLast ? 3 : 1;
        const workPerThread = isVec4 ? 2 : 1;
        let declareFunctions = `
  fn setOutputAtIndex(flatIndex : u32, value : ${isVec4 ? `vec4<${dataType}>` : dataType}) {
    result[flatIndex] = ${isVec4 ? `vec4<${dataType}>` : dataType}(value);
  }`;
        if (hasBias) {
          declareFunctions += `
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${isVec4 ? `vec4<${dataType}>` : dataType} {
      return bias[coords.${isChannelsLast ? "w" : "y"}${isVec4 ? "/ 4" : ""}];
    }`;
        }
        const components = isVec4 ? 4 : 1;
        const w = inputVariable("W", inputs[1].dataType, inputs[1].dims.length, components);
        const dy = inputVariable("Dy", inputs[0].dataType, inputs[0].dims.length, components);
        const inputVariables = [dy, w];
        if (hasBias) {
          inputVariables.push(inputVariable("bias", inputs[2].dataType, [outputShape[channelDim]].length, components));
        }
        const output = outputVariable("result", inputs[0].dataType, outputShape.length, components);
        const codeSnippet4 = `{
        let batch: u32 = ${is1DimensionDispatch ? "global_id.z" : "workgroup_id.z"} / uniforms.result_shape[1];
        let r = ${is1DimensionDispatch ? "global_id.z" : "workgroup_id.z"} % uniforms.result_shape[1];
        let c = ${is1DimensionDispatch ? "global_id.y" : "workgroup_id.y"} * ${workPerThread};
        let d1: u32 = ${is1DimensionDispatch ? "global_id.x" : "workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(uniforms.pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${dataType}>, ${workPerThread}>;
        for (var i = 0; i < ${workPerThread}; i++) {
          dotProd[i] = vec4<${dataType}>(0.0);
        }
        for (var wR: u32 = 0; wR < uniforms.filter_dims[0]; wR = wR + 1) {
          var dyR = (${dataType}(dyCorner.x) + ${dataType}(wR)) / ${dataType}(uniforms.strides.x);
          let wRPerm = uniforms.filter_dims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${dataType}(uniforms.Dy_shape[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < uniforms.filter_dims[1]; wC = wC + 1) {
            let dyC = (${dataType}(dyCorner.y) + ${dataType}(wC)) / ${dataType}(uniforms.strides.y);
            let dyC2 = (${dataType}(dyCorner.y) + 1.0 + ${dataType}(wC)) / ${dataType}(uniforms.strides.y);
            let wCPerm = uniforms.filter_dims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${dataType}(uniforms.Dy_shape[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${dataType}(uniforms.Dy_shape[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1", "d2")};
                let wValue1 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 1", "d2")};
                let wValue2 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 2", "d2")};
                let wValue3 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 3", "d2")};

                var xValue = ${dy.get("batch", "idyR", "idyC", "d2")};
                let tmpval = vec4<${dataType}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${dy.get("batch", "idyR", "idyC2", "d2")};

                dotProd[1] = dotProd[1] + vec4<${dataType}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = uniforms.Dy_shape[${channelDim}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1", "d2")};
                let wValue1 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 1", "d2")};
                let wValue2 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 2", "d2")};
                let wValue3 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 3", "d2")};

                var xValue = ${dy.get("batch", "idyR", "idyC", "d2")};
                let tmpval = vec4<${dataType}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = uniforms.Dy_shape[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1", "d2")};
                let wValue1 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 1", "d2")};
                let wValue2 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 2", "d2")};
                let wValue3 = ${w.get("u32(wRPerm)", "u32(wCPerm)", "d1 + 3", "d2")};

                var xValue = ${dy.get("batch", "idyR", "idyC2", "d2")};
                let tmpval = vec4<${dataType}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${workPerThread}; i = i + 1) {
          let value = dotProd[i] + ${hasBias ? "bias[c+i]" : `vec4<${dataType}>(0.0)`};
          ${output.set("batch", "r", "c + i", "d1", "value")};
        }
      }`;
        const codeSnippet = `
          let outputIndices = ${output.offsetToIndices("global_idx")};
          let batch = ${output.indicesGet("outputIndices", 0)};
          let d1 = ${output.indicesGet("outputIndices", channelDim)};
          let r = ${output.indicesGet("outputIndices", rowDim)};
          let c = ${output.indicesGet("outputIndices", colDim)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / uniforms.output_channels_per_group;
          let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = ${dataType}(0.0);
          for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
            if (wR % uniforms.dilations.x != 0) {
              continue;
            }
            let dyR = (${dataType}(dyRCorner) + ${dataType}(wR)) / ${dataType}(uniforms.strides[0]);
            let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
            if (dyR < 0.0 || dyR >= ${dataType}(uniforms.Dy_shape[${rowDim}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
              if (wC % uniforms.dilations.y != 0) {
                continue;
              }
              let dyC = (${dataType}(dyCCorner) + ${dataType}(wC)) / ${dataType}(uniforms.strides.y);
              let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
              if (dyC < 0.0 || dyC >= ${dataType}(uniforms.Dy_shape[${colDim}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * uniforms.input_channels_per_group;
              for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + 1) {
                let xValue = ${isChannelsLast ? dy.get("batch", "idyR", "idyC", "inputChannel") : dy.get("batch", "inputChannel", "idyR", "idyC")};
                let wValue = ${w.get("inputChannel", "wOutChannel", "u32(wRPerm)", "u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${hasBias ? "bias[d1]" : `${dataType}(0.0)`};
          ${output.setByOffset("global_idx", "value")};
        `;
        return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
  ${declareFunctions}

    ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
  ${isVec4 ? codeSnippet4 : codeSnippet}}`;
      };
      createConvTranspose2DProgramInfo = (inputs, attributes, squeezeOutputShapeFunction) => {
        const hasBias = inputs.length > 2;
        const outputShape = attributes.outputShape;
        const outputSize = ShapeUtil.size(outputShape);
        const dispatch = [Math.ceil(outputSize / 64), 1, 1];
        LOG_DEBUG("verbose", () => `[conv2d_backprop_webgpu] dispatch = ${dispatch}`);
        const isChannelsLast = attributes.format === "NHWC";
        const inputDependencies = ["rank", "rank"];
        const strides = [attributes.strides[0], attributes.strides[1]];
        const filterDims = [attributes.kernelShape[isChannelsLast ? 1 : 2], attributes.kernelShape[isChannelsLast ? 2 : 3]];
        const dilations = [attributes.dilations[0], attributes.dilations[1]];
        const effectiveFilterDims = [
          filterDims[0] + (attributes.dilations[0] <= 1 ? 0 : (attributes.kernelShape[isChannelsLast ? 1 : 2] - 1) * (attributes.dilations[0] - 1)),
          filterDims[1] + (attributes.dilations[1] <= 1 ? 0 : (attributes.kernelShape[isChannelsLast ? 2 : 3] - 1) * (attributes.dilations[1] - 1))
        ];
        const pads = [
          effectiveFilterDims[0] - 1 - Math.floor((attributes.pads[0] + attributes.pads[2]) / 2),
          effectiveFilterDims[1] - 1 - Math.floor(attributes.pads[1] + attributes.pads[3]) / 2
        ];
        const isVec4 = false;
        const group = attributes.group;
        const wShape = inputs[1].dims;
        const inputChannelsPerGroup = wShape[0] / group;
        const outputChannelsPerGroup = wShape[1];
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: strides },
          { type: 12 /* uint32 */, data: filterDims },
          { type: 12 /* uint32 */, data: dilations },
          { type: 12 /* uint32 */, data: effectiveFilterDims },
          { type: 6 /* int32 */, data: pads },
          { type: 12 /* uint32 */, data: inputChannelsPerGroup },
          { type: 12 /* uint32 */, data: outputChannelsPerGroup },
          ...createTensorShapeVariables(inputs[0].dims, inputs[1].dims)
        ];
        if (hasBias) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
          inputDependencies.push("rank");
        }
        programUniforms.push(...createTensorShapeVariables(outputShape));
        const is1DimensionDispatch = dispatch[1] === 1 && dispatch[2] === 1;
        const getShaderSource = (shaderHelper) => {
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "strides", type: "u32", length: strides.length },
            { name: "filter_dims", type: "u32", length: filterDims.length },
            { name: "dilations", type: "u32", length: filterDims.length },
            { name: "effective_filter_dims", type: "u32", length: effectiveFilterDims.length },
            { name: "pads", type: "i32", length: pads.length },
            { name: "input_channels_per_group", type: "u32" },
            { name: "output_channels_per_group", type: "u32" }
          ];
          const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
          return `${createConvTranspose2DOpProgramShaderSource(
            shaderHelper,
            inputs,
            outputShape,
            hasBias,
            is1DimensionDispatch,
            isVec4,
            dataType,
            uniforms,
            isChannelsLast
          )}`;
        };
        return {
          name: "ConvTranspose2D",
          shaderCache: { hint: `${attributes.cacheKey};`, inputDependencies },
          getRunData: () => ({
            dispatchGroup: { x: dispatch[0], y: dispatch[1], z: dispatch[2] },
            outputs: [
              {
                dims: squeezeOutputShapeFunction ? squeezeOutputShapeFunction(outputShape) : outputShape,
                dataType: inputs[0].dataType
              }
            ],
            programUniforms
          }),
          getShaderSource
        };
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/conv-transpose.ts
  var computeTotalPad, distributePadding, calculateOutputShapeAndPads, getAdjustedConvTransposeAttributes, parseConvTransposeAttributes, validateInputs10, weightTransposePerm, convTranspose2d, convTranspose1d, convTranspose;
  var init_conv_transpose = __esm({
    "web/lib/wasm/jsep/webgpu/ops/conv-transpose.ts"() {
      "use strict";
      init_conv_backprop_mm_webgpu();
      init_conv_backprop_webgpu();
      init_fuse_utils();
      init_transpose();
      computeTotalPad = (inDim, stride, adj, kernel, dilation, outSize) => (inDim - 1) * stride + adj + (kernel - 1) * dilation + 1 - outSize;
      distributePadding = (totalPad, autoPad, pads, head, tail) => {
        const smallPad = Math.floor(totalPad / 2);
        if (autoPad === "SAME_UPPER") {
          pads[head] = smallPad;
          pads[tail] = totalPad - smallPad;
        } else if (autoPad === "SAME_LOWER") {
          pads[head] = totalPad - smallPad;
          pads[tail] = smallPad;
        }
      };
      calculateOutputShapeAndPads = (inputShape, kernelShape, dilations, autoPad, group, pads, strides, isChannelLast, outputPadding, outputShape) => {
        const spatialRank = inputShape.length - 2;
        const updateOutputShape = outputShape.length === 0;
        if (outputPadding.length < spatialRank) {
          outputPadding.push(...Array(spatialRank - outputPadding.length).fill(0));
        }
        const batchSize = inputShape[0];
        const outChannels = kernelShape[isChannelLast ? 3 : 1] * group;
        for (let i = 0, j = inputShape.length - spatialRank - (isChannelLast ? 1 : 0); i < spatialRank; ++i, ++j) {
          const inSize = inputShape[j];
          const outSize = updateOutputShape ? inSize * strides[i] : outputShape[i];
          const totalPad = computeTotalPad(inSize, strides[i], pads[i], kernelShape[j], dilations[i], outSize);
          distributePadding(totalPad, autoPad, pads, i, i + spatialRank);
          if (updateOutputShape) {
            outputShape.push(
              strides[i] * (inSize - 1) + outputPadding[i] + (kernelShape[j] - 1) * dilations[i] + 1 - pads[i] - pads[i + spatialRank]
            );
          }
        }
        outputShape.splice(0, 0, batchSize);
        outputShape.splice(isChannelLast ? 3 : 1, 0, outChannels);
      };
      getAdjustedConvTransposeAttributes = (attributes, inputs) => {
        const kernelShape = attributes.kernelShape.slice();
        if (attributes.kernelShape.length === 0 || attributes.kernelShape.reduce((a, b) => a * b, 1) === 0) {
          kernelShape.length = 0;
          for (let i = 2; i < inputs[1].dims.length; ++i) {
            kernelShape.push(inputs[1].dims[i]);
          }
        }
        const isChannelsLast = attributes.format === "NHWC";
        kernelShape.splice(0, 0, inputs[1].dims[0]);
        kernelShape.splice(isChannelsLast ? 3 : 1, 0, inputs[1].dims[1]);
        const pads = attributes.pads.slice();
        const outputShape = attributes.outputShape.slice();
        const outputPadding = attributes.outputPadding.slice();
        const inputShape = inputs[0].dims;
        let dilations = attributes.dilations.slice();
        if (dilations.reduce((a, b) => a + b, 0) === 0) {
          const spatialRank = inputs[0].dims.length - 2;
          dilations = new Array(spatialRank).fill(1);
        }
        let strides = attributes.strides.slice();
        if (strides.reduce((a, b) => a + b, 0) === 0) {
          const spatialRank = inputs[0].dims.length - 2;
          strides = new Array(spatialRank).fill(1);
        }
        calculateOutputShapeAndPads(
          inputShape,
          kernelShape,
          dilations,
          attributes.autoPad,
          attributes.group,
          pads,
          strides,
          isChannelsLast,
          outputPadding,
          outputShape
        );
        const newAttributes = Object.assign({}, attributes);
        Object.assign(newAttributes, { kernelShape, pads, outputPadding, outputShape, dilations, strides });
        return newAttributes;
      };
      parseConvTransposeAttributes = (attributes) => {
        const activationAttributes = parseInternalActivationAttributes(attributes);
        const format = attributes.format;
        const autoPad = ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][typeof attributes.autoPad == "undefined" ? 0 : attributes.autoPad];
        const dilations = attributes.dilations;
        const group = attributes.group;
        const kernelShape = attributes.kernelShape;
        const pads = attributes.pads;
        const strides = attributes.strides;
        const wIsConst = attributes.wIsConst();
        const outputPadding = attributes.outputPadding;
        const outputShape = attributes.outputShape;
        return {
          autoPad,
          format,
          dilations,
          group,
          kernelShape,
          outputPadding,
          outputShape,
          pads,
          strides,
          wIsConst,
          ...activationAttributes,
          cacheKey: `${attributes.format};${activationAttributes.activation};`
        };
      };
      validateInputs10 = (inputs, attributes) => {
        if (!inputs || inputs.length !== 2 && inputs.length !== 3) {
          throw new Error("Conv requires 2 or 3 inputs");
        }
        if (inputs[0].dims.length !== 4 && inputs[0].dims.length !== 3) {
          throw new Error("currently only support 2-dimensional conv");
        }
        if (inputs[0].dims.length !== inputs[1].dims.length) {
          throw new Error("filter does not have same dimension as input");
        }
        const dataChannel = inputs[0].dims[attributes.format === "NHWC" ? inputs[0].dims.length - 1 : 1];
        const filterInChannel = inputs[1].dims[0];
        if (dataChannel !== filterInChannel) {
          throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
        }
        const featureMaps = inputs[1].dims[1] * attributes.group;
        if (inputs.length === 3 && (inputs[2].dims.length !== 1 || inputs[2].dims[0] !== featureMaps)) {
          throw new Error("invalid bias");
        }
        const spatialRank = inputs[0].dims.length - 2;
        const dilationsSet = attributes.dilations.reduce((a, b) => a + b, 0) > 0;
        if (dilationsSet && attributes.dilations.length !== spatialRank) {
          throw new Error(`dilations should be ${spatialRank}D`);
        }
        const stridesSet = attributes.strides.reduce((a, b) => a + b, 0) > 0;
        if (stridesSet && attributes.strides.length !== spatialRank) {
          throw new Error(`strides should be ${spatialRank}D`);
        }
        const padsSet = attributes.pads.reduce((a, b) => a + b, 0) > 0;
        if (padsSet && attributes.pads.length !== spatialRank * 2) {
          throw new Error(`pads should be ${spatialRank * 2}D`);
        }
        if (attributes.outputPadding.length !== spatialRank && attributes.outputPadding.length !== 0) {
          throw new Error(`output_padding should be ${spatialRank}D`);
        }
        const kernelShapeSet = attributes.kernelShape.reduce((a, b) => a + b, 0) > 0;
        if (kernelShapeSet && attributes.kernelShape.length !== 0 && attributes.kernelShape.length !== inputs[1].dims.length - 2) {
          throw new Error("invalid kernel shape");
        }
        if (attributes.outputShape.length !== 0 && attributes.outputShape.length !== inputs[0].dims.length - 2) {
          throw new Error("invalid output shape");
        }
      };
      weightTransposePerm = [2, 3, 1, 0];
      convTranspose2d = (context, inputs, attributes) => {
        const adjustedAttributes = getAdjustedConvTransposeAttributes(attributes, inputs);
        const isChannelsLast = attributes.format === "NHWC";
        const outputShape = adjustedAttributes.outputShape;
        const outChannels = outputShape[isChannelsLast ? 3 : 1];
        const inputChannels = inputs[0].dims[isChannelsLast ? 3 : 1];
        if (adjustedAttributes.group !== 1 || outChannels === 1 && inputChannels === 1) {
          context.compute(createConvTranspose2DProgramInfo(inputs, adjustedAttributes));
          return;
        }
        const outHeight = outputShape[isChannelsLast ? 1 : 2];
        const outWidth = outputShape[isChannelsLast ? 2 : 3];
        const weightHeight = inputs[1].dims[2];
        const weightWidth = inputs[1].dims[3];
        const dimAOuter = isChannelsLast ? outHeight * outWidth : outChannels;
        const dimBOuter = isChannelsLast ? outChannels : outHeight * outWidth;
        const dimInner = weightHeight * weightWidth * inputChannels;
        const sequentialAccessByThreads = (
          /* backend.adapterInfo.isIntel() */
          true
        );
        const transposedWeight = context.kernelCustomData.wT ?? context.compute(createTransposeProgramInfo(inputs[1], weightTransposePerm), {
          inputs: [1],
          outputs: [attributes.wIsConst ? -2 : -1]
        })[0];
        if (attributes.wIsConst && !context.kernelCustomData.wT) {
          context.kernelCustomData.wT = transposedWeight;
        }
        const convTransposeInputs = [inputs[0], transposedWeight];
        const hasBias = inputs.length === 3;
        if (hasBias) {
          if (!isChannelsLast && inputs[2].dims.length === 1) {
            convTransposeInputs.push(inputs[2].reshape([inputs[2].dims[0], 1, 1]));
          } else {
            convTransposeInputs.push(inputs[2]);
          }
        }
        context.compute(
          createConv2DTransposeMatMulProgramInfo(
            convTransposeInputs,
            adjustedAttributes,
            outputShape,
            dimAOuter,
            dimBOuter,
            dimInner,
            hasBias,
            sequentialAccessByThreads
          ),
          { inputs: convTransposeInputs }
        );
      };
      convTranspose1d = (context, attributes) => {
        const isChannelLast = attributes.format === "NHWC";
        const inputs = [
          context.inputs[0].reshape(
            isChannelLast ? (
              // [N, W, C] -> [N, H=1, W, C]
              [context.inputs[0].dims[0], 1, context.inputs[0].dims[1], context.inputs[0].dims[2]]
            ) : (
              // [N, C, W] -> [N, C, H=1, W]
              [context.inputs[0].dims[0], context.inputs[0].dims[1], 1, context.inputs[0].dims[2]]
            )
          ),
          //[FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kW] -> [FILTER_OUT_CHANNEL, FILTER_IN_CHANNEL, kH=1, kW]
          context.inputs[1].reshape([context.inputs[1].dims[0], context.inputs[1].dims[1], 1, context.inputs[1].dims[2]])
        ];
        if (context.inputs.length === 3) {
          inputs.push(context.inputs[2]);
        }
        let kernelShape = attributes.kernelShape;
        if (kernelShape.length === 0 || kernelShape[0] === 0) {
          kernelShape = [context.inputs[1].dims[2]];
        }
        let dilations = attributes.dilations;
        if (dilations.length === 0 || dilations[0] === 0) {
          dilations = [1];
        }
        let strides = attributes.strides;
        if (strides.length === 0 || strides[0] === 0) {
          strides = [1];
        }
        let pads = attributes.pads;
        if (pads.length === 0) {
          pads = [0, 0];
        }
        pads = [0, pads[0], 0, pads[1]];
        strides = [1].concat(strides);
        dilations = [1].concat(dilations);
        kernelShape = [1].concat(kernelShape);
        const adjustedAttributes = getAdjustedConvTransposeAttributes(
          { ...attributes, pads, strides, dilations, kernelShape },
          inputs
        );
        context.compute(
          createConvTranspose2DProgramInfo(
            inputs,
            adjustedAttributes,
            (outputShape) => isChannelLast ? [outputShape[0], outputShape[2], outputShape[3]] : [outputShape[0], outputShape[1], outputShape[3]]
          )
        );
      };
      convTranspose = (context, attributes) => {
        validateInputs10(context.inputs, attributes);
        if (context.inputs[0].dims.length === 3) {
          convTranspose1d(context, attributes);
        } else {
          convTranspose2d(context, context.inputs, attributes);
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/cumsum.ts
  var createCumsumProgramInfo, cumsum, parseCumSumAttributes;
  var init_cumsum = __esm({
    "web/lib/wasm/jsep/webgpu/ops/cumsum.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      createCumsumProgramInfo = (inputType, inputShape, axisInput, attributes) => {
        const outputSize = ShapeUtil.size(inputShape);
        const rank = inputShape.length;
        const input = inputVariable("input", inputType, rank);
        const output = outputVariable("output", inputType, rank);
        const axisValue = axisInput.dataType === 6 /* int32 */ ? axisInput.getInt32Array()[0] : Number(axisInput.getBigInt64Array()[0]);
        const axis = ShapeUtil.normalizeAxis(axisValue, rank);
        const getShaderSource = (shaderHelper) => {
          const index = ` i32(${input.indicesGet("inputIndices", "uniforms.axis")}) `;
          const max = getElementAt("uniforms.input_shape", "uniforms.axis", rank);
          const lowerLimit = attributes.reverse ? index + (attributes.exclusive ? " + 1" : "") : "0";
          const upperLimit = attributes.reverse ? max : index + (attributes.exclusive ? "" : " + 1");
          return `
                ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axis", "u32").declareVariables(input, output)}
                ${shaderHelper.mainStart()}
                  ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${output.offsetToIndices("global_idx")};
                  var sum = ${output.type.value}(0);
                  let first : i32 = ${lowerLimit};
                  let last : i32 = ${upperLimit};
                  for (var i : i32 = first; i < last; i++) {
                    ${input.indicesSet("inputIndices", "uniforms.axis", "u32(i)")};
                    sum = sum + ${input.getByIndices("inputIndices")};
                  }
                  ${output.setByOffset("global_idx", "sum")};
                }`;
        };
        return {
          name: "CumSum",
          shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank"] },
          getRunData: () => ({
            outputs: [{ dims: inputShape, dataType: inputType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: outputSize },
              { type: 12 /* uint32 */, data: axis },
              ...createTensorShapeVariables(inputShape, inputShape)
            ]
          }),
          getShaderSource
        };
      };
      cumsum = (context, attributes) => {
        const inputShape = context.inputs[0].dims;
        const inputType = context.inputs[0].dataType;
        const axis = context.inputs[1];
        context.compute(createCumsumProgramInfo(inputType, inputShape, axis, attributes), { inputs: [0] });
      };
      parseCumSumAttributes = (attributes) => {
        const exclusive = attributes.exclusive === 1;
        const reverse = attributes.reverse === 1;
        return createAttributeWithCacheKey({ exclusive, reverse });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/depth-to-space.ts
  var validateInputs11, permFunctionBody2, createDepthToSpaceProgramInfo, depthToSpace, parseDepthToSpaceAttributes;
  var init_depth_to_space = __esm({
    "web/lib/wasm/jsep/webgpu/ops/depth-to-space.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs11 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("DepthToSpace requires 1 input.");
        }
        if (inputs[0].dims.length !== 4) {
          throw new Error("DepthToSpace requires 4D input.");
        }
      };
      permFunctionBody2 = (perm, rank, input, output) => {
        const reverseFunc = [];
        reverseFunc.push(`fn perm(i: ${output.type.indices}) -> ${input.type.indices} {
    var a: ${input.type.indices};`);
        for (let i = 0; i < rank; ++i) {
          reverseFunc.push(input.indicesSet("a", perm[i], `i[${i}]`));
        }
        reverseFunc.push("return a;}");
        return reverseFunc.join("\n");
      };
      createDepthToSpaceProgramInfo = (inputTensor, attributes) => {
        let n, h, w, c;
        let shape;
        let perm;
        const isChannelLast = attributes.format === "NHWC";
        const blocksize = attributes.blocksize;
        const isDCRmode = attributes.mode === "DCR";
        if (isChannelLast) {
          [n, h, w, c] = inputTensor.dims;
          shape = isDCRmode ? [n, h, w, blocksize, blocksize, c / blocksize ** 2] : [n, h, w, c / blocksize ** 2, blocksize, blocksize];
          perm = isDCRmode ? [0, 1, 3, 2, 4, 5] : [0, 1, 4, 2, 5, 3];
        } else {
          [n, h, w, c] = [inputTensor.dims[0], inputTensor.dims[2], inputTensor.dims[3], inputTensor.dims[1]];
          shape = isDCRmode ? [n, blocksize, blocksize, c / blocksize ** 2, h, w] : [n, c / blocksize ** 2, blocksize, blocksize, h, w];
          perm = isDCRmode ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3];
        }
        const reshapedInputTensor = inputTensor.reshape(shape);
        const reshapedInputRank = reshapedInputTensor.dims.length;
        const inputDataType = inputTensor.dataType;
        const reshapedInput = inputVariable("a", inputDataType, reshapedInputRank);
        const permedOutput = outputVariable("output", inputDataType, reshapedInputRank);
        const getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(reshapedInput, permedOutput)}

  ${permFunctionBody2(perm, reshapedInputRank, reshapedInput, permedOutput)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${permedOutput.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${permedOutput.setByOffset("global_idx", reshapedInput.getByIndices("aIndices"))}
  }`;
        return {
          name: "DepthToSpace",
          shaderCache: {
            hint: `${inputTensor.dims};${attributes.blocksize};${attributes.mode}`,
            inputDependencies: ["rank"]
          },
          getRunData: (inputs) => {
            const outputShape = isChannelLast ? [n, h * blocksize, w * blocksize, c / blocksize ** 2] : [n, c / blocksize ** 2, h * blocksize, w * blocksize];
            const outputSize = ShapeUtil.size(outputShape);
            const shapeBeforePerm = reshapedInputTensor.dims;
            const shapeAfterPerm = ShapeUtil.sortBasedOnPerm(shapeBeforePerm, perm);
            return {
              outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
              dispatchGroup: { x: Math.ceil(
                outputSize / 64
                /* workgroup size */
              ) },
              programUniforms: [
                { type: 12 /* uint32 */, data: outputSize },
                ...createTensorShapeVariables(shapeBeforePerm, shapeAfterPerm)
              ]
            };
          },
          getShaderSource
        };
      };
      depthToSpace = (context, attributes) => {
        validateInputs11(context.inputs);
        context.compute(createDepthToSpaceProgramInfo(context.inputs[0], attributes));
      };
      parseDepthToSpaceAttributes = (attributes) => createAttributeWithCacheKey({
        blocksize: attributes.blocksize,
        mode: attributes.mode,
        format: attributes.format
      });
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/einsum.ts
  var symbolPattern, termPattern, termPatternOnly, lhsPattern, lhsPatternOnly, EinsumTerm, EinsumEquation, appendMax, createEinsumProgramInfo, einsum, parseEinsumAttributes;
  var init_einsum = __esm({
    "web/lib/wasm/jsep/webgpu/ops/einsum.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      symbolPattern = "[a-zA-Z]|\\.\\.\\.";
      termPattern = "(" + symbolPattern + ")+";
      termPatternOnly = "^" + termPattern + "$";
      lhsPattern = "(" + termPattern + ",)*" + termPattern;
      lhsPatternOnly = "^" + lhsPattern + "$";
      EinsumTerm = class {
        constructor(inputIndex = -1) {
          this.symbolToIndices = /* @__PURE__ */ new Map();
          this.inputIndex = inputIndex;
        }
        // Add a symbol to the term
        addSymbol(symbol, index) {
          let value = this.symbolToIndices.get(symbol);
          if (value === void 0) {
            value = [index];
          } else {
            value.push(index);
          }
          this.symbolToIndices.set(symbol, value);
        }
        // -1 for output and 0, 1, 2, ... for inputs
      };
      EinsumEquation = class {
        constructor(inputs, equation) {
          this.equation = equation;
          this.hasEllipsis = false;
          this.symbolToInfo = /* @__PURE__ */ new Map();
          this.lhs = new Array();
          this.outputDims = [];
          let [lhs, rhs] = equation.includes("->") ? equation.split("->", 2) : [equation, ""];
          if (!lhs.match(RegExp(lhsPatternOnly))) {
            throw new Error("Invalid LHS term");
          }
          const inputTerms = lhs.split(",");
          inputTerms.forEach((inputTerm, index) => {
            const dims = inputs[index].dims.slice();
            if (!inputTerm.match(RegExp(termPatternOnly))) {
              throw new Error("Invalid LHS term");
            }
            const einsumTerm = this.processTerm(inputTerm, true, dims, index);
            this.lhs.push(einsumTerm);
          });
          if (rhs === "") {
            rhs += [...this.symbolToInfo.entries()].filter(([sym, info]) => info.count === 1 || sym === "...").map(([sym]) => sym).join("");
          } else {
            if (!rhs.match(RegExp(termPattern))) {
              throw new Error("Invalid RHS");
            }
          }
          const rhsSymbols = rhs.match(RegExp(symbolPattern, "g"));
          rhsSymbols?.forEach((symbol) => {
            if (symbol === "...") {
              this.outputDims = this.outputDims.concat(this.ellipsisDims);
            } else {
              const info = this.symbolToInfo.get(symbol);
              if (info === void 0) {
                throw new Error("Invalid RHS symbol");
              }
              this.outputDims.push(info.dimValue);
            }
          });
          this.rhs = this.processTerm(rhs, false, this.outputDims);
        }
        // End of EinsumEqation constructor
        // Add a symbol to the equation
        addSymbol(symbol, dimValue, inputIndex) {
          let info = this.symbolToInfo.get(symbol);
          if (info !== void 0) {
            if (info.dimValue !== dimValue && info.count !== 1) {
              throw new Error("Dimension mismatch");
            } else {
              info.count++;
              info.inputIndices.push(inputIndex);
            }
          } else {
            info = { count: 1, dimValue, inputIndices: [inputIndex] };
          }
          this.symbolToInfo.set(symbol, info);
        }
        // Process one input/output term
        processTerm(term, isInput, dims, index = -1) {
          const rank = dims.length;
          let ellipsis = false;
          let ellipsisDims = [];
          let nextDim = 0;
          if (!term.match(RegExp(termPatternOnly)) && !isInput && term !== "") {
            throw new Error("Invalid LHS term");
          }
          const indexSymbols = term.match(RegExp(symbolPattern, "g"));
          const einsumTerm = new EinsumTerm(index);
          indexSymbols?.forEach((symbol, i) => {
            if (symbol === "...") {
              if (ellipsis) {
                throw new Error("Only one ellipsis is allowed per input term");
              }
              ellipsis = true;
              const ellipsisDimLength = rank - indexSymbols.length + 1;
              if (ellipsisDimLength < 0) {
                throw new Error("Ellipsis out of bounds");
              }
              ellipsisDims = dims.slice(nextDim, nextDim + ellipsisDimLength);
              if (this.hasEllipsis) {
                if (this.ellipsisDims.length !== ellipsisDims.length || this.ellipsisDims.toString() !== ellipsisDims.toString()) {
                  throw new Error("Ellipsis dimensions mismatch");
                }
              } else if (isInput) {
                this.hasEllipsis = true;
                this.ellipsisDims = ellipsisDims;
              } else {
                throw new Error("Ellipsis must be specified in the LHS");
              }
              for (let j = 0; j < ellipsisDims.length; j++) {
                const symbol2 = String.fromCharCode("0".charCodeAt(0) + j);
                einsumTerm.addSymbol(symbol2, i + j);
                this.addSymbol(symbol2, dims[nextDim++], index);
              }
            } else {
              einsumTerm.addSymbol(symbol, i + (this.hasEllipsis ? this.ellipsisDims.length - 1 : 0));
              this.addSymbol(symbol, dims[nextDim++], index);
            }
          });
          return einsumTerm;
        }
        // Output dimensions of the equation
      };
      appendMax = (name) => name + "_max";
      createEinsumProgramInfo = (inputShapes, dataType, einsumEquation, outputShape) => {
        const ranks = inputShapes.map((dims) => dims.length);
        const inputVars = ranks.map((rank, index) => inputVariable(`input${index}`, dataType, rank));
        const outputSize = ShapeUtil.size(outputShape);
        const output = outputVariable("output", dataType, outputShape.length);
        const uniformsSymbols = [...einsumEquation.symbolToInfo.keys()].filter(
          (symbol) => !einsumEquation.rhs.symbolToIndices.has(symbol)
        );
        const getShaderSource = (shaderHelper) => {
          const idxCopy = [];
          const initProd = "var prod = 1.0;";
          const initSum = "var sum = 0.0;";
          const updateSum = "sum += prod;";
          const reduceOpsSetIndices = [];
          const reduceOpsLoopHeaders = [];
          const reduceOpsLoopFooters = [];
          const reduceOpCompute = [];
          const isReduceOpsWithoutLoop = einsumEquation.symbolToInfo.size === einsumEquation.rhs.symbolToIndices.size;
          einsumEquation.symbolToInfo.forEach((info, symbol) => {
            if (einsumEquation.rhs.symbolToIndices.has(symbol)) {
              const outputIndex = einsumEquation.rhs.symbolToIndices.get(symbol)?.[0];
              if (outputIndex !== void 0) {
                einsumEquation.lhs.forEach((term, i) => {
                  if (info.inputIndices.includes(i)) {
                    const indices = term.symbolToIndices.get(symbol);
                    if (indices === void 0) {
                      throw new Error("Invalid symbol error");
                    }
                    indices.forEach((index) => {
                      idxCopy.push(
                        `${inputVars[i].indicesSet(
                          `input${i}Indices`,
                          index,
                          output.indicesGet("outputIndices", outputIndex)
                        )}`
                      );
                    });
                  }
                });
              }
            } else {
              einsumEquation.lhs.forEach((term, i) => {
                if (info.inputIndices.includes(i)) {
                  const indices = term.symbolToIndices.get(symbol);
                  if (indices === void 0) {
                    throw new Error("Invalid symbol error");
                  }
                  indices.forEach((index) => {
                    reduceOpsSetIndices.push(`${inputVars[i].indicesSet(`input${i}Indices`, index, `${symbol}`)}`);
                  });
                  reduceOpCompute.push(`prod *= ${inputVars[i].getByIndices(`input${i}Indices`)};`);
                }
              });
              reduceOpsLoopHeaders.push(
                `for(var ${symbol}: u32 = 0; ${symbol} < uniforms.${appendMax(symbol)}; ${symbol}++) {`
              );
              reduceOpsLoopFooters.push("}");
            }
          });
          const reduceOps2 = isReduceOpsWithoutLoop ? [
            ...idxCopy,
            `let sum = ${inputVars.map((inputVar, i) => inputVar.getByIndices(`input${i}Indices`)).join(" * ")};`
          ] : [
            ...idxCopy,
            initSum,
            ...reduceOpsLoopHeaders,
            ...reduceOpsSetIndices,
            initProd,
            ...reduceOpCompute,
            updateSum,
            ...reduceOpsLoopFooters
          ];
          return `
            ${shaderHelper.registerUniforms(uniformsSymbols.map((symbol) => ({ name: `${appendMax(symbol)}`, type: "u32" }))).registerUniform("outputSize", "u32").declareVariables(...inputVars, output)}

            ${shaderHelper.mainStart()}
            ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${output.offsetToIndices("global_idx")};
            ${inputVars.map((_var, i) => `var input${i}Indices: ${inputVars[i].type.indices};`).join("\n")}
            ${reduceOps2.join("\n")};
            ${output.setByOffset("global_idx", "sum")};
          }`;
        };
        return {
          name: "Einsum",
          shaderCache: { hint: einsumEquation.equation, inputDependencies: inputShapes.map(() => "rank") },
          getRunData: () => {
            const programUniformsInit = uniformsSymbols.filter((symbol) => einsumEquation.symbolToInfo.has(symbol)).map((symbol) => ({ type: 12 /* uint32 */, data: einsumEquation.symbolToInfo.get(symbol)?.dimValue || 0 }));
            programUniformsInit.push({ type: 12 /* uint32 */, data: outputSize });
            const programUniforms = inputShapes.map((dims, _) => [...createTensorShapeVariables(dims)]).reduce((acc, inputProgramUniforms) => acc.concat(inputProgramUniforms), programUniformsInit);
            programUniforms.push(...createTensorShapeVariables(outputShape));
            return {
              outputs: [{ dims: outputShape, dataType }],
              dispatchGroup: { x: Math.ceil(
                outputSize / 64
                /* workgroup size */
              ) },
              programUniforms
            };
          },
          getShaderSource
        };
      };
      einsum = (context, attributes) => {
        const einsumEquation = new EinsumEquation(context.inputs, attributes.equation);
        const outputShape = einsumEquation.outputDims;
        const inputShapes = context.inputs.map((input, _) => input.dims);
        context.compute(createEinsumProgramInfo(inputShapes, context.inputs[0].dataType, einsumEquation, outputShape));
      };
      parseEinsumAttributes = (attributes) => {
        const equation = attributes.equation.replace(/\s+/g, "");
        return createAttributeWithCacheKey({ equation });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/expand.ts
  var validateInputs12, getAdjustedShape, calculateOutputShape2, createExpandProgramInfo, expand;
  var init_expand = __esm({
    "web/lib/wasm/jsep/webgpu/ops/expand.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      validateInputs12 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("Expand requires 2 input.");
        }
        const inputShape = inputs[0].dims;
        const shape = Array.from(inputs[1].getBigInt64Array(), Number);
        let shapeIndex = shape.length < inputShape.length ? 0 : shape.length - inputShape.length;
        let inputShapeIndex = inputShape.length < shape.length ? 0 : inputShape.length - shape.length;
        for (; shapeIndex < shape.length && inputShapeIndex < inputShape.length; ++shapeIndex, ++inputShapeIndex) {
          if (shape[shapeIndex] !== inputShape[inputShapeIndex] && shape[shapeIndex] !== 1 && inputShape[inputShapeIndex] !== 1) {
            throw new Error("Expand requires shape to be broadcastable to input");
          }
        }
      };
      getAdjustedShape = (shape1, shape2) => {
        const diff = shape1.length - shape2.length;
        const shape = [];
        for (let i = 0; i < diff; ++i) {
          shape.push(shape1[i]);
        }
        for (let i = 0; i < shape2.length; ++i) {
          shape.push(shape2[i] === 1 ? shape1[i + diff] : shape2[i]);
        }
        return shape;
      };
      calculateOutputShape2 = (inputShape, shape) => inputShape.length > shape.length ? getAdjustedShape(inputShape, shape) : getAdjustedShape(shape, inputShape);
      createExpandProgramInfo = (inputs) => {
        const inputShape = inputs[0].dims;
        const shape = Array.from(inputs[1].getBigInt64Array(), Number);
        const outputShape = calculateOutputShape2(inputShape, shape);
        const dataType = inputs[0].dataType;
        const components = dataType === 9 /* bool */ ? 4 : 1;
        const outputSize = Math.ceil(ShapeUtil.size(outputShape) / components);
        const getShaderSource = (shaderHelper) => {
          const input = inputVariable("input", dataType, inputShape.length, components);
          const output = outputVariable("output", dataType, outputShape.length, components);
          let assignment;
          if (dataType === 9 /* bool */) {
            const singleAssignment = (resStr, x, typeCast = "") => `
          let outputIndices${x} = ${output.offsetToIndices(`outputOffset + ${x}u`)};
          let offset${x} = ${input.broadcastedIndicesToOffset(`outputIndices${x}`, output)};
          let index${x} = offset${x} / 4u;
          let component${x} = offset${x} % 4u;
          ${resStr}[${x}] = ${typeCast}(${input.getByOffset(`index${x}`)}[component${x}]);
        `;
            assignment = `
        let outputOffset = global_idx * ${components};
        var data = vec4<u32>(0);
        ${singleAssignment("data", 0, "u32")}
        ${singleAssignment("data", 1, "u32")}
        ${singleAssignment("data", 2, "u32")}
        ${singleAssignment("data", 3, "u32")}
        ${output.setByOffset("global_idx", "data")}
      }`;
          } else {
            assignment = `
        let outputIndices = ${output.offsetToIndices("global_idx")};
        let inputOffset = ${input.broadcastedIndicesToOffset("outputIndices", output)};
        ${output.setByOffset("global_idx", input.getByOffset("inputOffset"))}
      }`;
          }
          return `
    ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(input, output)}
    ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${assignment}`;
        };
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          ...createTensorShapeVariables(inputShape, outputShape)
        ];
        return {
          name: "Expand",
          shaderCache: { hint: `${outputShape.length}`, inputDependencies: ["rank"] },
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          })
        };
      };
      expand = (context) => {
        validateInputs12(context.inputs);
        context.compute(createExpandProgramInfo(context.inputs), { inputs: [0] });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/fast-gelu.ts
  var createFastGeluProgramInfo, fastGelu2;
  var init_fast_gelu = __esm({
    "web/lib/wasm/jsep/webgpu/ops/fast-gelu.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      init_unary_op();
      createFastGeluProgramInfo = (inputTensors) => {
        const dataType = inputTensors[0].dataType;
        const outputSize = ShapeUtil.size(inputTensors[0].dims);
        const biasLength = ShapeUtil.size(inputTensors[1].dims);
        const useVec4 = biasLength % 4 === 0;
        const getShaderSource = (shaderHelper) => {
          const x = inputVariable("x", dataType, [1], 4);
          const bias = inputVariable("bias", dataType, [1], 4);
          const y = outputVariable("y", dataType, [1], 4);
          const uniforms = [
            { name: "output_vec_size", type: "u32" },
            { name: "bias_size", type: "u32" }
          ];
          const singleElementBias = (i) => `
      let bias${i}_offset: u32 = (global_idx * 4 + ${i}) % uniforms.bias_size;
      let bias${i} = ${bias.getByOffset(`bias${i}_offset / 4`)}[bias${i}_offset % 4];`;
          const biasGetExpression = useVec4 ? `
      let bias = ${bias.getByOffset("global_idx % (uniforms.bias_size / 4)")};` : `${singleElementBias(0)}${singleElementBias(1)}${singleElementBias(2)}${singleElementBias(3)}
      let bias = ${x.type.value}(bias0, bias1, bias2, bias3);`;
          return `${shaderHelper.registerUniforms(uniforms).declareVariables(x, bias, y)}

    ${fastGeluImpl(tensorTypeToWsglValueType(dataType))}

    ${shaderHelper.mainStart(WORKGROUP_SIZE)}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${x.getByOffset("global_idx")};
      ${biasGetExpression}
      let x_in = x + bias;
      ${y.setByOffset("global_idx", fastGeluExpression("x_in"))}
    }`;
        };
        return {
          name: "FastGeluWithBias",
          shaderCache: { hint: `${useVec4}`, inputDependencies: ["type", "type"] },
          getShaderSource,
          getRunData: (inputs) => ({
            outputs: [{ dims: inputs[0].dims, dataType: inputs[0].dataType }],
            programUniforms: [
              { type: 12 /* uint32 */, data: Math.ceil(outputSize / 4) },
              { type: 12 /* uint32 */, data: biasLength }
            ],
            dispatchGroup: { x: Math.ceil(outputSize / WORKGROUP_SIZE / 4) }
          })
        };
      };
      fastGelu2 = (context) => {
        if (context.inputs.length < 2 || ShapeUtil.size(context.inputs[1].dims) === 0) {
          fastGelu(context);
        } else {
          context.compute(createFastGeluProgramInfo(context.inputs));
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/gather.ts
  var validateInputs13, createGatherProgramInfo, parseGatherAttributes, gather;
  var init_gather = __esm({
    "web/lib/wasm/jsep/webgpu/ops/gather.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs13 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("Gather requires 2 inputs.");
        }
      };
      createGatherProgramInfo = (inputs, attributes) => {
        const inputShape = inputs[0].dims;
        const indicesShape = inputs[1].dims;
        const inputRank = inputShape.length;
        const axis = ShapeUtil.normalizeAxis(attributes.axis, inputRank);
        const outputShape = inputShape.slice(0);
        outputShape.splice(axis, 1, ...indicesShape);
        const axisDimLimit = inputShape[axis];
        const components = inputs[0].dataType === 9 /* bool */ ? 4 : 1;
        const outputSize = Math.ceil(ShapeUtil.size(outputShape) / components);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 6 /* int32 */, data: axisDimLimit },
          { type: 12 /* uint32 */, data: axis },
          ...createTensorShapeVariables(inputs[0].dims, inputs[1].dims, outputShape)
        ];
        const getShaderSource = (shaderHelper) => {
          const data = inputVariable("data", inputs[0].dataType, inputs[0].dims.length, components);
          const indices = inputVariable("inputIndices", inputs[1].dataType, inputs[1].dims.length);
          const output = outputVariable("output", inputs[0].dataType, outputShape.length, components);
          const calcDataIndices = (x) => {
            const indicesRank = indicesShape.length;
            let calcStr = `var indicesIndices${x}  = ${indices.type.indices}(0);`;
            for (let i = 0; i < indicesRank; i++) {
              calcStr += `${indicesRank > 1 ? `indicesIndices${x}[${i}]` : `indicesIndices${x}`} = ${outputShape.length > 1 ? `outputIndices${x}[uniforms.axis + ${i}]` : `outputIndices${x}`};`;
            }
            calcStr += `
          var idx${x} = ${indices.getByIndices(`indicesIndices${x}`)};
          if (idx${x} < 0) {
            idx${x} = idx${x} + uniforms.axisDimLimit;
          }
          var dataIndices${x} : ${data.type.indices};
        `;
            for (let i = 0, j = 0; i < inputRank; i++) {
              if (i === axis) {
                calcStr += `${inputRank > 1 ? `dataIndices${x}[${i}]` : `dataIndices${x}`} = u32(idx${x});`;
                j += indicesRank;
              } else {
                calcStr += `${inputRank > 1 ? `dataIndices${x}[${i}]` : `dataIndices${x}`} = ${outputShape.length > 1 ? `outputIndices${x}[${j}]` : `outputIndices${x}`};`;
                j++;
              }
            }
            return calcStr;
          };
          let assignment;
          if (inputs[0].dataType === 9 /* bool */) {
            const singleAssignment = (resStr, x, typeCast = "") => `
          let outputIndices${x} = ${output.offsetToIndices(`outputOffset + ${x}u`)};
          ${calcDataIndices(x)};
          let offset${x} = ${data.indicesToOffset(`dataIndices${x}`)};
          let index${x} = offset${x} / 4u;
          let component${x} = offset${x} % 4u;
          ${resStr}[${x}] = ${typeCast}(${data.getByOffset(`index${x}`)}[component${x}]);
        `;
            assignment = `
        let outputOffset = global_idx * ${components};
        var value = vec4<u32>(0);
        ${singleAssignment("value", 0, "u32")}
        ${singleAssignment("value", 1, "u32")}
        ${singleAssignment("value", 2, "u32")}
        ${singleAssignment("value", 3, "u32")}
        ${output.setByOffset("global_idx", "value")}
      `;
          } else {
            assignment = `
      let outputIndices = ${output.offsetToIndices("global_idx")};
      ${calcDataIndices("")};
      let value = ${data.getByIndices("dataIndices")};
      ${output.setByOffset("global_idx", "value")};
      `;
          }
          return `
      ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axisDimLimit", "i32").registerUniform("axis", "u32").declareVariables(data, indices, output)}
      ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${assignment}
      }`;
        };
        return {
          name: "Gather",
          shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank", "rank"] },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      parseGatherAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
      gather = (context, attributes) => {
        const inputs = context.inputs;
        validateInputs13(inputs);
        context.compute(createGatherProgramInfo(context.inputs, attributes));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/gather-block-quantized.ts
  var validateInputs14, createGatherBlockQuantizedProgramInfo, gatherBlockQuantized, parseGatherBlockQuantizedAttributes;
  var init_gather_block_quantized = __esm({
    "web/lib/wasm/jsep/webgpu/ops/gather-block-quantized.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs14 = (inputs, attributes) => {
        if (inputs.length < 3 || inputs.length > 4) {
          throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");
        }
        const quantizeAxis = ShapeUtil.normalizeAxis(attributes.quantizeAxis, inputs[0].dims.length);
        const blockSize = attributes.blockSize;
        const data = inputs[0];
        const scales = inputs[2];
        const zeroPoint = inputs.length === 4 ? inputs[3] : void 0;
        if (scales.dims.length !== data.dims.length || !data.dims.map((d, i) => i === quantizeAxis ? Math.ceil(d / blockSize) === scales.dims[i] : d === scales.dims[i]).reduce((a, b) => a && b, true)) {
          throw new Error(
            "Scales must have the same rank as the input tensor and the dims should match except on gatherAxis."
          );
        }
        if (zeroPoint) {
          if (zeroPoint.dataType !== data.dataType) {
            throw new Error("Zero point must have the same data type as the input tensor.");
          }
          if (zeroPoint.dims.length !== scales.dims.length || !zeroPoint.dims.map((d, i) => d === scales.dims[i]).reduce((a, b) => a && b, true)) {
            throw new Error(
              "Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis."
            );
          }
        }
      };
      createGatherBlockQuantizedProgramInfo = (inputs, attributes) => {
        const inputShape = inputs[0].dims;
        const indicesShape = inputs[1].dims;
        const inputRank = inputShape.length;
        const gatherAxis = ShapeUtil.normalizeAxis(attributes.gatherAxis, inputRank);
        const quantizeAxis = ShapeUtil.normalizeAxis(attributes.quantizeAxis, inputRank);
        const outputShape = inputShape.slice(0);
        outputShape.splice(gatherAxis, 1, ...indicesShape);
        const outputSize = ShapeUtil.size(outputShape);
        const outputType = inputs[2].dataType;
        const inputType = inputs[0].dataType;
        const isSigned = inputType === 22 /* int4 */;
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: quantizeAxis },
          { type: 12 /* uint32 */, data: gatherAxis },
          { type: 12 /* uint32 */, data: attributes.blockSize },
          ...createTensorShapeVariables(...inputs.map((input, _) => input.dims), outputShape)
        ];
        const getShaderSource = (shaderHelper) => {
          const data = inputVariable("data", inputs[0].dataType, inputs[0].dims.length);
          const indices = inputVariable("inputIndices", inputs[1].dataType, inputs[1].dims.length);
          const scales = inputVariable("scales", inputs[2].dataType, inputs[2].dims.length);
          const zeroPoint = inputs.length > 3 ? inputVariable("zeroPoint", inputs[3].dataType, inputs[3].dims.length) : void 0;
          const output = outputVariable("output", outputType, outputShape.length);
          const inputVariables = [data, indices, scales];
          if (zeroPoint) {
            inputVariables.push(zeroPoint);
          }
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "quantize_axis", type: "u32" },
            { name: "gather_axis", type: "u32" },
            { name: "block_size", type: "u32" }
          ];
          return `
        ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
        ${shaderHelper.mainStart()}
        let output_indices = ${output.offsetToIndices("global_idx")};
        var indices_indices = ${indices.type.indices}(0);
        ${(() => {
            if (indicesShape.length > 1) {
              return `
          for (var i: u32 = 0; i < ${indicesShape.length}; i++) {
            let index = ${output.indicesGet("output_indices", "uniforms.gather_axis + i")};
            ${indices.indicesSet("indices_indices", "i", "index")};
          }`;
            } else {
              return `indices_indices = ${output.indicesGet("output_indices", "uniforms.gather_axis")};`;
            }
          })()};
        var data_indices = ${data.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${output.indicesGet("output_indices", "i")};
          ${data.indicesSet("data_indices", "i", "index")};
        }
        var index_from_indices = ${indices.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${inputShape[gatherAxis]};
        }
        ${data.indicesSet("data_indices", "uniforms.gather_axis", "u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${outputShape.length}; i++) {
          let index = ${output.indicesGet("output_indices", `i + ${indicesShape.length} - 1`)};
          ${data.indicesSet("data_indices", "i", "index")};
        }
        let data_offset = ${data.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${data.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${isSigned ? "unpack4xI8" : "unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${scales.indicesGet("data_indices", "uniforms.quantize_axis")} / uniforms.block_size;
        ${scales.indicesSet("scale_indices", "uniforms.quantize_axis", "quantize_axis_index")};
        var scale = ${scales.getByIndices("scale_indices")};
        ${(() => {
            if (!zeroPoint) {
              return "var zero_point = 0";
            } else {
              return `
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${zeroPoint.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${zeroPoint.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${isSigned ? "unpack4xI8" : "unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`;
            }
          })()};
        let dequantized_data = ${tensorTypeToWsglValueType(outputType)}(quantized_data - zero_point) * scale;
        ${output.setByOffset("global_idx", "dequantized_data")};
    }`;
        };
        return {
          name: "GatherBlockQuantized",
          shaderCache: {
            hint: `${attributes.cacheKey};${inputs.filter((_, i) => i !== 1).map((input) => input.dims.join("_")).join(";")}`,
            inputDependencies: Array.from({ length: inputs.length }, (_v, _i) => "rank")
          },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: outputType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      gatherBlockQuantized = (context, attributes) => {
        const inputs = context.inputs;
        validateInputs14(inputs, attributes);
        context.compute(createGatherBlockQuantizedProgramInfo(context.inputs, attributes));
      };
      parseGatherBlockQuantizedAttributes = (attributes) => createAttributeWithCacheKey({
        blockSize: attributes.blockSize,
        gatherAxis: attributes.gatherAxis,
        quantizeAxis: attributes.quantizeAxis
      });
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/gather-elements.ts
  var validateInputs15, createGatherElementsProgramInfo, parseGatherElementsAttributes, gatherElements;
  var init_gather_elements = __esm({
    "web/lib/wasm/jsep/webgpu/ops/gather-elements.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs15 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("GatherElements requires 2 inputs.");
        }
        if (inputs[0].dims.length < 1) {
          throw new Error("GatherElements requires that the data input be rank >= 1.");
        }
        if (inputs[0].dims.length !== inputs[1].dims.length) {
          throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`);
        }
      };
      createGatherElementsProgramInfo = (inputs, attributes) => {
        const inputShape = inputs[0].dims;
        const inputOutputDataType = inputs[0].dataType;
        const inputRank = inputShape.length;
        const indicesShape = inputs[1].dims;
        const indicesDataType = inputs[1].dataType;
        const axis = ShapeUtil.normalizeAxis(attributes.axis, inputRank);
        const axisDimLimit = inputShape[axis];
        const outputShape = indicesShape.slice(0);
        const outputSize = ShapeUtil.size(outputShape);
        const input = inputVariable("input", inputOutputDataType, inputRank);
        const indices = inputVariable("indicesInput", indicesDataType, indicesShape.length);
        const output = outputVariable("output", inputOutputDataType, outputShape.length);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 6 /* int32 */, data: axisDimLimit },
          { type: 12 /* uint32 */, data: axis }
        ];
        programUniforms.push(...createTensorShapeVariables(inputShape, indicesShape, outputShape));
        const inputDependencies = ["rank", "rank"];
        const getShaderSource = (shaderHelper) => `
      ${shaderHelper.registerUniform("outputSize", "u32").registerUniform("axisDimLimit", "i32").registerUniform("axis", "u32").declareVariables(input, indices, output)}
      ${shaderHelper.mainStart()}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${output.offsetToIndices("global_idx")};

      var idx = ${indices.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${input.type.indices}(outputIndices);
      ${input.indicesSet("inputIndices", "uniforms.axis", "u32(idx)")};
      let value = ${input.getByIndices("inputIndices")};

      ${output.setByOffset("global_idx", "value")};
  }`;
        return {
          name: "GatherElements",
          shaderCache: { inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      parseGatherElementsAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
      gatherElements = (context, attributes) => {
        const inputs = context.inputs;
        validateInputs15(inputs);
        context.compute(createGatherElementsProgramInfo(context.inputs, attributes));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/gemm.ts
  var validateInputs16, createGemmProgramInfo, parseGemmAttributes, gemm;
  var init_gemm = __esm({
    "web/lib/wasm/jsep/webgpu/ops/gemm.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      validateInputs16 = (inputs) => {
        if (!inputs) {
          throw new Error("Input is missing");
        }
        if (inputs.length < 2 || inputs.length > 3) {
          throw new Error("Invaid input number.");
        }
        if (inputs.length === 3 && inputs[2].dims.length > 2) {
          throw new Error("Invalid input shape of C");
        }
        if (inputs[0].dataType !== inputs[1].dataType || inputs.length === 3 && inputs[0].dataType !== inputs[2].dataType) {
          throw new Error("Input types are mismatched");
        }
      };
      createGemmProgramInfo = (inputs, attributes) => {
        const aShape = inputs[0].dims.slice();
        const bShape = inputs[1].dims.slice();
        const [M, N, K] = GemmUtil.getShapeOfGemmResult(
          aShape,
          attributes.transA,
          bShape,
          attributes.transB,
          inputs.length === 3 ? inputs[2].dims : void 0
        );
        const outputShape = [M, N];
        if (!outputShape) {
          throw new Error("Can't use gemm on the given tensors");
        }
        const outputSize = ShapeUtil.size(outputShape);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: M },
          { type: 12 /* uint32 */, data: N },
          { type: 12 /* uint32 */, data: K },
          { type: 1 /* float */, data: attributes.alpha },
          { type: 1 /* float */, data: attributes.beta }
        ];
        const inputDependencies = ["type", "type"];
        if (inputs.length === 3) {
          programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
          inputDependencies.push("rank");
        }
        programUniforms.push(...createTensorShapeVariables(outputShape));
        const getShaderSource = (shaderHelper) => {
          let line = "";
          if (attributes.transA && attributes.transB) {
            line = "value += a[k * uniforms.M + m] * b[n * uniforms.K + k];";
          } else if (attributes.transA && !attributes.transB) {
            line = "value += a[k * uniforms.M + m] * b[k * uniforms.N + n];";
          } else if (!attributes.transA && attributes.transB) {
            line = "value += a[m * uniforms.K + k] * b[n * uniforms.K + k];";
          } else if (!attributes.transA && !attributes.transB) {
            line = "value += a[m * uniforms.K + k] * b[k * uniforms.N + n];";
          }
          const calculateAlpha = attributes.alpha === 1 ? "" : "value *= uniforms.alpha;";
          const a = inputVariable("a", inputs[0].dataType, inputs[0].dims);
          const b = inputVariable("b", inputs[1].dataType, inputs[1].dims);
          const dataType = a.type.value;
          let c = null;
          const variables = [a, b];
          if (inputs.length === 3) {
            c = inputVariable("c", inputs[2].dataType, inputs[2].dims.length);
            variables.push(c);
          }
          const output = outputVariable("output", inputs[0].dataType, outputShape.length);
          variables.push(output);
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "M", type: "u32" },
            { name: "N", type: "u32" },
            { name: "K", type: "u32" },
            { name: "alpha", type: "f32" },
            { name: "beta", type: "f32" }
          ];
          return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${dataType}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${line}
    }

    ${calculateAlpha}
    ${(() => {
            if (c != null) {
              return `let cOffset = ${c.broadcastedIndicesToOffset("vec2(m, n)", output)}; value += ${dataType}(uniforms.beta) * ${c.getByOffset("cOffset")};`;
            }
            return "";
          })()}
    output[global_idx] = value;
  }`;
        };
        return {
          name: "Gemm",
          shaderCache: { hint: `${attributes.cacheKey}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      parseGemmAttributes = (attributes) => {
        const transA = attributes.transA;
        const transB = attributes.transB;
        const alpha = attributes.alpha;
        const beta = attributes.beta;
        return {
          transA,
          transB,
          alpha,
          beta,
          cacheKey: `${attributes.transA};${attributes.transB};${attributes.alpha === 1}`
        };
      };
      gemm = (context, attributes) => {
        validateInputs16(context.inputs);
        context.compute(createGemmProgramInfo(context.inputs, attributes));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/multihead-attention.ts
  var getInput, validateInputs17, parseMultiHeadAttentionAttributes, weightTransposeAttribute2, addBiasTranspose, maybeTransposeToBNSHAndAddBias, multiHeadAttention;
  var init_multihead_attention = __esm({
    "web/lib/wasm/jsep/webgpu/ops/multihead-attention.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_types();
      init_attention();
      init_common();
      init_transpose();
      getInput = (inputs, i) => inputs.length > i && inputs[i].dims.length > 0 ? inputs[i] : void 0;
      validateInputs17 = (inputs, attributes) => {
        const query = inputs[0];
        const key = getInput(inputs, 1);
        const value = getInput(inputs, 2);
        const bias = getInput(inputs, 3);
        const keyPaddingMask = getInput(inputs, 4);
        const attentionBias = getInput(inputs, 5);
        const pastKey = getInput(inputs, 6);
        const pastValue = getInput(inputs, 7);
        if (query.dims.length !== 3 && query.dims.length !== 5) {
          throw new Error("Input query is expected to have 3 or 5 dimensions");
        }
        const batchSize = query.dims[0];
        const sequenceLength = query.dims[1];
        const hiddenSize = query.dims.length === 3 ? query.dims[2] : attributes.numHeads * query.dims[4];
        let kvSequenceLength = sequenceLength;
        let pastSequenceLength = 0;
        let maxSequenceLength = 0;
        const headSize = Math.floor(hiddenSize / attributes.numHeads);
        if (pastKey && pastValue && ShapeUtil.size(pastKey.dims) && ShapeUtil.size(pastValue.dims)) {
          if (pastKey.dims.length !== 4) {
            throw new Error('Input "past_key" is expected to have 4 dimensions');
          }
          if (pastKey.dims[0] !== batchSize || pastKey.dims[1] !== attributes.numHeads || pastKey.dims[3] !== headSize) {
            throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');
          }
          if (pastValue.dims[0] !== batchSize || pastValue.dims[1] !== attributes.numHeads || pastValue.dims[3] !== headSize) {
            throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');
          }
          if (pastKey.dims[2] !== pastValue.dims[2]) {
            throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');
          }
          if (pastValue.dims.length !== 4) {
            throw new Error('Input "past_value" is expected to have 4 dimensions');
          }
          pastSequenceLength = pastKey.dims[2];
          maxSequenceLength = pastKey.dims[2];
        } else if (pastKey && ShapeUtil.size(pastKey.dims) || pastValue && ShapeUtil.size(pastValue.dims)) {
          throw new Error('Input "past_key" and "past_value" shall be both present or both absent');
        }
        let qkvFormat;
        if (key && ShapeUtil.size(key.dims) > 0) {
          if (query.dims.length !== 3) {
            throw new Error('Input "query" is expected to have 3 dimensions when key is given');
          }
          if (key.dims.length < 3 || key.dims.length > 5) {
            throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');
          }
          if (query.dims[0] !== key.dims[0]) {
            throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');
          }
          if (key.dims.length === 3) {
            if (key.dims[2] !== query.dims[2]) {
              throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');
            }
            qkvFormat = 2 /* qkvBSNH */;
            kvSequenceLength = key.dims[1];
          } else if (key.dims.length === 5) {
            if (key.dims[2] !== attributes.numHeads || key.dims[3] !== 2 || key.dims[4] !== headSize) {
              throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');
            }
            if (value) {
              throw new Error('Expect "value" be none when "key" has packed kv format.');
            }
            qkvFormat = 5 /* qKvBSNHxBSN2H */;
            kvSequenceLength = key.dims[1];
          } else {
            if (key.dims[1] !== attributes.numHeads || key.dims[3] !== headSize) {
              throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');
            }
            qkvFormat = 0 /* unknown */;
            kvSequenceLength = key.dims[2];
          }
        } else {
          if (query.dims.length !== 5) {
            throw new Error('Input "query" is expected to have 5 dimensions when key is empty');
          }
          if (query.dims[2] !== attributes.numHeads || query.dims[3] !== 3) {
            throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');
          }
          qkvFormat = 3 /* qkvBSN3H */;
        }
        if (bias && ShapeUtil.size(bias.dims) > 0) {
          if (bias.dims.length !== 1) {
            throw new Error('Input "bias" is expected to have 1 dimension');
          }
          if (key) {
            if (key.dims.length === 5 && key.dims[3] === 2) {
              throw new Error("bias is not allowed for packed kv.");
            }
          }
        }
        const totalSequenceLength = pastSequenceLength + kvSequenceLength;
        let maskType = 0 /* none */;
        if (keyPaddingMask && ShapeUtil.size(keyPaddingMask.dims) > 0) {
          maskType = 8 /* maskUnknown */;
          const maskDims = keyPaddingMask.dims;
          if (maskDims.length === 1) {
            if (maskDims[0] === batchSize) {
              maskType = 1 /* mask1dKeySeqLen */;
            } else if (maskDims[0] === 3 * batchSize + 2) {
              maskType = 3 /* mask1DKeySeqLenStart */;
            }
          } else if (maskDims.length === 2 && maskDims[0] === batchSize && maskDims[1] === totalSequenceLength) {
            maskType = 5 /* mask2dKeyPadding */;
          }
          if (maskType === 8 /* maskUnknown */) {
            throw new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)');
          }
          throw new Error("Mask not supported");
        }
        let passPastInKv = false;
        let vHiddenSize = hiddenSize;
        if (value && ShapeUtil.size(value.dims) > 0) {
          if (value.dims.length !== 3 && value.dims.length !== 4) {
            throw new Error('Input "value" is expected to have 3 or 4 dimensions');
          }
          if (query.dims[0] !== value.dims[0]) {
            throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');
          }
          if (value.dims.length === 3) {
            if (kvSequenceLength !== value.dims[1]) {
              throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');
            }
            vHiddenSize = value.dims[2];
          } else {
            if (kvSequenceLength !== value.dims[2]) {
              throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');
            }
            vHiddenSize = value.dims[1] * value.dims[3];
            passPastInKv = true;
          }
        }
        const broadcastResPosBias = false;
        if (keyPaddingMask && ShapeUtil.size(keyPaddingMask.dims) > 0) {
          throw new Error("Key padding mask is not supported");
        }
        if (attentionBias && ShapeUtil.size(attentionBias.dims) > 0) {
          if (attentionBias.dims.length !== 4) {
            throw new Error('Input "attention_bias" is expected to have 4 dimensions');
          }
          if (attentionBias.dims[0] !== batchSize || attentionBias.dims[1] !== attributes.numHeads || attentionBias.dims[2] !== sequenceLength || attentionBias.dims[3] !== totalSequenceLength) {
            throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)');
          }
        }
        return {
          batchSize,
          sequenceLength,
          pastSequenceLength,
          kvSequenceLength,
          totalSequenceLength,
          maxSequenceLength,
          inputHiddenSize: 0,
          hiddenSize,
          vHiddenSize,
          headSize,
          vHeadSize: Math.floor(vHiddenSize / attributes.numHeads),
          numHeads: attributes.numHeads,
          isUnidirectional: false,
          pastPresentShareBuffer: false,
          maskFilterValue: attributes.maskFilterValue,
          maskType,
          scale: attributes.scale,
          broadcastResPosBias,
          passPastInKv,
          qkvFormat
        };
      };
      parseMultiHeadAttentionAttributes = (attributes) => createAttributeWithCacheKey({ ...attributes });
      weightTransposeAttribute2 = createAttributeWithCacheKey({ perm: [0, 2, 1, 3] });
      addBiasTranspose = (context, qkv, bias, batchSize, sequenceLength, hiddenSize, biasOffset) => {
        const outputShape = [batchSize, sequenceLength, hiddenSize];
        const outputSize = ShapeUtil.size(outputShape);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: biasOffset },
          { type: 12 /* uint32 */, data: hiddenSize }
        ];
        const getShaderSource = (shaderHelper) => {
          const output = outputVariable("qkv_with_bias", qkv.dataType, outputShape);
          const qkvInput = inputVariable("qkv", qkv.dataType, outputShape);
          const biasInput = inputVariable("bias", bias.dataType, outputShape);
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "bias_offset", type: "u32" },
            { name: "hidden_size", type: "u32" }
          ];
          return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(qkvInput, biasInput, output)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`;
        };
        return context.compute(
          {
            name: "MultiHeadAttentionAddBias",
            shaderCache: { inputDependencies: ["type", "type"] },
            getRunData: () => ({
              outputs: [{ dims: outputShape, dataType: qkv.dataType, gpuDataType: 0 /* default */ }],
              dispatchGroup: { x: Math.ceil(
                outputSize / 64
                /* workgroup size */
              ) },
              programUniforms
            }),
            getShaderSource
          },
          { inputs: [qkv, bias], outputs: [-1] }
        )[0];
      };
      maybeTransposeToBNSHAndAddBias = (context, batchSize, numHeads, sequenceLength, headSize, input, bias, biasOffset) => {
        let reshapedInput = input;
        if (!(bias && ShapeUtil.size(bias.dims) > 0)) {
          if (input.dims.length === 3) {
            reshapedInput = input.reshape([batchSize, sequenceLength, numHeads, headSize]);
          }
          return context.compute(createTransposeProgramInfo(reshapedInput, weightTransposeAttribute2.perm), {
            inputs: [reshapedInput],
            outputs: [-1]
          })[0];
        } else {
          if (sequenceLength === 1) {
            throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");
          } else {
            reshapedInput = addBiasTranspose(
              context,
              input,
              bias,
              batchSize,
              sequenceLength,
              numHeads * headSize,
              biasOffset
            );
            reshapedInput = reshapedInput.reshape([batchSize, sequenceLength, numHeads, headSize]);
            return context.compute(createTransposeProgramInfo(reshapedInput, weightTransposeAttribute2.perm), {
              inputs: [reshapedInput],
              outputs: [-1]
            })[0];
          }
        }
      };
      multiHeadAttention = (context, attributes) => {
        const params = validateInputs17(context.inputs, attributes);
        const query = context.inputs[0];
        const key = getInput(context.inputs, 1);
        const value = getInput(context.inputs, 2);
        const bias = getInput(context.inputs, 3);
        const keyPaddingMask = getInput(context.inputs, 4);
        const attentionBias = getInput(context.inputs, 5);
        const pastKey = getInput(context.inputs, 6);
        const pastValue = getInput(context.inputs, 7);
        if (query.dims.length === 5) {
          throw new Error("Packed QKV is not implemented");
        }
        if (key?.dims.length === 5) {
          throw new Error("Packed KV is not implemented");
        }
        const kvBNSH = key && value && key.dims.length === 4 && value.dims.length === 4;
        const Q = maybeTransposeToBNSHAndAddBias(
          context,
          params.batchSize,
          params.numHeads,
          params.sequenceLength,
          params.headSize,
          query,
          bias,
          0
        );
        if (kvBNSH) {
          return applyAttention(
            context,
            Q,
            key,
            value,
            keyPaddingMask,
            void 0,
            pastKey,
            pastValue,
            attentionBias,
            params,
            attributes
          );
        }
        if (!key || !value) {
          throw new Error("key and value must be provided");
        }
        const K = maybeTransposeToBNSHAndAddBias(
          context,
          params.batchSize,
          params.numHeads,
          params.kvSequenceLength,
          params.headSize,
          key,
          bias,
          params.hiddenSize
        );
        const V = maybeTransposeToBNSHAndAddBias(
          context,
          params.batchSize,
          params.numHeads,
          params.kvSequenceLength,
          params.vHeadSize,
          value,
          bias,
          2 * params.hiddenSize
        );
        applyAttention(context, Q, K, V, keyPaddingMask, void 0, pastKey, pastValue, attentionBias, params, attributes);
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/tile.ts
  var getRepeats, validateInputs18, getOutputShape2, createTileProgramInfo, tile;
  var init_tile = __esm({
    "web/lib/wasm/jsep/webgpu/ops/tile.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      getRepeats = (repeatsTensorView) => Array.from(repeatsTensorView.getBigInt64Array(), Number);
      validateInputs18 = (inputs) => {
        if (!inputs || inputs.length !== 2) {
          throw new Error("Tile requires 2 inputs.");
        }
        if (inputs[0].dataType !== 1 /* float */ && inputs[0].dataType !== 10 /* float16 */ && inputs[0].dataType !== 6 /* int32 */ && inputs[0].dataType !== 12 /* uint32 */) {
          throw new Error("Tile only support float, float16, int32, and uint32 data types");
        }
        if (inputs[1].dataType !== 7 /* int64 */) {
          throw new Error("Tile `repeats` input should be of int64 data type");
        }
        if (inputs[1].dims.length !== 1) {
          throw new Error("Tile `repeats` input should be 1-D");
        }
        const repeats = getRepeats(inputs[1]);
        if (repeats.length !== inputs[0].dims.length) {
          throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor");
        }
      };
      getOutputShape2 = (inputShape, repeats) => {
        const outputShape = [];
        for (let i = 0; i < inputShape.length; ++i) {
          outputShape.push(inputShape[i] * repeats[i]);
        }
        return outputShape;
      };
      createTileProgramInfo = (inputs, shape) => {
        const inputShape = inputs[0].dims;
        const repeats = shape == null ? getRepeats(inputs[1]) : shape;
        const outputShape = getOutputShape2(inputShape, repeats);
        const outputSize = ShapeUtil.size(outputShape);
        const dataType = inputs[0].dataType;
        const input = inputVariable("input", dataType, inputShape.length);
        const output = outputVariable("output", dataType, outputShape.length);
        const getShaderSource = (shaderHelper) => `
      const inputShape = ${input.indices(...inputShape)};
      ${shaderHelper.registerUniform("output_size", "u32").declareVariables(input, output)}
      ${shaderHelper.mainStart()}
      ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${output.offsetToIndices("global_idx")};
      var input_indices: ${input.type.indices};
      for (var i = 0; i < ${inputShape.length}; i++) {
        let input_dim_i = ${input.indicesGet("uniforms.input_shape", "i")};
        let input_dim_value = ${output.indicesGet("output_indices", "i")}  % input_dim_i;

        ${input.indicesSet("input_indices", "i", "input_dim_value")}
      }
      ${output.setByOffset("global_idx", input.getByIndices("input_indices"))}
    }`;
        return {
          name: "Tile",
          shaderCache: { hint: `${repeats}`, inputDependencies: ["rank"] },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: outputSize },
              ...createTensorShapeVariables(inputs[0].dims, outputShape)
            ]
          }),
          getShaderSource
        };
      };
      tile = (context) => {
        validateInputs18(context.inputs);
        context.compute(createTileProgramInfo(context.inputs), { inputs: [0] });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/group-query-attention.ts
  var validateInputs19, createConcatProgramInfo2, parseGroupQueryAttentionAttributes, weightTransposeAttribute3, maybeExpandAndTransposeToBNSH, groupQueryAttention;
  var init_group_query_attention = __esm({
    "web/lib/wasm/jsep/webgpu/ops/group-query-attention.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_attention();
      init_common();
      init_multihead_attention();
      init_tile();
      init_transpose();
      validateInputs19 = (inputs, attributes) => {
        const query = inputs[0];
        const key = inputs[1];
        const value = inputs[2];
        const pastKey = inputs[3];
        const pastValue = inputs[4];
        if (query.dims.length !== 3 && query.dims.length !== 5) {
          throw new Error("Input query is expected to have 3 or 5 dimensions");
        }
        const dmmhaPacking = false;
        const batchSize = query.dims[0];
        const sequenceLength = query.dims[1];
        const hiddenSize = query.dims.length === 3 ? dmmhaPacking ? query.dims[2] / 3 : query.dims[2] : attributes.numHeads * query.dims[4];
        let kvSequenceLength = sequenceLength;
        let pastSequenceLength = 0;
        let maxSequenceLength = 0;
        const headSize = Math.floor(hiddenSize / attributes.numHeads);
        const hasPastKey = pastKey && pastKey.dims.length !== 0;
        const hasPastValue = pastValue && pastValue.dims.length !== 0;
        const isPastkvBSNH = true;
        if (hasPastKey && hasPastValue) {
          if (pastKey.dims.length !== 4) {
            throw new Error('Input "past_key" is expected to have 4 dimensions');
          }
          if (pastValue.dims.length !== 4) {
            throw new Error('Input "past_value" is expected to have 4 dimensions');
          }
          if (isPastkvBSNH) {
            pastSequenceLength = pastKey.dims[1];
            maxSequenceLength = pastKey.dims[1];
          } else {
            pastSequenceLength = pastKey.dims[2];
            maxSequenceLength = pastKey.dims[2];
          }
        } else if (hasPastKey || hasPastValue) {
          throw new Error('Input "past_key" and "past_value" shall be both present or both absent');
        }
        let qkvFormat;
        if (key) {
          if (query.dims.length !== 3) {
            throw new Error('Input "query" is expected to have 3 dimensions when key is given');
          }
          if (key.dims.length < 3 || key.dims.length > 5) {
            throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');
          }
          if (query.dims[0] !== key.dims[0]) {
            throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');
          }
          if (key.dims.length === 3) {
            if (query.dims[2] % key.dims[2] !== 0) {
              throw new Error('Dimension 2 of "query" should be a multiple of "key"');
            }
            qkvFormat = 2 /* qkvBSNH */;
            kvSequenceLength = key.dims[1];
          } else if (key.dims.length === 5) {
            if (key.dims[2] !== attributes.numHeads || key.dims[3] !== 2 || key.dims[4] !== headSize) {
              throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');
            }
            if (value) {
              throw new Error('Expect "value" be none when "key" has packed kv format.');
            }
            qkvFormat = 5 /* qKvBSNHxBSN2H */;
            kvSequenceLength = key.dims[1];
          } else {
            if (key.dims[1] !== attributes.numHeads || key.dims[3] !== headSize) {
              throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');
            }
            qkvFormat = 0 /* unknown */;
            kvSequenceLength = key.dims[2];
          }
        } else {
          if (query.dims.length !== 3 && query.dims.length !== 5) {
            throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');
          }
          if (query.dims.length === 5 && (query.dims[2] !== attributes.numHeads || query.dims[3] !== 3)) {
            throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');
          }
          qkvFormat = 3 /* qkvBSN3H */;
        }
        const maskType = 0 /* none */;
        let passPastInKv = false;
        let vHiddenSize = hiddenSize;
        if (value) {
          if (value.dims.length !== 3 && value.dims.length !== 4) {
            throw new Error('Input "value" is expected to have 3 or 4 dimensions');
          }
          if (query.dims[0] !== value.dims[0]) {
            throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');
          }
          if (value.dims.length === 3) {
            if (kvSequenceLength !== value.dims[1]) {
              throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');
            }
            vHiddenSize = value.dims[2];
          } else {
            if (kvSequenceLength !== value.dims[2]) {
              throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');
            }
            vHiddenSize = value.dims[1] * value.dims[3];
            passPastInKv = true;
          }
        }
        const totalSequenceLength = pastSequenceLength + kvSequenceLength;
        const broadcastResPosBias = false;
        return {
          batchSize,
          sequenceLength,
          pastSequenceLength,
          kvSequenceLength,
          totalSequenceLength,
          maxSequenceLength,
          inputHiddenSize: 0,
          hiddenSize,
          vHiddenSize,
          headSize,
          vHeadSize: Math.floor(vHiddenSize / attributes.kvNumHeads),
          numHeads: attributes.numHeads,
          kvNumHeads: attributes.kvNumHeads,
          nReps: attributes.numHeads / attributes.kvNumHeads,
          pastPresentShareBuffer: false,
          maskType,
          scale: attributes.scale,
          broadcastResPosBias,
          passPastInKv,
          qkvFormat,
          isPastkvBSNH
        };
      };
      createConcatProgramInfo2 = (a, b, dataType, params) => {
        const outputShape = [params.batchSize, params.totalSequenceLength, params.kvNumHeads, params.headSize];
        const component = 4;
        const outputSize = ShapeUtil.size(outputShape) / component;
        const presentSequenceLength = params.totalSequenceLength;
        const output = outputVariable("present_kv", dataType, outputShape.length, component);
        const inputA = inputVariable("new_kv", a.dataType, a.dims.length, component);
        const inputB = b ? inputVariable("past_kv", b.dataType, b.dims.length, component) : void 0;
        const H = Math.ceil(params.headSize / component);
        const dispatch = { x: presentSequenceLength, y: a.dims[0], z: 1 };
        const inputDependencies = b ? ["rank", "rank"] : ["rank"];
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: params.pastSequenceLength },
          { type: 12 /* uint32 */, data: params.kvSequenceLength },
          { type: 12 /* uint32 */, data: params.totalSequenceLength }
        ];
        const inputs = [inputA];
        if (inputB) {
          programUniforms.push(
            ...createTensorShapeVariables(a.dims),
            ...createTensorShapeVariables(b.dims),
            ...createTensorShapeVariables(outputShape)
          );
          inputs.push(inputB);
        } else {
          programUniforms.push(...createTensorShapeVariables(a.dims), ...createTensorShapeVariables(outputShape));
        }
        const uniforms = [
          { name: "output_size", type: "u32" },
          { name: "past_seqlen", type: "u32" },
          { name: "new_seqlen", type: "u32" },
          { name: "present_seqlen", type: "u32" }
        ];
        const pastStr = `      let past_batch_stride = uniforms.past_seqlen * num_heads * H;
        var past_head_stride = uniforms.past_seqlen * H;
        if (is_bsnh) {
          past_head_stride = H;
        }
        let in_offset = b * past_batch_stride + s * row_stride + n * past_head_stride + h;
        present_kv[out_offset] = past_kv[in_offset];`;
        const newStr = `      let new_batch_stride = uniforms.new_seqlen * num_heads * H;
        let new_row_stride = num_heads * H;
        let new_head_stride = H;
        let in_offset = b * new_batch_stride + (s - past_seqlen) * new_row_stride + n * new_head_stride + h;
        present_kv[out_offset] = new_kv[in_offset];`;
        const concatStr = b ? `if (s < past_seqlen) {
        ${pastStr}
        } else if (s < past_seqlen + uniforms.new_seqlen) {
        ${newStr}
        }` : `if (s < past_seqlen + uniforms.new_seqlen) {
          ${newStr}
        }`;
        const getShaderSource = (shaderHelper) => `

  ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputs, output)}
  ${shaderHelper.mainStart([H, params.kvNumHeads, 1])}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    var indices = ${output.offsetToIndices("global_idx")};
    let h = local_id.x;
    let n = local_id.y;
    let s = workgroup_id.x;
    let b = workgroup_id.y;
    let num_heads = ${params.kvNumHeads}u;
    let H = ${H}u;

    let present_seqlen = uniforms.present_seqlen;
    let present_batch_stride = present_seqlen * num_heads * H;
    var row_stride = H;
    let is_bsnh = ${params.isPastkvBSNH};

    if (is_bsnh) {
      row_stride = num_heads * H;
    }
    var present_head_stride = present_seqlen * H;
    if (is_bsnh) {
      present_head_stride = H;
    }

    let past_seqlen = uniforms.past_seqlen;

    let out_offset = b * present_batch_stride + s * row_stride + n * present_head_stride + h;
    ${concatStr}
  }`;
        return {
          name: "ConcatPastNew",
          shaderCache: { hint: `${params.kvNumHeads}${H}${!!b}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType }],
            dispatchGroup: dispatch,
            programUniforms
          }),
          getShaderSource
        };
      };
      parseGroupQueryAttentionAttributes = (attributes) => createAttributeWithCacheKey({ ...attributes });
      weightTransposeAttribute3 = createAttributeWithCacheKey({ perm: [0, 2, 1, 3] });
      maybeExpandAndTransposeToBNSH = (context, input, pastKV, params, outputIndex) => {
        let reshapedInput = input;
        const numHeads = params.kvNumHeads;
        const nReps = params.nReps;
        if (input.dims.length === 3 && params.kvSequenceLength !== 0) {
          reshapedInput = input.reshape([params.batchSize, params.kvSequenceLength, numHeads, params.headSize]);
        }
        if (pastKV) {
          reshapedInput = context.compute(createConcatProgramInfo2(reshapedInput, pastKV, reshapedInput.dataType, params), {
            inputs: [reshapedInput, pastKV],
            outputs: [params.isPastkvBSNH ? outputIndex : -1]
          })[0];
        } else {
          reshapedInput = context.compute(createConcatProgramInfo2(reshapedInput, void 0, reshapedInput.dataType, params), {
            inputs: [reshapedInput],
            outputs: [params.isPastkvBSNH ? outputIndex : -1]
          })[0];
        }
        if (nReps !== 1) {
          reshapedInput = context.compute(createTileProgramInfo([reshapedInput], [1, 1, 1, nReps]), {
            inputs: [reshapedInput],
            outputs: [-1]
          })[0];
          reshapedInput = reshapedInput.reshape([
            params.batchSize,
            params.totalSequenceLength,
            numHeads * nReps,
            params.headSize
          ]);
        }
        return context.compute(createTransposeProgramInfo(reshapedInput, weightTransposeAttribute3.perm), {
          inputs: [reshapedInput],
          outputs: [-1]
        })[0];
      };
      groupQueryAttention = (context, attributes) => {
        const params = validateInputs19(context.inputs, attributes);
        if (context.inputs[0].dims.length === 5) {
          throw new Error("Packed QKV is not implemented");
        }
        if (context.inputs[1]?.dims.length === 5) {
          throw new Error("Packed KV is not implemented");
        }
        const Q = maybeTransposeToBNSHAndAddBias(
          context,
          params.batchSize,
          params.numHeads,
          params.sequenceLength,
          params.headSize,
          context.inputs[0],
          void 0,
          0
        );
        const pastKey = context.inputs[3] && context.inputs[3].dims.length !== 0 ? context.inputs[3] : void 0;
        const pastValue = context.inputs[4] && context.inputs[4].dims.length !== 0 ? context.inputs[4] : void 0;
        const K = maybeExpandAndTransposeToBNSH(context, context.inputs[1], pastKey, params, 1);
        const V = maybeExpandAndTransposeToBNSH(context, context.inputs[2], pastValue, params, 2);
        applyAttention(context, Q, K, V, void 0, void 0, void 0, void 0, void 0, params, attributes);
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/instance-norm.ts
  var computeChannelScaleShift, createInstanceNormProgramInfo, createInstanceNormNHWCProgramInfo, instanceNorm;
  var init_instance_norm = __esm({
    "web/lib/wasm/jsep/webgpu/ops/instance-norm.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_transpose();
      init_common();
      computeChannelScaleShift = (context, input, scale, bias, n, h, c, epsilon) => {
        const components = getMaxComponents(h);
        const f32Type = components === 1 ? "f32" : `vec${components}f`;
        const wgType = components === 1 ? "vec2f" : `mat2x${components}f`;
        const unitsOfWork = n * c;
        const inputShape = [n, c, h / components];
        const outputShape = [n, c, 2];
        const inputDependencies = ["rank", "type", "type"];
        const programUniforms = [];
        programUniforms.push(...createTensorShapeVariables(inputShape, outputShape));
        const getShaderSource = (shaderHelper) => {
          const x = inputVariable("x", input.dataType, 3, components);
          const s = inputVariable("scale", scale.dataType, scale.dims);
          const b = inputVariable("bias", bias.dataType, bias.dims);
          const output = outputVariable("output", 1 /* float */, 3, 2);
          const variables = [x, s, b, output];
          const workgroupSize = 64;
          return `
  var<workgroup> workgroup_shared : array<${wgType}, ${workgroupSize}>;
  const workgroup_size = ${workgroupSize}u;
  ${shaderHelper.declareVariables(...variables)}
  ${shaderHelper.mainStart(workgroupSize)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${f32Type}(0);
    var squared_sum = ${f32Type}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${f32Type}(${x.get("batch", "channel", "h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${wgType}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${sumVector("workgroup_shared[0][0]", components)} / f32(hight * ${components});
      let squared_sum_final = ${sumVector("workgroup_shared[0][1]", components)} / f32(hight * ${components});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${epsilon}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`;
        };
        return context.compute(
          {
            name: "InstanceNormComputeChannelScaleShift",
            // TODO: use epsilon as uniform. Currently epsilon as uniform fails test_instancenorm_epsilon.
            shaderCache: { hint: `${components};${epsilon}`, inputDependencies },
            getRunData: () => ({
              outputs: [{ dims: outputShape, dataType: 1 /* float */ }],
              dispatchGroup: { x: unitsOfWork },
              programUniforms
            }),
            getShaderSource
          },
          { inputs: [input, scale, bias], outputs: [-1] }
        )[0];
      };
      createInstanceNormProgramInfo = (context, inputs, attributes) => {
        const xShape = inputs[0].dims;
        const outputShape = xShape;
        const axis = 2;
        const N = xShape[0];
        const C = xShape[1];
        const H = ShapeUtil.sizeFromDimension(xShape, axis);
        const components = getMaxComponents(H);
        const outputSize = ShapeUtil.size(outputShape) / components;
        const channelScaleShift = computeChannelScaleShift(
          context,
          inputs[0],
          inputs[1],
          inputs[2],
          N,
          H,
          C,
          attributes.epsilon
        );
        const inputShape = [N, C, H / components];
        const scaleShape = [N, C];
        const inputDependencies = ["type", "none"];
        const getShaderSource = (shaderHelper) => {
          const x = inputVariable("x", inputs[0].dataType, inputShape.length, components);
          const scale = inputVariable("scale_shift", 1 /* float */, scaleShape.length, 2);
          const output = outputVariable("output", inputs[0].dataType, inputShape.length, components);
          const variables = [x, scale, output];
          return `
  ${shaderHelper.registerUniform("output_size", "u32").declareVariables(...variables)}
  ${shaderHelper.mainStart()}
  ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${output.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${scale.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${x.getByOffset("global_idx")} * ${output.type.value}(scale_shift.x) + ${output.type.value}(scale_shift.y);
      ${output.setByOffset("global_idx", "value")};
  }`;
        };
        context.compute(
          {
            name: "InstanceNormalization",
            shaderCache: { hint: `${components}`, inputDependencies },
            getRunData: () => ({
              outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
              dispatchGroup: { x: Math.ceil(
                outputSize / 64
                /* workgroup size */
              ) },
              programUniforms: [
                { type: 12 /* uint32 */, data: outputSize },
                ...createTensorShapeVariables(inputShape, scaleShape, inputShape)
              ]
            }),
            getShaderSource
          },
          { inputs: [inputs[0], channelScaleShift] }
        );
      };
      createInstanceNormNHWCProgramInfo = (context, inputs, attributes) => {
        const xShape = inputs[0].dims;
        const outputShape = xShape;
        const N = xShape[0];
        const C = xShape[xShape.length - 1];
        const H = ShapeUtil.sizeFromDimension(xShape, 1) / C;
        const components = getMaxComponents(C);
        const outputSize = ShapeUtil.size(outputShape) / components;
        const programUniforms = [
          { type: 12 /* uint32 */, data: H },
          { type: 12 /* uint32 */, data: Math.floor(C / components) }
        ];
        const inputDependencies = ["type", "type"];
        const transposedXPerm = [0, xShape.length - 1];
        for (let i = 0; i < xShape.length - 2; i++) {
          transposedXPerm.push(i + 1);
        }
        const transposedX = context.compute(createTransposeProgramInfo(context.inputs[0], transposedXPerm), {
          inputs: [context.inputs[0]],
          outputs: [-1]
        })[0];
        const channelScaleShift = computeChannelScaleShift(
          context,
          transposedX,
          inputs[1],
          inputs[2],
          N,
          H,
          C,
          attributes.epsilon
        );
        const getShaderSource = (shaderHelper) => {
          const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
          const scaleType = components === 1 ? "vec2f" : `mat${components}x2f`;
          const scaleData = (num) => {
            const index = num === 0 ? "x" : "y";
            const f32Type = components === 1 ? "f32" : `vec${components}f`;
            switch (components) {
              case 1:
                return `${dataType}(${f32Type}(scale.${index}))`;
              case 2:
                return `vec2<${dataType}>(${f32Type}(scale[0].${index}, scale[1].${index}))`;
              case 4:
                return `vec4<${dataType}>(${f32Type}(scale[0].${index}, scale[1].${index}, scale[2].${index}, scale[3].${index}))`;
              default:
                throw new Error(`Not supported compoents ${components}`);
            }
          };
          const inputHelper = inputVariable("input", inputs[0].dataType, inputs[0].dims, components);
          const outputHelper = outputVariable("output", inputs[0].dataType, outputShape, components);
          return `
  @group(0) @binding(0) var<storage, read> input : array<${inputHelper.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${scaleType}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${outputHelper.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${shaderHelper.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${scaleData(0)}, ${scaleData(1)});
  }`;
        };
        context.compute(
          {
            name: "InstanceNormalizationNHWC",
            shaderCache: { hint: `${components}`, inputDependencies },
            getRunData: () => ({
              outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
              dispatchGroup: { x: Math.ceil(
                outputSize / 64
                /* workgroup size */
              ) },
              programUniforms
            }),
            getShaderSource
          },
          { inputs: [inputs[0], channelScaleShift] }
        );
      };
      instanceNorm = (context, attributes) => {
        if (attributes.format === "NHWC") {
          createInstanceNormNHWCProgramInfo(context, context.inputs, attributes);
        } else {
          createInstanceNormProgramInfo(context, context.inputs, attributes);
        }
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/layer-norm.ts
  var validateInputs20, createLayerNormProgramInfo, layerNorm;
  var init_layer_norm = __esm({
    "web/lib/wasm/jsep/webgpu/ops/layer-norm.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      validateInputs20 = (inputs) => {
        if (!inputs || inputs.length < 2) {
          throw new Error("layerNorm requires at least 2 inputs.");
        }
      };
      createLayerNormProgramInfo = (inputs, attributes, outputCount) => {
        const simplified = attributes.simplified;
        const xShape = inputs[0].dims;
        const scale = inputs[1];
        const bias = !simplified && inputs[2];
        const outputShape = xShape;
        const axis = ShapeUtil.normalizeAxis(attributes.axis, xShape.length);
        const normCount = ShapeUtil.sizeToDimension(xShape, axis);
        const normSize = ShapeUtil.sizeFromDimension(xShape, axis);
        const scaleSize = ShapeUtil.size(scale.dims);
        const biasSize = bias ? ShapeUtil.size(bias.dims) : 0;
        if (scaleSize !== normSize || bias && biasSize !== normSize) {
          throw new Error(`Size of X.shape()[axis:] == ${normSize}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${scaleSize} and bias size of ${biasSize}`);
        }
        const meanInvStdDevDim = [];
        for (let i = 0; i < xShape.length; ++i) {
          if (i < axis) {
            meanInvStdDevDim.push(xShape[i]);
          } else {
            meanInvStdDevDim.push(1);
          }
        }
        const components = getMaxComponents(normSize);
        const inputDependencies = ["type", "type"];
        const programUniforms = [
          { type: 12 /* uint32 */, data: normCount },
          { type: 1 /* float */, data: normSize },
          { type: 12 /* uint32 */, data: Math.floor(normSize / components) },
          { type: 1 /* float */, data: attributes.epsilon }
        ];
        if (bias) {
          inputDependencies.push("type");
        }
        const hasMeanDataOutput = outputCount > 1;
        const hasInvStdOutput = outputCount > 2;
        const getShaderSource = (shaderHelper) => {
          const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
          const variables = [
            inputVariable("x", inputs[0].dataType, inputs[0].dims, components),
            inputVariable("scale", scale.dataType, scale.dims, components)
          ];
          if (bias) {
            variables.push(inputVariable("bias", bias.dataType, bias.dims, components));
          }
          variables.push(outputVariable("output", inputs[0].dataType, outputShape, components));
          if (hasMeanDataOutput) {
            variables.push(outputVariable("mean_data_output", 1 /* float */, meanInvStdDevDim));
          }
          if (hasInvStdOutput) {
            variables.push(outputVariable("inv_std_output", 1 /* float */, meanInvStdDevDim));
          }
          const uniforms = [
            { name: "norm_count", type: "u32" },
            { name: "norm_size", type: "f32" },
            { name: "norm_size_vectorized", type: "u32" },
            { name: "epsilon", type: "f32" }
          ];
          return `
  ${shaderHelper.registerUniforms(uniforms).declareVariables(...variables)}
  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${fillVector("f32", components)};
    var mean_square_vector = ${fillVector("f32", components)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${castToF32(dataType, components, "x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${sumVector("mean_vector", components)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${sumVector("mean_square_vector", components)} / uniforms.norm_size ${simplified ? "" : "- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${castToF32(dataType, components, "x[j + offset]")};
      let f32scale = ${castToF32(dataType, components, "scale[j]")};
      output[j + offset] = ${variables[0].type.value}((f32input ${simplified ? "" : "- mean"}) * inv_std_dev * f32scale
        ${bias ? `+ ${castToF32(dataType, components, "bias[j]")}` : ""}
      );
    }

    ${hasMeanDataOutput ? "mean_data_output[global_idx] = mean" : ""};
    ${hasInvStdOutput ? "inv_std_output[global_idx] = inv_std_dev" : ""};
  }`;
        };
        const outputs = [{ dims: outputShape, dataType: inputs[0].dataType }];
        if (hasMeanDataOutput) {
          outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
        }
        if (hasInvStdOutput) {
          outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
        }
        return {
          name: "LayerNormalization",
          shaderCache: { hint: `${components};${outputCount};${simplified}`, inputDependencies },
          getRunData: () => ({
            outputs,
            dispatchGroup: { x: Math.ceil(
              normCount / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      layerNorm = (context, attributes) => {
        validateInputs20(context.inputs);
        context.compute(createLayerNormProgramInfo(context.inputs, attributes, context.outputCount));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/matmulnbits.ts
  var validateInputs21, createMatMulNBitsProgramInfo, matMulNBits, parseMatMulNBitsAttributes;
  var init_matmulnbits = __esm({
    "web/lib/wasm/jsep/webgpu/ops/matmulnbits.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs21 = (inputs, attributes) => {
        if (inputs.length < 3 || inputs.length > 4) {
          throw new Error("MatMulNBits requires 3 or 4 inputs");
        }
        const a = inputs[0];
        const aRank = a.dims.length;
        if (a.dims[aRank - 1] !== attributes.k) {
          throw new Error("The last dim of input shape does not match the k value");
        }
        const nBlocksPerCol = Math.floor((attributes.k + attributes.blockSize - 1) / attributes.blockSize);
        const blobSize = attributes.blockSize / 8 * attributes.bits;
        const b = inputs[1];
        if (!ShapeUtil.areEqual(b.dims, [attributes.n, nBlocksPerCol, blobSize])) {
          throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");
        }
        const scales = inputs[2];
        const scalesShape = scales.dims;
        if (ShapeUtil.size(scalesShape) !== attributes.n * nBlocksPerCol) {
          throw new Error("scales input size error.");
        }
        if (inputs.length === 4) {
          const zeroPoints = inputs[3];
          const zeroPointsShape = zeroPoints.dims;
          const expectedZeroPointsSize = attributes.bits > 4 ? attributes.n * nBlocksPerCol : attributes.n * Math.floor((nBlocksPerCol + 1) / 2);
          if (ShapeUtil.size(zeroPointsShape) !== expectedZeroPointsSize) {
            throw new Error("zeroPoints input size error.");
          }
        }
      };
      createMatMulNBitsProgramInfo = (inputs, attributes) => {
        const inputShape = inputs[0].dims;
        const aRank = inputShape.length;
        const dimAOuter = inputShape[aRank - 2];
        const dimInner = attributes.k;
        const dimBOuter = attributes.n;
        const batchDims = inputShape.slice(0, aRank - 2);
        const batchSize = ShapeUtil.size(batchDims);
        const blobSize = inputs[1].dims[2];
        const blobSizeInWords = blobSize / 4;
        const dataType = inputs[0].dataType;
        const aComponents = getMaxComponents(attributes.k);
        const bComponents = getMaxComponents(blobSizeInWords);
        const components = getMaxComponents(dimBOuter);
        const outputShape = batchDims.concat([dimAOuter, dimBOuter]);
        const outputNumber = dimAOuter > 1 && dimBOuter / components % 2 === 0 ? 2 : 1;
        const dispatchSize = ShapeUtil.size(outputShape) / components / outputNumber;
        const workgroupSize = 64;
        const programUniforms = [];
        const inputShapeTemp = [batchSize, dimAOuter, dimInner / aComponents];
        const bShape = ShapeUtil.convertShape(inputs[1].dims).slice();
        bShape.splice(-1, 1, blobSizeInWords / bComponents);
        programUniforms.push(...createTensorShapeVariables(inputShapeTemp));
        programUniforms.push(...createTensorShapeVariables(bShape));
        programUniforms.push(...createTensorShapeVariables(inputs[2].dims));
        if (inputs.length === 4) {
          programUniforms.push(...createTensorShapeVariables(ShapeUtil.convertShape(inputs[3].dims)));
        }
        const outputShapeTemp = [batchSize, dimAOuter, dimBOuter / components];
        programUniforms.push(...createTensorShapeVariables(outputShapeTemp));
        const getShaderSource = (shaderHelper) => {
          const inputRank = inputShapeTemp.length;
          const a = inputVariable("a", inputs[0].dataType, inputRank, aComponents);
          const b = inputVariable("b", 12 /* uint32 */, bShape.length, bComponents);
          const scales = inputVariable("scales", inputs[2].dataType, inputs[2].dims.length);
          const inputVariables = [a, b, scales];
          const zeroPoints = inputs.length === 4 ? inputVariable("zero_points", 12 /* uint32 */, inputs[3].dims.length) : void 0;
          if (zeroPoints) {
            inputVariables.push(zeroPoints);
          }
          const outputRank = outputShapeTemp.length;
          const output = outputVariable("output", inputs[0].dataType, outputRank, components);
          const dataType2 = tensorTypeToWsglStorageType(inputs[0].dataType);
          const qDqDataType = (() => {
            switch (aComponents) {
              case 1:
                return `array<${dataType2}, 8>`;
              case 2:
                return `mat4x2<${dataType2}>`;
              case 4:
                return `mat2x4<${dataType2}>`;
              default:
                throw new Error(`${aComponents}-component is not supported.`);
            }
          })();
          const processOneWord = () => {
            let calcStr = `
          // reuse a data
            var input_offset = ${a.indicesToOffset(`${a.type.indices}(batch, row, word_offset)`)};
            var a_data: ${qDqDataType};
            for (var j: u32 = 0; j < ${8 / aComponents}; j++) {
              a_data[j] = ${a.getByOffset("input_offset")};
              input_offset++;
            }
          `;
            for (let c = 0; c < components * outputNumber; c++) {
              calcStr += `
            b_value = ${bComponents === 1 ? `b${c}_data` : `b${c}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${qDqDataType}(${Array.from(
                { length: 4 },
                (_, i) => `${dataType2}(b_value_lower[${i}]), ${dataType2}(b_value_upper[${i}])`
              ).join(", ")});
            b_dequantized_values = ${(() => {
                if (aComponents === 1) {
                  return `${qDqDataType}(${Array.from(
                    { length: 8 },
                    (_, i) => `(b_quantized_values[${i}] - ${zeroPoints ? `zero_point${c}` : "zero_point"}) * scale${c}`
                  ).join(", ")});`;
                } else {
                  return `(b_quantized_values - ${qDqDataType}(${Array(8).fill(`${zeroPoints ? `zero_point${c}` : "zero_point"}`).join(",")})) * scale${c};`;
                }
              })()};
            workgroup_shared[local_id.x * ${outputNumber} + ${Math.floor(c / components)}]${components > 1 ? `[${c % components}]` : ""} += ${Array.from(
                { length: 8 / aComponents },
                (_, i) => `${aComponents === 1 ? `a_data[${i}] * b_dequantized_values[${i}]` : `dot(a_data[${i}], b_dequantized_values[${i}])`}`
              ).join(" + ")};
          `;
            }
            return calcStr;
          };
          const prepareScaleAndZeroPoint = () => {
            let calcStr = `
            var col_index = col * ${components};
            ${zeroPoints ? `
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;` : `
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${dataType2}(${8});`}
            `;
            for (let c = 0; c < components * outputNumber; c++) {
              calcStr += `
            let scale${c} = ${scales.getByOffset(`col_index * nBlocksPerCol + block`)};
            ${zeroPoints ? `
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${zeroPoints.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${c} = ${dataType2}((zero_point_word) & 0xFu);` : ""}
            col_index += 1;`;
            }
            return calcStr;
          };
          const prepareBData = () => {
            let calcStr = `col_index = col * ${components};`;
            for (let c = 0; c < components * outputNumber; c++) {
              calcStr += `
            let b${c}_data = ${b.getByIndices(`${b.type.indices}(col_index, block, word)`)};
            col_index += 1;`;
            }
            calcStr += `
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${qDqDataType};
            var b_dequantized_values: ${qDqDataType};`;
            return calcStr;
          };
          return `
        var<workgroup> workgroup_shared: array<${output.type.value}, ${outputNumber * workgroupSize}>;
        ${shaderHelper.declareVariables(...inputVariables, output)}
        ${shaderHelper.mainStart([workgroupSize, 1, 1])}
          let output_indices = ${output.offsetToIndices(`(global_idx / ${workgroupSize}) * ${outputNumber}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${workgroupSize}) {
            //process one block
            var word_offset: u32 = block * ${attributes.blockSize / aComponents};
            ${prepareScaleAndZeroPoint()}
            for (var word: u32 = 0; word < ${blobSizeInWords}; word += ${bComponents}) {
              ${prepareBData()}
              for (var i: u32 = 0; i < ${bComponents}; i++) {
                ${processOneWord()}
                word_offset += ${8 / aComponents};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${outputNumber}) {
            var output_value: ${output.type.value} = ${output.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${workgroupSize}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${outputNumber};
            }
            ${output.setByIndices(`${output.type.indices}(batch, row, col + local_id.x)`, "output_value")};
          }
        }`;
        };
        return {
          name: "MatMulNBits",
          shaderCache: {
            hint: `${attributes.blockSize};${attributes.bits};${aComponents};${bComponents};${components};${outputNumber};${workgroupSize}`,
            inputDependencies: Array(inputs.length).fill("rank")
          },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType }],
            dispatchGroup: { x: dispatchSize },
            programUniforms
          }),
          getShaderSource
        };
      };
      matMulNBits = (context, attributes) => {
        validateInputs21(context.inputs, attributes);
        context.compute(createMatMulNBitsProgramInfo(context.inputs, attributes));
      };
      parseMatMulNBitsAttributes = (attributes) => createAttributeWithCacheKey(attributes);
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/pad.ts
  var validateInputs22, getPadConstant, getPadReflect, getPadEdge, getPadWrap, getPadSnippet, createPadProgramInfo, createPadAttributesFromInputs, pad;
  var init_pad = __esm({
    "web/lib/wasm/jsep/webgpu/ops/pad.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      validateInputs22 = (inputs) => {
        if (!inputs || inputs.length < 1) {
          throw new Error("Too few inputs");
        }
        if (inputs[0].dataType !== 1 /* float */ && inputs[0].dataType !== 10 /* float16 */) {
          throw new Error("Input type must be float or float16.");
        }
        if (inputs.length >= 2) {
          let validPads = inputs[0].dims.length * 2 === inputs[1].dims[0];
          if (inputs.length === 4) {
            validPads = inputs[3].dims[0] * 2 === inputs[1].dims[0];
          }
          if (!validPads) {
            throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].");
          }
        }
      };
      getPadConstant = (output, inputRank, padsLength) => {
        let block = "";
        for (let i = inputRank - 1; i >= 0; --i) {
          block += `
            k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
              break;
            }
            offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
        `;
        }
        return `
          value = ${output.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${block}
            value = x[offset];
          }
      `;
      };
      getPadReflect = (output, inputRank, padsLength) => {
        let block = "";
        for (let i = inputRank - 1; i >= 0; --i) {
          block += `
                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${getElementAt("uniforms.x_shape", i, inputRank)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
            `;
        }
        return `
              var offset = 0;
              var k = 0;
              ${block}
              value = x[offset];
          `;
      };
      getPadEdge = (output, inputRank, padsLength) => {
        let block = "";
        for (let i = inputRank - 1; i >= 0; --i) {
          block += `
                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
                  k = i32(${getElementAt("uniforms.x_shape", i, inputRank)}) - 1;
                }
                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
            `;
        }
        return `
              var offset = 0;
              var k = 0;
              ${block}
              value = x[offset];
          `;
      };
      getPadWrap = (output, inputRank, padsLength) => {
        let block = "";
        for (let i = inputRank - 1; i >= 0; --i) {
          block += `
                k = i32(${output.indicesGet("indices", i)}) - ${getElementAt("uniforms.pads", i, padsLength)};
                if (k < 0)  {
                  k += i32(${getElementAt("uniforms.x_shape", i, inputRank)}]);
                }
                if (k >= i32(${getElementAt("uniforms.x_shape", i, inputRank)})) {
                  k -= i32(${getElementAt("uniforms.x_shape", i, inputRank)});
                }
                offset += k * i32(${getElementAt("uniforms.x_strides", i, inputRank)});
            `;
        }
        return `
              var offset = 0;
              var k = 0;
              ${block}
              value = x[offset];
          `;
      };
      getPadSnippet = (output, inputRank, attributes) => {
        switch (attributes.mode) {
          case 0:
            return getPadConstant(output, inputRank, attributes.pads.length);
          case 1:
            return getPadReflect(output, inputRank, attributes.pads.length);
          case 2:
            return getPadEdge(output, inputRank, attributes.pads.length);
          case 3:
            return getPadWrap(output, inputRank, attributes.pads.length);
          default:
            throw new Error("Invalid mode");
        }
      };
      createPadProgramInfo = (inputs, attributes) => {
        const outputShape = ShapeUtil.padShape(inputs[0].dims.slice(), attributes.pads);
        const inputDims = inputs[0].dims;
        const outputSize = ShapeUtil.size(outputShape);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 6 /* int32 */, data: attributes.pads }
        ];
        const isValueFromInput = inputs.length >= 3 && inputs[2].data;
        if (attributes.mode === 0) {
          programUniforms.push({ type: isValueFromInput ? inputs[2].dataType : 1 /* float */, data: attributes.value });
        }
        programUniforms.push(...createTensorShapeVariables(inputs[0].dims, outputShape));
        const inputDependencies = ["rank"];
        const getShaderSource = (shaderHelper) => {
          const output = outputVariable("output", inputs[0].dataType, outputShape.length);
          const input = inputVariable("x", inputs[0].dataType, inputDims.length);
          const dataType = input.type.value;
          const padSnippet = getPadSnippet(output, inputDims.length, attributes);
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "pads", type: "i32", length: attributes.pads.length }
          ];
          if (attributes.mode === 0) {
            uniforms.push({ name: "constant_value", type: isValueFromInput ? dataType : "f32" });
          }
          return `
            ${shaderHelper.registerUniforms(uniforms).declareVariables(input, output)}
            ${shaderHelper.mainStart()}
            ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${output.offsetToIndices("global_idx")};

            var value = ${dataType}(0);
            ${padSnippet}
            output[global_idx] = value;
        }`;
        };
        return {
          name: "Pad",
          shaderCache: { hint: `${attributes.mode}${isValueFromInput}`, inputDependencies },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(
              ShapeUtil.size(outputShape) / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource
        };
      };
      createPadAttributesFromInputs = (inputs, attributes) => {
        if (inputs.length > 1) {
          const bigInt64Pads = inputs[1].getBigInt64Array();
          const value = inputs.length >= 3 && inputs[2].data ? inputs[2].dataType === 10 /* float16 */ ? inputs[2].getUint16Array()[0] : inputs[2].getFloat32Array()[0] : 0;
          const inputRank = inputs[0].dims.length;
          const updatePads = new Int32Array(2 * inputRank).fill(0);
          if (inputs.length >= 4) {
            const axes = inputs[3].getBigInt64Array();
            for (let i = 0; i < axes.length; i++) {
              updatePads[Number(axes[i])] = Number(bigInt64Pads[i]);
              updatePads[Number(axes[i]) + inputRank] = Number(bigInt64Pads[i + axes.length]);
            }
          } else {
            bigInt64Pads.forEach((v, i) => updatePads[Number(i)] = Number(v));
          }
          const pads = [];
          updatePads.forEach((v) => pads.push(v));
          return { mode: attributes.mode, value, pads };
        } else {
          return attributes;
        }
      };
      pad = (context, attributes) => {
        validateInputs22(context.inputs);
        const updatedAttributes = createPadAttributesFromInputs(context.inputs, attributes);
        context.compute(createPadProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/pool.ts
  var validateInputs23, getAdjustedPoolAttributesAndOutputShape, getUniformAndPadInfo, generatePoolingCode, createShaderKeyFromAttributes, createAveragePoolShaderKeyFromAttributes, createMaxPoolShaderKeyFromAttributes, parsePoolCommonAttributes, createAveragePoolProgramInfo, parseAveragePoolAttributes, averagePool, globalPoolAttributes, parseGlobalAveragePoolAttributes, globalAveragePool, createMaxPoolProgramInfo, maxPool, parseMaxPoolAttributes, parseGlobalMaxPoolAttributes, globalMaxPool;
  var init_pool = __esm({
    "web/lib/wasm/jsep/webgpu/ops/pool.ts"() {
      "use strict";
      init_esm();
      init_wasm_common();
      init_util();
      init_common();
      validateInputs23 = (inputs) => {
        if (env2.webgpu.validateInputContent && (!inputs || inputs.length !== 1)) {
          throw new Error("Pool ops requires 1 input.");
        }
      };
      getAdjustedPoolAttributesAndOutputShape = (input, attributes, isGlobalOperator) => {
        const isChannelsLast = attributes.format === "NHWC";
        const inputShapeAsChannelFirst = input.dims.slice();
        if (isChannelsLast) {
          inputShapeAsChannelFirst.splice(1, 0, inputShapeAsChannelFirst.pop());
        }
        const hasDilations = Object.hasOwnProperty.call(attributes, "dilations");
        const kernelShape = attributes.kernelShape.slice();
        const strides = attributes.strides.slice();
        const dilations = hasDilations ? attributes.dilations.slice() : [];
        const pads = attributes.pads.slice();
        PoolConvUtil.adjustPoolAttributes(isGlobalOperator, inputShapeAsChannelFirst, kernelShape, strides, dilations, pads);
        const outputShapeAsChannelFirst = PoolConvUtil.computePoolOutputShape(
          isGlobalOperator,
          inputShapeAsChannelFirst,
          strides,
          dilations,
          kernelShape,
          pads,
          attributes.autoPad
        );
        const newAttributes = Object.assign({}, attributes);
        if (hasDilations) {
          Object.assign(newAttributes, { kernelShape, strides, pads, dilations, cacheKey: attributes.cacheKey });
        } else {
          Object.assign(newAttributes, { kernelShape, strides, pads, cacheKey: attributes.cacheKey });
        }
        const outputShapeAsChannelLast = outputShapeAsChannelFirst.slice();
        outputShapeAsChannelLast.push(outputShapeAsChannelLast.splice(1, 1)[0]);
        return [newAttributes, isChannelsLast ? outputShapeAsChannelLast : outputShapeAsChannelFirst];
      };
      getUniformAndPadInfo = (outputShape, attributes) => {
        const isChannelsLast = attributes.format === "NHWC";
        const outputSize = ShapeUtil.size(outputShape);
        const kernelSize = ShapeUtil.size(attributes.kernelShape);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: kernelSize }
        ];
        const uniforms = [
          { name: "outputSize", type: "u32" },
          { name: "kernelSize", type: "u32" }
        ];
        if (attributes.kernelShape.length <= 2) {
          const kw = attributes.kernelShape[attributes.kernelShape.length - 1];
          const sw = attributes.strides[attributes.strides.length - 1];
          const pwStart = attributes.pads[attributes.pads.length / 2 - 1];
          const pwEnd = attributes.pads[attributes.pads.length - 1];
          const pwStartEndNotZero = !!(pwStart + pwEnd);
          programUniforms.push(
            { type: 12 /* uint32 */, data: kw },
            { type: 12 /* uint32 */, data: sw },
            { type: 12 /* uint32 */, data: pwStart },
            { type: 12 /* uint32 */, data: pwEnd }
          );
          uniforms.push(
            { name: "kw", type: "u32" },
            { name: "sw", type: "u32" },
            { name: "pwStart", type: "u32" },
            { name: "pwEnd", type: "u32" }
          );
          let phStartEndNotZero = false;
          if (attributes.kernelShape.length === 2) {
            const kh = attributes.kernelShape[attributes.kernelShape.length - 2];
            const sh = attributes.strides[attributes.strides.length - 2];
            const phStart = attributes.pads[attributes.pads.length / 2 - 2];
            const phEnd = attributes.pads[attributes.pads.length - 2];
            phStartEndNotZero = !!(phStart + phEnd);
            programUniforms.push(
              { type: 12 /* uint32 */, data: kh },
              { type: 12 /* uint32 */, data: sh },
              { type: 12 /* uint32 */, data: phStart },
              { type: 12 /* uint32 */, data: phEnd }
            );
            uniforms.push(
              { name: "kh", type: "u32" },
              { name: "sh", type: "u32" },
              { name: "phStart", type: "u32" },
              { name: "phEnd", type: "u32" }
            );
          }
          return [programUniforms, uniforms, true, pwStartEndNotZero, phStartEndNotZero];
        } else {
          if (isChannelsLast) {
            throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");
          }
          const kernelStrides = ShapeUtil.computeStrides(attributes.kernelShape);
          programUniforms.push(
            { type: 12 /* uint32 */, data: kernelStrides },
            { type: 12 /* uint32 */, data: attributes.pads },
            { type: 12 /* uint32 */, data: attributes.strides }
          );
          uniforms.push(
            { name: "kernelStrides", type: "u32", length: kernelStrides.length },
            { name: "pads", type: "u32", length: attributes.pads.length },
            { name: "strides", type: "u32", length: attributes.strides.length }
          );
          const hasPads = attributes.pads.reduce((sum, cur) => sum + cur);
          return [programUniforms, uniforms, !!hasPads, false, false];
        }
      };
      generatePoolingCode = (shaderHelper, x, rank, outputShapeRank, attributes, op1, op2, start, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero) => {
        const isChannelsLast = attributes.format === "NHWC";
        const dataType = x.type.value;
        const output = outputVariable("output", x.type.tensor, outputShapeRank);
        if (attributes.kernelShape.length <= 2) {
          let codeW = "";
          let codeH = "";
          let codeHEnd = "";
          const dimIdxW = rank - (isChannelsLast ? 2 : 1);
          if (pwStartEndNotZero) {
            codeW = `
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${dimIdxW}] = indices[${dimIdxW}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${dimIdxW}] < 0 || xIndices[${dimIdxW}]
                      >= uniforms.x_shape[${dimIdxW}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${x.indicesToOffset("xIndices")}];
                  ${op1}
                }`;
          } else {
            codeW = `
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${dimIdxW}] = indices[${dimIdxW}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${x.indicesToOffset("xIndices")}];
                  ${op1}
                }`;
          }
          if (attributes.kernelShape.length === 2) {
            const dimIdxH = rank - (isChannelsLast ? 3 : 2);
            if (phStartEndNotZero) {
              codeH = `
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${dimIdxH}] = indices[${dimIdxH}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${dimIdxH}] < 0 || xIndices[${dimIdxH}] >= uniforms.x_shape[${dimIdxH}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `;
            } else {
              codeH = `
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${dimIdxH}] = indices[${dimIdxH}] * uniforms.sh - uniforms.phStart + j;
                `;
            }
            codeHEnd = `
              }
            `;
          }
          const poolingCode = `
            ${shaderHelper.registerUniforms(uniforms).declareVariables(x, output)}

            ${shaderHelper.mainStart()}
              ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${output.offsetToIndices("global_idx")};
              var xIndices = ${output.offsetToIndices("global_idx")};

              var value = ${dataType}(${start});
              var pad = 0;
              ${codeH}
              ${codeW}
              ${codeHEnd}
              ${op2}

              output[global_idx] = value;
            }`;
          return poolingCode;
        } else {
          if (isChannelsLast) {
            throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");
          }
          const stridesRank = attributes.kernelShape.length;
          const padsRank = attributes.pads.length;
          let padCode = "";
          if (hasPads) {
            padCode = `
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${x.indicesToOffset("xIndices")}];
                ${op1}
              }`;
          } else {
            padCode = `
              }
              let x_val = x[${x.indicesToOffset("xIndices")}];
              ${op1}
            `;
          }
          const poolingCode = `
            ${shaderHelper.registerUniforms(uniforms).declareVariables(x, output)}

            ${shaderHelper.mainStart()}
              ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${output.offsetToIndices("global_idx")};
              var xIndices = ${output.offsetToIndices("global_idx")};

              var offsets: array<u32, ${stridesRank}>;

              var value = ${dataType}(${start});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${stridesRank - 1}u; j++) {
                  offsets[j] = offset / ${getElementAt("uniforms.kernelStrides", "j", stridesRank)};
                  offset -= offsets[j] * ${getElementAt("uniforms.kernelStrides", "j", stridesRank)};
                }
                offsets[${stridesRank - 1}] = offset;

                isPad = false;
                for (var j = ${rank - stridesRank}u; j < ${rank}u; j++) {
                  xIndices[j] = indices[j] * ${getElementAt(
            "uniforms.strides",
            `j - ${rank - stridesRank}u`,
            stridesRank
          )}
                    + offsets[j - ${rank - stridesRank}u] - ${getElementAt("uniforms.pads", "j - 2u", padsRank)};
                  ${padCode}
              }
              ${op2}

              output[global_idx] = value;
            }`;
          return poolingCode;
        }
      };
      createShaderKeyFromAttributes = (attributes) => `${attributes.format};${attributes.ceilMode};${attributes.autoPad};${attributes.kernelShape.length}`;
      createAveragePoolShaderKeyFromAttributes = (attributes) => `${createShaderKeyFromAttributes(attributes)};${attributes.countIncludePad}`;
      createMaxPoolShaderKeyFromAttributes = (attributes) => `${createShaderKeyFromAttributes(attributes)};${attributes.storageOrder};${attributes.dilations}`;
      parsePoolCommonAttributes = (attributes) => ({
        format: attributes.format,
        autoPad: ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][attributes.auto_pad],
        ceilMode: attributes.ceil_mode,
        kernelShape: attributes.kernel_shape,
        strides: attributes.strides,
        pads: attributes.pads
      });
      createAveragePoolProgramInfo = (name, input, isGlobalOperator, attributes) => {
        const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(
          input,
          attributes,
          isGlobalOperator
        );
        const x = inputVariable("x", input.dataType, input.dims.length);
        const dataType = x.type.value;
        const op1 = "value += x_val;";
        let op2 = "";
        if (adjustedAttributes.countIncludePad) {
          op2 += `value /= ${dataType}(uniforms.kernelSize);`;
        } else {
          op2 += `value /= ${dataType}(i32(uniforms.kernelSize) - pad);`;
        }
        const [programUniforms, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero] = getUniformAndPadInfo(
          outputShape,
          adjustedAttributes
        );
        programUniforms.push(...createTensorShapeVariables(input.dims, outputShape));
        const inputDependencies = ["rank"];
        return {
          name,
          shaderCache: {
            hint: `${attributes.cacheKey};${hasPads};${pwStartEndNotZero};${phStartEndNotZero}`,
            inputDependencies
          },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: input.dataType }],
            dispatchGroup: { x: Math.ceil(
              ShapeUtil.size(outputShape) / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource: (shaderHelper) => generatePoolingCode(
            shaderHelper,
            x,
            input.dims.length,
            outputShape.length,
            adjustedAttributes,
            op1,
            op2,
            0,
            uniforms,
            hasPads,
            pwStartEndNotZero,
            phStartEndNotZero
          )
        };
      };
      parseAveragePoolAttributes = (attributes) => {
        const countIncludePad = attributes.count_include_pad === 0 ? false : true;
        const attr = parsePoolCommonAttributes(attributes);
        if (attr.ceilMode !== 0) {
          throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
        }
        const averagePoolAttributes = { countIncludePad, ...attr, cacheKey: "" };
        return { ...averagePoolAttributes, cacheKey: createAveragePoolShaderKeyFromAttributes(averagePoolAttributes) };
      };
      averagePool = (context, attributes) => {
        validateInputs23(context.inputs);
        context.compute(createAveragePoolProgramInfo("AveragePool", context.inputs[0], false, attributes));
      };
      globalPoolAttributes = {
        autoPad: "",
        ceilMode: 0,
        countIncludePad: false,
        kernelShape: [],
        strides: [],
        pads: [],
        storageOrder: 0,
        dilations: []
      };
      parseGlobalAveragePoolAttributes = (attributes) => {
        const format = attributes.format;
        return { format, ...globalPoolAttributes, cacheKey: format };
      };
      globalAveragePool = (context, attributes) => {
        validateInputs23(context.inputs);
        context.compute(createAveragePoolProgramInfo("GlobalAveragePool", context.inputs[0], true, attributes));
      };
      createMaxPoolProgramInfo = (name, input, isGlobalOperator, attributes) => {
        const [adjustedAttributes, outputShape] = getAdjustedPoolAttributesAndOutputShape(
          input,
          attributes,
          isGlobalOperator
        );
        const op1 = `
      value = max(x_val, value);
    `;
        const op2 = "";
        const x = inputVariable("x", input.dataType, input.dims.length);
        const inputDependencies = ["rank"];
        const [programUniforms, uniforms, hasPads, pwStartEndNotZero, phStartEndNotZero] = getUniformAndPadInfo(
          outputShape,
          adjustedAttributes
        );
        programUniforms.push(...createTensorShapeVariables(input.dims, outputShape));
        return {
          name,
          shaderCache: {
            hint: `${attributes.cacheKey};${hasPads};${pwStartEndNotZero};${phStartEndNotZero}`,
            inputDependencies
          },
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: input.dataType }],
            dispatchGroup: { x: Math.ceil(
              ShapeUtil.size(outputShape) / 64
              /* workgroup size */
            ) },
            programUniforms
          }),
          getShaderSource: (shaderHelper) => generatePoolingCode(
            shaderHelper,
            x,
            input.dims.length,
            outputShape.length,
            adjustedAttributes,
            op1,
            op2,
            input.dataType === 10 /* float16 */ ? -65504 : -1e5,
            uniforms,
            hasPads,
            pwStartEndNotZero,
            phStartEndNotZero
          )
        };
      };
      maxPool = (context, attributes) => {
        validateInputs23(context.inputs);
        context.compute(createMaxPoolProgramInfo("MaxPool", context.inputs[0], false, attributes));
      };
      parseMaxPoolAttributes = (attributes) => {
        const storageOrder = attributes.storage_order;
        const dilations = attributes.dilations;
        const attr = parsePoolCommonAttributes(attributes);
        if (storageOrder !== 0) {
          throw new Error("column major storage order is not yet supported for MaxPool");
        }
        if (attr.ceilMode !== 0) {
          throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
        }
        const maxPoolAttributes = { storageOrder, dilations, ...attr, cacheKey: "" };
        return { ...maxPoolAttributes, cacheKey: createMaxPoolShaderKeyFromAttributes(maxPoolAttributes) };
      };
      parseGlobalMaxPoolAttributes = (attributes) => {
        const format = attributes.format;
        return { format, ...globalPoolAttributes, cacheKey: format };
      };
      globalMaxPool = (context, attributes) => {
        validateInputs23(context.inputs);
        context.compute(createMaxPoolProgramInfo("GlobalMaxPool", context.inputs[0], true, attributes));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/quantize-linear.ts
  var validateInputs24, createDequantizeLinearProgramInfo, dequantizeLinear, parseDequantizeLinearAttributes;
  var init_quantize_linear = __esm({
    "web/lib/wasm/jsep/webgpu/ops/quantize-linear.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs24 = (inputs, attributes) => {
        if (inputs.length < 2 || inputs.length > 3) {
          throw new Error("DequantizeLinear requires 2 or 3 inputs.");
        }
        if (inputs.length === 3 && inputs[1].dims === inputs[2].dims) {
          throw new Error("x-scale and x-zero-point must have the same shape.");
        }
        if (inputs.length === 3 && inputs[0].dataType !== inputs[2].dataType) {
          throw new Error("x and x-zero-point must have the same data type.");
        }
        if (inputs[0].dataType === 6 /* int32 */ && inputs.length > 2) {
          throw new Error("In the case of dequantizing int32 there is no zero point.");
        }
        if (inputs[1].dims.length !== 0 && inputs[1].dims.length !== 1 && inputs[1].dims.length !== inputs[0].dims.length) {
          throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");
        }
        if (inputs.length > 2) {
          if (inputs[0].dataType !== inputs[2].dataType) {
            throw new Error("x and x-zero-point must have the same data type.");
          }
          if (inputs[1].dims.length !== inputs[2].dims.length) {
            throw new Error("scale and zero-point inputs must have the same rank.");
          }
          if (!inputs[1].dims.map((d, i) => d === inputs[2].dims[i]).reduce((a, b) => a && b, true)) {
            throw new Error("scale and zero-point inputs must have the same shape.");
          }
        }
        if (attributes.blockSize > 0) {
          if (inputs[1].dims.length === 0 || inputs[1].dims.length === 1 && inputs[1].dims[0] === 1) {
            throw new Error("blockSize must be set only for block quantization.");
          }
          if (!inputs[1].dims.map((d, i) => i === attributes.axis || d === inputs[0].dims[i]).reduce((a, b) => a && b, true)) {
            throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");
          }
          if (inputs[1].dims.length !== inputs[0].dims.length) {
            throw new Error("For block qunatization the scale input rank must be the same as the x rank.");
          }
          const dI = inputs[0].dims[attributes.axis];
          const si = inputs[1].dims[attributes.axis];
          if (attributes.blockSize < Math.ceil(dI / si) || attributes.blockSize > Math.ceil(dI / (si - 1) - 1)) {
            throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].");
          }
        }
      };
      createDequantizeLinearProgramInfo = (inputs, attributes) => {
        const axis = ShapeUtil.normalizeAxis(attributes.axis, inputs[0].dims.length);
        const inputType = inputs[0].dataType;
        const isSigned = inputType === 3 /* int8 */;
        const outputShape = inputs[0].dims;
        const dataType = inputs[1].dataType;
        const outputSize = ShapeUtil.size(outputShape);
        const isPacked = inputType === 3 /* int8 */ || inputType === 2 /* uint8 */;
        const inputShape = isPacked ? [Math.ceil(ShapeUtil.size(inputs[0].dims) / 4)] : inputs[0].dims;
        const scaleShape = inputs[1].dims;
        const zeroPointInput = inputs.length > 2 ? inputs[2] : void 0;
        const zeroPointShape = zeroPointInput ? isPacked ? [Math.ceil(ShapeUtil.size(zeroPointInput.dims) / 4)] : zeroPointInput.dims : void 0;
        const perLayerQuantization = scaleShape.length === 0 || scaleShape.length === 1 && scaleShape[0] === 1;
        const perAxisQuantization = perLayerQuantization === false && scaleShape.length === 1;
        const maxComponents = getMaxComponents(outputSize);
        const useComponents = perLayerQuantization && (!isPacked || maxComponents === 4);
        const components = useComponents ? maxComponents : 1;
        const inputComponent = useComponents && !isPacked ? maxComponents : 1;
        const input = inputVariable("input", isPacked ? 12 /* uint32 */ : inputType, inputShape.length, inputComponent);
        const scale = inputVariable("scale", dataType, scaleShape.length);
        const zeroPoint = zeroPointInput ? inputVariable("zero_point", isPacked ? 12 /* uint32 */ : inputType, zeroPointShape.length) : void 0;
        const output = outputVariable("output", dataType, outputShape.length, components);
        const inputVariables = [input, scale];
        if (zeroPoint) {
          inputVariables.push(zeroPoint);
        }
        const inputShapes = [inputShape, scaleShape];
        if (zeroPointInput) {
          inputShapes.push(zeroPointShape);
        }
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize / components },
          { type: 12 /* uint32 */, data: axis },
          { type: 12 /* uint32 */, data: attributes.blockSize },
          ...createTensorShapeVariables(...inputShapes, outputShape)
        ];
        const getShaderSource = (shaderHelper) => {
          const uniforms = [
            { name: "output_size", type: "u32" },
            { name: "axis", type: "u32" },
            { name: "block_size", type: "u32" }
          ];
          return `
      ${shaderHelper.registerUniforms(uniforms).declareVariables(...inputVariables, output)}
      ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${output.offsetToIndices("global_idx")};

          // Set input x
          ${(() => {
            if (isPacked) {
              return `
            let input = ${input.getByOffset("global_idx / 4")};
            let x_vec = ${isSigned ? "unpack4xI8(input)" : "unpack4xU8(input)"};
            let x_value = ${components === 1 ? "x_vec[global_idx % 4]" : "x_vec"};`;
            } else {
              return `let x_value = ${input.getByOffset("global_idx")};`;
            }
          })()};

          // Set scale input
          ${(() => {
            if (perLayerQuantization) {
              return `let scale_value= ${scale.getByOffset("0")}`;
            } else if (perAxisQuantization) {
              return `
            let scale_index = ${output.indicesGet("output_indices", "uniforms.axis")};
            let scale_value= ${scale.getByOffset("scale_index")};`;
            } else {
              return `
            var scale_indices: ${scale.type.indices} = output_indices;
            let index = ${scale.indicesGet("scale_indices", "uniforms.axis")} / uniforms.block_size;
            ${scale.indicesSet("scale_indices", "uniforms.axis", "index")};
            let scale_value= ${scale.getByIndices("scale_indices")};`;
            }
          })()};

          // Set zero-point input
          ${(() => {
            if (zeroPoint) {
              if (perLayerQuantization) {
                if (isPacked) {
                  return `
                let zero_point_input = ${zeroPoint.getByOffset("0")};
                let zero_point_vec =  ${isSigned ? "unpack4xI8(zero_point_input)" : "unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`;
                } else {
                  return `let zero_point_value = ${zeroPoint.getByOffset("0")}`;
                }
              } else if (perAxisQuantization) {
                if (isPacked) {
                  return `
                let zero_point_index = ${output.indicesGet("output_indices", "uniforms.axis")};
                let zero_point_input = ${zeroPoint.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${isSigned ? "unpack4xI8(zero_point_input)" : "unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`;
                } else {
                  return `
                let zero_point_index = ${output.indicesGet("output_indices", "uniforms.axis")};
                let zero_point_value = ${zeroPoint.getByOffset("zero_point_index")};`;
                }
              } else {
                if (isPacked) {
                  return `
                let zero_point_offset = ${scale.indicesToOffset("scale_indices")};
                let zero_point_input = ${zeroPoint.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${isSigned ? "unpack4xI8(zero_point_input)" : "unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`;
                } else {
                  return `let zero_point_value = ${zeroPoint.getByIndices("scale_indices")};`;
                }
              }
            } else {
              return `let zero_point_value = ${isPacked ? isSigned ? "i32" : "u32" : input.type.value}(0);`;
            }
          })()};
      // Compute and write output
      ${output.setByOffset("global_idx", `${output.type.value}(x_value - zero_point_value) * scale_value`)};
      }`;
        };
        return {
          name: "DequantizeLinear",
          shaderCache: {
            hint: attributes.cacheKey,
            inputDependencies: zeroPoint ? ["rank", "rank", "rank"] : ["rank", "rank"]
          },
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType }],
            dispatchGroup: { x: Math.ceil(outputSize / components / 64), y: 1, z: 1 },
            programUniforms
          })
        };
      };
      dequantizeLinear = (context, attributes) => {
        validateInputs24(context.inputs, attributes);
        context.compute(createDequantizeLinearProgramInfo(context.inputs, attributes));
      };
      parseDequantizeLinearAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis, blockSize: attributes.blockSize });
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/range.ts
  var validateInputsContent, createRangeProgramInfo, range;
  var init_range = __esm({
    "web/lib/wasm/jsep/webgpu/ops/range.ts"() {
      "use strict";
      init_esm();
      init_wasm_common();
      init_common();
      validateInputsContent = (start, limit, delta) => {
        const sameStartLimit = start === limit;
        const increasingRangeNegativeStep = start < limit && delta < 0;
        const decreasingRangePositiveStep = start > limit && delta > 0;
        if (sameStartLimit || increasingRangeNegativeStep || decreasingRangePositiveStep) {
          throw new Error("Range these inputs' contents are invalid.");
        }
      };
      createRangeProgramInfo = (start, limit, delta, dataType) => {
        const numElements = Math.abs(Math.ceil((limit - start) / delta));
        const outputShape = [numElements];
        const outputSize = numElements;
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: dataType, data: start },
          { type: dataType, data: delta },
          ...createTensorShapeVariables(outputShape)
        ];
        const getShaderSource = (shaderHelper) => {
          const output = outputVariable("output", dataType, outputShape.length);
          const wgslType = output.type.value;
          const uniforms = [
            { name: "outputSize", type: "u32" },
            { name: "start", type: wgslType },
            { name: "delta", type: wgslType }
          ];
          return `
        ${shaderHelper.registerUniforms(uniforms).declareVariables(output)}
        ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${wgslType}(global_idx) * uniforms.delta;
      }`;
        };
        return {
          name: "Range",
          shaderCache: { hint: `${dataType}` },
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          })
        };
      };
      range = (context) => {
        let start = 0;
        let limit = 0;
        let delta = 0;
        if (context.inputs[0].dataType === 6 /* int32 */) {
          start = context.inputs[0].getInt32Array()[0];
          limit = context.inputs[1].getInt32Array()[0];
          delta = context.inputs[2].getInt32Array()[0];
        } else if (context.inputs[0].dataType === 1 /* float */) {
          start = context.inputs[0].getFloat32Array()[0];
          limit = context.inputs[1].getFloat32Array()[0];
          delta = context.inputs[2].getFloat32Array()[0];
        }
        if (env2.webgpu.validateInputContent) {
          validateInputsContent(start, limit, delta);
        }
        context.compute(createRangeProgramInfo(start, limit, delta, context.inputs[0].dataType), { inputs: [] });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/resize.ts
  var validateScales, updateScales, validateInputs25, getOriginalCoordinateFromResizedCoordinate, getNearestPixelFromOriginal, updateRoI, initOutputShape, adjustOutputShape, calculateOriginalIndicesFromOutputIndices, calculateInputIndicesFromOutputIndices, checkInputIndices, setChannelAndBatchIndices, bilinearInterpolation, bicubicInterpolation, trilinearInterpolation, createResizeProgramInfo, getOpsetVersionFromCustomDataBuffer, resize, parseResizeAttributes;
  var init_resize = __esm({
    "web/lib/wasm/jsep/webgpu/ops/resize.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateScales = (scales, attributes) => {
        scales.every(
          (value) => value > 0 || (() => {
            throw new Error("Resize requires scales input values to be positive");
          })
        );
        if (scales.length > 0) {
          if (attributes.mode === "linear") {
            if (!(scales.length === 2 || scales.length === 3 || scales.length === 4 && scales[0] === 1 && scales[1] === 1 || scales.length === 4 && scales[0] === 1 && scales[3] === 1 || scales.length === 5 && scales[0] === 1 && scales[1] === 1)) {
              throw new Error(
                `For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`
              );
            }
          } else if (attributes.mode === "cubic") {
            if (!(scales.length === 2 || scales.length === 4 && scales[0] === 1 && scales[1] === 1 || scales.length === 4 && scales[0] === 1 && scales[3] === 1)) {
              throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode");
            }
          }
        }
      };
      updateScales = (scales, axes, rank) => {
        axes.every(
          (value) => value >= 0 && value < rank || (() => {
            throw new Error("Resize requires axes input values to be positive and less than rank");
          })
        );
        const newScales = new Array(rank).fill(1);
        axes.forEach((value, index) => newScales[value] = scales[index]);
        return newScales;
      };
      validateInputs25 = (inputs, attributes, opsetVersion, scales, sizes, roi) => {
        const [roiInputIndex, scalesInputIndex, sizesInputIndex] = opsetVersion > 10 ? [1, 2, 3] : [-1, inputs.length > 1 ? 1 : -1, -1];
        const rank = inputs[0].dims.length;
        if (roiInputIndex > 0 && inputs.length > roiInputIndex && inputs[roiInputIndex].dims.length > 0) {
          inputs[roiInputIndex].getFloat32Array().forEach((value) => roi.push(value));
        } else if (attributes.coordinateTransformMode === "tf_crop_and_resize") {
          throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");
        }
        if (scalesInputIndex > 0 && inputs.length > scalesInputIndex && inputs[scalesInputIndex].dims.length > 0) {
          inputs[scalesInputIndex].getFloat32Array().forEach((value) => scales.push(value));
          if (scales.length !== 0 && scales.length !== rank && opsetVersion >= 18 && scales.length !== attributes.axes.length) {
            throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");
          }
          validateScales(scales, attributes);
          if (attributes.axes.length > 0) {
            updateScales(scales, attributes.axes, rank).forEach((value, index) => scales[index] = value);
          }
        }
        if (sizesInputIndex > 0 && inputs.length > sizesInputIndex) {
          inputs[sizesInputIndex].getBigInt64Array().forEach((value) => sizes.push(Number(value)));
          if (sizes.length !== rank || opsetVersion >= 18 && sizes.length === attributes.axes.length) {
            throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");
          }
        }
        if (attributes.axes.length > 0) {
          if (scales.length !== attributes.axes.length) {
            throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');
          }
          if (sizes.length !== attributes.axes.length) {
            throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified');
          }
        }
        if (typeof scales !== "undefined" && typeof sizes !== "undefined" && scales.length > 0 && sizes.length > rank) {
          throw new Error("Resize requires only of scales or sizes to be specified");
        }
      };
      getOriginalCoordinateFromResizedCoordinate = (coordinateTransferMode, dType) => `fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${dType} { ` + (() => {
        switch (coordinateTransferMode) {
          case "asymmetric":
            return `return ${dType}(xResized) / ${dType}(xScale);`;
          case "pytorch_half_pixel":
            return `if (lengthResized > 1) {
                    return (${dType}(xResized) + 0.5) / ${dType}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;
          case "tf_half_pixel_for_nn":
            return `return (${dType}(xResized) + 0.5) / ${dType}(xScale);`;
          case "align_corners":
            return `if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating
                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
                    // offset-by-one error later in floor().
                    let whole = ${dType}(xResized * (lengthOriginal - 1) / (lengthResized - 1));
                    let fract =
                        ${dType}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${dType}(lengthResized - 1);
                    return whole + fract;
                  }`;
          case "tf_crop_and_resize":
            return `if (lengthResized > 1) {
                    return ${dType}(roiStart) * ${dType}(lengthOriginal - 1) +
                        (${dType}(xResized) * ${dType}(roiEnd - roiStart) * ${dType}(lengthOriginal - 1)) /
                        ${dType}(lengthResized - 1);
                  } else {
                    return 0.5 * ${dType}(roiStart + roiEnd) * ${dType}(lengthOriginal - 1);
                  }`;
          case "half_pixel_symmetric":
            return `const outputWidth = ${dType}xScale * ${dType}(lengthResized);
                  const adjustment = ${dType}(lengthResized) / outputWidth;
                  const center = ${dType}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${dType}(xResized) + 0.5) / ${dType}(xScale)) - 0.5;`;
          case "half_pixel":
            return `return ((${dType}(xResized) + 0.5) / ${dType}(xScale)) - 0.5;`;
          default:
            throw new Error(`Coordinate transform mode ${coordinateTransferMode} is not supported`);
        }
      })() + "}";
      getNearestPixelFromOriginal = (nearestMode, opsetVersion, dType) => `fn getNearestPixelFromOriginal(xOriginal: ${dType}, isDownSample: bool) -> ${dType} {` + (() => {
        switch (nearestMode) {
          case "round_prefer_ceil":
            return "if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";
          case "floor":
            return "return floor(xOriginal);";
          case "ceil":
            return "return ceil(xOriginal);";
          case "round_prefer_floor":
            return "if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";
          case "simple":
          default:
            if (opsetVersion < 11) {
              return "if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";
            }
            throw new Error(`Nearest mode ${nearestMode} is not supported`);
        }
      })() + "}";
      updateRoI = (roi, axes, rank) => {
        const roiTmp = new Array(rank).fill(0).concat(new Array(rank).fill(1));
        const roiLocal = roi.length === 0 ? roiTmp : roi.slice();
        if (axes.length > 0) {
          axes.forEach((v, i) => {
            roiTmp[v] = roiLocal[i];
            roiTmp[i + rank] = roiLocal[axes.length + i];
          });
          return roiTmp;
        }
        return roiLocal;
      };
      initOutputShape = (inputShape, scales, sizes, axes) => {
        let outputShape = [];
        if (sizes.length > 0) {
          if (axes.length > 0) {
            inputShape.forEach((v) => outputShape.push(v));
            if (Math.max(...axes) > inputShape.length) {
              throw new Error("axes is out of bound");
            }
            axes.forEach((v, i) => outputShape[v] = sizes[i]);
          } else {
            sizes.forEach((v) => outputShape.push(v));
          }
        } else {
          if (scales.length === 0) {
            throw new Error("Resize requires either scales or sizes.");
          } else {
            outputShape = inputShape.map((value, index) => Math.round(value * scales[index]));
          }
        }
        return outputShape;
      };
      adjustOutputShape = (inputShape, scales, attributes) => {
        const scaleInPolicy = (() => {
          switch (attributes.keepAspectRatioPolicy) {
            case "not_larger":
              return attributes.axes.length > 0 ? Math.min(...attributes.axes.map((i) => scales[i]), Number.MAX_VALUE) : Math.min(...scales, Number.MAX_VALUE);
            case "not_smaller":
              return attributes.axes.length > 0 ? Math.max(...attributes.axes.map((i) => scales[i]), Number.MIN_VALUE) : Math.max(...scales, Number.MIN_VALUE);
            default:
              throw new Error(`Keep aspect ratio policy ${attributes.keepAspectRatioPolicy} is not supported`);
          }
        })();
        scales.fill(1, 0, scales.length);
        const adjustedOutputShape = inputShape.slice();
        if (attributes.axes.length > 0) {
          attributes.axes.forEach((v) => scales[v] = scaleInPolicy);
          attributes.axes.forEach((v) => adjustedOutputShape[v] = Math.round(inputShape[v] * scales[v]));
        } else {
          scales.fill(scaleInPolicy, 0, scales.length);
          adjustedOutputShape.forEach((v, i) => adjustedOutputShape[i] = Math.round(v * scales[i]));
        }
        return adjustedOutputShape;
      };
      calculateOriginalIndicesFromOutputIndices = (output, inputShape, outputShape, scalesLength, roiLength) => `
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${output.type.indices}) -> array<${output.type.value}, ${outputShape.length}> {
      var original_indices: array<${output.type.value}, ${outputShape.length}>;
      for (var i:u32 = 0; i < ${outputShape.length}; i++) {
        var output_index = ${output.indicesGet("output_indices", "i")};
        var scale = ${getElementAt("uniforms.scales", "i", scalesLength)};
        var roi_low = ${getElementAt("uniforms.roi", "i", roiLength)};
        var roi_hi = ${getElementAt("uniforms.roi", `i + ${inputShape.length}`, roiLength)};
        if (scale == 1.0) {
          original_indices[i] = ${output.type.value}(output_index);
        } else {
          var input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};
          var output_shape_i = ${getElementAt("uniforms.output_shape", "i", outputShape.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`;
      calculateInputIndicesFromOutputIndices = (input, output, inputShape, outputShape, scalesLength, roiLength, useExtrapolation) => `
    fn calculateInputIndicesFromOutputIndices(output_indices: ${output.type.indices}) -> ${input.type.indices} {
      var input_indices: ${input.type.indices};
      for (var i:u32 = 0; i < ${outputShape.length}; i++) {
        var output_index = ${output.indicesGet("output_indices", "i")};
        var input_index: u32;
        var scale = ${getElementAt("uniforms.scales", "i", scalesLength)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${getElementAt("uniforms.roi", "i", roiLength)};
          var roi_hi = ${getElementAt("uniforms.roi", `i + ${inputShape.length}`, roiLength)};
          var input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};
          var output_shape_i = ${getElementAt("uniforms.output_shape", "i", outputShape.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${useExtrapolation} || (original_idx >= 0 && original_idx < ${output.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${output.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${input.indicesSet("input_indices", "i", " input_index")}
      }
      return input_indices;
    }`;
      checkInputIndices = (input, inputShape) => `
    fn checkInputIndices(input_indices: ${input.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${inputShape.length}; i++) {
        var input_index = ${input.indicesGet("input_indices", "i")};
        if (input_index < 0 || input_index >= ${getElementAt("uniforms.input_shape", "i", inputShape.length)}) {
          return false;
        }
      }
      return true;
    }`;
      setChannelAndBatchIndices = (input, channelIdx, batchIdx, spacialDims) => input.rank > spacialDims ? `
    ${input.indicesSet("input_indices", channelIdx, "channel")};
    ${input.indicesSet("input_indices", batchIdx, "batch")};
` : "";
      bilinearInterpolation = (input, output, inputShape, useExtrapolation, extrapolationValue) => {
        const isNchw = true;
        const [batchIdx, heightIdx, widthIdx, channelIdx] = inputShape.length === 2 ? [-1, 0, 1, -1] : isNchw ? [0, 2, 3, 1] : [0, 1, 2, 3];
        const dType = input.type.value;
        return `
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${dType} {
      var input_indices: ${input.type.indices};
      ${input.indicesSet("input_indices", heightIdx, `max(0, min(row, ${inputShape[heightIdx]} - 1))`)};
      ${input.indicesSet("input_indices", widthIdx, `max(0, min(col, ${inputShape[widthIdx]} - 1))`)};
      ${setChannelAndBatchIndices(input, channelIdx, batchIdx, 2)}
      return ${input.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${output.type.indices}) -> ${dType} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${dType} = originalIndices[${heightIdx}];
      var col:${dType} = originalIndices[${widthIdx}];
      ${useExtrapolation ? `if (row < 0 || row > (${inputShape[heightIdx]} - 1) || col < 0 || col > (${inputShape[widthIdx]} - 1)) {
        return ${extrapolationValue};
      }` : ""};
      row = max(0, min(row, ${inputShape[heightIdx]} - 1));
      col = max(0, min(col, ${inputShape[widthIdx]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${inputShape.length > 2 ? `u32(originalIndices[${channelIdx}])` : "0"};
      var batch: u32 =  ${inputShape.length > 2 ? `u32(originalIndices[${batchIdx}])` : "0"};
      var x11: ${dType} = getInputValue(batch, channel, row1, col1);
      var x12: ${dType} = getInputValue(batch, channel, row1, col2);
      var x21: ${dType} = getInputValue(batch, channel, row2, col1);
      var x22: ${dType} = getInputValue(batch, channel, row2, col2);
      var dx1: ${dType} = abs(row - ${dType}(row1));
      var dx2: ${dType} = abs(${dType}(row2) - row);
      var dy1: ${dType} = abs(col - ${dType}(col1));
      var dy2: ${dType} = abs(${dType}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`;
      };
      bicubicInterpolation = (input, output, inputShape, outputShape, scales, roi, cubicCoeffA, useExtrapolation, extrapolationValue, excludeOutside) => {
        const is2D = inputShape.length === 2;
        const isNchw = true;
        const [heightIdx, widthIdx] = is2D ? [0, 1] : isNchw ? [2, 3] : [1, 2];
        const dType = input.type.value;
        const createCubicInterpolationFunction = (idx) => {
          const direction = idx === heightIdx ? "row" : "col";
          return `
      fn ${direction}CubicInterpolation(input_indices: ${input.type.indices}, output_indices: ${output.type.indices}) -> ${dType} {
        var output_index = ${output.indicesGet("output_indices", idx)};
        var originalIdx: ${dType} = getOriginalCoordinateFromResizedCoordinate(output_index, ${scales[idx]},
        ${outputShape[idx]}, ${inputShape[idx]}, ${roi[idx]}, ${roi[idx]} + ${inputShape.length});
        var fractOriginalIdx: ${dType} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${useExtrapolation} && (originalIdx < 0 || originalIdx > (${inputShape[idx]} - 1))) {
          return ${extrapolationValue};
        }
        var data: array<${dType}, 4> = array<${dType}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${direction}: ${dType} = originalIdx + ${dType}(i);
          if (${direction} < 0 || ${direction} >= ${inputShape[idx]}) {
            ${(() => {
            if (excludeOutside) {
              return `coefs[i + 1] = 0.0;
                        continue;`;
            } else if (useExtrapolation) {
              return `return ${extrapolationValue};`;
            } else {
              return `${direction} = max(0, min(${direction}, ${inputShape[idx]} - 1));`;
            }
          })()};
          }
        var input_indices_copy: ${input.type.indices} = input_indices;
          ${input.indicesSet("input_indices_copy", idx, `u32(${direction})`)};
          data[i + 1] = ${idx === heightIdx ? input.getByIndices("input_indices_copy") : "rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`;
        };
        return `
    ${createCubicInterpolationFunction(heightIdx)};
    ${createCubicInterpolationFunction(widthIdx)};
  fn getCubicInterpolationCoefs(s: ${dType}) -> array<${dType}, 4> {
    var absS = abs(s);
    var coeffs: array<${dType}, 4> = array<${dType}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${dType} = 1.0 - absS;
    var twoMinusAbsS: ${dType} = 2.0 - absS;
    var onePlusAbsS: ${dType} = 1.0 + absS;
    coeffs[0] = ((${cubicCoeffA} * onePlusAbsS - 5 * ${cubicCoeffA}) * onePlusAbsS + 8 * ${cubicCoeffA}) * onePlusAbsS - 4 * ${cubicCoeffA};
    coeffs[1] = ((${cubicCoeffA} + 2) * absS - (${cubicCoeffA} + 3)) * absS * absS + 1;
    coeffs[2] = ((${cubicCoeffA} + 2) * oneMinusAbsS - (${cubicCoeffA} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${cubicCoeffA} * twoMinusAbsS - 5 * ${cubicCoeffA}) * twoMinusAbsS + 8 * ${cubicCoeffA}) * twoMinusAbsS - 4 * ${cubicCoeffA};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${dType}, 4>, coefs: array<${dType}, 4>) -> ${dType} {
    var coefsSum: ${dType} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${output.type.indices}) -> ${dType} {
    var input_indices: ${input.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `;
      };
      trilinearInterpolation = (input, output, inputShape, useExtrapolation, extrapolationValue) => {
        const isNchw = true;
        const [batchIdx, depthIdx, heightIdx, widthIdx, channelIdx] = inputShape.length === 3 ? [-1, 0, 1, 2, -1] : isNchw ? [0, 2, 3, 4, 1] : [0, 1, 2, 3, 4];
        const dType = input.type.value;
        return `
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${dType} {
      var input_indices: ${input.type.indices};
      ${input.indicesSet("input_indices", depthIdx, `max(0, min(depth, ${inputShape[depthIdx]} - 1))`)};
      ${input.indicesSet("input_indices", heightIdx, `max(0, min(height, ${inputShape[heightIdx]} - 1))`)};
      ${input.indicesSet("input_indices", widthIdx, `max(0, min(width, ${inputShape[widthIdx]} - 1))`)};
      ${setChannelAndBatchIndices(input, channelIdx, batchIdx, 3)}
      return ${input.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${output.type.indices}) -> ${dType} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${dType} = originalIndices[${depthIdx}];
      var height:${dType} = originalIndices[${heightIdx}];
      var width:${dType} = originalIndices[${widthIdx}];
      ${useExtrapolation ? `if (depth < 0 || depth > (${inputShape[depthIdx]} - 1) || height < 0 || height > (${inputShape[heightIdx]} - 1) || width < 0 || (width > ${inputShape[widthIdx]} - 1)) {
      return ${extrapolationValue};
        }` : ""};

    depth = max(0, min(depth, ${inputShape[depthIdx]} - 1));
      height = max(0, min(height, ${inputShape[heightIdx]} - 1));
      width = max(0, min(width, ${inputShape[widthIdx]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${inputShape.length > 3 ? `u32(originalIndices[${channelIdx}])` : "0"};
      var batch: u32 =  ${inputShape.length > 3 ? `u32(originalIndices[${batchIdx}])` : "0"};

      var x111: ${dType} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${dType} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${dType} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${dType} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${dType} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${dType} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${dType} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${dType} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${dType} = abs(depth - ${dType}(depth1));
      var dx2: ${dType} = abs(${dType}(depth2) - depth);
      var dy1: ${dType} = abs(height - ${dType}(height1));
      var dy2: ${dType} = abs(${dType}(height2) - height);
      var dz1: ${dType} = abs(width - ${dType}(width1));
      var dz2: ${dType} = abs(${dType}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`;
      };
      createResizeProgramInfo = (inputTensor, attributes, opsetVersion, scalesInput, sizes, roiInput) => {
        const inputShape = inputTensor.dims;
        const roi = updateRoI(roiInput, attributes.axes, inputShape.length);
        let outputShape = initOutputShape(inputShape, scalesInput, sizes, attributes.axes);
        let scales = scalesInput.slice();
        if (scalesInput.length === 0) {
          scales = inputShape.map((value, index) => value === 0 ? 1 : outputShape[index] / value);
          if (attributes.keepAspectRatioPolicy !== "stretch") {
            outputShape = adjustOutputShape(inputShape, scales, attributes);
          }
        }
        const output = outputVariable("output", inputTensor.dataType, outputShape.length);
        const input = inputVariable("input", inputTensor.dataType, inputShape.length);
        const outputSize = ShapeUtil.size(outputShape);
        const noScale = inputShape.length === outputShape.length && inputShape.every((d, i) => d === outputShape[i]);
        const useExtrapolation = attributes.coordinateTransformMode === "tf_crop_and_resize";
        const extrapolationValue = attributes.extrapolationValue;
        const dataType = input.type.value;
        const getShaderSource = (shaderHelper) => `
      ${noScale ? "" : `
      ${getOriginalCoordinateFromResizedCoordinate(attributes.coordinateTransformMode, dataType)};
      ${(() => {
          switch (attributes.mode) {
            case "nearest":
              return `
              ${checkInputIndices(input, inputShape)};
              ${getNearestPixelFromOriginal(attributes.nearestMode, opsetVersion, dataType)};
              ${calculateInputIndicesFromOutputIndices(
                input,
                output,
                inputShape,
                outputShape,
                scales.length,
                roi.length,
                useExtrapolation
              )};
              `;
            case "linear":
              return `
              ${calculateOriginalIndicesFromOutputIndices(output, inputShape, outputShape, scales.length, roi.length)};
              ${(() => {
                if (inputShape.length === 2 || inputShape.length === 4) {
                  return `${bilinearInterpolation(input, output, inputShape, useExtrapolation, extrapolationValue)}`;
                } else if (inputShape.length === 3 || inputShape.length === 5) {
                  return `${trilinearInterpolation(input, output, inputShape, useExtrapolation, extrapolationValue)}`;
                } else {
                  throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.");
                }
              })()};
            `;
            case "cubic":
              return `
            ${(() => {
                if (inputShape.length === 2 || inputShape.length === 4) {
                  return `${bicubicInterpolation(
                    input,
                    output,
                    inputShape,
                    outputShape,
                    scales,
                    roi,
                    attributes.cubicCoeffA,
                    useExtrapolation,
                    attributes.extrapolationValue,
                    attributes.excludeOutside
                  )}`;
                } else {
                  throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.");
                }
              })()};
            `;
            default:
              throw Error("Invalid resize mode");
          }
        })()};
      `}
      ${shaderHelper.registerUniform("output_size", "u32").registerUniform("scales", "f32", scales.length).registerUniform("roi", "f32", roi.length).declareVariables(input, output)}
      ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${noScale ? "output[global_idx] = input[global_idx];" : `
        let output_indices = ${output.offsetToIndices("global_idx")};
        var input_indices: ${input.type.indices};
        ${(() => {
          switch (attributes.mode) {
            case "nearest":
              return `input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${input.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${attributes.extrapolationValue};
                }`;
            case "linear":
              return `output[global_idx] = ${inputShape.length === 2 || inputShape.length === 4 ? "bilinearInterpolation" : "trilinearInterpolation"}(output_indices);`;
            case "cubic":
              return "output[global_idx] = bicubicInterpolation(output_indices);";
            default:
              throw Error(`Unsupported resize mode: ${attributes.mode}`);
          }
        })()};
`}
      }`;
        return {
          name: "Resize",
          shaderCache: {
            hint: `${attributes.cacheKey}|${opsetVersion}|${scales.length > 0 ? scales : ""}|${sizes.length > 0 ? sizes : ""}|${roi.length > 0 ? roi : ""}|${noScale}|${inputShape}`,
            inputDependencies: ["rank"]
          },
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: inputTensor.dataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64
              /* workgroup size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: outputSize },
              { type: 1 /* float */, data: scales },
              { type: 1 /* float */, data: roi },
              ...createTensorShapeVariables(inputShape, outputShape)
            ]
          })
        };
      };
      getOpsetVersionFromCustomDataBuffer = (context) => {
        const customDataBuffer = context.customDataBuffer;
        const customDataBuffer32 = new Uint32Array(customDataBuffer, customDataBuffer.byteOffset, 1);
        const opsetVersion = customDataBuffer32[0];
        return opsetVersion;
      };
      resize = (context, attributes) => {
        const scales = [];
        const sizes = [];
        const roi = [];
        const opsetVersion = getOpsetVersionFromCustomDataBuffer(context);
        if (attributes.antialias !== 0) {
          throw Error("Only default value (0) for Antialias attribute is supported");
        }
        validateInputs25(context.inputs, attributes, opsetVersion, scales, sizes, roi);
        context.compute(createResizeProgramInfo(context.inputs[0], attributes, opsetVersion, scales, sizes, roi), {
          inputs: [0]
        });
      };
      parseResizeAttributes = (attributes) => {
        const antialias = attributes.antialias;
        const axes = attributes.axes;
        const coordinateTransformMode = attributes.coordinateTransformMode;
        const cubicCoeffA = attributes.cubicCoeffA;
        const excludeOutside = attributes.excludeOutside !== 0;
        const extrapolationValue = attributes.extrapolationValue;
        const keepAspectRatioPolicy = attributes.keepAspectRatioPolicy;
        const mode = attributes.mode;
        const nearestMode = attributes.nearestMode === "" ? "simple" : attributes.nearestMode;
        return createAttributeWithCacheKey({
          antialias,
          axes,
          coordinateTransformMode,
          cubicCoeffA,
          excludeOutside,
          extrapolationValue,
          keepAspectRatioPolicy,
          mode,
          nearestMode
        });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/rotary-embedding.ts
  var validateInputs26, createRotaryEmbeddingProgramInfo, rotaryEmbedding;
  var init_rotary_embedding = __esm({
    "web/lib/wasm/jsep/webgpu/ops/rotary-embedding.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs26 = (inputs, attributes) => {
        const [input, positionIds, cosCache, sinCache] = inputs;
        const { numHeads, rotaryEmbeddingDim } = attributes;
        if (input.dims.length !== 3 && input.dims.length !== 4) {
          throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${input.dims.length}`);
        }
        if (!ShapeUtil.areEqual(positionIds.dims, []) && !ShapeUtil.areEqual(positionIds.dims, [1]) && positionIds.dims.length !== 2) {
          throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${positionIds.dims.length}`);
        }
        if (cosCache.dims.length !== 2) {
          throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${cosCache.dims.length}`);
        }
        if (sinCache.dims.length !== 2) {
          throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${sinCache.dims.length}`);
        }
        if (!ShapeUtil.areEqual(cosCache.dims, sinCache.dims)) {
          throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");
        }
        if (rotaryEmbeddingDim > 0 && numHeads === 0) {
          throw new Error("num_heads must be provided if rotary_embedding_dim is specified");
        }
        const batchSize = input.dims[0];
        const sequenceLength = input.dims[input.dims.length - 2];
        const maxSequenceLength = cosCache.dims[0];
        const hiddenSize = ShapeUtil.sizeFromDimension(input.dims, 1) / sequenceLength;
        const headSize = rotaryEmbeddingDim === 0 ? cosCache.dims[1] * 2 : hiddenSize / numHeads;
        if (rotaryEmbeddingDim > headSize) {
          throw new Error("rotary_embedding_dim must be less than or equal to head_size");
        }
        if (positionIds.dims.length === 2) {
          if (batchSize !== positionIds.dims[0]) {
            throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${positionIds.dims[0]}`);
          }
          if (sequenceLength !== positionIds.dims[1]) {
            throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${positionIds.dims[1]}`);
          }
        }
        if (headSize / 2 !== cosCache.dims[1] && rotaryEmbeddingDim / 2 !== cosCache.dims[1]) {
          throw new Error(
            `Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${cosCache.dims[1]}`
          );
        }
        if (sequenceLength > maxSequenceLength) {
          throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported");
        }
      };
      createRotaryEmbeddingProgramInfo = (inputs, attributes) => {
        const { interleaved, numHeads, rotaryEmbeddingDim, scale } = attributes;
        const batchSize = inputs[0].dims[0];
        const batchStride = ShapeUtil.sizeFromDimension(inputs[0].dims, 1);
        const sequenceLength = inputs[0].dims[inputs[0].dims.length - 2];
        const hiddenSize = batchStride / sequenceLength;
        const halfRotaryEmbeddingDim = inputs[2].dims[1];
        const headSize = rotaryEmbeddingDim === 0 ? halfRotaryEmbeddingDim * 2 : hiddenSize / numHeads;
        const globalShape = new Array(
          batchSize,
          sequenceLength,
          hiddenSize / headSize,
          headSize - halfRotaryEmbeddingDim
        );
        const globalStrides = ShapeUtil.computeStrides(globalShape);
        const programUniforms = [
          { type: 1 /* float */, data: scale },
          { type: 12 /* uint32 */, data: globalShape },
          { type: 12 /* uint32 */, data: globalStrides },
          // strides for addressing the input/output tensor, in permutated order to align with the unfolded global index,
          // i.e. BSNH
          ...inputs[0].dims.length === 3 ? new Array({ type: 12 /* uint32 */, data: [batchStride, hiddenSize, headSize, 1] }) : [],
          ...inputs[0].dims.length === 4 ? new Array({
            type: 12 /* uint32 */,
            data: [batchStride, headSize, sequenceLength * headSize, 1]
          }) : [],
          ...createTensorShapeVariables(inputs[0].dims, inputs[1].dims, inputs[2].dims, inputs[3].dims, inputs[0].dims)
        ];
        const getShaderSource = (shaderHelper) => {
          const input = inputVariable("input", inputs[0].dataType, inputs[0].dims.length);
          const positionIds = inputVariable("position_ids", inputs[1].dataType, inputs[1].dims.length);
          const cosCache = inputVariable("cos_cache", inputs[2].dataType, inputs[2].dims.length);
          const sinCache = inputVariable("sin_cache", inputs[3].dataType, inputs[3].dims.length);
          const output = outputVariable("output", inputs[0].dataType, inputs[0].dims.length);
          shaderHelper.registerUniforms([
            { name: "scale", type: "f32" },
            { name: "global_shape", type: "u32", length: globalShape.length },
            { name: "global_strides", type: "u32", length: globalStrides.length },
            { name: "input_output_strides", type: "u32", length: globalStrides.length }
          ]);
          return `
        ${shaderHelper.declareVariables(input, positionIds, cosCache, sinCache, output)}

        ${shaderHelper.mainStart(WORKGROUP_SIZE)}
          let half_rotary_emb_dim = uniforms.${cosCache.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${positionIds.broadcastedIndicesToOffset("bsnh.xy", outputVariable("", positionIds.type.tensor, 2))};
            let position_id =
                u32(${positionIds.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${interleaved});
            let j = i + select(half_rotary_emb_dim, 1, ${interleaved});
            let re = ${input.getByOffset("i")} * ${cosCache.get("position_id", "bsnh[3]")} -
                ${input.getByOffset("j")} * ${sinCache.get("position_id", "bsnh[3]")};
            ${output.setByOffset("i", "re")}
            let im = ${input.getByOffset("i")} * ${sinCache.get("position_id", "bsnh[3]")} +
                ${input.getByOffset("j")} * ${cosCache.get("position_id", "bsnh[3]")};
            ${output.setByOffset("j", "im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${output.setByOffset("k", input.getByOffset("k"))}
          }
        }`;
        };
        return {
          name: "RotaryEmbedding",
          shaderCache: {
            hint: createAttributeWithCacheKey({
              interleaved
            }).cacheKey,
            inputDependencies: ["rank", "rank", "rank", "rank"]
          },
          getShaderSource,
          getRunData: () => ({
            outputs: [{ dims: inputs[0].dims, dataType: inputs[0].dataType }],
            dispatchGroup: { x: Math.ceil(ShapeUtil.size(globalShape) / WORKGROUP_SIZE) },
            programUniforms
          })
        };
      };
      rotaryEmbedding = (context, attributes) => {
        validateInputs26(context.inputs, attributes);
        context.compute(createRotaryEmbeddingProgramInfo(context.inputs, attributes));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/skip-layer-norm.ts
  var validateInputs27, createSkipLayerNormProgramInfo, skipLayerNorm;
  var init_skip_layer_norm = __esm({
    "web/lib/wasm/jsep/webgpu/ops/skip-layer-norm.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      validateInputs27 = (inputs) => {
        if (!inputs || inputs.length < 3) {
          throw new Error("layerNorm requires at least 3 inputs.");
        }
        const input = inputs[0];
        const skip = inputs[1];
        const gamma = inputs[2];
        if (input.dataType !== skip.dataType || input.dataType !== gamma.dataType) {
          throw new Error("All inputs must have the same data type");
        }
        if (input.dims.length !== 3 && input.dims.length !== 2) {
          throw new Error("Input must be 2D or 3D");
        }
        if (skip.dims.length !== 3 && skip.dims.length !== 2) {
          throw new Error("Skip must be 2D or 3D");
        }
        const hiddenSize = input.dims[input.dims.length - 1];
        const sequenceLength = input.dims[input.dims.length - 2];
        if (skip.dims[skip.dims.length - 1] !== hiddenSize) {
          throw new Error("Skip must have the same hidden size as input");
        }
        if (skip.dims[skip.dims.length - 2] !== sequenceLength) {
          throw new Error("Skip must have the same sequence length as input");
        }
        if (gamma.dims.length !== 1) {
          throw new Error("Gamma must be 1D");
        }
        if (gamma.dims[gamma.dims.length - 1] !== hiddenSize) {
          throw new Error("Gamma must have the same hidden size as input");
        }
        if (inputs.length > 3) {
          const beta = inputs[3];
          if (beta.dims.length !== 1) {
            throw new Error("Beta must be 1D");
          }
          if (beta.dims[beta.dims.length - 1] !== hiddenSize) {
            throw new Error("Beta must have the same hidden size as input");
          }
        }
        if (inputs.length > 4) {
          const bias = inputs[4];
          if (bias.dims.length !== 1) {
            throw new Error("Bias must be 1D");
          }
          if (bias.dims[bias.dims.length - 1] !== hiddenSize) {
            throw new Error("Bias must have the same hidden size as input");
          }
        }
      };
      createSkipLayerNormProgramInfo = (inputs, attributes, outputCount, isTraining) => {
        const simplified = attributes.simplified;
        const inputShape = inputs[0].dims;
        const inputSize = ShapeUtil.size(inputShape);
        const outputShape = inputShape;
        const outputSize = inputSize;
        const hiddenSize = inputShape.slice(-1)[0];
        const meanInvStdDevDim = isTraining ? inputShape.slice(0, -1).concat(1) : [];
        const hasBetaInput = !simplified && inputs.length > 3;
        const hasBiasInput = inputs.length > 4;
        const hasMeanOutput = isTraining && outputCount > 1;
        const hasInvStdDevOutput = isTraining && outputCount > 2;
        const hasInputSkipBiasSumOutput = outputCount > 3;
        const workgroupSize = 64;
        const components = getMaxComponents(hiddenSize);
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: components },
          { type: 12 /* uint32 */, data: hiddenSize },
          { type: 1 /* float */, data: attributes.epsilon }
        ];
        const getShaderSource = (shaderHelper) => {
          const uniformsArray = [
            { name: "output_size", type: "u32" },
            { name: "components", type: "u32" },
            { name: "hidden_size", type: "u32" },
            { name: "epsilon", type: "f32" }
          ];
          const variables = [
            inputVariable("x", inputs[0].dataType, inputs[0].dims, components),
            inputVariable("skip", inputs[1].dataType, inputs[1].dims, components),
            inputVariable("gamma", inputs[2].dataType, inputs[2].dims, components)
          ];
          if (hasBetaInput) {
            variables.push(inputVariable("beta", inputs[3].dataType, inputs[3].dims, components));
          }
          if (hasBiasInput) {
            variables.push(inputVariable("bias", inputs[4].dataType, inputs[4].dims, components));
          }
          variables.push(outputVariable("output", inputs[0].dataType, outputShape, components));
          if (hasMeanOutput) {
            variables.push(outputVariable("mean_output", 1 /* float */, meanInvStdDevDim));
          }
          if (hasInvStdDevOutput) {
            variables.push(outputVariable("inv_std_output", 1 /* float */, meanInvStdDevDim));
          }
          if (hasInputSkipBiasSumOutput) {
            variables.push(outputVariable("input_skip_bias_sum", inputs[0].dataType, outputShape, components));
          }
          const dataType = tensorTypeToWsglStorageType(inputs[0].dataType);
          const vecDataType = tensorTypeToWsglStorageType(1 /* float */, components);
          return `

      ${shaderHelper.registerUniforms(uniformsArray).declareVariables(...variables)}
      var<workgroup> sum_shared : array<${vecDataType}, ${workgroupSize}>;
      var<workgroup> sum_squared_shared : array<${vecDataType}, ${workgroupSize}>;

      ${shaderHelper.mainStart([workgroupSize, 1, 1])}
        let ix = local_id.x;
        let iy = global_id.x / ${workgroupSize};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${workgroupSize};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${workgroupSize - 1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${hasBiasInput ? "bias[offset1d + i]" : dataType + "(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${hasInputSkipBiasSumOutput ? "input_skip_bias_sum[offset + i] = value;" : ""}
          output[offset + i] = value;
          let f32_value = ${castToF32(dataType, components, "value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${workgroupSize};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${sumVector("sum", components)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${sumVector("square_sum", components)} / f32(uniforms.hidden_size) ${simplified ? "" : "- mean * mean"} + uniforms.epsilon);
        ${hasMeanOutput ? "mean_output[global_idx] = mean;" : ""}
        ${hasInvStdDevOutput ? "inv_std_output[global_idx] = inv_std_dev;" : ""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${simplified ? "" : `- ${dataType}(mean)`}) *
            ${dataType}(inv_std_dev) * gamma[offset1d + i]
            ${hasBetaInput ? "+ beta[offset1d + i]" : ""};
        }
      }`;
        };
        const outputs = [{ dims: outputShape, dataType: inputs[0].dataType }];
        if (outputCount > 1) {
          outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
        }
        if (outputCount > 2) {
          outputs.push({ dims: meanInvStdDevDim, dataType: 1 /* float */ });
        }
        if (outputCount > 3) {
          outputs.push({ dims: inputShape, dataType: inputs[0].dataType });
        }
        return {
          name: "SkipLayerNormalization",
          shaderCache: {
            hint: `${components};${hasMeanOutput};${hasInvStdDevOutput};${hasInputSkipBiasSumOutput}`,
            inputDependencies: inputs.map((_input, _index) => "type")
          },
          getShaderSource,
          getRunData: () => ({
            outputs,
            dispatchGroup: {
              x: Math.ceil(outputSize / hiddenSize)
            },
            programUniforms
          })
        };
      };
      skipLayerNorm = (context, attributes) => {
        const isTraining = false;
        validateInputs27(context.inputs);
        const outputs = [0];
        if (context.outputCount > 1) {
          outputs.push(isTraining ? 1 : -3);
        }
        if (context.outputCount > 2) {
          outputs.push(isTraining ? 2 : -3);
        }
        if (context.outputCount > 3) {
          outputs.push(3);
        }
        context.compute(createSkipLayerNormProgramInfo(context.inputs, attributes, context.outputCount, isTraining), {
          outputs
        });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/slice.ts
  var validateInputs28, readInput, createSliceAttributesFromInputs, fixStartEndValues, calculateInputIndicesImpl, createSliceProgramInfo, slice, parseSliceAttributes;
  var init_slice = __esm({
    "web/lib/wasm/jsep/webgpu/ops/slice.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs28 = (inputs, attributes) => {
        if (!inputs || inputs.length < 1) {
          throw new Error("too few inputs");
        }
        if (attributes.axes.length !== 0) {
          if (attributes.axes.length !== attributes.starts.length || attributes.axes.length !== attributes.ends.length) {
            throw new Error("axes, starts and ends must have the same length");
          }
        } else if (attributes.starts.length !== attributes.ends.length) {
          throw new Error("starts and ends must have the same length");
        }
        inputs.slice(1).forEach((_, idx) => {
          if (inputs[idx + 1].dataType !== 6 /* int32 */ && inputs[idx + 1].dataType !== 7 /* int64 */) {
            throw new Error(`Input ${idx} must be an array of int32 or int64`);
          }
        });
      };
      readInput = (inputs, idx) => {
        const input = [];
        if (inputs.length > idx) {
          if (inputs[idx].dataType === 7 /* int64 */) {
            inputs[idx].getBigInt64Array().forEach((v) => input.push(Number(v)));
          } else if (inputs[idx].dataType === 6 /* int32 */) {
            inputs[idx].getInt32Array().forEach((v) => input.push(Number(v)));
          } else {
            throw new Error(`Input ${idx} must be an array of int32 or int64`);
          }
        }
        return input;
      };
      createSliceAttributesFromInputs = (inputs, attributes) => {
        if (inputs.length > 1) {
          const starts = readInput(inputs, 1);
          const ends = readInput(inputs, 2);
          let axes = readInput(inputs, 3);
          if (axes.length === 0) {
            axes = [...Array(inputs[0].dims.length).keys()];
          }
          return createAttributeWithCacheKey({ starts, ends, axes });
        } else {
          return attributes;
        }
      };
      fixStartEndValues = (value, index, inputShape, axes, steps) => {
        let newValue = value;
        if (value < 0) {
          newValue += inputShape[axes[index]];
        }
        if (steps[index] < 0) {
          return Math.max(0, Math.min(newValue, inputShape[axes[index]] - 1));
        } else {
          return Math.max(0, Math.min(newValue, inputShape[axes[index]]));
        }
      };
      calculateInputIndicesImpl = (input, output, inputShape) => `fn calculateInputIndices(output_indices: ${output.type.indices}) -> ${input.type.indices} {
          var input_indices: ${input.type.indices};
          var carry = 0u;
          for (var i = ${inputShape.length}; i >= 0; i--) {
            let input_shape_i = ${getElementAt("uniforms.input_shape", "i", inputShape.length)};
            let steps_i = ${getElementAt("uniforms.steps", "i", inputShape.length)};
            let signs_i = ${getElementAt("uniforms.signs", "i", inputShape.length)};
            let starts_i = ${getElementAt("uniforms.starts", "i", inputShape.length)};
            var output_index = ${output.indicesGet("output_indices", "i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${input.indicesSet("input_indices", "i", "input_index")};
          }
          return input_indices;
      }`;
      createSliceProgramInfo = (inputs, attributes) => {
        const inputShape = inputs[0].dims;
        const inputSize = ShapeUtil.size(inputShape);
        const axes = attributes.axes.length > 0 ? ShapeUtil.normalizeAxes(attributes.axes, inputShape.length) : [...Array(inputShape.length).keys()];
        let steps = readInput(inputs, 4);
        steps.forEach(
          (step) => step !== 0 || (() => {
            throw new Error("step cannot be 0");
          })
        );
        if (steps.length === 0) {
          steps = Array(axes.length).fill(1);
        }
        const starts = attributes.starts.map((start, i) => fixStartEndValues(start, i, inputShape, axes, steps));
        const ends = attributes.ends.map((end, i) => fixStartEndValues(end, i, inputShape, axes, steps));
        if (axes.length !== starts.length || axes.length !== ends.length) {
          throw new Error("start, ends and axes should have the same number of elements");
        }
        if (axes.length !== inputShape.length) {
          for (let i = 0; i < inputShape.length; ++i) {
            if (!axes.includes(i)) {
              starts.splice(i, 0, 0);
              ends.splice(i, 0, inputShape[i]);
              steps.splice(i, 0, 1);
            }
          }
        }
        const signs = steps.map((step) => Math.sign(step));
        steps.forEach((step, i, array) => {
          if (step < 0) {
            const numSteps = (ends[i] - starts[i]) / step;
            const newEnd = starts[i];
            const newStart = newEnd + numSteps * steps[i];
            starts[i] = newStart;
            ends[i] = newEnd;
            array[i] = -step;
          }
        });
        const outputShape = inputShape.slice(0);
        axes.forEach((axis, _) => {
          outputShape[axis] = Math.ceil((ends[axis] - starts[axis]) / steps[axis]);
        });
        const outputTensorInfo = { dims: outputShape, dataType: inputs[0].dataType };
        const output = outputVariable("output", inputs[0].dataType, outputShape.length);
        const input = inputVariable("input", inputs[0].dataType, inputs[0].dims.length);
        const outputSize = ShapeUtil.size(outputShape);
        const uniforms = [
          { name: "outputSize", type: "u32" },
          { name: "starts", type: "u32", length: starts.length },
          { name: "signs", type: "i32", length: signs.length },
          { name: "steps", type: "u32", length: steps.length }
        ];
        const programUniforms = [
          { type: 12 /* uint32 */, data: outputSize },
          { type: 12 /* uint32 */, data: starts },
          { type: 6 /* int32 */, data: signs },
          { type: 12 /* uint32 */, data: steps },
          ...createTensorShapeVariables(inputs[0].dims, outputShape)
        ];
        const getShaderSource = (shaderHelper) => `
      ${shaderHelper.registerUniforms(uniforms).declareVariables(input, output)}
        ${calculateInputIndicesImpl(input, output, inputShape)}
        ${shaderHelper.mainStart()}
          ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${output.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${output.setByOffset("global_idx", input.getByIndices("input_indices"))}
      }`;
        return {
          name: "Slice",
          shaderCache: { hint: `${signs.length}_${starts.length}_${steps.length}`, inputDependencies: ["rank"] },
          getShaderSource,
          getRunData: () => ({
            outputs: [outputTensorInfo],
            dispatchGroup: { x: Math.ceil(
              inputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          })
        };
      };
      slice = (context, attributes) => {
        validateInputs28(context.inputs, attributes);
        const updatedAttributes = createSliceAttributesFromInputs(context.inputs, attributes);
        context.compute(createSliceProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });
      };
      parseSliceAttributes = (attributes) => {
        const starts = attributes.starts;
        const ends = attributes.ends;
        const axes = attributes.axes;
        return createAttributeWithCacheKey({ starts, ends, axes });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/softmax.ts
  var validateInputs29, createSoftmaxProgramInfo, softmax, parseSoftmaxAttributes;
  var init_softmax = __esm({
    "web/lib/wasm/jsep/webgpu/ops/softmax.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs29 = (inputs) => {
        if (!inputs || inputs.length !== 1) {
          throw new Error("Softmax op requires 1 input.");
        }
      };
      createSoftmaxProgramInfo = (input, attributes) => {
        const shape = input.dims;
        const outputSize = ShapeUtil.size(shape);
        const WG = 64;
        let axis = attributes.axis;
        if (axis < 0) {
          axis = shape.length + axis;
        }
        if (axis < shape.length - 1) {
          throw new Error("softmax only supports last axis for now.");
        }
        const cols = shape[axis];
        const rows = outputSize / cols;
        const components = getMaxComponents(cols);
        const packedCols = cols / components;
        const maxVector = (name, components2) => {
          if (components2 === 4) {
            return `max(max(${name}.x, ${name}.y), max(${name}.z, ${name}.w))`;
          } else if (components2 === 2) {
            return `max(${name}.x, ${name}.y)`;
          } else if (components2 === 3) {
            return `max(max(${name}.x, ${name}.y), ${name}.z)`;
          }
          return name;
        };
        const x = inputVariable("x", input.dataType, input.dims, components);
        const output = outputVariable("result", input.dataType, input.dims, components);
        const valueType = x.type.value;
        const threadMaxDecl = tensorTypeToWsglStorageType(input.dataType) === "f32" ? `var threadMax = ${valueType}(-3.402823e+38f);` : `var threadMax = ${valueType}(-65504.0h);`;
        const getShaderSource = (shaderHelper) => `
      var<workgroup> rowMaxShared : ${valueType};
      var<workgroup> rowSumShared : ${valueType};
      var<workgroup> threadShared : array<${valueType}, ${WG}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${valueType} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${valueType}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${shaderHelper.registerUniform("packedCols", "i32").declareVariables(x, output)}
      ${shaderHelper.mainStart()}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${WG};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${threadMaxDecl}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${valueType}(${maxVector("threadShared[0]", components)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${valueType}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${valueType}(${sumVector("threadShared[0]", components)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`;
        return {
          name: "Softmax",
          shaderCache: { hint: `${components}`, inputDependencies: ["type"] },
          getRunData: () => ({
            outputs: [{ dims: shape, dataType: input.dataType }],
            dispatchGroup: { x: rows },
            programUniforms: [{ type: 6 /* int32 */, data: packedCols }]
          }),
          getShaderSource
        };
      };
      softmax = (context, attributes) => {
        validateInputs29(context.inputs);
        context.compute(createSoftmaxProgramInfo(context.inputs[0], attributes));
      };
      parseSoftmaxAttributes = (attributes) => createAttributeWithCacheKey({ axis: attributes.axis });
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/split.ts
  var validateInputs30, createSplitAttributesFromInputs, calculateOutputIndexImpl, writeBufferDataImpl, createSplitProgramInfo, split, parseSplitAttributes;
  var init_split = __esm({
    "web/lib/wasm/jsep/webgpu/ops/split.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_attribute_with_cache_key();
      init_common();
      validateInputs30 = (inputs) => {
        if (!inputs || inputs.length < 1) {
          throw new Error("too few inputs");
        }
      };
      createSplitAttributesFromInputs = (inputs, attributes) => {
        const splitSizes = [];
        let numOutputs = attributes.numOutputs;
        if (inputs[1].dims[0] > 0) {
          inputs[1].getBigInt64Array().forEach((v) => splitSizes.push(Number(v)));
          numOutputs = splitSizes.length;
        }
        return createAttributeWithCacheKey({ numOutputs, axis: attributes.axis, splitSizes });
      };
      calculateOutputIndexImpl = (numberOfTensors) => `
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${numberOfTensors}u; i += 1u ) {
    if (index < ${getElementAt("uniforms.size_in_split_axis", "i", numberOfTensors)}) {
        return i;
    }
    }
    return ${numberOfTensors}u;
}`;
      writeBufferDataImpl = (outputs) => {
        const numberOfTensors = outputs.length;
        const codeLines = [];
        for (let i = 0; i < numberOfTensors; ++i) {
          const returnSnippet = outputs[i].setByIndices("indices", "input[global_idx]");
          if (numberOfTensors === 1) {
            codeLines.push(returnSnippet);
          } else if (i === 0) {
            codeLines.push(`if (output_number == ${i}u) { ${returnSnippet} }`);
          } else if (i === numberOfTensors - 1) {
            codeLines.push(`else { ${returnSnippet} }`);
          } else {
            codeLines.push(`else if (output_number == ${i}) { ${returnSnippet} }`);
          }
        }
        return `
      fn writeBufferData(output_number: u32, indices: ${outputs[0].type.indices}, global_idx: u32) {
        ${codeLines.join("\n")}
      }`;
      };
      createSplitProgramInfo = (inputs, attributes) => {
        const inputShape = inputs[0].dims;
        const inputSize = ShapeUtil.size(inputShape);
        const dataType = inputs[0].dataType;
        const axis = ShapeUtil.normalizeAxis(attributes.axis, inputShape.length);
        const outputs = new Array(attributes.numOutputs);
        const input = inputVariable("input", dataType, inputShape.length);
        const sizeInSplitAxis = new Array(attributes.numOutputs);
        const outputsTensorInfo = [];
        const outputShapes = [];
        let previousSum = 0;
        const programUniforms = [{ type: 12 /* uint32 */, data: inputSize }];
        for (let i = 0; i < attributes.numOutputs; i++) {
          previousSum += attributes.splitSizes[i];
          sizeInSplitAxis[i] = previousSum;
          const outputShape = inputShape.slice();
          outputShape[axis] = attributes.splitSizes[i];
          outputShapes.push(outputShape);
          outputs[i] = outputVariable(`output${i}`, dataType, outputShape.length);
          outputsTensorInfo.push({ dims: outputShapes[i], dataType: inputs[0].dataType });
        }
        programUniforms.push(
          { type: 12 /* uint32 */, data: sizeInSplitAxis },
          ...createTensorShapeVariables(inputShape, ...outputShapes)
        );
        const getShaderSource = (shaderHelper) => `
  ${shaderHelper.registerUniform("input_size", "u32").registerUniform("size_in_split_axis", "u32", sizeInSplitAxis.length).declareVariables(input, ...outputs)}
  ${calculateOutputIndexImpl(sizeInSplitAxis.length)}
  ${writeBufferDataImpl(outputs)}

  ${shaderHelper.mainStart()}
    ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${input.offsetToIndices("global_idx")};
    var index = ${input.indicesGet("indices", axis)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${getElementAt("uniforms.size_in_split_axis", "output_number - 1u", sizeInSplitAxis.length)};
      ${input.indicesSet("indices", axis, "index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;
        return {
          name: "Split",
          shaderCache: { hint: attributes.cacheKey, inputDependencies: ["rank"] },
          getShaderSource,
          getRunData: () => ({
            outputs: outputsTensorInfo,
            dispatchGroup: { x: Math.ceil(
              inputSize / 64
              /* workgroup size */
            ) },
            programUniforms
          })
        };
      };
      split = (context, attributes) => {
        validateInputs30(context.inputs);
        const updatedAttributes = context.inputs.length === 1 ? attributes : createSplitAttributesFromInputs(context.inputs, attributes);
        context.compute(createSplitProgramInfo(context.inputs, updatedAttributes), { inputs: [0] });
      };
      parseSplitAttributes = (attributes) => {
        const axis = attributes.axis;
        const splitSizes = attributes.splitSizes;
        const numOutputs = attributes.numOutputs < 0 ? splitSizes.length : attributes.numOutputs;
        if (numOutputs !== splitSizes.length) {
          throw new Error("numOutputs and splitSizes lengh must be equal");
        }
        return createAttributeWithCacheKey({ axis, numOutputs, splitSizes });
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/ops/where.ts
  var createWhereOpProgramShader, createWhereOpProgramInfo, where;
  var init_where = __esm({
    "web/lib/wasm/jsep/webgpu/ops/where.ts"() {
      "use strict";
      init_wasm_common();
      init_util();
      init_common();
      createWhereOpProgramShader = (shaderHelper, inputs, dimsOutput, isBroadcast, typeOutput) => {
        const output = outputVariable("output_data", typeOutput, dimsOutput.length, 4);
        const a = inputVariable("a_data", inputs[1].dataType, inputs[1].dims.length, 4);
        const b = inputVariable("b_data", inputs[2].dataType, inputs[2].dims.length, 4);
        const c = inputVariable("c_data", inputs[0].dataType, inputs[0].dims.length, 4);
        let assignment;
        const expression = (a2, b2, c2) => `select(${b2}, ${a2}, ${c2})`;
        if (!isBroadcast) {
          assignment = output.setByOffset(
            "global_idx",
            expression(a.getByOffset("global_idx"), b.getByOffset("global_idx"), c.getByOffset("global_idx"))
          );
        } else {
          const singleAssignment = (resStr, x, typeCast = "") => {
            const expressionA = `a_data[index_a${x}][component_a${x}]`;
            const expressionB = `b_data[index_b${x}][component_b${x}]`;
            const expressionC = `bool(c_data[index_c${x}] & (0xffu << (component_c${x} * 8)))`;
            return `
            let output_indices${x} = ${output.offsetToIndices(`global_idx * 4u + ${x}u`)};
            let offset_a${x} = ${a.broadcastedIndicesToOffset(`output_indices${x}`, output)};
            let offset_b${x} = ${b.broadcastedIndicesToOffset(`output_indices${x}`, output)};
            let offset_c${x} = ${c.broadcastedIndicesToOffset(`output_indices${x}`, output)};
            let index_a${x} = offset_a${x} / 4u;
            let index_b${x} = offset_b${x} / 4u;
            let index_c${x} = offset_c${x} / 4u;
            let component_a${x} = offset_a${x} % 4u;
            let component_b${x} = offset_b${x} % 4u;
            let component_c${x} = offset_c${x} % 4u;
            ${resStr}[${x}] = ${typeCast}(${expression(expressionA, expressionB, expressionC)});
          `;
          };
          if (typeOutput === 9 /* bool */) {
            assignment = `
            var data = vec4<u32>(0);
            ${singleAssignment("data", 0, "u32")}
            ${singleAssignment("data", 1, "u32")}
            ${singleAssignment("data", 2, "u32")}
            ${singleAssignment("data", 3, "u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`;
          } else {
            assignment = `
            ${singleAssignment("output_data[global_idx]", 0)}
            ${singleAssignment("output_data[global_idx]", 1)}
            ${singleAssignment("output_data[global_idx]", 2)}
            ${singleAssignment("output_data[global_idx]", 3)}
          `;
          }
        }
        return `
        ${shaderHelper.registerUniform("vec_size", "u32").declareVariables(c, a, b, output)}
        ${shaderHelper.mainStart()}
        ${shaderHelper.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${assignment}
      }`;
      };
      createWhereOpProgramInfo = (inputs) => {
        const dimsA = inputs[1].dims;
        const dimsB = inputs[2].dims;
        const dimsC = inputs[0].dims;
        const outputDataType = inputs[1].dataType;
        const isBroadcast = !(ShapeUtil.areEqual(dimsA, dimsB) && ShapeUtil.areEqual(dimsB, dimsC));
        let outputShape = dimsA;
        let outputSize = ShapeUtil.size(dimsA);
        if (isBroadcast) {
          const calculatedShape = BroadcastUtil.calcShape(BroadcastUtil.calcShape(dimsA, dimsB, false), dimsC, false);
          if (!calculatedShape) {
            throw new Error("Can't perform where op on the given tensors");
          }
          outputShape = calculatedShape;
          outputSize = ShapeUtil.size(outputShape);
        }
        const vecSize = Math.ceil(outputSize / 4);
        return {
          name: "Where",
          shaderCache: { inputDependencies: ["rank", "rank", "rank"] },
          getShaderSource: (shaderHelper) => createWhereOpProgramShader(shaderHelper, inputs, outputShape, isBroadcast, outputDataType),
          getRunData: () => ({
            outputs: [{ dims: outputShape, dataType: outputDataType }],
            dispatchGroup: { x: Math.ceil(
              outputSize / 64 / 4
              /* vec size */
            ) },
            programUniforms: [
              { type: 12 /* uint32 */, data: vecSize },
              ...createTensorShapeVariables(dimsC, dimsA, dimsB, outputShape)
            ]
          })
        };
      };
      where = (context) => {
        context.compute(createWhereOpProgramInfo(context.inputs));
      };
    }
  });

  // web/lib/wasm/jsep/webgpu/op-resolve-rules.ts
  var WEBGPU_OP_RESOLVE_RULES;
  var init_op_resolve_rules = __esm({
    "web/lib/wasm/jsep/webgpu/op-resolve-rules.ts"() {
      "use strict";
      init_argminmax();
      init_attention();
      init_batch_norm();
      init_bias_add();
      init_bias_split_gelu();
      init_binary_op();
      init_concat();
      init_conv();
      init_conv_transpose();
      init_cumsum();
      init_depth_to_space();
      init_einsum();
      init_expand();
      init_fast_gelu();
      init_gather();
      init_gather_block_quantized();
      init_gather_elements();
      init_gemm();
      init_group_query_attention();
      init_instance_norm();
      init_layer_norm();
      init_matmul();
      init_matmulnbits();
      init_multihead_attention();
      init_pad();
      init_pool();
      init_quantize_linear();
      init_range();
      init_reduce();
      init_resize();
      init_rotary_embedding();
      init_skip_layer_norm();
      init_slice();
      init_softmax();
      init_split();
      init_tile();
      init_transpose();
      init_unary_op();
      init_where();
      WEBGPU_OP_RESOLVE_RULES = /* @__PURE__ */ new Map([
        ["Abs", [abs]],
        ["Acos", [acos]],
        ["Acosh", [acosh]],
        ["Add", [add]],
        ["ArgMax", [argMax, parseArgMinMaxAttributes]],
        ["ArgMin", [argMin, parseArgMinMaxAttributes]],
        ["Asin", [asin]],
        ["Asinh", [asinh]],
        ["Atan", [atan]],
        ["Atanh", [atanh]],
        ["Attention", [attention]],
        // TODO: support new attributes for AveragePool-10
        ["AveragePool", [averagePool, parseAveragePoolAttributes]],
        ["BatchNormalization", [batchNorm]],
        ["BiasAdd", [biasAdd]],
        ["BiasSplitGelu", [biasSplitGelu]],
        ["Cast", [cast, parseCastAttributes]],
        ["Ceil", [ceil]],
        ["Clip", [clip]],
        ["Concat", [concat, parseConcatAttributes]],
        ["Conv", [conv, parseConvAttributes]],
        ["ConvTranspose", [convTranspose, parseConvTransposeAttributes]],
        ["Cos", [cos]],
        ["Cosh", [cosh]],
        ["CumSum", [cumsum, parseCumSumAttributes]],
        ["DepthToSpace", [depthToSpace, parseDepthToSpaceAttributes]],
        ["DequantizeLinear", [dequantizeLinear, parseDequantizeLinearAttributes]],
        ["Div", [div]],
        ["Einsum", [einsum, parseEinsumAttributes]],
        ["Elu", [elu, parseAlphaAttributes]],
        ["Equal", [equal]],
        ["Erf", [erf]],
        ["Exp", [exp]],
        ["Expand", [expand]],
        ["FastGelu", [fastGelu2]],
        ["Floor", [floor]],
        ["FusedConv", [conv, parseConvAttributes]],
        ["Gather", [gather, parseGatherAttributes]],
        ["GatherElements", [gatherElements, parseGatherElementsAttributes]],
        ["GatherBlockQuantized", [gatherBlockQuantized, parseGatherBlockQuantizedAttributes]],
        ["Gelu", [gelu]],
        ["Gemm", [gemm, parseGemmAttributes]],
        ["GlobalAveragePool", [globalAveragePool, parseGlobalAveragePoolAttributes]],
        ["GlobalMaxPool", [globalMaxPool, parseGlobalMaxPoolAttributes]],
        ["Greater", [greater]],
        ["GreaterOrEqual", [greaterOrEqual]],
        ["GroupQueryAttention", [groupQueryAttention, parseGroupQueryAttentionAttributes]],
        ["HardSigmoid", [hardSigmoid, parseHardSigmoidAttributes]],
        ["InstanceNormalization", [instanceNorm]],
        ["LayerNormalization", [layerNorm]],
        ["LeakyRelu", [leakyRelu, parseAlphaAttributes]],
        ["Less", [less]],
        ["LessOrEqual", [lessOrEqual]],
        ["Log", [log]],
        ["MatMul", [matMul]],
        ["MatMulNBits", [matMulNBits, parseMatMulNBitsAttributes]],
        // TODO: support new attributes for MaxPool-8 and MaxPool-10
        ["MaxPool", [maxPool, parseMaxPoolAttributes]],
        ["Mul", [mul]],
        ["MultiHeadAttention", [multiHeadAttention, parseMultiHeadAttentionAttributes]],
        ["Neg", [neg]],
        ["Not", [not]],
        ["Pad", [pad]],
        ["Pow", [pow]],
        ["QuickGelu", [quickgelu, parseAlphaAttributes]],
        ["Range", [range]],
        ["Reciprocal", [reciprocal]],
        ["ReduceMin", [reduceMin]],
        ["ReduceMean", [reduceMean]],
        ["ReduceMax", [reduceMax]],
        ["ReduceSum", [reduceSum]],
        ["ReduceProd", [reduceProd]],
        ["ReduceL1", [reduceL1]],
        ["ReduceL2", [reduceL2]],
        ["ReduceLogSum", [reduceLogSum]],
        ["ReduceLogSumExp", [reduceLogSumExp]],
        ["ReduceSumSquare", [reduceSumSquare]],
        ["Relu", [relu]],
        ["Resize", [resize, parseResizeAttributes]],
        ["RotaryEmbedding", [rotaryEmbedding]],
        ["Sigmoid", [sigmoid]],
        ["Sin", [sin]],
        ["Sinh", [sinh]],
        ["Slice", [slice, parseSliceAttributes]],
        ["SkipLayerNormalization", [skipLayerNorm]],
        ["Split", [split, parseSplitAttributes]],
        ["Sqrt", [sqrt]],
        ["Softmax", [softmax, parseSoftmaxAttributes]],
        ["Sub", [sub]],
        ["Tan", [tan]],
        ["Tanh", [tanh]],
        ["ThresholdedRelu", [thresholdedRelu, parseAlphaAttributes]],
        ["Tile", [tile]],
        ["Transpose", [transpose, parseTransposeAttributes]],
        ["Where", [where]]
      ]);
    }
  });

  // web/lib/wasm/jsep/webgpu/program-manager.ts
  var ProgramManager;
  var init_program_manager = __esm({
    "web/lib/wasm/jsep/webgpu/program-manager.ts"() {
      "use strict";
      init_esm();
      init_log();
      init_common();
      ProgramManager = class {
        constructor(backend) {
          this.backend = backend;
          this.repo = /* @__PURE__ */ new Map();
          this.attributesBound = false;
        }
        getArtifact(key) {
          return this.repo.get(key);
        }
        setArtifact(key, artifact) {
          this.repo.set(key, artifact);
        }
        run(buildArtifact, inputs, outputs, dispatchGroup, uniformBufferBinding) {
          TRACE_FUNC_BEGIN(buildArtifact.programInfo.name);
          const device = this.backend.device;
          const computePassEncoder = this.backend.getComputePassEncoder();
          this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2);
          const entries = [];
          for (const input of inputs) {
            entries.push({ binding: entries.length, resource: { buffer: input.buffer } });
          }
          for (const output of outputs) {
            entries.push({ binding: entries.length, resource: { buffer: output.buffer } });
          }
          if (uniformBufferBinding) {
            entries.push({ binding: entries.length, resource: uniformBufferBinding });
          }
          const bindGroup = device.createBindGroup({
            layout: buildArtifact.computePipeline.getBindGroupLayout(0),
            entries,
            label: buildArtifact.programInfo.name
          });
          if (this.backend.sessionStatus === "capturing") {
            const commandInfo = {
              kernelId: this.backend.currentKernelId,
              computePipeline: buildArtifact.computePipeline,
              bindGroup,
              dispatchGroup
            };
            const sessionCommandList = this.backend.capturedCommandList.get(this.backend.currentSessionId);
            sessionCommandList.push(commandInfo);
          }
          computePassEncoder.setPipeline(buildArtifact.computePipeline);
          computePassEncoder.setBindGroup(0, bindGroup);
          computePassEncoder.dispatchWorkgroups(...dispatchGroup);
          this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2 + 1);
          this.backend.pendingDispatchNumber++;
          if (this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber || this.backend.queryType === "at-passes") {
            this.backend.endComputePass();
          }
          if (this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber) {
            this.backend.flush();
          }
          TRACE_FUNC_END(buildArtifact.programInfo.name);
        }
        dispose() {
        }
        build(programInfo, normalizedDispatchGroupSize) {
          TRACE_FUNC_BEGIN(programInfo.name);
          const device = this.backend.device;
          const extensions = [];
          if (device.features.has("shader-f16")) {
            extensions.push("enable f16;");
          }
          const shaderHelper = createShaderHelper(normalizedDispatchGroupSize, this.backend.device.limits);
          const userCode = programInfo.getShaderSource(shaderHelper);
          const code = `${extensions.join("\n")}
${shaderHelper.additionalImplementations}
${userCode}`;
          const shaderModule = device.createShaderModule({ code, label: programInfo.name });
          LOG_DEBUG("verbose", () => `[WebGPU] ${programInfo.name} shader code: ${code}`);
          const computePipeline = device.createComputePipeline({
            compute: { module: shaderModule, entryPoint: "main" },
            layout: "auto",
            label: programInfo.name
          });
          TRACE_FUNC_END(programInfo.name);
          return { programInfo, computePipeline, uniformVariablesInfo: shaderHelper.variablesInfo };
        }
        normalizeDispatchGroupSize(dispatchGroup) {
          const x = typeof dispatchGroup === "number" ? dispatchGroup : dispatchGroup.x;
          const y = typeof dispatchGroup === "number" ? 1 : dispatchGroup.y || 1;
          const z = typeof dispatchGroup === "number" ? 1 : dispatchGroup.z || 1;
          const limitPerDimension = this.backend.device.limits.maxComputeWorkgroupsPerDimension;
          if (x <= limitPerDimension && y <= limitPerDimension && z <= limitPerDimension) {
            return [x, y, z];
          }
          const size = x * y * z;
          let dispatchAverage = Math.ceil(Math.sqrt(size));
          if (dispatchAverage > limitPerDimension) {
            dispatchAverage = Math.ceil(Math.cbrt(size));
            if (dispatchAverage > limitPerDimension) {
              throw new Error("Total dispatch size exceeds WebGPU maximum.");
            }
            return [dispatchAverage, dispatchAverage, dispatchAverage];
          } else {
            return [dispatchAverage, dispatchAverage, 1];
          }
        }
      };
    }
  });

  // web/lib/wasm/jsep/backend-webgpu.ts
  var getProgramInputTensorInfoDependencyKey, getProgramInfoUniqueKey, AdapterInfoImpl, WebGpuBackend;
  var init_backend_webgpu = __esm({
    "web/lib/wasm/jsep/backend-webgpu.ts"() {
      "use strict";
      init_esm();
      init_wasm_common();
      init_log();
      init_tensor_view();
      init_gpu_data_manager();
      init_op_resolve_rules();
      init_program_manager();
      getProgramInputTensorInfoDependencyKey = (inputTensors, inputDependencies) => {
        if (inputDependencies.length !== inputTensors.length) {
          throw new Error(
            `inputDependencies length ${inputDependencies.length} is not equal to inputTensors length ${inputTensors.length}.`
          );
        }
        const inputInfos = [];
        for (let i = 0; i < inputTensors.length; ++i) {
          const type = inputTensors[i].dataType;
          switch (inputDependencies[i]) {
            case "none": {
              inputInfos.push("");
              break;
            }
            case "type": {
              inputInfos.push(`${type}`);
              break;
            }
            case "rank": {
              const rank = inputTensors[i].dims.length;
              inputInfos.push(`${type};${rank}`);
              break;
            }
            case "dims": {
              const dims = inputTensors[i].dims.join(",");
              inputInfos.push(`${type};${dims}`);
              break;
            }
            default:
              throw new Error(`unsupported input dependency: ${inputDependencies[i]}`);
          }
        }
        return inputInfos.join("|");
      };
      getProgramInfoUniqueKey = (programInfo, inputTensors, is1DimensionDispatch) => {
        let key = programInfo.name;
        if (programInfo.shaderCache?.hint) {
          key += "[" + programInfo.shaderCache.hint + "]";
        }
        key += ":" + is1DimensionDispatch + `:${getProgramInputTensorInfoDependencyKey(
          inputTensors,
          programInfo.shaderCache?.inputDependencies ?? new Array(inputTensors.length).fill("dims")
        )}`;
        return key;
      };
      AdapterInfoImpl = class {
        constructor(adapterInfo) {
          if (adapterInfo) {
            this.architecture = adapterInfo.architecture;
            this.vendor = adapterInfo.vendor;
          }
        }
        isArchitecture(architecture) {
          return this.architecture === architecture;
        }
        isVendor(vendor) {
          return this.vendor === vendor;
        }
      };
      WebGpuBackend = class {
        constructor() {
          /**
           * representing the session ID of which is currently being run.
           * `null` means no session is being run.
           * only valid when session.run is executed.
           */
          this.currentSessionId = null;
          /**
           * representing the kernel ID of which is currently being computed (CPU code perspective).
           * `null` means no kernel is being computed.
           * only one kernel can be computed at a moment.
           */
          this.currentKernelId = null;
          this.commandEncoder = null;
          this.computePassEncoder = null;
          this.maxDispatchNumber = 16;
          this.pendingDispatchNumber = 0;
          // info of kernels pending submission for a single batch
          this.pendingKernels = [];
          // queryReadBuffer -> pendingKernels mapping for all the batches
          this.pendingQueries = /* @__PURE__ */ new Map();
          this.sessionStatus = "default";
          /**
           * a SessionID -> CommandInfo[] mapping. It's used to record all GPU commands for corresponding session.
           */
          this.capturedCommandList = /* @__PURE__ */ new Map();
          /**
           * a SessionID -> PendingKernelInfo[] mapping for profiling.
           */
          this.capturedPendingKernels = /* @__PURE__ */ new Map();
          /**
           * a SessionID -> a Map of (InputOutputIndex -> [ID, GPUBuffer]) mapping.
           */
          this.sessionExternalDataMapping = /* @__PURE__ */ new Map();
        }
        /**
         * get the custom data of the current kernel
         */
        get currentKernelCustomData() {
          if (this.currentKernelId === null) {
            throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");
          }
          let data = this.kernelCustomData.get(this.currentKernelId);
          if (!data) {
            data = {};
            this.kernelCustomData.set(this.currentKernelId, data);
          }
          return data;
        }
        async initialize(env3, adapter) {
          this.env = env3;
          const requiredFeatures = [];
          const deviceDescriptor = {
            requiredLimits: {
              maxComputeWorkgroupStorageSize: adapter.limits.maxComputeWorkgroupStorageSize,
              maxComputeWorkgroupsPerDimension: adapter.limits.maxComputeWorkgroupsPerDimension,
              maxStorageBufferBindingSize: adapter.limits.maxStorageBufferBindingSize,
              maxBufferSize: adapter.limits.maxBufferSize,
              maxComputeInvocationsPerWorkgroup: adapter.limits.maxComputeInvocationsPerWorkgroup,
              maxComputeWorkgroupSizeX: adapter.limits.maxComputeWorkgroupSizeX,
              maxComputeWorkgroupSizeY: adapter.limits.maxComputeWorkgroupSizeY,
              maxComputeWorkgroupSizeZ: adapter.limits.maxComputeWorkgroupSizeZ
            },
            requiredFeatures
          };
          if (adapter.features.has("chromium-experimental-timestamp-query-inside-passes")) {
            requiredFeatures.push("chromium-experimental-timestamp-query-inside-passes");
          } else if (adapter.features.has("timestamp-query")) {
            requiredFeatures.push("timestamp-query");
          }
          if (adapter.features.has("shader-f16")) {
            requiredFeatures.push("shader-f16");
          }
          this.device = await adapter.requestDevice(deviceDescriptor);
          this.adapterInfo = new AdapterInfoImpl(adapter.info || await adapter.requestAdapterInfo());
          this.gpuDataManager = createGpuDataManager(this);
          this.programManager = new ProgramManager(this);
          this.kernels = /* @__PURE__ */ new Map();
          this.kernelPersistentData = /* @__PURE__ */ new Map();
          this.kernelCustomData = /* @__PURE__ */ new Map();
          configureLogger(env3.logLevel, !!env3.debug);
          this.device.onuncapturederror = (ev) => {
            if (ev.error instanceof GPUValidationError) {
              console.error(`An uncaught WebGPU validation error was raised: ${ev.error.message}`);
            }
          };
          Object.defineProperty(this.env.webgpu, "device", {
            value: this.device,
            writable: false,
            enumerable: true,
            configurable: false
          });
          Object.defineProperty(this.env.webgpu, "adapter", {
            value: adapter,
            writable: false,
            enumerable: true,
            configurable: false
          });
          this.setQueryType();
        }
        dispose() {
          if (typeof this.querySet !== "undefined") {
            this.querySet.destroy();
          }
          this.gpuDataManager.dispose();
        }
        getCommandEncoder() {
          if (!this.commandEncoder) {
            this.commandEncoder = this.device.createCommandEncoder();
          }
          return this.commandEncoder;
        }
        getComputePassEncoder() {
          if (!this.computePassEncoder) {
            const commandEncoder = this.getCommandEncoder();
            const computePassDescriptor = {};
            if (this.queryType === "at-passes") {
              computePassDescriptor.timestampWrites = {
                querySet: this.querySet,
                beginningOfPassWriteIndex: this.pendingDispatchNumber * 2,
                endOfPassWriteIndex: this.pendingDispatchNumber * 2 + 1
              };
            }
            this.computePassEncoder = commandEncoder.beginComputePass(computePassDescriptor);
          }
          return this.computePassEncoder;
        }
        endComputePass() {
          if (this.computePassEncoder) {
            this.computePassEncoder.end();
            this.computePassEncoder = null;
          }
        }
        flush() {
          if (!this.commandEncoder) {
            return;
          }
          TRACE_FUNC_BEGIN();
          this.endComputePass();
          let queryReadBuffer;
          if (this.queryType !== "none") {
            this.commandEncoder.resolveQuerySet(
              this.querySet,
              0,
              this.pendingDispatchNumber * 2,
              this.queryResolveBuffer,
              0
            );
            queryReadBuffer = this.device.createBuffer(
              // eslint-disable-next-line no-bitwise
              { size: this.pendingDispatchNumber * 2 * 8, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST }
            );
            this.pendingQueries.set(queryReadBuffer, this.pendingKernels);
            this.pendingKernels = [];
            this.commandEncoder.copyBufferToBuffer(
              this.queryResolveBuffer,
              0,
              queryReadBuffer,
              0,
              this.pendingDispatchNumber * 2 * 8
            );
          }
          this.device.queue.submit([this.commandEncoder.finish()]);
          this.gpuDataManager.refreshPendingBuffers();
          this.commandEncoder = null;
          this.pendingDispatchNumber = 0;
          if (this.queryType !== "none") {
            void queryReadBuffer.mapAsync(GPUMapMode.READ).then(() => {
              const mappedData = new BigUint64Array(queryReadBuffer.getMappedRange());
              const pendingKernels = this.pendingQueries.get(queryReadBuffer);
              for (let i = 0; i < mappedData.length / 2; i++) {
                const pendingKernelInfo = pendingKernels[i];
                const kernelId = pendingKernelInfo.kernelId;
                const kernelInfo = this.kernels.get(kernelId);
                const kernelType = kernelInfo.kernelType;
                const kernelName = kernelInfo.kernelName;
                const programName = pendingKernelInfo.programName;
                const inputTensorViews = pendingKernelInfo.inputTensorViews;
                const outputTensorViews = pendingKernelInfo.outputTensorViews;
                const startTimeU64 = mappedData[i * 2];
                const endTimeU64 = mappedData[i * 2 + 1];
                if (typeof this.queryTimeBase === "undefined") {
                  this.queryTimeBase = startTimeU64;
                }
                const startTime = Number(startTimeU64 - this.queryTimeBase);
                const endTime = Number(endTimeU64 - this.queryTimeBase);
                if (!Number.isSafeInteger(startTime) || !Number.isSafeInteger(endTime)) {
                  throw new RangeError("incorrect timestamp range");
                }
                if (this.env.webgpu.profiling?.ondata) {
                  this.env.webgpu.profiling.ondata({
                    version: 1,
                    inputsMetadata: inputTensorViews.map((value) => ({
                      dims: value.dims,
                      dataType: tensorDataTypeEnumToString(value.dataType)
                    })),
                    outputsMetadata: outputTensorViews.map((value) => ({
                      dims: value.dims,
                      dataType: tensorDataTypeEnumToString(value.dataType)
                    })),
                    kernelId,
                    kernelType,
                    kernelName,
                    programName,
                    startTime,
                    endTime
                  });
                } else {
                  let inputShapes = "";
                  inputTensorViews.forEach((value, i2) => {
                    inputShapes += `input[${i2}]: [${value.dims}] | ${tensorDataTypeEnumToString(value.dataType)}, `;
                  });
                  let outputShapes = "";
                  outputTensorViews.forEach((value, i2) => {
                    outputShapes += `output[${i2}]: [${value.dims}] | ${tensorDataTypeEnumToString(value.dataType)}, `;
                  });
                  console.log(
                    `[profiling] kernel "${kernelId}|${kernelType}|${kernelName}|${programName}" ${inputShapes}${outputShapes}execution time: ${endTime - startTime} ns`
                  );
                }
                TRACE("GPU", `${programName}::${startTimeU64}::${endTimeU64}`);
              }
              queryReadBuffer.unmap();
              this.pendingQueries.delete(queryReadBuffer);
            });
          }
          TRACE_FUNC_END();
        }
        /**
         * run a WebGPU program.
         * @param program a ProgramInfo instance
         * @param inputTensorViews a TensorView array. each element represents a value already exists in GPU.
         * @param outputIndices an indices array. each element can be either -1 (temporary data), -2 (persistent data) or an
         * index to the kernel's output.
         * @param createKernelOutput a callback function that create a value to kernel's output with the given index
         * @param createIntermediateOutput a callback function that create a value as a intermediate value, either temporary
         * or persistent (owned by the current kernel)
         * @returns a TensorView array representing the result.
         */
        run(program, inputTensorViews, outputIndices, createKernelOutput, createIntermediateOutput, outputCount) {
          TRACE_FUNC_BEGIN(program.name);
          const inputDatas = [];
          for (let i = 0; i < inputTensorViews.length; ++i) {
            const data = inputTensorViews[i].data;
            if (data === 0) {
              continue;
            }
            const gpuData = this.gpuDataManager.get(data);
            if (!gpuData) {
              throw new Error(`no GPU data for input: ${data}`);
            }
            inputDatas.push(gpuData);
          }
          const { outputs, dispatchGroup, programUniforms } = program.getRunData(inputTensorViews);
          const validatedOutputIndices = outputIndices.length === 0 ? outputs.map((_, i) => i) : outputIndices;
          if (validatedOutputIndices.length !== outputs.length) {
            throw new Error(`Output size ${validatedOutputIndices.length} must be equal to ${outputs.length}.`);
          }
          const outputTensorViews = [];
          const outputDatas = [];
          for (let i = 0; i < outputs.length; ++i) {
            if (!Number.isInteger(validatedOutputIndices[i]) || validatedOutputIndices[i] < -3 || validatedOutputIndices[i] >= outputCount) {
              throw new Error(`Invalid output index: ${validatedOutputIndices[i]}`);
            }
            if (validatedOutputIndices[i] === -3) {
              continue;
            }
            const isTemporary = validatedOutputIndices[i] === -1;
            const isPersistent = validatedOutputIndices[i] === -2;
            const tensorView = isTemporary || isPersistent ? createIntermediateOutput(outputs[i].dataType, outputs[i].dims) : createKernelOutput(validatedOutputIndices[i], outputs[i].dataType, outputs[i].dims);
            outputTensorViews.push(tensorView);
            if (tensorView.data === 0) {
              continue;
            }
            const gpuData = this.gpuDataManager.get(tensorView.data);
            if (!gpuData) {
              throw new Error(`no GPU data for output: ${tensorView.data}`);
            }
            if (isTemporary) {
              this.temporaryData.push(gpuData);
            }
            if (isPersistent) {
              let persistentData = this.kernelPersistentData.get(this.currentKernelId);
              if (!persistentData) {
                persistentData = [];
                this.kernelPersistentData.set(this.currentKernelId, persistentData);
              }
              persistentData.push(gpuData);
            }
            outputDatas.push(gpuData);
          }
          if (inputDatas.length !== inputTensorViews.length || outputDatas.length !== outputTensorViews.length) {
            if (outputDatas.length === 0) {
              TRACE_FUNC_END(program.name);
              return outputTensorViews;
            }
            throw new Error(
              `Program ${program.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`
            );
          }
          let uniformBufferBinding;
          if (programUniforms) {
            let currentOffset = 0;
            const offsets = [];
            programUniforms.forEach((v) => {
              const data = typeof v.data === "number" ? [v.data] : v.data;
              if (data.length === 0) {
                return;
              }
              const sizeOfElement = v.type === 10 /* float16 */ ? 2 : 4;
              let sizeOfVecOrMat;
              let baseAlignment;
              if (v.type === 10 /* float16 */) {
                baseAlignment = data.length > 4 ? 16 : data.length > 2 ? 8 : data.length * sizeOfElement;
                sizeOfVecOrMat = data.length > 4 ? 16 : sizeOfElement * data.length;
              } else {
                baseAlignment = data.length <= 2 ? data.length * sizeOfElement : 16;
                sizeOfVecOrMat = 16;
              }
              currentOffset = Math.ceil(currentOffset / baseAlignment) * baseAlignment;
              offsets.push(currentOffset);
              const elementPerVecOrMat = v.type === 10 /* float16 */ ? 8 : 4;
              currentOffset += data.length > 4 ? Math.ceil(data.length / elementPerVecOrMat) * sizeOfVecOrMat : data.length * sizeOfElement;
            });
            const maxAlignmentOfField = 16;
            currentOffset = Math.ceil(currentOffset / maxAlignmentOfField) * maxAlignmentOfField;
            const arrayBuffer = new ArrayBuffer(currentOffset);
            programUniforms.forEach((v, i) => {
              const offset = offsets[i];
              const data = typeof v.data === "number" ? [v.data] : v.data;
              if (v.type === 6 /* int32 */) {
                new Int32Array(arrayBuffer, offset, data.length).set(data);
              } else if (v.type === 12 /* uint32 */) {
                new Uint32Array(arrayBuffer, offset, data.length).set(data);
              } else if (v.type === 10 /* float16 */) {
                new Uint16Array(arrayBuffer, offset, data.length).set(data);
              } else if (v.type === 1 /* float */) {
                new Float32Array(arrayBuffer, offset, data.length).set(data);
              } else {
                throw new Error(`Unsupported uniform type: ${tensorDataTypeEnumToString(v.type)}`);
              }
            });
            const uniformBufferData = (
              // eslint-disable-next-line no-bitwise
              this.gpuDataManager.create(currentOffset, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM)
            );
            this.device.queue.writeBuffer(uniformBufferData.buffer, 0, arrayBuffer, 0, currentOffset);
            this.gpuDataManager.release(uniformBufferData.id);
            uniformBufferBinding = { offset: 0, size: currentOffset, buffer: uniformBufferData.buffer };
          }
          const normalizedDispatchGroup = this.programManager.normalizeDispatchGroupSize(dispatchGroup);
          const is1DimensionDispatch = normalizedDispatchGroup[1] === 1 && normalizedDispatchGroup[2] === 1;
          const key = getProgramInfoUniqueKey(program, inputTensorViews, is1DimensionDispatch);
          let artifact = this.programManager.getArtifact(key);
          if (!artifact) {
            artifact = this.programManager.build(program, normalizedDispatchGroup);
            this.programManager.setArtifact(key, artifact);
            LOG_DEBUG("info", () => `[artifact] key: ${key}, programName: ${program.name}`);
          }
          if (programUniforms && artifact.uniformVariablesInfo) {
            if (programUniforms.length !== artifact.uniformVariablesInfo.length) {
              throw new Error(
                `Uniform variables count mismatch: expect ${artifact.uniformVariablesInfo.length}, got ${programUniforms.length} in program "${artifact.programInfo.name}".`
              );
            }
            for (let i = 0; i < programUniforms.length; i++) {
              const uniform = programUniforms[i];
              const actualType = uniform.type;
              const actualLength = typeof uniform.data === "number" ? 1 : uniform.data.length;
              const [type, length] = artifact.uniformVariablesInfo[i];
              if (actualType !== type || actualLength !== length) {
                throw new Error(
                  `Uniform variable ${i} mismatch: expect type ${type} with size ${length}, got type ${actualType} with size ${actualLength} in program "${artifact.programInfo.name}".`
                );
              }
            }
          }
          LOG_DEBUG(
            "info",
            () => `[ProgramManager] run "${program.name}" (key=${key}) with ${normalizedDispatchGroup[0]}x${normalizedDispatchGroup[1]}x${normalizedDispatchGroup[2]}`
          );
          if (this.queryType !== "none" || this.sessionStatus === "capturing") {
            const pendingKernelInfo = {
              kernelId: this.currentKernelId,
              programName: artifact.programInfo.name,
              inputTensorViews,
              outputTensorViews
            };
            this.pendingKernels.push(pendingKernelInfo);
            if (this.sessionStatus === "capturing") {
              const sessionPendingKernels = this.capturedPendingKernels.get(this.currentSessionId);
              sessionPendingKernels.push(pendingKernelInfo);
            }
          }
          this.programManager.run(artifact, inputDatas, outputDatas, normalizedDispatchGroup, uniformBufferBinding);
          TRACE_FUNC_END(program.name);
          return outputTensorViews;
        }
        upload(gpuDataId, data) {
          this.gpuDataManager.upload(gpuDataId, data);
        }
        memcpy(src, dst) {
          this.gpuDataManager.memcpy(src, dst);
        }
        async download(gpuDataId, getTargetBuffer) {
          await this.gpuDataManager.download(gpuDataId, getTargetBuffer);
        }
        alloc(size) {
          return this.gpuDataManager.create(size).id;
        }
        free(ptr) {
          return this.gpuDataManager.release(ptr);
        }
        createKernel(kernelType, kernelId, attribute, kernelName) {
          const op = WEBGPU_OP_RESOLVE_RULES.get(kernelType);
          if (!op) {
            throw new Error(`kernel not implemented: ${kernelType}`);
          }
          const kernelInfo = {
            kernelType,
            kernelName,
            kernelEntry: op[0],
            attributes: [op[1], attribute]
          };
          this.kernels.set(kernelId, kernelInfo);
        }
        releaseKernel(kernelId) {
          const persistentData = this.kernelPersistentData.get(kernelId);
          if (persistentData) {
            for (const data of persistentData) {
              this.gpuDataManager.release(data.id);
            }
            this.kernelPersistentData.delete(kernelId);
          }
          this.kernelCustomData.delete(kernelId);
          this.kernels.delete(kernelId);
        }
        computeKernel(kernelId, context, errors) {
          const kernel = this.kernels.get(kernelId);
          if (!kernel) {
            throw new Error(`kernel not created: ${kernelId}`);
          }
          const kernelType = kernel.kernelType;
          const kernelName = kernel.kernelName;
          const kernelEntry = kernel.kernelEntry;
          const attributes = kernel.attributes;
          if (this.currentKernelId !== null) {
            throw new Error(`kernel "[${kernelType}] ${kernelName}" is not allowed to be called recursively`);
          }
          this.currentKernelId = kernelId;
          if (attributes[0]) {
            attributes[1] = attributes[0](attributes[1]);
            attributes[0] = void 0;
          }
          LOG_DEBUG("info", () => `[WebGPU] Start to run kernel "[${kernelType}] ${kernelName}"...`);
          const useErrorScope = this.env.debug;
          this.temporaryData = [];
          try {
            if (useErrorScope) {
              this.device.pushErrorScope("validation");
            }
            kernelEntry(context, attributes[1]);
            return 0;
          } catch (e) {
            errors.push(Promise.resolve(`[WebGPU] Kernel "[${kernelType}] ${kernelName}" failed. ${e}`));
            return 1;
          } finally {
            if (useErrorScope) {
              errors.push(
                this.device.popErrorScope().then(
                  (err) => err ? `GPU validation error for kernel "[${kernelType}] ${kernelName}": ${err.message}` : null
                )
              );
            }
            for (const data of this.temporaryData) {
              this.gpuDataManager.release(data.id);
            }
            this.temporaryData = [];
            this.currentKernelId = null;
          }
        }
        // #region external buffer
        registerBuffer(sessionId, index, buffer, size) {
          let sessionInputOutputMapping = this.sessionExternalDataMapping.get(sessionId);
          if (!sessionInputOutputMapping) {
            sessionInputOutputMapping = /* @__PURE__ */ new Map();
            this.sessionExternalDataMapping.set(sessionId, sessionInputOutputMapping);
          }
          const previousBuffer = sessionInputOutputMapping.get(index);
          const id = this.gpuDataManager.registerExternalBuffer(buffer, size, previousBuffer?.[1]);
          sessionInputOutputMapping.set(index, [id, buffer]);
          return id;
        }
        unregisterBuffers(sessionId) {
          const sessionInputOutputMapping = this.sessionExternalDataMapping.get(sessionId);
          if (sessionInputOutputMapping) {
            sessionInputOutputMapping.forEach((bufferInfo) => this.gpuDataManager.unregisterExternalBuffer(bufferInfo[1]));
            this.sessionExternalDataMapping.delete(sessionId);
          }
        }
        getBuffer(gpuDataId) {
          const gpuData = this.gpuDataManager.get(gpuDataId);
          if (!gpuData) {
            throw new Error(`no GPU data for buffer: ${gpuDataId}`);
          }
          return gpuData.buffer;
        }
        createDownloader(gpuBuffer, size, type) {
          return async () => {
            const data = await downloadGpuData(this, gpuBuffer, size);
            return createView(data.buffer, type);
          };
        }
        // #endregion
        writeTimestamp(index) {
          if (this.queryType !== "inside-passes") {
            return;
          }
          this.computePassEncoder.writeTimestamp(this.querySet, index);
        }
        setQueryType() {
          this.queryType = "none";
          if (this.env.webgpu.profiling?.mode === "default" || (typeof this.env.trace === "undefined" ? this.env.wasm.trace : this.env.trace)) {
            if (this.device.features.has("chromium-experimental-timestamp-query-inside-passes")) {
              this.queryType = "inside-passes";
            } else if (this.device.features.has("timestamp-query")) {
              this.queryType = "at-passes";
            }
            if (this.queryType !== "none" && typeof this.querySet === "undefined") {
              this.querySet = this.device.createQuerySet({
                type: "timestamp",
                count: this.maxDispatchNumber * 2
              });
              this.queryResolveBuffer = this.device.createBuffer(
                // eslint-disable-next-line no-bitwise
                { size: this.maxDispatchNumber * 2 * 8, usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE }
              );
            }
          }
        }
        captureBegin() {
          LOG_DEBUG("info", "captureBegin");
          if (!this.capturedCommandList.get(this.currentSessionId)) {
            this.capturedCommandList.set(this.currentSessionId, []);
          }
          if (!this.capturedPendingKernels.get(this.currentSessionId)) {
            this.capturedPendingKernels.set(this.currentSessionId, []);
          }
          this.flush();
          this.sessionStatus = "capturing";
        }
        captureEnd() {
          LOG_DEBUG("info", "captureEnd");
          this.flush();
          this.sessionStatus = "default";
        }
        replay() {
          LOG_DEBUG("info", "replay");
          this.sessionStatus = "replaying";
          const sessionCommandList = this.capturedCommandList.get(this.currentSessionId);
          const sessionPendingKernels = this.capturedPendingKernels.get(this.currentSessionId);
          const length = sessionCommandList.length;
          this.pendingKernels = [];
          for (let i = 0; i < length; i++) {
            const computePassEncoder = this.getComputePassEncoder();
            const command = sessionCommandList[i];
            this.writeTimestamp(this.pendingDispatchNumber * 2);
            computePassEncoder.setPipeline(command.computePipeline);
            computePassEncoder.setBindGroup(0, command.bindGroup);
            computePassEncoder.dispatchWorkgroups(...command.dispatchGroup);
            this.writeTimestamp(this.pendingDispatchNumber * 2 + 1);
            this.pendingDispatchNumber++;
            if (this.queryType !== "none") {
              this.pendingKernels.push(sessionPendingKernels[i]);
            }
            if (this.pendingDispatchNumber >= this.maxDispatchNumber || this.queryType === "at-passes") {
              this.endComputePass();
            }
            if (this.pendingDispatchNumber >= this.maxDispatchNumber) {
              this.flush();
            }
          }
          this.flush();
          this.sessionStatus = "default";
        }
        onReleaseSession(sessionId) {
          this.unregisterBuffers(sessionId);
          if (this.capturedCommandList.has(sessionId)) {
            this.capturedCommandList.delete(sessionId);
          }
          if (this.capturedPendingKernels.has(sessionId)) {
            this.capturedPendingKernels.delete(sessionId);
          }
          this.gpuDataManager.onReleaseSession(sessionId);
        }
        onRunStart(sessionId) {
          this.currentSessionId = sessionId;
          this.setQueryType();
        }
      };
    }
  });

  // web/lib/wasm/jsep/init.ts
  var init_exports = {};
  __export(init_exports, {
    init: () => init
  });
  var TensorViewImpl, ComputeContextImpl, init;
  var init_init = __esm({
    "web/lib/wasm/jsep/init.ts"() {
      "use strict";
      init_wasm_common();
      init_backend_webgpu();
      init_log();
      init_util();
      TensorViewImpl = class _TensorViewImpl {
        constructor(module, dataType, data, dims) {
          this.module = module;
          this.dataType = dataType;
          this.data = data;
          this.dims = dims;
        }
        getFloat32Array() {
          if (this.dataType !== 1 /* float */) {
            throw new Error("Invalid data type");
          }
          const elementCount = ShapeUtil.size(this.dims);
          return elementCount === 0 ? new Float32Array() : new Float32Array(this.module.HEAP8.buffer, this.data, elementCount);
        }
        getBigInt64Array() {
          if (this.dataType !== 7 /* int64 */) {
            throw new Error("Invalid data type");
          }
          const elementCount = ShapeUtil.size(this.dims);
          return elementCount === 0 ? new BigInt64Array() : new BigInt64Array(this.module.HEAP8.buffer, this.data, elementCount);
        }
        getInt32Array() {
          if (this.dataType !== 6 /* int32 */) {
            throw new Error("Invalid data type");
          }
          const elementCount = ShapeUtil.size(this.dims);
          return elementCount === 0 ? new Int32Array() : new Int32Array(this.module.HEAP8.buffer, this.data, elementCount);
        }
        getUint16Array() {
          if (this.dataType !== 10 /* float16 */ && this.dataType !== 4 /* uint16 */) {
            throw new Error("Invalid data type");
          }
          const elementCount = ShapeUtil.size(this.dims);
          return elementCount === 0 ? new Uint16Array() : new Uint16Array(this.module.HEAP8.buffer, this.data, elementCount);
        }
        reshape(newDims) {
          if (ShapeUtil.size(newDims) !== ShapeUtil.size(this.dims)) {
            throw new Error("Invalid new shape");
          }
          return new _TensorViewImpl(this.module, this.dataType, this.data, newDims);
        }
      };
      ComputeContextImpl = class {
        constructor(module, backend, contextDataOffset) {
          this.module = module;
          this.backend = backend;
          this.customDataOffset = 0;
          this.customDataSize = 0;
          this.adapterInfo = backend.adapterInfo;
          const heapU32 = module.HEAPU32;
          let dataIndex = contextDataOffset >>> 2;
          this.opKernelContext = heapU32[dataIndex++];
          const inputCount = heapU32[dataIndex++];
          this.outputCount = heapU32[dataIndex++];
          this.customDataOffset = heapU32[dataIndex++];
          this.customDataSize = heapU32[dataIndex++];
          const inputs = [];
          for (let i = 0; i < inputCount; i++) {
            const dataType = heapU32[dataIndex++];
            const data = heapU32[dataIndex++];
            const dim = heapU32[dataIndex++];
            const dims = [];
            for (let d = 0; d < dim; d++) {
              dims.push(heapU32[dataIndex++]);
            }
            inputs.push(new TensorViewImpl(module, dataType, data, dims));
          }
          this.inputs = inputs;
        }
        get kernelCustomData() {
          return this.backend.currentKernelCustomData;
        }
        get customDataBuffer() {
          return this.module.HEAPU8.subarray(this.customDataOffset, this.customDataOffset + this.customDataSize);
        }
        getMaxComputeWorkgroupSizes() {
          return [
            this.backend.device.limits.maxComputeWorkgroupSizeX,
            this.backend.device.limits.maxComputeWorkgroupSizeY,
            this.backend.device.limits.maxComputeWorkgroupSizeZ
          ];
        }
        getMaxComputeWorkgroupStoragesize() {
          return this.backend.device.limits.maxComputeWorkgroupStorageSize;
        }
        compute(program, inputsOutputsMapping) {
          const mappedInputs = inputsOutputsMapping?.inputs?.map((i) => typeof i === "number" ? this.inputs[i] : i) ?? this.inputs;
          const outputIndices = inputsOutputsMapping?.outputs ?? [];
          const createKernelOutput = (index, dataType, dims) => new TensorViewImpl(this.module, dataType, this.output(index, dims), dims);
          const createTemporaryOutput = (dataType, dims) => {
            const bufferSize = calculateTensorSizeInBytes(dataType, dims);
            if (!bufferSize) {
              throw new Error(`Unsupported data type: ${dataType}`);
            }
            const gpuDataId = bufferSize > 0 ? this.backend.gpuDataManager.create(bufferSize).id : 0;
            return new TensorViewImpl(this.module, dataType, gpuDataId, dims);
          };
          return this.backend.run(
            program,
            mappedInputs,
            outputIndices,
            createKernelOutput,
            createTemporaryOutput,
            this.outputCount
          );
        }
        output(index, dims) {
          const stack = this.module.stackSave();
          try {
            const data = this.module.stackAlloc(
              (1 + dims.length) * 4
              /* sizeof(size_t) */
            );
            let offset = data >> 2;
            this.module.HEAPU32[offset++] = dims.length;
            for (let i = 0; i < dims.length; i++) {
              this.module.HEAPU32[offset++] = dims[i];
            }
            return this.module._JsepOutput(this.opKernelContext, index, data);
          } catch (e) {
            throw new Error(
              `Failed to generate kernel's output[${index}] with dims [${dims}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${e}`
            );
          } finally {
            this.module.stackRestore(stack);
          }
        }
      };
      init = async (name, module, env3, gpuAdapter) => {
        const jsepInit = module.jsepInit;
        if (!jsepInit) {
          throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");
        }
        if (name === "webgpu") {
          const backend = new WebGpuBackend();
          await backend.initialize(env3, gpuAdapter);
          jsepInit("webgpu", [
            // backend
            backend,
            // jsepAlloc()
            (size) => backend.alloc(size),
            // jsepFree()
            (ptr) => backend.free(ptr),
            // jsepCopy(src, dst, size, isSourceGpu)
            (src, dst, size, isSourceGpu = false) => {
              if (isSourceGpu) {
                LOG_DEBUG("verbose", () => `[WebGPU] jsepCopyGpuToGpu: src=${src}, dst=${dst}, size=${size}`);
                backend.memcpy(src, dst);
              } else {
                LOG_DEBUG("verbose", () => `[WebGPU] jsepCopyCpuToGpu: dataOffset=${src}, gpuDataId=${dst}, size=${size}`);
                const data = module.HEAPU8.subarray(src >>> 0, (src >>> 0) + size);
                backend.upload(dst, data);
              }
            },
            // jsepCopyAsync(src, dst, size)
            async (gpuDataId, dataOffset, size) => {
              LOG_DEBUG(
                "verbose",
                () => `[WebGPU] jsepCopyGpuToCpu: gpuDataId=${gpuDataId}, dataOffset=${dataOffset}, size=${size}`
              );
              await backend.download(gpuDataId, () => module.HEAPU8.subarray(dataOffset >>> 0, (dataOffset >>> 0) + size));
            },
            // jsepCreateKernel
            (kernelType, kernelId, attribute) => backend.createKernel(kernelType, kernelId, attribute, module.UTF8ToString(module._JsepGetNodeName(kernelId))),
            // jsepReleaseKernel
            (kernel) => backend.releaseKernel(kernel),
            // jsepRun
            (kernel, contextDataOffset, sessionHandle, errors) => {
              LOG_DEBUG(
                "verbose",
                () => `[WebGPU] jsepRun: sessionHandle=${sessionHandle}, kernel=${kernel}, contextDataOffset=${contextDataOffset}`
              );
              const context = new ComputeContextImpl(module, backend, contextDataOffset);
              return backend.computeKernel(kernel, context, errors);
            },
            // jsepCaptureBegin
            () => backend.captureBegin(),
            // jsepCaptureEnd
            () => backend.captureEnd(),
            // jsepReplay
            () => backend.replay()
          ]);
        } else {
          jsepInit("webnn");
        }
      };
    }
  });

  // web/lib/wasm/wasm-core-impl.ts
  var initOrt, initRuntime, initEp, activeSessions, getSessionInputOutputCount, copyFromExternalBuffer, createSession, releaseSession, prepareInputOutputTensor, run, endProfiling, extractTransferableBuffers;
  var init_wasm_core_impl = __esm({
    "web/lib/wasm/wasm-core-impl.ts"() {
      "use strict";
      init_run_options();
      init_session_options();
      init_wasm_common();
      init_wasm_factory();
      init_wasm_utils();
      init_wasm_utils_load_file();
      initOrt = (numThreads, loggingLevel) => {
        const errorCode = getInstance()._OrtInit(numThreads, loggingLevel);
        if (errorCode !== 0) {
          checkLastError("Can't initialize onnxruntime.");
        }
      };
      initRuntime = async (env3) => {
        initOrt(env3.wasm.numThreads, logLevelStringToEnum(env3.logLevel));
      };
      initEp = async (env3, epName) => {
        if (true) {
          const initJsep = (init_init(), __toCommonJS(init_exports)).init;
          if (epName === "webgpu") {
            if (typeof navigator === "undefined" || !navigator.gpu) {
              throw new Error("WebGPU is not supported in current environment");
            }
            let adapter = env3.webgpu.adapter;
            if (!adapter) {
              const powerPreference = env3.webgpu.powerPreference;
              if (powerPreference !== void 0 && powerPreference !== "low-power" && powerPreference !== "high-performance") {
                throw new Error(`Invalid powerPreference setting: "${powerPreference}"`);
              }
              const forceFallbackAdapter = env3.webgpu.forceFallbackAdapter;
              if (forceFallbackAdapter !== void 0 && typeof forceFallbackAdapter !== "boolean") {
                throw new Error(`Invalid forceFallbackAdapter setting: "${forceFallbackAdapter}"`);
              }
              adapter = await navigator.gpu.requestAdapter({ powerPreference, forceFallbackAdapter });
              if (!adapter) {
                throw new Error(
                  'Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.'
                );
              }
            } else {
              if (typeof adapter.limits !== "object" || typeof adapter.features !== "object" || typeof adapter.requestDevice !== "function") {
                throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.");
              }
            }
            await initJsep("webgpu", getInstance(), env3, adapter);
          }
          if (epName === "webnn") {
            if (typeof navigator === "undefined" || !navigator.ml) {
              throw new Error("WebNN is not supported in current environment");
            }
            await initJsep("webnn", getInstance(), env3);
          }
        }
      };
      activeSessions = /* @__PURE__ */ new Map();
      getSessionInputOutputCount = (sessionHandle) => {
        const wasm2 = getInstance();
        const stack = wasm2.stackSave();
        try {
          const dataOffset = wasm2.stackAlloc(8);
          const errorCode = wasm2._OrtGetInputOutputCount(sessionHandle, dataOffset, dataOffset + 4);
          if (errorCode !== 0) {
            checkLastError("Can't get session input/output count.");
          }
          return [wasm2.HEAP32[dataOffset / 4], wasm2.HEAP32[dataOffset / 4 + 1]];
        } finally {
          wasm2.stackRestore(stack);
        }
      };
      copyFromExternalBuffer = (model) => {
        const wasm2 = getInstance();
        const modelDataOffset = wasm2._malloc(model.byteLength);
        if (modelDataOffset === 0) {
          throw new Error(`Can't create a session. failed to allocate a buffer of size ${model.byteLength}.`);
        }
        wasm2.HEAPU8.set(model, modelDataOffset);
        return [modelDataOffset, model.byteLength];
      };
      createSession = async (modelData, options) => {
        let modelDataOffset, modelDataLength;
        const wasm2 = getInstance();
        if (Array.isArray(modelData)) {
          [modelDataOffset, modelDataLength] = modelData;
        } else if (modelData.buffer === wasm2.HEAPU8.buffer) {
          [modelDataOffset, modelDataLength] = [modelData.byteOffset, modelData.byteLength];
        } else {
          [modelDataOffset, modelDataLength] = copyFromExternalBuffer(modelData);
        }
        let sessionHandle = 0;
        let sessionOptionsHandle = 0;
        let ioBindingHandle = 0;
        let allocs = [];
        const inputNamesUTF8Encoded = [];
        const outputNamesUTF8Encoded = [];
        try {
          [sessionOptionsHandle, allocs] = setSessionOptions(options);
          if (options?.externalData && wasm2.mountExternalData) {
            const loadingPromises = [];
            for (const file of options.externalData) {
              const path = typeof file === "string" ? file : file.path;
              loadingPromises.push(
                loadFile(typeof file === "string" ? file : file.data).then((data) => {
                  wasm2.mountExternalData(path, data);
                })
              );
            }
            await Promise.all(loadingPromises);
          }
          for (const provider of options?.executionProviders ?? []) {
            const providerName = typeof provider === "string" ? provider : provider.name;
            if (providerName === "webnn") {
              if (wasm2.currentContext) {
                throw new Error("WebNN execution provider is already set.");
              }
              if (typeof provider !== "string") {
                const webnnOptions = provider;
                const context = webnnOptions?.context;
                const gpuDevice = webnnOptions?.gpuDevice;
                const deviceType = webnnOptions?.deviceType;
                const numThreads = webnnOptions?.numThreads;
                const powerPreference = webnnOptions?.powerPreference;
                if (context) {
                  wasm2.currentContext = context;
                } else if (gpuDevice) {
                  wasm2.currentContext = await navigator.ml.createContext(gpuDevice);
                } else {
                  wasm2.currentContext = await navigator.ml.createContext({ deviceType, numThreads, powerPreference });
                }
              } else {
                wasm2.currentContext = await navigator.ml.createContext();
              }
              break;
            }
          }
          sessionHandle = await wasm2._OrtCreateSession(modelDataOffset, modelDataLength, sessionOptionsHandle);
          if (sessionHandle === 0) {
            checkLastError("Can't create a session.");
          }
          if (wasm2.currentContext) {
            wasm2.currentContext = void 0;
          }
          const [inputCount, outputCount] = getSessionInputOutputCount(sessionHandle);
          const enableGraphCapture = !!options?.enableGraphCapture;
          const inputNames = [];
          const outputNames = [];
          const outputPreferredLocations = [];
          for (let i = 0; i < inputCount; i++) {
            const name = wasm2._OrtGetInputName(sessionHandle, i);
            if (name === 0) {
              checkLastError("Can't get an input name.");
            }
            inputNamesUTF8Encoded.push(name);
            inputNames.push(wasm2.UTF8ToString(name));
          }
          for (let i = 0; i < outputCount; i++) {
            const name = wasm2._OrtGetOutputName(sessionHandle, i);
            if (name === 0) {
              checkLastError("Can't get an output name.");
            }
            outputNamesUTF8Encoded.push(name);
            const nameString = wasm2.UTF8ToString(name);
            outputNames.push(nameString);
            if (true) {
              if (enableGraphCapture && options?.preferredOutputLocation === void 0) {
                outputPreferredLocations.push("gpu-buffer");
                continue;
              }
              const location2 = typeof options?.preferredOutputLocation === "string" ? options.preferredOutputLocation : options?.preferredOutputLocation?.[nameString] ?? "cpu";
              if (location2 !== "cpu" && location2 !== "cpu-pinned" && location2 !== "gpu-buffer") {
                throw new Error(`Not supported preferred output location: ${location2}.`);
              }
              if (enableGraphCapture && location2 !== "gpu-buffer") {
                throw new Error(
                  `Not supported preferred output location: ${location2}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`
                );
              }
              outputPreferredLocations.push(location2);
            }
          }
          let bindingState = null;
          if (outputPreferredLocations.some((l) => l === "gpu-buffer")) {
            ioBindingHandle = wasm2._OrtCreateBinding(sessionHandle);
            if (ioBindingHandle === 0) {
              checkLastError("Can't create IO binding.");
            }
            bindingState = {
              handle: ioBindingHandle,
              outputPreferredLocations,
              outputPreferredLocationsEncoded: outputPreferredLocations.map((l) => dataLocationStringToEnum(l))
            };
          }
          activeSessions.set(sessionHandle, [
            sessionHandle,
            inputNamesUTF8Encoded,
            outputNamesUTF8Encoded,
            bindingState,
            enableGraphCapture,
            false
          ]);
          return [sessionHandle, inputNames, outputNames];
        } catch (e) {
          inputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
          outputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
          if (ioBindingHandle !== 0) {
            wasm2._OrtReleaseBinding(ioBindingHandle);
          }
          if (sessionHandle !== 0) {
            wasm2._OrtReleaseSession(sessionHandle);
          }
          throw e;
        } finally {
          wasm2._free(modelDataOffset);
          if (sessionOptionsHandle !== 0) {
            wasm2._OrtReleaseSessionOptions(sessionOptionsHandle);
          }
          allocs.forEach((alloc) => wasm2._free(alloc));
          wasm2.unmountExternalData?.();
        }
      };
      releaseSession = (sessionId) => {
        const wasm2 = getInstance();
        const session = activeSessions.get(sessionId);
        if (!session) {
          throw new Error(`cannot release session. invalid session id: ${sessionId}`);
        }
        const [sessionHandle, inputNamesUTF8Encoded, outputNamesUTF8Encoded, ioBindingState, enableGraphCapture] = session;
        if (ioBindingState) {
          if (enableGraphCapture) {
            wasm2._OrtClearBoundOutputs(ioBindingState.handle);
          }
          wasm2._OrtReleaseBinding(ioBindingState.handle);
        }
        wasm2.jsepOnReleaseSession?.(sessionId);
        inputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
        outputNamesUTF8Encoded.forEach((buf) => wasm2._OrtFree(buf));
        wasm2._OrtReleaseSession(sessionHandle);
        activeSessions.delete(sessionId);
      };
      prepareInputOutputTensor = (tensor, tensorHandles, allocs, sessionId, index, enableGraphCapture = false) => {
        if (!tensor) {
          tensorHandles.push(0);
          return;
        }
        const wasm2 = getInstance();
        const dataType = tensor[0];
        const dims = tensor[1];
        const location2 = tensor[3];
        let rawData;
        let dataByteLength;
        if (dataType === "string" && location2 === "gpu-buffer") {
          throw new Error("String tensor is not supported on GPU.");
        }
        if (enableGraphCapture && location2 !== "gpu-buffer") {
          throw new Error(
            `External buffer must be provided for input/output index ${index} when enableGraphCapture is true.`
          );
        }
        if (location2 === "gpu-buffer") {
          const gpuBuffer = tensor[2].gpuBuffer;
          dataByteLength = calculateTensorSizeInBytes(tensorDataTypeStringToEnum(dataType), dims);
          const registerBuffer = wasm2.jsepRegisterBuffer;
          if (!registerBuffer) {
            throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');
          }
          rawData = registerBuffer(sessionId, index, gpuBuffer, dataByteLength);
        } else {
          const data = tensor[2];
          if (Array.isArray(data)) {
            dataByteLength = 4 * data.length;
            rawData = wasm2._malloc(dataByteLength);
            allocs.push(rawData);
            let dataIndex = rawData / 4;
            for (let i = 0; i < data.length; i++) {
              if (typeof data[i] !== "string") {
                throw new TypeError(`tensor data at index ${i} is not a string`);
              }
              wasm2.HEAPU32[dataIndex++] = allocWasmString(data[i], allocs);
            }
          } else {
            dataByteLength = data.byteLength;
            rawData = wasm2._malloc(dataByteLength);
            allocs.push(rawData);
            wasm2.HEAPU8.set(new Uint8Array(data.buffer, data.byteOffset, dataByteLength), rawData);
          }
        }
        const stack = wasm2.stackSave();
        const dimsOffset = wasm2.stackAlloc(4 * dims.length);
        try {
          let dimIndex = dimsOffset / 4;
          dims.forEach((d) => wasm2.HEAP32[dimIndex++] = d);
          const tensor2 = wasm2._OrtCreateTensor(
            tensorDataTypeStringToEnum(dataType),
            rawData,
            dataByteLength,
            dimsOffset,
            dims.length,
            dataLocationStringToEnum(location2)
          );
          if (tensor2 === 0) {
            checkLastError(`Can't create tensor for input/output. session=${sessionId}, index=${index}.`);
          }
          tensorHandles.push(tensor2);
        } finally {
          wasm2.stackRestore(stack);
        }
      };
      run = async (sessionId, inputIndices, inputTensors, outputIndices, outputTensors, options) => {
        const wasm2 = getInstance();
        const session = activeSessions.get(sessionId);
        if (!session) {
          throw new Error(`cannot run inference. invalid session id: ${sessionId}`);
        }
        const sessionHandle = session[0];
        const inputNamesUTF8Encoded = session[1];
        const outputNamesUTF8Encoded = session[2];
        const ioBindingState = session[3];
        const enableGraphCapture = session[4];
        const inputOutputBound = session[5];
        const inputCount = inputIndices.length;
        const outputCount = outputIndices.length;
        let runOptionsHandle = 0;
        let runOptionsAllocs = [];
        const inputTensorHandles = [];
        const outputTensorHandles = [];
        const inputOutputAllocs = [];
        const beforeRunStack = wasm2.stackSave();
        const inputValuesOffset = wasm2.stackAlloc(inputCount * 4);
        const inputNamesOffset = wasm2.stackAlloc(inputCount * 4);
        const outputValuesOffset = wasm2.stackAlloc(outputCount * 4);
        const outputNamesOffset = wasm2.stackAlloc(outputCount * 4);
        try {
          [runOptionsHandle, runOptionsAllocs] = setRunOptions(options);
          for (let i = 0; i < inputCount; i++) {
            prepareInputOutputTensor(
              inputTensors[i],
              inputTensorHandles,
              inputOutputAllocs,
              sessionId,
              inputIndices[i],
              enableGraphCapture
            );
          }
          for (let i = 0; i < outputCount; i++) {
            prepareInputOutputTensor(
              outputTensors[i],
              outputTensorHandles,
              inputOutputAllocs,
              sessionId,
              inputCount + outputIndices[i],
              enableGraphCapture
            );
          }
          let inputValuesIndex = inputValuesOffset / 4;
          let inputNamesIndex = inputNamesOffset / 4;
          let outputValuesIndex = outputValuesOffset / 4;
          let outputNamesIndex = outputNamesOffset / 4;
          for (let i = 0; i < inputCount; i++) {
            wasm2.HEAPU32[inputValuesIndex++] = inputTensorHandles[i];
            wasm2.HEAPU32[inputNamesIndex++] = inputNamesUTF8Encoded[inputIndices[i]];
          }
          for (let i = 0; i < outputCount; i++) {
            wasm2.HEAPU32[outputValuesIndex++] = outputTensorHandles[i];
            wasm2.HEAPU32[outputNamesIndex++] = outputNamesUTF8Encoded[outputIndices[i]];
          }
          if (ioBindingState && !inputOutputBound) {
            const { handle, outputPreferredLocations, outputPreferredLocationsEncoded } = ioBindingState;
            if (inputNamesUTF8Encoded.length !== inputCount) {
              throw new Error(
                `input count from feeds (${inputCount}) is expected to be always equal to model's input count (${inputNamesUTF8Encoded.length}).`
              );
            }
            for (let i = 0; i < inputCount; i++) {
              const index = inputIndices[i];
              const errorCode2 = await wasm2._OrtBindInput(handle, inputNamesUTF8Encoded[index], inputTensorHandles[i]);
              if (errorCode2 !== 0) {
                checkLastError(`Can't bind input[${i}] for session=${sessionId}.`);
              }
            }
            for (let i = 0; i < outputCount; i++) {
              const index = outputIndices[i];
              const location2 = outputTensors[i]?.[3];
              if (location2) {
                const errorCode2 = wasm2._OrtBindOutput(handle, outputNamesUTF8Encoded[index], outputTensorHandles[i], 0);
                if (errorCode2 !== 0) {
                  checkLastError(`Can't bind pre-allocated output[${i}] for session=${sessionId}.`);
                }
              } else {
                const errorCode2 = wasm2._OrtBindOutput(
                  handle,
                  outputNamesUTF8Encoded[index],
                  0,
                  outputPreferredLocationsEncoded[index]
                );
                if (errorCode2 !== 0) {
                  checkLastError(`Can't bind output[${i}] to ${outputPreferredLocations[i]} for session=${sessionId}.`);
                }
              }
            }
            activeSessions.set(sessionId, [
              sessionHandle,
              inputNamesUTF8Encoded,
              outputNamesUTF8Encoded,
              ioBindingState,
              enableGraphCapture,
              true
            ]);
          }
          wasm2.jsepOnRunStart?.(sessionHandle);
          let errorCode;
          if (ioBindingState) {
            errorCode = await wasm2._OrtRunWithBinding(
              sessionHandle,
              ioBindingState.handle,
              outputCount,
              outputValuesOffset,
              runOptionsHandle
            );
          } else {
            errorCode = await wasm2._OrtRun(
              sessionHandle,
              inputNamesOffset,
              inputValuesOffset,
              inputCount,
              outputNamesOffset,
              outputCount,
              outputValuesOffset,
              runOptionsHandle
            );
          }
          if (errorCode !== 0) {
            checkLastError("failed to call OrtRun().");
          }
          const output = [];
          for (let i = 0; i < outputCount; i++) {
            const tensor = wasm2.HEAPU32[outputValuesOffset / 4 + i];
            if (tensor === outputTensorHandles[i]) {
              output.push(outputTensors[i]);
              continue;
            }
            const beforeGetTensorDataStack = wasm2.stackSave();
            const tensorDataOffset = wasm2.stackAlloc(4 * 4);
            let keepOutputTensor = false;
            let type, dataOffset = 0;
            try {
              const errorCode2 = wasm2._OrtGetTensorData(
                tensor,
                tensorDataOffset,
                tensorDataOffset + 4,
                tensorDataOffset + 8,
                tensorDataOffset + 12
              );
              if (errorCode2 !== 0) {
                checkLastError(`Can't access output tensor data on index ${i}.`);
              }
              let tensorDataIndex = tensorDataOffset / 4;
              const dataType = wasm2.HEAPU32[tensorDataIndex++];
              dataOffset = wasm2.HEAPU32[tensorDataIndex++];
              const dimsOffset = wasm2.HEAPU32[tensorDataIndex++];
              const dimsLength = wasm2.HEAPU32[tensorDataIndex++];
              const dims = [];
              for (let i2 = 0; i2 < dimsLength; i2++) {
                dims.push(wasm2.HEAPU32[dimsOffset / 4 + i2]);
              }
              wasm2._OrtFree(dimsOffset);
              const size = dims.reduce((a, b) => a * b, 1);
              type = tensorDataTypeEnumToString(dataType);
              const preferredLocation = ioBindingState?.outputPreferredLocations[outputIndices[i]];
              if (type === "string") {
                if (preferredLocation === "gpu-buffer") {
                  throw new Error("String tensor is not supported on GPU.");
                }
                const stringData = [];
                let dataIndex = dataOffset / 4;
                for (let i2 = 0; i2 < size; i2++) {
                  const offset = wasm2.HEAPU32[dataIndex++];
                  const maxBytesToRead = i2 === size - 1 ? void 0 : wasm2.HEAPU32[dataIndex] - offset;
                  stringData.push(wasm2.UTF8ToString(offset, maxBytesToRead));
                }
                output.push([type, dims, stringData, "cpu"]);
              } else {
                if (preferredLocation === "gpu-buffer" && size > 0) {
                  const getBuffer = wasm2.jsepGetBuffer;
                  if (!getBuffer) {
                    throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');
                  }
                  const gpuBuffer = getBuffer(dataOffset);
                  const bufferSize = calculateTensorSizeInBytes(dataType, size);
                  if (bufferSize === void 0 || !isGpuBufferSupportedType(type)) {
                    throw new Error(`Unsupported data type: ${type}`);
                  }
                  keepOutputTensor = true;
                  output.push([
                    type,
                    dims,
                    {
                      gpuBuffer,
                      download: wasm2.jsepCreateDownloader(gpuBuffer, bufferSize, type),
                      dispose: () => {
                        wasm2._OrtReleaseTensor(tensor);
                      }
                    },
                    "gpu-buffer"
                  ]);
                } else {
                  const typedArrayConstructor = tensorTypeToTypedArrayConstructor(type);
                  const data = new typedArrayConstructor(size);
                  new Uint8Array(data.buffer, data.byteOffset, data.byteLength).set(
                    wasm2.HEAPU8.subarray(dataOffset, dataOffset + data.byteLength)
                  );
                  output.push([type, dims, data, "cpu"]);
                }
              }
            } finally {
              wasm2.stackRestore(beforeGetTensorDataStack);
              if (type === "string" && dataOffset) {
                wasm2._free(dataOffset);
              }
              if (!keepOutputTensor) {
                wasm2._OrtReleaseTensor(tensor);
              }
            }
          }
          if (ioBindingState && !enableGraphCapture) {
            wasm2._OrtClearBoundOutputs(ioBindingState.handle);
            activeSessions.set(sessionId, [
              sessionHandle,
              inputNamesUTF8Encoded,
              outputNamesUTF8Encoded,
              ioBindingState,
              enableGraphCapture,
              false
            ]);
          }
          return output;
        } finally {
          wasm2.stackRestore(beforeRunStack);
          inputTensorHandles.forEach((v) => wasm2._OrtReleaseTensor(v));
          outputTensorHandles.forEach((v) => wasm2._OrtReleaseTensor(v));
          inputOutputAllocs.forEach((p) => wasm2._free(p));
          if (runOptionsHandle !== 0) {
            wasm2._OrtReleaseRunOptions(runOptionsHandle);
          }
          runOptionsAllocs.forEach((p) => wasm2._free(p));
        }
      };
      endProfiling = (sessionId) => {
        const wasm2 = getInstance();
        const session = activeSessions.get(sessionId);
        if (!session) {
          throw new Error("invalid session id");
        }
        const sessionHandle = session[0];
        const profileFileName = wasm2._OrtEndProfiling(sessionHandle);
        if (profileFileName === 0) {
          checkLastError("Can't get an profile file name.");
        }
        wasm2._OrtFree(profileFileName);
      };
      extractTransferableBuffers = (tensors) => {
        const buffers = [];
        for (const tensor of tensors) {
          const data = tensor[2];
          if (!Array.isArray(data) && "buffer" in data) {
            buffers.push(data.buffer);
          }
        }
        return buffers;
      };
    }
  });

  // web/lib/wasm/proxy-wrapper.ts
  var isProxy, proxyWorker, initializing2, initialized2, aborted2, temporaryObjectUrl, initWasmCallbacks, queuedCallbacks, enqueueCallbacks, ensureWorker, onProxyWorkerMessage, initializeWebAssemblyAndOrtRuntime, initializeOrtEp, copyFromExternalBuffer2, createSession2, releaseSession2, run2, endProfiling2;
  var init_proxy_wrapper = __esm({
    "web/lib/wasm/proxy-wrapper.ts"() {
      "use strict";
      init_esm();
      init_wasm_core_impl();
      init_wasm_factory();
      init_wasm_utils_import();
      isProxy = () => !!env2.wasm.proxy && typeof document !== "undefined";
      initializing2 = false;
      initialized2 = false;
      aborted2 = false;
      queuedCallbacks = /* @__PURE__ */ new Map();
      enqueueCallbacks = (type, callbacks) => {
        const queue = queuedCallbacks.get(type);
        if (queue) {
          queue.push(callbacks);
        } else {
          queuedCallbacks.set(type, [callbacks]);
        }
      };
      ensureWorker = () => {
        if (initializing2 || !initialized2 || aborted2 || !proxyWorker) {
          throw new Error("worker not ready");
        }
      };
      onProxyWorkerMessage = (ev) => {
        switch (ev.data.type) {
          case "init-wasm":
            initializing2 = false;
            if (ev.data.err) {
              aborted2 = true;
              initWasmCallbacks[1](ev.data.err);
            } else {
              initialized2 = true;
              initWasmCallbacks[0]();
            }
            if (temporaryObjectUrl) {
              URL.revokeObjectURL(temporaryObjectUrl);
              temporaryObjectUrl = void 0;
            }
            break;
          case "init-ep":
          case "copy-from":
          case "create":
          case "release":
          case "run":
          case "end-profiling": {
            const callbacks = queuedCallbacks.get(ev.data.type);
            if (ev.data.err) {
              callbacks.shift()[1](ev.data.err);
            } else {
              callbacks.shift()[0](ev.data.out);
            }
            break;
          }
          default:
        }
      };
      initializeWebAssemblyAndOrtRuntime = async () => {
        if (initialized2) {
          return;
        }
        if (initializing2) {
          throw new Error("multiple calls to 'initWasm()' detected.");
        }
        if (aborted2) {
          throw new Error("previous call to 'initWasm()' failed.");
        }
        initializing2 = true;
        if (isProxy()) {
          return new Promise((resolve, reject) => {
            proxyWorker?.terminate();
            void importProxyWorker().then(([objectUrl, worker]) => {
              try {
                proxyWorker = worker;
                proxyWorker.onerror = (ev) => reject(ev);
                proxyWorker.onmessage = onProxyWorkerMessage;
                initWasmCallbacks = [resolve, reject];
                const message = { type: "init-wasm", in: env2 };
                proxyWorker.postMessage(message);
                temporaryObjectUrl = objectUrl;
              } catch (e) {
                reject(e);
              }
            }, reject);
          });
        } else {
          try {
            await initializeWebAssembly(env2.wasm);
            await initRuntime(env2);
            initialized2 = true;
          } catch (e) {
            aborted2 = true;
            throw e;
          } finally {
            initializing2 = false;
          }
        }
      };
      initializeOrtEp = async (epName) => {
        if (isProxy()) {
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("init-ep", [resolve, reject]);
            const message = { type: "init-ep", in: { epName, env: env2 } };
            proxyWorker.postMessage(message);
          });
        } else {
          await initEp(env2, epName);
        }
      };
      copyFromExternalBuffer2 = async (buffer) => {
        if (isProxy()) {
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("copy-from", [resolve, reject]);
            const message = { type: "copy-from", in: { buffer } };
            proxyWorker.postMessage(message, [buffer.buffer]);
          });
        } else {
          return copyFromExternalBuffer(buffer);
        }
      };
      createSession2 = async (model, options) => {
        if (isProxy()) {
          if (options?.preferredOutputLocation) {
            throw new Error('session option "preferredOutputLocation" is not supported for proxy.');
          }
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("create", [resolve, reject]);
            const message = { type: "create", in: { model, options: { ...options } } };
            const transferable = [];
            if (model instanceof Uint8Array) {
              transferable.push(model.buffer);
            }
            proxyWorker.postMessage(message, transferable);
          });
        } else {
          return createSession(model, options);
        }
      };
      releaseSession2 = async (sessionId) => {
        if (isProxy()) {
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("release", [resolve, reject]);
            const message = { type: "release", in: sessionId };
            proxyWorker.postMessage(message);
          });
        } else {
          releaseSession(sessionId);
        }
      };
      run2 = async (sessionId, inputIndices, inputs, outputIndices, outputs, options) => {
        if (isProxy()) {
          if (inputs.some((t) => t[3] !== "cpu")) {
            throw new Error("input tensor on GPU is not supported for proxy.");
          }
          if (outputs.some((t) => t)) {
            throw new Error("pre-allocated output tensor is not supported for proxy.");
          }
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("run", [resolve, reject]);
            const serializableInputs = inputs;
            const message = {
              type: "run",
              in: { sessionId, inputIndices, inputs: serializableInputs, outputIndices, options }
            };
            proxyWorker.postMessage(message, extractTransferableBuffers(serializableInputs));
          });
        } else {
          return run(sessionId, inputIndices, inputs, outputIndices, outputs, options);
        }
      };
      endProfiling2 = async (sessionId) => {
        if (isProxy()) {
          ensureWorker();
          return new Promise((resolve, reject) => {
            enqueueCallbacks("end-profiling", [resolve, reject]);
            const message = { type: "end-profiling", in: sessionId };
            proxyWorker.postMessage(message);
          });
        } else {
          endProfiling(sessionId);
        }
      };
    }
  });

  // web/lib/wasm/session-handler-inference.ts
  var encodeTensorMetadata, decodeTensorMetadata, OnnxruntimeWebAssemblySessionHandler;
  var init_session_handler_inference = __esm({
    "web/lib/wasm/session-handler-inference.ts"() {
      "use strict";
      init_esm();
      init_proxy_wrapper();
      init_wasm_common();
      init_wasm_utils_env();
      init_wasm_utils_load_file();
      encodeTensorMetadata = (tensor, getName) => {
        switch (tensor.location) {
          case "cpu":
            return [tensor.type, tensor.dims, tensor.data, "cpu"];
          case "gpu-buffer":
            return [tensor.type, tensor.dims, { gpuBuffer: tensor.gpuBuffer }, "gpu-buffer"];
          default:
            throw new Error(`invalid data location: ${tensor.location} for ${getName()}`);
        }
      };
      decodeTensorMetadata = (tensor) => {
        switch (tensor[3]) {
          case "cpu":
            return new Tensor2(tensor[0], tensor[2], tensor[1]);
          case "gpu-buffer": {
            const dataType = tensor[0];
            if (!isGpuBufferSupportedType(dataType)) {
              throw new Error(`not supported data type: ${dataType} for deserializing GPU tensor`);
            }
            const { gpuBuffer, download, dispose } = tensor[2];
            return Tensor2.fromGpuBuffer(gpuBuffer, { dataType, dims: tensor[1], download, dispose });
          }
          default:
            throw new Error(`invalid data location: ${tensor[3]}`);
        }
      };
      OnnxruntimeWebAssemblySessionHandler = class {
        async fetchModelAndCopyToWasmMemory(path) {
          return copyFromExternalBuffer2(await loadFile(path));
        }
        async loadModel(pathOrBuffer, options) {
          TRACE_FUNC_BEGIN();
          let model;
          if (typeof pathOrBuffer === "string") {
            if (isNode) {
              model = await loadFile(pathOrBuffer);
            } else {
              model = await this.fetchModelAndCopyToWasmMemory(pathOrBuffer);
            }
          } else {
            model = pathOrBuffer;
          }
          [this.sessionId, this.inputNames, this.outputNames] = await createSession2(model, options);
          TRACE_FUNC_END();
        }
        async dispose() {
          return releaseSession2(this.sessionId);
        }
        async run(feeds, fetches, options) {
          TRACE_FUNC_BEGIN();
          const inputArray = [];
          const inputIndices = [];
          Object.entries(feeds).forEach((kvp) => {
            const name = kvp[0];
            const tensor = kvp[1];
            const index = this.inputNames.indexOf(name);
            if (index === -1) {
              throw new Error(`invalid input '${name}'`);
            }
            inputArray.push(tensor);
            inputIndices.push(index);
          });
          const outputArray = [];
          const outputIndices = [];
          Object.entries(fetches).forEach((kvp) => {
            const name = kvp[0];
            const tensor = kvp[1];
            const index = this.outputNames.indexOf(name);
            if (index === -1) {
              throw new Error(`invalid output '${name}'`);
            }
            outputArray.push(tensor);
            outputIndices.push(index);
          });
          const inputs = inputArray.map(
            (t, i) => encodeTensorMetadata(t, () => `input "${this.inputNames[inputIndices[i]]}"`)
          );
          const outputs = outputArray.map(
            (t, i) => t ? encodeTensorMetadata(t, () => `output "${this.outputNames[outputIndices[i]]}"`) : null
          );
          const results = await run2(this.sessionId, inputIndices, inputs, outputIndices, outputs, options);
          const resultMap = {};
          for (let i = 0; i < results.length; i++) {
            resultMap[this.outputNames[outputIndices[i]]] = outputArray[i] ?? decodeTensorMetadata(results[i]);
          }
          TRACE_FUNC_END();
          return resultMap;
        }
        startProfiling() {
        }
        endProfiling() {
          void endProfiling2(this.sessionId);
        }
      };
    }
  });

  // web/lib/backend-wasm.ts
  var backend_wasm_exports = {};
  __export(backend_wasm_exports, {
    OnnxruntimeWebAssemblyBackend: () => OnnxruntimeWebAssemblyBackend,
    initializeFlags: () => initializeFlags,
    wasmBackend: () => wasmBackend
  });
  var initializeFlags, OnnxruntimeWebAssemblyBackend, wasmBackend;
  var init_backend_wasm = __esm({
    "web/lib/backend-wasm.ts"() {
      "use strict";
      init_esm();
      init_proxy_wrapper();
      init_session_handler_inference();
      init_wasm_utils_import();
      initializeFlags = () => {
        if (typeof env2.wasm.initTimeout !== "number" || env2.wasm.initTimeout < 0) {
          env2.wasm.initTimeout = 0;
        }
        if (env2.wasm.simd === false) {
          console.warn(
            'Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'
          );
        }
        if (typeof env2.wasm.proxy !== "boolean") {
          env2.wasm.proxy = false;
        }
        if (typeof env2.wasm.trace !== "boolean") {
          env2.wasm.trace = false;
        }
        if (typeof env2.wasm.numThreads !== "number" || !Number.isInteger(env2.wasm.numThreads) || env2.wasm.numThreads <= 0) {
          if (typeof self !== "undefined" && !self.crossOriginIsolated) {
            env2.wasm.numThreads = 1;
          } else {
            const numCpuLogicalCores = typeof navigator === "undefined" ? __require("node:os").cpus().length : navigator.hardwareConcurrency;
            env2.wasm.numThreads = Math.min(4, Math.ceil((numCpuLogicalCores || 1) / 2));
          }
        }
        if (true) {
          if (env2.wasm.wasmPaths === void 0 && scriptSrc && scriptSrc.indexOf("blob:") !== 0) {
            env2.wasm.wasmPaths = scriptSrc.substring(0, scriptSrc.lastIndexOf("/") + 1);
          }
        }
      };
      OnnxruntimeWebAssemblyBackend = class {
        /**
         * This function initializes the WebAssembly backend.
         *
         * This function will be called only once for each backend name. It will be called the first time when
         * `ort.InferenceSession.create()` is called with a registered backend name.
         *
         * @param backendName - the registered backend name.
         */
        async init(backendName) {
          initializeFlags();
          await initializeWebAssemblyAndOrtRuntime();
          await initializeOrtEp(backendName);
        }
        async createInferenceSessionHandler(pathOrBuffer, options) {
          const handler = new OnnxruntimeWebAssemblySessionHandler();
          await handler.loadModel(pathOrBuffer, options);
          return Promise.resolve(handler);
        }
      };
      wasmBackend = new OnnxruntimeWebAssemblyBackend();
    }
  });

  // web/lib/index.ts
  var lib_exports = {};
  __export(lib_exports, {
    InferenceSession: () => InferenceSession2,
    TRACE: () => TRACE,
    TRACE_FUNC_BEGIN: () => TRACE_FUNC_BEGIN,
    TRACE_FUNC_END: () => TRACE_FUNC_END,
    Tensor: () => Tensor2,
    TrainingSession: () => TrainingSession2,
    default: () => lib_default,
    env: () => env2,
    registerBackend: () => registerBackend
  });
  init_esm();
  init_esm();
  init_esm();

  // web/lib/version.ts
  var version2 = "1.20.0";

  // web/lib/index.ts
  var lib_default = esm_exports;
  if (false) {
    const onnxjsBackend = null.onnxjsBackend;
    registerBackend("webgl", onnxjsBackend, -10);
  }
  if (true) {
    const wasmBackend2 = (init_backend_wasm(), __toCommonJS(backend_wasm_exports)).wasmBackend;
    if (true) {
      registerBackend("webgpu", wasmBackend2, 5);
      registerBackend("webnn", wasmBackend2, 5);
    }
    registerBackend("cpu", wasmBackend2, 10);
    registerBackend("wasm", wasmBackend2, 10);
  }
  Object.defineProperty(env2.versions, "web", { value: version2, enumerable: true });
  return __toCommonJS(lib_exports);
})();
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
typeof exports=="object"&&typeof module=="object"&&(module.exports=ort);
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vY29tbW9uL2xpYi9iYWNrZW5kLWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi9iYWNrZW5kLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdmVyc2lvbi50cyIsICIuLi8uLi9jb21tb24vbGliL2Vudi1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvZW52LnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdGVuc29yLWNvbnZlcnNpb24taW1wbC50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1mYWN0b3J5LWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItaW1wbC10eXBlLW1hcHBpbmcudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItdXRpbHMtaW1wbC50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdGVuc29yLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvdHJhY2UudHMiLCAiLi4vLi4vY29tbW9uL2xpYi9pbmZlcmVuY2Utc2Vzc2lvbi1pbXBsLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvaW5mZXJlbmNlLXNlc3Npb24udHMiLCAiLi4vLi4vY29tbW9uL2xpYi90ZW5zb3ItY29udmVyc2lvbi50cyIsICIuLi8uLi9jb21tb24vbGliL3RlbnNvci1mYWN0b3J5LnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvb25ueC1tb2RlbC50cyIsICIuLi8uLi9jb21tb24vbGliL29ubngtdmFsdWUudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90cmFpbmluZy1zZXNzaW9uLWltcGwudHMiLCAiLi4vLi4vY29tbW9uL2xpYi90cmFpbmluZy1zZXNzaW9uLnRzIiwgIi4uLy4uL2NvbW1vbi9saWIvaW5kZXgudHMiLCAiLi4vbGliL3dhc20vd2FzbS11dGlscy1lbnYudHMiLCAiLi4vbGliL3dhc20vcHJveHktd29ya2VyL21haW4udHMiLCAiLi4vbGliL3dhc20vd2FzbS11dGlscy1pbXBvcnQudHMiLCAiLi4vbGliL3dhc20vd2FzbS1mYWN0b3J5LnRzIiwgIi4uL2xpYi93YXNtL3dhc20tdXRpbHMudHMiLCAiLi4vbGliL3dhc20vcnVuLW9wdGlvbnMudHMiLCAiLi4vbGliL3dhc20vc2Vzc2lvbi1vcHRpb25zLnRzIiwgIi4uL2xpYi93YXNtL3dhc20tY29tbW9uLnRzIiwgIi4uL2xpYi93YXNtL3dhc20tdXRpbHMtbG9hZC1maWxlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvbG9nLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvdGVuc29yLXZpZXcudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvdHlwZXMudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvZ3B1LWRhdGEtbWFuYWdlci50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXkudHMiLCAiLi4vbGliL3dhc20vanNlcC91dGlsLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9jb21tb24udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3RyYW5zcG9zZS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvcmVkdWNlLXNoYXJlZC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvcmVkdWNlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9hcmdtaW5tYXgudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2F0dGVudGlvbi50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvYmF0Y2gtbm9ybS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvYmlhcy1hZGQudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3VuYXJ5LW9wLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9iaWFzLXNwbGl0LWdlbHUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2JpbmFyeS1vcC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvY29uY2F0LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9mdXNlLXV0aWxzLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvYWN0aXZhdGlvbl91dGlsLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvY29udl91dGlsLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvbWF0bXVsX3BhY2tlZF93ZWJncHUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzLzNyZC1wYXJ0eS9jb252MmRfbW1fd2ViZ3B1LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy8zcmQtcGFydHkvY29udjNkX25haXZlX3dlYmdwdS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvY29udi1ncm91cGVkLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9tYXRtdWwudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2NvbnYudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzLzNyZC1wYXJ0eS9jb252X2JhY2twcm9wX21tX3dlYmdwdS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvM3JkLXBhcnR5L2NvbnZfYmFja3Byb3Bfd2ViZ3B1LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9jb252LXRyYW5zcG9zZS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvY3Vtc3VtLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9kZXB0aC10by1zcGFjZS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvZWluc3VtLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9leHBhbmQudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2Zhc3QtZ2VsdS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvZ2F0aGVyLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9nYXRoZXItYmxvY2stcXVhbnRpemVkLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9nYXRoZXItZWxlbWVudHMudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2dlbW0udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL211bHRpaGVhZC1hdHRlbnRpb24udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3RpbGUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL2dyb3VwLXF1ZXJ5LWF0dGVudGlvbi50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvaW5zdGFuY2Utbm9ybS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvbGF5ZXItbm9ybS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvbWF0bXVsbmJpdHMudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3BhZC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvcG9vbC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvcXVhbnRpemUtbGluZWFyLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9yYW5nZS50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvcmVzaXplLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9yb3RhcnktZW1iZWRkaW5nLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9za2lwLWxheWVyLW5vcm0udHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3BzL3NsaWNlLnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9zb2Z0bWF4LnRzIiwgIi4uL2xpYi93YXNtL2pzZXAvd2ViZ3B1L29wcy9zcGxpdC50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9vcHMvd2hlcmUudHMiLCAiLi4vbGliL3dhc20vanNlcC93ZWJncHUvb3AtcmVzb2x2ZS1ydWxlcy50cyIsICIuLi9saWIvd2FzbS9qc2VwL3dlYmdwdS9wcm9ncmFtLW1hbmFnZXIudHMiLCAiLi4vbGliL3dhc20vanNlcC9iYWNrZW5kLXdlYmdwdS50cyIsICIuLi9saWIvd2FzbS9qc2VwL2luaXQudHMiLCAiLi4vbGliL3dhc20vd2FzbS1jb3JlLWltcGwudHMiLCAiLi4vbGliL3dhc20vcHJveHktd3JhcHBlci50cyIsICIuLi9saWIvd2FzbS9zZXNzaW9uLWhhbmRsZXItaW5mZXJlbmNlLnRzIiwgIi4uL2xpYi9iYWNrZW5kLXdhc20udHMiLCAiLi4vbGliL2luZGV4LnRzIiwgIi4uL2xpYi92ZXJzaW9uLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgQmFja2VuZCB9IGZyb20gJy4vYmFja2VuZC5qcyc7XG5pbXBvcnQgeyBJbmZlcmVuY2VTZXNzaW9uIH0gZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi5qcyc7XG5cbmludGVyZmFjZSBCYWNrZW5kSW5mbyB7XG4gIGJhY2tlbmQ6IEJhY2tlbmQ7XG4gIHByaW9yaXR5OiBudW1iZXI7XG5cbiAgaW5pdFByb21pc2U/OiBQcm9taXNlPHZvaWQ+O1xuICBpbml0aWFsaXplZD86IGJvb2xlYW47XG4gIGFib3J0ZWQ/OiBib29sZWFuO1xuICBlcnJvcj86IHN0cmluZztcbn1cblxuY29uc3QgYmFja2VuZHM6IE1hcDxzdHJpbmcsIEJhY2tlbmRJbmZvPiA9IG5ldyBNYXAoKTtcbmNvbnN0IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eTogc3RyaW5nW10gPSBbXTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIGJhY2tlbmQuXG4gKlxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBhcyBhIGtleSB0byBsb29rdXAgYXMgYW4gZXhlY3V0aW9uIHByb3ZpZGVyLlxuICogQHBhcmFtIGJhY2tlbmQgLSB0aGUgYmFja2VuZCBvYmplY3QuXG4gKiBAcGFyYW0gcHJpb3JpdHkgLSBhbiBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIHByaW9yaXR5IG9mIHRoZSBiYWNrZW5kLiBIaWdoZXIgbnVtYmVyIG1lYW5zIGhpZ2hlciBwcmlvcml0eS4gaWYgcHJpb3JpdHlcbiAqIDwgMCwgaXQgd2lsbCBiZSBjb25zaWRlcmVkIGFzIGEgJ2JldGEnIHZlcnNpb24gYW5kIHdpbGwgbm90IGJlIHVzZWQgYXMgYSBmYWxsYmFjayBiYWNrZW5kIGJ5IGRlZmF1bHQuXG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJCYWNrZW5kID0gKG5hbWU6IHN0cmluZywgYmFja2VuZDogQmFja2VuZCwgcHJpb3JpdHk6IG51bWJlcik6IHZvaWQgPT4ge1xuICBpZiAoYmFja2VuZCAmJiB0eXBlb2YgYmFja2VuZC5pbml0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBiYWNrZW5kLmNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgY3VycmVudEJhY2tlbmQgPSBiYWNrZW5kcy5nZXQobmFtZSk7XG4gICAgaWYgKGN1cnJlbnRCYWNrZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGJhY2tlbmRzLnNldChuYW1lLCB7IGJhY2tlbmQsIHByaW9yaXR5IH0pO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudEJhY2tlbmQucHJpb3JpdHkgPiBwcmlvcml0eSkge1xuICAgICAgLy8gc2FtZSBuYW1lIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCB3aXRoIGEgaGlnaGVyIHByaW9yaXR5LiBza2lwIHJlZ2lzdGVyYXRpb24uXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChjdXJyZW50QmFja2VuZC5wcmlvcml0eSA9PT0gcHJpb3JpdHkpIHtcbiAgICAgIGlmIChjdXJyZW50QmFja2VuZC5iYWNrZW5kICE9PSBiYWNrZW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlZ2lzdGVyIGJhY2tlbmQgXCIke25hbWV9XCIgdXNpbmcgcHJpb3JpdHkgJHtwcmlvcml0eX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJpb3JpdHkgPj0gMCkge1xuICAgICAgY29uc3QgaSA9IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5pbmRleE9mKG5hbWUpO1xuICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgIGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChiYWNrZW5kcy5nZXQoYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5W2ldKSEucHJpb3JpdHkgPD0gcHJpb3JpdHkpIHtcbiAgICAgICAgICBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkuc3BsaWNlKGksIDAsIG5hbWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5LnB1c2gobmFtZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vdCBhIHZhbGlkIGJhY2tlbmQnKTtcbn07XG5cbi8qKlxuICogVHJ5IHRvIHJlc29sdmUgYW5kIGluaXRpYWxpemUgYSBiYWNrZW5kLlxuICpcbiAqIEBwYXJhbSBiYWNrZW5kTmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBiYWNrZW5kLlxuICogQHJldHVybnMgdGhlIGJhY2tlbmQgaW5zdGFuY2UgaWYgcmVzb2x2ZWQgYW5kIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseSwgb3IgYW4gZXJyb3IgbWVzc2FnZSBpZiBmYWlsZWQuXG4gKi9cbmNvbnN0IHRyeVJlc29sdmVBbmRJbml0aWFsaXplQmFja2VuZCA9IGFzeW5jIChiYWNrZW5kTmFtZTogc3RyaW5nKTogUHJvbWlzZTxCYWNrZW5kIHwgc3RyaW5nPiA9PiB7XG4gIGNvbnN0IGJhY2tlbmRJbmZvID0gYmFja2VuZHMuZ2V0KGJhY2tlbmROYW1lKTtcbiAgaWYgKCFiYWNrZW5kSW5mbykge1xuICAgIHJldHVybiAnYmFja2VuZCBub3QgZm91bmQuJztcbiAgfVxuXG4gIGlmIChiYWNrZW5kSW5mby5pbml0aWFsaXplZCkge1xuICAgIHJldHVybiBiYWNrZW5kSW5mby5iYWNrZW5kO1xuICB9IGVsc2UgaWYgKGJhY2tlbmRJbmZvLmFib3J0ZWQpIHtcbiAgICByZXR1cm4gYmFja2VuZEluZm8uZXJyb3IhO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGlzSW5pdGlhbGl6aW5nID0gISFiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICB0cnkge1xuICAgICAgaWYgKCFpc0luaXRpYWxpemluZykge1xuICAgICAgICBiYWNrZW5kSW5mby5pbml0UHJvbWlzZSA9IGJhY2tlbmRJbmZvLmJhY2tlbmQuaW5pdChiYWNrZW5kTmFtZSk7XG4gICAgICB9XG4gICAgICBhd2FpdCBiYWNrZW5kSW5mby5pbml0UHJvbWlzZTtcbiAgICAgIGJhY2tlbmRJbmZvLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBiYWNrZW5kSW5mby5iYWNrZW5kO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghaXNJbml0aWFsaXppbmcpIHtcbiAgICAgICAgYmFja2VuZEluZm8uZXJyb3IgPSBgJHtlfWA7XG4gICAgICAgIGJhY2tlbmRJbmZvLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhY2tlbmRJbmZvLmVycm9yITtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZGVsZXRlIGJhY2tlbmRJbmZvLmluaXRQcm9taXNlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZXNvbHZlIGV4ZWN1dGlvbiBwcm92aWRlcnMgZnJvbSB0aGUgc3BlY2lmaWMgc2Vzc2lvbiBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gdGhlIHNlc3Npb24gb3B0aW9ucyBvYmplY3QuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHR1cGxlIG9mIGFuIGluaXRpYWxpemVkIGJhY2tlbmQgaW5zdGFuY2UgYW5kIGEgc2Vzc2lvbiBvcHRpb25zIG9iamVjdCB3aXRoXG4gKiBmaWx0ZXJlZCBFUCBsaXN0LlxuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGNvbnN0IHJlc29sdmVCYWNrZW5kQW5kRXhlY3V0aW9uUHJvdmlkZXJzID0gYXN5bmMgKFxuICBvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLFxuKTogUHJvbWlzZTxbYmFja2VuZDogQmFja2VuZCwgb3B0aW9uczogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9uc10+ID0+IHtcbiAgLy8gZXh0cmFjdCBiYWNrZW5kIGhpbnRzIGZyb20gc2Vzc2lvbiBvcHRpb25zXG4gIGNvbnN0IGVwcyA9IG9wdGlvbnMuZXhlY3V0aW9uUHJvdmlkZXJzIHx8IFtdO1xuICBjb25zdCBiYWNrZW5kSGludHMgPSBlcHMubWFwKChpKSA9PiAodHlwZW9mIGkgPT09ICdzdHJpbmcnID8gaSA6IGkubmFtZSkpO1xuICBjb25zdCBiYWNrZW5kTmFtZXMgPSBiYWNrZW5kSGludHMubGVuZ3RoID09PSAwID8gYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5IDogYmFja2VuZEhpbnRzO1xuXG4gIC8vIHRyeSB0byByZXNvbHZlIGFuZCBpbml0aWFsaXplIGFsbCByZXF1ZXN0ZWQgYmFja2VuZHNcbiAgbGV0IGJhY2tlbmQ6IEJhY2tlbmQgfCB1bmRlZmluZWQ7XG4gIGNvbnN0IGVycm9ycyA9IFtdO1xuICBjb25zdCBhdmFpbGFibGVCYWNrZW5kTmFtZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgZm9yIChjb25zdCBiYWNrZW5kTmFtZSBvZiBiYWNrZW5kTmFtZXMpIHtcbiAgICBjb25zdCByZXNvbHZlUmVzdWx0ID0gYXdhaXQgdHJ5UmVzb2x2ZUFuZEluaXRpYWxpemVCYWNrZW5kKGJhY2tlbmROYW1lKTtcbiAgICBpZiAodHlwZW9mIHJlc29sdmVSZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvcnMucHVzaCh7IG5hbWU6IGJhY2tlbmROYW1lLCBlcnI6IHJlc29sdmVSZXN1bHQgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghYmFja2VuZCkge1xuICAgICAgICBiYWNrZW5kID0gcmVzb2x2ZVJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChiYWNrZW5kID09PSByZXNvbHZlUmVzdWx0KSB7XG4gICAgICAgIGF2YWlsYWJsZUJhY2tlbmROYW1lcy5hZGQoYmFja2VuZE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGlmIG5vIGJhY2tlbmQgaXMgYXZhaWxhYmxlLCB0aHJvdyBlcnJvci5cbiAgaWYgKCFiYWNrZW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBubyBhdmFpbGFibGUgYmFja2VuZCBmb3VuZC4gRVJSOiAke2Vycm9ycy5tYXAoKGUpID0+IGBbJHtlLm5hbWV9XSAke2UuZXJyfWApLmpvaW4oJywgJyl9YCk7XG4gIH1cblxuICAvLyBmb3IgZWFjaCBleHBsaWNpdGx5IHJlcXVlc3RlZCBiYWNrZW5kLCBpZiBpdCdzIG5vdCBhdmFpbGFibGUsIG91dHB1dCB3YXJuaW5nIG1lc3NhZ2UuXG4gIGZvciAoY29uc3QgeyBuYW1lLCBlcnIgfSBvZiBlcnJvcnMpIHtcbiAgICBpZiAoYmFja2VuZEhpbnRzLmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgcmVtb3ZpbmcgcmVxdWVzdGVkIGV4ZWN1dGlvbiBwcm92aWRlciBcIiR7bmFtZX1cIiBmcm9tIHNlc3Npb24gb3B0aW9ucyBiZWNhdXNlIGl0IGlzIG5vdCBhdmFpbGFibGU6ICR7ZXJyfWAsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGZpbHRlcmVkRXBzID0gZXBzLmZpbHRlcigoaSkgPT4gYXZhaWxhYmxlQmFja2VuZE5hbWVzLmhhcyh0eXBlb2YgaSA9PT0gJ3N0cmluZycgPyBpIDogaS5uYW1lKSk7XG5cbiAgcmV0dXJuIFtcbiAgICBiYWNrZW5kLFxuICAgIG5ldyBQcm94eShvcHRpb25zLCB7XG4gICAgICBnZXQ6ICh0YXJnZXQsIHByb3ApID0+IHtcbiAgICAgICAgaWYgKHByb3AgPT09ICdleGVjdXRpb25Qcm92aWRlcnMnKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbHRlcmVkRXBzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3ApO1xuICAgICAgfSxcbiAgICB9KSxcbiAgXTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gfSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLmpzJztcbmltcG9ydCB7IE9ubnhWYWx1ZSB9IGZyb20gJy4vb25ueC12YWx1ZS5qcyc7XG5pbXBvcnQgeyBUcmFpbmluZ1Nlc3Npb24gfSBmcm9tICcuL3RyYWluaW5nLXNlc3Npb24uanMnO1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFNlc3Npb25IYW5kbGVyIHtcbiAgdHlwZSBGZWVkc1R5cGUgPSB7IFtuYW1lOiBzdHJpbmddOiBPbm54VmFsdWUgfTtcbiAgdHlwZSBGZXRjaGVzVHlwZSA9IHsgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB8IG51bGwgfTtcbiAgdHlwZSBSZXR1cm5UeXBlID0geyBbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlIH07XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBzaGFyZWQgU2Vzc2lvbkhhbmRsZXIgZnVuY3Rpb25hbGl0eVxuICpcbiAqIEBpZ25vcmVcbiAqL1xuaW50ZXJmYWNlIFNlc3Npb25IYW5kbGVyIHtcbiAgZGlzcG9zZSgpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIHJlYWRvbmx5IGlucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuICByZWFkb25seSBvdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG59XG5cbi8qKlxuICogUmVwcmVzZW50IGEgaGFuZGxlciBpbnN0YW5jZSBvZiBhbiBpbmZlcmVuY2Ugc2Vzc2lvbi5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIgZXh0ZW5kcyBTZXNzaW9uSGFuZGxlciB7XG4gIHN0YXJ0UHJvZmlsaW5nKCk6IHZvaWQ7XG4gIGVuZFByb2ZpbGluZygpOiB2b2lkO1xuXG4gIHJ1bihcbiAgICBmZWVkczogU2Vzc2lvbkhhbmRsZXIuRmVlZHNUeXBlLFxuICAgIGZldGNoZXM6IFNlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlLFxuICAgIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlPjtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBoYW5kbGVyIGluc3RhbmNlIG9mIGEgdHJhaW5pbmcgaW5mZXJlbmNlIHNlc3Npb24uXG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYWluaW5nU2Vzc2lvbkhhbmRsZXIgZXh0ZW5kcyBTZXNzaW9uSGFuZGxlciB7XG4gIHJlYWRvbmx5IGV2YWxJbnB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcbiAgcmVhZG9ubHkgZXZhbE91dHB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICBsYXp5UmVzZXRHcmFkKCk6IFByb21pc2U8dm9pZD47XG4gIHJ1blRyYWluU3RlcChcbiAgICBmZWVkczogU2Vzc2lvbkhhbmRsZXIuRmVlZHNUeXBlLFxuICAgIGZldGNoZXM6IFNlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlLFxuICAgIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlPjtcbiAgcnVuT3B0aW1pemVyU3RlcChvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+O1xuICBydW5FdmFsU3RlcChcbiAgICBmZWVkczogU2Vzc2lvbkhhbmRsZXIuRmVlZHNUeXBlLFxuICAgIGZldGNoZXM6IFNlc3Npb25IYW5kbGVyLkZldGNoZXNUeXBlLFxuICAgIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxTZXNzaW9uSGFuZGxlci5SZXR1cm5UeXBlPjtcblxuICBnZXRQYXJhbWV0ZXJzU2l6ZSh0cmFpbmFibGVPbmx5OiBib29sZWFuKTogUHJvbWlzZTxudW1iZXI+O1xuICBsb2FkUGFyYW1ldGVyc0J1ZmZlcihidWZmZXI6IFVpbnQ4QXJyYXksIHRyYWluYWJsZU9ubHk6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+O1xuICBnZXRDb250aWd1b3VzUGFyYW1ldGVycyh0cmFpbmFibGVPbmx5OiBib29sZWFuKTogUHJvbWlzZTxPbm54VmFsdWU+O1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIGJhY2tlbmQgdGhhdCBwcm92aWRlcyBpbXBsZW1lbnRhdGlvbiBvZiBtb2RlbCBpbmZlcmVuY2luZy5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmFja2VuZCB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBiYWNrZW5kIGFzeW5jaHJvbm91c2x5LiBTaG91bGQgdGhyb3cgd2hlbiBmYWlsZWQuXG4gICAqL1xuICBpbml0KGJhY2tlbmROYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKFxuICAgIHVyaU9yQnVmZmVyOiBzdHJpbmcgfCBVaW50OEFycmF5LFxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLFxuICApOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25IYW5kbGVyPjtcblxuICBjcmVhdGVUcmFpbmluZ1Nlc3Npb25IYW5kbGVyPyhcbiAgICBjaGVja3BvaW50U3RhdGVVcmlPckJ1ZmZlcjogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyLFxuICAgIHRyYWluTW9kZWxVcmlPckJ1ZmZlcjogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyLFxuICAgIGV2YWxNb2RlbFVyaU9yQnVmZmVyOiBUcmFpbmluZ1Nlc3Npb24uVXJpT3JCdWZmZXIsXG4gICAgb3B0aW1pemVyTW9kZWxVcmlPckJ1ZmZlcjogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyLFxuICAgIG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMsXG4gICk6IFByb21pc2U8VHJhaW5pbmdTZXNzaW9uSGFuZGxlcj47XG59XG5cbmV4cG9ydCB7IHJlZ2lzdGVyQmFja2VuZCB9IGZyb20gJy4vYmFja2VuZC1pbXBsLmpzJztcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSAvanMvc2NyaXB0cy91cGRhdGUtdmVyc2lvbi50c1xuLy8gRG8gbm90IG1vZGlmeSBmaWxlIGNvbnRlbnQgbWFudWFsbHkuXG5cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzEuMjAuMCc7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEVudiB9IGZyb20gJy4vZW52LmpzJztcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24uanMnO1xuXG50eXBlIExvZ0xldmVsVHlwZSA9IEVudlsnbG9nTGV2ZWwnXTtcblxubGV0IGxvZ0xldmVsVmFsdWU6IFJlcXVpcmVkPExvZ0xldmVsVHlwZT4gPSAnd2FybmluZyc7XG5cbmV4cG9ydCBjb25zdCBlbnY6IEVudiA9IHtcbiAgd2FzbToge30gYXMgRW52LldlYkFzc2VtYmx5RmxhZ3MsXG4gIHdlYmdsOiB7fSBhcyBFbnYuV2ViR0xGbGFncyxcbiAgd2ViZ3B1OiB7fSBhcyBFbnYuV2ViR3B1RmxhZ3MsXG4gIHZlcnNpb25zOiB7IGNvbW1vbjogdmVyc2lvbiB9LFxuXG4gIHNldCBsb2dMZXZlbCh2YWx1ZTogTG9nTGV2ZWxUeXBlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgWyd2ZXJib3NlJywgJ2luZm8nLCAnd2FybmluZycsICdlcnJvcicsICdmYXRhbCddLmluZGV4T2YodmFsdWUpID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke3ZhbHVlfWApO1xuICAgIH1cbiAgICBsb2dMZXZlbFZhbHVlID0gdmFsdWU7XG4gIH0sXG4gIGdldCBsb2dMZXZlbCgpOiBSZXF1aXJlZDxMb2dMZXZlbFR5cGU+IHtcbiAgICByZXR1cm4gbG9nTGV2ZWxWYWx1ZTtcbiAgfSxcbn07XG5cbi8vIHNldCBwcm9wZXJ0eSAnbG9nTGV2ZWwnIHNvIHRoYXQgdGhleSBjYW4gYmUgY29ycmVjdGx5IHRyYW5zZmVycmVkIHRvIHdvcmtlciBieSBgcG9zdE1lc3NhZ2UoKWAuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZW52LCAnbG9nTGV2ZWwnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IGVudiBhcyBlbnZJbXBsIH0gZnJvbSAnLi9lbnYtaW1wbC5qcyc7XG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBFbnYge1xuICBleHBvcnQgdHlwZSBXYXNtUGF0aFByZWZpeCA9IHN0cmluZztcbiAgZXhwb3J0IGludGVyZmFjZSBXYXNtRmlsZVBhdGhzIHtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHRoZSBvdmVycmlkZSBwYXRoIGZvciB0aGUgbWFpbiAud2FzbSBmaWxlLlxuICAgICAqXG4gICAgICogVGhpcyBwYXRoIHNob3VsZCBiZSBhbiBhYnNvbHV0ZSBwYXRoLlxuICAgICAqXG4gICAgICogSWYgbm90IG1vZGlmaWVkLCB0aGUgZmlsZW5hbWUgb2YgdGhlIC53YXNtIGZpbGUgaXM6XG4gICAgICogLSBgb3J0LXdhc20tc2ltZC10aHJlYWRlZC53YXNtYCBmb3IgZGVmYXVsdCBidWlsZFxuICAgICAqIC0gYG9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtYCBmb3IgSlNFUCBidWlsZCAod2l0aCBXZWJHUFUgYW5kIFdlYk5OKVxuICAgICAqIC0gYG9ydC10cmFpbmluZy13YXNtLXNpbWQtdGhyZWFkZWQud2FzbWAgZm9yIHRyYWluaW5nIGJ1aWxkXG4gICAgICovXG4gICAgd2FzbT86IFVSTCB8IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHRoZSBvdmVycmlkZSBwYXRoIGZvciB0aGUgbWFpbiAubWpzIGZpbGUuXG4gICAgICpcbiAgICAgKiBUaGlzIHBhdGggc2hvdWxkIGJlIGFuIGFic29sdXRlIHBhdGguXG4gICAgICpcbiAgICAgKiBJZiBub3QgbW9kaWZpZWQsIHRoZSBmaWxlbmFtZSBvZiB0aGUgLm1qcyBmaWxlIGlzOlxuICAgICAqIC0gYG9ydC13YXNtLXNpbWQtdGhyZWFkZWQubWpzYCBmb3IgZGVmYXVsdCBidWlsZFxuICAgICAqIC0gYG9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC5tanNgIGZvciBKU0VQIGJ1aWxkICh3aXRoIFdlYkdQVSBhbmQgV2ViTk4pXG4gICAgICogLSBgb3J0LXRyYWluaW5nLXdhc20tc2ltZC10aHJlYWRlZC5tanNgIGZvciB0cmFpbmluZyBidWlsZFxuICAgICAqL1xuICAgIG1qcz86IFVSTCB8IHN0cmluZztcbiAgfVxuICBleHBvcnQgdHlwZSBXYXNtUHJlZml4T3JGaWxlUGF0aHMgPSBXYXNtUGF0aFByZWZpeCB8IFdhc21GaWxlUGF0aHM7XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViQXNzZW1ibHlGbGFncyB7XG4gICAgLyoqXG4gICAgICogc2V0IG9yIGdldCBudW1iZXIgb2YgdGhyZWFkKHMpLiBJZiBvbWl0dGVkIG9yIHNldCB0byAwLCBudW1iZXIgb2YgdGhyZWFkKHMpIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSBzeXN0ZW0uIElmIHNldFxuICAgICAqIHRvIDEsIG5vIHdvcmtlciB0aHJlYWQgd2lsbCBiZSBzcGF3bmVkLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IHdoZW4gV2ViQXNzZW1ibHkgbXVsdGl0aHJlYWQgZmVhdHVyZSBpcyBhdmFpbGFibGUgaW4gY3VycmVudCBjb250ZXh0LlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgMGBcbiAgICAgKi9cbiAgICBudW1UaHJlYWRzPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogc2V0IG9yIGdldCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRvIGVuYWJsZSBTSU1ELiBJZiBzZXQgdG8gZmFsc2UsIFNJTUQgd2lsbCBiZSBmb3JjZWx5IGRpc2FibGVkLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IHdoZW4gV2ViQXNzZW1ibHkgU0lNRCBmZWF0dXJlIGlzIGF2YWlsYWJsZSBpbiBjdXJyZW50IGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQuIFNpbmNlIFNJTUQgaXMgc3VwcG9ydGVkIGJ5IGFsbCBtYWpvciBKYXZhU2NyaXB0IGVuZ2luZXMsIG5vbi1TSU1EXG4gICAgICogYnVpbGQgaXMgbm8gbG9uZ2VyIHByb3ZpZGVkLiBUaGlzIHByb3BlcnR5IHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZS5cbiAgICAgKiBAZGVmYXVsdFZhbHVlIGB0cnVlYFxuICAgICAqL1xuICAgIHNpbWQ/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogc2V0IG9yIGdldCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRvIGVuYWJsZSB0cmFjZS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgZW52LnRyYWNlYCBpbnN0ZWFkLiBJZiBgZW52LnRyYWNlYCBpcyBzZXQsIHRoaXMgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgICAqL1xuICAgIHRyYWNlPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgYSBudW1iZXIgc3BlY2lmeWluZyB0aGUgdGltZW91dCBmb3IgaW5pdGlhbGl6YXRpb24gb2YgV2ViQXNzZW1ibHkgYmFja2VuZCwgaW4gbWlsbGlzZWNvbmRzLiBBIHplcm9cbiAgICAgKiB2YWx1ZSBpbmRpY2F0ZXMgbm8gdGltZW91dCBpcyBzZXQuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGAwYFxuICAgICAqL1xuICAgIGluaXRUaW1lb3V0PzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogU2V0IGEgY3VzdG9tIFVSTCBwcmVmaXggdG8gdGhlIC53YXNtLy5tanMgZmlsZXMsIG9yIGFuIG9iamVjdCBvZiBvdmVycmlkZXMgZm9yIGJvdGggLndhc20vLm1qcyBmaWxlLiBUaGUgb3ZlcnJpZGVcbiAgICAgKiBwYXRoIHNob3VsZCBiZSBhbiBhYnNvbHV0ZSBwYXRoLlxuICAgICAqL1xuICAgIHdhc21QYXRocz86IFdhc21QcmVmaXhPckZpbGVQYXRocztcblxuICAgIC8qKlxuICAgICAqIFNldCBhIGN1c3RvbSBidWZmZXIgd2hpY2ggY29udGFpbnMgdGhlIFdlYkFzc2VtYmx5IGJpbmFyeS4gSWYgdGhpcyBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBgd2FzbVBhdGhzYCBwcm9wZXJ0eSB3aWxsXG4gICAgICogYmUgaWdub3JlZC5cbiAgICAgKi9cbiAgICB3YXNtQmluYXJ5PzogQXJyYXlCdWZmZXJMaWtlIHwgVWludDhBcnJheTtcblxuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgYSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0byBwcm94eSB0aGUgZXhlY3V0aW9uIG9mIG1haW4gdGhyZWFkIHRvIGEgd29ya2VyIHRocmVhZC5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgICAqL1xuICAgIHByb3h5PzogYm9vbGVhbjtcbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR0xGbGFncyB7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgV2ViR0wgQ29udGV4dCBJRCAod2ViZ2wgb3Igd2ViZ2wyKS5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYCd3ZWJnbDInYFxuICAgICAqL1xuICAgIGNvbnRleHRJZD86ICd3ZWJnbCcgfCAnd2ViZ2wyJztcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIFdlYkdMIHJlbmRlcmluZyBjb250ZXh0LlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGNvbnRleHQ6IFdlYkdMUmVuZGVyaW5nQ29udGV4dDtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBtYXhpbXVtIGJhdGNoIHNpemUgZm9yIG1hdG11bC4gMCBtZWFucyB0byBkaXNhYmxlIGJhdGNoaW5nLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBtYXRtdWxNYXhCYXRjaFNpemU/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgdGV4dHVyZSBjYWNoZSBtb2RlLlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgJ2Z1bGwnYFxuICAgICAqL1xuICAgIHRleHR1cmVDYWNoZU1vZGU/OiAnaW5pdGlhbGl6ZXJPbmx5JyB8ICdmdWxsJztcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBwYWNrZWQgdGV4dHVyZSBtb2RlXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICAgKi9cbiAgICBwYWNrPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHdoZXRoZXIgZW5hYmxlIGFzeW5jIGRvd25sb2FkLlxuICAgICAqXG4gICAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAgICovXG4gICAgYXN5bmM/OiBib29sZWFuO1xuICB9XG5cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJHcHVQcm9maWxpbmdEYXRhVjFUZW5zb3JNZXRhZGF0YSB7XG4gICAgZGltczogcmVhZG9ubHkgbnVtYmVyW107XG4gICAgZGF0YVR5cGU6IHN0cmluZztcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkdwdVByb2ZpbGluZ0RhdGFWMSB7XG4gICAgdmVyc2lvbjogMTtcbiAgICBpbnB1dHNNZXRhZGF0YTogcmVhZG9ubHkgV2ViR3B1UHJvZmlsaW5nRGF0YVYxVGVuc29yTWV0YWRhdGFbXTtcbiAgICBvdXRwdXRzTWV0YWRhdGE6IHJlYWRvbmx5IFdlYkdwdVByb2ZpbGluZ0RhdGFWMVRlbnNvck1ldGFkYXRhW107XG4gICAga2VybmVsSWQ6IG51bWJlcjtcbiAgICBrZXJuZWxUeXBlOiBzdHJpbmc7XG4gICAga2VybmVsTmFtZTogc3RyaW5nO1xuICAgIHByb2dyYW1OYW1lOiBzdHJpbmc7XG4gICAgc3RhcnRUaW1lOiBudW1iZXI7XG4gICAgZW5kVGltZTogbnVtYmVyO1xuICB9XG5cbiAgZXhwb3J0IHR5cGUgV2ViR3B1UHJvZmlsaW5nRGF0YSA9IFdlYkdwdVByb2ZpbGluZ0RhdGFWMTtcblxuICBleHBvcnQgaW50ZXJmYWNlIFdlYkdwdUZsYWdzIHtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBwcm9maWxpbmcgbW9kZS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgZW52LndlYmdwdS5wcm9maWxpbmcubW9kZWAgaW5zdGVhZC4gSWYgYGVudi53ZWJncHUucHJvZmlsaW5nLm1vZGVgIGlzIHNldCwgdGhpcyBwcm9wZXJ0eSB3aWxsIGJlXG4gICAgICogaWdub3JlZC5cbiAgICAgKi9cbiAgICBwcm9maWxpbmdNb2RlPzogJ29mZicgfCAnZGVmYXVsdCc7XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgcHJvZmlsaW5nIGNvbmZpZ3VyYXRpb24uXG4gICAgICovXG4gICAgcHJvZmlsaW5nPzoge1xuICAgICAgLyoqXG4gICAgICAgKiBTZXQgb3IgZ2V0IHRoZSBwcm9maWxpbmcgbW9kZS5cbiAgICAgICAqXG4gICAgICAgKiBAZGVmYXVsdFZhbHVlIGAnb2ZmJ2BcbiAgICAgICAqL1xuICAgICAgbW9kZT86ICdvZmYnIHwgJ2RlZmF1bHQnO1xuXG4gICAgICAvKipcbiAgICAgICAqIFNldCBvciBnZXQgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIGEgcHJvZmlsaW5nIGRhdGEgaXMgcmVjZWl2ZWQuIElmIG5vdCBzZXQsIHRoZSBwcm9maWxpbmcgZGF0YSB3aWxsIGJlXG4gICAgICAgKiBwcmludGVkIHRvIGNvbnNvbGUuXG4gICAgICAgKi9cbiAgICAgIG9uZGF0YT86IChkYXRhOiBXZWJHcHVQcm9maWxpbmdEYXRhKSA9PiB2b2lkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IG9yIGdldCB0aGUgcG93ZXIgcHJlZmVyZW5jZS5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSBvbmx5IGhhcyBlZmZlY3QgYmVmb3JlIHRoZSBmaXJzdCBXZWJHUFUgaW5mZXJlbmNlIHNlc3Npb24gaXMgY3JlYXRlZC4gVGhlIHZhbHVlIHdpbGwgYmVcbiAgICAgKiB1c2VkIGFzIG9wdGlvbnMgZm9yIGBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKClgLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBodHRwczovL2dwdXdlYi5naXRodWIuaW8vZ3B1d2ViLyNkaWN0ZGVmLWdwdXJlcXVlc3RhZGFwdGVyb3B0aW9uc30gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYHVuZGVmaW5lZGBcbiAgICAgKi9cbiAgICBwb3dlclByZWZlcmVuY2U/OiAnbG93LXBvd2VyJyB8ICdoaWdoLXBlcmZvcm1hbmNlJztcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHRoZSBmb3JjZSBmYWxsYmFjayBhZGFwdGVyIGZsYWcuXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgb25seSBoYXMgZWZmZWN0IGJlZm9yZSB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuIFRoZSB2YWx1ZSB3aWxsIGJlXG4gICAgICogdXNlZCBhcyBvcHRpb25zIGZvciBgbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcigpYC5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9ncHV3ZWIuZ2l0aHViLmlvL2dwdXdlYi8jZGljdGRlZi1ncHVyZXF1ZXN0YWRhcHRlcm9wdGlvbnN9IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdFZhbHVlIGB1bmRlZmluZWRgXG4gICAgICovXG4gICAgZm9yY2VGYWxsYmFja0FkYXB0ZXI/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNldCBvciBnZXQgdGhlIGFkYXB0ZXIgZm9yIFdlYkdQVS5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSBvbmx5IGhhcyBlZmZlY3QgYmVmb3JlIHRoZSBmaXJzdCBXZWJHUFUgaW5mZXJlbmNlIHNlc3Npb24gaXMgY3JlYXRlZC4gVGhlIHZhbHVlIHdpbGwgYmVcbiAgICAgKiB1c2VkIGFzIHRoZSBHUFUgYWRhcHRlciBmb3IgdGhlIHVuZGVybHlpbmcgV2ViR1BVIGJhY2tlbmQgdG8gY3JlYXRlIEdQVSBkZXZpY2UuXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIHByb3BlcnR5IGlzIG5vdCBzZXQsIGl0IHdpbGwgYmUgYXZhaWxhYmxlIHRvIGdldCBhZnRlciB0aGUgZmlyc3QgV2ViR1BVIGluZmVyZW5jZSBzZXNzaW9uIGlzIGNyZWF0ZWQuIFRoZVxuICAgICAqIHZhbHVlIHdpbGwgYmUgdGhlIEdQVSBhZGFwdGVyIHRoYXQgY3JlYXRlZCBieSB0aGUgdW5kZXJseWluZyBXZWJHUFUgYmFja2VuZC5cbiAgICAgKlxuICAgICAqIFdoZW4gdXNlIHdpdGggVHlwZVNjcmlwdCwgdGhlIHR5cGUgb2YgdGhpcyBwcm9wZXJ0eSBpcyBgR1BVQWRhcHRlcmAgZGVmaW5lZCBpbiBcIkB3ZWJncHUvdHlwZXNcIi5cbiAgICAgKiBVc2UgYGNvbnN0IGFkYXB0ZXIgPSBlbnYud2ViZ3B1LmFkYXB0ZXIgYXMgR1BVQWRhcHRlcjtgIGluIFR5cGVTY3JpcHQgdG8gYWNjZXNzIHRoaXMgcHJvcGVydHkgd2l0aCBjb3JyZWN0IHR5cGUuXG4gICAgICpcbiAgICAgKiBzZWUgY29tbWVudHMgb24ge0BsaW5rIFRlbnNvci5HcHVCdWZmZXJUeXBlfVxuICAgICAqL1xuICAgIGFkYXB0ZXI6IHVua25vd247XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkZXZpY2UgZm9yIFdlYkdQVS5cbiAgICAgKlxuICAgICAqIFRoaXMgcHJvcGVydHkgaXMgb25seSBhdmFpbGFibGUgYWZ0ZXIgdGhlIGZpcnN0IFdlYkdQVSBpbmZlcmVuY2Ugc2Vzc2lvbiBpcyBjcmVhdGVkLlxuICAgICAqXG4gICAgICogV2hlbiB1c2Ugd2l0aCBUeXBlU2NyaXB0LCB0aGUgdHlwZSBvZiB0aGlzIHByb3BlcnR5IGlzIGBHUFVEZXZpY2VgIGRlZmluZWQgaW4gXCJAd2ViZ3B1L3R5cGVzXCIuXG4gICAgICogVXNlIGBjb25zdCBkZXZpY2UgPSBlbnYud2ViZ3B1LmRldmljZSBhcyBHUFVEZXZpY2U7YCBpbiBUeXBlU2NyaXB0IHRvIGFjY2VzcyB0aGlzIHByb3BlcnR5IHdpdGggY29ycmVjdCB0eXBlLlxuICAgICAqXG4gICAgICogc2VlIGNvbW1lbnRzIG9uIHtAbGluayBUZW5zb3IuR3B1QnVmZmVyVHlwZX0gZm9yIG1vcmUgZGV0YWlscyBhYm91dCB3aHkgbm90IHVzZSB0eXBlcyBkZWZpbmVkIGluIFwiQHdlYmdwdS90eXBlc1wiLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGRldmljZTogdW5rbm93bjtcbiAgICAvKipcbiAgICAgKiBTZXQgb3IgZ2V0IHdoZXRoZXIgdmFsaWRhdGUgaW5wdXQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0VmFsdWUgYGZhbHNlYFxuICAgICAqL1xuICAgIHZhbGlkYXRlSW5wdXRDb250ZW50PzogYm9vbGVhbjtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVudiB7XG4gIC8qKlxuICAgKiBzZXQgdGhlIHNldmVyaXR5IGxldmVsIGZvciBsb2dnaW5nLlxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGAnd2FybmluZydgXG4gICAqL1xuICBsb2dMZXZlbD86ICd2ZXJib3NlJyB8ICdpbmZvJyB8ICd3YXJuaW5nJyB8ICdlcnJvcicgfCAnZmF0YWwnO1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZSB3aGV0aGVyIHJ1biBpbiBkZWJ1ZyBtb2RlLlxuICAgKlxuICAgKiBAZGVmYXVsdFZhbHVlIGBmYWxzZWBcbiAgICovXG4gIGRlYnVnPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogc2V0IG9yIGdldCBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRvIGVuYWJsZSB0cmFjZS5cbiAgICpcbiAgICogQGRlZmF1bHRWYWx1ZSBgZmFsc2VgXG4gICAqL1xuICB0cmFjZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEdldCB2ZXJzaW9uIG9mIHRoZSBjdXJyZW50IHBhY2thZ2UuXG4gICAqL1xuICByZWFkb25seSB2ZXJzaW9uczoge1xuICAgIHJlYWRvbmx5IGNvbW1vbjogc3RyaW5nO1xuICAgIHJlYWRvbmx5IHdlYj86IHN0cmluZztcbiAgICByZWFkb25seSBub2RlPzogc3RyaW5nO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgICByZWFkb25seSAncmVhY3QtbmF0aXZlJz86IHN0cmluZztcbiAgfTtcblxuICAvKipcbiAgICogUmVwcmVzZW50IGEgc2V0IG9mIGZsYWdzIGZvciBXZWJBc3NlbWJseVxuICAgKi9cbiAgcmVhZG9ubHkgd2FzbTogRW52LldlYkFzc2VtYmx5RmxhZ3M7XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudCBhIHNldCBvZiBmbGFncyBmb3IgV2ViR0xcbiAgICovXG4gIHJlYWRvbmx5IHdlYmdsOiBFbnYuV2ViR0xGbGFncztcblxuICAvKipcbiAgICogUmVwcmVzZW50IGEgc2V0IG9mIGZsYWdzIGZvciBXZWJHUFVcbiAgICovXG4gIHJlYWRvbmx5IHdlYmdwdTogRW52LldlYkdwdUZsYWdzO1xuXG4gIFtuYW1lOiBzdHJpbmddOiB1bmtub3duO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBhIHNldCBvZiBmbGFncyBhcyBhIGdsb2JhbCBzaW5nbGV0b24uXG4gKi9cbmV4cG9ydCBjb25zdCBlbnY6IEVudiA9IGVudkltcGw7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvclRvRGF0YVVybE9wdGlvbnMsIFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyB9IGZyb20gJy4vdGVuc29yLWNvbnZlcnNpb24uanMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3IuanMnO1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci50b0RhdGFVUkwoKVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yVG9EYXRhVVJMID0gKHRlbnNvcjogVGVuc29yLCBvcHRpb25zPzogVGVuc29yVG9EYXRhVXJsT3B0aW9ucyk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGNhbnZhcyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSA6IG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSk7XG4gIGNhbnZhcy53aWR0aCA9IHRlbnNvci5kaW1zWzNdO1xuICBjYW52YXMuaGVpZ2h0ID0gdGVuc29yLmRpbXNbMl07XG4gIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIGFzXG4gICAgfCBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcbiAgICB8IE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFxuICAgIHwgbnVsbDtcblxuICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcbiAgICAvLyBEZWZhdWx0IHZhbHVlcyBmb3IgaGVpZ2h0IGFuZCB3aWR0aCAmIGZvcm1hdFxuICAgIGxldCB3aWR0aDogbnVtYmVyO1xuICAgIGxldCBoZWlnaHQ6IG51bWJlcjtcbiAgICBpZiAob3B0aW9ucz8udGVuc29yTGF5b3V0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy50ZW5zb3JMYXlvdXQgPT09ICdOSFdDJykge1xuICAgICAgd2lkdGggPSB0ZW5zb3IuZGltc1syXTtcbiAgICAgIGhlaWdodCA9IHRlbnNvci5kaW1zWzNdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWZhdWx0IGxheW91dCBpcyBOQ1dIXG4gICAgICB3aWR0aCA9IHRlbnNvci5kaW1zWzNdO1xuICAgICAgaGVpZ2h0ID0gdGVuc29yLmRpbXNbMl07XG4gICAgfVxuXG4gICAgY29uc3QgaW5wdXRmb3JtYXQgPSBvcHRpb25zPy5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZm9ybWF0IDogJ1JHQic7XG5cbiAgICBjb25zdCBub3JtID0gb3B0aW9ucz8ubm9ybTtcbiAgICBsZXQgbm9ybU1lYW46IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICAgIGxldCBub3JtQmlhczogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gICAgaWYgKG5vcm0gPT09IHVuZGVmaW5lZCB8fCBub3JtLm1lYW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9ybU1lYW4gPSBbMjU1LCAyNTUsIDI1NSwgMjU1XTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBub3JtLm1lYW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5vcm1NZWFuID0gW25vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW5bMF0sIG5vcm0ubWVhblsxXSwgbm9ybS5tZWFuWzJdLCAwXTtcbiAgICAgICAgaWYgKG5vcm0ubWVhblszXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9ybU1lYW5bM10gPSBub3JtLm1lYW5bM107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vcm0gPT09IHVuZGVmaW5lZCB8fCBub3JtLmJpYXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9ybUJpYXMgPSBbMCwgMCwgMCwgMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2Ygbm9ybS5iaWFzID09PSAnbnVtYmVyJykge1xuICAgICAgICBub3JtQmlhcyA9IFtub3JtLmJpYXMsIG5vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzWzBdLCBub3JtLmJpYXNbMV0sIG5vcm0uYmlhc1syXSwgMF07XG4gICAgICAgIGlmIChub3JtLmJpYXNbM10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vcm1CaWFzWzNdID0gbm9ybS5iaWFzWzNdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3RyaWRlID0gaGVpZ2h0ICogd2lkdGg7XG4gICAgLy8gRGVmYXVsdCBwb2ludGVyIGFzc2lnbm1lbnRzXG4gICAgbGV0IHJUZW5zb3JQb2ludGVyID0gMCxcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlLFxuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyLFxuICAgICAgYVRlbnNvclBvaW50ZXIgPSAtMTtcblxuICAgIC8vIFVwZGF0aW5nIHRoZSBwb2ludGVyIGFzc2lnbm1lbnRzIGJhc2VkIG9uIHRoZSBpbnB1dCBpbWFnZSBmb3JtYXRcbiAgICBpZiAoaW5wdXRmb3JtYXQgPT09ICdSR0JBJykge1xuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgICBhVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDM7XG4gICAgfSBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQicpIHtcbiAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRmb3JtYXQgPT09ICdSQkcnKSB7XG4gICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICAgICAgY29uc3QgUiA9ICgodGVuc29yLmRhdGFbclRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzBdKSAqIG5vcm1NZWFuWzBdOyAvLyBSIHZhbHVlXG4gICAgICAgIGNvbnN0IEcgPSAoKHRlbnNvci5kYXRhW2dUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1sxXSkgKiBub3JtTWVhblsxXTsgLy8gRyB2YWx1ZVxuICAgICAgICBjb25zdCBCID0gKCh0ZW5zb3IuZGF0YVtiVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbMl0pICogbm9ybU1lYW5bMl07IC8vIEIgdmFsdWVcbiAgICAgICAgY29uc3QgQSA9IGFUZW5zb3JQb2ludGVyID09PSAtMSA/IDI1NSA6ICgodGVuc29yLmRhdGFbYVRlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzNdKSAqIG5vcm1NZWFuWzNdOyAvLyBBIHZhbHVlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kc1xuICAgICAgICBwaXhlbHMyRENvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIFIgKyAnLCcgKyBHICsgJywnICsgQiArICcsJyArIEEgKyAnKSc7XG4gICAgICAgIHBpeGVsczJEQ29udGV4dC5maWxsUmVjdChqLCBpLCAxLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCd0b0RhdGFVUkwnIGluIGNhbnZhcykge1xuICAgICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b0RhdGFVUkwgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IudG9JbWFnZURhdGEoKVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yVG9JbWFnZURhdGEgPSAodGVuc29yOiBUZW5zb3IsIG9wdGlvbnM/OiBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnMpOiBJbWFnZURhdGEgPT4ge1xuICBjb25zdCBwaXhlbHMyRENvbnRleHQgPVxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKVxuICAgICAgOiAobmV3IE9mZnNjcmVlbkNhbnZhcygxLCAxKS5nZXRDb250ZXh0KCcyZCcpIGFzIE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCk7XG4gIGxldCBpbWFnZTogSW1hZ2VEYXRhO1xuICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcbiAgICAvLyBEZWZhdWx0IHZhbHVlcyBmb3IgaGVpZ2h0IGFuZCB3aWR0aCAmIGZvcm1hdFxuICAgIGxldCB3aWR0aDogbnVtYmVyO1xuICAgIGxldCBoZWlnaHQ6IG51bWJlcjtcbiAgICBsZXQgY2hhbm5lbHM6IG51bWJlcjtcbiAgICBpZiAob3B0aW9ucz8udGVuc29yTGF5b3V0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy50ZW5zb3JMYXlvdXQgPT09ICdOSFdDJykge1xuICAgICAgd2lkdGggPSB0ZW5zb3IuZGltc1syXTtcbiAgICAgIGhlaWdodCA9IHRlbnNvci5kaW1zWzFdO1xuICAgICAgY2hhbm5lbHMgPSB0ZW5zb3IuZGltc1szXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVmYXVsdCBsYXlvdXQgaXMgTkNXSFxuICAgICAgd2lkdGggPSB0ZW5zb3IuZGltc1szXTtcbiAgICAgIGhlaWdodCA9IHRlbnNvci5kaW1zWzJdO1xuICAgICAgY2hhbm5lbHMgPSB0ZW5zb3IuZGltc1sxXTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRmb3JtYXQgPSBvcHRpb25zICE9PSB1bmRlZmluZWQgPyAob3B0aW9ucy5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZm9ybWF0IDogJ1JHQicpIDogJ1JHQic7XG5cbiAgICBjb25zdCBub3JtID0gb3B0aW9ucz8ubm9ybTtcbiAgICBsZXQgbm9ybU1lYW46IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICAgIGxldCBub3JtQmlhczogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gICAgaWYgKG5vcm0gPT09IHVuZGVmaW5lZCB8fCBub3JtLm1lYW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9ybU1lYW4gPSBbMjU1LCAyNTUsIDI1NSwgMjU1XTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBub3JtLm1lYW4gPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5vcm1NZWFuID0gW25vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW5bMF0sIG5vcm0ubWVhblsxXSwgbm9ybS5tZWFuWzJdLCAyNTVdO1xuICAgICAgICBpZiAobm9ybS5tZWFuWzNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBub3JtTWVhblszXSA9IG5vcm0ubWVhblszXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9ybSA9PT0gdW5kZWZpbmVkIHx8IG5vcm0uYmlhcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBub3JtQmlhcyA9IFswLCAwLCAwLCAwXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBub3JtLmJpYXMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG5vcm1CaWFzID0gW25vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhc107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtQmlhcyA9IFtub3JtLmJpYXNbMF0sIG5vcm0uYmlhc1sxXSwgbm9ybS5iaWFzWzJdLCAwXTtcbiAgICAgICAgaWYgKG5vcm0uYmlhc1szXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9ybUJpYXNbM10gPSBub3JtLmJpYXNbM107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzdHJpZGUgPSBoZWlnaHQgKiB3aWR0aDtcbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoXG4gICAgICAgIChvcHRpb25zLmZvcm1hdCAhPT0gdW5kZWZpbmVkICYmIGNoYW5uZWxzID09PSA0ICYmIG9wdGlvbnMuZm9ybWF0ICE9PSAnUkdCQScpIHx8XG4gICAgICAgIChjaGFubmVscyA9PT0gMyAmJiBvcHRpb25zLmZvcm1hdCAhPT0gJ1JHQicgJiYgb3B0aW9ucy5mb3JtYXQgIT09ICdCR1InKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRlbnNvciBmb3JtYXQgZG9lc24ndCBtYXRjaCBpbnB1dCB0ZW5zb3IgZGltc1wiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHBvaW50ZXIgYXNzaWdubWVudHNcbiAgICBjb25zdCBzdGVwID0gNDtcbiAgICBsZXQgckltYWdlUG9pbnRlciA9IDAsXG4gICAgICBnSW1hZ2VQb2ludGVyID0gMSxcbiAgICAgIGJJbWFnZVBvaW50ZXIgPSAyLFxuICAgICAgYUltYWdlUG9pbnRlciA9IDM7XG4gICAgbGV0IHJUZW5zb3JQb2ludGVyID0gMCxcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlLFxuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyLFxuICAgICAgYVRlbnNvclBvaW50ZXIgPSAtMTtcblxuICAgIC8vIFVwZGF0aW5nIHRoZSBwb2ludGVyIGFzc2lnbm1lbnRzIGJhc2VkIG9uIHRoZSBpbnB1dCBpbWFnZSBmb3JtYXRcbiAgICBpZiAoaW5wdXRmb3JtYXQgPT09ICdSR0JBJykge1xuICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgICBhVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDM7XG4gICAgfSBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQicpIHtcbiAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRmb3JtYXQgPT09ICdSQkcnKSB7XG4gICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICB9XG5cbiAgICBpbWFnZSA9IHBpeGVsczJEQ29udGV4dC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG5cbiAgICBmb3IgKFxuICAgICAgbGV0IGkgPSAwO1xuICAgICAgaSA8IGhlaWdodCAqIHdpZHRoO1xuICAgICAgckltYWdlUG9pbnRlciArPSBzdGVwLCBnSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGJJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYUltYWdlUG9pbnRlciArPSBzdGVwLCBpKytcbiAgICApIHtcbiAgICAgIGltYWdlLmRhdGFbckltYWdlUG9pbnRlcl0gPSAoKHRlbnNvci5kYXRhW3JUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1swXSkgKiBub3JtTWVhblswXTsgLy8gUiB2YWx1ZVxuICAgICAgaW1hZ2UuZGF0YVtnSW1hZ2VQb2ludGVyXSA9ICgodGVuc29yLmRhdGFbZ1RlbnNvclBvaW50ZXIrK10gYXMgbnVtYmVyKSAtIG5vcm1CaWFzWzFdKSAqIG5vcm1NZWFuWzFdOyAvLyBHIHZhbHVlXG4gICAgICBpbWFnZS5kYXRhW2JJbWFnZVBvaW50ZXJdID0gKCh0ZW5zb3IuZGF0YVtiVGVuc29yUG9pbnRlcisrXSBhcyBudW1iZXIpIC0gbm9ybUJpYXNbMl0pICogbm9ybU1lYW5bMl07IC8vIEIgdmFsdWVcbiAgICAgIGltYWdlLmRhdGFbYUltYWdlUG9pbnRlcl0gPVxuICAgICAgICBhVGVuc29yUG9pbnRlciA9PT0gLTEgPyAyNTUgOiAoKHRlbnNvci5kYXRhW2FUZW5zb3JQb2ludGVyKytdIGFzIG51bWJlcikgLSBub3JtQmlhc1szXSkgKiBub3JtTWVhblszXTsgLy8gQSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcbiAgfVxuICByZXR1cm4gaW1hZ2U7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQge1xuICBPcHRpb25zRGltZW5zaW9ucyxcbiAgT3B0aW9uc0Zvcm1hdCxcbiAgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzLFxuICBPcHRpb25zVGVuc29yRm9ybWF0LFxuICBPcHRpb25zVGVuc29yTGF5b3V0LFxuICBUZW5zb3JGcm9tR3B1QnVmZmVyT3B0aW9ucyxcbiAgVGVuc29yRnJvbUltYWdlQml0bWFwT3B0aW9ucyxcbiAgVGVuc29yRnJvbUltYWdlRGF0YU9wdGlvbnMsXG4gIFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zLFxuICBUZW5zb3JGcm9tVGV4dHVyZU9wdGlvbnMsXG4gIFRlbnNvckZyb21VcmxPcHRpb25zLFxufSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LmpzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLWltcGwuanMnO1xuaW1wb3J0IHsgVGVuc29yIGFzIFRlbnNvckludGVyZmFjZSB9IGZyb20gJy4vdGVuc29yLmpzJztcblxuaW50ZXJmYWNlIEJ1ZmZlclRvVGVuc29yT3B0aW9uc1xuICBleHRlbmRzIE9wdGlvbnNEaW1lbnNpb25zLFxuICAgIE9wdGlvbnNUZW5zb3JMYXlvdXQsXG4gICAgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzLFxuICAgIE9wdGlvbnNGb3JtYXQsXG4gICAgT3B0aW9uc1RlbnNvckZvcm1hdCB7fVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gaW1hZ2Ugb2JqZWN0XG4gKlxuICogQHBhcmFtIGJ1ZmZlciAtIEV4dHJhY3RlZCBpbWFnZSBidWZmZXIgZGF0YSAtIGFzc3VtaW5nIFJHQkEgZm9ybWF0XG4gKiBAcGFyYW0gaW1hZ2VGb3JtYXQgLSBpbnB1dCBpbWFnZSBjb25maWd1cmF0aW9uIC0gcmVxdWlyZWQgY29uZmlndXJhdGlvbnMgaGVpZ2h0LCB3aWR0aCwgZm9ybWF0XG4gKiBAcGFyYW0gdGVuc29yRm9ybWF0IC0gb3V0cHV0IHRlbnNvciBjb25maWd1cmF0aW9uIC0gRGVmYXVsdCBpcyBSR0IgZm9ybWF0XG4gKi9cbmV4cG9ydCBjb25zdCBidWZmZXJUb1RlbnNvciA9IChidWZmZXI6IFVpbnQ4Q2xhbXBlZEFycmF5IHwgdW5kZWZpbmVkLCBvcHRpb25zOiBCdWZmZXJUb1RlbnNvck9wdGlvbnMpOiBUZW5zb3IgPT4ge1xuICBpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGJ1ZmZlciBtdXN0IGJlIGRlZmluZWQnKTtcbiAgfVxuICBpZiAob3B0aW9ucy5oZWlnaHQgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLndpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGhlaWdodCBhbmQgd2lkdGggbXVzdCBiZSBkZWZpbmVkJyk7XG4gIH1cbiAgaWYgKG9wdGlvbnMudGVuc29yTGF5b3V0ID09PSAnTkhXQycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05IV0MgVGVuc29yIGxheW91dCBpcyBub3Qgc3VwcG9ydGVkIHlldCcpO1xuICB9XG5cbiAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSBvcHRpb25zO1xuXG4gIGNvbnN0IG5vcm0gPSBvcHRpb25zLm5vcm0gPz8geyBtZWFuOiAyNTUsIGJpYXM6IDAgfTtcbiAgbGV0IG5vcm1NZWFuOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgbGV0IG5vcm1CaWFzOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcblxuICBpZiAodHlwZW9mIG5vcm0ubWVhbiA9PT0gJ251bWJlcicpIHtcbiAgICBub3JtTWVhbiA9IFtub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW5dO1xuICB9IGVsc2Uge1xuICAgIG5vcm1NZWFuID0gW25vcm0ubWVhbiFbMF0sIG5vcm0ubWVhbiFbMV0sIG5vcm0ubWVhbiFbMl0sIG5vcm0ubWVhbiFbM10gPz8gMjU1XTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygbm9ybS5iaWFzID09PSAnbnVtYmVyJykge1xuICAgIG5vcm1CaWFzID0gW25vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhc107XG4gIH0gZWxzZSB7XG4gICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzIVswXSwgbm9ybS5iaWFzIVsxXSwgbm9ybS5iaWFzIVsyXSwgbm9ybS5iaWFzIVszXSA/PyAwXTtcbiAgfVxuXG4gIGNvbnN0IGlucHV0Zm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZm9ybWF0IDogJ1JHQkEnO1xuICAvLyBkZWZhdWx0IHZhbHVlIGlzIFJHQkEgc2luY2UgaW1hZ2VkYXRhIGFuZCBIVE1MSW1hZ2VFbGVtZW50IHVzZXMgaXRcblxuICBjb25zdCBvdXRwdXRmb3JtYXQgPVxuICAgIG9wdGlvbnMudGVuc29yRm9ybWF0ICE9PSB1bmRlZmluZWQgPyAob3B0aW9ucy50ZW5zb3JGb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGVuc29yRm9ybWF0IDogJ1JHQicpIDogJ1JHQic7XG4gIGNvbnN0IHN0cmlkZSA9IGhlaWdodCAqIHdpZHRoO1xuICBjb25zdCBmbG9hdDMyRGF0YSA9IG91dHB1dGZvcm1hdCA9PT0gJ1JHQkEnID8gbmV3IEZsb2F0MzJBcnJheShzdHJpZGUgKiA0KSA6IG5ldyBGbG9hdDMyQXJyYXkoc3RyaWRlICogMyk7XG5cbiAgLy8gRGVmYXVsdCBwb2ludGVyIGFzc2lnbm1lbnRzXG4gIGxldCBzdGVwID0gNCxcbiAgICBySW1hZ2VQb2ludGVyID0gMCxcbiAgICBnSW1hZ2VQb2ludGVyID0gMSxcbiAgICBiSW1hZ2VQb2ludGVyID0gMixcbiAgICBhSW1hZ2VQb2ludGVyID0gMztcbiAgbGV0IHJUZW5zb3JQb2ludGVyID0gMCxcbiAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZSxcbiAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDIsXG4gICAgYVRlbnNvclBvaW50ZXIgPSAtMTtcblxuICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgaW5wdXQgaW1hZ2UgZm9ybWF0XG4gIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQicpIHtcbiAgICBzdGVwID0gMztcbiAgICBySW1hZ2VQb2ludGVyID0gMDtcbiAgICBnSW1hZ2VQb2ludGVyID0gMTtcbiAgICBiSW1hZ2VQb2ludGVyID0gMjtcbiAgICBhSW1hZ2VQb2ludGVyID0gLTE7XG4gIH1cblxuICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgb3V0cHV0IHRlbnNvciBmb3JtYXRcbiAgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ1JHQkEnKSB7XG4gICAgYVRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAzO1xuICB9IGVsc2UgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ1JCRycpIHtcbiAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICB9IGVsc2UgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ0JHUicpIHtcbiAgICBiVGVuc29yUG9pbnRlciA9IDA7XG4gICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgclRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICB9XG5cbiAgZm9yIChcbiAgICBsZXQgaSA9IDA7XG4gICAgaSA8IHN0cmlkZTtcbiAgICBpKyssIHJJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYkltYWdlUG9pbnRlciArPSBzdGVwLCBnSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGFJbWFnZVBvaW50ZXIgKz0gc3RlcFxuICApIHtcbiAgICBmbG9hdDMyRGF0YVtyVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbckltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1swXSkgLyBub3JtTWVhblswXTtcbiAgICBmbG9hdDMyRGF0YVtnVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbZ0ltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1sxXSkgLyBub3JtTWVhblsxXTtcbiAgICBmbG9hdDMyRGF0YVtiVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbYkltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1syXSkgLyBub3JtTWVhblsyXTtcbiAgICBpZiAoYVRlbnNvclBvaW50ZXIgIT09IC0xICYmIGFJbWFnZVBvaW50ZXIgIT09IC0xKSB7XG4gICAgICBmbG9hdDMyRGF0YVthVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbYUltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1szXSkgLyBub3JtTWVhblszXTtcbiAgICB9XG4gIH1cblxuICAvLyBGbG9hdDMyQXJyYXkgLT4gb3J0LlRlbnNvclxuICBjb25zdCBvdXRwdXRUZW5zb3IgPVxuICAgIG91dHB1dGZvcm1hdCA9PT0gJ1JHQkEnXG4gICAgICA/IG5ldyBUZW5zb3IoJ2Zsb2F0MzInLCBmbG9hdDMyRGF0YSwgWzEsIDQsIGhlaWdodCwgd2lkdGhdKVxuICAgICAgOiBuZXcgVGVuc29yKCdmbG9hdDMyJywgZmxvYXQzMkRhdGEsIFsxLCAzLCBoZWlnaHQsIHdpZHRoXSk7XG4gIHJldHVybiBvdXRwdXRUZW5zb3I7XG59O1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5mcm9tSW1hZ2UoKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21JbWFnZSA9IGFzeW5jIChcbiAgaW1hZ2U6IEltYWdlRGF0YSB8IEhUTUxJbWFnZUVsZW1lbnQgfCBJbWFnZUJpdG1hcCB8IHN0cmluZyxcbiAgb3B0aW9ucz86XG4gICAgfCBUZW5zb3JGcm9tSW1hZ2VEYXRhT3B0aW9uc1xuICAgIHwgVGVuc29yRnJvbUltYWdlRWxlbWVudE9wdGlvbnNcbiAgICB8IFRlbnNvckZyb21JbWFnZUJpdG1hcE9wdGlvbnNcbiAgICB8IFRlbnNvckZyb21VcmxPcHRpb25zLFxuKTogUHJvbWlzZTxUZW5zb3I+ID0+IHtcbiAgLy8gY2hlY2tpbmcgdGhlIHR5cGUgb2YgaW1hZ2Ugb2JqZWN0XG4gIGNvbnN0IGlzSFRNTEltYWdlRWxlID0gdHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudDtcbiAgY29uc3QgaXNJbWFnZURhdGFFbGUgPSB0eXBlb2YgSW1hZ2VEYXRhICE9PSAndW5kZWZpbmVkJyAmJiBpbWFnZSBpbnN0YW5jZW9mIEltYWdlRGF0YTtcbiAgY29uc3QgaXNJbWFnZUJpdG1hcCA9IHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcDtcbiAgY29uc3QgaXNTdHJpbmcgPSB0eXBlb2YgaW1hZ2UgPT09ICdzdHJpbmcnO1xuXG4gIGxldCBkYXRhOiBVaW50OENsYW1wZWRBcnJheSB8IHVuZGVmaW5lZDtcbiAgbGV0IGJ1ZmZlclRvVGVuc29yT3B0aW9uczogQnVmZmVyVG9UZW5zb3JPcHRpb25zID0gb3B0aW9ucyA/PyB7fTtcblxuICBjb25zdCBjcmVhdGVDYW52YXMgPSAoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcygxLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW52YXMgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgY3JlYXRlQ2FudmFzQ29udGV4dCA9IChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50IHwgT2Zmc2NyZWVuQ2FudmFzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB9IGVsc2UgaWYgKGNhbnZhcyBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykge1xuICAgICAgcmV0dXJuIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIGFzIE9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuICAvLyBmaWxsaW5nIGFuZCBjaGVja2luZyBpbWFnZSBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgaWYgKGlzSFRNTEltYWdlRWxlKSB7XG4gICAgLy8gSFRNTEltYWdlRWxlbWVudCAtIGltYWdlIG9iamVjdCAtIGZvcm1hdCBpcyBSR0JBIGJ5IGRlZmF1bHRcbiAgICBjb25zdCBjYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcbiAgICBjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQoY2FudmFzKTtcblxuICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgbGV0IGhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICAgIGxldCB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRIZWlnaHQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGhlaWdodCA9IG9wdGlvbnMucmVzaXplZEhlaWdodDtcbiAgICAgICAgd2lkdGggPSBvcHRpb25zLnJlc2l6ZWRXaWR0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBpZiAob3B0aW9ucy50ZW5zb3JGb3JtYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgaW5wdXQgY29uZmlnIGZvcm1hdCBtdXN0IGJlIFJHQkEgZm9yIEhUTUxJbWFnZUVsZW1lbnQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMudGVuc29yRm9ybWF0ID0gJ1JHQkEnO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy53aWR0aCA9IHdpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLnRlbnNvckZvcm1hdCA9ICdSR0JBJztcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gd2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHBpeGVsczJEQ29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuICAgICAgZGF0YSA9IHBpeGVsczJEQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzSW1hZ2VEYXRhRWxlKSB7XG4gICAgbGV0IGhlaWdodDogbnVtYmVyO1xuICAgIGxldCB3aWR0aDogbnVtYmVyO1xuXG4gICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRXaWR0aCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVzaXplZEhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBoZWlnaHQgPSBvcHRpb25zLnJlc2l6ZWRIZWlnaHQ7XG4gICAgICB3aWR0aCA9IG9wdGlvbnMucmVzaXplZFdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgICB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy5mb3JtYXQgPSAnUkdCQSc7XG4gICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMud2lkdGggPSB3aWR0aDtcblxuICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcblxuICAgICAgdGVtcENhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQodGVtcENhbnZhcyk7XG5cbiAgICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBwaXhlbHMyRENvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlLCAwLCAwKTtcbiAgICAgICAgZGF0YSA9IHBpeGVsczJEQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCkuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gaW1hZ2UuZGF0YTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNJbWFnZUJpdG1hcCkge1xuICAgIC8vIEltYWdlQml0bWFwIC0gaW1hZ2Ugb2JqZWN0IC0gZm9ybWF0IG11c3QgYmUgcHJvdmlkZWQgYnkgdXNlclxuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgaW1hZ2UgY29uZmlnIHdpdGggZm9ybWF0IGZvciBJbWFnZWJpdG1hcCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbnZhcyA9IGNyZWF0ZUNhbnZhcygpO1xuICAgIGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dChjYW52YXMpO1xuXG4gICAgaWYgKHBpeGVsczJEQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgICBjb25zdCB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgcGl4ZWxzMkRDb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBkYXRhID0gcGl4ZWxzMkRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy53aWR0aCA9IHdpZHRoO1xuICAgICAgcmV0dXJuIGJ1ZmZlclRvVGVuc29yKGRhdGEsIGJ1ZmZlclRvVGVuc29yT3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1N0cmluZykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBjYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0KGNhbnZhcyk7XG4gICAgICBpZiAoIWltYWdlIHx8ICFjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiByZWplY3QoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0ltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICBuZXdJbWFnZS5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnO1xuICAgICAgbmV3SW1hZ2Uuc3JjID0gaW1hZ2U7XG4gICAgICBuZXdJbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IG5ld0ltYWdlLndpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gbmV3SW1hZ2UuaGVpZ2h0O1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShuZXdJbWFnZSwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgaW1nID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgICByZXNvbHZlKGJ1ZmZlclRvVGVuc29yKGltZy5kYXRhLCBidWZmZXJUb1RlbnNvck9wdGlvbnMpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBkYXRhIHByb3ZpZGVkIGlzIG5vdCBzdXBwb3J0ZWQgLSBhYm9ydGVkIHRlbnNvciBjcmVhdGlvbicpO1xuICB9XG5cbiAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBidWZmZXJUb1RlbnNvcihkYXRhLCBidWZmZXJUb1RlbnNvck9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb24nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IuZnJvbVRleHR1cmUoKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21UZXh0dXJlID0gPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuVGV4dHVyZURhdGFUeXBlcz4oXG4gIHRleHR1cmU6IFRlbnNvckludGVyZmFjZS5UZXh0dXJlVHlwZSxcbiAgb3B0aW9uczogVGVuc29yRnJvbVRleHR1cmVPcHRpb25zPFQ+LFxuKTogVGVuc29yID0+IHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBkb3dubG9hZCwgZGlzcG9zZSB9ID0gb3B0aW9ucztcbiAgLy8gQWx3YXlzIGFzc3VtZSBSR0JBRjMyLiBUT0RPOiBzdXBwb3J0IGRpZmZlcmVudCB0ZXh0dXJlIGZvcm1hdFxuICBjb25zdCBkaW1zID0gWzEsIGhlaWdodCwgd2lkdGgsIDRdO1xuICByZXR1cm4gbmV3IFRlbnNvcih7IGxvY2F0aW9uOiAndGV4dHVyZScsIHR5cGU6ICdmbG9hdDMyJywgdGV4dHVyZSwgZGltcywgZG93bmxvYWQsIGRpc3Bvc2UgfSk7XG59O1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5mcm9tR3B1QnVmZmVyKCkuXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JGcm9tR3B1QnVmZmVyID0gPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuR3B1QnVmZmVyRGF0YVR5cGVzPihcbiAgZ3B1QnVmZmVyOiBUZW5zb3JJbnRlcmZhY2UuR3B1QnVmZmVyVHlwZSxcbiAgb3B0aW9uczogVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnM8VD4sXG4pOiBUZW5zb3IgPT4ge1xuICBjb25zdCB7IGRhdGFUeXBlLCBkaW1zLCBkb3dubG9hZCwgZGlzcG9zZSB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIG5ldyBUZW5zb3IoeyBsb2NhdGlvbjogJ2dwdS1idWZmZXInLCB0eXBlOiBkYXRhVHlwZSA/PyAnZmxvYXQzMicsIGdwdUJ1ZmZlciwgZGltcywgZG93bmxvYWQsIGRpc3Bvc2UgfSk7XG59O1xuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5mcm9tUGlubmVkQnVmZmVyKCkuXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JGcm9tUGlubmVkQnVmZmVyID0gPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuQ3B1UGlubmVkRGF0YVR5cGVzPihcbiAgdHlwZTogVCxcbiAgYnVmZmVyOiBUZW5zb3JJbnRlcmZhY2UuRGF0YVR5cGVNYXBbVF0sXG4gIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcbik6IFRlbnNvciA9PiBuZXcgVGVuc29yKHsgbG9jYXRpb246ICdjcHUtcGlubmVkJywgdHlwZSwgZGF0YTogYnVmZmVyLCBkaW1zOiBkaW1zID8/IFtidWZmZXIubGVuZ3RoXSB9KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3IuanMnO1xuXG5leHBvcnQgdHlwZSBTdXBwb3J0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3JzID1cbiAgfCBGbG9hdDMyQXJyYXlDb25zdHJ1Y3RvclxuICB8IFVpbnQ4QXJyYXlDb25zdHJ1Y3RvclxuICB8IEludDhBcnJheUNvbnN0cnVjdG9yXG4gIHwgVWludDE2QXJyYXlDb25zdHJ1Y3RvclxuICB8IEludDE2QXJyYXlDb25zdHJ1Y3RvclxuICB8IEludDMyQXJyYXlDb25zdHJ1Y3RvclxuICB8IEJpZ0ludDY0QXJyYXlDb25zdHJ1Y3RvclxuICB8IFVpbnQ4QXJyYXlDb25zdHJ1Y3RvclxuICB8IEZsb2F0NjRBcnJheUNvbnN0cnVjdG9yXG4gIHwgVWludDMyQXJyYXlDb25zdHJ1Y3RvclxuICB8IEJpZ1VpbnQ2NEFycmF5Q29uc3RydWN0b3I7XG5leHBvcnQgdHlwZSBTdXBwb3J0ZWRUeXBlZEFycmF5ID0gSW5zdGFuY2VUeXBlPFN1cHBvcnRlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnM+O1xuXG4vLyBhIHJ1bnRpbWUgbWFwIHRoYXQgbWFwcyB0eXBlIHN0cmluZyB0byBUeXBlZEFycmF5IGNvbnN0cnVjdG9yLiBTaG91bGQgbWF0Y2ggVGVuc29yLkRhdGFUeXBlTWFwLlxuZXhwb3J0IGNvbnN0IE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAgPSBuZXcgTWFwPHN0cmluZywgU3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycz4oW1xuICBbJ2Zsb2F0MzInLCBGbG9hdDMyQXJyYXldLFxuICBbJ3VpbnQ4JywgVWludDhBcnJheV0sXG4gIFsnaW50OCcsIEludDhBcnJheV0sXG4gIFsndWludDE2JywgVWludDE2QXJyYXldLFxuICBbJ2ludDE2JywgSW50MTZBcnJheV0sXG4gIFsnaW50MzInLCBJbnQzMkFycmF5XSxcbiAgWydib29sJywgVWludDhBcnJheV0sXG4gIFsnZmxvYXQ2NCcsIEZsb2F0NjRBcnJheV0sXG4gIFsndWludDMyJywgVWludDMyQXJyYXldLFxuICBbJ2ludDQnLCBVaW50OEFycmF5XSxcbiAgWyd1aW50NCcsIFVpbnQ4QXJyYXldLFxuXSk7XG5cbi8vIGEgcnVudGltZSBtYXAgdGhhdCBtYXBzIHR5cGUgc3RyaW5nIHRvIFR5cGVkQXJyYXkgY29uc3RydWN0b3IuIFNob3VsZCBtYXRjaCBUZW5zb3IuRGF0YVR5cGVNYXAuXG5leHBvcnQgY29uc3QgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUCA9IG5ldyBNYXA8U3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycywgVGVuc29yLlR5cGU+KFtcbiAgW0Zsb2F0MzJBcnJheSwgJ2Zsb2F0MzInXSxcbiAgW1VpbnQ4QXJyYXksICd1aW50OCddLFxuICBbSW50OEFycmF5LCAnaW50OCddLFxuICBbVWludDE2QXJyYXksICd1aW50MTYnXSxcbiAgW0ludDE2QXJyYXksICdpbnQxNiddLFxuICBbSW50MzJBcnJheSwgJ2ludDMyJ10sXG4gIFtGbG9hdDY0QXJyYXksICdmbG9hdDY0J10sXG4gIFtVaW50MzJBcnJheSwgJ3VpbnQzMiddLFxuXSk7XG5cbi8vIGEgZHVtbXkgdHlwZSBkZWNsYXJhdGlvbiBmb3IgRmxvYXQxNkFycmF5IGluIGNhc2UgYW55IHBvbHlmaWxsIGlzIGF2YWlsYWJsZS5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiwgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBjb25zdCBGbG9hdDE2QXJyYXk6IGFueTtcbn1cblxuLy8gdGhlIGZvbGxvd2luZyBjb2RlIGFsbG93cyBkZWxheWluZyBleGVjdXRpb24gb2YgQmlnSW50L0Zsb2F0MTZBcnJheSBjaGVja2luZy4gVGhpcyBhbGxvd3MgbGF6eSBpbml0aWFsaXphdGlvbiBmb3Jcbi8vIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAgYW5kIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAsIHdoaWNoIGFsbG93cyBCaWdJbnQvRmxvYXQxNkFycmF5XG4vLyBwb2x5ZmlsbCBpZiBhdmFpbGFibGUuXG5sZXQgaXNUeXBlZEFycmF5Q2hlY2tlZCA9IGZhbHNlO1xuZXhwb3J0IGNvbnN0IGNoZWNrVHlwZWRBcnJheSA9ICgpID0+IHtcbiAgaWYgKCFpc1R5cGVkQXJyYXlDaGVja2VkKSB7XG4gICAgaXNUeXBlZEFycmF5Q2hlY2tlZCA9IHRydWU7XG4gICAgY29uc3QgaXNCaWdJbnQ2NEFycmF5QXZhaWxhYmxlID0gdHlwZW9mIEJpZ0ludDY0QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIEJpZ0ludDY0QXJyYXkuZnJvbTtcbiAgICBjb25zdCBpc0JpZ1VpbnQ2NEFycmF5QXZhaWxhYmxlID0gdHlwZW9mIEJpZ1VpbnQ2NEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBCaWdVaW50NjRBcnJheS5mcm9tO1xuICAgIGNvbnN0IGlzRmxvYXQxNkFycmF5QXZhaWxhYmxlID0gdHlwZW9mIEZsb2F0MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgRmxvYXQxNkFycmF5LmZyb207XG5cbiAgICBpZiAoaXNCaWdJbnQ2NEFycmF5QXZhaWxhYmxlKSB7XG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLnNldCgnaW50NjQnLCBCaWdJbnQ2NEFycmF5KTtcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAuc2V0KEJpZ0ludDY0QXJyYXksICdpbnQ2NCcpO1xuICAgIH1cbiAgICBpZiAoaXNCaWdVaW50NjRBcnJheUF2YWlsYWJsZSkge1xuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5zZXQoJ3VpbnQ2NCcsIEJpZ1VpbnQ2NEFycmF5KTtcbiAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAuc2V0KEJpZ1VpbnQ2NEFycmF5LCAndWludDY0Jyk7XG4gICAgfVxuICAgIGlmIChpc0Zsb2F0MTZBcnJheUF2YWlsYWJsZSkge1xuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5zZXQoJ2Zsb2F0MTYnLCBGbG9hdDE2QXJyYXkpO1xuICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUC5zZXQoRmxvYXQxNkFycmF5LCAnZmxvYXQxNicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBGbG9hdDE2QXJyYXkgaXMgbm90IGF2YWlsYWJsZSwgdXNlICdVaW50MTZBcnJheScgdG8gc3RvcmUgdGhlIGRhdGEuXG4gICAgICBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLnNldCgnZmxvYXQxNicsIFVpbnQxNkFycmF5KTtcbiAgICB9XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7XG4gIENwdVBpbm5lZENvbnN0cnVjdG9yUGFyYW1ldGVycyxcbiAgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzLFxuICBUZXh0dXJlQ29uc3RydWN0b3JQYXJhbWV0ZXJzLFxufSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LmpzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLWltcGwuanMnO1xuXG4vKipcbiAqIGNhbGN1bGF0ZSBzaXplIGZyb20gZGltcy5cbiAqXG4gKiBAcGFyYW0gZGltcyB0aGUgZGltcyBhcnJheS4gTWF5IGJlIGFuIGlsbGVnYWwgaW5wdXQuXG4gKi9cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVTaXplID0gKGRpbXM6IHJlYWRvbmx5IHVua25vd25bXSk6IG51bWJlciA9PiB7XG4gIGxldCBzaXplID0gMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZGltID0gZGltc1tpXTtcbiAgICBpZiAodHlwZW9mIGRpbSAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc1NhZmVJbnRlZ2VyKGRpbSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGRpbXNbJHtpfV0gbXVzdCBiZSBhbiBpbnRlZ2VyLCBnb3Q6ICR7ZGltfWApO1xuICAgIH1cbiAgICBpZiAoZGltIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGRpbXNbJHtpfV0gbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLCBnb3Q6ICR7ZGltfWApO1xuICAgIH1cbiAgICBzaXplICo9IGRpbTtcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn07XG5cbi8qKlxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLnJlc2hhcGUoKVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yUmVzaGFwZSA9ICh0ZW5zb3I6IFRlbnNvciwgZGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBUZW5zb3IgPT4ge1xuICBzd2l0Y2ggKHRlbnNvci5sb2NhdGlvbikge1xuICAgIGNhc2UgJ2NwdSc6XG4gICAgICByZXR1cm4gbmV3IFRlbnNvcih0ZW5zb3IudHlwZSwgdGVuc29yLmRhdGEsIGRpbXMpO1xuICAgIGNhc2UgJ2NwdS1waW5uZWQnOlxuICAgICAgcmV0dXJuIG5ldyBUZW5zb3Ioe1xuICAgICAgICBsb2NhdGlvbjogJ2NwdS1waW5uZWQnLFxuICAgICAgICBkYXRhOiB0ZW5zb3IuZGF0YSBhcyBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnNbJ2RhdGEnXSxcbiAgICAgICAgdHlwZTogdGVuc29yLnR5cGUgYXMgQ3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzWyd0eXBlJ10sXG4gICAgICAgIGRpbXMsXG4gICAgICB9KTtcbiAgICBjYXNlICd0ZXh0dXJlJzpcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKHtcbiAgICAgICAgbG9jYXRpb246ICd0ZXh0dXJlJyxcbiAgICAgICAgdGV4dHVyZTogdGVuc29yLnRleHR1cmUsXG4gICAgICAgIHR5cGU6IHRlbnNvci50eXBlIGFzIFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnNbJ3R5cGUnXSxcbiAgICAgICAgZGltcyxcbiAgICAgIH0pO1xuICAgIGNhc2UgJ2dwdS1idWZmZXInOlxuICAgICAgcmV0dXJuIG5ldyBUZW5zb3Ioe1xuICAgICAgICBsb2NhdGlvbjogJ2dwdS1idWZmZXInLFxuICAgICAgICBncHVCdWZmZXI6IHRlbnNvci5ncHVCdWZmZXIsXG4gICAgICAgIHR5cGU6IHRlbnNvci50eXBlIGFzIEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVyc1sndHlwZSddLFxuICAgICAgICBkaW1zLFxuICAgICAgfSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdGVuc29yUmVzaGFwZTogdGVuc29yIGxvY2F0aW9uICR7dGVuc29yLmxvY2F0aW9ufSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IHRlbnNvclRvRGF0YVVSTCwgdGVuc29yVG9JbWFnZURhdGEgfSBmcm9tICcuL3RlbnNvci1jb252ZXJzaW9uLWltcGwuanMnO1xuaW1wb3J0IHsgVGVuc29yVG9EYXRhVXJsT3B0aW9ucywgVGVuc29yVG9JbWFnZURhdGFPcHRpb25zIH0gZnJvbSAnLi90ZW5zb3ItY29udmVyc2lvbi5qcyc7XG5pbXBvcnQge1xuICB0ZW5zb3JGcm9tR3B1QnVmZmVyLFxuICB0ZW5zb3JGcm9tSW1hZ2UsXG4gIHRlbnNvckZyb21QaW5uZWRCdWZmZXIsXG4gIHRlbnNvckZyb21UZXh0dXJlLFxufSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LWltcGwuanMnO1xuaW1wb3J0IHtcbiAgQ3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzLFxuICBHcHVCdWZmZXJDb25zdHJ1Y3RvclBhcmFtZXRlcnMsXG4gIFRlbnNvckZyb21HcHVCdWZmZXJPcHRpb25zLFxuICBUZW5zb3JGcm9tSW1hZ2VCaXRtYXBPcHRpb25zLFxuICBUZW5zb3JGcm9tSW1hZ2VEYXRhT3B0aW9ucyxcbiAgVGVuc29yRnJvbUltYWdlRWxlbWVudE9wdGlvbnMsXG4gIFRlbnNvckZyb21UZXh0dXJlT3B0aW9ucyxcbiAgVGVuc29yRnJvbVVybE9wdGlvbnMsXG4gIFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnMsXG59IGZyb20gJy4vdGVuc29yLWZhY3RvcnkuanMnO1xuaW1wb3J0IHtcbiAgY2hlY2tUeXBlZEFycmF5LFxuICBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLFxuICBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLFxuICBTdXBwb3J0ZWRUeXBlZEFycmF5LFxuICBTdXBwb3J0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3JzLFxufSBmcm9tICcuL3RlbnNvci1pbXBsLXR5cGUtbWFwcGluZy5qcyc7XG5pbXBvcnQgeyBjYWxjdWxhdGVTaXplLCB0ZW5zb3JSZXNoYXBlIH0gZnJvbSAnLi90ZW5zb3ItdXRpbHMtaW1wbC5qcyc7XG5pbXBvcnQgeyBUZW5zb3IgYXMgVGVuc29ySW50ZXJmYWNlIH0gZnJvbSAnLi90ZW5zb3IuanMnO1xuXG4vLyB0eXBlIGFsaWFzZXMgZm9yIHRob3NlIGV4cG9ydGVkIGZyb20gVGVuc29yIGludGVyZmFjZVxuXG50eXBlIFRlbnNvclR5cGUgPSBUZW5zb3JJbnRlcmZhY2UuVHlwZTtcbnR5cGUgVGVuc29yRGF0YVR5cGUgPSBUZW5zb3JJbnRlcmZhY2UuRGF0YVR5cGU7XG50eXBlIFRlbnNvckRhdGFMb2NhdGlvbiA9IFRlbnNvckludGVyZmFjZS5EYXRhTG9jYXRpb247XG50eXBlIFRlbnNvclRleHR1cmVUeXBlID0gVGVuc29ySW50ZXJmYWNlLlRleHR1cmVUeXBlO1xudHlwZSBUZW5zb3JHcHVCdWZmZXJUeXBlID0gVGVuc29ySW50ZXJmYWNlLkdwdUJ1ZmZlclR5cGU7XG5cbi8qKlxuICogdGhlIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvciBpbnRlcmZhY2UuXG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgVGVuc29yIGltcGxlbWVudHMgVGVuc29ySW50ZXJmYWNlIHtcbiAgLy8gI3JlZ2lvbiBjb25zdHJ1Y3RvcnNcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IENQVSB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIHR5cGUsIGRhdGEgYW5kIGRpbXMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICB0eXBlOiBUZW5zb3JUeXBlLFxuICAgIGRhdGE6IFRlbnNvckRhdGFUeXBlIHwgVWludDhDbGFtcGVkQXJyYXkgfCByZWFkb25seSBzdHJpbmdbXSB8IHJlYWRvbmx5IG51bWJlcltdIHwgcmVhZG9ubHkgYm9vbGVhbltdLFxuICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcbiAgKTtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBDUFUgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLiBUeXBlIGlzIGluZmVycmVkIGZyb20gZGF0YS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIGRhdGE6IFRlbnNvckRhdGFUeXBlIHwgVWludDhDbGFtcGVkQXJyYXkgfCByZWFkb25seSBzdHJpbmdbXSB8IHJlYWRvbmx5IGJvb2xlYW5bXSxcbiAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICk7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBwaW5uZWQgQ1BVIGRhdGEgd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgZGltcy5cbiAgICpcbiAgICogVGVuc29yJ3MgbG9jYXRpb24gd2lsbCBiZSBzZXQgdG8gJ2NwdS1waW5uZWQnLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gU3BlY2lmeSB0aGUgcGFyYW1ldGVycyB0byBjb25zdHJ1Y3QgdGhlIHRlbnNvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtczogQ3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzKTtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIFdlYkdMIHRleHR1cmUgd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgZGltcy5cbiAgICpcbiAgICogVGVuc29yJ3MgbG9jYXRpb24gd2lsbCBiZSBzZXQgdG8gJ3RleHR1cmUnLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gU3BlY2lmeSB0aGUgcGFyYW1ldGVycyB0byBjb25zdHJ1Y3QgdGhlIHRlbnNvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmFtczogVGV4dHVyZUNvbnN0cnVjdG9yUGFyYW1ldGVycyk7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBXZWJHUFUgYnVmZmVyIHdpdGggdGhlIGdpdmVuIHR5cGUgYW5kIGRpbXMuXG4gICAqXG4gICAqIFRlbnNvcidzIGxvY2F0aW9uIHdpbGwgYmUgc2V0IHRvICdncHUtYnVmZmVyJy5cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtcyAtIFNwZWNpZnkgdGhlIHBhcmFtZXRlcnMgdG8gY29uc3RydWN0IHRoZSB0ZW5zb3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJhbXM6IEdwdUJ1ZmZlckNvbnN0cnVjdG9yUGFyYW1ldGVycyk7XG5cbiAgLyoqXG4gICAqIGltcGxlbWVudGF0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgYXJnMDpcbiAgICAgIHwgVGVuc29yVHlwZVxuICAgICAgfCBUZW5zb3JEYXRhVHlwZVxuICAgICAgfCBVaW50OENsYW1wZWRBcnJheVxuICAgICAgfCByZWFkb25seSBzdHJpbmdbXVxuICAgICAgfCByZWFkb25seSBib29sZWFuW11cbiAgICAgIHwgQ3B1UGlubmVkQ29uc3RydWN0b3JQYXJhbWV0ZXJzXG4gICAgICB8IFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnNcbiAgICAgIHwgR3B1QnVmZmVyQ29uc3RydWN0b3JQYXJhbWV0ZXJzLFxuICAgIGFyZzE/OiBUZW5zb3JEYXRhVHlwZSB8IFVpbnQ4Q2xhbXBlZEFycmF5IHwgcmVhZG9ubHkgbnVtYmVyW10gfCByZWFkb25seSBzdHJpbmdbXSB8IHJlYWRvbmx5IGJvb2xlYW5bXSxcbiAgICBhcmcyPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICkge1xuICAgIC8vIHBlcmZvcm0gb25lLXRpbWUgY2hlY2sgZm9yIEJpZ0ludC9GbG9hdDE2QXJyYXkgc3VwcG9ydFxuICAgIGNoZWNrVHlwZWRBcnJheSgpO1xuXG4gICAgbGV0IHR5cGU6IFRlbnNvclR5cGU7XG4gICAgbGV0IGRpbXM6IHJlYWRvbmx5IG51bWJlcltdO1xuXG4gICAgaWYgKHR5cGVvZiBhcmcwID09PSAnb2JqZWN0JyAmJiAnbG9jYXRpb24nIGluIGFyZzApIHtcbiAgICAgIC8vXG4gICAgICAvLyBjb25zdHJ1Y3RpbmcgdGVuc29yIGZyb20gc3BlY2lmaWMgbG9jYXRpb25cbiAgICAgIC8vXG4gICAgICB0aGlzLmRhdGFMb2NhdGlvbiA9IGFyZzAubG9jYXRpb247XG4gICAgICB0eXBlID0gYXJnMC50eXBlO1xuICAgICAgZGltcyA9IGFyZzAuZGltcztcbiAgICAgIHN3aXRjaCAoYXJnMC5sb2NhdGlvbikge1xuICAgICAgICBjYXNlICdjcHUtcGlubmVkJzoge1xuICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUC5nZXQodHlwZSk7XG4gICAgICAgICAgaWYgKCFleHBlY3RlZFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7dHlwZX1cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gcGlubmVkIGJ1ZmZlcmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShhcmcwLmRhdGEgaW5zdGFuY2VvZiBleHBlY3RlZFR5cGVkQXJyYXlDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGJ1ZmZlciBzaG91bGQgYmUgb2YgdHlwZSAke2V4cGVjdGVkVHlwZWRBcnJheUNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY3B1RGF0YSA9IGFyZzAuZGF0YTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICd0ZXh0dXJlJzoge1xuICAgICAgICAgIGlmICh0eXBlICE9PSAnZmxvYXQzMicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke3R5cGV9XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIHRleHR1cmVgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5ncHVUZXh0dXJlRGF0YSA9IGFyZzAudGV4dHVyZTtcbiAgICAgICAgICB0aGlzLmRvd25sb2FkZXIgPSBhcmcwLmRvd25sb2FkO1xuICAgICAgICAgIHRoaXMuZGlzcG9zZXIgPSBhcmcwLmRpc3Bvc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZ3B1LWJ1ZmZlcic6IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0eXBlICE9PSAnZmxvYXQzMicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdmbG9hdDE2JyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDMyJyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDY0JyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ3VpbnQzMicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICd1aW50OCcgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdib29sJyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ3VpbnQ0JyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDQnXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHt0eXBlfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSBncHUgYnVmZmVyYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZ3B1QnVmZmVyRGF0YSA9IGFyZzAuZ3B1QnVmZmVyO1xuICAgICAgICAgIHRoaXMuZG93bmxvYWRlciA9IGFyZzAuZG93bmxvYWQ7XG4gICAgICAgICAgdGhpcy5kaXNwb3NlciA9IGFyZzAuZGlzcG9zZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGVuc29yIGNvbnN0cnVjdG9yOiB1bnN1cHBvcnRlZCBsb2NhdGlvbiAnJHt0aGlzLmRhdGFMb2NhdGlvbn0nYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vXG4gICAgICAvLyBjb25zdHJ1Y3RpbmcgdGVuc29yIG9mIGxvY2F0aW9uICdjcHUnXG4gICAgICAvL1xuICAgICAgbGV0IGRhdGE6IFRlbnNvckRhdGFUeXBlO1xuICAgICAgbGV0IG1heWJlRGltczogdHlwZW9mIGFyZzEgfCB0eXBlb2YgYXJnMjtcbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgYXJnMCBpcyB0eXBlIG9yIGRhdGFcbiAgICAgIGlmICh0eXBlb2YgYXJnMCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gT3ZlcnJpZGU6IGNvbnN0cnVjdG9yKHR5cGUsIGRhdGEsIC4uLilcbiAgICAgICAgLy9cbiAgICAgICAgdHlwZSA9IGFyZzA7XG4gICAgICAgIG1heWJlRGltcyA9IGFyZzI7XG4gICAgICAgIGlmIChhcmcwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIHN0cmluZyB0ZW5zb3JcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnMSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHN0cmluZyB0ZW5zb3IncyBkYXRhIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSBkb24ndCBjaGVjayB3aGV0aGVyIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIGFycmF5IGlzIHN0cmluZzsgdGhpcyBpcyB0b28gc2xvdy4gd2UgYXNzdW1lIGl0J3MgY29ycmVjdCBhbmRcbiAgICAgICAgICAvLyBlcnJvciB3aWxsIGJlIHBvcHVsYXRlZCBhdCBpbmZlcmVuY2VcbiAgICAgICAgICBkYXRhID0gYXJnMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBudW1lcmljIHRlbnNvclxuICAgICAgICAgIGNvbnN0IHR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuZ2V0KGFyZzApO1xuICAgICAgICAgIGlmICh0eXBlZEFycmF5Q29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdGVuc29yIHR5cGU6ICR7YXJnMH0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgICAgICBpZiAoKGFyZzAgPT09ICdmbG9hdDE2JyAmJiB0eXBlZEFycmF5Q29uc3RydWN0b3IgPT09IFVpbnQxNkFycmF5KSB8fCBhcmcwID09PSAndWludDQnIHx8IGFyZzAgPT09ICdpbnQ0Jykge1xuICAgICAgICAgICAgICAvLyAtICdmbG9hdDE2JzpcbiAgICAgICAgICAgICAgLy8gICBXaGVuIG5vIEZsb2F0MTZBcnJheSBwb2x5ZmlsbCBpcyB1c2VkLCB3ZSBjYW5ub3QgY3JlYXRlICdmbG9hdDE2JyB0ZW5zb3IgZnJvbSBudW1iZXIgYXJyYXkuXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vICAgVGhyb3cgZXJyb3IgaGVyZSBiZWNhdXNlIHdoZW4gdXNlciB0cnkgdG8gdXNlIG51bWJlciBhcnJheSBhcyBkYXRhLFxuICAgICAgICAgICAgICAvLyAgIGUuZy4gbmV3IFRlbnNvcignZmxvYXQxNicsIFsxLCAyLCAzLCA0XSwgZGltcykpLCBpdCB3aWxsIGFjdHVhbGx5IGNhbGxcbiAgICAgICAgICAgICAgLy8gICBVaW50MTZBcnJheS5mcm9tKGFyZzEpIHdoaWNoIGdlbmVyYXRlcyB3cm9uZyBkYXRhLlxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyAtICd1aW50NCcgYW5kICdpbnQ0JzpcbiAgICAgICAgICAgICAgLy8gICBVaW50OEFycmF5LmZyb20oYXJnMSkgd2lsbCBnZW5lcmF0ZSB3cm9uZyBkYXRhIGZvciAndWludDQnIGFuZCAnaW50NCcgdGVuc29yLlxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBDcmVhdGluZyBhICR7YXJnMH0gdGVuc29yIGZyb20gbnVtYmVyIGFycmF5IGlzIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgJHt0eXBlZEFycmF5Q29uc3RydWN0b3IubmFtZX0gYXMgZGF0YS5gLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcwID09PSAndWludDY0JyB8fCBhcmcwID09PSAnaW50NjQnKSB7XG4gICAgICAgICAgICAgIC8vIHVzZSAnYXMgYW55JyBoZXJlIGJlY2F1c2U6XG4gICAgICAgICAgICAgIC8vIDEuIFR5cGVTY3JpcHQncyBjaGVjayBvbiB0eXBlIG9mICdBcnJheS5pc0FycmF5KCknIGRvZXMgbm90IHdvcmsgd2l0aCByZWFkb25seSBhcnJheXMuXG4gICAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzE3MDAyXG4gICAgICAgICAgICAgIC8vIDIuIFR5cGVTY3JpcHQncyBjaGVjayBvbiB1bmlvbiB0eXBlIG9mICcoQmlnSW50NjRBcnJheUNvbnN0cnVjdG9yfEJpZ1VpbnQ2NEFycmF5Q29uc3RydWN0b3IpLmZyb20oKSdcbiAgICAgICAgICAgICAgLy8gZG9lcyBub3QgYWNjZXB0IHBhcmFtZXRlciBtYXBGbi5cbiAgICAgICAgICAgICAgLy8gMy4gcGFyYW1ldGVycyBvZiAnU3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycy5mcm9tKCknIGRvZXMgbm90IG1hdGNoIHRoZSByZXF1aXJlbWVudCBvZiB0aGUgdW5pb25cbiAgICAgICAgICAgICAgLy8gdHlwZS5cblxuICAgICAgICAgICAgICAvLyBhc3N1bWUgJ2FyZzEnIGlzIG9mIHR5cGUgXCJyZWFkb25seSBudW1iZXJbXXxyZWFkb25seSBiaWdpbnRbXVwiIGhlcmUuXG5cbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgZGF0YSA9ICh0eXBlZEFycmF5Q29uc3RydWN0b3IgYXMgYW55KS5mcm9tKGFyZzEsIEJpZ0ludCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBhc3N1bWUgJ2FyZzEnIGlzIG9mIHR5cGUgXCJyZWFkb25seSBudW1iZXJbXVwiIGhlcmUuXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgIGRhdGEgPSAodHlwZWRBcnJheUNvbnN0cnVjdG9yIGFzIGFueSkuZnJvbShhcmcxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGFyZzEgaW5zdGFuY2VvZiB0eXBlZEFycmF5Q29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGRhdGEgPSBhcmcxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYXJnMSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB7XG4gICAgICAgICAgICBpZiAoYXJnMCA9PT0gJ3VpbnQ4Jykge1xuICAgICAgICAgICAgICBkYXRhID0gVWludDhBcnJheS5mcm9tKGFyZzEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSBVaW50OENsYW1wZWRBcnJheSB0ZW5zb3IncyBkYXRhIG11c3QgYmUgdHlwZSBvZiB1aW50OGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBICR7dHlwZX0gdGVuc29yJ3MgZGF0YSBtdXN0IGJlIHR5cGUgb2YgJHt0eXBlZEFycmF5Q29uc3RydWN0b3J9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL1xuICAgICAgICAvLyBPdmVycmlkZTogY29uc3RydWN0b3IoZGF0YSwgLi4uKVxuICAgICAgICAvL1xuICAgICAgICBtYXliZURpbXMgPSBhcmcxO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcwKSkge1xuICAgICAgICAgIC8vIG9ubHkgYm9vbGVhbltdIGFuZCBzdHJpbmdbXSBpcyBzdXBwb3J0ZWRcbiAgICAgICAgICBpZiAoYXJnMC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RlbnNvciB0eXBlIGNhbm5vdCBiZSBpbmZlcnJlZCBmcm9tIGFuIGVtcHR5IGFycmF5LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmaXJzdEVsZW1lbnRUeXBlID0gdHlwZW9mIGFyZzBbMF07XG4gICAgICAgICAgaWYgKGZpcnN0RWxlbWVudFR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0eXBlID0gJ3N0cmluZyc7XG4gICAgICAgICAgICBkYXRhID0gYXJnMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZpcnN0RWxlbWVudFR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdHlwZSA9ICdib29sJztcbiAgICAgICAgICAgIC8vICdhcmcwJyBpcyBvZiB0eXBlICdib29sZWFuW10nLiBVaW50OEFycmF5LmZyb20oYm9vbGVhbltdKSBhY3R1YWxseSB3b3JrcywgYnV0IHR5cGVzY3JpcHQgdGhpbmtzIHRoaXMgaXNcbiAgICAgICAgICAgIC8vIHdyb25nIHR5cGUuIFdlIHVzZSAnYXMgYW55JyB0byBtYWtlIGl0IGhhcHB5LlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGRhdGEgPSBVaW50OEFycmF5LmZyb20oYXJnMCBhcyBhbnlbXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgZWxlbWVudCB0eXBlIG9mIGRhdGEgYXJyYXk6ICR7Zmlyc3RFbGVtZW50VHlwZX0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGFyZzAgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xuICAgICAgICAgIHR5cGUgPSAndWludDgnO1xuICAgICAgICAgIGRhdGEgPSBVaW50OEFycmF5LmZyb20oYXJnMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZ2V0IHRlbnNvciB0eXBlIGZyb20gVHlwZWRBcnJheVxuICAgICAgICAgIGNvbnN0IG1hcHBlZFR5cGUgPSBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLmdldChcbiAgICAgICAgICAgIGFyZzAuY29uc3RydWN0b3IgYXMgU3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChtYXBwZWRUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHR5cGUgZm9yIHRlbnNvciBkYXRhOiAke2FyZzAuY29uc3RydWN0b3J9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0eXBlID0gbWFwcGVkVHlwZTtcbiAgICAgICAgICBkYXRhID0gYXJnMCBhcyBTdXBwb3J0ZWRUeXBlZEFycmF5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHR5cGUgYW5kIGRhdGEgaXMgcHJvY2Vzc2VkLCBub3cgcHJvY2Vzc2luZyBkaW1zXG4gICAgICBpZiAobWF5YmVEaW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gYXNzdW1lIDEtRCB0ZW5zb3IgaWYgZGltcyBvbWl0dGVkXG4gICAgICAgIG1heWJlRGltcyA9IFtkYXRhLmxlbmd0aF07XG4gICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG1heWJlRGltcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgdGVuc29yJ3MgZGltcyBtdXN0IGJlIGEgbnVtYmVyIGFycmF5XCIpO1xuICAgICAgfVxuICAgICAgZGltcyA9IG1heWJlRGltcyBhcyByZWFkb25seSBudW1iZXJbXTtcblxuICAgICAgdGhpcy5jcHVEYXRhID0gZGF0YTtcbiAgICAgIHRoaXMuZGF0YUxvY2F0aW9uID0gJ2NwdSc7XG4gICAgfVxuXG4gICAgLy8gcGVyZm9ybSBjaGVjayBvbiBkaW1zXG4gICAgY29uc3Qgc2l6ZSA9IGNhbGN1bGF0ZVNpemUoZGltcyk7XG4gICAgLy8gaWYgZGF0YSBpcyBvbiBDUFUsIGNoZWNrIHdoZXRoZXIgZGF0YSBsZW5ndGggbWF0Y2hlcyB0ZW5zb3Igc2l6ZVxuICAgIGlmICh0aGlzLmNwdURhdGEgJiYgc2l6ZSAhPT0gdGhpcy5jcHVEYXRhLmxlbmd0aCkge1xuICAgICAgaWYgKCh0eXBlID09PSAndWludDQnIHx8IHR5cGUgPT09ICdpbnQ0JykgJiYgTWF0aC5jZWlsKHNpemUgLyAyKSA9PT0gdGhpcy5jcHVEYXRhLmxlbmd0aCkge1xuICAgICAgICAvLyBmb3IgKHUpaW50NCwgdGhlIGRhdGEgbGVuZ3RoIGlzIGhhbGYgb2YgdGhlIHRlbnNvciBzaXplLiBTbyB3ZSBjaGVjayB0aGlzIHNwZWNpYWwgY2FzZSB3aGVuIHNpemUgaXMgb2RkLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZW5zb3IncyBzaXplKCR7c2l6ZX0pIGRvZXMgbm90IG1hdGNoIGRhdGEgbGVuZ3RoKCR7dGhpcy5jcHVEYXRhLmxlbmd0aH0pLmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5kaW1zID0gZGltcztcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICB9XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIGZhY3RvcnlcbiAgc3RhdGljIGFzeW5jIGZyb21JbWFnZShcbiAgICBpbWFnZTogSW1hZ2VEYXRhIHwgSFRNTEltYWdlRWxlbWVudCB8IEltYWdlQml0bWFwIHwgc3RyaW5nLFxuICAgIG9wdGlvbnM/OlxuICAgICAgfCBUZW5zb3JGcm9tSW1hZ2VEYXRhT3B0aW9uc1xuICAgICAgfCBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9uc1xuICAgICAgfCBUZW5zb3JGcm9tSW1hZ2VCaXRtYXBPcHRpb25zXG4gICAgICB8IFRlbnNvckZyb21VcmxPcHRpb25zLFxuICApOiBQcm9taXNlPFRlbnNvckludGVyZmFjZT4ge1xuICAgIHJldHVybiB0ZW5zb3JGcm9tSW1hZ2UoaW1hZ2UsIG9wdGlvbnMpO1xuICB9XG5cbiAgc3RhdGljIGZyb21UZXh0dXJlPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuVGV4dHVyZURhdGFUeXBlcz4oXG4gICAgdGV4dHVyZTogVGVuc29yVGV4dHVyZVR5cGUsXG4gICAgb3B0aW9uczogVGVuc29yRnJvbVRleHR1cmVPcHRpb25zPFQ+LFxuICApOiBUZW5zb3JJbnRlcmZhY2Uge1xuICAgIHJldHVybiB0ZW5zb3JGcm9tVGV4dHVyZSh0ZXh0dXJlLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tR3B1QnVmZmVyPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuR3B1QnVmZmVyRGF0YVR5cGVzPihcbiAgICBncHVCdWZmZXI6IFRlbnNvckdwdUJ1ZmZlclR5cGUsXG4gICAgb3B0aW9uczogVGVuc29yRnJvbUdwdUJ1ZmZlck9wdGlvbnM8VD4sXG4gICk6IFRlbnNvckludGVyZmFjZSB7XG4gICAgcmV0dXJuIHRlbnNvckZyb21HcHVCdWZmZXIoZ3B1QnVmZmVyLCBvcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUGlubmVkQnVmZmVyPFQgZXh0ZW5kcyBUZW5zb3JJbnRlcmZhY2UuQ3B1UGlubmVkRGF0YVR5cGVzPihcbiAgICB0eXBlOiBULFxuICAgIGJ1ZmZlcjogVGVuc29ySW50ZXJmYWNlLkRhdGFUeXBlTWFwW1RdLFxuICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcbiAgKTogVGVuc29yIHtcbiAgICByZXR1cm4gdGVuc29yRnJvbVBpbm5lZEJ1ZmZlcih0eXBlLCBidWZmZXIsIGRpbXMpO1xuICB9XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gY29udmVyc2lvbnNcbiAgdG9EYXRhVVJMKG9wdGlvbnM/OiBUZW5zb3JUb0RhdGFVcmxPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGVuc29yVG9EYXRhVVJMKHRoaXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgdG9JbWFnZURhdGEob3B0aW9ucz86IFRlbnNvclRvSW1hZ2VEYXRhT3B0aW9ucyk6IEltYWdlRGF0YSB7XG4gICAgcmV0dXJuIHRlbnNvclRvSW1hZ2VEYXRhKHRoaXMsIG9wdGlvbnMpO1xuICB9XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIHB1YmxpYyBmaWVsZHNcbiAgcmVhZG9ubHkgZGltczogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IHR5cGU6IFRlbnNvclR5cGU7XG4gIHJlYWRvbmx5IHNpemU6IG51bWJlcjtcbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gcHJpdmF0ZSBmaWVsZHNcblxuICAvKipcbiAgICogc3RvcmVzIHRoZSBsb2NhdGlvbiBvZiB0aGUgZGF0YS5cbiAgICovXG4gIHByaXZhdGUgZGF0YUxvY2F0aW9uOiBUZW5zb3JEYXRhTG9jYXRpb247XG5cbiAgLyoqXG4gICAqIHN0b3JlcyB0aGUgZGF0YSBvbiBDUFUsIGlmIGxvY2F0aW9uIGlzICdjcHUnIG9yICdjcHUtcGlubmVkJy4gb3RoZXJ3aXNlIGVtcHR5LlxuICAgKi9cbiAgcHJpdmF0ZSBjcHVEYXRhPzogVGVuc29yRGF0YVR5cGU7XG5cbiAgLyoqXG4gICAqIHN0b3JlcyB0aGUgdW5kZXJseWluZyB0ZXh0dXJlIHdoZW4gbG9jYXRpb24gaXMgJ3RleHR1cmUnLiBvdGhlcndpc2UgZW1wdHkuXG4gICAqL1xuICBwcml2YXRlIGdwdVRleHR1cmVEYXRhPzogVGVuc29yVGV4dHVyZVR5cGU7XG5cbiAgLyoqXG4gICAqIHN0b3JlcyB0aGUgdW5kZXJseWluZyBHUFUgYnVmZmVyIHdoZW4gbG9jYXRpb24gaXMgJ2dwdS1idWZmZXInLiBvdGhlcndpc2UgZW1wdHkuXG4gICAqL1xuICBwcml2YXRlIGdwdUJ1ZmZlckRhdGE/OiBUZW5zb3JHcHVCdWZmZXJUeXBlO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgYW4gb3B0aW9uYWwgZG93bmxvYWRlciBmdW5jdGlvbiB0byBkb3dubG9hZCBkYXRhIGZyb20gR1BVIHRvIENQVS5cbiAgICovXG4gIHByaXZhdGUgZG93bmxvYWRlcj8oKTogUHJvbWlzZTxUZW5zb3JEYXRhVHlwZT47XG5cbiAgLyoqXG4gICAqIGEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRhdGEgaXMgYmVpbmcgZG93bmxvYWRlZCBmcm9tIEdQVSB0byBDUFUuXG4gICAqL1xuICBwcml2YXRlIGlzRG93bmxvYWRpbmc/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBzdG9yZXMgYW4gb3B0aW9uYWwgZGlzcG9zZXIgZnVuY3Rpb24gdG8gZGlzcG9zZSB0aGUgdW5kZXJseWluZyBkYXRhLlxuICAgKi9cbiAgcHJpdmF0ZSBkaXNwb3Nlcj8oKTogdm9pZDtcbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gcHJvcGVydGllc1xuICBnZXQgZGF0YSgpOiBUZW5zb3JEYXRhVHlwZSB7XG4gICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xuICAgIGlmICghdGhpcy5jcHVEYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUaGUgZGF0YSBpcyBub3Qgb24gQ1BVLiBVc2UgYGdldERhdGEoKWAgdG8gZG93bmxvYWQgR1BVIGRhdGEgdG8gQ1BVLCAnICtcbiAgICAgICAgICAnb3IgdXNlIGB0ZXh0dXJlYCBvciBgZ3B1QnVmZmVyYCBwcm9wZXJ0eSB0byBhY2Nlc3MgdGhlIEdQVSBkYXRhIGRpcmVjdGx5LicsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jcHVEYXRhO1xuICB9XG5cbiAgZ2V0IGxvY2F0aW9uKCk6IFRlbnNvckRhdGFMb2NhdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YUxvY2F0aW9uO1xuICB9XG5cbiAgZ2V0IHRleHR1cmUoKTogVGVuc29yVGV4dHVyZVR5cGUge1xuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcbiAgICBpZiAoIXRoaXMuZ3B1VGV4dHVyZURhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYkdMIHRleHR1cmUuJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdwdVRleHR1cmVEYXRhO1xuICB9XG5cbiAgZ2V0IGdwdUJ1ZmZlcigpOiBUZW5zb3JHcHVCdWZmZXJUeXBlIHtcbiAgICB0aGlzLmVuc3VyZVZhbGlkKCk7XG4gICAgaWYgKCF0aGlzLmdwdUJ1ZmZlckRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYkdQVSBidWZmZXIuJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdwdUJ1ZmZlckRhdGE7XG4gIH1cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gbWV0aG9kc1xuXG4gIGFzeW5jIGdldERhdGEocmVsZWFzZURhdGE/OiBib29sZWFuKTogUHJvbWlzZTxUZW5zb3JEYXRhVHlwZT4ge1xuICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcbiAgICBzd2l0Y2ggKHRoaXMuZGF0YUxvY2F0aW9uKSB7XG4gICAgICBjYXNlICdjcHUnOlxuICAgICAgY2FzZSAnY3B1LXBpbm5lZCc6XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgICBjYXNlICd0ZXh0dXJlJzpcbiAgICAgIGNhc2UgJ2dwdS1idWZmZXInOiB7XG4gICAgICAgIGlmICghdGhpcy5kb3dubG9hZGVyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3VycmVudCB0ZW5zb3IgaXMgbm90IGNyZWF0ZWQgd2l0aCBhIHNwZWNpZmllZCBkYXRhIGRvd25sb2FkZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNEb3dubG9hZGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmlzRG93bmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmRvd25sb2FkZXIoKTtcbiAgICAgICAgICB0aGlzLmRvd25sb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy5kYXRhTG9jYXRpb24gPSAnY3B1JztcbiAgICAgICAgICB0aGlzLmNwdURhdGEgPSBkYXRhO1xuXG4gICAgICAgICAgaWYgKHJlbGVhc2VEYXRhICYmIHRoaXMuZGlzcG9zZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhpcy5pc0Rvd25sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGdldCBkYXRhIGZyb20gbG9jYXRpb246ICR7dGhpcy5kYXRhTG9jYXRpb259YCk7XG4gICAgfVxuICB9XG5cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0Rvd25sb2FkaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjdXJyZW50IHRlbnNvciBpcyBiZWluZyBkb3dubG9hZGVkLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRpc3Bvc2VyKSB7XG4gICAgICB0aGlzLmRpc3Bvc2VyKCk7XG4gICAgICB0aGlzLmRpc3Bvc2VyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLmNwdURhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ncHVUZXh0dXJlRGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmdwdUJ1ZmZlckRhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5kb3dubG9hZGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaXNEb3dubG9hZGluZyA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuZGF0YUxvY2F0aW9uID0gJ25vbmUnO1xuICB9XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gdGVuc29yIHV0aWxpdGllc1xuICBwcml2YXRlIGVuc3VyZVZhbGlkKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmRhdGFMb2NhdGlvbiA9PT0gJ25vbmUnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0ZW5zb3IgaXMgZGlzcG9zZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgcmVzaGFwZShkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvckludGVyZmFjZSB7XG4gICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xuICAgIGlmICh0aGlzLmRvd25sb2FkZXIgfHwgdGhpcy5kaXNwb3Nlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVzaGFwZSBhIHRlbnNvciB0aGF0IG93bnMgR1BVIHJlc291cmNlLicpO1xuICAgIH1cbiAgICByZXR1cm4gdGVuc29yUmVzaGFwZSh0aGlzLCBkaW1zKTtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvckZhY3RvcnkgfSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LmpzJztcbmltcG9ydCB7IFRlbnNvciBhcyBUZW5zb3JJbXBsIH0gZnJvbSAnLi90ZW5zb3ItaW1wbC5qcyc7XG5pbXBvcnQgeyBUeXBlZFRlbnNvclV0aWxzIH0gZnJvbSAnLi90ZW5zb3ItdXRpbHMuanMnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkZWNsYXJlICovXG5cbi8qKlxuICogcmVwcmVzZW50IGEgYmFzaWMgdGVuc29yIHdpdGggc3BlY2lmaWVkIGRpbWVuc2lvbnMgYW5kIGRhdGEgdHlwZS5cbiAqL1xuaW50ZXJmYWNlIFR5cGVkVGVuc29yQmFzZTxUIGV4dGVuZHMgVGVuc29yLlR5cGU+IHtcbiAgLyoqXG4gICAqIEdldCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgdGVuc29yLlxuICAgKi9cbiAgcmVhZG9ubHkgZGltczogcmVhZG9ubHkgbnVtYmVyW107XG4gIC8qKlxuICAgKiBHZXQgdGhlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yLlxuICAgKi9cbiAgcmVhZG9ubHkgdHlwZTogVDtcbiAgLyoqXG4gICAqIEdldCB0aGUgYnVmZmVyIGRhdGEgb2YgdGhlIHRlbnNvci5cbiAgICpcbiAgICogSWYgdGhlIGRhdGEgaXMgbm90IG9uIENQVSAoZWcuIGl0J3MgaW4gdGhlIGZvcm0gb2YgV2ViR0wgdGV4dHVyZSBvciBXZWJHUFUgYnVmZmVyKSwgdGhyb3cgZXJyb3IuXG4gICAqL1xuICByZWFkb25seSBkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbVF07XG4gIC8qKlxuICAgKiBHZXQgdGhlIGxvY2F0aW9uIG9mIHRoZSBkYXRhLlxuICAgKi9cbiAgcmVhZG9ubHkgbG9jYXRpb246IFRlbnNvci5EYXRhTG9jYXRpb247XG4gIC8qKlxuICAgKiBHZXQgdGhlIFdlYkdMIHRleHR1cmUgdGhhdCBob2xkcyB0aGUgdGVuc29yIGRhdGEuXG4gICAqXG4gICAqIElmIHRoZSBkYXRhIGlzIG5vdCBvbiBHUFUgYXMgV2ViR0wgdGV4dHVyZSwgdGhyb3cgZXJyb3IuXG4gICAqL1xuICByZWFkb25seSB0ZXh0dXJlOiBUZW5zb3IuVGV4dHVyZVR5cGU7XG4gIC8qKlxuICAgKiBHZXQgdGhlIFdlYkdQVSBidWZmZXIgdGhhdCBob2xkcyB0aGUgdGVuc29yIGRhdGEuXG4gICAqXG4gICAqIElmIHRoZSBkYXRhIGlzIG5vdCBvbiBHUFUgYXMgV2ViR1BVIGJ1ZmZlciwgdGhyb3cgZXJyb3IuXG4gICAqL1xuICByZWFkb25seSBncHVCdWZmZXI6IFRlbnNvci5HcHVCdWZmZXJUeXBlO1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGJ1ZmZlciBkYXRhIG9mIHRoZSB0ZW5zb3IuXG4gICAqXG4gICAqIElmIHRoZSBkYXRhIGlzIG9uIENQVSwgcmV0dXJucyB0aGUgZGF0YSBpbW1lZGlhdGVseS5cbiAgICogSWYgdGhlIGRhdGEgaXMgb24gR1BVLCBkb3dubG9hZHMgdGhlIGRhdGEgYW5kIHJldHVybnMgdGhlIHByb21pc2UuXG4gICAqXG4gICAqIEBwYXJhbSByZWxlYXNlRGF0YSAtIHdoZXRoZXIgcmVsZWFzZSB0aGUgZGF0YSBvbiBHUFUuIElnbm9yZSBpZiBkYXRhIGlzIGFscmVhZHkgb24gQ1BVLlxuICAgKi9cbiAgZ2V0RGF0YShyZWxlYXNlRGF0YT86IGJvb2xlYW4pOiBQcm9taXNlPFRlbnNvci5EYXRhVHlwZU1hcFtUXT47XG5cbiAgLyoqXG4gICAqIERpc3Bvc2UgdGhlIHRlbnNvciBkYXRhLlxuICAgKlxuICAgKiBJZiB0aGUgZGF0YSBpcyBvbiBDUFUsIHJlbW92ZSBpdHMgaW50ZXJuYWwgcmVmZXJlbmNlIHRvIHRoZSB1bmRlcmx5aW5nIGRhdGEuXG4gICAqIElmIHRoZSBkYXRhIGlzIG9uIEdQVSwgcmVsZWFzZSB0aGUgZGF0YSBvbiBHUFUuXG4gICAqXG4gICAqIEFmdGVyIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiwgdGhlIHRlbnNvciBpcyBjb25zaWRlcmVkIG5vIGxvbmdlciB2YWxpZC4gSXRzIGxvY2F0aW9uIHdpbGwgYmUgc2V0IHRvICdub25lJy5cbiAgICovXG4gIGRpc3Bvc2UoKTogdm9pZDtcbn1cblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIFRlbnNvciB7XG4gIGludGVyZmFjZSBEYXRhVHlwZU1hcCB7XG4gICAgZmxvYXQzMjogRmxvYXQzMkFycmF5O1xuICAgIHVpbnQ4OiBVaW50OEFycmF5O1xuICAgIGludDg6IEludDhBcnJheTtcbiAgICB1aW50MTY6IFVpbnQxNkFycmF5O1xuICAgIGludDE2OiBJbnQxNkFycmF5O1xuICAgIGludDMyOiBJbnQzMkFycmF5O1xuICAgIGludDY0OiBCaWdJbnQ2NEFycmF5O1xuICAgIHN0cmluZzogc3RyaW5nW107XG4gICAgYm9vbDogVWludDhBcnJheTtcbiAgICBmbG9hdDE2OiBVaW50MTZBcnJheTsgLy8gS2VlcCB1c2luZyBVaW50MTZBcnJheSB1bnRpbCB3ZSBoYXZlIGEgY29uY3JldGUgc29sdXRpb24gZm9yIGZsb2F0IDE2LlxuICAgIGZsb2F0NjQ6IEZsb2F0NjRBcnJheTtcbiAgICB1aW50MzI6IFVpbnQzMkFycmF5O1xuICAgIHVpbnQ2NDogQmlnVWludDY0QXJyYXk7XG4gICAgLy8gY29tcGxleDY0OiBuZXZlcjtcbiAgICAvLyBjb21wbGV4MTI4OiBuZXZlcjtcbiAgICAvLyBiZmxvYXQxNjogbmV2ZXI7XG4gICAgdWludDQ6IFVpbnQ4QXJyYXk7XG4gICAgaW50NDogSW50OEFycmF5O1xuICB9XG5cbiAgaW50ZXJmYWNlIEVsZW1lbnRUeXBlTWFwIHtcbiAgICBmbG9hdDMyOiBudW1iZXI7XG4gICAgdWludDg6IG51bWJlcjtcbiAgICBpbnQ4OiBudW1iZXI7XG4gICAgdWludDE2OiBudW1iZXI7XG4gICAgaW50MTY6IG51bWJlcjtcbiAgICBpbnQzMjogbnVtYmVyO1xuICAgIGludDY0OiBiaWdpbnQ7XG4gICAgc3RyaW5nOiBzdHJpbmc7XG4gICAgYm9vbDogYm9vbGVhbjtcbiAgICBmbG9hdDE2OiBudW1iZXI7IC8vIEtlZXAgdXNpbmcgVWludDE2QXJyYXkgdW50aWwgd2UgaGF2ZSBhIGNvbmNyZXRlIHNvbHV0aW9uIGZvciBmbG9hdCAxNi5cbiAgICBmbG9hdDY0OiBudW1iZXI7XG4gICAgdWludDMyOiBudW1iZXI7XG4gICAgdWludDY0OiBiaWdpbnQ7XG4gICAgLy8gY29tcGxleDY0OiBuZXZlcjtcbiAgICAvLyBjb21wbGV4MTI4OiBuZXZlcjtcbiAgICAvLyBiZmxvYXQxNjogbmV2ZXI7XG4gICAgdWludDQ6IG51bWJlcjtcbiAgICBpbnQ0OiBudW1iZXI7XG4gIH1cblxuICB0eXBlIERhdGFUeXBlID0gRGF0YVR5cGVNYXBbVHlwZV07XG4gIHR5cGUgRWxlbWVudFR5cGUgPSBFbGVtZW50VHlwZU1hcFtUeXBlXTtcblxuICAvKipcbiAgICogc3VwcG9ydGVkIGRhdGEgdHlwZXMgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgcGlubmVkIENQVSBidWZmZXJcbiAgICovXG4gIGV4cG9ydCB0eXBlIENwdVBpbm5lZERhdGFUeXBlcyA9IEV4Y2x1ZGU8VGVuc29yLlR5cGUsICdzdHJpbmcnPjtcblxuICAvKipcbiAgICogdHlwZSBhbGlhcyBmb3IgV2ViR0wgdGV4dHVyZVxuICAgKi9cbiAgZXhwb3J0IHR5cGUgVGV4dHVyZVR5cGUgPSBXZWJHTFRleHR1cmU7XG5cbiAgLyoqXG4gICAqIHN1cHBvcnRlZCBkYXRhIHR5cGVzIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIFdlYkdMIHRleHR1cmVcbiAgICovXG4gIGV4cG9ydCB0eXBlIFRleHR1cmVEYXRhVHlwZXMgPSAnZmxvYXQzMic7XG5cbiAgLyoqXG4gICAqIHR5cGUgYWxpYXMgZm9yIFdlYkdQVSBidWZmZXJcbiAgICpcbiAgICogVGhlIHJlYXNvbiB3aHkgd2UgZG9uJ3QgdXNlIHR5cGUgXCJHUFVCdWZmZXJcIiBkZWZpbmVkIGluIHdlYmdwdS5kLnRzIGZyb20gQHdlYmdwdS90eXBlcyBpcyBiZWNhdXNlIFwiQHdlYmdwdS90eXBlc1wiXG4gICAqIHJlcXVpcmVzIFwiQHR5cGVzL2RvbS13ZWJjb2RlY3NcIiBhcyBwZWVyIGRlcGVuZGVuY3kgd2hlbiB1c2luZyBUeXBlU2NyaXB0IDwgdjUuMSBhbmQgaXRzIHZlcnNpb24gbmVlZCB0byBiZSBjaG9zZW5cbiAgICogY2FyZWZ1bGx5IGFjY29yZGluZyB0byB0aGUgVHlwZVNjcmlwdCB2ZXJzaW9uIGJlaW5nIHVzZWQuIFRoaXMgbWVhbnMgc28gZmFyIHRoZXJlIGlzIG5vdCBhIHdheSB0byBrZWVwIGV2ZXJ5XG4gICAqIFR5cGVTY3JpcHQgdmVyc2lvbiBoYXBweS4gSXQgdHVybnMgb3V0IHRoYXQgd2Ugd2lsbCBlYXNpbHkgYnJva2UgdXNlcnMgb24gc29tZSBUeXBlU2NyaXB0IHZlcnNpb24uXG4gICAqXG4gICAqIGZvciBtb3JlIGluZm8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncHV3ZWIvdHlwZXMvaXNzdWVzLzEyN1xuICAgKi9cbiAgZXhwb3J0IHR5cGUgR3B1QnVmZmVyVHlwZSA9IHsgc2l6ZTogbnVtYmVyOyBtYXBTdGF0ZTogJ3VubWFwcGVkJyB8ICdwZW5kaW5nJyB8ICdtYXBwZWQnIH07XG5cbiAgLyoqXG4gICAqIHN1cHBvcnRlZCBkYXRhIHR5cGVzIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIFdlYkdQVSBidWZmZXJcbiAgICovXG4gIGV4cG9ydCB0eXBlIEdwdUJ1ZmZlckRhdGFUeXBlcyA9ICdmbG9hdDMyJyB8ICdmbG9hdDE2JyB8ICdpbnQzMicgfCAnaW50NjQnIHwgJ3VpbnQzMicgfCAndWludDgnIHwgJ2Jvb2wnO1xuXG4gIC8qKlxuICAgKiByZXByZXNlbnQgd2hlcmUgdGhlIHRlbnNvciBkYXRhIGlzIHN0b3JlZFxuICAgKi9cbiAgZXhwb3J0IHR5cGUgRGF0YUxvY2F0aW9uID0gJ25vbmUnIHwgJ2NwdScgfCAnY3B1LXBpbm5lZCcgfCAndGV4dHVyZScgfCAnZ3B1LWJ1ZmZlcic7XG5cbiAgLyoqXG4gICAqIHJlcHJlc2VudCB0aGUgZGF0YSB0eXBlIG9mIGEgdGVuc29yXG4gICAqL1xuICBleHBvcnQgdHlwZSBUeXBlID0ga2V5b2YgRGF0YVR5cGVNYXA7XG59XG5cbi8qKlxuICogUmVwcmVzZW50IG11bHRpLWRpbWVuc2lvbmFsIGFycmF5cyB0byBmZWVkIHRvIG9yIGZldGNoIGZyb20gbW9kZWwgaW5mZXJlbmNpbmcuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHlwZWRUZW5zb3I8VCBleHRlbmRzIFRlbnNvci5UeXBlPiBleHRlbmRzIFR5cGVkVGVuc29yQmFzZTxUPiwgVHlwZWRUZW5zb3JVdGlsczxUPiB7fVxuLyoqXG4gKiBSZXByZXNlbnQgbXVsdGktZGltZW5zaW9uYWwgYXJyYXlzIHRvIGZlZWQgdG8gb3IgZmV0Y2ggZnJvbSBtb2RlbCBpbmZlcmVuY2luZy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZW5zb3IgZXh0ZW5kcyBUeXBlZFRlbnNvckJhc2U8VGVuc29yLlR5cGU+LCBUeXBlZFRlbnNvclV0aWxzPFRlbnNvci5UeXBlPiB7fVxuXG4vKipcbiAqIHR5cGUgVGVuc29yQ29uc3RydWN0b3IgZGVmaW5lcyB0aGUgY29uc3RydWN0b3JzIG9mICdUZW5zb3InIHRvIGNyZWF0ZSBDUFUgdGVuc29yIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JDb25zdHJ1Y3RvciBleHRlbmRzIFRlbnNvckZhY3Rvcnkge1xuICAvLyAjcmVnaW9uIENQVSB0ZW5zb3IgLSBzcGVjaWZ5IGVsZW1lbnQgdHlwZVxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHN0cmluZyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIHR5cGUsIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gU3BlY2lmeSB0aGUgZWxlbWVudCB0eXBlLlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIGRhdGE6IFRlbnNvci5EYXRhVHlwZU1hcFsnc3RyaW5nJ10gfCByZWFkb25seSBzdHJpbmdbXSxcbiAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICk6IFR5cGVkVGVuc29yPCdzdHJpbmcnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGJvb2wgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiB0eXBlLCBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIFNwZWNpZnkgdGhlIGVsZW1lbnQgdHlwZS5cbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChcbiAgICB0eXBlOiAnYm9vbCcsXG4gICAgZGF0YTogVGVuc29yLkRhdGFUeXBlTWFwWydib29sJ10gfCByZWFkb25seSBib29sZWFuW10sXG4gICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdLFxuICApOiBUeXBlZFRlbnNvcjwnYm9vbCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdWludDggdGVuc29yIG9iamVjdCBmcm9tIGEgVWludDhDbGFtcGVkQXJyYXksIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gU3BlY2lmeSB0aGUgZWxlbWVudCB0eXBlLlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKHR5cGU6ICd1aW50OCcsIGRhdGE6IFVpbnQ4Q2xhbXBlZEFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwndWludDgnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IDY0LWJpdCBpbnRlZ2VyIHR5cGVkIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyA8VCBleHRlbmRzICd1aW50NjQnIHwgJ2ludDY0Jz4oXG4gICAgdHlwZTogVCxcbiAgICBkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbVF0gfCByZWFkb25seSBiaWdpbnRbXSB8IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSxcbiAgKTogVHlwZWRUZW5zb3I8VD47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBudW1lcmljIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gdHlwZSwgZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSBTcGVjaWZ5IHRoZSBlbGVtZW50IHR5cGUuXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyA8VCBleHRlbmRzIEV4Y2x1ZGU8VGVuc29yLlR5cGUsICdzdHJpbmcnIHwgJ2Jvb2wnIHwgJ3VpbnQ2NCcgfCAnaW50NjQnPj4oXG4gICAgdHlwZTogVCxcbiAgICBkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbVF0gfCByZWFkb25seSBudW1iZXJbXSxcbiAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICk6IFR5cGVkVGVuc29yPFQ+O1xuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBDUFUgdGVuc29yIC0gaW5mZXIgZWxlbWVudCB0eXBlc1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgZmxvYXQzMiB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogRmxvYXQzMkFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnZmxvYXQzMic+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgaW50OCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogSW50OEFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnaW50OCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdWludDggdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKGRhdGE6IFVpbnQ4QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50OCc+O1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgdWludDggdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKGRhdGE6IFVpbnQ4Q2xhbXBlZEFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwndWludDgnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHVpbnQxNiB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogVWludDE2QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50MTYnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGludDE2IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiBJbnQxNkFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnaW50MTYnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGludDMyIHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiBJbnQzMkFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnaW50MzInPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGludDY0IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiBCaWdJbnQ2NEFycmF5LCBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10pOiBUeXBlZFRlbnNvcjwnaW50NjQnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHN0cmluZyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogcmVhZG9ubHkgc3RyaW5nW10sIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCdzdHJpbmcnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGJvb2wgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKGRhdGE6IHJlYWRvbmx5IGJvb2xlYW5bXSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2Jvb2wnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IGZsb2F0NjQgdGVuc29yIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBkYXRhIGFuZCBkaW1zLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKGRhdGE6IEZsb2F0NjRBcnJheSwgZGltcz86IHJlYWRvbmx5IG51bWJlcltdKTogVHlwZWRUZW5zb3I8J2Zsb2F0NjQnPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHVpbnQzMiB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogVWludDMyQXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50MzInPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHVpbnQ2NCB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhIC0gU3BlY2lmeSB0aGUgQ1BVIHRlbnNvciBkYXRhLlxuICAgKiBAcGFyYW0gZGltcyAtIFNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICovXG4gIG5ldyAoZGF0YTogQmlnVWludDY0QXJyYXksIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFR5cGVkVGVuc29yPCd1aW50NjQnPjtcblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBDUFUgdGVuc29yIC0gZmFsbCBiYWNrIHRvIG5vbi1nZW5lcmljIHRlbnNvciB0eXBlIGRlY2xhcmF0aW9uXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyB0ZW5zb3Igb2JqZWN0IGZyb20gdGhlIGdpdmVuIHR5cGUsIGRhdGEgYW5kIGRpbXMuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gU3BlY2lmeSB0aGUgZWxlbWVudCB0eXBlLlxuICAgKiBAcGFyYW0gZGF0YSAtIFNwZWNpZnkgdGhlIENQVSB0ZW5zb3IgZGF0YS5cbiAgICogQHBhcmFtIGRpbXMgLSBTcGVjaWZ5IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYSAxLUQgdGVuc29yIGlzIGFzc3VtZWQuXG4gICAqL1xuICBuZXcgKFxuICAgIHR5cGU6IFRlbnNvci5UeXBlLFxuICAgIGRhdGE6IFRlbnNvci5EYXRhVHlwZSB8IHJlYWRvbmx5IG51bWJlcltdIHwgcmVhZG9ubHkgc3RyaW5nW10gfCByZWFkb25seSBiaWdpbnRbXSB8IHJlYWRvbmx5IGJvb2xlYW5bXSxcbiAgICBkaW1zPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICk6IFRlbnNvcjtcblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBhbmQgZGltcy5cbiAgICpcbiAgICogQHBhcmFtIGRhdGEgLSBTcGVjaWZ5IHRoZSBDUFUgdGVuc29yIGRhdGEuXG4gICAqIEBwYXJhbSBkaW1zIC0gU3BlY2lmeSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0ZW5zb3IuIElmIG9taXR0ZWQsIGEgMS1EIHRlbnNvciBpcyBhc3N1bWVkLlxuICAgKi9cbiAgbmV3IChkYXRhOiBUZW5zb3IuRGF0YVR5cGUsIGRpbXM/OiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvcjtcbiAgLy8gI2VuZHJlZ2lvblxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5leHBvcnQgY29uc3QgVGVuc29yID0gVGVuc29ySW1wbCBhcyBUZW5zb3JDb25zdHJ1Y3RvcjtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgZW52IH0gZnJvbSAnLi9lbnYtaW1wbC5qcyc7XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY29uc3QgVFJBQ0UgPSAoZGV2aWNlVHlwZTogc3RyaW5nLCBsYWJlbDogc3RyaW5nKSA9PiB7XG4gIGlmICh0eXBlb2YgZW52LnRyYWNlID09PSAndW5kZWZpbmVkJyA/ICFlbnYud2FzbS50cmFjZSA6ICFlbnYudHJhY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgY29uc29sZS50aW1lU3RhbXAoYCR7ZGV2aWNlVHlwZX06Ok9SVDo6JHtsYWJlbH1gKTtcbn07XG5cbmNvbnN0IFRSQUNFX0ZVTkMgPSAobXNnOiBzdHJpbmcsIGV4dHJhTXNnPzogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s/LnNwbGl0KC9cXHJcXG58XFxyfFxcbi9nKSB8fCBbXTtcbiAgbGV0IGhhc1RyYWNlRnVuYyA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGhhc1RyYWNlRnVuYyAmJiAhc3RhY2tbaV0uaW5jbHVkZXMoJ1RSQUNFX0ZVTkMnKSkge1xuICAgICAgbGV0IGxhYmVsID0gYEZVTkNfJHttc2d9Ojoke3N0YWNrW2ldLnRyaW0oKS5zcGxpdCgnICcpWzFdfWA7XG4gICAgICBpZiAoZXh0cmFNc2cpIHtcbiAgICAgICAgbGFiZWwgKz0gYDo6JHtleHRyYU1zZ31gO1xuICAgICAgfVxuICAgICAgVFJBQ0UoJ0NQVScsIGxhYmVsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN0YWNrW2ldLmluY2x1ZGVzKCdUUkFDRV9GVU5DJykpIHtcbiAgICAgIGhhc1RyYWNlRnVuYyA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGNvbnN0IFRSQUNFX0ZVTkNfQkVHSU4gPSAoZXh0cmFNc2c/OiBzdHJpbmcpID0+IHtcbiAgaWYgKHR5cGVvZiBlbnYudHJhY2UgPT09ICd1bmRlZmluZWQnID8gIWVudi53YXNtLnRyYWNlIDogIWVudi50cmFjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBUUkFDRV9GVU5DKCdCRUdJTicsIGV4dHJhTXNnKTtcbn07XG5cbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY29uc3QgVFJBQ0VfRlVOQ19FTkQgPSAoZXh0cmFNc2c/OiBzdHJpbmcpID0+IHtcbiAgaWYgKHR5cGVvZiBlbnYudHJhY2UgPT09ICd1bmRlZmluZWQnID8gIWVudi53YXNtLnRyYWNlIDogIWVudi50cmFjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBUUkFDRV9GVU5DKCdFTkQnLCBleHRyYU1zZyk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyByZXNvbHZlQmFja2VuZEFuZEV4ZWN1dGlvblByb3ZpZGVycyB9IGZyb20gJy4vYmFja2VuZC1pbXBsLmpzJztcbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb25IYW5kbGVyIH0gZnJvbSAnLi9iYWNrZW5kLmpzJztcbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gYXMgSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZSB9IGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24uanMnO1xuaW1wb3J0IHsgT25ueFZhbHVlIH0gZnJvbSAnLi9vbm54LXZhbHVlLmpzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcbmltcG9ydCB7IFRSQUNFX0ZVTkNfQkVHSU4sIFRSQUNFX0ZVTkNfRU5EIH0gZnJvbSAnLi90cmFjZS5qcyc7XG5cbnR5cGUgU2Vzc2lvbk9wdGlvbnMgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLlNlc3Npb25PcHRpb25zO1xudHlwZSBSdW5PcHRpb25zID0gSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5SdW5PcHRpb25zO1xudHlwZSBGZWVkc1R5cGUgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLkZlZWRzVHlwZTtcbnR5cGUgRmV0Y2hlc1R5cGUgPSBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLkZldGNoZXNUeXBlO1xudHlwZSBSZXR1cm5UeXBlID0gSW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZS5SZXR1cm5UeXBlO1xuXG5leHBvcnQgY2xhc3MgSW5mZXJlbmNlU2Vzc2lvbiBpbXBsZW1lbnRzIEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2Uge1xuICBwcml2YXRlIGNvbnN0cnVjdG9yKGhhbmRsZXI6IEluZmVyZW5jZVNlc3Npb25IYW5kbGVyKSB7XG4gICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgfVxuICBydW4oZmVlZHM6IEZlZWRzVHlwZSwgb3B0aW9ucz86IFJ1bk9wdGlvbnMpOiBQcm9taXNlPFJldHVyblR5cGU+O1xuICBydW4oZmVlZHM6IEZlZWRzVHlwZSwgZmV0Y2hlczogRmV0Y2hlc1R5cGUsIG9wdGlvbnM/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPjtcbiAgYXN5bmMgcnVuKGZlZWRzOiBGZWVkc1R5cGUsIGFyZzE/OiBGZXRjaGVzVHlwZSB8IFJ1bk9wdGlvbnMsIGFyZzI/OiBSdW5PcHRpb25zKTogUHJvbWlzZTxSZXR1cm5UeXBlPiB7XG4gICAgVFJBQ0VfRlVOQ19CRUdJTigpO1xuICAgIGNvbnN0IGZldGNoZXM6IHsgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB8IG51bGwgfSA9IHt9O1xuICAgIGxldCBvcHRpb25zOiBSdW5PcHRpb25zID0ge307XG4gICAgLy8gY2hlY2sgaW5wdXRzXG4gICAgaWYgKHR5cGVvZiBmZWVkcyAhPT0gJ29iamVjdCcgfHwgZmVlZHMgPT09IG51bGwgfHwgZmVlZHMgaW5zdGFuY2VvZiBUZW5zb3IgfHwgQXJyYXkuaXNBcnJheShmZWVkcykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiJ2ZlZWRzJyBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IHVzZSBpbnB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXCIsXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCBpc0ZldGNoZXNFbXB0eSA9IHRydWU7XG4gICAgLy8gZGV0ZXJtaW5lIHdoaWNoIG92ZXJyaWRlIGlzIGJlaW5nIHVzZWRcbiAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoYXJnMSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBjYW5ub3QgYmUgbnVsbC4nKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmcxIGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgY2Fubm90IGJlIGEgVGVuc29yXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcxKSkge1xuICAgICAgICBpZiAoYXJnMS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaXNGZXRjaGVzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgLy8gb3V0cHV0IG5hbWVzXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBhcmcxKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBtdXN0IGJlIGEgc3RyaW5nIGFycmF5IG9yIGFuIG9iamVjdC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLm91dHB1dE5hbWVzLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2ZldGNoZXMnIGNvbnRhaW5zIGludmFsaWQgb3V0cHV0IG5hbWU6ICR7bmFtZX0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcmcyID09PSAnb2JqZWN0JyAmJiBhcmcyICE9PSBudWxsKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlY2lkZSB3aGV0aGVyIGFyZzEgaXMgZmV0Y2hlcyBvciBvcHRpb25zXG4gICAgICAgIC8vIGlmIGFueSBvdXRwdXQgbmFtZSBpcyBwcmVzZW50IGFuZCBpdHMgdmFsdWUgaXMgdmFsaWQgT25ueFZhbHVlLCB3ZSBjb25zaWRlciBpdCBmZXRjaGVzXG4gICAgICAgIGxldCBpc0ZldGNoZXMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgYXJnMUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcmcxKTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMub3V0cHV0TmFtZXMpIHtcbiAgICAgICAgICBpZiAoYXJnMUtleXMuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSAoYXJnMSBhcyBJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlLk51bGxhYmxlT25ueFZhbHVlTWFwVHlwZSlbbmFtZV07XG4gICAgICAgICAgICBpZiAodiA9PT0gbnVsbCB8fCB2IGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgICAgICAgIGlzRmV0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0ZldGNoZXMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucyA9IGFyZzEgYXMgUnVuT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFsxXTogbXVzdCBiZSAnZmV0Y2hlcycgb3IgJ29wdGlvbnMnLlwiKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBhbGwgaW5wdXRzIGFyZSBpbiBmZWVkXG4gICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMuaW5wdXROYW1lcykge1xuICAgICAgaWYgKHR5cGVvZiBmZWVkc1tuYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnB1dCAnJHtuYW1lfScgaXMgbWlzc2luZyBpbiAnZmVlZHMnLmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIG5vIGZldGNoZXMgaXMgc3BlY2lmaWVkLCB3ZSB1c2UgdGhlIGZ1bGwgb3V0cHV0IG5hbWVzIGxpc3RcbiAgICBpZiAoaXNGZXRjaGVzRW1wdHkpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLm91dHB1dE5hbWVzKSB7XG4gICAgICAgIGZldGNoZXNbbmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZlZWRzLCBmZXRjaGVzIGFuZCBvcHRpb25zIGFyZSBwcmVwYXJlZFxuXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuaGFuZGxlci5ydW4oZmVlZHMsIGZldGNoZXMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHJldHVyblZhbHVlOiB7IFtuYW1lOiBzdHJpbmddOiBPbm54VmFsdWUgfSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdHMpIHtcbiAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHRzLCBrZXkpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdHNba2V5XTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICAgIHJldHVyblZhbHVlW2tleV0gPSByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuVmFsdWVba2V5XSA9IG5ldyBUZW5zb3IocmVzdWx0LnR5cGUsIHJlc3VsdC5kYXRhLCByZXN1bHQuZGltcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgVFJBQ0VfRlVOQ19FTkQoKTtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH1cblxuICBhc3luYyByZWxlYXNlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZShwYXRoOiBzdHJpbmcsIG9wdGlvbnM/OiBTZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZT47XG4gIHN0YXRpYyBjcmVhdGUoYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2UsIG9wdGlvbnM/OiBTZXNzaW9uT3B0aW9ucyk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbkludGVyZmFjZT47XG4gIHN0YXRpYyBjcmVhdGUoXG4gICAgYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2UsXG4gICAgYnl0ZU9mZnNldDogbnVtYmVyLFxuICAgIGJ5dGVMZW5ndGg/OiBudW1iZXIsXG4gICAgb3B0aW9ucz86IFNlc3Npb25PcHRpb25zLFxuICApOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb25JbnRlcmZhY2U+O1xuICBzdGF0aWMgY3JlYXRlKGJ1ZmZlcjogVWludDhBcnJheSwgb3B0aW9ucz86IFNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlPjtcbiAgc3RhdGljIGFzeW5jIGNyZWF0ZShcbiAgICBhcmcwOiBzdHJpbmcgfCBBcnJheUJ1ZmZlckxpa2UgfCBVaW50OEFycmF5LFxuICAgIGFyZzE/OiBTZXNzaW9uT3B0aW9ucyB8IG51bWJlcixcbiAgICBhcmcyPzogbnVtYmVyLFxuICAgIGFyZzM/OiBTZXNzaW9uT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSW50ZXJmYWNlPiB7XG4gICAgVFJBQ0VfRlVOQ19CRUdJTigpO1xuICAgIC8vIGVpdGhlciBsb2FkIGZyb20gYSBmaWxlIG9yIGJ1ZmZlclxuICAgIGxldCBmaWxlUGF0aE9yVWludDhBcnJheTogc3RyaW5nIHwgVWludDhBcnJheTtcbiAgICBsZXQgb3B0aW9uczogU2Vzc2lvbk9wdGlvbnMgPSB7fTtcblxuICAgIGlmICh0eXBlb2YgYXJnMCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZpbGVQYXRoT3JVaW50OEFycmF5ID0gYXJnMDtcbiAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcgJiYgYXJnMSAhPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJnMCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIGZpbGVQYXRoT3JVaW50OEFycmF5ID0gYXJnMDtcbiAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcgJiYgYXJnMSAhPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBhcmcwIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHxcbiAgICAgICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGFyZzAgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcilcbiAgICApIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGFyZzA7XG4gICAgICBsZXQgYnl0ZU9mZnNldCA9IDA7XG4gICAgICBsZXQgYnl0ZUxlbmd0aCA9IGFyZzAuYnl0ZUxlbmd0aDtcbiAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcgJiYgYXJnMSAhPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzEgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGJ5dGVPZmZzZXQgPSBhcmcxO1xuICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGJ5dGVPZmZzZXQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInYnl0ZU9mZnNldCcgbXVzdCBiZSBhbiBpbnRlZ2VyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYnl0ZU9mZnNldCA+PSBidWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZU9mZnNldCcgaXMgb3V0IG9mIHJhbmdlIFswLCAke2J1ZmZlci5ieXRlTGVuZ3RofSkuYCk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZUxlbmd0aCA9IGFyZzAuYnl0ZUxlbmd0aCAtIGJ5dGVPZmZzZXQ7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBieXRlTGVuZ3RoID0gYXJnMjtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGJ5dGVMZW5ndGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidieXRlTGVuZ3RoJyBtdXN0IGJlIGFuIGludGVnZXIuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCA8PSAwIHx8IGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoID4gYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZUxlbmd0aCcgaXMgb3V0IG9mIHJhbmdlICgwLCAke2J1ZmZlci5ieXRlTGVuZ3RoIC0gYnl0ZU9mZnNldH1dLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGFyZzMgPT09ICdvYmplY3QnICYmIGFyZzMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhcmczO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZzIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidieXRlTGVuZ3RoJyBtdXN0IGJlIGEgbnVtYmVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgICB9XG4gICAgICBmaWxlUGF0aE9yVWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzBdOiBtdXN0IGJlICdwYXRoJyBvciAnYnVmZmVyJy5cIik7XG4gICAgfVxuXG4gICAgLy8gcmVzb2x2ZSBiYWNrZW5kLCB1cGRhdGUgc2Vzc2lvbiBvcHRpb25zIHdpdGggdmFsaWRhdGVkIEVQcywgYW5kIGNyZWF0ZSBzZXNzaW9uIGhhbmRsZXJcbiAgICBjb25zdCBbYmFja2VuZCwgb3B0aW9uc1dpdGhWYWxpZGF0ZWRFUHNdID0gYXdhaXQgcmVzb2x2ZUJhY2tlbmRBbmRFeGVjdXRpb25Qcm92aWRlcnMob3B0aW9ucyk7XG4gICAgY29uc3QgaGFuZGxlciA9IGF3YWl0IGJhY2tlbmQuY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIoZmlsZVBhdGhPclVpbnQ4QXJyYXksIG9wdGlvbnNXaXRoVmFsaWRhdGVkRVBzKTtcbiAgICBUUkFDRV9GVU5DX0VORCgpO1xuICAgIHJldHVybiBuZXcgSW5mZXJlbmNlU2Vzc2lvbihoYW5kbGVyKTtcbiAgfVxuXG4gIHN0YXJ0UHJvZmlsaW5nKCk6IHZvaWQge1xuICAgIHRoaXMuaGFuZGxlci5zdGFydFByb2ZpbGluZygpO1xuICB9XG4gIGVuZFByb2ZpbGluZygpOiB2b2lkIHtcbiAgICB0aGlzLmhhbmRsZXIuZW5kUHJvZmlsaW5nKCk7XG4gIH1cblxuICBnZXQgaW5wdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5pbnB1dE5hbWVzO1xuICB9XG4gIGdldCBvdXRwdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vdXRwdXROYW1lcztcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlcjogSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXI7XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gYXMgSW5mZXJlbmNlU2Vzc2lvbkltcGwgfSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLWltcGwuanMnO1xuaW1wb3J0IHsgT25ueE1vZGVsT3B0aW9ucyB9IGZyb20gJy4vb25ueC1tb2RlbC5qcyc7XG5pbXBvcnQgeyBPbm54VmFsdWUsIE9ubnhWYWx1ZURhdGFMb2NhdGlvbiB9IGZyb20gJy4vb25ueC12YWx1ZS5qcyc7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWRlY2xhcmUgKi9cblxuZXhwb3J0IGRlY2xhcmUgbmFtZXNwYWNlIEluZmVyZW5jZVNlc3Npb24ge1xuICAvLyAjcmVnaW9uIGlucHV0L291dHB1dCB0eXBlc1xuXG4gIHR5cGUgT25ueFZhbHVlTWFwVHlwZSA9IHsgcmVhZG9ubHkgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB9O1xuICB0eXBlIE51bGxhYmxlT25ueFZhbHVlTWFwVHlwZSA9IHsgcmVhZG9ubHkgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB8IG51bGwgfTtcblxuICAvKipcbiAgICogQSBmZWVkcyAobW9kZWwgaW5wdXRzKSBpcyBhbiBvYmplY3QgdGhhdCB1c2VzIGlucHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICovXG4gIHR5cGUgRmVlZHNUeXBlID0gT25ueFZhbHVlTWFwVHlwZTtcblxuICAvKipcbiAgICogQSBmZXRjaGVzIChtb2RlbCBvdXRwdXRzKSBjb3VsZCBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAgICpcbiAgICogLSBPbWl0dGVkLiBVc2UgbW9kZWwncyBvdXRwdXQgbmFtZXMgZGVmaW5pdGlvbi5cbiAgICogLSBBbiBhcnJheSBvZiBzdHJpbmcgaW5kaWNhdGluZyB0aGUgb3V0cHV0IG5hbWVzLlxuICAgKiAtIEFuIG9iamVjdCB0aGF0IHVzZSBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIG9yIG51bGwgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAqXG4gICAqIEByZW1hcmtcbiAgICogZGlmZmVyZW50IGZyb20gaW5wdXQgYXJndW1lbnQsIGluIG91dHB1dCwgT25ueFZhbHVlIGlzIG9wdGlvbmFsLiBJZiBhbiBPbm54VmFsdWUgaXMgcHJlc2VudCBpdCB3aWxsIGJlXG4gICAqIHVzZWQgYXMgYSBwcmUtYWxsb2NhdGVkIHZhbHVlIGJ5IHRoZSBpbmZlcmVuY2UgZW5naW5lOyBpZiBvbWl0dGVkLCBpbmZlcmVuY2UgZW5naW5lIHdpbGwgYWxsb2NhdGUgYnVmZmVyXG4gICAqIGludGVybmFsbHkuXG4gICAqL1xuICB0eXBlIEZldGNoZXNUeXBlID0gcmVhZG9ubHkgc3RyaW5nW10gfCBOdWxsYWJsZU9ubnhWYWx1ZU1hcFR5cGU7XG5cbiAgLyoqXG4gICAqIEEgaW5mZXJlbmNpbmcgcmV0dXJuIHR5cGUgaXMgYW4gb2JqZWN0IHRoYXQgdXNlcyBvdXRwdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgKi9cbiAgdHlwZSBSZXR1cm5UeXBlID0gT25ueFZhbHVlTWFwVHlwZTtcblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBzZXNzaW9uIG9wdGlvbnNcblxuICAvKipcbiAgICogQSBzZXQgb2YgY29uZmlndXJhdGlvbnMgZm9yIHNlc3Npb24gYmVoYXZpb3IuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFNlc3Npb25PcHRpb25zIGV4dGVuZHMgT25ueE1vZGVsT3B0aW9ucyB7XG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgZXhlY3V0aW9uIHByb3ZpZGVyIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBBbiBleGVjdXRpb24gcHJvdmlkZXIgb3B0aW9uIGNhbiBiZSBhIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBuYW1lIG9mIHRoZSBleGVjdXRpb24gcHJvdmlkZXIsXG4gICAgICogb3IgYW4gb2JqZWN0IG9mIGNvcnJlc3BvbmRpbmcgdHlwZS5cbiAgICAgKi9cbiAgICBleGVjdXRpb25Qcm92aWRlcnM/OiByZWFkb25seSBFeGVjdXRpb25Qcm92aWRlckNvbmZpZ1tdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludHJhIE9QIHRocmVhZHMgbnVtYmVyLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkuXG4gICAgICovXG4gICAgaW50cmFPcE51bVRocmVhZHM/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW50ZXIgT1AgdGhyZWFkcyBudW1iZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKS5cbiAgICAgKi9cbiAgICBpbnRlck9wTnVtVGhyZWFkcz86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZS5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBmcmVlRGltZW5zaW9uT3ZlcnJpZGVzPzogeyByZWFkb25seSBbZGltZW5zaW9uTmFtZTogc3RyaW5nXTogbnVtYmVyIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3B0aW1pemF0aW9uIGxldmVsLlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGdyYXBoT3B0aW1pemF0aW9uTGV2ZWw/OiAnZGlzYWJsZWQnIHwgJ2Jhc2ljJyB8ICdleHRlbmRlZCcgfCAnYWxsJztcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgZW5hYmxlIENQVSBtZW1vcnkgYXJlbmEuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgZW5hYmxlQ3B1TWVtQXJlbmE/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBlbmFibGUgbWVtb3J5IHBhdHRlcm4uXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgZW5hYmxlTWVtUGF0dGVybj86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRpb24gbW9kZS5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUpIG9yIFdlYkFzc2VtYmx5IGJhY2tlbmRcbiAgICAgKi9cbiAgICBleGVjdXRpb25Nb2RlPzogJ3NlcXVlbnRpYWwnIHwgJ3BhcmFsbGVsJztcblxuICAgIC8qKlxuICAgICAqIE9wdGltaXplZCBtb2RlbCBmaWxlIHBhdGguXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIHNldHRpbmcgaXMgc3BlY2lmaWVkLCB0aGUgb3B0aW1pemVkIG1vZGVsIHdpbGwgYmUgZHVtcGVkLiBJbiBicm93c2VyLCBhIGJsb2Igd2lsbCBiZSBjcmVhdGVkXG4gICAgICogd2l0aCBhIHBvcC11cCB3aW5kb3cuXG4gICAgICovXG4gICAgb3B0aW1pemVkTW9kZWxGaWxlUGF0aD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgZW5hYmxlIHByb2ZpbGluZy5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhIHBsYWNlaG9sZGVyIGZvciBhIGZ1dHVyZSB1c2UuXG4gICAgICovXG4gICAgZW5hYmxlUHJvZmlsaW5nPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEZpbGUgcHJlZml4IGZvciBwcm9maWxpbmcuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYSBwbGFjZWhvbGRlciBmb3IgYSBmdXR1cmUgdXNlLlxuICAgICAqL1xuICAgIHByb2ZpbGVGaWxlUHJlZml4Pzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogTG9nIElELlxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGxvZ0lkPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogTG9nIHNldmVyaXR5IGxldmVsLiBTZWVcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhydW50aW1lL2Jsb2IvbWFpbi9pbmNsdWRlL29ubnhydW50aW1lL2NvcmUvY29tbW9uL2xvZ2dpbmcvc2V2ZXJpdHkuaFxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIGxvZ1NldmVyaXR5TGV2ZWw/OiAwIHwgMSB8IDIgfCAzIHwgNDtcblxuICAgIC8qKlxuICAgICAqIExvZyB2ZXJib3NpdHkgbGV2ZWwuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gV2ViQXNzZW1ibHkgYmFja2VuZC4gV2lsbCBzdXBwb3J0IE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlIGxhdGVyXG4gICAgICovXG4gICAgbG9nVmVyYm9zaXR5TGV2ZWw/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHN0cmluZyBhcyBhIHByZWZlcnJlZCBkYXRhIGxvY2F0aW9uIGZvciBhbGwgb3V0cHV0cywgb3IgYW4gb2JqZWN0IHRoYXQgdXNlIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBhXG4gICAgICogcHJlZmVycmVkIGRhdGEgbG9jYXRpb24gYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgV2ViIGZvciBXZWJHTCBhbmQgV2ViR1BVIEVQLlxuICAgICAqL1xuICAgIHByZWZlcnJlZE91dHB1dExvY2F0aW9uPzogT25ueFZhbHVlRGF0YUxvY2F0aW9uIHwgeyByZWFkb25seSBbb3V0cHV0TmFtZTogc3RyaW5nXTogT25ueFZhbHVlRGF0YUxvY2F0aW9uIH07XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGVuYWJsZSBncmFwaCBjYXB0dXJlLlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSBXZWIgZm9yIFdlYkdQVSBFUC5cbiAgICAgKi9cbiAgICBlbmFibGVHcmFwaENhcHR1cmU/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogU3RvcmUgY29uZmlndXJhdGlvbnMgZm9yIGEgc2Vzc2lvbi4gU2VlXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS9ibG9iL21haW4vaW5jbHVkZS9vbm54cnVudGltZS9jb3JlL3Nlc3Npb24vXG4gICAgICogb25ueHJ1bnRpbWVfc2Vzc2lvbl9vcHRpb25zX2NvbmZpZ19rZXlzLmhcbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBXZWJBc3NlbWJseSBiYWNrZW5kLiBXaWxsIHN1cHBvcnQgTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUgbGF0ZXJcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBleHRyYToge1xuICAgICAqICAgc2Vzc2lvbjoge1xuICAgICAqICAgICBzZXRfZGVub3JtYWxfYXNfemVybzogXCIxXCIsXG4gICAgICogICAgIGRpc2FibGVfcHJlcGFja2luZzogXCIxXCJcbiAgICAgKiAgIH0sXG4gICAgICogICBvcHRpbWl6YXRpb246IHtcbiAgICAgKiAgICAgZW5hYmxlX2dlbHVfYXBwcm94aW1hdGlvbjogXCIxXCJcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZXh0cmE/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgfVxuXG4gIC8vICNyZWdpb24gZXhlY3V0aW9uIHByb3ZpZGVyc1xuXG4gIC8vIEN1cnJlbnRseSwgd2UgaGF2ZSB0aGUgZm9sbG93aW5nIGJhY2tlbmRzIHRvIHN1cHBvcnQgZXhlY3V0aW9uIHByb3ZpZGVyczpcbiAgLy8gQmFja2VuZCBOb2RlLmpzIGJpbmRpbmc6IHN1cHBvcnRzICdjcHUnLCAnZG1sJyAod2luMzIpLCAnY29yZW1sJyAobWFjT1MpIGFuZCAnY3VkYScgKGxpbnV4KS5cbiAgLy8gQmFja2VuZCBXZWJBc3NlbWJseTogc3VwcG9ydHMgJ2NwdScsICd3YXNtJywgJ3dlYmdwdScgYW5kICd3ZWJubicuXG4gIC8vIEJhY2tlbmQgT05OWC5qczogc3VwcG9ydHMgJ3dlYmdsJy5cbiAgLy8gQmFja2VuZCBSZWFjdCBOYXRpdmU6IHN1cHBvcnRzICdjcHUnLCAneG5ucGFjaycsICdjb3JlbWwnIChpT1MpLCAnbm5hcGknIChBbmRyb2lkKS5cbiAgaW50ZXJmYWNlIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uTWFwIHtcbiAgICBjb3JlbWw6IENvcmVNTEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIGNwdTogQ3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgY3VkYTogQ3VkYUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIGRtbDogRG1sRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgbm5hcGk6IE5uYXBpRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgdGVuc29ycnQ6IFRlbnNvclJ0RXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgd2FzbTogV2ViQXNzZW1ibHlFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICB3ZWJnbDogV2ViR0xFeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICB3ZWJncHU6IFdlYkdwdUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHdlYm5uOiBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgIHFubjogUW5uRXhlY3V0aW9uUHJvdmlkZXJPcHRpb247XG4gICAgeG5ucGFjazogWG5ucGFja0V4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICB9XG5cbiAgdHlwZSBFeGVjdXRpb25Qcm92aWRlck5hbWUgPSBrZXlvZiBFeGVjdXRpb25Qcm92aWRlck9wdGlvbk1hcDtcbiAgdHlwZSBFeGVjdXRpb25Qcm92aWRlckNvbmZpZyA9XG4gICAgfCBFeGVjdXRpb25Qcm92aWRlck9wdGlvbk1hcFtFeGVjdXRpb25Qcm92aWRlck5hbWVdXG4gICAgfCBFeGVjdXRpb25Qcm92aWRlck9wdGlvblxuICAgIHwgRXhlY3V0aW9uUHJvdmlkZXJOYW1lXG4gICAgfCBzdHJpbmc7XG5cbiAgZXhwb3J0IGludGVyZmFjZSBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ2NwdSc7XG4gICAgdXNlQXJlbmE/OiBib29sZWFuO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgQ3VkYUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICdjdWRhJztcbiAgICBkZXZpY2VJZD86IG51bWJlcjtcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIERtbEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICdkbWwnO1xuICAgIGRldmljZUlkPzogbnVtYmVyO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgVGVuc29yUnRFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAndGVuc29ycnQnO1xuICAgIGRldmljZUlkPzogbnVtYmVyO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViQXNzZW1ibHlFeGVjdXRpb25Qcm92aWRlck9wdGlvbiBleHRlbmRzIEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIHtcbiAgICByZWFkb25seSBuYW1lOiAnd2FzbSc7XG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJHTEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICd3ZWJnbCc7XG4gICAgLy8gVE9ETzogYWRkIGZsYWdzXG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBYbm5wYWNrRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3hubnBhY2snO1xuICB9XG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViR3B1RXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3dlYmdwdSc7XG4gICAgcHJlZmVycmVkTGF5b3V0PzogJ05DSFcnIHwgJ05IV0MnO1xuICB9XG5cbiAgLy8gI3JlZ2lvbiBXZWJOTiBvcHRpb25zXG5cbiAgaW50ZXJmYWNlIFdlYk5ORXhlY3V0aW9uUHJvdmlkZXJOYW1lIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICd3ZWJubic7XG4gIH1cblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHNldCBvZiBvcHRpb25zIGZvciBjcmVhdGluZyBhIFdlYk5OIE1MQ29udGV4dC5cbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvd2Vibm4vI2RpY3RkZWYtbWxjb250ZXh0b3B0aW9uc1xuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJOTkNvbnRleHRPcHRpb25zIHtcbiAgICBkZXZpY2VUeXBlPzogJ2NwdScgfCAnZ3B1JyB8ICducHUnO1xuICAgIG51bVRocmVhZHM/OiBudW1iZXI7XG4gICAgcG93ZXJQcmVmZXJlbmNlPzogJ2RlZmF1bHQnIHwgJ2xvdy1wb3dlcicgfCAnaGlnaC1wZXJmb3JtYW5jZSc7XG4gIH1cblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHNldCBvZiBvcHRpb25zIGZvciBXZWJOTiBleGVjdXRpb24gcHJvdmlkZXIgd2l0aG91dCBNTENvbnRleHQuXG4gICAqL1xuICBleHBvcnQgaW50ZXJmYWNlIFdlYk5OT3B0aW9uc1dpdGhvdXRNTENvbnRleHQgZXh0ZW5kcyBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyTmFtZSwgV2ViTk5Db250ZXh0T3B0aW9ucyB7XG4gICAgY29udGV4dD86IG5ldmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBzZXQgb2Ygb3B0aW9ucyBmb3IgV2ViTk4gZXhlY3V0aW9uIHByb3ZpZGVyIHdpdGggTUxDb250ZXh0LlxuICAgKlxuICAgKiBXaGVuIE1MQ29udGV4dCBpcyBwcm92aWRlZCwgdGhlIGRldmljZVR5cGUgaXMgYWxzbyByZXF1aXJlZCBzbyB0aGF0IHRoZSBXZWJOTiBFUCBjYW4gZGV0ZXJtaW5lIHRoZSBwcmVmZXJyZWRcbiAgICogY2hhbm5lbCBsYXlvdXQuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYm5uLyNkb20tbWwtY3JlYXRlY29udGV4dFxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBXZWJOTk9wdGlvbnNXaXRoTUxDb250ZXh0XG4gICAgZXh0ZW5kcyBXZWJOTkV4ZWN1dGlvblByb3ZpZGVyTmFtZSxcbiAgICAgIE9taXQ8V2ViTk5Db250ZXh0T3B0aW9ucywgJ2RldmljZVR5cGUnPixcbiAgICAgIFJlcXVpcmVkPFBpY2s8V2ViTk5Db250ZXh0T3B0aW9ucywgJ2RldmljZVR5cGUnPj4ge1xuICAgIGNvbnRleHQ6IHVua25vd24gLyogTUxDb250ZXh0ICovO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBzZXQgb2Ygb3B0aW9ucyBmb3IgV2ViTk4gZXhlY3V0aW9uIHByb3ZpZGVyIHdpdGggTUxDb250ZXh0IHdoaWNoIGlzIGNyZWF0ZWQgZnJvbSBHUFVEZXZpY2UuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYm5uLyNkb20tbWwtY3JlYXRlY29udGV4dC1ncHVkZXZpY2VcbiAgICovXG4gIGV4cG9ydCBpbnRlcmZhY2UgV2ViTk5PcHRpb25zV2ViR3B1IGV4dGVuZHMgV2ViTk5FeGVjdXRpb25Qcm92aWRlck5hbWUge1xuICAgIGNvbnRleHQ6IHVua25vd24gLyogTUxDb250ZXh0ICovO1xuICAgIGdwdURldmljZTogdW5rbm93biAvKiBHUFVEZXZpY2UgKi87XG4gIH1cblxuICAvKipcbiAgICogT3B0aW9ucyBmb3IgV2ViTk4gZXhlY3V0aW9uIHByb3ZpZGVyLlxuICAgKi9cbiAgZXhwb3J0IHR5cGUgV2ViTk5FeGVjdXRpb25Qcm92aWRlck9wdGlvbiA9XG4gICAgfCBXZWJOTk9wdGlvbnNXaXRob3V0TUxDb250ZXh0XG4gICAgfCBXZWJOTk9wdGlvbnNXaXRoTUxDb250ZXh0XG4gICAgfCBXZWJOTk9wdGlvbnNXZWJHcHU7XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgUW5uRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24gZXh0ZW5kcyBFeGVjdXRpb25Qcm92aWRlck9wdGlvbiB7XG4gICAgcmVhZG9ubHkgbmFtZTogJ3Fubic7XG4gICAgLy8gVE9ETyBhZGQgZmxhZ3NcbiAgfVxuICBleHBvcnQgaW50ZXJmYWNlIENvcmVNTEV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICdjb3JlbWwnO1xuICAgIC8qKlxuICAgICAqIFRoZSBiaXQgZmxhZ3MgZm9yIENvcmVNTCBleGVjdXRpb24gcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBDT1JFTUxfRkxBR19VU0VfQ1BVX09OTFkgPSAweDAwMVxuICAgICAqIENPUkVNTF9GTEFHX0VOQUJMRV9PTl9TVUJHUkFQSCA9IDB4MDAyXG4gICAgICogQ09SRU1MX0ZMQUdfT05MWV9FTkFCTEVfREVWSUNFX1dJVEhfQU5FID0gMHgwMDRcbiAgICAgKiBDT1JFTUxfRkxBR19PTkxZX0FMTE9XX1NUQVRJQ19JTlBVVF9TSEFQRVMgPSAweDAwOFxuICAgICAqIENPUkVNTF9GTEFHX0NSRUFURV9NTFBST0dSQU0gPSAweDAxMFxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogU2VlIGluY2x1ZGUvb25ueHJ1bnRpbWUvY29yZS9wcm92aWRlcnMvY29yZW1sL2NvcmVtbF9wcm92aWRlcl9mYWN0b3J5LmggZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFRoaXMgZmxhZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAoTm9kZS5qcyBiaW5kaW5nKS5cbiAgICAgKi9cbiAgICBjb3JlTWxGbGFncz86IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHdoZXRoZXIgdG8gdXNlIENQVSBvbmx5IGluIENvcmVNTCBFUC5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAocmVhY3QtbmF0aXZlKS5cbiAgICAgKi9cbiAgICB1c2VDUFVPbmx5PzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHdoZXRoZXIgdG8gZW5hYmxlIENvcmVNTCBFUCBvbiBzdWJncmFwaC5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAocmVhY3QtbmF0aXZlKS5cbiAgICAgKi9cbiAgICBlbmFibGVPblN1YmdyYXBoPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHdoZXRoZXIgdG8gb25seSBlbmFibGUgQ29yZU1MIEVQIGZvciBBcHBsZSBkZXZpY2VzIHdpdGggQU5FIChBcHBsZSBOZXVyYWwgRW5naW5lKS5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBPTk5YUnVudGltZSAocmVhY3QtbmF0aXZlKS5cbiAgICAgKi9cbiAgICBvbmx5RW5hYmxlRGV2aWNlV2l0aEFORT86IGJvb2xlYW47XG4gIH1cbiAgZXhwb3J0IGludGVyZmFjZSBObmFwaUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uIGV4dGVuZHMgRXhlY3V0aW9uUHJvdmlkZXJPcHRpb24ge1xuICAgIHJlYWRvbmx5IG5hbWU6ICdubmFwaSc7XG4gICAgdXNlRlAxNj86IGJvb2xlYW47XG4gICAgdXNlTkNIVz86IGJvb2xlYW47XG4gICAgY3B1RGlzYWJsZWQ/OiBib29sZWFuO1xuICAgIGNwdU9ubHk/OiBib29sZWFuO1xuICB9XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBydW4gb3B0aW9uc1xuXG4gIC8qKlxuICAgKiBBIHNldCBvZiBjb25maWd1cmF0aW9ucyBmb3IgaW5mZXJlbmNlIHJ1biBiZWhhdmlvclxuICAgKi9cbiAgZXhwb3J0IGludGVyZmFjZSBSdW5PcHRpb25zIHtcbiAgICAvKipcbiAgICAgKiBMb2cgc2V2ZXJpdHkgbGV2ZWwuIFNlZVxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvb25ueHJ1bnRpbWUvYmxvYi9tYWluL2luY2x1ZGUvb25ueHJ1bnRpbWUvY29yZS9jb21tb24vbG9nZ2luZy9zZXZlcml0eS5oXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gT05OWFJ1bnRpbWUgKE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlKSBvciBXZWJBc3NlbWJseSBiYWNrZW5kXG4gICAgICovXG4gICAgbG9nU2V2ZXJpdHlMZXZlbD86IDAgfCAxIHwgMiB8IDMgfCA0O1xuXG4gICAgLyoqXG4gICAgICogTG9nIHZlcmJvc2l0eSBsZXZlbC5cbiAgICAgKlxuICAgICAqIFRoaXMgc2V0dGluZyBpcyBhdmFpbGFibGUgb25seSBpbiBXZWJBc3NlbWJseSBiYWNrZW5kLiBXaWxsIHN1cHBvcnQgTm9kZS5qcyBiaW5kaW5nIGFuZCByZWFjdC1uYXRpdmUgbGF0ZXJcbiAgICAgKi9cbiAgICBsb2dWZXJib3NpdHlMZXZlbD86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRlcm1pbmF0ZSBhbGwgaW5jb21wbGV0ZSBPcnRSdW4gY2FsbHMgYXMgc29vbiBhcyBwb3NzaWJsZSBpZiB0cnVlXG4gICAgICpcbiAgICAgKiBUaGlzIHNldHRpbmcgaXMgYXZhaWxhYmxlIG9ubHkgaW4gV2ViQXNzZW1ibHkgYmFja2VuZC4gV2lsbCBzdXBwb3J0IE5vZGUuanMgYmluZGluZyBhbmQgcmVhY3QtbmF0aXZlIGxhdGVyXG4gICAgICovXG4gICAgdGVybWluYXRlPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEEgdGFnIGZvciB0aGUgUnVuKCkgY2FsbHMgdXNpbmcgdGhpc1xuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIE9OTlhSdW50aW1lIChOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSkgb3IgV2ViQXNzZW1ibHkgYmFja2VuZFxuICAgICAqL1xuICAgIHRhZz86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFNldCBhIHNpbmdsZSBydW4gY29uZmlndXJhdGlvbiBlbnRyeS4gU2VlXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS9ibG9iL21haW4vaW5jbHVkZS9vbm54cnVudGltZS9jb3JlL3Nlc3Npb24vXG4gICAgICogb25ueHJ1bnRpbWVfcnVuX29wdGlvbnNfY29uZmlnX2tleXMuaFxuICAgICAqXG4gICAgICogVGhpcyBzZXR0aW5nIGlzIGF2YWlsYWJsZSBvbmx5IGluIFdlYkFzc2VtYmx5IGJhY2tlbmQuIFdpbGwgc3VwcG9ydCBOb2RlLmpzIGJpbmRpbmcgYW5kIHJlYWN0LW5hdGl2ZSBsYXRlclxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogZXh0cmE6IHtcbiAgICAgKiAgIG1lbW9yeToge1xuICAgICAqICAgICBlbmFibGVfbWVtb3J5X2FyZW5hX3Nocmlua2FnZTogXCIxXCIsXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGV4dHJhPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gIH1cblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiB2YWx1ZSBtZXRhZGF0YVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktaW50ZXJmYWNlXG4gIGludGVyZmFjZSBWYWx1ZU1ldGFkYXRhIHtcbiAgICAvLyBUQkRcbiAgfVxuXG4gIC8vICNlbmRyZWdpb25cbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBydW50aW1lIGluc3RhbmNlIG9mIGFuIE9OTlggbW9kZWwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5mZXJlbmNlU2Vzc2lvbiB7XG4gIC8vICNyZWdpb24gcnVuKClcblxuICAvKipcbiAgICogRXhlY3V0ZSB0aGUgbW9kZWwgYXN5bmNocm9ub3VzbHkgd2l0aCB0aGUgZ2l2ZW4gZmVlZHMgYW5kIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBmZWVkcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBpbnB1dC4gU2VlIHR5cGUgZGVzY3JpcHRpb24gb2YgYEluZmVyZW5jZVNlc3Npb24uSW5wdXRUeXBlYCBmb3IgZGV0YWlsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBBIHNldCBvZiBvcHRpb25zIHRoYXQgY29udHJvbHMgdGhlIGJlaGF2aW9yIG9mIG1vZGVsIGluZmVyZW5jZS5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBtYXAsIHdoaWNoIHVzZXMgb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICovXG4gIHJ1bihmZWVkczogSW5mZXJlbmNlU2Vzc2lvbi5GZWVkc1R5cGUsIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24uUmV0dXJuVHlwZT47XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgdGhlIG1vZGVsIGFzeW5jaHJvbm91c2x5IHdpdGggdGhlIGdpdmVuIGZlZWRzLCBmZXRjaGVzIGFuZCBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gZmVlZHMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgaW5wdXQuIFNlZSB0eXBlIGRlc2NyaXB0aW9uIG9mIGBJbmZlcmVuY2VTZXNzaW9uLklucHV0VHlwZWAgZm9yIGRldGFpbC5cbiAgICogQHBhcmFtIGZldGNoZXMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgb3V0cHV0LiBTZWUgdHlwZSBkZXNjcmlwdGlvbiBvZiBgSW5mZXJlbmNlU2Vzc2lvbi5PdXRwdXRUeXBlYCBmb3JcbiAgICogZGV0YWlsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBBIHNldCBvZiBvcHRpb25zIHRoYXQgY29udHJvbHMgdGhlIGJlaGF2aW9yIG9mIG1vZGVsIGluZmVyZW5jZS5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBtYXAsIHdoaWNoIHVzZXMgb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICovXG4gIHJ1bihcbiAgICBmZWVkczogSW5mZXJlbmNlU2Vzc2lvbi5GZWVkc1R5cGUsXG4gICAgZmV0Y2hlczogSW5mZXJlbmNlU2Vzc2lvbi5GZXRjaGVzVHlwZSxcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zLFxuICApOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24uUmV0dXJuVHlwZT47XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gcmVsZWFzZSgpXG5cbiAgLyoqXG4gICAqIFJlbGVhc2UgdGhlIGluZmVyZW5jZSBzZXNzaW9uIGFuZCB0aGUgdW5kZXJseWluZyByZXNvdXJjZXMuXG4gICAqL1xuICByZWxlYXNlKCk6IFByb21pc2U8dm9pZD47XG5cbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gcHJvZmlsaW5nXG5cbiAgLyoqXG4gICAqIFN0YXJ0IHByb2ZpbGluZy5cbiAgICovXG4gIHN0YXJ0UHJvZmlsaW5nKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEVuZCBwcm9maWxpbmcuXG4gICAqL1xuICBlbmRQcm9maWxpbmcoKTogdm9pZDtcblxuICAvLyAjZW5kcmVnaW9uXG5cbiAgLy8gI3JlZ2lvbiBtZXRhZGF0YVxuXG4gIC8qKlxuICAgKiBHZXQgaW5wdXQgbmFtZXMgb2YgdGhlIGxvYWRlZCBtb2RlbC5cbiAgICovXG4gIHJlYWRvbmx5IGlucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBHZXQgb3V0cHV0IG5hbWVzIG9mIHRoZSBsb2FkZWQgbW9kZWwuXG4gICAqL1xuICByZWFkb25seSBvdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG5cbiAgLy8gLyoqXG4gIC8vICAqIEdldCBpbnB1dCBtZXRhZGF0YSBvZiB0aGUgbG9hZGVkIG1vZGVsLlxuICAvLyAgKi9cbiAgLy8gcmVhZG9ubHkgaW5wdXRNZXRhZGF0YTogUmVhZG9ubHlBcnJheTxSZWFkb25seTxJbmZlcmVuY2VTZXNzaW9uLlZhbHVlTWV0YWRhdGE+PjtcblxuICAvLyAvKipcbiAgLy8gICogR2V0IG91dHB1dCBtZXRhZGF0YSBvZiB0aGUgbG9hZGVkIG1vZGVsLlxuICAvLyAgKi9cbiAgLy8gcmVhZG9ubHkgb3V0cHV0TWV0YWRhdGE6IFJlYWRvbmx5QXJyYXk8UmVhZG9ubHk8SW5mZXJlbmNlU2Vzc2lvbi5WYWx1ZU1ldGFkYXRhPj47XG5cbiAgLy8gI2VuZHJlZ2lvblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluZmVyZW5jZVNlc3Npb25GYWN0b3J5IHtcbiAgLy8gI3JlZ2lvbiBjcmVhdGUoKVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24gYW5kIGxvYWQgbW9kZWwgYXN5bmNocm9ub3VzbHkgZnJvbSBhbiBPTk5YIG1vZGVsIGZpbGUuXG4gICAqXG4gICAqIEBwYXJhbSB1cmkgLSBUaGUgVVJJIG9yIGZpbGUgcGF0aCBvZiB0aGUgbW9kZWwgdG8gbG9hZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBzcGVjaWZ5IGNvbmZpZ3VyYXRpb24gZm9yIGNyZWF0aW5nIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBJbmZlcmVuY2VTZXNzaW9uIG9iamVjdC5cbiAgICovXG4gIGNyZWF0ZSh1cmk6IHN0cmluZywgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24+O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24gYW5kIGxvYWQgbW9kZWwgYXN5bmNocm9ub3VzbHkgZnJvbSBhbiBhcnJheSBidWZlci5cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciAtIEFuIEFycmF5QnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIGFuIE9OTlggbW9kZWwuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gc3BlY2lmeSBjb25maWd1cmF0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbi5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gSW5mZXJlbmNlU2Vzc2lvbiBvYmplY3QuXG4gICAqL1xuICBjcmVhdGUoYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2UsIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uPjtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluZmVyZW5jZSBzZXNzaW9uIGFuZCBsb2FkIG1vZGVsIGFzeW5jaHJvbm91c2x5IGZyb20gc2VnbWVudCBvZiBhbiBhcnJheSBidWZlci5cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciAtIEFuIEFycmF5QnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIGFuIE9OTlggbW9kZWwuXG4gICAqIEBwYXJhbSBieXRlT2Zmc2V0IC0gVGhlIGJlZ2lubmluZyBvZiB0aGUgc3BlY2lmaWVkIHBvcnRpb24gb2YgdGhlIGFycmF5IGJ1ZmZlci5cbiAgICogQHBhcmFtIGJ5dGVMZW5ndGggLSBUaGUgbGVuZ3RoIGluIGJ5dGVzIG9mIHRoZSBhcnJheSBidWZmZXIuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gc3BlY2lmeSBjb25maWd1cmF0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbi5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gSW5mZXJlbmNlU2Vzc2lvbiBvYmplY3QuXG4gICAqL1xuICBjcmVhdGUoXG4gICAgYnVmZmVyOiBBcnJheUJ1ZmZlckxpa2UsXG4gICAgYnl0ZU9mZnNldDogbnVtYmVyLFxuICAgIGJ5dGVMZW5ndGg/OiBudW1iZXIsXG4gICAgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMsXG4gICk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbj47XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBpbmZlcmVuY2Ugc2Vzc2lvbiBhbmQgbG9hZCBtb2RlbCBhc3luY2hyb25vdXNseSBmcm9tIGEgVWludDhBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciAtIEEgVWludDhBcnJheSByZXByZXNlbnRhdGlvbiBvZiBhbiBPTk5YIG1vZGVsLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIHNwZWNpZnkgY29uZmlndXJhdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgaW5mZXJlbmNlIHNlc3Npb24uXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIEluZmVyZW5jZVNlc3Npb24gb2JqZWN0LlxuICAgKi9cbiAgY3JlYXRlKGJ1ZmZlcjogVWludDhBcnJheSwgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiBQcm9taXNlPEluZmVyZW5jZVNlc3Npb24+O1xuXG4gIC8vICNlbmRyZWdpb25cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuZXhwb3J0IGNvbnN0IEluZmVyZW5jZVNlc3Npb246IEluZmVyZW5jZVNlc3Npb25GYWN0b3J5ID0gSW5mZXJlbmNlU2Vzc2lvbkltcGw7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IE9wdGlvbnNGb3JtYXQsIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycywgT3B0aW9uc1RlbnNvckxheW91dCB9IGZyb20gJy4vdGVuc29yLWZhY3RvcnkuanMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvclRvRGF0YVVybE9wdGlvbnMgZXh0ZW5kcyBPcHRpb25zVGVuc29yTGF5b3V0LCBPcHRpb25zRm9ybWF0LCBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge31cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JUb0ltYWdlRGF0YU9wdGlvbnMgZXh0ZW5kcyBPcHRpb25zVGVuc29yTGF5b3V0LCBPcHRpb25zRm9ybWF0LCBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge31cblxuZXhwb3J0IGludGVyZmFjZSBDb252ZXJzaW9uVXRpbHMge1xuICAvKipcbiAgICogY3JlYXRlcyBhIERhdGFVUkwgaW5zdGFuY2UgZnJvbSB0ZW5zb3JcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3QgcmVwcmVzZW50aW5nIG9wdGlvbnMgZm9yIGNyZWF0aW5nIGEgRGF0YVVSTCBpbnN0YW5jZSBmcm9tIHRoZSB0ZW5zb3IuXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XG4gICAqIC0gYGZvcm1hdGA6IGAnUkdCJ2BcbiAgICogLSBgdGVuc29yTGF5b3V0YDogYCdOQ0hXJ2BcbiAgICogQHJldHVybnMgYSBEYXRhVVJMIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGltYWdlIGNvbnZlcnRlZCBmcm9tIHRlbnNvciBkYXRhXG4gICAqL1xuICB0b0RhdGFVUkwob3B0aW9ucz86IFRlbnNvclRvRGF0YVVybE9wdGlvbnMpOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGNyZWF0ZXMgYW4gSW1hZ2VEYXRhIGluc3RhbmNlIGZyb20gdGVuc29yXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyBhbiBJbWFnZURhdGEgaW5zdGFuY2UgZnJvbSB0aGUgdGVuc29yLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGRlZmF1bHQgc2V0dGluZ3Mgd2lsbCBiZSBhcHBsaWVkOlxuICAgKiAtIGBmb3JtYXRgOiBgJ1JHQidgXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXG4gICAqIEByZXR1cm5zIGFuIEltYWdlRGF0YSBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhlIGltYWdlIGNvbnZlcnRlZCBmcm9tIHRlbnNvciBkYXRhXG4gICAqL1xuICB0b0ltYWdlRGF0YShvcHRpb25zPzogVGVuc29yVG9JbWFnZURhdGFPcHRpb25zKTogSW1hZ2VEYXRhO1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBUZW5zb3IsIFR5cGVkVGVuc29yIH0gZnJvbSAnLi90ZW5zb3IuanMnO1xuXG5leHBvcnQgdHlwZSBJbWFnZUZvcm1hdCA9ICdSR0InIHwgJ1JHQkEnIHwgJ0JHUicgfCAnUkJHJztcbmV4cG9ydCB0eXBlIEltYWdlVGVuc29yTGF5b3V0ID0gJ05IV0MnIHwgJ05DSFcnO1xuXG4vLyB0aGUgZm9sbG93aW5nIHJlZ2lvbiBjb250YWlucyB0eXBlIGRlZmluaXRpb25zIGZvciBjb25zdHJ1Y3RpbmcgdGVuc29yIGZyb20gYSBzcGVjaWZpYyBsb2NhdGlvbi5cblxuLy8gI3JlZ2lvbiB0eXBlcyBmb3IgY29uc3RydWN0aW5nIGEgdGVuc29yIGZyb20gYSBzcGVjaWZpYyBsb2NhdGlvblxuXG4vKipcbiAqIHJlcHJlc2VudCBjb21tb24gcHJvcGVydGllcyBvZiB0aGUgcGFyYW1ldGVyIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIHNwZWNpZmljIGxvY2F0aW9uLlxuICovXG5pbnRlcmZhY2UgQ29tbW9uQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IGV4dGVuZHMgUGljazxUZW5zb3IsICdkaW1zJz4ge1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuXG4gICAqL1xuICByZWFkb25seSB0eXBlOiBUO1xufVxuXG4vKipcbiAqIHJlcHJlc2VudCB0aGUgcGFyYW1ldGVyIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIEdQVSByZXNvdXJjZS5cbiAqL1xuaW50ZXJmYWNlIEdwdVJlc291cmNlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBUZW5zb3IuVHlwZT4ge1xuICAvKipcbiAgICogYW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZG93bmxvYWQgZGF0YSBmcm9tIEdQVSB0byBDUFUuXG4gICAqXG4gICAqIElmIG5vdCBwcm92aWRlZCwgdGhlIHRlbnNvciB0cmVhdCB0aGUgR1BVIGRhdGEgYXMgZXh0ZXJuYWwgcmVzb3VyY2UuXG4gICAqL1xuICBkb3dubG9hZD8oKTogUHJvbWlzZTxUZW5zb3IuRGF0YVR5cGVNYXBbVF0+O1xuXG4gIC8qKlxuICAgKiBhbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIHRlbnNvciBpcyBkaXNwb3NlZC5cbiAgICpcbiAgICogSWYgbm90IHByb3ZpZGVkLCB0aGUgdGVuc29yIHRyZWF0IHRoZSBHUFUgZGF0YSBhcyBleHRlcm5hbCByZXNvdXJjZS5cbiAgICovXG4gIGRpc3Bvc2U/KCk6IHZvaWQ7XG59XG5cbi8qKlxuICogcmVwcmVzZW50IHRoZSBwYXJhbWV0ZXIgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgcGlubmVkIENQVSBidWZmZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDcHVQaW5uZWRDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VCBleHRlbmRzIFRlbnNvci5DcHVQaW5uZWREYXRhVHlwZXMgPSBUZW5zb3IuQ3B1UGlubmVkRGF0YVR5cGVzPlxuICBleHRlbmRzIENvbW1vbkNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBsb2NhdGlvbiBvZiB0aGUgZGF0YSB0byBiZSAnY3B1LXBpbm5lZCcuXG4gICAqL1xuICByZWFkb25seSBsb2NhdGlvbjogJ2NwdS1waW5uZWQnO1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgQ1BVIHBpbm5lZCBidWZmZXIgdGhhdCBob2xkcyB0aGUgdGVuc29yIGRhdGEuXG4gICAqL1xuICByZWFkb25seSBkYXRhOiBUZW5zb3IuRGF0YVR5cGVNYXBbVF07XG59XG5cbi8qKlxuICogcmVwcmVzZW50IHRoZSBwYXJhbWV0ZXIgZm9yIGNvbnN0cnVjdGluZyBhIHRlbnNvciBmcm9tIGEgV2ViR0wgdGV4dHVyZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRleHR1cmVDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VCBleHRlbmRzIFRlbnNvci5UZXh0dXJlRGF0YVR5cGVzID0gVGVuc29yLlRleHR1cmVEYXRhVHlwZXM+XG4gIGV4dGVuZHMgQ29tbW9uQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+LFxuICAgIEdwdVJlc291cmNlQ29uc3RydWN0b3JQYXJhbWV0ZXJzPFQ+IHtcbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIGxvY2F0aW9uIG9mIHRoZSBkYXRhIHRvIGJlICd0ZXh0dXJlJy5cbiAgICovXG4gIHJlYWRvbmx5IGxvY2F0aW9uOiAndGV4dHVyZSc7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBXZWJHTCB0ZXh0dXJlIHRoYXQgaG9sZHMgdGhlIHRlbnNvciBkYXRhLlxuICAgKi9cbiAgcmVhZG9ubHkgdGV4dHVyZTogVGVuc29yLlRleHR1cmVUeXBlO1xufVxuXG4vKipcbiAqIHJlcHJlc2VudCB0aGUgcGFyYW1ldGVyIGZvciBjb25zdHJ1Y3RpbmcgYSB0ZW5zb3IgZnJvbSBhIFdlYkdQVSBidWZmZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHcHVCdWZmZXJDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VCBleHRlbmRzIFRlbnNvci5HcHVCdWZmZXJEYXRhVHlwZXMgPSBUZW5zb3IuR3B1QnVmZmVyRGF0YVR5cGVzPlxuICBleHRlbmRzIENvbW1vbkNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPixcbiAgICBHcHVSZXNvdXJjZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBsb2NhdGlvbiBvZiB0aGUgZGF0YSB0byBiZSAnZ3B1LWJ1ZmZlcicuXG4gICAqL1xuICByZWFkb25seSBsb2NhdGlvbjogJ2dwdS1idWZmZXInO1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgV2ViR1BVIGJ1ZmZlciB0aGF0IGhvbGRzIHRoZSB0ZW5zb3IgZGF0YS5cbiAgICovXG4gIHJlYWRvbmx5IGdwdUJ1ZmZlcjogVGVuc29yLkdwdUJ1ZmZlclR5cGU7XG59XG5cbi8vICNlbmRyZWdpb25cblxuLy8gdGhlIGZvbGxvd2luZyByZWdpb24gY29udGFpbnMgdHlwZSBkZWZpbml0aW9ucyBvZiBlYWNoIGluZGl2aWR1YWwgb3B0aW9ucy5cbi8vIHRoZSB0ZW5zb3IgZmFjdG9yeSBmdW5jdGlvbnMgdXNlIGEgY29tcG9zaXRpb24gb2YgdGhvc2Ugb3B0aW9ucyBhcyB0aGUgcGFyYW1ldGVyIHR5cGUuXG5cbi8vICNyZWdpb24gT3B0aW9ucyBmaWVsZHNcblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zRm9ybWF0IHtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyB0aGUgaW1hZ2UgZm9ybWF0IHJlcHJlc2VudGVkIGluIFJHQkEgY29sb3Igc3BhY2UuXG4gICAqL1xuICBmb3JtYXQ/OiBJbWFnZUZvcm1hdDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zVGVuc29yRm9ybWF0IHtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyB0aGUgaW1hZ2UgZm9ybWF0IG9mIHRoZSB0ZW5zb3IuXG4gICAqXG4gICAqIE5PVEU6IHRoaXMgaXMgZGlmZmVyZW50IGZyb20gb3B0aW9uICdmb3JtYXQnLiBXaGlsZSBvcHRpb24gJ2Zvcm1hdCcgcmVwcmVzZW50cyB0aGUgb3JpZ2luYWwgaW1hZ2UsICd0ZW5zb3JGb3JtYXQnXG4gICAqIHJlcHJlc2VudHMgdGhlIHRhcmdldCBmb3JtYXQgb2YgdGhlIHRlbnNvci4gQSB0cmFuc3Bvc2Ugd2lsbCBiZSBwZXJmb3JtZWQgaWYgdGhleSBhcmUgZGlmZmVyZW50LlxuICAgKi9cbiAgdGVuc29yRm9ybWF0PzogSW1hZ2VGb3JtYXQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uc1RlbnNvckRhdGFUeXBlIHtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyB0aGUgZGF0YSB0eXBlIG9mIHRoZSB0ZW5zb3IuXG4gICAqL1xuICBkYXRhVHlwZT86ICdmbG9hdDMyJyB8ICd1aW50OCc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uc1RlbnNvckxheW91dCB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIHRlbnNvciBsYXlvdXQgd2hlbiByZXByZXNlbnRpbmcgZGF0YSBvZiBvbmUgb3IgbW9yZSBpbWFnZShzKS5cbiAgICovXG4gIHRlbnNvckxheW91dD86IEltYWdlVGVuc29yTGF5b3V0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnNEaW1lbnNpb25zIHtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyB0aGUgaW1hZ2UgaGVpZ2h0IGluIHBpeGVsXG4gICAqL1xuICBoZWlnaHQ/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGltYWdlIHdpZHRoIGluIHBpeGVsXG4gICAqL1xuICB3aWR0aD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25SZXNpemVkRGltZW5zaW9ucyB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIHJlc2l6ZWQgaGVpZ2h0LiBJZiBvbWl0dGVkLCBvcmlnaW5hbCBoZWlnaHQgd2lsbCBiZSB1c2VkLlxuICAgKi9cbiAgcmVzaXplZEhlaWdodD86IG51bWJlcjtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyByZXNpemVkIHdpZHRoIC0gY2FuIGJlIGFjY2Vzc2VkIHZpYSB0ZW5zb3IgZGltZW5zaW9ucyBhcyB3ZWxsXG4gICAqL1xuICByZXNpemVkV2lkdGg/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHtcbiAgLyoqXG4gICAqIERlc2NyaWJlcyBub3JtYWxpemF0aW9uIHBhcmFtZXRlcnMgd2hlbiBwcmVwcm9jZXNzaW5nIHRoZSBpbWFnZSBhcyBtb2RlbCBpbnB1dC5cbiAgICpcbiAgICogRGF0YSBlbGVtZW50IGFyZSByYW5nZWQgZnJvbSAwIHRvIDI1NS5cbiAgICovXG4gIG5vcm0/OiB7XG4gICAgLyoqXG4gICAgICogVGhlICdiaWFzJyB2YWx1ZSBmb3IgaW1hZ2Ugbm9ybWFsaXphdGlvbi5cbiAgICAgKiAtIElmIG9taXR0ZWQsIHVzZSBkZWZhdWx0IHZhbHVlIDAuXG4gICAgICogLSBJZiBpdCdzIGEgc2luZ2xlIG51bWJlciwgYXBwbHkgdG8gZWFjaCBjaGFubmVsXG4gICAgICogLSBJZiBpdCdzIGFuIGFycmF5IG9mIDMgb3IgNCBudW1iZXJzLCBhcHBseSBlbGVtZW50LXdpc2UuIE51bWJlciBvZiBlbGVtZW50cyBuZWVkIHRvIG1hdGNoIHRoZSBudW1iZXIgb2YgY2hhbm5lbHNcbiAgICAgKiBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgaW1hZ2UgZm9ybWF0XG4gICAgICovXG4gICAgYmlhcz86IG51bWJlciB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICAgIC8qKlxuICAgICAqIFRoZSAnbWVhbicgdmFsdWUgZm9yIGltYWdlIG5vcm1hbGl6YXRpb24uXG4gICAgICogLSBJZiBvbWl0dGVkLCB1c2UgZGVmYXVsdCB2YWx1ZSAyNTUuXG4gICAgICogLSBJZiBpdCdzIGEgc2luZ2xlIG51bWJlciwgYXBwbHkgdG8gZWFjaCBjaGFubmVsXG4gICAgICogLSBJZiBpdCdzIGFuIGFycmF5IG9mIDMgb3IgNCBudW1iZXJzLCBhcHBseSBlbGVtZW50LXdpc2UuIE51bWJlciBvZiBlbGVtZW50cyBuZWVkIHRvIG1hdGNoIHRoZSBudW1iZXIgb2YgY2hhbm5lbHNcbiAgICAgKiBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgaW1hZ2UgZm9ybWF0XG4gICAgICovXG4gICAgbWVhbj86IG51bWJlciB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICB9O1xufVxuXG4vLyAjZW5kcmVnaW9uXG5cbi8vICNyZWdpb24gT3B0aW9ucyBjb21wb3NpdGlvblxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZyb21JbWFnZURhdGFPcHRpb25zXG4gIGV4dGVuZHMgT3B0aW9uUmVzaXplZERpbWVuc2lvbnMsXG4gICAgT3B0aW9uc1RlbnNvckZvcm1hdCxcbiAgICBPcHRpb25zVGVuc29yTGF5b3V0LFxuICAgIE9wdGlvbnNUZW5zb3JEYXRhVHlwZSxcbiAgICBPcHRpb25zTm9ybWFsaXphdGlvblBhcmFtZXRlcnMge31cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tSW1hZ2VFbGVtZW50T3B0aW9uc1xuICBleHRlbmRzIE9wdGlvblJlc2l6ZWREaW1lbnNpb25zLFxuICAgIE9wdGlvbnNUZW5zb3JGb3JtYXQsXG4gICAgT3B0aW9uc1RlbnNvckxheW91dCxcbiAgICBPcHRpb25zVGVuc29yRGF0YVR5cGUsXG4gICAgT3B0aW9uc05vcm1hbGl6YXRpb25QYXJhbWV0ZXJzIHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yRnJvbVVybE9wdGlvbnNcbiAgZXh0ZW5kcyBPcHRpb25zRGltZW5zaW9ucyxcbiAgICBPcHRpb25SZXNpemVkRGltZW5zaW9ucyxcbiAgICBPcHRpb25zVGVuc29yRm9ybWF0LFxuICAgIE9wdGlvbnNUZW5zb3JMYXlvdXQsXG4gICAgT3B0aW9uc1RlbnNvckRhdGFUeXBlLFxuICAgIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZyb21JbWFnZUJpdG1hcE9wdGlvbnNcbiAgZXh0ZW5kcyBPcHRpb25SZXNpemVkRGltZW5zaW9ucyxcbiAgICBPcHRpb25zVGVuc29yRm9ybWF0LFxuICAgIE9wdGlvbnNUZW5zb3JMYXlvdXQsXG4gICAgT3B0aW9uc1RlbnNvckRhdGFUeXBlLFxuICAgIE9wdGlvbnNOb3JtYWxpemF0aW9uUGFyYW1ldGVycyB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZyb21UZXh0dXJlT3B0aW9uczxUIGV4dGVuZHMgVGVuc29yLlRleHR1cmVEYXRhVHlwZXM+XG4gIGV4dGVuZHMgUmVxdWlyZWQ8T3B0aW9uc0RpbWVuc2lvbnM+LFxuICAgIE9wdGlvbnNGb3JtYXQsXG4gICAgR3B1UmVzb3VyY2VDb25zdHJ1Y3RvclBhcmFtZXRlcnM8VD4gLyogVE9ETzogYWRkIG1vcmUgKi8ge31cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JGcm9tR3B1QnVmZmVyT3B0aW9uczxUIGV4dGVuZHMgVGVuc29yLkdwdUJ1ZmZlckRhdGFUeXBlcz5cbiAgZXh0ZW5kcyBQaWNrPFRlbnNvciwgJ2RpbXMnPixcbiAgICBHcHVSZXNvdXJjZUNvbnN0cnVjdG9yUGFyYW1ldGVyczxUPiB7XG4gIC8qKlxuICAgKiBEZXNjcmliZXMgdGhlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yLlxuICAgKi9cbiAgZGF0YVR5cGU/OiBUO1xufVxuXG4vLyAjZW5kcmVnaW9uXG5cbi8qKlxuICogdHlwZSBUZW5zb3JGYWN0b3J5IGRlZmluZXMgdGhlIGZhY3RvcnkgZnVuY3Rpb25zIG9mICdUZW5zb3InIHRvIGNyZWF0ZSB0ZW5zb3IgaW5zdGFuY2VzIGZyb20gZXhpc3RpbmcgZGF0YSBvclxuICogcmVzb3VyY2VzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvckZhY3Rvcnkge1xuICAvKipcbiAgICogY3JlYXRlIGEgdGVuc29yIGZyb20gYW4gSW1hZ2VEYXRhIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0gaW1hZ2VEYXRhIC0gdGhlIEltYWdlRGF0YSBvYmplY3QgdG8gY3JlYXRlIHRlbnNvciBmcm9tXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyB0ZW5zb3IgZnJvbSBJbWFnZURhdGEuXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgZGVmYXVsdCBzZXR0aW5ncyB3aWxsIGJlIGFwcGxpZWQ6XG4gICAqIC0gYHRlbnNvckZvcm1hdGA6IGAnUkdCJ2BcbiAgICogLSBgdGVuc29yTGF5b3V0YDogYCdOQ0hXJ2BcbiAgICogLSBgZGF0YVR5cGVgOiBgJ2Zsb2F0MzInYFxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHRlbnNvciBvYmplY3RcbiAgICovXG4gIGZyb21JbWFnZShcbiAgICBpbWFnZURhdGE6IEltYWdlRGF0YSxcbiAgICBvcHRpb25zPzogVGVuc29yRnJvbUltYWdlRGF0YU9wdGlvbnMsXG4gICk6IFByb21pc2U8VHlwZWRUZW5zb3I8J2Zsb2F0MzInPiB8IFR5cGVkVGVuc29yPCd1aW50OCc+PjtcblxuICAvKipcbiAgICogY3JlYXRlIGEgdGVuc29yIGZyb20gYSBIVE1MSW1hZ2VFbGVtZW50IG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0gaW1hZ2VFbGVtZW50IC0gdGhlIEhUTUxJbWFnZUVsZW1lbnQgb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gSFRNTEltYWdlRWxlbWVudC5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBkZWZhdWx0IHNldHRpbmdzIHdpbGwgYmUgYXBwbGllZDpcbiAgICogLSBgdGVuc29yRm9ybWF0YDogYCdSR0InYFxuICAgKiAtIGB0ZW5zb3JMYXlvdXRgOiBgJ05DSFcnYFxuICAgKiAtIGBkYXRhVHlwZWA6IGAnZmxvYXQzMidgXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdGVuc29yIG9iamVjdFxuICAgKi9cbiAgZnJvbUltYWdlKFxuICAgIGltYWdlRWxlbWVudDogSFRNTEltYWdlRWxlbWVudCxcbiAgICBvcHRpb25zPzogVGVuc29yRnJvbUltYWdlRWxlbWVudE9wdGlvbnMsXG4gICk6IFByb21pc2U8VHlwZWRUZW5zb3I8J2Zsb2F0MzInPiB8IFR5cGVkVGVuc29yPCd1aW50OCc+PjtcblxuICAvKipcbiAgICogY3JlYXRlIGEgdGVuc29yIGZyb20gVVJMXG4gICAqXG4gICAqIEBwYXJhbSB1cmxTb3VyY2UgLSBhIHN0cmluZyBhcyBhIFVSTCB0byB0aGUgaW1hZ2Ugb3IgYSBkYXRhIFVSTCBjb250YWluaW5nIHRoZSBpbWFnZSBkYXRhLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gVVJMLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGRlZmF1bHQgc2V0dGluZ3Mgd2lsbCBiZSBhcHBsaWVkOlxuICAgKiAtIGB0ZW5zb3JGb3JtYXRgOiBgJ1JHQidgXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXG4gICAqIC0gYGRhdGFUeXBlYDogYCdmbG9hdDMyJ2BcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSB0ZW5zb3Igb2JqZWN0XG4gICAqL1xuICBmcm9tSW1hZ2UodXJsU291cmNlOiBzdHJpbmcsIG9wdGlvbnM/OiBUZW5zb3JGcm9tVXJsT3B0aW9ucyk6IFByb21pc2U8VHlwZWRUZW5zb3I8J2Zsb2F0MzInPiB8IFR5cGVkVGVuc29yPCd1aW50OCc+PjtcblxuICAvKipcbiAgICogY3JlYXRlIGEgdGVuc29yIGZyb20gYW4gSW1hZ2VCaXRtYXAgb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSBiaXRtYXAgLSB0aGUgSW1hZ2VCaXRtYXAgb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gVVJMLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGRlZmF1bHQgc2V0dGluZ3Mgd2lsbCBiZSBhcHBsaWVkOlxuICAgKiAtIGB0ZW5zb3JGb3JtYXRgOiBgJ1JHQidgXG4gICAqIC0gYHRlbnNvckxheW91dGA6IGAnTkNIVydgXG4gICAqIC0gYGRhdGFUeXBlYDogYCdmbG9hdDMyJ2BcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSB0ZW5zb3Igb2JqZWN0XG4gICAqL1xuICBmcm9tSW1hZ2UoXG4gICAgYml0bWFwOiBJbWFnZUJpdG1hcCxcbiAgICBvcHRpb25zOiBUZW5zb3JGcm9tSW1hZ2VCaXRtYXBPcHRpb25zLFxuICApOiBQcm9taXNlPFR5cGVkVGVuc29yPCdmbG9hdDMyJz4gfCBUeXBlZFRlbnNvcjwndWludDgnPj47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIGEgV2ViR0wgdGV4dHVyZVxuICAgKlxuICAgKiBAcGFyYW0gdGV4dHVyZSAtIHRoZSBXZWJHTFRleHR1cmUgb2JqZWN0IHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbmFsIG9iamVjdCByZXByZXNlbnRpbmcgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGVuc29yIGZyb20gV2ViR0wgdGV4dHVyZS5cbiAgICpcbiAgICogVGhlIG9wdGlvbnMgaW5jbHVkZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogLSBgd2lkdGhgOiB0aGUgd2lkdGggb2YgdGhlIHRleHR1cmUuIFJlcXVpcmVkLlxuICAgKiAtIGBoZWlnaHRgOiB0aGUgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlLiBSZXF1aXJlZC5cbiAgICogLSBgZm9ybWF0YDogdGhlIGZvcm1hdCBvZiB0aGUgdGV4dHVyZS4gSWYgb21pdHRlZCwgYXNzdW1lICdSR0JBJy5cbiAgICogLSBgZG93bmxvYWRgOiBhbiBvcHRpb25hbCBmdW5jdGlvbiB0byBkb3dubG9hZCB0aGUgdGVuc29yIGRhdGEgZnJvbSBHUFUgdG8gQ1BVLiBJZiBvbWl0dGVkLCB0aGUgR1BVIGRhdGFcbiAgICogd2lsbCBub3QgYmUgYWJsZSB0byBkb3dubG9hZC4gVXN1YWxseSwgdGhpcyBpcyBwcm92aWRlZCBieSBhIEdQVSBiYWNrZW5kIGZvciB0aGUgaW5mZXJlbmNlIG91dHB1dHMuIFVzZXJzIGRvbid0XG4gICAqIG5lZWQgdG8gcHJvdmlkZSB0aGlzIGZ1bmN0aW9uLlxuICAgKiAtIGBkaXNwb3NlYDogYW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZGlzcG9zZSB0aGUgdGVuc29yIGRhdGEgb24gR1BVLiBJZiBvbWl0dGVkLCB0aGUgR1BVIGRhdGEgd2lsbCBub3QgYmUgZGlzcG9zZWQuXG4gICAqIFVzdWFsbHksIHRoaXMgaXMgcHJvdmlkZWQgYnkgYSBHUFUgYmFja2VuZCBmb3IgdGhlIGluZmVyZW5jZSBvdXRwdXRzLiBVc2VycyBkb24ndCBuZWVkIHRvIHByb3ZpZGUgdGhpcyBmdW5jdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMgYSB0ZW5zb3Igb2JqZWN0XG4gICAqL1xuICBmcm9tVGV4dHVyZTxUIGV4dGVuZHMgVGVuc29yLlRleHR1cmVEYXRhVHlwZXMgPSAnZmxvYXQzMic+KFxuICAgIHRleHR1cmU6IFRlbnNvci5UZXh0dXJlVHlwZSxcbiAgICBvcHRpb25zOiBUZW5zb3JGcm9tVGV4dHVyZU9wdGlvbnM8VD4sXG4gICk6IFR5cGVkVGVuc29yPCdmbG9hdDMyJz47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIGEgV2ViR1BVIGJ1ZmZlclxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIC0gdGhlIEdQVUJ1ZmZlciBvYmplY3QgdG8gY3JlYXRlIHRlbnNvciBmcm9tXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IHJlcHJlc2VudGluZyBvcHRpb25zIGZvciBjcmVhdGluZyB0ZW5zb3IgZnJvbSBXZWJHUFUgYnVmZmVyLlxuICAgKlxuICAgKiBUaGUgb3B0aW9ucyBpbmNsdWRlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiAtIGBkYXRhVHlwZWA6IHRoZSBkYXRhIHR5cGUgb2YgdGhlIHRlbnNvci4gSWYgb21pdHRlZCwgYXNzdW1lICdmbG9hdDMyJy5cbiAgICogLSBgZGltc2A6IHRoZSBkaW1lbnNpb24gb2YgdGhlIHRlbnNvci4gUmVxdWlyZWQuXG4gICAqIC0gYGRvd25sb2FkYDogYW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZG93bmxvYWQgdGhlIHRlbnNvciBkYXRhIGZyb20gR1BVIHRvIENQVS4gSWYgb21pdHRlZCwgdGhlIEdQVSBkYXRhXG4gICAqIHdpbGwgbm90IGJlIGFibGUgdG8gZG93bmxvYWQuIFVzdWFsbHksIHRoaXMgaXMgcHJvdmlkZWQgYnkgYSBHUFUgYmFja2VuZCBmb3IgdGhlIGluZmVyZW5jZSBvdXRwdXRzLiBVc2VycyBkb24ndFxuICAgKiBuZWVkIHRvIHByb3ZpZGUgdGhpcyBmdW5jdGlvbi5cbiAgICogLSBgZGlzcG9zZWA6IGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGRpc3Bvc2UgdGhlIHRlbnNvciBkYXRhIG9uIEdQVS4gSWYgb21pdHRlZCwgdGhlIEdQVSBkYXRhIHdpbGwgbm90IGJlIGRpc3Bvc2VkLlxuICAgKiBVc3VhbGx5LCB0aGlzIGlzIHByb3ZpZGVkIGJ5IGEgR1BVIGJhY2tlbmQgZm9yIHRoZSBpbmZlcmVuY2Ugb3V0cHV0cy4gVXNlcnMgZG9uJ3QgbmVlZCB0byBwcm92aWRlIHRoaXMgZnVuY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIGEgdGVuc29yIG9iamVjdFxuICAgKi9cbiAgZnJvbUdwdUJ1ZmZlcjxUIGV4dGVuZHMgVGVuc29yLkdwdUJ1ZmZlckRhdGFUeXBlcz4oXG4gICAgYnVmZmVyOiBUZW5zb3IuR3B1QnVmZmVyVHlwZSxcbiAgICBvcHRpb25zOiBUZW5zb3JGcm9tR3B1QnVmZmVyT3B0aW9uczxUPixcbiAgKTogVHlwZWRUZW5zb3I8VD47XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIHRlbnNvciBmcm9tIGEgcHJlLWFsbG9jYXRlZCBidWZmZXIuIFRoZSBidWZmZXIgd2lsbCBiZSB1c2VkIGFzIGEgcGlubmVkIGJ1ZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSB0aGUgdGVuc29yIGVsZW1lbnQgdHlwZS5cbiAgICogQHBhcmFtIGJ1ZmZlciAtIGEgVHlwZWRBcnJheSBjb3JyZXNwb25kaW5nIHRvIHRoZSB0eXBlLlxuICAgKiBAcGFyYW0gZGltcyAtIHNwZWNpZnkgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGVuc29yLiBJZiBvbWl0dGVkLCBhIDEtRCB0ZW5zb3IgaXMgYXNzdW1lZC5cbiAgICpcbiAgICogQHJldHVybnMgYSB0ZW5zb3Igb2JqZWN0XG4gICAqL1xuICBmcm9tUGlubmVkQnVmZmVyPFQgZXh0ZW5kcyBFeGNsdWRlPFRlbnNvci5UeXBlLCAnc3RyaW5nJz4+KFxuICAgIHR5cGU6IFQsXG4gICAgYnVmZmVyOiBUZW5zb3IuRGF0YVR5cGVNYXBbVF0sXG4gICAgZGltcz86IHJlYWRvbmx5IG51bWJlcltdLFxuICApOiBUeXBlZFRlbnNvcjxUPjtcbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLyoqXG4gKiBBIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBmaWxlJ3MgVVJMIG9yIHBhdGguXG4gKlxuICogUGF0aCBpcyB2YWlsYWJsZSBvbmx5IGluIG9ubnhydW50aW1lLW5vZGUgb3Igb25ueHJ1bnRpbWUtd2ViIHJ1bm5pbmcgaW4gTm9kZS5qcy5cbiAqL1xuZXhwb3J0IHR5cGUgRmlsZVVybE9yUGF0aCA9IHN0cmluZztcblxuLyoqXG4gKiBBIEJsb2Igb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIGZpbGUuXG4gKi9cbmV4cG9ydCB0eXBlIEZpbGVCbG9iID0gQmxvYjtcblxuLyoqXG4gKiBBIFVpbnQ4QXJyYXksIEFycmF5QnVmZmVyIG9yIFNoYXJlZEFycmF5QnVmZmVyIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgYSBmaWxlIGNvbnRlbnQuXG4gKlxuICogV2hlbiBpdCBpcyBhbiBBcnJheUJ1ZmZlciBvciBTaGFyZWRBcnJheUJ1ZmZlciwgdGhlIHdob2xlIGJ1ZmZlciBpcyBhc3N1bWVkIHRvIGJlIHRoZSBmaWxlIGNvbnRlbnQuXG4gKi9cbmV4cG9ydCB0eXBlIEZpbGVEYXRhID0gVWludDhBcnJheSB8IEFycmF5QnVmZmVyTGlrZTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgZmlsZSB0aGF0IGNhbiBiZSBsb2FkZWQgYnkgdGhlIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSS5cbiAqL1xuZXhwb3J0IHR5cGUgRmlsZVR5cGUgPSBGaWxlVXJsT3JQYXRoIHwgRmlsZUJsb2IgfCBGaWxlRGF0YTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGV4dGVybmFsIGRhdGEgZmlsZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFeHRlcm5hbERhdGFGaWxlRGVzY3JpcHRpb24ge1xuICAvKipcbiAgICogU3BlY2lmeSB0aGUgZXh0ZXJuYWwgZGF0YSBmaWxlLlxuICAgKi9cbiAgZGF0YTogRmlsZVR5cGU7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBmaWxlIHBhdGguXG4gICAqL1xuICBwYXRoOiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBleHRlcm5hbCBkYXRhIGZpbGUuXG4gKlxuICogV2hlbiB1c2luZyBhIHN0cmluZywgaXQgc2hvdWxkIGJlIGEgZmlsZSBVUkwgb3IgcGF0aCB0aGF0IGluIHRoZSBzYW1lIGRpcmVjdG9yeSBhcyB0aGUgbW9kZWwgZmlsZS5cbiAqL1xuZXhwb3J0IHR5cGUgRXh0ZXJuYWxEYXRhRmlsZVR5cGUgPSBFeHRlcm5hbERhdGFGaWxlRGVzY3JpcHRpb24gfCBGaWxlVXJsT3JQYXRoO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIG1vZGVsIGxvYWRpbmcuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT25ueE1vZGVsT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5aW5nIGEgbGlzdCBvZiBmaWxlcyB0aGF0IHJlcHJlc2VudHMgdGhlIGV4dGVybmFsIGRhdGEuXG4gICAqL1xuICBleHRlcm5hbERhdGE/OiByZWFkb25seSBFeHRlcm5hbERhdGFGaWxlVHlwZVtdO1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuL3RlbnNvci5qcyc7XG5cbmV4cG9ydCB0eXBlIE5vblRlbnNvclR5cGUgPSBuZXZlcjtcblxuLyoqXG4gKiBUeXBlIE9ubnhWYWx1ZSBSZXByZXNlbnRzIGJvdGggdGVuc29ycyBhbmQgbm9uLXRlbnNvcnMgdmFsdWUgZm9yIG1vZGVsJ3MgaW5wdXRzL291dHB1dHMuXG4gKlxuICogTk9URTogY3VycmVudGx5IG5vdCBzdXBwb3J0IG5vbi10ZW5zb3JcbiAqL1xuZXhwb3J0IHR5cGUgT25ueFZhbHVlID0gVGVuc29yIHwgTm9uVGVuc29yVHlwZTtcblxuLyoqXG4gKiBUeXBlIE9ubnhWYWx1ZURhdGFMb2NhdGlvbiByZXByZXNlbnRzIHRoZSBsb2NhdGlvbiBvZiB0aGUgZGF0YSBvZiBhbiBPbm54VmFsdWUuXG4gKi9cbmV4cG9ydCB0eXBlIE9ubnhWYWx1ZURhdGFMb2NhdGlvbiA9IFRlbnNvci5EYXRhTG9jYXRpb247XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IHJlc29sdmVCYWNrZW5kQW5kRXhlY3V0aW9uUHJvdmlkZXJzIH0gZnJvbSAnLi9iYWNrZW5kLWltcGwuanMnO1xuaW1wb3J0IHsgU2Vzc2lvbkhhbmRsZXIsIFRyYWluaW5nU2Vzc2lvbkhhbmRsZXIgfSBmcm9tICcuL2JhY2tlbmQuanMnO1xuaW1wb3J0IHsgSW5mZXJlbmNlU2Vzc2lvbiBhcyBJbmZlcmVuY2VTZXNzaW9uIH0gZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi5qcyc7XG5pbXBvcnQgeyBPbm54VmFsdWUgfSBmcm9tICcuL29ubngtdmFsdWUuanMnO1xuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnLi90ZW5zb3IuanMnO1xuaW1wb3J0IHsgVHJhaW5pbmdTZXNzaW9uIGFzIFRyYWluaW5nU2Vzc2lvbkludGVyZmFjZSwgVHJhaW5pbmdTZXNzaW9uQ3JlYXRlT3B0aW9ucyB9IGZyb20gJy4vdHJhaW5pbmctc2Vzc2lvbi5qcyc7XG5cbnR5cGUgU2Vzc2lvbk9wdGlvbnMgPSBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zO1xudHlwZSBGZWVkc1R5cGUgPSBJbmZlcmVuY2VTZXNzaW9uLkZlZWRzVHlwZTtcbnR5cGUgRmV0Y2hlc1R5cGUgPSBJbmZlcmVuY2VTZXNzaW9uLkZldGNoZXNUeXBlO1xudHlwZSBSZXR1cm5UeXBlID0gSW5mZXJlbmNlU2Vzc2lvbi5SZXR1cm5UeXBlO1xudHlwZSBSdW5PcHRpb25zID0gSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zO1xuXG5jb25zdCBub0JhY2tlbmRFcnJNc2c6IHN0cmluZyA9XG4gICdUcmFpbmluZyBiYWNrZW5kIGNvdWxkIG5vdCBiZSByZXNvbHZlZC4gJyArIFwiTWFrZSBzdXJlIHlvdSdyZSB1c2luZyB0aGUgY29ycmVjdCBjb25maWd1cmF0aW9uICYgV2ViQXNzZW1ibHkgZmlsZXMuXCI7XG5cbmV4cG9ydCBjbGFzcyBUcmFpbmluZ1Nlc3Npb24gaW1wbGVtZW50cyBUcmFpbmluZ1Nlc3Npb25JbnRlcmZhY2Uge1xuICBwcml2YXRlIGNvbnN0cnVjdG9yKGhhbmRsZXI6IFRyYWluaW5nU2Vzc2lvbkhhbmRsZXIsIGhhc09wdGltaXplck1vZGVsOiBib29sZWFuLCBoYXNFdmFsTW9kZWw6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIHRoaXMuaGFzT3B0aW1pemVyTW9kZWwgPSBoYXNPcHRpbWl6ZXJNb2RlbDtcbiAgICB0aGlzLmhhc0V2YWxNb2RlbCA9IGhhc0V2YWxNb2RlbDtcbiAgfVxuICBwcml2YXRlIGhhbmRsZXI6IFRyYWluaW5nU2Vzc2lvbkhhbmRsZXI7XG4gIHByaXZhdGUgaGFzT3B0aW1pemVyTW9kZWw6IGJvb2xlYW47XG4gIHByaXZhdGUgaGFzRXZhbE1vZGVsOiBib29sZWFuO1xuXG4gIGdldCB0cmFpbmluZ0lucHV0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuaW5wdXROYW1lcztcbiAgfVxuICBnZXQgdHJhaW5pbmdPdXRwdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vdXRwdXROYW1lcztcbiAgfVxuXG4gIGdldCBldmFsSW5wdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgaWYgKHRoaXMuaGFzRXZhbE1vZGVsKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmV2YWxJbnB1dE5hbWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdHJhaW5pbmcgc2Vzc2lvbiBoYXMgbm8gZXZhbE1vZGVsIGxvYWRlZC4nKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGV2YWxPdXRwdXROYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgaWYgKHRoaXMuaGFzRXZhbE1vZGVsKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmV2YWxPdXRwdXROYW1lcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHRyYWluaW5nIHNlc3Npb24gaGFzIG5vIGV2YWxNb2RlbCBsb2FkZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZShcbiAgICB0cmFpbmluZ09wdGlvbnM6IFRyYWluaW5nU2Vzc2lvbkNyZWF0ZU9wdGlvbnMsXG4gICAgc2Vzc2lvbk9wdGlvbnM/OiBTZXNzaW9uT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxUcmFpbmluZ1Nlc3Npb24+IHtcbiAgICBjb25zdCBldmFsTW9kZWw6IHN0cmluZyB8IFVpbnQ4QXJyYXkgPSB0cmFpbmluZ09wdGlvbnMuZXZhbE1vZGVsIHx8ICcnO1xuICAgIGNvbnN0IG9wdGltaXplck1vZGVsOiBzdHJpbmcgfCBVaW50OEFycmF5ID0gdHJhaW5pbmdPcHRpb25zLm9wdGltaXplck1vZGVsIHx8ICcnO1xuICAgIGNvbnN0IG9wdGlvbnM6IFNlc3Npb25PcHRpb25zID0gc2Vzc2lvbk9wdGlvbnMgfHwge307XG5cbiAgICAvLyByZXNvbHZlIGJhY2tlbmQsIHVwZGF0ZSBzZXNzaW9uIG9wdGlvbnMgd2l0aCB2YWxpZGF0ZWQgRVBzLCBhbmQgY3JlYXRlIHNlc3Npb24gaGFuZGxlclxuICAgIGNvbnN0IFtiYWNrZW5kLCBvcHRpb25zV2l0aFZhbGlkYXRlZEVQc10gPSBhd2FpdCByZXNvbHZlQmFja2VuZEFuZEV4ZWN1dGlvblByb3ZpZGVycyhvcHRpb25zKTtcbiAgICBpZiAoYmFja2VuZC5jcmVhdGVUcmFpbmluZ1Nlc3Npb25IYW5kbGVyKSB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gYXdhaXQgYmFja2VuZC5jcmVhdGVUcmFpbmluZ1Nlc3Npb25IYW5kbGVyKFxuICAgICAgICB0cmFpbmluZ09wdGlvbnMuY2hlY2twb2ludFN0YXRlLFxuICAgICAgICB0cmFpbmluZ09wdGlvbnMudHJhaW5Nb2RlbCxcbiAgICAgICAgZXZhbE1vZGVsLFxuICAgICAgICBvcHRpbWl6ZXJNb2RlbCxcbiAgICAgICAgb3B0aW9uc1dpdGhWYWxpZGF0ZWRFUHMsXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ldyBUcmFpbmluZ1Nlc3Npb24oaGFuZGxlciwgISF0cmFpbmluZ09wdGlvbnMub3B0aW1pemVyTW9kZWwsICEhdHJhaW5pbmdPcHRpb25zLmV2YWxNb2RlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihub0JhY2tlbmRFcnJNc2cpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIHJ1blRyYWluU3RlcCBhbmQgZnV0dXJlIHJ1blN0ZXAgbWV0aG9kcyB0aGF0IGhhbmRsZXMgdGhlIHR5cGUtbmFycm93aW5nIGNvbnZlcnNpb24gZnJvbVxuICAgKiB0aGUgZ2l2ZW4gcGFyYW1ldGVycyB0byBTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSBhbmQgUnVuT3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0TmFtZXMgdGhlIGZlZWRzIG9iamVjdCBpcyBjaGVja2VkIHRoYXQgdGhleSBjb250YWluIGFsbCBpbnB1dCBuYW1lcyBpbiB0aGUgcHJvdmlkZWQgbGlzdCBvZiBpbnB1dFxuICAgKiBuYW1lcy5cbiAgICogQHBhcmFtIG91dHB1dE5hbWVzIHRoZSBmZXRjaGVzIG9iamVjdCBpcyBjaGVja2VkIHRoYXQgdGhlaXIga2V5cyBtYXRjaCB1cCB3aXRoIHZhbGlkIG5hbWVzIGluIHRoZSBsaXN0IG9mIG91dHB1dFxuICAgKiBuYW1lcy5cbiAgICogQHBhcmFtIGZlZWRzIHRoZSByZXF1aXJlZCBpbnB1dFxuICAgKiBAcGFyYW0gYXJnMSBuYXJyb3dlZCAmIGNvbnZlcnRlZCBpbnRvIHRoZSBTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSBvciBSdW5PcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0gYXJnMiBvcHRpb25hbCBSdW5PcHRpb25zIG9iamVjdC5cbiAgICogQHJldHVybnNcbiAgICovXG4gIHR5cGVOYXJyb3dpbmdGb3JSdW5TdGVwKFxuICAgIGlucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdLFxuICAgIG91dHB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXSxcbiAgICBmZWVkczogRmVlZHNUeXBlLFxuICAgIGFyZzE/OiBGZXRjaGVzVHlwZSB8IFJ1bk9wdGlvbnMsXG4gICAgYXJnMj86IFJ1bk9wdGlvbnMsXG4gICk6IFtTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSwgUnVuT3B0aW9uc10ge1xuICAgIGNvbnN0IGZldGNoZXM6IHsgW25hbWU6IHN0cmluZ106IE9ubnhWYWx1ZSB8IG51bGwgfSA9IHt9O1xuICAgIGxldCBvcHRpb25zOiBSdW5PcHRpb25zID0ge307XG4gICAgLy8gY2hlY2sgaW5wdXRzXG4gICAgaWYgKHR5cGVvZiBmZWVkcyAhPT0gJ29iamVjdCcgfHwgZmVlZHMgPT09IG51bGwgfHwgZmVlZHMgaW5zdGFuY2VvZiBUZW5zb3IgfHwgQXJyYXkuaXNBcnJheShmZWVkcykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiJ2ZlZWRzJyBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IHVzZSBpbnB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXCIsXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCBpc0ZldGNoZXNFbXB0eSA9IHRydWU7XG4gICAgLy8gZGV0ZXJtaW5lIHdoaWNoIG92ZXJyaWRlIGlzIGJlaW5nIHVzZWRcbiAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoYXJnMSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBjYW5ub3QgYmUgbnVsbC4nKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmcxIGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgY2Fubm90IGJlIGEgVGVuc29yXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcxKSkge1xuICAgICAgICBpZiAoYXJnMS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaXNGZXRjaGVzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgLy8gb3V0cHV0IG5hbWVzXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBhcmcxKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBtdXN0IGJlIGEgc3RyaW5nIGFycmF5IG9yIGFuIG9iamVjdC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvdXRwdXROYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdmZXRjaGVzJyBjb250YWlucyBpbnZhbGlkIG91dHB1dCBuYW1lOiAke25hbWV9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmZXRjaGVzW25hbWVdID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ29iamVjdCcgJiYgYXJnMiAhPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWNpZGUgd2hldGhlciBhcmcxIGlzIGZldGNoZXMgb3Igb3B0aW9uc1xuICAgICAgICAvLyBpZiBhbnkgb3V0cHV0IG5hbWUgaXMgcHJlc2VudCBhbmQgaXRzIHZhbHVlIGlzIHZhbGlkIE9ubnhWYWx1ZSwgd2UgY29uc2lkZXIgaXQgZmV0Y2hlc1xuICAgICAgICBsZXQgaXNGZXRjaGVzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGFyZzFLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJnMSk7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBvdXRwdXROYW1lcykge1xuICAgICAgICAgIGlmIChhcmcxS2V5cy5pbmRleE9mKG5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgdiA9IChhcmcxIGFzIEluZmVyZW5jZVNlc3Npb24uTnVsbGFibGVPbm54VmFsdWVNYXBUeXBlKVtuYW1lXTtcbiAgICAgICAgICAgIGlmICh2ID09PSBudWxsIHx8IHYgaW5zdGFuY2VvZiBUZW5zb3IpIHtcbiAgICAgICAgICAgICAgaXNGZXRjaGVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaXNGZXRjaGVzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgZmV0Y2hlc1tuYW1lXSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRmV0Y2hlcykge1xuICAgICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ29iamVjdCcgJiYgYXJnMiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zID0gYXJnMSBhcyBSdW5PcHRpb25zO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJnMSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBtdXN0IGJlICdmZXRjaGVzJyBvciAnb3B0aW9ucycuXCIpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIGFsbCBpbnB1dHMgYXJlIGluIGZlZWRcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgaW5wdXROYW1lcykge1xuICAgICAgaWYgKHR5cGVvZiBmZWVkc1tuYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnB1dCAnJHtuYW1lfScgaXMgbWlzc2luZyBpbiAnZmVlZHMnLmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIG5vIGZldGNoZXMgaXMgc3BlY2lmaWVkLCB3ZSB1c2UgdGhlIGZ1bGwgb3V0cHV0IG5hbWVzIGxpc3RcbiAgICBpZiAoaXNGZXRjaGVzRW1wdHkpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBvdXRwdXROYW1lcykge1xuICAgICAgICBmZXRjaGVzW25hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW2ZldGNoZXMsIG9wdGlvbnNdO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBtZXRob2QgZm9yIHJ1blRyYWluU3RlcCBhbmQgYW55IG90aGVyIHJ1blN0ZXAgbWV0aG9kcy4gVGFrZXMgdGhlIFJldHVyblR5cGUgcmVzdWx0IGZyb20gdGhlIFNlc3Npb25IYW5kbGVyXG4gICAqIGFuZCBjaGFuZ2VzIGl0IGludG8gYSBtYXAgb2YgVGVuc29ycy5cbiAgICpcbiAgICogQHBhcmFtIHJlc3VsdHNcbiAgICogQHJldHVybnNcbiAgICovXG4gIGNvbnZlcnRIYW5kbGVyUmV0dXJuVHlwZVRvTWFwT2ZUZW5zb3JzKHJlc3VsdHM6IFNlc3Npb25IYW5kbGVyLlJldHVyblR5cGUpOiBSZXR1cm5UeXBlIHtcbiAgICBjb25zdCByZXR1cm5WYWx1ZTogeyBbbmFtZTogc3RyaW5nXTogT25ueFZhbHVlIH0gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiByZXN1bHRzKSB7XG4gICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0cywga2V5KSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZXN1bHRzW2tleV07XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBUZW5zb3IpIHtcbiAgICAgICAgICByZXR1cm5WYWx1ZVtrZXldID0gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVyblZhbHVlW2tleV0gPSBuZXcgVGVuc29yKHJlc3VsdC50eXBlLCByZXN1bHQuZGF0YSwgcmVzdWx0LmRpbXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfVxuXG4gIGFzeW5jIGxhenlSZXNldEdyYWQoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5oYW5kbGVyLmxhenlSZXNldEdyYWQoKTtcbiAgfVxuXG4gIHJ1blRyYWluU3RlcChmZWVkczogRmVlZHNUeXBlLCBvcHRpb25zPzogUnVuT3B0aW9ucyk6IFByb21pc2U8UmV0dXJuVHlwZT47XG4gIHJ1blRyYWluU3RlcChmZWVkczogRmVlZHNUeXBlLCBmZXRjaGVzOiBGZXRjaGVzVHlwZSwgb3B0aW9ucz86IFJ1bk9wdGlvbnMpOiBQcm9taXNlPFJldHVyblR5cGU+O1xuICBhc3luYyBydW5UcmFpblN0ZXAoZmVlZHM6IEZlZWRzVHlwZSwgYXJnMT86IEZldGNoZXNUeXBlIHwgUnVuT3B0aW9ucywgYXJnMj86IFJ1bk9wdGlvbnMpOiBQcm9taXNlPFJldHVyblR5cGU+IHtcbiAgICBjb25zdCBbZmV0Y2hlcywgb3B0aW9uc10gPSB0aGlzLnR5cGVOYXJyb3dpbmdGb3JSdW5TdGVwKFxuICAgICAgdGhpcy50cmFpbmluZ0lucHV0TmFtZXMsXG4gICAgICB0aGlzLnRyYWluaW5nT3V0cHV0TmFtZXMsXG4gICAgICBmZWVkcyxcbiAgICAgIGFyZzEsXG4gICAgICBhcmcyLFxuICAgICk7XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuaGFuZGxlci5ydW5UcmFpblN0ZXAoZmVlZHMsIGZldGNoZXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLmNvbnZlcnRIYW5kbGVyUmV0dXJuVHlwZVRvTWFwT2ZUZW5zb3JzKHJlc3VsdHMpO1xuICB9XG5cbiAgYXN5bmMgcnVuT3B0aW1pemVyU3RlcChvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5SdW5PcHRpb25zIHwgdW5kZWZpbmVkKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuaGFzT3B0aW1pemVyTW9kZWwpIHtcbiAgICAgIGF3YWl0IHRoaXMuaGFuZGxlci5ydW5PcHRpbWl6ZXJTdGVwKG9wdGlvbnMgfHwge30pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgVHJhaW5pbmdTZXNzaW9uIGhhcyBubyBPcHRpbWl6ZXJNb2RlbCBsb2FkZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgcnVuRXZhbFN0ZXAoZmVlZHM6IEZlZWRzVHlwZSwgb3B0aW9ucz86IFJ1bk9wdGlvbnMgfCB1bmRlZmluZWQpOiBQcm9taXNlPFJldHVyblR5cGU+O1xuICBydW5FdmFsU3RlcChmZWVkczogRmVlZHNUeXBlLCBmZXRjaGVzOiBGZXRjaGVzVHlwZSwgb3B0aW9ucz86IFJ1bk9wdGlvbnMgfCB1bmRlZmluZWQpOiBQcm9taXNlPFJldHVyblR5cGU+O1xuICBhc3luYyBydW5FdmFsU3RlcChmZWVkczogRmVlZHNUeXBlLCBhcmcxPzogRmV0Y2hlc1R5cGUgfCBSdW5PcHRpb25zLCBhcmcyPzogUnVuT3B0aW9ucyk6IFByb21pc2U8UmV0dXJuVHlwZT4ge1xuICAgIGlmICh0aGlzLmhhc0V2YWxNb2RlbCkge1xuICAgICAgY29uc3QgW2ZldGNoZXMsIG9wdGlvbnNdID0gdGhpcy50eXBlTmFycm93aW5nRm9yUnVuU3RlcChcbiAgICAgICAgdGhpcy5ldmFsSW5wdXROYW1lcyxcbiAgICAgICAgdGhpcy5ldmFsT3V0cHV0TmFtZXMsXG4gICAgICAgIGZlZWRzLFxuICAgICAgICBhcmcxLFxuICAgICAgICBhcmcyLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLmhhbmRsZXIucnVuRXZhbFN0ZXAoZmVlZHMsIGZldGNoZXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuY29udmVydEhhbmRsZXJSZXR1cm5UeXBlVG9NYXBPZlRlbnNvcnMocmVzdWx0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBUcmFpbmluZ1Nlc3Npb24gaGFzIG5vIEV2YWxNb2RlbCBsb2FkZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0UGFyYW1ldGVyc1NpemUodHJhaW5hYmxlT25seSA9IHRydWUpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZ2V0UGFyYW1ldGVyc1NpemUodHJhaW5hYmxlT25seSk7XG4gIH1cblxuICBhc3luYyBsb2FkUGFyYW1ldGVyc0J1ZmZlcihhcnJheTogVWludDhBcnJheSwgdHJhaW5hYmxlT25seSA9IHRydWUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBwYXJhbXNTaXplID0gYXdhaXQgdGhpcy5nZXRQYXJhbWV0ZXJzU2l6ZSh0cmFpbmFibGVPbmx5KTtcbiAgICAvLyBjaGVja2luZyB0aGF0IHRoZSBzaXplIG9mIHRoZSBVaW50OEFycmF5IGlzIGVxdWl2YWxlbnQgdG8gdGhlIGJ5dGUgbGVuZ3RoIG9mIGEgRmxvYXQzMkFycmF5IG9mIHRoZSBudW1iZXJcbiAgICAvLyBvZiBwYXJhbWV0ZXJzXG4gICAgaWYgKGFycmF5Lmxlbmd0aCAhPT0gNCAqIHBhcmFtc1NpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1NpemUgb2YgdGhlIGJ1ZmZlciBwYXNzZWQgaW50byBsb2FkUGFyYW1ldGVyc0J1ZmZlciBtdXN0IG1hdGNoIHRoZSBudW1iZXIgb2YgcGFyYW1ldGVycyBpbiAnICtcbiAgICAgICAgICAndGhlIG1vZGVsLiBQbGVhc2UgdXNlIGdldFBhcmFtZXRlcnNTaXplIG1ldGhvZCB0byBjaGVjay4nLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5sb2FkUGFyYW1ldGVyc0J1ZmZlcihhcnJheSwgdHJhaW5hYmxlT25seSk7XG4gIH1cblxuICBhc3luYyBnZXRDb250aWd1b3VzUGFyYW1ldGVycyh0cmFpbmFibGVPbmx5ID0gdHJ1ZSk6IFByb21pc2U8T25ueFZhbHVlPiB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5nZXRDb250aWd1b3VzUGFyYW1ldGVycyh0cmFpbmFibGVPbmx5KTtcbiAgfVxuXG4gIGFzeW5jIHJlbGVhc2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5kaXNwb3NlKCk7XG4gIH1cbn1cbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgSW5mZXJlbmNlU2Vzc2lvbiB9IGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24uanMnO1xuaW1wb3J0IHsgT25ueFZhbHVlIH0gZnJvbSAnLi9vbm54LXZhbHVlLmpzJztcbmltcG9ydCB7IFRyYWluaW5nU2Vzc2lvbiBhcyBUcmFpbmluZ1Nlc3Npb25JbXBsIH0gZnJvbSAnLi90cmFpbmluZy1zZXNzaW9uLWltcGwuanMnO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkZWNsYXJlICovXG5cbmV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSBUcmFpbmluZ1Nlc3Npb24ge1xuICAvKipcbiAgICogRWl0aGVyIFVSSSBmaWxlIHBhdGggKHN0cmluZykgb3IgVWludDhBcnJheSBjb250YWluaW5nIG1vZGVsIG9yIGNoZWNrcG9pbnQgaW5mb3JtYXRpb24uXG4gICAqL1xuICB0eXBlIFVyaU9yQnVmZmVyID0gc3RyaW5nIHwgVWludDhBcnJheTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnQgYSBydW50aW1lIGluc3RhbmNlIG9mIGFuIE9OTlggdHJhaW5pbmcgc2Vzc2lvbixcbiAqIHdoaWNoIGNvbnRhaW5zIGEgbW9kZWwgdGhhdCBjYW4gYmUgdHJhaW5lZCwgYW5kLCBvcHRpb25hbGx5LFxuICogYW4gZXZhbCBhbmQgb3B0aW1pemVyIG1vZGVsLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYWluaW5nU2Vzc2lvbiB7XG4gIC8vICNyZWdpb24gcnVuKClcblxuICAvKipcbiAgICogTGF6aWx5IHJlc2V0cyB0aGUgZ3JhZGllbnRzIG9mIGFsbCB0cmFpbmFibGUgcGFyYW1ldGVycyB0byB6ZXJvLiBTaG91bGQgaGFwcGVuIGFmdGVyIHRoZSBpbnZvY2F0aW9uIG9mXG4gICAqIHJ1bk9wdGltaXplclN0ZXAuXG4gICAqL1xuICBsYXp5UmVzZXRHcmFkKCk6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIFJ1biBUcmFpblN0ZXAgYXN5bmNocm9ub3VzbHkgd2l0aCB0aGUgZ2l2ZW4gZmVlZHMgYW5kIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBmZWVkcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBpbnB1dC4gU2VlIHR5cGUgZGVzY3JpcHRpb24gb2YgYEluZmVyZW5jZVNlc3Npb24uSW5wdXRUeXBlYCBmb3JcbiAgIGRldGFpbC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gQSBzZXQgb2Ygb3B0aW9ucyB0aGF0IGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBtb2RlbCB0cmFpbmluZy5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBtYXAsIHdoaWNoIHVzZXMgb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICovXG4gIHJ1blRyYWluU3RlcChcbiAgICBmZWVkczogSW5mZXJlbmNlU2Vzc2lvbi5GZWVkc1R5cGUsXG4gICAgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uLlJldHVyblR5cGU+O1xuXG4gIC8qKlxuICAgKiBSdW4gYSBzaW5nbGUgdHJhaW4gc3RlcCB3aXRoIHRoZSBnaXZlbiBpbnB1dHMgYW5kIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSBmZWVkcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBpbnB1dC5cbiAgICogQHBhcmFtIGZldGNoZXMgLSBSZXByZXNlbnRhdGlvbiBvZiB0aGUgbW9kZWwgb3V0cHV0LlxuICAgKiBkZXRhaWwuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwuIEEgc2V0IG9mIG9wdGlvbnMgdGhhdCBjb250cm9scyB0aGUgYmVoYXZpb3Igb2YgbW9kZWwgdHJhaW5pbmcuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbWFwLCB3aGljaCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZ1xuICAgdmFsdWVzLlxuICAgKi9cbiAgcnVuVHJhaW5TdGVwKFxuICAgIGZlZWRzOiBJbmZlcmVuY2VTZXNzaW9uLkZlZWRzVHlwZSxcbiAgICBmZXRjaGVzOiBJbmZlcmVuY2VTZXNzaW9uLkZldGNoZXNUeXBlLFxuICAgIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMsXG4gICk6IFByb21pc2U8SW5mZXJlbmNlU2Vzc2lvbi5SZXR1cm5UeXBlPjtcblxuICAvKipcbiAgICogUnVucyBhIHNpbmdsZSBvcHRpbWl6ZXIgc3RlcCwgd2hpY2ggcGVyZm9ybXMgd2VpZ2h0IHVwZGF0ZXMgZm9yIHRoZSB0cmFpbmFibGUgcGFyYW1ldGVycyB1c2luZyB0aGUgb3B0aW1pemVyIG1vZGVsLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBBIHNldCBvZiBvcHRpb25zIHRoYXQgY29udHJvbHMgdGhlIGJlaGF2aW9yIG9mIG1vZGVsIG9wdGltaXppbmcuXG4gICAqL1xuICBydW5PcHRpbWl6ZXJTdGVwKG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBSdW4gYSBzaW5nbGUgZXZhbCBzdGVwIHdpdGggdGhlIGdpdmVuIGlucHV0cyBhbmQgb3B0aW9ucyB1c2luZyB0aGUgZXZhbCBtb2RlbC5cbiAgICpcbiAgICogQHBhcmFtIGZlZWRzIC0gUmVwcmVzZW50YXRpb24gb2YgdGhlIG1vZGVsIGlucHV0LlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsLiBBIHNldCBvZiBvcHRpb25zIHRoYXQgY29udHJvbHMgdGhlIGJlaGF2aW9yIG9mIG1vZGVsIGV2YWwgc3RlcC5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBtYXAsIHdoaWNoIHVzZXMgb3V0cHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nXG4gICB2YWx1ZXMuXG4gICAqL1xuICBydW5FdmFsU3RlcChcbiAgICBmZWVkczogSW5mZXJlbmNlU2Vzc2lvbi5GZWVkc1R5cGUsXG4gICAgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uLlJldHVyblR5cGU+O1xuXG4gIC8qKlxuICAgKiBSdW4gYSBzaW5nbGUgZXZhbCBzdGVwIHdpdGggdGhlIGdpdmVuIGlucHV0cyBhbmQgb3B0aW9ucyB1c2luZyB0aGUgZXZhbCBtb2RlbC5cbiAgICpcbiAgICogQHBhcmFtIGZlZWRzIC0gUmVwcmVzZW50YXRpb24gb2YgdGhlIG1vZGVsIGlucHV0LlxuICAgKiBAcGFyYW0gZmV0Y2hlcyAtIFJlcHJlc2VudGF0aW9uIG9mIHRoZSBtb2RlbCBvdXRwdXQuXG4gICAqIGRldGFpbC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbC4gQSBzZXQgb2Ygb3B0aW9ucyB0aGF0IGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBtb2RlbCBldmFsIHN0ZXAuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbWFwLCB3aGljaCB1c2VzIG91dHB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZ1xuICAgdmFsdWVzLlxuICAgKi9cbiAgcnVuRXZhbFN0ZXAoXG4gICAgZmVlZHM6IEluZmVyZW5jZVNlc3Npb24uRmVlZHNUeXBlLFxuICAgIGZldGNoZXM6IEluZmVyZW5jZVNlc3Npb24uRmV0Y2hlc1R5cGUsXG4gICAgb3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uLlJldHVyblR5cGU+O1xuXG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIGNvcHkgcGFyYW1ldGVyc1xuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIHNpemUgb2YgYWxsIHBhcmFtZXRlcnMgZm9yIHRoZSB0cmFpbmluZyBzdGF0ZS4gQ2FsY3VsYXRlcyB0aGUgdG90YWwgbnVtYmVyIG9mIHByaW1pdGl2ZSAoZGF0YXR5cGUgb2ZcbiAgICogdGhlIHBhcmFtZXRlcnMpIGVsZW1lbnRzIG9mIGFsbCB0aGUgcGFyYW1ldGVycyBpbiB0aGUgdHJhaW5pbmcgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB0cmFpbmFibGVPbmx5IC0gV2hlbiBzZXQgdG8gdHJ1ZSwgdGhlIHNpemUgaXMgY2FsY3VsYXRlZCBmb3IgdHJhaW5hYmxlIHBhcmFtcyBvbmx5LiBEZWZhdWx0IHZhbHVlIGlzIHRydWUuXG4gICAqL1xuICBnZXRQYXJhbWV0ZXJzU2l6ZSh0cmFpbmFibGVPbmx5OiBib29sZWFuKTogUHJvbWlzZTxudW1iZXI+O1xuXG4gIC8qKlxuICAgKiBDb3BpZXMgcGFyYW1ldGVyIHZhbHVlcyBmcm9tIHRoZSBnaXZlbiBidWZmZXIgdG8gdGhlIHRyYWluaW5nIHN0YXRlLiBDdXJyZW50bHksIG9ubHkgc3VwcG9ydGluZyBtb2RlbHMgd2l0aFxuICAgKiBwYXJhbWV0ZXJzIG9mIHR5cGUgRmxvYXQzMi5cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciAtIEEgVWludDhBcnJheSByZXByZXNlbnRhdGlvbiBvZiBGbG9hdDMyIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSB0cmFpbmFibGVPbmx5IC0gVHJ1ZSBpZiB0cmFpbmFibGUgcGFyYW1ldGVycyBvbmx5IHRvIGJlIG1vZGlmaWVkLCBmYWxzZSBvdGhlcndpc2UuIERlZmF1bHQgdmFsdWUgaXMgdHJ1ZS5cbiAgICovXG4gIGxvYWRQYXJhbWV0ZXJzQnVmZmVyKGJ1ZmZlcjogVWludDhBcnJheSwgdHJhaW5hYmxlT25seTogYm9vbGVhbik6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgbW9kZWwgcGFyYW1ldGVycyB0byBhIGNvbnRpZ3VvdXMgYnVmZmVyLiBVc3VhbGx5IHVzZWQgaW4gdGhlIGNvbnRleHQgb2YgRmVkZXJhdGVkIExlYXJuaW5nLlxuICAgKiBDdXJyZW50bHksIG9ubHkgc3VwcG9ydGluZyBtb2RlbHMgd2l0aCBwYXJhbWV0ZXJzIG9mIHR5cGUgRmxvYXQzMi5cbiAgICpcbiAgICogQHBhcmFtIHRyYWluYWJsZU9ubHkgLSBXaGVuIHNldCB0byB0cnVlLCBvbmx5IHRyYWluYWJsZSBwYXJhbWV0ZXJzIGFyZSBjb3BpZWQuIFRyYWluYWJsZSBwYXJhbWV0ZXJzIGFyZSBwYXJhbWV0ZXJzXG4gICAqIGZvciB3aGljaCByZXF1aXJlc19ncmFkIGlzIHNldCB0byB0cnVlLiBEZWZhdWx0IHZhbHVlIGlzIHRydWUuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgRmxvYXQzMiBPbm54VmFsdWUgb2YgdGhlIHJlcXVlc3RlZCBwYXJhbWV0ZXJzLlxuICAgKi9cbiAgZ2V0Q29udGlndW91c1BhcmFtZXRlcnModHJhaW5hYmxlT25seTogYm9vbGVhbik6IFByb21pc2U8T25ueFZhbHVlPjtcbiAgLy8gI2VuZHJlZ2lvblxuXG4gIC8vICNyZWdpb24gcmVsZWFzZSgpXG5cbiAgLyoqXG4gICAqIFJlbGVhc2UgdGhlIGluZmVyZW5jZSBzZXNzaW9uIGFuZCB0aGUgdW5kZXJseWluZyByZXNvdXJjZXMuXG4gICAqL1xuICByZWxlYXNlKCk6IFByb21pc2U8dm9pZD47XG4gIC8vICNlbmRyZWdpb25cblxuICAvLyAjcmVnaW9uIG1ldGFkYXRhXG5cbiAgLyoqXG4gICAqIEdldCBpbnB1dCBuYW1lcyBvZiB0aGUgbG9hZGVkIHRyYWluaW5nIG1vZGVsLlxuICAgKi9cbiAgcmVhZG9ubHkgdHJhaW5pbmdJbnB1dE5hbWVzOiByZWFkb25seSBzdHJpbmdbXTtcblxuICAvKipcbiAgICogR2V0IG91dHB1dCBuYW1lcyBvZiB0aGUgbG9hZGVkIHRyYWluaW5nIG1vZGVsLlxuICAgKi9cbiAgcmVhZG9ubHkgdHJhaW5pbmdPdXRwdXROYW1lczogcmVhZG9ubHkgc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIEdldCBpbnB1dCBuYW1lcyBvZiB0aGUgbG9hZGVkIGV2YWwgbW9kZWwuIElzIGFuIGVtcHR5IGFycmF5IGlmIG5vIGV2YWwgbW9kZWwgaXMgbG9hZGVkLlxuICAgKi9cbiAgcmVhZG9ubHkgZXZhbElucHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBHZXQgb3V0cHV0IG5hbWVzIG9mIHRoZSBsb2FkZWQgZXZhbCBtb2RlbC4gSXMgYW4gZW1wdHkgYXJyYXkgaWYgbm8gZXZhbCBtb2RlbCBpcyBsb2FkZWQuXG4gICAqL1xuICByZWFkb25seSBldmFsT3V0cHV0TmFtZXM6IHJlYWRvbmx5IHN0cmluZ1tdO1xuXG4gIC8vICNlbmRyZWdpb25cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBvcHRpb25hbCBwYXJhbWV0ZXJzIHRoYXQgY2FuIGJlIHBhc3NlZCBpbnRvIHRoZSBUcmFpbmluZ1Nlc3Npb25GYWN0b3J5LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYWluaW5nU2Vzc2lvbkNyZWF0ZU9wdGlvbnMge1xuICAvKipcbiAgICogVVJJIG9yIGJ1ZmZlciBmb3IgYSAuY2twdCBmaWxlIHRoYXQgY29udGFpbnMgdGhlIGNoZWNrcG9pbnQgZm9yIHRoZSB0cmFpbmluZyBtb2RlbC5cbiAgICovXG4gIGNoZWNrcG9pbnRTdGF0ZTogVHJhaW5pbmdTZXNzaW9uLlVyaU9yQnVmZmVyO1xuICAvKipcbiAgICogVVJJIG9yIGJ1ZmZlciBmb3IgdGhlIC5vbm54IHRyYWluaW5nIGZpbGUuXG4gICAqL1xuICB0cmFpbk1vZGVsOiBUcmFpbmluZ1Nlc3Npb24uVXJpT3JCdWZmZXI7XG4gIC8qKlxuICAgKiBPcHRpb25hbC4gVVJJIG9yIGJ1ZmZlciBmb3IgdGhlIC5vbm54IG9wdGltaXplciBtb2RlbCBmaWxlLlxuICAgKi9cbiAgb3B0aW1pemVyTW9kZWw/OiBUcmFpbmluZ1Nlc3Npb24uVXJpT3JCdWZmZXI7XG4gIC8qKlxuICAgKiBPcHRpb25hbC4gVVJJIG9yIGJ1ZmZlciBmb3IgdGhlIC5vbm54IGV2YWwgbW9kZWwgZmlsZS5cbiAgICovXG4gIGV2YWxNb2RlbD86IFRyYWluaW5nU2Vzc2lvbi5VcmlPckJ1ZmZlcjtcbn1cblxuLyoqXG4gKiBEZWZpbmVzIG1ldGhvZCBvdmVybG9hZCBwb3NzaWJpbGl0aWVzIGZvciBjcmVhdGluZyBhIFRyYWluaW5nU2Vzc2lvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFpbmluZ1Nlc3Npb25GYWN0b3J5IHtcbiAgLy8gI3JlZ2lvbiBjcmVhdGUoKVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFRyYWluaW5nU2Vzc2lvbiBhbmQgYXN5bmNocm9ub3VzbHkgbG9hZHMgYW55IG1vZGVscyBwYXNzZWQgaW4gdGhyb3VnaCB0cmFpbmluZ09wdGlvbnNcbiAgICpcbiAgICogQHBhcmFtIHRyYWluaW5nT3B0aW9ucyBzcGVjaWZ5IG1vZGVscyBhbmQgY2hlY2twb2ludHMgdG8gbG9hZCBpbnRvIHRoZSBUcmFpbmluZyBTZXNzaW9uXG4gICAqIEBwYXJhbSBzZXNzaW9uT3B0aW9ucyBzcGVjaWZ5IGNvbmZpZ3VyYXRpb24gZm9yIHRyYWluaW5nIHNlc3Npb24gYmVoYXZpb3JcbiAgICpcbiAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgVHJhaW5pbmdTZXNzaW9uIG9iamVjdFxuICAgKi9cbiAgY3JlYXRlKFxuICAgIHRyYWluaW5nT3B0aW9uczogVHJhaW5pbmdTZXNzaW9uQ3JlYXRlT3B0aW9ucyxcbiAgICBzZXNzaW9uT3B0aW9ucz86IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMsXG4gICk6IFByb21pc2U8VHJhaW5pbmdTZXNzaW9uPjtcblxuICAvLyAjZW5kcmVnaW9uXG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmV4cG9ydCBjb25zdCBUcmFpbmluZ1Nlc3Npb246IFRyYWluaW5nU2Vzc2lvbkZhY3RvcnkgPSBUcmFpbmluZ1Nlc3Npb25JbXBsO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vKipcbiAqICMgT05OWCBSdW50aW1lIEphdmFTY3JpcHQgQVBJXG4gKlxuICogT05OWCBSdW50aW1lIEphdmFTY3JpcHQgQVBJIGlzIGEgdW5pZmllZCBBUEkgZm9yIGFsbCBKYXZhU2NyaXB0IHVzYWdlcywgaW5jbHVkaW5nIHRoZSBmb2xsb3dpbmcgTlBNIHBhY2thZ2VzOlxuICpcbiAqIC0gW29ubnhydW50aW1lLW5vZGVdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL29ubnhydW50aW1lLW5vZGUpXG4gKiAtIFtvbm54cnVudGltZS13ZWJdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL29ubnhydW50aW1lLXdlYilcbiAqIC0gW29ubnhydW50aW1lLXJlYWN0LW5hdGl2ZV0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvb25ueHJ1bnRpbWUtcmVhY3QtbmF0aXZlKVxuICpcbiAqIFNlZSBhbHNvOlxuICogLSBbR2V0IFN0YXJ0ZWRdKGh0dHBzOi8vb25ueHJ1bnRpbWUuYWkvZG9jcy9nZXQtc3RhcnRlZC93aXRoLWphdmFzY3JpcHQvKVxuICogLSBbSW5mZXJlbmNlIGV4YW1wbGVzXShodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L29ubnhydW50aW1lLWluZmVyZW5jZS1leGFtcGxlcy90cmVlL21haW4vanMpXG4gKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cblxuZXhwb3J0ICogZnJvbSAnLi9iYWNrZW5kLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vZW52LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vaW5mZXJlbmNlLXNlc3Npb24uanMnO1xuZXhwb3J0ICogZnJvbSAnLi90ZW5zb3IuanMnO1xuZXhwb3J0ICogZnJvbSAnLi90ZW5zb3ItY29udmVyc2lvbi5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3RlbnNvci1mYWN0b3J5LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdHJhY2UuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9vbm54LW1vZGVsLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vb25ueC12YWx1ZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3RyYWluaW5nLXNlc3Npb24uanMnO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5leHBvcnQgY29uc3QgaXNOb2RlID0gISEodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlKTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLy8vIDxyZWZlcmVuY2UgbGliPVwid2Vid29ya2VyXCIgLz5cblxuLy9cbi8vICogdHlwZSBoYWNrIGZvciBcIkhUTUxJbWFnZUVsZW1lbnRcIlxuLy9cbi8vIGluIHR5cGVzY3JpcHQsIHRoZSB0eXBlIG9mIFwiSFRNTEltYWdlRWxlbWVudFwiIGlzIGRlZmluZWQgaW4gbGliLmRvbS5kLnRzLCB3aGljaCBpcyBjb25mbGljdCB3aXRoIGxpYi53ZWJ3b3JrZXIuZC50cy5cbi8vIHdoZW4gd2UgdXNlIHdlYndvcmtlciwgdGhlIGxpYi53ZWJ3b3JrZXIuZC50cyB3aWxsIGJlIHVzZWQsIHdoaWNoIGRvZXMgbm90IGhhdmUgSFRNTEltYWdlRWxlbWVudCBkZWZpbmVkLlxuLy9cbi8vIHdlIHdpbGwgZ2V0IHRoZSBmb2xsb3dpbmcgZXJyb3JzIGNvbXBsYWluaW5nIHRoYXQgSFRNTEltYWdlRWxlbWVudCBpcyBub3QgZGVmaW5lZDpcbi8vXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy9cbi8vIC4uL2NvbW1vbi9kaXN0L2Nqcy90ZW5zb3ItZmFjdG9yeS5kLnRzOjE4NzoyOSAtIGVycm9yIFRTMjU1MjogQ2Fubm90IGZpbmQgbmFtZSAnSFRNTEltYWdlRWxlbWVudCcuIERpZCB5b3UgbWVhblxuLy8gJ0hUTUxMSUVsZW1lbnQnP1xuLy9cbi8vIDE4NyAgICAgZnJvbUltYWdlKGltYWdlRWxlbWVudDogSFRNTEltYWdlRWxlbWVudCwgb3B0aW9ucz86IFRlbnNvckZyb21JbWFnZUVsZW1lbnRPcHRpb25zKTpcbi8vIFByb21pc2U8VHlwZWRUZW5zb3I8J2Zsb2F0MzInPiB8IFR5cGVkVGVuc29yPCd1aW50OCc+Pjtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfn5+fn5+fn5+fn5+fn5+flxuLy9cbi8vIG5vZGVfbW9kdWxlcy9Ad2ViZ3B1L3R5cGVzL2Rpc3QvaW5kZXguZC50czo4Mzo3IC0gZXJyb3IgVFMyNTUyOiBDYW5ub3QgZmluZCBuYW1lICdIVE1MSW1hZ2VFbGVtZW50Jy4gRGlkIHlvdSBtZWFuXG4vLyAnSFRNTExJRWxlbWVudCc/XG4vL1xuLy8gODMgICAgIHwgSFRNTEltYWdlRWxlbWVudFxuLy8gICAgICAgICAgfn5+fn5+fn5+fn5+fn5+flxuLy9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vL1xuLy8gYEhUTUxJbWFnZUVsZW1lbnRgIGlzIG9ubHkgdXNlZCBpbiB0eXBlIGRlY2xhcmF0aW9uIGFuZCBub3QgaW4gcmVhbCBjb2RlLiBTbyB3ZSBkZWZpbmUgaXQgYXMgYHVua25vd25gIGhlcmUgdG9cbi8vIGJ5cGFzcyB0aGUgdHlwZSBjaGVjay5cblxuLy9cbi8vICogdHlwZSBoYWNrIGZvciBcImRvY3VtZW50XCJcbi8vXG4vLyBpbiB0eXBlc2NyaXB0LCB0aGUgdHlwZSBvZiBcImRvY3VtZW50XCIgaXMgZGVmaW5lZCBpbiBsaWIuZG9tLmQudHMsIHNvIGl0J3Mgbm90IGF2YWlsYWJsZSBpbiB3ZWJ3b3JrZXIuXG4vL1xuLy8gd2Ugd2lsbCBnZXQgdGhlIGZvbGxvd2luZyBlcnJvcnMgY29tcGxhaW5pbmcgdGhhdCBkb2N1bWVudCBpcyBub3QgZGVmaW5lZDpcbi8vXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy9cbi8vIGxpYi93YXNtL3dhc20tdXRpbHMtaW1wb3J0LnRzOjc6MzMgLSBlcnJvciBUUzI1ODQ6IENhbm5vdCBmaW5kIG5hbWUgJ2RvY3VtZW50Jy4gRG8geW91IG5lZWQgdG8gY2hhbmdlIHlvdXIgdGFyZ2V0XG4vLyBsaWJyYXJ5PyBUcnkgY2hhbmdpbmcgdGhlICdsaWInIGNvbXBpbGVyIG9wdGlvbiB0byBpbmNsdWRlICdkb20nLlxuLy9cbi8vIDcgZXhwb3J0IGNvbnN0IHNjcmlwdFNyYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyAoZG9jdW1lbnQ/LmN1cnJlbnRTY3JpcHQgYXMgSFRNTFNjcmlwdEVsZW1lbnQpPy5zcmMgOlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH5+fn5+fn5+XG4vL1xuLy8gbGliL3dhc20vd2FzbS11dGlscy1pbXBvcnQudHM6Nzo2MSAtIGVycm9yIFRTMjU4NDogQ2Fubm90IGZpbmQgbmFtZSAnZG9jdW1lbnQnLiBEbyB5b3UgbmVlZCB0byBjaGFuZ2UgeW91ciB0YXJnZXRcbi8vIGxpYnJhcnk/IFRyeSBjaGFuZ2luZyB0aGUgJ2xpYicgY29tcGlsZXIgb3B0aW9uIHRvIGluY2x1ZGUgJ2RvbScuXG4vL1xuLy8gNyBleHBvcnQgY29uc3Qgc2NyaXB0U3JjID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IChkb2N1bWVudD8uY3VycmVudFNjcmlwdCBhcyBIVE1MU2NyaXB0RWxlbWVudCk/LnNyYyA6XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH5+fn5+fn5+XG4vL1xuLy8gbGliL3dhc20vd2FzbS11dGlscy1pbXBvcnQudHM6Nzo4OCAtIGVycm9yIFRTMjU1MjogQ2Fubm90IGZpbmQgbmFtZSAnSFRNTFNjcmlwdEVsZW1lbnQnLiBEaWQgeW91IG1lYW5cbi8vICdIVE1MTElFbGVtZW50Jz9cbi8vXG4vLyA3IGV4cG9ydCBjb25zdCBzY3JpcHRTcmMgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gKGRvY3VtZW50Py5jdXJyZW50U2NyaXB0IGFzIEhUTUxTY3JpcHRFbGVtZW50KT8uc3JjIDpcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfn5+fn5+fn5+fn5+fn5+fn5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vL1xuLy8gYGRvY3VtZW50YCBpcyB1c2VkIHRvIGdldCB0aGUgY3VycmVudCBzY3JpcHQgVVJMLCB3aGljaCBpcyBub3QgYXZhaWxhYmxlIGluIHdlYndvcmtlci4gVGhpcyBmaWxlIGlzIHNlcnZlZCBhcyBhXG4vLyBcImR1YWxcIiBmaWxlIGZvciBlbnRyaWVzIG9mIGJvdGggd2Vid29ya2VyIGFuZCB0aGUgZXNtIG1vZHVsZS5cbi8vXG5kZWNsYXJlIGdsb2JhbCB7XG4gIHR5cGUgSFRNTEltYWdlRWxlbWVudCA9IHVua25vd247XG4gIHR5cGUgSFRNTFNjcmlwdEVsZW1lbnQgPSB7IHNyYz86IHN0cmluZyB9O1xuICBjb25zdCBkb2N1bWVudDogdW5kZWZpbmVkIHwgeyBjdXJyZW50U2NyaXB0PzogSFRNTFNjcmlwdEVsZW1lbnQgfTtcbn1cblxuLyoqXG4gKiBAc3VtbWFyeVxuICpcbiAqIFRoaXMgZmlsZSBpcyBzZXJ2ZWQgYXMgYSBcImR1YWxcIiBmaWxlIGZvciBib3RoIGVudHJpZXMgb2YgdGhlIGZvbGxvd2luZzpcbiAqIC0gVGhlIHByb3h5IHdvcmtlciBpdHNlbGYuXG4gKiAgIC0gV2hlbiB1c2VkIGFzIGEgd29ya2VyLCBpdCBsaXN0ZW5zIHRvIHRoZSBtZXNzYWdlcyBmcm9tIHRoZSBtYWluIHRocmVhZCBhbmQgcGVyZm9ybXMgdGhlIGNvcnJlc3BvbmRpbmcgb3BlcmF0aW9ucy5cbiAqICAgLSBTaG91bGQgYmUgaW1wb3J0ZWQgZGlyZWN0bHkgdXNpbmcgYG5ldyBXb3JrZXIoKWAgaW4gdGhlIG1haW4gdGhyZWFkLlxuICpcbiAqIC0gVGhlIEVTTSBtb2R1bGUgdGhhdCBjcmVhdGVzIHRoZSBwcm94eSB3b3JrZXIgKGFzIGEgd29ya2VyIGxhdW5jaGVyKS5cbiAqICAgLSBXaGVuIHVzZWQgYXMgYSB3b3JrZXIgbGF1bmNoZXIsIGl0IGNyZWF0ZXMgdGhlIHByb3h5IHdvcmtlciBhbmQgcmV0dXJucyBpdC5cbiAqICAgLSBTaG91bGQgYmUgaW1wb3J0ZWQgdXNpbmcgYGltcG9ydCgpYCBpbiB0aGUgbWFpbiB0aHJlYWQsIHdpdGggdGhlIHF1ZXJ5IHBhcmFtZXRlciBgaW1wb3J0PTFgLlxuICpcbiAqIFRoaXMgZmlsZSB3aWxsIGJlIGFsd2F5cyBjb21waWxpbmcgaW50byBFU00gZm9ybWF0LlxuICovXG5cbmltcG9ydCB0eXBlIHsgT3J0V2FzbU1lc3NhZ2UsIFNlcmlhbGl6YWJsZVRlbnNvck1ldGFkYXRhIH0gZnJvbSAnLi4vcHJveHktbWVzc2FnZXMuanMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlU2Vzc2lvbixcbiAgY29weUZyb21FeHRlcm5hbEJ1ZmZlcixcbiAgZW5kUHJvZmlsaW5nLFxuICBleHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycyxcbiAgaW5pdEVwLFxuICBpbml0UnVudGltZSxcbiAgcmVsZWFzZVNlc3Npb24sXG4gIHJ1bixcbn0gZnJvbSAnLi4vd2FzbS1jb3JlLWltcGwuanMnO1xuaW1wb3J0IHsgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5IH0gZnJvbSAnLi4vd2FzbS1mYWN0b3J5LmpzJztcbmltcG9ydCB7IHNjcmlwdFNyYyB9IGZyb20gJy4uL3dhc20tdXRpbHMtaW1wb3J0LmpzJztcblxuY29uc3QgV09SS0VSX05BTUUgPSAnb3J0LXdhc20tcHJveHktd29ya2VyJztcbmNvbnN0IGlzUHJveHlXb3JrZXIgPSBnbG9iYWxUaGlzLnNlbGY/Lm5hbWUgPT09IFdPUktFUl9OQU1FO1xuXG5pZiAoaXNQcm94eVdvcmtlcikge1xuICAvLyBXb3JrZXIgdGhyZWFkXG4gIHNlbGYub25tZXNzYWdlID0gKGV2OiBNZXNzYWdlRXZlbnQ8T3J0V2FzbU1lc3NhZ2U+KTogdm9pZCA9PiB7XG4gICAgY29uc3QgeyB0eXBlLCBpbjogbWVzc2FnZSB9ID0gZXYuZGF0YTtcbiAgICB0cnkge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2luaXQtd2FzbSc6XG4gICAgICAgICAgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KG1lc3NhZ2UhLndhc20pLnRoZW4oXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgIGluaXRSdW50aW1lKG1lc3NhZ2UhKS50aGVuKFxuICAgICAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSwgZXJyIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUsIGVyciB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaW5pdC1lcCc6IHtcbiAgICAgICAgICBjb25zdCB7IGVwTmFtZSwgZW52IH0gPSBtZXNzYWdlITtcbiAgICAgICAgICBpbml0RXAoZW52LCBlcE5hbWUpLnRoZW4oXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSwgZXJyIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2NvcHktZnJvbSc6IHtcbiAgICAgICAgICBjb25zdCB7IGJ1ZmZlciB9ID0gbWVzc2FnZSE7XG4gICAgICAgICAgY29uc3QgYnVmZmVyRGF0YSA9IGNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIoYnVmZmVyKTtcbiAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUsIG91dDogYnVmZmVyRGF0YSB9IGFzIE9ydFdhc21NZXNzYWdlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdjcmVhdGUnOiB7XG4gICAgICAgICAgY29uc3QgeyBtb2RlbCwgb3B0aW9ucyB9ID0gbWVzc2FnZSE7XG4gICAgICAgICAgY3JlYXRlU2Vzc2lvbihtb2RlbCwgb3B0aW9ucykudGhlbihcbiAgICAgICAgICAgIChzZXNzaW9uTWV0YWRhdGEpID0+IHtcbiAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UoeyB0eXBlLCBvdXQ6IHNlc3Npb25NZXRhZGF0YSB9IGFzIE9ydFdhc21NZXNzYWdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSwgZXJyIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3JlbGVhc2UnOlxuICAgICAgICAgIHJlbGVhc2VTZXNzaW9uKG1lc3NhZ2UhKTtcbiAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3J1bic6IHtcbiAgICAgICAgICBjb25zdCB7IHNlc3Npb25JZCwgaW5wdXRJbmRpY2VzLCBpbnB1dHMsIG91dHB1dEluZGljZXMsIG9wdGlvbnMgfSA9IG1lc3NhZ2UhO1xuICAgICAgICAgIHJ1bihzZXNzaW9uSWQsIGlucHV0SW5kaWNlcywgaW5wdXRzLCBvdXRwdXRJbmRpY2VzLCBuZXcgQXJyYXkob3V0cHV0SW5kaWNlcy5sZW5ndGgpLmZpbGwobnVsbCksIG9wdGlvbnMpLnRoZW4oXG4gICAgICAgICAgICAob3V0cHV0cykgPT4ge1xuICAgICAgICAgICAgICBpZiAob3V0cHV0cy5zb21lKChvKSA9PiBvWzNdICE9PSAnY3B1JykpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUsIGVycjogJ1Byb3h5IGRvZXMgbm90IHN1cHBvcnQgbm9uLWNwdSB0ZW5zb3IgbG9jYXRpb24uJyB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZShcbiAgICAgICAgICAgICAgICAgIHsgdHlwZSwgb3V0OiBvdXRwdXRzIH0gYXMgT3J0V2FzbU1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICBleHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycyhbLi4uaW5wdXRzLCAuLi5vdXRwdXRzXSBhcyBTZXJpYWxpemFibGVUZW5zb3JNZXRhZGF0YVtdKSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGUsIGVyciB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdlbmQtcHJvZmlsaW5nJzpcbiAgICAgICAgICBlbmRQcm9maWxpbmcobWVzc2FnZSEpO1xuICAgICAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHBvc3RNZXNzYWdlKHsgdHlwZSwgZXJyIH0gYXMgT3J0V2FzbU1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQcm94eVdvcmtlclxuICA/IG51bGxcbiAgOiAodXJsT3ZlcnJpZGU/OiBzdHJpbmcpID0+XG4gICAgICBuZXcgV29ya2VyKHVybE92ZXJyaWRlID8/IHNjcmlwdFNyYyEsIHsgdHlwZTogQlVJTERfREVGUy5JU19FU00gPyAnbW9kdWxlJyA6ICdjbGFzc2ljJywgbmFtZTogV09SS0VSX05BTUUgfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB0eXBlIHsgT3J0V2FzbU1vZHVsZSB9IGZyb20gJy4vd2FzbS10eXBlcyc7XG5pbXBvcnQgeyBpc05vZGUgfSBmcm9tICcuL3dhc20tdXRpbHMtZW52JztcblxuLyoqXG4gKiBUaGUgY2xhc3NpYyBzY3JpcHQgc291cmNlIFVSTC4gVGhpcyBpcyBub3QgYWx3YXlzIGF2YWlsYWJsZSBpbiBub24gRVNNb2R1bGUgZW52aXJvbm1lbnRzLlxuICpcbiAqIEluIE5vZGUuanMsIHRoaXMgaXMgdW5kZWZpbmVkLlxuICovXG5leHBvcnQgY29uc3Qgc2NyaXB0U3JjID1cbiAgLy8gaWYgTm9kZWpzLCByZXR1cm4gdW5kZWZpbmVkXG4gIGlzTm9kZVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiAvLyBpZiBJdCdzIEVTTSwgdXNlIGltcG9ydC5tZXRhLnVybFxuICAgICAgKEJVSUxEX0RFRlMuRVNNX0lNUE9SVF9NRVRBX1VSTCA/P1xuICAgICAgLy8gdXNlIGBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyY2AgaWYgYXZhaWxhYmxlXG4gICAgICAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IChkb2N1bWVudC5jdXJyZW50U2NyaXB0IGFzIEhUTUxTY3JpcHRFbGVtZW50KT8uc3JjXG4gICAgICAgIDogLy8gdXNlIGBzZWxmLmxvY2F0aW9uLmhyZWZgIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgID8gc2VsZi5sb2NhdGlvbj8uaHJlZlxuICAgICAgICAgIDogdW5kZWZpbmVkKSk7XG5cbi8qKlxuICogVGhlIG9yaWdpbiBvZiB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqXG4gKiBJbiBOb2RlLmpzLCB0aGlzIGlzIHVuZGVmaW5lZC5cbiAqL1xuY29uc3Qgb3JpZ2luID0gaXNOb2RlIHx8IHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBsb2NhdGlvbi5vcmlnaW47XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGZpbGVuYW1lIHdpdGggcHJlZml4IGlzIGZyb20gdGhlIHNhbWUgb3JpZ2luLlxuICovXG5jb25zdCBpc1NhbWVPcmlnaW4gPSAoZmlsZW5hbWU6IHN0cmluZywgcHJlZml4T3ZlcnJpZGU/OiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBiYXNlVXJsID0gcHJlZml4T3ZlcnJpZGUgPz8gc2NyaXB0U3JjO1xuICAgIGNvbnN0IHVybCA9IGJhc2VVcmwgPyBuZXcgVVJMKGZpbGVuYW1lLCBiYXNlVXJsKSA6IG5ldyBVUkwoZmlsZW5hbWUpO1xuICAgIHJldHVybiB1cmwub3JpZ2luID09PSBvcmlnaW47XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGlucHV0cyB0byBhbiBhYnNvbHV0ZSBVUkwgd2l0aCB0aGUgZ2l2ZW4gcHJlZml4IG92ZXJyaWRlLiBJZiBmYWlsZWQsIHJldHVybiB1bmRlZmluZWQuXG4gKi9cbmNvbnN0IG5vcm1hbGl6ZVVybCA9IChmaWxlbmFtZTogc3RyaW5nLCBwcmVmaXhPdmVycmlkZT86IHN0cmluZykgPT4ge1xuICBjb25zdCBiYXNlVXJsID0gcHJlZml4T3ZlcnJpZGUgPz8gc2NyaXB0U3JjO1xuICB0cnkge1xuICAgIGNvbnN0IHVybCA9IGJhc2VVcmwgPyBuZXcgVVJMKGZpbGVuYW1lLCBiYXNlVXJsKSA6IG5ldyBVUkwoZmlsZW5hbWUpO1xuICAgIHJldHVybiB1cmwuaHJlZjtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBmYWxsYmFjayBVUkwgaWYgYW4gYWJzb2x1dGUgVVJMIGNhbm5vdCBiZSBjcmVhdGVkIGJ5IHRoZSBub3JtYWxpemVVcmwgZnVuY3Rpb24uXG4gKi9cbmNvbnN0IGZhbGxiYWNrVXJsID0gKGZpbGVuYW1lOiBzdHJpbmcsIHByZWZpeE92ZXJyaWRlPzogc3RyaW5nKSA9PiBgJHtwcmVmaXhPdmVycmlkZSA/PyAnLi8nfSR7ZmlsZW5hbWV9YDtcblxuLyoqXG4gKiBUaGlzIGhlbHBlciBmdW5jdGlvbiBpcyB1c2VkIHRvIHByZWxvYWQgYSBtb2R1bGUgZnJvbSBhIFVSTC5cbiAqXG4gKiBJZiB0aGUgb3JpZ2luIG9mIHRoZSB3b3JrZXIgVVJMIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IG9yaWdpbiwgdGhlIHdvcmtlciBjYW5ub3QgYmUgbG9hZGVkIGRpcmVjdGx5LlxuICogU2VlIGRpc2N1c3Npb25zIGluIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvd29ya2VyLWxvYWRlci9pc3N1ZXMvMTU0XG4gKlxuICogSW4gdGhpcyBjYXNlLCB3ZSB3aWxsIGZldGNoIHRoZSB3b3JrZXIgVVJMIGFuZCBjcmVhdGUgYSBuZXcgQmxvYiBVUkwgd2l0aCB0aGUgc2FtZSBvcmlnaW4gYXMgYSB3b3JrYXJvdW5kLlxuICpcbiAqIEBwYXJhbSBhYnNvbHV0ZVVybCAtIFRoZSBhYnNvbHV0ZSBVUkwgdG8gcHJlbG9hZC5cbiAqXG4gKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbmV3IEJsb2IgVVJMXG4gKi9cbmNvbnN0IHByZWxvYWQgPSBhc3luYyAoYWJzb2x1dGVVcmw6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYWJzb2x1dGVVcmwsIHsgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicgfSk7XG4gIGNvbnN0IGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xufTtcblxuLyoqXG4gKiBUaGlzIGhlbHBlciBmdW5jdGlvbiBpcyB1c2VkIHRvIGR5bmFtaWNhbGx5IGltcG9ydCBhIG1vZHVsZSBmcm9tIGEgVVJMLlxuICpcbiAqIFRoZSBidWlsZCBzY3JpcHQgaGFzIHNwZWNpYWwgaGFuZGxpbmcgZm9yIHRoaXMgZnVuY3Rpb24gdG8gZW5zdXJlIHRoYXQgdGhlIFVSTCBpcyBub3QgYnVuZGxlZCBpbnRvIHRoZSBmaW5hbCBvdXRwdXQuXG4gKlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gaW1wb3J0LlxuICpcbiAqIEByZXR1cm5zIC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRlZmF1bHQgZXhwb3J0IG9mIHRoZSBtb2R1bGUuXG4gKi9cbmNvbnN0IGR5bmFtaWNJbXBvcnREZWZhdWx0ID0gYXN5bmMgPFQ+KHVybDogc3RyaW5nKTogUHJvbWlzZTxUPiA9PlxuICAoYXdhaXQgaW1wb3J0KC8qIHdlYnBhY2tJZ25vcmU6IHRydWUgKi8gdXJsKSkuZGVmYXVsdDtcblxuLyoqXG4gKiBUaGUgcHJveHkgd29ya2VyIGZhY3RvcnkgaW1wb3J0ZWQgZnJvbSB0aGUgcHJveHkgd29ya2VyIG1vZHVsZS5cbiAqXG4gKiBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIHdoZW4gdGhlIFdlYkFzc2VtYmx5IHByb3h5IGlzIG5vdCBkaXNhYmxlZC5cbiAqL1xuY29uc3QgY3JlYXRlUHJveHlXb3JrZXI6ICgodXJsT3ZlcnJpZGU/OiBzdHJpbmcpID0+IFdvcmtlcikgfCB1bmRlZmluZWQgPVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cywgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuICBCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTV9QUk9YWSA/IHVuZGVmaW5lZCA6IHJlcXVpcmUoJy4vcHJveHktd29ya2VyL21haW4nKS5kZWZhdWx0O1xuXG4vKipcbiAqIEltcG9ydCB0aGUgcHJveHkgd29ya2VyLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBwZXJmb3JtIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG4gKiAxLiBJZiBhIHByZWxvYWQgaXMgbmVlZGVkLCBpdCB3aWxsIHByZWxvYWQgdGhlIG1vZHVsZSBhbmQgcmV0dXJuIHRoZSBvYmplY3QgVVJMLlxuICogMi4gVXNlIHRoZSBwcm94eSB3b3JrZXIgZmFjdG9yeSB0byBjcmVhdGUgdGhlIHByb3h5IHdvcmtlci5cbiAqXG4gKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdHVwbGUgb2YgMiBlbGVtZW50czpcbiAqICAgICAgICAgICAgLSBUaGUgb2JqZWN0IFVSTCBvZiB0aGUgcHJlbG9hZGVkIG1vZHVsZSwgb3IgdW5kZWZpbmVkIGlmIG5vIHByZWxvYWQgaXMgbmVlZGVkLlxuICogICAgICAgICAgICAtIFRoZSBwcm94eSB3b3JrZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBpbXBvcnRQcm94eVdvcmtlciA9IGFzeW5jICgpOiBQcm9taXNlPFt1bmRlZmluZWQgfCBzdHJpbmcsIFdvcmtlcl0+ID0+IHtcbiAgaWYgKCFzY3JpcHRTcmMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIHByb3h5IHdvcmtlcjogY2Fubm90IGRldGVybWluZSB0aGUgc2NyaXB0IHNvdXJjZSBVUkwuJyk7XG4gIH1cblxuICAvLyBJZiB0aGUgc2NyaXB0IHNvdXJjZSBpcyBmcm9tIHRoZSBzYW1lIG9yaWdpbiwgd2UgY2FuIHVzZSB0aGUgZW1iZWRkZWQgcHJveHkgbW9kdWxlIGRpcmVjdGx5LlxuICBpZiAoaXNTYW1lT3JpZ2luKHNjcmlwdFNyYykpIHtcbiAgICByZXR1cm4gW3VuZGVmaW5lZCwgY3JlYXRlUHJveHlXb3JrZXIhKCldO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCBuZWVkIHRvIHByZWxvYWRcbiAgY29uc3QgdXJsID0gYXdhaXQgcHJlbG9hZChzY3JpcHRTcmMpO1xuICByZXR1cm4gW3VybCwgY3JlYXRlUHJveHlXb3JrZXIhKHVybCldO1xufTtcblxuLyoqXG4gKiBUaGUgZW1iZWRkZWQgV2ViQXNzZW1ibHkgbW9kdWxlLlxuICpcbiAqIFRoaXMgaXMgb25seSBhdmFpbGFibGUgaW4gRVNNIGFuZCB3aGVuIGVtYmVkZGluZyBpcyBub3QgZGlzYWJsZWQuXG4gKi9cbmNvbnN0IGVtYmVkZGVkV2FzbU1vZHVsZTogRW1zY3JpcHRlbk1vZHVsZUZhY3Rvcnk8T3J0V2FzbU1vZHVsZT4gfCB1bmRlZmluZWQgPVxuICBCVUlMRF9ERUZTLklTX0VTTSAmJiBCVUlMRF9ERUZTLkRJU0FCTEVfRFlOQU1JQ19JTVBPUlRcbiAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG4gICAgICByZXF1aXJlKFxuICAgICAgICAhQlVJTERfREVGUy5ESVNBQkxFX0pTRVBcbiAgICAgICAgICA/ICcuLi8uLi9kaXN0L29ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC5tanMnXG4gICAgICAgICAgOiAnLi4vLi4vZGlzdC9vcnQtd2FzbS1zaW1kLXRocmVhZGVkLm1qcycsXG4gICAgICApLmRlZmF1bHRcbiAgICA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBJbXBvcnQgdGhlIFdlYkFzc2VtYmx5IG1vZHVsZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgcGVyZm9ybSB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuICogMS4gSWYgQlVJTERfREVGUy5ESVNBQkxFX0RZTkFNSUNfSU1QT1JUIGlzIHRydWUsIHVzZSB0aGUgZW1iZWRkZWQgbW9kdWxlLlxuICogMi4gSWYgYSBwcmVsb2FkIGlzIG5lZWRlZCwgaXQgd2lsbCBwcmVsb2FkIHRoZSBtb2R1bGUgYW5kIHJldHVybiB0aGUgb2JqZWN0IFVSTC5cbiAqIDMuIE90aGVyd2lzZSwgaXQgd2lsbCBwZXJmb3JtIGEgZHluYW1pYyBpbXBvcnQgb2YgdGhlIG1vZHVsZS5cbiAqXG4gKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgdHVwbGUgb2YgMiBlbGVtZW50czpcbiAqICAgICAgICAgICAgLSBUaGUgb2JqZWN0IFVSTCBvZiB0aGUgcHJlbG9hZGVkIG1vZHVsZSwgb3IgdW5kZWZpbmVkIGlmIG5vIHByZWxvYWQgaXMgbmVlZGVkLlxuICogICAgICAgICAgICAtIFRoZSBkZWZhdWx0IGV4cG9ydCBvZiB0aGUgbW9kdWxlLCB3aGljaCBpcyBhIGZhY3RvcnkgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBXZWJBc3NlbWJseSBtb2R1bGUuXG4gKi9cbmV4cG9ydCBjb25zdCBpbXBvcnRXYXNtTW9kdWxlID0gYXN5bmMgKFxuICB1cmxPdmVycmlkZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICBwcmVmaXhPdmVycmlkZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICBpc011bHRpVGhyZWFkZWQ6IGJvb2xlYW4sXG4pOiBQcm9taXNlPFt1bmRlZmluZWQgfCBzdHJpbmcsIEVtc2NyaXB0ZW5Nb2R1bGVGYWN0b3J5PE9ydFdhc21Nb2R1bGU+XT4gPT4ge1xuICBpZiAoQlVJTERfREVGUy5ESVNBQkxFX0RZTkFNSUNfSU1QT1JUKSB7XG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIGVtYmVkZGVkV2FzbU1vZHVsZSFdO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHdhc21Nb2R1bGVGaWxlbmFtZSA9ICFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUFxuICAgICAgPyAnb3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLm1qcydcbiAgICAgIDogJ29ydC13YXNtLXNpbWQtdGhyZWFkZWQubWpzJztcbiAgICBjb25zdCB3YXNtTW9kdWxlVXJsID0gdXJsT3ZlcnJpZGUgPz8gbm9ybWFsaXplVXJsKHdhc21Nb2R1bGVGaWxlbmFtZSwgcHJlZml4T3ZlcnJpZGUpO1xuICAgIC8vIG5lZWQgdG8gcHJlbG9hZCBpZiBhbGwgb2YgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gICAgLy8gMS4gbm90IGluIE5vZGUuanMuXG4gICAgLy8gICAgLSBOb2RlLmpzIGRvZXMgbm90IGhhdmUgdGhlIHNhbWUgb3JpZ2luIHBvbGljeSBmb3IgY3JlYXRpbmcgd29ya2Vycy5cbiAgICAvLyAyLiBtdWx0aS10aHJlYWRlZCBpcyBlbmFibGVkLlxuICAgIC8vICAgIC0gSWYgbXVsdGktdGhyZWFkZWQgaXMgZGlzYWJsZWQsIG5vIHdvcmtlciB3aWxsIGJlIGNyZWF0ZWQuIFNvIHdlIGRvbid0IG5lZWQgdG8gcHJlbG9hZCB0aGUgbW9kdWxlLlxuICAgIC8vIDMuIHRoZSBhYnNvbHV0ZSBVUkwgaXMgYXZhaWxhYmxlLlxuICAgIC8vICAgIC0gSWYgdGhlIGFic29sdXRlIFVSTCBpcyBmYWlsZWQgdG8gYmUgY3JlYXRlZCwgdGhlIG9yaWdpbiBjYW5ub3QgYmUgZGV0ZXJtaW5lZC4gSW4gdGhpcyBjYXNlLCB3ZSB3aWxsIG5vdFxuICAgIC8vICAgIHByZWxvYWQgdGhlIG1vZHVsZS5cbiAgICAvLyA0LiB0aGUgd29ya2VyIFVSTCBpcyBub3QgZnJvbSB0aGUgc2FtZSBvcmlnaW4uXG4gICAgLy8gICAgLSBJZiB0aGUgd29ya2VyIFVSTCBpcyBmcm9tIHRoZSBzYW1lIG9yaWdpbiwgd2UgY2FuIGNyZWF0ZSB0aGUgd29ya2VyIGRpcmVjdGx5LlxuICAgIGNvbnN0IG5lZWRQcmVsb2FkID0gIWlzTm9kZSAmJiBpc011bHRpVGhyZWFkZWQgJiYgd2FzbU1vZHVsZVVybCAmJiAhaXNTYW1lT3JpZ2luKHdhc21Nb2R1bGVVcmwsIHByZWZpeE92ZXJyaWRlKTtcbiAgICBjb25zdCB1cmwgPSBuZWVkUHJlbG9hZFxuICAgICAgPyBhd2FpdCBwcmVsb2FkKHdhc21Nb2R1bGVVcmwpXG4gICAgICA6ICh3YXNtTW9kdWxlVXJsID8/IGZhbGxiYWNrVXJsKHdhc21Nb2R1bGVGaWxlbmFtZSwgcHJlZml4T3ZlcnJpZGUpKTtcbiAgICByZXR1cm4gW25lZWRQcmVsb2FkID8gdXJsIDogdW5kZWZpbmVkLCBhd2FpdCBkeW5hbWljSW1wb3J0RGVmYXVsdDxFbXNjcmlwdGVuTW9kdWxlRmFjdG9yeTxPcnRXYXNtTW9kdWxlPj4odXJsKV07XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEVudiB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB0eXBlIHsgT3J0V2FzbU1vZHVsZSB9IGZyb20gJy4vd2FzbS10eXBlcyc7XG5pbXBvcnQgeyBpbXBvcnRXYXNtTW9kdWxlIH0gZnJvbSAnLi93YXNtLXV0aWxzLWltcG9ydCc7XG5cbmxldCB3YXNtOiBPcnRXYXNtTW9kdWxlIHwgdW5kZWZpbmVkO1xubGV0IGluaXRpYWxpemVkID0gZmFsc2U7XG5sZXQgaW5pdGlhbGl6aW5nID0gZmFsc2U7XG5sZXQgYWJvcnRlZCA9IGZhbHNlO1xuXG5jb25zdCBpc011bHRpVGhyZWFkU3VwcG9ydGVkID0gKCk6IGJvb2xlYW4gPT4ge1xuICAvLyBJZiAnU2hhcmVkQXJyYXlCdWZmZXInIGlzIG5vdCBhdmFpbGFibGUsIFdlYkFzc2VtYmx5IHRocmVhZHMgd2lsbCBub3Qgd29yay5cbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRlc3QgZm9yIHRyYW5zZmVyYWJpbGl0eSBvZiBTQUJzIChmb3IgYnJvd3NlcnMuIG5lZWRlZCBmb3IgRmlyZWZveClcbiAgICAvLyBodHRwczovL2dyb3Vwcy5nb29nbGUuY29tL2ZvcnVtLyMhbXNnL21vemlsbGEuZGV2LnBsYXRmb3JtL0lIa0JabEhFVHBBL2R3c01OY2hXRVFBSlxuICAgIGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBuZXcgTWVzc2FnZUNoYW5uZWwoKS5wb3J0MS5wb3N0TWVzc2FnZShuZXcgU2hhcmVkQXJyYXlCdWZmZXIoMSkpO1xuICAgIH1cblxuICAgIC8vIFRlc3QgZm9yIFdlYkFzc2VtYmx5IHRocmVhZHMgY2FwYWJpbGl0eSAoZm9yIGJvdGggYnJvd3NlcnMgYW5kIE5vZGUuanMpXG4gICAgLy8gVGhpcyB0eXBlZCBhcnJheSBpcyBhIFdlYkFzc2VtYmx5IHByb2dyYW0gY29udGFpbmluZyB0aHJlYWRlZCBpbnN0cnVjdGlvbnMuXG4gICAgcmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKFxuICAgICAgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAwLCA5NywgMTE1LCAxMDksIDEsIDAsIDAsIDAsIDEsIDQsIDEsIDk2LCAwLCAwLCAzLCAyLCAxLCAwLCA1LCA0LCAxLCAzLCAxLCAxLCAxMCwgMTEsIDEsIDksIDAsIDY1LCAwLCAyNTQsIDE2LFxuICAgICAgICAyLCAwLCAyNiwgMTEsXG4gICAgICBdKSxcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5jb25zdCBpc1NpbWRTdXBwb3J0ZWQgPSAoKTogYm9vbGVhbiA9PiB7XG4gIHRyeSB7XG4gICAgLy8gVGVzdCBmb3IgV2ViQXNzZW1ibHkgU0lNRCBjYXBhYmlsaXR5IChmb3IgYm90aCBicm93c2VycyBhbmQgTm9kZS5qcylcbiAgICAvLyBUaGlzIHR5cGVkIGFycmF5IGlzIGEgV2ViQXNzZW1ibHkgcHJvZ3JhbSBjb250YWluaW5nIFNJTUQgaW5zdHJ1Y3Rpb25zLlxuXG4gICAgLy8gVGhlIGJpbmFyeSBkYXRhIGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBmb2xsb3dpbmcgY29kZSBieSB3YXQyd2FzbTpcbiAgICAvL1xuICAgIC8vIChtb2R1bGVcbiAgICAvLyAgICh0eXBlICR0MCAoZnVuYykpXG4gICAgLy8gICAoZnVuYyAkZjAgKHR5cGUgJHQwKVxuICAgIC8vICAgICAoZHJvcFxuICAgIC8vICAgICAgIChpMzJ4NC5kb3RfaTE2eDhfc1xuICAgIC8vICAgICAgICAgKGk4eDE2LnNwbGF0XG4gICAgLy8gICAgICAgICAgIChpMzIuY29uc3QgMCkpXG4gICAgLy8gICAgICAgICAodjEyOC5jb25zdCBpMzJ4NCAweDAwMDAwMDAwIDB4MDAwMDAwMDAgMHgwMDAwMDAwMCAweDAwMDAwMDAwKSkpKSlcblxuICAgIHJldHVybiBXZWJBc3NlbWJseS52YWxpZGF0ZShcbiAgICAgIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgMCwgOTcsIDExNSwgMTA5LCAxLCAwLCAwLCAwLCAxLCA0LCAxLCA5NiwgMCwgMCwgMywgMiwgMSwgMCwgMTAsIDMwLCAxLCAyOCwgMCwgNjUsIDAsIDI1MywgMTUsIDI1MywgMTIsIDAsIDAsIDAsXG4gICAgICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDI1MywgMTg2LCAxLCAyNiwgMTEsXG4gICAgICBdKSxcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5ID0gYXN5bmMgKGZsYWdzOiBFbnYuV2ViQXNzZW1ibHlGbGFncyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoaW5pdGlhbGl6ZWQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbiAgaWYgKGluaXRpYWxpemluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGNhbGxzIHRvICdpbml0aWFsaXplV2ViQXNzZW1ibHkoKScgZGV0ZWN0ZWQuXCIpO1xuICB9XG4gIGlmIChhYm9ydGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicHJldmlvdXMgY2FsbCB0byAnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KCknIGZhaWxlZC5cIik7XG4gIH1cblxuICBpbml0aWFsaXppbmcgPSB0cnVlO1xuXG4gIC8vIHdhc20gZmxhZ3MgYXJlIGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAgY29uc3QgdGltZW91dCA9IGZsYWdzLmluaXRUaW1lb3V0ITtcbiAgbGV0IG51bVRocmVhZHMgPSBmbGFncy5udW1UaHJlYWRzITtcblxuICAvLyBlbnN1cmUgU0lNRCBpcyBzdXBwb3J0ZWRcbiAgaWYgKCFpc1NpbWRTdXBwb3J0ZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignV2ViQXNzZW1ibHkgU0lNRCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LicpO1xuICB9XG5cbiAgLy8gY2hlY2sgaWYgbXVsdGktdGhyZWFkaW5nIGlzIHN1cHBvcnRlZFxuICBjb25zdCBtdWx0aVRocmVhZFN1cHBvcnRlZCA9IGlzTXVsdGlUaHJlYWRTdXBwb3J0ZWQoKTtcbiAgaWYgKG51bVRocmVhZHMgPiAxICYmICFtdWx0aVRocmVhZFN1cHBvcnRlZCkge1xuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgIXNlbGYuY3Jvc3NPcmlnaW5Jc29sYXRlZCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ2Vudi53YXNtLm51bVRocmVhZHMgaXMgc2V0IHRvICcgK1xuICAgICAgICAgIG51bVRocmVhZHMgK1xuICAgICAgICAgICcsIGJ1dCB0aGlzIHdpbGwgbm90IHdvcmsgdW5sZXNzIHlvdSBlbmFibGUgY3Jvc3NPcmlnaW5Jc29sYXRlZCBtb2RlLiAnICtcbiAgICAgICAgICAnU2VlIGh0dHBzOi8vd2ViLmRldi9jcm9zcy1vcmlnaW4taXNvbGF0aW9uLWd1aWRlLyBmb3IgbW9yZSBpbmZvLicsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ1dlYkFzc2VtYmx5IG11bHRpLXRocmVhZGluZyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LiAnICsgJ0ZhbGxpbmcgYmFjayB0byBzaW5nbGUtdGhyZWFkaW5nLicsXG4gICAgKTtcblxuICAgIC8vIHNldCBmbGFncy5udW1UaHJlYWRzIHRvIDEgc28gdGhhdCBPcnRJbml0KCkgd2lsbCBub3QgY3JlYXRlIGEgZ2xvYmFsIHRocmVhZCBwb29sLlxuICAgIGZsYWdzLm51bVRocmVhZHMgPSBudW1UaHJlYWRzID0gMTtcbiAgfVxuXG4gIGNvbnN0IHdhc21QYXRocyA9IGZsYWdzLndhc21QYXRocztcbiAgY29uc3Qgd2FzbVByZWZpeE92ZXJyaWRlID0gdHlwZW9mIHdhc21QYXRocyA9PT0gJ3N0cmluZycgPyB3YXNtUGF0aHMgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IG1qc1BhdGhPdmVycmlkZUZsYWcgPSAod2FzbVBhdGhzIGFzIEVudi5XYXNtRmlsZVBhdGhzKT8ubWpzO1xuICBjb25zdCBtanNQYXRoT3ZlcnJpZGUgPSAobWpzUGF0aE92ZXJyaWRlRmxhZyBhcyBVUkwpPy5ocmVmID8/IG1qc1BhdGhPdmVycmlkZUZsYWc7XG4gIGNvbnN0IHdhc21QYXRoT3ZlcnJpZGVGbGFnID0gKHdhc21QYXRocyBhcyBFbnYuV2FzbUZpbGVQYXRocyk/Lndhc207XG4gIGNvbnN0IHdhc21QYXRoT3ZlcnJpZGUgPSAod2FzbVBhdGhPdmVycmlkZUZsYWcgYXMgVVJMKT8uaHJlZiA/PyB3YXNtUGF0aE92ZXJyaWRlRmxhZztcbiAgY29uc3Qgd2FzbUJpbmFyeU92ZXJyaWRlID0gZmxhZ3Mud2FzbUJpbmFyeTtcblxuICBjb25zdCBbb2JqZWN0VXJsLCBvcnRXYXNtRmFjdG9yeV0gPSBhd2FpdCBpbXBvcnRXYXNtTW9kdWxlKG1qc1BhdGhPdmVycmlkZSwgd2FzbVByZWZpeE92ZXJyaWRlLCBudW1UaHJlYWRzID4gMSk7XG5cbiAgbGV0IGlzVGltZW91dCA9IGZhbHNlO1xuXG4gIGNvbnN0IHRhc2tzOiBBcnJheTxQcm9taXNlPHZvaWQ+PiA9IFtdO1xuXG4gIC8vIHByb21pc2UgZm9yIHRpbWVvdXRcbiAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgdGFza3MucHVzaChcbiAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlzVGltZW91dCA9IHRydWU7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICAvLyBwcm9taXNlIGZvciBtb2R1bGUgaW5pdGlhbGl6YXRpb25cbiAgdGFza3MucHVzaChcbiAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBjb25maWc6IFBhcnRpYWw8T3J0V2FzbU1vZHVsZT4gPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIHRocmVhZHMuIFdlYkFzc2VtYmx5IHdpbGwgY3JlYXRlIChNb2R1bGUubnVtVGhyZWFkcyAtIDEpIHdvcmtlcnMuIElmIGl0IGlzIDEsIG5vIHdvcmtlciB3aWxsIGJlXG4gICAgICAgICAqIGNyZWF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBudW1UaHJlYWRzLFxuICAgICAgfTtcblxuICAgICAgaWYgKHdhc21CaW5hcnlPdmVycmlkZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGEgY3VzdG9tIGJ1ZmZlciB3aGljaCBjb250YWlucyB0aGUgV2ViQXNzZW1ibHkgYmluYXJ5LiBUaGlzIHdpbGwgc2tpcCB0aGUgd2FzbSBmaWxlIGZldGNoaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uZmlnLndhc21CaW5hcnkgPSB3YXNtQmluYXJ5T3ZlcnJpZGU7XG4gICAgICB9IGVsc2UgaWYgKHdhc21QYXRoT3ZlcnJpZGUgfHwgd2FzbVByZWZpeE92ZXJyaWRlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGxvY2F0ZSB0aGUgV2ViQXNzZW1ibHkgZmlsZS4gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gdGhlIGZ1bGwgcGF0aCBvZiB0aGUgZmlsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogU2luY2UgRW1zY3JpcHRlbiAzLjEuNTgsIHRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgZm9yIHRoZSAud2FzbSBmaWxlLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uZmlnLmxvY2F0ZUZpbGUgPSAoZmlsZU5hbWUsIHNjcmlwdERpcmVjdG9yeSkgPT5cbiAgICAgICAgICB3YXNtUGF0aE92ZXJyaWRlID8/ICh3YXNtUHJlZml4T3ZlcnJpZGUgPz8gc2NyaXB0RGlyZWN0b3J5KSArIGZpbGVOYW1lO1xuICAgICAgfVxuXG4gICAgICBvcnRXYXNtRmFjdG9yeShjb25maWcpLnRoZW4oXG4gICAgICAgIC8vIHdhc20gbW9kdWxlIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseVxuICAgICAgICAobW9kdWxlKSA9PiB7XG4gICAgICAgICAgaW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgIHdhc20gPSBtb2R1bGU7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIGlmIChvYmplY3RVcmwpIHtcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwob2JqZWN0VXJsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHdhc20gbW9kdWxlIGZhaWxlZCB0byBpbml0aWFsaXplXG4gICAgICAgICh3aGF0KSA9PiB7XG4gICAgICAgICAgaW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgICAgICAgYWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgcmVqZWN0KHdoYXQpO1xuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9KSxcbiAgKTtcblxuICBhd2FpdCBQcm9taXNlLnJhY2UodGFza3MpO1xuXG4gIGlmIChpc1RpbWVvdXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFdlYkFzc2VtYmx5IGJhY2tlbmQgaW5pdGlhbGl6aW5nIGZhaWxlZCBkdWUgdG8gdGltZW91dDogJHt0aW1lb3V0fW1zYCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRJbnN0YW5jZSA9ICgpOiBPcnRXYXNtTW9kdWxlID0+IHtcbiAgaWYgKGluaXRpYWxpemVkICYmIHdhc20pIHtcbiAgICByZXR1cm4gd2FzbTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignV2ViQXNzZW1ibHkgaXMgbm90IGluaXRpYWxpemVkIHlldC4nKTtcbn07XG5cbmV4cG9ydCBjb25zdCBkaXNwb3NlID0gKCk6IHZvaWQgPT4ge1xuICBpZiAoaW5pdGlhbGl6ZWQgJiYgIWluaXRpYWxpemluZyAmJiAhYWJvcnRlZCkge1xuICAgIC8vIFRPRE86IGN1cnJlbnRseSBcIlBUaHJlYWQudGVybWluYXRlQWxsVGhyZWFkcygpXCIgaXMgbm90IGV4cG9zZWQgaW4gdGhlIHdhc20gbW9kdWxlLlxuICAgIC8vICAgICAgIEFuZCB0aGlzIGZ1bmN0aW9uIGlzIG5vdCB5ZXQgY2FsbGVkIGJ5IGFueSBjb2RlLlxuICAgIC8vICAgICAgIElmIGl0IGlzIG5lZWRlZCBpbiB0aGUgZnV0dXJlLCB3ZSBzaG91bGQgZXhwb3NlIGl0IGluIHRoZSB3YXNtIG1vZHVsZSBhbmQgdW5jb21tZW50IHRoZSBmb2xsb3dpbmcgbGluZS5cblxuICAgIC8vIHdhc20/LlBUaHJlYWQ/LnRlcm1pbmF0ZUFsbFRocmVhZHMoKTtcbiAgICB3YXNtID0gdW5kZWZpbmVkO1xuXG4gICAgaW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgZ2V0SW5zdGFuY2UgfSBmcm9tICcuL3dhc20tZmFjdG9yeSc7XG5cbmV4cG9ydCBjb25zdCBhbGxvY1dhc21TdHJpbmcgPSAoZGF0YTogc3RyaW5nLCBhbGxvY3M6IG51bWJlcltdKTogbnVtYmVyID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG5cbiAgY29uc3QgZGF0YUxlbmd0aCA9IHdhc20ubGVuZ3RoQnl0ZXNVVEY4KGRhdGEpICsgMTtcbiAgY29uc3QgZGF0YU9mZnNldCA9IHdhc20uX21hbGxvYyhkYXRhTGVuZ3RoKTtcbiAgd2FzbS5zdHJpbmdUb1VURjgoZGF0YSwgZGF0YU9mZnNldCwgZGF0YUxlbmd0aCk7XG4gIGFsbG9jcy5wdXNoKGRhdGFPZmZzZXQpO1xuXG4gIHJldHVybiBkYXRhT2Zmc2V0O1xufTtcblxuaW50ZXJmYWNlIEV4dHJhT3B0aW9uc0hhbmRsZXIge1xuICAobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogdm9pZDtcbn1cblxuZXhwb3J0IGNvbnN0IGl0ZXJhdGVFeHRyYU9wdGlvbnMgPSAoXG4gIG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBwcmVmaXg6IHN0cmluZyxcbiAgc2VlbjogV2Vha1NldDxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4sXG4gIGhhbmRsZXI6IEV4dHJhT3B0aW9uc0hhbmRsZXIsXG4pOiB2b2lkID0+IHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdvYmplY3QnICYmIG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICBpZiAoc2Vlbi5oYXMob3B0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2lyY3VsYXIgcmVmZXJlbmNlIGluIG9wdGlvbnMnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2Vlbi5hZGQob3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmVudHJpZXMob3B0aW9ucykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgY29uc3QgbmFtZSA9IHByZWZpeCA/IHByZWZpeCArIGtleSA6IGtleTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgaXRlcmF0ZUV4dHJhT3B0aW9ucyh2YWx1ZSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiwgbmFtZSArICcuJywgc2VlbiwgaGFuZGxlcik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGhhbmRsZXIobmFtZSwgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgaGFuZGxlcihuYW1lLCB2YWx1ZSA/ICcxJyA6ICcwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgaGFuZGxlIGV4dHJhIGNvbmZpZyB0eXBlOiAke3R5cGVvZiB2YWx1ZX1gKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBjaGVjayB3ZWIgYXNzZW1ibHkgQVBJJ3MgbGFzdCBlcnJvciBhbmQgdGhyb3cgZXJyb3IgaWYgYW55IGVycm9yIG9jY3VycmVkLlxuICogQHBhcmFtIG1lc3NhZ2UgYSBtZXNzYWdlIHVzZWQgd2hlbiBhbiBlcnJvciBvY2N1cnJlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNoZWNrTGFzdEVycm9yID0gKG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQgPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcblxuICBjb25zdCBzdGFjayA9IHdhc20uc3RhY2tTYXZlKCk7XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyYW1zT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKDgpO1xuICAgIHdhc20uX09ydEdldExhc3RFcnJvcihwYXJhbXNPZmZzZXQsIHBhcmFtc09mZnNldCArIDQpO1xuICAgIGNvbnN0IGVycm9yQ29kZSA9IHdhc20uSEVBUDMyW3BhcmFtc09mZnNldCAvIDRdO1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZVBvaW50ZXIgPSB3YXNtLkhFQVBVMzJbcGFyYW1zT2Zmc2V0IC8gNCArIDFdO1xuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yTWVzc2FnZVBvaW50ZXIgPyB3YXNtLlVURjhUb1N0cmluZyhlcnJvck1lc3NhZ2VQb2ludGVyKSA6ICcnO1xuICAgIHRocm93IG5ldyBFcnJvcihgJHttZXNzYWdlfSBFUlJPUl9DT0RFOiAke2Vycm9yQ29kZX0sIEVSUk9SX01FU1NBR0U6ICR7ZXJyb3JNZXNzYWdlfWApO1xuICB9IGZpbmFsbHkge1xuICAgIHdhc20uc3RhY2tSZXN0b3JlKHN0YWNrKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgSW5mZXJlbmNlU2Vzc2lvbiB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7IGdldEluc3RhbmNlIH0gZnJvbSAnLi93YXNtLWZhY3RvcnknO1xuaW1wb3J0IHsgYWxsb2NXYXNtU3RyaW5nLCBjaGVja0xhc3RFcnJvciwgaXRlcmF0ZUV4dHJhT3B0aW9ucyB9IGZyb20gJy4vd2FzbS11dGlscyc7XG5cbmV4cG9ydCBjb25zdCBzZXRSdW5PcHRpb25zID0gKG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uUnVuT3B0aW9ucyk6IFtudW1iZXIsIG51bWJlcltdXSA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBsZXQgcnVuT3B0aW9uc0hhbmRsZSA9IDA7XG4gIGNvbnN0IGFsbG9jczogbnVtYmVyW10gPSBbXTtcblxuICBjb25zdCBydW5PcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHRyeSB7XG4gICAgaWYgKG9wdGlvbnM/LmxvZ1NldmVyaXR5TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcnVuT3B0aW9ucy5sb2dTZXZlcml0eUxldmVsID0gMjsgLy8gRGVmYXVsdCB0byB3YXJuaW5nXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHR5cGVvZiBvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgIT09ICdudW1iZXInIHx8XG4gICAgICAhTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwpIHx8XG4gICAgICBvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgPCAwIHx8XG4gICAgICBvcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwgPiA0XG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGxvZyBzZXJ2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke29wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbH1gKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucz8ubG9nVmVyYm9zaXR5TGV2ZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcnVuT3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbCA9IDA7IC8vIERlZmF1bHQgdG8gMFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWwgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKG9wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke29wdGlvbnMubG9nVmVyYm9zaXR5TGV2ZWx9YCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnM/LnRlcm1pbmF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBydW5PcHRpb25zLnRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGxldCB0YWdEYXRhT2Zmc2V0ID0gMDtcbiAgICBpZiAob3B0aW9ucz8udGFnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhZ0RhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcob3B0aW9ucy50YWcsIGFsbG9jcyk7XG4gICAgfVxuXG4gICAgcnVuT3B0aW9uc0hhbmRsZSA9IHdhc20uX09ydENyZWF0ZVJ1bk9wdGlvbnMoXG4gICAgICBydW5PcHRpb25zLmxvZ1NldmVyaXR5TGV2ZWwhLFxuICAgICAgcnVuT3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbCEsXG4gICAgICAhIXJ1bk9wdGlvbnMudGVybWluYXRlISxcbiAgICAgIHRhZ0RhdGFPZmZzZXQsXG4gICAgKTtcbiAgICBpZiAocnVuT3B0aW9uc0hhbmRsZSA9PT0gMCkge1xuICAgICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBjcmVhdGUgcnVuIG9wdGlvbnMuXCIpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zPy5leHRyYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpdGVyYXRlRXh0cmFPcHRpb25zKG9wdGlvbnMuZXh0cmEsICcnLCBuZXcgV2Vha1NldDxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oKSwgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3Qga2V5RGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhrZXksIGFsbG9jcyk7XG4gICAgICAgIGNvbnN0IHZhbHVlRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyh2YWx1ZSwgYWxsb2NzKTtcblxuICAgICAgICBpZiAod2FzbS5fT3J0QWRkUnVuQ29uZmlnRW50cnkocnVuT3B0aW9uc0hhbmRsZSwga2V5RGF0YU9mZnNldCwgdmFsdWVEYXRhT2Zmc2V0KSAhPT0gMCkge1xuICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBzZXQgYSBydW4gY29uZmlnIGVudHJ5OiAke2tleX0gLSAke3ZhbHVlfS5gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtydW5PcHRpb25zSGFuZGxlLCBhbGxvY3NdO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHJ1bk9wdGlvbnNIYW5kbGUgIT09IDApIHtcbiAgICAgIHdhc20uX09ydFJlbGVhc2VSdW5PcHRpb25zKHJ1bk9wdGlvbnNIYW5kbGUpO1xuICAgIH1cbiAgICBhbGxvY3MuZm9yRWFjaCgoYWxsb2MpID0+IHdhc20uX2ZyZWUoYWxsb2MpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBJbmZlcmVuY2VTZXNzaW9uIH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHsgZ2V0SW5zdGFuY2UgfSBmcm9tICcuL3dhc20tZmFjdG9yeSc7XG5pbXBvcnQgeyBhbGxvY1dhc21TdHJpbmcsIGNoZWNrTGFzdEVycm9yLCBpdGVyYXRlRXh0cmFPcHRpb25zIH0gZnJvbSAnLi93YXNtLXV0aWxzJztcblxuY29uc3QgZ2V0R3JhcGhPcHRpbXphdGlvbkxldmVsID0gKGdyYXBoT3B0aW1pemF0aW9uTGV2ZWw6IHN0cmluZyB8IHVua25vd24pOiBudW1iZXIgPT4ge1xuICBzd2l0Y2ggKGdyYXBoT3B0aW1pemF0aW9uTGV2ZWwpIHtcbiAgICBjYXNlICdkaXNhYmxlZCc6XG4gICAgICByZXR1cm4gMDtcbiAgICBjYXNlICdiYXNpYyc6XG4gICAgICByZXR1cm4gMTtcbiAgICBjYXNlICdleHRlbmRlZCc6XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlICdhbGwnOlxuICAgICAgcmV0dXJuIDk5O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGdyYXBoIG9wdGltaXphdGlvbiBsZXZlbDogJHtncmFwaE9wdGltaXphdGlvbkxldmVsfWApO1xuICB9XG59O1xuXG5jb25zdCBnZXRFeGVjdXRpb25Nb2RlID0gKGV4ZWN1dGlvbk1vZGU6ICdzZXF1ZW50aWFsJyB8ICdwYXJhbGxlbCcpOiBudW1iZXIgPT4ge1xuICBzd2l0Y2ggKGV4ZWN1dGlvbk1vZGUpIHtcbiAgICBjYXNlICdzZXF1ZW50aWFsJzpcbiAgICAgIHJldHVybiAwO1xuICAgIGNhc2UgJ3BhcmFsbGVsJzpcbiAgICAgIHJldHVybiAxO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGV4ZWN1dGlvbiBtb2RlOiAke2V4ZWN1dGlvbk1vZGV9YCk7XG4gIH1cbn07XG5cbmNvbnN0IGFwcGVuZERlZmF1bHRPcHRpb25zID0gKG9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMpOiB2b2lkID0+IHtcbiAgaWYgKCFvcHRpb25zLmV4dHJhKSB7XG4gICAgb3B0aW9ucy5leHRyYSA9IHt9O1xuICB9XG4gIGlmICghb3B0aW9ucy5leHRyYS5zZXNzaW9uKSB7XG4gICAgb3B0aW9ucy5leHRyYS5zZXNzaW9uID0ge307XG4gIH1cbiAgY29uc3Qgc2Vzc2lvbiA9IG9wdGlvbnMuZXh0cmEuc2Vzc2lvbiBhcyBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICBpZiAoIXNlc3Npb24udXNlX29ydF9tb2RlbF9ieXRlc19kaXJlY3RseSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcbiAgICBzZXNzaW9uLnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHkgPSAnMSc7XG4gIH1cblxuICAvLyBpZiB1c2luZyBKU0VQIHdpdGggV2ViR1BVLCBhbHdheXMgZGlzYWJsZSBtZW1vcnkgcGF0dGVyblxuICBpZiAoXG4gICAgb3B0aW9ucy5leGVjdXRpb25Qcm92aWRlcnMgJiZcbiAgICBvcHRpb25zLmV4ZWN1dGlvblByb3ZpZGVycy5zb21lKChlcCkgPT4gKHR5cGVvZiBlcCA9PT0gJ3N0cmluZycgPyBlcCA6IGVwLm5hbWUpID09PSAnd2ViZ3B1JylcbiAgKSB7XG4gICAgb3B0aW9ucy5lbmFibGVNZW1QYXR0ZXJuID0gZmFsc2U7XG4gIH1cbn07XG5cbmNvbnN0IHNldEV4ZWN1dGlvblByb3ZpZGVycyA9IChcbiAgc2Vzc2lvbk9wdGlvbnNIYW5kbGU6IG51bWJlcixcbiAgZXhlY3V0aW9uUHJvdmlkZXJzOiByZWFkb25seSBJbmZlcmVuY2VTZXNzaW9uLkV4ZWN1dGlvblByb3ZpZGVyQ29uZmlnW10sXG4gIGFsbG9jczogbnVtYmVyW10sXG4pOiB2b2lkID0+IHtcbiAgZm9yIChjb25zdCBlcCBvZiBleGVjdXRpb25Qcm92aWRlcnMpIHtcbiAgICBsZXQgZXBOYW1lID0gdHlwZW9mIGVwID09PSAnc3RyaW5nJyA/IGVwIDogZXAubmFtZTtcblxuICAgIC8vIGNoZWNrIEVQIG5hbWVcbiAgICBzd2l0Y2ggKGVwTmFtZSkge1xuICAgICAgY2FzZSAnd2Vibm4nOlxuICAgICAgICBlcE5hbWUgPSAnV0VCTk4nO1xuICAgICAgICBpZiAodHlwZW9mIGVwICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNvbnN0IHdlYm5uT3B0aW9ucyA9IGVwIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5FeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICAgICAgICAvLyBjb25zdCBjb250ZXh0ID0gKHdlYm5uT3B0aW9ucyBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5OT3B0aW9uc1dpdGhNTENvbnRleHQpPy5jb250ZXh0O1xuICAgICAgICAgIGNvbnN0IGRldmljZVR5cGUgPSAod2Vibm5PcHRpb25zIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5Db250ZXh0T3B0aW9ucyk/LmRldmljZVR5cGU7XG4gICAgICAgICAgaWYgKGRldmljZVR5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoJ2RldmljZVR5cGUnLCBhbGxvY3MpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVEYXRhT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKGRldmljZVR5cGUsIGFsbG9jcyk7XG4gICAgICAgICAgICBpZiAoZ2V0SW5zdGFuY2UoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KHNlc3Npb25PcHRpb25zSGFuZGxlLCBrZXlEYXRhT2Zmc2V0LCB2YWx1ZURhdGFPZmZzZXQpICE9PSAwKSB7XG4gICAgICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ2RldmljZVR5cGUnIC0gJHtkZXZpY2VUeXBlfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd3ZWJncHUnOlxuICAgICAgICBlcE5hbWUgPSAnSlMnO1xuICAgICAgICBpZiAodHlwZW9mIGVwICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNvbnN0IHdlYmdwdU9wdGlvbnMgPSBlcCBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYkdwdUV4ZWN1dGlvblByb3ZpZGVyT3B0aW9uO1xuICAgICAgICAgIGlmICh3ZWJncHVPcHRpb25zPy5wcmVmZXJyZWRMYXlvdXQpIHtcbiAgICAgICAgICAgIGlmICh3ZWJncHVPcHRpb25zLnByZWZlcnJlZExheW91dCAhPT0gJ05DSFcnICYmIHdlYmdwdU9wdGlvbnMucHJlZmVycmVkTGF5b3V0ICE9PSAnTkhXQycpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcmVmZXJyZWRMYXlvdXQgbXVzdCBiZSBlaXRoZXIgJ05DSFcnIG9yICdOSFdDJzogJHt3ZWJncHVPcHRpb25zLnByZWZlcnJlZExheW91dH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGtleURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoJ3ByZWZlcnJlZExheW91dCcsIGFsbG9jcyk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcod2ViZ3B1T3B0aW9ucy5wcmVmZXJyZWRMYXlvdXQsIGFsbG9jcyk7XG4gICAgICAgICAgICBpZiAoZ2V0SW5zdGFuY2UoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KHNlc3Npb25PcHRpb25zSGFuZGxlLCBrZXlEYXRhT2Zmc2V0LCB2YWx1ZURhdGFPZmZzZXQpICE9PSAwKSB7XG4gICAgICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ3ByZWZlcnJlZExheW91dCcgLSAke3dlYmdwdU9wdGlvbnMucHJlZmVycmVkTGF5b3V0fS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd3YXNtJzpcbiAgICAgIGNhc2UgJ2NwdSc6XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtlcE5hbWV9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgZXBOYW1lRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhlcE5hbWUsIGFsbG9jcyk7XG4gICAgaWYgKGdldEluc3RhbmNlKCkuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyKHNlc3Npb25PcHRpb25zSGFuZGxlLCBlcE5hbWVEYXRhT2Zmc2V0KSAhPT0gMCkge1xuICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGFwcGVuZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7ZXBOYW1lfS5gKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBzZXRTZXNzaW9uT3B0aW9ucyA9IChvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyk6IFtudW1iZXIsIG51bWJlcltdXSA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBsZXQgc2Vzc2lvbk9wdGlvbnNIYW5kbGUgPSAwO1xuICBjb25zdCBhbGxvY3M6IG51bWJlcltdID0gW107XG5cbiAgY29uc3Qgc2Vzc2lvbk9wdGlvbnM6IEluZmVyZW5jZVNlc3Npb24uU2Vzc2lvbk9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBhcHBlbmREZWZhdWx0T3B0aW9ucyhzZXNzaW9uT3B0aW9ucyk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBncmFwaE9wdGltaXphdGlvbkxldmVsID0gZ2V0R3JhcGhPcHRpbXphdGlvbkxldmVsKHNlc3Npb25PcHRpb25zLmdyYXBoT3B0aW1pemF0aW9uTGV2ZWwgPz8gJ2FsbCcpO1xuICAgIGNvbnN0IGV4ZWN1dGlvbk1vZGUgPSBnZXRFeGVjdXRpb25Nb2RlKHNlc3Npb25PcHRpb25zLmV4ZWN1dGlvbk1vZGUgPz8gJ3NlcXVlbnRpYWwnKTtcbiAgICBjb25zdCBsb2dJZERhdGFPZmZzZXQgPVxuICAgICAgdHlwZW9mIHNlc3Npb25PcHRpb25zLmxvZ0lkID09PSAnc3RyaW5nJyA/IGFsbG9jV2FzbVN0cmluZyhzZXNzaW9uT3B0aW9ucy5sb2dJZCwgYWxsb2NzKSA6IDA7XG5cbiAgICBjb25zdCBsb2dTZXZlcml0eUxldmVsID0gc2Vzc2lvbk9wdGlvbnMubG9nU2V2ZXJpdHlMZXZlbCA/PyAyOyAvLyBEZWZhdWx0IHRvIDIgLSB3YXJuaW5nXG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGxvZ1NldmVyaXR5TGV2ZWwpIHx8IGxvZ1NldmVyaXR5TGV2ZWwgPCAwIHx8IGxvZ1NldmVyaXR5TGV2ZWwgPiA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGxvZyBzZXJ2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2xvZ1NldmVyaXR5TGV2ZWx9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgbG9nVmVyYm9zaXR5TGV2ZWwgPSBzZXNzaW9uT3B0aW9ucy5sb2dWZXJib3NpdHlMZXZlbCA/PyAwOyAvLyBEZWZhdWx0IHRvIDAgLSB2ZXJib3NlXG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGxvZ1ZlcmJvc2l0eUxldmVsKSB8fCBsb2dWZXJib3NpdHlMZXZlbCA8IDAgfHwgbG9nVmVyYm9zaXR5TGV2ZWwgPiA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2xvZ1ZlcmJvc2l0eUxldmVsfWApO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGltaXplZE1vZGVsRmlsZVBhdGhPZmZzZXQgPVxuICAgICAgdHlwZW9mIHNlc3Npb25PcHRpb25zLm9wdGltaXplZE1vZGVsRmlsZVBhdGggPT09ICdzdHJpbmcnXG4gICAgICAgID8gYWxsb2NXYXNtU3RyaW5nKHNlc3Npb25PcHRpb25zLm9wdGltaXplZE1vZGVsRmlsZVBhdGgsIGFsbG9jcylcbiAgICAgICAgOiAwO1xuXG4gICAgc2Vzc2lvbk9wdGlvbnNIYW5kbGUgPSB3YXNtLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyhcbiAgICAgIGdyYXBoT3B0aW1pemF0aW9uTGV2ZWwsXG4gICAgICAhIXNlc3Npb25PcHRpb25zLmVuYWJsZUNwdU1lbUFyZW5hLFxuICAgICAgISFzZXNzaW9uT3B0aW9ucy5lbmFibGVNZW1QYXR0ZXJuLFxuICAgICAgZXhlY3V0aW9uTW9kZSxcbiAgICAgICEhc2Vzc2lvbk9wdGlvbnMuZW5hYmxlUHJvZmlsaW5nLFxuICAgICAgMCxcbiAgICAgIGxvZ0lkRGF0YU9mZnNldCxcbiAgICAgIGxvZ1NldmVyaXR5TGV2ZWwsXG4gICAgICBsb2dWZXJib3NpdHlMZXZlbCxcbiAgICAgIG9wdGltaXplZE1vZGVsRmlsZVBhdGhPZmZzZXQsXG4gICAgKTtcbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnNIYW5kbGUgPT09IDApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgY3JlYXRlIHNlc3Npb24gb3B0aW9ucy5cIik7XG4gICAgfVxuXG4gICAgaWYgKHNlc3Npb25PcHRpb25zLmV4ZWN1dGlvblByb3ZpZGVycykge1xuICAgICAgc2V0RXhlY3V0aW9uUHJvdmlkZXJzKHNlc3Npb25PcHRpb25zSGFuZGxlLCBzZXNzaW9uT3B0aW9ucy5leGVjdXRpb25Qcm92aWRlcnMsIGFsbG9jcyk7XG4gICAgfVxuXG4gICAgaWYgKHNlc3Npb25PcHRpb25zLmVuYWJsZUdyYXBoQ2FwdHVyZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIHNlc3Npb25PcHRpb25zLmVuYWJsZUdyYXBoQ2FwdHVyZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZW5hYmxlR3JhcGhDYXB0dXJlIG11c3QgYmUgYSBib29sZWFuIHZhbHVlOiAke3Nlc3Npb25PcHRpb25zLmVuYWJsZUdyYXBoQ2FwdHVyZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoJ2VuYWJsZUdyYXBoQ2FwdHVyZScsIGFsbG9jcyk7XG4gICAgICBjb25zdCB2YWx1ZURhdGFPZmZzZXQgPSBhbGxvY1dhc21TdHJpbmcoc2Vzc2lvbk9wdGlvbnMuZW5hYmxlR3JhcGhDYXB0dXJlLnRvU3RyaW5nKCksIGFsbG9jcyk7XG4gICAgICBpZiAod2FzbS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KHNlc3Npb25PcHRpb25zSGFuZGxlLCBrZXlEYXRhT2Zmc2V0LCB2YWx1ZURhdGFPZmZzZXQpICE9PSAwKSB7XG4gICAgICAgIGNoZWNrTGFzdEVycm9yKFxuICAgICAgICAgIGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ2VuYWJsZUdyYXBoQ2FwdHVyZScgLSAke3Nlc3Npb25PcHRpb25zLmVuYWJsZUdyYXBoQ2FwdHVyZX0uYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnMuZnJlZURpbWVuc2lvbk92ZXJyaWRlcykge1xuICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHNlc3Npb25PcHRpb25zLmZyZWVEaW1lbnNpb25PdmVycmlkZXMpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlIG5hbWUgbXVzdCBiZSBhIHN0cmluZzogJHtuYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlIHZhbHVlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcjogJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lT2Zmc2V0ID0gYWxsb2NXYXNtU3RyaW5nKG5hbWUsIGFsbG9jcyk7XG4gICAgICAgIGlmICh3YXNtLl9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGUoc2Vzc2lvbk9wdGlvbnNIYW5kbGUsIG5hbWVPZmZzZXQsIHZhbHVlKSAhPT0gMCkge1xuICAgICAgICAgIGNoZWNrTGFzdEVycm9yKGBDYW4ndCBzZXQgYSBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZTogJHtuYW1lfSAtICR7dmFsdWV9LmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNlc3Npb25PcHRpb25zLmV4dHJhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGl0ZXJhdGVFeHRyYU9wdGlvbnMoc2Vzc2lvbk9wdGlvbnMuZXh0cmEsICcnLCBuZXcgV2Vha1NldDxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oKSwgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3Qga2V5RGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyhrZXksIGFsbG9jcyk7XG4gICAgICAgIGNvbnN0IHZhbHVlRGF0YU9mZnNldCA9IGFsbG9jV2FzbVN0cmluZyh2YWx1ZSwgYWxsb2NzKTtcblxuICAgICAgICBpZiAod2FzbS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KHNlc3Npb25PcHRpb25zSGFuZGxlLCBrZXlEYXRhT2Zmc2V0LCB2YWx1ZURhdGFPZmZzZXQpICE9PSAwKSB7XG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAke2tleX0gLSAke3ZhbHVlfS5gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtzZXNzaW9uT3B0aW9uc0hhbmRsZSwgYWxsb2NzXTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChzZXNzaW9uT3B0aW9uc0hhbmRsZSAhPT0gMCkge1xuICAgICAgd2FzbS5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKHNlc3Npb25PcHRpb25zSGFuZGxlKTtcbiAgICB9XG4gICAgYWxsb2NzLmZvckVhY2goKGFsbG9jKSA9PiB3YXNtLl9mcmVlKGFsbG9jKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVGVuc29yIH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuLy8gYSBkdW1teSB0eXBlIGRlY2xhcmF0aW9uIGZvciBGbG9hdDE2QXJyYXkgaW4gY2FzZSBhbnkgcG9seWZpbGwgaXMgYXZhaWxhYmxlLlxuZGVjbGFyZSBnbG9iYWwge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGNvbnN0IEZsb2F0MTZBcnJheTogYW55O1xufVxuXG4vLyBUaGlzIGZpbGUgaW5jbHVkZXMgY29tbW9uIGRlZmluaXRpb25zLiBUaGV5IGRvIE5PVCBoYXZlIGRlcGVuZGVuY3kgb24gdGhlIFdlYkFzc2VtYmx5IGluc3RhbmNlLlxuXG4vKipcbiAqIENvcGllZCBmcm9tIE9OTlggZGVmaW5pdGlvbi4gVXNlIHRoaXMgdG8gZHJvcCBkZXBlbmRlbmN5ICdvbm54X3Byb3RvJyB0byBkZWNyZWFzZSBjb21waWxlZCAuanMgZmlsZSBzaXplLlxuICovXG5leHBvcnQgY29uc3QgZW51bSBEYXRhVHlwZSB7XG4gIHVuZGVmaW5lZCA9IDAsXG4gIGZsb2F0ID0gMSxcbiAgdWludDggPSAyLFxuICBpbnQ4ID0gMyxcbiAgdWludDE2ID0gNCxcbiAgaW50MTYgPSA1LFxuICBpbnQzMiA9IDYsXG4gIGludDY0ID0gNyxcbiAgc3RyaW5nID0gOCxcbiAgYm9vbCA9IDksXG4gIGZsb2F0MTYgPSAxMCxcbiAgZG91YmxlID0gMTEsXG4gIHVpbnQzMiA9IDEyLFxuICB1aW50NjQgPSAxMyxcbiAgY29tcGxleDY0ID0gMTQsXG4gIGNvbXBsZXgxMjggPSAxNSxcbiAgYmZsb2F0MTYgPSAxNixcblxuICAvLyA0LWJpdCBkYXRhLXR5cGVzXG4gIHVpbnQ0ID0gMjEsXG4gIGludDQgPSAyMixcbn1cblxuLyoqXG4gKiBNYXAgc3RyaW5nIHRlbnNvciBkYXRhIHRvIGVudW0gdmFsdWVcbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtID0gKHR5cGU6IHN0cmluZyk6IERhdGFUeXBlID0+IHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnaW50OCc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuaW50ODtcbiAgICBjYXNlICd1aW50OCc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUudWludDg7XG4gICAgY2FzZSAnYm9vbCc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuYm9vbDtcbiAgICBjYXNlICdpbnQxNic6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuaW50MTY7XG4gICAgY2FzZSAndWludDE2JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS51aW50MTY7XG4gICAgY2FzZSAnaW50MzInOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLmludDMyO1xuICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICByZXR1cm4gRGF0YVR5cGUudWludDMyO1xuICAgIGNhc2UgJ2Zsb2F0MTYnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLmZsb2F0MTY7XG4gICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuZmxvYXQ7XG4gICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuZG91YmxlO1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gRGF0YVR5cGUuc3RyaW5nO1xuICAgIGNhc2UgJ2ludDY0JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5pbnQ2NDtcbiAgICBjYXNlICd1aW50NjQnOlxuICAgICAgcmV0dXJuIERhdGFUeXBlLnVpbnQ2NDtcbiAgICBjYXNlICdpbnQ0JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS5pbnQ0O1xuICAgIGNhc2UgJ3VpbnQ0JzpcbiAgICAgIHJldHVybiBEYXRhVHlwZS51aW50NDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0eXBlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIE1hcCBlbnVtIHZhbHVlIHRvIHN0cmluZyB0ZW5zb3IgZGF0YVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcgPSAodHlwZVByb3RvOiBEYXRhVHlwZSk6IFRlbnNvci5UeXBlID0+IHtcbiAgc3dpdGNoICh0eXBlUHJvdG8pIHtcbiAgICBjYXNlIERhdGFUeXBlLmludDg6XG4gICAgICByZXR1cm4gJ2ludDgnO1xuICAgIGNhc2UgRGF0YVR5cGUudWludDg6XG4gICAgICByZXR1cm4gJ3VpbnQ4JztcbiAgICBjYXNlIERhdGFUeXBlLmJvb2w6XG4gICAgICByZXR1cm4gJ2Jvb2wnO1xuICAgIGNhc2UgRGF0YVR5cGUuaW50MTY6XG4gICAgICByZXR1cm4gJ2ludDE2JztcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQxNjpcbiAgICAgIHJldHVybiAndWludDE2JztcbiAgICBjYXNlIERhdGFUeXBlLmludDMyOlxuICAgICAgcmV0dXJuICdpbnQzMic7XG4gICAgY2FzZSBEYXRhVHlwZS51aW50MzI6XG4gICAgICByZXR1cm4gJ3VpbnQzMic7XG4gICAgY2FzZSBEYXRhVHlwZS5mbG9hdDE2OlxuICAgICAgcmV0dXJuICdmbG9hdDE2JztcbiAgICBjYXNlIERhdGFUeXBlLmZsb2F0OlxuICAgICAgcmV0dXJuICdmbG9hdDMyJztcbiAgICBjYXNlIERhdGFUeXBlLmRvdWJsZTpcbiAgICAgIHJldHVybiAnZmxvYXQ2NCc7XG4gICAgY2FzZSBEYXRhVHlwZS5zdHJpbmc6XG4gICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgY2FzZSBEYXRhVHlwZS5pbnQ2NDpcbiAgICAgIHJldHVybiAnaW50NjQnO1xuICAgIGNhc2UgRGF0YVR5cGUudWludDY0OlxuICAgICAgcmV0dXJuICd1aW50NjQnO1xuICAgIGNhc2UgRGF0YVR5cGUuaW50NDpcbiAgICAgIHJldHVybiAnaW50NCc7XG4gICAgY2FzZSBEYXRhVHlwZS51aW50NDpcbiAgICAgIHJldHVybiAndWludDQnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R5cGVQcm90b31gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBnZXQgdGVuc29yIHNpemUgaW4gYnl0ZXMgYnkgdGhlIGdpdmVuIGRhdGEgdHlwZSBhbmQgZGltZW5zaW9uc1xuICogQHJldHVybnMgc2l6ZSBpbiBpbnRlZ2VyIG9yIHVuZGVmaW5lZCBpZiB0aGUgZGF0YSB0eXBlIGlzIG5vdCBzdXBwb3J0ZWRcbiAqL1xuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZVRlbnNvclNpemVJbkJ5dGVzID0gKFxuICBkYXRlVHlwZTogbnVtYmVyLFxuICBkaW1zT3JTaXplOiByZWFkb25seSBudW1iZXJbXSB8IG51bWJlcixcbik6IG51bWJlciB8IHVuZGVmaW5lZCA9PiB7XG4gIGNvbnN0IGVsZW1lbnRTaXplID0gW1xuICAgIC0xLCAvLyB1bmRlZmluZWQgPSAwXG4gICAgNCwgLy8gZmxvYXQgPSAxXG4gICAgMSwgLy8gdWludDggPSAyXG4gICAgMSwgLy8gaW50OCA9IDNcbiAgICAyLCAvLyB1aW50MTYgPSA0XG4gICAgMiwgLy8gaW50MTYgPSA1XG4gICAgNCwgLy8gaW50MzIgPSA2XG4gICAgOCwgLy8gaW50NjQgPSA3XG4gICAgLTEsIC8vIHN0cmluZyA9IDhcbiAgICAxLCAvLyBib29sID0gOVxuICAgIDIsIC8vIGZsb2F0MTYgPSAxMFxuICAgIDgsIC8vIGRvdWJsZSA9IDExXG4gICAgNCwgLy8gdWludDMyID0gMTJcbiAgICA4LCAvLyB1aW50NjQgPSAxM1xuICAgIC0xLCAvLyBjb21wbGV4NjQgPSAxNFxuICAgIC0xLCAvLyBjb21wbGV4MTI4ID0gMTVcbiAgICAtMSwgLy8gYmZsb2F0MTYgPSAxNlxuICAgIC0xLCAvLyBGTE9BVDhFNE0zRk4gPSAxN1xuICAgIC0xLCAvLyBGTE9BVDhFNE0zRk5VWiA9IDE4XG4gICAgLTEsIC8vIEZMT0FUOEU1TTIgPSAxOVxuICAgIC0xLCAvLyBGTE9BVDhFNU0yRk5VWiA9IDIwXG4gICAgMC41LCAvLyB1aW50NCA9IDIxXG4gICAgMC41LCAvLyBpbnQ0ID0gMjJcbiAgXVtkYXRlVHlwZV07XG5cbiAgY29uc3Qgc2l6ZSA9IHR5cGVvZiBkaW1zT3JTaXplID09PSAnbnVtYmVyJyA/IGRpbXNPclNpemUgOiBkaW1zT3JTaXplLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIsIDEpO1xuICByZXR1cm4gZWxlbWVudFNpemUgPiAwID8gTWF0aC5jZWlsKHNpemUgKiBlbGVtZW50U2l6ZSkgOiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIGdldCB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvciBieSB0aGUgZ2l2ZW4gdGVuc29yIHR5cGVcbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IChcbiAgdHlwZTogVGVuc29yLlR5cGUsXG4pOlxuICB8IEZsb2F0MzJBcnJheUNvbnN0cnVjdG9yXG4gIHwgVWludDhBcnJheUNvbnN0cnVjdG9yXG4gIHwgSW50OEFycmF5Q29uc3RydWN0b3JcbiAgfCBVaW50MTZBcnJheUNvbnN0cnVjdG9yXG4gIHwgSW50MTZBcnJheUNvbnN0cnVjdG9yXG4gIHwgSW50MzJBcnJheUNvbnN0cnVjdG9yXG4gIHwgQmlnSW50NjRBcnJheUNvbnN0cnVjdG9yXG4gIHwgVWludDhBcnJheUNvbnN0cnVjdG9yXG4gIHwgRmxvYXQ2NEFycmF5Q29uc3RydWN0b3JcbiAgfCBVaW50MzJBcnJheUNvbnN0cnVjdG9yXG4gIHwgQmlnVWludDY0QXJyYXlDb25zdHJ1Y3RvciA9PiB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2Zsb2F0MTYnOlxuICAgICAgLy8gYWxsb3cgRmxvYXQxNkFycmF5IHBvbHlmaWxsLlxuICAgICAgcmV0dXJuIHR5cGVvZiBGbG9hdDE2QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIEZsb2F0MTZBcnJheS5mcm9tID8gRmxvYXQxNkFycmF5IDogVWludDE2QXJyYXk7XG4gICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICByZXR1cm4gRmxvYXQzMkFycmF5O1xuICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgIHJldHVybiBVaW50OEFycmF5O1xuICAgIGNhc2UgJ2ludDgnOlxuICAgICAgcmV0dXJuIEludDhBcnJheTtcbiAgICBjYXNlICd1aW50MTYnOlxuICAgICAgcmV0dXJuIFVpbnQxNkFycmF5O1xuICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgIHJldHVybiBJbnQxNkFycmF5O1xuICAgIGNhc2UgJ2ludDMyJzpcbiAgICAgIHJldHVybiBJbnQzMkFycmF5O1xuICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXk7XG4gICAgY2FzZSAnZmxvYXQ2NCc6XG4gICAgICByZXR1cm4gRmxvYXQ2NEFycmF5O1xuICAgIGNhc2UgJ3VpbnQzMic6XG4gICAgICByZXR1cm4gVWludDMyQXJyYXk7XG4gICAgY2FzZSAnaW50NjQnOlxuICAgICAgcmV0dXJuIEJpZ0ludDY0QXJyYXk7XG4gICAgY2FzZSAndWludDY0JzpcbiAgICAgIHJldHVybiBCaWdVaW50NjRBcnJheTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCB0eXBlOiAke3R5cGV9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogTWFwIHN0cmluZyBsb2cgbGV2ZWwgdG8gaW50ZWdlciB2YWx1ZVxuICovXG5leHBvcnQgY29uc3QgbG9nTGV2ZWxTdHJpbmdUb0VudW0gPSAobG9nTGV2ZWw/OiAndmVyYm9zZScgfCAnaW5mbycgfCAnd2FybmluZycgfCAnZXJyb3InIHwgJ2ZhdGFsJyk6IG51bWJlciA9PiB7XG4gIHN3aXRjaCAobG9nTGV2ZWwpIHtcbiAgICBjYXNlICd2ZXJib3NlJzpcbiAgICAgIHJldHVybiAwO1xuICAgIGNhc2UgJ2luZm8nOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSAnd2FybmluZyc6XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlICdlcnJvcic6XG4gICAgICByZXR1cm4gMztcbiAgICBjYXNlICdmYXRhbCc6XG4gICAgICByZXR1cm4gNDtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke2xvZ0xldmVsfWApO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHRlbnNvciB0eXBlIGlzIHN1cHBvcnRlZCBieSBHUFUgYnVmZmVyXG4gKi9cbmV4cG9ydCBjb25zdCBpc0dwdUJ1ZmZlclN1cHBvcnRlZFR5cGUgPSAodHlwZTogVGVuc29yLlR5cGUpOiB0eXBlIGlzIFRlbnNvci5HcHVCdWZmZXJEYXRhVHlwZXMgPT5cbiAgdHlwZSA9PT0gJ2Zsb2F0MzInIHx8XG4gIHR5cGUgPT09ICdmbG9hdDE2JyB8fFxuICB0eXBlID09PSAnaW50MzInIHx8XG4gIHR5cGUgPT09ICdpbnQ2NCcgfHxcbiAgdHlwZSA9PT0gJ3VpbnQzMicgfHxcbiAgdHlwZSA9PT0gJ3VpbnQ4JyB8fFxuICB0eXBlID09PSAnYm9vbCcgfHxcbiAgdHlwZSA9PT0gJ3VpbnQ0JyB8fFxuICB0eXBlID09PSAnaW50NCc7XG5cbi8qKlxuICogTWFwIHN0cmluZyBkYXRhIGxvY2F0aW9uIHRvIGludGVnZXIgdmFsdWVcbiAqL1xuZXhwb3J0IGNvbnN0IGRhdGFMb2NhdGlvblN0cmluZ1RvRW51bSA9IChsb2NhdGlvbjogVGVuc29yLkRhdGFMb2NhdGlvbik6IG51bWJlciA9PiB7XG4gIHN3aXRjaCAobG9jYXRpb24pIHtcbiAgICBjYXNlICdub25lJzpcbiAgICAgIHJldHVybiAwO1xuICAgIGNhc2UgJ2NwdSc6XG4gICAgICByZXR1cm4gMTtcbiAgICBjYXNlICdjcHUtcGlubmVkJzpcbiAgICAgIHJldHVybiAyO1xuICAgIGNhc2UgJ3RleHR1cmUnOlxuICAgICAgcmV0dXJuIDM7XG4gICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XG4gICAgICByZXR1cm4gNDtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIGxvY2F0aW9uOiAke2xvY2F0aW9ufWApO1xuICB9XG59O1xuXG4vKipcbiAqIE1hcCBpbnRlZ2VyIGRhdGEgbG9jYXRpb24gdG8gc3RyaW5nIHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCBkYXRhTG9jYXRpb25FbnVtVG9TdHJpbmcgPSAobG9jYXRpb246IG51bWJlcik6IFRlbnNvci5EYXRhTG9jYXRpb24gfCB1bmRlZmluZWQgPT5cbiAgKFsnbm9uZScsICdjcHUnLCAnY3B1LXBpbm5lZCcsICd0ZXh0dXJlJywgJ2dwdS1idWZmZXInXSBhcyBjb25zdClbbG9jYXRpb25dO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBpc05vZGUgfSBmcm9tICcuL3dhc20tdXRpbHMtZW52JztcblxuLyoqXG4gKiBMb2FkIGEgZmlsZSBpbnRvIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0gZmlsZSAtIHRoZSBmaWxlIHRvIGxvYWQuIENhbiBiZSBhIFVSTC9wYXRoLCBhIEJsb2IsIGFuIEFycmF5QnVmZmVyLCBvciBhIFVpbnQ4QXJyYXkuXG4gKiBAcmV0dXJucyBhIFVpbnQ4QXJyYXkgY29udGFpbmluZyB0aGUgZmlsZSBkYXRhLlxuICovXG5leHBvcnQgY29uc3QgbG9hZEZpbGUgPSBhc3luYyAoZmlsZTogc3RyaW5nIHwgQmxvYiB8IEFycmF5QnVmZmVyTGlrZSB8IFVpbnQ4QXJyYXkpOiBQcm9taXNlPFVpbnQ4QXJyYXk+ID0+IHtcbiAgaWYgKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChpc05vZGUpIHtcbiAgICAgIC8vIGxvYWQgZmlsZSBpbnRvIEFycmF5QnVmZmVyIGluIE5vZGUuanNcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgcmVhZEZpbGUgfSA9IHJlcXVpcmUoJ25vZGU6ZnMvcHJvbWlzZXMnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHJlYWRGaWxlKGZpbGUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUuY29kZSA9PT0gJ0VSUl9GU19GSUxFX1RPT19MQVJHRScpIHtcbiAgICAgICAgICAvLyBmaWxlIGlzIHRvbyBsYXJnZSwgdXNlIGZzLmNyZWF0ZVJlYWRTdHJlYW0gaW5zdGVhZFxuICAgICAgICAgIGNvbnN0IHsgY3JlYXRlUmVhZFN0cmVhbSB9ID0gcmVxdWlyZSgnbm9kZTpmcycpO1xuICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IGNyZWF0ZVJlYWRTdHJlYW0oZmlsZSk7XG4gICAgICAgICAgY29uc3QgY2h1bmtzOiBVaW50OEFycmF5W10gPSBbXTtcbiAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmNvbmNhdChjaHVua3MpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsb2FkIGZpbGUgaW50byBBcnJheUJ1ZmZlciBpbiBicm93c2Vyc1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChmaWxlKTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gbG9hZCBleHRlcm5hbCBkYXRhIGZpbGU6ICR7ZmlsZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGhIZWFkZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1MZW5ndGgnKTtcbiAgICAgIGNvbnN0IGZpbGVTaXplID0gY29udGVudExlbmd0aEhlYWRlciA/IHBhcnNlSW50KGNvbnRlbnRMZW5ndGhIZWFkZXIsIDEwKSA6IDA7XG4gICAgICBpZiAoZmlsZVNpemUgPCAxMDczNzQxODI0IC8qIDFHQiAqLykge1xuICAgICAgICAvLyB3aGVuIENvbnRlbnQtTGVuZ3RoIGhlYWRlciBpcyBub3Qgc2V0LCB3ZSBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBmaWxlIHNpemUuIFdlIGFzc3VtZSBpdCBpcyBzbWFsbCBlbm91Z2ggdG9cbiAgICAgICAgLy8gbG9hZCBpbnRvIG1lbW9yeS5cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmlsZSBpcyB0b28gbGFyZ2UsIHVzZSBzdHJlYW0gaW5zdGVhZFxuICAgICAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBsb2FkIGV4dGVybmFsIGRhdGEgZmlsZTogJHtmaWxlfSwgbm8gcmVzcG9uc2UgYm9keS5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuXG4gICAgICAgIGxldCBidWZmZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gdHJ5IHRvIGNyZWF0ZSBBcnJheUJ1ZmZlciBkaXJlY3RseVxuICAgICAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihmaWxlU2l6ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFJhbmdlRXJyb3IpIHtcbiAgICAgICAgICAgIC8vIHVzZSBXZWJBc3NlbWJseSBNZW1vcnkgdG8gYWxsb2NhdGUgbGFyZ2VyIEFycmF5QnVmZmVyXG4gICAgICAgICAgICBjb25zdCBwYWdlcyA9IE1hdGguY2VpbChmaWxlU2l6ZSAvIDY1NTM2KTtcbiAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoeyBpbml0aWFsOiBwYWdlcywgbWF4aW11bTogcGFnZXMgfSkuYnVmZmVyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgY29uc3QgY2h1bmsgPSBuZXcgVWludDhBcnJheShidWZmZXIsIG9mZnNldCwgY2h1bmtTaXplKTtcbiAgICAgICAgICBjaHVuay5zZXQodmFsdWUpO1xuICAgICAgICAgIG9mZnNldCArPSBjaHVua1NpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgMCwgZmlsZVNpemUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChmaWxlIGluc3RhbmNlb2YgQmxvYikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShhd2FpdCBmaWxlLmFycmF5QnVmZmVyKCkpO1xuICB9IGVsc2UgaWYgKGZpbGUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGZpbGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGZpbGUpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBFbnYgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgeyBsb2dMZXZlbFN0cmluZ1RvRW51bSB9IGZyb20gJy4uL3dhc20tY29tbW9uJztcblxudHlwZSBMb2dMZXZlbCA9IE5vbk51bGxhYmxlPEVudlsnbG9nTGV2ZWwnXT47XG50eXBlIE1lc3NhZ2VTdHJpbmcgPSBzdHJpbmc7XG50eXBlIE1lc3NhZ2VGdW5jdGlvbiA9ICgpID0+IHN0cmluZztcbnR5cGUgTWVzc2FnZSA9IE1lc3NhZ2VTdHJpbmcgfCBNZXNzYWdlRnVuY3Rpb247XG5cbmNvbnN0IGxvZ0xldmVsUHJlZml4ID0gWydWJywgJ0knLCAnVycsICdFJywgJ0YnXTtcblxuY29uc3QgZG9Mb2cgPSAobGV2ZWw6IG51bWJlciwgbWVzc2FnZTogc3RyaW5nKTogdm9pZCA9PiB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gIGNvbnNvbGUubG9nKGBbJHtsb2dMZXZlbFByZWZpeFtsZXZlbF19LCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfV0ke21lc3NhZ2V9YCk7XG59O1xuXG5sZXQgY29uZmlnTG9nTGV2ZWw6IExvZ0xldmVsIHwgdW5kZWZpbmVkO1xubGV0IGRlYnVnOiBib29sZWFuIHwgdW5kZWZpbmVkO1xuXG5leHBvcnQgY29uc3QgY29uZmlndXJlTG9nZ2VyID0gKCRjb25maWdMb2dMZXZlbDogTG9nTGV2ZWwsICRkZWJ1ZzogYm9vbGVhbik6IHZvaWQgPT4ge1xuICBjb25maWdMb2dMZXZlbCA9ICRjb25maWdMb2dMZXZlbDtcbiAgZGVidWcgPSAkZGVidWc7XG59O1xuXG4vKipcbiAqIEEgc2ltcGxlIGxvZ2dpbmcgdXRpbGl0eSB0byBsb2cgbWVzc2FnZXMgdG8gdGhlIGNvbnNvbGUuXG4gKi9cbmV4cG9ydCBjb25zdCBMT0cgPSAobG9nTGV2ZWw6IExvZ0xldmVsLCBtc2c6IE1lc3NhZ2UpOiB2b2lkID0+IHtcbiAgY29uc3QgbWVzc2FnZUxldmVsID0gbG9nTGV2ZWxTdHJpbmdUb0VudW0obG9nTGV2ZWwpO1xuICBjb25zdCBjb25maWdMZXZlbCA9IGxvZ0xldmVsU3RyaW5nVG9FbnVtKGNvbmZpZ0xvZ0xldmVsKTtcbiAgaWYgKG1lc3NhZ2VMZXZlbCA+PSBjb25maWdMZXZlbCkge1xuICAgIGRvTG9nKG1lc3NhZ2VMZXZlbCwgdHlwZW9mIG1zZyA9PT0gJ2Z1bmN0aW9uJyA/IG1zZygpIDogbXNnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBIHNpbXBsZSBsb2dnaW5nIHV0aWxpdHkgdG8gbG9nIG1lc3NhZ2VzIHRvIHRoZSBjb25zb2xlLiBPbmx5IGxvZ3Mgd2hlbiBkZWJ1ZyBpcyBlbmFibGVkLlxuICovXG5leHBvcnQgY29uc3QgTE9HX0RFQlVHOiB0eXBlb2YgTE9HID0gKC4uLmFyZ3M6IFBhcmFtZXRlcnM8dHlwZW9mIExPRz4pID0+IHtcbiAgaWYgKGRlYnVnKSB7XG4gICAgTE9HKC4uLmFyZ3MpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgeyB0ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3IgfSBmcm9tICcuLi93YXNtLWNvbW1vbic7XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVWaWV3ID0gKFxuICBkYXRhQnVmZmVyOiBBcnJheUJ1ZmZlcixcbiAgdHlwZTogVGVuc29yLlR5cGUsXG4pOlxuICB8IEludDMyQXJyYXlcbiAgfCBVaW50MzJBcnJheVxuICB8IEJpZ0ludDY0QXJyYXlcbiAgfCBCaWdVaW50NjRBcnJheVxuICB8IFVpbnQ4QXJyYXlcbiAgfCBGbG9hdDMyQXJyYXlcbiAgfCBGbG9hdDY0QXJyYXlcbiAgfCBJbnQ4QXJyYXlcbiAgfCBJbnQxNkFycmF5XG4gIHwgVWludDE2QXJyYXkgPT4gbmV3ICh0ZW5zb3JUeXBlVG9UeXBlZEFycmF5Q29uc3RydWN0b3IodHlwZSkpKGRhdGFCdWZmZXIpO1xuXG4vKipcbiAqIGEgVGVuc29yVmlldyBkb2VzIG5vdCBvd24gdGhlIGRhdGEuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGVuc29yVmlldyB7XG4gIHJlYWRvbmx5IGRhdGE6IG51bWJlcjtcbiAgcmVhZG9ubHkgZGF0YVR5cGU6IG51bWJlcjtcbiAgcmVhZG9ubHkgZGltczogcmVhZG9ubHkgbnVtYmVyW107XG5cbiAgLyoqXG4gICAqIGdldCBhIEZsb2F0MTZBcnJheSBkYXRhIHZpZXcgb2YgdGhlIHRlbnNvciBkYXRhLiB0ZW5zb3IgZGF0YSBtdXN0IGJlIG9uIENQVS5cbiAgICovXG4gIGdldFVpbnQxNkFycmF5KCk6IFVpbnQxNkFycmF5O1xuXG4gIC8qKlxuICAgKiBnZXQgYSBGbG9hdDMyQXJyYXkgZGF0YSB2aWV3IG9mIHRoZSB0ZW5zb3IgZGF0YS4gdGVuc29yIGRhdGEgbXVzdCBiZSBvbiBDUFUuXG4gICAqL1xuICBnZXRGbG9hdDMyQXJyYXkoKTogRmxvYXQzMkFycmF5O1xuXG4gIC8qKlxuICAgKiBnZXQgYSBCaWdJbnQ2NEFycmF5IGRhdGEgdmlldyBvZiB0aGUgdGVuc29yIGRhdGEuIHRlbnNvciBkYXRhIG11c3QgYmUgb24gQ1BVLlxuICAgKi9cbiAgZ2V0QmlnSW50NjRBcnJheSgpOiBCaWdJbnQ2NEFycmF5O1xuXG4gIC8qKlxuICAgKiBnZXQgYSBJbnQzMkFycmF5IGRhdGEgdmlldyBvZiB0aGUgdGVuc29yIGRhdGEuIHRlbnNvciBkYXRhIG11c3QgYmUgb24gQ1BVLlxuICAgKi9cbiAgZ2V0SW50MzJBcnJheSgpOiBJbnQzMkFycmF5O1xuXG4gIC8qKlxuICAgKiBnZXQgYSBVaW50MTZBcnJheSBkYXRhIHZpZXcgb2YgdGhlIHRlbnNvciBkYXRhLiB0ZW5zb3IgZGF0YSBtdXN0IGJlIG9uIENQVS5cbiAgICovXG4gIGdldFVpbnQxNkFycmF5KCk6IFVpbnQxNkFycmF5O1xuXG4gIC8qKlxuICAgKiBjcmVhdGUgYSBuZXcgdGVuc29yIHZpZXcgd2l0aCB0aGUgc2FtZSBkYXRhIGJ1dCBkaWZmZXJlbnQgZGltZW5zaW9ucy5cbiAgICovXG4gIHJlc2hhcGUobmV3RGltczogcmVhZG9ubHkgbnVtYmVyW10pOiBUZW5zb3JWaWV3O1xufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi90ZW5zb3Itdmlldyc7XG5cbmltcG9ydCB7IFNoYWRlckhlbHBlciB9IGZyb20gJy4vb3BzL2NvbW1vbic7XG5cbmV4cG9ydCB0eXBlIFNlc3Npb25TdGF0ZSA9ICdkZWZhdWx0JyB8ICdjYXB0dXJpbmcnIHwgJ3JlcGxheWluZyc7XG5cbmV4cG9ydCBlbnVtIEdwdURhdGFUeXBlIHtcbiAgZGVmYXVsdCA9IDAsXG4gIHVwbG9hZCA9IDEsXG4gIHByb2ZpbGUgPSAyLFxufVxuZXhwb3J0IHR5cGUgR3B1RGF0YUlkID0gbnVtYmVyO1xuXG5leHBvcnQgdHlwZSBHcHVBcmNoaXRlY3R1cmUgPSAnYW1wZXJlJztcbmV4cG9ydCB0eXBlIEdwdVZlbmRvciA9ICdhbWQnIHwgJ2ludGVsJyB8ICdudmlkaWEnO1xuZXhwb3J0IGludGVyZmFjZSBBZGFwdGVySW5mbyB7XG4gIGlzQXJjaGl0ZWN0dXJlOiAoYXJjaGl0ZWN0dXJlOiBHcHVBcmNoaXRlY3R1cmUpID0+IGJvb2xlYW47XG4gIGlzVmVuZG9yOiAodmVuZG9yOiBHcHVWZW5kb3IpID0+IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3B1RGF0YSB7XG4gIHR5cGU6IEdwdURhdGFUeXBlO1xuICBpZDogR3B1RGF0YUlkO1xuICBidWZmZXI6IEdQVUJ1ZmZlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JJbmZvIHtcbiAgZGltczogcmVhZG9ubHkgbnVtYmVyW107XG4gIGRhdGFUeXBlOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvZ3JhbVVuaWZvcm0ge1xuICB0eXBlOiBEYXRhVHlwZTtcbiAgZGF0YTogbnVtYmVyIHwgcmVhZG9ubHkgbnVtYmVyW107XG59XG5cbmV4cG9ydCB0eXBlIFByb2dyYW1Vbmlmb3JtVmFyaWFibGVJbmZvID0gW3R5cGU6IERhdGFUeXBlLCBsZW5ndGg6IG51bWJlcl07XG5cbi8qKlxuICogUmVwcmVzZW50IHRoZSBkZXBlbmRlbmN5IG9mIGEgcHJvZ3JhbSBvbiBhIHNwZWNpZmljIGlucHV0IHRlbnNvci5cbiAqXG4gKiAtICdub25lJzogdGhlIHNoYWRlci91bmlmb3JtIGRvZXMgbm90IGRlcGVuZCBvbiB0aGlzIGlucHV0J3MgaW5mb1xuICogLSAndHlwZSc6IHRoZSBzaGFkZXIvdW5pZm9ybSBkZXBlbmRzIG9uIGRhdGEgdHlwZSBvZiB0aGlzIGlucHV0XG4gKiAtICdyYW5rJzogdGhlIHNoYWRlci91bmlmb3JtIGRlcGVuZHMgb24gZGF0YSB0eXBlIGFuZCB0aGUgcmFuayBvZiB0aGlzIGlucHV0XG4gKiAtICdkaW1zJzogdGhlIHNoYWRlci91bmlmb3JtIGRlcGVuZHMgb24gZGF0YSB0eXBlIGFuZCB0aGUgZGltcyBvZiB0aGlzIGlucHV0XG4gKiAtICdkYXRhJzogdGhlIHNoYWRlci91bmlmb3JtIGRlcGVuZHMgb24gZGF0YSB0eXBlLCB0aGUgZGltcyBhbmQgdGhlIGRhdGEgb2YgdGhpcyBpbnB1dFxuICovXG5leHBvcnQgdHlwZSBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSA9ICdub25lJyB8ICd0eXBlJyB8ICdyYW5rJyB8ICdkaW1zJyB8ICdkYXRhJztcblxuLyoqXG4gKiBSZXByZXNlbnQgaW5mb3JtYXRpb24gYWJvdXQgYSBwcm9ncmFtJ3MgY2FjaGUgZm9yIHNoYWRlci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcm9ncmFtU2hhZGVyQ2FjaGVJbmZvIHtcbiAgLyoqXG4gICAqIGFuIG9wdGlvbmFsIHN0cmluZyBhcyBhIGNhY2hlIGhpbnQgaW4gdGhlIGFydGlmYWN0IGNhY2hlLiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBjYWNoZSBoaW50IHdpbGwgYmUgZW1wdHkuXG4gICAqXG4gICAqIFRoaXMgaGludCBzdHJpbmcgc2hvdWxkIG9ubHkgY29udGFpbnMgaW5pdGlhbGl6aW5nLXRpbWUgaW5mb3JtYXRpb24sIHN1Y2ggYXMgdGhlIGF0dHJpYnV0ZXMgb3IgYW55IGluZm9ybWF0aW9uIG9mXG4gICAqIGluaXRpYWxpemVycy4gSXQgc2hvdWxkIE5PVCBjb250YWluIGFueSBydW50aW1lIGluZm9ybWF0aW9uLCBzdWNoIGFzIHRoZSBzaGFwZSBvZiBpbnB1dHMuXG4gICAqL1xuICBoaW50Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBhbiBvcHRpb25hbCBsaXN0IG9mIGRlcGVuZGVuY2llcyBvZiB0aGUgcHJvZ3JhbSBvbiB0aGUgaW5wdXQgdGVuc29ycy4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgcHJvZ3JhbSBkZXBlbmRzXG4gICAqIG9uICdkaW1zJyBvZiBhbGwgaW5wdXRzLlxuICAgKi9cbiAgaW5wdXREZXBlbmRlbmNpZXM/OiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudCBpbmZvcm1hdGlvbiBhYm91dCBhIHByb2dyYW0ncyBjYWNoZSBmb3IgdW5pZm9ybS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcm9ncmFtVW5pZm9ybUNhY2hlSW5mbyB7XG4gIC8qKlxuICAgKiBhbiBvcHRpb25hbCBzdHJpbmcgYXMgYSBjYWNoZSBoaW50IGluIHRoZSB1bmlmb3JtIGNhY2hlLiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBjYWNoZSBoaW50IHdpbGwgYmUgZW1wdHkuXG4gICAqXG4gICAqIFRoaXMgaGludCBzdHJpbmcgc2hvdWxkIG9ubHkgY29udGFpbnMgcnVudGltZSBpbmZvcm1hdGlvbiwgc3VjaCBhcyB0aGUgc2hhcGUgb2YgaW5wdXRzLlxuICAgKi9cbiAgaGludD86IHN0cmluZztcblxuICAvKipcbiAgICogYW4gb3B0aW9uYWwgbGlzdCBvZiBkZXBlbmRlbmNpZXMgb2YgdGhlIHByb2dyYW0gb24gdGhlIGlucHV0IHRlbnNvcnMuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCwgdGhlIHByb2dyYW0gZGVwZW5kc1xuICAgKiBvbiAnbm9uZScgb2YgYWxsIGlucHV0cy5cbiAgICovXG4gIGlucHV0RGVwZW5kZW5jaWVzPzogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXTtcbn1cblxuLyoqXG4gKiBBIHNldCBvZiBkYXRhIHRoYXQgcmVwcmVzZW50IGEgc2hhZGVyIHByb2dyYW1cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcm9ncmFtSW5mbyB7XG4gIC8qKlxuICAgKiB0aGUgbmFtZSBvZiB0aGUgcHJvZ3JhbS4gdXNlZCBmb3IgZGVidWdnaW5nIGFuZCBwcm9maWxpbmdcbiAgICovXG4gIG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogYW4gb3B0aW9uYWwgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGNhY2hlIGluZm9ybWF0aW9uIG9mIHRoZSBwcm9ncmFtIHNoYWRlci5cbiAgICpcbiAgICogSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgaGludCBpcyBlbXB0eSBhbmQgaW5wdXREZXBlbmRlbmNpZXMgYXJlIFsnZGltcyddIGZvciBhbGwgaW5wdXRzLlxuICAgKi9cbiAgc2hhZGVyQ2FjaGU/OiBQcm9ncmFtU2hhZGVyQ2FjaGVJbmZvO1xuXG4gIC8qKlxuICAgKiB0aGUgc2hhZGVyJ3MgcHJvY2Vzc2luZyBzb3VyY2UgY29kZS5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuIHNoYWRlciBjYWNoZSBtaXNzZWQuXG4gICAqL1xuICBnZXRTaGFkZXJTb3VyY2U6IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRvIGdldCBydW4gZGF0YSByZXF1aXJlZCB0byBydW4gdGhlIHByb2dyYW0uXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgZXZlcnkgdGltZSB0aGUgcHJvZ3JhbSBpcyBleGVjdXRlZC4gU2hvdWxkIGtlZXAgdGhpcyBmdW5jdGlvbiBhcyBzaW1wbGUgYXMgcG9zc2libGUuXG4gICAqL1xuICBnZXRSdW5EYXRhOiAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pID0+IHtcbiAgICBvdXRwdXRzOiByZWFkb25seSBUZW5zb3JJbmZvW107XG4gICAgZGlzcGF0Y2hHcm91cDogeyB4OiBudW1iZXI7IHk/OiBudW1iZXI7IHo/OiBudW1iZXIgfTtcbiAgICBwcm9ncmFtVW5pZm9ybXM/OiByZWFkb25seSBQcm9ncmFtVW5pZm9ybVtdO1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFydGlmYWN0IHtcbiAgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvO1xuICBjb21wdXRlUGlwZWxpbmU6IEdQVUNvbXB1dGVQaXBlbGluZTtcbiAgdW5pZm9ybVZhcmlhYmxlc0luZm86IHJlYWRvbmx5IFByb2dyYW1Vbmlmb3JtVmFyaWFibGVJbmZvW10gfCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcHV0ZUNvbnRleHRJbnB1dHNPdXRwdXRzTWFwcGluZyB7XG4gIC8qKlxuICAgKiBzcGVjaWZ5IHRoZSBtYXBwaW5nIHRvIHRoZSBwcm9ncmFtJ3MgaW5wdXRzLiB0aGUgdmFsdWUgY2FuIGJlIGEgbnVtYmVyIG9yIGEgdGVuc29yIHZpZXcuXG4gICAqIC0gaWYgaXQncyBhIG51bWJlciwgaXQncyB0aGUgaW5kZXggb2YgdGhlIGtlcm5lbCdzIGlucHV0XG4gICAqIC0gaWYgaXQncyBhIHRlbnNvciB2aWV3LCBpdCdzIGFuIGV4aXN0aW5nIHRlbnNvciB2aWV3IHRoYXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbnB1dFxuICAgKlxuICAgKiBpZiBpbnB1dHMgaXMgbm90IHNwZWNpZmllZCwgdGhlIG1hcHBpbmcgd2lsbCBiZSB0aGUga2VybmVsJ3MgaW5wdXRzIGluIG9yZGVyLlxuICAgKi9cbiAgcmVhZG9ubHkgaW5wdXRzPzogUmVhZG9ubHlBcnJheTxUZW5zb3JWaWV3IHwgbnVtYmVyPjtcbiAgLyoqXG4gICAqIHNwZWNpZnkgdGhlIG1hcHBpbmcgdG8gdGhlIHByb2dyYW0ncyBvdXRwdXRzLiB0aGUgdmFsdWUgbXVzdCBiZSBhIG51bWJlci5cbiAgICogLSBpZiBpdCdzIGEgbm9uLW5lZ2F0aXZlIG51bWJlciwgaXQncyB0aGUgaW5kZXggb2YgdGhlIGtlcm5lbCdzIG91dHB1dFxuICAgKiAtIGlmIGl0J3MgLTEsIGl0J3MgYW4gb3V0cHV0IHRoYXQgd2lsbCBiZSBjcmVhdGVkIGFzIGEgdGVtcG9yYXJ5IHZhbHVlLiB0aGlzIHZhbHVlIHdpbGwgYmUgcmVsZWFzZWQgYWZ0ZXJcbiAgICogdGhlIGtlcm5lbCBpcyBleGVjdXRlZC5cbiAgICogLSBpZiBpdCdzIC0yLCBpdCdzIGFuIG91dHB1dCB0aGF0IHdpbGwgYmUgY3JlYXRlZCBhcyBhIHBlcnNpc3RlbnQgdmFsdWUuIHRoaXMgdmFsdWUgd2lsbCBiZSByZWxlYXNlZCB3aGVuIHRoZVxuICAgKiBrZXJuZWwgaXMgcmVsZWFzZWQuXG4gICAqXG4gICAqIGlmIG91dHB1dHMgaXMgbm90IHNwZWNpZmllZCwgdGhlIG1hcHBpbmcgd2lsbCBiZSB0aGUga2VybmVsJ3Mgb3V0cHV0cyBpbiBvcmRlci5cbiAgICovXG4gIHJlYWRvbmx5IG91dHB1dHM/OiByZWFkb25seSBudW1iZXJbXTtcbn1cblxuLyoqXG4gKiBBIENvbXB1dGVDb250ZXh0IGluc3RhbmNlIGNhcnJpZXMgdGhlIHN0YXRlcyB0aGF0IHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBydW5uaW5nIG9mIGEga2VybmVsLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbXB1dGVDb250ZXh0IHtcbiAgLyoqXG4gICAqIGdwdSBhZGFwdGVyIGluZm9cbiAgICovXG4gIHJlYWRvbmx5IGFkYXB0ZXJJbmZvOiBBZGFwdGVySW5mbztcblxuICAvKipcbiAgICogc3RvcmVzIHRoZSBwb2ludGVyIHRvIE9wS2VybmVsQ29udGV4dFxuICAgKi9cbiAgcmVhZG9ubHkgb3BLZXJuZWxDb250ZXh0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIGEgbGlzdCBvZiBpbnB1dHMsIGVhY2ggaW5wdXQgaXMgYW4gaW5zdGFuY2Ugb2YgVGVuc29yVmlld1xuICAgKi9cbiAgcmVhZG9ubHkgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W107XG5cbiAgLyoqXG4gICAqIGEgY3VzdG9tIGRhdGEgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYW55IGRhdGEgdGhhdCBpcyBuZWVkZWQgYnkgdGhlIGtlcm5lbFxuICAgKi9cbiAgcmVhZG9ubHkga2VybmVsQ3VzdG9tRGF0YTogeyBba2V5OiBzdHJpbmddOiB1bmtub3duIH07XG5cbiAgLyoqXG4gICAqIGEgYnVmZmVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gYWNjZXNzIGN1c3RvbSBkYXRhIGNyZWF0ZWQgZWFjaCB0aW1lIHRoZSBrZXJuZWwgaXMgZXhlY3V0ZWRcbiAgICovXG4gIHJlYWRvbmx5IGN1c3RvbURhdGFCdWZmZXI6IFVpbnQ4QXJyYXk7XG5cbiAgLyoqXG4gICAqIGEgbnVtYmVyIG9mIG91dHB1dHMgZm9yIHRoZSBub2RlXG4gICAqL1xuICByZWFkb25seSBvdXRwdXRDb3VudDogbnVtYmVyO1xuXG4gIGNvbXB1dGUocHJvZ3JhbTogUHJvZ3JhbUluZm8sIGlucHV0c091dHB1dHNNYXBwaW5nPzogQ29tcHV0ZUNvbnRleHRJbnB1dHNPdXRwdXRzTWFwcGluZyk6IFRlbnNvclZpZXdbXTtcbiAgb3V0cHV0KGluZGV4OiBudW1iZXIsIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogbnVtYmVyO1xuICBnZXRNYXhDb21wdXRlV29ya2dyb3VwU2l6ZXMoKTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICBnZXRNYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZXNpemUoKTogbnVtYmVyO1xufVxuXG5leHBvcnQgdHlwZSBUaW1lc3RhbXBRdWVyeSA9ICdub25lJyB8ICdpbnNpZGUtcGFzc2VzJyB8ICdhdC1wYXNzZXMnO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBXZWJHcHVCYWNrZW5kIH0gZnJvbSAnLi4vYmFja2VuZC13ZWJncHUnO1xuaW1wb3J0IHsgTE9HX0RFQlVHIH0gZnJvbSAnLi4vbG9nJztcblxuaW1wb3J0IHsgR3B1RGF0YSwgR3B1RGF0YUlkLCBHcHVEYXRhVHlwZSB9IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIG1hbmFnZXMgR3B1RGF0YUlkIC0+IEdwdUJ1ZmZlclxuICovXG5leHBvcnQgaW50ZXJmYWNlIEdwdURhdGFNYW5hZ2VyIHtcbiAgLyoqXG4gICAqIGNvcHkgZGF0YSBmcm9tIENQVSB0byBHUFUuXG4gICAqL1xuICB1cGxvYWQoaWQ6IEdwdURhdGFJZCwgZGF0YTogVWludDhBcnJheSk6IHZvaWQ7XG4gIC8qKlxuICAgKiBjb3B5IGRhdGEgZnJvbSBHUFUgdG8gR1BVLlxuICAgKi9cbiAgbWVtY3B5KHNvdXJjZUlkOiBHcHVEYXRhSWQsIGRlc3RpbmF0aW9uSWQ6IEdwdURhdGFJZCk6IHZvaWQ7XG4gIC8qKlxuICAgKiBjcmVhdGUgbmV3IGRhdGEgb24gR1BVLlxuICAgKi9cbiAgY3JlYXRlKHNpemU6IG51bWJlciwgdXNhZ2U/OiBudW1iZXIpOiBHcHVEYXRhO1xuICAvKipcbiAgICogZ2V0IEdQVSBkYXRhIGJ5IElELlxuICAgKi9cbiAgZ2V0KGlkOiBHcHVEYXRhSWQpOiBHcHVEYXRhIHwgdW5kZWZpbmVkO1xuICAvKipcbiAgICogcmVsZWFzZSB0aGUgZGF0YSBvbiBHUFUgYnkgSUQuXG4gICAqXG4gICAqIEByZXR1cm4gc2l6ZSBvZiB0aGUgZGF0YSByZWxlYXNlZFxuICAgKi9cbiAgcmVsZWFzZShpZDogR3B1RGF0YUlkKTogbnVtYmVyO1xuICAvKipcbiAgICogY29weSBkYXRhIGZyb20gR1BVIHRvIENQVS5cbiAgICovXG4gIGRvd25sb2FkKGlkOiBHcHVEYXRhSWQsIGdldFRhcmdldEJ1ZmZlcjogKCkgPT4gVWludDhBcnJheSk6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIHJlZnJlc2ggdGhlIGJ1ZmZlcnMgdGhhdCBtYXJrZWQgZm9yIHJlbGVhc2UuXG4gICAqXG4gICAqIHdoZW4gcmVsZWFzZSgpIGlzIGNhbGxlZCwgdGhlIGJ1ZmZlciBpcyBub3QgcmVsZWFzZWQgaW1tZWRpYXRlbHkuIHRoaXMgaXMgYmVjYXVzZSB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBjb21tYW5kc1xuICAgKiB0byBiZSBzdWJtaXR0ZWQgdG8gdGhlIEdQVS4gdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGNvbW1hbmRzIGFyZSBzdWJtaXR0ZWQgc28gdGhhdCB0aGUgYnVmZmVycyBjYW4gYmVcbiAgICogYWN0dWFsbHkgcmVsZWFzZWQuXG4gICAqL1xuICByZWZyZXNoUGVuZGluZ0J1ZmZlcnMoKTogdm9pZDtcblxuICAvKipcbiAgICogcmVnaXN0ZXIgYW4gZXh0ZXJuYWwgYnVmZmVyIGZvciBJTyBCaW5kaW5nLiBJZiB0aGUgYnVmZmVyIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCwgcmV0dXJuIHRoZSBleGlzdGluZyBHUFUgZGF0YSBJRC5cbiAgICpcbiAgICogR1BVIGRhdGEgbWFuYWdlciBvbmx5IG1hbmFnZXMgYSBtYXBwaW5nIGJldHdlZW4gdGhlIGJ1ZmZlciBhbmQgdGhlIEdQVSBkYXRhIElELiBJdCB3aWxsIG5vdCBtYW5hZ2UgdGhlIGxpZmVjeWNsZSBvZlxuICAgKiB0aGUgZXh0ZXJuYWwgYnVmZmVyLlxuICAgKi9cbiAgcmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihidWZmZXI6IEdQVUJ1ZmZlciwgb3JpZ2luYWxTaXplOiBudW1iZXIsIHByZXZpb3VzQnVmZmVyPzogR1BVQnVmZmVyKTogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiB1bnJlZ2lzdGVyIGFuIGV4dGVybmFsIGJ1ZmZlciBmb3IgSU8gQmluZGluZy5cbiAgICovXG4gIHVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihidWZmZXI6IEdQVUJ1ZmZlcik6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIGRlc3Ryb3kgYWxsIGdwdSBidWZmZXJzLlxuICAgKi9cbiAgZGlzcG9zZSgpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiByZWxlYXNlIHNlc3Npb24gcmVsYXRlZCBkYXRhLlxuICAgKiBAcGFyYW0gc2Vzc2lvbklkIC0gc3BlY2lmeSB0aGUgc2Vzc2lvbiBJRC5cbiAgICovXG4gIG9uUmVsZWFzZVNlc3Npb24oc2Vzc2lvbklkOiBudW1iZXIpOiB2b2lkO1xufVxuXG5pbnRlcmZhY2UgU3RvcmFnZUNhY2hlVmFsdWUge1xuICBncHVEYXRhOiBHcHVEYXRhO1xuICBvcmlnaW5hbFNpemU6IG51bWJlcjtcbn1cblxuY29uc3QgYnVja2V0RnJlZWxpc3Q6IE1hcDxudW1iZXIsIG51bWJlcj4gPSBuZXcgTWFwKFtcbiAgWzY0LCAyNTBdLFxuICBbMTI4LCAyMDBdLFxuICBbMjU2LCAyMDBdLFxuICBbNTEyLCAyMDBdLFxuICBbMjA0OCwgMjMwXSxcbiAgWzQwOTYsIDIwMF0sXG4gIFs4MTkyLCA1MF0sXG4gIFsxNjM4NCwgNTBdLFxuICBbMzI3NjgsIDUwXSxcbiAgWzY1NTM2LCA1MF0sXG4gIFsxMzEwNzIsIDUwXSxcbiAgWzI2MjE0NCwgNTBdLFxuICBbNTI0Mjg4LCA1MF0sXG4gIFsxMDQ4NTc2LCA1MF0sXG4gIFsyMDk3MTUyLCAzMF0sXG4gIFs0MTk0MzA0LCAyMF0sXG4gIFs4Mzg4NjA4LCAxMF0sXG4gIFsxMjU4MjkxMiwgMTBdLFxuICBbMTY3NzcyMTYsIDEwXSxcbiAgWzI2MjE0NDAwLCAxNV0sXG4gIFszMzU1NDQzMiwgMjJdLFxuICBbNDQyMzY4MDAsIDJdLFxuICBbNTg5ODI0MDAsIDZdLFxuICAvLyB3ZSBkb24ndCB3YW50IHRvIGNhY2hlIHRoZSBidWNrZXQgc2l6ZXMgYmVsb3cgYnV0IG5vdCBjYWNoaW5nIHRoZW1cbiAgLy8gcmVzdWx0cyBpbiBzb21lIG1ham9yIHBlcmZvcm1hbmNlIGhpdHMgZm9yIG1vZGVscyBsaWtlIHNkLXR1cmJvLlxuICBbNjcxMDg4NjQsIDZdLFxuICBbMTM0MjE3NzI4LCA2XSxcbiAgWzE2Nzc3MjE2MCwgNl0sXG5dKTtcblxuY29uc3QgYnVja2V0QXJyOiBudW1iZXJbXSA9IFtdO1xuXG4vKipcbiAqIG5vcm1hbGl6ZSB0aGUgYnVmZmVyIHNpemUgc28gdGhhdCBpdCBmaXRzIHRoZSAxMjgtYml0cyAoMTYgYnl0ZXMpIGFsaWdubWVudC5cbiAqL1xuY29uc3QgY2FsY05vcm1hbGl6ZWRCdWZmZXJTaXplID0gKHNpemU6IG51bWJlcikgPT4gTWF0aC5jZWlsKHNpemUgLyAxNikgKiAxNjtcblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIGJ1ZmZlciBzaXplIHNvIHRoYXQgaXQgZml0cyBpbnRvIGJ1Y2tldHMuXG4gKi9cbmNvbnN0IGNhbGNCdWNrZXRCdWZmZXJTaXplID0gKHNpemU6IG51bWJlcikgPT4ge1xuICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBidWNrZXRBcnIubGVuZ3RoOyBpZHgrKykge1xuICAgIGNvbnN0IHNpemVGb3JCdWNrZXQgPSBidWNrZXRBcnJbaWR4XTtcbiAgICBpZiAoc2l6ZSA8PSBzaXplRm9yQnVja2V0KSB7XG4gICAgICByZXR1cm4gc2l6ZUZvckJ1Y2tldDtcbiAgICB9XG4gIH1cbiAgLy8gbm90IGluIGJ1Y2tldCBsaXN0IC0+IGNhbGxlciB3aWxsIG5vdCBjYWNoZSwgcm91bmQgdXAgdG8gMTYuXG4gIHJldHVybiBNYXRoLmNlaWwoc2l6ZSAvIDE2KSAqIDE2O1xufTtcblxubGV0IGd1aWQgPSAxO1xuY29uc3QgY3JlYXRlTmV3R3B1RGF0YUlkID0gKCkgPT4gZ3VpZCsrO1xuXG4vKipcbiAqIGV4cG9ydGVkIHN0YW5kYXJkIGRvd25sb2FkIGZ1bmN0aW9uLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYnkgdGhlIHNlc3Npb24gdG8gZG93bmxvYWQgdGhlIGRhdGEgZnJvbSBHUFUsIGFuZCBhbHNvIGJ5XG4gKiBmYWN0b3J5IHRvIGNyZWF0ZSBHUFUgdGVuc29ycyB3aXRoIHRoZSBjYXBhY2l0eSBvZiBkb3dubG9hZGluZyBkYXRhIGZyb20gR1BVLlxuICpcbiAqIEBwYXJhbSBiYWNrZW5kIC0gdGhlIFdlYkdQVSBiYWNrZW5kXG4gKiBAcGFyYW0gZ3B1QnVmZmVyIC0gdGhlIEdQVSBidWZmZXIgdG8gZG93bmxvYWRcbiAqIEBwYXJhbSBvcmlnaW5hbFNpemUgLSB0aGUgb3JpZ2luYWwgc2l6ZSBvZiB0aGUgZGF0YVxuICogQHBhcmFtIGdldFRhcmdldEJ1ZmZlciAtIG9wdGlvbmFsLiBJZiBwcm92aWRlZCwgdGhlIGRhdGEgd2lsbCBiZSBjb3BpZWQgdG8gdGhlIHRhcmdldCBidWZmZXIuIE90aGVyd2lzZSwgYSBuZXcgYnVmZmVyXG4gKiB3aWxsIGJlIGNyZWF0ZWQgYW5kIHJldHVybmVkLlxuICovXG5leHBvcnQgY29uc3QgZG93bmxvYWRHcHVEYXRhID0gYXN5bmMgKFxuICBiYWNrZW5kOiBXZWJHcHVCYWNrZW5kLFxuICBncHVCdWZmZXI6IEdQVUJ1ZmZlcixcbiAgb3JpZ2luYWxTaXplOiBudW1iZXIsXG4gIGdldFRhcmdldEJ1ZmZlcj86ICgpID0+IFVpbnQ4QXJyYXksXG4pOiBQcm9taXNlPFVpbnQ4QXJyYXk+ID0+IHtcbiAgY29uc3QgYnVmZmVyU2l6ZSA9IGNhbGNOb3JtYWxpemVkQnVmZmVyU2l6ZShvcmlnaW5hbFNpemUpO1xuICBjb25zdCBncHVSZWFkQnVmZmVyID0gYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgeyBzaXplOiBidWZmZXJTaXplLCB1c2FnZTogR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QgfCBHUFVCdWZmZXJVc2FnZS5NQVBfUkVBRCB9LFxuICApO1xuICB0cnkge1xuICAgIGNvbnN0IGNvbW1hbmRFbmNvZGVyID0gYmFja2VuZC5nZXRDb21tYW5kRW5jb2RlcigpO1xuICAgIGJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKTtcbiAgICBjb21tYW5kRW5jb2Rlci5jb3B5QnVmZmVyVG9CdWZmZXIoXG4gICAgICBncHVCdWZmZXIgLyogc291cmNlIGJ1ZmZlciAqLyxcbiAgICAgIDAgLyogc291cmNlIG9mZnNldCAqLyxcbiAgICAgIGdwdVJlYWRCdWZmZXIgLyogZGVzdGluYXRpb24gYnVmZmVyICovLFxuICAgICAgMCAvKiBkZXN0aW5hdGlvbiBvZmZzZXQgKi8sXG4gICAgICBidWZmZXJTaXplIC8qIHNpemUgKi8sXG4gICAgKTtcbiAgICBiYWNrZW5kLmZsdXNoKCk7XG5cbiAgICBhd2FpdCBncHVSZWFkQnVmZmVyLm1hcEFzeW5jKEdQVU1hcE1vZGUuUkVBRCk7XG5cbiAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGdwdVJlYWRCdWZmZXIuZ2V0TWFwcGVkUmFuZ2UoKTtcbiAgICBpZiAoZ2V0VGFyZ2V0QnVmZmVyKSB7XG4gICAgICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBDUFUgYnVmZmVyIHRvIGFjY2VwdCB0aGUgZGF0YSwgbm8gbmVlZCB0byBjbG9uZSB0aGUgQXJyYXlCdWZmZXIuXG4gICAgICBjb25zdCB0YXJnZXRCdWZmZXIgPSBnZXRUYXJnZXRCdWZmZXIoKTtcbiAgICAgIHRhcmdldEJ1ZmZlci5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIsIDAsIG9yaWdpbmFsU2l6ZSkpO1xuICAgICAgcmV0dXJuIHRhcmdldEJ1ZmZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGhlIG1hcHBlZCBBcnJheUJ1ZmZlciB3aWxsIGJlIHJlbGVhc2VkIHdoZW4gdGhlIEdQVSBidWZmZXIgaXMgZGVzdHJveWVkLiBOZWVkIHRvIGNsb25lIHRoZVxuICAgICAgLy8gQXJyYXlCdWZmZXIuXG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIuc2xpY2UoMCwgb3JpZ2luYWxTaXplKSk7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGdwdVJlYWRCdWZmZXIuZGVzdHJveSgpO1xuICB9XG59O1xuXG5jbGFzcyBHcHVEYXRhTWFuYWdlckltcGwgaW1wbGVtZW50cyBHcHVEYXRhTWFuYWdlciB7XG4gIC8vIEdQVSBEYXRhIElEID0+IEdQVSBEYXRhICggc3RvcmFnZSBidWZmZXIgKVxuICBwcml2YXRlIHN0b3JhZ2VDYWNoZTogTWFwPEdwdURhdGFJZCwgU3RvcmFnZUNhY2hlVmFsdWU+O1xuXG4gIC8vIHBlbmRpbmcgYnVmZmVycyBmb3IgdXBsb2FkaW5nICggZGF0YSBpcyB1bm1hcHBlZCApXG4gIHByaXZhdGUgYnVmZmVyc0ZvclVwbG9hZGluZ1BlbmRpbmc6IEdQVUJ1ZmZlcltdO1xuICAvLyBwZW5kaW5nIGJ1ZmZlcnMgZm9yIGNvbXB1dGluZ1xuICBwcml2YXRlIGJ1ZmZlcnNQZW5kaW5nOiBHUFVCdWZmZXJbXTtcblxuICAvLyBUaGUgcmV1c2FibGUgc3RvcmFnZSBidWZmZXJzIGZvciBjb21wdXRpbmcuXG4gIHByaXZhdGUgZnJlZUJ1ZmZlcnM6IE1hcDxudW1iZXIsIEdQVUJ1ZmZlcltdPjtcbiAgLy8gVGhlIHJldXNhYmxlIHVuaWZvcm0gYnVmZmVyc1xuICBwcml2YXRlIGZyZWVVbmlmb3JtQnVmZmVyczogTWFwPG51bWJlciwgR1BVQnVmZmVyW10+O1xuXG4gIC8vIFRoZSBleHRlcm5hbCBidWZmZXJzIHJlZ2lzdGVyZWQgdXNlcnMgZm9yIElPIEJpbmRpbmcuXG4gIHByaXZhdGUgZXh0ZXJuYWxCdWZmZXJzOiBNYXA8R1BVQnVmZmVyLCBHcHVEYXRhSWQ+O1xuXG4gIC8vIFRoZSBwZW5kaW5nQnVmZmVycyBmb3IgY2FwdHVyZSBncmFwaC5cbiAgLy8gYSBTZXNzaW9uSUQgLT4gR1BVQnVmZmVyW10gbWFwcGluZy5cbiAgcHJpdmF0ZSBjYXB0dXJlZFBlbmRpbmdCdWZmZXJzOiBNYXA8bnVtYmVyLCBHUFVCdWZmZXJbXT47XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBiYWNrZW5kOiBXZWJHcHVCYWNrZW5kKSB7XG4gICAgdGhpcy5zdG9yYWdlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5mcmVlQnVmZmVycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmZyZWVVbmlmb3JtQnVmZmVycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmJ1ZmZlcnNGb3JVcGxvYWRpbmdQZW5kaW5nID0gW107XG4gICAgdGhpcy5idWZmZXJzUGVuZGluZyA9IFtdO1xuICAgIHRoaXMuZXh0ZXJuYWxCdWZmZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycyA9IG5ldyBNYXAoKTtcblxuICAgIGZvciAoY29uc3QgW2tleV0gb2YgYnVja2V0RnJlZWxpc3QpIHtcbiAgICAgIGJ1Y2tldEFyci5wdXNoKGtleSk7XG4gICAgICB0aGlzLmZyZWVCdWZmZXJzLnNldChrZXksIFtdKTtcbiAgICAgIHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLnNldChrZXksIFtdKTtcbiAgICB9XG4gIH1cblxuICB1cGxvYWQoaWQ6IEdwdURhdGFJZCwgZGF0YTogVWludDhBcnJheSk6IHZvaWQge1xuICAgIGNvbnN0IHNyY0FycmF5QnVmZmVyID0gZGF0YS5idWZmZXI7XG4gICAgY29uc3Qgc3JjT2Zmc2V0ID0gZGF0YS5ieXRlT2Zmc2V0O1xuICAgIGNvbnN0IHNyY0xlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCBzaXplID0gY2FsY05vcm1hbGl6ZWRCdWZmZXJTaXplKHNyY0xlbmd0aCk7XG5cbiAgICAvLyBnZXQgZGVzdGluYXRpb24gZ3B1IGJ1ZmZlclxuICAgIGNvbnN0IGdwdURhdGFDYWNoZSA9IHRoaXMuc3RvcmFnZUNhY2hlLmdldChpZCk7XG4gICAgaWYgKCFncHVEYXRhQ2FjaGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ3B1IGRhdGEgZm9yIHVwbG9hZGluZyBkb2VzIG5vdCBleGlzdCcpO1xuICAgIH1cbiAgICBpZiAoZ3B1RGF0YUNhY2hlLm9yaWdpbmFsU2l6ZSAhPT0gc3JjTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGluY29uc2lzdGVudCBkYXRhIHNpemUuIGdwdSBkYXRhIHNpemU9JHtncHVEYXRhQ2FjaGUub3JpZ2luYWxTaXplfSwgZGF0YSBzaXplPSR7c3JjTGVuZ3RofWApO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBncHUgYnVmZmVyXG4gICAgY29uc3QgZ3B1QnVmZmVyRm9yVXBsb2FkaW5nID0gdGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgeyBtYXBwZWRBdENyZWF0aW9uOiB0cnVlLCBzaXplLCB1c2FnZTogR1BVQnVmZmVyVXNhZ2UuTUFQX1dSSVRFIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkMgfSxcbiAgICApO1xuXG4gICAgLy8gY29weSAodXBsb2FkKSBkYXRhXG4gICAgY29uc3QgYXJyYXlCdWZmZXIgPSBncHVCdWZmZXJGb3JVcGxvYWRpbmcuZ2V0TWFwcGVkUmFuZ2UoKTtcbiAgICBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikuc2V0KG5ldyBVaW50OEFycmF5KHNyY0FycmF5QnVmZmVyLCBzcmNPZmZzZXQsIHNyY0xlbmd0aCkpO1xuICAgIGdwdUJ1ZmZlckZvclVwbG9hZGluZy51bm1hcCgpO1xuXG4gICAgLy8gR1BVIGNvcHlcbiAgICBjb25zdCBjb21tYW5kRW5jb2RlciA9IHRoaXMuYmFja2VuZC5nZXRDb21tYW5kRW5jb2RlcigpO1xuICAgIHRoaXMuYmFja2VuZC5lbmRDb21wdXRlUGFzcygpO1xuICAgIGNvbW1hbmRFbmNvZGVyLmNvcHlCdWZmZXJUb0J1ZmZlcihncHVCdWZmZXJGb3JVcGxvYWRpbmcsIDAsIGdwdURhdGFDYWNoZS5ncHVEYXRhLmJ1ZmZlciwgMCwgc2l6ZSk7XG5cbiAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIudXBsb2FkKGlkPSR7aWR9KWApO1xuXG4gICAgdGhpcy5idWZmZXJzRm9yVXBsb2FkaW5nUGVuZGluZy5wdXNoKGdwdUJ1ZmZlckZvclVwbG9hZGluZyk7XG4gIH1cblxuICBtZW1jcHkoc291cmNlSWQ6IEdwdURhdGFJZCwgZGVzdGluYXRpb25JZDogR3B1RGF0YUlkKTogdm9pZCB7XG4gICAgLy8gZ2V0IHNvdXJjZSBncHUgYnVmZmVyXG4gICAgY29uc3Qgc291cmNlR3B1RGF0YUNhY2hlID0gdGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHNvdXJjZUlkKTtcbiAgICBpZiAoIXNvdXJjZUdwdURhdGFDYWNoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2UgZ3B1IGRhdGEgZm9yIG1lbWNweSBkb2VzIG5vdCBleGlzdCcpO1xuICAgIH1cbiAgICAvLyBnZXQgZGVzdGluYXRpb24gZ3B1IGJ1ZmZlclxuICAgIGNvbnN0IGRlc3RpbmF0aW9uR3B1RGF0YUNhY2hlID0gdGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KGRlc3RpbmF0aW9uSWQpO1xuICAgIGlmICghZGVzdGluYXRpb25HcHVEYXRhQ2FjaGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZGVzdGluYXRpb24gZ3B1IGRhdGEgZm9yIG1lbWNweSBkb2VzIG5vdCBleGlzdCcpO1xuICAgIH1cbiAgICBpZiAoc291cmNlR3B1RGF0YUNhY2hlLm9yaWdpbmFsU2l6ZSAhPT0gZGVzdGluYXRpb25HcHVEYXRhQ2FjaGUub3JpZ2luYWxTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luY29uc2lzdGVudCBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGdwdSBkYXRhIHNpemUnKTtcbiAgICB9XG5cbiAgICBjb25zdCBzaXplID0gY2FsY05vcm1hbGl6ZWRCdWZmZXJTaXplKHNvdXJjZUdwdURhdGFDYWNoZS5vcmlnaW5hbFNpemUpO1xuXG4gICAgLy8gR1BVIGNvcHlcbiAgICBjb25zdCBjb21tYW5kRW5jb2RlciA9IHRoaXMuYmFja2VuZC5nZXRDb21tYW5kRW5jb2RlcigpO1xuICAgIHRoaXMuYmFja2VuZC5lbmRDb21wdXRlUGFzcygpO1xuICAgIGNvbW1hbmRFbmNvZGVyLmNvcHlCdWZmZXJUb0J1ZmZlcihcbiAgICAgIHNvdXJjZUdwdURhdGFDYWNoZS5ncHVEYXRhLmJ1ZmZlcixcbiAgICAgIDAsXG4gICAgICBkZXN0aW5hdGlvbkdwdURhdGFDYWNoZS5ncHVEYXRhLmJ1ZmZlcixcbiAgICAgIDAsXG4gICAgICBzaXplLFxuICAgICk7XG4gIH1cblxuICByZWdpc3RlckV4dGVybmFsQnVmZmVyKGJ1ZmZlcjogR1BVQnVmZmVyLCBvcmlnaW5hbFNpemU6IG51bWJlciwgcHJldmlvdXNCdWZmZXI/OiBHUFVCdWZmZXIpOiBudW1iZXIge1xuICAgIGxldCBpZDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGlmIChwcmV2aW91c0J1ZmZlcikge1xuICAgICAgaWQgPSB0aGlzLmV4dGVybmFsQnVmZmVycy5nZXQocHJldmlvdXNCdWZmZXIpO1xuICAgICAgaWYgKGlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcmV2aW91cyBidWZmZXIgaXMgbm90IHJlZ2lzdGVyZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChidWZmZXIgPT09IHByZXZpb3VzQnVmZmVyKSB7XG4gICAgICAgIExPR19ERUJVRyhcbiAgICAgICAgICAndmVyYm9zZScsXG4gICAgICAgICAgKCkgPT5cbiAgICAgICAgICAgIGBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHNpemU9JHtvcmlnaW5hbFNpemV9KSA9PiBpZD0ke1xuICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgfSwgYnVmZmVyIGlzIHRoZSBzYW1lLCBza2lwLmAsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5iYWNrZW5kLmNhcHR1cmVkQ29tbWFuZExpc3QuaGFzKHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkISkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWdpc3RlcmluZyBhIGRpZmZlcmVudCBleHRlcm5hbCBidWZmZXIgdW5kZXIgZ3JhcGggY2FwdHVyZSBtb2RlIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LlxuICAgICAgICAgICAgIFBsZWFzZSB1c2UgdGhlIHByZXZpb3VzIGV4dGVybmFsIGJ1ZmZlciFgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXh0ZXJuYWxCdWZmZXJzLmRlbGV0ZShwcmV2aW91c0J1ZmZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlkID0gY3JlYXRlTmV3R3B1RGF0YUlkKCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdG9yYWdlQ2FjaGUuc2V0KGlkLCB7IGdwdURhdGE6IHsgaWQsIHR5cGU6IEdwdURhdGFUeXBlLmRlZmF1bHQsIGJ1ZmZlciB9LCBvcmlnaW5hbFNpemUgfSk7XG4gICAgdGhpcy5leHRlcm5hbEJ1ZmZlcnMuc2V0KGJ1ZmZlciwgaWQpO1xuICAgIExPR19ERUJVRyhcbiAgICAgICd2ZXJib3NlJyxcbiAgICAgICgpID0+IGBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHNpemU9JHtvcmlnaW5hbFNpemV9KSA9PiBpZD0ke2lkfSwgcmVnaXN0ZXJlZC5gLFxuICAgICk7XG4gICAgcmV0dXJuIGlkO1xuICB9XG5cbiAgdW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKGJ1ZmZlcjogR1BVQnVmZmVyKTogdm9pZCB7XG4gICAgY29uc3QgaWQgPSB0aGlzLmV4dGVybmFsQnVmZmVycy5nZXQoYnVmZmVyKTtcbiAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zdG9yYWdlQ2FjaGUuZGVsZXRlKGlkKTtcbiAgICAgIHRoaXMuZXh0ZXJuYWxCdWZmZXJzLmRlbGV0ZShidWZmZXIpO1xuICAgICAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcigpID0+IGlkPSR7aWR9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgY3JlYXRlKHNpemU6IG51bWJlciwgdXNhZ2UgPSBHUFVCdWZmZXJVc2FnZS5TVE9SQUdFIHwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkMgfCBHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCk6IEdwdURhdGEge1xuICAgIGNvbnN0IGJ1ZmZlclNpemUgPSBjYWxjQnVja2V0QnVmZmVyU2l6ZShzaXplKTtcblxuICAgIGxldCBncHVCdWZmZXI7XG4gICAgLy8gQ3VycmVudGx5LCBvbmx5IHN0b3JhZ2UgYnVmZmVycyBhcmUgcmV1c2VkLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgY29uc3QgaXNTdG9yYWdlID0gKHVzYWdlICYgR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSkgPT09IEdQVUJ1ZmZlclVzYWdlLlNUT1JBR0U7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICBjb25zdCBpc1VuaWZvcm0gPSAodXNhZ2UgJiBHUFVCdWZmZXJVc2FnZS5VTklGT1JNKSA9PT0gR1BVQnVmZmVyVXNhZ2UuVU5JRk9STTtcbiAgICBpZiAoaXNTdG9yYWdlIHx8IGlzVW5pZm9ybSkge1xuICAgICAgY29uc3QgZnJlZUJ1ZmZlcnMgPSBpc1N0b3JhZ2UgPyB0aGlzLmZyZWVCdWZmZXJzIDogdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnM7XG4gICAgICBjb25zdCBidWZmZXJzID0gZnJlZUJ1ZmZlcnMuZ2V0KGJ1ZmZlclNpemUpO1xuICAgICAgaWYgKCFidWZmZXJzKSB7XG4gICAgICAgIC8vIG5vIHN1Y2ggYnVja2V0L2ZyZWVsaXN0IC0gY3JlYXRlIGdwdSBidWZmZXJcbiAgICAgICAgZ3B1QnVmZmVyID0gdGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoeyBzaXplOiBidWZmZXJTaXplLCB1c2FnZSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChidWZmZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBpbiBmcmVlbGlzdCwgdXNlIGl0XG4gICAgICAgICAgZ3B1QnVmZmVyID0gYnVmZmVycy5wb3AoKSBhcyBHUFVCdWZmZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYnVja2V0IGVtcHR5LCBjcmVhdGUgZ3B1IGJ1ZmZlclxuICAgICAgICAgIGdwdUJ1ZmZlciA9IHRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHsgc2l6ZTogYnVmZmVyU2l6ZSwgdXNhZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY3JlYXRlIGdwdSBidWZmZXJcbiAgICAgIGdwdUJ1ZmZlciA9IHRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHsgc2l6ZTogYnVmZmVyU2l6ZSwgdXNhZ2UgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgZ3B1RGF0YSA9IHsgaWQ6IGNyZWF0ZU5ld0dwdURhdGFJZCgpLCB0eXBlOiBHcHVEYXRhVHlwZS5kZWZhdWx0LCBidWZmZXI6IGdwdUJ1ZmZlciB9O1xuICAgIHRoaXMuc3RvcmFnZUNhY2hlLnNldChncHVEYXRhLmlkLCB7IGdwdURhdGEsIG9yaWdpbmFsU2l6ZTogc2l6ZSB9KTtcblxuICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5jcmVhdGUoc2l6ZT0ke3NpemV9KSA9PiBpZD0ke2dwdURhdGEuaWR9YCk7XG4gICAgcmV0dXJuIGdwdURhdGE7XG4gIH1cblxuICBnZXQoaWQ6IEdwdURhdGFJZCk6IEdwdURhdGEgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2VDYWNoZS5nZXQoaWQpPy5ncHVEYXRhO1xuICB9XG5cbiAgcmVsZWFzZShpZDogR3B1RGF0YUlkKTogbnVtYmVyIHtcbiAgICBjb25zdCBjYWNoZWREYXRhID0gdGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoIWNhY2hlZERhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVsZWFzaW5nIGRhdGEgZG9lcyBub3QgZXhpc3QnKTtcbiAgICB9XG5cbiAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVsZWFzZShpZD0ke2lkfSksIGdwdURhdGFJZD0ke2NhY2hlZERhdGEuZ3B1RGF0YS5pZH1gKTtcblxuICAgIHRoaXMuc3RvcmFnZUNhY2hlLmRlbGV0ZShpZCk7XG4gICAgdGhpcy5idWZmZXJzUGVuZGluZy5wdXNoKGNhY2hlZERhdGEuZ3B1RGF0YS5idWZmZXIpO1xuICAgIC8vIGNhY2hlZERhdGEuZ3B1RGF0YS5idWZmZXIuZGVzdHJveSgpO1xuXG4gICAgcmV0dXJuIGNhY2hlZERhdGEub3JpZ2luYWxTaXplO1xuICB9XG5cbiAgYXN5bmMgZG93bmxvYWQoaWQ6IEdwdURhdGFJZCwgZ2V0VGFyZ2V0QnVmZmVyOiAoKSA9PiBVaW50OEFycmF5KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgY2FjaGVkRGF0YSA9IHRoaXMuc3RvcmFnZUNhY2hlLmdldChpZCk7XG4gICAgaWYgKCFjYWNoZWREYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGEgZG9lcyBub3QgZXhpc3QnKTtcbiAgICB9XG4gICAgYXdhaXQgZG93bmxvYWRHcHVEYXRhKHRoaXMuYmFja2VuZCwgY2FjaGVkRGF0YS5ncHVEYXRhLmJ1ZmZlciwgY2FjaGVkRGF0YS5vcmlnaW5hbFNpemUsIGdldFRhcmdldEJ1ZmZlcik7XG4gIH1cblxuICByZWZyZXNoUGVuZGluZ0J1ZmZlcnMoKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBidWZmZXIgb2YgdGhpcy5idWZmZXJzRm9yVXBsb2FkaW5nUGVuZGluZykge1xuICAgICAgLy8gdXBsb2FkIGJ1ZmZlciBpcyBvbmx5IHVzZWZ1bCBpbiB0aGUgc2Vzc2lvbiBjcmVhdGlvbiB0aW1lLiBTbyB3ZSBkb24ndCBuZWVkIHRvIHJldXNlIHRoZW0gaW4gc2Vzc2lvbiBydW5uaW5nLlxuICAgICAgYnVmZmVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5idWZmZXJzRm9yVXBsb2FkaW5nUGVuZGluZyA9IFtdO1xuXG4gICAgaWYgKHRoaXMuYnVmZmVyc1BlbmRpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYmFja2VuZC5zZXNzaW9uU3RhdHVzID09PSAnZGVmYXVsdCcpIHtcbiAgICAgIGZvciAoY29uc3QgYnVmZmVyIG9mIHRoaXMuYnVmZmVyc1BlbmRpbmcpIHtcbiAgICAgICAgY29uc3QgbWF4SW5GcmVlTGlzdCA9IGJ1Y2tldEZyZWVsaXN0LmdldChidWZmZXIuc2l6ZSk7XG5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgaWYgKChidWZmZXIudXNhZ2UgJiBHUFVCdWZmZXJVc2FnZS5TVE9SQUdFKSA9PT0gR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSkge1xuICAgICAgICAgIC8vIFB1dCB0aGUgcGVuZGluZyBidWZmZXIgdG8gZnJlZUJ1ZmZlcnMgbGlzdCBpbnN0ZWFkIG9mIHJlYWxseSBkZXN0cm95aW5nIGl0IGZvciBidWZmZXIgcmV1c2luZy5cbiAgICAgICAgICBjb25zdCBmcmVlbGlzdCA9IHRoaXMuZnJlZUJ1ZmZlcnMuZ2V0KGJ1ZmZlci5zaXplKSB8fCBbXTtcbiAgICAgICAgICBpZiAobWF4SW5GcmVlTGlzdCA9PT0gdW5kZWZpbmVkIHx8IGZyZWVsaXN0Lmxlbmd0aCA+PSBtYXhJbkZyZWVMaXN0KSB7XG4gICAgICAgICAgICBidWZmZXIuZGVzdHJveSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmVlbGlzdC5wdXNoKGJ1ZmZlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgIH0gZWxzZSBpZiAoKGJ1ZmZlci51c2FnZSAmIEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pID09PSBHUFVCdWZmZXJVc2FnZS5VTklGT1JNKSB7XG4gICAgICAgICAgLy8gUHV0IHRoZSBwZW5kaW5nIGJ1ZmZlciB0byBmcmVlVW5pZm9ybUJ1ZmZlcnMgbGlzdCBpbnN0ZWFkIG9mIHJlYWxseSBkZXN0cm95aW5nIGl0IGZvciBidWZmZXIgcmV1c2luZy5cbiAgICAgICAgICBjb25zdCBmcmVlbGlzdCA9IHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLmdldChidWZmZXIuc2l6ZSkgfHwgW107XG4gICAgICAgICAgaWYgKG1heEluRnJlZUxpc3QgPT09IHVuZGVmaW5lZCB8fCBmcmVlbGlzdC5sZW5ndGggPj0gbWF4SW5GcmVlTGlzdCkge1xuICAgICAgICAgICAgYnVmZmVyLmRlc3Ryb3koKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJlZWxpc3QucHVzaChidWZmZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWZmZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmJ1ZmZlcnNQZW5kaW5nID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERvbid0IHJlbGVhc2UgaW50ZXJtZWRpYXRlIHRlbnNvcnMgaW4gbm9uLWRlZmF1bHQgbW9kZS5cbiAgICAgIC8vIFRPRE86IHJldXNlIHRoZSBzdG9yYWdlIGJ1ZmZlcnMgaW4gbm9uLWRlZmF1bHQgbW9kZS5cbiAgICAgIGxldCBjYXB0dXJlZEJ1ZmZlcnMgPSB0aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMuZ2V0KHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkISk7XG4gICAgICBpZiAoIWNhcHR1cmVkQnVmZmVycykge1xuICAgICAgICBjYXB0dXJlZEJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLnNldCh0aGlzLmJhY2tlbmQuY3VycmVudFNlc3Npb25JZCEsIGNhcHR1cmVkQnVmZmVycyk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGJ1ZmZlciBvZiB0aGlzLmJ1ZmZlcnNQZW5kaW5nKSB7XG4gICAgICAgIGNhcHR1cmVkQnVmZmVycy5wdXNoKGJ1ZmZlcik7XG4gICAgICB9XG4gICAgICB0aGlzLmJ1ZmZlcnNQZW5kaW5nID0gW107XG4gICAgfVxuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmZyZWVCdWZmZXJzLmZvckVhY2goKGJ1ZmZlcnMpID0+IHtcbiAgICAgIGJ1ZmZlcnMuZm9yRWFjaCgoYnVmZmVyKSA9PiB7XG4gICAgICAgIGJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLmZyZWVVbmlmb3JtQnVmZmVycy5mb3JFYWNoKChidWZmZXJzKSA9PiB7XG4gICAgICBidWZmZXJzLmZvckVhY2goKGJ1ZmZlcikgPT4ge1xuICAgICAgICBidWZmZXIuZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnN0b3JhZ2VDYWNoZS5mb3JFYWNoKChzdG9yYWdlKSA9PiB7XG4gICAgICBzdG9yYWdlLmdwdURhdGEuYnVmZmVyLmRlc3Ryb3koKTtcbiAgICB9KTtcblxuICAgIHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5mb3JFYWNoKChidWZmZXJzKSA9PiB7XG4gICAgICBidWZmZXJzLmZvckVhY2goKGJ1ZmZlcikgPT4ge1xuICAgICAgICBidWZmZXIuZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5zdG9yYWdlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5mcmVlQnVmZmVycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmZyZWVVbmlmb3JtQnVmZmVycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMgPSBuZXcgTWFwKCk7XG4gIH1cblxuICBvblJlbGVhc2VTZXNzaW9uKHNlc3Npb25JZDogbnVtYmVyKSB7XG4gICAgLy8gcmVsZWFzZSB0aGUgY2FwdHVyZWQgcGVuZGluZyBidWZmZXJzLlxuICAgIGNvbnN0IHBlbmRpbmdCdWZmZXJzID0gdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmdldChzZXNzaW9uSWQpO1xuICAgIGlmIChwZW5kaW5nQnVmZmVycykge1xuICAgICAgcGVuZGluZ0J1ZmZlcnMuZm9yRWFjaCgoYnVmZmVyKSA9PiB7XG4gICAgICAgIGJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5kZWxldGUoc2Vzc2lvbklkKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUdwdURhdGFNYW5hZ2VyID0gKC4uLmFyZ3M6IENvbnN0cnVjdG9yUGFyYW1ldGVyczx0eXBlb2YgR3B1RGF0YU1hbmFnZXJJbXBsPik6IEdwdURhdGFNYW5hZ2VyID0+XG4gIG5ldyBHcHVEYXRhTWFuYWdlckltcGwoLi4uYXJncyk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmNsYXNzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleUltcGwge1xuICBjb25zdHJ1Y3RvcihhdHRyaWJ1dGU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBhdHRyaWJ1dGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBrZXk6IHN0cmluZztcbiAgcHVibGljIGdldCBjYWNoZUtleSgpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5rZXkpIHtcbiAgICAgIHRoaXMua2V5ID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcylcbiAgICAgICAgLnNvcnQoKVxuICAgICAgICAubWFwKChuYW1lKSA9PiBgJHsodGhpcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilbbmFtZV19YClcbiAgICAgICAgLmpvaW4oJzsnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMua2V5O1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgY2FjaGVLZXk6IHN0cmluZztcbn1cblxuLyoqXG4gKiBjcmVhdGUgYSBuZXcgb2JqZWN0IGZyb20gdGhlIGdpdmVuIGF0dHJpYnV0ZSwgYW5kIGFkZCBhIGNhY2hlS2V5IHByb3BlcnR5IHRvIGl0XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgPSA8VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+PihcbiAgYXR0cmlidXRlOiBULFxuKTogVCAmIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSA9PiBuZXcgQXR0cmlidXRlV2l0aENhY2hlS2V5SW1wbChhdHRyaWJ1dGUpIGFzIHVua25vd24gYXMgVCAmIEF0dHJpYnV0ZVdpdGhDYWNoZUtleTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cblxuZXhwb3J0IGNsYXNzIE1hdE11bFV0aWwge1xuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBleHBlY3RlZCBzaGFwZSB3aGVuIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgKiBAcGFyYW0gYSBUaGUgc2hhcGUgb2YgdGVuc29yIEEuIFNob3VsZCBiZSBhIHR1cGxlIG9mIDIgcG9zaXRpdmUgaW50ZWdlcnNcbiAgICogQHBhcmFtIGIgVGhlIHNoYXBlIG9mIHRlbnNvciBCLiBTaG91bGQgYmUgYSB0dXBsZSBvZiAyIHBvc2l0aXZlIGludGVnZXJzXG4gICAqIEByZXR1cm5zIFRoZSBleHBlY3RlZCBzaGFwZSBvZiB0aGUgcmVzdWx0LCBvciB1bmRlZmluZWQgaWYgTi9BXG4gICAqL1xuICBzdGF0aWMgY2FsY01hdE11bFNoYXBlKGE6IFtudW1iZXIsIG51bWJlcl0sIGI6IFtudW1iZXIsIG51bWJlcl0pOiBbbnVtYmVyLCBudW1iZXJdIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gYVsxXSAhPT0gYlswXSA/IHVuZGVmaW5lZCA6IFthWzBdLCBiWzFdXTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQnJvYWRjYXN0VXRpbCB7XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGV4cGVjdGVkIHNoYXBlIHdoZW4gYnJvYWRjYXN0aW5nIDIgdGVuc29yc1xuICAgKiBAcGFyYW0gYSBUaGUgc2hhcGUgb2YgdGVuc29yIEEuIFNob3VsZCBiZSBhbiBhcnJheSBvZiBwb3NpdGl2ZSBpbnRlZ2Vyc1xuICAgKiBAcGFyYW0gYiBUaGUgc2hhcGUgb2YgdGVuc29yIEIuIFNob3VsZCBiZSBhbiBhcnJheSBvZiBwb3NpdGl2ZSBpbnRlZ2Vyc1xuICAgKiBAcGFyYW0gaXNNYXRNdWwgV2hldGhlciB0aGUgb3BlcmF0aW9uIGlzIE1hdE11bFxuICAgKiBAcmV0dXJucyBUaGUgZXhwZWN0ZWQgc2hhcGUgb2YgdGhlIHJlc3VsdCwgb3IgdW5kZWZpbmVkIGlmIE4vQVxuICAgKi9cbiAgc3RhdGljIGNhbGNTaGFwZShcbiAgICBhZGltczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgYmRpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGlzTWF0TXVsID0gZmFsc2UsXG4gICk6IHJlYWRvbmx5IG51bWJlcltdIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBhcmFuayA9IGFkaW1zLmxlbmd0aDtcbiAgICBjb25zdCBicmFuayA9IGJkaW1zLmxlbmd0aDtcbiAgICBpZiAoYXJhbmsgPT09IDApIHtcbiAgICAgIHJldHVybiBiZGltcztcbiAgICB9XG4gICAgaWYgKGJyYW5rID09PSAwKSB7XG4gICAgICByZXR1cm4gYWRpbXM7XG4gICAgfVxuICAgIGNvbnN0IGNyYW5rID0gTWF0aC5tYXgoYWRpbXMubGVuZ3RoLCBiZGltcy5sZW5ndGgpO1xuICAgIGNvbnN0IGNkaW1zID0gbmV3IEFycmF5PG51bWJlcj4oY3JhbmspO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBsYXN0IDIgZGltZW5zaW9uIGlmIGl0IGlzIE1hdE11bFxuICAgIGlmIChpc01hdE11bCkge1xuICAgICAgaWYgKGFyYW5rIDwgMiB8fCBicmFuayA8IDIpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNTaGFwZU1hdE11bCA9IE1hdE11bFV0aWwuY2FsY01hdE11bFNoYXBlKFxuICAgICAgICBbYWRpbXNbYXJhbmsgLSAyXSwgYWRpbXNbYXJhbmsgLSAxXV0sXG4gICAgICAgIFtiZGltc1ticmFuayAtIDJdLCBiZGltc1ticmFuayAtIDFdXSxcbiAgICAgICk7XG4gICAgICBpZiAoY1NoYXBlTWF0TXVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIFtjZGltc1tjcmFuayAtIDJdLCBjZGltc1tjcmFuayAtIDFdXSA9IGNTaGFwZU1hdE11bDtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gaXNNYXRNdWwgPyAzIDogMTsgaSA8PSBjcmFuazsgaSsrKSB7XG4gICAgICBjb25zdCBhTGVuID0gYXJhbmsgLSBpIDwgMCA/IDEgOiBhZGltc1thcmFuayAtIGldO1xuICAgICAgY29uc3QgYkxlbiA9IGJyYW5rIC0gaSA8IDAgPyAxIDogYmRpbXNbYnJhbmsgLSBpXTtcblxuICAgICAgaWYgKGFMZW4gIT09IGJMZW4gJiYgYUxlbiA+IDEgJiYgYkxlbiA+IDEpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KGFMZW4sIGJMZW4pO1xuICAgICAgaWYgKGFMZW4gJiYgYkxlbikge1xuICAgICAgICBjZGltc1tjcmFuayAtIGldID0gTWF0aC5tYXgoYUxlbiwgYkxlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3aGVuIGVpdGhlciBhTGVuIG9yIGJMZW4gaXMgMCwgdGhlIG90aGVyIHNob3VsZCBiZSBlaXRoZXIgMCBvciAxLCBvdGhlcndpc2UgaXQgaXMgbm90IGJyb2FkY2FzdGFibGUuXG4gICAgICAgIGlmIChtYXggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjZGltc1tjcmFuayAtIGldID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2RpbXM7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIGEgc2hhcGUgaXMgdW5pZGlyZWN0aW9uYWwgYnJvYWRjYXN0YWJsZSB0byBhbm90aGVyIHNoYXBlXG4gICAqIEBwYXJhbSBzaGFwZSBUaGUgaW5wdXQgc2hhcGVcbiAgICogQHBhcmFtIGZpbmFsU2hhcGUgVGhlIGRlc2lyZWQgc2hhcGUgYWZ0ZXIgYnJvYWRjYXN0aW5nXG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZEJyb2FkY2FzdChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIGZpbmFsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKTogYm9vbGVhbiB7XG4gICAgLy8gYWxpZ24gc2hhcGUgdG8gdGhlIHJpZ2h0XG4gICAgY29uc3QgaW5wdXRSYW5rID0gc2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IGZpbmFsUmFuayA9IGZpbmFsU2hhcGUubGVuZ3RoO1xuICAgIGlmIChpbnB1dFJhbmsgPiBmaW5hbFJhbmspIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gaW5wdXRSYW5rOyBpKyspIHtcbiAgICAgIGlmIChzaGFwZVtpbnB1dFJhbmsgLSBpXSAhPT0gMSAmJiBzaGFwZVtpbnB1dFJhbmsgLSBpXSAhPT0gZmluYWxTaGFwZVtmaW5hbFJhbmsgLSBpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTaGFwZVV0aWwge1xuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBzaXplIChudW1iZXIgb2YgZWxlbWVudHMpXG4gICAqL1xuICBzdGF0aWMgc2l6ZShkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlciB7XG4gICAgcmV0dXJuIFNoYXBlVXRpbC5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGRpbXMsIDAsIGRpbXMubGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjb252ZXJ0IGRpbXMgY29ycmVzcG9uZGluZyB0byB0eXBlIGNoYW5nZSB0byBwYWNrLiBleC4gdWludDggZGF0YSB0byB1aW50MzJcbiAgICovXG4gIHN0YXRpYyBjb252ZXJ0U2hhcGUoZGltczogcmVhZG9ubHkgbnVtYmVyW10sIHNpemUgPSA0KTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGNvbnN0IHJhbmsgPSBkaW1zLmxlbmd0aDtcbiAgICBpZiAocmFuayA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBuZXdEaW1zID0gbmV3IEFycmF5KHJhbmspO1xuICAgIGxldCBpID0gcmFuayAtIDE7XG4gICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgaWYgKGRpbXNbaV0gJSBzaXplID09PSAwKSB7XG4gICAgICAgIG5ld0RpbXNbaV0gPSBkaW1zW2ldIC8gc2l6ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc2l6ZSAlIGRpbXNbaV0gIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY29udmVydCBzaGFwZScpO1xuICAgICAgfVxuICAgICAgbmV3RGltc1tpXSA9IDE7XG4gICAgICBzaXplIC89IGRpbXNbaV07XG4gICAgICBpLS07XG4gICAgfVxuICAgIGZvciAoaS0tOyBpID49IDA7IGktLSkge1xuICAgICAgbmV3RGltc1tpXSA9IGRpbXNbaV07XG4gICAgfVxuICAgIHJldHVybiBuZXdEaW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgc2l6ZSAobnVtYmVyIG9mIGVsZW1lbnRzKSBmcm9tIHRoZSBnaXZlbiBheGlzIChpbmNsdXNpdmUpXG4gICAqL1xuICBzdGF0aWMgc2l6ZUZyb21EaW1lbnNpb24oZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGF4aXM6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKGF4aXMgPCAwIHx8IGF4aXMgPiBkaW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke2F4aXN9IGZvciBzaXplRnJvbURpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7ZGltcy5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7XG4gICAgfVxuICAgIHJldHVybiBTaGFwZVV0aWwuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZShkaW1zLCBheGlzLCBkaW1zLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBzaXplIChudW1iZXIgb2YgZWxlbWVudHMpIHRvIHRoZSBnaXZlbiBheGlzIChleGNsdXNpdmUpXG4gICAqL1xuICBzdGF0aWMgc2l6ZVRvRGltZW5zaW9uKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGlzOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChheGlzIDwgMCB8fCBheGlzID4gZGltcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkaW1lbnNpb24gb2YgJHtheGlzfSBmb3Igc2l6ZVRvRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHtkaW1zLmxlbmd0aH0gZGltZW5zaW9ucy5gKTtcbiAgICB9XG4gICAgcmV0dXJuIFNoYXBlVXRpbC5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGRpbXMsIDAsIGF4aXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgc2l6ZSAobnVtYmVyIG9mIGVsZW1lbnRzKSBmcm9tIGFuZCB0byB0aGUgZ2l2ZW4gYXhpcyBbc3RhcnQsIGVuZClcbiAgICovXG4gIHN0YXRpYyBnZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcik6IG51bWJlciB7XG4gICAgbGV0IHNpemUgPSAxO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAvLyBzYWZldHkgY2hlY2sgYXMgdGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IG11bHRpcGxlIG90aGVyIG1ldGhvZHMgcmVxdWlyaW5nIHNpemUuXG4gICAgICAvLyBzaXplIGNhbm5vdCBiZSBuZWdhdGl2ZS5cbiAgICAgIGlmIChkaW1zW2ldIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICAgICAgICAnY2Fubm90IGdldCB2YWxpZCBzaXplIGZyb20gc3BlY2lmaWVkIGRpbWVuc2lvbiByYW5nZS4gTW9zdCBsaWtlbHkgdGhlIHJhbmdlIGNvbnRhaW5zIG5lZ2F0aXZlIHZhbHVlcyBpbiB0aGVtLicsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBzaXplICo9IGRpbXNbaV07XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xuICB9XG5cbiAgc3RhdGljIGNvbXB1dGVTdHJpZGVzKGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10ge1xuICAgIGNvbnN0IHJhbmsgPSBkaW1zLmxlbmd0aDtcbiAgICBpZiAocmFuayA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSBpZiAocmFuayA9PT0gMSkge1xuICAgICAgcmV0dXJuIFsxXTtcbiAgICB9XG4gICAgY29uc3Qgc3RyaWRlcyA9IG5ldyBBcnJheShyYW5rKTtcbiAgICBzdHJpZGVzW3JhbmsgLSAxXSA9IDE7XG4gICAgc3RyaWRlc1tyYW5rIC0gMl0gPSBkaW1zW3JhbmsgLSAxXTtcbiAgICBmb3IgKGxldCBpID0gcmFuayAtIDM7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBzdHJpZGVzW2ldID0gc3RyaWRlc1tpICsgMV0gKiBkaW1zW2kgKyAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmlkZXM7XG4gIH1cblxuICAvKipcbiAgICogbm9ybWFpbHplIGF4aXMgb2YgcmFuZ2UgWy1yLCByKSBpbnRvIFswLCByKS5cbiAgICovXG4gIHN0YXRpYyBub3JtYWxpemVBeGlzKGF4aXM6IG51bWJlciwgdGVuc29yUmFuazogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAoYXhpcyA8IC10ZW5zb3JSYW5rICYmIGF4aXMgPj0gdGVuc29yUmFuaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBheGlzIGZvciB0aGlzIG9wZXJhdGlvbi4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGF4aXMgPCAwID8gYXhpcyArIHRlbnNvclJhbmsgOiBheGlzO1xuICB9XG5cbiAgc3RhdGljIG5vcm1hbGl6ZUF4ZXMoYXhlczogcmVhZG9ubHkgbnVtYmVyW10sIHRlbnNvclJhbms/OiBudW1iZXIpOiBudW1iZXJbXSB7XG4gICAgcmV0dXJuIGF4ZXMubWFwKCh4KSA9PiB0aGlzLm5vcm1hbGl6ZUF4aXMoeCwgdGVuc29yUmFuayA/PyBheGVzLmxlbmd0aCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNvcnRzIGEgZ2l2ZW4gYXJyYXkgYmFzZWQgb24gdGhlIGluZGljZXMgaW4gdGhlIFBlcm0gYXJyYXlcbiAgICogVXNlZCBpbiBUcmFuc3Bvc2VcbiAgICogQHBhcmFtIGEgQXJyYXkgdG8gYmUgc29ydGVkIHN1Y2ggYXMgZGltcyBvciBzdHJpZGVzXG4gICAqIEBwYXJhbSBwZXJtIFBlcm0gZ2l2ZW47IGlmIG51bGwgYSB3aWxsIGJlIHJldmVyc2VkXG4gICAqL1xuICBzdGF0aWMgc29ydEJhc2VkT25QZXJtKGE6IHJlYWRvbmx5IG51bWJlcltdLCBwZXJtPzogcmVhZG9ubHkgbnVtYmVyW10pOiByZWFkb25seSBudW1iZXJbXSB7XG4gICAgaWYgKHBlcm0pIHtcbiAgICAgIHJldHVybiBwZXJtLm1hcCgodikgPT4gYVt2XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYWRzIGEgZ2l2ZW4gc2hhcGUgYWNjb3JkaW5nIHRvIHRoZSBwYWRkaW5nIHZhbHVlc1xuICAgKiBAcGFyYW0gZGltcyBzaGFwZSBvZiB0aGUgVGVuc29yIHRvIGJlIHBhZGRlZFxuICAgKiBAcGFyYW0gcGFkIHBhZCB2YWx1ZXNcbiAgICovXG4gIHN0YXRpYyBwYWRTaGFwZShkaW1zOiByZWFkb25seSBudW1iZXJbXSwgcGFkOiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBjb25zdCByYW5rID0gZGltcy5sZW5ndGg7XG4gICAgcmV0dXJuIGRpbXMubWFwKCh2LCBpKSA9PiB2ICsgcGFkW2ldICsgcGFkW2kgKyByYW5rXSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgdHdvIHNoYXBlcyBhcmUgaWRlbnRpY2FsXG4gICAqIEBwYXJhbSBzaGFwZTFcbiAgICogQHBhcmFtIHNoYXBlMlxuICAgKi9cbiAgc3RhdGljIGFyZUVxdWFsKHNoYXBlMTogcmVhZG9ubHkgbnVtYmVyW10sIHNoYXBlMjogcmVhZG9ubHkgbnVtYmVyW10pOiBib29sZWFuIHtcbiAgICBpZiAoc2hhcGUxLmxlbmd0aCAhPT0gc2hhcGUyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc2hhcGUxLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBzaGFwZTJbaV0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQb29sQ29udlV0aWwge1xuICAvKipcbiAgICogQWRqdXN0IHRoZSBrZXJuZWwsIHN0cmlkZXMsIHBhZHMgdG8gY29ycmVjdCByYW5rLiBTZXQgdG8gZGVmYXVsdCB2YWx1ZSBpZiBub3QgcHJlc2VudFxuICAgKiBAcGFyYW0gaXNHbG9iYWxPcGVyYXRvciBJZiB0cnVlLCBwZXJmb3JtIGdsb2JhbCBwb29saW5nLlxuICAgKiBAcGFyYW0gaW5wdXREaW1zIFRoZSBpbnB1dCB0ZW5zb3IgZGltZW5zaW9uLlxuICAgKiBAcGFyYW0ga2VybmVsU2hhcGUgVGhlIHNpemUgb2YgdGhlIGtlcm5lbCBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBzdHJpZGVzIFN0cmlkZSBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBkaWxhdGlvbnMgRGlsYXRpb24gYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gcGFkcyBQYWRkaW5nIGZvciB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgYWxvbmcgZWFjaCBheGlzLlxuICAgKi9cbiAgc3RhdGljIGFkanVzdFBvb2xBdHRyaWJ1dGVzKFxuICAgIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sXG4gICAgaW5wdXREaW1zOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBrZXJuZWxTaGFwZTogbnVtYmVyW10sXG4gICAgc3RyaWRlczogbnVtYmVyW10sXG4gICAgZGlsYXRpb25zOiBudW1iZXJbXSxcbiAgICBwYWRzOiBudW1iZXJbXSxcbiAgKTogdm9pZCB7XG4gICAgaWYgKCFpc0dsb2JhbE9wZXJhdG9yICYmIGtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gaW5wdXREaW1zLmxlbmd0aCAtIDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbGVuZ3RoIG9mIHNwZWNpZmllZCBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSAyIGxlc3MgdGhhbiBsZW5ndGggb2YgaW5wdXQgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGlmIChpc0dsb2JhbE9wZXJhdG9yKSB7XG4gICAgICAvLyBhZGp1c3Qga2VybmVsIHNoYXBlIHRvIGNvdmVyIHRoZSBpbnB1dCBkaW1zXG4gICAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBpbnB1dERpbXMubGVuZ3RoIC0gMjsgZGltKyspIHtcbiAgICAgICAgaWYgKGRpbSA+PSBrZXJuZWxTaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgICBrZXJuZWxTaGFwZS5wdXNoKGlucHV0RGltc1tkaW0gKyAyXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2VybmVsU2hhcGVbZGltXSA9IGlucHV0RGltc1tkaW0gKyAyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkanVzdCBzdHJpZGVzIGxlbmd0aCB0byBtYXRjaCBrZXJuZWwgc2hhcGUgbGVuZ3RoXG4gICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwga2VybmVsU2hhcGUubGVuZ3RoOyBkaW0rKykge1xuICAgICAgaWYgKGRpbSA8IHN0cmlkZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzdHJpZGVzW2RpbV0gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpZGVzIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJpZGVzLnB1c2goMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IGRpbGF0aW9uIHZhbHVlXG4gICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwga2VybmVsU2hhcGUubGVuZ3RoOyBkaW0rKykge1xuICAgICAgaWYgKGRpbSA8IGRpbGF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGRpbGF0aW9uc1tkaW1dIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlsYXRpb25zIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWxhdGlvbnMucHVzaCgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGp1c3QgcGFkcyBsZW5ndGggdG8gbWF0Y2ggMiAqIGtlcm5lbCBzaGFwZSBsZW5ndGhcbiAgICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBrZXJuZWxTaGFwZS5sZW5ndGggKiAyOyBkaW0rKykge1xuICAgICAgaWYgKGRpbSA8IHBhZHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChwYWRzW2RpbV0gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhZHMucHVzaCgwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzYW5pdHkgY2hlY2tzIGZvciB2YWx1ZXMgaW4ga2VybmVsIHNoYXBlcyBhbmQgcGFkc1xuICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGtlcm5lbFNoYXBlLmxlbmd0aDsgZGltKyspIHtcbiAgICAgIGlmIChrZXJuZWxTaGFwZVtkaW1dIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZXJuZWwgc2hhcGVzIG5lZWQgdG8gYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhZHNbZGltXSA+PSBrZXJuZWxTaGFwZVtkaW1dIHx8IHBhZHNbZGltICsga2VybmVsU2hhcGUubGVuZ3RoXSA+PSBrZXJuZWxTaGFwZVtkaW1dKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkcyBzaG91bGQgYmUgc21hbGxlciB0aGFuIGtlcm5lbCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkanVzdCBwYWQgdmFsdWVzIGJhc2VkIG9uICdhdXRvUGFkJyBhdHRyaWJ1dGVcbiAgc3RhdGljIGFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZChcbiAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGRpbGF0aW9uczogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHBhZHM6IG51bWJlcltdLFxuICAgIGlzQ2hhbm5lbExhc3Q6IGJvb2xlYW4sXG4gICAgYXV0b1BhZD86IHN0cmluZyxcbiAgKTogdm9pZCB7XG4gICAgaWYgKCFhdXRvUGFkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBhZHMubGVuZ3RoICE9PSAyICogKGlucHV0RGltcy5sZW5ndGggLSAyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZW5ndGggb2YgcGFkcyBzaG91bGQgYmUgdHdpY2UgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAoc3RyaWRlcy5sZW5ndGggIT09IGlucHV0RGltcy5sZW5ndGggLSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiBzdHJpZGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGlmIChrZXJuZWxTaGFwZS5sZW5ndGggIT09IGlucHV0RGltcy5sZW5ndGggLSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlbmd0aCBvZiBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGlucHV0RGltcy5sZW5ndGggLSAyOyBkaW0rKykge1xuICAgICAgUG9vbENvbnZVdGlsLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKFxuICAgICAgICBpbnB1dERpbXNbZGltICsgKGlzQ2hhbm5lbExhc3QgPyAxIDogMildLFxuICAgICAgICBzdHJpZGVzW2RpbV0sXG4gICAgICAgIGRpbGF0aW9uc1tkaW1dLFxuICAgICAgICBrZXJuZWxTaGFwZVtkaW1dLFxuICAgICAgICBwYWRzLFxuICAgICAgICBkaW0sXG4gICAgICAgIGRpbSArIGlucHV0RGltcy5sZW5ndGggLSAyLFxuICAgICAgICBhdXRvUGFkLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBvdXRwdXQgc2hhcGUgZm9yIFBvb2wgb3BzIGJhc2VkIG9uIGlucHV0IGF0dHJpYnV0ZXMuIChTaG91bGQgYmUgdXNlZCBvbmx5IGZvciBQb29sIG9wcylcbiAgICogQHBhcmFtIGlzR2xvYmFsT3BlcmF0b3IgSWYgdHJ1ZSwgcGVyZm9ybSBnbG9iYWwgcG9vbGluZy5cbiAgICogQHBhcmFtIGlucHV0RGltcyBUaGUgaW5wdXQgdGVuc29yIGRpbWVuc2lvbi4gKGlucHV0c1swXS5kaW1zKVxuICAgKiBAcGFyYW0gc3RyaWRlcyBTdHJpZGUgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gZGlsYXRpb25zIERpbGF0aW9uIGFsb25nIGVhY2ggYXhpcy5cbiAgICogQHBhcmFtIGtlcm5lbFNoYXBlIFRoZSBzaXplIG9mIHRoZSBrZXJuZWwgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gcGFkcyBQYWRkaW5nIGZvciB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0gYXV0b1BhZCBERVBSRUNBVEVEIGF0dHJpYnV0ZSBzdXBwb3J0ZWQgZm9yIGxlZ2FjeSBtb2RlbHMuIFNwZWNpZmllcyBob3cgdG8gaW1wbGljaXRseSBjYWxjdWxhdGUgcGFkcyBpbiBlYWNoXG4gICAqICAgICBkaW1lbnNpb24uIENhbiB0YWtlIHZhbHVlcyBOT1RTRVQsIFNBTUVfVVBQRVIsIFNBTUVfTE9XRVIsIG9yIFZBTElELlxuICAgKi9cbiAgc3RhdGljIGNvbXB1dGVQb29sT3V0cHV0U2hhcGUoXG4gICAgaXNHbG9iYWxPcGVyYXRvcjogYm9vbGVhbixcbiAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHN0cmlkZXM6IG51bWJlcltdLFxuICAgIGRpbGF0aW9uczogbnVtYmVyW10sXG4gICAga2VybmVsU2hhcGU6IG51bWJlcltdLFxuICAgIHBhZHM6IG51bWJlcltdLFxuICAgIGF1dG9QYWQ/OiBzdHJpbmcsXG4gICk6IG51bWJlcltdIHtcbiAgICBpZiAoaW5wdXREaW1zLmxlbmd0aCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHNoYXBlIG11c3QgYmUgb2Ygc2l6ZSBncmVhdGVyIHRoYW4gMCcpO1xuICAgIH1cblxuICAgIC8vIEFkZCBiYXRjaCBzaXplIGFuZCBudW1iZXIgb2YgY2hhbm5lbHMgb2Ygb3V0cHV0XG4gICAgY29uc3Qgb3V0cHV0RGltcyA9IFtpbnB1dERpbXNbMF0sIGlucHV0RGltc1sxXV07XG5cbiAgICBQb29sQ29udlV0aWwuY29tcHV0ZVNoYXBlSGVscGVyKFxuICAgICAgaXNHbG9iYWxPcGVyYXRvcixcbiAgICAgIGlucHV0RGltcyxcbiAgICAgIG91dHB1dERpbXMsXG4gICAgICBzdHJpZGVzLFxuICAgICAgZGlsYXRpb25zLFxuICAgICAga2VybmVsU2hhcGUsXG4gICAgICBwYWRzLFxuICAgICAgYXV0b1BhZCxcbiAgICApO1xuICAgIHJldHVybiBvdXRwdXREaW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgb3V0cHV0IHNoYXBlIGZvciBDb252IG9wIGJhc2VkIG9uIGlucHV0IGF0dHJpYnV0ZXMuIChTaG91bGQgYmUgdXNlZCBvbmx5IGZvciBDb252IG9wKVxuICAgKiBAcGFyYW0gaW5wdXREaW1zIFRoZSBpbnB1dCB0ZW5zb3IgZGltZW5zaW9uLiAoaW5wdXRzWzBdLmRpbXMpXG4gICAqIEBwYXJhbSBmaWx0ZXJEaW1zIFRoZSBmaWx0ZXIgdGVuc29yIGRpbWVuc2lvbi4gKGlucHV0c1sxXS5kaW1zKVxuICAgKiBAcGFyYW0gc3RyaWRlcyBTdHJpZGUgYWxvbmcgZWFjaCBheGlzLlxuICAgKiBAcGFyYW0ga2VybmVsU2hhcGUgVGhlIHNpemUgb2YgdGhlIGtlcm5lbCBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBwYWRzIFBhZGRpbmcgZm9yIHRoZSBiZWdpbm5pbmcgYW5kIGVuZGluZyBhbG9uZyBlYWNoIGF4aXMuXG4gICAqIEBwYXJhbSBhdXRvUGFkIERFUFJFQ0FURUQgYXR0cmlidXRlIHN1cHBvcnRlZCBmb3IgbGVnYWN5IG1vZGVscy4gU3BlY2lmaWVzIGhvdyB0byBpbXBsaWNpdGx5IGNhbGN1bGF0ZSBwYWRzIGluIGVhY2hcbiAgICogICAgIGRpbWVuc2lvbi4gQ2FuIHRha2UgdmFsdWVzIE5PVFNFVCwgU0FNRV9VUFBFUiwgU0FNRV9MT1dFUiwgb3IgVkFMSUQuXG4gICAqL1xuICBzdGF0aWMgY29tcHV0ZUNvbnZPdXRwdXRTaGFwZShcbiAgICBpbnB1dERpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGZpbHRlckRpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHN0cmlkZXM6IG51bWJlcltdLFxuICAgIGRpbGF0aW9uczogbnVtYmVyW10sXG4gICAga2VybmVsU2hhcGU6IG51bWJlcltdLFxuICAgIHBhZHM6IG51bWJlcltdLFxuICAgIGF1dG9QYWQ/OiBzdHJpbmcsXG4gICk6IG51bWJlcltdIHtcbiAgICBpZiAoaW5wdXREaW1zLmxlbmd0aCA8PSAwIHx8IGZpbHRlckRpbXMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnB1dCB0ZW5zb3IgZGltcyBvciBpbnZhbGlkIGZpbHRlciB0ZW5zb3IgZGltcycpO1xuICAgIH1cblxuICAgIC8vIEFkZCBiYXRjaCBzaXplIGFuZCBudW1iZXIgb2YgY2hhbm5lbHMgb2Ygb3V0cHV0XG4gICAgY29uc3Qgb3V0cHV0RGltcyA9IFtpbnB1dERpbXNbMF0sIGZpbHRlckRpbXNbMF1dO1xuXG4gICAgUG9vbENvbnZVdGlsLmNvbXB1dGVTaGFwZUhlbHBlcihmYWxzZSwgaW5wdXREaW1zLCBvdXRwdXREaW1zLCBzdHJpZGVzLCBkaWxhdGlvbnMsIGtlcm5lbFNoYXBlLCBwYWRzLCBhdXRvUGFkKTtcbiAgICByZXR1cm4gb3V0cHV0RGltcztcbiAgfVxuXG4gIC8vIHdpbGwgY29tcHV0ZSBvdXRwdXQgc2hhcGVzIGZvciBkYXRhIGRpbWVuc2lvbnMgT05MWSAoaS5lLikgbm8gYmF0Y2ggc2l6ZSBhbmQgY2hhbm5lbHNcbiAgLy8gY2FsbGVkIGJ5IGNvbXB1dGVQb29sT3V0cHV0U2hhcGUoKSBhbmQgY29tcHV0ZUNvbnZPdXRwdXRTaGFwZSgpXG4gIC8vIGFkanVzdCBwYWRzIGJhc2VkIG9uICdhdXRvUGFkJyBhdHRyaWJ1dGUgcHJpb3IgdG8gc2hhcGUgY29tcHV0YXRpb25cbiAgcHJpdmF0ZSBzdGF0aWMgY29tcHV0ZVNoYXBlSGVscGVyKFxuICAgIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sXG4gICAgaW5wdXREaW1zOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBvdXRwdXREaW1zOiBudW1iZXJbXSxcbiAgICBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBkaWxhdGlvbnM6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBwYWRzOiBudW1iZXJbXSxcbiAgICBhdXRvUGFkPzogc3RyaW5nLFxuICApIHtcbiAgICBpZiAoaXNHbG9iYWxPcGVyYXRvcikge1xuICAgICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgaW5wdXREaW1zLmxlbmd0aCAtIDI7IGRpbSsrKSB7XG4gICAgICAgIG91dHB1dERpbXMucHVzaCgxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgaW5wdXREaW1zLmxlbmd0aCAtIDI7IGRpbSsrKSB7XG4gICAgICAgIG91dHB1dERpbXMucHVzaChcbiAgICAgICAgICBQb29sQ29udlV0aWwuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUoXG4gICAgICAgICAgICBpbnB1dERpbXNbZGltICsgMl0sXG4gICAgICAgICAgICBzdHJpZGVzW2RpbV0sXG4gICAgICAgICAgICBkaWxhdGlvbnNbZGltXSxcbiAgICAgICAgICAgIGtlcm5lbFNoYXBlW2RpbV0sXG4gICAgICAgICAgICBwYWRzLFxuICAgICAgICAgICAgZGltLFxuICAgICAgICAgICAgZGltICsgaW5wdXREaW1zLmxlbmd0aCAtIDIsXG4gICAgICAgICAgICBhdXRvUGFkLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaGVscGVyIGZvciBjb21wdXRlU2hhcGVIZWxwZXIoKSBhbmQgYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKClcbiAgLy8gYWRqdXN0cyBwYWQgdmFsdWUgZm9yIGdpdmVuICdhdXRvUGFkJyBzdHJpbmcgYW5kIGNvbXB1dGVzIG91dHB1dCBzaGFwZSBhbG9uZyBhIHBhcnRpY3VsYXIgZGltZW5zaW9uXG4gIHByaXZhdGUgc3RhdGljIGFkanVzdFBhZEFuZFJldHVyblNoYXBlKFxuICAgIGluU2l6ZTogbnVtYmVyLFxuICAgIHN0cmlkZTogbnVtYmVyLFxuICAgIGRpbGF0aW9uOiBudW1iZXIsXG4gICAga2VybmVsOiBudW1iZXIsXG4gICAgcGFkczogbnVtYmVyW10sXG4gICAgcGFkSGVhZEluZGV4OiBudW1iZXIsXG4gICAgcGFkVGFpbEluZGV4OiBudW1iZXIsXG4gICAgYXV0b1BhZD86IHN0cmluZyxcbiAgKTogbnVtYmVyIHtcbiAgICBjb25zdCBka2VybmVsID0gZGlsYXRpb24gKiAoa2VybmVsIC0gMSkgKyAxO1xuICAgIGlmIChhdXRvUGFkICYmIGF1dG9QYWQgIT09ICdOT1RTRVQnKSB7XG4gICAgICBzd2l0Y2ggKGF1dG9QYWQpIHtcbiAgICAgICAgY2FzZSAnVkFMSUQnOlxuICAgICAgICAgIHBhZHNbcGFkSGVhZEluZGV4XSA9IDA7XG4gICAgICAgICAgcGFkc1twYWRUYWlsSW5kZXhdID0gMDtcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoaW5TaXplIC0gZGtlcm5lbCkgLyBzdHJpZGUgKyAxKTtcbiAgICAgICAgY2FzZSAnU0FNRV9MT1dFUic6XG4gICAgICAgIGNhc2UgJ1NBTUVfVVBQRVInOlxuICAgICAgICAgIGlmIChkaWxhdGlvbiAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaWxhdGlvbiBub3Qgc3VwcG9ydGVkIGZvciBTQU1FX1VQUEVSIG9yIFNBTUVfTE9XRVInKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbGVnYWN5VGFyZ2V0U2l6ZSA9IChpblNpemUgKyBzdHJpZGUgLSAxKSAvIHN0cmlkZTtcbiAgICAgICAgICAgIGNvbnN0IHBhZE5lZWRlZCA9IChsZWdhY3lUYXJnZXRTaXplIC0gMSkgKiBzdHJpZGUgKyBrZXJuZWwgLSBpblNpemU7XG4gICAgICAgICAgICBwYWRzW3BhZEhlYWRJbmRleF0gPSBhdXRvUGFkID09PSAnU0FNRV9MT1dFUicgPyBNYXRoLmZsb29yKChwYWROZWVkZWQgKyAxKSAvIDIpIDogTWF0aC5mbG9vcihwYWROZWVkZWQgLyAyKTtcbiAgICAgICAgICAgIHBhZHNbcGFkVGFpbEluZGV4XSA9IHBhZE5lZWRlZCAtIHBhZHNbcGFkSGVhZEluZGV4XTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKChpblNpemUgKyBwYWROZWVkZWQgLSBrZXJuZWwpIC8gc3RyaWRlICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgQXV0b1BhZCB0eXBlJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKChpblNpemUgKyBwYWRzW3BhZEhlYWRJbmRleF0gKyBwYWRzW3BhZFRhaWxJbmRleF0gLSBka2VybmVsKSAvIHN0cmlkZSArIDEpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgR2VtbVV0aWwge1xuICAvLyB3aWxsIG1ha2Ugc3VyZSBpbnB1dCBzaGFwZXMgYXJlIGNvbXBhdGlibGUgZm9yIHRoaXMgb3BcbiAgLy8gYW5kIHJldHVybiBiYWNrIHRoZSBzaGFwZSBvZiB0aGUgb3V0cHV0IGluIHRoZSBmb3JtIG9mIGEgdHVwbGVcbiAgLy8gd2lsbCB0aHJvdyBleGNlcHRpb24gaWYgdGhlIGlucHV0IHNoYXBlcyBhcmUgbm90IGNvbXBhdGlibGVcbiAgc3RhdGljIGdldFNoYXBlT2ZHZW1tUmVzdWx0KFxuICAgIGxlZnRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gICAgdHJhbnNMZWZ0OiBib29sZWFuLFxuICAgIHJpZ2h0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICAgIHRyYW5zUmlnaHQ6IGJvb2xlYW4sXG4gICAgYmlhc1NoYXBlPzogcmVhZG9ubHkgbnVtYmVyW10sXG4gICk6IHJlYWRvbmx5IG51bWJlcltdIHtcbiAgICBpZiAobGVmdFNoYXBlLmxlbmd0aCAhPT0gMiB8fCByaWdodFNoYXBlLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaGFwZSBuZWVkIHRvIGJlIG9mIHNpemUgMicpO1xuICAgIH1cblxuICAgIGxldCBNOiBudW1iZXI7XG4gICAgbGV0IEs6IG51bWJlcjtcbiAgICBsZXQgTjogbnVtYmVyO1xuXG4gICAgaWYgKHRyYW5zTGVmdCkge1xuICAgICAgTSA9IGxlZnRTaGFwZVsxXTtcbiAgICAgIEsgPSBsZWZ0U2hhcGVbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIE0gPSBsZWZ0U2hhcGVbMF07XG4gICAgICBLID0gbGVmdFNoYXBlWzFdO1xuICAgIH1cblxuICAgIGxldCBrRGltID0gLTE7XG5cbiAgICBpZiAodHJhbnNSaWdodCkge1xuICAgICAgTiA9IHJpZ2h0U2hhcGVbMF07XG4gICAgICBrRGltID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgTiA9IHJpZ2h0U2hhcGVbMV07XG4gICAgICBrRGltID0gMDtcbiAgICB9XG5cbiAgICBpZiAocmlnaHRTaGFwZVtrRGltXSAhPT0gSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaW1lbnNpb24gbWlzbWF0Y2gnKTtcbiAgICB9XG5cbiAgICBpZiAoTSA8PSAwIHx8IE4gPD0gMCB8fCBLIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzaGFwZSBzcGVjaWZpZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoYmlhc1NoYXBlICYmICFCcm9hZGNhc3RVdGlsLmlzVmFsaWRCcm9hZGNhc3QoYmlhc1NoYXBlLCBbTSwgTl0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlbW06IGludmFsaWQgYmlhcyBzaGFwZSBmb3IgYnJvYWRjYXN0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtNLCBOLCBLXTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgTUlOX0NMSVAgPSAtMy40MDI4MjM0NjYzODUyODg2ZTM4O1xuZXhwb3J0IGNvbnN0IE1BWF9DTElQID0gMy40MDI4MjM0NjYzODUyODg2ZTM4O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgUHJvZ3JhbVVuaWZvcm0sIFByb2dyYW1Vbmlmb3JtVmFyaWFibGVJbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG4vKipcbiAqIGNvbnN0YW50IHZhbHVlIGZvciBhIHdvcmtncm91cCBzaXplLlxuICpcbiAqIFdlIGRlZmluaXRlbHkgY2FuIGRvIGZ1cnRoZXIgb3B0aW1pemF0aW9uIGluIGZ1dHVyZSwgYnV0IGZvciBub3cgd2UgdXNlIDY0LlxuICpcbiAqIHJ1bGUgb2YgdGh1bWI6IFVzZSBbYSB3b3JrZ3JvdXAgc2l6ZSBvZl0gNjQgdW5sZXNzIHlvdSBrbm93IHdoYXQgR1BVIHlvdSBhcmUgdGFyZ2V0aW5nIG9yIHRoYXQgeW91ciB3b3JrbG9hZFxuICogICAgICAgICAgICAgICAgbmVlZHMgc29tZXRoaW5nIGRpZmZlcmVudC5cbiAqXG4gKiBmcm9tOiBodHRwczovL3N1cm1hLmRldi90aGluZ3Mvd2ViZ3B1L1xuICoqL1xuZXhwb3J0IGNvbnN0IFdPUktHUk9VUF9TSVpFID0gNjQ7XG5cbmludGVyZmFjZSBJbmRpY2VzSGVscGVyVHlwZXMge1xuICAvKipcbiAgICogV0dTTCB0eXBlIG9mIGluZGljZXMgZXhwcmVzc2lvblxuICAgKi9cbiAgcmVhZG9ubHkgaW5kaWNlczogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIHR5cGUgb2YgYSB2YWx1ZVxuICAgKi9cbiAgcmVhZG9ubHkgdmFsdWU6IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCB0eXBlIG9mIHN0b3JhZ2UgdHlwZSByZXByZXNlbnRpbmcgYSB2YWx1ZVxuICAgKlxuICAgKiBUaGlzIGlzIHVzdWFsbHkgdGhlIHNhbWUgdG8gYHZhbHVlYCwgYnV0IGZvciBzb21lIHR5cGUgKGVnLiBib29sKSwgd2UgbmVlZCB0byB1c2UgYHUzMmAgYXMgc3RvcmFnZSB0eXBlIGZvclxuICAgKiB2YWx1ZSB0eXBlIGB2ZWM0PGJvb2w+YFxuICAgKi9cbiAgcmVhZG9ubHkgc3RvcmFnZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiB0ZW5zb3IgdHlwZSBhcyByZXByZXNlbnRlZCBpbiBUZW5zb3JWaWV3XG4gICAqL1xuICByZWFkb25seSB0ZW5zb3I6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBBIGhlbHBlciBjbGFzcyBmb3IgZ2VuZXJhdGluZyBXR1NMIGNvZGUgZm9yIG1hbmlwdWxhdGluZyBpbmRpY2VzIGFuZCBkYXRhIGZvciBhIHNoYWRlcidzIGlucHV0IG9yIG91dHB1dC5cbiAqXG4gKiBUaGlzIGNsYXNzIGlzIGRlc2lnbmVkIHRvIG9mZmVyIGEgdW5pZmllZCB3YXkgdG8gZ2VuZXJhdGUgV0dTTCBjb2RlIGZvciBtYW5pcHVsYXRpbmcgaW5kaWNlcyBhbmQgZGF0YSBmb3IgYSBzaGFkZXInc1xuICogaW5wdXQgb3Igb3V0cHV0LlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgaXMgYSBsaXN0IG9mIHRlcm1pbm9sb2dpZXMgdXNlZCBpbiB0aGlzIGNsYXNzOlxuICogLSBgb2Zmc2V0YDogYSB1aW50MzIgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBvZmZzZXQgb2YgYW4gZWxlbWVudCBpbiB0aGUgZGF0YSBidWZmZXIuXG4gKiAtIGBpbmRpY2VzYDogYW4gYWJzdHJhY3Rpb24gb2YgYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSdzIGluZGljZXMgcmVwcmVzZW50aW5nIHRoZSBkYXRhJ3MgaW5kZXggb24gZWFjaCBkaW1lbnNpb24uXG4gKiAtIGB2YWx1ZWA6IGEgdmFsdWUgb2YgYSBkYXRhIGVsZW1lbnQuXG4gKlxuICogVXNlcnMgYXJlIGV4cGVjdGVkIHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGZvciBlYWNoIHNoYWRlcidzIGlucHV0IG9yIG91dHB1dCwgYW5kIHVzZSB0aGUgaW5zdGFuY2UgdG9cbiAqIGdlbmVyYXRlIFdHU0wgY29kZSBmb3IgbWFuaXB1bGF0aW5nIGluZGljZXMgYW5kIGRhdGEuIFRoZSBmb2xsb3dpbmcgMiBleHBvcnRlZCBmdW5jdGlvbnMgYXJlIGZvciB1c2VycyB0byBjYWxsIHRvXG4gKiBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYW4gaW5kaWNlcyBoZWxwZXI6XG4gKiAtIGBpbnB1dFZhcmlhYmxlKClgOiBjcmVhdGUgYW4gaW5kaWNlcyBoZWxwZXIgaW5zdGFuY2UgZm9yIGFuIGlucHV0LlxuICogLSBgb3V0cHV0VmFyaWFibGUoKWA6IGNyZWF0ZSBhbiBpbmRpY2VzIGhlbHBlciBpbnN0YW5jZSBmb3IgYW4gb3V0cHV0LlxuICogLSBgaW50ZXJuYWxWYXJpYWJsZSgpYDogY3JlYXRlIGFuIGluZGljZXMgaGVscGVyIGluc3RhbmNlIGZvciBhbiBpbnRlcm5hbCB2YXJpYWJsZS5cbiAqXG4gKiBBbiBpbmRpY2VzIGhlbHBlciBpbnN0YW5jZSBjb250YWlucyBoZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgZm9sbG93aW5nIG9wZXJhdGlvbnM6XG4gKiAtIGFjY2VzcyByZWFkb25seSBiYXNpYyBpbmZvcm1hdGlvbiwgaW5jbHVkaW5nOiBgbmFtZWAodGhlIG5hbWUgb2YgdGhlIGlucHV0IG9yIG91dHB1dCksIGB1c2FnZWAod2hldGhlciBpdCdzIGFuXG4gKiBpbnB1dCwgYW4gb3V0cHV0IG9yIGFuIGludGVybmFsIHZhcmlhYmxlKSBhbmQgYHNoYXBlYCh0aGUgcGFzc2VkIGluIHNoYXBlKS5cbiAqIC0gYHR5cGVgOiBhY2Nlc3MgcmVhZG9ubHkgdHlwZSBpbmZvcm1hdGlvbiwgaW5jbHVkaW5nOiBgaW5kaWNlc2AodGhlIHR5cGUgb2YgaW5kaWNlcyksIGB2YWx1ZWAodGhlIHR5cGUgb2YgdmFsdWUgYXRcbiAqIHJ1bnRpbWUpLCBgc3RvcmFnZWAodGhlIHR5cGUgb2YgdmFsdWUgYXQgc3RvcmFnZSkgYW5kIGB0ZW5zb3JgKHRoZSB0ZW5zb3IgdHlwZSBhcyByZXByZXNlbnRlZCBpbiBUZW5zb3JWaWV3KS5cbiAqIC0gZ2VuZXJhdGUgV0dTTCBjb2RlIGZvciBnZXR0aW5nIGluZGljZXMgZnJvbSBvZmZzZXQuIFVzZSBgb2Zmc2V0VG9JbmRpY2VzKClgIGZvciBXR1NMIGNvZGUgc25pcHBldCB0byBjYWxjdWxhdGVcbiAqIGluZGljZXMgZnJvbSBvZmZzZXQsIGFuZCB1c2UgYGluZGljZXNUb09mZnNldCgpYCBmb3IgV0dTTCBjb2RlIHNuaXBwZXQgdG8gY2FsY3VsYXRlIG9mZnNldCBmcm9tIGluZGljZXMuXG4gKiAtIHRvIG1hbmlwdWxhdGUgYW4gaW5zdGFuY2Ugb2YgaW5kaWNlcywgdXNlIGBzZXRJbmRpY2VzKClgIGFuZCBgZ2V0SW5kaWNlcygpYCB0byBzZXQgYW5kIGdldCB0aGUgaW5kaWNlcyBvbiBhblxuICogaW5kaWNlcyB2YXJpYWJsZS5cbiAqIC0gdG8gbWFuaXB1bGF0ZSBkYXRhLCB1c2UgYHNldCgpYC9gZ2V0KClgIHRvIGFjY2VzcyBkYXRhIGF0IHRoZSBnaXZlbiBpbmRpY2VzIGZyb20gcGFyYW1ldGVyIGxpc3QsIHVzZVxuICogYHNldEJ5SW5kaWNlcygpYC9gZ2V0QnlJbmRpY2VzKClgIHRvIGFjY2VzcyBkYXRhIGF0IHRoZSBnaXZlbiBpbmRpY2VzIGZyb20gYW4gaW5kaWNlcyB2YXJpYWJsZSwgYW5kIHVzZVxuICogYHNldEJ5T2Zmc2V0KClgL2BnZXRCeU9mZnNldCgpYCB0byBhY2Nlc3MgZGF0YSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0LlxuICogLSBgaW1wbGA6IGdldCBXR1NMIGNvZGUgb2YgZnVuY3Rpb24gaW1wbGVtZW50YXRpb24gZm9yIHRoZSB1dGlsIGZ1bmN0aW9ucyBtZW50aW9uZWQgYWJvdmUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW5kaWNlc0hlbHBlciB7XG4gIC8qKlxuICAgKiBnZXQgV0dTTCBjb2RlIG9mIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uIGZvciB0aGUgdXRpbCBmdW5jdGlvbnMuXG4gICAqXG4gICAqL1xuICByZWFkb25seSBpbXBsOiAoKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGdldCB0eXBlIGluZm9cbiAgICovXG4gIHJlYWRvbmx5IHR5cGU6IEluZGljZXNIZWxwZXJUeXBlcztcblxuICAvKipcbiAgICogV0dTTCBjb2RlIG9mIGEgZXhwcmVzc2lvbiBmb3IgZ2V0dGluZyBpbmRpY2VzIGZyb20gb2Zmc2V0LlxuICAgKlxuICAgKiBAcGFyYW0gdmFyT2Zmc2V0IC0gYSB1MzIgZXhwcmVzc2lvbiByZXByZXNlbnRpbmcgdGhlIG9mZnNldC5cbiAgICpcbiAgICogQHJldHVybnMgYW4gYHR5cGUuaW5kaWNlc2AgZXhwcmVzc2lvblxuICAgKi9cbiAgcmVhZG9ubHkgb2Zmc2V0VG9JbmRpY2VzOiAodmFyT2Zmc2V0OiBzdHJpbmcpID0+IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCBjb2RlIG9mIGFuIGB1MzJgIGV4cHJlc3Npb24gZm9yIGdldHRpbmcgb2Zmc2V0IGZyb20gaW5kaWNlcy5cbiAgICpcbiAgICogQHBhcmFtIHZhckluZGljZXMgLSBhIGB0eXBlLmluZGljZXNgIGV4cHJlc3Npb24gcmVwcmVzZW50aW5nIHRoZSBpbmRpY2VzLlxuICAgKlxuICAgKiBAcmV0dXJucyBhbiBgdTMyYCBleHByZXNzaW9uXG4gICAqL1xuICByZWFkb25seSBpbmRpY2VzVG9PZmZzZXQ6ICh2YXJJbmRpY2VzOiBzdHJpbmcpID0+IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCBjb2RlIG9mIGFuIGB1MzJgIGV4cHJlc3Npb24gZm9yIGdldHRpbmcgb3JpZ2luYWwgb2Zmc2V0IGZyb20gYnJvYWRjYXN0ZWQgaW5kaWNlcy5cbiAgICpcbiAgICogQHBhcmFtIHZhckluZGljZXMgLSBhIGB0eXBlLmluZGljZXNgIGV4cHJlc3Npb24gcmVwcmVzZW50aW5nIHRoZSBvdXRwdXQgaW5kaWNlcy5cbiAgICogQHBhcmFtIG91dHB1dCAtIG91dHB1dCBJbmRpY2VzSGVscGVyLlxuICAgKlxuICAgKiBAcmV0dXJucyBhbiBgdTMyYCBleHByZXNzaW9uXG4gICAqL1xuICByZWFkb25seSBicm9hZGNhc3RlZEluZGljZXNUb09mZnNldDogKHZhckluZGljZXM6IHN0cmluZywgb3V0cHV0OiBJbmRpY2VzSGVscGVyKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBvZiBnZW5lcmF0aW5nIGFuIGluZGljZXMgbGl0ZXJhbFxuICAgKlxuICAgKiBAcGFyYW0gaW5pdCAtIGluaXRpYWwgdmFsdWUuXG4gICAqL1xuICByZWFkb25seSBpbmRpY2VzOiAoLi4uaW5pdDogUmVhZG9ubHlBcnJheTxudW1iZXIgfCBzdHJpbmc+KSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBvZiBhIHN0YXRlbWVudCBmb3Igc2V0dGluZyBpbmRpY2VzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFySW5kaWNlcyAtIGEgdmFyaWFibGUgbmFtZSBmb3IgdGhlIGluZGljZXMuXG4gICAqIEBwYXJhbSBpZHggLSB0aGUgaW5kZXggb2YgdGhlIGluZGljZXMgdG8gc2V0LiBjYW4gYmUgYSBudW1iZXIgb3IgYSBzdHJpbmcgKFdHU0wgYHUzMmAgZXhwcmVzc2lvbikuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBzZXQuIGNhbiBiZSBhIG51bWJlciBvciBhIHN0cmluZyAoV0dTTCBgdTMyYCBleHByZXNzaW9uKS5cbiAgICpcbiAgICogQHJldHVybnMgYSBXR1NMIHN0YXRlbWVudFxuICAgKi9cbiAgcmVhZG9ubHkgaW5kaWNlc1NldDogKHZhckluZGljZXM6IHN0cmluZywgaWR4OiBudW1iZXIgfCBzdHJpbmcsIHZhbHVlOiBudW1iZXIgfCBzdHJpbmcpID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBvZiBhbiBgdTMyYCBleHByZXNzaW9uIGZvciBnZXR0aW5nIGluZGljZXMuXG4gICAqXG4gICAqIEBwYXJhbSB2YXJJbmRpY2VzIC0gYSB2YXJpYWJsZSBuYW1lIGZvciB0aGUgaW5kaWNlcy5cbiAgICogQHBhcmFtIGlkeCAtIHRoZSBpbmRleCBvZiB0aGUgaW5kaWNlcyB0byBnZXQuIGNhbiBiZSBhIG51bWJlciBvciBhIHN0cmluZyAoV0dTTCBgdTMyYCBleHByZXNzaW9uKS5cbiAgICpcbiAgICogQHJldHVybnMgYW4gYHUzMmAgZXhwcmVzc2lvblxuICAgKi9cbiAgcmVhZG9ubHkgaW5kaWNlc0dldDogKHZhckluZGljZXM6IHN0cmluZywgaWR4OiBudW1iZXIgfCBzdHJpbmcpID0+IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCBjb2RlIGZvciBhIHN0YXRlbWVudCBmb3Igc2V0dGluZyBkYXRhIGF0IHRoZSBnaXZlbiBpbmRpY2VzLlxuICAgKlxuICAgKiBAcGFyYW0gaW5kaWNlc0FuZFZhbHVlIC0gYW4gYXJyYXkgb2YgbnVtYmVycyBvciBzdHJpbmdzIChXR1NMIGB1MzJgIGV4cHJlc3Npb24pIHJlcHJlc2VudGluZyB0aGUgaW5kaWNlcywgZm9sbG93ZWRcbiAgICogICAgIGJ5IHRoZSB2YWx1ZSB0byBzZXQuIFRoaXMgYXJyYXkgc2hvdWxkIGhhdmUgZXhhY3RseSBgc2hhcGUubGVuZ3RoICsgMWAgZWxlbWVudHMuXG4gICAqL1xuICByZWFkb25seSBzZXQ6ICguLi5pbmRpY2VzQW5kVmFsdWU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyIHwgc3RyaW5nPikgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgZm9yIGEgc3RhdGVtZW50IGZvciBzZXR0aW5nIGRhdGEgYXQgdGhlIGdpdmVuIGluZGljZXMgdmFyaWFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB2YXJJbmRpY2VzIC0gYSB2YXJpYWJsZSBuYW1lIGZvciB0aGUgaW5kaWNlcy5cbiAgICogQHBhcmFtIHZhbHVlIC0gdGhlIHZhbHVlIHRvIHNldC4gc2hvdWxkIGJlIGEgV0dTTCBleHByZXNzaW9uLlxuICAgKi9cbiAgcmVhZG9ubHkgc2V0QnlJbmRpY2VzOiAodmFySW5kaWNlczogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBmb3IgYSBzdGF0ZW1lbnQgZm9yIHNldHRpbmcgZGF0YSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0LlxuICAgKlxuICAgKiBAcGFyYW0gb2Zmc2V0IC0gYSBudW1iZXIgb3IgYSBzdHJpbmcgKFdHU0wgYHUzMmAgZXhwcmVzc2lvbikgcmVwcmVzZW50aW5nIHRoZSBvZmZzZXQuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBzZXQuIHNob3VsZCBiZSBhIFdHU0wgZXhwcmVzc2lvbi5cbiAgICovXG4gIHJlYWRvbmx5IHNldEJ5T2Zmc2V0OiAob2Zmc2V0OiBudW1iZXIgfCBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpID0+IHN0cmluZztcblxuICAvKipcbiAgICogV0dTTCBjb2RlIGZvciBhbiBleHByZXNzaW9uIGZvciBnZXR0aW5nIGRhdGEgYXQgdGhlIGdpdmVuIGluZGljZXMuXG4gICAqXG4gICAqIEBwYXJhbSBpbmRpY2VzIC0gYW4gYXJyYXkgb2YgbnVtYmVycyBvciBzdHJpbmdzIChXR1NMIGB1MzJgIGV4cHJlc3Npb24pIHJlcHJlc2VudGluZyB0aGUgaW5kaWNlcy5cbiAgICovXG4gIHJlYWRvbmx5IGdldDogKC4uLmluZGljZXM6IFJlYWRvbmx5QXJyYXk8bnVtYmVyIHwgc3RyaW5nPikgPT4gc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXR1NMIGNvZGUgZm9yIGFuIGV4cHJlc3Npb24gZm9yIGdldHRpbmcgZGF0YSBhdCB0aGUgZ2l2ZW4gaW5kaWNlcyB2YXJpYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHZhckluZGljZXMgLSBhIHZhcmlhYmxlIG5hbWUgZm9yIHRoZSBpbmRpY2VzLlxuICAgKi9cbiAgcmVhZG9ubHkgZ2V0QnlJbmRpY2VzOiAodmFySW5kaWNlczogc3RyaW5nKSA9PiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdHU0wgY29kZSBmb3IgYW4gZXhwcmVzc2lvbiBmb3IgZ2V0dGluZyBkYXRhIGF0IHRoZSBnaXZlbiBvZmZzZXQuXG4gICAqXG4gICAqIEBwYXJhbSBvZmZzZXQgLSBhIG51bWJlciBvciBhIHN0cmluZyAoV0dTTCBgdTMyYCBleHByZXNzaW9uKSByZXByZXNlbnRpbmcgdGhlIG9mZnNldC5cbiAgICovXG4gIHJlYWRvbmx5IGdldEJ5T2Zmc2V0OiAob2Zmc2V0OiBudW1iZXIgfCBzdHJpbmcpID0+IHN0cmluZztcblxuICAvKipcbiAgICogbmFtZSBvZiB0aGUgZGF0YSB2YXJpYWJsZVxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiB3aGV0aGVyIHRoZSBoZWxwZXIgaXMgZm9yIGFuIGlucHV0LCBhbiBvdXRwdXQgb3IgYW4gaW50ZXJuYWwgdmFyaWFibGUuXG4gICAqL1xuICByZWFkb25seSB1c2FnZTogJ2lucHV0JyB8ICdvdXRwdXQnIHwgJ2ludGVybmFsJztcblxuICAvKipcbiAgICogdGhlIHJhbmsgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cbiAgICovXG4gIHJlYWRvbmx5IHJhbms6IG51bWJlcjtcblxuICAvKipcbiAgICogYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YXJpYWJsZSBuYW1lIGZvciB0aGUgc2hhcGUgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cbiAgICovXG4gIHJlYWRvbmx5IHNoYXBlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFyaWFibGUgbmFtZSBmb3IgdGhlIHN0cmlkZXMgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cbiAgICovXG4gIHJlYWRvbmx5IHN0cmlkZXM6IHN0cmluZztcbn1cblxuY29uc3QgZ2V0V2dzbE1hcHBlZFR5cGUgPSAodHlwZTogbnVtYmVyLCBjb21wb25lbnRzOiAxIHwgMiB8IDMgfCA0KTogc3RyaW5nIHwgW3N0cmluZywgc3RyaW5nXSA9PiB7XG4gIGlmIChjb21wb25lbnRzID09PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd2ZWMzIGhhcyBzYW1lIGFsaWdubWVudCBhcyB2ZWM0LCB1c2UgdmVjNCBpbnN0ZWFkJyk7XG4gIH1cblxuICAvLyByZXR1cm4gdHlwZSBpcyBbIHN0b3JhZ2UgdHlwZSwgcnVudGltZSB0eXBlIF0gb3IgYSBzaW5nbGUgc3RyaW5nIGZvciBib3RoXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgRGF0YVR5cGUuZmxvYXQxNjpcbiAgICAgIHJldHVybiBjb21wb25lbnRzID4gMSA/IGB2ZWMke2NvbXBvbmVudHN9PGYxNj5gIDogJ2YxNic7XG4gICAgY2FzZSBEYXRhVHlwZS5mbG9hdDpcbiAgICAgIHJldHVybiBjb21wb25lbnRzID4gMSA/IGB2ZWMke2NvbXBvbmVudHN9PGYzMj5gIDogJ2YzMic7XG4gICAgY2FzZSBEYXRhVHlwZS5pbnQzMjpcbiAgICAgIHJldHVybiBjb21wb25lbnRzID4gMSA/IGB2ZWMke2NvbXBvbmVudHN9PGkzMj5gIDogJ2kzMic7XG4gICAgY2FzZSBEYXRhVHlwZS51aW50MzI6XG4gICAgICByZXR1cm4gY29tcG9uZW50cyA+IDEgPyBgdmVjJHtjb21wb25lbnRzfTx1MzI+YCA6ICd1MzInO1xuICAgIGNhc2UgRGF0YVR5cGUuaW50NjQ6XG4gICAgICBpZiAoY29tcG9uZW50cyA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjdXJyZW50bHkgbm90IHN1cHBvcnRlZCB2ZWNYIG9mIHVpbnQ2NCB5ZXQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbJ3ZlYzI8dTMyPicsICdpMzInXTtcbiAgICBjYXNlIERhdGFUeXBlLnVpbnQ2NDpcbiAgICAgIGlmIChjb21wb25lbnRzID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnRseSBub3Qgc3VwcG9ydGVkIHZlY1ggb2YgdWludDY0IHlldCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFsndmVjMjx1MzI+JywgJ3UzMiddO1xuICAgIGNhc2UgRGF0YVR5cGUuYm9vbDpcbiAgICAgIGlmIChjb21wb25lbnRzICE9PSA0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYm9vbCBtdXN0IGJlIHZlYzQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbJ3UzMicsICd2ZWM0PGJvb2w+J107XG4gICAgY2FzZSBEYXRhVHlwZS5pbnQ0OlxuICAgICAgcmV0dXJuICdpMzInO1xuICAgIGNhc2UgRGF0YVR5cGUudWludDQ6XG4gICAgICByZXR1cm4gJ3UzMic7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhIHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSA9ICh0eXBlOiBEYXRhVHlwZSwgY29tcG9uZW50czogMSB8IDIgfCAzIHwgNCA9IDEpID0+IHtcbiAgY29uc3QgbWFwcGVkVHlwZSA9IGdldFdnc2xNYXBwZWRUeXBlKHR5cGUsIGNvbXBvbmVudHMpO1xuICByZXR1cm4gdHlwZW9mIG1hcHBlZFR5cGUgPT09ICdzdHJpbmcnID8gbWFwcGVkVHlwZSA6IG1hcHBlZFR5cGVbMF07XG59O1xuXG5leHBvcnQgY29uc3QgdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZSA9ICh0eXBlOiBEYXRhVHlwZSwgY29tcG9uZW50czogMSB8IDIgfCAzIHwgNCA9IDEpID0+IHtcbiAgY29uc3QgbWFwcGVkVHlwZSA9IGdldFdnc2xNYXBwZWRUeXBlKHR5cGUsIGNvbXBvbmVudHMpO1xuICByZXR1cm4gdHlwZW9mIG1hcHBlZFR5cGUgPT09ICdzdHJpbmcnID8gbWFwcGVkVHlwZSA6IG1hcHBlZFR5cGVbMV07XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMgPSAoLi4uZGltczogUmVhZG9ubHlBcnJheTxyZWFkb25seSBudW1iZXJbXT4pOiBQcm9ncmFtVW5pZm9ybVtdID0+IHtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW107XG4gIGRpbXMuZm9yRWFjaCgoZGltKSA9PiB7XG4gICAgaWYgKGRpbS5sZW5ndGggIT09IDApIHtcbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKFxuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZGltIH0sXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBTaGFwZVV0aWwuY29tcHV0ZVN0cmlkZXMoZGltKSB9LFxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcHJvZ3JhbVVuaWZvcm1zO1xufTtcblxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0byBnZXQgbWF4aW11bSB2ZWN0b3Igc2l6ZSBmb3Igc3BlY2lmaWVkIGRhdGEgbGVuZ3RoXG4gKiBAcGFyYW0gc2l6ZVxuICovXG5leHBvcnQgY29uc3QgZ2V0TWF4Q29tcG9uZW50cyA9IChzaXplOiBudW1iZXIpID0+IHtcbiAgLy8gd2UgY2Fubm90IHVzZSB2ZWMzIHR5cGUgc2luY2UgaXQgaGFzIGFsaWdubWVudCBvZiAxNiBieXRlc1xuICBpZiAoc2l6ZSAlIDQgPT09IDApIHtcbiAgICByZXR1cm4gNDtcbiAgfSBlbHNlIGlmIChzaXplICUgMiA9PT0gMCkge1xuICAgIHJldHVybiAyO1xuICB9XG5cbiAgcmV0dXJuIDE7XG59O1xuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgaW5pdGlhbGl6ZXMgdmFyaWFibGUgYXMgYSBzY2FsYXIgb3IgdmVjdG9yLiBlLmcuIGYzMigwKSBvciB2ZWM0ZigwLDAsMCwwKVxuICogQHBhcmFtIGRhdGFUeXBlXG4gKiBAcGFyYW0gY29tcG9uZW50c1xuICogQHBhcmFtIHZhbHVlXG4gKi9cbmV4cG9ydCBjb25zdCBmaWxsVmVjdG9yID0gKGRhdGFUeXBlID0gJ2YzMicsIGNvbXBvbmVudHM/OiBudW1iZXIsIHZhbHVlID0gJzAnKSA9PiB7XG4gIGlmICghY29tcG9uZW50cyB8fCBjb21wb25lbnRzID09PSAxKSB7XG4gICAgcmV0dXJuIGAke2RhdGFUeXBlfSgke3ZhbHVlfSlgO1xuICB9XG5cbiAgcmV0dXJuIGB2ZWMke2NvbXBvbmVudHN9PCR7ZGF0YVR5cGV9Pigke3ZhbHVlfSlgO1xufTtcblxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IGNhc3RzIHZhbHVlIG9yIHZlY3RvciB0byBmMzJcbiAqIEBwYXJhbSBkYXRhVHlwZVxuICogQHBhcmFtIGNvbXBvbmVudHNcbiAqIEBwYXJhbSB2YWx1ZVxuICovXG5leHBvcnQgY29uc3QgY2FzdFRvRjMyID0gKGRhdGFUeXBlOiBzdHJpbmcsIGNvbXBvbmVudHM6IG51bWJlciwgdmFsdWU6IHN0cmluZykgPT4ge1xuICBpZiAoZGF0YVR5cGUgPT09ICdmMzInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChjb21wb25lbnRzID09PSAxKSB7XG4gICAgcmV0dXJuIGBmMzIoJHt2YWx1ZX0pYDtcbiAgfVxuXG4gIHJldHVybiBgdmVjJHtjb21wb25lbnRzfTxmMzI+KCR7dmFsdWV9KWA7XG59O1xuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBzY2FsYXIgb3Igc3VtcyBhbGwgY29tcG9uZW50cyBvZiBhIHZlY3RvclxuICogQHBhcmFtIG5hbWVcbiAqIEBwYXJhbSBjb21wb25lbnRzXG4gKi9cbmV4cG9ydCBjb25zdCBzdW1WZWN0b3IgPSAobmFtZTogc3RyaW5nLCBjb21wb25lbnRzOiBudW1iZXIpID0+IHtcbiAgaWYgKGNvbXBvbmVudHMgPT09IDQpIHtcbiAgICByZXR1cm4gYCgke25hbWV9LnggKyAke25hbWV9LnkgKyAke25hbWV9LnogKyAke25hbWV9LncpYDtcbiAgfSBlbHNlIGlmIChjb21wb25lbnRzID09PSAyKSB7XG4gICAgcmV0dXJuIGAoJHtuYW1lfS54ICsgJHtuYW1lfS55KWA7XG4gIH0gZWxzZSBpZiAoY29tcG9uZW50cyA9PT0gMykge1xuICAgIHJldHVybiBgKCR7bmFtZX0ueCArICR7bmFtZX0ueSArICR7bmFtZX0ueilgO1xuICB9XG5cbiAgcmV0dXJuIG5hbWU7XG59O1xuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB2YXJpYWJsZSBlbGVtZW50IGF0IGluZGV4LlxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBvZiB2YXJpYWJsZS5cbiAqIEBwYXJhbSBpbmRleCAtIHRoZSBpbmRleCBvZiB2YXJpYWJsZSBlbGVtZW50LlxuICogQHBhcmFtIGxlbmd0aCAtIHRoZSBsZW5ndGggb2YgdmFyaWFibGUuXG4gKiBAcGFyYW0gdHlwZSAtIHRoZSB0eXBlIG9mIHZhcmlhYmxlLCBvcHRpb25hbC5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEVsZW1lbnRBdCA9IChcbiAgbmFtZTogc3RyaW5nLFxuICBpbmRleDogbnVtYmVyIHwgc3RyaW5nLFxuICBsZW5ndGg6IG51bWJlcixcbiAgdHlwZT86IFVuaWZvcm1EYXRhRWxlbWVudFR5cGUsXG4pOiBzdHJpbmcgPT4ge1xuICBpZiAobmFtZS5zdGFydHNXaXRoKCd1bmlmb3Jtcy4nKSAmJiBsZW5ndGggPiA0KSB7XG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlID09PSAnZjE2Jykge1xuICAgICAgICByZXR1cm4gYCR7bmFtZX1bKCR7aW5kZXh9KSAvIDhdWygke2luZGV4fSkgJSA4IC8gNF1bKCR7aW5kZXh9KSAlIDggJSA0XWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYCR7bmFtZX1bKCR7aW5kZXh9KSAvIDRdWygke2luZGV4fSkgJSA0XWA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlID09PSAnZjE2Jykge1xuICAgICAgICByZXR1cm4gYCR7bmFtZX1bJHtNYXRoLmZsb29yKGluZGV4IC8gOCl9XVske01hdGguZmxvb3IoKGluZGV4ICUgOCkgLyA0KX1dWyR7KGluZGV4ICUgOCkgJSA0fV1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGAke25hbWV9WyR7TWF0aC5mbG9vcihpbmRleCAvIDQpfV1bJHtpbmRleCAlIDR9XWA7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBsZW5ndGggPiAxID8gYCR7bmFtZX1bJHtpbmRleH1dYCA6IG5hbWU7XG4gIH1cbn07XG5cbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGEgSW5kaWNlc0hlbHBlciBmb3IgYSBnaXZlbiBpbnB1dCBvciBvdXRwdXQuXG4gKlxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgaW5wdXQgb3Igb3V0cHV0LlxuICogQHBhcmFtIHRlbnNvclR5cGUgLSB0aGUgdGVuc29yIHR5cGUgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cbiAqIEBwYXJhbSBzaGFwZU9yUmFuayAtIHRoZSB0ZW5zb3Igc2hhcGUgb3IgdGhlIHJhbmsgb2YgdGhlIGlucHV0IG9yIG91dHB1dC5cbiAqIEBwYXJhbSB1c2FnZSAtIHRoZSB1c2FnZSBvZiB0aGUgaW5kaWNlcyBoZWxwZXIuXG4gKiBAcGFyYW0gY29tcG9uZW50cyAtIGluZGljYXRlcyB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgb2YgZWFjaCBlbGVtZW50LiAxIGZvciBzY2FsYXIsIDIgZm9yIHZlYzIsIDMgZm9yIHZlYzMsIDQgZm9yXG4gKiAgICB2ZWM0LlxuICovXG5jb25zdCBjcmVhdGVJbmRpY2VzSGVscGVyID0gKFxuICBuYW1lOiBzdHJpbmcsXG4gIHRlbnNvclR5cGU6IG51bWJlcixcbiAgc2hhcGVPclJhbms6IG51bWJlciB8IHJlYWRvbmx5IG51bWJlcltdLFxuICB1c2FnZTogSW5kaWNlc0hlbHBlclsndXNhZ2UnXSxcbiAgY29tcG9uZW50czogMSB8IDIgfCAzIHwgNCxcbik6IEluZGljZXNIZWxwZXIgPT4ge1xuICBjb25zdCB1c2VVbmlmb3JtID0gdHlwZW9mIHNoYXBlT3JSYW5rID09PSAnbnVtYmVyJztcbiAgY29uc3QgcmFuayA9IHVzZVVuaWZvcm0gPyBzaGFwZU9yUmFuayA6IHNoYXBlT3JSYW5rLmxlbmd0aDtcbiAgY29uc3QgcmFua0lkZW50aXR5ID0gWy4uLm5ldyBBcnJheShyYW5rKS5rZXlzKCldO1xuICBjb25zdCBpbmRpY2VzVHlwZSA9IHJhbmsgPCAyID8gJ3UzMicgOiByYW5rIDw9IDQgPyBgdmVjJHtyYW5rfTx1MzI+YCA6IGBhcnJheTx1MzIsICR7cmFua30+YDtcbiAgY29uc3QgbWFwcGVkVHlwZSA9IGdldFdnc2xNYXBwZWRUeXBlKHRlbnNvclR5cGUsIGNvbXBvbmVudHMpO1xuICBjb25zdCB2YWx1ZVR5cGUgPSB0eXBlb2YgbWFwcGVkVHlwZSA9PT0gJ3N0cmluZycgPyBtYXBwZWRUeXBlIDogbWFwcGVkVHlwZVsxXTtcbiAgY29uc3Qgc3RvcmFnZVR5cGUgPSB0eXBlb2YgbWFwcGVkVHlwZSA9PT0gJ3N0cmluZycgPyBtYXBwZWRUeXBlIDogbWFwcGVkVHlwZVswXTtcbiAgY29uc3QgdHlwZSA9IHsgaW5kaWNlczogaW5kaWNlc1R5cGUsIHZhbHVlOiB2YWx1ZVR5cGUsIHN0b3JhZ2U6IHN0b3JhZ2VUeXBlLCB0ZW5zb3I6IHRlbnNvclR5cGUgfTtcblxuICBjb25zdCBub3JtYWxpemVEaW0gPSAoZGltOiBudW1iZXIgfCBzdHJpbmcpOiBzdHJpbmcgPT4gKHR5cGVvZiBkaW0gPT09ICdzdHJpbmcnID8gZGltIDogYCR7ZGltfXVgKTtcblxuICBjb25zdCBpbXBsZW1lbnRhdGlvblVzZWQgPSB7XG4gICAgb2Zmc2V0VG9JbmRpY2VzOiBmYWxzZSxcbiAgICBpbmRpY2VzVG9PZmZzZXQ6IGZhbHNlLFxuICAgIGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0OiBmYWxzZSxcbiAgICBzZXQ6IGZhbHNlLFxuICAgIHNldEJ5SW5kaWNlczogZmFsc2UsXG4gICAgZ2V0OiBmYWxzZSxcbiAgICBnZXRCeUluZGljZXM6IGZhbHNlLFxuICB9O1xuXG4gIGNvbnN0IHVuaWZvcm1QcmVmaXggPSB1c2VVbmlmb3JtID8gJ3VuaWZvcm1zLicgOiAnJztcbiAgY29uc3Qgc2hhcGUgPSBgJHt1bmlmb3JtUHJlZml4fSR7bmFtZX1fc2hhcGVgO1xuICBjb25zdCBzdHJpZGVzID0gYCR7dW5pZm9ybVByZWZpeH0ke25hbWV9X3N0cmlkZXNgO1xuXG4gIGxldCBvMmlTbmlwcGV0ID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuayAtIDE7IGkrKykge1xuICAgIG8yaVNuaXBwZXQgKz0gYFxuICAgIGxldCBkaW0ke2l9ID0gY3VycmVudCAvICR7Z2V0RWxlbWVudEF0KHN0cmlkZXMsIGksIHJhbmspfTtcbiAgICBsZXQgcmVzdCR7aX0gPSBjdXJyZW50ICUgJHtnZXRFbGVtZW50QXQoc3RyaWRlcywgaSwgcmFuayl9O1xuICAgIGluZGljZXNbJHtpfV0gPSBkaW0ke2l9O1xuICAgIGN1cnJlbnQgPSByZXN0JHtpfTtcbiAgICBgO1xuICB9XG4gIG8yaVNuaXBwZXQgKz0gYGluZGljZXNbJHtyYW5rIC0gMX1dID0gY3VycmVudDtgO1xuXG4gIGNvbnN0IG9mZnNldFRvSW5kaWNlc0ltcGxlbWVudGF0aW9uID1cbiAgICByYW5rIDwgMlxuICAgICAgPyAnJ1xuICAgICAgOiBgXG4gIGZuIG8yaV8ke25hbWV9KG9mZnNldDogdTMyKSAtPiAke3R5cGUuaW5kaWNlc30ge1xuICAgIHZhciBpbmRpY2VzOiAke3R5cGUuaW5kaWNlc307XG4gICAgdmFyIGN1cnJlbnQgPSBvZmZzZXQ7XG4gICAgJHtvMmlTbmlwcGV0fVxuICAgIHJldHVybiBpbmRpY2VzO1xuICB9YDtcblxuICBjb25zdCBvZmZzZXRUb0luZGljZXMgPSAodmFyT2Zmc2V0OiBzdHJpbmcpID0+IHtcbiAgICBpbXBsZW1lbnRhdGlvblVzZWQub2Zmc2V0VG9JbmRpY2VzID0gdHJ1ZTtcbiAgICByZXR1cm4gcmFuayA8IDIgPyB2YXJPZmZzZXQgOiBgbzJpXyR7bmFtZX0oJHt2YXJPZmZzZXR9KWA7XG4gIH07XG5cbiAgY29uc3Qgb2Zmc2V0czogc3RyaW5nW10gPSBbXTtcbiAgaWYgKHJhbmsgPj0gMikge1xuICAgIGZvciAobGV0IGkgPSByYW5rIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIG9mZnNldHMucHVzaChgJHtnZXRFbGVtZW50QXQoc3RyaWRlcywgaSwgcmFuayl9ICogKGluZGljZXNbJHtpfV0pYCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgaW5kaWNlc1RvT2Zmc2V0SW1wbGVtZW50YXRpb24gPVxuICAgIHJhbmsgPCAyXG4gICAgICA/ICcnXG4gICAgICA6IGBcbiAgZm4gaTJvXyR7bmFtZX0oaW5kaWNlczogJHt0eXBlLmluZGljZXN9KSAtPiB1MzIge1xuICAgIHJldHVybiAke29mZnNldHMuam9pbignKycpfTtcbiAgfWA7XG5cbiAgY29uc3QgaW5kaWNlc1RvT2Zmc2V0ID0gKHZhckluZGljZXM6IHN0cmluZykgPT4ge1xuICAgIGltcGxlbWVudGF0aW9uVXNlZC5pbmRpY2VzVG9PZmZzZXQgPSB0cnVlO1xuICAgIHJldHVybiByYW5rIDwgMiA/IHZhckluZGljZXMgOiBgaTJvXyR7bmFtZX0oJHt2YXJJbmRpY2VzfSlgO1xuICB9O1xuXG4gIGNvbnN0IGluZGljZXMgPSAoLi4uaW5pdDogUmVhZG9ubHlBcnJheTxudW1iZXIgfCBzdHJpbmc+KSA9PlxuICAgIHJhbmsgPT09IDAgPyAnMHUnIDogYCR7dHlwZS5pbmRpY2VzfSgke2luaXQubWFwKG5vcm1hbGl6ZURpbSkuam9pbignLCcpfSlgO1xuXG4gIGNvbnN0IGluZGljZXNHZXQgPSAodmFySW5kaWNlczogc3RyaW5nLCBpZHg6IG51bWJlciB8IHN0cmluZykgPT4ge1xuICAgIGlmIChyYW5rIDwgMikge1xuICAgICAgcmV0dXJuIGAke3ZhckluZGljZXN9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGAke2dldEVsZW1lbnRBdCh2YXJJbmRpY2VzLCBpZHgsIHJhbmspfWA7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGluZGljZXNTZXQgPSAodmFySW5kaWNlczogc3RyaW5nLCBpZHg6IG51bWJlciB8IHN0cmluZywgdmFsdWU6IHN0cmluZykgPT4ge1xuICAgIGlmIChyYW5rIDwgMikge1xuICAgICAgcmV0dXJuIGAke3ZhckluZGljZXN9PSR7dmFsdWV9O2A7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBgJHtnZXRFbGVtZW50QXQodmFySW5kaWNlcywgaWR4LCByYW5rKX09JHt2YWx1ZX07YDtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXRJbXBsZW1lbnRhdGlvbjogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xuICBjb25zdCBicm9hZGNhc3RlZEluZGljZXNUb09mZnNldCA9ICh2YXJJbmRpY2VzOiBzdHJpbmcsIG91dHB1dDogSW5kaWNlc0hlbHBlcikgPT4ge1xuICAgIGltcGxlbWVudGF0aW9uVXNlZC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCA9IHRydWU7XG4gICAgY29uc3QgaW1wbEtleSA9IGAke291dHB1dC5uYW1lfWJyb2FkY2FzdGVkSW5kaWNlc1RvJHtuYW1lfU9mZnNldGA7XG4gICAgaWYgKGltcGxLZXkgaW4gYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXRJbXBsZW1lbnRhdGlvbikge1xuICAgICAgcmV0dXJuIGAke2ltcGxLZXl9KCR7dmFySW5kaWNlc30pYDtcbiAgICB9XG4gICAgY29uc3Qgb2Zmc2V0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSByYW5rIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGlkeCA9IG91dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRJbmRpY2VzJywgaSArIG91dHB1dC5yYW5rIC0gcmFuayk7XG4gICAgICBvZmZzZXRzLnB1c2goYCR7aW5kaWNlc0dldChzdHJpZGVzLCBpKX0gKiAoJHtpZHh9ICUgJHtpbmRpY2VzR2V0KHNoYXBlLCBpKX0pYCk7XG4gICAgfVxuICAgIGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0SW1wbGVtZW50YXRpb25baW1wbEtleV0gPSBgZm4gJHtpbXBsS2V5fShvdXRwdXRJbmRpY2VzOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiB1MzIge1xuICAgICAgICAgICAgIHJldHVybiAke29mZnNldHMubGVuZ3RoID4gMCA/IG9mZnNldHMuam9pbignKycpIDogJzB1J307XG4gICAgICAgICAgIH1gO1xuXG4gICAgcmV0dXJuIGAke2ltcGxLZXl9KCR7dmFySW5kaWNlc30pYDtcbiAgfTtcblxuICBjb25zdCBzZXRCeU9mZnNldCA9IChvZmZzZXQ6IG51bWJlciB8IHN0cmluZywgdmFsdWU6IHN0cmluZykgPT5cbiAgICAoKCkgPT4ge1xuICAgICAgaWYgKHR5cGUuc3RvcmFnZSA9PT0gdHlwZS52YWx1ZSkge1xuICAgICAgICByZXR1cm4gYCR7bmFtZX1bJHtvZmZzZXR9XT0ke3ZhbHVlfTtgO1xuICAgICAgfSBlbHNlIGlmICh0eXBlLnN0b3JhZ2UgPT09ICd2ZWMyPHUzMj4nICYmIHR5cGUudmFsdWUgPT09ICdpMzInKSB7XG4gICAgICAgIC8vIGludDY0LCBjb21wb25lbnRzID09PSAxXG4gICAgICAgIHJldHVybiBgJHtuYW1lfVske29mZnNldH1dPXZlYzI8dTMyPih1MzIoJHt2YWx1ZX0pLCBzZWxlY3QoMHUsIDB4RkZGRkZGRkZ1LCAke3ZhbHVlfSA8IDApKTtgO1xuICAgICAgfSBlbHNlIGlmICh0eXBlLnN0b3JhZ2UgPT09ICd2ZWMyPHUzMj4nICYmIHR5cGUudmFsdWUgPT09ICd1MzInKSB7XG4gICAgICAgIC8vIHVpbnQ2NCwgY29tcG9uZW50cyA9PT0gMVxuICAgICAgICByZXR1cm4gYCR7bmFtZX1bJHtvZmZzZXR9XT12ZWMyPHUzMj4odTMyKCR7dmFsdWV9KSwgMHUpO2A7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUuc3RvcmFnZSA9PT0gJ3UzMicgJiYgdHlwZS52YWx1ZSA9PT0gJ3ZlYzQ8Ym9vbD4nKSB7XG4gICAgICAgIC8vIGJvb2wsIGNvbXBvbmVudHMgPT09IDRcbiAgICAgICAgcmV0dXJuIGAke25hbWV9WyR7b2Zmc2V0fV09ZG90KHZlYzQ8dTMyPigweDEsIDB4MTAwLCAweDEwMDAwLCAweDEwMDAwMDApLCB2ZWM0PHUzMj4oJHt2YWx1ZX0pKTtgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGNvbWJpbmF0aW9uIG9mIHN0b3JhZ2UgdHlwZSAke3R5cGUuc3RvcmFnZX0gYW5kIHZhbHVlIHR5cGUgJHt0eXBlLnZhbHVlfSB5ZXRgKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuXG4gIGNvbnN0IGdldEJ5T2Zmc2V0ID0gKG9mZnNldDogbnVtYmVyIHwgc3RyaW5nKSA9PlxuICAgICgoKSA9PiB7XG4gICAgICBpZiAodHlwZS5zdG9yYWdlID09PSB0eXBlLnZhbHVlKSB7XG4gICAgICAgIHJldHVybiBgJHtuYW1lfVske29mZnNldH1dYDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZS5zdG9yYWdlID09PSAndmVjMjx1MzI+JyAmJiB0eXBlLnZhbHVlID09PSAnaTMyJykge1xuICAgICAgICAvLyBpbnQ2NCwgY29tcG9uZW50cyA9PT0gMVxuICAgICAgICByZXR1cm4gYGkzMigke25hbWV9WyR7b2Zmc2V0fV0ueClgO1xuICAgICAgfSBlbHNlIGlmICh0eXBlLnN0b3JhZ2UgPT09ICd2ZWMyPHUzMj4nICYmIHR5cGUudmFsdWUgPT09ICd1MzInKSB7XG4gICAgICAgIC8vIHVpbnQ2NCwgY29tcG9uZW50cyA9PT0gMVxuICAgICAgICByZXR1cm4gYHUzMigke25hbWV9WyR7b2Zmc2V0fV0ueClgO1xuICAgICAgfSBlbHNlIGlmICh0eXBlLnN0b3JhZ2UgPT09ICd1MzInICYmIHR5cGUudmFsdWUgPT09ICd2ZWM0PGJvb2w+Jykge1xuICAgICAgICAvLyBib29sLCBjb21wb25lbnRzID09PSA0XG4gICAgICAgIHJldHVybiBgdmVjNDxib29sPihib29sKCR7bmFtZX1bJHtvZmZzZXR9XSAmIDB4RkZ1KSwgYm9vbCgke25hbWV9WyR7b2Zmc2V0fV0gJiAweEZGMDB1KSwgYm9vbCgke25hbWV9WyR7XG4gICAgICAgICAgb2Zmc2V0XG4gICAgICAgIH1dICYgMHhGRjAwMDB1KSwgYm9vbCgke25hbWV9WyR7b2Zmc2V0fV0gJiAweEZGMDAwMDAwdSkpYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBjb21iaW5hdGlvbiBvZiBzdG9yYWdlIHR5cGUgJHt0eXBlLnN0b3JhZ2V9IGFuZCB2YWx1ZSB0eXBlICR7dHlwZS52YWx1ZX0geWV0YCk7XG4gICAgICB9XG4gICAgfSkoKTtcblxuICBjb25zdCBnZXRCeUluZGljZXNJbXBsZW1lbnRhdGlvbiA9XG4gICAgcmFuayA8IDJcbiAgICAgID8gJydcbiAgICAgIDogYFxuICBmbiBnZXRfJHtuYW1lfUJ5SW5kaWNlcyhpbmRpY2VzOiAke3R5cGUuaW5kaWNlc30pIC0+ICR7dmFsdWVUeXBlfSB7XG4gICAgcmV0dXJuICR7Z2V0QnlPZmZzZXQoYGkyb18ke25hbWV9KGluZGljZXMpYCl9O1xuICB9YDtcblxuICBjb25zdCBnZXRJbXBsZW1lbnRhdGlvbiA9XG4gICAgcmFuayA8IDJcbiAgICAgID8gJydcbiAgICAgIDogKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBmdW5jdGlvblBhcmFtcyA9IHJhbmtJZGVudGl0eS5tYXAoKGkpID0+IGBkJHtpfTogdTMyYCkuam9pbignLCAnKTtcbiAgICAgICAgICBjb25zdCBkaW1zUGFyYW1zID0gcmFua0lkZW50aXR5Lm1hcCgoaSkgPT4gYGQke2l9YCkuam9pbignLCAnKTtcbiAgICAgICAgICByZXR1cm4gYFxuICBmbiBnZXRfJHtuYW1lfSgke2Z1bmN0aW9uUGFyYW1zfSkgLT4gJHt2YWx1ZVR5cGV9IHtcbiAgICByZXR1cm4gZ2V0XyR7bmFtZX1CeUluZGljZXMoJHtpbmRpY2VzKGRpbXNQYXJhbXMpfSk7XG4gIH1gO1xuICAgICAgICB9KSgpO1xuXG4gIGNvbnN0IGdldCA9ICguLi5pbmRpY2VzOiBSZWFkb25seUFycmF5PG51bWJlciB8IHN0cmluZz4pID0+IHtcbiAgICBpZiAoaW5kaWNlcy5sZW5ndGggIT09IHJhbmspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW5kaWNlcyBsZW5ndGggbXVzdCBiZSAke3Jhbmt9YCk7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9ybWFsaXplZEluZGljZXMgPSBpbmRpY2VzLm1hcChub3JtYWxpemVEaW0pLmpvaW4oJywnKTtcblxuICAgIGlmIChyYW5rID09PSAwKSB7XG4gICAgICByZXR1cm4gZ2V0QnlPZmZzZXQoJzB1Jyk7XG4gICAgfSBlbHNlIGlmIChyYW5rID09PSAxKSB7XG4gICAgICByZXR1cm4gZ2V0QnlPZmZzZXQobm9ybWFsaXplZEluZGljZXNbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbXBsZW1lbnRhdGlvblVzZWQuZ2V0ID0gdHJ1ZTtcbiAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5nZXRCeUluZGljZXMgPSB0cnVlO1xuICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLmluZGljZXNUb09mZnNldCA9IHRydWU7XG4gICAgICByZXR1cm4gYGdldF8ke25hbWV9KCR7bm9ybWFsaXplZEluZGljZXN9KWA7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGdldEJ5SW5kaWNlcyA9ICh2YXJJbmRpY2VzOiBzdHJpbmcpID0+IHtcbiAgICBpZiAocmFuayA8IDIpIHtcbiAgICAgIHJldHVybiBnZXRCeU9mZnNldCh2YXJJbmRpY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLmdldEJ5SW5kaWNlcyA9IHRydWU7XG4gICAgICBpbXBsZW1lbnRhdGlvblVzZWQuaW5kaWNlc1RvT2Zmc2V0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBgZ2V0XyR7bmFtZX1CeUluZGljZXMoJHt2YXJJbmRpY2VzfSlgO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBzZXRCeUluZGljZXNJbXBsZW1lbnRhdGlvbiA9XG4gICAgcmFuayA8IDJcbiAgICAgID8gJydcbiAgICAgIDogYFxuICBmbiBzZXRfJHtuYW1lfUJ5SW5kaWNlcyhpbmRpY2VzOiAke3R5cGUuaW5kaWNlc30sIHZhbHVlOiAke3ZhbHVlVHlwZX0pIHtcbiAgICAke3NldEJ5T2Zmc2V0KGBpMm9fJHtuYW1lfShpbmRpY2VzKWAsICd2YWx1ZScpfVxuICB9YDtcblxuICBjb25zdCBzZXRJbXBsZW1lbnRhdGlvbiA9XG4gICAgcmFuayA8IDJcbiAgICAgID8gJydcbiAgICAgIDogKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBmdW5jdGlvblBhcmFtcyA9IHJhbmtJZGVudGl0eS5tYXAoKGkpID0+IGBkJHtpfTogdTMyYCkuam9pbignLCAnKTtcbiAgICAgICAgICBjb25zdCBkaW1zUGFyYW1zID0gcmFua0lkZW50aXR5Lm1hcCgoaSkgPT4gYGQke2l9YCkuam9pbignLCAnKTtcbiAgICAgICAgICByZXR1cm4gYFxuICBmbiBzZXRfJHtuYW1lfSgke2Z1bmN0aW9uUGFyYW1zfSwgdmFsdWU6ICR7dmFsdWVUeXBlfSkge1xuICAgIHNldF8ke25hbWV9QnlJbmRpY2VzKCR7aW5kaWNlcyhkaW1zUGFyYW1zKX0sIHZhbHVlKTtcbiAgfWA7XG4gICAgICAgIH0pKCk7XG5cbiAgY29uc3Qgc2V0ID0gKC4uLmluZGljZXNBbmRWYWx1ZTogUmVhZG9ubHlBcnJheTxudW1iZXIgfCBzdHJpbmc+KSA9PiB7XG4gICAgaWYgKGluZGljZXNBbmRWYWx1ZS5sZW5ndGggIT09IHJhbmsgKyAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGluZGljZXMgbGVuZ3RoIG11c3QgYmUgJHtyYW5rfWApO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IGluZGljZXNBbmRWYWx1ZVtyYW5rXTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YWx1ZSBtdXN0IGJlIHN0cmluZycpO1xuICAgIH1cblxuICAgIGNvbnN0IG5vcm1hbGl6ZWRJbmRpY2VzID0gaW5kaWNlc0FuZFZhbHVlLnNsaWNlKDAsIHJhbmspLm1hcChub3JtYWxpemVEaW0pLmpvaW4oJywnKTtcblxuICAgIGlmIChyYW5rID09PSAwKSB7XG4gICAgICByZXR1cm4gc2V0QnlPZmZzZXQoJzB1JywgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocmFuayA9PT0gMSkge1xuICAgICAgcmV0dXJuIHNldEJ5T2Zmc2V0KG5vcm1hbGl6ZWRJbmRpY2VzWzBdLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5zZXQgPSB0cnVlO1xuICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLnNldEJ5SW5kaWNlcyA9IHRydWU7XG4gICAgICBpbXBsZW1lbnRhdGlvblVzZWQuaW5kaWNlc1RvT2Zmc2V0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBgc2V0XyR7bmFtZX0oJHtub3JtYWxpemVkSW5kaWNlc30sICR7dmFsdWV9KWA7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHNldEJ5SW5kaWNlcyA9ICh2YXJJbmRpY2VzOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICBpZiAocmFuayA8IDIpIHtcbiAgICAgIHJldHVybiBzZXRCeU9mZnNldCh2YXJJbmRpY2VzLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGltcGxlbWVudGF0aW9uVXNlZC5zZXRCeUluZGljZXMgPSB0cnVlO1xuICAgICAgaW1wbGVtZW50YXRpb25Vc2VkLmluZGljZXNUb09mZnNldCA9IHRydWU7XG4gICAgICByZXR1cm4gYHNldF8ke25hbWV9QnlJbmRpY2VzKCR7dmFySW5kaWNlc30sICR7dmFsdWV9KTtgO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBpbXBsID0gKCkgPT4ge1xuICAgIGNvbnN0IGltcGxzID0gW107XG4gICAgbGV0IG5lZWRTaGFwZVN0cmlkZXMgPSBmYWxzZTtcbiAgICBpZiAoaW1wbGVtZW50YXRpb25Vc2VkLm9mZnNldFRvSW5kaWNlcykge1xuICAgICAgaW1wbHMucHVzaChvZmZzZXRUb0luZGljZXNJbXBsZW1lbnRhdGlvbik7XG4gICAgICBuZWVkU2hhcGVTdHJpZGVzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGltcGxlbWVudGF0aW9uVXNlZC5pbmRpY2VzVG9PZmZzZXQpIHtcbiAgICAgIGltcGxzLnB1c2goaW5kaWNlc1RvT2Zmc2V0SW1wbGVtZW50YXRpb24pO1xuICAgICAgbmVlZFNoYXBlU3RyaWRlcyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpbXBsZW1lbnRhdGlvblVzZWQuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQpIHtcbiAgICAgIE9iamVjdC52YWx1ZXMoYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXRJbXBsZW1lbnRhdGlvbikuZm9yRWFjaCgoaW1wbCkgPT4gaW1wbHMucHVzaChpbXBsKSk7XG4gICAgICBuZWVkU2hhcGVTdHJpZGVzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGltcGxlbWVudGF0aW9uVXNlZC5zZXQpIHtcbiAgICAgIGltcGxzLnB1c2goc2V0SW1wbGVtZW50YXRpb24pO1xuICAgICAgbmVlZFNoYXBlU3RyaWRlcyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpbXBsZW1lbnRhdGlvblVzZWQuc2V0QnlJbmRpY2VzKSB7XG4gICAgICBpbXBscy5wdXNoKHNldEJ5SW5kaWNlc0ltcGxlbWVudGF0aW9uKTtcbiAgICAgIG5lZWRTaGFwZVN0cmlkZXMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaW1wbGVtZW50YXRpb25Vc2VkLmdldCkge1xuICAgICAgaW1wbHMucHVzaChnZXRJbXBsZW1lbnRhdGlvbik7XG4gICAgICBuZWVkU2hhcGVTdHJpZGVzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGltcGxlbWVudGF0aW9uVXNlZC5nZXRCeUluZGljZXMpIHtcbiAgICAgIGltcGxzLnB1c2goZ2V0QnlJbmRpY2VzSW1wbGVtZW50YXRpb24pO1xuICAgICAgbmVlZFNoYXBlU3RyaWRlcyA9IHRydWU7XG4gICAgfVxuICAgIGlmICghdXNlVW5pZm9ybSAmJiBuZWVkU2hhcGVTdHJpZGVzKSB7XG4gICAgICBpbXBscy51bnNoaWZ0KFxuICAgICAgICBgY29uc3QgJHtzaGFwZX0gPSAke3R5cGUuaW5kaWNlc30oJHtzaGFwZU9yUmFuay5qb2luKCcsJyl9KTtgLFxuICAgICAgICBgY29uc3QgJHtzdHJpZGVzfSA9ICR7dHlwZS5pbmRpY2VzfSgke1NoYXBlVXRpbC5jb21wdXRlU3RyaWRlcyhzaGFwZU9yUmFuaykuam9pbignLCcpfSk7YCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBpbXBscy5qb2luKCdcXG4nKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGltcGwsXG4gICAgdHlwZSxcbiAgICBvZmZzZXRUb0luZGljZXMsXG4gICAgaW5kaWNlc1RvT2Zmc2V0LFxuICAgIGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0LFxuICAgIGluZGljZXMsXG4gICAgaW5kaWNlc0dldCxcbiAgICBpbmRpY2VzU2V0LFxuICAgIHNldCxcbiAgICBzZXRCeU9mZnNldCxcbiAgICBzZXRCeUluZGljZXMsXG4gICAgZ2V0LFxuICAgIGdldEJ5T2Zmc2V0LFxuICAgIGdldEJ5SW5kaWNlcyxcbiAgICAvLyBpc1ZlYzQsXG4gICAgdXNhZ2UsXG4gICAgbmFtZSxcbiAgICBzdHJpZGVzLFxuICAgIHNoYXBlLFxuICAgIHJhbmssXG4gIH07XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIEluZGljZXNIZWxwZXIgZm9yIGFuIGlucHV0LlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGlucHV0LlxuICogQHBhcmFtIHR5cGUgLSB0aGUgdGVuc29yIHR5cGUgb2YgdGhlIGlucHV0LlxuICogQHBhcmFtIHNoYXBlT3JSYW5rIC0gdGhlIHRlbnNvciBzaGFwZSBvciB0aGUgcmFuayBvZiB0aGUgaW5wdXQuXG4gKiBAcGFyYW0gY29tcG9uZW50cyAtIHRoZSBudW1iZXIgb2YgY29tcG9uZW50cyBvZiB0aGUgaW5wdXQuIGF2YWlsYWJsZSB2YWx1ZXMgYXJlIDEsIDIsIDMsIDQuIGRlZmF1bHQgaXMgMS5cbiAqIEByZXR1cm5zIGFuIEluZGljZXNIZWxwZXIgZm9yIHRoZSBpbnB1dC5cbiAqL1xuZXhwb3J0IGNvbnN0IGlucHV0VmFyaWFibGUgPSAoXG4gIG5hbWU6IHN0cmluZyxcbiAgdHlwZTogbnVtYmVyLFxuICBzaGFwZU9yUmFuazogbnVtYmVyIHwgcmVhZG9ubHkgbnVtYmVyW10sXG4gIGNvbXBvbmVudHM6IDEgfCAyIHwgMyB8IDQgPSAxLFxuKTogSW5kaWNlc0hlbHBlciA9PiBjcmVhdGVJbmRpY2VzSGVscGVyKG5hbWUsIHR5cGUsIHNoYXBlT3JSYW5rLCAnaW5wdXQnLCBjb21wb25lbnRzKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBJbmRpY2VzSGVscGVyIGZvciBhbiBvdXRwdXQuXG4gKlxuICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgb3V0cHV0LlxuICogQHBhcmFtIHR5cGUgLSB0aGUgdGVuc29yIHR5cGUgb2YgdGhlIG91dHB1dC5cbiAqIEBwYXJhbSBzaGFwZU9yUmFuayAtIHRoZSB0ZW5zb3Igc2hhcGUgb3IgdGhlIHJhbmsgb2YgdGhlIG91dHB1dC5cbiAqIEBwYXJhbSBjb21wb25lbnRzIC0gdGhlIG51bWJlciBvZiBjb21wb25lbnRzIG9mIHRoZSBvdXRwdXQuIGF2YWlsYWJsZSB2YWx1ZXMgYXJlIDEsIDIsIDMsIDQuIGRlZmF1bHQgaXMgMS5cbiAqIEByZXR1cm5zIGFuIEluZGljZXNIZWxwZXIgZm9yIHRoZSBvdXRwdXQuXG4gKi9cbmV4cG9ydCBjb25zdCBvdXRwdXRWYXJpYWJsZSA9IChcbiAgbmFtZTogc3RyaW5nLFxuICB0eXBlOiBudW1iZXIsXG4gIHNoYXBlT3JSYW5rOiBudW1iZXIgfCByZWFkb25seSBudW1iZXJbXSxcbiAgY29tcG9uZW50czogMSB8IDIgfCAzIHwgNCA9IDEsXG4pOiBJbmRpY2VzSGVscGVyID0+IGNyZWF0ZUluZGljZXNIZWxwZXIobmFtZSwgdHlwZSwgc2hhcGVPclJhbmssICdvdXRwdXQnLCBjb21wb25lbnRzKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBJbmRpY2VzSGVscGVyIGZvciBhbiBpbnRlcm5hbCB2YXJpYWJsZS5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZS5cbiAqIEBwYXJhbSB0eXBlIC0gdGhlIHRlbnNvciB0eXBlIG9mIHRoZSB2YXJpYWJsZS5cbiAqIEBwYXJhbSBzaGFwZU9yUmFuayAtIHRoZSB0ZW5zb3Igc2hhcGUgb3IgdGhlIHJhbmsgb2YgdGhlIHZhcmlhYmxlLlxuICogQHBhcmFtIGNvbXBvbmVudHMgLSB0aGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgb2YgdGhlIHZhcmlhYmxlLiBhdmFpbGFibGUgdmFsdWVzIGFyZSAxLCAyLCAzLCA0LiBkZWZhdWx0IGlzIDEuXG4gKiBAcmV0dXJucyBhbiBJbmRpY2VzSGVscGVyIGZvciB0aGUgdmFyaWFibGUuXG4gKi9cbmV4cG9ydCBjb25zdCBpbnRlcm5hbFZhcmlhYmxlID0gKFxuICBuYW1lOiBzdHJpbmcsXG4gIHR5cGU6IG51bWJlcixcbiAgc2hhcGVPclJhbms6IG51bWJlciB8IHJlYWRvbmx5IG51bWJlcltdLFxuICBjb21wb25lbnRzOiAxIHwgMiB8IDMgfCA0ID0gMSxcbik6IEluZGljZXNIZWxwZXIgPT4gY3JlYXRlSW5kaWNlc0hlbHBlcihuYW1lLCB0eXBlLCBzaGFwZU9yUmFuaywgJ2ludGVybmFsJywgY29tcG9uZW50cyk7XG5cbmV4cG9ydCB0eXBlIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUgPSAndTMyJyB8ICdmMTYnIHwgJ2YzMicgfCAnaTMyJztcbmV4cG9ydCB0eXBlIFVuaWZvcm1zQXJyYXlUeXBlID0gQXJyYXk8eyBuYW1lOiBzdHJpbmc7IHR5cGU6IFVuaWZvcm1EYXRhRWxlbWVudFR5cGU7IGxlbmd0aD86IG51bWJlciB9PjtcblxuLyoqXG4gKiBBIFNoYWRlckhlbHBlciBpcyBhIGhlbHBlciBjbGFzcyBmb3IgZ2VuZXJhdGluZyBXR1NMIGNvZGUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2hhZGVySGVscGVyIHtcbiAgLyoqXG4gICAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIHRoZSBzdGFydCBvZiBtYWluIGZ1bmN0aW9uIGluIFdHU0wgc291cmNlIGNvZGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICAgKiAgLi4uXG4gICAqXG4gICAqICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICogICAgLy8geW91ciBjb2RlIGhlcmUgaW5zaWRlIG1haW4oKSBmdW5jdGlvblxuICAgKiAgICAuLi5cbiAgICogIH1cbiAgICogYDtcbiAgICpcbiAgICogQHBhcmFtIHdvcmtncm91cFNpemUgLSBhbiBvcHRpb25hbCB3b3JrZ3JvdXAgc2l6ZS4gZGVmYXVsdCBpcyBXT1JLR1JPVVBfU0laRS5cbiAgICovXG4gIG1haW5TdGFydCh3b3JrZ3JvdXBTaXplPzogbnVtYmVyIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXJdKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byBnZW5lcmF0ZSB0aGUgY29kZSBzbmlwcGV0IGZvciBndWFyZGluZyBhZ2FpbnN0IG91dC1vZi1ib3VuZHMgc2l6ZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICAqICAuLi5cbiAgICpcbiAgICogICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgKiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKG91dHB1dFNpemUpfVxuICAgKlxuICAgKiAgICAvLyB5b3VyIGNvZGUgaGVyZSBpbnNpZGUgbWFpbigpIGZ1bmN0aW9uXG4gICAqICAgIC4uLlxuICAgKiAgfVxuICAgKiBgO1xuICAgKlxuICAgKiBAcGFyYW0gc2l6ZSAtIHRoZSBzaXplIG9mIHRoZSBkYXRhIHRvIGd1YXJkIGFnYWluc3QuIGNhbiBiZSBhIG51bWJlciBvciBhIHN0cmluZyAoV0dTTCBgdTMyYCBleHByZXNzaW9uKS5cbiAgICovXG4gIGd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoc2l6ZTogdW5rbm93bik6IHN0cmluZztcblxuICAvKipcbiAgICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgdGhlIGNvZGUgc25pcHBldCBmb3IgZGVjbGFyaW5nIG11bHRpcGxlIGlucHV0cyBvciBvdXRwdXRzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFyaWFibGVzIC0gYW4gYXJyYXkgb2YgSW5kaWNlc0hlbHBlciBmb3IgdGhlIHZhcmlhYmxlcy5cbiAgICovXG4gIGRlY2xhcmVWYXJpYWJsZXMoLi4udmFyaWFibGVzOiBJbmRpY2VzSGVscGVyW10pOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIHJlZ2lzdGVyIG9uZSB1bmlmb3JtLiBDYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHRvIHJlZ2lzdGVyIG11bHRpcGxlIHVuaWZvcm1zLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSB1bmlmb3JtLlxuICAgKiBAcGFyYW0gdHlwZSAtIHRoZSB0eXBlIG9mIHRoZSB1bmlmb3JtLlxuICAgKiBAcGFyYW0gbGVuZ3RoIC0gdGhlIGxlbmd0aCBvZiB0aGUgdW5pZm9ybSwgZGVmYXVsdCB0byAxIHdoZW4gaXQgaXMgbm90IHByb3ZpZGVkLlxuICAgKi9cbiAgcmVnaXN0ZXJVbmlmb3JtKG5hbWU6IHN0cmluZywgdHlwZTogc3RyaW5nLCBsZW5ndGg/OiBudW1iZXIpOiBTaGFkZXJIZWxwZXI7XG5cbiAgLyoqXG4gICAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIHJlZ2lzdGVyIG11bHRpcGxlIHVuaWZvcm1zLiBDYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHRvIHJlZ2lzdGVyIG11bHRpcGxlIHVuaWZvcm1zLlxuICAgKlxuICAgKiBAcGFyYW0gdW5pZm9ybXMgLSBhbiBhcnJheSBvZiB1bmlmb3Jtcy4gRWFjaCBlbGVtZW50IG9mIHRoZSBhcnJheSBpcyBhbiBvYmplY3Qgd2l0aCAyIHByb3BlcnRpZXM6IGBuYW1lYCBhbmRcbiAgICogICAgIGB0eXBlYC5cbiAgICovXG4gIHJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlKTogU2hhZGVySGVscGVyO1xuXG4gIC8qKlxuICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byByZWdpc3RlciBtdWx0aXBsZSBpbnRlcm5hbCB2YXJpYWJsZXMuIENhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgdG8gcmVnaXN0ZXIgbXVsdGlwbGVcbiAgICogaW50ZXJuYWwgdmFyaWFibGVzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFyaWFibGVzIC0gYW4gYXJyYXkgb2YgSW5kaWNlc0hlbHBlciBmb3IgdGhlIHZhcmlhYmxlcy5cbiAgICovXG4gIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoLi4udmFyaWFibGVzOiBJbmRpY2VzSGVscGVyW10pOiBTaGFkZXJIZWxwZXI7XG59XG5cbmNsYXNzIFNoYWRlckhlbHBlckltcGwgaW1wbGVtZW50cyBTaGFkZXJIZWxwZXIge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIG5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgcHJpdmF0ZSBsaW1pdHM6IEdQVVN1cHBvcnRlZExpbWl0cyxcbiAgKSB7fVxuXG4gIGd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoc2l6ZTogbnVtYmVyIHwgc3RyaW5nKTogc3RyaW5nIHtcbiAgICAvLyBHdWFyZCBhZ2FpbnN0IG91dC1vZi1ib3VuZHMgd29yayBncm91cCBzaXplc1xuICAgIGNvbnN0IHNpemVJbkNvZGUgPSB0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicgPyBgJHtzaXplfXVgIDogc2l6ZTtcbiAgICByZXR1cm4gYGlmIChnbG9iYWxfaWR4ID49ICR7c2l6ZUluQ29kZX0pIHsgcmV0dXJuOyB9YDtcbiAgfVxuXG4gIG1haW5TdGFydCh3b3JrZ3JvdXBTaXplOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBXT1JLR1JPVVBfU0laRSkge1xuICAgIGNvbnN0IHdvcmtncm91cFNpemVYID0gdHlwZW9mIHdvcmtncm91cFNpemUgPT09ICdudW1iZXInID8gd29ya2dyb3VwU2l6ZSA6IHdvcmtncm91cFNpemVbMF07XG4gICAgY29uc3Qgd29ya2dyb3VwU2l6ZVkgPSB0eXBlb2Ygd29ya2dyb3VwU2l6ZSA9PT0gJ251bWJlcicgPyAxIDogd29ya2dyb3VwU2l6ZVsxXTtcbiAgICBjb25zdCB3b3JrZ3JvdXBTaXplWiA9IHR5cGVvZiB3b3JrZ3JvdXBTaXplID09PSAnbnVtYmVyJyA/IDEgOiB3b3JrZ3JvdXBTaXplWzJdO1xuXG4gICAgaWYgKFxuICAgICAgd29ya2dyb3VwU2l6ZVggPiB0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVggfHxcbiAgICAgIHdvcmtncm91cFNpemVZID4gdGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVZIHx8XG4gICAgICB3b3JrZ3JvdXBTaXplWiA+IHRoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWlxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgd29ya2dyb3VwIHNpemUgWyR7d29ya2dyb3VwU2l6ZVh9LCAke3dvcmtncm91cFNpemVZfSwgJHtcbiAgICAgICAgICB3b3JrZ3JvdXBTaXplWlxuICAgICAgICB9XSBleGNlZWRzIHRoZSBtYXhpbXVtIHdvcmtncm91cCBzaXplIFske3RoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWH0sICR7XG4gICAgICAgICAgdGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVZXG4gICAgICAgIH0sICR7dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVafV0uYCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHdvcmtncm91cFNpemVYICogd29ya2dyb3VwU2l6ZVkgKiB3b3JrZ3JvdXBTaXplWiA+IHRoaXMubGltaXRzLm1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgd29ya2dyb3VwIHNpemUgWyR7d29ya2dyb3VwU2l6ZVh9LCAke3dvcmtncm91cFNpemVZfSwgJHtcbiAgICAgICAgICB3b3JrZ3JvdXBTaXplWlxuICAgICAgICB9XSBleGNlZWRzIHRoZSBtYXhpbXVtIHdvcmtncm91cCBpbnZvY2F0aW9ucyAke3RoaXMubGltaXRzLm1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cH0uYCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgaXMxRGltZW5zaW9uRGlzcGF0Y2ggPSB0aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzFdID09PSAxICYmIHRoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMl0gPT09IDE7XG4gICAgY29uc3QgcGFyYW1MaXN0ID0gaXMxRGltZW5zaW9uRGlzcGF0Y2hcbiAgICAgID8gYEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxfaWQgOiB2ZWMzPHUzMj4sXG4gICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBfaWQgOiB2ZWMzPHUzMj4sXG4gICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxfaWQgOiB2ZWMzPHUzMj5gXG4gICAgICA6IGBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsX2lkIDogdmVjMzx1MzI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxfaWQgOiB2ZWMzPHUzMj4sXG4gICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pbmRleCkgbG9jYWxfaWR4IDogdTMyLFxuICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKG51bV93b3JrZ3JvdXBzKSBudW1fd29ya2dyb3VwcyA6IHZlYzM8dTMyPmA7XG4gICAgY29uc3QgZ2xvYmFsSWR4RGVmaW5pdGlvbiA9IGlzMURpbWVuc2lvbkRpc3BhdGNoXG4gICAgICA/IGBsZXQgZ2xvYmFsX2lkeCA9IGdsb2JhbF9pZC54O1xuICAgICAgICAgbGV0IGxvY2FsX2lkeCA9IGxvY2FsX2lkLng7XG4gICAgICAgICBsZXQgd29ya2dyb3VwX2luZGV4ID0gd29ya2dyb3VwX2lkLng7YFxuICAgICAgOiBgbGV0IHdvcmtncm91cF9pbmRleCA9IHdvcmtncm91cF9pZC56ICogbnVtX3dvcmtncm91cHNbMF0gKiBudW1fd29ya2dyb3Vwc1sxXSArXG4gICAgICAgICAgICAgd29ya2dyb3VwX2lkLnkgKiBudW1fd29ya2dyb3Vwc1swXSArIHdvcmtncm91cF9pZC54O1xuICAgICAgICAgbGV0IGdsb2JhbF9pZHggPSB3b3JrZ3JvdXBfaW5kZXggKiAke3dvcmtncm91cFNpemVYICogd29ya2dyb3VwU2l6ZVkgKiB3b3JrZ3JvdXBTaXplWn11ICsgbG9jYWxfaWR4O2A7XG5cbiAgICByZXR1cm4gYEBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3dvcmtncm91cFNpemVYfSwgJHt3b3JrZ3JvdXBTaXplWX0sICR7d29ya2dyb3VwU2l6ZVp9KVxuICBmbiBtYWluKCR7cGFyYW1MaXN0fSkge1xuICAgICR7Z2xvYmFsSWR4RGVmaW5pdGlvbn1cbiAgYDtcbiAgfVxuXG4gIHByaXZhdGUgYXBwZW5kVmFyaWFibGVVbmlmb3Jtcyh2YXJpYWJsZTogSW5kaWNlc0hlbHBlcik6IHZvaWQge1xuICAgIGlmICh2YXJpYWJsZS5yYW5rICE9PSAwKSB7XG4gICAgICBpZiAodmFyaWFibGUuc2hhcGUuc3RhcnRzV2l0aCgndW5pZm9ybXMuJykpIHtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5wdXNoKHsgbmFtZTogdmFyaWFibGUuc2hhcGUucmVwbGFjZSgndW5pZm9ybXMuJywgJycpLCB0eXBlOiAndTMyJywgbGVuZ3RoOiB2YXJpYWJsZS5yYW5rIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHZhcmlhYmxlLnN0cmlkZXMuc3RhcnRzV2l0aCgndW5pZm9ybXMuJykpIHtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5wdXNoKHsgbmFtZTogdmFyaWFibGUuc3RyaWRlcy5yZXBsYWNlKCd1bmlmb3Jtcy4nLCAnJyksIHR5cGU6ICd1MzInLCBsZW5ndGg6IHZhcmlhYmxlLnJhbmsgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBkZWNsYXJlVmFyaWFibGUodmFyaWFibGU6IEluZGljZXNIZWxwZXIsIGJpbmRpbmdJbmRleDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICBpZiAodmFyaWFibGUudXNhZ2UgPT09ICdpbnRlcm5hbCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHVzZSBpbnRlcm5hbCB2YXJpYWJsZSB3aXRoIGRlY2xhcmVWYXJpYWJsZSgpLiB1c2UgcmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcygpIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIHRoaXMudmFyaWFibGVzLnB1c2godmFyaWFibGUpO1xuICAgIHRoaXMuYXBwZW5kVmFyaWFibGVVbmlmb3Jtcyh2YXJpYWJsZSk7XG5cbiAgICBjb25zdCBhY2Nlc3MgPSB2YXJpYWJsZS51c2FnZSA9PT0gJ2lucHV0JyA/ICdyZWFkJyA6ICdyZWFkX3dyaXRlJztcbiAgICBjb25zdCBzdG9yYWdlVHlwZSA9IHZhcmlhYmxlLnR5cGUuc3RvcmFnZTtcbiAgICByZXR1cm4gYEBncm91cCgwKSBAYmluZGluZygke2JpbmRpbmdJbmRleH0pIHZhcjxzdG9yYWdlLCAke2FjY2Vzc30+ICR7dmFyaWFibGUubmFtZX06IGFycmF5PCR7c3RvcmFnZVR5cGV9PjtgO1xuICB9XG5cbiAgZGVjbGFyZVZhcmlhYmxlcyguLi52YXJpYWJsZXM6IEluZGljZXNIZWxwZXJbXSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHZhcmlhYmxlcy5tYXAoKHYpID0+IHRoaXMuZGVjbGFyZVZhcmlhYmxlKHYsIHRoaXMudmFyaWFibGVJbmRleCsrKSkuam9pbignXFxuJyk7XG4gIH1cblxuICBwcml2YXRlIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZSh2YXJpYWJsZTogSW5kaWNlc0hlbHBlcik6IHZvaWQge1xuICAgIGlmICh2YXJpYWJsZS51c2FnZSAhPT0gJ2ludGVybmFsJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnY2Fubm90IHVzZSBpbnB1dCBvciBvdXRwdXQgdmFyaWFibGUgd2l0aCByZWdpc3RlckludGVybmFsVmFyaWFibGUoKS4gdXNlIGRlY2xhcmVWYXJpYWJsZXMoKSBpbnN0ZWFkLicsXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuaW50ZXJuYWxWYXJpYWJsZXMucHVzaCh2YXJpYWJsZSk7XG4gICAgdGhpcy5hcHBlbmRWYXJpYWJsZVVuaWZvcm1zKHZhcmlhYmxlKTtcbiAgfVxuXG4gIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoLi4udmFyaWFibGVzOiBJbmRpY2VzSGVscGVyW10pOiBTaGFkZXJIZWxwZXIge1xuICAgIHZhcmlhYmxlcy5mb3JFYWNoKCh2KSA9PiB0aGlzLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZSh2KSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZWdpc3RlclVuaWZvcm0obmFtZTogc3RyaW5nLCB0eXBlOiBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlLCBsZW5ndGggPSAxKTogU2hhZGVySGVscGVyIHtcbiAgICB0aGlzLnVuaWZvcm1zLnB1c2goeyBuYW1lLCB0eXBlLCBsZW5ndGggfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZWdpc3RlclVuaWZvcm1zKGFkZGl0aW9uYWxVbmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUpOiBTaGFkZXJIZWxwZXIge1xuICAgIHRoaXMudW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zLmNvbmNhdChhZGRpdGlvbmFsVW5pZm9ybXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcHJpdmF0ZSBpbnRlcm5hbFZhcmlhYmxlczogSW5kaWNlc0hlbHBlcltdID0gW107XG4gIHByaXZhdGUgdmFyaWFibGVzOiBJbmRpY2VzSGVscGVyW10gPSBbXTtcbiAgcHJpdmF0ZSB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXTtcbiAgcHJpdmF0ZSB1bmlmb3JtRGVjbGFyYXRpb24oKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy51bmlmb3Jtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBjb25zdCB1bmlmb3JtU25pcHBldHM6IHN0cmluZ1tdID0gW107XG4gICAgZm9yIChjb25zdCB7IG5hbWUsIHR5cGUsIGxlbmd0aCB9IG9mIHRoaXMudW5pZm9ybXMpIHtcbiAgICAgIGlmIChsZW5ndGggJiYgbGVuZ3RoID4gNCkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2YxNicpIHtcbiAgICAgICAgICB1bmlmb3JtU25pcHBldHMucHVzaChgQGFsaWduKDE2KSAke25hbWV9OmFycmF5PG1hdDJ4NDwke3R5cGV9PiwgJHtNYXRoLmNlaWwobGVuZ3RoIC8gOCl9PmApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVuaWZvcm1TbmlwcGV0cy5wdXNoKGAke25hbWV9OmFycmF5PHZlYzQ8JHt0eXBlfT4sICR7TWF0aC5jZWlsKGxlbmd0aCAvIDQpfT5gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdHlwZVRlbXAgPSBsZW5ndGggPT0gbnVsbCB8fCBsZW5ndGggPT09IDEgPyB0eXBlIDogYHZlYyR7bGVuZ3RofTwke3R5cGV9PmA7XG4gICAgICAgIHVuaWZvcm1TbmlwcGV0cy5wdXNoKGAke25hbWV9OiR7dHlwZVRlbXB9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGBcbiAgICAgIHN0cnVjdCBVbmlmb3JtcyB7ICR7dW5pZm9ybVNuaXBwZXRzLmpvaW4oJywgJyl9IH07XG4gICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoJHt0aGlzLnZhcmlhYmxlSW5kZXh9KSB2YXI8dW5pZm9ybT4gdW5pZm9ybXM6IFVuaWZvcm1zO2A7XG4gIH1cbiAgcHJpdmF0ZSB2YXJpYWJsZUluZGV4ID0gMDtcblxuICAvKipcbiAgICogR2V0IGFkZGl0aW9uYWwgaW1wbGVtZW50YXRpb24gdGhhdCBuZWVkcyB0byBiZSBhZGRlZCB0byB0aGUgc2hhZGVyIHNvdXJjZS5cbiAgICovXG4gIGdldCBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb25zKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMudW5pZm9ybURlY2xhcmF0aW9uKCkgK1xuICAgICAgdGhpcy52YXJpYWJsZXMubWFwKChpKSA9PiBpLmltcGwoKSkuam9pbignXFxuJykgK1xuICAgICAgdGhpcy5pbnRlcm5hbFZhcmlhYmxlcy5tYXAoKGkpID0+IGkuaW1wbCgpKS5qb2luKCdcXG4nKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB2YXJpYWJsZSBpbmZvIG9mIHRoZSBzaGFkZXIgcHJvZ3JhbS5cbiAgICovXG4gIGdldCB2YXJpYWJsZXNJbmZvKCk6IFByb2dyYW1Vbmlmb3JtVmFyaWFibGVJbmZvW10gfCB1bmRlZmluZWQge1xuICAgIGlmICh0aGlzLnVuaWZvcm1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCB1bmlmb3JtV2dzbFR5cGVUb0RhdGFUeXBlID0gKHR5cGU6IFVuaWZvcm1EYXRhRWxlbWVudFR5cGUpID0+XG4gICAgICBbRGF0YVR5cGUudWludDMyLCBEYXRhVHlwZS5mbG9hdDE2LCBEYXRhVHlwZS5mbG9hdCwgRGF0YVR5cGUuaW50MzJdW1sndTMyJywgJ2YxNicsICdmMzInLCAnaTMyJ10uaW5kZXhPZih0eXBlKV07XG4gICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubWFwKCh1KSA9PiBbdW5pZm9ybVdnc2xUeXBlVG9EYXRhVHlwZSh1LnR5cGUpLCB1Lmxlbmd0aCA/PyAxXSk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVNoYWRlckhlbHBlciA9IChkaXNwYXRjaEdyb3VwOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIGxpbWl0czogR1BVU3VwcG9ydGVkTGltaXRzKSA9PlxuICBuZXcgU2hhZGVySGVscGVySW1wbChkaXNwYXRjaEdyb3VwLCBsaW1pdHMpO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY29tZXMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vdGVuc29yZmxvdy90ZmpzL2Jsb2IvbWFzdGVyL3RmanMtY29yZS9zcmMvb3BzL2Jyb2FkY2FzdF91dGlsLnRzI0wxOC1MNDBcbiAqIFJldHVybnMgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGlucHV0IHNoYXBlIHRoYXQgYXJlIGJyb2FkY2FzdGVkIHRvXG4gKiBwcm9kdWNlIHRoZSBwcm92aWRlZCBvdXRwdXQgc2hhcGUuXG4gKlxuICogVGhlIHJldHVybmVkIGRpbWVuc2lvbnMgYXJlIDAtaW5kZXhlZCBhbmQgc29ydGVkLiBBbiBleGFtcGxlOlxuICogaW5TaGFwZSA9IFs0LCAxLCAzXVxuICogb3V0U2hhcGUgPSBbNSwgNCwgMywgM11cbiAqIHJlc3VsdCA9IFsxXS4gRGltZW5zaW9uIDEgKDJuZCBkaW1lbnNpb24gb2YgaW5wdXQpIGdldHMgYnJvYWRjYXN0ZWQgMSA9PiAzLlxuICovXG5leHBvcnQgY29uc3QgZ2V0QnJvYWRjYXN0RGltcyA9IChpblNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgb3V0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCBpblJhbmsgPSBpblNoYXBlLmxlbmd0aDtcbiAgY29uc3QgZGltczogbnVtYmVyW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpblJhbms7IGkrKykge1xuICAgIGNvbnN0IGRpbSA9IGluUmFuayAtIDEgLSBpO1xuICAgIGNvbnN0IGEgPSBpblNoYXBlW2RpbV0gfHwgMTtcbiAgICBjb25zdCBiID0gb3V0U2hhcGVbb3V0U2hhcGUubGVuZ3RoIC0gMSAtIGldIHx8IDE7XG4gICAgaWYgKGIgPiAxICYmIGEgPT09IDEpIHtcbiAgICAgIGRpbXMudW5zaGlmdChkaW0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGltcztcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgSW5kaWNlc0hlbHBlciwgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc3Bvc2VBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgcGVybTogbnVtYmVyW107XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9zZSByZXF1aXJlcyAxIGlucHV0LicpO1xuICB9XG59O1xuXG5jb25zdCBnZXRBZGp1c3RlZFBlcm0gPSAoaW5wdXRSYW5rOiBudW1iZXIsIHBlcm06IG51bWJlcltdKTogbnVtYmVyW10gPT5cbiAgcGVybSAmJiBwZXJtLmxlbmd0aCAhPT0gaW5wdXRSYW5rID8gWy4uLm5ldyBBcnJheShpbnB1dFJhbmspLmtleXMoKV0ucmV2ZXJzZSgpIDogcGVybTtcblxuY29uc3QgZ2V0T3V0cHV0U2hhcGUgPSAoaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHBlcm06IG51bWJlcltdKTogcmVhZG9ubHkgbnVtYmVyW10gPT5cbiAgU2hhcGVVdGlsLnNvcnRCYXNlZE9uUGVybShpbnB1dFNoYXBlLCBnZXRBZGp1c3RlZFBlcm0oaW5wdXRTaGFwZS5sZW5ndGgsIHBlcm0pKTtcblxuY29uc3QgcGVybUZ1bmN0aW9uQm9keSA9IChwZXJtOiBudW1iZXJbXSwgcmFuazogbnVtYmVyLCBpbnB1dDogSW5kaWNlc0hlbHBlciwgb3V0cHV0OiBJbmRpY2VzSGVscGVyKTogc3RyaW5nID0+IHtcbiAgbGV0IHJldmVyc2VGdW5jID0gYGZuIHBlcm0oaTogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gJHtpbnB1dC50eXBlLmluZGljZXN9IHtcbiAgICB2YXIgYTogJHtpbnB1dC50eXBlLmluZGljZXN9O2A7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgcmV2ZXJzZUZ1bmMgKz0gaW5wdXQuaW5kaWNlc1NldCgnYScsIHBlcm1baV0sIGBpWyR7aX1dYCk7XG4gIH1cbiAgcmV0dXJuIChyZXZlcnNlRnVuYyArPSAncmV0dXJuIGE7fScpO1xufTtcblxuY29uc3Qgc3F1ZWV6ZVNoYXBlID0gKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgYWRqdXN0ZWRQZXJtOiBudW1iZXJbXSk6IHsgbmV3U2hhcGU6IG51bWJlcltdOyBuZXdQZXJtOiBudW1iZXJbXSB9ID0+IHtcbiAgY29uc3QgbmV3U2hhcGU6IG51bWJlcltdID0gW107XG4gIGNvbnN0IG5ld1Blcm06IG51bWJlcltdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoc2hhcGVbaV0gIT09IDEpIHtcbiAgICAgIG5ld1NoYXBlLnB1c2goc2hhcGVbaV0pO1xuICAgIH1cbiAgICBpZiAoc2hhcGVbYWRqdXN0ZWRQZXJtW2ldXSAhPT0gMSkge1xuICAgICAgbmV3UGVybS5wdXNoKGFkanVzdGVkUGVybVtpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IG5ld1NoYXBlLCBuZXdQZXJtIH07XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8gPSAoaW5wdXRUZW5zb3I6IFRlbnNvclZpZXcsIHBlcm1BdHRyOiBudW1iZXJbXSk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaW5wdXREYXRhVHlwZSA9IGlucHV0VGVuc29yLmRhdGFUeXBlO1xuICBjb25zdCBpbnB1dFJhbmsgPSBpbnB1dFRlbnNvci5kaW1zLmxlbmd0aDtcbiAgY29uc3QgcGVybSA9IGdldEFkanVzdGVkUGVybShpbnB1dFJhbmssIHBlcm1BdHRyKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBnZXRPdXRwdXRTaGFwZShpbnB1dFRlbnNvci5kaW1zLCBwZXJtKTtcbiAgY29uc3QgeyBuZXdTaGFwZSwgbmV3UGVybSB9ID0gc3F1ZWV6ZVNoYXBlKGlucHV0VGVuc29yLmRpbXMsIHBlcm0pO1xuICBjb25zdCBjaGFubmVsc0xhc3QgPSBTaGFwZVV0aWwuYXJlRXF1YWwobmV3UGVybSwgWzIsIDMsIDFdKTtcbiAgY29uc3QgY2hhbm5lbHNGaXJzdCA9IFNoYXBlVXRpbC5hcmVFcXVhbChuZXdQZXJtLCBbMywgMSwgMl0pO1xuICBjb25zdCB1c2VTaGFyZWQgPSAobmV3U2hhcGUubGVuZ3RoID09PSAyICYmIG5ld1Blcm1bMF0gPiBuZXdQZXJtWzFdKSB8fCBjaGFubmVsc0xhc3QgfHwgY2hhbm5lbHNGaXJzdDtcbiAgbGV0IG5ld0lucHV0U2hhcGUgPSB1c2VTaGFyZWQgPyBuZXdTaGFwZSA6IGlucHV0VGVuc29yLmRpbXM7XG4gIGxldCBuZXdPdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlO1xuICBpZiAodXNlU2hhcmVkKSB7XG4gICAgbmV3SW5wdXRTaGFwZSA9IGNoYW5uZWxzTGFzdFxuICAgICAgPyBbbmV3U2hhcGVbMF0sIG5ld1NoYXBlWzFdICogbmV3U2hhcGVbMl1dXG4gICAgICA6IGNoYW5uZWxzRmlyc3RcbiAgICAgICAgPyBbbmV3U2hhcGVbMF0gKiBuZXdTaGFwZVsxXSwgbmV3U2hhcGVbMl1dXG4gICAgICAgIDogbmV3U2hhcGU7XG4gICAgbmV3T3V0cHV0U2hhcGUgPSBbbmV3SW5wdXRTaGFwZVsxXSwgbmV3SW5wdXRTaGFwZVswXV07XG4gIH1cbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdhJywgaW5wdXREYXRhVHlwZSwgbmV3SW5wdXRTaGFwZS5sZW5ndGgpO1xuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXREYXRhVHlwZSwgbmV3T3V0cHV0U2hhcGUubGVuZ3RoKTtcbiAgY29uc3QgdGlsZVNpemUgPSAxNjtcbiAgbGV0IGdldFNoYWRlclNvdXJjZTtcbiAgaWYgKHVzZVNoYXJlZCkge1xuICAgIGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dF9zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGUgOiBhcnJheTxhcnJheTwke291dHB1dC50eXBlLnZhbHVlfSwgJHt0aWxlU2l6ZSArIDF9PiwgJHt0aWxlU2l6ZX0+O1xuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoW3RpbGVTaXplLCB0aWxlU2l6ZSwgMV0pfVxuICAgIGxldCBzdHJpZGUgPSAodW5pZm9ybXMub3V0cHV0X3NoYXBlWzFdIC0gMSkgLyAke3RpbGVTaXplfSArIDE7XG4gICAgbGV0IHdvcmtncm91cF9pZF94ID0gd29ya2dyb3VwX2luZGV4ICUgc3RyaWRlO1xuICAgIGxldCB3b3JrZ3JvdXBfaWRfeSA9IHdvcmtncm91cF9pbmRleCAvIHN0cmlkZTtcbiAgICBsZXQgaW5wdXRfY29sID0gd29ya2dyb3VwX2lkX3kgKiAke3RpbGVTaXplfXUgKyBsb2NhbF9pZC54O1xuICAgIGxldCBpbnB1dF9yb3cgPSB3b3JrZ3JvdXBfaWRfeCAqICR7dGlsZVNpemV9dSArIGxvY2FsX2lkLnk7XG4gICAgaWYgKGlucHV0X3JvdyA8IHVuaWZvcm1zLmFfc2hhcGVbMF0gJiYgaW5wdXRfY29sIDwgdW5pZm9ybXMuYV9zaGFwZVsxXSkge1xuICAgICAgdGlsZVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKGAke2lucHV0LnR5cGUuaW5kaWNlc30oaW5wdXRfcm93LCBpbnB1dF9jb2wpYCl9O1xuICAgIH1cbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICBsZXQgb3V0cHV0X2NvbCA9IHdvcmtncm91cF9pZF94ICogJHt0aWxlU2l6ZX11ICsgbG9jYWxfaWQueDtcbiAgICBsZXQgb3V0cHV0X3JvdyA9IHdvcmtncm91cF9pZF95ICogJHt0aWxlU2l6ZX11ICsgbG9jYWxfaWQueTtcbiAgICBpZiAob3V0cHV0X3JvdyA8IHVuaWZvcm1zLm91dHB1dF9zaGFwZVswXSAmJiBvdXRwdXRfY29sIDwgdW5pZm9ybXMub3V0cHV0X3NoYXBlWzFdKSB7XG4gICAgICAke291dHB1dC5zZXRCeUluZGljZXMoYCR7b3V0cHV0LnR5cGUuaW5kaWNlc30ob3V0cHV0X3Jvdywgb3V0cHV0X2NvbClgLCAndGlsZVtsb2NhbF9pZC54XVtsb2NhbF9pZC55XScpfVxuICAgIH1cbiAgfWA7XG4gIH0gZWxzZSB7XG4gICAgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0X3NpemUnLCAndTMyJykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cblxuICAke3Blcm1GdW5jdGlvbkJvZHkocGVybSwgaW5wdXRSYW5rLCBpbnB1dCwgb3V0cHV0KX1cblxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuXG4gICAgbGV0IGluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgbGV0IGFJbmRpY2VzID0gcGVybShpbmRpY2VzKTtcblxuICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgaW5wdXQuZ2V0QnlJbmRpY2VzKCdhSW5kaWNlcycpKX1cbiAgfWA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiB1c2VTaGFyZWQgPyAnVHJhbnNwb3NlU2hhcmVkJyA6ICdUcmFuc3Bvc2UnLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke3Blcm1BdHRyfWAsIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXSB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+IHtcbiAgICAgIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0VGVuc29yLmRhdGFUeXBlIH1dLFxuICAgICAgICBkaXNwYXRjaEdyb3VwOiB1c2VTaGFyZWRcbiAgICAgICAgICA/IHsgeDogTWF0aC5jZWlsKG5ld091dHB1dFNoYXBlWzFdIC8gdGlsZVNpemUpLCB5OiBNYXRoLmNlaWwobmV3T3V0cHV0U2hhcGVbMF0gLyB0aWxlU2l6ZSkgfVxuICAgICAgICAgIDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgICBwcm9ncmFtVW5pZm9ybXM6IFtcbiAgICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgICAgICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG5ld0lucHV0U2hhcGUsIG5ld091dHB1dFNoYXBlKSxcbiAgICAgICAgXSxcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgdHJhbnNwb3NlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBUcmFuc3Bvc2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCBhdHRyaWJ1dGVzLnBlcm0pKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVRyYW5zcG9zZUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBUcmFuc3Bvc2VBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IHBlcm06IGF0dHJpYnV0ZXMucGVybSBhcyBudW1iZXJbXSB9KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1TaGFkZXJDYWNoZUluZm8gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgeyBjcmVhdGVSZWR1Y2VBdHRyaWJ1dGVzRnJvbUlucHV0cywgUmVkdWNlQXR0cmlidXRlcyB9IGZyb20gJy4vcmVkdWNlJztcbmltcG9ydCB7IGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvIH0gZnJvbSAnLi90cmFuc3Bvc2UnO1xuXG5jb25zdCByZWR1Y2VPcHM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gIG1heDogJ3NlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlID4gYmVzdFZhbHVlKScsXG4gIG1pbjogJ3NlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlIDwgYmVzdFZhbHVlKScsXG4gIG1lYW46ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxuICBzdW06ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxuICBwcm9kOiAnYmVzdFZhbHVlICogY2FuZGlkYXRlJyxcbiAgc3VtU3F1YXJlOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlICogY2FuZGlkYXRlJyxcbiAgbG9nU3VtRXhwOiAnYmVzdFZhbHVlICsgZXhwKGNhbmRpZGF0ZSknLFxuICBsMTogJ2Jlc3RWYWx1ZSArIGFicyhjYW5kaWRhdGUpJyxcbiAgbDI6ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUgKiBjYW5kaWRhdGUnLFxuICBsb2dTdW06ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxufTtcblxuY29uc3QgcmVkdWNlU2hhcmVkT3BzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge1xuICBtYXg6ICdzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA+IGJlc3RWYWx1ZSknLFxuICBtaW46ICdzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA8IGJlc3RWYWx1ZSknLFxuICBtZWFuOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJyxcbiAgc3VtOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJyxcbiAgcHJvZDogJ2Jlc3RWYWx1ZSAqIGNhbmRpZGF0ZScsXG4gIHN1bVNxdWFyZTogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXG4gIGxvZ1N1bUV4cDogJ2Jlc3RWYWx1ZSArIGNhbmRpZGF0ZScsXG4gIGwxOiAnYmVzdFZhbHVlICsgY2FuZGlkYXRlJyxcbiAgbDI6ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxuICBsb2dTdW06ICdiZXN0VmFsdWUgKyBjYW5kaWRhdGUnLFxufTtcblxuY29uc3QgcmVkdWNlSW5pdFZhbHVlczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcbiAgbWF4OiAnX0Fbb2Zmc2V0XScsXG4gIG1pbjogJ19BW29mZnNldF0nLFxuICBtZWFuOiAnMCcsXG4gIHN1bTogJzAnLFxuICBwcm9kOiAnMScsXG4gIHN1bVNxdWFyZTogJzAnLFxuICBsb2dTdW1FeHA6ICcwJyxcbiAgbDE6ICcwJyxcbiAgbDI6ICcwJyxcbiAgbG9nU3VtOiAnMCcsXG59O1xuXG5jb25zdCByZWR1Y2VPdXRwdXRWYWx1ZXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gIG1heDogJ2Jlc3RWYWx1ZScsXG4gIG1pbjogJ2Jlc3RWYWx1ZScsXG4gIHN1bTogJ2Jlc3RWYWx1ZScsXG4gIHByb2Q6ICdiZXN0VmFsdWUnLFxuICBzdW1TcXVhcmU6ICdiZXN0VmFsdWUnLFxuICBsb2dTdW1FeHA6ICdsb2coYmVzdFZhbHVlKScsXG4gIGwxOiAnYmVzdFZhbHVlJyxcbiAgbDI6ICdzcXJ0KGJlc3RWYWx1ZSknLFxuICBsb2dTdW06ICdsb2coYmVzdFZhbHVlKScsXG59O1xuXG5jb25zdCBnZXRJbm5lck1vc3RBeGVzID0gKG51bUlubmVyQXhlczogbnVtYmVyLCByYW5rOiBudW1iZXIpOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gcmFuayAtIG51bUlubmVyQXhlczsgaSA8IHJhbms7ICsraSkge1xuICAgIHJlcy5wdXNoKGkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5jb25zdCBjb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzID0gKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgYXhlczogcmVhZG9ubHkgbnVtYmVyW10pOiBbbnVtYmVyW10sIG51bWJlcltdXSA9PiB7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gW107XG4gIGNvbnN0IHJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IHJhbms7IGRpbSsrKSB7XG4gICAgaWYgKGF4ZXMuaW5kZXhPZihkaW0pID09PSAtMSkge1xuICAgICAgb3V0cHV0U2hhcGUucHVzaChzaGFwZVtkaW1dKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVkdWNlU2hhcGUgPSBheGVzLm1hcCgoZGltKSA9PiBzaGFwZVtkaW1dKTtcbiAgcmV0dXJuIFtvdXRwdXRTaGFwZSwgcmVkdWNlU2hhcGVdO1xufTtcblxuY29uc3QgZXhwYW5kU2hhcGVUb0tlZXBEaW0gPSAoc2hhcGU6IG51bWJlcltdLCBheGVzOiBudW1iZXJbXSk6IG51bWJlcltdID0+IHtcbiAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aCArIGF4ZXMubGVuZ3RoO1xuICBjb25zdCBleHBhbmRTaGFwZSA9IFtdO1xuICBsZXQgc2hhcGVJZHggPSAwO1xuICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCByYW5rOyBkaW0rKykge1xuICAgIGlmIChheGVzLmluZGV4T2YoZGltKSA9PT0gLTEpIHtcbiAgICAgIGV4cGFuZFNoYXBlLnB1c2goc2hhcGVbc2hhcGVJZHgrK10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBhbmRTaGFwZS5wdXNoKDEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXhwYW5kU2hhcGU7XG59O1xuXG5jb25zdCBhcmVBeGVzSW5uZXJNb3N0RGltcyA9IChheGVzOiBudW1iZXJbXSwgcmFuazogbnVtYmVyKTogYm9vbGVhbiA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChheGVzW2F4ZXMubGVuZ3RoIC0gaSAtIDFdICE9PSByYW5rIC0gMSAtIGkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBnZXRBeGVzUGVybXV0YXRpb24gPSAoYXhlczogbnVtYmVyW10sIHJhbms6IG51bWJlcik6IG51bWJlcltdID0+IHtcbiAgY29uc3QgcmVzID0gW107XG4gIGlmICghYXJlQXhlc0lubmVyTW9zdERpbXMoYXhlcywgcmFuaykpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbms7ICsraSkge1xuICAgICAgaWYgKGF4ZXMuaW5kZXhPZihpKSA9PT0gLTEpIHtcbiAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICB9XG4gICAgfVxuICAgIGF4ZXMuZm9yRWFjaCgoYXhpcykgPT4gcmVzLnB1c2goYXhpcykpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlUmVkdWNlU2hhcmVkUHJvZ3JhbUluZm8gPSAoXG4gIG5hbWU6IHN0cmluZyxcbiAgc2hhZGVyQ2FjaGU6IFByb2dyYW1TaGFkZXJDYWNoZUluZm8sXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICByZWR1Y2VUeXBlOiBzdHJpbmcsXG4gIG91dHB1dERhdGFUeXBlOiBEYXRhVHlwZSxcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdLFxuICByZWR1Y2VTaGFwZTogbnVtYmVyW10sXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcblxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICBjb25zdCByZWR1Y2VTaXplID0gU2hhcGVVdGlsLnNpemUocmVkdWNlU2hhcGUpO1xuXG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnX0EnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0U2hhcGUpO1xuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0Jywgb3V0cHV0RGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcblxuICBjb25zdCB3b3JrZ3JvdXBTaXplID0gMzI7XG5cbiAgY29uc3Qgc2hhcmVkTWVtb3J5U25pcHBldCA9IGBcbiAgICAgICAgICB2YXI8d29ya2dyb3VwPiBhQmVzdFZhbHVlcyA6IGFycmF5PGYzMiwgJHt3b3JrZ3JvdXBTaXplfT47XG4gICAgICAgYDtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdyZWR1Y2VTaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG4gICAgICAgICR7c2hhcmVkTWVtb3J5U25pcHBldH1cbiAgICAgICAgZm4gRElWX0NFSUwoYSA6IHUzMiwgYiA6IHUzMikgLT4gdTMyIHtcbiAgICAgICAgICByZXR1cm4gKChhIC0gMXUpIC8gYiArIDF1KTtcbiAgICAgICAgIH1cbiAgICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCh3b3JrZ3JvdXBTaXplKX1cblxuICAgICAgICAgIGxldCBvdXRwdXRJbmRleCA9IGdsb2JhbF9pZHggLyAke3dvcmtncm91cFNpemV9O1xuICAgICAgICAgIGxldCBvZmZzZXQgPSBvdXRwdXRJbmRleCAqIHVuaWZvcm1zLnJlZHVjZVNpemU7XG5cbiAgICAgICAgICB2YXIgYmVzdFZhbHVlID0gZjMyKCR7cmVkdWNlSW5pdFZhbHVlc1tyZWR1Y2VUeXBlXX0pO1xuICAgICAgICAgIGxldCBMZW5ndGggPSB1bmlmb3Jtcy5yZWR1Y2VTaXplO1xuICAgICAgICAgIGZvciAodmFyIGsgPSBsb2NhbF9pZHg7IGsgPCBMZW5ndGg7IGsgPSBrICsgJHt3b3JrZ3JvdXBTaXplfSkge1xuICAgICAgICAgICBsZXQgY2FuZGlkYXRlID0gZjMyKCR7aW5wdXQuZ2V0QnlPZmZzZXQoJ29mZnNldCArIGsnKX0pO1xuICAgICAgICAgICBiZXN0VmFsdWUgPSAke3JlZHVjZU9wc1tyZWR1Y2VUeXBlXX07XG4gICAgICAgICAgfVxuICAgICAgICAgIGFCZXN0VmFsdWVzW2xvY2FsX2lkeF0gPSBiZXN0VmFsdWU7XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IG1pbihMZW5ndGgsICR7d29ya2dyb3VwU2l6ZX11KTtcbiAgICAgICAgIGZvciAodmFyIGN1cnJlbnRTaXplID0gcmVkdWNlU2l6ZSAvIDJ1OyByZWR1Y2VTaXplID4gMXU7XG4gICAgICAgICAgICAgY3VycmVudFNpemUgPSByZWR1Y2VTaXplIC8gMnUpIHtcbiAgICAgICAgICAgbGV0IGludGVydmFsID0gRElWX0NFSUwocmVkdWNlU2l6ZSwgMnUpO1xuICAgICAgICAgICBpZiAobG9jYWxfaWR4IDwgY3VycmVudFNpemUpIHtcbiAgICAgICAgICAgIGxldCBjYW5kaWRhdGUgPSBhQmVzdFZhbHVlc1tsb2NhbF9pZHggKyBpbnRlcnZhbF07XG4gICAgICAgICAgICBiZXN0VmFsdWUgPSAke3JlZHVjZVNoYXJlZE9wc1tyZWR1Y2VUeXBlXX07XG4gICAgICAgICAgICBhQmVzdFZhbHVlc1tsb2NhbF9pZHhdID0gYmVzdFZhbHVlO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIHJlZHVjZVNpemUgPSBpbnRlcnZhbDtcbiAgICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAobG9jYWxfaWR4ID09IDB1KSB7XG4gICAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoXG4gICAgICAgICAgICAnb3V0cHV0SW5kZXgnLFxuICAgICAgICAgICAgYCR7XG4gICAgICAgICAgICAgIHJlZHVjZVR5cGUgPT09ICdtZWFuJ1xuICAgICAgICAgICAgICAgID8gYCR7b3V0cHV0LnR5cGUuc3RvcmFnZX0oYmVzdFZhbHVlIC8gZjMyKHVuaWZvcm1zLnJlZHVjZVNpemUpKWBcbiAgICAgICAgICAgICAgICA6IGAke291dHB1dC50eXBlLnN0b3JhZ2V9KCR7cmVkdWNlT3V0cHV0VmFsdWVzW3JlZHVjZVR5cGVdfSlgXG4gICAgICAgICAgICB9YCxcbiAgICAgICAgICApfTtcbiAgICAgICAgIH1cbiAgICAgICAgfWA7XG5cbiAgLy8gT25lIHdvcmsgZ3JvdXAgaXMgcmVzcG9uc2libGUgZm9yIG9ubHkgb25lIGVsZW1lbnQgb2Ygb3V0cHV0LlxuICByZXR1cm4ge1xuICAgIG5hbWUsXG4gICAgc2hhZGVyQ2FjaGUsXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IG91dHB1dERhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBvdXRwdXRTaXplIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXM6IFt7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcmVkdWNlU2l6ZSB9XSxcbiAgICB9KSxcbiAgfTtcbn07XG5cbmNvbnN0IHJlZHVjZUNvbW1vbiA9IChcbiAgY29udGV4dDogQ29tcHV0ZUNvbnRleHQsXG4gIG5hbWU6IHN0cmluZyxcbiAgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyxcbiAgcmVkdWNlVHlwZTogJ3N1bScgfCAnc3VtU3F1YXJlJyB8ICdwcm9kJyB8ICdtaW4nIHwgJ21heCcgfCAnbWVhbicgfCAnbG9nU3VtRXhwJyB8ICdsMScgfCAnbDInIHwgJ2xvZ1N1bScsXG4pOiB2b2lkID0+IHtcbiAgY29uc3QgdXBkYXRlZEF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMgPVxuICAgIGNvbnRleHQuaW5wdXRzLmxlbmd0aCA9PT0gMSA/IGF0dHJpYnV0ZXMgOiBjcmVhdGVSZWR1Y2VBdHRyaWJ1dGVzRnJvbUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG5cbiAgbGV0IHVwZGF0ZWRBeGVzID0gdXBkYXRlZEF0dHJpYnV0ZXMuYXhlcztcbiAgaWYgKHVwZGF0ZWRBeGVzLmxlbmd0aCA9PT0gMCAmJiAhdXBkYXRlZEF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpIHtcbiAgICB1cGRhdGVkQXhlcyA9IGNvbnRleHQuaW5wdXRzWzBdLmRpbXMubWFwKChfZGltLCBpKSA9PiBpKTtcbiAgfVxuICBjb25zdCBub3JtYWxpemVBeGVzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4ZXModXBkYXRlZEF4ZXMsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtcblxuICBsZXQgYXhlcyA9IG5vcm1hbGl6ZUF4ZXM7XG4gIGxldCBpbnB1dCA9IGNvbnRleHQuaW5wdXRzWzBdO1xuICBjb25zdCBwZXJtdXRlZEF4ZXMgPSBnZXRBeGVzUGVybXV0YXRpb24oYXhlcywgY29udGV4dC5pbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuICBpZiAocGVybXV0ZWRBeGVzLmxlbmd0aCA+IDApIHtcbiAgICBpbnB1dCA9IGNvbnRleHQuY29tcHV0ZShjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgcGVybXV0ZWRBeGVzKSwge1xuICAgICAgaW5wdXRzOiBbMF0sXG4gICAgICBvdXRwdXRzOiBbLTFdLFxuICAgIH0pWzBdO1xuICAgIGF4ZXMgPSBnZXRJbm5lck1vc3RBeGVzKGF4ZXMubGVuZ3RoLCBpbnB1dC5kaW1zLmxlbmd0aCk7XG4gIH1cblxuICBjb25zdCBbb3V0cHV0U2hhcGUsIHJlZHVjZVNoYXBlXSA9IGNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoaW5wdXQuZGltcywgYXhlcyk7XG4gIGxldCBmaW5hbE91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XG4gIGlmICh1cGRhdGVkQXR0cmlidXRlcy5rZWVwRGltcykge1xuICAgIGZpbmFsT3V0cHV0U2hhcGUgPSBleHBhbmRTaGFwZVRvS2VlcERpbShvdXRwdXRTaGFwZSwgbm9ybWFsaXplQXhlcyk7XG4gIH1cblxuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgY3JlYXRlUmVkdWNlU2hhcmVkUHJvZ3JhbUluZm8oXG4gICAgICBuYW1lLFxuICAgICAgeyBoaW50OiB1cGRhdGVkQXR0cmlidXRlcy5jYWNoZUtleSwgaW5wdXREZXBlbmRlbmNpZXM6IFsndHlwZSddIH0sXG4gICAgICBbaW5wdXRdLFxuICAgICAgcmVkdWNlVHlwZSxcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlLFxuICAgICAgZmluYWxPdXRwdXRTaGFwZSxcbiAgICAgIHJlZHVjZVNoYXBlLFxuICAgICksXG4gICAgeyBpbnB1dHM6IFtpbnB1dF0gfSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VNZWFuU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlTWVhblNoYXJlZCcsIGF0dHJpYnV0ZXMsICdtZWFuJyk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlTDFTaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VMMVNoYXJlZCcsIGF0dHJpYnV0ZXMsICdsMScpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZUwyU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlTDJTaGFyZWQnLCBhdHRyaWJ1dGVzLCAnbDInKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VMb2dTdW1FeHBTaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VMb2dTdW1FeHBTaGFyZWQnLCBhdHRyaWJ1dGVzLCAnbG9nU3VtRXhwJyk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlTWF4U2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlTWF4U2hhcmVkJywgYXR0cmlidXRlcywgJ21heCcpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZU1pblNoYXJlZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZU1pblNoYXJlZCcsIGF0dHJpYnV0ZXMsICdtaW4nKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VQcm9kU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlUHJvZFNoYXJlZCcsIGF0dHJpYnV0ZXMsICdwcm9kJyk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlU3VtU2hhcmVkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHJlZHVjZUNvbW1vbihjb250ZXh0LCAnUmVkdWNlU3VtU2hhcmVkJywgYXR0cmlidXRlcywgJ3N1bScpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlZHVjZVN1bVNxdWFyZVNoYXJlZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICByZWR1Y2VDb21tb24oY29udGV4dCwgJ1JlZHVjZVN1bVNxdWFyZVNoYXJlZCcsIGF0dHJpYnV0ZXMsICdzdW1TcXVhcmUnKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VMb2dTdW1TaGFyZWQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgcmVkdWNlQ29tbW9uKGNvbnRleHQsICdSZWR1Y2VMb2dTdW1TaGFyZWQnLCBhdHRyaWJ1dGVzLCAnbG9nU3VtJyk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVNoYWRlckNhY2hlSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIEluZGljZXNIZWxwZXIsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQge1xuICByZWR1Y2VMMVNoYXJlZCxcbiAgcmVkdWNlTDJTaGFyZWQsXG4gIHJlZHVjZUxvZ1N1bUV4cFNoYXJlZCxcbiAgcmVkdWNlTG9nU3VtU2hhcmVkLFxuICByZWR1Y2VNYXhTaGFyZWQsXG4gIHJlZHVjZU1lYW5TaGFyZWQsXG4gIHJlZHVjZU1pblNoYXJlZCxcbiAgcmVkdWNlUHJvZFNoYXJlZCxcbiAgcmVkdWNlU3VtU2hhcmVkLFxuICByZWR1Y2VTdW1TcXVhcmVTaGFyZWQsXG59IGZyb20gJy4vcmVkdWNlLXNoYXJlZCc7XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPT09IDAgfHwgaW5wdXRzLmxlbmd0aCA+IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZSBvcCByZXF1aXJlcyAxIG9yIDIgaW5wdXRzLicpO1xuICB9XG5cbiAgaWYgKGlucHV0cy5sZW5ndGggPT09IDIgJiYgaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGF4ZXMgaW5wdXQgZGltcy4nKTtcbiAgfVxufTtcblxuZXhwb3J0IGludGVyZmFjZSBSZWR1Y2VBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAga2VlcERpbXM6IGJvb2xlYW47XG4gIG5vb3BXaXRoRW1wdHlBeGVzOiBib29sZWFuO1xuICBheGVzOiBudW1iZXJbXTtcbn1cblxuZXhwb3J0IHR5cGUgUmVkdWNlT3AgPSAoXG4gIGlucHV0OiBJbmRpY2VzSGVscGVyLFxuICBvdXRwdXQ6IEluZGljZXNIZWxwZXIsXG4gIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuKSA9PiBbc3RyaW5nLCBzdHJpbmcsIHN0cmluZywgc3RyaW5nLCAuLi5zdHJpbmdbXV07XG5cbmNvbnN0IG5vT3A6IFJlZHVjZU9wID0gKGlucHV0KSA9PiBbJycsICcnLCBgdmFyIHZhbHVlID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07YCwgJyddO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlZHVjZVByb2dyYW1JbmZvID0gKFxuICBuYW1lOiBzdHJpbmcsXG4gIHNoYWRlckNhY2hlOiBQcm9ncmFtU2hhZGVyQ2FjaGVJbmZvLFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgcmVkdWNlT3A6IFJlZHVjZU9wLFxuICBheGVzSW5wdXQ6IG51bWJlcltdLFxuICBvdXRwdXREYXRhVHlwZTogRGF0YVR5cGUsXG4gIGtlZXBEaW1zID0gZmFsc2UsXG4gIG5vb3BXaXRoRW1wdHlBeGVzID0gZmFsc2UsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IG91dHB1dFNoYXBlOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGlucHV0UmFuayA9IGlucHV0U2hhcGUubGVuZ3RoO1xuICBjb25zdCBheGVzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4ZXMoYXhlc0lucHV0LCBpbnB1dFJhbmspO1xuICBjb25zdCByZWR1Y2VPbkFsbEF4ZXMgPSAhbm9vcFdpdGhFbXB0eUF4ZXMgJiYgYXhlcy5sZW5ndGggPT09IDA7XG4gIGlucHV0U2hhcGUuZm9yRWFjaCgoZCwgaSkgPT4ge1xuICAgIGlmIChyZWR1Y2VPbkFsbEF4ZXMgfHwgYXhlcy5pbmRleE9mKGkpID49IDApIHtcbiAgICAgIGlmIChrZWVwRGltcykge1xuICAgICAgICBvdXRwdXRTaGFwZS5wdXNoKDEpO1xuICAgICAgfSAvLyBlbHNlIHsgLy8gc2tpcCB0aGlzIGF4aXN9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dFNoYXBlLnB1c2goZCk7XG4gICAgfVxuICB9KTtcbiAgY29uc3Qgb3V0cHV0UmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgaWR4Q29weTogc3RyaW5nW10gPSBbXTsgLy8gY29weSBvdXRwdXQgaW5kZXhlcyB0byBpbnB1dCBpbmRleGVzXG5cbiAgICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ19BJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dFJhbmspO1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBvdXRwdXREYXRhVHlwZSwgb3V0cHV0UmFuayk7XG4gICAgY29uc3Qgb3BzID0gcmVkdWNlT3AoaW5wdXQsIG91dHB1dCwgYXhlcyk7XG4gICAgbGV0IHJlZHVjZU9wcyA9IG9wc1syXTtcblxuICAgIGZvciAobGV0IGsgPSAwLCBsID0gMDsgayA8IGlucHV0UmFuazsgaysrKSB7XG4gICAgICAvLyBpZiB0aGlzIGF4aXMgaXMgcmVkdWNlZFxuICAgICAgaWYgKHJlZHVjZU9uQWxsQXhlcyB8fCBheGVzLmluZGV4T2YoaykgPj0gMCkge1xuICAgICAgICBpZiAoa2VlcERpbXMpIHtcbiAgICAgICAgICBsKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9vcCBvdmVyIHRoZSBkLXRoIGF4aXNcbiAgICAgICAgcmVkdWNlT3BzID0gYGZvcih2YXIgaiR7a306IHUzMiA9IDA7IGoke2t9IDwgJHtpbnB1dFNoYXBlW2tdfTsgaiR7a30rKykge1xuICAgICAgICAgICAgICAgICAgJHtvcHNbMl0uaW5jbHVkZXMoJ2xhc3RfaW5kZXgnKSA/IGBsZXQgbGFzdF9pbmRleCA9IGoke2t9O2AgOiAnJ31cbiAgICAgICAgICAgICAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsIGssIGBqJHtrfWApfVxuICAgICAgICAgICAgICAgICAgJHtyZWR1Y2VPcHN9XG4gICAgICAgICAgICAgICAgfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZHhDb3B5LnB1c2goYCR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsIGssIG91dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsIGwpKX07YCk7XG4gICAgICAgIGwrKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGBcblxuICAgICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dF9zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG5cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICAgICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9O1xuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcblxuICAgICAgICAgICR7aWR4Q29weS5qb2luKCdcXG4nKX1cbiAgICAgICAgICAke29wc1swXX0gICAgICAgLy8gaW5pdCBvcHMgZm9yIHJlZHVjZSBtYXgvbWluXG4gICAgICAgICAgJHtvcHNbMV19XG4gICAgICAgICAgJHtyZWR1Y2VPcHN9XG4gICAgICAgICAgJHtvcHNbM119XG4gICAgICAgICAgJHtvcHMubGVuZ3RoID09PSA0ID8gb3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlJykgOiBvcHMuc2xpY2UoNCkuam9pbignXFxuJyl9XG4gICAgICAgIH1gO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZSxcbiAgICBzaGFkZXJDYWNoZSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogb3V0cHV0RGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXM6IFtcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSwgb3V0cHV0U2hhcGUpLFxuICAgICAgXSxcbiAgICB9KSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVSZWR1Y2VBdHRyaWJ1dGVzRnJvbUlucHV0cyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMsXG4pOiBSZWR1Y2VBdHRyaWJ1dGVzID0+IHtcbiAgY29uc3QgYXhlczogbnVtYmVyW10gPSBbXTtcbiAgaWYgKGlucHV0c1sxXS5kaW1zWzBdID4gMCkge1xuICAgIGlucHV0c1sxXS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaCgodikgPT4gYXhlcy5wdXNoKE51bWJlcih2KSkpO1xuICB9XG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xuICAgIGF4ZXMsXG4gICAga2VlcERpbXM6IGF0dHJpYnV0ZXMua2VlcERpbXMsXG4gICAgbm9vcFdpdGhFbXB0eUF4ZXM6IGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMsXG4gIH0pO1xufTtcblxuY29uc3QgcnVuUmVkdWNlUHJvZ3JhbSA9IChcbiAgY29udGV4dDogQ29tcHV0ZUNvbnRleHQsXG4gIG5hbWU6IHN0cmluZyxcbiAgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyxcbiAgcmVkdWNlT3A6IFJlZHVjZU9wLFxuKTogdm9pZCA9PiB7XG4gIGNvbnN0IGlucHV0cyA9IGNvbnRleHQuaW5wdXRzO1xuICBjb25zdCB1cGRhdGVkQXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyA9XG4gICAgaW5wdXRzLmxlbmd0aCA9PT0gMSA/IGF0dHJpYnV0ZXMgOiBjcmVhdGVSZWR1Y2VBdHRyaWJ1dGVzRnJvbUlucHV0cyhpbnB1dHMsIGF0dHJpYnV0ZXMpO1xuXG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVSZWR1Y2VQcm9ncmFtSW5mbyhcbiAgICAgIG5hbWUsXG4gICAgICB7IGhpbnQ6IHVwZGF0ZWRBdHRyaWJ1dGVzLmNhY2hlS2V5LCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ10gfSxcbiAgICAgIFtpbnB1dHNbMF1dLFxuICAgICAgdXBkYXRlZEF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMgJiYgdXBkYXRlZEF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggPT09IDAgPyBub09wIDogcmVkdWNlT3AsXG4gICAgICB1cGRhdGVkQXR0cmlidXRlcy5heGVzLFxuICAgICAgaW5wdXRzWzBdLmRhdGFUeXBlLFxuICAgICAgdXBkYXRlZEF0dHJpYnV0ZXMua2VlcERpbXMsXG4gICAgICB1cGRhdGVkQXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcyxcbiAgICApLFxuICAgIHsgaW5wdXRzOiBbMF0gfSxcbiAgKTtcbn07XG5cbmNvbnN0IHJlZHVjZUxvZ1N1bU5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQpID0+IFtcbiAgICBgdmFyIHZhbHVlID0gJHtvdXRwdXQudHlwZS5zdG9yYWdlfSgwKTtgLFxuICAgICcnLFxuICAgIGB2YWx1ZSArPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtgLFxuICAgICd2YWx1ZSA9IGxvZyh2YWx1ZSk7JyxcbiAgXTtcbiAgcnVuUmVkdWNlUHJvZ3JhbShjb250ZXh0LCAnUmVkdWNlTG9nU3VtJywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xufTtcblxuY29uc3QgcmVkdWNlTDFOYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgb3V0cHV0KSA9PiBbXG4gICAgYHZhciB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUuc3RvcmFnZX0oMCk7YCxcbiAgICAnJyxcbiAgICBgdmFsdWUgKz0gYWJzKCR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9KTtgLFxuICAgICcnLFxuICBdO1xuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VMMScsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcbn07XG5cbmNvbnN0IHJlZHVjZUwyTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCkgPT4gW1xuICAgIGB2YXIgdCA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDApOyB2YXIgdmFsdWUgPSAke291dHB1dC50eXBlLnZhbHVlfSgwKTtgLFxuICAgICcnLFxuICAgIGB0ID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07IHZhbHVlICs9ICh0ICogdCk7YCxcbiAgICAndmFsdWUgPSBzcXJ0KHZhbHVlKTsnLFxuICBdO1xuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VMMicsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcbn07XG5cbmNvbnN0IHJlZHVjZUxvZ1N1bUV4cE5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQpID0+IFtcbiAgICBgdmFyIHZhbHVlID0gJHtvdXRwdXQudHlwZS5zdG9yYWdlfSgwKTtgLFxuICAgICcnLFxuICAgIGB2YWx1ZSArPSBleHAoJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX0pO2AsXG4gICAgJ3ZhbHVlID0gbG9nKHZhbHVlKTsnLFxuICBdO1xuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VMb2dTdW1FeHAnLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XG59O1xuXG5jb25zdCByZWR1Y2VNYXhOYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgX291dHB1dCwgYXhlcykgPT4ge1xuICAgIGNvbnN0IGlkeFplcm8gPSBbXTtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IGlucHV0LnJhbms7IGsrKykge1xuICAgICAgaWYgKGF4ZXMuaW5kZXhPZihrKSA+PSAwIHx8IGF4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlkeFplcm8ucHVzaChpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgaywgMCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbXG4gICAgICBgJHtpZHhaZXJvLmpvaW4oJ1xcbicpfWAsXG4gICAgICBgdmFyIHZhbHVlID0gJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX07YCxcbiAgICAgIGB2YWx1ZSA9IG1heCh2YWx1ZSwgJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX0pO2AsXG4gICAgICAnJyxcbiAgICBdO1xuICB9O1xuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VNYXgnLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XG59O1xuXG5jb25zdCByZWR1Y2VNZWFuTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCwgYXhlcykgPT4ge1xuICAgIGxldCBzaXplID0gMS4wO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaW5wdXQucmFuazsgaysrKSB7XG4gICAgICBpZiAoYXhlcy5pbmRleE9mKGspID49IDAgfHwgYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gVE9ETzogdGhpcyBkZXBlbmRzIG9uIHRoZSBpbnB1dCBkaW1zLiBJZiB3ZSB3YW50IHRvIHVzZSB1bmlmb3JtLCB0aGlzIG5lZWQgdG8gYmUgdXBkYXRlZC5cbiAgICAgICAgc2l6ZSAqPSBjb250ZXh0LmlucHV0c1swXS5kaW1zW2tdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbXG4gICAgICAndmFyIHN1bSA9IGYzMigwKTsnLFxuICAgICAgJycsXG4gICAgICBgc3VtICs9IGYzMigke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfSk7YCxcbiAgICAgIGBsZXQgdmFsdWUgPSAke291dHB1dC50eXBlLnZhbHVlfShzdW0gLyAke3NpemV9KTtgLFxuICAgIF07XG4gIH07XG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZU1lYW4nLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XG59O1xuXG5jb25zdCByZWR1Y2VNaW5OYWl2ZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IHJlZHVjZU9wOiBSZWR1Y2VPcCA9IChpbnB1dCwgX291dHB1dCwgYXhlcykgPT4ge1xuICAgIGNvbnN0IGlkeFplcm8gPSBbXTtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IGlucHV0LnJhbms7IGsrKykge1xuICAgICAgaWYgKGF4ZXMuaW5kZXhPZihrKSA+PSAwIHx8IGF4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlkeFplcm8ucHVzaChgaW5wdXRfaW5kaWNlc1ske2t9XSA9IDA7YCk7IC8vIGZpcnN0IGVsZW1lbnRcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgYCR7aWR4WmVyby5qb2luKCdcXG4nKX1gLFxuICAgICAgYHZhciB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O2AsXG4gICAgICBgdmFsdWUgPSBtaW4odmFsdWUsICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9KTtgLFxuICAgICAgJycsXG4gICAgXTtcbiAgfTtcbiAgcnVuUmVkdWNlUHJvZ3JhbShjb250ZXh0LCAnUmVkdWNlTWluJywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xufTtcblxuY29uc3QgcmVkdWNlUHJvZE5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQpID0+IFtcbiAgICBgdmFyIHZhbHVlID0gJHtvdXRwdXQudHlwZS5zdG9yYWdlfSgxKTtgLFxuICAgICcnLFxuICAgIGB2YWx1ZSAqPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtgLFxuICAgICcnLFxuICBdO1xuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VQcm9kJywgYXR0cmlidXRlcywgcmVkdWNlT3ApO1xufTtcblxuY29uc3QgcmVkdWNlU3VtTmFpdmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCByZWR1Y2VPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCkgPT4gW1xuICAgIGB2YXIgdmFsdWUgPSAke291dHB1dC50eXBlLnN0b3JhZ2V9KDApO2AsXG4gICAgJycsXG4gICAgYHZhbHVlICs9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O2AsXG4gICAgJycsXG4gIF07XG4gIHJ1blJlZHVjZVByb2dyYW0oY29udGV4dCwgJ1JlZHVjZVN1bScsIGF0dHJpYnV0ZXMsIHJlZHVjZU9wKTtcbn07XG5cbmNvbnN0IHJlZHVjZVN1bVNxdWFyZU5haXZlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgcmVkdWNlT3A6IFJlZHVjZU9wID0gKGlucHV0LCBvdXRwdXQpID0+IFtcbiAgICBgdmFyIHQgPSAke291dHB1dC50eXBlLnZhbHVlfSgwKTsgdmFyIHZhbHVlID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMCk7YCxcbiAgICAnJyxcbiAgICBgdCA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9OyB2YWx1ZSArPSB0ICogdDtgLFxuICAgICcnLFxuICBdO1xuICBydW5SZWR1Y2VQcm9ncmFtKGNvbnRleHQsICdSZWR1Y2VTdW1TcXVhcmUnLCBhdHRyaWJ1dGVzLCByZWR1Y2VPcCk7XG59O1xuXG5jb25zdCB1c2VOYWl2ZVJlZHVjZU1ldGhvZCA9IChcbiAgc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBheGVzOiByZWFkb25seSBudW1iZXJbXSxcbiAgbm9vcFdpdGhFbXB0eUF4ZXM6IGJvb2xlYW4sXG4pOiBib29sZWFuID0+IHtcbiAgaWYgKGF4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5vb3BXaXRoRW1wdHlBeGVzO1xuICB9XG5cbiAgbGV0IG91dHB1dFNpemUgPSAxO1xuICBsZXQgcmVkdWNlU2l6ZSA9IDE7XG4gIGZvciAobGV0IGRpbSA9IDA7IGRpbSA8IGF4ZXMubGVuZ3RoOyBkaW0rKykge1xuICAgIGlmIChheGVzLmluZGV4T2YoZGltKSA9PT0gLTEpIHtcbiAgICAgIG91dHB1dFNpemUgKj0gc2hhcGVbZGltXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVkdWNlU2l6ZSAqPSBzaGFwZVtkaW1dO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRoZSBjb25kaXRpb24gZGF0YSBpcyB2ZXJ5IHJvdWdoLCBhbHRob3VnaCBjb25zaWRlcmluZyB0aGUgY291bnQgb2YgRXhlY3V0aW9uIFVuaXQgKEVVKSwgdGhlIHBvdGVudGlhbFxuICAvLyB3b3JrIGdyb3VwcyBpbiBhIEVVIGFuZCB0aGUgY291bnRzIG9mIGxvb3BzIGluIHRoZSBuYWl2ZSBhbmQgc2hhcmVkIG1ldGhvZHMsIGFsc28gZG9pbmcgZXhwZXJpbWVudHNcbiAgLy8gb24gc29tZSBtYWNoaW5lcy5cbiAgcmV0dXJuIHJlZHVjZVNpemUgPCAzMiAmJiBvdXRwdXRTaXplID4gMTAyNDtcbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VNZWFuID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmICh1c2VOYWl2ZVJlZHVjZU1ldGhvZChjb250ZXh0LmlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLmF4ZXMsIGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpKSB7XG4gICAgcmVkdWNlTWVhbk5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlZHVjZU1lYW5TaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VMMSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xuICAgIHJlZHVjZUwxTmFpdmUoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVkdWNlTDFTaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VMMiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUmVkdWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAodXNlTmFpdmVSZWR1Y2VNZXRob2QoY29udGV4dC5pbnB1dHNbMF0uZGltcywgYXR0cmlidXRlcy5heGVzLCBhdHRyaWJ1dGVzLm5vb3BXaXRoRW1wdHlBeGVzKSkge1xuICAgIHJlZHVjZUwyTmFpdmUoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVkdWNlTDJTaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VMb2dTdW1FeHAgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcbiAgICByZWR1Y2VMb2dTdW1FeHBOYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWR1Y2VMb2dTdW1FeHBTaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VNYXggPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcbiAgICByZWR1Y2VNYXhOYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWR1Y2VNYXhTaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VNaW4gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcbiAgICByZWR1Y2VNaW5OYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWR1Y2VNaW5TaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VQcm9kID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZWR1Y2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmICh1c2VOYWl2ZVJlZHVjZU1ldGhvZChjb250ZXh0LmlucHV0c1swXS5kaW1zLCBhdHRyaWJ1dGVzLmF4ZXMsIGF0dHJpYnV0ZXMubm9vcFdpdGhFbXB0eUF4ZXMpKSB7XG4gICAgcmVkdWNlUHJvZE5haXZlKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlZHVjZVByb2RTaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VTdW0gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcbiAgICByZWR1Y2VTdW1OYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWR1Y2VTdW1TaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VTdW1TcXVhcmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcbiAgICByZWR1Y2VTdW1TcXVhcmVOYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWR1Y2VTdW1TcXVhcmVTaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWR1Y2VMb2dTdW0gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlZHVjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKHVzZU5haXZlUmVkdWNlTWV0aG9kKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMsIGF0dHJpYnV0ZXMuYXhlcywgYXR0cmlidXRlcy5ub29wV2l0aEVtcHR5QXhlcykpIHtcbiAgICByZWR1Y2VMb2dTdW1OYWl2ZShjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWR1Y2VMb2dTdW1TaGFyZWQoY29udGV4dCwgYXR0cmlidXRlcyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8vIFRPRE86IHRoaXMgaXMgdGhlIHNhbWUgbmFpdmUgaW1wbGVtZW50YXRpb24gd2UgdXNlIGZvciByZWR1Y2UgdGhhdCBoYXNcbi8vIHBlcmZvcm1hbmNlIGxpbWl0YXRpb25zIHdoZW4gdGhlIHJlZHVjZWQgYXhpcyBpcyBsb25nLiBOZWVkIHRvIGFkZFxuLy8gYSBvcHRpbWl6ZWQgY29kZXBhdGggZm9yIHRoaXMuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVSZWR1Y2VQcm9ncmFtSW5mbywgUmVkdWNlT3AgfSBmcm9tICcuL3JlZHVjZSc7XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPT09IDAgfHwgaW5wdXRzLmxlbmd0aCA+IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ01pbk1heE9wIG9wIHJlcXVpcmVzIDEgb3IgMiBpbnB1dHMuJyk7XG4gIH1cbiAgaWYgKGlucHV0c1swXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuZmxvYXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdHlwZS4nKTtcbiAgfVxufTtcblxuZXhwb3J0IGludGVyZmFjZSBBcmdNaW5NYXhBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAga2VlcERpbXM6IGJvb2xlYW47XG4gIGF4aXM6IG51bWJlcjtcbiAgc2VsZWN0TGFzdEluZGV4OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBhcmdNaW4gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEFyZ01pbk1heEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCBhcmdNaW5NYXhPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCwgYXhlcykgPT4ge1xuICAgIGNvbnN0IGlkeFplcm8gPSBbXTtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IGlucHV0LnJhbms7IGsrKykge1xuICAgICAgaWYgKGF4ZXMuaW5kZXhPZihrKSA+PSAwIHx8IGF4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlkeFplcm8ucHVzaChgaW5wdXRfaW5kaWNlc1ske2t9XSA9IDA7YCk7IC8vIGZpcnN0IGVsZW1lbnRcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIGAke2lkeFplcm8uam9pbignXFxuJyl9YCxcbiAgICAgIGB2YXIgdmFsdWUgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcXG52YXIgYmVzdF9pbmRleCA6IGkzMiA9IDA7YCxcbiAgICAgIGBpZiAoJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX0gJHthdHRyaWJ1dGVzLnNlbGVjdExhc3RJbmRleCA+IDAgPyAnPD0nIDogJzwnfSB2YWx1ZSkge1xuICAgICAgICAgdmFsdWUgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcbiAgICAgICAgIGJlc3RfaW5kZXggPSBpMzIobGFzdF9pbmRleCk7XG4gICAgICAgfWAsXG4gICAgICAnJyxcbiAgICAgIG91dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICdiZXN0X2luZGV4JyksXG4gICAgXTtcbiAgfTtcblxuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgY3JlYXRlUmVkdWNlUHJvZ3JhbUluZm8oXG4gICAgICAnQXJnTWluJyxcbiAgICAgIHsgaGludDogYXR0cmlidXRlcy5jYWNoZUtleSwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddIH0sXG4gICAgICBbY29udGV4dC5pbnB1dHNbMF1dLFxuICAgICAgYXJnTWluTWF4T3AsXG4gICAgICBbYXR0cmlidXRlcy5heGlzXSxcbiAgICAgIERhdGFUeXBlLmludDY0LFxuICAgICAgYXR0cmlidXRlcy5rZWVwRGltcyxcbiAgICApLFxuICAgIHsgaW5wdXRzOiBbMF0gfSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBhcmdNYXggPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEFyZ01pbk1heEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCBhcmdNaW5NYXhPcDogUmVkdWNlT3AgPSAoaW5wdXQsIG91dHB1dCwgYXhlcykgPT4ge1xuICAgIGNvbnN0IGlkeFplcm8gPSBbXTtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IGlucHV0LnJhbms7IGsrKykge1xuICAgICAgaWYgKGF4ZXMuaW5kZXhPZihrKSA+PSAwIHx8IGF4ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlkeFplcm8ucHVzaChgaW5wdXRfaW5kaWNlc1ske2t9XSA9IDA7YCk7IC8vIGZpcnN0IGVsZW1lbnRcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIGAke2lkeFplcm8uam9pbignXFxuJyl9YCxcbiAgICAgIGB2YXIgdmFsdWUgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcXG52YXIgYmVzdF9pbmRleCA6IGkzMiA9IDA7YCxcbiAgICAgIGBpZiAoJHtpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKX0gJHthdHRyaWJ1dGVzLnNlbGVjdExhc3RJbmRleCA+IDAgPyAnPj0nIDogJz4nfSB2YWx1ZSkge1xuICAgICAgICAgdmFsdWUgPSAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcbiAgICAgICAgIGJlc3RfaW5kZXggPSBpMzIobGFzdF9pbmRleCk7XG4gICAgICAgfWAsXG4gICAgICAnJyxcbiAgICAgIG91dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICdiZXN0X2luZGV4JyksXG4gICAgXTtcbiAgfTtcblxuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgY3JlYXRlUmVkdWNlUHJvZ3JhbUluZm8oXG4gICAgICAnYXJnTWF4JyxcbiAgICAgIHsgaGludDogYXR0cmlidXRlcy5jYWNoZUtleSwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddIH0sXG4gICAgICBbY29udGV4dC5pbnB1dHNbMF1dLFxuICAgICAgYXJnTWluTWF4T3AsXG4gICAgICBbYXR0cmlidXRlcy5heGlzXSxcbiAgICAgIERhdGFUeXBlLmludDY0LFxuICAgICAgYXR0cmlidXRlcy5rZWVwRGltcyxcbiAgICApLFxuICAgIHsgaW5wdXRzOiBbMF0gfSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUFyZ01pbk1heEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBBcmdNaW5NYXhBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShhdHRyaWJ1dGVzIGFzIE9taXQ8QXJnTWluTWF4QXR0cmlidXRlcywga2V5b2YgQXR0cmlidXRlV2l0aENhY2hlS2V5Pik7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIEdwdURhdGFUeXBlLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGdldE1heENvbXBvbmVudHMsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSxcbiAgdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZSxcbiAgVW5pZm9ybURhdGFFbGVtZW50VHlwZSxcbiAgVW5pZm9ybXNBcnJheVR5cGUsXG59IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGNvbnN0IGVudW0gQXR0ZW50aW9uUWt2Rm9ybWF0IHtcbiAgdW5rbm93biwgLy8gZW51bSB2YWx1ZSBub3Qgc2V0LCBvciBkZXBlbmRzIG9uIHFrdiBwcm9qZWN0aW9uIGltcGxlbWVudGF0aW9uIGRldGFpbHNcbiAgcWt2Qk5TSCwgLy8gZm9yIG5vbi1wYWNrZWQgcWt2LCBwZXJtdXRlZFxuICBxa3ZCU05ILCAvLyBmb3Igbm9uLXBhY2tlZCBxa3YsIG5vdCBwZXJtdXRlZCwgdXNlZCBieSBtZW1vcnkgZWZmaWNpZW50IGF0dGVudGlvbiBvciBNdWx0aUhlYWRBdHRlbnRpb25cbiAgcWt2QlNOM0gsIC8vIGZvciBUUlQgZnVzZWQgYXR0ZW50aW9uLCBxa3YgYXJlIHBhY2tlZFxuICBxa3ZCTlNIcWt2QlMzTkgsIC8vIGZvciBUUlQgZnVzZWQgY2F1c2FsIGF0dGVudGlvbiwgZGF0YSBoYXMgdHdvIGZvcm1hdHMgKHFrdiBpcyAzQk5TSCwgZ2VtbV9idWZmZXIgaXMgQlMzTkgpXG4gIHFLdkJTTkh4QlNOMkgsIC8vIGZvciBUUlQgZnVzZWQgY3Jvc3MgYXR0ZW50aW9uLCBrdiBhcmUgcGFja2VkXG4gIHFrdlROSCwgLy8gZm9yIG1lbW9yeSBlZmZpY2llbnQgYXR0ZW50aW9uLCBxa3YgYXJlIG5vdCBwYWNrZWQsIGFuZCBwYWRkaW5ncyBhcmUgcmVtb3ZlZC5cbiAgcWt2VE4zSCwgLy8gZm9yIFRSVCBmdXNlZCBhdHRlbnRpb24sIHFrdiBhcmUgcGFja2VkIGFuZCBwYWRkaW5ncyBhcmUgcmVtb3ZlZFxufVxuXG5leHBvcnQgY29uc3QgZW51bSBBdHRlbnRpb25NYXNrVHlwZSB7XG4gIG5vbmUsIC8vIE5vIG1hc2tcbiAgbWFzazFkS2V5U2VxTGVuLCAvLyBbYmF0Y2hfc2l6ZV0sIGtleSBzZXF1ZW5jZSBsZW5ndGhcbiAgbWFzazFkRW5kU3RhcnQsIC8vIFsyICogYmF0Y2hfc2l6ZV0gd2l0aCBlbmQgcG9zaXRpb25zIGFuZCBzdGFydCBwb3NpdGlvbnNcbiAgbWFzazFES2V5U2VxTGVuU3RhcnQsIC8vIFszICogYmF0Y2hfc2l6ZSArIDJdIHdpdGggW2tleV9sZW5bMF0sIC4uLiwga2V5X2xlbltiYXRjaF9zaXplIC0gMV0sIHF1ZXJ5X3N0YXJ0WzBdLFxuICAvLyAuLi4sIHF1ZXJ5X3N0YXJ0W2JhdGNoX3NpemUgLSAxXSwgcXVlcnlfZW5kW2JhdGNoX3NpemUgLSAxXSwga2V5X3N0YXJ0WzBdLCAuLi4sXG4gIC8vIGtleV9zdGFydFtiYXRjaF9zaXplIC0gMV0sIGtleV9lbmRbYmF0Y2hfc2l6ZSAtIDFdXVxuICBtYXNrMmREdW1teSwgLy8gZHVtbXkgbWFzayB3aXRoIHNoYXBlIFsxLCAxXSBvciBbYmF0Y2hfc2l6ZSwgMV0uIEl0IGhhcyBzYW1lIGVmZmVjdCBhcyBubyBtYXNrLlxuICBtYXNrMmRLZXlQYWRkaW5nLCAvLyBbYmF0Y2hfc2l6ZSwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoXVxuICBtYXNrM2RBdHRlbnRpb24sIC8vIFtiYXRjaF9zaXplLCBzZXF1ZW5jZV9sZW5ndGgsIHRvdGFsX3NlcXVlbmNlX2xlbmd0aF1cbiAgbWFzazRkTWVnYXRyb24sIC8vIE1lZ2F0cm9uIGNhdXNhbCBtYXNrIHdpdGggc2hhcGUgW2JhdGNoX3NpemUsIDEsIG1heF9zZXF1ZW5jZV9sZW5ndGgsIG1heF9zZXF1ZW5jZV9sZW5ndGhdXG4gIG1hc2tVbmtub3duLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF0dGVudGlvblBhcmFtZXRlcnMge1xuICBiYXRjaFNpemU6IG51bWJlcjtcbiAgc2VxdWVuY2VMZW5ndGg6IG51bWJlcjtcbiAgcGFzdFNlcXVlbmNlTGVuZ3RoOiBudW1iZXI7XG4gIGt2U2VxdWVuY2VMZW5ndGg6IG51bWJlcjtcbiAgdG90YWxTZXF1ZW5jZUxlbmd0aDogbnVtYmVyO1xuICBtYXhTZXF1ZW5jZUxlbmd0aDogbnVtYmVyO1xuICBpbnB1dEhpZGRlblNpemU6IG51bWJlcjtcbiAgaGlkZGVuU2l6ZTogbnVtYmVyO1xuICB2SGlkZGVuU2l6ZTogbnVtYmVyO1xuICBoZWFkU2l6ZTogbnVtYmVyO1xuICB2SGVhZFNpemU6IG51bWJlcjtcbiAgbnVtSGVhZHM6IG51bWJlcjtcbiAga3ZOdW1IZWFkcz86IG51bWJlcjtcbiAgblJlcHM/OiBudW1iZXI7XG4gIGlzVW5pZGlyZWN0aW9uYWw/OiBib29sZWFuO1xuICBwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiBib29sZWFuO1xuICBtYXNrRmlsdGVyVmFsdWU/OiBudW1iZXI7XG4gIG1hc2tUeXBlOiBBdHRlbnRpb25NYXNrVHlwZTtcbiAgc2NhbGU6IG51bWJlcjtcbiAgYnJvYWRjYXN0UmVzUG9zQmlhczogYm9vbGVhbjtcbiAgcGFzc1Bhc3RJbkt2OiBib29sZWFuO1xuICBxa3ZGb3JtYXQ6IEF0dGVudGlvblFrdkZvcm1hdDtcbiAgaXNQYXN0a3ZCU05IPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdHRlbnRpb25BdHRycyB7XG4gIG51bUhlYWRzOiBudW1iZXI7XG4gIGt2TnVtSGVhZHM/OiBudW1iZXI7XG4gIGlzVW5pZGlyZWN0aW9uYWw/OiBudW1iZXI7XG4gIG1hc2tGaWx0ZXJWYWx1ZT86IG51bWJlcjtcbiAgc2NhbGU6IG51bWJlcjtcbiAgZG9Sb3Rhcnk6IG51bWJlcjtcbiAgcWt2SGlkZGVuU2l6ZXM6IG51bWJlcltdO1xuICBwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiBib29sZWFuO1xufVxuXG5jb25zdCB2YWxpZGF0ZUF0dGVudGlvbklucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogQXR0ZW50aW9uQXR0cnMpOiBBdHRlbnRpb25QYXJhbWV0ZXJzID0+IHtcbiAgLy8gQWJicmV2aWF0aW9uIGFuZCBNZWFuaW5nczpcbiAgLy8gICBCOiAgICBiYXRjaF9zaXplXG4gIC8vICAgUzogICAgc2VxdWVuY2VfbGVuZ3RoIChpbnB1dCBzZXF1ZW5jZSBsZW5ndGggb2YgcXVlcnkpXG4gIC8vICAgUDogICAgcGFzdF9zZXF1ZW5jZV9sZW5ndGggKHBhc3Qgc2VxdWVuY2UgbGVuZ3RoIG9mIGtleSBvciB2YWx1ZSlcbiAgLy8gICBMOiAgICBrdl9zZXF1ZW5jZV9sZW5ndGggKGlucHV0IHNlcXVlbmNlIGxlbmd0aCBvZiBrZXkgb3IgdmFsdWUpXG4gIC8vICAgTTogICAgbWF4X3NlcXVlbmNlX2xlbmd0aFxuICAvLyAgIFQ6ICAgIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoICsga3Zfc2VxdWVuY2VfbGVuZ3RoXG4gIC8vICAgTjogICAgbnVtX2hlYWRzXG4gIC8vICAgSDogICAgaGVhZCBzaXplIGZvciBRIGFuZCBLLCBha2EgcV9oZWFkX3NpemUgb3Iga19oZWFkX3NpemUgb3IgcWtfaGVhZF9zaXplXG4gIC8vICAgSF92OiAgdl9oZWFkX3NpemVcbiAgLy8gICBEX2k6ICBpbnB1dCBoaWRkZW4gc2l6ZVxuICAvLyAgIEQ6ICAgIGhpZGRlbiBzaXplIGZvciBRIGFuZCBLIChEID0gTiAqIEgpLCBha2EgcV9oaWRkZW5fc2l6ZSBvciBrX2hpZGRlbl9zaXplIG9yIHFrX2hpZGRlbl9zaXplXG4gIC8vICAgRF92OiAgdl9oaWRkZW5fc2l6ZSA9IG51bV9oZWFkcyAqIHZfaGVhZF9zaXplXG5cbiAgLy8gV2hlbiBwYXN0IHN0YXRlIGlzIHVzZWQsIFEsIEsgYW5kIFYgc2hvdWxkIGhhdmUgc2FtZSBoaWRkZW4gc2l6ZSAodW5sZXNzIHdlIHNwbGl0IGl0IGludG8gcGFzdF9rZXkgYW5kIHBhc3RfdmFsdWUpLlxuXG4gIC8vIElucHV0IHNoYXBlczpcbiAgLy8gICBpbnB1dCAgICAgICAgKFEvSy9WKSAgICA6IChCLCBTLCBEX2kpXG4gIC8vICAgd2VpZ2h0cyAgICAgIChRL0svVikgICAgOiAoRF9pLCBEICsgRCArIERfdilcbiAgLy8gICBiaWFzICAgICAgICAgKFEvSy9WKSAgICA6IChEICsgRCArIERfdilcbiAgLy8gICBtYXNrX2luZGV4ICAgICAgICAgICAgICA6IHNlZSBiZWxvd1xuICAvLyAgIHBhc3QgICAgICAgICAoSy9WKSAgICAgIDogKDIsIEIsIE4sIFAsIEgpIG9yIE5VTExcbiAgLy8gICBhdHRlbnRpb25fYmlhcyAgICAgICAgICA6IChCLCBOLCBTLCBUKSBvciBOVUxMXG5cbiAgLy8gRm9yIG1hc2tfaW5kZXgsIHRoZSBmb2xsb3dpbmcgc2hhcGVzIGFyZSBzdXBwb3J0ZWQ6XG4gIC8vICAgICBOVUxMLCAoQiwgMSksICgxLCAxKVxuICAvLyAgICAgKEIpLCAoMiAqIEIpLCAoMyAqIEIgKyAyKVxuICAvLyAgICAgKEIsIFQpXG4gIC8vICAgICAoQiwgUywgVClcbiAgLy8gICAgIChCLCAxLCBNLCBNKVxuICAvL1xuICAvLyBXaGVuIGEgbW9kZWwgaXMgcHJ1bmVkIChsaWtlIHNvbWUgYXR0ZW50aW9uIGhlYWRzIGFyZSByZW1vdmVkIGluIFEvSy9WKSwgaW5wdXRfaGlkZGVuX3NpemUgY291bGQgYmUgbGFyZ2VyXG4gIC8vIHRoYW4gaGlkZGVuIGRpbWVuc2lvbiBvZiBRLCBLIGFuZCBWLlxuXG4gIGNvbnN0IGlucHV0ID0gaW5wdXRzWzBdO1xuICBjb25zdCB3ZWlnaHRzID0gaW5wdXRzWzFdO1xuICBjb25zdCBiaWFzID0gaW5wdXRzWzJdO1xuICBjb25zdCBtYXNrSW5kZXggPSBpbnB1dHNbM107XG4gIGNvbnN0IHBhc3QgPSBpbnB1dHNbNF07XG4gIGNvbnN0IGF0dGVudGlvbkJpYXMgPSBpbnB1dHNbNV07XG5cbiAgaWYgKHBhc3QgJiYgYXR0ZW50aW9uQmlhcykge1xuICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW50aW9uIGNhbm5vdCBoYXZlIGJvdGggcGFzdCBhbmQgYXR0ZW50aW9uX2JpYXMnKTtcbiAgfVxuXG4gIGlmIChpbnB1dC5kaW1zLmxlbmd0aCAhPT0gMykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJpbnB1dFwiIG11c3QgaGF2ZSAzIGRpbWVuc2lvbnMnKTtcbiAgfVxuXG4gIGNvbnN0IGJhdGNoU2l6ZSA9IGlucHV0LmRpbXNbMF07XG4gIGNvbnN0IHNlcXVlbmNlTGVuZ3RoID0gaW5wdXQuZGltc1sxXTtcbiAgY29uc3QgaW5wdXRIaWRkZW5TaXplID0gaW5wdXQuZGltc1syXTtcblxuICBpZiAoYmlhcy5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbnMnKTtcbiAgfVxuXG4gIGlmICh3ZWlnaHRzLmRpbXMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcIndlaWdodHNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDIgZGltZW5zaW9ucycpO1xuICB9XG5cbiAgaWYgKHdlaWdodHMuZGltc1swXSAhPT0gaW5wdXRIaWRkZW5TaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCAxIGRpbWVuc2lvbiAwIHNob3VsZCBoYXZlIHNhbWUgbGVuZ3RoIGFzIGRpbWVuc2lvbiAyIG9mIGlucHV0IDAnKTtcbiAgfVxuXG4gIGlmIChiaWFzLmRpbXNbMF0gIT09IHdlaWdodHMuZGltc1sxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgZGltZW5zaW9uIDAgc2hvdWxkIGhhdmUgc2FtZSBsZW5ndGggYXMgZGltZW5zaW9uIDEgb2YgaW5wdXQgXCJ3ZWlnaHRzXCInKTtcbiAgfVxuXG4gIGxldCBxSGlkZGVuU2l6ZSA9IGJpYXMuZGltc1swXSAvIDM7XG4gIGxldCBrSGlkZGVuU2l6ZSA9IHFIaWRkZW5TaXplO1xuICBsZXQgdkhpZGRlblNpemUgPSBrSGlkZGVuU2l6ZTtcbiAgaWYgKGF0dHJpYnV0ZXMucWt2SGlkZGVuU2l6ZXMubGVuZ3RoID4gMCkge1xuICAgIGlmIChhdHRyaWJ1dGVzLnFrdkhpZGRlblNpemVzLmxlbmd0aCAhPT0gMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdxa3ZfaGlkZGVuX3NpemVzIGF0dHJpYnV0ZSBzaG91bGQgaGF2ZSAzIGVsZW1lbnRzJyk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc3ogb2YgYXR0cmlidXRlcy5xa3ZIaWRkZW5TaXplcykge1xuICAgICAgaWYgKHN6ICUgYXR0cmlidXRlcy5udW1IZWFkcyAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Frdl9oaWRkZW5fc2l6ZXMgc2hvdWxkIGJlIGRpdmlzaWJsZSBieSBudW1faGVhZHMnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBxSGlkZGVuU2l6ZSA9IGF0dHJpYnV0ZXMucWt2SGlkZGVuU2l6ZXNbMF07XG4gICAga0hpZGRlblNpemUgPSBhdHRyaWJ1dGVzLnFrdkhpZGRlblNpemVzWzFdO1xuICAgIHZIaWRkZW5TaXplID0gYXR0cmlidXRlcy5xa3ZIaWRkZW5TaXplc1syXTtcbiAgfVxuXG4gIGNvbnN0IGt2U2VxdWVuY2VMZW5ndGggPSBzZXF1ZW5jZUxlbmd0aDtcblxuICBpZiAocUhpZGRlblNpemUgIT09IGtIaWRkZW5TaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdxa3ZfaGlkZGVuX3NpemVzIGZpcnN0IGVsZW1lbnQgc2hvdWxkIGJlIHNhbWUgYXMgdGhlIHNlY29uZCcpO1xuICB9XG5cbiAgaWYgKGJpYXMuZGltc1swXSAhPT0gcUhpZGRlblNpemUgKyBrSGlkZGVuU2l6ZSArIHZIaWRkZW5TaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBkaW1lbnNpb24gMCBzaG91bGQgaGF2ZSBzYW1lIGxlbmd0aCBhcyBzdW0gb2YgUS9LL1YgaGlkZGVuIHNpemVzJyk7XG4gIH1cblxuICBsZXQgcGFzdFNlcXVlbmNlTGVuZ3RoID0gMDtcbiAgaWYgKHBhc3QpIHtcbiAgICBpZiAoa0hpZGRlblNpemUgIT09IHZIaWRkZW5TaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIGV4cGVjdCBrX2hpZGRlbl9zaXplID09IHZfaGlkZGVuX3NpemUnKTtcbiAgICB9XG4gICAgaWYgKHBhc3QuZGltcy5sZW5ndGggIT09IDUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgbXVzdCBoYXZlIDUgZGltZW5zaW9ucycpO1xuICAgIH1cbiAgICBpZiAocGFzdC5kaW1zWzBdICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIGZpcnN0IGRpbWVuc2lvbiBtdXN0IGJlIDInKTtcbiAgICB9XG4gICAgaWYgKHBhc3QuZGltc1sxXSAhPT0gYmF0Y2hTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIHNlY29uZCBkaW1lbnNpb24gbXVzdCBiZSBiYXRjaF9zaXplJyk7XG4gICAgfVxuICAgIGlmIChwYXN0LmRpbXNbMl0gIT09IGF0dHJpYnV0ZXMubnVtSGVhZHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgdGhpcmQgZGltZW5zaW9uIG11c3QgYmUgbnVtX2hlYWRzJyk7XG4gICAgfVxuICAgIGlmIChwYXN0LmRpbXNbNF0gIT09IGtIaWRkZW5TaXplIC8gYXR0cmlidXRlcy5udW1IZWFkcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBmaWZ0aCBkaW1lbnNpb24gbXVzdCBiZSBrX2hpZGRlbl9zaXplIC8gbnVtX2hlYWRzJyk7XG4gICAgfVxuXG4gICAgaWYgKCFhdHRyaWJ1dGVzLnBhc3RQcmVzZW50U2hhcmVCdWZmZXIpIHtcbiAgICAgIHBhc3RTZXF1ZW5jZUxlbmd0aCA9IHBhc3QuZGltc1szXTtcbiAgICB9XG4gICAgLy8gVE9ETzogaGFuZGxlIHBhc3Rfc2VxX2xlblxuICB9XG5cbiAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aCA9IGt2U2VxdWVuY2VMZW5ndGggKyBwYXN0U2VxdWVuY2VMZW5ndGg7XG4gIGNvbnN0IG1heFNlcXVlbmNlTGVuZ3RoID0gLTE7XG5cbiAgY29uc3QgbWFza1R5cGUgPSBBdHRlbnRpb25NYXNrVHlwZS5ub25lO1xuICBpZiAobWFza0luZGV4KSB7XG4gICAgLy8gbWFza1R5cGUgPSBBdHRlbnRpb25NYXNrVHlwZS5NQVNLX1VOS05PV047XG4gICAgLy8gVE9ETzogaGFuZGxlIG1hc2tcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01hc2sgbm90IHN1cHBvcnRlZCcpO1xuICB9XG5cbiAgaWYgKHBhc3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bhc3QgaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9XG5cbiAgaWYgKGF0dGVudGlvbkJpYXMpIHtcbiAgICBpZiAoYXR0ZW50aW9uQmlhcy5kaW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImF0dGVudGlvbl9iaWFzXCIgbXVzdCBoYXZlIDQgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHN1cHBvcnQgYnJvYWRjYXN0aW5nIHRoZSBmaXJzdCBhbmQgc2Vjb25kIGRpbWVuc2lvbnMgb2YgYXR0ZW50aW9uX2JpYXNcbiAgICBpZiAoXG4gICAgICBhdHRlbnRpb25CaWFzLmRpbXNbMF0gIT09IGJhdGNoU2l6ZSB8fFxuICAgICAgYXR0ZW50aW9uQmlhcy5kaW1zWzFdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8XG4gICAgICBhdHRlbnRpb25CaWFzLmRpbXNbMl0gIT09IHNlcXVlbmNlTGVuZ3RoIHx8XG4gICAgICBhdHRlbnRpb25CaWFzLmRpbXNbM10gIT09IHRvdGFsU2VxdWVuY2VMZW5ndGhcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwiYXR0ZW50aW9uX2JpYXNcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBzZXF1ZW5jZV9sZW5ndGgsIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCknKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJhdGNoU2l6ZSxcbiAgICBzZXF1ZW5jZUxlbmd0aCxcbiAgICBwYXN0U2VxdWVuY2VMZW5ndGgsXG4gICAga3ZTZXF1ZW5jZUxlbmd0aCxcbiAgICB0b3RhbFNlcXVlbmNlTGVuZ3RoLFxuICAgIG1heFNlcXVlbmNlTGVuZ3RoLFxuICAgIGlucHV0SGlkZGVuU2l6ZSxcbiAgICBoaWRkZW5TaXplOiBxSGlkZGVuU2l6ZSxcbiAgICB2SGlkZGVuU2l6ZSxcbiAgICBoZWFkU2l6ZTogTWF0aC5mbG9vcihxSGlkZGVuU2l6ZSAvIGF0dHJpYnV0ZXMubnVtSGVhZHMpLFxuICAgIHZIZWFkU2l6ZTogTWF0aC5mbG9vcih2SGlkZGVuU2l6ZSAvIGF0dHJpYnV0ZXMubnVtSGVhZHMpLFxuICAgIG51bUhlYWRzOiBhdHRyaWJ1dGVzLm51bUhlYWRzLFxuICAgIGlzVW5pZGlyZWN0aW9uYWw6IGZhbHNlLFxuICAgIHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6IGZhbHNlLFxuICAgIG1hc2tGaWx0ZXJWYWx1ZTogYXR0cmlidXRlcy5tYXNrRmlsdGVyVmFsdWUsXG4gICAgbWFza1R5cGUsXG4gICAgc2NhbGU6IGF0dHJpYnV0ZXMuc2NhbGUsXG4gICAgYnJvYWRjYXN0UmVzUG9zQmlhczogZmFsc2UsXG4gICAgcGFzc1Bhc3RJbkt2OiBmYWxzZSxcbiAgICBxa3ZGb3JtYXQ6IEF0dGVudGlvblFrdkZvcm1hdC5xa3ZCTlNILFxuICB9O1xufTtcblxuY29uc3QgY3JlYXRlSW5QbGFjZVNvZnRtYXhQcm9ncmFtSW5mbyA9IChpbnB1dDogVGVuc29yVmlldywgbjogbnVtYmVyLCBkOiBudW1iZXIpID0+IHtcbiAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoZCk7XG4gIGxldCBXRyA9IDY0O1xuICBjb25zdCBkQ29tcCA9IGQgLyBjb21wb25lbnRzO1xuICBpZiAoZENvbXAgPCBXRykge1xuICAgIFdHID0gMzI7XG4gIH1cbiAgY29uc3QgZWxlbWVudHNQZXJUaHJlYWQgPSBNYXRoLmNlaWwoZCAvIGNvbXBvbmVudHMgLyBXRyk7XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiAxIC8gZCB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBkQ29tcCB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBlbGVtZW50c1BlclRocmVhZCB9LFxuICBdO1xuICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dC5kYXRhVHlwZSwgY29tcG9uZW50cyk7XG4gIGNvbnN0IGYzMlR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKERhdGFUeXBlLmZsb2F0LCBjb21wb25lbnRzKTtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnXTtcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgaW5wdXRIZWxwZXIgPSBvdXRwdXRWYXJpYWJsZSgneCcsIGlucHV0LmRhdGFUeXBlLCBpbnB1dC5kaW1zLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCBlbGVtVmFsdWVUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShpbnB1dC5kYXRhVHlwZSk7XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnZF9pbnYnLCB0eXBlOiAnZjMyJyB9LFxuICAgICAgeyBuYW1lOiAnZF9jb21wJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2VsZW1lbnRzX3Blcl90aHJlYWQnLCB0eXBlOiAndTMyJyB9LFxuICAgIF07XG5cbiAgICByZXR1cm4gYFxuICB2YXI8d29ya2dyb3VwPiB0aHJlYWRfbWF4OiBhcnJheTxmMzIsICR7V0d9PjtcbiAgdmFyPHdvcmtncm91cD4gdGhyZWFkX3N1bTogYXJyYXk8ZjMyLCAke1dHfT47XG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXRIZWxwZXIpfVxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoW1dHLCAxLCAxXSl9XG4gICAgbGV0IGxvY2FsX29mZnNldCA9IGxvY2FsX2lkeCAqIHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQ7XG4gICAgbGV0IG9mZnNldCA9IChnbG9iYWxfaWR4IC8gJHtXR30pICogdW5pZm9ybXMuZF9jb21wICsgbG9jYWxfb2Zmc2V0O1xuXG4gICAgdmFyIHRocmVhZF9tYXhfdmVjdG9yID0gJHtmMzJUeXBlfSgtMy40MDI4MjNlKzM4Zik7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQgJiYgaSArIGxvY2FsX29mZnNldCA8IHVuaWZvcm1zLmRfY29tcDsgaSsrKSB7XG4gICAgICB0aHJlYWRfbWF4X3ZlY3RvciA9IG1heCgke2YzMlR5cGV9KHhbb2Zmc2V0ICsgaV0pLCB0aHJlYWRfbWF4X3ZlY3Rvcik7XG4gICAgfVxuICAgIHRocmVhZF9tYXhbbG9jYWxfaWR4XSA9ICR7KCgpID0+IHtcbiAgICAgIHN3aXRjaCAoY29tcG9uZW50cykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuICd0aHJlYWRfbWF4X3ZlY3Rvcic7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gJ21heCh0aHJlYWRfbWF4X3ZlY3Rvci54LCB0aHJlYWRfbWF4X3ZlY3Rvci55KSc7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gJ21heChtYXgodGhyZWFkX21heF92ZWN0b3IueCwgdGhyZWFkX21heF92ZWN0b3IueSksIG1heCh0aHJlYWRfbWF4X3ZlY3Rvci56LCB0aHJlYWRfbWF4X3ZlY3Rvci53KSknO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29tcG9uZW50czogJHtjb21wb25lbnRzfWApO1xuICAgICAgfVxuICAgIH0pKCl9O1xuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIHZhciBtYXhfdmFsdWUgPSAgZjMyKC0zLjQwMjgyM2UrMzhmKTtcbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke1dHfTsgaSsrKSB7XG4gICAgICBtYXhfdmFsdWUgPSBtYXgodGhyZWFkX21heFtpXSwgbWF4X3ZhbHVlKTtcbiAgICB9XG5cbiAgICB2YXIgc3VtX3ZlY3RvciA9ICR7ZjMyVHlwZX0oMCk7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQgJiYgaSArIGxvY2FsX29mZnNldCA8IHVuaWZvcm1zLmRfY29tcDsgaSsrKSB7XG4gICAgICBzdW1fdmVjdG9yICs9IGV4cCgke2YzMlR5cGV9KHhbb2Zmc2V0ICsgaV0pIC0gbWF4X3ZhbHVlKTtcbiAgICB9XG4gICAgdGhyZWFkX3N1bVtsb2NhbF9pZHhdID0gJHsoKCkgPT4ge1xuICAgICAgc3dpdGNoIChjb21wb25lbnRzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gJ3N1bV92ZWN0b3InO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuICdzdW1fdmVjdG9yLnggKyBzdW1fdmVjdG9yLnknO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuICdzdW1fdmVjdG9yLnggKyBzdW1fdmVjdG9yLnkgKyBzdW1fdmVjdG9yLnogKyBzdW1fdmVjdG9yLncnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29tcG9uZW50czogJHtjb21wb25lbnRzfWApO1xuICAgICAgfVxuICAgIH0pKCl9O1xuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIHZhciBzdW06IGYzMiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHtXR307IGkrKykge1xuICAgICAgc3VtICs9IHRocmVhZF9zdW1baV07XG4gICAgfVxuXG4gICAgaWYgKHN1bSA9PSAwKSB7XG4gICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZCAmJiBpICsgbG9jYWxfb2Zmc2V0IDwgdW5pZm9ybXMuZF9jb21wOyBpKyspIHtcbiAgICAgICAgeFtvZmZzZXQgKyBpXSA9ICR7aW5wdXRIZWxwZXIudHlwZS52YWx1ZX0oJHtlbGVtVmFsdWVUeXBlfSh1bmlmb3Jtcy5kX2ludikpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZCAmJiBpICsgbG9jYWxfb2Zmc2V0IDwgdW5pZm9ybXMuZF9jb21wOyBpKyspIHtcbiAgICAgICAgdmFyIGYzMmlucHV0ID0gJHtmMzJUeXBlfSh4W29mZnNldCArIGldKTtcbiAgICAgICAgeFtvZmZzZXQgKyBpXSA9ICR7aW5wdXRIZWxwZXIudHlwZS52YWx1ZX0oZXhwKGYzMmlucHV0IC0gbWF4X3ZhbHVlKSAvIHN1bSk7XG4gICAgICB9XG4gICAgfVxuICB9YDtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdBdHRlbnRpb25Qcm9ic1NvZnRtYXgnLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke1dHfTske2RhdGFUeXBlfTske2NvbXBvbmVudHN9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHsgb3V0cHV0czogW10sIGRpc3BhdGNoR3JvdXA6IHsgeDogbiB9LCBwcm9ncmFtVW5pZm9ybXMgfSksXG4gIH07XG59O1xuXG5jb25zdCBjcmVhdGVBdHRlbnRpb25Qcm9ic1Byb2dyYW1JbmZvID0gKFxuICBvdXRwdXRDb3VudDogbnVtYmVyLFxuICBxOiBUZW5zb3JWaWV3LFxuICBrZXk6IFRlbnNvclZpZXcsXG4gIHBhc3RLZXk6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXG4gIGF0dGVudGlvbkJpYXM6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXG4gIHBhcmFtZXRlcnM6IEF0dGVudGlvblBhcmFtZXRlcnMsXG4gIGF0dHJpYnV0ZXM6IEF0dGVudGlvbkF0dHJzLFxuICBwYXN0U2VxdWVuY2VMZW5ndGg6IG51bWJlcixcbikgPT4ge1xuICBjb25zdCB0b3RhbFNlcXVlbmNlTGVuZ3RoID0gcGFzdFNlcXVlbmNlTGVuZ3RoICsgcGFyYW1ldGVycy5rdlNlcXVlbmNlTGVuZ3RoO1xuICBjb25zdCBwcm9ic1NoYXBlID0gW3BhcmFtZXRlcnMuYmF0Y2hTaXplLCBwYXJhbWV0ZXJzLm51bUhlYWRzLCBwYXJhbWV0ZXJzLnNlcXVlbmNlTGVuZ3RoLCB0b3RhbFNlcXVlbmNlTGVuZ3RoXTtcbiAgY29uc3QgcHJlc2VudEtleSA9IHBhcmFtZXRlcnMua3ZOdW1IZWFkcyA9PT0gdW5kZWZpbmVkICYmIG91dHB1dENvdW50ID4gMSAmJiBwYXN0S2V5O1xuICBjb25zdCBwcmVzZW50S2V5U2hhcGUgPSBwcmVzZW50S2V5XG4gICAgPyBbcGFyYW1ldGVycy5iYXRjaFNpemUsIHBhcmFtZXRlcnMubnVtSGVhZHMsIHRvdGFsU2VxdWVuY2VMZW5ndGgsIHBhcmFtZXRlcnMuaGVhZFNpemVdXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgLy8gVE9ETzogaGFuZGxlIG1hc2tcblxuICBjb25zdCBhbHBoYSA9IGF0dHJpYnV0ZXMuc2NhbGUgPT09IDAgPyAxLjAgLyBNYXRoLnNxcnQocGFyYW1ldGVycy5oZWFkU2l6ZSkgOiBhdHRyaWJ1dGVzLnNjYWxlO1xuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhwYXJhbWV0ZXJzLmhlYWRTaXplKTtcbiAgY29uc3QgdmVjdG9yaXplZEhlYWRTaXplID0gcGFyYW1ldGVycy5oZWFkU2l6ZSAvIGNvbXBvbmVudHM7XG4gIGNvbnN0IFRJTEVfU0laRSA9IDEyO1xuICBjb25zdCBkaXNwYXRjaCA9IHtcbiAgICB4OiBNYXRoLmNlaWwodG90YWxTZXF1ZW5jZUxlbmd0aCAvIFRJTEVfU0laRSksXG4gICAgeTogTWF0aC5jZWlsKHBhcmFtZXRlcnMuc2VxdWVuY2VMZW5ndGggLyBUSUxFX1NJWkUpLFxuICAgIHo6IHBhcmFtZXRlcnMuYmF0Y2hTaXplICogcGFyYW1ldGVycy5udW1IZWFkcyxcbiAgfTtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbWV0ZXJzLnNlcXVlbmNlTGVuZ3RoIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHZlY3Rvcml6ZWRIZWFkU2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiB0b3RhbFNlcXVlbmNlTGVuZ3RoIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtZXRlcnMubnVtSGVhZHMgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBhbHBoYSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXN0U2VxdWVuY2VMZW5ndGggfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1ldGVycy5rdlNlcXVlbmNlTGVuZ3RoIH0sXG4gIF07XG4gIC8vIEZlZWQgcGFzdEtleSB0byB0aGUgc2hhZGVyLWNvZGUgb25seSBpZiBpdCBpcyBub24temVybyBhbmQgcHJlc2VudEtleSBpcyBiZWluZyBwcm9kdWNlZFxuICBjb25zdCBmZWVkUGFzdEtleSA9IHByZXNlbnRLZXkgJiYgcGFzdEtleSAmJiBTaGFwZVV0aWwuc2l6ZShwYXN0S2V5LmRpbXMpID4gMDtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnLCAndHlwZSddO1xuICBpZiAoZmVlZFBhc3RLZXkpIHtcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCd0eXBlJyk7XG4gIH1cbiAgaWYgKGF0dGVudGlvbkJpYXMpIHtcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCd0eXBlJyk7XG4gIH1cbiAgY29uc3Qgb3V0cHV0cyA9IFt7IGRpbXM6IHByb2JzU2hhcGUsIGRhdGFUeXBlOiBxLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCB9XTtcbiAgaWYgKHByZXNlbnRLZXkpIHtcbiAgICBvdXRwdXRzLnB1c2goeyBkaW1zOiBwcmVzZW50S2V5U2hhcGUhLCBkYXRhVHlwZTogcS5kYXRhVHlwZSwgZ3B1RGF0YVR5cGU6IEdwdURhdGFUeXBlLmRlZmF1bHQgfSk7XG4gIH1cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgcUlucHV0ID0gaW5wdXRWYXJpYWJsZSgncScsIHEuZGF0YVR5cGUsIHEuZGltcywgY29tcG9uZW50cyk7XG4gICAgY29uc3Qga0lucHV0ID0gaW5wdXRWYXJpYWJsZSgna2V5Jywga2V5LmRhdGFUeXBlLCBrZXkuZGltcywgY29tcG9uZW50cyk7XG4gICAgY29uc3QgaW5wdXRWYXJzID0gW3FJbnB1dCwga0lucHV0XTtcbiAgICBpZiAoZmVlZFBhc3RLZXkpIHtcbiAgICAgIGNvbnN0IHBhc3RLZXlJbnB1dCA9IGlucHV0VmFyaWFibGUoJ3Bhc3Rfa2V5JywgcGFzdEtleS5kYXRhVHlwZSwgcGFzdEtleS5kaW1zLCBjb21wb25lbnRzKTtcbiAgICAgIGlucHV0VmFycy5wdXNoKHBhc3RLZXlJbnB1dCk7XG4gICAgfVxuICAgIGlmIChhdHRlbnRpb25CaWFzKSB7XG4gICAgICBpbnB1dFZhcnMucHVzaChpbnB1dFZhcmlhYmxlKCdhdHRlbnRpb25fYmlhcycsIGF0dGVudGlvbkJpYXMuZGF0YVR5cGUsIGF0dGVudGlvbkJpYXMuZGltcykpO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgcS5kYXRhVHlwZSwgcHJvYnNTaGFwZSk7XG4gICAgY29uc3Qgb3V0cHV0VmFycyA9IFtvdXRwdXRdO1xuICAgIGlmIChwcmVzZW50S2V5KSB7XG4gICAgICBvdXRwdXRWYXJzLnB1c2gob3V0cHV0VmFyaWFibGUoJ3ByZXNlbnRfa2V5JywgcS5kYXRhVHlwZSwgcHJlc2VudEtleVNoYXBlISwgY29tcG9uZW50cykpO1xuICAgIH1cbiAgICBjb25zdCBmMzJUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShEYXRhVHlwZS5mbG9hdCwgY29tcG9uZW50cyk7XG5cbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdNJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ0snLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnTicsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdudW1faGVhZHMnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnYWxwaGEnLCB0eXBlOiAnZjMyJyBhcyBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlIH0sXG4gICAgICB7IG5hbWU6ICdwYXN0X3NlcXVlbmNlX2xlbmd0aCcsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdrdl9zZXF1ZW5jZV9sZW5ndGgnLCB0eXBlOiAndTMyJyB9LFxuICAgIF07XG4gICAgcmV0dXJuIGBcbiAgY29uc3QgVElMRV9TSVpFID0gJHtUSUxFX1NJWkV9dTtcblxuICB2YXI8d29ya2dyb3VwPiB0aWxlUTogYXJyYXk8JHtxSW5wdXQudHlwZS5zdG9yYWdlfSwgJHtUSUxFX1NJWkUgKiBUSUxFX1NJWkV9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZUs6IGFycmF5PCR7cUlucHV0LnR5cGUuc3RvcmFnZX0sICR7VElMRV9TSVpFICogVElMRV9TSVpFfT47XG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJzLCAuLi5vdXRwdXRWYXJzKX1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFtUSUxFX1NJWkUsIFRJTEVfU0laRSwgMV0pfVxuICAgIC8vIHggaG9sZHMgdGhlIE4gYW5kIHkgaG9sZHMgdGhlIE1cbiAgICBsZXQgaGVhZElkeCA9IHdvcmtncm91cF9pZC56O1xuICAgIGxldCBtID0gd29ya2dyb3VwX2lkLnkgKiBUSUxFX1NJWkU7XG4gICAgbGV0IG4gPSB3b3JrZ3JvdXBfaWQueCAqIFRJTEVfU0laRTtcbiAgICBsZXQgcU9mZnNldCA9IHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5LICogaGVhZElkeCArIG0gKiB1bmlmb3Jtcy5LO1xuICAgICR7KCgpID0+IHtcbiAgICAgIGlmIChmZWVkUGFzdEtleSAmJiBwcmVzZW50S2V5KSB7XG4gICAgICAgIHJldHVybiBgXG4gICAgbGV0IGtPZmZzZXQgPSB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGggKiB1bmlmb3Jtcy5LICogaGVhZElkeDtcbiAgICBsZXQgcGFzdEtleU9mZnNldCA9IHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoICogdW5pZm9ybXMuSyAqIGhlYWRJZHg7YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBgXG4gICAgbGV0IGtPZmZzZXQgPSB1bmlmb3Jtcy5OICogdW5pZm9ybXMuSyAqIGhlYWRJZHggKyBuICogdW5pZm9ybXMuSztgO1xuICAgICAgfVxuICAgIH0pKCl9XG4gICAgJHtwcmVzZW50S2V5ID8gJ2xldCBwcmVzZW50S2V5T2Zmc2V0ID0gaGVhZElkeCAqIHVuaWZvcm1zLk4gKiB1bmlmb3Jtcy5LOycgOiAnJ31cbiAgICB2YXIgdmFsdWUgPSAke2YzMlR5cGV9KDApO1xuICAgIGZvciAodmFyIHc6IHUzMiA9IDB1OyB3IDwgdW5pZm9ybXMuSzsgdyArPSBUSUxFX1NJWkUpIHtcbiAgICAgIGlmIChnbG9iYWxfaWQueSA8IHVuaWZvcm1zLk0gJiYgdyArIGxvY2FsX2lkLnggPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHFbcU9mZnNldCArIGxvY2FsX2lkLnkgKiB1bmlmb3Jtcy5LICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgfVxuICAgICAgaWYgKG4gKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuTiAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdmFyIGlkeCA9IFRJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54O1xuICAgICAgJHsoKCkgPT4ge1xuICAgICAgICBpZiAoZmVlZFBhc3RLZXkgJiYgcHJlc2VudEtleSkge1xuICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICAgIGlmIChuICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGlsZUtbaWR4XSA9IHBhc3Rfa2V5W3Bhc3RLZXlPZmZzZXQgKyAobiArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aWxlS1tpZHhdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICBrZXlba09mZnNldCArIChuICsgbG9jYWxfaWQueSAtIHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICAgICAgICAgIH1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAndGlsZUtbaWR4XSA9IGtleVtrT2Zmc2V0ICsgbG9jYWxfaWQueSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07JztcbiAgICAgICAgfVxuICAgICAgfSkoKX1cbiAgICAgICR7XG4gICAgICAgIHByZXNlbnRLZXkgPyAncHJlc2VudF9rZXlbcHJlc2VudEtleU9mZnNldCArIChuICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5LICsgdyArIGxvY2FsX2lkLnhdID0gdGlsZUtbaWR4XTsnIDogJydcbiAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCBUSUxFX1NJWkUgJiYgdytrIDwgdW5pZm9ybXMuSzsgaysrKSB7XG4gICAgICAgIHZhbHVlICs9ICR7ZjMyVHlwZX0odGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGtdICogdGlsZUtbVElMRV9TSVpFICogbG9jYWxfaWQueCArIGtdKTtcbiAgICAgIH1cblxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cblxuICAgIGxldCBoZWFkT2Zmc2V0ID0gaGVhZElkeCAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5OO1xuICAgIGlmIChnbG9iYWxfaWQueSA8IHVuaWZvcm1zLk0gJiYgZ2xvYmFsX2lkLnggPCB1bmlmb3Jtcy5OKSB7XG4gICAgICBsZXQgb3V0cHV0SWR4ID0gaGVhZE9mZnNldCArIGdsb2JhbF9pZC55ICogdW5pZm9ybXMuTiArIGdsb2JhbF9pZC54O1xuICAgICAgdmFyIHN1bTogZjMyID0gJHsoKCkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGNvbXBvbmVudHMpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gJ3ZhbHVlJztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gJ3ZhbHVlLnggKyB2YWx1ZS55JztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gJ3ZhbHVlLnggKyB2YWx1ZS55ICsgdmFsdWUueiArIHZhbHVlLncnO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbXBvbmVudHM6ICR7Y29tcG9uZW50c31gKTtcbiAgICAgICAgfVxuICAgICAgfSkoKX07XG4gICAgICAgIG91dHB1dFtvdXRwdXRJZHhdID0gJHtvdXRwdXQudHlwZS52YWx1ZX0gKHN1bSAqIHVuaWZvcm1zLmFscGhhKSArICR7XG4gICAgICAgICAgYXR0ZW50aW9uQmlhcyA/ICdhdHRlbnRpb25fYmlhc1tvdXRwdXRJZHhdJyA6ICcwLjAnXG4gICAgICAgIH07XG4gICAgfVxuICB9YDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnQXR0ZW50aW9uUHJvYnMnLFxuICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICBoaW50OiBgJHtjb21wb25lbnRzfTske2F0dGVudGlvbkJpYXMgIT09IHVuZGVmaW5lZH07JHtwYXN0S2V5ICE9PSB1bmRlZmluZWR9OyR7b3V0cHV0Q291bnR9YCxcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzLFxuICAgIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHsgb3V0cHV0cywgZGlzcGF0Y2hHcm91cDogZGlzcGF0Y2gsIHByb2dyYW1Vbmlmb3JtcyB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5jb25zdCBjcmVhdGVWeEF0dGVudGlvblNjb3JlUHJvZ3JhbUluZm8gPSAoXG4gIG91dHB1dENvdW50OiBudW1iZXIsXG4gIHByb2JzOiBUZW5zb3JWaWV3LFxuICB2OiBUZW5zb3JWaWV3LFxuICBwYXN0VmFsdWU6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXG4gIHBhcmFtczogQXR0ZW50aW9uUGFyYW1ldGVycyxcbiAgcGFzdFNlcXVlbmNlTGVuZ3RoOiBudW1iZXIsXG4pID0+IHtcbiAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aCA9IHBhc3RTZXF1ZW5jZUxlbmd0aCArIHBhcmFtcy5rdlNlcXVlbmNlTGVuZ3RoO1xuICBjb25zdCBuUmVwcyA9IHBhcmFtcy5uUmVwcyA/IHBhcmFtcy5uUmVwcyA6IDE7XG4gIGNvbnN0IHJlcGVhdGVkVkhpZGRlblNpemUgPSBwYXJhbXMudkhpZGRlblNpemUgKiBuUmVwcztcbiAgY29uc3QgcHJlc2VudFZhbHVlID0gcGFyYW1zLmt2TnVtSGVhZHMgPT0gbnVsbCAmJiBvdXRwdXRDb3VudCA+IDEgJiYgcGFzdFZhbHVlO1xuICBjb25zdCBwcmVzZW50VmFsdWVTaGFwZSA9IHByZXNlbnRWYWx1ZVxuICAgID8gW3BhcmFtcy5iYXRjaFNpemUsIHBhcmFtcy5udW1IZWFkcywgdG90YWxTZXF1ZW5jZUxlbmd0aCwgcGFyYW1zLmhlYWRTaXplXVxuICAgIDogdW5kZWZpbmVkO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IFtwYXJhbXMuYmF0Y2hTaXplLCBwYXJhbXMuc2VxdWVuY2VMZW5ndGgsIHJlcGVhdGVkVkhpZGRlblNpemVdO1xuICBjb25zdCBUSUxFX1NJWkUgPSAxMjtcbiAgY29uc3QgZGlzcGF0Y2ggPSB7XG4gICAgeDogTWF0aC5jZWlsKHBhcmFtcy52SGVhZFNpemUgLyBUSUxFX1NJWkUpLFxuICAgIHk6IE1hdGguY2VpbChwYXJhbXMuc2VxdWVuY2VMZW5ndGggLyBUSUxFX1NJWkUpLFxuICAgIHo6IHBhcmFtcy5iYXRjaFNpemUgKiBwYXJhbXMubnVtSGVhZHMsXG4gIH07XG5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbXMuc2VxdWVuY2VMZW5ndGggfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogdG90YWxTZXF1ZW5jZUxlbmd0aCB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbXMudkhlYWRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtcy5udW1IZWFkcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiByZXBlYXRlZFZIaWRkZW5TaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhc3RTZXF1ZW5jZUxlbmd0aCB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbXMua3ZTZXF1ZW5jZUxlbmd0aCB9LFxuICBdO1xuICAvLyBGZWVkIHBhc3RWYWx1ZSB0byB0aGUgc2hhZGVyLWNvZGUgb25seSBpZiBpdCBpcyBub24tZW1wdHkgYW5kIHByZXNlbnRWYWx1ZSBpcyBiZWluZyBwcm9kdWNlZFxuICBjb25zdCBmZWVkUGFzdFZhbHVlID0gcHJlc2VudFZhbHVlICYmIHBhc3RWYWx1ZSAmJiBTaGFwZVV0aWwuc2l6ZShwYXN0VmFsdWUuZGltcykgPiAwO1xuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsndHlwZScsICd0eXBlJ107XG4gIGlmIChmZWVkUGFzdFZhbHVlKSB7XG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgndHlwZScpO1xuICB9XG4gIGNvbnN0IG91dHB1dHMgPSBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IHByb2JzLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCB9XTtcbiAgaWYgKHByZXNlbnRWYWx1ZSkge1xuICAgIG91dHB1dHMucHVzaCh7IGRpbXM6IHByZXNlbnRWYWx1ZVNoYXBlISwgZGF0YVR5cGU6IHByb2JzLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCB9KTtcbiAgfVxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBwcm9ic0hlbHBlciA9IGlucHV0VmFyaWFibGUoJ3Byb2JzJywgcHJvYnMuZGF0YVR5cGUsIHByb2JzLmRpbXMpO1xuICAgIGNvbnN0IHZIZWxwZXIgPSBpbnB1dFZhcmlhYmxlKCd2Jywgdi5kYXRhVHlwZSwgdi5kaW1zKTtcbiAgICBjb25zdCBpbnB1dFZhcnMgPSBbcHJvYnNIZWxwZXIsIHZIZWxwZXJdO1xuICAgIGlmIChmZWVkUGFzdFZhbHVlKSB7XG4gICAgICBpbnB1dFZhcnMucHVzaChpbnB1dFZhcmlhYmxlKCdwYXN0X3ZhbHVlJywgcGFzdFZhbHVlLmRhdGFUeXBlLCBwYXN0VmFsdWUuZGltcykpO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgcHJvYnMuZGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcbiAgICBjb25zdCBvdXRwdXRWYXJzID0gW291dHB1dF07XG4gICAgaWYgKHByZXNlbnRWYWx1ZSkge1xuICAgICAgb3V0cHV0VmFycy5wdXNoKG91dHB1dFZhcmlhYmxlKCdwcmVzZW50X3ZhbHVlJywgcHJvYnMuZGF0YVR5cGUsIHByZXNlbnRWYWx1ZVNoYXBlISkpO1xuICAgIH1cbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdNJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ0snLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnTicsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdudW1faGVhZHMnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAndl9oaWRkZW5fc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdwYXN0X3NlcXVlbmNlX2xlbmd0aCcsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdrdl9zZXF1ZW5jZV9sZW5ndGgnLCB0eXBlOiAndTMyJyB9LFxuICAgIF07XG4gICAgcmV0dXJuIGBcbiAgY29uc3QgVElMRV9TSVpFID0gJHtUSUxFX1NJWkV9dTtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVE6IGFycmF5PCR7cHJvYnNIZWxwZXIudHlwZS52YWx1ZX0sICR7VElMRV9TSVpFICogVElMRV9TSVpFfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVLOiBhcnJheTwke3Byb2JzSGVscGVyLnR5cGUudmFsdWV9LCAke1RJTEVfU0laRSAqIFRJTEVfU0laRX0+O1xuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFycywgLi4ub3V0cHV0VmFycyl9XG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydChbVElMRV9TSVpFLCBUSUxFX1NJWkUsIDFdKX1cbiAgIGxldCBoZWFkSWR4ID0gd29ya2dyb3VwX2lkLno7XG4gICBsZXQgbSA9IGdsb2JhbF9pZC55O1xuICAgbGV0IG4gPSBnbG9iYWxfaWQueDtcblxuICAgbGV0IG9mZnNldEEgPSBoZWFkSWR4ICogKHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5LKSArIG0gKiB1bmlmb3Jtcy5LO1xuICAgJHsoKCkgPT4ge1xuICAgICBpZiAoZmVlZFBhc3RWYWx1ZSAmJiBwcmVzZW50VmFsdWUpIHtcbiAgICAgICByZXR1cm4gYFxuICAgIGxldCBwYXN0VmFsdWVPZmZzZXQgPSBoZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoICsgbjtcbiAgICBsZXQgdk9mZnNldCA9IGhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoICsgbjtcbiAgICAgIGA7XG4gICAgIH0gZWxzZSB7XG4gICAgICAgcmV0dXJuIGBcbiAgIGxldCBvZmZzZXRCID0gaGVhZElkeCAqIHVuaWZvcm1zLk4gKiB1bmlmb3Jtcy5LICsgbjtcbiAgICAgICAgICAgIGA7XG4gICAgIH1cbiAgIH0pKCl9XG4gICAgJHtwcmVzZW50VmFsdWUgPyAnbGV0IHByZXNlbnRWYWx1ZU9mZnNldCA9IGhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMuSyArIG47JyA6ICcnfVxuICAgdmFyIHZhbHVlID0gJHtwcm9ic0hlbHBlci50eXBlLnN0b3JhZ2V9KDApO1xuICAgZm9yICh2YXIgdzogdTMyID0gMHU7IHcgPCB1bmlmb3Jtcy5LOyB3ICs9IFRJTEVfU0laRSkge1xuICAgICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSBwcm9ic1tvZmZzZXRBICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgfVxuICAgICAgaWYgKG4gPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB2YXIgaWR4ID0gVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLng7XG4gICAgICAgICR7KCgpID0+IHtcbiAgICAgICAgICBpZiAoZmVlZFBhc3RWYWx1ZSAmJiBwcmVzZW50VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBgXG4gICAgICAgIGlmICh3ICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgdGlsZUtbaWR4XSA9IHBhc3RfdmFsdWVbcGFzdFZhbHVlT2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLk5dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbGVLW2lkeF0gPSB2W3ZPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkgLSB1bmlmb3Jtcy5wYXN0X3NlcXVlbmNlX2xlbmd0aCkgKiB1bmlmb3Jtcy5OXTtcbiAgICAgICAgfVxuICAgICAgYDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgdGlsZUtbaWR4XSA9IHZbb2Zmc2V0QiArICh3ICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5OXTtcbiAgICAgIGA7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpfVxuICAgICAgICAke3ByZXNlbnRWYWx1ZSA/ICdwcmVzZW50X3ZhbHVlW3ByZXNlbnRWYWx1ZU9mZnNldCArICh3ICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5OXSA9IHRpbGVLW2lkeF07JyA6ICcnfVxuICAgICAgfVxuICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgVElMRV9TSVpFICYmIHcrayA8IHVuaWZvcm1zLks7IGsrKykge1xuICAgICAgIHZhbHVlICs9IHRpbGVRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBrXSAqIHRpbGVLW1RJTEVfU0laRSAqIGsgKyBsb2NhbF9pZC54XTtcbiAgICAgfVxuICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICB9XG5cbiAgIC8vIHdlIG5lZWQgdG8gdHJhbnNwb3NlIG91dHB1dCBmcm9tIEJOU0hfdiB0byBCU05EX3ZcbiAgIGxldCBiYXRjaElkeCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgbGV0IGN1cnJlbnRCYXRjaEhlYWROdW1iZXIgPSB3b3JrZ3JvdXBfaWQueiAlIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiBuIDwgdW5pZm9ybXMuTikge1xuICAgICBsZXQgb3V0cHV0SWR4ID0gYmF0Y2hJZHggKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMudl9oaWRkZW5fc2l6ZSArIG0gKiB1bmlmb3Jtcy52X2hpZGRlbl9zaXplXG4gICAgICAgKyBjdXJyZW50QmF0Y2hIZWFkTnVtYmVyICogdW5pZm9ybXMuTiArIG47XG4gICAgIG91dHB1dFtvdXRwdXRJZHhdID0gdmFsdWU7XG4gICB9XG4gIH1gO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0F0dGVudGlvblNjb3JlJyxcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHtwYXN0VmFsdWUgIT09IHVuZGVmaW5lZH07JHtvdXRwdXRDb3VudH1gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7IG91dHB1dHMsIGRpc3BhdGNoR3JvdXA6IGRpc3BhdGNoLCBwcm9ncmFtVW5pZm9ybXMgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGFwcGx5QXR0ZW50aW9uID0gKFxuICBjb250ZXh0OiBDb21wdXRlQ29udGV4dCxcbiAgcTogVGVuc29yVmlldyxcbiAgazogVGVuc29yVmlldyxcbiAgdjogVGVuc29yVmlldyxcbiAgX21hc2tJbmRleDogVGVuc29yVmlldyB8IHVuZGVmaW5lZCxcbiAgX3Bhc3Q6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXG4gIHBhc3RLZXk6IFRlbnNvclZpZXcgfCB1bmRlZmluZWQsXG4gIHBhc3RWYWx1ZTogVGVuc29yVmlldyB8IHVuZGVmaW5lZCxcbiAgYXR0ZW50aW9uQmlhc0lucHV0OiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkLFxuICBwYXJhbWV0ZXJzOiBBdHRlbnRpb25QYXJhbWV0ZXJzLFxuICBhdHRyaWJ1dGVzOiBBdHRlbnRpb25BdHRycyxcbikgPT4ge1xuICAvLyBBc3N1bXB0aW9uICBpcyB0aGF0IHByZXNlbnRLZXkvcHJlc2VudFZhbHVlIGV4aXN0cyBvbmx5IGlmIHBhc3RLZXkvcGFzdFZhbHVlIGV4aXN0cy5cbiAgY29uc3Qgb3V0cHV0Q291bnQgPSBNYXRoLm1pbihjb250ZXh0Lm91dHB1dENvdW50LCAxICsgKHBhc3RLZXkgPyAxIDogMCkgKyAocGFzdFZhbHVlID8gMSA6IDApKTtcbiAgY29uc3QgcGFzdFNlcXVlbmNlTGVuZ3RoID0gcGFyYW1ldGVycy5rdk51bUhlYWRzICE9PSB1bmRlZmluZWQgfHwgb3V0cHV0Q291bnQgPiAxID8gcGFyYW1ldGVycy5wYXN0U2VxdWVuY2VMZW5ndGggOiAwO1xuICBjb25zdCB0b3RhbFNlcXVlbmNlTGVuZ3RoID0gcGFzdFNlcXVlbmNlTGVuZ3RoICsgcGFyYW1ldGVycy5rdlNlcXVlbmNlTGVuZ3RoO1xuICBjb25zdCBhdHRlbnRpb25CaWFzID1cbiAgICBhdHRlbnRpb25CaWFzSW5wdXQgJiYgU2hhcGVVdGlsLnNpemUoYXR0ZW50aW9uQmlhc0lucHV0LmRpbXMpID4gMCA/IGF0dGVudGlvbkJpYXNJbnB1dCA6IHVuZGVmaW5lZDtcblxuICBjb25zdCBpbnB1dHNLID0gW3EsIGtdO1xuICBpZiAocGFyYW1ldGVycy5rdk51bUhlYWRzID09PSB1bmRlZmluZWQgJiYgb3V0cHV0Q291bnQgPiAxICYmIHBhc3RLZXkgJiYgU2hhcGVVdGlsLnNpemUocGFzdEtleS5kaW1zKSA+IDApIHtcbiAgICBpbnB1dHNLLnB1c2gocGFzdEtleSk7XG4gIH1cbiAgaWYgKGF0dGVudGlvbkJpYXMpIHtcbiAgICBpbnB1dHNLLnB1c2goYXR0ZW50aW9uQmlhcyk7XG4gIH1cblxuICAvLyBSdW4gQXR0ZW50aW9uUHJvYnNcbiAgY29uc3QgcHJvYnMgPSBjb250ZXh0LmNvbXB1dGUoXG4gICAgY3JlYXRlQXR0ZW50aW9uUHJvYnNQcm9ncmFtSW5mbyhcbiAgICAgIG91dHB1dENvdW50LFxuICAgICAgcSxcbiAgICAgIGssXG4gICAgICBwYXN0S2V5LFxuICAgICAgYXR0ZW50aW9uQmlhcyxcbiAgICAgIHBhcmFtZXRlcnMsXG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgcGFzdFNlcXVlbmNlTGVuZ3RoLFxuICAgICksXG4gICAgeyBpbnB1dHM6IGlucHV0c0ssIG91dHB1dHM6IHBhcmFtZXRlcnMua3ZOdW1IZWFkcyA9PT0gdW5kZWZpbmVkICYmIG91dHB1dENvdW50ID4gMSA/IFstMSwgMV0gOiBbLTFdIH0sXG4gIClbMF07XG5cbiAgLy8gUnVuIFNvZnRtYXhcbiAgY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZUluUGxhY2VTb2Z0bWF4UHJvZ3JhbUluZm8oXG4gICAgICBwcm9icyxcbiAgICAgIHBhcmFtZXRlcnMuYmF0Y2hTaXplICogcGFyYW1ldGVycy5udW1IZWFkcyAqIHBhcmFtZXRlcnMuc2VxdWVuY2VMZW5ndGgsXG4gICAgICB0b3RhbFNlcXVlbmNlTGVuZ3RoLFxuICAgICksXG4gICAgeyBpbnB1dHM6IFtwcm9ic10sIG91dHB1dHM6IFtdIH0sXG4gICk7XG5cbiAgLy8gUnVuIEF0dHJpb25TY29yZVxuICBjb25zdCBpbnB1dHNWID0gW3Byb2JzLCB2XTtcbiAgaWYgKHBhcmFtZXRlcnMua3ZOdW1IZWFkcyA9PT0gdW5kZWZpbmVkICYmIG91dHB1dENvdW50ID4gMSAmJiBwYXN0VmFsdWUgJiYgU2hhcGVVdGlsLnNpemUocGFzdFZhbHVlLmRpbXMpID4gMCkge1xuICAgIGlucHV0c1YucHVzaChwYXN0VmFsdWUpO1xuICB9XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVWeEF0dGVudGlvblNjb3JlUHJvZ3JhbUluZm8ob3V0cHV0Q291bnQsIHByb2JzLCB2LCBwYXN0VmFsdWUsIHBhcmFtZXRlcnMsIHBhc3RTZXF1ZW5jZUxlbmd0aCksIHtcbiAgICBpbnB1dHM6IGlucHV0c1YsXG4gICAgb3V0cHV0czogcGFyYW1ldGVycy5rdk51bUhlYWRzID09PSB1bmRlZmluZWQgJiYgb3V0cHV0Q291bnQgPiAxID8gWzAsIDJdIDogWzBdLFxuICB9KTtcbn07XG5cbmNvbnN0IHByZXBhcmUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIHBhcmFtZXRlcnM6IEF0dGVudGlvblBhcmFtZXRlcnMpID0+IHtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbcGFyYW1ldGVycy5iYXRjaFNpemUsIHBhcmFtZXRlcnMubnVtSGVhZHMsIHBhcmFtZXRlcnMuc2VxdWVuY2VMZW5ndGgsIHBhcmFtZXRlcnMuaGVhZFNpemVdO1xuICBjb25zdCBNID0gcGFyYW1ldGVycy5zZXF1ZW5jZUxlbmd0aDtcbiAgY29uc3QgSyA9IHBhcmFtZXRlcnMuaW5wdXRIaWRkZW5TaXplO1xuICBjb25zdCBOID0gcGFyYW1ldGVycy5oZWFkU2l6ZTtcbiAgY29uc3QgVElMRV9TSVpFID0gMTI7XG4gIGNvbnN0IGRpc3BhdGNoID0ge1xuICAgIHg6IE1hdGguY2VpbChwYXJhbWV0ZXJzLmhlYWRTaXplIC8gVElMRV9TSVpFKSxcbiAgICB5OiBNYXRoLmNlaWwocGFyYW1ldGVycy5zZXF1ZW5jZUxlbmd0aCAvIFRJTEVfU0laRSksXG4gICAgejogcGFyYW1ldGVycy5iYXRjaFNpemUgKiBwYXJhbWV0ZXJzLm51bUhlYWRzLFxuICB9O1xuICBjb25zdCBpbnB1dHMgPSBbY29udGV4dC5pbnB1dHNbMF0sIGNvbnRleHQuaW5wdXRzWzFdLCBjb250ZXh0LmlucHV0c1syXV07XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBLIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE4gfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcGFyYW1ldGVycy5udW1IZWFkcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbWV0ZXJzLmhlYWRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtZXRlcnMuaGlkZGVuU2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbWV0ZXJzLmhpZGRlblNpemUgKyBwYXJhbWV0ZXJzLmhpZGRlblNpemUgKyBwYXJhbWV0ZXJzLnZIaWRkZW5TaXplIH0sXG4gIF07XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3Qgb3V0cHV0USA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXRfcScsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUpO1xuICAgIGNvbnN0IG91dHB1dEsgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0X2snLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcbiAgICBjb25zdCBvdXRwdXRWID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dF92JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XG4gICAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMpO1xuICAgIGNvbnN0IHdlaWdodCA9IGlucHV0VmFyaWFibGUoJ3dlaWdodCcsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMpO1xuICAgIGNvbnN0IGJpYXMgPSBpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcyk7XG4gICAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dC50eXBlLnN0b3JhZ2U7XG5cbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdNJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ0snLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnTicsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdudW1faGVhZHMnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnaGVhZF9zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2hpZGRlbl9zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2xkYicsIHR5cGU6ICd1MzInIH0sXG4gICAgXTtcbiAgICByZXR1cm4gYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke1RJTEVfU0laRX11O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlSW5wdXQ6IGFycmF5PCR7ZGF0YVR5cGV9LCAke1RJTEVfU0laRSAqIFRJTEVfU0laRX0+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlV2VpZ2h0UTogYXJyYXk8JHtkYXRhVHlwZX0sICR7VElMRV9TSVpFICogVElMRV9TSVpFfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVXZWlnaHRLOiBhcnJheTwke2RhdGFUeXBlfSwgJHtUSUxFX1NJWkUgKiBUSUxFX1NJWkV9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVdlaWdodFY6IGFycmF5PCR7ZGF0YVR5cGV9LCAke1RJTEVfU0laRSAqIFRJTEVfU0laRX0+O1xuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCB3ZWlnaHQsIGJpYXMsIG91dHB1dFEsIG91dHB1dEssIG91dHB1dFYpfVxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoW1RJTEVfU0laRSwgVElMRV9TSVpFLCAxXSl9XG4gICAgbGV0IGJhdGNoSW5kZXggPSB3b3JrZ3JvdXBfaWQueiAvIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgICBsZXQgaGVhZE51bWJlciA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBtID0gZ2xvYmFsX2lkLnk7XG4gICAgbGV0IG4gPSBnbG9iYWxfaWQueDtcblxuICAgIGxldCBpbnB1dE9mZnNldCA9IGJhdGNoSW5kZXggKiAodW5pZm9ybXMuTSAqIHVuaWZvcm1zLkspICsgbSAqIHVuaWZvcm1zLks7XG4gICAgbGV0IGJpYXNPZmZzZXRRID0gaGVhZE51bWJlciAqIHVuaWZvcm1zLmhlYWRfc2l6ZTtcbiAgICBsZXQgYmlhc09mZnNldEsgPSB1bmlmb3Jtcy5oaWRkZW5fc2l6ZSArIGJpYXNPZmZzZXRRO1xuICAgIGxldCBiaWFzT2Zmc2V0ViA9IHVuaWZvcm1zLmhpZGRlbl9zaXplICsgYmlhc09mZnNldEs7XG5cbiAgICB2YXIgdmFsdWVRID0gJHtkYXRhVHlwZX0oMCk7XG4gICAgdmFyIHZhbHVlSyA9ICR7ZGF0YVR5cGV9KDApO1xuICAgIHZhciB2YWx1ZVYgPSAke2RhdGFUeXBlfSgwKTtcbiAgICBmb3IgKHZhciB3OiB1MzIgPSAwdTsgdyA8IHVuaWZvcm1zLks7IHcgKz0gVElMRV9TSVpFKSB7XG4gICAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgdyArIGxvY2FsX2lkLnggPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVJbnB1dFtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSBpbnB1dFtpbnB1dE9mZnNldCArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgIH1cbiAgICAgIGlmIChuIDwgdW5pZm9ybXMuTiAmJiB3ICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgbGV0IG9mZnNldCA9IG4gKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMubGRiO1xuICAgICAgICB0aWxlV2VpZ2h0UVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSB3ZWlnaHRbYmlhc09mZnNldFEgKyBvZmZzZXRdO1xuICAgICAgICB0aWxlV2VpZ2h0S1tUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSB3ZWlnaHRbYmlhc09mZnNldEsgKyBvZmZzZXRdO1xuICAgICAgICB0aWxlV2VpZ2h0VltUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSB3ZWlnaHRbYmlhc09mZnNldFYgKyBvZmZzZXRdO1xuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGs8VElMRV9TSVpFICYmIHcrayA8IHVuaWZvcm1zLks7IGsrKykge1xuICAgICAgICBsZXQgaW5wdXRUaWxlT2Zmc2V0ID0gVElMRV9TSVpFICogbG9jYWxfaWQueSArIGs7XG4gICAgICAgIGxldCB3ZWlnaHRUaWxlT2Zmc2V0ID0gVElMRV9TSVpFICogayArIGxvY2FsX2lkLng7XG4gICAgICAgIHZhbHVlUSArPSB0aWxlSW5wdXRbaW5wdXRUaWxlT2Zmc2V0XSAqIHRpbGVXZWlnaHRRW3dlaWdodFRpbGVPZmZzZXRdO1xuICAgICAgICB2YWx1ZUsgKz0gdGlsZUlucHV0W2lucHV0VGlsZU9mZnNldF0gKiB0aWxlV2VpZ2h0S1t3ZWlnaHRUaWxlT2Zmc2V0XTtcbiAgICAgICAgdmFsdWVWICs9IHRpbGVJbnB1dFtpbnB1dFRpbGVPZmZzZXRdICogdGlsZVdlaWdodFZbd2VpZ2h0VGlsZU9mZnNldF07XG4gICAgICB9XG5cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG5cbiAgICBsZXQgaGVhZE9mZnNldCA9IChtICogdW5pZm9ybXMuTiArIG4pICUgdW5pZm9ybXMuaGVhZF9zaXplO1xuICAgIHZhbHVlUSArPSBiaWFzW2hlYWRPZmZzZXQgKyBiaWFzT2Zmc2V0UV07XG4gICAgdmFsdWVLICs9IGJpYXNbaGVhZE9mZnNldCArIGJpYXNPZmZzZXRLXTtcbiAgICB2YWx1ZVYgKz0gYmlhc1toZWFkT2Zmc2V0ICsgYmlhc09mZnNldFZdO1xuXG4gICAgbGV0IG9mZnNldCA9IHdvcmtncm91cF9pZC56ICogdW5pZm9ybXMuTSAqIHVuaWZvcm1zLk47XG4gICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIG4gPCB1bmlmb3Jtcy5OKSB7XG4gICAgICBsZXQgb3V0cHV0SWR4ID0gb2Zmc2V0ICsgbSAqIHVuaWZvcm1zLk4gKyBuO1xuICAgICAgb3V0cHV0X3Fbb3V0cHV0SWR4XSA9IHZhbHVlUTtcbiAgICAgIG91dHB1dF9rW291dHB1dElkeF0gPSB2YWx1ZUs7XG4gICAgICBvdXRwdXRfdltvdXRwdXRJZHhdID0gdmFsdWVWO1xuICAgIH1cbiAgfWA7XG4gIH07XG5cbiAgcmV0dXJuIGNvbnRleHQuY29tcHV0ZShcbiAgICB7XG4gICAgICBuYW1lOiAnQXR0ZW50aW9uUHJlcGFyZScsXG4gICAgICBzaGFkZXJDYWNoZTogeyBpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJywgJ3R5cGUnLCAndHlwZSddIH0sXG4gICAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlLCBncHVEYXRhVHlwZTogR3B1RGF0YVR5cGUuZGVmYXVsdCB9LFxuICAgICAgICAgIHsgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSwgZ3B1RGF0YVR5cGU6IEdwdURhdGFUeXBlLmRlZmF1bHQgfSxcbiAgICAgICAgICB7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsIGdwdURhdGFUeXBlOiBHcHVEYXRhVHlwZS5kZWZhdWx0IH0sXG4gICAgICAgIF0sXG4gICAgICAgIGRpc3BhdGNoR3JvdXA6IGRpc3BhdGNoLFxuICAgICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgICB9KSxcbiAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICB9LFxuICAgIHsgaW5wdXRzLCBvdXRwdXRzOiBbLTEsIC0xLCAtMV0gfSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBhdHRlbnRpb24gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEF0dGVudGlvbkF0dHJzKTogdm9pZCA9PiB7XG4gIGNvbnN0IHBhcmFtcyA9IHZhbGlkYXRlQXR0ZW50aW9uSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcblxuICBjb25zdCBbcSwgaywgdl0gPSBwcmVwYXJlKGNvbnRleHQsIHBhcmFtcyk7XG5cbiAgcmV0dXJuIGFwcGx5QXR0ZW50aW9uKFxuICAgIGNvbnRleHQsXG4gICAgcSxcbiAgICBrLFxuICAgIHYsXG4gICAgY29udGV4dC5pbnB1dHNbNF0sXG4gICAgdW5kZWZpbmVkLFxuICAgIHVuZGVmaW5lZCxcbiAgICB1bmRlZmluZWQsXG4gICAgY29udGV4dC5pbnB1dHNbNV0sXG4gICAgcGFyYW1zLFxuICAgIGF0dHJpYnV0ZXMsXG4gICk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBlbnYgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGdldE1heENvbXBvbmVudHMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmF0Y2hOb3JtQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGVwc2lsb246IG51bWJlcjtcbiAgcmVhZG9ubHkgbW9tZW50dW06IG51bWJlcjtcbiAgcmVhZG9ubHkgc3BhdGlhbDogYm9vbGVhbjtcbiAgcmVhZG9ubHkgdHJhaW5pbmdNb2RlOiBib29sZWFuO1xuICByZWFkb25seSBmb3JtYXQ6ICdOSFdDJyB8ICdOQ0hXJztcbiAgcmVhZG9ubHkgb3V0cHV0Q291bnQ6IG51bWJlcjtcbn1cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IEJhdGNoTm9ybUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmF0Y2hOb3JtYWxpemF0aW9uIHJlcXVpcmVzIDUgaW5wdXRzJyk7XG4gIH1cblxuICBjb25zdCBjaGVja1NoYXBlRXF1YWwgPSAoYWN0dWFsOiByZWFkb25seSBudW1iZXJbXSwgZXhwZWN0ZWQ6IHJlYWRvbmx5IG51bWJlcltdLCBtZXNzYWdlOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCByID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgIGlmIChyICE9PSBhY3R1YWwubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bWVzc2FnZX06IG51bSBkaW1lbnNpb25zICE9ICR7cn1gKTtcbiAgICB9XG4gICAgZXhwZWN0ZWQuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgaWYgKHYgIT09IGFjdHVhbFtpXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bWVzc2FnZX06IGRpbVske2l9XSBkbyBub3QgbWF0Y2hgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IHNoYXBlID1cbiAgICAgIGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQydcbiAgICAgICAgPyBhdHRyaWJ1dGVzLnNwYXRpYWxcbiAgICAgICAgICA/IGlucHV0c1swXS5kaW1zLnNsaWNlKC0xKVxuICAgICAgICAgIDogaW5wdXRzWzBdLmRpbXMuc2xpY2UoLTEpLmNvbmNhdChpbnB1dHNbMF0uZGltcy5zbGljZSgxLCBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAxKSlcbiAgICAgICAgOiBpbnB1dHNbMF0uZGltcy5zbGljZSgxLCBhdHRyaWJ1dGVzLnNwYXRpYWwgPyAyIDogdW5kZWZpbmVkKTtcbiAgICBjaGVja1NoYXBlRXF1YWwoaW5wdXRzWzFdLmRpbXMsIHNoYXBlLCAnSW52YWxpZCBpbnB1dCBzY2FsZScpO1xuICAgIGNoZWNrU2hhcGVFcXVhbChpbnB1dHNbMl0uZGltcywgc2hhcGUsICdJbnZhbGlkIGlucHV0IEInKTtcbiAgICBjaGVja1NoYXBlRXF1YWwoaW5wdXRzWzNdLmRpbXMsIHNoYXBlLCAnSW52YWxpZCBpbnB1dCBtZWFuJyk7XG4gICAgY2hlY2tTaGFwZUVxdWFsKGlucHV0c1s0XS5kaW1zLCBzaGFwZSwgJ0ludmFsaWQgaW5wdXQgdmFyJyk7XG4gIH0gZWxzZSB7XG4gICAgY2hlY2tTaGFwZUVxdWFsKGlucHV0c1sxXS5kaW1zLCBbMV0sICdJbnZhbGlkIGlucHV0IHNjYWxlJyk7XG4gICAgY2hlY2tTaGFwZUVxdWFsKGlucHV0c1syXS5kaW1zLCBbMV0sICdJbnZhbGlkIGlucHV0IEInKTtcbiAgICBjaGVja1NoYXBlRXF1YWwoaW5wdXRzWzNdLmRpbXMsIFsxXSwgJ0ludmFsaWQgaW5wdXQgbWVhbicpO1xuICAgIGNoZWNrU2hhcGVFcXVhbChpbnB1dHNbNF0uZGltcywgWzFdLCAnSW52YWxpZCBpbnB1dCB2YXInKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlQmF0Y2hOb3JtSW5mZXJlbmNlUHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhdHRyaWJ1dGVzOiBCYXRjaE5vcm1BdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCB7IGVwc2lsb24sIHNwYXRpYWwsIGZvcm1hdCB9ID0gYXR0cmlidXRlcztcbiAgY29uc3QgeVNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBzcGF0aWFsID8gZ2V0TWF4Q29tcG9uZW50cyh5U2hhcGVbeVNoYXBlLmxlbmd0aCAtIDFdKSA6IDE7XG4gIGNvbnN0IGNDb21wb25lbnRzID0gZm9ybWF0ID09PSAnTkhXQycgJiYgeVNoYXBlLmxlbmd0aCA+IDEgPyBjb21wb25lbnRzIDogMTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKHlTaGFwZSkgLyBjb21wb25lbnRzO1xuICAvLyBPbmx5IHN1cHBvcnQgdW5pZm9ybXMgZm9yIG9wc2V0IHZlcnNpb24gPj0gOSAoc3BhdGlhbCA9IHRydWUpLlxuICBjb25zdCB1c2VTaGFwZXNVbmlmb3JtcyA9IHNwYXRpYWw7XG4gIGNvbnN0IHNoYXBlT3JSYW5rID0gdXNlU2hhcGVzVW5pZm9ybXMgPyB5U2hhcGUubGVuZ3RoIDogeVNoYXBlO1xuICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMsIGNvbXBvbmVudHMpO1xuICBjb25zdCBzY2FsZSA9IGlucHV0VmFyaWFibGUoJ3NjYWxlJywgaW5wdXRzWzFdLmRhdGFUeXBlLCBpbnB1dHNbMV0uZGltcywgY0NvbXBvbmVudHMpO1xuICBjb25zdCBiaWFzID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMsIGNDb21wb25lbnRzKTtcbiAgY29uc3QgaW5wdXRNZWFuID0gaW5wdXRWYXJpYWJsZSgnaW5wdXRNZWFuJywgaW5wdXRzWzNdLmRhdGFUeXBlLCBpbnB1dHNbM10uZGltcywgY0NvbXBvbmVudHMpO1xuICBjb25zdCBpbnB1dFZhciA9IGlucHV0VmFyaWFibGUoJ2lucHV0VmFyJywgaW5wdXRzWzRdLmRhdGFUeXBlLCBpbnB1dHNbNF0uZGltcywgY0NvbXBvbmVudHMpO1xuICBjb25zdCB5ID0gb3V0cHV0VmFyaWFibGUoJ3knLCBpbnB1dHNbMF0uZGF0YVR5cGUsIHNoYXBlT3JSYW5rLCBjb21wb25lbnRzKTtcbiAgLy8gVE9ETzogc3VwcG9ydCBpbnB1dHMgd2l0aCBkaWZmZXJlbnQgZGF0YSB0eXBlLiBDdXJyZW50IHdlIG5lZWQgdG8gbWFrZSBzdXJlIGFsbCBpbnB1dHMgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGUuXG4gIC8vIE90aGVyd2lzZSwgdGhlIHNoYWRlciBjb21waWxhdGlvbiB3aWxsIGZhaWwuXG4gIGNvbnN0IGNhbGNDT2Zmc2V0ID0gKCk6IHN0cmluZyA9PiB7XG4gICAgbGV0IGNPZmZzZXQgPSAnJztcbiAgICBpZiAoc3BhdGlhbCkge1xuICAgICAgY09mZnNldCA9IGBsZXQgY09mZnNldCA9ICR7XG4gICAgICAgIHlTaGFwZS5sZW5ndGggPT09IDFcbiAgICAgICAgICA/ICcwdSdcbiAgICAgICAgICA6IGZvcm1hdCA9PT0gJ05IV0MnXG4gICAgICAgICAgICA/IGBvdXRwdXRJbmRpY2VzWyR7eVNoYXBlLmxlbmd0aCAtIDF9XSAvICR7Y29tcG9uZW50c31gXG4gICAgICAgICAgICA6ICdvdXRwdXRJbmRpY2VzWzFdJ1xuICAgICAgfTtgO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZm9ybWF0ID09PSAnTkNIVycpIHtcbiAgICAgICAgY09mZnNldCA9IGBcbiAgICAgICAgICAgICR7eS5pbmRpY2VzU2V0KCdvdXRwdXRJbmRpY2VzJywgJzAnLCAnMCcpfVxuICAgICAgICAgICAgbGV0IGNPZmZzZXQgPSAke3kuaW5kaWNlc1RvT2Zmc2V0KCdvdXRwdXRJbmRpY2VzJyl9O2A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1cGRhdGUgQyBjaGFubmVsLlxuICAgICAgICBjT2Zmc2V0ID0gYHZhciBjSW5kaWNlcyA9ICR7c2NhbGUudHlwZS5pbmRpY2VzfSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgY0luZGljZXNbMF0gPSBvdXRwdXRJbmRpY2VzWyR7eVNoYXBlLmxlbmd0aCAtIDF9XTtgO1xuICAgICAgICAvLyB1cGRhdGUgRDEgeCAuLi4geCBEbiBjaGFubmVscy5cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzY2FsZS5yYW5rOyBpKyspIHtcbiAgICAgICAgICBjT2Zmc2V0ICs9IGBjSW5kaWNlc1ske2l9XSA9IG91dHB1dEluZGljZXNbJHtpfV07YDtcbiAgICAgICAgfVxuICAgICAgICBjT2Zmc2V0ICs9IGBsZXQgY09mZnNldCA9ICR7c2NhbGUuaW5kaWNlc1RvT2Zmc2V0KCdjSW5kaWNlcycpfTtgO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY09mZnNldDtcbiAgfTtcbiAgY29uc3QgZ2V0SW5mZXJlbmNlTW9kZVNoYWRlclNvdXJjZSA9IChoZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICBjb25zdCBlcHNpbG9uID0gJHtlcHNpbG9ufTtcbiAgJHtoZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRTaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoeCwgc2NhbGUsIGJpYXMsIGlucHV0TWVhbiwgaW5wdXRWYXIsIHkpfVxuICAke2hlbHBlci5tYWluU3RhcnQoKX1cbiAgJHtoZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxuICAgIHZhciBvdXRwdXRJbmRpY2VzID0gJHt5Lm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqICR7Y29tcG9uZW50c31gKX07XG4gICAgJHtjYWxjQ09mZnNldCgpfVxuICAgIGxldCBzY2FsZSA9ICR7c2NhbGUuZ2V0QnlPZmZzZXQoJ2NPZmZzZXQnKX07XG4gICAgbGV0IGJpYXMgPSAke2JpYXMuZ2V0QnlPZmZzZXQoJ2NPZmZzZXQnKX07XG4gICAgbGV0IGlucHV0TWVhbiA9ICR7aW5wdXRNZWFuLmdldEJ5T2Zmc2V0KCdjT2Zmc2V0Jyl9O1xuICAgIGxldCBpbnB1dFZhciA9ICR7aW5wdXRWYXIuZ2V0QnlPZmZzZXQoJ2NPZmZzZXQnKX07XG4gICAgbGV0IHggPSAke3guZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKX07XG4gICAgbGV0IHZhbHVlID0gKHggLSBpbnB1dE1lYW4pICogaW52ZXJzZVNxcnQoaW5wdXRWYXIgKyBlcHNpbG9uKSAqIHNjYWxlICsgYmlhcztcbiAgICAke3kuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWUnKX1cbiAgfWA7XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0JhdGNoTm9ybWFsaXphdGlvbicsXG4gICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgIGhpbnQ6IGAke2F0dHJpYnV0ZXMuZXBzaWxvbn1fJHthdHRyaWJ1dGVzLmZvcm1hdH1fJHtzcGF0aWFsfV8ke2NvbXBvbmVudHN9YCxcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiB1c2VTaGFwZXNVbmlmb3JtcyA/IFsncmFuaycsICd0eXBlJywgJ3R5cGUnLCAndHlwZScsICd0eXBlJ10gOiB1bmRlZmluZWQsXG4gICAgfSxcbiAgICBnZXRTaGFkZXJTb3VyY2U6IGdldEluZmVyZW5jZU1vZGVTaGFkZXJTb3VyY2UsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IGlucHV0c1swXS5kaW1zLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zOiB1c2VTaGFwZXNVbmlmb3Jtc1xuICAgICAgICA/IFt7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LCAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyh5U2hhcGUpXVxuICAgICAgICA6IFt7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9XSxcbiAgICB9KSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUJhdGNoTm9ybUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBCYXRjaE5vcm1BdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShhdHRyaWJ1dGVzIGFzIE9taXQ8QmF0Y2hOb3JtQXR0cmlidXRlcywga2V5b2YgQXR0cmlidXRlV2l0aENhY2hlS2V5Pik7XG5cbmV4cG9ydCBjb25zdCBiYXRjaE5vcm0gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdm9pZCA9PiB7XG4gIGNvbnN0IHsgaW5wdXRzLCBvdXRwdXRDb3VudCB9ID0gY29udGV4dDtcbiAgY29uc3QgdXBkYXRlZEF0dHJpYnV0ZXMgPSBwYXJzZUJhdGNoTm9ybUF0dHJpYnV0ZXMoeyAuLi5hdHRyaWJ1dGVzLCBvdXRwdXRDb3VudCB9KTtcbiAgaWYgKGVudi53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQpIHtcbiAgICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIHVwZGF0ZWRBdHRyaWJ1dGVzKTtcbiAgfVxuICBpZiAoYXR0cmlidXRlcy50cmFpbmluZ01vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhdGNoTm9ybWFsaXphdGlvbiB0cmFpbmluZ01vZGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQuJyk7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUJhdGNoTm9ybUluZmVyZW5jZVByb2dyYW1JbmZvKGlucHV0cywgdXBkYXRlZEF0dHJpYnV0ZXMpKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBzaG91bGQgaGF2ZSAzIGRpbWVuc2lvbnMnKTtcbiAgfVxuXG4gIGlmICghWzMyMCwgNjQwLCAxMjgwXS5pbmNsdWRlcyhpbnB1dHNbMF0uZGltc1syXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBvZiBjaGFubmVscyBzaG91bGQgYmUgMzIwLCA2NDAgb3IgMTI4MCcpO1xuICB9XG5cbiAgaWYgKGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignYmlhcyBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9ucycpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zWzJdICE9PSBpbnB1dHNbMV0uZGltc1swXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbGFzdCBkaW1lbnNpb24gb2YgaW5wdXQgYW5kIGJpYXMgYXJlIG5vdCB0aGUgc2FtZScpO1xuICB9XG59O1xuXG5jb25zdCBjcmVhdGVCaWFzQWRkUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG5cbiAgY29uc3QgY2hhbm5lbHMgPSBpbnB1dHNbMF0uZGltc1syXTtcbiAgLy8gc2luY2UgY2hhbm5lbCBudW1iZXIgY2FuIGJlIG9ubHkgMzIwLzY0MC8xMjgwLCBpdCdzIGFsd2F5cyBkaXZpc2FibGUgYnkgNFxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gNDtcblxuICBjb25zdCBkYXRhVHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgNCk7XG4gIGNvbnN0IGJpYXMgPSBpbnB1dFZhcmlhYmxlKCdiaWFzJywgZGF0YVR5cGUsIFtjaGFubmVsc10sIDQpO1xuICBjb25zdCByZXNpZHVhbCA9IGlucHV0VmFyaWFibGUoJ3Jlc2lkdWFsJywgZGF0YVR5cGUsIG91dHB1dFNoYXBlLCA0KTtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgNCk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG4gIGNvbnN0IGNoYW5uZWxzID0gJHtjaGFubmVsc311IC8gNDtcbiAgJHtzaGFkZXJIZWxwZXIuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgYmlhcywgcmVzaWR1YWwsIG91dHB1dCl9XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhvdXRwdXRTaXplKX1cbiAgICBsZXQgdmFsdWUgPSAke2lucHV0LmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4Jyl9XG4gICAgICArICR7Ymlhcy5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCAlIGNoYW5uZWxzJyl9ICsgJHtyZXNpZHVhbC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfTtcbiAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpfVxuICB9YDtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdCaWFzQWRkJyxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGJpYXNBZGQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQmlhc0FkZFByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzKSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUsXG4gIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUsXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxufSBmcm9tICcuL2NvbW1vbic7XG5cbnR5cGUgQnVpbHRpbkZ1bmN0aW9uTmFtZSA9IHN0cmluZztcbnR5cGUgRWxlbWVudHdpc2VDdXN0b21FeHByZXNzaW9uID0gKGV4cHJlc3Npb246IHN0cmluZykgPT4gc3RyaW5nO1xudHlwZSBFbGVtZW50d2lzZUZ1bmN0aW9uQ2FsbCA9IEJ1aWx0aW5GdW5jdGlvbk5hbWUgfCBFbGVtZW50d2lzZUN1c3RvbUV4cHJlc3Npb247XG5cbmNvbnN0IGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbVNoYWRlciA9IChcbiAgc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIsXG4gIGRhdGFzaXplOiBudW1iZXIsXG4gIGlucHV0RGF0YVR5cGU6IG51bWJlcixcbiAgb3V0cHV0RGF0YVR5cGU6IG51bWJlcixcbiAgZnVuY0NhbGw6IEVsZW1lbnR3aXNlRnVuY3Rpb25DYWxsLFxuICBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb24/OiBzdHJpbmcsXG4gIGFkZGl0aW9uYWxVbmlmb3Jtc1R5cGU/OiBVbmlmb3Jtc0FycmF5VHlwZSxcbik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHZlY1NpemUgPSBNYXRoLmNlaWwoZGF0YXNpemUgLyA0KTtcblxuICBsZXQgZXhwcmVzc2lvbiA9ICcnO1xuICBpZiAodHlwZW9mIGZ1bmNDYWxsID09PSAnc3RyaW5nJykge1xuICAgIGV4cHJlc3Npb24gPSBgJHtmdW5jQ2FsbH0oYSlgO1xuICB9IGVsc2Uge1xuICAgIGV4cHJlc3Npb24gPSBmdW5jQ2FsbCgnYScpO1xuICB9XG5cbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dERhdGEnLCBpbnB1dERhdGFUeXBlLCBbdmVjU2l6ZV0sIDQpO1xuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0RGF0YScsIG91dHB1dERhdGFUeXBlLCBbdmVjU2l6ZV0sIDQpO1xuICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbeyBuYW1lOiAndmVjX3NpemUnLCB0eXBlOiAndTMyJyB9XTtcbiAgaWYgKGFkZGl0aW9uYWxVbmlmb3Jtc1R5cGUpIHtcbiAgICB1bmlmb3Jtcy5wdXNoKC4uLmFkZGl0aW9uYWxVbmlmb3Jtc1R5cGUpO1xuICB9XG5cbiAgcmV0dXJuIGBcbiAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG5cbiAgJHthZGRpdGlvbmFsSW1wbGVtZW50YXRpb24gPz8gJyd9XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMudmVjX3NpemUnKX1cblxuICAgIGxldCBhID0gJHtpbnB1dC5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpfTtcbiAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsIGV4cHJlc3Npb24pfVxuICB9YDtcbn07XG5cbmNvbnN0IGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0OiBUZW5zb3JWaWV3LFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bmNDYWxsOiBFbGVtZW50d2lzZUZ1bmN0aW9uQ2FsbCxcbiAgYWRkaXRpb25hbEltcGxlbWVudGF0aW9uPzogc3RyaW5nLFxuICBjYWNoZUtleT86IHN0cmluZyxcbiAgb3V0cHV0RGF0YVR5cGU6IG51bWJlciA9IGlucHV0LmRhdGFUeXBlLFxuICBhZGRpdGlvbmFsVW5pZm9ybXM/OiBQcm9ncmFtVW5pZm9ybVtdLFxuICBhZGRpdGlvbmFsVW5pZm9ybXNUeXBlPzogVW5pZm9ybXNBcnJheVR5cGUsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKGlucHV0LmRpbXMpIC8gNCkgfSxcbiAgXTtcbiAgaWYgKGFkZGl0aW9uYWxVbmlmb3Jtcykge1xuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmFkZGl0aW9uYWxVbmlmb3Jtcyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWUsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogY2FjaGVLZXksIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3R5cGUnXSB9LFxuICAgIGdldFNoYWRlclNvdXJjZTogKHNoYWRlckhlbHBlcikgPT5cbiAgICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbVNoYWRlcihcbiAgICAgICAgc2hhZGVySGVscGVyLFxuICAgICAgICBTaGFwZVV0aWwuc2l6ZShpbnB1dC5kaW1zKSxcbiAgICAgICAgaW5wdXQuZGF0YVR5cGUsXG4gICAgICAgIG91dHB1dERhdGFUeXBlLFxuICAgICAgICBmdW5jQ2FsbCxcbiAgICAgICAgYWRkaXRpb25hbEltcGxlbWVudGF0aW9uLFxuICAgICAgICBhZGRpdGlvbmFsVW5pZm9ybXNUeXBlLFxuICAgICAgKSxcbiAgICBnZXRSdW5EYXRhOiAoaW5wdXRUZW5zb3JzKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogaW5wdXQuZGltcywgZGF0YVR5cGU6IG91dHB1dERhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDoge1xuICAgICAgICB4OiBNYXRoLmNlaWwoU2hhcGVVdGlsLnNpemUoaW5wdXRUZW5zb3JzWzBdLmRpbXMpIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8gLyA0IC8qIHZlYyBzaXplICovKSxcbiAgICAgIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgYWJzID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQWJzJywgJ2FicycpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBhY29zID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQWNvcycsICdhY29zJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGFjb3NoID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQWNvc2gnLCAnYWNvc2gnKSk7XG59O1xuXG5leHBvcnQgY29uc3QgYXNpbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0FzaW4nLCAnYXNpbicpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBhc2luaCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0FzaW5oJywgJ2FzaW5oJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGF0YW4gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdBdGFuJywgJ2F0YW4nKSk7XG59O1xuZXhwb3J0IGNvbnN0IGF0YW5oID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQXRhbmgnLCAnYXRhbmgnKSk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIENhc3RBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgdG86IG51bWJlcjtcbiAgcmVhZG9ubHkgc2F0dXJhdGU/OiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgcGFyc2VDYXN0QXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IENhc3RBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShhdHRyaWJ1dGVzIGFzIHsgdG86IG51bWJlciB9KTtcblxuZXhwb3J0IGNvbnN0IGNhc3QgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IENhc3RBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGxldCBmdW5jOiBFbGVtZW50d2lzZUZ1bmN0aW9uQ2FsbDtcbiAgc3dpdGNoIChhdHRyaWJ1dGVzLnRvKSB7XG4gICAgY2FzZSBEYXRhVHlwZS5mbG9hdDE2OlxuICAgICAgZnVuYyA9ICd2ZWM0PGYxNj4nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBEYXRhVHlwZS5mbG9hdDpcbiAgICAgIGZ1bmMgPSAndmVjNDxmMzI+JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRGF0YVR5cGUudWludDMyOlxuICAgICAgZnVuYyA9ICd2ZWM0PHUzMj4nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBEYXRhVHlwZS5pbnQzMjpcbiAgICAgIGZ1bmMgPSAndmVjNDxpMzI+JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRGF0YVR5cGUuYm9vbDpcbiAgICAgIGZ1bmMgPSAndmVjNDxib29sPic7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYG5vdCBzdXBwb3J0ZWQgdHlwZSAoc3BlY2lmaWVkIGluIGF0dHJpYnV0ZSAndG8nIGZyb20gJ0Nhc3QnIG9wZXJhdG9yKTogJHthdHRyaWJ1dGVzLnRvfWApO1xuICB9XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQ2FzdCcsIGZ1bmMsIHVuZGVmaW5lZCwgYXR0cmlidXRlcy5jYWNoZUtleSwgYXR0cmlidXRlcy50byksXG4gICk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIENsaXBBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgbWluOiBudW1iZXI7XG4gIHJlYWRvbmx5IG1heDogbnVtYmVyO1xufVxuXG5jb25zdCBnZW5lcmF0ZUNsaXBBdHRyaWJ1dGVzRnJvbUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IENsaXBBdHRyaWJ1dGVzID0+IHtcbiAgbGV0IG1pbjogbnVtYmVyO1xuICBsZXQgbWF4OiBudW1iZXI7XG4gIGNvbnN0IGhhc01pbiA9IGlucHV0cy5sZW5ndGggPj0gMiAmJiBpbnB1dHNbMV0uZGF0YSAhPT0gMDtcbiAgY29uc3QgaGFzTWF4ID0gaW5wdXRzLmxlbmd0aCA+PSAzICYmIGlucHV0c1syXS5kYXRhICE9PSAwO1xuXG4gIHN3aXRjaCAoaW5wdXRzWzBdLmRhdGFUeXBlKSB7XG4gICAgY2FzZSBEYXRhVHlwZS5mbG9hdDpcbiAgICAgIG1pbiA9IGhhc01pbiA/IGlucHV0c1sxXS5nZXRGbG9hdDMyQXJyYXkoKVswXSA6IC0zLjQwMjgyMzQ2NjM4NTI4ODZlMzg7XG4gICAgICBtYXggPSBoYXNNYXggPyBpbnB1dHNbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF0gOiAzLjQwMjgyMzQ2NjM4NTI4ODZlMzg7XG4gICAgICBicmVhaztcbiAgICBjYXNlIERhdGFUeXBlLmZsb2F0MTY6XG4gICAgICBtaW4gPSBoYXNNaW4gPyBpbnB1dHNbMV0uZ2V0VWludDE2QXJyYXkoKVswXSA6IDY0NTExOyAvLyB1aW50MTYoNjQ1MTEpIDwtPiBmbG9hdDE2KC02NTUwNC4wKVxuICAgICAgbWF4ID0gaGFzTWF4ID8gaW5wdXRzWzJdLmdldFVpbnQxNkFycmF5KClbMF0gOiAzMTc0MzsgLy8gdWludDE2KDMxNzQzKSA8LT4gZmxvYXQxNig2NTUwNC4wKVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0IGRhdGEgdHlwZScpO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IG1pbiwgbWF4IH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGNsaXAgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGNsaXBBdHRyaWJ1dGVzOiBDbGlwQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gY2xpcEF0dHJpYnV0ZXMgPyBjbGlwQXR0cmlidXRlcyA6IGdlbmVyYXRlQ2xpcEF0dHJpYnV0ZXNGcm9tSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcbiAgICAgICdDbGlwJyxcbiAgICAgIChhKSA9PiBgY2xhbXAoJHthfSwgdmVjNDwke2RhdGFUeXBlfT4odW5pZm9ybXMubWluKSwgdmVjNDwke2RhdGFUeXBlfT4odW5pZm9ybXMubWF4KSlgLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIFtcbiAgICAgICAgeyB0eXBlOiBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSwgZGF0YTogYXR0cmlidXRlcy5taW4gfSxcbiAgICAgICAgeyB0eXBlOiBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSwgZGF0YTogYXR0cmlidXRlcy5tYXggfSxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgIHsgbmFtZTogJ21pbicsIHR5cGU6IGRhdGFUeXBlIGFzIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUgfSxcbiAgICAgICAgeyBuYW1lOiAnbWF4JywgdHlwZTogZGF0YVR5cGUgYXMgVW5pZm9ybURhdGFFbGVtZW50VHlwZSB9LFxuICAgICAgXSxcbiAgICApLFxuICAgIHsgaW5wdXRzOiBbMF0gfSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBjZWlsID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnQ2VpbCcsICdjZWlsJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvcyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0NvcycsICdjb3MnKSk7XG59O1xuXG5leHBvcnQgY29uc3QgY29zaCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0Nvc2gnLCAnY29zaCcpKTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWxwaGFBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgcmVhZG9ubHkgYWxwaGE6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IHBhcnNlQWxwaGFBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQWxwaGFBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShhdHRyaWJ1dGVzIGFzIHsgYWxwaGE6IG51bWJlciB9KTtcblxuZXhwb3J0IGNvbnN0IGVsdSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQWxwaGFBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0sXG4gICAgICAnRWx1JyxcbiAgICAgIChhKSA9PiBgZWx1X3ZmMzIoJHthfSlgLFxuICAgICAgYFxuICBjb25zdCBlbHVfYWxwaGFfID0gJHtkYXRhVHlwZX0oJHthdHRyaWJ1dGVzLmFscGhhfSk7XG5cbiAgZm4gZWx1X2YzMihhOiAke2RhdGFUeXBlfSkgLT4gJHtkYXRhVHlwZX0ge1xuICByZXR1cm4gc2VsZWN0KChleHAoYSkgLSAxLjApICogZWx1X2FscGhhXywgYSwgYSA+PSAwLjApO1xuICB9XG5cbiAgZm4gZWx1X3ZmMzIodjogdmVjNDwke2RhdGFUeXBlfT4pIC0+IHZlYzQ8JHtkYXRhVHlwZX0+IHtcbiAgcmV0dXJuIHZlYzQoZWx1X2YzMih2LngpLCBlbHVfZjMyKHYueSksIGVsdV9mMzIodi56KSwgZWx1X2YzMih2LncpKTtcbiAgfWAsXG4gICAgICBhdHRyaWJ1dGVzLmNhY2hlS2V5LFxuICAgICksXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgZXJmSW1wbCA9ICh2YXJUeXBlID0gJ2YzMicpID0+IGBcbmNvbnN0IHIwOiAke3ZhclR5cGV9ID0gMC4zMjc1OTExO1xuY29uc3QgcjE6ICR7dmFyVHlwZX0gPSAwLjI1NDgyOTU5MjtcbmNvbnN0IHIyOiAke3ZhclR5cGV9ID0gLTAuMjg0NDk2NzM2O1xuY29uc3QgcjM6ICR7dmFyVHlwZX0gPSAxLjQyMTQxMzc0MTtcbmNvbnN0IHI0OiAke3ZhclR5cGV9ID0gLTEuNDUzMTUyMDI3O1xuY29uc3QgcjU6ICR7dmFyVHlwZX0gPSAxLjA2MTQwNTQyOTtcblxuZm4gZXJmX3ZmMzIodjogdmVjNDwke3ZhclR5cGV9PikgLT4gdmVjNDwke3ZhclR5cGV9PiB7XG4gIGxldCBhYnN2ID0gYWJzKHYpO1xuICBsZXQgeCA9IDEuMCAvICgxLjAgKyByMCAqIGFic3YpO1xuICByZXR1cm4gc2lnbih2KSAqICgxLjAgLSAoKCgocjUgKiB4ICsgcjQpICogeCArIHIzKSAqIHggKyByMikgKiB4ICsgcjEpICogeCAqIGV4cCgtYWJzdiAqIGFic3YpKTtcbn1gO1xuXG5leHBvcnQgY29uc3QgZXJmID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnRXJmJywgKGEpID0+IGBlcmZfdmYzMigke2F9KWAsIGVyZkltcGwoZGF0YVR5cGUpKSk7XG59O1xuXG5leHBvcnQgY29uc3QgZXhwID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnRXhwJywgJ2V4cCcpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBmbG9vciA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ0Zsb29yJywgJ2Zsb29yJykpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcbiAgICAgICdHZWx1JyxcbiAgICAgIChhKSA9PiBgMC41ICogJHthfSAqICgxLjAgKyBlcmZfdmYzMigke2F9ICogMC43MDcxMDY3ODExODY1NDc1KSlgLFxuICAgICAgZXJmSW1wbChkYXRhVHlwZSksXG4gICAgKSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBsZWFreVJlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEFscGhhQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUpO1xuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLFxuICAgICAgJ0xlYWt5UmVsdScsXG4gICAgICAoYSkgPT4gYHNlbGVjdChsZWFreV9yZWx1X2FscGhhXyAqICR7YX0sICR7YX0sICR7YX0gPj0gdmVjNDwke2RhdGFUeXBlfT4oMC4wKSlgLFxuICAgICAgYGNvbnN0IGxlYWt5X3JlbHVfYWxwaGFfID0gJHtkYXRhVHlwZX0oJHthdHRyaWJ1dGVzLmFscGhhfSk7YCxcbiAgICAgIGF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gICAgKSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBub3QgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sICdOb3QnLCAoYSkgPT4gYCEke2F9YCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IG5lZyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ05lZycsIChhKSA9PiBgLSR7YX1gKSk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVjaXByb2NhbCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1JlY2lwcm9jYWwnLCAoYSkgPT4gYDEuMC8ke2F9YCkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcbiAgICAgICdSZWx1JyxcbiAgICAgIChhKSA9PiBgc2VsZWN0KHZlYzQ8JHtkYXRhVHlwZX0+KDAuMCksICR7YX0sICR7YX0gPiB2ZWM0PCR7ZGF0YVR5cGV9PigwLjApKWAsXG4gICAgKSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzaWdtb2lkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnU2lnbW9pZCcsIChhKSA9PiBgKDEuMCAvICgxLjAgKyBleHAoLSR7YX0pKSlgKSk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEhhcmRTaWdtb2lkQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGFscGhhOiBudW1iZXI7XG4gIHJlYWRvbmx5IGJldGE6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IHBhcnNlSGFyZFNpZ21vaWRBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogSGFyZFNpZ21vaWRBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShcbiAgICBhdHRyaWJ1dGVzIGFzIHtcbiAgICAgIGFscGhhOiBudW1iZXI7XG4gICAgICBiZXRhOiBudW1iZXI7XG4gICAgfSxcbiAgKTtcblxuZXhwb3J0IGNvbnN0IGhhcmRTaWdtb2lkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBIYXJkU2lnbW9pZEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcbiAgICAgICdIYXJkU2lnbW9pZCcsXG4gICAgICAoYSkgPT5cbiAgICAgICAgYG1heCh2ZWM0PCR7ZGF0YVR5cGV9PigwLjApLCBtaW4odmVjNDwke2RhdGFUeXBlfT4oMS4wKSwgJHthdHRyaWJ1dGVzLmFscGhhfSAqICR7YX0gKyB2ZWM0PCR7ZGF0YVR5cGV9Pigke2F0dHJpYnV0ZXMuYmV0YX0pKSlgLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgICApLFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IHNpbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1NpbicsICdzaW4nKSk7XG59O1xuXG5leHBvcnQgY29uc3Qgc2luaCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1NpbmgnLCAnc2luaCcpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzcXJ0ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnU3FydCcsICdzcXJ0JykpO1xufTtcblxuZXhwb3J0IGNvbnN0IHRhbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1RhbicsICd0YW4nKSk7XG59O1xuXG5leHBvcnQgY29uc3QgdGFuaEV4cHJlc3Npb24gPSAoYTogc3RyaW5nKSA9PiBgc2lnbigke2F9KSAqICgxIC0gZXhwKC0yICogYWJzKCR7YX0pKSkgLyAoMSArIGV4cCgtMiAqIGFicygke2F9KSkpYDtcblxuZXhwb3J0IGNvbnN0IHRhbmggPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgLy8gVE9ETzogcmV2aXNpdCBhZnRlciBodHRwczovL2dpdGh1Yi5jb20vZ3B1d2ViL2dwdXdlYi9pc3N1ZXMvNDQ1OCBpcyByZXNvbHZlZFxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgJ1RhbmgnLCB0YW5oRXhwcmVzc2lvbikpO1xufTtcblxuZXhwb3J0IGNvbnN0IGZhc3RHZWx1SW1wbCA9ICh2YXJUeXBlID0gJ2YzMicpID0+IGBcbmNvbnN0IGZhc3RfZ2VsdV9hOiAke3ZhclR5cGV9ID0gMC41O1xuY29uc3QgZmFzdF9nZWx1X2I6ICR7dmFyVHlwZX0gPSAwLjc5Nzg4NDU2MDgwMjg2NTQ7XG5jb25zdCBmYXN0X2dlbHVfYzogJHt2YXJUeXBlfSA9IDAuMDM1Njc3NDA4MTM2MzAwMTI1O1xuXG5mbiB0YW5oX3YodjogdmVjNDwke3ZhclR5cGV9PikgLT4gdmVjNDwke3ZhclR5cGV9PiB7XG4gIHJldHVybiAke3RhbmhFeHByZXNzaW9uKCd2Jyl9O1xufVxuYDtcblxuZXhwb3J0IGNvbnN0IGZhc3RHZWx1RXhwcmVzc2lvbiA9ICh4OiBzdHJpbmcpID0+XG4gIGAoZmFzdF9nZWx1X2EgKyBmYXN0X2dlbHVfYSAqIHRhbmhfdigke3h9ICogKGZhc3RfZ2VsdV9jICogJHt4fSAqICR7eH0gKyBmYXN0X2dlbHVfYikpKSAqICR7eH1gO1xuXG5leHBvcnQgY29uc3QgZmFzdEdlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZUVsZW1lbnR3aXNlUHJvZ3JhbUluZm8oXG4gICAgICBjb250ZXh0LmlucHV0c1swXSxcbiAgICAgICdGYXN0R2VsdScsXG4gICAgICBmYXN0R2VsdUV4cHJlc3Npb24sXG4gICAgICBmYXN0R2VsdUltcGwoZGF0YVR5cGUpLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsXG4gICAgKSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCB0aHJlc2hvbGRlZFJlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEFscGhhQXR0cmlidXRlcyk6IG51bWJlciA9PiB7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZShjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSk7XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0sXG4gICAgICAnVGhyZXNob2xkZWRSZWx1JyxcbiAgICAgIChhKSA9PiBgc2VsZWN0KHZlYzQ8JHtkYXRhVHlwZX0+KDAuMCksICR7YX0sICR7YX0gPiB0aHJlc2hvbGRlZF9yZWx1X2FscGhhXylgLFxuICAgICAgYGNvbnN0IHRocmVzaG9sZGVkX3JlbHVfYWxwaGFfID0gdmVjNDwke2RhdGFUeXBlfT4oJHthdHRyaWJ1dGVzLmFscGhhfSk7YCxcbiAgICAgIGF0dHJpYnV0ZXMuY2FjaGVLZXksXG4gICAgKSxcbiAgKTtcbiAgcmV0dXJuIDA7XG59O1xuXG5leHBvcnQgY29uc3QgbG9nID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVFbGVtZW50d2lzZVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzWzBdLCAnTG9nJywgJ2xvZycpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBxdWlja0dlbHVJbXBsID0gKHZhclR5cGU6IHN0cmluZywgYWxwaGE6IG51bWJlcikgPT4gYFxuY29uc3QgYWxwaGEgPSB2ZWM0PCR7dmFyVHlwZX0+KCR7YWxwaGF9KTtcbmNvbnN0IG9uZSA9ICR7dmFyVHlwZX0oMS4wKTtcbmNvbnN0IHplcm8gPSAke3ZhclR5cGV9KDAuMCk7XG5cbmZuIHF1aWNrX2dlbHVfaW1wbCh4OiB2ZWM0PCR7dmFyVHlwZX0+KSAtPiB2ZWM0PCR7dmFyVHlwZX0+IHtcbiAgbGV0IHYgPSB4ICphbHBoYTtcbiAgdmFyIHgxIDogdmVjNDwke3ZhclR5cGV9PjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpID0gaSArIDEpIHtcbiAgICBpZiAodltpXSA+PSB6ZXJvKSB7XG4gICAgICB4MVtpXSA9IG9uZSAvIChvbmUgKyBleHAoLXZbaV0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeDFbaV0gPSBvbmUgLSBvbmUgLyAob25lICsgZXhwKHZbaV0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHggKiB4MTtcbn1cbmA7XG5cbmV4cG9ydCBjb25zdCBxdWlja0dlbHVFeHByZXNzaW9uID0gKHg6IHN0cmluZykgPT4gYHF1aWNrX2dlbHVfaW1wbCgke3h9KWA7XG5cbmV4cG9ydCBjb25zdCBxdWlja2dlbHUgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEFscGhhQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBkVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUoY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUpO1xuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgY3JlYXRlRWxlbWVudHdpc2VQcm9ncmFtSW5mbyhcbiAgICAgIGNvbnRleHQuaW5wdXRzWzBdLFxuICAgICAgJ1F1aWNrR2VsdScsXG4gICAgICBxdWlja0dlbHVFeHByZXNzaW9uLFxuICAgICAgcXVpY2tHZWx1SW1wbChkVHlwZSwgYXR0cmlidXRlcy5hbHBoYSksXG4gICAgICBhdHRyaWJ1dGVzLmNhY2hlS2V5LFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUsXG4gICAgKSxcbiAgKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciwgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlIH0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IHsgZXJmSW1wbCB9IGZyb20gJy4vdW5hcnktb3AnO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBzaG91bGQgaGF2ZSAzIGRpbWVuc2lvbnMnKTtcbiAgfVxuXG4gIGlmICghWzI1NjAsIDUxMjAsIDEwMjQwXS5pbmNsdWRlcyhpbnB1dHNbMF0uZGltc1syXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2hpZGRlbiBzdGF0ZSBzaG91bGQgYmUgMjU2MCwgNTEyMCBvciAxMDI0MCcpO1xuICB9XG5cbiAgaWYgKGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignYmlhcyBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9ucycpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zWzJdICE9PSBpbnB1dHNbMV0uZGltc1swXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbGFzdCBkaW1lbnNpb24gb2YgaW5wdXQgYW5kIGJpYXMgYXJlIG5vdCB0aGUgc2FtZScpO1xuICB9XG59O1xuXG5jb25zdCBjcmVhdGVCaWFzU3BsaXRHZWx1UHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXMuc2xpY2UoKTtcbiAgb3V0cHV0U2hhcGVbMl0gPSBvdXRwdXRTaGFwZVsyXSAvIDI7XG5cbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMsIDQpO1xuICBjb25zdCBiaWFzID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1swXS5kYXRhVHlwZSwgW2lucHV0c1swXS5kaW1zWzJdXSwgNCk7XG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLCA0KTtcblxuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gNDtcbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgY29uc3QgTV9TUVJUMiA9IHNxcnQoMi4wKTtcbiAgY29uc3QgaGFsZkNoYW5uZWxzID0gJHtpbnB1dHNbMF0uZGltc1syXSAvIDQgLyAyfXU7XG5cbiAgJHtzaGFkZXJIZWxwZXIuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgYmlhcywgb3V0cHV0KX1cblxuICAke2VyZkltcGwoZGF0YVR5cGUpfVxuXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMob3V0cHV0U2l6ZSl9XG4gICAgbGV0IGJpYXNJZHggPSBnbG9iYWxfaWR4ICUgaGFsZkNoYW5uZWxzO1xuICAgIGxldCBiYXRjaEluZGV4ID0gZ2xvYmFsX2lkeCAvIGhhbGZDaGFubmVscztcbiAgICBsZXQgaW5wdXRPZmZzZXQgPSBiaWFzSWR4ICsgYmF0Y2hJbmRleCAqIGhhbGZDaGFubmVscyAqIDI7XG4gICAgbGV0IHZhbHVlTGVmdCA9IGlucHV0W2lucHV0T2Zmc2V0XSArIGJpYXNbYmlhc0lkeF07XG4gICAgbGV0IHZhbHVlUmlnaHQgPSBpbnB1dFtpbnB1dE9mZnNldCArIGhhbGZDaGFubmVsc10gKyBiaWFzW2JpYXNJZHggKyBoYWxmQ2hhbm5lbHNdO1xuICAgIGxldCBnZWx1UmlnaHQgPSB2YWx1ZVJpZ2h0ICogMC41ICogKGVyZl92ZjMyKHZhbHVlUmlnaHQgLyBNX1NRUlQyKSArIDEpO1xuXG4gICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWVMZWZ0ICogZ2VsdVJpZ2h0Jyl9XG4gIH1gO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0JpYXNTcGxpdEdlbHUnLFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgYmlhc1NwbGl0R2VsdSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVCaWFzU3BsaXRHZWx1UHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMpKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IEJyb2FkY2FzdFV0aWwsIFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcblxudHlwZSBCdWlsdGluRnVuY3Rpb25OYW1lID0gc3RyaW5nO1xudHlwZSBCaW5hcnlDdXN0b21FeHByZXNzaW9uID0gKGV4cHJlc3Npb25BOiBzdHJpbmcsIGV4cHJlc3Npb25COiBzdHJpbmcpID0+IHN0cmluZztcbnR5cGUgQmluYXJ5RnVuY3Rpb25DYWxsID1cbiAgfCBCdWlsdGluRnVuY3Rpb25OYW1lXG4gIHwgQmluYXJ5Q3VzdG9tRXhwcmVzc2lvblxuICB8IHtcbiAgICAgIHNjYWxhcjogQmluYXJ5Q3VzdG9tRXhwcmVzc2lvbjtcbiAgICAgIHZlY3RvcjogQmluYXJ5Q3VzdG9tRXhwcmVzc2lvbjtcbiAgICB9O1xuXG5jb25zdCBjcmVhdGVCaW5hcnlPcFByb2dyYW1TaGFkZXIgPSAoXG4gIHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyLFxuICBkaW1zQTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGRpbXNCOiByZWFkb25seSBudW1iZXJbXSxcbiAgZGltc091dHB1dDogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHZlY3Rvcml6ZTogYm9vbGVhbixcbiAgZG9Ccm9hZGNhc3Q6IGJvb2xlYW4sXG4gIHNoYXJlZERpbWVuc2lvbkRpdmlzaWJsZUJ5NDogYm9vbGVhbixcbiAgZnVuY0NhbGw6IEJpbmFyeUZ1bmN0aW9uQ2FsbCxcbiAgdHlwZUE6IG51bWJlcixcbiAgdHlwZUI6IG51bWJlcixcbiAgdHlwZU91dHB1dDogbnVtYmVyLFxuICBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb24/OiBzdHJpbmcsXG4pID0+IHtcbiAgbGV0IGV4cHJlc3Npb25TY2FsYXI6IEJpbmFyeUN1c3RvbUV4cHJlc3Npb247XG4gIGxldCBleHByZXNzaW9uVmVjdG9yOiBCaW5hcnlDdXN0b21FeHByZXNzaW9uO1xuICBpZiAodHlwZW9mIGZ1bmNDYWxsID09PSAnc3RyaW5nJykge1xuICAgIGV4cHJlc3Npb25TY2FsYXIgPSBleHByZXNzaW9uVmVjdG9yID0gKGEsIGIpID0+IGAke2Z1bmNDYWxsfSgoJHthfSksKCR7Yn0pKWA7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGZ1bmNDYWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXhwcmVzc2lvblNjYWxhciA9IGV4cHJlc3Npb25WZWN0b3IgPSBmdW5jQ2FsbDtcbiAgfSBlbHNlIHtcbiAgICBleHByZXNzaW9uU2NhbGFyID0gZnVuY0NhbGwuc2NhbGFyO1xuICAgIGV4cHJlc3Npb25WZWN0b3IgPSBmdW5jQ2FsbC52ZWN0b3I7XG4gIH1cblxuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0RGF0YScsIHR5cGVPdXRwdXQsIGRpbXNPdXRwdXQubGVuZ3RoLCA0KTtcbiAgY29uc3QgYSA9IGlucHV0VmFyaWFibGUoJ2FEYXRhJywgdHlwZUEsIGRpbXNBLmxlbmd0aCwgNCk7XG4gIGNvbnN0IGIgPSBpbnB1dFZhcmlhYmxlKCdiRGF0YScsIHR5cGVCLCBkaW1zQi5sZW5ndGgsIDQpO1xuXG4gIGxldCBhc3NpZ25tZW50OiBzdHJpbmc7XG4gIGlmICh2ZWN0b3JpemUpIHtcbiAgICBpZiAoZG9Ccm9hZGNhc3QpIHtcbiAgICAgIGNvbnN0IGlzQU9uZUVsZW1lbnQgPSBTaGFwZVV0aWwuc2l6ZShkaW1zQSkgPT09IDE7XG4gICAgICBjb25zdCBpc0JPbmVFbGVtZW50ID0gU2hhcGVVdGlsLnNpemUoZGltc0IpID09PSAxO1xuICAgICAgY29uc3QgYUxhc3REaW1EaXZpc2libGVCeTQgPSBkaW1zQS5sZW5ndGggPiAwICYmIGRpbXNBW2RpbXNBLmxlbmd0aCAtIDFdICUgNCA9PT0gMDtcbiAgICAgIGNvbnN0IGJMYXN0RGltRGl2aXNpYmxlQnk0ID0gZGltc0IubGVuZ3RoID4gMCAmJiBkaW1zQltkaW1zQi5sZW5ndGggLSAxXSAlIDQgPT09IDA7XG4gICAgICBpZiAoaXNBT25lRWxlbWVudCB8fCBpc0JPbmVFbGVtZW50KSB7XG4gICAgICAgIGFzc2lnbm1lbnQgPSBvdXRwdXQuc2V0QnlPZmZzZXQoXG4gICAgICAgICAgJ2dsb2JhbF9pZHgnLFxuICAgICAgICAgIGV4cHJlc3Npb25WZWN0b3IoXG4gICAgICAgICAgICBpc0FPbmVFbGVtZW50ID8gYCR7YS50eXBlLnZhbHVlfSgke2EuZ2V0QnlPZmZzZXQoJzAnKX0ueClgIDogYS5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpLFxuICAgICAgICAgICAgaXNCT25lRWxlbWVudCA/IGAke2IudHlwZS52YWx1ZX0oJHtiLmdldEJ5T2Zmc2V0KCcwJyl9LngpYCA6IGIuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKSxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNzaWdubWVudCA9IGBcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4ICogNHUnKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSA9ICR7YS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCgnb3V0cHV0SW5kaWNlcycsIG91dHB1dCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEIgPSAke2IuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoJ291dHB1dEluZGljZXMnLCBvdXRwdXQpfTtcbiAgICAgICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KFxuICAgICAgICAgICAgICAnZ2xvYmFsX2lkeCcsXG4gICAgICAgICAgICAgIGV4cHJlc3Npb25WZWN0b3IoXG4gICAgICAgICAgICAgICAgc2hhcmVkRGltZW5zaW9uRGl2aXNpYmxlQnk0IHx8IGFMYXN0RGltRGl2aXNpYmxlQnk0XG4gICAgICAgICAgICAgICAgICA/IGEuZ2V0QnlPZmZzZXQoJ29mZnNldEEgLyA0dScpXG4gICAgICAgICAgICAgICAgICA6IGAke2EudHlwZS52YWx1ZX0oJHthLmdldEJ5T2Zmc2V0KCdvZmZzZXRBIC8gNHUnKX1bb2Zmc2V0QSAlIDR1XSlgLFxuICAgICAgICAgICAgICAgIHNoYXJlZERpbWVuc2lvbkRpdmlzaWJsZUJ5NCB8fCBiTGFzdERpbURpdmlzaWJsZUJ5NFxuICAgICAgICAgICAgICAgICAgPyBiLmdldEJ5T2Zmc2V0KCdvZmZzZXRCIC8gNHUnKVxuICAgICAgICAgICAgICAgICAgOiBgJHtiLnR5cGUudmFsdWV9KCR7Yi5nZXRCeU9mZnNldCgnb2Zmc2V0QiAvIDR1Jyl9W29mZnNldEIgJSA0dV0pYCxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICl9XG4gICAgICAgICAgYDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWdubWVudCA9IG91dHB1dC5zZXRCeU9mZnNldChcbiAgICAgICAgJ2dsb2JhbF9pZHgnLFxuICAgICAgICBleHByZXNzaW9uVmVjdG9yKGEuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKSwgYi5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpKSxcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghZG9Ccm9hZGNhc3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gbmVjZXNzYXJ5IHRvIHVzZSBzY2FsYXIgaW1wbGVtZW50YXRpb24gZm9yIGVsZW1lbnQtd2lzZSBiaW5hcnkgb3AgaW1wbGVtZW50YXRpb24uJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2luZ2xlQXNzaWdubWVudCA9IChyZXNTdHI6IHN0cmluZywgeDogbnVtYmVyLCB0eXBlQ2FzdCA9ICcnKSA9PiB7XG4gICAgICBjb25zdCBleHByZXNzaW9uQSA9IGBhRGF0YVtpbmRleEEke3h9XVtjb21wb25lbnRBJHt4fV1gO1xuICAgICAgY29uc3QgZXhwcmVzc2lvbkIgPSBgYkRhdGFbaW5kZXhCJHt4fV1bY29tcG9uZW50QiR7eH1dYDtcbiAgICAgIHJldHVybiBgXG4gICAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7eH0gPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiA0dSArICR7eH11YCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEEke3h9ID0gJHthLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRJbmRpY2VzJHt4fWAsIG91dHB1dCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEIke3h9ID0gJHtiLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRJbmRpY2VzJHt4fWAsIG91dHB1dCl9O1xuICAgICAgICAgICAgbGV0IGluZGV4QSR7eH0gPSBvZmZzZXRBJHt4fSAvIDR1O1xuICAgICAgICAgICAgbGV0IGluZGV4QiR7eH0gPSBvZmZzZXRCJHt4fSAvIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudEEke3h9ID0gb2Zmc2V0QSR7eH0gJSA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRCJHt4fSA9IG9mZnNldEIke3h9ICUgNHU7XG4gICAgICAgICAgICAke3Jlc1N0cn1bJHt4fV0gPSAke3R5cGVDYXN0fSgke2V4cHJlc3Npb25TY2FsYXIoZXhwcmVzc2lvbkEsIGV4cHJlc3Npb25CKX0pO1xuICAgICAgICAgIGA7XG4gICAgfTtcbiAgICBpZiAodHlwZU91dHB1dCA9PT0gRGF0YVR5cGUuYm9vbCkge1xuICAgICAgYXNzaWdubWVudCA9IGBcbiAgICAgICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMCwgJ3UzMicpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMSwgJ3UzMicpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMiwgJ3UzMicpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMywgJ3UzMicpfVxuICAgICAgICAgICAgb3V0cHV0RGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25tZW50ID0gYFxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXREYXRhW2dsb2JhbF9pZHhdJywgMCl9XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ291dHB1dERhdGFbZ2xvYmFsX2lkeF0nLCAxKX1cbiAgICAgICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnb3V0cHV0RGF0YVtnbG9iYWxfaWR4XScsIDIpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXREYXRhW2dsb2JhbF9pZHhdJywgMyl9XG4gICAgICAgICAgYDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYFxuICAgICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ3ZlY19zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoYSwgYiwgb3V0cHV0KX1cblxuICAgICAgICAke2FkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbiA/PyAnJ31cblxuICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMudmVjX3NpemUnKX1cbiAgICAgICAgJHthc3NpZ25tZW50fVxuICAgICAgfWA7XG59O1xuXG5jb25zdCBjcmVhdGVCaW5hcnlPcFByb2dyYW1JbmZvID0gKFxuICBuYW1lOiBzdHJpbmcsXG4gIGNhY2hlS2V5OiBzdHJpbmcsXG4gIGE6IFRlbnNvclZpZXcsXG4gIGI6IFRlbnNvclZpZXcsXG4gIGZ1bmNDYWxsOiBCaW5hcnlGdW5jdGlvbkNhbGwsXG4gIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbj86IHN0cmluZyxcbiAgb3V0cHV0RGF0YVR5cGU6IG51bWJlciA9IGEuZGF0YVR5cGUsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlzQnJvYWRjYXN0ID0gIVNoYXBlVXRpbC5hcmVFcXVhbChhLmRpbXMsIGIuZGltcyk7XG4gIGxldCBvdXRwdXRTaGFwZSA9IGEuZGltcztcbiAgbGV0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShhLmRpbXMpO1xuXG4gIGxldCB2ZWN0b3JpemUgPSBmYWxzZTtcbiAgbGV0IHNoYXJlZERpbWVuc2lvbkRpdmlzaWJsZUJ5NCA9IGZhbHNlO1xuXG4gIC8vIFRPRE86IGRlYWwgd2l0aCB6ZXJvLXNpemVkIHRlbnNvcnMgKGVnLiBkaW1zPVsxLDBdKVxuICBjb25zdCBjYWNoZUtleUF1eCA9IFtpc0Jyb2FkY2FzdF07XG4gIGlmIChpc0Jyb2FkY2FzdCkge1xuICAgIGNvbnN0IGNhbGN1bGF0ZWRTaGFwZSA9IEJyb2FkY2FzdFV0aWwuY2FsY1NoYXBlKGEuZGltcywgYi5kaW1zLCBmYWxzZSk7XG4gICAgaWYgKCFjYWxjdWxhdGVkU2hhcGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHBlcmZvcm0gYmluYXJ5IG9wIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO1xuICAgIH1cbiAgICBvdXRwdXRTaGFwZSA9IGNhbGN1bGF0ZWRTaGFwZTtcbiAgICBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICAgIGNvbnN0IGlzQU9uZUVsZW1lbnQgPSBTaGFwZVV0aWwuc2l6ZShhLmRpbXMpID09PSAxO1xuICAgIGNvbnN0IGlzQk9uZUVsZW1lbnQgPSBTaGFwZVV0aWwuc2l6ZShiLmRpbXMpID09PSAxO1xuICAgIGNvbnN0IGFMYXN0RGltRGl2aXNpYmxlQnk0ID0gYS5kaW1zLmxlbmd0aCA+IDAgJiYgYS5kaW1zW2EuZGltcy5sZW5ndGggLSAxXSAlIDQgPT09IDA7XG4gICAgY29uc3QgYkxhc3REaW1EaXZpc2libGVCeTQgPSBiLmRpbXMubGVuZ3RoID4gMCAmJiBiLmRpbXNbYi5kaW1zLmxlbmd0aCAtIDFdICUgNCA9PT0gMDtcbiAgICBjYWNoZUtleUF1eC5wdXNoKGlzQU9uZUVsZW1lbnQpO1xuICAgIGNhY2hlS2V5QXV4LnB1c2goaXNCT25lRWxlbWVudCk7XG4gICAgY2FjaGVLZXlBdXgucHVzaChhTGFzdERpbURpdmlzaWJsZUJ5NCk7XG4gICAgY2FjaGVLZXlBdXgucHVzaChiTGFzdERpbURpdmlzaWJsZUJ5NCk7XG4gICAgLy8gY2hlY2sgd2hldGhlciB2ZWN0b3JpemUgY2FuIGJlIGVuYWJsZWRcbiAgICBsZXQgc2hhcmVkRGltZW5zaW9uID0gMTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG91dHB1dFNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkaW1BID0gYS5kaW1zW2EuZGltcy5sZW5ndGggLSBpXSA/PyAxO1xuICAgICAgY29uc3QgZGltQiA9IGIuZGltc1tiLmRpbXMubGVuZ3RoIC0gaV0gPz8gMTtcbiAgICAgIGlmIChkaW1BID09PSBkaW1CKSB7XG4gICAgICAgIHNoYXJlZERpbWVuc2lvbiAqPSBkaW1BO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaGFyZWREaW1lbnNpb24gJSA0ID09PSAwKSB7XG4gICAgICBzaGFyZWREaW1lbnNpb25EaXZpc2libGVCeTQgPSB0cnVlO1xuICAgICAgdmVjdG9yaXplID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzQU9uZUVsZW1lbnQgfHwgaXNCT25lRWxlbWVudCB8fCBhTGFzdERpbURpdmlzaWJsZUJ5NCB8fCBiTGFzdERpbURpdmlzaWJsZUJ5NCkge1xuICAgICAgdmVjdG9yaXplID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZWxlbWVudC13aXNlXG4gICAgdmVjdG9yaXplID0gdHJ1ZTtcbiAgfVxuICBjYWNoZUtleUF1eC5wdXNoKHZlY3Rvcml6ZSk7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICBoaW50OiBjYWNoZUtleSArIGNhY2hlS2V5QXV4Lm1hcCgoeCkgPT4geC50b1N0cmluZygpKS5qb2luKCdfJyksXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJywgJ3JhbmsnXSxcbiAgICB9LFxuICAgIGdldFNoYWRlclNvdXJjZTogKHNoYWRlckhlbHBlcikgPT5cbiAgICAgIGNyZWF0ZUJpbmFyeU9wUHJvZ3JhbVNoYWRlcihcbiAgICAgICAgc2hhZGVySGVscGVyLFxuICAgICAgICBhLmRpbXMsXG4gICAgICAgIGIuZGltcyxcbiAgICAgICAgb3V0cHV0U2hhcGUsXG4gICAgICAgIHZlY3Rvcml6ZSxcbiAgICAgICAgaXNCcm9hZGNhc3QsXG4gICAgICAgIHNoYXJlZERpbWVuc2lvbkRpdmlzaWJsZUJ5NCxcbiAgICAgICAgZnVuY0NhbGwsXG4gICAgICAgIGEuZGF0YVR5cGUsXG4gICAgICAgIGIuZGF0YVR5cGUsXG4gICAgICAgIG91dHB1dERhdGFUeXBlLFxuICAgICAgICBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb24sXG4gICAgICApLFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IG91dHB1dERhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovIC8gNCAvKiBjb21wb25lbnQgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtczogW1xuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIDQpIH0sXG4gICAgICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGEuZGltcywgYi5kaW1zLCBvdXRwdXRTaGFwZSksXG4gICAgICBdLFxuICAgIH0pLFxuICB9O1xufTtcblxuY29uc3QgcnVuQmluYXJ5T3AgPSAoXG4gIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bmNDYWxsOiBCaW5hcnlGdW5jdGlvbkNhbGwsXG4gIGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbj86IHN0cmluZyxcbiAgY2FjaGVLZXk/OiBzdHJpbmcsXG4gIG91dHB1dERhdGFUeXBlPzogbnVtYmVyLFxuKTogdm9pZCA9PiB7XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVCaW5hcnlPcFByb2dyYW1JbmZvKFxuICAgICAgbmFtZSxcbiAgICAgIGNhY2hlS2V5ID8/ICcnLFxuICAgICAgY29udGV4dC5pbnB1dHNbMF0sXG4gICAgICBjb250ZXh0LmlucHV0c1sxXSxcbiAgICAgIGZ1bmNDYWxsLFxuICAgICAgYWRkaXRpb25hbEltcGxlbWVudGF0aW9uLFxuICAgICAgb3V0cHV0RGF0YVR5cGUsXG4gICAgKSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBhZGQgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoY29udGV4dCwgJ0FkZCcsIChhLCBiKSA9PiBgJHthfSske2J9YCk7XG59O1xuXG5leHBvcnQgY29uc3QgZGl2ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIHJ1bkJpbmFyeU9wKGNvbnRleHQsICdEaXYnLCAoYSwgYikgPT4gYCR7YX0vJHtifWApO1xufTtcblxuZXhwb3J0IGNvbnN0IGVxdWFsID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIHJ1bkJpbmFyeU9wKFxuICAgIGNvbnRleHQsXG4gICAgJ0VxdWFsJyxcbiAgICB7IHNjYWxhcjogKGEsIGIpID0+IGB1MzIoJHthfT09JHtifSlgLCB2ZWN0b3I6IChhLCBiKSA9PiBgdmVjNDx1MzI+KCR7YX09PSR7Yn0pYCB9LFxuICAgIHVuZGVmaW5lZCxcbiAgICB1bmRlZmluZWQsXG4gICAgRGF0YVR5cGUuYm9vbCxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBtdWwgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoY29udGV4dCwgJ011bCcsIChhLCBiKSA9PiBgJHthfSoke2J9YCk7XG59O1xuXG5leHBvcnQgY29uc3QgcG93ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGNvbnN0IHR5cGUgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlLCBjb250ZXh0LmlucHV0c1swXS5kaW1zKS50eXBlLnZhbHVlO1xuICBjb25zdCByb3VuZFN0ciA9IHR5cGUgPT09ICdpMzInID8gJ3JvdW5kJyA6ICcnO1xuICBydW5CaW5hcnlPcChcbiAgICBjb250ZXh0LFxuICAgICdQb3cnLFxuICAgIHsgc2NhbGFyOiAoYSwgYikgPT4gYHBvd19jdXN0b20oJHthfSwke2J9KWAsIHZlY3RvcjogKGEsIGIpID0+IGBwb3dfdmVjdG9yX2N1c3RvbSgke2F9LCR7Yn0pYCB9LFxuICAgIGBcbiAgICBmbiBwb3dfY3VzdG9tKGEgOiAke3R5cGV9LCBiIDogJHt0eXBlfSkgLT4gJHt0eXBlfSB7XG4gICAgICBpZiAoYiA9PSAke3R5cGV9KDAuMCkpIHtcbiAgICAgICAgcmV0dXJuICR7dHlwZX0oMS4wKTtcbiAgICAgIH0gZWxzZSBpZiAoYSA8ICR7dHlwZX0oMC4wKSAmJiBmMzIoYikgIT0gZmxvb3IoZjMyKGIpKSkge1xuICAgICAgICByZXR1cm4gJHt0eXBlfShwb3coZjMyKGEpLCBmMzIoYikpKTsgLy8gTmFOXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0KHNpZ24oYSksICR7dHlwZX0oMS4wKSwgcm91bmQoZjMyKGFicyhiKSAlICR7dHlwZX0oMi4wKSkpICE9IDEuMCkgKiAke3R5cGV9KCR7XG4gICAgICAgIHJvdW5kU3RyXG4gICAgICB9KHBvdyhmMzIoYWJzKGEpKSwgZjMyKGIpKSkpO1xuICAgIH1cbiAgICBmbiBwb3dfdmVjdG9yX2N1c3RvbShhIDogdmVjNDwke3R5cGV9PiwgYiA6IHZlYzQ8JHt0eXBlfT4pIC0+IHZlYzQ8JHt0eXBlfT4ge1xuICAgICAgLy8gVE9ETzogaW1wbGVtZW50IHZlY3Rvcml6ZWQgcG93XG4gICAgICByZXR1cm4gdmVjNDwke3R5cGV9Pihwb3dfY3VzdG9tKGEueCwgYi54KSwgcG93X2N1c3RvbShhLnksIGIueSksIHBvd19jdXN0b20oYS56LCBiLnopLCBwb3dfY3VzdG9tKGEudywgYi53KSk7XG4gICAgfVxuICAgICAgYCxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzdWIgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoY29udGV4dCwgJ1N1YicsIChhLCBiKSA9PiBgJHthfS0ke2J9YCk7XG59O1xuXG5leHBvcnQgY29uc3QgZ3JlYXRlciA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBydW5CaW5hcnlPcChcbiAgICBjb250ZXh0LFxuICAgICdHcmVhdGVyJyxcbiAgICB7IHNjYWxhcjogKGEsIGIpID0+IGB1MzIoJHthfT4ke2J9KWAsIHZlY3RvcjogKGEsIGIpID0+IGB2ZWM0PHUzMj4oJHthfT4ke2J9KWAgfSxcbiAgICB1bmRlZmluZWQsXG4gICAgdW5kZWZpbmVkLFxuICAgIERhdGFUeXBlLmJvb2wsXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgbGVzcyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBydW5CaW5hcnlPcChcbiAgICBjb250ZXh0LFxuICAgICdMZXNzJyxcbiAgICB7IHNjYWxhcjogKGEsIGIpID0+IGB1MzIoJHthfTwke2J9KWAsIHZlY3RvcjogKGEsIGIpID0+IGB2ZWM0PHUzMj4oJHthfTwke2J9KWAgfSxcbiAgICB1bmRlZmluZWQsXG4gICAgdW5kZWZpbmVkLFxuICAgIERhdGFUeXBlLmJvb2wsXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgZ3JlYXRlck9yRXF1YWwgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgcnVuQmluYXJ5T3AoXG4gICAgY29udGV4dCxcbiAgICAnR3JlYXRlck9yRXF1YWwnLFxuICAgIHsgc2NhbGFyOiAoYSwgYikgPT4gYHUzMigke2F9Pj0ke2J9KWAsIHZlY3RvcjogKGEsIGIpID0+IGB2ZWM0PHUzMj4oJHthfT49JHtifSlgIH0sXG4gICAgdW5kZWZpbmVkLFxuICAgIHVuZGVmaW5lZCxcbiAgICBEYXRhVHlwZS5ib29sLFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGxlc3NPckVxdWFsID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIHJ1bkJpbmFyeU9wKFxuICAgIGNvbnRleHQsXG4gICAgJ0xlc3NPckVxdWFsJyxcbiAgICB7IHNjYWxhcjogKGEsIGIpID0+IGB1MzIoJHthfTw9JHtifSlgLCB2ZWN0b3I6IChhLCBiKSA9PiBgdmVjNDx1MzI+KCR7YX08PSR7Yn0pYCB9LFxuICAgIHVuZGVmaW5lZCxcbiAgICB1bmRlZmluZWQsXG4gICAgRGF0YVR5cGUuYm9vbCxcbiAgKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBJbmRpY2VzSGVscGVyLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbmNhdEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBheGlzOiBudW1iZXI7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBheGlzOiBudW1iZXIpOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvbyBmZXcgaW5wdXRzJyk7XG4gIH1cbiAgY29uc3QgcmVmZXJlbmNlSW5kZXggPSAwO1xuICBjb25zdCByZWZlcmVuY2VJbnB1dCA9IGlucHV0c1tyZWZlcmVuY2VJbmRleF07XG4gIGNvbnN0IGlucHV0VHlwZSA9IHJlZmVyZW5jZUlucHV0LmRhdGFUeXBlO1xuICBjb25zdCBpbnB1dFJhbmsgPSByZWZlcmVuY2VJbnB1dC5kaW1zLmxlbmd0aDtcbiAgaW5wdXRzLmZvckVhY2goKGlucHV0LCBpKSA9PiB7XG4gICAgaWYgKGkgPT09IHJlZmVyZW5jZUluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSB0eXBlcyBvZiBhbGwgaW5wdXRzIG1hdGNoXG4gICAgaWYgKGlucHV0LmRhdGFUeXBlICE9PSBpbnB1dFR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgdGVuc29ycyBzaG91bGQgYmUgb25lIHR5cGUnKTtcbiAgICB9XG4gICAgLy8gbWFrZSBzdXJlIHRoZSBkaW1lbnNpb25hbGl0eSBvZiBhbGwgaW5wdXRzIGFyZSB0aGUgc2FtZVxuICAgIGlmIChpbnB1dC5kaW1zLmxlbmd0aCAhPT0gaW5wdXRSYW5rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IHRlbnNvcnMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgc2hhcGUnKTtcbiAgICB9XG4gICAgaW5wdXQuZGltcy5mb3JFYWNoKChkaW0sIGkpID0+IHtcbiAgICAgIGlmIChpICE9PSBheGlzICYmIGRpbSAhPT0gcmVmZXJlbmNlSW5wdXQuZGltc1tpXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vbiBjb25jYXQgZGltZW5zaW9ucyBtdXN0IG1hdGNoJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuY29uc3QgY2FsY3VsYXRlSW5wdXRJbmRleEltcGwgPSAobnVtYmVyT2ZUZW5zb3JzOiBudW1iZXIsIHNpemVJbkNvbmNhdEF4aXNTdHI6IHN0cmluZyk6IHN0cmluZyA9PiBgXG4gIGZuIGNhbGN1bGF0ZUlucHV0SW5kZXgoaW5kZXg6IHUzMikgLT4gdTMyIHtcbiAgICBsZXQgc2l6ZUluQ29uY2F0QXhpcyA9IGFycmF5PHUzMiwgJHtudW1iZXJPZlRlbnNvcnN9dT4oJHtzaXplSW5Db25jYXRBeGlzU3RyfSk7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke251bWJlck9mVGVuc29yc307IGkgKz0gMXUgKSB7XG4gICAgICBpZiAoaW5kZXggPCBzaXplSW5Db25jYXRBeGlzW2ldKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJHtudW1iZXJPZlRlbnNvcnN9dTtcbiAgfWA7XG5cbmNvbnN0IGFzc2lnbk91dHB1dERhdGEgPSAoaW5wdXRzOiByZWFkb25seSBJbmRpY2VzSGVscGVyW10sIG91dHB1dDogSW5kaWNlc0hlbHBlcikgPT4ge1xuICBjb25zdCBudW1iZXJPZlRlbnNvcnMgPSBpbnB1dHMubGVuZ3RoO1xuXG4gIGNvbnN0IGNvZGVMaW5lczogc3RyaW5nW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlRlbnNvcnM7ICsraSkge1xuICAgIGNvbnN0IHJldHVyblNuaXBwZXQgPSBvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCBpbnB1dHNbaV0uZ2V0QnlJbmRpY2VzKCdpbmRpY2VzJykpO1xuICAgIGlmIChudW1iZXJPZlRlbnNvcnMgPT09IDEpIHtcbiAgICAgIGNvZGVMaW5lcy5wdXNoKHJldHVyblNuaXBwZXQpO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgY29kZUxpbmVzLnB1c2goYGlmIChpbnB1dEluZGV4ID09ICR7aX11KSB7ICR7cmV0dXJuU25pcHBldH0gfWApO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gbnVtYmVyT2ZUZW5zb3JzIC0gMSkge1xuICAgICAgY29kZUxpbmVzLnB1c2goYGVsc2UgeyAke3JldHVyblNuaXBwZXR9IH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZUxpbmVzLnB1c2goYGVsc2UgaWYgKGlucHV0SW5kZXggPT0gJHtpfSkgeyAke3JldHVyblNuaXBwZXR9IH1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvZGVMaW5lcy5qb2luKCdcXG4nKTtcbn07XG5cbmNvbnN0IGNyZWF0ZUNvbmNhdFByb2dyYW1JbmZvID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYWRqdXN0ZWRBeGlzOiBudW1iZXIsXG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXSxcbiAgZGF0YVR5cGU6IERhdGFUeXBlLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuXG4gIGNvbnN0IHNpemVJbkNvbmNhdEF4aXMgPSBuZXcgQXJyYXk8bnVtYmVyPihpbnB1dHMubGVuZ3RoKTtcbiAgY29uc3QgaW5wdXRWYXJzID0gbmV3IEFycmF5PEluZGljZXNIZWxwZXI+KGlucHV0cy5sZW5ndGgpO1xuXG4gIGxldCBwcmV2aW91c1N1bSA9IDA7XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gW107XG4gIGNvbnN0IGlucHV0UmFua3MgPSBbXTtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW3sgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH1dO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7ICsraSkge1xuICAgIHByZXZpb3VzU3VtICs9IGlucHV0c1tpXS5kaW1zW2FkanVzdGVkQXhpc107XG4gICAgc2l6ZUluQ29uY2F0QXhpc1tpXSA9IHByZXZpb3VzU3VtO1xuICAgIGlucHV0UmFua3MucHVzaChpbnB1dHNbaV0uZGltcy5sZW5ndGgpO1xuICAgIGlucHV0VmFyc1tpXSA9IGlucHV0VmFyaWFibGUoYGlucHV0JHtpfWAsIGRhdGFUeXBlLCBpbnB1dFJhbmtzW2ldKTtcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCdyYW5rJyk7XG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHNpemVJbkNvbmNhdEF4aXNbaV0gfSk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbaV0uZGltcykpO1xuICB9XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSk7XG5cbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICBjb25zdCBpbmRpY2VzQXhpcyA9IG91dHB1dC5pbmRpY2VzR2V0KCdpbmRpY2VzJywgYWRqdXN0ZWRBeGlzKTtcbiAgY29uc3Qgc2l6ZUluQ29uY2F0QXhpc1N0ciA9IEFycmF5LmZyb20oQXJyYXkoc2l6ZUluQ29uY2F0QXhpcy5sZW5ndGgpLmtleXMoKSlcbiAgICAubWFwKChpKSA9PiBgdW5pZm9ybXMuc2l6ZUluQ29uY2F0QXhpcyR7aX1gKVxuICAgIC5qb2luKCcsJyk7XG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuXG4gICR7KCgpID0+IHtcbiAgICBzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRTaXplJywgJ3UzMicpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKGBzaXplSW5Db25jYXRBeGlzJHtpfWAsICd1MzInKTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWRlckhlbHBlci5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFycywgb3V0cHV0KTtcbiAgfSkoKX1cblxuICAke2NhbGN1bGF0ZUlucHV0SW5kZXhJbXBsKHNpemVJbkNvbmNhdEF4aXMubGVuZ3RoLCBzaXplSW5Db25jYXRBeGlzU3RyKX1cblxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRTaXplJyl9XG5cbiAgICB2YXIgaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcblxuICAgIGxldCBpbnB1dEluZGV4ID0gY2FsY3VsYXRlSW5wdXRJbmRleCgke2luZGljZXNBeGlzfSk7XG4gICAgaWYgKGlucHV0SW5kZXggIT0gMHUpIHtcbiAgICAgIGxldCBzaXplSW5Db25jYXRBeGlzID0gYXJyYXk8dTMyLCAke3NpemVJbkNvbmNhdEF4aXMubGVuZ3RofXU+KCR7c2l6ZUluQ29uY2F0QXhpc1N0cn0pO1xuICAgICAgJHtpbmRpY2VzQXhpc30gLT0gc2l6ZUluQ29uY2F0QXhpc1tpbnB1dEluZGV4IC0gMXVdO1xuICAgIH1cblxuICAgICR7YXNzaWduT3V0cHV0RGF0YShpbnB1dFZhcnMsIG91dHB1dCl9XG4gIH1gO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0NvbmNhdCcsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7YWRqdXN0ZWRBeGlzfWAsIGlucHV0RGVwZW5kZW5jaWVzIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgY29uY2F0ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBDb25jYXRBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGlucHV0cyA9IGNvbnRleHQuaW5wdXRzO1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGFkanVzdGVkQXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMuYXhpcywgaW5wdXRTaGFwZS5sZW5ndGgpO1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIGFkanVzdGVkQXhpcyk7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgpO1xuICBvdXRwdXRTaGFwZVthZGp1c3RlZEF4aXNdID0gaW5wdXRzLnJlZHVjZShcbiAgICAoc3VtLCBpbnB1dCkgPT4gc3VtICsgKGlucHV0LmRpbXMubGVuZ3RoID4gYWRqdXN0ZWRBeGlzID8gaW5wdXQuZGltc1thZGp1c3RlZEF4aXNdIDogMCksXG4gICAgMCxcbiAgKTtcbiAgLy8gMCBsZW5ndGggdGVuc29ycyBhcmUgdmFsaWQgZm9yIGNvbmNhdCwgcmVtb3ZlIHRoZW1cbiAgY29uc3Qgbm9uRW1wdHlJbnB1dHMgPSBpbnB1dHMuZmlsdGVyKChpbnB1dCkgPT4gU2hhcGVVdGlsLnNpemUoaW5wdXQuZGltcykgPiAwKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUNvbmNhdFByb2dyYW1JbmZvKG5vbkVtcHR5SW5wdXRzLCBhZGp1c3RlZEF4aXMsIG91dHB1dFNoYXBlLCBpbnB1dHNbMF0uZGF0YVR5cGUpLCB7XG4gICAgaW5wdXRzOiBub25FbXB0eUlucHV0cyxcbiAgfSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VDb25jYXRBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQ29uY2F0QXR0cmlidXRlcyA9PlxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBheGlzOiBhdHRyaWJ1dGVzLmF4aXMgYXMgbnVtYmVyIH0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IE1BWF9DTElQLCBNSU5fQ0xJUCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IFVuaWZvcm1zQXJyYXlUeXBlIH0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMge1xuICByZWFkb25seSBhY3RpdmF0aW9uOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGNsaXBNaW4/OiBudW1iZXI7XG4gIHJlYWRvbmx5IGNsaXBNYXg/OiBudW1iZXI7XG4gIHJlYWRvbmx5IGFscGhhPzogbnVtYmVyO1xuICByZWFkb25seSBiZXRhPzogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgZ2V0QWN0aXZhdGlvblNuaXBwZXQgPSAoXG4gIGF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsXG4gIHZhbHVlVHlwZTogc3RyaW5nLFxuICBiYXNlVHlwZSA9ICdmMzInLFxuKTogc3RyaW5nID0+IHtcbiAgc3dpdGNoIChhdHRyaWJ1dGVzLmFjdGl2YXRpb24pIHtcbiAgICBjYXNlICdSZWx1JzpcbiAgICAgIHJldHVybiBgdmFsdWUgPSBtYXgodmFsdWUsICR7dmFsdWVUeXBlfSgwLjApKTtgO1xuICAgIGNhc2UgJ1NpZ21vaWQnOlxuICAgICAgcmV0dXJuIGB2YWx1ZSA9ICgke3ZhbHVlVHlwZX0oMS4wKSAvICgke3ZhbHVlVHlwZX0oMS4wKSArIGV4cCgtdmFsdWUpKSk7YDtcbiAgICBjYXNlICdDbGlwJzpcbiAgICAgIHJldHVybiBgdmFsdWUgPSBjbGFtcCh2YWx1ZSwgJHt2YWx1ZVR5cGV9KCR7YmFzZVR5cGV9KHVuaWZvcm1zLmNsaXBfbWluKSksICR7dmFsdWVUeXBlfSgke1xuICAgICAgICBiYXNlVHlwZVxuICAgICAgfSh1bmlmb3Jtcy5jbGlwX21heCkpKTtgO1xuICAgIGNhc2UgJ0hhcmRTaWdtb2lkJzpcbiAgICAgIHJldHVybiBgdmFsdWUgPSBtYXgoJHt2YWx1ZVR5cGV9KDAuMCksIG1pbigke3ZhbHVlVHlwZX0oMS4wKSwgJHtiYXNlVHlwZX0odW5pZm9ybXMuYWxwaGEpICogdmFsdWUgKyAke1xuICAgICAgICBiYXNlVHlwZVxuICAgICAgfSh1bmlmb3Jtcy5iZXRhKSkpO2A7XG4gICAgY2FzZSAnTGVha3lSZWx1JzpcbiAgICAgIHJldHVybiBgdmFsdWUgPSBzZWxlY3QoJHtiYXNlVHlwZX0odW5pZm9ybXMuYWxwaGEpICogdmFsdWUsIHZhbHVlLCB2YWx1ZSA+PSAke3ZhbHVlVHlwZX0oMC4wKSk7YDtcbiAgICBjYXNlICdUYW5oJzpcbiAgICAgIHJldHVybiBgbGV0IGUyeCA9IGV4cCgtMi4wICogYWJzKHZhbHVlKSk7XG4gICAgICAgICAgICAgIHZhbHVlID0gc2lnbih2YWx1ZSkgKiAoMS4wIC0gZTJ4KSAvICgxLjAgKyBlMngpO1xuICAgICAgICBgO1xuICAgIGNhc2UgJyc6XG4gICAgICByZXR1cm4gJyc7XG4gICAgLy8gVE9ETzogYWRkaW5nIG90aGVyIGFjdGl2YXRpb25zIHRoYXQgY2FuIGJlIGZ1c2VkLlxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGFjdGl2YXRpb24gJHthdHRyaWJ1dGVzLmFjdGl2YXRpb259YCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhID0gKFxuICBhdHRyaWJ1dGVzOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLFxuICBwcm9ncmFtVW5pZm9ybTogUHJvZ3JhbVVuaWZvcm1bXSxcbikgPT4ge1xuICBpZiAoYXR0cmlidXRlcy5hY3RpdmF0aW9uID09PSAnQ2xpcCcpIHtcbiAgICBwcm9ncmFtVW5pZm9ybS5wdXNoKFxuICAgICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5jbGlwTWF4ISB9LFxuICAgICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5jbGlwTWluISB9LFxuICAgICk7XG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlcy5hY3RpdmF0aW9uID09PSAnSGFyZFNpZ21vaWQnKSB7XG4gICAgcHJvZ3JhbVVuaWZvcm0ucHVzaChcbiAgICAgIHsgdHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IGF0dHJpYnV0ZXMuYWxwaGEhIH0sXG4gICAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBhdHRyaWJ1dGVzLmJldGEhIH0sXG4gICAgKTtcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLmFjdGl2YXRpb24gPT09ICdMZWFreVJlbHUnKSB7XG4gICAgcHJvZ3JhbVVuaWZvcm0ucHVzaCh7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBhdHRyaWJ1dGVzLmFscGhhISB9KTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyA9IChhdHRyaWJ1dGVzOiBJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzLCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUpID0+IHtcbiAgaWYgKGF0dHJpYnV0ZXMuYWN0aXZhdGlvbiA9PT0gJ0NsaXAnKSB7XG4gICAgdW5pZm9ybXMucHVzaCh7IG5hbWU6ICdjbGlwX21heCcsIHR5cGU6ICdmMzInIH0sIHsgbmFtZTogJ2NsaXBfbWluJywgdHlwZTogJ2YzMicgfSk7XG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlcy5hY3RpdmF0aW9uID09PSAnSGFyZFNpZ21vaWQnKSB7XG4gICAgdW5pZm9ybXMucHVzaCh7IG5hbWU6ICdhbHBoYScsIHR5cGU6ICdmMzInIH0sIHsgbmFtZTogJ2JldGEnLCB0eXBlOiAnZjMyJyB9KTtcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLmFjdGl2YXRpb24gPT09ICdMZWFreVJlbHUnKSB7XG4gICAgdW5pZm9ybXMucHVzaCh7IG5hbWU6ICdhbHBoYScsIHR5cGU6ICdmMzInIH0pO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VJbnRlcm5hbEFjdGl2YXRpb25BdHRyaWJ1dGVzID0gKFxuICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8IHVuZGVmaW5lZCxcbik6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBhY3RpdmF0aW9uID0gKGF0dHJpYnV0ZXM/LmFjdGl2YXRpb24gYXMgc3RyaW5nKSB8fCAnJztcbiAgaWYgKGFjdGl2YXRpb24gPT09ICdIYXJkU2lnbW9pZCcpIHtcbiAgICBjb25zdCBbYWxwaGEsIGJldGFdID0gKGF0dHJpYnV0ZXM/LmFjdGl2YXRpb25fcGFyYW1zIGFzIFtudW1iZXIsIG51bWJlcl0pIHx8IFswLjIsIDAuNV07XG4gICAgcmV0dXJuIHsgYWN0aXZhdGlvbiwgYWxwaGEsIGJldGEgfTtcbiAgfSBlbHNlIGlmIChhY3RpdmF0aW9uID09PSAnQ2xpcCcpIHtcbiAgICBjb25zdCBbY2xpcE1pbiwgY2xpcE1heF0gPSAoYXR0cmlidXRlcz8uYWN0aXZhdGlvbl9wYXJhbXMgYXMgW251bWJlciwgbnVtYmVyXSkgfHwgW01JTl9DTElQLCBNQVhfQ0xJUF07XG4gICAgcmV0dXJuIHsgYWN0aXZhdGlvbiwgY2xpcE1heCwgY2xpcE1pbiB9O1xuICB9IGVsc2UgaWYgKGFjdGl2YXRpb24gPT09ICdMZWFreVJlbHUnKSB7XG4gICAgY29uc3QgW2FscGhhXSA9IChhdHRyaWJ1dGVzPy5hY3RpdmF0aW9uX3BhcmFtcyBhcyBbbnVtYmVyXSkgfHwgWzAuMDFdO1xuICAgIHJldHVybiB7IGFjdGl2YXRpb24sIGFscGhhIH07XG4gIH1cbiAgcmV0dXJuIHsgYWN0aXZhdGlvbiB9O1xufTtcbiIsICIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1iYWNrZW5kLXdlYmdwdS9zcmMvYWN0aXZhdGlvbl91dGlsLnRzXG4vL1xuLy8gbW9kaWZpZWQgdG8gZml0IHRoZSBuZWVkcyBvZiB0aGUgcHJvamVjdFxuXG5leHBvcnQgY29uc3QgdHlwZVNuaXBwZXQgPSAoY29tcG9uZW50OiBudW1iZXIsIGRhdGFUeXBlOiBzdHJpbmcpID0+IHtcbiAgc3dpdGNoIChjb21wb25lbnQpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZGF0YVR5cGU7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIGB2ZWMyPCR7ZGF0YVR5cGV9PmA7XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIGB2ZWMzPCR7ZGF0YVR5cGV9PmA7XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIGB2ZWM0PCR7ZGF0YVR5cGV9PmA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb21wb25lbnR9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgYmlhc1NuaXBwZXQgPSAoaGFzQmlhczogYm9vbGVhbik6IHN0cmluZyA9PiBgXG4gICAgICAke2hhc0JpYXMgPyAndmFsdWUgPSB2YWx1ZSArIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMpOycgOiAnJ31cbiAgICAgIGA7XG4iLCAiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vLyBzYW1wbGVkIGZyb20gW0B0ZW5zb3JmbG93L3RmanNdIHRmanMtY29yZS9zcmMvb3BzL2NvbnZfdXRpbC50c1xuLy9cbi8vIG1vZGlmaWVkIHRvIGZpdCB0aGUgbmVlZHMgb2YgdGhlIHByb2plY3RcblxuZXhwb3J0IGNvbnN0IHV0aWxGdW5jdGlvbnMgPSAoc3RyaWRlU3RyOiBzdHJpbmcpID0+IGBcbmZuIGdldEluZGV4RnJvbUNvb3JkczREKGNvb3JkcyA6IHZlYzQ8aTMyPiwgc2hhcGUgOiB2ZWM0PGkzMj4pIC0+IGkzMiB7XG4gIHJldHVybiBkb3QoY29vcmRzLCB2ZWM0PGkzMj4oXG4gICAgICBzaGFwZS55ICogc2hhcGUueiAqIHNoYXBlLncsIHNoYXBlLnogKiBzaGFwZS53LCBzaGFwZS53LCAxKSk7XG59XG5mbiBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiBpMzIge1xuICByZXR1cm4gZG90KGNvb3JkcywgdmVjNDxpMzI+KFxuICAgIGkzMigke3N0cmlkZVN0cn0ueCksIGkzMigke3N0cmlkZVN0cn0ueSksIGkzMigke3N0cmlkZVN0cn0ueiksIDEpKTtcbn1cbmA7XG4iLCAiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vLyBzYW1wbGVkIGZyb20gW0B0ZW5zb3JmbG93L3RmanNdIHRmanMtYmFja2VuZC13ZWJncHUvc3JjL21hdG11bF9wYWNrZWRfd2ViZ3B1LnRzXG4vL1xuLy8gbW9kaWZpZWQgdG8gZml0IHRoZSBuZWVkcyBvZiB0aGUgcHJvamVjdFxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQge1xuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcbiAgZ2V0QnJvYWRjYXN0RGltcyxcbiAgSW5kaWNlc0hlbHBlcixcbiAgaW5wdXRWYXJpYWJsZSxcbiAgaW50ZXJuYWxWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7XG4gIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyxcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YSxcbiAgZ2V0QWN0aXZhdGlvblNuaXBwZXQsXG4gIEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsXG59IGZyb20gJy4uL2Z1c2UtdXRpbHMnO1xuXG5pbXBvcnQgeyB0eXBlU25pcHBldCB9IGZyb20gJy4vYWN0aXZhdGlvbl91dGlsJztcblxuY29uc3Qgd3JpdGVEYXRhVG9TdWJBVmVjNFNuaXBwZXQgPSAodHJhbnNwb3NlOiBib29sZWFuLCBiYXRjaERpbXM/OiBJbmRpY2VzSGVscGVyKSA9PiB7XG4gIGlmICh0cmFuc3Bvc2UpIHtcbiAgICByZXR1cm4gYFxuICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgICBnbG9iYWxSb3dTdGFydCAvIGlubmVyRWxlbWVudFNpemUgKyBpbnB1dENvbCR7YmF0Y2hEaW1zID8gJywgYmF0Y2hJbmRpY2VzJyA6ICcnfSk7XG4gICAgICAgIGA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGBcbiAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAgZ2xvYmFsUm93ICsgaW5uZXJSb3csXG4gICAgICAgICAga1N0YXJ0IC8gaW5uZXJFbGVtZW50U2l6ZSArIGlucHV0Q29sJHtiYXRjaERpbXMgPyAnLCBiYXRjaEluZGljZXMnIDogJyd9KTtcbiAgICAgICAgYDtcbiAgfVxufTtcblxuY29uc3QgY2FsY3VsYXRlUmVzdWx0U25pcHBldCA9ICh0cmFuc3Bvc2VBOiBib29sZWFuLCBpbm5lckVsZW1lbnRTaXplOiBudW1iZXIpID0+IHtcbiAgaWYgKHRyYW5zcG9zZUEpIHtcbiAgICByZXR1cm4gYFxuICAgICAgICBsZXQgQUNhY2hlZDAgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplXVtsb2NhbFJvd107XG4gICAgICAgIGxldCBBQ2FjaGVkMSA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAxXVtsb2NhbFJvd107XG4gICAgICAgIGxldCBBQ2FjaGVkMiA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAyXVtsb2NhbFJvd107XG4gICAgICAgICR7aW5uZXJFbGVtZW50U2l6ZSA9PT0gMyA/ICcnIDogJ2xldCBBQ2FjaGVkMyA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAzXVtsb2NhbFJvd107J31cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dQZXJUaHJlYWQ7IGkgPSBpICsgMSkge1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQwICogQUNhY2hlZDBbaV0gKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDEgKiBBQ2FjaGVkMVtpXSArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMiAqIEFDYWNoZWQyW2ldICsgYWNjW2ldO1xuICAgICAgICAgICR7aW5uZXJFbGVtZW50U2l6ZSA9PT0gMyA/ICcnIDogJ2FjY1tpXSA9IEJDYWNoZWQzICogQUNhY2hlZDNbaV0gKyBhY2NbaV07J31cbiAgICAgICAgfWA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dQZXJUaHJlYWQ7IGkgPSBpICsgMSkge1xuICAgICAgICAgIGxldCBBQ2FjaGVkID0gbW1fQXN1Ylt0aWxlUm93ICsgaV1ba107XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDAgKiBBQ2FjaGVkLnggKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDEgKiBBQ2FjaGVkLnkgKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDIgKiBBQ2FjaGVkLnogKyBhY2NbaV07XG4gICAgICAgICAgJHtpbm5lckVsZW1lbnRTaXplID09PSAzID8gJycgOiAnYWNjW2ldID0gQkNhY2hlZDMgKiBBQ2FjaGVkLncgKyBhY2NbaV07J31cbiAgICAgICAgfWA7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBtYWtlTWF0TXVsUGFja2VkVmVjNFNvdXJjZSA9IChcbiAgd29ya1BlclRocmVhZDogbnVtYmVyW10sXG4gIHdvcmtncm91cFNpemU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgdHlwZSA9ICdmMzInLFxuICBiYXRjaERpbXM/OiBJbmRpY2VzSGVscGVyLFxuICB0cmFuc3Bvc2VBID0gZmFsc2UsXG4gIHRpbGVJbm5lciA9IDMyLFxuICBzcGxpdEsgPSBmYWxzZSxcbiAgc3BsaXRlZERpbUlubmVyID0gMzIsXG4pOiBzdHJpbmcgPT4ge1xuICBjb25zdCB0aWxlQU91dGVyID0gd29ya2dyb3VwU2l6ZVsxXSAqIHdvcmtQZXJUaHJlYWRbMV07XG4gIGNvbnN0IHRpbGVCT3V0ZXIgPSB3b3JrZ3JvdXBTaXplWzBdICogd29ya1BlclRocmVhZFswXTtcbiAgY29uc3QgdGlsZUFXaWR0aCA9IHRyYW5zcG9zZUEgPyB0aWxlQU91dGVyIDogdGlsZUlubmVyO1xuICBjb25zdCB0aWxlQUhpZ2h0ID0gdHJhbnNwb3NlQSA/IHRpbGVJbm5lciA6IHRpbGVBT3V0ZXI7XG4gIGNvbnN0IGlubmVyRWxlbWVudFNpemUgPSB0aWxlQVdpZHRoIC8gd29ya2dyb3VwU2l6ZVswXTtcbiAgY29uc3Qgcm93UGVyVGhyZWFkQiA9IHRpbGVJbm5lciAvIHdvcmtncm91cFNpemVbMV07XG5cbiAgaWYgKFxuICAgICEoXG4gICAgICAoKHRyYW5zcG9zZUEgJiYgaW5uZXJFbGVtZW50U2l6ZSA9PT0gNCAmJiB3b3JrUGVyVGhyZWFkWzFdID09PSA0KSB8fFxuICAgICAgICAoIXRyYW5zcG9zZUEgJiYgKGlubmVyRWxlbWVudFNpemUgPT09IDMgfHwgaW5uZXJFbGVtZW50U2l6ZSA9PT0gNCkpKSAmJlxuICAgICAgdGlsZUFXaWR0aCAlIHdvcmtncm91cFNpemVbMF0gPT09IDAgJiZcbiAgICAgIHRpbGVJbm5lciAlIHdvcmtncm91cFNpemVbMV0gPT09IDAgJiZcbiAgICAgIHdvcmtQZXJUaHJlYWRbMF0gPT09IDRcbiAgICApXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSWYgdHJhbnNwb3NlQSAke3RyYW5zcG9zZUF9IGlzIHRydWUsIGlubmVyRWxlbWVudFNpemUgJHtpbm5lckVsZW1lbnRTaXplfSBhbmQgd29ya1BlclRocmVhZFsxXSAke3dvcmtQZXJUaHJlYWRbMV19IG11c3QgYmUgNC5cbiAgICAgIE90aGVyd2lzZSwgaW5uZXJFbGVtZW50U2l6ZSAke2lubmVyRWxlbWVudFNpemV9IG11c3QgYmUgMyBvciA0LlxuICB0aWxlQVdpZHRoICR7dGlsZUFXaWR0aH0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVswXSR7d29ya2dyb3VwU2l6ZVswXX0uIHRpbGVJbm5lciAke3RpbGVJbm5lcn0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSAke3dvcmtncm91cFNpemVbMV19LiBjb2xQZXJUaHJlYWQgJHt3b3JrUGVyVGhyZWFkWzBdfSBtdXN0IGJlIDQuYCk7XG4gIH1cbiAgcmV0dXJuIGBcbnZhcjx3b3JrZ3JvdXA+IG1tX0FzdWI6IGFycmF5PGFycmF5PHZlYyR7aW5uZXJFbGVtZW50U2l6ZX08JHt0eXBlfT4sICR7dGlsZUFXaWR0aCAvIGlubmVyRWxlbWVudFNpemV9PiwgJHt0aWxlQUhpZ2h0fT47XG52YXI8d29ya2dyb3VwPiBtbV9Cc3ViOiBhcnJheTxhcnJheTx2ZWM0PCR7dHlwZX0+LCAke3RpbGVCT3V0ZXIgLyB3b3JrUGVyVGhyZWFkWzBdfT4sICR7dGlsZUlubmVyfT47XG5cbmNvbnN0IHJvd1BlclRocmVhZCA9ICR7d29ya1BlclRocmVhZFsxXX07XG5jb25zdCBjb2xQZXJUaHJlYWQgPSAke3dvcmtQZXJUaHJlYWRbMF19O1xuY29uc3QgaW5uZXJFbGVtZW50U2l6ZSA9ICR7aW5uZXJFbGVtZW50U2l6ZX07XG5jb25zdCB0aWxlSW5uZXIgPSAke3RpbGVJbm5lcn07XG5cbkBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3dvcmtncm91cFNpemVbMF19LCAke3dvcmtncm91cFNpemVbMV19LCAke3dvcmtncm91cFNpemVbMl19KVxuZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwSWQgOiB2ZWMzPHUzMj4pIHtcbiAgbGV0IGxvY2FsUm93ID0gaTMyKGxvY2FsSWQueSk7XG4gIGxldCB0aWxlUm93ID0gbG9jYWxSb3cgKiByb3dQZXJUaHJlYWQ7XG4gIGxldCB0aWxlQ29sID0gaTMyKGxvY2FsSWQueCk7XG5cbiAgbGV0IGdsb2JhbFJvdyA9aTMyKGdsb2JhbElkLnkpICogcm93UGVyVGhyZWFkO1xuICBsZXQgZ2xvYmFsQ29sID0gaTMyKGdsb2JhbElkLngpO1xuICBsZXQgYmF0Y2ggPSAke3NwbGl0SyA/ICcwJyA6ICdpMzIoZ2xvYmFsSWQueiknfTtcbiAgJHtiYXRjaERpbXMgPyBgbGV0IGJhdGNoSW5kaWNlcyA9ICR7YmF0Y2hEaW1zLm9mZnNldFRvSW5kaWNlcygndTMyKGJhdGNoKScpfTtgIDogJyd9XG4gIGxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7dGlsZUFPdXRlcn07XG5cbiAgbGV0IG51bV90aWxlcyA9ICR7c3BsaXRLID8gYCR7TWF0aC5jZWlsKHNwbGl0ZWREaW1Jbm5lciAvIHRpbGVJbm5lcil9YCA6ICcodW5pZm9ybXMuZGltX2lubmVyIC0gMSkgLyB0aWxlSW5uZXIgKyAxJ307XG4gIHZhciBrU3RhcnQgPSAke3NwbGl0SyA/IGBpMzIoZ2xvYmFsSWQueikgKiAke3NwbGl0ZWREaW1Jbm5lcn1gIDogJzAnfTtcblxuICB2YXIgYWNjOiBhcnJheTx2ZWM0PCR7dHlwZX0+LCByb3dQZXJUaHJlYWQ+O1xuXG4gIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuICBsZXQgdGlsZVJvd0IgPSBsb2NhbFJvdyAqICR7cm93UGVyVGhyZWFkQn07XG4gIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtX3RpbGVzOyB0ID0gdCArIDEpIHtcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvdyArIGlubmVyUm93O1xuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XG4gICAgICAgICAgJHt3cml0ZURhdGFUb1N1YkFWZWM0U25pcHBldCh0cmFuc3Bvc2VBLCBiYXRjaERpbXMpfVxuICAgICAgfVxuXG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHtyb3dQZXJUaHJlYWRCfTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QiArIGlubmVyUm93O1xuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XG4gICAgICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsIGtTdGFydCArIGlucHV0Um93LCBnbG9iYWxDb2wke1xuICAgICAgICAgICAgYmF0Y2hEaW1zID8gJywgYmF0Y2hJbmRpY2VzJyA6ICcnXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXIgLyBpbm5lckVsZW1lbnRTaXplOyBrID0gayArIDEpIHtcbiAgICAgICAgICBsZXQgQkNhY2hlZDAgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplXVt0aWxlQ29sXTtcbiAgICAgICAgICBsZXQgQkNhY2hlZDEgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMV1bdGlsZUNvbF07XG4gICAgICAgICAgbGV0IEJDYWNoZWQyID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDJdW3RpbGVDb2xdO1xuICAgICAgICAgICR7aW5uZXJFbGVtZW50U2l6ZSA9PT0gMyA/ICcnIDogJ2xldCBCQ2FjaGVkMyA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAzXVt0aWxlQ29sXTsnfVxuXG4gICAgICAgICAgJHtjYWxjdWxhdGVSZXN1bHRTbmlwcGV0KHRyYW5zcG9zZUEsIGlubmVyRWxlbWVudFNpemUpfVxuICAgICAgfVxuXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gIH1cblxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgbW1fd3JpdGUoYmF0Y2gsIGdsb2JhbFJvdyArIGlubmVyUm93LCBnbG9iYWxDb2wsIGFjY1tpbm5lclJvd10pO1xuICB9XG59YDtcbn07XG5cbmNvbnN0IHdyaXRlRGF0YVRvU3ViQVNuaXBwZXQgPSAodHJhbnNwb3NlOiBib29sZWFuLCBiYXRjaERpbXM/OiBJbmRpY2VzSGVscGVyKSA9PiB7XG4gIGlmICh0cmFuc3Bvc2UpIHtcbiAgICByZXR1cm4gYFxuICAgICAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgICAgICBnbG9iYWxSb3dTdGFydCArIGlucHV0Q29sJHtiYXRjaERpbXMgPyAnLCBiYXRjaEluZGljZXMnIDogJyd9KTtcbiAgICAgICAgICAgIGA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGBcbiAgICAgICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgICAgICBnbG9iYWxSb3dTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgICAgICBrU3RhcnQgKyBpbnB1dENvbCR7YmF0Y2hEaW1zID8gJywgYmF0Y2hJbmRpY2VzJyA6ICcnfSk7XG4gICAgICAgICAgICBgO1xuICB9XG59O1xuXG5jb25zdCByZWFkRGF0YUZyb21TdWJBU25pcHBldCA9ICh0cmFuc3Bvc2VBOiBib29sZWFuKSA9PlxuICB0cmFuc3Bvc2VBID8gJ2xldCBBQ2FjaGVkID0gbW1fQXN1YltrXVt0aWxlUm93ICsgaW5uZXJSb3ddOycgOiAnbGV0IEFDYWNoZWQgPSBtbV9Bc3ViW3RpbGVSb3cgKyBpbm5lclJvd11ba107JztcblxuLy8gc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkcyBtZWFucyBzZXF1ZW50aWFsIGRhdGEgaW4gbWVtb3J5IGlzIGFjY2Vzc2VkIGJ5XG4vLyB0aHJlYWRzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHRocmVhZCAoZGVmYXVsdCBiZWhhdmlvcikuXG5leHBvcnQgY29uc3QgbWFrZU1hdE11bFBhY2tlZFNvdXJjZSA9IChcbiAgd29ya1BlclRocmVhZDogbnVtYmVyW10sXG4gIHdvcmtncm91cFNpemU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgdHlwZSA9ICdmMzInLFxuICBiYXRjaERpbXM/OiBJbmRpY2VzSGVscGVyLFxuICB0cmFuc3Bvc2VBID0gZmFsc2UsXG4gIHRpbGVJbm5lciA9IDMyLFxuICBzcGxpdEsgPSBmYWxzZSxcbiAgc3BsaXRlZERpbUlubmVyID0gMzIsXG4gIHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHMgPSBmYWxzZSxcbik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHRpbGVBT3V0ZXIgPSB3b3JrUGVyVGhyZWFkWzFdICogd29ya2dyb3VwU2l6ZVsxXTtcbiAgY29uc3QgdGlsZUJPdXRlciA9IHdvcmtQZXJUaHJlYWRbMF0gKiB3b3JrZ3JvdXBTaXplWzBdO1xuICBjb25zdCB0aWxlQVdpZHRoID0gdHJhbnNwb3NlQSA/IHRpbGVBT3V0ZXIgOiB0aWxlSW5uZXI7XG4gIGNvbnN0IHRpbGVBSGlnaHQgPSB0cmFuc3Bvc2VBID8gdGlsZUlubmVyIDogdGlsZUFPdXRlcjtcblxuICBpZiAoXG4gICAgISh0aWxlQUhpZ2h0ICUgd29ya2dyb3VwU2l6ZVsxXSA9PT0gMCAmJiB0aWxlQVdpZHRoICUgd29ya2dyb3VwU2l6ZVswXSA9PT0gMCAmJiB0aWxlSW5uZXIgJSB3b3JrZ3JvdXBTaXplWzFdID09PSAwKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgdGlsZUFIaWdodCAke3RpbGVBSGlnaHR9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMV0ke3dvcmtncm91cFNpemVbMV19LCB0aWxlQVdpZHRoICR7dGlsZUFXaWR0aH0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVswXSR7d29ya2dyb3VwU2l6ZVswXX0sIHRpbGVJbm5lciAke3RpbGVJbm5lcn0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSR7d29ya2dyb3VwU2l6ZVsxXX1gLFxuICAgICk7XG4gIH1cbiAgY29uc3Qgcm93UGVyVGhyZWFkQSA9IHRpbGVBSGlnaHQgLyB3b3JrZ3JvdXBTaXplWzFdO1xuICBjb25zdCBjb2xQZXJUaHJlYWRBID0gdGlsZUFXaWR0aCAvIHdvcmtncm91cFNpemVbMF07XG4gIGNvbnN0IHJvd1BlclRocmVhZEIgPSB0aWxlSW5uZXIgLyB3b3JrZ3JvdXBTaXplWzFdO1xuICBjb25zdCBtYXRtdWxTbmlwcGV0ID0gc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkc1xuICAgID8gYFxuICAgIGxldCBsb2NhbFJvdyA9IGkzMihsb2NhbElkLnkpO1xuICAgIGxldCBsb2NhbENvbCA9IGkzMihsb2NhbElkLngpO1xuICAgIGxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7dGlsZUFPdXRlcn07XG4gICAgbGV0IGdsb2JhbENvbFN0YXJ0ID0gaTMyKHdvcmtncm91cElkLngpICogJHt0aWxlQk91dGVyfTtcblxuICAgIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtX3RpbGVzOyB0ID0gdCArIDEpIHtcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlucHV0Um93ID0gbG9jYWxSb3c7IGlucHV0Um93IDwgJHt0aWxlQUhpZ2h0fTsgaW5wdXRSb3cgPSBpbnB1dFJvdyArICR7d29ya2dyb3VwU2l6ZVsxXX0pIHtcbiAgICAgICAgZm9yICh2YXIgaW5wdXRDb2wgPSBsb2NhbENvbDsgaW5wdXRDb2wgPCAke3RpbGVBV2lkdGh9OyBpbnB1dENvbCA9IGlucHV0Q29sICsgJHt3b3JrZ3JvdXBTaXplWzBdfSkge1xuICAgICAgICAgICR7d3JpdGVEYXRhVG9TdWJBU25pcHBldCh0cmFuc3Bvc2VBLCBiYXRjaERpbXMpfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbnB1dFJvdyA9IGxvY2FsUm93OyBpbnB1dFJvdyA8ICR7dGlsZUlubmVyfTsgaW5wdXRSb3cgPSBpbnB1dFJvdyArICR7d29ya2dyb3VwU2l6ZVsxXX0pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlucHV0Q29sID0gbG9jYWxDb2w7IGlucHV0Q29sIDwgJHt0aWxlQk91dGVyfTsgaW5wdXRDb2wgPSBpbnB1dENvbCArICR7d29ya2dyb3VwU2l6ZVswXX0pIHtcbiAgICAgICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCxcbiAgICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgICAgZ2xvYmFsQ29sU3RhcnQgKyBpbnB1dENvbCR7YmF0Y2hEaW1zID8gJywgYmF0Y2hJbmRpY2VzJyA6ICcnfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXG4gICAgICB2YXIgQkNhY2hlZCA6IGFycmF5PCR7dHlwZX0sIGNvbFBlclRocmVhZD47XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lcjsgayA9IGsgKyAxKSB7XG4gICAgICAgIGZvciAodmFyIGlubmVyID0gMDsgaW5uZXIgPCBjb2xQZXJUaHJlYWQ7IGlubmVyID0gaW5uZXIgKyAxKSB7XG4gICAgICAgICAgQkNhY2hlZFtpbm5lcl0gPSBtbV9Cc3ViW2tdW2xvY2FsQ29sICsgaW5uZXIgKiAke3dvcmtncm91cFNpemVbMF19XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgICAgIGxldCBBQ2FjaGVkID0gJHtcbiAgICAgICAgICAgIHRyYW5zcG9zZUFcbiAgICAgICAgICAgICAgPyBgbW1fQXN1YltrXVtsb2NhbFJvdyArIGlubmVyUm93ICogJHt3b3JrZ3JvdXBTaXplWzFdfV07YFxuICAgICAgICAgICAgICA6IGBtbV9Bc3ViW2xvY2FsUm93ICsgaW5uZXJSb3cgKiAke3dvcmtncm91cFNpemVbMV19XVtrXTtgXG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IGFjY1tpbm5lclJvd11baW5uZXJDb2xdICtcbiAgICAgICAgICAgICAgICBBQ2FjaGVkICogQkNhY2hlZFtpbm5lckNvbF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICBsZXQgZ1JvdyA9IGdsb2JhbFJvd1N0YXJ0ICsgbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7d29ya2dyb3VwU2l6ZVsxXX07XG4gICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICBsZXQgZ0NvbCA9IGdsb2JhbENvbFN0YXJ0ICsgbG9jYWxDb2wgKyBpbm5lckNvbCAqICR7d29ya2dyb3VwU2l6ZVswXX07XG4gICAgICAgIG1tX3dyaXRlKGJhdGNoLCBnUm93LCBnQ29sLCBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGBcbiAgICA6IGBcbmxldCB0aWxlUm93ID0gaTMyKGxvY2FsSWQueSkgKiByb3dQZXJUaHJlYWQ7XG5sZXQgdGlsZUNvbCA9IGkzMihsb2NhbElkLngpICogY29sUGVyVGhyZWFkO1xuXG5sZXQgZ2xvYmFsUm93ID0gaTMyKGdsb2JhbElkLnkpICogcm93UGVyVGhyZWFkO1xubGV0IGdsb2JhbENvbCA9IGkzMihnbG9iYWxJZC54KSAqIGNvbFBlclRocmVhZDtcbmxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7dGlsZUFPdXRlcn07XG5cbmxldCB0aWxlUm93QSA9IGkzMihsb2NhbElkLnkpICogJHtyb3dQZXJUaHJlYWRBfTtcbmxldCB0aWxlQ29sQSA9IGkzMihsb2NhbElkLngpICogJHtjb2xQZXJUaHJlYWRBfTtcbmxldCB0aWxlUm93QiA9IGkzMihsb2NhbElkLnkpICogJHtyb3dQZXJUaHJlYWRCfTtcbi8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuZm9yICh2YXIgdCA9IDA7IHQgPCBudW1fdGlsZXM7IHQgPSB0ICsgMSkge1xuICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke3Jvd1BlclRocmVhZEF9OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCAke2NvbFBlclRocmVhZEF9OyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0EgKyBpbm5lclJvdztcbiAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2xBICsgaW5uZXJDb2w7XG4gICAgICAke3dyaXRlRGF0YVRvU3ViQVNuaXBwZXQodHJhbnNwb3NlQSwgYmF0Y2hEaW1zKX1cbiAgICB9XG4gIH1cblxuICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke3Jvd1BlclRocmVhZEJ9OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QiArIGlubmVyUm93O1xuICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbCArIGlubmVyQ29sO1xuICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsXG4gICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICBnbG9iYWxDb2wgKyBpbm5lckNvbCR7YmF0Y2hEaW1zID8gJywgYmF0Y2hJbmRpY2VzJyA6ICcnfSk7XG4gICAgfVxuICB9XG4gIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcbiAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxuICB2YXIgQkNhY2hlZCA6IGFycmF5PCR7dHlwZX0sIGNvbFBlclRocmVhZD47XG4gIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyOyBrID0gayArIDEpIHtcbiAgICBmb3IgKHZhciBpbm5lciA9IDA7IGlubmVyIDwgY29sUGVyVGhyZWFkOyBpbm5lciA9IGlubmVyICsgMSkge1xuICAgICAgQkNhY2hlZFtpbm5lcl0gPSBtbV9Cc3ViW2tdW3RpbGVDb2wgKyBpbm5lcl07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICR7cmVhZERhdGFGcm9tU3ViQVNuaXBwZXQodHJhbnNwb3NlQSl9XG4gICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IGFjY1tpbm5lclJvd11baW5uZXJDb2xdICsgQUNhY2hlZCAqIEJDYWNoZWRbaW5uZXJDb2xdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHdvcmtncm91cEJhcnJpZXIoKTtcbn1cblxuZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICBtbV93cml0ZShiYXRjaCwgZ2xvYmFsUm93ICsgaW5uZXJSb3csIGdsb2JhbENvbCArIGlubmVyQ29sLFxuICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSk7XG4gIH1cbn1cbmA7XG5cbiAgcmV0dXJuIGBcbiAgdmFyPHdvcmtncm91cD4gbW1fQXN1YiA6IGFycmF5PGFycmF5PCR7dHlwZX0sICR7dGlsZUFXaWR0aH0+LCAke3RpbGVBSGlnaHR9PjtcbiAgdmFyPHdvcmtncm91cD4gbW1fQnN1YiA6IGFycmF5PGFycmF5PCR7dHlwZX0sICR7dGlsZUJPdXRlcn0+LCAke3RpbGVJbm5lcn0+O1xuICBjb25zdCByb3dQZXJUaHJlYWQgPSAke3dvcmtQZXJUaHJlYWRbMV19O1xuICBjb25zdCBjb2xQZXJUaHJlYWQgPSAke3dvcmtQZXJUaHJlYWRbMF19O1xuICBjb25zdCB0aWxlSW5uZXIgPSAke3RpbGVJbm5lcn07XG5cbkBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3dvcmtncm91cFNpemVbMF19LCAke3dvcmtncm91cFNpemVbMV19LCAke3dvcmtncm91cFNpemVbMl19KVxuZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwSWQgOiB2ZWMzPHUzMj4pIHtcbiAgICBsZXQgYmF0Y2ggPSAke3NwbGl0SyA/ICcwJyA6ICdpMzIoZ2xvYmFsSWQueiknfTtcbiAgICAke2JhdGNoRGltcyA/IGBsZXQgYmF0Y2hJbmRpY2VzID0gJHtiYXRjaERpbXMub2Zmc2V0VG9JbmRpY2VzKCd1MzIoYmF0Y2gpJyl9O2AgOiAnJ31cbiAgICBsZXQgbnVtX3RpbGVzID0gJHtcbiAgICAgIHNwbGl0SyA/IGAke01hdGguY2VpbChzcGxpdGVkRGltSW5uZXIgLyB0aWxlSW5uZXIpfWAgOiAnKHVuaWZvcm1zLmRpbV9pbm5lciAtIDEpIC8gdGlsZUlubmVyICsgMSdcbiAgICB9O1xuICAgIHZhciBrU3RhcnQgPSAke3NwbGl0SyA/IGBpMzIoZ2xvYmFsSWQueikgKiAke3NwbGl0ZWREaW1Jbm5lcn1gIDogJzAnfTtcblxuICAgIHZhciBhY2MgOiBhcnJheTxhcnJheTwke3R5cGV9LCBjb2xQZXJUaHJlYWQ+LCByb3dQZXJUaHJlYWQ+O1xuICAgICR7bWF0bXVsU25pcHBldH1cbiAgfVxuYDtcbn07XG5cbmNvbnN0IG1hdE11bFJlYWRXcml0ZUZuU291cmNlID0gKFxuICBjb21wb25lbnQ6IG51bWJlcixcbiAgaGFzQmlhczogYm9vbGVhbixcbiAgYXBwbHlBY3RpdmF0aW9uOiBzdHJpbmcsXG4gIHZhcmlhYmxlczogSW5kaWNlc0hlbHBlcltdLFxuICBiYXRjaFNoYXBlczogQXJyYXk8cmVhZG9ubHkgbnVtYmVyW10+LFxuICBpc0NoYW5uZWxzTGFzdCA9IGZhbHNlLFxuKTogc3RyaW5nID0+IHtcbiAgY29uc3QgW2JhdGNoQVNoYXBlLCBiYXRjaEJTaGFwZSwgYmF0Y2hTaGFwZV0gPSBiYXRjaFNoYXBlcztcbiAgY29uc3QgW2JhdGNoVmFyaWFibGUsIGFWYXJpYWJsZSwgYlZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZV0gPSB2YXJpYWJsZXM7XG4gIGNvbnN0IGJyb2FkQ2FzdEFEaW1zID0gZ2V0QnJvYWRjYXN0RGltcyhiYXRjaEFTaGFwZSwgYmF0Y2hTaGFwZSk7XG4gIGNvbnN0IGJyb2FkQ2FzdEJEaW1zID0gZ2V0QnJvYWRjYXN0RGltcyhiYXRjaEJTaGFwZSwgYmF0Y2hTaGFwZSk7XG4gIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKHZhcmlhYmxlc1swXS50eXBlLnRlbnNvcik7XG4gIGNvbnN0IGdldEFJbmRpY2VzID0gKCkgPT4ge1xuICAgIGNvbnN0IGFSYW5rID0gYVZhcmlhYmxlLnJhbms7XG4gICAgY29uc3QgYmF0Y2hSYW5rID0gYmF0Y2hWYXJpYWJsZS5yYW5rO1xuICAgIGxldCByZXNTdHIgPSBgdmFyIGFJbmRpY2VzOiAke2FWYXJpYWJsZS50eXBlLmluZGljZXN9O2A7XG4gICAgZm9yIChsZXQgaSA9IGFSYW5rIC0gMiAtIDEsIGogPSBiYXRjaFJhbmsgLSAxOyBpID49IDA7IGktLSwgai0tKSB7XG4gICAgICByZXNTdHIgKz0gYFxcbmFJbmRpY2VzWyR7aX1dID0gJHtiYXRjaFJhbmsgPiAxID8gYGJhdGNoSW5kaWNlc1ske2p9XWAgOiAnYmF0Y2hJbmRpY2VzJ307YDtcbiAgICB9XG4gICAgYnJvYWRDYXN0QURpbXMuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgcmVzU3RyICs9IGBcXG5hSW5kaWNlc1ske2l9XSA9IDA7YDtcbiAgICB9KTtcbiAgICByZXNTdHIgKz0gYFxcbmFJbmRpY2VzWyR7YVJhbmsgLSAyfV0gPSB1MzIocm93KTtcbiAgICAgICAgICAgICAgICAgICBhSW5kaWNlc1ske2FSYW5rIC0gMX1dID0gdTMyKGNvbEluKTtgO1xuICAgIHJldHVybiByZXNTdHI7XG4gIH07XG4gIGNvbnN0IGdldEJJbmRpY2VzID0gKCkgPT4ge1xuICAgIGNvbnN0IGJSYW5rID0gYlZhcmlhYmxlLnJhbms7XG4gICAgY29uc3QgYmF0Y2hSYW5rID0gYmF0Y2hWYXJpYWJsZS5yYW5rO1xuICAgIGxldCByZXNTdHIgPSBgdmFyIGJJbmRpY2VzOiAke2JWYXJpYWJsZS50eXBlLmluZGljZXN9O2A7XG4gICAgZm9yIChsZXQgaSA9IGJSYW5rIC0gMiAtIDEsIGogPSBiYXRjaFJhbmsgLSAxOyBpID49IDA7IGktLSwgai0tKSB7XG4gICAgICByZXNTdHIgKz0gYFxcbmJJbmRpY2VzWyR7aX1dID0gJHtiYXRjaFJhbmsgPiAxID8gYGJhdGNoSW5kaWNlc1ske2p9XWAgOiAnYmF0Y2hJbmRpY2VzJ307YDtcbiAgICB9XG4gICAgYnJvYWRDYXN0QkRpbXMuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgcmVzU3RyICs9IGBcXG5iSW5kaWNlc1ske2l9XSA9IDA7YDtcbiAgICB9KTtcbiAgICByZXNTdHIgKz0gYFxcbmJJbmRpY2VzWyR7YlJhbmsgLSAyfV0gPSB1MzIocm93KTtcbiAgICAgICAgICAgICAgICAgICBiSW5kaWNlc1ske2JSYW5rIC0gMX1dID0gdTMyKGNvbEluKTtgO1xuICAgIHJldHVybiByZXNTdHI7XG4gIH07XG4gIGNvbnN0IHNvdXJjZSA9IGBcbiAgICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgYmF0Y2hJbmRpY2VzOiAke2JhdGNoVmFyaWFibGUudHlwZS5pbmRpY2VzfSkgLT4gJHt0eXBlU25pcHBldChcbiAgICAgIGNvbXBvbmVudCxcbiAgICAgIGRhdGFUeXBlLFxuICAgICl9IHtcbiAgICAgIHZhciB2YWx1ZSA9ICR7dHlwZVNuaXBwZXQoY29tcG9uZW50LCBkYXRhVHlwZSl9KDAuMCk7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2NvbXBvbmVudH07XG4gICAgICBpZihyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1faW5uZXIpXG4gICAgICB7XG4gICAgICAgICR7Z2V0QUluZGljZXMoKX1cbiAgICAgICAgdmFsdWUgPSAke2FWYXJpYWJsZS5nZXRCeUluZGljZXMoJ2FJbmRpY2VzJyl9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZuIG1tX3JlYWRCKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCBiYXRjaEluZGljZXM6ICR7YmF0Y2hWYXJpYWJsZS50eXBlLmluZGljZXN9KSAtPiAke3R5cGVTbmlwcGV0KFxuICAgICAgY29tcG9uZW50LFxuICAgICAgZGF0YVR5cGUsXG4gICAgKX0ge1xuICAgICAgdmFyIHZhbHVlID0gJHt0eXBlU25pcHBldChjb21wb25lbnQsIGRhdGFUeXBlKX0oMC4wKTtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7Y29tcG9uZW50fTtcbiAgICAgIGlmKHJvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcilcbiAgICAgIHtcbiAgICAgICAgJHtnZXRCSW5kaWNlcygpfVxuICAgICAgICB2YWx1ZSA9ICR7YlZhcmlhYmxlLmdldEJ5SW5kaWNlcygnYkluZGljZXMnKX07XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93OiBpMzIsIGNvbEluOiBpMzIsIHZhbHVlSW46ICR7dHlwZVNuaXBwZXQoY29tcG9uZW50LCBkYXRhVHlwZSl9KSB7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2NvbXBvbmVudH07XG4gICAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbjtcbiAgICAgICAgbGV0IGNvb3JkcyA9IHZlYzM8aTMyPihiYXRjaCwgcm93LCBjb2xJbik7XG4gICAgICAgICR7XG4gICAgICAgICAgaGFzQmlhc1xuICAgICAgICAgICAgPyBgdmFsdWUgPSB2YWx1ZSArICR7aXNDaGFubmVsc0xhc3QgPyAnYmlhc1tjb2xJbl0nIDogYCR7dHlwZVNuaXBwZXQoY29tcG9uZW50LCBkYXRhVHlwZSl9KGJpYXNbcm93XSlgfTtgXG4gICAgICAgICAgICA6ICcnXG4gICAgICAgIH1cbiAgICAgICAgJHthcHBseUFjdGl2YXRpb259XG4gICAgICAgICR7b3V0cHV0VmFyaWFibGUuc2V0QnlJbmRpY2VzKCd2ZWMzPHUzMj4oY29vcmRzKScsICd2YWx1ZScpfVxuICAgICAgfVxuICAgIH1cbiAgICBgO1xuICByZXR1cm4gc291cmNlO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYWN0aXZhdGlvbkF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsXG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgcmVzaGFwZWRPdXRwdXRTaGFwZT86IHJlYWRvbmx5IG51bWJlcltdLFxuICBpc0NoYW5uZWxzTGFzdCA9IGZhbHNlIC8qIG9ubHkgdXNlZCBmb3IgY29udjJkQnlNYXRNdWwqLyxcbiAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24/OiAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBudW1iZXJbXSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgYVNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGJTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuICBjb25zdCBvdXRlckRpbXNBID0gYVNoYXBlLnNsaWNlKDAsIC0yKTtcbiAgY29uc3Qgb3V0ZXJEaW1zQiA9IGJTaGFwZS5zbGljZSgwLCAtMik7XG4gIGNvbnN0IG91dGVyRGltcyA9IHJlc2hhcGVkT3V0cHV0U2hhcGUgPyByZXNoYXBlZE91dHB1dFNoYXBlLnNsaWNlKDAsIC0yKSA6IG91dHB1dFNoYXBlLnNsaWNlKDAsIC0yKTtcbiAgY29uc3QgYmF0Y2hTaXplID0gU2hhcGVVdGlsLnNpemUob3V0ZXJEaW1zKTtcbiAgY29uc3QgZGltQU91dGVyID0gYVNoYXBlW2FTaGFwZS5sZW5ndGggLSAyXTtcbiAgY29uc3QgZGltSW5uZXIgPSBhU2hhcGVbYVNoYXBlLmxlbmd0aCAtIDFdO1xuICBjb25zdCBkaW1CT3V0ZXIgPSBiU2hhcGVbYlNoYXBlLmxlbmd0aCAtIDFdO1xuICBjb25zdCBpc1ZlYzQgPSBkaW1Jbm5lciAlIDQgPT09IDAgJiYgZGltQk91dGVyICUgNCA9PT0gMDtcblxuICAvLyBUT0RPOiBmaW5lIHR1bmUgc2l6ZVxuICBjb25zdCBlbGVtZW50c1BlclRocmVhZCA9IGRpbUFPdXRlciA8PSA4ID8gWzQsIDEsIDFdIDogWzQsIDQsIDFdO1xuICBjb25zdCB3b3JrZ3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbOCwgOCwgMV07XG4gIGNvbnN0IGRpc3BhdGNoID0gW1xuICAgIE1hdGguY2VpbChkaW1CT3V0ZXIgLyB3b3JrZ3JvdXBTaXplWzBdIC8gZWxlbWVudHNQZXJUaHJlYWRbMF0pLFxuICAgIE1hdGguY2VpbChkaW1BT3V0ZXIgLyB3b3JrZ3JvdXBTaXplWzFdIC8gZWxlbWVudHNQZXJUaHJlYWRbMV0pLFxuICAgIE1hdGguY2VpbChiYXRjaFNpemUgLyB3b3JrZ3JvdXBTaXplWzJdIC8gZWxlbWVudHNQZXJUaHJlYWRbMl0pLFxuICBdO1xuXG4gIGNvbnN0IGNvbXBvbmVudHMgPSBpc1ZlYzQgPyA0IDogMTtcbiAgY29uc3QgYVNoYXBlVGVtcCA9IFsuLi5vdXRlckRpbXNBLCBkaW1BT3V0ZXIsIGRpbUlubmVyIC8gY29tcG9uZW50c107XG4gIGNvbnN0IGFSYW5rID0gYVNoYXBlVGVtcC5sZW5ndGg7XG4gIGNvbnN0IGJTaGFwZVRlbXAgPSBbLi4ub3V0ZXJEaW1zQiwgZGltSW5uZXIsIGRpbUJPdXRlciAvIGNvbXBvbmVudHNdO1xuICBjb25zdCBiUmFuayA9IGJTaGFwZVRlbXAubGVuZ3RoO1xuICBjb25zdCBvdXRwdXRTaGFwZVRlbXAgPSBbYmF0Y2hTaXplLCBkaW1BT3V0ZXIsIGRpbUJPdXRlciAvIGNvbXBvbmVudHNdO1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZGltQU91dGVyIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZGltQk91dGVyIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZGltSW5uZXIgfSxcbiAgXTtcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YShhY3RpdmF0aW9uQXR0cmlidXRlcywgcHJvZ3JhbVVuaWZvcm1zKTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0ZXJEaW1zLCBhU2hhcGVUZW1wLCBiU2hhcGVUZW1wKSk7XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWydyYW5rJywgJ3JhbmsnXTtcblxuICBjb25zdCBoYXNCaWFzID0gaW5wdXRzLmxlbmd0aCA+IDI7XG4gIGlmIChoYXNCaWFzKSB7XG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzJdLmRpbXMpKTtcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCdyYW5rJyk7XG4gIH1cbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGVUZW1wKSk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgYmF0Y2hSYW5rID0gb3V0ZXJEaW1zLmxlbmd0aDtcbiAgICBjb25zdCBiYXRjaERpbXMgPSBpbnRlcm5hbFZhcmlhYmxlKCdiYXRjaERpbXMnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGJhdGNoUmFuaywgMSk7XG4gICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcblxuICAgIGNvbnN0IEEgPSBpbnB1dFZhcmlhYmxlKCdhJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBhUmFuaywgY29tcG9uZW50cyk7XG4gICAgY29uc3QgQiA9IGlucHV0VmFyaWFibGUoJ2InLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGJSYW5rLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgncmVzdWx0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZVRlbXAubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFtBLCBCXTtcbiAgICBpZiAoaGFzQmlhcykge1xuICAgICAgY29uc3QgYmlhc0NvbXBvbmVudHMgPSBpc0NoYW5uZWxzTGFzdCA/IGNvbXBvbmVudHMgOiAxO1xuICAgICAgaW5wdXRWYXJpYWJsZXMucHVzaChpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgsIGJpYXNDb21wb25lbnRzKSk7XG4gICAgfVxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgIHsgbmFtZTogJ2RpbV9hX291dGVyJywgdHlwZTogJ2kzMicgfSxcbiAgICAgIHsgbmFtZTogJ2RpbV9iX291dGVyJywgdHlwZTogJ2kzMicgfSxcbiAgICAgIHsgbmFtZTogJ2RpbV9pbm5lcicsIHR5cGU6ICdpMzInIH0sXG4gICAgXTtcbiAgICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMoYWN0aXZhdGlvbkF0dHJpYnV0ZXMsIHVuaWZvcm1zKTtcbiAgICBjb25zdCBiYXNlVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShvdXRwdXQudHlwZS50ZW5zb3IpO1xuICAgIGNvbnN0IGFwcGx5QWN0aXZhdGlvbiA9IGdldEFjdGl2YXRpb25TbmlwcGV0KGFjdGl2YXRpb25BdHRyaWJ1dGVzLCBvdXRwdXQudHlwZS52YWx1ZSwgYmFzZVR5cGUpO1xuICAgIGNvbnN0IGRlY2xhcmVGdW5jdGlvbnMgPSBtYXRNdWxSZWFkV3JpdGVGblNvdXJjZShcbiAgICAgIGNvbXBvbmVudHMsXG4gICAgICBoYXNCaWFzLFxuICAgICAgYXBwbHlBY3RpdmF0aW9uLFxuICAgICAgW2JhdGNoRGltcywgQSwgQiwgb3V0cHV0XSxcbiAgICAgIFtvdXRlckRpbXNBLCBvdXRlckRpbXNCLCBvdXRlckRpbXNdLFxuICAgICAgaXNDaGFubmVsc0xhc3QsXG4gICAgKTtcbiAgICByZXR1cm4gYFxuICAke3NoYWRlckhlbHBlclxuICAgIC5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKVxuICAgIC5yZWdpc3RlckludGVybmFsVmFyaWFibGVzKGJhdGNoRGltcylcbiAgICAuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcmlhYmxlcywgb3V0cHV0KX1cbiAgJHtkZWNsYXJlRnVuY3Rpb25zfVxuICAke1xuICAgIGlzVmVjNFxuICAgICAgPyBtYWtlTWF0TXVsUGFja2VkVmVjNFNvdXJjZShlbGVtZW50c1BlclRocmVhZCwgd29ya2dyb3VwU2l6ZSwgZGF0YVR5cGUsIGJhdGNoRGltcylcbiAgICAgIDogbWFrZU1hdE11bFBhY2tlZFNvdXJjZShlbGVtZW50c1BlclRocmVhZCwgd29ya2dyb3VwU2l6ZSwgZGF0YVR5cGUsIGJhdGNoRGltcylcbiAgfVxuICAgICAgICAgICAgICAgICAgIGA7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ01hdE11bCcsXG4gICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgIGhpbnQ6IGAke2VsZW1lbnRzUGVyVGhyZWFkfTske2FjdGl2YXRpb25BdHRyaWJ1dGVzLmFjdGl2YXRpb259OyR7aXNWZWM0fTske2lzQ2hhbm5lbHNMYXN0fWAsXG4gICAgICBpbnB1dERlcGVuZGVuY2llcyxcbiAgICB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBkaW1zOiBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbiA/IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uKG91dHB1dFNoYXBlKSA6IG91dHB1dFNoYXBlLFxuICAgICAgICAgIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBkaXNwYXRjaFswXSwgeTogZGlzcGF0Y2hbMV0sIHo6IGRpc3BhdGNoWzJdIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcbiIsICIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8vIHNhbXBsZWQgZnJvbSBbQHRlbnNvcmZsb3cvdGZqc10gdGZqcy1iYWNrZW5kLXdlYmdwdS9zcmMvY29udjJkX21tX3dlYmdwdS50c1xuLy9cbi8vIG1vZGlmaWVkIHRvIGZpdCB0aGUgbmVlZHMgb2YgdGhlIHByb2plY3RcblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBMT0dfREVCVUcgfSBmcm9tICcuLi8uLi8uLi9sb2cnO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQge1xuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7IENvbnZBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vY29udic7XG5pbXBvcnQgeyBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMsIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEsIGdldEFjdGl2YXRpb25TbmlwcGV0IH0gZnJvbSAnLi4vZnVzZS11dGlscyc7XG5cbmltcG9ydCB7IGJpYXNTbmlwcGV0LCB0eXBlU25pcHBldCB9IGZyb20gJy4vYWN0aXZhdGlvbl91dGlsJztcbmltcG9ydCB7IHV0aWxGdW5jdGlvbnMgfSBmcm9tICcuL2NvbnZfdXRpbCc7XG5pbXBvcnQgeyBtYWtlTWF0TXVsUGFja2VkU291cmNlLCBtYWtlTWF0TXVsUGFja2VkVmVjNFNvdXJjZSB9IGZyb20gJy4vbWF0bXVsX3BhY2tlZF93ZWJncHUnO1xuXG5jb25zdCBjb252MmRDb21tb25TbmlwcGV0ID0gKFxuICBpc0NoYW5uZWxzTGFzdDogYm9vbGVhbixcbiAgZml0QU91dGVyOiBib29sZWFuLFxuICBmaXRCT3V0ZXI6IGJvb2xlYW4sXG4gIGZpdElubmVyOiBib29sZWFuLFxuICBhZGRCaWFzID0gZmFsc2UsXG4gIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLFxuICBpbm5lckVsZW1lbnRTaXplWCA9IDQsXG4gIGlubmVyRWxlbWVudFNpemVXID0gNCxcbiAgaW5uZXJFbGVtZW50U2l6ZSA9IDQsXG4gIGRhdGFUeXBlID0gJ2YzMicsXG4pOiBzdHJpbmcgPT4ge1xuICBjb25zdCBnZXRYU25pcHBldCA9IChpbm5lckVsZW1lbnRTaXplOiBudW1iZXIpID0+IHtcbiAgICBzd2l0Y2ggKGlubmVyRWxlbWVudFNpemUpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuICdyZXNEYXRhID0geFt4SW5kZXhdOyc7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiBgcmVzRGF0YSA9IHZlYzM8JHtkYXRhVHlwZX0+KHhbeEluZGV4XSwgeFt4SW5kZXggKyAxXSwgeFt4SW5kZXggKyAyXSk7YDtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgcmV0dXJuICdyZXNEYXRhID0geFt4SW5kZXggLyA0XTsnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7aW5uZXJFbGVtZW50U2l6ZX0gaXMgbm90IHN1cHBvcnRlZC5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGdldFdTbmlwcGV0ID0gKGlubmVyRWxlbWVudFNpemU6IG51bWJlcikgPT4ge1xuICAgIHN3aXRjaCAoaW5uZXJFbGVtZW50U2l6ZSkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gJ3JldHVybiB3W3JvdyAqIGkzMih1bmlmb3Jtcy53X3NoYXBlWzNdKSArIGNvbEluXTsnO1xuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gJ3JldHVybiB3W3JvdyAqIGkzMih1bmlmb3Jtcy53X3NoYXBlWzNdKSAvIDQgKyBjb2xJbl07JztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke2lubmVyRWxlbWVudFNpemV9IGlzIG5vdCBzdXBwb3J0ZWQuYCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBjb29yZEFTbmlwcGV0ID0gaXNDaGFubmVsc0xhc3RcbiAgICA/IGBcbiAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhSb3csIHhDb2wsIHhDaCk7XG4gICAgYFxuICAgIDogYFxuICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgeENoLCB4Um93LCB4Q29sKTtcbiAgICBgO1xuXG4gIGNvbnN0IGNvb3JkUmVzU25pcHBldCA9IGlzQ2hhbm5lbHNMYXN0XG4gICAgPyBgXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcbiAgICAgIGJhdGNoLFxuICAgICAgcm93IC8gb3V0V2lkdGgsXG4gICAgICByb3cgJSBvdXRXaWR0aCxcbiAgICAgIGNvbCk7XG4gICAgYFxuICAgIDogYFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXG4gICAgICBiYXRjaCxcbiAgICAgIHJvdyxcbiAgICAgIGNvbCAvIG91dFdpZHRoLFxuICAgICAgY29sICUgb3V0V2lkdGgpO1xuICAgIGA7XG5cbiAgY29uc3QgeEhlaWdodCA9IGlzQ2hhbm5lbHNMYXN0ID8gJ2kzMih1bmlmb3Jtcy54X3NoYXBlWzFdKScgOiAnaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pJztcbiAgY29uc3QgeFdpZHRoID0gaXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pJyA6ICdpMzIodW5pZm9ybXMueF9zaGFwZVszXSknO1xuICBjb25zdCByb3cgPSBpc0NoYW5uZWxzTGFzdCA/ICdyb3cnIDogJ2NvbCc7XG4gIGNvbnN0IGNvbCA9IGlzQ2hhbm5lbHNMYXN0ID8gJ2NvbCcgOiAncm93JztcbiAgY29uc3QgcmVhZFhTbmlwcGV0ID0gYFxuICAgIGxldCBpbkNoYW5uZWxzID0gaTMyKHVuaWZvcm1zLndfc2hhcGVbMl0pO1xuICAgIGxldCBvdXRXaWR0aCA9ICR7aXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsyXSknIDogJ2kzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbM10pJ307XG4gICAgbGV0IG91dFJvdyA9ICR7cm93fSAvIG91dFdpZHRoO1xuICAgIGxldCBvdXRDb2wgPSAke3Jvd30gJSBvdXRXaWR0aDtcblxuICAgIGxldCBXUm93ID0gJHtjb2x9IC8gKGkzMih1bmlmb3Jtcy53X3NoYXBlWzFdKSAqIGluQ2hhbm5lbHMpO1xuICAgIGxldCBXQ29sID0gJHtjb2x9IC8gaW5DaGFubmVscyAlIGkzMih1bmlmb3Jtcy53X3NoYXBlWzFdKTtcbiAgICBsZXQgeFJvdyA9IG91dFJvdyAqIHVuaWZvcm1zLnN0cmlkZVswXSArIHVuaWZvcm1zLmRpbGF0aW9uWzBdICogV1JvdyAtIHVuaWZvcm1zLnBhZFswXTtcbiAgICBsZXQgeENvbCA9IG91dENvbCAqIHVuaWZvcm1zLnN0cmlkZVsxXSArIHVuaWZvcm1zLmRpbGF0aW9uWzFdICogV0NvbCAtIHVuaWZvcm1zLnBhZFsxXTtcbiAgICBsZXQgeENoID0gJHtjb2x9ICUgaW5DaGFubmVscztcbiAgICB2YXIgcmVzRGF0YSA9ICR7dHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVgsIGRhdGFUeXBlKX0oMC4wKTtcbiAgICAvLyBUaGUgYm91bmRzIGNoZWNraW5nIGlzIGFsd2F5cyBuZWVkZWQgc2luY2Ugd2UgdXNlIGl0IHRvIHBhZCB6ZXJvIGZvclxuICAgIC8vIHRoZSAnc2FtZScgcGFkZGluZyB0eXBlLlxuICAgIGlmICh4Um93ID49IDAgJiYgeFJvdyA8ICR7eEhlaWdodH0gJiYgeENvbCA+PSAwICYmIHhDb2wgPCAke3hXaWR0aH0pIHtcbiAgICAgICR7Y29vcmRBU25pcHBldH1cbiAgICAgIGxldCB4SW5kZXggPSBnZXRJbmRleEZyb21Db29yZHM0RChjb29yZCwgdmVjNDxpMzI+KHVuaWZvcm1zLnhfc2hhcGUpKTtcbiAgICAgICR7Z2V0WFNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVgpfVxuICAgIH1cbiAgICByZXR1cm4gcmVzRGF0YTtgO1xuXG4gIGNvbnN0IHNhbXBsZVggPSBpc0NoYW5uZWxzTGFzdFxuICAgID8gZml0QU91dGVyICYmIGZpdElubmVyXG4gICAgICA/IGBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2lubmVyRWxlbWVudFNpemVYfTtcbiAgICAke3JlYWRYU25pcHBldH1gXG4gICAgICA6IGBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2lubmVyRWxlbWVudFNpemVYfTtcbiAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2lubmVyKSB7XG4gICAgICAke3JlYWRYU25pcHBldH1cbiAgICB9XG4gICAgcmV0dXJuICR7dHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVgsIGRhdGFUeXBlKX0oMC4wKTtgXG4gICAgOiBmaXRJbm5lciAmJiBmaXRCT3V0ZXJcbiAgICAgID8gYFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZVh9O1xuICAgICR7cmVhZFhTbmlwcGV0fWBcbiAgICAgIDogYFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZVh9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcbiAgICAgICR7cmVhZFhTbmlwcGV0fVxuICAgIH1cbiAgICByZXR1cm4gJHt0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplWCwgZGF0YVR5cGUpfSgwLjApO2A7XG5cbiAgY29uc3Qgc2FtcGxlVyA9IGAke2dldFdTbmlwcGV0KGlubmVyRWxlbWVudFNpemVXKX1gO1xuXG4gIGNvbnN0IHJlc1R5cGUgPSB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplLCBkYXRhVHlwZSk7XG4gIGNvbnN0IGFUeXBlID0gaXNDaGFubmVsc0xhc3QgPyB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplWCwgZGF0YVR5cGUpIDogdHlwZVNuaXBwZXQoaW5uZXJFbGVtZW50U2l6ZVcsIGRhdGFUeXBlKTtcbiAgY29uc3QgYlR5cGUgPSBpc0NoYW5uZWxzTGFzdCA/IHR5cGVTbmlwcGV0KGlubmVyRWxlbWVudFNpemVXLCBkYXRhVHlwZSkgOiB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplWCwgZGF0YVR5cGUpO1xuICBjb25zdCBhcHBseUFjdGl2YXRpb24gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhdHRyaWJ1dGVzLCByZXNUeXBlLCBkYXRhVHlwZSk7XG4gIGNvbnN0IHVzZXJDb2RlID0gYFxuICAgIGZuIG1tX3JlYWRBKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7YVR5cGV9IHtcbiAgICAgICR7aXNDaGFubmVsc0xhc3QgPyBzYW1wbGVYIDogc2FtcGxlV31cbiAgICB9XG5cbiAgICBmbiBtbV9yZWFkQihiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke2JUeXBlfSB7XG4gICAgICAke2lzQ2hhbm5lbHNMYXN0ID8gc2FtcGxlVyA6IHNhbXBsZVh9XG4gICAgfVxuXG4gICAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMiwgdmFsdWVJbiA6ICR7cmVzVHlwZX0pIHtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZX07XG4gICAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpXG4gICAgICB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZUluO1xuICAgICAgbGV0IG91dFdpZHRoID0gJHtpc0NoYW5uZWxzTGFzdCA/ICdpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzJdKScgOiAnaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVszXSknfTtcbiAgICAgICR7Y29vcmRSZXNTbmlwcGV0fVxuICAgICAgJHtiaWFzU25pcHBldChhZGRCaWFzKX1cbiAgICAgICR7YXBwbHlBY3RpdmF0aW9ufVxuICAgICAgc2V0T3V0cHV0QXRDb29yZHMoY29vcmRzWzBdLCBjb29yZHNbMV0sIGNvb3Jkc1syXSwgY29vcmRzWzNdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfWA7XG4gIHJldHVybiB1c2VyQ29kZTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVDb252MkRNYXRNdWxQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLFxuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGRpbUFPdXRlcjogbnVtYmVyLFxuICBkaW1CT3V0ZXI6IG51bWJlcixcbiAgZGltSW5uZXI6IG51bWJlcixcbiAgaGFzQmlhczogYm9vbGVhbixcbiAgc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkczogYm9vbGVhbixcbiAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24/OiAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBudW1iZXJbXSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICBjb25zdCBpbkNoYW5uZWxzID0gaXNDaGFubmVsc0xhc3QgPyBpbnB1dHNbMF0uZGltc1szXSA6IGlucHV0c1swXS5kaW1zWzFdO1xuICBjb25zdCBiYXRjaFNpemUgPSBvdXRwdXRTaGFwZVswXTtcbiAgY29uc3Qgb3V0V2lkdGggPSBpc0NoYW5uZWxzTGFzdCA/IG91dHB1dFNoYXBlWzJdIDogb3V0cHV0U2hhcGVbM107XG4gIGNvbnN0IG91dEhlaWdodCA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0cHV0U2hhcGVbMV0gOiBvdXRwdXRTaGFwZVsyXTtcbiAgY29uc3Qgb3V0Q2hhbm5lbHMgPSBpc0NoYW5uZWxzTGFzdCA/IG91dHB1dFNoYXBlWzNdIDogb3V0cHV0U2hhcGVbMV07XG4gIC8vIFRPRE86IGVuYWJsZSB2ZWM0IGZvciBOQ0hXXG4gIGNvbnN0IGlzVmVjNCA9IGlzQ2hhbm5lbHNMYXN0ICYmIChpbkNoYW5uZWxzICUgNCA9PT0gMCB8fCBpbkNoYW5uZWxzICUgMyA9PT0gMCkgJiYgb3V0Q2hhbm5lbHMgJSA0ID09PSAwO1xuXG4gIC8vIFRPRE86IGZpbmUgdHVuZSBzaXplXG4gIGNvbnN0IGRpc3BhdGNoWCA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0Q2hhbm5lbHMgOiBvdXRXaWR0aCAqIG91dEhlaWdodDtcbiAgY29uc3QgZGlzcGF0Y2hZID0gaXNDaGFubmVsc0xhc3QgPyBvdXRXaWR0aCAqIG91dEhlaWdodCA6IG91dENoYW5uZWxzO1xuICBjb25zdCB3b3JrR3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbOCwgOCwgMV07XG4gIGNvbnN0IGVsZW1lbnRzUGVyVGhyZWFkID0gZGltQU91dGVyIDw9IDggPyBbNCwgMSwgMV0gOiBbNCwgNCwgMV07XG4gIGNvbnN0IGRpc3BhdGNoID0gW1xuICAgIE1hdGguY2VpbChkaXNwYXRjaFggLyB3b3JrR3JvdXBTaXplWzBdIC8gZWxlbWVudHNQZXJUaHJlYWRbMF0pLFxuICAgIE1hdGguY2VpbChkaXNwYXRjaFkgLyB3b3JrR3JvdXBTaXplWzFdIC8gZWxlbWVudHNQZXJUaHJlYWRbMV0pLFxuICAgIE1hdGguY2VpbChiYXRjaFNpemUgLyB3b3JrR3JvdXBTaXplWzJdIC8gZWxlbWVudHNQZXJUaHJlYWRbMl0pLFxuICBdO1xuXG4gIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbY29udjJkX21tX3dlYmdwdV0gZGlzcGF0Y2ggPSAke2Rpc3BhdGNofWApO1xuXG4gIGNvbnN0IGlubmVyRWxlbWVudFNpemUgPSBpc1ZlYzQgPyAoaXNDaGFubmVsc0xhc3QgJiYgaW5DaGFubmVscyAlIDQgIT09IDAgPyAzIDogNCkgOiAxO1xuICBjb25zdCB0aWxlQU91dGVyID0gd29ya0dyb3VwU2l6ZVsxXSAqIGVsZW1lbnRzUGVyVGhyZWFkWzFdO1xuICBjb25zdCB0aWxlQk91dGVyID0gd29ya0dyb3VwU2l6ZVswXSAqIGVsZW1lbnRzUGVyVGhyZWFkWzBdO1xuICBjb25zdCB0aWxlSW5uZXIgPSBNYXRoLm1heCh3b3JrR3JvdXBTaXplWzBdICogaW5uZXJFbGVtZW50U2l6ZSwgd29ya0dyb3VwU2l6ZVsxXSk7XG4gIGNvbnN0IGZpdEFPdXRlciA9IGRpbUFPdXRlciAlIHRpbGVBT3V0ZXIgPT09IDA7XG4gIGNvbnN0IGZpdEJPdXRlciA9IGRpbUJPdXRlciAlIHRpbGVCT3V0ZXIgPT09IDA7XG4gIGNvbnN0IGZpdElubmVyID0gZGltSW5uZXIgJSB0aWxlSW5uZXIgPT09IDA7XG4gIGNvbnN0IGVsZW1lbnRzU2l6ZSA9IGlzVmVjNCA/IFtpbm5lckVsZW1lbnRTaXplLCA0LCA0XSA6IFsxLCAxLCAxXTtcblxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZGltQU91dGVyIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZGltQk91dGVyIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZGltSW5uZXIgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBbYXR0cmlidXRlcy5wYWRzWzBdLCBhdHRyaWJ1dGVzLnBhZHNbMV1dIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogYXR0cmlidXRlcy5zdHJpZGVzIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogYXR0cmlidXRlcy5kaWxhdGlvbnMgfSxcbiAgXTtcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YShhdHRyaWJ1dGVzLCBwcm9ncmFtVW5pZm9ybXMpO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgaW5wdXRzWzFdLmRpbXMpKTtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3JhbmsnLCAncmFuayddO1xuICBpZiAoaGFzQmlhcykge1xuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1syXS5kaW1zKSk7XG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgncmFuaycpO1xuICB9XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnZGltX2Ffb3V0ZXInLCB0eXBlOiAnaTMyJyB9LFxuICAgICAgeyBuYW1lOiAnZGltX2Jfb3V0ZXInLCB0eXBlOiAnaTMyJyB9LFxuICAgICAgeyBuYW1lOiAnZGltX2lubmVyJywgdHlwZTogJ2kzMicgfSxcbiAgICAgIHsgbmFtZTogJ3BhZCcsIHR5cGU6ICdpMzInLCBsZW5ndGg6IDIgfSxcbiAgICAgIHsgbmFtZTogJ3N0cmlkZScsIHR5cGU6ICdpMzInLCBsZW5ndGg6IDIgfSxcbiAgICAgIHsgbmFtZTogJ2RpbGF0aW9uJywgdHlwZTogJ2kzMicsIGxlbmd0aDogMiB9LFxuICAgIF07XG4gICAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zKGF0dHJpYnV0ZXMsIHVuaWZvcm1zKTtcblxuICAgIC8vIFRPRE86IHN1cHBvcnQgY29tcG9uZW50IDIsIDMuXG4gICAgY29uc3QgY29tcG9uZW50cyA9IGlzVmVjNCA/IDQgOiAxO1xuICAgIGNvbnN0IHQgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgICBsZXQgZGVjbGFyZUZ1bmN0aW9ucyA9IGBcbiAgICAgIGZuIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4IDogaTMyLCB2YWx1ZSA6ICR7aXNWZWM0ID8gYHZlYzQ8JHt0fT5gIDogdH0pIHtcbiAgICAgICAgcmVzdWx0W2ZsYXRJbmRleF0gPSAke2lzVmVjNCA/IGB2ZWM0PCR7dH0+YCA6IHR9KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGZuIHNldE91dHB1dEF0Q29vcmRzKGQwIDogaTMyLCBkMSA6IGkzMiwgZDIgOiBpMzIsIGQzIDogaTMyLCB2YWx1ZSA6ICR7aXNWZWM0ID8gYHZlYzQ8JHt0fT5gIDogdH0pIHtcbiAgICAgICAgbGV0IGZsYXRJbmRleCA9IGdldE91dHB1dEluZGV4RnJvbUNvb3Jkcyh2ZWM0PGkzMj4oZDAsIGQxLCBkMiwgZDMpKTtcbiAgICAgICAgc2V0T3V0cHV0QXRJbmRleChmbGF0SW5kZXggJHtpc1ZlYzQgPyAnLyA0JyA6ICcnfSwgdmFsdWUpO1xuICAgICAgfWA7XG4gICAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoXG4gICAgICAneCcsXG4gICAgICBpbnB1dHNbMF0uZGF0YVR5cGUsXG4gICAgICBpbnB1dHNbMF0uZGltcy5sZW5ndGgsXG4gICAgICBpbm5lckVsZW1lbnRTaXplID09PSAzID8gMSA6IGlubmVyRWxlbWVudFNpemUsXG4gICAgKTtcbiAgICBjb25zdCB3ID0gaW5wdXRWYXJpYWJsZSgndycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFt4LCB3XTtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgncmVzdWx0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICBjb25zdCBiaWFzID0gaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICAgIGlucHV0VmFyaWFibGVzLnB1c2goYmlhcyk7XG4gICAgICBkZWNsYXJlRnVuY3Rpb25zICs9IGBcbiAgICAgICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IHZlYzQ8aTMyPikgLT4gJHtpc1ZlYzQgPyBgdmVjNDwke3R9PmAgOiB0fSB7XG4gICAgICAgICAgcmV0dXJuIGJpYXNbY29vcmRzLiR7aXNDaGFubmVsc0xhc3QgPyAndycgOiAneSd9JHtpc1ZlYzQgPyAnLyA0JyA6ICcnfV07XG4gICAgICAgIH1gO1xuICAgIH1cblxuICAgIHJldHVybiBgXG4gICAgICAgICR7dXRpbEZ1bmN0aW9ucygndW5pZm9ybXMucmVzdWx0X3N0cmlkZXMnKX1cbiAgICAgICAgLy9zdHJ1Y3QgVW5pZm9ybXMgeyB4U2hhcGUgOiB2ZWM0PGkzMj4sIHdTaGFwZSA6IHZlYzQ8aTMyPiwgb3V0U2hhcGUgOiB2ZWM0PGkzMj4sXG4gICAgICAgIC8vICBvdXRTaGFwZVN0cmlkZXM6IHZlYzM8aTMyPiwgZmlsdGVyRGltcyA6IHZlYzI8aTMyPiwgcGFkIDogdmVjMjxpMzI+LCBzdHJpZGUgOiB2ZWMyPGkzMj4sXG4gICAgICAgIC8vICBkaWxhdGlvbiA6IHZlYzI8aTMyPiwgZGltQU91dGVyIDogaTMyLCBkaW1CT3V0ZXIgOiBpMzIsIGRpbUlubmVyIDogaTMyIH07XG4gICAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJpYWJsZXMsIG91dHB1dCl9XG4gICAgICAgICR7ZGVjbGFyZUZ1bmN0aW9uc31cbiAgICAgICAgJHtjb252MmRDb21tb25TbmlwcGV0KFxuICAgICAgICAgIGlzQ2hhbm5lbHNMYXN0LFxuICAgICAgICAgIGZpdEFPdXRlcixcbiAgICAgICAgICBmaXRCT3V0ZXIsXG4gICAgICAgICAgZml0SW5uZXIsXG4gICAgICAgICAgaGFzQmlhcyxcbiAgICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgICAgIGVsZW1lbnRzU2l6ZVswXSxcbiAgICAgICAgICBlbGVtZW50c1NpemVbMV0sXG4gICAgICAgICAgZWxlbWVudHNTaXplWzJdLFxuICAgICAgICAgIHQsXG4gICAgICAgICl9XG4gICAgICAgICR7XG4gICAgICAgICAgaXNWZWM0XG4gICAgICAgICAgICA/IG1ha2VNYXRNdWxQYWNrZWRWZWM0U291cmNlKGVsZW1lbnRzUGVyVGhyZWFkLCB3b3JrR3JvdXBTaXplLCB0LCB1bmRlZmluZWQsICFpc0NoYW5uZWxzTGFzdCwgdGlsZUlubmVyKVxuICAgICAgICAgICAgOiBtYWtlTWF0TXVsUGFja2VkU291cmNlKFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzUGVyVGhyZWFkLFxuICAgICAgICAgICAgICAgIHdvcmtHcm91cFNpemUsXG4gICAgICAgICAgICAgICAgdCxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgIWlzQ2hhbm5lbHNMYXN0LFxuICAgICAgICAgICAgICAgIHRpbGVJbm5lcixcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkcyxcbiAgICAgICAgICAgICAgKVxuICAgICAgICB9YDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnQ29udjJETWF0TXVsJyxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX07JHtpbm5lckVsZW1lbnRTaXplfTske2lzVmVjNH07JHtmaXRBT3V0ZXJ9OyR7Zml0Qk91dGVyfTske2ZpdElubmVyfTske3RpbGVBT3V0ZXJ9OyR7dGlsZUJPdXRlcn07JHt0aWxlSW5uZXJ9YCxcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzLFxuICAgIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGRpbXM6IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uID8gc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24ob3V0cHV0U2hhcGUpIDogb3V0cHV0U2hhcGUsXG4gICAgICAgICAgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IGRpc3BhdGNoWzBdLCB5OiBkaXNwYXRjaFsxXSwgejogZGlzcGF0Y2hbMl0gfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuIiwgIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLy8gc2FtcGxlZCBmcm9tIFtAdGVuc29yZmxvdy90ZmpzXSB0ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9jb252M2RfbmFpdmVfd2ViZ3B1LnRzXG4vL1xuLy8gbW9kaWZpZWQgdG8gZml0IHRoZSBuZWVkcyBvZiB0aGUgcHJvamVjdFxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IExPR19ERUJVRyB9IGZyb20gJy4uLy4uLy4uL2xvZyc7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXG4gIGdldEVsZW1lbnRBdCxcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7IENvbnZBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vY29udic7XG5pbXBvcnQgeyBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMsIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEsIGdldEFjdGl2YXRpb25TbmlwcGV0IH0gZnJvbSAnLi4vZnVzZS11dGlscyc7XG5cbmltcG9ydCB7IHR5cGVTbmlwcGV0IH0gZnJvbSAnLi9hY3RpdmF0aW9uX3V0aWwnO1xuXG5jb25zdCBhcnJheVByb2R1Y3QgPSAoYXJyOiBudW1iZXJbXSkgPT4ge1xuICBsZXQgcHJvZHVjdCA9IDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJvZHVjdCAqPSBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHByb2R1Y3Q7XG59O1xuXG5jb25zdCBwYXJzZTNUdXBsZVBhcmFtID0gKHBhcmFtOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0pOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPT5cbiAgdHlwZW9mIHBhcmFtID09PSAnbnVtYmVyJyA/IFtwYXJhbSwgcGFyYW0sIHBhcmFtXSA6IHBhcmFtO1xuXG5jb25zdCBnZXRFZmZlY3RpdmVGaWx0ZXJTaXplID0gKGZpbHRlclNpemU6IG51bWJlciwgZGlsYXRpb246IG51bWJlcik6IG51bWJlciA9PiB7XG4gIGlmIChkaWxhdGlvbiA8PSAxKSB7XG4gICAgcmV0dXJuIGZpbHRlclNpemU7XG4gIH1cblxuICByZXR1cm4gZmlsdGVyU2l6ZSArIChmaWx0ZXJTaXplIC0gMSkgKiAoZGlsYXRpb24gLSAxKTtcbn07XG5cbmNvbnN0IGNvbXB1dGVEZWZhdWx0UGFkID0gKFxuICBpbnB1dFNoYXBlOiBbbnVtYmVyLCBudW1iZXJdIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gIGZpZWxkU2l6ZTogbnVtYmVyLFxuICBzdHJpZGU6IG51bWJlcixcbiAgZGlsYXRpb24gPSAxLFxuKTogbnVtYmVyID0+IHtcbiAgY29uc3QgZWZmZWN0aXZlRmllbGRTaXplID0gZ2V0RWZmZWN0aXZlRmlsdGVyU2l6ZShmaWVsZFNpemUsIGRpbGF0aW9uKTtcbiAgcmV0dXJuIE1hdGguZmxvb3IoKGlucHV0U2hhcGVbMF0gKiAoc3RyaWRlIC0gMSkgLSBzdHJpZGUgKyBlZmZlY3RpdmVGaWVsZFNpemUpIC8gMik7XG59O1xuXG5jb25zdCBjb21wdXRlT3V0cHV0U2hhcGU0RCA9IChcbiAgaW5TaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gIGZpbHRlclNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gIG91dENoYW5uZWxzOiBudW1iZXIsXG4gIHN0cmlkZXM6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgemVyb1BhZD86IG51bWJlcixcbik6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdID0+IHtcbiAgaWYgKHplcm9QYWQgPT0gbnVsbCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHplcm9QYWQgPSBjb21wdXRlRGVmYXVsdFBhZChpblNoYXBlLCBmaWx0ZXJTaGFwZVswXSwgc3RyaWRlc1swXSk7XG4gIH1cbiAgY29uc3Qgb3V0U2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzAsIDAsIDAsIG91dENoYW5uZWxzXTtcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IDM7IGluZGV4KyspIHtcbiAgICBpZiAoaW5TaGFwZVtpbmRleF0gKyAyICogemVyb1BhZCA+PSBmaWx0ZXJTaGFwZVtpbmRleF0pIHtcbiAgICAgIG91dFNoYXBlW2luZGV4XSA9IE1hdGgudHJ1bmMoKGluU2hhcGVbaW5kZXhdIC0gZmlsdGVyU2hhcGVbaW5kZXhdICsgMiAqIHplcm9QYWQpIC8gc3RyaWRlc1tpbmRleF0gKyAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dFNoYXBlO1xufTtcblxuY29uc3QgZ2V0M0RQYWRBbmRPdXRJbmZvID0gKFxuICBwYWQ6IG51bWJlciB8IHN0cmluZyB8IG51bWJlcltdLFxuICBpbkRlcHRoOiBudW1iZXIsXG4gIGluSGVpZ2h0OiBudW1iZXIsXG4gIGluV2lkdGg6IG51bWJlcixcbiAgc3RyaWRlRGVwdGg6IG51bWJlcixcbiAgc3RyaWRlSGVpZ2h0OiBudW1iZXIsXG4gIHN0cmlkZVdpZHRoOiBudW1iZXIsXG4gIGZpbHRlckRlcHRoOiBudW1iZXIsXG4gIGZpbHRlckhlaWdodDogbnVtYmVyLFxuICBmaWx0ZXJXaWR0aDogbnVtYmVyLFxuKTogeyBwYWRJbmZvOiBQYWRJbmZvM0Q7IG91dERlcHRoOiBudW1iZXI7IG91dEhlaWdodDogbnVtYmVyOyBvdXRXaWR0aDogbnVtYmVyIH0gPT4ge1xuICBsZXQgcGFkSW5mbzogUGFkSW5mbzNEO1xuICBsZXQgb3V0RGVwdGg6IG51bWJlcjtcbiAgbGV0IG91dEhlaWdodDogbnVtYmVyO1xuICBsZXQgb3V0V2lkdGg6IG51bWJlcjtcblxuICBpZiAocGFkID09PSAnVkFMSUQnKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgcGFkID0gMDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGFkID09PSAnbnVtYmVyJykge1xuICAgIHBhZEluZm8gPSB7IHRvcDogcGFkLCBib3R0b206IHBhZCwgbGVmdDogcGFkLCByaWdodDogcGFkLCBmcm9udDogcGFkLCBiYWNrOiBwYWQgfTtcbiAgICBjb25zdCBvdXRTaGFwZSA9IGNvbXB1dGVPdXRwdXRTaGFwZTREKFxuICAgICAgW2luRGVwdGgsIGluSGVpZ2h0LCBpbldpZHRoLCAxXSxcbiAgICAgIFtmaWx0ZXJEZXB0aCwgZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aF0sXG4gICAgICAxLFxuICAgICAgW3N0cmlkZURlcHRoLCBzdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoXSxcbiAgICAgIHBhZCxcbiAgICApO1xuICAgIG91dERlcHRoID0gb3V0U2hhcGVbMF07XG4gICAgb3V0SGVpZ2h0ID0gb3V0U2hhcGVbMV07XG4gICAgb3V0V2lkdGggPSBvdXRTaGFwZVsyXTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhZCkpIHtcbiAgICBpZiAoIXBhZC5ldmVyeSgodmFsLCBfLCBhcnIpID0+IHZhbCA9PT0gYXJyWzBdKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYFVuc3VwcG9ydGVkIHBhZGRpbmcgcGFyYW1ldGVyOiAke3BhZH1gKTtcbiAgICB9XG4gICAgcGFkSW5mbyA9IHsgdG9wOiBwYWRbMF0sIGJvdHRvbTogcGFkWzFdLCBsZWZ0OiBwYWRbMl0sIHJpZ2h0OiBwYWRbM10sIGZyb250OiBwYWRbNF0sIGJhY2s6IHBhZFs1XSB9O1xuICAgIGNvbnN0IG91dFNoYXBlID0gY29tcHV0ZU91dHB1dFNoYXBlNEQoXG4gICAgICBbaW5EZXB0aCwgaW5IZWlnaHQsIGluV2lkdGgsIDFdLFxuICAgICAgW2ZpbHRlckRlcHRoLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoXSxcbiAgICAgIDEsXG4gICAgICBbc3RyaWRlRGVwdGgsIHN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGhdLFxuICAgICAgcGFkWzBdLFxuICAgICk7XG4gICAgb3V0RGVwdGggPSBvdXRTaGFwZVswXTtcbiAgICBvdXRIZWlnaHQgPSBvdXRTaGFwZVsxXTtcbiAgICBvdXRXaWR0aCA9IG91dFNoYXBlWzJdO1xuICB9IGVsc2UgaWYgKHBhZCA9PT0gJ1NBTUVfVVBQRVInKSB7XG4gICAgLy8gVE9ETzogc3VwcG9ydCAnU0FNRV9MT1dFUicuXG4gICAgb3V0RGVwdGggPSBNYXRoLmNlaWwoaW5EZXB0aCAvIHN0cmlkZURlcHRoKTtcbiAgICBvdXRIZWlnaHQgPSBNYXRoLmNlaWwoaW5IZWlnaHQgLyBzdHJpZGVIZWlnaHQpO1xuICAgIG91dFdpZHRoID0gTWF0aC5jZWlsKGluV2lkdGggLyBzdHJpZGVXaWR0aCk7XG4gICAgY29uc3QgcGFkQWxvbmdEZXB0aCA9IChvdXREZXB0aCAtIDEpICogc3RyaWRlRGVwdGggKyBmaWx0ZXJEZXB0aCAtIGluRGVwdGg7XG4gICAgY29uc3QgcGFkQWxvbmdIZWlnaHQgPSAob3V0SGVpZ2h0IC0gMSkgKiBzdHJpZGVIZWlnaHQgKyBmaWx0ZXJIZWlnaHQgLSBpbkhlaWdodDtcbiAgICBjb25zdCBwYWRBbG9uZ1dpZHRoID0gKG91dFdpZHRoIC0gMSkgKiBzdHJpZGVXaWR0aCArIGZpbHRlcldpZHRoIC0gaW5XaWR0aDtcbiAgICBjb25zdCBmcm9udCA9IE1hdGguZmxvb3IocGFkQWxvbmdEZXB0aCAvIDIpO1xuICAgIGNvbnN0IGJhY2sgPSBwYWRBbG9uZ0RlcHRoIC0gZnJvbnQ7XG4gICAgY29uc3QgdG9wID0gTWF0aC5mbG9vcihwYWRBbG9uZ0hlaWdodCAvIDIpO1xuICAgIGNvbnN0IGJvdHRvbSA9IHBhZEFsb25nSGVpZ2h0IC0gdG9wO1xuICAgIGNvbnN0IGxlZnQgPSBNYXRoLmZsb29yKHBhZEFsb25nV2lkdGggLyAyKTtcbiAgICBjb25zdCByaWdodCA9IHBhZEFsb25nV2lkdGggLSBsZWZ0O1xuXG4gICAgcGFkSW5mbyA9IHsgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0LCBmcm9udCwgYmFjayB9O1xuICB9IGVsc2Uge1xuICAgIHRocm93IEVycm9yKGBVbmtub3duIHBhZGRpbmcgcGFyYW1ldGVyOiAke3BhZH1gKTtcbiAgfVxuICByZXR1cm4geyBwYWRJbmZvLCBvdXREZXB0aCwgb3V0SGVpZ2h0LCBvdXRXaWR0aCB9O1xufTtcblxudHlwZSBQYWRJbmZvM0QgPSB7XG4gIHRvcDogbnVtYmVyO1xuICBsZWZ0OiBudW1iZXI7XG4gIHJpZ2h0OiBudW1iZXI7XG4gIGJvdHRvbTogbnVtYmVyO1xuICBmcm9udDogbnVtYmVyO1xuICBiYWNrOiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBDb252M0RJbmZvID0ge1xuICBiYXRjaFNpemU6IG51bWJlcjtcbiAgaW5EZXB0aDogbnVtYmVyO1xuICBpbkhlaWdodDogbnVtYmVyO1xuICBpbldpZHRoOiBudW1iZXI7XG4gIGluQ2hhbm5lbHM6IG51bWJlcjtcbiAgb3V0RGVwdGg6IG51bWJlcjtcbiAgb3V0SGVpZ2h0OiBudW1iZXI7XG4gIG91dFdpZHRoOiBudW1iZXI7XG4gIG91dENoYW5uZWxzOiBudW1iZXI7XG4gIGRhdGFGb3JtYXQ6ICdjaGFubmVsc0ZpcnN0JyB8ICdjaGFubmVsc0xhc3QnO1xuICBzdHJpZGVEZXB0aDogbnVtYmVyO1xuICBzdHJpZGVIZWlnaHQ6IG51bWJlcjtcbiAgc3RyaWRlV2lkdGg6IG51bWJlcjtcbiAgZGlsYXRpb25EZXB0aDogbnVtYmVyO1xuICBkaWxhdGlvbkhlaWdodDogbnVtYmVyO1xuICBkaWxhdGlvbldpZHRoOiBudW1iZXI7XG4gIGZpbHRlckRlcHRoOiBudW1iZXI7XG4gIGZpbHRlckhlaWdodDogbnVtYmVyO1xuICBmaWx0ZXJXaWR0aDogbnVtYmVyO1xuICBlZmZlY3RpdmVGaWx0ZXJEZXB0aDogbnVtYmVyO1xuICBlZmZlY3RpdmVGaWx0ZXJIZWlnaHQ6IG51bWJlcjtcbiAgZWZmZWN0aXZlRmlsdGVyV2lkdGg6IG51bWJlcjtcbiAgcGFkSW5mbzogUGFkSW5mbzNEO1xuICBpblNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICBvdXRTaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgZmlsdGVyU2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG59O1xuXG5leHBvcnQgY29uc3QgY29tcHV0ZUNvbnYzREluZm8gPSAoXG4gIGluU2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gIGZpbHRlclNoYXBlOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICBzdHJpZGVzOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gIGRpbGF0aW9uczogbnVtYmVyIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICBwYWQ6IG51bWJlciB8IHN0cmluZyB8IG51bWJlcltdLFxuICBkZXB0aHdpc2UgPSBmYWxzZSxcbiAgZGF0YUZvcm1hdDogJ2NoYW5uZWxzRmlyc3QnIHwgJ2NoYW5uZWxzTGFzdCcgPSAnY2hhbm5lbHNMYXN0Jyxcbik6IENvbnYzREluZm8gPT4ge1xuICBsZXQgYmF0Y2hTaXplLCBpbkRlcHRoLCBpbkhlaWdodCwgaW5XaWR0aCwgaW5DaGFubmVscztcbiAgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnKSB7XG4gICAgW2JhdGNoU2l6ZSwgaW5EZXB0aCwgaW5IZWlnaHQsIGluV2lkdGgsIGluQ2hhbm5lbHNdID0gaW5TaGFwZTtcbiAgfSBlbHNlIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICBbYmF0Y2hTaXplLCBpbkNoYW5uZWxzLCBpbkRlcHRoLCBpbkhlaWdodCwgaW5XaWR0aF0gPSBpblNoYXBlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhRm9ybWF0ICR7ZGF0YUZvcm1hdH1gKTtcbiAgfVxuICBjb25zdCBbZmlsdGVyQ2hhbm5lbHMsICwgZmlsdGVyRGVwdGgsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGhdID0gZmlsdGVyU2hhcGU7XG5cbiAgY29uc3QgW3N0cmlkZURlcHRoLCBzdHJpZGVIZWlnaHQsIHN0cmlkZVdpZHRoXSA9IHBhcnNlM1R1cGxlUGFyYW0oc3RyaWRlcyk7XG4gIGNvbnN0IFtkaWxhdGlvbkRlcHRoLCBkaWxhdGlvbkhlaWdodCwgZGlsYXRpb25XaWR0aF0gPSBwYXJzZTNUdXBsZVBhcmFtKGRpbGF0aW9ucyk7XG5cbiAgY29uc3QgZWZmZWN0aXZlRmlsdGVyRGVwdGggPSBnZXRFZmZlY3RpdmVGaWx0ZXJTaXplKGZpbHRlckRlcHRoLCBkaWxhdGlvbkRlcHRoKTtcbiAgY29uc3QgZWZmZWN0aXZlRmlsdGVySGVpZ2h0ID0gZ2V0RWZmZWN0aXZlRmlsdGVyU2l6ZShmaWx0ZXJIZWlnaHQsIGRpbGF0aW9uSGVpZ2h0KTtcbiAgY29uc3QgZWZmZWN0aXZlRmlsdGVyV2lkdGggPSBnZXRFZmZlY3RpdmVGaWx0ZXJTaXplKGZpbHRlcldpZHRoLCBkaWxhdGlvbldpZHRoKTtcbiAgY29uc3QgeyBwYWRJbmZvLCBvdXREZXB0aCwgb3V0SGVpZ2h0LCBvdXRXaWR0aCB9ID0gZ2V0M0RQYWRBbmRPdXRJbmZvKFxuICAgIHBhZCxcbiAgICBpbkRlcHRoLFxuICAgIGluSGVpZ2h0LFxuICAgIGluV2lkdGgsXG4gICAgc3RyaWRlRGVwdGgsXG4gICAgc3RyaWRlSGVpZ2h0LFxuICAgIHN0cmlkZVdpZHRoLFxuICAgIGVmZmVjdGl2ZUZpbHRlckRlcHRoLFxuICAgIGVmZmVjdGl2ZUZpbHRlckhlaWdodCxcbiAgICBlZmZlY3RpdmVGaWx0ZXJXaWR0aCxcbiAgKTtcblxuICBjb25zdCBvdXRDaGFubmVscyA9IGRlcHRod2lzZSA/IGZpbHRlckNoYW5uZWxzICogaW5DaGFubmVscyA6IGZpbHRlckNoYW5uZWxzO1xuXG4gIGxldCBvdXRTaGFwZTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFswLCAwLCAwLCAwLCAwXTtcbiAgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgIG91dFNoYXBlID0gW2JhdGNoU2l6ZSwgb3V0Q2hhbm5lbHMsIG91dERlcHRoLCBvdXRIZWlnaHQsIG91dFdpZHRoXTtcbiAgfSBlbHNlIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0Jykge1xuICAgIG91dFNoYXBlID0gW2JhdGNoU2l6ZSwgb3V0RGVwdGgsIG91dEhlaWdodCwgb3V0V2lkdGgsIG91dENoYW5uZWxzXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmF0Y2hTaXplLFxuICAgIGRhdGFGb3JtYXQsXG4gICAgaW5EZXB0aCxcbiAgICBpbkhlaWdodCxcbiAgICBpbldpZHRoLFxuICAgIGluQ2hhbm5lbHMsXG4gICAgb3V0RGVwdGgsXG4gICAgb3V0SGVpZ2h0LFxuICAgIG91dFdpZHRoLFxuICAgIG91dENoYW5uZWxzLFxuICAgIHBhZEluZm8sXG4gICAgc3RyaWRlRGVwdGgsXG4gICAgc3RyaWRlSGVpZ2h0LFxuICAgIHN0cmlkZVdpZHRoLFxuICAgIGZpbHRlckRlcHRoLFxuICAgIGZpbHRlckhlaWdodCxcbiAgICBmaWx0ZXJXaWR0aCxcbiAgICBlZmZlY3RpdmVGaWx0ZXJEZXB0aCxcbiAgICBlZmZlY3RpdmVGaWx0ZXJIZWlnaHQsXG4gICAgZWZmZWN0aXZlRmlsdGVyV2lkdGgsXG4gICAgZGlsYXRpb25EZXB0aCxcbiAgICBkaWxhdGlvbkhlaWdodCxcbiAgICBkaWxhdGlvbldpZHRoLFxuICAgIGluU2hhcGUsXG4gICAgb3V0U2hhcGUsXG4gICAgZmlsdGVyU2hhcGUsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlQ29udjNETmFpdmVQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLFxuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGZpbHRlckRpbXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICBwYWRzOiByZWFkb25seSBudW1iZXJbXSxcbiAgZGF0YUZvcm1hdDogc3RyaW5nLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBpc0NoYW5uZWxMYXN0ID0gZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCc7XG4gIGNvbnN0IGluQ2hhbm5lbHMgPSBpc0NoYW5uZWxMYXN0ID8gaW5wdXRzWzBdLmRpbXNbM10gOiBpbnB1dHNbMF0uZGltc1sxXTtcbiAgLy8gVE9ETzogZW5hYmxlIHZlYzQuXG4gIGNvbnN0IGlzVmVjNCA9IGZhbHNlO1xuICBjb25zdCB3b3JrR3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbNjQsIDEsIDFdO1xuICBjb25zdCBkaXNwYXRjaExheW91dCA9IHsgeDogb3V0cHV0U2hhcGUubWFwKChfLCBpKSA9PiBpKSB9O1xuICBjb25zdCBkaXNwYXRjaCA9IFtNYXRoLmNlaWwoYXJyYXlQcm9kdWN0KGRpc3BhdGNoTGF5b3V0LngubWFwKChkKSA9PiBvdXRwdXRTaGFwZVtkXSkpIC8gd29ya0dyb3VwU2l6ZVswXSksIDEsIDFdO1xuXG4gIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbY29udjNkX25haXZlX3dlYmdwdV0gZGlzcGF0Y2ggPSAke2Rpc3BhdGNofWApO1xuXG4gIGNvbnN0IGlubmVyRWxlbWVudFNpemUgPSBpc1ZlYzQgPyAoaXNDaGFubmVsTGFzdCAmJiBpbkNoYW5uZWxzICUgNCAhPT0gMCA/IDMgOiA0KSA6IDE7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBmaWx0ZXJEaW1zIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhZHMgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXR0cmlidXRlcy5zdHJpZGVzIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuZGlsYXRpb25zIH0sXG4gIF07XG4gIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEoYXR0cmlidXRlcywgcHJvZ3JhbVVuaWZvcm1zKTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zKSk7XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWydyYW5rJywgJ3JhbmsnXTtcbiAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPT09IDM7XG4gIGlmIChoYXNCaWFzKSB7XG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzJdLmRpbXMpKTtcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCdyYW5rJyk7XG4gIH1cbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpKTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdmaWx0ZXJfZGltcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGZpbHRlckRpbXMubGVuZ3RoIH0sXG4gICAgICB7IG5hbWU6ICdwYWRzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogcGFkcy5sZW5ndGggfSxcbiAgICAgIHsgbmFtZTogJ3N0cmlkZXMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBhdHRyaWJ1dGVzLnN0cmlkZXMubGVuZ3RoIH0sXG4gICAgICB7IG5hbWU6ICdkaWxhdGlvbnMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBhdHRyaWJ1dGVzLmRpbGF0aW9ucy5sZW5ndGggfSxcbiAgICBdO1xuICAgIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyhhdHRyaWJ1dGVzLCB1bmlmb3Jtcyk7XG4gICAgLy8gVE9ETzogc3VwcG9ydCBjb21wb25lbnQgMiwgMy5cbiAgICBjb25zdCBjb21wb25lbnRzID0gaXNWZWM0ID8gNCA6IDE7XG4gICAgY29uc3QgdCA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xuXG4gICAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoXG4gICAgICAneCcsXG4gICAgICBpbnB1dHNbMF0uZGF0YVR5cGUsXG4gICAgICBpbnB1dHNbMF0uZGltcy5sZW5ndGgsXG4gICAgICBpbm5lckVsZW1lbnRTaXplID09PSAzID8gMSA6IGlubmVyRWxlbWVudFNpemUsXG4gICAgKTtcbiAgICBjb25zdCB3ID0gaW5wdXRWYXJpYWJsZSgnVycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFt4LCB3XTtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgncmVzdWx0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGxldCBkZWNsYXJlRnVuY3Rpb25zID0gJyc7XG4gICAgaWYgKGhhc0JpYXMpIHtcbiAgICAgIGNvbnN0IGJpYXMgPSBpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcy5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgICAgaW5wdXRWYXJpYWJsZXMucHVzaChiaWFzKTtcbiAgICAgIGRlY2xhcmVGdW5jdGlvbnMgKz0gYFxuICAgICAgICBmbiBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzIDogYXJyYXk8dTMyLCA1PikgLT4gJHtpc1ZlYzQgPyBgdmVjNDwke3R9PmAgOiB0fSB7XG4gICAgICAgICAgcmV0dXJuIGJpYXNbJHtpc0NoYW5uZWxMYXN0ID8gZ2V0RWxlbWVudEF0KCdjb29yZHMnLCA0LCA1KSA6IGdldEVsZW1lbnRBdCgnY29vcmRzJywgMSwgNSl9JHtcbiAgICAgICAgICAgIGlzVmVjNCA/ICcvIDQnIDogJydcbiAgICAgICAgICB9XTtcbiAgICAgICAgfWA7XG4gICAgfVxuICAgIGNvbnN0IHJlc1R5cGUgPSB0eXBlU25pcHBldChpbm5lckVsZW1lbnRTaXplLCB0KTtcbiAgICBjb25zdCBhcHBseUFjdGl2YXRpb24gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhdHRyaWJ1dGVzLCByZXNUeXBlLCB0KTtcblxuICAgIHJldHVybiBgXG4gICAgICAgICAgICAke2RlY2xhcmVGdW5jdGlvbnN9XG4gICAgICAgICAgICBmbiBnZXRYKGQwIDogdTMyLCBkMSA6IHUzMiwgZDIgOiB1MzIsIGQzIDogdTMyLCBkNCA6IHUzMikgLT4gZjMyIHtcbiAgICAgICAgICAgICAgbGV0IGFJbmRpY2VzID0gYXJyYXk8dTMyLCA1PihkMCwgZDEsIGQyLCBkMywgZDQpO1xuICAgICAgICAgICAgICByZXR1cm4gJHt4LmdldEJ5SW5kaWNlcygnYUluZGljZXMnKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbiBnZXRXKGQwIDogdTMyLCBkMSA6IHUzMiwgZDIgOiB1MzIsIGQzIDogdTMyLCBkNCA6IHUzMikgLT4gZjMyIHtcbiAgICAgICAgICAgICAgbGV0IGFJbmRpY2VzID0gYXJyYXk8dTMyLCA1PihkMCwgZDEsIGQyLCBkMywgZDQpO1xuICAgICAgICAgICAgICByZXR1cm4gJHt3LmdldEJ5SW5kaWNlcygnYUluZGljZXMnKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcmlhYmxlcywgb3V0cHV0KX1cbiAgICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICAgICAgICAgICAgICBsZXQgY29vcmRzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgICAgICAgICAgICBsZXQgYmF0Y2ggPSAke2dldEVsZW1lbnRBdCgnY29vcmRzJywgMCwgeC5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCBkMiA9ICR7XG4gICAgICAgICAgICAgICAgaXNDaGFubmVsTGFzdCA/IGdldEVsZW1lbnRBdCgnY29vcmRzJywgeC5yYW5rIC0gMSwgeC5yYW5rKSA6IGdldEVsZW1lbnRBdCgnY29vcmRzJywgMSwgeC5yYW5rKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBsZXQgeEZSQ0Nvcm5lciA9IHZlYzM8dTMyPigke1xuICAgICAgICAgICAgICAgIGlzQ2hhbm5lbExhc3QgPyBnZXRFbGVtZW50QXQoJ2Nvb3JkcycsIDEsIHgucmFuaykgOiBnZXRFbGVtZW50QXQoJ2Nvb3JkcycsIDIsIHgucmFuaylcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgJHtpc0NoYW5uZWxMYXN0ID8gZ2V0RWxlbWVudEF0KCdjb29yZHMnLCAyLCB4LnJhbmspIDogZ2V0RWxlbWVudEF0KCdjb29yZHMnLCAzLCB4LnJhbmspfSxcbiAgICAgICAgICAgICAgJHtcbiAgICAgICAgICAgICAgICBpc0NoYW5uZWxMYXN0ID8gZ2V0RWxlbWVudEF0KCdjb29yZHMnLCAzLCB4LnJhbmspIDogZ2V0RWxlbWVudEF0KCdjb29yZHMnLCA0LCB4LnJhbmspXG4gICAgICAgICAgICAgIH0pICogdW5pZm9ybXMuc3RyaWRlcyAtIHVuaWZvcm1zLnBhZHM7XG4gICAgICAgICAgICAgIGxldCB4RkNvcm5lciA9IHhGUkNDb3JuZXIueDtcbiAgICAgICAgICAgICAgbGV0IHhSQ29ybmVyID0geEZSQ0Nvcm5lci55O1xuICAgICAgICAgICAgICBsZXQgeENDb3JuZXIgPSB4RlJDQ29ybmVyLno7XG4gICAgICAgICAgICAgIGxldCB4U2hhcGVZID0gJHtcbiAgICAgICAgICAgICAgICBpc0NoYW5uZWxMYXN0XG4gICAgICAgICAgICAgICAgICA/IGdldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIDEsIHgucmFuaylcbiAgICAgICAgICAgICAgICAgIDogZ2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgMiwgeC5yYW5rKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBsZXQgeFNoYXBlWiA9ICR7XG4gICAgICAgICAgICAgICAgaXNDaGFubmVsTGFzdFxuICAgICAgICAgICAgICAgICAgPyBnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCAyLCB4LnJhbmspXG4gICAgICAgICAgICAgICAgICA6IGdldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIDMsIHgucmFuaylcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgbGV0IHhTaGFwZVcgPSAke1xuICAgICAgICAgICAgICAgIGlzQ2hhbm5lbExhc3RcbiAgICAgICAgICAgICAgICAgID8gZ2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgMywgeC5yYW5rKVxuICAgICAgICAgICAgICAgICAgOiBnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCA0LCB4LnJhbmspXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGxldCB4U2hhcGVVID0gJHtcbiAgICAgICAgICAgICAgICBpc0NoYW5uZWxMYXN0XG4gICAgICAgICAgICAgICAgICA/IGdldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIDQsIHgucmFuaylcbiAgICAgICAgICAgICAgICAgIDogZ2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgMSwgeC5yYW5rKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBsZXQgaW5wdXREZXB0aE5lYXJlc3RWZWM0ID0gKHhTaGFwZVUgLyA0KSAqIDQ7XG4gICAgICAgICAgICAgIGxldCBpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9IHhTaGFwZVUgJSA0O1xuXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IDAuMDtcbiAgICAgICAgICAgICAgZm9yICh2YXIgd0YgPSAwdTsgd0YgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1swXTsgd0YrKykge1xuICAgICAgICAgICAgICAgIGxldCB4RiA9IHhGQ29ybmVyICsgd0YgKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMF07XG4gICAgICAgICAgICAgICAgaWYgKHhGIDwgMCB8fCB4RiA+PSB4U2hhcGVZKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciB3UiA9IDB1OyB3UiA8IHVuaWZvcm1zLmZpbHRlcl9kaW1zWzFdOyB3UisrKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgeFIgPSB4UkNvcm5lciArIHdSICogdW5pZm9ybXMuZGlsYXRpb25zWzFdO1xuICAgICAgICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSB4U2hhcGVaKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciB3QyA9IDB1OyB3QyA8IHVuaWZvcm1zLmZpbHRlcl9kaW1zWzJdOyB3QysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB4QyA9IHhDQ29ybmVyICsgd0MgKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMl07XG4gICAgICAgICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0geFNoYXBlVykge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZDEgPSAwdTsgZDEgPCBpbnB1dERlcHRoTmVhcmVzdFZlYzQ7IGQxICs9IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAke1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNDaGFubmVsTGFzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IGBsZXQgeFZhbHVlcyA9IHZlYzQ8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBgbGV0IHhWYWx1ZXMgPSB2ZWM0PGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMSwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEgKyAyLCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSArIDMsIHhGLCB4UiwgeEMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3VmFsdWVzID0gdmVjNDxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgZDEsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgZDEgKyAxLCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGQxICsgMiwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBkMSArIDMsIHdGLCB3Uiwgd0MpKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ2hhbm5lbExhc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGB2YWx1ZSArPSBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICogZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB3Riwgd1IsIHdDKTtgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBgdmFsdWUgKz0gZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB4RiwgeFIsIHhDKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAqIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgd0YsIHdSLCB3Qyk7YFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAke1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNDaGFubmVsTGFzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IGBsZXQgeFZhbHVlcyA9IHZlYzI8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IGBsZXQgeFZhbHVlcyA9IHZlYzI8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxLCB4RiwgeFIsIHhDKSk7XG4gICAgICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCB3VmFsdWVzID0gdmVjMjxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSwgd0YsIHdSLCB3QykpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ2hhbm5lbExhc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgbGV0IHhWYWx1ZXMgPSB2ZWMzPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICAgICAgICA6IGBsZXQgeFZhbHVlcyA9IHZlYzM8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxLCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDIsIHhGLCB4UiwgeEMpKTtcbiAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHdWYWx1ZXMgPSB2ZWMzPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxLCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAyLCB3Riwgd1IsIHdDKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICR7aGFzQmlhcyA/ICd2YWx1ZSA9IHZhbHVlICsgZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyknIDogJyd9O1xuICAgICAgICAgICAgICAke2FwcGx5QWN0aXZhdGlvbn1cbiAgICAgICAgICAgICAgcmVzdWx0W2dsb2JhbF9pZHhdID0gZjMyKHZhbHVlKTtcbiAgICAgICAgICB9YDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnQ29udjNETmFpdmUnLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9OyR7aXNDaGFubmVsTGFzdH07JHtpbm5lckVsZW1lbnRTaXplfTske2hhc0JpYXN9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IGRpc3BhdGNoWzBdLCB5OiBkaXNwYXRjaFsxXSwgejogZGlzcGF0Y2hbMl0gfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBnZXRNYXhDb21wb25lbnRzLFxuICBpbnB1dFZhcmlhYmxlLFxuICBvdXRwdXRWYXJpYWJsZSxcbiAgU2hhZGVySGVscGVyLFxuICB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxufSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQgeyBDb252QXR0cmlidXRlcyB9IGZyb20gJy4vY29udic7XG5pbXBvcnQgeyBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMsIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3Jtc0RhdGEsIGdldEFjdGl2YXRpb25TbmlwcGV0IH0gZnJvbSAnLi9mdXNlLXV0aWxzJztcblxuLyoqXG4gKiBuYWl2ZSBncm91cGVkIGNvbnYgaW1wbGVtZW50YXRpb24sIHN1cHBvcnRzIDFkLzJkIGNvbnZcbiAqIEBwYXJhbSBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbiAtIGFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIHNxdWVlemUgdGhlIG91dHB1dCBzaGFwZSwgb25seSB1c2VkIGluIGNvbnYxZFxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlR3JvdXBlZENvbnZQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IENvbnZBdHRyaWJ1dGVzLFxuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uPzogKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSkgPT4gbnVtYmVyW10sXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGhhc0JpYXMgPSBpbnB1dHMubGVuZ3RoID4gMjtcbiAgY29uc3QgcHJvY2Vzc0JpYXMgPSBoYXNCaWFzID8gJ3ZhbHVlICs9IGJbb3V0cHV0X2NoYW5uZWxdOycgOiAnJztcbiAgY29uc3QgeFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IHdTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuXG4gIGNvbnN0IGlzQ2hhbm5lbExhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICBjb25zdCBvdXRwdXRDaGFubmVscyA9IGlzQ2hhbm5lbExhc3QgPyBvdXRwdXRTaGFwZVszXSA6IG91dHB1dFNoYXBlWzFdO1xuICBjb25zdCBvdXRwdXRDaGFubmVsc1Blckdyb3VwID0gb3V0cHV0Q2hhbm5lbHMgLyBhdHRyaWJ1dGVzLmdyb3VwO1xuICBjb25zdCBjb21wb25lbnRzID0gaXNDaGFubmVsTGFzdCAmJiBvdXRwdXRDaGFubmVsc1Blckdyb3VwID49IDQgPyBnZXRNYXhDb21wb25lbnRzKG91dHB1dENoYW5uZWxzKSA6IDE7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyBjb21wb25lbnRzO1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBhdHRyaWJ1dGVzLmRpbGF0aW9ucyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBbYXR0cmlidXRlcy5zdHJpZGVzWzBdLCBhdHRyaWJ1dGVzLnN0cmlkZXNbMV1dIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IFthdHRyaWJ1dGVzLnBhZHNbMF0sIGF0dHJpYnV0ZXMucGFkc1sxXV0gfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0Q2hhbm5lbHNQZXJHcm91cCB9LFxuICBdO1xuICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhKGF0dHJpYnV0ZXMsIHByb2dyYW1Vbmlmb3Jtcyk7XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKFxuICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKHhTaGFwZSwgW3dTaGFwZVswXSwgd1NoYXBlWzFdLCB3U2hhcGVbMl0sIHdTaGFwZVszXSAvIGNvbXBvbmVudHNdKSxcbiAgKTtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBoYXNCaWFzID8gWydyYW5rJywgJ3JhbmsnLCAncmFuayddIDogWydyYW5rJywgJ3JhbmsnXTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoW291dHB1dFNoYXBlWzBdLCBvdXRwdXRTaGFwZVsxXSwgb3V0cHV0U2hhcGVbMl0sIG91dHB1dFNoYXBlWzNdIC8gY29tcG9uZW50c10pLFxuICApO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3QgYmFzZVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUob3V0cHV0LnR5cGUudGVuc29yKTtcbiAgICBjb25zdCBhcHBseUFjdGl2YXRpb24gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhdHRyaWJ1dGVzLCBvdXRwdXQudHlwZS52YWx1ZSwgYmFzZVR5cGUpO1xuICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCB4U2hhcGUubGVuZ3RoKTtcbiAgICBjb25zdCB3ID0gaW5wdXRWYXJpYWJsZSgndycsIGlucHV0c1sxXS5kYXRhVHlwZSwgd1NoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3QgaW5wdXRWYXJzID0gW3gsIHddO1xuICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICBpbnB1dFZhcnMucHVzaChpbnB1dFZhcmlhYmxlKCdiJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcywgY29tcG9uZW50cykpO1xuICAgIH1cblxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgIHsgbmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2RpbGF0aW9ucycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGF0dHJpYnV0ZXMuZGlsYXRpb25zLmxlbmd0aCB9LFxuICAgICAgeyBuYW1lOiAnc3RyaWRlcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IDIgfSxcbiAgICAgIHsgbmFtZTogJ3BhZHMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiAyIH0sXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwJywgdHlwZTogJ3UzMicgfSxcbiAgICBdO1xuICAgIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyhhdHRyaWJ1dGVzLCB1bmlmb3Jtcyk7XG5cbiAgICBjb25zdCBjYWxjdWxhdGVSZXN1bHQgPSBpc0NoYW5uZWxMYXN0XG4gICAgICA/IGBcbiAgICAgIGZvciAodmFyIHdIZWlnaHQ6IHUzMiA9IDB1OyB3SGVpZ2h0IDwgdW5pZm9ybXMud19zaGFwZVswXTsgd0hlaWdodCsrKSB7XG4gICAgICAgIGxldCB4SGVpZ2h0ID0geFJDQ29ybmVyLnggKyB3SGVpZ2h0ICogdW5pZm9ybXMuZGlsYXRpb25zWzBdO1xuXG4gICAgICAgIGlmICh4SGVpZ2h0IDwgMHUgfHwgeEhlaWdodCA+PSB1bmlmb3Jtcy54X3NoYXBlWzFdKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciB3V2lkdGg6IHUzMiA9IDB1OyB3V2lkdGggPCB1bmlmb3Jtcy53X3NoYXBlWzFdOyB3V2lkdGgrKykge1xuICAgICAgICAgIGxldCB4V2lkdGggPSB4UkNDb3JuZXIueSArIHdXaWR0aCAqIHVuaWZvcm1zLmRpbGF0aW9uc1sxXTtcbiAgICAgICAgICBpZiAoeFdpZHRoIDwgMHUgfHwgeFdpZHRoID49IHVuaWZvcm1zLnhfc2hhcGVbMl0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIHdJbkNoYW5uZWw6IHUzMiA9IDB1OyB3SW5DaGFubmVsIDwgdW5pZm9ybXMud19zaGFwZVsyXTsgd0luQ2hhbm5lbCsrKSB7XG4gICAgICAgICAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IGluX2NoYW5uZWxfb2Zmc2V0ICsgd0luQ2hhbm5lbDtcbiAgICAgICAgICAgIGxldCB4VmFsID0gJHt4LmdldCgnYmF0Y2gnLCAneEhlaWdodCcsICd4V2lkdGgnLCAnaW5wdXRfY2hhbm5lbCcpfTtcbiAgICAgICAgICAgIGxldCB3VmFsID0gJHt3LmdldCgnd0hlaWdodCcsICd3V2lkdGgnLCAnd0luQ2hhbm5lbCcsICdvdXRwdXRfY2hhbm5lbCcpfTtcbiAgICAgICAgICAgIHZhbHVlICs9IHhWYWwgKiB3VmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYFxuICAgICAgOiBgXG4gICAgICBmb3IgKHZhciB3SW5DaGFubmVsOiB1MzIgPSAwdTsgd0luQ2hhbm5lbCA8IHVuaWZvcm1zLndfc2hhcGVbMV07IHdJbkNoYW5uZWwrKykge1xuICAgICAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IGluX2NoYW5uZWxfb2Zmc2V0ICsgd0luQ2hhbm5lbDtcbiAgICAgICAgZm9yICh2YXIgd0hlaWdodDogdTMyID0gMHU7IHdIZWlnaHQgPCB1bmlmb3Jtcy53X3NoYXBlWzJdOyB3SGVpZ2h0KyspIHtcbiAgICAgICAgICBsZXQgeEhlaWdodCA9IHhSQ0Nvcm5lci54ICsgd0hlaWdodCAqIHVuaWZvcm1zLmRpbGF0aW9uc1swXTtcblxuICAgICAgICAgIGlmICh4SGVpZ2h0IDwgMHUgfHwgeEhlaWdodCA+PSB1bmlmb3Jtcy54X3NoYXBlWzJdKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciB3V2lkdGg6IHUzMiA9IDB1OyB3V2lkdGggPCB1bmlmb3Jtcy53X3NoYXBlWzNdOyB3V2lkdGgrKykge1xuICAgICAgICAgICAgbGV0IHhXaWR0aCA9IHhSQ0Nvcm5lci55ICsgd1dpZHRoICogdW5pZm9ybXMuZGlsYXRpb25zWzFdO1xuICAgICAgICAgICAgaWYgKHhXaWR0aCA8IDB1IHx8IHhXaWR0aCA+PSB1bmlmb3Jtcy54X3NoYXBlWzNdKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgeFZhbCA9ICR7eC5nZXQoJ2JhdGNoJywgJ2lucHV0X2NoYW5uZWwnLCAneEhlaWdodCcsICd4V2lkdGgnKX07XG4gICAgICAgICAgICBsZXQgd1ZhbCA9ICR7dy5nZXQoJ291dHB1dF9jaGFubmVsJywgJ3dJbkNoYW5uZWwnLCAnd0hlaWdodCcsICd3V2lkdGgnKX07XG4gICAgICAgICAgICB2YWx1ZSArPSB4VmFsICogd1ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGA7XG4gICAgcmV0dXJuIGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcnMsIG91dHB1dCl9XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cblxuICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgIGxldCBiYXRjaDogdTMyID0gb3V0cHV0SW5kaWNlc1swXTtcbiAgICBsZXQgb3V0cHV0X2NoYW5uZWw6IHUzMiA9IG91dHB1dEluZGljZXNbJHtpc0NoYW5uZWxMYXN0ID8gMyA6IDF9XTtcbiAgICBsZXQgeFJDQ29ybmVyOiB2ZWMyPHUzMj4gPSB2ZWMyPHUzMj4ob3V0cHV0SW5kaWNlc1ske2lzQ2hhbm5lbExhc3QgPyAxIDogMn1dLCBvdXRwdXRJbmRpY2VzWyR7XG4gICAgICBpc0NoYW5uZWxMYXN0ID8gMiA6IDNcbiAgICB9XSkgKiB1bmlmb3Jtcy5zdHJpZGVzIC0gdW5pZm9ybXMucGFkcztcbiAgICBsZXQgZ3JvdXBfaWQ6IHUzMiA9IG91dHB1dF9jaGFubmVsICogJHtjb21wb25lbnRzfSAvIHVuaWZvcm1zLm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgdmFyIGluX2NoYW5uZWxfb2Zmc2V0ID0gZ3JvdXBfaWQgKiB1bmlmb3Jtcy53X3NoYXBlWyR7aXNDaGFubmVsTGFzdCA/IDIgOiAxfV07XG5cbiAgICB2YXIgdmFsdWU6ICR7b3V0cHV0LnR5cGUudmFsdWV9ID0gJHtvdXRwdXQudHlwZS52YWx1ZX0oMCk7XG4gICAgJHtjYWxjdWxhdGVSZXN1bHR9XG4gICAgJHtwcm9jZXNzQmlhc31cbiAgICAke2FwcGx5QWN0aXZhdGlvbn1cbiAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpfVxuICB9YDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnR3JvdXBlZENvbnYnLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9XyR7Y29tcG9uZW50c31gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBkaW1zOiBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbiA/IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uKG91dHB1dFNoYXBlKSA6IG91dHB1dFNoYXBlLFxuICAgICAgICAgIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVHcm91cGVkQ29udlZlY3Rvcml6ZVByb2dyYW1JbmZvID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMsXG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24/OiAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBudW1iZXJbXSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPiAyO1xuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhvdXRwdXRTaGFwZVszXSk7XG4gIGNvbnN0IG91dHB1dE51bWJlciA9IGdldE1heENvbXBvbmVudHMob3V0cHV0U2hhcGVbMl0pO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gY29tcG9uZW50cyAvIG91dHB1dE51bWJlcjtcbiAgY29uc3QgeFNoYXBlID0gW2lucHV0c1swXS5kaW1zWzBdLCBpbnB1dHNbMF0uZGltc1sxXSwgaW5wdXRzWzBdLmRpbXNbMl0sIGlucHV0c1swXS5kaW1zWzNdIC8gY29tcG9uZW50c107XG4gIGNvbnN0IHdTaGFwZSA9IFtpbnB1dHNbMV0uZGltc1swXSwgaW5wdXRzWzFdLmRpbXNbMV0sIGlucHV0c1sxXS5kaW1zWzJdLCBpbnB1dHNbMV0uZGltc1szXSAvIGNvbXBvbmVudHNdO1xuICBjb25zdCBvdXRwdXRTaGFwZUluU2hhZGVyID0gW291dHB1dFNoYXBlWzBdLCBvdXRwdXRTaGFwZVsxXSwgb3V0cHV0U2hhcGVbMl0sIG91dHB1dFNoYXBlWzNdIC8gY29tcG9uZW50c107XG5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogW2F0dHJpYnV0ZXMuc3RyaWRlc1swXSwgYXR0cmlidXRlcy5zdHJpZGVzWzFdXSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IFthdHRyaWJ1dGVzLnBhZHNbMF0sIGF0dHJpYnV0ZXMucGFkc1sxXV0gfSxcbiAgXTtcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YShhdHRyaWJ1dGVzLCBwcm9ncmFtVW5pZm9ybXMpO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyh4U2hhcGUsIHdTaGFwZSwgb3V0cHV0U2hhcGVJblNoYWRlcikpO1xuICBjb25zdCB4TnVtYmVyID0gKG91dHB1dE51bWJlciAtIDEpICogYXR0cmlidXRlcy5zdHJpZGVzWzFdICsgd1NoYXBlWzFdO1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZUluU2hhZGVyLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3QgYmFzZVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUob3V0cHV0LnR5cGUudGVuc29yKTtcbiAgICBjb25zdCBhcHBseUFjdGl2YXRpb24gPSBnZXRBY3RpdmF0aW9uU25pcHBldChhdHRyaWJ1dGVzLCBvdXRwdXQudHlwZS52YWx1ZSwgYmFzZVR5cGUpO1xuICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCB4U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCB3ID0gaW5wdXRWYXJpYWJsZSgndycsIGlucHV0c1sxXS5kYXRhVHlwZSwgd1NoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3QgaW5wdXRWYXJzID0gW3gsIHddO1xuICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICBpbnB1dFZhcnMucHVzaChpbnB1dFZhcmlhYmxlKCdiJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcywgY29tcG9uZW50cykpO1xuICAgIH1cbiAgICBjb25zdCBwcm9jZXNzQmlhcyA9IGhhc0JpYXMgPyAndmFsdWUgKz0gYltvdXRwdXRfY2hhbm5lbF07JyA6ICcnO1xuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgIHsgbmFtZTogJ291dHB1dF9zaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ3N0cmlkZXMnLCB0eXBlOiAnaTMyJywgbGVuZ3RoOiAyIH0sXG4gICAgICB7IG5hbWU6ICdwYWRzJywgdHlwZTogJ2kzMicsIGxlbmd0aDogMiB9LFxuICAgIF07XG4gICAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zKGF0dHJpYnV0ZXMsIHVuaWZvcm1zKTtcbiAgICByZXR1cm4gYFxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFycywgb3V0cHV0KX1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICBsZXQgd2lkdGgwID0gdW5pZm9ybXMub3V0cHV0X3NoYXBlWzNdO1xuICAgIGxldCBvdXRwdXRfY2hhbm5lbCA9IGdsb2JhbF9pZHggJSB3aWR0aDA7XG4gICAgdmFyIGluZGV4MSA9IGdsb2JhbF9pZHggLyB3aWR0aDA7XG4gICAgbGV0IHdpZHRoMSA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZVsyXSAvICR7b3V0cHV0TnVtYmVyfXU7XG4gICAgbGV0IGNvbCA9IChpbmRleDEgJSB3aWR0aDEpICogJHtvdXRwdXROdW1iZXJ9dTtcbiAgICBpbmRleDEgPSBpbmRleDEgLyB3aWR0aDE7XG4gICAgbGV0IHJvdyA9IGluZGV4MSAlIHVuaWZvcm1zLm91dHB1dF9zaGFwZVsxXTtcbiAgICBsZXQgYmF0Y2ggPSBpbmRleDEgLyB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV07XG5cbiAgICBsZXQgeF9jb3JuZXIgPSB2ZWMyPGkzMj4oaTMyKHJvdyksIGkzMihjb2wpKSAqIHVuaWZvcm1zLnN0cmlkZXMgLSB1bmlmb3Jtcy5wYWRzO1xuXG4gICAgdmFyIHhfdmFsczogYXJyYXk8JHt4LnR5cGUudmFsdWV9LCAke3hOdW1iZXJ9PjtcbiAgICB2YXIgdmFsdWVzOiBhcnJheTwke291dHB1dC50eXBlLnZhbHVlfSwgJHtvdXRwdXROdW1iZXJ9PjtcbiAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IG91dHB1dF9jaGFubmVsO1xuICAgIC8vIFVzZSBjb25zdGFudCBpbnN0ZWFkIG9mIHVuaWZvcm0gY2FuIGdpdmUgYmV0dGVyIHBlcmZvcm1hbmNlIGZvciB3J3MgaGVpZ2h0L3dpZHRoLlxuICAgIGZvciAodmFyIHdfaGVpZ2h0OiB1MzIgPSAwdTsgd19oZWlnaHQgPCAke3dTaGFwZVswXX07IHdfaGVpZ2h0KyspIHtcbiAgICAgIGxldCB4X2hlaWdodCA9IHhfY29ybmVyLnggKyBpMzIod19oZWlnaHQpO1xuICAgICAgaWYgKHhfaGVpZ2h0ID49IDAgJiYgdTMyKHhfaGVpZ2h0KSA8IHVuaWZvcm1zLnhfc2hhcGVbMV0pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke3hOdW1iZXJ9OyBpKyspIHtcbiAgICAgICAgICBsZXQgeF93aWR0aCA9IHhfY29ybmVyLnkgKyBpO1xuICAgICAgICAgIGlmICh4X3dpZHRoID49IDAgJiYgdTMyKHhfd2lkdGgpIDwgdW5pZm9ybXMueF9zaGFwZVsyXSkge1xuICAgICAgICAgICAgeF92YWxzW2ldID0gJHt4LmdldCgnYmF0Y2gnLCAndTMyKHhfaGVpZ2h0KScsICd1MzIoeF93aWR0aCknLCAnaW5wdXRfY2hhbm5lbCcpfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeF92YWxzW2ldID0gJHt4LnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB3X3dpZHRoOiB1MzIgPSAwdTsgd193aWR0aCA8ICR7d1NoYXBlWzFdfTsgd193aWR0aCsrKSB7XG4gICAgICAgICAgbGV0IHdfdmFsID0gJHt3LmdldCgnd19oZWlnaHQnLCAnd193aWR0aCcsICcwJywgJ291dHB1dF9jaGFubmVsJyl9O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7b3V0cHV0TnVtYmVyfXU7IGkrKykge1xuICAgICAgICAgICAgdmFsdWVzW2ldID0gZm1hKHhfdmFsc1tpICogdTMyKHVuaWZvcm1zLnN0cmlkZXNbMV0pICsgd193aWR0aF0sIHdfdmFsLCB2YWx1ZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7b3V0cHV0TnVtYmVyfXU7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgJHtwcm9jZXNzQmlhc31cbiAgICAgICR7YXBwbHlBY3RpdmF0aW9ufVxuICAgICAgJHtvdXRwdXQuc2V0KCdiYXRjaCcsICdyb3cnLCAnY29sICsgaScsICdvdXRwdXRfY2hhbm5lbCcsICd2YWx1ZScpfTtcbiAgICB9XG4gIH1gO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0dyb3VwZWRDb252LVZlY3Rvcml6ZScsXG4gICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgIGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9OyR7Y29tcG9uZW50c307JHtvdXRwdXROdW1iZXJ9OyR7eE51bWJlcn07JHt3U2hhcGVbMF19OyR7d1NoYXBlWzFdfWAsXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogaGFzQmlhcyA/IFsncmFuaycsICdyYW5rJywgJ3R5cGUnXSA6IFsncmFuaycsICdyYW5rJ10sXG4gICAgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW1xuICAgICAgICB7XG4gICAgICAgICAgZGltczogc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24gPyBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbihvdXRwdXRTaGFwZSkgOiBvdXRwdXRTaGFwZSxcbiAgICAgICAgICBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBCcm9hZGNhc3RVdGlsLCBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvIH0gZnJvbSAnLi8zcmQtcGFydHkvbWF0bXVsX3BhY2tlZF93ZWJncHUnO1xuaW1wb3J0IHtcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXG4gIGdldEJyb2FkY2FzdERpbXMsXG4gIGdldE1heENvbXBvbmVudHMsXG4gIEluZGljZXNIZWxwZXIsXG4gIGlucHV0VmFyaWFibGUsXG4gIGludGVybmFsVmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSxcbiAgVW5pZm9ybXNBcnJheVR5cGUsXG59IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7XG4gIGFwcGVuZEFjdGl2YXRpb25Vbmlmb3JtcyxcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YSxcbiAgZ2V0QWN0aXZhdGlvblNuaXBwZXQsXG4gIEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsXG59IGZyb20gJy4vZnVzZS11dGlscyc7XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVOYWl2ZU1hdG11bFByb2dyYW1JbmZvID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYWN0aXZhdGlvbkF0dHJpYnV0ZXM6IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsXG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgcmVzaGFwZWRPdXRwdXRTaGFwZT86IHJlYWRvbmx5IG51bWJlcltdLFxuICBpc0NoYW5uZWxzTGFzdCA9IGZhbHNlIC8qIG9ubHkgdXNlZCBmb3IgY29udjJkQnlNYXRNdWwqLyxcbiAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24/OiAoc2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKSA9PiBudW1iZXJbXSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgYVNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGJTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuXG4gIGNvbnN0IE0gPSBhU2hhcGVbYVNoYXBlLmxlbmd0aCAtIDJdO1xuICBjb25zdCBOID0gYlNoYXBlW2JTaGFwZS5sZW5ndGggLSAxXTtcbiAgY29uc3QgSyA9IGFTaGFwZVthU2hhcGUubGVuZ3RoIC0gMV07XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKE4pO1xuICBjb25zdCBhQ29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoSyk7XG4gIGNvbnN0IG91dHB1dE51bWJlciA9IGdldE1heENvbXBvbmVudHMoTSk7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyBjb21wb25lbnRzIC8gb3V0cHV0TnVtYmVyO1xuICBjb25zdCBoYXNCaWFzID0gaW5wdXRzLmxlbmd0aCA+IDI7XG4gIGNvbnN0IG91dGVyRGltcyA9IHJlc2hhcGVkT3V0cHV0U2hhcGUgPyByZXNoYXBlZE91dHB1dFNoYXBlLnNsaWNlKDAsIC0yKSA6IG91dHB1dFNoYXBlLnNsaWNlKDAsIC0yKTtcbiAgY29uc3QgYmF0Y2hTaXplID0gU2hhcGVVdGlsLnNpemUob3V0ZXJEaW1zKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGVJblNoYWRlciA9IFtiYXRjaFNpemUsIE0sIE5dO1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE4gfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogSyB9LFxuICBdO1xuICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhKGFjdGl2YXRpb25BdHRyaWJ1dGVzLCBwcm9ncmFtVW5pZm9ybXMpO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRlckRpbXMsIGFTaGFwZSwgYlNoYXBlKSk7XG4gIGlmIChoYXNCaWFzKSB7XG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzJdLmRpbXMpKTtcbiAgfVxuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhvdXRwdXRTaGFwZUluU2hhZGVyKSk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgYmF0Y2hEaW1zID0gaW50ZXJuYWxWYXJpYWJsZSgnYmF0Y2hfZGltcycsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0ZXJEaW1zLmxlbmd0aCk7XG4gICAgY29uc3QgYSA9IGlucHV0VmFyaWFibGUoJ2EnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGFTaGFwZS5sZW5ndGgsIGFDb21wb25lbnRzKTtcbiAgICBjb25zdCBiID0gaW5wdXRWYXJpYWJsZSgnYicsIGlucHV0c1sxXS5kYXRhVHlwZSwgYlNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGVJblNoYWRlci5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IGJhc2VUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKG91dHB1dC50eXBlLnRlbnNvcik7XG4gICAgY29uc3QgYXBwbHlBY3RpdmF0aW9uID0gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYWN0aXZhdGlvbkF0dHJpYnV0ZXMsIG91dHB1dC50eXBlLnZhbHVlLCBiYXNlVHlwZSk7XG4gICAgY29uc3QgaW5wdXRWYXJpYWJsZXMgPSBbYSwgYl07XG4gICAgbGV0IHByb2Nlc3NCaWFzID0gJyc7XG4gICAgaWYgKGhhc0JpYXMpIHtcbiAgICAgIGNvbnN0IGJpYXNDb21wb25lbnRzID0gaXNDaGFubmVsc0xhc3QgPyBjb21wb25lbnRzIDogMTtcbiAgICAgIGlucHV0VmFyaWFibGVzLnB1c2goaW5wdXRWYXJpYWJsZSgnYmlhcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoLCBiaWFzQ29tcG9uZW50cykpO1xuICAgICAgcHJvY2Vzc0JpYXMgPSBgJHtcbiAgICAgICAgaXNDaGFubmVsc0xhc3QgPyBgdmFsdWUgKz0gYmlhc1tjb2wgLyAke2JpYXNDb21wb25lbnRzfV07YCA6IGB2YWx1ZSArPSAke291dHB1dC50eXBlLnZhbHVlfShiaWFzW3JvdyArIGldKTtgXG4gICAgICB9YDtcbiAgICB9XG5cbiAgICBjb25zdCBvdXRlckRpbXNBID0gYVNoYXBlLnNsaWNlKDAsIC0yKTtcbiAgICBjb25zdCBvdXRlckRpbXNCID0gYlNoYXBlLnNsaWNlKDAsIC0yKTtcbiAgICBjb25zdCBicm9hZENhc3RBRGltcyA9IGdldEJyb2FkY2FzdERpbXMob3V0ZXJEaW1zQSwgb3V0ZXJEaW1zKTtcbiAgICBjb25zdCBicm9hZENhc3RCRGltcyA9IGdldEJyb2FkY2FzdERpbXMob3V0ZXJEaW1zQiwgb3V0ZXJEaW1zKTtcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdNJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ04nLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnSycsIHR5cGU6ICd1MzInIH0sXG4gICAgXTtcbiAgICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMoYWN0aXZhdGlvbkF0dHJpYnV0ZXMsIHVuaWZvcm1zKTtcblxuICAgIGNvbnN0IGdldEluZGljZXMgPSAodmFyaWFibGU6IEluZGljZXNIZWxwZXIsIGJyb2FkQ2FzdERpbXM6IG51bWJlcltdKSA9PiB7XG4gICAgICBjb25zdCByYW5rID0gdmFyaWFibGUucmFuaztcbiAgICAgIGNvbnN0IG5hbWUgPSB2YXJpYWJsZS5uYW1lO1xuICAgICAgaWYgKHJhbmsgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGB2YXIgJHtuYW1lfV9pbmRpY2VzID0gJHt2YXJpYWJsZS50eXBlLmluZGljZXN9KDB1LCAwdSk7YDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJhdGNoUmFuayA9IGJhdGNoRGltcy5yYW5rO1xuICAgICAgbGV0IHJlc1N0ciA9IGB2YXIgJHtuYW1lfV9pbmRpY2VzOiAke3ZhcmlhYmxlLnR5cGUuaW5kaWNlc307YDtcbiAgICAgIGZvciAobGV0IGkgPSByYW5rIC0gMiAtIDEsIGogPSBiYXRjaFJhbmsgLSAxOyBpID49IDA7IGktLSwgai0tKSB7XG4gICAgICAgIHJlc1N0ciArPSBgXFxuJHtuYW1lfV9pbmRpY2VzWyR7aX1dID0gJHtiYXRjaFJhbmsgPiAxID8gYGJhdGNoX2luZGljZXNbJHtqfV1gIDogJ2JhdGNoX2luZGljZXMnfTtgO1xuICAgICAgfVxuICAgICAgYnJvYWRDYXN0RGltcy5mb3JFYWNoKChpKSA9PiB7XG4gICAgICAgIHJlc1N0ciArPSBgXFxuJHtuYW1lfV9pbmRpY2VzWyR7aX1dID0gMDtgO1xuICAgICAgfSk7XG4gICAgICByZXNTdHIgKz0gYCR7bmFtZX1faW5kaWNlc1ske3JhbmsgLSAyfV0gPSAwdTtcbiAgICAgICAgICAgICAgICAgICAgICR7bmFtZX1faW5kaWNlc1ske3JhbmsgLSAxfV0gPSAwdTtgO1xuICAgICAgcmV0dXJuIHJlc1N0cjtcbiAgICB9O1xuXG4gICAgY29uc3QgY2FsY1Jlc3VsdCA9ICgpOiBzdHJpbmcgPT4ge1xuICAgICAgbGV0IGNhbGNTdHIgPSBgdmFyIGFfZGF0YTogJHthLnR5cGUudmFsdWV9O2A7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFDb21wb25lbnRzOyBpKyspIHtcbiAgICAgICAgY2FsY1N0ciArPSBgXG4gICAgICAgICAgICAgIGxldCBiX2RhdGEke2l9ID0gYlsoYl9vZmZzZXQgKyAoayArICR7aX0pICogdW5pZm9ybXMuTiArIGNvbCkgLyAke2NvbXBvbmVudHN9XTtgO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXROdW1iZXI7IGkrKykge1xuICAgICAgICBjYWxjU3RyICs9IGBhX2RhdGEgPSBhWyhhX29mZnNldCArIChyb3cgKyAke2l9KSAqIHVuaWZvcm1zLksgKyBrKSAvICR7YUNvbXBvbmVudHN9XTtgO1xuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYUNvbXBvbmVudHM7IGorKykge1xuICAgICAgICAgIGNhbGNTdHIgKz0gYFxuICAgICAgICAgICAgdmFsdWVzWyR7aX1dID0gZm1hKCR7Yi50eXBlLnZhbHVlfShhX2RhdGEke2FDb21wb25lbnRzID09PSAxID8gJycgOiBgWyR7an1dYH0pLCBiX2RhdGEke2p9LCB2YWx1ZXNbJHtpfV0pO1xcbmA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWxjU3RyO1xuICAgIH07XG5cbiAgICByZXR1cm4gYFxuICAke3NoYWRlckhlbHBlclxuICAgIC5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKVxuICAgIC5yZWdpc3RlckludGVybmFsVmFyaWFibGVzKGJhdGNoRGltcylcbiAgICAuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcmlhYmxlcywgb3V0cHV0KX1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICBsZXQgY29sID0gKGdsb2JhbF9pZHggJSAodW5pZm9ybXMuTiAvICR7Y29tcG9uZW50c30pKSAqICR7Y29tcG9uZW50c307XG4gICAgdmFyIGluZGV4MSA9IGdsb2JhbF9pZHggLyAodW5pZm9ybXMuTiAvICR7Y29tcG9uZW50c30pO1xuICAgIGxldCBzdHJpZGUxID0gdW5pZm9ybXMuTSAvICR7b3V0cHV0TnVtYmVyfTtcbiAgICBsZXQgcm93ID0gKGluZGV4MSAlIHN0cmlkZTEpICogJHtvdXRwdXROdW1iZXJ9O1xuICAgIGxldCBiYXRjaCA9IGluZGV4MSAvIHN0cmlkZTE7XG5cbiAgICAke291dHB1dFNoYXBlLmxlbmd0aCA9PT0gMiA/ICcnIDogYGxldCBiYXRjaF9pbmRpY2VzID0gJHtiYXRjaERpbXMub2Zmc2V0VG9JbmRpY2VzKCdiYXRjaCcpfTtgfVxuICAgICR7Z2V0SW5kaWNlcyhhLCBicm9hZENhc3RBRGltcyl9XG4gICAgbGV0IGFfb2Zmc2V0ID0gJHthLmluZGljZXNUb09mZnNldCgnYV9pbmRpY2VzJyl9O1xuICAgICR7Z2V0SW5kaWNlcyhiLCBicm9hZENhc3RCRGltcyl9XG4gICAgbGV0IGJfb2Zmc2V0ID0gJHtiLmluZGljZXNUb09mZnNldCgnYl9pbmRpY2VzJyl9O1xuICAgIHZhciB2YWx1ZXM6IGFycmF5PCR7b3V0cHV0LnR5cGUudmFsdWV9LCAke291dHB1dE51bWJlcn0+O1xuICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgdW5pZm9ybXMuSzsgayA9IGsgKyAke2FDb21wb25lbnRzfSkge1xuICAgICAgJHtjYWxjUmVzdWx0KCl9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7b3V0cHV0TnVtYmVyfXU7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgJHtwcm9jZXNzQmlhc31cbiAgICAgICR7YXBwbHlBY3RpdmF0aW9ufVxuICAgICAgbGV0IGN1cl9pbmRpY2VzID0gJHtvdXRwdXQudHlwZS5pbmRpY2VzfShiYXRjaCwgcm93ICsgaSwgY29sKTtcbiAgICAgIGxldCBvZmZzZXQgPSAke291dHB1dC5pbmRpY2VzVG9PZmZzZXQoJ2N1cl9pbmRpY2VzJyl9O1xuICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoYG9mZnNldCAvICR7Y29tcG9uZW50c31gLCAndmFsdWUnKX07XG4gICAgfVxuICB9XG4gIGA7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ01hdE11bE5haXZlJyxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYCR7YWN0aXZhdGlvbkF0dHJpYnV0ZXMuYWN0aXZhdGlvbn07JHtjb21wb25lbnRzfTske2FDb21wb25lbnRzfTske291dHB1dE51bWJlcn07JHtpc0NoYW5uZWxzTGFzdH1gLFxuICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IGhhc0JpYXMgPyBbJ3JhbmsnLCAncmFuaycsICdyYW5rJ10gOiBbJ3JhbmsnLCAncmFuayddLFxuICAgIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGRpbXM6IHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uID8gc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24ob3V0cHV0U2hhcGUpIDogb3V0cHV0U2hhcGUsXG4gICAgICAgICAgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignTWF0TXVsIHJlcXVpcmVzIDIgaW5wdXRzLicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zW2lucHV0c1swXS5kaW1zLmxlbmd0aCAtIDFdICE9PSBpbnB1dHNbMV0uZGltc1tpbnB1dHNbMV0uZGltcy5sZW5ndGggLSAyXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2hhcmVkIGRpbWVuc2lvbiBkb2VzIG5vdCBtYXRjaC4nKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IG1hdE11bCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gQnJvYWRjYXN0VXRpbC5jYWxjU2hhcGUoY29udGV4dC5pbnB1dHNbMF0uZGltcywgY29udGV4dC5pbnB1dHNbMV0uZGltcywgdHJ1ZSk7XG4gIGlmICghb3V0cHV0U2hhcGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1c2UgbWF0bXVsIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO1xuICB9XG4gIGNvbnN0IE4gPSBvdXRwdXRTaGFwZVtvdXRwdXRTaGFwZS5sZW5ndGggLSAxXTtcbiAgY29uc3QgSyA9IGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbY29udGV4dC5pbnB1dHNbMF0uZGltcy5sZW5ndGggLSAxXTtcbiAgaWYgKE4gPCA4ICYmIEsgPCA4KSB7XG4gICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZU5haXZlTWF0bXVsUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIHsgYWN0aXZhdGlvbjogJycgfSwgb3V0cHV0U2hhcGUpKTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlTWF0bXVsUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIHsgYWN0aXZhdGlvbjogJycgfSwgb3V0cHV0U2hhcGUpKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFBvb2xDb252VXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVDb252MkRNYXRNdWxQcm9ncmFtSW5mbyB9IGZyb20gJy4vM3JkLXBhcnR5L2NvbnYyZF9tbV93ZWJncHUnO1xuaW1wb3J0IHsgY29tcHV0ZUNvbnYzREluZm8sIGNyZWF0ZUNvbnYzRE5haXZlUHJvZ3JhbUluZm8gfSBmcm9tICcuLzNyZC1wYXJ0eS9jb252M2RfbmFpdmVfd2ViZ3B1JztcbmltcG9ydCB7IGNyZWF0ZU1hdG11bFByb2dyYW1JbmZvIH0gZnJvbSAnLi8zcmQtcGFydHkvbWF0bXVsX3BhY2tlZF93ZWJncHUnO1xuaW1wb3J0IHsgY3JlYXRlR3JvdXBlZENvbnZQcm9ncmFtSW5mbywgY3JlYXRlR3JvdXBlZENvbnZWZWN0b3JpemVQcm9ncmFtSW5mbyB9IGZyb20gJy4vY29udi1ncm91cGVkJztcbmltcG9ydCB7IEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsIHBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyB9IGZyb20gJy4vZnVzZS11dGlscyc7XG5pbXBvcnQgeyBjcmVhdGVOYWl2ZU1hdG11bFByb2dyYW1JbmZvIH0gZnJvbSAnLi9tYXRtdWwnO1xuaW1wb3J0IHsgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8gfSBmcm9tICcuL3RyYW5zcG9zZSc7XG5cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVPdXRwdXRTaGFwZSA9IChcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgZGlsYXRpb25zOiByZWFkb25seSBudW1iZXJbXSxcbiAgYWRqdXN0UGFkczogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICBpc0NoYW5uZWxMYXN0OiBib29sZWFuLFxuKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCBiYXRjaFNpemUgPSBpbnB1dFNoYXBlWzBdO1xuICBjb25zdCBpbnB1dFNwYXRpYWxTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoaXNDaGFubmVsTGFzdCA/IDEgOiAyLCBpc0NoYW5uZWxMYXN0ID8gMyA6IDQpO1xuICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0U3BhdGlhbFNoYXBlLmxlbmd0aDtcbiAgY29uc3Qgb3V0Q2hhbm5lbHMgPSBrZXJuZWxTaGFwZVswXTtcbiAgY29uc3Qga2VybmVsU3BhdGlhbFNoYXBlID0ga2VybmVsU2hhcGUuc2xpY2UoMik7XG4gIGNvbnN0IGRpbGF0ZWRLZXJuZWxTaGFwZSA9IGtlcm5lbFNwYXRpYWxTaGFwZS5tYXAoKHYsIGkpID0+IHYgKyAodiAtIDEpICogKGRpbGF0aW9uc1tpXSAtIDEpKTtcbiAgY29uc3QgaW5wdXRTcGF0aWFsU2hhcGVXaXRoUGFkID0gaW5wdXRTcGF0aWFsU2hhcGUubWFwKCh2LCBpKSA9PiB2ICsgYWRqdXN0UGFkc1tpXSArIGFkanVzdFBhZHNbaSArIHNwYXRpYWxSYW5rXSk7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTcGF0aWFsU2hhcGVXaXRoUGFkLm1hcCgodiwgaSkgPT5cbiAgICBNYXRoLmZsb29yKCh2IC0gZGlsYXRlZEtlcm5lbFNoYXBlW2ldICsgc3RyaWRlc1tpXSkgLyBzdHJpZGVzW2ldKSxcbiAgKTtcbiAgb3V0cHV0U2hhcGUuc3BsaWNlKDAsIDAsIGJhdGNoU2l6ZSk7XG4gIG91dHB1dFNoYXBlLnNwbGljZShpc0NoYW5uZWxMYXN0ID8gMyA6IDEsIDAsIG91dENoYW5uZWxzKTtcbiAgcmV0dXJuIG91dHB1dFNoYXBlO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBDb252QXR0cmlidXRlcyBleHRlbmRzIEludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMsIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGF1dG9QYWQ6IHN0cmluZztcbiAgcmVhZG9ubHkgZGlsYXRpb25zOiByZWFkb25seSBudW1iZXJbXTtcbiAgcmVhZG9ubHkgZm9ybWF0OiAnTkhXQycgfCAnTkNIVyc7XG4gIHJlYWRvbmx5IGdyb3VwOiBudW1iZXI7XG4gIHJlYWRvbmx5IGtlcm5lbFNoYXBlOiByZWFkb25seSBudW1iZXJbXTtcbiAgcmVhZG9ubHkgcGFkczogcmVhZG9ubHkgbnVtYmVyW107XG4gIHJlYWRvbmx5IHN0cmlkZXM6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSB3SXNDb25zdDogYm9vbGVhbjtcbn1cblxuLy8gZm9yIHRyYW5zcG9zaW5nIHdlaWdodCB0ZW5zb3IgZnJvbSBbTSwgQy9ncm91cCwgS0gsIEtXXSB0byBbS0gsIEtXLCBDL2dyb3VwLCBNXVxuY29uc3Qgd2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlID0gWzIsIDMsIDEsIDBdO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgLy8gUmVmZXIgdG8gdGhlIGJlbG93IGxpbmsgZm9yIGFsbCBpbnB1dCBjaGVja3NcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL29ubngvb25ueC9ibG9iL21hc3Rlci9kb2NzL09wZXJhdG9ycy5tZCNDb252XG4gIGlmICghaW5wdXRzIHx8IChpbnB1dHMubGVuZ3RoICE9PSAyICYmIGlucHV0cy5sZW5ndGggIT09IDMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb252IHJlcXVpcmVzIDIgb3IgMyBpbnB1dHMnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggPiA1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdncmVhdGVyIHRoYW4gNUQgaXMgbm90IHN1cHBvcnRlZCcpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dCcpO1xuICB9XG5cbiAgLy8gRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFxuICBjb25zdCBkYXRhQ2hhbm5lbCA9IGlucHV0c1swXS5kaW1zW2F0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQycgPyBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAxIDogMV07XG4gIGNvbnN0IGZpbHRlckluQ2hhbm5lbCA9IGlucHV0c1sxXS5kaW1zWzFdICogYXR0cmlidXRlcy5ncm91cDtcbiAgaWYgKGRhdGFDaGFubmVsICE9PSBmaWx0ZXJJbkNoYW5uZWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUwnKTtcbiAgfVxuXG4gIC8vIGlmIGJpYXMgaXMgcHJvdmlkZWQgaXQgc2hvdWxkIGJlIDFEIGFuZCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHNob3VsZCBiZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGZlYXR1cmUgbWFwc1xuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiAoaW5wdXRzWzJdLmRpbXMubGVuZ3RoICE9PSAxIHx8IGlucHV0c1sxXS5kaW1zWzBdICE9PSBpbnB1dHNbMl0uZGltc1swXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYmlhcycpO1xuICB9XG5cbiAgY29uc3Qgc3BhdGlhbFJhbmsgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAyO1xuICAvLyB3cm9uZyBkaWxhdGlvbnMgZGltZW5zaW9uXG4gIGlmIChhdHRyaWJ1dGVzLmRpbGF0aW9ucy5sZW5ndGggIT09IHNwYXRpYWxSYW5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xuICB9XG5cbiAgLy8gV3Jvbmcgc3RyaWRlcyBkaW1lbnNpb25cbiAgaWYgKGF0dHJpYnV0ZXMuc3RyaWRlcy5sZW5ndGggIT09IHNwYXRpYWxSYW5rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke3NwYXRpYWxSYW5rfURgKTtcbiAgfVxuXG4gIC8vIFdyb25nIHBhZHMgZGltZW5zaW9uXG4gIGlmIChhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoICE9PSBzcGF0aWFsUmFuayAqIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZHMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmsgKiAyfURgKTtcbiAgfVxuXG4gIC8vIGlmIGtlcm5lbFNoYXBlIGlzIHNwZWNpZmllZCwgaXQncyBkYXRhIGxlbmd0aCBtdXN0IGJlIDIgbGVzcyB0aGFuIGRpbXMgbGVuZ3RoIG9mIHRoZSB3ZWlnaHRzIHRlbnNvclxuICAvLyAodGhlIGZpcnN0IDIgZGltcyBhcmUgYmF0Y2hfc2l6ZSBhbmQgY2hhbm5lbHMpXG4gIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gMCAmJiBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoIC0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBrZXJuZWwgc2hhcGUnKTtcbiAgfVxufTtcblxuY29uc3QgZ2V0QWRqdXN0ZWRDb252QXR0cmlidXRlcyA9IDxUIGV4dGVuZHMgQ29udkF0dHJpYnV0ZXM+KGF0dHJpYnV0ZXM6IFQsIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogVCA9PiB7XG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5zbGljZSgpO1xuICAvLyBpZiBrZXJuZWxTaGFwZSBpcyBub3Qgd2VsbCBzcGVjaWZpZWQgaW4gdGhlIGF0dHJpYnV0ZXMsIGluZmVyIGl0IGZyb20gdGhlIHdlaWdodCB0ZW5zb3IgZGltc1xuICBpZiAoa2VybmVsU2hhcGUubGVuZ3RoIDwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoIC0gMikge1xuICAgIGtlcm5lbFNoYXBlLnB1c2goLi4uQXJyYXkoaW5wdXRzWzFdLmRpbXMubGVuZ3RoIC0gMiAtIGtlcm5lbFNoYXBlLmxlbmd0aCkuZmlsbCgwKSk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDI7IGkgPCBpbnB1dHNbMV0uZGltcy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChrZXJuZWxTaGFwZVtpIC0gMl0gPT09IDApIHtcbiAgICAgIGtlcm5lbFNoYXBlW2kgLSAyXSA9IGlucHV0c1sxXS5kaW1zW2ldO1xuICAgIH1cbiAgfVxuICBjb25zdCBwYWRzID0gYXR0cmlidXRlcy5wYWRzLnNsaWNlKCk7XG4gIFBvb2xDb252VXRpbC5hZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQoXG4gICAgaW5wdXRzWzBdLmRpbXMsXG4gICAgYXR0cmlidXRlcy5zdHJpZGVzLFxuICAgIGF0dHJpYnV0ZXMuZGlsYXRpb25zLFxuICAgIGtlcm5lbFNoYXBlLFxuICAgIHBhZHMsXG4gICAgYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJyxcbiAgICBhdHRyaWJ1dGVzLmF1dG9QYWQsXG4gICk7XG5cbiAgLy8gYWx3YXlzIHJldHVybiBhIG5ldyBvYmplY3Qgc28gZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCBhdHRyaWJ1dGVzXG4gIGNvbnN0IG5ld0F0dHJpYnV0ZXM6IFQgPSBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKTtcbiAgT2JqZWN0LmFzc2lnbihuZXdBdHRyaWJ1dGVzLCB7IGtlcm5lbFNoYXBlLCBwYWRzIH0pO1xuICByZXR1cm4gbmV3QXR0cmlidXRlcztcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUNvbnZBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQ29udkF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBhY3RpdmF0aW9uQXR0cmlidXRlcyA9IHBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgLy8gVE9ETyA6IE1ha2UgdGhpcyBnZW5lcmljIGVub3VnaCB0byBjb21wdXRlIGRlZmF1bHQgYXR0cmlidXRlcyBmb3IgbXVsdGktZGltZW5zaW9uYWwgY29udlxuICBjb25zdCBmb3JtYXQgPSBhdHRyaWJ1dGVzLmZvcm1hdCBhcyAnTkhXQycgfCAnTkNIVyc7XG4gIGNvbnN0IGF1dG9QYWQgPSBbJ05PVFNFVCcsICdWQUxJRCcsICdTQU1FX1VQUEVSJywgJ1NBTUVfTE9XRVInXVthdHRyaWJ1dGVzLmF1dG9fcGFkIGFzIG51bWJlcl07XG4gIGNvbnN0IGRpbGF0aW9ucyA9IGF0dHJpYnV0ZXMuZGlsYXRpb25zIGFzIG51bWJlcltdO1xuICBjb25zdCBncm91cCA9IGF0dHJpYnV0ZXMuZ3JvdXAgYXMgbnVtYmVyO1xuICBjb25zdCBrZXJuZWxTaGFwZSA9IGF0dHJpYnV0ZXMua2VybmVsX3NoYXBlIGFzIG51bWJlcltdO1xuICBjb25zdCBwYWRzID0gYXR0cmlidXRlcy5wYWRzIGFzIG51bWJlcltdO1xuICBjb25zdCBzdHJpZGVzID0gYXR0cmlidXRlcy5zdHJpZGVzIGFzIG51bWJlcltdO1xuICBjb25zdCB3SXNDb25zdCA9IChhdHRyaWJ1dGVzLndfaXNfY29uc3QgYXMgKCkgPT4gYm9vbGVhbikoKTtcblxuICByZXR1cm4ge1xuICAgIGF1dG9QYWQsXG4gICAgZm9ybWF0LFxuICAgIGRpbGF0aW9ucyxcbiAgICBncm91cCxcbiAgICBrZXJuZWxTaGFwZSxcbiAgICBwYWRzLFxuICAgIHN0cmlkZXMsXG4gICAgd0lzQ29uc3QsXG4gICAgLi4uYWN0aXZhdGlvbkF0dHJpYnV0ZXMsXG4gICAgY2FjaGVLZXk6IGAke2F0dHJpYnV0ZXMuZm9ybWF0fTske2FjdGl2YXRpb25BdHRyaWJ1dGVzLmFjdGl2YXRpb259O2AsXG4gIH07XG59O1xuXG5jb25zdCBjb252MmQgPSAoXG4gIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMsXG4gIHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uPzogKHNoYXBlOiByZWFkb25seSBudW1iZXJbXSkgPT4gbnVtYmVyW10sXG4pOiB2b2lkID0+IHtcbiAgLy8gY2hlY2sgYXR0cmlidXRlc1xuXG4gIC8vIGNvbnN0IGhhc1ByZWx1QWN0aXZhdGlvbldlaWdodHMgPSBmYWxzZTsgLyogVE9ETzogYWRkIHN1cHBvcnQgZm9yIHByZWx1IGFjdGl2YXRpb24gd2VpZ2h0cyAqL1xuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gY2FsY3VsYXRlT3V0cHV0U2hhcGUoXG4gICAgaW5wdXRzWzBdLmRpbXMsXG4gICAgaW5wdXRzWzFdLmRpbXMsXG4gICAgYXR0cmlidXRlcy5kaWxhdGlvbnMsXG4gICAgYXR0cmlidXRlcy5wYWRzLFxuICAgIGF0dHJpYnV0ZXMuc3RyaWRlcyxcbiAgICBpc0NoYW5uZWxzTGFzdCxcbiAgKTtcbiAgaWYgKGF0dHJpYnV0ZXMuZ3JvdXAgIT09IDEpIHtcbiAgICBjb25zdCBjb252SW5wdXRzID0gW2lucHV0c1swXV07XG4gICAgaWYgKGlzQ2hhbm5lbHNMYXN0KSB7XG4gICAgICBjb25zdCB0cmFuc3Bvc2VkV2VpZ2h0ID1cbiAgICAgICAgKGNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCBhcyBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkKSA/P1xuICAgICAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8oaW5wdXRzWzFdLCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUpLCB7XG4gICAgICAgICAgaW5wdXRzOiBbMV0sXG4gICAgICAgICAgb3V0cHV0czogW2F0dHJpYnV0ZXMud0lzQ29uc3QgPyAtMiA6IC0xXSxcbiAgICAgICAgfSlbMF07XG4gICAgICBpZiAoYXR0cmlidXRlcy53SXNDb25zdCAmJiAhY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUKSB7XG4gICAgICAgIGNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCA9IHRyYW5zcG9zZWRXZWlnaHQ7XG4gICAgICB9XG4gICAgICBjb252SW5wdXRzLnB1c2godHJhbnNwb3NlZFdlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnZJbnB1dHMucHVzaChpbnB1dHNbMV0pO1xuICAgIH1cbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgY29udklucHV0cy5wdXNoKGlucHV0c1syXSk7XG4gICAgfVxuICAgIC8vIE5WSURJQSBHUFUgd2l0aCBhbXBlcmUgYXJjaGl0ZWN0dXJlIGZhaWxzIHdpdGggYmVsb3cgMiBjYXNlcywgYnV0IHdlIGNvdWxkbid0IHJlcHJvIHRoZW0gd2l0aCBhbnkgb3RoZXJcbiAgICAvLyBHUFVzLiBTbyBqdXN0IGRpc2FibGUgdmVjdG9yaXplIG9uIE5WSURJQSBhbXBlcmUgdG8gZW5zdXJlIGFsd2F5cyBjb3JyZWN0IG91dHB1dHMuXG4gICAgLy8gW3dlYmdwdV1Db252IC0gY29udiAtIHZlY3Rvcml6ZSBncm91cCAtIEJcbiAgICAvLyBbd2ViZ3B1XUNvbnYgLSBjb252IC0gdmVjdG9yaXplIGdyb3VwIC0gRFxuICAgIGNvbnN0IGVuYWJsZUdyb3VwZWRDb252VmVjdG9yaXplID0gIWNvbnRleHQuYWRhcHRlckluZm8uaXNBcmNoaXRlY3R1cmUoJ2FtcGVyZScpO1xuICAgIGlmIChcbiAgICAgIGVuYWJsZUdyb3VwZWRDb252VmVjdG9yaXplICYmXG4gICAgICBpc0NoYW5uZWxzTGFzdCAmJlxuICAgICAgaW5wdXRzWzFdLmRpbXNbMF0gPT09IGF0dHJpYnV0ZXMuZ3JvdXAgJiZcbiAgICAgIGlucHV0c1sxXS5kaW1zWzFdID09PSAxICYmXG4gICAgICBhdHRyaWJ1dGVzLmRpbGF0aW9uc1swXSA9PT0gMSAmJlxuICAgICAgYXR0cmlidXRlcy5kaWxhdGlvbnNbMV0gPT09IDFcbiAgICApIHtcbiAgICAgIGNvbnRleHQuY29tcHV0ZShcbiAgICAgICAgY3JlYXRlR3JvdXBlZENvbnZWZWN0b3JpemVQcm9ncmFtSW5mbyhjb252SW5wdXRzLCBhdHRyaWJ1dGVzLCBvdXRwdXRTaGFwZSwgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24pLFxuICAgICAgICB7IGlucHV0czogY29udklucHV0cyB9LFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUdyb3VwZWRDb252UHJvZ3JhbUluZm8oY29udklucHV0cywgYXR0cmlidXRlcywgb3V0cHV0U2hhcGUsIHNxdWVlemVPdXRwdXRTaGFwZUZ1bmN0aW9uKSwge1xuICAgICAgICBpbnB1dHM6IGNvbnZJbnB1dHMsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgaGFzQmlhcyA9IGlucHV0cy5sZW5ndGggPT09IDM7XG4gIGNvbnN0IGlucHV0SGVpZ2h0ID0gaW5wdXRzWzBdLmRpbXNbaXNDaGFubmVsc0xhc3QgPyAxIDogMl07XG4gIGNvbnN0IGlucHV0V2lkdGggPSBpbnB1dHNbMF0uZGltc1tpc0NoYW5uZWxzTGFzdCA/IDIgOiAzXTtcbiAgY29uc3QgaW5wdXRDaGFubmVscyA9IGlucHV0c1swXS5kaW1zW2lzQ2hhbm5lbHNMYXN0ID8gMyA6IDFdO1xuICBjb25zdCB3ZWlnaHRIZWlnaHQgPSBpbnB1dHNbMV0uZGltc1syXTtcbiAgY29uc3Qgd2VpZ2h0V2lkdGggPSBpbnB1dHNbMV0uZGltc1szXTtcblxuICBjb25zdCBvdXRIZWlnaHQgPSBvdXRwdXRTaGFwZVtpc0NoYW5uZWxzTGFzdCA/IDEgOiAyXTtcbiAgY29uc3Qgb3V0V2lkdGggPSBvdXRwdXRTaGFwZVtpc0NoYW5uZWxzTGFzdCA/IDIgOiAzXTtcbiAgY29uc3Qgb3V0Q2hhbm5lbHMgPSBvdXRwdXRTaGFwZVtpc0NoYW5uZWxzTGFzdCA/IDMgOiAxXTtcblxuICBjb25zdCBzYW1lU2l6ZSA9XG4gICAgaXNDaGFubmVsc0xhc3QgJiZcbiAgICB3ZWlnaHRIZWlnaHQgPT09IGlucHV0SGVpZ2h0ICYmXG4gICAgd2VpZ2h0V2lkdGggPT09IGlucHV0V2lkdGggJiZcbiAgICBhdHRyaWJ1dGVzLnBhZHNbMF0gPT09IDAgJiZcbiAgICBhdHRyaWJ1dGVzLnBhZHNbMV0gPT09IDA7XG4gIGlmIChcbiAgICBzYW1lU2l6ZSB8fFxuICAgICh3ZWlnaHRIZWlnaHQgPT09IDEgJiZcbiAgICAgIHdlaWdodFdpZHRoID09PSAxICYmXG4gICAgICBhdHRyaWJ1dGVzLmRpbGF0aW9uc1swXSA9PT0gMSAmJlxuICAgICAgYXR0cmlidXRlcy5kaWxhdGlvbnNbMV0gPT09IDEgJiZcbiAgICAgIGF0dHJpYnV0ZXMuc3RyaWRlc1swXSA9PT0gMSAmJlxuICAgICAgYXR0cmlidXRlcy5zdHJpZGVzWzFdID09PSAxICYmXG4gICAgICBhdHRyaWJ1dGVzLnBhZHNbMF0gPT09IDAgJiZcbiAgICAgIGF0dHJpYnV0ZXMucGFkc1sxXSA9PT0gMClcbiAgKSB7XG4gICAgLy8gY29udjJkQnlNYXRNdWxcbiAgICBjb25zdCBiYXRjaCA9IG91dHB1dFNoYXBlWzBdO1xuICAgIGxldCB4UmVzaGFwZWQsIHdSZXNoYXBlZCwgbWF0bXVsT3V0cHV0U2hhcGU7XG4gICAgY29uc3QgbWF0bXVsSW5wdXRzID0gW107XG4gICAgaWYgKGlzQ2hhbm5lbHNMYXN0KSB7XG4gICAgICBjb25zdCB0cmFuc3Bvc2VkV2VpZ2h0ID1cbiAgICAgICAgKGNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCBhcyBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkKSA/P1xuICAgICAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8oaW5wdXRzWzFdLCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUpLCB7XG4gICAgICAgICAgaW5wdXRzOiBbMV0sXG4gICAgICAgICAgb3V0cHV0czogW2F0dHJpYnV0ZXMud0lzQ29uc3QgPyAtMiA6IC0xXSxcbiAgICAgICAgfSlbMF07XG4gICAgICBpZiAoYXR0cmlidXRlcy53SXNDb25zdCAmJiAhY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUKSB7XG4gICAgICAgIGNvbnRleHQua2VybmVsQ3VzdG9tRGF0YS53VCA9IHRyYW5zcG9zZWRXZWlnaHQ7XG4gICAgICB9XG4gICAgICBpZiAoc2FtZVNpemUpIHtcbiAgICAgICAgY29uc3Qgc2hhcmVkRGltID0gaW5wdXRIZWlnaHQgKiBpbnB1dFdpZHRoICogaW5wdXRDaGFubmVscztcbiAgICAgICAgeFJlc2hhcGVkID0gaW5wdXRzWzBdLnJlc2hhcGUoWzEsIGJhdGNoLCBzaGFyZWREaW1dKTtcbiAgICAgICAgd1Jlc2hhcGVkID0gdHJhbnNwb3NlZFdlaWdodC5yZXNoYXBlKFsxLCBzaGFyZWREaW0sIG91dENoYW5uZWxzXSk7XG4gICAgICAgIG1hdG11bE91dHB1dFNoYXBlID0gWzEsIGJhdGNoLCBvdXRDaGFubmVsc107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4UmVzaGFwZWQgPSBpbnB1dHNbMF0ucmVzaGFwZShbYmF0Y2gsIGlucHV0SGVpZ2h0ICogaW5wdXRXaWR0aCwgaW5wdXRDaGFubmVsc10pO1xuICAgICAgICB3UmVzaGFwZWQgPSB0cmFuc3Bvc2VkV2VpZ2h0LnJlc2hhcGUoWzEsIGlucHV0Q2hhbm5lbHMsIG91dENoYW5uZWxzXSk7XG4gICAgICAgIG1hdG11bE91dHB1dFNoYXBlID0gW2JhdGNoLCBvdXRIZWlnaHQgKiBvdXRXaWR0aCwgb3V0Q2hhbm5lbHNdO1xuICAgICAgfVxuICAgICAgbWF0bXVsSW5wdXRzLnB1c2goeFJlc2hhcGVkKTtcbiAgICAgIG1hdG11bElucHV0cy5wdXNoKHdSZXNoYXBlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHhSZXNoYXBlZCA9IGlucHV0c1swXS5yZXNoYXBlKFtiYXRjaCwgaW5wdXRDaGFubmVscywgaW5wdXRIZWlnaHQgKiBpbnB1dFdpZHRoXSk7XG4gICAgICB3UmVzaGFwZWQgPSBpbnB1dHNbMV0ucmVzaGFwZShbMSwgb3V0Q2hhbm5lbHMsIGlucHV0Q2hhbm5lbHNdKTtcbiAgICAgIG1hdG11bE91dHB1dFNoYXBlID0gW2JhdGNoLCBvdXRDaGFubmVscywgb3V0SGVpZ2h0ICogb3V0V2lkdGhdO1xuICAgICAgbWF0bXVsSW5wdXRzLnB1c2god1Jlc2hhcGVkKTtcbiAgICAgIG1hdG11bElucHV0cy5wdXNoKHhSZXNoYXBlZCk7XG4gICAgfVxuICAgIGlmIChoYXNCaWFzKSB7XG4gICAgICBtYXRtdWxJbnB1dHMucHVzaChpbnB1dHNbMl0pO1xuICAgIH1cbiAgICBjb25zdCBOID0gbWF0bXVsT3V0cHV0U2hhcGVbMl07XG4gICAgY29uc3QgSyA9IG1hdG11bElucHV0c1swXS5kaW1zW21hdG11bElucHV0c1swXS5kaW1zLmxlbmd0aCAtIDFdO1xuICAgIC8vIFR1bmUgdGhlIHRocmVzaG9sZC5cbiAgICBpZiAoTiA8IDggJiYgSyA8IDgpIHtcbiAgICAgIGNvbnRleHQuY29tcHV0ZShcbiAgICAgICAgY3JlYXRlTmFpdmVNYXRtdWxQcm9ncmFtSW5mbyhcbiAgICAgICAgICBtYXRtdWxJbnB1dHMsXG4gICAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgICBvdXRwdXRTaGFwZSxcbiAgICAgICAgICBtYXRtdWxPdXRwdXRTaGFwZSxcbiAgICAgICAgICBpc0NoYW5uZWxzTGFzdCxcbiAgICAgICAgICBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbixcbiAgICAgICAgKSxcbiAgICAgICAgeyBpbnB1dHM6IG1hdG11bElucHV0cyB9LFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5jb21wdXRlKFxuICAgICAgICBjcmVhdGVNYXRtdWxQcm9ncmFtSW5mbyhcbiAgICAgICAgICBtYXRtdWxJbnB1dHMsXG4gICAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgICBvdXRwdXRTaGFwZSxcbiAgICAgICAgICBtYXRtdWxPdXRwdXRTaGFwZSxcbiAgICAgICAgICBpc0NoYW5uZWxzTGFzdCxcbiAgICAgICAgICBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbixcbiAgICAgICAgKSxcbiAgICAgICAgeyBpbnB1dHM6IG1hdG11bElucHV0cyB9LFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVE9ETzogaW1wbGVtZW50IGNvbnYyZFdpdGhJbTJDb2woKVxuXG4gIGNvbnN0IHNlcXVlbnRpYWxBY2Nlc3NCeVRocmVhZHMgPSAvKiBiYWNrZW5kLmFkYXB0ZXJJbmZvLmlzSW50ZWwoKSAqLyB0cnVlO1xuXG4gIC8vIFNURVAuMTogdHJhbnNwb3NlIHdlaWdodFxuICBjb25zdCB0cmFuc3Bvc2VkV2VpZ2h0ID1cbiAgICAoY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUIGFzIFRlbnNvclZpZXcgfCB1bmRlZmluZWQpID8/XG4gICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKGlucHV0c1sxXSwgd2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlKSwge1xuICAgICAgaW5wdXRzOiBbMV0sXG4gICAgICBvdXRwdXRzOiBbYXR0cmlidXRlcy53SXNDb25zdCA/IC0yIDogLTFdLFxuICAgIH0pWzBdO1xuICBpZiAoYXR0cmlidXRlcy53SXNDb25zdCAmJiAhY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUKSB7XG4gICAgY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUID0gdHJhbnNwb3NlZFdlaWdodDtcbiAgfVxuXG4gIC8vIFNURVAuMjogcHJlcGFyZSByZXNoYXBlZCBpbnB1dHNcbiAgY29uc3QgY29udklucHV0cyA9IFtpbnB1dHNbMF0sIHRyYW5zcG9zZWRXZWlnaHRdO1xuICBpZiAoaGFzQmlhcykge1xuICAgIGNvbnZJbnB1dHMucHVzaChpbnB1dHNbMl0pO1xuICB9XG5cbiAgLy8gU1RFUC4zOiBjb21wdXRlIG1hdG11bFxuICBjb25zdCBkaW1BT3V0ZXIgPSBpc0NoYW5uZWxzTGFzdCA/IG91dEhlaWdodCAqIG91dFdpZHRoIDogb3V0Q2hhbm5lbHM7XG4gIGNvbnN0IGRpbUJPdXRlciA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0Q2hhbm5lbHMgOiBvdXRIZWlnaHQgKiBvdXRXaWR0aDtcbiAgY29uc3QgZGltSW5uZXIgPSB3ZWlnaHRIZWlnaHQgKiB3ZWlnaHRXaWR0aCAqIGlucHV0Q2hhbm5lbHM7XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVDb252MkRNYXRNdWxQcm9ncmFtSW5mbyhcbiAgICAgIGNvbnZJbnB1dHMsXG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgb3V0cHV0U2hhcGUsXG4gICAgICBkaW1BT3V0ZXIsXG4gICAgICBkaW1CT3V0ZXIsXG4gICAgICBkaW1Jbm5lcixcbiAgICAgIGhhc0JpYXMsXG4gICAgICBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzLFxuICAgICAgc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24sXG4gICAgKSxcbiAgICB7IGlucHV0czogY29udklucHV0cyB9LFxuICApO1xufTtcblxuY29uc3QgY29udjFkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICAvLyBleHRlbmQgdGhlIGlucHV0IHRvIDJEIGJ5IGFkZGluZyBIIGRpbWVuc2lvblxuICBjb25zdCBpc0NoYW5uZWxMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcbiAgY29uc3QgaW5wdXRzID0gW1xuICAgIGNvbnRleHQuaW5wdXRzWzBdLnJlc2hhcGUoXG4gICAgICBpc0NoYW5uZWxMYXN0XG4gICAgICAgID8gLy8gW04sIFcsIENdIC0+IFtOLCBIPTEsIFcsIENdXG4gICAgICAgICAgW2NvbnRleHQuaW5wdXRzWzBdLmRpbXNbMF0sIDEsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMV0sIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMl1dXG4gICAgICAgIDogLy8gW04sIEMsIFddIC0+IFtOLCBDLCBIPTEsIFddXG4gICAgICAgICAgW2NvbnRleHQuaW5wdXRzWzBdLmRpbXNbMF0sIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMV0sIDEsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMl1dLFxuICAgICksXG4gICAgLy9bRklMVEVSX09VVF9DSEFOTkVMLCBGSUxURVJfSU5fQ0hBTk5FTCwga1ddIC0+IFtGSUxURVJfT1VUX0NIQU5ORUwsIEZJTFRFUl9JTl9DSEFOTkVMLCBrSD0xLCBrV11cbiAgICBjb250ZXh0LmlucHV0c1sxXS5yZXNoYXBlKFtjb250ZXh0LmlucHV0c1sxXS5kaW1zWzBdLCBjb250ZXh0LmlucHV0c1sxXS5kaW1zWzFdLCAxLCBjb250ZXh0LmlucHV0c1sxXS5kaW1zWzJdXSksXG4gIF07XG4gIGlmIChjb250ZXh0LmlucHV0cy5sZW5ndGggPT09IDMpIHtcbiAgICBpbnB1dHMucHVzaChjb250ZXh0LmlucHV0c1syXSk7XG4gIH1cbiAgY29uc3QgcGFkcyA9IFswLCBhdHRyaWJ1dGVzLnBhZHNbMF0sIDAsIGF0dHJpYnV0ZXMucGFkc1sxXV07XG4gIGNvbnN0IHN0cmlkZXMgPSBbMV0uY29uY2F0KGF0dHJpYnV0ZXMuc3RyaWRlcyk7XG4gIGNvbnN0IGRpbGF0aW9ucyA9IFsxXS5jb25jYXQoYXR0cmlidXRlcy5kaWxhdGlvbnMpO1xuICBjb25zdCBrZXJuZWxTaGFwZSA9IFsxXS5jb25jYXQoYXR0cmlidXRlcy5rZXJuZWxTaGFwZSk7XG4gIGNvbnN0IGFkanVzdGVkQXR0cmlidXRlcyA9IGdldEFkanVzdGVkQ29udkF0dHJpYnV0ZXMoXG4gICAgeyAuLi5hdHRyaWJ1dGVzLCBwYWRzLCBzdHJpZGVzLCBkaWxhdGlvbnMsIGtlcm5lbFNoYXBlIH0sXG4gICAgaW5wdXRzLFxuICApO1xuICBjb252MmQoY29udGV4dCwgaW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMsIChvdXRwdXRTaGFwZSkgPT5cbiAgICBpc0NoYW5uZWxMYXN0ID8gW291dHB1dFNoYXBlWzBdLCBvdXRwdXRTaGFwZVsyXSwgb3V0cHV0U2hhcGVbM11dIDogW291dHB1dFNoYXBlWzBdLCBvdXRwdXRTaGFwZVsxXSwgb3V0cHV0U2hhcGVbM11dLFxuICApO1xufTtcblxuY29uc3QgY29udjNkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogQ29udkF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29uc3QgZm9ybWF0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJyA/ICdjaGFubmVsc0xhc3QnIDogJ2NoYW5uZWxzRmlyc3QnO1xuICBjb25zdCBhZGp1c3RlZEF0dHJpYnV0ZXMgPSBnZXRBZGp1c3RlZENvbnZBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIGlucHV0cyk7XG4gIGNvbnN0IHBhZHMgPSBhdHRyaWJ1dGVzLmF1dG9QYWQgPT09ICdOT1RTRVQnID8gYXR0cmlidXRlcy5wYWRzIDogYXR0cmlidXRlcy5hdXRvUGFkO1xuICBjb25zdCBjb252SW5mbyA9IGNvbXB1dGVDb252M0RJbmZvKFxuICAgIGlucHV0c1swXS5kaW1zIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgaW5wdXRzWzFdLmRpbXMgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICBhdHRyaWJ1dGVzLnN0cmlkZXMgYXMgbnVtYmVyIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgIGF0dHJpYnV0ZXMuZGlsYXRpb25zIGFzIG51bWJlciB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbiAgICBwYWRzIGFzIHN0cmluZyB8IG51bWJlcltdLFxuICAgIGZhbHNlLFxuICAgIGZvcm1hdCxcbiAgKTtcbiAgY29udGV4dC5jb21wdXRlKFxuICAgIGNyZWF0ZUNvbnYzRE5haXZlUHJvZ3JhbUluZm8oXG4gICAgICBpbnB1dHMsXG4gICAgICBhZGp1c3RlZEF0dHJpYnV0ZXMsXG4gICAgICBjb252SW5mby5vdXRTaGFwZSxcbiAgICAgIFtjb252SW5mby5maWx0ZXJEZXB0aCwgY29udkluZm8uZmlsdGVySGVpZ2h0LCBjb252SW5mby5maWx0ZXJXaWR0aF0sXG4gICAgICBbY29udkluZm8ucGFkSW5mby5mcm9udCwgY29udkluZm8ucGFkSW5mby50b3AsIGNvbnZJbmZvLnBhZEluZm8ubGVmdF0sXG4gICAgICBmb3JtYXQsXG4gICAgKSxcbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBjb252ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBDb252QXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIGlmIChjb250ZXh0LmlucHV0c1swXS5kaW1zLmxlbmd0aCA9PT0gMykge1xuICAgIGNvbnYxZChjb250ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIGlmIChjb250ZXh0LmlucHV0c1swXS5kaW1zLmxlbmd0aCA9PT0gNSkge1xuICAgIGNvbnYzZChjb250ZXh0LCBjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYWRqdXN0ZWRBdHRyaWJ1dGVzID0gZ2V0QWRqdXN0ZWRDb252QXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBjb250ZXh0LmlucHV0cyk7XG4gICAgY29udjJkKGNvbnRleHQsIGNvbnRleHQuaW5wdXRzLCBhZGp1c3RlZEF0dHJpYnV0ZXMpO1xuICB9XG59O1xuIiwgIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLy8gc2FtcGxlZCBmcm9tIFtAdGVuc29yZmxvdy90ZmpzXSB0ZmpzLWJhY2tlbmQtd2ViZ3B1L3NyYy9jb252X2JhY2twcm9wX21tX3dlYmdwdS50c1xuLy9cbi8vIG1vZGlmaWVkIHRvIGZpdCB0aGUgbmVlZHMgb2YgdGhlIHByb2plY3RcblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBMT0dfREVCVUcgfSBmcm9tICcuLi8uLi8uLi9sb2cnO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQge1xuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vY29udi10cmFuc3Bvc2UnO1xuaW1wb3J0IHsgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zLCBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXNEYXRhLCBnZXRBY3RpdmF0aW9uU25pcHBldCB9IGZyb20gJy4uL2Z1c2UtdXRpbHMnO1xuXG5pbXBvcnQgeyBiaWFzU25pcHBldCB9IGZyb20gJy4vYWN0aXZhdGlvbl91dGlsJztcbmltcG9ydCB7IHV0aWxGdW5jdGlvbnMgfSBmcm9tICcuL2NvbnZfdXRpbCc7XG5pbXBvcnQgeyBtYWtlTWF0TXVsUGFja2VkU291cmNlLCBtYWtlTWF0TXVsUGFja2VkVmVjNFNvdXJjZSB9IGZyb20gJy4vbWF0bXVsX3BhY2tlZF93ZWJncHUnO1xuXG5jb25zdCBjb252MmRUcmFuc3Bvc2VDb21tb25TbmlwcGV0ID0gKFxuICBpc0NoYW5uZWxzTGFzdDogYm9vbGVhbixcbiAgYWRkQmlhcyA9IGZhbHNlLFxuICBhdHRyaWJ1dGVzOiBDb252VHJhbnNwb3NlQXR0cmlidXRlcyxcbiAgdHlwZTogc3RyaW5nLFxuICBpbm5lckVsZW1lbnRTaXplID0gNCxcbik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGdldFdTbmlwcGV0ID0gKGlubmVyRWxlbWVudFNpemU6IG51bWJlcikgPT4ge1xuICAgIHN3aXRjaCAoaW5uZXJFbGVtZW50U2l6ZSkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gJ3JldHVybiB3W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkLCB2ZWM0PGkzMj4odW5pZm9ybXMud19zaGFwZSkpXTsnO1xuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgbGV0IGNvb3JkMSA9IHZlYzQ8aTMyPihjb29yZFgsIGNvb3JkWSwgY29sICsgMSwgcm93SW5uZXIpO1xuICAgICAgICAgICAgbGV0IGNvb3JkMiA9IHZlYzQ8aTMyPihjb29yZFgsIGNvb3JkWSwgY29sICsgMiwgcm93SW5uZXIpO1xuICAgICAgICAgICAgbGV0IGNvb3JkMyA9IHZlYzQ8aTMyPihjb29yZFgsIGNvb3JkWSwgY29sICsgMywgcm93SW5uZXIpO1xuICAgICAgICAgICAgbGV0IHYwID0gd1tnZXRJbmRleEZyb21Db29yZHM0RChjb29yZCwgdmVjNDxpMzI+KHVuaWZvcm1zLndfc2hhcGUpKV07XG4gICAgICAgICAgICBsZXQgdjEgPSB3W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkMSwgdmVjNDxpMzI+KHVuaWZvcm1zLndfc2hhcGUpKV07XG4gICAgICAgICAgICBsZXQgdjIgPSB3W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkMiwgdmVjNDxpMzI+KHVuaWZvcm1zLndfc2hhcGUpKV07XG4gICAgICAgICAgICBsZXQgdjMgPSB3W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkMywgdmVjNDxpMzI+KHVuaWZvcm1zLndfc2hhcGUpKV07XG4gICAgICAgICAgICByZXR1cm4gJHt0eXBlfSh2MCwgdjEsIHYyLCB2Myk7XG4gICAgICAgICAgICBgO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7aW5uZXJFbGVtZW50U2l6ZX0gaXMgbm90IHN1cHBvcnRlZC5gKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGNvb3JkQVNuaXBwZXQgPSBpc0NoYW5uZWxzTGFzdFxuICAgID8gYFxuICAgICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCBpWFIsIGlYQywgeENoKTtcbiAgICAgIGBcbiAgICA6IGBcbiAgICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgeENoLCBpWFIsIGlYQyk7XG4gICAgICBgO1xuXG4gIGNvbnN0IGNvb3JkUmVzU25pcHBldCA9IGlzQ2hhbm5lbHNMYXN0XG4gICAgPyBgXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcbiAgICAgIGJhdGNoLFxuICAgICAgcm93IC8gb3V0V2lkdGgsXG4gICAgICByb3cgJSBvdXRXaWR0aCxcbiAgICAgIGNvbCk7XG4gICAgYFxuICAgIDogYFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXG4gICAgICBiYXRjaCxcbiAgICAgIHJvdyxcbiAgICAgIGNvbCAvIG91dFdpZHRoLFxuICAgICAgY29sICUgb3V0V2lkdGgpO1xuICAgIGA7XG5cbiAgY29uc3QgeEhlaWdodCA9IGlzQ2hhbm5lbHNMYXN0ID8gJ2kzMih1bmlmb3Jtcy54X3NoYXBlWzFdKScgOiAnaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pJztcbiAgY29uc3QgeFdpZHRoID0gaXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pJyA6ICdpMzIodW5pZm9ybXMueF9zaGFwZVszXSknO1xuICBjb25zdCByb3cgPSBpc0NoYW5uZWxzTGFzdCA/ICdyb3cnIDogJ2NvbCc7XG4gIGNvbnN0IGNvbCA9IGlzQ2hhbm5lbHNMYXN0ID8gJ2NvbCcgOiAncm93JztcblxuICBjb25zdCByZWFkQVNuaXBwZXQgPSBgXG4gICAgICBsZXQgaW5DaGFubmVscyA9ICR7aXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnhfc2hhcGVbM10pJyA6ICdpMzIodW5pZm9ybXMueF9zaGFwZVsxXSknfTtcbiAgICAgIGxldCBvdXRXaWR0aCA9ICR7aXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsyXSknIDogJ2kzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbM10pJ307XG4gICAgICBsZXQgb3V0Um93ID0gJHtyb3d9IC8gb3V0V2lkdGg7XG4gICAgICBsZXQgb3V0Q29sID0gJHtyb3d9ICUgb3V0V2lkdGg7XG5cbiAgICAgIGxldCBXUm93ID0gJHtjb2x9IC8gKHVuaWZvcm1zLmZpbHRlcl9kaW1zWzFdICogaW5DaGFubmVscyk7XG4gICAgICBsZXQgV0NvbCA9ICR7Y29sfSAvIGluQ2hhbm5lbHMgJSB1bmlmb3Jtcy5maWx0ZXJfZGltc1sxXTtcbiAgICAgIGxldCB4UiA9IGYzMihvdXRSb3cgLSB1bmlmb3Jtcy5wYWRzWzBdICsgdW5pZm9ybXMuZGlsYXRpb25zWzBdICogV1JvdykgLyBmMzIodW5pZm9ybXMuc3RyaWRlc1swXSk7XG4gICAgICBsZXQgeEMgPSBmMzIob3V0Q29sIC0gdW5pZm9ybXMucGFkc1sxXSArIHVuaWZvcm1zLmRpbGF0aW9uc1sxXSAqIFdDb2wpIC8gZjMyKHVuaWZvcm1zLnN0cmlkZXNbMV0pO1xuICAgICAgaWYgKHhSIDwgMC4wIHx8IHhSID49IGYzMigke3hIZWlnaHR9KSB8fCBmcmFjdCh4UikgPiAwLjApIHtcbiAgICAgICAgcmV0dXJuICR7dHlwZX0oMC4wKTtcbiAgICAgIH1cbiAgICAgIGlmICh4QyA8IDAuMCB8fCB4QyA+PSBmMzIoJHt4V2lkdGh9KSB8fCBmcmFjdCh4QykgPiAwLjApIHtcbiAgICAgICAgcmV0dXJuICR7dHlwZX0oMC4wKTtcbiAgICAgIH1cbiAgICAgIGxldCBpWFIgPSBpMzIoeFIpO1xuICAgICAgbGV0IGlYQyA9IGkzMih4Qyk7XG4gICAgICBsZXQgeENoID0gJHtjb2x9ICUgaW5DaGFubmVscztcbiAgICAgICR7Y29vcmRBU25pcHBldH1cbiAgICAgIHJldHVybiB4W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkLCB2ZWM0PGkzMj4odW5pZm9ybXMueF9zaGFwZSkpLyR7aW5uZXJFbGVtZW50U2l6ZX1dO2A7XG5cbiAgY29uc3Qgc2FtcGxlQSA9IGlzQ2hhbm5lbHNMYXN0XG4gICAgPyBgXG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2lubmVyRWxlbWVudFNpemV9O1xuICAgICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9pbm5lcikge1xuICAgICAgICAke3JlYWRBU25pcHBldH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAke3R5cGV9KDAuMCk7YFxuICAgIDogYFxuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtpbm5lckVsZW1lbnRTaXplfTtcbiAgICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcbiAgICAgICAgJHtyZWFkQVNuaXBwZXR9XG4gICAgICB9XG4gICAgICByZXR1cm4gJHt0eXBlfSgwLjApO2A7XG5cbiAgY29uc3Qgc2FtcGxlVyA9IGBcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZX07XG4gICAgICBsZXQgaW5DaGFubmVscyA9ICR7aXNDaGFubmVsc0xhc3QgPyAnaTMyKHVuaWZvcm1zLnhfc2hhcGVbM10pJyA6ICdpMzIodW5pZm9ybXMueF9zaGFwZVsxXSknfTtcbiAgICAgIGxldCBjb29yZFggPSB1bmlmb3Jtcy5maWx0ZXJfZGltc1swXSAtIDEgLSByb3cgLyAodW5pZm9ybXMuZmlsdGVyX2RpbXNbMV0gKiBpbkNoYW5uZWxzKTtcbiAgICAgIGxldCBjb29yZFkgPSB1bmlmb3Jtcy5maWx0ZXJfZGltc1sxXSAtIDEgLSAocm93IC8gaW5DaGFubmVscykgJSB1bmlmb3Jtcy5maWx0ZXJfZGltc1sxXTtcbiAgICAgIGlmICgke1xuICAgICAgICBpc0NoYW5uZWxzTGFzdFxuICAgICAgICAgID8gJ3JvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcidcbiAgICAgICAgICA6ICdyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXInXG4gICAgICB9ICAmJiBjb29yZFggPj0gMCAmJiBjb29yZFkgPj0gMCkge1xuICAgICAgICBsZXQgcm93SW5uZXIgPSByb3cgJSBpbkNoYW5uZWxzO1xuICAgICAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oY29vcmRYLCBjb29yZFksIGNvbCwgcm93SW5uZXIpO1xuICAgICAgICAke2dldFdTbmlwcGV0KGlubmVyRWxlbWVudFNpemUpfVxuICAgICAgfVxuICAgICAgcmV0dXJuICR7dHlwZX0oMC4wKTtcbiAgICAgIGA7XG5cbiAgY29uc3QgYXBwbHlBY3RpdmF0aW9uID0gZ2V0QWN0aXZhdGlvblNuaXBwZXQoYXR0cmlidXRlcywgdHlwZSk7XG4gIGNvbnN0IHVzZXJDb2RlID0gYFxuICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke3R5cGV9IHtcbiAgICAke2lzQ2hhbm5lbHNMYXN0ID8gc2FtcGxlQSA6IHNhbXBsZVd9XG4gIH1cblxuICBmbiBtbV9yZWFkQihiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke3R5cGV9IHtcbiAgICAke2lzQ2hhbm5lbHNMYXN0ID8gc2FtcGxlVyA6IHNhbXBsZUF9XG4gIH1cblxuICBmbiBtbV93cml0ZShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyLCB2YWx1ZUlucHV0IDogJHt0eXBlfSkge1xuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7aW5uZXJFbGVtZW50U2l6ZX07XG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKSB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZUlucHV0O1xuICAgICAgbGV0IG91dFdpZHRoID0gJHtpc0NoYW5uZWxzTGFzdCA/ICdpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzJdKScgOiAnaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVszXSknfTtcbiAgICAgICR7Y29vcmRSZXNTbmlwcGV0fVxuICAgICAgJHtiaWFzU25pcHBldChhZGRCaWFzKX1cbiAgICAgICR7YXBwbHlBY3RpdmF0aW9ufVxuICAgICAgcmVzdWx0W2dldEluZGV4RnJvbUNvb3JkczREKGNvb3JkcywgdmVjNDxpMzI+KHVuaWZvcm1zLnJlc3VsdF9zaGFwZSkpLyR7aW5uZXJFbGVtZW50U2l6ZX1dID0gdmFsdWU7XG4gICAgfVxuICB9YDtcbiAgcmV0dXJuIHVzZXJDb2RlO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUNvbnYyRFRyYW5zcG9zZU1hdE11bFByb2dyYW1JbmZvID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMsXG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgZGltQU91dGVyOiBudW1iZXIsXG4gIGRpbUJPdXRlcjogbnVtYmVyLFxuICBkaW1Jbm5lcjogbnVtYmVyLFxuICBoYXNCaWFzOiBib29sZWFuLFxuICBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzOiBib29sZWFuLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gIGNvbnN0IGluQ2hhbm5lbHMgPSBpc0NoYW5uZWxzTGFzdCA/IGlucHV0c1swXS5kaW1zWzNdIDogaW5wdXRzWzBdLmRpbXNbMV07XG4gIGNvbnN0IGJhdGNoU2l6ZSA9IG91dHB1dFNoYXBlWzBdO1xuICBjb25zdCBvdXRXaWR0aCA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0cHV0U2hhcGVbMl0gOiBvdXRwdXRTaGFwZVszXTtcbiAgY29uc3Qgb3V0SGVpZ2h0ID0gaXNDaGFubmVsc0xhc3QgPyBvdXRwdXRTaGFwZVsxXSA6IG91dHB1dFNoYXBlWzJdO1xuICBjb25zdCBvdXRDaGFubmVscyA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0cHV0U2hhcGVbM10gOiBvdXRwdXRTaGFwZVsxXTtcbiAgLy8gVE9ETzogZW5hYmxlIHZlYzQgZm9yIE5DSFdcbiAgY29uc3QgaXNWZWM0ID0gaXNDaGFubmVsc0xhc3QgJiYgaW5DaGFubmVscyAlIDQgPT09IDAgJiYgaW5DaGFubmVscyAlIDMgJiYgb3V0Q2hhbm5lbHMgJSA0ID09PSAwO1xuXG4gIC8vIFRPRE86IGZpbmUgdHVuZSBzaXplXG4gIGNvbnN0IGRpc3BhdGNoWCA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0Q2hhbm5lbHMgOiBvdXRXaWR0aCAqIG91dEhlaWdodDtcbiAgY29uc3QgZGlzcGF0Y2hZID0gaXNDaGFubmVsc0xhc3QgPyBvdXRXaWR0aCAqIG91dEhlaWdodCA6IG91dENoYW5uZWxzO1xuICBjb25zdCB3b3JrR3JvdXBTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbOCwgOCwgMV07XG4gIGNvbnN0IGVsZW1lbnRzUGVyVGhyZWFkID0gZGltQU91dGVyIDw9IDggPyBbNCwgMSwgMV0gOiBbNCwgNCwgMV07XG4gIGNvbnN0IGRpc3BhdGNoID0gW1xuICAgIE1hdGguY2VpbChkaXNwYXRjaFggLyB3b3JrR3JvdXBTaXplWzBdIC8gZWxlbWVudHNQZXJUaHJlYWRbMF0pLFxuICAgIE1hdGguY2VpbChkaXNwYXRjaFkgLyB3b3JrR3JvdXBTaXplWzFdIC8gZWxlbWVudHNQZXJUaHJlYWRbMV0pLFxuICAgIE1hdGguY2VpbChiYXRjaFNpemUgLyB3b3JrR3JvdXBTaXplWzJdIC8gZWxlbWVudHNQZXJUaHJlYWRbMl0pLFxuICBdO1xuXG4gIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbY29udl9iYWNrcHJvcF9tbV93ZWJncHVdIGRpc3BhdGNoID0gJHtkaXNwYXRjaH1gKTtcblxuICBjb25zdCBpbm5lckVsZW1lbnRTaXplID0gaXNWZWM0ID8gNCA6IDE7XG4gIGNvbnN0IHRpbGVJbm5lciA9IE1hdGgubWF4KHdvcmtHcm91cFNpemVbMF0gKiBpbm5lckVsZW1lbnRTaXplLCB3b3JrR3JvdXBTaXplWzFdKTtcbiAgY29uc3QgY29tcG9uZW50cyA9IGlzVmVjNCA/IDQgOiAxO1xuICBjb25zdCBmaWx0ZXJEaW1zID0gW2F0dHJpYnV0ZXMua2VybmVsU2hhcGVbaXNDaGFubmVsc0xhc3QgPyAxIDogMl0sIGF0dHJpYnV0ZXMua2VybmVsU2hhcGVbaXNDaGFubmVsc0xhc3QgPyAyIDogM11dO1xuICBjb25zdCBlZmZlY3RpdmVGaWx0ZXJEaW1zID0gW1xuICAgIGZpbHRlckRpbXNbMF0gKyAoYXR0cmlidXRlcy5kaWxhdGlvbnNbMF0gPD0gMSA/IDAgOiAoZmlsdGVyRGltc1swXSAtIDEpICogKGF0dHJpYnV0ZXMuZGlsYXRpb25zWzBdIC0gMSkpLFxuICAgIGZpbHRlckRpbXNbMV0gKyAoYXR0cmlidXRlcy5kaWxhdGlvbnNbMV0gPD0gMSA/IDAgOiAoZmlsdGVyRGltc1sxXSAtIDEpICogKGF0dHJpYnV0ZXMuZGlsYXRpb25zWzFdIC0gMSkpLFxuICBdO1xuICBjb25zdCBwYWRzID0gW1xuICAgIGVmZmVjdGl2ZUZpbHRlckRpbXNbMF0gLSAxIC0gTWF0aC5mbG9vcigoYXR0cmlidXRlcy5wYWRzWzBdICsgYXR0cmlidXRlcy5wYWRzWzJdKSAvIDIpLFxuICAgIGVmZmVjdGl2ZUZpbHRlckRpbXNbMV0gLSAxIC0gTWF0aC5mbG9vcigoYXR0cmlidXRlcy5wYWRzWzFdICsgYXR0cmlidXRlcy5wYWRzWzNdKSAvIDIpLFxuICBdO1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBkaW1BT3V0ZXIgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBkaW1CT3V0ZXIgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLmludDMyLCBkYXRhOiBkaW1Jbm5lciB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuc3RyaWRlcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuZGlsYXRpb25zIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogZmlsdGVyRGltcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IHBhZHMgfSxcbiAgXTtcbiAgYXBwZW5kQWN0aXZhdGlvblVuaWZvcm1zRGF0YShhdHRyaWJ1dGVzLCBwcm9ncmFtVW5pZm9ybXMpO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgaW5wdXRzWzFdLmRpbXMpKTtcblxuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuaycsICdyYW5rJ107XG4gIGlmIChoYXNCaWFzKSB7XG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzJdLmRpbXMpKTtcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCdyYW5rJyk7XG4gIH1cbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpKTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCB3ID0gaW5wdXRWYXJpYWJsZSgndycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoLCAxKTtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgncmVzdWx0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IGlucHV0VmFyaWFibGVzID0gW3gsIHddO1xuXG4gICAgbGV0IGRlY2xhcmVGdW5jdGlvbnMgPSAnJztcbiAgICBpZiAoaGFzQmlhcykge1xuICAgICAgY29uc3QgYmlhcyA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKGJpYXMpO1xuICAgICAgZGVjbGFyZUZ1bmN0aW9ucyArPSBgXG4gICAgICAgICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IHZlYzQ8aTMyPikgLT4gJHtiaWFzLnR5cGUudmFsdWV9IHtcbiAgICAgICAgICAgIHJldHVybiBiaWFzW2Nvb3Jkcy4ke2lzQ2hhbm5lbHNMYXN0ID8gJ3cnIDogJ3knfSR7aXNWZWM0ID8gJy8gNCcgOiAnJ31dO1xuICAgICAgICAgIH1gO1xuICAgIH1cblxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgIHsgbmFtZTogJ2RpbV9hX291dGVyJywgdHlwZTogJ2kzMicgfSxcbiAgICAgIHsgbmFtZTogJ2RpbV9iX291dGVyJywgdHlwZTogJ2kzMicgfSxcbiAgICAgIHsgbmFtZTogJ2RpbV9pbm5lcicsIHR5cGU6ICdpMzInIH0sXG4gICAgICB7IG5hbWU6ICdzdHJpZGVzJywgdHlwZTogJ2kzMicsIGxlbmd0aDogMiB9LFxuICAgICAgeyBuYW1lOiAnZGlsYXRpb25zJywgdHlwZTogJ2kzMicsIGxlbmd0aDogMiB9LFxuICAgICAgeyBuYW1lOiAnZmlsdGVyX2RpbXMnLCB0eXBlOiAnaTMyJywgbGVuZ3RoOiBmaWx0ZXJEaW1zLmxlbmd0aCB9LFxuICAgICAgeyBuYW1lOiAncGFkcycsIHR5cGU6ICdpMzInLCBsZW5ndGg6IHBhZHMubGVuZ3RoIH0sXG4gICAgXTtcbiAgICBhcHBlbmRBY3RpdmF0aW9uVW5pZm9ybXMoYXR0cmlidXRlcywgdW5pZm9ybXMpO1xuICAgIGNvbnN0IGVsZW1UeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0c1swXS5kYXRhVHlwZSwgMSk7XG4gICAgaWYgKGVsZW1UeXBlICE9PSAnZjE2JyAmJiBlbGVtVHlwZSAhPT0gJ2YzMicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZWxlbVR5cGUgJHtlbGVtVHlwZX0gaXMgbm90IHN1cHBvcnRlZC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGBcbiAgICAgICAgJHt1dGlsRnVuY3Rpb25zKCd1bmlmb3Jtcy5yZXN1bHRfc3RyaWRlcycpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfTtcbiAgICAgICAgJHtkZWNsYXJlRnVuY3Rpb25zfVxuICAgICAgICAke2NvbnYyZFRyYW5zcG9zZUNvbW1vblNuaXBwZXQoaXNDaGFubmVsc0xhc3QsIGhhc0JpYXMsIGF0dHJpYnV0ZXMsIHgudHlwZS52YWx1ZSwgaW5uZXJFbGVtZW50U2l6ZSl9XG4gICAgICAgICR7XG4gICAgICAgICAgaXNWZWM0XG4gICAgICAgICAgICA/IG1ha2VNYXRNdWxQYWNrZWRWZWM0U291cmNlKFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzUGVyVGhyZWFkLFxuICAgICAgICAgICAgICAgIHdvcmtHcm91cFNpemUsXG4gICAgICAgICAgICAgICAgZWxlbVR5cGUsXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICFpc0NoYW5uZWxzTGFzdCxcbiAgICAgICAgICAgICAgICB0aWxlSW5uZXIsXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogbWFrZU1hdE11bFBhY2tlZFNvdXJjZShcbiAgICAgICAgICAgICAgICBlbGVtZW50c1BlclRocmVhZCxcbiAgICAgICAgICAgICAgICB3b3JrR3JvdXBTaXplLFxuICAgICAgICAgICAgICAgIGVsZW1UeXBlLFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAhaXNDaGFubmVsc0xhc3QsXG4gICAgICAgICAgICAgICAgdGlsZUlubmVyLFxuICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzLFxuICAgICAgICAgICAgICApXG4gICAgICAgIH1gO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0NvbnYyRFRyYW5zcG9zZU1hdE11bCcsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX07JHtlbGVtZW50c1BlclRocmVhZH07JHt3b3JrR3JvdXBTaXplfTske2lzVmVjNH1gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogZGlzcGF0Y2hbMF0sIHk6IGRpc3BhdGNoWzFdLCB6OiBkaXNwYXRjaFsyXSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG4iLCAiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vLyBzYW1wbGVkIGZyb20gW0B0ZW5zb3JmbG93L3RmanNdIHRmanMtYmFja2VuZC13ZWJncHUvc3JjL2NvbnZfYmFja3Byb3Bfd2ViZ3B1LnRzXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgTE9HX0RFQlVHIH0gZnJvbSAnLi4vLi4vLi4vbG9nJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi8uLi91dGlsJztcbmltcG9ydCB7IFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQge1xuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vY29udi10cmFuc3Bvc2UnO1xuXG5jb25zdCBjcmVhdGVDb252VHJhbnNwb3NlMkRPcFByb2dyYW1TaGFkZXJTb3VyY2UgPSAoXG4gIHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyLFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBoYXNCaWFzOiBib29sZWFuLFxuICBpczFEaW1lbnNpb25EaXNwYXRjaDogYm9vbGVhbixcbiAgaXNWZWM0ID0gZmFsc2UsXG4gIGRhdGFUeXBlOiBzdHJpbmcsXG4gIHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSxcbiAgaXNDaGFubmVsc0xhc3QgPSBmYWxzZSxcbik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHJvd0RpbSA9IGlzQ2hhbm5lbHNMYXN0ID8gMSA6IDI7XG4gIGNvbnN0IGNvbERpbSA9IGlzQ2hhbm5lbHNMYXN0ID8gMiA6IDM7XG4gIGNvbnN0IGNoYW5uZWxEaW0gPSBpc0NoYW5uZWxzTGFzdCA/IDMgOiAxO1xuICBjb25zdCB3b3JrUGVyVGhyZWFkID0gaXNWZWM0ID8gMiA6IDE7XG5cbiAgbGV0IGRlY2xhcmVGdW5jdGlvbnMgPSBgXG4gIGZuIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4IDogdTMyLCB2YWx1ZSA6ICR7aXNWZWM0ID8gYHZlYzQ8JHtkYXRhVHlwZX0+YCA6IGRhdGFUeXBlfSkge1xuICAgIHJlc3VsdFtmbGF0SW5kZXhdID0gJHtpc1ZlYzQgPyBgdmVjNDwke2RhdGFUeXBlfT5gIDogZGF0YVR5cGV9KHZhbHVlKTtcbiAgfWA7XG4gIGlmIChoYXNCaWFzKSB7XG4gICAgZGVjbGFyZUZ1bmN0aW9ucyArPSBgXG4gICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IHZlYzQ8dTMyPikgLT4gJHtpc1ZlYzQgPyBgdmVjNDwke2RhdGFUeXBlfT5gIDogZGF0YVR5cGV9IHtcbiAgICAgIHJldHVybiBiaWFzW2Nvb3Jkcy4ke2lzQ2hhbm5lbHNMYXN0ID8gJ3cnIDogJ3knfSR7aXNWZWM0ID8gJy8gNCcgOiAnJ31dO1xuICAgIH1gO1xuICB9XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBpc1ZlYzQgPyA0IDogMTtcbiAgY29uc3QgdyA9IGlucHV0VmFyaWFibGUoJ1cnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gIGNvbnN0IGR5ID0gaW5wdXRWYXJpYWJsZSgnRHknLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gIGNvbnN0IGlucHV0VmFyaWFibGVzID0gW2R5LCB3XTtcbiAgaWYgKGhhc0JpYXMpIHtcbiAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKGlucHV0VmFyaWFibGUoJ2JpYXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIFtvdXRwdXRTaGFwZVtjaGFubmVsRGltXV0ubGVuZ3RoLCBjb21wb25lbnRzKSk7XG4gIH1cbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ3Jlc3VsdCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcblxuICBjb25zdCBjb2RlU25pcHBldDQgPSBge1xuICAgICAgICBsZXQgYmF0Y2g6IHUzMiA9ICR7aXMxRGltZW5zaW9uRGlzcGF0Y2ggPyAnZ2xvYmFsX2lkLnonIDogJ3dvcmtncm91cF9pZC56J30gLyB1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbMV07XG4gICAgICAgIGxldCByID0gJHtpczFEaW1lbnNpb25EaXNwYXRjaCA/ICdnbG9iYWxfaWQueicgOiAnd29ya2dyb3VwX2lkLnonfSAlIHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsxXTtcbiAgICAgICAgbGV0IGMgPSAke2lzMURpbWVuc2lvbkRpc3BhdGNoID8gJ2dsb2JhbF9pZC55JyA6ICd3b3JrZ3JvdXBfaWQueSd9ICogJHt3b3JrUGVyVGhyZWFkfTtcbiAgICAgICAgbGV0IGQxOiB1MzIgPSAke2lzMURpbWVuc2lvbkRpc3BhdGNoID8gJ2dsb2JhbF9pZC54JyA6ICd3b3JrZ3JvdXBfaWQueCd9ICogNDtcblxuICAgICAgICBsZXQgZHlDb3JuZXIgPSB2ZWMyPGkzMj4oaTMyKHIpLCBpMzIoYykpIC0gdmVjMjxpMzI+KHVuaWZvcm1zLnBhZHMpO1xuXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQyKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBjb21wdXRlIGR4KHhSLCB4QywgZDEpLlxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgICAgdmFyIGRvdFByb2Q6IGFycmF5PHZlYzQ8JHtkYXRhVHlwZX0+LCAke3dvcmtQZXJUaHJlYWR9PjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke3dvcmtQZXJUaHJlYWR9OyBpKyspIHtcbiAgICAgICAgICBkb3RQcm9kW2ldID0gdmVjNDwke2RhdGFUeXBlfT4oMC4wKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB3UjogdTMyID0gMDsgd1IgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1swXTsgd1IgPSB3UiArIDEpIHtcbiAgICAgICAgICB2YXIgZHlSID0gKCR7ZGF0YVR5cGV9KGR5Q29ybmVyLngpICsgJHtkYXRhVHlwZX0od1IpKSAvICR7ZGF0YVR5cGV9KHVuaWZvcm1zLnN0cmlkZXMueCk7XG4gICAgICAgICAgbGV0IHdSUGVybSA9IHVuaWZvcm1zLmZpbHRlcl9kaW1zWzBdIC0gMSAtIHdSO1xuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49ICR7ZGF0YVR5cGV9KHVuaWZvcm1zLkR5X3NoYXBlWzFdKSB8fFxuICAgICAgICAgICAgICBmcmFjdChkeVIpID4gMC4wIHx8IHdSUGVybSA8IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgaWR5UjogdTMyID0gdTMyKGR5Uik7XG5cbiAgICAgICAgICBmb3IgKHZhciB3QzogdTMyID0gMDsgd0MgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1sxXTsgd0MgPSB3QyArIDEpIHtcbiAgICAgICAgICAgIGxldCBkeUMgPSAoJHtkYXRhVHlwZX0oZHlDb3JuZXIueSkgKyAke2RhdGFUeXBlfSh3QykpIC8gJHtkYXRhVHlwZX0odW5pZm9ybXMuc3RyaWRlcy55KTtcbiAgICAgICAgICAgIGxldCBkeUMyID0gKCR7ZGF0YVR5cGV9KGR5Q29ybmVyLnkpICsgMS4wICsgJHtkYXRhVHlwZX0od0MpKSAvICR7ZGF0YVR5cGV9KHVuaWZvcm1zLnN0cmlkZXMueSk7XG4gICAgICAgICAgICBsZXQgd0NQZXJtID0gdW5pZm9ybXMuZmlsdGVyX2RpbXNbMV0gLSAxIC0gd0M7XG4gICAgICAgICAgICBpZiAod0NQZXJtIDwgMCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiRHlDVmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBiRHlDVmFsMiA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSAke2RhdGFUeXBlfSh1bmlmb3Jtcy5EeV9zaGFwZVsyXSkgfHxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XG4gICAgICAgICAgICAgIGJEeUNWYWwgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkeUMyIDwgMC4wIHx8IGR5QzIgPj0gJHtkYXRhVHlwZX0odW5pZm9ybXMuRHlfc2hhcGVbMl0pIHx8XG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDMikgPiAwLjApIHtcbiAgICAgICAgICAgICAgYkR5Q1ZhbDIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGlkeUM6IHUzMiA9IHUzMihkeUMpO1xuICAgICAgICAgICAgbGV0IGlkeUMyOiB1MzIgPSB1MzIoZHlDMik7XG4gICAgICAgICAgICBpZiAoYkR5Q1ZhbCAmJiBiRHlDVmFsMikge1xuICAgICAgICAgICAgICBsZXQgZDJMZW5ndGggPSB1bmlmb3Jtcy5EeV9zaGFwZVszXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgZDIgOnUzMiA9IDA7IGQyIDwgZDJMZW5ndGg7IGQyID0gZDIgKyA0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTAgPSAke3cuZ2V0KCd1MzIod1JQZXJtKScsICd1MzIod0NQZXJtKScsICdkMScsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMSA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxICsgMScsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMiA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxICsgMicsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMyA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxICsgMycsICdkMicpfTtcblxuICAgICAgICAgICAgICAgIHZhciB4VmFsdWUgPSAke2R5LmdldCgnYmF0Y2gnLCAnaWR5UicsICdpZHlDJywgJ2QyJyl9O1xuICAgICAgICAgICAgICAgIGxldCB0bXB2YWwgPSB2ZWM0PCR7ZGF0YVR5cGV9Pihkb3QoeFZhbHVlLCB3VmFsdWUwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUzKSk7XG4gICAgICAgICAgICAgICAgZG90UHJvZFswXSA9IGRvdFByb2RbMF0gKyB0bXB2YWw7XG5cbiAgICAgICAgICAgICAgICB4VmFsdWUgPSAgJHtkeS5nZXQoJ2JhdGNoJywgJ2lkeVInLCAnaWR5QzInLCAnZDInKX07XG5cbiAgICAgICAgICAgICAgICBkb3RQcm9kWzFdID0gZG90UHJvZFsxXSArIHZlYzQ8JHtkYXRhVHlwZX0+KGRvdCh4VmFsdWUsIHdWYWx1ZTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChiRHlDVmFsKSB7XG4gICAgICAgICAgICAgIGxldCBkMkxlbmd0aCA9IHVuaWZvcm1zLkR5X3NoYXBlWyR7Y2hhbm5lbERpbX1dO1xuICAgICAgICAgICAgICBmb3IgKHZhciBkMjogdTMyID0gMDsgZDIgPCBkMkxlbmd0aDsgZDIgPSBkMiArIDQpIHtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMCA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxJywgJ2QyJyl9O1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUxID0gJHt3LmdldCgndTMyKHdSUGVybSknLCAndTMyKHdDUGVybSknLCAnZDEgKyAxJywgJ2QyJyl9O1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUyID0gJHt3LmdldCgndTMyKHdSUGVybSknLCAndTMyKHdDUGVybSknLCAnZDEgKyAyJywgJ2QyJyl9O1xuICAgICAgICAgICAgICAgIGxldCB3VmFsdWUzID0gJHt3LmdldCgndTMyKHdSUGVybSknLCAndTMyKHdDUGVybSknLCAnZDEgKyAzJywgJ2QyJyl9O1xuXG4gICAgICAgICAgICAgICAgdmFyIHhWYWx1ZSA9ICR7ZHkuZ2V0KCdiYXRjaCcsICdpZHlSJywgJ2lkeUMnLCAnZDInKX07XG4gICAgICAgICAgICAgICAgbGV0IHRtcHZhbCA9IHZlYzQ8JHtkYXRhVHlwZX0+KGRvdCh4VmFsdWUsIHdWYWx1ZTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTMpKTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kWzBdID0gZG90UHJvZFswXSArIHRtcHZhbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChiRHlDVmFsMikge1xuICAgICAgICAgICAgICBsZXQgZDJMZW5ndGggPSB1bmlmb3Jtcy5EeV9zaGFwZVszXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgZDI6IHUzMiA9IDA7IGQyIDwgZDJMZW5ndGg7IGQyID0gZDIgKyA0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZTAgPSAke3cuZ2V0KCd1MzIod1JQZXJtKScsICd1MzIod0NQZXJtKScsICdkMScsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMSA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxICsgMScsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMiA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxICsgMicsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlMyA9ICR7dy5nZXQoJ3UzMih3UlBlcm0pJywgJ3UzMih3Q1Blcm0pJywgJ2QxICsgMycsICdkMicpfTtcblxuICAgICAgICAgICAgICAgIHZhciB4VmFsdWUgPSAke2R5LmdldCgnYmF0Y2gnLCAnaWR5UicsICdpZHlDMicsICdkMicpfTtcbiAgICAgICAgICAgICAgICBsZXQgdG1wdmFsID0gdmVjNDwke2RhdGFUeXBlfT4oZG90KHhWYWx1ZSwgd1ZhbHVlMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdCh4VmFsdWUsIHdWYWx1ZTEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QoeFZhbHVlLCB3VmFsdWUyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90KHhWYWx1ZSwgd1ZhbHVlMykpO1xuICAgICAgICAgICAgICAgIGRvdFByb2RbMV0gPSBkb3RQcm9kWzFdICsgdG1wdmFsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7d29ya1BlclRocmVhZH07IGkgPSBpICsgMSkge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGRvdFByb2RbaV0gKyAke2hhc0JpYXMgPyAnYmlhc1tjK2ldJyA6IGB2ZWM0PCR7ZGF0YVR5cGV9PigwLjApYH07XG4gICAgICAgICAgJHtvdXRwdXQuc2V0KCdiYXRjaCcsICdyJywgJ2MgKyBpJywgJ2QxJywgJ3ZhbHVlJyl9O1xuICAgICAgICB9XG4gICAgICB9YDtcbiAgY29uc3QgY29kZVNuaXBwZXQgPSBgXG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICAgICAgbGV0IGJhdGNoID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0SW5kaWNlcycsIDApfTtcbiAgICAgICAgICBsZXQgZDEgPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRJbmRpY2VzJywgY2hhbm5lbERpbSl9O1xuICAgICAgICAgIGxldCByID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0SW5kaWNlcycsIHJvd0RpbSl9O1xuICAgICAgICAgIGxldCBjID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0SW5kaWNlcycsIGNvbERpbSl9O1xuICAgICAgICAgIGxldCBkeUNvcm5lciA9IHZlYzI8aTMyPihpMzIociksIGkzMihjKSkgLSB1bmlmb3Jtcy5wYWRzO1xuICAgICAgICAgIGxldCBkeVJDb3JuZXIgPSBkeUNvcm5lci54O1xuICAgICAgICAgIGxldCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xuICAgICAgICAgIGxldCBncm91cElkID0gZDEgLyB1bmlmb3Jtcy5vdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xuICAgICAgICAgIGxldCB3T3V0Q2hhbm5lbCA9IGQxIC0gZ3JvdXBJZCAqIHVuaWZvcm1zLm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZDIpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGNvbXB1dGUgZHgoeFIsIHhDLCBkMSkuXG4gICAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXG4gICAgICAgICAgdmFyIGRvdFByb2QgPSAke2RhdGFUeXBlfSgwLjApO1xuICAgICAgICAgIGZvciAodmFyIHdSOiB1MzIgPSAwOyB3UiA8IHVuaWZvcm1zLmVmZmVjdGl2ZV9maWx0ZXJfZGltcy54OyB3UiA9IHdSICsgMSkge1xuICAgICAgICAgICAgaWYgKHdSICUgdW5pZm9ybXMuZGlsYXRpb25zLnggIT0gMCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkeVIgPSAoJHtkYXRhVHlwZX0oZHlSQ29ybmVyKSArICR7ZGF0YVR5cGV9KHdSKSkgLyAke2RhdGFUeXBlfSh1bmlmb3Jtcy5zdHJpZGVzWzBdKTtcbiAgICAgICAgICAgIGxldCB3UlBlcm0gPSB1bmlmb3Jtcy5maWx0ZXJfZGltcy54IC0gMSAtIHdSIC8gdW5pZm9ybXMuZGlsYXRpb25zLng7XG4gICAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSAke2RhdGFUeXBlfSh1bmlmb3Jtcy5EeV9zaGFwZVske3Jvd0RpbX1dKSB8fCBmcmFjdChkeVIpID4gMC4wIHx8XG4gICAgICAgICAgICAgICAgd1JQZXJtIDwgMCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpZHlSOiB1MzIgPSB1MzIoZHlSKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgd0M6IHUzMiA9IDA7IHdDIDwgdW5pZm9ybXMuZWZmZWN0aXZlX2ZpbHRlcl9kaW1zLnk7IHdDID0gd0MgKyAxKSB7XG4gICAgICAgICAgICAgIGlmICh3QyAlIHVuaWZvcm1zLmRpbGF0aW9ucy55ICE9IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgZHlDID0gKCR7ZGF0YVR5cGV9KGR5Q0Nvcm5lcikgKyAke2RhdGFUeXBlfSh3QykpIC8gJHtkYXRhVHlwZX0odW5pZm9ybXMuc3RyaWRlcy55KTtcbiAgICAgICAgICAgICAgbGV0IHdDUGVybSA9IHVuaWZvcm1zLmZpbHRlcl9kaW1zLnkgLSAxIC0gd0MgLyB1bmlmb3Jtcy5kaWxhdGlvbnMueTtcbiAgICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gJHtkYXRhVHlwZX0odW5pZm9ybXMuRHlfc2hhcGVbJHtjb2xEaW19XSkgfHxcbiAgICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjAgfHwgd0NQZXJtIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBpZHlDOiB1MzIgPSB1MzIoZHlDKTtcbiAgICAgICAgICAgICAgdmFyIGlucHV0Q2hhbm5lbCA9IGdyb3VwSWQgKiB1bmlmb3Jtcy5pbnB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgICAgICAgICAgIGZvciAodmFyIGQyOiB1MzIgPSAwOyBkMiA8IHVuaWZvcm1zLmlucHV0X2NoYW5uZWxzX3Blcl9ncm91cDsgZDIgPSBkMiArIDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgeFZhbHVlID0gJHtcbiAgICAgICAgICAgICAgICAgIGlzQ2hhbm5lbHNMYXN0XG4gICAgICAgICAgICAgICAgICAgID8gZHkuZ2V0KCdiYXRjaCcsICdpZHlSJywgJ2lkeUMnLCAnaW5wdXRDaGFubmVsJylcbiAgICAgICAgICAgICAgICAgICAgOiBkeS5nZXQoJ2JhdGNoJywgJ2lucHV0Q2hhbm5lbCcsICdpZHlSJywgJ2lkeUMnKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbGV0IHdWYWx1ZSA9ICR7dy5nZXQoJ2lucHV0Q2hhbm5lbCcsICd3T3V0Q2hhbm5lbCcsICd1MzIod1JQZXJtKScsICd1MzIod0NQZXJtKScpfTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIHhWYWx1ZSAqIHdWYWx1ZTtcbiAgICAgICAgICAgICAgICBpbnB1dENoYW5uZWwgPSBpbnB1dENoYW5uZWwgKyAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCB2YWx1ZSA9IGRvdFByb2QgKyAke2hhc0JpYXMgPyAnYmlhc1tkMV0nIDogYCR7ZGF0YVR5cGV9KDAuMClgfTtcbiAgICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICd2YWx1ZScpfTtcbiAgICAgICAgYDtcblxuICByZXR1cm4gYFxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLmlucHV0VmFyaWFibGVzLCBvdXRwdXQpfVxuICAke2RlY2xhcmVGdW5jdGlvbnN9XG5cbiAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfTtcbiAgJHtpc1ZlYzQgPyBjb2RlU25pcHBldDQgOiBjb2RlU25pcHBldH19YDtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVDb252VHJhbnNwb3NlMkRQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzLFxuICBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbj86IChzaGFwZTogcmVhZG9ubHkgbnVtYmVyW10pID0+IG51bWJlcltdLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBoYXNCaWFzID0gaW5wdXRzLmxlbmd0aCA+IDI7XG4gIC8vIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBhdHRyaWJ1dGVzLm91dHB1dFNoYXBlO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuXG4gIC8vIGNvbnN0IGluQ2hhbm5lbHMgPSBpbnB1dHNbMF0uZGltc1tpc0NoYW5uZWxzTGFzdCA/IDMgOiAxXTtcbiAgLy8gVE9ETyBFbmFibGUgaXNWZWM0IGZvciBwZXJmb3JtYW5jZVxuICAvLyBEaXNhYmxlZCBkdWUgdG8gd2VpZ2h0IG1hdHJpeCBsYXlvdXQgaXNzdWVcbiAgLy8gY29uc3QgaXNWZWM0ID0gYXR0cmlidXRlcy5ncm91cCA9PT0gMSAmJiBpc0NoYW5uZWxzTGFzdCAmJiBpbkNoYW5uZWxzICUgNCA9PT0gMCAmJiBvdXRDaGFubmVscyAlIDQgPT09IDA7XG4gIGNvbnN0IGRpc3BhdGNoID0gW01hdGguY2VpbChvdXRwdXRTaXplIC8gNjQpLCAxLCAxXTtcbiAgTE9HX0RFQlVHKCd2ZXJib3NlJywgKCkgPT4gYFtjb252MmRfYmFja3Byb3Bfd2ViZ3B1XSBkaXNwYXRjaCA9ICR7ZGlzcGF0Y2h9YCk7XG5cbiAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuaycsICdyYW5rJ107XG4gIGNvbnN0IHN0cmlkZXMgPSBbYXR0cmlidXRlcy5zdHJpZGVzWzBdLCBhdHRyaWJ1dGVzLnN0cmlkZXNbMV1dO1xuICBjb25zdCBmaWx0ZXJEaW1zID0gW2F0dHJpYnV0ZXMua2VybmVsU2hhcGVbaXNDaGFubmVsc0xhc3QgPyAxIDogMl0sIGF0dHJpYnV0ZXMua2VybmVsU2hhcGVbaXNDaGFubmVsc0xhc3QgPyAyIDogM11dO1xuICBjb25zdCBkaWxhdGlvbnMgPSBbYXR0cmlidXRlcy5kaWxhdGlvbnNbMF0sIGF0dHJpYnV0ZXMuZGlsYXRpb25zWzFdXTtcbiAgY29uc3QgZWZmZWN0aXZlRmlsdGVyRGltcyA9IFtcbiAgICBmaWx0ZXJEaW1zWzBdICtcbiAgICAgIChhdHRyaWJ1dGVzLmRpbGF0aW9uc1swXSA8PSAxXG4gICAgICAgID8gMFxuICAgICAgICA6IChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMSA6IDJdIC0gMSkgKiAoYXR0cmlidXRlcy5kaWxhdGlvbnNbMF0gLSAxKSksXG4gICAgZmlsdGVyRGltc1sxXSArXG4gICAgICAoYXR0cmlidXRlcy5kaWxhdGlvbnNbMV0gPD0gMVxuICAgICAgICA/IDBcbiAgICAgICAgOiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZVtpc0NoYW5uZWxzTGFzdCA/IDIgOiAzXSAtIDEpICogKGF0dHJpYnV0ZXMuZGlsYXRpb25zWzFdIC0gMSkpLFxuICBdO1xuICBjb25zdCBwYWRzID0gW1xuICAgIGVmZmVjdGl2ZUZpbHRlckRpbXNbMF0gLSAxIC0gTWF0aC5mbG9vcigoYXR0cmlidXRlcy5wYWRzWzBdICsgYXR0cmlidXRlcy5wYWRzWzJdKSAvIDIpLFxuICAgIGVmZmVjdGl2ZUZpbHRlckRpbXNbMV0gLSAxIC0gTWF0aC5mbG9vcihhdHRyaWJ1dGVzLnBhZHNbMV0gKyBhdHRyaWJ1dGVzLnBhZHNbM10pIC8gMixcbiAgXTtcblxuICBjb25zdCBpc1ZlYzQgPSBmYWxzZTtcbiAgY29uc3QgZ3JvdXAgPSBhdHRyaWJ1dGVzLmdyb3VwO1xuICBjb25zdCB3U2hhcGUgPSBpbnB1dHNbMV0uZGltcztcbiAgY29uc3QgaW5wdXRDaGFubmVsc1Blckdyb3VwID0gd1NoYXBlWzBdIC8gZ3JvdXA7XG4gIGNvbnN0IG91dHB1dENoYW5uZWxzUGVyR3JvdXAgPSB3U2hhcGVbMV07XG5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHN0cmlkZXMgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZmlsdGVyRGltcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBkaWxhdGlvbnMgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZWZmZWN0aXZlRmlsdGVyRGltcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IHBhZHMgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogaW5wdXRDaGFubmVsc1Blckdyb3VwIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dENoYW5uZWxzUGVyR3JvdXAgfSxcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgaW5wdXRzWzFdLmRpbXMpLFxuICBdO1xuICBpZiAoaGFzQmlhcykge1xuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1syXS5kaW1zKSk7XG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgncmFuaycpO1xuICB9XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSk7XG5cbiAgY29uc3QgaXMxRGltZW5zaW9uRGlzcGF0Y2ggPSBkaXNwYXRjaFsxXSA9PT0gMSAmJiBkaXNwYXRjaFsyXSA9PT0gMTtcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnc3RyaWRlcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IHN0cmlkZXMubGVuZ3RoIH0sXG4gICAgICB7IG5hbWU6ICdmaWx0ZXJfZGltcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGZpbHRlckRpbXMubGVuZ3RoIH0sXG4gICAgICB7IG5hbWU6ICdkaWxhdGlvbnMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBmaWx0ZXJEaW1zLmxlbmd0aCB9LFxuICAgICAgeyBuYW1lOiAnZWZmZWN0aXZlX2ZpbHRlcl9kaW1zJywgdHlwZTogJ3UzMicsIGxlbmd0aDogZWZmZWN0aXZlRmlsdGVyRGltcy5sZW5ndGggfSxcbiAgICAgIHsgbmFtZTogJ3BhZHMnLCB0eXBlOiAnaTMyJywgbGVuZ3RoOiBwYWRzLmxlbmd0aCB9LFxuICAgICAgeyBuYW1lOiAnaW5wdXRfY2hhbm5lbHNfcGVyX2dyb3VwJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ291dHB1dF9jaGFubmVsc19wZXJfZ3JvdXAnLCB0eXBlOiAndTMyJyB9LFxuICAgIF07XG4gICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgICByZXR1cm4gYCR7Y3JlYXRlQ29udlRyYW5zcG9zZTJET3BQcm9ncmFtU2hhZGVyU291cmNlKFxuICAgICAgc2hhZGVySGVscGVyLFxuICAgICAgaW5wdXRzLFxuICAgICAgb3V0cHV0U2hhcGUsXG4gICAgICBoYXNCaWFzLFxuICAgICAgaXMxRGltZW5zaW9uRGlzcGF0Y2gsXG4gICAgICBpc1ZlYzQsXG4gICAgICBkYXRhVHlwZSxcbiAgICAgIHVuaWZvcm1zLFxuICAgICAgaXNDaGFubmVsc0xhc3QsXG4gICAgKX1gO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdDb252VHJhbnNwb3NlMkQnLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9O2AsIGlucHV0RGVwZW5kZW5jaWVzIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogZGlzcGF0Y2hbMF0sIHk6IGRpc3BhdGNoWzFdLCB6OiBkaXNwYXRjaFsyXSB9LFxuICAgICAgb3V0cHV0czogW1xuICAgICAgICB7XG4gICAgICAgICAgZGltczogc3F1ZWV6ZU91dHB1dFNoYXBlRnVuY3Rpb24gPyBzcXVlZXplT3V0cHV0U2hhcGVGdW5jdGlvbihvdXRwdXRTaGFwZSkgOiBvdXRwdXRTaGFwZSxcbiAgICAgICAgICBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQgfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNyZWF0ZUNvbnYyRFRyYW5zcG9zZU1hdE11bFByb2dyYW1JbmZvIH0gZnJvbSAnLi8zcmQtcGFydHkvY29udl9iYWNrcHJvcF9tbV93ZWJncHUnO1xuaW1wb3J0IHsgY3JlYXRlQ29udlRyYW5zcG9zZTJEUHJvZ3JhbUluZm8gfSBmcm9tICcuLzNyZC1wYXJ0eS9jb252X2JhY2twcm9wX3dlYmdwdSc7XG5pbXBvcnQgeyBDb252QXR0cmlidXRlcyB9IGZyb20gJy4vY29udic7XG5pbXBvcnQgeyBwYXJzZUludGVybmFsQWN0aXZhdGlvbkF0dHJpYnV0ZXMgfSBmcm9tICcuL2Z1c2UtdXRpbHMnO1xuaW1wb3J0IHsgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8gfSBmcm9tICcuL3RyYW5zcG9zZSc7XG5cbmNvbnN0IGNvbXB1dGVUb3RhbFBhZCA9IChcbiAgaW5EaW06IG51bWJlcixcbiAgc3RyaWRlOiBudW1iZXIsXG4gIGFkajogbnVtYmVyLFxuICBrZXJuZWw6IG51bWJlcixcbiAgZGlsYXRpb246IG51bWJlcixcbiAgb3V0U2l6ZTogbnVtYmVyLFxuKSA9PiAoaW5EaW0gLSAxKSAqIHN0cmlkZSArIGFkaiArIChrZXJuZWwgLSAxKSAqIGRpbGF0aW9uICsgMSAtIG91dFNpemU7XG5cbmNvbnN0IGRpc3RyaWJ1dGVQYWRkaW5nID0gKHRvdGFsUGFkOiBudW1iZXIsIGF1dG9QYWQ6IHN0cmluZywgcGFkczogbnVtYmVyW10sIGhlYWQ6IG51bWJlciwgdGFpbDogbnVtYmVyKSA9PiB7XG4gIGNvbnN0IHNtYWxsUGFkID0gTWF0aC5mbG9vcih0b3RhbFBhZCAvIDIpO1xuICBpZiAoYXV0b1BhZCA9PT0gJ1NBTUVfVVBQRVInKSB7XG4gICAgcGFkc1toZWFkXSA9IHNtYWxsUGFkO1xuICAgIHBhZHNbdGFpbF0gPSB0b3RhbFBhZCAtIHNtYWxsUGFkO1xuICB9IGVsc2UgaWYgKGF1dG9QYWQgPT09ICdTQU1FX0xPV0VSJykge1xuICAgIHBhZHNbaGVhZF0gPSB0b3RhbFBhZCAtIHNtYWxsUGFkO1xuICAgIHBhZHNbdGFpbF0gPSBzbWFsbFBhZDtcbiAgfVxufTtcblxuY29uc3QgY2FsY3VsYXRlT3V0cHV0U2hhcGVBbmRQYWRzID0gKFxuICBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBkaWxhdGlvbnM6IHJlYWRvbmx5IG51bWJlcltdLFxuICBhdXRvUGFkOiBzdHJpbmcsXG4gIGdyb3VwOiBudW1iZXIsXG4gIHBhZHM6IG51bWJlcltdLFxuICBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXSxcbiAgaXNDaGFubmVsTGFzdDogYm9vbGVhbixcbiAgb3V0cHV0UGFkZGluZzogbnVtYmVyW10sXG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXSxcbikgPT4ge1xuICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0U2hhcGUubGVuZ3RoIC0gMjtcbiAgY29uc3QgdXBkYXRlT3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZS5sZW5ndGggPT09IDA7XG4gIGlmIChvdXRwdXRQYWRkaW5nLmxlbmd0aCA8IHNwYXRpYWxSYW5rKSB7XG4gICAgb3V0cHV0UGFkZGluZy5wdXNoKC4uLkFycmF5KHNwYXRpYWxSYW5rIC0gb3V0cHV0UGFkZGluZy5sZW5ndGgpLmZpbGwoMCkpO1xuICB9XG4gIGNvbnN0IGJhdGNoU2l6ZSA9IGlucHV0U2hhcGVbMF07XG4gIGNvbnN0IG91dENoYW5uZWxzID0ga2VybmVsU2hhcGVbaXNDaGFubmVsTGFzdCA/IDMgOiAxXSAqIGdyb3VwO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IGlucHV0U2hhcGUubGVuZ3RoIC0gc3BhdGlhbFJhbmsgLSAoaXNDaGFubmVsTGFzdCA/IDEgOiAwKTsgaSA8IHNwYXRpYWxSYW5rOyArK2ksICsraikge1xuICAgIGNvbnN0IGluU2l6ZSA9IGlucHV0U2hhcGVbal07XG4gICAgY29uc3Qgb3V0U2l6ZSA9IHVwZGF0ZU91dHB1dFNoYXBlID8gaW5TaXplICogc3RyaWRlc1tpXSA6IG91dHB1dFNoYXBlW2ldO1xuICAgIGNvbnN0IHRvdGFsUGFkID0gY29tcHV0ZVRvdGFsUGFkKGluU2l6ZSwgc3RyaWRlc1tpXSwgcGFkc1tpXSwga2VybmVsU2hhcGVbal0sIGRpbGF0aW9uc1tpXSwgb3V0U2l6ZSk7XG4gICAgZGlzdHJpYnV0ZVBhZGRpbmcodG90YWxQYWQsIGF1dG9QYWQsIHBhZHMsIGksIGkgKyBzcGF0aWFsUmFuayk7XG4gICAgaWYgKHVwZGF0ZU91dHB1dFNoYXBlKSB7XG4gICAgICBvdXRwdXRTaGFwZS5wdXNoKFxuICAgICAgICBzdHJpZGVzW2ldICogKGluU2l6ZSAtIDEpICtcbiAgICAgICAgICBvdXRwdXRQYWRkaW5nW2ldICtcbiAgICAgICAgICAoa2VybmVsU2hhcGVbal0gLSAxKSAqIGRpbGF0aW9uc1tpXSArXG4gICAgICAgICAgMSAtXG4gICAgICAgICAgcGFkc1tpXSAtXG4gICAgICAgICAgcGFkc1tpICsgc3BhdGlhbFJhbmtdLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgb3V0cHV0U2hhcGUuc3BsaWNlKDAsIDAsIGJhdGNoU2l6ZSk7XG4gIG91dHB1dFNoYXBlLnNwbGljZShpc0NoYW5uZWxMYXN0ID8gMyA6IDEsIDAsIG91dENoYW5uZWxzKTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgZXh0ZW5kcyBDb252QXR0cmlidXRlcyB7XG4gIHJlYWRvbmx5IG91dHB1dFBhZGRpbmc6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW107XG59XG5cbmNvbnN0IGdldEFkanVzdGVkQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgPSA8VCBleHRlbmRzIENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzPihcbiAgYXR0cmlidXRlczogVCxcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4pOiBUID0+IHtcbiAgY29uc3Qga2VybmVsU2hhcGUgPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLnNsaWNlKCk7XG4gIC8vIGlmIGtlcm5lbFNoYXBlIGlzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIGF0dHJpYnV0ZXMgb2YgdGhpcyBvcCwgaW5mZXIgaXQgZnJvbSB0aGUgd2VpZ2h0IHRlbnNvciBkaW1zXG4gIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCA9PT0gMCB8fCBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIsIDEpID09PSAwKSB7XG4gICAga2VybmVsU2hhcGUubGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMjsgaSA8IGlucHV0c1sxXS5kaW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICBrZXJuZWxTaGFwZS5wdXNoKGlucHV0c1sxXS5kaW1zW2ldKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBhdHRyaWJ1dGVzLmZvcm1hdCA9PT0gJ05IV0MnO1xuICBrZXJuZWxTaGFwZS5zcGxpY2UoMCwgMCwgaW5wdXRzWzFdLmRpbXNbMF0pO1xuICBrZXJuZWxTaGFwZS5zcGxpY2UoaXNDaGFubmVsc0xhc3QgPyAzIDogMSwgMCwgaW5wdXRzWzFdLmRpbXNbMV0pO1xuXG4gIGNvbnN0IHBhZHMgPSBhdHRyaWJ1dGVzLnBhZHMuc2xpY2UoKTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBhdHRyaWJ1dGVzLm91dHB1dFNoYXBlLnNsaWNlKCk7XG4gIGNvbnN0IG91dHB1dFBhZGRpbmcgPSBhdHRyaWJ1dGVzLm91dHB1dFBhZGRpbmcuc2xpY2UoKTtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBsZXQgZGlsYXRpb25zID0gYXR0cmlidXRlcy5kaWxhdGlvbnMuc2xpY2UoKTtcbiAgaWYgKGRpbGF0aW9ucy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSA9PT0gMCkge1xuICAgIGNvbnN0IHNwYXRpYWxSYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMjtcbiAgICBkaWxhdGlvbnMgPSBuZXcgQXJyYXkoc3BhdGlhbFJhbmspLmZpbGwoMSk7XG4gIH1cbiAgbGV0IHN0cmlkZXMgPSBhdHRyaWJ1dGVzLnN0cmlkZXMuc2xpY2UoKTtcbiAgaWYgKHN0cmlkZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgPT09IDApIHtcbiAgICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDI7XG4gICAgc3RyaWRlcyA9IG5ldyBBcnJheShzcGF0aWFsUmFuaykuZmlsbCgxKTtcbiAgfVxuICAvLyBJZiBvdXRwdXRTaGFwZSBpcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBhdHRyaWJ1dGVzIG9mIHRoaXMgb3AsIGluZmVyIGl0IGZyb20gdGhlIHBhcmFtZXRlcnNcbiAgLy8gU2ltaWxhcmx5LCBhdXRvbWF0aWNhbGx5IGluZmVyIHBhZHMgaWYgbm90IHNwZWNpZmllZFxuICBjYWxjdWxhdGVPdXRwdXRTaGFwZUFuZFBhZHMoXG4gICAgaW5wdXRTaGFwZSxcbiAgICBrZXJuZWxTaGFwZSxcbiAgICBkaWxhdGlvbnMsXG4gICAgYXR0cmlidXRlcy5hdXRvUGFkLFxuICAgIGF0dHJpYnV0ZXMuZ3JvdXAsXG4gICAgcGFkcyxcbiAgICBzdHJpZGVzLFxuICAgIGlzQ2hhbm5lbHNMYXN0LFxuICAgIG91dHB1dFBhZGRpbmcsXG4gICAgb3V0cHV0U2hhcGUsXG4gICk7XG5cbiAgLy8gYWx3YXlzIHJldHVybiBhIG5ldyBvYmplY3Qgc28gZG9lcyBub3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCBhdHRyaWJ1dGVzXG4gIGNvbnN0IG5ld0F0dHJpYnV0ZXM6IFQgPSBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKTtcbiAgT2JqZWN0LmFzc2lnbihuZXdBdHRyaWJ1dGVzLCB7IGtlcm5lbFNoYXBlLCBwYWRzLCBvdXRwdXRQYWRkaW5nLCBvdXRwdXRTaGFwZSwgZGlsYXRpb25zLCBzdHJpZGVzIH0pO1xuICByZXR1cm4gbmV3QXR0cmlidXRlcztcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUNvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBhY3RpdmF0aW9uQXR0cmlidXRlcyA9IHBhcnNlSW50ZXJuYWxBY3RpdmF0aW9uQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcbiAgLy8gVE9ETyA6IE1ha2UgdGhpcyBnZW5lcmljIGVub3VnaCB0byBjb21wdXRlIGRlZmF1bHQgYXR0cmlidXRlcyBmb3IgbXVsdGktZGltZW5zaW9uYWwgY29udlxuICBjb25zdCBmb3JtYXQgPSBhdHRyaWJ1dGVzLmZvcm1hdCBhcyAnTkhXQycgfCAnTkNIVyc7XG4gIGNvbnN0IGF1dG9QYWQgPSBbJ05PVFNFVCcsICdWQUxJRCcsICdTQU1FX1VQUEVSJywgJ1NBTUVfTE9XRVInXVtcbiAgICB0eXBlb2YgYXR0cmlidXRlcy5hdXRvUGFkID09ICd1bmRlZmluZWQnID8gMCA6IChhdHRyaWJ1dGVzLmF1dG9QYWQgYXMgbnVtYmVyKVxuICBdO1xuICBjb25zdCBkaWxhdGlvbnMgPSBhdHRyaWJ1dGVzLmRpbGF0aW9ucyBhcyBbbnVtYmVyLCBudW1iZXJdO1xuICBjb25zdCBncm91cCA9IGF0dHJpYnV0ZXMuZ3JvdXAgYXMgbnVtYmVyO1xuICBjb25zdCBrZXJuZWxTaGFwZSA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUgYXMgW251bWJlciwgbnVtYmVyXTtcbiAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMucGFkcyBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbiAgY29uc3Qgc3RyaWRlcyA9IGF0dHJpYnV0ZXMuc3RyaWRlcyBhcyBbbnVtYmVyLCBudW1iZXJdO1xuICBjb25zdCB3SXNDb25zdCA9IChhdHRyaWJ1dGVzLndJc0NvbnN0IGFzICgpID0+IGJvb2xlYW4pKCk7XG4gIGNvbnN0IG91dHB1dFBhZGRpbmcgPSBhdHRyaWJ1dGVzLm91dHB1dFBhZGRpbmcgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gYXR0cmlidXRlcy5vdXRwdXRTaGFwZSBhcyBbbnVtYmVyLCBudW1iZXJdO1xuICByZXR1cm4ge1xuICAgIGF1dG9QYWQsXG4gICAgZm9ybWF0LFxuICAgIGRpbGF0aW9ucyxcbiAgICBncm91cCxcbiAgICBrZXJuZWxTaGFwZSxcbiAgICBvdXRwdXRQYWRkaW5nLFxuICAgIG91dHB1dFNoYXBlLFxuICAgIHBhZHMsXG4gICAgc3RyaWRlcyxcbiAgICB3SXNDb25zdCxcbiAgICAuLi5hY3RpdmF0aW9uQXR0cmlidXRlcyxcbiAgICBjYWNoZUtleTogYCR7YXR0cmlidXRlcy5mb3JtYXR9OyR7YWN0aXZhdGlvbkF0dHJpYnV0ZXMuYWN0aXZhdGlvbn07YCxcbiAgfTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBDb252VHJhbnNwb3NlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICAvLyBSZWZlciB0byB0aGUgYmVsb3cgbGluayBmb3IgYWxsIGlucHV0IGNoZWNrc1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vb25ueC9vbm54L2Jsb2IvbWFpbi9kb2NzL09wZXJhdG9ycy5tZCNDb252VHJhbnNwb3NlXG4gIGlmICghaW5wdXRzIHx8IChpbnB1dHMubGVuZ3RoICE9PSAyICYmIGlucHV0cy5sZW5ndGggIT09IDMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb252IHJlcXVpcmVzIDIgb3IgMyBpbnB1dHMnKTtcbiAgfVxuXG4gIC8vIFRPRE8gOiBOZWVkIHRvIGFkZCBzdXBwb3J0IGZvciBtdWx0aS1kaW1lbnNpb25hbCBjb252XG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDQgJiYgaW5wdXRzWzBdLmRpbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjdXJyZW50bHkgb25seSBzdXBwb3J0IDItZGltZW5zaW9uYWwgY29udicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dCcpO1xuICB9XG5cbiAgLy8gRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFxuICBjb25zdCBkYXRhQ2hhbm5lbCA9IGlucHV0c1swXS5kaW1zW2F0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQycgPyBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAxIDogMV07XG4gIGNvbnN0IGZpbHRlckluQ2hhbm5lbCA9IGlucHV0c1sxXS5kaW1zWzBdO1xuICBpZiAoZGF0YUNoYW5uZWwgIT09IGZpbHRlckluQ2hhbm5lbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTCcpO1xuICB9XG5cbiAgY29uc3QgZmVhdHVyZU1hcHMgPSBpbnB1dHNbMV0uZGltc1sxXSAqIGF0dHJpYnV0ZXMuZ3JvdXA7XG5cbiAgLy8gaWYgYmlhcyBpcyBwcm92aWRlZCBpdCBzaG91bGQgYmUgMUQgYW5kIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgc2hvdWxkIGJlIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgZmVhdHVyZSBtYXBzXG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSAzICYmIChpbnB1dHNbMl0uZGltcy5sZW5ndGggIT09IDEgfHwgaW5wdXRzWzJdLmRpbXNbMF0gIT09IGZlYXR1cmVNYXBzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBiaWFzJyk7XG4gIH1cblxuICBjb25zdCBzcGF0aWFsUmFuayA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAtIDI7XG4gIGNvbnN0IGRpbGF0aW9uc1NldCA9IGF0dHJpYnV0ZXMuZGlsYXRpb25zLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApID4gMDtcbiAgLy8gd3JvbmcgZGlsYXRpb25zIGRpbWVuc2lvblxuICBpZiAoZGlsYXRpb25zU2V0ICYmIGF0dHJpYnV0ZXMuZGlsYXRpb25zLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGRpbGF0aW9ucyBzaG91bGQgYmUgJHtzcGF0aWFsUmFua31EYCk7XG4gIH1cblxuICBjb25zdCBzdHJpZGVzU2V0ID0gYXR0cmlidXRlcy5zdHJpZGVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApID4gMDtcbiAgLy8gV3Jvbmcgc3RyaWRlcyBkaW1lbnNpb25cbiAgaWYgKHN0cmlkZXNTZXQgJiYgYXR0cmlidXRlcy5zdHJpZGVzLmxlbmd0aCAhPT0gc3BhdGlhbFJhbmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7c3BhdGlhbFJhbmt9RGApO1xuICB9XG5cbiAgLy8gV3JvbmcgcGFkcyBkaW1lbnNpb25cbiAgY29uc3QgcGFkc1NldCA9IGF0dHJpYnV0ZXMucGFkcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSA+IDA7XG4gIGlmIChwYWRzU2V0ICYmIGF0dHJpYnV0ZXMucGFkcy5sZW5ndGggIT09IHNwYXRpYWxSYW5rICogMikge1xuICAgIHRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHtzcGF0aWFsUmFuayAqIDJ9RGApO1xuICB9XG5cbiAgLy8gV3Jvbmcgb3V0cHV0IHBhZGRpbmcgZGltZW5zaW9uXG4gIGlmIChhdHRyaWJ1dGVzLm91dHB1dFBhZGRpbmcubGVuZ3RoICE9PSBzcGF0aWFsUmFuayAmJiBhdHRyaWJ1dGVzLm91dHB1dFBhZGRpbmcubGVuZ3RoICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBvdXRwdXRfcGFkZGluZyBzaG91bGQgYmUgJHtzcGF0aWFsUmFua31EYCk7XG4gIH1cblxuICAvLyBpZiBrZXJuZWxTaGFwZSBpcyBzcGVjaWZpZWQsIGl0J3MgZGF0YSBsZW5ndGggbXVzdCBiZSAyIGxlc3MgdGhhbiBkaW1zIGxlbmd0aCBvZiB0aGUgd2VpZ2h0cyB0ZW5zb3JcbiAgLy8gKHRoZSBmaXJzdCAyIGRpbXMgYXJlIGJhdGNoX3NpemUgYW5kIGNoYW5uZWxzKVxuICBjb25zdCBrZXJuZWxTaGFwZVNldCA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgPiAwO1xuICBpZiAoXG4gICAga2VybmVsU2hhcGVTZXQgJiZcbiAgICBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCAhPT0gMCAmJlxuICAgIGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoICE9PSBpbnB1dHNbMV0uZGltcy5sZW5ndGggLSAyXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBrZXJuZWwgc2hhcGUnKTtcbiAgfVxuXG4gIC8vIGFzIHdpdGgga2VybmVsU2hhcGUsIG11c3QgaGF2ZSBzYW1lIG51bWJlciBvZiBzcGF0aWFsIGRpbXMgYXMgaW5wdXRcbiAgaWYgKGF0dHJpYnV0ZXMub3V0cHV0U2hhcGUubGVuZ3RoICE9PSAwICYmIGF0dHJpYnV0ZXMub3V0cHV0U2hhcGUubGVuZ3RoICE9PSBpbnB1dHNbMF0uZGltcy5sZW5ndGggLSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG91dHB1dCBzaGFwZScpO1xuICB9XG59O1xuXG4vLyBmb3IgdHJhbnNwb3Npbmcgd2VpZ2h0IHRlbnNvciBmcm9tIFtDLCBNL2dyb3VwLCBLSCwgS1ddIHRvIFtLSCwgS1csIE0vZ3JvdXAsIENdXG5jb25zdCB3ZWlnaHRUcmFuc3Bvc2VQZXJtID0gWzIsIDMsIDEsIDBdO1xuXG5jb25zdCBjb252VHJhbnNwb3NlMmQgPSAoXG4gIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMsXG4pOiB2b2lkID0+IHtcbiAgY29uc3QgYWRqdXN0ZWRBdHRyaWJ1dGVzID0gZ2V0QWRqdXN0ZWRDb252VHJhbnNwb3NlQXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBpbnB1dHMpO1xuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gYWRqdXN0ZWRBdHRyaWJ1dGVzLm91dHB1dFNoYXBlO1xuICBjb25zdCBvdXRDaGFubmVscyA9IG91dHB1dFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMyA6IDFdO1xuICBjb25zdCBpbnB1dENoYW5uZWxzID0gaW5wdXRzWzBdLmRpbXNbaXNDaGFubmVsc0xhc3QgPyAzIDogMV07XG4gIC8vIFN3aXRjaCB0byBuYWl2ZSBtZXRob2Qgd2hlbiBvdXRDaGFubmVscyBhbmQgaW5wdXRDaGFubmVscyBhcmUgdmVyeSBzbWFsbC4gSXQncyBiZWNhdXNlIHRoYXQgaW4gdGhpcyBjYXNlIGl0J3NcbiAgLy8gbm90IHN1aXRhYmxlIGZvciBtYXRtdWwgdmVyc2lvbiBzaW5jZSBtYXRtdWwgdXNlcyB0aWxlIHNpemUgMzJ4MzIgcmVzdWx0aW5nIHRoZSB1bmRlcmx5aW5nIGV4ZWN1dGlvbiB1bml0XG4gIC8vIHV0aWxpemF0aW9uIHJhdGUgaXMgdmVyeSBsb3cuXG4gIGlmIChhZGp1c3RlZEF0dHJpYnV0ZXMuZ3JvdXAgIT09IDEgfHwgKG91dENoYW5uZWxzID09PSAxICYmIGlucHV0Q2hhbm5lbHMgPT09IDEpKSB7XG4gICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUNvbnZUcmFuc3Bvc2UyRFByb2dyYW1JbmZvKGlucHV0cywgYWRqdXN0ZWRBdHRyaWJ1dGVzKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG91dEhlaWdodCA9IG91dHB1dFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMSA6IDJdO1xuICBjb25zdCBvdXRXaWR0aCA9IG91dHB1dFNoYXBlW2lzQ2hhbm5lbHNMYXN0ID8gMiA6IDNdO1xuICBjb25zdCB3ZWlnaHRIZWlnaHQgPSBpbnB1dHNbMV0uZGltc1syXTtcbiAgY29uc3Qgd2VpZ2h0V2lkdGggPSBpbnB1dHNbMV0uZGltc1szXTtcblxuICBjb25zdCBkaW1BT3V0ZXIgPSBpc0NoYW5uZWxzTGFzdCA/IG91dEhlaWdodCAqIG91dFdpZHRoIDogb3V0Q2hhbm5lbHM7XG4gIGNvbnN0IGRpbUJPdXRlciA9IGlzQ2hhbm5lbHNMYXN0ID8gb3V0Q2hhbm5lbHMgOiBvdXRIZWlnaHQgKiBvdXRXaWR0aDtcbiAgY29uc3QgZGltSW5uZXIgPSB3ZWlnaHRIZWlnaHQgKiB3ZWlnaHRXaWR0aCAqIGlucHV0Q2hhbm5lbHM7XG5cbiAgY29uc3Qgc2VxdWVudGlhbEFjY2Vzc0J5VGhyZWFkcyA9IC8qIGJhY2tlbmQuYWRhcHRlckluZm8uaXNJbnRlbCgpICovIHRydWU7XG5cbiAgLy8gU1RFUC4xOiB0cmFuc3Bvc2Ugd2VpZ2h0XG4gIGNvbnN0IHRyYW5zcG9zZWRXZWlnaHQgPVxuICAgIChjb250ZXh0Lmtlcm5lbEN1c3RvbURhdGEud1QgYXMgVGVuc29yVmlldyB8IHVuZGVmaW5lZCkgPz9cbiAgICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8oaW5wdXRzWzFdLCB3ZWlnaHRUcmFuc3Bvc2VQZXJtKSwge1xuICAgICAgaW5wdXRzOiBbMV0sXG4gICAgICBvdXRwdXRzOiBbYXR0cmlidXRlcy53SXNDb25zdCA/IC0yIDogLTFdLFxuICAgIH0pWzBdO1xuICBpZiAoYXR0cmlidXRlcy53SXNDb25zdCAmJiAhY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUKSB7XG4gICAgY29udGV4dC5rZXJuZWxDdXN0b21EYXRhLndUID0gdHJhbnNwb3NlZFdlaWdodDtcbiAgfVxuXG4gIC8vIFNURVAuMjogcHJlcGFyZSByZXNoYXBlZCBpbnB1dHNcbiAgY29uc3QgY29udlRyYW5zcG9zZUlucHV0cyA9IFtpbnB1dHNbMF0sIHRyYW5zcG9zZWRXZWlnaHRdO1xuICBjb25zdCBoYXNCaWFzID0gaW5wdXRzLmxlbmd0aCA9PT0gMztcbiAgaWYgKGhhc0JpYXMpIHtcbiAgICBpZiAoIWlzQ2hhbm5lbHNMYXN0ICYmIGlucHV0c1syXS5kaW1zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29udlRyYW5zcG9zZUlucHV0cy5wdXNoKGlucHV0c1syXS5yZXNoYXBlKFtpbnB1dHNbMl0uZGltc1swXSwgMSwgMV0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udlRyYW5zcG9zZUlucHV0cy5wdXNoKGlucHV0c1syXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gU1RFUC4zOiBjb21wdXRlIG1hdG11bFxuICBjb250ZXh0LmNvbXB1dGUoXG4gICAgY3JlYXRlQ29udjJEVHJhbnNwb3NlTWF0TXVsUHJvZ3JhbUluZm8oXG4gICAgICBjb252VHJhbnNwb3NlSW5wdXRzLFxuICAgICAgYWRqdXN0ZWRBdHRyaWJ1dGVzLFxuICAgICAgb3V0cHV0U2hhcGUsXG4gICAgICBkaW1BT3V0ZXIsXG4gICAgICBkaW1CT3V0ZXIsXG4gICAgICBkaW1Jbm5lcixcbiAgICAgIGhhc0JpYXMsXG4gICAgICBzZXF1ZW50aWFsQWNjZXNzQnlUaHJlYWRzLFxuICAgICksXG4gICAgeyBpbnB1dHM6IGNvbnZUcmFuc3Bvc2VJbnB1dHMgfSxcbiAgKTtcbn07XG5cbmNvbnN0IGNvbnZUcmFuc3Bvc2UxZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQ29udlRyYW5zcG9zZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgLy8gZXh0ZW5kIHRoZSBpbnB1dCB0byAyRCBieSBhZGRpbmcgSCBkaW1lbnNpb25cbiAgY29uc3QgaXNDaGFubmVsTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG5cbiAgY29uc3QgaW5wdXRzID0gW1xuICAgIGNvbnRleHQuaW5wdXRzWzBdLnJlc2hhcGUoXG4gICAgICBpc0NoYW5uZWxMYXN0XG4gICAgICAgID8gLy8gW04sIFcsIENdIC0+IFtOLCBIPTEsIFcsIENdXG4gICAgICAgICAgW2NvbnRleHQuaW5wdXRzWzBdLmRpbXNbMF0sIDEsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMV0sIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMl1dXG4gICAgICAgIDogLy8gW04sIEMsIFddIC0+IFtOLCBDLCBIPTEsIFddXG4gICAgICAgICAgW2NvbnRleHQuaW5wdXRzWzBdLmRpbXNbMF0sIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMV0sIDEsIGNvbnRleHQuaW5wdXRzWzBdLmRpbXNbMl1dLFxuICAgICksXG4gICAgLy9bRklMVEVSX09VVF9DSEFOTkVMLCBGSUxURVJfSU5fQ0hBTk5FTCwga1ddIC0+IFtGSUxURVJfT1VUX0NIQU5ORUwsIEZJTFRFUl9JTl9DSEFOTkVMLCBrSD0xLCBrV11cbiAgICBjb250ZXh0LmlucHV0c1sxXS5yZXNoYXBlKFtjb250ZXh0LmlucHV0c1sxXS5kaW1zWzBdLCBjb250ZXh0LmlucHV0c1sxXS5kaW1zWzFdLCAxLCBjb250ZXh0LmlucHV0c1sxXS5kaW1zWzJdXSksXG4gIF07XG4gIGlmIChjb250ZXh0LmlucHV0cy5sZW5ndGggPT09IDMpIHtcbiAgICBpbnB1dHMucHVzaChjb250ZXh0LmlucHV0c1syXSk7XG4gIH1cbiAgbGV0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZTtcbiAgaWYgKGtlcm5lbFNoYXBlLmxlbmd0aCA9PT0gMCB8fCBrZXJuZWxTaGFwZVswXSA9PT0gMCkge1xuICAgIGtlcm5lbFNoYXBlID0gW2NvbnRleHQuaW5wdXRzWzFdLmRpbXNbMl1dO1xuICB9XG4gIGxldCBkaWxhdGlvbnMgPSBhdHRyaWJ1dGVzLmRpbGF0aW9ucztcbiAgaWYgKGRpbGF0aW9ucy5sZW5ndGggPT09IDAgfHwgZGlsYXRpb25zWzBdID09PSAwKSB7XG4gICAgZGlsYXRpb25zID0gWzFdO1xuICB9XG4gIGxldCBzdHJpZGVzID0gYXR0cmlidXRlcy5zdHJpZGVzO1xuICBpZiAoc3RyaWRlcy5sZW5ndGggPT09IDAgfHwgc3RyaWRlc1swXSA9PT0gMCkge1xuICAgIHN0cmlkZXMgPSBbMV07XG4gIH1cbiAgbGV0IHBhZHMgPSBhdHRyaWJ1dGVzLnBhZHM7XG4gIGlmIChwYWRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHBhZHMgPSBbMCwgMF07XG4gIH1cbiAgcGFkcyA9IFswLCBwYWRzWzBdLCAwLCBwYWRzWzFdXTtcbiAgc3RyaWRlcyA9IFsxXS5jb25jYXQoc3RyaWRlcyk7XG4gIGRpbGF0aW9ucyA9IFsxXS5jb25jYXQoZGlsYXRpb25zKTtcbiAga2VybmVsU2hhcGUgPSBbMV0uY29uY2F0KGtlcm5lbFNoYXBlKTtcbiAgY29uc3QgYWRqdXN0ZWRBdHRyaWJ1dGVzID0gZ2V0QWRqdXN0ZWRDb252VHJhbnNwb3NlQXR0cmlidXRlcyhcbiAgICB7IC4uLmF0dHJpYnV0ZXMsIHBhZHMsIHN0cmlkZXMsIGRpbGF0aW9ucywga2VybmVsU2hhcGUgfSxcbiAgICBpbnB1dHMsXG4gICk7XG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICBjcmVhdGVDb252VHJhbnNwb3NlMkRQcm9ncmFtSW5mbyhpbnB1dHMsIGFkanVzdGVkQXR0cmlidXRlcywgKG91dHB1dFNoYXBlKSA9PlxuICAgICAgaXNDaGFubmVsTGFzdFxuICAgICAgICA/IFtvdXRwdXRTaGFwZVswXSwgb3V0cHV0U2hhcGVbMl0sIG91dHB1dFNoYXBlWzNdXVxuICAgICAgICA6IFtvdXRwdXRTaGFwZVswXSwgb3V0cHV0U2hhcGVbMV0sIG91dHB1dFNoYXBlWzNdXSxcbiAgICApLFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvbnZUcmFuc3Bvc2UgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IENvbnZUcmFuc3Bvc2VBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgaWYgKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMubGVuZ3RoID09PSAzKSB7XG4gICAgY29udlRyYW5zcG9zZTFkKGNvbnRleHQsIGF0dHJpYnV0ZXMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnZUcmFuc3Bvc2UyZChjb250ZXh0LCBjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgZ2V0RWxlbWVudEF0LCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEN1bVN1bUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBleGNsdXNpdmU6IGJvb2xlYW47XG4gIHJlYWRvbmx5IHJldmVyc2U6IGJvb2xlYW47XG59XG5jb25zdCBjcmVhdGVDdW1zdW1Qcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRUeXBlOiBudW1iZXIsXG4gIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBheGlzSW5wdXQ6IFRlbnNvclZpZXcsXG4gIGF0dHJpYnV0ZXM6IEN1bVN1bUF0dHJpYnV0ZXMsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShpbnB1dFNoYXBlKTsgLy8gb3V0cHV0U2hhcGUgaXMgc2FtZSBhcyBpbnB1dFNoYXBlLlxuICBjb25zdCByYW5rID0gaW5wdXRTaGFwZS5sZW5ndGg7IC8vIGlucHV0L291dHB1dCByYW5rXG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpbnB1dFR5cGUsIHJhbmspO1xuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRUeXBlLCByYW5rKTtcbiAgY29uc3QgYXhpc1ZhbHVlID1cbiAgICBheGlzSW5wdXQuZGF0YVR5cGUgPT09IERhdGFUeXBlLmludDMyID8gYXhpc0lucHV0LmdldEludDMyQXJyYXkoKVswXSA6IE51bWJlcihheGlzSW5wdXQuZ2V0QmlnSW50NjRBcnJheSgpWzBdKTtcbiAgY29uc3QgYXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF4aXNWYWx1ZSwgcmFuayk7XG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gYCBpMzIoJHtpbnB1dC5pbmRpY2VzR2V0KCdpbnB1dEluZGljZXMnLCAndW5pZm9ybXMuYXhpcycpfSkgYDtcbiAgICBjb25zdCBtYXggPSBnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLmlucHV0X3NoYXBlJywgJ3VuaWZvcm1zLmF4aXMnLCByYW5rKTtcbiAgICBjb25zdCBsb3dlckxpbWl0ID0gYXR0cmlidXRlcy5yZXZlcnNlID8gaW5kZXggKyAoYXR0cmlidXRlcy5leGNsdXNpdmUgPyAnICsgMScgOiAnJykgOiAnMCc7XG4gICAgY29uc3QgdXBwZXJMaW1pdCA9IGF0dHJpYnV0ZXMucmV2ZXJzZSA/IG1heCA6IGluZGV4ICsgKGF0dHJpYnV0ZXMuZXhjbHVzaXZlID8gJycgOiAnICsgMScpO1xuICAgIHJldHVybiBgXG4gICAgICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXJcbiAgICAgICAgICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ291dHB1dFNpemUnLCAndTMyJylcbiAgICAgICAgICAgICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ2F4aXMnLCAndTMyJylcbiAgICAgICAgICAgICAgICAgIC5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBvdXRwdXQpfVxuICAgICAgICAgICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxuICAgICAgICAgICAgICAgICAgdmFyIGlucHV0SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICAgICAgICAgICAgIHZhciBzdW0gPSAke291dHB1dC50eXBlLnZhbHVlfSgwKTtcbiAgICAgICAgICAgICAgICAgIGxldCBmaXJzdCA6IGkzMiA9ICR7bG93ZXJMaW1pdH07XG4gICAgICAgICAgICAgICAgICBsZXQgbGFzdCA6IGkzMiA9ICR7dXBwZXJMaW1pdH07XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIDogaTMyID0gZmlyc3Q7IGkgPCBsYXN0OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dEluZGljZXMnLCAndW5pZm9ybXMuYXhpcycsICd1MzIoaSknKX07XG4gICAgICAgICAgICAgICAgICAgIHN1bSA9IHN1bSArICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dEluZGljZXMnKX07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICdzdW0nKX07XG4gICAgICAgICAgICAgICAgfWA7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0N1bVN1bScsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYXR0cmlidXRlcy5jYWNoZUtleSwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IGlucHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dFR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXM6IFtcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF4aXMgfSxcbiAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSwgaW5wdXRTaGFwZSksXG4gICAgICBdLFxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBjdW1zdW0gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEN1bVN1bUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGNvbnRleHQuaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGlucHV0VHlwZSA9IGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlO1xuICBjb25zdCBheGlzID0gY29udGV4dC5pbnB1dHNbMV07XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVDdW1zdW1Qcm9ncmFtSW5mbyhpbnB1dFR5cGUsIGlucHV0U2hhcGUsIGF4aXMsIGF0dHJpYnV0ZXMpLCB7IGlucHV0czogWzBdIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQ3VtU3VtQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEN1bVN1bUF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBleGNsdXNpdmUgPSAoYXR0cmlidXRlcy5leGNsdXNpdmUgYXMgbnVtYmVyKSA9PT0gMTtcbiAgY29uc3QgcmV2ZXJzZSA9IChhdHRyaWJ1dGVzLnJldmVyc2UgYXMgbnVtYmVyKSA9PT0gMTtcbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGV4Y2x1c2l2ZSwgcmV2ZXJzZSB9KTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgSW5kaWNlc0hlbHBlciwgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBGb3JtYXRBdHRyaWJ1dGVzIHtcbiAgcmVhZG9ubHkgZm9ybWF0OiAnTkhXQycgfCAnTkNIVyc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVwdGhUb1NwYWNlQXR0cmlidXRlcyBleHRlbmRzIEZvcm1hdEF0dHJpYnV0ZXMsIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGJsb2Nrc2l6ZTogbnVtYmVyO1xuICByZWFkb25seSBtb2RlOiBzdHJpbmc7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlcHRoVG9TcGFjZSByZXF1aXJlcyAxIGlucHV0LicpO1xuICB9XG4gIGlmIChpbnB1dHNbMF0uZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlcHRoVG9TcGFjZSByZXF1aXJlcyA0RCBpbnB1dC4nKTtcbiAgfVxufTtcblxuY29uc3QgcGVybUZ1bmN0aW9uQm9keSA9IChwZXJtOiBudW1iZXJbXSwgcmFuazogbnVtYmVyLCBpbnB1dDogSW5kaWNlc0hlbHBlciwgb3V0cHV0OiBJbmRpY2VzSGVscGVyKTogc3RyaW5nID0+IHtcbiAgY29uc3QgcmV2ZXJzZUZ1bmMgPSBbXTtcbiAgcmV2ZXJzZUZ1bmMucHVzaChgZm4gcGVybShpOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiAke2lucHV0LnR5cGUuaW5kaWNlc30ge1xuICAgIHZhciBhOiAke2lucHV0LnR5cGUuaW5kaWNlc307YCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuazsgKytpKSB7XG4gICAgcmV2ZXJzZUZ1bmMucHVzaChpbnB1dC5pbmRpY2VzU2V0KCdhJywgcGVybVtpXSwgYGlbJHtpfV1gKSk7XG4gIH1cbiAgcmV2ZXJzZUZ1bmMucHVzaCgncmV0dXJuIGE7fScpO1xuICByZXR1cm4gcmV2ZXJzZUZ1bmMuam9pbignXFxuJyk7XG59O1xuXG5jb25zdCBjcmVhdGVEZXB0aFRvU3BhY2VQcm9ncmFtSW5mbyA9IChpbnB1dFRlbnNvcjogVGVuc29yVmlldywgYXR0cmlidXRlczogRGVwdGhUb1NwYWNlQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgbGV0IG46IG51bWJlciwgaDogbnVtYmVyLCB3OiBudW1iZXIsIGM6IG51bWJlcjtcbiAgbGV0IHNoYXBlOiBudW1iZXJbXTtcbiAgbGV0IHBlcm06IG51bWJlcltdO1xuICBjb25zdCBpc0NoYW5uZWxMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcbiAgY29uc3QgYmxvY2tzaXplID0gYXR0cmlidXRlcy5ibG9ja3NpemU7XG4gIGNvbnN0IGlzRENSbW9kZSA9IGF0dHJpYnV0ZXMubW9kZSA9PT0gJ0RDUic7XG4gIGlmIChpc0NoYW5uZWxMYXN0KSB7XG4gICAgW24sIGgsIHcsIGNdID0gaW5wdXRUZW5zb3IuZGltcztcbiAgICBzaGFwZSA9IGlzRENSbW9kZVxuICAgICAgPyBbbiwgaCwgdywgYmxvY2tzaXplLCBibG9ja3NpemUsIGMgLyBibG9ja3NpemUgKiogMl1cbiAgICAgIDogW24sIGgsIHcsIGMgLyBibG9ja3NpemUgKiogMiwgYmxvY2tzaXplLCBibG9ja3NpemVdO1xuICAgIHBlcm0gPSBpc0RDUm1vZGUgPyBbMCwgMSwgMywgMiwgNCwgNV0gOiBbMCwgMSwgNCwgMiwgNSwgM107XG4gIH0gZWxzZSB7XG4gICAgW24sIGgsIHcsIGNdID0gW2lucHV0VGVuc29yLmRpbXNbMF0sIGlucHV0VGVuc29yLmRpbXNbMl0sIGlucHV0VGVuc29yLmRpbXNbM10sIGlucHV0VGVuc29yLmRpbXNbMV1dO1xuICAgIHNoYXBlID0gaXNEQ1Jtb2RlXG4gICAgICA/IFtuLCBibG9ja3NpemUsIGJsb2Nrc2l6ZSwgYyAvIGJsb2Nrc2l6ZSAqKiAyLCBoLCB3XVxuICAgICAgOiBbbiwgYyAvIGJsb2Nrc2l6ZSAqKiAyLCBibG9ja3NpemUsIGJsb2Nrc2l6ZSwgaCwgd107XG4gICAgcGVybSA9IGlzRENSbW9kZSA/IFswLCAzLCA0LCAxLCA1LCAyXSA6IFswLCAxLCA0LCAyLCA1LCAzXTtcbiAgfVxuICBjb25zdCByZXNoYXBlZElucHV0VGVuc29yID0gaW5wdXRUZW5zb3IucmVzaGFwZShzaGFwZSk7XG4gIGNvbnN0IHJlc2hhcGVkSW5wdXRSYW5rID0gcmVzaGFwZWRJbnB1dFRlbnNvci5kaW1zLmxlbmd0aDtcbiAgY29uc3QgaW5wdXREYXRhVHlwZSA9IGlucHV0VGVuc29yLmRhdGFUeXBlO1xuXG4gIGNvbnN0IHJlc2hhcGVkSW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdhJywgaW5wdXREYXRhVHlwZSwgcmVzaGFwZWRJbnB1dFJhbmspO1xuICBjb25zdCBwZXJtZWRPdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXREYXRhVHlwZSwgcmVzaGFwZWRJbnB1dFJhbmspO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dF9zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMocmVzaGFwZWRJbnB1dCwgcGVybWVkT3V0cHV0KX1cblxuICAke3Blcm1GdW5jdGlvbkJvZHkocGVybSwgcmVzaGFwZWRJbnB1dFJhbmssIHJlc2hhcGVkSW5wdXQsIHBlcm1lZE91dHB1dCl9XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cblxuICAgIGxldCBpbmRpY2VzID0gJHtwZXJtZWRPdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgIGxldCBhSW5kaWNlcyA9IHBlcm0oaW5kaWNlcyk7XG5cbiAgICAke3Blcm1lZE91dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsIHJlc2hhcGVkSW5wdXQuZ2V0QnlJbmRpY2VzKCdhSW5kaWNlcycpKX1cbiAgfWA7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnRGVwdGhUb1NwYWNlJyxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYCR7aW5wdXRUZW5zb3IuZGltc307JHthdHRyaWJ1dGVzLmJsb2Nrc2l6ZX07JHthdHRyaWJ1dGVzLm1vZGV9YCxcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXSxcbiAgICB9LFxuICAgIGdldFJ1bkRhdGE6IChpbnB1dHMpID0+IHtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gaXNDaGFubmVsTGFzdFxuICAgICAgICA/IFtuLCBoICogYmxvY2tzaXplLCB3ICogYmxvY2tzaXplLCBjIC8gYmxvY2tzaXplICoqIDJdXG4gICAgICAgIDogW24sIGMgLyBibG9ja3NpemUgKiogMiwgaCAqIGJsb2Nrc2l6ZSwgdyAqIGJsb2Nrc2l6ZV07XG4gICAgICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuICAgICAgY29uc3Qgc2hhcGVCZWZvcmVQZXJtID0gcmVzaGFwZWRJbnB1dFRlbnNvci5kaW1zO1xuICAgICAgY29uc3Qgc2hhcGVBZnRlclBlcm0gPSBTaGFwZVV0aWwuc29ydEJhc2VkT25QZXJtKHNoYXBlQmVmb3JlUGVybSwgcGVybSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgICBwcm9ncmFtVW5pZm9ybXM6IFtcbiAgICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgICAgICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKHNoYXBlQmVmb3JlUGVybSwgc2hhcGVBZnRlclBlcm0pLFxuICAgICAgICBdLFxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBkZXB0aFRvU3BhY2UgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IERlcHRoVG9TcGFjZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRGVwdGhUb1NwYWNlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sIGF0dHJpYnV0ZXMpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZURlcHRoVG9TcGFjZUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7XG4gICAgYmxvY2tzaXplOiBhdHRyaWJ1dGVzLmJsb2Nrc2l6ZSBhcyBudW1iZXIsXG4gICAgbW9kZTogYXR0cmlidXRlcy5tb2RlIGFzIHN0cmluZyxcbiAgICBmb3JtYXQ6IGF0dHJpYnV0ZXMuZm9ybWF0IGFzICdOSFdDJyB8ICdOQ0hXJyxcbiAgfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIgfSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRWluc3VtQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGVxdWF0aW9uOiBzdHJpbmc7XG59XG4vLyBUaGUgZXF1YXRpb24gYXR0cmlidXRlIHZhbHVlIGlzIGEgc3RyaW5nIHdoaWNoIGNvbnNpc3RzIG9mIGxlZnQgaGFuZCBzaWRlIChMSFMpIGFuZCBvcHRpb25hbGx5IHJpZ2h0IGhhbmQgc2lkZSAoUkhTKVxuLy8gc2VwYXJhdGVkIGJ5ICctPicuIEV4LiBcImlqLGprIC0+IGlrXCIgZXhwcmVzc2VzIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuLy8gICAgIFwiaWotPmppXCIgZXhwcmVzc2VzIG1hdHJpeCB0cmFuc3Bvc2Vcbi8vICAgICAgXCJpaS0+aVwiIGRpYWdvbmFsIGVsZW1lbnRzIG9mIGEgc3F1YXJlIG1hdHJpeFxuLy8gTEhTIGNvbnNpc3RzIG9mIGEgc2VxdWVuY2Ugb2YgdGVybXMgc2VwYXJhdGVkIGJ5IGNvbW1hcy4gRWFjaCB0ZXJtIGNvcnJlc3BvbmRzIHRvIGFuIGlucHV0IHZhcmlhYmxlLlxuLy8gRWFjaCBzeW1ib2wgY29ycmVzcG9uZHMgdG8gYSBkaW1lbnNpb24gaW4gdGhlIGlucHV0IHZhcmlhYmxlLiBUaGUgc3ltYm9sIGNhbiBiZSBlaXRoZXIgYSBsZXR0ZXIsICdhJyB0byAneicgb3IgJ0EnIHRvXG4vLyAnWicgb3IgJy4uLicgdG8gcmVwcmVzZW50IGFyYml0cmFyeSBkaW1lbnNpb25zLlxuXG5jb25zdCBzeW1ib2xQYXR0ZXJuID0gJ1thLXpBLVpdfFxcXFwuXFxcXC5cXFxcLic7IC8vIFRoZSBwYXR0ZXJuIGVhY2ggc3ltYm9sIGluIGVhY2ggdGVybSBpbiB0aGUgc3ltYm9saWMgZXF1YXRpb24gc2hvdWxkIG1hdGNoXG5jb25zdCB0ZXJtUGF0dGVybiA9ICcoJyArIHN5bWJvbFBhdHRlcm4gKyAnKSsnOyAvLyBUaGUgcGF0dGVybiBlYWNoIHRlcm0gaW4gdGhlIHN5bWJvbGljIGVxdWF0aW9uIHNob3VsZCBtYXRjaFxuY29uc3QgdGVybVBhdHRlcm5Pbmx5ID0gJ14nICsgdGVybVBhdHRlcm4gKyAnJCc7IC8vIFRoZSBwYXR0ZXJucyBvbmx5IG1hdGNocyBhIHRlcm0gYmVnaW4gdG8gZW5kLlxuY29uc3QgbGhzUGF0dGVybiA9ICcoJyArIHRlcm1QYXR0ZXJuICsgJywpKicgKyB0ZXJtUGF0dGVybjsgLy8gVGhlIHBhdHRlcm4gdGhlIExIUyBzaG91bGQgbWF0Y2hcbmNvbnN0IGxoc1BhdHRlcm5Pbmx5ID0gJ14nICsgbGhzUGF0dGVybiArICckJzsgLy8gVGhlIHBhdHRlcm5zIG9ubHkgbWF0Y2hzIGEgTEhTIGJlZ2luIHRvIGVuZC5cblxuaW50ZXJmYWNlIFN5bWJvbEluZm8ge1xuICBjb3VudDogbnVtYmVyOyAvLyBTeW1ib2wgY29ycmVzcG9uZGluZyB0byBhIGRpbW1lbnNpb24gb2YgYW4gaW5wdXRcbiAgaW5wdXRJbmRpY2VzOiBudW1iZXJbXTsgLy8gTnVtYmVyIG9mIGlucHV0IHZhcmlhYmxlcyB0aGUgc3ltYm9sIGNvcnJlc3BvbmRzIHRvXG4gIGRpbVZhbHVlOiBudW1iZXI7IC8vIE51bWJlciBvZiBkaW1lbnNpb25zIHRoZSBzeW1ib2wgY29ycmVzcG9uZHMgdG9cbn1cblxuY2xhc3MgRWluc3VtVGVybSB7XG4gIGNvbnN0cnVjdG9yKGlucHV0SW5kZXggPSAtMSkge1xuICAgIHRoaXMuc3ltYm9sVG9JbmRpY2VzID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcltdPigpO1xuICAgIHRoaXMuaW5wdXRJbmRleCA9IGlucHV0SW5kZXg7XG4gIH1cblxuICAvLyBBZGQgYSBzeW1ib2wgdG8gdGhlIHRlcm1cbiAgYWRkU3ltYm9sKHN5bWJvbDogc3RyaW5nLCBpbmRleDogbnVtYmVyKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5zeW1ib2xUb0luZGljZXMuZ2V0KHN5bWJvbCk7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlID0gW2luZGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUucHVzaChpbmRleCk7XG4gICAgfVxuICAgIHRoaXMuc3ltYm9sVG9JbmRpY2VzLnNldChzeW1ib2wsIHZhbHVlKTtcbiAgfVxuXG4gIHN5bWJvbFRvSW5kaWNlczogTWFwPHN0cmluZywgbnVtYmVyW10+OyAvLyBNYXAgZnJvbSBzeW1ib2wgdG8gZGltZW5zaW9ucyBvZiB0aGUgaW5wdXQgY29ycmVzcG9uZGluZyB0byB0aGUgdGVybVxuICBpbnB1dEluZGV4OiBudW1iZXI7IC8vIC0xIGZvciBvdXRwdXQgYW5kIDAsIDEsIDIsIC4uLiBmb3IgaW5wdXRzXG59XG5cbmNsYXNzIEVpbnN1bUVxdWF0aW9uIHtcbiAgY29uc3RydWN0b3IoXG4gICAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gICAgcHVibGljIHJlYWRvbmx5IGVxdWF0aW9uOiBzdHJpbmcsXG4gICkge1xuICAgIHRoaXMuaGFzRWxsaXBzaXMgPSBmYWxzZTtcbiAgICB0aGlzLnN5bWJvbFRvSW5mbyA9IG5ldyBNYXA8c3RyaW5nLCBTeW1ib2xJbmZvPigpO1xuICAgIHRoaXMubGhzID0gbmV3IEFycmF5PEVpbnN1bVRlcm0+KCk7XG4gICAgdGhpcy5vdXRwdXREaW1zID0gW107XG4gICAgLy8gQXMgcmhzIG5lZWRzIHRvIGJlIHVwZGF0ZWQgYWxsb3cgdXNpbmcgbGV0IGluc3RlYWQgb2YgY29uc3QgZm9yIGJvdGggbGhzIGFuZCByaHMuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgIGxldCBbbGhzLCByaHNdID0gZXF1YXRpb24uaW5jbHVkZXMoJy0+JykgPyBlcXVhdGlvbi5zcGxpdCgnLT4nLCAyKSA6IFtlcXVhdGlvbiwgJyddO1xuICAgIGlmICghbGhzLm1hdGNoKFJlZ0V4cChsaHNQYXR0ZXJuT25seSkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTEhTIHRlcm0nKTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRUZXJtcyA9IGxocy5zcGxpdCgnLCcpO1xuICAgIGlucHV0VGVybXMuZm9yRWFjaCgoaW5wdXRUZXJtLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgZGltcyA9IGlucHV0c1tpbmRleF0uZGltcy5zbGljZSgpO1xuICAgICAgaWYgKCFpbnB1dFRlcm0ubWF0Y2goUmVnRXhwKHRlcm1QYXR0ZXJuT25seSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMSFMgdGVybScpO1xuICAgICAgfVxuICAgICAgY29uc3QgZWluc3VtVGVybSA9IHRoaXMucHJvY2Vzc1Rlcm0oaW5wdXRUZXJtLCB0cnVlLCBkaW1zLCBpbmRleCk7XG4gICAgICB0aGlzLmxocy5wdXNoKGVpbnN1bVRlcm0pO1xuICAgIH0pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgUkhTIGlmIG5vdCBzcGVjaWZpZWRcbiAgICBpZiAocmhzID09PSAnJykge1xuICAgICAgLy8gQ29uc3RydWN0IFJIUyBmcm9tIExIUyB0ZXJtcy9zeW1ib2xzXG4gICAgICByaHMgKz0gWy4uLnRoaXMuc3ltYm9sVG9JbmZvLmVudHJpZXMoKV1cbiAgICAgICAgLmZpbHRlcigoW3N5bSwgaW5mb10pID0+IGluZm8uY291bnQgPT09IDEgfHwgc3ltID09PSAnLi4uJylcbiAgICAgICAgLm1hcCgoW3N5bV0pID0+IHN5bSlcbiAgICAgICAgLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXJocy5tYXRjaChSZWdFeHAodGVybVBhdHRlcm4pKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUkhTJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBvdXRwdXQgZGltc1xuICAgIGNvbnN0IHJoc1N5bWJvbHMgPSByaHMubWF0Y2goUmVnRXhwKHN5bWJvbFBhdHRlcm4sICdnJykpO1xuICAgIHJoc1N5bWJvbHM/LmZvckVhY2goKHN5bWJvbCkgPT4ge1xuICAgICAgaWYgKHN5bWJvbCA9PT0gJy4uLicpIHtcbiAgICAgICAgdGhpcy5vdXRwdXREaW1zID0gdGhpcy5vdXRwdXREaW1zLmNvbmNhdCh0aGlzLmVsbGlwc2lzRGltcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpbmZvID0gdGhpcy5zeW1ib2xUb0luZm8uZ2V0KHN5bWJvbCk7XG4gICAgICAgIGlmIChpbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUkhTIHN5bWJvbCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0RGltcy5wdXNoKGluZm8uZGltVmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucmhzID0gdGhpcy5wcm9jZXNzVGVybShyaHMsIGZhbHNlLCB0aGlzLm91dHB1dERpbXMpO1xuICB9IC8vIEVuZCBvZiBFaW5zdW1FcWF0aW9uIGNvbnN0cnVjdG9yXG5cbiAgLy8gQWRkIGEgc3ltYm9sIHRvIHRoZSBlcXVhdGlvblxuICBhZGRTeW1ib2woc3ltYm9sOiBzdHJpbmcsIGRpbVZhbHVlOiBudW1iZXIsIGlucHV0SW5kZXg6IG51bWJlcikge1xuICAgIGxldCBpbmZvID0gdGhpcy5zeW1ib2xUb0luZm8uZ2V0KHN5bWJvbCk7XG4gICAgaWYgKGluZm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGluZm8uZGltVmFsdWUgIT09IGRpbVZhbHVlICYmIGluZm8uY291bnQgIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb24gbWlzbWF0Y2gnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8uY291bnQrKztcbiAgICAgICAgaW5mby5pbnB1dEluZGljZXMucHVzaChpbnB1dEluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyA9IHsgY291bnQ6IDEsIGRpbVZhbHVlLCBpbnB1dEluZGljZXM6IFtpbnB1dEluZGV4XSB9O1xuICAgIH1cbiAgICB0aGlzLnN5bWJvbFRvSW5mby5zZXQoc3ltYm9sLCBpbmZvKTtcbiAgfVxuXG4gIC8vIFByb2Nlc3Mgb25lIGlucHV0L291dHB1dCB0ZXJtXG4gIHByb2Nlc3NUZXJtKHRlcm06IHN0cmluZywgaXNJbnB1dDogYm9vbGVhbiwgZGltczogcmVhZG9ubHkgbnVtYmVyW10sIGluZGV4ID0gLTEpOiBFaW5zdW1UZXJtIHtcbiAgICBjb25zdCByYW5rID0gZGltcy5sZW5ndGg7XG4gICAgbGV0IGVsbGlwc2lzID0gZmFsc2U7XG4gICAgbGV0IGVsbGlwc2lzRGltcyA9IFtdO1xuICAgIGxldCBuZXh0RGltID0gMDtcbiAgICAvLyBGb3Igb3V0cHV0IGVtcHR5IHN0cmluZyBpcyBhbGxvd2VkIGJlY2F1c2UgdGhlIG91dHB1dCBtYXkgYmUgcmVkdWNlZCB0byBhIHNjYWxhciB2YWx1ZVxuICAgIGlmICghdGVybS5tYXRjaChSZWdFeHAodGVybVBhdHRlcm5Pbmx5KSkgJiYgIWlzSW5wdXQgJiYgdGVybSAhPT0gJycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMSFMgdGVybScpO1xuICAgIH1cbiAgICBjb25zdCBpbmRleFN5bWJvbHMgPSB0ZXJtLm1hdGNoKFJlZ0V4cChzeW1ib2xQYXR0ZXJuLCAnZycpKTtcbiAgICBjb25zdCBlaW5zdW1UZXJtID0gbmV3IEVpbnN1bVRlcm0oaW5kZXgpO1xuICAgIC8vIHN5bWJvbCBjYW4gYmUgZWl0aGVyIGEgbGV0dHJlLCAnYScgdG8gJ3onIG9yICdBJyB0byAnWicsIG9yICcuLi4nXG4gICAgaW5kZXhTeW1ib2xzPy5mb3JFYWNoKChzeW1ib2w6IHN0cmluZywgaTogbnVtYmVyKSA9PiB7XG4gICAgICBpZiAoc3ltYm9sID09PSAnLi4uJykge1xuICAgICAgICBpZiAoZWxsaXBzaXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb25lIGVsbGlwc2lzIGlzIGFsbG93ZWQgcGVyIGlucHV0IHRlcm0nKTtcbiAgICAgICAgfVxuICAgICAgICBlbGxpcHNpcyA9IHRydWU7XG4gICAgICAgIGNvbnN0IGVsbGlwc2lzRGltTGVuZ3RoID0gcmFuayAtIGluZGV4U3ltYm9scy5sZW5ndGggKyAxO1xuICAgICAgICBpZiAoZWxsaXBzaXNEaW1MZW5ndGggPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGxpcHNpcyBvdXQgb2YgYm91bmRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxsaXBzaXNEaW1zID0gZGltcy5zbGljZShuZXh0RGltLCBuZXh0RGltICsgZWxsaXBzaXNEaW1MZW5ndGgpO1xuICAgICAgICBpZiAodGhpcy5oYXNFbGxpcHNpcykge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuZWxsaXBzaXNEaW1zLmxlbmd0aCAhPT0gZWxsaXBzaXNEaW1zLmxlbmd0aCB8fFxuICAgICAgICAgICAgdGhpcy5lbGxpcHNpc0RpbXMudG9TdHJpbmcoKSAhPT0gZWxsaXBzaXNEaW1zLnRvU3RyaW5nKClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRWxsaXBzaXMgZGltZW5zaW9ucyBtaXNtYXRjaCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc0lucHV0KSB7XG4gICAgICAgICAgdGhpcy5oYXNFbGxpcHNpcyA9IHRydWU7XG4gICAgICAgICAgdGhpcy5lbGxpcHNpc0RpbXMgPSBlbGxpcHNpc0RpbXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGxpcHNpcyBtdXN0IGJlIHNwZWNpZmllZCBpbiB0aGUgTEhTJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkICcwJywgJzEnLCAnMicsICczJywgJzQnLCBldGMgdG8gcmVwcmVzZW50IGVsbGlwc2lzIGRpbWVuc2lvbnMgdG8gYXZvaWQgc3BlY2lhbCBoYW5kbGluZ1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGVsbGlwc2lzRGltcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IHN5bWJvbCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoJzAnLmNoYXJDb2RlQXQoMCkgKyBqKTtcbiAgICAgICAgICBlaW5zdW1UZXJtLmFkZFN5bWJvbChzeW1ib2wsIGkgKyBqKTtcbiAgICAgICAgICB0aGlzLmFkZFN5bWJvbChzeW1ib2wsIGRpbXNbbmV4dERpbSsrXSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlaW5zdW1UZXJtLmFkZFN5bWJvbChzeW1ib2wsIGkgKyAodGhpcy5oYXNFbGxpcHNpcyA/IHRoaXMuZWxsaXBzaXNEaW1zLmxlbmd0aCAtIDEgOiAwKSk7XG4gICAgICAgIHRoaXMuYWRkU3ltYm9sKHN5bWJvbCwgZGltc1tuZXh0RGltKytdLCBpbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGVpbnN1bVRlcm07XG4gIH1cblxuICBzeW1ib2xUb0luZm86IE1hcDxzdHJpbmcsIFN5bWJvbEluZm8+OyAvLyBBbGwgc3ltYm9scyBpbiB0aGUgZXF1YXRpb25cbiAgaGFzRWxsaXBzaXM6IGJvb2xlYW47IC8vIFRoZSBlcXVhdGlvbiBoYXMgZWxsaXBzaXMgb3Igbm90XG4gIGVsbGlwc2lzRGltczogbnVtYmVyW107IC8vIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBlcXVhdGlvbiBlbGxpcHNpcyBjb3JyZXNwb25kcyB0by5cbiAgbGhzOiBFaW5zdW1UZXJtW107IC8vIFRlcm1zIG9uIHRoZSBsZWZ0LWhhbmQgc2lkZSBvZiB0aGUgZXF1YXRpb25cbiAgcmhzOiBFaW5zdW1UZXJtOyAvLyBUZXJtIG9uIHRoZSByaWdodC1oYW5kIHNpZGUgb2YgdGhlIGVxdWF0aW9uXG4gIG91dHB1dERpbXM6IG51bWJlcltdOyAvLyBPdXRwdXQgZGltZW5zaW9ucyBvZiB0aGUgZXF1YXRpb25cbn0gLy8gRW5kIG9mIGNsYXNzIEVpbnN1bUVxdWF0aW9uXG5cbmNvbnN0IGFwcGVuZE1heCA9IChuYW1lOiBzdHJpbmcpOiBzdHJpbmcgPT4gbmFtZSArICdfbWF4JztcblxuY29uc3QgY3JlYXRlRWluc3VtUHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0U2hhcGVzOiBBcnJheTxyZWFkb25seSBudW1iZXJbXT4sXG4gIGRhdGFUeXBlOiBudW1iZXIsXG4gIGVpbnN1bUVxdWF0aW9uOiBFaW5zdW1FcXVhdGlvbixcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCByYW5rcyA9IGlucHV0U2hhcGVzLm1hcCgoZGltcykgPT4gZGltcy5sZW5ndGgpO1xuICBjb25zdCBpbnB1dFZhcnMgPSByYW5rcy5tYXAoKHJhbmssIGluZGV4KSA9PiBpbnB1dFZhcmlhYmxlKGBpbnB1dCR7aW5kZXh9YCwgZGF0YVR5cGUsIHJhbmspKTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICBjb25zdCB1bmlmb3Jtc1N5bWJvbHMgPSBbLi4uZWluc3VtRXF1YXRpb24uc3ltYm9sVG9JbmZvLmtleXMoKV0uZmlsdGVyKFxuICAgIChzeW1ib2wpID0+ICFlaW5zdW1FcXVhdGlvbi5yaHMuc3ltYm9sVG9JbmRpY2VzLmhhcyhzeW1ib2wpLFxuICApO1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBpZHhDb3B5OiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IGluaXRQcm9kID0gJ3ZhciBwcm9kID0gMS4wOyc7XG4gICAgY29uc3QgaW5pdFN1bSA9ICd2YXIgc3VtID0gMC4wOyc7XG4gICAgY29uc3QgdXBkYXRlU3VtID0gJ3N1bSArPSBwcm9kOyc7XG4gICAgY29uc3QgcmVkdWNlT3BzU2V0SW5kaWNlczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCByZWR1Y2VPcHNMb29wSGVhZGVyczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCByZWR1Y2VPcHNMb29wRm9vdGVyczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCByZWR1Y2VPcENvbXB1dGU6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgaXNSZWR1Y2VPcHNXaXRob3V0TG9vcCA9IGVpbnN1bUVxdWF0aW9uLnN5bWJvbFRvSW5mby5zaXplID09PSBlaW5zdW1FcXVhdGlvbi5yaHMuc3ltYm9sVG9JbmRpY2VzLnNpemU7XG4gICAgZWluc3VtRXF1YXRpb24uc3ltYm9sVG9JbmZvLmZvckVhY2goKGluZm8sIHN5bWJvbCkgPT4ge1xuICAgICAgaWYgKGVpbnN1bUVxdWF0aW9uLnJocy5zeW1ib2xUb0luZGljZXMuaGFzKHN5bWJvbCkpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0SW5kZXggPSBlaW5zdW1FcXVhdGlvbi5yaHMuc3ltYm9sVG9JbmRpY2VzLmdldChzeW1ib2wpPy5bMF07XG4gICAgICAgIGlmIChvdXRwdXRJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZWluc3VtRXF1YXRpb24ubGhzLmZvckVhY2goKHRlcm0sIGkpID0+IHtcbiAgICAgICAgICAgIGlmIChpbmZvLmlucHV0SW5kaWNlcy5pbmNsdWRlcyhpKSkge1xuICAgICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gdGVybS5zeW1ib2xUb0luZGljZXMuZ2V0KHN5bWJvbCk7XG4gICAgICAgICAgICAgIGlmIChpbmRpY2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3ltYm9sIGVycm9yJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaW5kaWNlcy5mb3JFYWNoKChpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlkeENvcHkucHVzaChcbiAgICAgICAgICAgICAgICAgIGAke2lucHV0VmFyc1tpXS5pbmRpY2VzU2V0KFxuICAgICAgICAgICAgICAgICAgICBgaW5wdXQke2l9SW5kaWNlc2AsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0SW5kaWNlcycsIG91dHB1dEluZGV4KSxcbiAgICAgICAgICAgICAgICAgICl9YCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWluc3VtRXF1YXRpb24ubGhzLmZvckVhY2goKHRlcm0sIGkpID0+IHtcbiAgICAgICAgICBpZiAoaW5mby5pbnB1dEluZGljZXMuaW5jbHVkZXMoaSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGljZXMgPSB0ZXJtLnN5bWJvbFRvSW5kaWNlcy5nZXQoc3ltYm9sKTtcbiAgICAgICAgICAgIGlmIChpbmRpY2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN5bWJvbCBlcnJvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kaWNlcy5mb3JFYWNoKChpbmRleCkgPT4ge1xuICAgICAgICAgICAgICByZWR1Y2VPcHNTZXRJbmRpY2VzLnB1c2goYCR7aW5wdXRWYXJzW2ldLmluZGljZXNTZXQoYGlucHV0JHtpfUluZGljZXNgLCBpbmRleCwgYCR7c3ltYm9sfWApfWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZWR1Y2VPcENvbXB1dGUucHVzaChgcHJvZCAqPSAke2lucHV0VmFyc1tpXS5nZXRCeUluZGljZXMoYGlucHV0JHtpfUluZGljZXNgKX07YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVkdWNlT3BzTG9vcEhlYWRlcnMucHVzaChcbiAgICAgICAgICBgZm9yKHZhciAke3N5bWJvbH06IHUzMiA9IDA7ICR7c3ltYm9sfSA8IHVuaWZvcm1zLiR7YXBwZW5kTWF4KHN5bWJvbCl9OyAke3N5bWJvbH0rKykge2AsXG4gICAgICAgICk7XG4gICAgICAgIHJlZHVjZU9wc0xvb3BGb290ZXJzLnB1c2goJ30nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCByZWR1Y2VPcHMgPSBpc1JlZHVjZU9wc1dpdGhvdXRMb29wXG4gICAgICA/IFtcbiAgICAgICAgICAuLi5pZHhDb3B5LFxuICAgICAgICAgIGBsZXQgc3VtID0gJHtpbnB1dFZhcnMubWFwKChpbnB1dFZhciwgaSkgPT4gaW5wdXRWYXIuZ2V0QnlJbmRpY2VzKGBpbnB1dCR7aX1JbmRpY2VzYCkpLmpvaW4oJyAqICcpfTtgLFxuICAgICAgICBdXG4gICAgICA6IFtcbiAgICAgICAgICAuLi5pZHhDb3B5LFxuICAgICAgICAgIGluaXRTdW0sXG4gICAgICAgICAgLi4ucmVkdWNlT3BzTG9vcEhlYWRlcnMsXG4gICAgICAgICAgLi4ucmVkdWNlT3BzU2V0SW5kaWNlcyxcbiAgICAgICAgICBpbml0UHJvZCxcbiAgICAgICAgICAuLi5yZWR1Y2VPcENvbXB1dGUsXG4gICAgICAgICAgdXBkYXRlU3VtLFxuICAgICAgICAgIC4uLnJlZHVjZU9wc0xvb3BGb290ZXJzLFxuICAgICAgICBdO1xuICAgIHJldHVybiBgXG4gICAgICAgICAgICAke3NoYWRlckhlbHBlclxuICAgICAgICAgICAgICAucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3Jtc1N5bWJvbHMubWFwKChzeW1ib2wpID0+ICh7IG5hbWU6IGAke2FwcGVuZE1heChzeW1ib2wpfWAsIHR5cGU6ICd1MzInIH0pKSlcbiAgICAgICAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0U2l6ZScsICd1MzInKVxuICAgICAgICAgICAgICAuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcnMsIG91dHB1dCl9XG5cbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxuICAgICAgICAgICAgdmFyIG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICAgICAgICAke2lucHV0VmFycy5tYXAoKF92YXIsIGkpID0+IGB2YXIgaW5wdXQke2l9SW5kaWNlczogJHtpbnB1dFZhcnNbaV0udHlwZS5pbmRpY2VzfTtgKS5qb2luKCdcXG4nKX1cbiAgICAgICAgICAgICR7cmVkdWNlT3BzLmpvaW4oJ1xcbicpfTtcbiAgICAgICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3N1bScpfTtcbiAgICAgICAgICB9YDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnRWluc3VtJyxcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBlaW5zdW1FcXVhdGlvbi5lcXVhdGlvbiwgaW5wdXREZXBlbmRlbmNpZXM6IGlucHV0U2hhcGVzLm1hcCgoKSA9PiAncmFuaycpIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4ge1xuICAgICAgLy8gVGhlIHN5bWJvbHMgZnJvbSB1bmlmb3JtU3ltYm9scyBhcnJheSBhcmUgZ3VhcmFudGVlZCB0byBleGlzdCBpbiBlaW5zdW1FcXVhdGlvbnMuc3ltYm9sVG9JbmZvIG1hcC4gVGhlXG4gICAgICAvLyBmaWx0ZXIgaXMgYWRkZWQgdG8gbWFrZSBzdXJlIHRoYXQgZGltVmFsdWUgaXMgbmV2ZXIgMC5cbiAgICAgIGNvbnN0IHByb2dyYW1Vbmlmb3Jtc0luaXQ6IFByb2dyYW1Vbmlmb3JtW10gPSB1bmlmb3Jtc1N5bWJvbHNcbiAgICAgICAgLmZpbHRlcigoc3ltYm9sKSA9PiBlaW5zdW1FcXVhdGlvbi5zeW1ib2xUb0luZm8uaGFzKHN5bWJvbCkpXG4gICAgICAgIC5tYXAoKHN5bWJvbCkgPT4gKHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBlaW5zdW1FcXVhdGlvbi5zeW1ib2xUb0luZm8uZ2V0KHN5bWJvbCk/LmRpbVZhbHVlIHx8IDAgfSkpO1xuICAgICAgcHJvZ3JhbVVuaWZvcm1zSW5pdC5wdXNoKHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0pO1xuICAgICAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gaW5wdXRTaGFwZXNcbiAgICAgICAgLm1hcCgoZGltcywgXykgPT4gWy4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGRpbXMpXSlcbiAgICAgICAgLnJlZHVjZSgoYWNjLCBpbnB1dFByb2dyYW1Vbmlmb3JtcykgPT4gYWNjLmNvbmNhdChpbnB1dFByb2dyYW1Vbmlmb3JtcyksIHByb2dyYW1Vbmlmb3Jtc0luaXQpO1xuICAgICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZSB9XSxcbiAgICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGVpbnN1bSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogRWluc3VtQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBlaW5zdW1FcXVhdGlvbiA9IG5ldyBFaW5zdW1FcXVhdGlvbihjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcy5lcXVhdGlvbik7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gZWluc3VtRXF1YXRpb24ub3V0cHV0RGltcztcbiAgY29uc3QgaW5wdXRTaGFwZXMgPSBjb250ZXh0LmlucHV0cy5tYXAoKGlucHV0LCBfKSA9PiBpbnB1dC5kaW1zKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUVpbnN1bVByb2dyYW1JbmZvKGlucHV0U2hhcGVzLCBjb250ZXh0LmlucHV0c1swXS5kYXRhVHlwZSwgZWluc3VtRXF1YXRpb24sIG91dHB1dFNoYXBlKSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VFaW5zdW1BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogRWluc3VtQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGVxdWF0aW9uID0gKGF0dHJpYnV0ZXMuZXF1YXRpb24gYXMgc3RyaW5nKS5yZXBsYWNlKC9cXHMrL2csICcnKTtcbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGVxdWF0aW9uIH0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMgfHwgaW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwYW5kIHJlcXVpcmVzIDIgaW5wdXQuJyk7XG4gIH1cbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBzaGFwZSA9IEFycmF5LmZyb20oaW5wdXRzWzFdLmdldEJpZ0ludDY0QXJyYXkoKSwgTnVtYmVyKTtcblxuICBsZXQgc2hhcGVJbmRleCA9IHNoYXBlLmxlbmd0aCA8IGlucHV0U2hhcGUubGVuZ3RoID8gMCA6IHNoYXBlLmxlbmd0aCAtIGlucHV0U2hhcGUubGVuZ3RoO1xuICBsZXQgaW5wdXRTaGFwZUluZGV4ID0gaW5wdXRTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGggPyAwIDogaW5wdXRTaGFwZS5sZW5ndGggLSBzaGFwZS5sZW5ndGg7XG4gIGZvciAoOyBzaGFwZUluZGV4IDwgc2hhcGUubGVuZ3RoICYmIGlucHV0U2hhcGVJbmRleCA8IGlucHV0U2hhcGUubGVuZ3RoOyArK3NoYXBlSW5kZXgsICsraW5wdXRTaGFwZUluZGV4KSB7XG4gICAgaWYgKFxuICAgICAgc2hhcGVbc2hhcGVJbmRleF0gIT09IGlucHV0U2hhcGVbaW5wdXRTaGFwZUluZGV4XSAmJlxuICAgICAgc2hhcGVbc2hhcGVJbmRleF0gIT09IDEgJiZcbiAgICAgIGlucHV0U2hhcGVbaW5wdXRTaGFwZUluZGV4XSAhPT0gMVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBhbmQgcmVxdWlyZXMgc2hhcGUgdG8gYmUgYnJvYWRjYXN0YWJsZSB0byBpbnB1dCcpO1xuICAgIH1cbiAgfVxufTtcblxuY29uc3QgZ2V0QWRqdXN0ZWRTaGFwZSA9IChzaGFwZTE6IHJlYWRvbmx5IG51bWJlcltdLCBzaGFwZTI6IHJlYWRvbmx5IG51bWJlcltdKTogbnVtYmVyW10gPT4ge1xuICBjb25zdCBkaWZmID0gc2hhcGUxLmxlbmd0aCAtIHNoYXBlMi5sZW5ndGg7XG4gIGNvbnN0IHNoYXBlOiBudW1iZXJbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZmY7ICsraSkge1xuICAgIHNoYXBlLnB1c2goc2hhcGUxW2ldKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNoYXBlMi5sZW5ndGg7ICsraSkge1xuICAgIHNoYXBlLnB1c2goc2hhcGUyW2ldID09PSAxID8gc2hhcGUxW2kgKyBkaWZmXSA6IHNoYXBlMltpXSk7XG4gIH1cbiAgcmV0dXJuIHNoYXBlO1xufTtcblxuY29uc3QgY2FsY3VsYXRlT3V0cHV0U2hhcGUgPSAoaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sIHNoYXBlOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlcltdID0+XG4gIGlucHV0U2hhcGUubGVuZ3RoID4gc2hhcGUubGVuZ3RoID8gZ2V0QWRqdXN0ZWRTaGFwZShpbnB1dFNoYXBlLCBzaGFwZSkgOiBnZXRBZGp1c3RlZFNoYXBlKHNoYXBlLCBpbnB1dFNoYXBlKTtcblxuY29uc3QgY3JlYXRlRXhwYW5kUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3Qgc2hhcGUgPSBBcnJheS5mcm9tKGlucHV0c1sxXS5nZXRCaWdJbnQ2NEFycmF5KCksIE51bWJlcik7XG4gIGNvbnN0IG91dHB1dFNoYXBlOiBudW1iZXJbXSA9IGNhbGN1bGF0ZU91dHB1dFNoYXBlKGlucHV0U2hhcGUsIHNoYXBlKTtcbiAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dHNbMF0uZGF0YVR5cGU7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBkYXRhVHlwZSA9PT0gRGF0YVR5cGUuYm9vbCA/IDQgOiAxO1xuICBjb25zdCBvdXRwdXRTaXplID0gTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIGNvbXBvbmVudHMpO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBkYXRhVHlwZSwgaW5wdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBkYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICBsZXQgYXNzaWdubWVudDogc3RyaW5nO1xuICAgIGlmIChkYXRhVHlwZSA9PT0gRGF0YVR5cGUuYm9vbCkge1xuICAgICAgY29uc3Qgc2luZ2xlQXNzaWdubWVudCA9IChyZXNTdHI6IHN0cmluZywgeDogbnVtYmVyLCB0eXBlQ2FzdCA9ICcnKSA9PiBgXG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMke3h9ID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKGBvdXRwdXRPZmZzZXQgKyAke3h9dWApfTtcbiAgICAgICAgICBsZXQgb2Zmc2V0JHt4fSA9ICR7aW5wdXQuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke3h9YCwgb3V0cHV0KX07XG4gICAgICAgICAgbGV0IGluZGV4JHt4fSA9IG9mZnNldCR7eH0gLyA0dTtcbiAgICAgICAgICBsZXQgY29tcG9uZW50JHt4fSA9IG9mZnNldCR7eH0gJSA0dTtcbiAgICAgICAgICAke3Jlc1N0cn1bJHt4fV0gPSAke3R5cGVDYXN0fSgke2lucHV0LmdldEJ5T2Zmc2V0KGBpbmRleCR7eH1gKX1bY29tcG9uZW50JHt4fV0pO1xuICAgICAgICBgO1xuICAgICAgYXNzaWdubWVudCA9IGBcbiAgICAgICAgbGV0IG91dHB1dE9mZnNldCA9IGdsb2JhbF9pZHggKiAke2NvbXBvbmVudHN9O1xuICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMCwgJ3UzMicpfVxuICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAxLCAndTMyJyl9XG4gICAgICAgICR7c2luZ2xlQXNzaWdubWVudCgnZGF0YScsIDIsICd1MzInKX1cbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdkYXRhJywgMywgJ3UzMicpfVxuICAgICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsICdkYXRhJyl9XG4gICAgICB9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWdubWVudCA9IGBcbiAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICAgIGxldCBpbnB1dE9mZnNldCA9ICR7aW5wdXQuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoJ291dHB1dEluZGljZXMnLCBvdXRwdXQpfTtcbiAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCBpbnB1dC5nZXRCeU9mZnNldCgnaW5wdXRPZmZzZXQnKSl9XG4gICAgICB9YDtcbiAgICB9XG4gICAgcmV0dXJuIGBcbiAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ3ZlY19zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG4gICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMudmVjX3NpemUnKX1cbiAgICAke2Fzc2lnbm1lbnR9YDtcbiAgfTtcblxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlLCBvdXRwdXRTaGFwZSksXG4gIF07XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0V4cGFuZCcsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7b3V0cHV0U2hhcGUubGVuZ3RofWAsIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXSB9LFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZXhwYW5kID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUV4cGFuZFByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzKSwgeyBpbnB1dHM6IFswXSB9KTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBpbnB1dFZhcmlhYmxlLFxuICBvdXRwdXRWYXJpYWJsZSxcbiAgU2hhZGVySGVscGVyLFxuICB0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbiAgV09SS0dST1VQX1NJWkUsXG59IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCAqIGFzIHVuYXJ5IGZyb20gJy4vdW5hcnktb3AnO1xuXG4vLyBHRUxVIGlzIGRlZmluZWQgYXMgWT0wLjUqWCooMSt0YW5oKDAuNzk3ODg1KlgrMC4wMzU2NzcqWCpYKlgpKSwgd2hlcmUgWCBtYXkgcHJlLWFkZCBhIGJpYXMuXG5cbmNvbnN0IGNyZWF0ZUZhc3RHZWx1UHJvZ3JhbUluZm8gPSAoaW5wdXRUZW5zb3JzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGRhdGFUeXBlID0gaW5wdXRUZW5zb3JzWzBdLmRhdGFUeXBlO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUoaW5wdXRUZW5zb3JzWzBdLmRpbXMpO1xuICBjb25zdCBiaWFzTGVuZ3RoID0gU2hhcGVVdGlsLnNpemUoaW5wdXRUZW5zb3JzWzFdLmRpbXMpO1xuICAvLyBjYW4gb25seSB1c2UgdmVjNCB3aGVuIGJpYXMgbGVuZ3RoIGlzIG11bHRpcGxlIG9mIDRcbiAgY29uc3QgdXNlVmVjNCA9IGJpYXNMZW5ndGggJSA0ID09PSAwO1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpOiBzdHJpbmcgPT4ge1xuICAgIGNvbnN0IHggPSBpbnB1dFZhcmlhYmxlKCd4JywgZGF0YVR5cGUsIFsxXSwgNCk7XG4gICAgY29uc3QgYmlhcyA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBkYXRhVHlwZSwgWzFdLCA0KTtcbiAgICBjb25zdCB5ID0gb3V0cHV0VmFyaWFibGUoJ3knLCBkYXRhVHlwZSwgWzFdLCA0KTtcblxuICAgIGNvbnN0IHVuaWZvcm1zOiBVbmlmb3Jtc0FycmF5VHlwZSA9IFtcbiAgICAgIHsgbmFtZTogJ291dHB1dF92ZWNfc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdiaWFzX3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgIF07XG5cbiAgICBjb25zdCBzaW5nbGVFbGVtZW50QmlhcyA9IChpOiAwIHwgMSB8IDIgfCAzKSA9PiBgXG4gICAgICBsZXQgYmlhcyR7aX1fb2Zmc2V0OiB1MzIgPSAoZ2xvYmFsX2lkeCAqIDQgKyAke2l9KSAlIHVuaWZvcm1zLmJpYXNfc2l6ZTtcbiAgICAgIGxldCBiaWFzJHtpfSA9ICR7Ymlhcy5nZXRCeU9mZnNldChgYmlhcyR7aX1fb2Zmc2V0IC8gNGApfVtiaWFzJHtpfV9vZmZzZXQgJSA0XTtgO1xuICAgIGNvbnN0IGJpYXNHZXRFeHByZXNzaW9uID0gdXNlVmVjNFxuICAgICAgPyBgXG4gICAgICBsZXQgYmlhcyA9ICR7Ymlhcy5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCAlICh1bmlmb3Jtcy5iaWFzX3NpemUgLyA0KScpfTtgXG4gICAgICA6IGAke3NpbmdsZUVsZW1lbnRCaWFzKDApfSR7c2luZ2xlRWxlbWVudEJpYXMoMSl9JHtzaW5nbGVFbGVtZW50QmlhcygyKX0ke3NpbmdsZUVsZW1lbnRCaWFzKDMpfVxuICAgICAgbGV0IGJpYXMgPSAke3gudHlwZS52YWx1ZX0oYmlhczAsIGJpYXMxLCBiaWFzMiwgYmlhczMpO2A7XG5cbiAgICByZXR1cm4gYCR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoeCwgYmlhcywgeSl9XG5cbiAgICAke3VuYXJ5LmZhc3RHZWx1SW1wbCh0ZW5zb3JUeXBlVG9Xc2dsVmFsdWVUeXBlKGRhdGFUeXBlKSl9XG5cbiAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoV09SS0dST1VQX1NJWkUpfVxuICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3ZlY19zaXplJyl9XG5cbiAgICAgIGxldCB4ID0gJHt4LmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4Jyl9O1xuICAgICAgJHtiaWFzR2V0RXhwcmVzc2lvbn1cbiAgICAgIGxldCB4X2luID0geCArIGJpYXM7XG4gICAgICAke3kuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCB1bmFyeS5mYXN0R2VsdUV4cHJlc3Npb24oJ3hfaW4nKSl9XG4gICAgfWA7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnRmFzdEdlbHVXaXRoQmlhcycsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7dXNlVmVjNH1gLCBpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJywgJ3R5cGUnXSB9LFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICBnZXRSdW5EYXRhOiAoaW5wdXRzKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogaW5wdXRzWzBdLmRpbXMsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXM6IFtcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNCkgfSxcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGJpYXNMZW5ndGggfSxcbiAgICAgIF0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gV09SS0dST1VQX1NJWkUgLyA0KSB9LFxuICAgIH0pLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGZhc3RHZWx1ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0KTogdm9pZCA9PiB7XG4gIGlmIChjb250ZXh0LmlucHV0cy5sZW5ndGggPCAyIHx8IFNoYXBlVXRpbC5zaXplKGNvbnRleHQuaW5wdXRzWzFdLmRpbXMpID09PSAwKSB7XG4gICAgdW5hcnkuZmFzdEdlbHUoY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5jb21wdXRlKGNyZWF0ZUZhc3RHZWx1UHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMpKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBHYXRoZXJBdHRyaWJ1dGVzIGV4dGVuZHMgQXR0cmlidXRlV2l0aENhY2hlS2V5IHtcbiAgYXhpczogbnVtYmVyO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHYXRoZXIgcmVxdWlyZXMgMiBpbnB1dHMuJyk7XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZUdhdGhlclByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBHYXRoZXJBdHRyaWJ1dGVzKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGluZGljZXNTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuXG4gIGNvbnN0IGlucHV0UmFuayA9IGlucHV0U2hhcGUubGVuZ3RoO1xuICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dFJhbmspO1xuXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgwKTtcbiAgb3V0cHV0U2hhcGUuc3BsaWNlKGF4aXMsIDEsIC4uLmluZGljZXNTaGFwZSk7XG5cbiAgY29uc3QgYXhpc0RpbUxpbWl0ID0gaW5wdXRTaGFwZVtheGlzXTtcbiAgY29uc3QgY29tcG9uZW50cyA9IGlucHV0c1swXS5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuYm9vbCA/IDQgOiAxO1xuICBjb25zdCBvdXRwdXRTaXplID0gTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIGNvbXBvbmVudHMpO1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGF4aXNEaW1MaW1pdCB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBheGlzIH0sXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMsIGlucHV0c1sxXS5kaW1zLCBvdXRwdXRTaGFwZSksXG4gIF07XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IGlucHV0VmFyaWFibGUoJ2RhdGEnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gICAgY29uc3QgaW5kaWNlcyA9IGlucHV0VmFyaWFibGUoJ2lucHV0SW5kaWNlcycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoKTtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuXG4gICAgY29uc3QgY2FsY0RhdGFJbmRpY2VzID0gKHg6IG51bWJlciB8IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgICBjb25zdCBpbmRpY2VzUmFuayA9IGluZGljZXNTaGFwZS5sZW5ndGg7XG4gICAgICBsZXQgY2FsY1N0ciA9IGB2YXIgaW5kaWNlc0luZGljZXMke3h9ICA9ICR7aW5kaWNlcy50eXBlLmluZGljZXN9KDApO2A7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXNSYW5rOyBpKyspIHtcbiAgICAgICAgY2FsY1N0ciArPSBgJHtpbmRpY2VzUmFuayA+IDEgPyBgaW5kaWNlc0luZGljZXMke3h9WyR7aX1dYCA6IGBpbmRpY2VzSW5kaWNlcyR7eH1gfSA9ICR7XG4gICAgICAgICAgb3V0cHV0U2hhcGUubGVuZ3RoID4gMSA/IGBvdXRwdXRJbmRpY2VzJHt4fVt1bmlmb3Jtcy5heGlzICsgJHtpfV1gIDogYG91dHB1dEluZGljZXMke3h9YFxuICAgICAgICB9O2A7XG4gICAgICB9XG4gICAgICBjYWxjU3RyICs9IGBcbiAgICAgICAgICB2YXIgaWR4JHt4fSA9ICR7aW5kaWNlcy5nZXRCeUluZGljZXMoYGluZGljZXNJbmRpY2VzJHt4fWApfTtcbiAgICAgICAgICBpZiAoaWR4JHt4fSA8IDApIHtcbiAgICAgICAgICAgIGlkeCR7eH0gPSBpZHgke3h9ICsgdW5pZm9ybXMuYXhpc0RpbUxpbWl0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGF0YUluZGljZXMke3h9IDogJHtkYXRhLnR5cGUuaW5kaWNlc307XG4gICAgICAgIGA7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBpbnB1dFJhbms7IGkrKykge1xuICAgICAgICBpZiAoaSA9PT0gYXhpcykge1xuICAgICAgICAgIGNhbGNTdHIgKz0gYCR7aW5wdXRSYW5rID4gMSA/IGBkYXRhSW5kaWNlcyR7eH1bJHtpfV1gIDogYGRhdGFJbmRpY2VzJHt4fWB9ID0gdTMyKGlkeCR7eH0pO2A7XG4gICAgICAgICAgaiArPSBpbmRpY2VzUmFuaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxjU3RyICs9IGAke2lucHV0UmFuayA+IDEgPyBgZGF0YUluZGljZXMke3h9WyR7aX1dYCA6IGBkYXRhSW5kaWNlcyR7eH1gfSA9ICR7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZS5sZW5ndGggPiAxID8gYG91dHB1dEluZGljZXMke3h9WyR7an1dYCA6IGBvdXRwdXRJbmRpY2VzJHt4fWBcbiAgICAgICAgICB9O2A7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FsY1N0cjtcbiAgICB9O1xuICAgIGxldCBhc3NpZ25tZW50OiBzdHJpbmc7XG4gICAgaWYgKGlucHV0c1swXS5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuYm9vbCkge1xuICAgICAgY29uc3Qgc2luZ2xlQXNzaWdubWVudCA9IChyZXNTdHI6IHN0cmluZywgeDogbnVtYmVyLCB0eXBlQ2FzdCA9ICcnKSA9PiBgXG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMke3h9ID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKGBvdXRwdXRPZmZzZXQgKyAke3h9dWApfTtcbiAgICAgICAgICAke2NhbGNEYXRhSW5kaWNlcyh4KX07XG4gICAgICAgICAgbGV0IG9mZnNldCR7eH0gPSAke2RhdGEuaW5kaWNlc1RvT2Zmc2V0KGBkYXRhSW5kaWNlcyR7eH1gKX07XG4gICAgICAgICAgbGV0IGluZGV4JHt4fSA9IG9mZnNldCR7eH0gLyA0dTtcbiAgICAgICAgICBsZXQgY29tcG9uZW50JHt4fSA9IG9mZnNldCR7eH0gJSA0dTtcbiAgICAgICAgICAke3Jlc1N0cn1bJHt4fV0gPSAke3R5cGVDYXN0fSgke2RhdGEuZ2V0QnlPZmZzZXQoYGluZGV4JHt4fWApfVtjb21wb25lbnQke3h9XSk7XG4gICAgICAgIGA7XG4gICAgICBhc3NpZ25tZW50ID0gYFxuICAgICAgICBsZXQgb3V0cHV0T2Zmc2V0ID0gZ2xvYmFsX2lkeCAqICR7Y29tcG9uZW50c307XG4gICAgICAgIHZhciB2YWx1ZSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCd2YWx1ZScsIDAsICd1MzInKX1cbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCd2YWx1ZScsIDEsICd1MzInKX1cbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCd2YWx1ZScsIDIsICd1MzInKX1cbiAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCd2YWx1ZScsIDMsICd1MzInKX1cbiAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWUnKX1cbiAgICAgIGA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnbm1lbnQgPSBgXG4gICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICR7Y2FsY0RhdGFJbmRpY2VzKCcnKX07XG4gICAgICBsZXQgdmFsdWUgPSAke2RhdGEuZ2V0QnlJbmRpY2VzKCdkYXRhSW5kaWNlcycpfTtcbiAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlJyl9O1xuICAgICAgYDtcbiAgICB9XG4gICAgcmV0dXJuIGBcbiAgICAgICR7c2hhZGVySGVscGVyXG4gICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ291dHB1dFNpemUnLCAndTMyJylcbiAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnYXhpc0RpbUxpbWl0JywgJ2kzMicpXG4gICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ2F4aXMnLCAndTMyJylcbiAgICAgICAgLmRlY2xhcmVWYXJpYWJsZXMoZGF0YSwgaW5kaWNlcywgb3V0cHV0KX1cbiAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRTaXplJyl9XG4gICAgICAgICR7YXNzaWdubWVudH1cbiAgICAgIH1gO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdHYXRoZXInLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGF0dHJpYnV0ZXMuY2FjaGVLZXksIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnLCAncmFuayddIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUdhdGhlckF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBHYXRoZXJBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGF4aXM6IGF0dHJpYnV0ZXMuYXhpcyBhcyBudW1iZXIgfSk7XG5cbmV4cG9ydCBjb25zdCBnYXRoZXIgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEdhdGhlckF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgY29uc3QgaW5wdXRzID0gY29udGV4dC5pbnB1dHM7XG4gIHZhbGlkYXRlSW5wdXRzKGlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVHYXRoZXJQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcykpO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgdGVuc29yVHlwZVRvV3NnbFZhbHVlVHlwZSxcbiAgVW5pZm9ybXNBcnJheVR5cGUsXG59IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBHYXRoZXJCbG9ja1F1YW50aXplZEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBnYXRoZXJBeGlzOiBudW1iZXI7XG4gIHF1YW50aXplQXhpczogbnVtYmVyO1xuICBibG9ja1NpemU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBHYXRoZXJCbG9ja1F1YW50aXplZEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKGlucHV0cy5sZW5ndGggPCAzIHx8IGlucHV0cy5sZW5ndGggPiA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHYXRoZXJCbG9ja1F1YW50aXplZCByZXF1aXJlcyAzIG9yIDQgaW5wdXRzLicpO1xuICB9XG4gIGNvbnN0IHF1YW50aXplQXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMucXVhbnRpemVBeGlzLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuICBjb25zdCBibG9ja1NpemUgPSBhdHRyaWJ1dGVzLmJsb2NrU2l6ZTtcbiAgY29uc3QgZGF0YSA9IGlucHV0c1swXTtcbiAgY29uc3Qgc2NhbGVzID0gaW5wdXRzWzJdO1xuICBjb25zdCB6ZXJvUG9pbnQgPSBpbnB1dHMubGVuZ3RoID09PSA0ID8gaW5wdXRzWzNdIDogdW5kZWZpbmVkO1xuICBpZiAoXG4gICAgc2NhbGVzLmRpbXMubGVuZ3RoICE9PSBkYXRhLmRpbXMubGVuZ3RoIHx8XG4gICAgIWRhdGEuZGltc1xuICAgICAgLm1hcCgoZCwgaSkgPT4gKGkgPT09IHF1YW50aXplQXhpcyA/IE1hdGguY2VpbChkIC8gYmxvY2tTaXplKSA9PT0gc2NhbGVzLmRpbXNbaV0gOiBkID09PSBzY2FsZXMuZGltc1tpXSkpXG4gICAgICAucmVkdWNlKChhLCBiKSA9PiBhICYmIGIsIHRydWUpXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdTY2FsZXMgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsgYXMgdGhlIGlucHV0IHRlbnNvciBhbmQgdGhlIGRpbXMgc2hvdWxkIG1hdGNoIGV4Y2VwdCBvbiBnYXRoZXJBeGlzLicsXG4gICAgKTtcbiAgfVxuICAvLyBUT0RPIFVuY29tbWVudCB0aGUgZm9sbG93aW5nIGNoZWNrIG9uY2UgdGhlIHRlc3QgY2FzZSBjcmVhdGlvbiBjb2RlIGlzIGZpeGVkIHRvIGNyZWF0ZSBkYXRhIGNvcnJlY3RseSBhbGlnbmVkLlxuICAvLyBjb25zdCBpbmRpY2VzID0gaW5wdXRzWzFdO1xuICAvLyBjb25zdCB2YWxpZEluZGV4ID0gKGluZGV4OiBudW1iZXIpID0+IGluZGV4ID49IDAgJiYgaW5kZXggPCBkYXRhLmRpbXNbYXR0cmlidXRlcy5nYXRoZXJBeGlzXTtcbiAgLy8gaWYgKGluZGljZXMuZGF0YVR5cGUgPT09IERhdGFUeXBlLmludDMyICYmIGluZGljZXMuZ2V0SW50MzJBcnJheSgpLnNvbWUoKHYpID0+ICF2YWxpZEluZGV4KHYpKSB8fFxuICAvLyAgICAgaW5kaWNlcy5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuaW50NjQgJiYgaW5kaWNlcy5nZXRCaWdJbnQ2NEFycmF5KCkuc29tZSgodikgPT4gIXZhbGlkSW5kZXgoTnVtYmVyKHYpKSkpIHtcbiAgLy8gICB0aHJvdyBuZXcgRXJyb3IoJ0luZGljZXMgbXVzdCBiZSB3aXRoaW4gdGhlIGJvdW5kcyBvZiB0aGUgZ2F0aGVyQXhpcy4nKTtcbiAgLy8gfVxuICBpZiAoemVyb1BvaW50KSB7XG4gICAgaWYgKHplcm9Qb2ludC5kYXRhVHlwZSAhPT0gZGF0YS5kYXRhVHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdaZXJvIHBvaW50IG11c3QgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGUgYXMgdGhlIGlucHV0IHRlbnNvci4nKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgemVyb1BvaW50LmRpbXMubGVuZ3RoICE9PSBzY2FsZXMuZGltcy5sZW5ndGggfHxcbiAgICAgICF6ZXJvUG9pbnQuZGltcy5tYXAoKGQsIGkpID0+IGQgPT09IHNjYWxlcy5kaW1zW2ldKS5yZWR1Y2UoKGEsIGIpID0+IGEgJiYgYiwgdHJ1ZSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1plcm8gcG9pbnQgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsgYXMgdGhlIGlucHV0IHRlbnNvciBhbmQgdGhlIGRpbXMgc2hvdWxkIG1hdGNoIGV4Y2VwdCBvbiBxdWFudGl6ZUF4aXMuJyxcbiAgICAgICk7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBjcmVhdGVHYXRoZXJCbG9ja1F1YW50aXplZFByb2dyYW1JbmZvID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogR2F0aGVyQmxvY2tRdWFudGl6ZWRBdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IGluZGljZXNTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuICBjb25zdCBpbnB1dFJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcbiAgY29uc3QgZ2F0aGVyQXhpcyA9IFNoYXBlVXRpbC5ub3JtYWxpemVBeGlzKGF0dHJpYnV0ZXMuZ2F0aGVyQXhpcywgaW5wdXRSYW5rKTtcbiAgY29uc3QgcXVhbnRpemVBeGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5xdWFudGl6ZUF4aXMsIGlucHV0UmFuayk7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgwKTtcbiAgb3V0cHV0U2hhcGUuc3BsaWNlKGdhdGhlckF4aXMsIDEsIC4uLmluZGljZXNTaGFwZSk7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IG91dHB1dFR5cGUgPSBpbnB1dHNbMl0uZGF0YVR5cGU7XG4gIGNvbnN0IGlucHV0VHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcbiAgY29uc3QgaXNTaWduZWQgPSBpbnB1dFR5cGUgPT09IERhdGFUeXBlLmludDQ7IC8vIGlucHV0IGRhdGEgdHlwZSBpcyBlaXRoZXIgaW50NCBvciB1aW50NC5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHF1YW50aXplQXhpcyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBnYXRoZXJBeGlzIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMuYmxvY2tTaXplIH0sXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoLi4uaW5wdXRzLm1hcCgoaW5wdXQsIF8pID0+IGlucHV0LmRpbXMpLCBvdXRwdXRTaGFwZSksXG4gIF07XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IGlucHV0VmFyaWFibGUoJ2RhdGEnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCk7XG4gICAgY29uc3QgaW5kaWNlcyA9IGlucHV0VmFyaWFibGUoJ2lucHV0SW5kaWNlcycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoKTtcbiAgICBjb25zdCBzY2FsZXMgPSBpbnB1dFZhcmlhYmxlKCdzY2FsZXMnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCk7XG4gICAgY29uc3QgemVyb1BvaW50ID1cbiAgICAgIGlucHV0cy5sZW5ndGggPiAzID8gaW5wdXRWYXJpYWJsZSgnemVyb1BvaW50JywgaW5wdXRzWzNdLmRhdGFUeXBlLCBpbnB1dHNbM10uZGltcy5sZW5ndGgpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBvdXRwdXRUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgIGNvbnN0IGlucHV0VmFyaWFibGVzID0gW2RhdGEsIGluZGljZXMsIHNjYWxlc107XG4gICAgaWYgKHplcm9Qb2ludCkge1xuICAgICAgaW5wdXRWYXJpYWJsZXMucHVzaCh6ZXJvUG9pbnQpO1xuICAgIH1cbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdxdWFudGl6ZV9heGlzJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2dhdGhlcl9heGlzJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2Jsb2NrX3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgIF07XG4gICAgcmV0dXJuIGBcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcmlhYmxlcywgb3V0cHV0KX1cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICAgdmFyIGluZGljZXNfaW5kaWNlcyA9ICR7aW5kaWNlcy50eXBlLmluZGljZXN9KDApO1xuICAgICAgICAkeygoKSA9PiB7XG4gICAgICAgICAgaWYgKGluZGljZXNTaGFwZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCAke2luZGljZXNTaGFwZS5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgJ3VuaWZvcm1zLmdhdGhlcl9heGlzICsgaScpfTtcbiAgICAgICAgICAgICR7aW5kaWNlcy5pbmRpY2VzU2V0KCdpbmRpY2VzX2luZGljZXMnLCAnaScsICdpbmRleCcpfTtcbiAgICAgICAgICB9YDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGBpbmRpY2VzX2luZGljZXMgPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICd1bmlmb3Jtcy5nYXRoZXJfYXhpcycpfTtgO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKX07XG4gICAgICAgIHZhciBkYXRhX2luZGljZXMgPSAke2RhdGEudHlwZS5pbmRpY2VzfSgwKTtcbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmdhdGhlcl9heGlzOyBpKyspIHtcbiAgICAgICAgICBsZXQgaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICdpJyl9O1xuICAgICAgICAgICR7ZGF0YS5pbmRpY2VzU2V0KCdkYXRhX2luZGljZXMnLCAnaScsICdpbmRleCcpfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXhfZnJvbV9pbmRpY2VzID0gJHtpbmRpY2VzLmdldEJ5SW5kaWNlcygnaW5kaWNlc19pbmRpY2VzJyl9O1xuICAgICAgICBpZiAoaW5kZXhfZnJvbV9pbmRpY2VzIDwgMCkge1xuICAgICAgICAgIGluZGV4X2Zyb21faW5kaWNlcyArPSAke2lucHV0U2hhcGVbZ2F0aGVyQXhpc119O1xuICAgICAgICB9XG4gICAgICAgICR7ZGF0YS5pbmRpY2VzU2V0KCdkYXRhX2luZGljZXMnLCAndW5pZm9ybXMuZ2F0aGVyX2F4aXMnLCAndTMyKGluZGV4X2Zyb21faW5kaWNlcyknKX07XG4gICAgICAgIGZvciAodmFyIGkgPSB1bmlmb3Jtcy5nYXRoZXJfYXhpcyArIDE7IGkgPCAke291dHB1dFNoYXBlLmxlbmd0aH07IGkrKykge1xuICAgICAgICAgIGxldCBpbmRleCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgYGkgKyAke2luZGljZXNTaGFwZS5sZW5ndGh9IC0gMWApfTtcbiAgICAgICAgICAke2RhdGEuaW5kaWNlc1NldCgnZGF0YV9pbmRpY2VzJywgJ2knLCAnaW5kZXgnKX07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGFfb2Zmc2V0ID0gJHtkYXRhLmluZGljZXNUb09mZnNldCgnZGF0YV9pbmRpY2VzJyl9O1xuICAgICAgICBsZXQgZGF0YV9pbmRleCA9IGRhdGFfb2Zmc2V0ICUgODtcbiAgICAgICAgLy8gQ29udmVydCA0LWJpdCBwYWNrZWQgZGF0YSB0byA4LWJpdCBwYWNrZWQgZGF0YS5cbiAgICAgICAgbGV0IHBhY2tlZF80Yml0X3F1YW50aXplZF9kYXRhID0gJHtkYXRhLmdldEJ5T2Zmc2V0KCdkYXRhX29mZnNldCAvIDgnKX07XG4gICAgICAgIGxldCBwYWNrZWRfOGJpdF9xdWFudGl6ZWRfZGF0YSA9IChwYWNrZWRfNGJpdF9xdWFudGl6ZWRfZGF0YSA+PiAoNCAqIChkYXRhX2luZGV4ICUgMikpKSAmIDB4MGYwZjBmMGY7XG4gICAgICAgIGxldCBxdWFudGl6ZWRfZGF0YV92ZWMgPSAke2lzU2lnbmVkID8gJ3VucGFjazR4STgnIDogJ3VucGFjazR4VTgnfSh1MzIocGFja2VkXzhiaXRfcXVhbnRpemVkX2RhdGEpKTtcbiAgICAgICAgbGV0IHF1YW50aXplZF9kYXRhID0gcXVhbnRpemVkX2RhdGFfdmVjW2RhdGFfaW5kZXggLyAyXTtcbiAgICAgICAgdmFyIHNjYWxlX2luZGljZXMgPSBkYXRhX2luZGljZXM7XG4gICAgICAgIGxldCBxdWFudGl6ZV9heGlzX2luZGV4ID0gJHtzY2FsZXMuaW5kaWNlc0dldCgnZGF0YV9pbmRpY2VzJywgJ3VuaWZvcm1zLnF1YW50aXplX2F4aXMnKX0gLyB1bmlmb3Jtcy5ibG9ja19zaXplO1xuICAgICAgICAke3NjYWxlcy5pbmRpY2VzU2V0KCdzY2FsZV9pbmRpY2VzJywgJ3VuaWZvcm1zLnF1YW50aXplX2F4aXMnLCAncXVhbnRpemVfYXhpc19pbmRleCcpfTtcbiAgICAgICAgdmFyIHNjYWxlID0gJHtzY2FsZXMuZ2V0QnlJbmRpY2VzKCdzY2FsZV9pbmRpY2VzJyl9O1xuICAgICAgICAkeygoKSA9PiB7XG4gICAgICAgICAgaWYgKCF6ZXJvUG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAndmFyIHplcm9fcG9pbnQgPSAwJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5kaWNlcyA9IHNjYWxlX2luZGljZXM7XG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X29mZnNldCA9ICR7emVyb1BvaW50LmluZGljZXNUb09mZnNldCgnemVyb19wb2ludF9pbmRpY2VzJyl9O1xuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRleCA9IHplcm9fcG9pbnRfb2Zmc2V0ICUgODtcbiAgICAgICAgICAgICAgbGV0IHBhY2tlZF80Yml0X3plcm9fcG9pbnRzID0gJHt6ZXJvUG9pbnQuZ2V0QnlPZmZzZXQoJ3plcm9fcG9pbnRfb2Zmc2V0IC8gOCcpfTtcbiAgICAgICAgICAgICAgbGV0IHBhY2tlZF84Yml0X3plcm9fcG9pbnRzID0gKHBhY2tlZF80Yml0X3plcm9fcG9pbnRzID4+ICg0ICogKHplcm9fcG9pbnRfaW5kZXggJSAyKSkpICYgMHgwZjBmMGYwZjtcbiAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmVjID0gJHtpc1NpZ25lZCA/ICd1bnBhY2s0eEk4JyA6ICd1bnBhY2s0eFU4J30odTMyKHBhY2tlZF84Yml0X3plcm9fcG9pbnRzKSk7XG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gemVyb19wb2ludF92ZWNbemVyb19wb2ludF9pbmRleCAvIDJdO2A7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpfTtcbiAgICAgICAgbGV0IGRlcXVhbnRpemVkX2RhdGEgPSAke3RlbnNvclR5cGVUb1dzZ2xWYWx1ZVR5cGUob3V0cHV0VHlwZSl9KHF1YW50aXplZF9kYXRhIC0gemVyb19wb2ludCkgKiBzY2FsZTtcbiAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAnZGVxdWFudGl6ZWRfZGF0YScpfTtcbiAgICB9YDtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnR2F0aGVyQmxvY2tRdWFudGl6ZWQnLFxuICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fTske2lucHV0c1xuICAgICAgICAuZmlsdGVyKChfLCBpKSA9PiBpICE9PSAxKVxuICAgICAgICAubWFwKChpbnB1dCkgPT4gaW5wdXQuZGltcy5qb2luKCdfJykpXG4gICAgICAgIC5qb2luKCc7Jyl9YCxcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBpbnB1dHMubGVuZ3RoIH0sIChfdiwgX2kpID0+ICdyYW5rJyksXG4gICAgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBvdXRwdXRUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogeyB4OiBNYXRoLmNlaWwob3V0cHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBnYXRoZXJCbG9ja1F1YW50aXplZCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogR2F0aGVyQmxvY2tRdWFudGl6ZWRBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGlucHV0cyA9IGNvbnRleHQuaW5wdXRzO1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlR2F0aGVyQmxvY2tRdWFudGl6ZWRQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcykpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlR2F0aGVyQmxvY2tRdWFudGl6ZWRBdHRyaWJ1dGVzID0gKFxuICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbik6IEdhdGhlckJsb2NrUXVhbnRpemVkQXR0cmlidXRlcyA9PlxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xuICAgIGJsb2NrU2l6ZTogYXR0cmlidXRlcy5ibG9ja1NpemUgYXMgbnVtYmVyLFxuICAgIGdhdGhlckF4aXM6IGF0dHJpYnV0ZXMuZ2F0aGVyQXhpcyBhcyBudW1iZXIsXG4gICAgcXVhbnRpemVBeGlzOiBhdHRyaWJ1dGVzLnF1YW50aXplQXhpcyBhcyBudW1iZXIsXG4gIH0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBHYXRoZXJFbGVtZW50c0F0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBheGlzOiBudW1iZXI7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dhdGhlckVsZW1lbnRzIHJlcXVpcmVzIDIgaW5wdXRzLicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dhdGhlckVsZW1lbnRzIHJlcXVpcmVzIHRoYXQgdGhlIGRhdGEgaW5wdXQgYmUgcmFuayA+PSAxLicpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kaW1zLmxlbmd0aCAhPT0gaW5wdXRzWzFdLmRpbXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBHYXRoZXJFbGVtZW50cyByZXF1aXJlcyB0aGF0IHRoZSBkYXRhIGlucHV0IGFuZFxuICAgICAgICAgICAgICAgICAgICAgaW5kaWNlcyBpbnB1dCB0ZW5zb3JzIGJlIG9mIHNhbWUgcmFuay5gKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlR2F0aGVyRWxlbWVudHNQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IEdhdGhlckVsZW1lbnRzQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBpbnB1dE91dHB1dERhdGFUeXBlID0gaW5wdXRzWzBdLmRhdGFUeXBlO1xuICBjb25zdCBpbnB1dFJhbmsgPSBpbnB1dFNoYXBlLmxlbmd0aDtcblxuICBjb25zdCBpbmRpY2VzU2hhcGUgPSBpbnB1dHNbMV0uZGltcztcbiAgY29uc3QgaW5kaWNlc0RhdGFUeXBlID0gaW5wdXRzWzFdLmRhdGFUeXBlO1xuICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dFJhbmspO1xuICBjb25zdCBheGlzRGltTGltaXQgPSBpbnB1dFNoYXBlW2F4aXNdO1xuXG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5kaWNlc1NoYXBlLnNsaWNlKDApO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuXG4gIGNvbnN0IGlucHV0ID0gaW5wdXRWYXJpYWJsZSgnaW5wdXQnLCBpbnB1dE91dHB1dERhdGFUeXBlLCBpbnB1dFJhbmspO1xuICBjb25zdCBpbmRpY2VzID0gaW5wdXRWYXJpYWJsZSgnaW5kaWNlc0lucHV0JywgaW5kaWNlc0RhdGFUeXBlLCBpbmRpY2VzU2hhcGUubGVuZ3RoKTtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0T3V0cHV0RGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5pbnQzMiwgZGF0YTogYXhpc0RpbUxpbWl0IH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF4aXMgfSxcbiAgXTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSwgaW5kaWNlc1NoYXBlLCBvdXRwdXRTaGFwZSkpO1xuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuaycsICdyYW5rJ107XG5cbiAgLy8gaW50NjQgaW5kaWNlcyB3b3VsZCBiZSB0cmVhdGVkIGFzIGxpdHRsZSBlbmRpYW4gaTMyIHdpdGggYXNzdW1wdGlvbiB0aGV5IGZhbGwgaW4gaTMyIGxpbWl0c1xuICAvLyBUaGF0IGFzc3VtcHRpb24gaXMgc2FmZSBhcyBpdCdzIG5vdCBwb3NzaWJsZSB0byBhbGxvY2F0ZSA+MmdiIGJ1ZmZlciBmb3IgaW5wdXQgdGVuc29yXG4gIC8vIElucHV0IGRhdGEgd2lsbCBiZSB0cmVhdGVkIGFzIHUzMiBvciB0d28gdTMyIGZvciA4LWJ5dGUgdGVuc29yc1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgICAgICR7c2hhZGVySGVscGVyXG4gICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ291dHB1dFNpemUnLCAndTMyJylcbiAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnYXhpc0RpbUxpbWl0JywgJ2kzMicpXG4gICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ2F4aXMnLCAndTMyJylcbiAgICAgICAgLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIGluZGljZXMsIG91dHB1dCl9XG4gICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dFNpemUnKX1cblxuICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG5cbiAgICAgIHZhciBpZHggPSAke2luZGljZXMuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKX07XG4gICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICBpZHggPSBpZHggKyB1bmlmb3Jtcy5heGlzRGltTGltaXQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5wdXRJbmRpY2VzID0gJHtpbnB1dC50eXBlLmluZGljZXN9KG91dHB1dEluZGljZXMpO1xuICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dEluZGljZXMnLCAndW5pZm9ybXMuYXhpcycsICd1MzIoaWR4KScpfTtcbiAgICAgIGxldCB2YWx1ZSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dEluZGljZXMnKX07XG5cbiAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JywgJ3ZhbHVlJyl9O1xuICB9YDtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdHYXRoZXJFbGVtZW50cycsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaW5wdXREZXBlbmRlbmNpZXMgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlR2F0aGVyRWxlbWVudHNBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogR2F0aGVyRWxlbWVudHNBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7IGF4aXM6IGF0dHJpYnV0ZXMuYXhpcyBhcyBudW1iZXIgfSk7XG5cbmV4cG9ydCBjb25zdCBnYXRoZXJFbGVtZW50cyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogR2F0aGVyRWxlbWVudHNBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IGlucHV0cyA9IGNvbnRleHQuaW5wdXRzO1xuICB2YWxpZGF0ZUlucHV0cyhpbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlR2F0aGVyRWxlbWVudHNQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcykpO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgR2VtbVV0aWwsIFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcbiAgSW5kaWNlc0hlbHBlcixcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgVW5pZm9ybXNBcnJheVR5cGUsXG59IGZyb20gJy4vY29tbW9uJztcblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10pOiB2b2lkID0+IHtcbiAgaWYgKCFpbnB1dHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGlzIG1pc3NpbmcnKTtcbiAgfVxuICBpZiAoaW5wdXRzLmxlbmd0aCA8IDIgfHwgaW5wdXRzLmxlbmd0aCA+IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFpZCBpbnB1dCBudW1iZXIuJyk7XG4gIH1cblxuICAvLyAnQycgY2FuIGJlIG9mIGRpbWVuc2lvbmFsaXR5IDAsIDEgb3IgMiBvbmx5XG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSAzICYmIGlucHV0c1syXS5kaW1zLmxlbmd0aCA+IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgc2hhcGUgb2YgQycpO1xuICB9XG5cbiAgaWYgKGlucHV0c1swXS5kYXRhVHlwZSAhPT0gaW5wdXRzWzFdLmRhdGFUeXBlIHx8IChpbnB1dHMubGVuZ3RoID09PSAzICYmIGlucHV0c1swXS5kYXRhVHlwZSAhPT0gaW5wdXRzWzJdLmRhdGFUeXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgdHlwZXMgYXJlIG1pc21hdGNoZWQnKTtcbiAgfVxufTtcblxuZXhwb3J0IGludGVyZmFjZSBHZW1tQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHRyYW5zQTogYm9vbGVhbjtcbiAgdHJhbnNCOiBib29sZWFuO1xuICBhbHBoYTogbnVtYmVyO1xuICBiZXRhOiBudW1iZXI7XG59XG5cbmNvbnN0IGNyZWF0ZUdlbW1Qcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogR2VtbUF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGFTaGFwZSA9IGlucHV0c1swXS5kaW1zLnNsaWNlKCk7XG4gIGNvbnN0IGJTaGFwZSA9IGlucHV0c1sxXS5kaW1zLnNsaWNlKCk7XG4gIGNvbnN0IFtNLCBOLCBLXSA9IEdlbW1VdGlsLmdldFNoYXBlT2ZHZW1tUmVzdWx0KFxuICAgIGFTaGFwZSxcbiAgICBhdHRyaWJ1dGVzLnRyYW5zQSxcbiAgICBiU2hhcGUsXG4gICAgYXR0cmlidXRlcy50cmFuc0IsXG4gICAgaW5wdXRzLmxlbmd0aCA9PT0gMyA/IGlucHV0c1syXS5kaW1zIDogdW5kZWZpbmVkLFxuICApO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IFtNLCBOXTtcbiAgaWYgKCFvdXRwdXRTaGFwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBnZW1tIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO1xuICB9XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE4gfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogSyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuZmxvYXQsIGRhdGE6IGF0dHJpYnV0ZXMuYWxwaGEgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBhdHRyaWJ1dGVzLmJldGEgfSxcbiAgXTtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3R5cGUnLCAndHlwZSddO1xuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMykge1xuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1syXS5kaW1zKSk7XG4gICAgaW5wdXREZXBlbmRlbmNpZXMucHVzaCgncmFuaycpO1xuICB9XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgbGV0IGxpbmUgPSAnJztcbiAgICBpZiAoYXR0cmlidXRlcy50cmFuc0EgJiYgYXR0cmlidXRlcy50cmFuc0IpIHtcbiAgICAgIGxpbmUgPSAndmFsdWUgKz0gYVtrICogdW5pZm9ybXMuTSArIG1dICogYltuICogdW5pZm9ybXMuSyArIGtdOyc7XG4gICAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLnRyYW5zQSAmJiAhYXR0cmlidXRlcy50cmFuc0IpIHtcbiAgICAgIGxpbmUgPSAndmFsdWUgKz0gYVtrICogdW5pZm9ybXMuTSArIG1dICogYltrICogdW5pZm9ybXMuTiArIG5dOyc7XG4gICAgfSBlbHNlIGlmICghYXR0cmlidXRlcy50cmFuc0EgJiYgYXR0cmlidXRlcy50cmFuc0IpIHtcbiAgICAgIGxpbmUgPSAndmFsdWUgKz0gYVttICogdW5pZm9ybXMuSyArIGtdICogYltuICogdW5pZm9ybXMuSyArIGtdOyc7XG4gICAgfSBlbHNlIGlmICghYXR0cmlidXRlcy50cmFuc0EgJiYgIWF0dHJpYnV0ZXMudHJhbnNCKSB7XG4gICAgICBsaW5lID0gJ3ZhbHVlICs9IGFbbSAqIHVuaWZvcm1zLksgKyBrXSAqIGJbayAqIHVuaWZvcm1zLk4gKyBuXTsnO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbGN1bGF0ZUFscGhhID0gYXR0cmlidXRlcy5hbHBoYSA9PT0gMSA/ICcnIDogJ3ZhbHVlICo9IHVuaWZvcm1zLmFscGhhOyc7XG4gICAgY29uc3QgYSA9IGlucHV0VmFyaWFibGUoJ2EnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zKTtcbiAgICBjb25zdCBiID0gaW5wdXRWYXJpYWJsZSgnYicsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMpO1xuICAgIGNvbnN0IGRhdGFUeXBlID0gYS50eXBlLnZhbHVlO1xuICAgIGxldCBjOiBJbmRpY2VzSGVscGVyIHwgbnVsbCA9IG51bGw7XG4gICAgY29uc3QgdmFyaWFibGVzID0gW2EsIGJdO1xuICAgIGlmIChpbnB1dHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBjID0gaW5wdXRWYXJpYWJsZSgnYycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoKTtcbiAgICAgIHZhcmlhYmxlcy5wdXNoKGMpO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuICAgIHZhcmlhYmxlcy5wdXNoKG91dHB1dCk7XG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnTScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdOJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ0snLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnYWxwaGEnLCB0eXBlOiAnZjMyJyB9LFxuICAgICAgeyBuYW1lOiAnYmV0YScsIHR5cGU6ICdmMzInIH0sXG4gICAgXTtcbiAgICByZXR1cm4gYFxuICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKC4uLnZhcmlhYmxlcyl9XG5cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cblxuICAgIGxldCBtID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLk47XG4gICAgbGV0IG4gPSBnbG9iYWxfaWR4ICUgdW5pZm9ybXMuTjtcblxuICAgIHZhciB2YWx1ZSA9ICR7ZGF0YVR5cGV9KDApO1xuICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgdW5pZm9ybXMuSzsgaysrKSB7XG4gICAgICAke2xpbmV9XG4gICAgfVxuXG4gICAgJHtjYWxjdWxhdGVBbHBoYX1cbiAgICAkeygoKSA9PiB7XG4gICAgICBpZiAoYyAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBgbGV0IGNPZmZzZXQgPSAke2MuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoJ3ZlYzIobSwgbiknLCBvdXRwdXQpfTsgdmFsdWUgKz0gJHtcbiAgICAgICAgICBkYXRhVHlwZVxuICAgICAgICB9KHVuaWZvcm1zLmJldGEpICogJHtjLmdldEJ5T2Zmc2V0KCdjT2Zmc2V0Jyl9O2A7XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSkoKX1cbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcbiAgfWA7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnR2VtbScsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7YXR0cmlidXRlcy5jYWNoZUtleX1gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VHZW1tQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEdlbW1BdHRyaWJ1dGVzID0+IHtcbiAgY29uc3QgdHJhbnNBID0gYXR0cmlidXRlcy50cmFuc0EgYXMgYm9vbGVhbjtcbiAgY29uc3QgdHJhbnNCID0gYXR0cmlidXRlcy50cmFuc0IgYXMgYm9vbGVhbjtcbiAgY29uc3QgYWxwaGEgPSBhdHRyaWJ1dGVzLmFscGhhIGFzIG51bWJlcjtcbiAgY29uc3QgYmV0YSA9IGF0dHJpYnV0ZXMuYmV0YSBhcyBudW1iZXI7XG4gIHJldHVybiB7XG4gICAgdHJhbnNBLFxuICAgIHRyYW5zQixcbiAgICBhbHBoYSxcbiAgICBiZXRhLFxuICAgIGNhY2hlS2V5OiBgJHthdHRyaWJ1dGVzLnRyYW5zQX07JHthdHRyaWJ1dGVzLnRyYW5zQn07JHthdHRyaWJ1dGVzLmFscGhhID09PSAxfWAsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZ2VtbSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogR2VtbUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlR2VtbVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgR3B1RGF0YVR5cGUsIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBhcHBseUF0dGVudGlvbixcbiAgQXR0ZW50aW9uQXR0cnMsXG4gIEF0dGVudGlvbk1hc2tUeXBlLFxuICBBdHRlbnRpb25QYXJhbWV0ZXJzLFxuICBBdHRlbnRpb25Ra3ZGb3JtYXQsXG59IGZyb20gJy4vYXR0ZW50aW9uJztcbmltcG9ydCB7IGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIFVuaWZvcm1zQXJyYXlUeXBlIH0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IHsgY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8sIFRyYW5zcG9zZUF0dHJpYnV0ZXMgfSBmcm9tICcuL3RyYW5zcG9zZSc7XG5cbmNvbnN0IGdldElucHV0ID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBpOiBudW1iZXIpID0+XG4gIGlucHV0cy5sZW5ndGggPiBpICYmIGlucHV0c1tpXS5kaW1zLmxlbmd0aCA+IDAgPyBpbnB1dHNbaV0gOiB1bmRlZmluZWQ7XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBBdHRlbnRpb25BdHRycyk6IEF0dGVudGlvblBhcmFtZXRlcnMgPT4ge1xuICBjb25zdCBxdWVyeSA9IGlucHV0c1swXTtcbiAgY29uc3Qga2V5ID0gZ2V0SW5wdXQoaW5wdXRzLCAxKTtcbiAgY29uc3QgdmFsdWUgPSBnZXRJbnB1dChpbnB1dHMsIDIpO1xuICBjb25zdCBiaWFzID0gZ2V0SW5wdXQoaW5wdXRzLCAzKTtcbiAgY29uc3Qga2V5UGFkZGluZ01hc2sgPSBnZXRJbnB1dChpbnB1dHMsIDQpO1xuICBjb25zdCBhdHRlbnRpb25CaWFzID0gZ2V0SW5wdXQoaW5wdXRzLCA1KTtcbiAgY29uc3QgcGFzdEtleSA9IGdldElucHV0KGlucHV0cywgNik7XG4gIGNvbnN0IHBhc3RWYWx1ZSA9IGdldElucHV0KGlucHV0cywgNyk7XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIE5vdGF0aW9uczpcbiAgLy8gICAgQjogYmF0Y2hfc2l6ZVxuICAvLyAgICBOOiBudW1faGVhZHNcbiAgLy8gICAgSDogaGVhZF9zaXplIG9mIFEgYW5kIEtcbiAgLy8gICAgSF92OiBoZWFkX3NpemUgb2YgVlxuICAvLyAgICBEOiBoaWRkZW5fc2l6ZSBmb3IgUSBhbmQgSywgd2hlcmUgRCA9IE4gKiBIXG4gIC8vICAgIERfdjogaGlkZGVuX3NpemUgb2YgViwgd2hlcmUgRF92ID0gTiAqIEhfdlxuICAvLyAgICBTOiBxX3NlcXVlbmNlX2xlbmd0aFxuICAvLyAgICBQOiBwYXN0X3NlcXVlbmNlX2xlbmd0aCBvZiBrdiBjYWNoZVxuICAvLyAgICBMOiBrdl9zZXF1ZW5jZV9sZW5ndGhcbiAgLy8gICAgVDogdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gUCArIExcbiAgLy8gICAgTTogbWF4X3NlcXVlbmNlX2xlbmd0aCBvZiBrdiBjYWNoZSB3aGVuIHBhc3QgYW5kIHByZXNlbnQgc2hhcmUgYnVmZmVyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBNdWx0aUhlYWRBdHRlbnRpb24gaW5wdXRzOlxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gIFFfS19WX0JTTkggLSBubyBwYWNraW5nOlxuICAvLyAgICAgcXVlcnkgICAgICAgICAgICAoUSkgICAgICAgOiAoQiwgUywgRClcbiAgLy8gICAgIGtleSAgICAgICAgICAgICAgKEspICAgICAgIDogKEIsIEwsIEQpXG4gIC8vICAgICB2YWx1ZSAgICAgICAgICAgIChWKSAgICAgICA6IChCLCBMLCBEX3YpXG4gIC8vICBRX0tfVl9CU05IX0JOU0hfQk5TSCAtIGNyb3NzIGF0dGVudGlvbiAoa3YgY2FjaGUgaXMgbm90IHVzZWQsIEwgPT0gVCwgRCA9PSBEX3YpOlxuICAvLyAgICAgcXVlcnkgICAgICAgICAgICAoUSkgICAgICAgOiAoQiwgUywgRClcbiAgLy8gICAgIGtleSAgICAgICAgICAgICAgKEspICAgICAgIDogKEIsIE4sIEwsIEgpXG4gIC8vICAgICB2YWx1ZSAgICAgICAgICAgIChWKSAgICAgICA6IChCLCBOLCBMLCBIX3YpXG4gIC8vICBRX0tWX0JTTkhfQlNOMkggLSBwYWNrZWQga3YgKGt2IGNhY2hlIGlzIG5vdCB1c2VkLCBiaWFzIGlzIG5vdCBhbGxvd2VkIGZvciBwYWNrZWQga3YpOlxuICAvLyAgICAgcXVlcnkgICAgICAgICAgICAoUSkgICAgICAgOiAoQiwgUywgRClcbiAgLy8gICAgIGtleSAgICAgICAgICAgICAgKEsvVikgICAgIDogKEIsIEwsIE4sIDIsIEgpXG4gIC8vICAgICB2YWx1ZSAgICAgICAgICAgICAgICAgICAgICA6IE5vbmVcbiAgLy8gIFFLVl9CU04zSCAtIHBhY2tlZCBxa3YgKGt2IGNhY2hlIGlzIG5vdCB1c2VkLCBTID09IEwsIEQgPT0gRF92KTpcbiAgLy8gICAgIHF1ZXJ5ICAgICAgICAgICAgKFEvSy9WKSAgIDogKEIsIFMsIE4sIDMsIEgpXG4gIC8vICAgICBrZXkgICAgICAgICAgICAgICAgICAgICAgICA6IE5vbmVcbiAgLy8gICAgIHZhbHVlICAgICAgICAgICAgICAgICAgICAgIDogTm9uZVxuICAvL1xuICAvLyAgT3RoZXIgaW5wdXRzOlxuICAvLyAgICAgYmlhcyAgICAgICAgICAgICAoUS9LL1YpICAgOiBOb25lIG9yIChEICsgRCArIERfdilcbiAgLy8gICAgIGtleV9wYWRkaW5nX21hc2sgKEsvVikgICAgIDogKEIpIG9yICgzICogQiArIDIpIG9yIChCLCBUKSBvciAoQiwgUywgVClcbiAgLy8gICAgIGF0dGVudGlvbl9iaWFzICAgICAgICAgICAgIDogTm9uZSBvciAoQiwgTiwgUywgVCksICgxLCBOLCBTLCBUKSwgKEIsIDEsIFMsIFQpIG9yICgxLCAxLCBTLCBUKVxuICAvLyAgICAgcGFzdF9rZXkgICAgICAgICAgICAgICAgICAgOiAoQiwgTiwgUCwgSCkgb3IgTm9uZS4gUGFzdCBzdGF0ZSBpcyBvbmx5IGFsbG93ZWQgZm9yIFFfS19WX0JTTkguXG4gIC8vICAgICBwYXN0X3ZhbHVlICAgICAgICAgICAgICAgICA6IChCLCBOLCBQLCBIKSBvciBOb25lLiBQYXN0IHN0YXRlIGlzIG9ubHkgYWxsb3dlZCBmb3IgUV9LX1ZfQlNOSC5cbiAgLy9cbiAgLy8gIE5vdCBTdXBwb3J0ZWQ6XG4gIC8vICAgICBrZXlfcGFkZGluZ19tYXNrLCBwYWNrZWQga3YsIHBhY2tlZCBxa3YsIGFuZCBicm9hZGNhc3QgZm9yIGF0dGVudGlvbl9iaWFzLlxuXG4gIGlmIChxdWVyeS5kaW1zLmxlbmd0aCAhPT0gMyAmJiBxdWVyeS5kaW1zLmxlbmd0aCAhPT0gNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgcXVlcnkgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDUgZGltZW5zaW9ucycpO1xuICB9XG5cbiAgY29uc3QgYmF0Y2hTaXplID0gcXVlcnkuZGltc1swXTtcbiAgY29uc3Qgc2VxdWVuY2VMZW5ndGggPSBxdWVyeS5kaW1zWzFdO1xuICBjb25zdCBoaWRkZW5TaXplID0gcXVlcnkuZGltcy5sZW5ndGggPT09IDMgPyBxdWVyeS5kaW1zWzJdIDogYXR0cmlidXRlcy5udW1IZWFkcyAqIHF1ZXJ5LmRpbXNbNF07XG4gIGxldCBrdlNlcXVlbmNlTGVuZ3RoID0gc2VxdWVuY2VMZW5ndGg7XG5cbiAgbGV0IHBhc3RTZXF1ZW5jZUxlbmd0aCA9IDA7XG4gIGxldCBtYXhTZXF1ZW5jZUxlbmd0aCA9IDA7XG4gIGNvbnN0IGhlYWRTaXplID0gTWF0aC5mbG9vcihoaWRkZW5TaXplIC8gYXR0cmlidXRlcy5udW1IZWFkcyk7XG4gIGlmIChwYXN0S2V5ICYmIHBhc3RWYWx1ZSAmJiBTaGFwZVV0aWwuc2l6ZShwYXN0S2V5LmRpbXMpICYmIFNoYXBlVXRpbC5zaXplKHBhc3RWYWx1ZS5kaW1zKSkge1xuICAgIGlmIChwYXN0S2V5LmRpbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO1xuICAgIH1cbiAgICBpZiAocGFzdEtleS5kaW1zWzBdICE9PSBiYXRjaFNpemUgfHwgcGFzdEtleS5kaW1zWzFdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8IHBhc3RLZXkuZGltc1szXSAhPT0gaGVhZFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpJyk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIHBhc3RWYWx1ZS5kaW1zWzBdICE9PSBiYXRjaFNpemUgfHxcbiAgICAgIHBhc3RWYWx1ZS5kaW1zWzFdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8XG4gICAgICBwYXN0VmFsdWUuZGltc1szXSAhPT0gaGVhZFNpemVcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X3ZhbHVlXCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywgcGFzdF9zZXF1ZW5jZV9sZW5ndGgsIGhlYWRfc2l6ZSknKTtcbiAgICB9XG4gICAgaWYgKHBhc3RLZXkuZGltc1syXSAhPT0gcGFzdFZhbHVlLmRpbXNbMl0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGFuZCBcInBhc3RfdmFsdWVcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDIgKHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKScpO1xuICAgIH1cbiAgICBpZiAocGFzdFZhbHVlLmRpbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF92YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7XG4gICAgfVxuICAgIHBhc3RTZXF1ZW5jZUxlbmd0aCA9IHBhc3RLZXkuZGltc1syXTtcbiAgICBtYXhTZXF1ZW5jZUxlbmd0aCA9IHBhc3RLZXkuZGltc1syXTtcbiAgfSBlbHNlIGlmICgocGFzdEtleSAmJiBTaGFwZVV0aWwuc2l6ZShwYXN0S2V5LmRpbXMpKSB8fCAocGFzdFZhbHVlICYmIFNoYXBlVXRpbC5zaXplKHBhc3RWYWx1ZS5kaW1zKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgYmUgYm90aCBwcmVzZW50IG9yIGJvdGggYWJzZW50Jyk7XG4gIH1cblxuICBsZXQgcWt2Rm9ybWF0OiBBdHRlbnRpb25Ra3ZGb3JtYXQ7XG4gIGlmIChrZXkgJiYgU2hhcGVVdGlsLnNpemUoa2V5LmRpbXMpID4gMCkge1xuICAgIGlmIChxdWVyeS5kaW1zLmxlbmd0aCAhPT0gMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZ2l2ZW4nKTtcbiAgICB9XG4gICAgaWYgKGtleS5kaW1zLmxlbmd0aCA8IDMgfHwga2V5LmRpbXMubGVuZ3RoID4gNSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMywgNCwgb3IgNSBkaW1lbnNpb25zJyk7XG4gICAgfVxuICAgIGlmIChxdWVyeS5kaW1zWzBdICE9PSBrZXkuZGltc1swXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwia2V5XCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAwIChiYXRjaCBzaXplKScpO1xuICAgIH1cblxuICAgIGlmIChrZXkuZGltcy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGlmIChrZXkuZGltc1syXSAhPT0gcXVlcnkuZGltc1syXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJrZXlcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDIgKGhpZGRlbl9zaXplKScpO1xuICAgICAgfVxuICAgICAgcWt2Rm9ybWF0ID0gQXR0ZW50aW9uUWt2Rm9ybWF0LnFrdkJTTkg7XG4gICAgICBrdlNlcXVlbmNlTGVuZ3RoID0ga2V5LmRpbXNbMV07XG4gICAgfSBlbHNlIGlmIChrZXkuZGltcy5sZW5ndGggPT09IDUpIHtcbiAgICAgIGlmIChrZXkuZGltc1syXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fCBrZXkuZGltc1szXSAhPT0gMiB8fCBrZXkuZGltc1s0XSAhPT0gaGVhZFNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJrZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDIsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwidmFsdWVcIiBiZSBub25lIHdoZW4gXCJrZXlcIiBoYXMgcGFja2VkIGt2IGZvcm1hdC4nKTtcbiAgICAgIH1cbiAgICAgIHFrdkZvcm1hdCA9IEF0dGVudGlvblFrdkZvcm1hdC5xS3ZCU05IeEJTTjJIO1xuICAgICAga3ZTZXF1ZW5jZUxlbmd0aCA9IGtleS5kaW1zWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBrZXlfZGltcy5zaXplKCkgPT0gNCAoY3Jvc3MtYXR0ZW50aW9uIHdpdGggcGFzdF9rZXkpXG4gICAgICBpZiAoa2V5LmRpbXNbMV0gIT09IGF0dHJpYnV0ZXMubnVtSGVhZHMgfHwga2V5LmRpbXNbM10gIT09IGhlYWRTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0IFwia2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywga3Zfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpIGZvciBwYXN0X2tleScpO1xuICAgICAgfVxuXG4gICAgICBxa3ZGb3JtYXQgPSBBdHRlbnRpb25Ra3ZGb3JtYXQudW5rbm93bjsgLy8gUV9LX1ZfQlNOSF9CTlNIX0JOU0hcbiAgICAgIGt2U2VxdWVuY2VMZW5ndGggPSBrZXkuZGltc1syXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gcGFja2VkIFFLVlxuICAgIGlmIChxdWVyeS5kaW1zLmxlbmd0aCAhPT0gNSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA1IGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZW1wdHknKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmRpbXNbMl0gIT09IGF0dHJpYnV0ZXMubnVtSGVhZHMgfHwgcXVlcnkuZGltc1szXSAhPT0gMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJxdWVyeVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMywgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7XG4gICAgfVxuXG4gICAgcWt2Rm9ybWF0ID0gQXR0ZW50aW9uUWt2Rm9ybWF0LnFrdkJTTjNIO1xuICB9XG5cbiAgaWYgKGJpYXMgJiYgU2hhcGVVdGlsLnNpemUoYmlhcy5kaW1zKSA+IDApIHtcbiAgICBpZiAoYmlhcy5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKGtleSkge1xuICAgICAgaWYgKGtleS5kaW1zLmxlbmd0aCA9PT0gNSAmJiBrZXkuZGltc1szXSA9PT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpYXMgaXMgbm90IGFsbG93ZWQgZm9yIHBhY2tlZCBrdi4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCB0b3RhbFNlcXVlbmNlTGVuZ3RoID0gcGFzdFNlcXVlbmNlTGVuZ3RoICsga3ZTZXF1ZW5jZUxlbmd0aDtcblxuICBsZXQgbWFza1R5cGU6IEF0dGVudGlvbk1hc2tUeXBlID0gQXR0ZW50aW9uTWFza1R5cGUubm9uZTtcbiAgaWYgKGtleVBhZGRpbmdNYXNrICYmIFNoYXBlVXRpbC5zaXplKGtleVBhZGRpbmdNYXNrLmRpbXMpID4gMCkge1xuICAgIG1hc2tUeXBlID0gQXR0ZW50aW9uTWFza1R5cGUubWFza1Vua25vd247XG4gICAgY29uc3QgbWFza0RpbXMgPSBrZXlQYWRkaW5nTWFzay5kaW1zO1xuICAgIGlmIChtYXNrRGltcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChtYXNrRGltc1swXSA9PT0gYmF0Y2hTaXplKSB7XG4gICAgICAgIG1hc2tUeXBlID0gQXR0ZW50aW9uTWFza1R5cGUubWFzazFkS2V5U2VxTGVuO1xuICAgICAgfSBlbHNlIGlmIChtYXNrRGltc1swXSA9PT0gMyAqIGJhdGNoU2l6ZSArIDIpIHtcbiAgICAgICAgbWFza1R5cGUgPSBBdHRlbnRpb25NYXNrVHlwZS5tYXNrMURLZXlTZXFMZW5TdGFydDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1hc2tEaW1zLmxlbmd0aCA9PT0gMiAmJiBtYXNrRGltc1swXSA9PT0gYmF0Y2hTaXplICYmIG1hc2tEaW1zWzFdID09PSB0b3RhbFNlcXVlbmNlTGVuZ3RoKSB7XG4gICAgICBtYXNrVHlwZSA9IEF0dGVudGlvbk1hc2tUeXBlLm1hc2syZEtleVBhZGRpbmc7XG4gICAgfVxuICAgIGlmIChtYXNrVHlwZSA9PT0gQXR0ZW50aW9uTWFza1R5cGUubWFza1Vua25vd24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlfcGFkZGluZ19tYXNrXCIgc2hhcGUgc2hhbGwgYmUgKGJhdGNoX3NpemUpIG9yIChiYXRjaF9zaXplLCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGgpJyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTWFzayBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cblxuICBsZXQgcGFzc1Bhc3RJbkt2ID0gZmFsc2U7XG4gIGxldCB2SGlkZGVuU2l6ZSA9IGhpZGRlblNpemU7XG4gIGlmICh2YWx1ZSAmJiBTaGFwZVV0aWwuc2l6ZSh2YWx1ZS5kaW1zKSA+IDApIHtcbiAgICBpZiAodmFsdWUuZGltcy5sZW5ndGggIT09IDMgJiYgdmFsdWUuZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJ2YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA0IGRpbWVuc2lvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAocXVlcnkuZGltc1swXSAhPT0gdmFsdWUuZGltc1swXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoX3NpemUpJyk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLmRpbXMubGVuZ3RoID09PSAzKSB7XG4gICAgICBpZiAoa3ZTZXF1ZW5jZUxlbmd0aCAhPT0gdmFsdWUuZGltc1sxXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAxIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7XG4gICAgICB9XG4gICAgICB2SGlkZGVuU2l6ZSA9IHZhbHVlLmRpbXNbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFFfS19WX0JTTkhfQk5TSF9CTlNIXG4gICAgICBpZiAoa3ZTZXF1ZW5jZUxlbmd0aCAhPT0gdmFsdWUuZGltc1syXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAyIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7XG4gICAgICB9XG4gICAgICB2SGlkZGVuU2l6ZSA9IHZhbHVlLmRpbXNbMV0gKiB2YWx1ZS5kaW1zWzNdO1xuICAgICAgcGFzc1Bhc3RJbkt2ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBicm9hZGNhc3RSZXNQb3NCaWFzID0gZmFsc2U7XG5cbiAgaWYgKGtleVBhZGRpbmdNYXNrICYmIFNoYXBlVXRpbC5zaXplKGtleVBhZGRpbmdNYXNrLmRpbXMpID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignS2V5IHBhZGRpbmcgbWFzayBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cblxuICBpZiAoYXR0ZW50aW9uQmlhcyAmJiBTaGFwZVV0aWwuc2l6ZShhdHRlbnRpb25CaWFzLmRpbXMpID4gMCkge1xuICAgIGlmIChhdHRlbnRpb25CaWFzLmRpbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYXR0ZW50aW9uX2JpYXNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHN1cHBvcnQgYnJvYWRjYXN0aW5nIHRoZSBmaXJzdCBhbmQgc2Vjb25kIGRpbWVuc2lvbnMgb2YgYXR0ZW50aW9uX2JpYXMuXG4gICAgaWYgKFxuICAgICAgYXR0ZW50aW9uQmlhcy5kaW1zWzBdICE9PSBiYXRjaFNpemUgfHxcbiAgICAgIGF0dGVudGlvbkJpYXMuZGltc1sxXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fFxuICAgICAgYXR0ZW50aW9uQmlhcy5kaW1zWzJdICE9PSBzZXF1ZW5jZUxlbmd0aCB8fFxuICAgICAgYXR0ZW50aW9uQmlhcy5kaW1zWzNdICE9PSB0b3RhbFNlcXVlbmNlTGVuZ3RoXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImF0dGVudGlvbl9iaWFzXCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywgc2VxdWVuY2VfbGVuZ3RoLCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGgpJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiYXRjaFNpemUsXG4gICAgc2VxdWVuY2VMZW5ndGgsXG4gICAgcGFzdFNlcXVlbmNlTGVuZ3RoLFxuICAgIGt2U2VxdWVuY2VMZW5ndGgsXG4gICAgdG90YWxTZXF1ZW5jZUxlbmd0aCxcbiAgICBtYXhTZXF1ZW5jZUxlbmd0aCxcbiAgICBpbnB1dEhpZGRlblNpemU6IDAsXG4gICAgaGlkZGVuU2l6ZSxcbiAgICB2SGlkZGVuU2l6ZSxcbiAgICBoZWFkU2l6ZSxcbiAgICB2SGVhZFNpemU6IE1hdGguZmxvb3IodkhpZGRlblNpemUgLyBhdHRyaWJ1dGVzLm51bUhlYWRzKSxcbiAgICBudW1IZWFkczogYXR0cmlidXRlcy5udW1IZWFkcyxcbiAgICBpc1VuaWRpcmVjdGlvbmFsOiBmYWxzZSxcbiAgICBwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiBmYWxzZSxcbiAgICBtYXNrRmlsdGVyVmFsdWU6IGF0dHJpYnV0ZXMubWFza0ZpbHRlclZhbHVlLFxuICAgIG1hc2tUeXBlLFxuICAgIHNjYWxlOiBhdHRyaWJ1dGVzLnNjYWxlLFxuICAgIGJyb2FkY2FzdFJlc1Bvc0JpYXMsXG4gICAgcGFzc1Bhc3RJbkt2LFxuICAgIHFrdkZvcm1hdCxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZU11bHRpSGVhZEF0dGVudGlvbkF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogQXR0ZW50aW9uQXR0cnMpOiBBdHRlbnRpb25BdHRycyA9PlxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyAuLi5hdHRyaWJ1dGVzIH0pO1xuXG5jb25zdCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGU6IFRyYW5zcG9zZUF0dHJpYnV0ZXMgPSBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBwZXJtOiBbMCwgMiwgMSwgM10gfSk7XG5cbmNvbnN0IGFkZEJpYXNUcmFuc3Bvc2UgPSAoXG4gIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LFxuICBxa3Y6IFRlbnNvclZpZXcsXG4gIGJpYXM6IFRlbnNvclZpZXcsXG4gIGJhdGNoU2l6ZTogbnVtYmVyLFxuICBzZXF1ZW5jZUxlbmd0aDogbnVtYmVyLFxuICBoaWRkZW5TaXplOiBudW1iZXIsXG4gIGJpYXNPZmZzZXQ6IG51bWJlcixcbikgPT4ge1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IFtiYXRjaFNpemUsIHNlcXVlbmNlTGVuZ3RoLCBoaWRkZW5TaXplXTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGJpYXNPZmZzZXQgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogaGlkZGVuU2l6ZSB9LFxuICBdO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdxa3Zfd2l0aF9iaWFzJywgcWt2LmRhdGFUeXBlLCBvdXRwdXRTaGFwZSk7XG4gICAgY29uc3QgcWt2SW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdxa3YnLCBxa3YuZGF0YVR5cGUsIG91dHB1dFNoYXBlKTtcbiAgICBjb25zdCBiaWFzSW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdiaWFzJywgYmlhcy5kYXRhVHlwZSwgb3V0cHV0U2hhcGUpO1xuXG4gICAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnYmlhc19vZmZzZXQnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnaGlkZGVuX3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgIF07XG4gICAgcmV0dXJuIGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyhxa3ZJbnB1dCwgYmlhc0lucHV0LCBvdXRwdXQpfVxuICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICAgIGxldCBiaWFzX29mZnNldF9pZHggPSAoZ2xvYmFsX2lkeCAlIHVuaWZvcm1zLmhpZGRlbl9zaXplKSArIHVuaWZvcm1zLmJpYXNfb2Zmc2V0O1xuXG4gICAgcWt2X3dpdGhfYmlhc1tnbG9iYWxfaWR4XSA9IHFrdltnbG9iYWxfaWR4XSArIGJpYXNbYmlhc19vZmZzZXRfaWR4XTtcbiAgfWA7XG4gIH07XG5cbiAgcmV0dXJuIGNvbnRleHQuY29tcHV0ZShcbiAgICB7XG4gICAgICBuYW1lOiAnTXVsdGlIZWFkQXR0ZW50aW9uQWRkQmlhcycsXG4gICAgICBzaGFkZXJDYWNoZTogeyBpbnB1dERlcGVuZGVuY2llczogWyd0eXBlJywgJ3R5cGUnXSB9LFxuICAgICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBxa3YuZGF0YVR5cGUsIGdwdURhdGFUeXBlOiBHcHVEYXRhVHlwZS5kZWZhdWx0IH1dLFxuICAgICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICAgIH0pLFxuICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIH0sXG4gICAgeyBpbnB1dHM6IFtxa3YsIGJpYXNdLCBvdXRwdXRzOiBbLTFdIH0sXG4gIClbMF07XG59O1xuXG5leHBvcnQgY29uc3QgbWF5YmVUcmFuc3Bvc2VUb0JOU0hBbmRBZGRCaWFzID0gKFxuICBjb250ZXh0OiBDb21wdXRlQ29udGV4dCxcbiAgYmF0Y2hTaXplOiBudW1iZXIsXG4gIG51bUhlYWRzOiBudW1iZXIsXG4gIHNlcXVlbmNlTGVuZ3RoOiBudW1iZXIsXG4gIGhlYWRTaXplOiBudW1iZXIsXG4gIGlucHV0OiBUZW5zb3JWaWV3LFxuICBiaWFzPzogVGVuc29yVmlldyxcbiAgYmlhc09mZnNldD86IG51bWJlcixcbikgPT4ge1xuICAvLyBjb25zdCBuZXdEaW1zID0gW107XG5cbiAgbGV0IHJlc2hhcGVkSW5wdXQgPSBpbnB1dDtcbiAgaWYgKCEoYmlhcyAmJiBTaGFwZVV0aWwuc2l6ZShiaWFzLmRpbXMpID4gMCkpIHtcbiAgICBpZiAoaW5wdXQuZGltcy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHJlc2hhcGVkSW5wdXQgPSBpbnB1dC5yZXNoYXBlKFtiYXRjaFNpemUsIHNlcXVlbmNlTGVuZ3RoLCBudW1IZWFkcywgaGVhZFNpemVdKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQuY29tcHV0ZShjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbyhyZXNoYXBlZElucHV0LCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUucGVybSksIHtcbiAgICAgIGlucHV0czogW3Jlc2hhcGVkSW5wdXRdLFxuICAgICAgb3V0cHV0czogWy0xXSxcbiAgICB9KVswXTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoc2VxdWVuY2VMZW5ndGggPT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWRkQmlhc1Jlc2hhcGUgaXMgbm90IGltcGxlbWVudGVkLiBQbGVhc2UgZXhwb3J0IHlvdXIgbW9kZWwgd2l0aCBwYWNrZWQgUUtWIG9yIEtWJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc2hhcGVkSW5wdXQgPSBhZGRCaWFzVHJhbnNwb3NlKFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgYmlhcyxcbiAgICAgICAgYmF0Y2hTaXplLFxuICAgICAgICBzZXF1ZW5jZUxlbmd0aCxcbiAgICAgICAgbnVtSGVhZHMgKiBoZWFkU2l6ZSxcbiAgICAgICAgYmlhc09mZnNldCEsXG4gICAgICApO1xuICAgICAgcmVzaGFwZWRJbnB1dCA9IHJlc2hhcGVkSW5wdXQucmVzaGFwZShbYmF0Y2hTaXplLCBzZXF1ZW5jZUxlbmd0aCwgbnVtSGVhZHMsIGhlYWRTaXplXSk7XG4gICAgICByZXR1cm4gY29udGV4dC5jb21wdXRlKGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKHJlc2hhcGVkSW5wdXQsIHdlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZS5wZXJtKSwge1xuICAgICAgICBpbnB1dHM6IFtyZXNoYXBlZElucHV0XSxcbiAgICAgICAgb3V0cHV0czogWy0xXSxcbiAgICAgIH0pWzBdO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IG11bHRpSGVhZEF0dGVudGlvbiA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogQXR0ZW50aW9uQXR0cnMpOiB2b2lkID0+IHtcbiAgY29uc3QgcGFyYW1zID0gdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBjb25zdCBxdWVyeSA9IGNvbnRleHQuaW5wdXRzWzBdO1xuICBjb25zdCBrZXkgPSBnZXRJbnB1dChjb250ZXh0LmlucHV0cywgMSk7XG4gIGNvbnN0IHZhbHVlID0gZ2V0SW5wdXQoY29udGV4dC5pbnB1dHMsIDIpO1xuICBjb25zdCBiaWFzID0gZ2V0SW5wdXQoY29udGV4dC5pbnB1dHMsIDMpO1xuICBjb25zdCBrZXlQYWRkaW5nTWFzayA9IGdldElucHV0KGNvbnRleHQuaW5wdXRzLCA0KTtcbiAgY29uc3QgYXR0ZW50aW9uQmlhcyA9IGdldElucHV0KGNvbnRleHQuaW5wdXRzLCA1KTtcbiAgY29uc3QgcGFzdEtleSA9IGdldElucHV0KGNvbnRleHQuaW5wdXRzLCA2KTtcbiAgY29uc3QgcGFzdFZhbHVlID0gZ2V0SW5wdXQoY29udGV4dC5pbnB1dHMsIDcpO1xuICBpZiAocXVlcnkuZGltcy5sZW5ndGggPT09IDUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhY2tlZCBRS1YgaXMgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICBpZiAoa2V5Py5kaW1zLmxlbmd0aCA9PT0gNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFja2VkIEtWIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgLy8gYXBwbHlBdHRlbnRpb24gZXhwZWN0cyBCTlNIIGlucHV0c1xuICBjb25zdCBrdkJOU0ggPSBrZXkgJiYgdmFsdWUgJiYga2V5LmRpbXMubGVuZ3RoID09PSA0ICYmIHZhbHVlLmRpbXMubGVuZ3RoID09PSA0O1xuXG4gIGNvbnN0IFEgPSBtYXliZVRyYW5zcG9zZVRvQk5TSEFuZEFkZEJpYXMoXG4gICAgY29udGV4dCxcbiAgICBwYXJhbXMuYmF0Y2hTaXplLFxuICAgIHBhcmFtcy5udW1IZWFkcyxcbiAgICBwYXJhbXMuc2VxdWVuY2VMZW5ndGgsXG4gICAgcGFyYW1zLmhlYWRTaXplLFxuICAgIHF1ZXJ5LFxuICAgIGJpYXMsXG4gICAgMCxcbiAgKTtcblxuICBpZiAoa3ZCTlNIKSB7XG4gICAgcmV0dXJuIGFwcGx5QXR0ZW50aW9uKFxuICAgICAgY29udGV4dCxcbiAgICAgIFEsXG4gICAgICBrZXksXG4gICAgICB2YWx1ZSxcbiAgICAgIGtleVBhZGRpbmdNYXNrLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgcGFzdEtleSxcbiAgICAgIHBhc3RWYWx1ZSxcbiAgICAgIGF0dGVudGlvbkJpYXMsXG4gICAgICBwYXJhbXMsXG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICk7XG4gIH1cbiAgaWYgKCFrZXkgfHwgIXZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdrZXkgYW5kIHZhbHVlIG11c3QgYmUgcHJvdmlkZWQnKTtcbiAgfVxuICBjb25zdCBLID0gbWF5YmVUcmFuc3Bvc2VUb0JOU0hBbmRBZGRCaWFzKFxuICAgIGNvbnRleHQsXG4gICAgcGFyYW1zLmJhdGNoU2l6ZSxcbiAgICBwYXJhbXMubnVtSGVhZHMsXG4gICAgcGFyYW1zLmt2U2VxdWVuY2VMZW5ndGgsXG4gICAgcGFyYW1zLmhlYWRTaXplLFxuICAgIGtleSxcbiAgICBiaWFzLFxuICAgIHBhcmFtcy5oaWRkZW5TaXplLFxuICApO1xuXG4gIGNvbnN0IFYgPSBtYXliZVRyYW5zcG9zZVRvQk5TSEFuZEFkZEJpYXMoXG4gICAgY29udGV4dCxcbiAgICBwYXJhbXMuYmF0Y2hTaXplLFxuICAgIHBhcmFtcy5udW1IZWFkcyxcbiAgICBwYXJhbXMua3ZTZXF1ZW5jZUxlbmd0aCxcbiAgICBwYXJhbXMudkhlYWRTaXplLFxuICAgIHZhbHVlLFxuICAgIGJpYXMsXG4gICAgMiAqIHBhcmFtcy5oaWRkZW5TaXplLFxuICApO1xuXG4gIGFwcGx5QXR0ZW50aW9uKGNvbnRleHQsIFEsIEssIFYsIGtleVBhZGRpbmdNYXNrLCB1bmRlZmluZWQsIHBhc3RLZXksIHBhc3RWYWx1ZSwgYXR0ZW50aW9uQmlhcywgcGFyYW1zLCBhdHRyaWJ1dGVzKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcywgaW5wdXRWYXJpYWJsZSwgb3V0cHV0VmFyaWFibGUsIFNoYWRlckhlbHBlciB9IGZyb20gJy4vY29tbW9uJztcblxuY29uc3QgZ2V0UmVwZWF0cyA9IChyZXBlYXRzVGVuc29yVmlldzogVGVuc29yVmlldyk6IHJlYWRvbmx5IG51bWJlcltdID0+XG4gIEFycmF5LmZyb20ocmVwZWF0c1RlbnNvclZpZXcuZ2V0QmlnSW50NjRBcnJheSgpLCBOdW1iZXIpO1xuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaWxlIHJlcXVpcmVzIDIgaW5wdXRzLicpO1xuICB9XG5cbiAgaWYgKFxuICAgIGlucHV0c1swXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuZmxvYXQgJiZcbiAgICBpbnB1dHNbMF0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmZsb2F0MTYgJiZcbiAgICBpbnB1dHNbMF0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmludDMyICYmXG4gICAgaW5wdXRzWzBdLmRhdGFUeXBlICE9PSBEYXRhVHlwZS51aW50MzJcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaWxlIG9ubHkgc3VwcG9ydCBmbG9hdCwgZmxvYXQxNiwgaW50MzIsIGFuZCB1aW50MzIgZGF0YSB0eXBlcycpO1xuICB9XG5cbiAgaWYgKGlucHV0c1sxXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuaW50NjQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBiZSBvZiBpbnQ2NCBkYXRhIHR5cGUnKTtcbiAgfVxuXG4gIGlmIChpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBiZSAxLUQnKTtcbiAgfVxuXG4gIGNvbnN0IHJlcGVhdHM6IHJlYWRvbmx5IG51bWJlcltdID0gZ2V0UmVwZWF0cyhpbnB1dHNbMV0pO1xuXG4gIGlmIChyZXBlYXRzLmxlbmd0aCAhPT0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgaGF2ZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cyBhcyByYW5rIG9mIGlucHV0IGRhdGEgdGVuc29yJyk7XG4gIH1cbn07XG5cbmNvbnN0IGdldE91dHB1dFNoYXBlID0gKGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLCByZXBlYXRzOiByZWFkb25seSBudW1iZXJbXSk6IHJlYWRvbmx5IG51bWJlcltdID0+IHtcbiAgY29uc3Qgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgb3V0cHV0U2hhcGUucHVzaChpbnB1dFNoYXBlW2ldICogcmVwZWF0c1tpXSk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0U2hhcGU7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlVGlsZVByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBzaGFwZT86IG51bWJlcltdKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IHJlcGVhdHM6IHJlYWRvbmx5IG51bWJlcltdID0gc2hhcGUgPT0gbnVsbCA/IGdldFJlcGVhdHMoaW5wdXRzWzFdKSA6IHNoYXBlO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGdldE91dHB1dFNoYXBlKGlucHV0U2hhcGUsIHJlcGVhdHMpO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpO1xuXG4gIGNvbnN0IGRhdGFUeXBlID0gaW5wdXRzWzBdLmRhdGFUeXBlO1xuICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgZGF0YVR5cGUsIGlucHV0U2hhcGUubGVuZ3RoKTtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGRhdGFUeXBlLCBvdXRwdXRTaGFwZS5sZW5ndGgpO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4gYFxuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9ICR7aW5wdXQuaW5kaWNlcyguLi5pbnB1dFNoYXBlKX07XG4gICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ291dHB1dF9zaXplJywgJ3UzMicpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG4gICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLm91dHB1dF9zaXplJyl9XG4gICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke2lucHV0U2hhcGUubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIGxldCBpbnB1dF9kaW1faSA9ICR7aW5wdXQuaW5kaWNlc0dldCgndW5pZm9ybXMuaW5wdXRfc2hhcGUnLCAnaScpfTtcbiAgICAgICAgbGV0IGlucHV0X2RpbV92YWx1ZSA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgJ2knKX0gICUgaW5wdXRfZGltX2k7XG5cbiAgICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgJ2knLCAnaW5wdXRfZGltX3ZhbHVlJyl9XG4gICAgICB9XG4gICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsIGlucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpKX1cbiAgICB9YDtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdUaWxlJyxcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHtyZXBlYXRzfWAsIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXSB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtczogW1xuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMF0uZGltcywgb3V0cHV0U2hhcGUpLFxuICAgICAgXSxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgdGlsZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVUaWxlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMpLCB7IGlucHV0czogWzBdIH0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSwgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGFwcGx5QXR0ZW50aW9uLFxuICBBdHRlbnRpb25BdHRycyxcbiAgQXR0ZW50aW9uTWFza1R5cGUsXG4gIEF0dGVudGlvblBhcmFtZXRlcnMsXG4gIEF0dGVudGlvblFrdkZvcm1hdCxcbn0gZnJvbSAnLi9hdHRlbnRpb24nO1xuaW1wb3J0IHsgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsIGlucHV0VmFyaWFibGUsIG91dHB1dFZhcmlhYmxlLCBTaGFkZXJIZWxwZXIsIFVuaWZvcm1zQXJyYXlUeXBlIH0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IHsgbWF5YmVUcmFuc3Bvc2VUb0JOU0hBbmRBZGRCaWFzIH0gZnJvbSAnLi9tdWx0aWhlYWQtYXR0ZW50aW9uJztcbmltcG9ydCB7IGNyZWF0ZVRpbGVQcm9ncmFtSW5mbyB9IGZyb20gJy4vdGlsZSc7XG5pbXBvcnQgeyBjcmVhdGVUcmFuc3Bvc2VQcm9ncmFtSW5mbywgVHJhbnNwb3NlQXR0cmlidXRlcyB9IGZyb20gJy4vdHJhbnNwb3NlJztcblxuZXhwb3J0IGNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBBdHRlbnRpb25BdHRycyk6IEF0dGVudGlvblBhcmFtZXRlcnMgPT4ge1xuICBjb25zdCBxdWVyeSA9IGlucHV0c1swXTtcbiAgY29uc3Qga2V5ID0gaW5wdXRzWzFdO1xuICBjb25zdCB2YWx1ZSA9IGlucHV0c1syXTtcbiAgY29uc3QgcGFzdEtleSA9IGlucHV0c1szXTtcbiAgY29uc3QgcGFzdFZhbHVlID0gaW5wdXRzWzRdO1xuXG4gIC8vIEFiYnJldmlhdGlvbiBhbmQgTWVhbmluZ3M6XG4gIC8vICAgQjogICAgYmF0Y2hfc2l6ZVxuICAvLyAgIFM6ICAgIHNlcXVlbmNlX2xlbmd0aCAoaW5wdXQgc2VxdWVuY2UgbGVuZ3RoIG9mIHF1ZXJ5KVxuICAvLyAgIFA6ICAgIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoIChwYXN0IHNlcXVlbmNlIGxlbmd0aCBvZiBrZXkgb3IgdmFsdWUpXG4gIC8vICAgTDogICAga3Zfc2VxdWVuY2VfbGVuZ3RoIChpbnB1dCBzZXF1ZW5jZSBsZW5ndGggb2Yga2V5IG9yIHZhbHVlKVxuICAvLyAgIE06ICAgIG1heF9zZXF1ZW5jZV9sZW5ndGhcbiAgLy8gICBUOiAgICB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSBwYXN0X3NlcXVlbmNlX2xlbmd0aCArIGt2X3NlcXVlbmNlX2xlbmd0aFxuICAvLyAgIE46ICAgIG51bV9oZWFkc1xuICAvLyAgIEg6ICAgIGhlYWQgc2l6ZSBmb3IgUSBhbmQgSywgYWthIHFfaGVhZF9zaXplIG9yIGtfaGVhZF9zaXplIG9yIHFrX2hlYWRfc2l6ZVxuICAvLyAgIEhfdjogIHZfaGVhZF9zaXplXG4gIC8vICAgRF9pOiAgaW5wdXQgaGlkZGVuIHNpemVcbiAgLy8gICBEOiAgICBoaWRkZW4gc2l6ZSBmb3IgUSBhbmQgSyAoRCA9IE4gKiBIKSwgYWthIHFfaGlkZGVuX3NpemUgb3Iga19oaWRkZW5fc2l6ZSBvciBxa19oaWRkZW5fc2l6ZVxuICAvLyAgIERfdjogIHZfaGlkZGVuX3NpemUgPSBudW1faGVhZHMgKiB2X2hlYWRfc2l6ZVxuXG4gIC8vICAgICBwYXN0X2tleSAgICAgICAgICAgICAgICAgICA6IChCLCBOLCBTKiwgSClcbiAgLy8gICAgIHBhc3RfdmFsdWUgICAgICAgICAgICAgICAgIDogKEIsIE4sIFMqLCBIKVxuICAvLyBXaGVuIG5vIHBhY2tpbmcgZm9yIHEvay92OlxuICAvLyAgICAgcXVlcnkgICAgICAgICAgICAoUSkgICAgICAgOiAoQiwgUywgRClcbiAgLy8gICAgIGtleSAgICAgICAgICAgICAgKEspICAgICAgIDogKEIsIEwsIEQpIG9yIChCLCBOLCBTKiwgSClcbiAgLy8gICAgIHZhbHVlICAgICAgICAgICAgKFYpICAgICAgIDogKEIsIEwsIERfdikgb3IgKEIsIE4sIFMqLCBIKVxuICAvLyBXaGVuIHBhY2tlZCBrdiBpcyB1c2VkOlxuICAvLyAgICAgcXVlcnkgICAgICAgICAgICAoUSkgICAgICAgOiAoQiwgUywgRClcbiAgLy8gICAgIGtleSAgICAgICAgICAgICAgKEspICAgICAgIDogKEIsIEwsIE4sIDIsIEgpXG4gIC8vICAgICB2YWx1ZSAgICAgICAgICAgIChWKSAgICAgICA6IE5vbmVcbiAgLy8gV2hlbiBwYWNrZWQgcWt2IGlzIHVzZWQ6XG4gIC8vICAgICBxdWVyeSAgICAgICAgICAgIChRKSAgICAgICA6IChCLCBMLCBOLCAzLCBIKSBvciAoQiwgUywgMypEKVxuICAvLyAgICAga2V5ICAgICAgICAgICAgICAoSykgICAgICAgOiBOb25lXG4gIC8vICAgICB2YWx1ZSAgICAgICAgICAgIChWKSAgICAgICA6IE5vbmVcblxuICBpZiAocXVlcnkuZGltcy5sZW5ndGggIT09IDMgJiYgcXVlcnkuZGltcy5sZW5ndGggIT09IDUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IHF1ZXJ5IGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA1IGRpbWVuc2lvbnMnKTtcbiAgfVxuXG4gIGNvbnN0IGRtbWhhUGFja2luZyA9IGZhbHNlO1xuICBjb25zdCBiYXRjaFNpemUgPSBxdWVyeS5kaW1zWzBdO1xuICBjb25zdCBzZXF1ZW5jZUxlbmd0aCA9IHF1ZXJ5LmRpbXNbMV07XG4gIGNvbnN0IGhpZGRlblNpemUgPVxuICAgIHF1ZXJ5LmRpbXMubGVuZ3RoID09PSAzID8gKGRtbWhhUGFja2luZyA/IHF1ZXJ5LmRpbXNbMl0gLyAzIDogcXVlcnkuZGltc1syXSkgOiBhdHRyaWJ1dGVzLm51bUhlYWRzICogcXVlcnkuZGltc1s0XTtcbiAgbGV0IGt2U2VxdWVuY2VMZW5ndGggPSBzZXF1ZW5jZUxlbmd0aDtcblxuICBsZXQgcGFzdFNlcXVlbmNlTGVuZ3RoID0gMDtcbiAgbGV0IG1heFNlcXVlbmNlTGVuZ3RoID0gMDtcbiAgY29uc3QgaGVhZFNpemUgPSBNYXRoLmZsb29yKGhpZGRlblNpemUgLyBhdHRyaWJ1dGVzLm51bUhlYWRzKTtcbiAgY29uc3QgaGFzUGFzdEtleSA9IHBhc3RLZXkgJiYgcGFzdEtleS5kaW1zLmxlbmd0aCAhPT0gMDtcbiAgY29uc3QgaGFzUGFzdFZhbHVlID0gcGFzdFZhbHVlICYmIHBhc3RWYWx1ZS5kaW1zLmxlbmd0aCAhPT0gMDtcbiAgLy8gVE9ETyA6IHRoaXMgc2hvdWxkIGJlIGZyb20gYXR0cmlidXRlcy5cbiAgY29uc3QgaXNQYXN0a3ZCU05IID0gdHJ1ZTtcbiAgaWYgKGhhc1Bhc3RLZXkgJiYgaGFzUGFzdFZhbHVlKSB7XG4gICAgaWYgKHBhc3RLZXkuZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7XG4gICAgfVxuICAgIGlmIChwYXN0VmFsdWUuZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X3ZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtcbiAgICB9XG4gICAgaWYgKGlzUGFzdGt2QlNOSCkge1xuICAgICAgLy8gRm9yIEJTTkhcbiAgICAgIHBhc3RTZXF1ZW5jZUxlbmd0aCA9IHBhc3RLZXkuZGltc1sxXTtcbiAgICAgIG1heFNlcXVlbmNlTGVuZ3RoID0gcGFzdEtleS5kaW1zWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgQk5TSFxuICAgICAgcGFzdFNlcXVlbmNlTGVuZ3RoID0gcGFzdEtleS5kaW1zWzJdO1xuICAgICAgbWF4U2VxdWVuY2VMZW5ndGggPSBwYXN0S2V5LmRpbXNbMl07XG4gICAgfVxuICB9IGVsc2UgaWYgKGhhc1Bhc3RLZXkgfHwgaGFzUGFzdFZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgYW5kIFwicGFzdF92YWx1ZVwiIHNoYWxsIGJlIGJvdGggcHJlc2VudCBvciBib3RoIGFic2VudCcpO1xuICB9XG5cbiAgbGV0IHFrdkZvcm1hdDogQXR0ZW50aW9uUWt2Rm9ybWF0O1xuICBpZiAoa2V5KSB7XG4gICAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBnaXZlbicpO1xuICAgIH1cbiAgICBpZiAoa2V5LmRpbXMubGVuZ3RoIDwgMyB8fCBrZXkuZGltcy5sZW5ndGggPiA1KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzLCA0LCBvciA1IGRpbWVuc2lvbnMnKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5LmRpbXNbMF0gIT09IGtleS5kaW1zWzBdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJrZXlcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoIHNpemUpJyk7XG4gICAgfVxuXG4gICAgaWYgKGtleS5kaW1zLmxlbmd0aCA9PT0gMykge1xuICAgICAgaWYgKHF1ZXJ5LmRpbXNbMl0gJSBrZXkuZGltc1syXSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpbWVuc2lvbiAyIG9mIFwicXVlcnlcIiBzaG91bGQgYmUgYSBtdWx0aXBsZSBvZiBcImtleVwiJyk7XG4gICAgICB9XG4gICAgICBxa3ZGb3JtYXQgPSBBdHRlbnRpb25Ra3ZGb3JtYXQucWt2QlNOSDtcbiAgICAgIGt2U2VxdWVuY2VMZW5ndGggPSBrZXkuZGltc1sxXTtcbiAgICB9IGVsc2UgaWYgKGtleS5kaW1zLmxlbmd0aCA9PT0gNSkge1xuICAgICAgaWYgKGtleS5kaW1zWzJdICE9PSBhdHRyaWJ1dGVzLm51bUhlYWRzIHx8IGtleS5kaW1zWzNdICE9PSAyIHx8IGtleS5kaW1zWzRdICE9PSBoZWFkU2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMiwgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJ2YWx1ZVwiIGJlIG5vbmUgd2hlbiBcImtleVwiIGhhcyBwYWNrZWQga3YgZm9ybWF0LicpO1xuICAgICAgfVxuICAgICAgcWt2Rm9ybWF0ID0gQXR0ZW50aW9uUWt2Rm9ybWF0LnFLdkJTTkh4QlNOMkg7XG4gICAgICBrdlNlcXVlbmNlTGVuZ3RoID0ga2V5LmRpbXNbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGtleV9kaW1zLnNpemUoKSA9PSA0IChjcm9zcy1hdHRlbnRpb24gd2l0aCBwYXN0X2tleSlcbiAgICAgIGlmIChrZXkuZGltc1sxXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fCBrZXkuZGltc1szXSAhPT0gaGVhZFNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJrZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIGhlYWRfc2l6ZSkgZm9yIHBhc3Rfa2V5Jyk7XG4gICAgICB9XG5cbiAgICAgIHFrdkZvcm1hdCA9IEF0dGVudGlvblFrdkZvcm1hdC51bmtub3duO1xuICAgICAga3ZTZXF1ZW5jZUxlbmd0aCA9IGtleS5kaW1zWzJdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBwYWNrZWQgUUtWXG4gICAgaWYgKHF1ZXJ5LmRpbXMubGVuZ3RoICE9PSAzICYmIHF1ZXJ5LmRpbXMubGVuZ3RoICE9PSA1KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNSBkaW1lbnNpb25zIHdoZW4ga2V5IGlzIGVtcHR5Jyk7XG4gICAgfVxuICAgIGlmIChxdWVyeS5kaW1zLmxlbmd0aCA9PT0gNSAmJiAocXVlcnkuZGltc1syXSAhPT0gYXR0cmlidXRlcy5udW1IZWFkcyB8fCBxdWVyeS5kaW1zWzNdICE9PSAzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJxdWVyeVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMywgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7XG4gICAgfVxuXG4gICAgcWt2Rm9ybWF0ID0gQXR0ZW50aW9uUWt2Rm9ybWF0LnFrdkJTTjNIO1xuICB9XG5cbiAgY29uc3QgbWFza1R5cGU6IEF0dGVudGlvbk1hc2tUeXBlID0gQXR0ZW50aW9uTWFza1R5cGUubm9uZTtcbiAgbGV0IHBhc3NQYXN0SW5LdiA9IGZhbHNlO1xuICBsZXQgdkhpZGRlblNpemUgPSBoaWRkZW5TaXplO1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuZGltcy5sZW5ndGggIT09IDMgJiYgdmFsdWUuZGltcy5sZW5ndGggIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJ2YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA0IGRpbWVuc2lvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAocXVlcnkuZGltc1swXSAhPT0gdmFsdWUuZGltc1swXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoX3NpemUpJyk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLmRpbXMubGVuZ3RoID09PSAzKSB7XG4gICAgICBpZiAoa3ZTZXF1ZW5jZUxlbmd0aCAhPT0gdmFsdWUuZGltc1sxXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAxIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7XG4gICAgICB9XG4gICAgICB2SGlkZGVuU2l6ZSA9IHZhbHVlLmRpbXNbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChrdlNlcXVlbmNlTGVuZ3RoICE9PSB2YWx1ZS5kaW1zWzJdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGFuZCBcInBhc3RfdmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAyIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7XG4gICAgICB9XG4gICAgICB2SGlkZGVuU2l6ZSA9IHZhbHVlLmRpbXNbMV0gKiB2YWx1ZS5kaW1zWzNdO1xuICAgICAgcGFzc1Bhc3RJbkt2ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdG90YWxTZXF1ZW5jZUxlbmd0aCA9IHBhc3RTZXF1ZW5jZUxlbmd0aCArIGt2U2VxdWVuY2VMZW5ndGg7XG4gIGNvbnN0IGJyb2FkY2FzdFJlc1Bvc0JpYXMgPSBmYWxzZTtcblxuICByZXR1cm4ge1xuICAgIGJhdGNoU2l6ZSxcbiAgICBzZXF1ZW5jZUxlbmd0aCxcbiAgICBwYXN0U2VxdWVuY2VMZW5ndGgsXG4gICAga3ZTZXF1ZW5jZUxlbmd0aCxcbiAgICB0b3RhbFNlcXVlbmNlTGVuZ3RoLFxuICAgIG1heFNlcXVlbmNlTGVuZ3RoLFxuICAgIGlucHV0SGlkZGVuU2l6ZTogMCxcbiAgICBoaWRkZW5TaXplLFxuICAgIHZIaWRkZW5TaXplLFxuICAgIGhlYWRTaXplLFxuICAgIHZIZWFkU2l6ZTogTWF0aC5mbG9vcih2SGlkZGVuU2l6ZSAvIGF0dHJpYnV0ZXMua3ZOdW1IZWFkcyEpLFxuICAgIG51bUhlYWRzOiBhdHRyaWJ1dGVzLm51bUhlYWRzLFxuICAgIGt2TnVtSGVhZHM6IGF0dHJpYnV0ZXMua3ZOdW1IZWFkcyxcbiAgICBuUmVwczogYXR0cmlidXRlcy5udW1IZWFkcyAvIGF0dHJpYnV0ZXMua3ZOdW1IZWFkcyEsXG4gICAgcGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjogZmFsc2UsXG4gICAgbWFza1R5cGUsXG4gICAgc2NhbGU6IGF0dHJpYnV0ZXMuc2NhbGUsXG4gICAgYnJvYWRjYXN0UmVzUG9zQmlhcyxcbiAgICBwYXNzUGFzdEluS3YsXG4gICAgcWt2Rm9ybWF0LFxuICAgIGlzUGFzdGt2QlNOSCxcbiAgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZUNvbmNhdFByb2dyYW1JbmZvID0gKFxuICBhOiBUZW5zb3JWaWV3LFxuICBiOiBUZW5zb3JWaWV3IHwgdW5kZWZpbmVkLFxuICBkYXRhVHlwZTogRGF0YVR5cGUsXG4gIHBhcmFtczogQXR0ZW50aW9uUGFyYW1ldGVycyxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbcGFyYW1zLmJhdGNoU2l6ZSwgcGFyYW1zLnRvdGFsU2VxdWVuY2VMZW5ndGgsIHBhcmFtcy5rdk51bUhlYWRzISwgcGFyYW1zLmhlYWRTaXplXTtcbiAgY29uc3QgY29tcG9uZW50ID0gNDtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIGNvbXBvbmVudDtcbiAgY29uc3QgcHJlc2VudFNlcXVlbmNlTGVuZ3RoID0gcGFyYW1zLnRvdGFsU2VxdWVuY2VMZW5ndGg7XG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdwcmVzZW50X2t2JywgZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50KTtcbiAgY29uc3QgaW5wdXRBID0gaW5wdXRWYXJpYWJsZSgnbmV3X2t2JywgYS5kYXRhVHlwZSwgYS5kaW1zLmxlbmd0aCwgY29tcG9uZW50KTtcbiAgY29uc3QgaW5wdXRCID0gYiA/IGlucHV0VmFyaWFibGUoJ3Bhc3Rfa3YnLCBiLmRhdGFUeXBlLCBiLmRpbXMubGVuZ3RoLCBjb21wb25lbnQpIDogdW5kZWZpbmVkO1xuXG4gIGNvbnN0IEggPSBNYXRoLmNlaWwocGFyYW1zLmhlYWRTaXplIC8gY29tcG9uZW50KTtcbiAgY29uc3QgZGlzcGF0Y2ggPSB7IHg6IHByZXNlbnRTZXF1ZW5jZUxlbmd0aCwgeTogYS5kaW1zWzBdLCB6OiAxIH07XG5cbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBiID8gWydyYW5rJywgJ3JhbmsnXSA6IFsncmFuayddO1xuXG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwYXJhbXMucGFzdFNlcXVlbmNlTGVuZ3RoIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtcy5rdlNlcXVlbmNlTGVuZ3RoIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHBhcmFtcy50b3RhbFNlcXVlbmNlTGVuZ3RoIH0sXG4gIF07XG5cbiAgY29uc3QgaW5wdXRzID0gW2lucHV0QV07XG4gIGlmIChpbnB1dEIpIHtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaChcbiAgICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGEuZGltcyksXG4gICAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhiIS5kaW1zKSxcbiAgICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSxcbiAgICApO1xuICAgIGlucHV0cy5wdXNoKGlucHV0Qik7XG4gIH0gZWxzZSB7XG4gICAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoYS5kaW1zKSwgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGUpKTtcbiAgfVxuICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgIHsgbmFtZTogJ3Bhc3Rfc2VxbGVuJywgdHlwZTogJ3UzMicgfSxcbiAgICB7IG5hbWU6ICduZXdfc2VxbGVuJywgdHlwZTogJ3UzMicgfSxcbiAgICB7IG5hbWU6ICdwcmVzZW50X3NlcWxlbicsIHR5cGU6ICd1MzInIH0sXG4gIF07XG5cbiAgY29uc3QgcGFzdFN0ciA9IGAgICAgICBsZXQgcGFzdF9iYXRjaF9zdHJpZGUgPSB1bmlmb3Jtcy5wYXN0X3NlcWxlbiAqIG51bV9oZWFkcyAqIEg7XG4gICAgICAgIHZhciBwYXN0X2hlYWRfc3RyaWRlID0gdW5pZm9ybXMucGFzdF9zZXFsZW4gKiBIO1xuICAgICAgICBpZiAoaXNfYnNuaCkge1xuICAgICAgICAgIHBhc3RfaGVhZF9zdHJpZGUgPSBIO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbl9vZmZzZXQgPSBiICogcGFzdF9iYXRjaF9zdHJpZGUgKyBzICogcm93X3N0cmlkZSArIG4gKiBwYXN0X2hlYWRfc3RyaWRlICsgaDtcbiAgICAgICAgcHJlc2VudF9rdltvdXRfb2Zmc2V0XSA9IHBhc3Rfa3ZbaW5fb2Zmc2V0XTtgO1xuICBjb25zdCBuZXdTdHIgPSBgICAgICAgbGV0IG5ld19iYXRjaF9zdHJpZGUgPSB1bmlmb3Jtcy5uZXdfc2VxbGVuICogbnVtX2hlYWRzICogSDtcbiAgICAgICAgbGV0IG5ld19yb3dfc3RyaWRlID0gbnVtX2hlYWRzICogSDtcbiAgICAgICAgbGV0IG5ld19oZWFkX3N0cmlkZSA9IEg7XG4gICAgICAgIGxldCBpbl9vZmZzZXQgPSBiICogbmV3X2JhdGNoX3N0cmlkZSArIChzIC0gcGFzdF9zZXFsZW4pICogbmV3X3Jvd19zdHJpZGUgKyBuICogbmV3X2hlYWRfc3RyaWRlICsgaDtcbiAgICAgICAgcHJlc2VudF9rdltvdXRfb2Zmc2V0XSA9IG5ld19rdltpbl9vZmZzZXRdO2A7XG4gIGNvbnN0IGNvbmNhdFN0ciA9IGJcbiAgICA/IGBpZiAocyA8IHBhc3Rfc2VxbGVuKSB7XG4gICAgICAgICR7cGFzdFN0cn1cbiAgICAgICAgfSBlbHNlIGlmIChzIDwgcGFzdF9zZXFsZW4gKyB1bmlmb3Jtcy5uZXdfc2VxbGVuKSB7XG4gICAgICAgICR7bmV3U3RyfVxuICAgICAgICB9YFxuICAgIDogYGlmIChzIDwgcGFzdF9zZXFsZW4gKyB1bmlmb3Jtcy5uZXdfc2VxbGVuKSB7XG4gICAgICAgICAgJHtuZXdTdHJ9XG4gICAgICAgIH1gO1xuXG4gIC8vIFRPRE86IGhhbmRsZSBIICogcGFyYW1zLmt2TnVtSGVhZHMgZ3JlYXRlciB0aGFuIG1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cCBsaW1pdC5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiBgXG5cbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dHMsIG91dHB1dCl9XG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydChbSCwgcGFyYW1zLmt2TnVtSGVhZHMhLCAxXSl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cbiAgICB2YXIgaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICBsZXQgaCA9IGxvY2FsX2lkLng7XG4gICAgbGV0IG4gPSBsb2NhbF9pZC55O1xuICAgIGxldCBzID0gd29ya2dyb3VwX2lkLng7XG4gICAgbGV0IGIgPSB3b3JrZ3JvdXBfaWQueTtcbiAgICBsZXQgbnVtX2hlYWRzID0gJHtwYXJhbXMua3ZOdW1IZWFkcyF9dTtcbiAgICBsZXQgSCA9ICR7SH11O1xuXG4gICAgbGV0IHByZXNlbnRfc2VxbGVuID0gdW5pZm9ybXMucHJlc2VudF9zZXFsZW47XG4gICAgbGV0IHByZXNlbnRfYmF0Y2hfc3RyaWRlID0gcHJlc2VudF9zZXFsZW4gKiBudW1faGVhZHMgKiBIO1xuICAgIHZhciByb3dfc3RyaWRlID0gSDtcbiAgICBsZXQgaXNfYnNuaCA9ICR7cGFyYW1zLmlzUGFzdGt2QlNOSH07XG5cbiAgICBpZiAoaXNfYnNuaCkge1xuICAgICAgcm93X3N0cmlkZSA9IG51bV9oZWFkcyAqIEg7XG4gICAgfVxuICAgIHZhciBwcmVzZW50X2hlYWRfc3RyaWRlID0gcHJlc2VudF9zZXFsZW4gKiBIO1xuICAgIGlmIChpc19ic25oKSB7XG4gICAgICBwcmVzZW50X2hlYWRfc3RyaWRlID0gSDtcbiAgICB9XG5cbiAgICBsZXQgcGFzdF9zZXFsZW4gPSB1bmlmb3Jtcy5wYXN0X3NlcWxlbjtcblxuICAgIGxldCBvdXRfb2Zmc2V0ID0gYiAqIHByZXNlbnRfYmF0Y2hfc3RyaWRlICsgcyAqIHJvd19zdHJpZGUgKyBuICogcHJlc2VudF9oZWFkX3N0cmlkZSArIGg7XG4gICAgJHtjb25jYXRTdHJ9XG4gIH1gO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0NvbmNhdFBhc3ROZXcnLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke3BhcmFtcy5rdk51bUhlYWRzIX0ke0h9JHshIWJ9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlIH1dLFxuICAgICAgZGlzcGF0Y2hHcm91cDogZGlzcGF0Y2gsXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlR3JvdXBRdWVyeUF0dGVudGlvbkF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogQXR0ZW50aW9uQXR0cnMpOiBBdHRlbnRpb25BdHRycyA9PlxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyAuLi5hdHRyaWJ1dGVzIH0pO1xuXG5jb25zdCB3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGU6IFRyYW5zcG9zZUF0dHJpYnV0ZXMgPSBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBwZXJtOiBbMCwgMiwgMSwgM10gfSk7XG5cbmNvbnN0IG1heWJlRXhwYW5kQW5kVHJhbnNwb3NlVG9CTlNIID0gKFxuICBjb250ZXh0OiBDb21wdXRlQ29udGV4dCxcbiAgaW5wdXQ6IFRlbnNvclZpZXcsXG4gIHBhc3RLVjogVGVuc29yVmlldyB8IHVuZGVmaW5lZCxcbiAgcGFyYW1zOiBBdHRlbnRpb25QYXJhbWV0ZXJzLFxuICBvdXRwdXRJbmRleDogbnVtYmVyLFxuKSA9PiB7XG4gIGxldCByZXNoYXBlZElucHV0ID0gaW5wdXQ7XG4gIGNvbnN0IG51bUhlYWRzID0gcGFyYW1zLmt2TnVtSGVhZHMhO1xuICBjb25zdCBuUmVwcyA9IHBhcmFtcy5uUmVwcyE7XG4gIGlmIChpbnB1dC5kaW1zLmxlbmd0aCA9PT0gMyAmJiBwYXJhbXMua3ZTZXF1ZW5jZUxlbmd0aCAhPT0gMCkge1xuICAgIHJlc2hhcGVkSW5wdXQgPSBpbnB1dC5yZXNoYXBlKFtwYXJhbXMuYmF0Y2hTaXplLCBwYXJhbXMua3ZTZXF1ZW5jZUxlbmd0aCwgbnVtSGVhZHMsIHBhcmFtcy5oZWFkU2l6ZV0pO1xuICB9XG5cbiAgaWYgKHBhc3RLVikge1xuICAgIHJlc2hhcGVkSW5wdXQgPSBjb250ZXh0LmNvbXB1dGUoY3JlYXRlQ29uY2F0UHJvZ3JhbUluZm8ocmVzaGFwZWRJbnB1dCwgcGFzdEtWLCByZXNoYXBlZElucHV0LmRhdGFUeXBlLCBwYXJhbXMpLCB7XG4gICAgICBpbnB1dHM6IFtyZXNoYXBlZElucHV0LCBwYXN0S1ZdLFxuICAgICAgb3V0cHV0czogW3BhcmFtcy5pc1Bhc3RrdkJTTkggPyBvdXRwdXRJbmRleCA6IC0xXSxcbiAgICB9KVswXTtcbiAgfSBlbHNlIHtcbiAgICByZXNoYXBlZElucHV0ID0gY29udGV4dC5jb21wdXRlKGNyZWF0ZUNvbmNhdFByb2dyYW1JbmZvKHJlc2hhcGVkSW5wdXQsIHVuZGVmaW5lZCwgcmVzaGFwZWRJbnB1dC5kYXRhVHlwZSwgcGFyYW1zKSwge1xuICAgICAgaW5wdXRzOiBbcmVzaGFwZWRJbnB1dF0sXG4gICAgICBvdXRwdXRzOiBbcGFyYW1zLmlzUGFzdGt2QlNOSCA/IG91dHB1dEluZGV4IDogLTFdLFxuICAgIH0pWzBdO1xuICB9XG4gIGlmIChuUmVwcyAhPT0gMSkge1xuICAgIHJlc2hhcGVkSW5wdXQgPSBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVGlsZVByb2dyYW1JbmZvKFtyZXNoYXBlZElucHV0XSwgWzEsIDEsIDEsIG5SZXBzXSksIHtcbiAgICAgIGlucHV0czogW3Jlc2hhcGVkSW5wdXRdLFxuICAgICAgb3V0cHV0czogWy0xXSxcbiAgICB9KVswXTtcbiAgICByZXNoYXBlZElucHV0ID0gcmVzaGFwZWRJbnB1dC5yZXNoYXBlKFtcbiAgICAgIHBhcmFtcy5iYXRjaFNpemUsXG4gICAgICBwYXJhbXMudG90YWxTZXF1ZW5jZUxlbmd0aCxcbiAgICAgIG51bUhlYWRzICogblJlcHMsXG4gICAgICBwYXJhbXMuaGVhZFNpemUsXG4gICAgXSk7XG4gIH1cblxuICByZXR1cm4gY29udGV4dC5jb21wdXRlKGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvKHJlc2hhcGVkSW5wdXQsIHdlaWdodFRyYW5zcG9zZUF0dHJpYnV0ZS5wZXJtKSwge1xuICAgIGlucHV0czogW3Jlc2hhcGVkSW5wdXRdLFxuICAgIG91dHB1dHM6IFstMV0sXG4gIH0pWzBdO1xufTtcblxuZXhwb3J0IGNvbnN0IGdyb3VwUXVlcnlBdHRlbnRpb24gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEF0dGVudGlvbkF0dHJzKTogdm9pZCA9PiB7XG4gIGNvbnN0IHBhcmFtcyA9IHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKTtcbiAgaWYgKGNvbnRleHQuaW5wdXRzWzBdLmRpbXMubGVuZ3RoID09PSA1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYWNrZWQgUUtWIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgaWYgKGNvbnRleHQuaW5wdXRzWzFdPy5kaW1zLmxlbmd0aCA9PT0gNSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFja2VkIEtWIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgY29uc3QgUSA9IG1heWJlVHJhbnNwb3NlVG9CTlNIQW5kQWRkQmlhcyhcbiAgICBjb250ZXh0LFxuICAgIHBhcmFtcy5iYXRjaFNpemUsXG4gICAgcGFyYW1zLm51bUhlYWRzLFxuICAgIHBhcmFtcy5zZXF1ZW5jZUxlbmd0aCxcbiAgICBwYXJhbXMuaGVhZFNpemUsXG4gICAgY29udGV4dC5pbnB1dHNbMF0sXG4gICAgdW5kZWZpbmVkLFxuICAgIDAsXG4gICk7XG4gIGNvbnN0IHBhc3RLZXkgPSBjb250ZXh0LmlucHV0c1szXSAmJiBjb250ZXh0LmlucHV0c1szXS5kaW1zLmxlbmd0aCAhPT0gMCA/IGNvbnRleHQuaW5wdXRzWzNdIDogdW5kZWZpbmVkO1xuICBjb25zdCBwYXN0VmFsdWUgPSBjb250ZXh0LmlucHV0c1s0XSAmJiBjb250ZXh0LmlucHV0c1s0XS5kaW1zLmxlbmd0aCAhPT0gMCA/IGNvbnRleHQuaW5wdXRzWzRdIDogdW5kZWZpbmVkO1xuICBjb25zdCBLID0gbWF5YmVFeHBhbmRBbmRUcmFuc3Bvc2VUb0JOU0goY29udGV4dCwgY29udGV4dC5pbnB1dHNbMV0sIHBhc3RLZXksIHBhcmFtcywgMSk7XG4gIGNvbnN0IFYgPSBtYXliZUV4cGFuZEFuZFRyYW5zcG9zZVRvQk5TSChjb250ZXh0LCBjb250ZXh0LmlucHV0c1syXSwgcGFzdFZhbHVlLCBwYXJhbXMsIDIpO1xuICBhcHBseUF0dGVudGlvbihjb250ZXh0LCBRLCBLLCBWLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgcGFyYW1zLCBhdHRyaWJ1dGVzKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGNyZWF0ZVRyYW5zcG9zZVByb2dyYW1JbmZvIH0gZnJvbSAnLi90cmFuc3Bvc2UnO1xuXG5pbXBvcnQge1xuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcbiAgZ2V0TWF4Q29tcG9uZW50cyxcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgc3VtVmVjdG9yLFxuICB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUsXG59IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBJbnN0YW5jZU5vcm1BdHRyaWJ1dGVzIHtcbiAgZXBzaWxvbjogbnVtYmVyO1xuICBmb3JtYXQ6ICdOSFdDJyB8ICdOQ0hXJztcbn1cblxuY29uc3QgY29tcHV0ZUNoYW5uZWxTY2FsZVNoaWZ0ID0gKFxuICBjb250ZXh0OiBDb21wdXRlQ29udGV4dCxcbiAgaW5wdXQ6IFRlbnNvclZpZXcsXG4gIHNjYWxlOiBUZW5zb3JWaWV3LFxuICBiaWFzOiBUZW5zb3JWaWV3LFxuICBuOiBudW1iZXIsXG4gIGg6IG51bWJlcixcbiAgYzogbnVtYmVyLFxuICBlcHNpbG9uOiBudW1iZXIsXG4pID0+IHtcbiAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoaCk7XG4gIGNvbnN0IGYzMlR5cGUgPSBjb21wb25lbnRzID09PSAxID8gJ2YzMicgOiBgdmVjJHtjb21wb25lbnRzfWZgO1xuICBjb25zdCB3Z1R5cGUgPSBjb21wb25lbnRzID09PSAxID8gJ3ZlYzJmJyA6IGBtYXQyeCR7Y29tcG9uZW50c31mYDtcbiAgY29uc3QgdW5pdHNPZldvcmsgPSBuICogYztcblxuICBjb25zdCBpbnB1dFNoYXBlID0gW24sIGMsIGggLyBjb21wb25lbnRzXTtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBbbiwgYywgMl07XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWydyYW5rJywgJ3R5cGUnLCAndHlwZSddO1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSwgb3V0cHV0U2hhcGUpKTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0LmRhdGFUeXBlLCAzLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCBzID0gaW5wdXRWYXJpYWJsZSgnc2NhbGUnLCBzY2FsZS5kYXRhVHlwZSwgc2NhbGUuZGltcyk7XG4gICAgY29uc3QgYiA9IGlucHV0VmFyaWFibGUoJ2JpYXMnLCBiaWFzLmRhdGFUeXBlLCBiaWFzLmRpbXMpO1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBEYXRhVHlwZS5mbG9hdCwgMywgMik7XG4gICAgY29uc3QgdmFyaWFibGVzID0gW3gsIHMsIGIsIG91dHB1dF07XG4gICAgY29uc3Qgd29ya2dyb3VwU2l6ZSA9IDY0O1xuICAgIHJldHVybiBgXG4gIHZhcjx3b3JrZ3JvdXA+IHdvcmtncm91cF9zaGFyZWQgOiBhcnJheTwke3dnVHlwZX0sICR7d29ya2dyb3VwU2l6ZX0+O1xuICBjb25zdCB3b3JrZ3JvdXBfc2l6ZSA9ICR7d29ya2dyb3VwU2l6ZX11O1xuICAke3NoYWRlckhlbHBlci5kZWNsYXJlVmFyaWFibGVzKC4uLnZhcmlhYmxlcyl9XG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCh3b3JrZ3JvdXBTaXplKX1cbiAgICBsZXQgYmF0Y2ggPSB3b3JrZ3JvdXBfaW5kZXggLyB1bmlmb3Jtcy54X3NoYXBlWzFdO1xuICAgIGxldCBjaGFubmVsID0gd29ya2dyb3VwX2luZGV4ICUgdW5pZm9ybXMueF9zaGFwZVsxXTtcbiAgICBsZXQgaGlnaHQgPSB1bmlmb3Jtcy54X3NoYXBlWzJdO1xuICAgIC8vIGluaXRpYWxpemUgd29ya2dyb3VwIG1lbW9yeVxuICAgIHZhciBzdW0gPSAke2YzMlR5cGV9KDApO1xuICAgIHZhciBzcXVhcmVkX3N1bSA9ICR7ZjMyVHlwZX0oMCk7XG4gICAgZm9yICh2YXIgaCA9IGxvY2FsX2lkeDsgaCA8IGhpZ2h0OyBoICs9IHdvcmtncm91cF9zaXplKSB7XG4gICAgICBsZXQgdmFsdWUgPSAke2YzMlR5cGV9KCR7eC5nZXQoJ2JhdGNoJywgJ2NoYW5uZWwnLCAnaCcpfSk7XG4gICAgICBzdW0gKz0gdmFsdWU7XG4gICAgICBzcXVhcmVkX3N1bSArPSB2YWx1ZSAqIHZhbHVlO1xuICAgIH1cbiAgICB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkeF0gPSAke3dnVHlwZX0oc3VtLCBzcXVhcmVkX3N1bSk7XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgZm9yICh2YXIgY3VyclNpemUgPSB3b3JrZ3JvdXBfc2l6ZSA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IGN1cnJTaXplID4+IDEpIHtcbiAgICAgIGlmIChsb2NhbF9pZHggPCBjdXJyU2l6ZSkge1xuICAgICAgICB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkeF0gPSB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkeF0gKyB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkeCArIGN1cnJTaXplXTtcbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG4gICAgaWYgKGxvY2FsX2lkeCA9PSAwKSB7XG4gICAgICBsZXQgc3VtX2ZpbmFsID0gJHtzdW1WZWN0b3IoJ3dvcmtncm91cF9zaGFyZWRbMF1bMF0nLCBjb21wb25lbnRzKX0gLyBmMzIoaGlnaHQgKiAke2NvbXBvbmVudHN9KTtcbiAgICAgIGxldCBzcXVhcmVkX3N1bV9maW5hbCA9ICR7c3VtVmVjdG9yKCd3b3JrZ3JvdXBfc2hhcmVkWzBdWzFdJywgY29tcG9uZW50cyl9IC8gZjMyKGhpZ2h0ICogJHtjb21wb25lbnRzfSk7XG5cbiAgICAgIGxldCBpbnZfc3RkX2RldiA9IGludmVyc2VTcXJ0KHNxdWFyZWRfc3VtX2ZpbmFsIC0gc3VtX2ZpbmFsICogc3VtX2ZpbmFsICsgZjMyKCR7ZXBzaWxvbn0pKTtcbiAgICAgIGxldCBjaGFubmVsX3NjYWxlID0gaW52X3N0ZF9kZXYgKiBmMzIoc2NhbGVbY2hhbm5lbF0pO1xuICAgICAgbGV0IGNoYW5uZWxfc2hpZnQgPSBmMzIoYmlhc1tjaGFubmVsXSkgLSBzdW1fZmluYWwgKiBjaGFubmVsX3NjYWxlO1xuICAgICAgb3V0cHV0W3dvcmtncm91cF9pbmRleF0gPSB2ZWMyZihjaGFubmVsX3NjYWxlLCBjaGFubmVsX3NoaWZ0KTtcbiAgICB9XG4gIH1gO1xuICB9O1xuXG4gIHJldHVybiBjb250ZXh0LmNvbXB1dGUoXG4gICAge1xuICAgICAgbmFtZTogJ0luc3RhbmNlTm9ybUNvbXB1dGVDaGFubmVsU2NhbGVTaGlmdCcsXG4gICAgICAvLyBUT0RPOiB1c2UgZXBzaWxvbiBhcyB1bmlmb3JtLiBDdXJyZW50bHkgZXBzaWxvbiBhcyB1bmlmb3JtIGZhaWxzIHRlc3RfaW5zdGFuY2Vub3JtX2Vwc2lsb24uXG4gICAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHtjb21wb25lbnRzfTske2Vwc2lsb259YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcbiAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogRGF0YVR5cGUuZmxvYXQgfV0sXG4gICAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogdW5pdHNPZldvcmsgfSxcbiAgICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgICAgfSksXG4gICAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgfSxcbiAgICB7IGlucHV0czogW2lucHV0LCBzY2FsZSwgYmlhc10sIG91dHB1dHM6IFstMV0gfSxcbiAgKVswXTtcbn07XG5cbmNvbnN0IGNyZWF0ZUluc3RhbmNlTm9ybVByb2dyYW1JbmZvID0gKFxuICBjb250ZXh0OiBDb21wdXRlQ29udGV4dCxcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IEluc3RhbmNlTm9ybUF0dHJpYnV0ZXMsXG4pID0+IHtcbiAgY29uc3QgeFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0geFNoYXBlO1xuICBjb25zdCBheGlzID0gMjtcbiAgY29uc3QgTiA9IHhTaGFwZVswXTtcbiAgY29uc3QgQyA9IHhTaGFwZVsxXTtcbiAgY29uc3QgSCA9IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbih4U2hhcGUsIGF4aXMpO1xuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhIKTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIGNvbXBvbmVudHM7XG4gIC8vIGNvbXB1dGUgY2hhbm5lbCBzY2FsZSBhbmQgY2hhbm5lbCBzaGlmdC5cbiAgY29uc3QgY2hhbm5lbFNjYWxlU2hpZnQgPSBjb21wdXRlQ2hhbm5lbFNjYWxlU2hpZnQoXG4gICAgY29udGV4dCxcbiAgICBpbnB1dHNbMF0sXG4gICAgaW5wdXRzWzFdLFxuICAgIGlucHV0c1syXSxcbiAgICBOLFxuICAgIEgsXG4gICAgQyxcbiAgICBhdHRyaWJ1dGVzLmVwc2lsb24sXG4gICk7XG5cbiAgY29uc3QgaW5wdXRTaGFwZSA9IFtOLCBDLCBIIC8gY29tcG9uZW50c107XG4gIGNvbnN0IHNjYWxlU2hhcGUgPSBbTiwgQ107XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWyd0eXBlJywgJ25vbmUnXTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRTaGFwZS5sZW5ndGgsIGNvbXBvbmVudHMpO1xuICAgIGNvbnN0IHNjYWxlID0gaW5wdXRWYXJpYWJsZSgnc2NhbGVfc2hpZnQnLCBEYXRhVHlwZS5mbG9hdCwgc2NhbGVTaGFwZS5sZW5ndGgsIDIpO1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0U2hhcGUubGVuZ3RoLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCB2YXJpYWJsZXMgPSBbeCwgc2NhbGUsIG91dHB1dF07XG4gICAgcmV0dXJuIGBcbiAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCdvdXRwdXRfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKC4uLnZhcmlhYmxlcyl9XG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICBsZXQgYmF0Y2ggPSBvdXRwdXRJbmRpY2VzWzBdO1xuICAgICAgbGV0IGNoYW5uZWwgPSBvdXRwdXRJbmRpY2VzWzFdO1xuICAgICAgbGV0IHNjYWxlX3NoaWZ0ID0gJHtzY2FsZS5nZXRCeUluZGljZXMoJ3ZlYzI8dTMyPihiYXRjaCwgY2hhbm5lbCknKX07XG4gICAgICBsZXQgdmFsdWUgPSAke3guZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKX0gKiAke291dHB1dC50eXBlLnZhbHVlfShzY2FsZV9zaGlmdC54KSArICR7b3V0cHV0LnR5cGUudmFsdWV9KHNjYWxlX3NoaWZ0LnkpO1xuICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCAndmFsdWUnKX07XG4gIH1gO1xuICB9O1xuXG4gIGNvbnRleHQuY29tcHV0ZShcbiAgICB7XG4gICAgICBuYW1lOiAnSW5zdGFuY2VOb3JtYWxpemF0aW9uJyxcbiAgICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2NvbXBvbmVudHN9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcbiAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxuICAgICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICAgIHByb2dyYW1Vbmlmb3JtczogW1xuICAgICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRTaGFwZSwgc2NhbGVTaGFwZSwgaW5wdXRTaGFwZSksXG4gICAgICAgIF0sXG4gICAgICB9KSxcbiAgICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICB9LFxuICAgIHsgaW5wdXRzOiBbaW5wdXRzWzBdLCBjaGFubmVsU2NhbGVTaGlmdF0gfSxcbiAgKTtcbn07XG5cbmNvbnN0IGNyZWF0ZUluc3RhbmNlTm9ybU5IV0NQcm9ncmFtSW5mbyA9IChcbiAgY29udGV4dDogQ29tcHV0ZUNvbnRleHQsXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhdHRyaWJ1dGVzOiBJbnN0YW5jZU5vcm1BdHRyaWJ1dGVzLFxuKSA9PiB7XG4gIGNvbnN0IHhTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IHhTaGFwZTtcbiAgY29uc3QgTiA9IHhTaGFwZVswXTtcbiAgY29uc3QgQyA9IHhTaGFwZVt4U2hhcGUubGVuZ3RoIC0gMV07XG4gIGNvbnN0IEggPSBTaGFwZVV0aWwuc2l6ZUZyb21EaW1lbnNpb24oeFNoYXBlLCAxKSAvIEM7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKEMpO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUob3V0cHV0U2hhcGUpIC8gY29tcG9uZW50cztcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBIIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IE1hdGguZmxvb3IoQyAvIGNvbXBvbmVudHMpIH0sXG4gIF07XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWyd0eXBlJywgJ3R5cGUnXTtcblxuICAvLyAxLiB0cmFuc3Bvc2UgeCBmcm9tIE5IV0MgdG8gTkNIV1xuICBjb25zdCB0cmFuc3Bvc2VkWFBlcm0gPSBbMCwgeFNoYXBlLmxlbmd0aCAtIDFdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHhTaGFwZS5sZW5ndGggLSAyOyBpKyspIHtcbiAgICB0cmFuc3Bvc2VkWFBlcm0ucHVzaChpICsgMSk7XG4gIH1cbiAgY29uc3QgdHJhbnNwb3NlZFggPSBjb250ZXh0LmNvbXB1dGUoY3JlYXRlVHJhbnNwb3NlUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHNbMF0sIHRyYW5zcG9zZWRYUGVybSksIHtcbiAgICBpbnB1dHM6IFtjb250ZXh0LmlucHV0c1swXV0sXG4gICAgb3V0cHV0czogWy0xXSxcbiAgfSlbMF07XG4gIC8vIDIuIGNvbXB1dGUgY2hhbm5lbCBzY2FsZSBhbmQgY2hhbm5lbCBzaGlmdC5cbiAgY29uc3QgY2hhbm5lbFNjYWxlU2hpZnQgPSBjb21wdXRlQ2hhbm5lbFNjYWxlU2hpZnQoXG4gICAgY29udGV4dCxcbiAgICB0cmFuc3Bvc2VkWCxcbiAgICBpbnB1dHNbMV0sXG4gICAgaW5wdXRzWzJdLFxuICAgIE4sXG4gICAgSCxcbiAgICBDLFxuICAgIGF0dHJpYnV0ZXMuZXBzaWxvbixcbiAgKTtcbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoaW5wdXRzWzBdLmRhdGFUeXBlKTtcbiAgICBjb25zdCBzY2FsZVR5cGUgPSBjb21wb25lbnRzID09PSAxID8gJ3ZlYzJmJyA6IGBtYXQke2NvbXBvbmVudHN9eDJmYDtcbiAgICBjb25zdCBzY2FsZURhdGEgPSAobnVtOiBudW1iZXIpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gbnVtID09PSAwID8gJ3gnIDogJ3knO1xuICAgICAgY29uc3QgZjMyVHlwZSA9IGNvbXBvbmVudHMgPT09IDEgPyAnZjMyJyA6IGB2ZWMke2NvbXBvbmVudHN9ZmA7XG4gICAgICBzd2l0Y2ggKGNvbXBvbmVudHMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBgJHtkYXRhVHlwZX0oJHtmMzJUeXBlfShzY2FsZS4ke2luZGV4fSkpYDtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiBgdmVjMjwke2RhdGFUeXBlfT4oJHtmMzJUeXBlfShzY2FsZVswXS4ke2luZGV4fSwgc2NhbGVbMV0uJHtpbmRleH0pKWA7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gYHZlYzQ8JHtkYXRhVHlwZX0+KCR7ZjMyVHlwZX0oc2NhbGVbMF0uJHtpbmRleH0sIHNjYWxlWzFdLiR7aW5kZXh9LCBzY2FsZVsyXS4ke2luZGV4fSwgc2NhbGVbM10uJHtpbmRleH0pKWA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3Qgc3VwcG9ydGVkIGNvbXBvZW50cyAke2NvbXBvbmVudHN9YCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbnB1dEhlbHBlciA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcywgY29tcG9uZW50cyk7XG4gICAgY29uc3Qgb3V0cHV0SGVscGVyID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUsIGNvbXBvbmVudHMpO1xuXG4gICAgcmV0dXJuIGBcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiBpbnB1dCA6IGFycmF5PCR7aW5wdXRIZWxwZXIudHlwZS5zdG9yYWdlfT47XG4gIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZD4gc2NhbGVfaW5wdXQgOiBhcnJheTwke3NjYWxlVHlwZX0+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG91dHB1dCA6IGFycmF5PCR7b3V0cHV0SGVscGVyLnR5cGUuc3RvcmFnZX0+O1xuICBzdHJ1Y3QgVW5pZm9ybXMge0g6IHUzMiwgQyA6IHUzMn07XG4gIEBncm91cCgwKSBAYmluZGluZygzKSB2YXI8dW5pZm9ybT4gdW5pZm9ybXM6IFVuaWZvcm1zO1xuXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgIGxldCBjdXJyZW50X2ltYWdlX251bWJlciA9IGdsb2JhbF9pZHggLyAodW5pZm9ybXMuQyAqIHVuaWZvcm1zLkgpO1xuICAgIGxldCBjdXJyZW50X2NoYW5uZWxfbnVtYmVyID0gZ2xvYmFsX2lkeCAlIHVuaWZvcm1zLkM7XG5cbiAgICBsZXQgc2NhbGVfb2Zmc2V0ID0gY3VycmVudF9pbWFnZV9udW1iZXIgKiB1bmlmb3Jtcy5DICsgY3VycmVudF9jaGFubmVsX251bWJlcjtcbiAgICBsZXQgc2NhbGUgPSBzY2FsZV9pbnB1dFtzY2FsZV9vZmZzZXRdO1xuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGZtYShpbnB1dFtnbG9iYWxfaWR4XSwgJHtzY2FsZURhdGEoMCl9LCAke3NjYWxlRGF0YSgxKX0pO1xuICB9YDtcbiAgfTtcbiAgY29udGV4dC5jb21wdXRlKFxuICAgIHtcbiAgICAgIG5hbWU6ICdJbnN0YW5jZU5vcm1hbGl6YXRpb25OSFdDJyxcbiAgICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2NvbXBvbmVudHN9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcbiAgICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH1dLFxuICAgICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICAgIH0pLFxuICAgICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIH0sXG4gICAgeyBpbnB1dHM6IFtpbnB1dHNbMF0sIGNoYW5uZWxTY2FsZVNoaWZ0XSB9LFxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IGluc3RhbmNlTm9ybSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogSW5zdGFuY2VOb3JtQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAoYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJykge1xuICAgIGNyZWF0ZUluc3RhbmNlTm9ybU5IV0NQcm9ncmFtSW5mbyhjb250ZXh0LCBjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgY3JlYXRlSW5zdGFuY2VOb3JtUHJvZ3JhbUluZm8oY29udGV4dCwgY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICB9XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3ksIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBjYXN0VG9GMzIsXG4gIGZpbGxWZWN0b3IsXG4gIGdldE1heENvbXBvbmVudHMsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIHN1bVZlY3RvcixcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi9jb21tb24nO1xuXG5pbnRlcmZhY2UgTGF5ZXJOb3JtQXR0cmlidXRlcyB7XG4gIHNpbXBsaWZpZWQ6IGJvb2xlYW47XG4gIGF4aXM6IG51bWJlcjtcbiAgZXBzaWxvbjogbnVtYmVyO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcignbGF5ZXJOb3JtIHJlcXVpcmVzIGF0IGxlYXN0IDIgaW5wdXRzLicpO1xuICB9XG59O1xuXG5jb25zdCBjcmVhdGVMYXllck5vcm1Qcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IExheWVyTm9ybUF0dHJpYnV0ZXMsXG4gIG91dHB1dENvdW50OiBudW1iZXIsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IHNpbXBsaWZpZWQgPSBhdHRyaWJ1dGVzLnNpbXBsaWZpZWQ7XG5cbiAgY29uc3QgeFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IHNjYWxlID0gaW5wdXRzWzFdO1xuICBjb25zdCBiaWFzID0gIXNpbXBsaWZpZWQgJiYgaW5wdXRzWzJdO1xuXG4gIGNvbnN0IG91dHB1dFNoYXBlID0geFNoYXBlO1xuICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCB4U2hhcGUubGVuZ3RoKTtcbiAgY29uc3Qgbm9ybUNvdW50ID0gU2hhcGVVdGlsLnNpemVUb0RpbWVuc2lvbih4U2hhcGUsIGF4aXMpO1xuICBjb25zdCBub3JtU2l6ZSA9IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbih4U2hhcGUsIGF4aXMpO1xuXG4gIGNvbnN0IHNjYWxlU2l6ZSA9IFNoYXBlVXRpbC5zaXplKHNjYWxlLmRpbXMpO1xuICBjb25zdCBiaWFzU2l6ZSA9IGJpYXMgPyBTaGFwZVV0aWwuc2l6ZShiaWFzLmRpbXMpIDogMDtcbiAgaWYgKHNjYWxlU2l6ZSAhPT0gbm9ybVNpemUgfHwgKGJpYXMgJiYgYmlhc1NpemUgIT09IG5vcm1TaXplKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgU2l6ZSBvZiBYLnNoYXBlKClbYXhpczpdID09ICR7bm9ybVNpemV9LlxuICAgICAgIFNpemUgb2Ygc2NhbGUgYW5kIGJpYXMgKGlmIHByb3ZpZGVkKSBtdXN0IG1hdGNoIHRoaXMuXG4gICAgICAgR290IHNjYWxlIHNpemUgb2YgJHtzY2FsZVNpemV9IGFuZCBiaWFzIHNpemUgb2YgJHtiaWFzU2l6ZX1gKTtcbiAgfVxuXG4gIGNvbnN0IG1lYW5JbnZTdGREZXZEaW06IG51bWJlcltdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgeFNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGkgPCBheGlzKSB7XG4gICAgICBtZWFuSW52U3RkRGV2RGltLnB1c2goeFNoYXBlW2ldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVhbkludlN0ZERldkRpbS5wdXNoKDEpO1xuICAgIH1cbiAgfVxuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhub3JtU2l6ZSk7XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWyd0eXBlJywgJ3R5cGUnXTtcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBub3JtQ291bnQgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBub3JtU2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBNYXRoLmZsb29yKG5vcm1TaXplIC8gY29tcG9uZW50cykgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBhdHRyaWJ1dGVzLmVwc2lsb24gfSxcbiAgXTtcbiAgaWYgKGJpYXMpIHtcbiAgICBpbnB1dERlcGVuZGVuY2llcy5wdXNoKCd0eXBlJyk7XG4gIH1cbiAgY29uc3QgaGFzTWVhbkRhdGFPdXRwdXQgPSBvdXRwdXRDb3VudCA+IDE7XG4gIGNvbnN0IGhhc0ludlN0ZE91dHB1dCA9IG91dHB1dENvdW50ID4gMjtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xuICAgIGNvbnN0IHZhcmlhYmxlcyA9IFtcbiAgICAgIGlucHV0VmFyaWFibGUoJ3gnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLCBjb21wb25lbnRzKSxcbiAgICAgIGlucHV0VmFyaWFibGUoJ3NjYWxlJywgc2NhbGUuZGF0YVR5cGUsIHNjYWxlLmRpbXMsIGNvbXBvbmVudHMpLFxuICAgIF07XG4gICAgaWYgKGJpYXMpIHtcbiAgICAgIHZhcmlhYmxlcy5wdXNoKGlucHV0VmFyaWFibGUoJ2JpYXMnLCBiaWFzLmRhdGFUeXBlLCBiaWFzLmRpbXMsIGNvbXBvbmVudHMpKTtcbiAgICB9XG4gICAgdmFyaWFibGVzLnB1c2gob3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUsIGNvbXBvbmVudHMpKTtcbiAgICBpZiAoaGFzTWVhbkRhdGFPdXRwdXQpIHtcbiAgICAgIHZhcmlhYmxlcy5wdXNoKG91dHB1dFZhcmlhYmxlKCdtZWFuX2RhdGFfb3V0cHV0JywgRGF0YVR5cGUuZmxvYXQsIG1lYW5JbnZTdGREZXZEaW0pKTtcbiAgICB9XG4gICAgaWYgKGhhc0ludlN0ZE91dHB1dCkge1xuICAgICAgdmFyaWFibGVzLnB1c2gob3V0cHV0VmFyaWFibGUoJ2ludl9zdGRfb3V0cHV0JywgRGF0YVR5cGUuZmxvYXQsIG1lYW5JbnZTdGREZXZEaW0pKTtcbiAgICB9XG5cbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdub3JtX2NvdW50JywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ25vcm1fc2l6ZScsIHR5cGU6ICdmMzInIH0sXG4gICAgICB7IG5hbWU6ICdub3JtX3NpemVfdmVjdG9yaXplZCcsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdlcHNpbG9uJywgdHlwZTogJ2YzMicgfSxcbiAgICBdO1xuICAgIHJldHVybiBgXG4gICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4udmFyaWFibGVzKX1cbiAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMubm9ybV9jb3VudCcpfVxuICAgIGxldCBvZmZzZXQgPSBnbG9iYWxfaWR4ICogdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7XG4gICAgdmFyIG1lYW5fdmVjdG9yID0gJHtmaWxsVmVjdG9yKCdmMzInLCBjb21wb25lbnRzKX07XG4gICAgdmFyIG1lYW5fc3F1YXJlX3ZlY3RvciA9ICR7ZmlsbFZlY3RvcignZjMyJywgY29tcG9uZW50cyl9O1xuXG4gICAgZm9yICh2YXIgaDogdTMyID0gMHU7IGggPCB1bmlmb3Jtcy5ub3JtX3NpemVfdmVjdG9yaXplZDsgaCsrKSB7XG4gICAgICBsZXQgdmFsdWUgPSAke2Nhc3RUb0YzMihkYXRhVHlwZSwgY29tcG9uZW50cywgJ3hbaCArIG9mZnNldF0nKX07XG4gICAgICBtZWFuX3ZlY3RvciArPSB2YWx1ZTtcbiAgICAgIG1lYW5fc3F1YXJlX3ZlY3RvciArPSB2YWx1ZSAqIHZhbHVlO1xuICAgIH1cbiAgICBsZXQgbWVhbiA9ICR7c3VtVmVjdG9yKCdtZWFuX3ZlY3RvcicsIGNvbXBvbmVudHMpfSAvIHVuaWZvcm1zLm5vcm1fc2l6ZTtcbiAgICBsZXQgaW52X3N0ZF9kZXYgPSBpbnZlcnNlU3FydCgke3N1bVZlY3RvcignbWVhbl9zcXVhcmVfdmVjdG9yJywgY29tcG9uZW50cyl9IC8gdW5pZm9ybXMubm9ybV9zaXplICR7XG4gICAgICBzaW1wbGlmaWVkID8gJycgOiAnLSBtZWFuICogbWVhbidcbiAgICB9ICsgdW5pZm9ybXMuZXBzaWxvbik7XG5cbiAgICBmb3IgKHZhciBqOiB1MzIgPSAwOyBqIDwgdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7IGorKykge1xuICAgICAgbGV0IGYzMmlucHV0ID0gJHtjYXN0VG9GMzIoZGF0YVR5cGUsIGNvbXBvbmVudHMsICd4W2ogKyBvZmZzZXRdJyl9O1xuICAgICAgbGV0IGYzMnNjYWxlID0gJHtjYXN0VG9GMzIoZGF0YVR5cGUsIGNvbXBvbmVudHMsICdzY2FsZVtqXScpfTtcbiAgICAgIG91dHB1dFtqICsgb2Zmc2V0XSA9ICR7dmFyaWFibGVzWzBdLnR5cGUudmFsdWV9KChmMzJpbnB1dCAke3NpbXBsaWZpZWQgPyAnJyA6ICctIG1lYW4nfSkgKiBpbnZfc3RkX2RldiAqIGYzMnNjYWxlXG4gICAgICAgICR7YmlhcyA/IGArICR7Y2FzdFRvRjMyKGRhdGFUeXBlLCBjb21wb25lbnRzLCAnYmlhc1tqXScpfWAgOiAnJ31cbiAgICAgICk7XG4gICAgfVxuXG4gICAgJHtoYXNNZWFuRGF0YU91dHB1dCA/ICdtZWFuX2RhdGFfb3V0cHV0W2dsb2JhbF9pZHhdID0gbWVhbicgOiAnJ307XG4gICAgJHtoYXNJbnZTdGRPdXRwdXQgPyAnaW52X3N0ZF9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnZfc3RkX2RldicgOiAnJ307XG4gIH1gO1xuICB9O1xuICBjb25zdCBvdXRwdXRzID0gW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV07XG4gIGlmIChoYXNNZWFuRGF0YU91dHB1dCkge1xuICAgIG91dHB1dHMucHVzaCh7IGRpbXM6IG1lYW5JbnZTdGREZXZEaW0sIGRhdGFUeXBlOiBEYXRhVHlwZS5mbG9hdCB9KTtcbiAgfVxuICBpZiAoaGFzSW52U3RkT3V0cHV0KSB7XG4gICAgb3V0cHV0cy5wdXNoKHsgZGltczogbWVhbkludlN0ZERldkRpbSwgZGF0YVR5cGU6IERhdGFUeXBlLmZsb2F0IH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnTGF5ZXJOb3JtYWxpemF0aW9uJyxcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHtjb21wb25lbnRzfTske291dHB1dENvdW50fTske3NpbXBsaWZpZWR9YCwgaW5wdXREZXBlbmRlbmNpZXMgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0cyxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG5vcm1Db3VudCAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBsYXllck5vcm0gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IExheWVyTm9ybUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlTGF5ZXJOb3JtUHJvZ3JhbUluZm8oY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMsIGNvbnRleHQub3V0cHV0Q291bnQpKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXG4gIGdldE1heENvbXBvbmVudHMsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZSxcbn0gZnJvbSAnLi9jb21tb24nO1xuXG4vLyAgVE9ETyBzdXBwb3J0IHF1YW50aXphdGlvbiBiaXRzIG5vdCBlcXVhbCB0byA0XG5leHBvcnQgaW50ZXJmYWNlIE1hdE11bE5CaXRzQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIGs6IG51bWJlcjtcbiAgbjogbnVtYmVyO1xuICBhY2N1cmFjeUxldmVsOiBudW1iZXI7XG4gIGJpdHM6IG51bWJlcjtcbiAgYmxvY2tTaXplOiBudW1iZXI7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBNYXRNdWxOQml0c0F0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgaWYgKGlucHV0cy5sZW5ndGggPCAzIHx8IGlucHV0cy5sZW5ndGggPiA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXRNdWxOQml0cyByZXF1aXJlcyAzIG9yIDQgaW5wdXRzJyk7XG4gIH1cbiAgY29uc3QgYSA9IGlucHV0c1swXTtcbiAgY29uc3QgYVJhbmsgPSBhLmRpbXMubGVuZ3RoO1xuICBpZiAoYS5kaW1zW2FSYW5rIC0gMV0gIT09IGF0dHJpYnV0ZXMuaykge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGxhc3QgZGltIG9mIGlucHV0IHNoYXBlIGRvZXMgbm90IG1hdGNoIHRoZSBrIHZhbHVlJyk7XG4gIH1cbiAgY29uc3QgbkJsb2Nrc1BlckNvbCA9IE1hdGguZmxvb3IoKGF0dHJpYnV0ZXMuayArIGF0dHJpYnV0ZXMuYmxvY2tTaXplIC0gMSkgLyBhdHRyaWJ1dGVzLmJsb2NrU2l6ZSk7XG4gIGNvbnN0IGJsb2JTaXplID0gKGF0dHJpYnV0ZXMuYmxvY2tTaXplIC8gOCkgKiBhdHRyaWJ1dGVzLmJpdHM7XG4gIGNvbnN0IGIgPSBpbnB1dHNbMV07XG4gIGlmICghU2hhcGVVdGlsLmFyZUVxdWFsKGIuZGltcywgW2F0dHJpYnV0ZXMubiwgbkJsb2Nrc1BlckNvbCwgYmxvYlNpemVdKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNlY29uZCBpbnB1dHMgbXVzdCBiZSAzRCB0ZW5zb3Igd2l0aCBzaGFwZSBOIFggbkJsb2Nrc1BlckNvbCBYIGJsb2JTaXplJyk7XG4gIH1cbiAgY29uc3Qgc2NhbGVzID0gaW5wdXRzWzJdO1xuICBjb25zdCBzY2FsZXNTaGFwZSA9IHNjYWxlcy5kaW1zO1xuICBpZiAoU2hhcGVVdGlsLnNpemUoc2NhbGVzU2hhcGUpICE9PSBhdHRyaWJ1dGVzLm4gKiBuQmxvY2tzUGVyQ29sKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzY2FsZXMgaW5wdXQgc2l6ZSBlcnJvci4nKTtcbiAgfVxuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gNCkge1xuICAgIGNvbnN0IHplcm9Qb2ludHMgPSBpbnB1dHNbM107XG4gICAgY29uc3QgemVyb1BvaW50c1NoYXBlID0gemVyb1BvaW50cy5kaW1zO1xuICAgIGNvbnN0IGV4cGVjdGVkWmVyb1BvaW50c1NpemUgPVxuICAgICAgYXR0cmlidXRlcy5iaXRzID4gNCA/IGF0dHJpYnV0ZXMubiAqIG5CbG9ja3NQZXJDb2wgOiBhdHRyaWJ1dGVzLm4gKiBNYXRoLmZsb29yKChuQmxvY2tzUGVyQ29sICsgMSkgLyAyKTtcbiAgICBpZiAoU2hhcGVVdGlsLnNpemUoemVyb1BvaW50c1NoYXBlKSAhPT0gZXhwZWN0ZWRaZXJvUG9pbnRzU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd6ZXJvUG9pbnRzIGlucHV0IHNpemUgZXJyb3IuJyk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlTWF0TXVsTkJpdHNQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IE1hdE11bE5CaXRzQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBhUmFuayA9IGlucHV0U2hhcGUubGVuZ3RoO1xuICBjb25zdCBkaW1BT3V0ZXIgPSBpbnB1dFNoYXBlW2FSYW5rIC0gMl07XG4gIGNvbnN0IGRpbUlubmVyID0gYXR0cmlidXRlcy5rO1xuICBjb25zdCBkaW1CT3V0ZXIgPSBhdHRyaWJ1dGVzLm47XG4gIGNvbnN0IGJhdGNoRGltcyA9IGlucHV0U2hhcGUuc2xpY2UoMCwgYVJhbmsgLSAyKTtcbiAgY29uc3QgYmF0Y2hTaXplID0gU2hhcGVVdGlsLnNpemUoYmF0Y2hEaW1zKTtcbiAgY29uc3QgYmxvYlNpemUgPSBpbnB1dHNbMV0uZGltc1syXTtcbiAgY29uc3QgYmxvYlNpemVJbldvcmRzID0gYmxvYlNpemUgLyA0O1xuICBjb25zdCBkYXRhVHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcbiAgY29uc3QgYUNvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKGF0dHJpYnV0ZXMuayk7XG4gIGNvbnN0IGJDb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhibG9iU2l6ZUluV29yZHMpO1xuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhkaW1CT3V0ZXIpO1xuICBjb25zdCBvdXRwdXRTaGFwZSA9IGJhdGNoRGltcy5jb25jYXQoW2RpbUFPdXRlciwgZGltQk91dGVyXSk7XG4gIGNvbnN0IG91dHB1dE51bWJlciA9IGRpbUFPdXRlciA+IDEgJiYgKGRpbUJPdXRlciAvIGNvbXBvbmVudHMpICUgMiA9PT0gMCA/IDIgOiAxO1xuICBjb25zdCBkaXNwYXRjaFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyBjb21wb25lbnRzIC8gb3V0cHV0TnVtYmVyO1xuXG4gIGNvbnN0IHdvcmtncm91cFNpemUgPSA2NDtcblxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXTtcbiAgY29uc3QgaW5wdXRTaGFwZVRlbXAgPSBbYmF0Y2hTaXplLCBkaW1BT3V0ZXIsIGRpbUlubmVyIC8gYUNvbXBvbmVudHNdO1xuICBjb25zdCBiU2hhcGUgPSBTaGFwZVV0aWwuY29udmVydFNoYXBlKGlucHV0c1sxXS5kaW1zKS5zbGljZSgpO1xuICBiU2hhcGUuc3BsaWNlKC0xLCAxLCBibG9iU2l6ZUluV29yZHMgLyBiQ29tcG9uZW50cyk7XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0U2hhcGVUZW1wKSk7XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGJTaGFwZSkpO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dHNbMl0uZGltcykpO1xuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gNCkge1xuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKFNoYXBlVXRpbC5jb252ZXJ0U2hhcGUoaW5wdXRzWzNdLmRpbXMpKSk7XG4gIH1cbiAgY29uc3Qgb3V0cHV0U2hhcGVUZW1wID0gW2JhdGNoU2l6ZSwgZGltQU91dGVyLCBkaW1CT3V0ZXIgLyBjb21wb25lbnRzXTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMob3V0cHV0U2hhcGVUZW1wKSk7XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXRTaGFwZVRlbXAubGVuZ3RoO1xuICAgIGNvbnN0IGEgPSBpbnB1dFZhcmlhYmxlKCdhJywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dFJhbmssIGFDb21wb25lbnRzKTtcbiAgICBjb25zdCBiID0gaW5wdXRWYXJpYWJsZSgnYicsIERhdGFUeXBlLnVpbnQzMiwgYlNoYXBlLmxlbmd0aCwgYkNvbXBvbmVudHMpO1xuICAgIGNvbnN0IHNjYWxlcyA9IGlucHV0VmFyaWFibGUoJ3NjYWxlcycsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoKTtcbiAgICBjb25zdCBpbnB1dFZhcmlhYmxlcyA9IFthLCBiLCBzY2FsZXNdO1xuICAgIGNvbnN0IHplcm9Qb2ludHMgPVxuICAgICAgaW5wdXRzLmxlbmd0aCA9PT0gNCA/IGlucHV0VmFyaWFibGUoJ3plcm9fcG9pbnRzJywgRGF0YVR5cGUudWludDMyLCBpbnB1dHNbM10uZGltcy5sZW5ndGgpIDogdW5kZWZpbmVkO1xuICAgIGlmICh6ZXJvUG9pbnRzKSB7XG4gICAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKHplcm9Qb2ludHMpO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXRSYW5rID0gb3V0cHV0U2hhcGVUZW1wLmxlbmd0aDtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRSYW5rLCBjb21wb25lbnRzKTtcbiAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclR5cGVUb1dzZ2xTdG9yYWdlVHlwZShpbnB1dHNbMF0uZGF0YVR5cGUpO1xuXG4gICAgY29uc3QgcURxRGF0YVR5cGUgPSAoKCkgPT4ge1xuICAgICAgc3dpdGNoIChhQ29tcG9uZW50cykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIGBhcnJheTwke2RhdGFUeXBlfSwgOD5gO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIGBtYXQ0eDI8JHtkYXRhVHlwZX0+YDtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiBgbWF0Mng0PCR7ZGF0YVR5cGV9PmA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2FDb21wb25lbnRzfS1jb21wb25lbnQgaXMgbm90IHN1cHBvcnRlZC5gKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuXG4gICAgY29uc3QgcHJvY2Vzc09uZVdvcmQgPSAoKTogc3RyaW5nID0+IHtcbiAgICAgIGxldCBjYWxjU3RyID0gYFxuICAgICAgICAgIC8vIHJldXNlIGEgZGF0YVxuICAgICAgICAgICAgdmFyIGlucHV0X29mZnNldCA9ICR7YS5pbmRpY2VzVG9PZmZzZXQoYCR7YS50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIHdvcmRfb2Zmc2V0KWApfTtcbiAgICAgICAgICAgIHZhciBhX2RhdGE6ICR7cURxRGF0YVR5cGV9O1xuICAgICAgICAgICAgZm9yICh2YXIgajogdTMyID0gMDsgaiA8ICR7OCAvIGFDb21wb25lbnRzfTsgaisrKSB7XG4gICAgICAgICAgICAgIGFfZGF0YVtqXSA9ICR7YS5nZXRCeU9mZnNldCgnaW5wdXRfb2Zmc2V0Jyl9O1xuICAgICAgICAgICAgICBpbnB1dF9vZmZzZXQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBgO1xuICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjb21wb25lbnRzICogb3V0cHV0TnVtYmVyOyBjKyspIHtcbiAgICAgICAgY2FsY1N0ciArPSBgXG4gICAgICAgICAgICBiX3ZhbHVlID0gJHtiQ29tcG9uZW50cyA9PT0gMSA/IGBiJHtjfV9kYXRhYCA6IGBiJHtjfV9kYXRhW2ldYH07XG4gICAgICAgICAgICBiX3ZhbHVlX2xvd2VyID0gdW5wYWNrNHhVOChiX3ZhbHVlICYgYl9tYXNrKTtcbiAgICAgICAgICAgIGJfdmFsdWVfdXBwZXIgPSB1bnBhY2s0eFU4KChiX3ZhbHVlID4+IDQpICYgYl9tYXNrKTtcbiAgICAgICAgICAgIGJfcXVhbnRpemVkX3ZhbHVlcyA9ICR7cURxRGF0YVR5cGV9KCR7QXJyYXkuZnJvbShcbiAgICAgICAgICAgICAgeyBsZW5ndGg6IDQgfSxcbiAgICAgICAgICAgICAgKF8sIGkpID0+IGAke2RhdGFUeXBlfShiX3ZhbHVlX2xvd2VyWyR7aX1dKSwgJHtkYXRhVHlwZX0oYl92YWx1ZV91cHBlclske2l9XSlgLFxuICAgICAgICAgICAgKS5qb2luKCcsICcpfSk7XG4gICAgICAgICAgICBiX2RlcXVhbnRpemVkX3ZhbHVlcyA9ICR7KCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGFDb21wb25lbnRzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3FEcURhdGFUeXBlfSgke0FycmF5LmZyb20oXG4gICAgICAgICAgICAgICAgICB7IGxlbmd0aDogOCB9LFxuICAgICAgICAgICAgICAgICAgKF8sIGkpID0+IGAoYl9xdWFudGl6ZWRfdmFsdWVzWyR7aX1dIC0gJHt6ZXJvUG9pbnRzID8gYHplcm9fcG9pbnQke2N9YCA6ICd6ZXJvX3BvaW50J30pICogc2NhbGUke2N9YCxcbiAgICAgICAgICAgICAgICApLmpvaW4oJywgJyl9KTtgO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBgKGJfcXVhbnRpemVkX3ZhbHVlcyAtICR7cURxRGF0YVR5cGV9KCR7QXJyYXkoOClcbiAgICAgICAgICAgICAgICAgIC5maWxsKGAke3plcm9Qb2ludHMgPyBgemVyb19wb2ludCR7Y31gIDogJ3plcm9fcG9pbnQnfWApXG4gICAgICAgICAgICAgICAgICAuam9pbignLCcpfSkpICogc2NhbGUke2N9O2A7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCl9O1xuICAgICAgICAgICAgd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZC54ICogJHtvdXRwdXROdW1iZXJ9ICsgJHtNYXRoLmZsb29yKGMgLyBjb21wb25lbnRzKX1dJHtjb21wb25lbnRzID4gMSA/IGBbJHtjICUgY29tcG9uZW50c31dYCA6ICcnfSArPSAke0FycmF5LmZyb20oXG4gICAgICAgICAgICAgIHsgbGVuZ3RoOiA4IC8gYUNvbXBvbmVudHMgfSxcbiAgICAgICAgICAgICAgKF8sIGkpID0+XG4gICAgICAgICAgICAgICAgYCR7XG4gICAgICAgICAgICAgICAgICBhQ29tcG9uZW50cyA9PT0gMVxuICAgICAgICAgICAgICAgICAgICA/IGBhX2RhdGFbJHtpfV0gKiBiX2RlcXVhbnRpemVkX3ZhbHVlc1ske2l9XWBcbiAgICAgICAgICAgICAgICAgICAgOiBgZG90KGFfZGF0YVske2l9XSwgYl9kZXF1YW50aXplZF92YWx1ZXNbJHtpfV0pYFxuICAgICAgICAgICAgICAgIH1gLFxuICAgICAgICAgICAgKS5qb2luKCcgKyAnKX07XG4gICAgICAgICAgYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWxjU3RyO1xuICAgIH07XG4gICAgY29uc3QgcHJlcGFyZVNjYWxlQW5kWmVyb1BvaW50ID0gKCk6IHN0cmluZyA9PiB7XG4gICAgICBsZXQgY2FsY1N0ciA9IGBcbiAgICAgICAgICAgIHZhciBjb2xfaW5kZXggPSBjb2wgKiAke2NvbXBvbmVudHN9O1xuICAgICAgICAgICAgJHtcbiAgICAgICAgICAgICAgemVyb1BvaW50c1xuICAgICAgICAgICAgICAgID8gYFxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYnl0ZXNfcGVyX2NvbCA9IChuQmxvY2tzUGVyQ29sICsgMSkgLyAyO1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfYnl0ZV9jb3VudDogdTMyO1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfd29yZF9pbmRleDogdTMyO1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQ6IHUzMjtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X25pYmJsZV9vZmZzZXQ6IHUzMiA9IGJsb2NrICYgMHgxdTtcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0OiB1MzI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF93b3JkOiB1MzI7YFxuICAgICAgICAgICAgICAgIDogYFxuICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgemVybyBwb2ludCBpcyA4IGZvciB1bnNpZ25lZCA0LWJpdCBxdWFudGl6YXRpb24uXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludCA9ICR7ZGF0YVR5cGV9KCR7OC4wfSk7YFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYDtcbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY29tcG9uZW50cyAqIG91dHB1dE51bWJlcjsgYysrKSB7XG4gICAgICAgIGNhbGNTdHIgKz0gYFxuICAgICAgICAgICAgbGV0IHNjYWxlJHtjfSA9ICR7c2NhbGVzLmdldEJ5T2Zmc2V0KGBjb2xfaW5kZXggKiBuQmxvY2tzUGVyQ29sICsgYmxvY2tgKX07XG4gICAgICAgICAgICAke1xuICAgICAgICAgICAgICB6ZXJvUG9pbnRzXG4gICAgICAgICAgICAgICAgPyBgXG4gICAgICAgICAgICB6ZXJvX3BvaW50X2J5dGVfY291bnQgPSBjb2xfaW5kZXggKiB6ZXJvX3BvaW50X2J5dGVzX3Blcl9jb2wgKyAoYmxvY2sgPj4gMHgxdSk7XG4gICAgICAgICAgICB6ZXJvX3BvaW50X3dvcmRfaW5kZXggPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgPj4gMHgydTtcbiAgICAgICAgICAgIHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgJiAweDN1O1xuICAgICAgICAgICAgemVyb19wb2ludF9iaXRzX29mZnNldCA9ICh6ZXJvX3BvaW50X2J5dGVfb2Zmc2V0IDw8IDMpICsgKHplcm9fcG9pbnRfbmliYmxlX29mZnNldCA8PCAyKTtcbiAgICAgICAgICAgIHplcm9fcG9pbnRfd29yZCA9ICR7emVyb1BvaW50cy5nZXRCeU9mZnNldCgnemVyb19wb2ludF93b3JkX2luZGV4Jyl9ID4+IHplcm9fcG9pbnRfYml0c19vZmZzZXQ7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludCR7Y30gPSAke2RhdGFUeXBlfSgoemVyb19wb2ludF93b3JkKSAmIDB4RnUpO2BcbiAgICAgICAgICAgICAgICA6ICcnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2xfaW5kZXggKz0gMTtgO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbGNTdHI7XG4gICAgfTtcbiAgICBjb25zdCBwcmVwYXJlQkRhdGEgPSAoKTogc3RyaW5nID0+IHtcbiAgICAgIGxldCBjYWxjU3RyID0gYGNvbF9pbmRleCA9IGNvbCAqICR7Y29tcG9uZW50c307YDtcbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY29tcG9uZW50cyAqIG91dHB1dE51bWJlcjsgYysrKSB7XG4gICAgICAgIGNhbGNTdHIgKz0gYFxuICAgICAgICAgICAgbGV0IGIke2N9X2RhdGEgPSAke2IuZ2V0QnlJbmRpY2VzKGAke2IudHlwZS5pbmRpY2VzfShjb2xfaW5kZXgsIGJsb2NrLCB3b3JkKWApfTtcbiAgICAgICAgICAgIGNvbF9pbmRleCArPSAxO2A7XG4gICAgICB9XG4gICAgICBjYWxjU3RyICs9IGBcbiAgICAgICAgICAgIHZhciBiX3ZhbHVlOiB1MzI7XG4gICAgICAgICAgICBsZXQgYl9tYXNrOiB1MzIgPSAweDBGMEYwRjBGdTtcbiAgICAgICAgICAgIHZhciBiX3ZhbHVlX2xvd2VyOiB2ZWM0PHUzMj47XG4gICAgICAgICAgICB2YXIgYl92YWx1ZV91cHBlcjogdmVjNDx1MzI+O1xuICAgICAgICAgICAgdmFyIGJfcXVhbnRpemVkX3ZhbHVlczogJHtxRHFEYXRhVHlwZX07XG4gICAgICAgICAgICB2YXIgYl9kZXF1YW50aXplZF92YWx1ZXM6ICR7cURxRGF0YVR5cGV9O2A7XG4gICAgICByZXR1cm4gY2FsY1N0cjtcbiAgICB9O1xuICAgIHJldHVybiBgXG4gICAgICAgIHZhcjx3b3JrZ3JvdXA+IHdvcmtncm91cF9zaGFyZWQ6IGFycmF5PCR7b3V0cHV0LnR5cGUudmFsdWV9LCAke291dHB1dE51bWJlciAqIHdvcmtncm91cFNpemV9PjtcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIuZGVjbGFyZVZhcmlhYmxlcyguLi5pbnB1dFZhcmlhYmxlcywgb3V0cHV0KX1cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFt3b3JrZ3JvdXBTaXplLCAxLCAxXSl9XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKGAoZ2xvYmFsX2lkeCAvICR7d29ya2dyb3VwU2l6ZX0pICogJHtvdXRwdXROdW1iZXJ9YCl9O1xuICAgICAgICAgIGxldCBjb2wgPSBvdXRwdXRfaW5kaWNlc1syXTtcbiAgICAgICAgICBsZXQgcm93ID0gb3V0cHV0X2luZGljZXNbMV07XG4gICAgICAgICAgbGV0IGJhdGNoID0gb3V0cHV0X2luZGljZXNbMF07XG4gICAgICAgICAgbGV0IG5CbG9ja3NQZXJDb2wgPSB1bmlmb3Jtcy5iX3NoYXBlWzFdO1xuXG4gICAgICAgICAgZm9yICh2YXIgYmxvY2sgPSBsb2NhbF9pZC54OyBibG9jayA8IG5CbG9ja3NQZXJDb2w7IGJsb2NrICs9ICR7d29ya2dyb3VwU2l6ZX0pIHtcbiAgICAgICAgICAgIC8vcHJvY2VzcyBvbmUgYmxvY2tcbiAgICAgICAgICAgIHZhciB3b3JkX29mZnNldDogdTMyID0gYmxvY2sgKiAke2F0dHJpYnV0ZXMuYmxvY2tTaXplIC8gYUNvbXBvbmVudHN9O1xuICAgICAgICAgICAgJHtwcmVwYXJlU2NhbGVBbmRaZXJvUG9pbnQoKX1cbiAgICAgICAgICAgIGZvciAodmFyIHdvcmQ6IHUzMiA9IDA7IHdvcmQgPCAke2Jsb2JTaXplSW5Xb3Jkc307IHdvcmQgKz0gJHtiQ29tcG9uZW50c30pIHtcbiAgICAgICAgICAgICAgJHtwcmVwYXJlQkRhdGEoKX1cbiAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7YkNvbXBvbmVudHN9OyBpKyspIHtcbiAgICAgICAgICAgICAgICAke3Byb2Nlc3NPbmVXb3JkKCl9XG4gICAgICAgICAgICAgICAgd29yZF9vZmZzZXQgKz0gJHs4IC8gYUNvbXBvbmVudHN9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAgIGlmIChsb2NhbF9pZC54IDwgJHtvdXRwdXROdW1iZXJ9KSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0X3ZhbHVlOiAke291dHB1dC50eXBlLnZhbHVlfSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgdmFyIHdvcmtncm91cF9zaGFyZWRfb2Zmc2V0OiB1MzIgPSBsb2NhbF9pZC54O1xuICAgICAgICAgICAgZm9yICh2YXIgYjogdTMyID0gMHU7IGIgPCAke3dvcmtncm91cFNpemV9dTsgYisrKSB7XG4gICAgICAgICAgICAgIG91dHB1dF92YWx1ZSArPSB3b3JrZ3JvdXBfc2hhcmVkW3dvcmtncm91cF9zaGFyZWRfb2Zmc2V0XTtcbiAgICAgICAgICAgICAgd29ya2dyb3VwX3NoYXJlZF9vZmZzZXQgKz0gJHtvdXRwdXROdW1iZXJ9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHtvdXRwdXQuc2V0QnlJbmRpY2VzKGAke291dHB1dC50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIGNvbCArIGxvY2FsX2lkLngpYCwgJ291dHB1dF92YWx1ZScpfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1gO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdNYXRNdWxOQml0cycsXG4gICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgIGhpbnQ6IGAke2F0dHJpYnV0ZXMuYmxvY2tTaXplfTske2F0dHJpYnV0ZXMuYml0c307JHthQ29tcG9uZW50c307JHtiQ29tcG9uZW50c307JHtjb21wb25lbnRzfTske291dHB1dE51bWJlcn07JHt3b3JrZ3JvdXBTaXplfWAsXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogQXJyYXkoaW5wdXRzLmxlbmd0aCkuZmlsbCgncmFuaycpLFxuICAgIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogZGlzcGF0Y2hTaXplIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IG1hdE11bE5CaXRzID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBNYXRNdWxOQml0c0F0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlTWF0TXVsTkJpdHNQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcykpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlTWF0TXVsTkJpdHNBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogTWF0TXVsTkJpdHNBdHRyaWJ1dGVzID0+XG4gIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleShhdHRyaWJ1dGVzIGFzIE9taXQ8TWF0TXVsTkJpdHNBdHRyaWJ1dGVzLCBrZXlvZiBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXk+KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXG4gIGdldEVsZW1lbnRBdCxcbiAgSW5kaWNlc0hlbHBlcixcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgVW5pZm9ybURhdGFFbGVtZW50VHlwZSxcbiAgVW5pZm9ybXNBcnJheVR5cGUsXG59IGZyb20gJy4vY29tbW9uJztcblxuaW50ZXJmYWNlIFBhZEF0dHJpYnV0ZXMge1xuICAvLyAwLWNvbnN0YW50LCAxLXJlZmxlY3QsIDItZWRnZSwgMy13cmFwXG4gIHJlYWRvbmx5IG1vZGU6IG51bWJlcjtcbiAgcmVhZG9ubHkgdmFsdWU6IG51bWJlcjtcbiAgcmVhZG9ubHkgcGFkczogbnVtYmVyW107XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUb28gZmV3IGlucHV0cycpO1xuICB9XG4gIGlmIChpbnB1dHNbMF0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmZsb2F0ICYmIGlucHV0c1swXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuZmxvYXQxNikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgdHlwZSBtdXN0IGJlIGZsb2F0IG9yIGZsb2F0MTYuJyk7XG4gIH1cblxuICBpZiAoaW5wdXRzLmxlbmd0aCA+PSAyKSB7XG4gICAgbGV0IHZhbGlkUGFkcyA9IGlucHV0c1swXS5kaW1zLmxlbmd0aCAqIDIgPT09IGlucHV0c1sxXS5kaW1zWzBdO1xuICAgIGlmIChpbnB1dHMubGVuZ3RoID09PSA0KSB7XG4gICAgICB2YWxpZFBhZHMgPSBpbnB1dHNbM10uZGltc1swXSAqIDIgPT09IGlucHV0c1sxXS5kaW1zWzBdO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkUGFkcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcGFkcyBzaG91bGQgYmUgYSAxRCB0ZW5zb3Igb2Ygc2hhcGUgWzIgKiBpbnB1dF9yYW5rXSBvciBbMiAqIG51bV9heGVzXS4nKTtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IGdldFBhZENvbnN0YW50ID0gKG91dHB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRSYW5rOiBudW1iZXIsIHBhZHNMZW5ndGg6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gIGxldCBibG9jayA9ICcnO1xuICBmb3IgKGxldCBpID0gaW5wdXRSYW5rIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBibG9jayArPSBgXG4gICAgICAgICAgICBrID0gaTMyKCR7b3V0cHV0LmluZGljZXNHZXQoJ2luZGljZXMnLCBpKX0pIC0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnBhZHMnLCBpLCBwYWRzTGVuZ3RoKX07XG4gICAgICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoayA+PSBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCBpLCBpbnB1dFJhbmspfSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gayAqIGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zdHJpZGVzJywgaSwgaW5wdXRSYW5rKX0pO1xuICAgICAgICBgO1xuICB9XG5cbiAgcmV0dXJuIGBcbiAgICAgICAgICB2YWx1ZSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KHVuaWZvcm1zLmNvbnN0YW50X3ZhbHVlKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAke2Jsb2NrfVxuICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgfVxuICAgICAgYDtcbn07XG5cbmNvbnN0IGdldFBhZFJlZmxlY3QgPSAob3V0cHV0OiBJbmRpY2VzSGVscGVyLCBpbnB1dFJhbms6IG51bWJlciwgcGFkc0xlbmd0aDogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgbGV0IGJsb2NrID0gJyc7XG4gIGZvciAobGV0IGkgPSBpbnB1dFJhbmsgLSAxOyBpID49IDA7IC0taSkge1xuICAgIGJsb2NrICs9IGBcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7b3V0cHV0LmluZGljZXNHZXQoJ2luZGljZXMnLCBpKX0pIC0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnBhZHMnLCBpLCBwYWRzTGVuZ3RoKX07XG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBrID0gLWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGxldCBfMm5fMSA9IDIgKiAoaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX0pIC0gMSk7XG4gICAgICAgICAgICAgICAgICBrID0gayAlIF8ybl8xO1xuICAgICAgICAgICAgICAgICAgaWYoayA+PSBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCBpLCBpbnB1dFJhbmspfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgayA9IF8ybl8xIC0gaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc3RyaWRlcycsIGksIGlucHV0UmFuayl9KTtcbiAgICAgICAgICAgIGA7XG4gIH1cblxuICByZXR1cm4gYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke2Jsb2NrfVxuICAgICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcbiAgICAgICAgICBgO1xufTtcblxuY29uc3QgZ2V0UGFkRWRnZSA9IChvdXRwdXQ6IEluZGljZXNIZWxwZXIsIGlucHV0UmFuazogbnVtYmVyLCBwYWRzTGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICBsZXQgYmxvY2sgPSAnJztcbiAgZm9yIChsZXQgaSA9IGlucHV0UmFuayAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgYmxvY2sgKz0gYFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtvdXRwdXQuaW5kaWNlc0dldCgnaW5kaWNlcycsIGkpfSkgLSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucGFkcycsIGksIHBhZHNMZW5ndGgpfTtcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgICAgICAgIGsgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoayA+PSBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCBpLCBpbnB1dFJhbmspfSkpIHtcbiAgICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc2hhcGUnLCBpLCBpbnB1dFJhbmspfSkgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gayAqIGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zdHJpZGVzJywgaSwgaW5wdXRSYW5rKX0pO1xuICAgICAgICAgICAgYDtcbiAgfVxuXG4gIHJldHVybiBgXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAgICR7YmxvY2t9XG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIGA7XG59O1xuXG5jb25zdCBnZXRQYWRXcmFwID0gKG91dHB1dDogSW5kaWNlc0hlbHBlciwgaW5wdXRSYW5rOiBudW1iZXIsIHBhZHNMZW5ndGg6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gIGxldCBibG9jayA9ICcnO1xuICBmb3IgKGxldCBpID0gaW5wdXRSYW5rIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBibG9jayArPSBgXG4gICAgICAgICAgICAgICAgayA9IGkzMigke291dHB1dC5pbmRpY2VzR2V0KCdpbmRpY2VzJywgaSl9KSAtICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5wYWRzJywgaSwgcGFkc0xlbmd0aCl9O1xuICAgICAgICAgICAgICAgIGlmIChrIDwgMCkgIHtcbiAgICAgICAgICAgICAgICAgIGsgKz0gaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX1dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy54X3NoYXBlJywgaSwgaW5wdXRSYW5rKX0pKSB7XG4gICAgICAgICAgICAgICAgICBrIC09IGkzMigke2dldEVsZW1lbnRBdCgndW5pZm9ybXMueF9zaGFwZScsIGksIGlucHV0UmFuayl9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnhfc3RyaWRlcycsIGksIGlucHV0UmFuayl9KTtcbiAgICAgICAgICAgIGA7XG4gIH1cblxuICByZXR1cm4gYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke2Jsb2NrfVxuICAgICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcbiAgICAgICAgICBgO1xufTtcblxuY29uc3QgZ2V0UGFkU25pcHBldCA9IChvdXRwdXQ6IEluZGljZXNIZWxwZXIsIGlucHV0UmFuazogbnVtYmVyLCBhdHRyaWJ1dGVzOiBQYWRBdHRyaWJ1dGVzKTogc3RyaW5nID0+IHtcbiAgc3dpdGNoIChhdHRyaWJ1dGVzLm1vZGUpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gZ2V0UGFkQ29uc3RhbnQob3V0cHV0LCBpbnB1dFJhbmssIGF0dHJpYnV0ZXMucGFkcy5sZW5ndGgpO1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBnZXRQYWRSZWZsZWN0KG91dHB1dCwgaW5wdXRSYW5rLCBhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoKTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZ2V0UGFkRWRnZShvdXRwdXQsIGlucHV0UmFuaywgYXR0cmlidXRlcy5wYWRzLmxlbmd0aCk7XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIGdldFBhZFdyYXAob3V0cHV0LCBpbnB1dFJhbmssIGF0dHJpYnV0ZXMucGFkcy5sZW5ndGgpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbW9kZScpO1xuICB9XG59O1xuXG5jb25zdCBjcmVhdGVQYWRQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogUGFkQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3Qgb3V0cHV0U2hhcGUgPSBTaGFwZVV0aWwucGFkU2hhcGUoaW5wdXRzWzBdLmRpbXMuc2xpY2UoKSwgYXR0cmlidXRlcy5wYWRzKTtcbiAgY29uc3QgaW5wdXREaW1zID0gaW5wdXRzWzBdLmRpbXM7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFtcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IGF0dHJpYnV0ZXMucGFkcyB9LFxuICBdO1xuXG4gIGNvbnN0IGlzVmFsdWVGcm9tSW5wdXQgPSBpbnB1dHMubGVuZ3RoID49IDMgJiYgaW5wdXRzWzJdLmRhdGE7XG4gIGlmIChhdHRyaWJ1dGVzLm1vZGUgPT09IDApIHtcbiAgICBwcm9ncmFtVW5pZm9ybXMucHVzaCh7IHR5cGU6IGlzVmFsdWVGcm9tSW5wdXQgPyBpbnB1dHNbMl0uZGF0YVR5cGUgOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy52YWx1ZSB9KTtcbiAgfVxuXG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1swXS5kaW1zLCBvdXRwdXRTaGFwZSkpO1xuICBjb25zdCBpbnB1dERlcGVuZGVuY2llczogUHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lbXSA9IFsncmFuayddO1xuXG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gICAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCd4JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dERpbXMubGVuZ3RoKTtcbiAgICBjb25zdCBkYXRhVHlwZSA9IGlucHV0LnR5cGUudmFsdWU7XG4gICAgY29uc3QgcGFkU25pcHBldCA9IGdldFBhZFNuaXBwZXQob3V0cHV0LCBpbnB1dERpbXMubGVuZ3RoLCBhdHRyaWJ1dGVzKTtcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdwYWRzJywgdHlwZTogJ2kzMicsIGxlbmd0aDogYXR0cmlidXRlcy5wYWRzLmxlbmd0aCB9LFxuICAgIF07XG4gICAgaWYgKGF0dHJpYnV0ZXMubW9kZSA9PT0gMCkge1xuICAgICAgdW5pZm9ybXMucHVzaCh7IG5hbWU6ICdjb25zdGFudF92YWx1ZScsIHR5cGU6IChpc1ZhbHVlRnJvbUlucHV0ID8gZGF0YVR5cGUgOiAnZjMyJykgYXMgVW5pZm9ybURhdGFFbGVtZW50VHlwZSB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYFxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cbiAgICAgICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0X3NpemUnKX1cblxuICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG5cbiAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR7ZGF0YVR5cGV9KDApO1xuICAgICAgICAgICAgJHtwYWRTbmlwcGV0fVxuICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gICAgICAgIH1gO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1BhZCcsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYCR7YXR0cmlidXRlcy5tb2RlfSR7aXNWYWx1ZUZyb21JbnB1dH1gLCBpbnB1dERlcGVuZGVuY2llcyB9LFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZVBhZEF0dHJpYnV0ZXNGcm9tSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBQYWRBdHRyaWJ1dGVzKTogUGFkQXR0cmlidXRlcyA9PiB7XG4gIGlmIChpbnB1dHMubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IGJpZ0ludDY0UGFkcyA9IGlucHV0c1sxXS5nZXRCaWdJbnQ2NEFycmF5KCk7XG4gICAgY29uc3QgdmFsdWUgPVxuICAgICAgaW5wdXRzLmxlbmd0aCA+PSAzICYmIGlucHV0c1syXS5kYXRhXG4gICAgICAgID8gaW5wdXRzWzJdLmRhdGFUeXBlID09PSBEYXRhVHlwZS5mbG9hdDE2XG4gICAgICAgICAgPyBpbnB1dHNbMl0uZ2V0VWludDE2QXJyYXkoKVswXVxuICAgICAgICAgIDogaW5wdXRzWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdXG4gICAgICAgIDogMC4wO1xuXG4gICAgY29uc3QgaW5wdXRSYW5rID0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoO1xuICAgIGNvbnN0IHVwZGF0ZVBhZHMgPSBuZXcgSW50MzJBcnJheSgyICogaW5wdXRSYW5rKS5maWxsKDApO1xuICAgIGlmIChpbnB1dHMubGVuZ3RoID49IDQpIHtcbiAgICAgIGNvbnN0IGF4ZXMgPSBpbnB1dHNbM10uZ2V0QmlnSW50NjRBcnJheSgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHVwZGF0ZVBhZHNbTnVtYmVyKGF4ZXNbaV0pXSA9IE51bWJlcihiaWdJbnQ2NFBhZHNbaV0pO1xuICAgICAgICB1cGRhdGVQYWRzW051bWJlcihheGVzW2ldKSArIGlucHV0UmFua10gPSBOdW1iZXIoYmlnSW50NjRQYWRzW2kgKyBheGVzLmxlbmd0aF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBiaWdJbnQ2NFBhZHMuZm9yRWFjaCgodiwgaSkgPT4gKHVwZGF0ZVBhZHNbTnVtYmVyKGkpXSA9IE51bWJlcih2KSkpO1xuICAgIH1cblxuICAgIGNvbnN0IHBhZHM6IG51bWJlcltdID0gW107XG4gICAgdXBkYXRlUGFkcy5mb3JFYWNoKCh2KSA9PiBwYWRzLnB1c2godikpO1xuXG4gICAgcmV0dXJuIHsgbW9kZTogYXR0cmlidXRlcy5tb2RlLCB2YWx1ZSwgcGFkcyB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcGFkID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBQYWRBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29uc3QgdXBkYXRlZEF0dHJpYnV0ZXMgPSBjcmVhdGVQYWRBdHRyaWJ1dGVzRnJvbUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVQYWRQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgdXBkYXRlZEF0dHJpYnV0ZXMpLCB7IGlucHV0czogWzBdIH0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgZW52IH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgUG9vbENvbnZVdGlsLCBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5LCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXG4gIGdldEVsZW1lbnRBdCxcbiAgSW5kaWNlc0hlbHBlcixcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbiAgVW5pZm9ybXNBcnJheVR5cGUsXG59IGZyb20gJy4vY29tbW9uJztcblxuLy8gVE9ETzogc3VwcG9ydDpcbi8vIC0gY2VpbF9tb2RlICAgICAgICAgICAgICAgICBcInRlc3RfbWF4cG9vbF8yZF9jZWlsXCJcbi8vIC0gc3RvcmFnZV9vcmRlciAgICAgICAgICAgICBcInRlc3RfbWF4cG9vbF93aXRoX2FyZ21heF8yZF9wcmVjb21wdXRlZF9zdHJpZGVzXCJcbi8vIC0gW01heFBvb2xdIGRpbGF0aW9ucyAgICAgICBcInRlc3RfbWF4cG9vbF8yZF9kaWxhdGlvbnNcIlxuLy8gLSBbTWF4UG9vbF0gb3V0cHV0WzFdICAgICAgIFwidGVzdF9tYXhwb29sX3dpdGhfYXJnbWF4XzJkX3ByZWNvbXB1dGVkX3BhZHNcIlxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoZW52LndlYmdwdS52YWxpZGF0ZUlucHV0Q29udGVudCAmJiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoICE9PSAxKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUG9vbCBvcHMgcmVxdWlyZXMgMSBpbnB1dC4nKTtcbiAgfVxufTtcblxuY29uc3QgZ2V0QWRqdXN0ZWRQb29sQXR0cmlidXRlc0FuZE91dHB1dFNoYXBlID0gPEF0dHJpYnV0ZVR5cGUgZXh0ZW5kcyBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgfCBNYXhQb29sQXR0cmlidXRlcz4oXG4gIGlucHV0OiBUZW5zb3JWaWV3LFxuICBhdHRyaWJ1dGVzOiBBdHRyaWJ1dGVUeXBlLFxuICBpc0dsb2JhbE9wZXJhdG9yOiBib29sZWFuLFxuKTogW0F0dHJpYnV0ZVR5cGUsIG51bWJlcltdXSA9PiB7XG4gIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcbiAgY29uc3QgaW5wdXRTaGFwZUFzQ2hhbm5lbEZpcnN0ID0gaW5wdXQuZGltcy5zbGljZSgpO1xuICBpZiAoaXNDaGFubmVsc0xhc3QpIHtcbiAgICBpbnB1dFNoYXBlQXNDaGFubmVsRmlyc3Quc3BsaWNlKDEsIDAsIGlucHV0U2hhcGVBc0NoYW5uZWxGaXJzdC5wb3AoKSEpOyAvLyBNb3ZlIGNoYW5uZWwgdG8gdGhlIHNlY29uZCBwb3NpdGlvbi5cbiAgfVxuICBjb25zdCBoYXNEaWxhdGlvbnMgPSBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChhdHRyaWJ1dGVzLCAnZGlsYXRpb25zJyk7XG4gIGNvbnN0IGtlcm5lbFNoYXBlID0gYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5zbGljZSgpO1xuICBjb25zdCBzdHJpZGVzID0gYXR0cmlidXRlcy5zdHJpZGVzLnNsaWNlKCk7XG4gIGNvbnN0IGRpbGF0aW9uczogbnVtYmVyW10gPSBoYXNEaWxhdGlvbnMgPyAoYXR0cmlidXRlcyBhcyBNYXhQb29sQXR0cmlidXRlcykuZGlsYXRpb25zLnNsaWNlKCkgOiBbXTtcbiAgY29uc3QgcGFkcyA9IGF0dHJpYnV0ZXMucGFkcy5zbGljZSgpO1xuICBQb29sQ29udlV0aWwuYWRqdXN0UG9vbEF0dHJpYnV0ZXMoaXNHbG9iYWxPcGVyYXRvciwgaW5wdXRTaGFwZUFzQ2hhbm5lbEZpcnN0LCBrZXJuZWxTaGFwZSwgc3RyaWRlcywgZGlsYXRpb25zLCBwYWRzKTtcblxuICBjb25zdCBvdXRwdXRTaGFwZUFzQ2hhbm5lbEZpcnN0ID0gUG9vbENvbnZVdGlsLmNvbXB1dGVQb29sT3V0cHV0U2hhcGUoXG4gICAgaXNHbG9iYWxPcGVyYXRvcixcbiAgICBpbnB1dFNoYXBlQXNDaGFubmVsRmlyc3QsXG4gICAgc3RyaWRlcyxcbiAgICBkaWxhdGlvbnMsXG4gICAga2VybmVsU2hhcGUsXG4gICAgcGFkcyxcbiAgICBhdHRyaWJ1dGVzLmF1dG9QYWQsXG4gICk7XG5cbiAgY29uc3QgbmV3QXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXMpO1xuICBpZiAoaGFzRGlsYXRpb25zKSB7XG4gICAgT2JqZWN0LmFzc2lnbihuZXdBdHRyaWJ1dGVzLCB7IGtlcm5lbFNoYXBlLCBzdHJpZGVzLCBwYWRzLCBkaWxhdGlvbnMsIGNhY2hlS2V5OiBhdHRyaWJ1dGVzLmNhY2hlS2V5IH0pO1xuICB9IGVsc2Uge1xuICAgIE9iamVjdC5hc3NpZ24obmV3QXR0cmlidXRlcywgeyBrZXJuZWxTaGFwZSwgc3RyaWRlcywgcGFkcywgY2FjaGVLZXk6IGF0dHJpYnV0ZXMuY2FjaGVLZXkgfSk7XG4gIH1cbiAgY29uc3Qgb3V0cHV0U2hhcGVBc0NoYW5uZWxMYXN0ID0gb3V0cHV0U2hhcGVBc0NoYW5uZWxGaXJzdC5zbGljZSgpO1xuICBvdXRwdXRTaGFwZUFzQ2hhbm5lbExhc3QucHVzaChvdXRwdXRTaGFwZUFzQ2hhbm5lbExhc3Quc3BsaWNlKDEsIDEpWzBdKTtcbiAgcmV0dXJuIFtuZXdBdHRyaWJ1dGVzLCBpc0NoYW5uZWxzTGFzdCA/IG91dHB1dFNoYXBlQXNDaGFubmVsTGFzdCA6IG91dHB1dFNoYXBlQXNDaGFubmVsRmlyc3RdO1xufTtcblxuY29uc3QgZ2V0VW5pZm9ybUFuZFBhZEluZm8gPSA8QXR0cmlidXRlVHlwZSBleHRlbmRzIEF2ZXJhZ2VQb29sQXR0cmlidXRlcyB8IE1heFBvb2xBdHRyaWJ1dGVzPihcbiAgb3V0cHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBhdHRyaWJ1dGVzOiBBdHRyaWJ1dGVUeXBlLFxuKTogW1Byb2dyYW1Vbmlmb3JtW10sIFVuaWZvcm1zQXJyYXlUeXBlLCBib29sZWFuLCBib29sZWFuLCBib29sZWFuXSA9PiB7XG4gIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gYXR0cmlidXRlcy5mb3JtYXQgPT09ICdOSFdDJztcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgY29uc3Qga2VybmVsU2l6ZSA9IFNoYXBlVXRpbC5zaXplKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUpO1xuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YToga2VybmVsU2l6ZSB9LFxuICBdO1xuICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgeyBuYW1lOiAnb3V0cHV0U2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgeyBuYW1lOiAna2VybmVsU2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gIF07XG4gIGlmIChhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlLmxlbmd0aCA8PSAyKSB7XG4gICAgY29uc3Qga3cgPSBhdHRyaWJ1dGVzLmtlcm5lbFNoYXBlW2F0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoIC0gMV07XG4gICAgY29uc3Qgc3cgPSBhdHRyaWJ1dGVzLnN0cmlkZXNbYXR0cmlidXRlcy5zdHJpZGVzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHB3U3RhcnQgPSBhdHRyaWJ1dGVzLnBhZHNbYXR0cmlidXRlcy5wYWRzLmxlbmd0aCAvIDIgLSAxXTtcbiAgICBjb25zdCBwd0VuZCA9IGF0dHJpYnV0ZXMucGFkc1thdHRyaWJ1dGVzLnBhZHMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgcHdTdGFydEVuZE5vdFplcm8gPSAhIShwd1N0YXJ0ICsgcHdFbmQpO1xuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKFxuICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGt3IH0sXG4gICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogc3cgfSxcbiAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwd1N0YXJ0IH0sXG4gICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogcHdFbmQgfSxcbiAgICApO1xuICAgIHVuaWZvcm1zLnB1c2goXG4gICAgICB7IG5hbWU6ICdrdycsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdzdycsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdwd1N0YXJ0JywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ3B3RW5kJywgdHlwZTogJ3UzMicgfSxcbiAgICApO1xuXG4gICAgbGV0IHBoU3RhcnRFbmROb3RaZXJvID0gZmFsc2U7XG4gICAgaWYgKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCBraCA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGVbYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggLSAyXTtcbiAgICAgIGNvbnN0IHNoID0gYXR0cmlidXRlcy5zdHJpZGVzW2F0dHJpYnV0ZXMuc3RyaWRlcy5sZW5ndGggLSAyXTtcbiAgICAgIGNvbnN0IHBoU3RhcnQgPSBhdHRyaWJ1dGVzLnBhZHNbYXR0cmlidXRlcy5wYWRzLmxlbmd0aCAvIDIgLSAyXTtcbiAgICAgIGNvbnN0IHBoRW5kID0gYXR0cmlidXRlcy5wYWRzW2F0dHJpYnV0ZXMucGFkcy5sZW5ndGggLSAyXTtcbiAgICAgIHBoU3RhcnRFbmROb3RaZXJvID0gISEocGhTdGFydCArIHBoRW5kKTtcbiAgICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKFxuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YToga2ggfSxcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHNoIH0sXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwaFN0YXJ0IH0sXG4gICAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBwaEVuZCB9LFxuICAgICAgKTtcblxuICAgICAgdW5pZm9ybXMucHVzaChcbiAgICAgICAgeyBuYW1lOiAna2gnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgICB7IG5hbWU6ICdzaCcsIHR5cGU6ICd1MzInIH0sXG4gICAgICAgIHsgbmFtZTogJ3BoU3RhcnQnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgICB7IG5hbWU6ICdwaEVuZCcsIHR5cGU6ICd1MzInIH0sXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gW3Byb2dyYW1Vbmlmb3JtcywgdW5pZm9ybXMsIHRydWUsIHB3U3RhcnRFbmROb3RaZXJvLCBwaFN0YXJ0RW5kTm90WmVyb107XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzQ2hhbm5lbHNMYXN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvb2xpbmcgd2l0aCBrZXJuZWxTaGFwZS5sZW5ndGggPiAyIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIE5IV0MgZm9ybWF0LicpO1xuICAgIH1cbiAgICBjb25zdCBrZXJuZWxTdHJpZGVzID0gU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGF0dHJpYnV0ZXMua2VybmVsU2hhcGUpO1xuICAgIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKFxuICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGtlcm5lbFN0cmlkZXMgfSxcbiAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBhdHRyaWJ1dGVzLnBhZHMgfSxcbiAgICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBhdHRyaWJ1dGVzLnN0cmlkZXMgfSxcbiAgICApO1xuICAgIHVuaWZvcm1zLnB1c2goXG4gICAgICB7IG5hbWU6ICdrZXJuZWxTdHJpZGVzJywgdHlwZTogJ3UzMicsIGxlbmd0aDoga2VybmVsU3RyaWRlcy5sZW5ndGggfSxcbiAgICAgIHsgbmFtZTogJ3BhZHMnLCB0eXBlOiAndTMyJywgbGVuZ3RoOiBhdHRyaWJ1dGVzLnBhZHMubGVuZ3RoIH0sXG4gICAgICB7IG5hbWU6ICdzdHJpZGVzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogYXR0cmlidXRlcy5zdHJpZGVzLmxlbmd0aCB9LFxuICAgICk7XG5cbiAgICBjb25zdCBoYXNQYWRzID0gYXR0cmlidXRlcy5wYWRzLnJlZHVjZSgoc3VtLCBjdXIpID0+IHN1bSArIGN1cik7XG4gICAgcmV0dXJuIFtwcm9ncmFtVW5pZm9ybXMsIHVuaWZvcm1zLCAhIWhhc1BhZHMsIGZhbHNlLCBmYWxzZV07XG4gIH1cbn07XG5cbmNvbnN0IGdlbmVyYXRlUG9vbGluZ0NvZGUgPSA8QXR0cmlidXRlVHlwZSBleHRlbmRzIEF2ZXJhZ2VQb29sQXR0cmlidXRlcyB8IE1heFBvb2xBdHRyaWJ1dGVzPihcbiAgc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIsXG4gIHg6IEluZGljZXNIZWxwZXIsXG4gIHJhbms6IG51bWJlcixcbiAgb3V0cHV0U2hhcGVSYW5rOiBudW1iZXIsXG4gIGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZVR5cGUsXG4gIG9wMTogc3RyaW5nLFxuICBvcDI6IHN0cmluZyxcbiAgc3RhcnQ6IG51bWJlcixcbiAgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlLFxuICBoYXNQYWRzOiBib29sZWFuLFxuICBwd1N0YXJ0RW5kTm90WmVybzogYm9vbGVhbixcbiAgcGhTdGFydEVuZE5vdFplcm86IGJvb2xlYW4sXG4pOiBzdHJpbmcgPT4ge1xuICBjb25zdCBpc0NoYW5uZWxzTGFzdCA9IGF0dHJpYnV0ZXMuZm9ybWF0ID09PSAnTkhXQyc7XG4gIGNvbnN0IGRhdGFUeXBlID0geC50eXBlLnZhbHVlO1xuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgeC50eXBlLnRlbnNvciwgb3V0cHV0U2hhcGVSYW5rKTtcblxuICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggPD0gMikge1xuICAgIGxldCBjb2RlVyA9ICcnO1xuICAgIGxldCBjb2RlSCA9ICcnO1xuICAgIGxldCBjb2RlSEVuZCA9ICcnO1xuICAgIGNvbnN0IGRpbUlkeFcgPSByYW5rIC0gKGlzQ2hhbm5lbHNMYXN0ID8gMiA6IDEpO1xuICAgIGlmIChwd1N0YXJ0RW5kTm90WmVybykge1xuICAgICAgY29kZVcgPSBgXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCB1bmlmb3Jtcy5rdzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske2RpbUlkeFd9XSA9IGluZGljZXNbJHtkaW1JZHhXfV0gKiB1bmlmb3Jtcy5zdyAtIHVuaWZvcm1zLnB3U3RhcnQgKyBpO1xuICAgICAgICAgICAgICAgICAgaWYgKHhJbmRpY2VzWyR7ZGltSWR4V31dIDwgMCB8fCB4SW5kaWNlc1ske2RpbUlkeFd9XVxuICAgICAgICAgICAgICAgICAgICAgID49IHVuaWZvcm1zLnhfc2hhcGVbJHtkaW1JZHhXfV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFkKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3guaW5kaWNlc1RvT2Zmc2V0KCd4SW5kaWNlcycpfV07XG4gICAgICAgICAgICAgICAgICAke29wMX1cbiAgICAgICAgICAgICAgICB9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZVcgPSBgXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCB1bmlmb3Jtcy5rdzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske2RpbUlkeFd9XSA9IGluZGljZXNbJHtkaW1JZHhXfV0gKiB1bmlmb3Jtcy5zdyAtIHVuaWZvcm1zLnB3U3RhcnQgKyBpO1xuICAgICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3guaW5kaWNlc1RvT2Zmc2V0KCd4SW5kaWNlcycpfV07XG4gICAgICAgICAgICAgICAgICAke29wMX1cbiAgICAgICAgICAgICAgICB9YDtcbiAgICB9XG5cbiAgICBpZiAoYXR0cmlidXRlcy5rZXJuZWxTaGFwZS5sZW5ndGggPT09IDIpIHtcbiAgICAgIGNvbnN0IGRpbUlkeEggPSByYW5rIC0gKGlzQ2hhbm5lbHNMYXN0ID8gMyA6IDIpO1xuICAgICAgaWYgKHBoU3RhcnRFbmROb3RaZXJvKSB7XG4gICAgICAgIGNvZGVIID0gYFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGo6IHUzMiA9IDB1OyBqIDwgdW5pZm9ybXMua2g7IGorKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtkaW1JZHhIfV0gPSBpbmRpY2VzWyR7ZGltSWR4SH1dICogdW5pZm9ybXMuc2ggLSB1bmlmb3Jtcy5waFN0YXJ0ICsgajtcbiAgICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1ske2RpbUlkeEh9XSA8IDAgfHwgeEluZGljZXNbJHtkaW1JZHhIfV0gPj0gdW5pZm9ybXMueF9zaGFwZVske2RpbUlkeEh9XSkge1xuICAgICAgICAgICAgICAgICAgICBwYWQgKz0gaTMyKHVuaWZvcm1zLmt3KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2RlSCA9IGBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwdTsgaiA8IHVuaWZvcm1zLmtoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7ZGltSWR4SH1dID0gaW5kaWNlc1ske2RpbUlkeEh9XSAqIHVuaWZvcm1zLnNoIC0gdW5pZm9ybXMucGhTdGFydCArIGo7XG4gICAgICAgICAgICAgICAgYDtcbiAgICAgIH1cbiAgICAgIGNvZGVIRW5kID0gYFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgO1xuICAgIH1cblxuICAgIGNvbnN0IHBvb2xpbmdDb2RlID0gYFxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyh4LCBvdXRwdXQpfVxuXG4gICAgICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxuXG4gICAgICAgICAgICAgIGxldCBpbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuICAgICAgICAgICAgICB2YXIgeEluZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG5cbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gJHtkYXRhVHlwZX0oJHtzdGFydH0pO1xuICAgICAgICAgICAgICB2YXIgcGFkID0gMDtcbiAgICAgICAgICAgICAgJHtjb2RlSH1cbiAgICAgICAgICAgICAgJHtjb2RlV31cbiAgICAgICAgICAgICAgJHtjb2RlSEVuZH1cbiAgICAgICAgICAgICAgJHtvcDJ9XG5cbiAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gICAgICAgICAgICB9YDtcbiAgICByZXR1cm4gcG9vbGluZ0NvZGU7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzQ2hhbm5lbHNMYXN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvb2xpbmcgd2l0aCBrZXJuZWxTaGFwZS5sZW5ndGggPiAyIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIE5IV0MgZm9ybWF0LicpO1xuICAgIH1cbiAgICBjb25zdCBzdHJpZGVzUmFuayA9IGF0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RoO1xuICAgIGNvbnN0IHBhZHNSYW5rID0gYXR0cmlidXRlcy5wYWRzLmxlbmd0aDtcbiAgICBsZXQgcGFkQ29kZSA9ICcnO1xuICAgIGlmIChoYXNQYWRzKSB7XG4gICAgICBwYWRDb2RlID0gYFxuICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1tqXSA+PSB1bmlmb3Jtcy54X3NoYXBlW2pdKSB7XG4gICAgICAgICAgICAgICAgICBwYWQrKztcbiAgICAgICAgICAgICAgICAgIGlzUGFkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWlzUGFkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3guaW5kaWNlc1RvT2Zmc2V0KCd4SW5kaWNlcycpfV07XG4gICAgICAgICAgICAgICAgJHtvcDF9XG4gICAgICAgICAgICAgIH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWRDb2RlID0gYFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt4LmluZGljZXNUb09mZnNldCgneEluZGljZXMnKX1dO1xuICAgICAgICAgICAgICAke29wMX1cbiAgICAgICAgICAgIGA7XG4gICAgfVxuICAgIGNvbnN0IHBvb2xpbmdDb2RlID0gYFxuICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3Jtcyh1bmlmb3JtcykuZGVjbGFyZVZhcmlhYmxlcyh4LCBvdXRwdXQpfVxuXG4gICAgICAgICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxuICAgICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICAgICAgICAgdmFyIHhJbmRpY2VzID0gJHtvdXRwdXQub2Zmc2V0VG9JbmRpY2VzKCdnbG9iYWxfaWR4Jyl9O1xuXG4gICAgICAgICAgICAgIHZhciBvZmZzZXRzOiBhcnJheTx1MzIsICR7c3RyaWRlc1Jhbmt9PjtcblxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAke2RhdGFUeXBlfSgke3N0YXJ0fSk7XG4gICAgICAgICAgICAgIHZhciBwYWQgPSAwO1xuICAgICAgICAgICAgICB2YXIgaXNQYWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8IHVuaWZvcm1zLmtlcm5lbFNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwdTsgaiA8ICR7c3RyaWRlc1JhbmsgLSAxfXU7IGorKykge1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0c1tqXSA9IG9mZnNldCAvICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5rZXJuZWxTdHJpZGVzJywgJ2onLCBzdHJpZGVzUmFuayl9O1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0IC09IG9mZnNldHNbal0gKiAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMua2VybmVsU3RyaWRlcycsICdqJywgc3RyaWRlc1JhbmspfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0c1ske3N0cmlkZXNSYW5rIC0gMX1dID0gb2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgaXNQYWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gJHtyYW5rIC0gc3RyaWRlc1Jhbmt9dTsgaiA8ICR7cmFua311OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzW2pdID0gaW5kaWNlc1tqXSAqICR7Z2V0RWxlbWVudEF0KFxuICAgICAgICAgICAgICAgICAgICAndW5pZm9ybXMuc3RyaWRlcycsXG4gICAgICAgICAgICAgICAgICAgIGBqIC0gJHtyYW5rIC0gc3RyaWRlc1Jhbmt9dWAsXG4gICAgICAgICAgICAgICAgICAgIHN0cmlkZXNSYW5rLFxuICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgKyBvZmZzZXRzW2ogLSAke3JhbmsgLSBzdHJpZGVzUmFua311XSAtICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5wYWRzJywgJ2ogLSAydScsIHBhZHNSYW5rKX07XG4gICAgICAgICAgICAgICAgICAke3BhZENvZGV9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHtvcDJ9XG5cbiAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gICAgICAgICAgICB9YDtcbiAgICByZXR1cm4gcG9vbGluZ0NvZGU7XG4gIH1cbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgRm9ybWF0QXR0cmlidXRlcyB7XG4gIHJlYWRvbmx5IGZvcm1hdDogJ05IV0MnIHwgJ05DSFcnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBvb2xDb21tb25BdHRyaWJ1dGVzIGV4dGVuZHMgRm9ybWF0QXR0cmlidXRlcyB7XG4gIHJlYWRvbmx5IGF1dG9QYWQ6IHN0cmluZztcbiAgcmVhZG9ubHkgY2VpbE1vZGU6IG51bWJlcjtcbiAgcmVhZG9ubHkga2VybmVsU2hhcGU6IHJlYWRvbmx5IG51bWJlcltdO1xuICByZWFkb25seSBzdHJpZGVzOiByZWFkb25seSBudW1iZXJbXTtcbiAgcmVhZG9ubHkgcGFkczogcmVhZG9ubHkgbnVtYmVyW107XG59XG5cbmNvbnN0IGNyZWF0ZVNoYWRlcktleUZyb21BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFBvb2xDb21tb25BdHRyaWJ1dGVzKTogc3RyaW5nID0+XG4gIGAke2F0dHJpYnV0ZXMuZm9ybWF0fTske2F0dHJpYnV0ZXMuY2VpbE1vZGV9OyR7YXR0cmlidXRlcy5hdXRvUGFkfTske2F0dHJpYnV0ZXMua2VybmVsU2hhcGUubGVuZ3RofWA7XG5cbmNvbnN0IGNyZWF0ZUF2ZXJhZ2VQb29sU2hhZGVyS2V5RnJvbUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogQXZlcmFnZVBvb2xBdHRyaWJ1dGVzKTogc3RyaW5nID0+XG4gIGAke2NyZWF0ZVNoYWRlcktleUZyb21BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpfTske2F0dHJpYnV0ZXMuY291bnRJbmNsdWRlUGFkfWA7XG5cbmNvbnN0IGNyZWF0ZU1heFBvb2xTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBNYXhQb29sQXR0cmlidXRlcyk6IHN0cmluZyA9PlxuICBgJHtjcmVhdGVTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyhhdHRyaWJ1dGVzKX07JHthdHRyaWJ1dGVzLnN0b3JhZ2VPcmRlcn07JHthdHRyaWJ1dGVzLmRpbGF0aW9uc31gO1xuXG5jb25zdCBwYXJzZVBvb2xDb21tb25BdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogUG9vbENvbW1vbkF0dHJpYnV0ZXMgPT4gKHtcbiAgZm9ybWF0OiBhdHRyaWJ1dGVzLmZvcm1hdCBhcyBGb3JtYXRBdHRyaWJ1dGVzWydmb3JtYXQnXSxcbiAgYXV0b1BhZDogWydOT1RTRVQnLCAnVkFMSUQnLCAnU0FNRV9VUFBFUicsICdTQU1FX0xPV0VSJ11bYXR0cmlidXRlcy5hdXRvX3BhZCBhcyBudW1iZXJdLFxuICBjZWlsTW9kZTogYXR0cmlidXRlcy5jZWlsX21vZGUgYXMgbnVtYmVyLFxuICBrZXJuZWxTaGFwZTogYXR0cmlidXRlcy5rZXJuZWxfc2hhcGUgYXMgW251bWJlciwgbnVtYmVyXSxcbiAgc3RyaWRlczogYXR0cmlidXRlcy5zdHJpZGVzIGFzIFtudW1iZXIsIG51bWJlcl0sXG4gIHBhZHM6IGF0dHJpYnV0ZXMucGFkcyBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSxcbn0pO1xuXG5leHBvcnQgaW50ZXJmYWNlIEF2ZXJhZ2VQb29sQXR0cmlidXRlcyBleHRlbmRzIFBvb2xDb21tb25BdHRyaWJ1dGVzLCBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBjb3VudEluY2x1ZGVQYWQ6IGJvb2xlYW47XG59XG5cbmNvbnN0IGNyZWF0ZUF2ZXJhZ2VQb29sUHJvZ3JhbUluZm8gPSAoXG4gIG5hbWU6IHN0cmluZyxcbiAgaW5wdXQ6IFRlbnNvclZpZXcsXG4gIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sXG4gIGF0dHJpYnV0ZXM6IEF2ZXJhZ2VQb29sQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgW2FkanVzdGVkQXR0cmlidXRlcywgb3V0cHV0U2hhcGVdID0gZ2V0QWRqdXN0ZWRQb29sQXR0cmlidXRlc0FuZE91dHB1dFNoYXBlKFxuICAgIGlucHV0LFxuICAgIGF0dHJpYnV0ZXMsXG4gICAgaXNHbG9iYWxPcGVyYXRvcixcbiAgKTtcbiAgY29uc3QgeCA9IGlucHV0VmFyaWFibGUoJ3gnLCBpbnB1dC5kYXRhVHlwZSwgaW5wdXQuZGltcy5sZW5ndGgpO1xuICBjb25zdCBkYXRhVHlwZSA9IHgudHlwZS52YWx1ZTtcblxuICBjb25zdCBvcDEgPSAndmFsdWUgKz0geF92YWw7JztcbiAgbGV0IG9wMiA9ICcnO1xuICBpZiAoYWRqdXN0ZWRBdHRyaWJ1dGVzLmNvdW50SW5jbHVkZVBhZCkge1xuICAgIG9wMiArPSBgdmFsdWUgLz0gJHtkYXRhVHlwZX0odW5pZm9ybXMua2VybmVsU2l6ZSk7YDtcbiAgfSBlbHNlIHtcbiAgICBvcDIgKz0gYHZhbHVlIC89ICR7ZGF0YVR5cGV9KGkzMih1bmlmb3Jtcy5rZXJuZWxTaXplKSAtIHBhZCk7YDtcbiAgfVxuICBjb25zdCBbcHJvZ3JhbVVuaWZvcm1zLCB1bmlmb3JtcywgaGFzUGFkcywgcHdTdGFydEVuZE5vdFplcm8sIHBoU3RhcnRFbmROb3RaZXJvXSA9IGdldFVuaWZvcm1BbmRQYWRJbmZvKFxuICAgIG91dHB1dFNoYXBlLFxuICAgIGFkanVzdGVkQXR0cmlidXRlcyxcbiAgKTtcbiAgcHJvZ3JhbVVuaWZvcm1zLnB1c2goLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXQuZGltcywgb3V0cHV0U2hhcGUpKTtcbiAgY29uc3QgaW5wdXREZXBlbmRlbmNpZXM6IFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5W10gPSBbJ3JhbmsnXTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICBoaW50OiBgJHthdHRyaWJ1dGVzLmNhY2hlS2V5fTske2hhc1BhZHN9OyR7cHdTdGFydEVuZE5vdFplcm99OyR7cGhTdGFydEVuZE5vdFplcm99YCxcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzLFxuICAgIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXQuZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSkgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtcyxcbiAgICB9KSxcbiAgICBnZXRTaGFkZXJTb3VyY2U6IChzaGFkZXJIZWxwZXIpID0+XG4gICAgICBnZW5lcmF0ZVBvb2xpbmdDb2RlKFxuICAgICAgICBzaGFkZXJIZWxwZXIsXG4gICAgICAgIHgsXG4gICAgICAgIGlucHV0LmRpbXMubGVuZ3RoLFxuICAgICAgICBvdXRwdXRTaGFwZS5sZW5ndGgsXG4gICAgICAgIGFkanVzdGVkQXR0cmlidXRlcyxcbiAgICAgICAgb3AxLFxuICAgICAgICBvcDIsXG4gICAgICAgIDAuMCxcbiAgICAgICAgdW5pZm9ybXMsXG4gICAgICAgIGhhc1BhZHMsXG4gICAgICAgIHB3U3RhcnRFbmROb3RaZXJvLFxuICAgICAgICBwaFN0YXJ0RW5kTm90WmVybyxcbiAgICAgICksXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBBdmVyYWdlUG9vbEF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBjb3VudEluY2x1ZGVQYWQgPSAoYXR0cmlidXRlcy5jb3VudF9pbmNsdWRlX3BhZCBhcyBudW1iZXIpID09PSAwID8gZmFsc2UgOiB0cnVlO1xuXG4gIGNvbnN0IGF0dHIgPSBwYXJzZVBvb2xDb21tb25BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xuICAvLyBUT0RPOiBzdXBwb3J0IGF0dHJpYnV0ZSAnY2VpbF9tb2RlJ1xuICBpZiAoYXR0ci5jZWlsTW9kZSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNpbmcgY2VpbCgpIGluIHNoYXBlIGNvbXB1dGF0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBBdmVyYWdlUG9vbCcpO1xuICB9XG4gIGNvbnN0IGF2ZXJhZ2VQb29sQXR0cmlidXRlcyA9IHsgY291bnRJbmNsdWRlUGFkLCAuLi5hdHRyLCBjYWNoZUtleTogJycgfTtcbiAgcmV0dXJuIHsgLi4uYXZlcmFnZVBvb2xBdHRyaWJ1dGVzLCBjYWNoZUtleTogY3JlYXRlQXZlcmFnZVBvb2xTaGFkZXJLZXlGcm9tQXR0cmlidXRlcyhhdmVyYWdlUG9vbEF0dHJpYnV0ZXMpIH07XG59O1xuXG5leHBvcnQgY29uc3QgYXZlcmFnZVBvb2wgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEF2ZXJhZ2VQb29sQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVBdmVyYWdlUG9vbFByb2dyYW1JbmZvKCdBdmVyYWdlUG9vbCcsIGNvbnRleHQuaW5wdXRzWzBdLCBmYWxzZSwgYXR0cmlidXRlcykpO1xufTtcblxuY29uc3QgZ2xvYmFsUG9vbEF0dHJpYnV0ZXMgPSB7XG4gIGF1dG9QYWQ6ICcnLFxuICBjZWlsTW9kZTogMCxcbiAgY291bnRJbmNsdWRlUGFkOiBmYWxzZSxcbiAga2VybmVsU2hhcGU6IFtdLFxuICBzdHJpZGVzOiBbXSxcbiAgcGFkczogW10sXG4gIHN0b3JhZ2VPcmRlcjogMCxcbiAgZGlsYXRpb25zOiBbXSxcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZUdsb2JhbEF2ZXJhZ2VQb29sQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IEF2ZXJhZ2VQb29sQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGZvcm1hdCA9IGF0dHJpYnV0ZXMuZm9ybWF0IGFzIEZvcm1hdEF0dHJpYnV0ZXNbJ2Zvcm1hdCddO1xuICByZXR1cm4geyBmb3JtYXQsIC4uLmdsb2JhbFBvb2xBdHRyaWJ1dGVzLCBjYWNoZUtleTogZm9ybWF0IH07XG59O1xuXG5leHBvcnQgY29uc3QgZ2xvYmFsQXZlcmFnZVBvb2wgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IEF2ZXJhZ2VQb29sQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVBdmVyYWdlUG9vbFByb2dyYW1JbmZvKCdHbG9iYWxBdmVyYWdlUG9vbCcsIGNvbnRleHQuaW5wdXRzWzBdLCB0cnVlLCBhdHRyaWJ1dGVzKSk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIE1heFBvb2xBdHRyaWJ1dGVzIGV4dGVuZHMgUG9vbENvbW1vbkF0dHJpYnV0ZXMsIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IHN0b3JhZ2VPcmRlcjogbnVtYmVyO1xuICByZWFkb25seSBkaWxhdGlvbnM6IG51bWJlcltdO1xufVxuXG5jb25zdCBjcmVhdGVNYXhQb29sUHJvZ3JhbUluZm8gPSAoXG4gIG5hbWU6IHN0cmluZyxcbiAgaW5wdXQ6IFRlbnNvclZpZXcsXG4gIGlzR2xvYmFsT3BlcmF0b3I6IGJvb2xlYW4sXG4gIGF0dHJpYnV0ZXM6IE1heFBvb2xBdHRyaWJ1dGVzLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBbYWRqdXN0ZWRBdHRyaWJ1dGVzLCBvdXRwdXRTaGFwZV0gPSBnZXRBZGp1c3RlZFBvb2xBdHRyaWJ1dGVzQW5kT3V0cHV0U2hhcGUoXG4gICAgaW5wdXQsXG4gICAgYXR0cmlidXRlcyxcbiAgICBpc0dsb2JhbE9wZXJhdG9yLFxuICApO1xuICBjb25zdCBvcDEgPSBgXG4gICAgICB2YWx1ZSA9IG1heCh4X3ZhbCwgdmFsdWUpO1xuICAgIGA7XG4gIGNvbnN0IG9wMiA9ICcnO1xuICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0LmRhdGFUeXBlLCBpbnB1dC5kaW1zLmxlbmd0aCk7XG4gIGNvbnN0IGlucHV0RGVwZW5kZW5jaWVzOiBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdID0gWydyYW5rJ107XG4gIGNvbnN0IFtwcm9ncmFtVW5pZm9ybXMsIHVuaWZvcm1zLCBoYXNQYWRzLCBwd1N0YXJ0RW5kTm90WmVybywgcGhTdGFydEVuZE5vdFplcm9dID0gZ2V0VW5pZm9ybUFuZFBhZEluZm8oXG4gICAgb3V0cHV0U2hhcGUsXG4gICAgYWRqdXN0ZWRBdHRyaWJ1dGVzLFxuICApO1xuICBwcm9ncmFtVW5pZm9ybXMucHVzaCguLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dC5kaW1zLCBvdXRwdXRTaGFwZSkpO1xuICByZXR1cm4ge1xuICAgIG5hbWUsXG4gICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgIGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9OyR7aGFzUGFkc307JHtwd1N0YXJ0RW5kTm90WmVyb307JHtwaFN0YXJ0RW5kTm90WmVyb31gLFxuICAgICAgaW5wdXREZXBlbmRlbmNpZXMsXG4gICAgfSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dC5kYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICAgIGdldFNoYWRlclNvdXJjZTogKHNoYWRlckhlbHBlcikgPT5cbiAgICAgIGdlbmVyYXRlUG9vbGluZ0NvZGUoXG4gICAgICAgIHNoYWRlckhlbHBlcixcbiAgICAgICAgeCxcbiAgICAgICAgaW5wdXQuZGltcy5sZW5ndGgsXG4gICAgICAgIG91dHB1dFNoYXBlLmxlbmd0aCxcbiAgICAgICAgYWRqdXN0ZWRBdHRyaWJ1dGVzLFxuICAgICAgICBvcDEsXG4gICAgICAgIG9wMixcbiAgICAgICAgaW5wdXQuZGF0YVR5cGUgPT09IERhdGFUeXBlLmZsb2F0MTYgPyAtNjU1MDQgOiAtMWU1LFxuICAgICAgICB1bmlmb3JtcyxcbiAgICAgICAgaGFzUGFkcyxcbiAgICAgICAgcHdTdGFydEVuZE5vdFplcm8sXG4gICAgICAgIHBoU3RhcnRFbmROb3RaZXJvLFxuICAgICAgKSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBtYXhQb29sID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBNYXhQb29sQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVNYXhQb29sUHJvZ3JhbUluZm8oJ01heFBvb2wnLCBjb250ZXh0LmlucHV0c1swXSwgZmFsc2UsIGF0dHJpYnV0ZXMpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZU1heFBvb2xBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogTWF4UG9vbEF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBzdG9yYWdlT3JkZXIgPSBhdHRyaWJ1dGVzLnN0b3JhZ2Vfb3JkZXIgYXMgbnVtYmVyO1xuICBjb25zdCBkaWxhdGlvbnMgPSBhdHRyaWJ1dGVzLmRpbGF0aW9ucyBhcyBbbnVtYmVyLCBudW1iZXJdO1xuXG4gIGNvbnN0IGF0dHIgPSBwYXJzZVBvb2xDb21tb25BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xuICAvLyBUT0RPOiBzdXBwb3J0IGF0dHJpYnV0ZSAnY2VpbF9tb2RlJyBhbmQgJ3N0b3JhZ2Vfb3JkZXInXG4gIGlmIChzdG9yYWdlT3JkZXIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbHVtbiBtYWpvciBzdG9yYWdlIG9yZGVyIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sJyk7XG4gIH1cbiAgaWYgKGF0dHIuY2VpbE1vZGUgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbCcpO1xuICB9XG4gIGNvbnN0IG1heFBvb2xBdHRyaWJ1dGVzID0geyBzdG9yYWdlT3JkZXIsIGRpbGF0aW9ucywgLi4uYXR0ciwgY2FjaGVLZXk6ICcnIH07XG4gIHJldHVybiB7IC4uLm1heFBvb2xBdHRyaWJ1dGVzLCBjYWNoZUtleTogY3JlYXRlTWF4UG9vbFNoYWRlcktleUZyb21BdHRyaWJ1dGVzKG1heFBvb2xBdHRyaWJ1dGVzKSB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlR2xvYmFsTWF4UG9vbEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBNYXhQb29sQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IGZvcm1hdCA9IGF0dHJpYnV0ZXMuZm9ybWF0IGFzIEZvcm1hdEF0dHJpYnV0ZXNbJ2Zvcm1hdCddO1xuICByZXR1cm4geyBmb3JtYXQsIC4uLmdsb2JhbFBvb2xBdHRyaWJ1dGVzLCBjYWNoZUtleTogZm9ybWF0IH07XG59O1xuXG5leHBvcnQgY29uc3QgZ2xvYmFsTWF4UG9vbCA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogTWF4UG9vbEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlTWF4UG9vbFByb2dyYW1JbmZvKCdHbG9iYWxNYXhQb29sJywgY29udGV4dC5pbnB1dHNbMF0sIHRydWUsIGF0dHJpYnV0ZXMpKTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgQXR0cmlidXRlV2l0aENhY2hlS2V5LCBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkgfSBmcm9tICcuLi9hdHRyaWJ1dGUtd2l0aC1jYWNoZS1rZXknO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXG4gIGdldE1heENvbXBvbmVudHMsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxufSBmcm9tICcuL2NvbW1vbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVxdWFudGl6ZUxpbmVyQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIGF4aXM6IG51bWJlcjtcbiAgYmxvY2tTaXplOiBudW1iZXI7XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBEZXF1YW50aXplTGluZXJBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGlmIChpbnB1dHMubGVuZ3RoIDwgMiB8fCBpbnB1dHMubGVuZ3RoID4gMykge1xuICAgIHRocm93IG5ldyBFcnJvcignRGVxdWFudGl6ZUxpbmVhciByZXF1aXJlcyAyIG9yIDMgaW5wdXRzLicpO1xuICB9XG4gIGlmIChpbnB1dHMubGVuZ3RoID09PSAzICYmIGlucHV0c1sxXS5kaW1zID09PSBpbnB1dHNbMl0uZGltcykge1xuICAgIHRocm93IG5ldyBFcnJvcigneC1zY2FsZSBhbmQgeC16ZXJvLXBvaW50IG11c3QgaGF2ZSB0aGUgc2FtZSBzaGFwZS4nKTtcbiAgfVxuICBpZiAoaW5wdXRzLmxlbmd0aCA9PT0gMyAmJiBpbnB1dHNbMF0uZGF0YVR5cGUgIT09IGlucHV0c1syXS5kYXRhVHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigneCBhbmQgeC16ZXJvLXBvaW50IG11c3QgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGUuJyk7XG4gIH1cbiAgaWYgKGlucHV0c1swXS5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuaW50MzIgJiYgaW5wdXRzLmxlbmd0aCA+IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0luIHRoZSBjYXNlIG9mIGRlcXVhbnRpemluZyBpbnQzMiB0aGVyZSBpcyBubyB6ZXJvIHBvaW50LicpO1xuICB9XG4gIGlmIChpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IDAgJiYgaW5wdXRzWzFdLmRpbXMubGVuZ3RoICE9PSAxICYmIGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzY2FsZSBpbnB1dCBtdXN0IGJlIGEgc2NhbGFyLCBhIDFEIHRlbnNvciwgb3IgaGF2ZSB0aGUgc2FtZSByYW5rIGFzIHRoZSBpbnB1dCB0ZW5zb3IuJyk7XG4gIH1cbiAgLy8gdmFsaWRhdGUgc2NhbGUgYW5kIHplcm8tcG9pbnQgaW5wdXQgc2hhcGVzXG4gIGlmIChpbnB1dHMubGVuZ3RoID4gMikge1xuICAgIC8vIHplcm8tcG9pbnQgaW5wdXQgdHlwZSBzaG91bGQgYmUgdGhlIHNhbWUgYXMgaW5wdXQgZGF0YSB0eXBlLlxuICAgIGlmIChpbnB1dHNbMF0uZGF0YVR5cGUgIT09IGlucHV0c1syXS5kYXRhVHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd4IGFuZCB4LXplcm8tcG9pbnQgbXVzdCBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZS4nKTtcbiAgICB9XG4gICAgLy8gU2NhbGUgYW5kIHplcm8tcG9pbnQgaW5wdXRzIG11c3QgaGF2ZSB0aGUgc2FtZSBzaGFwZVxuICAgIGlmIChpbnB1dHNbMV0uZGltcy5sZW5ndGggIT09IGlucHV0c1syXS5kaW1zLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzY2FsZSBhbmQgemVyby1wb2ludCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsuJyk7XG4gICAgfVxuICAgIGlmICghaW5wdXRzWzFdLmRpbXMubWFwKChkLCBpKSA9PiBkID09PSBpbnB1dHNbMl0uZGltc1tpXSkucmVkdWNlKChhLCBiKSA9PiBhICYmIGIsIHRydWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NjYWxlIGFuZCB6ZXJvLXBvaW50IGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgc2hhcGUuJyk7XG4gICAgfVxuICB9XG4gIC8vIFZhbGlkYXRlIGJsb2NrU2l6ZVxuICBpZiAoYXR0cmlidXRlcy5ibG9ja1NpemUgPiAwKSB7XG4gICAgLy8gQmxvY2sgcXVuYXRpemF0aW9uXG4gICAgaWYgKGlucHV0c1sxXS5kaW1zLmxlbmd0aCA9PT0gMCB8fCAoaW5wdXRzWzFdLmRpbXMubGVuZ3RoID09PSAxICYmIGlucHV0c1sxXS5kaW1zWzBdID09PSAxKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdibG9ja1NpemUgbXVzdCBiZSBzZXQgb25seSBmb3IgYmxvY2sgcXVhbnRpemF0aW9uLicpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAhaW5wdXRzWzFdLmRpbXMubWFwKChkLCBpKSA9PiBpID09PSBhdHRyaWJ1dGVzLmF4aXMgfHwgZCA9PT0gaW5wdXRzWzBdLmRpbXNbaV0pLnJlZHVjZSgoYSwgYikgPT4gYSAmJiBiLCB0cnVlKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3IgYmxvY2sgcXVuYXRpemF0aW9uLCBzY2FsZSBpbnB1dCBzaGFwZSB0byBtYXRjaCB0aGUgaW5wdXQgc2hhcGUgZXhjZXB0IGZvciB0aGUgYXhpcycpO1xuICAgIH1cbiAgICAvLyBTY2FsZSBpbnB1dCByYW5rIHNob3VsZCBiZSBzYW1lIGFzIHRoZSBpbnB1dCByYW5rXG4gICAgaWYgKGlucHV0c1sxXS5kaW1zLmxlbmd0aCAhPT0gaW5wdXRzWzBdLmRpbXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvciBibG9jayBxdW5hdGl6YXRpb24gdGhlIHNjYWxlIGlucHV0IHJhbmsgbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgeCByYW5rLicpO1xuICAgIH1cbiAgICBjb25zdCBkSSA9IGlucHV0c1swXS5kaW1zW2F0dHJpYnV0ZXMuYXhpc107XG4gICAgY29uc3Qgc2kgPSBpbnB1dHNbMV0uZGltc1thdHRyaWJ1dGVzLmF4aXNdO1xuICAgIGlmIChhdHRyaWJ1dGVzLmJsb2NrU2l6ZSA8IE1hdGguY2VpbChkSSAvIHNpKSB8fCBhdHRyaWJ1dGVzLmJsb2NrU2l6ZSA+IE1hdGguY2VpbChkSSAvIChzaSAtIDEpIC0gMSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYmxvY2tTaXplIG11c3QgYmUgd2l0aCBpbiB0aGUgcmFuZ2UgW2NlaWwoZEkgLyBTaSksIGNlaWwoZEkgLyAoU2kgLSAxKSAtIDEpXS4nKTtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZURlcXVhbnRpemVMaW5lYXJQcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IERlcXVhbnRpemVMaW5lckF0dHJpYnV0ZXMsXG4pOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGF4aXMgPSBTaGFwZVV0aWwubm9ybWFsaXplQXhpcyhhdHRyaWJ1dGVzLmF4aXMsIGlucHV0c1swXS5kaW1zLmxlbmd0aCk7XG4gIGNvbnN0IGlucHV0VHlwZSA9IGlucHV0c1swXS5kYXRhVHlwZTtcbiAgY29uc3QgaXNTaWduZWQgPSBpbnB1dFR5cGUgPT09IERhdGFUeXBlLmludDg7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRzWzBdLmRpbXM7IC8vIG91dHB1dCBzaGFwZSBpcyBzYW1lIGFzIHRoZSBpbnB1dCBzaGFwZVxuICBjb25zdCBkYXRhVHlwZSA9IGlucHV0c1sxXS5kYXRhVHlwZTsgLy8gb3V0cHV0IHR5cGUgaXMgc2FtZSBhcyB0aGUgdGhlIHNjYWxlIGlucHV0IHR5cGVcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgY29uc3QgaXNQYWNrZWQgPSBpbnB1dFR5cGUgPT09IERhdGFUeXBlLmludDggfHwgaW5wdXRUeXBlID09PSBEYXRhVHlwZS51aW50ODtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlzUGFja2VkID8gW01hdGguY2VpbChTaGFwZVV0aWwuc2l6ZShpbnB1dHNbMF0uZGltcykgLyA0KV0gOiBpbnB1dHNbMF0uZGltcztcbiAgY29uc3Qgc2NhbGVTaGFwZSA9IGlucHV0c1sxXS5kaW1zO1xuICBjb25zdCB6ZXJvUG9pbnRJbnB1dCA9IGlucHV0cy5sZW5ndGggPiAyID8gaW5wdXRzWzJdIDogdW5kZWZpbmVkO1xuICBjb25zdCB6ZXJvUG9pbnRTaGFwZSA9IHplcm9Qb2ludElucHV0XG4gICAgPyBpc1BhY2tlZFxuICAgICAgPyBbTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKHplcm9Qb2ludElucHV0LmRpbXMpIC8gNCldXG4gICAgICA6IHplcm9Qb2ludElucHV0LmRpbXNcbiAgICA6IHVuZGVmaW5lZDtcbiAgLy8gU2NhbGVzIGlucHV0IGlzIGEgc2NhbGVyIGZvciBwZXItdGVuc29yL3Blci1sYXllciBxdWFudGl6YXRpb24sIDEtRCB0ZW5zb3IgZm9yIHBlci1heGlzIHF1YW50aXphdGlvblxuICAvLyBvciB0ZW5zb3Igd2l0aCBzYW1lIHJhbmsgYXMgaW5wdXQgZm9yIGJsb2NrZWQgcXVhbnRpemF0aW9uLlxuICBjb25zdCBwZXJMYXllclF1YW50aXphdGlvbiA9IHNjYWxlU2hhcGUubGVuZ3RoID09PSAwIHx8IChzY2FsZVNoYXBlLmxlbmd0aCA9PT0gMSAmJiBzY2FsZVNoYXBlWzBdID09PSAxKTtcbiAgY29uc3QgcGVyQXhpc1F1YW50aXphdGlvbiA9IHBlckxheWVyUXVhbnRpemF0aW9uID09PSBmYWxzZSAmJiBzY2FsZVNoYXBlLmxlbmd0aCA9PT0gMTtcbiAgLy8gTGVmdCB1bm5lY2Vzc2FyeSBjb21tZW50ZWQtb3V0IGFzc2lnbm1lbnQgZm9yIGRvY3VtZW50YXRpb25cbiAgLy8gY29uc3QgYmxvY2tRdWFudGl6YXRpb24gPSBwZXJMYXllclF1YW50aXphdGlvbiA9PT0gZmFsc2UgJiYgcGVyQXhpc1F1YW50aXphdGlvbiA9PT0gZmFsc2U7XG4gIGNvbnN0IG1heENvbXBvbmVudHMgPSBnZXRNYXhDb21wb25lbnRzKG91dHB1dFNpemUpO1xuICBjb25zdCB1c2VDb21wb25lbnRzID0gcGVyTGF5ZXJRdWFudGl6YXRpb24gJiYgKCFpc1BhY2tlZCB8fCBtYXhDb21wb25lbnRzID09PSA0KTtcbiAgY29uc3QgY29tcG9uZW50cyA9IHVzZUNvbXBvbmVudHMgPyBtYXhDb21wb25lbnRzIDogMTtcbiAgY29uc3QgaW5wdXRDb21wb25lbnQgPSB1c2VDb21wb25lbnRzICYmICFpc1BhY2tlZCA/IG1heENvbXBvbmVudHMgOiAxO1xuICBjb25zdCBpbnB1dCA9IGlucHV0VmFyaWFibGUoJ2lucHV0JywgaXNQYWNrZWQgPyBEYXRhVHlwZS51aW50MzIgOiBpbnB1dFR5cGUsIGlucHV0U2hhcGUubGVuZ3RoLCBpbnB1dENvbXBvbmVudCk7XG4gIGNvbnN0IHNjYWxlID0gaW5wdXRWYXJpYWJsZSgnc2NhbGUnLCBkYXRhVHlwZSwgc2NhbGVTaGFwZS5sZW5ndGgpO1xuICBjb25zdCB6ZXJvUG9pbnQgPSB6ZXJvUG9pbnRJbnB1dFxuICAgID8gaW5wdXRWYXJpYWJsZSgnemVyb19wb2ludCcsIGlzUGFja2VkID8gRGF0YVR5cGUudWludDMyIDogaW5wdXRUeXBlLCB6ZXJvUG9pbnRTaGFwZSEubGVuZ3RoKVxuICAgIDogdW5kZWZpbmVkO1xuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCwgY29tcG9uZW50cyk7XG4gIGNvbnN0IGlucHV0VmFyaWFibGVzID0gW2lucHV0LCBzY2FsZV07XG4gIGlmICh6ZXJvUG9pbnQpIHtcbiAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKHplcm9Qb2ludCk7XG4gIH1cbiAgY29uc3QgaW5wdXRTaGFwZXMgPSBbaW5wdXRTaGFwZSwgc2NhbGVTaGFwZV07XG4gIGlmICh6ZXJvUG9pbnRJbnB1dCkge1xuICAgIGlucHV0U2hhcGVzLnB1c2goemVyb1BvaW50U2hhcGUhKTtcbiAgfVxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgLyBjb21wb25lbnRzIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IGF4aXMgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogYXR0cmlidXRlcy5ibG9ja1NpemUgfSxcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyguLi5pbnB1dFNoYXBlcywgb3V0cHV0U2hhcGUpLFxuICBdO1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdvdXRwdXRfc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdheGlzJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ2Jsb2NrX3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgIF07XG4gICAgcmV0dXJuIGBcbiAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaW5wdXRWYXJpYWJsZXMsIG91dHB1dCl9XG4gICAgICAke3NoYWRlckhlbHBlci5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcblxuICAgICAgICAgIC8vIFNldCBpbnB1dCB4XG4gICAgICAgICAgJHsoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzUGFja2VkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICBsZXQgaW5wdXQgPSAke2lucHV0LmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4IC8gNCcpfTtcbiAgICAgICAgICAgIGxldCB4X3ZlYyA9ICR7aXNTaWduZWQgPyAndW5wYWNrNHhJOChpbnB1dCknIDogJ3VucGFjazR4VTgoaW5wdXQpJ307XG4gICAgICAgICAgICBsZXQgeF92YWx1ZSA9ICR7Y29tcG9uZW50cyA9PT0gMSA/ICd4X3ZlY1tnbG9iYWxfaWR4ICUgNF0nIDogJ3hfdmVjJ307YDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBgbGV0IHhfdmFsdWUgPSAke2lucHV0LmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4Jyl9O2A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkoKX07XG5cbiAgICAgICAgICAvLyBTZXQgc2NhbGUgaW5wdXRcbiAgICAgICAgICAkeygoKSA9PiB7XG4gICAgICAgICAgICBpZiAocGVyTGF5ZXJRdWFudGl6YXRpb24pIHtcbiAgICAgICAgICAgICAgLy8gc2NhbGUgaW5wdXQgaXMgYSBzY2FsYXIgKClcbiAgICAgICAgICAgICAgcmV0dXJuIGBsZXQgc2NhbGVfdmFsdWU9ICR7c2NhbGUuZ2V0QnlPZmZzZXQoJzAnKX1gO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwZXJBeGlzUXVhbnRpemF0aW9uKSB7XG4gICAgICAgICAgICAgIC8vIHNjYWxlIGlucHV0IGlzIGEgMUQgdGVuc29yXG4gICAgICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICBsZXQgc2NhbGVfaW5kZXggPSAke291dHB1dC5pbmRpY2VzR2V0KCdvdXRwdXRfaW5kaWNlcycsICd1bmlmb3Jtcy5heGlzJyl9O1xuICAgICAgICAgICAgbGV0IHNjYWxlX3ZhbHVlPSAke3NjYWxlLmdldEJ5T2Zmc2V0KCdzY2FsZV9pbmRleCcpfTtgO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gQmxvY2sgcXVhbnRpemF0aW9uLiBTY2FsZSBpbnB1dCByYW5rIGlzIHNhbWUgYXMgaW5wdXQvb3V0cHV0IHJhbmsuXG4gICAgICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICB2YXIgc2NhbGVfaW5kaWNlczogJHtzY2FsZS50eXBlLmluZGljZXN9ID0gb3V0cHV0X2luZGljZXM7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAke3NjYWxlLmluZGljZXNHZXQoJ3NjYWxlX2luZGljZXMnLCAndW5pZm9ybXMuYXhpcycpfSAvIHVuaWZvcm1zLmJsb2NrX3NpemU7XG4gICAgICAgICAgICAke3NjYWxlLmluZGljZXNTZXQoJ3NjYWxlX2luZGljZXMnLCAndW5pZm9ybXMuYXhpcycsICdpbmRleCcpfTtcbiAgICAgICAgICAgIGxldCBzY2FsZV92YWx1ZT0gJHtzY2FsZS5nZXRCeUluZGljZXMoJ3NjYWxlX2luZGljZXMnKX07YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSgpfTtcblxuICAgICAgICAgIC8vIFNldCB6ZXJvLXBvaW50IGlucHV0XG4gICAgICAgICAgJHsoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHplcm9Qb2ludCkge1xuICAgICAgICAgICAgICBpZiAocGVyTGF5ZXJRdWFudGl6YXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyB6ZXJvLXBvaW50IGlucHV0IGlzIGEgc2NhbGFyXG4gICAgICAgICAgICAgICAgaWYgKGlzUGFja2VkKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2lucHV0ID0gJHt6ZXJvUG9pbnQuZ2V0QnlPZmZzZXQoJzAnKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmVjID0gICR7aXNTaWduZWQgPyAndW5wYWNrNHhJOCh6ZXJvX3BvaW50X2lucHV0KScgOiAndW5wYWNrNHhVOCh6ZXJvX3BvaW50X2lucHV0KSd9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZhbHVlPSB6ZXJvX3BvaW50X3ZlY1swXWA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSAke3plcm9Qb2ludC5nZXRCeU9mZnNldCgnMCcpfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBlckF4aXNRdWFudGl6YXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyB6ZXJvLXBvaW50IGlucHV0IGlzIGEgMUQgdGVuc29yXG4gICAgICAgICAgICAgICAgaWYgKGlzUGFja2VkKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2luZGV4ID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCAndW5pZm9ybXMuYXhpcycpfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbnB1dCA9ICR7emVyb1BvaW50LmdldEJ5T2Zmc2V0KCd6ZXJvX3BvaW50X2luZGV4IC8gNCcpfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92ZWMgPSAgJHtpc1NpZ25lZCA/ICd1bnBhY2s0eEk4KHplcm9fcG9pbnRfaW5wdXQpJyA6ICd1bnBhY2s0eFU4KHplcm9fcG9pbnRfaW5wdXQpJ307XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSB6ZXJvX3BvaW50X3ZlY1t6ZXJvX3BvaW50X2luZGV4ICUgNF1gO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2luZGV4ID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCAndW5pZm9ybXMuYXhpcycpfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92YWx1ZSA9ICR7emVyb1BvaW50LmdldEJ5T2Zmc2V0KCd6ZXJvX3BvaW50X2luZGV4Jyl9O2A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEJsb2NrZWRRdWFudGl6YXRpb24uIFRoZSB6ZXJvLXBvaW50IGlucHV0IHNoYXBlIGlzIHNhbWUgYXMgdGhlIGlucHV0IHNoYXBlIGV4Y2VwdCBhbG9uZyBheGlzLlxuICAgICAgICAgICAgICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9vZmZzZXQgPSAke3NjYWxlLmluZGljZXNUb09mZnNldCgnc2NhbGVfaW5kaWNlcycpfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbnB1dCA9ICR7emVyb1BvaW50LmdldEJ5T2Zmc2V0KCd6ZXJvX3BvaW50X29mZnNldCAvIDQnKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmVjID0gJHtpc1NpZ25lZCA/ICd1bnBhY2s0eEk4KHplcm9fcG9pbnRfaW5wdXQpJyA6ICd1bnBhY2s0eFU4KHplcm9fcG9pbnRfaW5wdXQpJ307XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSB6ZXJvX3BvaW50X3ZlY1t6ZXJvX3BvaW50X29mZnNldCAlIDRdO2A7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSAke3plcm9Qb2ludC5nZXRCeUluZGljZXMoJ3NjYWxlX2luZGljZXMnKX07YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSAke2lzUGFja2VkID8gKGlzU2lnbmVkID8gJ2kzMicgOiAndTMyJykgOiBpbnB1dC50eXBlLnZhbHVlfSgwKTtgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKCl9O1xuICAgICAgLy8gQ29tcHV0ZSBhbmQgd3JpdGUgb3V0cHV0XG4gICAgICAke291dHB1dC5zZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcsIGAke291dHB1dC50eXBlLnZhbHVlfSh4X3ZhbHVlIC0gemVyb19wb2ludF92YWx1ZSkgKiBzY2FsZV92YWx1ZWApfTtcbiAgICAgIH1gO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdEZXF1YW50aXplTGluZWFyJyxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYXR0cmlidXRlcy5jYWNoZUtleSxcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiB6ZXJvUG9pbnQgPyBbJ3JhbmsnLCAncmFuaycsICdyYW5rJ10gOiBbJ3JhbmsnLCAncmFuayddLFxuICAgIH0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gY29tcG9uZW50cyAvIDY0KSwgeTogMSwgejogMSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGRlcXVhbnRpemVMaW5lYXIgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IERlcXVhbnRpemVMaW5lckF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlRGVxdWFudGl6ZUxpbmVhclByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzKSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VEZXF1YW50aXplTGluZWFyQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IERlcXVhbnRpemVMaW5lckF0dHJpYnV0ZXMgPT5cbiAgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgYXhpczogYXR0cmlidXRlcy5heGlzIGFzIG51bWJlciwgYmxvY2tTaXplOiBhdHRyaWJ1dGVzLmJsb2NrU2l6ZSBhcyBudW1iZXIgfSk7XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IGVudiB9IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQsIFByb2dyYW1JbmZvLCBQcm9ncmFtVW5pZm9ybSB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIFVuaWZvcm1EYXRhRWxlbWVudFR5cGUsXG4gIFVuaWZvcm1zQXJyYXlUeXBlLFxufSBmcm9tICcuL2NvbW1vbic7XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzQ29udGVudCA9IChzdGFydDogbnVtYmVyLCBsaW1pdDogbnVtYmVyLCBkZWx0YTogbnVtYmVyKTogdm9pZCA9PiB7XG4gIGNvbnN0IHNhbWVTdGFydExpbWl0ID0gc3RhcnQgPT09IGxpbWl0O1xuICBjb25zdCBpbmNyZWFzaW5nUmFuZ2VOZWdhdGl2ZVN0ZXAgPSBzdGFydCA8IGxpbWl0ICYmIGRlbHRhIDwgMDtcbiAgY29uc3QgZGVjcmVhc2luZ1JhbmdlUG9zaXRpdmVTdGVwID0gc3RhcnQgPiBsaW1pdCAmJiBkZWx0YSA+IDA7XG5cbiAgaWYgKHNhbWVTdGFydExpbWl0IHx8IGluY3JlYXNpbmdSYW5nZU5lZ2F0aXZlU3RlcCB8fCBkZWNyZWFzaW5nUmFuZ2VQb3NpdGl2ZVN0ZXApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYW5nZSB0aGVzZSBpbnB1dHMnIGNvbnRlbnRzIGFyZSBpbnZhbGlkLlwiKTtcbiAgfVxufTtcblxuY29uc3QgY3JlYXRlUmFuZ2VQcm9ncmFtSW5mbyA9IChzdGFydDogbnVtYmVyLCBsaW1pdDogbnVtYmVyLCBkZWx0YTogbnVtYmVyLCBkYXRhVHlwZTogRGF0YVR5cGUpOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IG51bUVsZW1lbnRzID0gTWF0aC5hYnMoTWF0aC5jZWlsKChsaW1pdCAtIHN0YXJ0KSAvIGRlbHRhKSk7XG4gIGNvbnN0IG91dHB1dFNoYXBlOiBudW1iZXJbXSA9IFtudW1FbGVtZW50c107XG4gIGNvbnN0IG91dHB1dFNpemUgPSBudW1FbGVtZW50cztcbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgeyB0eXBlOiBkYXRhVHlwZSwgZGF0YTogc3RhcnQgfSxcbiAgICB7IHR5cGU6IGRhdGFUeXBlLCBkYXRhOiBkZWx0YSB9LFxuICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKG91dHB1dFNoYXBlKSxcbiAgXTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IHtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgZGF0YVR5cGUsIG91dHB1dFNoYXBlLmxlbmd0aCk7XG4gICAgY29uc3Qgd2dzbFR5cGUgPSBvdXRwdXQudHlwZS52YWx1ZTtcbiAgICBjb25zdCB1bmlmb3JtczogVW5pZm9ybXNBcnJheVR5cGUgPSBbXG4gICAgICB7IG5hbWU6ICdvdXRwdXRTaXplJywgdHlwZTogJ3UzMicgfSxcbiAgICAgIHsgbmFtZTogJ3N0YXJ0JywgdHlwZTogd2dzbFR5cGUgYXMgVW5pZm9ybURhdGFFbGVtZW50VHlwZSB9LFxuICAgICAgeyBuYW1lOiAnZGVsdGEnLCB0eXBlOiB3Z3NsVHlwZSBhcyBVbmlmb3JtRGF0YUVsZW1lbnRUeXBlIH0sXG4gICAgXTtcbiAgICByZXR1cm4gYFxuICAgICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm1zKHVuaWZvcm1zKS5kZWNsYXJlVmFyaWFibGVzKG91dHB1dCl9XG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRTaXplJyl9XG4gICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHVuaWZvcm1zLnN0YXJ0ICsgJHt3Z3NsVHlwZX0oZ2xvYmFsX2lkeCkgKiB1bmlmb3Jtcy5kZWx0YTtcbiAgICAgIH1gO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1JhbmdlJyxcbiAgICBzaGFkZXJDYWNoZTogeyBoaW50OiBgJHtkYXRhVHlwZX1gIH0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBvdXRwdXRTaGFwZSwgZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gNjQgLyogd29ya2dyb3VwIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXMsXG4gICAgfSksXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgcmFuZ2UgPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQpOiB2b2lkID0+IHtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGxpbWl0ID0gMDtcbiAgbGV0IGRlbHRhID0gMDtcbiAgaWYgKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlID09PSBEYXRhVHlwZS5pbnQzMikge1xuICAgIHN0YXJ0ID0gY29udGV4dC5pbnB1dHNbMF0uZ2V0SW50MzJBcnJheSgpWzBdO1xuICAgIGxpbWl0ID0gY29udGV4dC5pbnB1dHNbMV0uZ2V0SW50MzJBcnJheSgpWzBdO1xuICAgIGRlbHRhID0gY29udGV4dC5pbnB1dHNbMl0uZ2V0SW50MzJBcnJheSgpWzBdO1xuICB9IGVsc2UgaWYgKGNvbnRleHQuaW5wdXRzWzBdLmRhdGFUeXBlID09PSBEYXRhVHlwZS5mbG9hdCkge1xuICAgIHN0YXJ0ID0gY29udGV4dC5pbnB1dHNbMF0uZ2V0RmxvYXQzMkFycmF5KClbMF07XG4gICAgbGltaXQgPSBjb250ZXh0LmlucHV0c1sxXS5nZXRGbG9hdDMyQXJyYXkoKVswXTtcbiAgICBkZWx0YSA9IGNvbnRleHQuaW5wdXRzWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdO1xuICB9XG4gIGlmIChlbnYud2ViZ3B1LnZhbGlkYXRlSW5wdXRDb250ZW50KSB7XG4gICAgdmFsaWRhdGVJbnB1dHNDb250ZW50KHN0YXJ0LCBsaW1pdCwgZGVsdGEpO1xuICB9XG5cbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVJhbmdlUHJvZ3JhbUluZm8oc3RhcnQsIGxpbWl0LCBkZWx0YSwgY29udGV4dC5pbnB1dHNbMF0uZGF0YVR5cGUpLCB7IGlucHV0czogW10gfSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbyB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtcbiAgY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMsXG4gIGdldEVsZW1lbnRBdCxcbiAgSW5kaWNlc0hlbHBlcixcbiAgaW5wdXRWYXJpYWJsZSxcbiAgb3V0cHV0VmFyaWFibGUsXG4gIFNoYWRlckhlbHBlcixcbn0gZnJvbSAnLi9jb21tb24nO1xuXG50eXBlIENvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlID1cbiAgfCAnaGFsZl9waXhlbCdcbiAgfCAnYXN5bW1ldHJpYydcbiAgfCAncHl0b3JjaF9oYWxmX3BpeGVsJ1xuICB8ICd0Zl9oYWxmX3BpeGVsX2Zvcl9ubidcbiAgfCAnYWxpZ25fY29ybmVycydcbiAgfCAndGZfY3JvcF9hbmRfcmVzaXplJ1xuICB8ICdoYWxmX3BpeGVsX3N5bW1ldHJpYyc7XG5cbnR5cGUgS2VlcEFzcGVjdFJhdGlvUG9saWN5ID0gJ3N0cmV0Y2gnIHwgJ25vdF9zbWFsbGVyJyB8ICdub3RfbGFyZ2VyJztcblxudHlwZSBNb2RlID0gJ25lYXJlc3QnIHwgJ2xpbmVhcicgfCAnY3ViaWMnO1xuXG50eXBlIE5lYXJlc3RNb2RlID0gJ3JvdW5kX3ByZWZlcl9mbG9vcicgfCAncm91bmRfcHJlZmVyX2NlaWwnIHwgJ2Zsb29yJyB8ICdjZWlsJyB8ICdzaW1wbGUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlc2l6ZUF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICBhbnRpYWxpYXM6IG51bWJlcjtcbiAgYXhlczogbnVtYmVyW107XG4gIGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOiBDb29yZGluYXRlVHJhbnNmb3JtTW9kZTtcbiAgY3ViaWNDb2VmZkE6IG51bWJlcjtcbiAgZXhjbHVkZU91dHNpZGU6IGJvb2xlYW47XG4gIGV4dHJhcG9sYXRpb25WYWx1ZTogbnVtYmVyO1xuICBrZWVwQXNwZWN0UmF0aW9Qb2xpY3k6IEtlZXBBc3BlY3RSYXRpb1BvbGljeTtcbiAgbW9kZTogTW9kZTtcbiAgbmVhcmVzdE1vZGU6IE5lYXJlc3RNb2RlO1xufVxuXG5jb25zdCB2YWxpZGF0ZVNjYWxlcyA9IChzY2FsZXM6IG51bWJlcltdLCBhdHRyaWJ1dGVzOiBSZXNpemVBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHNjYWxlcy5ldmVyeShcbiAgICAodmFsdWUpID0+XG4gICAgICB2YWx1ZSA+IDAgfHxcbiAgICAgICgoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCB2YWx1ZXMgdG8gYmUgcG9zaXRpdmUnKTtcbiAgICAgIH0pLFxuICApO1xuICAvLyBDaGVjayBzY2FsZXMgZGltcyBiYXNlZCBvbiBtb2RlOiBMSU5FQVIsIENVQklDXG4gIGlmIChzY2FsZXMubGVuZ3RoID4gMCkge1xuICAgIGlmIChhdHRyaWJ1dGVzLm1vZGUgPT09ICdsaW5lYXInKSB7XG4gICAgICBpZiAoXG4gICAgICAgICEoXG4gICAgICAgICAgc2NhbGVzLmxlbmd0aCA9PT0gMiB8fFxuICAgICAgICAgIHNjYWxlcy5sZW5ndGggPT09IDMgfHxcbiAgICAgICAgICAoc2NhbGVzLmxlbmd0aCA9PT0gNCAmJiBzY2FsZXNbMF0gPT09IDEgJiYgc2NhbGVzWzFdID09PSAxKSB8fFxuICAgICAgICAgIChzY2FsZXMubGVuZ3RoID09PSA0ICYmIHNjYWxlc1swXSA9PT0gMSAmJiBzY2FsZXNbM10gPT09IDEpIHx8XG4gICAgICAgICAgKHNjYWxlcy5sZW5ndGggPT09IDUgJiYgc2NhbGVzWzBdID09PSAxICYmIHNjYWxlc1sxXSA9PT0gMSlcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRm9yIGxpbmVhciBtb2RlLCBSZXNpemUgcmVxdWlyZXMgc2NhbGVzIHRvIGJlIDJELCAzRCwgNEQgd2l0aCBlaXRoZXIgdHdvIG91dGVybW9zdCBvciBvbmUgaW5uZXJtb3N0IGFuZFxuICAgICAgICAgICAgb25lIG91dGVybW9zdCBzY2FsZSB2YWx1ZXMgZXF1YWwgdG8gMSwgb3IgNUQgd2l0aCB0d28gb3V0ZXJtb3N0IHNjYWxlIHZhbHVlcyBlcXVhbCB0byAxYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXMubW9kZSA9PT0gJ2N1YmljJykge1xuICAgICAgaWYgKFxuICAgICAgICAhKFxuICAgICAgICAgIHNjYWxlcy5sZW5ndGggPT09IDIgfHxcbiAgICAgICAgICAoc2NhbGVzLmxlbmd0aCA9PT0gNCAmJiBzY2FsZXNbMF0gPT09IDEgJiYgc2NhbGVzWzFdID09PSAxKSB8fFxuICAgICAgICAgIChzY2FsZXMubGVuZ3RoID09PSA0ICYmIHNjYWxlc1swXSA9PT0gMSAmJiBzY2FsZXNbM10gPT09IDEpXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgc2l6ZSB0byBiZSAyIG9yIDQgZm9yIGN1YmljIG1vZGUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IHVwZGF0ZVNjYWxlcyA9IChzY2FsZXM6IHJlYWRvbmx5IG51bWJlcltdLCBheGVzOiByZWFkb25seSBudW1iZXJbXSwgcmFuazogbnVtYmVyKTogbnVtYmVyW10gPT4ge1xuICBheGVzLmV2ZXJ5KFxuICAgICh2YWx1ZSkgPT5cbiAgICAgICh2YWx1ZSA+PSAwICYmIHZhbHVlIDwgcmFuaykgfHxcbiAgICAgICgoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIGF4ZXMgaW5wdXQgdmFsdWVzIHRvIGJlIHBvc2l0aXZlIGFuZCBsZXNzIHRoYW4gcmFuaycpO1xuICAgICAgfSksXG4gICk7XG4gIGNvbnN0IG5ld1NjYWxlcyA9IG5ldyBBcnJheShyYW5rKS5maWxsKDEuMCk7XG4gIGF4ZXMuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiAobmV3U2NhbGVzW3ZhbHVlXSA9IHNjYWxlc1tpbmRleF0pKTtcbiAgcmV0dXJuIG5ld1NjYWxlcztcbn07XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogUmVzaXplQXR0cmlidXRlcyxcbiAgb3BzZXRWZXJzaW9uOiBudW1iZXIsXG4gIHNjYWxlczogbnVtYmVyW10sXG4gIHNpemVzOiBudW1iZXJbXSxcbiAgcm9pOiBudW1iZXJbXSxcbik6IHZvaWQgPT4ge1xuICBjb25zdCBbcm9pSW5wdXRJbmRleCwgc2NhbGVzSW5wdXRJbmRleCwgc2l6ZXNJbnB1dEluZGV4XSA9XG4gICAgb3BzZXRWZXJzaW9uID4gMTAgPyBbMSwgMiwgM10gOiBbLTEsIGlucHV0cy5sZW5ndGggPiAxID8gMSA6IC0xLCAtMV07XG4gIGNvbnN0IHJhbmsgPSBpbnB1dHNbMF0uZGltcy5sZW5ndGg7XG4gIGlmIChyb2lJbnB1dEluZGV4ID4gMCAmJiBpbnB1dHMubGVuZ3RoID4gcm9pSW5wdXRJbmRleCAmJiBpbnB1dHNbcm9pSW5wdXRJbmRleF0uZGltcy5sZW5ndGggPiAwKSB7XG4gICAgaW5wdXRzW3JvaUlucHV0SW5kZXhdLmdldEZsb2F0MzJBcnJheSgpLmZvckVhY2goKHZhbHVlKSA9PiByb2kucHVzaCh2YWx1ZSkpO1xuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZXMuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUgPT09ICd0Zl9jcm9wX2FuZF9yZXNpemUnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgUm9JIGlucHV0IHRvIGJlIHNwZWNpZmllZCB3aGVuIGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlIGlzIHRmQ3JvcEFuZFJlc2l6ZScpO1xuICB9XG5cbiAgaWYgKHNjYWxlc0lucHV0SW5kZXggPiAwICYmIGlucHV0cy5sZW5ndGggPiBzY2FsZXNJbnB1dEluZGV4ICYmIGlucHV0c1tzY2FsZXNJbnB1dEluZGV4XS5kaW1zLmxlbmd0aCA+IDApIHtcbiAgICBpbnB1dHNbc2NhbGVzSW5wdXRJbmRleF0uZ2V0RmxvYXQzMkFycmF5KCkuZm9yRWFjaCgodmFsdWUpID0+IHNjYWxlcy5wdXNoKHZhbHVlKSk7XG4gICAgaWYgKFxuICAgICAgc2NhbGVzLmxlbmd0aCAhPT0gMCAmJlxuICAgICAgc2NhbGVzLmxlbmd0aCAhPT0gcmFuayAmJlxuICAgICAgb3BzZXRWZXJzaW9uID49IDE4ICYmXG4gICAgICBzY2FsZXMubGVuZ3RoICE9PSBhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgc2l6ZSB0byBiZSBzYW1lIGFzIGlucHV0IHJhbmsgb3IgYXhlcyBzaXplIGZvciBvcHNldCAxOCBhbmQgdXAnKTtcbiAgICB9XG4gICAgdmFsaWRhdGVTY2FsZXMoc2NhbGVzLCBhdHRyaWJ1dGVzKTtcbiAgICBpZiAoYXR0cmlidXRlcy5heGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHVwZGF0ZVNjYWxlcyhzY2FsZXMsIGF0dHJpYnV0ZXMuYXhlcywgcmFuaykuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiAoc2NhbGVzW2luZGV4XSA9IHZhbHVlKSk7XG4gICAgfVxuICB9XG4gIGlmIChzaXplc0lucHV0SW5kZXggPiAwICYmIGlucHV0cy5sZW5ndGggPiBzaXplc0lucHV0SW5kZXgpIHtcbiAgICBpbnB1dHNbc2l6ZXNJbnB1dEluZGV4XS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaCgodmFsdWUpID0+IHNpemVzLnB1c2goTnVtYmVyKHZhbHVlKSkpO1xuICAgIGlmIChzaXplcy5sZW5ndGggIT09IHJhbmsgfHwgKG9wc2V0VmVyc2lvbiA+PSAxOCAmJiBzaXplcy5sZW5ndGggPT09IGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBzaXplcyBpbnB1dCBzaXplIHRvIGJlIHNhbWUgYXMgaW5wdXQgcmFuayBvciBheGVzIHNpemUgZm9yIG9wc2V0IDE4IGFuZCB1cCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoID4gMCkge1xuICAgIGlmIChzY2FsZXMubGVuZ3RoICE9PSBhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBcInNjYWxlc1wiIGlucHV0IHNpemUgdG8gYmUgb2YgYXhlcyByYW5rIHdoZW4gYXhlcyBhdHRyaWJ1dGVzIGlzIHNwZWNpZmllZCcpO1xuICAgIH1cbiAgICBpZiAoc2l6ZXMubGVuZ3RoICE9PSBhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBcInNpemVzXCIgaW5wdXQgc2l6ZSB0byBiZSBvZiByYW5rIGF4ZXMgcmFuayB3aGVuIGF4ZXMgYXR0cmlidXRlcyBpcyBzcGVjaWZpZWQnKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBzY2FsZXMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBzaXplcyAhPT0gJ3VuZGVmaW5lZCcgJiYgc2NhbGVzLmxlbmd0aCA+IDAgJiYgc2l6ZXMubGVuZ3RoID4gcmFuaykge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIG9ubHkgb2Ygc2NhbGVzIG9yIHNpemVzIHRvIGJlIHNwZWNpZmllZCcpO1xuICB9XG59O1xuXG5jb25zdCBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUgPSAoXG4gIGNvb3JkaW5hdGVUcmFuc2Zlck1vZGU6IENvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlLFxuICBkVHlwZTogc3RyaW5nLFxuKTogc3RyaW5nID0+XG4gIGBmbiBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUoeFJlc2l6ZWQ6IHUzMiwgeFNjYWxlOiBmMzIsIGxlbmd0aFJlc2l6ZWQ6IHUzMixcbiAgICAgbGVuZ3RoT3JpZ2luYWw6IHUzMiwgcm9pU3RhcnQ6IGYzMiwgcm9pRW5kOiBmMzIpIC0+ICR7ZFR5cGV9IHsgYCArXG4gICgoKSA9PiB7XG4gICAgc3dpdGNoIChjb29yZGluYXRlVHJhbnNmZXJNb2RlKSB7XG4gICAgICBjYXNlICdhc3ltbWV0cmljJzpcbiAgICAgICAgcmV0dXJuIGByZXR1cm4gJHtkVHlwZX0oeFJlc2l6ZWQpIC8gJHtkVHlwZX0oeFNjYWxlKTtgO1xuICAgICAgY2FzZSAncHl0b3JjaF9oYWxmX3BpeGVsJzpcbiAgICAgICAgcmV0dXJuIGBpZiAobGVuZ3RoUmVzaXplZCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgke2RUeXBlfSh4UmVzaXplZCkgKyAwLjUpIC8gJHtkVHlwZX0oeFNjYWxlKSAtIDAuNTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgICAgICAgICAgICB9YDtcbiAgICAgIGNhc2UgJ3RmX2hhbGZfcGl4ZWxfZm9yX25uJzpcbiAgICAgICAgcmV0dXJuIGByZXR1cm4gKCR7ZFR5cGV9KHhSZXNpemVkKSArIDAuNSkgLyAke2RUeXBlfSh4U2NhbGUpO2A7XG4gICAgICBjYXNlICdhbGlnbl9jb3JuZXJzJzpcbiAgICAgICAgcmV0dXJuIGBpZiAobGVuZ3RoUmVzaXplZCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgd2hvbGUgcGFydCBhbmQgdGhlIGZyYWN0aW9uYWwgcGFydCBhcmUgY2FsY3VsYXRlZCBzZXBhcmF0ZWx5IGR1ZSB0byBpbmFjY3VyYWN5IG9mIGZsb2F0aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIHBvaW50IGRpdmlzaW9uLiBBcyBhbiBleGFtcGxlLCBmMzIoMjEpIC8gZjMyKDcpIG1heSBldmFsdWF0ZSB0byAyLjk5Li4uIGluc3RlYWQgb2YgMywgY2F1c2luZyBhblxuICAgICAgICAgICAgICAgICAgICAvLyBvZmZzZXQtYnktb25lIGVycm9yIGxhdGVyIGluIGZsb29yKCkuXG4gICAgICAgICAgICAgICAgICAgIGxldCB3aG9sZSA9ICR7ZFR5cGV9KHhSZXNpemVkICogKGxlbmd0aE9yaWdpbmFsIC0gMSkgLyAobGVuZ3RoUmVzaXplZCAtIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZyYWN0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICR7ZFR5cGV9KHhSZXNpemVkICogKGxlbmd0aE9yaWdpbmFsIC0gMSkgJSAobGVuZ3RoUmVzaXplZCAtIDEpKSAvICR7ZFR5cGV9KGxlbmd0aFJlc2l6ZWQgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdob2xlICsgZnJhY3Q7XG4gICAgICAgICAgICAgICAgICB9YDtcbiAgICAgIGNhc2UgJ3RmX2Nyb3BfYW5kX3Jlc2l6ZSc6XG4gICAgICAgIHJldHVybiBgaWYgKGxlbmd0aFJlc2l6ZWQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAke2RUeXBlfShyb2lTdGFydCkgKiAke2RUeXBlfShsZW5ndGhPcmlnaW5hbCAtIDEpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICgke2RUeXBlfSh4UmVzaXplZCkgKiAke2RUeXBlfShyb2lFbmQgLSByb2lTdGFydCkgKiAke2RUeXBlfShsZW5ndGhPcmlnaW5hbCAtIDEpKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAke2RUeXBlfShsZW5ndGhSZXNpemVkIC0gMSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogJHtkVHlwZX0ocm9pU3RhcnQgKyByb2lFbmQpICogJHtkVHlwZX0obGVuZ3RoT3JpZ2luYWwgLSAxKTtcbiAgICAgICAgICAgICAgICAgIH1gO1xuICAgICAgY2FzZSAnaGFsZl9waXhlbF9zeW1tZXRyaWMnOlxuICAgICAgICByZXR1cm4gYGNvbnN0IG91dHB1dFdpZHRoID0gJHtkVHlwZX14U2NhbGUgKiAke2RUeXBlfShsZW5ndGhSZXNpemVkKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGFkanVzdG1lbnQgPSAke2RUeXBlfShsZW5ndGhSZXNpemVkKSAvIG91dHB1dFdpZHRoO1xuICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyID0gJHtkVHlwZX0obGVuZ3RoT3JpZ2luYWwpIC8gMjtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGNlbnRlciAqICgxIC0gYWRqdXN0bWVudCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0ICsgKCgke2RUeXBlfSh4UmVzaXplZCkgKyAwLjUpIC8gJHtkVHlwZX0oeFNjYWxlKSkgLSAwLjU7YDtcbiAgICAgIGNhc2UgJ2hhbGZfcGl4ZWwnOlxuICAgICAgICByZXR1cm4gYHJldHVybiAoKCR7ZFR5cGV9KHhSZXNpemVkKSArIDAuNSkgLyAke2RUeXBlfSh4U2NhbGUpKSAtIDAuNTtgO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb29yZGluYXRlIHRyYW5zZm9ybSBtb2RlICR7Y29vcmRpbmF0ZVRyYW5zZmVyTW9kZX0gaXMgbm90IHN1cHBvcnRlZGApO1xuICAgIH1cbiAgfSkoKSArXG4gICd9JztcblxuY29uc3QgZ2V0TmVhcmVzdFBpeGVsRnJvbU9yaWdpbmFsID0gKG5lYXJlc3RNb2RlOiBOZWFyZXN0TW9kZSwgb3BzZXRWZXJzaW9uOiBudW1iZXIsIGRUeXBlOiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAgYGZuIGdldE5lYXJlc3RQaXhlbEZyb21PcmlnaW5hbCh4T3JpZ2luYWw6ICR7ZFR5cGV9LCBpc0Rvd25TYW1wbGU6IGJvb2wpIC0+ICR7ZFR5cGV9IHtgICtcbiAgKCgpID0+IHtcbiAgICBzd2l0Y2ggKG5lYXJlc3RNb2RlKSB7XG4gICAgICBjYXNlICdyb3VuZF9wcmVmZXJfY2VpbCc6XG4gICAgICAgIHJldHVybiAnaWYgKGZyYWN0KHhPcmlnaW5hbCkgPT0gMC41KSB7IFxcXG4gICAgICAgICAgICByZXR1cm4gY2VpbCh4T3JpZ2luYWwpOyBcXFxuICAgICAgICAgIH0gZWxzZSB7IFxcXG4gICAgICAgICAgICByZXR1cm4gcm91bmQoeE9yaWdpbmFsKTsgXFxcbiAgICAgICAgICB9JztcbiAgICAgIGNhc2UgJ2Zsb29yJzpcbiAgICAgICAgcmV0dXJuICdyZXR1cm4gZmxvb3IoeE9yaWdpbmFsKTsnO1xuICAgICAgY2FzZSAnY2VpbCc6XG4gICAgICAgIHJldHVybiAncmV0dXJuIGNlaWwoeE9yaWdpbmFsKTsnO1xuICAgICAgY2FzZSAncm91bmRfcHJlZmVyX2Zsb29yJzpcbiAgICAgICAgcmV0dXJuICdpZiAoZnJhY3QoeE9yaWdpbmFsKSA9PSAwLjUpIHsgXFxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsb29yKHhPcmlnaW5hbCk7IFxcXG4gICAgICAgICAgICAgICAgICB9IGVsc2UgeyBcXFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm91bmQoeE9yaWdpbmFsKTsgXFxcbiAgICAgICAgICAgICAgICAgIH0nO1xuICAgICAgY2FzZSAnc2ltcGxlJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChvcHNldFZlcnNpb24gPCAxMSkge1xuICAgICAgICAgIHJldHVybiAnaWYgKGlzRG93blNhbXBsZSkgXFxcbiAgICAgICAgICAgICAgICAgICAgeyBcXFxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjZWlsKHhPcmlnaW5hbCk7IFxcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IFxcXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhPcmlnaW5hbDsgXFxcbiAgICAgICAgICAgICAgICAgICAgfSc7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZWFyZXN0IG1vZGUgJHtuZWFyZXN0TW9kZX0gaXMgbm90IHN1cHBvcnRlZGApO1xuICAgIH1cbiAgfSkoKSArXG4gICd9JztcblxuY29uc3QgdXBkYXRlUm9JID0gKHJvaTogcmVhZG9ubHkgbnVtYmVyW10sIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLCByYW5rOiBudW1iZXIpOiBudW1iZXJbXSA9PiB7XG4gIGNvbnN0IHJvaVRtcCA9IG5ldyBBcnJheShyYW5rKS5maWxsKDApLmNvbmNhdChuZXcgQXJyYXkocmFuaykuZmlsbCgxKSk7XG4gIGNvbnN0IHJvaUxvY2FsID0gcm9pLmxlbmd0aCA9PT0gMCA/IHJvaVRtcCA6IHJvaS5zbGljZSgpO1xuICBpZiAoYXhlcy5sZW5ndGggPiAwKSB7XG4gICAgYXhlcy5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgICByb2lUbXBbdl0gPSByb2lMb2NhbFtpXTtcbiAgICAgIHJvaVRtcFtpICsgcmFua10gPSByb2lMb2NhbFtheGVzLmxlbmd0aCArIGldO1xuICAgIH0pO1xuICAgIHJldHVybiByb2lUbXA7XG4gIH1cbiAgcmV0dXJuIHJvaUxvY2FsO1xufTtcblxuY29uc3QgaW5pdE91dHB1dFNoYXBlID0gKFxuICBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgc2NhbGVzOiByZWFkb25seSBudW1iZXJbXSxcbiAgc2l6ZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICBheGVzOiByZWFkb25seSBudW1iZXJbXSxcbik6IG51bWJlcltdID0+IHtcbiAgbGV0IG91dHB1dFNoYXBlOiBudW1iZXJbXSA9IFtdO1xuICBpZiAoc2l6ZXMubGVuZ3RoID4gMCkge1xuICAgIGlmIChheGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGlucHV0U2hhcGUuZm9yRWFjaCgodikgPT4gb3V0cHV0U2hhcGUucHVzaCh2KSk7XG4gICAgICBpZiAoTWF0aC5tYXgoLi4uYXhlcykgPiBpbnB1dFNoYXBlLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F4ZXMgaXMgb3V0IG9mIGJvdW5kJyk7XG4gICAgICB9XG4gICAgICBheGVzLmZvckVhY2goKHYsIGkpID0+IChvdXRwdXRTaGFwZVt2XSA9IHNpemVzW2ldKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpemVzLmZvckVhY2goKHYpID0+IG91dHB1dFNoYXBlLnB1c2godikpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc2NhbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgZWl0aGVyIHNjYWxlcyBvciBzaXplcy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlLm1hcCgodmFsdWUsIGluZGV4KSA9PiBNYXRoLnJvdW5kKHZhbHVlICogc2NhbGVzW2luZGV4XSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0cHV0U2hhcGU7XG59O1xuXG5jb25zdCBhZGp1c3RPdXRwdXRTaGFwZSA9IChpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSwgc2NhbGVzOiBudW1iZXJbXSwgYXR0cmlidXRlczogUmVzaXplQXR0cmlidXRlcykgPT4ge1xuICBjb25zdCBzY2FsZUluUG9saWN5ID0gKCgpID0+IHtcbiAgICBzd2l0Y2ggKGF0dHJpYnV0ZXMua2VlcEFzcGVjdFJhdGlvUG9saWN5KSB7XG4gICAgICBjYXNlICdub3RfbGFyZ2VyJzpcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggPiAwXG4gICAgICAgICAgPyBNYXRoLm1pbiguLi5hdHRyaWJ1dGVzLmF4ZXMubWFwKChpKSA9PiBzY2FsZXNbaV0pLCBOdW1iZXIuTUFYX1ZBTFVFKVxuICAgICAgICAgIDogTWF0aC5taW4oLi4uc2NhbGVzLCBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICAgIGNhc2UgJ25vdF9zbWFsbGVyJzpcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXMuYXhlcy5sZW5ndGggPiAwXG4gICAgICAgICAgPyBNYXRoLm1heCguLi5hdHRyaWJ1dGVzLmF4ZXMubWFwKChpKSA9PiBzY2FsZXNbaV0pLCBOdW1iZXIuTUlOX1ZBTFVFKVxuICAgICAgICAgIDogTWF0aC5tYXgoLi4uc2NhbGVzLCBOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgS2VlcCBhc3BlY3QgcmF0aW8gcG9saWN5ICR7YXR0cmlidXRlcy5rZWVwQXNwZWN0UmF0aW9Qb2xpY3l9IGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICB9XG4gIH0pKCk7XG4gIHNjYWxlcy5maWxsKDEuMCwgMCwgc2NhbGVzLmxlbmd0aCk7XG4gIGNvbnN0IGFkanVzdGVkT3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlLnNsaWNlKCk7XG4gIGlmIChhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoID4gMCkge1xuICAgIGF0dHJpYnV0ZXMuYXhlcy5mb3JFYWNoKCh2KSA9PiAoc2NhbGVzW3ZdID0gc2NhbGVJblBvbGljeSkpO1xuICAgIGF0dHJpYnV0ZXMuYXhlcy5mb3JFYWNoKCh2KSA9PiAoYWRqdXN0ZWRPdXRwdXRTaGFwZVt2XSA9IE1hdGgucm91bmQoaW5wdXRTaGFwZVt2XSAqIHNjYWxlc1t2XSkpKTtcbiAgfSBlbHNlIHtcbiAgICBzY2FsZXMuZmlsbChzY2FsZUluUG9saWN5LCAwLCBzY2FsZXMubGVuZ3RoKTtcbiAgICBhZGp1c3RlZE91dHB1dFNoYXBlLmZvckVhY2goKHYsIGkpID0+IChhZGp1c3RlZE91dHB1dFNoYXBlW2ldID0gTWF0aC5yb3VuZCh2ICogc2NhbGVzW2ldKSkpO1xuICB9XG4gIHJldHVybiBhZGp1c3RlZE91dHB1dFNoYXBlO1xufTtcblxuY29uc3QgY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMgPSAoXG4gIG91dHB1dDogSW5kaWNlc0hlbHBlcixcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgc2NhbGVzTGVuZ3RoOiBudW1iZXIsXG4gIHJvaUxlbmd0aDogbnVtYmVyLFxuKTogc3RyaW5nID0+IGBcbiAgICBmbiBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gYXJyYXk8JHtcbiAgICAgIG91dHB1dC50eXBlLnZhbHVlXG4gICAgfSwgJHtvdXRwdXRTaGFwZS5sZW5ndGh9PiB7XG4gICAgICB2YXIgb3JpZ2luYWxfaW5kaWNlczogYXJyYXk8JHtvdXRwdXQudHlwZS52YWx1ZX0sICR7b3V0cHV0U2hhcGUubGVuZ3RofT47XG4gICAgICBmb3IgKHZhciBpOnUzMiA9IDA7IGkgPCAke291dHB1dFNoYXBlLmxlbmd0aH07IGkrKykge1xuICAgICAgICB2YXIgb3V0cHV0X2luZGV4ID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCAnaScpfTtcbiAgICAgICAgdmFyIHNjYWxlID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnNjYWxlcycsICdpJywgc2NhbGVzTGVuZ3RoKX07XG4gICAgICAgIHZhciByb2lfbG93ID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnJvaScsICdpJywgcm9pTGVuZ3RoKX07XG4gICAgICAgIHZhciByb2lfaGkgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucm9pJywgYGkgKyAke2lucHV0U2hhcGUubGVuZ3RofWAsIHJvaUxlbmd0aCl9O1xuICAgICAgICBpZiAoc2NhbGUgPT0gMS4wKSB7XG4gICAgICAgICAgb3JpZ2luYWxfaW5kaWNlc1tpXSA9ICR7b3V0cHV0LnR5cGUudmFsdWV9KG91dHB1dF9pbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGlucHV0X3NoYXBlX2kgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuaW5wdXRfc2hhcGUnLCAnaScsIGlucHV0U2hhcGUubGVuZ3RoKX07XG4gICAgICAgICAgdmFyIG91dHB1dF9zaGFwZV9pID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLm91dHB1dF9zaGFwZScsICdpJywgb3V0cHV0U2hhcGUubGVuZ3RoKX07XG4gICAgICAgICAgb3JpZ2luYWxfaW5kaWNlc1tpXSA9IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZShvdXRwdXRfaW5kZXgsIHNjYWxlLCBvdXRwdXRfc2hhcGVfaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0X3NoYXBlX2ksIHJvaV9sb3csIHJvaV9oaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnaW5hbF9pbmRpY2VzO1xuICAgIH1gO1xuXG5jb25zdCBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyA9IChcbiAgaW5wdXQ6IEluZGljZXNIZWxwZXIsXG4gIG91dHB1dDogSW5kaWNlc0hlbHBlcixcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIG91dHB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgc2NhbGVzTGVuZ3RoOiBudW1iZXIsXG4gIHJvaUxlbmd0aDogbnVtYmVyLFxuICB1c2VFeHRyYXBvbGF0aW9uOiBib29sZWFuLFxuKTogc3RyaW5nID0+IGBcbiAgICBmbiBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gJHtpbnB1dC50eXBlLmluZGljZXN9IHtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc307XG4gICAgICBmb3IgKHZhciBpOnUzMiA9IDA7IGkgPCAke291dHB1dFNoYXBlLmxlbmd0aH07IGkrKykge1xuICAgICAgICB2YXIgb3V0cHV0X2luZGV4ID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCAnaScpfTtcbiAgICAgICAgdmFyIGlucHV0X2luZGV4OiB1MzI7XG4gICAgICAgIHZhciBzY2FsZSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5zY2FsZXMnLCAnaScsIHNjYWxlc0xlbmd0aCl9O1xuICAgICAgICBpZiAoc2NhbGUgPT0gMS4wKSB7XG4gICAgICAgICAgaW5wdXRfaW5kZXggPSBvdXRwdXRfaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJvaV9sb3cgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMucm9pJywgJ2knLCByb2lMZW5ndGgpfTtcbiAgICAgICAgICB2YXIgcm9pX2hpID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnJvaScsIGBpICsgJHtpbnB1dFNoYXBlLmxlbmd0aH1gLCByb2lMZW5ndGgpfTtcbiAgICAgICAgICB2YXIgaW5wdXRfc2hhcGVfaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5pbnB1dF9zaGFwZScsICdpJywgaW5wdXRTaGFwZS5sZW5ndGgpfTtcbiAgICAgICAgICB2YXIgb3V0cHV0X3NoYXBlX2kgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMub3V0cHV0X3NoYXBlJywgJ2knLCBvdXRwdXRTaGFwZS5sZW5ndGgpfTtcbiAgICAgICAgICB2YXIgb3JpZ2luYWxfaWR4ID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKG91dHB1dF9pbmRleCwgc2NhbGUsIG91dHB1dF9zaGFwZV9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRfc2hhcGVfaSwgcm9pX2xvdywgcm9pX2hpKTtcbiAgICAgICAgICBpZiAoISR7dXNlRXh0cmFwb2xhdGlvbn0gfHwgKG9yaWdpbmFsX2lkeCA+PSAwICYmIG9yaWdpbmFsX2lkeCA8ICR7b3V0cHV0LnR5cGUudmFsdWV9KGlucHV0X3NoYXBlX2kpKSkge1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsX2lkeCA8IDApIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcmlnaW5hbF9pZHggPiAke291dHB1dC50eXBlLnZhbHVlfShpbnB1dF9zaGFwZV9pIC0gMSkpIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSBpbnB1dF9zaGFwZV9pIC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlucHV0X2luZGV4ID0gdTMyKGdldE5lYXJlc3RQaXhlbEZyb21PcmlnaW5hbChvcmlnaW5hbF9pZHgsIHNjYWxlIDwgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dF9pbmRleCA9IHUzMihvcmlnaW5hbF9pZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCAnaScsICcgaW5wdXRfaW5kZXgnKX1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnB1dF9pbmRpY2VzO1xuICAgIH1gO1xuY29uc3QgY2hlY2tJbnB1dEluZGljZXMgPSAoaW5wdXQ6IEluZGljZXNIZWxwZXIsIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdKTogc3RyaW5nID0+IGBcbiAgICBmbiBjaGVja0lucHV0SW5kaWNlcyhpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc30pIC0+IGJvb2wge1xuICAgICAgZm9yICh2YXIgaTp1MzIgPSAwOyBpIDwgJHtpbnB1dFNoYXBlLmxlbmd0aH07IGkrKykge1xuICAgICAgICB2YXIgaW5wdXRfaW5kZXggPSAke2lucHV0LmluZGljZXNHZXQoJ2lucHV0X2luZGljZXMnLCAnaScpfTtcbiAgICAgICAgaWYgKGlucHV0X2luZGV4IDwgMCB8fCBpbnB1dF9pbmRleCA+PSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuaW5wdXRfc2hhcGUnLCAnaScsIGlucHV0U2hhcGUubGVuZ3RoKX0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1gO1xuXG5jb25zdCBzZXRDaGFubmVsQW5kQmF0Y2hJbmRpY2VzID0gKFxuICBpbnB1dDogSW5kaWNlc0hlbHBlcixcbiAgY2hhbm5lbElkeDogbnVtYmVyLFxuICBiYXRjaElkeDogbnVtYmVyLFxuICBzcGFjaWFsRGltczogbnVtYmVyLFxuKTogc3RyaW5nID0+XG4gIGlucHV0LnJhbmsgPiBzcGFjaWFsRGltc1xuICAgID8gYFxuICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsIGNoYW5uZWxJZHgsICdjaGFubmVsJyl9O1xuICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsIGJhdGNoSWR4LCAnYmF0Y2gnKX07XG5gXG4gICAgOiAnJztcblxuY29uc3QgYmlsaW5lYXJJbnRlcnBvbGF0aW9uID0gKFxuICBpbnB1dDogSW5kaWNlc0hlbHBlcixcbiAgb3V0cHV0OiBJbmRpY2VzSGVscGVyLFxuICBpbnB1dFNoYXBlOiByZWFkb25seSBudW1iZXJbXSxcbiAgdXNlRXh0cmFwb2xhdGlvbjogYm9vbGVhbixcbiAgZXh0cmFwb2xhdGlvblZhbHVlOiBudW1iZXIsXG4pOiBzdHJpbmcgPT4ge1xuICBjb25zdCBpc05jaHcgPSB0cnVlO1xuICBjb25zdCBbYmF0Y2hJZHgsIGhlaWdodElkeCwgd2lkdGhJZHgsIGNoYW5uZWxJZHhdID1cbiAgICBpbnB1dFNoYXBlLmxlbmd0aCA9PT0gMiA/IFstMSwgMCwgMSwgLTFdIDogaXNOY2h3ID8gWzAsIDIsIDMsIDFdIDogWzAsIDEsIDIsIDNdO1xuICBjb25zdCBkVHlwZSA9IGlucHV0LnR5cGUudmFsdWU7XG4gIHJldHVybiBgXG4gICAgZm4gZ2V0SW5wdXRWYWx1ZShiYXRjaDogdTMyLCBjaGFubmVsOiB1MzIsIHJvdzogdTMyLCBjb2w6IHUzMikgLT4gJHtkVHlwZX0ge1xuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfTtcbiAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsIGhlaWdodElkeCwgYG1heCgwLCBtaW4ocm93LCAke2lucHV0U2hhcGVbaGVpZ2h0SWR4XX0gLSAxKSlgKX07XG4gICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCB3aWR0aElkeCwgYG1heCgwLCBtaW4oY29sLCAke2lucHV0U2hhcGVbd2lkdGhJZHhdfSAtIDEpKWApfTtcbiAgICAgICR7c2V0Q2hhbm5lbEFuZEJhdGNoSW5kaWNlcyhpbnB1dCwgY2hhbm5lbElkeCwgYmF0Y2hJZHgsIDIpfVxuICAgICAgcmV0dXJuICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O1xuICAgIH1cblxuICAgIGZuIGJpbGluZWFySW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlczogJHtvdXRwdXQudHlwZS5pbmRpY2VzfSkgLT4gJHtkVHlwZX0ge1xuICAgICAgdmFyIG9yaWdpbmFsSW5kaWNlcyA9IGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcbiAgICAgIHZhciByb3c6JHtkVHlwZX0gPSBvcmlnaW5hbEluZGljZXNbJHtoZWlnaHRJZHh9XTtcbiAgICAgIHZhciBjb2w6JHtkVHlwZX0gPSBvcmlnaW5hbEluZGljZXNbJHt3aWR0aElkeH1dO1xuICAgICAgJHtcbiAgICAgICAgdXNlRXh0cmFwb2xhdGlvblxuICAgICAgICAgID8gYGlmIChyb3cgPCAwIHx8IHJvdyA+ICgke2lucHV0U2hhcGVbaGVpZ2h0SWR4XX0gLSAxKSB8fCBjb2wgPCAwIHx8IGNvbCA+ICgke2lucHV0U2hhcGVbd2lkdGhJZHhdfSAtIDEpKSB7XG4gICAgICAgIHJldHVybiAke2V4dHJhcG9sYXRpb25WYWx1ZX07XG4gICAgICB9YFxuICAgICAgICAgIDogJydcbiAgICAgIH07XG4gICAgICByb3cgPSBtYXgoMCwgbWluKHJvdywgJHtpbnB1dFNoYXBlW2hlaWdodElkeF19IC0gMSkpO1xuICAgICAgY29sID0gbWF4KDAsIG1pbihjb2wsICR7aW5wdXRTaGFwZVt3aWR0aElkeF19IC0gMSkpO1xuICAgICAgdmFyIHJvdzE6IHUzMiA9IHUzMihyb3cpO1xuICAgICAgdmFyIGNvbDE6IHUzMiA9IHUzMihjb2wpO1xuICAgICAgdmFyIHJvdzI6IHUzMiA9IHUzMihyb3cgKyAxKTtcbiAgICAgIHZhciBjb2wyOiB1MzIgPSB1MzIoY29sICsgMSk7XG4gICAgICB2YXIgY2hhbm5lbDogdTMyID0gJHtpbnB1dFNoYXBlLmxlbmd0aCA+IDIgPyBgdTMyKG9yaWdpbmFsSW5kaWNlc1ske2NoYW5uZWxJZHh9XSlgIDogJzAnfTtcbiAgICAgIHZhciBiYXRjaDogdTMyID0gICR7aW5wdXRTaGFwZS5sZW5ndGggPiAyID8gYHUzMihvcmlnaW5hbEluZGljZXNbJHtiYXRjaElkeH1dKWAgOiAnMCd9O1xuICAgICAgdmFyIHgxMTogJHtkVHlwZX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cxLCBjb2wxKTtcbiAgICAgIHZhciB4MTI6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MSwgY29sMik7XG4gICAgICB2YXIgeDIxOiAke2RUeXBlfSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIHJvdzIsIGNvbDEpO1xuICAgICAgdmFyIHgyMjogJHtkVHlwZX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cyLCBjb2wyKTtcbiAgICAgIHZhciBkeDE6ICR7ZFR5cGV9ID0gYWJzKHJvdyAtICR7ZFR5cGV9KHJvdzEpKTtcbiAgICAgIHZhciBkeDI6ICR7ZFR5cGV9ID0gYWJzKCR7ZFR5cGV9KHJvdzIpIC0gcm93KTtcbiAgICAgIHZhciBkeTE6ICR7ZFR5cGV9ID0gYWJzKGNvbCAtICR7ZFR5cGV9KGNvbDEpKTtcbiAgICAgIHZhciBkeTI6ICR7ZFR5cGV9ID0gYWJzKCR7ZFR5cGV9KGNvbDIpIC0gY29sKTtcbiAgICAgIGlmIChyb3cxID09IHJvdzIpIHtcbiAgICAgICAgZHgxID0gMC41O1xuICAgICAgICBkeDIgPSAwLjU7XG4gICAgICB9XG4gICAgICBpZiAoY29sMSA9PSBjb2wyKSB7XG4gICAgICAgIGR5MSA9IDAuNTtcbiAgICAgICAgZHkyID0gMC41O1xuICAgICAgfVxuICAgICAgcmV0dXJuICh4MTEgKiBkeDIgKiBkeTIgKyB4MTIgKiBkeDIgKiBkeTEgKyB4MjEgKiBkeDEgKiBkeTIgKyB4MjIgKiBkeDEgKiBkeTEpO1xuICAgIH1gO1xufTtcblxuY29uc3QgYmljdWJpY0ludGVycG9sYXRpb24gPSAoXG4gIGlucHV0OiBJbmRpY2VzSGVscGVyLFxuICBvdXRwdXQ6IEluZGljZXNIZWxwZXIsXG4gIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICBvdXRwdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHNjYWxlczogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHJvaTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGN1YmljQ29lZmZBOiBudW1iZXIsXG4gIHVzZUV4dHJhcG9sYXRpb246IGJvb2xlYW4sXG4gIGV4dHJhcG9sYXRpb25WYWx1ZTogbnVtYmVyLFxuICBleGNsdWRlT3V0c2lkZTogYm9vbGVhbixcbik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGlzMkQgPSBpbnB1dFNoYXBlLmxlbmd0aCA9PT0gMjtcbiAgY29uc3QgaXNOY2h3ID0gdHJ1ZTtcbiAgY29uc3QgW2hlaWdodElkeCwgd2lkdGhJZHhdID0gaXMyRCA/IFswLCAxXSA6IGlzTmNodyA/IFsyLCAzXSA6IFsxLCAyXTtcbiAgY29uc3QgZFR5cGUgPSBpbnB1dC50eXBlLnZhbHVlO1xuICBjb25zdCBjcmVhdGVDdWJpY0ludGVycG9sYXRpb25GdW5jdGlvbiA9IChpZHg6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gaWR4ID09PSBoZWlnaHRJZHggPyAncm93JyA6ICdjb2wnO1xuICAgIHJldHVybiBgXG4gICAgICBmbiAke2RpcmVjdGlvbn1DdWJpY0ludGVycG9sYXRpb24oaW5wdXRfaW5kaWNlczogJHtpbnB1dC50eXBlLmluZGljZXN9LCBvdXRwdXRfaW5kaWNlczogJHtcbiAgICAgICAgb3V0cHV0LnR5cGUuaW5kaWNlc1xuICAgICAgfSkgLT4gJHtkVHlwZX0ge1xuICAgICAgICB2YXIgb3V0cHV0X2luZGV4ID0gJHtvdXRwdXQuaW5kaWNlc0dldCgnb3V0cHV0X2luZGljZXMnLCBpZHgpfTtcbiAgICAgICAgdmFyIG9yaWdpbmFsSWR4OiAke2RUeXBlfSA9IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZShvdXRwdXRfaW5kZXgsICR7c2NhbGVzW2lkeF19LFxuICAgICAgICAke291dHB1dFNoYXBlW2lkeF19LCAke2lucHV0U2hhcGVbaWR4XX0sICR7cm9pW2lkeF19LCAke3JvaVtpZHhdfSArICR7aW5wdXRTaGFwZS5sZW5ndGh9KTtcbiAgICAgICAgdmFyIGZyYWN0T3JpZ2luYWxJZHg6ICR7ZFR5cGV9ID0gb3JpZ2luYWxJZHggLSBmbG9vcihvcmlnaW5hbElkeCk7XG4gICAgICAgIHZhciBjb2VmcyA9IGdldEN1YmljSW50ZXJwb2xhdGlvbkNvZWZzKGZyYWN0T3JpZ2luYWxJZHgpO1xuXG4gICAgICAgIGlmICgke3VzZUV4dHJhcG9sYXRpb259ICYmIChvcmlnaW5hbElkeCA8IDAgfHwgb3JpZ2luYWxJZHggPiAoJHtpbnB1dFNoYXBlW2lkeF19IC0gMSkpKSB7XG4gICAgICAgICAgcmV0dXJuICR7ZXh0cmFwb2xhdGlvblZhbHVlfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YTogYXJyYXk8JHtkVHlwZX0sIDQ+ID0gYXJyYXk8JHtkVHlwZX0sIDQ+KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gICAgICAgIGZvciAodmFyIGk6IGkzMiA9IC0xOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgdmFyICR7ZGlyZWN0aW9ufTogJHtkVHlwZX0gPSBvcmlnaW5hbElkeCArICR7ZFR5cGV9KGkpO1xuICAgICAgICAgIGlmICgke2RpcmVjdGlvbn0gPCAwIHx8ICR7ZGlyZWN0aW9ufSA+PSAke2lucHV0U2hhcGVbaWR4XX0pIHtcbiAgICAgICAgICAgICR7KCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGV4Y2x1ZGVPdXRzaWRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBjb2Vmc1tpICsgMV0gPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtgO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHVzZUV4dHJhcG9sYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYHJldHVybiAke2V4dHJhcG9sYXRpb25WYWx1ZX07YDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7ZGlyZWN0aW9ufSA9IG1heCgwLCBtaW4oJHtkaXJlY3Rpb259LCAke2lucHV0U2hhcGVbaWR4XX0gLSAxKSk7YDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKX07XG4gICAgICAgICAgfVxuICAgICAgICB2YXIgaW5wdXRfaW5kaWNlc19jb3B5OiAke2lucHV0LnR5cGUuaW5kaWNlc30gPSBpbnB1dF9pbmRpY2VzO1xuICAgICAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlc19jb3B5JywgaWR4LCBgdTMyKCR7ZGlyZWN0aW9ufSlgKX07XG4gICAgICAgICAgZGF0YVtpICsgMV0gPSAke1xuICAgICAgICAgICAgaWR4ID09PSBoZWlnaHRJZHhcbiAgICAgICAgICAgICAgPyBpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXNfY29weScpXG4gICAgICAgICAgICAgIDogJ3Jvd0N1YmljSW50ZXJwb2xhdGlvbihpbnB1dF9pbmRpY2VzX2NvcHksIG91dHB1dF9pbmRpY2VzKSdcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdWJpY0ludGVycG9sYXRpb24xRChkYXRhLCBjb2Vmcyk7XG4gICAgICB9YDtcbiAgfTtcblxuICByZXR1cm4gYFxuICAgICR7Y3JlYXRlQ3ViaWNJbnRlcnBvbGF0aW9uRnVuY3Rpb24oaGVpZ2h0SWR4KX07XG4gICAgJHtjcmVhdGVDdWJpY0ludGVycG9sYXRpb25GdW5jdGlvbih3aWR0aElkeCl9O1xuICBmbiBnZXRDdWJpY0ludGVycG9sYXRpb25Db2VmcyhzOiAke2RUeXBlfSkgLT4gYXJyYXk8JHtkVHlwZX0sIDQ+IHtcbiAgICB2YXIgYWJzUyA9IGFicyhzKTtcbiAgICB2YXIgY29lZmZzOiBhcnJheTwke2RUeXBlfSwgND4gPSBhcnJheTwke2RUeXBlfSwgND4oMC4wLCAwLjAsIDAuMCwgMC4wKTtcbiAgICB2YXIgb25lTWludXNBYnNTOiAke2RUeXBlfSA9IDEuMCAtIGFic1M7XG4gICAgdmFyIHR3b01pbnVzQWJzUzogJHtkVHlwZX0gPSAyLjAgLSBhYnNTO1xuICAgIHZhciBvbmVQbHVzQWJzUzogJHtkVHlwZX0gPSAxLjAgKyBhYnNTO1xuICAgIGNvZWZmc1swXSA9ICgoJHtjdWJpY0NvZWZmQX0gKiBvbmVQbHVzQWJzUyAtIDUgKiAke2N1YmljQ29lZmZBfSkgKiBvbmVQbHVzQWJzUyArIDggKiAke1xuICAgICAgY3ViaWNDb2VmZkFcbiAgICB9KSAqIG9uZVBsdXNBYnNTIC0gNCAqICR7Y3ViaWNDb2VmZkF9O1xuICAgIGNvZWZmc1sxXSA9ICgoJHtjdWJpY0NvZWZmQX0gKyAyKSAqIGFic1MgLSAoJHtjdWJpY0NvZWZmQX0gKyAzKSkgKiBhYnNTICogYWJzUyArIDE7XG4gICAgY29lZmZzWzJdID0gKCgke2N1YmljQ29lZmZBfSArIDIpICogb25lTWludXNBYnNTIC0gKCR7Y3ViaWNDb2VmZkF9ICsgMykpICogb25lTWludXNBYnNTICogb25lTWludXNBYnNTICsgMTtcbiAgICBjb2VmZnNbM10gPSAoKCR7Y3ViaWNDb2VmZkF9ICogdHdvTWludXNBYnNTIC0gNSAqICR7Y3ViaWNDb2VmZkF9KSAqIHR3b01pbnVzQWJzUyArIDggKiAke1xuICAgICAgY3ViaWNDb2VmZkFcbiAgICB9KSAqIHR3b01pbnVzQWJzUyAtIDQgKiAke2N1YmljQ29lZmZBfTtcbiAgICByZXR1cm4gY29lZmZzO1xuICB9XG5cbiAgZm4gY3ViaWNJbnRlcnBvbGF0aW9uMUQoeDogYXJyYXk8JHtkVHlwZX0sIDQ+LCBjb2VmczogYXJyYXk8JHtkVHlwZX0sIDQ+KSAtPiAke2RUeXBlfSB7XG4gICAgdmFyIGNvZWZzU3VtOiAke2RUeXBlfSA9IGNvZWZzWzBdICsgY29lZnNbMV0gKyBjb2Vmc1syXSArIGNvZWZzWzNdO1xuICAgIHJldHVybiAoeFswXSAqIGNvZWZzWzBdICsgeFsxXSAqIGNvZWZzWzFdKyB4WzJdICogY29lZnNbMl0rIHhbM10gKiBjb2Vmc1szXSkgLyBjb2Vmc1N1bTtcbiAgfVxuXG4gIGZuIGJpY3ViaWNJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiAke2RUeXBlfSB7XG4gICAgdmFyIGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfSA9IG91dHB1dF9pbmRpY2VzO1xuICAgIHJldHVybiBjb2xDdWJpY0ludGVycG9sYXRpb24oaW5wdXRfaW5kaWNlcywgb3V0cHV0X2luZGljZXMpO1xuICB9XG4gICAgYDtcbn07XG5cbmNvbnN0IHRyaWxpbmVhckludGVycG9sYXRpb24gPSAoXG4gIGlucHV0OiBJbmRpY2VzSGVscGVyLFxuICBvdXRwdXQ6IEluZGljZXNIZWxwZXIsXG4gIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuICB1c2VFeHRyYXBvbGF0aW9uOiBib29sZWFuLFxuICBleHRyYXBvbGF0aW9uVmFsdWU6IG51bWJlcixcbik6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGlzTmNodyA9IHRydWU7XG4gIGNvbnN0IFtiYXRjaElkeCwgZGVwdGhJZHgsIGhlaWdodElkeCwgd2lkdGhJZHgsIGNoYW5uZWxJZHhdID1cbiAgICBpbnB1dFNoYXBlLmxlbmd0aCA9PT0gMyA/IFstMSwgMCwgMSwgMiwgLTFdIDogaXNOY2h3ID8gWzAsIDIsIDMsIDQsIDFdIDogWzAsIDEsIDIsIDMsIDRdO1xuICBjb25zdCBkVHlwZSA9IGlucHV0LnR5cGUudmFsdWU7XG4gIHJldHVybiBgXG4gICAgZm4gZ2V0SW5wdXRWYWx1ZShiYXRjaDogdTMyLCBjaGFubmVsOiB1MzIsIGRlcHRoOnUzMiwgaGVpZ2h0OiB1MzIsIHdpZHRoOiB1MzIpIC0+ICR7ZFR5cGV9IHtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc307XG4gICAgICAke2lucHV0LmluZGljZXNTZXQoJ2lucHV0X2luZGljZXMnLCBkZXB0aElkeCwgYG1heCgwLCBtaW4oZGVwdGgsICR7aW5wdXRTaGFwZVtkZXB0aElkeF19IC0gMSkpYCl9O1xuICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgaGVpZ2h0SWR4LCBgbWF4KDAsIG1pbihoZWlnaHQsICR7aW5wdXRTaGFwZVtoZWlnaHRJZHhdfSAtIDEpKWApfTtcbiAgICAgICR7aW5wdXQuaW5kaWNlc1NldCgnaW5wdXRfaW5kaWNlcycsIHdpZHRoSWR4LCBgbWF4KDAsIG1pbih3aWR0aCwgJHtpbnB1dFNoYXBlW3dpZHRoSWR4XX0gLSAxKSlgKX07XG4gICAgICAke3NldENoYW5uZWxBbmRCYXRjaEluZGljZXMoaW5wdXQsIGNoYW5uZWxJZHgsIGJhdGNoSWR4LCAzKX1cbiAgICAgIHJldHVybiAke2lucHV0LmdldEJ5SW5kaWNlcygnaW5wdXRfaW5kaWNlcycpfTtcbiAgICB9XG5cbiAgICBmbiB0cmlsaW5lYXJJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzOiAke291dHB1dC50eXBlLmluZGljZXN9KSAtPiAke2RUeXBlfSB7XG4gICAgICB2YXIgb3JpZ2luYWxJbmRpY2VzID0gY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xuICAgICAgdmFyIGRlcHRoOiR7ZFR5cGV9ID0gb3JpZ2luYWxJbmRpY2VzWyR7ZGVwdGhJZHh9XTtcbiAgICAgIHZhciBoZWlnaHQ6JHtkVHlwZX0gPSBvcmlnaW5hbEluZGljZXNbJHtoZWlnaHRJZHh9XTtcbiAgICAgIHZhciB3aWR0aDoke2RUeXBlfSA9IG9yaWdpbmFsSW5kaWNlc1ske3dpZHRoSWR4fV07XG4gICAgICAke1xuICAgICAgICB1c2VFeHRyYXBvbGF0aW9uXG4gICAgICAgICAgPyBgaWYgKGRlcHRoIDwgMCB8fCBkZXB0aCA+ICgke2lucHV0U2hhcGVbZGVwdGhJZHhdfSAtIDEpIHx8IGhlaWdodCA8IDAgfHwgaGVpZ2h0ID4gKCR7XG4gICAgICAgICAgICAgIGlucHV0U2hhcGVbaGVpZ2h0SWR4XVxuICAgICAgICAgICAgfSAtIDEpIHx8IHdpZHRoIDwgMCB8fCAod2lkdGggPiAke2lucHV0U2hhcGVbd2lkdGhJZHhdfSAtIDEpKSB7XG4gICAgICByZXR1cm4gJHtleHRyYXBvbGF0aW9uVmFsdWV9O1xuICAgICAgICB9YFxuICAgICAgICAgIDogJydcbiAgICAgIH07XG5cbiAgICBkZXB0aCA9IG1heCgwLCBtaW4oZGVwdGgsICR7aW5wdXRTaGFwZVtkZXB0aElkeF19IC0gMSkpO1xuICAgICAgaGVpZ2h0ID0gbWF4KDAsIG1pbihoZWlnaHQsICR7aW5wdXRTaGFwZVtoZWlnaHRJZHhdfSAtIDEpKTtcbiAgICAgIHdpZHRoID0gbWF4KDAsIG1pbih3aWR0aCwgJHtpbnB1dFNoYXBlW3dpZHRoSWR4XX0gLSAxKSk7XG4gICAgICB2YXIgZGVwdGgxOiB1MzIgPSB1MzIoZGVwdGgpO1xuICAgICAgdmFyIGhlaWdodDE6IHUzMiA9IHUzMihoZWlnaHQpO1xuICAgICAgdmFyIHdpZHRoMTogdTMyID0gdTMyKHdpZHRoKTtcbiAgICAgIHZhciBkZXB0aDI6IHUzMiA9IHUzMihkZXB0aCArIDEpO1xuICAgICAgdmFyIGhlaWdodDI6IHUzMiA9IHUzMihoZWlnaHQgKyAxKTtcbiAgICAgIHZhciB3aWR0aDI6IHUzMiA9IHUzMih3aWR0aCArIDEpO1xuICAgICAgdmFyIGNoYW5uZWw6IHUzMiA9ICR7aW5wdXRTaGFwZS5sZW5ndGggPiAzID8gYHUzMihvcmlnaW5hbEluZGljZXNbJHtjaGFubmVsSWR4fV0pYCA6ICcwJ307XG4gICAgICB2YXIgYmF0Y2g6IHUzMiA9ICAke2lucHV0U2hhcGUubGVuZ3RoID4gMyA/IGB1MzIob3JpZ2luYWxJbmRpY2VzWyR7YmF0Y2hJZHh9XSlgIDogJzAnfTtcblxuICAgICAgdmFyIHgxMTE6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQxLCB3aWR0aDEpO1xuICAgICAgdmFyIHgxMTI6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQxLCB3aWR0aDIpO1xuICAgICAgdmFyIHgxMjE6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQyLCB3aWR0aDEpO1xuICAgICAgdmFyIHgxMjI6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQyLCB3aWR0aDIpO1xuICAgICAgdmFyIHgyMTE6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQxLCB3aWR0aDEpO1xuICAgICAgdmFyIHgyMTI6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQxLCB3aWR0aDIpO1xuICAgICAgdmFyIHgyMjE6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQyLCB3aWR0aDEpO1xuICAgICAgdmFyIHgyMjI6ICR7ZFR5cGV9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQyLCB3aWR0aDIpO1xuICAgICAgdmFyIGR4MTogJHtkVHlwZX0gPSBhYnMoZGVwdGggLSAke2RUeXBlfShkZXB0aDEpKTtcbiAgICAgIHZhciBkeDI6ICR7ZFR5cGV9ID0gYWJzKCR7ZFR5cGV9KGRlcHRoMikgLSBkZXB0aCk7XG4gICAgICB2YXIgZHkxOiAke2RUeXBlfSA9IGFicyhoZWlnaHQgLSAke2RUeXBlfShoZWlnaHQxKSk7XG4gICAgICB2YXIgZHkyOiAke2RUeXBlfSA9IGFicygke2RUeXBlfShoZWlnaHQyKSAtIGhlaWdodCk7XG4gICAgICB2YXIgZHoxOiAke2RUeXBlfSA9IGFicyh3aWR0aCAtICR7ZFR5cGV9KHdpZHRoMSkpO1xuICAgICAgdmFyIGR6MjogJHtkVHlwZX0gPSBhYnMoJHtkVHlwZX0od2lkdGgyKSAtIHdpZHRoKTtcbiAgICAgIGlmIChkZXB0aDEgPT0gZGVwdGgyKSB7XG4gICAgICAgIGR4MSA9IDAuNTtcbiAgICAgICAgZHgyID0gMC41O1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodDEgPT0gaGVpZ2h0Mikge1xuICAgICAgICBkeTEgPSAwLjU7XG4gICAgICAgIGR5MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIGlmICh3aWR0aDEgPT0gd2lkdGgyKSB7XG4gICAgICAgIGR6MSA9IDAuNTtcbiAgICAgICAgZHoyID0gMC41O1xuICAgICAgfVxuICAgICAgcmV0dXJuICh4MTExICogZHgyICogZHkyICogZHoyICsgeDExMiAqIGR4MiAqIGR5MiAqIGR6MSArIHgxMjEgKiBkeDIgKiBkeTEgKmR6MiArIHgxMjIgKiBkeDIgKiBkeTEgKiBkejEgK1xuICAgICAgICAgICAgICB4MjExICogZHgxICogZHkyICogZHoyICsgeDIxMiAqIGR4MSAqIGR5MiAqIGR6MSArIHgyMjEgKiBkeDEgKiBkeTEgKmR6MiArIHgyMjIgKiBkeDEgKiBkeTEgKiBkejEpO1xuICAgIH1gO1xufTtcblxuY29uc3QgY3JlYXRlUmVzaXplUHJvZ3JhbUluZm8gPSAoXG4gIGlucHV0VGVuc29yOiBUZW5zb3JWaWV3LFxuICBhdHRyaWJ1dGVzOiBSZXNpemVBdHRyaWJ1dGVzLFxuICBvcHNldFZlcnNpb246IG51bWJlcixcbiAgc2NhbGVzSW5wdXQ6IHJlYWRvbmx5IG51bWJlcltdLFxuICBzaXplczogcmVhZG9ubHkgbnVtYmVyW10sXG4gIHJvaUlucHV0OiByZWFkb25seSBudW1iZXJbXSxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0VGVuc29yLmRpbXM7XG4gIGNvbnN0IHJvaSA9IHVwZGF0ZVJvSShyb2lJbnB1dCwgYXR0cmlidXRlcy5heGVzLCBpbnB1dFNoYXBlLmxlbmd0aCk7XG5cbiAgbGV0IG91dHB1dFNoYXBlID0gaW5pdE91dHB1dFNoYXBlKGlucHV0U2hhcGUsIHNjYWxlc0lucHV0LCBzaXplcywgYXR0cmlidXRlcy5heGVzKTtcbiAgbGV0IHNjYWxlcyA9IHNjYWxlc0lucHV0LnNsaWNlKCk7XG4gIGlmIChzY2FsZXNJbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICBzY2FsZXMgPSBpbnB1dFNoYXBlLm1hcCgodmFsdWUsIGluZGV4KSA9PiAodmFsdWUgPT09IDAgPyAxLjAgOiBvdXRwdXRTaGFwZVtpbmRleF0gLyB2YWx1ZSkpO1xuICAgIGlmIChhdHRyaWJ1dGVzLmtlZXBBc3BlY3RSYXRpb1BvbGljeSAhPT0gJ3N0cmV0Y2gnKSB7XG4gICAgICBvdXRwdXRTaGFwZSA9IGFkanVzdE91dHB1dFNoYXBlKGlucHV0U2hhcGUsIHNjYWxlcywgYXR0cmlidXRlcyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG91dHB1dCA9IG91dHB1dFZhcmlhYmxlKCdvdXRwdXQnLCBpbnB1dFRlbnNvci5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoKTtcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0VGVuc29yLmRhdGFUeXBlLCBpbnB1dFNoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIGNvbnN0IG5vU2NhbGUgPSBpbnB1dFNoYXBlLmxlbmd0aCA9PT0gb3V0cHV0U2hhcGUubGVuZ3RoICYmIGlucHV0U2hhcGUuZXZlcnkoKGQsIGkpID0+IGQgPT09IG91dHB1dFNoYXBlW2ldKTtcbiAgY29uc3QgdXNlRXh0cmFwb2xhdGlvbiA9IGF0dHJpYnV0ZXMuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUgPT09ICd0Zl9jcm9wX2FuZF9yZXNpemUnO1xuICBjb25zdCBleHRyYXBvbGF0aW9uVmFsdWUgPSBhdHRyaWJ1dGVzLmV4dHJhcG9sYXRpb25WYWx1ZTtcbiAgY29uc3QgZGF0YVR5cGUgPSBpbnB1dC50eXBlLnZhbHVlO1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgICAgICR7XG4gICAgICAgIG5vU2NhbGVcbiAgICAgICAgICA/ICcnXG4gICAgICAgICAgOiBgXG4gICAgICAke2dldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZShhdHRyaWJ1dGVzLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlLCBkYXRhVHlwZSl9O1xuICAgICAgJHsoKCkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGF0dHJpYnV0ZXMubW9kZSkge1xuICAgICAgICAgIGNhc2UgJ25lYXJlc3QnOlxuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgJHtjaGVja0lucHV0SW5kaWNlcyhpbnB1dCwgaW5wdXRTaGFwZSl9O1xuICAgICAgICAgICAgICAke2dldE5lYXJlc3RQaXhlbEZyb21PcmlnaW5hbChhdHRyaWJ1dGVzLm5lYXJlc3RNb2RlLCBvcHNldFZlcnNpb24sIGRhdGFUeXBlKX07XG4gICAgICAgICAgICAgICR7Y2FsY3VsYXRlSW5wdXRJbmRpY2VzRnJvbU91dHB1dEluZGljZXMoXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgICAgICAgIGlucHV0U2hhcGUsXG4gICAgICAgICAgICAgICAgb3V0cHV0U2hhcGUsXG4gICAgICAgICAgICAgICAgc2NhbGVzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICByb2kubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHVzZUV4dHJhcG9sYXRpb24sXG4gICAgICAgICAgICAgICl9O1xuICAgICAgICAgICAgICBgO1xuICAgICAgICAgIGNhc2UgJ2xpbmVhcic6XG4gICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgICAke2NhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dCwgaW5wdXRTaGFwZSwgb3V0cHV0U2hhcGUsIHNjYWxlcy5sZW5ndGgsIHJvaS5sZW5ndGgpfTtcbiAgICAgICAgICAgICAgJHsoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dFNoYXBlLmxlbmd0aCA9PT0gMiB8fCBpbnB1dFNoYXBlLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke2JpbGluZWFySW50ZXJwb2xhdGlvbihpbnB1dCwgb3V0cHV0LCBpbnB1dFNoYXBlLCB1c2VFeHRyYXBvbGF0aW9uLCBleHRyYXBvbGF0aW9uVmFsdWUpfWA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dFNoYXBlLmxlbmd0aCA9PT0gMyB8fCBpbnB1dFNoYXBlLmxlbmd0aCA9PT0gNSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke3RyaWxpbmVhckludGVycG9sYXRpb24oaW5wdXQsIG91dHB1dCwgaW5wdXRTaGFwZSwgdXNlRXh0cmFwb2xhdGlvbiwgZXh0cmFwb2xhdGlvblZhbHVlKX1gO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignTGluZWFyIG1vZGUgb25seSBzdXBwb3J0cyBpbnB1dCBkaW1zIDIsIDMsIDQgYW5kIDUgYXJlIHN1cHBvcnRlZCBpbiBsaW5lYXIgbW9kZS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pKCl9O1xuICAgICAgICAgICAgYDtcbiAgICAgICAgICBjYXNlICdjdWJpYyc6XG4gICAgICAgICAgICByZXR1cm4gYFxuICAgICAgICAgICAgJHsoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoaW5wdXRTaGFwZS5sZW5ndGggPT09IDIgfHwgaW5wdXRTaGFwZS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7YmljdWJpY0ludGVycG9sYXRpb24oXG4gICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgICAgICAgIGlucHV0U2hhcGUsXG4gICAgICAgICAgICAgICAgICBvdXRwdXRTaGFwZSxcbiAgICAgICAgICAgICAgICAgIHNjYWxlcyxcbiAgICAgICAgICAgICAgICAgIHJvaSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuY3ViaWNDb2VmZkEsXG4gICAgICAgICAgICAgICAgICB1c2VFeHRyYXBvbGF0aW9uLFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcy5leHRyYXBvbGF0aW9uVmFsdWUsXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLmV4Y2x1ZGVPdXRzaWRlLFxuICAgICAgICAgICAgICAgICl9YDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignQ3ViaWMgbW9kZSBvbmx5IHN1cHBvcnRzIGlucHV0IGRpbXMgMiBhbmQgNCBhcmUgc3VwcG9ydGVkIGluIGxpbmVhciBtb2RlLicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpfTtcbiAgICAgICAgICAgIGA7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIHJlc2l6ZSBtb2RlJyk7XG4gICAgICAgIH1cbiAgICAgIH0pKCl9O1xuICAgICAgYFxuICAgICAgfVxuICAgICAgJHtzaGFkZXJIZWxwZXJcbiAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnb3V0cHV0X3NpemUnLCAndTMyJylcbiAgICAgICAgLnJlZ2lzdGVyVW5pZm9ybSgnc2NhbGVzJywgJ2YzMicsIHNjYWxlcy5sZW5ndGgpXG4gICAgICAgIC5yZWdpc3RlclVuaWZvcm0oJ3JvaScsICdmMzInLCByb2kubGVuZ3RoKVxuICAgICAgICAuZGVjbGFyZVZhcmlhYmxlcyhpbnB1dCwgb3V0cHV0KX1cbiAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy5vdXRwdXRfc2l6ZScpfVxuICAgICAgICAke1xuICAgICAgICAgIG5vU2NhbGVcbiAgICAgICAgICAgID8gJ291dHB1dFtnbG9iYWxfaWR4XSA9IGlucHV0W2dsb2JhbF9pZHhdOydcbiAgICAgICAgICAgIDogYFxuICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2lucHV0LnR5cGUuaW5kaWNlc307XG4gICAgICAgICR7KCgpID0+IHtcbiAgICAgICAgICBzd2l0Y2ggKGF0dHJpYnV0ZXMubW9kZSkge1xuICAgICAgICAgICAgY2FzZSAnbmVhcmVzdCc6XG4gICAgICAgICAgICAgIHJldHVybiBgaW5wdXRfaW5kaWNlcyA9IGNhbGN1bGF0ZUlucHV0SW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tJbnB1dEluZGljZXMoaW5wdXRfaW5kaWNlcykpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7aW5wdXQuZ2V0QnlJbmRpY2VzKCdpbnB1dF9pbmRpY2VzJyl9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke2F0dHJpYnV0ZXMuZXh0cmFwb2xhdGlvblZhbHVlfTtcbiAgICAgICAgICAgICAgICB9YDtcbiAgICAgICAgICAgIGNhc2UgJ2xpbmVhcic6XG4gICAgICAgICAgICAgIHJldHVybiBgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHtcbiAgICAgICAgICAgICAgICBpbnB1dFNoYXBlLmxlbmd0aCA9PT0gMiB8fCBpbnB1dFNoYXBlLmxlbmd0aCA9PT0gNCA/ICdiaWxpbmVhckludGVycG9sYXRpb24nIDogJ3RyaWxpbmVhckludGVycG9sYXRpb24nXG4gICAgICAgICAgICAgIH0ob3V0cHV0X2luZGljZXMpO2A7XG4gICAgICAgICAgICBjYXNlICdjdWJpYyc6XG4gICAgICAgICAgICAgIHJldHVybiAnb3V0cHV0W2dsb2JhbF9pZHhdID0gYmljdWJpY0ludGVycG9sYXRpb24ob3V0cHV0X2luZGljZXMpOyc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgcmVzaXplIG1vZGU6ICR7YXR0cmlidXRlcy5tb2RlfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKX07XG5gXG4gICAgICAgIH1cbiAgICAgIH1gO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1Jlc2l6ZScsXG4gICAgc2hhZGVyQ2FjaGU6IHtcbiAgICAgIGhpbnQ6IGAke2F0dHJpYnV0ZXMuY2FjaGVLZXl9fCR7b3BzZXRWZXJzaW9ufXwke3NjYWxlcy5sZW5ndGggPiAwID8gc2NhbGVzIDogJyd9fCR7XG4gICAgICAgIHNpemVzLmxlbmd0aCA+IDAgPyBzaXplcyA6ICcnXG4gICAgICB9fCR7cm9pLmxlbmd0aCA+IDAgPyByb2kgOiAnJ318JHtub1NjYWxlfXwke2lucHV0U2hhcGV9YCxcbiAgICAgIGlucHV0RGVwZW5kZW5jaWVzOiBbJ3JhbmsnXSxcbiAgICB9LFxuICAgIGdldFNoYWRlclNvdXJjZSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dFRlbnNvci5kYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLykgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtczogW1xuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogb3V0cHV0U2l6ZSB9LFxuICAgICAgICB7IHR5cGU6IERhdGFUeXBlLmZsb2F0LCBkYXRhOiBzY2FsZXMgfSxcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogcm9pIH0sXG4gICAgICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0U2hhcGUsIG91dHB1dFNoYXBlKSxcbiAgICAgIF0sXG4gICAgfSksXG4gIH07XG59O1xuXG5jb25zdCBnZXRPcHNldFZlcnNpb25Gcm9tQ3VzdG9tRGF0YUJ1ZmZlciA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IG51bWJlciA9PiB7XG4gIGNvbnN0IGN1c3RvbURhdGFCdWZmZXIgPSBjb250ZXh0LmN1c3RvbURhdGFCdWZmZXI7XG4gIGNvbnN0IGN1c3RvbURhdGFCdWZmZXIzMiA9IG5ldyBVaW50MzJBcnJheShjdXN0b21EYXRhQnVmZmVyLCBjdXN0b21EYXRhQnVmZmVyLmJ5dGVPZmZzZXQsIDEpO1xuICBjb25zdCBvcHNldFZlcnNpb24gPSBjdXN0b21EYXRhQnVmZmVyMzJbMF07XG4gIHJldHVybiBvcHNldFZlcnNpb247XG59O1xuXG5leHBvcnQgY29uc3QgcmVzaXplID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBSZXNpemVBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIGNvbnN0IHNjYWxlczogbnVtYmVyW10gPSBbXTtcbiAgY29uc3Qgc2l6ZXM6IG51bWJlcltdID0gW107XG4gIGNvbnN0IHJvaTogbnVtYmVyW10gPSBbXTtcblxuICAvLyBOb3RlIHRoYXQgc2NhbGVzIGluIHJlc2l6ZSBhcmUgYWx3YXlzIGYzMi4gcm9pIGNhbiBiZSBmMzIgb3IgZjE2LlxuICAvLyBUT0RPOiBDdXJyZW50bHkgdGhpcyBjb2RlIGRvZXMgbm90IHN1cHBvcnQgZjE2IGZvciByb2kgd2hlbiBwYXNzZWQgYXMgb3B0aW9uYWwgaW5wdXQuXG5cbiAgY29uc3Qgb3BzZXRWZXJzaW9uID0gZ2V0T3BzZXRWZXJzaW9uRnJvbUN1c3RvbURhdGFCdWZmZXIoY29udGV4dCk7XG4gIGlmIChhdHRyaWJ1dGVzLmFudGlhbGlhcyAhPT0gMCkge1xuICAgIHRocm93IEVycm9yKCdPbmx5IGRlZmF1bHQgdmFsdWUgKDApIGZvciBBbnRpYWxpYXMgYXR0cmlidXRlIGlzIHN1cHBvcnRlZCcpO1xuICB9XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzLCBvcHNldFZlcnNpb24sIHNjYWxlcywgc2l6ZXMsIHJvaSk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVSZXNpemVQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgYXR0cmlidXRlcywgb3BzZXRWZXJzaW9uLCBzY2FsZXMsIHNpemVzLCByb2kpLCB7XG4gICAgaW5wdXRzOiBbMF0sXG4gIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlUmVzaXplQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFJlc2l6ZUF0dHJpYnV0ZXMgPT4ge1xuICBjb25zdCBhbnRpYWxpYXMgPSBhdHRyaWJ1dGVzLmFudGlhbGlhcyBhcyBudW1iZXI7XG4gIGNvbnN0IGF4ZXMgPSBhdHRyaWJ1dGVzLmF4ZXMgYXMgbnVtYmVyW107XG4gIGNvbnN0IGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOiBDb29yZGluYXRlVHJhbnNmb3JtTW9kZSA9XG4gICAgYXR0cmlidXRlcy5jb29yZGluYXRlVHJhbnNmb3JtTW9kZSBhcyBDb29yZGluYXRlVHJhbnNmb3JtTW9kZTtcbiAgY29uc3QgY3ViaWNDb2VmZkEgPSBhdHRyaWJ1dGVzLmN1YmljQ29lZmZBIGFzIG51bWJlcjtcbiAgY29uc3QgZXhjbHVkZU91dHNpZGUgPSAoYXR0cmlidXRlcy5leGNsdWRlT3V0c2lkZSBhcyBudW1iZXIpICE9PSAwO1xuICBjb25zdCBleHRyYXBvbGF0aW9uVmFsdWUgPSBhdHRyaWJ1dGVzLmV4dHJhcG9sYXRpb25WYWx1ZSBhcyBudW1iZXI7XG4gIGNvbnN0IGtlZXBBc3BlY3RSYXRpb1BvbGljeTogS2VlcEFzcGVjdFJhdGlvUG9saWN5ID0gYXR0cmlidXRlcy5rZWVwQXNwZWN0UmF0aW9Qb2xpY3kgYXMgS2VlcEFzcGVjdFJhdGlvUG9saWN5O1xuICBjb25zdCBtb2RlOiBNb2RlID0gYXR0cmlidXRlcy5tb2RlIGFzIE1vZGU7XG4gIC8vIElmIG5lYXJlc3RNb2RlIGlzIG5vdCBzcGVjaWZpZWQsIHVzZSBzaW1wbGUgbW9kZS5cbiAgY29uc3QgbmVhcmVzdE1vZGU6IE5lYXJlc3RNb2RlID0gKGF0dHJpYnV0ZXMubmVhcmVzdE1vZGUgPT09ICcnID8gJ3NpbXBsZScgOiBhdHRyaWJ1dGVzLm5lYXJlc3RNb2RlKSBhcyBOZWFyZXN0TW9kZTtcbiAgcmV0dXJuIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSh7XG4gICAgYW50aWFsaWFzLFxuICAgIGF4ZXMsXG4gICAgY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUsXG4gICAgY3ViaWNDb2VmZkEsXG4gICAgZXhjbHVkZU91dHNpZGUsXG4gICAgZXh0cmFwb2xhdGlvblZhbHVlLFxuICAgIGtlZXBBc3BlY3RSYXRpb1BvbGljeSxcbiAgICBtb2RlLFxuICAgIG5lYXJlc3RNb2RlLFxuICB9KTtcbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IERhdGFUeXBlIH0gZnJvbSAnLi4vLi4vLi4vd2FzbS1jb21tb24nO1xuaW1wb3J0IHsgVGVuc29yVmlldyB9IGZyb20gJy4uLy4uL3RlbnNvci12aWV3JztcbmltcG9ydCB7IFNoYXBlVXRpbCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyLCBXT1JLR1JPVVBfU0laRSB9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBSb3RhcnlFbWJlZGRpbmdBdHRyaWJ1dGVzIHtcbiAgcmVhZG9ubHkgaW50ZXJsZWF2ZWQ6IGJvb2xlYW47XG4gIHJlYWRvbmx5IG51bUhlYWRzOiBudW1iZXI7XG4gIHJlYWRvbmx5IHJvdGFyeUVtYmVkZGluZ0RpbTogbnVtYmVyO1xuICByZWFkb25seSBzY2FsZTogbnVtYmVyO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSwgYXR0cmlidXRlczogUm90YXJ5RW1iZWRkaW5nQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBjb25zdCBbaW5wdXQsIHBvc2l0aW9uSWRzLCBjb3NDYWNoZSwgc2luQ2FjaGVdID0gaW5wdXRzO1xuICBjb25zdCB7IG51bUhlYWRzLCByb3RhcnlFbWJlZGRpbmdEaW0gfSA9IGF0dHJpYnV0ZXM7XG5cbiAgaWYgKGlucHV0LmRpbXMubGVuZ3RoICE9PSAzICYmIGlucHV0LmRpbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAneCcgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDQgZGltZW5zaW9ucywgZ290ICR7aW5wdXQuZGltcy5sZW5ndGh9YCk7XG4gIH1cbiAgaWYgKFxuICAgICFTaGFwZVV0aWwuYXJlRXF1YWwocG9zaXRpb25JZHMuZGltcywgW10pICYmXG4gICAgIVNoYXBlVXRpbC5hcmVFcXVhbChwb3NpdGlvbklkcy5kaW1zLCBbMV0pICYmXG4gICAgcG9zaXRpb25JZHMuZGltcy5sZW5ndGggIT09IDJcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAncG9zaXRpb25faWRzJyBpcyBleHBlY3RlZCB0byBoYXZlIDAsIDEsIG9yIDIgZGltZW5zaW9ucywgZ290ICR7cG9zaXRpb25JZHMuZGltcy5sZW5ndGh9YCk7XG4gIH1cbiAgaWYgKGNvc0NhY2hlLmRpbXMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAnY29zX2NhY2hlJyBpcyBleHBlY3RlZCB0byBoYXZlIDIgZGltZW5zaW9ucywgZ290ICR7Y29zQ2FjaGUuZGltcy5sZW5ndGh9YCk7XG4gIH1cbiAgaWYgKHNpbkNhY2hlLmRpbXMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAnc2luX2NhY2hlJyBpcyBleHBlY3RlZCB0byBoYXZlIDIgZGltZW5zaW9ucywgZ290ICR7c2luQ2FjaGUuZGltcy5sZW5ndGh9YCk7XG4gIH1cbiAgaWYgKCFTaGFwZVV0aWwuYXJlRXF1YWwoY29zQ2FjaGUuZGltcywgc2luQ2FjaGUuZGltcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dHMgJ2Nvc19jYWNoZScgYW5kICdzaW5fY2FjaGUnIGFyZSBleHBlY3RlZCB0byBoYXZlIHRoZSBzYW1lIHNoYXBlXCIpO1xuICB9XG5cbiAgaWYgKHJvdGFyeUVtYmVkZGluZ0RpbSA+IDAgJiYgbnVtSGVhZHMgPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ251bV9oZWFkcyBtdXN0IGJlIHByb3ZpZGVkIGlmIHJvdGFyeV9lbWJlZGRpbmdfZGltIGlzIHNwZWNpZmllZCcpO1xuICB9XG5cbiAgY29uc3QgYmF0Y2hTaXplID0gaW5wdXQuZGltc1swXTtcbiAgY29uc3Qgc2VxdWVuY2VMZW5ndGggPSBpbnB1dC5kaW1zW2lucHV0LmRpbXMubGVuZ3RoIC0gMl07XG4gIGNvbnN0IG1heFNlcXVlbmNlTGVuZ3RoID0gY29zQ2FjaGUuZGltc1swXTtcbiAgY29uc3QgaGlkZGVuU2l6ZSA9IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbihpbnB1dC5kaW1zLCAxKSAvIHNlcXVlbmNlTGVuZ3RoO1xuICBjb25zdCBoZWFkU2l6ZSA9IHJvdGFyeUVtYmVkZGluZ0RpbSA9PT0gMCA/IGNvc0NhY2hlLmRpbXNbMV0gKiAyIDogaGlkZGVuU2l6ZSAvIG51bUhlYWRzO1xuICBpZiAocm90YXJ5RW1iZWRkaW5nRGltID4gaGVhZFNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JvdGFyeV9lbWJlZGRpbmdfZGltIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGhlYWRfc2l6ZScpO1xuICB9XG5cbiAgaWYgKHBvc2l0aW9uSWRzLmRpbXMubGVuZ3RoID09PSAyKSB7XG4gICAgaWYgKGJhdGNoU2l6ZSAhPT0gcG9zaXRpb25JZHMuZGltc1swXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAncG9zaXRpb25faWRzJyBkaW1lbnNpb24gMCBzaG91bGQgYmUgb2Ygc2l6ZSBiYXRjaF9zaXplLCBnb3QgJHtwb3NpdGlvbklkcy5kaW1zWzBdfWApO1xuICAgIH1cbiAgICBpZiAoc2VxdWVuY2VMZW5ndGggIT09IHBvc2l0aW9uSWRzLmRpbXNbMV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Bvc2l0aW9uX2lkcycgZGltZW5zaW9uIDEgc2hvdWxkIGJlIG9mIHNpemUgc2VxdWVuY2VfbGVuZ3RoLCBnb3QgJHtwb3NpdGlvbklkcy5kaW1zWzFdfWApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChoZWFkU2l6ZSAvIDIgIT09IGNvc0NhY2hlLmRpbXNbMV0gJiYgcm90YXJ5RW1iZWRkaW5nRGltIC8gMiAhPT0gY29zQ2FjaGUuZGltc1sxXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnB1dCAnY29zX2NhY2hlJyBkaW1lbnNpb24gMSBzaG91bGQgYmUgc2FtZSBhcyBoZWFkX3NpemUgLyAyIG9yIHJvdGFyeV9lbWJlZGRpbmdfZGltIC8gMiwgZ290ICR7XG4gICAgICAgIGNvc0NhY2hlLmRpbXNbMV1cbiAgICAgIH1gLFxuICAgICk7XG4gIH1cblxuICBpZiAoc2VxdWVuY2VMZW5ndGggPiBtYXhTZXF1ZW5jZUxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVXBkYXRpbmcgY29zX2NhY2hlIGFuZCBzaW5fY2FjaGUgaW4gUm90YXJ5RW1iZWRkaW5nIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkJyk7XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZVJvdGFyeUVtYmVkZGluZ1Byb2dyYW1JbmZvID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogUm90YXJ5RW1iZWRkaW5nQXR0cmlidXRlcyxcbik6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgeyBpbnRlcmxlYXZlZCwgbnVtSGVhZHMsIHJvdGFyeUVtYmVkZGluZ0RpbSwgc2NhbGUgfSA9IGF0dHJpYnV0ZXM7XG4gIGNvbnN0IGJhdGNoU2l6ZSA9IGlucHV0c1swXS5kaW1zWzBdO1xuICBjb25zdCBiYXRjaFN0cmlkZSA9IFNoYXBlVXRpbC5zaXplRnJvbURpbWVuc2lvbihpbnB1dHNbMF0uZGltcywgMSk7XG4gIGNvbnN0IHNlcXVlbmNlTGVuZ3RoID0gaW5wdXRzWzBdLmRpbXNbaW5wdXRzWzBdLmRpbXMubGVuZ3RoIC0gMl07XG4gIGNvbnN0IGhpZGRlblNpemUgPSBiYXRjaFN0cmlkZSAvIHNlcXVlbmNlTGVuZ3RoO1xuICBjb25zdCBoYWxmUm90YXJ5RW1iZWRkaW5nRGltID0gaW5wdXRzWzJdLmRpbXNbMV07XG4gIGNvbnN0IGhlYWRTaXplID0gcm90YXJ5RW1iZWRkaW5nRGltID09PSAwID8gaGFsZlJvdGFyeUVtYmVkZGluZ0RpbSAqIDIgOiBoaWRkZW5TaXplIC8gbnVtSGVhZHM7XG5cbiAgLy8gUm90YXJ5IGVtYmVkZGluZ3Mgd2lsbCBiZSBjYWxjdWxhdGVkIGluIGEgcGFpci13aXNlIGZhc2hpb24uIEluIGFjY29yZGFuY2UsIHVzZSB0aGUgc2hhcGVcbiAgLy8gW2JhdGNoIHNpemUsIHNlcXVlbmNlIGxlbmd0aCwgbnVtIG9mIGhlYWRzLCBudW0gb2YgcGFpcnMgdG8gcm90YXRlICsgbnVtIG9mIGRpbXMgdG8gY29weV1cbiAgLy8gdG8gdW5mb2xkIHRoZSBnbG9iYWwgaW5kZXggaW4gc2hhZGVyLlxuICBjb25zdCBnbG9iYWxTaGFwZSA9IG5ldyBBcnJheTxudW1iZXI+KFxuICAgIGJhdGNoU2l6ZSxcbiAgICBzZXF1ZW5jZUxlbmd0aCxcbiAgICBoaWRkZW5TaXplIC8gaGVhZFNpemUsXG4gICAgaGVhZFNpemUgLSBoYWxmUm90YXJ5RW1iZWRkaW5nRGltLFxuICApO1xuICBjb25zdCBnbG9iYWxTdHJpZGVzID0gU2hhcGVVdGlsLmNvbXB1dGVTdHJpZGVzKGdsb2JhbFNoYXBlKTtcblxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogc2NhbGUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZ2xvYmFsU2hhcGUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogZ2xvYmFsU3RyaWRlcyB9LFxuXG4gICAgLy8gc3RyaWRlcyBmb3IgYWRkcmVzc2luZyB0aGUgaW5wdXQvb3V0cHV0IHRlbnNvciwgaW4gcGVybXV0YXRlZCBvcmRlciB0byBhbGlnbiB3aXRoIHRoZSB1bmZvbGRlZCBnbG9iYWwgaW5kZXgsXG4gICAgLy8gaS5lLiBCU05IXG4gICAgLi4uKGlucHV0c1swXS5kaW1zLmxlbmd0aCA9PT0gM1xuICAgICAgPyBuZXcgQXJyYXk8UHJvZ3JhbVVuaWZvcm0+KHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBbYmF0Y2hTdHJpZGUsIGhpZGRlblNpemUsIGhlYWRTaXplLCAxXSB9KVxuICAgICAgOiBbXSksXG4gICAgLi4uKGlucHV0c1swXS5kaW1zLmxlbmd0aCA9PT0gNFxuICAgICAgPyBuZXcgQXJyYXk8UHJvZ3JhbVVuaWZvcm0+KHtcbiAgICAgICAgICB0eXBlOiBEYXRhVHlwZS51aW50MzIsXG4gICAgICAgICAgZGF0YTogW2JhdGNoU3RyaWRlLCBoZWFkU2l6ZSwgc2VxdWVuY2VMZW5ndGggKiBoZWFkU2l6ZSwgMV0sXG4gICAgICAgIH0pXG4gICAgICA6IFtdKSxcblxuICAgIC4uLmNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzKGlucHV0c1swXS5kaW1zLCBpbnB1dHNbMV0uZGltcywgaW5wdXRzWzJdLmRpbXMsIGlucHV0c1szXS5kaW1zLCBpbnB1dHNbMF0uZGltcyksXG4gIF07XG5cbiAgY29uc3QgZ2V0U2hhZGVyU291cmNlID0gKHNoYWRlckhlbHBlcjogU2hhZGVySGVscGVyKSA9PiB7XG4gICAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtcbiAgICBjb25zdCBwb3NpdGlvbklkcyA9IGlucHV0VmFyaWFibGUoJ3Bvc2l0aW9uX2lkcycsIGlucHV0c1sxXS5kYXRhVHlwZSwgaW5wdXRzWzFdLmRpbXMubGVuZ3RoKTtcbiAgICBjb25zdCBjb3NDYWNoZSA9IGlucHV0VmFyaWFibGUoJ2Nvc19jYWNoZScsIGlucHV0c1syXS5kYXRhVHlwZSwgaW5wdXRzWzJdLmRpbXMubGVuZ3RoKTtcbiAgICBjb25zdCBzaW5DYWNoZSA9IGlucHV0VmFyaWFibGUoJ3Npbl9jYWNoZScsIGlucHV0c1szXS5kYXRhVHlwZSwgaW5wdXRzWzNdLmRpbXMubGVuZ3RoKTtcbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBpbnB1dHNbMF0uZGltcy5sZW5ndGgpO1xuXG4gICAgc2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXMoW1xuICAgICAgeyBuYW1lOiAnc2NhbGUnLCB0eXBlOiAnZjMyJyB9LFxuICAgICAgeyBuYW1lOiAnZ2xvYmFsX3NoYXBlJywgdHlwZTogJ3UzMicsIGxlbmd0aDogZ2xvYmFsU2hhcGUubGVuZ3RoIH0sXG4gICAgICB7IG5hbWU6ICdnbG9iYWxfc3RyaWRlcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGdsb2JhbFN0cmlkZXMubGVuZ3RoIH0sXG4gICAgICB7IG5hbWU6ICdpbnB1dF9vdXRwdXRfc3RyaWRlcycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IGdsb2JhbFN0cmlkZXMubGVuZ3RoIH0sXG4gICAgXSk7XG5cbiAgICByZXR1cm4gYFxuICAgICAgICAke3NoYWRlckhlbHBlci5kZWNsYXJlVmFyaWFibGVzKGlucHV0LCBwb3NpdGlvbklkcywgY29zQ2FjaGUsIHNpbkNhY2hlLCBvdXRwdXQpfVxuXG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydChXT1JLR1JPVVBfU0laRSl9XG4gICAgICAgICAgbGV0IGhhbGZfcm90YXJ5X2VtYl9kaW0gPSB1bmlmb3Jtcy4ke2Nvc0NhY2hlLm5hbWV9X3NoYXBlWzFdO1xuICAgICAgICAgIGxldCBic25oID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLmdsb2JhbF9zdHJpZGVzICUgdW5pZm9ybXMuZ2xvYmFsX3NoYXBlO1xuICAgICAgICAgIGxldCBzaXplID0gdW5pZm9ybXMuZ2xvYmFsX3NoYXBlWzBdICogdW5pZm9ybXMuZ2xvYmFsX3N0cmlkZXNbMF07XG4gICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygnc2l6ZScpfVxuXG4gICAgICAgICAgaWYgKGJzbmhbM10gPCBoYWxmX3JvdGFyeV9lbWJfZGltKSB7XG4gICAgICAgICAgICBsZXQgcG9zaXRpb25faWRzX2lkeCA9XG4gICAgICAgICAgICAgICAgJHtwb3NpdGlvbklkcy5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCgnYnNuaC54eScsIG91dHB1dFZhcmlhYmxlKCcnLCBwb3NpdGlvbklkcy50eXBlLnRlbnNvciwgMikpfTtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbl9pZCA9XG4gICAgICAgICAgICAgICAgdTMyKCR7cG9zaXRpb25JZHMuZ2V0QnlPZmZzZXQoJ3Bvc2l0aW9uX2lkc19pZHgnKX0pICsgc2VsZWN0KDAsIGJzbmhbMV0sIHBvc2l0aW9uX2lkc19pZHggPT0gMCk7XG4gICAgICAgICAgICBsZXQgaSA9IGRvdChic25oLCB1bmlmb3Jtcy5pbnB1dF9vdXRwdXRfc3RyaWRlcykgKyBzZWxlY3QoMCwgYnNuaFszXSwgJHtpbnRlcmxlYXZlZH0pO1xuICAgICAgICAgICAgbGV0IGogPSBpICsgc2VsZWN0KGhhbGZfcm90YXJ5X2VtYl9kaW0sIDEsICR7aW50ZXJsZWF2ZWR9KTtcbiAgICAgICAgICAgIGxldCByZSA9ICR7aW5wdXQuZ2V0QnlPZmZzZXQoJ2knKX0gKiAke2Nvc0NhY2hlLmdldCgncG9zaXRpb25faWQnLCAnYnNuaFszXScpfSAtXG4gICAgICAgICAgICAgICAgJHtpbnB1dC5nZXRCeU9mZnNldCgnaicpfSAqICR7c2luQ2FjaGUuZ2V0KCdwb3NpdGlvbl9pZCcsICdic25oWzNdJyl9O1xuICAgICAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2knLCAncmUnKX1cbiAgICAgICAgICAgIGxldCBpbSA9ICR7aW5wdXQuZ2V0QnlPZmZzZXQoJ2knKX0gKiAke3NpbkNhY2hlLmdldCgncG9zaXRpb25faWQnLCAnYnNuaFszXScpfSArXG4gICAgICAgICAgICAgICAgJHtpbnB1dC5nZXRCeU9mZnNldCgnaicpfSAqICR7Y29zQ2FjaGUuZ2V0KCdwb3NpdGlvbl9pZCcsICdic25oWzNdJyl9O1xuICAgICAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2onLCAnaW0nKX1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGsgPSBkb3QoYnNuaCwgdW5pZm9ybXMuaW5wdXRfb3V0cHV0X3N0cmlkZXMpICsgaGFsZl9yb3RhcnlfZW1iX2RpbTtcbiAgICAgICAgICAgICR7b3V0cHV0LnNldEJ5T2Zmc2V0KCdrJywgaW5wdXQuZ2V0QnlPZmZzZXQoJ2snKSl9XG4gICAgICAgICAgfVxuICAgICAgICB9YDtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdSb3RhcnlFbWJlZGRpbmcnLFxuICAgIHNoYWRlckNhY2hlOiB7XG4gICAgICBoaW50OiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoe1xuICAgICAgICBpbnRlcmxlYXZlZCxcbiAgICAgIH0pLmNhY2hlS2V5LFxuICAgICAgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuaycsICdyYW5rJywgJ3JhbmsnLCAncmFuayddLFxuICAgIH0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBbeyBkaW1zOiBpbnB1dHNbMF0uZGltcywgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKFNoYXBlVXRpbC5zaXplKGdsb2JhbFNoYXBlKSAvIFdPUktHUk9VUF9TSVpFKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHJvdGFyeUVtYmVkZGluZyA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCwgYXR0cmlidXRlczogUm90YXJ5RW1iZWRkaW5nQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICB2YWxpZGF0ZUlucHV0cyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcyk7XG4gIGNvbnRleHQuY29tcHV0ZShjcmVhdGVSb3RhcnlFbWJlZGRpbmdQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgYXR0cmlidXRlcykpO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBjYXN0VG9GMzIsXG4gIGdldE1heENvbXBvbmVudHMsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIHN1bVZlY3RvcixcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNraXBMYXllck5vcm1BdHRyaWJ1dGVzIHtcbiAgc2ltcGxpZmllZDogYm9vbGVhbjtcbiAgZXBzaWxvbjogbnVtYmVyO1xufVxuXG5jb25zdCB2YWxpZGF0ZUlucHV0cyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMykge1xuICAgIHRocm93IG5ldyBFcnJvcignbGF5ZXJOb3JtIHJlcXVpcmVzIGF0IGxlYXN0IDMgaW5wdXRzLicpO1xuICB9XG5cbiAgY29uc3QgaW5wdXQ6IFRlbnNvclZpZXcgPSBpbnB1dHNbMF07XG4gIGNvbnN0IHNraXA6IFRlbnNvclZpZXcgPSBpbnB1dHNbMV07XG4gIGNvbnN0IGdhbW1hOiBUZW5zb3JWaWV3ID0gaW5wdXRzWzJdO1xuXG4gIGlmIChpbnB1dC5kYXRhVHlwZSAhPT0gc2tpcC5kYXRhVHlwZSB8fCBpbnB1dC5kYXRhVHlwZSAhPT0gZ2FtbWEuZGF0YVR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsbCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZScpO1xuICB9XG5cbiAgaWYgKGlucHV0LmRpbXMubGVuZ3RoICE9PSAzICYmIGlucHV0LmRpbXMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBtdXN0IGJlIDJEIG9yIDNEJyk7XG4gIH1cblxuICBpZiAoc2tpcC5kaW1zLmxlbmd0aCAhPT0gMyAmJiBza2lwLmRpbXMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTa2lwIG11c3QgYmUgMkQgb3IgM0QnKTtcbiAgfVxuXG4gIGNvbnN0IGhpZGRlblNpemUgPSBpbnB1dC5kaW1zW2lucHV0LmRpbXMubGVuZ3RoIC0gMV07XG4gIGNvbnN0IHNlcXVlbmNlTGVuZ3RoID0gaW5wdXQuZGltc1tpbnB1dC5kaW1zLmxlbmd0aCAtIDJdO1xuICBpZiAoc2tpcC5kaW1zW3NraXAuZGltcy5sZW5ndGggLSAxXSAhPT0gaGlkZGVuU2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2tpcCBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXQnKTtcbiAgfVxuICBpZiAoc2tpcC5kaW1zW3NraXAuZGltcy5sZW5ndGggLSAyXSAhPT0gc2VxdWVuY2VMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NraXAgbXVzdCBoYXZlIHRoZSBzYW1lIHNlcXVlbmNlIGxlbmd0aCBhcyBpbnB1dCcpO1xuICB9XG5cbiAgaWYgKGdhbW1hLmRpbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHYW1tYSBtdXN0IGJlIDFEJyk7XG4gIH1cbiAgaWYgKGdhbW1hLmRpbXNbZ2FtbWEuZGltcy5sZW5ndGggLSAxXSAhPT0gaGlkZGVuU2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignR2FtbWEgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0Jyk7XG4gIH1cbiAgaWYgKGlucHV0cy5sZW5ndGggPiAzKSB7XG4gICAgY29uc3QgYmV0YTogVGVuc29yVmlldyA9IGlucHV0c1szXTtcbiAgICBpZiAoYmV0YS5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCZXRhIG11c3QgYmUgMUQnKTtcbiAgICB9XG4gICAgaWYgKGJldGEuZGltc1tiZXRhLmRpbXMubGVuZ3RoIC0gMV0gIT09IGhpZGRlblNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmV0YSBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXQnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlucHV0cy5sZW5ndGggPiA0KSB7XG4gICAgY29uc3QgYmlhczogVGVuc29yVmlldyA9IGlucHV0c1s0XTtcbiAgICBpZiAoYmlhcy5kaW1zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCaWFzIG11c3QgYmUgMUQnKTtcbiAgICB9XG4gICAgaWYgKGJpYXMuZGltc1tiaWFzLmRpbXMubGVuZ3RoIC0gMV0gIT09IGhpZGRlblNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQmlhcyBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXQnKTtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IGNyZWF0ZVNraXBMYXllck5vcm1Qcm9ncmFtSW5mbyA9IChcbiAgaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGF0dHJpYnV0ZXM6IFNraXBMYXllck5vcm1BdHRyaWJ1dGVzLFxuICBvdXRwdXRDb3VudDogbnVtYmVyLFxuICBpc1RyYWluaW5nOiBib29sZWFuLFxuKTogUHJvZ3JhbUluZm8gPT4ge1xuICBjb25zdCBzaW1wbGlmaWVkID0gYXR0cmlidXRlcy5zaW1wbGlmaWVkO1xuXG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgaW5wdXRTaXplID0gU2hhcGVVdGlsLnNpemUoaW5wdXRTaGFwZSk7XG4gIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IGlucHV0U2l6ZTtcbiAgY29uc3QgaGlkZGVuU2l6ZSA9IGlucHV0U2hhcGUuc2xpY2UoLTEpWzBdO1xuICBjb25zdCBtZWFuSW52U3RkRGV2RGltID0gaXNUcmFpbmluZyA/IGlucHV0U2hhcGUuc2xpY2UoMCwgLTEpLmNvbmNhdCgxKSA6IFtdO1xuICBjb25zdCBoYXNCZXRhSW5wdXQgPSAhc2ltcGxpZmllZCAmJiBpbnB1dHMubGVuZ3RoID4gMztcbiAgY29uc3QgaGFzQmlhc0lucHV0ID0gaW5wdXRzLmxlbmd0aCA+IDQ7XG4gIGNvbnN0IGhhc01lYW5PdXRwdXQgPSBpc1RyYWluaW5nICYmIG91dHB1dENvdW50ID4gMTtcbiAgY29uc3QgaGFzSW52U3RkRGV2T3V0cHV0ID0gaXNUcmFpbmluZyAmJiBvdXRwdXRDb3VudCA+IDI7XG4gIGNvbnN0IGhhc0lucHV0U2tpcEJpYXNTdW1PdXRwdXQgPSBvdXRwdXRDb3VudCA+IDM7XG4gIGNvbnN0IHdvcmtncm91cFNpemUgPSA2NDtcblxuICBjb25zdCBjb21wb25lbnRzID0gZ2V0TWF4Q29tcG9uZW50cyhoaWRkZW5TaXplKTtcblxuICBjb25zdCBwcm9ncmFtVW5pZm9ybXM6IFByb2dyYW1Vbmlmb3JtW10gPSBbXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IG91dHB1dFNpemUgfSxcbiAgICB7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogY29tcG9uZW50cyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBoaWRkZW5TaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS5mbG9hdCwgZGF0YTogYXR0cmlidXRlcy5lcHNpbG9uIH0sXG4gIF07XG4gIGNvbnN0IGdldFNoYWRlclNvdXJjZSA9IChzaGFkZXJIZWxwZXI6IFNoYWRlckhlbHBlcikgPT4ge1xuICAgIGNvbnN0IHVuaWZvcm1zQXJyYXk6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgICAgeyBuYW1lOiAnb3V0cHV0X3NpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgICAgeyBuYW1lOiAnY29tcG9uZW50cycsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdoaWRkZW5fc2l6ZScsIHR5cGU6ICd1MzInIH0sXG4gICAgICB7IG5hbWU6ICdlcHNpbG9uJywgdHlwZTogJ2YzMicgfSxcbiAgICBdO1xuICAgIGNvbnN0IHZhcmlhYmxlcyA9IFtcbiAgICAgIGlucHV0VmFyaWFibGUoJ3gnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLCBjb21wb25lbnRzKSxcbiAgICAgIGlucHV0VmFyaWFibGUoJ3NraXAnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zLCBjb21wb25lbnRzKSxcbiAgICAgIGlucHV0VmFyaWFibGUoJ2dhbW1hJywgaW5wdXRzWzJdLmRhdGFUeXBlLCBpbnB1dHNbMl0uZGltcywgY29tcG9uZW50cyksXG4gICAgXTtcbiAgICBpZiAoaGFzQmV0YUlucHV0KSB7XG4gICAgICB2YXJpYWJsZXMucHVzaChpbnB1dFZhcmlhYmxlKCdiZXRhJywgaW5wdXRzWzNdLmRhdGFUeXBlLCBpbnB1dHNbM10uZGltcywgY29tcG9uZW50cykpO1xuICAgIH1cbiAgICBpZiAoaGFzQmlhc0lucHV0KSB7XG4gICAgICB2YXJpYWJsZXMucHVzaChpbnB1dFZhcmlhYmxlKCdiaWFzJywgaW5wdXRzWzRdLmRhdGFUeXBlLCBpbnB1dHNbNF0uZGltcywgY29tcG9uZW50cykpO1xuICAgIH1cbiAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnb3V0cHV0JywgaW5wdXRzWzBdLmRhdGFUeXBlLCBvdXRwdXRTaGFwZSwgY29tcG9uZW50cykpO1xuICAgIGlmIChoYXNNZWFuT3V0cHV0KSB7XG4gICAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnbWVhbl9vdXRwdXQnLCBEYXRhVHlwZS5mbG9hdCwgbWVhbkludlN0ZERldkRpbSkpO1xuICAgIH1cbiAgICBpZiAoaGFzSW52U3RkRGV2T3V0cHV0KSB7XG4gICAgICB2YXJpYWJsZXMucHVzaChvdXRwdXRWYXJpYWJsZSgnaW52X3N0ZF9vdXRwdXQnLCBEYXRhVHlwZS5mbG9hdCwgbWVhbkludlN0ZERldkRpbSkpO1xuICAgIH1cbiAgICBpZiAoaGFzSW5wdXRTa2lwQmlhc1N1bU91dHB1dCkge1xuICAgICAgdmFyaWFibGVzLnB1c2gob3V0cHV0VmFyaWFibGUoJ2lucHV0X3NraXBfYmlhc19zdW0nLCBpbnB1dHNbMF0uZGF0YVR5cGUsIG91dHB1dFNoYXBlLCBjb21wb25lbnRzKSk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGFUeXBlID0gdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0c1swXS5kYXRhVHlwZSk7XG4gICAgY29uc3QgdmVjRGF0YVR5cGUgPSB0ZW5zb3JUeXBlVG9Xc2dsU3RvcmFnZVR5cGUoRGF0YVR5cGUuZmxvYXQsIGNvbXBvbmVudHMpO1xuICAgIHJldHVybiBgXG5cbiAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXNBcnJheSkuZGVjbGFyZVZhcmlhYmxlcyguLi52YXJpYWJsZXMpfVxuICAgICAgdmFyPHdvcmtncm91cD4gc3VtX3NoYXJlZCA6IGFycmF5PCR7dmVjRGF0YVR5cGV9LCAke3dvcmtncm91cFNpemV9PjtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHN1bV9zcXVhcmVkX3NoYXJlZCA6IGFycmF5PCR7dmVjRGF0YVR5cGV9LCAke3dvcmtncm91cFNpemV9PjtcblxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KFt3b3JrZ3JvdXBTaXplLCAxLCAxXSl9XG4gICAgICAgIGxldCBpeCA9IGxvY2FsX2lkLng7XG4gICAgICAgIGxldCBpeSA9IGdsb2JhbF9pZC54IC8gJHt3b3JrZ3JvdXBTaXplfTtcblxuICAgICAgICBsZXQgaGlkZGVuX3NpemVfdmVjdG9yaXplZDogdTMyID0gdW5pZm9ybXMuaGlkZGVuX3NpemUgLyB1bmlmb3Jtcy5jb21wb25lbnRzO1xuICAgICAgICB2YXIgc3RyaWRlID0gaGlkZGVuX3NpemVfdmVjdG9yaXplZCAvICR7d29ya2dyb3VwU2l6ZX07XG4gICAgICAgIGxldCBvZmZzZXQgPSBpeCAqIHN0cmlkZSArIGl5ICogaGlkZGVuX3NpemVfdmVjdG9yaXplZDtcbiAgICAgICAgbGV0IG9mZnNldDFkID0gc3RyaWRlICogaXg7XG4gICAgICAgIGlmIChpeCA9PSAke3dvcmtncm91cFNpemUgLSAxfSkge1xuICAgICAgICAgIHN0cmlkZSA9IGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQgLSBzdHJpZGUgKiBpeDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgc3RyaWRlOyBpKyspIHtcbiAgICAgICAgICBsZXQgc2tpcF92YWx1ZSA9IHNraXBbb2Zmc2V0ICsgaV07XG4gICAgICAgICAgbGV0IGJpYXNfdmFsdWUgPSAke2hhc0JpYXNJbnB1dCA/ICdiaWFzW29mZnNldDFkICsgaV0nIDogZGF0YVR5cGUgKyAnKDAuMCknfTtcbiAgICAgICAgICBsZXQgaW5wdXRfdmFsdWUgPSB4W29mZnNldCArIGldO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGlucHV0X3ZhbHVlICsgc2tpcF92YWx1ZSArIGJpYXNfdmFsdWU7XG4gICAgICAgICAgJHtoYXNJbnB1dFNraXBCaWFzU3VtT3V0cHV0ID8gJ2lucHV0X3NraXBfYmlhc19zdW1bb2Zmc2V0ICsgaV0gPSB2YWx1ZTsnIDogJyd9XG4gICAgICAgICAgb3V0cHV0W29mZnNldCArIGldID0gdmFsdWU7XG4gICAgICAgICAgbGV0IGYzMl92YWx1ZSA9ICR7Y2FzdFRvRjMyKGRhdGFUeXBlLCBjb21wb25lbnRzLCAndmFsdWUnKX07XG4gICAgICAgICAgc3VtX3NoYXJlZFtpeF0gKz0gZjMyX3ZhbHVlO1xuICAgICAgICAgIHN1bV9zcXVhcmVkX3NoYXJlZFtpeF0gKz0gZjMyX3ZhbHVlICogZjMyX3ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICB2YXIgcmVkdWNlX3NpemUgOiB1MzIgPSAke3dvcmtncm91cFNpemV9O1xuICAgICAgICBmb3IgKHZhciBjdXJyX3NpemUgPSByZWR1Y2Vfc2l6ZSA+PiAxOyAgY3Vycl9zaXplID4gMDsgY3Vycl9zaXplID0gcmVkdWNlX3NpemUgPj4gMSkge1xuICAgICAgICAgIHJlZHVjZV9zaXplID0gY3Vycl9zaXplICsgKHJlZHVjZV9zaXplICYgMSk7XG4gICAgICAgICAgaWYgKGl4IDwgY3Vycl9zaXplKSB7XG4gICAgICAgICAgICBzdW1fc2hhcmVkW2l4XSArPSBzdW1fc2hhcmVkW2l4ICsgcmVkdWNlX3NpemVdO1xuICAgICAgICAgICAgc3VtX3NxdWFyZWRfc2hhcmVkW2l4XSArPSBzdW1fc3F1YXJlZF9zaGFyZWRbaXggKyByZWR1Y2Vfc2l6ZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdW0gPSBzdW1fc2hhcmVkWzBdO1xuICAgICAgICBsZXQgc3F1YXJlX3N1bSA9IHN1bV9zcXVhcmVkX3NoYXJlZFswXTtcbiAgICAgICAgbGV0IG1lYW4gPSAke3N1bVZlY3Rvcignc3VtJywgY29tcG9uZW50cyl9IC8gZjMyKHVuaWZvcm1zLmhpZGRlbl9zaXplKTtcbiAgICAgICAgbGV0IGludl9zdGRfZGV2ID0gaW52ZXJzZVNxcnQoJHtzdW1WZWN0b3IoJ3NxdWFyZV9zdW0nLCBjb21wb25lbnRzKX0gLyBmMzIodW5pZm9ybXMuaGlkZGVuX3NpemUpICR7XG4gICAgICAgICAgc2ltcGxpZmllZCA/ICcnIDogJy0gbWVhbiAqIG1lYW4nXG4gICAgICAgIH0gKyB1bmlmb3Jtcy5lcHNpbG9uKTtcbiAgICAgICAgJHtoYXNNZWFuT3V0cHV0ID8gJ21lYW5fb3V0cHV0W2dsb2JhbF9pZHhdID0gbWVhbjsnIDogJyd9XG4gICAgICAgICR7aGFzSW52U3RkRGV2T3V0cHV0ID8gJ2ludl9zdGRfb3V0cHV0W2dsb2JhbF9pZHhdID0gaW52X3N0ZF9kZXY7JyA6ICcnfVxuXG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCBzdHJpZGU7IGkrKykge1xuICAgICAgICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IChvdXRwdXRbb2Zmc2V0ICsgaV0gJHtzaW1wbGlmaWVkID8gJycgOiBgLSAke2RhdGFUeXBlfShtZWFuKWB9KSAqXG4gICAgICAgICAgICAke2RhdGFUeXBlfShpbnZfc3RkX2RldikgKiBnYW1tYVtvZmZzZXQxZCArIGldXG4gICAgICAgICAgICAke2hhc0JldGFJbnB1dCA/ICcrIGJldGFbb2Zmc2V0MWQgKyBpXScgOiAnJ307XG4gICAgICAgIH1cbiAgICAgIH1gO1xuICB9O1xuICBjb25zdCBvdXRwdXRzID0gW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBpbnB1dHNbMF0uZGF0YVR5cGUgfV07XG4gIGlmIChvdXRwdXRDb3VudCA+IDEpIHtcbiAgICBvdXRwdXRzLnB1c2goeyBkaW1zOiBtZWFuSW52U3RkRGV2RGltLCBkYXRhVHlwZTogRGF0YVR5cGUuZmxvYXQgfSk7XG4gIH1cbiAgaWYgKG91dHB1dENvdW50ID4gMikge1xuICAgIG91dHB1dHMucHVzaCh7IGRpbXM6IG1lYW5JbnZTdGREZXZEaW0sIGRhdGFUeXBlOiBEYXRhVHlwZS5mbG9hdCB9KTtcbiAgfVxuICBpZiAob3V0cHV0Q291bnQgPiAzKSB7XG4gICAgb3V0cHV0cy5wdXNoKHsgZGltczogaW5wdXRTaGFwZSwgZGF0YVR5cGU6IGlucHV0c1swXS5kYXRhVHlwZSB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdTa2lwTGF5ZXJOb3JtYWxpemF0aW9uJyxcbiAgICBzaGFkZXJDYWNoZToge1xuICAgICAgaGludDogYCR7Y29tcG9uZW50c307JHtoYXNNZWFuT3V0cHV0fTske2hhc0ludlN0ZERldk91dHB1dH07JHtoYXNJbnB1dFNraXBCaWFzU3VtT3V0cHV0fWAsXG4gICAgICBpbnB1dERlcGVuZGVuY2llczogaW5wdXRzLm1hcCgoX2lucHV0LCBfaW5kZXgpID0+ICd0eXBlJyksXG4gICAgfSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHMsXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7XG4gICAgICAgIHg6IE1hdGguY2VpbChvdXRwdXRTaXplIC8gaGlkZGVuU2l6ZSksXG4gICAgICB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHNraXBMYXllck5vcm0gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFNraXBMYXllck5vcm1BdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIC8vIFRPRE86IGluaXRpYWxpemUgaXNUcmFpbmluZyBmcm9tIENvbXB1dGVDb250ZXh0XG4gIGNvbnN0IGlzVHJhaW5pbmcgPSBmYWxzZTtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICAvLyBNZWFuIGFuZCBJbnZTdGREZXYgYXJlIG9ubHkgdXNlZCBpbiB0cmFpbmluZyBtb2RlIGFuZCBhcmUgbm90IHJlcXVpcmVkIGZvciBpbmZlcmVuY2UuXG4gIC8vIFRoZXkgYXJlIGFkZGVkIGhlcmUgZm9yIGNvbXBsZXRlbmVzcyBvbmx5LlxuICBjb25zdCBvdXRwdXRzID0gWzBdO1xuICBpZiAoY29udGV4dC5vdXRwdXRDb3VudCA+IDEpIHtcbiAgICBvdXRwdXRzLnB1c2goaXNUcmFpbmluZyA/IDEgOiAtMyk7XG4gIH1cbiAgaWYgKGNvbnRleHQub3V0cHV0Q291bnQgPiAyKSB7XG4gICAgb3V0cHV0cy5wdXNoKGlzVHJhaW5pbmcgPyAyIDogLTMpO1xuICB9XG4gIGlmIChjb250ZXh0Lm91dHB1dENvdW50ID4gMykge1xuICAgIG91dHB1dHMucHVzaCgzKTtcbiAgfVxuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlU2tpcExheWVyTm9ybVByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzLCBhdHRyaWJ1dGVzLCBjb250ZXh0Lm91dHB1dENvdW50LCBpc1RyYWluaW5nKSwge1xuICAgIG91dHB1dHMsXG4gIH0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8sIFByb2dyYW1Vbmlmb3JtLCBUZW5zb3JJbmZvIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge1xuICBjcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyxcbiAgZ2V0RWxlbWVudEF0LFxuICBJbmRpY2VzSGVscGVyLFxuICBpbnB1dFZhcmlhYmxlLFxuICBvdXRwdXRWYXJpYWJsZSxcbiAgU2hhZGVySGVscGVyLFxuICBVbmlmb3Jtc0FycmF5VHlwZSxcbn0gZnJvbSAnLi9jb21tb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWNlQXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IHN0YXJ0czogbnVtYmVyW107XG4gIHJlYWRvbmx5IGVuZHM6IG51bWJlcltdO1xuICByZWFkb25seSBheGVzOiBudW1iZXJbXTtcbn1cblxuY29uc3QgdmFsaWRhdGVJbnB1dHMgPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFNsaWNlQXR0cmlidXRlcyk6IHZvaWQgPT4ge1xuICBpZiAoIWlucHV0cyB8fCBpbnB1dHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndG9vIGZldyBpbnB1dHMnKTtcbiAgfVxuICBpZiAoYXR0cmlidXRlcy5heGVzLmxlbmd0aCAhPT0gMCkge1xuICAgIGlmIChhdHRyaWJ1dGVzLmF4ZXMubGVuZ3RoICE9PSBhdHRyaWJ1dGVzLnN0YXJ0cy5sZW5ndGggfHwgYXR0cmlidXRlcy5heGVzLmxlbmd0aCAhPT0gYXR0cmlidXRlcy5lbmRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdheGVzLCBzdGFydHMgYW5kIGVuZHMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aCcpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLnN0YXJ0cy5sZW5ndGggIT09IGF0dHJpYnV0ZXMuZW5kcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0cyBhbmQgZW5kcyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoJyk7XG4gIH1cbiAgaW5wdXRzLnNsaWNlKDEpLmZvckVhY2goKF8sIGlkeCkgPT4ge1xuICAgIGlmIChpbnB1dHNbaWR4ICsgMV0uZGF0YVR5cGUgIT09IERhdGFUeXBlLmludDMyICYmIGlucHV0c1tpZHggKyAxXS5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuaW50NjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJHtpZHh9IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50MzIgb3IgaW50NjRgKTtcbiAgICB9XG4gIH0pO1xufTtcblxuY29uc3QgcmVhZElucHV0ID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBpZHg6IG51bWJlcik6IG51bWJlcltdID0+IHtcbiAgY29uc3QgaW5wdXQ6IG51bWJlcltdID0gW107XG4gIGlmIChpbnB1dHMubGVuZ3RoID4gaWR4KSB7XG4gICAgaWYgKGlucHV0c1tpZHhdLmRhdGFUeXBlID09PSBEYXRhVHlwZS5pbnQ2NCkge1xuICAgICAgaW5wdXRzW2lkeF0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2goKHYpID0+IGlucHV0LnB1c2goTnVtYmVyKHYpKSk7XG4gICAgfSBlbHNlIGlmIChpbnB1dHNbaWR4XS5kYXRhVHlwZSA9PT0gRGF0YVR5cGUuaW50MzIpIHtcbiAgICAgIGlucHV0c1tpZHhdLmdldEludDMyQXJyYXkoKS5mb3JFYWNoKCh2KSA9PiBpbnB1dC5wdXNoKE51bWJlcih2KSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICR7aWR4fSBtdXN0IGJlIGFuIGFycmF5IG9mIGludDMyIG9yIGludDY0YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbmNvbnN0IGNyZWF0ZVNsaWNlQXR0cmlidXRlc0Zyb21JbnB1dHMgPSAoXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBhdHRyaWJ1dGVzOiBTbGljZUF0dHJpYnV0ZXMsXG4pOiBTbGljZUF0dHJpYnV0ZXMgPT4ge1xuICBpZiAoaW5wdXRzLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBzdGFydHM6IG51bWJlcltdID0gcmVhZElucHV0KGlucHV0cywgMSk7XG4gICAgY29uc3QgZW5kczogbnVtYmVyW10gPSByZWFkSW5wdXQoaW5wdXRzLCAyKTtcbiAgICBsZXQgYXhlczogbnVtYmVyW10gPSByZWFkSW5wdXQoaW5wdXRzLCAzKTtcbiAgICBpZiAoYXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGF4ZXMgPSBbLi4uQXJyYXkoaW5wdXRzWzBdLmRpbXMubGVuZ3RoKS5rZXlzKCldO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgc3RhcnRzLCBlbmRzLCBheGVzIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICB9XG59O1xuXG5jb25zdCBmaXhTdGFydEVuZFZhbHVlcyA9IChcbiAgdmFsdWU6IG51bWJlcixcbiAgaW5kZXg6IG51bWJlcixcbiAgaW5wdXRTaGFwZTogcmVhZG9ubHkgbnVtYmVyW10sXG4gIGF4ZXM6IHJlYWRvbmx5IG51bWJlcltdLFxuICBzdGVwczogcmVhZG9ubHkgbnVtYmVyW10sXG4pOiBudW1iZXIgPT4ge1xuICBsZXQgbmV3VmFsdWUgPSB2YWx1ZTtcbiAgaWYgKHZhbHVlIDwgMCkge1xuICAgIG5ld1ZhbHVlICs9IGlucHV0U2hhcGVbYXhlc1tpbmRleF1dO1xuICB9XG4gIGlmIChzdGVwc1tpbmRleF0gPCAwKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKG5ld1ZhbHVlLCBpbnB1dFNoYXBlW2F4ZXNbaW5kZXhdXSAtIDEpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4obmV3VmFsdWUsIGlucHV0U2hhcGVbYXhlc1tpbmRleF1dKSk7XG4gIH1cbn07XG5cbmNvbnN0IGNhbGN1bGF0ZUlucHV0SW5kaWNlc0ltcGwgPSAoXG4gIGlucHV0OiBJbmRpY2VzSGVscGVyLFxuICBvdXRwdXQ6IEluZGljZXNIZWxwZXIsXG4gIGlucHV0U2hhcGU6IHJlYWRvbmx5IG51bWJlcltdLFxuKTogc3RyaW5nID0+XG4gIGBmbiBjYWxjdWxhdGVJbnB1dEluZGljZXMob3V0cHV0X2luZGljZXM6ICR7b3V0cHV0LnR5cGUuaW5kaWNlc30pIC0+ICR7aW5wdXQudHlwZS5pbmRpY2VzfSB7XG4gICAgICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7aW5wdXQudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgICB2YXIgY2FycnkgPSAwdTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gJHtpbnB1dFNoYXBlLmxlbmd0aH07IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgaW5wdXRfc2hhcGVfaSA9ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5pbnB1dF9zaGFwZScsICdpJywgaW5wdXRTaGFwZS5sZW5ndGgpfTtcbiAgICAgICAgICAgIGxldCBzdGVwc19pID0gJHtnZXRFbGVtZW50QXQoJ3VuaWZvcm1zLnN0ZXBzJywgJ2knLCBpbnB1dFNoYXBlLmxlbmd0aCl9O1xuICAgICAgICAgICAgbGV0IHNpZ25zX2kgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuc2lnbnMnLCAnaScsIGlucHV0U2hhcGUubGVuZ3RoKX07XG4gICAgICAgICAgICBsZXQgc3RhcnRzX2kgPSAke2dldEVsZW1lbnRBdCgndW5pZm9ybXMuc3RhcnRzJywgJ2knLCBpbnB1dFNoYXBlLmxlbmd0aCl9O1xuICAgICAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7b3V0cHV0LmluZGljZXNHZXQoJ291dHB1dF9pbmRpY2VzJywgJ2knKX07XG4gICAgICAgICAgICB2YXIgaW5wdXRfaW5kZXggPSBvdXRwdXRfaW5kZXggKiBzdGVwc19pICsgc3RhcnRzX2kgKyBjYXJyeTtcbiAgICAgICAgICAgIGNhcnJ5ID0gaW5wdXRfaW5kZXggLyBpbnB1dF9zaGFwZV9pO1xuICAgICAgICAgICAgaW5wdXRfaW5kZXggPSBpbnB1dF9pbmRleCAlIGlucHV0X3NoYXBlX2k7XG4gICAgICAgICAgICBpZiAoc2lnbnNfaSA8IDApIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSBpbnB1dF9zaGFwZV9pIC0gaW5wdXRfaW5kZXggLSAxdSArIHN0YXJ0c19pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbnB1dF9pbmRpY2VzJywgJ2knLCAnaW5wdXRfaW5kZXgnKX07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpbnB1dF9pbmRpY2VzO1xuICAgICAgfWA7XG5cbmNvbnN0IGNyZWF0ZVNsaWNlUHJvZ3JhbUluZm8gPSAoaW5wdXRzOiByZWFkb25seSBUZW5zb3JWaWV3W10sIGF0dHJpYnV0ZXM6IFNsaWNlQXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0c1swXS5kaW1zO1xuICBjb25zdCBpbnB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShpbnB1dFNoYXBlKTtcbiAgY29uc3QgYXhlcyA9XG4gICAgYXR0cmlidXRlcy5heGVzLmxlbmd0aCA+IDBcbiAgICAgID8gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4ZXMoYXR0cmlidXRlcy5heGVzLCBpbnB1dFNoYXBlLmxlbmd0aClcbiAgICAgIDogWy4uLkFycmF5KGlucHV0U2hhcGUubGVuZ3RoKS5rZXlzKCldO1xuICBsZXQgc3RlcHMgPSByZWFkSW5wdXQoaW5wdXRzLCA0KTtcbiAgc3RlcHMuZm9yRWFjaChcbiAgICAoc3RlcCkgPT5cbiAgICAgIHN0ZXAgIT09IDAgfHxcbiAgICAgICgoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RlcCBjYW5ub3QgYmUgMCcpO1xuICAgICAgfSksXG4gICk7XG4gIGlmIChzdGVwcy5sZW5ndGggPT09IDApIHtcbiAgICBzdGVwcyA9IEFycmF5KGF4ZXMubGVuZ3RoKS5maWxsKDEpO1xuICB9XG4gIGNvbnN0IHN0YXJ0cyA9IGF0dHJpYnV0ZXMuc3RhcnRzLm1hcCgoc3RhcnQsIGkpID0+IGZpeFN0YXJ0RW5kVmFsdWVzKHN0YXJ0LCBpLCBpbnB1dFNoYXBlLCBheGVzLCBzdGVwcykpO1xuXG4gIGNvbnN0IGVuZHMgPSBhdHRyaWJ1dGVzLmVuZHMubWFwKChlbmQsIGkpID0+IGZpeFN0YXJ0RW5kVmFsdWVzKGVuZCwgaSwgaW5wdXRTaGFwZSwgYXhlcywgc3RlcHMpKTtcblxuICBpZiAoYXhlcy5sZW5ndGggIT09IHN0YXJ0cy5sZW5ndGggfHwgYXhlcy5sZW5ndGggIT09IGVuZHMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydCwgZW5kcyBhbmQgYXhlcyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMnKTtcbiAgfVxuXG4gIGlmIChheGVzLmxlbmd0aCAhPT0gaW5wdXRTaGFwZS5sZW5ndGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0U2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICghYXhlcy5pbmNsdWRlcyhpKSkge1xuICAgICAgICBzdGFydHMuc3BsaWNlKGksIDAsIDApO1xuICAgICAgICBlbmRzLnNwbGljZShpLCAwLCBpbnB1dFNoYXBlW2ldKTtcbiAgICAgICAgc3RlcHMuc3BsaWNlKGksIDAsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBzaWducyA9IHN0ZXBzLm1hcCgoc3RlcCkgPT4gTWF0aC5zaWduKHN0ZXApKTtcbiAgLy8gQ29udmVydCBuZWdhdGl2ZSBzdGVwcyB0byBwb3NpdGl2ZSBzdGVwcyBhbmQgcmV2ZXJzZSBzdGFydHMgYW5kIGVuZHNcbiAgc3RlcHMuZm9yRWFjaCgoc3RlcCwgaSwgYXJyYXkpID0+IHtcbiAgICBpZiAoc3RlcCA8IDApIHtcbiAgICAgIGNvbnN0IG51bVN0ZXBzID0gKGVuZHNbaV0gLSBzdGFydHNbaV0pIC8gc3RlcDtcbiAgICAgIGNvbnN0IG5ld0VuZCA9IHN0YXJ0c1tpXTtcbiAgICAgIGNvbnN0IG5ld1N0YXJ0ID0gbmV3RW5kICsgbnVtU3RlcHMgKiBzdGVwc1tpXTtcbiAgICAgIHN0YXJ0c1tpXSA9IG5ld1N0YXJ0O1xuICAgICAgZW5kc1tpXSA9IG5ld0VuZDtcbiAgICAgIGFycmF5W2ldID0gLXN0ZXA7XG4gICAgfVxuICB9KTtcbiAgLy8gT3V0cHV0IHJhbmsgaXMgZXhwZWN0ZWQgdG8gYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBpbnB1dCByYW5rLlxuICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoMCk7XG4gIGF4ZXMuZm9yRWFjaCgoYXhpcywgXykgPT4ge1xuICAgIG91dHB1dFNoYXBlW2F4aXNdID0gTWF0aC5jZWlsKChlbmRzW2F4aXNdIC0gc3RhcnRzW2F4aXNdKSAvIHN0ZXBzW2F4aXNdKTtcbiAgfSk7XG4gIGNvbnN0IG91dHB1dFRlbnNvckluZm86IFRlbnNvckluZm8gPSB7IGRpbXM6IG91dHB1dFNoYXBlLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH07XG5cbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ291dHB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoKTtcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGlucHV0c1swXS5kYXRhVHlwZSwgaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IFNoYXBlVXRpbC5zaXplKG91dHB1dFNoYXBlKTtcbiAgY29uc3QgdW5pZm9ybXM6IFVuaWZvcm1zQXJyYXlUeXBlID0gW1xuICAgIHsgbmFtZTogJ291dHB1dFNpemUnLCB0eXBlOiAndTMyJyB9LFxuICAgIHsgbmFtZTogJ3N0YXJ0cycsIHR5cGU6ICd1MzInLCBsZW5ndGg6IHN0YXJ0cy5sZW5ndGggfSxcbiAgICB7IG5hbWU6ICdzaWducycsIHR5cGU6ICdpMzInLCBsZW5ndGg6IHNpZ25zLmxlbmd0aCB9LFxuICAgIHsgbmFtZTogJ3N0ZXBzJywgdHlwZTogJ3UzMicsIGxlbmd0aDogc3RlcHMubGVuZ3RoIH0sXG4gIF07XG5cbiAgY29uc3QgcHJvZ3JhbVVuaWZvcm1zOiBQcm9ncmFtVW5pZm9ybVtdID0gW1xuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBvdXRwdXRTaXplIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHN0YXJ0cyB9LFxuICAgIHsgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IHNpZ25zIH0sXG4gICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHN0ZXBzIH0sXG4gICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoaW5wdXRzWzBdLmRpbXMsIG91dHB1dFNoYXBlKSxcbiAgXTtcblxuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgICAgICR7c2hhZGVySGVscGVyLnJlZ2lzdGVyVW5pZm9ybXModW5pZm9ybXMpLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIG91dHB1dCl9XG4gICAgICAgICR7Y2FsY3VsYXRlSW5wdXRJbmRpY2VzSW1wbChpbnB1dCwgb3V0cHV0LCBpbnB1dFNoYXBlKX1cbiAgICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgICAgJHtzaGFkZXJIZWxwZXIuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcygndW5pZm9ybXMub3V0cHV0U2l6ZScpfVxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7b3V0cHV0Lm9mZnNldFRvSW5kaWNlcygnZ2xvYmFsX2lkeCcpfTtcbiAgICAgICAgICBsZXQgaW5wdXRfaW5kaWNlcyA9IGNhbGN1bGF0ZUlucHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICAgICAgJHtvdXRwdXQuc2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnLCBpbnB1dC5nZXRCeUluZGljZXMoJ2lucHV0X2luZGljZXMnKSl9XG4gICAgICB9YDtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnU2xpY2UnLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke3NpZ25zLmxlbmd0aH1fJHtzdGFydHMubGVuZ3RofV8ke3N0ZXBzLmxlbmd0aH1gLCBpbnB1dERlcGVuZGVuY2llczogWydyYW5rJ10gfSxcbiAgICBnZXRTaGFkZXJTb3VyY2UsXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFtvdXRwdXRUZW5zb3JJbmZvXSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKGlucHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHNsaWNlID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBTbGljZUF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBjb25zdCB1cGRhdGVkQXR0cmlidXRlcyA9IGNyZWF0ZVNsaWNlQXR0cmlidXRlc0Zyb21JbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlU2xpY2VQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgdXBkYXRlZEF0dHJpYnV0ZXMpLCB7IGlucHV0czogWzBdIH0pO1xuICAvLyBpZiAoU2hhcGVVdGlsLnNpemUocHJvZ3JhbS5vdXRwdXRzWzBdLmRpbXMpID4gMCkge1xuICAvLyAgIGNvbnRleHQuY29tcHV0ZShwcm9ncmFtSW5mb0xvYWRlciwge2lucHV0czogWzBdfSk7XG4gIC8vIH0gZWxzZSB7XG4gIC8vICAgLy8gVE9ETzogc3VwcG9ydCBlbXB0eSBvdXRwdXRcbiAgLy8gICB0aHJvdyBuZXcgRXJyb3IoJ3NsaWNlOiBvdXRwdXQgc2l6ZSBpcyAwJyk7XG4gIC8vIH1cbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVNsaWNlQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFNsaWNlQXR0cmlidXRlcyA9PiB7XG4gIGNvbnN0IHN0YXJ0cyA9IGF0dHJpYnV0ZXMuc3RhcnRzIGFzIG51bWJlcltdO1xuICBjb25zdCBlbmRzID0gYXR0cmlidXRlcy5lbmRzIGFzIG51bWJlcltdO1xuICBjb25zdCBheGVzID0gYXR0cmlidXRlcy5heGVzIGFzIG51bWJlcltdO1xuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgc3RhcnRzLCBlbmRzLCBheGVzIH0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLy8gVE9ETzogdGhpcyBpcyB0aGUgc2FtZSBuYWl2ZSBpbXBsZW1lbnRhdGlvbiB3ZSB1c2UgZm9yIHJlZHVjZSB0aGF0IGhhc1xuLy8gcGVyZm9ybWFuY2UgbGltaXRhdGlvbnMgd2hlbiB0aGUgcmVkdWNlZCBheGlzIGlzIGxvbmcuIE5lZWQgdG8gYWRkXG4vLyBhIG9wdGltaXplZCBjb2RlcGF0aCBmb3IgdGhpcy5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXksIGNyZWF0ZUF0dHJpYnV0ZVdpdGhDYWNoZUtleSB9IGZyb20gJy4uL2F0dHJpYnV0ZS13aXRoLWNhY2hlLWtleSc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGdldE1heENvbXBvbmVudHMsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG4gIHN1bVZlY3RvcixcbiAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlLFxufSBmcm9tICcuL2NvbW1vbic7XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NvZnRtYXggb3AgcmVxdWlyZXMgMSBpbnB1dC4nKTtcbiAgfVxufTtcblxuZXhwb3J0IGludGVyZmFjZSBTb2Z0bWF4QXR0cmlidXRlcyBleHRlbmRzIEF0dHJpYnV0ZVdpdGhDYWNoZUtleSB7XG4gIHJlYWRvbmx5IGF4aXM6IG51bWJlcjtcbn1cblxuY29uc3QgY3JlYXRlU29mdG1heFByb2dyYW1JbmZvID0gKGlucHV0OiBUZW5zb3JWaWV3LCBhdHRyaWJ1dGVzOiBTb2Z0bWF4QXR0cmlidXRlcyk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3Qgc2hhcGUgPSBpbnB1dC5kaW1zO1xuICBjb25zdCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUoc2hhcGUpO1xuICBjb25zdCBXRyA9IDY0O1xuICBsZXQgYXhpcyA9IGF0dHJpYnV0ZXMuYXhpcztcbiAgaWYgKGF4aXMgPCAwKSB7XG4gICAgYXhpcyA9IHNoYXBlLmxlbmd0aCArIGF4aXM7XG4gIH1cbiAgaWYgKGF4aXMgPCBzaGFwZS5sZW5ndGggLSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb2Z0bWF4IG9ubHkgc3VwcG9ydHMgbGFzdCBheGlzIGZvciBub3cuJyk7XG4gIH1cblxuICBjb25zdCBjb2xzID0gc2hhcGVbYXhpc107XG4gIGNvbnN0IHJvd3MgPSBvdXRwdXRTaXplIC8gY29scztcbiAgY29uc3QgY29tcG9uZW50cyA9IGdldE1heENvbXBvbmVudHMoY29scyk7XG4gIGNvbnN0IHBhY2tlZENvbHMgPSBjb2xzIC8gY29tcG9uZW50cztcblxuICBjb25zdCBtYXhWZWN0b3IgPSAobmFtZTogc3RyaW5nLCBjb21wb25lbnRzOiBudW1iZXIpID0+IHtcbiAgICBpZiAoY29tcG9uZW50cyA9PT0gNCkge1xuICAgICAgcmV0dXJuIGBtYXgobWF4KCR7bmFtZX0ueCwgJHtuYW1lfS55KSwgbWF4KCR7bmFtZX0ueiwgJHtuYW1lfS53KSlgO1xuICAgIH0gZWxzZSBpZiAoY29tcG9uZW50cyA9PT0gMikge1xuICAgICAgcmV0dXJuIGBtYXgoJHtuYW1lfS54LCAke25hbWV9LnkpYDtcbiAgICB9IGVsc2UgaWYgKGNvbXBvbmVudHMgPT09IDMpIHtcbiAgICAgIHJldHVybiBgbWF4KG1heCgke25hbWV9LngsICR7bmFtZX0ueSksICR7bmFtZX0ueilgO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lO1xuICB9O1xuICBjb25zdCB4ID0gaW5wdXRWYXJpYWJsZSgneCcsIGlucHV0LmRhdGFUeXBlLCBpbnB1dC5kaW1zLCBjb21wb25lbnRzKTtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0VmFyaWFibGUoJ3Jlc3VsdCcsIGlucHV0LmRhdGFUeXBlLCBpbnB1dC5kaW1zLCBjb21wb25lbnRzKTtcbiAgY29uc3QgdmFsdWVUeXBlID0geC50eXBlLnZhbHVlO1xuICAvLyA2LjIuNCBpbiB3Z3NsIHNwZWNcbiAgY29uc3QgdGhyZWFkTWF4RGVjbCA9XG4gICAgdGVuc29yVHlwZVRvV3NnbFN0b3JhZ2VUeXBlKGlucHV0LmRhdGFUeXBlKSA9PT0gJ2YzMidcbiAgICAgID8gYHZhciB0aHJlYWRNYXggPSAke3ZhbHVlVHlwZX0oLTMuNDAyODIzZSszOGYpO2BcbiAgICAgIDogYHZhciB0aHJlYWRNYXggPSAke3ZhbHVlVHlwZX0oLTY1NTA0LjBoKTtgO1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHJvd01heFNoYXJlZCA6ICR7dmFsdWVUeXBlfTtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHJvd1N1bVNoYXJlZCA6ICR7dmFsdWVUeXBlfTtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHRocmVhZFNoYXJlZCA6IGFycmF5PCR7dmFsdWVUeXBlfSwgJHtXR30+O1xuXG4gICAgICBmbiBnZXRWYWx1ZShyb3c6IGkzMiwgY29sOiBpMzIsIHJvd19zdHJpZGU6IGkzMikgLT4gJHt2YWx1ZVR5cGV9IHtcbiAgICAgICAgbGV0IGluZGV4ID0gcm93ICogcm93X3N0cmlkZSArIGNvbDtcbiAgICAgICAgcmV0dXJuIHhbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBmbiBzZXRWYWx1ZShyb3c6IGkzMiwgY29sOiBpMzIsIHJvd19zdHJpZGU6IGkzMiwgdmFsdWU6ICR7dmFsdWVUeXBlfSkge1xuICAgICAgICBsZXQgaW5kZXggPSByb3cgKiByb3dfc3RyaWRlICsgY29sO1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICAke3NoYWRlckhlbHBlci5yZWdpc3RlclVuaWZvcm0oJ3BhY2tlZENvbHMnLCAnaTMyJykuZGVjbGFyZVZhcmlhYmxlcyh4LCBvdXRwdXQpfVxuICAgICAgJHtzaGFkZXJIZWxwZXIubWFpblN0YXJ0KCl9XG4gICAgICAgIGxldCBnaW5kZXggPSBpMzIoZ2xvYmFsX2lkeCk7XG4gICAgICAgIGxldCBsaW5kZXggPSBpMzIobG9jYWxfaWR4KTtcbiAgICAgICAgY29uc3Qgd2cgPSAke1dHfTtcbiAgICAgICAgbGV0IHJvdyA9IGdpbmRleCAvIHdnO1xuICAgICAgICBsZXQgY29scyA9IHVuaWZvcm1zLnBhY2tlZENvbHM7XG4gICAgICAgIGxldCByb3dfc3RyaWRlIDogaTMyID0gdW5pZm9ybXMucGFja2VkQ29scztcblxuICAgICAgICAvLyBmaW5kIHRoZSByb3dzIG1heFxuICAgICAgICAke3RocmVhZE1heERlY2x9XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpO1xuICAgICAgICAgIHRocmVhZE1heCA9IG1heCh0aHJlYWRNYXgsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZGV4IDwgY29scykge1xuICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkTWF4O1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IG1pbihjb2xzLCB3Zyk7XG4gICAgICAgIGZvciAodmFyIGN1cnJTaXplID0gcmVkdWNlU2l6ZSA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IHJlZHVjZVNpemUgPj4gMSkge1xuICAgICAgICAgIHJlZHVjZVNpemUgPSBjdXJyU2l6ZSArIChyZWR1Y2VTaXplICYgMSk7XG4gICAgICAgICAgaWYgKGxpbmRleCA8IGN1cnJTaXplKSB7XG4gICAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IG1heCh0aHJlYWRTaGFyZWRbbGluZGV4XSwgdGhyZWFkU2hhcmVkW2xpbmRleCArIHJlZHVjZVNpemVdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5kZXggPT0gMCkge1xuICAgICAgICAgIHJvd01heFNoYXJlZCA9ICR7dmFsdWVUeXBlfSgke21heFZlY3RvcigndGhyZWFkU2hhcmVkWzBdJywgY29tcG9uZW50cyl9KTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgcm93cyBzdW1cbiAgICAgICAgdmFyIHRocmVhZFN1bSA9ICR7dmFsdWVUeXBlfSgwLjApO1xuICAgICAgICBmb3IgKHZhciBjb2wgPSBsaW5kZXg7IGNvbCA8IGNvbHM7IGNvbCArPSB3Zykge1xuICAgICAgICAgIGxldCBzdWJFeHAgPSBleHAoZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpIC0gcm93TWF4U2hhcmVkKTtcbiAgICAgICAgICB0aHJlYWRTdW0gKz0gc3ViRXhwO1xuICAgICAgICB9XG4gICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkU3VtO1xuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgZm9yICh2YXIgY3VyclNpemUgPSB3ZyA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IGN1cnJTaXplID4+IDEpIHtcbiAgICAgICAgICBpZiAobGluZGV4IDwgY3VyclNpemUpIHtcbiAgICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkU2hhcmVkW2xpbmRleF0gKyB0aHJlYWRTaGFyZWRbbGluZGV4ICsgY3VyclNpemVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmRleCA9PSAwKSB7XG4gICAgICAgICAgcm93U3VtU2hhcmVkID0gJHt2YWx1ZVR5cGV9KCR7c3VtVmVjdG9yKCd0aHJlYWRTaGFyZWRbMF0nLCBjb21wb25lbnRzKX0pO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWUgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgcm93XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gZXhwKGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKSAtIHJvd01heFNoYXJlZCkgLyByb3dTdW1TaGFyZWQ7XG4gICAgICAgICAgc2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfWA7XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ1NvZnRtYXgnLFxuICAgIHNoYWRlckNhY2hlOiB7IGhpbnQ6IGAke2NvbXBvbmVudHN9YCwgaW5wdXREZXBlbmRlbmNpZXM6IFsndHlwZSddIH0sXG4gICAgZ2V0UnVuRGF0YTogKCkgPT4gKHtcbiAgICAgIG91dHB1dHM6IFt7IGRpbXM6IHNoYXBlLCBkYXRhVHlwZTogaW5wdXQuZGF0YVR5cGUgfV0sXG4gICAgICBkaXNwYXRjaEdyb3VwOiB7IHg6IHJvd3MgfSxcbiAgICAgIHByb2dyYW1Vbmlmb3JtczogW3sgdHlwZTogRGF0YVR5cGUuaW50MzIsIGRhdGE6IHBhY2tlZENvbHMgfV0sXG4gICAgfSksXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHNvZnRtYXggPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZXM6IFNvZnRtYXhBdHRyaWJ1dGVzKTogdm9pZCA9PiB7XG4gIHZhbGlkYXRlSW5wdXRzKGNvbnRleHQuaW5wdXRzKTtcbiAgY29udGV4dC5jb21wdXRlKGNyZWF0ZVNvZnRtYXhQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0c1swXSwgYXR0cmlidXRlcykpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlU29mdG1heEF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBTb2Z0bWF4QXR0cmlidXRlcyA9PlxuICBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBheGlzOiBhdHRyaWJ1dGVzLmF4aXMgYXMgbnVtYmVyIH0pO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBEYXRhVHlwZSB9IGZyb20gJy4uLy4uLy4uL3dhc20tY29tbW9uJztcbmltcG9ydCB7IFRlbnNvclZpZXcgfSBmcm9tICcuLi8uLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7IEF0dHJpYnV0ZVdpdGhDYWNoZUtleSwgY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5IH0gZnJvbSAnLi4vYXR0cmlidXRlLXdpdGgtY2FjaGUta2V5JztcbmltcG9ydCB7IENvbXB1dGVDb250ZXh0LCBQcm9ncmFtSW5mbywgUHJvZ3JhbVVuaWZvcm0sIFRlbnNvckluZm8gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7XG4gIGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLFxuICBnZXRFbGVtZW50QXQsXG4gIEluZGljZXNIZWxwZXIsXG4gIGlucHV0VmFyaWFibGUsXG4gIG91dHB1dFZhcmlhYmxlLFxuICBTaGFkZXJIZWxwZXIsXG59IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBTcGxpdEF0dHJpYnV0ZXMgZXh0ZW5kcyBBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkge1xuICByZWFkb25seSBheGlzOiBudW1iZXI7XG4gIHJlYWRvbmx5IG51bU91dHB1dHM6IG51bWJlcjtcbiAgcmVhZG9ubHkgc3BsaXRTaXplczogbnVtYmVyW107XG59XG5cbmNvbnN0IHZhbGlkYXRlSW5wdXRzID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdKTogdm9pZCA9PiB7XG4gIGlmICghaW5wdXRzIHx8IGlucHV0cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0b28gZmV3IGlucHV0cycpO1xuICB9XG59O1xuXG5jb25zdCBjcmVhdGVTcGxpdEF0dHJpYnV0ZXNGcm9tSW5wdXRzID0gKFxuICBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgYXR0cmlidXRlczogU3BsaXRBdHRyaWJ1dGVzLFxuKTogU3BsaXRBdHRyaWJ1dGVzID0+IHtcbiAgY29uc3Qgc3BsaXRTaXplczogbnVtYmVyW10gPSBbXTtcbiAgbGV0IG51bU91dHB1dHM6IG51bWJlciA9IGF0dHJpYnV0ZXMubnVtT3V0cHV0cztcbiAgaWYgKGlucHV0c1sxXS5kaW1zWzBdID4gMCkge1xuICAgIGlucHV0c1sxXS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaCgodikgPT4gc3BsaXRTaXplcy5wdXNoKE51bWJlcih2KSkpO1xuICAgIG51bU91dHB1dHMgPSBzcGxpdFNpemVzLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQXR0cmlidXRlV2l0aENhY2hlS2V5KHsgbnVtT3V0cHV0cywgYXhpczogYXR0cmlidXRlcy5heGlzLCBzcGxpdFNpemVzIH0pO1xufTtcblxuY29uc3QgY2FsY3VsYXRlT3V0cHV0SW5kZXhJbXBsID0gKG51bWJlck9mVGVuc29yczogbnVtYmVyKTogc3RyaW5nID0+IGBcbmZuIGNhbGN1bGF0ZU91dHB1dEluZGV4KGluZGV4OiB1MzIpIC0+IHUzMiB7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke251bWJlck9mVGVuc29yc311OyBpICs9IDF1ICkge1xuICAgIGlmIChpbmRleCA8ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5zaXplX2luX3NwbGl0X2F4aXMnLCAnaScsIG51bWJlck9mVGVuc29ycyl9KSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICR7bnVtYmVyT2ZUZW5zb3JzfXU7XG59YDtcbmNvbnN0IHdyaXRlQnVmZmVyRGF0YUltcGwgPSAob3V0cHV0czogcmVhZG9ubHkgSW5kaWNlc0hlbHBlcltdKSA9PiB7XG4gIGNvbnN0IG51bWJlck9mVGVuc29ycyA9IG91dHB1dHMubGVuZ3RoO1xuICBjb25zdCBjb2RlTGluZXM6IHN0cmluZ1tdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZUZW5zb3JzOyArK2kpIHtcbiAgICBjb25zdCByZXR1cm5TbmlwcGV0ID0gb3V0cHV0c1tpXS5zZXRCeUluZGljZXMoJ2luZGljZXMnLCAnaW5wdXRbZ2xvYmFsX2lkeF0nKTtcbiAgICBpZiAobnVtYmVyT2ZUZW5zb3JzID09PSAxKSB7XG4gICAgICBjb2RlTGluZXMucHVzaChyZXR1cm5TbmlwcGV0KTtcbiAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgIGNvZGVMaW5lcy5wdXNoKGBpZiAob3V0cHV0X251bWJlciA9PSAke2l9dSkgeyAke3JldHVyblNuaXBwZXR9IH1gKTtcbiAgICB9IGVsc2UgaWYgKGkgPT09IG51bWJlck9mVGVuc29ycyAtIDEpIHtcbiAgICAgIGNvZGVMaW5lcy5wdXNoKGBlbHNlIHsgJHtyZXR1cm5TbmlwcGV0fSB9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGVMaW5lcy5wdXNoKGBlbHNlIGlmIChvdXRwdXRfbnVtYmVyID09ICR7aX0pIHsgJHtyZXR1cm5TbmlwcGV0fSB9YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBgXG4gICAgICBmbiB3cml0ZUJ1ZmZlckRhdGEob3V0cHV0X251bWJlcjogdTMyLCBpbmRpY2VzOiAke291dHB1dHNbMF0udHlwZS5pbmRpY2VzfSwgZ2xvYmFsX2lkeDogdTMyKSB7XG4gICAgICAgICR7Y29kZUxpbmVzLmpvaW4oJ1xcbicpfVxuICAgICAgfWA7XG59O1xuXG5jb25zdCBjcmVhdGVTcGxpdFByb2dyYW1JbmZvID0gKGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLCBhdHRyaWJ1dGVzOiBTcGxpdEF0dHJpYnV0ZXMpOiBQcm9ncmFtSW5mbyA9PiB7XG4gIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3QgaW5wdXRTaXplID0gU2hhcGVVdGlsLnNpemUoaW5wdXRTaGFwZSk7XG4gIGNvbnN0IGRhdGFUeXBlID0gaW5wdXRzWzBdLmRhdGFUeXBlO1xuICBjb25zdCBheGlzID0gU2hhcGVVdGlsLm5vcm1hbGl6ZUF4aXMoYXR0cmlidXRlcy5heGlzLCBpbnB1dFNoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IG91dHB1dHMgPSBuZXcgQXJyYXk8SW5kaWNlc0hlbHBlcj4oYXR0cmlidXRlcy5udW1PdXRwdXRzKTtcbiAgY29uc3QgaW5wdXQgPSBpbnB1dFZhcmlhYmxlKCdpbnB1dCcsIGRhdGFUeXBlLCBpbnB1dFNoYXBlLmxlbmd0aCk7XG4gIGNvbnN0IHNpemVJblNwbGl0QXhpcyA9IG5ldyBBcnJheTxudW1iZXI+KGF0dHJpYnV0ZXMubnVtT3V0cHV0cyk7XG4gIGNvbnN0IG91dHB1dHNUZW5zb3JJbmZvOiBUZW5zb3JJbmZvW10gPSBbXTtcbiAgY29uc3Qgb3V0cHV0U2hhcGVzOiBudW1iZXJbXVtdID0gW107XG4gIGxldCBwcmV2aW91c1N1bSA9IDA7XG4gIGNvbnN0IHByb2dyYW1Vbmlmb3JtczogUHJvZ3JhbVVuaWZvcm1bXSA9IFt7IHR5cGU6IERhdGFUeXBlLnVpbnQzMiwgZGF0YTogaW5wdXRTaXplIH1dO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubnVtT3V0cHV0czsgaSsrKSB7XG4gICAgcHJldmlvdXNTdW0gKz0gYXR0cmlidXRlcy5zcGxpdFNpemVzW2ldO1xuICAgIHNpemVJblNwbGl0QXhpc1tpXSA9IHByZXZpb3VzU3VtO1xuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgpO1xuICAgIG91dHB1dFNoYXBlW2F4aXNdID0gYXR0cmlidXRlcy5zcGxpdFNpemVzW2ldO1xuICAgIG91dHB1dFNoYXBlcy5wdXNoKG91dHB1dFNoYXBlKTtcbiAgICBvdXRwdXRzW2ldID0gb3V0cHV0VmFyaWFibGUoYG91dHB1dCR7aX1gLCBkYXRhVHlwZSwgb3V0cHV0U2hhcGUubGVuZ3RoKTtcbiAgICBvdXRwdXRzVGVuc29ySW5mby5wdXNoKHsgZGltczogb3V0cHV0U2hhcGVzW2ldLCBkYXRhVHlwZTogaW5wdXRzWzBdLmRhdGFUeXBlIH0pO1xuICB9XG4gIHByb2dyYW1Vbmlmb3Jtcy5wdXNoKFxuICAgIHsgdHlwZTogRGF0YVR5cGUudWludDMyLCBkYXRhOiBzaXplSW5TcGxpdEF4aXMgfSxcbiAgICAuLi5jcmVhdGVUZW5zb3JTaGFwZVZhcmlhYmxlcyhpbnB1dFNoYXBlLCAuLi5vdXRwdXRTaGFwZXMpLFxuICApO1xuICBjb25zdCBnZXRTaGFkZXJTb3VyY2UgPSAoc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIpID0+IGBcbiAgJHtzaGFkZXJIZWxwZXJcbiAgICAucmVnaXN0ZXJVbmlmb3JtKCdpbnB1dF9zaXplJywgJ3UzMicpXG4gICAgLnJlZ2lzdGVyVW5pZm9ybSgnc2l6ZV9pbl9zcGxpdF9heGlzJywgJ3UzMicsIHNpemVJblNwbGl0QXhpcy5sZW5ndGgpXG4gICAgLmRlY2xhcmVWYXJpYWJsZXMoaW5wdXQsIC4uLm91dHB1dHMpfVxuICAke2NhbGN1bGF0ZU91dHB1dEluZGV4SW1wbChzaXplSW5TcGxpdEF4aXMubGVuZ3RoKX1cbiAgJHt3cml0ZUJ1ZmZlckRhdGFJbXBsKG91dHB1dHMpfVxuXG4gICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICR7c2hhZGVySGVscGVyLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoJ3VuaWZvcm1zLmlucHV0X3NpemUnKX1cblxuICAgIHZhciBpbmRpY2VzID0gJHtpbnB1dC5vZmZzZXRUb0luZGljZXMoJ2dsb2JhbF9pZHgnKX07XG4gICAgdmFyIGluZGV4ID0gJHtpbnB1dC5pbmRpY2VzR2V0KCdpbmRpY2VzJywgYXhpcyl9O1xuICAgIGxldCBvdXRwdXRfbnVtYmVyID0gY2FsY3VsYXRlT3V0cHV0SW5kZXgoaW5kZXgpO1xuICAgIGlmIChvdXRwdXRfbnVtYmVyICE9IDApIHtcbiAgICAgIGluZGV4IC09ICR7Z2V0RWxlbWVudEF0KCd1bmlmb3Jtcy5zaXplX2luX3NwbGl0X2F4aXMnLCAnb3V0cHV0X251bWJlciAtIDF1Jywgc2l6ZUluU3BsaXRBeGlzLmxlbmd0aCl9O1xuICAgICAgJHtpbnB1dC5pbmRpY2VzU2V0KCdpbmRpY2VzJywgYXhpcywgJ2luZGV4Jyl9O1xuICAgIH1cbiAgICB3cml0ZUJ1ZmZlckRhdGEob3V0cHV0X251bWJlciwgaW5kaWNlcywgZ2xvYmFsX2lkeCk7XG4gIH1gO1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdTcGxpdCcsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaGludDogYXR0cmlidXRlcy5jYWNoZUtleSwgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuayddIH0sXG4gICAgZ2V0U2hhZGVyU291cmNlLFxuICAgIGdldFJ1bkRhdGE6ICgpID0+ICh7XG4gICAgICBvdXRwdXRzOiBvdXRwdXRzVGVuc29ySW5mbyxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKGlucHV0U2l6ZSAvIDY0IC8qIHdvcmtncm91cCBzaXplICovKSB9LFxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLFxuICAgIH0pLFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IHNwbGl0ID0gKGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBhdHRyaWJ1dGVzOiBTcGxpdEF0dHJpYnV0ZXMpOiB2b2lkID0+IHtcbiAgdmFsaWRhdGVJbnB1dHMoY29udGV4dC5pbnB1dHMpO1xuICBjb25zdCB1cGRhdGVkQXR0cmlidXRlcyA9XG4gICAgY29udGV4dC5pbnB1dHMubGVuZ3RoID09PSAxID8gYXR0cmlidXRlcyA6IGNyZWF0ZVNwbGl0QXR0cmlidXRlc0Zyb21JbnB1dHMoY29udGV4dC5pbnB1dHMsIGF0dHJpYnV0ZXMpO1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlU3BsaXRQcm9ncmFtSW5mbyhjb250ZXh0LmlucHV0cywgdXBkYXRlZEF0dHJpYnV0ZXMpLCB7IGlucHV0czogWzBdIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlU3BsaXRBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogU3BsaXRBdHRyaWJ1dGVzID0+IHtcbiAgY29uc3QgYXhpcyA9IGF0dHJpYnV0ZXMuYXhpcyBhcyBudW1iZXI7XG4gIGNvbnN0IHNwbGl0U2l6ZXM6IG51bWJlcltdID0gYXR0cmlidXRlcy5zcGxpdFNpemVzIGFzIG51bWJlcltdO1xuICBjb25zdCBudW1PdXRwdXRzID0gKGF0dHJpYnV0ZXMubnVtT3V0cHV0cyBhcyBudW1iZXIpIDwgMCA/IHNwbGl0U2l6ZXMubGVuZ3RoIDogKGF0dHJpYnV0ZXMubnVtT3V0cHV0cyBhcyBudW1iZXIpO1xuICBpZiAobnVtT3V0cHV0cyAhPT0gc3BsaXRTaXplcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ251bU91dHB1dHMgYW5kIHNwbGl0U2l6ZXMgbGVuZ2ggbXVzdCBiZSBlcXVhbCcpO1xuICB9XG4gIHJldHVybiBjcmVhdGVBdHRyaWJ1dGVXaXRoQ2FjaGVLZXkoeyBheGlzLCBudW1PdXRwdXRzLCBzcGxpdFNpemVzIH0pO1xufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgRGF0YVR5cGUgfSBmcm9tICcuLi8uLi8uLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi4vLi4vdGVuc29yLXZpZXcnO1xuaW1wb3J0IHsgQnJvYWRjYXN0VXRpbCwgU2hhcGVVdGlsIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBDb21wdXRlQ29udGV4dCwgUHJvZ3JhbUluZm8gfSBmcm9tICcuLi90eXBlcyc7XG5cbmltcG9ydCB7IGNyZWF0ZVRlbnNvclNoYXBlVmFyaWFibGVzLCBpbnB1dFZhcmlhYmxlLCBvdXRwdXRWYXJpYWJsZSwgU2hhZGVySGVscGVyIH0gZnJvbSAnLi9jb21tb24nO1xuXG5jb25zdCBjcmVhdGVXaGVyZU9wUHJvZ3JhbVNoYWRlciA9IChcbiAgc2hhZGVySGVscGVyOiBTaGFkZXJIZWxwZXIsXG4gIGlucHV0czogcmVhZG9ubHkgVGVuc29yVmlld1tdLFxuICBkaW1zT3V0cHV0OiByZWFkb25seSBudW1iZXJbXSxcbiAgaXNCcm9hZGNhc3Q6IGJvb2xlYW4sXG4gIHR5cGVPdXRwdXQ6IG51bWJlcixcbikgPT4ge1xuICBjb25zdCBvdXRwdXQgPSBvdXRwdXRWYXJpYWJsZSgnb3V0cHV0X2RhdGEnLCB0eXBlT3V0cHV0LCBkaW1zT3V0cHV0Lmxlbmd0aCwgNCk7XG4gIGNvbnN0IGEgPSBpbnB1dFZhcmlhYmxlKCdhX2RhdGEnLCBpbnB1dHNbMV0uZGF0YVR5cGUsIGlucHV0c1sxXS5kaW1zLmxlbmd0aCwgNCk7XG4gIGNvbnN0IGIgPSBpbnB1dFZhcmlhYmxlKCdiX2RhdGEnLCBpbnB1dHNbMl0uZGF0YVR5cGUsIGlucHV0c1syXS5kaW1zLmxlbmd0aCwgNCk7XG4gIGNvbnN0IGMgPSBpbnB1dFZhcmlhYmxlKCdjX2RhdGEnLCBpbnB1dHNbMF0uZGF0YVR5cGUsIGlucHV0c1swXS5kaW1zLmxlbmd0aCwgNCk7XG5cbiAgbGV0IGFzc2lnbm1lbnQ6IHN0cmluZztcbiAgY29uc3QgZXhwcmVzc2lvbiA9IChhOiBzdHJpbmcsIGI6IHN0cmluZywgYzogc3RyaW5nKSA9PiBgc2VsZWN0KCR7Yn0sICR7YX0sICR7Y30pYDtcbiAgaWYgKCFpc0Jyb2FkY2FzdCkge1xuICAgIGFzc2lnbm1lbnQgPSBvdXRwdXQuc2V0QnlPZmZzZXQoXG4gICAgICAnZ2xvYmFsX2lkeCcsXG4gICAgICBleHByZXNzaW9uKGEuZ2V0QnlPZmZzZXQoJ2dsb2JhbF9pZHgnKSwgYi5nZXRCeU9mZnNldCgnZ2xvYmFsX2lkeCcpLCBjLmdldEJ5T2Zmc2V0KCdnbG9iYWxfaWR4JykpLFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc2luZ2xlQXNzaWdubWVudCA9IChyZXNTdHI6IHN0cmluZywgeDogbnVtYmVyLCB0eXBlQ2FzdCA9ICcnKSA9PiB7XG4gICAgICBjb25zdCBleHByZXNzaW9uQSA9IGBhX2RhdGFbaW5kZXhfYSR7eH1dW2NvbXBvbmVudF9hJHt4fV1gO1xuICAgICAgY29uc3QgZXhwcmVzc2lvbkIgPSBgYl9kYXRhW2luZGV4X2Ike3h9XVtjb21wb25lbnRfYiR7eH1dYDtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICBjb25zdCBleHByZXNzaW9uQyA9IGBib29sKGNfZGF0YVtpbmRleF9jJHt4fV0gJiAoMHhmZnUgPDwgKGNvbXBvbmVudF9jJHt4fSAqIDgpKSlgO1xuICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyR7eH0gPSAke291dHB1dC5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiA0dSArICR7eH11YCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldF9hJHt4fSA9ICR7YS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0X2luZGljZXMke3h9YCwgb3V0cHV0KX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0X2Ike3h9ID0gJHtiLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRfaW5kaWNlcyR7eH1gLCBvdXRwdXQpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRfYyR7eH0gPSAke2MuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dF9pbmRpY2VzJHt4fWAsIG91dHB1dCl9O1xuICAgICAgICAgICAgbGV0IGluZGV4X2Eke3h9ID0gb2Zmc2V0X2Eke3h9IC8gNHU7XG4gICAgICAgICAgICBsZXQgaW5kZXhfYiR7eH0gPSBvZmZzZXRfYiR7eH0gLyA0dTtcbiAgICAgICAgICAgIGxldCBpbmRleF9jJHt4fSA9IG9mZnNldF9jJHt4fSAvIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudF9hJHt4fSA9IG9mZnNldF9hJHt4fSAlIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudF9iJHt4fSA9IG9mZnNldF9iJHt4fSAlIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudF9jJHt4fSA9IG9mZnNldF9jJHt4fSAlIDR1O1xuICAgICAgICAgICAgJHtyZXNTdHJ9WyR7eH1dID0gJHt0eXBlQ2FzdH0oJHtleHByZXNzaW9uKGV4cHJlc3Npb25BLCBleHByZXNzaW9uQiwgZXhwcmVzc2lvbkMpfSk7XG4gICAgICAgICAgYDtcbiAgICB9O1xuICAgIGlmICh0eXBlT3V0cHV0ID09PSBEYXRhVHlwZS5ib29sKSB7XG4gICAgICBhc3NpZ25tZW50ID0gYFxuICAgICAgICAgICAgdmFyIGRhdGEgPSB2ZWM0PHUzMj4oMCk7XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAwLCAndTMyJyl9XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAxLCAndTMyJyl9XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAyLCAndTMyJyl9XG4gICAgICAgICAgICAke3NpbmdsZUFzc2lnbm1lbnQoJ2RhdGEnLCAzLCAndTMyJyl9XG4gICAgICAgICAgICBvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25tZW50ID0gYFxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XScsIDApfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XScsIDEpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XScsIDIpfVxuICAgICAgICAgICAgJHtzaW5nbGVBc3NpZ25tZW50KCdvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XScsIDMpfVxuICAgICAgICAgIGA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGBcbiAgICAgICAgJHtzaGFkZXJIZWxwZXIucmVnaXN0ZXJVbmlmb3JtKCd2ZWNfc2l6ZScsICd1MzInKS5kZWNsYXJlVmFyaWFibGVzKGMsIGEsIGIsIG91dHB1dCl9XG4gICAgICAgICR7c2hhZGVySGVscGVyLm1haW5TdGFydCgpfVxuICAgICAgICAke3NoYWRlckhlbHBlci5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKCd1bmlmb3Jtcy52ZWNfc2l6ZScpfVxuICAgICAgICAke2Fzc2lnbm1lbnR9XG4gICAgICB9YDtcbn07XG5cbmNvbnN0IGNyZWF0ZVdoZXJlT3BQcm9ncmFtSW5mbyA9IChpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSk6IFByb2dyYW1JbmZvID0+IHtcbiAgY29uc3QgZGltc0EgPSBpbnB1dHNbMV0uZGltcztcbiAgY29uc3QgZGltc0IgPSBpbnB1dHNbMl0uZGltcztcbiAgY29uc3QgZGltc0MgPSBpbnB1dHNbMF0uZGltcztcbiAgY29uc3Qgb3V0cHV0RGF0YVR5cGUgPSBpbnB1dHNbMV0uZGF0YVR5cGU7XG5cbiAgY29uc3QgaXNCcm9hZGNhc3QgPSAhKFNoYXBlVXRpbC5hcmVFcXVhbChkaW1zQSwgZGltc0IpICYmIFNoYXBlVXRpbC5hcmVFcXVhbChkaW1zQiwgZGltc0MpKTtcbiAgbGV0IG91dHB1dFNoYXBlID0gZGltc0E7XG4gIGxldCBvdXRwdXRTaXplID0gU2hhcGVVdGlsLnNpemUoZGltc0EpO1xuICAvLyBUT0RPOiBkZWFsIHdpdGggemVyby1zaXplZCB0ZW5zb3JzIChlZy4gZGltcz1bMSwwXSlcblxuICBpZiAoaXNCcm9hZGNhc3QpIHtcbiAgICBjb25zdCBjYWxjdWxhdGVkU2hhcGUgPSBCcm9hZGNhc3RVdGlsLmNhbGNTaGFwZShCcm9hZGNhc3RVdGlsLmNhbGNTaGFwZShkaW1zQSwgZGltc0IsIGZhbHNlKSEsIGRpbXNDLCBmYWxzZSk7XG4gICAgaWYgKCFjYWxjdWxhdGVkU2hhcGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHBlcmZvcm0gd2hlcmUgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7XG4gICAgfVxuICAgIG91dHB1dFNoYXBlID0gY2FsY3VsYXRlZFNoYXBlO1xuICAgIG91dHB1dFNpemUgPSBTaGFwZVV0aWwuc2l6ZShvdXRwdXRTaGFwZSk7XG4gIH1cblxuICBjb25zdCB2ZWNTaXplID0gTWF0aC5jZWlsKG91dHB1dFNpemUgLyA0KTtcblxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdXaGVyZScsXG4gICAgc2hhZGVyQ2FjaGU6IHsgaW5wdXREZXBlbmRlbmNpZXM6IFsncmFuaycsICdyYW5rJywgJ3JhbmsnXSB9LFxuICAgIGdldFNoYWRlclNvdXJjZTogKHNoYWRlckhlbHBlcikgPT5cbiAgICAgIGNyZWF0ZVdoZXJlT3BQcm9ncmFtU2hhZGVyKHNoYWRlckhlbHBlciwgaW5wdXRzLCBvdXRwdXRTaGFwZSwgaXNCcm9hZGNhc3QsIG91dHB1dERhdGFUeXBlKSxcbiAgICBnZXRSdW5EYXRhOiAoKSA9PiAoe1xuICAgICAgb3V0cHV0czogW3sgZGltczogb3V0cHV0U2hhcGUsIGRhdGFUeXBlOiBvdXRwdXREYXRhVHlwZSB9XSxcbiAgICAgIGRpc3BhdGNoR3JvdXA6IHsgeDogTWF0aC5jZWlsKG91dHB1dFNpemUgLyA2NCAvKiB3b3JrZ3JvdXAgc2l6ZSAqLyAvIDQgLyogdmVjIHNpemUgKi8pIH0sXG4gICAgICBwcm9ncmFtVW5pZm9ybXM6IFtcbiAgICAgICAgeyB0eXBlOiBEYXRhVHlwZS51aW50MzIsIGRhdGE6IHZlY1NpemUgfSxcbiAgICAgICAgLi4uY3JlYXRlVGVuc29yU2hhcGVWYXJpYWJsZXMoZGltc0MsIGRpbXNBLCBkaW1zQiwgb3V0cHV0U2hhcGUpLFxuICAgICAgXSxcbiAgICB9KSxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCB3aGVyZSA9IChjb250ZXh0OiBDb21wdXRlQ29udGV4dCk6IHZvaWQgPT4ge1xuICBjb250ZXh0LmNvbXB1dGUoY3JlYXRlV2hlcmVPcFByb2dyYW1JbmZvKGNvbnRleHQuaW5wdXRzKSk7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBhcmdNYXgsIGFyZ01pbiwgcGFyc2VBcmdNaW5NYXhBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvYXJnbWlubWF4JztcbmltcG9ydCB7IGF0dGVudGlvbiB9IGZyb20gJy4vb3BzL2F0dGVudGlvbic7XG5pbXBvcnQgeyBiYXRjaE5vcm0gfSBmcm9tICcuL29wcy9iYXRjaC1ub3JtJztcbmltcG9ydCB7IGJpYXNBZGQgfSBmcm9tICcuL29wcy9iaWFzLWFkZCc7XG5pbXBvcnQgeyBiaWFzU3BsaXRHZWx1IH0gZnJvbSAnLi9vcHMvYmlhcy1zcGxpdC1nZWx1JztcbmltcG9ydCAqIGFzIGJpbmFyeU9wcyBmcm9tICcuL29wcy9iaW5hcnktb3AnO1xuaW1wb3J0IHsgY29uY2F0LCBwYXJzZUNvbmNhdEF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9jb25jYXQnO1xuaW1wb3J0IHsgY29udiwgcGFyc2VDb252QXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2NvbnYnO1xuaW1wb3J0IHsgY29udlRyYW5zcG9zZSwgcGFyc2VDb252VHJhbnNwb3NlQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2NvbnYtdHJhbnNwb3NlJztcbmltcG9ydCB7IGN1bXN1bSwgcGFyc2VDdW1TdW1BdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvY3Vtc3VtJztcbmltcG9ydCB7IGRlcHRoVG9TcGFjZSwgcGFyc2VEZXB0aFRvU3BhY2VBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvZGVwdGgtdG8tc3BhY2UnO1xuaW1wb3J0IHsgZWluc3VtLCBwYXJzZUVpbnN1bUF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9laW5zdW0nO1xuaW1wb3J0IHsgZXhwYW5kIH0gZnJvbSAnLi9vcHMvZXhwYW5kJztcbmltcG9ydCB7IGZhc3RHZWx1IH0gZnJvbSAnLi9vcHMvZmFzdC1nZWx1JztcbmltcG9ydCB7IGdhdGhlciwgcGFyc2VHYXRoZXJBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvZ2F0aGVyJztcbmltcG9ydCB7IGdhdGhlckJsb2NrUXVhbnRpemVkLCBwYXJzZUdhdGhlckJsb2NrUXVhbnRpemVkQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL2dhdGhlci1ibG9jay1xdWFudGl6ZWQnO1xuaW1wb3J0IHsgZ2F0aGVyRWxlbWVudHMsIHBhcnNlR2F0aGVyRWxlbWVudHNBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvZ2F0aGVyLWVsZW1lbnRzJztcbmltcG9ydCB7IGdlbW0sIHBhcnNlR2VtbUF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9nZW1tJztcbmltcG9ydCB7IGdyb3VwUXVlcnlBdHRlbnRpb24sIHBhcnNlR3JvdXBRdWVyeUF0dGVudGlvbkF0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9ncm91cC1xdWVyeS1hdHRlbnRpb24nO1xuaW1wb3J0IHsgaW5zdGFuY2VOb3JtIH0gZnJvbSAnLi9vcHMvaW5zdGFuY2Utbm9ybSc7XG5pbXBvcnQgeyBsYXllck5vcm0gfSBmcm9tICcuL29wcy9sYXllci1ub3JtJztcbmltcG9ydCB7IG1hdE11bCB9IGZyb20gJy4vb3BzL21hdG11bCc7XG5pbXBvcnQgeyBtYXRNdWxOQml0cywgcGFyc2VNYXRNdWxOQml0c0F0dHJpYnV0ZXMgfSBmcm9tICcuL29wcy9tYXRtdWxuYml0cyc7XG5pbXBvcnQgeyBtdWx0aUhlYWRBdHRlbnRpb24sIHBhcnNlTXVsdGlIZWFkQXR0ZW50aW9uQXR0cmlidXRlcyB9IGZyb20gJy4vb3BzL211bHRpaGVhZC1hdHRlbnRpb24nO1xuaW1wb3J0IHsgcGFkIH0gZnJvbSAnLi9vcHMvcGFkJztcbmltcG9ydCAqIGFzIHBvb2wgZnJvbSAnLi9vcHMvcG9vbCc7XG5pbXBvcnQgeyBkZXF1YW50aXplTGluZWFyLCBwYXJzZURlcXVhbnRpemVMaW5lYXJBdHRyaWJ1dGVzIH0gZnJvbSAnLi9vcHMvcXVhbnRpemUtbGluZWFyJztcbmltcG9ydCB7IHJhbmdlIH0gZnJvbSAnLi9vcHMvcmFuZ2UnO1xuaW1wb3J0IHtcbiAgcmVkdWNlTDEsXG4gIHJlZHVjZUwyLFxuICByZWR1Y2VMb2dTdW0sXG4gIHJlZHVjZUxvZ1N1bUV4cCxcbiAgcmVkdWNlTWF4LFxuICByZWR1Y2VNZWFuLFxuICByZWR1Y2VNaW4sXG4gIHJlZHVjZVByb2QsXG4gIHJlZHVjZVN1bSxcbiAgcmVkdWNlU3VtU3F1YXJlLFxufSBmcm9tICcuL29wcy9yZWR1Y2UnO1xuaW1wb3J0IHsgcGFyc2VSZXNpemVBdHRyaWJ1dGVzLCByZXNpemUgfSBmcm9tICcuL29wcy9yZXNpemUnO1xuaW1wb3J0IHsgcm90YXJ5RW1iZWRkaW5nIH0gZnJvbSAnLi9vcHMvcm90YXJ5LWVtYmVkZGluZyc7XG5pbXBvcnQgeyBza2lwTGF5ZXJOb3JtIH0gZnJvbSAnLi9vcHMvc2tpcC1sYXllci1ub3JtJztcbmltcG9ydCB7IHBhcnNlU2xpY2VBdHRyaWJ1dGVzLCBzbGljZSB9IGZyb20gJy4vb3BzL3NsaWNlJztcbmltcG9ydCB7IHBhcnNlU29mdG1heEF0dHJpYnV0ZXMsIHNvZnRtYXggfSBmcm9tICcuL29wcy9zb2Z0bWF4JztcbmltcG9ydCB7IHBhcnNlU3BsaXRBdHRyaWJ1dGVzLCBzcGxpdCB9IGZyb20gJy4vb3BzL3NwbGl0JztcbmltcG9ydCB7IHRpbGUgfSBmcm9tICcuL29wcy90aWxlJztcbmltcG9ydCB7IHBhcnNlVHJhbnNwb3NlQXR0cmlidXRlcywgdHJhbnNwb3NlIH0gZnJvbSAnLi9vcHMvdHJhbnNwb3NlJztcbmltcG9ydCAqIGFzIHVuYXJ5T3BzIGZyb20gJy4vb3BzL3VuYXJ5LW9wJztcbmltcG9ydCB7IHdoZXJlIH0gZnJvbSAnLi9vcHMvd2hlcmUnO1xuaW1wb3J0IHsgQ29tcHV0ZUNvbnRleHQgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IHR5cGUgUnVuRnVuY3Rpb24gPSAoY29udGV4dDogQ29tcHV0ZUNvbnRleHQsIGF0dHJpYnV0ZT86IHVua25vd24pID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBQYXJzZUF0dHJpYnV0ZUZ1bmN0aW9uID0gKGF0dHJpYnV0ZVJhdzogdW5rbm93bikgPT4gdW5rbm93bjtcbmV4cG9ydCB0eXBlIE9wZXJhdG9ySW1wbGVtZW50YXRpb24gPSBbUnVuRnVuY3Rpb25dIHwgW1J1bkZ1bmN0aW9uLCBQYXJzZUF0dHJpYnV0ZUZ1bmN0aW9uXTtcblxuZXhwb3J0IGNvbnN0IFdFQkdQVV9PUF9SRVNPTFZFX1JVTEVTOiBNYXA8c3RyaW5nLCBPcGVyYXRvckltcGxlbWVudGF0aW9uPiA9IG5ldyBNYXAoW1xuICBbJ0FicycsIFt1bmFyeU9wcy5hYnNdXSxcbiAgWydBY29zJywgW3VuYXJ5T3BzLmFjb3NdXSxcbiAgWydBY29zaCcsIFt1bmFyeU9wcy5hY29zaF1dLFxuICBbJ0FkZCcsIFtiaW5hcnlPcHMuYWRkXV0sXG4gIFsnQXJnTWF4JywgW2FyZ01heCwgcGFyc2VBcmdNaW5NYXhBdHRyaWJ1dGVzXV0sXG4gIFsnQXJnTWluJywgW2FyZ01pbiwgcGFyc2VBcmdNaW5NYXhBdHRyaWJ1dGVzXV0sXG4gIFsnQXNpbicsIFt1bmFyeU9wcy5hc2luXV0sXG4gIFsnQXNpbmgnLCBbdW5hcnlPcHMuYXNpbmhdXSxcbiAgWydBdGFuJywgW3VuYXJ5T3BzLmF0YW5dXSxcbiAgWydBdGFuaCcsIFt1bmFyeU9wcy5hdGFuaF1dLFxuICBbJ0F0dGVudGlvbicsIFthdHRlbnRpb25dXSxcbiAgLy8gVE9ETzogc3VwcG9ydCBuZXcgYXR0cmlidXRlcyBmb3IgQXZlcmFnZVBvb2wtMTBcbiAgWydBdmVyYWdlUG9vbCcsIFtwb29sLmF2ZXJhZ2VQb29sLCBwb29sLnBhcnNlQXZlcmFnZVBvb2xBdHRyaWJ1dGVzXV0sXG4gIFsnQmF0Y2hOb3JtYWxpemF0aW9uJywgW2JhdGNoTm9ybV1dLFxuICBbJ0JpYXNBZGQnLCBbYmlhc0FkZF1dLFxuICBbJ0JpYXNTcGxpdEdlbHUnLCBbYmlhc1NwbGl0R2VsdV1dLFxuICBbJ0Nhc3QnLCBbdW5hcnlPcHMuY2FzdCwgdW5hcnlPcHMucGFyc2VDYXN0QXR0cmlidXRlc11dLFxuICBbJ0NlaWwnLCBbdW5hcnlPcHMuY2VpbF1dLFxuICBbJ0NsaXAnLCBbdW5hcnlPcHMuY2xpcF1dLFxuICBbJ0NvbmNhdCcsIFtjb25jYXQsIHBhcnNlQ29uY2F0QXR0cmlidXRlc11dLFxuICBbJ0NvbnYnLCBbY29udiwgcGFyc2VDb252QXR0cmlidXRlc11dLFxuICBbJ0NvbnZUcmFuc3Bvc2UnLCBbY29udlRyYW5zcG9zZSwgcGFyc2VDb252VHJhbnNwb3NlQXR0cmlidXRlc11dLFxuICBbJ0NvcycsIFt1bmFyeU9wcy5jb3NdXSxcbiAgWydDb3NoJywgW3VuYXJ5T3BzLmNvc2hdXSxcbiAgWydDdW1TdW0nLCBbY3Vtc3VtLCBwYXJzZUN1bVN1bUF0dHJpYnV0ZXNdXSxcbiAgWydEZXB0aFRvU3BhY2UnLCBbZGVwdGhUb1NwYWNlLCBwYXJzZURlcHRoVG9TcGFjZUF0dHJpYnV0ZXNdXSxcbiAgWydEZXF1YW50aXplTGluZWFyJywgW2RlcXVhbnRpemVMaW5lYXIsIHBhcnNlRGVxdWFudGl6ZUxpbmVhckF0dHJpYnV0ZXNdXSxcbiAgWydEaXYnLCBbYmluYXJ5T3BzLmRpdl1dLFxuICBbJ0VpbnN1bScsIFtlaW5zdW0sIHBhcnNlRWluc3VtQXR0cmlidXRlc11dLFxuICBbJ0VsdScsIFt1bmFyeU9wcy5lbHUsIHVuYXJ5T3BzLnBhcnNlQWxwaGFBdHRyaWJ1dGVzXV0sXG4gIFsnRXF1YWwnLCBbYmluYXJ5T3BzLmVxdWFsXV0sXG4gIFsnRXJmJywgW3VuYXJ5T3BzLmVyZl1dLFxuICBbJ0V4cCcsIFt1bmFyeU9wcy5leHBdXSxcbiAgWydFeHBhbmQnLCBbZXhwYW5kXV0sXG4gIFsnRmFzdEdlbHUnLCBbZmFzdEdlbHVdXSxcbiAgWydGbG9vcicsIFt1bmFyeU9wcy5mbG9vcl1dLFxuICBbJ0Z1c2VkQ29udicsIFtjb252LCBwYXJzZUNvbnZBdHRyaWJ1dGVzXV0sXG4gIFsnR2F0aGVyJywgW2dhdGhlciwgcGFyc2VHYXRoZXJBdHRyaWJ1dGVzXV0sXG4gIFsnR2F0aGVyRWxlbWVudHMnLCBbZ2F0aGVyRWxlbWVudHMsIHBhcnNlR2F0aGVyRWxlbWVudHNBdHRyaWJ1dGVzXV0sXG4gIFsnR2F0aGVyQmxvY2tRdWFudGl6ZWQnLCBbZ2F0aGVyQmxvY2tRdWFudGl6ZWQsIHBhcnNlR2F0aGVyQmxvY2tRdWFudGl6ZWRBdHRyaWJ1dGVzXV0sXG4gIFsnR2VsdScsIFt1bmFyeU9wcy5nZWx1XV0sXG4gIFsnR2VtbScsIFtnZW1tLCBwYXJzZUdlbW1BdHRyaWJ1dGVzXV0sXG4gIFsnR2xvYmFsQXZlcmFnZVBvb2wnLCBbcG9vbC5nbG9iYWxBdmVyYWdlUG9vbCwgcG9vbC5wYXJzZUdsb2JhbEF2ZXJhZ2VQb29sQXR0cmlidXRlc11dLFxuICBbJ0dsb2JhbE1heFBvb2wnLCBbcG9vbC5nbG9iYWxNYXhQb29sLCBwb29sLnBhcnNlR2xvYmFsTWF4UG9vbEF0dHJpYnV0ZXNdXSxcbiAgWydHcmVhdGVyJywgW2JpbmFyeU9wcy5ncmVhdGVyXV0sXG4gIFsnR3JlYXRlck9yRXF1YWwnLCBbYmluYXJ5T3BzLmdyZWF0ZXJPckVxdWFsXV0sXG4gIFsnR3JvdXBRdWVyeUF0dGVudGlvbicsIFtncm91cFF1ZXJ5QXR0ZW50aW9uLCBwYXJzZUdyb3VwUXVlcnlBdHRlbnRpb25BdHRyaWJ1dGVzXV0sXG4gIFsnSGFyZFNpZ21vaWQnLCBbdW5hcnlPcHMuaGFyZFNpZ21vaWQsIHVuYXJ5T3BzLnBhcnNlSGFyZFNpZ21vaWRBdHRyaWJ1dGVzXV0sXG4gIFsnSW5zdGFuY2VOb3JtYWxpemF0aW9uJywgW2luc3RhbmNlTm9ybV1dLFxuICBbJ0xheWVyTm9ybWFsaXphdGlvbicsIFtsYXllck5vcm1dXSxcbiAgWydMZWFreVJlbHUnLCBbdW5hcnlPcHMubGVha3lSZWx1LCB1bmFyeU9wcy5wYXJzZUFscGhhQXR0cmlidXRlc11dLFxuICBbJ0xlc3MnLCBbYmluYXJ5T3BzLmxlc3NdXSxcbiAgWydMZXNzT3JFcXVhbCcsIFtiaW5hcnlPcHMubGVzc09yRXF1YWxdXSxcbiAgWydMb2cnLCBbdW5hcnlPcHMubG9nXV0sXG4gIFsnTWF0TXVsJywgW21hdE11bF1dLFxuICBbJ01hdE11bE5CaXRzJywgW21hdE11bE5CaXRzLCBwYXJzZU1hdE11bE5CaXRzQXR0cmlidXRlc11dLFxuICAvLyBUT0RPOiBzdXBwb3J0IG5ldyBhdHRyaWJ1dGVzIGZvciBNYXhQb29sLTggYW5kIE1heFBvb2wtMTBcbiAgWydNYXhQb29sJywgW3Bvb2wubWF4UG9vbCwgcG9vbC5wYXJzZU1heFBvb2xBdHRyaWJ1dGVzXV0sXG4gIFsnTXVsJywgW2JpbmFyeU9wcy5tdWxdXSxcbiAgWydNdWx0aUhlYWRBdHRlbnRpb24nLCBbbXVsdGlIZWFkQXR0ZW50aW9uLCBwYXJzZU11bHRpSGVhZEF0dGVudGlvbkF0dHJpYnV0ZXNdXSxcbiAgWydOZWcnLCBbdW5hcnlPcHMubmVnXV0sXG4gIFsnTm90JywgW3VuYXJ5T3BzLm5vdF1dLFxuICBbJ1BhZCcsIFtwYWRdXSxcbiAgWydQb3cnLCBbYmluYXJ5T3BzLnBvd11dLFxuICBbJ1F1aWNrR2VsdScsIFt1bmFyeU9wcy5xdWlja2dlbHUsIHVuYXJ5T3BzLnBhcnNlQWxwaGFBdHRyaWJ1dGVzXV0sXG4gIFsnUmFuZ2UnLCBbcmFuZ2VdXSxcbiAgWydSZWNpcHJvY2FsJywgW3VuYXJ5T3BzLnJlY2lwcm9jYWxdXSxcbiAgWydSZWR1Y2VNaW4nLCBbcmVkdWNlTWluXV0sXG4gIFsnUmVkdWNlTWVhbicsIFtyZWR1Y2VNZWFuXV0sXG4gIFsnUmVkdWNlTWF4JywgW3JlZHVjZU1heF1dLFxuICBbJ1JlZHVjZVN1bScsIFtyZWR1Y2VTdW1dXSxcbiAgWydSZWR1Y2VQcm9kJywgW3JlZHVjZVByb2RdXSxcbiAgWydSZWR1Y2VMMScsIFtyZWR1Y2VMMV1dLFxuICBbJ1JlZHVjZUwyJywgW3JlZHVjZUwyXV0sXG4gIFsnUmVkdWNlTG9nU3VtJywgW3JlZHVjZUxvZ1N1bV1dLFxuICBbJ1JlZHVjZUxvZ1N1bUV4cCcsIFtyZWR1Y2VMb2dTdW1FeHBdXSxcbiAgWydSZWR1Y2VTdW1TcXVhcmUnLCBbcmVkdWNlU3VtU3F1YXJlXV0sXG4gIFsnUmVsdScsIFt1bmFyeU9wcy5yZWx1XV0sXG4gIFsnUmVzaXplJywgW3Jlc2l6ZSwgcGFyc2VSZXNpemVBdHRyaWJ1dGVzXV0sXG4gIFsnUm90YXJ5RW1iZWRkaW5nJywgW3JvdGFyeUVtYmVkZGluZ11dLFxuICBbJ1NpZ21vaWQnLCBbdW5hcnlPcHMuc2lnbW9pZF1dLFxuICBbJ1NpbicsIFt1bmFyeU9wcy5zaW5dXSxcbiAgWydTaW5oJywgW3VuYXJ5T3BzLnNpbmhdXSxcbiAgWydTbGljZScsIFtzbGljZSwgcGFyc2VTbGljZUF0dHJpYnV0ZXNdXSxcbiAgWydTa2lwTGF5ZXJOb3JtYWxpemF0aW9uJywgW3NraXBMYXllck5vcm1dXSxcbiAgWydTcGxpdCcsIFtzcGxpdCwgcGFyc2VTcGxpdEF0dHJpYnV0ZXNdXSxcbiAgWydTcXJ0JywgW3VuYXJ5T3BzLnNxcnRdXSxcbiAgWydTb2Z0bWF4JywgW3NvZnRtYXgsIHBhcnNlU29mdG1heEF0dHJpYnV0ZXNdXSxcbiAgWydTdWInLCBbYmluYXJ5T3BzLnN1Yl1dLFxuICBbJ1RhbicsIFt1bmFyeU9wcy50YW5dXSxcbiAgWydUYW5oJywgW3VuYXJ5T3BzLnRhbmhdXSxcbiAgWydUaHJlc2hvbGRlZFJlbHUnLCBbdW5hcnlPcHMudGhyZXNob2xkZWRSZWx1LCB1bmFyeU9wcy5wYXJzZUFscGhhQXR0cmlidXRlc11dLFxuICBbJ1RpbGUnLCBbdGlsZV1dLFxuICBbJ1RyYW5zcG9zZScsIFt0cmFuc3Bvc2UsIHBhcnNlVHJhbnNwb3NlQXR0cmlidXRlc11dLFxuICBbJ1doZXJlJywgW3doZXJlXV0sXG5dKTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHsgVFJBQ0VfRlVOQ19CRUdJTiwgVFJBQ0VfRlVOQ19FTkQgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgeyBXZWJHcHVCYWNrZW5kIH0gZnJvbSAnLi4vYmFja2VuZC13ZWJncHUnO1xuaW1wb3J0IHsgTE9HX0RFQlVHIH0gZnJvbSAnLi4vbG9nJztcblxuaW1wb3J0IHsgY3JlYXRlU2hhZGVySGVscGVyIH0gZnJvbSAnLi9vcHMvY29tbW9uJztcbmltcG9ydCB7IEFydGlmYWN0LCBHcHVEYXRhLCBQcm9ncmFtSW5mbyB9IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIFByb2dyYW1NYW5hZ2VyIGlzIHRoZSBtYWluIGNsYXNzIGJlaGluZCBydW5uaW5nIGNvbXB1dGF0aW9uc1xuICogSXQgYnVpbGRzIFByb2dyYW1JbmZvJ3MgaW50byBBcnRpZmFjdHNcbiAqIEl0IGNvbXBpbGVzIGdpdmVuIFByb2dyYW1JbmZvJ3MgaW50byBXZWJHTCBQcm9yYW1zIChjYWNoZWQgYXMgQXJ0aWZhY3RzKVxuICogVXNlcyB0aGUgYXJ0aWZhY3QgdG8gcnVuIHRoZSBjb21wdXRhdGlvbiBieSBjYWxsaW5nIERyYXcgb25cbiAqIHRoZSBXZWJHTCBkcmF3aW5nIGJ1ZmZlclxuICogUHJvZ3JhbU1hbmFnZXIgYXV0b21hdGljYWxseSBtYXBzIChiaW5kcykgaW5wdXQgdmFyaWFibGVzIHRvIHRoZWlyXG4gKiBjb3JyZXNwb25kaW5nIExvY2F0aW9uJ3MgaW4gdGhlIGJpbmFyeSBwcm9ncmFtXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9ncmFtTWFuYWdlciB7XG4gIHJlcG86IE1hcDx1bmtub3duLCBBcnRpZmFjdD47IC8vIHRoaXMgc2hvdWxkIGJlIHBlci1zZXNzaW9uIG9iamVjdFxuICBhdHRyaWJ1dGVzQm91bmQ6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBiYWNrZW5kOiBXZWJHcHVCYWNrZW5kKSB7XG4gICAgdGhpcy5yZXBvID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYXR0cmlidXRlc0JvdW5kID0gZmFsc2U7XG4gIH1cbiAgZ2V0QXJ0aWZhY3Qoa2V5OiB1bmtub3duKTogQXJ0aWZhY3QgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnJlcG8uZ2V0KGtleSk7XG4gIH1cbiAgc2V0QXJ0aWZhY3Qoa2V5OiB1bmtub3duLCBhcnRpZmFjdDogQXJ0aWZhY3QpOiB2b2lkIHtcbiAgICB0aGlzLnJlcG8uc2V0KGtleSwgYXJ0aWZhY3QpO1xuICB9XG4gIHJ1bihcbiAgICBidWlsZEFydGlmYWN0OiBBcnRpZmFjdCxcbiAgICBpbnB1dHM6IEdwdURhdGFbXSxcbiAgICBvdXRwdXRzOiBHcHVEYXRhW10sXG4gICAgZGlzcGF0Y2hHcm91cDogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgIHVuaWZvcm1CdWZmZXJCaW5kaW5nOiBHUFVCaW5kaW5nUmVzb3VyY2UgfCB1bmRlZmluZWQsXG4gICk6IHZvaWQge1xuICAgIFRSQUNFX0ZVTkNfQkVHSU4oYnVpbGRBcnRpZmFjdC5wcm9ncmFtSW5mby5uYW1lKTtcbiAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmJhY2tlbmQuZGV2aWNlO1xuICAgIGNvbnN0IGNvbXB1dGVQYXNzRW5jb2RlciA9IHRoaXMuYmFja2VuZC5nZXRDb21wdXRlUGFzc0VuY29kZXIoKTtcbiAgICB0aGlzLmJhY2tlbmQud3JpdGVUaW1lc3RhbXAodGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIpO1xuICAgIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGlucHV0cykge1xuICAgICAgZW50cmllcy5wdXNoKHsgYmluZGluZzogZW50cmllcy5sZW5ndGgsIHJlc291cmNlOiB7IGJ1ZmZlcjogaW5wdXQuYnVmZmVyIH0gfSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgb3V0cHV0IG9mIG91dHB1dHMpIHtcbiAgICAgIGVudHJpZXMucHVzaCh7IGJpbmRpbmc6IGVudHJpZXMubGVuZ3RoLCByZXNvdXJjZTogeyBidWZmZXI6IG91dHB1dC5idWZmZXIgfSB9KTtcbiAgICB9XG4gICAgaWYgKHVuaWZvcm1CdWZmZXJCaW5kaW5nKSB7XG4gICAgICBlbnRyaWVzLnB1c2goeyBiaW5kaW5nOiBlbnRyaWVzLmxlbmd0aCwgcmVzb3VyY2U6IHVuaWZvcm1CdWZmZXJCaW5kaW5nIH0pO1xuICAgIH1cbiAgICBjb25zdCBiaW5kR3JvdXAgPSBkZXZpY2UuY3JlYXRlQmluZEdyb3VwKHtcbiAgICAgIGxheW91dDogYnVpbGRBcnRpZmFjdC5jb21wdXRlUGlwZWxpbmUuZ2V0QmluZEdyb3VwTGF5b3V0KDApLFxuICAgICAgZW50cmllcyxcbiAgICAgIGxhYmVsOiBidWlsZEFydGlmYWN0LnByb2dyYW1JbmZvLm5hbWUsXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5iYWNrZW5kLnNlc3Npb25TdGF0dXMgPT09ICdjYXB0dXJpbmcnKSB7XG4gICAgICBjb25zdCBjb21tYW5kSW5mbyA9IHtcbiAgICAgICAga2VybmVsSWQ6IHRoaXMuYmFja2VuZC5jdXJyZW50S2VybmVsSWQhLFxuICAgICAgICBjb21wdXRlUGlwZWxpbmU6IGJ1aWxkQXJ0aWZhY3QuY29tcHV0ZVBpcGVsaW5lLFxuICAgICAgICBiaW5kR3JvdXAsXG4gICAgICAgIGRpc3BhdGNoR3JvdXAsXG4gICAgICB9O1xuICAgICAgY29uc3Qgc2Vzc2lvbkNvbW1hbmRMaXN0ID0gdGhpcy5iYWNrZW5kLmNhcHR1cmVkQ29tbWFuZExpc3QuZ2V0KHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkISk7XG4gICAgICBzZXNzaW9uQ29tbWFuZExpc3QhLnB1c2goY29tbWFuZEluZm8pO1xuICAgIH1cblxuICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5zZXRQaXBlbGluZShidWlsZEFydGlmYWN0LmNvbXB1dGVQaXBlbGluZSk7XG4gICAgY29tcHV0ZVBhc3NFbmNvZGVyLnNldEJpbmRHcm91cCgwLCBiaW5kR3JvdXApO1xuICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5kaXNwYXRjaFdvcmtncm91cHMoLi4uZGlzcGF0Y2hHcm91cCk7XG4gICAgdGhpcy5iYWNrZW5kLndyaXRlVGltZXN0YW1wKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyICsgMSk7XG4gICAgdGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcisrO1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlciA+PSB0aGlzLmJhY2tlbmQubWF4RGlzcGF0Y2hOdW1iZXIgfHxcbiAgICAgIHRoaXMuYmFja2VuZC5xdWVyeVR5cGUgPT09ICdhdC1wYXNzZXMnXG4gICAgKSB7XG4gICAgICB0aGlzLmJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgPj0gdGhpcy5iYWNrZW5kLm1heERpc3BhdGNoTnVtYmVyKSB7XG4gICAgICB0aGlzLmJhY2tlbmQuZmx1c2goKTtcbiAgICB9XG4gICAgVFJBQ0VfRlVOQ19FTkQoYnVpbGRBcnRpZmFjdC5wcm9ncmFtSW5mby5uYW1lKTtcbiAgfVxuICBkaXNwb3NlKCk6IHZvaWQge1xuICAgIC8vIHRoaXMucmVwby5mb3JFYWNoKGEgPT4gdGhpcy5nbENvbnRleHQuZGVsZXRlUHJvZ3JhbShhLnByb2dyYW0pKTtcbiAgfVxuICBidWlsZChwcm9ncmFtSW5mbzogUHJvZ3JhbUluZm8sIG5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdKTogQXJ0aWZhY3Qge1xuICAgIFRSQUNFX0ZVTkNfQkVHSU4ocHJvZ3JhbUluZm8ubmFtZSk7XG4gICAgY29uc3QgZGV2aWNlID0gdGhpcy5iYWNrZW5kLmRldmljZTtcbiAgICBjb25zdCBleHRlbnNpb25zOiBzdHJpbmdbXSA9IFtdO1xuICAgIGlmIChkZXZpY2UuZmVhdHVyZXMuaGFzKCdzaGFkZXItZjE2JykpIHtcbiAgICAgIGV4dGVuc2lvbnMucHVzaCgnZW5hYmxlIGYxNjsnKTtcbiAgICB9XG4gICAgY29uc3Qgc2hhZGVySGVscGVyID0gY3JlYXRlU2hhZGVySGVscGVyKG5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwU2l6ZSwgdGhpcy5iYWNrZW5kLmRldmljZS5saW1pdHMpO1xuICAgIGNvbnN0IHVzZXJDb2RlID0gcHJvZ3JhbUluZm8uZ2V0U2hhZGVyU291cmNlKHNoYWRlckhlbHBlcik7XG4gICAgY29uc3QgY29kZSA9IGAke2V4dGVuc2lvbnMuam9pbignXFxuJyl9XFxuJHtzaGFkZXJIZWxwZXIuYWRkaXRpb25hbEltcGxlbWVudGF0aW9uc31cXG4ke3VzZXJDb2RlfWA7XG4gICAgY29uc3Qgc2hhZGVyTW9kdWxlID0gZGV2aWNlLmNyZWF0ZVNoYWRlck1vZHVsZSh7IGNvZGUsIGxhYmVsOiBwcm9ncmFtSW5mby5uYW1lIH0pO1xuICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbV2ViR1BVXSAke3Byb2dyYW1JbmZvLm5hbWV9IHNoYWRlciBjb2RlOiAke2NvZGV9YCk7XG5cbiAgICBjb25zdCBjb21wdXRlUGlwZWxpbmUgPSBkZXZpY2UuY3JlYXRlQ29tcHV0ZVBpcGVsaW5lKHtcbiAgICAgIGNvbXB1dGU6IHsgbW9kdWxlOiBzaGFkZXJNb2R1bGUsIGVudHJ5UG9pbnQ6ICdtYWluJyB9LFxuICAgICAgbGF5b3V0OiAnYXV0bycsXG4gICAgICBsYWJlbDogcHJvZ3JhbUluZm8ubmFtZSxcbiAgICB9KTtcblxuICAgIFRSQUNFX0ZVTkNfRU5EKHByb2dyYW1JbmZvLm5hbWUpO1xuICAgIHJldHVybiB7IHByb2dyYW1JbmZvLCBjb21wdXRlUGlwZWxpbmUsIHVuaWZvcm1WYXJpYWJsZXNJbmZvOiBzaGFkZXJIZWxwZXIudmFyaWFibGVzSW5mbyB9O1xuICB9XG5cbiAgbm9ybWFsaXplRGlzcGF0Y2hHcm91cFNpemUoXG4gICAgZGlzcGF0Y2hHcm91cDogUmV0dXJuVHlwZTxQcm9ncmFtSW5mb1snZ2V0UnVuRGF0YSddPlsnZGlzcGF0Y2hHcm91cCddLFxuICApOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0ge1xuICAgIGNvbnN0IHggPSB0eXBlb2YgZGlzcGF0Y2hHcm91cCA9PT0gJ251bWJlcicgPyBkaXNwYXRjaEdyb3VwIDogZGlzcGF0Y2hHcm91cC54O1xuICAgIGNvbnN0IHkgPSB0eXBlb2YgZGlzcGF0Y2hHcm91cCA9PT0gJ251bWJlcicgPyAxIDogZGlzcGF0Y2hHcm91cC55IHx8IDE7XG4gICAgY29uc3QgeiA9IHR5cGVvZiBkaXNwYXRjaEdyb3VwID09PSAnbnVtYmVyJyA/IDEgOiBkaXNwYXRjaEdyb3VwLnogfHwgMTtcbiAgICBjb25zdCBsaW1pdFBlckRpbWVuc2lvbiA9IHRoaXMuYmFja2VuZC5kZXZpY2UubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uO1xuICAgIGlmICh4IDw9IGxpbWl0UGVyRGltZW5zaW9uICYmIHkgPD0gbGltaXRQZXJEaW1lbnNpb24gJiYgeiA8PSBsaW1pdFBlckRpbWVuc2lvbikge1xuICAgICAgcmV0dXJuIFt4LCB5LCB6XTtcbiAgICB9XG4gICAgY29uc3Qgc2l6ZSA9IHggKiB5ICogejtcbiAgICBsZXQgZGlzcGF0Y2hBdmVyYWdlID0gTWF0aC5jZWlsKE1hdGguc3FydChzaXplKSk7XG4gICAgaWYgKGRpc3BhdGNoQXZlcmFnZSA+IGxpbWl0UGVyRGltZW5zaW9uKSB7XG4gICAgICBkaXNwYXRjaEF2ZXJhZ2UgPSBNYXRoLmNlaWwoTWF0aC5jYnJ0KHNpemUpKTtcbiAgICAgIGlmIChkaXNwYXRjaEF2ZXJhZ2UgPiBsaW1pdFBlckRpbWVuc2lvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvdGFsIGRpc3BhdGNoIHNpemUgZXhjZWVkcyBXZWJHUFUgbWF4aW11bS4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbZGlzcGF0Y2hBdmVyYWdlLCBkaXNwYXRjaEF2ZXJhZ2UsIGRpc3BhdGNoQXZlcmFnZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbZGlzcGF0Y2hBdmVyYWdlLCBkaXNwYXRjaEF2ZXJhZ2UsIDFdO1xuICAgIH1cbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBFbnYsIFRlbnNvciwgVFJBQ0UsIFRSQUNFX0ZVTkNfQkVHSU4sIFRSQUNFX0ZVTkNfRU5EIH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcblxuaW1wb3J0IHsgRGF0YVR5cGUsIHRlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nIH0gZnJvbSAnLi4vd2FzbS1jb21tb24nO1xuXG5pbXBvcnQgeyBjb25maWd1cmVMb2dnZXIsIExPR19ERUJVRyB9IGZyb20gJy4vbG9nJztcbmltcG9ydCB7IGNyZWF0ZVZpZXcsIFRlbnNvclZpZXcgfSBmcm9tICcuL3RlbnNvci12aWV3JztcbmltcG9ydCB7IGNyZWF0ZUdwdURhdGFNYW5hZ2VyLCBkb3dubG9hZEdwdURhdGEsIEdwdURhdGFNYW5hZ2VyIH0gZnJvbSAnLi93ZWJncHUvZ3B1LWRhdGEtbWFuYWdlcic7XG5pbXBvcnQgeyBSdW5GdW5jdGlvbiwgV0VCR1BVX09QX1JFU09MVkVfUlVMRVMgfSBmcm9tICcuL3dlYmdwdS9vcC1yZXNvbHZlLXJ1bGVzJztcbmltcG9ydCB7IFByb2dyYW1NYW5hZ2VyIH0gZnJvbSAnLi93ZWJncHUvcHJvZ3JhbS1tYW5hZ2VyJztcbmltcG9ydCB7XG4gIEFkYXB0ZXJJbmZvLFxuICBDb21wdXRlQ29udGV4dCxcbiAgR3B1QXJjaGl0ZWN0dXJlLFxuICBHcHVEYXRhLFxuICBHcHVWZW5kb3IsXG4gIFByb2dyYW1JbmZvLFxuICBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeSxcbiAgU2Vzc2lvblN0YXRlLFxuICBUaW1lc3RhbXBRdWVyeSxcbn0gZnJvbSAnLi93ZWJncHUvdHlwZXMnO1xuXG5pbnRlcmZhY2UgQ29tbWFuZEluZm8ge1xuICByZWFkb25seSBrZXJuZWxJZDogbnVtYmVyO1xuICByZWFkb25seSBjb21wdXRlUGlwZWxpbmU6IEdQVUNvbXB1dGVQaXBlbGluZTtcbiAgcmVhZG9ubHkgYmluZEdyb3VwOiBHUFVCaW5kR3JvdXA7XG4gIHJlYWRvbmx5IGRpc3BhdGNoR3JvdXA6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcbn1cblxuaW50ZXJmYWNlIEtlcm5lbEluZm8ge1xuICByZWFkb25seSBrZXJuZWxUeXBlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGtlcm5lbE5hbWU6IHN0cmluZztcbiAgcmVhZG9ubHkga2VybmVsRW50cnk6IFJ1bkZ1bmN0aW9uO1xuICByZWFkb25seSBhdHRyaWJ1dGVzOiBbKChhdHRyaWJ1dGU6IHVua25vd24pID0+IHVua25vd24pIHwgdW5kZWZpbmVkLCB1bmtub3duXTtcbn1cblxuaW50ZXJmYWNlIFBlbmRpbmdLZXJuZWxJbmZvIHtcbiAgcmVhZG9ubHkga2VybmVsSWQ6IG51bWJlcjtcbiAgcmVhZG9ubHkgcHJvZ3JhbU5hbWU6IHN0cmluZztcbiAgcmVhZG9ubHkgaW5wdXRUZW5zb3JWaWV3czogcmVhZG9ubHkgVGVuc29yVmlld1tdO1xuICByZWFkb25seSBvdXRwdXRUZW5zb3JWaWV3czogcmVhZG9ubHkgVGVuc29yVmlld1tdO1xufVxuXG5jb25zdCBnZXRQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeUtleSA9IChcbiAgaW5wdXRUZW5zb3JzOiByZWFkb25seSBUZW5zb3JWaWV3W10sXG4gIGlucHV0RGVwZW5kZW5jaWVzOiByZWFkb25seSBQcm9ncmFtSW5wdXRUZW5zb3JJbmZvRGVwZW5kZW5jeVtdLFxuKTogc3RyaW5nID0+IHtcbiAgaWYgKGlucHV0RGVwZW5kZW5jaWVzLmxlbmd0aCAhPT0gaW5wdXRUZW5zb3JzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBpbnB1dERlcGVuZGVuY2llcyBsZW5ndGggJHtpbnB1dERlcGVuZGVuY2llcy5sZW5ndGh9IGlzIG5vdCBlcXVhbCB0byBpbnB1dFRlbnNvcnMgbGVuZ3RoICR7XG4gICAgICAgIGlucHV0VGVuc29ycy5sZW5ndGhcbiAgICAgIH0uYCxcbiAgICApO1xuICB9XG5cbiAgY29uc3QgaW5wdXRJbmZvczogc3RyaW5nW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFRlbnNvcnMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCB0eXBlID0gaW5wdXRUZW5zb3JzW2ldLmRhdGFUeXBlO1xuICAgIHN3aXRjaCAoaW5wdXREZXBlbmRlbmNpZXNbaV0pIHtcbiAgICAgIGNhc2UgJ25vbmUnOiB7XG4gICAgICAgIGlucHV0SW5mb3MucHVzaCgnJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAndHlwZSc6IHtcbiAgICAgICAgaW5wdXRJbmZvcy5wdXNoKGAke3R5cGV9YCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAncmFuayc6IHtcbiAgICAgICAgY29uc3QgcmFuayA9IGlucHV0VGVuc29yc1tpXS5kaW1zLmxlbmd0aDtcbiAgICAgICAgaW5wdXRJbmZvcy5wdXNoKGAke3R5cGV9OyR7cmFua31gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdkaW1zJzoge1xuICAgICAgICBjb25zdCBkaW1zID0gaW5wdXRUZW5zb3JzW2ldLmRpbXMuam9pbignLCcpO1xuICAgICAgICBpbnB1dEluZm9zLnB1c2goYCR7dHlwZX07JHtkaW1zfWApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgaW5wdXQgZGVwZW5kZW5jeTogJHtpbnB1dERlcGVuZGVuY2llc1tpXX1gKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5wdXRJbmZvcy5qb2luKCd8Jyk7XG59O1xuXG4vKipcbiAqIGdldCBhIHVuaXF1ZSBrZXkgcmVwcmVzZW50aW5nIHRoZSBwcm9ncmFtIGZyb20gdGhlIHByb2dyYW0gaW5mbywgaW5wdXQgc2hhcGVzIGFuZCB0eXBlcy5cbiAqXG4gKiBAcmV0dXJucyBhIHVuaXF1ZSBrZXkgaXMgYSBzaG9ydGVyIHN0cmluZyB0aGFuIHRoZSBzaGFkZXIgc291cmNlLCB3aGljaCBjb250YWlucyBhbGwgdGhlIGluZm9ybWF0aW9uIHRvIGlkZW50aWZ5IGFcbiAqIHByb2dyYW0uIGlmIHRoZSBrZXkgaXMgdGhlIHNhbWUsIHRoZSBwcm9ncmFtIHNoYWRlciBzb3VyY2Ugc2hvdWxkIGJlIHRoZSBzYW1lLCBzbyB3ZSBjYW4gcmV1c2UgdGhlIHByb2dyYW0uXG4gKlxuICovXG5jb25zdCBnZXRQcm9ncmFtSW5mb1VuaXF1ZUtleSA9IChcbiAgcHJvZ3JhbUluZm86IFByb2dyYW1JbmZvLFxuICBpbnB1dFRlbnNvcnM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgaXMxRGltZW5zaW9uRGlzcGF0Y2g6IGJvb2xlYW4sXG4pOiBzdHJpbmcgPT4ge1xuICAvLyBmaW5hbCBrZXkgZm9ybWF0OlxuICAvLyA8UFJPR1JBTV9OQU1FPls8UFJPR1JBTV9DVVNUT01fQ0FDSEVfSElOVD5dOmlzMURpbWVuc2lvbkRpc3BhdGNoOjxJTlBVVFNfSU5GT18wPnw8SU5QVVRTX0lORk9fMT58Li4uXG4gIGxldCBrZXkgPSBwcm9ncmFtSW5mby5uYW1lO1xuICBpZiAocHJvZ3JhbUluZm8uc2hhZGVyQ2FjaGU/LmhpbnQpIHtcbiAgICBrZXkgKz0gJ1snICsgcHJvZ3JhbUluZm8uc2hhZGVyQ2FjaGUuaGludCArICddJztcbiAgfVxuICBrZXkgKz1cbiAgICAnOicgK1xuICAgIGlzMURpbWVuc2lvbkRpc3BhdGNoICtcbiAgICBgOiR7Z2V0UHJvZ3JhbUlucHV0VGVuc29ySW5mb0RlcGVuZGVuY3lLZXkoXG4gICAgICBpbnB1dFRlbnNvcnMsXG4gICAgICBwcm9ncmFtSW5mby5zaGFkZXJDYWNoZT8uaW5wdXREZXBlbmRlbmNpZXMgPz9cbiAgICAgICAgbmV3IEFycmF5PFByb2dyYW1JbnB1dFRlbnNvckluZm9EZXBlbmRlbmN5PihpbnB1dFRlbnNvcnMubGVuZ3RoKS5maWxsKCdkaW1zJyksXG4gICAgKX1gO1xuICByZXR1cm4ga2V5O1xufTtcblxuY2xhc3MgQWRhcHRlckluZm9JbXBsIGltcGxlbWVudHMgQWRhcHRlckluZm8ge1xuICByZWFkb25seSBhcmNoaXRlY3R1cmU/OiBzdHJpbmc7XG4gIHJlYWRvbmx5IHZlbmRvcj86IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihhZGFwdGVySW5mbzogR1BVQWRhcHRlckluZm8pIHtcbiAgICBpZiAoYWRhcHRlckluZm8pIHtcbiAgICAgIHRoaXMuYXJjaGl0ZWN0dXJlID0gYWRhcHRlckluZm8uYXJjaGl0ZWN0dXJlO1xuICAgICAgdGhpcy52ZW5kb3IgPSBhZGFwdGVySW5mby52ZW5kb3I7XG4gICAgfVxuICB9XG5cbiAgaXNBcmNoaXRlY3R1cmUoYXJjaGl0ZWN0dXJlOiBHcHVBcmNoaXRlY3R1cmUpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5hcmNoaXRlY3R1cmUgPT09IGFyY2hpdGVjdHVyZTtcbiAgfVxuXG4gIGlzVmVuZG9yKHZlbmRvcjogR3B1VmVuZG9yKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMudmVuZG9yID09PSB2ZW5kb3I7XG4gIH1cbn1cblxuLyoqXG4gKiB0aGlzIGNsYXNzIGlzIGRlc2lnbmVkIHRvIHN0b3JlIHN0YXR1cyBhbmQgYmVpbmcgdXNlZCBhcyBhIHNpbmdsZXRvbiBmb3IgSlNFUC4gSXQgd2lsbCBiZSBwYXNzZWQgdG8ganNlcEluaXQoKSBhc1xuICogdGhlIGZpcnN0IHBhcmFtZXRlciBzbyB0aGF0IGl0IGlzIHN0b3JlZCBmb3IgZnV0dXJlIHVzZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYkdwdUJhY2tlbmQge1xuICBhZGFwdGVySW5mbzogQWRhcHRlckluZm9JbXBsO1xuICBkZXZpY2U6IEdQVURldmljZTtcbiAgLyoqXG4gICAqIGFuIGluc3RhbmNlIG9mIEdwdURhdGFNYW5hZ2VyIHRvIG1hbmFnZSBhIEdwdURhdGFJZCAtPiBHcHVCdWZmZXIgbWFwcGluZ1xuICAgKi9cbiAgZ3B1RGF0YU1hbmFnZXI6IEdwdURhdGFNYW5hZ2VyO1xuICAvKipcbiAgICogYW4gaW5zdGFuY2Ugb2YgUHJvZ3JhbU1hbmFnZXIgdG8gYnVpbGQgYW5kIHJ1biBXZWJHUFUgY29tcHV0ZSBzaGFkZXIgcHJvZ3JhbSwgYW5kIG1hbmFnZSBhIFByb2dyYW1LZXkgLT4gUHJvZ3JhbVxuICAgKiBhcnRpZmFjdHMgbWFwcGluZ1xuICAgKi9cbiAgcHJvZ3JhbU1hbmFnZXI6IFByb2dyYW1NYW5hZ2VyO1xuXG4gIC8qKlxuICAgKiByZXByZXNlbnRpbmcgdGhlIHNlc3Npb24gSUQgb2Ygd2hpY2ggaXMgY3VycmVudGx5IGJlaW5nIHJ1bi5cbiAgICogYG51bGxgIG1lYW5zIG5vIHNlc3Npb24gaXMgYmVpbmcgcnVuLlxuICAgKiBvbmx5IHZhbGlkIHdoZW4gc2Vzc2lvbi5ydW4gaXMgZXhlY3V0ZWQuXG4gICAqL1xuICBjdXJyZW50U2Vzc2lvbklkOiBudW1iZXIgfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICogcmVwcmVzZW50aW5nIHRoZSBrZXJuZWwgSUQgb2Ygd2hpY2ggaXMgY3VycmVudGx5IGJlaW5nIGNvbXB1dGVkIChDUFUgY29kZSBwZXJzcGVjdGl2ZSkuXG4gICAqIGBudWxsYCBtZWFucyBubyBrZXJuZWwgaXMgYmVpbmcgY29tcHV0ZWQuXG4gICAqIG9ubHkgb25lIGtlcm5lbCBjYW4gYmUgY29tcHV0ZWQgYXQgYSBtb21lbnQuXG4gICAqL1xuICBjdXJyZW50S2VybmVsSWQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAvKipcbiAgICogYSBsaXN0IG9mIHRlbXBvcmFyeSBHUFUgZGF0YSBmb3IgdGhlIGN1cnJlbnQga2VybmVsLiBzaG91bGQgcmVsZWFzZSB3aGVuIHRoZSBrZXJuZWwgZG9uZSBjb21wdXRhdGlvbi5cbiAgICovXG4gIHByaXZhdGUgdGVtcG9yYXJ5RGF0YTogR3B1RGF0YVtdO1xuICAvKipcbiAgICogYSBLZXJuZWxJRCAtPiBhIEdQVSBkYXRhIGxpc3QsIHdoaWNoIHN0b3JlcyBwZXJzaXN0ZW50IEdQVSBkYXRhIG93bmVkIGJ5IHRoZSBzcGVjaWZpYyBrZXJuZWwuXG4gICAqL1xuICBwcml2YXRlIGtlcm5lbFBlcnNpc3RlbnREYXRhOiBNYXA8bnVtYmVyLCBHcHVEYXRhW10+O1xuICAvKipcbiAgICogYSBLZXJuZWxJRCAtPiBhIGN1c3RvbSBkYXRhLCB3aGljaCBzdG9yZXMgY3VzdG9tIGRhdGEgb3duZWQgYnkgdGhlIHNwZWNpZmljIGtlcm5lbC5cbiAgICovXG4gIHByaXZhdGUga2VybmVsQ3VzdG9tRGF0YTogTWFwPG51bWJlciwgeyBba2V5OiBzdHJpbmddOiB1bmtub3duIH0+O1xuICAvKipcbiAgICogZ2V0IHRoZSBjdXN0b20gZGF0YSBvZiB0aGUgY3VycmVudCBrZXJuZWxcbiAgICovXG4gIGdldCBjdXJyZW50S2VybmVsQ3VzdG9tRGF0YSgpOiB7IFtrZXk6IHN0cmluZ106IHVua25vd24gfSB7XG4gICAgaWYgKHRoaXMuY3VycmVudEtlcm5lbElkID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2N1cnJlbnRLZXJuZWxDdXN0b21EYXRhKCk6IGN1cnJlbnRLZXJuZWxJZCBpcyBudWxsLiAoc2hvdWxkIG5vdCBoYXBwZW4pJyk7XG4gICAgfVxuXG4gICAgbGV0IGRhdGEgPSB0aGlzLmtlcm5lbEN1c3RvbURhdGEuZ2V0KHRoaXMuY3VycmVudEtlcm5lbElkKTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIGRhdGEgPSB7fTtcbiAgICAgIHRoaXMua2VybmVsQ3VzdG9tRGF0YS5zZXQodGhpcy5jdXJyZW50S2VybmVsSWQsIGRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgLy8gS2VybmVsSUQgLT4ga2VybmVsSW5mbyBtYXBwaW5nXG4gIGtlcm5lbHM6IE1hcDxudW1iZXIsIEtlcm5lbEluZm8+O1xuICBwcml2YXRlIGNvbW1hbmRFbmNvZGVyOiBHUFVDb21tYW5kRW5jb2RlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGNvbXB1dGVQYXNzRW5jb2RlcjogR1BVQ29tcHV0ZVBhc3NFbmNvZGVyIHwgbnVsbCA9IG51bGw7XG4gIG1heERpc3BhdGNoTnVtYmVyID0gMTY7XG4gIHBlbmRpbmdEaXNwYXRjaE51bWJlciA9IDA7XG5cbiAgLy8gaW5mbyBvZiBrZXJuZWxzIHBlbmRpbmcgc3VibWlzc2lvbiBmb3IgYSBzaW5nbGUgYmF0Y2hcbiAgcHJpdmF0ZSBwZW5kaW5nS2VybmVsczogUGVuZGluZ0tlcm5lbEluZm9bXSA9IFtdO1xuICAvLyBxdWVyeVJlYWRCdWZmZXIgLT4gcGVuZGluZ0tlcm5lbHMgbWFwcGluZyBmb3IgYWxsIHRoZSBiYXRjaGVzXG4gIHByaXZhdGUgcGVuZGluZ1F1ZXJpZXM6IE1hcDxHUFVCdWZmZXIsIFBlbmRpbmdLZXJuZWxJbmZvW10+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIHF1ZXJ5UmVzb2x2ZUJ1ZmZlcj86IEdQVUJ1ZmZlcjtcbiAgcHJpdmF0ZSBxdWVyeVNldD86IEdQVVF1ZXJ5U2V0O1xuICBwcml2YXRlIHF1ZXJ5VGltZUJhc2U/OiBiaWdpbnQ7XG4gIHF1ZXJ5VHlwZTogVGltZXN0YW1wUXVlcnk7XG5cbiAgZW52OiBFbnY7XG4gIHNlc3Npb25TdGF0dXM6IFNlc3Npb25TdGF0ZSA9ICdkZWZhdWx0JztcbiAgLyoqXG4gICAqIGEgU2Vzc2lvbklEIC0+IENvbW1hbmRJbmZvW10gbWFwcGluZy4gSXQncyB1c2VkIHRvIHJlY29yZCBhbGwgR1BVIGNvbW1hbmRzIGZvciBjb3JyZXNwb25kaW5nIHNlc3Npb24uXG4gICAqL1xuICBjYXB0dXJlZENvbW1hbmRMaXN0OiBNYXA8bnVtYmVyLCBDb21tYW5kSW5mb1tdPiA9IG5ldyBNYXAoKTtcblxuICAvKipcbiAgICogYSBTZXNzaW9uSUQgLT4gUGVuZGluZ0tlcm5lbEluZm9bXSBtYXBwaW5nIGZvciBwcm9maWxpbmcuXG4gICAqL1xuICBwcml2YXRlIGNhcHR1cmVkUGVuZGluZ0tlcm5lbHM6IE1hcDxudW1iZXIsIFBlbmRpbmdLZXJuZWxJbmZvW10+ID0gbmV3IE1hcCgpO1xuXG4gIC8qKlxuICAgKiBhIFNlc3Npb25JRCAtPiBhIE1hcCBvZiAoSW5wdXRPdXRwdXRJbmRleCAtPiBbSUQsIEdQVUJ1ZmZlcl0pIG1hcHBpbmcuXG4gICAqL1xuICBzZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZzogTWFwPG51bWJlciwgTWFwPG51bWJlciwgW251bWJlciwgR1BVQnVmZmVyXT4+ID0gbmV3IE1hcCgpO1xuXG4gIGFzeW5jIGluaXRpYWxpemUoZW52OiBFbnYsIGFkYXB0ZXI6IEdQVUFkYXB0ZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLmVudiA9IGVudjtcbiAgICBjb25zdCByZXF1aXJlZEZlYXR1cmVzOiBHUFVGZWF0dXJlTmFtZVtdID0gW107XG4gICAgY29uc3QgZGV2aWNlRGVzY3JpcHRvcjogR1BVRGV2aWNlRGVzY3JpcHRvciA9IHtcbiAgICAgIHJlcXVpcmVkTGltaXRzOiB7XG4gICAgICAgIG1heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZTogYWRhcHRlci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFN0b3JhZ2VTaXplLFxuICAgICAgICBtYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbjogYWRhcHRlci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb24sXG4gICAgICAgIG1heFN0b3JhZ2VCdWZmZXJCaW5kaW5nU2l6ZTogYWRhcHRlci5saW1pdHMubWF4U3RvcmFnZUJ1ZmZlckJpbmRpbmdTaXplLFxuICAgICAgICBtYXhCdWZmZXJTaXplOiBhZGFwdGVyLmxpbWl0cy5tYXhCdWZmZXJTaXplLFxuICAgICAgICBtYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXA6IGFkYXB0ZXIubGltaXRzLm1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cCxcbiAgICAgICAgbWF4Q29tcHV0ZVdvcmtncm91cFNpemVYOiBhZGFwdGVyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVgsXG4gICAgICAgIG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWTogYWRhcHRlci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVZLFxuICAgICAgICBtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVo6IGFkYXB0ZXIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWixcbiAgICAgIH0sXG4gICAgICByZXF1aXJlZEZlYXR1cmVzLFxuICAgIH07XG5cbiAgICBpZiAoYWRhcHRlci5mZWF0dXJlcy5oYXMoJ2Nocm9taXVtLWV4cGVyaW1lbnRhbC10aW1lc3RhbXAtcXVlcnktaW5zaWRlLXBhc3NlcycpKSB7XG4gICAgICByZXF1aXJlZEZlYXR1cmVzLnB1c2goJ2Nocm9taXVtLWV4cGVyaW1lbnRhbC10aW1lc3RhbXAtcXVlcnktaW5zaWRlLXBhc3NlcycgYXMgR1BVRmVhdHVyZU5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYWRhcHRlci5mZWF0dXJlcy5oYXMoJ3RpbWVzdGFtcC1xdWVyeScpKSB7XG4gICAgICByZXF1aXJlZEZlYXR1cmVzLnB1c2goJ3RpbWVzdGFtcC1xdWVyeScpO1xuICAgIH1cbiAgICBpZiAoYWRhcHRlci5mZWF0dXJlcy5oYXMoJ3NoYWRlci1mMTYnKSkge1xuICAgICAgcmVxdWlyZWRGZWF0dXJlcy5wdXNoKCdzaGFkZXItZjE2Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5kZXZpY2UgPSBhd2FpdCBhZGFwdGVyLnJlcXVlc3REZXZpY2UoZGV2aWNlRGVzY3JpcHRvcik7XG4gICAgdGhpcy5hZGFwdGVySW5mbyA9IG5ldyBBZGFwdGVySW5mb0ltcGwoYWRhcHRlci5pbmZvIHx8IChhd2FpdCBhZGFwdGVyLnJlcXVlc3RBZGFwdGVySW5mbygpKSk7XG4gICAgdGhpcy5ncHVEYXRhTWFuYWdlciA9IGNyZWF0ZUdwdURhdGFNYW5hZ2VyKHRoaXMpO1xuICAgIHRoaXMucHJvZ3JhbU1hbmFnZXIgPSBuZXcgUHJvZ3JhbU1hbmFnZXIodGhpcyk7XG4gICAgdGhpcy5rZXJuZWxzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMua2VybmVsUGVyc2lzdGVudERhdGEgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5rZXJuZWxDdXN0b21EYXRhID0gbmV3IE1hcCgpO1xuXG4gICAgLy8gc2V0IHVwIGZsYWdzIGZvciBsb2dnZXJcbiAgICBjb25maWd1cmVMb2dnZXIoZW52LmxvZ0xldmVsISwgISFlbnYuZGVidWcpO1xuXG4gICAgLy8gVE9ETzogc2V0IHVwIGZsYWdzXG5cbiAgICB0aGlzLmRldmljZS5vbnVuY2FwdHVyZWRlcnJvciA9IChldikgPT4ge1xuICAgICAgaWYgKGV2LmVycm9yIGluc3RhbmNlb2YgR1BVVmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEFuIHVuY2F1Z2h0IFdlYkdQVSB2YWxpZGF0aW9uIGVycm9yIHdhcyByYWlzZWQ6ICR7ZXYuZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZW52LndlYmdwdSwgJ2RldmljZScsIHtcbiAgICAgIHZhbHVlOiB0aGlzLmRldmljZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmVudi53ZWJncHUsICdhZGFwdGVyJywge1xuICAgICAgdmFsdWU6IGFkYXB0ZXIsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICB9KTtcblxuICAgIC8vIGluaXQgcXVlcnlUeXBlLCB3aGljaCBpcyBuZWNlc3NhcnkgZm9yIEluZmVyZW5jZVNlc3Npb24uY3JlYXRlXG4gICAgdGhpcy5zZXRRdWVyeVR5cGUoKTtcbiAgfVxuXG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnF1ZXJ5U2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5xdWVyeVNldC5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuZ3B1RGF0YU1hbmFnZXIuZGlzcG9zZSgpO1xuICB9XG5cbiAgZ2V0Q29tbWFuZEVuY29kZXIoKTogR1BVQ29tbWFuZEVuY29kZXIge1xuICAgIGlmICghdGhpcy5jb21tYW5kRW5jb2Rlcikge1xuICAgICAgdGhpcy5jb21tYW5kRW5jb2RlciA9IHRoaXMuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbW1hbmRFbmNvZGVyO1xuICB9XG5cbiAgZ2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCk6IEdQVUNvbXB1dGVQYXNzRW5jb2RlciB7XG4gICAgaWYgKCF0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcikge1xuICAgICAgY29uc3QgY29tbWFuZEVuY29kZXIgPSB0aGlzLmdldENvbW1hbmRFbmNvZGVyKCk7XG4gICAgICBjb25zdCBjb21wdXRlUGFzc0Rlc2NyaXB0b3I6IEdQVUNvbXB1dGVQYXNzRGVzY3JpcHRvciA9IHt9O1xuXG4gICAgICBpZiAodGhpcy5xdWVyeVR5cGUgPT09ICdhdC1wYXNzZXMnKSB7XG4gICAgICAgIGNvbXB1dGVQYXNzRGVzY3JpcHRvci50aW1lc3RhbXBXcml0ZXMgPSB7XG4gICAgICAgICAgcXVlcnlTZXQ6IHRoaXMucXVlcnlTZXQhLFxuICAgICAgICAgIGJlZ2lubmluZ09mUGFzc1dyaXRlSW5kZXg6IHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyICogMixcbiAgICAgICAgICBlbmRPZlBhc3NXcml0ZUluZGV4OiB0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIgKyAxLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbXB1dGVQYXNzRW5jb2RlciA9IGNvbW1hbmRFbmNvZGVyLmJlZ2luQ29tcHV0ZVBhc3MoY29tcHV0ZVBhc3NEZXNjcmlwdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyO1xuICB9XG5cbiAgZW5kQ29tcHV0ZVBhc3MoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyKSB7XG4gICAgICB0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlci5lbmQoKTtcbiAgICAgIHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmbHVzaCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuY29tbWFuZEVuY29kZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBUUkFDRV9GVU5DX0JFR0lOKCk7XG5cbiAgICB0aGlzLmVuZENvbXB1dGVQYXNzKCk7XG4gICAgbGV0IHF1ZXJ5UmVhZEJ1ZmZlcjogR1BVQnVmZmVyO1xuICAgIGlmICh0aGlzLnF1ZXJ5VHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICB0aGlzLmNvbW1hbmRFbmNvZGVyLnJlc29sdmVRdWVyeVNldChcbiAgICAgICAgdGhpcy5xdWVyeVNldCEsXG4gICAgICAgIDAsXG4gICAgICAgIHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyICogMixcbiAgICAgICAgdGhpcy5xdWVyeVJlc29sdmVCdWZmZXIhLFxuICAgICAgICAwLFxuICAgICAgKTtcblxuICAgICAgcXVlcnlSZWFkQnVmZmVyID0gdGhpcy5kZXZpY2UuY3JlYXRlQnVmZmVyKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICB7IHNpemU6IHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyICogMiAqIDgsIHVzYWdlOiBHUFVCdWZmZXJVc2FnZS5NQVBfUkVBRCB8IEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUIH0sXG4gICAgICApO1xuXG4gICAgICB0aGlzLnBlbmRpbmdRdWVyaWVzLnNldChxdWVyeVJlYWRCdWZmZXIsIHRoaXMucGVuZGluZ0tlcm5lbHMpO1xuICAgICAgdGhpcy5wZW5kaW5nS2VybmVscyA9IFtdO1xuICAgICAgdGhpcy5jb21tYW5kRW5jb2Rlci5jb3B5QnVmZmVyVG9CdWZmZXIoXG4gICAgICAgIHRoaXMucXVlcnlSZXNvbHZlQnVmZmVyISxcbiAgICAgICAgMCxcbiAgICAgICAgcXVlcnlSZWFkQnVmZmVyLFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciAqIDIgKiA4LFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmRldmljZS5xdWV1ZS5zdWJtaXQoW3RoaXMuY29tbWFuZEVuY29kZXIuZmluaXNoKCldKTtcbiAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlZnJlc2hQZW5kaW5nQnVmZmVycygpO1xuICAgIHRoaXMuY29tbWFuZEVuY29kZXIgPSBudWxsO1xuICAgIHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyID0gMDtcblxuICAgIGlmICh0aGlzLnF1ZXJ5VHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICB2b2lkIHF1ZXJ5UmVhZEJ1ZmZlciEubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFEKS50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc3QgbWFwcGVkRGF0YSA9IG5ldyBCaWdVaW50NjRBcnJheShxdWVyeVJlYWRCdWZmZXIuZ2V0TWFwcGVkUmFuZ2UoKSk7XG4gICAgICAgIGNvbnN0IHBlbmRpbmdLZXJuZWxzID0gdGhpcy5wZW5kaW5nUXVlcmllcy5nZXQocXVlcnlSZWFkQnVmZmVyKSE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwcGVkRGF0YS5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBwZW5kaW5nS2VybmVsSW5mbyA9IHBlbmRpbmdLZXJuZWxzW2ldO1xuICAgICAgICAgIGNvbnN0IGtlcm5lbElkID0gcGVuZGluZ0tlcm5lbEluZm8ua2VybmVsSWQ7XG4gICAgICAgICAgY29uc3Qga2VybmVsSW5mbyA9IHRoaXMua2VybmVscy5nZXQoa2VybmVsSWQpITtcbiAgICAgICAgICBjb25zdCBrZXJuZWxUeXBlID0ga2VybmVsSW5mby5rZXJuZWxUeXBlO1xuICAgICAgICAgIGNvbnN0IGtlcm5lbE5hbWUgPSBrZXJuZWxJbmZvLmtlcm5lbE5hbWU7XG4gICAgICAgICAgY29uc3QgcHJvZ3JhbU5hbWUgPSBwZW5kaW5nS2VybmVsSW5mby5wcm9ncmFtTmFtZTtcbiAgICAgICAgICBjb25zdCBpbnB1dFRlbnNvclZpZXdzID0gcGVuZGluZ0tlcm5lbEluZm8uaW5wdXRUZW5zb3JWaWV3cztcbiAgICAgICAgICBjb25zdCBvdXRwdXRUZW5zb3JWaWV3cyA9IHBlbmRpbmdLZXJuZWxJbmZvLm91dHB1dFRlbnNvclZpZXdzO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZVU2NCA9IG1hcHBlZERhdGFbaSAqIDJdO1xuICAgICAgICAgIGNvbnN0IGVuZFRpbWVVNjQgPSBtYXBwZWREYXRhW2kgKiAyICsgMV07XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMucXVlcnlUaW1lQmFzZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMucXVlcnlUaW1lQmFzZSA9IHN0YXJ0VGltZVU2NDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBOdW1iZXIoc3RhcnRUaW1lVTY0IC0gdGhpcy5xdWVyeVRpbWVCYXNlKTtcbiAgICAgICAgICBjb25zdCBlbmRUaW1lID0gTnVtYmVyKGVuZFRpbWVVNjQgLSB0aGlzLnF1ZXJ5VGltZUJhc2UpO1xuXG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihzdGFydFRpbWUpIHx8ICFOdW1iZXIuaXNTYWZlSW50ZWdlcihlbmRUaW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luY29ycmVjdCB0aW1lc3RhbXAgcmFuZ2UnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5lbnYud2ViZ3B1LnByb2ZpbGluZz8ub25kYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmVudi53ZWJncHUucHJvZmlsaW5nLm9uZGF0YSh7XG4gICAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgICAgIGlucHV0c01ldGFkYXRhOiBpbnB1dFRlbnNvclZpZXdzLm1hcCgodmFsdWUpID0+ICh7XG4gICAgICAgICAgICAgICAgZGltczogdmFsdWUuZGltcyxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcodmFsdWUuZGF0YVR5cGUpLFxuICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgIG91dHB1dHNNZXRhZGF0YTogb3V0cHV0VGVuc29yVmlld3MubWFwKCh2YWx1ZSkgPT4gKHtcbiAgICAgICAgICAgICAgICBkaW1zOiB2YWx1ZS5kaW1zLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyh2YWx1ZS5kYXRhVHlwZSksXG4gICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAga2VybmVsSWQsXG4gICAgICAgICAgICAgIGtlcm5lbFR5cGUsXG4gICAgICAgICAgICAgIGtlcm5lbE5hbWUsXG4gICAgICAgICAgICAgIHByb2dyYW1OYW1lLFxuICAgICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICAgIGVuZFRpbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgbm8gY2FsbGJhY2sgaXMgcHJvdmlkZWQsIHByaW50IHRoZSBwcm9maWxpbmcgbWVzc2FnZSB0byBjb25zb2xlXG4gICAgICAgICAgICBsZXQgaW5wdXRTaGFwZXMgPSAnJztcbiAgICAgICAgICAgIGlucHV0VGVuc29yVmlld3MuZm9yRWFjaCgodmFsdWUsIGkpID0+IHtcbiAgICAgICAgICAgICAgaW5wdXRTaGFwZXMgKz0gYGlucHV0WyR7aX1dOiBbJHt2YWx1ZS5kaW1zfV0gfCAke3RlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nKHZhbHVlLmRhdGFUeXBlKX0sIGA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBvdXRwdXRTaGFwZXMgPSAnJztcbiAgICAgICAgICAgIG91dHB1dFRlbnNvclZpZXdzLmZvckVhY2goKHZhbHVlLCBpKSA9PiB7XG4gICAgICAgICAgICAgIG91dHB1dFNoYXBlcyArPSBgb3V0cHV0WyR7aX1dOiBbJHt2YWx1ZS5kaW1zfV0gfCAke3RlbnNvckRhdGFUeXBlRW51bVRvU3RyaW5nKHZhbHVlLmRhdGFUeXBlKX0sIGA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgYFtwcm9maWxpbmddIGtlcm5lbCBcIiR7a2VybmVsSWR9fCR7a2VybmVsVHlwZX18JHtrZXJuZWxOYW1lfXwke3Byb2dyYW1OYW1lfVwiICR7aW5wdXRTaGFwZXN9JHtcbiAgICAgICAgICAgICAgICBvdXRwdXRTaGFwZXNcbiAgICAgICAgICAgICAgfWV4ZWN1dGlvbiB0aW1lOiAke2VuZFRpbWUgLSBzdGFydFRpbWV9IG5zYCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFRSQUNFKCdHUFUnLCBgJHtwcm9ncmFtTmFtZX06OiR7c3RhcnRUaW1lVTY0fTo6JHtlbmRUaW1lVTY0fWApO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXJ5UmVhZEJ1ZmZlci51bm1hcCgpO1xuICAgICAgICB0aGlzLnBlbmRpbmdRdWVyaWVzLmRlbGV0ZShxdWVyeVJlYWRCdWZmZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIFRSQUNFX0ZVTkNfRU5EKCk7XG4gIH1cblxuICAvKipcbiAgICogcnVuIGEgV2ViR1BVIHByb2dyYW0uXG4gICAqIEBwYXJhbSBwcm9ncmFtIGEgUHJvZ3JhbUluZm8gaW5zdGFuY2VcbiAgICogQHBhcmFtIGlucHV0VGVuc29yVmlld3MgYSBUZW5zb3JWaWV3IGFycmF5LiBlYWNoIGVsZW1lbnQgcmVwcmVzZW50cyBhIHZhbHVlIGFscmVhZHkgZXhpc3RzIGluIEdQVS5cbiAgICogQHBhcmFtIG91dHB1dEluZGljZXMgYW4gaW5kaWNlcyBhcnJheS4gZWFjaCBlbGVtZW50IGNhbiBiZSBlaXRoZXIgLTEgKHRlbXBvcmFyeSBkYXRhKSwgLTIgKHBlcnNpc3RlbnQgZGF0YSkgb3IgYW5cbiAgICogaW5kZXggdG8gdGhlIGtlcm5lbCdzIG91dHB1dC5cbiAgICogQHBhcmFtIGNyZWF0ZUtlcm5lbE91dHB1dCBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgY3JlYXRlIGEgdmFsdWUgdG8ga2VybmVsJ3Mgb3V0cHV0IHdpdGggdGhlIGdpdmVuIGluZGV4XG4gICAqIEBwYXJhbSBjcmVhdGVJbnRlcm1lZGlhdGVPdXRwdXQgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGNyZWF0ZSBhIHZhbHVlIGFzIGEgaW50ZXJtZWRpYXRlIHZhbHVlLCBlaXRoZXIgdGVtcG9yYXJ5XG4gICAqIG9yIHBlcnNpc3RlbnQgKG93bmVkIGJ5IHRoZSBjdXJyZW50IGtlcm5lbClcbiAgICogQHJldHVybnMgYSBUZW5zb3JWaWV3IGFycmF5IHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICAgKi9cbiAgcnVuKFxuICAgIHByb2dyYW06IFByb2dyYW1JbmZvLFxuICAgIGlucHV0VGVuc29yVmlld3M6IHJlYWRvbmx5IFRlbnNvclZpZXdbXSxcbiAgICBvdXRwdXRJbmRpY2VzOiByZWFkb25seSBudW1iZXJbXSxcbiAgICBjcmVhdGVLZXJuZWxPdXRwdXQ6IChpbmRleDogbnVtYmVyLCBkYXRhVHlwZTogbnVtYmVyLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSkgPT4gVGVuc29yVmlldyxcbiAgICBjcmVhdGVJbnRlcm1lZGlhdGVPdXRwdXQ6IChkYXRhVHlwZTogbnVtYmVyLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSkgPT4gVGVuc29yVmlldyxcbiAgICBvdXRwdXRDb3VudDogbnVtYmVyLFxuICApOiBUZW5zb3JWaWV3W10ge1xuICAgIFRSQUNFX0ZVTkNfQkVHSU4ocHJvZ3JhbS5uYW1lKTtcbiAgICAvLyBjcmVhdGUgaW5mbyBmb3IgaW5wdXRzXG4gICAgY29uc3QgaW5wdXREYXRhczogR3B1RGF0YVtdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFRlbnNvclZpZXdzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBkYXRhID0gaW5wdXRUZW5zb3JWaWV3c1tpXS5kYXRhO1xuICAgICAgLy8gaWYgdGVuc29yIHZpZXcgZGF0YSBpcyAwLCBpdCBtZWFucyB0aGUgb3V0cHV0IGlzIHplcm8tc2l6ZWQgdGVuc29yLCBhbmQgdGhlcmUgaXMgbm8gR1BVIGRhdGEgZm9yIGl0LlxuICAgICAgaWYgKGRhdGEgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBncHVEYXRhID0gdGhpcy5ncHVEYXRhTWFuYWdlci5nZXQoZGF0YSk7XG4gICAgICBpZiAoIWdwdURhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3IgaW5wdXQ6ICR7ZGF0YX1gKTtcbiAgICAgIH1cbiAgICAgIGlucHV0RGF0YXMucHVzaChncHVEYXRhKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IG91dHB1dHMsIGRpc3BhdGNoR3JvdXAsIHByb2dyYW1Vbmlmb3JtcyB9ID0gcHJvZ3JhbS5nZXRSdW5EYXRhKGlucHV0VGVuc29yVmlld3MpO1xuXG4gICAgLy8gY2hlY2sgb3V0cHV0IGluZGljZXNcbiAgICBjb25zdCB2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzID0gb3V0cHV0SW5kaWNlcy5sZW5ndGggPT09IDAgPyBvdXRwdXRzLm1hcCgoXywgaSkgPT4gaSkgOiBvdXRwdXRJbmRpY2VzO1xuICAgIGlmICh2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzLmxlbmd0aCAhPT0gb3V0cHV0cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgT3V0cHV0IHNpemUgJHt2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzLmxlbmd0aH0gbXVzdCBiZSBlcXVhbCB0byAke291dHB1dHMubGVuZ3RofS5gKTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgaW5mbyBmb3Igb3V0cHV0c1xuICAgIGNvbnN0IG91dHB1dFRlbnNvclZpZXdzOiBUZW5zb3JWaWV3W10gPSBbXTtcbiAgICBjb25zdCBvdXRwdXREYXRhczogR3B1RGF0YVtdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAvLyB2YWx1ZSAtMSBhbmQgLTIgYXJlIHVzZWQgZm9yIGNyZWF0aW5nIHRlbXBvcmFyeSBhbmQgcGVyc2lzdGVudCBvdXRwdXRzLlxuICAgICAgLy8gdmFsdWUgLTMgaXMgdXNlZCBmb3IgcGxhY2Vob2xkZXIgb3V0cHV0LiBTbyAtMywgLTIsIC0xIGFuZCAwLCAxLCAyLCAuLi4gYXJlIHZhbGlkXG4gICAgICAvLyBvdXRwdXQgaW5kaWNlcy4gc2VlIHR5cGUgZGVmaW5pdGlvbiBvZiBDb21wdXRlQ29udGV4dElucHV0c091dHB1dHNNYXBwaW5nIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBpZiAoXG4gICAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKHZhbGlkYXRlZE91dHB1dEluZGljZXNbaV0pIHx8XG4gICAgICAgIHZhbGlkYXRlZE91dHB1dEluZGljZXNbaV0gPCAtMyB8fFxuICAgICAgICB2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzW2ldID49IG91dHB1dENvdW50XG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG91dHB1dCBpbmRleDogJHt2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzW2ldfWApO1xuICAgICAgfVxuICAgICAgaWYgKHZhbGlkYXRlZE91dHB1dEluZGljZXNbaV0gPT09IC0zKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNUZW1wb3JhcnkgPSB2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzW2ldID09PSAtMTtcbiAgICAgIGNvbnN0IGlzUGVyc2lzdGVudCA9IHZhbGlkYXRlZE91dHB1dEluZGljZXNbaV0gPT09IC0yO1xuICAgICAgY29uc3QgdGVuc29yVmlldyA9XG4gICAgICAgIGlzVGVtcG9yYXJ5IHx8IGlzUGVyc2lzdGVudFxuICAgICAgICAgID8gY3JlYXRlSW50ZXJtZWRpYXRlT3V0cHV0KG91dHB1dHNbaV0uZGF0YVR5cGUsIG91dHB1dHNbaV0uZGltcylcbiAgICAgICAgICA6IGNyZWF0ZUtlcm5lbE91dHB1dCh2YWxpZGF0ZWRPdXRwdXRJbmRpY2VzW2ldLCBvdXRwdXRzW2ldLmRhdGFUeXBlLCBvdXRwdXRzW2ldLmRpbXMpO1xuICAgICAgb3V0cHV0VGVuc29yVmlld3MucHVzaCh0ZW5zb3JWaWV3KTtcbiAgICAgIC8vIGlmIHRlbnNvciB2aWV3IGRhdGEgaXMgMCwgaXQgbWVhbnMgdGhlIG91dHB1dCBpcyB6ZXJvLXNpemVkIHRlbnNvciwgYW5kIHRoZXJlIGlzIG5vIEdQVSBkYXRhIGZvciBpdC5cbiAgICAgIGlmICh0ZW5zb3JWaWV3LmRhdGEgPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBncHVEYXRhID0gdGhpcy5ncHVEYXRhTWFuYWdlci5nZXQodGVuc29yVmlldy5kYXRhKTtcbiAgICAgIGlmICghZ3B1RGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBvdXRwdXQ6ICR7dGVuc29yVmlldy5kYXRhfWApO1xuICAgICAgfVxuICAgICAgaWYgKGlzVGVtcG9yYXJ5KSB7XG4gICAgICAgIHRoaXMudGVtcG9yYXJ5RGF0YS5wdXNoKGdwdURhdGEpO1xuICAgICAgfVxuICAgICAgaWYgKGlzUGVyc2lzdGVudCkge1xuICAgICAgICBsZXQgcGVyc2lzdGVudERhdGEgPSB0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmdldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCEpO1xuICAgICAgICBpZiAoIXBlcnNpc3RlbnREYXRhKSB7XG4gICAgICAgICAgcGVyc2lzdGVudERhdGEgPSBbXTtcbiAgICAgICAgICB0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLnNldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCEsIHBlcnNpc3RlbnREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBwZXJzaXN0ZW50RGF0YS5wdXNoKGdwdURhdGEpO1xuICAgICAgfVxuICAgICAgb3V0cHV0RGF0YXMucHVzaChncHVEYXRhKTtcbiAgICB9XG5cbiAgICAvLyB3aGVuIHRoZXJlIGFyZSBhbnkgemVyby1zaXplZCB0ZW5zb3IgaW4gdGhlIGlucHV0cyBvciBvdXRwdXRzLCB3ZSBzaG91bGQgcmVwb3J0IGVycm9yIHVubGVzcyBhbGwgb3V0cHV0cyBhcmVcbiAgICAvLyB6ZXJvLXNpemVkIHRlbnNvcnMuXG4gICAgaWYgKGlucHV0RGF0YXMubGVuZ3RoICE9PSBpbnB1dFRlbnNvclZpZXdzLmxlbmd0aCB8fCBvdXRwdXREYXRhcy5sZW5ndGggIT09IG91dHB1dFRlbnNvclZpZXdzLmxlbmd0aCkge1xuICAgICAgLy8gaWYgYWxsIG91dHB1dHMgYXJlIHplcm8tc2l6ZWQgdGVuc29ycywgdGhlcmUgaXMgbm8gbmVlZCB0byBydW4gdGhlIHByb2dyYW0uXG4gICAgICBpZiAob3V0cHV0RGF0YXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIFRSQUNFX0ZVTkNfRU5EKHByb2dyYW0ubmFtZSk7XG4gICAgICAgIHJldHVybiBvdXRwdXRUZW5zb3JWaWV3cztcbiAgICAgIH1cbiAgICAgIC8vIGlmIHNvbWUgb3V0cHV0cyBhcmUgemVyby1zaXplZCB0ZW5zb3JzLCByZXBvcnQgYW4gZXJyb3IuXG4gICAgICAvL1xuICAgICAgLy8gVE9ETzogc28gZmFyIHdlIGRvbid0IHNlZSBhbnkgdXNlIGNhc2UgdGhhdCBvdXRwdXRzIGluY2x1ZGUgYm90aCB6ZXJvLXNpemVkIHRlbnNvcnMgYW5kIG5vbi16ZXJvLXNpemVkIHRlbnNvcnMuXG4gICAgICAvLyBJZiB3ZSBzZWUgc3VjaCB1c2UgY2FzZSwgd2UgbmVlZCB0byBtYWtlIGEgY2hhbmdlIGhlcmUgdG8gc3VwcG9ydCBpdC5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFByb2dyYW0gJHtwcm9ncmFtLm5hbWV9IGhhcyB6ZXJvLXNpemVkIHRlbnNvcihzKSBpbiBpbnB1dHMgb3Igb3V0cHV0cy4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIG5vdy5gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBsb2FkIHVuaWZvcm1zXG4gICAgLy8gVE9ETzogYWRkIGNhY2hlIGZvciB1bmlmb3JtIChpcyBpdCBuZWNlc3Nhcnk/KVxuICAgIC8vXG4gICAgbGV0IHVuaWZvcm1CdWZmZXJCaW5kaW5nOiBHUFVCaW5kaW5nUmVzb3VyY2UgfCB1bmRlZmluZWQ7XG4gICAgaWYgKHByb2dyYW1Vbmlmb3Jtcykge1xuICAgICAgbGV0IGN1cnJlbnRPZmZzZXQgPSAwO1xuICAgICAgY29uc3Qgb2Zmc2V0czogbnVtYmVyW10gPSBbXTtcblxuICAgICAgcHJvZ3JhbVVuaWZvcm1zLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiB2LmRhdGEgPT09ICdudW1iZXInID8gW3YuZGF0YV0gOiB2LmRhdGE7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvV0dTTC8jYWxpZ25vZlxuICAgICAgICBjb25zdCBzaXplT2ZFbGVtZW50ID0gdi50eXBlID09PSBEYXRhVHlwZS5mbG9hdDE2ID8gMiA6IDQ7XG4gICAgICAgIGxldCBzaXplT2ZWZWNPck1hdDtcbiAgICAgICAgbGV0IGJhc2VBbGlnbm1lbnQ7XG4gICAgICAgIGlmICh2LnR5cGUgPT09IERhdGFUeXBlLmZsb2F0MTYpIHtcbiAgICAgICAgICBiYXNlQWxpZ25tZW50ID0gZGF0YS5sZW5ndGggPiA0ID8gMTYgOiBkYXRhLmxlbmd0aCA+IDIgPyA4IDogZGF0YS5sZW5ndGggKiBzaXplT2ZFbGVtZW50O1xuICAgICAgICAgIHNpemVPZlZlY09yTWF0ID0gZGF0YS5sZW5ndGggPiA0ID8gMTYgOiBzaXplT2ZFbGVtZW50ICogZGF0YS5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFzZUFsaWdubWVudCA9IGRhdGEubGVuZ3RoIDw9IDIgPyBkYXRhLmxlbmd0aCAqIHNpemVPZkVsZW1lbnQgOiAxNjtcbiAgICAgICAgICBzaXplT2ZWZWNPck1hdCA9IDE2O1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRPZmZzZXQgPSBNYXRoLmNlaWwoY3VycmVudE9mZnNldCAvIGJhc2VBbGlnbm1lbnQpICogYmFzZUFsaWdubWVudDtcbiAgICAgICAgb2Zmc2V0cy5wdXNoKGN1cnJlbnRPZmZzZXQpO1xuICAgICAgICAvLyBGb3Igbm9uLWZsb2F0MTYgdHlwZSwgd2hlbiBkYXRhLmxlbmd0aCA+IDQsIHRoZSB1bmlmb3JtIHZhcmlhYmxlIGlzIG9mIHR5cGUgYXJyYXk8dmVjNDxpMzJ8dTMyfGYzMj4sTj4sIHdoZXJlXG4gICAgICAgIC8vIE4gPSBNYXRoLmNlaWwoZGF0YS5sZW5ndGggLyA0KSBhbmQgU2l6ZU9mKHZlYzQ8aTMyfHUzMnxmMzI+KSA9IDE2LiBUaGUgdG90YWwgYnl0ZSBsZW5ndGggaXMgTiAqXG4gICAgICAgIC8vIFNpemVPZih2ZWM0PGkzMnx1MzJ8ZjMyPikuIEZvciBmbG9hdDE2IHR5cGUsIHdoZW4gZGF0YS5sZW5ndGggPiA0LCB0aGUgdW5pZm9ybSB2YXJpYWJsZSBpcyBvZiB0eXBlXG4gICAgICAgIC8vIGFycmF5PG1hdDJ4NDxmMTY+LE4+LCB3aGVyZSBOID0gTWF0aC5jZWlsKGRhdGEubGVuZ3RoIC8gOCkgYW5kIFNpemVPZihtYXQyeDQ8ZjE2PikgPSAxNi4gVGhlIHRvdGFsIGJ5dGVcbiAgICAgICAgLy8gbGVuZ3RoIGlzIE4gKiBTaXplT2YobWF0Mng0PGYxNj4pLlxuICAgICAgICBjb25zdCBlbGVtZW50UGVyVmVjT3JNYXQgPSB2LnR5cGUgPT09IERhdGFUeXBlLmZsb2F0MTYgPyA4IDogNDtcbiAgICAgICAgY3VycmVudE9mZnNldCArPVxuICAgICAgICAgIGRhdGEubGVuZ3RoID4gNCA/IE1hdGguY2VpbChkYXRhLmxlbmd0aCAvIGVsZW1lbnRQZXJWZWNPck1hdCkgKiBzaXplT2ZWZWNPck1hdCA6IGRhdGEubGVuZ3RoICogc2l6ZU9mRWxlbWVudDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNZWV0IGFsaWdubWVudCBvZiBzdHJ1Y3QgaGVyZTogaHR0cHM6Ly93d3cudzMub3JnL1RSL1dHU0wvI2FsaWdubWVudC1hbmQtc2l6ZS4gRm9yIHNpbXBsaWNpdHksIHNldFxuICAgICAgLy8gbWF4QWxpZ25tZW50T2ZGaWVsZCB0byAxNiBzaW5jZSB0aGUgdW5kZXJseWluZyBidWZmZXIgaGFzIGJlZW4gcm91bmRlZCB1cCB0byAxNi5cbiAgICAgIGNvbnN0IG1heEFsaWdubWVudE9mRmllbGQgPSAxNjtcbiAgICAgIGN1cnJlbnRPZmZzZXQgPSBNYXRoLmNlaWwoY3VycmVudE9mZnNldCAvIG1heEFsaWdubWVudE9mRmllbGQpICogbWF4QWxpZ25tZW50T2ZGaWVsZDtcbiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGN1cnJlbnRPZmZzZXQpO1xuICAgICAgcHJvZ3JhbVVuaWZvcm1zLmZvckVhY2goKHYsIGkpID0+IHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gb2Zmc2V0c1tpXTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiB2LmRhdGEgPT09ICdudW1iZXInID8gW3YuZGF0YV0gOiB2LmRhdGE7XG4gICAgICAgIGlmICh2LnR5cGUgPT09IERhdGFUeXBlLmludDMyKSB7XG4gICAgICAgICAgbmV3IEludDMyQXJyYXkoYXJyYXlCdWZmZXIsIG9mZnNldCwgZGF0YS5sZW5ndGgpLnNldChkYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmICh2LnR5cGUgPT09IERhdGFUeXBlLnVpbnQzMikge1xuICAgICAgICAgIG5ldyBVaW50MzJBcnJheShhcnJheUJ1ZmZlciwgb2Zmc2V0LCBkYXRhLmxlbmd0aCkuc2V0KGRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKHYudHlwZSA9PT0gRGF0YVR5cGUuZmxvYXQxNikge1xuICAgICAgICAgIG5ldyBVaW50MTZBcnJheShhcnJheUJ1ZmZlciwgb2Zmc2V0LCBkYXRhLmxlbmd0aCkuc2V0KGRhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKHYudHlwZSA9PT0gRGF0YVR5cGUuZmxvYXQpIHtcbiAgICAgICAgICBuZXcgRmxvYXQzMkFycmF5KGFycmF5QnVmZmVyLCBvZmZzZXQsIGRhdGEubGVuZ3RoKS5zZXQoZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB1bmlmb3JtIHR5cGU6ICR7dGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcodi50eXBlKX1gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHVuaWZvcm1CdWZmZXJEYXRhID1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgdGhpcy5ncHVEYXRhTWFuYWdlci5jcmVhdGUoY3VycmVudE9mZnNldCwgR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1QgfCBHUFVCdWZmZXJVc2FnZS5VTklGT1JNKTtcbiAgICAgIHRoaXMuZGV2aWNlLnF1ZXVlLndyaXRlQnVmZmVyKHVuaWZvcm1CdWZmZXJEYXRhLmJ1ZmZlciwgMCwgYXJyYXlCdWZmZXIsIDAsIGN1cnJlbnRPZmZzZXQpO1xuICAgICAgdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKHVuaWZvcm1CdWZmZXJEYXRhLmlkKTtcbiAgICAgIHVuaWZvcm1CdWZmZXJCaW5kaW5nID0geyBvZmZzZXQ6IDAsIHNpemU6IGN1cnJlbnRPZmZzZXQsIGJ1ZmZlcjogdW5pZm9ybUJ1ZmZlckRhdGEuYnVmZmVyIH07XG4gICAgfVxuXG4gICAgY29uc3Qgbm9ybWFsaXplZERpc3BhdGNoR3JvdXAgPSB0aGlzLnByb2dyYW1NYW5hZ2VyLm5vcm1hbGl6ZURpc3BhdGNoR3JvdXBTaXplKGRpc3BhdGNoR3JvdXApO1xuICAgIGNvbnN0IGlzMURpbWVuc2lvbkRpc3BhdGNoID0gbm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMV0gPT09IDEgJiYgbm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMl0gPT09IDE7XG4gICAgLy8gZ2V0IHByb2dyYW0gaW5mb1xuICAgIGNvbnN0IGtleSA9IGdldFByb2dyYW1JbmZvVW5pcXVlS2V5KHByb2dyYW0sIGlucHV0VGVuc29yVmlld3MsIGlzMURpbWVuc2lvbkRpc3BhdGNoKTtcbiAgICBsZXQgYXJ0aWZhY3QgPSB0aGlzLnByb2dyYW1NYW5hZ2VyLmdldEFydGlmYWN0KGtleSk7XG4gICAgaWYgKCFhcnRpZmFjdCkge1xuICAgICAgYXJ0aWZhY3QgPSB0aGlzLnByb2dyYW1NYW5hZ2VyLmJ1aWxkKHByb2dyYW0sIG5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwKTtcbiAgICAgIHRoaXMucHJvZ3JhbU1hbmFnZXIuc2V0QXJ0aWZhY3Qoa2V5LCBhcnRpZmFjdCk7XG4gICAgICBMT0dfREVCVUcoJ2luZm8nLCAoKSA9PiBgW2FydGlmYWN0XSBrZXk6ICR7a2V5fSwgcHJvZ3JhbU5hbWU6ICR7cHJvZ3JhbS5uYW1lfWApO1xuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIHVuaWZvcm0gdmFyaWFibGVzXG4gICAgaWYgKHByb2dyYW1Vbmlmb3JtcyAmJiBhcnRpZmFjdC51bmlmb3JtVmFyaWFibGVzSW5mbykge1xuICAgICAgaWYgKHByb2dyYW1Vbmlmb3Jtcy5sZW5ndGggIT09IGFydGlmYWN0LnVuaWZvcm1WYXJpYWJsZXNJbmZvLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFVuaWZvcm0gdmFyaWFibGVzIGNvdW50IG1pc21hdGNoOiBleHBlY3QgJHthcnRpZmFjdC51bmlmb3JtVmFyaWFibGVzSW5mby5sZW5ndGh9LCBnb3QgJHtcbiAgICAgICAgICAgIHByb2dyYW1Vbmlmb3Jtcy5sZW5ndGhcbiAgICAgICAgICB9IGluIHByb2dyYW0gXCIke2FydGlmYWN0LnByb2dyYW1JbmZvLm5hbWV9XCIuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvZ3JhbVVuaWZvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHVuaWZvcm0gPSBwcm9ncmFtVW5pZm9ybXNbaV07XG4gICAgICAgIGNvbnN0IGFjdHVhbFR5cGUgPSB1bmlmb3JtLnR5cGU7XG4gICAgICAgIGNvbnN0IGFjdHVhbExlbmd0aCA9IHR5cGVvZiB1bmlmb3JtLmRhdGEgPT09ICdudW1iZXInID8gMSA6IHVuaWZvcm0uZGF0YS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IFt0eXBlLCBsZW5ndGhdID0gYXJ0aWZhY3QudW5pZm9ybVZhcmlhYmxlc0luZm9baV07XG4gICAgICAgIGlmIChhY3R1YWxUeXBlICE9PSB0eXBlIHx8IGFjdHVhbExlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFVuaWZvcm0gdmFyaWFibGUgJHtpfSBtaXNtYXRjaDogZXhwZWN0IHR5cGUgJHt0eXBlfSB3aXRoIHNpemUgJHtsZW5ndGh9LCBnb3QgdHlwZSAke1xuICAgICAgICAgICAgICBhY3R1YWxUeXBlXG4gICAgICAgICAgICB9IHdpdGggc2l6ZSAke2FjdHVhbExlbmd0aH0gaW4gcHJvZ3JhbSBcIiR7YXJ0aWZhY3QucHJvZ3JhbUluZm8ubmFtZX1cIi5gLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBMT0dfREVCVUcoXG4gICAgICAnaW5mbycsXG4gICAgICAoKSA9PlxuICAgICAgICBgW1Byb2dyYW1NYW5hZ2VyXSBydW4gXCIke3Byb2dyYW0ubmFtZX1cIiAoa2V5PSR7a2V5fSkgd2l0aCAke25vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzBdfXgke1xuICAgICAgICAgIG5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzFdXG4gICAgICAgIH14JHtub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsyXX1gLFxuICAgICk7XG5cbiAgICBpZiAodGhpcy5xdWVyeVR5cGUgIT09ICdub25lJyB8fCB0aGlzLnNlc3Npb25TdGF0dXMgPT09ICdjYXB0dXJpbmcnKSB7XG4gICAgICBjb25zdCBwZW5kaW5nS2VybmVsSW5mbzogUGVuZGluZ0tlcm5lbEluZm8gPSB7XG4gICAgICAgIGtlcm5lbElkOiB0aGlzLmN1cnJlbnRLZXJuZWxJZCEsXG4gICAgICAgIHByb2dyYW1OYW1lOiBhcnRpZmFjdC5wcm9ncmFtSW5mby5uYW1lLFxuICAgICAgICBpbnB1dFRlbnNvclZpZXdzLFxuICAgICAgICBvdXRwdXRUZW5zb3JWaWV3cyxcbiAgICAgIH07XG4gICAgICB0aGlzLnBlbmRpbmdLZXJuZWxzLnB1c2gocGVuZGluZ0tlcm5lbEluZm8pO1xuXG4gICAgICBpZiAodGhpcy5zZXNzaW9uU3RhdHVzID09PSAnY2FwdHVyaW5nJykge1xuICAgICAgICBjb25zdCBzZXNzaW9uUGVuZGluZ0tlcm5lbHMgPSB0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCEpO1xuICAgICAgICBzZXNzaW9uUGVuZGluZ0tlcm5lbHMhLnB1c2gocGVuZGluZ0tlcm5lbEluZm8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucHJvZ3JhbU1hbmFnZXIucnVuKGFydGlmYWN0LCBpbnB1dERhdGFzLCBvdXRwdXREYXRhcywgbm9ybWFsaXplZERpc3BhdGNoR3JvdXAsIHVuaWZvcm1CdWZmZXJCaW5kaW5nKTtcblxuICAgIFRSQUNFX0ZVTkNfRU5EKHByb2dyYW0ubmFtZSk7XG4gICAgcmV0dXJuIG91dHB1dFRlbnNvclZpZXdzO1xuICB9XG5cbiAgdXBsb2FkKGdwdURhdGFJZDogbnVtYmVyLCBkYXRhOiBVaW50OEFycmF5KTogdm9pZCB7XG4gICAgdGhpcy5ncHVEYXRhTWFuYWdlci51cGxvYWQoZ3B1RGF0YUlkLCBkYXRhKTtcbiAgfVxuXG4gIG1lbWNweShzcmM6IG51bWJlciwgZHN0OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLm1lbWNweShzcmMsIGRzdCk7XG4gIH1cblxuICBhc3luYyBkb3dubG9hZChncHVEYXRhSWQ6IG51bWJlciwgZ2V0VGFyZ2V0QnVmZmVyOiAoKSA9PiBVaW50OEFycmF5KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gdGhlIHVuZGVybHlpbmcgYnVmZmVyIG1heSBiZSBjaGFuZ2VkIGFmdGVyIHRoZSBhc3luYyBmdW5jdGlvbiBpcyBjYWxsZWQuIHNvIHdlIHVzZSBhIGdldHRlciBmdW5jdGlvbiB0byBtYWtlIHN1cmVcbiAgICAvLyB0aGUgYnVmZmVyIGlzIHVwLXRvLWRhdGUuXG4gICAgYXdhaXQgdGhpcy5ncHVEYXRhTWFuYWdlci5kb3dubG9hZChncHVEYXRhSWQsIGdldFRhcmdldEJ1ZmZlcik7XG4gIH1cblxuICBhbGxvYyhzaXplOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZShzaXplKS5pZDtcbiAgfVxuXG4gIGZyZWUocHRyOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UocHRyKTtcbiAgfVxuXG4gIGNyZWF0ZUtlcm5lbChrZXJuZWxUeXBlOiBzdHJpbmcsIGtlcm5lbElkOiBudW1iZXIsIGF0dHJpYnV0ZTogdW5rbm93biwga2VybmVsTmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3Qgb3AgPSBXRUJHUFVfT1BfUkVTT0xWRV9SVUxFUy5nZXQoa2VybmVsVHlwZSk7XG4gICAgaWYgKCFvcCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBrZXJuZWwgbm90IGltcGxlbWVudGVkOiAke2tlcm5lbFR5cGV9YCk7XG4gICAgfVxuXG4gICAgY29uc3Qga2VybmVsSW5mbzogS2VybmVsSW5mbyA9IHtcbiAgICAgIGtlcm5lbFR5cGUsXG4gICAgICBrZXJuZWxOYW1lLFxuICAgICAga2VybmVsRW50cnk6IG9wWzBdLFxuICAgICAgYXR0cmlidXRlczogW29wWzFdLCBhdHRyaWJ1dGVdLFxuICAgIH07XG4gICAgdGhpcy5rZXJuZWxzLnNldChrZXJuZWxJZCwga2VybmVsSW5mbyk7XG4gIH1cblxuICByZWxlYXNlS2VybmVsKGtlcm5lbElkOiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBwZXJzaXN0ZW50RGF0YSA9IHRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZ2V0KGtlcm5lbElkKTtcbiAgICBpZiAocGVyc2lzdGVudERhdGEpIHtcbiAgICAgIGZvciAoY29uc3QgZGF0YSBvZiBwZXJzaXN0ZW50RGF0YSkge1xuICAgICAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoZGF0YS5pZCk7XG4gICAgICB9XG4gICAgICB0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmRlbGV0ZShrZXJuZWxJZCk7XG4gICAgfVxuXG4gICAgdGhpcy5rZXJuZWxDdXN0b21EYXRhLmRlbGV0ZShrZXJuZWxJZCk7XG4gICAgdGhpcy5rZXJuZWxzLmRlbGV0ZShrZXJuZWxJZCk7XG4gIH1cblxuICBjb21wdXRlS2VybmVsKGtlcm5lbElkOiBudW1iZXIsIGNvbnRleHQ6IENvbXB1dGVDb250ZXh0LCBlcnJvcnM6IEFycmF5PFByb21pc2U8c3RyaW5nIHwgbnVsbD4+KTogbnVtYmVyIHtcbiAgICBjb25zdCBrZXJuZWwgPSB0aGlzLmtlcm5lbHMuZ2V0KGtlcm5lbElkKTtcbiAgICBpZiAoIWtlcm5lbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBrZXJuZWwgbm90IGNyZWF0ZWQ6ICR7a2VybmVsSWR9YCk7XG4gICAgfVxuICAgIGNvbnN0IGtlcm5lbFR5cGUgPSBrZXJuZWwua2VybmVsVHlwZTtcbiAgICBjb25zdCBrZXJuZWxOYW1lID0ga2VybmVsLmtlcm5lbE5hbWU7XG4gICAgY29uc3Qga2VybmVsRW50cnkgPSBrZXJuZWwua2VybmVsRW50cnk7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IGtlcm5lbC5hdHRyaWJ1dGVzO1xuICAgIGlmICh0aGlzLmN1cnJlbnRLZXJuZWxJZCAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBrZXJuZWwgXCJbJHtrZXJuZWxUeXBlfV0gJHtrZXJuZWxOYW1lfVwiIGlzIG5vdCBhbGxvd2VkIHRvIGJlIGNhbGxlZCByZWN1cnNpdmVseWApO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRLZXJuZWxJZCA9IGtlcm5lbElkO1xuXG4gICAgLy8gcGFyc2UgYXR0cmlidXRlcyBpZiBuZWNlc3NhcnlcbiAgICBpZiAoYXR0cmlidXRlc1swXSkge1xuICAgICAgYXR0cmlidXRlc1sxXSA9IGF0dHJpYnV0ZXNbMF0oYXR0cmlidXRlc1sxXSk7XG4gICAgICBhdHRyaWJ1dGVzWzBdID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIExPR19ERUJVRygnaW5mbycsICgpID0+IGBbV2ViR1BVXSBTdGFydCB0byBydW4ga2VybmVsIFwiWyR7a2VybmVsVHlwZX1dICR7a2VybmVsTmFtZX1cIi4uLmApO1xuXG4gICAgY29uc3QgdXNlRXJyb3JTY29wZSA9IHRoaXMuZW52LmRlYnVnO1xuXG4gICAgdGhpcy50ZW1wb3JhcnlEYXRhID0gW107XG4gICAgdHJ5IHtcbiAgICAgIGlmICh1c2VFcnJvclNjb3BlKSB7XG4gICAgICAgIHRoaXMuZGV2aWNlLnB1c2hFcnJvclNjb3BlKCd2YWxpZGF0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIGtlcm5lbEVudHJ5KGNvbnRleHQsIGF0dHJpYnV0ZXNbMV0pO1xuICAgICAgcmV0dXJuIDA7IC8vIE9SVF9PS1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9ycy5wdXNoKFByb21pc2UucmVzb2x2ZShgW1dlYkdQVV0gS2VybmVsIFwiWyR7a2VybmVsVHlwZX1dICR7a2VybmVsTmFtZX1cIiBmYWlsZWQuICR7ZX1gKSk7XG4gICAgICByZXR1cm4gMTsgLy8gT1JUX0ZBSUxcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHVzZUVycm9yU2NvcGUpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgICAgdGhpcy5kZXZpY2VcbiAgICAgICAgICAgIC5wb3BFcnJvclNjb3BlKClcbiAgICAgICAgICAgIC50aGVuKChlcnIpID0+XG4gICAgICAgICAgICAgIGVyciA/IGBHUFUgdmFsaWRhdGlvbiBlcnJvciBmb3Iga2VybmVsIFwiWyR7a2VybmVsVHlwZX1dICR7a2VybmVsTmFtZX1cIjogJHtlcnIubWVzc2FnZX1gIDogbnVsbCxcbiAgICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgZGF0YSBvZiB0aGlzLnRlbXBvcmFyeURhdGEpIHtcbiAgICAgICAgdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKGRhdGEuaWQpO1xuICAgICAgfVxuICAgICAgdGhpcy50ZW1wb3JhcnlEYXRhID0gW107XG4gICAgICB0aGlzLmN1cnJlbnRLZXJuZWxJZCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gI3JlZ2lvbiBleHRlcm5hbCBidWZmZXJcbiAgcmVnaXN0ZXJCdWZmZXIoc2Vzc2lvbklkOiBudW1iZXIsIGluZGV4OiBudW1iZXIsIGJ1ZmZlcjogR1BVQnVmZmVyLCBzaXplOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGxldCBzZXNzaW9uSW5wdXRPdXRwdXRNYXBwaW5nID0gdGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5nZXQoc2Vzc2lvbklkKTtcbiAgICBpZiAoIXNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcpIHtcbiAgICAgIHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLnNldChzZXNzaW9uSWQsIHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcpO1xuICAgIH1cblxuICAgIGNvbnN0IHByZXZpb3VzQnVmZmVyID0gc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZy5nZXQoaW5kZXgpO1xuICAgIGNvbnN0IGlkID0gdGhpcy5ncHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKGJ1ZmZlciwgc2l6ZSwgcHJldmlvdXNCdWZmZXI/LlsxXSk7XG4gICAgc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZy5zZXQoaW5kZXgsIFtpZCwgYnVmZmVyXSk7XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIHVucmVnaXN0ZXJCdWZmZXJzKHNlc3Npb25JZDogbnVtYmVyKTogdm9pZCB7XG4gICAgY29uc3Qgc2Vzc2lvbklucHV0T3V0cHV0TWFwcGluZyA9IHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZ2V0KHNlc3Npb25JZCk7XG4gICAgaWYgKHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcpIHtcbiAgICAgIHNlc3Npb25JbnB1dE91dHB1dE1hcHBpbmcuZm9yRWFjaCgoYnVmZmVySW5mbykgPT4gdGhpcy5ncHVEYXRhTWFuYWdlci51bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoYnVmZmVySW5mb1sxXSkpO1xuICAgICAgdGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5kZWxldGUoc2Vzc2lvbklkKTtcbiAgICB9XG4gIH1cbiAgZ2V0QnVmZmVyKGdwdURhdGFJZDogbnVtYmVyKTogR1BVQnVmZmVyIHtcbiAgICBjb25zdCBncHVEYXRhID0gdGhpcy5ncHVEYXRhTWFuYWdlci5nZXQoZ3B1RGF0YUlkKTtcbiAgICBpZiAoIWdwdURhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIGJ1ZmZlcjogJHtncHVEYXRhSWR9YCk7XG4gICAgfVxuICAgIHJldHVybiBncHVEYXRhLmJ1ZmZlcjtcbiAgfVxuICBjcmVhdGVEb3dubG9hZGVyKFxuICAgIGdwdUJ1ZmZlcjogR1BVQnVmZmVyLFxuICAgIHNpemU6IG51bWJlcixcbiAgICB0eXBlOiBUZW5zb3IuR3B1QnVmZmVyRGF0YVR5cGVzLFxuICApOiAoKSA9PiBQcm9taXNlPFRlbnNvci5EYXRhVHlwZT4ge1xuICAgIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZG93bmxvYWRHcHVEYXRhKHRoaXMsIGdwdUJ1ZmZlciwgc2l6ZSk7XG4gICAgICByZXR1cm4gY3JlYXRlVmlldyhkYXRhLmJ1ZmZlciwgdHlwZSk7XG4gICAgfTtcbiAgfVxuICAvLyAjZW5kcmVnaW9uXG4gIHdyaXRlVGltZXN0YW1wKGluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5xdWVyeVR5cGUgIT09ICdpbnNpZGUtcGFzc2VzJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgKHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyIGFzIGFueSkud3JpdGVUaW1lc3RhbXAodGhpcy5xdWVyeVNldCwgaW5kZXgpO1xuICB9XG4gIHNldFF1ZXJ5VHlwZSgpOiB2b2lkIHtcbiAgICB0aGlzLnF1ZXJ5VHlwZSA9ICdub25lJztcbiAgICBpZiAoXG4gICAgICB0aGlzLmVudi53ZWJncHUucHJvZmlsaW5nPy5tb2RlID09PSAnZGVmYXVsdCcgfHxcbiAgICAgICh0eXBlb2YgdGhpcy5lbnYudHJhY2UgPT09ICd1bmRlZmluZWQnID8gdGhpcy5lbnYud2FzbS50cmFjZSA6IHRoaXMuZW52LnRyYWNlKVxuICAgICkge1xuICAgICAgaWYgKHRoaXMuZGV2aWNlLmZlYXR1cmVzLmhhcygnY2hyb21pdW0tZXhwZXJpbWVudGFsLXRpbWVzdGFtcC1xdWVyeS1pbnNpZGUtcGFzc2VzJykpIHtcbiAgICAgICAgdGhpcy5xdWVyeVR5cGUgPSAnaW5zaWRlLXBhc3Nlcyc7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZGV2aWNlLmZlYXR1cmVzLmhhcygndGltZXN0YW1wLXF1ZXJ5JykpIHtcbiAgICAgICAgdGhpcy5xdWVyeVR5cGUgPSAnYXQtcGFzc2VzJztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucXVlcnlUeXBlICE9PSAnbm9uZScgJiYgdHlwZW9mIHRoaXMucXVlcnlTZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMucXVlcnlTZXQgPSB0aGlzLmRldmljZS5jcmVhdGVRdWVyeVNldCh7XG4gICAgICAgICAgdHlwZTogJ3RpbWVzdGFtcCcsXG4gICAgICAgICAgY291bnQ6IHRoaXMubWF4RGlzcGF0Y2hOdW1iZXIgKiAyLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5xdWVyeVJlc29sdmVCdWZmZXIgPSB0aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICB7IHNpemU6IHRoaXMubWF4RGlzcGF0Y2hOdW1iZXIgKiAyICogOCwgdXNhZ2U6IEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDIHwgR1BVQnVmZmVyVXNhZ2UuUVVFUllfUkVTT0xWRSB9LFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNhcHR1cmVCZWdpbigpOiB2b2lkIHtcbiAgICBMT0dfREVCVUcoJ2luZm8nLCAnY2FwdHVyZUJlZ2luJyk7XG4gICAgaWYgKCF0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCEpKSB7XG4gICAgICB0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3Quc2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCEsIFtdKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCEpKSB7XG4gICAgICB0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuc2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCEsIFtdKTtcbiAgICB9XG4gICAgLy8gZmx1c2ggdGhlIGxlZnQgY29tbWFuZHMgYmVmb3JlIHdlIGNoYW5nZSB0aGUgc3RhdHVzLlxuICAgIHRoaXMuZmx1c2goKTtcbiAgICB0aGlzLnNlc3Npb25TdGF0dXMgPSAnY2FwdHVyaW5nJztcbiAgfVxuICBjYXB0dXJlRW5kKCk6IHZvaWQge1xuICAgIExPR19ERUJVRygnaW5mbycsICdjYXB0dXJlRW5kJyk7XG4gICAgLy8gZmx1c2ggdGhlIGxlZnQgY29tbWFuZHMgYmVmb3JlIHdlIGNoYW5nZSB0aGUgc3RhdHVzLlxuICAgIHRoaXMuZmx1c2goKTtcbiAgICB0aGlzLnNlc3Npb25TdGF0dXMgPSAnZGVmYXVsdCc7XG4gIH1cbiAgcmVwbGF5KCk6IHZvaWQge1xuICAgIExPR19ERUJVRygnaW5mbycsICdyZXBsYXknKTtcbiAgICB0aGlzLnNlc3Npb25TdGF0dXMgPSAncmVwbGF5aW5nJztcbiAgICBjb25zdCBzZXNzaW9uQ29tbWFuZExpc3QgPSB0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCEpO1xuICAgIGNvbnN0IHNlc3Npb25QZW5kaW5nS2VybmVscyA9IHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkISk7XG4gICAgY29uc3QgbGVuZ3RoID0gc2Vzc2lvbkNvbW1hbmRMaXN0IS5sZW5ndGg7XG4gICAgdGhpcy5wZW5kaW5nS2VybmVscyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvbXB1dGVQYXNzRW5jb2RlciA9IHRoaXMuZ2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCk7XG4gICAgICBjb25zdCBjb21tYW5kID0gc2Vzc2lvbkNvbW1hbmRMaXN0IVtpXTtcbiAgICAgIHRoaXMud3JpdGVUaW1lc3RhbXAodGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyKTtcbiAgICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5zZXRQaXBlbGluZShjb21tYW5kLmNvbXB1dGVQaXBlbGluZSk7XG4gICAgICBjb21wdXRlUGFzc0VuY29kZXIuc2V0QmluZEdyb3VwKDAsIGNvbW1hbmQuYmluZEdyb3VwKTtcbiAgICAgIGNvbXB1dGVQYXNzRW5jb2Rlci5kaXNwYXRjaFdvcmtncm91cHMoLi4uY29tbWFuZC5kaXNwYXRjaEdyb3VwKTtcbiAgICAgIHRoaXMud3JpdGVUaW1lc3RhbXAodGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIgKiAyICsgMSk7XG4gICAgICB0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcisrO1xuICAgICAgaWYgKHRoaXMucXVlcnlUeXBlICE9PSAnbm9uZScpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nS2VybmVscy5wdXNoKHNlc3Npb25QZW5kaW5nS2VybmVscyFbaV0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyID49IHRoaXMubWF4RGlzcGF0Y2hOdW1iZXIgfHwgdGhpcy5xdWVyeVR5cGUgPT09ICdhdC1wYXNzZXMnKSB7XG4gICAgICAgIHRoaXMuZW5kQ29tcHV0ZVBhc3MoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlciA+PSB0aGlzLm1heERpc3BhdGNoTnVtYmVyKSB7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZmx1c2ggdGhlIGxlZnQgY29tbWFuZHMgYmVmb3JlIHdlIGNoYW5nZSB0aGUgc3RhdHVzLlxuICAgIHRoaXMuZmx1c2goKTtcbiAgICB0aGlzLnNlc3Npb25TdGF0dXMgPSAnZGVmYXVsdCc7XG4gIH1cblxuICBvblJlbGVhc2VTZXNzaW9uKHNlc3Npb25JZDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy51bnJlZ2lzdGVyQnVmZmVycyhzZXNzaW9uSWQpO1xuICAgIGlmICh0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuaGFzKHNlc3Npb25JZCkpIHtcbiAgICAgIHRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5kZWxldGUoc2Vzc2lvbklkKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5oYXMoc2Vzc2lvbklkKSkge1xuICAgICAgdGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmRlbGV0ZShzZXNzaW9uSWQpO1xuICAgIH1cbiAgICB0aGlzLmdwdURhdGFNYW5hZ2VyLm9uUmVsZWFzZVNlc3Npb24oc2Vzc2lvbklkKTtcbiAgfVxuXG4gIG9uUnVuU3RhcnQoc2Vzc2lvbklkOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRTZXNzaW9uSWQgPSBzZXNzaW9uSWQ7XG4gICAgdGhpcy5zZXRRdWVyeVR5cGUoKTtcbiAgfVxufVxuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBFbnYgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgeyBjYWxjdWxhdGVUZW5zb3JTaXplSW5CeXRlcywgRGF0YVR5cGUgfSBmcm9tICcuLi93YXNtLWNvbW1vbic7XG5cbmltcG9ydCB0eXBlIHsgT3J0V2FzbU1vZHVsZSB9IGZyb20gJy4uL3dhc20tdHlwZXMnO1xuXG5pbXBvcnQgeyBXZWJHcHVCYWNrZW5kIH0gZnJvbSAnLi9iYWNrZW5kLXdlYmdwdSc7XG5pbXBvcnQgeyBMT0dfREVCVUcgfSBmcm9tICcuL2xvZyc7XG5pbXBvcnQgeyBUZW5zb3JWaWV3IH0gZnJvbSAnLi90ZW5zb3Itdmlldyc7XG5pbXBvcnQgeyBTaGFwZVV0aWwgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgQWRhcHRlckluZm8sIENvbXB1dGVDb250ZXh0LCBDb21wdXRlQ29udGV4dElucHV0c091dHB1dHNNYXBwaW5nLCBQcm9ncmFtSW5mbyB9IGZyb20gJy4vd2ViZ3B1L3R5cGVzJztcblxuLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuXG5jbGFzcyBUZW5zb3JWaWV3SW1wbCBpbXBsZW1lbnRzIFRlbnNvclZpZXcge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIG1vZHVsZTogT3J0V2FzbU1vZHVsZSxcbiAgICBwdWJsaWMgcmVhZG9ubHkgZGF0YVR5cGU6IG51bWJlcixcbiAgICBwdWJsaWMgcmVhZG9ubHkgZGF0YTogbnVtYmVyLFxuICAgIHB1YmxpYyByZWFkb25seSBkaW1zOiByZWFkb25seSBudW1iZXJbXSxcbiAgKSB7fVxuXG4gIGdldEZsb2F0MzJBcnJheSgpOiBGbG9hdDMyQXJyYXkge1xuICAgIGlmICh0aGlzLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5mbG9hdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRhdGEgdHlwZScpO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50Q291bnQgPSBTaGFwZVV0aWwuc2l6ZSh0aGlzLmRpbXMpO1xuICAgIHJldHVybiBlbGVtZW50Q291bnQgPT09IDBcbiAgICAgID8gbmV3IEZsb2F0MzJBcnJheSgpXG4gICAgICA6IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLCB0aGlzLmRhdGEsIGVsZW1lbnRDb3VudCk7XG4gIH1cblxuICBnZXRCaWdJbnQ2NEFycmF5KCk6IEJpZ0ludDY0QXJyYXkge1xuICAgIGlmICh0aGlzLmRhdGFUeXBlICE9PSBEYXRhVHlwZS5pbnQ2NCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRhdGEgdHlwZScpO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50Q291bnQgPSBTaGFwZVV0aWwuc2l6ZSh0aGlzLmRpbXMpO1xuICAgIHJldHVybiBlbGVtZW50Q291bnQgPT09IDBcbiAgICAgID8gbmV3IEJpZ0ludDY0QXJyYXkoKVxuICAgICAgOiBuZXcgQmlnSW50NjRBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsIHRoaXMuZGF0YSwgZWxlbWVudENvdW50KTtcbiAgfVxuXG4gIGdldEludDMyQXJyYXkoKTogSW50MzJBcnJheSB7XG4gICAgaWYgKHRoaXMuZGF0YVR5cGUgIT09IERhdGFUeXBlLmludDMyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGF0YSB0eXBlJyk7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRDb3VudCA9IFNoYXBlVXRpbC5zaXplKHRoaXMuZGltcyk7XG4gICAgcmV0dXJuIGVsZW1lbnRDb3VudCA9PT0gMCA/IG5ldyBJbnQzMkFycmF5KCkgOiBuZXcgSW50MzJBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsIHRoaXMuZGF0YSwgZWxlbWVudENvdW50KTtcbiAgfVxuXG4gIGdldFVpbnQxNkFycmF5KCk6IFVpbnQxNkFycmF5IHtcbiAgICBpZiAodGhpcy5kYXRhVHlwZSAhPT0gRGF0YVR5cGUuZmxvYXQxNiAmJiB0aGlzLmRhdGFUeXBlICE9PSBEYXRhVHlwZS51aW50MTYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIHR5cGUnKTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudENvdW50ID0gU2hhcGVVdGlsLnNpemUodGhpcy5kaW1zKTtcbiAgICByZXR1cm4gZWxlbWVudENvdW50ID09PSAwID8gbmV3IFVpbnQxNkFycmF5KCkgOiBuZXcgVWludDE2QXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLCB0aGlzLmRhdGEsIGVsZW1lbnRDb3VudCk7XG4gIH1cblxuICByZXNoYXBlKG5ld0RpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29yVmlldyB7XG4gICAgaWYgKFNoYXBlVXRpbC5zaXplKG5ld0RpbXMpICE9PSBTaGFwZVV0aWwuc2l6ZSh0aGlzLmRpbXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbmV3IHNoYXBlJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGVuc29yVmlld0ltcGwodGhpcy5tb2R1bGUsIHRoaXMuZGF0YVR5cGUsIHRoaXMuZGF0YSwgbmV3RGltcyk7XG4gIH1cbn1cblxuY2xhc3MgQ29tcHV0ZUNvbnRleHRJbXBsIGltcGxlbWVudHMgQ29tcHV0ZUNvbnRleHQge1xuICByZWFkb25seSBhZGFwdGVySW5mbzogQWRhcHRlckluZm87XG4gIHJlYWRvbmx5IG9wS2VybmVsQ29udGV4dDogbnVtYmVyO1xuICByZWFkb25seSBpbnB1dHM6IHJlYWRvbmx5IFRlbnNvclZpZXdbXTtcbiAgcmVhZG9ubHkgb3V0cHV0Q291bnQ6IG51bWJlcjtcbiAgZ2V0IGtlcm5lbEN1c3RvbURhdGEoKTogeyBba2V5OiBzdHJpbmddOiB1bmtub3duIH0ge1xuICAgIHJldHVybiB0aGlzLmJhY2tlbmQuY3VycmVudEtlcm5lbEN1c3RvbURhdGE7XG4gIH1cbiAgZ2V0IGN1c3RvbURhdGFCdWZmZXIoKTogVWludDhBcnJheSB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlLkhFQVBVOC5zdWJhcnJheSh0aGlzLmN1c3RvbURhdGFPZmZzZXQsIHRoaXMuY3VzdG9tRGF0YU9mZnNldCArIHRoaXMuY3VzdG9tRGF0YVNpemUpO1xuICB9XG4gIHByaXZhdGUgY3VzdG9tRGF0YU9mZnNldCA9IDA7XG4gIHByaXZhdGUgY3VzdG9tRGF0YVNpemUgPSAwO1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIG1vZHVsZTogT3J0V2FzbU1vZHVsZSxcbiAgICBwcml2YXRlIGJhY2tlbmQ6IFdlYkdwdUJhY2tlbmQsXG4gICAgY29udGV4dERhdGFPZmZzZXQ6IG51bWJlcixcbiAgKSB7XG4gICAgdGhpcy5hZGFwdGVySW5mbyA9IGJhY2tlbmQuYWRhcHRlckluZm87XG4gICAgY29uc3QgaGVhcFUzMiA9IG1vZHVsZS5IRUFQVTMyO1xuXG4gICAgLy8gZXh0cmFjdCBjb250ZXh0IGRhdGFcbiAgICBsZXQgZGF0YUluZGV4ID0gY29udGV4dERhdGFPZmZzZXQgPj4+IDI7XG4gICAgdGhpcy5vcEtlcm5lbENvbnRleHQgPSBoZWFwVTMyW2RhdGFJbmRleCsrXTtcbiAgICBjb25zdCBpbnB1dENvdW50ID0gaGVhcFUzMltkYXRhSW5kZXgrK107XG4gICAgdGhpcy5vdXRwdXRDb3VudCA9IGhlYXBVMzJbZGF0YUluZGV4KytdO1xuICAgIHRoaXMuY3VzdG9tRGF0YU9mZnNldCA9IGhlYXBVMzJbZGF0YUluZGV4KytdO1xuICAgIHRoaXMuY3VzdG9tRGF0YVNpemUgPSBoZWFwVTMyW2RhdGFJbmRleCsrXTtcblxuICAgIGNvbnN0IGlucHV0czogVGVuc29yVmlld1tdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGRhdGFUeXBlID0gaGVhcFUzMltkYXRhSW5kZXgrK107XG4gICAgICBjb25zdCBkYXRhID0gaGVhcFUzMltkYXRhSW5kZXgrK107XG4gICAgICBjb25zdCBkaW0gPSBoZWFwVTMyW2RhdGFJbmRleCsrXTtcbiAgICAgIGNvbnN0IGRpbXM6IG51bWJlcltdID0gW107XG4gICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRpbTsgZCsrKSB7XG4gICAgICAgIGRpbXMucHVzaChoZWFwVTMyW2RhdGFJbmRleCsrXSk7XG4gICAgICB9XG4gICAgICBpbnB1dHMucHVzaChuZXcgVGVuc29yVmlld0ltcGwobW9kdWxlLCBkYXRhVHlwZSwgZGF0YSwgZGltcykpO1xuICAgIH1cbiAgICB0aGlzLmlucHV0cyA9IGlucHV0cztcbiAgfVxuXG4gIGdldE1heENvbXB1dGVXb3JrZ3JvdXBTaXplcygpOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0ge1xuICAgIHJldHVybiBbXG4gICAgICB0aGlzLmJhY2tlbmQuZGV2aWNlLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVgsXG4gICAgICB0aGlzLmJhY2tlbmQuZGV2aWNlLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVksXG4gICAgICB0aGlzLmJhY2tlbmQuZGV2aWNlLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVosXG4gICAgXTtcbiAgfVxuXG4gIGdldE1heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlc2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmJhY2tlbmQuZGV2aWNlLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemU7XG4gIH1cblxuICBjb21wdXRlKHByb2dyYW06IFByb2dyYW1JbmZvLCBpbnB1dHNPdXRwdXRzTWFwcGluZz86IENvbXB1dGVDb250ZXh0SW5wdXRzT3V0cHV0c01hcHBpbmcpOiBUZW5zb3JWaWV3W10ge1xuICAgIC8vIHByZXBhcmUgaW5wdXRzLiBpbnB1dHMgc2hvdWxkIGFsd2F5cyBiZSB2YWxpZCBkYXRhLlxuICAgIGNvbnN0IG1hcHBlZElucHV0cyA9XG4gICAgICBpbnB1dHNPdXRwdXRzTWFwcGluZz8uaW5wdXRzPy5tYXAoKGkpID0+ICh0eXBlb2YgaSA9PT0gJ251bWJlcicgPyB0aGlzLmlucHV0c1tpXSA6IGkpKSA/PyB0aGlzLmlucHV0cztcbiAgICAvLyBwcmVwYXJlIG91dHB1dHMuXG4gICAgY29uc3Qgb3V0cHV0SW5kaWNlcyA9IGlucHV0c091dHB1dHNNYXBwaW5nPy5vdXRwdXRzID8/IFtdO1xuICAgIGNvbnN0IGNyZWF0ZUtlcm5lbE91dHB1dCA9IChpbmRleDogbnVtYmVyLCBkYXRhVHlwZTogbnVtYmVyLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IFRlbnNvclZpZXcgPT5cbiAgICAgIG5ldyBUZW5zb3JWaWV3SW1wbCh0aGlzLm1vZHVsZSwgZGF0YVR5cGUsIHRoaXMub3V0cHV0KGluZGV4LCBkaW1zKSwgZGltcyk7XG4gICAgY29uc3QgY3JlYXRlVGVtcG9yYXJ5T3V0cHV0ID0gKGRhdGFUeXBlOiBudW1iZXIsIGRpbXM6IHJlYWRvbmx5IG51bWJlcltdKTogVGVuc29yVmlldyA9PiB7XG4gICAgICBjb25zdCBidWZmZXJTaXplID0gY2FsY3VsYXRlVGVuc29yU2l6ZUluQnl0ZXMoZGF0YVR5cGUsIGRpbXMpO1xuICAgICAgaWYgKCFidWZmZXJTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2RhdGFUeXBlfWApO1xuICAgICAgfVxuICAgICAgY29uc3QgZ3B1RGF0YUlkID0gYnVmZmVyU2l6ZSA+IDAgPyB0aGlzLmJhY2tlbmQuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKGJ1ZmZlclNpemUpLmlkIDogMDtcbiAgICAgIHJldHVybiBuZXcgVGVuc29yVmlld0ltcGwodGhpcy5tb2R1bGUsIGRhdGFUeXBlLCBncHVEYXRhSWQsIGRpbXMpO1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuYmFja2VuZC5ydW4oXG4gICAgICBwcm9ncmFtLFxuICAgICAgbWFwcGVkSW5wdXRzLFxuICAgICAgb3V0cHV0SW5kaWNlcyxcbiAgICAgIGNyZWF0ZUtlcm5lbE91dHB1dCxcbiAgICAgIGNyZWF0ZVRlbXBvcmFyeU91dHB1dCxcbiAgICAgIHRoaXMub3V0cHV0Q291bnQsXG4gICAgKTtcbiAgfVxuXG4gIG91dHB1dChpbmRleDogbnVtYmVyLCBkaW1zOiByZWFkb25seSBudW1iZXJbXSk6IG51bWJlciB7XG4gICAgY29uc3Qgc3RhY2sgPSB0aGlzLm1vZHVsZS5zdGFja1NhdmUoKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IHRoaXMubW9kdWxlLnN0YWNrQWxsb2MoKDEgKyBkaW1zLmxlbmd0aCkgKiA0IC8qIHNpemVvZihzaXplX3QpICovKTtcbiAgICAgIGxldCBvZmZzZXQgPSBkYXRhID4+IDI7XG4gICAgICB0aGlzLm1vZHVsZS5IRUFQVTMyW29mZnNldCsrXSA9IGRpbXMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMubW9kdWxlLkhFQVBVMzJbb2Zmc2V0KytdID0gZGltc1tpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1vZHVsZS5fSnNlcE91dHB1dCEodGhpcy5vcEtlcm5lbENvbnRleHQsIGluZGV4LCBkYXRhKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gZ2VuZXJhdGUga2VybmVsJ3Mgb3V0cHV0WyR7aW5kZXh9XSB3aXRoIGRpbXMgWyR7ZGltc31dLiBgICtcbiAgICAgICAgICAnSWYgeW91IGFyZSBydW5uaW5nIHdpdGggcHJlLWFsbG9jYXRlZCBvdXRwdXQsIHBsZWFzZSBtYWtlIHN1cmUgdGhlIG91dHB1dCB0eXBlL2RpbXMgYXJlIGNvcnJlY3QuICcgK1xuICAgICAgICAgIGBFcnJvcjogJHtlfWAsXG4gICAgICApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLm1vZHVsZS5zdGFja1Jlc3RvcmUoc3RhY2spO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEluaXRpYWxpemUgSlNFUCB3aXRoIFdlYkdQVSBiYWNrZW5kLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIFdlYkFzc2VtYmx5IG1vZHVsZSBpcyBsb2FkZWQgYW5kIGluaXRpYWxpemVkIChcIl9PcnRJbml0XCIgaXMgY2FsbGVkKSwgb25jZSBmb3JcbiAqIGVhY2ggb2YgdGhlIGZvbGxvd2luZyBFUHMgaWYgdGhleSBhcmUgc3BlY2lmaWVkOlxuICogLSBcIndlYmdwdVwiXG4gKiAtIFwid2Vibm5cIlxuICpcbiAqIEZvciBXZWJHUFUsIHRoaXMgZnVuY3Rpb24gZXhwZWN0czpcbiAqICAtIFdlYkdQVSBpcyBlbmFibGVkIGluIGJ1aWxkIChCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCA9PT0gZmFsc2UpLlxuICogIC0gV2ViR1BVIGlzIGF2YWlsYWJsZSBpbiBjdXJyZW50IGVudmlyb25tZW50LiAoYSB2YWxpZCBHUFVBZGFwdGVyIGlzIHBhc3NlZCBpbilcbiAqXG4gKiBGb3IgV2ViTk4sIHRoaXMgZnVuY3Rpb24gZXhwZWN0czpcbiAqIC0gV2ViTk4gaXMgZW5hYmxlZCBpbiBidWlsZCAoQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgPT09IGZhbHNlKS5cbiAqIC0gV2ViTk4gaXMgYXZhaWxhYmxlIGluIGN1cnJlbnQgZW52aXJvbm1lbnQuIChuYXZpZ2F0b3IubWwgaXMgbm90IHVuZGVmaW5lZClcbiAqXG4gKiBJZiB0aGUgV2ViQXNzZW1ibHkgbW9kdWxlIGlzIG5vdCBidWlsdCB3aXRoIEpTRVAgc3VwcG9ydCwgdGhpcyBmdW5jdGlvbiB3aWxsIHRocm93IGFuIGVycm9yLiBUaGlzIHdpbGwgaW52YWxpZGF0ZVxuICogJ3dlYmdwdScvJ3dlYm5uJyBiYWNrZW5kLlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIEVQLCBlaXRoZXIgXCJ3ZWJncHVcIiBvciBcIndlYm5uXCJcbiAqIEBwYXJhbSBtb2R1bGUgLSB0aGUgT1JUIFdlYkFzc2VtYmx5IG1vZHVsZVxuICogQHBhcmFtIGVudiAtIHRoZSBPUlQgZW52aXJvbm1lbnQgdmFyaWFibGUgKG9ydC5lbnYpXG4gKiBAcGFyYW0gZ3B1QWRhcHRlciAtIHRoZSBwcmUtY3JlYXRlZCBHUFUgYWRhcHRlclxuICovXG5leHBvcnQgY29uc3QgaW5pdCA9IGFzeW5jIChcbiAgbmFtZTogJ3dlYmdwdScgfCAnd2Vibm4nLFxuICBtb2R1bGU6IE9ydFdhc21Nb2R1bGUsXG4gIGVudjogRW52LFxuICBncHVBZGFwdGVyPzogR1BVQWRhcHRlcixcbik6IFByb21pc2U8dm9pZD4gPT4ge1xuICBjb25zdCBqc2VwSW5pdCA9IG1vZHVsZS5qc2VwSW5pdDtcbiAgaWYgKCFqc2VwSW5pdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgSlNFUC4gVGhlIFdlYkFzc2VtYmx5IG1vZHVsZSBpcyBub3QgYnVpbHQgd2l0aCBKU0VQIHN1cHBvcnQuJyk7XG4gIH1cblxuICBpZiAobmFtZSA9PT0gJ3dlYmdwdScpIHtcbiAgICBjb25zdCBiYWNrZW5kID0gbmV3IFdlYkdwdUJhY2tlbmQoKTtcbiAgICBhd2FpdCBiYWNrZW5kLmluaXRpYWxpemUoZW52LCBncHVBZGFwdGVyISk7XG5cbiAgICBqc2VwSW5pdCgnd2ViZ3B1JywgW1xuICAgICAgLy8gYmFja2VuZFxuICAgICAgYmFja2VuZCxcblxuICAgICAgLy8ganNlcEFsbG9jKClcbiAgICAgIChzaXplOiBudW1iZXIpID0+IGJhY2tlbmQuYWxsb2Moc2l6ZSksXG5cbiAgICAgIC8vIGpzZXBGcmVlKClcbiAgICAgIChwdHI6IG51bWJlcikgPT4gYmFja2VuZC5mcmVlKHB0ciksXG5cbiAgICAgIC8vIGpzZXBDb3B5KHNyYywgZHN0LCBzaXplLCBpc1NvdXJjZUdwdSlcbiAgICAgIChzcmM6IG51bWJlciwgZHN0OiBudW1iZXIsIHNpemU6IG51bWJlciwgaXNTb3VyY2VHcHUgPSBmYWxzZSkgPT4ge1xuICAgICAgICBpZiAoaXNTb3VyY2VHcHUpIHtcbiAgICAgICAgICBMT0dfREVCVUcoJ3ZlcmJvc2UnLCAoKSA9PiBgW1dlYkdQVV0ganNlcENvcHlHcHVUb0dwdTogc3JjPSR7c3JjfSwgZHN0PSR7ZHN0fSwgc2l6ZT0ke3NpemV9YCk7XG4gICAgICAgICAgYmFja2VuZC5tZW1jcHkoc3JjLCBkc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIExPR19ERUJVRygndmVyYm9zZScsICgpID0+IGBbV2ViR1BVXSBqc2VwQ29weUNwdVRvR3B1OiBkYXRhT2Zmc2V0PSR7c3JjfSwgZ3B1RGF0YUlkPSR7ZHN0fSwgc2l6ZT0ke3NpemV9YCk7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IG1vZHVsZS5IRUFQVTguc3ViYXJyYXkoc3JjID4+PiAwLCAoc3JjID4+PiAwKSArIHNpemUpO1xuICAgICAgICAgIGJhY2tlbmQudXBsb2FkKGRzdCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8vIGpzZXBDb3B5QXN5bmMoc3JjLCBkc3QsIHNpemUpXG4gICAgICBhc3luYyAoZ3B1RGF0YUlkOiBudW1iZXIsIGRhdGFPZmZzZXQ6IG51bWJlciwgc2l6ZTogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgICAgIExPR19ERUJVRyhcbiAgICAgICAgICAndmVyYm9zZScsXG4gICAgICAgICAgKCkgPT4gYFtXZWJHUFVdIGpzZXBDb3B5R3B1VG9DcHU6IGdwdURhdGFJZD0ke2dwdURhdGFJZH0sIGRhdGFPZmZzZXQ9JHtkYXRhT2Zmc2V0fSwgc2l6ZT0ke3NpemV9YCxcbiAgICAgICAgKTtcblxuICAgICAgICBhd2FpdCBiYWNrZW5kLmRvd25sb2FkKGdwdURhdGFJZCwgKCkgPT4gbW9kdWxlLkhFQVBVOC5zdWJhcnJheShkYXRhT2Zmc2V0ID4+PiAwLCAoZGF0YU9mZnNldCA+Pj4gMCkgKyBzaXplKSk7XG4gICAgICB9LFxuXG4gICAgICAvLyBqc2VwQ3JlYXRlS2VybmVsXG4gICAgICAoa2VybmVsVHlwZTogc3RyaW5nLCBrZXJuZWxJZDogbnVtYmVyLCBhdHRyaWJ1dGU6IHVua25vd24pID0+XG4gICAgICAgIGJhY2tlbmQuY3JlYXRlS2VybmVsKGtlcm5lbFR5cGUsIGtlcm5lbElkLCBhdHRyaWJ1dGUsIG1vZHVsZS5VVEY4VG9TdHJpbmcobW9kdWxlLl9Kc2VwR2V0Tm9kZU5hbWUhKGtlcm5lbElkKSkpLFxuXG4gICAgICAvLyBqc2VwUmVsZWFzZUtlcm5lbFxuICAgICAgKGtlcm5lbDogbnVtYmVyKSA9PiBiYWNrZW5kLnJlbGVhc2VLZXJuZWwoa2VybmVsKSxcblxuICAgICAgLy8ganNlcFJ1blxuICAgICAgKGtlcm5lbDogbnVtYmVyLCBjb250ZXh0RGF0YU9mZnNldDogbnVtYmVyLCBzZXNzaW9uSGFuZGxlOiBudW1iZXIsIGVycm9yczogQXJyYXk8UHJvbWlzZTxzdHJpbmcgfCBudWxsPj4pID0+IHtcbiAgICAgICAgTE9HX0RFQlVHKFxuICAgICAgICAgICd2ZXJib3NlJyxcbiAgICAgICAgICAoKSA9PlxuICAgICAgICAgICAgYFtXZWJHUFVdIGpzZXBSdW46IHNlc3Npb25IYW5kbGU9JHtzZXNzaW9uSGFuZGxlfSwga2VybmVsPSR7a2VybmVsfSwgY29udGV4dERhdGFPZmZzZXQ9JHtjb250ZXh0RGF0YU9mZnNldH1gLFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gbmV3IENvbXB1dGVDb250ZXh0SW1wbChtb2R1bGUsIGJhY2tlbmQsIGNvbnRleHREYXRhT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIGJhY2tlbmQuY29tcHV0ZUtlcm5lbChrZXJuZWwsIGNvbnRleHQsIGVycm9ycyk7XG4gICAgICB9LFxuICAgICAgLy8ganNlcENhcHR1cmVCZWdpblxuICAgICAgKCkgPT4gYmFja2VuZC5jYXB0dXJlQmVnaW4oKSxcbiAgICAgIC8vIGpzZXBDYXB0dXJlRW5kXG4gICAgICAoKSA9PiBiYWNrZW5kLmNhcHR1cmVFbmQoKSxcbiAgICAgIC8vIGpzZXBSZXBsYXlcbiAgICAgICgpID0+IGJhY2tlbmQucmVwbGF5KCksXG4gICAgXSk7XG4gIH0gZWxzZSB7XG4gICAganNlcEluaXQoJ3dlYm5uJyk7XG4gIH1cbn07XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbi8vIFdlYk5OIEFQSSBjdXJyZW50bHkgZG9lcyBub3QgaGF2ZSBhIFR5cGVTY3JpcHQgZGVmaW5pdGlvbiBmaWxlLiBUaGlzIGZpbGUgaXMgYSB3b3JrYXJvdW5kIHdpdGggdHlwZXMgZ2VuZXJhdGVkIGZyb21cbi8vIFdlYk5OIEFQSSBzcGVjaWZpY2F0aW9uLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYm1hY2hpbmVsZWFybmluZy93ZWJubi9pc3N1ZXMvNjc3XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwianNlcC93ZWJubi93ZWJubi5kLnRzXCIgLz5cblxuaW1wb3J0IHsgRW52LCBJbmZlcmVuY2VTZXNzaW9uLCBUZW5zb3IgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQge1xuICBTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlcixcbiAgU2VyaWFsaXphYmxlU2Vzc2lvbk1ldGFkYXRhLFxuICBTZXJpYWxpemFibGVUZW5zb3JNZXRhZGF0YSxcbiAgVGVuc29yTWV0YWRhdGEsXG59IGZyb20gJy4vcHJveHktbWVzc2FnZXMnO1xuaW1wb3J0IHsgc2V0UnVuT3B0aW9ucyB9IGZyb20gJy4vcnVuLW9wdGlvbnMnO1xuaW1wb3J0IHsgc2V0U2Vzc2lvbk9wdGlvbnMgfSBmcm9tICcuL3Nlc3Npb24tb3B0aW9ucyc7XG5pbXBvcnQge1xuICBjYWxjdWxhdGVUZW5zb3JTaXplSW5CeXRlcyxcbiAgZGF0YUxvY2F0aW9uU3RyaW5nVG9FbnVtLFxuICBpc0dwdUJ1ZmZlclN1cHBvcnRlZFR5cGUsXG4gIGxvZ0xldmVsU3RyaW5nVG9FbnVtLFxuICB0ZW5zb3JEYXRhVHlwZUVudW1Ub1N0cmluZyxcbiAgdGVuc29yRGF0YVR5cGVTdHJpbmdUb0VudW0sXG4gIHRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3Rvcixcbn0gZnJvbSAnLi93YXNtLWNvbW1vbic7XG5pbXBvcnQgeyBnZXRJbnN0YW5jZSB9IGZyb20gJy4vd2FzbS1mYWN0b3J5JztcbmltcG9ydCB7IGFsbG9jV2FzbVN0cmluZywgY2hlY2tMYXN0RXJyb3IgfSBmcm9tICcuL3dhc20tdXRpbHMnO1xuaW1wb3J0IHsgbG9hZEZpbGUgfSBmcm9tICcuL3dhc20tdXRpbHMtbG9hZC1maWxlJztcblxuLy8gI3JlZ2lvbiBJbml0aWFsaXphdGlvbnNcblxuLyoqXG4gKiBUaGVyZSBhcmUgNCBkaWZmZXJlbnQgXCJpbml0aWFsaXphdGlvblwiIHN0ZXBzIGZvciBPUlQuIFRoZXkgaGFwcGVuIGluIGRpZmZlcmVudCBwbGFjZXMgYW5kIGRpZmZlcmVudCB0aW1lLlxuICpcbiAqIDEuIEphdmFTY3JpcHQgaW5pdGlhbGl6YXRpb24gZm9yIG9ubnhydW50aW1lLWNvbW1vbiBhbmQgb25ueHJ1bnRpbWUtd2ViLlxuICogICAgVGhpcyBpcyB0aGUgZmlyc3QgaW5pdGlhbGl6YXRpb24gc3RlcC4gSW4gdGhpcyBzdGVwLCBvbm54cnVudGltZS13ZWIgY2FsbHMgb25ueHJ1bnRpbWUtY29tbW9uJ3MgcmVnaXN0ZXJCYWNrZW5kKClcbiAqIGZ1bmN0aW9uIG11bHRpcGxlIHRpbWVzIHRvIHJlZ2lzdGVyIGFsbCB0aGUgYXZhaWxhYmxlIGJhY2tlbmRzLiBUaGUgYmFja2VuZCByZWdpc3RyYXRpb24gaXMgdmVyeSBmYXN0LiBJdCBvbmx5XG4gKiByZWdpc3RlcnMgdGhlIGJhY2tlbmQgbmFtZSB3aXRoIHRoZSB1bmluaXRpYWxpemVkIGJhY2tlbmQgb2JqZWN0LiBObyBoZWF2eSBpbml0aWFsaXphdGlvbiBpcyBkb25lIGluIHRoaXMgc3RlcC5cbiAqICAgIFJlZmVyIHRvIHdlYi9saWIvaW5kZXgudHMgZm9yIHRoZSBiYWNrZW5kIHJlZ2lzdHJhdGlvbi5cbiAqXG4gKiAyLiBXZWJBc3NlbWJseSBhcnRpZmFjdCBpbml0aWFsaXphdGlvbi5cbiAqICAgIFRoaXMgaGFwcGVucyB3aGVuIGFueSByZWdpc3RlcmVkIHdhc20gYmFja2VuZCBpcyB1c2VkIGZvciB0aGUgZmlyc3QgdGltZSAoaWUuIGBvcnQuSW5mZXJlbmNlU2Vzc2lvbi5jcmVhdGUoKWAgaXNcbiAqIGNhbGxlZCkuIEluIHRoaXMgc3RlcCwgb25ueHJ1bnRpbWUtd2ViIGRvZXMgdGhlIGZvbGxvd2luZ3M6XG4gKiAgICAgLSBjcmVhdGUgYSBwcm94eSB3b3JrZXIgYW5kIG1ha2Ugc3VyZSB0aGUgcHJveHkgd29ya2VyIGlzIHJlYWR5IHRvIHJlY2VpdmUgbWVzc2FnZXMsIGlmIHByb3h5IGlzIGVuYWJsZWQuXG4gKiAgICAgLSBwZXJmb3JtIGZlYXR1cmUgZGV0ZWN0aW9uLCBsb2NhdGUgY29ycmVjdCBXZWJBc3NlbWJseSBhcnRpZmFjdCBwYXRoIGFuZCBjYWxsIHRoZSBFbXNjcmlwdGVuIGdlbmVyYXRlZFxuICogSmF2YVNjcmlwdCBjb2RlIHRvIGluaXRpYWxpemUgdGhlIFdlYkFzc2VtYmx5IHJ1bnRpbWUuXG4gKiAgICAgICAgIC0gaWYgcHJveHkgaXMgZW5hYmxlZCwgdGhpcyBzdGVwIGhhcHBlbnMgaW4gdGhlIHByb3h5IHdvcmtlciB1c2luZyBtZXNzYWdlICdpbml0LXdhc20nLlxuICogICAgICAgICAtIGRvd25sb2FkaW5nIHRoZSAnb3J0LXdhc217Li4ufS53YXNtJyBmaWxlIGlzIGRvbmUgaW4gdGhpcyBzdGVwLlxuICogICAgICAgICAtIGlmIG11bHRpLXRocmVhZCBpcyBlbmFibGVkLCBvbmUgb3IgbW9yZSB3ZWJ3b3JrZXIgd2lsbCBiZSBjcmVhdGVkIHRvIGluaXRpYWxpemUgdGhlIFBUaHJlYWQgdGhyZWFkcG9vbC5cbiAqXG4gKiAzLiBPUlQgZW52aXJvbm1lbnQgaW5pdGlhbGl6YXRpb24uXG4gKiAgICBUaGlzIGhhcHBlbnMgYWZ0ZXIgc3RlcCAyLiBJbiB0aGlzIHN0ZXAsIG9ubnhydW50aW1lLXdlYiBwZXJmb3JtcyBPTk5YIFJ1bnRpbWUgZW52aXJvbm1lbnQgaW5pdGlhbGl6YXRpb24uXG4gKiBGdW5jdGlvbiBgX09ydEluaXQoKWAgaXMgY2FsbGVkIGluIHRoaXMgc3RlcC5cbiAqICAgICAtIGlmIHByb3h5IGlzIGVuYWJsZWQsIHRoaXMgc3RlcCBoYXBwZW5zIGluIHRoZSBwcm94eSB3b3JrZXIgdXNpbmcgbWVzc2FnZSAnaW5pdC1vcnQnLlxuICogICAgIC0gbG9nZ2luZyBsZXZlbCAob3J0LmVudi5sb2dMZXZlbCkgYW5kIHRocmVhZCBudW1iZXIgKG9ydC5lbnYud2FzbS5udW1UaHJlYWRzKSBhcmUgc2V0IGluIHRoaXMgc3RlcC5cbiAqXG4gKiA0LiBTZXNzaW9uIGluaXRpYWxpemF0aW9uLlxuICogICAgVGhpcyBoYXBwZW5zIHdoZW4gYG9ydC5JbmZlcmVuY2VTZXNzaW9uLmNyZWF0ZSgpYCBpcyBjYWxsZWQuIFVubGlrZSB0aGUgZmlyc3QgMyBzdGVwcyAodGhleSBvbmx5IGNhbGxlZCBvbmNlKSxcbiAqIHRoaXMgc3RlcCB3aWxsIGJlIGRvbmUgZm9yIGVhY2ggc2Vzc2lvbi4gSW4gdGhpcyBzdGVwLCBvbm54cnVudGltZS13ZWIgZG9lcyB0aGUgZm9sbG93aW5nczpcbiAqICAgIElmIHRoZSBwYXJhbWV0ZXIgaXMgYSBVUkw6XG4gKiAgICAtIGRvd25sb2FkIHRoZSBtb2RlbCBkYXRhIGZyb20gdGhlIFVSTC5cbiAqICAgIC0gY29weSB0aGUgbW9kZWwgZGF0YSB0byB0aGUgV0FTTSBoZWFwLiAocHJveHk6ICdjb3B5LWZyb20nKVxuICogICAgLSBkZXJlZmVyZW5jZSB0aGUgbW9kZWwgYnVmZmVyLiBUaGlzIHN0ZXAgYWxsb3dzIHRoZSBvcmlnaW5hbCBBcnJheUJ1ZmZlciB0byBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cbiAqICAgIC0gY2FsbCBgX09ydENyZWF0ZVNlc3Npb24oKWAgdG8gY3JlYXRlIHRoZSBzZXNzaW9uLiAocHJveHk6ICdjcmVhdGUnKVxuICpcbiAqICAgIElmIHRoZSBwYXJhbWV0ZXIgaXMgYSBVaW50OEFycmF5IG9iamVjdDpcbiAqICAgIC0gY29weSB0aGUgbW9kZWwgZGF0YSB0byB0aGUgV0FTTSBoZWFwLiAocHJveHk6ICdjb3B5LWZyb20nKVxuICogICAgLSBjYWxsIGBfT3J0Q3JlYXRlU2Vzc2lvbigpYCB0byBjcmVhdGUgdGhlIHNlc3Npb24uIChwcm94eTogJ2NyZWF0ZScpXG4gKlxuICpcbiAqL1xuXG4vKipcbiAqIGluaXRpYWxpemUgT1JUIGVudmlyb25tZW50LlxuICpcbiAqIEBwYXJhbSBudW1UaHJlYWRzIFNldEdsb2JhbEludHJhT3BOdW1UaHJlYWRzKG51bVRocmVhZHMpXG4gKiBAcGFyYW0gbG9nZ2luZ0xldmVsIENyZWF0ZUVudihzdGF0aWNfY2FzdDxPcnRMb2dnaW5nTGV2ZWw+KGxvZ2dpbmdfbGV2ZWwpKVxuICovXG5jb25zdCBpbml0T3J0ID0gKG51bVRocmVhZHM6IG51bWJlciwgbG9nZ2luZ0xldmVsOiBudW1iZXIpOiB2b2lkID0+IHtcbiAgY29uc3QgZXJyb3JDb2RlID0gZ2V0SW5zdGFuY2UoKS5fT3J0SW5pdChudW1UaHJlYWRzLCBsb2dnaW5nTGV2ZWwpO1xuICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XG4gICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBpbml0aWFsaXplIG9ubnhydW50aW1lLlwiKTtcbiAgfVxufTtcblxuLyoqXG4gKiBpbml0aWFsaXplIHJ1bnRpbWUgZW52aXJvbm1lbnQuXG4gKiBAcGFyYW0gZW52IHBhc3NlZCBpbiB0aGUgZW52aXJvbm1lbnQgY29uZmlnIG9iamVjdC5cbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRSdW50aW1lID0gYXN5bmMgKGVudjogRW52KTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIC8vIGluaXQgT1JUXG4gIGluaXRPcnQoZW52Lndhc20ubnVtVGhyZWFkcyEsIGxvZ0xldmVsU3RyaW5nVG9FbnVtKGVudi5sb2dMZXZlbCkpO1xufTtcblxuLyoqXG4gKiBwZXJmb3JtIEVQIHNwZWNpZmljIGluaXRpYWxpemF0aW9uLlxuICpcbiAqIEBwYXJhbSBlbnZcbiAqIEBwYXJhbSBlcE5hbWVcbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRFcCA9IGFzeW5jIChlbnY6IEVudiwgZXBOYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG4gICAgY29uc3QgaW5pdEpzZXAgPSByZXF1aXJlKCcuL2pzZXAvaW5pdCcpLmluaXQ7XG5cbiAgICBpZiAoZXBOYW1lID09PSAnd2ViZ3B1Jykge1xuICAgICAgLy8gcGVyZm9ybSBXZWJHUFUgYXZhaWxhYmlsaXR5IGNoZWNrXG4gICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgIW5hdmlnYXRvci5ncHUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJHUFUgaXMgbm90IHN1cHBvcnRlZCBpbiBjdXJyZW50IGVudmlyb25tZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGxldCBhZGFwdGVyID0gZW52LndlYmdwdS5hZGFwdGVyIGFzIEdQVUFkYXB0ZXIgfCBudWxsO1xuICAgICAgaWYgKCFhZGFwdGVyKSB7XG4gICAgICAgIC8vIGlmIGFkYXB0ZXIgaXMgbm90IHNldCwgcmVxdWVzdCBhIG5ldyBhZGFwdGVyLlxuICAgICAgICBjb25zdCBwb3dlclByZWZlcmVuY2UgPSBlbnYud2ViZ3B1LnBvd2VyUHJlZmVyZW5jZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHBvd2VyUHJlZmVyZW5jZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgcG93ZXJQcmVmZXJlbmNlICE9PSAnbG93LXBvd2VyJyAmJlxuICAgICAgICAgIHBvd2VyUHJlZmVyZW5jZSAhPT0gJ2hpZ2gtcGVyZm9ybWFuY2UnXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwb3dlclByZWZlcmVuY2Ugc2V0dGluZzogXCIke3Bvd2VyUHJlZmVyZW5jZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcmNlRmFsbGJhY2tBZGFwdGVyID0gZW52LndlYmdwdS5mb3JjZUZhbGxiYWNrQWRhcHRlcjtcbiAgICAgICAgaWYgKGZvcmNlRmFsbGJhY2tBZGFwdGVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGZvcmNlRmFsbGJhY2tBZGFwdGVyICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZm9yY2VGYWxsYmFja0FkYXB0ZXIgc2V0dGluZzogXCIke2ZvcmNlRmFsbGJhY2tBZGFwdGVyfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRhcHRlciA9IGF3YWl0IG5hdmlnYXRvci5ncHUucmVxdWVzdEFkYXB0ZXIoeyBwb3dlclByZWZlcmVuY2UsIGZvcmNlRmFsbGJhY2tBZGFwdGVyIH0pO1xuICAgICAgICBpZiAoIWFkYXB0ZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnRmFpbGVkIHRvIGdldCBHUFUgYWRhcHRlci4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IG5lZWQgdG8gZW5hYmxlIGZsYWcgXCItLWVuYWJsZS11bnNhZmUtd2ViZ3B1XCIgaWYgeW91IGFyZSB1c2luZyBDaHJvbWUuJyxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBhZGFwdGVyIGlzIHNldCwgdmFsaWRhdGUgaXQuXG4gICAgICAgIGlmIChcbiAgICAgICAgICB0eXBlb2YgYWRhcHRlci5saW1pdHMgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgdHlwZW9mIGFkYXB0ZXIuZmVhdHVyZXMgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgdHlwZW9mIGFkYXB0ZXIucmVxdWVzdERldmljZSAhPT0gJ2Z1bmN0aW9uJ1xuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgR1BVIGFkYXB0ZXIgc2V0IGluIGBlbnYud2ViZ3B1LmFkYXB0ZXJgLiBJdCBtdXN0IGJlIGEgR1BVQWRhcHRlciBvYmplY3QuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYXdhaXQgaW5pdEpzZXAoJ3dlYmdwdScsIGdldEluc3RhbmNlKCksIGVudiwgYWRhcHRlcik7XG4gICAgfVxuICAgIGlmIChlcE5hbWUgPT09ICd3ZWJubicpIHtcbiAgICAgIC8vIHBlcmZvcm0gV2ViTk4gYXZhaWxhYmlsaXR5IGNoZWNrXG4gICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgIShuYXZpZ2F0b3IgYXMgdW5rbm93biBhcyB7IG1sOiB1bmtub3duIH0pLm1sKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViTk4gaXMgbm90IHN1cHBvcnRlZCBpbiBjdXJyZW50IGVudmlyb25tZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IGluaXRKc2VwKCd3ZWJubicsIGdldEluc3RhbmNlKCksIGVudik7XG4gICAgfVxuICB9XG59O1xuXG4vLyAjZW5kcmVnaW9uIEluaXRpYWxpemF0aW9uc1xuXG4vKipcbiAqIHZhbGlkIGRhdGEgbG9jYXRpb25zIGZvciBpbnB1dC9vdXRwdXQgdGVuc29ycy5cbiAqL1xudHlwZSBTdXBwb3J0ZWRUZW5zb3JEYXRhTG9jYXRpb25Gb3JJbnB1dE91dHB1dCA9ICdjcHUnIHwgJ2NwdS1waW5uZWQnIHwgJ2dwdS1idWZmZXInO1xuXG50eXBlIElPQmluZGluZ1N0YXRlID0ge1xuICAvKipcbiAgICogdGhlIGhhbmRsZSBvZiBJTyBiaW5kaW5nLlxuICAgKi9cbiAgcmVhZG9ubHkgaGFuZGxlOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIHRoZSBwcmVmZXJyZWQgbG9jYXRpb24gZm9yIGVhY2ggb3V0cHV0IHRlbnNvci5cbiAgICpcbiAgICogdmFsdWUgaXMgb25lIG9mICdjcHUnLCAnY3B1LXBpbm5lZCcsICdncHUtYnVmZmVyJy5cbiAgICovXG4gIHJlYWRvbmx5IG91dHB1dFByZWZlcnJlZExvY2F0aW9uczogcmVhZG9ubHkgU3VwcG9ydGVkVGVuc29yRGF0YUxvY2F0aW9uRm9ySW5wdXRPdXRwdXRbXTtcblxuICAvKipcbiAgICogZW51bSB2YWx1ZSBvZiB0aGUgcHJlZmVycmVkIGxvY2F0aW9uIGZvciBlYWNoIG91dHB1dCB0ZW5zb3IuXG4gICAqL1xuICByZWFkb25seSBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkOiByZWFkb25seSBudW1iZXJbXTtcbn07XG5cbi8qKlxuICogIHR1cGxlIGVsZW1lbnRzIGFyZTogSW5mZXJlbmNlU2Vzc2lvbiBJRDsgaW5wdXROYW1lc1VURjhFbmNvZGVkOyBvdXRwdXROYW1lc1VURjhFbmNvZGVkOyBiaW5kaW5nU3RhdGVcbiAqL1xudHlwZSBTZXNzaW9uTWV0YWRhdGEgPSBbXG4gIGluZmVyZW5jZVNlc3Npb25JZDogbnVtYmVyLFxuICBpbnB1dE5hbWVzVVRGOEVuY29kZWQ6IG51bWJlcltdLFxuICBvdXRwdXROYW1lc1VURjhFbmNvZGVkOiBudW1iZXJbXSxcbiAgYmluZGluZ1N0YXRlOiBJT0JpbmRpbmdTdGF0ZSB8IG51bGwsXG4gIGVuYWJsZUdyYXBoQ2FwdHVyZTogYm9vbGVhbixcbiAgaW5wdXRPdXRwdXRCb3VuZDogYm9vbGVhbixcbl07XG5cbmNvbnN0IGFjdGl2ZVNlc3Npb25zID0gbmV3IE1hcDxudW1iZXIsIFNlc3Npb25NZXRhZGF0YT4oKTtcblxuLyoqXG4gKiBnZXQgdGhlIGlucHV0L291dHB1dCBjb3VudCBvZiB0aGUgc2Vzc2lvbi5cbiAqIEBwYXJhbSBzZXNzaW9uSGFuZGxlIHRoZSBoYW5kbGUgcmVwcmVzZW50aW5nIHRoZSBzZXNzaW9uLiBzaG91bGQgYmUgbm9uLXplcm8uXG4gKiBAcmV0dXJucyBhIHR1cGxlIGluY2x1ZGluZyAyIG51bWJlcnMsIHJlcHJlc2VudGluZyB0aGUgaW5wdXQgY291bnQgYW5kIG91dHB1dCBjb3VudC5cbiAqL1xuY29uc3QgZ2V0U2Vzc2lvbklucHV0T3V0cHV0Q291bnQgPSAoc2Vzc2lvbkhhbmRsZTogbnVtYmVyKTogW251bWJlciwgbnVtYmVyXSA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBjb25zdCBzdGFjayA9IHdhc20uc3RhY2tTYXZlKCk7XG4gIHRyeSB7XG4gICAgY29uc3QgZGF0YU9mZnNldCA9IHdhc20uc3RhY2tBbGxvYyg4KTtcbiAgICBjb25zdCBlcnJvckNvZGUgPSB3YXNtLl9PcnRHZXRJbnB1dE91dHB1dENvdW50KHNlc3Npb25IYW5kbGUsIGRhdGFPZmZzZXQsIGRhdGFPZmZzZXQgKyA0KTtcbiAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XG4gICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGdldCBzZXNzaW9uIGlucHV0L291dHB1dCBjb3VudC5cIik7XG4gICAgfVxuICAgIHJldHVybiBbd2FzbS5IRUFQMzJbZGF0YU9mZnNldCAvIDRdLCB3YXNtLkhFQVAzMltkYXRhT2Zmc2V0IC8gNCArIDFdXTtcbiAgfSBmaW5hbGx5IHtcbiAgICB3YXNtLnN0YWNrUmVzdG9yZShzdGFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogYWxsb2NhdGUgdGhlIG1lbW9yeSBhbmQgbWVtY3B5IHRoZSBleHRlcm5hbCBidWZmZXIuXG4gKlxuICogQHBhcmFtIG1vZGVsIC0gdGhlIGV4dGVybmFsIGJ1ZmZlciBjb250YWluaW5nIHRoZSBtb2RlbCBkYXRhLiBNdXN0IG5vdCBiZSB0aGUgc2FtZSBidWZmZXIgYXMgdGhlIFdBU00gaGVhcC5cbiAqIEByZXR1cm5zIGEgMi1lbGVtZW50cyB0dXBsZSAtIHRoZSBwb2ludGVyIGFuZCBzaXplIG9mIHRoZSBhbGxvY2F0ZWQgYnVmZmVyXG4gKi9cbmV4cG9ydCBjb25zdCBjb3B5RnJvbUV4dGVybmFsQnVmZmVyID0gKG1vZGVsOiBVaW50OEFycmF5KTogW251bWJlciwgbnVtYmVyXSA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBjb25zdCBtb2RlbERhdGFPZmZzZXQgPSB3YXNtLl9tYWxsb2MobW9kZWwuYnl0ZUxlbmd0aCk7XG4gIGlmIChtb2RlbERhdGFPZmZzZXQgPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGNyZWF0ZSBhIHNlc3Npb24uIGZhaWxlZCB0byBhbGxvY2F0ZSBhIGJ1ZmZlciBvZiBzaXplICR7bW9kZWwuYnl0ZUxlbmd0aH0uYCk7XG4gIH1cbiAgd2FzbS5IRUFQVTguc2V0KG1vZGVsLCBtb2RlbERhdGFPZmZzZXQpO1xuICByZXR1cm4gW21vZGVsRGF0YU9mZnNldCwgbW9kZWwuYnl0ZUxlbmd0aF07XG59O1xuXG4vKipcbiAqIGNyZWF0ZSBhbiBpbmZlcmVuY2Ugc2Vzc2lvbiBmcm9tIGEgbW9kZWwgZGF0YSBidWZmZXIuXG4gKlxuICogQHBhcmFtIG1vZGVsRGF0YSAtIGVpdGhlciBhIFVpbnQ4QXJyYXkgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgbW9kZWwgZGF0YSwgb3IgYSAyLWVsZW1lbnRzIHR1cGxlIGNvbnRhaW5pbmcgdGhlXG4gKiAgICAgcG9pbnRlciBhbmQgc2l6ZSBvZiB0aGUgbW9kZWwgZGF0YSBidWZmZXIuXG4gKiBAcGFyYW0gb3B0aW9ucyBhbiBvcHRpb25hbCBzZXNzaW9uIG9wdGlvbnMgb2JqZWN0LlxuICogQHJldHVybnMgYSAzLWVsZW1lbnRzIHR1cGxlIGNvbnRhaW5pbmcgW3Nlc3Npb24gaGFuZGxlLCBpbnB1dCBuYW1lcywgb3V0cHV0IG5hbWVzXVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlU2Vzc2lvbiA9IGFzeW5jIChcbiAgbW9kZWxEYXRhOiBVaW50OEFycmF5IHwgU2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXIsXG4gIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zLFxuKTogUHJvbWlzZTxTZXJpYWxpemFibGVTZXNzaW9uTWV0YWRhdGE+ID0+IHtcbiAgbGV0IG1vZGVsRGF0YU9mZnNldDogbnVtYmVyLCBtb2RlbERhdGFMZW5ndGg6IG51bWJlcjtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobW9kZWxEYXRhKSkge1xuICAgIC8vIGlmIG1vZGVsIGRhdGEgaXMgYW4gYXJyYXksIGl0IG11c3QgYmUgYSAyLWVsZW1lbnRzIHR1cGxlIGNvbnRhaW5pbmcgdGhlIHBvaW50ZXIgYW5kIHNpemUgb2YgdGhlIG1vZGVsIGRhdGFcbiAgICBbbW9kZWxEYXRhT2Zmc2V0LCBtb2RlbERhdGFMZW5ndGhdID0gbW9kZWxEYXRhO1xuICB9IGVsc2UgaWYgKG1vZGVsRGF0YS5idWZmZXIgPT09IHdhc20uSEVBUFU4LmJ1ZmZlcikge1xuICAgIC8vIGlmIG1vZGVsIGRhdGEgdXNlcyB0aGUgc2FtZSBidWZmZXIgYXMgdGhlIFdBU00gaGVhcCwgd2UgZG9uJ3QgbmVlZCB0byBjb3B5IGl0LlxuICAgIFttb2RlbERhdGFPZmZzZXQsIG1vZGVsRGF0YUxlbmd0aF0gPSBbbW9kZWxEYXRhLmJ5dGVPZmZzZXQsIG1vZGVsRGF0YS5ieXRlTGVuZ3RoXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBvdGhlcndpc2UsIGNvcHkgdGhlIG1vZGVsIGRhdGEgdG8gdGhlIFdBU00gaGVhcC5cbiAgICBbbW9kZWxEYXRhT2Zmc2V0LCBtb2RlbERhdGFMZW5ndGhdID0gY29weUZyb21FeHRlcm5hbEJ1ZmZlcihtb2RlbERhdGEpO1xuICB9XG5cbiAgbGV0IHNlc3Npb25IYW5kbGUgPSAwO1xuICBsZXQgc2Vzc2lvbk9wdGlvbnNIYW5kbGUgPSAwO1xuICBsZXQgaW9CaW5kaW5nSGFuZGxlID0gMDtcbiAgbGV0IGFsbG9jczogbnVtYmVyW10gPSBbXTtcbiAgY29uc3QgaW5wdXROYW1lc1VURjhFbmNvZGVkID0gW107XG4gIGNvbnN0IG91dHB1dE5hbWVzVVRGOEVuY29kZWQgPSBbXTtcblxuICB0cnkge1xuICAgIFtzZXNzaW9uT3B0aW9uc0hhbmRsZSwgYWxsb2NzXSA9IHNldFNlc3Npb25PcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgaWYgKG9wdGlvbnM/LmV4dGVybmFsRGF0YSAmJiB3YXNtLm1vdW50RXh0ZXJuYWxEYXRhKSB7XG4gICAgICBjb25zdCBsb2FkaW5nUHJvbWlzZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBvcHRpb25zLmV4dGVybmFsRGF0YSkge1xuICAgICAgICBjb25zdCBwYXRoID0gdHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnID8gZmlsZSA6IGZpbGUucGF0aDtcbiAgICAgICAgbG9hZGluZ1Byb21pc2VzLnB1c2goXG4gICAgICAgICAgbG9hZEZpbGUodHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnID8gZmlsZSA6IGZpbGUuZGF0YSkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgd2FzbS5tb3VudEV4dGVybmFsRGF0YSEocGF0aCwgZGF0YSk7XG4gICAgICAgICAgfSksXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIHdhaXQgZm9yIGFsbCBleHRlcm5hbCBkYXRhIGZpbGVzIHRvIGJlIGxvYWRlZFxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwobG9hZGluZ1Byb21pc2VzKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHByb3ZpZGVyIG9mIG9wdGlvbnM/LmV4ZWN1dGlvblByb3ZpZGVycyA/PyBbXSkge1xuICAgICAgY29uc3QgcHJvdmlkZXJOYW1lID0gdHlwZW9mIHByb3ZpZGVyID09PSAnc3RyaW5nJyA/IHByb3ZpZGVyIDogcHJvdmlkZXIubmFtZTtcbiAgICAgIGlmIChwcm92aWRlck5hbWUgPT09ICd3ZWJubicpIHtcbiAgICAgICAgaWYgKHdhc20uY3VycmVudENvbnRleHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYk5OIGV4ZWN1dGlvbiBwcm92aWRlciBpcyBhbHJlYWR5IHNldC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVyICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNvbnN0IHdlYm5uT3B0aW9ucyA9IHByb3ZpZGVyIGFzIEluZmVyZW5jZVNlc3Npb24uV2ViTk5FeGVjdXRpb25Qcm92aWRlck9wdGlvbjtcbiAgICAgICAgICBjb25zdCBjb250ZXh0ID0gKHdlYm5uT3B0aW9ucyBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5OT3B0aW9uc1dpdGhNTENvbnRleHQpPy5jb250ZXh0O1xuICAgICAgICAgIGNvbnN0IGdwdURldmljZSA9ICh3ZWJubk9wdGlvbnMgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTk9wdGlvbnNXZWJHcHUpPy5ncHVEZXZpY2U7XG4gICAgICAgICAgY29uc3QgZGV2aWNlVHlwZSA9ICh3ZWJubk9wdGlvbnMgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTkNvbnRleHRPcHRpb25zKT8uZGV2aWNlVHlwZTtcbiAgICAgICAgICBjb25zdCBudW1UaHJlYWRzID0gKHdlYm5uT3B0aW9ucyBhcyBJbmZlcmVuY2VTZXNzaW9uLldlYk5OQ29udGV4dE9wdGlvbnMpPy5udW1UaHJlYWRzO1xuICAgICAgICAgIGNvbnN0IHBvd2VyUHJlZmVyZW5jZSA9ICh3ZWJubk9wdGlvbnMgYXMgSW5mZXJlbmNlU2Vzc2lvbi5XZWJOTkNvbnRleHRPcHRpb25zKT8ucG93ZXJQcmVmZXJlbmNlO1xuICAgICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICB3YXNtLmN1cnJlbnRDb250ZXh0ID0gY29udGV4dCBhcyBNTENvbnRleHQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChncHVEZXZpY2UpIHtcbiAgICAgICAgICAgIHdhc20uY3VycmVudENvbnRleHQgPSBhd2FpdCBuYXZpZ2F0b3IubWwuY3JlYXRlQ29udGV4dChncHVEZXZpY2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3YXNtLmN1cnJlbnRDb250ZXh0ID0gYXdhaXQgbmF2aWdhdG9yLm1sLmNyZWF0ZUNvbnRleHQoeyBkZXZpY2VUeXBlLCBudW1UaHJlYWRzLCBwb3dlclByZWZlcmVuY2UgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhc20uY3VycmVudENvbnRleHQgPSBhd2FpdCBuYXZpZ2F0b3IubWwuY3JlYXRlQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlc3Npb25IYW5kbGUgPSBhd2FpdCB3YXNtLl9PcnRDcmVhdGVTZXNzaW9uKG1vZGVsRGF0YU9mZnNldCwgbW9kZWxEYXRhTGVuZ3RoLCBzZXNzaW9uT3B0aW9uc0hhbmRsZSk7XG4gICAgaWYgKHNlc3Npb25IYW5kbGUgPT09IDApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgY3JlYXRlIGEgc2Vzc2lvbi5cIik7XG4gICAgfVxuXG4gICAgLy8gY2xlYXIgY3VycmVudCBNTENvbnRleHQgYWZ0ZXIgc2Vzc2lvbiBjcmVhdGlvblxuICAgIGlmICh3YXNtLmN1cnJlbnRDb250ZXh0KSB7XG4gICAgICB3YXNtLmN1cnJlbnRDb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IFtpbnB1dENvdW50LCBvdXRwdXRDb3VudF0gPSBnZXRTZXNzaW9uSW5wdXRPdXRwdXRDb3VudChzZXNzaW9uSGFuZGxlKTtcblxuICAgIGNvbnN0IGVuYWJsZUdyYXBoQ2FwdHVyZSA9ICEhb3B0aW9ucz8uZW5hYmxlR3JhcGhDYXB0dXJlO1xuXG4gICAgY29uc3QgaW5wdXROYW1lcyA9IFtdO1xuICAgIGNvbnN0IG91dHB1dE5hbWVzID0gW107XG4gICAgY29uc3Qgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zOiBTdXBwb3J0ZWRUZW5zb3JEYXRhTG9jYXRpb25Gb3JJbnB1dE91dHB1dFtdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dENvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IG5hbWUgPSB3YXNtLl9PcnRHZXRJbnB1dE5hbWUoc2Vzc2lvbkhhbmRsZSwgaSk7XG4gICAgICBpZiAobmFtZSA9PT0gMCkge1xuICAgICAgICBjaGVja0xhc3RFcnJvcihcIkNhbid0IGdldCBhbiBpbnB1dCBuYW1lLlwiKTtcbiAgICAgIH1cbiAgICAgIGlucHV0TmFtZXNVVEY4RW5jb2RlZC5wdXNoKG5hbWUpO1xuICAgICAgaW5wdXROYW1lcy5wdXNoKHdhc20uVVRGOFRvU3RyaW5nKG5hbWUpKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBuYW1lID0gd2FzbS5fT3J0R2V0T3V0cHV0TmFtZShzZXNzaW9uSGFuZGxlLCBpKTtcbiAgICAgIGlmIChuYW1lID09PSAwKSB7XG4gICAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgZ2V0IGFuIG91dHB1dCBuYW1lLlwiKTtcbiAgICAgIH1cbiAgICAgIG91dHB1dE5hbWVzVVRGOEVuY29kZWQucHVzaChuYW1lKTtcbiAgICAgIGNvbnN0IG5hbWVTdHJpbmcgPSB3YXNtLlVURjhUb1N0cmluZyhuYW1lKTtcbiAgICAgIG91dHB1dE5hbWVzLnB1c2gobmFtZVN0cmluZyk7XG5cbiAgICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX0pTRVApIHtcbiAgICAgICAgaWYgKGVuYWJsZUdyYXBoQ2FwdHVyZSAmJiBvcHRpb25zPy5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zLnB1c2goJ2dwdS1idWZmZXInKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9XG4gICAgICAgICAgdHlwZW9mIG9wdGlvbnM/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBvcHRpb25zLnByZWZlcnJlZE91dHB1dExvY2F0aW9uXG4gICAgICAgICAgICA6IChvcHRpb25zPy5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj8uW25hbWVTdHJpbmddID8/ICdjcHUnKTtcbiAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAnY3B1JyAmJiBsb2NhdGlvbiAhPT0gJ2NwdS1waW5uZWQnICYmIGxvY2F0aW9uICE9PSAnZ3B1LWJ1ZmZlcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgcHJlZmVycmVkIG91dHB1dCBsb2NhdGlvbjogJHtsb2NhdGlvbn0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuYWJsZUdyYXBoQ2FwdHVyZSAmJiBsb2NhdGlvbiAhPT0gJ2dwdS1idWZmZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYE5vdCBzdXBwb3J0ZWQgcHJlZmVycmVkIG91dHB1dCBsb2NhdGlvbjogJHtsb2NhdGlvbn0uIE9ubHkgJ2dwdS1idWZmZXInIGxvY2F0aW9uIGlzIHN1cHBvcnRlZCB3aGVuIGVuYWJsZUdyYXBoQ2FwdHVyZSBpcyB0cnVlLmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMucHVzaChsb2NhdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdXNlIElPIGJpbmRpbmcgb25seSB3aGVuIGF0IGxlYXN0IG9uZSBvdXRwdXQgaXMgcHJlZmZlcmVkIHRvIGJlIG9uIEdQVS5cbiAgICBsZXQgYmluZGluZ1N0YXRlOiBJT0JpbmRpbmdTdGF0ZSB8IG51bGwgPSBudWxsO1xuICAgIGlmICghQlVJTERfREVGUy5ESVNBQkxFX0pTRVAgJiYgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zLnNvbWUoKGwpID0+IGwgPT09ICdncHUtYnVmZmVyJykpIHtcbiAgICAgIGlvQmluZGluZ0hhbmRsZSA9IHdhc20uX09ydENyZWF0ZUJpbmRpbmcoc2Vzc2lvbkhhbmRsZSk7XG4gICAgICBpZiAoaW9CaW5kaW5nSGFuZGxlID09PSAwKSB7XG4gICAgICAgIGNoZWNrTGFzdEVycm9yKFwiQ2FuJ3QgY3JlYXRlIElPIGJpbmRpbmcuXCIpO1xuICAgICAgfVxuXG4gICAgICBiaW5kaW5nU3RhdGUgPSB7XG4gICAgICAgIGhhbmRsZTogaW9CaW5kaW5nSGFuZGxlLFxuICAgICAgICBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMsXG4gICAgICAgIG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6IG91dHB1dFByZWZlcnJlZExvY2F0aW9ucy5tYXAoKGwpID0+IGRhdGFMb2NhdGlvblN0cmluZ1RvRW51bShsKSksXG4gICAgICB9O1xuICAgIH1cblxuICAgIGFjdGl2ZVNlc3Npb25zLnNldChzZXNzaW9uSGFuZGxlLCBbXG4gICAgICBzZXNzaW9uSGFuZGxlLFxuICAgICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLFxuICAgICAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCxcbiAgICAgIGJpbmRpbmdTdGF0ZSxcbiAgICAgIGVuYWJsZUdyYXBoQ2FwdHVyZSxcbiAgICAgIGZhbHNlLFxuICAgIF0pO1xuICAgIHJldHVybiBbc2Vzc2lvbkhhbmRsZSwgaW5wdXROYW1lcywgb3V0cHV0TmFtZXNdO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2goKGJ1ZikgPT4gd2FzbS5fT3J0RnJlZShidWYpKTtcbiAgICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2goKGJ1ZikgPT4gd2FzbS5fT3J0RnJlZShidWYpKTtcblxuICAgIGlmIChpb0JpbmRpbmdIYW5kbGUgIT09IDApIHtcbiAgICAgIHdhc20uX09ydFJlbGVhc2VCaW5kaW5nKGlvQmluZGluZ0hhbmRsZSk7XG4gICAgfVxuXG4gICAgaWYgKHNlc3Npb25IYW5kbGUgIT09IDApIHtcbiAgICAgIHdhc20uX09ydFJlbGVhc2VTZXNzaW9uKHNlc3Npb25IYW5kbGUpO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9IGZpbmFsbHkge1xuICAgIHdhc20uX2ZyZWUobW9kZWxEYXRhT2Zmc2V0KTtcbiAgICBpZiAoc2Vzc2lvbk9wdGlvbnNIYW5kbGUgIT09IDApIHtcbiAgICAgIHdhc20uX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhzZXNzaW9uT3B0aW9uc0hhbmRsZSk7XG4gICAgfVxuICAgIGFsbG9jcy5mb3JFYWNoKChhbGxvYykgPT4gd2FzbS5fZnJlZShhbGxvYykpO1xuXG4gICAgLy8gdW5tb3VudCBleHRlcm5hbCBkYXRhIGlmIG5lY2Vzc2FyeVxuICAgIHdhc20udW5tb3VudEV4dGVybmFsRGF0YT8uKCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWxlYXNlU2Vzc2lvbiA9IChzZXNzaW9uSWQ6IG51bWJlcik6IHZvaWQgPT4ge1xuICBjb25zdCB3YXNtID0gZ2V0SW5zdGFuY2UoKTtcbiAgY29uc3Qgc2Vzc2lvbiA9IGFjdGl2ZVNlc3Npb25zLmdldChzZXNzaW9uSWQpO1xuICBpZiAoIXNlc3Npb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWxlYXNlIHNlc3Npb24uIGludmFsaWQgc2Vzc2lvbiBpZDogJHtzZXNzaW9uSWR9YCk7XG4gIH1cbiAgY29uc3QgW3Nlc3Npb25IYW5kbGUsIGlucHV0TmFtZXNVVEY4RW5jb2RlZCwgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCwgaW9CaW5kaW5nU3RhdGUsIGVuYWJsZUdyYXBoQ2FwdHVyZV0gPSBzZXNzaW9uO1xuXG4gIGlmIChpb0JpbmRpbmdTdGF0ZSkge1xuICAgIGlmIChlbmFibGVHcmFwaENhcHR1cmUpIHtcbiAgICAgIHdhc20uX09ydENsZWFyQm91bmRPdXRwdXRzKGlvQmluZGluZ1N0YXRlLmhhbmRsZSk7XG4gICAgfVxuICAgIHdhc20uX09ydFJlbGVhc2VCaW5kaW5nKGlvQmluZGluZ1N0YXRlLmhhbmRsZSk7XG4gIH1cblxuICB3YXNtLmpzZXBPblJlbGVhc2VTZXNzaW9uPy4oc2Vzc2lvbklkKTtcblxuICBpbnB1dE5hbWVzVVRGOEVuY29kZWQuZm9yRWFjaCgoYnVmKSA9PiB3YXNtLl9PcnRGcmVlKGJ1ZikpO1xuICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLmZvckVhY2goKGJ1ZikgPT4gd2FzbS5fT3J0RnJlZShidWYpKTtcbiAgd2FzbS5fT3J0UmVsZWFzZVNlc3Npb24oc2Vzc2lvbkhhbmRsZSk7XG4gIGFjdGl2ZVNlc3Npb25zLmRlbGV0ZShzZXNzaW9uSWQpO1xufTtcblxuZXhwb3J0IGNvbnN0IHByZXBhcmVJbnB1dE91dHB1dFRlbnNvciA9IChcbiAgdGVuc29yOiBUZW5zb3JNZXRhZGF0YSB8IG51bGwsXG4gIHRlbnNvckhhbmRsZXM6IG51bWJlcltdLFxuICBhbGxvY3M6IG51bWJlcltdLFxuICBzZXNzaW9uSWQ6IG51bWJlcixcbiAgaW5kZXg6IG51bWJlcixcbiAgZW5hYmxlR3JhcGhDYXB0dXJlID0gZmFsc2UsXG4pOiB2b2lkID0+IHtcbiAgaWYgKCF0ZW5zb3IpIHtcbiAgICB0ZW5zb3JIYW5kbGVzLnB1c2goMCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG5cbiAgY29uc3QgZGF0YVR5cGUgPSB0ZW5zb3JbMF07XG4gIGNvbnN0IGRpbXMgPSB0ZW5zb3JbMV07XG4gIGNvbnN0IGxvY2F0aW9uID0gdGVuc29yWzNdO1xuXG4gIGxldCByYXdEYXRhOiBudW1iZXI7XG4gIGxldCBkYXRhQnl0ZUxlbmd0aDogbnVtYmVyO1xuXG4gIGlmIChkYXRhVHlwZSA9PT0gJ3N0cmluZycgJiYgbG9jYXRpb24gPT09ICdncHUtYnVmZmVyJykge1xuICAgIHRocm93IG5ldyBFcnJvcignU3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIG9uIEdQVS4nKTtcbiAgfVxuXG4gIGlmIChlbmFibGVHcmFwaENhcHR1cmUgJiYgbG9jYXRpb24gIT09ICdncHUtYnVmZmVyJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHRlcm5hbCBidWZmZXIgbXVzdCBiZSBwcm92aWRlZCBmb3IgaW5wdXQvb3V0cHV0IGluZGV4ICR7aW5kZXh9IHdoZW4gZW5hYmxlR3JhcGhDYXB0dXJlIGlzIHRydWUuYCxcbiAgICApO1xuICB9XG5cbiAgaWYgKGxvY2F0aW9uID09PSAnZ3B1LWJ1ZmZlcicpIHtcbiAgICBjb25zdCBncHVCdWZmZXIgPSB0ZW5zb3JbMl0uZ3B1QnVmZmVyIGFzIEdQVUJ1ZmZlcjtcbiAgICBkYXRhQnl0ZUxlbmd0aCA9IGNhbGN1bGF0ZVRlbnNvclNpemVJbkJ5dGVzKHRlbnNvckRhdGFUeXBlU3RyaW5nVG9FbnVtKGRhdGFUeXBlKSwgZGltcykhO1xuXG4gICAgY29uc3QgcmVnaXN0ZXJCdWZmZXIgPSB3YXNtLmpzZXBSZWdpc3RlckJ1ZmZlcjtcbiAgICBpZiAoIXJlZ2lzdGVyQnVmZmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBsb2NhdGlvbiBcImdwdS1idWZmZXJcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViR1BVLicpO1xuICAgIH1cbiAgICByYXdEYXRhID0gcmVnaXN0ZXJCdWZmZXIoc2Vzc2lvbklkLCBpbmRleCwgZ3B1QnVmZmVyLCBkYXRhQnl0ZUxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZGF0YSA9IHRlbnNvclsyXTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAvLyBzdHJpbmcgdGVuc29yXG4gICAgICBkYXRhQnl0ZUxlbmd0aCA9IDQgKiBkYXRhLmxlbmd0aDtcbiAgICAgIHJhd0RhdGEgPSB3YXNtLl9tYWxsb2MoZGF0YUJ5dGVMZW5ndGgpO1xuICAgICAgYWxsb2NzLnB1c2gocmF3RGF0YSk7XG4gICAgICBsZXQgZGF0YUluZGV4ID0gcmF3RGF0YSAvIDQ7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHRlbnNvciBkYXRhIGF0IGluZGV4ICR7aX0gaXMgbm90IGEgc3RyaW5nYCk7XG4gICAgICAgIH1cbiAgICAgICAgd2FzbS5IRUFQVTMyW2RhdGFJbmRleCsrXSA9IGFsbG9jV2FzbVN0cmluZyhkYXRhW2ldLCBhbGxvY3MpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhQnl0ZUxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIHJhd0RhdGEgPSB3YXNtLl9tYWxsb2MoZGF0YUJ5dGVMZW5ndGgpO1xuICAgICAgYWxsb2NzLnB1c2gocmF3RGF0YSk7XG4gICAgICB3YXNtLkhFQVBVOC5zZXQobmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YUJ5dGVMZW5ndGgpLCByYXdEYXRhKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBzdGFjayA9IHdhc20uc3RhY2tTYXZlKCk7XG4gIGNvbnN0IGRpbXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoNCAqIGRpbXMubGVuZ3RoKTtcbiAgdHJ5IHtcbiAgICBsZXQgZGltSW5kZXggPSBkaW1zT2Zmc2V0IC8gNDtcbiAgICBkaW1zLmZvckVhY2goKGQpID0+ICh3YXNtLkhFQVAzMltkaW1JbmRleCsrXSA9IGQpKTtcbiAgICBjb25zdCB0ZW5zb3IgPSB3YXNtLl9PcnRDcmVhdGVUZW5zb3IoXG4gICAgICB0ZW5zb3JEYXRhVHlwZVN0cmluZ1RvRW51bShkYXRhVHlwZSksXG4gICAgICByYXdEYXRhLFxuICAgICAgZGF0YUJ5dGVMZW5ndGgsXG4gICAgICBkaW1zT2Zmc2V0LFxuICAgICAgZGltcy5sZW5ndGgsXG4gICAgICBkYXRhTG9jYXRpb25TdHJpbmdUb0VudW0obG9jYXRpb24pLFxuICAgICk7XG4gICAgaWYgKHRlbnNvciA9PT0gMCkge1xuICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGNyZWF0ZSB0ZW5zb3IgZm9yIGlucHV0L291dHB1dC4gc2Vzc2lvbj0ke3Nlc3Npb25JZH0sIGluZGV4PSR7aW5kZXh9LmApO1xuICAgIH1cbiAgICB0ZW5zb3JIYW5kbGVzLnB1c2godGVuc29yKTtcbiAgfSBmaW5hbGx5IHtcbiAgICB3YXNtLnN0YWNrUmVzdG9yZShzdGFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogcGVyZm9ybSBpbmZlcmVuY2UgcnVuXG4gKi9cbmV4cG9ydCBjb25zdCBydW4gPSBhc3luYyAoXG4gIHNlc3Npb25JZDogbnVtYmVyLFxuICBpbnB1dEluZGljZXM6IG51bWJlcltdLFxuICBpbnB1dFRlbnNvcnM6IFRlbnNvck1ldGFkYXRhW10sXG4gIG91dHB1dEluZGljZXM6IG51bWJlcltdLFxuICBvdXRwdXRUZW5zb3JzOiBBcnJheTxUZW5zb3JNZXRhZGF0YSB8IG51bGw+LFxuICBvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMsXG4pOiBQcm9taXNlPFRlbnNvck1ldGFkYXRhW10+ID0+IHtcbiAgY29uc3Qgd2FzbSA9IGdldEluc3RhbmNlKCk7XG4gIGNvbnN0IHNlc3Npb24gPSBhY3RpdmVTZXNzaW9ucy5nZXQoc2Vzc2lvbklkKTtcbiAgaWYgKCFzZXNzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcnVuIGluZmVyZW5jZS4gaW52YWxpZCBzZXNzaW9uIGlkOiAke3Nlc3Npb25JZH1gKTtcbiAgfVxuICBjb25zdCBzZXNzaW9uSGFuZGxlID0gc2Vzc2lvblswXTtcbiAgY29uc3QgaW5wdXROYW1lc1VURjhFbmNvZGVkID0gc2Vzc2lvblsxXTtcbiAgY29uc3Qgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZCA9IHNlc3Npb25bMl07XG4gIGNvbnN0IGlvQmluZGluZ1N0YXRlID0gc2Vzc2lvblszXTtcbiAgY29uc3QgZW5hYmxlR3JhcGhDYXB0dXJlID0gc2Vzc2lvbls0XTtcbiAgY29uc3QgaW5wdXRPdXRwdXRCb3VuZCA9IHNlc3Npb25bNV07XG5cbiAgY29uc3QgaW5wdXRDb3VudCA9IGlucHV0SW5kaWNlcy5sZW5ndGg7XG4gIGNvbnN0IG91dHB1dENvdW50ID0gb3V0cHV0SW5kaWNlcy5sZW5ndGg7XG5cbiAgbGV0IHJ1bk9wdGlvbnNIYW5kbGUgPSAwO1xuICBsZXQgcnVuT3B0aW9uc0FsbG9jczogbnVtYmVyW10gPSBbXTtcblxuICBjb25zdCBpbnB1dFRlbnNvckhhbmRsZXM6IG51bWJlcltdID0gW107XG4gIGNvbnN0IG91dHB1dFRlbnNvckhhbmRsZXM6IG51bWJlcltdID0gW107XG4gIGNvbnN0IGlucHV0T3V0cHV0QWxsb2NzOiBudW1iZXJbXSA9IFtdO1xuXG4gIGNvbnN0IGJlZm9yZVJ1blN0YWNrID0gd2FzbS5zdGFja1NhdmUoKTtcbiAgY29uc3QgaW5wdXRWYWx1ZXNPZmZzZXQgPSB3YXNtLnN0YWNrQWxsb2MoaW5wdXRDb3VudCAqIDQpO1xuICBjb25zdCBpbnB1dE5hbWVzT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKGlucHV0Q291bnQgKiA0KTtcbiAgY29uc3Qgb3V0cHV0VmFsdWVzT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKG91dHB1dENvdW50ICogNCk7XG4gIGNvbnN0IG91dHB1dE5hbWVzT2Zmc2V0ID0gd2FzbS5zdGFja0FsbG9jKG91dHB1dENvdW50ICogNCk7XG5cbiAgdHJ5IHtcbiAgICBbcnVuT3B0aW9uc0hhbmRsZSwgcnVuT3B0aW9uc0FsbG9jc10gPSBzZXRSdW5PcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgLy8gY3JlYXRlIGlucHV0IHRlbnNvcnNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xuICAgICAgcHJlcGFyZUlucHV0T3V0cHV0VGVuc29yKFxuICAgICAgICBpbnB1dFRlbnNvcnNbaV0sXG4gICAgICAgIGlucHV0VGVuc29ySGFuZGxlcyxcbiAgICAgICAgaW5wdXRPdXRwdXRBbGxvY3MsXG4gICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgaW5wdXRJbmRpY2VzW2ldLFxuICAgICAgICBlbmFibGVHcmFwaENhcHR1cmUsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBvdXRwdXQgdGVuc29yc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Q291bnQ7IGkrKykge1xuICAgICAgcHJlcGFyZUlucHV0T3V0cHV0VGVuc29yKFxuICAgICAgICBvdXRwdXRUZW5zb3JzW2ldLFxuICAgICAgICBvdXRwdXRUZW5zb3JIYW5kbGVzLFxuICAgICAgICBpbnB1dE91dHB1dEFsbG9jcyxcbiAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICBpbnB1dENvdW50ICsgb3V0cHV0SW5kaWNlc1tpXSxcbiAgICAgICAgZW5hYmxlR3JhcGhDYXB0dXJlLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgaW5wdXRWYWx1ZXNJbmRleCA9IGlucHV0VmFsdWVzT2Zmc2V0IC8gNDtcbiAgICBsZXQgaW5wdXROYW1lc0luZGV4ID0gaW5wdXROYW1lc09mZnNldCAvIDQ7XG4gICAgbGV0IG91dHB1dFZhbHVlc0luZGV4ID0gb3V0cHV0VmFsdWVzT2Zmc2V0IC8gNDtcbiAgICBsZXQgb3V0cHV0TmFtZXNJbmRleCA9IG91dHB1dE5hbWVzT2Zmc2V0IC8gNDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Q291bnQ7IGkrKykge1xuICAgICAgd2FzbS5IRUFQVTMyW2lucHV0VmFsdWVzSW5kZXgrK10gPSBpbnB1dFRlbnNvckhhbmRsZXNbaV07XG4gICAgICB3YXNtLkhFQVBVMzJbaW5wdXROYW1lc0luZGV4KytdID0gaW5wdXROYW1lc1VURjhFbmNvZGVkW2lucHV0SW5kaWNlc1tpXV07XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Q291bnQ7IGkrKykge1xuICAgICAgd2FzbS5IRUFQVTMyW291dHB1dFZhbHVlc0luZGV4KytdID0gb3V0cHV0VGVuc29ySGFuZGxlc1tpXTtcbiAgICAgIHdhc20uSEVBUFUzMltvdXRwdXROYW1lc0luZGV4KytdID0gb3V0cHV0TmFtZXNVVEY4RW5jb2RlZFtvdXRwdXRJbmRpY2VzW2ldXTtcbiAgICB9XG5cbiAgICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQICYmIGlvQmluZGluZ1N0YXRlICYmICFpbnB1dE91dHB1dEJvdW5kKSB7XG4gICAgICBjb25zdCB7IGhhbmRsZSwgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zLCBvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkIH0gPSBpb0JpbmRpbmdTdGF0ZTtcblxuICAgICAgaWYgKGlucHV0TmFtZXNVVEY4RW5jb2RlZC5sZW5ndGggIT09IGlucHV0Q291bnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBpbnB1dCBjb3VudCBmcm9tIGZlZWRzICgke2lucHV0Q291bnR9KSBpcyBleHBlY3RlZCB0byBiZSBhbHdheXMgZXF1YWwgdG8gbW9kZWwncyBpbnB1dCBjb3VudCAoJHtpbnB1dE5hbWVzVVRGOEVuY29kZWQubGVuZ3RofSkuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gcHJvY2VzcyBpbnB1dHNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaW5wdXRJbmRpY2VzW2ldO1xuICAgICAgICBjb25zdCBlcnJvckNvZGUgPSBhd2FpdCB3YXNtLl9PcnRCaW5kSW5wdXQoaGFuZGxlLCBpbnB1dE5hbWVzVVRGOEVuY29kZWRbaW5kZXhdLCBpbnB1dFRlbnNvckhhbmRsZXNbaV0pO1xuICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XG4gICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGJpbmQgaW5wdXRbJHtpfV0gZm9yIHNlc3Npb249JHtzZXNzaW9uSWR9LmApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHByb2Nlc3MgcHJlLWFsbG9jYXRlZCBvdXRwdXRzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dENvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBvdXRwdXRJbmRpY2VzW2ldO1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IG91dHB1dFRlbnNvcnNbaV0/LlszXTsgLy8gdW5kZWZpbmVkIG1lYW5zIG91dHB1dCBpcyBub3QgcHJlLWFsbG9jYXRlZC5cblxuICAgICAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgICAgICAvLyBvdXRwdXQgaXMgcHJlLWFsbG9jYXRlZC4gYmluZCB0aGUgdGVuc29yLlxuICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHdhc20uX09ydEJpbmRPdXRwdXQoaGFuZGxlLCBvdXRwdXROYW1lc1VURjhFbmNvZGVkW2luZGV4XSwgb3V0cHV0VGVuc29ySGFuZGxlc1tpXSwgMCk7XG4gICAgICAgICAgaWYgKGVycm9yQ29kZSAhPT0gMCkge1xuICAgICAgICAgICAgY2hlY2tMYXN0RXJyb3IoYENhbid0IGJpbmQgcHJlLWFsbG9jYXRlZCBvdXRwdXRbJHtpfV0gZm9yIHNlc3Npb249JHtzZXNzaW9uSWR9LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBvdXRwdXQgaXMgbm90IHByZS1hbGxvY2F0ZWQuIHJlc2V0IHByZWZlcnJlZCBsb2NhdGlvbi5cbiAgICAgICAgICBjb25zdCBlcnJvckNvZGUgPSB3YXNtLl9PcnRCaW5kT3V0cHV0KFxuICAgICAgICAgICAgaGFuZGxlLFxuICAgICAgICAgICAgb3V0cHV0TmFtZXNVVEY4RW5jb2RlZFtpbmRleF0sXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zRW5jb2RlZFtpbmRleF0sXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSAwKSB7XG4gICAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3QgYmluZCBvdXRwdXRbJHtpfV0gdG8gJHtvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNbaV19IGZvciBzZXNzaW9uPSR7c2Vzc2lvbklkfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFjdGl2ZVNlc3Npb25zLnNldChzZXNzaW9uSWQsIFtcbiAgICAgICAgc2Vzc2lvbkhhbmRsZSxcbiAgICAgICAgaW5wdXROYW1lc1VURjhFbmNvZGVkLFxuICAgICAgICBvdXRwdXROYW1lc1VURjhFbmNvZGVkLFxuICAgICAgICBpb0JpbmRpbmdTdGF0ZSxcbiAgICAgICAgZW5hYmxlR3JhcGhDYXB0dXJlLFxuICAgICAgICB0cnVlLFxuICAgICAgXSk7XG4gICAgfVxuXG4gICAgd2FzbS5qc2VwT25SdW5TdGFydD8uKHNlc3Npb25IYW5kbGUpO1xuICAgIGxldCBlcnJvckNvZGU6IG51bWJlcjtcbiAgICBpZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9KU0VQICYmIGlvQmluZGluZ1N0YXRlKSB7XG4gICAgICBlcnJvckNvZGUgPSBhd2FpdCB3YXNtLl9PcnRSdW5XaXRoQmluZGluZyhcbiAgICAgICAgc2Vzc2lvbkhhbmRsZSxcbiAgICAgICAgaW9CaW5kaW5nU3RhdGUuaGFuZGxlLFxuICAgICAgICBvdXRwdXRDb3VudCxcbiAgICAgICAgb3V0cHV0VmFsdWVzT2Zmc2V0LFxuICAgICAgICBydW5PcHRpb25zSGFuZGxlLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3JDb2RlID0gYXdhaXQgd2FzbS5fT3J0UnVuKFxuICAgICAgICBzZXNzaW9uSGFuZGxlLFxuICAgICAgICBpbnB1dE5hbWVzT2Zmc2V0LFxuICAgICAgICBpbnB1dFZhbHVlc09mZnNldCxcbiAgICAgICAgaW5wdXRDb3VudCxcbiAgICAgICAgb3V0cHV0TmFtZXNPZmZzZXQsXG4gICAgICAgIG91dHB1dENvdW50LFxuICAgICAgICBvdXRwdXRWYWx1ZXNPZmZzZXQsXG4gICAgICAgIHJ1bk9wdGlvbnNIYW5kbGUsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChlcnJvckNvZGUgIT09IDApIHtcbiAgICAgIGNoZWNrTGFzdEVycm9yKCdmYWlsZWQgdG8gY2FsbCBPcnRSdW4oKS4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBvdXRwdXQ6IFRlbnNvck1ldGFkYXRhW10gPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Q291bnQ7IGkrKykge1xuICAgICAgY29uc3QgdGVuc29yID0gd2FzbS5IRUFQVTMyW291dHB1dFZhbHVlc09mZnNldCAvIDQgKyBpXTtcbiAgICAgIGlmICh0ZW5zb3IgPT09IG91dHB1dFRlbnNvckhhbmRsZXNbaV0pIHtcbiAgICAgICAgLy8gb3V0cHV0IHRlbnNvciBpcyBwcmUtYWxsb2NhdGVkLiBubyBuZWVkIHRvIGNvcHkgZGF0YS5cbiAgICAgICAgb3V0cHV0LnB1c2gob3V0cHV0VGVuc29yc1tpXSEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYmVmb3JlR2V0VGVuc29yRGF0YVN0YWNrID0gd2FzbS5zdGFja1NhdmUoKTtcbiAgICAgIC8vIHN0YWNrIGFsbG9jYXRlIDQgcG9pbnRlciB2YWx1ZVxuICAgICAgY29uc3QgdGVuc29yRGF0YU9mZnNldCA9IHdhc20uc3RhY2tBbGxvYyg0ICogNCk7XG5cbiAgICAgIGxldCBrZWVwT3V0cHV0VGVuc29yID0gZmFsc2U7XG4gICAgICBsZXQgdHlwZTogVGVuc29yLlR5cGUgfCB1bmRlZmluZWQsXG4gICAgICAgIGRhdGFPZmZzZXQgPSAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gd2FzbS5fT3J0R2V0VGVuc29yRGF0YShcbiAgICAgICAgICB0ZW5zb3IsXG4gICAgICAgICAgdGVuc29yRGF0YU9mZnNldCxcbiAgICAgICAgICB0ZW5zb3JEYXRhT2Zmc2V0ICsgNCxcbiAgICAgICAgICB0ZW5zb3JEYXRhT2Zmc2V0ICsgOCxcbiAgICAgICAgICB0ZW5zb3JEYXRhT2Zmc2V0ICsgMTIsXG4gICAgICAgICk7XG4gICAgICAgIGlmIChlcnJvckNvZGUgIT09IDApIHtcbiAgICAgICAgICBjaGVja0xhc3RFcnJvcihgQ2FuJ3QgYWNjZXNzIG91dHB1dCB0ZW5zb3IgZGF0YSBvbiBpbmRleCAke2l9LmApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0ZW5zb3JEYXRhSW5kZXggPSB0ZW5zb3JEYXRhT2Zmc2V0IC8gNDtcbiAgICAgICAgY29uc3QgZGF0YVR5cGUgPSB3YXNtLkhFQVBVMzJbdGVuc29yRGF0YUluZGV4KytdO1xuICAgICAgICBkYXRhT2Zmc2V0ID0gd2FzbS5IRUFQVTMyW3RlbnNvckRhdGFJbmRleCsrXTtcbiAgICAgICAgY29uc3QgZGltc09mZnNldCA9IHdhc20uSEVBUFUzMlt0ZW5zb3JEYXRhSW5kZXgrK107XG4gICAgICAgIGNvbnN0IGRpbXNMZW5ndGggPSB3YXNtLkhFQVBVMzJbdGVuc29yRGF0YUluZGV4KytdO1xuICAgICAgICBjb25zdCBkaW1zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZGltcy5wdXNoKHdhc20uSEVBUFUzMltkaW1zT2Zmc2V0IC8gNCArIGldKTtcbiAgICAgICAgfVxuICAgICAgICB3YXNtLl9PcnRGcmVlKGRpbXNPZmZzZXQpO1xuXG4gICAgICAgIGNvbnN0IHNpemUgPSBkaW1zLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIsIDEpO1xuICAgICAgICB0eXBlID0gdGVuc29yRGF0YVR5cGVFbnVtVG9TdHJpbmcoZGF0YVR5cGUpO1xuXG4gICAgICAgIGNvbnN0IHByZWZlcnJlZExvY2F0aW9uID0gaW9CaW5kaW5nU3RhdGU/Lm91dHB1dFByZWZlcnJlZExvY2F0aW9uc1tvdXRwdXRJbmRpY2VzW2ldXTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAocHJlZmVycmVkTG9jYXRpb24gPT09ICdncHUtYnVmZmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzdHJpbmdEYXRhOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICAgIGxldCBkYXRhSW5kZXggPSBkYXRhT2Zmc2V0IC8gNDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2FzbS5IRUFQVTMyW2RhdGFJbmRleCsrXTtcbiAgICAgICAgICAgIGNvbnN0IG1heEJ5dGVzVG9SZWFkID0gaSA9PT0gc2l6ZSAtIDEgPyB1bmRlZmluZWQgOiB3YXNtLkhFQVBVMzJbZGF0YUluZGV4XSAtIG9mZnNldDtcbiAgICAgICAgICAgIHN0cmluZ0RhdGEucHVzaCh3YXNtLlVURjhUb1N0cmluZyhvZmZzZXQsIG1heEJ5dGVzVG9SZWFkKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dHB1dC5wdXNoKFt0eXBlLCBkaW1zLCBzdHJpbmdEYXRhLCAnY3B1J10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIGEgY2VydGFpbiBvdXRwdXQncyBwcmVmZXJyZWQgbG9jYXRpb24gaXMgR1BVIGJ1dCB0aGUgdGVuc29yIGlzIGVtcHR5LCB3ZSBzdGlsbCBuZWVkIHRvIGNyZWF0ZSBhIENQVVxuICAgICAgICAgIC8vIHRlbnNvciBmb3IgaXQuIFRoZXJlIGlzIG5vIG1hcHBpbmcgR1BVIGJ1ZmZlciBmb3IgYW4gZW1wdHkgdGVuc29yLlxuICAgICAgICAgIGlmIChwcmVmZXJyZWRMb2NhdGlvbiA9PT0gJ2dwdS1idWZmZXInICYmIHNpemUgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBnZXRCdWZmZXIgPSB3YXNtLmpzZXBHZXRCdWZmZXI7XG4gICAgICAgICAgICBpZiAoIWdldEJ1ZmZlcikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZWZlcnJlZExvY2F0aW9uIFwiZ3B1LWJ1ZmZlclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJHUFUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBncHVCdWZmZXIgPSBnZXRCdWZmZXIoZGF0YU9mZnNldCk7XG4gICAgICAgICAgICBjb25zdCBidWZmZXJTaXplID0gY2FsY3VsYXRlVGVuc29yU2l6ZUluQnl0ZXMoZGF0YVR5cGUsIHNpemUpO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlclNpemUgPT09IHVuZGVmaW5lZCB8fCAhaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R5cGV9YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRvIG5vdCByZWxlYXNlIHRoZSB0ZW5zb3IgcmlnaHQgbm93LiBpdCB3aWxsIGJlIHJlbGVhc2VkIHdoZW4gdXNlciBjYWxscyB0ZW5zb3IuZGlzcG9zZSgpLlxuICAgICAgICAgICAga2VlcE91dHB1dFRlbnNvciA9IHRydWU7XG5cbiAgICAgICAgICAgIG91dHB1dC5wdXNoKFtcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgZGltcyxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGdwdUJ1ZmZlcixcbiAgICAgICAgICAgICAgICBkb3dubG9hZDogd2FzbS5qc2VwQ3JlYXRlRG93bmxvYWRlciEoZ3B1QnVmZmVyLCBidWZmZXJTaXplLCB0eXBlKSxcbiAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICB3YXNtLl9PcnRSZWxlYXNlVGVuc29yKHRlbnNvcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgJ2dwdS1idWZmZXInLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IHRlbnNvclR5cGVUb1R5cGVkQXJyYXlDb25zdHJ1Y3Rvcih0eXBlKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgdHlwZWRBcnJheUNvbnN0cnVjdG9yKHNpemUpO1xuICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKS5zZXQoXG4gICAgICAgICAgICAgIHdhc20uSEVBUFU4LnN1YmFycmF5KGRhdGFPZmZzZXQsIGRhdGFPZmZzZXQgKyBkYXRhLmJ5dGVMZW5ndGgpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKFt0eXBlLCBkaW1zLCBkYXRhLCAnY3B1J10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgd2FzbS5zdGFja1Jlc3RvcmUoYmVmb3JlR2V0VGVuc29yRGF0YVN0YWNrKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIGRhdGFPZmZzZXQpIHtcbiAgICAgICAgICB3YXNtLl9mcmVlKGRhdGFPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgha2VlcE91dHB1dFRlbnNvcikge1xuICAgICAgICAgIHdhc20uX09ydFJlbGVhc2VUZW5zb3IodGVuc29yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpb0JpbmRpbmdTdGF0ZSAmJiAhZW5hYmxlR3JhcGhDYXB0dXJlKSB7XG4gICAgICB3YXNtLl9PcnRDbGVhckJvdW5kT3V0cHV0cyhpb0JpbmRpbmdTdGF0ZS5oYW5kbGUpO1xuICAgICAgYWN0aXZlU2Vzc2lvbnMuc2V0KHNlc3Npb25JZCwgW1xuICAgICAgICBzZXNzaW9uSGFuZGxlLFxuICAgICAgICBpbnB1dE5hbWVzVVRGOEVuY29kZWQsXG4gICAgICAgIG91dHB1dE5hbWVzVVRGOEVuY29kZWQsXG4gICAgICAgIGlvQmluZGluZ1N0YXRlLFxuICAgICAgICBlbmFibGVHcmFwaENhcHR1cmUsXG4gICAgICAgIGZhbHNlLFxuICAgICAgXSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH0gZmluYWxseSB7XG4gICAgd2FzbS5zdGFja1Jlc3RvcmUoYmVmb3JlUnVuU3RhY2spO1xuXG4gICAgaW5wdXRUZW5zb3JIYW5kbGVzLmZvckVhY2goKHYpID0+IHdhc20uX09ydFJlbGVhc2VUZW5zb3IodikpO1xuICAgIG91dHB1dFRlbnNvckhhbmRsZXMuZm9yRWFjaCgodikgPT4gd2FzbS5fT3J0UmVsZWFzZVRlbnNvcih2KSk7XG4gICAgaW5wdXRPdXRwdXRBbGxvY3MuZm9yRWFjaCgocCkgPT4gd2FzbS5fZnJlZShwKSk7XG5cbiAgICBpZiAocnVuT3B0aW9uc0hhbmRsZSAhPT0gMCkge1xuICAgICAgd2FzbS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMocnVuT3B0aW9uc0hhbmRsZSk7XG4gICAgfVxuICAgIHJ1bk9wdGlvbnNBbGxvY3MuZm9yRWFjaCgocCkgPT4gd2FzbS5fZnJlZShwKSk7XG4gIH1cbn07XG5cbi8qKlxuICogZW5kIHByb2ZpbGluZ1xuICovXG5leHBvcnQgY29uc3QgZW5kUHJvZmlsaW5nID0gKHNlc3Npb25JZDogbnVtYmVyKTogdm9pZCA9PiB7XG4gIGNvbnN0IHdhc20gPSBnZXRJbnN0YW5jZSgpO1xuICBjb25zdCBzZXNzaW9uID0gYWN0aXZlU2Vzc2lvbnMuZ2V0KHNlc3Npb25JZCk7XG4gIGlmICghc2Vzc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzZXNzaW9uIGlkJyk7XG4gIH1cbiAgY29uc3Qgc2Vzc2lvbkhhbmRsZSA9IHNlc3Npb25bMF07XG5cbiAgLy8gcHJvZmlsZSBmaWxlIG5hbWUgaXMgbm90IHVzZWQgeWV0LCBidXQgaXQgbXVzdCBiZSBmcmVlZC5cbiAgY29uc3QgcHJvZmlsZUZpbGVOYW1lID0gd2FzbS5fT3J0RW5kUHJvZmlsaW5nKHNlc3Npb25IYW5kbGUpO1xuICBpZiAocHJvZmlsZUZpbGVOYW1lID09PSAwKSB7XG4gICAgY2hlY2tMYXN0RXJyb3IoXCJDYW4ndCBnZXQgYW4gcHJvZmlsZSBmaWxlIG5hbWUuXCIpO1xuICB9XG4gIHdhc20uX09ydEZyZWUocHJvZmlsZUZpbGVOYW1lKTtcbn07XG5cbmV4cG9ydCBjb25zdCBleHRyYWN0VHJhbnNmZXJhYmxlQnVmZmVycyA9ICh0ZW5zb3JzOiByZWFkb25seSBTZXJpYWxpemFibGVUZW5zb3JNZXRhZGF0YVtdKTogQXJyYXlCdWZmZXJMaWtlW10gPT4ge1xuICBjb25zdCBidWZmZXJzOiBBcnJheUJ1ZmZlckxpa2VbXSA9IFtdO1xuICBmb3IgKGNvbnN0IHRlbnNvciBvZiB0ZW5zb3JzKSB7XG4gICAgY29uc3QgZGF0YSA9IHRlbnNvclsyXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkgJiYgJ2J1ZmZlcicgaW4gZGF0YSkge1xuICAgICAgYnVmZmVycy5wdXNoKGRhdGEuYnVmZmVyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlcnM7XG59O1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG5pbXBvcnQgeyBlbnYsIEluZmVyZW5jZVNlc3Npb24gfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQge1xuICBPcnRXYXNtTWVzc2FnZSxcbiAgU2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXIsXG4gIFNlcmlhbGl6YWJsZVNlc3Npb25NZXRhZGF0YSxcbiAgU2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGEsXG4gIFRlbnNvck1ldGFkYXRhLFxufSBmcm9tICcuL3Byb3h5LW1lc3NhZ2VzJztcbmltcG9ydCAqIGFzIGNvcmUgZnJvbSAnLi93YXNtLWNvcmUtaW1wbCc7XG5pbXBvcnQgeyBpbml0aWFsaXplV2ViQXNzZW1ibHkgfSBmcm9tICcuL3dhc20tZmFjdG9yeSc7XG5pbXBvcnQgeyBpbXBvcnRQcm94eVdvcmtlciB9IGZyb20gJy4vd2FzbS11dGlscy1pbXBvcnQnO1xuXG5jb25zdCBpc1Byb3h5ID0gKCk6IGJvb2xlYW4gPT4gISFlbnYud2FzbS5wcm94eSAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xubGV0IHByb3h5V29ya2VyOiBXb3JrZXIgfCB1bmRlZmluZWQ7XG5sZXQgaW5pdGlhbGl6aW5nID0gZmFsc2U7XG5sZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbmxldCBhYm9ydGVkID0gZmFsc2U7XG5sZXQgdGVtcG9yYXJ5T2JqZWN0VXJsOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbnR5cGUgUHJvbWlzZUNhbGxiYWNrczxUID0gdm9pZD4gPSBbcmVzb2x2ZTogKHJlc3VsdDogVCkgPT4gdm9pZCwgcmVqZWN0OiAocmVhc29uOiB1bmtub3duKSA9PiB2b2lkXTtcbmxldCBpbml0V2FzbUNhbGxiYWNrczogUHJvbWlzZUNhbGxiYWNrcztcbmNvbnN0IHF1ZXVlZENhbGxiYWNrczogTWFwPE9ydFdhc21NZXNzYWdlWyd0eXBlJ10sIEFycmF5PFByb21pc2VDYWxsYmFja3M8dW5rbm93bj4+PiA9IG5ldyBNYXAoKTtcblxuY29uc3QgZW5xdWV1ZUNhbGxiYWNrcyA9ICh0eXBlOiBPcnRXYXNtTWVzc2FnZVsndHlwZSddLCBjYWxsYmFja3M6IFByb21pc2VDYWxsYmFja3M8dW5rbm93bj4pOiB2b2lkID0+IHtcbiAgY29uc3QgcXVldWUgPSBxdWV1ZWRDYWxsYmFja3MuZ2V0KHR5cGUpO1xuICBpZiAocXVldWUpIHtcbiAgICBxdWV1ZS5wdXNoKGNhbGxiYWNrcyk7XG4gIH0gZWxzZSB7XG4gICAgcXVldWVkQ2FsbGJhY2tzLnNldCh0eXBlLCBbY2FsbGJhY2tzXSk7XG4gIH1cbn07XG5cbmNvbnN0IGVuc3VyZVdvcmtlciA9ICgpOiB2b2lkID0+IHtcbiAgaWYgKGluaXRpYWxpemluZyB8fCAhaW5pdGlhbGl6ZWQgfHwgYWJvcnRlZCB8fCAhcHJveHlXb3JrZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3dvcmtlciBub3QgcmVhZHknKTtcbiAgfVxufTtcblxuY29uc3Qgb25Qcm94eVdvcmtlck1lc3NhZ2UgPSAoZXY6IE1lc3NhZ2VFdmVudDxPcnRXYXNtTWVzc2FnZT4pOiB2b2lkID0+IHtcbiAgc3dpdGNoIChldi5kYXRhLnR5cGUpIHtcbiAgICBjYXNlICdpbml0LXdhc20nOlxuICAgICAgaW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgICBpZiAoZXYuZGF0YS5lcnIpIHtcbiAgICAgICAgYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIGluaXRXYXNtQ2FsbGJhY2tzWzFdKGV2LmRhdGEuZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgaW5pdFdhc21DYWxsYmFja3NbMF0oKTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZW1wb3JhcnlPYmplY3RVcmwpIHtcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh0ZW1wb3JhcnlPYmplY3RVcmwpO1xuICAgICAgICB0ZW1wb3JhcnlPYmplY3RVcmwgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbml0LWVwJzpcbiAgICBjYXNlICdjb3B5LWZyb20nOlxuICAgIGNhc2UgJ2NyZWF0ZSc6XG4gICAgY2FzZSAncmVsZWFzZSc6XG4gICAgY2FzZSAncnVuJzpcbiAgICBjYXNlICdlbmQtcHJvZmlsaW5nJzoge1xuICAgICAgY29uc3QgY2FsbGJhY2tzID0gcXVldWVkQ2FsbGJhY2tzLmdldChldi5kYXRhLnR5cGUpITtcbiAgICAgIGlmIChldi5kYXRhLmVycikge1xuICAgICAgICBjYWxsYmFja3Muc2hpZnQoKSFbMV0oZXYuZGF0YS5lcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2tzLnNoaWZ0KCkhWzBdKGV2LmRhdGEub3V0ISk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGluaXRpYWxpemVXZWJBc3NlbWJseUFuZE9ydFJ1bnRpbWUgPSBhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGlmIChpbml0aWFsaXplZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaW5pdGlhbGl6aW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gJ2luaXRXYXNtKCknIGRldGVjdGVkLlwiKTtcbiAgfVxuICBpZiAoYWJvcnRlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGNhbGwgdG8gJ2luaXRXYXNtKCknIGZhaWxlZC5cIik7XG4gIH1cblxuICBpbml0aWFsaXppbmcgPSB0cnVlO1xuXG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgJiYgaXNQcm94eSgpKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHByb3h5V29ya2VyPy50ZXJtaW5hdGUoKTtcblxuICAgICAgdm9pZCBpbXBvcnRQcm94eVdvcmtlcigpLnRoZW4oKFtvYmplY3RVcmwsIHdvcmtlcl0pID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwcm94eVdvcmtlciA9IHdvcmtlcjtcbiAgICAgICAgICBwcm94eVdvcmtlci5vbmVycm9yID0gKGV2OiBFcnJvckV2ZW50KSA9PiByZWplY3QoZXYpO1xuICAgICAgICAgIHByb3h5V29ya2VyLm9ubWVzc2FnZSA9IG9uUHJveHlXb3JrZXJNZXNzYWdlO1xuICAgICAgICAgIGluaXRXYXNtQ2FsbGJhY2tzID0gW3Jlc29sdmUsIHJlamVjdF07XG4gICAgICAgICAgY29uc3QgbWVzc2FnZTogT3J0V2FzbU1lc3NhZ2UgPSB7IHR5cGU6ICdpbml0LXdhc20nLCBpbjogZW52IH07XG4gICAgICAgICAgcHJveHlXb3JrZXIucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgdGVtcG9yYXJ5T2JqZWN0VXJsID0gb2JqZWN0VXJsO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICB9LCByZWplY3QpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBpbml0aWFsaXplV2ViQXNzZW1ibHkoZW52Lndhc20pO1xuICAgICAgYXdhaXQgY29yZS5pbml0UnVudGltZShlbnYpO1xuICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGFib3J0ZWQgPSB0cnVlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZU9ydEVwID0gYXN5bmMgKGVwTmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgJiYgaXNQcm94eSgpKSB7XG4gICAgZW5zdXJlV29ya2VyKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGVucXVldWVDYWxsYmFja3MoJ2luaXQtZXAnLCBbcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHsgdHlwZTogJ2luaXQtZXAnLCBpbjogeyBlcE5hbWUsIGVudiB9IH07XG4gICAgICBwcm94eVdvcmtlciEucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYXdhaXQgY29yZS5pbml0RXAoZW52LCBlcE5hbWUpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgY29weUZyb21FeHRlcm5hbEJ1ZmZlciA9IGFzeW5jIChidWZmZXI6IFVpbnQ4QXJyYXkpOiBQcm9taXNlPFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyPiA9PiB7XG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgJiYgaXNQcm94eSgpKSB7XG4gICAgZW5zdXJlV29ya2VyKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBlbnF1ZXVlQ2FsbGJhY2tzKCdjb3B5LWZyb20nLCBbcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHsgdHlwZTogJ2NvcHktZnJvbScsIGluOiB7IGJ1ZmZlciB9IH07XG4gICAgICBwcm94eVdvcmtlciEucG9zdE1lc3NhZ2UobWVzc2FnZSwgW2J1ZmZlci5idWZmZXJdKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29yZS5jb3B5RnJvbUV4dGVybmFsQnVmZmVyKGJ1ZmZlcik7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVTZXNzaW9uID0gYXN5bmMgKFxuICBtb2RlbDogU2VyaWFsaXphYmxlSW50ZXJuYWxCdWZmZXIgfCBVaW50OEFycmF5LFxuICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcbik6IFByb21pc2U8U2VyaWFsaXphYmxlU2Vzc2lvbk1ldGFkYXRhPiA9PiB7XG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgJiYgaXNQcm94eSgpKSB7XG4gICAgLy8gY2hlY2sgdW5zdXBwb3J0ZWQgb3B0aW9uc1xuICAgIGlmIChvcHRpb25zPy5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXNzaW9uIG9wdGlvbiBcInByZWZlcnJlZE91dHB1dExvY2F0aW9uXCIgaXMgbm90IHN1cHBvcnRlZCBmb3IgcHJveHkuJyk7XG4gICAgfVxuICAgIGVuc3VyZVdvcmtlcigpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTxTZXJpYWxpemFibGVTZXNzaW9uTWV0YWRhdGE+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGVucXVldWVDYWxsYmFja3MoJ2NyZWF0ZScsIFtyZXNvbHZlLCByZWplY3RdKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2U6IE9ydFdhc21NZXNzYWdlID0geyB0eXBlOiAnY3JlYXRlJywgaW46IHsgbW9kZWwsIG9wdGlvbnM6IHsgLi4ub3B0aW9ucyB9IH0gfTtcbiAgICAgIGNvbnN0IHRyYW5zZmVyYWJsZTogVHJhbnNmZXJhYmxlW10gPSBbXTtcbiAgICAgIGlmIChtb2RlbCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgdHJhbnNmZXJhYmxlLnB1c2gobW9kZWwuYnVmZmVyKTtcbiAgICAgIH1cbiAgICAgIHByb3h5V29ya2VyIS5wb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2ZlcmFibGUpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb3JlLmNyZWF0ZVNlc3Npb24obW9kZWwsIG9wdGlvbnMpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgcmVsZWFzZVNlc3Npb24gPSBhc3luYyAoc2Vzc2lvbklkOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTV9QUk9YWSAmJiBpc1Byb3h5KCkpIHtcbiAgICBlbnN1cmVXb3JrZXIoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZW5xdWV1ZUNhbGxiYWNrcygncmVsZWFzZScsIFtyZXNvbHZlLCByZWplY3RdKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2U6IE9ydFdhc21NZXNzYWdlID0geyB0eXBlOiAncmVsZWFzZScsIGluOiBzZXNzaW9uSWQgfTtcbiAgICAgIHByb3h5V29ya2VyIS5wb3N0TWVzc2FnZShtZXNzYWdlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb3JlLnJlbGVhc2VTZXNzaW9uKHNlc3Npb25JZCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBydW4gPSBhc3luYyAoXG4gIHNlc3Npb25JZDogbnVtYmVyLFxuICBpbnB1dEluZGljZXM6IG51bWJlcltdLFxuICBpbnB1dHM6IFRlbnNvck1ldGFkYXRhW10sXG4gIG91dHB1dEluZGljZXM6IG51bWJlcltdLFxuICBvdXRwdXRzOiBBcnJheTxUZW5zb3JNZXRhZGF0YSB8IG51bGw+LFxuICBvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMsXG4pOiBQcm9taXNlPFRlbnNvck1ldGFkYXRhW10+ID0+IHtcbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfV0FTTV9QUk9YWSAmJiBpc1Byb3h5KCkpIHtcbiAgICAvLyBjaGVjayBpbnB1dHMgbG9jYXRpb25cbiAgICBpZiAoaW5wdXRzLnNvbWUoKHQpID0+IHRbM10gIT09ICdjcHUnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCB0ZW5zb3Igb24gR1BVIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LicpO1xuICAgIH1cbiAgICAvLyBjaGVjayBvdXRwdXRzIGxvY2F0aW9uXG4gICAgaWYgKG91dHB1dHMuc29tZSgodCkgPT4gdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncHJlLWFsbG9jYXRlZCBvdXRwdXQgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LicpO1xuICAgIH1cbiAgICBlbnN1cmVXb3JrZXIoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8U2VyaWFsaXphYmxlVGVuc29yTWV0YWRhdGFbXT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZW5xdWV1ZUNhbGxiYWNrcygncnVuJywgW3Jlc29sdmUsIHJlamVjdF0pO1xuICAgICAgY29uc3Qgc2VyaWFsaXphYmxlSW5wdXRzID0gaW5wdXRzIGFzIFNlcmlhbGl6YWJsZVRlbnNvck1ldGFkYXRhW107IC8vIGV2ZXJ5IGlucHV0IGlzIG9uIENQVS5cbiAgICAgIGNvbnN0IG1lc3NhZ2U6IE9ydFdhc21NZXNzYWdlID0ge1xuICAgICAgICB0eXBlOiAncnVuJyxcbiAgICAgICAgaW46IHsgc2Vzc2lvbklkLCBpbnB1dEluZGljZXMsIGlucHV0czogc2VyaWFsaXphYmxlSW5wdXRzLCBvdXRwdXRJbmRpY2VzLCBvcHRpb25zIH0sXG4gICAgICB9O1xuICAgICAgcHJveHlXb3JrZXIhLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIGNvcmUuZXh0cmFjdFRyYW5zZmVyYWJsZUJ1ZmZlcnMoc2VyaWFsaXphYmxlSW5wdXRzKSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvcmUucnVuKHNlc3Npb25JZCwgaW5wdXRJbmRpY2VzLCBpbnB1dHMsIG91dHB1dEluZGljZXMsIG91dHB1dHMsIG9wdGlvbnMpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZW5kUHJvZmlsaW5nID0gYXN5bmMgKHNlc3Npb25JZDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX1dBU01fUFJPWFkgJiYgaXNQcm94eSgpKSB7XG4gICAgZW5zdXJlV29ya2VyKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGVucXVldWVDYWxsYmFja3MoJ2VuZC1wcm9maWxpbmcnLCBbcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICBjb25zdCBtZXNzYWdlOiBPcnRXYXNtTWVzc2FnZSA9IHsgdHlwZTogJ2VuZC1wcm9maWxpbmcnLCBpbjogc2Vzc2lvbklkIH07XG4gICAgICBwcm94eVdvcmtlciEucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29yZS5lbmRQcm9maWxpbmcoc2Vzc2lvbklkKTtcbiAgfVxufTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuaW1wb3J0IHtcbiAgSW5mZXJlbmNlU2Vzc2lvbixcbiAgSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIsXG4gIFNlc3Npb25IYW5kbGVyLFxuICBUZW5zb3IsXG4gIFRSQUNFX0ZVTkNfQkVHSU4sXG4gIFRSQUNFX0ZVTkNfRU5ELFxufSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgeyBTZXJpYWxpemFibGVJbnRlcm5hbEJ1ZmZlciwgVGVuc29yTWV0YWRhdGEgfSBmcm9tICcuL3Byb3h5LW1lc3NhZ2VzJztcbmltcG9ydCB7IGNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIsIGNyZWF0ZVNlc3Npb24sIGVuZFByb2ZpbGluZywgcmVsZWFzZVNlc3Npb24sIHJ1biB9IGZyb20gJy4vcHJveHktd3JhcHBlcic7XG5pbXBvcnQgeyBpc0dwdUJ1ZmZlclN1cHBvcnRlZFR5cGUgfSBmcm9tICcuL3dhc20tY29tbW9uJztcbmltcG9ydCB7IGlzTm9kZSB9IGZyb20gJy4vd2FzbS11dGlscy1lbnYnO1xuaW1wb3J0IHsgbG9hZEZpbGUgfSBmcm9tICcuL3dhc20tdXRpbHMtbG9hZC1maWxlJztcblxuZXhwb3J0IGNvbnN0IGVuY29kZVRlbnNvck1ldGFkYXRhID0gKHRlbnNvcjogVGVuc29yLCBnZXROYW1lOiAoKSA9PiBzdHJpbmcpOiBUZW5zb3JNZXRhZGF0YSA9PiB7XG4gIHN3aXRjaCAodGVuc29yLmxvY2F0aW9uKSB7XG4gICAgY2FzZSAnY3B1JzpcbiAgICAgIHJldHVybiBbdGVuc29yLnR5cGUsIHRlbnNvci5kaW1zLCB0ZW5zb3IuZGF0YSwgJ2NwdSddO1xuICAgIGNhc2UgJ2dwdS1idWZmZXInOlxuICAgICAgcmV0dXJuIFt0ZW5zb3IudHlwZSwgdGVuc29yLmRpbXMsIHsgZ3B1QnVmZmVyOiB0ZW5zb3IuZ3B1QnVmZmVyIH0sICdncHUtYnVmZmVyJ107XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkYXRhIGxvY2F0aW9uOiAke3RlbnNvci5sb2NhdGlvbn0gZm9yICR7Z2V0TmFtZSgpfWApO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZGVjb2RlVGVuc29yTWV0YWRhdGEgPSAodGVuc29yOiBUZW5zb3JNZXRhZGF0YSk6IFRlbnNvciA9PiB7XG4gIHN3aXRjaCAodGVuc29yWzNdKSB7XG4gICAgY2FzZSAnY3B1JzpcbiAgICAgIHJldHVybiBuZXcgVGVuc29yKHRlbnNvclswXSwgdGVuc29yWzJdLCB0ZW5zb3JbMV0pO1xuICAgIGNhc2UgJ2dwdS1idWZmZXInOiB7XG4gICAgICBjb25zdCBkYXRhVHlwZSA9IHRlbnNvclswXTtcbiAgICAgIGlmICghaXNHcHVCdWZmZXJTdXBwb3J0ZWRUeXBlKGRhdGFUeXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2RhdGFUeXBlfSBmb3IgZGVzZXJpYWxpemluZyBHUFUgdGVuc29yYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IGdwdUJ1ZmZlciwgZG93bmxvYWQsIGRpc3Bvc2UgfSA9IHRlbnNvclsyXTtcbiAgICAgIHJldHVybiBUZW5zb3IuZnJvbUdwdUJ1ZmZlcihncHVCdWZmZXIsIHsgZGF0YVR5cGUsIGRpbXM6IHRlbnNvclsxXSwgZG93bmxvYWQsIGRpc3Bvc2UgfSk7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGF0YSBsb2NhdGlvbjogJHt0ZW5zb3JbM119YCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjbGFzcyBPbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXIgaW1wbGVtZW50cyBJbmZlcmVuY2VTZXNzaW9uSGFuZGxlciB7XG4gIHByaXZhdGUgc2Vzc2lvbklkOiBudW1iZXI7XG5cbiAgaW5wdXROYW1lczogc3RyaW5nW107XG4gIG91dHB1dE5hbWVzOiBzdHJpbmdbXTtcblxuICBhc3luYyBmZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeShwYXRoOiBzdHJpbmcpOiBQcm9taXNlPFNlcmlhbGl6YWJsZUludGVybmFsQnVmZmVyPiB7XG4gICAgLy8gZmV0Y2ggbW9kZWwgZnJvbSB1cmwgYW5kIG1vdmUgdG8gd2FzbSBoZWFwLlxuICAgIHJldHVybiBjb3B5RnJvbUV4dGVybmFsQnVmZmVyKGF3YWl0IGxvYWRGaWxlKHBhdGgpKTtcbiAgfVxuXG4gIGFzeW5jIGxvYWRNb2RlbChwYXRoT3JCdWZmZXI6IHN0cmluZyB8IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBJbmZlcmVuY2VTZXNzaW9uLlNlc3Npb25PcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgVFJBQ0VfRlVOQ19CRUdJTigpO1xuICAgIGxldCBtb2RlbDogUGFyYW1ldGVyczx0eXBlb2YgY3JlYXRlU2Vzc2lvbj5bMF07XG5cbiAgICBpZiAodHlwZW9mIHBhdGhPckJ1ZmZlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChpc05vZGUpIHtcbiAgICAgICAgLy8gbm9kZVxuICAgICAgICBtb2RlbCA9IGF3YWl0IGxvYWRGaWxlKHBhdGhPckJ1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBicm93c2VyXG4gICAgICAgIC8vIGZldGNoIG1vZGVsIGFuZCBjb3B5IHRvIHdhc20gaGVhcC5cbiAgICAgICAgbW9kZWwgPSBhd2FpdCB0aGlzLmZldGNoTW9kZWxBbmRDb3B5VG9XYXNtTWVtb3J5KHBhdGhPckJ1ZmZlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGVsID0gcGF0aE9yQnVmZmVyO1xuICAgIH1cblxuICAgIFt0aGlzLnNlc3Npb25JZCwgdGhpcy5pbnB1dE5hbWVzLCB0aGlzLm91dHB1dE5hbWVzXSA9IGF3YWl0IGNyZWF0ZVNlc3Npb24obW9kZWwsIG9wdGlvbnMpO1xuICAgIFRSQUNFX0ZVTkNfRU5EKCk7XG4gIH1cblxuICBhc3luYyBkaXNwb3NlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiByZWxlYXNlU2Vzc2lvbih0aGlzLnNlc3Npb25JZCk7XG4gIH1cblxuICBhc3luYyBydW4oXG4gICAgZmVlZHM6IFNlc3Npb25IYW5kbGVyLkZlZWRzVHlwZSxcbiAgICBmZXRjaGVzOiBTZXNzaW9uSGFuZGxlci5GZXRjaGVzVHlwZSxcbiAgICBvcHRpb25zOiBJbmZlcmVuY2VTZXNzaW9uLlJ1bk9wdGlvbnMsXG4gICk6IFByb21pc2U8U2Vzc2lvbkhhbmRsZXIuUmV0dXJuVHlwZT4ge1xuICAgIFRSQUNFX0ZVTkNfQkVHSU4oKTtcbiAgICBjb25zdCBpbnB1dEFycmF5OiBUZW5zb3JbXSA9IFtdO1xuICAgIGNvbnN0IGlucHV0SW5kaWNlczogbnVtYmVyW10gPSBbXTtcbiAgICBPYmplY3QuZW50cmllcyhmZWVkcykuZm9yRWFjaCgoa3ZwKSA9PiB7XG4gICAgICBjb25zdCBuYW1lID0ga3ZwWzBdO1xuICAgICAgY29uc3QgdGVuc29yID0ga3ZwWzFdO1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmlucHV0TmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGlucHV0ICcke25hbWV9J2ApO1xuICAgICAgfVxuICAgICAgaW5wdXRBcnJheS5wdXNoKHRlbnNvcik7XG4gICAgICBpbnB1dEluZGljZXMucHVzaChpbmRleCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBvdXRwdXRBcnJheTogQXJyYXk8VGVuc29yIHwgbnVsbD4gPSBbXTtcbiAgICBjb25zdCBvdXRwdXRJbmRpY2VzOiBudW1iZXJbXSA9IFtdO1xuICAgIE9iamVjdC5lbnRyaWVzKGZldGNoZXMpLmZvckVhY2goKGt2cCkgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGt2cFswXTtcbiAgICAgIGNvbnN0IHRlbnNvciA9IGt2cFsxXTtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3V0cHV0ICcke25hbWV9J2ApO1xuICAgICAgfVxuICAgICAgb3V0cHV0QXJyYXkucHVzaCh0ZW5zb3IpO1xuICAgICAgb3V0cHV0SW5kaWNlcy5wdXNoKGluZGV4KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGlucHV0cyA9IGlucHV0QXJyYXkubWFwKCh0LCBpKSA9PlxuICAgICAgZW5jb2RlVGVuc29yTWV0YWRhdGEodCwgKCkgPT4gYGlucHV0IFwiJHt0aGlzLmlucHV0TmFtZXNbaW5wdXRJbmRpY2VzW2ldXX1cImApLFxuICAgICk7XG4gICAgY29uc3Qgb3V0cHV0cyA9IG91dHB1dEFycmF5Lm1hcCgodCwgaSkgPT5cbiAgICAgIHQgPyBlbmNvZGVUZW5zb3JNZXRhZGF0YSh0LCAoKSA9PiBgb3V0cHV0IFwiJHt0aGlzLm91dHB1dE5hbWVzW291dHB1dEluZGljZXNbaV1dfVwiYCkgOiBudWxsLFxuICAgICk7XG5cbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgcnVuKHRoaXMuc2Vzc2lvbklkLCBpbnB1dEluZGljZXMsIGlucHV0cywgb3V0cHV0SW5kaWNlcywgb3V0cHV0cywgb3B0aW9ucyk7XG5cbiAgICBjb25zdCByZXN1bHRNYXA6IFNlc3Npb25IYW5kbGVyLlJldHVyblR5cGUgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdE1hcFt0aGlzLm91dHB1dE5hbWVzW291dHB1dEluZGljZXNbaV1dXSA9IG91dHB1dEFycmF5W2ldID8/IGRlY29kZVRlbnNvck1ldGFkYXRhKHJlc3VsdHNbaV0pO1xuICAgIH1cbiAgICBUUkFDRV9GVU5DX0VORCgpO1xuICAgIHJldHVybiByZXN1bHRNYXA7XG4gIH1cblxuICBzdGFydFByb2ZpbGluZygpOiB2b2lkIHtcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgcHJvZmlsaW5nXG4gIH1cblxuICBlbmRQcm9maWxpbmcoKTogdm9pZCB7XG4gICAgdm9pZCBlbmRQcm9maWxpbmcodGhpcy5zZXNzaW9uSWQpO1xuICB9XG59XG4iLCAiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5cbmltcG9ydCB7IEJhY2tlbmQsIGVudiwgSW5mZXJlbmNlU2Vzc2lvbiwgSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIgfSBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuXG5pbXBvcnQgeyBpbml0aWFsaXplT3J0RXAsIGluaXRpYWxpemVXZWJBc3NlbWJseUFuZE9ydFJ1bnRpbWUgfSBmcm9tICcuL3dhc20vcHJveHktd3JhcHBlcic7XG5pbXBvcnQgeyBPbm54cnVudGltZVdlYkFzc2VtYmx5U2Vzc2lvbkhhbmRsZXIgfSBmcm9tICcuL3dhc20vc2Vzc2lvbi1oYW5kbGVyLWluZmVyZW5jZSc7XG5pbXBvcnQgeyBzY3JpcHRTcmMgfSBmcm9tICcuL3dhc20vd2FzbS11dGlscy1pbXBvcnQnO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaW5pdGlhbGl6ZXMgYWxsIGZsYWdzIGZvciBXZWJBc3NlbWJseS5cbiAqXG4gKiBUaG9zZSBmbGFncyBhcmUgYWNjZXNzaWJsZSBmcm9tIGBvcnQuZW52Lndhc21gLiBVc2VycyBhcmUgYWxsb3cgdG8gc2V0IHRob3NlIGZsYWdzIGJlZm9yZSB0aGUgZmlyc3QgaW5mZXJlbmNlIHNlc3Npb25cbiAqIGJlaW5nIGNyZWF0ZWQsIHRvIG92ZXJyaWRlIGRlZmF1bHQgdmFsdWUuXG4gKi9cbmV4cG9ydCBjb25zdCBpbml0aWFsaXplRmxhZ3MgPSAoKTogdm9pZCA9PiB7XG4gIGlmICh0eXBlb2YgZW52Lndhc20uaW5pdFRpbWVvdXQgIT09ICdudW1iZXInIHx8IGVudi53YXNtLmluaXRUaW1lb3V0IDwgMCkge1xuICAgIGVudi53YXNtLmluaXRUaW1lb3V0ID0gMDtcbiAgfVxuXG4gIGlmIChlbnYud2FzbS5zaW1kID09PSBmYWxzZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ0RlcHJlY2F0ZWQgcHJvcGVydHkgXCJlbnYud2FzbS5zaW1kXCIgaXMgc2V0IHRvIGZhbHNlLiAnICtcbiAgICAgICAgJ25vbi1TSU1EIGJ1aWxkIGlzIG5vIGxvbmdlciBwcm92aWRlZCwgYW5kIHRoaXMgc2V0dGluZyB3aWxsIGJlIGlnbm9yZWQuJyxcbiAgICApO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbnYud2FzbS5wcm94eSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgZW52Lndhc20ucHJveHkgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW52Lndhc20udHJhY2UgIT09ICdib29sZWFuJykge1xuICAgIGVudi53YXNtLnRyYWNlID0gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGVudi53YXNtLm51bVRocmVhZHMgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKGVudi53YXNtLm51bVRocmVhZHMpIHx8IGVudi53YXNtLm51bVRocmVhZHMgPD0gMCkge1xuICAgIC8vIFRoZSBmb2xsb3dpbmcgbG9naWMgb25seSBhcHBsaWVzIHdoZW4gYG9ydC5lbnYud2FzbS5udW1UaHJlYWRzYCBpcyBub3Qgc2V0IGJ5IHVzZXIuIFdlIHdpbGwgYWx3YXlzIGhvbm9yIHVzZXInc1xuICAgIC8vIHNldHRpbmcgaWYgaXQgaXMgcHJvdmlkZWQuXG5cbiAgICAvLyBCcm93c2VyOiB3aGVuIGNyb3NzT3JpZ2luSXNvbGF0ZWQgaXMgZmFsc2UsIFNoYXJlZEFycmF5QnVmZmVyIGlzIG5vdCBhdmFpbGFibGUgc28gV2ViQXNzZW1ibHkgdGhyZWFkcyB3aWxsIG5vdFxuICAgIC8vIHdvcmsuIEluIHRoaXMgY2FzZSwgd2Ugd2lsbCBzZXQgbnVtVGhyZWFkcyB0byAxLlxuICAgIC8vXG4gICAgLy8gVGhlcmUgaXMgYW4gZXhjZXB0aW9uOiB3aGVuIHRoZSBicm93c2VyIGlzIGNvbmZpZ3VyZWQgdG8gZm9yY2UtZW5hYmxlIFNoYXJlZEFycmF5QnVmZmVyIChlLmcuIENocm9tdWltIHdpdGhcbiAgICAvLyAtLWVuYWJsZS1mZWF0dXJlcz1TaGFyZWRBcnJheUJ1ZmZlciksIGl0IGlzIHBvc3NpYmxlIHRoYXQgYHNlbGYuY3Jvc3NPcmlnaW5Jc29sYXRlZGAgaXMgZmFsc2UgYW5kXG4gICAgLy8gU2hhcmVkQXJyYXlCdWZmZXIgaXMgYXZhaWxhYmxlIGF0IHRoZSBzYW1lIHRpbWUuIFRoaXMgaXMgdXN1YWxseSBmb3IgdGVzdGluZy4gSW4gdGhpcyBjYXNlLCAgd2Ugd2lsbCBzdGlsbCBzZXRcbiAgICAvLyBudW1UaHJlYWRzIHRvIDEgaGVyZS4gSWYgd2Ugd2FudCB0byBlbmFibGUgbXVsdGktdGhyZWFkaW5nIGluIHRlc3QsIHdlIHNob3VsZCBzZXQgYG9ydC5lbnYud2FzbS5udW1UaHJlYWRzYCB0byBhXG4gICAgLy8gdmFsdWUgZ3JlYXRlciB0aGFuIDEuXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAhc2VsZi5jcm9zc09yaWdpbklzb2xhdGVkKSB7XG4gICAgICBlbnYud2FzbS5udW1UaHJlYWRzID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbnVtQ3B1TG9naWNhbENvcmVzID1cbiAgICAgICAgdHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgPyByZXF1aXJlKCdub2RlOm9zJykuY3B1cygpLmxlbmd0aCA6IG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5O1xuICAgICAgZW52Lndhc20ubnVtVGhyZWFkcyA9IE1hdGgubWluKDQsIE1hdGguY2VpbCgobnVtQ3B1TG9naWNhbENvcmVzIHx8IDEpIC8gMikpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghQlVJTERfREVGUy5ESVNBQkxFX0RZTkFNSUNfSU1QT1JUKSB7XG4gICAgLy8gb3ZlcndyaXRlIHdhc20gcGF0aHMgb3ZlcnJpZGUgaWYgbm90IHNldFxuICAgIGlmIChlbnYud2FzbS53YXNtUGF0aHMgPT09IHVuZGVmaW5lZCAmJiBzY3JpcHRTcmMgJiYgc2NyaXB0U3JjLmluZGV4T2YoJ2Jsb2I6JykgIT09IDApIHtcbiAgICAgIGVudi53YXNtLndhc21QYXRocyA9IHNjcmlwdFNyYy5zdWJzdHJpbmcoMCwgc2NyaXB0U3JjLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjbGFzcyBPbm54cnVudGltZVdlYkFzc2VtYmx5QmFja2VuZCBpbXBsZW1lbnRzIEJhY2tlbmQge1xuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpbml0aWFsaXplcyB0aGUgV2ViQXNzZW1ibHkgYmFja2VuZC5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBvbmx5IG9uY2UgZm9yIGVhY2ggYmFja2VuZCBuYW1lLiBJdCB3aWxsIGJlIGNhbGxlZCB0aGUgZmlyc3QgdGltZSB3aGVuXG4gICAqIGBvcnQuSW5mZXJlbmNlU2Vzc2lvbi5jcmVhdGUoKWAgaXMgY2FsbGVkIHdpdGggYSByZWdpc3RlcmVkIGJhY2tlbmQgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIGJhY2tlbmROYW1lIC0gdGhlIHJlZ2lzdGVyZWQgYmFja2VuZCBuYW1lLlxuICAgKi9cbiAgYXN5bmMgaW5pdChiYWNrZW5kTmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gcG9wdWxhdGUgd2FzbSBmbGFnc1xuICAgIGluaXRpYWxpemVGbGFncygpO1xuXG4gICAgLy8gaW5pdCB3YXNtXG4gICAgYXdhaXQgaW5pdGlhbGl6ZVdlYkFzc2VtYmx5QW5kT3J0UnVudGltZSgpO1xuXG4gICAgLy8gcGVyZm9ybWUgRVAgc3BlY2lmaWMgaW5pdGlhbGl6YXRpb25cbiAgICBhd2FpdCBpbml0aWFsaXplT3J0RXAoYmFja2VuZE5hbWUpO1xuICB9XG4gIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKFxuICAgIHBhdGg6IHN0cmluZyxcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj47XG4gIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKFxuICAgIGJ1ZmZlcjogVWludDhBcnJheSxcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj47XG4gIGFzeW5jIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKFxuICAgIHBhdGhPckJ1ZmZlcjogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgICBvcHRpb25zPzogSW5mZXJlbmNlU2Vzc2lvbi5TZXNzaW9uT3B0aW9ucyxcbiAgKTogUHJvbWlzZTxJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj4ge1xuICAgIGNvbnN0IGhhbmRsZXIgPSBuZXcgT25ueHJ1bnRpbWVXZWJBc3NlbWJseVNlc3Npb25IYW5kbGVyKCk7XG4gICAgYXdhaXQgaGFuZGxlci5sb2FkTW9kZWwocGF0aE9yQnVmZmVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGhhbmRsZXIpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCB3YXNtQmFja2VuZCA9IG5ldyBPbm54cnVudGltZVdlYkFzc2VtYmx5QmFja2VuZCgpO1xuIiwgIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzICovXG5cbi8vIFdlIHVzZSBcInJlcXVpcmVcIiBpbnN0ZWFkIG9mIFwiaW1wb3J0XCIgaGVyZSBiZWNhdXNlIGltcG9ydCBzdGF0ZW1lbnQgbXVzdCBiZSBwdXQgaW4gdG9wIGxldmVsLiBPdXIgY3VycmVudCBjb2RlIGRvZXNcbi8vIG5vdCBhbGxvdyBidW5kbGVyIHRvIHRyZWUtc2hha2luZyBjb2RlIGFzIGV4cGVjdGVkIGJlY2F1c2Ugc29tZSBjb2RlcyBhcmUgdHJlYXRlZCBhcyBoYXZpbmcgc2lkZSBlZmZlY3RzLlxuLy8gU28gd2UgaW1wb3J0IGNvZGUgaW5zaWRlIHRoZSBpZi1jbGF1c2UgdG8gYWxsb3cgYnVuZGxlciByZW1vdmUgdGhlIGNvZGUgc2FmZWx5LlxuXG5leHBvcnQgKiBmcm9tICdvbm54cnVudGltZS1jb21tb24nO1xuaW1wb3J0ICogYXMgb3J0IGZyb20gJ29ubnhydW50aW1lLWNvbW1vbic7XG5leHBvcnQgZGVmYXVsdCBvcnQ7XG5cbmltcG9ydCB7IHJlZ2lzdGVyQmFja2VuZCwgZW52IH0gZnJvbSAnb25ueHJ1bnRpbWUtY29tbW9uJztcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nO1xuXG5pZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XRUJHTCkge1xuICBjb25zdCBvbm54anNCYWNrZW5kID0gcmVxdWlyZSgnLi9iYWNrZW5kLW9ubnhqcycpLm9ubnhqc0JhY2tlbmQ7XG4gIHJlZ2lzdGVyQmFja2VuZCgnd2ViZ2wnLCBvbm54anNCYWNrZW5kLCAtMTApO1xufVxuXG5pZiAoIUJVSUxEX0RFRlMuRElTQUJMRV9XQVNNKSB7XG4gIGNvbnN0IHdhc21CYWNrZW5kID0gcmVxdWlyZSgnLi9iYWNrZW5kLXdhc20nKS53YXNtQmFja2VuZDtcbiAgaWYgKCFCVUlMRF9ERUZTLkRJU0FCTEVfSlNFUCkge1xuICAgIHJlZ2lzdGVyQmFja2VuZCgnd2ViZ3B1Jywgd2FzbUJhY2tlbmQsIDUpO1xuICAgIHJlZ2lzdGVyQmFja2VuZCgnd2Vibm4nLCB3YXNtQmFja2VuZCwgNSk7XG4gIH1cbiAgcmVnaXN0ZXJCYWNrZW5kKCdjcHUnLCB3YXNtQmFja2VuZCwgMTApO1xuICByZWdpc3RlckJhY2tlbmQoJ3dhc20nLCB3YXNtQmFja2VuZCwgMTApO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZW52LnZlcnNpb25zLCAnd2ViJywgeyB2YWx1ZTogdmVyc2lvbiwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbiIsICIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cblxuLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSAvanMvc2NyaXB0cy91cGRhdGUtdmVyc2lvbi50c1xuLy8gRG8gbm90IG1vZGlmeSBmaWxlIGNvbnRlbnQgbWFudWFsbHkuXG5cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzEuMjAuMCc7XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQWdCTSxVQUNBLDBCQVlPLGlCQXdDUCxnQ0F3Q087QUE3R2I7OztBQWdCQSxNQUFNLFdBQXFDLG9CQUFJLElBQUc7QUFDbEQsTUFBTSwyQkFBcUMsQ0FBQTtBQVlwQyxNQUFNLGtCQUFrQixDQUFDLE1BQWMsU0FBa0IsYUFBMEI7QUFDeEYsWUFBSSxXQUFXLE9BQU8sUUFBUSxTQUFTLGNBQWMsT0FBTyxRQUFRLGtDQUFrQyxZQUFZO0FBQ2hILGdCQUFNLGlCQUFpQixTQUFTLElBQUksSUFBSTtBQUN4QyxjQUFJLG1CQUFtQixRQUFXO0FBQ2hDLHFCQUFTLElBQUksTUFBTSxFQUFFLFNBQVMsU0FBUSxDQUFFO3FCQUMvQixlQUFlLFdBQVcsVUFBVTtBQUU3QztxQkFDUyxlQUFlLGFBQWEsVUFBVTtBQUMvQyxnQkFBSSxlQUFlLFlBQVksU0FBUztBQUN0QyxvQkFBTSxJQUFJLE1BQU0sNEJBQTRCLElBQUksb0JBQW9CLFFBQVEsRUFBRTs7O0FBSWxGLGNBQUksWUFBWSxHQUFHO0FBQ2pCLGtCQUFNLElBQUkseUJBQXlCLFFBQVEsSUFBSTtBQUMvQyxnQkFBSSxNQUFNLElBQUk7QUFDWix1Q0FBeUIsT0FBTyxHQUFHLENBQUM7O0FBR3RDLHFCQUFTQSxLQUFJLEdBQUdBLEtBQUkseUJBQXlCLFFBQVFBLE1BQUs7QUFDeEQsa0JBQUksU0FBUyxJQUFJLHlCQUF5QkEsRUFBQyxDQUFDLEVBQUcsWUFBWSxVQUFVO0FBQ25FLHlDQUF5QixPQUFPQSxJQUFHLEdBQUcsSUFBSTtBQUMxQzs7O0FBR0oscUNB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UzVELE1BQU0sS0FBSyxhQUFvQztBQUU3QywwQkFBZ0I7QUFHaEIsZ0JBQU0sbUNBQW1DO0FBR3pDLGdCQUFNLGdCQUFnQixXQUFXO0FBQUEsUUFDbkM7QUFBQSxRQVNBLE1BQU0sOEJBQ0osY0FDQSxTQUNrQztBQUNsQyxnQkFBTSxVQUFVLElBQUkscUNBQXFDO0FBQ3pELGdCQUFNLFFBQVEsVUFBVSxjQUFjLE9BQU87QUFDN0MsaUJBQU8sUUFBUSxRQUFRLE9BQU87QUFBQSxRQUNoQztBQUFBLE1BQ0Y7QUFFTyxNQUFNLGNBQWMsSUFBSSw4QkFBOEI7QUFBQTtBQUFBOzs7QUN0RzdEO0FBQUE7QUFBQSw0QkFBQUM7QUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBLGtCQUFBQztBQUFBLElBQUEsdUJBQUFDO0FBQUEsSUFBQTtBQUFBLGVBQUFDO0FBQUEsSUFBQTtBQUFBO0FBU0E7QUFDQTtBQUdBOzs7QUNQTyxNQUFNQyxXQUFVOzs7QURLdkIsTUFBTyxjQUFRO0FBS2YsTUFBSSxPQUEyQjtBQUM3QixVQUFNLGdCQUFnQixLQUE0QjtBQUNsRCxvQkFBZ0IsU0FBUyxlQUFlLEdBQUc7QUFBQSxFQUM3QztBQUVBLE1BQUksTUFBMEI7QUFDNUIsVUFBTUMsZUFBYywwREFBMEI7QUFDOUMsUUFBSSxNQUEwQjtBQUM1QixzQkFBZ0IsVUFBVUEsY0FBYSxDQUFDO0FBQ3hDLHNCQUFnQixTQUFTQSxjQUFhLENBQUM7QUFBQSxJQUN6QztBQUNBLG9CQUFnQixPQUFPQSxjQUFhLEVBQUU7QUFDdEMsb0JBQWdCLFFBQVFBLGNBQWEsRUFBRTtBQUFBLEVBQ3pDO0FBRUEsU0FBTyxlQUFlQyxLQUFJLFVBQVUsT0FBTyxFQUFFLE9BQU9DLFVBQVMsWUFBWSxLQUFLLENBQUM7IiwKICAibmFtZXMiOiBbImkiLCAiZW52IiwgIlRlbnNvciIsICJUZW5zb3IiLCAiSW5mZXJlbmNlU2Vzc2lvbiIsICJUZW5zb3IiLCAiVHJhaW5pbmdTZXNzaW9uIiwgIkluZmVyZW5jZVNlc3Npb24iLCAiVGVuc29yIiwgIlRyYWluaW5nU2Vzc2lvbiIsICJlbnYiLCAiZW52IiwgIndhc20iLCAid2FzbSIsICJ3YXNtIiwgImxvY2F0aW9uIiwgInBhZCIsICJpbml0IiwgIm9mZnNldHMiLCAiaW5kaWNlcyIsICJpbXBsIiwgInZhbGlkYXRlSW5wdXRzIiwgInJlZHVjZU9wcyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJlbnYiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAiYSIsICJiIiwgInZhbGlkYXRlSW5wdXRzIiwgImkiLCAidHJhbnNwb3NlIiwgIm91dHB1dFZhcmlhYmxlIiwgImlubmVyRWxlbWVudFNpemUiLCAicGFkIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgImNvbnZJbnB1dHMiLCAidHJhbnNwb3NlZFdlaWdodCIsICJpbm5lckVsZW1lbnRTaXplIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgInBlcm1GdW5jdGlvbkJvZHkiLCAic3ltYm9sIiwgInJlZHVjZU9wcyIsICJ2YWxpZGF0ZUlucHV0cyIsICJjYWxjdWxhdGVPdXRwdXRTaGFwZSIsICJmYXN0R2VsdSIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJ3ZWlnaHRUcmFuc3Bvc2VBdHRyaWJ1dGUiLCAidmFsaWRhdGVJbnB1dHMiLCAiZ2V0T3V0cHV0U2hhcGUiLCAidmFsaWRhdGVJbnB1dHMiLCAiY3JlYXRlQ29uY2F0UHJvZ3JhbUluZm8iLCAid2VpZ2h0VHJhbnNwb3NlQXR0cmlidXRlIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgImRhdGFUeXBlIiwgInZhbGlkYXRlSW5wdXRzIiwgInZhbGlkYXRlSW5wdXRzIiwgImVudiIsICJ2YWxpZGF0ZUlucHV0cyIsICJlbnYiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAidmFsaWRhdGVJbnB1dHMiLCAiY29tcG9uZW50cyIsICJ2YWxpZGF0ZUlucHV0cyIsICJhIiwgImIiLCAiYyIsICJmYXN0R2VsdSIsICJlbnYiLCAiaSIsICJlbnYiLCAiZW52IiwgIndhc20iLCAibG9jYXRpb24iLCAidGVuc29yIiwgImVycm9yQ29kZSIsICJpIiwgImluaXRpYWxpemluZyIsICJpbml0aWFsaXplZCIsICJhYm9ydGVkIiwgImNvcHlGcm9tRXh0ZXJuYWxCdWZmZXIiLCAiY3JlYXRlU2Vzc2lvbiIsICJyZWxlYXNlU2Vzc2lvbiIsICJydW4iLCAiZW5kUHJvZmlsaW5nIiwgImVudiIsICJUZW5zb3IiLCAiY29weUZyb21FeHRlcm5hbEJ1ZmZlciIsICJjcmVhdGVTZXNzaW9uIiwgInJlbGVhc2VTZXNzaW9uIiwgInJ1biIsICJlbmRQcm9maWxpbmciLCAiZW52IiwgIkluZmVyZW5jZVNlc3Npb24iLCAiVGVuc29yIiwgIlRyYWluaW5nU2Vzc2lvbiIsICJlbnYiLCAidmVyc2lvbiIsICJ3YXNtQmFja2VuZCIsICJlbnYiLCAidmVyc2lvbiJdCn0K
