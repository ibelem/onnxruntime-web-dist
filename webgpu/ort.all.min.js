/*!
 * ONNX Runtime Web v1.17.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
"use strict";var ort=(()=>{var My=Object.create;var Uo=Object.defineProperty;var Ly=Object.getOwnPropertyDescriptor;var zy=Object.getOwnPropertyNames;var Ny=Object.getPrototypeOf,Fy=Object.prototype.hasOwnProperty;var R=(r,e)=>()=>(r&&(e=r(r=0)),e);var Ye=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),kr=(r,e)=>{for(var n in e)Uo(r,n,{get:e[n],enumerable:!0})},Ru=(r,e,n,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of zy(e))!Fy.call(r,o)&&o!==n&&Uo(r,o,{get:()=>e[o],enumerable:!(t=Ly(e,o))||t.enumerable});return r};var vn=(r,e,n)=>(n=r!=null?My(Ny(r)):{},Ru(e||!r||!r.__esModule?Uo(n,"default",{value:r,enumerable:!0}):n,r)),Sr=r=>Ru(Uo({},"__esModule",{value:!0}),r);var Wo,Yr,sr,Ho,qo=R(()=>{Wo=new Map,Yr=[],sr=(r,e,n)=>{if(e&&typeof e.init=="function"&&typeof e.createInferenceSessionHandler=="function"){let t=Wo.get(r);if(t===void 0)Wo.set(r,{backend:e,priority:n});else{if(t.priority>n)return;if(t.priority===n&&t.backend!==e)throw new Error(`cannot register backend "${r}" using priority ${n}`)}if(n>=0){let o=Yr.indexOf(r);o!==-1&&Yr.splice(o,1);for(let i=0;i<Yr.length;i++)if(Wo.get(Yr[i]).priority<=n){Yr.splice(i,0,r);return}Yr.push(r)}return}throw new TypeError("not a valid backend")},Ho=async r=>{let e=r.length===0?Yr:r,n=[];for(let t of e){let o=Wo.get(t);if(o){if(o.initialized)return o.backend;if(o.aborted)continue;let i=!!o.initPromise;try{return i||(o.initPromise=o.backend.init(t)),await o.initPromise,o.initialized=!0,o.backend}catch(u){i||n.push({name:t,err:u}),o.aborted=!0}finally{delete o.initPromise}}}throw new Error(`no available backend found. ERR: ${n.map(t=>`[${t.name}] ${t.err}`).join(", ")}`)}});var Mu=R(()=>{qo()});var Lu,zu=R(()=>{Lu="1.17.0"});var Nu,Ta,Fu=R(()=>{zu();Nu="warning",Ta={wasm:{},webgl:{},webgpu:{},versions:{common:Lu},set logLevel(r){if(r!==void 0){if(typeof r!="string"||["verbose","info","warning","error","fatal"].indexOf(r)===-1)throw new Error(`Unsupported logging level: ${r}`);Nu=r}},get logLevel(){return Nu}};Object.defineProperty(Ta,"logLevel",{enumerable:!0})});var xe,Vu=R(()=>{Fu();xe=Ta});var Gu,Uu,Wu=R(()=>{Gu=(r,e)=>{let n=document.createElement("canvas");n.width=r.dims[3],n.height=r.dims[2];let t=n.getContext("2d");if(t!=null){let o,i;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(o=r.dims[2],i=r.dims[3]):(o=r.dims[3],i=r.dims[2]);let u=e?.format!==void 0?e.format:"RGB",a=e?.norm,s,l;a===void 0||a.mean===void 0?s=[255,255,255,255]:typeof a.mean=="number"?s=[a.mean,a.mean,a.mean,a.mean]:(s=[a.mean[0],a.mean[1],a.mean[2],0],a.mean[3]!==void 0&&(s[3]=a.mean[3])),a===void 0||a.bias===void 0?l=[0,0,0,0]:typeof a.bias=="number"?l=[a.bias,a.bias,a.bias,a.bias]:(l=[a.bias[0],a.bias[1],a.bias[2],0],a.bias[3]!==void 0&&(l[3]=a.bias[3]));let d=i*o,f=0,p=d,g=d*2,b=-1;u==="RGBA"?(f=0,p=d,g=d*2,b=d*3):u==="RGB"?(f=0,p=d,g=d*2):u==="RBG"&&(f=0,g=d,p=d*2);for(let y=0;y<i;y++)for(let _=0;_<o;_++){let x=(r.data[f++]-l[0])*s[0],S=(r.data[p++]-l[1])*s[1],O=(r.data[g++]-l[2])*s[2],C=b===-1?255:(r.data[b++]-l[3])*s[3];t.fillStyle="rgba("+x+","+S+","+O+","+C+")",t.fillRect(_,y,1,1)}return n.toDataURL()}else throw new Error("Can not access image data")},Uu=(r,e)=>{let n=document.createElement("canvas").getContext("2d"),t;if(n!=null){let o,i,u;e?.tensorLayout!==void 0&&e.tensorLayout==="NHWC"?(o=r.dims[2],i=r.dims[1],u=r.dims[3]):(o=r.dims[3],i=r.dims[2],u=r.dims[1]);let a=e!==void 0&&e.format!==void 0?e.format:"RGB",s=e?.norm,l,d;s===void 0||s.mean===void 0?l=[255,255,255,255]:typeof s.mean=="number"?l=[s.mean,s.mean,s.mean,s.mean]:(l=[s.mean[0],s.mean[1],s.mean[2],255],s.mean[3]!==void 0&&(l[3]=s.mean[3])),s===void 0||s.bias===void 0?d=[0,0,0,0]:typeof s.bias=="number"?d=[s.bias,s.bias,s.bias,s.bias]:(d=[s.bias[0],s.bias[1],s.bias[2],0],s.bias[3]!==void 0&&(d[3]=s.bias[3]));let f=i*o;if(e!==void 0&&(e.format!==void 0&&u===4&&e.format!=="RGBA"||u===3&&e.format!=="RGB"&&e.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let p=4,g=0,b=1,y=2,_=3,x=0,S=f,O=f*2,C=-1;a==="RGBA"?(x=0,S=f,O=f*2,C=f*3):a==="RGB"?(x=0,S=f,O=f*2):a==="RBG"&&(x=0,O=f,S=f*2),t=n.createImageData(o,i);for(let N=0;N<i*o;g+=p,b+=p,y+=p,_+=p,N++)t.data[g]=(r.data[x++]-d[0])*l[0],t.data[b]=(r.data[S++]-d[1])*l[1],t.data[y]=(r.data[O++]-d[2])*l[2],t.data[_]=C===-1?255:(r.data[C++]-d[3])*l[3]}else throw new Error("Can not access image data");return t}});var _a,Hu,qu,ju,Ku,Yu=R(()=>{jo();_a=(r,e)=>{if(r===void 0)throw new Error("Image buffer must be defined");if(e.height===void 0||e.width===void 0)throw new Error("Image height and width must be defined");if(e.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:n,width:t}=e,o=e.norm??{mean:255,bias:0},i,u;typeof o.mean=="number"?i=[o.mean,o.mean,o.mean,o.mean]:i=[o.mean[0],o.mean[1],o.mean[2],o.mean[3]??255],typeof o.bias=="number"?u=[o.bias,o.bias,o.bias,o.bias]:u=[o.bias[0],o.bias[1],o.bias[2],o.bias[3]??0];let a=e.format!==void 0?e.format:"RGBA",s=e.tensorFormat!==void 0&&e.tensorFormat!==void 0?e.tensorFormat:"RGB",l=n*t,d=s==="RGBA"?new Float32Array(l*4):new Float32Array(l*3),f=4,p=0,g=1,b=2,y=3,_=0,x=l,S=l*2,O=-1;a==="RGB"&&(f=3,p=0,g=1,b=2,y=-1),s==="RGBA"?O=l*3:s==="RBG"?(_=0,S=l,x=l*2):s==="BGR"&&(S=0,x=l,_=l*2);for(let N=0;N<l;N++,p+=f,b+=f,g+=f,y+=f)d[_++]=(r[p]+u[0])/i[0],d[x++]=(r[g]+u[1])/i[1],d[S++]=(r[b]+u[2])/i[2],O!==-1&&y!==-1&&(d[O++]=(r[y]+u[3])/i[3]);return s==="RGBA"?new Et("float32",d,[1,4,n,t]):new Et("float32",d,[1,3,n,t])},Hu=async(r,e)=>{let n=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,t=typeof ImageData<"u"&&r instanceof ImageData,o=typeof ImageBitmap<"u"&&r instanceof ImageBitmap,i=typeof r=="string",u,a=e??{};if(n){let s=document.createElement("canvas");s.width=r.width,s.height=r.height;let l=s.getContext("2d");if(l!=null){let d=r.height,f=r.width;if(e!==void 0&&e.resizedHeight!==void 0&&e.resizedWidth!==void 0&&(d=e.resizedHeight,f=e.resizedWidth),e!==void 0){if(a=e,e.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");a.tensorFormat="RGBA",a.height=d,a.width=f}else a.tensorFormat="RGBA",a.height=d,a.width=f;l.drawImage(r,0,0),u=l.getImageData(0,0,f,d).data}else throw new Error("Can not access image data")}else if(t){let s,l;if(e!==void 0&&e.resizedWidth!==void 0&&e.resizedHeight!==void 0?(s=e.resizedHeight,l=e.resizedWidth):(s=r.height,l=r.width),e!==void 0&&(a=e),a.format="RGBA",a.height=s,a.width=l,e!==void 0){let d=document.createElement("canvas");d.width=l,d.height=s;let f=d.getContext("2d");if(f!=null)f.putImageData(r,0,0),u=f.getImageData(0,0,l,s).data;else throw new Error("Can not access image data")}else u=r.data}else if(o){if(e===void 0)throw new Error("Please provide image config with format for Imagebitmap");let s=document.createElement("canvas");s.width=r.width,s.height=r.height;let l=s.getContext("2d");if(l!=null){let d=r.height,f=r.width;return l.drawImage(r,0,0,f,d),u=l.getImageData(0,0,f,d).data,a.height=d,a.width=f,_a(u,a)}else throw new Error("Can not access image data")}else{if(i)return new Promise((s,l)=>{let d=document.createElement("canvas"),f=d.getContext("2d");if(!r||!f)return l();let p=new Image;p.crossOrigin="Anonymous",p.src=r,p.onload=()=>{d.width=p.width,d.height=p.height,f.drawImage(p,0,0,d.width,d.height);let g=f.getImageData(0,0,d.width,d.height);a.height=d.height,a.width=d.width,s(_a(g.data,a))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(u!==void 0)return _a(u,a);throw new Error("Input data provided is not supported - aborted tensor creation")},qu=(r,e)=>{let{width:n,height:t,download:o,dispose:i}=e,u=[1,t,n,4];return new Et({location:"texture",type:"float32",texture:r,dims:u,download:o,dispose:i})},ju=(r,e)=>{let{dataType:n,dims:t,download:o,dispose:i}=e;return new Et({location:"gpu-buffer",type:n??"float32",gpuBuffer:r,dims:t,download:o,dispose:i})},Ku=(r,e,n)=>new Et({location:"cpu-pinned",type:r,data:e,dims:n??[e.length]})});var eo,Ko,Xu,Zu,Ju=R(()=>{eo=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["float16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),Ko=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),Xu=!1,Zu=()=>{if(!Xu){Xu=!0;let r=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",e=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function";r&&(eo.set("int64",BigInt64Array),Ko.set(BigInt64Array,"int64")),e&&(eo.set("uint64",BigUint64Array),Ko.set(BigUint64Array,"uint64"))}}});var Qu,el,tl=R(()=>{jo();Qu=r=>{let e=1;for(let n=0;n<r.length;n++){let t=r[n];if(typeof t!="number"||!Number.isSafeInteger(t))throw new TypeError(`dims[${n}] must be an integer, got: ${t}`);if(t<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${t}`);e*=t}return e},el=(r,e)=>{switch(r.location){case"cpu":return new Et(r.type,r.data,e);case"cpu-pinned":return new Et({location:"cpu-pinned",data:r.data,type:r.type,dims:e});case"texture":return new Et({location:"texture",texture:r.texture,type:r.type,dims:e});case"gpu-buffer":return new Et({location:"gpu-buffer",gpuBuffer:r.gpuBuffer,type:r.type,dims:e});default:throw new Error(`tensorReshape: tensor location ${r.location} is not supported`)}}});var Et,jo=R(()=>{Wu();Yu();Ju();tl();Et=class{constructor(e,n,t){Zu();let o,i;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,o=e.type,i=e.dims,e.location){case"cpu-pinned":{let a=eo.get(o);if(!a)throw new TypeError(`unsupported type "${o}" to create tensor from pinned buffer`);if(!(e.data instanceof a))throw new TypeError(`buffer should be of type ${a.name}`);this.cpuData=e.data;break}case"texture":{if(o!=="float32")throw new TypeError(`unsupported type "${o}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(o!=="float32"&&o!=="float16"&&o!=="int32"&&o!=="int64"&&o!=="uint32"&&o!=="bool")throw new TypeError(`unsupported type "${o}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let a,s;if(typeof e=="string")if(o=e,s=t,e==="string"){if(!Array.isArray(n))throw new TypeError("A string tensor's data must be a string array.");a=n}else{let l=eo.get(e);if(l===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(n)){if(e==="float16")throw new TypeError("Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.");e==="uint64"||e==="int64"?a=l.from(n,BigInt):a=l.from(n)}else if(n instanceof l)a=n;else throw new TypeError(`A ${o} tensor's data must be type of ${l}`)}else if(s=n,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let l=typeof e[0];if(l==="string")o="string",a=e;else if(l==="boolean")o="bool",a=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${l}.`)}else{let l=Ko.get(e.constructor);if(l===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);o=l,a=e}if(s===void 0)s=[a.length];else if(!Array.isArray(s))throw new TypeError("A tensor's dims must be a number array");i=s,this.cpuData=a,this.dataLocation="cpu"}let u=Qu(i);if(this.cpuData&&u!==this.cpuData.length)throw new Error(`Tensor's size(${u}) does not match data length(${this.cpuData.length}).`);this.type=o,this.dims=i,this.size=u}static async fromImage(e,n){return Hu(e,n)}static fromTexture(e,n){return qu(e,n)}static fromGpuBuffer(e,n){return ju(e,n)}static fromPinnedBuffer(e,n,t){return Ku(e,n,t)}toDataURL(e){return Gu(this,e)}toImageData(e){return Uu(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let n=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=n,e&&this.disposer&&(this.disposer(),this.disposer=void 0),n}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return el(this,e)}}});var gt,Yo=R(()=>{jo();gt=Et});var Xo,rl=R(()=>{qo();Yo();Xo=class r{constructor(e){this.handler=e}async run(e,n,t){let o={},i={};if(typeof e!="object"||e===null||e instanceof gt||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let u=!0;if(typeof n=="object"){if(n===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(n instanceof gt)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(n)){if(n.length===0)throw new TypeError("'fetches' cannot be an empty array.");u=!1;for(let l of n){if(typeof l!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(l)===-1)throw new RangeError(`'fetches' contains invalid output name: ${l}.`);o[l]=null}if(typeof t=="object"&&t!==null)i=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else{let l=!1,d=Object.getOwnPropertyNames(n);for(let f of this.outputNames)if(d.indexOf(f)!==-1){let p=n[f];(p===null||p instanceof gt)&&(l=!0,u=!1,o[f]=p)}if(l){if(typeof t=="object"&&t!==null)i=t;else if(typeof t<"u")throw new TypeError("'options' must be an object.")}else i=n}}else if(typeof n<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let l of this.inputNames)if(typeof e[l]>"u")throw new Error(`input '${l}' is missing in 'feeds'.`);if(u)for(let l of this.outputNames)o[l]=null;let a=await this.handler.run(e,o,i),s={};for(let l in a)if(Object.hasOwnProperty.call(a,l)){let d=a[l];d instanceof gt?s[l]=d:s[l]=new gt(d.type,d.data,d.dims)}return s}async release(){return this.handler.dispose()}static async create(e,n,t,o){let i,u={};if(typeof e=="string"){if(i=e,typeof n=="object"&&n!==null)u=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(i=e,typeof n=="object"&&n!==null)u=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer){let f=e,p=0,g=e.byteLength;if(typeof n=="object"&&n!==null)u=n;else if(typeof n=="number"){if(p=n,!Number.isSafeInteger(p))throw new RangeError("'byteOffset' must be an integer.");if(p<0||p>=f.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${f.byteLength}).`);if(g=e.byteLength-p,typeof t=="number"){if(g=t,!Number.isSafeInteger(g))throw new RangeError("'byteLength' must be an integer.");if(g<=0||p+g>f.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${f.byteLength-p}].`);if(typeof o=="object"&&o!==null)u=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else if(typeof t<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof n<"u")throw new TypeError("'options' must be an object.");i=new Uint8Array(f,p,g)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let s=(u.executionProviders||[]).map(f=>typeof f=="string"?f:f.name),d=await(await Ho(s)).createInferenceSessionHandler(i,u);return new r(d)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var nl,ol=R(()=>{rl();nl=Xo});var il=R(()=>{});var Vy,Zo,al=R(()=>{qo();Yo();Vy="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",Zo=class r{constructor(e,n,t){this.handler=e,this.hasOptimizerModel=n,this.hasEvalModel=t}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(e,n){let t=e.evalModel||"",o=e.optimizerModel||"",i=n||{},a=(i.executionProviders||[]).map(l=>typeof l=="string"?l:l.name),s=await Ho(a);if(s.createTrainingSessionHandler){let l=await s.createTrainingSessionHandler(e.checkpointState,e.trainModel,t,o,i);return new r(l,!!e.optimizerModel,!!e.evalModel)}else throw new Error(Vy)}typeNarrowingForRunStep(e,n,t,o,i){let u={},a={};if(typeof t!="object"||t===null||t instanceof gt||Array.isArray(t))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let s=!0;if(typeof o=="object"){if(o===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(o instanceof gt)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(o)){if(o.length===0)throw new TypeError("'fetches' cannot be an empty array.");s=!1;for(let l of o){if(typeof l!="string")throw new TypeError("'fetches' must be a string array or an object.");if(n.indexOf(l)===-1)throw new RangeError(`'fetches' contains invalid output name: ${l}.`);u[l]=null}if(typeof i=="object"&&i!==null)a=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else{let l=!1,d=Object.getOwnPropertyNames(o);for(let f of n)if(d.indexOf(f)!==-1){let p=o[f];(p===null||p instanceof gt)&&(l=!0,s=!1,u[f]=p)}if(l){if(typeof i=="object"&&i!==null)a=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else a=o}}else if(typeof o<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let l of e)if(typeof t[l]>"u")throw new Error(`input '${l}' is missing in 'feeds'.`);if(s)for(let l of n)u[l]=null;return[u,a]}convertHandlerReturnTypeToMapOfTensors(e){let n={};for(let t in e)if(Object.hasOwnProperty.call(e,t)){let o=e[t];o instanceof gt?n[t]=o:n[t]=new gt(o.type,o.data,o.dims)}return n}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(e,n,t){let[o,i]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,e,n,t),u=await this.handler.runTrainStep(e,o,i);return this.convertHandlerReturnTypeToMapOfTensors(u)}async runOptimizerStep(e){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(e||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(e,n,t){if(this.hasEvalModel){let[o,i]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,e,n,t),u=await this.handler.runEvalStep(e,o,i);return this.convertHandlerReturnTypeToMapOfTensors(u)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(e=!0){return this.handler.getParametersSize(e)}async loadParametersBuffer(e,n=!0){let t=await this.getParametersSize(n);if(e.length!==4*t)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(e,n)}async getContiguousParameters(e=!0){return this.handler.getContiguousParameters(e)}async release(){return this.handler.dispose()}}});var sl,ul=R(()=>{al();sl=Zo});var Sa={};kr(Sa,{InferenceSession:()=>nl,Tensor:()=>gt,TrainingSession:()=>sl,env:()=>xe,registerBackend:()=>sr});var Bt=R(()=>{Mu();Vu();ol();Yo();il();ul()});function Dr(r,e,n,t){if(e===void 0)return Uy(r);if(n===void 0)Jo(r,e,1);else if(typeof n=="number"&&t===void 0)Jo(r,e,n);else if(typeof n=="string"&&t===void 0)Jo(r,n,1,e);else if(typeof n=="string"&&typeof t=="number")Jo(r,n,t,e);else throw new TypeError("input is valid")}function Uy(r){return{verbose:Dr.verbose.bind(null,r),info:Dr.info.bind(null,r),warning:Dr.warning.bind(null,r),error:Dr.error.bind(null,r),fatal:Dr.fatal.bind(null,r)}}function Jo(r,e,n,t){let o=to[t||""]||to[""];dl[r]<dl[o.minimalSeverity]||(o.logDateTime&&(e=`${new Date().toISOString()}|${e}`),o.logSourceLocation,Gy[o.provider].log(r,e,t))}var Ia,Aa,dl,Gy,cl,to,je,ei,ti,ri,Qo,Vt=R(()=>{"use strict";Ia=class{log(e,n,t){}},Aa=class{log(e,n,t){console.log(`${this.color(e)} ${t?"\x1B[35m"+t+"\x1B[0m ":""}${n}`)}color(e){switch(e){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${e}`)}}},dl={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},Gy={none:new Ia,console:new Aa},cl={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1},to={"":cl};(s=>{function r(l,d){s("verbose",l,d)}s.verbose=r;function e(l,d){s("info",l,d)}s.info=e;function n(l,d){s("warning",l,d)}s.warning=n;function t(l,d){s("error",l,d)}s.error=t;function o(l,d){s("fatal",l,d)}s.fatal=o;function i(l){to={},u("",l||{})}s.reset=i;function u(l,d){if(l==="*")i(d);else{let f=to[l]||cl;to[l]={provider:d.provider||f.provider,minimalSeverity:d.minimalSeverity||f.minimalSeverity,logDateTime:d.logDateTime===void 0?f.logDateTime:d.logDateTime,logSourceLocation:d.logSourceLocation===void 0?f.logSourceLocation:d.logSourceLocation}}}s.set=u;function a(l){let d={};l.logLevel&&(d.minimalSeverity=l.logLevel),u("",d)}s.setWithEnv=a})(Dr||={});je=Dr,ei=class{constructor(e,n,t,o,i,u){this.category=e;this.name=n;this.startTime=t;this.endCallback=o;this.timer=i;this.ctx=u}async end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}},ti=class{constructor(e,n,t,o){this.category=e;this.name=n;this.startTime=t;this.endTime=o}},ri=class{constructor(e,n,t){this._started=!1;this._flushPointer=0;this._started=!1,this._maxNumberEvents=e===void 0?1e4:e,this._flushBatchSize=n===void 0?10:n,this._flushIntervalInMilliseconds=t===void 0?5e3:t}static create(e){return e===void 0?new this:new this(e.maxNumberEvents,e.flushBatchSize,e.flushIntervalInMilliseconds)}start(){this._started=!0,this._timingEvents=[],this._flushTime=Qo(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(e,n,t,o){let i=this._started?this.begin(e,n,o):void 0,u=!1,a=t();if(a&&typeof a.then=="function")return u=!0,new Promise((s,l)=>{a.then(async d=>{i&&await i.end(),s(d)},async d=>{i&&await i.end(),l(d)})});if(!u&&i){let s=i.end();if(s&&typeof s.then=="function")return new Promise((l,d)=>{s.then(()=>{l(a)},f=>{d(f)})})}return a}begin(e,n,t){if(!this._started)throw new Error("profiler is not started yet");if(t===void 0){let o=Qo();return this.flush(o),new ei(e,n,o,i=>this.endSync(i))}else{let o=t.beginTimer();return new ei(e,n,0,async i=>this.end(i),o,t)}}async end(e){let n=await e.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new ti(e.category,e.name,e.startTime,n)),this.flush(n))}endSync(e){let n=Qo();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new ti(e.category,e.name,e.startTime,n)),this.flush(n))}logOneEvent(e){je.verbose(`Profiler.${e.category}`,`${(e.endTime-e.startTime).toFixed(2)}ms on event '${e.name}' at ${e.endTime.toFixed(2)}`)}flush(e){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||e-this._flushTime>=this._flushIntervalInMilliseconds){for(let n=this._flushPointer;this._flushPointer<n+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=Qo()}}get started(){return this._started}},Qo=typeof performance<"u"&&performance.now?()=>performance.now():Date.now});function fl(r,e,n){for(let t of n){let o=t[0],i=t[1],u=t[2],a=t[3],s=t[4];if(r.opType===o){for(let l of e)if((l.domain===i||l.domain==="ai.onnx"&&i==="")&&Wy(l.version,u))return{opImpl:a,opInit:s}}}throw new TypeError(`cannot resolve operator '${r.opType}' with opsets: ${e.map(t=>`${t.domain||"ai.onnx"} v${t.version}`).join(", ")}`)}function Wy(r,e){if(e.endsWith("+")){let n=Number.parseInt(e.substring(0,e.length-1),10);return!isNaN(n)&&n<=r}else if(e.split("-").length===2){let n=e.split("-"),t=Number.parseInt(n[0],10),o=Number.parseInt(n[1],10);return!isNaN(t)&&!isNaN(o)&&t<=r&&r<=o}else return Number.parseInt(e,10)===r}var pl=R(()=>{"use strict"});var hl=Ye(Oa=>{"use strict";Oa.__esModule=!0;var Hy=function(){function r(e){if(!e)throw new TypeError("Invalid argument; `value` has no value.");this.value=r.EMPTY,e&&r.isGuid(e)&&(this.value=e)}return r.isGuid=function(e){var n=e.toString();return e&&(e instanceof r||r.validator.test(n))},r.create=function(){return new r([r.gen(2),r.gen(1),r.gen(1),r.gen(1),r.gen(3)].join("-"))},r.createEmpty=function(){return new r("emptyguid")},r.parse=function(e){return new r(e)},r.raw=function(){return[r.gen(2),r.gen(1),r.gen(1),r.gen(1),r.gen(3)].join("-")},r.gen=function(e){for(var n="",t=0;t<e;t++)n+=((1+Math.random())*65536|0).toString(16).substring(1);return n},r.prototype.equals=function(e){return r.isGuid(e)&&this.value===e.toString()},r.prototype.isEmpty=function(){return this.value===r.EMPTY},r.prototype.toString=function(){return this.value},r.prototype.toJSON=function(){return{value:this.value}},r.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),r.EMPTY="00000000-0000-0000-0000-000000000000",r}();Oa.Guid=Hy});function Xe(r,e,n){this.low=r|0,this.high=e|0,this.unsigned=!!n}function It(r){return(r&&r.__isLong__)===!0}function ml(r){var e=Math.clz32(r&-r);return r?31-e:e}function Xr(r,e){var n,t,o;return e?(r>>>=0,(o=0<=r&&r<256)&&(t=bl[r],t)?t:(n=We(r,0,!0),o&&(bl[r]=n),n)):(r|=0,(o=-128<=r&&r<128)&&(t=gl[r],t)?t:(n=We(r,r<0?-1:0,!1),o&&(gl[r]=n),n))}function Ut(r,e){if(isNaN(r))return e?Ir:Zt;if(e){if(r<0)return Ir;if(r>=xl)return _l}else{if(r<=-vl)return Rt;if(r+1>=vl)return Tl}return r<0?Ut(-r,e).neg():We(r%xn|0,r/xn|0,e)}function We(r,e,n){return new Xe(r,e,n)}function Ca(r,e,n){if(r.length===0)throw Error("empty string");if(typeof e=="number"?(n=e,e=!1):e=!!e,r==="NaN"||r==="Infinity"||r==="+Infinity"||r==="-Infinity")return e?Ir:Zt;if(n=n||10,n<2||36<n)throw RangeError("radix");var t;if((t=r.indexOf("-"))>0)throw Error("interior hyphen");if(t===0)return Ca(r.substring(1),e,n).neg();for(var o=Ut(ni(n,8)),i=Zt,u=0;u<r.length;u+=8){var a=Math.min(8,r.length-u),s=parseInt(r.substring(u,u+a),n);if(a<8){var l=Ut(ni(n,a));i=i.mul(l).add(Ut(s))}else i=i.mul(o),i=i.add(Ut(s))}return i.unsigned=e,i}function Jt(r,e){return typeof r=="number"?Ut(r,e):typeof r=="string"?Ca(r,e):We(r.low,r.high,typeof e=="boolean"?e:r.unsigned)}var Gt,gl,bl,ni,yl,qy,xn,xl,vl,wl,Zt,Ir,wn,$l,Ea,Tl,_l,Rt,Y,Ar,Pa=R(()=>{Gt=null;try{Gt=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}Xe.prototype.__isLong__;Object.defineProperty(Xe.prototype,"__isLong__",{value:!0});Xe.isLong=It;gl={},bl={};Xe.fromInt=Xr;Xe.fromNumber=Ut;Xe.fromBits=We;ni=Math.pow;Xe.fromString=Ca;Xe.fromValue=Jt;yl=65536,qy=1<<24,xn=yl*yl,xl=xn*xn,vl=xl/2,wl=Xr(qy),Zt=Xr(0);Xe.ZERO=Zt;Ir=Xr(0,!0);Xe.UZERO=Ir;wn=Xr(1);Xe.ONE=wn;$l=Xr(1,!0);Xe.UONE=$l;Ea=Xr(-1);Xe.NEG_ONE=Ea;Tl=We(-1,2147483647,!1);Xe.MAX_VALUE=Tl;_l=We(-1,-1,!0);Xe.MAX_UNSIGNED_VALUE=_l;Rt=We(0,-2147483648,!1);Xe.MIN_VALUE=Rt;Y=Xe.prototype;Y.toInt=function(){return this.unsigned?this.low>>>0:this.low};Y.toNumber=function(){return this.unsigned?(this.high>>>0)*xn+(this.low>>>0):this.high*xn+(this.low>>>0)};Y.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Rt)){var n=Ut(e),t=this.div(n),o=t.mul(n).sub(this);return t.toString(e)+o.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var i=Ut(ni(e,6),this.unsigned),u=this,a="";;){var s=u.div(i),l=u.sub(s.mul(i)).toInt()>>>0,d=l.toString(e);if(u=s,u.isZero())return d+a;for(;d.length<6;)d="0"+d;a=""+d+a}};Y.getHighBits=function(){return this.high};Y.getHighBitsUnsigned=function(){return this.high>>>0};Y.getLowBits=function(){return this.low};Y.getLowBitsUnsigned=function(){return this.low>>>0};Y.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Rt)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,n=31;n>0&&!(e&1<<n);n--);return this.high!=0?n+33:n+1};Y.isZero=function(){return this.high===0&&this.low===0};Y.eqz=Y.isZero;Y.isNegative=function(){return!this.unsigned&&this.high<0};Y.isPositive=function(){return this.unsigned||this.high>=0};Y.isOdd=function(){return(this.low&1)===1};Y.isEven=function(){return(this.low&1)===0};Y.equals=function(e){return It(e)||(e=Jt(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};Y.eq=Y.equals;Y.notEquals=function(e){return!this.eq(e)};Y.neq=Y.notEquals;Y.ne=Y.notEquals;Y.lessThan=function(e){return this.comp(e)<0};Y.lt=Y.lessThan;Y.lessThanOrEqual=function(e){return this.comp(e)<=0};Y.lte=Y.lessThanOrEqual;Y.le=Y.lessThanOrEqual;Y.greaterThan=function(e){return this.comp(e)>0};Y.gt=Y.greaterThan;Y.greaterThanOrEqual=function(e){return this.comp(e)>=0};Y.gte=Y.greaterThanOrEqual;Y.ge=Y.greaterThanOrEqual;Y.compare=function(e){if(It(e)||(e=Jt(e)),this.eq(e))return 0;var n=this.isNegative(),t=e.isNegative();return n&&!t?-1:!n&&t?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};Y.comp=Y.compare;Y.negate=function(){return!this.unsigned&&this.eq(Rt)?Rt:this.not().add(wn)};Y.neg=Y.negate;Y.add=function(e){It(e)||(e=Jt(e));var n=this.high>>>16,t=this.high&65535,o=this.low>>>16,i=this.low&65535,u=e.high>>>16,a=e.high&65535,s=e.low>>>16,l=e.low&65535,d=0,f=0,p=0,g=0;return g+=i+l,p+=g>>>16,g&=65535,p+=o+s,f+=p>>>16,p&=65535,f+=t+a,d+=f>>>16,f&=65535,d+=n+u,d&=65535,We(p<<16|g,d<<16|f,this.unsigned)};Y.subtract=function(e){return It(e)||(e=Jt(e)),this.add(e.neg())};Y.sub=Y.subtract;Y.multiply=function(e){if(this.isZero())return this;if(It(e)||(e=Jt(e)),Gt){var n=Gt.mul(this.low,this.high,e.low,e.high);return We(n,Gt.get_high(),this.unsigned)}if(e.isZero())return this.unsigned?Ir:Zt;if(this.eq(Rt))return e.isOdd()?Rt:Zt;if(e.eq(Rt))return this.isOdd()?Rt:Zt;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(wl)&&e.lt(wl))return Ut(this.toNumber()*e.toNumber(),this.unsigned);var t=this.high>>>16,o=this.high&65535,i=this.low>>>16,u=this.low&65535,a=e.high>>>16,s=e.high&65535,l=e.low>>>16,d=e.low&65535,f=0,p=0,g=0,b=0;return b+=u*d,g+=b>>>16,b&=65535,g+=i*d,p+=g>>>16,g&=65535,g+=u*l,p+=g>>>16,g&=65535,p+=o*d,f+=p>>>16,p&=65535,p+=i*l,f+=p>>>16,p&=65535,p+=u*s,f+=p>>>16,p&=65535,f+=t*d+o*l+i*s+u*a,f&=65535,We(g<<16|b,f<<16|p,this.unsigned)};Y.mul=Y.multiply;Y.divide=function(e){if(It(e)||(e=Jt(e)),e.isZero())throw Error("division by zero");if(Gt){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var n=(this.unsigned?Gt.div_u:Gt.div_s)(this.low,this.high,e.low,e.high);return We(n,Gt.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Ir:Zt;var t,o,i;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Ir;if(e.gt(this.shru(1)))return $l;i=Ir}else{if(this.eq(Rt)){if(e.eq(wn)||e.eq(Ea))return Rt;if(e.eq(Rt))return wn;var u=this.shr(1);return t=u.div(e).shl(1),t.eq(Zt)?e.isNegative()?wn:Ea:(o=this.sub(e.mul(t)),i=t.add(o.div(e)),i)}else if(e.eq(Rt))return this.unsigned?Ir:Zt;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();i=Zt}for(o=this;o.gte(e);){t=Math.max(1,Math.floor(o.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(t)/Math.LN2),s=a<=48?1:ni(2,a-48),l=Ut(t),d=l.mul(e);d.isNegative()||d.gt(o);)t-=s,l=Ut(t,this.unsigned),d=l.mul(e);l.isZero()&&(l=wn),i=i.add(l),o=o.sub(d)}return i};Y.div=Y.divide;Y.modulo=function(e){if(It(e)||(e=Jt(e)),Gt){var n=(this.unsigned?Gt.rem_u:Gt.rem_s)(this.low,this.high,e.low,e.high);return We(n,Gt.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};Y.mod=Y.modulo;Y.rem=Y.modulo;Y.not=function(){return We(~this.low,~this.high,this.unsigned)};Y.countLeadingZeros=function(){return this.high?Math.clz32(this.high):Math.clz32(this.low)+32};Y.clz=Y.countLeadingZeros;Y.countTrailingZeros=function(){return this.low?ml(this.low):ml(this.high)+32};Y.ctz=Y.countTrailingZeros;Y.and=function(e){return It(e)||(e=Jt(e)),We(this.low&e.low,this.high&e.high,this.unsigned)};Y.or=function(e){return It(e)||(e=Jt(e)),We(this.low|e.low,this.high|e.high,this.unsigned)};Y.xor=function(e){return It(e)||(e=Jt(e)),We(this.low^e.low,this.high^e.high,this.unsigned)};Y.shiftLeft=function(e){return It(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?We(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):We(0,this.low<<e-32,this.unsigned)};Y.shl=Y.shiftLeft;Y.shiftRight=function(e){return It(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?We(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):We(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};Y.shr=Y.shiftRight;Y.shiftRightUnsigned=function(e){return It(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?We(this.low>>>e|this.high<<32-e,this.high>>>e,this.unsigned):e===32?We(this.high,0,this.unsigned):We(this.high>>>e-32,0,this.unsigned)};Y.shru=Y.shiftRightUnsigned;Y.shr_u=Y.shiftRightUnsigned;Y.rotateLeft=function(e){var n;return It(e)&&(e=e.toInt()),(e&=63)===0?this:e===32?We(this.high,this.low,this.unsigned):e<32?(n=32-e,We(this.low<<e|this.high>>>n,this.high<<e|this.low>>>n,this.unsigned)):(e-=32,n=32-e,We(this.high<<e|this.low>>>n,this.low<<e|this.high>>>n,this.unsigned))};Y.rotl=Y.rotateLeft;Y.rotateRight=function(e){var n;return It(e)&&(e=e.toInt()),(e&=63)===0?this:e===32?We(this.high,this.low,this.unsigned):e<32?(n=32-e,We(this.high<<n|this.low>>>e,this.low<<n|this.high>>>e,this.unsigned)):(e-=32,n=32-e,We(this.low<<n|this.high>>>e,this.high<<n|this.low>>>e,this.unsigned))};Y.rotr=Y.rotateRight;Y.toSigned=function(){return this.unsigned?We(this.low,this.high,!1):this};Y.toUnsigned=function(){return this.unsigned?this:We(this.low,this.high,!0)};Y.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};Y.toBytesLE=function(){var e=this.high,n=this.low;return[n&255,n>>>8&255,n>>>16&255,n>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};Y.toBytesBE=function(){var e=this.high,n=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,n>>>24,n>>>16&255,n>>>8&255,n&255]};Xe.fromBytes=function(e,n,t){return t?Xe.fromBytesLE(e,n):Xe.fromBytesBE(e,n)};Xe.fromBytesLE=function(e,n){return new Xe(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,n)};Xe.fromBytesBE=function(e,n){return new Xe(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],n)};Ar=Xe});var D,oi=R(()=>{D={};D.Offset;D.Table;D.SIZEOF_SHORT=2;D.SIZEOF_INT=4;D.FILE_IDENTIFIER_LENGTH=4;D.SIZE_PREFIX_LENGTH=4;D.Encoding={UTF8_BYTES:1,UTF16_STRING:2};D.int32=new Int32Array(2);D.float32=new Float32Array(D.int32.buffer);D.float64=new Float64Array(D.int32.buffer);D.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1;D.Long=function(r,e){this.low=r|0,this.high=e|0};D.Long.create=function(r,e){return r==0&&e==0?D.Long.ZERO:new D.Long(r,e)};D.Long.prototype.toFloat64=function(){return(this.low>>>0)+this.high*4294967296};D.Long.prototype.equals=function(r){return this.low==r.low&&this.high==r.high};D.Long.ZERO=new D.Long(0,0);D.Builder=function(r){if(r)var e=r;else var e=1024;this.bb=D.ByteBuffer.allocate(e),this.space=e,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1};D.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1};D.Builder.prototype.forceDefaults=function(r){this.force_defaults=r};D.Builder.prototype.dataBuffer=function(){return this.bb};D.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())};D.Builder.prototype.prep=function(r,e){r>this.minalign&&(this.minalign=r);for(var n=~(this.bb.capacity()-this.space+e)+1&r-1;this.space<n+r+e;){var t=this.bb.capacity();this.bb=D.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-t}this.pad(n)};D.Builder.prototype.pad=function(r){for(var e=0;e<r;e++)this.bb.writeInt8(--this.space,0)};D.Builder.prototype.writeInt8=function(r){this.bb.writeInt8(this.space-=1,r)};D.Builder.prototype.writeInt16=function(r){this.bb.writeInt16(this.space-=2,r)};D.Builder.prototype.writeInt32=function(r){this.bb.writeInt32(this.space-=4,r)};D.Builder.prototype.writeInt64=function(r){this.bb.writeInt64(this.space-=8,r)};D.Builder.prototype.writeFloat32=function(r){this.bb.writeFloat32(this.space-=4,r)};D.Builder.prototype.writeFloat64=function(r){this.bb.writeFloat64(this.space-=8,r)};D.Builder.prototype.addInt8=function(r){this.prep(1,0),this.writeInt8(r)};D.Builder.prototype.addInt16=function(r){this.prep(2,0),this.writeInt16(r)};D.Builder.prototype.addInt32=function(r){this.prep(4,0),this.writeInt32(r)};D.Builder.prototype.addInt64=function(r){this.prep(8,0),this.writeInt64(r)};D.Builder.prototype.addFloat32=function(r){this.prep(4,0),this.writeFloat32(r)};D.Builder.prototype.addFloat64=function(r){this.prep(8,0),this.writeFloat64(r)};D.Builder.prototype.addFieldInt8=function(r,e,n){(this.force_defaults||e!=n)&&(this.addInt8(e),this.slot(r))};D.Builder.prototype.addFieldInt16=function(r,e,n){(this.force_defaults||e!=n)&&(this.addInt16(e),this.slot(r))};D.Builder.prototype.addFieldInt32=function(r,e,n){(this.force_defaults||e!=n)&&(this.addInt32(e),this.slot(r))};D.Builder.prototype.addFieldInt64=function(r,e,n){(this.force_defaults||!e.equals(n))&&(this.addInt64(e),this.slot(r))};D.Builder.prototype.addFieldFloat32=function(r,e,n){(this.force_defaults||e!=n)&&(this.addFloat32(e),this.slot(r))};D.Builder.prototype.addFieldFloat64=function(r,e,n){(this.force_defaults||e!=n)&&(this.addFloat64(e),this.slot(r))};D.Builder.prototype.addFieldOffset=function(r,e,n){(this.force_defaults||e!=n)&&(this.addOffset(e),this.slot(r))};D.Builder.prototype.addFieldStruct=function(r,e,n){e!=n&&(this.nested(e),this.slot(r))};D.Builder.prototype.nested=function(r){if(r!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")};D.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")};D.Builder.prototype.slot=function(r){this.vtable[r]=this.offset()};D.Builder.prototype.offset=function(){return this.bb.capacity()-this.space};D.Builder.growByteBuffer=function(r){var e=r.capacity();if(e&3221225472)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var n=e<<1,t=D.ByteBuffer.allocate(n);return t.setPosition(n-e),t.bytes().set(r.bytes(),n-e),t};D.Builder.prototype.addOffset=function(r){this.prep(D.SIZEOF_INT,0),this.writeInt32(this.offset()-r+D.SIZEOF_INT)};D.Builder.prototype.startObject=function(r){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=r;for(var e=0;e<r;e++)this.vtable[e]=0;this.isNested=!0,this.object_start=this.offset()};D.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var r=this.offset(),e=this.vtable_in_use-1;e>=0&&this.vtable[e]==0;e--);for(var n=e+1;e>=0;e--)this.addInt16(this.vtable[e]!=0?r-this.vtable[e]:0);var t=2;this.addInt16(r-this.object_start);var o=(n+t)*D.SIZEOF_SHORT;this.addInt16(o);var i=0,u=this.space;e:for(e=0;e<this.vtables.length;e++){var a=this.bb.capacity()-this.vtables[e];if(o==this.bb.readInt16(a)){for(var s=D.SIZEOF_SHORT;s<o;s+=D.SIZEOF_SHORT)if(this.bb.readInt16(u+s)!=this.bb.readInt16(a+s))continue e;i=this.vtables[e];break}}return i?(this.space=this.bb.capacity()-r,this.bb.writeInt32(this.space,i-r)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-r,this.offset()-r)),this.isNested=!1,r};D.Builder.prototype.finish=function(r,e,n){var t=n?D.SIZE_PREFIX_LENGTH:0;if(e){var o=e;if(this.prep(this.minalign,D.SIZEOF_INT+D.FILE_IDENTIFIER_LENGTH+t),o.length!=D.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+D.FILE_IDENTIFIER_LENGTH);for(var i=D.FILE_IDENTIFIER_LENGTH-1;i>=0;i--)this.writeInt8(o.charCodeAt(i))}this.prep(this.minalign,D.SIZEOF_INT+t),this.addOffset(r),t&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)};D.Builder.prototype.finishSizePrefixed=function(r,e){this.finish(r,e,!0)};D.Builder.prototype.requiredField=function(r,e){var n=this.bb.capacity()-r,t=n-this.bb.readInt32(n),o=this.bb.readInt16(t+e)!=0;if(!o)throw new Error("FlatBuffers: field "+e+" must be set")};D.Builder.prototype.startVector=function(r,e,n){this.notNested(),this.vector_num_elems=e,this.prep(D.SIZEOF_INT,r*e),this.prep(n,r*e)};D.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()};D.Builder.prototype.createString=function(r){if(r instanceof Uint8Array)var e=r;else for(var e=[],n=0;n<r.length;){var t,o=r.charCodeAt(n++);if(o<55296||o>=56320)t=o;else{var i=r.charCodeAt(n++);t=(o<<10)+i+(65536-56623104-56320)}t<128?e.push(t):(t<2048?e.push(t>>6&31|192):(t<65536?e.push(t>>12&15|224):e.push(t>>18&7|240,t>>12&63|128),e.push(t>>6&63|128)),e.push(t&63|128))}this.addInt8(0),this.startVector(1,e.length,1),this.bb.setPosition(this.space-=e.length);for(var n=0,u=this.space,a=this.bb.bytes();n<e.length;n++)a[u++]=e[n];return this.endVector()};D.Builder.prototype.createLong=function(r,e){return D.Long.create(r,e)};D.ByteBuffer=function(r){this.bytes_=r,this.position_=0};D.ByteBuffer.allocate=function(r){return new D.ByteBuffer(new Uint8Array(r))};D.ByteBuffer.prototype.clear=function(){this.position_=0};D.ByteBuffer.prototype.bytes=function(){return this.bytes_};D.ByteBuffer.prototype.position=function(){return this.position_};D.ByteBuffer.prototype.setPosition=function(r){this.position_=r};D.ByteBuffer.prototype.capacity=function(){return this.bytes_.length};D.ByteBuffer.prototype.readInt8=function(r){return this.readUint8(r)<<24>>24};D.ByteBuffer.prototype.readUint8=function(r){return this.bytes_[r]};D.ByteBuffer.prototype.readInt16=function(r){return this.readUint16(r)<<16>>16};D.ByteBuffer.prototype.readUint16=function(r){return this.bytes_[r]|this.bytes_[r+1]<<8};D.ByteBuffer.prototype.readInt32=function(r){return this.bytes_[r]|this.bytes_[r+1]<<8|this.bytes_[r+2]<<16|this.bytes_[r+3]<<24};D.ByteBuffer.prototype.readUint32=function(r){return this.readInt32(r)>>>0};D.ByteBuffer.prototype.readInt64=function(r){return new D.Long(this.readInt32(r),this.readInt32(r+4))};D.ByteBuffer.prototype.readUint64=function(r){return new D.Long(this.readUint32(r),this.readUint32(r+4))};D.ByteBuffer.prototype.readFloat32=function(r){return D.int32[0]=this.readInt32(r),D.float32[0]};D.ByteBuffer.prototype.readFloat64=function(r){return D.int32[D.isLittleEndian?0:1]=this.readInt32(r),D.int32[D.isLittleEndian?1:0]=this.readInt32(r+4),D.float64[0]};D.ByteBuffer.prototype.writeInt8=function(r,e){this.bytes_[r]=e};D.ByteBuffer.prototype.writeUint8=function(r,e){this.bytes_[r]=e};D.ByteBuffer.prototype.writeInt16=function(r,e){this.bytes_[r]=e,this.bytes_[r+1]=e>>8};D.ByteBuffer.prototype.writeUint16=function(r,e){this.bytes_[r]=e,this.bytes_[r+1]=e>>8};D.ByteBuffer.prototype.writeInt32=function(r,e){this.bytes_[r]=e,this.bytes_[r+1]=e>>8,this.bytes_[r+2]=e>>16,this.bytes_[r+3]=e>>24};D.ByteBuffer.prototype.writeUint32=function(r,e){this.bytes_[r]=e,this.bytes_[r+1]=e>>8,this.bytes_[r+2]=e>>16,this.bytes_[r+3]=e>>24};D.ByteBuffer.prototype.writeInt64=function(r,e){this.writeInt32(r,e.low),this.writeInt32(r+4,e.high)};D.ByteBuffer.prototype.writeUint64=function(r,e){this.writeUint32(r,e.low),this.writeUint32(r+4,e.high)};D.ByteBuffer.prototype.writeFloat32=function(r,e){D.float32[0]=e,this.writeInt32(r,D.int32[0])};D.ByteBuffer.prototype.writeFloat64=function(r,e){D.float64[0]=e,this.writeInt32(r,D.int32[D.isLittleEndian?0:1]),this.writeInt32(r+4,D.int32[D.isLittleEndian?1:0])};D.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+D.SIZEOF_INT+D.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var r="",e=0;e<D.FILE_IDENTIFIER_LENGTH;e++)r+=String.fromCharCode(this.readInt8(this.position_+D.SIZEOF_INT+e));return r};D.ByteBuffer.prototype.__offset=function(r,e){var n=r-this.readInt32(r);return e<this.readInt16(n)?this.readInt16(n+e):0};D.ByteBuffer.prototype.__union=function(r,e){return r.bb_pos=e+this.readInt32(e),r.bb=this,r};D.ByteBuffer.prototype.__string=function(r,e){r+=this.readInt32(r);var n=this.readInt32(r),t="",o=0;if(r+=D.SIZEOF_INT,e===D.Encoding.UTF8_BYTES)return this.bytes_.subarray(r,r+n);for(;o<n;){var i,u=this.readUint8(r+o++);if(u<192)i=u;else{var a=this.readUint8(r+o++);if(u<224)i=(u&31)<<6|a&63;else{var s=this.readUint8(r+o++);if(u<240)i=(u&15)<<12|(a&63)<<6|s&63;else{var l=this.readUint8(r+o++);i=(u&7)<<18|(a&63)<<12|(s&63)<<6|l&63}}}i<65536?t+=String.fromCharCode(i):(i-=65536,t+=String.fromCharCode((i>>10)+55296,(i&1024-1)+56320))}return t};D.ByteBuffer.prototype.__indirect=function(r){return r+this.readInt32(r)};D.ByteBuffer.prototype.__vector=function(r){return r+this.readInt32(r)+D.SIZEOF_INT};D.ByteBuffer.prototype.__vector_len=function(r){return this.readInt32(r+this.readInt32(r))};D.ByteBuffer.prototype.__has_identifier=function(r){if(r.length!=D.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+D.FILE_IDENTIFIER_LENGTH);for(var e=0;e<D.FILE_IDENTIFIER_LENGTH;e++)if(r.charCodeAt(e)!=this.readInt8(this.position_+D.SIZEOF_INT+e))return!1;return!0};D.ByteBuffer.prototype.createLong=function(r,e){return D.Long.create(r,e)}});var se,ro=R(()=>{"use strict";oi();(e=>{let r;(t=>{let n;(i=>{let o;(O=>(O[O.UNDEFINED=0]="UNDEFINED",O[O.FLOAT=1]="FLOAT",O[O.INT=2]="INT",O[O.STRING=3]="STRING",O[O.TENSOR=4]="TENSOR",O[O.GRAPH=5]="GRAPH",O[O.FLOATS=6]="FLOATS",O[O.INTS=7]="INTS",O[O.STRINGS=8]="STRINGS",O[O.TENSORS=9]="TENSORS",O[O.GRAPHS=10]="GRAPHS",O[O.SPARSE_TENSOR=11]="SPARSE_TENSOR",O[O.SPARSE_TENSORS=12]="SPARSE_TENSORS"))(o=i.AttributeType||={})})(n=t.fbs||={})})(r=e.experimental||={})})(se||={});(e=>{let r;(t=>{let n;(i=>{let o;(l=>(l[l.UNKNOWN=0]="UNKNOWN",l[l.VALUE=1]="VALUE",l[l.PARAM=2]="PARAM"))(o=i.DimensionValueType||={})})(n=t.fbs||={})})(r=e.experimental||={})})(se||={});(e=>{let r;(t=>{let n;(i=>{let o;(P=>(P[P.UNDEFINED=0]="UNDEFINED",P[P.FLOAT=1]="FLOAT",P[P.UINT8=2]="UINT8",P[P.INT8=3]="INT8",P[P.UINT16=4]="UINT16",P[P.INT16=5]="INT16",P[P.INT32=6]="INT32",P[P.INT64=7]="INT64",P[P.STRING=8]="STRING",P[P.BOOL=9]="BOOL",P[P.FLOAT16=10]="FLOAT16",P[P.DOUBLE=11]="DOUBLE",P[P.UINT32=12]="UINT32",P[P.UINT64=13]="UINT64",P[P.COMPLEX64=14]="COMPLEX64",P[P.COMPLEX128=15]="COMPLEX128",P[P.BFLOAT16=16]="BFLOAT16",P[P.FLOAT8E4M3FN=17]="FLOAT8E4M3FN",P[P.FLOAT8E4M3FNUZ=18]="FLOAT8E4M3FNUZ",P[P.FLOAT8E5M2=19]="FLOAT8E5M2",P[P.FLOAT8E5M2FNUZ=20]="FLOAT8E5M2FNUZ"))(o=i.TensorDataType||={})})(n=t.fbs||={})})(r=e.experimental||={})})(se||={});(e=>{let r;(t=>{let n;(i=>{let o;(s=>(s[s.Primitive=0]="Primitive",s[s.Fused=1]="Fused"))(o=i.NodeType||={})})(n=t.fbs||={})})(r=e.experimental||={})})(se||={});(e=>{let r;(t=>{let n;(i=>{let o;(d=>(d[d.NONE=0]="NONE",d[d.tensor_type=1]="tensor_type",d[d.sequence_type=2]="sequence_type",d[d.map_type=3]="map_type"))(o=i.TypeInfoValue||={})})(n=t.fbs||={})})(r=e.experimental||={})})(se||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,s){return this.bb_pos=a,this.bb=s,this}static getRootAsShape(a,s){return(s||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsShape(a,s){return a.setPosition(a.position()+D.SIZE_PREFIX_LENGTH),(s||new o).__init(a.readInt32(a.position())+a.position(),a)}dim(a,s){let l=this.bb.__offset(this.bb_pos,4);return l?(s||new e.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}dimLength(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__vector_len(this.bb_pos+a):0}static startShape(a){a.startObject(1)}static addDim(a,s){a.addFieldOffset(0,s,0)}static createDimVector(a,s){a.startVector(4,s.length,4);for(let l=s.length-1;l>=0;l--)a.addOffset(s[l]);return a.endVector()}static startDimVector(a,s){a.startVector(4,s,4)}static endShape(a){return a.endObject()}static createShape(a,s){return o.startShape(a),o.addDim(a,s),o.endShape(a)}}i.Shape=o})(n=t.fbs||={})})(r=e.experimental||={})})(se||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,s){return this.bb_pos=a,this.bb=s,this}static getRootAsDimension(a,s){return(s||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsDimension(a,s){return a.setPosition(a.position()+D.SIZE_PREFIX_LENGTH),(s||new o).__init(a.readInt32(a.position())+a.position(),a)}value(a){let s=this.bb.__offset(this.bb_pos,4);return s?(a||new e.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}denotation(a){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,a):null}static startDimension(a){a.startObject(2)}static addValue(a,s){a.addFieldOffset(0,s,0)}static addDenotation(a,s){a.addFieldOffset(1,s,0)}static endDimension(a){return a.endObject()}static createDimension(a,s,l){return o.startDimension(a),o.addValue(a,s),o.addDenotation(a,l),o.endDimension(a)}}i.Dimension=o})(n=t.fbs||={})})(r=e.experimental||={})})(se||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,s){return this.bb_pos=a,this.bb=s,this}static getRootAsDimensionValue(a,s){return(s||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsDimensionValue(a,s){return a.setPosition(a.position()+D.SIZE_PREFIX_LENGTH),(s||new o).__init(a.readInt32(a.position())+a.position(),a)}dimType(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readInt8(this.bb_pos+a):0}dimValue(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.readInt64(this.bb_pos+a):this.bb.createLong(0,0)}dimParam(a){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.__string(this.bb_pos+s,a):null}static startDimensionValue(a){a.startObject(3)}static addDimType(a,s){a.addFieldInt8(0,s,0)}static addDimValue(a,s){a.addFieldInt64(1,s,a.createLong(0,0))}static addDimParam(a,s){a.addFieldOffset(2,s,0)}static endDimensionValue(a){return a.endObject()}static createDimensionValue(a,s,l,d){return o.startDimensionValue(a),o.addDimType(a,s),o.addDimValue(a,l),o.addDimParam(a,d),o.endDimensionValue(a)}}i.DimensionValue=o})(n=t.fbs||={})})(r=e.experimental||={})})(se||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,s){return this.bb_pos=a,this.bb=s,this}static getRootAsTensorTypeAndShape(a,s){return(s||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsTensorTypeAndShape(a,s){return a.setPosition(a.position()+D.SIZE_PREFIX_LENGTH),(s||new o).__init(a.readInt32(a.position())+a.position(),a)}elemType(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readInt32(this.bb_pos+a):0}shape(a){let s=this.bb.__offset(this.bb_pos,6);return s?(a||new e.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}static startTensorTypeAndShape(a){a.startObject(2)}static addElemType(a,s){a.addFieldInt32(0,s,0)}static addShape(a,s){a.addFieldOffset(1,s,0)}static endTensorTypeAndShape(a){return a.endObject()}static createTensorTypeAndShape(a,s,l){return o.startTensorTypeAndShape(a),o.addElemType(a,s),o.addShape(a,l),o.endTensorTypeAndShape(a)}}i.TensorTypeAndShape=o})(n=t.fbs||={})})(r=e.experimental||={})})(se||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,s){return this.bb_pos=a,this.bb=s,this}static getRootAsMapType(a,s){return(s||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsMapType(a,s){return a.setPosition(a.position()+D.SIZE_PREFIX_LENGTH),(s||new o).__init(a.readInt32(a.position())+a.position(),a)}keyType(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readInt32(this.bb_pos+a):0}valueType(a){let s=this.bb.__offset(this.bb_pos,6);return s?(a||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}static startMapType(a){a.startObject(2)}static addKeyType(a,s){a.addFieldInt32(0,s,0)}static addValueType(a,s){a.addFieldOffset(1,s,0)}static endMapType(a){return a.endObject()}static createMapType(a,s,l){return o.startMapType(a),o.addKeyType(a,s),o.addValueType(a,l),o.endMapType(a)}}i.MapType=o})(n=t.fbs||={})})(r=e.experimental||={})})(se||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,s){return this.bb_pos=a,this.bb=s,this}static getRootAsSequenceType(a,s){return(s||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsSequenceType(a,s){return a.setPosition(a.position()+D.SIZE_PREFIX_LENGTH),(s||new o).__init(a.readInt32(a.position())+a.position(),a)}elemType(a){let s=this.bb.__offset(this.bb_pos,4);return s?(a||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}static startSequenceType(a){a.startObject(1)}static addElemType(a,s){a.addFieldOffset(0,s,0)}static endSequenceType(a){return a.endObject()}static createSequenceType(a,s){return o.startSequenceType(a),o.addElemType(a,s),o.endSequenceType(a)}}i.SequenceType=o})(n=t.fbs||={})})(r=e.experimental||={})})(se||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,s){return this.bb_pos=a,this.bb=s,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(a,s,l,d){return a.prep(4,12),a.writeInt32(d),a.writeInt32(l),a.writeInt32(s),a.offset()}}i.EdgeEnd=o})(n=t.fbs||={})})(r=e.experimental||={})})(se||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,s){return this.bb_pos=a,this.bb=s,this}static getRootAsNodeEdge(a,s){return(s||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsNodeEdge(a,s){return a.setPosition(a.position()+D.SIZE_PREFIX_LENGTH),(s||new o).__init(a.readInt32(a.position())+a.position(),a)}nodeIndex(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readUint32(this.bb_pos+a):0}inputEdges(a,s){let l=this.bb.__offset(this.bb_pos,6);return l?(s||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+l)+a*12,this.bb):null}inputEdgesLength(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__vector_len(this.bb_pos+a):0}outputEdges(a,s){let l=this.bb.__offset(this.bb_pos,8);return l?(s||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+l)+a*12,this.bb):null}outputEdgesLength(){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__vector_len(this.bb_pos+a):0}static startNodeEdge(a){a.startObject(3)}static addNodeIndex(a,s){a.addFieldInt32(0,s,0)}static addInputEdges(a,s){a.addFieldOffset(1,s,0)}static startInputEdgesVector(a,s){a.startVector(12,s,4)}static addOutputEdges(a,s){a.addFieldOffset(2,s,0)}static startOutputEdgesVector(a,s){a.startVector(12,s,4)}static endNodeEdge(a){return a.endObject()}static createNodeEdge(a,s,l,d){return o.startNodeEdge(a),o.addNodeIndex(a,s),o.addInputEdges(a,l),o.addOutputEdges(a,d),o.endNodeEdge(a)}}i.NodeEdge=o})(n=t.fbs||={})})(r=e.experimental||={})})(se||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,s){return this.bb_pos=a,this.bb=s,this}static getRootAsNode(a,s){return(s||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsNode(a,s){return a.setPosition(a.position()+D.SIZE_PREFIX_LENGTH),(s||new o).__init(a.readInt32(a.position())+a.position(),a)}name(a){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,a):null}docString(a){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,a):null}domain(a){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.__string(this.bb_pos+s,a):null}sinceVersion(){let a=this.bb.__offset(this.bb_pos,10);return a?this.bb.readInt32(this.bb_pos+a):0}index(){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.readUint32(this.bb_pos+a):0}opType(a){let s=this.bb.__offset(this.bb_pos,14);return s?this.bb.__string(this.bb_pos+s,a):null}type(){let a=this.bb.__offset(this.bb_pos,16);return a?this.bb.readInt32(this.bb_pos+a):0}executionProviderType(a){let s=this.bb.__offset(this.bb_pos,18);return s?this.bb.__string(this.bb_pos+s,a):null}inputs(a,s){let l=this.bb.__offset(this.bb_pos,20);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+a*4,s):null}inputsLength(){let a=this.bb.__offset(this.bb_pos,20);return a?this.bb.__vector_len(this.bb_pos+a):0}outputs(a,s){let l=this.bb.__offset(this.bb_pos,22);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+a*4,s):null}outputsLength(){let a=this.bb.__offset(this.bb_pos,22);return a?this.bb.__vector_len(this.bb_pos+a):0}attributes(a,s){let l=this.bb.__offset(this.bb_pos,24);return l?(s||new e.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}attributesLength(){let a=this.bb.__offset(this.bb_pos,24);return a?this.bb.__vector_len(this.bb_pos+a):0}inputArgCounts(a){let s=this.bb.__offset(this.bb_pos,26);return s?this.bb.readInt32(this.bb.__vector(this.bb_pos+s)+a*4):0}inputArgCountsLength(){let a=this.bb.__offset(this.bb_pos,26);return a?this.bb.__vector_len(this.bb_pos+a):0}inputArgCountsArray(){let a=this.bb.__offset(this.bb_pos,26);return a?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+a),this.bb.__vector_len(this.bb_pos+a)):null}implicitInputs(a,s){let l=this.bb.__offset(this.bb_pos,28);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+a*4,s):null}implicitInputsLength(){let a=this.bb.__offset(this.bb_pos,28);return a?this.bb.__vector_len(this.bb_pos+a):0}static startNode(a){a.startObject(13)}static addName(a,s){a.addFieldOffset(0,s,0)}static addDocString(a,s){a.addFieldOffset(1,s,0)}static addDomain(a,s){a.addFieldOffset(2,s,0)}static addSinceVersion(a,s){a.addFieldInt32(3,s,0)}static addIndex(a,s){a.addFieldInt32(4,s,0)}static addOpType(a,s){a.addFieldOffset(5,s,0)}static addType(a,s){a.addFieldInt32(6,s,0)}static addExecutionProviderType(a,s){a.addFieldOffset(7,s,0)}static addInputs(a,s){a.addFieldOffset(8,s,0)}static createInputsVector(a,s){a.startVector(4,s.length,4);for(let l=s.length-1;l>=0;l--)a.addOffset(s[l]);return a.endVector()}static startInputsVector(a,s){a.startVector(4,s,4)}static addOutputs(a,s){a.addFieldOffset(9,s,0)}static createOutputsVector(a,s){a.startVector(4,s.length,4);for(let l=s.length-1;l>=0;l--)a.addOffset(s[l]);return a.endVector()}static startOutputsVector(a,s){a.startVector(4,s,4)}static addAttributes(a,s){a.addFieldOffset(10,s,0)}static createAttributesVector(a,s){a.startVector(4,s.length,4);for(let l=s.length-1;l>=0;l--)a.addOffset(s[l]);return a.endVector()}static startAttributesVector(a,s){a.startVector(4,s,4)}static addInputArgCounts(a,s){a.addFieldOffset(11,s,0)}static createInputArgCountsVector(a,s){a.startVector(4,s.length,4);for(let l=s.length-1;l>=0;l--)a.addInt32(s[l]);return a.endVector()}static startInputArgCountsVector(a,s){a.startVector(4,s,4)}static addImplicitInputs(a,s){a.addFieldOffset(12,s,0)}static createImplicitInputsVector(a,s){a.startVector(4,s.length,4);for(let l=s.length-1;l>=0;l--)a.addOffset(s[l]);return a.endVector()}static startImplicitInputsVector(a,s){a.startVector(4,s,4)}static endNode(a){return a.endObject()}static createNode(a,s,l,d,f,p,g,b,y,_,x,S,O,C){return o.startNode(a),o.addName(a,s),o.addDocString(a,l),o.addDomain(a,d),o.addSinceVersion(a,f),o.addIndex(a,p),o.addOpType(a,g),o.addType(a,b),o.addExecutionProviderType(a,y),o.addInputs(a,_),o.addOutputs(a,x),o.addAttributes(a,S),o.addInputArgCounts(a,O),o.addImplicitInputs(a,C),o.endNode(a)}}i.Node=o})(n=t.fbs||={})})(r=e.experimental||={})})(se||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,s){return this.bb_pos=a,this.bb=s,this}static getRootAsValueInfo(a,s){return(s||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsValueInfo(a,s){return a.setPosition(a.position()+D.SIZE_PREFIX_LENGTH),(s||new o).__init(a.readInt32(a.position())+a.position(),a)}name(a){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,a):null}docString(a){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,a):null}type(a){let s=this.bb.__offset(this.bb_pos,8);return s?(a||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}static startValueInfo(a){a.startObject(3)}static addName(a,s){a.addFieldOffset(0,s,0)}static addDocString(a,s){a.addFieldOffset(1,s,0)}static addType(a,s){a.addFieldOffset(2,s,0)}static endValueInfo(a){return a.endObject()}static createValueInfo(a,s,l,d){return o.startValueInfo(a),o.addName(a,s),o.addDocString(a,l),o.addType(a,d),o.endValueInfo(a)}}i.ValueInfo=o})(n=t.fbs||={})})(r=e.experimental||={})})(se||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,s){return this.bb_pos=a,this.bb=s,this}static getRootAsTypeInfo(a,s){return(s||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsTypeInfo(a,s){return a.setPosition(a.position()+D.SIZE_PREFIX_LENGTH),(s||new o).__init(a.readInt32(a.position())+a.position(),a)}denotation(a){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,a):null}valueType(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.readUint8(this.bb_pos+a):0}value(a){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.__union(a,this.bb_pos+s):null}static startTypeInfo(a){a.startObject(3)}static addDenotation(a,s){a.addFieldOffset(0,s,0)}static addValueType(a,s){a.addFieldInt8(1,s,0)}static addValue(a,s){a.addFieldOffset(2,s,0)}static endTypeInfo(a){return a.endObject()}static createTypeInfo(a,s,l,d){return o.startTypeInfo(a),o.addDenotation(a,s),o.addValueType(a,l),o.addValue(a,d),o.endTypeInfo(a)}}i.TypeInfo=o})(n=t.fbs||={})})(r=e.experimental||={})})(se||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,s){return this.bb_pos=a,this.bb=s,this}static getRootAsOperatorSetId(a,s){return(s||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsOperatorSetId(a,s){return a.setPosition(a.position()+D.SIZE_PREFIX_LENGTH),(s||new o).__init(a.readInt32(a.position())+a.position(),a)}domain(a){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,a):null}version(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.readInt64(this.bb_pos+a):this.bb.createLong(0,0)}static startOperatorSetId(a){a.startObject(2)}static addDomain(a,s){a.addFieldOffset(0,s,0)}static addVersion(a,s){a.addFieldInt64(1,s,a.createLong(0,0))}static endOperatorSetId(a){return a.endObject()}static createOperatorSetId(a,s,l){return o.startOperatorSetId(a),o.addDomain(a,s),o.addVersion(a,l),o.endOperatorSetId(a)}}i.OperatorSetId=o})(n=t.fbs||={})})(r=e.experimental||={})})(se||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,s){return this.bb_pos=a,this.bb=s,this}static getRootAsTensor(a,s){return(s||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsTensor(a,s){return a.setPosition(a.position()+D.SIZE_PREFIX_LENGTH),(s||new o).__init(a.readInt32(a.position())+a.position(),a)}name(a){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,a):null}docString(a){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,a):null}dims(a){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readInt64(this.bb.__vector(this.bb_pos+s)+a*8):this.bb.createLong(0,0)}dimsLength(){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__vector_len(this.bb_pos+a):0}dataType(){let a=this.bb.__offset(this.bb_pos,10);return a?this.bb.readInt32(this.bb_pos+a):0}rawData(a){let s=this.bb.__offset(this.bb_pos,12);return s?this.bb.readUint8(this.bb.__vector(this.bb_pos+s)+a):0}rawDataLength(){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.__vector_len(this.bb_pos+a):0}rawDataArray(){let a=this.bb.__offset(this.bb_pos,12);return a?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+a),this.bb.__vector_len(this.bb_pos+a)):null}stringData(a,s){let l=this.bb.__offset(this.bb_pos,14);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+a*4,s):null}stringDataLength(){let a=this.bb.__offset(this.bb_pos,14);return a?this.bb.__vector_len(this.bb_pos+a):0}static startTensor(a){a.startObject(6)}static addName(a,s){a.addFieldOffset(0,s,0)}static addDocString(a,s){a.addFieldOffset(1,s,0)}static addDims(a,s){a.addFieldOffset(2,s,0)}static createDimsVector(a,s){a.startVector(8,s.length,8);for(let l=s.length-1;l>=0;l--)a.addInt64(s[l]);return a.endVector()}static startDimsVector(a,s){a.startVector(8,s,8)}static addDataType(a,s){a.addFieldInt32(3,s,0)}static addRawData(a,s){a.addFieldOffset(4,s,0)}static createRawDataVector(a,s){a.startVector(1,s.length,1);for(let l=s.length-1;l>=0;l--)a.addInt8(s[l]);return a.endVector()}static startRawDataVector(a,s){a.startVector(1,s,1)}static addStringData(a,s){a.addFieldOffset(5,s,0)}static createStringDataVector(a,s){a.startVector(4,s.length,4);for(let l=s.length-1;l>=0;l--)a.addOffset(s[l]);return a.endVector()}static startStringDataVector(a,s){a.startVector(4,s,4)}static endTensor(a){return a.endObject()}static createTensor(a,s,l,d,f,p,g){return o.startTensor(a),o.addName(a,s),o.addDocString(a,l),o.addDims(a,d),o.addDataType(a,f),o.addRawData(a,p),o.addStringData(a,g),o.endTensor(a)}}i.Tensor=o})(n=t.fbs||={})})(r=e.experimental||={})})(se||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,s){return this.bb_pos=a,this.bb=s,this}static getRootAsSparseTensor(a,s){return(s||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsSparseTensor(a,s){return a.setPosition(a.position()+D.SIZE_PREFIX_LENGTH),(s||new o).__init(a.readInt32(a.position())+a.position(),a)}values(a){let s=this.bb.__offset(this.bb_pos,4);return s?(a||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}indices(a){let s=this.bb.__offset(this.bb_pos,6);return s?(a||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}dims(a){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readInt64(this.bb.__vector(this.bb_pos+s)+a*8):this.bb.createLong(0,0)}dimsLength(){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__vector_len(this.bb_pos+a):0}static startSparseTensor(a){a.startObject(3)}static addValues(a,s){a.addFieldOffset(0,s,0)}static addIndices(a,s){a.addFieldOffset(1,s,0)}static addDims(a,s){a.addFieldOffset(2,s,0)}static createDimsVector(a,s){a.startVector(8,s.length,8);for(let l=s.length-1;l>=0;l--)a.addInt64(s[l]);return a.endVector()}static startDimsVector(a,s){a.startVector(8,s,8)}static endSparseTensor(a){return a.endObject()}static createSparseTensor(a,s,l,d){return o.startSparseTensor(a),o.addValues(a,s),o.addIndices(a,l),o.addDims(a,d),o.endSparseTensor(a)}}i.SparseTensor=o})(n=t.fbs||={})})(r=e.experimental||={})})(se||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,s){return this.bb_pos=a,this.bb=s,this}static getRootAsAttribute(a,s){return(s||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsAttribute(a,s){return a.setPosition(a.position()+D.SIZE_PREFIX_LENGTH),(s||new o).__init(a.readInt32(a.position())+a.position(),a)}name(a){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,a):null}docString(a){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,a):null}type(){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.readInt32(this.bb_pos+a):0}f(){let a=this.bb.__offset(this.bb_pos,10);return a?this.bb.readFloat32(this.bb_pos+a):0}i(){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.readInt64(this.bb_pos+a):this.bb.createLong(0,0)}s(a){let s=this.bb.__offset(this.bb_pos,14);return s?this.bb.__string(this.bb_pos+s,a):null}t(a){let s=this.bb.__offset(this.bb_pos,16);return s?(a||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}g(a){let s=this.bb.__offset(this.bb_pos,18);return s?(a||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}floats(a){let s=this.bb.__offset(this.bb_pos,20);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+a*4):0}floatsLength(){let a=this.bb.__offset(this.bb_pos,20);return a?this.bb.__vector_len(this.bb_pos+a):0}floatsArray(){let a=this.bb.__offset(this.bb_pos,20);return a?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+a),this.bb.__vector_len(this.bb_pos+a)):null}ints(a){let s=this.bb.__offset(this.bb_pos,22);return s?this.bb.readInt64(this.bb.__vector(this.bb_pos+s)+a*8):this.bb.createLong(0,0)}intsLength(){let a=this.bb.__offset(this.bb_pos,22);return a?this.bb.__vector_len(this.bb_pos+a):0}strings(a,s){let l=this.bb.__offset(this.bb_pos,24);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+a*4,s):null}stringsLength(){let a=this.bb.__offset(this.bb_pos,24);return a?this.bb.__vector_len(this.bb_pos+a):0}tensors(a,s){let l=this.bb.__offset(this.bb_pos,26);return l?(s||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}tensorsLength(){let a=this.bb.__offset(this.bb_pos,26);return a?this.bb.__vector_len(this.bb_pos+a):0}graphs(a,s){let l=this.bb.__offset(this.bb_pos,28);return l?(s||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}graphsLength(){let a=this.bb.__offset(this.bb_pos,28);return a?this.bb.__vector_len(this.bb_pos+a):0}static startAttribute(a){a.startObject(13)}static addName(a,s){a.addFieldOffset(0,s,0)}static addDocString(a,s){a.addFieldOffset(1,s,0)}static addType(a,s){a.addFieldInt32(2,s,0)}static addF(a,s){a.addFieldFloat32(3,s,0)}static addI(a,s){a.addFieldInt64(4,s,a.createLong(0,0))}static addS(a,s){a.addFieldOffset(5,s,0)}static addT(a,s){a.addFieldOffset(6,s,0)}static addG(a,s){a.addFieldOffset(7,s,0)}static addFloats(a,s){a.addFieldOffset(8,s,0)}static createFloatsVector(a,s){a.startVector(4,s.length,4);for(let l=s.length-1;l>=0;l--)a.addFloat32(s[l]);return a.endVector()}static startFloatsVector(a,s){a.startVector(4,s,4)}static addInts(a,s){a.addFieldOffset(9,s,0)}static createIntsVector(a,s){a.startVector(8,s.length,8);for(let l=s.length-1;l>=0;l--)a.addInt64(s[l]);return a.endVector()}static startIntsVector(a,s){a.startVector(8,s,8)}static addStrings(a,s){a.addFieldOffset(10,s,0)}static createStringsVector(a,s){a.startVector(4,s.length,4);for(let l=s.length-1;l>=0;l--)a.addOffset(s[l]);return a.endVector()}static startStringsVector(a,s){a.startVector(4,s,4)}static addTensors(a,s){a.addFieldOffset(11,s,0)}static createTensorsVector(a,s){a.startVector(4,s.length,4);for(let l=s.length-1;l>=0;l--)a.addOffset(s[l]);return a.endVector()}static startTensorsVector(a,s){a.startVector(4,s,4)}static addGraphs(a,s){a.addFieldOffset(12,s,0)}static createGraphsVector(a,s){a.startVector(4,s.length,4);for(let l=s.length-1;l>=0;l--)a.addOffset(s[l]);return a.endVector()}static startGraphsVector(a,s){a.startVector(4,s,4)}static endAttribute(a){return a.endObject()}static createAttribute(a,s,l,d,f,p,g,b,y,_,x,S,O,C){return o.startAttribute(a),o.addName(a,s),o.addDocString(a,l),o.addType(a,d),o.addF(a,f),o.addI(a,p),o.addS(a,g),o.addT(a,b),o.addG(a,y),o.addFloats(a,_),o.addInts(a,x),o.addStrings(a,S),o.addTensors(a,O),o.addGraphs(a,C),o.endAttribute(a)}}i.Attribute=o})(n=t.fbs||={})})(r=e.experimental||={})})(se||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,s){return this.bb_pos=a,this.bb=s,this}static getRootAsGraph(a,s){return(s||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsGraph(a,s){return a.setPosition(a.position()+D.SIZE_PREFIX_LENGTH),(s||new o).__init(a.readInt32(a.position())+a.position(),a)}initializers(a,s){let l=this.bb.__offset(this.bb_pos,4);return l?(s||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}initializersLength(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__vector_len(this.bb_pos+a):0}nodeArgs(a,s){let l=this.bb.__offset(this.bb_pos,6);return l?(s||new e.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}nodeArgsLength(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__vector_len(this.bb_pos+a):0}nodes(a,s){let l=this.bb.__offset(this.bb_pos,8);return l?(s||new e.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}nodesLength(){let a=this.bb.__offset(this.bb_pos,8);return a?this.bb.__vector_len(this.bb_pos+a):0}maxNodeIndex(){let a=this.bb.__offset(this.bb_pos,10);return a?this.bb.readUint32(this.bb_pos+a):0}nodeEdges(a,s){let l=this.bb.__offset(this.bb_pos,12);return l?(s||new e.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}nodeEdgesLength(){let a=this.bb.__offset(this.bb_pos,12);return a?this.bb.__vector_len(this.bb_pos+a):0}inputs(a,s){let l=this.bb.__offset(this.bb_pos,14);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+a*4,s):null}inputsLength(){let a=this.bb.__offset(this.bb_pos,14);return a?this.bb.__vector_len(this.bb_pos+a):0}outputs(a,s){let l=this.bb.__offset(this.bb_pos,16);return l?this.bb.__string(this.bb.__vector(this.bb_pos+l)+a*4,s):null}outputsLength(){let a=this.bb.__offset(this.bb_pos,16);return a?this.bb.__vector_len(this.bb_pos+a):0}sparseInitializers(a,s){let l=this.bb.__offset(this.bb_pos,18);return l?(s||new e.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}sparseInitializersLength(){let a=this.bb.__offset(this.bb_pos,18);return a?this.bb.__vector_len(this.bb_pos+a):0}static startGraph(a){a.startObject(8)}static addInitializers(a,s){a.addFieldOffset(0,s,0)}static createInitializersVector(a,s){a.startVector(4,s.length,4);for(let l=s.length-1;l>=0;l--)a.addOffset(s[l]);return a.endVector()}static startInitializersVector(a,s){a.startVector(4,s,4)}static addNodeArgs(a,s){a.addFieldOffset(1,s,0)}static createNodeArgsVector(a,s){a.startVector(4,s.length,4);for(let l=s.length-1;l>=0;l--)a.addOffset(s[l]);return a.endVector()}static startNodeArgsVector(a,s){a.startVector(4,s,4)}static addNodes(a,s){a.addFieldOffset(2,s,0)}static createNodesVector(a,s){a.startVector(4,s.length,4);for(let l=s.length-1;l>=0;l--)a.addOffset(s[l]);return a.endVector()}static startNodesVector(a,s){a.startVector(4,s,4)}static addMaxNodeIndex(a,s){a.addFieldInt32(3,s,0)}static addNodeEdges(a,s){a.addFieldOffset(4,s,0)}static createNodeEdgesVector(a,s){a.startVector(4,s.length,4);for(let l=s.length-1;l>=0;l--)a.addOffset(s[l]);return a.endVector()}static startNodeEdgesVector(a,s){a.startVector(4,s,4)}static addInputs(a,s){a.addFieldOffset(5,s,0)}static createInputsVector(a,s){a.startVector(4,s.length,4);for(let l=s.length-1;l>=0;l--)a.addOffset(s[l]);return a.endVector()}static startInputsVector(a,s){a.startVector(4,s,4)}static addOutputs(a,s){a.addFieldOffset(6,s,0)}static createOutputsVector(a,s){a.startVector(4,s.length,4);for(let l=s.length-1;l>=0;l--)a.addOffset(s[l]);return a.endVector()}static startOutputsVector(a,s){a.startVector(4,s,4)}static addSparseInitializers(a,s){a.addFieldOffset(7,s,0)}static createSparseInitializersVector(a,s){a.startVector(4,s.length,4);for(let l=s.length-1;l>=0;l--)a.addOffset(s[l]);return a.endVector()}static startSparseInitializersVector(a,s){a.startVector(4,s,4)}static endGraph(a){return a.endObject()}static createGraph(a,s,l,d,f,p,g,b,y){return o.startGraph(a),o.addInitializers(a,s),o.addNodeArgs(a,l),o.addNodes(a,d),o.addMaxNodeIndex(a,f),o.addNodeEdges(a,p),o.addInputs(a,g),o.addOutputs(a,b),o.addSparseInitializers(a,y),o.endGraph(a)}}i.Graph=o})(n=t.fbs||={})})(r=e.experimental||={})})(se||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,s){return this.bb_pos=a,this.bb=s,this}static getRootAsModel(a,s){return(s||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsModel(a,s){return a.setPosition(a.position()+D.SIZE_PREFIX_LENGTH),(s||new o).__init(a.readInt32(a.position())+a.position(),a)}irVersion(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.readInt64(this.bb_pos+a):this.bb.createLong(0,0)}opsetImport(a,s){let l=this.bb.__offset(this.bb_pos,6);return l?(s||new e.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}opsetImportLength(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__vector_len(this.bb_pos+a):0}producerName(a){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.__string(this.bb_pos+s,a):null}producerVersion(a){let s=this.bb.__offset(this.bb_pos,10);return s?this.bb.__string(this.bb_pos+s,a):null}domain(a){let s=this.bb.__offset(this.bb_pos,12);return s?this.bb.__string(this.bb_pos+s,a):null}modelVersion(){let a=this.bb.__offset(this.bb_pos,14);return a?this.bb.readInt64(this.bb_pos+a):this.bb.createLong(0,0)}docString(a){let s=this.bb.__offset(this.bb_pos,16);return s?this.bb.__string(this.bb_pos+s,a):null}graph(a){let s=this.bb.__offset(this.bb_pos,18);return s?(a||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}graphDocString(a){let s=this.bb.__offset(this.bb_pos,20);return s?this.bb.__string(this.bb_pos+s,a):null}static startModel(a){a.startObject(9)}static addIrVersion(a,s){a.addFieldInt64(0,s,a.createLong(0,0))}static addOpsetImport(a,s){a.addFieldOffset(1,s,0)}static createOpsetImportVector(a,s){a.startVector(4,s.length,4);for(let l=s.length-1;l>=0;l--)a.addOffset(s[l]);return a.endVector()}static startOpsetImportVector(a,s){a.startVector(4,s,4)}static addProducerName(a,s){a.addFieldOffset(2,s,0)}static addProducerVersion(a,s){a.addFieldOffset(3,s,0)}static addDomain(a,s){a.addFieldOffset(4,s,0)}static addModelVersion(a,s){a.addFieldInt64(5,s,a.createLong(0,0))}static addDocString(a,s){a.addFieldOffset(6,s,0)}static addGraph(a,s){a.addFieldOffset(7,s,0)}static addGraphDocString(a,s){a.addFieldOffset(8,s,0)}static endModel(a){return a.endObject()}static createModel(a,s,l,d,f,p,g,b,y,_){return o.startModel(a),o.addIrVersion(a,s),o.addOpsetImport(a,l),o.addProducerName(a,d),o.addProducerVersion(a,f),o.addDomain(a,p),o.addModelVersion(a,g),o.addDocString(a,b),o.addGraph(a,y),o.addGraphDocString(a,_),o.endModel(a)}}i.Model=o})(n=t.fbs||={})})(r=e.experimental||={})})(se||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,s){return this.bb_pos=a,this.bb=s,this}static getRootAsKernelCreateInfos(a,s){return(s||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsKernelCreateInfos(a,s){return a.setPosition(a.position()+D.SIZE_PREFIX_LENGTH),(s||new o).__init(a.readInt32(a.position())+a.position(),a)}nodeIndices(a){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+a*4):0}nodeIndicesLength(){let a=this.bb.__offset(this.bb_pos,4);return a?this.bb.__vector_len(this.bb_pos+a):0}nodeIndicesArray(){let a=this.bb.__offset(this.bb_pos,4);return a?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+a),this.bb.__vector_len(this.bb_pos+a)):null}kernelDefHashes(a){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readUint64(this.bb.__vector(this.bb_pos+s)+a*8):this.bb.createLong(0,0)}kernelDefHashesLength(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__vector_len(this.bb_pos+a):0}static startKernelCreateInfos(a){a.startObject(2)}static addNodeIndices(a,s){a.addFieldOffset(0,s,0)}static createNodeIndicesVector(a,s){a.startVector(4,s.length,4);for(let l=s.length-1;l>=0;l--)a.addInt32(s[l]);return a.endVector()}static startNodeIndicesVector(a,s){a.startVector(4,s,4)}static addKernelDefHashes(a,s){a.addFieldOffset(1,s,0)}static createKernelDefHashesVector(a,s){a.startVector(8,s.length,8);for(let l=s.length-1;l>=0;l--)a.addInt64(s[l]);return a.endVector()}static startKernelDefHashesVector(a,s){a.startVector(8,s,8)}static endKernelCreateInfos(a){return a.endObject()}static createKernelCreateInfos(a,s,l){return o.startKernelCreateInfos(a),o.addNodeIndices(a,s),o.addKernelDefHashes(a,l),o.endKernelCreateInfos(a)}}i.KernelCreateInfos=o})(n=t.fbs||={})})(r=e.experimental||={})})(se||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,s){return this.bb_pos=a,this.bb=s,this}static getRootAsSubGraphSessionState(a,s){return(s||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsSubGraphSessionState(a,s){return a.setPosition(a.position()+D.SIZE_PREFIX_LENGTH),(s||new o).__init(a.readInt32(a.position())+a.position(),a)}graphId(a){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,a):null}sessionState(a){let s=this.bb.__offset(this.bb_pos,6);return s?(a||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}static startSubGraphSessionState(a){a.startObject(2)}static addGraphId(a,s){a.addFieldOffset(0,s,0)}static addSessionState(a,s){a.addFieldOffset(1,s,0)}static endSubGraphSessionState(a){let s=a.endObject();return a.requiredField(s,4),s}static createSubGraphSessionState(a,s,l){return o.startSubGraphSessionState(a),o.addGraphId(a,s),o.addSessionState(a,l),o.endSubGraphSessionState(a)}}i.SubGraphSessionState=o})(n=t.fbs||={})})(r=e.experimental||={})})(se||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,s){return this.bb_pos=a,this.bb=s,this}static getRootAsSessionState(a,s){return(s||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsSessionState(a,s){return a.setPosition(a.position()+D.SIZE_PREFIX_LENGTH),(s||new o).__init(a.readInt32(a.position())+a.position(),a)}kernels(a){let s=this.bb.__offset(this.bb_pos,4);return s?(a||new e.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}subGraphSessionStates(a,s){let l=this.bb.__offset(this.bb_pos,6);return l?(s||new e.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+l)+a*4),this.bb):null}subGraphSessionStatesLength(){let a=this.bb.__offset(this.bb_pos,6);return a?this.bb.__vector_len(this.bb_pos+a):0}static startSessionState(a){a.startObject(2)}static addKernels(a,s){a.addFieldOffset(0,s,0)}static addSubGraphSessionStates(a,s){a.addFieldOffset(1,s,0)}static createSubGraphSessionStatesVector(a,s){a.startVector(4,s.length,4);for(let l=s.length-1;l>=0;l--)a.addOffset(s[l]);return a.endVector()}static startSubGraphSessionStatesVector(a,s){a.startVector(4,s,4)}static endSessionState(a){return a.endObject()}static createSessionState(a,s,l){return o.startSessionState(a),o.addKernels(a,s),o.addSubGraphSessionStates(a,l),o.endSessionState(a)}}i.SessionState=o})(n=t.fbs||={})})(r=e.experimental||={})})(se||={});(e=>{let r;(t=>{let n;(i=>{class o{constructor(){this.bb=null;this.bb_pos=0}__init(a,s){return this.bb_pos=a,this.bb=s,this}static getRootAsInferenceSession(a,s){return(s||new o).__init(a.readInt32(a.position())+a.position(),a)}static getSizePrefixedRootAsInferenceSession(a,s){return a.setPosition(a.position()+D.SIZE_PREFIX_LENGTH),(s||new o).__init(a.readInt32(a.position())+a.position(),a)}static bufferHasIdentifier(a){return a.__has_identifier("ORTM")}ortVersion(a){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,a):null}model(a){let s=this.bb.__offset(this.bb_pos,6);return s?(a||new e.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}sessionState(a){let s=this.bb.__offset(this.bb_pos,8);return s?(a||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}static startInferenceSession(a){a.startObject(3)}static addOrtVersion(a,s){a.addFieldOffset(0,s,0)}static addModel(a,s){a.addFieldOffset(1,s,0)}static addSessionState(a,s){a.addFieldOffset(2,s,0)}static endInferenceSession(a){return a.endObject()}static finishInferenceSessionBuffer(a,s){a.finish(s,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(a,s){a.finish(s,"ORTM",!0)}static createInferenceSession(a,s,l,d){return o.startInferenceSession(a),o.addOrtVersion(a,s),o.addModel(a,l),o.addSessionState(a,d),o.endInferenceSession(a)}}i.InferenceSession=o})(n=t.fbs||={})})(r=e.experimental||={})})(se||={})});var Il=Ye((aT,Sl)=>{"use strict";Sl.exports=jy;function jy(r,e){for(var n=new Array(arguments.length-1),t=0,o=2,i=!0;o<arguments.length;)n[t++]=arguments[o++];return new Promise(function(a,s){n[t]=function(d){if(i)if(i=!1,d)s(d);else{for(var f=new Array(arguments.length-1),p=0;p<f.length;)f[p++]=arguments[p];a.apply(null,f)}};try{r.apply(e||null,n)}catch(l){i&&(i=!1,s(l))}})}});var Cl=Ye(El=>{"use strict";var ii=El;ii.length=function(e){var n=e.length;if(!n)return 0;for(var t=0;--n%4>1&&e.charAt(n)==="=";)++t;return Math.ceil(e.length*3)/4-t};var $n=new Array(64),Ol=new Array(123);for(Qt=0;Qt<64;)Ol[$n[Qt]=Qt<26?Qt+65:Qt<52?Qt+71:Qt<62?Qt-4:Qt-59|43]=Qt++;var Qt;ii.encode=function(e,n,t){for(var o=null,i=[],u=0,a=0,s;n<t;){var l=e[n++];switch(a){case 0:i[u++]=$n[l>>2],s=(l&3)<<4,a=1;break;case 1:i[u++]=$n[s|l>>4],s=(l&15)<<2,a=2;break;case 2:i[u++]=$n[s|l>>6],i[u++]=$n[l&63],a=0;break}u>8191&&((o||(o=[])).push(String.fromCharCode.apply(String,i)),u=0)}return a&&(i[u++]=$n[s],i[u++]=61,a===1&&(i[u++]=61)),o?(u&&o.push(String.fromCharCode.apply(String,i.slice(0,u))),o.join("")):String.fromCharCode.apply(String,i.slice(0,u))};var Al="invalid encoding";ii.decode=function(e,n,t){for(var o=t,i=0,u,a=0;a<e.length;){var s=e.charCodeAt(a++);if(s===61&&i>1)break;if((s=Ol[s])===void 0)throw Error(Al);switch(i){case 0:u=s,i=1;break;case 1:n[t++]=u<<2|(s&48)>>4,u=s,i=2;break;case 2:n[t++]=(u&15)<<4|(s&60)>>2,u=s,i=3;break;case 3:n[t++]=(u&3)<<6|s,i=0;break}}if(i===1)throw Error(Al);return t-o};ii.test=function(e){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e)}});var kl=Ye((uT,Pl)=>{"use strict";Pl.exports=ai;function ai(){this._listeners={}}ai.prototype.on=function(e,n,t){return(this._listeners[e]||(this._listeners[e]=[])).push({fn:n,ctx:t||this}),this};ai.prototype.off=function(e,n){if(e===void 0)this._listeners={};else if(n===void 0)this._listeners[e]=[];else for(var t=this._listeners[e],o=0;o<t.length;)t[o].fn===n?t.splice(o,1):++o;return this};ai.prototype.emit=function(e){var n=this._listeners[e];if(n){for(var t=[],o=1;o<arguments.length;)t.push(arguments[o++]);for(o=0;o<n.length;)n[o].fn.apply(n[o++].ctx,t)}return this}});var Nl=Ye((lT,zl)=>{"use strict";zl.exports=Dl(Dl);function Dl(r){return typeof Float32Array<"u"?function(){var e=new Float32Array([-0]),n=new Uint8Array(e.buffer),t=n[3]===128;function o(s,l,d){e[0]=s,l[d]=n[0],l[d+1]=n[1],l[d+2]=n[2],l[d+3]=n[3]}function i(s,l,d){e[0]=s,l[d]=n[3],l[d+1]=n[2],l[d+2]=n[1],l[d+3]=n[0]}r.writeFloatLE=t?o:i,r.writeFloatBE=t?i:o;function u(s,l){return n[0]=s[l],n[1]=s[l+1],n[2]=s[l+2],n[3]=s[l+3],e[0]}function a(s,l){return n[3]=s[l],n[2]=s[l+1],n[1]=s[l+2],n[0]=s[l+3],e[0]}r.readFloatLE=t?u:a,r.readFloatBE=t?a:u}():function(){function e(t,o,i,u){var a=o<0?1:0;if(a&&(o=-o),o===0)t(1/o>0?0:2147483648,i,u);else if(isNaN(o))t(2143289344,i,u);else if(o>34028234663852886e22)t((a<<31|2139095040)>>>0,i,u);else if(o<11754943508222875e-54)t((a<<31|Math.round(o/1401298464324817e-60))>>>0,i,u);else{var s=Math.floor(Math.log(o)/Math.LN2),l=Math.round(o*Math.pow(2,-s)*8388608)&8388607;t((a<<31|s+127<<23|l)>>>0,i,u)}}r.writeFloatLE=e.bind(null,Bl),r.writeFloatBE=e.bind(null,Rl);function n(t,o,i){var u=t(o,i),a=(u>>31)*2+1,s=u>>>23&255,l=u&8388607;return s===255?l?NaN:a*(1/0):s===0?a*1401298464324817e-60*l:a*Math.pow(2,s-150)*(l+8388608)}r.readFloatLE=n.bind(null,Ml),r.readFloatBE=n.bind(null,Ll)}(),typeof Float64Array<"u"?function(){var e=new Float64Array([-0]),n=new Uint8Array(e.buffer),t=n[7]===128;function o(s,l,d){e[0]=s,l[d]=n[0],l[d+1]=n[1],l[d+2]=n[2],l[d+3]=n[3],l[d+4]=n[4],l[d+5]=n[5],l[d+6]=n[6],l[d+7]=n[7]}function i(s,l,d){e[0]=s,l[d]=n[7],l[d+1]=n[6],l[d+2]=n[5],l[d+3]=n[4],l[d+4]=n[3],l[d+5]=n[2],l[d+6]=n[1],l[d+7]=n[0]}r.writeDoubleLE=t?o:i,r.writeDoubleBE=t?i:o;function u(s,l){return n[0]=s[l],n[1]=s[l+1],n[2]=s[l+2],n[3]=s[l+3],n[4]=s[l+4],n[5]=s[l+5],n[6]=s[l+6],n[7]=s[l+7],e[0]}function a(s,l){return n[7]=s[l],n[6]=s[l+1],n[5]=s[l+2],n[4]=s[l+3],n[3]=s[l+4],n[2]=s[l+5],n[1]=s[l+6],n[0]=s[l+7],e[0]}r.readDoubleLE=t?u:a,r.readDoubleBE=t?a:u}():function(){function e(t,o,i,u,a,s){var l=u<0?1:0;if(l&&(u=-u),u===0)t(0,a,s+o),t(1/u>0?0:2147483648,a,s+i);else if(isNaN(u))t(0,a,s+o),t(2146959360,a,s+i);else if(u>17976931348623157e292)t(0,a,s+o),t((l<<31|2146435072)>>>0,a,s+i);else{var d;if(u<22250738585072014e-324)d=u/5e-324,t(d>>>0,a,s+o),t((l<<31|d/4294967296)>>>0,a,s+i);else{var f=Math.floor(Math.log(u)/Math.LN2);f===1024&&(f=1023),d=u*Math.pow(2,-f),t(d*4503599627370496>>>0,a,s+o),t((l<<31|f+1023<<20|d*1048576&1048575)>>>0,a,s+i)}}}r.writeDoubleLE=e.bind(null,Bl,0,4),r.writeDoubleBE=e.bind(null,Rl,4,0);function n(t,o,i,u,a){var s=t(u,a+o),l=t(u,a+i),d=(l>>31)*2+1,f=l>>>20&2047,p=4294967296*(l&1048575)+s;return f===2047?p?NaN:d*(1/0):f===0?d*5e-324*p:d*Math.pow(2,f-1075)*(p+4503599627370496)}r.readDoubleLE=n.bind(null,Ml,0,4),r.readDoubleBE=n.bind(null,Ll,4,0)}(),r}function Bl(r,e,n){e[n]=r&255,e[n+1]=r>>>8&255,e[n+2]=r>>>16&255,e[n+3]=r>>>24}function Rl(r,e,n){e[n]=r>>>24,e[n+1]=r>>>16&255,e[n+2]=r>>>8&255,e[n+3]=r&255}function Ml(r,e){return(r[e]|r[e+1]<<8|r[e+2]<<16|r[e+3]<<24)>>>0}function Ll(r,e){return(r[e]<<24|r[e+1]<<16|r[e+2]<<8|r[e+3])>>>0}});var Fl=Ye((exports,module)=>{"use strict";module.exports=inquire;function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(r){}return null}});var Gl=Ye(Vl=>{"use strict";var ka=Vl;ka.length=function(e){for(var n=0,t=0,o=0;o<e.length;++o)t=e.charCodeAt(o),t<128?n+=1:t<2048?n+=2:(t&64512)===55296&&(e.charCodeAt(o+1)&64512)===56320?(++o,n+=4):n+=3;return n};ka.read=function(e,n,t){var o=t-n;if(o<1)return"";for(var i=null,u=[],a=0,s;n<t;)s=e[n++],s<128?u[a++]=s:s>191&&s<224?u[a++]=(s&31)<<6|e[n++]&63:s>239&&s<365?(s=((s&7)<<18|(e[n++]&63)<<12|(e[n++]&63)<<6|e[n++]&63)-65536,u[a++]=55296+(s>>10),u[a++]=56320+(s&1023)):u[a++]=(s&15)<<12|(e[n++]&63)<<6|e[n++]&63,a>8191&&((i||(i=[])).push(String.fromCharCode.apply(String,u)),a=0);return i?(a&&i.push(String.fromCharCode.apply(String,u.slice(0,a))),i.join("")):String.fromCharCode.apply(String,u.slice(0,a))};ka.write=function(e,n,t){for(var o=t,i,u,a=0;a<e.length;++a)i=e.charCodeAt(a),i<128?n[t++]=i:i<2048?(n[t++]=i>>6|192,n[t++]=i&63|128):(i&64512)===55296&&((u=e.charCodeAt(a+1))&64512)===56320?(i=65536+((i&1023)<<10)+(u&1023),++a,n[t++]=i>>18|240,n[t++]=i>>12&63|128,n[t++]=i>>6&63|128,n[t++]=i&63|128):(n[t++]=i>>12|224,n[t++]=i>>6&63|128,n[t++]=i&63|128);return t-o}});var Wl=Ye((cT,Ul)=>{"use strict";Ul.exports=Ky;function Ky(r,e,n){var t=n||8192,o=t>>>1,i=null,u=t;return function(s){if(s<1||s>o)return r(s);u+s>t&&(i=r(t),u=0);var l=e.call(i,u,u+=s);return u&7&&(u=(u|7)+1),l}}});var ql=Ye((fT,Hl)=>{"use strict";Hl.exports=wt;var no=Rr();function wt(r,e){this.lo=r>>>0,this.hi=e>>>0}var Zr=wt.zero=new wt(0,0);Zr.toNumber=function(){return 0};Zr.zzEncode=Zr.zzDecode=function(){return this};Zr.length=function(){return 1};var Yy=wt.zeroHash="\0\0\0\0\0\0\0\0";wt.fromNumber=function(e){if(e===0)return Zr;var n=e<0;n&&(e=-e);var t=e>>>0,o=(e-t)/4294967296>>>0;return n&&(o=~o>>>0,t=~t>>>0,++t>4294967295&&(t=0,++o>4294967295&&(o=0))),new wt(t,o)};wt.from=function(e){if(typeof e=="number")return wt.fromNumber(e);if(no.isString(e))if(no.Long)e=no.Long.fromString(e);else return wt.fromNumber(parseInt(e,10));return e.low||e.high?new wt(e.low>>>0,e.high>>>0):Zr};wt.prototype.toNumber=function(e){if(!e&&this.hi>>>31){var n=~this.lo+1>>>0,t=~this.hi>>>0;return n||(t=t+1>>>0),-(n+t*4294967296)}return this.lo+this.hi*4294967296};wt.prototype.toLong=function(e){return no.Long?new no.Long(this.lo|0,this.hi|0,!!e):{low:this.lo|0,high:this.hi|0,unsigned:!!e}};var Br=String.prototype.charCodeAt;wt.fromHash=function(e){return e===Yy?Zr:new wt((Br.call(e,0)|Br.call(e,1)<<8|Br.call(e,2)<<16|Br.call(e,3)<<24)>>>0,(Br.call(e,4)|Br.call(e,5)<<8|Br.call(e,6)<<16|Br.call(e,7)<<24)>>>0)};wt.prototype.toHash=function(){return String.fromCharCode(this.lo&255,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,this.hi&255,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)};wt.prototype.zzEncode=function(){var e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this};wt.prototype.zzDecode=function(){var e=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this};wt.prototype.length=function(){var e=this.lo,n=(this.lo>>>28|this.hi<<4)>>>0,t=this.hi>>>24;return t===0?n===0?e<16384?e<128?1:2:e<2097152?3:4:n<16384?n<128?5:6:n<2097152?7:8:t<128?9:10}});var Rr=Ye(Da=>{"use strict";var ue=Da;ue.asPromise=Il();ue.base64=Cl();ue.EventEmitter=kl();ue.float=Nl();ue.inquire=Fl();ue.utf8=Gl();ue.pool=Wl();ue.LongBits=ql();ue.isNode=!!(typeof global<"u"&&global&&global.process&&global.process.versions&&global.process.versions.node);ue.global=ue.isNode&&global||typeof window<"u"&&window||typeof self<"u"&&self||Da;ue.emptyArray=Object.freeze?Object.freeze([]):[];ue.emptyObject=Object.freeze?Object.freeze({}):{};ue.isInteger=Number.isInteger||function(e){return typeof e=="number"&&isFinite(e)&&Math.floor(e)===e};ue.isString=function(e){return typeof e=="string"||e instanceof String};ue.isObject=function(e){return e&&typeof e=="object"};ue.isset=ue.isSet=function(e,n){var t=e[n];return t!=null&&e.hasOwnProperty(n)?typeof t!="object"||(Array.isArray(t)?t.length:Object.keys(t).length)>0:!1};ue.Buffer=function(){try{var r=ue.inquire("buffer").Buffer;return r.prototype.utf8Write?r:null}catch{return null}}();ue._Buffer_from=null;ue._Buffer_allocUnsafe=null;ue.newBuffer=function(e){return typeof e=="number"?ue.Buffer?ue._Buffer_allocUnsafe(e):new ue.Array(e):ue.Buffer?ue._Buffer_from(e):typeof Uint8Array>"u"?e:new Uint8Array(e)};ue.Array=typeof Uint8Array<"u"?Uint8Array:Array;ue.Long=ue.global.dcodeIO&&ue.global.dcodeIO.Long||ue.global.Long||ue.inquire("long");ue.key2Re=/^true|false|0|1$/;ue.key32Re=/^-?(?:0|[1-9][0-9]*)$/;ue.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;ue.longToHash=function(e){return e?ue.LongBits.from(e).toHash():ue.LongBits.zeroHash};ue.longFromHash=function(e,n){var t=ue.LongBits.fromHash(e);return ue.Long?ue.Long.fromBits(t.lo,t.hi,n):t.toNumber(!!n)};function jl(r,e,n){for(var t=Object.keys(e),o=0;o<t.length;++o)(r[t[o]]===void 0||!n)&&(r[t[o]]=e[t[o]]);return r}ue.merge=jl;ue.lcFirst=function(e){return e.charAt(0).toLowerCase()+e.substring(1)};function Kl(r){function e(n,t){if(!(this instanceof e))return new e(n,t);Object.defineProperty(this,"message",{get:function(){return n}}),Error.captureStackTrace?Error.captureStackTrace(this,e):Object.defineProperty(this,"stack",{value:new Error().stack||""}),t&&jl(this,t)}return e.prototype=Object.create(Error.prototype,{constructor:{value:e,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return r},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),e}ue.newError=Kl;ue.ProtocolError=Kl("ProtocolError");ue.oneOfGetter=function(e){for(var n={},t=0;t<e.length;++t)n[e[t]]=1;return function(){for(var o=Object.keys(this),i=o.length-1;i>-1;--i)if(n[o[i]]===1&&this[o[i]]!==void 0&&this[o[i]]!==null)return o[i]}};ue.oneOfSetter=function(e){return function(n){for(var t=0;t<e.length;++t)e[t]!==n&&delete this[e[t]]}};ue.toJSONOptions={longs:String,enums:String,bytes:String,json:!0};ue._configure=function(){var r=ue.Buffer;if(!r){ue._Buffer_from=ue._Buffer_allocUnsafe=null;return}ue._Buffer_from=r.from!==Uint8Array.from&&r.from||function(n,t){return new r(n,t)},ue._Buffer_allocUnsafe=r.allocUnsafe||function(n){return new r(n)}}});var Fa=Ye((hT,Jl)=>{"use strict";Jl.exports=Ve;var Wt=Rr(),Ba,si=Wt.LongBits,Yl=Wt.base64,Xl=Wt.utf8;function oo(r,e,n){this.fn=r,this.len=e,this.next=void 0,this.val=n}function Ma(){}function Xy(r){this.head=r.head,this.tail=r.tail,this.len=r.len,this.next=r.states}function Ve(){this.len=0,this.head=new oo(Ma,0,0),this.tail=this.head,this.states=null}var Zl=function(){return Wt.Buffer?function(){return(Ve.create=function(){return new Ba})()}:function(){return new Ve}};Ve.create=Zl();Ve.alloc=function(e){return new Wt.Array(e)};Wt.Array!==Array&&(Ve.alloc=Wt.pool(Ve.alloc,Wt.Array.prototype.subarray));Ve.prototype._push=function(e,n,t){return this.tail=this.tail.next=new oo(e,n,t),this.len+=n,this};function La(r,e,n){e[n]=r&255}function Zy(r,e,n){for(;r>127;)e[n++]=r&127|128,r>>>=7;e[n]=r}function za(r,e){this.len=r,this.next=void 0,this.val=e}za.prototype=Object.create(oo.prototype);za.prototype.fn=Zy;Ve.prototype.uint32=function(e){return this.len+=(this.tail=this.tail.next=new za((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this};Ve.prototype.int32=function(e){return e<0?this._push(Na,10,si.fromNumber(e)):this.uint32(e)};Ve.prototype.sint32=function(e){return this.uint32((e<<1^e>>31)>>>0)};function Na(r,e,n){for(;r.hi;)e[n++]=r.lo&127|128,r.lo=(r.lo>>>7|r.hi<<25)>>>0,r.hi>>>=7;for(;r.lo>127;)e[n++]=r.lo&127|128,r.lo=r.lo>>>7;e[n++]=r.lo}Ve.prototype.uint64=function(e){var n=si.from(e);return this._push(Na,n.length(),n)};Ve.prototype.int64=Ve.prototype.uint64;Ve.prototype.sint64=function(e){var n=si.from(e).zzEncode();return this._push(Na,n.length(),n)};Ve.prototype.bool=function(e){return this._push(La,1,e?1:0)};function Ra(r,e,n){e[n]=r&255,e[n+1]=r>>>8&255,e[n+2]=r>>>16&255,e[n+3]=r>>>24}Ve.prototype.fixed32=function(e){return this._push(Ra,4,e>>>0)};Ve.prototype.sfixed32=Ve.prototype.fixed32;Ve.prototype.fixed64=function(e){var n=si.from(e);return this._push(Ra,4,n.lo)._push(Ra,4,n.hi)};Ve.prototype.sfixed64=Ve.prototype.fixed64;Ve.prototype.float=function(e){return this._push(Wt.float.writeFloatLE,4,e)};Ve.prototype.double=function(e){return this._push(Wt.float.writeDoubleLE,8,e)};var Jy=Wt.Array.prototype.set?function(e,n,t){n.set(e,t)}:function(e,n,t){for(var o=0;o<e.length;++o)n[t+o]=e[o]};Ve.prototype.bytes=function(e){var n=e.length>>>0;if(!n)return this._push(La,1,0);if(Wt.isString(e)){var t=Ve.alloc(n=Yl.length(e));Yl.decode(e,t,0),e=t}return this.uint32(n)._push(Jy,n,e)};Ve.prototype.string=function(e){var n=Xl.length(e);return n?this.uint32(n)._push(Xl.write,n,e):this._push(La,1,0)};Ve.prototype.fork=function(){return this.states=new Xy(this),this.head=this.tail=new oo(Ma,0,0),this.len=0,this};Ve.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new oo(Ma,0,0),this.len=0),this};Ve.prototype.ldelim=function(){var e=this.head,n=this.tail,t=this.len;return this.reset().uint32(t),t&&(this.tail.next=e.next,this.tail=n,this.len+=t),this};Ve.prototype.finish=function(){for(var e=this.head.next,n=this.constructor.alloc(this.len),t=0;e;)e.fn(e.val,n,t),t+=e.len,e=e.next;return n};Ve._configure=function(r){Ba=r,Ve.create=Zl(),Ba._configure()}});var td=Ye((mT,ed)=>{"use strict";ed.exports=ur;var Ql=Fa();(ur.prototype=Object.create(Ql.prototype)).constructor=ur;var Mr=Rr();function ur(){Ql.call(this)}ur._configure=function(){ur.alloc=Mr._Buffer_allocUnsafe,ur.writeBytesBuffer=Mr.Buffer&&Mr.Buffer.prototype instanceof Uint8Array&&Mr.Buffer.prototype.set.name==="set"?function(e,n,t){n.set(e,t)}:function(e,n,t){if(e.copy)e.copy(n,t,0,e.length);else for(var o=0;o<e.length;)n[t++]=e[o++]}};ur.prototype.bytes=function(e){Mr.isString(e)&&(e=Mr._Buffer_from(e,"base64"));var n=e.length>>>0;return this.uint32(n),n&&this._push(ur.writeBytesBuffer,n,e),this};function Qy(r,e,n){r.length<40?Mr.utf8.write(r,e,n):e.utf8Write?e.utf8Write(r,n):e.write(r,n)}ur.prototype.string=function(e){var n=Mr.Buffer.byteLength(e);return this.uint32(n),n&&this._push(Qy,n,e),this};ur._configure()});var Ua=Ye((gT,ad)=>{"use strict";ad.exports=dt;var lr=Rr(),Ga,od=lr.LongBits,e0=lr.utf8;function er(r,e){return RangeError("index out of range: "+r.pos+" + "+(e||1)+" > "+r.len)}function dt(r){this.buf=r,this.pos=0,this.len=r.length}var rd=typeof Uint8Array<"u"?function(e){if(e instanceof Uint8Array||Array.isArray(e))return new dt(e);throw Error("illegal buffer")}:function(e){if(Array.isArray(e))return new dt(e);throw Error("illegal buffer")},id=function(){return lr.Buffer?function(n){return(dt.create=function(o){return lr.Buffer.isBuffer(o)?new Ga(o):rd(o)})(n)}:rd};dt.create=id();dt.prototype._slice=lr.Array.prototype.subarray||lr.Array.prototype.slice;dt.prototype.uint32=function(){var e=4294967295;return function(){if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,er(this,10);return e}}();dt.prototype.int32=function(){return this.uint32()|0};dt.prototype.sint32=function(){var e=this.uint32();return e>>>1^-(e&1)|0};function Va(){var r=new od(0,0),e=0;if(this.len-this.pos>4){for(;e<4;++e)if(r.lo=(r.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return r;if(r.lo=(r.lo|(this.buf[this.pos]&127)<<28)>>>0,r.hi=(r.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return r;e=0}else{for(;e<3;++e){if(this.pos>=this.len)throw er(this);if(r.lo=(r.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return r}return r.lo=(r.lo|(this.buf[this.pos++]&127)<<e*7)>>>0,r}if(this.len-this.pos>4){for(;e<5;++e)if(r.hi=(r.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return r}else for(;e<5;++e){if(this.pos>=this.len)throw er(this);if(r.hi=(r.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return r}throw Error("invalid varint encoding")}dt.prototype.bool=function(){return this.uint32()!==0};function ui(r,e){return(r[e-4]|r[e-3]<<8|r[e-2]<<16|r[e-1]<<24)>>>0}dt.prototype.fixed32=function(){if(this.pos+4>this.len)throw er(this,4);return ui(this.buf,this.pos+=4)};dt.prototype.sfixed32=function(){if(this.pos+4>this.len)throw er(this,4);return ui(this.buf,this.pos+=4)|0};function nd(){if(this.pos+8>this.len)throw er(this,8);return new od(ui(this.buf,this.pos+=4),ui(this.buf,this.pos+=4))}dt.prototype.float=function(){if(this.pos+4>this.len)throw er(this,4);var e=lr.float.readFloatLE(this.buf,this.pos);return this.pos+=4,e};dt.prototype.double=function(){if(this.pos+8>this.len)throw er(this,4);var e=lr.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,e};dt.prototype.bytes=function(){var e=this.uint32(),n=this.pos,t=this.pos+e;if(t>this.len)throw er(this,e);return this.pos+=e,Array.isArray(this.buf)?this.buf.slice(n,t):n===t?new this.buf.constructor(0):this._slice.call(this.buf,n,t)};dt.prototype.string=function(){var e=this.bytes();return e0.read(e,0,e.length)};dt.prototype.skip=function(e){if(typeof e=="number"){if(this.pos+e>this.len)throw er(this,e);this.pos+=e}else do if(this.pos>=this.len)throw er(this);while(this.buf[this.pos++]&128);return this};dt.prototype.skipType=function(r){switch(r){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(r=this.uint32()&7)!==4;)this.skipType(r);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+r+" at offset "+this.pos)}return this};dt._configure=function(r){Ga=r,dt.create=id(),Ga._configure();var e=lr.Long?"toLong":"toNumber";lr.merge(dt.prototype,{int64:function(){return Va.call(this)[e](!1)},uint64:function(){return Va.call(this)[e](!0)},sint64:function(){return Va.call(this).zzDecode()[e](!1)},fixed64:function(){return nd.call(this)[e](!0)},sfixed64:function(){return nd.call(this)[e](!1)}})}});var dd=Ye((bT,ld)=>{"use strict";ld.exports=Jr;var ud=Ua();(Jr.prototype=Object.create(ud.prototype)).constructor=Jr;var sd=Rr();function Jr(r){ud.call(this,r)}Jr._configure=function(){sd.Buffer&&(Jr.prototype._slice=sd.Buffer.prototype.slice)};Jr.prototype.string=function(){var e=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+e,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+e,this.len))};Jr._configure()});var fd=Ye((yT,cd)=>{"use strict";cd.exports=io;var Wa=Rr();(io.prototype=Object.create(Wa.EventEmitter.prototype)).constructor=io;function io(r,e,n){if(typeof r!="function")throw TypeError("rpcImpl must be a function");Wa.EventEmitter.call(this),this.rpcImpl=r,this.requestDelimited=!!e,this.responseDelimited=!!n}io.prototype.rpcCall=function r(e,n,t,o,i){if(!o)throw TypeError("request must be specified");var u=this;if(!i)return Wa.asPromise(r,u,e,n,t,o);if(!u.rpcImpl){setTimeout(function(){i(Error("already ended"))},0);return}try{return u.rpcImpl(e,n[u.requestDelimited?"encodeDelimited":"encode"](o).finish(),function(s,l){if(s)return u.emit("error",s,e),i(s);if(l===null){u.end(!0);return}if(!(l instanceof t))try{l=t[u.responseDelimited?"decodeDelimited":"decode"](l)}catch(d){return u.emit("error",d,e),i(d)}return u.emit("data",l,e),i(null,l)})}catch(a){u.emit("error",a,e),setTimeout(function(){i(a)},0);return}};io.prototype.end=function(e){return this.rpcImpl&&(e||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}});var hd=Ye(pd=>{"use strict";var t0=pd;t0.Service=fd()});var gd=Ye((wT,md)=>{"use strict";md.exports={}});var vd=Ye(yd=>{"use strict";var Mt=yd;Mt.build="minimal";Mt.Writer=Fa();Mt.BufferWriter=td();Mt.Reader=Ua();Mt.BufferReader=dd();Mt.util=Rr();Mt.rpc=hd();Mt.roots=gd();Mt.configure=bd;function bd(){Mt.util._configure(),Mt.Writer._configure(Mt.BufferWriter),Mt.Reader._configure(Mt.BufferReader)}bd()});var xd=Ye(($T,wd)=>{"use strict";wd.exports=vd()});var Tn=Ye((TT,$d)=>{"use strict";var Ze=xd(),Z=Ze.Reader,ct=Ze.Writer,A=Ze.util,$=Ze.roots.default||(Ze.roots.default={});$.onnx=function(){var r={};return r.Version=function(){var e={},n=Object.create(e);return n[e[0]="_START_VERSION"]=0,n[e[1]="IR_VERSION_2017_10_10"]=1,n[e[2]="IR_VERSION_2017_10_30"]=2,n[e[3]="IR_VERSION_2017_11_3"]=3,n[e[4]="IR_VERSION_2019_1_22"]=4,n[e[5]="IR_VERSION_2019_3_18"]=5,n[e[6]="IR_VERSION_2019_9_19"]=6,n[e[7]="IR_VERSION_2020_5_8"]=7,n[e[8]="IR_VERSION_2021_7_30"]=8,n[e[9]="IR_VERSION"]=9,n}(),r.AttributeProto=function(){function e(n){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],this.sparseTensors=[],this.typeProtos=[],n)for(var t=Object.keys(n),o=0;o<t.length;++o)n[t[o]]!=null&&(this[t[o]]=n[t[o]])}return e.prototype.name="",e.prototype.refAttrName="",e.prototype.docString="",e.prototype.type=0,e.prototype.f=0,e.prototype.i=A.Long?A.Long.fromBits(0,0,!1):0,e.prototype.s=A.newBuffer([]),e.prototype.t=null,e.prototype.g=null,e.prototype.sparseTensor=null,e.prototype.tp=null,e.prototype.floats=A.emptyArray,e.prototype.ints=A.emptyArray,e.prototype.strings=A.emptyArray,e.prototype.tensors=A.emptyArray,e.prototype.graphs=A.emptyArray,e.prototype.sparseTensors=A.emptyArray,e.prototype.typeProtos=A.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=ct.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&o.uint32(10).string(t.name),t.f!=null&&Object.hasOwnProperty.call(t,"f")&&o.uint32(21).float(t.f),t.i!=null&&Object.hasOwnProperty.call(t,"i")&&o.uint32(24).int64(t.i),t.s!=null&&Object.hasOwnProperty.call(t,"s")&&o.uint32(34).bytes(t.s),t.t!=null&&Object.hasOwnProperty.call(t,"t")&&$.onnx.TensorProto.encode(t.t,o.uint32(42).fork()).ldelim(),t.g!=null&&Object.hasOwnProperty.call(t,"g")&&$.onnx.GraphProto.encode(t.g,o.uint32(50).fork()).ldelim(),t.floats!=null&&t.floats.length){o.uint32(58).fork();for(var i=0;i<t.floats.length;++i)o.float(t.floats[i]);o.ldelim()}if(t.ints!=null&&t.ints.length){o.uint32(66).fork();for(var i=0;i<t.ints.length;++i)o.int64(t.ints[i]);o.ldelim()}if(t.strings!=null&&t.strings.length)for(var i=0;i<t.strings.length;++i)o.uint32(74).bytes(t.strings[i]);if(t.tensors!=null&&t.tensors.length)for(var i=0;i<t.tensors.length;++i)$.onnx.TensorProto.encode(t.tensors[i],o.uint32(82).fork()).ldelim();if(t.graphs!=null&&t.graphs.length)for(var i=0;i<t.graphs.length;++i)$.onnx.GraphProto.encode(t.graphs[i],o.uint32(90).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&o.uint32(106).string(t.docString),t.tp!=null&&Object.hasOwnProperty.call(t,"tp")&&$.onnx.TypeProto.encode(t.tp,o.uint32(114).fork()).ldelim(),t.typeProtos!=null&&t.typeProtos.length)for(var i=0;i<t.typeProtos.length;++i)$.onnx.TypeProto.encode(t.typeProtos[i],o.uint32(122).fork()).ldelim();if(t.type!=null&&Object.hasOwnProperty.call(t,"type")&&o.uint32(160).int32(t.type),t.refAttrName!=null&&Object.hasOwnProperty.call(t,"refAttrName")&&o.uint32(170).string(t.refAttrName),t.sparseTensor!=null&&Object.hasOwnProperty.call(t,"sparseTensor")&&$.onnx.SparseTensorProto.encode(t.sparseTensor,o.uint32(178).fork()).ldelim(),t.sparseTensors!=null&&t.sparseTensors.length)for(var i=0;i<t.sparseTensors.length;++i)$.onnx.SparseTensorProto.encode(t.sparseTensors[i],o.uint32(186).fork()).ldelim();return o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof Z||(t=Z.create(t));for(var i=o===void 0?t.len:t.pos+o,u=new $.onnx.AttributeProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{u.name=t.string();break}case 21:{u.refAttrName=t.string();break}case 13:{u.docString=t.string();break}case 20:{u.type=t.int32();break}case 2:{u.f=t.float();break}case 3:{u.i=t.int64();break}case 4:{u.s=t.bytes();break}case 5:{u.t=$.onnx.TensorProto.decode(t,t.uint32());break}case 6:{u.g=$.onnx.GraphProto.decode(t,t.uint32());break}case 22:{u.sparseTensor=$.onnx.SparseTensorProto.decode(t,t.uint32());break}case 14:{u.tp=$.onnx.TypeProto.decode(t,t.uint32());break}case 7:{if(u.floats&&u.floats.length||(u.floats=[]),(a&7)===2)for(var s=t.uint32()+t.pos;t.pos<s;)u.floats.push(t.float());else u.floats.push(t.float());break}case 8:{if(u.ints&&u.ints.length||(u.ints=[]),(a&7)===2)for(var s=t.uint32()+t.pos;t.pos<s;)u.ints.push(t.int64());else u.ints.push(t.int64());break}case 9:{u.strings&&u.strings.length||(u.strings=[]),u.strings.push(t.bytes());break}case 10:{u.tensors&&u.tensors.length||(u.tensors=[]),u.tensors.push($.onnx.TensorProto.decode(t,t.uint32()));break}case 11:{u.graphs&&u.graphs.length||(u.graphs=[]),u.graphs.push($.onnx.GraphProto.decode(t,t.uint32()));break}case 23:{u.sparseTensors&&u.sparseTensors.length||(u.sparseTensors=[]),u.sparseTensors.push($.onnx.SparseTensorProto.decode(t,t.uint32()));break}case 15:{u.typeProtos&&u.typeProtos.length||(u.typeProtos=[]),u.typeProtos.push($.onnx.TypeProto.decode(t,t.uint32()));break}default:t.skipType(a&7);break}}return u},e.decodeDelimited=function(t){return t instanceof Z||(t=new Z(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!A.isString(t.name))return"name: string expected";if(t.refAttrName!=null&&t.hasOwnProperty("refAttrName")&&!A.isString(t.refAttrName))return"refAttrName: string expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!A.isString(t.docString))return"docString: string expected";if(t.type!=null&&t.hasOwnProperty("type"))switch(t.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 11:case 13:case 6:case 7:case 8:case 9:case 10:case 12:case 14:break}if(t.f!=null&&t.hasOwnProperty("f")&&typeof t.f!="number")return"f: number expected";if(t.i!=null&&t.hasOwnProperty("i")&&!A.isInteger(t.i)&&!(t.i&&A.isInteger(t.i.low)&&A.isInteger(t.i.high)))return"i: integer|Long expected";if(t.s!=null&&t.hasOwnProperty("s")&&!(t.s&&typeof t.s.length=="number"||A.isString(t.s)))return"s: buffer expected";if(t.t!=null&&t.hasOwnProperty("t")){var o=$.onnx.TensorProto.verify(t.t);if(o)return"t."+o}if(t.g!=null&&t.hasOwnProperty("g")){var o=$.onnx.GraphProto.verify(t.g);if(o)return"g."+o}if(t.sparseTensor!=null&&t.hasOwnProperty("sparseTensor")){var o=$.onnx.SparseTensorProto.verify(t.sparseTensor);if(o)return"sparseTensor."+o}if(t.tp!=null&&t.hasOwnProperty("tp")){var o=$.onnx.TypeProto.verify(t.tp);if(o)return"tp."+o}if(t.floats!=null&&t.hasOwnProperty("floats")){if(!Array.isArray(t.floats))return"floats: array expected";for(var i=0;i<t.floats.length;++i)if(typeof t.floats[i]!="number")return"floats: number[] expected"}if(t.ints!=null&&t.hasOwnProperty("ints")){if(!Array.isArray(t.ints))return"ints: array expected";for(var i=0;i<t.ints.length;++i)if(!A.isInteger(t.ints[i])&&!(t.ints[i]&&A.isInteger(t.ints[i].low)&&A.isInteger(t.ints[i].high)))return"ints: integer|Long[] expected"}if(t.strings!=null&&t.hasOwnProperty("strings")){if(!Array.isArray(t.strings))return"strings: array expected";for(var i=0;i<t.strings.length;++i)if(!(t.strings[i]&&typeof t.strings[i].length=="number"||A.isString(t.strings[i])))return"strings: buffer[] expected"}if(t.tensors!=null&&t.hasOwnProperty("tensors")){if(!Array.isArray(t.tensors))return"tensors: array expected";for(var i=0;i<t.tensors.length;++i){var o=$.onnx.TensorProto.verify(t.tensors[i]);if(o)return"tensors."+o}}if(t.graphs!=null&&t.hasOwnProperty("graphs")){if(!Array.isArray(t.graphs))return"graphs: array expected";for(var i=0;i<t.graphs.length;++i){var o=$.onnx.GraphProto.verify(t.graphs[i]);if(o)return"graphs."+o}}if(t.sparseTensors!=null&&t.hasOwnProperty("sparseTensors")){if(!Array.isArray(t.sparseTensors))return"sparseTensors: array expected";for(var i=0;i<t.sparseTensors.length;++i){var o=$.onnx.SparseTensorProto.verify(t.sparseTensors[i]);if(o)return"sparseTensors."+o}}if(t.typeProtos!=null&&t.hasOwnProperty("typeProtos")){if(!Array.isArray(t.typeProtos))return"typeProtos: array expected";for(var i=0;i<t.typeProtos.length;++i){var o=$.onnx.TypeProto.verify(t.typeProtos[i]);if(o)return"typeProtos."+o}}return null},e.fromObject=function(t){if(t instanceof $.onnx.AttributeProto)return t;var o=new $.onnx.AttributeProto;switch(t.name!=null&&(o.name=String(t.name)),t.refAttrName!=null&&(o.refAttrName=String(t.refAttrName)),t.docString!=null&&(o.docString=String(t.docString)),t.type){default:if(typeof t.type=="number"){o.type=t.type;break}break;case"UNDEFINED":case 0:o.type=0;break;case"FLOAT":case 1:o.type=1;break;case"INT":case 2:o.type=2;break;case"STRING":case 3:o.type=3;break;case"TENSOR":case 4:o.type=4;break;case"GRAPH":case 5:o.type=5;break;case"SPARSE_TENSOR":case 11:o.type=11;break;case"TYPE_PROTO":case 13:o.type=13;break;case"FLOATS":case 6:o.type=6;break;case"INTS":case 7:o.type=7;break;case"STRINGS":case 8:o.type=8;break;case"TENSORS":case 9:o.type=9;break;case"GRAPHS":case 10:o.type=10;break;case"SPARSE_TENSORS":case 12:o.type=12;break;case"TYPE_PROTOS":case 14:o.type=14;break}if(t.f!=null&&(o.f=Number(t.f)),t.i!=null&&(A.Long?(o.i=A.Long.fromValue(t.i)).unsigned=!1:typeof t.i=="string"?o.i=parseInt(t.i,10):typeof t.i=="number"?o.i=t.i:typeof t.i=="object"&&(o.i=new A.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber())),t.s!=null&&(typeof t.s=="string"?A.base64.decode(t.s,o.s=A.newBuffer(A.base64.length(t.s)),0):t.s.length>=0&&(o.s=t.s)),t.t!=null){if(typeof t.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");o.t=$.onnx.TensorProto.fromObject(t.t)}if(t.g!=null){if(typeof t.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");o.g=$.onnx.GraphProto.fromObject(t.g)}if(t.sparseTensor!=null){if(typeof t.sparseTensor!="object")throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");o.sparseTensor=$.onnx.SparseTensorProto.fromObject(t.sparseTensor)}if(t.tp!=null){if(typeof t.tp!="object")throw TypeError(".onnx.AttributeProto.tp: object expected");o.tp=$.onnx.TypeProto.fromObject(t.tp)}if(t.floats){if(!Array.isArray(t.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");o.floats=[];for(var i=0;i<t.floats.length;++i)o.floats[i]=Number(t.floats[i])}if(t.ints){if(!Array.isArray(t.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");o.ints=[];for(var i=0;i<t.ints.length;++i)A.Long?(o.ints[i]=A.Long.fromValue(t.ints[i])).unsigned=!1:typeof t.ints[i]=="string"?o.ints[i]=parseInt(t.ints[i],10):typeof t.ints[i]=="number"?o.ints[i]=t.ints[i]:typeof t.ints[i]=="object"&&(o.ints[i]=new A.LongBits(t.ints[i].low>>>0,t.ints[i].high>>>0).toNumber())}if(t.strings){if(!Array.isArray(t.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");o.strings=[];for(var i=0;i<t.strings.length;++i)typeof t.strings[i]=="string"?A.base64.decode(t.strings[i],o.strings[i]=A.newBuffer(A.base64.length(t.strings[i])),0):t.strings[i].length>=0&&(o.strings[i]=t.strings[i])}if(t.tensors){if(!Array.isArray(t.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");o.tensors=[];for(var i=0;i<t.tensors.length;++i){if(typeof t.tensors[i]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");o.tensors[i]=$.onnx.TensorProto.fromObject(t.tensors[i])}}if(t.graphs){if(!Array.isArray(t.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");o.graphs=[];for(var i=0;i<t.graphs.length;++i){if(typeof t.graphs[i]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");o.graphs[i]=$.onnx.GraphProto.fromObject(t.graphs[i])}}if(t.sparseTensors){if(!Array.isArray(t.sparseTensors))throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");o.sparseTensors=[];for(var i=0;i<t.sparseTensors.length;++i){if(typeof t.sparseTensors[i]!="object")throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");o.sparseTensors[i]=$.onnx.SparseTensorProto.fromObject(t.sparseTensors[i])}}if(t.typeProtos){if(!Array.isArray(t.typeProtos))throw TypeError(".onnx.AttributeProto.typeProtos: array expected");o.typeProtos=[];for(var i=0;i<t.typeProtos.length;++i){if(typeof t.typeProtos[i]!="object")throw TypeError(".onnx.AttributeProto.typeProtos: object expected");o.typeProtos[i]=$.onnx.TypeProto.fromObject(t.typeProtos[i])}}return o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.floats=[],i.ints=[],i.strings=[],i.tensors=[],i.graphs=[],i.typeProtos=[],i.sparseTensors=[]),o.defaults){if(i.name="",i.f=0,A.Long){var u=new A.Long(0,0,!1);i.i=o.longs===String?u.toString():o.longs===Number?u.toNumber():u}else i.i=o.longs===String?"0":0;o.bytes===String?i.s="":(i.s=[],o.bytes!==Array&&(i.s=A.newBuffer(i.s))),i.t=null,i.g=null,i.docString="",i.tp=null,i.type=o.enums===String?"UNDEFINED":0,i.refAttrName="",i.sparseTensor=null}if(t.name!=null&&t.hasOwnProperty("name")&&(i.name=t.name),t.f!=null&&t.hasOwnProperty("f")&&(i.f=o.json&&!isFinite(t.f)?String(t.f):t.f),t.i!=null&&t.hasOwnProperty("i")&&(typeof t.i=="number"?i.i=o.longs===String?String(t.i):t.i:i.i=o.longs===String?A.Long.prototype.toString.call(t.i):o.longs===Number?new A.LongBits(t.i.low>>>0,t.i.high>>>0).toNumber():t.i),t.s!=null&&t.hasOwnProperty("s")&&(i.s=o.bytes===String?A.base64.encode(t.s,0,t.s.length):o.bytes===Array?Array.prototype.slice.call(t.s):t.s),t.t!=null&&t.hasOwnProperty("t")&&(i.t=$.onnx.TensorProto.toObject(t.t,o)),t.g!=null&&t.hasOwnProperty("g")&&(i.g=$.onnx.GraphProto.toObject(t.g,o)),t.floats&&t.floats.length){i.floats=[];for(var a=0;a<t.floats.length;++a)i.floats[a]=o.json&&!isFinite(t.floats[a])?String(t.floats[a]):t.floats[a]}if(t.ints&&t.ints.length){i.ints=[];for(var a=0;a<t.ints.length;++a)typeof t.ints[a]=="number"?i.ints[a]=o.longs===String?String(t.ints[a]):t.ints[a]:i.ints[a]=o.longs===String?A.Long.prototype.toString.call(t.ints[a]):o.longs===Number?new A.LongBits(t.ints[a].low>>>0,t.ints[a].high>>>0).toNumber():t.ints[a]}if(t.strings&&t.strings.length){i.strings=[];for(var a=0;a<t.strings.length;++a)i.strings[a]=o.bytes===String?A.base64.encode(t.strings[a],0,t.strings[a].length):o.bytes===Array?Array.prototype.slice.call(t.strings[a]):t.strings[a]}if(t.tensors&&t.tensors.length){i.tensors=[];for(var a=0;a<t.tensors.length;++a)i.tensors[a]=$.onnx.TensorProto.toObject(t.tensors[a],o)}if(t.graphs&&t.graphs.length){i.graphs=[];for(var a=0;a<t.graphs.length;++a)i.graphs[a]=$.onnx.GraphProto.toObject(t.graphs[a],o)}if(t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),t.tp!=null&&t.hasOwnProperty("tp")&&(i.tp=$.onnx.TypeProto.toObject(t.tp,o)),t.typeProtos&&t.typeProtos.length){i.typeProtos=[];for(var a=0;a<t.typeProtos.length;++a)i.typeProtos[a]=$.onnx.TypeProto.toObject(t.typeProtos[a],o)}if(t.type!=null&&t.hasOwnProperty("type")&&(i.type=o.enums===String?$.onnx.AttributeProto.AttributeType[t.type]===void 0?t.type:$.onnx.AttributeProto.AttributeType[t.type]:t.type),t.refAttrName!=null&&t.hasOwnProperty("refAttrName")&&(i.refAttrName=t.refAttrName),t.sparseTensor!=null&&t.hasOwnProperty("sparseTensor")&&(i.sparseTensor=$.onnx.SparseTensorProto.toObject(t.sparseTensor,o)),t.sparseTensors&&t.sparseTensors.length){i.sparseTensors=[];for(var a=0;a<t.sparseTensors.length;++a)i.sparseTensors[a]=$.onnx.SparseTensorProto.toObject(t.sparseTensors[a],o)}return i},e.prototype.toJSON=function(){return this.constructor.toObject(this,Ze.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.AttributeProto"},e.AttributeType=function(){var n={},t=Object.create(n);return t[n[0]="UNDEFINED"]=0,t[n[1]="FLOAT"]=1,t[n[2]="INT"]=2,t[n[3]="STRING"]=3,t[n[4]="TENSOR"]=4,t[n[5]="GRAPH"]=5,t[n[11]="SPARSE_TENSOR"]=11,t[n[13]="TYPE_PROTO"]=13,t[n[6]="FLOATS"]=6,t[n[7]="INTS"]=7,t[n[8]="STRINGS"]=8,t[n[9]="TENSORS"]=9,t[n[10]="GRAPHS"]=10,t[n[12]="SPARSE_TENSORS"]=12,t[n[14]="TYPE_PROTOS"]=14,t}(),e}(),r.ValueInfoProto=function(){function e(n){if(n)for(var t=Object.keys(n),o=0;o<t.length;++o)n[t[o]]!=null&&(this[t[o]]=n[t[o]])}return e.prototype.name="",e.prototype.type=null,e.prototype.docString="",e.create=function(t){return new e(t)},e.encode=function(t,o){return o||(o=ct.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&o.uint32(10).string(t.name),t.type!=null&&Object.hasOwnProperty.call(t,"type")&&$.onnx.TypeProto.encode(t.type,o.uint32(18).fork()).ldelim(),t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&o.uint32(26).string(t.docString),o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof Z||(t=Z.create(t));for(var i=o===void 0?t.len:t.pos+o,u=new $.onnx.ValueInfoProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{u.name=t.string();break}case 2:{u.type=$.onnx.TypeProto.decode(t,t.uint32());break}case 3:{u.docString=t.string();break}default:t.skipType(a&7);break}}return u},e.decodeDelimited=function(t){return t instanceof Z||(t=new Z(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!A.isString(t.name))return"name: string expected";if(t.type!=null&&t.hasOwnProperty("type")){var o=$.onnx.TypeProto.verify(t.type);if(o)return"type."+o}return t.docString!=null&&t.hasOwnProperty("docString")&&!A.isString(t.docString)?"docString: string expected":null},e.fromObject=function(t){if(t instanceof $.onnx.ValueInfoProto)return t;var o=new $.onnx.ValueInfoProto;if(t.name!=null&&(o.name=String(t.name)),t.type!=null){if(typeof t.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");o.type=$.onnx.TypeProto.fromObject(t.type)}return t.docString!=null&&(o.docString=String(t.docString)),o},e.toObject=function(t,o){o||(o={});var i={};return o.defaults&&(i.name="",i.type=null,i.docString=""),t.name!=null&&t.hasOwnProperty("name")&&(i.name=t.name),t.type!=null&&t.hasOwnProperty("type")&&(i.type=$.onnx.TypeProto.toObject(t.type,o)),t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,Ze.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.ValueInfoProto"},e}(),r.NodeProto=function(){function e(n){if(this.input=[],this.output=[],this.attribute=[],n)for(var t=Object.keys(n),o=0;o<t.length;++o)n[t[o]]!=null&&(this[t[o]]=n[t[o]])}return e.prototype.input=A.emptyArray,e.prototype.output=A.emptyArray,e.prototype.name="",e.prototype.opType="",e.prototype.domain="",e.prototype.attribute=A.emptyArray,e.prototype.docString="",e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=ct.create()),t.input!=null&&t.input.length)for(var i=0;i<t.input.length;++i)o.uint32(10).string(t.input[i]);if(t.output!=null&&t.output.length)for(var i=0;i<t.output.length;++i)o.uint32(18).string(t.output[i]);if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&o.uint32(26).string(t.name),t.opType!=null&&Object.hasOwnProperty.call(t,"opType")&&o.uint32(34).string(t.opType),t.attribute!=null&&t.attribute.length)for(var i=0;i<t.attribute.length;++i)$.onnx.AttributeProto.encode(t.attribute[i],o.uint32(42).fork()).ldelim();return t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&o.uint32(50).string(t.docString),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&o.uint32(58).string(t.domain),o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof Z||(t=Z.create(t));for(var i=o===void 0?t.len:t.pos+o,u=new $.onnx.NodeProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{u.input&&u.input.length||(u.input=[]),u.input.push(t.string());break}case 2:{u.output&&u.output.length||(u.output=[]),u.output.push(t.string());break}case 3:{u.name=t.string();break}case 4:{u.opType=t.string();break}case 7:{u.domain=t.string();break}case 5:{u.attribute&&u.attribute.length||(u.attribute=[]),u.attribute.push($.onnx.AttributeProto.decode(t,t.uint32()));break}case 6:{u.docString=t.string();break}default:t.skipType(a&7);break}}return u},e.decodeDelimited=function(t){return t instanceof Z||(t=new Z(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var o=0;o<t.input.length;++o)if(!A.isString(t.input[o]))return"input: string[] expected"}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(var o=0;o<t.output.length;++o)if(!A.isString(t.output[o]))return"output: string[] expected"}if(t.name!=null&&t.hasOwnProperty("name")&&!A.isString(t.name))return"name: string expected";if(t.opType!=null&&t.hasOwnProperty("opType")&&!A.isString(t.opType))return"opType: string expected";if(t.domain!=null&&t.hasOwnProperty("domain")&&!A.isString(t.domain))return"domain: string expected";if(t.attribute!=null&&t.hasOwnProperty("attribute")){if(!Array.isArray(t.attribute))return"attribute: array expected";for(var o=0;o<t.attribute.length;++o){var i=$.onnx.AttributeProto.verify(t.attribute[o]);if(i)return"attribute."+i}}return t.docString!=null&&t.hasOwnProperty("docString")&&!A.isString(t.docString)?"docString: string expected":null},e.fromObject=function(t){if(t instanceof $.onnx.NodeProto)return t;var o=new $.onnx.NodeProto;if(t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.NodeProto.input: array expected");o.input=[];for(var i=0;i<t.input.length;++i)o.input[i]=String(t.input[i])}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.NodeProto.output: array expected");o.output=[];for(var i=0;i<t.output.length;++i)o.output[i]=String(t.output[i])}if(t.name!=null&&(o.name=String(t.name)),t.opType!=null&&(o.opType=String(t.opType)),t.domain!=null&&(o.domain=String(t.domain)),t.attribute){if(!Array.isArray(t.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");o.attribute=[];for(var i=0;i<t.attribute.length;++i){if(typeof t.attribute[i]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");o.attribute[i]=$.onnx.AttributeProto.fromObject(t.attribute[i])}}return t.docString!=null&&(o.docString=String(t.docString)),o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.input=[],i.output=[],i.attribute=[]),o.defaults&&(i.name="",i.opType="",i.docString="",i.domain=""),t.input&&t.input.length){i.input=[];for(var u=0;u<t.input.length;++u)i.input[u]=t.input[u]}if(t.output&&t.output.length){i.output=[];for(var u=0;u<t.output.length;++u)i.output[u]=t.output[u]}if(t.name!=null&&t.hasOwnProperty("name")&&(i.name=t.name),t.opType!=null&&t.hasOwnProperty("opType")&&(i.opType=t.opType),t.attribute&&t.attribute.length){i.attribute=[];for(var u=0;u<t.attribute.length;++u)i.attribute[u]=$.onnx.AttributeProto.toObject(t.attribute[u],o)}return t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),t.domain!=null&&t.hasOwnProperty("domain")&&(i.domain=t.domain),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,Ze.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.NodeProto"},e}(),r.TrainingInfoProto=function(){function e(n){if(this.initializationBinding=[],this.updateBinding=[],n)for(var t=Object.keys(n),o=0;o<t.length;++o)n[t[o]]!=null&&(this[t[o]]=n[t[o]])}return e.prototype.initialization=null,e.prototype.algorithm=null,e.prototype.initializationBinding=A.emptyArray,e.prototype.updateBinding=A.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=ct.create()),t.initialization!=null&&Object.hasOwnProperty.call(t,"initialization")&&$.onnx.GraphProto.encode(t.initialization,o.uint32(10).fork()).ldelim(),t.algorithm!=null&&Object.hasOwnProperty.call(t,"algorithm")&&$.onnx.GraphProto.encode(t.algorithm,o.uint32(18).fork()).ldelim(),t.initializationBinding!=null&&t.initializationBinding.length)for(var i=0;i<t.initializationBinding.length;++i)$.onnx.StringStringEntryProto.encode(t.initializationBinding[i],o.uint32(26).fork()).ldelim();if(t.updateBinding!=null&&t.updateBinding.length)for(var i=0;i<t.updateBinding.length;++i)$.onnx.StringStringEntryProto.encode(t.updateBinding[i],o.uint32(34).fork()).ldelim();return o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof Z||(t=Z.create(t));for(var i=o===void 0?t.len:t.pos+o,u=new $.onnx.TrainingInfoProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{u.initialization=$.onnx.GraphProto.decode(t,t.uint32());break}case 2:{u.algorithm=$.onnx.GraphProto.decode(t,t.uint32());break}case 3:{u.initializationBinding&&u.initializationBinding.length||(u.initializationBinding=[]),u.initializationBinding.push($.onnx.StringStringEntryProto.decode(t,t.uint32()));break}case 4:{u.updateBinding&&u.updateBinding.length||(u.updateBinding=[]),u.updateBinding.push($.onnx.StringStringEntryProto.decode(t,t.uint32()));break}default:t.skipType(a&7);break}}return u},e.decodeDelimited=function(t){return t instanceof Z||(t=new Z(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.initialization!=null&&t.hasOwnProperty("initialization")){var o=$.onnx.GraphProto.verify(t.initialization);if(o)return"initialization."+o}if(t.algorithm!=null&&t.hasOwnProperty("algorithm")){var o=$.onnx.GraphProto.verify(t.algorithm);if(o)return"algorithm."+o}if(t.initializationBinding!=null&&t.hasOwnProperty("initializationBinding")){if(!Array.isArray(t.initializationBinding))return"initializationBinding: array expected";for(var i=0;i<t.initializationBinding.length;++i){var o=$.onnx.StringStringEntryProto.verify(t.initializationBinding[i]);if(o)return"initializationBinding."+o}}if(t.updateBinding!=null&&t.hasOwnProperty("updateBinding")){if(!Array.isArray(t.updateBinding))return"updateBinding: array expected";for(var i=0;i<t.updateBinding.length;++i){var o=$.onnx.StringStringEntryProto.verify(t.updateBinding[i]);if(o)return"updateBinding."+o}}return null},e.fromObject=function(t){if(t instanceof $.onnx.TrainingInfoProto)return t;var o=new $.onnx.TrainingInfoProto;if(t.initialization!=null){if(typeof t.initialization!="object")throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");o.initialization=$.onnx.GraphProto.fromObject(t.initialization)}if(t.algorithm!=null){if(typeof t.algorithm!="object")throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");o.algorithm=$.onnx.GraphProto.fromObject(t.algorithm)}if(t.initializationBinding){if(!Array.isArray(t.initializationBinding))throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");o.initializationBinding=[];for(var i=0;i<t.initializationBinding.length;++i){if(typeof t.initializationBinding[i]!="object")throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");o.initializationBinding[i]=$.onnx.StringStringEntryProto.fromObject(t.initializationBinding[i])}}if(t.updateBinding){if(!Array.isArray(t.updateBinding))throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");o.updateBinding=[];for(var i=0;i<t.updateBinding.length;++i){if(typeof t.updateBinding[i]!="object")throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");o.updateBinding[i]=$.onnx.StringStringEntryProto.fromObject(t.updateBinding[i])}}return o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.initializationBinding=[],i.updateBinding=[]),o.defaults&&(i.initialization=null,i.algorithm=null),t.initialization!=null&&t.hasOwnProperty("initialization")&&(i.initialization=$.onnx.GraphProto.toObject(t.initialization,o)),t.algorithm!=null&&t.hasOwnProperty("algorithm")&&(i.algorithm=$.onnx.GraphProto.toObject(t.algorithm,o)),t.initializationBinding&&t.initializationBinding.length){i.initializationBinding=[];for(var u=0;u<t.initializationBinding.length;++u)i.initializationBinding[u]=$.onnx.StringStringEntryProto.toObject(t.initializationBinding[u],o)}if(t.updateBinding&&t.updateBinding.length){i.updateBinding=[];for(var u=0;u<t.updateBinding.length;++u)i.updateBinding[u]=$.onnx.StringStringEntryProto.toObject(t.updateBinding[u],o)}return i},e.prototype.toJSON=function(){return this.constructor.toObject(this,Ze.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TrainingInfoProto"},e}(),r.ModelProto=function(){function e(n){if(this.opsetImport=[],this.metadataProps=[],this.trainingInfo=[],this.functions=[],n)for(var t=Object.keys(n),o=0;o<t.length;++o)n[t[o]]!=null&&(this[t[o]]=n[t[o]])}return e.prototype.irVersion=A.Long?A.Long.fromBits(0,0,!1):0,e.prototype.opsetImport=A.emptyArray,e.prototype.producerName="",e.prototype.producerVersion="",e.prototype.domain="",e.prototype.modelVersion=A.Long?A.Long.fromBits(0,0,!1):0,e.prototype.docString="",e.prototype.graph=null,e.prototype.metadataProps=A.emptyArray,e.prototype.trainingInfo=A.emptyArray,e.prototype.functions=A.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=ct.create()),t.irVersion!=null&&Object.hasOwnProperty.call(t,"irVersion")&&o.uint32(8).int64(t.irVersion),t.producerName!=null&&Object.hasOwnProperty.call(t,"producerName")&&o.uint32(18).string(t.producerName),t.producerVersion!=null&&Object.hasOwnProperty.call(t,"producerVersion")&&o.uint32(26).string(t.producerVersion),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&o.uint32(34).string(t.domain),t.modelVersion!=null&&Object.hasOwnProperty.call(t,"modelVersion")&&o.uint32(40).int64(t.modelVersion),t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&o.uint32(50).string(t.docString),t.graph!=null&&Object.hasOwnProperty.call(t,"graph")&&$.onnx.GraphProto.encode(t.graph,o.uint32(58).fork()).ldelim(),t.opsetImport!=null&&t.opsetImport.length)for(var i=0;i<t.opsetImport.length;++i)$.onnx.OperatorSetIdProto.encode(t.opsetImport[i],o.uint32(66).fork()).ldelim();if(t.metadataProps!=null&&t.metadataProps.length)for(var i=0;i<t.metadataProps.length;++i)$.onnx.StringStringEntryProto.encode(t.metadataProps[i],o.uint32(114).fork()).ldelim();if(t.trainingInfo!=null&&t.trainingInfo.length)for(var i=0;i<t.trainingInfo.length;++i)$.onnx.TrainingInfoProto.encode(t.trainingInfo[i],o.uint32(162).fork()).ldelim();if(t.functions!=null&&t.functions.length)for(var i=0;i<t.functions.length;++i)$.onnx.FunctionProto.encode(t.functions[i],o.uint32(202).fork()).ldelim();return o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof Z||(t=Z.create(t));for(var i=o===void 0?t.len:t.pos+o,u=new $.onnx.ModelProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{u.irVersion=t.int64();break}case 8:{u.opsetImport&&u.opsetImport.length||(u.opsetImport=[]),u.opsetImport.push($.onnx.OperatorSetIdProto.decode(t,t.uint32()));break}case 2:{u.producerName=t.string();break}case 3:{u.producerVersion=t.string();break}case 4:{u.domain=t.string();break}case 5:{u.modelVersion=t.int64();break}case 6:{u.docString=t.string();break}case 7:{u.graph=$.onnx.GraphProto.decode(t,t.uint32());break}case 14:{u.metadataProps&&u.metadataProps.length||(u.metadataProps=[]),u.metadataProps.push($.onnx.StringStringEntryProto.decode(t,t.uint32()));break}case 20:{u.trainingInfo&&u.trainingInfo.length||(u.trainingInfo=[]),u.trainingInfo.push($.onnx.TrainingInfoProto.decode(t,t.uint32()));break}case 25:{u.functions&&u.functions.length||(u.functions=[]),u.functions.push($.onnx.FunctionProto.decode(t,t.uint32()));break}default:t.skipType(a&7);break}}return u},e.decodeDelimited=function(t){return t instanceof Z||(t=new Z(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.irVersion!=null&&t.hasOwnProperty("irVersion")&&!A.isInteger(t.irVersion)&&!(t.irVersion&&A.isInteger(t.irVersion.low)&&A.isInteger(t.irVersion.high)))return"irVersion: integer|Long expected";if(t.opsetImport!=null&&t.hasOwnProperty("opsetImport")){if(!Array.isArray(t.opsetImport))return"opsetImport: array expected";for(var o=0;o<t.opsetImport.length;++o){var i=$.onnx.OperatorSetIdProto.verify(t.opsetImport[o]);if(i)return"opsetImport."+i}}if(t.producerName!=null&&t.hasOwnProperty("producerName")&&!A.isString(t.producerName))return"producerName: string expected";if(t.producerVersion!=null&&t.hasOwnProperty("producerVersion")&&!A.isString(t.producerVersion))return"producerVersion: string expected";if(t.domain!=null&&t.hasOwnProperty("domain")&&!A.isString(t.domain))return"domain: string expected";if(t.modelVersion!=null&&t.hasOwnProperty("modelVersion")&&!A.isInteger(t.modelVersion)&&!(t.modelVersion&&A.isInteger(t.modelVersion.low)&&A.isInteger(t.modelVersion.high)))return"modelVersion: integer|Long expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!A.isString(t.docString))return"docString: string expected";if(t.graph!=null&&t.hasOwnProperty("graph")){var i=$.onnx.GraphProto.verify(t.graph);if(i)return"graph."+i}if(t.metadataProps!=null&&t.hasOwnProperty("metadataProps")){if(!Array.isArray(t.metadataProps))return"metadataProps: array expected";for(var o=0;o<t.metadataProps.length;++o){var i=$.onnx.StringStringEntryProto.verify(t.metadataProps[o]);if(i)return"metadataProps."+i}}if(t.trainingInfo!=null&&t.hasOwnProperty("trainingInfo")){if(!Array.isArray(t.trainingInfo))return"trainingInfo: array expected";for(var o=0;o<t.trainingInfo.length;++o){var i=$.onnx.TrainingInfoProto.verify(t.trainingInfo[o]);if(i)return"trainingInfo."+i}}if(t.functions!=null&&t.hasOwnProperty("functions")){if(!Array.isArray(t.functions))return"functions: array expected";for(var o=0;o<t.functions.length;++o){var i=$.onnx.FunctionProto.verify(t.functions[o]);if(i)return"functions."+i}}return null},e.fromObject=function(t){if(t instanceof $.onnx.ModelProto)return t;var o=new $.onnx.ModelProto;if(t.irVersion!=null&&(A.Long?(o.irVersion=A.Long.fromValue(t.irVersion)).unsigned=!1:typeof t.irVersion=="string"?o.irVersion=parseInt(t.irVersion,10):typeof t.irVersion=="number"?o.irVersion=t.irVersion:typeof t.irVersion=="object"&&(o.irVersion=new A.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber())),t.opsetImport){if(!Array.isArray(t.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");o.opsetImport=[];for(var i=0;i<t.opsetImport.length;++i){if(typeof t.opsetImport[i]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");o.opsetImport[i]=$.onnx.OperatorSetIdProto.fromObject(t.opsetImport[i])}}if(t.producerName!=null&&(o.producerName=String(t.producerName)),t.producerVersion!=null&&(o.producerVersion=String(t.producerVersion)),t.domain!=null&&(o.domain=String(t.domain)),t.modelVersion!=null&&(A.Long?(o.modelVersion=A.Long.fromValue(t.modelVersion)).unsigned=!1:typeof t.modelVersion=="string"?o.modelVersion=parseInt(t.modelVersion,10):typeof t.modelVersion=="number"?o.modelVersion=t.modelVersion:typeof t.modelVersion=="object"&&(o.modelVersion=new A.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber())),t.docString!=null&&(o.docString=String(t.docString)),t.graph!=null){if(typeof t.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");o.graph=$.onnx.GraphProto.fromObject(t.graph)}if(t.metadataProps){if(!Array.isArray(t.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");o.metadataProps=[];for(var i=0;i<t.metadataProps.length;++i){if(typeof t.metadataProps[i]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");o.metadataProps[i]=$.onnx.StringStringEntryProto.fromObject(t.metadataProps[i])}}if(t.trainingInfo){if(!Array.isArray(t.trainingInfo))throw TypeError(".onnx.ModelProto.trainingInfo: array expected");o.trainingInfo=[];for(var i=0;i<t.trainingInfo.length;++i){if(typeof t.trainingInfo[i]!="object")throw TypeError(".onnx.ModelProto.trainingInfo: object expected");o.trainingInfo[i]=$.onnx.TrainingInfoProto.fromObject(t.trainingInfo[i])}}if(t.functions){if(!Array.isArray(t.functions))throw TypeError(".onnx.ModelProto.functions: array expected");o.functions=[];for(var i=0;i<t.functions.length;++i){if(typeof t.functions[i]!="object")throw TypeError(".onnx.ModelProto.functions: object expected");o.functions[i]=$.onnx.FunctionProto.fromObject(t.functions[i])}}return o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.opsetImport=[],i.metadataProps=[],i.trainingInfo=[],i.functions=[]),o.defaults){if(A.Long){var u=new A.Long(0,0,!1);i.irVersion=o.longs===String?u.toString():o.longs===Number?u.toNumber():u}else i.irVersion=o.longs===String?"0":0;if(i.producerName="",i.producerVersion="",i.domain="",A.Long){var u=new A.Long(0,0,!1);i.modelVersion=o.longs===String?u.toString():o.longs===Number?u.toNumber():u}else i.modelVersion=o.longs===String?"0":0;i.docString="",i.graph=null}if(t.irVersion!=null&&t.hasOwnProperty("irVersion")&&(typeof t.irVersion=="number"?i.irVersion=o.longs===String?String(t.irVersion):t.irVersion:i.irVersion=o.longs===String?A.Long.prototype.toString.call(t.irVersion):o.longs===Number?new A.LongBits(t.irVersion.low>>>0,t.irVersion.high>>>0).toNumber():t.irVersion),t.producerName!=null&&t.hasOwnProperty("producerName")&&(i.producerName=t.producerName),t.producerVersion!=null&&t.hasOwnProperty("producerVersion")&&(i.producerVersion=t.producerVersion),t.domain!=null&&t.hasOwnProperty("domain")&&(i.domain=t.domain),t.modelVersion!=null&&t.hasOwnProperty("modelVersion")&&(typeof t.modelVersion=="number"?i.modelVersion=o.longs===String?String(t.modelVersion):t.modelVersion:i.modelVersion=o.longs===String?A.Long.prototype.toString.call(t.modelVersion):o.longs===Number?new A.LongBits(t.modelVersion.low>>>0,t.modelVersion.high>>>0).toNumber():t.modelVersion),t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),t.graph!=null&&t.hasOwnProperty("graph")&&(i.graph=$.onnx.GraphProto.toObject(t.graph,o)),t.opsetImport&&t.opsetImport.length){i.opsetImport=[];for(var a=0;a<t.opsetImport.length;++a)i.opsetImport[a]=$.onnx.OperatorSetIdProto.toObject(t.opsetImport[a],o)}if(t.metadataProps&&t.metadataProps.length){i.metadataProps=[];for(var a=0;a<t.metadataProps.length;++a)i.metadataProps[a]=$.onnx.StringStringEntryProto.toObject(t.metadataProps[a],o)}if(t.trainingInfo&&t.trainingInfo.length){i.trainingInfo=[];for(var a=0;a<t.trainingInfo.length;++a)i.trainingInfo[a]=$.onnx.TrainingInfoProto.toObject(t.trainingInfo[a],o)}if(t.functions&&t.functions.length){i.functions=[];for(var a=0;a<t.functions.length;++a)i.functions[a]=$.onnx.FunctionProto.toObject(t.functions[a],o)}return i},e.prototype.toJSON=function(){return this.constructor.toObject(this,Ze.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.ModelProto"},e}(),r.StringStringEntryProto=function(){function e(n){if(n)for(var t=Object.keys(n),o=0;o<t.length;++o)n[t[o]]!=null&&(this[t[o]]=n[t[o]])}return e.prototype.key="",e.prototype.value="",e.create=function(t){return new e(t)},e.encode=function(t,o){return o||(o=ct.create()),t.key!=null&&Object.hasOwnProperty.call(t,"key")&&o.uint32(10).string(t.key),t.value!=null&&Object.hasOwnProperty.call(t,"value")&&o.uint32(18).string(t.value),o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof Z||(t=Z.create(t));for(var i=o===void 0?t.len:t.pos+o,u=new $.onnx.StringStringEntryProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{u.key=t.string();break}case 2:{u.value=t.string();break}default:t.skipType(a&7);break}}return u},e.decodeDelimited=function(t){return t instanceof Z||(t=new Z(t)),this.decode(t,t.uint32())},e.verify=function(t){return typeof t!="object"||t===null?"object expected":t.key!=null&&t.hasOwnProperty("key")&&!A.isString(t.key)?"key: string expected":t.value!=null&&t.hasOwnProperty("value")&&!A.isString(t.value)?"value: string expected":null},e.fromObject=function(t){if(t instanceof $.onnx.StringStringEntryProto)return t;var o=new $.onnx.StringStringEntryProto;return t.key!=null&&(o.key=String(t.key)),t.value!=null&&(o.value=String(t.value)),o},e.toObject=function(t,o){o||(o={});var i={};return o.defaults&&(i.key="",i.value=""),t.key!=null&&t.hasOwnProperty("key")&&(i.key=t.key),t.value!=null&&t.hasOwnProperty("value")&&(i.value=t.value),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,Ze.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.StringStringEntryProto"},e}(),r.TensorAnnotation=function(){function e(n){if(this.quantParameterTensorNames=[],n)for(var t=Object.keys(n),o=0;o<t.length;++o)n[t[o]]!=null&&(this[t[o]]=n[t[o]])}return e.prototype.tensorName="",e.prototype.quantParameterTensorNames=A.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=ct.create()),t.tensorName!=null&&Object.hasOwnProperty.call(t,"tensorName")&&o.uint32(10).string(t.tensorName),t.quantParameterTensorNames!=null&&t.quantParameterTensorNames.length)for(var i=0;i<t.quantParameterTensorNames.length;++i)$.onnx.StringStringEntryProto.encode(t.quantParameterTensorNames[i],o.uint32(18).fork()).ldelim();return o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof Z||(t=Z.create(t));for(var i=o===void 0?t.len:t.pos+o,u=new $.onnx.TensorAnnotation;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{u.tensorName=t.string();break}case 2:{u.quantParameterTensorNames&&u.quantParameterTensorNames.length||(u.quantParameterTensorNames=[]),u.quantParameterTensorNames.push($.onnx.StringStringEntryProto.decode(t,t.uint32()));break}default:t.skipType(a&7);break}}return u},e.decodeDelimited=function(t){return t instanceof Z||(t=new Z(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.tensorName!=null&&t.hasOwnProperty("tensorName")&&!A.isString(t.tensorName))return"tensorName: string expected";if(t.quantParameterTensorNames!=null&&t.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(t.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var o=0;o<t.quantParameterTensorNames.length;++o){var i=$.onnx.StringStringEntryProto.verify(t.quantParameterTensorNames[o]);if(i)return"quantParameterTensorNames."+i}}return null},e.fromObject=function(t){if(t instanceof $.onnx.TensorAnnotation)return t;var o=new $.onnx.TensorAnnotation;if(t.tensorName!=null&&(o.tensorName=String(t.tensorName)),t.quantParameterTensorNames){if(!Array.isArray(t.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");o.quantParameterTensorNames=[];for(var i=0;i<t.quantParameterTensorNames.length;++i){if(typeof t.quantParameterTensorNames[i]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");o.quantParameterTensorNames[i]=$.onnx.StringStringEntryProto.fromObject(t.quantParameterTensorNames[i])}}return o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.quantParameterTensorNames=[]),o.defaults&&(i.tensorName=""),t.tensorName!=null&&t.hasOwnProperty("tensorName")&&(i.tensorName=t.tensorName),t.quantParameterTensorNames&&t.quantParameterTensorNames.length){i.quantParameterTensorNames=[];for(var u=0;u<t.quantParameterTensorNames.length;++u)i.quantParameterTensorNames[u]=$.onnx.StringStringEntryProto.toObject(t.quantParameterTensorNames[u],o)}return i},e.prototype.toJSON=function(){return this.constructor.toObject(this,Ze.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorAnnotation"},e}(),r.GraphProto=function(){function e(n){if(this.node=[],this.initializer=[],this.sparseInitializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],n)for(var t=Object.keys(n),o=0;o<t.length;++o)n[t[o]]!=null&&(this[t[o]]=n[t[o]])}return e.prototype.node=A.emptyArray,e.prototype.name="",e.prototype.initializer=A.emptyArray,e.prototype.sparseInitializer=A.emptyArray,e.prototype.docString="",e.prototype.input=A.emptyArray,e.prototype.output=A.emptyArray,e.prototype.valueInfo=A.emptyArray,e.prototype.quantizationAnnotation=A.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=ct.create()),t.node!=null&&t.node.length)for(var i=0;i<t.node.length;++i)$.onnx.NodeProto.encode(t.node[i],o.uint32(10).fork()).ldelim();if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&o.uint32(18).string(t.name),t.initializer!=null&&t.initializer.length)for(var i=0;i<t.initializer.length;++i)$.onnx.TensorProto.encode(t.initializer[i],o.uint32(42).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&o.uint32(82).string(t.docString),t.input!=null&&t.input.length)for(var i=0;i<t.input.length;++i)$.onnx.ValueInfoProto.encode(t.input[i],o.uint32(90).fork()).ldelim();if(t.output!=null&&t.output.length)for(var i=0;i<t.output.length;++i)$.onnx.ValueInfoProto.encode(t.output[i],o.uint32(98).fork()).ldelim();if(t.valueInfo!=null&&t.valueInfo.length)for(var i=0;i<t.valueInfo.length;++i)$.onnx.ValueInfoProto.encode(t.valueInfo[i],o.uint32(106).fork()).ldelim();if(t.quantizationAnnotation!=null&&t.quantizationAnnotation.length)for(var i=0;i<t.quantizationAnnotation.length;++i)$.onnx.TensorAnnotation.encode(t.quantizationAnnotation[i],o.uint32(114).fork()).ldelim();if(t.sparseInitializer!=null&&t.sparseInitializer.length)for(var i=0;i<t.sparseInitializer.length;++i)$.onnx.SparseTensorProto.encode(t.sparseInitializer[i],o.uint32(122).fork()).ldelim();return o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof Z||(t=Z.create(t));for(var i=o===void 0?t.len:t.pos+o,u=new $.onnx.GraphProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{u.node&&u.node.length||(u.node=[]),u.node.push($.onnx.NodeProto.decode(t,t.uint32()));break}case 2:{u.name=t.string();break}case 5:{u.initializer&&u.initializer.length||(u.initializer=[]),u.initializer.push($.onnx.TensorProto.decode(t,t.uint32()));break}case 15:{u.sparseInitializer&&u.sparseInitializer.length||(u.sparseInitializer=[]),u.sparseInitializer.push($.onnx.SparseTensorProto.decode(t,t.uint32()));break}case 10:{u.docString=t.string();break}case 11:{u.input&&u.input.length||(u.input=[]),u.input.push($.onnx.ValueInfoProto.decode(t,t.uint32()));break}case 12:{u.output&&u.output.length||(u.output=[]),u.output.push($.onnx.ValueInfoProto.decode(t,t.uint32()));break}case 13:{u.valueInfo&&u.valueInfo.length||(u.valueInfo=[]),u.valueInfo.push($.onnx.ValueInfoProto.decode(t,t.uint32()));break}case 14:{u.quantizationAnnotation&&u.quantizationAnnotation.length||(u.quantizationAnnotation=[]),u.quantizationAnnotation.push($.onnx.TensorAnnotation.decode(t,t.uint32()));break}default:t.skipType(a&7);break}}return u},e.decodeDelimited=function(t){return t instanceof Z||(t=new Z(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.node!=null&&t.hasOwnProperty("node")){if(!Array.isArray(t.node))return"node: array expected";for(var o=0;o<t.node.length;++o){var i=$.onnx.NodeProto.verify(t.node[o]);if(i)return"node."+i}}if(t.name!=null&&t.hasOwnProperty("name")&&!A.isString(t.name))return"name: string expected";if(t.initializer!=null&&t.hasOwnProperty("initializer")){if(!Array.isArray(t.initializer))return"initializer: array expected";for(var o=0;o<t.initializer.length;++o){var i=$.onnx.TensorProto.verify(t.initializer[o]);if(i)return"initializer."+i}}if(t.sparseInitializer!=null&&t.hasOwnProperty("sparseInitializer")){if(!Array.isArray(t.sparseInitializer))return"sparseInitializer: array expected";for(var o=0;o<t.sparseInitializer.length;++o){var i=$.onnx.SparseTensorProto.verify(t.sparseInitializer[o]);if(i)return"sparseInitializer."+i}}if(t.docString!=null&&t.hasOwnProperty("docString")&&!A.isString(t.docString))return"docString: string expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var o=0;o<t.input.length;++o){var i=$.onnx.ValueInfoProto.verify(t.input[o]);if(i)return"input."+i}}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(var o=0;o<t.output.length;++o){var i=$.onnx.ValueInfoProto.verify(t.output[o]);if(i)return"output."+i}}if(t.valueInfo!=null&&t.hasOwnProperty("valueInfo")){if(!Array.isArray(t.valueInfo))return"valueInfo: array expected";for(var o=0;o<t.valueInfo.length;++o){var i=$.onnx.ValueInfoProto.verify(t.valueInfo[o]);if(i)return"valueInfo."+i}}if(t.quantizationAnnotation!=null&&t.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(t.quantizationAnnotation))return"quantizationAnnotation: array expected";for(var o=0;o<t.quantizationAnnotation.length;++o){var i=$.onnx.TensorAnnotation.verify(t.quantizationAnnotation[o]);if(i)return"quantizationAnnotation."+i}}return null},e.fromObject=function(t){if(t instanceof $.onnx.GraphProto)return t;var o=new $.onnx.GraphProto;if(t.node){if(!Array.isArray(t.node))throw TypeError(".onnx.GraphProto.node: array expected");o.node=[];for(var i=0;i<t.node.length;++i){if(typeof t.node[i]!="object")throw TypeError(".onnx.GraphProto.node: object expected");o.node[i]=$.onnx.NodeProto.fromObject(t.node[i])}}if(t.name!=null&&(o.name=String(t.name)),t.initializer){if(!Array.isArray(t.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");o.initializer=[];for(var i=0;i<t.initializer.length;++i){if(typeof t.initializer[i]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");o.initializer[i]=$.onnx.TensorProto.fromObject(t.initializer[i])}}if(t.sparseInitializer){if(!Array.isArray(t.sparseInitializer))throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");o.sparseInitializer=[];for(var i=0;i<t.sparseInitializer.length;++i){if(typeof t.sparseInitializer[i]!="object")throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");o.sparseInitializer[i]=$.onnx.SparseTensorProto.fromObject(t.sparseInitializer[i])}}if(t.docString!=null&&(o.docString=String(t.docString)),t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.GraphProto.input: array expected");o.input=[];for(var i=0;i<t.input.length;++i){if(typeof t.input[i]!="object")throw TypeError(".onnx.GraphProto.input: object expected");o.input[i]=$.onnx.ValueInfoProto.fromObject(t.input[i])}}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.GraphProto.output: array expected");o.output=[];for(var i=0;i<t.output.length;++i){if(typeof t.output[i]!="object")throw TypeError(".onnx.GraphProto.output: object expected");o.output[i]=$.onnx.ValueInfoProto.fromObject(t.output[i])}}if(t.valueInfo){if(!Array.isArray(t.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");o.valueInfo=[];for(var i=0;i<t.valueInfo.length;++i){if(typeof t.valueInfo[i]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");o.valueInfo[i]=$.onnx.ValueInfoProto.fromObject(t.valueInfo[i])}}if(t.quantizationAnnotation){if(!Array.isArray(t.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");o.quantizationAnnotation=[];for(var i=0;i<t.quantizationAnnotation.length;++i){if(typeof t.quantizationAnnotation[i]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");o.quantizationAnnotation[i]=$.onnx.TensorAnnotation.fromObject(t.quantizationAnnotation[i])}}return o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.node=[],i.initializer=[],i.input=[],i.output=[],i.valueInfo=[],i.quantizationAnnotation=[],i.sparseInitializer=[]),o.defaults&&(i.name="",i.docString=""),t.node&&t.node.length){i.node=[];for(var u=0;u<t.node.length;++u)i.node[u]=$.onnx.NodeProto.toObject(t.node[u],o)}if(t.name!=null&&t.hasOwnProperty("name")&&(i.name=t.name),t.initializer&&t.initializer.length){i.initializer=[];for(var u=0;u<t.initializer.length;++u)i.initializer[u]=$.onnx.TensorProto.toObject(t.initializer[u],o)}if(t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),t.input&&t.input.length){i.input=[];for(var u=0;u<t.input.length;++u)i.input[u]=$.onnx.ValueInfoProto.toObject(t.input[u],o)}if(t.output&&t.output.length){i.output=[];for(var u=0;u<t.output.length;++u)i.output[u]=$.onnx.ValueInfoProto.toObject(t.output[u],o)}if(t.valueInfo&&t.valueInfo.length){i.valueInfo=[];for(var u=0;u<t.valueInfo.length;++u)i.valueInfo[u]=$.onnx.ValueInfoProto.toObject(t.valueInfo[u],o)}if(t.quantizationAnnotation&&t.quantizationAnnotation.length){i.quantizationAnnotation=[];for(var u=0;u<t.quantizationAnnotation.length;++u)i.quantizationAnnotation[u]=$.onnx.TensorAnnotation.toObject(t.quantizationAnnotation[u],o)}if(t.sparseInitializer&&t.sparseInitializer.length){i.sparseInitializer=[];for(var u=0;u<t.sparseInitializer.length;++u)i.sparseInitializer[u]=$.onnx.SparseTensorProto.toObject(t.sparseInitializer[u],o)}return i},e.prototype.toJSON=function(){return this.constructor.toObject(this,Ze.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.GraphProto"},e}(),r.TensorProto=function(){function e(n){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],n)for(var t=Object.keys(n),o=0;o<t.length;++o)n[t[o]]!=null&&(this[t[o]]=n[t[o]])}return e.prototype.dims=A.emptyArray,e.prototype.dataType=0,e.prototype.segment=null,e.prototype.floatData=A.emptyArray,e.prototype.int32Data=A.emptyArray,e.prototype.stringData=A.emptyArray,e.prototype.int64Data=A.emptyArray,e.prototype.name="",e.prototype.docString="",e.prototype.rawData=A.newBuffer([]),e.prototype.externalData=A.emptyArray,e.prototype.dataLocation=0,e.prototype.doubleData=A.emptyArray,e.prototype.uint64Data=A.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=ct.create()),t.dims!=null&&t.dims.length){o.uint32(10).fork();for(var i=0;i<t.dims.length;++i)o.int64(t.dims[i]);o.ldelim()}if(t.dataType!=null&&Object.hasOwnProperty.call(t,"dataType")&&o.uint32(16).int32(t.dataType),t.segment!=null&&Object.hasOwnProperty.call(t,"segment")&&$.onnx.TensorProto.Segment.encode(t.segment,o.uint32(26).fork()).ldelim(),t.floatData!=null&&t.floatData.length){o.uint32(34).fork();for(var i=0;i<t.floatData.length;++i)o.float(t.floatData[i]);o.ldelim()}if(t.int32Data!=null&&t.int32Data.length){o.uint32(42).fork();for(var i=0;i<t.int32Data.length;++i)o.int32(t.int32Data[i]);o.ldelim()}if(t.stringData!=null&&t.stringData.length)for(var i=0;i<t.stringData.length;++i)o.uint32(50).bytes(t.stringData[i]);if(t.int64Data!=null&&t.int64Data.length){o.uint32(58).fork();for(var i=0;i<t.int64Data.length;++i)o.int64(t.int64Data[i]);o.ldelim()}if(t.name!=null&&Object.hasOwnProperty.call(t,"name")&&o.uint32(66).string(t.name),t.rawData!=null&&Object.hasOwnProperty.call(t,"rawData")&&o.uint32(74).bytes(t.rawData),t.doubleData!=null&&t.doubleData.length){o.uint32(82).fork();for(var i=0;i<t.doubleData.length;++i)o.double(t.doubleData[i]);o.ldelim()}if(t.uint64Data!=null&&t.uint64Data.length){o.uint32(90).fork();for(var i=0;i<t.uint64Data.length;++i)o.uint64(t.uint64Data[i]);o.ldelim()}if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&o.uint32(98).string(t.docString),t.externalData!=null&&t.externalData.length)for(var i=0;i<t.externalData.length;++i)$.onnx.StringStringEntryProto.encode(t.externalData[i],o.uint32(106).fork()).ldelim();return t.dataLocation!=null&&Object.hasOwnProperty.call(t,"dataLocation")&&o.uint32(112).int32(t.dataLocation),o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof Z||(t=Z.create(t));for(var i=o===void 0?t.len:t.pos+o,u=new $.onnx.TensorProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{if(u.dims&&u.dims.length||(u.dims=[]),(a&7)===2)for(var s=t.uint32()+t.pos;t.pos<s;)u.dims.push(t.int64());else u.dims.push(t.int64());break}case 2:{u.dataType=t.int32();break}case 3:{u.segment=$.onnx.TensorProto.Segment.decode(t,t.uint32());break}case 4:{if(u.floatData&&u.floatData.length||(u.floatData=[]),(a&7)===2)for(var s=t.uint32()+t.pos;t.pos<s;)u.floatData.push(t.float());else u.floatData.push(t.float());break}case 5:{if(u.int32Data&&u.int32Data.length||(u.int32Data=[]),(a&7)===2)for(var s=t.uint32()+t.pos;t.pos<s;)u.int32Data.push(t.int32());else u.int32Data.push(t.int32());break}case 6:{u.stringData&&u.stringData.length||(u.stringData=[]),u.stringData.push(t.bytes());break}case 7:{if(u.int64Data&&u.int64Data.length||(u.int64Data=[]),(a&7)===2)for(var s=t.uint32()+t.pos;t.pos<s;)u.int64Data.push(t.int64());else u.int64Data.push(t.int64());break}case 8:{u.name=t.string();break}case 12:{u.docString=t.string();break}case 9:{u.rawData=t.bytes();break}case 13:{u.externalData&&u.externalData.length||(u.externalData=[]),u.externalData.push($.onnx.StringStringEntryProto.decode(t,t.uint32()));break}case 14:{u.dataLocation=t.int32();break}case 10:{if(u.doubleData&&u.doubleData.length||(u.doubleData=[]),(a&7)===2)for(var s=t.uint32()+t.pos;t.pos<s;)u.doubleData.push(t.double());else u.doubleData.push(t.double());break}case 11:{if(u.uint64Data&&u.uint64Data.length||(u.uint64Data=[]),(a&7)===2)for(var s=t.uint32()+t.pos;t.pos<s;)u.uint64Data.push(t.uint64());else u.uint64Data.push(t.uint64());break}default:t.skipType(a&7);break}}return u},e.decodeDelimited=function(t){return t instanceof Z||(t=new Z(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.dims!=null&&t.hasOwnProperty("dims")){if(!Array.isArray(t.dims))return"dims: array expected";for(var o=0;o<t.dims.length;++o)if(!A.isInteger(t.dims[o])&&!(t.dims[o]&&A.isInteger(t.dims[o].low)&&A.isInteger(t.dims[o].high)))return"dims: integer|Long[] expected"}if(t.dataType!=null&&t.hasOwnProperty("dataType")&&!A.isInteger(t.dataType))return"dataType: integer expected";if(t.segment!=null&&t.hasOwnProperty("segment")){var i=$.onnx.TensorProto.Segment.verify(t.segment);if(i)return"segment."+i}if(t.floatData!=null&&t.hasOwnProperty("floatData")){if(!Array.isArray(t.floatData))return"floatData: array expected";for(var o=0;o<t.floatData.length;++o)if(typeof t.floatData[o]!="number")return"floatData: number[] expected"}if(t.int32Data!=null&&t.hasOwnProperty("int32Data")){if(!Array.isArray(t.int32Data))return"int32Data: array expected";for(var o=0;o<t.int32Data.length;++o)if(!A.isInteger(t.int32Data[o]))return"int32Data: integer[] expected"}if(t.stringData!=null&&t.hasOwnProperty("stringData")){if(!Array.isArray(t.stringData))return"stringData: array expected";for(var o=0;o<t.stringData.length;++o)if(!(t.stringData[o]&&typeof t.stringData[o].length=="number"||A.isString(t.stringData[o])))return"stringData: buffer[] expected"}if(t.int64Data!=null&&t.hasOwnProperty("int64Data")){if(!Array.isArray(t.int64Data))return"int64Data: array expected";for(var o=0;o<t.int64Data.length;++o)if(!A.isInteger(t.int64Data[o])&&!(t.int64Data[o]&&A.isInteger(t.int64Data[o].low)&&A.isInteger(t.int64Data[o].high)))return"int64Data: integer|Long[] expected"}if(t.name!=null&&t.hasOwnProperty("name")&&!A.isString(t.name))return"name: string expected";if(t.docString!=null&&t.hasOwnProperty("docString")&&!A.isString(t.docString))return"docString: string expected";if(t.rawData!=null&&t.hasOwnProperty("rawData")&&!(t.rawData&&typeof t.rawData.length=="number"||A.isString(t.rawData)))return"rawData: buffer expected";if(t.externalData!=null&&t.hasOwnProperty("externalData")){if(!Array.isArray(t.externalData))return"externalData: array expected";for(var o=0;o<t.externalData.length;++o){var i=$.onnx.StringStringEntryProto.verify(t.externalData[o]);if(i)return"externalData."+i}}if(t.dataLocation!=null&&t.hasOwnProperty("dataLocation"))switch(t.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:break}if(t.doubleData!=null&&t.hasOwnProperty("doubleData")){if(!Array.isArray(t.doubleData))return"doubleData: array expected";for(var o=0;o<t.doubleData.length;++o)if(typeof t.doubleData[o]!="number")return"doubleData: number[] expected"}if(t.uint64Data!=null&&t.hasOwnProperty("uint64Data")){if(!Array.isArray(t.uint64Data))return"uint64Data: array expected";for(var o=0;o<t.uint64Data.length;++o)if(!A.isInteger(t.uint64Data[o])&&!(t.uint64Data[o]&&A.isInteger(t.uint64Data[o].low)&&A.isInteger(t.uint64Data[o].high)))return"uint64Data: integer|Long[] expected"}return null},e.fromObject=function(t){if(t instanceof $.onnx.TensorProto)return t;var o=new $.onnx.TensorProto;if(t.dims){if(!Array.isArray(t.dims))throw TypeError(".onnx.TensorProto.dims: array expected");o.dims=[];for(var i=0;i<t.dims.length;++i)A.Long?(o.dims[i]=A.Long.fromValue(t.dims[i])).unsigned=!1:typeof t.dims[i]=="string"?o.dims[i]=parseInt(t.dims[i],10):typeof t.dims[i]=="number"?o.dims[i]=t.dims[i]:typeof t.dims[i]=="object"&&(o.dims[i]=new A.LongBits(t.dims[i].low>>>0,t.dims[i].high>>>0).toNumber())}if(t.dataType!=null&&(o.dataType=t.dataType|0),t.segment!=null){if(typeof t.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");o.segment=$.onnx.TensorProto.Segment.fromObject(t.segment)}if(t.floatData){if(!Array.isArray(t.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");o.floatData=[];for(var i=0;i<t.floatData.length;++i)o.floatData[i]=Number(t.floatData[i])}if(t.int32Data){if(!Array.isArray(t.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");o.int32Data=[];for(var i=0;i<t.int32Data.length;++i)o.int32Data[i]=t.int32Data[i]|0}if(t.stringData){if(!Array.isArray(t.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");o.stringData=[];for(var i=0;i<t.stringData.length;++i)typeof t.stringData[i]=="string"?A.base64.decode(t.stringData[i],o.stringData[i]=A.newBuffer(A.base64.length(t.stringData[i])),0):t.stringData[i].length>=0&&(o.stringData[i]=t.stringData[i])}if(t.int64Data){if(!Array.isArray(t.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");o.int64Data=[];for(var i=0;i<t.int64Data.length;++i)A.Long?(o.int64Data[i]=A.Long.fromValue(t.int64Data[i])).unsigned=!1:typeof t.int64Data[i]=="string"?o.int64Data[i]=parseInt(t.int64Data[i],10):typeof t.int64Data[i]=="number"?o.int64Data[i]=t.int64Data[i]:typeof t.int64Data[i]=="object"&&(o.int64Data[i]=new A.LongBits(t.int64Data[i].low>>>0,t.int64Data[i].high>>>0).toNumber())}if(t.name!=null&&(o.name=String(t.name)),t.docString!=null&&(o.docString=String(t.docString)),t.rawData!=null&&(typeof t.rawData=="string"?A.base64.decode(t.rawData,o.rawData=A.newBuffer(A.base64.length(t.rawData)),0):t.rawData.length>=0&&(o.rawData=t.rawData)),t.externalData){if(!Array.isArray(t.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");o.externalData=[];for(var i=0;i<t.externalData.length;++i){if(typeof t.externalData[i]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");o.externalData[i]=$.onnx.StringStringEntryProto.fromObject(t.externalData[i])}}switch(t.dataLocation){default:if(typeof t.dataLocation=="number"){o.dataLocation=t.dataLocation;break}break;case"DEFAULT":case 0:o.dataLocation=0;break;case"EXTERNAL":case 1:o.dataLocation=1;break}if(t.doubleData){if(!Array.isArray(t.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");o.doubleData=[];for(var i=0;i<t.doubleData.length;++i)o.doubleData[i]=Number(t.doubleData[i])}if(t.uint64Data){if(!Array.isArray(t.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");o.uint64Data=[];for(var i=0;i<t.uint64Data.length;++i)A.Long?(o.uint64Data[i]=A.Long.fromValue(t.uint64Data[i])).unsigned=!0:typeof t.uint64Data[i]=="string"?o.uint64Data[i]=parseInt(t.uint64Data[i],10):typeof t.uint64Data[i]=="number"?o.uint64Data[i]=t.uint64Data[i]:typeof t.uint64Data[i]=="object"&&(o.uint64Data[i]=new A.LongBits(t.uint64Data[i].low>>>0,t.uint64Data[i].high>>>0).toNumber(!0))}return o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.dims=[],i.floatData=[],i.int32Data=[],i.stringData=[],i.int64Data=[],i.doubleData=[],i.uint64Data=[],i.externalData=[]),o.defaults&&(i.dataType=0,i.segment=null,i.name="",o.bytes===String?i.rawData="":(i.rawData=[],o.bytes!==Array&&(i.rawData=A.newBuffer(i.rawData))),i.docString="",i.dataLocation=o.enums===String?"DEFAULT":0),t.dims&&t.dims.length){i.dims=[];for(var u=0;u<t.dims.length;++u)typeof t.dims[u]=="number"?i.dims[u]=o.longs===String?String(t.dims[u]):t.dims[u]:i.dims[u]=o.longs===String?A.Long.prototype.toString.call(t.dims[u]):o.longs===Number?new A.LongBits(t.dims[u].low>>>0,t.dims[u].high>>>0).toNumber():t.dims[u]}if(t.dataType!=null&&t.hasOwnProperty("dataType")&&(i.dataType=t.dataType),t.segment!=null&&t.hasOwnProperty("segment")&&(i.segment=$.onnx.TensorProto.Segment.toObject(t.segment,o)),t.floatData&&t.floatData.length){i.floatData=[];for(var u=0;u<t.floatData.length;++u)i.floatData[u]=o.json&&!isFinite(t.floatData[u])?String(t.floatData[u]):t.floatData[u]}if(t.int32Data&&t.int32Data.length){i.int32Data=[];for(var u=0;u<t.int32Data.length;++u)i.int32Data[u]=t.int32Data[u]}if(t.stringData&&t.stringData.length){i.stringData=[];for(var u=0;u<t.stringData.length;++u)i.stringData[u]=o.bytes===String?A.base64.encode(t.stringData[u],0,t.stringData[u].length):o.bytes===Array?Array.prototype.slice.call(t.stringData[u]):t.stringData[u]}if(t.int64Data&&t.int64Data.length){i.int64Data=[];for(var u=0;u<t.int64Data.length;++u)typeof t.int64Data[u]=="number"?i.int64Data[u]=o.longs===String?String(t.int64Data[u]):t.int64Data[u]:i.int64Data[u]=o.longs===String?A.Long.prototype.toString.call(t.int64Data[u]):o.longs===Number?new A.LongBits(t.int64Data[u].low>>>0,t.int64Data[u].high>>>0).toNumber():t.int64Data[u]}if(t.name!=null&&t.hasOwnProperty("name")&&(i.name=t.name),t.rawData!=null&&t.hasOwnProperty("rawData")&&(i.rawData=o.bytes===String?A.base64.encode(t.rawData,0,t.rawData.length):o.bytes===Array?Array.prototype.slice.call(t.rawData):t.rawData),t.doubleData&&t.doubleData.length){i.doubleData=[];for(var u=0;u<t.doubleData.length;++u)i.doubleData[u]=o.json&&!isFinite(t.doubleData[u])?String(t.doubleData[u]):t.doubleData[u]}if(t.uint64Data&&t.uint64Data.length){i.uint64Data=[];for(var u=0;u<t.uint64Data.length;++u)typeof t.uint64Data[u]=="number"?i.uint64Data[u]=o.longs===String?String(t.uint64Data[u]):t.uint64Data[u]:i.uint64Data[u]=o.longs===String?A.Long.prototype.toString.call(t.uint64Data[u]):o.longs===Number?new A.LongBits(t.uint64Data[u].low>>>0,t.uint64Data[u].high>>>0).toNumber(!0):t.uint64Data[u]}if(t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),t.externalData&&t.externalData.length){i.externalData=[];for(var u=0;u<t.externalData.length;++u)i.externalData[u]=$.onnx.StringStringEntryProto.toObject(t.externalData[u],o)}return t.dataLocation!=null&&t.hasOwnProperty("dataLocation")&&(i.dataLocation=o.enums===String?$.onnx.TensorProto.DataLocation[t.dataLocation]===void 0?t.dataLocation:$.onnx.TensorProto.DataLocation[t.dataLocation]:t.dataLocation),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,Ze.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorProto"},e.DataType=function(){var n={},t=Object.create(n);return t[n[0]="UNDEFINED"]=0,t[n[1]="FLOAT"]=1,t[n[2]="UINT8"]=2,t[n[3]="INT8"]=3,t[n[4]="UINT16"]=4,t[n[5]="INT16"]=5,t[n[6]="INT32"]=6,t[n[7]="INT64"]=7,t[n[8]="STRING"]=8,t[n[9]="BOOL"]=9,t[n[10]="FLOAT16"]=10,t[n[11]="DOUBLE"]=11,t[n[12]="UINT32"]=12,t[n[13]="UINT64"]=13,t[n[14]="COMPLEX64"]=14,t[n[15]="COMPLEX128"]=15,t[n[16]="BFLOAT16"]=16,t[n[17]="FLOAT8E4M3FN"]=17,t[n[18]="FLOAT8E4M3FNUZ"]=18,t[n[19]="FLOAT8E5M2"]=19,t[n[20]="FLOAT8E5M2FNUZ"]=20,t}(),e.Segment=function(){function n(t){if(t)for(var o=Object.keys(t),i=0;i<o.length;++i)t[o[i]]!=null&&(this[o[i]]=t[o[i]])}return n.prototype.begin=A.Long?A.Long.fromBits(0,0,!1):0,n.prototype.end=A.Long?A.Long.fromBits(0,0,!1):0,n.create=function(o){return new n(o)},n.encode=function(o,i){return i||(i=ct.create()),o.begin!=null&&Object.hasOwnProperty.call(o,"begin")&&i.uint32(8).int64(o.begin),o.end!=null&&Object.hasOwnProperty.call(o,"end")&&i.uint32(16).int64(o.end),i},n.encodeDelimited=function(o,i){return this.encode(o,i).ldelim()},n.decode=function(o,i){o instanceof Z||(o=Z.create(o));for(var u=i===void 0?o.len:o.pos+i,a=new $.onnx.TensorProto.Segment;o.pos<u;){var s=o.uint32();switch(s>>>3){case 1:{a.begin=o.int64();break}case 2:{a.end=o.int64();break}default:o.skipType(s&7);break}}return a},n.decodeDelimited=function(o){return o instanceof Z||(o=new Z(o)),this.decode(o,o.uint32())},n.verify=function(o){return typeof o!="object"||o===null?"object expected":o.begin!=null&&o.hasOwnProperty("begin")&&!A.isInteger(o.begin)&&!(o.begin&&A.isInteger(o.begin.low)&&A.isInteger(o.begin.high))?"begin: integer|Long expected":o.end!=null&&o.hasOwnProperty("end")&&!A.isInteger(o.end)&&!(o.end&&A.isInteger(o.end.low)&&A.isInteger(o.end.high))?"end: integer|Long expected":null},n.fromObject=function(o){if(o instanceof $.onnx.TensorProto.Segment)return o;var i=new $.onnx.TensorProto.Segment;return o.begin!=null&&(A.Long?(i.begin=A.Long.fromValue(o.begin)).unsigned=!1:typeof o.begin=="string"?i.begin=parseInt(o.begin,10):typeof o.begin=="number"?i.begin=o.begin:typeof o.begin=="object"&&(i.begin=new A.LongBits(o.begin.low>>>0,o.begin.high>>>0).toNumber())),o.end!=null&&(A.Long?(i.end=A.Long.fromValue(o.end)).unsigned=!1:typeof o.end=="string"?i.end=parseInt(o.end,10):typeof o.end=="number"?i.end=o.end:typeof o.end=="object"&&(i.end=new A.LongBits(o.end.low>>>0,o.end.high>>>0).toNumber())),i},n.toObject=function(o,i){i||(i={});var u={};if(i.defaults){if(A.Long){var a=new A.Long(0,0,!1);u.begin=i.longs===String?a.toString():i.longs===Number?a.toNumber():a}else u.begin=i.longs===String?"0":0;if(A.Long){var a=new A.Long(0,0,!1);u.end=i.longs===String?a.toString():i.longs===Number?a.toNumber():a}else u.end=i.longs===String?"0":0}return o.begin!=null&&o.hasOwnProperty("begin")&&(typeof o.begin=="number"?u.begin=i.longs===String?String(o.begin):o.begin:u.begin=i.longs===String?A.Long.prototype.toString.call(o.begin):i.longs===Number?new A.LongBits(o.begin.low>>>0,o.begin.high>>>0).toNumber():o.begin),o.end!=null&&o.hasOwnProperty("end")&&(typeof o.end=="number"?u.end=i.longs===String?String(o.end):o.end:u.end=i.longs===String?A.Long.prototype.toString.call(o.end):i.longs===Number?new A.LongBits(o.end.low>>>0,o.end.high>>>0).toNumber():o.end),u},n.prototype.toJSON=function(){return this.constructor.toObject(this,Ze.util.toJSONOptions)},n.getTypeUrl=function(o){return o===void 0&&(o="type.googleapis.com"),o+"/onnx.TensorProto.Segment"},n}(),e.DataLocation=function(){var n={},t=Object.create(n);return t[n[0]="DEFAULT"]=0,t[n[1]="EXTERNAL"]=1,t}(),e}(),r.SparseTensorProto=function(){function e(n){if(this.dims=[],n)for(var t=Object.keys(n),o=0;o<t.length;++o)n[t[o]]!=null&&(this[t[o]]=n[t[o]])}return e.prototype.values=null,e.prototype.indices=null,e.prototype.dims=A.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=ct.create()),t.values!=null&&Object.hasOwnProperty.call(t,"values")&&$.onnx.TensorProto.encode(t.values,o.uint32(10).fork()).ldelim(),t.indices!=null&&Object.hasOwnProperty.call(t,"indices")&&$.onnx.TensorProto.encode(t.indices,o.uint32(18).fork()).ldelim(),t.dims!=null&&t.dims.length){o.uint32(26).fork();for(var i=0;i<t.dims.length;++i)o.int64(t.dims[i]);o.ldelim()}return o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof Z||(t=Z.create(t));for(var i=o===void 0?t.len:t.pos+o,u=new $.onnx.SparseTensorProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{u.values=$.onnx.TensorProto.decode(t,t.uint32());break}case 2:{u.indices=$.onnx.TensorProto.decode(t,t.uint32());break}case 3:{if(u.dims&&u.dims.length||(u.dims=[]),(a&7)===2)for(var s=t.uint32()+t.pos;t.pos<s;)u.dims.push(t.int64());else u.dims.push(t.int64());break}default:t.skipType(a&7);break}}return u},e.decodeDelimited=function(t){return t instanceof Z||(t=new Z(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.values!=null&&t.hasOwnProperty("values")){var o=$.onnx.TensorProto.verify(t.values);if(o)return"values."+o}if(t.indices!=null&&t.hasOwnProperty("indices")){var o=$.onnx.TensorProto.verify(t.indices);if(o)return"indices."+o}if(t.dims!=null&&t.hasOwnProperty("dims")){if(!Array.isArray(t.dims))return"dims: array expected";for(var i=0;i<t.dims.length;++i)if(!A.isInteger(t.dims[i])&&!(t.dims[i]&&A.isInteger(t.dims[i].low)&&A.isInteger(t.dims[i].high)))return"dims: integer|Long[] expected"}return null},e.fromObject=function(t){if(t instanceof $.onnx.SparseTensorProto)return t;var o=new $.onnx.SparseTensorProto;if(t.values!=null){if(typeof t.values!="object")throw TypeError(".onnx.SparseTensorProto.values: object expected");o.values=$.onnx.TensorProto.fromObject(t.values)}if(t.indices!=null){if(typeof t.indices!="object")throw TypeError(".onnx.SparseTensorProto.indices: object expected");o.indices=$.onnx.TensorProto.fromObject(t.indices)}if(t.dims){if(!Array.isArray(t.dims))throw TypeError(".onnx.SparseTensorProto.dims: array expected");o.dims=[];for(var i=0;i<t.dims.length;++i)A.Long?(o.dims[i]=A.Long.fromValue(t.dims[i])).unsigned=!1:typeof t.dims[i]=="string"?o.dims[i]=parseInt(t.dims[i],10):typeof t.dims[i]=="number"?o.dims[i]=t.dims[i]:typeof t.dims[i]=="object"&&(o.dims[i]=new A.LongBits(t.dims[i].low>>>0,t.dims[i].high>>>0).toNumber())}return o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.dims=[]),o.defaults&&(i.values=null,i.indices=null),t.values!=null&&t.hasOwnProperty("values")&&(i.values=$.onnx.TensorProto.toObject(t.values,o)),t.indices!=null&&t.hasOwnProperty("indices")&&(i.indices=$.onnx.TensorProto.toObject(t.indices,o)),t.dims&&t.dims.length){i.dims=[];for(var u=0;u<t.dims.length;++u)typeof t.dims[u]=="number"?i.dims[u]=o.longs===String?String(t.dims[u]):t.dims[u]:i.dims[u]=o.longs===String?A.Long.prototype.toString.call(t.dims[u]):o.longs===Number?new A.LongBits(t.dims[u].low>>>0,t.dims[u].high>>>0).toNumber():t.dims[u]}return i},e.prototype.toJSON=function(){return this.constructor.toObject(this,Ze.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.SparseTensorProto"},e}(),r.TensorShapeProto=function(){function e(n){if(this.dim=[],n)for(var t=Object.keys(n),o=0;o<t.length;++o)n[t[o]]!=null&&(this[t[o]]=n[t[o]])}return e.prototype.dim=A.emptyArray,e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=ct.create()),t.dim!=null&&t.dim.length)for(var i=0;i<t.dim.length;++i)$.onnx.TensorShapeProto.Dimension.encode(t.dim[i],o.uint32(10).fork()).ldelim();return o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof Z||(t=Z.create(t));for(var i=o===void 0?t.len:t.pos+o,u=new $.onnx.TensorShapeProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{u.dim&&u.dim.length||(u.dim=[]),u.dim.push($.onnx.TensorShapeProto.Dimension.decode(t,t.uint32()));break}default:t.skipType(a&7);break}}return u},e.decodeDelimited=function(t){return t instanceof Z||(t=new Z(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.dim!=null&&t.hasOwnProperty("dim")){if(!Array.isArray(t.dim))return"dim: array expected";for(var o=0;o<t.dim.length;++o){var i=$.onnx.TensorShapeProto.Dimension.verify(t.dim[o]);if(i)return"dim."+i}}return null},e.fromObject=function(t){if(t instanceof $.onnx.TensorShapeProto)return t;var o=new $.onnx.TensorShapeProto;if(t.dim){if(!Array.isArray(t.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");o.dim=[];for(var i=0;i<t.dim.length;++i){if(typeof t.dim[i]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");o.dim[i]=$.onnx.TensorShapeProto.Dimension.fromObject(t.dim[i])}}return o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.dim=[]),t.dim&&t.dim.length){i.dim=[];for(var u=0;u<t.dim.length;++u)i.dim[u]=$.onnx.TensorShapeProto.Dimension.toObject(t.dim[u],o)}return i},e.prototype.toJSON=function(){return this.constructor.toObject(this,Ze.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.TensorShapeProto"},e.Dimension=function(){function n(o){if(o)for(var i=Object.keys(o),u=0;u<i.length;++u)o[i[u]]!=null&&(this[i[u]]=o[i[u]])}n.prototype.dimValue=null,n.prototype.dimParam=null,n.prototype.denotation="";var t;return Object.defineProperty(n.prototype,"value",{get:A.oneOfGetter(t=["dimValue","dimParam"]),set:A.oneOfSetter(t)}),n.create=function(i){return new n(i)},n.encode=function(i,u){return u||(u=ct.create()),i.dimValue!=null&&Object.hasOwnProperty.call(i,"dimValue")&&u.uint32(8).int64(i.dimValue),i.dimParam!=null&&Object.hasOwnProperty.call(i,"dimParam")&&u.uint32(18).string(i.dimParam),i.denotation!=null&&Object.hasOwnProperty.call(i,"denotation")&&u.uint32(26).string(i.denotation),u},n.encodeDelimited=function(i,u){return this.encode(i,u).ldelim()},n.decode=function(i,u){i instanceof Z||(i=Z.create(i));for(var a=u===void 0?i.len:i.pos+u,s=new $.onnx.TensorShapeProto.Dimension;i.pos<a;){var l=i.uint32();switch(l>>>3){case 1:{s.dimValue=i.int64();break}case 2:{s.dimParam=i.string();break}case 3:{s.denotation=i.string();break}default:i.skipType(l&7);break}}return s},n.decodeDelimited=function(i){return i instanceof Z||(i=new Z(i)),this.decode(i,i.uint32())},n.verify=function(i){if(typeof i!="object"||i===null)return"object expected";var u={};if(i.dimValue!=null&&i.hasOwnProperty("dimValue")&&(u.value=1,!A.isInteger(i.dimValue)&&!(i.dimValue&&A.isInteger(i.dimValue.low)&&A.isInteger(i.dimValue.high))))return"dimValue: integer|Long expected";if(i.dimParam!=null&&i.hasOwnProperty("dimParam")){if(u.value===1)return"value: multiple values";if(u.value=1,!A.isString(i.dimParam))return"dimParam: string expected"}return i.denotation!=null&&i.hasOwnProperty("denotation")&&!A.isString(i.denotation)?"denotation: string expected":null},n.fromObject=function(i){if(i instanceof $.onnx.TensorShapeProto.Dimension)return i;var u=new $.onnx.TensorShapeProto.Dimension;return i.dimValue!=null&&(A.Long?(u.dimValue=A.Long.fromValue(i.dimValue)).unsigned=!1:typeof i.dimValue=="string"?u.dimValue=parseInt(i.dimValue,10):typeof i.dimValue=="number"?u.dimValue=i.dimValue:typeof i.dimValue=="object"&&(u.dimValue=new A.LongBits(i.dimValue.low>>>0,i.dimValue.high>>>0).toNumber())),i.dimParam!=null&&(u.dimParam=String(i.dimParam)),i.denotation!=null&&(u.denotation=String(i.denotation)),u},n.toObject=function(i,u){u||(u={});var a={};return u.defaults&&(a.denotation=""),i.dimValue!=null&&i.hasOwnProperty("dimValue")&&(typeof i.dimValue=="number"?a.dimValue=u.longs===String?String(i.dimValue):i.dimValue:a.dimValue=u.longs===String?A.Long.prototype.toString.call(i.dimValue):u.longs===Number?new A.LongBits(i.dimValue.low>>>0,i.dimValue.high>>>0).toNumber():i.dimValue,u.oneofs&&(a.value="dimValue")),i.dimParam!=null&&i.hasOwnProperty("dimParam")&&(a.dimParam=i.dimParam,u.oneofs&&(a.value="dimParam")),i.denotation!=null&&i.hasOwnProperty("denotation")&&(a.denotation=i.denotation),a},n.prototype.toJSON=function(){return this.constructor.toObject(this,Ze.util.toJSONOptions)},n.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TensorShapeProto.Dimension"},n}(),e}(),r.TypeProto=function(){function e(t){if(t)for(var o=Object.keys(t),i=0;i<o.length;++i)t[o[i]]!=null&&(this[o[i]]=t[o[i]])}e.prototype.tensorType=null,e.prototype.sequenceType=null,e.prototype.mapType=null,e.prototype.optionalType=null,e.prototype.sparseTensorType=null,e.prototype.denotation="";var n;return Object.defineProperty(e.prototype,"value",{get:A.oneOfGetter(n=["tensorType","sequenceType","mapType","optionalType","sparseTensorType"]),set:A.oneOfSetter(n)}),e.create=function(o){return new e(o)},e.encode=function(o,i){return i||(i=ct.create()),o.tensorType!=null&&Object.hasOwnProperty.call(o,"tensorType")&&$.onnx.TypeProto.Tensor.encode(o.tensorType,i.uint32(10).fork()).ldelim(),o.sequenceType!=null&&Object.hasOwnProperty.call(o,"sequenceType")&&$.onnx.TypeProto.Sequence.encode(o.sequenceType,i.uint32(34).fork()).ldelim(),o.mapType!=null&&Object.hasOwnProperty.call(o,"mapType")&&$.onnx.TypeProto.Map.encode(o.mapType,i.uint32(42).fork()).ldelim(),o.denotation!=null&&Object.hasOwnProperty.call(o,"denotation")&&i.uint32(50).string(o.denotation),o.sparseTensorType!=null&&Object.hasOwnProperty.call(o,"sparseTensorType")&&$.onnx.TypeProto.SparseTensor.encode(o.sparseTensorType,i.uint32(66).fork()).ldelim(),o.optionalType!=null&&Object.hasOwnProperty.call(o,"optionalType")&&$.onnx.TypeProto.Optional.encode(o.optionalType,i.uint32(74).fork()).ldelim(),i},e.encodeDelimited=function(o,i){return this.encode(o,i).ldelim()},e.decode=function(o,i){o instanceof Z||(o=Z.create(o));for(var u=i===void 0?o.len:o.pos+i,a=new $.onnx.TypeProto;o.pos<u;){var s=o.uint32();switch(s>>>3){case 1:{a.tensorType=$.onnx.TypeProto.Tensor.decode(o,o.uint32());break}case 4:{a.sequenceType=$.onnx.TypeProto.Sequence.decode(o,o.uint32());break}case 5:{a.mapType=$.onnx.TypeProto.Map.decode(o,o.uint32());break}case 9:{a.optionalType=$.onnx.TypeProto.Optional.decode(o,o.uint32());break}case 8:{a.sparseTensorType=$.onnx.TypeProto.SparseTensor.decode(o,o.uint32());break}case 6:{a.denotation=o.string();break}default:o.skipType(s&7);break}}return a},e.decodeDelimited=function(o){return o instanceof Z||(o=new Z(o)),this.decode(o,o.uint32())},e.verify=function(o){if(typeof o!="object"||o===null)return"object expected";var i={};if(o.tensorType!=null&&o.hasOwnProperty("tensorType")){i.value=1;{var u=$.onnx.TypeProto.Tensor.verify(o.tensorType);if(u)return"tensorType."+u}}if(o.sequenceType!=null&&o.hasOwnProperty("sequenceType")){if(i.value===1)return"value: multiple values";i.value=1;{var u=$.onnx.TypeProto.Sequence.verify(o.sequenceType);if(u)return"sequenceType."+u}}if(o.mapType!=null&&o.hasOwnProperty("mapType")){if(i.value===1)return"value: multiple values";i.value=1;{var u=$.onnx.TypeProto.Map.verify(o.mapType);if(u)return"mapType."+u}}if(o.optionalType!=null&&o.hasOwnProperty("optionalType")){if(i.value===1)return"value: multiple values";i.value=1;{var u=$.onnx.TypeProto.Optional.verify(o.optionalType);if(u)return"optionalType."+u}}if(o.sparseTensorType!=null&&o.hasOwnProperty("sparseTensorType")){if(i.value===1)return"value: multiple values";i.value=1;{var u=$.onnx.TypeProto.SparseTensor.verify(o.sparseTensorType);if(u)return"sparseTensorType."+u}}return o.denotation!=null&&o.hasOwnProperty("denotation")&&!A.isString(o.denotation)?"denotation: string expected":null},e.fromObject=function(o){if(o instanceof $.onnx.TypeProto)return o;var i=new $.onnx.TypeProto;if(o.tensorType!=null){if(typeof o.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");i.tensorType=$.onnx.TypeProto.Tensor.fromObject(o.tensorType)}if(o.sequenceType!=null){if(typeof o.sequenceType!="object")throw TypeError(".onnx.TypeProto.sequenceType: object expected");i.sequenceType=$.onnx.TypeProto.Sequence.fromObject(o.sequenceType)}if(o.mapType!=null){if(typeof o.mapType!="object")throw TypeError(".onnx.TypeProto.mapType: object expected");i.mapType=$.onnx.TypeProto.Map.fromObject(o.mapType)}if(o.optionalType!=null){if(typeof o.optionalType!="object")throw TypeError(".onnx.TypeProto.optionalType: object expected");i.optionalType=$.onnx.TypeProto.Optional.fromObject(o.optionalType)}if(o.sparseTensorType!=null){if(typeof o.sparseTensorType!="object")throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");i.sparseTensorType=$.onnx.TypeProto.SparseTensor.fromObject(o.sparseTensorType)}return o.denotation!=null&&(i.denotation=String(o.denotation)),i},e.toObject=function(o,i){i||(i={});var u={};return i.defaults&&(u.denotation=""),o.tensorType!=null&&o.hasOwnProperty("tensorType")&&(u.tensorType=$.onnx.TypeProto.Tensor.toObject(o.tensorType,i),i.oneofs&&(u.value="tensorType")),o.sequenceType!=null&&o.hasOwnProperty("sequenceType")&&(u.sequenceType=$.onnx.TypeProto.Sequence.toObject(o.sequenceType,i),i.oneofs&&(u.value="sequenceType")),o.mapType!=null&&o.hasOwnProperty("mapType")&&(u.mapType=$.onnx.TypeProto.Map.toObject(o.mapType,i),i.oneofs&&(u.value="mapType")),o.denotation!=null&&o.hasOwnProperty("denotation")&&(u.denotation=o.denotation),o.sparseTensorType!=null&&o.hasOwnProperty("sparseTensorType")&&(u.sparseTensorType=$.onnx.TypeProto.SparseTensor.toObject(o.sparseTensorType,i),i.oneofs&&(u.value="sparseTensorType")),o.optionalType!=null&&o.hasOwnProperty("optionalType")&&(u.optionalType=$.onnx.TypeProto.Optional.toObject(o.optionalType,i),i.oneofs&&(u.value="optionalType")),u},e.prototype.toJSON=function(){return this.constructor.toObject(this,Ze.util.toJSONOptions)},e.getTypeUrl=function(o){return o===void 0&&(o="type.googleapis.com"),o+"/onnx.TypeProto"},e.Tensor=function(){function t(o){if(o)for(var i=Object.keys(o),u=0;u<i.length;++u)o[i[u]]!=null&&(this[i[u]]=o[i[u]])}return t.prototype.elemType=0,t.prototype.shape=null,t.create=function(i){return new t(i)},t.encode=function(i,u){return u||(u=ct.create()),i.elemType!=null&&Object.hasOwnProperty.call(i,"elemType")&&u.uint32(8).int32(i.elemType),i.shape!=null&&Object.hasOwnProperty.call(i,"shape")&&$.onnx.TensorShapeProto.encode(i.shape,u.uint32(18).fork()).ldelim(),u},t.encodeDelimited=function(i,u){return this.encode(i,u).ldelim()},t.decode=function(i,u){i instanceof Z||(i=Z.create(i));for(var a=u===void 0?i.len:i.pos+u,s=new $.onnx.TypeProto.Tensor;i.pos<a;){var l=i.uint32();switch(l>>>3){case 1:{s.elemType=i.int32();break}case 2:{s.shape=$.onnx.TensorShapeProto.decode(i,i.uint32());break}default:i.skipType(l&7);break}}return s},t.decodeDelimited=function(i){return i instanceof Z||(i=new Z(i)),this.decode(i,i.uint32())},t.verify=function(i){if(typeof i!="object"||i===null)return"object expected";if(i.elemType!=null&&i.hasOwnProperty("elemType")&&!A.isInteger(i.elemType))return"elemType: integer expected";if(i.shape!=null&&i.hasOwnProperty("shape")){var u=$.onnx.TensorShapeProto.verify(i.shape);if(u)return"shape."+u}return null},t.fromObject=function(i){if(i instanceof $.onnx.TypeProto.Tensor)return i;var u=new $.onnx.TypeProto.Tensor;if(i.elemType!=null&&(u.elemType=i.elemType|0),i.shape!=null){if(typeof i.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");u.shape=$.onnx.TensorShapeProto.fromObject(i.shape)}return u},t.toObject=function(i,u){u||(u={});var a={};return u.defaults&&(a.elemType=0,a.shape=null),i.elemType!=null&&i.hasOwnProperty("elemType")&&(a.elemType=i.elemType),i.shape!=null&&i.hasOwnProperty("shape")&&(a.shape=$.onnx.TensorShapeProto.toObject(i.shape,u)),a},t.prototype.toJSON=function(){return this.constructor.toObject(this,Ze.util.toJSONOptions)},t.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TypeProto.Tensor"},t}(),e.Sequence=function(){function t(o){if(o)for(var i=Object.keys(o),u=0;u<i.length;++u)o[i[u]]!=null&&(this[i[u]]=o[i[u]])}return t.prototype.elemType=null,t.create=function(i){return new t(i)},t.encode=function(i,u){return u||(u=ct.create()),i.elemType!=null&&Object.hasOwnProperty.call(i,"elemType")&&$.onnx.TypeProto.encode(i.elemType,u.uint32(10).fork()).ldelim(),u},t.encodeDelimited=function(i,u){return this.encode(i,u).ldelim()},t.decode=function(i,u){i instanceof Z||(i=Z.create(i));for(var a=u===void 0?i.len:i.pos+u,s=new $.onnx.TypeProto.Sequence;i.pos<a;){var l=i.uint32();switch(l>>>3){case 1:{s.elemType=$.onnx.TypeProto.decode(i,i.uint32());break}default:i.skipType(l&7);break}}return s},t.decodeDelimited=function(i){return i instanceof Z||(i=new Z(i)),this.decode(i,i.uint32())},t.verify=function(i){if(typeof i!="object"||i===null)return"object expected";if(i.elemType!=null&&i.hasOwnProperty("elemType")){var u=$.onnx.TypeProto.verify(i.elemType);if(u)return"elemType."+u}return null},t.fromObject=function(i){if(i instanceof $.onnx.TypeProto.Sequence)return i;var u=new $.onnx.TypeProto.Sequence;if(i.elemType!=null){if(typeof i.elemType!="object")throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");u.elemType=$.onnx.TypeProto.fromObject(i.elemType)}return u},t.toObject=function(i,u){u||(u={});var a={};return u.defaults&&(a.elemType=null),i.elemType!=null&&i.hasOwnProperty("elemType")&&(a.elemType=$.onnx.TypeProto.toObject(i.elemType,u)),a},t.prototype.toJSON=function(){return this.constructor.toObject(this,Ze.util.toJSONOptions)},t.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TypeProto.Sequence"},t}(),e.Map=function(){function t(o){if(o)for(var i=Object.keys(o),u=0;u<i.length;++u)o[i[u]]!=null&&(this[i[u]]=o[i[u]])}return t.prototype.keyType=0,t.prototype.valueType=null,t.create=function(i){return new t(i)},t.encode=function(i,u){return u||(u=ct.create()),i.keyType!=null&&Object.hasOwnProperty.call(i,"keyType")&&u.uint32(8).int32(i.keyType),i.valueType!=null&&Object.hasOwnProperty.call(i,"valueType")&&$.onnx.TypeProto.encode(i.valueType,u.uint32(18).fork()).ldelim(),u},t.encodeDelimited=function(i,u){return this.encode(i,u).ldelim()},t.decode=function(i,u){i instanceof Z||(i=Z.create(i));for(var a=u===void 0?i.len:i.pos+u,s=new $.onnx.TypeProto.Map;i.pos<a;){var l=i.uint32();switch(l>>>3){case 1:{s.keyType=i.int32();break}case 2:{s.valueType=$.onnx.TypeProto.decode(i,i.uint32());break}default:i.skipType(l&7);break}}return s},t.decodeDelimited=function(i){return i instanceof Z||(i=new Z(i)),this.decode(i,i.uint32())},t.verify=function(i){if(typeof i!="object"||i===null)return"object expected";if(i.keyType!=null&&i.hasOwnProperty("keyType")&&!A.isInteger(i.keyType))return"keyType: integer expected";if(i.valueType!=null&&i.hasOwnProperty("valueType")){var u=$.onnx.TypeProto.verify(i.valueType);if(u)return"valueType."+u}return null},t.fromObject=function(i){if(i instanceof $.onnx.TypeProto.Map)return i;var u=new $.onnx.TypeProto.Map;if(i.keyType!=null&&(u.keyType=i.keyType|0),i.valueType!=null){if(typeof i.valueType!="object")throw TypeError(".onnx.TypeProto.Map.valueType: object expected");u.valueType=$.onnx.TypeProto.fromObject(i.valueType)}return u},t.toObject=function(i,u){u||(u={});var a={};return u.defaults&&(a.keyType=0,a.valueType=null),i.keyType!=null&&i.hasOwnProperty("keyType")&&(a.keyType=i.keyType),i.valueType!=null&&i.hasOwnProperty("valueType")&&(a.valueType=$.onnx.TypeProto.toObject(i.valueType,u)),a},t.prototype.toJSON=function(){return this.constructor.toObject(this,Ze.util.toJSONOptions)},t.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TypeProto.Map"},t}(),e.Optional=function(){function t(o){if(o)for(var i=Object.keys(o),u=0;u<i.length;++u)o[i[u]]!=null&&(this[i[u]]=o[i[u]])}return t.prototype.elemType=null,t.create=function(i){return new t(i)},t.encode=function(i,u){return u||(u=ct.create()),i.elemType!=null&&Object.hasOwnProperty.call(i,"elemType")&&$.onnx.TypeProto.encode(i.elemType,u.uint32(10).fork()).ldelim(),u},t.encodeDelimited=function(i,u){return this.encode(i,u).ldelim()},t.decode=function(i,u){i instanceof Z||(i=Z.create(i));for(var a=u===void 0?i.len:i.pos+u,s=new $.onnx.TypeProto.Optional;i.pos<a;){var l=i.uint32();switch(l>>>3){case 1:{s.elemType=$.onnx.TypeProto.decode(i,i.uint32());break}default:i.skipType(l&7);break}}return s},t.decodeDelimited=function(i){return i instanceof Z||(i=new Z(i)),this.decode(i,i.uint32())},t.verify=function(i){if(typeof i!="object"||i===null)return"object expected";if(i.elemType!=null&&i.hasOwnProperty("elemType")){var u=$.onnx.TypeProto.verify(i.elemType);if(u)return"elemType."+u}return null},t.fromObject=function(i){if(i instanceof $.onnx.TypeProto.Optional)return i;var u=new $.onnx.TypeProto.Optional;if(i.elemType!=null){if(typeof i.elemType!="object")throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");u.elemType=$.onnx.TypeProto.fromObject(i.elemType)}return u},t.toObject=function(i,u){u||(u={});var a={};return u.defaults&&(a.elemType=null),i.elemType!=null&&i.hasOwnProperty("elemType")&&(a.elemType=$.onnx.TypeProto.toObject(i.elemType,u)),a},t.prototype.toJSON=function(){return this.constructor.toObject(this,Ze.util.toJSONOptions)},t.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TypeProto.Optional"},t}(),e.SparseTensor=function(){function t(o){if(o)for(var i=Object.keys(o),u=0;u<i.length;++u)o[i[u]]!=null&&(this[i[u]]=o[i[u]])}return t.prototype.elemType=0,t.prototype.shape=null,t.create=function(i){return new t(i)},t.encode=function(i,u){return u||(u=ct.create()),i.elemType!=null&&Object.hasOwnProperty.call(i,"elemType")&&u.uint32(8).int32(i.elemType),i.shape!=null&&Object.hasOwnProperty.call(i,"shape")&&$.onnx.TensorShapeProto.encode(i.shape,u.uint32(18).fork()).ldelim(),u},t.encodeDelimited=function(i,u){return this.encode(i,u).ldelim()},t.decode=function(i,u){i instanceof Z||(i=Z.create(i));for(var a=u===void 0?i.len:i.pos+u,s=new $.onnx.TypeProto.SparseTensor;i.pos<a;){var l=i.uint32();switch(l>>>3){case 1:{s.elemType=i.int32();break}case 2:{s.shape=$.onnx.TensorShapeProto.decode(i,i.uint32());break}default:i.skipType(l&7);break}}return s},t.decodeDelimited=function(i){return i instanceof Z||(i=new Z(i)),this.decode(i,i.uint32())},t.verify=function(i){if(typeof i!="object"||i===null)return"object expected";if(i.elemType!=null&&i.hasOwnProperty("elemType")&&!A.isInteger(i.elemType))return"elemType: integer expected";if(i.shape!=null&&i.hasOwnProperty("shape")){var u=$.onnx.TensorShapeProto.verify(i.shape);if(u)return"shape."+u}return null},t.fromObject=function(i){if(i instanceof $.onnx.TypeProto.SparseTensor)return i;var u=new $.onnx.TypeProto.SparseTensor;if(i.elemType!=null&&(u.elemType=i.elemType|0),i.shape!=null){if(typeof i.shape!="object")throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");u.shape=$.onnx.TensorShapeProto.fromObject(i.shape)}return u},t.toObject=function(i,u){u||(u={});var a={};return u.defaults&&(a.elemType=0,a.shape=null),i.elemType!=null&&i.hasOwnProperty("elemType")&&(a.elemType=i.elemType),i.shape!=null&&i.hasOwnProperty("shape")&&(a.shape=$.onnx.TensorShapeProto.toObject(i.shape,u)),a},t.prototype.toJSON=function(){return this.constructor.toObject(this,Ze.util.toJSONOptions)},t.getTypeUrl=function(i){return i===void 0&&(i="type.googleapis.com"),i+"/onnx.TypeProto.SparseTensor"},t}(),e}(),r.OperatorSetIdProto=function(){function e(n){if(n)for(var t=Object.keys(n),o=0;o<t.length;++o)n[t[o]]!=null&&(this[t[o]]=n[t[o]])}return e.prototype.domain="",e.prototype.version=A.Long?A.Long.fromBits(0,0,!1):0,e.create=function(t){return new e(t)},e.encode=function(t,o){return o||(o=ct.create()),t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&o.uint32(10).string(t.domain),t.version!=null&&Object.hasOwnProperty.call(t,"version")&&o.uint32(16).int64(t.version),o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof Z||(t=Z.create(t));for(var i=o===void 0?t.len:t.pos+o,u=new $.onnx.OperatorSetIdProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{u.domain=t.string();break}case 2:{u.version=t.int64();break}default:t.skipType(a&7);break}}return u},e.decodeDelimited=function(t){return t instanceof Z||(t=new Z(t)),this.decode(t,t.uint32())},e.verify=function(t){return typeof t!="object"||t===null?"object expected":t.domain!=null&&t.hasOwnProperty("domain")&&!A.isString(t.domain)?"domain: string expected":t.version!=null&&t.hasOwnProperty("version")&&!A.isInteger(t.version)&&!(t.version&&A.isInteger(t.version.low)&&A.isInteger(t.version.high))?"version: integer|Long expected":null},e.fromObject=function(t){if(t instanceof $.onnx.OperatorSetIdProto)return t;var o=new $.onnx.OperatorSetIdProto;return t.domain!=null&&(o.domain=String(t.domain)),t.version!=null&&(A.Long?(o.version=A.Long.fromValue(t.version)).unsigned=!1:typeof t.version=="string"?o.version=parseInt(t.version,10):typeof t.version=="number"?o.version=t.version:typeof t.version=="object"&&(o.version=new A.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber())),o},e.toObject=function(t,o){o||(o={});var i={};if(o.defaults)if(i.domain="",A.Long){var u=new A.Long(0,0,!1);i.version=o.longs===String?u.toString():o.longs===Number?u.toNumber():u}else i.version=o.longs===String?"0":0;return t.domain!=null&&t.hasOwnProperty("domain")&&(i.domain=t.domain),t.version!=null&&t.hasOwnProperty("version")&&(typeof t.version=="number"?i.version=o.longs===String?String(t.version):t.version:i.version=o.longs===String?A.Long.prototype.toString.call(t.version):o.longs===Number?new A.LongBits(t.version.low>>>0,t.version.high>>>0).toNumber():t.version),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,Ze.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.OperatorSetIdProto"},e}(),r.OperatorStatus=function(){var e={},n=Object.create(e);return n[e[0]="EXPERIMENTAL"]=0,n[e[1]="STABLE"]=1,n}(),r.FunctionProto=function(){function e(n){if(this.input=[],this.output=[],this.attribute=[],this.attributeProto=[],this.node=[],this.opsetImport=[],n)for(var t=Object.keys(n),o=0;o<t.length;++o)n[t[o]]!=null&&(this[t[o]]=n[t[o]])}return e.prototype.name="",e.prototype.input=A.emptyArray,e.prototype.output=A.emptyArray,e.prototype.attribute=A.emptyArray,e.prototype.attributeProto=A.emptyArray,e.prototype.node=A.emptyArray,e.prototype.docString="",e.prototype.opsetImport=A.emptyArray,e.prototype.domain="",e.create=function(t){return new e(t)},e.encode=function(t,o){if(o||(o=ct.create()),t.name!=null&&Object.hasOwnProperty.call(t,"name")&&o.uint32(10).string(t.name),t.input!=null&&t.input.length)for(var i=0;i<t.input.length;++i)o.uint32(34).string(t.input[i]);if(t.output!=null&&t.output.length)for(var i=0;i<t.output.length;++i)o.uint32(42).string(t.output[i]);if(t.attribute!=null&&t.attribute.length)for(var i=0;i<t.attribute.length;++i)o.uint32(50).string(t.attribute[i]);if(t.node!=null&&t.node.length)for(var i=0;i<t.node.length;++i)$.onnx.NodeProto.encode(t.node[i],o.uint32(58).fork()).ldelim();if(t.docString!=null&&Object.hasOwnProperty.call(t,"docString")&&o.uint32(66).string(t.docString),t.opsetImport!=null&&t.opsetImport.length)for(var i=0;i<t.opsetImport.length;++i)$.onnx.OperatorSetIdProto.encode(t.opsetImport[i],o.uint32(74).fork()).ldelim();if(t.domain!=null&&Object.hasOwnProperty.call(t,"domain")&&o.uint32(82).string(t.domain),t.attributeProto!=null&&t.attributeProto.length)for(var i=0;i<t.attributeProto.length;++i)$.onnx.AttributeProto.encode(t.attributeProto[i],o.uint32(90).fork()).ldelim();return o},e.encodeDelimited=function(t,o){return this.encode(t,o).ldelim()},e.decode=function(t,o){t instanceof Z||(t=Z.create(t));for(var i=o===void 0?t.len:t.pos+o,u=new $.onnx.FunctionProto;t.pos<i;){var a=t.uint32();switch(a>>>3){case 1:{u.name=t.string();break}case 4:{u.input&&u.input.length||(u.input=[]),u.input.push(t.string());break}case 5:{u.output&&u.output.length||(u.output=[]),u.output.push(t.string());break}case 6:{u.attribute&&u.attribute.length||(u.attribute=[]),u.attribute.push(t.string());break}case 11:{u.attributeProto&&u.attributeProto.length||(u.attributeProto=[]),u.attributeProto.push($.onnx.AttributeProto.decode(t,t.uint32()));break}case 7:{u.node&&u.node.length||(u.node=[]),u.node.push($.onnx.NodeProto.decode(t,t.uint32()));break}case 8:{u.docString=t.string();break}case 9:{u.opsetImport&&u.opsetImport.length||(u.opsetImport=[]),u.opsetImport.push($.onnx.OperatorSetIdProto.decode(t,t.uint32()));break}case 10:{u.domain=t.string();break}default:t.skipType(a&7);break}}return u},e.decodeDelimited=function(t){return t instanceof Z||(t=new Z(t)),this.decode(t,t.uint32())},e.verify=function(t){if(typeof t!="object"||t===null)return"object expected";if(t.name!=null&&t.hasOwnProperty("name")&&!A.isString(t.name))return"name: string expected";if(t.input!=null&&t.hasOwnProperty("input")){if(!Array.isArray(t.input))return"input: array expected";for(var o=0;o<t.input.length;++o)if(!A.isString(t.input[o]))return"input: string[] expected"}if(t.output!=null&&t.hasOwnProperty("output")){if(!Array.isArray(t.output))return"output: array expected";for(var o=0;o<t.output.length;++o)if(!A.isString(t.output[o]))return"output: string[] expected"}if(t.attribute!=null&&t.hasOwnProperty("attribute")){if(!Array.isArray(t.attribute))return"attribute: array expected";for(var o=0;o<t.attribute.length;++o)if(!A.isString(t.attribute[o]))return"attribute: string[] expected"}if(t.attributeProto!=null&&t.hasOwnProperty("attributeProto")){if(!Array.isArray(t.attributeProto))return"attributeProto: array expected";for(var o=0;o<t.attributeProto.length;++o){var i=$.onnx.AttributeProto.verify(t.attributeProto[o]);if(i)return"attributeProto."+i}}if(t.node!=null&&t.hasOwnProperty("node")){if(!Array.isArray(t.node))return"node: array expected";for(var o=0;o<t.node.length;++o){var i=$.onnx.NodeProto.verify(t.node[o]);if(i)return"node."+i}}if(t.docString!=null&&t.hasOwnProperty("docString")&&!A.isString(t.docString))return"docString: string expected";if(t.opsetImport!=null&&t.hasOwnProperty("opsetImport")){if(!Array.isArray(t.opsetImport))return"opsetImport: array expected";for(var o=0;o<t.opsetImport.length;++o){var i=$.onnx.OperatorSetIdProto.verify(t.opsetImport[o]);if(i)return"opsetImport."+i}}return t.domain!=null&&t.hasOwnProperty("domain")&&!A.isString(t.domain)?"domain: string expected":null},e.fromObject=function(t){if(t instanceof $.onnx.FunctionProto)return t;var o=new $.onnx.FunctionProto;if(t.name!=null&&(o.name=String(t.name)),t.input){if(!Array.isArray(t.input))throw TypeError(".onnx.FunctionProto.input: array expected");o.input=[];for(var i=0;i<t.input.length;++i)o.input[i]=String(t.input[i])}if(t.output){if(!Array.isArray(t.output))throw TypeError(".onnx.FunctionProto.output: array expected");o.output=[];for(var i=0;i<t.output.length;++i)o.output[i]=String(t.output[i])}if(t.attribute){if(!Array.isArray(t.attribute))throw TypeError(".onnx.FunctionProto.attribute: array expected");o.attribute=[];for(var i=0;i<t.attribute.length;++i)o.attribute[i]=String(t.attribute[i])}if(t.attributeProto){if(!Array.isArray(t.attributeProto))throw TypeError(".onnx.FunctionProto.attributeProto: array expected");o.attributeProto=[];for(var i=0;i<t.attributeProto.length;++i){if(typeof t.attributeProto[i]!="object")throw TypeError(".onnx.FunctionProto.attributeProto: object expected");o.attributeProto[i]=$.onnx.AttributeProto.fromObject(t.attributeProto[i])}}if(t.node){if(!Array.isArray(t.node))throw TypeError(".onnx.FunctionProto.node: array expected");o.node=[];for(var i=0;i<t.node.length;++i){if(typeof t.node[i]!="object")throw TypeError(".onnx.FunctionProto.node: object expected");o.node[i]=$.onnx.NodeProto.fromObject(t.node[i])}}if(t.docString!=null&&(o.docString=String(t.docString)),t.opsetImport){if(!Array.isArray(t.opsetImport))throw TypeError(".onnx.FunctionProto.opsetImport: array expected");o.opsetImport=[];for(var i=0;i<t.opsetImport.length;++i){if(typeof t.opsetImport[i]!="object")throw TypeError(".onnx.FunctionProto.opsetImport: object expected");o.opsetImport[i]=$.onnx.OperatorSetIdProto.fromObject(t.opsetImport[i])}}return t.domain!=null&&(o.domain=String(t.domain)),o},e.toObject=function(t,o){o||(o={});var i={};if((o.arrays||o.defaults)&&(i.input=[],i.output=[],i.attribute=[],i.node=[],i.opsetImport=[],i.attributeProto=[]),o.defaults&&(i.name="",i.docString="",i.domain=""),t.name!=null&&t.hasOwnProperty("name")&&(i.name=t.name),t.input&&t.input.length){i.input=[];for(var u=0;u<t.input.length;++u)i.input[u]=t.input[u]}if(t.output&&t.output.length){i.output=[];for(var u=0;u<t.output.length;++u)i.output[u]=t.output[u]}if(t.attribute&&t.attribute.length){i.attribute=[];for(var u=0;u<t.attribute.length;++u)i.attribute[u]=t.attribute[u]}if(t.node&&t.node.length){i.node=[];for(var u=0;u<t.node.length;++u)i.node[u]=$.onnx.NodeProto.toObject(t.node[u],o)}if(t.docString!=null&&t.hasOwnProperty("docString")&&(i.docString=t.docString),t.opsetImport&&t.opsetImport.length){i.opsetImport=[];for(var u=0;u<t.opsetImport.length;++u)i.opsetImport[u]=$.onnx.OperatorSetIdProto.toObject(t.opsetImport[u],o)}if(t.domain!=null&&t.hasOwnProperty("domain")&&(i.domain=t.domain),t.attributeProto&&t.attributeProto.length){i.attributeProto=[];for(var u=0;u<t.attributeProto.length;++u)i.attributeProto[u]=$.onnx.AttributeProto.toObject(t.attributeProto[u],o)}return i},e.prototype.toJSON=function(){return this.constructor.toObject(this,Ze.util.toJSONOptions)},e.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/onnx.FunctionProto"},e}(),r}();$d.exports=$});function _n(r,e){if(!r)throw new Error(typeof e=="string"?e:e())}function so(r){return new TextDecoder().decode(r)}var Je,Qr,Ha,Ct,li,St,Lt,oe,ao,en,tn,rn,He=R(()=>{"use strict";oi();Pa();Je=vn(Tn());nn();Qr=class{static arraysEqual(e,n){if(e.length!==n.length)return!1;for(let t=0;t<e.length;t++)if(e[t]!==n[t])return!1;return!0}},Ha=class{static preprocessInputShapes(e,n){let t=e.length===1?[1,e[0]]:e,o=n.length===1?[n[0],1]:n;return[t,o]}static postprocessOutputShape(e,n,t){n===1&&e.splice(e.length-2,1),t===1&&e.pop()}static calcMatMulShape(e,n){return e[1]!==n[0]?void 0:[e[0],n[1]]}},Ct=class r{static calcShape(e,n,t=!1){let o=e.length,i=n.length;if(o===0)return n;if(i===0)return e;let u=Math.max(e.length,n.length),a=new Array(u);if(t){if(o<2||i<2)return;let s=Ha.calcMatMulShape([e[o-2],e[o-1]],[n[i-2],n[i-1]]);if(s===void 0)return;[a[u-2],a[u-1]]=s}for(let s=t?3:1;s<=u;s++){let l=o-s<0?1:e[o-s],d=i-s<0?1:n[i-s];if(l!==d&&l>1&&d>1)return;a[u-s]=Math.max(l,d)}return a}static index(e,n){let t=new Array(n.length);return r.fillIndex(e,n,t),t}static fillIndex(e,n,t){let o=e.length-n.length;for(let i=0;i<n.length;i++)t[i]=e[o+i]%n[i]}static calc(e,n,t,o,i){let u=r.calcShape(e.dims,n.dims);if(u){if(o&&!oe.areEqual(u,e.dims))return;let a=oe.size(u),s=o?e:new mt(u,i||e.type);if(u.length===0)s.set([],t(e.get([]),n.get([])));else{let l=new Array(u.length),d=new Array(e.dims.length),f=new Array(n.dims.length),p=0,g=0,b=!1,y=!1;e.dims.length===0&&(p=e.get([]),b=!0),n.dims.length===0&&(g=n.get([]),y=!0);let _;for(let x=0;x<a;x++){_=x;for(let S=u.length-1;S>=0;S--)l[S]=_%u[S],_=Math.floor(_/u[S]);b||(r.fillIndex(l,e.dims,d),p=e.get(d)),y||(r.fillIndex(l,n.dims,f),g=n.get(f)),s.set(l,t(p,g))}}return s}}static isValidBroadcast(e,n){let t=e.length,o=n.length;if(t>o)return!1;for(let i=1;i<=t;i++)if(e[t-i]!==1&&e[t-i]!==n[o-i])return!1;return!0}static getBroadcastDims(e,n){let t=e.length,o=[];for(let i=0;i<t;i++){let u=t-1-i,a=e[u]||1;(n[n.length-1-i]||1)>1&&a===1&&o.unshift(u)}return o}},li=class{static getShapeOfGemmResult(e,n,t,o,i){if(e.length!==2||t.length!==2)throw new Error("shape need to be of size 2");let u,a,s;n?(u=e[1],a=e[0]):(u=e[0],a=e[1]);let l=-1;if(o?(s=t[0],l=1):(s=t[1],l=0),t[l]!==a)throw new Error("dimension mismatch");if(u<=0||s<=0||a<=0)throw new Error("invalid shape specified");if(i&&!Ct.isValidBroadcast(i,[u,s]))throw new Error("gemm: invalid bias shape for broadcast");return[u,s,a]}},St=class r{static tensorDataTypeFromProto(e){switch(e){case Je.onnx.TensorProto.DataType.INT8:return"int8";case Je.onnx.TensorProto.DataType.UINT8:return"uint8";case Je.onnx.TensorProto.DataType.BOOL:return"bool";case Je.onnx.TensorProto.DataType.INT16:return"int16";case Je.onnx.TensorProto.DataType.UINT16:return"uint16";case Je.onnx.TensorProto.DataType.INT32:return"int32";case Je.onnx.TensorProto.DataType.UINT32:return"uint32";case Je.onnx.TensorProto.DataType.FLOAT:return"float32";case Je.onnx.TensorProto.DataType.DOUBLE:return"float64";case Je.onnx.TensorProto.DataType.STRING:return"string";case Je.onnx.TensorProto.DataType.INT64:return"int32";case Je.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${Je.onnx.TensorProto.DataType[e]}`)}}static tensorDataTypeStringToEnum(e){switch(e){case"int8":return Je.onnx.TensorProto.DataType.INT8;case"uint8":return Je.onnx.TensorProto.DataType.UINT8;case"bool":return Je.onnx.TensorProto.DataType.BOOL;case"int16":return Je.onnx.TensorProto.DataType.INT16;case"uint16":return Je.onnx.TensorProto.DataType.UINT16;case"int32":return Je.onnx.TensorProto.DataType.INT32;case"uint32":return Je.onnx.TensorProto.DataType.UINT32;case"float32":return Je.onnx.TensorProto.DataType.FLOAT;case"float64":return Je.onnx.TensorProto.DataType.DOUBLE;case"string":return Je.onnx.TensorProto.DataType.STRING;case"int64":return Je.onnx.TensorProto.DataType.INT64;case"uint64":return Je.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${e}`)}}static tensorDimsFromProto(e){return e.map(n=>Ar.isLong(n)?n.toNumber():n)}static tensorValueTypeFromProto(e){return{tensorType:r.tensorDataTypeFromProto(e.elemType),shape:{dims:r.tensorDimsFromProto(e.shape.dim.map(n=>n.dimValue))}}}static tensorDimsFromORTFormat(e){let n=[];for(let t=0;t<e.dimsLength();t++)n.push(Lt.longToNumber(e.dims(t)));return n}static tensorAttributesFromORTFormat(e){let n=[];for(let t=0;t<e.attributesLength();t++)n.push(e.attributes(t));return n}},Lt=class{static longToNumber(e,n){return Ar.isLong(e)?e.toNumber():e instanceof D.Long?Ar.fromValue({low:e.low,high:e.high,unsigned:n??!1}).toNumber():e}static isLong(e){return Ar.isLong(e)||e instanceof D.Long}},oe=class r{static size(e){return r.getSizeFromDimensionRange(e,0,e.length)}static sizeFromDimension(e,n){if(n<0||n>e.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return r.getSizeFromDimensionRange(e,n,e.length)}static sizeToDimension(e,n){if(n<0||n>e.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${e.length} dimensions.`);return r.getSizeFromDimensionRange(e,0,n)}static getSizeFromDimensionRange(e,n,t){let o=1;for(let i=n;i<t;i++){if(e[i]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");o*=e[i]}return o}static computeStrides(e){let n=e.length;if(n===0)return[];if(n===1)return[1];let t=new Array(n);t[n-1]=1,t[n-2]=e[n-1];for(let o=n-3;o>=0;--o)t[o]=t[o+1]*e[o+1];return t}static transpose(e){return e.slice().reverse()}static indicesToOffset(e,n,t){t===void 0&&(t=e.length);let o=0;for(let i=0;i<t;++i)o+=n[i]*e[i];return o}static offsetToIndices(e,n){let t=n.length;if(t===0)return[];if(t===1)return[e*n[0]];let o=new Array(n.length);for(let i=0;i<o.length-1;++i)o[i]=Math.floor(e/n[i]),e-=o[i]*n[i];return o[o.length-1]=e,o}static normalizeAxis(e,n){if(e<-n&&e>=n)throw new Error("unsupported axis for this operation.");return e<0?e+n:e}static normalizeAxes(e,n){return e.map(t=>this.normalizeAxis(t,n))}static incrementIndex(e,n,t){if(n.length===0||e.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(t===void 0)t=n.length;else if(t<=0||t>n.length)throw new Error("Incorrect axis to increment on");for(let o=t-1;o>=0&&(e[o]++,!(e[o]<n[o]));--o)e[o]=0}static calculateReshapedDims(e,n){if(n.length===0){if(e.length===0||r.size(e)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}let t=n.length,o=new Array(t),i=-1,u=1;for(let s=0;s<t;s++){if(n[s]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(n[s]===-1){if(i!==-1)throw new Error("at most one dimension in shape hints can be -1");i=s}else{if(n[s]===0){if(s>=e.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");o[s]=e[s]}else o[s]=n[s];u*=o[s]}}let a=r.size(e);if(i!==-1){if(a%u!==0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${e}] Output shape: [${n}]`);o[i]=a/u}else if(u!==a)throw new Error("reshapedDims and originalDims don't have matching sizes");return o}static sortBasedOnPerm(e,n){return n?n.map(t=>e[t]):e.slice().reverse()}static padShape(e,n){let t=e.length;return e.map((o,i)=>o+n[i]+n[i+t])}static areEqual(e,n){return e.length!==n.length?!1:e.every((t,o)=>t===n[o])}static validateDimsAndCalcSize(e){if(e.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let n=1;for(let t of e){if(!Number.isInteger(t))throw new TypeError(`Invalid shape: ${t} is not an integer`);if(t<0||t>2147483647)throw new TypeError(`Invalid shape: length ${t} is not allowed`);n*=t}return n}static flattenShape(e,n){n<0&&(n+=e.length);let t=e.reduce((u,a)=>u*a,1),o=e.slice(n).reduce((u,a)=>u*a,1);return[t/o,o]}static squeezeShape(e,n){let t=new Array;n=r.normalizeAxes(n,e.length);for(let o=0;o<e.length;o++){let i=n.indexOf(o)>=0;if(i&&e[o]!==1)throw new Error("squeeze an axis of size different than 1");(n.length===0&&e[o]>1||n.length>0&&!i)&&t.push(e[o])}return t}static unsqueezeShape(e,n){let t=new Array(e.length+n.length);t.fill(0);for(let i=0;i<n.length;i++){let u=r.normalizeAxis(n[i],t.length);if(u>=t.length)throw new Error("'axes' has an out of range axis");if(t[u]!==0)throw new Error("'axes' has a duplicate axis");t[u]=1}let o=0;for(let i=0;i<t.length;i++)t[i]===0&&(t[i]=e[o++]);if(o!==e.length)throw new Error("the unsqueezed dimension could not be established");return t}},ao=class r{static splitShape(e,n,t,o){if(t.length===0){if(!o)throw new Error("need to know number of outputs when the 'split' attribute is not specified");r.determineSplit(e[n],o,t)}let i=[],u=[0];for(let a=0;a<t.length;++a){a!==0&&u.push(u[a-1]+t[a-1]);let s=e.slice();s[n]=t[a],i.push(s)}return[i,u]}static determineSplit(e,n,t){if(e%n!==0)throw new Error("cannot split tensor to equal sized parts");for(let o=0;o<n;++o)t.push(e/n)}},en=class r{static adjustPoolAttributes(e,n,t,o,i,u){if(!e&&t.length!==n.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let a=0;a<n.length-2;a++)a>=t.length?t.push(n[a+2]):t[a]=n[a+2];for(let a=0;a<t.length;a++)if(a<o.length){if(o[a]<0)throw new Error("strides should be greater than or equal to 1")}else o.push(1);for(let a=0;a<t.length;a++)if(a<i.length){if(i[a]<0)throw new Error("dilations should be greater than or equal to 1")}else i.push(1);for(let a=0;a<t.length*2;a++)if(a<u.length){if(u[a]<0)throw new Error("pad should be greater than or equal to 1")}else u.push(0);for(let a=0;a<t.length;a++){if(t[a]<=0)throw new Error("kernel shapes need to be greater than 0");if(u[a]>=t[a]||u[a+t.length]>=t[a])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,n,t,o,i,u){if(u){if(i.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(n.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(o.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let a=0;a<e.length-2;a++)r.adjustPadAndReturnShape(e[a+2],n[a],t[a],o[a],i,a,a+e.length-2,u)}}static computePoolOutputShape(e,n,t,o,i,u,a){if(n.length<=0)throw new Error("input shape must be of size greater than 0");let s=[n[0],n[1]];return r.computeShapeHelper(e,n,s,t,o,i,u,a),s}static computeConvOutputShape(e,n,t,o,i,u,a){if(e.length<=0||n.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let s=[e[0],n[0]];return r.computeShapeHelper(!1,e,s,t,o,i,u,a),s}static computeShapeHelper(e,n,t,o,i,u,a,s){if(e)for(let l=0;l<n.length-2;l++)t.push(1);else for(let l=0;l<n.length-2;l++)t.push(r.adjustPadAndReturnShape(n[l+2],o[l],i[l],u[l],a,l,l+n.length-2,s))}static adjustPadAndReturnShape(e,n,t,o,i,u,a,s){let l=t*(o-1)+1;if(s&&s!=="NOTSET")switch(s){case"VALID":return i[u]=0,i[a]=0,Math.floor((e-l)/n+1);case"SAME_LOWER":case"SAME_UPPER":if(t!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let f=((e+n-1)/n-1)*n+o-e;return i[u]=Math.floor(s==="SAME_LOWER"?(f+1)/2:f/2),i[a]=f-i[u],Math.floor((e+f-o)/n+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((e+i[u]+i[a]-l)/n+1)}},tn=-34028234663852886e22,rn=34028234663852886e22});function r0(r){switch(r){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${r}`)}}function Td(r){switch(r){case Oe.onnx.TensorProto.DataType.UINT8:case Oe.onnx.TensorProto.DataType.INT8:case Oe.onnx.TensorProto.DataType.BOOL:return 1;case Oe.onnx.TensorProto.DataType.UINT16:case Oe.onnx.TensorProto.DataType.INT16:return 2;case Oe.onnx.TensorProto.DataType.FLOAT:case Oe.onnx.TensorProto.DataType.INT32:case Oe.onnx.TensorProto.DataType.UINT32:return 4;case Oe.onnx.TensorProto.DataType.INT64:case Oe.onnx.TensorProto.DataType.DOUBLE:case Oe.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${Oe.onnx.TensorProto.DataType[r]}`)}}function n0(r,e){return new(Id(e))(r)}function Id(r){switch(r){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function ja(r,e){if(e===Oe.onnx.TensorProto.DataType.INT64||e===qa.TensorDataType.INT64){if(r.greaterThanOrEqual(2147483648)||r.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else if(e===Oe.onnx.TensorProto.DataType.UINT32||e===qa.TensorDataType.UINT32||e===Oe.onnx.TensorProto.DataType.UINT64||e===qa.TensorDataType.UINT64){if(r.greaterThanOrEqual(4294967296)||r.lessThan(0))throw new TypeError("uint64 is not supported")}else throw new TypeError(`not a LONG type: ${Oe.onnx.TensorProto.DataType[e]}`);return r.toNumber()}function _d(r,e,n){switch(e){case Oe.onnx.TensorProto.DataType.BOOL:case Oe.onnx.TensorProto.DataType.UINT8:return r.getUint8(n);case Oe.onnx.TensorProto.DataType.INT8:return r.getInt8(n);case Oe.onnx.TensorProto.DataType.UINT16:return r.getUint16(n,!0);case Oe.onnx.TensorProto.DataType.INT16:return r.getInt16(n,!0);case Oe.onnx.TensorProto.DataType.FLOAT:return r.getFloat32(n,!0);case Oe.onnx.TensorProto.DataType.INT32:return r.getInt32(n,!0);case Oe.onnx.TensorProto.DataType.UINT32:return r.getUint32(n,!0);case Oe.onnx.TensorProto.DataType.INT64:return ja(Ar.fromBits(r.getUint32(n,!0),r.getUint32(n+4,!0),!1),e);case Oe.onnx.TensorProto.DataType.DOUBLE:return r.getFloat64(n,!0);case Oe.onnx.TensorProto.DataType.UINT64:return ja(Ar.fromBits(r.getUint32(n,!0),r.getUint32(n+4,!0),!0),e);default:throw new Error(`cannot read from DataView for type ${Oe.onnx.TensorProto.DataType[e]}`)}}var Sd,Oe,qa,mt,nn=R(()=>{"use strict";Sd=vn(hl());Pa();ro();Oe=vn(Tn());He();qa=se.experimental.fbs,mt=class r{constructor(e,n,t,o,i,u=Sd.Guid.create()){this.dims=e;this.type=n;this.dataProvider=t;this.asyncDataProvider=o;this.cache=i;this.dataId=u;this.size=oe.validateDimsAndCalcSize(e);let a=this.size,s=t===void 0&&o===void 0&&i===void 0;if(i!==void 0&&i.length!==a)throw new RangeError("Input dims doesn't match data length.");if(n==="string"){if(i!==void 0&&(!Array.isArray(i)||!i.every(l=>typeof l=="string")))throw new TypeError("cache should be a string array");s&&(this.cache=new Array(a))}else{if(i!==void 0){let l=Id(n);if(!(i instanceof l))throw new TypeError(`cache should be type ${l.name}`)}if(s){let l=new ArrayBuffer(a*r0(n));this.cache=n0(l,n)}}}get data(){if(this.cache===void 0){let e=this.dataProvider(this.dataId);if(e.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=e}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(e){return this.data[oe.indicesToOffset(e,this.strides)]}set(e,n){this.data[oe.indicesToOffset(e,this.strides)]=n}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=oe.computeStrides(this.dims)),this._strides}static fromProto(e){if(!e)throw new Error("cannot construct Value from an empty tensor");let n=St.tensorDataTypeFromProto(e.dataType),t=St.tensorDimsFromProto(e.dims),o=new r(t,n);if(n==="string")e.stringData.forEach((i,u)=>{o.data[u]=so(i)});else if(e.rawData&&typeof e.rawData.byteLength=="number"&&e.rawData.byteLength>0){let i=o.data,u=new DataView(e.rawData.buffer,e.rawData.byteOffset,e.rawData.byteLength),a=Td(e.dataType),s=e.rawData.byteLength/a;if(e.rawData.byteLength%a!==0)throw new Error("invalid buffer length");if(i.length!==s)throw new Error("buffer length mismatch");for(let l=0;l<s;l++){let d=_d(u,e.dataType,l*a);i[l]=d}}else{let i;switch(e.dataType){case Oe.onnx.TensorProto.DataType.FLOAT:i=e.floatData;break;case Oe.onnx.TensorProto.DataType.INT32:case Oe.onnx.TensorProto.DataType.INT16:case Oe.onnx.TensorProto.DataType.UINT16:case Oe.onnx.TensorProto.DataType.INT8:case Oe.onnx.TensorProto.DataType.UINT8:case Oe.onnx.TensorProto.DataType.BOOL:i=e.int32Data;break;case Oe.onnx.TensorProto.DataType.INT64:i=e.int64Data;break;case Oe.onnx.TensorProto.DataType.DOUBLE:i=e.doubleData;break;case Oe.onnx.TensorProto.DataType.UINT32:case Oe.onnx.TensorProto.DataType.UINT64:i=e.uint64Data;break;default:throw new Error("unspecific error")}if(i==null)throw new Error("failed to populate data from a tensorproto value");let u=o.data;if(u.length!==i.length)throw new Error("array length mismatch");for(let a=0;a<i.length;a++){let s=i[a];Ar.isLong(s)?u[a]=ja(s,e.dataType):u[a]=s}}return o}static fromData(e,n,t){return new r(n,t,void 0,void 0,e)}static fromOrtTensor(e){if(!e)throw new Error("cannot construct Value from an empty tensor");let n=St.tensorDimsFromORTFormat(e),t=St.tensorDataTypeFromProto(e.dataType()),o=new r(n,t);if(t==="string")for(let i=0;i<e.stringDataLength();i++)o.data[i]=e.stringData(i);else if(e.rawDataArray()&&typeof e.rawDataLength()=="number"&&e.rawDataLength()>0){let i=o.data,u=new DataView(e.rawDataArray().buffer,e.rawDataArray().byteOffset,e.rawDataLength()),a=Td(e.dataType()),s=e.rawDataLength()/a;if(e.rawDataLength()%a!==0)throw new Error("invalid buffer length");if(i.length!==s)throw new Error("buffer length mismatch");for(let l=0;l<s;l++){let d=_d(u,e.dataType(),l*a);i[l]=d}}return o}}});function le(r){return r===1?o0:i0}function Ad(r){let e=le(r);return`${e.version}
      precision highp float;
      ${e.attribute} vec3 position;
      ${e.attribute} vec2 textureCoord;

      ${e.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`}function Od(r){let e=le(r);return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFrag} vec2 TexCoords;
    ${e.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `}function Ed(r,e){let n=le(r);return`
  void main() {
    int indices[${e}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${n.output} = result;
  }
  `}var o0,i0,rt=R(()=>{"use strict";o0={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},i0={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"}});var ze=R(()=>{"use strict"});async function Ka(r,e=t=>0,n){return new Promise((t,o)=>{let i=0,u=()=>{if(r()){t();return}i++;let a=e(i);if(n!=null&&i>=n){o();return}setTimeout(u,a)};u()})}function di(r){return _n(typeof r<"u"&&r.length!==0,()=>"empty string found for sampler name"),"get"+r.charAt(0).toUpperCase()+r.slice(1)}function Cd(r){return _n(typeof r<"u"&&r.length!==0,()=>"empty string found for sampler name"),"get"+r.charAt(0).toUpperCase()+r.slice(1)+"AtOutCoords"}function Sn(r,e){let n=JSON.parse(JSON.stringify(r));return n=e,n}function In(r,e){return e.map(n=>r[n]).join(", ")}function Pt(r){if(r<=1)return"int";if(r===2)return"ivec2";if(r===3)return"ivec3";if(r===4)return"ivec4";if(r===5)return"ivec5";if(r===6)return"ivec6";throw Error(`GPU for rank ${r} is not yet supported`)}function tr(r=6){return["x","y","z","w","u","v"].slice(0,r)}var dr=R(()=>{"use strict";He()});function a0(r,e){return tr(e).map(n=>`${r}.${n}`)}function An(r,e){return e===1?[r]:a0(r,e)}function cr(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}var on=R(()=>{"use strict";dr()});function u0(r,e,n){if(r===0)return"false";if(r===1)return`rc > ${e[0]}`;let t="";for(let o=r-2;o<r;o++)t+=`${n[o]} >= ${e[o-r+2]}`,o<r-1&&(t+="||");return t}function l0(r,e){let n=r.length;if(n===0)return"getA(), 0, 0, 0";if(n===1)return`getA(rc),
            rc + 1 >= ${r[0]} ? 0. : getA(rc + 1),
            0, 0`;let t="r, c",o="r, cp1",i="rp1, c",u="rp1, cp1",a="";if(n>2)for(let s=0;s<n-2;++s)a=a+`${e[s]},`;return`getA(${a}${t}),
          rEdge ? 0. : getA(${a}${i}),
          cEdge ? 0. : getA(${a}${o}),
          rEdge || cEdge ? 0. : getA(${a}${u})`}function d0(r,e,n,t){return r===0||r===1?"":`
    int r = ${e[r-2]};
    int c = ${e[r-1]};
    int rp1 = ${e[r-2]} + 1;
    int cp1 = ${e[r-1]} + 1;
    bool rEdge = rp1 >= ${t};
    bool cEdge = cp1 >= ${n};
    `}var Pd,s0,kd,Dd=R(()=>{"use strict";rt();ze();dr();on();Pd={name:"pack",inputNames:["A"],inputTypes:[1]},s0=(r,e)=>{let n=le(r.session.backend.glContext.version),t=e.dims,o=t.length,i=e.dims.length,u=Pt(i),a=An("rc",i),s=d0(i,a,t[t.length-2],t[t.length-1]),l;o===0?l=[1,1]:o===1?l=[t[0],1]:l=[t[i-1],t[i-2]];let d=u0(i,l,a),f=l0(t,a),p=`
        void main() {
          ${u} rc = getOutputCoords();

          if(${d}) {
            ${n.output} = vec4(0);
          } else {
            ${s}

            ${n.output} = vec4(${f});
          }
        }
      `;return{...Pd,hasMain:!0,output:{dims:e.dims,type:e.type,textureType:2},shaderSource:p}},kd=(r,e)=>({...Pd,get:()=>s0(r,e)})});function Ya(r){if(r.length===0)return[1,1,1];let e=1;for(let n=0;n<r.length-2;++n)e*=r[n];return[e,r.length>1?r[r.length-2]:1,r[r.length-1]]}function Rd(r,e){let n=!1;return r.length===0||e.length===0?n=!0:r.length<2||e.length<2?n=r[r.length-1]===e[e.length-1]:n=r[r.length-1]===e[e.length-1]&&r[r.length-2]===e[e.length-2],n}function p0(r){let e=oe.computeStrides(r),n=["b","r","c"],t="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e.map((i,u)=>{let a=`int ${n[u]} = ${t} / ${i}`,s=u===e.length-1?`int ${n[u+1]} = ${t} - ${n[u]} * ${i}`:`index -= ${n[u]} * ${i}`;return`${a}; ${s};`}).join("")}
      return ivec3(b, r, c);
    }
  `}function h0(r){let e=oe.computeStrides(r);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${e[0]} + coords.z * ${e[1]} + coords.y;
  }
`}var c0,f0,Bd,Md=R(()=>{"use strict";He();rt();ze();on();c0=r=>({name:"Reshape (packed)",inputTypes:[2],inputNames:["A"],cacheHint:`${r}`}),f0=(r,e,n,t)=>{let o=e.dims,i=t,u="";for(let l=0;l<4;l++){let d="";switch(l){case 0:d="outputCoords = rc;";break;case 1:d="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:d="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:d="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}u+=`
        ${d}
        ${l>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${l}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${l>0?"}":""}
      `}let a=le(r.session.backend.glContext.version),s=`
      ${p0(o)}
      ${h0(i)}
      ${cr()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${i[2]};
        int cols = ${i[1]};

        ${u}
        ${a.output} = result;
      }
    `;return{...n,output:{dims:i,type:e.type,textureType:2},shaderSource:s,hasMain:!0}},Bd=(r,e,n)=>{let t=c0(n);return{...t,get:()=>f0(r,e,t,n)}}});var Xa,Ld=R(()=>{"use strict";rt();ze();Xa=(r,e)=>{let n=e.shape,t=le(r.session.backend.glContext.version),o=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${t.texture2D}(X,TexCoords).r;
      ${t.output} = encodeAsUint8(value);
    }`,i={name:"Uint8Encode",inputTypes:[0],inputNames:["X"],output:{dims:n,type:e.tensor.type,textureType:3},shaderSource:o,hasMain:!0};return r.executeProgram(i,[e.tensor])}});function g0(r,e){if(r===1)return"rc";let n="";for(let t=0;t<r;t++)n+=e[t],t<r-1&&(n+=",");return n}var zd,m0,Nd,Fd=R(()=>{"use strict";rt();ze();dr();on();zd={name:"unpack",inputNames:["A"],inputTypes:[2]},m0=(r,e)=>{let n=e.dims.length,t=An("rc",n),o=t.slice(-2),i=Pt(n),u=cr(),s=e.dims.length===0?"":g0(n,t),l=n<=1?"rc":`vec2(${o.join(",")})`,d=le(r.session.backend.glContext.version),f=`
    ${u}
    void main() {
      ${i} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${s});

       ${d.output} = vec4(getChannel(packedInput, ${l}), 0, 0, 0);
     }
   `;return{...zd,hasMain:!0,output:{dims:e.dims,type:e.type,textureType:0},shaderSource:f}},Nd=(r,e)=>({...zd,get:()=>m0(r,e)})});var ci,uo,fi,lo=R(()=>{"use strict";Vt();ci=class{constructor(e,n=1){if(n===1)this.internalFormat=e.R32F,this.format=e.RED,this.textureType=e.FLOAT,this.channelSize=n;else if(n===4)this.internalFormat=e.RGBA32F,this.format=e.RGBA,this.textureType=e.FLOAT,this.channelSize=n;else throw new Error(`Invalid number of channels: ${n}`)}encode(e,n){let t,o;return e.constructor!==Float32Array&&(je.warning("Encoder","data was not of type Float32; creating new Float32Array"),o=new Float32Array(e)),n*this.channelSize>e.length?(je.warning("Encoder","Source data too small. Allocating larger array"),o=e,t=this.allocate(n*this.channelSize),o.forEach((i,u)=>t[u]=i)):(o=e,t=o),t}allocate(e){return new Float32Array(e*4)}decode(e,n){return this.channelSize===1?e.filter((o,i)=>i%4===0).subarray(0,n):e.subarray(0,n)}},uo=class{constructor(e,n=1,t){if(n!==1&&n!==4)throw new Error(`Invalid number of channels: ${n}`);this.internalFormat=e.RGBA,this.format=e.RGBA,this.channelSize=n,this.textureType=t||e.FLOAT}encode(e,n){let t=e;return this.channelSize===1&&(je.verbose("Encoder","Exploding into a larger array"),t=this.allocate(n),e.forEach((o,i)=>t[i*4]=o)),t}allocate(e){return new Float32Array(e*4)}decode(e,n){return this.channelSize===1?e.filter((o,i)=>i%4===0).subarray(0,n):e.subarray(0,n)}},fi=class{constructor(e,n=1){this.channelSize=4;if(n===1)this.internalFormat=e.ALPHA,this.format=e.ALPHA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=n;else if(n===4)this.internalFormat=e.RGBA,this.format=e.RGBA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=n;else throw new Error(`Invalid number of channels: ${n}`)}encode(e,n){return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}allocate(e){return new Uint8Array(e*this.channelSize)}decode(e,n){if(e instanceof Uint8Array)return e.subarray(0,n);throw new Error(`Invalid array type: ${e.constructor}`)}}});var co,Vd,Za,Gd=R(()=>{"use strict";He();ze();co=(r,e,n)=>{let t=n===0||n===1?1:4,o=n===2,i=n===1||n===2,u=n===4?e.length-1:void 0,a=n===4?e.map((s,l)=>l===e.length-1?s*4:s):void 0;return Za(r,e,t,a,{isPacked:o,reverseWH:i,breakAxis:u})},Vd=(r,e,n)=>{let t=co(r,e,n);return[t.width,t.height]},Za=(r,e,n=1,t,o)=>{let i=!!(o&&o.isPacked),[u,a]=r.computeTextureWH(i&&t||e,o),s=e.length,l=e.slice(0);if(s===0&&(l=[1]),n===1)t=e;else if(i){if(n!==4)throw new Error("a packed texture must be 4-channel");t=e,s>0&&(l[s-1]=Math.ceil(l[s-1]/2)),s>1&&(l[s-2]=Math.ceil(l[s-2]/2))}else if(!t)throw new Error("Unpacked shape is needed when using channels > 1");return{width:u,height:a,channels:n,isPacked:i,shape:l,strides:oe.computeStrides(l),unpackedShape:t,reversedWH:o&&o.reverseWH}}});var y0,pi,Wd=R(()=>{"use strict";Vt();nn();He();Dd();Md();Ld();Fd();lo();Gd();ze();y0=(r,e)=>{let n=e.map(o=>`${o.unpackedShape.join(",")};${o.width}x${o.height}`).join("_"),t=r.name;return r.cacheHint&&(t+="["+r.cacheHint+"]"),t+=":"+n,t},pi=class{constructor(e){this.session=e;this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(e,n){return Vd(this.session.layoutStrategy,e,n)}executeProgram(e,n){if(n.length<e.inputNames.length)throw new Error(`Input size mustn't be less than ${e.inputNames.length}.`);if(e.inputNames.length!==e.inputTypes.length)throw new Error("input names size does not match input types");let t=[];for(let l=0;l<e.inputNames.length;++l)t[l]=this.getOrCreateTextureData(n[l],e.inputTypes[l]);let o=y0(e,t),i=this.session.programManager.getArtifact(o),u=i?i.programInfo:typeof e.get=="function"?e.get():e,a=co(this.session.layoutStrategy,u.output.dims,u.output.textureType),s=this.createTextureData(a,u.output.type);return i||(i=this.session.programManager.build(u,t,s),this.session.programManager.setArtifact(o,i)),this.runProgram(i,t,s),s}run(e,n){return this.executeProgram(e,n).tensor}runProgram(e,n,t){for(let o=0;o<n.length;++o)if(!!n[o].isPacked!=(e.programInfo.inputTypes[o]===2))throw new Error(`input[${o}] property packed inconsistent`);if(!!t.isPacked!=(e.programInfo.output.textureType===2))throw new Error("output property packed inconsistent");this.session.programManager.run(e,n,t)}getOrCreateTextureData(e,n){let t=this.getTextureData(e.dataId,n===2);if(!t&&(t=this.getTextureData(e.dataId,n!==2),t))return n===2?this.pack(t):this.unpack(t);if(!t){let o=co(this.session.layoutStrategy,e.dims,n);if(n===4){let a=e.dims;if(a.length===4){let s=[a[0],Math.ceil(a[1]*a[2]*a[3]/4)],l=co(this.session.layoutStrategy,s,n),d=e.numberData;if(a[1]*a[2]*a[3]%4!==0){let f=a[0],p=a[1]*a[2]*a[3],g=Math.ceil(p*1/4)*4,b=f*g;d=new Float32Array(b);for(let y=0;y<f;++y){let _=y*p,x=y*g+y%1*p;d.set(e.numberData.subarray(_,_+p),x)}}return this.createTextureData(l,e.type,d,e,1)}}if(n===2){let i=Za(this.session.layoutStrategy,e.dims,1,[],{reverseWH:!0}),u=this.createTextureData(i,e.type,e.numberData,e,1);t=this.pack(u)}else t=this.createTextureData(o,e.type,e.numberData,e,1)}return t}createTextureDataFromLayoutBindTensor(e,n,t,o){return this.createTextureData(e,n,t,o,1)}createTextureData(e,n,t,o,i){je.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(e)}]`);let u=this.session.textureManager.createTextureFromLayout(n,e,t,i);return this.createTextureDataFromTexture(e,n,u,o)}reshapeUnpacked(e,n){let t=this.getOrCreateTextureData(e,0),o={channels:t.channels,height:t.height,width:t.width,shape:n.length!==0?n:[1],strides:oe.computeStrides(n),unpackedShape:n};return this.createTextureDataFromTexture(o,e.type,t.texture).tensor}reshapePacked(e,n){let t=this.getOrCreateTextureData(e,2);if(Rd(e.dims,n)){let l={channels:t.channels,height:t.height,width:t.width,shape:n.length!==0?n:[1],strides:oe.computeStrides(n),unpackedShape:n,isPacked:!0};return this.createTextureDataFromTexture(l,e.type,t.texture).tensor}let o=Ya(e.dims),i=Ya(n),u=this.reshapePacked(e,o),a=this.run(Bd(this,u,i),[u]);return this.reshapePacked(a,n)}cast(e,n){let t=this.getOrCreateTextureData(e,0);return this.createTextureDataFromTexture(t,n,t.texture).tensor}createTextureDataFromTexture(e,n,t,o,i){let u={...e,tensor:o||new mt(e.unpackedShape,n,a=>this.readTexture(u),async a=>this.readTextureAsync(u),void 0,i),texture:t};return this.setTextureData(u.tensor.dataId,u,e.isPacked),u}getTextureData(e,n=!1){return this.session.isInitializer(e)?this.session.getTextureData(e,n):n?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,n,t=!1){this.session.isInitializer(e)?this.session.setTextureData(e,n,t):(t?this.packedTextureDataCache:this.unpackedTextureDataCache).set(e,n)}isTextureLayoutCached(e,n=!1){return!!this.getTextureData(e.dataId,n)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.unpackedTextureDataCache=new Map}readTexture(e){return e.isPacked?this.readTexture(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat(Xa(this,e))}async readTextureAsync(e){return e.isPacked?this.readTextureAsync(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat(Xa(this,e))}pack(e){return this.executeProgram(kd(this,e.tensor),[e.tensor])}unpack(e){return this.executeProgram(Nd(this,e.tensor),[e.tensor])}}});var Ja,Ie,xt=R(()=>{"use strict";Ja=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(e=>`${this[e]}`).join(";")),this.key}},Ie=r=>new Ja(r)});var Hd,qd,jd,v0,w0,Kd=R(()=>{"use strict";xt();rt();ze();Hd={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[0,0,0,0,0]},qd=(r,e,n)=>(w0(e),[r.run({...Hd,cacheHint:n.cacheKey,get:()=>v0(r,e,n)},e)]),jd=r=>{let e=r.attributes.getFloat("epsilon",1e-5),n=r.attributes.getFloat("momentum",.9),t=r.attributes.getInt("spatial",1);return Ie({epsilon:e,momentum:n,spatial:t})},v0=(r,e,n)=>{let t=le(r.session.backend.glContext.version),o=e[0].dims.length,[i,u]=r.calculateTextureWidthAndHeight(e[1].dims,0),a=`
  float process(int[${o}] indices) {
    vec2 position = offsetToCoords(indices[1], ${i}, ${u});
    float scale = getColorAsFloat(${t.texture2D}(Scale, position));
    float mean = getColorAsFloat(${t.texture2D}(Mean, position));
    float variance = getColorAsFloat(${t.texture2D}(Variance, position));
    float b = getColorAsFloat(${t.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n.epsilon})) ) + b;
  }`;return{...Hd,output:{dims:e[0].dims,type:e[0].type,textureType:0},shaderSource:a}},w0=r=>{if(!r||r.length!==5)throw new Error("BatchNormalization requires 5 inputs.");let e=r[0],n=r[1],t=r[2],o=r[3],i=r[4];if(e.dims.length<3||n.dims.length!==1||t.dims.length!==1||o.dims.length!==1||i.dims.length!==1)throw new Error("invalid input shape.");if(n.dims[0]!==e.dims[1]||t.dims[0]!==e.dims[1]||o.dims[0]!==e.dims[1]||i.dims[0]!==e.dims[1])throw new Error("invalid input shape.");if(e.type!=="float32"&&e.type!=="float64"||n.type!=="float32"&&n.type!=="float64"||t.type!=="float32"&&t.type!=="float64"||o.type!=="float32"&&o.type!=="float64"||i.type!=="float32"&&i.type!=="float64")throw new Error("invalid input tensor types.")}});var hi,Ht,Q,fo,mi,Or=R(()=>{"use strict";hi=class{constructor(e,n,t,o){this.glContext=e;this.programInfo=n;this.inputTextureLayouts=t;this.outputTextureLayout=o}},Ht=class{constructor(e){this.context=e}},Q=class{constructor(e,n){this.routineBody=e;this.dependencies=n}},fo=class{constructor(e,n,t){this.name=e;t?this.dependencies=t:this.dependencies=[],n&&(this.routineBody=n)}addDependency(e){e&&this.dependencies.push(e)}},mi=class{static returnOrderedNodes(e){if(!e||e.length===0)return[];if(e.length===1)return e;let n=new Set,t=new Set,o=new Array;return this.createOrderedNodes(e,n,t,o),o}static createOrderedNodes(e,n,t,o){for(let i=0;i<e.length;++i)this.dfsTraverse(e[i],n,t,o)}static dfsTraverse(e,n,t,o){if(!e||t.has(e.name))return;if(n.has(e.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");n.add(e.name);let i=e.dependencies;if(i&&i.length>0)for(let u=0;u<i.length;++u)this.dfsTraverse(i[u],n,t,o);o.push(e),t.add(e.name),n.delete(e.name)}}});function $0(){let r="add_";return{body:`
  float ${r}(float a, float b) {
    return a + b;
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:r,type:0}}function T0(){let r="div_";return{body:`
  float ${r}(float a, float b) {
    return a / b;
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:r,type:0}}function _0(){let r="mul_";return{body:`
  float ${r}(float a, float b) {
    return a * b;
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:r,type:0}}function S0(){let r="sub_";return{body:`
  float ${r}(float a, float b) {
    return a - b;
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:r,type:0}}function I0(){let r="equal_";return{body:`
  float ${r}(float a, float b) {
    return float(a == b);
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:r,type:0}}function A0(){let r="greater_";return{body:`
  float ${r}(float a, float b) {
    return float(a > b);
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:r,type:0}}function O0(){let r="less_";return{body:`
  float ${r}(float a, float b) {
    return float(a < b);
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:r,type:0}}function E0(){let r="and_";return{body:`
  float ${r}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:r,type:0}}function C0(){let r="or_";return{body:`
  float ${r}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:r,type:0}}function P0(){let r="xor_";return{body:`
  float ${r}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:r,type:0}}function k0(){return B0("pow")}function D0(){let r="prelu_";return{body:`
  float ${r}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${r}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:r,type:0}}function B0(r){let e=`${r}_`;return{body:`
  float ${e}(float a, float b) {
    return ${r}(a, b);
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return ${r}(v1, v2);
  }
  `,name:e,type:0}}var qt,R0,Yd,Xd,Zd,Jd,Qd,ec,tc,rc,nc,oc,ic,ac,sc=R(()=>{"use strict";He();Or();rt();ze();qt=(r,e,n,t=e[0].type,o)=>{let i=r.session.pack?2:0;return{name:n.name,inputNames:["A","B"],inputTypes:[i,i],cacheHint:o,get:()=>R0(r,e,n,t)}},R0=(r,e,n,t=e[0].type)=>{let o=r.session.pack?2:0,i=!oe.areEqual(e[0].dims,e[1].dims),u=e[0].dims,a=r.session.pack;if(i){let d=Ct.calcShape(e[0].dims,e[1].dims,!1);if(!d)throw new Error("Can't perform binary op on the given tensors");u=d;let f=u.length,p=e[0].dims.length!==0?e[0].dims.length:1,g=e[1].dims.length!==0?e[1].dims.length:1,b=e[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",y=e[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",_=le(r.session.backend.glContext.version),x=a?`
      ${n.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${n.name}(a, b);
        ${_.output} = result;
      }`:`
      ${n.body}
      float process(int indices[${f}]) {
        int aindices[${p}];
        int bindices[${g}];
        ${b}
        ${y}
        return ${n.name}(_A(aindices), _B(bindices));
      }`;return{name:n.name,inputNames:["A","B"],inputTypes:[o,o],output:{dims:u,type:t,textureType:o},shaderSource:x,hasMain:a}}let s=le(r.session.backend.glContext.version),l=`
    ${n.body}
    void main() {
      vec4 v1 = ${s.texture2D}(A, TexCoords);
      vec4 v2 = ${s.texture2D}(B, TexCoords);
      vec4 result = ${n.name}(v1, v2);
      ${s.output} = result;
    }
    `;return{name:n.name,inputNames:["A","B"],inputTypes:[o,o],output:{dims:e[0].dims,type:t,textureType:o},shaderSource:l,hasMain:!0}},Yd=(r,e)=>[r.run(qt(r,e,$0()),e)],Xd=(r,e)=>[r.run(qt(r,e,E0(),"bool"),e)],Zd=(r,e)=>[r.run(qt(r,e,T0()),e)],Jd=(r,e)=>[r.run(qt(r,e,I0(),"bool"),e)],Qd=(r,e)=>[r.run(qt(r,e,A0(),"bool"),e)],ec=(r,e)=>[r.run(qt(r,e,O0(),"bool"),e)],tc=(r,e)=>[r.run(qt(r,e,_0()),e)],rc=(r,e)=>[r.run(qt(r,e,C0(),"bool"),e)],nc=(r,e)=>[r.run(qt(r,e,k0()),e)],oc=(r,e)=>[r.run(qt(r,e,D0()),e)],ic=(r,e)=>[r.run(qt(r,e,S0()),e)],ac=(r,e)=>[r.run(qt(r,e,P0(),"bool"),e)]});var uc,lc,L0,dc=R(()=>{"use strict";He();uc=(r,e,n)=>(L0(e),[r.cast(e[0],n)]),lc=r=>St.tensorDataTypeFromProto(r.attributes.getInt("to")),L0=r=>{if(!r||r.length!==1)throw new Error("Cast requires 1 input.");if(r[0].type==="string")throw new Error("Invalid input type.")}});var z0,N0,cc,gi,fc=R(()=>{"use strict";rt();ze();dr();on();z0=(r,e)=>({name:"Concat (packed)",inputNames:Array.from({length:r},(n,t)=>`X${t}`),inputTypes:Array(r).fill(2),cacheHint:e}),N0=(r,e,n,t)=>{let o=n[0].dims.slice();if(t>=o.length||t<-1*o.length)throw new Error("axis specified for concat doesn't match input dimensionality");t<0&&(t=o.length+t);let i=o.slice(0);for(let N=1;N<n.length;N++){let k=n[N].dims.slice();for(let U=0;U<o.length;U++)if(U===t)i[t]+=k[U];else if(o[U]!==k[U])throw new Error("non concat dimensions must match")}let u=i.length,a=An("coords",u),s=Pt(u),l=cr(),d=n.map(N=>N.dims),f=tr(u),p=new Array(d.length-1);p[0]=d[0][t];for(let N=1;N<p.length;N++)p[N]=p[N-1]+d[N][t];let g=f[t],b=f.slice(-2),y=f.join(),_=`if (${g} < ${p[0]}) {
        return getChannel(
            getX0(${y}), vec2(${b.join()}));
        }`;for(let N=1;N<p.length;N++){let k=p[N-1];_+=`
            if (${g} < ${p[N]}  && ${g} >= ${p[N-1]}) {
              return getChannel(
                getX${N}(${gi(f,g,k)}),
                vec2(${gi(b,g,k)}));
            }`}let x=p.length,S=p[p.length-1];_+=`
            return getChannel(
              getX${x}(${gi(f,g,S)}),
              vec2(${gi(b,g,S)}));`;let O=le(r.session.backend.glContext.version),C=`
          ${l}
          float getValue(${f.map(N=>"int "+N)}) {
            ${_}
          }

          void main() {
            ${s} coords = getOutputCoords();
            int lastDim = coords.${f[u-1]};
            coords.${f[u-1]} = coords.${f[u-2]};
            coords.${f[u-2]} = lastDim;

            vec4 result = vec4(getValue(${a}), 0., 0., 0.);

            ${a[u-1]} = ${a[u-1]} + 1;
            if (${a[u-1]} < ${i[u-1]}) {
              result.g = getValue(${a});
            }

            ${a[u-2]} = ${a[u-2]} + 1;
            if (${a[u-2]} < ${i[u-2]}) {
              result.a = getValue(${a});
            }

            ${a[u-1]} = ${a[u-1]} - 1;
            if (${a[u-2]} < ${i[u-2]} &&
                ${a[u-1]} < ${i[u-1]}) {
              result.b = getValue(${a});
            }
            ${O.output} = result;
          }
        `;return{...e,output:{dims:i,type:n[0].type,textureType:2},shaderSource:C,hasMain:!0}},cc=(r,e,n)=>{let t=z0(e.length,n.cacheKey);return{...t,get:()=>N0(r,t,e,n.axis)}},gi=(r,e,n)=>{let t=r.indexOf(e);return r.map((i,u)=>u===t?`${i} - ${n}`:i).join()}});var pc,F0,V0,G0,hc,U0,W0,H0,mc,q0,gc=R(()=>{"use strict";xt();ze();fc();pc=(r,e,n)=>(q0(e),r.session.pack&&e[0].dims.length>1?[r.run(cc(r,e,n),e)]:[r.run(G0(r,e,n),e)]),F0=(r,e)=>({name:"Concat",inputNames:Array.from({length:r},(n,t)=>`X${t}`),inputTypes:Array(r).fill(0),cacheHint:e}),V0=(r,e,n,t)=>{let o=n[0].dims.slice();if(t>=o.length||t<-1*o.length)throw new Error("axis specified for concat doesn't match input dimensionality");t<0&&(t=o.length+t);let i=o.slice(0);for(let g=1;g<n.length;g++){let b=n[g].dims.slice();for(let y=0;y<o.length;y++)if(y===t)i[t]+=b[y];else if(o[y]!==b[y])throw new Error("non concat dimensions must match")}let u=i.length,a=new Array(n.length),s=0;for(let g=0;g<a.length;++g)s+=n[g].dims[t],a[g]=s;let l="";n.length<5?l=hc(a):l=U0(a);let d=W0(n.length,u),f=H0(a),p=`
        ${d}
        ${f}
        ${l}
        float process(int indices[${u}]) {
          int textureIndex = getTextureWhereDataResides (indices[${t}]);

          if(textureIndex != 0) {
            indices[${t}] = indices[${t}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return{...e,output:{dims:i,type:n[0].type,textureType:0},shaderSource:p}},G0=(r,e,n)=>{let t=F0(e.length,n.cacheKey);return{...t,get:()=>V0(r,t,e,n.axis)}},hc=r=>`int getTextureWhereDataResides(int index) {
      ${r.map((n,t)=>`if(index<${n}) {return ${t};}
`).join("")}
    }`,U0=r=>hc(r),W0=(r,e)=>{let n=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${e}]) {`];for(let t=0;t<r;++t)t===0?n.push(`	if (textureIndex == ${t}) { return _X${t}(indices); }`):t===r-1?n.push(`	else { return _X${t}(indices); }`):n.push(`	else if (textureIndex == ${t}) { return _X${t}(indices); }`);return n.push("	}"),n.join(`
`)},H0=r=>{let e=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let n=0;n<r.length;++n)n===0?e.push(`	if (index == ${n}) { return ${r[n]}; }`):n===r.length-1?e.push(`	else { return ${r[n]}; }`):e.push(`	else if (index == ${n}) { return ${r[n]}; }`);return e.push("	}"),e.join(`
`)},mc=r=>Ie({axis:r.attributes.getInt("axis")}),q0=r=>{if(!r||r.length<1)throw new Error("too few inputs");let e=r[0].type,n=r[0].dims.length;if(e==="string")throw new Error("string tensor is not supported yet");for(let t of r){if(t.type!==e)throw new Error("input tensors should be one type");if(t.dims.length!==n)throw new Error("input tensors should have the same shape")}}});function j0(){return jt("abs")}function K0(){return jt("acos")}function Y0(){return jt("asin")}function X0(){return jt("atan")}function Z0(){return jt("ceil")}function J0(){return jt("cos")}function Q0(r){let e="elu";return{body:`
  const float alpha = float(${r});

  float ${e}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${e}_(vec4 v) {
    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));
  }
  `,name:e,type:0}}function ev(){return jt("exp")}function tv(){return jt("floor")}function Qa(r,e){let n="clip";return{body:`
  const float min = float(${r});
  const float max = float(${e});

  float ${n}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${n}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:n,type:0}}function rv(){let r="indentity";return{body:`
  float ${r}_(float a) {
    return a;
  }
  vec4 ${r}_(vec4 v) {
    return v;
  }
  `,name:r,type:0}}function nv(r){let e="leakyRelu";return{body:`
  const float alpha = float(${r});

  float ${e}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${e}_(vec4 v) {
    return vec4(${e}_(v.x), ${e}_(v.y), ${e}_(v.z), ${e}_(v.w));
  }
  `,name:e,type:0}}function ov(){return jt("log")}function iv(){let r="neg";return{body:`
  float ${r}_(float a) {
    return -a;
  }
  vec4 ${r}_(vec4 v) {
    return -v;
  }
  `,name:r,type:0}}function av(){let r="not";return{body:`
  float ${r}_(float a) {
    return float( ! bool(a) );
  }
  bool ${r}_(bool a) {
    return !a;
  }
  vec4 ${r}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${r}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:r,type:0}}function sv(){return jt("sin")}function es(){let r="relu";return{body:`
  float ${r}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${r}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:r,type:0}}function ts(){let r="sigmoid";return{body:`
  float ${r}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${r}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:r,type:0}}function uv(){return jt("sqrt")}function lv(){return jt("tan")}function dv(){let r="tanh";return{body:`
  float ${r}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${r}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:r,type:0}}function jt(r){return{body:`
  float ${r}_(float a) {
    return ${r}(a);
  }
  vec4 ${r}_(vec4 v) {
    return ${r}(v);
  }
  `,name:r,type:0}}var cv,ft,bc,yc,vc,wc,rs,xc,$c,fv,Tc,_c,Sc,Ic,Ac,Oc,ns,Ec,Cc,Pc,kc,Dc,Bc,Rc,Mc,Lc,zc,Nc,os=R(()=>{"use strict";xt();He();Or();rt();ze();cv=(r,e,n,t)=>{let o=r.session.pack?2:0,i=le(r.session.backend.glContext.version);return{...e,output:{dims:n.dims,type:n.type,textureType:o},shaderSource:`
     ${t.body}
     void main() {
       vec4 v = ${i.texture2D}(A, TexCoords);
       v = ${t.name}_(v);
       ${i.output} = v;
     }
     `,hasMain:!0}},ft=(r,e,n,t)=>{let o=r.session.pack?2:0,i={name:n.name,inputTypes:[o],inputNames:["A"],cacheHint:t};return{...i,get:()=>cv(r,i,e,n)}},bc=(r,e)=>[r.run(ft(r,e[0],j0()),e)],yc=(r,e)=>[r.run(ft(r,e[0],K0()),e)],vc=(r,e)=>[r.run(ft(r,e[0],Y0()),e)],wc=(r,e)=>[r.run(ft(r,e[0],X0()),e)],rs=(r,e,n)=>[r.run(ft(r,e[0],Qa(n.min,n.max),n.cacheKey),e)],xc=r=>Ie({min:r.attributes.getFloat("min",tn),max:r.attributes.getFloat("max",rn)}),$c=(r,e)=>{let n=fv(r,e);return rs(r,[e[0]],n)},fv=(r,e)=>{if(e.length>=3&&(!r.session.isInitializer(e[1].dataId)||!r.session.isInitializer(e[2].dataId)))throw new Error("dynamic clip attributes are not allowed");let n=e.length>=3?e[1].numberData[0]:tn,t=e.length>=3?e[2].numberData[0]:rn;return Ie({min:n,max:t})},Tc=(r,e)=>[r.run(ft(r,e[0],Z0()),e)],_c=(r,e)=>[r.run(ft(r,e[0],J0()),e)],Sc=(r,e,n)=>[r.run(ft(r,e[0],Q0(n.alpha),n.cacheKey),e)],Ic=r=>Ie({alpha:r.attributes.getFloat("alpha",1)}),Ac=(r,e)=>[r.run(ft(r,e[0],ev()),e)],Oc=(r,e)=>[r.run(ft(r,e[0],tv()),e)],ns=(r,e)=>[r.run(ft(r,e[0],rv()),e)],Ec=(r,e,n)=>[r.run(ft(r,e[0],nv(n.alpha),n.cacheKey),e)],Cc=r=>Ie({alpha:r.attributes.getFloat("alpha",.01)}),Pc=(r,e)=>[r.run(ft(r,e[0],ov()),e)],kc=(r,e)=>[r.run(ft(r,e[0],iv()),e)],Dc=(r,e)=>[r.run(ft(r,e[0],av()),e)],Bc=(r,e)=>[r.run(ft(r,e[0],es()),e)],Rc=(r,e)=>[r.run(ft(r,e[0],ts()),e)],Mc=(r,e)=>[r.run(ft(r,e[0],sv()),e)],Lc=(r,e)=>[r.run(ft(r,e[0],uv()),e)],zc=(r,e)=>[r.run(ft(r,e[0],lv()),e)],Nc=(r,e)=>[r.run(ft(r,e[0],dv()),e)]});function fr(r){let e;switch(r.activation){case"Relu":e=es();break;case"Sigmoid":e=ts();break;case"Clip":e=Qa(r.clipMin,r.clipMax);break;default:return{activationFunction:"",applyActivation:""}}let n=e.name,t=e.body,o=`value = ${n}_(value);`;return{activationFunction:t,applyActivation:o}}var On,an=R(()=>{"use strict";He();os();On=r=>{let e=r.getString("activation","");if(e==="Clip"){let[n,t]=r.getFloats("activation_params",[tn,rn]);return{activation:e,clipMax:t,clipMin:n,activationCacheKey:`${e}:${n},${t}`}}return{activation:e,activationCacheKey:e}}});var hv,mv,Fc,Vc=R(()=>{"use strict";Vt();rt();ze();bi();an();hv=(r,e)=>({name:"GroupedConv",inputNames:r?["X","W","Bias"]:["X","W"],inputTypes:r?[0,0,0]:[0,0],cacheHint:e}),mv=(r,e,n,t)=>{let i=e.length>2?"value += getBias(output_channel);":"",u=e[0].dims.slice(),a=e[1].dims.slice(),s=a[0]/t.group;je.verbose("GroupedConv",`autpPad:${t.autoPad}, dilations:${t.dilations}, group:${t.group}, kernelShape:${t.kernelShape}, pads:${t.pads}, strides:${t.strides}`);let l=En(u,a,t.dilations,t.pads,t.strides),d=le(r.session.backend.glContext.version),{activationFunction:f,applyActivation:p}=fr(t),g=`
  const ivec2 strides = ivec2(${t.strides[0]}, ${t.strides[1]});
  const ivec2 pads = ivec2(${t.pads[0]}, ${t.pads[1]});
  ${f}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${s};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${a[1]}; wInChannel++) {
      int input_channel = group_id * ${a[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${a[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${t.dilations[0]};

        if (xHeight < 0 || xHeight >= ${u[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${a[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${t.dilations[1]};
          if (xWidth < 0 || xWidth >= ${u[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${i}
    ${p}
    ${d.output} = vec4(value, .0, .0, .0);
  }
`;return{...n,output:{dims:l,type:e[0].type,textureType:0},shaderSource:g,hasMain:!0}},Fc=(r,e,n)=>{let t=hv(e.length>2,n.cacheKey);return{...t,get:()=>mv(r,e,t,n)}}});var gv,bv,Gc,Uc=R(()=>{"use strict";rt();ze();on();gv=r=>({name:"Im2Col (packed)",inputNames:["A"],inputTypes:[2],cacheHint:r}),bv=(r,e,n,t,o,i)=>{let u=n.dims,a=t.dims,s=2,l=3,d=o.length,f=[a[1]*a[2]*a[3],o[2]*o[3]],p=a[2]*a[3],g=cr(),b=le(r.session.backend.glContext.version),y="";for(let x=0;x<=1;x++)for(let S=0;S<=1;S++)y+=`
            blockIndex = rc.x + ${S};
            pos = rc.y + ${x};

            if(blockIndex < ${f[1]} && pos < ${f[0]}) {
              offsetY = int(blockIndex / (${o[d-1]})) * ${i.strides[0]} -
                ${i.pads[0]};
              d0 = offsetY + ${i.dilations[0]} * (imod(pos, ${p}) / ${a[2]});

              if(d0 < ${u[s]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${o[d-1]}) * ${i.strides[1]} -
                  ${i.pads[1]};
                d1 = offsetX + ${i.dilations[1]} * imod(imod(pos, ${p}), ${a[2]});

                if(d1 < ${u[l]} && d1 >= 0) {

                  ch = int(float(pos)/ ${p}.);
                    innerDims = vec2(d0, d1);
                    result[${x*2+S}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;let _=`
      ${g}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${y}
          ${b.output} = result;
      }
            `;return{...e,output:{dims:f,type:n.type,textureType:2},shaderSource:_,hasMain:!0}},Gc=(r,e,n,t,o)=>{let i=gv(o.cacheKey);return{...i,get:()=>bv(r,i,e,n,t,o)}}});function vv(r,e,n){let t=e[0].dims,o=e[1].dims,i=Ct.calcShape(t,o,!0);if(!i)throw new Error("Can't use matmul on the given tensors");let u=Pt(i.length),a=tr(),{activationFunction:s,applyActivation:l}=fr(n),d=e.length>2,f=d?"value += getBiasForMatmul();":"",p=d?`${as(u,a,e[2].dims,i,!1)}`:"",g=i.length,b=t.length,y=o.length,_=t[t.length-1],x=`
    ${s}
    ${p}
    float process(int indices[${g}]) {
        int a[${b}];
        int b[${y}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${_}; ++k) {
            a[${b-1}] = k;
            b[${y-2}] = k;
            value += _A(a) * _B(b);
        }
        ${f}
        ${l}
        return value;
    }`;return{...r,output:{dims:i,type:e[0].type,textureType:0},shaderSource:x}}function is(r,e){let n=yv(r.length>2,e.activationCacheKey);return{...n,get:()=>vv(n,r,e)}}function as(r,e,n,t,o){let i="",u=n.length,a=t.length,s=a-u;a<2&&u>0?i="coords":i=n.map((y,_)=>`coords.${e[_+s]}`).join(", ");let d=Ct.getBroadcastDims(n,t).map(y=>`coords.${e[y+s]} = 0;`).join(`
`),p=oe.size(n)===1,g="vec4(outputValue.xx, outputValue.yy)";return p&&(g="vec4(outputValue.x)"),o?`
vec4 getBiasForMatmul() {
  ${r} coords = getOutputCoords();
  ${d}
  vec4 outputValue = getBias(${i});
  return ${g};
}`:`
float getBiasForMatmul() {
  ${r} coords = getOutputCoords();
  ${d}
  return getBias(coords.x);
}`}var Wc,Hc,yv,wv,yi=R(()=>{"use strict";He();ze();dr();an();ss();Wc=(r,e,n)=>(wv(e),r.session.pack?[r.run(vi(r,e,n),e)]:[r.run(is(e,n),e)]),Hc=r=>On(r.attributes),yv=(r,e)=>({name:"MatMul",inputNames:r?["A","B","Bias"]:["A","B"],inputTypes:r?[0,0,0]:[0,0],cacheHint:e});wv=r=>{if(!r||r.length!==2)throw new Error("MatMul requires 2 inputs.");if(r[0].dims[r[0].dims.length-1]!==r[1].dims[r[1].dims.length-2])throw new Error("shared dimension does not match.");if(r[0].type!=="float32"&&r[0].type!=="float64"||r[1].type!=="float32"&&r[1].type!=="float64")throw new Error("inputs should be float type");if(r[0].type!==r[1].type)throw new Error("inputs types should match")}});function Tv(r,e,n,t){let o=[],i=[],u=n[0].dims,a=n[1].dims,s=u.length,l=a.length,d=t.length,f=d-s,p=d-l;o=u.map((O,C)=>`coords.${e[C+f]}`),o[s-1]="i*2",o.join(", "),i=a.map((O,C)=>`coords.${e[C+p]}`),i[l-2]="i*2",i.join(", ");let g=Ct.getBroadcastDims(u,t),b=Ct.getBroadcastDims(a,t),y=g.map(O=>`coords.${e[O+f]} = 0;`).join(`
`),_=b.map(O=>`coords.${e[O+p]} = 0;`).join(`
`),x=`int lastDim = coords.${e[d-1]};
  coords.${e[d-1]} = coords.${e[d-2]};
  coords.${e[d-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${r} coords = getOutputCoords();
  ${x}
  ${y}
  vec4 outputValue = getA(${o});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${r} coords = getOutputCoords();
  ${x}
  ${_}
  vec4 outputValue = getB(${i});
  return outputValue;
}`}function _v(r,e){let n="";for(let t=0;t<e-2;t++)n+=`rc.${r[t]}, `;return n+=`rc.${r[e-2]}, i*2`,n}function Sv(r,e){let n="";for(let t=0;t<e-2;t++)n+=`rc.${r[t]}, `;return n+=`i*2, rc.${r[e-1]}`,n}var xv,$v,vi,ss=R(()=>{"use strict";He();rt();ze();dr();an();yi();xv=(r,e)=>({name:"MatMul (packed)",inputNames:r?["A","B","Bias"]:["A","B"],inputTypes:r?[2,2,2]:[2,2],cacheHint:e}),$v=(r,e,n,t)=>{let o=n.length>2,i=o?"value += getBiasForMatmul();":"",u=n[0].dims,a=n[1].dims,s=Ct.calcShape(u,a,!0),l=!oe.areEqual(n[0].dims,n[1].dims);if(!s)throw new Error("Can't use matmul on the given tensors");let d=u[u.length-1],f=Math.ceil(d/2),p=u.length,g=a.length,b=le(r.session.backend.glContext.version),y=Pt(s.length),_=s.length,x=tr(),{activationFunction:S,applyActivation:O}=fr(t),C=o?`${as(y,x,n[2].dims,s,!0)}`:"",N=l?`${Tv(y,x,n,s)}`:"",k=l?"getAAtOutCoordsMatmul(i)":`getA(${_v(x,p)})`,U=l?"getBAtOutCoordsMatmul(i)":`getB(${Sv(x,g)})`,G=l?"":`${y} rc =
          getOutputCoords(); int lastDim = rc.${x[_-1]}; rc.${x[_-1]} =
          rc.${x[_-2]}; rc.${x[_-2]} = lastDim;
      `,H=`
            ${N}
            ${C}
            ${S}
            void main() {
              ${G}

              vec4 value = vec4(0);
              for (int i = 0; i < ${f}; i++) {
                vec4 a = ${k};
                vec4 b = ${U};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${i}
              ${O}
              ${b.output} = value;
            }`;return{...e,output:{dims:s,type:n[0].type,textureType:2},shaderSource:H,hasMain:!0}},vi=(r,e,n)=>{let t=xv(e.length>2,n.activationCacheKey);return{...t,get:()=>$v(r,t,e,n)}}});var qc,jc=R(()=>{"use strict";bi();Uc();ss();qc=(r,e,n)=>{let t=e[0].dims,o=e[1].dims,i=En(t,o,n.dilations,n.pads,n.strides),u=r.run(Gc(r,e[0],e[1],i,n),[e[0]]),a=r.reshapePacked(e[1],[o[0],o[1]*o[2]*o[3]]),s=e.length===3?[a,u,e[2]]:[a,u],l=r.run(vi(r,s,n),s);return r.reshapePacked(l,i)}});var Iv,Av,Kc,us,ls=R(()=>{"use strict";ze();Iv=r=>({name:"Im2Col",inputNames:["X"],inputTypes:[0],cacheHint:r}),Av=(r,e,n,t,o,i)=>{let u=n.dims,a=t.dims,s=o.length,l=us(u,a,o,4),d=`
        const int XC = ${u[1]};
        const int XH = ${u[2]};
        const int XW = ${u[3]};
        const int KH = ${i.kernelShape[0]};
        const int KW = ${i.kernelShape[1]};
        const int dilationH = ${i.dilations[0]};
        const int dilationW = ${i.dilations[1]};
        const int strideH = ${i.strides[0]};
        const int strideW = ${i.strides[1]};
        const int padH = ${i.pads[0]};
        const int padW = ${i.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${s}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${u.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return{...e,output:{dims:l,type:n.type,textureType:4},shaderSource:d}},Kc=(r,e,n,t,o)=>{let i=Iv(o.cacheKey);return{...i,get:()=>Av(r,i,e,n,t,o)}},us=(r,e,n,t=4)=>[n[0],n[2],n[3],Math.ceil(r[1]*e[2]*e[3]/t)]});var Ov,Ev,Yc,Xc=R(()=>{"use strict";He();rt();ze();an();ls();Ov=(r,e)=>({name:"ConvDotProduct",inputNames:r?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:r?[0,4,0]:[0,4],cacheKey:e.activationCacheKey}),Ev=(r,e,n,t,o)=>{let i=n[0].dims,u=n[1].dims,a=[u[0],Math.ceil(i[1]*u[2]*u[3]/4)],s=us(i,u,t),[l,d]=r.calculateTextureWidthAndHeight(a,4),f=oe.computeStrides(s),[p,g]=r.calculateTextureWidthAndHeight(s,4),b=t.length,y=n.length<3?"0.0":"_B(b)",_=Math.ceil(i[1]*u[2]*u[3]/4),{activationFunction:x,applyActivation:S}=fr(o),O=le(r.session.backend.glContext.version),C=`
${x}
float process(int indices[${b}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${f[0]} + im2col[1] * ${f[1]} + im2col[2] * ${f[2]};
  int kernelOffset = indices[1] * ${a[1]};
  float value = ${y};
  for (int i = 0; i < ${_}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${p}, ${g});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${l}, ${d});
    value += dot(${O.texture2D}(Im2Col, im2colCoords), ${O.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${S}
  return value;
}`;return{...e,output:{dims:t,type:n[0].type,textureType:0},shaderSource:C}},Yc=(r,e,n,t)=>{let o=Ov(e.length>2,t);return{...o,get:()=>Ev(r,o,e,n,t)}}});var En,ds,Cv,Pv,kv,Dv,cs,Bv,bi=R(()=>{"use strict";xt();He();Vc();jc();Xc();an();ls();yi();En=(r,e,n,t,o)=>{let i=r[0],u=r.slice(2),a=u.length,s=e[0],d=e.slice(2).map((b,y)=>b+(b-1)*(n[y]-1)),p=u.map((b,y)=>b+t[y]+t[y+a]).map((b,y)=>Math.floor((b-d[y]+o[y])/o[y]));return[i,s].concat(...p)},ds=(r,e,n)=>(Bv(e,n),Cv(r,e,n)),Cv=(r,e,n)=>{let t=Dv(n,e),o=r.session.pack,i=t.kernelShape[0]===1&&t.kernelShape[1]===1;return t.group>1?[r.run(Fc(r,e,t),e)]:i&&o?[Pv(r,e,t)]:o&&e[0].dims.length===4&&e[0].dims[0]===1&&!i?[qc(r,e,t)]:[kv(r,e,t)]},Pv=(r,e,n)=>{let t=e[0].dims,o=e[1].dims,i=En(t,o,n.dilations,n.pads,n.strides),u=r.reshapeUnpacked(e[0],[t[1],t[2]*t[3]]),a=r.reshapeUnpacked(e[1],[o[0],o[1]]),s=e.length>2?[a,u,e[2]]:[a,u],l=r.run(is(s,n),s);return r.reshapeUnpacked(l,i)},kv=(r,e,n)=>{let t=e[0].dims,o=e[1].dims,i=En(t,o,n.dilations,n.pads,n.strides),u=r.run(Kc(r,e[0],e[1],i,n),[e[0]]),a=e.length===3?[u,e[1],e[2]]:[u,e[1]];return r.run(Yc(r,e,i,n),a)},Dv=(r,e)=>{let n=r.kernelShape.slice();if(r.kernelShape.length===0)for(let i=2;i<e[1].dims.length;++i)n.push(e[1].dims[i]);let t=r.pads.slice();en.adjustPadsBasedOnAutoPad(e[0].dims,r.strides,r.dilations,n,t,r.autoPad);let o=Object.assign({},r);return Object.assign(o,{kernelShape:n,pads:t,cacheKey:r.cacheKey}),o},cs=r=>{let e=r.attributes,n=On(e),t=e.getString("auto_pad","NOTSET"),o=e.getInts("dilations",[1,1]),i=e.getInt("group",1),u=e.getInts("kernel_shape",[]),a=e.getInts("pads",[0,0,0,0]),s=e.getInts("strides",[1,1]);return Ie({autoPad:t,dilations:o,group:i,kernelShape:u,pads:a,strides:s,...n})},Bv=(r,e)=>{if(!r||r.length!==2&&r.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(r[0].dims.length!==4||r[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let n=r[0].dims[1],t=r[1].dims[1]*e.group;if(n!==t)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(r.length===3&&(r[2].dims.length!==1||r[1].dims[0]!==r[2].dims[0]))throw new Error("invalid bias");let o=r[0].dims.length-2;if(e.dilations.length!==o)throw new Error(`dilations should be ${o}D`);if(e.strides.length!==o)throw new Error(`strides should be ${o}D`);if(e.pads.length!==o*2)throw new Error(`pads should be ${o*2}D`);if(e.kernelShape.length!==0&&e.kernelShape.length!==r[1].dims.length-2)throw new Error("invalid kernel shape");if(r[0].type!=="float32"||r[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(r.length===3&&r[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}});var Rv,Mv,Lv,Zc,zv,Nv,Fv,Vv,Gv,Uv,Jc,Wv,Qc=R(()=>{"use strict";xt();rt();ze();an();Rv=(r,e,n,t,o,i)=>(r-1)*e+n+(t-1)*o+1-i,Mv=(r,e,n,t,o)=>{let i=Math.floor(r/2);e==="SAME_UPPER"?(n[t]=i,n[o]=r-i):e==="SAME_LOWER"&&(n[t]=r-i,n[o]=i)},Lv=(r,e,n,t,o,i,u,a)=>{let s=r.length-2,l=a.length===0;for(let d=0;d<s;++d){let f=l?r[d+2]*i[d]:a[d],p=Rv(r[d+2],i[d],o[d],e[d],n[d],f);Mv(p,t,o,d,d+s),l&&a.push(i[d]*(r[d+2]-1)+u[d]+(e[d]-1)*n[d]+1-o[d]-o[d+s])}},Zc=(r,e,n)=>(Wv(e,n),zv(r,e,n)),zv=(r,e,n)=>{let t=Uv(n,e);return[Gv(r,e,t)]},Nv=(r,e)=>({name:"ConvTranspose",inputNames:r?["X","W","B"]:["X","W"],inputTypes:r?[0,0,0]:[0,0],cacheHint:e}),Fv=(r,e,n,t)=>{let i=e.length>2?"getB(output_channel)":"0.0",u=e[0].dims,a=e[1].dims,s=a[1],l=a[0]/t.group,d=[e[0].dims[0],e[1].dims[1]*t.group,...t.outputShape],f=le(r.session.backend.glContext.version),{activationFunction:p,applyActivation:g}=fr(t),b=`
  const ivec2 strides = ivec2(${t.strides[0]}, ${t.strides[1]});
  const ivec2 pads = ivec2(${t.pads[0]}, ${t.pads[1]});
  ${p}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${s};
    int wOutChannel = output_channel - group_id * ${s};

    float value = ${i};
    for (int inChannelOffset = 0; inChannelOffset < ${l}; inChannelOffset++) {
      int input_channel = group_id * ${l} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${a[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${a[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${t.dilations[0]}, wHOff * ${t.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${u[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${u[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${g}
    ${f.output} = vec4(value, .0, .0, .0);
  }
`;return{...n,output:{dims:d,type:e[0].type,textureType:0},shaderSource:b,hasMain:!0}},Vv=(r,e,n)=>{let t=Nv(e.length>2,n.cacheKey);return{...t,get:()=>Fv(r,e,t,n)}},Gv=(r,e,n)=>r.run(Vv(r,e,n),e),Uv=(r,e)=>{let n=r.kernelShape.slice();if(r.kernelShape.length===0)for(let a=2;a<e[1].dims.length;++a)n.push(e[1].dims[a]);let t=r.pads.slice(),o=r.outputShape.slice(),i=e[0].dims;Lv(i,n,r.dilations,r.autoPad,t,r.strides,r.outputPadding,o);let u=Object.assign({},r);return Object.assign(u,{kernelShape:n,pads:t,outputShape:o,cacheKey:r.cacheKey}),u},Jc=r=>{let e=r.attributes,n=On(e),t=e.getString("auto_pad","NOTSET"),o=e.getInts("dilations",[1,1]),i=e.getInt("group",1),u=e.getInts("kernel_shape",[]),a=e.getInts("output_padding",[0,0]),s=e.getInts("output_shape",[]),l=e.getInts("pads",[0,0,0,0]),d=e.getInts("strides",[1,1]);return Ie({autoPad:t,dilations:o,group:i,kernelShape:u,outputPadding:a,outputShape:s,pads:l,strides:d,...n})},Wv=(r,e)=>{if(!r||r.length!==2&&r.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(r[0].dims.length!==4||r[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let n=r[0].dims[1],t=r[1].dims[0];if(n!==t)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let o=r[1].dims[1]*e.group;if(r.length===3&&(r[2].dims.length!==1||r[2].dims[0]!==o))throw new Error("invalid bias");let i=r[0].dims.length-2;if(e.dilations.length!==i)throw new Error(`dilations should be ${i}D`);if(e.strides.length!==i)throw new Error(`strides should be ${i}D`);if(e.pads.length!==i*2)throw new Error(`pads should be ${i*2}D`);if(e.outputPadding.length!==i)throw new Error(`output_padding should be ${i}D`);if(e.kernelShape.length!==0&&e.kernelShape.length!==r[1].dims.length-2)throw new Error("invalid kernel shape");if(e.outputShape.length!==0&&e.outputShape.length!==r[0].dims.length-2)throw new Error("invalid output shape");if(r[0].type!=="float32"||r[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(r.length===3&&r[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}});var ef,sn,tf,Hv,rf,qv,jv,Kv,wi=R(()=>{"use strict";xt();He();ze();ef={name:"Transpose",inputNames:["A"],inputTypes:[0]},sn=(r,e,n)=>(Kv(e),[r.run({...ef,cacheHint:n.cacheKey,get:()=>Hv(r,e[0],n.perm)},e)]),tf=r=>Ie({perm:r.attributes.getInts("perm",[])}),Hv=(r,e,n)=>{let t=e.dims;n=rf(t,n);let o=qv(t,n),i=t.length,u=`
      ${jv("perm",n,i)}
      float process(int indices[${i}]) {
        int a[${i}];
        perm(a, indices);
        return _A(a);
      }`;return{...ef,output:{dims:o,type:e.type,textureType:0},shaderSource:u}},rf=(r,e)=>(e&&e.length!==r.length&&(e=[...r.keys()].reverse()),e),qv=(r,e)=>(e=rf(r,e),oe.sortBasedOnPerm(r,e)),jv=(r,e,n)=>{let t=[];t.push(`void ${r}(out int a[${n}], int src[${n}]) {`);for(let o=0;o<n;++o)t.push(`	a[${e[o]}]=src[${o}];`);return t.push("	}"),t.join(`
`)},Kv=r=>{if(!r||r.length!==1)throw new Error("Transpose requires 1 input.");if(r[0].type!=="float32"&&r[0].type!=="float64")throw new Error("input should be float tensor")}});var nf,of,Yv,af=R(()=>{"use strict";wi();nf=(r,e,n)=>{Yv(e);let t=n.blocksize,o=t*t,i=n.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],u=n.mode==="DCR"?[e[0].dims[0],t,t,e[0].dims[1]/o,e[0].dims[2],e[0].dims[3]]:[e[0].dims[0],e[0].dims[1]/o,t,t,e[0].dims[2],e[0].dims[3]],a=r.reshapeUnpacked(e[0],u),s={perm:i,cacheKey:`${i}`},[l]=sn(r,[a],s),d=[e[0].dims[0],e[0].dims[1]/o,e[0].dims[2]*t,e[0].dims[3]*t];return[r.reshapeUnpacked(l,d)]},of=r=>{let e=r.attributes.getInt("blocksize");if(e<1)throw new Error(`blocksize must be >= 1, but got : ${e} for DepthToSpace`);let n=r.attributes.getString("mode","DCR");if(n!=="DCR"&&n!=="CRD")throw new Error(`unrecognized mode: ${n} for DepthToSpace`);return{mode:n,blocksize:e}},Yv=r=>{if(r.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${r.length}`);if(r[0].type==="string"||r[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}});var sf,uf,Xv,lf=R(()=>{"use strict";He();sf=(r,e,n)=>{Xv(e,n);let t=oe.flattenShape(e[0].dims,n);return[r.reshapeUnpacked(e[0],t)]},uf=r=>r.attributes.getInt("axis",1),Xv=(r,e)=>{if(!r||r.length!==1)throw new Error("Flatten requires 1 input.");let n=r[0].dims.length;if(n===0)throw new Error("scalar tensor is not supported.");if(e<-n||e>n)throw new Error("Invalid axis");if(r[0].type==="string")throw new Error("string tensor is not supported.")}});var Lr,po=R(()=>{"use strict";Lr=["float32","float64","int32","int16","int8","uint16","uint32","uint8"]});var df,cf,Zv,Jv,Qv,ew,ff=R(()=>{"use strict";xt();po();He();ze();df=(r,e,n)=>(ew(e,n.axis),[r.run(Qv(r,e,n),e)]),cf=r=>Ie({axis:r.attributes.getInt("axis",0)}),Zv={name:"Gather",inputNames:["A","B"],inputTypes:[0,0]},Jv=(r,e,n,t)=>{let o=n[0].dims.slice(),i=n[1].dims.slice(),u=new Array(o.length+i.length-1);t=oe.normalizeAxis(t,o.length);let a=[];for(let p=0;p<u.length;p++)p<t?(u[p]=o[p],a.push(`inputIdx[${p}] = outputIdx[${p}];`)):p<t+i.length?(u[p]=i[p-t],a.push(`indexDataIdx[${p-t}] = outputIdx[${p}];`)):(u[p]=o[p-i.length+1],a.push(`inputIdx[${p-i.length+1}] = outputIdx[${p}];`));let s=u.length||1,l=o.length,d=i.length||1,f=`
      float process(int outputIdx[${s}]) {
        int inputIdx[${l}];
        int indexDataIdx[${d}];
        indexDataIdx[0] = 0;
        ${a.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${t}] = idx < 0 ? idx + ${o[t]} : idx;
        return _A(inputIdx);
      }`;return{...e,output:{dims:u,type:n[0].type,textureType:0},shaderSource:f}},Qv=(r,e,n)=>{let t={...Zv,cacheHint:n.cacheKey};return{...t,get:()=>Jv(r,t,e,n.axis)}},ew=(r,e)=>{if(!r||r.length!==2)throw new Error("Gather requires 2 inputs.");let n=r[0].dims.length;if(n<1)throw new Error("Invalid input shape.");if(e<-n||e>n-1)throw new Error("Invalid axis.");if(Lr.indexOf(r[0].type)===-1)throw new Error("Invaid input type.");if(r[1].type!=="int32"&&r[1].type!=="int16")throw new Error("Invaid input type.")}});var fs,pf,hf,mf,tw,rw,nw,gf=R(()=>{"use strict";xt();He();ze();fs=(r,e,n)=>(nw(e,n),[r.run(tw(e,n),e)]),pf=(r,e)=>{let n=r.attributes.getInt("transA",0)!==0,t=r.attributes.getInt("transB",0)!==0,o=r.attributes.getFloat("alpha",1),i=r.attributes.getFloat("beta",1);return Ie({transA:n,transB:t,alpha:o,beta:i,isOptionalC:e})},hf=r=>pf(r,!1),mf=r=>pf(r,!0),tw=(r,e)=>{let n={name:"Gemm",inputNames:r.length===3?["A","B","C"]:["A","B"],inputTypes:r.length===3?[0,0,0]:[0,0],key:e.cacheKey};return{...n,get:()=>rw(n,r,e)}},rw=(r,e,n)=>{let t=e[0].dims.slice(),o=e[1].dims.slice(),[i,u]=li.getShapeOfGemmResult(t,n.transA,o,n.transB,e.length===3?e[2].dims:void 0),a=[i,u];if(!a)throw new Error("Can't use gemm on the given tensors");let s=t[t.length-1],l="";n.transA&&(s=t[0]),n.transA&&n.transB?l="value += _A_T(a) * _B_T(b);":n.transA&&!n.transB?l="value += _A_T(a) * _B(b);":!n.transA&&n.transB?l="value += _A(a) * _B_T(b);":!n.transA&&!n.transB&&(l="value += _A(a) * _B(b);");let d=a.length,f=e.length===3?`int c[${e[2].dims.length}];`:"",p=e.length===3?"bcastIndices_C(indices, c);":"",g=e.length===3?"value += beta * _C(c);":"",b=`
      float process(int indices[${d}]) {
          int a[${d}];
          int b[${d}];
          ${f}

          copyVec(indices, a);
          copyVec(indices, b);
          ${p}

          float value = 0.0;
          for (int k=0; k<${s}; ++k) {
              a[${d-1}] = k;
              b[${d-2}] = k;
              ${l}
          }

          value = value * alpha;
          ${g}
          return value;
      }`;return{...r,output:{dims:a,type:e[0].type,textureType:0},variables:[{name:"alpha",type:"float",data:n.alpha},{name:"beta",type:"float",data:n.beta}],shaderSource:b}},nw=(r,e)=>{if(!r)throw new Error("Input is missing");if(e.isOptionalC&&(r.length<2||r.length>3))throw new Error("Invaid input shape.");if(!e.isOptionalC&&r.length!==3)throw new Error("Gemm requires 3 inputs");if(r.length===3&&r[2].dims.length!==1&&r[2].dims.length!==2)throw new Error("Invalid input shape of C");if(r[0].type!=="float32"&&r[0].type!=="float64"||r[1].type!=="float32"&&r[1].type!=="float64"||r.length===3&&r[2].type!=="float32"&&r[2].type!=="float64")throw new Error("Invalid input type.");if(r[0].type!==r[1].type||r.length===3&&r[0].type!==r[2].type)throw new Error("Input types are mismatched")}});var bf,yf,ow,iw,aw,sw,uw,vf=R(()=>{"use strict";xt();ze();bf=(r,e,n)=>(uw(e),[r.run(aw(r,e,n),e)]),yf=r=>{let e=r.attributes.getFloat("scale"),n=r.attributes.getFloats("bias");return Ie({scale:e,bias:n})},ow={name:"ImageScaler",inputNames:["X"],inputTypes:[0]},iw=(r,e,n,t)=>{let o=n[0].dims.slice(),i=o.length,a=`
      ${sw(t.bias.length)}
      float process(int indices[${i}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return{...e,output:{dims:o,type:n[0].type,textureType:0},variables:[{name:"bias",type:"float",arrayLength:t.bias.length,data:t.bias},{name:"scale",type:"float",data:t.scale}],shaderSource:a}},aw=(r,e,n)=>{let t={...ow,cacheHint:n.cacheKey};return{...t,get:()=>iw(r,t,e,n)}},sw=r=>{let e=[`float getBias(float bias[${r}], int channel) {`];for(let n=0;n<r;++n)n===0?e.push(`	if (channel == ${n}) { return bias[${n}]; }`):n===r-1?e.push(`	else { return bias[${n}]; }`):e.push(`	else if (channel == ${n}) { return bias[${n}]; }`);return e.push("	}"),e.join(`
`)},uw=r=>{if(!r||r.length!==1)throw new Error("ImageScaler requires 1 input.");if(r[0].dims.length!==4)throw new Error("Invalid input shape.");if(r[0].type!=="float32"&&r[0].type!=="float64")throw new Error("Invalid input type.")}});var xf,$f,wf,lw,dw,cw,fw,pw,hw,Tf=R(()=>{"use strict";rt();ze();xf=(r,e,n)=>{hw(e);let t=r.run(dw(e[0]),e);return[r.run(pw(r,e[0],n,t.dims),[e[0],t,e[1],e[2]])]},$f=r=>r.attributes.getFloat("epsilon",1e-5),wf={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[0]},lw=(r,e)=>{let n=e.dims.slice(),t=n[1],o=n[2]*n[3],i=[n[0],t],u=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${n[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${n[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${o});
        temp = 0.0;
        for(int a2=0; a2<${n[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${n[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${o});

        return v;
      }`;return{...r,output:{dims:i,type:e.type,textureType:4},shaderSource:u}},dw=r=>({...wf,get:()=>lw(wf,r)}),cw={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[0,4,0,0]},fw=(r,e,n,t,o)=>{let i=le(r.session.backend.glContext.version),[u,a]=r.calculateTextureWidthAndHeight(o,4),[s,l]=[u/4,a],d=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${s}, ${l});
        return ${i.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return{...e,output:{dims:n.dims,type:n.type,textureType:0},variables:[{name:"epsilon",type:"float",data:t}],shaderSource:d}},pw=(r,e,n,t)=>{let o={...cw,cacheHint:`${n}`};return{...o,get:()=>fw(r,o,e,n,t)}},hw=r=>{if(!r||r.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");let e=r[0],n=r[1],t=r[2];if(e.dims.length<3||n.dims.length!==1||t.dims.length!==1)throw new Error("Invalid input shape.");if(n.dims[0]!==e.dims[1]||t.dims[0]!==e.dims[1])throw new Error("Input shapes are mismatched.");if(e.type!=="float32"&&e.type!=="float64"||n.type!=="float32"&&n.type!=="float64"||t.type!=="float32"&&t.type!=="float64")throw new Error("Invalid input type.");if(r[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}});function mw(r,e){let n=r[0].dims[1],t=r[0].dims.length,o=-Math.floor((e.size-1)/2),i=Math.ceil((e.size-1)/2),u=`float(${e.alpha}) / float(${e.size})`,a=`float(${e.bias})`,s=`float(${e.beta})`,l=`
    float process(int indices[${t}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${o}; i <= ${i}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${n}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(${a} + ${u} * square_sum, ${s});
    }`;return{...If,cacheHint:e.cacheKey,output:{dims:r[0].dims,type:r[0].type,textureType:0},shaderSource:l}}function gw(r,e){return{...If,cacheHint:e.cacheKey,get:()=>mw(r,e)}}var _f,Sf,If,bw,Af=R(()=>{"use strict";xt();ze();_f=(r,e,n)=>(bw(e),[r.run(gw(e,n),e)]),Sf=r=>{let e=r.attributes.getFloat("alpha",1e-4),n=r.attributes.getFloat("beta",.75),t=r.attributes.getFloat("bias",1),o=r.attributes.getInt("size");return Ie({alpha:e,beta:n,bias:t,size:o})},If={name:"LRN",inputNames:["X"],inputTypes:[0]};bw=r=>{if(!r||r.length!==1)throw new Error("LRN requires 1 input.");if(r[0].dims.length!==4)throw new Error('currently only support LRN for input with "NCHW" format');if(r[0].type!=="float32")throw new Error("input should be float type")}});var yw,ps,Of,Ef,Cf,vw,ww,xw,$w,Tw,_w,Sw,Iw,Pf=R(()=>{"use strict";xt();He();rt();ze();yw={name:"Pad",inputNames:["A"],inputTypes:[0]},ps=(r,e,n)=>(xw(e),[r.run({...yw,cacheHint:n.cacheKey,get:()=>ww(r,e[0],n)},e)]),Of=r=>{let e=r.attributes.getString("mode","constant"),n=r.attributes.getFloat("value",0),t=r.attributes.getInts("pads");return Ie({mode:e,value:n,pads:t})},Ef=(r,e,n)=>{$w(e);let t=vw(r,e,n);return ps(r,[e[0]],t)},Cf=r=>r.attributes.getString("mode","constant"),vw=(r,e,n)=>{if(!r.session.isInitializer(e[1].dataId)||e.length>=3&&!r.session.isInitializer(e[2].dataId))throw new Error("dynamic pad attributes are not allowed");let t=Array.from(e[1].integerData),o=e.length>=3?e[2].floatData[0]:0;return Ie({mode:n,pads:t,value:o})},ww=(r,e,n)=>{let t=oe.padShape(e.dims.slice(),n.pads),o=t.length,u=`
      ${Tw(r,e,n)}
      float process(int[${o}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[0],output:{dims:t,type:e.type,textureType:0},shaderSource:u}},xw=r=>{if(!r||r.length!==1)throw new Error("Pad requires 1 input");if(r[0].type!=="float32"&&r[0].type!=="float64")throw new Error("Invalid input type.")},$w=r=>{if(!r||r.length!==2&&r.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(r[1].type!=="int32")throw new Error("Invalid input type.");if(r.length>=3&&r[2].type==="string")throw new Error("Invalid input type.")},Tw=(r,e,n)=>{let t=le(r.session.backend.glContext.version),[o,i]=r.calculateTextureWidthAndHeight(e.dims,0),u=oe.computeStrides(e.dims);switch(n.mode){case"constant":return _w(t,e.dims,u,o,i,n.pads,n.value);case"reflect":return Sw(t,e.dims,u,o,i,n.pads);case"edge":return Iw(t,e.dims,u,o,i,n.pads);default:throw new Error("Invalid mode")}},_w=(r,e,n,t,o,i,u)=>{let a=e.length,s="";for(let l=a-1;l>=0;--l)s+=`
        k = m[${l}] - ${i[l]};
        if (k < 0)  return constant;
        if (k >= ${e[l]}) return constant;
        offset += k * ${n[l]};
        `;return`
      float padA(int m[${a}]) {
        const float constant = float(${u});
        int offset = 0;
        int k = 0;
        ${s}
        vec2 coords = offsetToCoords(offset, ${t}, ${o});
        float value = getColorAsFloat(${r.texture2D}(A, coords));
        return value;
      }
      `},Sw=(r,e,n,t,o,i)=>{let u=e.length,a="";for(let s=u-1;s>=0;--s)a+=`
        k = m[${s}] - ${i[s]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(e[s]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${e[s]}) { k = _2n_1 - k; }
        }
        offset += k * ${n[s]};
        `;return`
      float padA(int m[${u}]) {
        int offset = 0;
        int k = 0;
        ${a}
        vec2 coords = offsetToCoords(offset, ${t}, ${o});
        float value = getColorAsFloat(${r.texture2D}(A, coords));
        return value;
      }
      `},Iw=(r,e,n,t,o,i)=>{let u=e.length,a="";for(let s=u-1;s>=0;--s)a+=`
        k = m[${s}] - ${i[s]};
        if (k < 0)  k = 0;
        if (k >= ${e[s]}) k = ${e[s]-1};
        offset += k * ${n[s]};
      `;return`
      float padA(int m[${u}]) {
        int offset = 0;
        int k = 0;
        ${a}
        vec2 coords = offsetToCoords(offset, ${t}, ${o});
        float value = getColorAsFloat(${r.texture2D}(A, coords));
        return value;
      }
      `}});var Df,Bf,Rf,Mf,Lf,zf,Nf,Ff,Vf,Aw,kf,Gf,$i,Uf,xi,Ow,Wf=R(()=>{"use strict";xt();He();ze();Df=(r,e,n)=>{$i(e);let t={name:"AveragePool",inputNames:["X"],inputTypes:[0],cacheHint:n.cacheKey};return[r.run({...t,get:()=>Rf(e,t,!1,n)},e)]},Bf=r=>{let e=r.attributes.getString("auto_pad","NOTSET"),n=r.attributes.getInt("ceil_mode",0),t=r.attributes.getInt("count_include_pad",0)!==0,o=r.attributes.getInts("kernel_shape"),i=r.attributes.getInts("strides",[]),u=r.attributes.getInts("pads",[]);if(n!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return Ie({autoPad:e,ceilMode:n,countIncludePad:t,kernelShape:o,strides:i,pads:u})},Rf=(r,e,n,t)=>{let[o,i]=Vf(r,t,n),u=oe.size(o.kernelShape),a="value += _X(x);",s="";o.countIncludePad?s+=`value /= float(${u});`:s+=`value /= float(${u} - pad);`;let d=`
        ${Uf(r[0].dims,o,a,s,"0.0")}
      `;return{...e,output:{dims:i,type:r[0].type,textureType:0},shaderSource:d}},Mf=(r,e,n)=>{$i(e);let t={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[0],cacheHint:`${n.countIncludePad}`};return[r.run({...t,get:()=>Rf(e,t,!0,n)},e)]},Lf=r=>{let e=r.attributes.getInt("count_include_pad",0)!==0;return Ie({autoPad:"",ceilMode:0,countIncludePad:e,kernelShape:[],strides:[],pads:[]})},zf=(r,e,n)=>{$i(e);let t={name:"MaxPool",inputNames:["X"],inputTypes:[0],cacheHint:n.cacheKey};return[r.run({...t,get:()=>Ff(e,t,!1,n)},e)]},Nf=r=>{let e=r.attributes.getString("auto_pad","NOTSET"),n=r.attributes.getInt("ceil_mode",0),t=r.attributes.getInts("kernel_shape"),o=r.attributes.getInts("strides",[]),i=r.attributes.getInts("pads",[]),u=r.attributes.getInt("storage_order",0),a=r.attributes.getInts("dilations",[]);if(u!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(n!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return Ie({autoPad:e,ceilMode:n,countIncludePad:!1,kernelShape:t,strides:o,pads:i,storageOrder:u,dilations:a})},Ff=(r,e,n,t)=>{let[o,i]=Vf(r,t,n),u=`
      value = max(_X(x), value);
    `,a="",l=`
      ${Uf(r[0].dims,o,u,a,"-1e5")}
    `;return{...e,output:{dims:i,type:r[0].type,textureType:0},shaderSource:l}},Vf=(r,e,n)=>{let t=r[0].dims.slice(),o=Object.hasOwnProperty.call(e,"dilations"),i=e.kernelShape.slice(),u=e.strides.slice(),a=o?e.dilations.slice():[],s=e.pads.slice();en.adjustPoolAttributes(n,t,i,u,a,s);let l=en.computePoolOutputShape(n,t,u,a,i,s,e.autoPad),d=Object.assign({},e);return o?Object.assign(d,{kernelShape:i,strides:u,pads:s,dilations:a,cacheKey:e.cacheKey}):Object.assign(d,{kernelShape:i,strides:u,pads:s,cacheKey:e.cacheKey}),[d,l]},Aw={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},kf={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[0]},Gf=(r,e)=>($i(e),[r.run({...kf,get:()=>Ff(e,kf,!0,Aw)},e)]),$i=r=>{if(!r||r.length!==1)throw new Error("Pool ops requires 1 input.");if(r[0].type!=="float32"&&r[0].type!=="float64")throw new Error("Invalid input type.")},Uf=(r,e,n,t,o)=>{let i=r.length;if(e.kernelShape.length<=2){let u=e.kernelShape[e.kernelShape.length-1],a=e.strides[e.strides.length-1],s=e.pads[e.pads.length/2-1],l=e.pads[e.pads.length-1],d=r[i-1],f="",p="",g="";if(s+l!==0?f=`
          for (int i = 0; i < ${u}; i++) {
            x[${i} - 1] = indices[${i} - 1] * ${a} - ${s} + i;
            if (x[${i} - 1] < 0 || x[${i} - 1] >= ${d}) {
              pad++;
              continue;
            }
            ${n}
          }`:f=`
          for (int i = 0; i < ${u}; i++) {
            x[${i} - 1] = indices[${i} - 1] * ${a} - ${s} + i;
            ${n}
          }`,e.kernelShape.length===2){let y=e.kernelShape[e.kernelShape.length-2],_=e.strides[e.strides.length-2],x=e.pads[e.pads.length/2-2],S=e.pads[e.pads.length-2],O=r[i-2];x+S!==0?p=`
            for (int j = 0; j < ${y}; j++) {
              x[${i} - 2] = indices[${i} - 2] * ${_} - ${x} + j;
              if (x[${i} - 2] < 0 || x[${i} - 2] >= ${O}) {
                pad+= ${u};
                continue;
              }
          `:p=`
            for (int j = 0; j < ${y}; j++) {
              x[${i} - 2] = indices[${i} - 2] * ${_} - ${x} + j;
            `,g=`
          }
        `}return`
        float process(int indices[${i}]) {
          int x[${i}];
          copyVec(indices, x);

          float value = ${o};
          int pad = 0;
          ${p}
          ${f}
          ${g}
          ${t}
          return value;
        }
      `}else{let u=oe.size(e.kernelShape),a=oe.computeStrides(e.kernelShape),s=a.length,l=e.pads.length,d=Ow(s),f=xi(r,"inputDims"),p=xi(e.pads,"pads"),g=xi(a,"kernelStrides"),b=xi(e.strides,"strides"),y=e.pads.reduce((S,O)=>S+O),_="";return y?_=`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${n}
          }`:_=`
          }
          ${n}
        `,`
        ${d}
        float process(int indices[${i}]) {
          int x[${i}];
          copyVec(indices, x);
          int offset[${s}];
          int pads[${l}];
          int inputDims[${i}];
          int kernelStrides[${s}];
          int strides[${s}];
          ${p}
          ${f}
          ${b}
          ${g}

          float value = ${o};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${u}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${i} - ${s}; j < ${i}; j++) {
              x[j] = indices[j] * strides[j - ${i} + ${s}]
                + offset[j - ${i} + ${s}] - pads[j - 2];
              ${_}
          }
          ${t}

          return value;
        }
      `}},xi=(r,e)=>{let n="";for(let t=0;t<r.length;t++)n+=`
      ${e}[${t}] = ${r[t]};
    `;return n},Ow=r=>`
  void offsetToIndices(int offset, int[${r}] strides, out int[${r}] indices) {
    if (${r} == 0) {
      return;
    }
    for (int i = 0; i < ${r} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${r} - 1] = offset;
  }`});var un,zr,Ew,Cw,Hf,qf,jf,Kf,Yf,Xf,Zf,Jf=R(()=>{"use strict";xt();po();He();ze();un=(r,e,n,t,o)=>{Cw(e);let i={name:t,inputNames:["A"],inputTypes:[0]};return[r.run({...i,cacheHint:n.cacheKey,get:()=>Ew(r,e,n,t,o,i)},e)]},zr=r=>{let e=r.attributes.getInts("axes",[]),n=r.attributes.getInt("keepdims",1)===1;return Ie({axes:e,keepDims:n})},Ew=(r,e,n,t,o,i)=>{let u=[],a=e[0].dims.length||1,s=[],l=oe.normalizeAxes(n.axes,e[0].dims.length),d=o(e,l),f=d[1];for(let b=0;b<e[0].dims.length;b++)l.indexOf(b)>=0||l.length===0?(n.keepDims&&u.push(1),f=`
          for(int j${b} = 0; j${b} < ${e[0].dims[b]}; j${b}++) {
            inputIdx[${b}] = j${b};
            ${f}
          }`):(s.push(`inputIdx[${b}] = outputIdx[${u.length}];`),u.push(e[0].dims[b]));let g=`
      float process(int outputIdx[${u.length||1}]) {
        float value;                 // final result
        int inputIdx[${a}];      // addressing input data
        ${s.join(`
`)}
        ${d[0]}       // init ops for reduce max/min
        ${f}
        ${d[2]}       // final computation for reduce mean
        return value;
      }`;return{...i,output:{dims:u,type:e[0].type,textureType:0},shaderSource:g}},Cw=r=>{if(!r||r.length!==1)throw new Error("Reduce op requires 1 input.");if(Lr.indexOf(r[0].type)===-1)throw new Error("Invalid input type.")},Hf=(r,e,n)=>un(r,e,n,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),qf=(r,e,n)=>un(r,e,n,"ReduceMean",(o,i)=>{let u=1;for(let a=0;a<o[0].dims.length;a++)(i.indexOf(a)>=0||i.length===0)&&(u*=o[0].dims[a]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${u}.;`]}),jf=(r,e,n)=>un(r,e,n,"ReduceMax",(o,i)=>{let u=[];for(let a=0;a<o[0].dims.length;a++)(i.indexOf(a)>=0||i.length===0)&&u.push(`inputIdx[${a}] = 0;`);return[`${u.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),Kf=(r,e,n)=>un(r,e,n,"ReduceMin",(o,i)=>{let u=[];for(let a=0;a<o[0].dims.length;a++)(i.indexOf(a)>=0||i.length===0)&&u.push(`inputIdx[${a}] = 0;`);return[`${u.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),Yf=(r,e,n)=>un(r,e,n,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),Xf=(r,e,n)=>un(r,e,n,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),Zf=(r,e,n)=>un(r,e,n,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])});var Qf,ep=R(()=>{"use strict";He();Qf=(r,e)=>{let n=oe.calculateReshapedDims(e[0].dims,e[1].integerData);return r.session.pack?[r.reshapePacked(e[0],n)]:[r.reshapeUnpacked(e[0],n)]}});var tp,hs,rp,np,ho,Pw,ms,Ti,gs=R(()=>{"use strict";xt();rt();ze();tp={name:"Upsample",inputNames:["X"],inputTypes:[0]},hs=(r,e,n)=>(ms(e,n),[r.run({...tp,cacheHint:n.cacheKey,get:()=>Pw(r,e,n)},e)]),rp=r=>ho(r,7),np=r=>ho(r,9),ho=(r,e)=>{let n=e>=10,t=r.attributes.getString("mode","nearest");if(t!=="nearest"&&t!=="linear"&&(e<11||t!=="cubic"))throw new Error(`unrecognized mode: ${t}`);let o=[];e<9&&(o=r.attributes.getFloats("scales"),Ti(o,t,n));let i=r.attributes.getFloat("extrapolation_value",0),u=e>10?r.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(u)===-1)throw new Error(`coordinate_transform_mode '${u}' is not supported`);let a=u==="tf_crop_and_resize",s=a,l=t==="nearest"&&e>=11?r.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(l)===-1)throw new Error(`nearest_mode '${l}' is not supported`);let d=r.attributes.getFloat("cubic_coeff_a",-.75),f=r.attributes.getInt("exclude_outside",0)!==0;if(f&&t!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");let p=e<11?!0:t==="nearest"&&u==="asymmetric"&&l==="floor",g=0,b=0,y=0;return e>10?r.inputs.length>2?(g=1,b=2,y=3):(b=1,y=2):e===9&&(b=1),Ie({opset:e,isResize:n,mode:t,scales:o,extrapolationValue:i,coordinateTransformMode:u,useExtrapolation:s,needRoiInput:a,nearestMode:l,cubicCoefficientA:d,excludeOutside:f,useNearest2xOptimization:p,roiInputIdx:g,scalesInputIdx:b,sizesInputIdx:y})},Pw=(r,e,n)=>{let t=le(r.session.backend.glContext.version),[o,i]=r.calculateTextureWidthAndHeight(e[0].dims,0),u=e[0].dims.map((y,_)=>Math.floor(y*n.scales[_])),[a,s]=r.calculateTextureWidthAndHeight(u,0),l=u.length,d=new Array(l),f=new Array(l),p=`
      int output_pitches[${l}];
      int input_pitches[${l}];
      `;for(let y=l-1;y>=0;y--)d[y]=y===l-1?1:d[y+1]*u[y+1],f[y]=y===l-1?1:f[y+1]*e[0].dims[y+1],p+=`
        output_pitches[${y}] = ${d[y]};
        input_pitches[${y}] = ${f[y]};
        `;let g=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${o}, ${i});
        float value = getColorAsFloat(${t.texture2D}(X, coords));
        return value;
      }
      `,b=n.mode==="nearest"?`
    ${g}
    float process(int indices[${l}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${a}, ${s});

      ${p}

      int d, m;
      for (int dim = 0; dim < ${l}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:l===4?`
    ${g}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${a}, ${s});

      ${p}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${e[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${g}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${a}, ${s});

      ${p}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${e[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return{...tp,output:{dims:u,type:e[0].type,textureType:0},shaderSource:b,variables:[{name:"scales",type:"int",arrayLength:n.scales.length,data:n.scales.map(y=>Math.ceil(y))}]}},ms=(r,e)=>{if(!r||e.opset<9&&r.length!==1||e.opset>=9&&e.opset<11&&r.length!==2||e.opset>=11&&r.length<2)throw new Error("invalid inputs.");if(e.scales.length>0&&r[0].dims.length!==e.scales.length)throw new Error("Invalid input shape.");if(r[0].type==="string")throw new Error("Invalid input tensor types.")},Ti=(r,e,n)=>{if(n){for(let t of r)if(t<=0)throw new Error("Scale value should be greater than 0.")}else for(let t of r)if(t<1)throw new Error("Scale value should be greater than or equal to 1.");if((e==="linear"||e==="cubic")&&r.length!==2&&(r.length!==4||r[0]!==1||r[1]!==1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${n?"Resize":"Upsample"} opeartor.`)}});var bs,ys,op,ip,kw,Dw,Bw,Rw,ap=R(()=>{"use strict";rt();ze();dr();on();gs();bs={name:"Resize",inputNames:["A"],inputTypes:[2]},ys=(r,e,n)=>(ms(e,n),[r.run({...bs,cacheHint:n.cacheKey,get:()=>kw(r,e,n)},e)]),op=r=>ho(r,10),ip=r=>ho(r,11),kw=(r,e,n)=>{let t=le(r.session.backend.glContext.version),[o,i]=Dw(e,n);if(o.every(O=>O===1)&&n.coordinateTransformMode!=="tf_crop_and_resize")return{...bs,output:{dims:i,type:e[0].type,textureType:2},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${t.texture2D}(X, TexCoords);
                    ${t.output} = v;
                }`};let a=i.length;if(a<2)throw new Error(`output dimension should be at least 2, but got ${a}`);let s=i[a-2],l=i[a-1],d=e[0].dims;if(a!==d.length)throw new Error(`output dimension should match input ${d.length}, but got ${a}`);let f=d[a-2],p=d[a-1],g=o[a-2],b=o[a-1],y="";if(n.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${n.mode}'`);switch(n.coordinateTransformMode){case"asymmetric":y=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":y=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":y=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${l}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${s}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${l}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${s}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":y=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${l}.0 - 1.0, ${s}.0 - 1.0, ${l}.0 - 1.0,
                            ${s}.0 - 1.0);
                        vec4 original = vec4(${p}.0 - 1.0, ${f}.0 - 1.0, ${p}.0 - 1.0,
                            ${f}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${n.coordinateTransformMode}'`)}let _=Pt(a),x=cr(),S=`
            const vec2 inputWH = vec2(${f}.0, ${p}.0);
            const vec4 scaleWHWH = vec4(float(${g}), float(${b}), float(${g}), float(${b}));
            ${x}
            ${y}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${_} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${s-1};
                bool hasNextCol = rc.z < ${l-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${t.output} = vec4(newValue);
            }
        `;return{...bs,output:{dims:i,type:e[0].type,textureType:2},hasMain:!0,shaderSource:S}},Dw=(r,e)=>{let t=r[0].dims,o=e.scales,i;if(o.length===0){let a=r[e.scalesInputIdx];if(a&&a.size!==0){if(r[e.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");o=Bw(a,e.mode,e.isResize)}else{let s=r[e.sizesInputIdx];if(!s||s.size===0)throw new Error("Either scales or sizes MUST be provided as input.");i=Array.from(s.integerData),o=Rw(i,t,e.mode,e.isResize)}}else if(r[e.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");let u=i||t.map((a,s)=>Math.floor(a*o[s]));return[o,u]},Bw=(r,e,n)=>{let t=Array.from(r.floatData);return Ti(t,e,n),t},Rw=(r,e,n,t)=>{let o=e.length,i=new Array(o);for(let u=0,a=o;u<a;u++)if(e[u]===0){if(r[u]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");i[u]=1}else i[u]=r[u]/e[u];return Ti(i,n,t),i}});var sp,Mw,up=R(()=>{"use strict";nn();sp=(r,e)=>(Mw(e),[new mt([e[0].dims.length],"int32",void 0,void 0,new Int32Array(e[0].dims))]),Mw=r=>{if(!r||r.length!==1)throw new Error("Shape requires 1 input.")}});var vs,lp,dp,cp,Lw,fp,zw,Nw,pp=R(()=>{"use strict";xt();po();He();ze();vs={name:"Slice",inputNames:["A"],inputTypes:[0]},lp=(r,e,n)=>(Lw(e),[r.run({...vs,cacheHint:n.cacheKey,get:()=>cp(r,e[0],n)},e)]),dp=r=>{let e=r.attributes.getInts("starts"),n=r.attributes.getInts("ends"),t=r.attributes.getInts("axes",[]);return Ie({starts:e,ends:n,axes:t})},cp=(r,e,n)=>{let t=n.axes.length===0?e.dims.slice(0).map((f,p)=>p):n.axes,o=oe.normalizeAxes(t,e.dims.length),i=n.starts.map((f,p)=>f>e.dims[o[p]]-1?e.dims[o[p]]:oe.normalizeAxis(f,e.dims[o[p]])),u=n.ends.map((f,p)=>f>e.dims[o[p]]-1?e.dims[o[p]]:oe.normalizeAxis(f,e.dims[o[p]])),a=e.dims.slice(),s=[];for(let f=0;f<o.length;f++)a[o[f]]=u[f]-i[f],i[f]>0&&s.push(`outputIdx[${o[f]}] += ${i[f]};`);let d=`
      float process(int outputIdx[${a.length}]) {
        ${s.join(`
      `)}
        return _A(outputIdx);
      }`;return{...vs,output:{dims:a,type:e.type,textureType:0},shaderSource:d}},Lw=r=>{if(!r||r.length!==1)throw new Error("Slice requires 1 input.");if(Lr.indexOf(r[0].type)===-1)throw new Error("Invalid input type.")},fp=(r,e)=>{Nw(e);let n=zw(r,e);return[r.run({...vs,cacheHint:n.cacheKey,get:()=>cp(r,e[0],n)},[e[0]])]},zw=(r,e)=>{if(!r.session.isInitializer(e[1].dataId)||!r.session.isInitializer(e[2].dataId)||e.length>=4&&!r.session.isInitializer(e[3].dataId)||e.length>=5&&!r.session.isInitializer(e[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(e.length>=5&&e[4].integerData.some(u=>u!==1))throw new Error("currently non-1 steps is not supported for Slice");let n=Array.from(e[1].integerData),t=Array.from(e[2].integerData),o=e.length>=4?Array.from(e[3].integerData):[],i=`${o};${n};${t}`;return{starts:n,ends:t,axes:o,cacheKey:i}},Nw=r=>{if(!r||r.length<3||r.length>5)throw new Error("Invalid input number.");if(r[1].type!=="int32"||r[1].dims.length!==1)throw new Error("Invalid input type.");if(r[2].type!=="int32"||r[2].dims.length!==1)throw new Error("Invalid input type.");if(r.length>=4&&(r[3].type!=="int32"||r[3].dims.length!==1))throw new Error("Invalid input type.");if(r.length>=5&&(r[4].type!=="int32"||r[4].dims.length!==1))throw new Error("Invalid input type.")}});var hp,mp,gp,bp,yp,vp,wp,xp,Fw,Vw,Gw,$p,Tp=R(()=>{"use strict";xt();He();rt();ze();wi();hp={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[0]},mp={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[0,0]},gp={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[0,0,0]},bp=(r,e,n)=>{$p(e);let t=e[0].dims.slice(),o=oe.normalizeAxis(n.axis,t.length),i=oe.sizeToDimension(t,o),u=oe.sizeFromDimension(t,o);return xp(r,e,n,i,u)},yp=r=>Ie({axis:r.attributes.getInt("axis",1)}),vp=r=>Ie({axis:r.attributes.getInt("axis",-1)}),wp=(r,e,n)=>{$p(e);let t=e[0].dims.slice(),o=oe.normalizeAxis(n.axis,t.length),i=t.length,u=o!==i-1,a=[],s=[],l=[],d;u&&(s=Array.from({length:i}).map((b,y)=>y),s[o]=i-1,s[i-1]=o,s.map(b=>a.push(t[b])),d=Ie({perm:s}),l=sn(r,e,d));let f=u?oe.sizeToDimension(a,i-1):oe.sizeToDimension(t,i-1),p=u?oe.sizeFromDimension(a,i-1):oe.sizeFromDimension(t,i-1),g=xp(r,u?l:e,n,f,p);return u?sn(r,g,d):g},xp=(r,e,n,t,o)=>{let i=Fw(r,e[0],t,o,[t]),u=r.run({...hp,cacheHint:n.cacheKey,get:()=>i},e),a=Vw(r,e[0],t,o,i.output.dims,[t]),s=r.run({...mp,cacheHint:n.cacheKey,get:()=>a},[e[0],u]),l=Gw(r,e[0],t,o,i.output.dims,a.output.dims);return[r.run({...gp,cacheHint:n.cacheKey,get:()=>l},[e[0],u,s])]},Fw=(r,e,n,t,o)=>{let[i,u]=r.calculateTextureWidthAndHeight(e.dims,0),a=o.length;if(n<1||t<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(o.length!==1)throw new Error("Dimensionality of the output should be 1");if(o[0]!==n)throw new Error("Shape of the output should be equal to logical row count");let s=le(r.session.backend.glContext.version),l=`
      float process(int[${a}] indices) {
        int logical_row_start_offset = indices[0] * ${t};

        float max = getColorAsFloat(${s.texture2D}(A, offsetToCoords(logical_row_start_offset, ${i},
        ${u} )));
        for(int i=1; i<${t}; ++i)
        {
          float current = getColorAsFloat(${s.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${i}, ${u})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return{...hp,output:{dims:o,type:e.type,textureType:0},shaderSource:l}},Vw=(r,e,n,t,o,i)=>{let[u,a]=r.calculateTextureWidthAndHeight(e.dims,0),s=i.length;if(n<1||t<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(i.length!==1)throw new Error("Dimensionality of the output should be 1");if(i[0]!==n)throw new Error("Shape of the output should be equal to logical row count");if(o.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(o[0]!==n)throw new Error("Shape of the intermediate results should be equal to logical row count");let l=le(r.session.backend.glContext.version),d=`
      float process(int[${s}] indices) {
        int logical_row_start_offset = indices[0] * ${t};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${t}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${l.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${u}, ${a}))) - max);
        }

        return norm_factor;
      }`;return{...mp,output:{dims:i,type:e.type,textureType:0},shaderSource:d}},Gw=(r,e,n,t,o,i)=>{let[u,a]=r.calculateTextureWidthAndHeight(e.dims,0),s=e.dims.length;if(n<1||t<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(o.length!==1||i.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(o[0]!==n||i[0]!==n)throw new Error("Shape of the intermediate results should be equal to logical row count");let l=`
      float process(int[${s}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${u}, ${a});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${t};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return{...gp,output:{dims:e.dims,type:e.type,textureType:0},shaderSource:l}},$p=r=>{if(!r||r.length!==1)throw new Error("Softmax requires 1 input.");if(r[0].type!=="float32"&&r[0].type!=="float64")throw new Error("Invalid input type")}});var _p,Sp,Ip,Uw,Ww,Hw,Ap=R(()=>{"use strict";xt();He();ze();_p={name:"Split",inputNames:["A"],inputTypes:[0]},Sp=(r,e,n)=>{Hw(e);let t=oe.normalizeAxis(n.axis,e[0].dims.length),o=Uw(r,e,t,n),i=[];for(let u=0;u<o;++u)i.push(r.run({..._p,cacheHint:`${n.cacheKey};${u}`,get:()=>Ww(r,e[0],n,t,u)},e));return i},Ip=r=>{let e=r.attributes.getInt("axis",0),n=r.attributes.getInts("split",[]),t=r.outputs.length;return Ie({axis:e,split:n,numOutputs:t})},Uw=(r,e,n,t)=>{let[,o]=ao.splitShape(e[0].dims,n,t.split,t.numOutputs);return o.length},Ww=(r,e,n,t,o)=>{let[i,u]=ao.splitShape(e.dims,t,n.split,n.numOutputs),a=u[o],s=i[o],d=`
      float process(int indices[${s.length}]) {
        indices[${t}] += ${a};
        return _A(indices);
      }
    `;return{..._p,cacheHint:`${n.cacheKey}:${o}`,output:{dims:s,type:e.type,textureType:0},shaderSource:d}},Hw=r=>{if(!r||r.length!==1)throw new Error("Split requires one input.");if(r[0].type!=="int8"&&r[0].type!=="uint8"&&r[0].type!=="int16"&&r[0].type!=="uint16"&&r[0].type!=="int32"&&r[0].type!=="uint32"&&r[0].type!=="float32"&&r[0].type!=="float64"&&r[0].type!=="bool")throw new Error("Invalid input type.")}});var ws,Op,Ep,qw,jw,Cp=R(()=>{"use strict";He();ws=(r,e,n)=>{qw(e);let t=oe.squeezeShape(e[0].dims,n);return[r.reshapeUnpacked(e[0],t)]},Op=(r,e)=>(jw(e),ws(r,[e[0]],Array.from(e[1].integerData))),Ep=r=>r.attributes.getInts("axes"),qw=r=>{if(!r||r.length!==1)throw new Error("Squeeze requires 1 input.");if(r[0].type==="string")throw new Error("invalid input tensor types.")},jw=r=>{if(!r||r.length!==2)throw new Error("Squeeze requires 2 inputs.");if(r[1].type!=="int32")throw new Error("Invalid input type.")}});var Pp,Kw,Yw,kp=R(()=>{"use strict";rt();ze();Pp=(r,e)=>{Yw(e);let n={name:"Sum",inputNames:e.map((o,i)=>`X${i}`),inputTypes:new Array(e.length).fill(0)};return[r.run({...n,get:()=>Kw(r,e,n)},e)]},Kw=(r,e,n)=>{let t=le(r.session.backend.glContext.version),o=e[0].dims.slice(),u=`
      void main() {
        vec4 result = ${e.map((a,s)=>`${t.texture2D}(X${s},TexCoords)`).join(" + ")};
        ${t.output} = result;
      }
    `;return{...n,output:{dims:o,type:e[0].type,textureType:0},hasMain:!0,shaderSource:u}},Yw=r=>{if(!r||r.length===0)throw new Error("Sum requires inputs.");let e=r[0].dims.length;for(let n=1;n<r.length;n++){if(e!==r[n].dims.length)throw new Error("Input shapes are mismatched.");for(let t=0;t<e;t++)if(r[0].dims[t]!==r[n].dims[t])throw new Error("Input shapes are not matched.")}if(r[0].type!=="float32"&&r[0].type!=="float64")throw new Error("Invalid input type.");for(let n=1;n<r.length;n++)if(r[0].type!==r[n].type)throw new Error("Input types are not matched.")}});var Dp,Xw,Zw,Bp=R(()=>{"use strict";po();ze();Dp=(r,e)=>{Zw(e);let n={name:"Tile",inputNames:["A"],inputTypes:[0]};return[r.run({...n,get:()=>Xw(r,e,n)},e)]},Xw=(r,e,n)=>{let t=e[0].dims.slice(),o=new Array(t.length),i=[];for(let s=0;s<t.length;s++)o[s]=t[s]*e[1].numberData[s],i.push(`inputIdx[${s}] = int(mod(float(outputIdx[${s}]), ${t[s]}.));`);let u=o.length,a=`
      float process(int outputIdx[${u}]) {
        int inputIdx[${u}];
        ${i.join(`
`)}
        return _A(inputIdx);
      }
    `;return{...n,output:{dims:o,type:e[0].type,textureType:0},shaderSource:a}},Zw=r=>{if(!r||r.length!==2)throw new Error("Tile requires 2 input.");if(r[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(r[1].dims[0]!==r[0].dims.length)throw new Error("Invalid input shape.");if(Lr.indexOf(r[0].type)===-1)throw new Error("Invalid input type.");if(r[1].type!=="int32"&&r[1].type!=="int16")throw new Error("Invalid repeat type.")}});var xs,Rp,Mp,Jw,Qw,Lp=R(()=>{"use strict";He();xs=(r,e,n)=>{Jw(e);let t=oe.unsqueezeShape(e[0].dims,n);return[r.reshapeUnpacked(e[0],t)]},Rp=(r,e)=>(Qw(e),xs(r,[e[0]],Array.from(e[1].integerData))),Mp=r=>r.attributes.getInts("axes"),Jw=r=>{if(!r||r.length!==1)throw new Error("Unsqueeze requires 1 input.");if(r[0].type==="string")throw new Error("invalid input tensor types.")},Qw=r=>{if(!r||r.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(r[1].type!=="int32")throw new Error("Invalid input type.")}});var zp,Np=R(()=>{"use strict";Kd();sc();dc();gc();bi();Qc();af();lf();ff();gf();vf();Tf();Af();yi();Pf();Wf();Jf();ep();ap();up();pp();Tp();Ap();Cp();kp();Bp();wi();os();Lp();gs();zp=[["Abs","","6+",bc],["Acos","","7+",yc],["Add","","7+",Yd],["And","","7+",Xd],["Asin","","7+",vc],["Atan","","7+",wc],["AveragePool","","7+",Df,Bf],["BatchNormalization","","7+",qd,jd],["Cast","","6+",uc,lc],["Ceil","","6+",Tc],["Clip","","6-10",rs,xc],["Clip","","11+",$c],["Concat","","4+",pc,mc],["Conv","","1+",ds,cs],["ConvTranspose","","1+",Zc,Jc],["Cos","","7+",_c],["Div","","7+",Zd],["Dropout","","7+",ns],["DepthToSpace","","1+",nf,of],["Equal","","7+",Jd],["Elu","","6+",Sc,Ic],["Exp","","6+",Ac],["Flatten","","1+",sf,uf],["Floor","","6+",Oc],["FusedConv","com.microsoft","1+",ds,cs],["Gather","","1+",df,cf],["Gemm","","7-10",fs,hf],["Gemm","","11+",fs,mf],["GlobalAveragePool","","1+",Mf,Lf],["GlobalMaxPool","","1+",Gf],["Greater","","7+",Qd],["Identity","","1+",ns],["ImageScaler","","1+",bf,yf],["InstanceNormalization","","6+",xf,$f],["LeakyRelu","","6+",Ec,Cc],["Less","","7+",ec],["LRN","","1+",_f,Sf],["Log","","6+",Pc],["MatMul","","1+",Wc,Hc],["MaxPool","","1+",zf,Nf],["Mul","","7+",tc],["Neg","","6+",kc],["Not","","1+",Dc],["Or","","7+",rc],["Pad","","2-10",ps,Of],["Pad","","11+",Ef,Cf],["Pow","","7+",nc],["PRelu","","7+",oc],["ReduceLogSum","","1+",Xf,zr],["ReduceMax","","1+",jf,zr],["ReduceMean","","1+",qf,zr],["ReduceMin","","1+",Kf,zr],["ReduceProd","","1+",Yf,zr],["ReduceSum","","1-12",Hf,zr],["ReduceSumSquare","","1+",Zf,zr],["Relu","","6+",Bc],["Reshape","","5+",Qf],["Resize","","10",ys,op],["Resize","","11+",ys,ip],["Shape","","1+",sp],["Sigmoid","","6+",Rc],["Sin","","7+",Mc],["Slice","","10+",fp],["Slice","","1-9",lp,dp],["Softmax","","1-12",bp,yp],["Softmax","","13+",wp,vp],["Split","","2-12",Sp,Ip],["Sqrt","","6+",Lc],["Squeeze","","1-12",ws,Ep],["Squeeze","","13+",Op],["Sub","","7+",ic],["Sum","","6+",Pp],["Tan","","7+",zc],["Tanh","","6+",Nc],["Tile","","6+",Dp],["Transpose","","1+",sn,tf],["Upsample","","7-8",hs,rp],["Upsample","","9",hs,np],["Unsqueeze","","1-12",xs,Mp],["Unsqueeze","","13+",Rp],["Xor","","7+",ac]]});function Vp(r){let e={},n;for(;(n=Fp.exec(r))!==null;){let t=n[3].split(",").map(o=>{let i=o.trim().split(" ");return i&&i.length===2?{type:i[0],name:i[1]}:null}).filter(o=>o!==null);e[n[2]]={params:t,body:n[4]}}for(let t in e){let o=ex.replace("__FUNC__",t),i=new RegExp(o,"gm");for(;(n=i.exec(r))!==null;){let u=n[1],a=n[2],s=n[3].split(","),l=u?`${u} ${a};`:"",d=e[t].body,f="";e[t].params.forEach((g,b)=>{g&&(f+=`${g.type} ${g.name} = ${s[b]};
`)}),d=`${f}
 ${d}`,d=d.replace("return",`${a} = `);let p=`
      ${l}
      {
        ${d}
      }
      `;r=r.replace(n[0],p)}}return r=r.replace(Fp,""),r}var Fp,ex,Gp=R(()=>{"use strict";Fp=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm,ex="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;"});function Cn(r,e){let n=[],t=[],o=e!=null&&Array.isArray(e)&&e.length===0,i=e==null||o?null:tx(e,r).sort(),u=0;for(let a=0;a<r.length;++a){if(i!=null){if(i[u]===a&&r[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${r[a]}' is not 1`);(i[u]==null||i[u]>a)&&r[a]===1&&(n.push(r[a]),t.push(a)),i[u]<=a&&u++}r[a]!==1&&(n.push(r[a]),t.push(a))}return{newShape:n,keptDims:t}}function tx(r,e){let n=e.length;return r=r==null?e.map((t,o)=>o):[].concat(r),_n(r.every(t=>t>=-n&&t<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${r}`),_n(r.every(rx),()=>`All values in axis param must be integers but got axis ${r}`),r.map(t=>t<0?n+t:t)}function rx(r){return r%1===0}function nx(r){if(r.length===0)return 1;let e=r[0];for(let n=1;n<r.length;n++)e*=r[n];return e}function Up(r){let e=Math.ceil(Math.sqrt(r));return[e,Math.ceil(r/e)]}var _i,$s=R(()=>{"use strict";Vt();He();_i=class{constructor(e){this.maxTextureSize=e}computeTextureWH(e,n){let t=this.computeTexture(e,n);return n&&n.isPacked&&(t[0]/=2,t[1]/=2),n&&n.reverseWH?[t[1],t[0]]:t}computeTexture(e,n){let t=n&&n.isPacked;if(e.length===0)return t?[2,2]:[1,1];let o=this.maxTextureSize;if(n&&n.breakAxis!==void 0){let a=n.breakAxis>=e.length?1:e.slice(n.breakAxis).reduce((l,d)=>l*d),s=n.breakAxis<=0?1:e.slice(0,n.breakAxis).reduce((l,d)=>l*d);if(a>o||s>o)je.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${e}, breakAxis:${n.breakAxis}`);else return[a,s]}let i=e.slice(0);t&&(o=o*2,i=i.map((a,s)=>s>=i.length-2?i[s]%2===0?i[s]:i[s]+1:i[s]),i.length===1&&(i=[2,i[0]])),i.length!==2&&(i=Cn(i).newShape);let u=nx(i);return i.length<=1&&u<=o?[1,u]:i.length===2&&i[0]<=o&&i[1]<=o?i:i.length===3&&i[0]*i[1]<=o&&i[2]<=o?[i[0]*i[1],i[2]]:i.length===3&&i[0]<=o&&i[1]*i[2]<=o?[i[0],i[1]*i[2]]:i.length===4&&i[0]*i[1]*i[2]<=o&&i[3]<=o?[i[0]*i[1]*i[2],i[3]]:i.length===4&&i[0]<=o&&i[1]*i[2]*i[3]<=o?[i[0],i[1]*i[2]*i[3]]:t?Up(u/4).map(a=>a*2):Up(u)}}});var Si,Wp=R(()=>{"use strict";He();Or();rt();$s();dr();Si=class extends Ht{constructor(n){super(n)}getFunctions(){return{...this.offsetToCoords(),...this.coordsToOffset(),...this.toVec(),...this.valueFrom(),...this.getCommonUtilFuncs(),...this.getInputsSamplingSnippets(),...this.getOutputSamplingSnippet()}}getCustomTypes(){return{}}offsetToCoords(){let n="offsetToCoords";return{offsetToCoords:new Q(`
      vec2 ${n}(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){let n="coordsToOffset";return{coordsToOffset:new Q(`
      int ${n}(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){let n=this.context.outputTextureLayout;return n.isPacked?this.getPackedOutputSamplingSnippet(n):this.getUnpackedOutputSamplingSnippet(n)}getPackedOutputSamplingSnippet(n){let t=n.unpackedShape,o=[n.width,n.height],i={},u="getOutputCoords";switch(t.length){case 0:i[u]=this.getOutputScalarCoords();break;case 1:i[u]=this.getOutputPacked1DCoords(t,o);break;case 2:i[u]=this.getOutputPacked2DCoords(t,o);break;case 3:i[u]=this.getOutputPacked3DCoords(t,o);break;default:i[u]=this.getOutputPackedNDCoords(t,o)}let s=`
      void setOutput(vec4 val) {
        ${le(this.context.glContext.version).output} = val;
      }
    `,l="floatTextureSetRGBA";return i[l]=new Q(s),i}getUnpackedOutputSamplingSnippet(n){let t=n.unpackedShape,o=[n.width,n.height],i={},u="getOutputCoords";switch(t.length){case 0:i[u]=this.getOutputScalarCoords();break;case 1:i[u]=this.getOutputUnpacked1DCoords(t,o);break;case 2:i[u]=this.getOutputUnpacked2DCoords(t,o);break;case 3:i[u]=this.getOutputUnpacked3DCoords(t,o);break;case 4:i[u]=this.getOutputUnpacked4DCoords(t,o);break;case 5:i[u]=this.getOutputUnpacked5DCoords(t,o);break;case 6:i[u]=this.getOutputUnpacked6DCoords(t,o);break;default:throw new Error(`Unsupported output dimensionality: ${t.length}`)}let s=`
        void setOutput(float val) {
          ${le(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `,l="floatTextureSetR";return i[l]=new Q(s),i}getOutputScalarCoords(){return new Q(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(n,t){let o=t,i="";return o[0]===1?(i=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${o[1]}.0);
          }
        `,new Q(i)):o[1]===1?(i=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${o[0]}.0);
          }
        `,new Q(i)):(i=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${o[0]}, ${o[1]}));
          return 2 * (resTexRC.y * ${o[0]} + resTexRC.x);
        }
      `,new Q(i))}getOutputPacked2DCoords(n,t){let o="";if(Qr.arraysEqual(n,t))return o=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${t[0]}, ${t[1]}));
        }
      `,new Q(o);let i=t,u=Math.ceil(n[1]/2);return o=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${i[0]}, ${i[1]}));

          int index = resTexRC.y * ${i[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${u}) * 2;
          int c = 2 * (index / ${u});

          return ivec2(r, c);
        }
      `,new Q(o)}getOutputPacked3DCoords(n,t){let o=[t[0],t[1]],i=Math.ceil(n[2]/2),u=i*Math.ceil(n[1]/2),a=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${o[0]}, ${o[1]}));
          int index = resTexRC.y * ${o[0]} + resTexRC.x;

          int b = index / ${u};
          index -= b * ${u};

          // reverse r and c order for packed texture
          int r = imod(index, ${i}) * 2;
          int c = 2 * (index / ${i});

          return ivec3(b, r, c);
        }
      `;return new Q(a)}getOutputPackedNDCoords(n,t){let o=[t[0],t[1]],i=Math.ceil(n[n.length-1]/2),u=i*Math.ceil(n[n.length-2]/2),a=u,s="",l="b, r, c";for(let f=2;f<n.length-1;f++)a*=n[n.length-f-1],s=`
      int b${f} = index / ${a};
      index -= b${f} * ${a};
    `+s,l=`b${f}, `+l;let d=`
      ivec${n.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${o[0]}, ${o[1]}));
        int index = resTexRC.y * ${o[0]} + resTexRC.x;

        ${s}

        int b = index / ${u};
        index -= b * ${u};

        // reverse r and c order for packed texture
        int r = imod(index, ${i}) * 2;
        int c = 2 * (index / ${i});

        return ivec${n.length}(${l});
      }
    `;return new Q(d)}getOutputUnpacked1DCoords(n,t){let o=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          return resTexRC.y * ${t[0]} + resTexRC.x;
        }
      `;return new Q(o)}getOutputUnpacked2DCoords(n,t){let o=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          int index = resTexRC.y * ${t[0]} + resTexRC.x;
          int r = index / ${n[1]};
          int c = index - r * ${n[1]};
          return ivec2(r, c);
        }
      `;return new Q(o)}getOutputUnpacked3DCoords(n,t){let o="",i=n.length,u=null;i<2&&(u=[]),u=new Array(i-1),u[i-2]=n[i-1];for(let l=i-3;l>=0;--l)u[l]=u[l+1]*n[l+1];let a=["r","c","d"],s=u.map((l,d)=>{let f=`int ${a[d]} = index / ${l}`,p=d===u.length-1?`int ${a[d+1]} = index - ${a[d]} * ${l}`:`index -= ${a[d]} * ${l}`;return`${f}; ${p};`}).join("");return o=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          int index = resTexRC.y * ${t[0]} + resTexRC.x;
          ${s}
          return ivec3(r, c, d);
        }
      `,new Q(o)}getOutputUnpacked4DCoords(n,t){let o="",i=n.length,u=null;i<2&&(u=[]),u=new Array(i-1),u[i-2]=n[i-1];for(let l=i-3;l>=0;--l)u[l]=u[l+1]*n[l+1];let a=["r","c","d","d2"],s=u.map((l,d)=>{let f=`int ${a[d]} = index / ${l}`,p=d===u.length-1?`int ${a[d+1]} = index - ${a[d]} * ${l}`:`index -= ${a[d]} * ${l}`;return`${f}; ${p};`}).join("");return o=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          int index = resTexRC.y * ${t[0]} + resTexRC.x;
          ${s}
          return ivec4(r, c, d, d2);
        }
      `,new Q(o)}getOutputUnpacked5DCoords(n,t){let o="",i=n.length,u=null;i<2&&(u=[]),u=new Array(i-1),u[i-2]=n[i-1];for(let l=i-3;l>=0;--l)u[l]=u[l+1]*n[l+1];let a=["r","c","d","d2","d3"],s=u.map((l,d)=>{let f=`int ${a[d]} = index / ${l}`,p=d===u.length-1?`int ${a[d+1]} = index - ${a[d]} * ${l}`:`index -= ${a[d]} * ${l}`;return`${f}; ${p};`}).join("");return o=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${t[0]}, ${t[1]}));
          int index = resTexRC.y * ${t[0]} + resTexRC.x;
          ${s}
          return ivec5(r, c, d, d2, d3);
        }
      `,new Q(o)}getOutputUnpacked6DCoords(n,t){let o="",i=n.length,u=null;i<2&&(u=[]),u=new Array(i-1),u[i-2]=n[i-1];for(let l=i-3;l>=0;--l)u[l]=u[l+1]*n[l+1];let a=["r","c","d","d2","d3","d4"],s=u.map((l,d)=>{let f=`int ${a[d]} = index / ${l}`,p=d===u.length-1?`int ${a[d+1]} = index - ${a[d]} * ${l}`:`index -= ${a[d]} * ${l}`;return`${f}; ${p};`}).join("");return o=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${t[0]}, ${t[1]}));
         int index = resTexRC.y * ${t[0]} + resTexRC.x;
         ${s}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new Q(o)}getCommonUtilFuncs(){let n={},t="uvFromFlat";n[t]=new Q(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),t="packedUVfrom1D",n[t]=new Q(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),t="packedUVfrom2D",n[t]=new Q(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),t="packedUVfrom3D",n[t]=new Q(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),t="sampleTexture";let o=le(this.context.glContext.version);return n[t]=new Q(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${o.texture2D}(textureSampler, uv).r;
        }`),n}getInputsSamplingSnippets(){let n={},t=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((o,i)=>{let u=this.context.inputTextureLayouts[i],a=di(o);u.isPacked?n[a]=this.getPackedSamplerFromInput(a,o,u):n[a]=this.getUnpackedSamplerFromInput(a,o,u);let s=Cd(o);u.unpackedShape.length<=t.unpackedShape.length&&(u.isPacked?n[s]=this.getPackedSamplerAtOutputCoords(s,u,t,o):n[s]=this.getUnpackedSamplerAtOutputCoords(s,u,t,o))}),n}getPackedSamplerAtOutputCoords(n,t,o,i){let u=t.unpackedShape,a=o.unpackedShape,l=di(i),d=u.length,f=a.length,p=Ct.getBroadcastDims(u,a),g=Pt(f),b=f-d,y,_=tr();d===0?y="":f<2&&p.length>=1?y="coords = 0;":y=p.map(H=>`coords.${_[H+b]} = 0;`).join(`
`);let x="";f<2&&d>0?x="coords":x=u.map((H,ne)=>`coords.${_[ne+b]}`).join(", ");let S="return outputValue;",C=oe.size(u)===1,k=oe.size(a)===1;if(d===1&&!C&&!k)S=`
        return vec4(outputValue.xy, outputValue.xy);
      `;else if(C&&!k)f===1?S=`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:S=`
          return vec4(outputValue.x);
        `;else if(p.length){let H=d-2,ne=d-1;p.indexOf(H)>-1&&p.indexOf(ne)>-1?S="return vec4(outputValue.x);":p.indexOf(H)>-1?S="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":p.indexOf(ne)>-1&&(S="return vec4(outputValue.xx, outputValue.zz);")}let U=`
        int lastDim = coords.${_[f-1]};
        coords.${_[f-1]} = coords.${_[f-2]};
        coords.${_[f-2]} = lastDim;
      `,G=`
      vec4 ${n}() {
        ${g} coords = getOutputCoords();
        ${U}
        ${y}
        vec4 outputValue = ${l}(${x});
        ${S}
      }
    `;return new Q(G,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(n,t,o,i){let u=[o.width,o.height],a=[t.width,t.height],s=t.unpackedShape.length,l=o.unpackedShape.length,d=t.unpackedShape,f=o.unpackedShape,p=di(i);if(s===l&&Qr.arraysEqual(a,u)){let C=`
          float ${n}() {
            return sampleTexture(${i}, TexCoords);
          }
        `;return new Q(C,["coordinates.sampleTexture"])}let g=Pt(l),b=Ct.getBroadcastDims(d,f),y=l-s,_,x=tr();s===0?_="":l<2&&b.length>=1?_="coords = 0;":_=b.map(C=>`coords.${x[C+y]} = 0;`).join(`
`);let S="";l<2&&s>0?S="coords":S=t.unpackedShape.map((C,N)=>`coords.${x[N+y]}`).join(", ");let O=`
        float ${n}() {
          ${g} coords = getOutputCoords();
          ${_}
          return ${p}(${S});
        }
      `;return new Q(O,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(n,t,o){switch(o.unpackedShape.length){case 0:return this.getPackedSamplerScalar(n,t);case 1:return this.getPackedSampler1D(n,t,o);case 2:return this.getPackedSampler2D(n,t,o);case 3:return this.getPackedSampler3D(n,t,o);default:return this.getPackedSamplerND(n,t,o)}}getUnpackedSamplerFromInput(n,t,o){let i=o.unpackedShape;switch(i.length){case 0:return this.getUnpackedSamplerScalar(n,t,o);case 1:return this.getUnpackedSampler1D(n,t,o);case 2:return this.getUnpackedSampler2D(n,t,o);case 3:return this.getUnpackedSampler3D(n,t,o);case 4:return this.getUnpackedSampler4D(n,t,o);case 5:return this.getUnpackedSampler5D(n,t,o);case 6:return this.getUnpackedSampler6D(n,t,o);default:throw new Error(`Unsupported dimension ${i.length}-D`)}}getPackedSamplerScalar(n,t){let o=le(this.context.glContext.version),i=`
          vec4 ${n}() {
            return ${o.texture2D}(${t}, halfCR);
          }
        `;return new Q(i)}getPackedSampler1D(n,t,o){let i=[o.width,o.height],u=[i[1],i[0]],a=le(this.context.glContext.version),l=`vec4 ${n}(int index) {
      vec2 uv = packedUVfrom1D(
      ${u[0]}, ${u[1]}, index);
      return ${a.texture2D}(${t}, uv);
    }`;return new Q(l,["coordinates.packedUVfrom1D"])}getPackedSampler2D(n,t,o){let i=o.unpackedShape,u=[o.width,o.height],a=le(this.context.glContext.version),s=u[0],l=u[1];if(u!=null&&Qr.arraysEqual(i,u)){let b=`vec4 ${n}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${s}.0);
        return ${a.texture2D}(${t}, uv);
      }`;return new Q(b)}let d=u,f=Math.ceil(i[1]/2),g=`vec4 ${n}(int row, int col) {
      vec2 uv = packedUVfrom2D(${d[1]}, ${d[0]}, ${f}, row, col);
      return ${a.texture2D}(${t}, uv);
    }`;return new Q(g,["coordinates.packedUVfrom2D"])}getPackedSampler3D(n,t,o){let i=o.unpackedShape,u=[o.width,o.height],a=[u[0],u[1]],s=le(this.context.glContext.version);if(i[0]===1){let y=i.slice(1),_=[1,2],x=Sn(i,y),S=["b","row","col"],O=JSON.parse(JSON.stringify(o));O.unpackedShape=x;let C=this.getPackedSamplerFromInput(n,t,O),k=`${C.routineBody}
      vec4 ${n}(int b, int row, int col) {
        return ${n}(${In(S,_)});
      } `;return new Q(k,C.dependencies)}let l=a[0],d=a[1],f=Math.ceil(i[2]/2),p=f*Math.ceil(i[1]/2),b=`vec4 ${n}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${d}, ${l}, ${p}, ${f}, b, row, col);
      return ${s.texture2D}(${t}, uv);}`;return new Q(b,["coordinates.packedUVfrom3D"])}getPackedSamplerND(n,t,o){let i=o.unpackedShape,u=i.length,a=[o.width,o.height],s=le(this.context.glContext.version),l=[a[0],a[1]],d=l[1],f=l[0],p=Math.ceil(i[u-1]/2),g=p*Math.ceil(i[u-2]/2),b="int b, int row, int col",y=`b * ${g} + (row / 2) * ${p} + (col / 2)`;for(let S=2;S<u-1;S++)b=`int b${S}, `+b,g*=i[u-S-1],y=`b${S} * ${g} + `+y;let x=`vec4 ${n}(${b}) {
      int index = ${y};
      int texR = index / ${f};
      int texC = index - texR * ${f};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${f}, ${d});
      return ${s.texture2D}(${t}, uv);
    }`;return new Q(x)}getUnpackedSamplerScalar(n,t,o){let[i,u]=[o.width,o.height];if(i===1&&u===1){let s=`
          float ${n}() {
            return sampleTexture(${t}, halfCR);
          }
        `;return new Q(s,["coordinates.sampleTexture"])}let a=`
        float ${n}() {
          int offset_${t} = coordsToOffset(TexCoords, ${i}, ${u});
          vec2 uv = uvFromFlat(${i}, ${u}, offset_${t});
          return sampleTexture(${t}, uv);
        }
      `;return new Q(a,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(n,t,o){let i=o.width,u=o.height;if(u===1&&i===1){let s=`
        float ${n}(int index) {
          return sampleTexture(${t}, halfCR);
        }
      `;return new Q(s,["coordinates.sampleTexture"])}if(u===1){let s=`
          float ${n}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${i}.0, 0.5);
            return sampleTexture(${t}, uv);
          }
        `;return new Q(s,["coordinates.sampleTexture"])}if(i===1){let s=`
          float ${n}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${u}.0);
            return sampleTexture(${t}, uv);
          }
        `;return new Q(s,["coordinates.sampleTexture"])}let a=`
        float ${n}(int index) {
          vec2 uv = uvFromFlat(${i}, ${u}, index);
          return sampleTexture(${t}, uv);
        }
      `;return new Q(a,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(n,t,o){let i=o.unpackedShape,u=[o.height,o.width];if(u!=null&&Qr.arraysEqual(i,u)){let g=u[1],b=u[0],y=`
          float ${n}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${g}.0, ${b}.0);
            return sampleTexture(${t}, uv);
          }
        `;return new Q(y,["coordinates.sampleTexture"])}let{newShape:a,keptDims:s}=Cn(i),l=a;if(l.length<i.length){let g=Sn(i,l),b=JSON.parse(JSON.stringify(o));b.unpackedShape=g;let y=["col","row"],_=`
          ${this.getUnpackedSamplerFromInput(n,t,b).routineBody}
          float ${n}(int row, int col) {
            return ${n}(${In(y,s)});
          }
        `;return new Q(_,["coordinates.sampleTexture"])}let d=u[1],f=u[0];if(f===1){let g=`
          float ${n}(int row, int col) {
            int offset_${t} = coordsToOffset(TexCoords, ${d}, ${f});
            float index = dot(vec3(row, col, offset_${t}), vec3(${i[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${d}.0);
            return sampleTexture(${t}, uv);
          }
        `;return new Q(g,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(d===1){let g=`
          float ${n}(int row, int col) {
            int offset_${t} = coordsToOffset(TexCoords, ${d}, ${f});
            float index = dot(vec3(row, col, offset_${t}), vec3(${i[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${f}.0, 0.5);
            return sampleTexture(${t}, uv);
          }
        `;return new Q(g,["coordinates.sampleTexture","coordinates.coordsToOffset"])}let p=`
        float ${n}(int row, int col) {
          int index = col * ${i[1]} + row;
          vec2 uv = uvFromFlat(${d}, ${f}, index);
          return sampleTexture(${t}, uv);
        }
      `;return new Q(p,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(n,t,o){let i=o.unpackedShape,u=i[1]*i[2],a=i[2],{newShape:s,keptDims:l}=Cn(i),d=s;if(d.length<i.length){let b=Sn(i,d),y=["batch","col","row"],_=JSON.parse(JSON.stringify(o));_.unpackedShape=b;let x=this.getUnpackedSamplerFromInput(n,t,_),S=l.reverse(),O=`
          ${x.routineBody}
          float ${n}(int batch, int row, int col) {
            return ${n}(${In(y,S)});
          }
        `;return new Q(O,x.dependencies)}let f=o.width,p=o.height,g=`
          float ${n}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${u} + col * ${a} + row;
            vec2 uv = uvFromFlat(${f}, ${p}, index);
            return sampleTexture(${t}, uv);
          }
      `;return new Q(g,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(n,t,o){let i=o.unpackedShape,u=i[3],a=i[2]*u,s=i[1]*a,l=o.width,d=o.height,f=`
        float ${n}(int row, int col, int depth, int depth2) {
          int index = row * ${s} + col * ${a} +
              depth2 * ${u} + depth;
          vec2 uv = uvFromFlat(${l}, ${d}, index);
          return sampleTexture(${t}, uv);
        }
      `;return new Q(f,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(n,t,o){let i=o.unpackedShape,u=i[4],a=i[3]*u,s=i[2]*a,l=i[1]*s,{newShape:d,keptDims:f}=Cn(i);if(d.length<i.length){let y=Sn(i,d),_=["row","col","depth","depth2","depth3"],x=JSON.parse(JSON.stringify(o));x.unpackedShape=y;let S=`
          ${this.getUnpackedSamplerFromInput(n,t,x).routineBody}
          float ${n}(int row, int col, int depth, int depth2, int depth3) {
            return ${n}(${In(_,f)});
          }
        `;return new Q(S,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let p=o.width,g=o.height,b=`
        float ${n}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${l} + col * ${s} + depth * ${a} +
          depth3 * ${u} + depth2;
          vec2 uv = uvFromFlat(${p}, ${g}, index);
          return sampleTexture(${t}, uv);
        }
      `;return new Q(b,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(n,t,o){let i=o.unpackedShape,u=i[5],a=i[4]*u,s=i[3]*a,l=i[2]*s,d=i[1]*l,{newShape:f,keptDims:p}=Cn(i);if(f.length<i.length){let _=Sn(i,f),x=["row","col","depth","depth2","depth3","depth4"],S=JSON.parse(JSON.stringify(o));S.unpackedShape=_;let O=`
            ${this.getUnpackedSamplerFromInput(n,t,S).routineBody}
            float ${n}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${n}(${In(x,p)});
            }
          `;return new Q(O,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let g=o.width,b=o.height,y=`
          float ${n}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${d} + col * ${l} + depth * ${s} +
            depth2 * ${a} + depth3 * ${u} + depth4;
            vec2 uv = uvFromFlat(${g}, ${b}, index);
            return sampleTexture(${t}, uv);
          }
        `;return new Q(y,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){let n=this.context.outputTextureLayout,t=n.shape.length,o=n.strides,i=n.width,u=n.height,a=[];for(let l=0;l<t-1;++l)a.push(`
        c[${l}] = offset / ${o[l]};`),a.push(`
        offset -= c[${l}] * ${o[l]};`);a.push(`
        c[${t-1}] = offset;`);let s=`
      void toVec(vec2 texCoords, out int c[${t}]) {
        int offset = coordsToOffset(texCoords, ${i}, ${u});
        ${a.join("")}
      }
      void toVec(int offset, out int c[${t}]) {
        ${a.join("")}
      }
    `;return{toVec:new Q(s,["coordinates.coordsToOffset"])}}valueFrom(){let n={};return this.context.programInfo.inputNames.forEach((t,o)=>{let i=this.context.inputTextureLayouts[o],a=(i.unpackedShape.length>0?i.unpackedShape:i.shape).length,s=`_${t}`;n[s]=new Q(this.getValueFromSingle(t,a,i.width,i.height,!1),[`shapeUtils.indicesToOffset${s}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),s=s+"_T",n[s]=new Q(this.getValueFromSingle(t,a,i.width,i.height,!0),[`shapeUtils.indicesToOffset${s}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),n}getValueFromSingle(n,t,o,i,u){let a=`_${n}`;u&&(a=a+"_T");let s=le(this.context.glContext.version);return`
        float ${a}(int m[${t}]) {
          int offset = indicesToOffset${a}(m);
          vec2 coords = offsetToCoords(offset, ${o}, ${i});
          float value = getColorAsFloat(${s.texture2D}(${n}, coords));
          return value;
        }
        `}getPackedValueFrom(n,t,o,i,u){let a=`_${n}_Pack`;u&&(a=a+"_T");let s=le(this.context.glContext.version);return`
        vec4 ${a}(int m[${t}]) {
          int offset = indicesToOffset_${n}(m);
          vec2 coords = offsetToCoords(offset, ${o}, ${i});
          return ${s.texture2D}(${n}, coords);
        }
        `}}});var Ii,Hp=R(()=>{"use strict";Or();Ii=class r extends Ht{constructor(e){super(e)}getFunctions(){return{...this.encodeFloat32(),...this.decodeFloat32()}}getCustomTypes(){return{}}encodeFloat32(){return{encode:new Q(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new Q(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){let e=r.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new Q(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${e}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){let e=r.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new Q(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${e}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){let e=new ArrayBuffer(4),n=new Uint32Array(e),t=new Uint8Array(e);if(n[0]=3735928559,t[0]===239)return!0;if(t[0]===222)return!1;throw new Error("unknown endianness")}}});var Ai,qp=R(()=>{"use strict";Or();rt();Ai=class extends Ht{constructor(e){super(e)}getFunctions(){return{...this.setFragColor(),...this.getColorAsFloat()}}getCustomTypes(){return{}}setFragColor(){let e=le(this.context.glContext.version);return{setFragColor:new Q(`
        void setFragColor(float value) {
            ${e.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new Q(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}});var Oi,jp=R(()=>{"use strict";Or();Oi=class r extends Ht{constructor(e){super(e)}getFunctions(){return{...this.bcastIndex(),...this.bcastMatmulIndex(),...this.offsetToIndices(),...this.indicesToOffset(),...this.incrementIndices()}}getCustomTypes(){return{}}bcastIndex(){let e=this.context.outputTextureLayout.shape.length,n={};return this.context.programInfo.inputNames.forEach((t,o)=>{let i=this.context.inputTextureLayouts[o].unpackedShape;if(i.length<=e){let u=i.length,a=e-u,s=`bcastIndices_${t}`,l="";for(let f=0;f<u;++f)l+=`
          realIndices[${f}] = int( mod(float(bcastedIndices[${a+f}]), ${i[f]}.0) );
          `;let d=`
        void ${s} (int bcastedIndices[${e}], out int realIndices[${u}]) {
          ${l}
        }
        `;n[s]=new Q(d)}}),n}bcastMatmulIndex(){let e=this.context.outputTextureLayout.shape.length,n={};return this.context.programInfo.inputNames.forEach((t,o)=>{let i=this.context.inputTextureLayouts[o].shape;if(!(i.length<2||i.length>e)){let u=i.length,a=e-u,s=`bcastMatmulIndices_${t}`,l="";for(let f=0;f<u-2;++f)l+=`
          realIndices[${f}] = int( mod(float(bcastedIndices[${a+f}]), ${i[f]}.0) );
          `;let d=`
        void ${s}(int bcastedIndices[${e}], out int realIndices[${u}]) {
          ${l}
          realIndices[${u-1}] = bcastedIndices[${e-1}];
          realIndices[${u-2}] = bcastedIndices[${e-2}];
        }
        `;n[s]=new Q(d)}}),n}indicesToOffset(){let e={};return this.context.programInfo.inputNames.forEach((n,t)=>{let o=this.context.inputTextureLayouts[t].shape,i=this.context.inputTextureLayouts[t].strides,u=o.length,a=`indicesToOffset_${n}`;e[a]=new Q(r.indexToOffsetSingle(a,u,i)),a=`indicesToOffset_${n}_T`,e[a]=new Q(r.indexToOffsetSingle(a,u,i.slice().reverse()))}),e}static indexToOffsetSingle(e,n,t){let o="";for(let i=n-1;i>=0;--i)o+=`
        offset += indices[${i}] * ${t[i]};
        `;return`
      int ${e}(int indices[${n}]) {
        int offset = 0;
        ${o}
        return offset;
      }
      `}offsetToIndices(){let e={};return this.context.programInfo.inputNames.forEach((n,t)=>{let o=this.context.inputTextureLayouts[t].shape,i=this.context.inputTextureLayouts[t].strides,u=o.length,a=`offsetToIndices_${n}`;e[a]=new Q(r.offsetToIndicesSingle(a,u,i)),a=`offsetToIndices_${n}_T`,e[a]=new Q(r.offsetToIndicesSingle(a,u,i.slice().reverse()))}),e}static offsetToIndicesSingle(e,n,t){let o=[];for(let i=0;i<n-1;++i)o.push(`
      indices[${i}] = offset / ${t[i]};`),o.push(`
        offset -= indices[${i}] * ${t[i]};`);return o.push(`
      indices[${n-1}] = offset;`),`
      void ${e}(int offset, out int indices[${n}]) {
        ${o.join("")}
      }
      `}incrementIndices(){let e={};return this.context.programInfo.inputNames.forEach((n,t)=>{let o=this.context.inputTextureLayouts[t].shape,i=o.length,u=`incrementIndices_${n}`,a="";for(let l=0;l<i;++l)a+=`
        shape[${l}] = ${o[l]};`;let s=`
        void ${u}(int axis, out int indices[${i}]) {
          int shape[${i}];
          ${a};
          for(int i = ${i} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;e[u]=new Q(s)}),e}}});var Ei,Kp=R(()=>{"use strict";Or();Ei=class extends Ht{constructor(e){super(e)}getCustomTypes(){return{}}getFunctions(){return{...this.binaryVecFunctions(),...this.copyVec(),...this.setVecItem(),...this.getVecItem()}}binaryVecFunctions(){let n=this.context.outputTextureLayout.shape.length,t={add:"+=",sub:"-=",mul:"*=",div:"/="},o={};for(let i in t){let u=`${i}Vec`,a="";for(let l=0;l<n;++l)a+=`
          dest[${l}] ${t[i]} src[${l}];
          `;let s=`
        void ${u}(int src[${n}], out int dest[${n}]) {
          ${a}
        }
        `;o[u]=new Q(s)}return o}copyVec(){let n=this.context.outputTextureLayout.shape.length,t="";for(let i=0;i<n;++i)t+=`
        dest[${i}] = src[${i}];
        `;let o=`
      void copyVec(int src[${n}], out int dest[${n}]) {
        ${t}
      }
      `;return{copyVec:new Q(o)}}setVecItem(){let n=this.context.outputTextureLayout.shape.length,t=`
        if(index < 0)
            index =${n} + index;
        if (index == 0)
            m[0] = value;
        `;for(let i=1;i<n-1;++i)t+=`
        else if (index == ${i})
            m[${i}] = value;
            `;t+=`
        else
            m[${n-1}] = value;
        `;let o=`
      void setVecItem(out int m[${n}], int index, int value) {
        ${t}
      }
        `;return{setVecItem:new Q(o)}}getVecItem(){let n=this.context.outputTextureLayout.shape.length,t=`
        if(index < 0)
            index = ${n} + index;
        if (index == 0)
            return m[0];
      `;for(let i=1;i<n-1;++i)t+=`
        else if (index == ${i})
            return m[${i}];
      `;t+=`
        else
            return m[${n-1}];
        `;let o=`
      int getVecItem(int m[${n}], int index) {
        ${t}
      }
    `;return{getVecItem:new Q(o)}}}});var Ts,Yp=R(()=>{"use strict";Wp();Hp();qp();jp();Kp();Ts={encoding:Ii,fragcolor:Ai,vec:Ei,shapeUtils:Oi,coordinates:Si}});var Ci,Xp=R(()=>{"use strict";Or();Gp();Yp();rt();Ci=class{constructor(e,n,t,o){this.libs={};this.glslLibRoutineDependencyGraph={};this.context=new hi(e,n,t,o),Object.keys(Ts).forEach(u=>{let a=new Ts[u](this.context);this.libs[u]=a});let i=this.glslLibRoutineDependencyGraph;for(let u in this.libs){let s=this.libs[u].getFunctions();for(let l in s){let d=u+"."+l,f;i[d]?(f=i[d],f.routineBody=s[l].routineBody):(f=new fo(d,s[l].routineBody),i[d]=f);let p=s[l].dependencies;if(p)for(let g=0;g<p.length;++g)if(i[p[g]])f.addDependency(i[p[g]]);else{let b=new fo(p[g]);i[p[g]]=b,f.addDependency(b)}}}}preprocess(){let e=this.context.programInfo,n=e.shaderSource;return this.context.programInfo.hasMain||(n=`${n}
      ${Ed(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),n=Vp(n),`${Od(this.context.glContext.version)}
    ${this.getUniforms(e.inputNames,e.variables)}
    ${this.getImports(n)}
    ${n}`}getImports(e){let n=this.selectGlslLibRoutinesToBeIncluded(e);if(n.length===0)return"";let t="";for(let o=0;o<n.length;++o)if(n[o].routineBody)t+=n[o].routineBody+`
`;else throw new Error(`Missing body for the Glsl Library routine: ${n[o].name}`);return t}selectGlslLibRoutinesToBeIncluded(e){let n=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(t=>{let o=t.split(".")[1];e.indexOf(o)!==-1&&n.push(this.glslLibRoutineDependencyGraph[t])}),mi.returnOrderedNodes(n)}getUniforms(e,n){let t=[];if(e)for(let o of e)t.push(`uniform sampler2D ${o};`);if(n)for(let o of n)t.push(`uniform ${o.type} ${o.name}${o.arrayLength?`[${o.arrayLength}]`:""};`);return t.join(`
`)}}});var Pi,Zp=R(()=>{"use strict";Bt();Vt();Xp();rt();Pi=class{constructor(e,n,t){this.profiler=e;this.glContext=n;this.textureLayoutStrategy=t;this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,n){this.repo.set(e,n)}run(e,n,t){this.profiler.event("op",`ProgramManager.run ${e.programInfo.name??"unknown kernel"}`,()=>{let o=this.glContext.gl,i=e.program;o.useProgram(i);try{this.bindOutput(t),this.attributesBound||this.bindAttributes(e.attribLocations),this.bindUniforms(e.uniformLocations,e.programInfo.variables??[],n)}catch(u){throw je.error("ProgramManager",e.programInfo.shaderSource),u}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(e=>this.glContext.deleteProgram(e.program))}build(e,n,t){return this.profiler.event("backend","ProgramManager.build",()=>{let o=new Ci(this.glContext,e,n,t),i=o.preprocess(),u=this.compile(i);return{programInfo:e,program:u,uniformLocations:this.getUniformLocations(u,o.context.programInfo.inputNames,o.context.programInfo.variables),attribLocations:this.getAttribLocations(u)}})}compile(e){if(!this.vertexShader){je.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");let o=Ad(this.glContext.version);this.vertexShader=this.glContext.compileShader(o,this.glContext.gl.VERTEX_SHADER)}xe.debug&&je.verbose("ProrgramManager",`FragShader:
${e}
`);let n=this.glContext.compileShader(e,this.glContext.gl.FRAGMENT_SHADER),t=this.glContext.createProgram(this.vertexShader,n);return this.glContext.deleteShader(n),t}bindOutput(e){let n=e.width,t=e.height;je.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${n}/${t}, shape=${e.shape}, type=${e.tensor.type}`),this.glContext.attachFramebuffer(e.texture,n,t)}bindAttributes(e){let n=e.position,t=e.textureCoord;this.glContext.setVertexAttributes(n,t),this.attributesBound=!0}bindUniforms(e,n,t){let o=this.glContext.gl,i=0;for(let{name:u,type:a,location:s,arrayLength:l}of e){let d=n.find(f=>f.name===u)?.data;if(a!=="sampler2D"&&!d)throw new Error(`variable '${u}' does not have data defined in program info`);switch(a){case"sampler2D":this.bindTexture(t[i],s,i),i++;break;case"float":l?o.uniform1fv(s,d):o.uniform1f(s,d);break;case"int":l?o.uniform1iv(s,d):o.uniform1i(s,d);break;default:throw new Error(`Uniform not implemented: ${a}`)}}}bindTexture(e,n,t){this.glContext.bindTextureToUniform(e.texture,t,n)}getAttribLocations(e){return{position:this.getAttribLocation(e,"position"),textureCoord:this.getAttribLocation(e,"textureCoord")}}getUniformLocations(e,n,t){let o=[];if(n)for(let i of n)o.push({name:i,type:"sampler2D",location:this.getUniformLocation(e,i)});if(t)for(let i of t)o.push({...i,location:this.getUniformLocation(e,i.name)});return o}getUniformLocation(e,n){let o=this.glContext.gl.getUniformLocation(e,n);if(o===null)throw new Error(`Uniform ${n} not found.`);return o}getAttribLocation(e,n){return this.glContext.gl.getAttribLocation(e,n)}}});var ki,Jp=R(()=>{"use strict";Vt();lo();ki=class{constructor(e,n,t,o){this.glContext=e;this.layoutStrategy=n;this.profiler=t;this.config=o;this.pendingRead=new Map;o.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(e,n,t,o){let i=this.toEncoderType(e),u=this.glContext.getEncoder(i,n.channels||1,o);if(n.isPacked&&o===1)throw new Error("not implemented");let a=n.width,s=n.height,l,d;if(this.config.reuseTextures){l=`${a}x${s}_${u.format}_${u.internalFormat}_${u.textureType}`,d=this.inUseTextures.get(l),d||(d=[],this.inUseTextures.set(l,d));let p=this.idleTextures.get(l);if(p&&p.length>0){let g=p.pop();return d.push(g),o===1&&this.glContext.updateTexture(g,a,s,u,this.toTextureData(e,t)),g}}je.verbose("TextureManager",`Creating new texture of size ${n.width}x${n.height}`);let f=this.glContext.allocateTexture(a,s,u,this.toTextureData(e,t));return this.config.reuseTextures&&(d.push(f),this.textureLookup.set(f,l)),f}readTexture(e,n,t){return t||(t=1),this.profiler.event("backend","TextureManager.readTexture",()=>{let o=e.shape.reduce((u,a)=>u*a)*t,i=this.glContext.readTexture(e.texture,e.width,e.height,o,this.toEncoderType(n),t);return this.toTensorData(n,i)})}async readTextureAsync(e,n,t){let o=e.tensor.dataId;if(t||(t=1),this.pendingRead.has(o)){let i=this.pendingRead.get(o);return new Promise(u=>i?.push(u))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(o,[]);let i=e.shape.reduce((l,d)=>l*d)*t;await this.glContext.createAndWaitForFence();let u=this.glContext.readTexture(e.texture,e.width,e.height,i,this.toEncoderType(n),t),a=this.toTensorData(n,u),s=this.pendingRead.get(o);return this.pendingRead.delete(o),s?.forEach(l=>l(a)),a})}readUint8TextureAsFloat(e){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{let n=e.shape.reduce((o,i)=>o*i),t=this.glContext.readTexture(e.texture,e.width,e.height,n*4,"byte",4);return new Float32Array(t.buffer,t.byteOffset,n)})}releaseTexture(e,n){let t;if(this.config.reuseTextures&&(t=this.textureLookup.get(e.texture),t)){n&&this.textureLookup.delete(t);let o=this.inUseTextures.get(t);if(o){let i=o.indexOf(e.texture);if(i!==-1){o.splice(i,1);let u=this.idleTextures.get(t);u||(u=[],this.idleTextures.set(t,u)),u.push(e.texture)}}}(!t||n)&&(je.verbose("TextureManager",`Deleting texture of size ${e.width}x${e.height}`),this.glContext.deleteTexture(e.texture))}toTensorData(e,n){switch(e){case"int16":return n instanceof Int16Array?n:Int16Array.from(n);case"int32":return n instanceof Int32Array?n:Int32Array.from(n);case"int8":return n instanceof Int8Array?n:Int8Array.from(n);case"uint16":return n instanceof Uint16Array?n:Uint16Array.from(n);case"uint32":return n instanceof Uint32Array?n:Uint32Array.from(n);case"uint8":case"bool":return n instanceof Uint8Array?n:Uint8Array.from(n);case"float32":return n instanceof Float32Array?n:Float32Array.from(n);case"float64":return n instanceof Float64Array?n:Float64Array.from(n);default:throw new Error(`TensorData type ${e} is not supported`)}}toTextureData(e,n){if(n)return n instanceof Float32Array?n:new Float32Array(n)}toEncoderType(e){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}});var Di,Qp=R(()=>{"use strict";Vt();pl();Wd();Np();Zp();$s();Jp();Di=class{constructor(e,n){this.backend=e;this.context=n;this.layoutStrategy=new _i(e.glContext.maxTextureSize),this.programManager=new Pi(this.context.profiler,e.glContext,this.layoutStrategy),this.textureManager=new ki(e.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:e.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=e.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new pi(this)}onGraphInitialized(e){let n=e.getValues().filter(t=>t.from===-1&&t.tensor).map(t=>t.tensor.dataId);this.initializers=new Set(n)}isInitializer(e){return this.initializers?this.initializers.has(e):!1}addInitializer(e){this.initializers.add(e)}getTextureData(e,n){return n?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,n,t=!1){je.verbose("WebGLSessionHandler","Storing Texture data in cache"),t?this.packedTextureDataCache.set(e,n):this.unpackedTextureDataCache.set(e,n)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(e=>this.textureManager.releaseTexture(e,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(e=>this.textureManager.releaseTexture(e,!0)),this.unpackedTextureDataCache=new Map}resolve(e,n,t){let o=fl(e,n,zp);return{impl:o.opImpl,context:o.opInit?o.opInit(e,t):e}}}});function ox(r){let e=0;for(;e<r.length&&r[e]();++e);return e-1}var mo,eh=R(()=>{"use strict";Bt();lo();lo();dr();mo=class{constructor(e,n){this.frameBufferBound=!1;this.itemsToPoll=[];this.gl=e,this.version=n,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(e,n,t,o){let i=this.gl,u=i.createTexture();i.bindTexture(i.TEXTURE_2D,u),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE);let a=o?t.encode(o,e*n):null;return i.texImage2D(i.TEXTURE_2D,0,t.internalFormat,e,n,0,t.format,t.textureType,a),this.checkError(),u}updateTexture(e,n,t,o,i){let u=this.gl;u.bindTexture(u.TEXTURE_2D,e);let a=o.encode(i,n*t);u.texSubImage2D(u.TEXTURE_2D,0,0,0,n,t,o.format,o.textureType,a),this.checkError()}attachFramebuffer(e,n,t){let o=this.gl;o.bindTexture(o.TEXTURE_2D,e),o.bindFramebuffer(o.FRAMEBUFFER,this.framebuffer),o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,e,0),this.checkError(),o.viewport(0,0,n,t),o.scissor(0,0,n,t)}readTexture(e,n,t,o,i,u){let a=this.gl;u||(u=1),this.frameBufferBound||this.attachFramebuffer(e,n,t);let s=this.getEncoder(i,u),l=s.allocate(n*t);return a.bindTexture(a.TEXTURE_2D,e),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e,0),a.readPixels(0,0,n,t,a.RGBA,s.textureType,l),this.checkError(),s.decode(l,o)}isFramebufferReady(){return!0}getActiveTexture(){let e=this.gl;return`TEXTURE${e.getParameter(this.gl.ACTIVE_TEXTURE)-e.TEXTURE0}`}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(e,n){let t=this.gl;t.vertexAttribPointer(e,3,t.FLOAT,!1,20,0),t.enableVertexAttribArray(e),n!==-1&&(t.vertexAttribPointer(n,2,t.FLOAT,!1,20,12),t.enableVertexAttribArray(n)),this.checkError()}createProgram(e,n){let t=this.gl,o=t.createProgram();return t.attachShader(o,e),t.attachShader(o,n),t.linkProgram(o),o}compileShader(e,n){let t=this.gl,o=t.createShader(n);if(!o)throw new Error(`createShader() returned null with type ${n}`);if(t.shaderSource(o,e),t.compileShader(o),t.getShaderParameter(o,t.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${t.getShaderInfoLog(o)}
Shader source:
${e}`);return o}deleteShader(e){this.gl.deleteShader(e)}bindTextureToUniform(e,n,t){let o=this.gl;o.activeTexture(o.TEXTURE0+n),this.checkError(),o.bindTexture(o.TEXTURE_2D,e),this.checkError(),o.uniform1i(t,n),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(xe.debug){let e=this.gl,n=e.getError(),t="";switch(n){case e.NO_ERROR:return;case e.INVALID_ENUM:t="INVALID_ENUM";break;case e.INVALID_VALUE:t="INVALID_VALUE";break;case e.INVALID_OPERATION:t="INVALID_OPERATION";break;case e.INVALID_FRAMEBUFFER_OPERATION:t="INVALID_FRAMEBUFFER_OPERATION";break;case e.OUT_OF_MEMORY:t="OUT_OF_MEMORY";break;case e.CONTEXT_LOST_WEBGL:t="CONTEXT_LOST_WEBGL";break;default:t=`Unknown WebGL Error: ${n.toString(16)}`}throw new Error(t)}}deleteTexture(e){this.gl.deleteTexture(e)}deleteProgram(e){this.gl.deleteProgram(e)}getEncoder(e,n,t=0){if(this.version===2)return new ci(this.gl,n);switch(e){case"float":return t===1||this.isRenderFloat32Supported?new uo(this.gl,n):new uo(this.gl,n,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new fi(this.gl,n);default:throw new Error(`Invalid dataType: ${e}`)}}clearActiveTextures(){let e=this.gl;for(let n=0;n<this.maxTextureImageUnits;++n)e.activeTexture(e.TEXTURE0+n),e.bindTexture(e.TEXTURE_2D,null)}dispose(){if(this.disposed)return;let e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(this.framebuffer),e.bindBuffer(e.ARRAY_BUFFER,null),e.deleteBuffer(this.vertexbuffer),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),e.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){let e=this.gl,n=e.createBuffer();if(!n)throw new Error("createBuffer() returned null");let t=this.createDefaultGeometry();return e.bindBuffer(e.ARRAY_BUFFER,n),e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW),this.checkError(),n}createFramebuffer(){let e=this.gl.createFramebuffer();if(!e)throw new Error("createFramebuffer returned null");return e}queryVitalParameters(){let e=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=e.getParameter(e.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){let e=this.gl,n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);let t=this.version===2?e.RGBA32F:e.RGBA;e.texImage2D(e.TEXTURE_2D,0,t,1,1,0,e.RGBA,e.FLOAT,null);let o=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(o),i}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){let e=this.gl,n,t,o,i,u;try{n=e.createTexture(),t=e.createFramebuffer(),e.bindTexture(e.TEXTURE_2D,n);let a=this.version===2?e.RGBA32F:e.RGBA;return e.texImage2D(e.TEXTURE_2D,0,a,1,1,0,e.RGBA,e.FLOAT,null),e.bindFramebuffer(e.FRAMEBUFFER,t),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0),e.enable(e.BLEND),o=e.createShader(e.VERTEX_SHADER),!o||(e.shaderSource(o,"void main(){}"),e.compileShader(o),i=e.createShader(e.FRAGMENT_SHADER),!i)||(e.shaderSource(i,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),e.compileShader(i),u=e.createProgram(),!u)?!1:(e.attachShader(u,o),e.attachShader(u,i),e.linkProgram(u),e.useProgram(u),e.drawArrays(e.POINTS,0,1),e.getError()===e.NO_ERROR)}finally{e.disable(e.BLEND),u&&e.deleteProgram(u),o&&e.deleteShader(o),i&&e.deleteShader(i),t&&(e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(t)),n&&(e.bindTexture(e.TEXTURE_2D,null),e.deleteTexture(n))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let e=this.gl,n=this.disjointTimerQueryWebgl2Extension,t=e.createQuery();return e.beginQuery(n.TIME_ELAPSED_EXT,t),t}else throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let e=this.gl,n=this.disjointTimerQueryWebgl2Extension;e.endQuery(n.TIME_ELAPSED_EXT);return}else throw new Error("WebGL1 profiling currently not supported")}isTimerResultAvailable(e){let n=!1,t=!1;if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let o=this.gl,i=this.disjointTimerQueryWebgl2Extension;n=o.getQueryParameter(e,o.QUERY_RESULT_AVAILABLE),t=o.getParameter(i.GPU_DISJOINT_EXT)}else throw new Error("WebGL1 profiling currently not supported");return n&&!t}getTimerResult(e){let n=0;if(this.version===2){let t=this.gl;n=t.getQueryParameter(e,t.QUERY_RESULT),t.deleteQuery(e)}else throw new Error("WebGL1 profiling currently not supported");return n/1e6}async waitForQueryAndGetTime(e){return await Ka(()=>this.isTimerResultAvailable(e)),this.getTimerResult(e)}async createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let n,t=e,o=t.fenceSync(t.SYNC_GPU_COMMANDS_COMPLETE,0);return e.flush(),o===null?n=()=>!0:n=()=>{let i=t.clientWaitSync(o,0,0);return i===t.ALREADY_SIGNALED||i===t.CONDITION_SATISFIED},{query:o,isFencePassed:n}}async pollFence(e){return new Promise(n=>{this.addItemToPoll(()=>e.isFencePassed(),()=>n())})}pollItems(){let e=ox(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=e;++n){let{resolveFn:t}=this.itemsToPoll[n];t()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}async addItemToPoll(e,n){this.itemsToPoll.push({isDoneFn:e,resolveFn:n}),!(this.itemsToPoll.length>1)&&await Ka(()=>(this.pollItems(),this.itemsToPoll.length===0))}}});function _s(r){let e;if((!r||r==="webgl2")&&"webgl2"in Pn?e=Pn.webgl2:(!r||r==="webgl")&&"webgl"in Pn&&(e=Pn.webgl),!e)try{let t=ax();e=th(t,r)}catch{let o=ix();e=th(o,r)}r=r||e.version===1?"webgl":"webgl2";let n=e.gl;return Pn[r]=e,n.isContextLost()?(delete Pn[r],_s(r)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),e)}function th(r,e){let n={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1},t,o=n;if((!e||e==="webgl2")&&(t=r.getContext("webgl2",o),t))try{return new mo(t,2)}catch(i){je.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${i}`)}if((!e||e==="webgl")&&(t=r.getContext("webgl",o)||r.getContext("experimental-webgl",o),t))try{return new mo(t,1)}catch(i){je.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${i}`)}throw new Error("WebGL is not supported")}function ix(){if(typeof document>"u")throw new TypeError("failed to create canvas: document is not supported");let r=document.createElement("canvas");return r.width=1,r.height=1,r}function ax(){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}var Pn,rh=R(()=>{"use strict";Vt();eh();Pn={}});var Bi,nh=R(()=>{"use strict";Bt();Vt();Qp();rh();Bi=class{get contextId(){return xe.webgl.contextId}set contextId(e){xe.webgl.contextId=e}get matmulMaxBatchSize(){return xe.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(e){xe.webgl.matmulMaxBatchSize=e}get textureCacheMode(){return xe.webgl.textureCacheMode}set textureCacheMode(e){xe.webgl.textureCacheMode=e}get pack(){return xe.webgl.pack}set pack(e){xe.webgl.pack=e}get async(){return xe.webgl.async}set async(e){xe.webgl.async=e}initialize(){try{return this.glContext=_s(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),je.setWithEnv(xe),xe.webgl.context||Object.defineProperty(xe.webgl,"context",{value:this.glContext.gl}),je.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(e){return je.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${e}`),!1}}createSessionHandler(e){return new Di(this,e)}dispose(){this.glContext.dispose()}}});async function Ss(r){if(r){let e=typeof r=="string"?[r]:r;for(let n of e){let t=oh.get(n);if(t)return t;let o=await ux(n);if(o)return o}}else return Ss(["webgl"]);throw new Error("no available backend to use")}async function ux(r){let e=sx;if(typeof e[r]<"u"&&lx(e[r])){let n=e[r],t=n.initialize();if(typeof t=="object"&&"then"in t&&(t=await t),t)return oh.set(r,n),n}}function lx(r){let e=r;return"initialize"in e&&typeof e.initialize=="function"&&"createSessionHandler"in e&&typeof e.createSessionHandler=="function"&&"dispose"in e&&typeof e.dispose=="function"}var oh,sx,ih=R(()=>{"use strict";nh();oh=new Map,sx={webgl:new Bi}});var Is,Ri,ah=R(()=>{"use strict";Vt();Is=class{constructor(e,n){this.op=e;this.node=n}},Ri=class{constructor(e,n,t){this.graph=e;this.profiler=t;this.initialize(n)}initialize(e){this.profiler.event("session","ExecutionPlan.initialize",()=>{let n=this.graph.getNodes();if(n.length!==e.length)throw new Error("The size of nodes and OPs do not match.");this._ops=e.map((t,o)=>new Is(t,n[o])),this.reset(),this._starter=[],this._ops.forEach((t,o)=>{let i=!0;for(let u of t.node.inputs)if(!this._values[u]&&this.graph.getInputIndices().indexOf(u)===-1){i=!1;break}i&&this._starter.push(o)})})}reset(){this._values=this.graph.getValues().map(e=>e.tensor)}async execute(e,n){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();let t=e.createInferenceHandler(),o=this.graph.getInputIndices();if(n.length!==o.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${n.length} expected: ${o.length}`);n.forEach((d,f)=>{let p=o[f];this._values[p]=d});let i=this._starter.slice(0),u=this.graph.getValues(),a=this.graph.getNodes(),s=0;for(;s<i.length;){let d=i[s++],f=this._ops[d],p=f.node.inputs.map(_=>this._values[_]);if(p.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${f.node}`);let g=p;je.verbose("ExecPlan",`Runing op:${f.node.name} (${g.map((_,x)=>`'${f.node.inputs[x]}': ${_.type}[${_.dims.join(",")}]`).join(", ")})`);let b=await this.profiler.event("node",f.node.name,async()=>f.op.impl(t,g,f.op.context));if(b.length!==f.node.outputs.length)throw new Error("the size of output does not match model definition.");b.forEach((_,x)=>{let S=f.node.outputs[x];if(this._values[S])throw new Error(`output [${S}] already has value: op:${f.node.name}`);this._values[S]=_});let y=new Set;b.forEach((_,x)=>{let S=f.node.outputs[x];for(let O of u[S].to){let C=a[O],N=!0;for(let k of C.inputs)if(!this._values[k]){N=!1;break}N&&y.add(O)}}),i.push(...y)}let l=[];for(let d=0;d<this.graph.getOutputIndices().length;d++){let f=this.graph.getOutputIndices()[d],p=this._values[f];if(p===void 0)throw new Error(`required output [${f}] does not have value`);f===0?await p.getData():p.data,l.push(p)}return je.verbose("ExecPlan","disposing of inferenceHandler"),t.dispose(),l})}}});var Pe,Kt,go,sh=R(()=>{"use strict";ro();Pe=vn(Tn());nn();He();Kt=se.experimental.fbs,go=class r{constructor(e){if(this._attributes=new Map,e!=null){for(let n of e)n instanceof Pe.onnx.AttributeProto?this._attributes.set(n.name,[r.getValue(n),r.getType(n)]):n instanceof Kt.Attribute&&this._attributes.set(n.name(),[r.getValue(n),r.getType(n)]);if(this._attributes.size<e.length)throw new Error("duplicated attribute names")}}set(e,n,t){this._attributes.set(e,[t,n])}delete(e){this._attributes.delete(e)}getFloat(e,n){return this.get(e,"float",n)}getInt(e,n){return this.get(e,"int",n)}getString(e,n){return this.get(e,"string",n)}getTensor(e,n){return this.get(e,"tensor",n)}getFloats(e,n){return this.get(e,"floats",n)}getInts(e,n){return this.get(e,"ints",n)}getStrings(e,n){return this.get(e,"strings",n)}getTensors(e,n){return this.get(e,"tensors",n)}get(e,n,t){let o=this._attributes.get(e);if(o===void 0){if(t!==void 0)return t;throw new Error(`required attribute not found: ${e}`)}if(o[1]!==n)throw new Error(`type mismatch: expected ${n} but got ${o[1]}`);return o[0]}static getType(e){let n=e instanceof Pe.onnx.AttributeProto?e.type:e.type();switch(n){case Pe.onnx.AttributeProto.AttributeType.FLOAT:return"float";case Pe.onnx.AttributeProto.AttributeType.INT:return"int";case Pe.onnx.AttributeProto.AttributeType.STRING:return"string";case Pe.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case Pe.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case Pe.onnx.AttributeProto.AttributeType.INTS:return"ints";case Pe.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case Pe.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${Pe.onnx.AttributeProto.AttributeType[n]}`)}}static getValue(e){let n=e instanceof Pe.onnx.AttributeProto?e.type:e.type();if(n===Pe.onnx.AttributeProto.AttributeType.GRAPH||n===Pe.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");let t=this.getValueNoCheck(e);if(n===Pe.onnx.AttributeProto.AttributeType.INT&&Lt.isLong(t))return Lt.longToNumber(t);if(n===Pe.onnx.AttributeProto.AttributeType.INTS){let o=t,i=new Array(o.length);for(let u=0;u<o.length;u++){let a=o[u];i[u]=Lt.longToNumber(a)}return i}if(n===Pe.onnx.AttributeProto.AttributeType.TENSOR)return e instanceof Pe.onnx.AttributeProto?mt.fromProto(t):mt.fromOrtTensor(t);if(n===Pe.onnx.AttributeProto.AttributeType.TENSORS){if(e instanceof Pe.onnx.AttributeProto)return t.map(i=>mt.fromProto(i));if(e instanceof Kt.Attribute)return t.map(i=>mt.fromOrtTensor(i))}return n===Pe.onnx.AttributeProto.AttributeType.STRING&&e instanceof Pe.onnx.AttributeProto?so(t):n===Pe.onnx.AttributeProto.AttributeType.STRINGS&&e instanceof Pe.onnx.AttributeProto?t.map(so):t}static getValueNoCheck(e){return e instanceof Pe.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(e):this.getValueNoCheckFromOrtFormat(e)}static getValueNoCheckFromOnnxFormat(e){switch(e.type){case Pe.onnx.AttributeProto.AttributeType.FLOAT:return e.f;case Pe.onnx.AttributeProto.AttributeType.INT:return e.i;case Pe.onnx.AttributeProto.AttributeType.STRING:return e.s;case Pe.onnx.AttributeProto.AttributeType.TENSOR:return e.t;case Pe.onnx.AttributeProto.AttributeType.GRAPH:return e.g;case Pe.onnx.AttributeProto.AttributeType.FLOATS:return e.floats;case Pe.onnx.AttributeProto.AttributeType.INTS:return e.ints;case Pe.onnx.AttributeProto.AttributeType.STRINGS:return e.strings;case Pe.onnx.AttributeProto.AttributeType.TENSORS:return e.tensors;case Pe.onnx.AttributeProto.AttributeType.GRAPHS:return e.graphs;default:throw new Error(`unsupported attribute type: ${Pe.onnx.AttributeProto.AttributeType[e.type]}`)}}static getValueNoCheckFromOrtFormat(e){switch(e.type()){case Kt.AttributeType.FLOAT:return e.f();case Kt.AttributeType.INT:return e.i();case Kt.AttributeType.STRING:return e.s();case Kt.AttributeType.TENSOR:return e.t();case Kt.AttributeType.GRAPH:return e.g();case Kt.AttributeType.FLOATS:return e.floatsArray();case Kt.AttributeType.INTS:{let n=[];for(let t=0;t<e.intsLength();t++)n.push(e.ints(t));return n}case Kt.AttributeType.STRINGS:{let n=[];for(let t=0;t<e.stringsLength();t++)n.push(e.strings(t));return n}case Kt.AttributeType.TENSORS:{let n=[];for(let t=0;t<e.tensorsLength();t++)n.push(e.tensors(t));return n}default:throw new Error(`unsupported attribute type: ${Kt.AttributeType[e.type()]}`)}}}});var Os,Mi,Es,pr,Li,As,uh=R(()=>{"use strict";sh();ro();Os=vn(Tn());nn();He();Mi=se.experimental.fbs,Es={from:(r,e)=>new As(r,e)},pr=class{constructor(e){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,e&&(this.type=St.tensorValueTypeFromProto(e.type.tensorType))}get from(){return this._from}get to(){return this._to}},Li=class{constructor(e,n){e instanceof Os.onnx.NodeProto?(this.name=e.name,this.opType=e.opType,this.attributes=new go(e.attribute)):e instanceof Mi.Node&&(this.name=n??e.name(),this.opType=e.opType(),this.attributes=new go(St.tensorAttributesFromORTFormat(e))),this.inputs=[],this.outputs=[],this.executeNode=!0}},As=class{constructor(e,n){if(!e)throw new TypeError("graph is empty");this.buildGraph(e),this.transformGraph(n),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(e){if(e instanceof Os.onnx.GraphProto)this.buildGraphFromOnnxFormat(e);else if(e instanceof Mi.Graph)this.buildGraphFromOrtFormat(e);else throw new TypeError("Graph type is not supported.")}buildGraphFromOnnxFormat(e){let n=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let t=new Map;if(!e.input)throw new Error("missing information in graph: input");let o=[];for(let i of e.input){if(n.has(i.name))throw new Error(`duplicated input name: ${i.name}`);let u=this._allData.push(new pr(i))-1;n.set(i.name,u),o.push(i.name)}if(!e.initializer)throw new Error("missing information in graph: initializer");for(let i of e.initializer){let u=n.get(i.name);if(u===void 0){let a=new pr;a.type={shape:{dims:St.tensorDimsFromProto(i.dims)},tensorType:St.tensorDataTypeFromProto(i.dataType)},u=this._allData.push(a)-1,n.set(i.name,u)}this._allData[u]._from=-1,this._allData[u].tensor=mt.fromProto(i)}for(let i=0;i<this._allData.length;i++)this._allData[i].tensor||(this._allInputIndices.push(i),this._allInputNames.push(o[i]));if(!e.output)throw new Error("missing information in graph: output");for(let i of e.output){if(n.has(i.name))throw new Error(`duplicated output name: ${i.name}`);let u=this._allData.push(new pr(i))-1;n.set(i.name,u),this._allOutputIndices.push(u),this._allOutputNames.push(i.name)}if(!e.node)throw new Error("missing information in graph: node");for(let i of e.node){if(!i.name)for(let a=0;;a++){let s=`unnamed_${i.opType}_${a}`;if(!t.has(s)){i.name=s;break}}if(t.has(i.name))throw new Error(`duplicated node name: ${i.name}`);let u=this._nodes.push(new Li(i))-1;t.set(i.name,u)}for(let i=0;i<this._nodes.length;i++){let u=this._nodes[i],a=e.node[i];if(!a.output)throw new Error(`missing output for node: ${a.name}`);for(let s of a.output){let l=n.get(s);if(typeof l>"u"&&(l=this._allData.push(new pr)-1,n.set(s,l)),u.outputs.push(l),this._allData[l]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${l}`);if(this._allData[l]._from=i,a.opType==="Constant"){if(!a.attribute||a.attribute.length!==1||!a.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!a.output||a.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");u.outputs.pop(),u.executeNode=!1,this._allData[l]._from=-1,this._allData[l].tensor=mt.fromProto(a.attribute[0].t)}}}for(let i=0;i<this._nodes.length;i++){let u=this._nodes[i],a=e.node[i];if(!a.input)throw new Error(`missing input for node: ${a.name}`);for(let s of a.input){let l=n.get(s);if(typeof l>"u"){if(s===""&&(a.input.length===3||a.input.length===4)&&a.opType==="Resize")continue;throw new Error(`unrecognized input '${s}' for node: ${a.name}`)}u.inputs.push(l),this._allData[l]._to.push(i)}}return!0}buildGraphFromOrtFormat(e){let n=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let t=new Map,o=[];for(let i=0;i<e.inputsLength();i++){let u=e.inputs(i);if(n.has(u))throw new Error(`duplicated input name: ${u}`);for(let a=0;a<e.nodeArgsLength();a++)if(e.nodeArgs(a)?.name()===u){let s=new pr;if(e.nodeArgs(a)?.type()?.valueType()!==Mi.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");let d=e.nodeArgs(a).type().value(new Mi.TensorTypeAndShape),f=St.tensorDataTypeFromProto(d.elemType()),p=d.shape(),g=[];for(let y=0;y<p.dimLength();y++)g.push(Lt.longToNumber(p.dim(y).value().dimValue()));s.type={shape:{dims:g},tensorType:f};let b=this._allData.push(s)-1;n.set(u,b),o.push(u)}}for(let i=0;i<e.initializersLength();i++){let u=e.initializers(i),a=n.get(u.name());if(a===void 0){let s=new pr,l=St.tensorDimsFromORTFormat(u),d=St.tensorDataTypeFromProto(u.dataType());s.type={shape:{dims:l},tensorType:d},a=this._allData.push(s)-1,n.set(u.name(),a)}this._allData[a]._from=-1,this._allData[a].tensor=mt.fromOrtTensor(u)}for(let i=0;i<this._allData.length;i++)this._allData[i].tensor||(this._allInputIndices.push(i),this._allInputNames.push(o[i]));for(let i=0;i<e.outputsLength();i++){let u=e.outputs(i);if(n.has(u))throw new Error(`duplicated output name: ${u}`);let a=this._allData.push(new pr)-1;n.set(u,a),this._allOutputIndices.push(a),this._allOutputNames.push(u)}if(!e.nodes)throw new Error("missing information in graph: node");for(let i=0;i<e.nodesLength();i++){let u=e.nodes(i),a=u.name();if(!a)for(let l=0;a=`unnamed_${u.opType()}_${l}`,!!t.has(a);l++);if(t.has(a))throw new Error(`duplicated node name: ${a}`);let s=this._nodes.push(new Li(u,a))-1;t.set(a,s)}for(let i=0;i<this._nodes.length;i++){let u=this._nodes[i],a=e.nodes(i);if(a==null)throw new Error(`No node exists at index ${i}`);if(a?.outputsLength()===0)throw new Error(`missing output for node: ${a.name}`);for(let s=0;s<a?.outputsLength();s++){let l=a?.outputs(s),d=n.get(l);if(typeof d>"u"&&(d=this._allData.push(new pr)-1,n.set(l,d)),u.outputs.push(d),this._allData[d]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${d}`);if(this._allData[d]._from=i,a.opType()==="Constant"){if(a.attributesLength()!==1||!a.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(a.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");u.outputs.pop(),u.executeNode=!1,this._allData[d]._from=-1,this._allData[d].tensor=mt.fromOrtTensor(a.attributes(0).t())}}}for(let i=0;i<this._nodes.length;i++){let u=this._nodes[i],a=e.nodes(i);if(a.inputsLength()===0)throw new Error(`missing input for node: ${a.name}`);for(let s=0;s<a.inputsLength();s++){let l=a.inputs(s),d=n.get(l);if(typeof d>"u")throw new Error(`unrecognized input '${l}' for node: ${a.name()}`);u.inputs.push(d),this._allData[d]._to.push(i)}}}checkIsAcyclic(){let e=new Set;this._allInputIndices.forEach(o=>{this._allData[o]._to.forEach(u=>{e.add(u)})});let n=Array.from(e),t=new Array(this._nodes.length).fill("white");for(;n.length>0;){let o=n.pop();t[o]==="gray"?t[o]="black":(n.push(o),t[o]="gray",this._nodes[o].outputs.forEach(i=>{let u=this._allData[i];if(typeof u.tensor<"u")throw new Error("node outputs should not be initialized");if(u._from!==o)throw new Error("from property of the Value object doesn't match index of Node being processed");u._to.forEach(a=>{if(t[a]==="gray")throw new Error("model graph is cyclic");t[a]==="white"&&n.push(a)})}))}}transformGraph(e){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),e&&e.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let e=0,n=new Array(this._nodes.length,0),t=0;for(let o=0;o<this._nodes.length;o++)n[o]=t,this._nodes[o].executeNode?(t!==o&&(this._nodes[t]=this._nodes[o]),t++):this._nodes[o].outputs.forEach(i=>{this._allData[i]._from=-2});this._nodes.splice(t,this._nodes.length-t);for(let o=0;o<this._allData.length;o++){let i=this._allData[o];i._from!==void 0&&i._from!==-1&&i._from!==-2&&(i._from=n[i._from]);for(let u=0;u<i._to.length;u++)if(i._to[u]>=0)i._to[u]=n[i._to[u]];else throw new Error("Trying to update a removed node")}e=0;for(let o=0;o<this._allData.length;o++){if(this._allData[o].from===-2&&this._allOutputIndices.indexOf(o+e)===-1){e++,this._allData.splice(o,1),o--;continue}if(e>0){let i=-1;this._allData[o].from!==void 0&&this._allData[o].from!==-1?(i=this._nodes[this._allData[o].from].outputs.indexOf(o+e),i!==-1&&(this._nodes[this._allData[o].from].outputs[i]=o)):(i=this._allInputIndices.indexOf(o+e),i!==-1&&(this._allInputIndices[i]=o)),this._allData[o].to.forEach(u=>{i=this._nodes[u].inputs.indexOf(o+e),i!==-1&&(this._nodes[u].inputs[i]=o)}),this._allData[o].to.length===0&&(i=this._allOutputIndices.indexOf(o+e),i!==-1&&(this._allOutputIndices[i]=o))}}}deleteNode(e){let n=this._nodes[e];if(n.outputs.length>1){for(let a=1;a<n.outputs.length;a++)if(this._allData[n.outputs[a]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}n.executeNode=!1;let t=n.inputs[0],o=n.outputs[0],i=this._allData[o].to;for(let a=0;a<n.inputs.length;a++){let s=this._allData[n.inputs[a]].to.indexOf(e);if(s===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[n.inputs[a]].to.splice(s,1)}this._allData[o]._to=[];let u=this._allOutputIndices.indexOf(o);if(u!==-1&&(this._allOutputIndices[u]=t),i&&i.length>0)for(let a of i){let s=this._nodes[a].inputs.indexOf(o);if(s===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[a].inputs[s]=t,this._allData[t].to.push(a)}}removeAllDropoutNodes(){let e=0;for(let n of this._nodes){if(n.opType==="Dropout"){if(n.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(n.outputs.length!==1&&n.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(n.outputs.length===2&&this._allData[n.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(e)}e++}}removeAllIdentityNodes(){let e=0;for(let n of this._nodes)n.opType==="Identity"&&this.deleteNode(e),e++}isActivation(e){switch(e.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(let e of this._nodes)if(e.opType==="Conv"){let n=this._allData[e.outputs[0]]._to;if(n.length===1&&this.isActivation(this._nodes[n[0]])){let t=this._nodes[n[0]];if(t.opType==="Clip")if(t.inputs.length===1)try{e.attributes.set("activation_params","floats",[t.attributes.getFloat("min"),t.attributes.getFloat("max")])}catch{e.attributes.set("activation_params","floats",[tn,rn])}else if(t.inputs.length>=3&&this._allData[t.inputs[1]].tensor!==void 0&&this._allData[t.inputs[2]].tensor!==void 0)e.attributes.set("activation_params","floats",[this._allData[t.inputs[1]].tensor.floatData[0],this._allData[t.inputs[2]].tensor.floatData[0]]);else continue;e.attributes.set("activation","string",t.opType),this.deleteNode(n[0])}}}}});var lh,dx,zi,dh=R(()=>{"use strict";oi();uh();ro();lh=vn(Tn());He();dx=se.experimental.fbs,zi=class{constructor(){}load(e,n,t){if(!t)try{this.loadFromOnnxFormat(e,n);return}catch(o){if(t!==void 0)throw o}this.loadFromOrtFormat(e,n)}loadFromOnnxFormat(e,n){let t=lh.onnx.ModelProto.decode(e);if(Lt.longToNumber(t.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=t.opsetImport.map(i=>({domain:i.domain,version:Lt.longToNumber(i.version)})),this._graph=Es.from(t.graph,n)}loadFromOrtFormat(e,n){let t=new D.ByteBuffer(e),o=dx.InferenceSession.getRootAsInferenceSession(t).model();if(Lt.longToNumber(o.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let u=0;u<o.opsetImportLength();u++){let a=o.opsetImport(u);this._opsets.push({domain:a?.domain(),version:Lt.longToNumber(a.version())})}this._graph=Es.from(o.graph(),n)}get graph(){return this._graph}get opsets(){return this._opsets}}});var Ni,ch=R(()=>{"use strict";ih();ah();Vt();dh();Ni=class{constructor(e={}){this._initialized=!1,this.backendHint=e.backendHint,this.profiler=ri.create(e.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(e,n,t){await this.profiler.event("session","Session.loadModel",async()=>{let o=await Ss(this.backendHint);if(this.sessionHandler=o.createSessionHandler(this.context),this._model=new zi,typeof e=="string"){let i=e.endsWith(".ort");if(typeof process<"u"&&process.versions&&process.versions.node){let u=await(void 0)(e);this.initialize(u,i)}else{let a=await(await fetch(e)).arrayBuffer();this.initialize(new Uint8Array(a),i)}}else if(ArrayBuffer.isView(e))this.initialize(e);else{let i=new Uint8Array(e,n||0,t||e.byteLength);this.initialize(i)}})}initialize(e,n){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{let t=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(e,t,n),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new Ri(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(e){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{let n=this.normalizeAndValidateInputs(e),t=await this._executionPlan.execute(this.sessionHandler,n);return this.createOutput(t)})}normalizeAndValidateInputs(e){let n=this._model.graph.getInputNames();if(Array.isArray(e)){if(e.length!==n.length)throw new Error(`incorrect input array length: expected ${n.length} but got ${e.length}`)}else{if(e.size!==n.length)throw new Error(`incorrect input map size: expected ${n.length} but got ${e.size}`);let t=new Array(e.size),o=0;for(let i=0;i<n.length;++i){let u=e.get(n[i]);if(!u)throw new Error(`missing input tensor for: '${name}'`);t[o++]=u}e=t}if(!this.context.graphInputTypes||this.context.graphInputTypes.length===0||!this.context.graphInputDims||this.context.graphInputDims.length===0){let t=this._model.graph.getInputIndices(),o=this._model.graph.getValues(),i=new Array(t.length);for(let u=0;u<t.length;++u){let a=o[t[u]];i[u]=a.type.shape.dims,this.context.graphInputTypes.push(a.type.tensorType),this.context.graphInputDims.push(e[u].dims)}this.validateInputTensorDims(i,e,!0)}else this.validateInputTensorDims(this.context.graphInputDims,e,!1);return this.validateInputTensorTypes(this.context.graphInputTypes,e),e}validateInputTensorTypes(e,n){for(let t=0;t<n.length;t++){let o=e[t],i=n[t].type;if(o!==i)throw new Error(`input tensor[${t}] check failed: expected type '${o}' but got ${i}`)}}validateInputTensorDims(e,n,t){for(let o=0;o<n.length;o++){let i=e[o],u=n[o].dims;if(!this.compareTensorDims(i,u,t))throw new Error(`input tensor[${o}] check failed: expected shape '[${i.join(",")}]' but got [${u.join(",")}]`)}}compareTensorDims(e,n,t){if(e.length!==n.length)return!1;for(let o=0;o<e.length;++o)if(e[o]!==n[o]&&(!t||e[o]!==0))return!1;return!0}createOutput(e){let n=this._model.graph.getOutputNames();if(e.length!==n.length)throw new Error("expected number of outputs do not match number of generated outputs");let t=new Map;for(let o=0;o<n.length;++o)t.set(n[o],e[o]);return t}initializeOps(e){let n=e.getNodes();this._ops=new Array(n.length);for(let t=0;t<n.length;t++)this._ops[t]=this.sessionHandler.resolve(n[t],this._model.opsets,e)}}});var Fi,fh=R(()=>{"use strict";Bt();nn();Fi=class{constructor(e){this.session=e;this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(e,n,t){let o=new Map;for(let a in e)if(Object.hasOwnProperty.call(e,a)){let s=e[a];o.set(a,new mt(s.dims,s.type,void 0,void 0,s.data))}let i=await this.session.run(o),u={};return i.forEach((a,s)=>{u[s]=new gt(a.type,a.data,a.dims)}),u}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}});var ph={};kr(ph,{onnxjsBackend:()=>fx});var Cs,fx,hh=R(()=>{"use strict";ch();fh();Cs=class{async init(){}async createInferenceSessionHandler(e,n){let t=new Ni(n);return typeof e=="string"?await t.loadModel(e):await t.loadModel(e),new Fi(t)}},fx=new Cs});var Ps={};kr(Ps,{readFile:()=>px});var px,ks=R(()=>{px=void 0});var Ds={};kr(Ds,{join:()=>hx});var hx,Bs=R(()=>{hx=void 0});var bh=Ye((gh,Rs)=>{"use strict";var mh=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(e={}){var n=e,t,o;n.ready=new Promise((h,v)=>{t=h,o=v}),n.jsepInit=(h,v,T,E,M,X,j,we)=>{n.Za=h,n.Oa=v,n.Qa=T,n.Ja=E,n.Pa=M,n.ra=X,n.Ra=j,n.Sa=we,v=(ie,he,de)=>(...Ee)=>{let Me=Ft,L=he?.();Ee=ie(...Ee);let be=he?.();return L!==be&&(ie=be,de(L),he=de=null),Ft!=Me?Do():Ee},T=ie=>async(...he)=>{try{if(n.Da)throw Error("Session already started");let de=n.Da={Ta:he[0],errors:[]},Ee=await ie(...he);if(n.Da!==de)throw Error("Session mismatch");h.flush();let Me=de.errors;if(0<Me.length){let L=await Promise.all(Me);if(L=L.filter(be=>be),0<L.length)throw Error(L.join(`
`))}return Ee}finally{n.Da=null}},n._OrtRun=T(v(n._OrtRun,()=>n._OrtRun,ie=>n._OrtRun=ie)),n._OrtRunWithBinding=T(v(n._OrtRunWithBinding,()=>n._OrtRunWithBinding,ie=>n._OrtRunWithBinding=ie)),n._OrtBindInput=v(n._OrtBindInput,()=>n._OrtBindInput,ie=>n._OrtBindInput=ie),n.jsepRegisterBuffer=(ie,he,de,Ee)=>h.registerBuffer(ie,he,de,Ee),n.jsepUnregisterBuffers=ie=>{h.unregisterBuffers(ie)},n.jsepGetBuffer=ie=>h.getBuffer(ie),n.jsepCreateDownloader=(ie,he,de)=>h.createDownloader(ie,he,de)};var i=Object.assign({},n),u="./this.program",a=(h,v)=>{throw v},s=typeof window=="object",l=typeof importScripts=="function",d=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",f="",p,g,b;if(d){var y=(ks(),Sr(Ps)),_=(Bs(),Sr(Ds));f=l?_.dirname(f)+"/":__dirname+"/",p=(h,v)=>(h=h.startsWith("file://")?new URL(h):_.normalize(h),y.readFileSync(h,v?void 0:"utf8")),b=h=>(h=p(h,!0),h.buffer||(h=new Uint8Array(h)),h),g=(h,v,T,E=!0)=>{h=h.startsWith("file://")?new URL(h):_.normalize(h),y.readFile(h,E?void 0:"utf8",(M,X)=>{M?T(M):v(E?X.buffer:X)})},!n.thisProgram&&1<process.argv.length&&(u=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),a=(h,v)=>{throw process.exitCode=h,v},n.inspect=()=>"[Emscripten Module object]"}else(s||l)&&(l?f=self.location.href:typeof document<"u"&&document.currentScript&&(f=document.currentScript.src),r&&(f=r),f.indexOf("blob:")!==0?f=f.substr(0,f.replace(/[?#].*/,"").lastIndexOf("/")+1):f="",p=h=>{var v=new XMLHttpRequest;return v.open("GET",h,!1),v.send(null),v.responseText},l&&(b=h=>{var v=new XMLHttpRequest;return v.open("GET",h,!1),v.responseType="arraybuffer",v.send(null),new Uint8Array(v.response)}),g=(h,v,T)=>{var E=new XMLHttpRequest;E.open("GET",h,!0),E.responseType="arraybuffer",E.onload=()=>{E.status==200||E.status==0&&E.response?v(E.response):T()},E.onerror=T,E.send(null)});var x=n.print||console.log.bind(console),S=n.printErr||console.error.bind(console);Object.assign(n,i),i=null,n.thisProgram&&(u=n.thisProgram),n.quit&&(a=n.quit);var O;n.wasmBinary&&(O=n.wasmBinary);var C=n.noExitRuntime||!0;typeof WebAssembly!="object"&&yt("no native wasm support detected");var N,k,U=!1,G,H,ne,P,J,Te,ae;function De(){var h=N.buffer;n.HEAP8=H=new Int8Array(h),n.HEAP16=new Int16Array(h),n.HEAP32=P=new Int32Array(h),n.HEAPU8=ne=new Uint8Array(h),n.HEAPU16=new Uint16Array(h),n.HEAPU32=J=new Uint32Array(h),n.HEAPF32=Te=new Float32Array(h),n.HEAPF64=ae=new Float64Array(h)}var re=[],Ce=[],Ne=[];function Se(){var h=n.preRun.shift();re.unshift(h)}var $e=0,ht=null,it=null;function yt(h){throw n.onAbort&&n.onAbort(h),h="Aborted("+h+")",S(h),U=!0,G=1,h=new WebAssembly.RuntimeError(h+". Build with -sASSERTIONS for more info."),o(h),h}function K(h){return h.startsWith("data:application/octet-stream;base64,")}var fe;if(fe="ort-wasm-simd.wasm",!K(fe)){var Ae=fe;fe=n.locateFile?n.locateFile(Ae,f):f+Ae}function Tt(h){if(h==fe&&O)return new Uint8Array(O);if(b)return b(h);throw"both async and sync fetching of the wasm failed"}function Dt(h){if(!O&&(s||l)){if(typeof fetch=="function"&&!h.startsWith("file://"))return fetch(h,{credentials:"same-origin"}).then(v=>{if(!v.ok)throw"failed to load wasm binary file at '"+h+"'";return v.arrayBuffer()}).catch(()=>Tt(h));if(g)return new Promise((v,T)=>{g(h,E=>v(new Uint8Array(E)),T)})}return Promise.resolve().then(()=>Tt(h))}function at(h,v,T){return Dt(h).then(E=>WebAssembly.instantiate(E,v)).then(E=>E).then(T,E=>{S("failed to asynchronously prepare wasm: "+E),yt(E)})}function vt(h,v){var T=fe;return O||typeof WebAssembly.instantiateStreaming!="function"||K(T)||T.startsWith("file://")||d||typeof fetch!="function"?at(T,h,v):fetch(T,{credentials:"same-origin"}).then(E=>WebAssembly.instantiateStreaming(E,h).then(v,function(M){return S("wasm streaming compile failed: "+M),S("falling back to ArrayBuffer instantiation"),at(T,h,v)}))}var Ot,or={912720:h=>{n.ra("Abs",h,void 0)},912771:h=>{n.ra("Neg",h,void 0)},912822:h=>{n.ra("Floor",h,void 0)},912875:h=>{n.ra("Ceil",h,void 0)},912927:h=>{n.ra("Reciprocal",h,void 0)},912985:h=>{n.ra("Sqrt",h,void 0)},913037:h=>{n.ra("Exp",h,void 0)},913088:h=>{n.ra("Erf",h,void 0)},913139:h=>{n.ra("Sigmoid",h,void 0)},913194:h=>{n.ra("Log",h,void 0)},913245:h=>{n.ra("Sin",h,void 0)},913296:h=>{n.ra("Cos",h,void 0)},913347:h=>{n.ra("Tan",h,void 0)},913398:h=>{n.ra("Asin",h,void 0)},913450:h=>{n.ra("Acos",h,void 0)},913502:h=>{n.ra("Atan",h,void 0)},913554:h=>{n.ra("Sinh",h,void 0)},913606:h=>{n.ra("Cosh",h,void 0)},913658:h=>{n.ra("Asinh",h,void 0)},913711:h=>{n.ra("Acosh",h,void 0)},913764:h=>{n.ra("Atanh",h,void 0)},913817:h=>{n.ra("Tanh",h,void 0)},913869:h=>{n.ra("Not",h,void 0)},913920:(h,v,T)=>{n.ra("Clip",h,{min:v,max:T})},913989:h=>{n.ra("Clip",h,void 0)},914041:(h,v)=>{n.ra("Elu",h,{alpha:v})},914099:h=>{n.ra("Relu",h,void 0)},914151:(h,v)=>{n.ra("LeakyRelu",h,{alpha:v})},914215:(h,v)=>{n.ra("ThresholdedRelu",h,{alpha:v})},914285:(h,v)=>{n.ra("Cast",h,{to:v})},914343:h=>{n.ra("Add",h,void 0)},914394:h=>{n.ra("Sub",h,void 0)},914445:h=>{n.ra("Mul",h,void 0)},914496:h=>{n.ra("Div",h,void 0)},914547:h=>{n.ra("Pow",h,void 0)},914598:h=>{n.ra("Equal",h,void 0)},914651:h=>{n.ra("Greater",h,void 0)},914706:h=>{n.ra("GreaterOrEqual",h,void 0)},914768:h=>{n.ra("Less",h,void 0)},914820:h=>{n.ra("LessOrEqual",h,void 0)},914879:(h,v,T,E,M)=>{n.ra("ReduceMean",h,{keepDims:!!v,noopWithEmptyAxes:!!T,axes:E?Array.from(P.subarray(M>>>0,M+E>>>0)):[]})},915043:(h,v,T,E,M)=>{n.ra("ReduceMax",h,{keepDims:!!v,noopWithEmptyAxes:!!T,axes:E?Array.from(P.subarray(M>>>0,M+E>>>0)):[]})},915206:(h,v,T,E,M)=>{n.ra("ReduceMin",h,{keepDims:!!v,noopWithEmptyAxes:!!T,axes:E?Array.from(P.subarray(M>>>0,M+E>>>0)):[]})},915369:(h,v,T,E,M)=>{n.ra("ReduceProd",h,{keepDims:!!v,noopWithEmptyAxes:!!T,axes:E?Array.from(P.subarray(M>>>0,M+E>>>0)):[]})},915533:(h,v,T,E,M)=>{n.ra("ReduceSum",h,{keepDims:!!v,noopWithEmptyAxes:!!T,axes:E?Array.from(P.subarray(M>>>0,M+E>>>0)):[]})},915696:(h,v,T,E,M)=>{n.ra("ReduceL1",h,{keepDims:!!v,noopWithEmptyAxes:!!T,axes:E?Array.from(P.subarray(M>>>0,M+E>>>0)):[]})},915858:(h,v,T,E,M)=>{n.ra("ReduceL2",h,{keepDims:!!v,noopWithEmptyAxes:!!T,axes:E?Array.from(P.subarray(M>>>0,M+E>>>0)):[]})},916020:(h,v,T,E,M)=>{n.ra("ReduceLogSum",h,{keepDims:!!v,noopWithEmptyAxes:!!T,axes:E?Array.from(P.subarray(M>>>0,M+E>>>0)):[]})},916186:(h,v,T,E,M)=>{n.ra("ReduceSumSquare",h,{keepDims:!!v,noopWithEmptyAxes:!!T,axes:E?Array.from(P.subarray(M>>>0,M+E>>>0)):[]})},916355:(h,v,T,E,M)=>{n.ra("ReduceLogSumExp",h,{keepDims:!!v,noopWithEmptyAxes:!!T,axes:E?Array.from(P.subarray(M>>>0,M+E>>>0)):[]})},916524:h=>{n.ra("Where",h,void 0)},916577:(h,v,T)=>{n.ra("Transpose",h,{perm:v?Array.from(P.subarray(T>>>0,T+v>>>0)):[]})},916690:(h,v,T,E,M,X,j,we,ie,he,de,Ee,Me,L,be)=>{n.ra("ConvTranspose",h,{format:ie?"NHWC":"NCHW",autoPad:v,dilations:[T],group:E,kernel_shape:[M],pads:[X,j],strides:[we],wIsConst:()=>!!H[he>>>0],outputPadding:de?Array.from(P.subarray(Ee>>>0,Ee+de>>>0)):[],outputShape:Me?Array.from(P.subarray(L>>>0,L+Me>>>0)):[],activation:lt(be)})},917104:(h,v,T,E,M,X,j,we,ie,he,de,Ee,Me,L)=>{n.ra("ConvTranspose",h,{format:we?"NHWC":"NCHW",autoPad:v,dilations:Array.from(P.subarray(T>>>0,T+2>>>0)),group:E,kernelShape:Array.from(P.subarray(M>>>0,M+2>>>0)),pads:Array.from(P.subarray(X>>>0,X+4>>>0)),strides:Array.from(P.subarray(j>>>0,j+2>>>0)),wIsConst:()=>!!H[ie>>>0],outputPadding:0<he?Array.from(P.subarray(de>>>0,de+he>>>0)):[],outputShape:0<Ee?Array.from(P.subarray(Me>>>0,Me+Ee>>>0)):[],activation:lt(L)})},917661:(h,v,T,E,M,X,j,we,ie,he,de,Ee,Me,L,be)=>{n.ra("ConvTranspose",h,{format:ie?"NHWC":"NCHW",autoPad:v,dilations:[T],group:E,kernel_shape:[M],pads:[X,j],strides:[we],wIsConst:()=>!!H[he>>>0],outputPadding:de?Array.from(P.subarray(Ee>>>0,Ee+de>>>0)):[],outputShape:Me?Array.from(P.subarray(L>>>0,L+Me>>>0)):[],activation:lt(be)})},918075:(h,v,T,E,M,X,j,we,ie,he,de,Ee,Me,L)=>{n.ra("ConvTranspose",h,{format:we?"NHWC":"NCHW",autoPad:v,dilations:Array.from(P.subarray(T>>>0,T+2>>>0)),group:E,kernelShape:Array.from(P.subarray(M>>>0,M+2>>>0)),pads:Array.from(P.subarray(X>>>0,X+4>>>0)),strides:Array.from(P.subarray(j>>>0,j+2>>>0)),wIsConst:()=>!!H[ie>>>0],outputPadding:0<he?Array.from(P.subarray(de>>>0,de+he>>>0)):[],outputShape:0<Ee?Array.from(P.subarray(Me>>>0,Me+Ee>>>0)):[],activation:lt(L)})},918632:(h,v)=>{n.ra("GlobalAveragePool",h,{format:v?"NHWC":"NCHW"})},918723:(h,v,T,E,M,X,j,we,ie,he,de,Ee,Me,L,be,Be)=>{n.ra("AveragePool",h,{format:Be?"NHWC":"NCHW",auto_pad:v,ceil_mode:T,count_include_pad:E,storage_order:M,dilations:[X,j],kernel_shape:[we,ie],pads:[he,de,Ee,Me],strides:[L,be]})},919007:(h,v)=>{n.ra("GlobalAveragePool",h,{format:v?"NHWC":"NCHW"})},919098:(h,v,T,E,M,X,j,we,ie,he,de,Ee,Me,L,be,Be)=>{n.ra("AveragePool",h,{format:Be?"NHWC":"NCHW",auto_pad:v,ceil_mode:T,count_include_pad:E,storage_order:M,dilations:[X,j],kernel_shape:[we,ie],pads:[he,de,Ee,Me],strides:[L,be]})},919382:(h,v)=>{n.ra("GlobalMaxPool",h,{format:v?"NHWC":"NCHW"})},919469:(h,v,T,E,M,X,j,we,ie,he,de,Ee,Me,L,be,Be)=>{n.ra("MaxPool",h,{format:Be?"NHWC":"NCHW",auto_pad:v,ceil_mode:T,count_include_pad:E,storage_order:M,dilations:[X,j],kernel_shape:[we,ie],pads:[he,de,Ee,Me],strides:[L,be]})},919749:(h,v)=>{n.ra("GlobalMaxPool",h,{format:v?"NHWC":"NCHW"})},919836:(h,v,T,E,M,X,j,we,ie,he,de,Ee,Me,L,be,Be)=>{n.ra("MaxPool",h,{format:Be?"NHWC":"NCHW",auto_pad:v,ceil_mode:T,count_include_pad:E,storage_order:M,dilations:[X,j],kernel_shape:[we,ie],pads:[he,de,Ee,Me],strides:[L,be]})},920116:(h,v,T,E,M)=>{n.ra("Gemm",h,{alpha:v,beta:T,transA:E,transB:M})},920220:h=>{n.ra("MatMul",h,void 0)},920274:(h,v,T,E)=>{n.ra("ArgMax",h,{keepDims:!!v,selectLastIndex:!!T,axis:E})},920382:(h,v,T,E)=>{n.ra("ArgMin",h,{keepDims:!!v,selectLastIndex:!!T,axis:E})},920490:(h,v)=>{n.ra("Softmax",h,{axis:v})},920553:(h,v)=>{n.ra("Concat",h,{axis:v})},920613:(h,v,T,E,M)=>{n.ra("Split",h,{axis:v,numOutputs:T,splitSizes:E?Array.from(P.subarray(M>>>0,M+E>>>0)):[]})},920758:h=>{n.ra("Expand",h,void 0)},920812:(h,v)=>{n.ra("Gather",h,{axis:Number(v)})},920883:(h,v)=>{n.ra("GatherElements",h,{axis:Number(v)})},920962:(h,v,T,E,M,X,j,we,ie,he,de)=>{n.ra("Resize",h,{antialias:v,axes:T?Array.from(P.subarray(E>>>0,E+T>>>0)):[],coordinateTransformMode:lt(M),cubicCoeffA:X,excludeOutside:j,extrapolationValue:we,keepAspectRatioPolicy:lt(ie),mode:lt(he),nearestMode:lt(de)})},921313:(h,v,T,E,M,X,j)=>{n.ra("Slice",h,{starts:v?Array.from(P.subarray(T>>>0,T+v>>>0)):[],ends:E?Array.from(P.subarray(M>>>0,M+E>>>0)):[],axes:X?Array.from(P.subarray(j>>>0,j+X>>>0)):[]})},921544:h=>{n.ra("Tile",h,void 0)},921596:(h,v,T)=>{n.ra("LayerNormalization",h,{axis:Number(v),epsilon:Number(T)})},921703:(h,v,T)=>{n.ra("InstanceNormalization",h,{epsilon:v,format:T?"NHWC":"NCHW"})},921817:(h,v,T)=>{n.ra("InstanceNormalization",h,{epsilon:v,format:T?"NHWC":"NCHW"})},921931:h=>{n.ra("Range",h,void 0)},921984:(h,v)=>{n.ra("Einsum",h,{equation:lt(v)})},922065:(h,v,T,E,M)=>{n.ra("Pad",h,{mode:v,value:T,pads:E?Array.from(P.subarray(M>>>0,M+E>>>0)):[]})},922197:(h,v,T,E,M,X)=>{n.ra("BatchNormalization",h,{epsilon:v,momentum:T,spatial:!!M,trainingMode:!!E,format:X?"NHWC":"NCHW"})},922366:(h,v,T,E,M,X)=>{n.ra("BatchNormalization",h,{epsilon:v,momentum:T,spatial:!!M,trainingMode:!!E,format:X?"NHWC":"NCHW"})},922535:(h,v,T)=>{n.ra("CumSum",h,{exclusive:Number(v),reverse:Number(T)})},922632:(h,v,T,E,M,X,j,we,ie)=>{n.ra("Attention",h,{numHeads:v,isUnidirectional:T,maskFilterValue:E,scale:M,doRotary:X,qkvHiddenSizes:j?Array.from(P.subarray(Number(we)>>>0,Number(we)+j>>>0)):[],pastPresentShareBuffer:!!ie})},922904:h=>{n.ra("Gelu",h,void 0)},922956:(h,v,T,E,M,X)=>{n.ra("MultiHeadAttention",h,{numHeads:v,isUnidirectional:T,maskFilterValue:E,scale:M,doRotary:X})},923115:h=>{n.ra("BiasAdd",h,void 0)},923170:h=>{n.ra("BiasSplitGelu",h,void 0)},923231:(h,v)=>{n.ra("SkipLayerNormalization",h,{epsilon:v})},923312:(h,v,T,E,M,X,j,we,ie,he,de,Ee,Me)=>{n.ra("Conv",h,{format:ie?"NHWC":"NCHW",auto_pad:v,dilations:[T],group:E,kernel_shape:[M],pads:X?Array.from(P.subarray(j>>>0,j+X>>>0)):[],strides:[we],w_is_const:()=>!!H[he>>>0],activation:lt(de),activation_params:Ee?Array.from(Te.subarray(Me>>>0,Me+Ee>>>0)):[]})},923693:(h,v,T,E,M,X,j,we,ie,he,de,Ee,Me,L,be,Be)=>{n.ra("Conv",h,{format:Ee?"NHWC":"NCHW",auto_pad:v,dilations:[T,E],group:M,kernel_shape:[X,j],pads:we?Array.from(P.subarray(ie>>>0,ie+we>>>0)):[],strides:[he,de],w_is_const:()=>!!H[Me>>>0],activation:lt(L),activation_params:be?Array.from(Te.subarray(Be>>>0,Be+be>>>0)):[]})},924095:h=>{n.Ra(h)},924129:(h,v)=>n.Sa(h,v,n.Da.Ta,n.Da.errors),924241:h=>n.Oa(h),924274:h=>n.Qa(h),924306:(h,v,T)=>{n.Ja(h,v,T,!0)},924345:(h,v,T)=>{n.Ja(h,v,T)}};function Nt(h){this.name="ExitStatus",this.message=`Program terminated with exit(${h})`,this.status=h}var Gr=h=>{for(;0<h.length;)h.shift()(n)};function Ur(h){this.Ha=h-24,this.Ma=function(v){J[this.Ha+4>>2>>>0]=v},this.La=function(v){J[this.Ha+8>>2>>>0]=v},this.Ya=function(v,T){this.Ka(),this.Ma(v),this.La(T)},this.Ka=function(){J[this.Ha+16>>2>>>0]=0}}var Ln=0,Io=0,Xt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,zn=(h,v,T)=>{v>>>=0;var E=v+T;for(T=v;h[T]&&!(T>=E);)++T;if(16<T-v&&h.buffer&&Xt)return Xt.decode(h.subarray(v,T));for(E="";v<T;){var M=h[v++];if(M&128){var X=h[v++]&63;if((M&224)==192)E+=String.fromCharCode((M&31)<<6|X);else{var j=h[v++]&63;M=(M&240)==224?(M&15)<<12|X<<6|j:(M&7)<<18|X<<12|j<<6|h[v++]&63,65536>M?E+=String.fromCharCode(M):(M-=65536,E+=String.fromCharCode(55296|M>>10,56320|M&1023))}}else E+=String.fromCharCode(M)}return E},lt=(h,v)=>(h>>>=0)?zn(ne,h,v):"",fn=h=>{for(var v=0,T=0;T<h.length;++T){var E=h.charCodeAt(T);127>=E?v++:2047>=E?v+=2:55296<=E&&57343>=E?(v+=4,++T):v+=3}return v},Nn=(h,v,T,E)=>{if(T>>>=0,!(0<E))return 0;var M=T;E=T+E-1;for(var X=0;X<h.length;++X){var j=h.charCodeAt(X);if(55296<=j&&57343>=j){var we=h.charCodeAt(++X);j=65536+((j&1023)<<10)|we&1023}if(127>=j){if(T>=E)break;v[T++>>>0]=j}else{if(2047>=j){if(T+1>=E)break;v[T++>>>0]=192|j>>6}else{if(65535>=j){if(T+2>=E)break;v[T++>>>0]=224|j>>12}else{if(T+3>=E)break;v[T++>>>0]=240|j>>18,v[T++>>>0]=128|j>>12&63}v[T++>>>0]=128|j>>6&63}v[T++>>>0]=128|j&63}}return v[T>>>0]=0,T-M},xr=h=>h%4===0&&(h%100!==0||h%400===0),Ao=[0,31,60,91,121,152,182,213,244,274,305,335],$r=[0,31,59,90,120,151,181,212,243,273,304,334],pn=h=>{var v=fn(h)+1,T=bn(v);return T&&Nn(h,ne,T,v),T},Er=[],hn=(h,v)=>{Er.length=0;var T;for(v>>=2;T=ne[h++>>>0];)v+=T!=105&v,Er.push(T==105?P[v>>>0]:ae[v++>>>1]),++v;return Er},mn={},Fn=()=>{if(!gn){var h={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:u||"./this.program"},v;for(v in mn)mn[v]===void 0?delete h[v]:h[v]=mn[v];var T=[];for(v in h)T.push(`${v}=${h[v]}`);gn=T}return gn},gn,Oo=[null,[],[]],_t=[31,29,31,30,31,30,31,31,30,31,30,31],Vn=[31,28,31,30,31,30,31,31,30,31,30,31];function Gn(h){var v=Array(fn(h)+1);return Nn(h,v,0,v.length),v}function ve(h,v,T,E){function M(L,be,Be){for(L=typeof L=="number"?L.toString():L||"";L.length<be;)L=Be[0]+L;return L}function X(L,be){return M(L,be,"0")}function j(L,be){function Be(Qn){return 0>Qn?-1:0<Qn?1:0}var _r;return(_r=Be(L.getFullYear()-be.getFullYear()))===0&&(_r=Be(L.getMonth()-be.getMonth()))===0&&(_r=Be(L.getDate()-be.getDate())),_r}function we(L){switch(L.getDay()){case 0:return new Date(L.getFullYear()-1,11,29);case 1:return L;case 2:return new Date(L.getFullYear(),0,3);case 3:return new Date(L.getFullYear(),0,2);case 4:return new Date(L.getFullYear(),0,1);case 5:return new Date(L.getFullYear()-1,11,31);case 6:return new Date(L.getFullYear()-1,11,30)}}function ie(L){var be=L.Ba;for(L=new Date(new Date(L.Ca+1900,0,1).getTime());0<be;){var Be=L.getMonth(),_r=(xr(L.getFullYear())?_t:Vn)[Be];if(be>_r-L.getDate())be-=_r-L.getDate()+1,L.setDate(1),11>Be?L.setMonth(Be+1):(L.setMonth(0),L.setFullYear(L.getFullYear()+1));else{L.setDate(L.getDate()+be);break}}return Be=new Date(L.getFullYear()+1,0,4),be=we(new Date(L.getFullYear(),0,4)),Be=we(Be),0>=j(be,L)?0>=j(Be,L)?L.getFullYear()+1:L.getFullYear():L.getFullYear()-1}h>>>=0,v>>>=0,T>>>=0,E>>>=0;var he=P[E+40>>2>>>0];E={Wa:P[E>>2>>>0],Va:P[E+4>>2>>>0],Ea:P[E+8>>2>>>0],Ia:P[E+12>>2>>>0],Fa:P[E+16>>2>>>0],Ca:P[E+20>>2>>>0],wa:P[E+24>>2>>>0],Ba:P[E+28>>2>>>0],$a:P[E+32>>2>>>0],Ua:P[E+36>>2>>>0],Xa:he?lt(he):""},T=lt(T),he={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var de in he)T=T.replace(new RegExp(de,"g"),he[de]);var Ee="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Me="January February March April May June July August September October November December".split(" ");he={"%a":L=>Ee[L.wa].substring(0,3),"%A":L=>Ee[L.wa],"%b":L=>Me[L.Fa].substring(0,3),"%B":L=>Me[L.Fa],"%C":L=>X((L.Ca+1900)/100|0,2),"%d":L=>X(L.Ia,2),"%e":L=>M(L.Ia,2," "),"%g":L=>ie(L).toString().substring(2),"%G":L=>ie(L),"%H":L=>X(L.Ea,2),"%I":L=>(L=L.Ea,L==0?L=12:12<L&&(L-=12),X(L,2)),"%j":L=>{for(var be=0,Be=0;Be<=L.Fa-1;be+=(xr(L.Ca+1900)?_t:Vn)[Be++]);return X(L.Ia+be,3)},"%m":L=>X(L.Fa+1,2),"%M":L=>X(L.Va,2),"%n":()=>`
`,"%p":L=>0<=L.Ea&&12>L.Ea?"AM":"PM","%S":L=>X(L.Wa,2),"%t":()=>"	","%u":L=>L.wa||7,"%U":L=>X(Math.floor((L.Ba+7-L.wa)/7),2),"%V":L=>{var be=Math.floor((L.Ba+7-(L.wa+6)%7)/7);if(2>=(L.wa+371-L.Ba-2)%7&&be++,be)be==53&&(Be=(L.wa+371-L.Ba)%7,Be==4||Be==3&&xr(L.Ca)||(be=1));else{be=52;var Be=(L.wa+7-L.Ba-1)%7;(Be==4||Be==5&&xr(L.Ca%400-1))&&be++}return X(be,2)},"%w":L=>L.wa,"%W":L=>X(Math.floor((L.Ba+7-(L.wa+6)%7)/7),2),"%y":L=>(L.Ca+1900).toString().substring(2),"%Y":L=>L.Ca+1900,"%z":L=>{L=L.Ua;var be=0<=L;return L=Math.abs(L)/60,(be?"+":"-")+("0000"+(L/60*100+L%60)).slice(-4)},"%Z":L=>L.Xa,"%%":()=>"%"},T=T.replace(/%%/g,"\0\0");for(de in he)T.includes(de)&&(T=T.replace(new RegExp(de,"g"),he[de](E)));return T=T.replace(/\0\0/g,"%"),de=Gn(T),de.length>v?0:(H.set(de,h>>>0),de.length-1)}function Tr(h){try{h()}catch(v){yt(v)}}function Eo(h){var v={},T;for(T in h)(function(E){var M=h[E];v[E]=typeof M=="function"?function(){Wr.push(E);try{return M.apply(null,arguments)}finally{U||(Wr.pop()===E||yt(),Ft&&ir===1&&Wr.length===0&&(ir=0,Tr(Zn),typeof Fibers<"u"&&Fibers.ab()))}}:M})(T);return v}var ir=0,Ft=null,Co=0,Wr=[],Un={},Wn={},Po=0,Hr=null,ko=[];function Do(){return new Promise((h,v)=>{Hr={resolve:h,reject:v}})}function Bo(){var h=bn(65548),v=h+12;J[h>>2>>>0]=v,J[h+4>>2>>>0]=v+65536,v=Wr[0];var T=Un[v];return T===void 0&&(T=Po++,Un[v]=T,Wn[T]=v),P[h+8>>2>>>0]=T,h}function Ro(h){if(!U){if(ir===0){var v=!1,T=!1;h((E=0)=>{if(!U&&(Co=E,v=!0,T)){ir=2,Tr(()=>yn(Ft)),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.resume(),E=!1;try{var M=(0,k[Wn[P[Ft+8>>2>>>0]]])()}catch(we){M=we,E=!0}var X=!1;if(!Ft){var j=Hr;j&&(Hr=null,(E?j.reject:j.resolve)(M),X=!0)}if(E&&!X)throw M}}),T=!0,v||(ir=1,Ft=Bo(),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.pause(),Tr(()=>Xn(Ft)))}else ir===2?(ir=0,Tr(qr),Hn(Ft),Ft=null,ko.forEach(E=>{if(!U)try{if(E(),!C)try{G=G=E=G,C||(n.onExit&&n.onExit(E),U=!0),a(E,new Nt(E))}catch(M){M instanceof Nt||M=="unwind"||a(1,M)}}catch(M){M instanceof Nt||M=="unwind"||a(1,M)}})):yt(`invalid state: ${ir}`);return Co}}function Mo(h){return Ro(v=>{h().then(v)})}var Lo={n:function(h,v,T){return Mo(async()=>{await n.Pa(h,v,T)})},a:function(h,v,T){throw h>>>=0,new Ur(h).Ya(v>>>0,T>>>0),Ln=h,Io++,Ln},g:function(){return 0},J:function(){},z:function(){},B:function(){},L:function(){return 0},H:function(){},C:function(){},G:function(){},l:function(){},A:function(){},x:function(){},I:function(){},y:function(){},m:()=>!0,q:function(h,v,T){h=v+2097152>>>0<4194305-!!h?(h>>>0)+4294967296*v:NaN,T>>>=0,h=new Date(1e3*h),P[T>>2>>>0]=h.getUTCSeconds(),P[T+4>>2>>>0]=h.getUTCMinutes(),P[T+8>>2>>>0]=h.getUTCHours(),P[T+12>>2>>>0]=h.getUTCDate(),P[T+16>>2>>>0]=h.getUTCMonth(),P[T+20>>2>>>0]=h.getUTCFullYear()-1900,P[T+24>>2>>>0]=h.getUTCDay(),P[T+28>>2>>>0]=(h.getTime()-Date.UTC(h.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(h,v,T){h=v+2097152>>>0<4194305-!!h?(h>>>0)+4294967296*v:NaN,T>>>=0,h=new Date(1e3*h),P[T>>2>>>0]=h.getSeconds(),P[T+4>>2>>>0]=h.getMinutes(),P[T+8>>2>>>0]=h.getHours(),P[T+12>>2>>>0]=h.getDate(),P[T+16>>2>>>0]=h.getMonth(),P[T+20>>2>>>0]=h.getFullYear()-1900,P[T+24>>2>>>0]=h.getDay(),P[T+28>>2>>>0]=(xr(h.getFullYear())?Ao:$r)[h.getMonth()]+h.getDate()-1|0,P[T+36>>2>>>0]=-(60*h.getTimezoneOffset()),v=new Date(h.getFullYear(),6,1).getTimezoneOffset();var E=new Date(h.getFullYear(),0,1).getTimezoneOffset();P[T+32>>2>>>0]=(v!=E&&h.getTimezoneOffset()==Math.min(E,v))|0},s:function(h){h>>>=0;var v=new Date(P[h+20>>2>>>0]+1900,P[h+16>>2>>>0],P[h+12>>2>>>0],P[h+8>>2>>>0],P[h+4>>2>>>0],P[h>>2>>>0],0),T=P[h+32>>2>>>0],E=v.getTimezoneOffset(),M=new Date(v.getFullYear(),6,1).getTimezoneOffset(),X=new Date(v.getFullYear(),0,1).getTimezoneOffset(),j=Math.min(X,M);return 0>T?P[h+32>>2>>>0]=+(M!=X&&j==E):0<T!=(j==E)&&(M=Math.max(X,M),v.setTime(v.getTime()+6e4*((0<T?j:M)-E))),P[h+24>>2>>>0]=v.getDay(),P[h+28>>2>>>0]=(xr(v.getFullYear())?Ao:$r)[v.getMonth()]+v.getDate()-1|0,P[h>>2>>>0]=v.getSeconds(),P[h+4>>2>>>0]=v.getMinutes(),P[h+8>>2>>>0]=v.getHours(),P[h+12>>2>>>0]=v.getDate(),P[h+16>>2>>>0]=v.getMonth(),P[h+20>>2>>>0]=v.getYear(),h=v.getTime()/1e3,qn((Ot=h,1<=+Math.abs(Ot)?0<Ot?+Math.floor(Ot/4294967296)>>>0:~~+Math.ceil((Ot-+(~~Ot>>>0))/4294967296)>>>0:0)),h>>>0},o:function(){return-52},p:function(){},v:function(h,v,T){function E(ie){return(ie=ie.toTimeString().match(/\(([A-Za-z ]+)\)$/))?ie[1]:"GMT"}T>>>=0;var M=new Date().getFullYear(),X=new Date(M,0,1),j=new Date(M,6,1);M=X.getTimezoneOffset();var we=j.getTimezoneOffset();J[h>>>0>>2>>>0]=60*Math.max(M,we),P[v>>>0>>2>>>0]=+(M!=we),h=E(X),v=E(j),h=pn(h),v=pn(v),we<M?(J[T>>2>>>0]=h,J[T+4>>2>>>0]=v):(J[T>>2>>>0]=v,J[T+4>>2>>>0]=h)},e:()=>{yt("")},b:function(h,v,T){return h>>>=0,v=hn(v>>>0,T>>>0),or[h].apply(null,v)},i:function(h,v,T){return h>>>=0,v=hn(v>>>0,T>>>0),or[h].apply(null,v)},h:function(){return Date.now()},w:function(){return 4294901760},c:()=>performance.now(),K:function(h,v,T){return v>>>=0,ne.copyWithin(h>>>0>>>0,v>>>0,v+(T>>>0)>>>0)},u:function(h){h>>>=0;var v=ne.length;if(4294901760<h)return!1;for(var T=1;4>=T;T*=2){var E=v*(1+.2/T);E=Math.min(E,h+100663296);var M=Math;E=Math.max(h,E);e:{M=M.min.call(M,4294901760,E+(65536-E%65536)%65536)-N.buffer.byteLength+65535>>>16;try{N.grow(M),De();var X=1;break e}catch{}X=void 0}if(X)return!0}return!1},D:function(h,v){h>>>=0,v>>>=0;var T=0;return Fn().forEach(function(E,M){var X=v+T;for(M=J[h+4*M>>2>>>0]=X,X=0;X<E.length;++X)H[M++>>0>>>0]=E.charCodeAt(X);H[M>>0>>>0]=0,T+=E.length+1}),0},E:function(h,v){h>>>=0,v>>>=0;var T=Fn();J[h>>2>>>0]=T.length;var E=0;return T.forEach(function(M){E+=M.length+1}),J[v>>2>>>0]=E,0},f:()=>52,k:function(){return 52},t:function(){return 70},j:function(h,v,T,E){v>>>=0,T>>>=0,E>>>=0;for(var M=0,X=0;X<T;X++){var j=J[v>>2>>>0],we=J[v+4>>2>>>0];v+=8;for(var ie=0;ie<we;ie++){var he=ne[j+ie>>>0],de=Oo[h];he===0||he===10?((h===1?x:S)(zn(de,0)),de.length=0):de.push(he)}M+=we}return J[E>>2>>>0]=M,0},F:ve,d:function(h,v,T,E){return ve(h>>>0,v>>>0,T>>>0,E>>>0)}};(function(){function h(T){if(T=T.exports,T=Eo(T),k=T=Cr(T),N=k.M,De(),Ce.unshift(k.N),$e--,n.monitorRunDependencies&&n.monitorRunDependencies($e),$e==0&&(ht!==null&&(clearInterval(ht),ht=null),it)){var E=it;it=null,E()}return T}var v={a:Lo};if($e++,n.monitorRunDependencies&&n.monitorRunDependencies($e),n.instantiateWasm)try{return n.instantiateWasm(v,h)}catch(T){S("Module.instantiateWasm callback failed with error: "+T),o(T)}return vt(v,function(T){h(T.instance)}).catch(o),{}})(),n._OrtInit=(h,v)=>(n._OrtInit=k.O)(h,v),n._OrtGetLastError=(h,v)=>(n._OrtGetLastError=k.P)(h,v),n._OrtCreateSessionOptions=(h,v,T,E,M,X,j,we,ie,he)=>(n._OrtCreateSessionOptions=k.Q)(h,v,T,E,M,X,j,we,ie,he),n._OrtAppendExecutionProvider=(h,v)=>(n._OrtAppendExecutionProvider=k.R)(h,v),n._OrtAddFreeDimensionOverride=(h,v,T)=>(n._OrtAddFreeDimensionOverride=k.S)(h,v,T),n._OrtAddSessionConfigEntry=(h,v,T)=>(n._OrtAddSessionConfigEntry=k.T)(h,v,T),n._OrtReleaseSessionOptions=h=>(n._OrtReleaseSessionOptions=k.U)(h),n._OrtCreateSession=(h,v,T)=>(n._OrtCreateSession=k.V)(h,v,T),n._OrtReleaseSession=h=>(n._OrtReleaseSession=k.W)(h),n._OrtGetInputOutputCount=(h,v,T)=>(n._OrtGetInputOutputCount=k.X)(h,v,T),n._OrtGetInputName=(h,v)=>(n._OrtGetInputName=k.Y)(h,v),n._OrtGetOutputName=(h,v)=>(n._OrtGetOutputName=k.Z)(h,v),n._OrtFree=h=>(n._OrtFree=k._)(h),n._OrtCreateTensor=(h,v,T,E,M,X)=>(n._OrtCreateTensor=k.$)(h,v,T,E,M,X),n._OrtGetTensorData=(h,v,T,E,M)=>(n._OrtGetTensorData=k.aa)(h,v,T,E,M),n._OrtReleaseTensor=h=>(n._OrtReleaseTensor=k.ba)(h),n._OrtCreateRunOptions=(h,v,T,E)=>(n._OrtCreateRunOptions=k.ca)(h,v,T,E),n._OrtAddRunConfigEntry=(h,v,T)=>(n._OrtAddRunConfigEntry=k.da)(h,v,T),n._OrtReleaseRunOptions=h=>(n._OrtReleaseRunOptions=k.ea)(h),n._OrtCreateBinding=h=>(n._OrtCreateBinding=k.fa)(h),n._OrtBindInput=(h,v,T)=>(n._OrtBindInput=k.ga)(h,v,T),n._OrtBindOutput=(h,v,T,E)=>(n._OrtBindOutput=k.ha)(h,v,T,E),n._OrtClearBoundOutputs=h=>(n._OrtClearBoundOutputs=k.ia)(h),n._OrtReleaseBinding=h=>(n._OrtReleaseBinding=k.ja)(h),n._OrtRunWithBinding=(h,v,T,E,M)=>(n._OrtRunWithBinding=k.ka)(h,v,T,E,M),n._OrtRun=(h,v,T,E,M,X,j,we)=>(n._OrtRun=k.la)(h,v,T,E,M,X,j,we),n._OrtEndProfiling=h=>(n._OrtEndProfiling=k.ma)(h),n._JsepOutput=(h,v,T)=>(n._JsepOutput=k.na)(h,v,T),n._JsepGetNodeName=h=>(n._JsepGetNodeName=k.oa)(h);var bn=n._malloc=h=>(bn=n._malloc=k.pa)(h),Hn=n._free=h=>(Hn=n._free=k.qa)(h),qn=h=>(qn=k.sa)(h),jn=()=>(jn=k.ta)(),Kn=h=>(Kn=k.ua)(h),Yn=h=>(Yn=k.va)(h),Xn=h=>(Xn=k.xa)(h),Zn=()=>(Zn=k.ya)(),yn=h=>(yn=k.za)(h),qr=()=>(qr=k.Aa)();n.___start_em_js=924378,n.___stop_em_js=924539;function Cr(h){h=Object.assign({},h);var v=E=>()=>E()>>>0,T=E=>M=>E(M)>>>0;return h.__errno_location=v(h.__errno_location),h.malloc=T(h.malloc),h.stackSave=v(h.stackSave),h.stackAlloc=T(h.stackAlloc),h}n.stackAlloc=Yn,n.stackSave=jn,n.stackRestore=Kn,n.UTF8ToString=lt,n.stringToUTF8=(h,v,T)=>Nn(h,ne,v,T),n.lengthBytesUTF8=fn;var jr;it=function h(){jr||Jn(),jr||(it=h)};function Jn(){function h(){if(!jr&&(jr=!0,n.calledRun=!0,!U)){if(Gr(Ce),t(n),n.onRuntimeInitialized&&n.onRuntimeInitialized(),n.postRun)for(typeof n.postRun=="function"&&(n.postRun=[n.postRun]);n.postRun.length;){var v=n.postRun.shift();Ne.unshift(v)}Gr(Ne)}}if(!(0<$e)){if(n.preRun)for(typeof n.preRun=="function"&&(n.preRun=[n.preRun]);n.preRun.length;)Se();Gr(re),0<$e||(n.setStatus?(n.setStatus("Running..."),setTimeout(function(){setTimeout(function(){n.setStatus("")},1),h()},1)):h())}}if(n.preInit)for(typeof n.preInit=="function"&&(n.preInit=[n.preInit]);0<n.preInit.length;)n.preInit.pop()();return Jn(),e.ready}})();typeof gh=="object"&&typeof Rs=="object"?Rs.exports=mh:typeof define=="function"&&define.amd&&define([],()=>mh)});var yh=Ye(()=>{});var vh=Ye(()=>{});var wh={};kr(wh,{cpus:()=>mx});var mx,xh=R(()=>{mx=void 0});var _h=Ye((Th,Ms)=>{"use strict";var $h=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(e={}){function n(){return De.buffer!=$e.buffer&&Ae(),$e}function t(){return De.buffer!=$e.buffer&&Ae(),ht}function o(){return De.buffer!=$e.buffer&&Ae(),it}function i(){return De.buffer!=$e.buffer&&Ae(),yt}function u(){return De.buffer!=$e.buffer&&Ae(),K}function a(){return De.buffer!=$e.buffer&&Ae(),fe}var s=e,l,d;s.ready=new Promise((c,m)=>{l=c,d=m}),s.jsepInit=(c,m,w,I,B,F,q,me)=>{s.Qb=c,s.wb=m,s.yb=w,s.jb=I,s.xb=B,s.Ea=F,s.zb=q,s.Ab=me,m=(ce,pe,ye)=>(...Le)=>{let Ue=ar,z=pe?.();Le=ce(...Le);let _e=pe?.();return z!==_e&&(ce=_e,ye(z),pe=ye=null),ar!=Ue?Oy():Le},w=ce=>async(...pe)=>{try{if(s.bb)throw Error("Session already started");let ye=s.bb={Fb:pe[0],errors:[]},Le=await ce(...pe);if(s.bb!==ye)throw Error("Session mismatch");c.flush();let Ue=ye.errors;if(0<Ue.length){let z=await Promise.all(Ue);if(z=z.filter(_e=>_e),0<z.length)throw Error(z.join(`
`))}return Le}finally{s.bb=null}},s._OrtRun=w(m(s._OrtRun,()=>s._OrtRun,ce=>s._OrtRun=ce)),s._OrtRunWithBinding=w(m(s._OrtRunWithBinding,()=>s._OrtRunWithBinding,ce=>s._OrtRunWithBinding=ce)),s._OrtBindInput=m(s._OrtBindInput,()=>s._OrtBindInput,ce=>s._OrtBindInput=ce),s.jsepRegisterBuffer=(ce,pe,ye,Le)=>c.registerBuffer(ce,pe,ye,Le),s.jsepUnregisterBuffers=ce=>{c.unregisterBuffers(ce)},s.jsepGetBuffer=ce=>c.getBuffer(ce),s.jsepCreateDownloader=(ce,pe,ye)=>c.createDownloader(ce,pe,ye)};var f=Object.assign({},s),p="./this.program",g=(c,m)=>{throw m},b=typeof window=="object",y=typeof importScripts=="function",_=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",x=s.ENVIRONMENT_IS_PTHREAD||!1,S="";function O(c){return s.locateFile?s.locateFile(c,S):S+c}var C,N,k;if(_){var U=(ks(),Sr(Ps)),G=(Bs(),Sr(Ds));S=y?G.dirname(S)+"/":__dirname+"/",C=(m,w)=>(m=m.startsWith("file://")?new URL(m):G.normalize(m),U.readFileSync(m,w?void 0:"utf8")),k=m=>(m=C(m,!0),m.buffer||(m=new Uint8Array(m)),m),N=(m,w,I,B=!0)=>{m=m.startsWith("file://")?new URL(m):G.normalize(m),U.readFile(m,B?void 0:"utf8",(F,q)=>{F?I(F):w(B?q.buffer:q)})},!s.thisProgram&&1<process.argv.length&&(p=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),g=(m,w)=>{throw process.exitCode=m,w},s.inspect=()=>"[Emscripten Module object]";let c;try{c=yh()}catch(m){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),m}global.Worker=c.Worker}else(b||y)&&(y?S=self.location.href:typeof document<"u"&&document.currentScript&&(S=document.currentScript.src),typeof r<"u"&&r&&(S=r),S.indexOf("blob:")!==0?S=S.substr(0,S.replace(/[?#].*/,"").lastIndexOf("/")+1):S="",_||(C=c=>{var m=new XMLHttpRequest;return m.open("GET",c,!1),m.send(null),m.responseText},y&&(k=c=>{var m=new XMLHttpRequest;return m.open("GET",c,!1),m.responseType="arraybuffer",m.send(null),new Uint8Array(m.response)}),N=(c,m,w)=>{var I=new XMLHttpRequest;I.open("GET",c,!0),I.responseType="arraybuffer",I.onload=()=>{I.status==200||I.status==0&&I.response?m(I.response):w()},I.onerror=w,I.send(null)}));_&&typeof performance>"u"&&(global.performance=vh().performance);var H=console.log.bind(console),ne=console.error.bind(console);_&&(H=(...c)=>U.writeSync(1,c.join(" ")+`
`),ne=(...c)=>U.writeSync(2,c.join(" ")+`
`));var P=s.print||H,J=s.printErr||ne;Object.assign(s,f),f=null,s.thisProgram&&(p=s.thisProgram),s.quit&&(g=s.quit);var Te;s.wasmBinary&&(Te=s.wasmBinary);var ae=s.noExitRuntime||!0;typeof WebAssembly!="object"&&Xt("no native wasm support detected");var De,re,Ce,Ne=!1,Se,$e,ht,it,yt,K,fe;function Ae(){var c=De.buffer;s.HEAP8=$e=new Int8Array(c),s.HEAP16=new Int16Array(c),s.HEAP32=it=new Int32Array(c),s.HEAPU8=ht=new Uint8Array(c),s.HEAPU16=new Uint16Array(c),s.HEAPU32=yt=new Uint32Array(c),s.HEAPF32=K=new Float32Array(c),s.HEAPF64=fe=new Float64Array(c)}var Tt=s.INITIAL_MEMORY||16777216;if(5242880<=Tt||Xt("INITIAL_MEMORY should be larger than STACK_SIZE, was "+Tt+"! (STACK_SIZE=5242880)"),x)De=s.wasmMemory;else if(s.wasmMemory)De=s.wasmMemory;else if(De=new WebAssembly.Memory({initial:Tt/65536,maximum:65536,shared:!0}),!(De.buffer instanceof SharedArrayBuffer))throw J("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&J("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");Ae(),Tt=De.buffer.byteLength;var Dt=[],at=[],vt=[],Ot=0;function or(){return ae||0<Ot}var Nt=0,Gr=null,Ur=null;function Ln(){Nt++,s.monitorRunDependencies&&s.monitorRunDependencies(Nt)}function Io(){if(Nt--,s.monitorRunDependencies&&s.monitorRunDependencies(Nt),Nt==0&&(Gr!==null&&(clearInterval(Gr),Gr=null),Ur)){var c=Ur;Ur=null,c()}}function Xt(c){throw s.onAbort&&s.onAbort(c),c="Aborted("+c+")",J(c),Ne=!0,Se=1,c=new WebAssembly.RuntimeError(c+". Build with -sASSERTIONS for more info."),d(c),c}function zn(c){return c.startsWith("data:application/octet-stream;base64,")}var lt;lt="ort-wasm-simd-threaded.wasm",zn(lt)||(lt=O(lt));function fn(c){if(c==lt&&Te)return new Uint8Array(Te);if(k)return k(c);throw"both async and sync fetching of the wasm failed"}function Nn(c){if(!Te&&(b||y)){if(typeof fetch=="function"&&!c.startsWith("file://"))return fetch(c,{credentials:"same-origin"}).then(m=>{if(!m.ok)throw"failed to load wasm binary file at '"+c+"'";return m.arrayBuffer()}).catch(()=>fn(c));if(N)return new Promise((m,w)=>{N(c,I=>m(new Uint8Array(I)),w)})}return Promise.resolve().then(()=>fn(c))}function xr(c,m,w){return Nn(c).then(I=>WebAssembly.instantiate(I,m)).then(I=>I).then(w,I=>{J("failed to asynchronously prepare wasm: "+I),Xt(I)})}function Ao(c,m){var w=lt;return Te||typeof WebAssembly.instantiateStreaming!="function"||zn(w)||w.startsWith("file://")||_||typeof fetch!="function"?xr(w,c,m):fetch(w,{credentials:"same-origin"}).then(I=>WebAssembly.instantiateStreaming(I,c).then(m,function(B){return J("wasm streaming compile failed: "+B),J("falling back to ArrayBuffer instantiation"),xr(w,c,m)}))}var $r,pn={1428192:c=>{s.Ea("Abs",c,void 0)},1428243:c=>{s.Ea("Neg",c,void 0)},1428294:c=>{s.Ea("Floor",c,void 0)},1428347:c=>{s.Ea("Ceil",c,void 0)},1428399:c=>{s.Ea("Reciprocal",c,void 0)},1428457:c=>{s.Ea("Sqrt",c,void 0)},1428509:c=>{s.Ea("Exp",c,void 0)},1428560:c=>{s.Ea("Erf",c,void 0)},1428611:c=>{s.Ea("Sigmoid",c,void 0)},1428666:c=>{s.Ea("Log",c,void 0)},1428717:c=>{s.Ea("Sin",c,void 0)},1428768:c=>{s.Ea("Cos",c,void 0)},1428819:c=>{s.Ea("Tan",c,void 0)},1428870:c=>{s.Ea("Asin",c,void 0)},1428922:c=>{s.Ea("Acos",c,void 0)},1428974:c=>{s.Ea("Atan",c,void 0)},1429026:c=>{s.Ea("Sinh",c,void 0)},1429078:c=>{s.Ea("Cosh",c,void 0)},1429130:c=>{s.Ea("Asinh",c,void 0)},1429183:c=>{s.Ea("Acosh",c,void 0)},1429236:c=>{s.Ea("Atanh",c,void 0)},1429289:c=>{s.Ea("Tanh",c,void 0)},1429341:c=>{s.Ea("Not",c,void 0)},1429392:(c,m,w)=>{s.Ea("Clip",c,{min:m,max:w})},1429461:c=>{s.Ea("Clip",c,void 0)},1429513:(c,m)=>{s.Ea("Elu",c,{alpha:m})},1429571:c=>{s.Ea("Relu",c,void 0)},1429623:(c,m)=>{s.Ea("LeakyRelu",c,{alpha:m})},1429687:(c,m)=>{s.Ea("ThresholdedRelu",c,{alpha:m})},1429757:c=>{s.zb(c)},1429791:(c,m)=>s.Ab(c,m,s.bb.Fb,s.bb.errors),1429903:(c,m)=>{s.Ea("Cast",c,{to:m})},1429961:c=>{s.Ea("Add",c,void 0)},1430012:c=>{s.Ea("Sub",c,void 0)},1430063:c=>{s.Ea("Mul",c,void 0)},1430114:c=>{s.Ea("Div",c,void 0)},1430165:c=>{s.Ea("Pow",c,void 0)},1430216:c=>{s.Ea("Equal",c,void 0)},1430269:c=>{s.Ea("Greater",c,void 0)},1430324:c=>{s.Ea("GreaterOrEqual",c,void 0)},1430386:c=>{s.Ea("Less",c,void 0)},1430438:c=>{s.Ea("LessOrEqual",c,void 0)},1430497:(c,m,w,I,B)=>{s.Ea("ReduceMean",c,{keepDims:!!m,noopWithEmptyAxes:!!w,axes:I?Array.from(o().subarray(B>>>0,B+I>>>0)):[]})},1430661:(c,m,w,I,B)=>{s.Ea("ReduceMax",c,{keepDims:!!m,noopWithEmptyAxes:!!w,axes:I?Array.from(o().subarray(B>>>0,B+I>>>0)):[]})},1430824:(c,m,w,I,B)=>{s.Ea("ReduceMin",c,{keepDims:!!m,noopWithEmptyAxes:!!w,axes:I?Array.from(o().subarray(B>>>0,B+I>>>0)):[]})},1430987:(c,m,w,I,B)=>{s.Ea("ReduceProd",c,{keepDims:!!m,noopWithEmptyAxes:!!w,axes:I?Array.from(o().subarray(B>>>0,B+I>>>0)):[]})},1431151:(c,m,w,I,B)=>{s.Ea("ReduceSum",c,{keepDims:!!m,noopWithEmptyAxes:!!w,axes:I?Array.from(o().subarray(B>>>0,B+I>>>0)):[]})},1431314:(c,m,w,I,B)=>{s.Ea("ReduceL1",c,{keepDims:!!m,noopWithEmptyAxes:!!w,axes:I?Array.from(o().subarray(B>>>0,B+I>>>0)):[]})},1431476:(c,m,w,I,B)=>{s.Ea("ReduceL2",c,{keepDims:!!m,noopWithEmptyAxes:!!w,axes:I?Array.from(o().subarray(B>>>0,B+I>>>0)):[]})},1431638:(c,m,w,I,B)=>{s.Ea("ReduceLogSum",c,{keepDims:!!m,noopWithEmptyAxes:!!w,axes:I?Array.from(o().subarray(B>>>0,B+I>>>0)):[]})},1431804:(c,m,w,I,B)=>{s.Ea("ReduceSumSquare",c,{keepDims:!!m,noopWithEmptyAxes:!!w,axes:I?Array.from(o().subarray(B>>>0,B+I>>>0)):[]})},1431973:(c,m,w,I,B)=>{s.Ea("ReduceLogSumExp",c,{keepDims:!!m,noopWithEmptyAxes:!!w,axes:I?Array.from(o().subarray(B>>>0,B+I>>>0)):[]})},1432142:c=>{s.Ea("Where",c,void 0)},1432195:(c,m,w)=>{s.Ea("Transpose",c,{perm:m?Array.from(o().subarray(w>>>0,w+m>>>0)):[]})},1432308:(c,m,w,I,B,F,q,me,ce,pe,ye,Le,Ue)=>{s.Ea("Conv",c,{format:ce?"NHWC":"NCHW",auto_pad:m,dilations:[w],group:I,kernel_shape:[B],pads:F?Array.from(o().subarray(q>>>0,q+F>>>0)):[],strides:[me],w_is_const:()=>!!n()[pe>>>0],activation:_t(ye),activation_params:Le?Array.from(u().subarray(Ue>>>0,Ue+Le>>>0)):[]})},1432689:(c,m,w,I,B,F,q,me,ce,pe,ye,Le,Ue,z,_e,Fe)=>{s.Ea("Conv",c,{format:Le?"NHWC":"NCHW",auto_pad:m,dilations:[w,I],group:B,kernel_shape:[F,q],pads:me?Array.from(o().subarray(ce>>>0,ce+me>>>0)):[],strides:[pe,ye],w_is_const:()=>!!n()[Ue>>>0],activation:_t(z),activation_params:_e?Array.from(u().subarray(Fe>>>0,Fe+_e>>>0)):[]})},1433091:(c,m,w,I,B,F,q,me,ce,pe,ye,Le,Ue,z,_e)=>{s.Ea("ConvTranspose",c,{format:ce?"NHWC":"NCHW",autoPad:m,dilations:[w],group:I,kernel_shape:[B],pads:[F,q],strides:[me],wIsConst:()=>!!n()[pe>>>0],outputPadding:ye?Array.from(o().subarray(Le>>>0,Le+ye>>>0)):[],outputShape:Ue?Array.from(o().subarray(z>>>0,z+Ue>>>0)):[],activation:_t(_e)})},1433505:(c,m,w,I,B,F,q,me,ce,pe,ye,Le,Ue,z)=>{s.Ea("ConvTranspose",c,{format:me?"NHWC":"NCHW",autoPad:m,dilations:Array.from(o().subarray(w>>>0,w+2>>>0)),group:I,kernelShape:Array.from(o().subarray(B>>>0,B+2>>>0)),pads:Array.from(o().subarray(F>>>0,F+4>>>0)),strides:Array.from(o().subarray(q>>>0,q+2>>>0)),wIsConst:()=>!!n()[ce>>>0],outputPadding:0<pe?Array.from(o().subarray(ye>>>0,ye+pe>>>0)):[],outputShape:0<Le?Array.from(o().subarray(Ue>>>0,Ue+Le>>>0)):[],activation:_t(z)})},1434062:(c,m,w,I,B,F,q,me,ce,pe,ye,Le,Ue,z,_e)=>{s.Ea("ConvTranspose",c,{format:ce?"NHWC":"NCHW",autoPad:m,dilations:[w],group:I,kernel_shape:[B],pads:[F,q],strides:[me],wIsConst:()=>!!n()[pe>>>0],outputPadding:ye?Array.from(o().subarray(Le>>>0,Le+ye>>>0)):[],outputShape:Ue?Array.from(o().subarray(z>>>0,z+Ue>>>0)):[],activation:_t(_e)})},1434476:(c,m,w,I,B,F,q,me,ce,pe,ye,Le,Ue,z)=>{s.Ea("ConvTranspose",c,{format:me?"NHWC":"NCHW",autoPad:m,dilations:Array.from(o().subarray(w>>>0,w+2>>>0)),group:I,kernelShape:Array.from(o().subarray(B>>>0,B+2>>>0)),pads:Array.from(o().subarray(F>>>0,F+4>>>0)),strides:Array.from(o().subarray(q>>>0,q+2>>>0)),wIsConst:()=>!!n()[ce>>>0],outputPadding:0<pe?Array.from(o().subarray(ye>>>0,ye+pe>>>0)):[],outputShape:0<Le?Array.from(o().subarray(Ue>>>0,Ue+Le>>>0)):[],activation:_t(z)})},1435033:(c,m)=>{s.Ea("GlobalAveragePool",c,{format:m?"NHWC":"NCHW"})},1435124:(c,m,w,I,B,F,q,me,ce,pe,ye,Le,Ue,z,_e,Fe)=>{s.Ea("AveragePool",c,{format:Fe?"NHWC":"NCHW",auto_pad:m,ceil_mode:w,count_include_pad:I,storage_order:B,dilations:[F,q],kernel_shape:[me,ce],pads:[pe,ye,Le,Ue],strides:[z,_e]})},1435408:(c,m)=>{s.Ea("GlobalAveragePool",c,{format:m?"NHWC":"NCHW"})},1435499:(c,m,w,I,B,F,q,me,ce,pe,ye,Le,Ue,z,_e,Fe)=>{s.Ea("AveragePool",c,{format:Fe?"NHWC":"NCHW",auto_pad:m,ceil_mode:w,count_include_pad:I,storage_order:B,dilations:[F,q],kernel_shape:[me,ce],pads:[pe,ye,Le,Ue],strides:[z,_e]})},1435783:(c,m)=>{s.Ea("GlobalMaxPool",c,{format:m?"NHWC":"NCHW"})},1435870:(c,m,w,I,B,F,q,me,ce,pe,ye,Le,Ue,z,_e,Fe)=>{s.Ea("MaxPool",c,{format:Fe?"NHWC":"NCHW",auto_pad:m,ceil_mode:w,count_include_pad:I,storage_order:B,dilations:[F,q],kernel_shape:[me,ce],pads:[pe,ye,Le,Ue],strides:[z,_e]})},1436150:(c,m)=>{s.Ea("GlobalMaxPool",c,{format:m?"NHWC":"NCHW"})},1436237:(c,m,w,I,B,F,q,me,ce,pe,ye,Le,Ue,z,_e,Fe)=>{s.Ea("MaxPool",c,{format:Fe?"NHWC":"NCHW",auto_pad:m,ceil_mode:w,count_include_pad:I,storage_order:B,dilations:[F,q],kernel_shape:[me,ce],pads:[pe,ye,Le,Ue],strides:[z,_e]})},1436517:(c,m,w,I,B)=>{s.Ea("Gemm",c,{alpha:m,beta:w,transA:I,transB:B})},1436621:c=>{s.Ea("MatMul",c,void 0)},1436675:(c,m,w,I)=>{s.Ea("ArgMax",c,{keepDims:!!m,selectLastIndex:!!w,axis:I})},1436783:(c,m,w,I)=>{s.Ea("ArgMin",c,{keepDims:!!m,selectLastIndex:!!w,axis:I})},1436891:(c,m)=>{s.Ea("Softmax",c,{axis:m})},1436954:(c,m)=>{s.Ea("Concat",c,{axis:m})},1437014:(c,m,w,I,B)=>{s.Ea("Split",c,{axis:m,numOutputs:w,splitSizes:I?Array.from(o().subarray(B>>>0,B+I>>>0)):[]})},1437159:c=>{s.Ea("Expand",c,void 0)},1437213:(c,m)=>{s.Ea("Gather",c,{axis:Number(m)})},1437284:(c,m)=>{s.Ea("GatherElements",c,{axis:Number(m)})},1437363:(c,m,w,I,B,F,q,me,ce,pe,ye)=>{s.Ea("Resize",c,{antialias:m,axes:w?Array.from(o().subarray(I>>>0,I+w>>>0)):[],coordinateTransformMode:_t(B),cubicCoeffA:F,excludeOutside:q,extrapolationValue:me,keepAspectRatioPolicy:_t(ce),mode:_t(pe),nearestMode:_t(ye)})},1437714:(c,m,w,I,B,F,q)=>{s.Ea("Slice",c,{starts:m?Array.from(o().subarray(w>>>0,w+m>>>0)):[],ends:I?Array.from(o().subarray(B>>>0,B+I>>>0)):[],axes:F?Array.from(o().subarray(q>>>0,q+F>>>0)):[]})},1437945:c=>{s.Ea("Tile",c,void 0)},1437997:(c,m,w)=>{s.Ea("LayerNormalization",c,{axis:Number(m),epsilon:Number(w)})},1438104:(c,m,w)=>{s.Ea("InstanceNormalization",c,{epsilon:m,format:w?"NHWC":"NCHW"})},1438218:(c,m,w)=>{s.Ea("InstanceNormalization",c,{epsilon:m,format:w?"NHWC":"NCHW"})},1438332:c=>{s.Ea("Range",c,void 0)},1438385:(c,m)=>{s.Ea("Einsum",c,{equation:_t(m)})},1438466:(c,m,w,I,B)=>{s.Ea("Pad",c,{mode:m,value:w,pads:I?Array.from(o().subarray(B>>>0,B+I>>>0)):[]})},1438598:(c,m,w,I,B,F)=>{s.Ea("BatchNormalization",c,{epsilon:m,momentum:w,spatial:!!B,trainingMode:!!I,format:F?"NHWC":"NCHW"})},1438767:(c,m,w,I,B,F)=>{s.Ea("BatchNormalization",c,{epsilon:m,momentum:w,spatial:!!B,trainingMode:!!I,format:F?"NHWC":"NCHW"})},1438936:(c,m,w)=>{s.Ea("CumSum",c,{exclusive:Number(m),reverse:Number(w)})},1439033:(c,m,w,I,B,F,q,me,ce)=>{s.Ea("Attention",c,{numHeads:m,isUnidirectional:w,maskFilterValue:I,scale:B,doRotary:F,qkvHiddenSizes:q?Array.from(o().subarray(Number(me)>>>0,Number(me)+q>>>0)):[],pastPresentShareBuffer:!!ce})},1439305:c=>{s.Ea("Gelu",c,void 0)},1439357:(c,m,w,I,B,F)=>{s.Ea("MultiHeadAttention",c,{numHeads:m,isUnidirectional:w,maskFilterValue:I,scale:B,doRotary:F})},1439516:c=>{s.Ea("BiasAdd",c,void 0)},1439571:c=>{s.Ea("BiasSplitGelu",c,void 0)},1439632:(c,m)=>{s.Ea("SkipLayerNormalization",c,{epsilon:m})},1439713:c=>s.wb(c),1439746:c=>s.yb(c),1439778:(c,m,w)=>{s.jb(c,m,w,!0)},1439817:(c,m,w)=>{s.jb(c,m,w)}};function Er(c){this.name="ExitStatus",this.message=`Program terminated with exit(${c})`,this.status=c}function hn(c){c.terminate(),c.onmessage=()=>{}}function mn(c){(c=ve.Qa[c])||Xt(),ve.Eb(c)}function Fn(c){var m=ve.tb();if(!m)return 6;ve.Ya.push(m),ve.Qa[c.Xa]=m,m.Xa=c.Xa;var w={cmd:"run",start_routine:c.Gb,arg:c.rb,pthread_ptr:c.Xa};return _&&m.unref(),m.postMessage(w,c.Mb),0}var gn=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Oo=(c,m,w)=>{m>>>=0;var I=m+w;for(w=m;c[w]&&!(w>=I);)++w;if(16<w-m&&c.buffer&&gn)return gn.decode(c.buffer instanceof SharedArrayBuffer?c.slice(m,w):c.subarray(m,w));for(I="";m<w;){var B=c[m++];if(B&128){var F=c[m++]&63;if((B&224)==192)I+=String.fromCharCode((B&31)<<6|F);else{var q=c[m++]&63;B=(B&240)==224?(B&15)<<12|F<<6|q:(B&7)<<18|F<<12|q<<6|c[m++]&63,65536>B?I+=String.fromCharCode(B):(B-=65536,I+=String.fromCharCode(55296|B>>10,56320|B&1023))}}else I+=String.fromCharCode(B)}return I},_t=(c,m)=>(c>>>=0)?Oo(t(),c,m):"";function Vn(c){if(x)return j(1,1,c);Se=c,or()||(ve.Hb(),s.onExit&&s.onExit(c),Ne=!0),g(c,new Er(c))}var Gn=c=>{if(Se=c,x)throw Eo(c),"unwind";Vn(c)},ve={ab:[],Ya:[],mb:[],Qa:{},gb:function(){x?ve.vb():ve.ub()},ub:function(){Dt.unshift(()=>{Ln(),ve.Bb(()=>Io())})},vb:function(){ve.receiveObjectTransfer=ve.Db,ve.threadInitTLS=ve.lb,ve.setExitStatus=ve.kb,ae=!1},kb:function(c){Se=c},Sb:["$terminateWorker"],Hb:function(){for(var c of ve.Ya)hn(c);for(c of ve.ab)hn(c);ve.ab=[],ve.Ya=[],ve.Qa=[]},Eb:function(c){var m=c.Xa;delete ve.Qa[m],ve.ab.push(c),ve.Ya.splice(ve.Ya.indexOf(c),1),c.Xa=0,va(m)},Db:function(){},lb:function(){ve.mb.forEach(c=>c())},Cb:c=>new Promise(m=>{c.onmessage=F=>{F=F.data;var q=F.cmd;if(F.targetThread&&F.targetThread!=Fo()){var me=ve.Qa[F.Rb];me?me.postMessage(F,F.transferList):J('Internal error! Worker sent a message "'+q+'" to target pthread '+F.targetThread+", but that thread no longer exists!")}else q==="checkMailbox"?qr():q==="spawnThread"?Fn(F):q==="cleanupThread"?mn(F.thread):q==="killThread"?(F=F.thread,q=ve.Qa[F],delete ve.Qa[F],hn(q),va(F),ve.Ya.splice(ve.Ya.indexOf(q),1),q.Xa=0):q==="cancelThread"?ve.Qa[F.thread].postMessage({cmd:"cancel"}):q==="loaded"?(c.loaded=!0,m(c)):q==="alert"?alert("Thread "+F.threadId+": "+F.text):F.target==="setimmediate"?c.postMessage(F):q==="callHandler"?s[F.handler](...F.args):q&&J("worker sent an unknown command "+q)},c.onerror=F=>{throw J("worker sent an error! "+F.filename+":"+F.lineno+": "+F.message),F},_&&(c.on("message",function(F){c.onmessage({data:F})}),c.on("error",function(F){c.onerror(F)}));var w=[],I=["onExit","onAbort","print","printErr"],B;for(B of I)s.hasOwnProperty(B)&&w.push(B);c.postMessage({cmd:"load",handlers:w,urlOrBlob:s.mainScriptUrlOrBlob||r,wasmMemory:De,wasmModule:Ce})}),Bb:function(c){c()},qb:function(){var c=O("ort-wasm-simd-threaded.worker.js");c=new Worker(c),ve.ab.push(c)},tb:function(){return ve.ab.length==0&&(ve.qb(),ve.Cb(ve.ab[0])),ve.ab.pop()}};s.PThread=ve;var Tr=c=>{for(;0<c.length;)c.shift()(s)};s.establishStackSpace=function(){var c=Fo(),m=o()[c+52>>2>>>0];c=o()[c+56>>2>>>0],Au(m,m-c),Vo(m)};function Eo(c){if(x)return j(2,0,c);Gn(c)}s.invokeEntryPoint=function(c,m){c=Ou.apply(null,[c,m]),or()?ve.kb(c):wa(c)};function ir(c){this.fb=c-24,this.pb=function(m){i()[this.fb+4>>2>>>0]=m},this.ob=function(m){i()[this.fb+8>>2>>>0]=m},this.gb=function(m,w){this.nb(),this.pb(m),this.ob(w)},this.nb=function(){i()[this.fb+16>>2>>>0]=0}}var Ft=0,Co=0;function Wr(c,m,w,I){return x?j(3,1,c,m,w,I):Un(c,m,w,I)}function Un(c,m,w,I){if(c>>>=0,m>>>=0,w>>>=0,I>>>=0,typeof SharedArrayBuffer>"u")return J("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var B=[];return x&&B.length===0?Wr(c,m,w,I):(c={Gb:w,Xa:c,rb:I,Mb:B},x?(c.Ob="spawnThread",postMessage(c,B),0):Fn(c))}function Wn(c,m,w){return x?j(4,1,c,m,w):0}function Po(c,m){if(x)return j(5,1,c,m)}var Hr=c=>{for(var m=0,w=0;w<c.length;++w){var I=c.charCodeAt(w);127>=I?m++:2047>=I?m+=2:55296<=I&&57343>=I?(m+=4,++w):m+=3}return m},ko=(c,m,w,I)=>{if(w>>>=0,!(0<I))return 0;var B=w;I=w+I-1;for(var F=0;F<c.length;++F){var q=c.charCodeAt(F);if(55296<=q&&57343>=q){var me=c.charCodeAt(++F);q=65536+((q&1023)<<10)|me&1023}if(127>=q){if(w>=I)break;m[w++>>>0]=q}else{if(2047>=q){if(w+1>=I)break;m[w++>>>0]=192|q>>6}else{if(65535>=q){if(w+2>=I)break;m[w++>>>0]=224|q>>12}else{if(w+3>=I)break;m[w++>>>0]=240|q>>18,m[w++>>>0]=128|q>>12&63}m[w++>>>0]=128|q>>6&63}m[w++>>>0]=128|q&63}}return m[w>>>0]=0,w-B},Do=(c,m,w)=>ko(c,t(),m,w);function Bo(c,m){if(x)return j(6,1,c,m)}function Ro(c,m,w){if(x)return j(7,1,c,m,w)}function Mo(c,m,w){return x?j(8,1,c,m,w):0}function Lo(c,m){if(x)return j(9,1,c,m)}function bn(c,m,w){if(x)return j(10,1,c,m,w)}function Hn(c,m,w,I){if(x)return j(11,1,c,m,w,I)}function qn(c,m,w,I){if(x)return j(12,1,c,m,w,I)}function jn(c,m,w,I){if(x)return j(13,1,c,m,w,I)}function Kn(c){if(x)return j(14,1,c)}function Yn(c,m){if(x)return j(15,1,c,m)}function Xn(c,m,w){if(x)return j(16,1,c,m,w)}var Zn=c=>{if(!Ne)try{if(c(),!or())try{x?wa(Se):Gn(Se)}catch(m){m instanceof Er||m=="unwind"||g(1,m)}}catch(m){m instanceof Er||m=="unwind"||g(1,m)}};function yn(c){c>>>=0,typeof Atomics.Nb=="function"&&(Atomics.Nb(o(),c>>2,c).value.then(qr),c+=128,Atomics.store(o(),c>>2,1))}s.__emscripten_thread_mailbox_await=yn;function qr(){var c=Fo();c&&(yn(c),Zn(()=>Su()))}s.checkMailbox=qr;var Cr=c=>c%4===0&&(c%100!==0||c%400===0),jr=[0,31,60,91,121,152,182,213,244,274,305,335],Jn=[0,31,59,90,120,151,181,212,243,273,304,334];function h(c,m,w,I,B,F,q,me){return x?j(17,1,c,m,w,I,B,F,q,me):-52}function v(c,m,w,I,B,F,q){if(x)return j(18,1,c,m,w,I,B,F,q)}var T=c=>{var m=Hr(c)+1,w=ya(m);return w&&Do(c,w,m),w},E=[],M=(c,m)=>{E.length=0;var w;for(m>>=2;w=t()[c++>>>0];)m+=w!=105&m,E.push(w==105?o()[m>>>0]:a()[m++>>>1]),++m;return E},X=c=>{var m=xa();return c=c(),Vo(m),c};function j(c,m){var w=arguments.length-2,I=arguments;return X(()=>{for(var B=$a(8*w),F=B>>3,q=0;q<w;q++){var me=I[2+q];a()[F+q>>>0]=me}return _u(c,w,B,m)})}var we=[],ie={},he=()=>{if(!de){var c={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"},m;for(m in ie)ie[m]===void 0?delete c[m]:c[m]=ie[m];var w=[];for(m in c)w.push(`${m}=${c[m]}`);de=w}return de},de;function Ee(c,m){if(x)return j(19,1,c,m);c>>>=0,m>>>=0;var w=0;return he().forEach(function(I,B){var F=m+w;for(B=i()[c+4*B>>2>>>0]=F,F=0;F<I.length;++F)n()[B++>>0>>>0]=I.charCodeAt(F);n()[B>>0>>>0]=0,w+=I.length+1}),0}function Me(c,m){if(x)return j(20,1,c,m);c>>>=0,m>>>=0;var w=he();i()[c>>2>>>0]=w.length;var I=0;return w.forEach(function(B){I+=B.length+1}),i()[m>>2>>>0]=I,0}function L(c){return x?j(21,1,c):52}function be(c,m,w,I){return x?j(22,1,c,m,w,I):52}function Be(c,m,w,I,B){return x?j(23,1,c,m,w,I,B):70}var _r=[null,[],[]];function Qn(c,m,w,I){if(x)return j(24,1,c,m,w,I);m>>>=0,w>>>=0,I>>>=0;for(var B=0,F=0;F<w;F++){var q=i()[m>>2>>>0],me=i()[m+4>>2>>>0];m+=8;for(var ce=0;ce<me;ce++){var pe=t()[q+ce>>>0],ye=_r[c];pe===0||pe===10?((c===1?P:J)(Oo(ye,0)),ye.length=0):ye.push(pe)}B+=me}return i()[I>>2>>>0]=B,0}var gu=[31,29,31,30,31,30,31,31,30,31,30,31],bu=[31,28,31,30,31,30,31,31,30,31,30,31];function Ty(c){var m=Array(Hr(c)+1);return ko(c,m,0,m.length),m}var _y=(c,m)=>{n().set(c,m>>>0)};function yu(c,m,w,I){function B(z,_e,Fe){for(z=typeof z=="number"?z.toString():z||"";z.length<_e;)z=Fe[0]+z;return z}function F(z,_e){return B(z,_e,"0")}function q(z,_e){function Fe(Bu){return 0>Bu?-1:0<Bu?1:0}var Kr;return(Kr=Fe(z.getFullYear()-_e.getFullYear()))===0&&(Kr=Fe(z.getMonth()-_e.getMonth()))===0&&(Kr=Fe(z.getDate()-_e.getDate())),Kr}function me(z){switch(z.getDay()){case 0:return new Date(z.getFullYear()-1,11,29);case 1:return z;case 2:return new Date(z.getFullYear(),0,3);case 3:return new Date(z.getFullYear(),0,2);case 4:return new Date(z.getFullYear(),0,1);case 5:return new Date(z.getFullYear()-1,11,31);case 6:return new Date(z.getFullYear()-1,11,30)}}function ce(z){var _e=z.Za;for(z=new Date(new Date(z.$a+1900,0,1).getTime());0<_e;){var Fe=z.getMonth(),Kr=(Cr(z.getFullYear())?gu:bu)[Fe];if(_e>Kr-z.getDate())_e-=Kr-z.getDate()+1,z.setDate(1),11>Fe?z.setMonth(Fe+1):(z.setMonth(0),z.setFullYear(z.getFullYear()+1));else{z.setDate(z.getDate()+_e);break}}return Fe=new Date(z.getFullYear()+1,0,4),_e=me(new Date(z.getFullYear(),0,4)),Fe=me(Fe),0>=q(_e,z)?0>=q(Fe,z)?z.getFullYear()+1:z.getFullYear():z.getFullYear()-1}c>>>=0,m>>>=0,w>>>=0,I>>>=0;var pe=o()[I+40>>2>>>0];I={Kb:o()[I>>2>>>0],Jb:o()[I+4>>2>>>0],cb:o()[I+8>>2>>>0],ib:o()[I+12>>2>>>0],eb:o()[I+16>>2>>>0],$a:o()[I+20>>2>>>0],Wa:o()[I+24>>2>>>0],Za:o()[I+28>>2>>>0],Tb:o()[I+32>>2>>>0],Ib:o()[I+36>>2>>>0],Lb:pe?_t(pe):""},w=_t(w),pe={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ye in pe)w=w.replace(new RegExp(ye,"g"),pe[ye]);var Le="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Ue="January February March April May June July August September October November December".split(" ");pe={"%a":z=>Le[z.Wa].substring(0,3),"%A":z=>Le[z.Wa],"%b":z=>Ue[z.eb].substring(0,3),"%B":z=>Ue[z.eb],"%C":z=>F((z.$a+1900)/100|0,2),"%d":z=>F(z.ib,2),"%e":z=>B(z.ib,2," "),"%g":z=>ce(z).toString().substring(2),"%G":z=>ce(z),"%H":z=>F(z.cb,2),"%I":z=>(z=z.cb,z==0?z=12:12<z&&(z-=12),F(z,2)),"%j":z=>{for(var _e=0,Fe=0;Fe<=z.eb-1;_e+=(Cr(z.$a+1900)?gu:bu)[Fe++]);return F(z.ib+_e,3)},"%m":z=>F(z.eb+1,2),"%M":z=>F(z.Jb,2),"%n":()=>`
`,"%p":z=>0<=z.cb&&12>z.cb?"AM":"PM","%S":z=>F(z.Kb,2),"%t":()=>"	","%u":z=>z.Wa||7,"%U":z=>F(Math.floor((z.Za+7-z.Wa)/7),2),"%V":z=>{var _e=Math.floor((z.Za+7-(z.Wa+6)%7)/7);if(2>=(z.Wa+371-z.Za-2)%7&&_e++,_e)_e==53&&(Fe=(z.Wa+371-z.Za)%7,Fe==4||Fe==3&&Cr(z.$a)||(_e=1));else{_e=52;var Fe=(z.Wa+7-z.Za-1)%7;(Fe==4||Fe==5&&Cr(z.$a%400-1))&&_e++}return F(_e,2)},"%w":z=>z.Wa,"%W":z=>F(Math.floor((z.Za+7-(z.Wa+6)%7)/7),2),"%y":z=>(z.$a+1900).toString().substring(2),"%Y":z=>z.$a+1900,"%z":z=>{z=z.Ib;var _e=0<=z;return z=Math.abs(z)/60,(_e?"+":"-")+("0000"+(z/60*100+z%60)).slice(-4)},"%Z":z=>z.Lb,"%%":()=>"%"},w=w.replace(/%%/g,"\0\0");for(ye in pe)w.includes(ye)&&(w=w.replace(new RegExp(ye,"g"),pe[ye](I)));return w=w.replace(/\0\0/g,"%"),ye=Ty(w),ye.length>m?0:(_y(ye,c),ye.length-1)}function zo(c){try{c()}catch(m){Xt(m)}}function Sy(c){var m={},w;for(w in c)(function(I){var B=c[I];m[I]=typeof B=="function"?function(){No.push(I);try{return B.apply(null,arguments)}finally{Ne||(No.pop()===I||Xt(),ar&&Pr===1&&No.length===0&&(Pr=0,Ot+=1,zo(Cu),typeof Fibers<"u"&&Fibers.Ub()))}}:B})(w);return m}var Pr=0,ar=null,vu=0,No=[],wu={},xu={},Iy=0,ba=null,Ay=[];function Oy(){return new Promise((c,m)=>{ba={resolve:c,reject:m}})}function Ey(){var c=ya(65548),m=c+12;i()[c>>2>>>0]=m,i()[c+4>>2>>>0]=m+65536,m=No[0];var w=wu[m];return w===void 0&&(w=Iy++,wu[m]=w,xu[w]=m),m=w,o()[c+8>>2>>>0]=m,c}function Cy(){var c=o()[ar+8>>2>>>0];return c=re[xu[c]],--Ot,c()}function Py(c){if(!Ne){if(Pr===0){var m=!1,w=!1;c((I=0)=>{if(!Ne&&(vu=I,m=!0,w)){Pr=2,zo(()=>Pu(ar)),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.resume(),I=!1;try{var B=Cy()}catch(me){B=me,I=!0}var F=!1;if(!ar){var q=ba;q&&(ba=null,(I?q.reject:q.resolve)(B),F=!0)}if(I&&!F)throw B}}),w=!0,m||(Pr=1,ar=Ey(),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.pause(),zo(()=>Eu(ar)))}else Pr===2?(Pr=0,zo(ku),$u(ar),ar=null,Ay.forEach(I=>Zn(I))):Xt(`invalid state: ${Pr}`);return vu}}function ky(c){return Py(m=>{c().then(m)})}ve.gb();var Dy=[null,Vn,Eo,Wr,Wn,Po,Bo,Ro,Mo,Lo,bn,Hn,qn,jn,Kn,Yn,Xn,h,v,Ee,Me,L,be,Be,Qn],By={r:function(c,m,w){return ky(async()=>{await s.xb(c,m,w)})},b:function(c,m,w){throw c>>>=0,new ir(c).gb(m>>>0,w>>>0),Ft=c,Co++,Ft},P:function(c){Tu(c>>>0,!y,1,!b,131072,!1),ve.lb()},n:function(c){c>>>=0,x?postMessage({cmd:"cleanupThread",thread:c}):mn(c)},K:Un,g:Wn,V:Po,F:Bo,H:Ro,y:Mo,T:Lo,L:bn,S:Hn,p:qn,G:jn,D:Kn,U:Yn,E:Xn,q:()=>!0,B:function(c,m){c>>>=0,c==m>>>0?setTimeout(()=>qr()):x?postMessage({targetThread:c,cmd:"checkMailbox"}):(c=ve.Qa[c])&&c.postMessage({cmd:"checkMailbox"})},N:function(){return-1},O:yn,X:function(c){_&&ve.Qa[c>>>0].ref()},u:function(c,m,w){c=m+2097152>>>0<4194305-!!c?(c>>>0)+4294967296*m:NaN,w>>>=0,c=new Date(1e3*c),o()[w>>2>>>0]=c.getUTCSeconds(),o()[w+4>>2>>>0]=c.getUTCMinutes(),o()[w+8>>2>>>0]=c.getUTCHours(),o()[w+12>>2>>>0]=c.getUTCDate(),o()[w+16>>2>>>0]=c.getUTCMonth(),o()[w+20>>2>>>0]=c.getUTCFullYear()-1900,o()[w+24>>2>>>0]=c.getUTCDay(),c=(c.getTime()-Date.UTC(c.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,o()[w+28>>2>>>0]=c},v:function(c,m,w){c=m+2097152>>>0<4194305-!!c?(c>>>0)+4294967296*m:NaN,w>>>=0,c=new Date(1e3*c),o()[w>>2>>>0]=c.getSeconds(),o()[w+4>>2>>>0]=c.getMinutes(),o()[w+8>>2>>>0]=c.getHours(),o()[w+12>>2>>>0]=c.getDate(),o()[w+16>>2>>>0]=c.getMonth(),o()[w+20>>2>>>0]=c.getFullYear()-1900,o()[w+24>>2>>>0]=c.getDay(),m=(Cr(c.getFullYear())?jr:Jn)[c.getMonth()]+c.getDate()-1|0,o()[w+28>>2>>>0]=m,o()[w+36>>2>>>0]=-(60*c.getTimezoneOffset()),m=new Date(c.getFullYear(),6,1).getTimezoneOffset();var I=new Date(c.getFullYear(),0,1).getTimezoneOffset();c=(m!=I&&c.getTimezoneOffset()==Math.min(I,m))|0,o()[w+32>>2>>>0]=c},w:function(c){c>>>=0;var m=new Date(o()[c+20>>2>>>0]+1900,o()[c+16>>2>>>0],o()[c+12>>2>>>0],o()[c+8>>2>>>0],o()[c+4>>2>>>0],o()[c>>2>>>0],0),w=o()[c+32>>2>>>0],I=m.getTimezoneOffset(),B=new Date(m.getFullYear(),6,1).getTimezoneOffset(),F=new Date(m.getFullYear(),0,1).getTimezoneOffset(),q=Math.min(F,B);return 0>w?o()[c+32>>2>>>0]=+(B!=F&&q==I):0<w!=(q==I)&&(B=Math.max(F,B),m.setTime(m.getTime()+6e4*((0<w?q:B)-I))),o()[c+24>>2>>>0]=m.getDay(),w=(Cr(m.getFullYear())?jr:Jn)[m.getMonth()]+m.getDate()-1|0,o()[c+28>>2>>>0]=w,o()[c>>2>>>0]=m.getSeconds(),o()[c+4>>2>>>0]=m.getMinutes(),o()[c+8>>2>>>0]=m.getHours(),o()[c+12>>2>>>0]=m.getDate(),o()[c+16>>2>>>0]=m.getMonth(),o()[c+20>>2>>>0]=m.getYear(),c=m.getTime()/1e3,Iu(($r=c,1<=+Math.abs($r)?0<$r?+Math.floor($r/4294967296)>>>0:~~+Math.ceil(($r-+(~~$r>>>0))/4294967296)>>>0:0)),c>>>0},s:h,t:v,A:function(c,m,w){function I(pe){return(pe=pe.toTimeString().match(/\(([A-Za-z ]+)\)$/))?pe[1]:"GMT"}c>>>=0,m>>>=0,w>>>=0;var B=new Date().getFullYear(),F=new Date(B,0,1),q=new Date(B,6,1);B=F.getTimezoneOffset();var me=q.getTimezoneOffset(),ce=Math.max(B,me);i()[c>>2>>>0]=60*ce,o()[m>>2>>>0]=+(B!=me),c=I(F),m=I(q),c=T(c),m=T(m),me<B?(i()[w>>2>>>0]=c,i()[w+4>>2>>>0]=m):(i()[w>>2>>>0]=m,i()[w+4>>2>>>0]=c)},e:()=>{Xt("")},c:function(c,m,w){return c>>>=0,m=M(m>>>0,w>>>0),pn[c].apply(null,m)},l:function(c,m,w){return c>>>=0,m=M(m>>>0,w>>>0),pn[c].apply(null,m)},o:function(){},k:function(){return Date.now()},W:()=>{throw Ot+=1,"unwind"},C:function(){return 4294901760},d:()=>performance.timeOrigin+performance.now(),i:function(){return _?(xh(),Sr(wh)).cpus().length:navigator.hardwareConcurrency},M:function(c,m,w,I){for(ve.Pb=m>>>0,we.length=w,m=I>>>0>>3,I=0;I<w;I++)we[I]=a()[m+I>>>0];return(0>c?pn[-c-1]:Dy[c]).apply(null,we)},z:function(c){c>>>=0;var m=t().length;if(c<=m||4294901760<c)return!1;for(var w=1;4>=w;w*=2){var I=m*(1+.2/w);I=Math.min(I,c+100663296);var B=Math;I=Math.max(c,I);e:{B=B.min.call(B,4294901760,I+(65536-I%65536)%65536)-De.buffer.byteLength+65535>>>16;try{De.grow(B),Ae();var F=1;break e}catch{}F=void 0}if(F)return!0}return!1},Q:Ee,R:Me,J:Gn,h:L,m:be,x:Be,j:Qn,a:De||s.wasmMemory,I:yu,f:function(c,m,w,I){return yu(c>>>0,m>>>0,w>>>0,I>>>0)}};(function(){function c(w,I){return w=w.exports,w=Sy(w),re=w=Ry(w),ve.mb.push(re.Da),at.unshift(re.Y),Ce=I,Io(),w}var m={a:By};if(Ln(),s.instantiateWasm)try{return s.instantiateWasm(m,c)}catch(w){J("Module.instantiateWasm callback failed with error: "+w),d(w)}return Ao(m,function(w){c(w.instance,w.module)}).catch(d),{}})(),s._OrtInit=(c,m)=>(s._OrtInit=re.Z)(c,m),s._OrtGetLastError=(c,m)=>(s._OrtGetLastError=re._)(c,m),s._OrtCreateSessionOptions=(c,m,w,I,B,F,q,me,ce,pe)=>(s._OrtCreateSessionOptions=re.$)(c,m,w,I,B,F,q,me,ce,pe),s._OrtAppendExecutionProvider=(c,m)=>(s._OrtAppendExecutionProvider=re.aa)(c,m),s._OrtAddFreeDimensionOverride=(c,m,w)=>(s._OrtAddFreeDimensionOverride=re.ba)(c,m,w),s._OrtAddSessionConfigEntry=(c,m,w)=>(s._OrtAddSessionConfigEntry=re.ca)(c,m,w),s._OrtReleaseSessionOptions=c=>(s._OrtReleaseSessionOptions=re.da)(c),s._OrtCreateSession=(c,m,w)=>(s._OrtCreateSession=re.ea)(c,m,w),s._OrtReleaseSession=c=>(s._OrtReleaseSession=re.fa)(c),s._OrtGetInputOutputCount=(c,m,w)=>(s._OrtGetInputOutputCount=re.ga)(c,m,w),s._OrtGetInputName=(c,m)=>(s._OrtGetInputName=re.ha)(c,m),s._OrtGetOutputName=(c,m)=>(s._OrtGetOutputName=re.ia)(c,m),s._OrtFree=c=>(s._OrtFree=re.ja)(c),s._OrtCreateTensor=(c,m,w,I,B,F)=>(s._OrtCreateTensor=re.ka)(c,m,w,I,B,F),s._OrtGetTensorData=(c,m,w,I,B)=>(s._OrtGetTensorData=re.la)(c,m,w,I,B),s._OrtReleaseTensor=c=>(s._OrtReleaseTensor=re.ma)(c),s._OrtCreateRunOptions=(c,m,w,I)=>(s._OrtCreateRunOptions=re.na)(c,m,w,I),s._OrtAddRunConfigEntry=(c,m,w)=>(s._OrtAddRunConfigEntry=re.oa)(c,m,w),s._OrtReleaseRunOptions=c=>(s._OrtReleaseRunOptions=re.pa)(c),s._OrtCreateBinding=c=>(s._OrtCreateBinding=re.qa)(c),s._OrtBindInput=(c,m,w)=>(s._OrtBindInput=re.ra)(c,m,w),s._OrtBindOutput=(c,m,w,I)=>(s._OrtBindOutput=re.sa)(c,m,w,I),s._OrtClearBoundOutputs=c=>(s._OrtClearBoundOutputs=re.ta)(c),s._OrtReleaseBinding=c=>(s._OrtReleaseBinding=re.ua)(c),s._OrtRunWithBinding=(c,m,w,I,B)=>(s._OrtRunWithBinding=re.va)(c,m,w,I,B),s._OrtRun=(c,m,w,I,B,F,q,me)=>(s._OrtRun=re.wa)(c,m,w,I,B,F,q,me),s._OrtEndProfiling=c=>(s._OrtEndProfiling=re.xa)(c),s._JsepOutput=(c,m,w)=>(s._JsepOutput=re.ya)(c,m,w),s._JsepGetNodeName=c=>(s._JsepGetNodeName=re.za)(c);var Fo=s._pthread_self=()=>(Fo=s._pthread_self=re.Aa)(),ya=s._malloc=c=>(ya=s._malloc=re.Ba)(c),$u=s._free=c=>($u=s._free=re.Ca)(c);s.__emscripten_tls_init=()=>(s.__emscripten_tls_init=re.Da)();var Tu=s.__emscripten_thread_init=(c,m,w,I,B,F)=>(Tu=s.__emscripten_thread_init=re.Fa)(c,m,w,I,B,F);s.__emscripten_thread_crashed=()=>(s.__emscripten_thread_crashed=re.Ga)();var _u=(c,m,w,I)=>(_u=re.Ha)(c,m,w,I),va=c=>(va=re.Ia)(c),wa=s.__emscripten_thread_exit=c=>(wa=s.__emscripten_thread_exit=re.Ja)(c),Su=s.__emscripten_check_mailbox=()=>(Su=s.__emscripten_check_mailbox=re.Ka)(),Iu=c=>(Iu=re.La)(c),Au=(c,m)=>(Au=re.Ma)(c,m),xa=()=>(xa=re.Na)(),Vo=c=>(Vo=re.Oa)(c),$a=c=>($a=re.Pa)(c),Ou=s.dynCall_ii=(c,m)=>(Ou=s.dynCall_ii=re.Ra)(c,m),Eu=c=>(Eu=re.Sa)(c),Cu=()=>(Cu=re.Ta)(),Pu=c=>(Pu=re.Ua)(c),ku=()=>(ku=re.Va)();s.___start_em_js=1439850,s.___stop_em_js=1440011;function Ry(c){c=Object.assign({},c);var m=I=>()=>I()>>>0,w=I=>B=>I(B)>>>0;return c.__errno_location=m(c.__errno_location),c.pthread_self=m(c.pthread_self),c.malloc=w(c.malloc),c.stackSave=m(c.stackSave),c.stackAlloc=w(c.stackAlloc),c}s.keepRuntimeAlive=or,s.wasmMemory=De,s.stackAlloc=$a,s.stackSave=xa,s.stackRestore=Vo,s.UTF8ToString=_t,s.stringToUTF8=Do,s.lengthBytesUTF8=Hr,s.ExitStatus=Er,s.PThread=ve;var Go;Ur=function c(){Go||Du(),Go||(Ur=c)};function Du(){function c(){if(!Go&&(Go=!0,s.calledRun=!0,!Ne)&&(x||Tr(at),l(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),!x)){if(s.postRun)for(typeof s.postRun=="function"&&(s.postRun=[s.postRun]);s.postRun.length;){var m=s.postRun.shift();vt.unshift(m)}Tr(vt)}}if(!(0<Nt))if(x)l(s),x||Tr(at),startWorker(s);else{if(s.preRun)for(typeof s.preRun=="function"&&(s.preRun=[s.preRun]);s.preRun.length;)Dt.unshift(s.preRun.shift());Tr(Dt),0<Nt||(s.setStatus?(s.setStatus("Running..."),setTimeout(function(){setTimeout(function(){s.setStatus("")},1),c()},1)):c())}}if(s.preInit)for(typeof s.preInit=="function"&&(s.preInit=[s.preInit]);0<s.preInit.length;)s.preInit.pop()();return Du(),e.ready}})();typeof Th=="object"&&typeof Ms=="object"?Ms.exports=$h:typeof define=="function"&&define.amd&&define([],()=>$h)});var Sh=Ye((WC,gx)=>{gx.exports='"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err("worker.js received unknown command "+e.data.cmd),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\n'});var Ah,bx,Ls,zs,Vi,Ih,yx,vx,wx,Oh,st,kn=R(()=>{"use strict";Ah=bh();bx=_h(),zs=!1,Vi=!1,Ih=!1,yx=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},vx=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},wx=(r,e)=>r?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":e?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Oh=async r=>{if(zs)return Promise.resolve();if(Vi)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Ih)throw new Error("previous call to 'initializeWebAssembly()' failed.");Vi=!0;let e=r.initTimeout,n=r.numThreads,t=r.simd,o=n>1&&yx(),i=t&&vx(),u=r.wasmPaths,a=typeof u=="string"?u:void 0,s=wx(i,o),l=typeof u=="object"?u[s]:void 0,d=!1,f=[];if(e>0&&f.push(new Promise(p=>{setTimeout(()=>{d=!0,p()},e)})),f.push(new Promise((p,g)=>{let b=o?bx:Ah,y={locateFile:(_,x)=>{if(o&&_.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Sh()],{type:"text/javascript"}));if(_.endsWith(".wasm")){if(l)return l;let S=a??x;return s==="ort-wasm-simd.wasm"?S+"ort-wasm-simd.jsep.wasm":s==="ort-wasm-simd-threaded.wasm"?S+"ort-wasm-simd-threaded.jsep.wasm":S+s}return x+_}};if(o)if(typeof Blob>"u")y.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let _=`var ortWasmThreaded=${b.toString()};`;y.mainScriptUrlOrBlob=new Blob([_],{type:"text/javascript"})}b(y).then(_=>{Vi=!1,zs=!0,Ls=_,p()},_=>{Vi=!1,Ih=!0,g(_)})})),await Promise.race(f),d)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},st=()=>{if(zs&&Ls)return Ls;throw new Error("WebAssembly is not initialized yet.")}});var pt,bo,Qe,Gi=R(()=>{"use strict";kn();pt=(r,e)=>{let n=st(),t=n.lengthBytesUTF8(r)+1,o=n._malloc(t);return n.stringToUTF8(r,o,t),e.push(o),o},bo=(r,e,n,t)=>{if(typeof r=="object"&&r!==null){if(n.has(r))throw new Error("Circular reference in options");n.add(r)}Object.entries(r).forEach(([o,i])=>{let u=e?e+o:o;if(typeof i=="object")bo(i,u+".",n,t);else if(typeof i=="string"||typeof i=="number")t(u,i.toString());else if(typeof i=="boolean")t(u,i?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof i}`)})},Qe=r=>{let e=st(),n=e.stackSave();try{let t=e.stackAlloc(8);e._OrtGetLastError(t,t+4);let o=e.HEAP32[t/4],i=e.HEAPU32[t/4+1],u=i?e.UTF8ToString(i):"";throw new Error(`${r} ERROR_CODE: ${o}, ERROR_MESSAGE: ${u}`)}finally{e.stackRestore(n)}}});var Eh,Ch=R(()=>{"use strict";kn();Gi();Eh=r=>{let e=st(),n=0,t=[],o=r||{};try{if(r?.logSeverityLevel===void 0)o.logSeverityLevel=2;else if(typeof r.logSeverityLevel!="number"||!Number.isInteger(r.logSeverityLevel)||r.logSeverityLevel<0||r.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${r.logSeverityLevel}`);if(r?.logVerbosityLevel===void 0)o.logVerbosityLevel=0;else if(typeof r.logVerbosityLevel!="number"||!Number.isInteger(r.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${r.logVerbosityLevel}`);r?.terminate===void 0&&(o.terminate=!1);let i=0;return r?.tag!==void 0&&(i=pt(r.tag,t)),n=e._OrtCreateRunOptions(o.logSeverityLevel,o.logVerbosityLevel,!!o.terminate,i),n===0&&Qe("Can't create run options."),r?.extra!==void 0&&bo(r.extra,"",new WeakSet,(u,a)=>{let s=pt(u,t),l=pt(a,t);e._OrtAddRunConfigEntry(n,s,l)!==0&&Qe(`Can't set a run config entry: ${u} - ${a}.`)}),[n,t]}catch(i){throw n!==0&&e._OrtReleaseRunOptions(n),t.forEach(u=>e._free(u)),i}}});var xx,$x,Tx,_x,Ph,kh=R(()=>{"use strict";kn();Gi();xx=r=>{switch(r){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${r}`)}},$x=r=>{switch(r){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${r}`)}},Tx=r=>{r.extra||(r.extra={}),r.extra.session||(r.extra.session={});let e=r.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1"),r.executionProviders&&r.executionProviders.some(n=>(typeof n=="string"?n:n.name)==="webgpu")&&(r.enableMemPattern=!1)},_x=(r,e,n)=>{for(let t of e){let o=typeof t=="string"?t:t.name;switch(o){case"xnnpack":o="XNNPACK";break;case"webnn":if(o="WEBNN",typeof t!="string"){let u=t;if(u?.deviceType){let a=pt("deviceType",n),s=pt(u.deviceType,n);st()._OrtAddSessionConfigEntry(r,a,s)!==0&&Qe(`Can't set a session config entry: 'deviceType' - ${u.deviceType}.`)}if(u?.numThreads){let a=u.numThreads;(typeof a!="number"||!Number.isInteger(a)||a<0)&&(a=0);let s=pt("numThreads",n),l=pt(a.toString(),n);st()._OrtAddSessionConfigEntry(r,s,l)!==0&&Qe(`Can't set a session config entry: 'numThreads' - ${u.numThreads}.`)}if(u?.powerPreference){let a=pt("powerPreference",n),s=pt(u.powerPreference,n);st()._OrtAddSessionConfigEntry(r,a,s)!==0&&Qe(`Can't set a session config entry: 'powerPreference' - ${u.powerPreference}.`)}}break;case"webgpu":if(o="JS",typeof t!="string"){let u=t;if(u?.preferredLayout){if(u.preferredLayout!=="NCHW"&&u.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${u.preferredLayout}`);let a=pt("preferredLayout",n),s=pt(u.preferredLayout,n);st()._OrtAddSessionConfigEntry(r,a,s)!==0&&Qe(`Can't set a session config entry: 'preferredLayout' - ${u.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${o}`)}let i=pt(o,n);st()._OrtAppendExecutionProvider(r,i)!==0&&Qe(`Can't append execution provider: ${o}.`)}},Ph=r=>{let e=st(),n=0,t=[],o=r||{};Tx(o);try{let i=xx(o.graphOptimizationLevel??"all"),u=$x(o.executionMode??"sequential"),a=typeof o.logId=="string"?pt(o.logId,t):0,s=o.logSeverityLevel??2;if(!Number.isInteger(s)||s<0||s>4)throw new Error(`log serverity level is not valid: ${s}`);let l=o.logVerbosityLevel??0;if(!Number.isInteger(l)||l<0||l>4)throw new Error(`log verbosity level is not valid: ${l}`);let d=typeof o.optimizedModelFilePath=="string"?pt(o.optimizedModelFilePath,t):0;if(n=e._OrtCreateSessionOptions(i,!!o.enableCpuMemArena,!!o.enableMemPattern,u,!!o.enableProfiling,0,a,s,l,d),n===0&&Qe("Can't create session options."),o.executionProviders&&_x(n,o.executionProviders,t),o.freeDimensionOverrides)for(let[f,p]of Object.entries(o.freeDimensionOverrides)){if(typeof f!="string")throw new Error(`free dimension override name must be a string: ${f}`);if(typeof p!="number"||!Number.isInteger(p)||p<0)throw new Error(`free dimension override value must be a non-negative integer: ${p}`);let g=pt(f,t);e._OrtAddFreeDimensionOverride(n,g,p)!==0&&Qe(`Can't set a free dimension override: ${f} - ${p}.`)}return o.extra!==void 0&&bo(o.extra,"",new WeakSet,(f,p)=>{let g=pt(f,t),b=pt(p,t);e._OrtAddSessionConfigEntry(n,g,b)!==0&&Qe(`Can't set a session config entry: ${f} - ${p}.`)}),[n,t]}catch(i){throw n!==0&&e._OrtReleaseSessionOptions(n),t.forEach(u=>e._free(u)),i}}});var Ns,ln,yo,Ui,vo,Wi,Fs,ut=R(()=>{"use strict";Ns=r=>{switch(r){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${r}`)}},ln=r=>{switch(r){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${r}`)}},yo=r=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][r],Ui=r=>{switch(r){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${r}`)}},vo=r=>{switch(r){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${r}`)}},Wi=r=>r==="float32"||r==="int32"||r==="int64"||r==="bool"||r==="float16"||r==="uint32",Fs=r=>{switch(r){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${r}`)}}});var Sx,Ix,Dh,Bh,Rh,Ax,nt,Nr=R(()=>{"use strict";ut();Sx=["V","I","W","E","F"],Ix=(r,e)=>{console.log(`[${Sx[r]},${new Date().toISOString()}]${e}`)},Rh=(r,e)=>{Dh=r,Bh=e},Ax=(r,e)=>{let n=vo(r),t=vo(Dh);n>=t&&Ix(n,typeof e=="function"?e():e)},nt=(...r)=>{Bh&&Ax(...r)}});var Mh,Lh=R(()=>{"use strict";ut();Mh=(r,e)=>new(Ui(e))(r)});var Hi=R(()=>{"use strict"});var qi,Ox,zh,Gs,Vs,Fh,Vh=R(()=>{"use strict";Nr();Hi();qi=r=>Math.ceil(r/16)*16,Ox=1,zh=()=>Ox++,Gs=async(r,e,n,t)=>{let o=qi(n),i=r.device.createBuffer({size:o,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let u=r.getCommandEncoder();r.endComputePass(),u.copyBufferToBuffer(e,0,i,0,o),r.flush(),await i.mapAsync(GPUMapMode.READ);let a=i.getMappedRange();if(t){let s=t();return s.set(new Uint8Array(a,0,n)),s}else return new Uint8Array(a.slice(0,n))}finally{i.destroy()}},Vs=class{constructor(e){this.backend=e;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(e,n){let t=n.buffer,o=n.byteOffset,i=n.byteLength,u=qi(i),a=this.storageCache.get(e);if(!a)throw new Error("gpu data for uploading does not exist");if(a.originalSize!==i)throw new Error(`inconsistent data size. gpu data size=${a.originalSize}, data size=${i}`);let s=this.backend.device.createBuffer({mappedAtCreation:!0,size:u,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),l=s.getMappedRange();new Uint8Array(l).set(new Uint8Array(t,o,i)),s.unmap();let d=this.backend.getCommandEncoder();this.backend.endComputePass(),d.copyBufferToBuffer(s,0,a.gpuData.buffer,0,u),nt("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${e})`),this.buffersForUploadingPending.push(s)}memcpy(e,n){let t=this.storageCache.get(e);if(!t)throw new Error("source gpu data for memcpy does not exist");let o=this.storageCache.get(n);if(!o)throw new Error("destination gpu data for memcpy does not exist");if(t.originalSize!==o.originalSize)throw new Error("inconsistent source and destination gpu data size");let i=qi(t.originalSize),u=this.backend.getCommandEncoder();this.backend.endComputePass(),u.copyBufferToBuffer(t.gpuData.buffer,0,o.gpuData.buffer,0,i)}registerExternalBuffer(e,n,t){let o;if(t){if(o=this.externalBuffers.get(t),o===void 0)throw new Error("previous buffer is not registered");if(e===t)return nt("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${n}) => id=${o}, buffer is the same, skip.`),o;this.externalBuffers.delete(t)}else o=zh();return this.storageCache.set(o,{gpuData:{id:o,type:0,buffer:e},originalSize:n}),this.externalBuffers.set(e,o),nt("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${n}) => id=${o}, registered.`),o}unregisterExternalBuffer(e){let n=this.externalBuffers.get(e);n!==void 0&&(this.storageCache.delete(n),this.externalBuffers.delete(e),nt("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${n}`))}create(e,n=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let t=qi(e),o,i=(n&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,u=(n&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(i||u){let s=i?this.freeBuffers:this.freeUniformBuffers,l=s.get(t);l||(l=[],s.set(t,l)),l.length>0?o=l.pop():o=this.backend.device.createBuffer({size:t,usage:n})}else o=this.backend.device.createBuffer({size:t,usage:n});let a={id:zh(),type:0,buffer:o};return this.storageCache.set(a.id,{gpuData:a,originalSize:e}),nt("verbose",()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${a.id}`),a}get(e){return this.storageCache.get(e)?.gpuData}release(e){let n=this.storageCache.get(e);if(!n)throw new Error("releasing data does not exist");return nt("verbose",()=>`[WebGPU] GpuDataManager.release(id=${e}), gpuDataId=${n.gpuData.id}`),this.storageCache.delete(e),this.buffersPending.push(n.gpuData.buffer),n.originalSize}async download(e,n){let t=this.storageCache.get(e);if(!t)throw new Error("data does not exist");await Gs(this.backend,t.gpuData.buffer,t.originalSize,n)}refreshPendingBuffers(){for(let e of this.buffersForUploadingPending)e.destroy();this.buffersForUploadingPending=[];for(let e of this.buffersPending)(e.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(e.size).push(e):(e.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(e.size).push(e):e.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(e=>{e.forEach(n=>{n.destroy()})}),this.freeUniformBuffers.forEach(e=>{e.forEach(n=>{n.destroy()})}),this.storageCache.forEach(e=>{e.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},Fh=(...r)=>new Vs(...r)});var Us,ge,ot=R(()=>{"use strict";Us=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(e=>`${this[e]}`).join(";")),this.key}},ge=r=>new Us(r)});var Ws,hr,V,dn,ji,Ki,Yi,Re=R(()=>{"use strict";Ws=class{static calcMatMulShape(e,n){return e[1]!==n[0]?void 0:[e[0],n[1]]}},hr=class{static calcShape(e,n,t=!1){let o=e.length,i=n.length;if(o===0)return n;if(i===0)return e;let u=Math.max(e.length,n.length),a=new Array(u);if(t){if(o<2||i<2)return;let s=Ws.calcMatMulShape([e[o-2],e[o-1]],[n[i-2],n[i-1]]);if(s===void 0)return;[a[u-2],a[u-1]]=s}for(let s=t?3:1;s<=u;s++){let l=o-s<0?1:e[o-s],d=i-s<0?1:n[i-s];if(l!==d&&l>1&&d>1)return;a[u-s]=Math.max(l,d)}return a}static isValidBroadcast(e,n){let t=e.length,o=n.length;if(t>o)return!1;for(let i=1;i<=t;i++)if(e[t-i]!==1&&e[t-i]!==n[o-i])return!1;return!0}},V=class r{static size(e){return r.getSizeFromDimensionRange(e,0,e.length)}static sizeFromDimension(e,n){if(n<0||n>e.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return r.getSizeFromDimensionRange(e,n,e.length)}static sizeToDimension(e,n){if(n<0||n>e.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${e.length} dimensions.`);return r.getSizeFromDimensionRange(e,0,n)}static getSizeFromDimensionRange(e,n,t){let o=1;for(let i=n;i<t;i++){if(e[i]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");o*=e[i]}return o}static computeStrides(e){let n=e.length;if(n===0)return[];if(n===1)return[1];let t=new Array(n);t[n-1]=1,t[n-2]=e[n-1];for(let o=n-3;o>=0;--o)t[o]=t[o+1]*e[o+1];return t}static normalizeAxis(e,n){if(e<-n&&e>=n)throw new Error("unsupported axis for this operation.");return e<0?e+n:e}static normalizeAxes(e,n){return e.map(t=>this.normalizeAxis(t,n??e.length))}static sortBasedOnPerm(e,n){return n?n.map(t=>e[t]):e.slice().reverse()}static padShape(e,n){let t=e.length;return e.map((o,i)=>o+n[i]+n[i+t])}static areEqual(e,n){return e.length!==n.length?!1:e.every((t,o)=>t===n[o])}},dn=class r{static adjustPoolAttributes(e,n,t,o,i,u){if(!e&&t.length!==n.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let a=0;a<n.length-2;a++)a>=t.length?t.push(n[a+2]):t[a]=n[a+2];for(let a=0;a<t.length;a++)if(a<o.length){if(o[a]<0)throw new Error("strides should be greater than or equal to 1")}else o.push(1);for(let a=0;a<t.length;a++)if(a<i.length){if(i[a]<0)throw new Error("dilations should be greater than or equal to 1")}else i.push(1);for(let a=0;a<t.length*2;a++)if(a<u.length){if(u[a]<0)throw new Error("pad should be greater than or equal to 1")}else u.push(0);for(let a=0;a<t.length;a++){if(t[a]<=0)throw new Error("kernel shapes need to be greater than 0");if(u[a]>=t[a]||u[a+t.length]>=t[a])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,n,t,o,i,u,a){if(a){if(i.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(n.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(o.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let s=0;s<e.length-2;s++)r.adjustPadAndReturnShape(e[s+(u?1:2)],n[s],t[s],o[s],i,s,s+e.length-2,a)}}static computePoolOutputShape(e,n,t,o,i,u,a){if(n.length<=0)throw new Error("input shape must be of size greater than 0");let s=[n[0],n[1]];return r.computeShapeHelper(e,n,s,t,o,i,u,a),s}static computeConvOutputShape(e,n,t,o,i,u,a){if(e.length<=0||n.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let s=[e[0],n[0]];return r.computeShapeHelper(!1,e,s,t,o,i,u,a),s}static computeShapeHelper(e,n,t,o,i,u,a,s){if(e)for(let l=0;l<n.length-2;l++)t.push(1);else for(let l=0;l<n.length-2;l++)t.push(r.adjustPadAndReturnShape(n[l+2],o[l],i[l],u[l],a,l,l+n.length-2,s))}static adjustPadAndReturnShape(e,n,t,o,i,u,a,s){let l=t*(o-1)+1;if(s&&s!=="NOTSET")switch(s){case"VALID":return i[u]=0,i[a]=0,Math.floor((e-l)/n+1);case"SAME_LOWER":case"SAME_UPPER":if(t!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let f=((e+n-1)/n-1)*n+o-e;return i[u]=Math.floor(s==="SAME_LOWER"?(f+1)/2:f/2),i[a]=f-i[u],Math.floor((e+f-o)/n+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((e+i[u]+i[a]-l)/n+1)}},ji=class{static getShapeOfGemmResult(e,n,t,o,i){if(e.length!==2||t.length!==2)throw new Error("shape need to be of size 2");let u,a,s;n?(u=e[1],a=e[0]):(u=e[0],a=e[1]);let l=-1;if(o?(s=t[0],l=1):(s=t[1],l=0),t[l]!==a)throw new Error("dimension mismatch");if(u<=0||s<=0||a<=0)throw new Error("invalid shape specified");if(i&&!hr.isValidBroadcast(i,[u,s]))throw new Error("gemm: invalid bias shape for broadcast");return[u,s,a]}},Ki=-34028234663852886e22,Yi=34028234663852886e22});var Ex,qs,et,Fr,ee,bt,At,rr,zt,qe,js,W,te,Xi,Hs,Gh,Dn,tt,ke=R(()=>{"use strict";ut();Re();Ex=64,qs=(r,e)=>{if(e===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(r){case 10:return e>1?`vec${e}<f16>`:"f16";case 1:return e>1?`vec${e}<f32>`:"f32";case 6:return e>1?`vec${e}<i32>`:"i32";case 12:return e>1?`vec${e}<u32>`:"u32";case 7:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(e>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(e!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${r}`)}},et=(r,e=1)=>{let n=qs(r,e);return typeof n=="string"?n:n[0]},Fr=(r,e=1)=>{let n=qs(r,e);return typeof n=="string"?n:n[1]},ee=r=>r.length===0?[]:[{type:"uint32",data:r},{type:"uint32",data:V.computeStrides(r)}],bt=r=>r%4===0?4:r%2===0?2:1,At=(r="f32",e,n="0")=>!e||e===1?`${r}(${n})`:`vec${e}<${r}>(${n})`,rr=(r,e,n)=>r==="f32"?n:e===1?`f32(${n})`:`vec${e}f(${n})`,zt=(r,e)=>e===4?`(${r}.x + ${r}.y + ${r}.z + ${r}.w)`:e===2?`(${r}.x + ${r}.y)`:e===3?`(${r}.x + ${r}.y + ${r}.z)`:r,qe=(r,e,n)=>r.startsWith("uniforms.")&&n>4?typeof e=="string"?`${r}[(${e}) / 4][(${e}) % 4]`:`${r}[${Math.floor(e/4)}][${e%4}]`:n>1?`${r}[${e}]`:r,js=(r,e,n,t,o)=>{let i=typeof n=="number",u=i?n:n.length,a=[...new Array(u).keys()],s=u<2?"u32":u<=4?`vec${u}<u32>`:`array<u32, ${u}>`,l=qs(e,o),d=typeof l=="string"?l:l[1],f=typeof l=="string"?l:l[0],p={indices:s,value:d,storage:f,tensor:e},g=K=>typeof K=="string"?K:`${K}u`,b={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},y=i?"uniforms.":"",_=`${y}${r}_shape`,x=`${y}${r}_strides`,S="";for(let K=0;K<u-1;K++)S+=`
    let dim${K} = current / ${qe(x,K,u)};
    let rest${K} = current % ${qe(x,K,u)};
    indices[${K}] = dim${K};
    current = rest${K};
    `;S+=`indices[${u-1}] = current;`;let O=u<2?"":`
  fn o2i_${r}(offset: u32) -> ${p.indices} {
    var indices: ${p.indices};
    var current = offset;
    ${S}
    return indices;
  }`,C=K=>(b.offsetToIndices=!0,u<2?K:`o2i_${r}(${K})`),N=[];if(u>=2)for(let K=u-1;K>=0;K--)N.push(`${qe(x,K,u)} * (indices[${K}])`);let k=u<2?"":`
  fn i2o_${r}(indices: ${p.indices}) -> u32 {
    return ${N.join("+")};
  }`,U=K=>(b.indicesToOffset=!0,u<2?K:`i2o_${r}(${K})`),G=(...K)=>u===0?"0u":`${p.indices}(${K.map(g).join(",")})`,H=(K,fe)=>u<2?`${K}`:`${qe(K,fe,u)}`,ne=(K,fe,Ae)=>u<2?`${K}=${Ae};`:`${qe(K,fe,u)}=${Ae};`,P={},J=(K,fe)=>{b.broadcastedIndicesToOffset=!0;let Ae=`${fe.name}broadcastedIndicesTo${r}Offset`;if(Ae in P)return`${Ae}(${K})`;let Tt=[];for(let Dt=u-1;Dt>=0;Dt--){let at=fe.indicesGet("outputIndices",Dt+fe.rank-u);Tt.push(`${H(x,Dt)} * (${at} % ${H(_,Dt)})`)}return P[Ae]=`fn ${Ae}(outputIndices: ${fe.type.indices}) -> u32 {
             return ${Tt.length>0?Tt.join("+"):"0u"};
           }`,`${Ae}(${K})`},Te=(K,fe)=>(()=>{if(p.storage===p.value)return`${r}[${K}]=${fe};`;if(p.storage==="vec2<u32>"&&p.value==="i32")return`${r}[${K}]=vec2<u32>(u32(${fe}), select(0u, 0xFFFFFFFFu, ${fe} < 0));`;if(p.storage==="vec2<u32>"&&p.value==="u32")return`${r}[${K}]=vec2<u32>(u32(${fe}), 0u);`;if(p.storage==="u32"&&p.value==="vec4<bool>")return`${r}[${K}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${fe}));`;throw new Error(`not supported combination of storage type ${p.storage} and value type ${p.value} yet`)})(),ae=K=>(()=>{if(p.storage===p.value)return`${r}[${K}]`;if(p.storage==="vec2<u32>"&&p.value==="i32")return`i32(${r}[${K}].x)`;if(p.storage==="vec2<u32>"&&p.value==="u32")return`u32(${r}[${K}].x)`;if(p.storage==="u32"&&p.value==="vec4<bool>")return`vec4<bool>(bool(${r}[${K}] & 0xFFu), bool(${r}[${K}] & 0xFF00u), bool(${r}[${K}] & 0xFF0000u), bool(${r}[${K}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${p.storage} and value type ${p.value} yet`)})(),De=u<2?"":`
  fn get_${r}ByIndices(indices: ${p.indices}) -> ${d} {
    return ${ae(`i2o_${r}(indices)`)};
  }`,re=u<2?"":(()=>{let K=a.map(Ae=>`d${Ae}: u32`).join(", "),fe=a.map(Ae=>`d${Ae}`).join(", ");return`
  fn get_${r}(${K}) -> ${d} {
    return get_${r}ByIndices(${G(fe)});
  }`})(),Ce=(...K)=>{if(K.length!==u)throw new Error(`indices length must be ${u}`);let fe=K.map(g).join(",");return u===0?ae("0u"):u===1?ae(fe[0]):(b.get=!0,b.getByIndices=!0,b.indicesToOffset=!0,`get_${r}(${fe})`)},Ne=K=>u<2?ae(K):(b.getByIndices=!0,b.indicesToOffset=!0,`get_${r}ByIndices(${K})`),Se=u<2?"":`
  fn set_${r}ByIndices(indices: ${p.indices}, value: ${d}) {
    ${Te(`i2o_${r}(indices)`,"value")}
  }`,$e=u<2?"":(()=>{let K=a.map(Ae=>`d${Ae}: u32`).join(", "),fe=a.map(Ae=>`d${Ae}`).join(", ");return`
  fn set_${r}(${K}, value: ${d}) {
    set_${r}ByIndices(${G(fe)}, value);
  }`})();return{impl:()=>{let K=[];return i||(K.push(`const ${_} = ${p.indices}(${n.join(",")});`),K.push(`const ${x} = ${p.indices}(${V.computeStrides(n).join(",")});`)),b.offsetToIndices&&K.push(O),b.indicesToOffset&&K.push(k),b.broadcastedIndicesToOffset&&Object.values(P).forEach(fe=>K.push(fe)),b.set&&K.push($e),b.setByIndices&&K.push(Se),b.get&&K.push(re),b.getByIndices&&K.push(De),K.join(`
`)},type:p,offsetToIndices:C,indicesToOffset:U,broadcastedIndicesToOffset:J,indices:G,indicesGet:H,indicesSet:ne,set:(...K)=>{if(K.length!==u+1)throw new Error(`indices length must be ${u}`);let fe=K[u];if(typeof fe!="string")throw new Error("value must be string");let Ae=K.slice(0,u).map(g).join(",");return u===0?Te("0u",fe):u===1?Te(Ae[0],fe):(b.set=!0,b.setByIndices=!0,b.indicesToOffset=!0,`set_${r}(${Ae}, ${fe})`)},setByOffset:Te,setByIndices:(K,fe)=>u<2?Te(K,fe):(b.setByIndices=!0,b.indicesToOffset=!0,`set_${r}ByIndices(${K}, ${fe});`),get:Ce,getByOffset:ae,getByIndices:Ne,usage:t,name:r,strides:x,shape:_,rank:u}},W=(r,e,n,t=1)=>js(r,e,n,"input",t),te=(r,e,n,t=1)=>js(r,e,n,"output",t),Xi=(r,e,n,t=1)=>js(r,e,n,"internal",t),Hs=class{constructor(e){this.normalizedDispatchGroup=e;this.internalVariables=[];this.variables=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${typeof e=="number"?`${e}u`:e}) { return; }`}mainStart(e=Ex){let n=typeof e=="number"?e:e[0],t=typeof e=="number"?1:e[1],o=typeof e=="number"?1:e[2],i=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,u=i?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,a=i?"let global_idx = global_id.x; let local_idx = local_id.x;":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${n*t*o}u + local_idx;`;return`@compute @workgroup_size(${n}, ${t}, ${o})
  fn main(${u}) {
    ${a}
  `}appendVariableUniforms(e){e.rank!==0&&(e.shape.startsWith("uniforms.")&&this.uniforms.push({name:e.shape.replace("uniforms.",""),type:"u32",length:e.rank}),e.strides.startsWith("uniforms.")&&this.uniforms.push({name:e.strides.replace("uniforms.",""),type:"u32",length:e.rank}))}declareVariable(e,n){if(e.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(e),this.appendVariableUniforms(e);let t=e.usage==="input"?"read":"read_write",o=e.type.storage;return`@group(0) @binding(${n}) var<storage, ${t}> ${e.name}: array<${o}>;`}declareVariables(...e){return e.map(n=>this.declareVariable(n,this.variableIndex++)).join(`
`)}registerInternalVariable(e){if(e.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(e),this.appendVariableUniforms(e)}registerInternalVariables(...e){return e.forEach(n=>this.registerInternalVariable(n)),this}registerUniform(e,n,t=1){return this.uniforms.push({name:e,type:n,length:t}),this}registerUniforms(e){return this.uniforms=this.uniforms.concat(e),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let e=[];for(let{name:n,type:t,length:o}of this.uniforms)if(o&&o>4)e.push(`${n}:array<vec4<${t}>, ${Math.ceil(o/4)}>`);else{let i=o==null||o===1?t:`vec${o}<${t}>`;e.push(`${n}:${i}`)}return`
      struct Uniforms { ${e.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(e=>e.impl()).join(`
`)+this.internalVariables.map(e=>e.impl()).join(`
`)}},Gh=r=>new Hs(r),Dn=(r,e)=>{let n=r.length,t=[];for(let o=0;o<n;o++){let i=n-1-o,u=r[i]||1;(e[e.length-1-o]||1)>1&&u===1&&t.unshift(i)}return t},tt=r=>!0});var Cx,Uh,Px,kx,nr,Wh,Hh,Bn=R(()=>{"use strict";Re();ot();ke();Cx=r=>{if(!r||r.length!==1)throw new Error("Transpose requires 1 input.")},Uh=(r,e)=>e&&e.length!==r?[...new Array(r).keys()].reverse():e,Px=(r,e)=>V.sortBasedOnPerm(r,Uh(r.length,e)),kx=(r,e,n,t)=>{let o=[];o.push(`fn perm(i: ${t.type.indices}) -> ${n.type.indices} {
    var a: ${n.type.indices};`);for(let i=0;i<e;++i)o.push(n.indicesSet("a",r[i],`i[${i}]`));return o.push("return a;}"),o.join(`
`)},nr=(r,e)=>{let n=r.dataType,t=r.dims.length,o=Uh(t,e),i=tt(t),u=Px(r.dims,o),a=i?u.length:u,s=i?t:r.dims,l=te("output",n,a),d=W("a",n,s),f=p=>`
  ${p.registerUniform("output_size","u32").declareVariables(d,l)}

  ${kx(o,t,d,l)}

  ${p.mainStart()}
    ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${l.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${l.setByOffset("global_idx",d.getByIndices("aIndices"))}
  }`;return{name:"Transpose",shaderCache:{hint:`${e}`,inputDependencies:i?["rank"]:["dims"]},getRunData:p=>{let g=V.size(u);return{outputs:[{dims:u,dataType:p[0].dataType}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:i?[{type:"uint32",data:g},...ee(p[0].dims),...ee(u)]:[{type:"uint32",data:g}]}},getShaderSource:f}},Wh=(r,e)=>{Cx(r.inputs),r.compute(nr(r.inputs[0],e.perm))},Hh=r=>ge({perm:r.perm})});var Dx,Bx,Rx,Mx,Lx,zx,Nx,Fx,Vx,Gx,mr,qh,jh,Kh,Yh,Xh,Zh,Jh,Qh,em,tm,rm=R(()=>{"use strict";Re();ke();Zi();Bn();Dx={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},Bx={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},Rx={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},Mx={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Lx=(r,e)=>{let n=[];for(let t=e-r;t<e;++t)n.push(t);return n},zx=(r,e)=>{let n=[],t=r.length;for(let i=0;i<t;i++)e.indexOf(i)===-1&&n.push(r[i]);let o=e.map(i=>r[i]);return[n,o]},Nx=(r,e)=>{let n=r.length+e.length,t=[],o=0;for(let i=0;i<n;i++)e.indexOf(i)===-1?t.push(r[o++]):t.push(1);return t},Fx=(r,e)=>{for(let n=0;n<r.length;++n)if(r[r.length-n-1]!==e-1-n)return!1;return!0},Vx=(r,e)=>{let n=[];if(!Fx(r,e)){for(let t=0;t<e;++t)r.indexOf(t)===-1&&n.push(t);r.forEach(t=>n.push(t))}return n},Gx=(r,e,n,t,o,i,u)=>{let a=n[0].dims,s=V.size(i),l=V.size(u),d=W("_A",n[0].dataType,a),f=te("output",o,i),p=32,g=`
          var<workgroup> aBestValues : array<${f.type.storage}, ${p}>;
       `;return{name:r,shaderCache:e,getShaderSource:y=>`
        ${y.registerUniform("reduceSize","u32").declareVariables(d,f)}
        ${g}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${y.mainStart(p)}

          let outputIndex = global_idx / ${p};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = ${f.type.storage}(${Rx[t]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${p}) {
           let candidate = ${f.type.storage}(${d.getByOffset("offset + k")});
           bestValue = ${Dx[t]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${p}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${Bx[t]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${f.setByOffset("outputIndex",`${t==="mean"?`bestValue / ${f.type.storage}(uniforms.reduceSize)`:`${Mx[t]}`}`)};
         }
        }`,getRunData:()=>({outputs:[{dims:i,dataType:o}],dispatchGroup:{x:s},programUniforms:[{type:"uint32",data:l}]})}},mr=(r,e,n,t)=>{let o=r.inputs.length===1?n:Ks(r.inputs,n),i=o.axes;i.length===0&&!o.noopWithEmptyAxes&&(i=r.inputs[0].dims.map((g,b)=>b));let u=V.normalizeAxes(i,r.inputs[0].dims.length),a=u,s=r.inputs[0],l=Vx(a,r.inputs[0].dims.length);l.length>0&&(s=r.compute(nr(r.inputs[0],l),{inputs:[0],outputs:[-1]})[0],a=Lx(a.length,s.dims.length));let[d,f]=zx(s.dims,a),p=d;o.keepDims&&(p=Nx(d,u)),r.compute(Gx(e,{hint:o.cacheKey,inputDependencies:["type"]},[s],t,r.inputs[0].dataType,p,f),{inputs:[s]})},qh=(r,e)=>{mr(r,"ReduceMeanShared",e,"mean")},jh=(r,e)=>{mr(r,"ReduceL1Shared",e,"l1")},Kh=(r,e)=>{mr(r,"ReduceL2Shared",e,"l2")},Yh=(r,e)=>{mr(r,"ReduceLogSumExpShared",e,"logSumExp")},Xh=(r,e)=>{mr(r,"ReduceMaxShared",e,"max")},Zh=(r,e)=>{mr(r,"ReduceMinShared",e,"min")},Jh=(r,e)=>{mr(r,"ReduceProdShared",e,"prod")},Qh=(r,e)=>{mr(r,"ReduceSumShared",e,"sum")},em=(r,e)=>{mr(r,"ReduceSumSquareShared",e,"sumSquare")},tm=(r,e)=>{mr(r,"ReduceLogSumShared",e,"logSum")}});var gr,Ux,Ji,Ks,br,Wx,Hx,qx,jx,Kx,Yx,Xx,Zx,Jx,Qx,yr,nm,om,im,am,sm,um,lm,dm,cm,fm,Zi=R(()=>{"use strict";Re();ot();ke();rm();gr=r=>{if(!r||r.length===0||r.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(r.length===2&&r[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Ux=r=>["","",`var value = ${r.getByIndices("input_indices")};`,""],Ji=(r,e,n,t,o,i,u=!1,a=!1)=>{let s=[],l=n[0].dims,d=l.length,f=V.normalizeAxes(o,d),p=!a&&f.length===0;l.forEach((_,x)=>{p||f.indexOf(x)>=0?u&&s.push(1):s.push(_)});let g=s.length,b=V.size(s);return{name:r,shaderCache:e,getShaderSource:_=>{let x=[],S=W("_A",n[0].dataType,d),O=te("output",i,g),C=t(S,O,f),N=C[2];for(let k=0,U=0;k<d;k++)p||f.indexOf(k)>=0?(u&&U++,N=`for(var j${k}: u32 = 0; j${k} < ${l[k]}; j${k}++) {
                  ${C[2].includes("last_index")?`let last_index = j${k};`:""}
                  ${S.indicesSet("input_indices",k,`j${k}`)}
                  ${N}
                }`):(x.push(`${S.indicesSet("input_indices",k,O.indicesGet("output_indices",U))};`),U++);return`

        ${_.registerUniform("output_size","u32").declareVariables(S,O)}

        ${_.mainStart()}
          ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${S.type.indices};
          let output_indices = ${O.offsetToIndices("global_idx")};

          ${x.join(`
`)}
          ${C[0]}       // init ops for reduce max/min
          ${C[1]}
          ${N}
          ${C[3]}
          ${C.length===4?O.setByOffset("global_idx","value"):C.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:s,dataType:i}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:[{type:"uint32",data:b},...ee(l),...ee(s)]})}},Ks=(r,e)=>{let n=[];return r[1].dims[0]>0&&r[1].getBigInt64Array().forEach(t=>n.push(Number(t))),ge({axes:n,keepDims:e.keepDims,noopWithEmptyAxes:e.noopWithEmptyAxes})},br=(r,e,n,t)=>{let o=r.inputs,i=o.length===1?n:Ks(o,n);r.compute(Ji(e,{hint:i.cacheKey,inputDependencies:["rank"]},[o[0]],i.noopWithEmptyAxes&&i.axes.length===0?Ux:t,i.axes,o[0].dataType,i.keepDims,i.noopWithEmptyAxes),{inputs:[0]})},Wx=(r,e)=>{gr(r.inputs),br(r,"ReduceLogSum",e,(t,o)=>[`var value = ${o.type.storage}(0);`,"",`value += ${t.getByIndices("input_indices")};`,"value = log(value);"])},Hx=(r,e)=>{gr(r.inputs),br(r,"ReduceL1",e,(t,o)=>[`var value = ${o.type.storage}(0);`,"",`value += abs(${t.getByIndices("input_indices")});`,""])},qx=(r,e)=>{gr(r.inputs),br(r,"ReduceL2",e,(t,o)=>[`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,"",`t = ${t.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},jx=(r,e)=>{gr(r.inputs),br(r,"ReduceLogSumExp",e,(t,o)=>[`var value = ${o.type.storage}(0);`,"",`value += exp(${t.getByIndices("input_indices")});`,"value = log(value);"])},Kx=(r,e)=>{gr(r.inputs),br(r,"ReduceMax",e,(t,o,i)=>{let u=[];for(let a=0;a<t.rank;a++)(i.indexOf(a)>=0||i.length===0)&&u.push(t.indicesSet("input_indices",a,0));return[`${u.join(`
`)}`,`var value = ${t.getByIndices("input_indices")};`,`value = max(value, ${t.getByIndices("input_indices")});`,""]})},Yx=(r,e)=>{gr(r.inputs),br(r,"ReduceMean",e,(t,o,i)=>{let u=1;for(let a=0;a<t.rank;a++)(i.indexOf(a)>=0||i.length===0)&&(u*=r.inputs[0].dims[a]);return["var sum = f32(0);","",`sum += f32(${t.getByIndices("input_indices")});`,`let value = ${o.type.value}(sum / ${u});`]})},Xx=(r,e)=>{gr(r.inputs),br(r,"ReduceMin",e,(t,o,i)=>{let u=[];for(let a=0;a<t.rank;a++)(i.indexOf(a)>=0||i.length===0)&&u.push(`input_indices[${a}] = 0;`);return[`${u.join(`
`)}`,`var value = ${t.getByIndices("input_indices")};`,`value = min(value, ${t.getByIndices("input_indices")});`,""]})},Zx=(r,e)=>{gr(r.inputs),br(r,"ReduceProd",e,(t,o)=>[`var value = ${o.type.storage}(1);`,"",`value *= ${t.getByIndices("input_indices")};`,""])},Jx=(r,e)=>{gr(r.inputs),br(r,"ReduceSum",e,(t,o)=>[`var value = ${o.type.storage}(0);`,"",`value += ${t.getByIndices("input_indices")};`,""])},Qx=(r,e)=>{gr(r.inputs),br(r,"ReduceSumSquare",e,(t,o)=>[`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,"",`t = ${t.getByIndices("input_indices")}; value += t * t;`,""])},yr=(r,e,n)=>{if(e.length===0)return n;let t=1,o=1;for(let i=0;i<e.length;i++)e.indexOf(i)===-1?t*=r[i]:o*=r[i];return o<32&&t>1024},nm=(r,e)=>{yr(r.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Yx(r,e):qh(r,e)},om=(r,e)=>{yr(r.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Hx(r,e):jh(r,e)},im=(r,e)=>{yr(r.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?qx(r,e):Kh(r,e)},am=(r,e)=>{yr(r.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?jx(r,e):Yh(r,e)},sm=(r,e)=>{yr(r.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Kx(r,e):Xh(r,e)},um=(r,e)=>{yr(r.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Xx(r,e):Zh(r,e)},lm=(r,e)=>{yr(r.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Zx(r,e):Jh(r,e)},dm=(r,e)=>{yr(r.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Jx(r,e):Qh(r,e)},cm=(r,e)=>{yr(r.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Qx(r,e):em(r,e)},fm=(r,e)=>{yr(r.inputs[0].dims,e.axes,e.noopWithEmptyAxes)?Wx(r,e):tm(r,e)}});var pm,hm,mm,Ys,gm=R(()=>{"use strict";ut();ot();Zi();pm=r=>{if(!r||r.length===0||r.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(r[0].dataType!==1)throw new Error("Invalid input type.")},hm=(r,e)=>{pm(r.inputs);let n=(t,o,i)=>{let u=[];for(let a=0;a<t.rank;a++)(i.indexOf(a)>=0||i.length===0)&&u.push(`input_indices[${a}] = 0;`);return[`${u.join(`
`)}`,`var value = ${t.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${t.getByIndices("input_indices")} ${e.selectLastIndex>0?"<=":"<"} value) {
         value = ${t.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",o.setByOffset("global_idx","best_index")]};r.compute(Ji("ArgMin",{hint:e.cacheKey,inputDependencies:["rank"]},[r.inputs[0]],n,[e.axis],7,e.keepDims),{inputs:[0]})},mm=(r,e)=>{pm(r.inputs);let n=(t,o,i)=>{let u=[];for(let a=0;a<t.rank;a++)(i.indexOf(a)>=0||i.length===0)&&u.push(`input_indices[${a}] = 0;`);return[`${u.join(`
`)}`,`var value = ${t.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${t.getByIndices("input_indices")} ${e.selectLastIndex>0?">=":">"} value) {
         value = ${t.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",o.setByOffset("global_idx","best_index")]};r.compute(Ji("argMax",{hint:e.cacheKey,inputDependencies:["rank"]},[r.inputs[0]],n,[e.axis],7,e.keepDims),{inputs:[0]})},Ys=r=>ge(r)});var e2,bm,t2,r2,n2,Qi,o2,ym,Xs=R(()=>{"use strict";ot();Hi();ke();e2=(r,e)=>{let n=r[0],t=r[1],o=r[2],i=r[3],u=r[4],a=r[5];if(u&&a)throw new Error("Attention cannot have both past and relative_position_bias");if(n.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let s=n.dims[0],l=n.dims[1],d=n.dims[2];if(o.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(t.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(t.dims[0]!==d)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(o.dims[0]!==t.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let f=o.dims[0]/3,p=f,g=p;if(e.qkvHiddenSizes.length>0){if(e.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let O of e.qkvHiddenSizes)if(O%e.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");f=e.qkvHiddenSizes[0],p=e.qkvHiddenSizes[1],g=e.qkvHiddenSizes[2]}let b=l;if(f!==p)throw new Error("qkv_hidden_sizes first element should be same as the second");if(o.dims[0]!==f+p+g)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let y=0;if(u){if(p!==g)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(u.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(u.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(u.dims[1]!==s)throw new Error('Input "past" second dimension must be batch_size');if(u.dims[2]!==e.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(u.dims[4]!==p/e.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');e.pastPresentShareBuffer||(y=u.dims[3])}let _=b+y,x=-1,S=0;if(i)throw new Error("Mask not supported");if(u)throw new Error("past is not supported");if(a)throw new Error("relativePositionBias is not supported");return{batchSize:s,sequenceLength:l,pastSequenceLength:y,kvSequenceLength:b,totalSequenceLength:_,maxSequenceLength:x,inputHiddenSize:d,hiddenSize:f,vHiddenSize:g,headSize:Math.floor(f/e.numHeads),vHeadSize:Math.floor(g/e.numHeads),numHeads:e.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:e.maskFilterValue,maskType:S,scale:e.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},bm=r=>ge({...r}),t2=(r,e,n,t)=>{let o=bt(t),i=te("x",e.dataType,e.dims,o),u="threadMaxVector";o===2?u="max(threadMaxVector.x, threadMaxVector.y)":o===4&&(u="max(max(threadMaxVector.x, threadMaxVector.y), max(threadMaxVector.z, threadMaxVector.w))");let a=et(e.dataType),s=64,l=t/o;l<s?s=1:l/8<64&&(s=Math.ceil(l/8));let d=Math.ceil(t/o/s),f=p=>`
  const dInv: ${a} = 1 / ${t};
  const dComp = ${t/o};
  var<workgroup> wgMax: array<f32, ${s}>;
  var<workgroup> wgSum: array<f32, ${s}>;

  ${p.declareVariables(i)}
  @compute @workgroup_size(${s}, 1, 1)
  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_index : u32) {
    let localOffset = local_index * ${d};
    let offset: u32 = workgroup_id.x * dComp + localOffset;

    var threadMaxVector = ${At("f32",o,"-3.402823e+38f")};
    for (var i: u32 = 0; i < ${d} && i + localOffset < dComp; i++) {
      threadMaxVector = max(${rr(a,o,"x[offset + i]")}, threadMaxVector);
    }
    wgMax[local_index] = ${u};
    workgroupBarrier();

    var maxValue = -3.402823e+38f;
    for (var i = 0u; i < ${s}; i++) {
      maxValue = max(wgMax[i], maxValue);
    }

    var sumVector = ${At("f32",o,"0")};
    for (var i: u32 = 0; i < ${d} && i + localOffset < dComp; i++) {
      sumVector += exp(${rr(a,o,"x[offset + i]")} - maxValue);
    }
    wgSum[local_index] = ${zt("sumVector",o)};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${s}; i++) {
      sum += wgSum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < ${d} && i + localOffset < dComp; i++) {
        x[offset + i] = ${At(a,o,"dInv")};
      }
    } else {
      for (var i: u32 = 0; i < ${d} && i + localOffset < dComp; i++) {
        let f32input = ${rr(a,o,"x[offset + i]")};
        x[offset + i] = ${i.type.value}(exp(f32input - maxValue) / sum);
      }
    }
  }`;r.compute({name:"AttentionProbsSoftmax",shaderCache:{hint:`${t}`},getShaderSource:f,getRunData:()=>({outputs:[],dispatchGroup:{x:n}})},{inputs:[e],outputs:[]})},r2=(r,e,n,t,o,i)=>{let u=[o.batchSize,o.numHeads,o.sequenceLength,o.kvSequenceLength+o.pastSequenceLength],a=i.scale===0?1/Math.sqrt(o.headSize):i.scale,s=et(e.dataType),l=bt(o.headSize),d=W("q",e.dataType,e.dims,l),f=W("key",n.dataType,n.dims,l),p=te("output",e.dataType,u),g=o.headSize/l,b=o.sequenceLength,y=o.totalSequenceLength,_=g,x=12,S={x:Math.ceil(o.totalSequenceLength/x),y:Math.ceil(o.sequenceLength/x),z:o.batchSize*o.numHeads},O=[e,n],C=k=>`
  const M: u32 = ${b}u;
  const N: u32 = ${y}u;
  const K: u32 = ${_}u;
  const alpha: ${s} = ${a};
  const beta: ${s} = 1.0;
  const TILE_SIZE = ${x}u;

  var<workgroup> tileQ: array<${d.type.storage}, ${x*x}>;
  var<workgroup> tileK: array<${d.type.storage}, ${x*x}>;

  ${k.declareVariables(d,f,p)}

  @compute @workgroup_size(${x}, ${x}, 1)
  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,
   @builtin(local_invocation_id) local_id : vec3<u32>, @builtin(local_invocation_index) local_index : u32) {
   let global_idx = (workgroup_id.z * ${S.x*S.y}u +
          workgroup_id.y * ${S.x}u + workgroup_id.x) * ${x*x}u + local_index;

    // x holds the N and y holds the M
    let headIdx = workgroup_id.z;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let lm = m + local_id.y;
    let ln = n + local_id.x;

    let qOffset = ${o.sequenceLength*g} * headIdx + m * K;
    let kOffset = ${o.kvSequenceLength*g} * headIdx + n * K;

    var value = ${At(s,l)};
    for (var w: u32 = 0u; w < K; w += TILE_SIZE) {
      if (m + local_id.y < M && w + local_id.x < K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * K + w + local_id.x];
      }
      if (n + local_id.y < N && w + local_id.x < K) {
        tileK[TILE_SIZE * local_id.y + local_id.x] = key[kOffset + local_id.y * K + w + local_id.x];
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k<TILE_SIZE && w+k < K; k++) {
        value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k];
      }

      workgroupBarrier();
    }

    let headOffset = headIdx * M * N;
    if (lm < M && ln < N) {
      let outputIdx = headOffset + lm * N + ln;
      output[outputIdx] = ${zt("value",l)} * alpha;
    }
  }`,N=r.compute({name:"AttentionProbs",shaderCache:{hint:JSON.stringify(o)},getRunData:()=>({outputs:[{dims:u,dataType:e.dataType,gpuDataType:0}],dispatchGroup:S}),getShaderSource:C},{inputs:O,outputs:[-1]})[0];return t2(r,N,o.batchSize*o.numHeads*o.sequenceLength,o.totalSequenceLength),N},n2=(r,e,n,t)=>{let o=[t.batchSize,t.sequenceLength,t.vHiddenSize],i=W("probs",e.dataType,e.dims),u=W("v",n.dataType,n.dims),a=te("output",e.dataType,o),s=et(e.dataType),l=12,d={x:Math.ceil(t.vHeadSize/l),y:Math.ceil(t.sequenceLength/l),z:t.batchSize*t.numHeads},f=p=>`
  const M: u32 = ${t.sequenceLength}u;
  const N: u32 = ${t.vHeadSize}u;
  const K: u32 = ${t.totalSequenceLength}u;
  const numHeads: u32 = ${t.numHeads}u;
  const TILE_SIZE = ${l}u;

  var<workgroup> tileQ: array<${i.type.storage}, ${l*l}>;
  var<workgroup> tileK: array<${i.type.storage}, ${l*l}>;

  ${p.declareVariables(i,u,a)}

  @compute @workgroup_size(${l}, ${l}, 1)
  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,
   @builtin(local_invocation_id) local_id : vec3<u32>, @builtin(local_invocation_index) local_index : u32) {
   let global_idx = (workgroup_id.z * ${d.x*d.y}u +
          workgroup_id.y * ${d.x}u + workgroup_id.x) * ${l*l}u + local_index;

   let headIdx = workgroup_id.z;
   let m = workgroup_id.y * TILE_SIZE + local_id.y;
   let n = workgroup_id.x * TILE_SIZE + local_id.x;

   let offsetA = headIdx * (M * K) + m * K;
   let offsetB = headIdx * (N * K) + n;

   var value = ${s}(0);
   for (var w: u32 = 0u; w < K; w += TILE_SIZE) {
     if (m < M && w + local_id.x < K) {
       tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
     }
     if (n < N && w + local_id.y < K) {
       tileK[TILE_SIZE * local_id.y + local_id.x] = v[offsetB + (w + local_id.y) * N];
     }
     workgroupBarrier();
     for (var k: u32 = 0u; k<TILE_SIZE && w+k < K; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   let batchIdx = workgroup_id.z / ${t.numHeads};
   let currentBatchHeadNumber = workgroup_id.z % ${t.numHeads};
   let headOffset = (batchIdx * M * ${t.numHeads} + currentBatchHeadNumber) * ${t.vHeadSize};
   if (m < M && n < N) {
     let outputIdx = batchIdx * ${t.sequenceLength*t.vHiddenSize} + m * ${t.vHiddenSize}
       + currentBatchHeadNumber * ${t.vHeadSize} + n;
     output[outputIdx] = value;
   }
  }`;return r.compute({name:"AttentionScore",shaderCache:{hint:JSON.stringify(t)},getRunData:()=>({outputs:[{dims:o,dataType:e.dataType,gpuDataType:0}],dispatchGroup:d}),getShaderSource:f},{inputs:[e,n],outputs:[0]})[0]},Qi=(r,e,n,t,o,i,u,a,s,l,d)=>{let f=r2(r,e,n,s,l,d);n2(r,f,t,l)},o2=(r,e)=>{let n=[e.batchSize,e.numHeads,e.sequenceLength,e.headSize],t=et(r.inputs[0].dataType),o=e.sequenceLength,i=e.inputHiddenSize,u=e.headSize,a=12,s={x:Math.ceil(e.headSize/a),y:Math.ceil(e.sequenceLength/a),z:e.batchSize*e.numHeads},l=()=>`
  const M: u32 = ${o}u;
  const K: u32 = ${i}u;
  const N: u32 = ${u}u;
  const numHeads: u32 = ${e.numHeads};
  const ldb = ${e.hiddenSize+e.hiddenSize+e.vHiddenSize}u;
  const TILE_SIZE = ${a}u;

  var<workgroup> tileInput: array<${t}, ${a*a}>;
  var<workgroup> tileWeightQ: array<${t}, ${a*a}>;
  var<workgroup> tileWeightK: array<${t}, ${a*a}>;
  var<workgroup> tileWeightV: array<${t}, ${a*a}>;

  @group(0) @binding(0) var<storage, read> input: array<${t}>;
  @group(0) @binding(1) var<storage, read> weight: array<${t}>;
  @group(0) @binding(2) var<storage, read> bias: array<${t}>;
  @group(0) @binding(3) var<storage, read_write> outputQ: array<${t}>;
  @group(0) @binding(4) var<storage, read_write> outputK: array<${t}>;
  @group(0) @binding(5) var<storage, read_write> outputV: array<${t}>;

  @compute @workgroup_size(${a}, ${a}, 1)
  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,
   @builtin(local_invocation_id) local_id : vec3<u32>, @builtin(local_invocation_index) local_index : u32) {
   let global_idx = (workgroup_id.z * ${s.x*s.y}u +
          workgroup_id.y * ${s.x}u + workgroup_id.x) * ${a*a}u + local_index;

    let batchIndex = workgroup_id.z / ${e.numHeads};
    let headNumber = workgroup_id.z % ${e.numHeads};
    let m = workgroup_id.y * TILE_SIZE + local_id.y;
    let n = workgroup_id.x * TILE_SIZE + local_id.x;

    let inputOffset = batchIndex * (M * K) + m * K;
    let biasOffsetQ = headNumber * ${e.headSize};
    let biasOffsetK = ${e.hiddenSize} + biasOffsetQ;
    let biasOffsetV = ${e.hiddenSize} + biasOffsetK;

    var valueQ = ${t}(0);
    var valueK = ${t}(0);
    var valueV = ${t}(0);
    for (var w: u32 = 0u; w < K; w += TILE_SIZE) {
      if (m < M && w + local_id.x < K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < N && w + local_id.y < K) {
        let offset = n + (w + local_id.y) * ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * N + n) % ${e.headSize};
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * M * N;
    if (m < M && n < N) {
      let outputIdx = offset + m * N + n;
      outputQ[outputIdx] = valueQ;
      outputK[outputIdx] = valueK;
      outputV[outputIdx] = valueV;
    }
  }`,d=[r.inputs[0],r.inputs[1],r.inputs[2]];return r.compute({name:"AttentionPrepare",shaderCache:{hint:JSON.stringify(e)},getRunData:()=>({outputs:[{dims:n,dataType:r.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:r.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:r.inputs[0].dataType,gpuDataType:0}],dispatchGroup:s}),getShaderSource:l},{inputs:d,outputs:[-1,-1,-1]})},ym=(r,e)=>{let n=e2(r.inputs,e),[t,o,i]=o2(r,n);return Qi(r,t,o,i,r.inputs[4],void 0,void 0,void 0,r.inputs[5],n,e)}});var i2,a2,s2,vm,wm=R(()=>{"use strict";Bt();Re();ot();ke();i2=(r,e)=>{if(!r||r.length!==5)throw new Error("BatchNormalization requires 5 inputs");let n=(t,o,i)=>{let u=o.length;if(u!==t.length)throw new Error(`${i}: num dimensions != ${u}`);o.forEach((a,s)=>{if(a!==t[s])throw new Error(`${i}: dim[${s}] do not match`)})};if(r[0].dims.length>1){let t=e.format==="NHWC"?e.spatial?r[0].dims.slice(-1):r[0].dims.slice(-1).concat(r[0].dims.slice(1,r[0].dims.length-1)):r[0].dims.slice(1,e.spatial?2:void 0);n(r[1].dims,t,"Invalid input scale"),n(r[2].dims,t,"Invalid input B"),n(r[3].dims,t,"Invalid input mean"),n(r[4].dims,t,"Invalid input var")}else n(r[1].dims,[1],"Invalid input scale"),n(r[2].dims,[1],"Invalid input B"),n(r[3].dims,[1],"Invalid input mean"),n(r[4].dims,[1],"Invalid input var")},a2=(r,e)=>{let{epsilon:n,spatial:t,format:o}=e,i=r[0].dims,u=t?bt(i[i.length-1]):1,a=o==="NHWC"&&i.length>1?u:1,s=V.size(i)/u,l=tt(i.length)&&t,d=l?i.length:i,f=W("x",r[0].dataType,r[0].dims,u),p=W("scale",r[1].dataType,r[1].dims,a),g=W("bias",r[2].dataType,r[2].dims,a),b=W("inputMean",r[3].dataType,r[3].dims,a),y=W("inputVar",r[4].dataType,r[4].dims,a),_=te("y",r[0].dataType,d,u),x=()=>{let O="";if(t)O=`let cOffset = ${i.length===1?"0u":o==="NHWC"?`outputIndices[${i.length-1}] / ${u}`:"outputIndices[1]"};`;else if(o==="NCHW")O=`
            ${_.indicesSet("outputIndices","0","0")}
            let cOffset = ${_.indicesToOffset("outputIndices")};`;else{O=`var cIndices = ${p.type.indices}(0);
                       cIndices[0] = outputIndices[${i.length-1}];`;for(let C=1;C<p.rank;C++)O+=`cIndices[${C}] = outputIndices[${C}];`;O+=`let cOffset = ${p.indicesToOffset("cIndices")};`}return O},S=O=>`
  const epsilon = ${n};
  ${O.registerUniform("outputSize","u32").declareVariables(f,p,g,b,y,_)}
  ${O.mainStart()}
  ${O.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${_.offsetToIndices(`global_idx * ${u}`)};
    ${x()}
    let scale = ${p.getByOffset("cOffset")};
    let bias = ${g.getByOffset("cOffset")};
    let inputMean = ${b.getByOffset("cOffset")};
    let inputVar = ${y.getByOffset("cOffset")};
    let x = ${f.getByOffset("global_idx")};
    let value = (x - inputMean) / sqrt(inputVar + epsilon) * scale + bias;
    ${_.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${e.epsilon}_${e.format}_${t}_${u}`,inputDependencies:l?["rank","type","type","type","type"]:void 0},getShaderSource:S,getRunData:()=>({outputs:[{dims:r[0].dims,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:l?[{type:"uint32",data:s},...ee(i)]:[{type:"uint32",data:s}]})}},s2=r=>ge(r),vm=(r,e)=>{let{inputs:n,outputCount:t}=r,o=s2({...e,outputCount:t});if(xe.webgpu.validateInputContent&&i2(n,o),e.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");r.compute(a2(n,o))}});var u2,l2,xm,$m=R(()=>{"use strict";Re();ke();u2=r=>{if(r[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(r[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(r[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(r[0].dims[2]!==r[1].dims[0])throw new Error("last dimension of input and bias are not the same")},l2=r=>{let e=r[0].dims,n=r[0].dims[2],t=V.size(e)/4,o=r[0].dataType,i=W("input",o,e,4),u=W("bias",o,[n],4),a=W("residual",o,e,4),s=te("output",o,e,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:e,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(t/64)}}),getShaderSource:d=>`
  const channels = ${n}u / 4;
  ${d.declareVariables(i,u,a,s)}

  ${d.mainStart()}
    ${d.guardAgainstOutOfBoundsWorkgroupSizes(t)}
    let value = ${i.getByOffset("global_idx")}
      + ${u.getByOffset("global_idx % channels")} + ${a.getByOffset("global_idx")};
    ${s.setByOffset("global_idx","value")}
  }`}},xm=r=>{u2(r.inputs),r.compute(l2(r.inputs))}});var d2,Ke,Tm,_m,Sm,Im,Am,Om,Em,Cm,Pm,c2,km,Dm,Bm,Rm,ea,Mm,ta,Lm,zm,Nm,Fm,Vm,Gm,Um,Wm,Hm,qm,jm,Km,Ym,Xm,Zm,Jm,Qm,Zs=R(()=>{"use strict";ut();Re();ot();ke();d2=(r,e,n,t,o,i)=>{let u=Math.ceil(e/4),a="";typeof o=="string"?a=`${o}(a)`:a=o("a");let s=W("inputData",n,[u],4),l=te("outputData",t,[u],4);return`
      ${r.registerUniform("vec_size","u32").declareVariables(s,l)}

  ${i??""}

  ${r.mainStart()}
    ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${s.getByOffset("global_idx")};
    ${l.setByOffset("global_idx",a)}
  }`},Ke=(r,e,n,t,o,i=r.dataType)=>({name:e,shaderCache:{hint:o,inputDependencies:["type"]},getShaderSource:u=>d2(u,V.size(r.dims),r.dataType,i,n,t),getRunData:u=>({outputs:[{dims:r.dims,dataType:i}],dispatchGroup:{x:Math.ceil(V.size(u[0].dims)/64/4)},programUniforms:[{type:"uint32",data:Math.ceil(V.size(r.dims)/4)}]})}),Tm=r=>{r.compute(Ke(r.inputs[0],"Abs","abs"))},_m=r=>{r.compute(Ke(r.inputs[0],"Acos","acos"))},Sm=r=>{r.compute(Ke(r.inputs[0],"Acosh","acosh"))},Im=r=>{r.compute(Ke(r.inputs[0],"Asin","asin"))},Am=r=>{r.compute(Ke(r.inputs[0],"Asinh","asinh"))},Om=r=>{r.compute(Ke(r.inputs[0],"Atan","atan"))},Em=r=>{r.compute(Ke(r.inputs[0],"Atanh","atanh"))},Cm=r=>ge(r),Pm=(r,e)=>{let n;switch(e.to){case 10:n="vec4<f16>";break;case 1:n="vec4<f32>";break;case 12:n="vec4<u32>";break;case 6:n="vec4<i32>";break;case 9:n="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${e.to}`)}r.compute(Ke(r.inputs[0],"Cast",n,void 0,e.cacheKey,e.to))},c2=r=>{let e=r.length>=2&&r[1].data!==0?r[1].getFloat32Array()[0]:Ki,n=r.length>=3&&r[2].data!==0?r[2].getFloat32Array()[0]:Yi;return ge({min:e,max:n})},km=(r,e)=>{let n=r.inputs.length===1?e:c2(r.inputs),t=Fr(r.inputs[0].dataType);r.compute(Ke(r.inputs[0],"Clip",o=>`clamp(${o}, clip_min_, clip_max_)`,`
    const clip_min_: vec4<${t}> = vec4(${t}(${n.min}));
    const clip_max_: vec4<${t}> = vec4(${t}(${n.max}));
`,n.cacheKey),{inputs:[0]})},Dm=r=>{r.compute(Ke(r.inputs[0],"Ceil","ceil"))},Bm=r=>{r.compute(Ke(r.inputs[0],"Cos","cos"))},Rm=r=>{r.compute(Ke(r.inputs[0],"Cosh","cosh"))},ea=r=>ge(r),Mm=(r,e)=>{let n=Fr(r.inputs[0].dataType);r.compute(Ke(r.inputs[0],"Elu",t=>`elu_vf32(${t})`,`
  const elu_alpha_ = ${n}(${e.alpha});

  fn elu_f32(a: ${n}) -> ${n} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${n}>) -> vec4<${n}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,e.cacheKey))},ta=(r,e="f32")=>`
const r0: ${e} = 0.3275911;
const r1: ${e} = 0.254829592;
const r2: ${e} = -0.284496736;
const r3: ${e} = 1.421413741;
const r4: ${e} = -1.453152027;
const r5: ${e} = 1.061405429;

fn erf_vf32(v: ${r}) -> ${r} {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,Lm=r=>{let e=Fr(r.inputs[0].dataType);r.compute(Ke(r.inputs[0],"Erf",n=>`erf_vf32(${n})`,ta(`vec4<${e}>`,e)))},zm=r=>{r.compute(Ke(r.inputs[0],"Exp","exp"))},Nm=r=>{r.compute(Ke(r.inputs[0],"Floor","floor"))},Fm=r=>{let e=Fr(r.inputs[0].dataType);r.compute(Ke(r.inputs[0],"Gelu",n=>`0.5 * ${n} * (1.0 + erf_vf32(${n} * 0.7071067811865475))`,ta(`vec4<${e}>`,e)))},Vm=(r,e)=>{let n=Fr(r.inputs[0].dataType);r.compute(Ke(r.inputs[0],"LeakyRelu",t=>`select(leaky_relu_alpha_ * ${t}, ${t}, ${t} >= vec4<${n}>(0.0))`,`const leaky_relu_alpha_ = ${n}(${e.alpha});`,e.cacheKey))},Gm=r=>{r.compute(Ke(r.inputs[0],"Not",e=>`!${e}`))},Um=r=>{r.compute(Ke(r.inputs[0],"Neg",e=>`-${e}`))},Wm=r=>{r.compute(Ke(r.inputs[0],"Reciprocal",e=>`1.0/${e}`))},Hm=r=>{let e=Fr(r.inputs[0].dataType);r.compute(Ke(r.inputs[0],"Relu",n=>`select(vec4<${e}>(0.0), ${n}, ${n} > vec4<${e}>(0.0))`))},qm=r=>{r.compute(Ke(r.inputs[0],"Sigmoid",e=>`(1.0 / (1.0 + exp(-${e})))`))},jm=r=>{r.compute(Ke(r.inputs[0],"Sin","sin"))},Km=r=>{r.compute(Ke(r.inputs[0],"Sinh","sinh"))},Ym=r=>{r.compute(Ke(r.inputs[0],"Sqrt","sqrt"))},Xm=r=>{r.compute(Ke(r.inputs[0],"Tan","tan"))},Zm=r=>{r.compute(Ke(r.inputs[0],"Tanh","tanh"))},Jm=(r,e)=>{let n=Fr(r.inputs[0].dataType);return r.compute(Ke(r.inputs[0],"ThresholdedRelu",t=>`select(vec4<${n}>(0.0), ${t}, ${t} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${n}>(${e.alpha});`,e.cacheKey)),0},Qm=r=>{r.compute(Ke(r.inputs[0],"Log","log"))}});var p2,h2,eg,tg=R(()=>{"use strict";Re();ke();Zs();p2=r=>{if(r[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(r[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(r[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(r[0].dims[2]!==r[1].dims[0])throw new Error("last dimension of input and bias are not the same")},h2=r=>{let e=r[0].dims.slice();e[2]=e[2]/2;let n=W("input",r[0].dataType,r[0].dims,4),t=W("bias",r[0].dataType,[r[0].dims[2]],4),o=te("output",r[0].dataType,e,4),i=V.size(e)/4,u=et(r[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:e,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:s=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${r[0].dims[2]/4/2}u;

  ${s.declareVariables(n,t,o)}

  ${ta(`vec4<${u}>`,u)}

  ${s.mainStart()}
    ${s.guardAgainstOutOfBoundsWorkgroupSizes(i)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${o.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},eg=r=>{p2(r.inputs),r.compute(h2(r.inputs))}});var m2,g2,vr,rg,ng,og,ig,ag,sg,ug,lg,dg,cg,fg=R(()=>{"use strict";ut();Re();ke();m2=(r,e,n,t,o,i,u,a,s,l,d,f,p)=>{let g,b;typeof a=="string"?g=b=(k,U)=>`${a}((${k}),(${U}))`:typeof a=="function"?g=b=a:(g=a.scalar,b=a.vector);let y=f?e.length:e,_=f?n.length:n,x=f?t.length:t,S=te("outputData",d,x,4),O=W("aData",s,y,4),C=W("bData",l,_,4),N;if(o)if(i){let k=V.size(e)===1,U=V.size(n)===1,G=e.length>0&&e[e.length-1]%4===0,H=n.length>0&&n[n.length-1]%4===0;k||U?N=S.setByOffset("global_idx",b(k?`${O.type.value}(${O.getByOffset("0")}.x)`:O.getByOffset("global_idx"),U?`${C.type.value}(${C.getByOffset("0")}.x)`:C.getByOffset("global_idx"))):N=`
            let outputIndices = ${S.offsetToIndices("global_idx * 4u")};
            let offsetA = ${O.broadcastedIndicesToOffset("outputIndices",S)};
            let offsetB = ${C.broadcastedIndicesToOffset("outputIndices",S)};
            ${S.setByOffset("global_idx",b(u||G?O.getByOffset("offsetA / 4u"):`${O.type.value}(${O.getByOffset("offsetA / 4u")}[offsetA % 4u])`,u||H?C.getByOffset("offsetB / 4u"):`${C.type.value}(${C.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else N=S.setByOffset("global_idx",b(O.getByOffset("global_idx"),C.getByOffset("global_idx")));else{if(!i)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let k=(U,G,H="")=>{let ne=`aData[indexA${G}][componentA${G}]`,P=`bData[indexB${G}][componentB${G}]`;return`
            let outputIndices${G} = ${S.offsetToIndices(`global_idx * 4u + ${G}u`)};
            let offsetA${G} = ${O.broadcastedIndicesToOffset(`outputIndices${G}`,S)};
            let offsetB${G} = ${C.broadcastedIndicesToOffset(`outputIndices${G}`,S)};
            let indexA${G} = offsetA${G} / 4u;
            let indexB${G} = offsetB${G} / 4u;
            let componentA${G} = offsetA${G} % 4u;
            let componentB${G} = offsetB${G} % 4u;
            ${U}[${G}] = ${H}(${g(ne,P)});
          `};d===9?N=`
            var data = vec4<u32>(0);
            ${k("data",0,"u32")}
            ${k("data",1,"u32")}
            ${k("data",2,"u32")}
            ${k("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:N=`
            ${k("outputData[global_idx]",0)}
            ${k("outputData[global_idx]",1)}
            ${k("outputData[global_idx]",2)}
            ${k("outputData[global_idx]",3)}
          `}return`
        ${r.registerUniform("vec_size","u32").declareVariables(O,C,S)}

        ${p??""}

        ${r.mainStart()}
        ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${N}
      }`},g2=(r,e,n,t,o,i,u=n.dataType)=>{let a=!V.areEqual(n.dims,t.dims),s=n.dims,l=V.size(n.dims),d=!1,f=!1,p=[a];if(a){let b=hr.calcShape(n.dims,t.dims,!1);if(!b)throw new Error("Can't perform binary op on the given tensors");s=b,l=V.size(s);let y=V.size(n.dims)===1,_=V.size(t.dims)===1,x=n.dims.length>0&&n.dims[n.dims.length-1]%4===0,S=t.dims.length>0&&t.dims[t.dims.length-1]%4===0;p.push(y),p.push(_),p.push(x),p.push(S);let O=1;for(let C=1;C<s.length;C++){let N=n.dims[n.dims.length-C]??1,k=t.dims[t.dims.length-C]??1;if(N===k)O*=N;else break}O%4===0?(f=!0,d=!0):(y||_||x||S)&&(d=!0)}else d=!0;p.push(d);let g=tt(n.dims.length)&&tt(t.dims.length)&&tt(s.length);return{name:r,shaderCache:{hint:e+p.map(b=>b.toString()).join("_"),inputDependencies:g?["rank","rank"]:["dims","dims"]},getShaderSource:b=>m2(b,n.dims,t.dims,s,d,a,f,o,n.dataType,t.dataType,u,g,i),getRunData:()=>({outputs:[{dims:s,dataType:u}],dispatchGroup:{x:Math.ceil(l/64/4)},programUniforms:g?[{type:"uint32",data:Math.ceil(V.size(s)/4)},...ee(n.dims),...ee(t.dims),...ee(s)]:[{type:"uint32",data:Math.ceil(V.size(s)/4)}]})}},vr=(r,e,n,t,o,i)=>{r.compute(g2(e,o??"",r.inputs[0],r.inputs[1],n,t,i))},rg=r=>{vr(r,"Add",(e,n)=>`${e}+${n}`)},ng=r=>{vr(r,"Div",(e,n)=>`${e}/${n}`)},og=r=>{vr(r,"Equal",{scalar:(e,n)=>`u32(${e}==${n})`,vector:(e,n)=>`vec4<u32>(${e}==${n})`},void 0,void 0,9)},ig=r=>{vr(r,"Mul",(e,n)=>`${e}*${n}`)},ag=r=>{let e=W("input",r.inputs[0].dataType,r.inputs[0].dims).type.value;vr(r,"Pow",{scalar:(t,o)=>`pow_custom(${t},${o})`,vector:(t,o)=>`pow_vector_custom(${t},${o})`},`
    fn pow_custom(a : ${e}, b : ${e}) -> ${e} {
      if (b == ${e}(0.0)) {
        return ${e}(1.0);
      } else if (a < ${e}(0.0) && f32(b) != floor(f32(b))) {
        return ${e}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${e}(1.0), round(f32(abs(b) % ${e}(2.0))) != 1.0) * ${e}(${e==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${e}>, b : vec4<${e}>) -> vec4<${e}> {
      // TODO: implement vectorized pow
      return vec4<${e}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},sg=r=>{vr(r,"Sub",(e,n)=>`${e}-${n}`)},ug=r=>{vr(r,"Greater",{scalar:(e,n)=>`u32(${e}>${n})`,vector:(e,n)=>`vec4<u32>(${e}>${n})`},void 0,void 0,9)},lg=r=>{vr(r,"Less",{scalar:(e,n)=>`u32(${e}<${n})`,vector:(e,n)=>`vec4<u32>(${e}<${n})`},void 0,void 0,9)},dg=r=>{vr(r,"GreaterOrEqual",{scalar:(e,n)=>`u32(${e}>=${n})`,vector:(e,n)=>`vec4<u32>(${e}>=${n})`},void 0,void 0,9)},cg=r=>{vr(r,"LessOrEqual",{scalar:(e,n)=>`u32(${e}<=${n})`,vector:(e,n)=>`vec4<u32>(${e}<=${n})`},void 0,void 0,9)}});var y2,v2,w2,x2,pg,hg,mg=R(()=>{"use strict";Re();ot();ke();y2=r=>{if(!r||r.length<1)throw new Error("too few inputs");let e=r[0].dataType,n=r[0].dims.length;for(let t of r){if(t.dataType!==e)throw new Error("input tensors should be one type");if(t.dims.length!==n)throw new Error("input tensors should have the same shape")}},v2=(r,e)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${r}u>(${e});
    for (var i: u32 = 0u; i < ${r}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${r}u;
  }`,w2=(r,e)=>{let n=r.length,t=[];for(let o=0;o<n;++o){let i=e.setByOffset("global_idx",r[o].getByIndices("indices"));n===1?t.push(i):o===0?t.push(`if (inputIndex == ${o}u) { ${i} }`):o===n-1?t.push(`else { ${i} }`):t.push(`else if (inputIndex == ${o}) { ${i} }`)}return t.join(`
`)},x2=(r,e)=>{let n=r[0].dims.slice();if(e>=n.length||e<-1*n.length)throw new Error("axis specified for concat doesn't match input dimensionality");let t=e<0?n.length+e:e,o=n.slice(0);for(let C=1;C<r.length;C++){let N=r[C].dims.slice();for(let k=0;k<n.length;k++)if(k===t)o[t]+=N[k];else if(n[k]!==N[k])throw new Error("non concat dimensions must match")}let i=V.size(o),u=new Array(r.length),a=new Array(r.length),s=r[0].dataType,l=0,d=[],f=[],p=[],g=[{type:"uint32",data:i}];for(let C=0;C<r.length;++C)l+=r[C].dims[t],u[C]=l,p.push(tt(r[C].dims.length)),f.push(p[C]?r[C].dims.length:r[C].dims),a[C]=W(`input${C}`,s,f[C]),d.push(p[C]?"rank":"dims"),g.push({type:"uint32",data:u[C]});for(let C=0;C<r.length;++C)p[C]&&g.push(...ee(r[C].dims));let b=tt(o.length);b&&g.push(...ee(o));let y=b?o.length:o,_=te("output",s,y),x=_.indicesGet("indices",t),S=Array.from(Array(u.length).keys()).map(C=>`uniforms.sizeInConcatAxis${C}`).join(","),O=C=>`

  ${(()=>{C.registerUniform("outputSize","u32");for(let N=0;N<r.length;N++)C.registerUniform(`sizeInConcatAxis${N}`,"u32");return C.declareVariables(...a,_)})()}

  ${v2(u.length,S)}

  ${C.mainStart()}
    ${C.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${_.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${x});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${u.length}u>(${S});
      ${x} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${w2(a,_)}
  }`;return{name:"Concat",shaderCache:{hint:`${e}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:o,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:g}),getShaderSource:O}},pg=(r,e)=>{y2(r.inputs),r.compute(x2(r.inputs,e.axis))},hg=r=>ge({axis:r.axis})});var wr,ra,Vr=R(()=>{"use strict";Re();wr=(r,e)=>{switch(r.activation){case"Relu":return{activationFunction:"",applyActivation:`value = max(value, ${e}(0.0));`};case"Sigmoid":return{activationFunction:"",applyActivation:`value = (${e}(1.0) / (${e}(1.0) + exp(-value)));`};case"Clip":return{activationFunction:`const clip_min_=${e}(${r.clipMin});const clip_max_=${e}(${r.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},ra=r=>{let e=r?.activation||"";if(e==="Clip"){let[n,t]=r?.activation_params||[Ki,Yi];return{activation:e,clipMax:t,clipMin:n,activationCacheKey:`${e}:${n},${t}`}}return{activation:e,activationCacheKey:e}}});var $t,na,oa=R(()=>{"use strict";$t=(r,e)=>{switch(r){case 1:return e;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${r}-component is not supported.`)}},na=r=>`
      ${r?"value = value + getBiasByOutputCoords(coords);":""}
      `});var ia,Js=R(()=>{"use strict";ia=r=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${r}.x), i32(${r}.y), i32(${r}.z), 1));
}
`});var $2,T2,wo,gg,_2,xo,S2,aa,$o=R(()=>{"use strict";Re();ke();Vr();oa();$2=(r,e)=>r?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${e?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${e?", batchIndices":""});
        `,T2=(r,e)=>r?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${e===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,wo=(r,e,n="f32",t,o=!1,i=32,u=!1,a=32)=>{let s=e[1]*r[1],l=e[0]*r[0],d=o?s:i,f=o?i:s,p=d/e[0],g=i/e[1];if(!((o&&p===4&&r[1]===4||!o&&(p===3||p===4))&&d%e[0]===0&&i%e[1]===0&&r[0]===4))throw new Error(`If transposeA ${o} is true, innerElementSize ${p} and workPerThread[1] ${r[1]} must be 4.
      Otherwise, innerElementSize ${p} must be 3 or 4.
  tileAWidth ${d} must be divisible by workgroupSize[0]${e[0]}. tileInner ${i} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${r[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${p}<${n}>, ${d/p}>, ${f}>;
var<workgroup> mm_Bsub: array<array<vec4<${n}>, ${l/r[0]}>, ${i}>;

const rowPerThread = ${r[1]};
const colPerThread = ${r[0]};
const innerElementSize = ${p};
const tileInner = ${i};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${u?"0":"i32(globalId.z)"};
  ${t?`let batchIndices = ${t.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${s};

  let numTiles = ${u?`${Math.ceil(a/i)}`:"(uniforms.dimInner - 1) / tileInner + 1"};
  var kStart = ${u?`i32(globalId.z) * ${a}`:"0"};

  var acc: array<vec4<${n}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${g};
  for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${$2(o,t)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${g}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${t?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${p===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${T2(o,p)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},gg=(r,e)=>r?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${e?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${e?", batchIndices":""});
            `,_2=r=>r?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",xo=(r,e,n="f32",t,o=!1,i=32,u=!1,a=32,s=!1)=>{let l=r[1]*e[1],d=r[0]*e[0],f=o?l:i,p=o?i:l;if(!(p%e[1]===0&&f%e[0]===0&&i%e[1]===0))throw new Error(`tileAHight ${p} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${f} must be divisible by workgroupSize[0]${e[0]}, tileInner ${i} must be divisible by workgroupSize[1]${e[1]}`);let g=p/e[1],b=f/e[0],y=i/e[1],_=s?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${l};
    let globalColStart = i32(workgroupId.x) * ${d};

    // Loop over shared dimension.
    for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${p}; inputRow = inputRow + ${e[1]}) {
        for (var inputCol = localCol; inputCol < ${f}; inputCol = inputCol + ${e[0]}) {
          ${gg(o,t)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${i}; inputRow = inputRow + ${e[1]}) {
            for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${e[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${t?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${n}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${o?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${e[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${e[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${l};

let tileRowA = i32(localId.y) * ${g};
let tileColA = i32(localId.x) * ${b};
let tileRowB = i32(localId.y) * ${y};
// Loop over shared dimension.
for (var t = 0; t < numTiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${g}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${b}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${gg(o,t)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${y}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${t?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${n}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${_2(o)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${n}, ${f}>, ${p}>;
  var<workgroup> mm_Bsub : array<array<${n}, ${d}>, ${i}>;
  const rowPerThread = ${r[1]};
  const colPerThread = ${r[0]};
  const tileInner = ${i};

@compute @workgroup_size(${e[0]}, ${e[1]}, ${e[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${u?"0":"i32(globalId.z)"};
    ${t?`let batchIndices = ${t.offsetToIndices("u32(batch)")};`:""}
    let numTiles = ${u?`${Math.ceil(a/i)}`:"(uniforms.dimInner - 1) / tileInner + 1"};
    var kStart = ${u?`i32(globalId.z) * ${a}`:"0"};

    var acc : array<array<${n}, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${_}
  }
`},S2=(r,e,n,t,o,i=!1)=>{let[u,a,s]=o,[l,d,f,p]=t,g=Dn(u,s),b=Dn(a,s),y=et(t[0].type.tensor),_=()=>{let O=d.rank,C=l.rank,N=`var aIndices: ${d.type.indices};`;for(let k=O-2-1,U=C-1;k>=0;k--,U--)N+=`
aIndices[${k}] = ${C>1?`batchIndices[${U}]`:"batchIndices"};`;return g.forEach(k=>{N+=`
aIndices[${k}] = 0;`}),N+=`
aIndices[${O-2}] = u32(row);
                   aIndices[${O-1}] = u32(colIn);`,N},x=()=>{let O=f.rank,C=l.rank,N=`var bIndices: ${f.type.indices};`;for(let k=O-2-1,U=C-1;k>=0;k--,U--)N+=`
bIndices[${k}] = ${C>1?`batchIndices[${U}]`:"batchIndices"};`;return b.forEach(k=>{N+=`
bIndices[${k}] = 0;`}),N+=`
bIndices[${O-2}] = u32(row);
                   bIndices[${O-1}] = u32(colIn);`,N};return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${l.type.indices}) -> ${$t(r,y)} {
      var value = ${$t(r,y)}(0.0);
      let col = colIn * ${r};
      if(row < uniforms.dimAOuter && col < uniforms.dimInner)
      {
        ${_()}
        value = ${d.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${l.type.indices}) -> ${$t(r,y)} {
      var value = ${$t(r,y)}(0.0);
      let col = colIn * ${r};
      if(row < uniforms.dimInner && col < uniforms.dimBOuter)
      {
        ${x()}
        value = ${f.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${$t(r,y)}) {
      let col = colIn * ${r};
      if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${e?`value = value + ${i?"bias[colIn]":`${$t(r,y)}(bias[row])`};`:""}
        ${n}
        ${p.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},aa=(r,e,n,t,o=!1)=>{let i=r[0].dims,u=r[1].dims,a=i.slice(0,-2),s=u.slice(0,-2),l=t?t.slice(0,-2):n.slice(0,-2),d=tt(l.length),f=d?l.length:l,p=Xi("batchDims",r[0].dataType,f,1),g=V.size(l),b=i[i.length-2],y=i[i.length-1],_=u[u.length-1],x=y%4===0&&_%4===0,S=b<=8?[4,1,1]:[4,4,1],O=[8,8,1],C=[Math.ceil(_/O[0]/S[0]),Math.ceil(b/O[1]/S[1]),Math.ceil(g/O[2]/S[2])],N=et(r[0].dataType),k=x?4:1,U=[...a,b,y/k],G=tt(U.length),H=G?U.length:U,ne=[...s,y,_/k],P=tt(ne.length),J=P?ne.length:ne,Te=[g,b,_/k],ae=W("a",r[0].dataType,H,k),De=W("b",r[1].dataType,J,k),re=te("result",r[0].dataType,Te.length,k),Ce=[ae,De],Ne=[{type:"int32",data:b},{type:"int32",data:_},{type:"int32",data:y}];d&&Ne.push(...ee(l)),G&&Ne.push(...ee(U)),P&&Ne.push(...ee(ne));let Se=[];Se.push(G?"rank":"dims"),Se.push(P?"rank":"dims");let $e=r.length>2,{activationFunction:ht,applyActivation:it}=wr(e,re.type.value),yt=S2(k,$e,it,[p,ae,De,re],[a,s,l],o);if($e){let fe=o?k:1;Ce.push(W("bias",r[2].dataType,r[2].dims.length,fe)),Ne.push(...ee(r[2].dims)),Se.push("rank")}Ne.push(...ee(Te));let K=fe=>`
  ${fe.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").registerInternalVariables(p).declareVariables(...Ce,re)}
  ${ht}
  ${yt}
  ${x?wo(S,O,N,p):xo(S,O,N,p)}
                   `;return{name:"MatMul",shaderCache:{hint:e.activationCacheKey+`${S}${x}${o}`,inputDependencies:Se},getRunData:()=>({outputs:[{dims:n,dataType:r[0].dataType}],dispatchGroup:{x:C[0],y:C[1],z:C[2]},programUniforms:Ne}),getShaderSource:K}}});var I2,bg,yg=R(()=>{"use strict";Nr();ke();Vr();oa();Js();$o();I2=(r,e,n,t,o=!1,i,u=4,a=4,s=4,l="f32")=>{let d=P=>{switch(P){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${l}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${P} is not supported.`)}},f=P=>{switch(P){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${P} is not supported.`)}},p=r?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,g=r?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,b=r?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",y=r?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",_=r?"row":"col",x=r?"col":"row",S=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${r?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${_} / outWidth;
    let outCol = ${_} % outWidth;

    let WRow = ${x} / (filterDims[1] * inChannels);
    let WCol = ${x} / inChannels % filterDims[1];
    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];
    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];
    let xCh = ${x} % inChannels;
    var resData = ${$t(u,l)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${b} && xCol >= 0 && xCol < ${y}) {
      ${p}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${d(u)}
    }
    return resData;`,O=r?e&&t?`
    let col = colIn * ${u};
    ${S}`:`
    let col = colIn * ${u};
    if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
      ${S}
    }
    return ${$t(u,l)}(0.0);`:t&&n?`
    let col = colIn * ${u};
    ${S}`:`
    let col = colIn * ${u};
    if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
      ${S}
    }
    return ${$t(u,l)}(0.0);`,C=`${f(a)}`,N=$t(s,l),k=r?$t(u,l):$t(a,l),U=r?$t(a,l):$t(u,l),{activationFunction:G,applyActivation:H}=wr(i,N);return`
    ${G}
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${k} {
      ${r?O:C}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${U} {
      ${r?C:O}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${N}) {
      let col = colIn * ${s};
      if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
      {
      var value = valueIn;
      let outWidth = ${r?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${g}
      ${na(o)}
      ${H}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},bg=(r,e,n,t,o,i,u,a)=>{let s=e.format==="NHWC",l=s?r[0].dims[3]:r[0].dims[1],d=n[0],f=s?n[2]:n[3],p=s?n[1]:n[2],g=s?n[3]:n[1],b=s&&(l%4===0||l%3===0)&&g%4===0,y=s?g:f*p,_=s?f*p:g,x=[8,8,1],S=t<=8?[4,1,1]:[4,4,1],O=[Math.ceil(y/x[0]/S[0]),Math.ceil(_/x[1]/S[1]),Math.ceil(d/x[2]/S[2])];nt("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${O}`);let C=b?s&&l%4!==0?3:4:1,N=x[1]*S[1],k=x[0]*S[0],U=Math.max(x[0]*C,x[1]),G=t%N===0,H=o%k===0,ne=i%U===0,P=b?[C,4,4]:[1,1,1],J=et(r[0].dataType),Te=b?4:1,ae=[{type:"int32",data:t},{type:"int32",data:o},{type:"int32",data:i}],De=W("x",r[0].dataType,r[0].dims.length,C===3?1:C),re=W("w",r[1].dataType,r[1].dims.length,Te),Ce=[De,re];ae.push(...ee(r[0].dims)),ae.push(...ee(r[1].dims));let Ne=`
      fn setOutputAtIndex(flatIndex : i32, value : ${b?`vec4<${J}>`:J}) {
        result[flatIndex] = ${b?`vec4<${J}>`:J}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${b?`vec4<${J}>`:J}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${b?"/ 4":""}, value);
      }`;if(u){let $e=W("bias",r[2].dataType,r[2].dims.length,Te);Ce.push($e),ae.push(...ee(r[2].dims)),Ne+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${b?`vec4<${J}>`:J} {
          return bias[coords.${s?"w":"y"}${b?"/ 4":""}];
        }`}let Se=te("result",r[0].dataType,n.length,Te);return ae.push(...ee(n)),{name:"Conv2DMatMul",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:n,dataType:r[0].dataType}],dispatchGroup:{x:O[0],y:O[1],z:O[2]},programUniforms:ae}),getShaderSource:$e=>`
        ${ia("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${$e.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").declareVariables(...Ce,Se)}
        const filterDims : vec2<i32> = vec2<i32>(${e.kernelShape[0]}, ${e.kernelShape[1]});
        const pad : vec2<i32> = vec2<i32>(${e.pads[0]}, ${e.pads[1]});
        const stride : vec2<i32> = vec2<i32>(${e.strides[0]}, ${e.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${e.dilations[0]}, ${e.dilations[1]});
        ${Ne}
        ${I2(s,G,H,ne,u,e,P[0],P[1],P[2],J)}
            ${b?wo(S,x,J,void 0,!s,U):xo(S,x,J,void 0,!s,U,!1,void 0,a)}`}}});var Qs,vg=R(()=>{"use strict";Re();ke();tu();Vr();Qs=(r,e,n)=>{let t=r.length>2,o=t?"value += b[output_channel];":"",i=r[0].dims,u=r[1].dims,a=u[0]/e.group,s=e.format==="NHWC",l=eu(i,u,e.dilations,e.pads,e.strides,s),d=V.size(l),f=te("output",r[0].dataType,l),{activationFunction:p,applyActivation:g}=wr(e,f.type.value),b=W("x",r[0].dataType,i),y=W("w",r[1].dataType,u),_=[b,y];t&&_.push(W("b",r[2].dataType,r[2].dims));let x=S=>`
  const strides: vec2<u32> = vec2(${e.strides[0]}u, ${e.strides[1]}u);
  const pads: vec2<u32> = vec2(${e.pads[0]}u, ${e.pads[1]}u);

  ${S.declareVariables(..._,f)}

  ${p}

  ${S.mainStart()}
    ${S.guardAgainstOutOfBoundsWorkgroupSizes(d)}

    let outputIndices = ${f.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${s?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${s?1:2}], outputIndices[${s?2:3}]) * strides - pads;
    let group_id: u32 = output_channel / ${a}u;

    var value: ${f.type.value} = ${f.type.value}(0);
    for (var wInChannel: u32 = 0u; wInChannel < ${u[1]}u; wInChannel++) {
      let input_channel = group_id * ${u[1]}u + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < ${u[2]}u; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * ${e.dilations[0]}u;

        if (xHeight < 0u || xHeight >= ${i[s?1:2]}u) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < ${u[3]}u; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * ${e.dilations[1]}u;
          if (xWidth < 0u || xWidth >= ${i[s?2:3]}u) {
            continue;
          }

          let xVal = ${s?b.get("batch","xHeight","xWidth","input_channel"):b.get("batch","input_channel","xHeight","xWidth")};
          let wVal = ${y.get("output_channel","wInChannel","wHeight","wWidth")};
          value += xVal*wVal;
        }
      }
    }
    ${o}
    ${g}
    ${f.setByOffset("global_idx","value")}
  }`;return{name:"GroupedConv",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:n?n(l):l,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)}}),getShaderSource:x}}});var ru,A2,wg,nu=R(()=>{"use strict";Re();$o();ke();Vr();ru=(r,e,n,t,o=!1)=>{let i=r[0].dims,u=r[1].dims,a=i[i.length-2],s=u[u.length-1],l=i[i.length-1],d=bt(s),f=bt(l),p=bt(a),g=V.size(n)/d/p,b=r.length>2,y=t?t.slice(0,-2):n.slice(0,-2),x=[V.size(y),a,s],S=[{type:"uint32",data:g},{type:"uint32",data:a},{type:"uint32",data:s},{type:"uint32",data:l},...ee(y),...ee(i),...ee(u)];b&&S.push(...ee(r[2].dims)),S.push(...ee(x));let O=C=>{let N=Xi("batch_dims",r[0].dataType,y.length),k=W("a",r[0].dataType,i.length,f),U=W("b",r[1].dataType,u.length,d),G=te("output",r[0].dataType,x.length,d),{activationFunction:H,applyActivation:ne}=wr(e,G.type.value),P=[k,U],J="";if(b){let Se=o?d:1;P.push(W("bias",r[2].dataType,r[2].dims.length,Se)),J=`${o?`value += bias[col / ${Se}];`:`value += ${G.type.value}(bias[row + i]);`}`}let Te=i.slice(0,-2),ae=u.slice(0,-2),De=Dn(Te,y),re=Dn(ae,y),Ce=(Se,$e)=>{let ht=Se.rank,it=Se.name;if(ht===2)return`var ${it}_indices = ${Se.type.indices}(0u, 0u);`;let yt=N.rank,K=`var ${it}_indices: ${Se.type.indices};`;for(let fe=ht-2-1,Ae=yt-1;fe>=0;fe--,Ae--)K+=`
${it}_indices[${fe}] = ${yt>1?`batch_indices[${Ae}]`:"batch_indices"};`;return $e.forEach(fe=>{K+=`
${it}_indices[${fe}] = 0;`}),K+=`${it}_indices[${ht-2}] = 0u;
                     ${it}_indices[${ht-1}] = 0u;`,K},Ne=()=>{let Se=`var a_data: ${k.type.value};`;for(let $e=0;$e<f;$e++)Se+=`
              let b_data${$e} = b[(b_offset + (k + ${$e}) * uniforms.N + col) / ${d}];`;for(let $e=0;$e<p;$e++){Se+=`a_data = a[(a_offset + (row + ${$e}) * uniforms.K + k) / ${f}];`;for(let ht=0;ht<f;ht++)Se+=`
            values[${$e}] = fma(${U.type.value}(a_data${f===1?"":`[${ht}]`}), b_data${ht}, values[${$e}]);
`}return Se};return`
  ${C.registerUniform("outputSize","u32").registerUniform("M","u32").registerUniform("N","u32").registerUniform("K","u32").registerInternalVariables(N).declareVariables(...P,G)}
  ${H}
  ${C.mainStart()}
    ${C.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    let col = (global_idx % (uniforms.N / ${d})) * ${d};
    var index1 = global_idx / (uniforms.N / ${d});
    let stride1 = uniforms.M / ${p};
    let row = (index1 % stride1) * ${p};
    let batch = index1 / stride1;

    ${n.length===2?"":`let batch_indices = ${N.offsetToIndices("batch")};`}
    ${Ce(k,De)}
    let a_offset = ${k.indicesToOffset("a_indices")};
    ${Ce(U,re)}
    let b_offset = ${U.indicesToOffset("b_indices")};
    var values: array<${G.type.value}, ${p}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${f}) {
      ${Ne()}
    }
    for (var i = 0u; i < ${p}u; i++) {
      var value = values[i];
      ${J}
      ${ne}
      let cur_indices = ${G.type.indices}(batch, row + i, col);
      let offset = ${G.indicesToOffset("cur_indices")};
      ${G.setByOffset(`offset / ${d}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${e.activationCacheKey}_${d}_${f}_${p}_${o}`,inputDependencies:b?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:n,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:S}),getShaderSource:O}},A2=r=>{if(!r||r.length!==2)throw new Error("MatMul requires 2 inputs.");if(r[0].dims[r[0].dims.length-1]!==r[1].dims[r[1].dims.length-2])throw new Error("shared dimension does not match.")},wg=r=>{A2(r.inputs);let e=hr.calcShape(r.inputs[0].dims,r.inputs[1].dims,!0);if(!e)throw new Error("Can't use matmul on the given tensors");let n=e[e.length-1],t=r.inputs[0].dims[r.inputs[0].dims.length-1];n<8&&t<8?r.compute(ru(r.inputs,{activation:"",activationCacheKey:""},e)):r.compute(aa(r.inputs,{activation:"",activationCacheKey:""},e))}});var eu,xg,O2,$g,ou,E2,C2,iu,tu=R(()=>{"use strict";Re();ot();yg();$o();vg();Vr();nu();Bn();eu=(r,e,n,t,o,i)=>{let u=r[0],a=r.slice(i?1:2,i?3:4),s=a.length,l=e[0],f=e.slice(2).map((b,y)=>b+(b-1)*(n[y]-1)),g=a.map((b,y)=>b+t[y]+t[y+s]).map((b,y)=>Math.floor((b-f[y]+o[y])/o[y]));return g.splice(0,0,u),g.splice(i?3:1,0,l),g},xg=[2,3,1,0],O2=(r,e)=>{if(!r||r.length!==2&&r.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(r[0].dims.length!==4&&r[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(r[0].dims.length!==r[1].dims.length)throw new Error("filter does not have same dimension as input");let n=r[0].dims[e.format==="NHWC"?r[0].dims.length-1:1],t=r[1].dims[1]*e.group;if(n!==t)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(r.length===3&&(r[2].dims.length!==1||r[1].dims[0]!==r[2].dims[0]))throw new Error("invalid bias");let o=r[0].dims.length-2;if(e.dilations.length!==o)throw new Error(`dilations should be ${o}D`);if(e.strides.length!==o)throw new Error(`strides should be ${o}D`);if(e.pads.length!==o*2)throw new Error(`pads should be ${o*2}D`);if(e.kernelShape.length!==0&&e.kernelShape.length!==r[1].dims.length-2)throw new Error("invalid kernel shape")},$g=(r,e)=>{let n=r.kernelShape.slice();for(let i=2;i<e[1].dims.length;++i)n[i-2]===0&&(n[i-2]=e[1].dims[i]);let t=r.pads.slice();dn.adjustPadsBasedOnAutoPad(e[0].dims,r.strides,r.dilations,n,t,r.format==="NHWC",r.autoPad);let o=Object.assign({},r);return Object.assign(o,{kernelShape:n,pads:t,cacheKey:r.cacheKey}),o},ou=r=>{let e=ra(r),n=r.format,t=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][r.auto_pad],o=r.dilations,i=r.group,u=r.kernel_shape,a=r.pads,s=r.strides,l=r.w_is_const();return ge({autoPad:t,format:n,dilations:o,group:i,kernelShape:u,pads:a,strides:s,wIsConst:l,...e})},E2=(r,e,n)=>{let t=$g(n,e);if(n.group!==1){r.compute(Qs(e,t));return}let o=n.format==="NHWC",i=e.length===3,u=e[0].dims[o?1:2],a=e[0].dims[o?2:3],s=e[0].dims[o?3:1],l=e[1].dims[2],d=e[1].dims[3],f=eu(e[0].dims,e[1].dims,n.dilations,t.pads,n.strides,o),p=f[o?1:2],g=f[o?2:3],b=f[o?3:1],y=o&&l===u&&d===a&&n.pads[0]===0&&n.pads[1]===0;if(y||l===1&&d===1&&n.dilations[0]===1&&n.dilations[1]===1&&n.strides[0]===1&&n.strides[1]===1&&n.pads[0]===0&&n.pads[1]===0){let k=f[0],U,G,H,ne=[];if(o){let Te=r.kernelCustomData.wT??r.compute(nr(e[1],xg),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];if(n.wIsConst&&!r.kernelCustomData.wT&&(r.kernelCustomData.wT=Te),y){let ae=u*a*s;U=e[0].reshape([1,k,ae]),G=Te.reshape([1,ae,b]),H=[1,k,b]}else U=e[0].reshape([k,u*a,s]),G=Te.reshape([1,s,b]),H=[k,p*g,b];ne.push(U),ne.push(G)}else U=e[0].reshape([k,s,u*a]),G=e[1].reshape([1,b,s]),H=[k,b,p*g],ne.push(G),ne.push(U);i&&ne.push(e[2]);let P=H[2],J=ne[0].dims[ne[0].dims.length-1];P<8&&J<8?r.compute(ru(ne,t,f,H,o),{inputs:ne}):r.compute(aa(ne,t,f,H,o),{inputs:ne});return}let _=!0,x=r.kernelCustomData.wT??r.compute(nr(e[1],xg),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!r.kernelCustomData.wT&&(r.kernelCustomData.wT=x);let S=[e[0],x];i&&S.push(e[2]);let O=o?p*g:b,C=o?b:p*g,N=l*d*s;r.compute(bg(S,t,f,O,C,N,i,_),{inputs:S})},C2=(r,e)=>{let n=e.format==="NHWC",t=[r.inputs[0].reshape(n?[r.inputs[0].dims[0],1,r.inputs[0].dims[1],r.inputs[0].dims[2]]:[r.inputs[0].dims[0],r.inputs[0].dims[1],1,r.inputs[0].dims[2]]),r.inputs[1].reshape([r.inputs[1].dims[0],r.inputs[1].dims[1],1,r.inputs[1].dims[2]])];r.inputs.length===3&&t.push(r.inputs[2]);let o=[0,e.pads[0],0,e.pads[1]],i=[1].concat(e.strides),u=[1].concat(e.dilations),a=[1].concat(e.kernelShape),s=$g({...e,pads:o,strides:i,dilations:u,kernelShape:a},t);r.compute(Qs(t,s,l=>n?[l[0],l[2],l[3]]:[]))},iu=(r,e)=>{O2(r.inputs,e),r.inputs[0].dims.length===3?C2(r,e):E2(r,r.inputs,e)}});var P2,Tg,_g=R(()=>{"use strict";Nr();ke();Vr();oa();Js();$o();P2=(r,e=!1,n,t=4)=>{let o=$t(t,"f32"),i=S=>{switch(S){case 1:return"return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];
            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];
            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];
            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${S} is not supported.`)}},u=r?`
      let coord = vec4<i32>(batch, iXR, iXC, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, iXR, iXC);
      `,a=r?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,s=r?"outBackprop[1]":"outBackprop[2]",l=r?"outBackprop[2]":"outBackprop[3]",d=r?"row":"col",f=r?"col":"row",p=`
      let inChannels = ${r?"outBackprop[3]":"outBackprop[1]"};
      let outWidth = ${r?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      let outRow = ${d} / outWidth;
      let outCol = ${d} % outWidth;

      let WRow = ${f} / (filterDims[1] * inChannels);
      let WCol = ${f} / inChannels % filterDims[1];
      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);
      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);
      if (xR < 0.0 || xR >= f32(${s}) || fract(xR) > 0.0) {
        return ${o}(0.0);
      }
      if (xC < 0.0 || xC >= f32(${l}) || fract(xC) > 0.0) {
        return ${o}(0.0);
      }
      let iXR = i32(xR);
      let iXC = i32(xC);
      let xCh = ${f} % inChannels;
      ${u}
      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${t}];`,g=r?`
      let col = colIn * ${t};
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${p}
      }
      return ${o}(0.0);`:`
      let col = colIn * ${t};
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${p}
      }
      return ${o}(0.0);`,b=`
      let col = colIn * ${t};
      let inChannels = ${r?"outBackprop[3]":"outBackprop[1]"};
      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);
      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];
      if (${r?"row < uniforms.dimInner && col < uniforms.dimBOuter":"row < uniforms.dimInner && col < uniforms.dimAOuter"}  && coordX >= 0 && coordY >= 0) {
        let rowInner = row % inChannels;
        let coord = vec4<i32>(coordX, coordY, col, rowInner);
        ${i(t)}
      }
      return ${o}(0.0);
      `,{activationFunction:y,applyActivation:_}=wr(n,o);return`
      ${y}
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${o} {
    ${r?g:b}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${o} {
    ${r?b:g}
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${o}) {
    let col = colIn * ${t};
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outWidth = ${r?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${a}
      ${na(e)}
      ${_}
      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${t}] = value;
    }
  }`},Tg=(r,e,n,t,o,i,u,a)=>{let s=e.format==="NHWC",l=s?r[0].dims[3]:r[0].dims[1],d=n[0],f=s?n[2]:n[3],p=s?n[1]:n[2],g=s?n[3]:n[1],b=s?l%4===0&&g%4===0:f%4===0&&g%4===0,y=s?g:f*p,_=s?f*p:g,x=b?[8,8,1]:[y<=4||_<=4?4:16,y>4&&_<=4?4:16,1],S=b?[4,4,1]:[y<=4?1:4,y>4&&_<=4?1:4,1],O=[Math.ceil(y/x[0]/S[0]),Math.ceil(_/x[1]/S[1]),Math.ceil(d/x[2]/S[2])];nt("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${O}`);let C=b?4:1,N=Math.max(x[0]*C,x[1]),k=b?4:1,U=[{type:"int32",data:t},{type:"int32",data:o},{type:"int32",data:i}],G=W("x",r[0].dataType,r[0].dims.length,k),H=W("w",r[1].dataType,r[1].dims.length,1),ne=te("result",r[0].dataType,n.length,k),P=[G,H];U.push(...ee(r[0].dims)),U.push(...ee(r[1].dims));let J="";if(u){let Te=W("bias",r[2].dataType,r[2].dims.length,k);P.push(Te),U.push(...ee(r[2].dims)),J+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${b?"vec4<f32>":"f32"} {
          return bias[coords.${s?"w":"y"}${b?"/ 4":""}];
        }`}return U.push(...ee(n)),{name:"Conv2DTransposeMatMul",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:n,dataType:r[0].dataType}],dispatchGroup:{x:O[0],y:O[1],z:O[2]},programUniforms:U}),getShaderSource:Te=>`
        ${ia("uniforms.result_strides")}
        ${Te.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").declareVariables(...P,ne)};
        const outBackprop : vec4<i32> = vec4<i32>(${r[0].dims.join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${e.kernelShape[s?1:2]}, ${e.kernelShape[s?2:3]});
        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(
              ${e.dilations[0]<=1?0:(e.kernelShape[s?1:2]-1)*(e.dilations[0]-1)},
              ${e.dilations[1]<=1?0:(e.kernelShape[s?2:3]-1)*(e.dilations[1]-1)});
        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${e.pads[0]+e.pads[2]})/2,
                                         i32(effectiveFilterDims[1]) - 1 - (${e.pads[1]+e.pads[3]})/2);
        const strides : vec2<i32> = vec2<i32>(${e.strides[0]}, ${e.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${e.dilations[0]}, ${e.dilations[1]});
        const dimAOuter : i32 = ${t};
        const dimBOuter : i32 = ${o};
        const dimInner : i32 = ${i};
        ${J}
        ${P2(s,u,e,C)}
        ${b?wo(S,x,"f32",void 0,!s,N):xo(S,x,"f32",void 0,!s,N,!1,void 0,a)}`}}});var k2,au,Sg=R(()=>{"use strict";Nr();Re();ke();k2=(r,e,n,t,o,i,u=!1,a)=>{let s=n.format==="NHWC",l=s?1:2,d=s?2:3,f=s?3:1,p=V.size(t),g=u?2:1,b=n.group,y=e[1].dims,_=y[0]/b,x=y[1],S=`
  fn setOutputAtIndex(flatIndex : u32, value : ${u?`vec4<${a}>`:a}) {
    result[flatIndex] = ${u?`vec4<${a}>`:a}(value);
  }`;o&&(S+=`
    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${u?`vec4<${a}>`:a} {
      return bias[coords.${s?"w":"y"}${u?"/ 4":""}];
    }`);let O=u?4:1,C=W("W",e[1].dataType,e[1].dims,O),N=W("Dy",e[0].dataType,e[0].dims,O),k=[N,C];o&&k.push(W("bias",e[2].dataType,[t[f]],O));let U=te("result",e[0].dataType,t,O),G=`{
        let batch: u32 = ${i?"global_id.z":"workgroup_id.z"} / outShape[1];
        let r = ${i?"global_id.z":"workgroup_id.z"} % outShape[1];
        let c = ${i?"global_id.y":"workgroup_id.y"} * ${g};
        let d1: u32 = ${i?"global_id.x":"workgroup_id.x"} * 4;

        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd: array<vec4<${a}>, ${g}>;
        for (var i = 0; i < ${g}; i++) {
          dotProd[i] = vec4<${a}>(0.0);
        }
        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {
          var dyR = (${a}(dyCorner.x) + ${a}(wR)) / ${a}(strides.x);
          let wRPerm = filterDims[0] - 1 - wR;
          if (dyR < 0.0 || dyR >= ${a}(outBackprop[1]) ||
              fract(dyR) > 0.0 || wRPerm < 0) {
            continue;
          }
          let idyR: u32 = u32(dyR);

          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {
            let dyC = (${a}(dyCorner.y) + ${a}(wC)) / ${a}(strides.y);
            let dyC2 = (${a}(dyCorner.y) + 1.0 + ${a}(wC)) / ${a}(strides.y);
            let wCPerm = filterDims[1] - 1 - wC;
            if (wCPerm < 0) {
              continue;
            }
            var bDyCVal = true;
            var bDyCVal2 = true;
            if (dyC < 0.0 || dyC >= ${a}(outBackprop[2]) ||
                fract(dyC) > 0.0) {
              bDyCVal = false;
            }
            if (dyC2 < 0.0 || dyC2 >= ${a}(outBackprop[2]) ||
                fract(dyC2) > 0.0) {
              bDyCVal2 = false;
            }

            let idyC: u32 = u32(dyC);
            let idyC2: u32 = u32(dyC2);
            if (bDyCVal && bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${C.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${C.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${C.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${C.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${N.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${a}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;

                xValue =  ${N.get("batch","idyR","idyC2","d2")};

                dotProd[1] = dotProd[1] + vec4<${a}>(dot(xValue, wValue0),
                                                    dot(xValue, wValue1),
                                                    dot(xValue, wValue2),
                                                    dot(xValue, wValue3));
              }
            } else if (bDyCVal) {
              let d2Length = outBackprop[${f}];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${C.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${C.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${C.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${C.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${N.get("batch","idyR","idyC","d2")};
                let tmpval = vec4<${a}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[0] = dotProd[0] + tmpval;
              }
            } else if (bDyCVal2) {
              let d2Length = outBackprop[3];
              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {
                let wValue0 = ${C.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};
                let wValue1 = ${C.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};
                let wValue2 = ${C.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};
                let wValue3 = ${C.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};

                var xValue = ${N.get("batch","idyR","idyC2","d2")};
                let tmpval = vec4<${a}>(dot(xValue, wValue0),
                                      dot(xValue, wValue1),
                                      dot(xValue, wValue2),
                                      dot(xValue, wValue3));
                dotProd[1] = dotProd[1] + tmpval;
              }
            }
          }
        }

        for (var i: u32 = 0; i < ${g}; i = i + 1) {
          let value = dotProd[i] + ${o?"bias[c+i]":"0.0"};
          ${U.set("batch","r","c + i","d1","value")};
        }
      }`,H=`
          let outputIndices = ${U.offsetToIndices("global_idx")};
          let batch = ${U.indicesGet("outputIndices",0)};
          let d1 = ${U.indicesGet("outputIndices",f)};
          let r = ${U.indicesGet("outputIndices",l)};
          let c = ${U.indicesGet("outputIndices",d)};
          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;
          let dyRCorner = dyCorner.x;
          let dyCCorner = dyCorner.y;
          let groupId = d1 / ${x};
          let wOutChannel = d1 - groupId * ${x};
          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
          // ? = to be determined. : = across all values in that axis.
          var dotProd = 0.0;
          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {
            if (wR % dilations.x != 0) {
              continue;
            }
            let dyR = (${a}(dyRCorner) + ${a}(wR)) / ${a}(strides[0]);
            let wRPerm = filterDims.x - 1 - wR / dilations.x;
            if (dyR < 0.0 || dyR >= ${a}(outBackprop[${l}]) || fract(dyR) > 0.0 ||
                wRPerm < 0) {
              continue;
            }
            let idyR: u32 = u32(dyR);

            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {
              if (wC % dilations.y != 0) {
                continue;
              }
              let dyC = (${a}(dyCCorner) + ${a}(wC)) / ${a}(strides.y);
              let wCPerm = filterDims.y - 1 - wC / dilations.y;
              if (dyC < 0.0 || dyC >= ${a}(outBackprop[${d}]) ||
                  fract(dyC) > 0.0 || wCPerm < 0) {
                continue;
              }
              let idyC: u32 = u32(dyC);
              var inputChannel = groupId * ${_};
              for (var d2: u32 = 0; d2 < ${_}; d2 = d2 + 1) {
                let xValue = ${s?N.get("batch","idyR","idyC","inputChannel"):N.get("batch","inputChannel","idyR","idyC")};
                let wValue = ${C.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};
                dotProd = dotProd + xValue * wValue;
                inputChannel = inputChannel + 1;
              }
            }
          }
          let value = dotProd + ${o?"bias[d1]":"0.0"};
          ${U.setByOffset("global_idx","value")};
        `;return`
  ${r.declareVariables(...k,U)}
  ${S}
  const outShape : vec4<u32> = vec4<u32>(${t.join(",")});
  const outBackprop : vec4<u32> = vec4<u32>(${e[0].dims.join(",")});
  const strides : vec2<u32> = vec2<u32>(${n.strides[0]}, ${n.strides[1]});
  const filterDims : vec2<u32> = vec2<u32>(${n.kernelShape[s?1:2]}, ${n.kernelShape[s?2:3]});
  const dilations : vec2<u32> = vec2<u32>(${n.dilations[0]}, ${n.dilations[1]});
  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(
          ${n.dilations[0]<=1?0:(n.kernelShape[s?1:2]-1)*(n.dilations[0]-1)},
          ${n.dilations[1]<=1?0:(n.kernelShape[s?2:3]-1)*(n.dilations[1]-1)});
  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${n.pads[0]+n.pads[2]})/2,
                                     i32(effectiveFilterDims[1]) - 1 - (${n.pads[1]+n.pads[3]})/2);
    ${r.mainStart()}
    ${r.guardAgainstOutOfBoundsWorkgroupSizes(p)};
  ${u?G:H}}`},au=(r,e,n)=>{let t=r.length>2,o=e.outputShape,i=V.size(o),u=[Math.ceil(i/64),1,1];nt("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${u}`);let a=et(r[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:e.cacheKey},getRunData:()=>({dispatchGroup:{x:u[0],y:u[1],z:u[2]},outputs:[{dims:n?n(o):o,dataType:r[0].dataType}]}),getShaderSource:s=>k2(s,r,e,o,t,u[1]===1&&u[2]===1,!1,a)}}});var D2,B2,R2,Ig,Ag,M2,L2,z2,N2,Og,Eg=R(()=>{"use strict";ot();_g();Sg();Vr();Bn();D2=(r,e,n,t,o,i)=>(r-1)*e+n+(t-1)*o+1-i,B2=(r,e,n,t,o)=>{let i=Math.floor(r/2);e==="SAME_UPPER"?(n[t]=i,n[o]=r-i):e==="SAME_LOWER"&&(n[t]=r-i,n[o]=i)},R2=(r,e,n,t,o,i,u,a,s,l)=>{let d=r.length-2,f=l.length===0;if(s.length===0)for(let b=0;b<d;++b)s.push(0);let p=r[0],g=e[a?3:1]*o;for(let b=0,y=r.length-d-(a?1:0);b<d;++b,++y){let _=r[y],x=f?_*u[b]:l[b],S=D2(_,u[b],i[b],e[y],n[b],x);B2(S,t,i,b,b+d),f&&l.push(u[b]*(_-1)+s[b]+(e[y]-1)*n[b]+1-i[b]-i[b+d])}l.splice(0,0,p),l.splice(a?3:1,0,g)},Ig=(r,e)=>{let n=r.kernelShape.slice();if(r.kernelShape.length===0||r.kernelShape.reduce((p,g)=>p*g,1)===0){n.length=0;for(let p=2;p<e[1].dims.length;++p)n.push(e[1].dims[p])}let t=r.format==="NHWC";n.splice(0,0,e[1].dims[0]),n.splice(t?3:1,0,e[1].dims[1]);let o=r.pads.slice(),i=r.outputShape.slice(),u=r.outputPadding.slice(),a=e[0].dims,s=r.dilations.slice();if(s.reduce((p,g)=>p+g,0)===0){let p=e[0].dims.length-2;s=new Array(p).fill(1)}let l=r.strides.slice();if(l.reduce((p,g)=>p+g,0)===0){let p=e[0].dims.length-2;l=new Array(p).fill(1)}R2(a,n,s,r.autoPad,r.group,o,l,t,u,i);let d=Object.assign({},r),f=r.cacheKey+[n.join("n,"),o.join(","),l.join(","),u.join(","),i.join(","),s.join(",")].join("_");return Object.assign(d,{kernelShape:n,pads:o,outputPadding:u,outputShape:i,dilations:s,strides:l,cacheKey:f}),d},Ag=r=>{let e=ra(r),n=r.format,t=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof r.autoPad>"u"?0:r.autoPad],o=r.dilations,i=r.group,u=r.kernelShape,a=r.pads,s=r.strides,l=r.wIsConst(),d=r.outputPadding,f=r.outputShape;return ge({autoPad:t,format:n,dilations:o,group:i,kernelShape:u,outputPadding:d,outputShape:f,pads:a,strides:s,wIsConst:l,...e})},M2=(r,e)=>{if(!r||r.length!==2&&r.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(r[0].dims.length!==4&&r[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(r[0].dims.length!==r[1].dims.length)throw new Error("filter does not have same dimension as input");let n=r[0].dims[e.format==="NHWC"?r[0].dims.length-1:1],t=r[1].dims[0];if(n!==t)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let o=r[1].dims[1]*e.group;if(r.length===3&&(r[2].dims.length!==1||r[2].dims[0]!==o))throw new Error("invalid bias");let i=r[0].dims.length-2;if(e.dilations.reduce((d,f)=>d+f,0)>0&&e.dilations.length!==i)throw new Error(`dilations should be ${i}D`);if(e.strides.reduce((d,f)=>d+f,0)>0&&e.strides.length!==i)throw new Error(`strides should be ${i}D`);if(e.pads.reduce((d,f)=>d+f,0)>0&&e.pads.length!==i*2)throw new Error(`pads should be ${i*2}D`);if(e.outputPadding.length!==i&&e.outputPadding.length!==0)throw new Error(`output_padding should be ${i}D`);if(e.kernelShape.reduce((d,f)=>d+f,0)>0&&e.kernelShape.length!==0&&e.kernelShape.length!==r[1].dims.length-2)throw new Error("invalid kernel shape");if(e.outputShape.length!==0&&e.outputShape.length!==r[0].dims.length-2)throw new Error("invalid output shape")},L2=[2,3,1,0],z2=(r,e,n)=>{let t=Ig(n,e),o=n.format==="NHWC",i=t.outputShape,u=i[o?3:1],a=e[0].dims[o?3:1];if(t.group!==1||u===1&&a===1){r.compute(au(e,t));return}let s=i[o?1:2],l=i[o?2:3],d=e[1].dims[2],f=e[1].dims[3],p=o?s*l:u,g=o?u:s*l,b=d*f*a,y=!0,_=r.kernelCustomData.wT??r.compute(nr(e[1],L2),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!r.kernelCustomData.wT&&(r.kernelCustomData.wT=_);let x=[e[0],_],S=e.length===3;S&&(!o&&e[2].dims.length===1?x.push(e[2].reshape([e[2].dims[0],1,1])):x.push(e[2])),r.compute(Tg(x,t,i,p,g,b,S,y),{inputs:x})},N2=(r,e)=>{let n=e.format==="NHWC",t=[r.inputs[0].reshape(n?[r.inputs[0].dims[0],1,r.inputs[0].dims[1],r.inputs[0].dims[2]]:[r.inputs[0].dims[0],r.inputs[0].dims[1],1,r.inputs[0].dims[2]]),r.inputs[1].reshape([r.inputs[1].dims[0],r.inputs[1].dims[1],1,r.inputs[1].dims[2]])];t.length===3&&t.push(r.inputs[2]);let o=e.kernelShape;(o.length===0||o[0]===0)&&(o=[r.inputs[1].dims[2]]);let i=e.dilations;(i.length===0||i[0]===0)&&(i=[1]);let u=e.strides;(u.length===0||u[0]===0)&&(u=[1]);let a=e.pads;a.length===0&&(a=[0,0]),a=[0,a[0],0,a[1]],u=[1].concat(u),i=[1].concat(i),o=[1].concat(o);let s=Ig({...e,pads:a,strides:u,dilations:i,kernelShape:o},t);r.compute(au(t,s,l=>n?[l[0],l[2],l[3]]:[l[0],l[1],l[3]]))},Og=(r,e)=>{M2(r.inputs,e),r.inputs[0].dims.length===3?N2(r,e):z2(r,r.inputs,e)}});var F2,Cg,Pg,kg=R(()=>{"use strict";ut();Re();ot();ke();F2=(r,e,n,t)=>{let o=V.size(e),i=e.length,u=W("input",r,i),a=te("output",r,i),s=n.dataType===6?n.getInt32Array()[0]:Number(n.getBigInt64Array()[0]),l=V.normalizeAxis(s,i),d=f=>{let p=` i32(${u.indicesGet("inputIndices","uniforms.axis")}) `,g=qe("uniforms.input_shape","uniforms.axis",i),b=t.reverse?p+(t.exclusive?" + 1":""):"0",y=t.reverse?g:p+(t.exclusive?"":" + 1");return`
                ${f.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(u,a)}
                ${f.mainStart()}
                  ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${a.offsetToIndices("global_idx")};
                  var sum = ${a.type.value}(0);
                  let first : i32 = ${b};
                  let last : i32 = ${y};
                  for (var i : i32 = first; i < last; i++) {
                    ${u.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${u.getByIndices("inputIndices")};
                  }
                  ${a.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:t.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:e,dataType:r}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:[{type:"uint32",data:o},{type:"int32",data:l},...ee(e),...ee(e)]}),getShaderSource:d}},Cg=(r,e)=>{let n=r.inputs[0].dims,t=r.inputs[0].dataType,o=r.inputs[1];r.compute(F2(t,n,o,e),{inputs:[0]})},Pg=r=>{let e=r.exclusive===1,n=r.reverse===1;return ge({exclusive:e,reverse:n})}});var su,sa,Dg,V2,G2,uu,lu,Bg,U2,Rg,Mg,Lg=R(()=>{"use strict";Re();ot();ke();su="[a-zA-Z]|\\.\\.\\.",sa="("+su+")+",Dg="^"+sa+"$",V2="("+sa+",)*"+sa,G2="^"+V2+"$",uu=class{constructor(e=-1){this.symbolToIndices=new Map,this.inputIndex=e}addSymbol(e,n){let t=this.symbolToIndices.get(e);t===void 0?t=[n]:t.push(n),this.symbolToIndices.set(e,t)}},lu=class{constructor(e,n){this.equation=n;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[t,o]=n.includes("->")?n.split("->",2):[n,""];if(!t.match(RegExp(G2)))throw new Error("Invalid LHS term");if(t.split(",").forEach((a,s)=>{let l=e[s].dims.slice();if(!a.match(RegExp(Dg)))throw new Error("Invalid LHS term");let d=this.processTerm(a,!0,l,s);this.lhs.push(d)}),o==="")o+=[...this.symbolToInfo.entries()].filter(([a,s])=>s.count===1||a==="...").map(([a])=>a).join("");else if(!o.match(RegExp(sa)))throw new Error("Invalid RHS");o.match(RegExp(su,"g"))?.forEach(a=>{if(a==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let s=this.symbolToInfo.get(a);if(s===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(s.dimValue)}}),this.rhs=this.processTerm(o,!1,this.outputDims)}addSymbol(e,n,t){let o=this.symbolToInfo.get(e);if(o!==void 0){if(o.dimValue!==n&&o.count!==1)throw new Error("Dimension mismatch");o.count++,o.inputIndices.push(t)}else o={count:1,dimValue:n,inputIndices:[t]};this.symbolToInfo.set(e,o)}processTerm(e,n,t,o=-1){let i=t.length,u=!1,a=[],s=0;if(!e.match(RegExp(Dg))&&!n&&e!=="")throw new Error("Invalid LHS term");let l=e.match(RegExp(su,"g")),d=new uu(o);return l?.forEach((f,p)=>{if(f==="..."){if(u)throw new Error("Only one ellipsis is allowed per input term");u=!0;let g=i-l.length+1;if(g<0)throw new Error("Ellipsis out of bounds");if(a=t.slice(s,s+g),this.hasEllipsis){if(this.ellipsisDims.length!==a.length||this.ellipsisDims.toString()!==a.toString())throw new Error("Ellipsis dimensions mismatch")}else if(n)this.hasEllipsis=!0,this.ellipsisDims=a;else throw new Error("Ellipsis must be specified in the LHS");for(let b=0;b<a.length;b++){let y=String.fromCharCode("0".charCodeAt(0)+b);d.addSymbol(y,p+b),this.addSymbol(y,t[s++],o)}}else d.addSymbol(f,p+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(f,t[s++],o)}),d}},Bg=r=>r+"_max",U2=(r,e,n,t,o)=>{let u=e.map((g,b)=>r[b]?g.length:g).map((g,b)=>W(`input${b}`,n,g)),a=V.size(o),s=tt(o.length),l=s?o.length:o,d=te("output",n,l),f=[...t.symbolToInfo.keys()].filter(g=>!t.rhs.symbolToIndices.has(g)),p=g=>{let b=[],y="var prod = 1.0;",_="var sum = 0.0;",x="sum += prod;",S=[],O=[],C=[],N=[],k=t.symbolToInfo.size===t.rhs.symbolToIndices.size;t.symbolToInfo.forEach((G,H)=>{if(t.rhs.symbolToIndices.has(H)){let ne=t.rhs.symbolToIndices.get(H)?.[0];ne!==void 0&&t.lhs.forEach((P,J)=>{if(G.inputIndices.includes(J)){let Te=P.symbolToIndices.get(H);if(Te===void 0)throw new Error("Invalid symbol error");Te.forEach(ae=>{b.push(`${u[J].indicesSet(`input${J}Indices`,ae,d.indicesGet("outputIndices",ne))}`)})}})}else t.lhs.forEach((ne,P)=>{if(G.inputIndices.includes(P)){let J=ne.symbolToIndices.get(H);if(J===void 0)throw new Error("Invalid symbol error");J.forEach(Te=>{S.push(`${u[P].indicesSet(`input${P}Indices`,Te,`${H}`)}`)}),N.push(`prod *= ${u[P].getByIndices(`input${P}Indices`)};`)}}),O.push(`for(var ${H}: u32 = 0; ${H} < uniforms.${Bg(H)}; ${H}++) {`),C.push("}")});let U=k?[...b,`let sum = ${u.map((G,H)=>G.getByIndices(`input${H}Indices`)).join(" * ")};`]:[...b,_,...O,...S,y,...N,x,...C];return`
            ${g.registerUniforms(f.map(G=>({name:`${Bg(G)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...u,d)}

            ${g.mainStart()}
            ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${d.offsetToIndices("global_idx")};
            ${u.map((G,H)=>`var input${H}Indices: ${u[H].type.indices};`).join(`
`)}
            ${U.join(`
`)};
            ${d.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:t.equation,inputDependencies:r.map(g=>g?"rank":"dims")},getRunData:()=>{let g=f.filter(y=>t.symbolToInfo.has(y)).map(y=>({type:"uint32",data:t.symbolToInfo.get(y)?.dimValue||0}));g.push({type:"uint32",data:a});let b=e.filter((y,_)=>r[_]).map((y,_)=>[...ee(y)]).reduce((y,_)=>y.concat(_),g);return s&&b.push(...ee(o)),{outputs:[{dims:o,dataType:n}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:b}},getShaderSource:p}},Rg=(r,e)=>{let n=new lu(r.inputs,e.equation),t=r.inputs.map((u,a)=>tt(u.dims.length)),o=n.outputDims,i=r.inputs.map((u,a)=>u.dims);r.compute(U2(t,i,r.inputs[0].dataType,n,o))},Mg=r=>{let e=r.equation.replace(/\s+/g,"");return ge({equation:e})}});var W2,zg,H2,q2,Ng,Fg=R(()=>{"use strict";ut();Re();ke();W2=r=>{if(!r||r.length!==2)throw new Error("Expand requires 2 input.");let e=r[0].dims,n=Array.from(r[1].getBigInt64Array(),Number),t=n.length<e.length?0:n.length-e.length,o=e.length<n.length?0:e.length-n.length;for(;t<n.length&&o<e.length;++t,++o)if(n[t]!==e[o]&&n[t]!==1&&e[o]!==1)throw new Error("Expand requires shape to be broadcastable to input")},zg=(r,e)=>{let n=r.length-e.length,t=[];for(let o=0;o<n;++o)t.push(r[o]);for(let o=0;o<e.length;++o)t.push(e[o]===1?r[o+n]:e[o]);return t},H2=(r,e)=>r.length>e.length?zg(r,e):zg(e,r),q2=r=>{let e=r[0].dims,n=Array.from(r[1].getBigInt64Array(),Number),t=H2(e,n),o=r[0].dataType,i=o===9?4:1,u=V.size(t)/i,a=tt(e.length),s=tt(t.length),l=f=>{let p=a?e.length:e,g=s?t.length:t,b=W("input",o,p,i),y=te("output",o,g,i),_;if(o===9){let x=(S,O,C="")=>`
          let outputIndices${O} = ${y.offsetToIndices(`outputOffset + ${O}u`)};
          let offset${O} = ${b.broadcastedIndicesToOffset(`outputIndices${O}`,y)};
          let index${O} = offset${O} / 4u;
          let component${O} = offset${O} % 4u;
          ${S}[${O}] = ${C}(${b.getByOffset(`index${O}`)}[component${O}]);
        `;_=`
        let outputOffset = global_idx * ${i};
        var data = vec4<u32>(0);
        ${x("data",0,"u32")}
        ${x("data",1,"u32")}
        ${x("data",2,"u32")}
        ${x("data",3,"u32")}
        ${y.setByOffset("global_idx","data")}
      }`}else _=`
        let outputIndices = ${y.offsetToIndices("global_idx")};
        let inputOffset = ${b.broadcastedIndicesToOffset("outputIndices",y)};
        ${y.setByOffset("global_idx",b.getByOffset("inputOffset"))}
      }`;return`
    ${f.registerUniform("vec_size","u32").declareVariables(b,y)}
    ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${_}`},d=[{type:"uint32",data:u}];return a&&d.push(...ee(e)),s&&d.push(...ee(t)),{name:"Expand",shaderCache:{hint:`${t.length}`,inputDependencies:[a?"rank":"dims"]},getShaderSource:l,getRunData:()=>({outputs:[{dims:t,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:d})}},Ng=r=>{W2(r.inputs),r.compute(q2(r.inputs),{inputs:[0]})}});var j2,K2,Vg,Gg,Ug=R(()=>{"use strict";ut();Re();ot();ke();j2=r=>{if(!r||r.length!==2)throw new Error("Gather requires 2 inputs.")},K2=(r,e)=>{let n=r[0].dims,t=r[1].dims,o=n.length,i=V.normalizeAxis(e.axis,o),u=n.slice(0);u.splice(i,1,...t);let a=n[i],s=r[0].dataType===9?4:1,l=V.size(u)/s,d=tt(r[0].dims.length),f=d?r[0].dims.length:r[0].dims,p=tt(r[1].dims.length),g=p?r[1].dims.length:r[1].dims,b=tt(u.length),y=b?u.length:u,_=[{type:"uint32",data:l},{type:"int32",data:a},{type:"uint32",data:i}];d&&_.push(...ee(r[0].dims)),p&&_.push(...ee(r[1].dims)),b&&_.push(...ee(u));let x=[];x.push(d?"rank":"dims"),x.push(p?"rank":"dims");let S=O=>{let C=W("data",r[0].dataType,f,s),N=W("inputIndices",r[1].dataType,g),k=te("output",r[0].dataType,y,s),U=H=>{let ne=t.length,P=`var indicesIndices${H}  = ${N.type.indices}(0);`;for(let J=0;J<ne;J++)P+=`${ne>1?`indicesIndices${H}[${J}]`:`indicesIndices${H}`} = ${u.length>1?`outputIndices${H}[uniforms.axis + ${J}]`:`outputIndices${H}`};`;P+=`
          var idx${H} = ${N.getByIndices(`indicesIndices${H}`)};
          if (idx${H} < 0) {
            idx${H} = idx${H} + uniforms.axisDimLimit;
          }
          var dataIndices${H} = ${C.type.indices}(0);
        `;for(let J=0,Te=0;J<o;J++)J===i?(P+=`${o>1?`dataIndices${H}[${J}]`:`dataIndices${H}`} = u32(idx${H});`,Te+=ne):(P+=`${o>1?`dataIndices${H}[${J}]`:`dataIndices${H}`} = ${u.length>1?`outputIndices${H}[${Te}]`:`outputIndices${H}`};`,Te++);return P},G;if(r[0].dataType===9){let H=(ne,P,J="")=>`
          let outputIndices${P} = ${k.offsetToIndices(`outputOffset + ${P}u`)};
          ${U(P)};
          let offset${P} = ${C.indicesToOffset(`dataIndices${P}`)};
          let index${P} = offset${P} / 4u;
          let component${P} = offset${P} % 4u;
          ${ne}[${P}] = ${J}(${C.getByOffset(`index${P}`)}[component${P}]);
        `;G=`
        let outputOffset = global_idx * ${s};
        var value = vec4<u32>(0);
        ${H("value",0,"u32")}
        ${H("value",1,"u32")}
        ${H("value",2,"u32")}
        ${H("value",3,"u32")}
        ${k.setByOffset("global_idx","value")}
      `}else G=`
      let outputIndices = ${k.offsetToIndices("global_idx")};
      ${U("")};
      let value = ${C.getByIndices("dataIndices")};
      ${k.setByOffset("global_idx","value")};
      `;return`
      ${O.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(C,N,k)}
      ${O.mainStart()}
        ${O.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${G}
      }`};return{name:"Gather",shaderCache:{hint:e.cacheKey,inputDependencies:x},getRunData:()=>({outputs:[{dims:u,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:_}),getShaderSource:S}},Vg=r=>ge({axis:r.axis}),Gg=(r,e)=>{let n=r.inputs;j2(n),r.compute(K2(r.inputs,e))}});var Y2,X2,Wg,Hg,qg=R(()=>{"use strict";Re();ot();ke();Y2=r=>{if(!r||r.length!==2)throw new Error("GatherElements requires 2 inputs.");if(r[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(r[0].dims.length!==r[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},X2=(r,e)=>{let n=r[0].dims,t=r[0].dataType,o=n.length,i=r[1].dims,u=r[1].dataType,a=V.normalizeAxis(e.axis,o),s=n[a],l=i.slice(0),d=V.size(l),f=W("input",t,o),p=W("indicesInput",u,i.length),g=te("output",t,l.length),b=[{type:"uint32",data:d},{type:"int32",data:s},{type:"uint32",data:a}];return b.push(...ee(n)),b.push(...ee(i)),b.push(...ee(l)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:l,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:b}),getShaderSource:x=>`
      ${x.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(f,p,g)}
      ${x.mainStart()}
      ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${g.offsetToIndices("global_idx")};

      var idx = ${p.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${f.type.indices}(outputIndices);
      ${f.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${f.getByIndices("inputIndices")};

      ${g.setByOffset("global_idx","value")};
  }`}},Wg=r=>ge({axis:r.axis}),Hg=(r,e)=>{let n=r.inputs;Y2(n),r.compute(X2(r.inputs,e))}});var Z2,J2,Q2,jg,Kg,Yg=R(()=>{"use strict";Re();ot();ke();Z2=r=>{if(!r)throw new Error("Input is missing");if(r.length<2||r.length>3)throw new Error("Invaid input number.");if(r.length===3&&r[2].dims.length>2)throw new Error("Invalid input shape of C");if(r[0].dataType!==r[1].dataType||r.length===3&&r[0].dataType!==r[2].dataType)throw new Error("Input types are mismatched")},J2=(r,e,n)=>{if(n.length===0)return"0u";let t=n.length===1&&r!==1||n.length===2&&n[0]!==r,o=n[n.length-1]!==e,i="0u";return t||(i+=`+ m * ${n[n.length-1]}u`),o||(i+="+n"),i},Q2=(r,e)=>{let n=r[0].dims.slice(),t=r[1].dims.slice(),[o,i,u]=ji.getShapeOfGemmResult(n,e.transA,t,e.transB,r.length===3?r[2].dims:void 0),a=[o,i];if(!a)throw new Error("Can't use gemm on the given tensors");let s=V.size(a),l="";e.transA&&e.transB?l="value += a[k * M + m] * b[n * K + k];":e.transA&&!e.transB?l="value += a[k * M + m] * b[k * N + n];":!e.transA&&e.transB?l="value += a[m * K + k] * b[n * K + k];":!e.transA&&!e.transB&&(l="value += a[m * K + k] * b[k * N + n];");let d=et(r[0].dataType),f=e.alpha===1?"":"value *= alpha;",p=r.length===3?`value += beta * c[${J2(o,i,r[2].dims)}];`:"",g=[`@group(0) @binding(0) var<storage, read> a : array<${d}>;`,`@group(0) @binding(1) var<storage, read> b : array<${d}>;`];r.length===3&&g.push(`@group(0) @binding(2) var<storage, read> c : array<${d}>;`);let b=y=>`
  const M: u32 = ${o}u;
  const N: u32 = ${i}u;
  const K: u32 = ${u}u;
  const alpha = ${d}(${e.alpha});
  const beta = ${d}(${e.beta});

  ${g.join(`
`)}
  @group(0) @binding(${r.length}) var<storage, read_write> output : array<${d}>;

  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes(s)}

    let m = global_idx / N;
    let n = global_idx % N;

    var value = ${d}(0);
    for (var k: u32 = 0u; k<${u}u; k++) {
      ${l}
    }

    ${f}
    ${p}
    output[global_idx] = value;

  }`;return{name:"Gemm",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:a,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:b}},jg=(r,e)=>{Z2(r.inputs),r.compute(Q2(r.inputs,e))},Kg=r=>ge(r)});var e1,t1,r1,n1,Xg,Zg,Jg=R(()=>{"use strict";ut();Re();ot();ke();e1={name:"InstanceNormalization"},t1=(r,e)=>{let n=r[0].dims,t=n,o=2,i=V.sizeToDimension(n,o),u=V.sizeFromDimension(n,o),a=bt(u),s=u/a,l=n[1],d=W("x",r[0].dataType,[n[0],n[1],s],a),f=W("scale",r[1].dataType,r[1].dims),p=W("bias",r[2].dataType,r[2].dims),g=te("output",r[0].dataType,[n[0],n[1],s],a),b=[d,f,p,g],y=d.type.value,_=a===1?"f32":`vec${a}<f32>`,x=64,S=O=>`

  const C: u32 = ${l};
  const normSize: u32 = ${u};
  const epsilon: f32 = ${e.epsilon};
  var<workgroup> meanShared : f32;
  var<workgroup> squaredNormShared : f32;
  var<workgroup> workgroupShared : array<${_}, ${x}>;
  const workgroupSize = ${x}u;
  ${O.declareVariables(...b)}
  ${O.mainStart(x)}
    let norm = global_idx / workgroupSize;
    let batch = norm / C;
    let channel = norm % C;
    let localIndex = local_id.x;

    // initialize workgroup memory
    var initial = ${_}(0);
    for (var h = localIndex; h < ${s}; h += workgroupSize) {
      initial = initial + ${_}(${d.get("batch","channel","h")});
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the mean of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      meanShared = ${zt("workgroupShared[0]",a)} / f32(normSize);
    }
    workgroupBarrier();

    // reinitialize workgroup memory.
    initial = ${_}(0);
    for (var h = localIndex; h < ${s}; h += workgroupSize) {
      let deviation =  ${_}(${d.get("batch","channel","h")}) - ${_}(meanShared);
      initial = initial + deviation * deviation;
    }
    workgroupShared[localIndex] = initial;
    workgroupBarrier();

    // Calculate the sum of square of deviation of current channel data.
    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (localIndex < currSize) {
        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];
      }
      workgroupBarrier();
    }
    if (localIndex == 0) {
      squaredNormShared = ${zt("workgroupShared[0]",a)};
    }
    workgroupBarrier();

    let invStdDev = 1 / sqrt(squaredNormShared / f32(normSize) + epsilon);
    let channelScale = invStdDev * f32(${f.getByOffset("channel")});
    let channelShift = f32(${p.getByOffset("channel")}) - meanShared * channelScale;
    for (var h = localIndex; h < ${s}; h += workgroupSize) {
      let value = ${d.get("batch","channel","h")} * ${y}(${_}(channelScale)) + ${y}(${_}(channelShift));
      ${g.set("batch","channel","h","value")};
    }
  }`;return{...e1,shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:t,dataType:r[0].dataType}],dispatchGroup:{x:i}}),getShaderSource:S}},r1=(r,e,n,t,o,i,u,a)=>{let s=bt(u),l=W("input",e.dataType,e.dims,s),d=W("scale",n.dataType,n.dims,s),f=W("bias",t.dataType,t.dims,s),p=64,g=s===1?"vec2f":`mat2x${s}f`,b=s===1?"f32":`vec${s}f`,y=(N,k)=>`${g}(${N}, ${k})`,_=o*u/s,x=Math.ceil(i/p),S=N=>`
  const H: u32 = ${i};
  const C: u32 = ${u/s};
  const imageSize: u32 = ${i*u/s};

  ${N.declareVariables(l)}
  @group(0) @binding(1) var<storage, read_write> output : array<${g}>;

  ${N.mainStart(p)}
    let currentImageNumber = global_idx / ${p} / C;
    let currentChannelNumber = (global_idx / ${p}) % C;
    let wgId = global_idx % ${p};
    let wgOffset = wgId * ${x};
    if (wgOffset >= H) {
        return;
    }
    let wgMax = min(wgOffset + ${x}, H);

    let offset = currentImageNumber * imageSize + currentChannelNumber;
    var sum = ${At("f32",s)};
    var squaredSum = ${At("f32",s)};
    for (var i: u32 = wgOffset; i < wgMax; i++) {
        let value = ${b}(input[offset + i * C]);
        sum += value;
        squaredSum += value * value;
    }
    output[global_idx] = ${y("sum","squaredSum")};
  }`,O=r.compute({name:"InstanceNormComputeMean",shaderCache:{hint:JSON.stringify({components:s,n:o,h:i,c:u})},getRunData:()=>({outputs:[{dims:[o,u,p,2],dataType:1}],dispatchGroup:{x:o*u/s}}),getShaderSource:S},{inputs:[e],outputs:[-1]})[0],C=N=>`
  const H: u32 = ${i};
  const C: u32 = ${u/s};
  const imageSize: u32 = ${p*u/s};
  const epsilon: f32 = ${a};

  @group(0) @binding(0) var<storage, read> input : array<${g}>;
  @group(0) @binding(1) var<storage, read> scale : array<${d.type.storage}>;
  @group(0) @binding(2) var<storage, read> bias : array<${f.type.storage}>;
  @group(0) @binding(3) var<storage, read_write> output : array<${g}>;

  ${N.mainStart()}
    ${N.guardAgainstOutOfBoundsWorkgroupSizes(_)}
    let currentImageNumber = global_idx / C;
    let currentChannelNumber = global_idx % C;

    let offset = currentImageNumber * imageSize;
    var sum = ${At("f32",s)};
    var squaredSum = ${At("f32",s)};
    for (var i: u32 = 0; i < ${p}; i++) {
        let value = input[offset + i + currentChannelNumber * ${p}];
        sum += value[0];
        squaredSum += value[1];
    }
    sum = sum / f32(H);
    squaredSum = squaredSum / f32(H);
    let invStdDev = 1 / sqrt(squaredSum - sum * sum + epsilon);
    let channelScale = invStdDev * ${b}(scale[currentChannelNumber]);
    let channelShift = ${b}(bias[currentChannelNumber]) - sum * channelScale;

    output[global_idx] = ${y("channelScale","channelShift")};
  }`;return r.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:JSON.stringify({components:s,n:o,h:i,c:u,epsilon:a})},getRunData:()=>({outputs:[{dims:[o,u,2],dataType:1}],dispatchGroup:{x:Math.ceil(_/64)}}),getShaderSource:C},{inputs:[O,n,t],outputs:[-1]})[0]},n1=(r,e,n)=>{let t=e[0].dims,o=t,i=t[0],u=t[t.length-1],a=V.sizeFromDimension(t,1)/u,s=bt(u),l=V.size(o)/s,d=W("input",e[0].dataType,e[0].dims,s),f=te("output",e[0].dataType,o,s),p=et(e[0].dataType),g=s===1?"vec2f":`mat2x${s}f`,b=s===1?p:`vec${s}<${p}>`,y=r1(r,e[0],e[1],e[2],i,a,u,n.epsilon),_=x=>`
  const H: u32 = ${a};
  const C: u32 = ${u/s};

  @group(0) @binding(0) var<storage, read> input : array<${d.type.storage}>;
  @group(0) @binding(1) var<storage, read> scaleInput : array<${g}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${f.type.storage}>;

  ${x.mainStart()}
    let currentImageNumber = global_idx / (C * H);
    let currentChannelNumber = global_idx % C;

    let scaleOffset = currentImageNumber * C + currentChannelNumber;
    let scale = scaleInput[scaleOffset];
    output[global_idx] = fma(input[global_idx], ${b}(scale[0]), ${b}(scale[1]));
  }`;r.compute({name:"InstanceNormalization",shaderCache:{hint:`${n.cacheKey}`},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)}}),getShaderSource:_},{inputs:[e[0],y]})},Xg=r=>ge({epsilon:r.epsilon,format:r.format}),Zg=(r,e)=>{e.format==="NHWC"?n1(r,r.inputs,e):r.compute(t1(r.inputs,e))}});var o1,i1,Qg,eb,tb=R(()=>{"use strict";ut();Re();ot();ke();o1=r=>{if(!r||r.length<2)throw new Error("layerNorm requires at least 2 inputs.")},i1=(r,e,n)=>{let t=r[0].dims,o=r[1],i=r[2],u=t,a=V.normalizeAxis(e.axis,t.length),s=V.sizeToDimension(t,a),l=V.sizeFromDimension(t,a),d=V.size(o.dims),f=i?V.size(i.dims):0;if(d!==l||i&&f!==l)throw new Error(`Size of X.shape()[axis:] == ${l}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${d} and bias size of ${f}`);let p=[];for(let C=0;C<t.length;++C)C<a?p.push(t[C]):p.push(1);let g=bt(l),b=et(r[0].dataType),y=[W("x",r[0].dataType,r[0].dims,g),W("scale",o.dataType,o.dims,g)];i&&y.push(W("bias",i.dataType,i.dims,g)),y.push(te("output",r[0].dataType,u,g));let _=n>1,x=n>2;_&&y.push(te("meanDataOutput",1,p)),x&&y.push(te("invStdOutput",1,p));let S=C=>`
  const normSize: f32 = ${l};
  const normSizeVectorized: u32 = ${l/g};
  const epsilon: f32 = ${e.epsilon};

  ${C.declareVariables(...y)}
  ${C.mainStart()}
    ${C.guardAgainstOutOfBoundsWorkgroupSizes(s)}
    let offset = global_idx * normSizeVectorized;
    var meanVector = ${At("f32",g)};
    var meanSquareVector = ${At("f32",g)};

    for (var h: u32 = 0u; h < normSizeVectorized; h++) {
      let value = ${rr(b,g,"x[h + offset]")};
      meanVector += value;
      meanSquareVector += value * value;
    }
    let mean = ${zt("meanVector",g)} / normSize;
    let meanSquare = sqrt(${zt("meanSquareVector",g)} 
      / normSize - mean * mean + epsilon);

    for (var j: u32 = 0; j < normSizeVectorized; j++) {
      let f32input = ${rr(b,g,"x[j + offset]")};
      let f32scale = ${rr(b,g,"scale[j]")};
      output[j + offset] = ${y[0].type.value}((f32input - mean) / meanSquare * f32scale
        ${i?`+ ${rr(b,g,"bias[j]")}`:""}
      );
    }

    ${_?"meanDataOutput[global_idx] = mean":""};
    ${x?"invStdOutput[global_idx] = 1 / meanSquare":""};
  }`,O=[{dims:u,dataType:r[0].dataType}];return _&&O.push({dims:p,dataType:1}),x&&O.push({dims:p,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${e.cacheKey}|${n}|${r.length}`},getRunData:()=>({outputs:O,dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:S}},Qg=r=>ge({axis:r.axis,epsilon:r.epsilon}),eb=(r,e)=>{o1(r.inputs),r.compute(i1(r.inputs,e,r.outputCount))}});var a1,nb,rb,s1,du,ob,ib=R(()=>{"use strict";Re();ot();Hi();Xs();ke();Bn();a1=(r,e)=>{let n=r[0],t=r[1],o=r[2],i=r[3],u=r[4],a=r[5],s=r[6],l=r[7];if(n.dims.length!==3&&n.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let d=!1,f=n.dims[0],p=n.dims[1],g=n.dims.length===3?d?n.dims[2]/3:n.dims[2]:e.numHeads*n.dims[4],b=p,y=0,_=0,x=Math.floor(g/e.numHeads);if(s&&l){if(s.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(l.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');y=s.dims[2],_=s.dims[2]}else if(s||l)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let S;if(t){if(n.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(t.dims.length<3||t.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==t.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(t.dims.length===3){if(t.dims[2]!==n.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');S=2,b=t.dims[1]}else if(t.dims.length===5){if(t.dims[2]!==e.numHeads||t.dims[3]!==2||t.dims[4]!==x)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(o)throw new Error('Expect "value" be none when "key" has packed kv format.');S=5,b=t.dims[1]}else{if(t.dims[1]!==e.numHeads||t.dims[3]!==x)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');S=0,b=t.dims[2]}}else{if(n.dims.length!==3&&n.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(n.dims.length===5&&(n.dims[2]!==e.numHeads||n.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');S=3}if(i){if(i.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(o&&n.dims.length===5&&n.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let O=0;if(u){O=8;let G=u.dims;throw G.length===1?G[0]===f?O=1:G[0]===3*f+2&&(O=3):G.length===2&&G[0]===f&&G[1]===b&&(O=5),O===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, kv_sequence_length)'):new Error("Mask not supported")}let C=!1,N=g;if(o){if(o.dims.length!==3&&o.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==o.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(o.dims.length===3){if(b!==o.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');N=o.dims[2]}else{if(b!==o.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');N=o.dims[1]*o.dims[3],C=!0}}let k=y+b,U=!1;if(u)throw new Error("Key padding mask is not supported");if(a)throw new Error("extraAddQk is not supported");if(s)throw new Error("pastKey is not supported");if(l)throw new Error("pastValue is not supported");return{batchSize:f,sequenceLength:p,pastSequenceLength:y,kvSequenceLength:b,totalSequenceLength:k,maxSequenceLength:_,inputHiddenSize:0,hiddenSize:g,vHiddenSize:N,headSize:x,vHeadSize:Math.floor(N/e.numHeads),numHeads:e.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:e.maskFilterValue,maskType:O,scale:e.scale,broadcastResPosBias:U,passPastInKv:C,qkvFormat:S}},nb=r=>ge({...r}),rb=ge({perm:[0,2,1,3]}),s1=(r,e,n,t,o,i,u)=>{let a=[t,o,i],s=V.size(a),l=et(e.dataType),d=f=>`
  const biasOffset = ${u}u;
  const hiddenSize = ${i}u;

  @group(0) @binding(0) var<storage, read> qkv: array<${l}>;
  @group(0) @binding(1) var<storage, read> bias: array<${l}>;
  @group(0) @binding(2) var<storage, read_write> qkv_with_bias: array<${l}>;

  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes(s)}
    let biasOffsetIdx = (global_idx % hiddenSize) + biasOffset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[biasOffsetIdx];
  }`;return r.compute({name:"MultiHeadAttentionAddBias",shaderCache:{hint:JSON.stringify({batchSize:t,sequenceLength:o,hiddenSize:i,biasOffset:u})},getRunData:()=>({outputs:[{dims:a,dataType:e.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:d},{inputs:[e,n],outputs:[-1]})[0]},du=(r,e,n,t,o,i,u,a)=>{let s=i;if(u){if(t===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return s=s1(r,i,u,e,t,n*o,a),s=s.reshape([e,t,n,o]),r.compute(nr(s,rb.perm),{inputs:[s],outputs:[-1]})[0]}else return i.dims.length===3&&(s=i.reshape([e,t,n,o])),r.compute(nr(s,rb.perm),{inputs:[s],outputs:[-1]})[0]},ob=(r,e)=>{let n=a1(r.inputs,e);if(r.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(r.inputs[1]?.dims.length===5)throw new Error("Packed KV is not implemented");let t=r.inputs[1]&&r.inputs[2]&&r.inputs[1].dims.length===4&&r.inputs[2].dims.length===4,o=du(r,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,r.inputs[0],r.inputs[3],0);if(t)return Qi(r,o,r.inputs[1],r.inputs[2],r.inputs[4],void 0,void 0,void 0,r.inputs[5],n,e);let i=du(r,n.batchSize,n.numHeads,n.kvSequenceLength,n.headSize,r.inputs[1],r.inputs[3],n.hiddenSize),u=du(r,n.batchSize,n.numHeads,n.kvSequenceLength,n.vHeadSize,r.inputs[2],r.inputs[3],2*n.hiddenSize);Qi(r,o,i,u,r.inputs[4],void 0,r.inputs[6],r.inputs[7],r.inputs[5],n,e)}});var u1,l1,d1,c1,f1,p1,h1,m1,g1,ab,sb,ub=R(()=>{"use strict";ut();Re();ot();ke();u1=r=>{if(!r||r.length<1)throw new Error("Too few inputs");if(r[0].dataType!==1)throw new Error("Input type must be float.");if(r.length>=2){let e=r[0].dims.length*2===r[1].dims[0];if(r.length===4&&(e=r[3].dims[0]*2===r[1].dims[0]),!e)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},l1=(r,e,n,t,o,i)=>{let u=e.length,a="";for(let s=u-1;s>=0;--s)a+=`
            k = i32(${r.indicesGet("indices",s)}) - ${t[s]};
            if (k < 0) {
              break;
            }
            if (k >= ${e[s]}) {
              break;
            }
            offset += k * ${n[s]};
        `;return`
          value = ${o}(${i});
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${a}
            value = x[offset];
          }
      `},d1=(r,e,n,t)=>{let o=e.length,i="";for(let u=o-1;u>=0;--u)i+=`
                k = i32(${r.indicesGet("indices",u)}) - ${t[u]};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = ${2*(e[u]-1)};
                  k = k % _2n_1;
                  if(k >= ${e[u]}) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * ${n[u]};
            `;return`
              var offset = 0;
              var k = 0;
              ${i}
              value = x[offset];
          `},c1=(r,e,n,t)=>{let o=e.length,i="";for(let u=o-1;u>=0;--u)i+=`
                k = i32(${r.indicesGet("indices",u)}) - ${t[u]};
                if (k < 0) {
                  k = 0;
                }
                if (k >= ${e[u]}) {
                  k = ${e[u]-1};
                }
                offset += k * ${n[u]};
            `;return`
              var offset = 0;
              var k = 0;
              ${i}
              value = x[offset];
          `},f1=(r,e,n,t)=>{let o=e.length,i="";for(let u=o-1;u>=0;--u)i+=`
                k = i32(${r.indicesGet("indices",u)}) - ${t[u]};
                if (k < 0)  {
                  k += ${e[u]};
                }
                if (k >= ${e[u]}) {
                  k -= ${e[u]};
                }
                offset += k * ${n[u]};
            `;return`
              var offset = 0;
              var k = 0;
              ${i}
              value = x[offset];
          `},p1=(r,e,n,t,o)=>{switch(t.mode){case 0:return l1(r,e,n,t.pads,o,t.value);case 1:return d1(r,e,n,t.pads);case 2:return c1(r,e,n,t.pads);case 3:return f1(r,e,n,t.pads);default:throw new Error("Invalid mode")}},h1=(r,e,n,t)=>{let o=e[0].dims,i=V.padShape(o.slice(),n.pads),u=V.size(i),a=V.computeStrides(o),s=te("output",e[0].dataType,i),l=W("x",e[0].dataType,o),d=p1(s,o,a,n,t);return`
              ${r.declareVariables(l,s)}
              ${r.mainStart()}
              ${r.guardAgainstOutOfBoundsWorkgroupSizes(u)}

              let indices = ${s.offsetToIndices("global_idx")};

              var value = ${t}(0);
              ${d}
              output[global_idx] = value;
          }`},m1=(r,e)=>{let n=V.padShape(r[0].dims.slice(),e.pads);return{name:"Pad",shaderCache:{hint:e.cacheKey},getRunData:()=>({outputs:[{dims:n,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(V.size(n)/64)}}),getShaderSource:t=>h1(t,r,e,"f32")}},g1=(r,e)=>{if(r.length>1){let n=r[1].getBigInt64Array(),t=r.length>=3&&r[2].data?r[2].getFloat32Array()[0]:0,o=r[0].dims.length,i=new Int32Array(2*o).fill(0);if(r.length>=4){let a=r[3].getBigInt64Array();for(let s=0;s<a.length;s++)i[Number(a[s])]=Number(n[s]),i[Number(a[s])+o]=Number(n[s+a.length])}else n.forEach((a,s)=>i[Number(s)]=Number(a));let u=[];return i.forEach(a=>u.push(a)),ge({mode:e.mode,value:t,pads:u})}else return e},ab=(r,e)=>{u1(r.inputs);let n=g1(r.inputs,e);r.compute(m1(r.inputs,n),{inputs:[0]})},sb=r=>{let e=r.mode,n=r.value,t=r.pads;return ge({mode:e,value:n,pads:t})}});var ua,lb,db,cb,fb,b1,y1,pb,hb,mb,gb,bb,yb,vb,wb,xb,$b,Tb,_b,Sb=R(()=>{"use strict";Bt();Re();ke();ua=r=>{if(xe.webgpu.validateInputContent&&(!r||r.length!==1))throw new Error("Pool ops requires 1 input.")},lb=(r,e,n)=>{let t=e.format==="NHWC",o=r.dims.slice();t&&o.splice(1,0,o.pop());let i=Object.hasOwnProperty.call(e,"dilations"),u=e.kernelShape.slice(),a=e.strides.slice(),s=i?e.dilations.slice():[],l=e.pads.slice();dn.adjustPoolAttributes(n,o,u,a,s,l);let d=dn.computePoolOutputShape(n,o,a,s,u,l,e.autoPad),f=Object.assign({},e);i?Object.assign(f,{kernelShape:u,strides:a,pads:l,dilations:s,cacheKey:e.cacheKey}):Object.assign(f,{kernelShape:u,strides:a,pads:l,cacheKey:e.cacheKey});let p=d.slice();return p.push(p.splice(1,1)[0]),[f,t?p:d]},db=(r,e)=>{let n=e.format==="NHWC",t=V.size(r),o=V.size(e.kernelShape),i=[{type:"uint32",data:t},{type:"uint32",data:o}],u=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(e.kernelShape.length<=2){let a=e.kernelShape[e.kernelShape.length-1],s=e.strides[e.strides.length-1],l=e.pads[e.pads.length/2-1],d=e.pads[e.pads.length-1],f=!!(l+d);i.push({type:"uint32",data:a},{type:"uint32",data:s},{type:"uint32",data:l},{type:"uint32",data:d}),u.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let p=!1;if(e.kernelShape.length===2){let g=e.kernelShape[e.kernelShape.length-2],b=e.strides[e.strides.length-2],y=e.pads[e.pads.length/2-2],_=e.pads[e.pads.length-2];p=!!(y+_),i.push({type:"uint32",data:g},{type:"uint32",data:b},{type:"uint32",data:y},{type:"uint32",data:_}),u.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[i,u,!0,f,p]}else{if(n)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let a=V.computeStrides(e.kernelShape);i.push({type:"uint32",data:a},{type:"uint32",data:e.pads},{type:"uint32",data:e.strides}),u.push({name:"kernelStrides",type:"u32",length:a.length},{name:"pads",type:"u32",length:e.pads.length},{name:"strides",type:"u32",length:e.strides.length});let s=e.pads.reduce((l,d)=>l+d);return[i,u,!!s,!1,!1]}},cb=(r,e,n,t,o,i,u,a,s,l,d,f)=>{let p=o.format==="NHWC",g=e.type.value,b=te("output",e.type.tensor,t);if(o.kernelShape.length<=2){let y="",_="",x="",S=n-(p?2:1);if(d?y=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${S}] = indices[${S}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${S}] < 0 || xIndices[${S}]
                      >= uniforms.x_shape[${S}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${i}
                }`:y=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${S}] = indices[${S}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${e.indicesToOffset("xIndices")}];
                  ${i}
                }`,o.kernelShape.length===2){let C=n-(p?3:2);f?_=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${C}] = indices[${C}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${C}] < 0 || xIndices[${C}] >= uniforms.x_shape[${C}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:_=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${C}] = indices[${C}] * uniforms.sh - uniforms.phStart + j;
                `,x=`
              }
            `}return`
            ${r.registerUniforms(s).declareVariables(e,b)}

            ${r.mainStart()}
              ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${b.offsetToIndices("global_idx")};
              var xIndices = ${b.offsetToIndices("global_idx")};

              var value = ${g}(${a});
              var pad = 0;
              ${_}
              ${y}
              ${x}
              ${u}

              output[global_idx] = value;
            }`}else{if(p)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let y=o.kernelShape.length,_=o.pads.length,x="";return l?x=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${e.indicesToOffset("xIndices")}];
                ${i}
              }`:x=`
              }
              let x_val = x[${e.indicesToOffset("xIndices")}];
              ${i}
            `,`
            ${r.registerUniforms(s).declareVariables(e,b)}

            ${r.mainStart()}
              ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${b.offsetToIndices("global_idx")};
              var xIndices = ${b.offsetToIndices("global_idx")};

              var offsets: array<u32, ${y}>;

              var value = ${g}(${a});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${y-1}u; j++) {
                  offsets[j] = offset / ${qe("uniforms.kernelStrides","j",y)};
                  offset -= offsets[j] * ${qe("uniforms.kernelStrides","j",y)};
                }
                offsets[${y-1}] = offset;

                isPad = false;
                for (var j = ${n-y}u; j < ${n}u; j++) {
                  xIndices[j] = indices[j] * ${qe("uniforms.strides",`j - ${n-y}u`,y)}
                    + offsets[j - ${n-y}u] - ${qe("uniforms.pads","j - 2u",_)};
                  ${x}
              }
              ${u}

              output[global_idx] = value;
            }`}},fb=r=>`${r.format};${r.ceilMode};${r.autoPad};${r.kernelShape.length}`,b1=r=>`${fb(r)};${r.countIncludePad}`,y1=r=>`${fb(r)};${r.storageOrder};${r.dilations}`,pb=r=>({format:r.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][r.auto_pad],ceilMode:r.ceil_mode,kernelShape:r.kernel_shape,strides:r.strides,pads:r.pads}),hb=(r,e,n,t)=>{let[o,i]=lb(e,t,n),u=W("x",e.dataType,e.dims.length),a=u.type.value,s="value += x_val;",l="";o.countIncludePad?l+=`value /= ${a}(uniforms.kernelSize);`:l+=`value /= ${a}(i32(uniforms.kernelSize) - pad);`;let[d,f,p,g,b]=db(i,o);d.push(...ee(e.dims),...ee(i));let y=["rank"];return{name:r,shaderCache:{hint:`${t.cacheKey};${p};${g};${b}`,inputDependencies:y},getRunData:()=>({outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(V.size(i)/64)},programUniforms:d}),getShaderSource:_=>cb(_,u,e.dims.length,i.length,o,s,l,0,f,p,g,b)}},mb=r=>{let e=r.count_include_pad!==0,n=pb(r);if(n.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let t={countIncludePad:e,...n,cacheKey:""};return{...t,cacheKey:b1(t)}},gb=(r,e)=>{ua(r.inputs),r.compute(hb("AveragePool",r.inputs[0],!1,e))},bb={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},yb=r=>{let e=r.format;return{format:e,...bb,cacheKey:e}},vb=(r,e)=>{ua(r.inputs),r.compute(hb("GlobalAveragePool",r.inputs[0],!0,e))},wb=(r,e,n,t)=>{let[o,i]=lb(e,t,n),u=`
      value = max(x_val, value);
    `,a="",s=W("x",e.dataType,e.dims.length),l=["rank"],[d,f,p,g,b]=db(i,o);return d.push(...ee(e.dims),...ee(i)),{name:r,shaderCache:{hint:`${t.cacheKey};${p};${g};${b}`,inputDependencies:l},getRunData:()=>({outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(V.size(i)/64)},programUniforms:d}),getShaderSource:y=>cb(y,s,e.dims.length,i.length,o,u,a,-1e5,f,p,g,b)}},xb=(r,e)=>{ua(r.inputs),r.compute(wb("MaxPool",r.inputs[0],!1,e))},$b=r=>{let e=r.storage_order,n=r.dilations,t=pb(r);if(e!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(t.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let o={storageOrder:e,dilations:n,...t,cacheKey:""};return{...o,cacheKey:y1(o)}},Tb=r=>{let e=r.format;return{format:e,...bb,cacheKey:e}},_b=(r,e)=>{ua(r.inputs),r.compute(wb("GlobalMaxPool",r.inputs[0],!0,e))}});var w1,x1,Ib,Ab=R(()=>{"use strict";Bt();ut();ke();w1=(r,e,n)=>{let t=r===e,o=r<e&&n<0,i=r>e&&n>0;if(t||o||i)throw new Error("Range these inputs' contents are invalid.")},x1=(r,e,n,t)=>{let o=Math.abs(Math.ceil((e-r)/n)),i=[o],u=o,a=te("output",t,i),s=a.type.storage,l=d=>`
        ${d.declareVariables(a)}
        ${d.mainStart()}
        ${d.guardAgainstOutOfBoundsWorkgroupSizes(u)}
        output[global_idx] = ${s}(${r}) + ${s}(global_idx) * ${s}(${n});
      }`;return{name:"Range",shaderCache:{hint:[r,e,n].map(d=>d.toString()).join("_")},getShaderSource:l,getRunData:()=>({outputs:[{dims:i,dataType:t}],dispatchGroup:{x:Math.ceil(u/64)}})}},Ib=r=>{let e=0,n=0,t=0;r.inputs[0].dataType===6?(e=r.inputs[0].getInt32Array()[0],n=r.inputs[1].getInt32Array()[0],t=r.inputs[2].getInt32Array()[0]):r.inputs[0].dataType===1&&(e=r.inputs[0].getFloat32Array()[0],n=r.inputs[1].getFloat32Array()[0],t=r.inputs[2].getFloat32Array()[0]),xe.webgpu.validateInputContent&&w1(e,n,t),r.compute(x1(e,n,t,r.inputs[0].dataType),{inputs:[]})}});var $1,T1,_1,S1,I1,A1,O1,E1,C1,P1,k1,D1,B1,R1,M1,Ob,Eb,Cb=R(()=>{"use strict";Re();ot();ke();$1=(r,e)=>{if(r.every(n=>n>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),r.length>0){if(e.mode==="linear"){if(!(r.length===2||r.length===4&&r[0]===1&&r[1]===1||r.length===4&&r[0]===1&&r[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(e.mode==="cubic"&&!(r.length===2||r.length===4&&r[0]===1&&r[1]===1||r.length===4&&r[0]===1&&r[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},T1=(r,e,n)=>{e.every(o=>o>=0&&o<n||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let t=new Array(n).fill(1);return e.forEach((o,i)=>t[o]=r[i]),t},_1=(r,e,n,t,o,i)=>{let[u,a,s]=n>10?[1,2,3]:[-1,r.length>1?1:-1,-1],l=r[0].dims.length;if(u>0&&r.length>u&&r[u].dims.length>0)r[u].getFloat32Array().forEach(d=>i.push(d));else if(e.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(a>0&&r.length>a&&r[a].dims.length>0){if(r[a].getFloat32Array().forEach(d=>t.push(d)),t.length!==0&&t.length!==l&&n>=18&&t.length!==e.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");$1(t,e),e.axes.length>0&&T1(t,e.axes,l).forEach((d,f)=>t[f]=d)}if(s>0&&r.length>s&&(r[s].getBigInt64Array().forEach(d=>o.push(Number(d))),o.length!==l||n>=18&&o.length===e.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(e.axes.length>0){if(t.length!==e.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(o.length!==e.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof t<"u"&&typeof o<"u"&&t.length>0&&o.length>l)throw new Error("Resize requires only of scales or sizes to be specified")},S1=(r,e)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: ${e}, xScale: ${e}, lengthResized: ${e},
     lengthOriginal: ${e}, roiStart: ${e}, roiEnd: ${e}) -> ${e} { `+(()=>{switch(r){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return`if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * ${e}(lengthOriginal - 1);                   }`;case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`
`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${r} is not supported`)}})()+"}",I1=(r,e,n)=>`fn getNearestPixelFromOriginal(xOriginal: ${n}, isDownSample: bool) -> ${n} {`+(()=>{switch(r){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(e<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${r} is not supported`)}})()+"}",A1=(r,e,n)=>{let t=new Array(n).fill(0).concat(new Array(n).fill(1)),o=r.length===0?t:r.slice();return e.length>0?(e.forEach((i,u)=>{t[i]=o[u],t[u+n]=o[e.length+u]}),t):o},O1=(r,e,n,t)=>{let o=[];if(n.length>0)if(t.length>0){if(r.forEach(i=>o.push(i)),Math.max(...t)>r.length)throw new Error("axes is out of bound");t.forEach((i,u)=>o[i]=n[u])}else n.forEach(i=>o.push(i));else{if(e.length===0)throw new Error("Resize requires either scales or sizes.");o=r.map((i,u)=>Math.round(i*e[u]))}return o},E1=(r,e,n)=>{let t=(()=>{switch(n.keepAspectRatioPolicy){case"not_larger":return n.axes.length>0?Math.min(...n.axes.map(i=>e[i]),Number.MAX_VALUE):Math.min(...e,Number.MAX_VALUE);case"not_smaller":return n.axes.length>0?Math.max(...n.axes.map(i=>e[i]),Number.MIN_VALUE):Math.max(...e,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${n.keepAspectRatioPolicy} is not supported`)}})();e.fill(1,0,e.length);let o=r.slice();return n.axes.length>0?(n.axes.forEach(i=>e[i]=t),n.axes.forEach(i=>o[i]=Math.round(r[i]*e[i]))):(e.fill(t,0,e.length),o.forEach((i,u)=>o[u]=Math.round(i*e[u]))),o},C1=(r,e,n,t,o)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${r.type.indices}) -> array<${r.type.value}, ${n.length}> {
      var original_indices: array<${r.type.value}, ${n.length}>;
      for (var i:u32 = 0; i < ${n.length}; i++) {
        var output_index = ${r.type.value}(${r.indicesGet("output_indices","i")});
        var scale = ${qe("uniforms.scales","i",t)};
        var roi_low = ${qe("uniforms.roi","i",o)};
        var roi_hi = ${qe("uniforms.roi",`i + ${e.length}`,o)};
        if (scale == 1.0) {
          original_indices[i] = output_index;
        } else {
          var input_shape_i = ${r.type.value}(${qe("uniforms.input_shape","i",e.length)});
          var output_shape_i = ${r.type.value}(${qe("uniforms.output_shape","i",n.length)});
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,P1=(r,e,n,t,o,i,u)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> ${r.type.indices} {
      var input_indices: ${r.type.indices};
      for (var i:u32 = 0; i < ${t.length}; i++) {
        var output_index = ${e.type.value}(${e.indicesGet("output_indices","i")});
        var input_index: u32;
        var scale = ${qe("uniforms.scales","i",o)};
        if (scale == 1.0) {
          input_index = u32(output_index);
        } else {
          var roi_low = ${qe("uniforms.roi","i",i)};
          var roi_hi = ${qe("uniforms.roi",`i + ${n.length}`,i)};
          var input_shape_i = ${e.type.value}(${qe("uniforms.input_shape","i",n.length)});
          var output_shape_i = ${e.type.value}(${qe("uniforms.output_shape","i",t.length)});
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${u} || (original_idx >= 0 && original_idx < input_shape_i)) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > (input_shape_i - 1)) {
              input_index = u32(input_shape_i) - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${r.indicesSet("input_indices","i"," input_index")}
      }
      return input_indices;
    }`,k1=(r,e)=>`
    fn checkInputIndices(input_indices: ${r.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${e.length}; i++) {
        var input_index = ${r.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${qe("uniforms.input_shape","i",e.length)}) {
          return false;
        }
      }
      return true;
    }`,D1=(r,e,n,t,o,i)=>{let[u,a,s,l]=n.length===2?[-1,0,1,-1]:t[1]===1?[0,2,3,1]:[0,1,2,3],d=r.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${d} {
      var input_indices: ${r.type.indices};
      ${r.indicesSet("input_indices",a,`max(0, min(row, ${n[a]} - 1))`)};
      ${r.indicesSet("input_indices",s,`max(0, min(col, ${n[s]} - 1))`)};
      if (${n.length} > 2) {
        ${r.indicesSet("input_indices",l,"channel")};
        ${r.indicesSet("input_indices",u,"batch")};
      };
      return ${r.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${e.type.indices}) -> ${d} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${d} = originalIndices[${a}];
      var col:${d} = originalIndices[${s}];
      if (${o} && (row < 0 || row > (${n[a]} - 1) || col < 0 || col > ${n[s]} - 1)) {
        return ${i};
      }
      row = max(0, min(row, ${n[a]} - 1));
      col = max(0, min(col, ${n[s]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = 0;
      var batch: u32 = 0;
      if (${n.length>2}) {
        channel = u32(originalIndices[${l}]);
        batch = u32(originalIndices[${u}]);
      }
      var x11: ${d} = getInputValue(batch, channel, row1, col1);
      var x12: ${d} = getInputValue(batch, channel, row1, col2);
      var x21: ${d} = getInputValue(batch, channel, row2, col1);
      var x22: ${d} = getInputValue(batch, channel, row2, col2);
      var dx1: ${d} = row - ${d}(row1);
      var dx2: ${d} = ${d}(row2) - row;
      var dy1 = col - ${d}(col1);
      var dy2 = ${d}(col2) - col;
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},B1=(r,e,n,t,o,i,u,a,s,l)=>{let[d,f]=n.length===2?[0,1]:o[1]===1?[2,3]:[1,2],p=r.type.value,g=b=>{let y=b===d?"row":"col";return`
      fn ${y}CubicInterpolation(input_indices: ${r.type.indices}, output_indices: ${e.type.indices}) -> ${p} {
        var output_index = ${e.indicesGet("output_indices",b)};
        var originalIdx: ${p} = getOriginalCoordinateFromResizedCoordinate(${p}(output_index), ${o[b]},
        ${p}(${t[b]}), ${p}(${n[b]}), ${i[b]}, ${i[b]} + ${n.length});
        var fractOriginalIdx: ${p} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${a} && (originalIdx < 0 || originalIdx > (${n[b]} - 1))) {
          return ${s};
        }
        var data: array<${p}, 4> = array<${p}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${y}: ${p} = originalIdx + ${p}(i);
          if (${y} < 0 || ${y} >= ${n[b]}) {
            if (${l}) {
              coefs[i + 1] = 0.0;
              continue;
            } else if (${a}) {
              return ${s};
            } else {
              ${y} = max(0, min(${y}, ${n[b]} - 1));
            }
          }
          var input_indices_copy: ${r.type.indices} = input_indices;
          ${r.indicesSet("input_indices_copy",b,`u32(${y})`)};
          data[i + 1] = ${b===d?r.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${g(d)};
    ${g(f)};
  fn getCubicInterpolationCoefs(s: ${p}) -> array<${p}, 4> {
    var absS = abs(s);
    var coeffs: array<${p}, 4> = array<${p}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${p} = 1.0 - absS;
    var twoMinusAbsS: ${p} = 2.0 - absS;
    var onePlusAbsS: ${p} = 1.0 + absS;
    coeffs[0] = ((${u} * onePlusAbsS - 5 * ${u}) * onePlusAbsS + 8 * ${u}) * onePlusAbsS - 4 * ${u};
    coeffs[1] = ((${u} + 2) * absS - (${u} + 3)) * absS * absS + 1;
    coeffs[2] = ((${u} + 2) * oneMinusAbsS - (${u} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${u} * twoMinusAbsS - 5 * ${u}) * twoMinusAbsS + 8 * ${u}) * twoMinusAbsS - 4 * ${u};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${p}, 4>, coefs: array<${p}, 4>) -> ${p} {
    var coefsSum: ${p} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${e.type.indices}) -> ${p} {
    var input_indices: ${r.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},R1=(r,e,n,t,o,i)=>{let u=r.dims,a=A1(i,e.axes,u.length),s=O1(u,t,o,e.axes),l=t.slice();t.length===0&&(l=u.map((x,S)=>x===0?1:s[S]/x),e.keepAspectRatioPolicy!=="stretch"&&(s=E1(u,l,e)));let d=te("output",r.dataType,s.length),f=W("input",r.dataType,u.length),p=V.size(s),g=u.length===s.length&&u.every((x,S)=>x===s[S]),b=e.coordinateTransformMode==="tf_crop_and_resize",y=f.type.value,_=x=>`
      ${g?"":`
      ${S1(e.coordinateTransformMode,y)};
      ${(()=>{switch(e.mode){case"nearest":return`
              ${k1(f,u)};
              ${I1(e.nearestMode,n,y)};
              ${P1(f,d,u,s,l.length,a.length,b)};
              `;case"linear":return`
              ${C1(d,u,s,l.length,a.length)};
              ${D1(f,d,u,l,b,e.extrapolationValue)};
              `;case"cubic":return`
            ${B1(f,d,u,s,l,a,e.cubicCoeffA,b,e.extrapolationValue,e.excludeOutside)};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${x.registerUniform("output_size","u32").registerUniform("scales","f32",l.length).registerUniform("roi","f32",a.length).declareVariables(f,d)}
      ${x.mainStart()}
        ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${g?"output[global_idx] = input[global_idx];":`
        let output_indices = ${d.offsetToIndices("global_idx")};
        var input_indices: ${f.type.indices};
        ${(()=>{switch(e.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${f.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${e.extrapolationValue};
                }`;case"linear":return"output[global_idx] = bilinearInterpolation(output_indices);";case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${e.mode}`)}})()};
        `}
      }`;return{name:"Resize",shaderCache:{hint:`${e.cacheKey}|${n}|${l.length>0?l:""}|${o.length>0?o:""}|${a.length>0?a:""}|${g}`,inputDependencies:["rank"]},getShaderSource:_,getRunData:()=>({outputs:[{dims:s,dataType:r.dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:[{type:"uint32",data:p},{type:"float32",data:l},{type:"float32",data:a},...ee(u),...ee(s)]})}},M1=r=>{let e=r.customDataBuffer;return new Uint32Array(e,e.byteOffset,1)[0]},Ob=(r,e)=>{let n=[],t=[],o=[],i=M1(r);_1(r.inputs,e,i,n,t,o),r.compute(R1(r.inputs[0],e,i,n,t,o),{inputs:[0]})},Eb=r=>{let e=r.antialias,n=r.axes,t=r.coordinateTransformMode,o=r.cubicCoeffA,i=r.excludeOutside!==0,u=r.extrapolationValue,a=r.keepAspectRatioPolicy,s=r.mode,l=r.nearestMode===""?"simple":r.nearestMode;return ge({antialias:e,axes:n,coordinateTransformMode:t,cubicCoeffA:o,excludeOutside:i,extrapolationValue:u,keepAspectRatioPolicy:a,mode:s,nearestMode:l})}});var L1,z1,Pb,kb,Db=R(()=>{"use strict";ut();Re();ot();ke();L1=r=>{if(!r||r.length<3)throw new Error("layerNorm requires at least 3 inputs.");let e=r[0],n=r[1],t=r[2];if(e.dataType!==n.dataType||e.dataType!==t.dataType)throw new Error("All inputs must have the same data type");if(e.dims.length!==3&&e.dims.length!==2)throw new Error("Input must be 2D or 3D");if(n.dims.length!==3&&n.dims.length!==2)throw new Error("Skip must be 2D or 3D");let o=e.dims[e.dims.length-1],i=e.dims[e.dims.length-2];if(n.dims[n.dims.length-1]!==o)throw new Error("Skip must have the same hidden size as input");if(n.dims[n.dims.length-2]!==i)throw new Error("Skip must have the same sequence length as input");if(t.dims.length!==1)throw new Error("Gamma must be 1D");if(t.dims[t.dims.length-1]!==o)throw new Error("Gamma must have the same hidden size as input");if(r.length>3){let u=r[3];if(u.dims.length!==1)throw new Error("Beta must be 1D");if(u.dims[u.dims.length-1]!==o)throw new Error("Beta must have the same hidden size as input")}if(r.length>4){let u=r[4];if(u.dims.length!==1)throw new Error("Bias must be 1D");if(u.dims[u.dims.length-1]!==o)throw new Error("Bias must have the same hidden size as input")}},z1=(r,e,n,t)=>{let o=r[0].dims,i=V.size(o),u=o,a=i,s=o.slice(-1)[0],l=t?o.slice(0,-1).concat(1):[],d=r.length>3,f=r.length>4,p=t&&n>1,g=t&&n>2,b=n>3,y=bt(s),_=[W("x",r[0].dataType,r[0].dims,y),W("skip",r[1].dataType,r[1].dims,y),W("gamma",r[2].dataType,r[2].dims,y)];d&&_.push(W("beta",r[3].dataType,r[3].dims,y)),f&&_.push(W("bias",r[4].dataType,r[4].dims,y)),_.push(te("output",r[0].dataType,u,y)),p&&_.push(te("meanOutput",1,l)),g&&_.push(te("invStdOutput",1,l)),b&&_.push(te("inputSkipBiasSum",r[0].dataType,u,y));let x=et(r[0].dataType),S=C=>`
      const hiddenSize: f32 = ${s};
      const hiddenSizeVectorized: u32 = ${s/y};
      const epsilon: f32 = ${e.epsilon};

      ${C.declareVariables(..._)}

      ${C.mainStart()}
        ${C.guardAgainstOutOfBoundsWorkgroupSizes(a/s)}
        let offset = global_idx * hiddenSizeVectorized;
        var sum = ${At("f32",y)};
        var squareSum = ${At("f32",y)};
        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {
          let skipValue = skip[offset + i];
          let biasValue = ${f?"bias[i]":"0.0"};
          let inputValue = x[offset + i];
          let value = inputValue + skipValue + biasValue;
          ${b?"inputSkipBiasSum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32Value = ${rr(x,y,"value")};
          sum += f32Value;
          squareSum += f32Value * f32Value;
        }
        let mean = ${zt("sum",y)} / hiddenSize;
        let variance = sqrt(${zt("squareSum",y)} / hiddenSize - mean * mean + epsilon);
        ${p?"meanOutput[global_idx] = mean;":""}
        ${g?"invStdOutput[global_idx] = 1.0 / variance;":""}
        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {
          output[offset + i] = (output[offset + i] - ${x}(mean)) / ${x}(variance) * gamma[i]
           + ${d?"beta[i]":"0.0"};
        }
      }`,O=[{dims:u,dataType:r[0].dataType}];return n>1&&O.push({dims:l,dataType:1}),n>2&&O.push({dims:l,dataType:1}),n>3&&O.push({dims:o,dataType:r[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:e.cacheKey},getShaderSource:S,getRunData:()=>({outputs:O,dispatchGroup:{x:Math.ceil(a/s/64)}})}},Pb=(r,e)=>{L1(r.inputs);let t=[0];r.outputCount>1&&t.push(-3),r.outputCount>2&&t.push(-3),r.outputCount>3&&t.push(3),r.compute(z1(r.inputs,e,r.outputCount,!1),{outputs:t})},kb=r=>{let e=r.epsilon;return ge({epsilon:e})}});var N1,la,F1,Bb,V1,G1,Rb,Mb,Lb=R(()=>{"use strict";ut();Re();ot();ke();N1=(r,e)=>{if(!r||r.length<1)throw new Error("too few inputs");if(e.axes.length!==0){if(e.axes.length!==e.starts.length||e.axes.length!==e.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(e.starts.length!==e.ends.length)throw new Error("starts and ends must have the same length");r.slice(1).forEach((n,t)=>{if(r[t+1].dataType!==6&&r[t+1].dataType!==7)throw new Error(`Input ${t} must be an array of int32 or int64`)})},la=(r,e)=>{let n=[];if(r.length>e)if(r[e].dataType===7)r[e].getBigInt64Array().forEach(t=>n.push(Number(t)));else if(r[e].dataType===6)r[e].getInt32Array().forEach(t=>n.push(Number(t)));else throw new Error(`Input ${e} must be an array of int32 or int64`);return n},F1=(r,e)=>{if(r.length>1){let n=la(r,1),t=la(r,2),o=la(r,3);return o.length===0&&(o=[...Array(r[0].dims.length).keys()]),ge({starts:n,ends:t,axes:o})}else return e},Bb=(r,e,n,t,o)=>{let i=r;return r<0&&(i+=n[t[e]]),o[e]<0?Math.max(0,Math.min(i,n[t[e]]-1)):Math.max(0,Math.min(i,n[t[e]]))},V1=(r,e,n)=>`fn calculateInputIndices(output_indices: ${e.type.indices}) -> ${r.type.indices} {
          var input_indices: ${r.type.indices};
          var carry = 0u;
          for (var i = ${n.length}; i >= 0; i--) {
            let input_shape_i = ${qe("uniforms.input_shape","i",n.length)};
            let steps_i = ${qe("uniforms.steps","i",n.length)};
            let signs_i = ${qe("uniforms.signs","i",n.length)};
            let starts_i = ${qe("uniforms.starts","i",n.length)};
            var output_index = ${e.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${r.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,G1=(r,e)=>{let n=r[0].dims,t=V.size(n),o=e.axes.length>0?V.normalizeAxes(e.axes,n.length):[...Array(n.length).keys()],i=la(r,4);i.forEach(x=>x!==0||(()=>{throw new Error("step cannot be 0")})),i.length===0&&(i=Array(o.length).fill(1));let u=e.starts.map((x,S)=>Bb(x,S,n,o,i)),a=e.ends.map((x,S)=>Bb(x,S,n,o,i));if(o.length!==u.length||o.length!==a.length)throw new Error("start, ends and axes should have the same number of elements");if(o.length!==n.length)for(let x=0;x<n.length;++x)o.includes(x)||(u.splice(x,0,0),a.splice(x,0,n[x]),i.splice(x,0,1));let s=i.map(x=>Math.sign(x));i.forEach((x,S,O)=>{if(x<0){let C=(a[S]-u[S])/x,N=u[S],k=N+C*i[S];u[S]=k,a[S]=N,O[S]=-x}});let l=n.slice(0);o.forEach((x,S)=>{l[x]=Math.ceil((a[x]-u[x])/i[x])});let d={dims:l,dataType:r[0].dataType},f=te("output",r[0].dataType,l.length),p=W("input",r[0].dataType,r[0].dims.length),g=V.size(l),b=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:u.length},{name:"signs",type:"i32",length:s.length},{name:"steps",type:"u32",length:i.length}],y=[{type:"uint32",data:g},{type:"uint32",data:u},{type:"int32",data:s},{type:"uint32",data:i},...ee(r[0].dims),...ee(l)],_=x=>`
      ${x.registerUniforms(b).declareVariables(p,f)}
        ${V1(p,f,n)}
        ${x.mainStart()}
          ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${f.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${f.setByOffset("global_idx",p.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${s.length}_${u.length}_${i.length}`,inputDependencies:["rank"]},getShaderSource:_,getRunData:()=>({outputs:[d],dispatchGroup:{x:Math.ceil(t/64)},programUniforms:y})}},Rb=(r,e)=>{N1(r.inputs,e);let n=F1(r.inputs,e);r.compute(G1(r.inputs,n),{inputs:[0]})},Mb=r=>{let e=r.starts,n=r.ends,t=r.axes;return ge({starts:e,ends:n,axes:t})}});var U1,W1,zb,Nb,Fb=R(()=>{"use strict";Re();ot();ke();U1=r=>{if(!r||r.length!==1)throw new Error("Softmax op requires 1 input.")},W1=(r,e)=>{let n=r.dims,t=V.size(n),o=64,i=e.axis;if(i<0&&(i=n.length+i),i<n.length-1)throw new Error("softmax only supports last axis for now.");let u=n[i],a=t/u,s=bt(u),l=u/s,d=(_,x)=>x===4?`max(max(${_}.x, ${_}.y), max(${_}.z, ${_}.w))`:x===2?`max(${_}.x, ${_}.y)`:x===3?`max(max(${_}.x, ${_}.y), ${_}.z)`:_,f=W("x",r.dataType,r.dims,s),p=te("result",r.dataType,r.dims,s),g=f.type.value,b=et(r.dataType)==="f32"?`var threadMax = ${g}(-3.402823e+38f);`:`var threadMax = ${g}(-65504.0h);`,y=_=>`
      var<workgroup> rowMaxShared : ${g};
      var<workgroup> rowSumShared : ${g};
      var<workgroup> threadShared : array<${g}, ${o}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${g} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${g}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${_.registerUniform("packedCols","i32").declareVariables(f,p)}
      ${_.mainStart()}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${o};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${b}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${g}(${d("threadShared[0]",s)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${g}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${g}(${zt("threadShared[0]",s)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`;return{name:"Softmax",shaderCache:{hint:`${s}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:n,dataType:r.dataType}],dispatchGroup:{x:a},programUniforms:[{type:"uint32",data:l}]}),getShaderSource:y}},zb=(r,e)=>{U1(r.inputs),r.compute(W1(r.inputs[0],e))},Nb=r=>ge({axis:r.axis})});var H1,q1,j1,K1,Y1,Vb,Gb,Ub=R(()=>{"use strict";Re();ot();ke();H1=r=>{if(!r||r.length<1)throw new Error("too few inputs")},q1=(r,e)=>{let n=[],t=e.numOutputs;return r[1].dims[0]>0&&(r[1].getBigInt64Array().forEach(o=>n.push(Number(o))),t=n.length),ge({numOutputs:t,axis:e.axis,splitSizes:n})},j1=r=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${r}u; i += 1u ) {
    if (index < ${qe("uniforms.size_in_split_axis","i",r)}) {
        return i;
    }
    }
    return ${r}u;
}`,K1=r=>{let e=r.length,n=[];for(let t=0;t<e;++t){let o=r[t].setByIndices("indices","input[global_idx]");e===1?n.push(o):t===0?n.push(`if (output_number == ${t}u) { ${o} }`):t===e-1?n.push(`else { ${o} }`):n.push(`else if (output_number == ${t}) { ${o} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${r[0].type.indices}, global_idx: u32) {
        ${n.join(`
`)}
      }`},Y1=(r,e)=>{let n=r[0].dims,t=V.size(n),o=r[0].dataType,i=V.normalizeAxis(e.axis,n.length),u=new Array(e.numOutputs),a=W("input",o,n),s=new Array(e.numOutputs),l=[],d=[],f=0,p=[{type:"uint32",data:t}];for(let b=0;b<e.numOutputs;b++){f+=e.splitSizes[b],s[b]=f;let y=n.slice();y[e.axis]=e.splitSizes[b],d.push(y),u[b]=te(`output${b}`,o,y),l.push({dims:d[b],dataType:r[0].dataType})}p.push({type:"uint32",data:s}),p.push(...ee(n)),d.forEach(b=>p.push(...ee(b)));let g=b=>`
  ${b.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",s.length).declareVariables(a,...u)}
  ${j1(s.length)}
  ${K1(u)}

  ${b.mainStart()}
    ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${a.offsetToIndices("global_idx")};
    var index = ${a.indicesGet("indices",i)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${qe("uniforms.size_in_split_axis","output_number - 1u",s.length)};
      ${a.indicesSet("indices",i,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:e.cacheKey,inputDependencies:["rank"]},getShaderSource:g,getRunData:()=>({outputs:l,dispatchGroup:{x:Math.ceil(t/64)},programUniforms:p})}},Vb=(r,e)=>{H1(r.inputs);let n=r.inputs.length===1?e:q1(r.inputs,e);r.compute(Y1(r.inputs,n),{inputs:[0]})},Gb=r=>{let e=r.axis,n=r.splitSizes,t=r.numOutputs<0?n.length:r.numOutputs;if(t!==n.length)throw new Error("numOutputs and splitSizes lengh must be equal");return ge({axis:e,numOutputs:t,splitSizes:n})}});var Wb,X1,Z1,J1,Hb,qb=R(()=>{"use strict";ut();Re();ke();Wb=r=>Array.from(r.getBigInt64Array(),Number),X1=r=>{if(!r||r.length!==2)throw new Error("Tile requires 2 inputs.");if(r[0].dataType!==1&&r[0].dataType!==6&&r[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(r[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(r[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(Wb(r[1]).length!==r[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Z1=(r,e)=>{let n=[];for(let t=0;t<r.length;++t)n.push(r[t]*e[t]);return n},J1=r=>{let e=r[0].dims,n=Wb(r[1]),t=Z1(e,n),o=V.size(t),i=r[0].dataType,u=W("input",i,e.length),a=te("output",i,t.length),s=l=>`
      const inputShape = ${u.indices(...e)};
      ${l.registerUniform("output_size","u32").declareVariables(u,a)}
      ${l.mainStart()}
      ${l.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${a.offsetToIndices("global_idx")};
      var input_indices: ${u.type.indices};
      for (var i = 0; i < ${e.length}; i++) {
        let input_dim_i = ${u.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${a.indicesGet("output_indices","i")}  % input_dim_i;

        ${u.indicesSet("input_indices","i","input_dim_value")}
      }
      ${a.setByOffset("global_idx",u.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${n}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:t,dataType:r[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:[{type:"uint32",data:o},...ee(r[0].dims),...ee(t)]}),getShaderSource:s}},Hb=r=>{X1(r.inputs),r.compute(J1(r.inputs),{inputs:[0]})}});var Q1,e$,jb,Kb=R(()=>{"use strict";ut();Re();ke();Q1=(r,e,n,t,o)=>{let i=te("output_data",o,n.length,4),u=W("a_data",e[1].dataType,e[1].dims.length,4),a=W("b_data",e[2].dataType,e[2].dims.length,4),s=W("c_data",e[0].dataType,e[0].dims.length,4),l,d=(f,p,g)=>`select(${p}, ${f}, ${g})`;if(!t)l=i.setByOffset("global_idx",d(u.getByOffset("global_idx"),a.getByOffset("global_idx"),s.getByOffset("global_idx")));else{let f=(p,g,b="")=>{let y=`a_data[index_a${g}][component_a${g}]`,_=`b_data[index_b${g}][component_b${g}]`,x=`bool(c_data[index_c${g}] & ${4278190080>>>(3-g)*8}u)`;return`
            let output_indices${g} = ${i.offsetToIndices(`global_idx * 4u + ${g}u`)};
            let offset_a${g} = ${u.broadcastedIndicesToOffset(`output_indices${g}`,i)};
            let offset_b${g} = ${a.broadcastedIndicesToOffset(`output_indices${g}`,i)};
            let offset_c${g} = ${s.broadcastedIndicesToOffset(`output_indices${g}`,i)};
            let index_a${g} = offset_a${g} / 4u;
            let index_b${g} = offset_b${g} / 4u;
            let index_c${g} = offset_c${g} / 4u;
            let component_a${g} = offset_a${g} % 4u;
            let component_b${g} = offset_b${g} % 4u;
            ${p}[${g}] = ${b}(${d(y,_,x)});
          `};o===9?l=`
            var data = vec4<u32>(0);
            ${f("data",0,"u32")}
            ${f("data",1,"u32")}
            ${f("data",2,"u32")}
            ${f("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:l=`
            ${f("output_data[global_idx]",0)}
            ${f("output_data[global_idx]",1)}
            ${f("output_data[global_idx]",2)}
            ${f("output_data[global_idx]",3)}
          `}return`
        ${r.registerUniform("vec_size","u32").declareVariables(s,u,a,i)}
        ${r.mainStart()}
        ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${l}
      }`},e$=r=>{let e=r[1].dims,n=r[2].dims,t=r[0].dims,o=r[1].dataType,i=!(V.areEqual(e,n)&&V.areEqual(n,t)),u=e,a=V.size(e),s=Math.ceil(a/4);if(i){let l=hr.calcShape(hr.calcShape(e,n,!1),t,!1);if(!l)throw new Error("Can't perform where op on the given tensors");u=l,a=V.size(u)}return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:l=>Q1(l,r,u,i,o),getRunData:()=>({outputs:[{dims:u,dataType:o}],dispatchGroup:{x:Math.ceil(a/64/4)},programUniforms:[{type:"uint32",data:s},...ee(t),...ee(e),...ee(n),...ee(u)]})}},jb=r=>{r.compute(e$(r.inputs))}});var Yb,Xb=R(()=>{"use strict";gm();Xs();wm();$m();tg();fg();mg();tu();Eg();kg();Lg();Fg();Ug();qg();Yg();Jg();tb();nu();ib();ub();Sb();Ab();Zi();Cb();Db();Lb();Fb();Ub();qb();Bn();Zs();Kb();Yb=new Map([["Abs",[Tm]],["Acos",[_m]],["Acosh",[Sm]],["Add",[rg]],["ArgMax",[mm,Ys]],["ArgMin",[hm,Ys]],["Asin",[Im]],["Asinh",[Am]],["Atan",[Om]],["Atanh",[Em]],["Attention",[ym,bm]],["AveragePool",[gb,mb]],["BatchNormalization",[vm]],["BiasAdd",[xm]],["BiasSplitGelu",[eg]],["Cast",[Pm,Cm]],["Ceil",[Dm]],["Clip",[km]],["Concat",[pg,hg]],["Conv",[iu,ou]],["ConvTranspose",[Og,Ag]],["Cos",[Bm]],["Cosh",[Rm]],["CumSum",[Cg,Pg]],["Div",[ng]],["Einsum",[Rg,Mg]],["Elu",[Mm,ea]],["Equal",[og]],["Erf",[Lm]],["Exp",[zm]],["Expand",[Ng]],["Floor",[Nm]],["FusedConv",[iu,ou]],["Gather",[Gg,Vg]],["GatherElements",[Hg,Wg]],["Gelu",[Fm]],["Gemm",[jg,Kg]],["GlobalAveragePool",[vb,yb]],["GlobalMaxPool",[_b,Tb]],["Greater",[ug]],["GreaterOrEqual",[dg]],["InstanceNormalization",[Zg,Xg]],["LayerNormalization",[eb,Qg]],["LeakyRelu",[Vm,ea]],["Less",[lg]],["LessOrEqual",[cg]],["Log",[Qm]],["MatMul",[wg]],["MaxPool",[xb,$b]],["Mul",[ig]],["MultiHeadAttention",[ob,nb]],["Neg",[Um]],["Not",[Gm]],["Pad",[ab,sb]],["Pow",[ag]],["Range",[Ib]],["Reciprocal",[Wm]],["ReduceMin",[um]],["ReduceMean",[nm]],["ReduceMax",[sm]],["ReduceSum",[dm]],["ReduceProd",[lm]],["ReduceL1",[om]],["ReduceL2",[im]],["ReduceLogSum",[fm]],["ReduceLogSumExp",[am]],["ReduceSumSquare",[cm]],["Relu",[Hm]],["Resize",[Ob,Eb]],["Sigmoid",[qm]],["Sin",[jm]],["Sinh",[Km]],["Slice",[Rb,Mb]],["SkipLayerNormalization",[Pb,kb]],["Split",[Vb,Gb]],["Sqrt",[Ym]],["Softmax",[zb,Nb]],["Sub",[sg]],["Tan",[Xm]],["Tanh",[Zm]],["ThresholdedRelu",[Jm,ea]],["Tile",[Hb]],["Transpose",[Wh,Hh]],["Where",[jb]]])});var da,Zb=R(()=>{"use strict";ut();Nr();ke();da=class{constructor(e){this.backend=e;this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,n){this.repo.set(e,n)}run(e,n,t,o,i,u,a){let s=this.backend.device,l=this.backend.getComputePassEncoder();l.setPipeline(e.computePipeline);let d=[];for(let p of o)d.push({binding:d.length,resource:{buffer:p.buffer}});for(let p of i)d.push({binding:d.length,resource:{buffer:p.buffer}});a&&d.push({binding:d.length,resource:a});let f=s.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:d,label:e.programInfo.name});if(l.setBindGroup(0,f),l.dispatchWorkgroups(...u),this.backend.pendingDispatchNumber++,this.backend.isQueryEnabled()){typeof this.backend.queryData>"u"&&(this.backend.queryData=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let p=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.querySet,0,2,this.backend.queryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.queryData.buffer,0,p.buffer,0,this.backend.querySetCount*8),this.backend.flush();let g=this.backend.currentKernelId,b=this.backend.kernels.get(g);p.buffer.mapAsync(GPUMapMode.READ).then(()=>{let y=new BigUint64Array(p.buffer.getMappedRange()),[_,x]=y,[S,O]=b;p.buffer.unmap(),typeof this.backend.queryTimeBase>"u"&&(this.backend.queryTimeBase=_);let C=Number(_-this.backend.queryTimeBase),N=Number(x-this.backend.queryTimeBase);if(!Number.isSafeInteger(C)||!Number.isSafeInteger(N))throw new RangeError("incorrect timestamp range");if(this.backend.gpuDataManager.release(p.id),this.backend.env.webgpu.profiling?.ondata)this.backend.env.webgpu.profiling.ondata({version:1,inputsMetadata:n.map(k=>({dims:k.dims,dataType:ln(k.dataType)})),outputsMetadata:t.map(k=>({dims:k.dims,dataType:ln(k.dataType)})),kernelId:g,kernelType:S,kernelName:O,startTime:C,endTime:N});else{let k="";n.forEach((G,H)=>{k+=`input[${H}]: [${G.dims}] | ${ln(G.dataType)}, `});let U="";t.forEach((G,H)=>{U+=`output[${H}]: [${G.dims}] | ${ln(G.dataType)}, `}),console.log(`[profiling] kernel "${g}|${O}|${e.programInfo.name}" ${k}${U}execution time: ${N-C} ns`)}})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(e,n){let t=this.backend.device,o=[];t.features.has("shader-f16")&&o.push("enable f16;");let i=Gh(n),u=e.getShaderSource(i),a=`${o.join(`
`)}
${i.additionalImplementations}
${u}`,s=t.createShaderModule({code:a,label:e.name});nt("verbose",()=>`[WebGPU] ${e.name} shader code: ${a}`);let l=t.createComputePipeline({compute:{module:s,entryPoint:"main"},layout:"auto",label:e.name});return{programInfo:e,computePipeline:l}}normalizeDispatchGroupSize(e){let n=typeof e=="number"?e:e.x,t=typeof e=="number"?1:e.y||1,o=typeof e=="number"?1:e.z||1,i=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(n<=i&&t<=i&&o<=i)return[n,t,o];let u=n*t*o,a=Math.ceil(Math.sqrt(u));if(a>i){if(a=Math.ceil(Math.cbrt(u)),a>i)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[a,a,a]}else return[a,a,1]}}});var t$,r$,ca,Jb=R(()=>{"use strict";Nr();Lh();Vh();Xb();Zb();t$=(r,e)=>{if(e.length!==r.length)throw new Error(`inputDependencies length ${e.length} is not equal to inputTensors length ${r.length}.`);let n=[];for(let t=0;t<r.length;++t){let o=r[t].dataType;switch(e[t]){case"none":{n.push("");break}case"type":{n.push(`${o}`);break}case"rank":{let i=r[t].dims.length;n.push(`${o};${i}`);break}case"dims":{let i=r[t].dims.join(",");n.push(`${o};${i}`);break}default:throw new Error(`unsupported input dependency: ${e[t]}`)}}return n.join("|")},r$=(r,e,n)=>{let t=r.name;return r.shaderCache?.hint&&(t+="["+r.shaderCache.hint+"]"),t+=":"+n+`:${t$(e,r.shaderCache?.inputDependencies??new Array(e.length).fill("dims"))}`,t},ca=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispatchNumber=0;this.querySetCount=2;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(e,n){this.env=e;let t=[],o={requiredLimits:{maxComputeWorkgroupStorageSize:n.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:n.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:n.limits.maxStorageBufferBindingSize,maxBufferSize:n.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:n.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:n.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:n.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:n.limits.maxComputeWorkgroupSizeZ},requiredFeatures:t};n.features.has("timestamp-query")&&t.push("timestamp-query"),n.features.has("shader-f16")&&t.push("shader-f16"),this.device=await n.requestDevice(o),this.gpuDataManager=Fh(this),this.programManager=new da(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Rh(e.logLevel,!!e.debug),this.device.onuncapturederror=i=>{i.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${i.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let e={};this.isQueryEnabled()&&(typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),e.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(e)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}isQueryEnabled(){return this.device.features.has("timestamp-query")&&(this.env.webgpu.profiling?.mode==="default"||!this.env.webgpu.profiling?.mode&&this.env.webgpu.profilingMode==="default")}run(e,n,t,o,i){let u=[];for(let S=0;S<n.length;++S){let O=this.gpuDataManager.get(n[S].data);if(!O)throw new Error(`no GPU data for input: ${n[S].data}`);u[S]=O}let{outputs:a,dispatchGroup:s,programUniforms:l}=e.getRunData(n),d=t.length===0?a.map((S,O)=>O):t;if(d.length!==a.length)throw new Error(`Output size ${d.length} must be equal to ${a.length}.`);let f=[],p=[];for(let S=0;S<a.length;++S){if(!Number.isInteger(d[S])||d[S]<-3||d[S]>=a.length)throw new Error(`Invalid output index: ${d[S]}`);if(d[S]===-3)continue;let O=d[S]===-1,C=d[S]===-2,N=O||C?i(a[S].dataType,a[S].dims):o(d[S],a[S].dataType,a[S].dims),k=this.gpuDataManager.get(N.data);if(!k)throw new Error(`no GPU data for output: ${N.data}`);if(O&&this.temporaryData.push(k),C){let U=this.kernelPersistentData.get(this.currentKernelId);U||(U=[],this.kernelPersistentData.set(this.currentKernelId,U)),U.push(k)}f.push(N),p.push(k)}let g;if(l){let S=0,O=[];l.forEach(U=>{let G=typeof U.data=="number"?[U.data]:U.data;if(G.length===0)return;let H=G.length<=2?G.length*4:16;S=Math.ceil(S/H)*H,O.push(S),S+=G.length>4?Math.ceil(G.length/4)*16:G.length*4});let C=16;S=Math.ceil(S/C)*C;let N=new ArrayBuffer(S);l.forEach((U,G)=>{let H=O[G],ne=typeof U.data=="number"?[U.data]:U.data;U.type==="int32"?new Int32Array(N,H,ne.length).set(ne):U.type==="uint32"?new Uint32Array(N,H,ne.length).set(ne):new Float32Array(N,H,ne.length).set(ne)});let k=this.gpuDataManager.create(S,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(k.buffer,0,N,0,S),this.gpuDataManager.release(k.id),g={offset:0,size:S,buffer:k.buffer}}let b=this.programManager.normalizeDispatchGroupSize(s),y=b[1]===1&&b[2]===1,_=r$(e,n,y),x=this.programManager.getArtifact(_);return x||(x=this.programManager.build(e,b),this.programManager.setArtifact(_,x),nt("info",()=>`[artifact] key: ${_}, programName: ${e.name}`)),nt("info",()=>`[ProgramManager] run "${e.name}" (key=${_}) with ${b[0]}x${b[1]}x${b[2]}`),this.programManager.run(x,n,f,u,p,b,g),f}upload(e,n){this.gpuDataManager.upload(e,n)}memcpy(e,n){this.gpuDataManager.memcpy(e,n)}async download(e,n){await this.gpuDataManager.download(e,n)}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,n,t,o){let i=Yb.get(e);if(!i)throw new Error(`kernel not implemented: ${e}`);this.kernels.set(n,[e,o,i[0],[i[1],t]])}releaseKernel(e){let n=this.kernelPersistentData.get(e);if(n){for(let t of n)this.gpuDataManager.release(t.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,n,t){let o=this.kernels.get(e);if(!o)throw new Error(`kernel not created: ${e}`);let[i,u,a,s]=o;if(this.currentKernelId!==null)throw new Error(`kernel "[${i}] ${u}" is not allowed to be called recursively`);this.currentKernelId=e,s[0]&&(s[1]=s[0](s[1]),s[0]=void 0),nt("info",()=>`[WebGPU] Start to run kernel "[${i}] ${u}"...`);let l=this.env.debug;this.temporaryData=[];try{return l&&this.device.pushErrorScope("validation"),a(n,s[1]),0}catch(d){return t.push(Promise.resolve(`[WebGPU] Kernel "[${i}] ${u}" failed. ${d}`)),1}finally{l&&t.push(this.device.popErrorScope().then(d=>d?`GPU validation error for kernel "[${i}] ${u}": ${d.message}`:null));for(let d of this.temporaryData)this.gpuDataManager.release(d.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(e,n,t,o){let i=this.sessionExternalDataMapping.get(e);i||(i=new Map,this.sessionExternalDataMapping.set(e,i));let u=i.get(n),a=this.gpuDataManager.registerExternalBuffer(t,o,u?.[1]);return i.set(n,[a,t]),a}unregisterBuffers(e){let n=this.sessionExternalDataMapping.get(e);n&&(n.forEach(t=>this.gpuDataManager.unregisterExternalBuffer(t[1])),this.sessionExternalDataMapping.delete(e))}getBuffer(e){let n=this.gpuDataManager.get(e);if(!n)throw new Error(`no GPU data for buffer: ${e}`);return n.buffer}createDownloader(e,n,t){return async()=>{let o=await Gs(this,e,n);return Mh(o.buffer,t)}}}});var Qb={};kr(Qb,{init:()=>n$});var To,cu,n$,ey=R(()=>{"use strict";ut();Jb();Nr();Re();To=class r{constructor(e,n,t,o){this.module=e;this.dataType=n;this.data=t;this.dims=o}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let e=V.size(this.dims);return e===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let e=V.size(this.dims);return e===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let e=V.size(this.dims);return e===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}reshape(e){if(V.size(e)!==V.size(this.dims))throw new Error("Invalid new shape");return new r(this.module,this.dataType,this.data,e)}},cu=class{constructor(e,n,t){this.module=e;this.backend=n;this.customDataOffset=0;this.customDataSize=0;let o=e.HEAPU32,i=t>>2;this.opKernelContext=o[i++];let u=o[i++];this.outputCount=o[i++],this.customDataOffset=o[i++],this.customDataSize=o[i++];let a=[];for(let s=0;s<u;s++){let l=o[i++],d=o[i++],f=o[i++],p=[];for(let g=0;g<f;g++)p.push(o[i++]);a.push(new To(e,l,d,p))}this.inputs=a}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(e,n){let t=n?.inputs?.map(a=>typeof a=="number"?this.inputs[a]:a)??this.inputs,o=n?.outputs??[],i=(a,s,l)=>new To(this.module,s,this.output(a,l),l),u=(a,s)=>{let l=yo(a);if(!l)throw new Error(`Unsupported data type: ${a}`);let d=l*V.size(s);return new To(this.module,a,this.backend.gpuDataManager.create(d).id,s)};return this.backend.run(e,t,o,i,u)}output(e,n){let t=this.module.stackSave();try{let o=this.module.stackAlloc((1+n.length)*4),i=o>>2;this.module.HEAPU32[i++]=n.length;for(let u=0;u<n.length;u++)this.module.HEAPU32[i++]=n[u];return this.module._JsepOutput(this.opKernelContext,e,o)}catch(o){throw new Error(`Failed to generate kernel's output[${e}] with dims [${n}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${o}`)}finally{this.module.stackRestore(t)}}},n$=async(r,e,n)=>{let t=r.jsepInit;if(!t)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");let o=new ca;await o.initialize(e,n),t(o,i=>o.alloc(i),i=>o.free(i),(i,u,a,s=!1)=>{if(s)nt("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${i}, dst=${u}, size=${a}`),o.memcpy(i,u);else{nt("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${i}, gpuDataId=${u}, size=${a}`);let l=r.HEAPU8.subarray(i,i+a);o.upload(u,l)}},async(i,u,a)=>{nt("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${i}, dataOffset=${u}, size=${a}`),await o.download(i,()=>r.HEAPU8.subarray(u,u+a))},(i,u,a)=>o.createKernel(i,u,a,e.debug||o.isQueryEnabled()?r.UTF8ToString(r._JsepGetNodeName(u)):`${u}`),i=>o.releaseKernel(i),(i,u,a,s)=>{nt("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${a}, kernel=${i}, contextDataOffset=${u}`);let l=new cu(r,o,u);return o.computeKernel(i,l,s)})}});var o$,ry,ny,_o,i$,fu,oy,iy,ty,ay,sy,uy,ly=R(()=>{"use strict";Ch();kh();ut();kn();Gi();o$=(r,e)=>{st()._OrtInit(r,e)!==0&&Qe("Can't initialize onnxruntime.")},ry=async r=>{o$(r.wasm.numThreads,vo(r.logLevel))},ny=async(r,e)=>{if(e==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let n=await navigator.gpu.requestAdapter();if(!n)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.');if(!r.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using `webgpu` EP");let t=(ey(),Sr(Qb)).init;await t(st(),r,n)}},_o=new Map,i$=r=>{let e=st(),n=e.stackSave();try{let t=e.stackAlloc(8);return e._OrtGetInputOutputCount(r,t,t+4)!==0&&Qe("Can't get session input/output count."),[e.HEAP32[t/4],e.HEAP32[t/4+1]]}finally{e.stackRestore(n)}},fu=r=>{let e=st(),n=e._malloc(r.byteLength);if(n===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${r.byteLength}.`);return e.HEAPU8.set(r,n),[n,r.byteLength]},oy=(r,e)=>{let n,t,o=st();Array.isArray(r)?[n,t]=r:r.buffer===o.HEAPU8.buffer?[n,t]=[r.byteOffset,r.byteLength]:[n,t]=fu(r);let i=0,u=0,a=0,s=[],l=[],d=[];try{[u,s]=Ph(e),i=o._OrtCreateSession(n,t,u),i===0&&Qe("Can't create a session.");let[f,p]=i$(i),g=[],b=[],y=[];for(let x=0;x<f;x++){let S=o._OrtGetInputName(i,x);S===0&&Qe("Can't get an input name."),l.push(S),g.push(o.UTF8ToString(S))}for(let x=0;x<p;x++){let S=o._OrtGetOutputName(i,x);S===0&&Qe("Can't get an output name."),d.push(S);let O=o.UTF8ToString(S);b.push(O);{let C=typeof e?.preferredOutputLocation=="string"?e.preferredOutputLocation:e?.preferredOutputLocation?.[O]??"cpu";if(C!=="cpu"&&C!=="cpu-pinned"&&C!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${C}.`);y.push(C)}}let _=null;return y.some(x=>x==="gpu-buffer")&&(a=o._OrtCreateBinding(i),a===0&&Qe("Can't create IO binding."),_={handle:a,outputPreferredLocations:y,outputPreferredLocationsEncoded:y.map(x=>Fs(x))}),_o.set(i,[i,l,d,_]),[i,g,b]}catch(f){throw l.forEach(p=>o._OrtFree(p)),d.forEach(p=>o._OrtFree(p)),a!==0&&o._OrtReleaseBinding(a),i!==0&&o._OrtReleaseSession(i),f}finally{o._free(n),u!==0&&o._OrtReleaseSessionOptions(u),s.forEach(f=>o._free(f))}},iy=r=>{let e=st(),n=_o.get(r);if(!n)throw new Error(`cannot release session. invalid session id: ${r}`);let[t,o,i,u]=n;u&&e._OrtReleaseBinding(u.handle),e.jsepUnregisterBuffers?.(r),o.forEach(a=>e._OrtFree(a)),i.forEach(a=>e._OrtFree(a)),e._OrtReleaseSession(t),_o.delete(r)},ty=(r,e,n,t,o)=>{if(!r){e.push(0);return}let i=st(),u=r[0],a=r[1],s=r[3],l,d;if(u==="string"&&s==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(s==="gpu-buffer"){let g=r[2].gpuBuffer,b=yo(Ns(u));d=a.reduce((y,_)=>y*_,1)*b,l=i.jsepRegisterBuffer(t,o,g,d)}else{let g=r[2];if(Array.isArray(g)){d=4*g.length,l=i._malloc(d),n.push(l);let b=l/4;for(let y=0;y<g.length;y++){if(typeof g[y]!="string")throw new TypeError(`tensor data at index ${y} is not a string`);i.HEAPU32[b++]=pt(g[y],n)}}else d=g.byteLength,l=i._malloc(d),n.push(l),i.HEAPU8.set(new Uint8Array(g.buffer,g.byteOffset,d),l)}let f=i.stackSave(),p=i.stackAlloc(4*a.length);try{let g=p/4;a.forEach(y=>i.HEAP32[g++]=y);let b=i._OrtCreateTensor(Ns(u),l,d,p,a.length,Fs(s));b===0&&Qe(`Can't create tensor for input/output. session=${t}, index=${o}.`),e.push(b)}finally{i.stackRestore(f)}},ay=async(r,e,n,t,o,i)=>{let u=st(),a=_o.get(r);if(!a)throw new Error(`cannot run inference. invalid session id: ${r}`);let[s,l,d,f]=a,p=e.length,g=t.length,b=0,y=[],_=[],x=[],S=[],O=u.stackSave(),C=u.stackAlloc(p*4),N=u.stackAlloc(p*4),k=u.stackAlloc(g*4),U=u.stackAlloc(g*4);try{[b,y]=Eh(i);for(let ae=0;ae<p;ae++)ty(n[ae],_,S,r,e[ae]);for(let ae=0;ae<g;ae++)ty(o[ae],x,S,r,p+t[ae]);let G=C/4,H=N/4,ne=k/4,P=U/4;for(let ae=0;ae<p;ae++)u.HEAPU32[G++]=_[ae],u.HEAPU32[H++]=l[e[ae]];for(let ae=0;ae<g;ae++)u.HEAPU32[ne++]=x[ae],u.HEAPU32[P++]=d[t[ae]];if(f){let{handle:ae,outputPreferredLocations:De,outputPreferredLocationsEncoded:re}=f;if(l.length!==p)throw new Error(`input count from feeds (${p}) is expected to be always equal to model's input count (${l.length}).`);for(let Ce=0;Ce<p;Ce++){let Ne=e[Ce];await u._OrtBindInput(ae,l[Ne],_[Ce])!==0&&Qe(`Can't bind input[${Ce}] for session=${r}.`)}for(let Ce=0;Ce<g;Ce++){let Ne=t[Ce];o[Ce]?.[3]?u._OrtBindOutput(ae,d[Ne],x[Ce],0)!==0&&Qe(`Can't bind pre-allocated output[${Ce}] for session=${r}.`):u._OrtBindOutput(ae,d[Ne],0,re[Ne])!==0&&Qe(`Can't bind output[${Ce}] to ${De[Ce]} for session=${r}.`)}}let J;f?J=await u._OrtRunWithBinding(s,f.handle,g,k,b):J=await u._OrtRun(s,N,C,p,U,g,k,b),J!==0&&Qe("failed to call OrtRun().");let Te=[];for(let ae=0;ae<g;ae++){let De=u.HEAPU32[k/4+ae];if(De===x[ae]){Te.push(o[ae]);continue}let re=u.stackSave(),Ce=u.stackAlloc(4*4),Ne=!1,Se,$e=0;try{u._OrtGetTensorData(De,Ce,Ce+4,Ce+8,Ce+12)!==0&&Qe(`Can't access output tensor data on index ${ae}.`);let it=Ce/4,yt=u.HEAPU32[it++];$e=u.HEAPU32[it++];let K=u.HEAPU32[it++],fe=u.HEAPU32[it++],Ae=[];for(let at=0;at<fe;at++)Ae.push(u.HEAPU32[K/4+at]);u._OrtFree(K);let Tt=Ae.reduce((at,vt)=>at*vt,1);Se=ln(yt);let Dt=f?.outputPreferredLocations[t[ae]];if(Se==="string"){if(Dt==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let at=[],vt=$e/4;for(let Ot=0;Ot<Tt;Ot++){let or=u.HEAPU32[vt++],Nt=Ot===Tt-1?void 0:u.HEAPU32[vt]-or;at.push(u.UTF8ToString(or,Nt))}Te.push([Se,Ae,at,"cpu"])}else if(Dt==="gpu-buffer"&&Tt>0){let at=u.jsepGetBuffer($e),vt=yo(yt);if(vt===void 0||!Wi(Se))throw new Error(`Unsupported data type: ${Se}`);Ne=!0,Te.push([Se,Ae,{gpuBuffer:at,download:u.jsepCreateDownloader(at,Tt*vt,Se),dispose:()=>{u._OrtReleaseTensor(De)}},"gpu-buffer"])}else{let at=Ui(Se),vt=new at(Tt);new Uint8Array(vt.buffer,vt.byteOffset,vt.byteLength).set(u.HEAPU8.subarray($e,$e+vt.byteLength)),Te.push([Se,Ae,vt,"cpu"])}}finally{u.stackRestore(re),Se==="string"&&$e&&u._free($e),Ne||u._OrtReleaseTensor(De)}}return f&&u._OrtClearBoundOutputs(f.handle),Te}finally{u.stackRestore(O),_.forEach(G=>u._OrtReleaseTensor(G)),x.forEach(G=>u._OrtReleaseTensor(G)),S.forEach(G=>u._free(G)),b!==0&&u._OrtReleaseRunOptions(b),y.forEach(G=>u._free(G))}},sy=r=>{let e=st(),n=_o.get(r);if(!n)throw new Error("invalid session id");let t=n[0],o=e._OrtEndProfiling(t);o===0&&Qe("Can't get an profile file name."),e._OrtFree(o)},uy=r=>{let e=[];for(let n of r){let t=n[2];!Array.isArray(t)&&"buffer"in t&&e.push(t.buffer)}return e}});var dy=Ye((sM,s$)=>{s$.exports='/*!\n * ONNX Runtime Web v1.17.0\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n"use strict";(()=>{var mn=Object.defineProperty;var Uu=Object.getOwnPropertyDescriptor;var Wu=Object.getOwnPropertyNames;var Nu=Object.prototype.hasOwnProperty;var Y=(e,t)=>()=>(e&&(t=e(e=0)),t);var ir=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Pr=(e,t)=>{for(var r in t)mn(e,r,{get:t[r],enumerable:!0})},Hu=(e,t,r,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of Wu(t))!Nu.call(e,n)&&n!==r&&mn(e,n,{get:()=>t[n],enumerable:!(o=Uu(t,n))||o.enumerable});return e};var Ut=e=>Hu(mn({},"__esModule",{value:!0}),e);var fn={};Pr(fn,{readFile:()=>Gu});var Gu,hn=Y(()=>{Gu=void 0});var gn={};Pr(gn,{join:()=>Lu});var Lu,yn=Y(()=>{Lu=void 0});var wo=ir((bo,bn)=>{"use strict";var yo=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){var r=t,o,n;r.ready=new Promise((l,m)=>{o=l,n=m}),r.jsepInit=(l,m,b,C,O,F,H,de)=>{r.Za=l,r.Oa=m,r.Qa=b,r.Ja=C,r.Pa=O,r.ra=F,r.Ra=H,r.Sa=de,m=(X,oe,ee)=>(...ge)=>{let Se=Qe,k=oe?.();ge=X(...ge);let se=oe?.();return k!==se&&(X=se,ee(k),oe=ee=null),Qe!=Se?Sr():ge},b=X=>async(...oe)=>{try{if(r.Da)throw Error("Session already started");let ee=r.Da={Ta:oe[0],errors:[]},ge=await X(...oe);if(r.Da!==ee)throw Error("Session mismatch");l.flush();let Se=ee.errors;if(0<Se.length){let k=await Promise.all(Se);if(k=k.filter(se=>se),0<k.length)throw Error(k.join(`\n`))}return ge}finally{r.Da=null}},r._OrtRun=b(m(r._OrtRun,()=>r._OrtRun,X=>r._OrtRun=X)),r._OrtRunWithBinding=b(m(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,X=>r._OrtRunWithBinding=X)),r._OrtBindInput=m(r._OrtBindInput,()=>r._OrtBindInput,X=>r._OrtBindInput=X),r.jsepRegisterBuffer=(X,oe,ee,ge)=>l.registerBuffer(X,oe,ee,ge),r.jsepUnregisterBuffers=X=>{l.unregisterBuffers(X)},r.jsepGetBuffer=X=>l.getBuffer(X),r.jsepCreateDownloader=(X,oe,ee)=>l.createDownloader(X,oe,ee)};var s=Object.assign({},r),u="./this.program",d=(l,m)=>{throw m},a=typeof window=="object",p=typeof importScripts=="function",h=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",v="",g,w,y;if(h){var x=(hn(),Ut(fn)),A=(yn(),Ut(gn));v=p?A.dirname(v)+"/":__dirname+"/",g=(l,m)=>(l=l.startsWith("file://")?new URL(l):A.normalize(l),x.readFileSync(l,m?void 0:"utf8")),y=l=>(l=g(l,!0),l.buffer||(l=new Uint8Array(l)),l),w=(l,m,b,C=!0)=>{l=l.startsWith("file://")?new URL(l):A.normalize(l),x.readFile(l,C?void 0:"utf8",(O,F)=>{O?b(O):m(C?F.buffer:F)})},!r.thisProgram&&1<process.argv.length&&(u=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),d=(l,m)=>{throw process.exitCode=l,m},r.inspect=()=>"[Emscripten Module object]"}else(a||p)&&(p?v=self.location.href:typeof document<"u"&&document.currentScript&&(v=document.currentScript.src),e&&(v=e),v.indexOf("blob:")!==0?v=v.substr(0,v.replace(/[?#].*/,"").lastIndexOf("/")+1):v="",g=l=>{var m=new XMLHttpRequest;return m.open("GET",l,!1),m.send(null),m.responseText},p&&(y=l=>{var m=new XMLHttpRequest;return m.open("GET",l,!1),m.responseType="arraybuffer",m.send(null),new Uint8Array(m.response)}),w=(l,m,b)=>{var C=new XMLHttpRequest;C.open("GET",l,!0),C.responseType="arraybuffer",C.onload=()=>{C.status==200||C.status==0&&C.response?m(C.response):b()},C.onerror=b,C.send(null)});var $=r.print||console.log.bind(console),_=r.printErr||console.error.bind(console);Object.assign(r,s),s=null,r.thisProgram&&(u=r.thisProgram),r.quit&&(d=r.quit);var R;r.wasmBinary&&(R=r.wasmBinary);var I=r.noExitRuntime||!0;typeof WebAssembly!="object"&&He("no native wasm support detected");var z,T,N=!1,U,G,J,B,q,pe,Q;function we(){var l=z.buffer;r.HEAP8=G=new Int8Array(l),r.HEAP16=new Int16Array(l),r.HEAP32=B=new Int32Array(l),r.HEAPU8=J=new Uint8Array(l),r.HEAPU16=new Uint16Array(l),r.HEAPU32=q=new Uint32Array(l),r.HEAPF32=pe=new Float32Array(l),r.HEAPF64=Q=new Float64Array(l)}var Z=[],ye=[],Ce=[];function fe(){var l=r.preRun.shift();Z.unshift(l)}var ce=0,We=null,Be=null;function He(l){throw r.onAbort&&r.onAbort(l),l="Aborted("+l+")",_(l),N=!0,U=1,l=new WebAssembly.RuntimeError(l+". Build with -sASSERTIONS for more info."),n(l),l}function L(l){return l.startsWith("data:application/octet-stream;base64,")}var re;if(re="ort-wasm-simd.wasm",!L(re)){var he=re;re=r.locateFile?r.locateFile(he,v):v+he}function Fe(l){if(l==re&&R)return new Uint8Array(R);if(y)return y(l);throw"both async and sync fetching of the wasm failed"}function Ze(l){if(!R&&(a||p)){if(typeof fetch=="function"&&!l.startsWith("file://"))return fetch(l,{credentials:"same-origin"}).then(m=>{if(!m.ok)throw"failed to load wasm binary file at \'"+l+"\'";return m.arrayBuffer()}).catch(()=>Fe(l));if(w)return new Promise((m,b)=>{w(l,C=>m(new Uint8Array(C)),b)})}return Promise.resolve().then(()=>Fe(l))}function Me(l,m,b){return Ze(l).then(C=>WebAssembly.instantiate(C,m)).then(C=>C).then(b,C=>{_("failed to asynchronously prepare wasm: "+C),He(C)})}function Ge(l,m){var b=re;return R||typeof WebAssembly.instantiateStreaming!="function"||L(b)||b.startsWith("file://")||h||typeof fetch!="function"?Me(b,l,m):fetch(b,{credentials:"same-origin"}).then(C=>WebAssembly.instantiateStreaming(C,l).then(m,function(O){return _("wasm streaming compile failed: "+O),_("falling back to ArrayBuffer instantiation"),Me(b,l,m)}))}var Ke,nt={912720:l=>{r.ra("Abs",l,void 0)},912771:l=>{r.ra("Neg",l,void 0)},912822:l=>{r.ra("Floor",l,void 0)},912875:l=>{r.ra("Ceil",l,void 0)},912927:l=>{r.ra("Reciprocal",l,void 0)},912985:l=>{r.ra("Sqrt",l,void 0)},913037:l=>{r.ra("Exp",l,void 0)},913088:l=>{r.ra("Erf",l,void 0)},913139:l=>{r.ra("Sigmoid",l,void 0)},913194:l=>{r.ra("Log",l,void 0)},913245:l=>{r.ra("Sin",l,void 0)},913296:l=>{r.ra("Cos",l,void 0)},913347:l=>{r.ra("Tan",l,void 0)},913398:l=>{r.ra("Asin",l,void 0)},913450:l=>{r.ra("Acos",l,void 0)},913502:l=>{r.ra("Atan",l,void 0)},913554:l=>{r.ra("Sinh",l,void 0)},913606:l=>{r.ra("Cosh",l,void 0)},913658:l=>{r.ra("Asinh",l,void 0)},913711:l=>{r.ra("Acosh",l,void 0)},913764:l=>{r.ra("Atanh",l,void 0)},913817:l=>{r.ra("Tanh",l,void 0)},913869:l=>{r.ra("Not",l,void 0)},913920:(l,m,b)=>{r.ra("Clip",l,{min:m,max:b})},913989:l=>{r.ra("Clip",l,void 0)},914041:(l,m)=>{r.ra("Elu",l,{alpha:m})},914099:l=>{r.ra("Relu",l,void 0)},914151:(l,m)=>{r.ra("LeakyRelu",l,{alpha:m})},914215:(l,m)=>{r.ra("ThresholdedRelu",l,{alpha:m})},914285:(l,m)=>{r.ra("Cast",l,{to:m})},914343:l=>{r.ra("Add",l,void 0)},914394:l=>{r.ra("Sub",l,void 0)},914445:l=>{r.ra("Mul",l,void 0)},914496:l=>{r.ra("Div",l,void 0)},914547:l=>{r.ra("Pow",l,void 0)},914598:l=>{r.ra("Equal",l,void 0)},914651:l=>{r.ra("Greater",l,void 0)},914706:l=>{r.ra("GreaterOrEqual",l,void 0)},914768:l=>{r.ra("Less",l,void 0)},914820:l=>{r.ra("LessOrEqual",l,void 0)},914879:(l,m,b,C,O)=>{r.ra("ReduceMean",l,{keepDims:!!m,noopWithEmptyAxes:!!b,axes:C?Array.from(B.subarray(O>>>0,O+C>>>0)):[]})},915043:(l,m,b,C,O)=>{r.ra("ReduceMax",l,{keepDims:!!m,noopWithEmptyAxes:!!b,axes:C?Array.from(B.subarray(O>>>0,O+C>>>0)):[]})},915206:(l,m,b,C,O)=>{r.ra("ReduceMin",l,{keepDims:!!m,noopWithEmptyAxes:!!b,axes:C?Array.from(B.subarray(O>>>0,O+C>>>0)):[]})},915369:(l,m,b,C,O)=>{r.ra("ReduceProd",l,{keepDims:!!m,noopWithEmptyAxes:!!b,axes:C?Array.from(B.subarray(O>>>0,O+C>>>0)):[]})},915533:(l,m,b,C,O)=>{r.ra("ReduceSum",l,{keepDims:!!m,noopWithEmptyAxes:!!b,axes:C?Array.from(B.subarray(O>>>0,O+C>>>0)):[]})},915696:(l,m,b,C,O)=>{r.ra("ReduceL1",l,{keepDims:!!m,noopWithEmptyAxes:!!b,axes:C?Array.from(B.subarray(O>>>0,O+C>>>0)):[]})},915858:(l,m,b,C,O)=>{r.ra("ReduceL2",l,{keepDims:!!m,noopWithEmptyAxes:!!b,axes:C?Array.from(B.subarray(O>>>0,O+C>>>0)):[]})},916020:(l,m,b,C,O)=>{r.ra("ReduceLogSum",l,{keepDims:!!m,noopWithEmptyAxes:!!b,axes:C?Array.from(B.subarray(O>>>0,O+C>>>0)):[]})},916186:(l,m,b,C,O)=>{r.ra("ReduceSumSquare",l,{keepDims:!!m,noopWithEmptyAxes:!!b,axes:C?Array.from(B.subarray(O>>>0,O+C>>>0)):[]})},916355:(l,m,b,C,O)=>{r.ra("ReduceLogSumExp",l,{keepDims:!!m,noopWithEmptyAxes:!!b,axes:C?Array.from(B.subarray(O>>>0,O+C>>>0)):[]})},916524:l=>{r.ra("Where",l,void 0)},916577:(l,m,b)=>{r.ra("Transpose",l,{perm:m?Array.from(B.subarray(b>>>0,b+m>>>0)):[]})},916690:(l,m,b,C,O,F,H,de,X,oe,ee,ge,Se,k,se)=>{r.ra("ConvTranspose",l,{format:X?"NHWC":"NCHW",autoPad:m,dilations:[b],group:C,kernel_shape:[O],pads:[F,H],strides:[de],wIsConst:()=>!!G[oe>>>0],outputPadding:ee?Array.from(B.subarray(ge>>>0,ge+ee>>>0)):[],outputShape:Se?Array.from(B.subarray(k>>>0,k+Se>>>0)):[],activation:ze(se)})},917104:(l,m,b,C,O,F,H,de,X,oe,ee,ge,Se,k)=>{r.ra("ConvTranspose",l,{format:de?"NHWC":"NCHW",autoPad:m,dilations:Array.from(B.subarray(b>>>0,b+2>>>0)),group:C,kernelShape:Array.from(B.subarray(O>>>0,O+2>>>0)),pads:Array.from(B.subarray(F>>>0,F+4>>>0)),strides:Array.from(B.subarray(H>>>0,H+2>>>0)),wIsConst:()=>!!G[X>>>0],outputPadding:0<oe?Array.from(B.subarray(ee>>>0,ee+oe>>>0)):[],outputShape:0<ge?Array.from(B.subarray(Se>>>0,Se+ge>>>0)):[],activation:ze(k)})},917661:(l,m,b,C,O,F,H,de,X,oe,ee,ge,Se,k,se)=>{r.ra("ConvTranspose",l,{format:X?"NHWC":"NCHW",autoPad:m,dilations:[b],group:C,kernel_shape:[O],pads:[F,H],strides:[de],wIsConst:()=>!!G[oe>>>0],outputPadding:ee?Array.from(B.subarray(ge>>>0,ge+ee>>>0)):[],outputShape:Se?Array.from(B.subarray(k>>>0,k+Se>>>0)):[],activation:ze(se)})},918075:(l,m,b,C,O,F,H,de,X,oe,ee,ge,Se,k)=>{r.ra("ConvTranspose",l,{format:de?"NHWC":"NCHW",autoPad:m,dilations:Array.from(B.subarray(b>>>0,b+2>>>0)),group:C,kernelShape:Array.from(B.subarray(O>>>0,O+2>>>0)),pads:Array.from(B.subarray(F>>>0,F+4>>>0)),strides:Array.from(B.subarray(H>>>0,H+2>>>0)),wIsConst:()=>!!G[X>>>0],outputPadding:0<oe?Array.from(B.subarray(ee>>>0,ee+oe>>>0)):[],outputShape:0<ge?Array.from(B.subarray(Se>>>0,Se+ge>>>0)):[],activation:ze(k)})},918632:(l,m)=>{r.ra("GlobalAveragePool",l,{format:m?"NHWC":"NCHW"})},918723:(l,m,b,C,O,F,H,de,X,oe,ee,ge,Se,k,se,ve)=>{r.ra("AveragePool",l,{format:ve?"NHWC":"NCHW",auto_pad:m,ceil_mode:b,count_include_pad:C,storage_order:O,dilations:[F,H],kernel_shape:[de,X],pads:[oe,ee,ge,Se],strides:[k,se]})},919007:(l,m)=>{r.ra("GlobalAveragePool",l,{format:m?"NHWC":"NCHW"})},919098:(l,m,b,C,O,F,H,de,X,oe,ee,ge,Se,k,se,ve)=>{r.ra("AveragePool",l,{format:ve?"NHWC":"NCHW",auto_pad:m,ceil_mode:b,count_include_pad:C,storage_order:O,dilations:[F,H],kernel_shape:[de,X],pads:[oe,ee,ge,Se],strides:[k,se]})},919382:(l,m)=>{r.ra("GlobalMaxPool",l,{format:m?"NHWC":"NCHW"})},919469:(l,m,b,C,O,F,H,de,X,oe,ee,ge,Se,k,se,ve)=>{r.ra("MaxPool",l,{format:ve?"NHWC":"NCHW",auto_pad:m,ceil_mode:b,count_include_pad:C,storage_order:O,dilations:[F,H],kernel_shape:[de,X],pads:[oe,ee,ge,Se],strides:[k,se]})},919749:(l,m)=>{r.ra("GlobalMaxPool",l,{format:m?"NHWC":"NCHW"})},919836:(l,m,b,C,O,F,H,de,X,oe,ee,ge,Se,k,se,ve)=>{r.ra("MaxPool",l,{format:ve?"NHWC":"NCHW",auto_pad:m,ceil_mode:b,count_include_pad:C,storage_order:O,dilations:[F,H],kernel_shape:[de,X],pads:[oe,ee,ge,Se],strides:[k,se]})},920116:(l,m,b,C,O)=>{r.ra("Gemm",l,{alpha:m,beta:b,transA:C,transB:O})},920220:l=>{r.ra("MatMul",l,void 0)},920274:(l,m,b,C)=>{r.ra("ArgMax",l,{keepDims:!!m,selectLastIndex:!!b,axis:C})},920382:(l,m,b,C)=>{r.ra("ArgMin",l,{keepDims:!!m,selectLastIndex:!!b,axis:C})},920490:(l,m)=>{r.ra("Softmax",l,{axis:m})},920553:(l,m)=>{r.ra("Concat",l,{axis:m})},920613:(l,m,b,C,O)=>{r.ra("Split",l,{axis:m,numOutputs:b,splitSizes:C?Array.from(B.subarray(O>>>0,O+C>>>0)):[]})},920758:l=>{r.ra("Expand",l,void 0)},920812:(l,m)=>{r.ra("Gather",l,{axis:Number(m)})},920883:(l,m)=>{r.ra("GatherElements",l,{axis:Number(m)})},920962:(l,m,b,C,O,F,H,de,X,oe,ee)=>{r.ra("Resize",l,{antialias:m,axes:b?Array.from(B.subarray(C>>>0,C+b>>>0)):[],coordinateTransformMode:ze(O),cubicCoeffA:F,excludeOutside:H,extrapolationValue:de,keepAspectRatioPolicy:ze(X),mode:ze(oe),nearestMode:ze(ee)})},921313:(l,m,b,C,O,F,H)=>{r.ra("Slice",l,{starts:m?Array.from(B.subarray(b>>>0,b+m>>>0)):[],ends:C?Array.from(B.subarray(O>>>0,O+C>>>0)):[],axes:F?Array.from(B.subarray(H>>>0,H+F>>>0)):[]})},921544:l=>{r.ra("Tile",l,void 0)},921596:(l,m,b)=>{r.ra("LayerNormalization",l,{axis:Number(m),epsilon:Number(b)})},921703:(l,m,b)=>{r.ra("InstanceNormalization",l,{epsilon:m,format:b?"NHWC":"NCHW"})},921817:(l,m,b)=>{r.ra("InstanceNormalization",l,{epsilon:m,format:b?"NHWC":"NCHW"})},921931:l=>{r.ra("Range",l,void 0)},921984:(l,m)=>{r.ra("Einsum",l,{equation:ze(m)})},922065:(l,m,b,C,O)=>{r.ra("Pad",l,{mode:m,value:b,pads:C?Array.from(B.subarray(O>>>0,O+C>>>0)):[]})},922197:(l,m,b,C,O,F)=>{r.ra("BatchNormalization",l,{epsilon:m,momentum:b,spatial:!!O,trainingMode:!!C,format:F?"NHWC":"NCHW"})},922366:(l,m,b,C,O,F)=>{r.ra("BatchNormalization",l,{epsilon:m,momentum:b,spatial:!!O,trainingMode:!!C,format:F?"NHWC":"NCHW"})},922535:(l,m,b)=>{r.ra("CumSum",l,{exclusive:Number(m),reverse:Number(b)})},922632:(l,m,b,C,O,F,H,de,X)=>{r.ra("Attention",l,{numHeads:m,isUnidirectional:b,maskFilterValue:C,scale:O,doRotary:F,qkvHiddenSizes:H?Array.from(B.subarray(Number(de)>>>0,Number(de)+H>>>0)):[],pastPresentShareBuffer:!!X})},922904:l=>{r.ra("Gelu",l,void 0)},922956:(l,m,b,C,O,F)=>{r.ra("MultiHeadAttention",l,{numHeads:m,isUnidirectional:b,maskFilterValue:C,scale:O,doRotary:F})},923115:l=>{r.ra("BiasAdd",l,void 0)},923170:l=>{r.ra("BiasSplitGelu",l,void 0)},923231:(l,m)=>{r.ra("SkipLayerNormalization",l,{epsilon:m})},923312:(l,m,b,C,O,F,H,de,X,oe,ee,ge,Se)=>{r.ra("Conv",l,{format:X?"NHWC":"NCHW",auto_pad:m,dilations:[b],group:C,kernel_shape:[O],pads:F?Array.from(B.subarray(H>>>0,H+F>>>0)):[],strides:[de],w_is_const:()=>!!G[oe>>>0],activation:ze(ee),activation_params:ge?Array.from(pe.subarray(Se>>>0,Se+ge>>>0)):[]})},923693:(l,m,b,C,O,F,H,de,X,oe,ee,ge,Se,k,se,ve)=>{r.ra("Conv",l,{format:ge?"NHWC":"NCHW",auto_pad:m,dilations:[b,C],group:O,kernel_shape:[F,H],pads:de?Array.from(B.subarray(X>>>0,X+de>>>0)):[],strides:[oe,ee],w_is_const:()=>!!G[Se>>>0],activation:ze(k),activation_params:se?Array.from(pe.subarray(ve>>>0,ve+se>>>0)):[]})},924095:l=>{r.Ra(l)},924129:(l,m)=>r.Sa(l,m,r.Da.Ta,r.Da.errors),924241:l=>r.Oa(l),924274:l=>r.Qa(l),924306:(l,m,b)=>{r.Ja(l,m,b,!0)},924345:(l,m,b)=>{r.Ja(l,m,b)}};function Je(l){this.name="ExitStatus",this.message=`Program terminated with exit(${l})`,this.status=l}var xt=l=>{for(;0<l.length;)l.shift()(r)};function Ct(l){this.Ha=l-24,this.Ma=function(m){q[this.Ha+4>>2>>>0]=m},this.La=function(m){q[this.Ha+8>>2>>>0]=m},this.Ya=function(m,b){this.Ka(),this.Ma(m),this.La(b)},this.Ka=function(){q[this.Ha+16>>2>>>0]=0}}var Gt=0,hr=0,et=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Lt=(l,m,b)=>{m>>>=0;var C=m+b;for(b=m;l[b]&&!(b>=C);)++b;if(16<b-m&&l.buffer&&et)return et.decode(l.subarray(m,b));for(C="";m<b;){var O=l[m++];if(O&128){var F=l[m++]&63;if((O&224)==192)C+=String.fromCharCode((O&31)<<6|F);else{var H=l[m++]&63;O=(O&240)==224?(O&15)<<12|F<<6|H:(O&7)<<18|F<<12|H<<6|l[m++]&63,65536>O?C+=String.fromCharCode(O):(O-=65536,C+=String.fromCharCode(55296|O>>10,56320|O&1023))}}else C+=String.fromCharCode(O)}return C},ze=(l,m)=>(l>>>=0)?Lt(J,l,m):"",Pt=l=>{for(var m=0,b=0;b<l.length;++b){var C=l.charCodeAt(b);127>=C?m++:2047>=C?m+=2:55296<=C&&57343>=C?(m+=4,++b):m+=3}return m},Ft=(l,m,b,C)=>{if(b>>>=0,!(0<C))return 0;var O=b;C=b+C-1;for(var F=0;F<l.length;++F){var H=l.charCodeAt(F);if(55296<=H&&57343>=H){var de=l.charCodeAt(++F);H=65536+((H&1023)<<10)|de&1023}if(127>=H){if(b>=C)break;m[b++>>>0]=H}else{if(2047>=H){if(b+1>=C)break;m[b++>>>0]=192|H>>6}else{if(65535>=H){if(b+2>=C)break;m[b++>>>0]=224|H>>12}else{if(b+3>=C)break;m[b++>>>0]=240|H>>18,m[b++>>>0]=128|H>>12&63}m[b++>>>0]=128|H>>6&63}m[b++>>>0]=128|H&63}}return m[b>>>0]=0,b-O},mt=l=>l%4===0&&(l%100!==0||l%400===0),gr=[0,31,60,91,121,152,182,213,244,274,305,335],ft=[0,31,59,90,120,151,181,212,243,273,304,334],Rt=l=>{var m=Pt(l)+1,b=zt(m);return b&&Ft(l,J,b,m),b},yt=[],Bt=(l,m)=>{yt.length=0;var b;for(m>>=2;b=J[l++>>>0];)m+=b!=105&m,yt.push(b==105?B[m>>>0]:Q[m++>>>1]),++m;return yt},Mt={},qt=()=>{if(!Dt){var l={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:u||"./this.program"},m;for(m in Mt)Mt[m]===void 0?delete l[m]:l[m]=Mt[m];var b=[];for(m in l)b.push(`${m}=${l[m]}`);Dt=b}return Dt},Dt,yr=[null,[],[]],qe=[31,29,31,30,31,30,31,31,30,31,30,31],jt=[31,28,31,30,31,30,31,31,30,31,30,31];function Kt(l){var m=Array(Pt(l)+1);return Ft(l,m,0,m.length),m}function le(l,m,b,C){function O(k,se,ve){for(k=typeof k=="number"?k.toString():k||"";k.length<se;)k=ve[0]+k;return k}function F(k,se){return O(k,se,"0")}function H(k,se){function ve(ar){return 0>ar?-1:0<ar?1:0}var gt;return(gt=ve(k.getFullYear()-se.getFullYear()))===0&&(gt=ve(k.getMonth()-se.getMonth()))===0&&(gt=ve(k.getDate()-se.getDate())),gt}function de(k){switch(k.getDay()){case 0:return new Date(k.getFullYear()-1,11,29);case 1:return k;case 2:return new Date(k.getFullYear(),0,3);case 3:return new Date(k.getFullYear(),0,2);case 4:return new Date(k.getFullYear(),0,1);case 5:return new Date(k.getFullYear()-1,11,31);case 6:return new Date(k.getFullYear()-1,11,30)}}function X(k){var se=k.Ba;for(k=new Date(new Date(k.Ca+1900,0,1).getTime());0<se;){var ve=k.getMonth(),gt=(mt(k.getFullYear())?qe:jt)[ve];if(se>gt-k.getDate())se-=gt-k.getDate()+1,k.setDate(1),11>ve?k.setMonth(ve+1):(k.setMonth(0),k.setFullYear(k.getFullYear()+1));else{k.setDate(k.getDate()+se);break}}return ve=new Date(k.getFullYear()+1,0,4),se=de(new Date(k.getFullYear(),0,4)),ve=de(ve),0>=H(se,k)?0>=H(ve,k)?k.getFullYear()+1:k.getFullYear():k.getFullYear()-1}l>>>=0,m>>>=0,b>>>=0,C>>>=0;var oe=B[C+40>>2>>>0];C={Wa:B[C>>2>>>0],Va:B[C+4>>2>>>0],Ea:B[C+8>>2>>>0],Ia:B[C+12>>2>>>0],Fa:B[C+16>>2>>>0],Ca:B[C+20>>2>>>0],wa:B[C+24>>2>>>0],Ba:B[C+28>>2>>>0],$a:B[C+32>>2>>>0],Ua:B[C+36>>2>>>0],Xa:oe?ze(oe):""},b=ze(b),oe={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ee in oe)b=b.replace(new RegExp(ee,"g"),oe[ee]);var ge="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Se="January February March April May June July August September October November December".split(" ");oe={"%a":k=>ge[k.wa].substring(0,3),"%A":k=>ge[k.wa],"%b":k=>Se[k.Fa].substring(0,3),"%B":k=>Se[k.Fa],"%C":k=>F((k.Ca+1900)/100|0,2),"%d":k=>F(k.Ia,2),"%e":k=>O(k.Ia,2," "),"%g":k=>X(k).toString().substring(2),"%G":k=>X(k),"%H":k=>F(k.Ea,2),"%I":k=>(k=k.Ea,k==0?k=12:12<k&&(k-=12),F(k,2)),"%j":k=>{for(var se=0,ve=0;ve<=k.Fa-1;se+=(mt(k.Ca+1900)?qe:jt)[ve++]);return F(k.Ia+se,3)},"%m":k=>F(k.Fa+1,2),"%M":k=>F(k.Va,2),"%n":()=>`\n`,"%p":k=>0<=k.Ea&&12>k.Ea?"AM":"PM","%S":k=>F(k.Wa,2),"%t":()=>"	","%u":k=>k.wa||7,"%U":k=>F(Math.floor((k.Ba+7-k.wa)/7),2),"%V":k=>{var se=Math.floor((k.Ba+7-(k.wa+6)%7)/7);if(2>=(k.wa+371-k.Ba-2)%7&&se++,se)se==53&&(ve=(k.wa+371-k.Ba)%7,ve==4||ve==3&&mt(k.Ca)||(se=1));else{se=52;var ve=(k.wa+7-k.Ba-1)%7;(ve==4||ve==5&&mt(k.Ca%400-1))&&se++}return F(se,2)},"%w":k=>k.wa,"%W":k=>F(Math.floor((k.Ba+7-(k.wa+6)%7)/7),2),"%y":k=>(k.Ca+1900).toString().substring(2),"%Y":k=>k.Ca+1900,"%z":k=>{k=k.Ua;var se=0<=k;return k=Math.abs(k)/60,(se?"+":"-")+("0000"+(k/60*100+k%60)).slice(-4)},"%Z":k=>k.Xa,"%%":()=>"%"},b=b.replace(/%%/g,"\\0\\0");for(ee in oe)b.includes(ee)&&(b=b.replace(new RegExp(ee,"g"),oe[ee](C)));return b=b.replace(/\\0\\0/g,"%"),ee=Kt(b),ee.length>m?0:(G.set(ee,l>>>0),ee.length-1)}function ht(l){try{l()}catch(m){He(m)}}function br(l){var m={},b;for(b in l)(function(C){var O=l[C];m[C]=typeof O=="function"?function(){_t.push(C);try{return O.apply(null,arguments)}finally{N||(_t.pop()===C||He(),Qe&&ot===1&&_t.length===0&&(ot=0,ht(nr),typeof Fibers<"u"&&Fibers.ab()))}}:O})(b);return m}var ot=0,Qe=null,wr=0,_t=[],Yt={},Zt={},vr=0,At=null,$r=[];function Sr(){return new Promise((l,m)=>{At={resolve:l,reject:m}})}function xr(){var l=zt(65548),m=l+12;q[l>>2>>>0]=m,q[l+4>>2>>>0]=m+65536,m=_t[0];var b=Yt[m];return b===void 0&&(b=vr++,Yt[m]=b,Zt[b]=m),B[l+8>>2>>>0]=b,l}function Cr(l){if(!N){if(ot===0){var m=!1,b=!1;l((C=0)=>{if(!N&&(wr=C,m=!0,b)){ot=2,ht(()=>Vt(Qe)),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.resume(),C=!1;try{var O=(0,T[Zt[B[Qe+8>>2>>>0]]])()}catch(de){O=de,C=!0}var F=!1;if(!Qe){var H=At;H&&(At=null,(C?H.reject:H.resolve)(O),F=!0)}if(C&&!F)throw O}}),b=!0,m||(ot=1,Qe=xr(),typeof Browser<"u"&&Browser.Ga.Na&&Browser.Ga.pause(),ht(()=>rr(Qe)))}else ot===2?(ot=0,ht(It),Xt(Qe),Qe=null,$r.forEach(C=>{if(!N)try{if(C(),!I)try{U=U=C=U,I||(r.onExit&&r.onExit(C),N=!0),d(C,new Je(C))}catch(O){O instanceof Je||O=="unwind"||d(1,O)}}catch(O){O instanceof Je||O=="unwind"||d(1,O)}})):He(`invalid state: ${ot}`);return wr}}function _r(l){return Cr(m=>{l().then(m)})}var Ar={n:function(l,m,b){return _r(async()=>{await r.Pa(l,m,b)})},a:function(l,m,b){throw l>>>=0,new Ct(l).Ya(m>>>0,b>>>0),Gt=l,hr++,Gt},g:function(){return 0},J:function(){},z:function(){},B:function(){},L:function(){return 0},H:function(){},C:function(){},G:function(){},l:function(){},A:function(){},x:function(){},I:function(){},y:function(){},m:()=>!0,q:function(l,m,b){l=m+2097152>>>0<4194305-!!l?(l>>>0)+4294967296*m:NaN,b>>>=0,l=new Date(1e3*l),B[b>>2>>>0]=l.getUTCSeconds(),B[b+4>>2>>>0]=l.getUTCMinutes(),B[b+8>>2>>>0]=l.getUTCHours(),B[b+12>>2>>>0]=l.getUTCDate(),B[b+16>>2>>>0]=l.getUTCMonth(),B[b+20>>2>>>0]=l.getUTCFullYear()-1900,B[b+24>>2>>>0]=l.getUTCDay(),B[b+28>>2>>>0]=(l.getTime()-Date.UTC(l.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},r:function(l,m,b){l=m+2097152>>>0<4194305-!!l?(l>>>0)+4294967296*m:NaN,b>>>=0,l=new Date(1e3*l),B[b>>2>>>0]=l.getSeconds(),B[b+4>>2>>>0]=l.getMinutes(),B[b+8>>2>>>0]=l.getHours(),B[b+12>>2>>>0]=l.getDate(),B[b+16>>2>>>0]=l.getMonth(),B[b+20>>2>>>0]=l.getFullYear()-1900,B[b+24>>2>>>0]=l.getDay(),B[b+28>>2>>>0]=(mt(l.getFullYear())?gr:ft)[l.getMonth()]+l.getDate()-1|0,B[b+36>>2>>>0]=-(60*l.getTimezoneOffset()),m=new Date(l.getFullYear(),6,1).getTimezoneOffset();var C=new Date(l.getFullYear(),0,1).getTimezoneOffset();B[b+32>>2>>>0]=(m!=C&&l.getTimezoneOffset()==Math.min(C,m))|0},s:function(l){l>>>=0;var m=new Date(B[l+20>>2>>>0]+1900,B[l+16>>2>>>0],B[l+12>>2>>>0],B[l+8>>2>>>0],B[l+4>>2>>>0],B[l>>2>>>0],0),b=B[l+32>>2>>>0],C=m.getTimezoneOffset(),O=new Date(m.getFullYear(),6,1).getTimezoneOffset(),F=new Date(m.getFullYear(),0,1).getTimezoneOffset(),H=Math.min(F,O);return 0>b?B[l+32>>2>>>0]=+(O!=F&&H==C):0<b!=(H==C)&&(O=Math.max(F,O),m.setTime(m.getTime()+6e4*((0<b?H:O)-C))),B[l+24>>2>>>0]=m.getDay(),B[l+28>>2>>>0]=(mt(m.getFullYear())?gr:ft)[m.getMonth()]+m.getDate()-1|0,B[l>>2>>>0]=m.getSeconds(),B[l+4>>2>>>0]=m.getMinutes(),B[l+8>>2>>>0]=m.getHours(),B[l+12>>2>>>0]=m.getDate(),B[l+16>>2>>>0]=m.getMonth(),B[l+20>>2>>>0]=m.getYear(),l=m.getTime()/1e3,Jt((Ke=l,1<=+Math.abs(Ke)?0<Ke?+Math.floor(Ke/4294967296)>>>0:~~+Math.ceil((Ke-+(~~Ke>>>0))/4294967296)>>>0:0)),l>>>0},o:function(){return-52},p:function(){},v:function(l,m,b){function C(X){return(X=X.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?X[1]:"GMT"}b>>>=0;var O=new Date().getFullYear(),F=new Date(O,0,1),H=new Date(O,6,1);O=F.getTimezoneOffset();var de=H.getTimezoneOffset();q[l>>>0>>2>>>0]=60*Math.max(O,de),B[m>>>0>>2>>>0]=+(O!=de),l=C(F),m=C(H),l=Rt(l),m=Rt(m),de<O?(q[b>>2>>>0]=l,q[b+4>>2>>>0]=m):(q[b>>2>>>0]=m,q[b+4>>2>>>0]=l)},e:()=>{He("")},b:function(l,m,b){return l>>>=0,m=Bt(m>>>0,b>>>0),nt[l].apply(null,m)},i:function(l,m,b){return l>>>=0,m=Bt(m>>>0,b>>>0),nt[l].apply(null,m)},h:function(){return Date.now()},w:function(){return 4294901760},c:()=>performance.now(),K:function(l,m,b){return m>>>=0,J.copyWithin(l>>>0>>>0,m>>>0,m+(b>>>0)>>>0)},u:function(l){l>>>=0;var m=J.length;if(4294901760<l)return!1;for(var b=1;4>=b;b*=2){var C=m*(1+.2/b);C=Math.min(C,l+100663296);var O=Math;C=Math.max(l,C);e:{O=O.min.call(O,4294901760,C+(65536-C%65536)%65536)-z.buffer.byteLength+65535>>>16;try{z.grow(O),we();var F=1;break e}catch{}F=void 0}if(F)return!0}return!1},D:function(l,m){l>>>=0,m>>>=0;var b=0;return qt().forEach(function(C,O){var F=m+b;for(O=q[l+4*O>>2>>>0]=F,F=0;F<C.length;++F)G[O++>>0>>>0]=C.charCodeAt(F);G[O>>0>>>0]=0,b+=C.length+1}),0},E:function(l,m){l>>>=0,m>>>=0;var b=qt();q[l>>2>>>0]=b.length;var C=0;return b.forEach(function(O){C+=O.length+1}),q[m>>2>>>0]=C,0},f:()=>52,k:function(){return 52},t:function(){return 70},j:function(l,m,b,C){m>>>=0,b>>>=0,C>>>=0;for(var O=0,F=0;F<b;F++){var H=q[m>>2>>>0],de=q[m+4>>2>>>0];m+=8;for(var X=0;X<de;X++){var oe=J[H+X>>>0],ee=yr[l];oe===0||oe===10?((l===1?$:_)(Lt(ee,0)),ee.length=0):ee.push(oe)}O+=de}return q[C>>2>>>0]=O,0},F:le,d:function(l,m,b,C){return le(l>>>0,m>>>0,b>>>0,C>>>0)}};(function(){function l(b){if(b=b.exports,b=br(b),T=b=bt(b),z=T.M,we(),ye.unshift(T.N),ce--,r.monitorRunDependencies&&r.monitorRunDependencies(ce),ce==0&&(We!==null&&(clearInterval(We),We=null),Be)){var C=Be;Be=null,C()}return b}var m={a:Ar};if(ce++,r.monitorRunDependencies&&r.monitorRunDependencies(ce),r.instantiateWasm)try{return r.instantiateWasm(m,l)}catch(b){_("Module.instantiateWasm callback failed with error: "+b),n(b)}return Ge(m,function(b){l(b.instance)}).catch(n),{}})(),r._OrtInit=(l,m)=>(r._OrtInit=T.O)(l,m),r._OrtGetLastError=(l,m)=>(r._OrtGetLastError=T.P)(l,m),r._OrtCreateSessionOptions=(l,m,b,C,O,F,H,de,X,oe)=>(r._OrtCreateSessionOptions=T.Q)(l,m,b,C,O,F,H,de,X,oe),r._OrtAppendExecutionProvider=(l,m)=>(r._OrtAppendExecutionProvider=T.R)(l,m),r._OrtAddFreeDimensionOverride=(l,m,b)=>(r._OrtAddFreeDimensionOverride=T.S)(l,m,b),r._OrtAddSessionConfigEntry=(l,m,b)=>(r._OrtAddSessionConfigEntry=T.T)(l,m,b),r._OrtReleaseSessionOptions=l=>(r._OrtReleaseSessionOptions=T.U)(l),r._OrtCreateSession=(l,m,b)=>(r._OrtCreateSession=T.V)(l,m,b),r._OrtReleaseSession=l=>(r._OrtReleaseSession=T.W)(l),r._OrtGetInputOutputCount=(l,m,b)=>(r._OrtGetInputOutputCount=T.X)(l,m,b),r._OrtGetInputName=(l,m)=>(r._OrtGetInputName=T.Y)(l,m),r._OrtGetOutputName=(l,m)=>(r._OrtGetOutputName=T.Z)(l,m),r._OrtFree=l=>(r._OrtFree=T._)(l),r._OrtCreateTensor=(l,m,b,C,O,F)=>(r._OrtCreateTensor=T.$)(l,m,b,C,O,F),r._OrtGetTensorData=(l,m,b,C,O)=>(r._OrtGetTensorData=T.aa)(l,m,b,C,O),r._OrtReleaseTensor=l=>(r._OrtReleaseTensor=T.ba)(l),r._OrtCreateRunOptions=(l,m,b,C)=>(r._OrtCreateRunOptions=T.ca)(l,m,b,C),r._OrtAddRunConfigEntry=(l,m,b)=>(r._OrtAddRunConfigEntry=T.da)(l,m,b),r._OrtReleaseRunOptions=l=>(r._OrtReleaseRunOptions=T.ea)(l),r._OrtCreateBinding=l=>(r._OrtCreateBinding=T.fa)(l),r._OrtBindInput=(l,m,b)=>(r._OrtBindInput=T.ga)(l,m,b),r._OrtBindOutput=(l,m,b,C)=>(r._OrtBindOutput=T.ha)(l,m,b,C),r._OrtClearBoundOutputs=l=>(r._OrtClearBoundOutputs=T.ia)(l),r._OrtReleaseBinding=l=>(r._OrtReleaseBinding=T.ja)(l),r._OrtRunWithBinding=(l,m,b,C,O)=>(r._OrtRunWithBinding=T.ka)(l,m,b,C,O),r._OrtRun=(l,m,b,C,O,F,H,de)=>(r._OrtRun=T.la)(l,m,b,C,O,F,H,de),r._OrtEndProfiling=l=>(r._OrtEndProfiling=T.ma)(l),r._JsepOutput=(l,m,b)=>(r._JsepOutput=T.na)(l,m,b),r._JsepGetNodeName=l=>(r._JsepGetNodeName=T.oa)(l);var zt=r._malloc=l=>(zt=r._malloc=T.pa)(l),Xt=r._free=l=>(Xt=r._free=T.qa)(l),Jt=l=>(Jt=T.sa)(l),Qt=()=>(Qt=T.ta)(),er=l=>(er=T.ua)(l),tr=l=>(tr=T.va)(l),rr=l=>(rr=T.xa)(l),nr=()=>(nr=T.ya)(),Vt=l=>(Vt=T.za)(l),It=()=>(It=T.Aa)();r.___start_em_js=924378,r.___stop_em_js=924539;function bt(l){l=Object.assign({},l);var m=C=>()=>C()>>>0,b=C=>O=>C(O)>>>0;return l.__errno_location=m(l.__errno_location),l.malloc=b(l.malloc),l.stackSave=m(l.stackSave),l.stackAlloc=b(l.stackAlloc),l}r.stackAlloc=tr,r.stackSave=Qt,r.stackRestore=er,r.UTF8ToString=ze,r.stringToUTF8=(l,m,b)=>Ft(l,J,m,b),r.lengthBytesUTF8=Pt;var Tt;Be=function l(){Tt||or(),Tt||(Be=l)};function or(){function l(){if(!Tt&&(Tt=!0,r.calledRun=!0,!N)){if(xt(ye),o(r),r.onRuntimeInitialized&&r.onRuntimeInitialized(),r.postRun)for(typeof r.postRun=="function"&&(r.postRun=[r.postRun]);r.postRun.length;){var m=r.postRun.shift();Ce.unshift(m)}xt(Ce)}}if(!(0<ce)){if(r.preRun)for(typeof r.preRun=="function"&&(r.preRun=[r.preRun]);r.preRun.length;)fe();xt(Z),0<ce||(r.setStatus?(r.setStatus("Running..."),setTimeout(function(){setTimeout(function(){r.setStatus("")},1),l()},1)):l())}}if(r.preInit)for(typeof r.preInit=="function"&&(r.preInit=[r.preInit]);0<r.preInit.length;)r.preInit.pop()();return or(),t.ready}})();typeof bo=="object"&&typeof bn=="object"?bn.exports=yo:typeof define=="function"&&define.amd&&define([],()=>yo)});var vo=ir(()=>{});var $o=ir(()=>{});var So={};Pr(So,{cpus:()=>Fu});var Fu,xo=Y(()=>{Fu=void 0});var Ao=ir((_o,wn)=>{"use strict";var Co=(()=>{var e=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(e=e||__filename),function(t={}){function r(){return we.buffer!=ce.buffer&&he(),ce}function o(){return we.buffer!=ce.buffer&&he(),We}function n(){return we.buffer!=ce.buffer&&he(),Be}function s(){return we.buffer!=ce.buffer&&he(),He}function u(){return we.buffer!=ce.buffer&&he(),L}function d(){return we.buffer!=ce.buffer&&he(),re}var a=t,p,h;a.ready=new Promise((i,c)=>{p=i,h=c}),a.jsepInit=(i,c,f,S,E,M,W,ae)=>{a.Qb=i,a.wb=c,a.yb=f,a.jb=S,a.xb=E,a.Ea=M,a.zb=W,a.Ab=ae,c=(te,ne,ue)=>(...xe)=>{let Ae=at,P=ne?.();xe=te(...xe);let me=ne?.();return P!==me&&(te=me,ue(P),ne=ue=null),at!=Ae?ku():xe},f=te=>async(...ne)=>{try{if(a.bb)throw Error("Session already started");let ue=a.bb={Fb:ne[0],errors:[]},xe=await te(...ne);if(a.bb!==ue)throw Error("Session mismatch");i.flush();let Ae=ue.errors;if(0<Ae.length){let P=await Promise.all(Ae);if(P=P.filter(me=>me),0<P.length)throw Error(P.join(`\n`))}return xe}finally{a.bb=null}},a._OrtRun=f(c(a._OrtRun,()=>a._OrtRun,te=>a._OrtRun=te)),a._OrtRunWithBinding=f(c(a._OrtRunWithBinding,()=>a._OrtRunWithBinding,te=>a._OrtRunWithBinding=te)),a._OrtBindInput=c(a._OrtBindInput,()=>a._OrtBindInput,te=>a._OrtBindInput=te),a.jsepRegisterBuffer=(te,ne,ue,xe)=>i.registerBuffer(te,ne,ue,xe),a.jsepUnregisterBuffers=te=>{i.unregisterBuffers(te)},a.jsepGetBuffer=te=>i.getBuffer(te),a.jsepCreateDownloader=(te,ne,ue)=>i.createDownloader(te,ne,ue)};var v=Object.assign({},a),g="./this.program",w=(i,c)=>{throw c},y=typeof window=="object",x=typeof importScripts=="function",A=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",$=a.ENVIRONMENT_IS_PTHREAD||!1,_="";function R(i){return a.locateFile?a.locateFile(i,_):_+i}var I,z,T;if(A){var N=(hn(),Ut(fn)),U=(yn(),Ut(gn));_=x?U.dirname(_)+"/":__dirname+"/",I=(c,f)=>(c=c.startsWith("file://")?new URL(c):U.normalize(c),N.readFileSync(c,f?void 0:"utf8")),T=c=>(c=I(c,!0),c.buffer||(c=new Uint8Array(c)),c),z=(c,f,S,E=!0)=>{c=c.startsWith("file://")?new URL(c):U.normalize(c),N.readFile(c,E?void 0:"utf8",(M,W)=>{M?S(M):f(E?W.buffer:W)})},!a.thisProgram&&1<process.argv.length&&(g=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),w=(c,f)=>{throw process.exitCode=c,f},a.inspect=()=>"[Emscripten Module object]";let i;try{i=vo()}catch(c){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),c}global.Worker=i.Worker}else(y||x)&&(x?_=self.location.href:typeof document<"u"&&document.currentScript&&(_=document.currentScript.src),typeof e<"u"&&e&&(_=e),_.indexOf("blob:")!==0?_=_.substr(0,_.replace(/[?#].*/,"").lastIndexOf("/")+1):_="",A||(I=i=>{var c=new XMLHttpRequest;return c.open("GET",i,!1),c.send(null),c.responseText},x&&(T=i=>{var c=new XMLHttpRequest;return c.open("GET",i,!1),c.responseType="arraybuffer",c.send(null),new Uint8Array(c.response)}),z=(i,c,f)=>{var S=new XMLHttpRequest;S.open("GET",i,!0),S.responseType="arraybuffer",S.onload=()=>{S.status==200||S.status==0&&S.response?c(S.response):f()},S.onerror=f,S.send(null)}));A&&typeof performance>"u"&&(global.performance=$o().performance);var G=console.log.bind(console),J=console.error.bind(console);A&&(G=(...i)=>N.writeSync(1,i.join(" ")+`\n`),J=(...i)=>N.writeSync(2,i.join(" ")+`\n`));var B=a.print||G,q=a.printErr||J;Object.assign(a,v),v=null,a.thisProgram&&(g=a.thisProgram),a.quit&&(w=a.quit);var pe;a.wasmBinary&&(pe=a.wasmBinary);var Q=a.noExitRuntime||!0;typeof WebAssembly!="object"&&et("no native wasm support detected");var we,Z,ye,Ce=!1,fe,ce,We,Be,He,L,re;function he(){var i=we.buffer;a.HEAP8=ce=new Int8Array(i),a.HEAP16=new Int16Array(i),a.HEAP32=Be=new Int32Array(i),a.HEAPU8=We=new Uint8Array(i),a.HEAPU16=new Uint16Array(i),a.HEAPU32=He=new Uint32Array(i),a.HEAPF32=L=new Float32Array(i),a.HEAPF64=re=new Float64Array(i)}var Fe=a.INITIAL_MEMORY||16777216;if(5242880<=Fe||et("INITIAL_MEMORY should be larger than STACK_SIZE, was "+Fe+"! (STACK_SIZE=5242880)"),$)we=a.wasmMemory;else if(a.wasmMemory)we=a.wasmMemory;else if(we=new WebAssembly.Memory({initial:Fe/65536,maximum:65536,shared:!0}),!(we.buffer instanceof SharedArrayBuffer))throw q("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),A&&q("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");he(),Fe=we.buffer.byteLength;var Ze=[],Me=[],Ge=[],Ke=0;function nt(){return Q||0<Ke}var Je=0,xt=null,Ct=null;function Gt(){Je++,a.monitorRunDependencies&&a.monitorRunDependencies(Je)}function hr(){if(Je--,a.monitorRunDependencies&&a.monitorRunDependencies(Je),Je==0&&(xt!==null&&(clearInterval(xt),xt=null),Ct)){var i=Ct;Ct=null,i()}}function et(i){throw a.onAbort&&a.onAbort(i),i="Aborted("+i+")",q(i),Ce=!0,fe=1,i=new WebAssembly.RuntimeError(i+". Build with -sASSERTIONS for more info."),h(i),i}function Lt(i){return i.startsWith("data:application/octet-stream;base64,")}var ze;ze="ort-wasm-simd-threaded.wasm",Lt(ze)||(ze=R(ze));function Pt(i){if(i==ze&&pe)return new Uint8Array(pe);if(T)return T(i);throw"both async and sync fetching of the wasm failed"}function Ft(i){if(!pe&&(y||x)){if(typeof fetch=="function"&&!i.startsWith("file://"))return fetch(i,{credentials:"same-origin"}).then(c=>{if(!c.ok)throw"failed to load wasm binary file at \'"+i+"\'";return c.arrayBuffer()}).catch(()=>Pt(i));if(z)return new Promise((c,f)=>{z(i,S=>c(new Uint8Array(S)),f)})}return Promise.resolve().then(()=>Pt(i))}function mt(i,c,f){return Ft(i).then(S=>WebAssembly.instantiate(S,c)).then(S=>S).then(f,S=>{q("failed to asynchronously prepare wasm: "+S),et(S)})}function gr(i,c){var f=ze;return pe||typeof WebAssembly.instantiateStreaming!="function"||Lt(f)||f.startsWith("file://")||A||typeof fetch!="function"?mt(f,i,c):fetch(f,{credentials:"same-origin"}).then(S=>WebAssembly.instantiateStreaming(S,i).then(c,function(E){return q("wasm streaming compile failed: "+E),q("falling back to ArrayBuffer instantiation"),mt(f,i,c)}))}var ft,Rt={1428192:i=>{a.Ea("Abs",i,void 0)},1428243:i=>{a.Ea("Neg",i,void 0)},1428294:i=>{a.Ea("Floor",i,void 0)},1428347:i=>{a.Ea("Ceil",i,void 0)},1428399:i=>{a.Ea("Reciprocal",i,void 0)},1428457:i=>{a.Ea("Sqrt",i,void 0)},1428509:i=>{a.Ea("Exp",i,void 0)},1428560:i=>{a.Ea("Erf",i,void 0)},1428611:i=>{a.Ea("Sigmoid",i,void 0)},1428666:i=>{a.Ea("Log",i,void 0)},1428717:i=>{a.Ea("Sin",i,void 0)},1428768:i=>{a.Ea("Cos",i,void 0)},1428819:i=>{a.Ea("Tan",i,void 0)},1428870:i=>{a.Ea("Asin",i,void 0)},1428922:i=>{a.Ea("Acos",i,void 0)},1428974:i=>{a.Ea("Atan",i,void 0)},1429026:i=>{a.Ea("Sinh",i,void 0)},1429078:i=>{a.Ea("Cosh",i,void 0)},1429130:i=>{a.Ea("Asinh",i,void 0)},1429183:i=>{a.Ea("Acosh",i,void 0)},1429236:i=>{a.Ea("Atanh",i,void 0)},1429289:i=>{a.Ea("Tanh",i,void 0)},1429341:i=>{a.Ea("Not",i,void 0)},1429392:(i,c,f)=>{a.Ea("Clip",i,{min:c,max:f})},1429461:i=>{a.Ea("Clip",i,void 0)},1429513:(i,c)=>{a.Ea("Elu",i,{alpha:c})},1429571:i=>{a.Ea("Relu",i,void 0)},1429623:(i,c)=>{a.Ea("LeakyRelu",i,{alpha:c})},1429687:(i,c)=>{a.Ea("ThresholdedRelu",i,{alpha:c})},1429757:i=>{a.zb(i)},1429791:(i,c)=>a.Ab(i,c,a.bb.Fb,a.bb.errors),1429903:(i,c)=>{a.Ea("Cast",i,{to:c})},1429961:i=>{a.Ea("Add",i,void 0)},1430012:i=>{a.Ea("Sub",i,void 0)},1430063:i=>{a.Ea("Mul",i,void 0)},1430114:i=>{a.Ea("Div",i,void 0)},1430165:i=>{a.Ea("Pow",i,void 0)},1430216:i=>{a.Ea("Equal",i,void 0)},1430269:i=>{a.Ea("Greater",i,void 0)},1430324:i=>{a.Ea("GreaterOrEqual",i,void 0)},1430386:i=>{a.Ea("Less",i,void 0)},1430438:i=>{a.Ea("LessOrEqual",i,void 0)},1430497:(i,c,f,S,E)=>{a.Ea("ReduceMean",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:S?Array.from(n().subarray(E>>>0,E+S>>>0)):[]})},1430661:(i,c,f,S,E)=>{a.Ea("ReduceMax",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:S?Array.from(n().subarray(E>>>0,E+S>>>0)):[]})},1430824:(i,c,f,S,E)=>{a.Ea("ReduceMin",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:S?Array.from(n().subarray(E>>>0,E+S>>>0)):[]})},1430987:(i,c,f,S,E)=>{a.Ea("ReduceProd",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:S?Array.from(n().subarray(E>>>0,E+S>>>0)):[]})},1431151:(i,c,f,S,E)=>{a.Ea("ReduceSum",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:S?Array.from(n().subarray(E>>>0,E+S>>>0)):[]})},1431314:(i,c,f,S,E)=>{a.Ea("ReduceL1",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:S?Array.from(n().subarray(E>>>0,E+S>>>0)):[]})},1431476:(i,c,f,S,E)=>{a.Ea("ReduceL2",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:S?Array.from(n().subarray(E>>>0,E+S>>>0)):[]})},1431638:(i,c,f,S,E)=>{a.Ea("ReduceLogSum",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:S?Array.from(n().subarray(E>>>0,E+S>>>0)):[]})},1431804:(i,c,f,S,E)=>{a.Ea("ReduceSumSquare",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:S?Array.from(n().subarray(E>>>0,E+S>>>0)):[]})},1431973:(i,c,f,S,E)=>{a.Ea("ReduceLogSumExp",i,{keepDims:!!c,noopWithEmptyAxes:!!f,axes:S?Array.from(n().subarray(E>>>0,E+S>>>0)):[]})},1432142:i=>{a.Ea("Where",i,void 0)},1432195:(i,c,f)=>{a.Ea("Transpose",i,{perm:c?Array.from(n().subarray(f>>>0,f+c>>>0)):[]})},1432308:(i,c,f,S,E,M,W,ae,te,ne,ue,xe,Ae)=>{a.Ea("Conv",i,{format:te?"NHWC":"NCHW",auto_pad:c,dilations:[f],group:S,kernel_shape:[E],pads:M?Array.from(n().subarray(W>>>0,W+M>>>0)):[],strides:[ae],w_is_const:()=>!!r()[ne>>>0],activation:qe(ue),activation_params:xe?Array.from(u().subarray(Ae>>>0,Ae+xe>>>0)):[]})},1432689:(i,c,f,S,E,M,W,ae,te,ne,ue,xe,Ae,P,me,_e)=>{a.Ea("Conv",i,{format:xe?"NHWC":"NCHW",auto_pad:c,dilations:[f,S],group:E,kernel_shape:[M,W],pads:ae?Array.from(n().subarray(te>>>0,te+ae>>>0)):[],strides:[ne,ue],w_is_const:()=>!!r()[Ae>>>0],activation:qe(P),activation_params:me?Array.from(u().subarray(_e>>>0,_e+me>>>0)):[]})},1433091:(i,c,f,S,E,M,W,ae,te,ne,ue,xe,Ae,P,me)=>{a.Ea("ConvTranspose",i,{format:te?"NHWC":"NCHW",autoPad:c,dilations:[f],group:S,kernel_shape:[E],pads:[M,W],strides:[ae],wIsConst:()=>!!r()[ne>>>0],outputPadding:ue?Array.from(n().subarray(xe>>>0,xe+ue>>>0)):[],outputShape:Ae?Array.from(n().subarray(P>>>0,P+Ae>>>0)):[],activation:qe(me)})},1433505:(i,c,f,S,E,M,W,ae,te,ne,ue,xe,Ae,P)=>{a.Ea("ConvTranspose",i,{format:ae?"NHWC":"NCHW",autoPad:c,dilations:Array.from(n().subarray(f>>>0,f+2>>>0)),group:S,kernelShape:Array.from(n().subarray(E>>>0,E+2>>>0)),pads:Array.from(n().subarray(M>>>0,M+4>>>0)),strides:Array.from(n().subarray(W>>>0,W+2>>>0)),wIsConst:()=>!!r()[te>>>0],outputPadding:0<ne?Array.from(n().subarray(ue>>>0,ue+ne>>>0)):[],outputShape:0<xe?Array.from(n().subarray(Ae>>>0,Ae+xe>>>0)):[],activation:qe(P)})},1434062:(i,c,f,S,E,M,W,ae,te,ne,ue,xe,Ae,P,me)=>{a.Ea("ConvTranspose",i,{format:te?"NHWC":"NCHW",autoPad:c,dilations:[f],group:S,kernel_shape:[E],pads:[M,W],strides:[ae],wIsConst:()=>!!r()[ne>>>0],outputPadding:ue?Array.from(n().subarray(xe>>>0,xe+ue>>>0)):[],outputShape:Ae?Array.from(n().subarray(P>>>0,P+Ae>>>0)):[],activation:qe(me)})},1434476:(i,c,f,S,E,M,W,ae,te,ne,ue,xe,Ae,P)=>{a.Ea("ConvTranspose",i,{format:ae?"NHWC":"NCHW",autoPad:c,dilations:Array.from(n().subarray(f>>>0,f+2>>>0)),group:S,kernelShape:Array.from(n().subarray(E>>>0,E+2>>>0)),pads:Array.from(n().subarray(M>>>0,M+4>>>0)),strides:Array.from(n().subarray(W>>>0,W+2>>>0)),wIsConst:()=>!!r()[te>>>0],outputPadding:0<ne?Array.from(n().subarray(ue>>>0,ue+ne>>>0)):[],outputShape:0<xe?Array.from(n().subarray(Ae>>>0,Ae+xe>>>0)):[],activation:qe(P)})},1435033:(i,c)=>{a.Ea("GlobalAveragePool",i,{format:c?"NHWC":"NCHW"})},1435124:(i,c,f,S,E,M,W,ae,te,ne,ue,xe,Ae,P,me,_e)=>{a.Ea("AveragePool",i,{format:_e?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:S,storage_order:E,dilations:[M,W],kernel_shape:[ae,te],pads:[ne,ue,xe,Ae],strides:[P,me]})},1435408:(i,c)=>{a.Ea("GlobalAveragePool",i,{format:c?"NHWC":"NCHW"})},1435499:(i,c,f,S,E,M,W,ae,te,ne,ue,xe,Ae,P,me,_e)=>{a.Ea("AveragePool",i,{format:_e?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:S,storage_order:E,dilations:[M,W],kernel_shape:[ae,te],pads:[ne,ue,xe,Ae],strides:[P,me]})},1435783:(i,c)=>{a.Ea("GlobalMaxPool",i,{format:c?"NHWC":"NCHW"})},1435870:(i,c,f,S,E,M,W,ae,te,ne,ue,xe,Ae,P,me,_e)=>{a.Ea("MaxPool",i,{format:_e?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:S,storage_order:E,dilations:[M,W],kernel_shape:[ae,te],pads:[ne,ue,xe,Ae],strides:[P,me]})},1436150:(i,c)=>{a.Ea("GlobalMaxPool",i,{format:c?"NHWC":"NCHW"})},1436237:(i,c,f,S,E,M,W,ae,te,ne,ue,xe,Ae,P,me,_e)=>{a.Ea("MaxPool",i,{format:_e?"NHWC":"NCHW",auto_pad:c,ceil_mode:f,count_include_pad:S,storage_order:E,dilations:[M,W],kernel_shape:[ae,te],pads:[ne,ue,xe,Ae],strides:[P,me]})},1436517:(i,c,f,S,E)=>{a.Ea("Gemm",i,{alpha:c,beta:f,transA:S,transB:E})},1436621:i=>{a.Ea("MatMul",i,void 0)},1436675:(i,c,f,S)=>{a.Ea("ArgMax",i,{keepDims:!!c,selectLastIndex:!!f,axis:S})},1436783:(i,c,f,S)=>{a.Ea("ArgMin",i,{keepDims:!!c,selectLastIndex:!!f,axis:S})},1436891:(i,c)=>{a.Ea("Softmax",i,{axis:c})},1436954:(i,c)=>{a.Ea("Concat",i,{axis:c})},1437014:(i,c,f,S,E)=>{a.Ea("Split",i,{axis:c,numOutputs:f,splitSizes:S?Array.from(n().subarray(E>>>0,E+S>>>0)):[]})},1437159:i=>{a.Ea("Expand",i,void 0)},1437213:(i,c)=>{a.Ea("Gather",i,{axis:Number(c)})},1437284:(i,c)=>{a.Ea("GatherElements",i,{axis:Number(c)})},1437363:(i,c,f,S,E,M,W,ae,te,ne,ue)=>{a.Ea("Resize",i,{antialias:c,axes:f?Array.from(n().subarray(S>>>0,S+f>>>0)):[],coordinateTransformMode:qe(E),cubicCoeffA:M,excludeOutside:W,extrapolationValue:ae,keepAspectRatioPolicy:qe(te),mode:qe(ne),nearestMode:qe(ue)})},1437714:(i,c,f,S,E,M,W)=>{a.Ea("Slice",i,{starts:c?Array.from(n().subarray(f>>>0,f+c>>>0)):[],ends:S?Array.from(n().subarray(E>>>0,E+S>>>0)):[],axes:M?Array.from(n().subarray(W>>>0,W+M>>>0)):[]})},1437945:i=>{a.Ea("Tile",i,void 0)},1437997:(i,c,f)=>{a.Ea("LayerNormalization",i,{axis:Number(c),epsilon:Number(f)})},1438104:(i,c,f)=>{a.Ea("InstanceNormalization",i,{epsilon:c,format:f?"NHWC":"NCHW"})},1438218:(i,c,f)=>{a.Ea("InstanceNormalization",i,{epsilon:c,format:f?"NHWC":"NCHW"})},1438332:i=>{a.Ea("Range",i,void 0)},1438385:(i,c)=>{a.Ea("Einsum",i,{equation:qe(c)})},1438466:(i,c,f,S,E)=>{a.Ea("Pad",i,{mode:c,value:f,pads:S?Array.from(n().subarray(E>>>0,E+S>>>0)):[]})},1438598:(i,c,f,S,E,M)=>{a.Ea("BatchNormalization",i,{epsilon:c,momentum:f,spatial:!!E,trainingMode:!!S,format:M?"NHWC":"NCHW"})},1438767:(i,c,f,S,E,M)=>{a.Ea("BatchNormalization",i,{epsilon:c,momentum:f,spatial:!!E,trainingMode:!!S,format:M?"NHWC":"NCHW"})},1438936:(i,c,f)=>{a.Ea("CumSum",i,{exclusive:Number(c),reverse:Number(f)})},1439033:(i,c,f,S,E,M,W,ae,te)=>{a.Ea("Attention",i,{numHeads:c,isUnidirectional:f,maskFilterValue:S,scale:E,doRotary:M,qkvHiddenSizes:W?Array.from(n().subarray(Number(ae)>>>0,Number(ae)+W>>>0)):[],pastPresentShareBuffer:!!te})},1439305:i=>{a.Ea("Gelu",i,void 0)},1439357:(i,c,f,S,E,M)=>{a.Ea("MultiHeadAttention",i,{numHeads:c,isUnidirectional:f,maskFilterValue:S,scale:E,doRotary:M})},1439516:i=>{a.Ea("BiasAdd",i,void 0)},1439571:i=>{a.Ea("BiasSplitGelu",i,void 0)},1439632:(i,c)=>{a.Ea("SkipLayerNormalization",i,{epsilon:c})},1439713:i=>a.wb(i),1439746:i=>a.yb(i),1439778:(i,c,f)=>{a.jb(i,c,f,!0)},1439817:(i,c,f)=>{a.jb(i,c,f)}};function yt(i){this.name="ExitStatus",this.message=`Program terminated with exit(${i})`,this.status=i}function Bt(i){i.terminate(),i.onmessage=()=>{}}function Mt(i){(i=le.Qa[i])||et(),le.Eb(i)}function qt(i){var c=le.tb();if(!c)return 6;le.Ya.push(c),le.Qa[i.Xa]=c,c.Xa=i.Xa;var f={cmd:"run",start_routine:i.Gb,arg:i.rb,pthread_ptr:i.Xa};return A&&c.unref(),c.postMessage(f,i.Mb),0}var Dt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,yr=(i,c,f)=>{c>>>=0;var S=c+f;for(f=c;i[f]&&!(f>=S);)++f;if(16<f-c&&i.buffer&&Dt)return Dt.decode(i.buffer instanceof SharedArrayBuffer?i.slice(c,f):i.subarray(c,f));for(S="";c<f;){var E=i[c++];if(E&128){var M=i[c++]&63;if((E&224)==192)S+=String.fromCharCode((E&31)<<6|M);else{var W=i[c++]&63;E=(E&240)==224?(E&15)<<12|M<<6|W:(E&7)<<18|M<<12|W<<6|i[c++]&63,65536>E?S+=String.fromCharCode(E):(E-=65536,S+=String.fromCharCode(55296|E>>10,56320|E&1023))}}else S+=String.fromCharCode(E)}return S},qe=(i,c)=>(i>>>=0)?yr(o(),i,c):"";function jt(i){if($)return H(1,1,i);fe=i,nt()||(le.Hb(),a.onExit&&a.onExit(i),Ce=!0),w(i,new yt(i))}var Kt=i=>{if(fe=i,$)throw br(i),"unwind";jt(i)},le={ab:[],Ya:[],mb:[],Qa:{},gb:function(){$?le.vb():le.ub()},ub:function(){Ze.unshift(()=>{Gt(),le.Bb(()=>hr())})},vb:function(){le.receiveObjectTransfer=le.Db,le.threadInitTLS=le.lb,le.setExitStatus=le.kb,Q=!1},kb:function(i){fe=i},Sb:["$terminateWorker"],Hb:function(){for(var i of le.Ya)Bt(i);for(i of le.ab)Bt(i);le.ab=[],le.Ya=[],le.Qa=[]},Eb:function(i){var c=i.Xa;delete le.Qa[c],le.ab.push(i),le.Ya.splice(le.Ya.indexOf(i),1),i.Xa=0,ln(c)},Db:function(){},lb:function(){le.mb.forEach(i=>i())},Cb:i=>new Promise(c=>{i.onmessage=M=>{M=M.data;var W=M.cmd;if(M.targetThread&&M.targetThread!=Er()){var ae=le.Qa[M.Rb];ae?ae.postMessage(M,M.transferList):q(\'Internal error! Worker sent a message "\'+W+\'" to target pthread \'+M.targetThread+", but that thread no longer exists!")}else W==="checkMailbox"?It():W==="spawnThread"?qt(M):W==="cleanupThread"?Mt(M.thread):W==="killThread"?(M=M.thread,W=le.Qa[M],delete le.Qa[M],Bt(W),ln(M),le.Ya.splice(le.Ya.indexOf(W),1),W.Xa=0):W==="cancelThread"?le.Qa[M.thread].postMessage({cmd:"cancel"}):W==="loaded"?(i.loaded=!0,c(i)):W==="alert"?alert("Thread "+M.threadId+": "+M.text):M.target==="setimmediate"?i.postMessage(M):W==="callHandler"?a[M.handler](...M.args):W&&q("worker sent an unknown command "+W)},i.onerror=M=>{throw q("worker sent an error! "+M.filename+":"+M.lineno+": "+M.message),M},A&&(i.on("message",function(M){i.onmessage({data:M})}),i.on("error",function(M){i.onerror(M)}));var f=[],S=["onExit","onAbort","print","printErr"],E;for(E of S)a.hasOwnProperty(E)&&f.push(E);i.postMessage({cmd:"load",handlers:f,urlOrBlob:a.mainScriptUrlOrBlob||e,wasmMemory:we,wasmModule:ye})}),Bb:function(i){i()},qb:function(){var i=R("ort-wasm-simd-threaded.worker.js");i=new Worker(i),le.ab.push(i)},tb:function(){return le.ab.length==0&&(le.qb(),le.Cb(le.ab[0])),le.ab.pop()}};a.PThread=le;var ht=i=>{for(;0<i.length;)i.shift()(a)};a.establishStackSpace=function(){var i=Er(),c=n()[i+52>>2>>>0];i=n()[i+56>>2>>>0],uo(c,c-i),Or(c)};function br(i){if($)return H(2,0,i);Kt(i)}a.invokeEntryPoint=function(i,c){i=lo.apply(null,[i,c]),nt()?le.kb(i):dn(i)};function ot(i){this.fb=i-24,this.pb=function(c){s()[this.fb+4>>2>>>0]=c},this.ob=function(c){s()[this.fb+8>>2>>>0]=c},this.gb=function(c,f){this.nb(),this.pb(c),this.ob(f)},this.nb=function(){s()[this.fb+16>>2>>>0]=0}}var Qe=0,wr=0;function _t(i,c,f,S){return $?H(3,1,i,c,f,S):Yt(i,c,f,S)}function Yt(i,c,f,S){if(i>>>=0,c>>>=0,f>>>=0,S>>>=0,typeof SharedArrayBuffer>"u")return q("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var E=[];return $&&E.length===0?_t(i,c,f,S):(i={Gb:f,Xa:i,rb:S,Mb:E},$?(i.Ob="spawnThread",postMessage(i,E),0):qt(i))}function Zt(i,c,f){return $?H(4,1,i,c,f):0}function vr(i,c){if($)return H(5,1,i,c)}var At=i=>{for(var c=0,f=0;f<i.length;++f){var S=i.charCodeAt(f);127>=S?c++:2047>=S?c+=2:55296<=S&&57343>=S?(c+=4,++f):c+=3}return c},$r=(i,c,f,S)=>{if(f>>>=0,!(0<S))return 0;var E=f;S=f+S-1;for(var M=0;M<i.length;++M){var W=i.charCodeAt(M);if(55296<=W&&57343>=W){var ae=i.charCodeAt(++M);W=65536+((W&1023)<<10)|ae&1023}if(127>=W){if(f>=S)break;c[f++>>>0]=W}else{if(2047>=W){if(f+1>=S)break;c[f++>>>0]=192|W>>6}else{if(65535>=W){if(f+2>=S)break;c[f++>>>0]=224|W>>12}else{if(f+3>=S)break;c[f++>>>0]=240|W>>18,c[f++>>>0]=128|W>>12&63}c[f++>>>0]=128|W>>6&63}c[f++>>>0]=128|W&63}}return c[f>>>0]=0,f-E},Sr=(i,c,f)=>$r(i,o(),c,f);function xr(i,c){if($)return H(6,1,i,c)}function Cr(i,c,f){if($)return H(7,1,i,c,f)}function _r(i,c,f){return $?H(8,1,i,c,f):0}function Ar(i,c){if($)return H(9,1,i,c)}function zt(i,c,f){if($)return H(10,1,i,c,f)}function Xt(i,c,f,S){if($)return H(11,1,i,c,f,S)}function Jt(i,c,f,S){if($)return H(12,1,i,c,f,S)}function Qt(i,c,f,S){if($)return H(13,1,i,c,f,S)}function er(i){if($)return H(14,1,i)}function tr(i,c){if($)return H(15,1,i,c)}function rr(i,c,f){if($)return H(16,1,i,c,f)}var nr=i=>{if(!Ce)try{if(i(),!nt())try{$?dn(fe):Kt(fe)}catch(c){c instanceof yt||c=="unwind"||w(1,c)}}catch(c){c instanceof yt||c=="unwind"||w(1,c)}};function Vt(i){i>>>=0,typeof Atomics.Nb=="function"&&(Atomics.Nb(n(),i>>2,i).value.then(It),i+=128,Atomics.store(n(),i>>2,1))}a.__emscripten_thread_mailbox_await=Vt;function It(){var i=Er();i&&(Vt(i),nr(()=>io()))}a.checkMailbox=It;var bt=i=>i%4===0&&(i%100!==0||i%400===0),Tt=[0,31,60,91,121,152,182,213,244,274,305,335],or=[0,31,59,90,120,151,181,212,243,273,304,334];function l(i,c,f,S,E,M,W,ae){return $?H(17,1,i,c,f,S,E,M,W,ae):-52}function m(i,c,f,S,E,M,W){if($)return H(18,1,i,c,f,S,E,M,W)}var b=i=>{var c=At(i)+1,f=un(c);return f&&Sr(i,f,c),f},C=[],O=(i,c)=>{C.length=0;var f;for(c>>=2;f=o()[i++>>>0];)c+=f!=105&c,C.push(f==105?n()[c>>>0]:d()[c++>>>1]),++c;return C},F=i=>{var c=cn();return i=i(),Or(c),i};function H(i,c){var f=arguments.length-2,S=arguments;return F(()=>{for(var E=pn(8*f),M=E>>3,W=0;W<f;W++){var ae=S[2+W];d()[M+W>>>0]=ae}return ao(i,f,E,c)})}var de=[],X={},oe=()=>{if(!ee){var i={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:g||"./this.program"},c;for(c in X)X[c]===void 0?delete i[c]:i[c]=X[c];var f=[];for(c in i)f.push(`${c}=${i[c]}`);ee=f}return ee},ee;function ge(i,c){if($)return H(19,1,i,c);i>>>=0,c>>>=0;var f=0;return oe().forEach(function(S,E){var M=c+f;for(E=s()[i+4*E>>2>>>0]=M,M=0;M<S.length;++M)r()[E++>>0>>>0]=S.charCodeAt(M);r()[E>>0>>>0]=0,f+=S.length+1}),0}function Se(i,c){if($)return H(20,1,i,c);i>>>=0,c>>>=0;var f=oe();s()[i>>2>>>0]=f.length;var S=0;return f.forEach(function(E){S+=E.length+1}),s()[c>>2>>>0]=S,0}function k(i){return $?H(21,1,i):52}function se(i,c,f,S){return $?H(22,1,i,c,f,S):52}function ve(i,c,f,S,E){return $?H(23,1,i,c,f,S,E):70}var gt=[null,[],[]];function ar(i,c,f,S){if($)return H(24,1,i,c,f,S);c>>>=0,f>>>=0,S>>>=0;for(var E=0,M=0;M<f;M++){var W=s()[c>>2>>>0],ae=s()[c+4>>2>>>0];c+=8;for(var te=0;te<ae;te++){var ne=o()[W+te>>>0],ue=gt[i];ne===0||ne===10?((i===1?B:q)(yr(ue,0)),ue.length=0):ue.push(ne)}E+=ae}return s()[S>>2>>>0]=E,0}var Xn=[31,29,31,30,31,30,31,31,30,31,30,31],Jn=[31,28,31,30,31,30,31,31,30,31,30,31];function Au(i){var c=Array(At(i)+1);return $r(i,c,0,c.length),c}var Iu=(i,c)=>{r().set(i,c>>>0)};function Qn(i,c,f,S){function E(P,me,_e){for(P=typeof P=="number"?P.toString():P||"";P.length<me;)P=_e[0]+P;return P}function M(P,me){return E(P,me,"0")}function W(P,me){function _e(go){return 0>go?-1:0<go?1:0}var Et;return(Et=_e(P.getFullYear()-me.getFullYear()))===0&&(Et=_e(P.getMonth()-me.getMonth()))===0&&(Et=_e(P.getDate()-me.getDate())),Et}function ae(P){switch(P.getDay()){case 0:return new Date(P.getFullYear()-1,11,29);case 1:return P;case 2:return new Date(P.getFullYear(),0,3);case 3:return new Date(P.getFullYear(),0,2);case 4:return new Date(P.getFullYear(),0,1);case 5:return new Date(P.getFullYear()-1,11,31);case 6:return new Date(P.getFullYear()-1,11,30)}}function te(P){var me=P.Za;for(P=new Date(new Date(P.$a+1900,0,1).getTime());0<me;){var _e=P.getMonth(),Et=(bt(P.getFullYear())?Xn:Jn)[_e];if(me>Et-P.getDate())me-=Et-P.getDate()+1,P.setDate(1),11>_e?P.setMonth(_e+1):(P.setMonth(0),P.setFullYear(P.getFullYear()+1));else{P.setDate(P.getDate()+me);break}}return _e=new Date(P.getFullYear()+1,0,4),me=ae(new Date(P.getFullYear(),0,4)),_e=ae(_e),0>=W(me,P)?0>=W(_e,P)?P.getFullYear()+1:P.getFullYear():P.getFullYear()-1}i>>>=0,c>>>=0,f>>>=0,S>>>=0;var ne=n()[S+40>>2>>>0];S={Kb:n()[S>>2>>>0],Jb:n()[S+4>>2>>>0],cb:n()[S+8>>2>>>0],ib:n()[S+12>>2>>>0],eb:n()[S+16>>2>>>0],$a:n()[S+20>>2>>>0],Wa:n()[S+24>>2>>>0],Za:n()[S+28>>2>>>0],Tb:n()[S+32>>2>>>0],Ib:n()[S+36>>2>>>0],Lb:ne?qe(ne):""},f=qe(f),ne={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var ue in ne)f=f.replace(new RegExp(ue,"g"),ne[ue]);var xe="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Ae="January February March April May June July August September October November December".split(" ");ne={"%a":P=>xe[P.Wa].substring(0,3),"%A":P=>xe[P.Wa],"%b":P=>Ae[P.eb].substring(0,3),"%B":P=>Ae[P.eb],"%C":P=>M((P.$a+1900)/100|0,2),"%d":P=>M(P.ib,2),"%e":P=>E(P.ib,2," "),"%g":P=>te(P).toString().substring(2),"%G":P=>te(P),"%H":P=>M(P.cb,2),"%I":P=>(P=P.cb,P==0?P=12:12<P&&(P-=12),M(P,2)),"%j":P=>{for(var me=0,_e=0;_e<=P.eb-1;me+=(bt(P.$a+1900)?Xn:Jn)[_e++]);return M(P.ib+me,3)},"%m":P=>M(P.eb+1,2),"%M":P=>M(P.Jb,2),"%n":()=>`\n`,"%p":P=>0<=P.cb&&12>P.cb?"AM":"PM","%S":P=>M(P.Kb,2),"%t":()=>"	","%u":P=>P.Wa||7,"%U":P=>M(Math.floor((P.Za+7-P.Wa)/7),2),"%V":P=>{var me=Math.floor((P.Za+7-(P.Wa+6)%7)/7);if(2>=(P.Wa+371-P.Za-2)%7&&me++,me)me==53&&(_e=(P.Wa+371-P.Za)%7,_e==4||_e==3&&bt(P.$a)||(me=1));else{me=52;var _e=(P.Wa+7-P.Za-1)%7;(_e==4||_e==5&&bt(P.$a%400-1))&&me++}return M(me,2)},"%w":P=>P.Wa,"%W":P=>M(Math.floor((P.Za+7-(P.Wa+6)%7)/7),2),"%y":P=>(P.$a+1900).toString().substring(2),"%Y":P=>P.$a+1900,"%z":P=>{P=P.Ib;var me=0<=P;return P=Math.abs(P)/60,(me?"+":"-")+("0000"+(P/60*100+P%60)).slice(-4)},"%Z":P=>P.Lb,"%%":()=>"%"},f=f.replace(/%%/g,"\\0\\0");for(ue in ne)f.includes(ue)&&(f=f.replace(new RegExp(ue,"g"),ne[ue](S)));return f=f.replace(/\\0\\0/g,"%"),ue=Au(f),ue.length>c?0:(Iu(ue,i),ue.length-1)}function Ir(i){try{i()}catch(c){et(c)}}function Tu(i){var c={},f;for(f in i)(function(S){var E=i[S];c[S]=typeof E=="function"?function(){Tr.push(S);try{return E.apply(null,arguments)}finally{Ce||(Tr.pop()===S||et(),at&&wt===1&&Tr.length===0&&(wt=0,Ke+=1,Ir(po),typeof Fibers<"u"&&Fibers.Ub()))}}:E})(f);return c}var wt=0,at=null,eo=0,Tr=[],to={},ro={},Eu=0,sn=null,Ou=[];function ku(){return new Promise((i,c)=>{sn={resolve:i,reject:c}})}function Pu(){var i=un(65548),c=i+12;s()[i>>2>>>0]=c,s()[i+4>>2>>>0]=c+65536,c=Tr[0];var f=to[c];return f===void 0&&(f=Eu++,to[c]=f,ro[f]=c),c=f,n()[i+8>>2>>>0]=c,i}function Ru(){var i=n()[at+8>>2>>>0];return i=Z[ro[i]],--Ke,i()}function Bu(i){if(!Ce){if(wt===0){var c=!1,f=!1;i((S=0)=>{if(!Ce&&(eo=S,c=!0,f)){wt=2,Ir(()=>mo(at)),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.resume(),S=!1;try{var E=Ru()}catch(ae){E=ae,S=!0}var M=!1;if(!at){var W=sn;W&&(sn=null,(S?W.reject:W.resolve)(E),M=!0)}if(S&&!M)throw E}}),f=!0,c||(wt=1,at=Pu(),typeof Browser<"u"&&Browser.hb.sb&&Browser.hb.pause(),Ir(()=>co(at)))}else wt===2?(wt=0,Ir(fo),no(at),at=null,Ou.forEach(S=>nr(S))):et(`invalid state: ${wt}`);return eo}}function Mu(i){return Bu(c=>{i().then(c)})}le.gb();var Du=[null,jt,br,_t,Zt,vr,xr,Cr,_r,Ar,zt,Xt,Jt,Qt,er,tr,rr,l,m,ge,Se,k,se,ve,ar],zu={r:function(i,c,f){return Mu(async()=>{await a.xb(i,c,f)})},b:function(i,c,f){throw i>>>=0,new ot(i).gb(c>>>0,f>>>0),Qe=i,wr++,Qe},P:function(i){oo(i>>>0,!x,1,!y,131072,!1),le.lb()},n:function(i){i>>>=0,$?postMessage({cmd:"cleanupThread",thread:i}):Mt(i)},K:Yt,g:Zt,V:vr,F:xr,H:Cr,y:_r,T:Ar,L:zt,S:Xt,p:Jt,G:Qt,D:er,U:tr,E:rr,q:()=>!0,B:function(i,c){i>>>=0,i==c>>>0?setTimeout(()=>It()):$?postMessage({targetThread:i,cmd:"checkMailbox"}):(i=le.Qa[i])&&i.postMessage({cmd:"checkMailbox"})},N:function(){return-1},O:Vt,X:function(i){A&&le.Qa[i>>>0].ref()},u:function(i,c,f){i=c+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*c:NaN,f>>>=0,i=new Date(1e3*i),n()[f>>2>>>0]=i.getUTCSeconds(),n()[f+4>>2>>>0]=i.getUTCMinutes(),n()[f+8>>2>>>0]=i.getUTCHours(),n()[f+12>>2>>>0]=i.getUTCDate(),n()[f+16>>2>>>0]=i.getUTCMonth(),n()[f+20>>2>>>0]=i.getUTCFullYear()-1900,n()[f+24>>2>>>0]=i.getUTCDay(),i=(i.getTime()-Date.UTC(i.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,n()[f+28>>2>>>0]=i},v:function(i,c,f){i=c+2097152>>>0<4194305-!!i?(i>>>0)+4294967296*c:NaN,f>>>=0,i=new Date(1e3*i),n()[f>>2>>>0]=i.getSeconds(),n()[f+4>>2>>>0]=i.getMinutes(),n()[f+8>>2>>>0]=i.getHours(),n()[f+12>>2>>>0]=i.getDate(),n()[f+16>>2>>>0]=i.getMonth(),n()[f+20>>2>>>0]=i.getFullYear()-1900,n()[f+24>>2>>>0]=i.getDay(),c=(bt(i.getFullYear())?Tt:or)[i.getMonth()]+i.getDate()-1|0,n()[f+28>>2>>>0]=c,n()[f+36>>2>>>0]=-(60*i.getTimezoneOffset()),c=new Date(i.getFullYear(),6,1).getTimezoneOffset();var S=new Date(i.getFullYear(),0,1).getTimezoneOffset();i=(c!=S&&i.getTimezoneOffset()==Math.min(S,c))|0,n()[f+32>>2>>>0]=i},w:function(i){i>>>=0;var c=new Date(n()[i+20>>2>>>0]+1900,n()[i+16>>2>>>0],n()[i+12>>2>>>0],n()[i+8>>2>>>0],n()[i+4>>2>>>0],n()[i>>2>>>0],0),f=n()[i+32>>2>>>0],S=c.getTimezoneOffset(),E=new Date(c.getFullYear(),6,1).getTimezoneOffset(),M=new Date(c.getFullYear(),0,1).getTimezoneOffset(),W=Math.min(M,E);return 0>f?n()[i+32>>2>>>0]=+(E!=M&&W==S):0<f!=(W==S)&&(E=Math.max(M,E),c.setTime(c.getTime()+6e4*((0<f?W:E)-S))),n()[i+24>>2>>>0]=c.getDay(),f=(bt(c.getFullYear())?Tt:or)[c.getMonth()]+c.getDate()-1|0,n()[i+28>>2>>>0]=f,n()[i>>2>>>0]=c.getSeconds(),n()[i+4>>2>>>0]=c.getMinutes(),n()[i+8>>2>>>0]=c.getHours(),n()[i+12>>2>>>0]=c.getDate(),n()[i+16>>2>>>0]=c.getMonth(),n()[i+20>>2>>>0]=c.getYear(),i=c.getTime()/1e3,so((ft=i,1<=+Math.abs(ft)?0<ft?+Math.floor(ft/4294967296)>>>0:~~+Math.ceil((ft-+(~~ft>>>0))/4294967296)>>>0:0)),i>>>0},s:l,t:m,A:function(i,c,f){function S(ne){return(ne=ne.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?ne[1]:"GMT"}i>>>=0,c>>>=0,f>>>=0;var E=new Date().getFullYear(),M=new Date(E,0,1),W=new Date(E,6,1);E=M.getTimezoneOffset();var ae=W.getTimezoneOffset(),te=Math.max(E,ae);s()[i>>2>>>0]=60*te,n()[c>>2>>>0]=+(E!=ae),i=S(M),c=S(W),i=b(i),c=b(c),ae<E?(s()[f>>2>>>0]=i,s()[f+4>>2>>>0]=c):(s()[f>>2>>>0]=c,s()[f+4>>2>>>0]=i)},e:()=>{et("")},c:function(i,c,f){return i>>>=0,c=O(c>>>0,f>>>0),Rt[i].apply(null,c)},l:function(i,c,f){return i>>>=0,c=O(c>>>0,f>>>0),Rt[i].apply(null,c)},o:function(){},k:function(){return Date.now()},W:()=>{throw Ke+=1,"unwind"},C:function(){return 4294901760},d:()=>performance.timeOrigin+performance.now(),i:function(){return A?(xo(),Ut(So)).cpus().length:navigator.hardwareConcurrency},M:function(i,c,f,S){for(le.Pb=c>>>0,de.length=f,c=S>>>0>>3,S=0;S<f;S++)de[S]=d()[c+S>>>0];return(0>i?Rt[-i-1]:Du[i]).apply(null,de)},z:function(i){i>>>=0;var c=o().length;if(i<=c||4294901760<i)return!1;for(var f=1;4>=f;f*=2){var S=c*(1+.2/f);S=Math.min(S,i+100663296);var E=Math;S=Math.max(i,S);e:{E=E.min.call(E,4294901760,S+(65536-S%65536)%65536)-we.buffer.byteLength+65535>>>16;try{we.grow(E),he();var M=1;break e}catch{}M=void 0}if(M)return!0}return!1},Q:ge,R:Se,J:Kt,h:k,m:se,x:ve,j:ar,a:we||a.wasmMemory,I:Qn,f:function(i,c,f,S){return Qn(i>>>0,c>>>0,f>>>0,S>>>0)}};(function(){function i(f,S){return f=f.exports,f=Tu(f),Z=f=Vu(f),le.mb.push(Z.Da),Me.unshift(Z.Y),ye=S,hr(),f}var c={a:zu};if(Gt(),a.instantiateWasm)try{return a.instantiateWasm(c,i)}catch(f){q("Module.instantiateWasm callback failed with error: "+f),h(f)}return gr(c,function(f){i(f.instance,f.module)}).catch(h),{}})(),a._OrtInit=(i,c)=>(a._OrtInit=Z.Z)(i,c),a._OrtGetLastError=(i,c)=>(a._OrtGetLastError=Z._)(i,c),a._OrtCreateSessionOptions=(i,c,f,S,E,M,W,ae,te,ne)=>(a._OrtCreateSessionOptions=Z.$)(i,c,f,S,E,M,W,ae,te,ne),a._OrtAppendExecutionProvider=(i,c)=>(a._OrtAppendExecutionProvider=Z.aa)(i,c),a._OrtAddFreeDimensionOverride=(i,c,f)=>(a._OrtAddFreeDimensionOverride=Z.ba)(i,c,f),a._OrtAddSessionConfigEntry=(i,c,f)=>(a._OrtAddSessionConfigEntry=Z.ca)(i,c,f),a._OrtReleaseSessionOptions=i=>(a._OrtReleaseSessionOptions=Z.da)(i),a._OrtCreateSession=(i,c,f)=>(a._OrtCreateSession=Z.ea)(i,c,f),a._OrtReleaseSession=i=>(a._OrtReleaseSession=Z.fa)(i),a._OrtGetInputOutputCount=(i,c,f)=>(a._OrtGetInputOutputCount=Z.ga)(i,c,f),a._OrtGetInputName=(i,c)=>(a._OrtGetInputName=Z.ha)(i,c),a._OrtGetOutputName=(i,c)=>(a._OrtGetOutputName=Z.ia)(i,c),a._OrtFree=i=>(a._OrtFree=Z.ja)(i),a._OrtCreateTensor=(i,c,f,S,E,M)=>(a._OrtCreateTensor=Z.ka)(i,c,f,S,E,M),a._OrtGetTensorData=(i,c,f,S,E)=>(a._OrtGetTensorData=Z.la)(i,c,f,S,E),a._OrtReleaseTensor=i=>(a._OrtReleaseTensor=Z.ma)(i),a._OrtCreateRunOptions=(i,c,f,S)=>(a._OrtCreateRunOptions=Z.na)(i,c,f,S),a._OrtAddRunConfigEntry=(i,c,f)=>(a._OrtAddRunConfigEntry=Z.oa)(i,c,f),a._OrtReleaseRunOptions=i=>(a._OrtReleaseRunOptions=Z.pa)(i),a._OrtCreateBinding=i=>(a._OrtCreateBinding=Z.qa)(i),a._OrtBindInput=(i,c,f)=>(a._OrtBindInput=Z.ra)(i,c,f),a._OrtBindOutput=(i,c,f,S)=>(a._OrtBindOutput=Z.sa)(i,c,f,S),a._OrtClearBoundOutputs=i=>(a._OrtClearBoundOutputs=Z.ta)(i),a._OrtReleaseBinding=i=>(a._OrtReleaseBinding=Z.ua)(i),a._OrtRunWithBinding=(i,c,f,S,E)=>(a._OrtRunWithBinding=Z.va)(i,c,f,S,E),a._OrtRun=(i,c,f,S,E,M,W,ae)=>(a._OrtRun=Z.wa)(i,c,f,S,E,M,W,ae),a._OrtEndProfiling=i=>(a._OrtEndProfiling=Z.xa)(i),a._JsepOutput=(i,c,f)=>(a._JsepOutput=Z.ya)(i,c,f),a._JsepGetNodeName=i=>(a._JsepGetNodeName=Z.za)(i);var Er=a._pthread_self=()=>(Er=a._pthread_self=Z.Aa)(),un=a._malloc=i=>(un=a._malloc=Z.Ba)(i),no=a._free=i=>(no=a._free=Z.Ca)(i);a.__emscripten_tls_init=()=>(a.__emscripten_tls_init=Z.Da)();var oo=a.__emscripten_thread_init=(i,c,f,S,E,M)=>(oo=a.__emscripten_thread_init=Z.Fa)(i,c,f,S,E,M);a.__emscripten_thread_crashed=()=>(a.__emscripten_thread_crashed=Z.Ga)();var ao=(i,c,f,S)=>(ao=Z.Ha)(i,c,f,S),ln=i=>(ln=Z.Ia)(i),dn=a.__emscripten_thread_exit=i=>(dn=a.__emscripten_thread_exit=Z.Ja)(i),io=a.__emscripten_check_mailbox=()=>(io=a.__emscripten_check_mailbox=Z.Ka)(),so=i=>(so=Z.La)(i),uo=(i,c)=>(uo=Z.Ma)(i,c),cn=()=>(cn=Z.Na)(),Or=i=>(Or=Z.Oa)(i),pn=i=>(pn=Z.Pa)(i),lo=a.dynCall_ii=(i,c)=>(lo=a.dynCall_ii=Z.Ra)(i,c),co=i=>(co=Z.Sa)(i),po=()=>(po=Z.Ta)(),mo=i=>(mo=Z.Ua)(i),fo=()=>(fo=Z.Va)();a.___start_em_js=1439850,a.___stop_em_js=1440011;function Vu(i){i=Object.assign({},i);var c=S=>()=>S()>>>0,f=S=>E=>S(E)>>>0;return i.__errno_location=c(i.__errno_location),i.pthread_self=c(i.pthread_self),i.malloc=f(i.malloc),i.stackSave=c(i.stackSave),i.stackAlloc=f(i.stackAlloc),i}a.keepRuntimeAlive=nt,a.wasmMemory=we,a.stackAlloc=pn,a.stackSave=cn,a.stackRestore=Or,a.UTF8ToString=qe,a.stringToUTF8=Sr,a.lengthBytesUTF8=At,a.ExitStatus=yt,a.PThread=le;var kr;Ct=function i(){kr||ho(),kr||(Ct=i)};function ho(){function i(){if(!kr&&(kr=!0,a.calledRun=!0,!Ce)&&($||ht(Me),p(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),!$)){if(a.postRun)for(typeof a.postRun=="function"&&(a.postRun=[a.postRun]);a.postRun.length;){var c=a.postRun.shift();Ge.unshift(c)}ht(Ge)}}if(!(0<Je))if($)p(a),$||ht(Me),startWorker(a);else{if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;)Ze.unshift(a.preRun.shift());ht(Ze),0<Je||(a.setStatus?(a.setStatus("Running..."),setTimeout(function(){setTimeout(function(){a.setStatus("")},1),i()},1)):i())}}if(a.preInit)for(typeof a.preInit=="function"&&(a.preInit=[a.preInit]);0<a.preInit.length;)a.preInit.pop()();return ho(),t.ready}})();typeof _o=="object"&&typeof wn=="object"?wn.exports=Co:typeof define=="function"&&define.amd&&define([],()=>Co)});var Io=ir((Gc,qu)=>{qu.exports=\'"use strict";var Module={},ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads"),parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",e=>onmessage({data:e}));var fs=require("fs");Object.assign(global,{self:global,require,Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:e=>(0,eval)(fs.readFileSync(e,"utf8")+"//# sourceURL="+e),postMessage:e=>parentPort.postMessage(e),performance:global.performance||{now:Date.now}})}var initializedJS=!1;function threadPrintErr(){var e=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,e+`\\n`);return}console.error(e)}function threadAlert(){var e=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:e,threadId:Module._pthread_self()})}var err=threadPrintErr;self.alert=threadAlert,Module.instantiateWasm=(e,t)=>{var a=Module.wasmModule;Module.wasmModule=null;var r=new WebAssembly.Instance(a,e);return t(r)},self.onunhandledrejection=e=>{throw e.reason??e};function handleMessage(e){try{if(e.data.cmd==="load"){let a=[];self.onmessage=r=>a.push(r),self.startWorker=r=>{Module=r,postMessage({cmd:"loaded"});for(let s of a)handleMessage(s);self.onmessage=handleMessage},Module.wasmModule=e.data.wasmModule;for(const r of e.data.handlers)Module[r]=(...s)=>{postMessage({cmd:"callHandler",handler:r,args:s})};if(Module.wasmMemory=e.data.wasmMemory,Module.buffer=Module.wasmMemory.buffer,Module.ENVIRONMENT_IS_PTHREAD=!0,typeof e.data.urlOrBlob=="string")importScripts(e.data.urlOrBlob);else{var t=URL.createObjectURL(e.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}ortWasmThreaded(Module)}else if(e.data.cmd==="run"){Module.__emscripten_thread_init(e.data.pthread_ptr,0,0,1),Module.__emscripten_thread_mailbox_await(e.data.pthread_ptr),Module.establishStackSpace(),Module.PThread.receiveObjectTransfer(e.data),Module.PThread.threadInitTLS(),initializedJS||(initializedJS=!0);try{Module.invokeEntryPoint(e.data.start_routine,e.data.arg)}catch(a){if(a!="unwind")throw a}}else e.data.cmd==="cancel"?Module._pthread_self()&&Module.__emscripten_thread_exit(-1):e.data.target==="setimmediate"||(e.data.cmd==="checkMailbox"?initializedJS&&Module.checkMailbox():e.data.cmd&&(err("worker.js received unknown command "+e.data.cmd),err(e.data)))}catch(a){throw Module.__emscripten_thread_crashed&&Module.__emscripten_thread_crashed(),a}}self.onmessage=handleMessage;\\n\'});var Sn,Ot,ur,Br,lr,Ro,xn,Ue=Y(()=>{"use strict";Sn=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},Ot=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},ur=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],Br=e=>{switch(e){case"float16":return Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},lr=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Ro=e=>e==="float32"||e==="int32"||e==="int64"||e==="bool"||e==="float16"||e==="uint32",xn=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;default:throw new Error(`unsupported data location: ${e}`)}}});var tl,rl,Bo,Mo,Do,nl,Pe,vt=Y(()=>{"use strict";Ue();tl=["V","I","W","E","F"],rl=(e,t)=>{console.log(`[${tl[e]},${new Date().toISOString()}]${t}`)},Do=(e,t)=>{Bo=e,Mo=t},nl=(e,t)=>{let r=lr(e),o=lr(Bo);r>=o&&rl(r,typeof t=="function"?t():t)},Pe=(...e)=>{Mo&&nl(...e)}});var zo,Vo=Y(()=>{"use strict";Ue();zo=(e,t)=>new(Br(t))(e)});var Mr=Y(()=>{"use strict"});var Dr,ol,Uo,_n,Cn,No,Ho=Y(()=>{"use strict";vt();Mr();Dr=e=>Math.ceil(e/16)*16,ol=1,Uo=()=>ol++,_n=async(e,t,r,o)=>{let n=Dr(r),s=e.device.createBuffer({size:n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let u=e.getCommandEncoder();e.endComputePass(),u.copyBufferToBuffer(t,0,s,0,n),e.flush(),await s.mapAsync(GPUMapMode.READ);let d=s.getMappedRange();if(o){let a=o();return a.set(new Uint8Array(d,0,r)),a}else return new Uint8Array(d.slice(0,r))}finally{s.destroy()}},Cn=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersForUploadingPending=[],this.buffersPending=[],this.externalBuffers=new Map}upload(t,r){let o=r.buffer,n=r.byteOffset,s=r.byteLength,u=Dr(s),d=this.storageCache.get(t);if(!d)throw new Error("gpu data for uploading does not exist");if(d.originalSize!==s)throw new Error(`inconsistent data size. gpu data size=${d.originalSize}, data size=${s}`);let a=this.backend.device.createBuffer({mappedAtCreation:!0,size:u,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),p=a.getMappedRange();new Uint8Array(p).set(new Uint8Array(o,n,s)),a.unmap();let h=this.backend.getCommandEncoder();this.backend.endComputePass(),h.copyBufferToBuffer(a,0,d.gpuData.buffer,0,u),Pe("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`),this.buffersForUploadingPending.push(a)}memcpy(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("source gpu data for memcpy does not exist");let n=this.storageCache.get(r);if(!n)throw new Error("destination gpu data for memcpy does not exist");if(o.originalSize!==n.originalSize)throw new Error("inconsistent source and destination gpu data size");let s=Dr(o.originalSize),u=this.backend.getCommandEncoder();this.backend.endComputePass(),u.copyBufferToBuffer(o.gpuData.buffer,0,n.gpuData.buffer,0,s)}registerExternalBuffer(t,r,o){let n;if(o){if(n=this.externalBuffers.get(o),n===void 0)throw new Error("previous buffer is not registered");if(t===o)return Pe("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, buffer is the same, skip.`),n;this.externalBuffers.delete(o)}else n=Uo();return this.storageCache.set(n,{gpuData:{id:n,type:0,buffer:t},originalSize:r}),this.externalBuffers.set(t,n),Pe("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${n}, registered.`),n}unregisterExternalBuffer(t){let r=this.externalBuffers.get(t);r!==void 0&&(this.storageCache.delete(r),this.externalBuffers.delete(t),Pe("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${r}`))}create(t,r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let o=Dr(t),n,s=(r&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,u=(r&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(s||u){let a=s?this.freeBuffers:this.freeUniformBuffers,p=a.get(o);p||(p=[],a.set(o,p)),p.length>0?n=p.pop():n=this.backend.device.createBuffer({size:o,usage:r})}else n=this.backend.device.createBuffer({size:o,usage:r});let d={id:Uo(),type:0,buffer:n};return this.storageCache.set(d.id,{gpuData:d,originalSize:t}),Pe("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${d.id}`),d}get(t){return this.storageCache.get(t)?.gpuData}release(t){let r=this.storageCache.get(t);if(!r)throw new Error("releasing data does not exist");return Pe("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,r){let o=this.storageCache.get(t);if(!o)throw new Error("data does not exist");await _n(this.backend,o.gpuData.buffer,o.originalSize,r)}refreshPendingBuffers(){for(let t of this.buffersForUploadingPending)t.destroy();this.buffersForUploadingPending=[];for(let t of this.buffersPending)(t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE?this.freeBuffers.get(t.size).push(t):(t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM?this.freeUniformBuffers.get(t.size).push(t):t.destroy();this.buffersPending=[]}dispose(){this.freeBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(r=>{r.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map}},No=(...e)=>new Cn(...e)});var An,ie,Re=Y(()=>{"use strict";An=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this.key}},ie=e=>new An(e)});var In,it,D,kt,zr,Vr,Ur,$e=Y(()=>{"use strict";In=class{static calcMatMulShape(t,r){return t[1]!==r[0]?void 0:[t[0],r[1]]}},it=class{static calcShape(t,r,o=!1){let n=t.length,s=r.length;if(n===0)return r;if(s===0)return t;let u=Math.max(t.length,r.length),d=new Array(u);if(o){if(n<2||s<2)return;let a=In.calcMatMulShape([t[n-2],t[n-1]],[r[s-2],r[s-1]]);if(a===void 0)return;[d[u-2],d[u-1]]=a}for(let a=o?3:1;a<=u;a++){let p=n-a<0?1:t[n-a],h=s-a<0?1:r[s-a];if(p!==h&&p>1&&h>1)return;d[u-a]=Math.max(p,h)}return d}static isValidBroadcast(t,r){let o=t.length,n=r.length;if(o>n)return!1;for(let s=1;s<=o;s++)if(t[o-s]!==1&&t[o-s]!==r[n-s])return!1;return!0}},D=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(t,r,o){let n=1;for(let s=r;s<o;s++){if(t[s]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");n*=t[s]}return n}static computeStrides(t){let r=t.length;if(r===0)return[];if(r===1)return[1];let o=new Array(r);o[r-1]=1,o[r-2]=t[r-1];for(let n=r-3;n>=0;--n)o[n]=o[n+1]*t[n+1];return o}static normalizeAxis(t,r){if(t<-r&&t>=r)throw new Error("unsupported axis for this operation.");return t<0?t+r:t}static normalizeAxes(t,r){return t.map(o=>this.normalizeAxis(o,r??t.length))}static sortBasedOnPerm(t,r){return r?r.map(o=>t[o]):t.slice().reverse()}static padShape(t,r){let o=t.length;return t.map((n,s)=>n+r[s]+r[s+o])}static areEqual(t,r){return t.length!==r.length?!1:t.every((o,n)=>o===r[n])}},kt=class e{static adjustPoolAttributes(t,r,o,n,s,u){if(!t&&o.length!==r.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(t)for(let d=0;d<r.length-2;d++)d>=o.length?o.push(r[d+2]):o[d]=r[d+2];for(let d=0;d<o.length;d++)if(d<n.length){if(n[d]<0)throw new Error("strides should be greater than or equal to 1")}else n.push(1);for(let d=0;d<o.length;d++)if(d<s.length){if(s[d]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let d=0;d<o.length*2;d++)if(d<u.length){if(u[d]<0)throw new Error("pad should be greater than or equal to 1")}else u.push(0);for(let d=0;d<o.length;d++){if(o[d]<=0)throw new Error("kernel shapes need to be greater than 0");if(u[d]>=o[d]||u[d+o.length]>=o[d])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,o,n,s,u,d){if(d){if(s.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let a=0;a<t.length-2;a++)e.adjustPadAndReturnShape(t[a+(u?1:2)],r[a],o[a],n[a],s,a,a+t.length-2,d)}}static computePoolOutputShape(t,r,o,n,s,u,d){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let a=[r[0],r[1]];return e.computeShapeHelper(t,r,a,o,n,s,u,d),a}static computeConvOutputShape(t,r,o,n,s,u,d){if(t.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let a=[t[0],r[0]];return e.computeShapeHelper(!1,t,a,o,n,s,u,d),a}static computeShapeHelper(t,r,o,n,s,u,d,a){if(t)for(let p=0;p<r.length-2;p++)o.push(1);else for(let p=0;p<r.length-2;p++)o.push(e.adjustPadAndReturnShape(r[p+2],n[p],s[p],u[p],d,p,p+r.length-2,a))}static adjustPadAndReturnShape(t,r,o,n,s,u,d,a){let p=o*(n-1)+1;if(a&&a!=="NOTSET")switch(a){case"VALID":return s[u]=0,s[d]=0,Math.floor((t-p)/r+1);case"SAME_LOWER":case"SAME_UPPER":if(o!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let v=((t+r-1)/r-1)*r+n-t;return s[u]=Math.floor(a==="SAME_LOWER"?(v+1)/2:v/2),s[d]=v-s[u],Math.floor((t+v-n)/r+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((t+s[u]+s[d]-p)/r+1)}},zr=class{static getShapeOfGemmResult(t,r,o,n,s){if(t.length!==2||o.length!==2)throw new Error("shape need to be of size 2");let u,d,a;r?(u=t[1],d=t[0]):(u=t[0],d=t[1]);let p=-1;if(n?(a=o[0],p=1):(a=o[1],p=0),o[p]!==d)throw new Error("dimension mismatch");if(u<=0||a<=0||d<=0)throw new Error("invalid shape specified");if(s&&!it.isValidBroadcast(s,[u,a]))throw new Error("gemm: invalid bias shape for broadcast");return[u,a,d]}},Vr=-34028234663852886e22,Ur=34028234663852886e22});var al,En,Oe,$t,j,Ne,je,tt,Xe,Ie,On,V,K,Wr,Tn,Go,Wt,ke,be=Y(()=>{"use strict";Ue();$e();al=64,En=(e,t)=>{if(t===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(e){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(t!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];default:throw new Error(`Unknown data type: ${e}`)}},Oe=(e,t=1)=>{let r=En(e,t);return typeof r=="string"?r:r[0]},$t=(e,t=1)=>{let r=En(e,t);return typeof r=="string"?r:r[1]},j=e=>e.length===0?[]:[{type:"uint32",data:e},{type:"uint32",data:D.computeStrides(e)}],Ne=e=>e%4===0?4:e%2===0?2:1,je=(e="f32",t,r="0")=>!t||t===1?`${e}(${r})`:`vec${t}<${e}>(${r})`,tt=(e,t,r)=>e==="f32"?r:t===1?`f32(${r})`:`vec${t}f(${r})`,Xe=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,Ie=(e,t,r)=>e.startsWith("uniforms.")&&r>4?typeof t=="string"?`${e}[(${t}) / 4][(${t}) % 4]`:`${e}[${Math.floor(t/4)}][${t%4}]`:r>1?`${e}[${t}]`:e,On=(e,t,r,o,n)=>{let s=typeof r=="number",u=s?r:r.length,d=[...new Array(u).keys()],a=u<2?"u32":u<=4?`vec${u}<u32>`:`array<u32, ${u}>`,p=En(t,n),h=typeof p=="string"?p:p[1],v=typeof p=="string"?p:p[0],g={indices:a,value:h,storage:v,tensor:t},w=L=>typeof L=="string"?L:`${L}u`,y={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},x=s?"uniforms.":"",A=`${x}${e}_shape`,$=`${x}${e}_strides`,_="";for(let L=0;L<u-1;L++)_+=`\n    let dim${L} = current / ${Ie($,L,u)};\n    let rest${L} = current % ${Ie($,L,u)};\n    indices[${L}] = dim${L};\n    current = rest${L};\n    `;_+=`indices[${u-1}] = current;`;let R=u<2?"":`\n  fn o2i_${e}(offset: u32) -> ${g.indices} {\n    var indices: ${g.indices};\n    var current = offset;\n    ${_}\n    return indices;\n  }`,I=L=>(y.offsetToIndices=!0,u<2?L:`o2i_${e}(${L})`),z=[];if(u>=2)for(let L=u-1;L>=0;L--)z.push(`${Ie($,L,u)} * (indices[${L}])`);let T=u<2?"":`\n  fn i2o_${e}(indices: ${g.indices}) -> u32 {\n    return ${z.join("+")};\n  }`,N=L=>(y.indicesToOffset=!0,u<2?L:`i2o_${e}(${L})`),U=(...L)=>u===0?"0u":`${g.indices}(${L.map(w).join(",")})`,G=(L,re)=>u<2?`${L}`:`${Ie(L,re,u)}`,J=(L,re,he)=>u<2?`${L}=${he};`:`${Ie(L,re,u)}=${he};`,B={},q=(L,re)=>{y.broadcastedIndicesToOffset=!0;let he=`${re.name}broadcastedIndicesTo${e}Offset`;if(he in B)return`${he}(${L})`;let Fe=[];for(let Ze=u-1;Ze>=0;Ze--){let Me=re.indicesGet("outputIndices",Ze+re.rank-u);Fe.push(`${G($,Ze)} * (${Me} % ${G(A,Ze)})`)}return B[he]=`fn ${he}(outputIndices: ${re.type.indices}) -> u32 {\n             return ${Fe.length>0?Fe.join("+"):"0u"};\n           }`,`${he}(${L})`},pe=(L,re)=>(()=>{if(g.storage===g.value)return`${e}[${L}]=${re};`;if(g.storage==="vec2<u32>"&&g.value==="i32")return`${e}[${L}]=vec2<u32>(u32(${re}), select(0u, 0xFFFFFFFFu, ${re} < 0));`;if(g.storage==="vec2<u32>"&&g.value==="u32")return`${e}[${L}]=vec2<u32>(u32(${re}), 0u);`;if(g.storage==="u32"&&g.value==="vec4<bool>")return`${e}[${L}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${re}));`;throw new Error(`not supported combination of storage type ${g.storage} and value type ${g.value} yet`)})(),Q=L=>(()=>{if(g.storage===g.value)return`${e}[${L}]`;if(g.storage==="vec2<u32>"&&g.value==="i32")return`i32(${e}[${L}].x)`;if(g.storage==="vec2<u32>"&&g.value==="u32")return`u32(${e}[${L}].x)`;if(g.storage==="u32"&&g.value==="vec4<bool>")return`vec4<bool>(bool(${e}[${L}] & 0xFFu), bool(${e}[${L}] & 0xFF00u), bool(${e}[${L}] & 0xFF0000u), bool(${e}[${L}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${g.storage} and value type ${g.value} yet`)})(),we=u<2?"":`\n  fn get_${e}ByIndices(indices: ${g.indices}) -> ${h} {\n    return ${Q(`i2o_${e}(indices)`)};\n  }`,Z=u<2?"":(()=>{let L=d.map(he=>`d${he}: u32`).join(", "),re=d.map(he=>`d${he}`).join(", ");return`\n  fn get_${e}(${L}) -> ${h} {\n    return get_${e}ByIndices(${U(re)});\n  }`})(),ye=(...L)=>{if(L.length!==u)throw new Error(`indices length must be ${u}`);let re=L.map(w).join(",");return u===0?Q("0u"):u===1?Q(re[0]):(y.get=!0,y.getByIndices=!0,y.indicesToOffset=!0,`get_${e}(${re})`)},Ce=L=>u<2?Q(L):(y.getByIndices=!0,y.indicesToOffset=!0,`get_${e}ByIndices(${L})`),fe=u<2?"":`\n  fn set_${e}ByIndices(indices: ${g.indices}, value: ${h}) {\n    ${pe(`i2o_${e}(indices)`,"value")}\n  }`,ce=u<2?"":(()=>{let L=d.map(he=>`d${he}: u32`).join(", "),re=d.map(he=>`d${he}`).join(", ");return`\n  fn set_${e}(${L}, value: ${h}) {\n    set_${e}ByIndices(${U(re)}, value);\n  }`})();return{impl:()=>{let L=[];return s||(L.push(`const ${A} = ${g.indices}(${r.join(",")});`),L.push(`const ${$} = ${g.indices}(${D.computeStrides(r).join(",")});`)),y.offsetToIndices&&L.push(R),y.indicesToOffset&&L.push(T),y.broadcastedIndicesToOffset&&Object.values(B).forEach(re=>L.push(re)),y.set&&L.push(ce),y.setByIndices&&L.push(fe),y.get&&L.push(Z),y.getByIndices&&L.push(we),L.join(`\n`)},type:g,offsetToIndices:I,indicesToOffset:N,broadcastedIndicesToOffset:q,indices:U,indicesGet:G,indicesSet:J,set:(...L)=>{if(L.length!==u+1)throw new Error(`indices length must be ${u}`);let re=L[u];if(typeof re!="string")throw new Error("value must be string");let he=L.slice(0,u).map(w).join(",");return u===0?pe("0u",re):u===1?pe(he[0],re):(y.set=!0,y.setByIndices=!0,y.indicesToOffset=!0,`set_${e}(${he}, ${re})`)},setByOffset:pe,setByIndices:(L,re)=>u<2?pe(L,re):(y.setByIndices=!0,y.indicesToOffset=!0,`set_${e}ByIndices(${L}, ${re});`),get:ye,getByOffset:Q,getByIndices:Ce,usage:o,name:e,strides:$,shape:A,rank:u}},V=(e,t,r,o=1)=>On(e,t,r,"input",o),K=(e,t,r,o=1)=>On(e,t,r,"output",o),Wr=(e,t,r,o=1)=>On(e,t,r,"internal",o),Tn=class{constructor(t){this.normalizedDispatchGroup=t;this.internalVariables=[];this.variables=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=al){let r=typeof t=="number"?t:t[0],o=typeof t=="number"?1:t[1],n=typeof t=="number"?1:t[2],s=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,u=s?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(local_invocation_index) local_idx : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>`,d=s?"let global_idx = global_id.x; let local_idx = local_id.x;":`let global_idx = (workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n          workgroup_id.y * num_workgroups[0] + workgroup_id.x) * ${r*o*n}u + local_idx;`;return`@compute @workgroup_size(${r}, ${o}, ${n})\n  fn main(${u}) {\n    ${d}\n  `}appendVariableUniforms(t){t.rank!==0&&(t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:"u32",length:t.rank}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:"u32",length:t.rank}))}declareVariable(t,r){if(t.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(t),this.appendVariableUniforms(t);let o=t.usage==="input"?"read":"read_write",n=t.type.storage;return`@group(0) @binding(${r}) var<storage, ${o}> ${t.name}: array<${n}>;`}declareVariables(...t){return t.map(r=>this.declareVariable(r,this.variableIndex++)).join(`\n`)}registerInternalVariable(t){if(t.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(t),this.appendVariableUniforms(t)}registerInternalVariables(...t){return t.forEach(r=>this.registerInternalVariable(r)),this}registerUniform(t,r,o=1){return this.uniforms.push({name:t,type:r,length:o}),this}registerUniforms(t){return this.uniforms=this.uniforms.concat(t),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:r,type:o,length:n}of this.uniforms)if(n&&n>4)t.push(`${r}:array<vec4<${o}>, ${Math.ceil(n/4)}>`);else{let s=n==null||n===1?o:`vec${n}<${o}>`;t.push(`${r}:${s}`)}return`\n      struct Uniforms { ${t.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(t=>t.impl()).join(`\n`)+this.internalVariables.map(t=>t.impl()).join(`\n`)}},Go=e=>new Tn(e),Wt=(e,t)=>{let r=e.length,o=[];for(let n=0;n<r;n++){let s=r-1-n,u=e[s]||1;(t[t.length-1-n]||1)>1&&u===1&&o.unshift(s)}return o},ke=e=>!0});var il,Lo,sl,ul,rt,Fo,qo,Nt=Y(()=>{"use strict";$e();Re();be();il=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.")},Lo=(e,t)=>t&&t.length!==e?[...new Array(e).keys()].reverse():t,sl=(e,t)=>D.sortBasedOnPerm(e,Lo(e.length,t)),ul=(e,t,r,o)=>{let n=[];n.push(`fn perm(i: ${o.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let s=0;s<t;++s)n.push(r.indicesSet("a",e[s],`i[${s}]`));return n.push("return a;}"),n.join(`\n`)},rt=(e,t)=>{let r=e.dataType,o=e.dims.length,n=Lo(o,t),s=ke(o),u=sl(e.dims,n),d=s?u.length:u,a=s?o:e.dims,p=K("output",r,d),h=V("a",r,a),v=g=>`\n  ${g.registerUniform("output_size","u32").declareVariables(h,p)}\n\n  ${ul(n,o,h,p)}\n\n  ${g.mainStart()}\n    ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${p.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${p.setByOffset("global_idx",h.getByIndices("aIndices"))}\n  }`;return{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:s?["rank"]:["dims"]},getRunData:g=>{let w=D.size(u);return{outputs:[{dims:u,dataType:g[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:s?[{type:"uint32",data:w},...j(g[0].dims),...j(u)]:[{type:"uint32",data:w}]}},getShaderSource:v}},Fo=(e,t)=>{il(e.inputs),e.compute(rt(e.inputs[0],t.perm))},qo=e=>ie({perm:e.perm})});var ll,dl,cl,pl,ml,fl,hl,gl,yl,bl,st,jo,Ko,Yo,Zo,Xo,Jo,Qo,ea,ta,ra,na=Y(()=>{"use strict";$e();be();Nr();Nt();ll={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},dl={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},cl={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},pl={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},ml=(e,t)=>{let r=[];for(let o=t-e;o<t;++o)r.push(o);return r},fl=(e,t)=>{let r=[],o=e.length;for(let s=0;s<o;s++)t.indexOf(s)===-1&&r.push(e[s]);let n=t.map(s=>e[s]);return[r,n]},hl=(e,t)=>{let r=e.length+t.length,o=[],n=0;for(let s=0;s<r;s++)t.indexOf(s)===-1?o.push(e[n++]):o.push(1);return o},gl=(e,t)=>{for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0},yl=(e,t)=>{let r=[];if(!gl(e,t)){for(let o=0;o<t;++o)e.indexOf(o)===-1&&r.push(o);e.forEach(o=>r.push(o))}return r},bl=(e,t,r,o,n,s,u)=>{let d=r[0].dims,a=D.size(s),p=D.size(u),h=V("_A",r[0].dataType,d),v=K("output",n,s),g=32,w=`\n          var<workgroup> aBestValues : array<${v.type.storage}, ${g}>;\n       `;return{name:e,shaderCache:t,getShaderSource:x=>`\n        ${x.registerUniform("reduceSize","u32").declareVariables(h,v)}\n        ${w}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${x.mainStart(g)}\n\n          let outputIndex = global_idx / ${g};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = ${v.type.storage}(${cl[o]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${g}) {\n           let candidate = ${v.type.storage}(${h.getByOffset("offset + k")});\n           bestValue = ${ll[o]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${g}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${dl[o]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${v.setByOffset("outputIndex",`${o==="mean"?`bestValue / ${v.type.storage}(uniforms.reduceSize)`:`${pl[o]}`}`)};\n         }\n        }`,getRunData:()=>({outputs:[{dims:s,dataType:n}],dispatchGroup:{x:a},programUniforms:[{type:"uint32",data:p}]})}},st=(e,t,r,o)=>{let n=e.inputs.length===1?r:kn(e.inputs,r),s=n.axes;s.length===0&&!n.noopWithEmptyAxes&&(s=e.inputs[0].dims.map((w,y)=>y));let u=D.normalizeAxes(s,e.inputs[0].dims.length),d=u,a=e.inputs[0],p=yl(d,e.inputs[0].dims.length);p.length>0&&(a=e.compute(rt(e.inputs[0],p),{inputs:[0],outputs:[-1]})[0],d=ml(d.length,a.dims.length));let[h,v]=fl(a.dims,d),g=h;n.keepDims&&(g=hl(h,u)),e.compute(bl(t,{hint:n.cacheKey,inputDependencies:["type"]},[a],o,e.inputs[0].dataType,g,v),{inputs:[a]})},jo=(e,t)=>{st(e,"ReduceMeanShared",t,"mean")},Ko=(e,t)=>{st(e,"ReduceL1Shared",t,"l1")},Yo=(e,t)=>{st(e,"ReduceL2Shared",t,"l2")},Zo=(e,t)=>{st(e,"ReduceLogSumExpShared",t,"logSumExp")},Xo=(e,t)=>{st(e,"ReduceMaxShared",t,"max")},Jo=(e,t)=>{st(e,"ReduceMinShared",t,"min")},Qo=(e,t)=>{st(e,"ReduceProdShared",t,"prod")},ea=(e,t)=>{st(e,"ReduceSumShared",t,"sum")},ta=(e,t)=>{st(e,"ReduceSumSquareShared",t,"sumSquare")},ra=(e,t)=>{st(e,"ReduceLogSumShared",t,"logSum")}});var ut,wl,Hr,kn,lt,vl,$l,Sl,xl,Cl,_l,Al,Il,Tl,El,dt,oa,aa,ia,sa,ua,la,da,ca,pa,ma,Nr=Y(()=>{"use strict";$e();Re();be();na();ut=e=>{if(!e||e.length===0||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(e.length===2&&e[1].dims.length!==1)throw new Error("Invalid axes input dims.")},wl=e=>["","",`var value = ${e.getByIndices("input_indices")};`,""],Hr=(e,t,r,o,n,s,u=!1,d=!1)=>{let a=[],p=r[0].dims,h=p.length,v=D.normalizeAxes(n,h),g=!d&&v.length===0;p.forEach((A,$)=>{g||v.indexOf($)>=0?u&&a.push(1):a.push(A)});let w=a.length,y=D.size(a);return{name:e,shaderCache:t,getShaderSource:A=>{let $=[],_=V("_A",r[0].dataType,h),R=K("output",s,w),I=o(_,R,v),z=I[2];for(let T=0,N=0;T<h;T++)g||v.indexOf(T)>=0?(u&&N++,z=`for(var j${T}: u32 = 0; j${T} < ${p[T]}; j${T}++) {\n                  ${I[2].includes("last_index")?`let last_index = j${T};`:""}\n                  ${_.indicesSet("input_indices",T,`j${T}`)}\n                  ${z}\n                }`):($.push(`${_.indicesSet("input_indices",T,R.indicesGet("output_indices",N))};`),N++);return`\n\n        ${A.registerUniform("output_size","u32").declareVariables(_,R)}\n\n        ${A.mainStart()}\n          ${A.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          var input_indices: ${_.type.indices};\n          let output_indices = ${R.offsetToIndices("global_idx")};\n\n          ${$.join(`\n`)}\n          ${I[0]}       // init ops for reduce max/min\n          ${I[1]}\n          ${z}\n          ${I[3]}\n          ${I.length===4?R.setByOffset("global_idx","value"):I.slice(4).join(`\n`)}\n        }`},getRunData:()=>({outputs:[{dims:a,dataType:s}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:[{type:"uint32",data:y},...j(p),...j(a)]})}},kn=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(o=>r.push(Number(o))),ie({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},lt=(e,t,r,o)=>{let n=e.inputs,s=n.length===1?r:kn(n,r);e.compute(Hr(t,{hint:s.cacheKey,inputDependencies:["rank"]},[n[0]],s.noopWithEmptyAxes&&s.axes.length===0?wl:o,s.axes,n[0].dataType,s.keepDims,s.noopWithEmptyAxes),{inputs:[0]})},vl=(e,t)=>{ut(e.inputs),lt(e,"ReduceLogSum",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${o.getByIndices("input_indices")};`,"value = log(value);"])},$l=(e,t)=>{ut(e.inputs),lt(e,"ReduceL1",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += abs(${o.getByIndices("input_indices")});`,""])},Sl=(e,t)=>{ut(e.inputs),lt(e,"ReduceL2",t,(o,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${o.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},xl=(e,t)=>{ut(e.inputs),lt(e,"ReduceLogSumExp",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += exp(${o.getByIndices("input_indices")});`,"value = log(value);"])},Cl=(e,t)=>{ut(e.inputs),lt(e,"ReduceMax",t,(o,n,s)=>{let u=[];for(let d=0;d<o.rank;d++)(s.indexOf(d)>=0||s.length===0)&&u.push(o.indicesSet("input_indices",d,0));return[`${u.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};`,`value = max(value, ${o.getByIndices("input_indices")});`,""]})},_l=(e,t)=>{ut(e.inputs),lt(e,"ReduceMean",t,(o,n,s)=>{let u=1;for(let d=0;d<o.rank;d++)(s.indexOf(d)>=0||s.length===0)&&(u*=e.inputs[0].dims[d]);return["var sum = f32(0);","",`sum += f32(${o.getByIndices("input_indices")});`,`let value = ${n.type.value}(sum / ${u});`]})},Al=(e,t)=>{ut(e.inputs),lt(e,"ReduceMin",t,(o,n,s)=>{let u=[];for(let d=0;d<o.rank;d++)(s.indexOf(d)>=0||s.length===0)&&u.push(`input_indices[${d}] = 0;`);return[`${u.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};`,`value = min(value, ${o.getByIndices("input_indices")});`,""]})},Il=(e,t)=>{ut(e.inputs),lt(e,"ReduceProd",t,(o,n)=>[`var value = ${n.type.storage}(1);`,"",`value *= ${o.getByIndices("input_indices")};`,""])},Tl=(e,t)=>{ut(e.inputs),lt(e,"ReduceSum",t,(o,n)=>[`var value = ${n.type.storage}(0);`,"",`value += ${o.getByIndices("input_indices")};`,""])},El=(e,t)=>{ut(e.inputs),lt(e,"ReduceSumSquare",t,(o,n)=>[`var t = ${n.type.value}(0); var value = ${n.type.value}(0);`,"",`t = ${o.getByIndices("input_indices")}; value += t * t;`,""])},dt=(e,t,r)=>{if(t.length===0)return r;let o=1,n=1;for(let s=0;s<t.length;s++)t.indexOf(s)===-1?o*=e[s]:n*=e[s];return n<32&&o>1024},oa=(e,t)=>{dt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?_l(e,t):jo(e,t)},aa=(e,t)=>{dt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?$l(e,t):Ko(e,t)},ia=(e,t)=>{dt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Sl(e,t):Yo(e,t)},sa=(e,t)=>{dt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?xl(e,t):Zo(e,t)},ua=(e,t)=>{dt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Cl(e,t):Xo(e,t)},la=(e,t)=>{dt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Al(e,t):Jo(e,t)},da=(e,t)=>{dt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Il(e,t):Qo(e,t)},ca=(e,t)=>{dt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?Tl(e,t):ea(e,t)},pa=(e,t)=>{dt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?El(e,t):ta(e,t)},ma=(e,t)=>{dt(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?vl(e,t):ra(e,t)}});var fa,ha,ga,Pn,ya=Y(()=>{"use strict";Ue();Re();Nr();fa=e=>{if(!e||e.length===0||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(e[0].dataType!==1)throw new Error("Invalid input type.")},ha=(e,t)=>{fa(e.inputs);let r=(o,n,s)=>{let u=[];for(let d=0;d<o.rank;d++)(s.indexOf(d)>=0||s.length===0)&&u.push(`input_indices[${d}] = 0;`);return[`${u.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${o.getByIndices("input_indices")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${o.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",n.setByOffset("global_idx","best_index")]};e.compute(Hr("ArgMin",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},ga=(e,t)=>{fa(e.inputs);let r=(o,n,s)=>{let u=[];for(let d=0;d<o.rank;d++)(s.indexOf(d)>=0||s.length===0)&&u.push(`input_indices[${d}] = 0;`);return[`${u.join(`\n`)}`,`var value = ${o.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${o.getByIndices("input_indices")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${o.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",n.setByOffset("global_idx","best_index")]};e.compute(Hr("argMax",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],r,[t.axis],7,t.keepDims),{inputs:[0]})},Pn=e=>ie(e)});var Ol,ba,kl,Pl,Rl,Gr,Bl,wa,Rn=Y(()=>{"use strict";Re();Mr();be();Ol=(e,t)=>{let r=e[0],o=e[1],n=e[2],s=e[3],u=e[4],d=e[5];if(u&&d)throw new Error("Attention cannot have both past and relative_position_bias");if(r.dims.length!==3)throw new Error(\'Input "input" must have 3 dimensions\');let a=r.dims[0],p=r.dims[1],h=r.dims[2];if(n.dims.length!==1)throw new Error(\'Input "bias" is expected to have 1 dimensions\');if(o.dims.length!==2)throw new Error(\'Input "weights" is expected to have 2 dimensions\');if(o.dims[0]!==h)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(n.dims[0]!==o.dims[1])throw new Error(\'Input "bias" dimension 0 should have same length as dimension 1 of input "weights"\');let v=n.dims[0]/3,g=v,w=g;if(t.qkvHiddenSizes.length>0){if(t.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let R of t.qkvHiddenSizes)if(R%t.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");v=t.qkvHiddenSizes[0],g=t.qkvHiddenSizes[1],w=t.qkvHiddenSizes[2]}let y=p;if(v!==g)throw new Error("qkv_hidden_sizes first element should be same as the second");if(n.dims[0]!==v+g+w)throw new Error(\'Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes\');let x=0;if(u){if(g!==w)throw new Error(\'Input "past" expect k_hidden_size == v_hidden_size\');if(u.dims.length!==5)throw new Error(\'Input "past" must have 5 dimensions\');if(u.dims[0]!==2)throw new Error(\'Input "past" first dimension must be 2\');if(u.dims[1]!==a)throw new Error(\'Input "past" second dimension must be batch_size\');if(u.dims[2]!==t.numHeads)throw new Error(\'Input "past" third dimension must be num_heads\');if(u.dims[4]!==g/t.numHeads)throw new Error(\'Input "past" fifth dimension must be k_hidden_size / num_heads\');t.pastPresentShareBuffer||(x=u.dims[3])}let A=y+x,$=-1,_=0;if(s)throw new Error("Mask not supported");if(u)throw new Error("past is not supported");if(d)throw new Error("relativePositionBias is not supported");return{batchSize:a,sequenceLength:p,pastSequenceLength:x,kvSequenceLength:y,totalSequenceLength:A,maxSequenceLength:$,inputHiddenSize:h,hiddenSize:v,vHiddenSize:w,headSize:Math.floor(v/t.numHeads),vHeadSize:Math.floor(w/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:_,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},ba=e=>ie({...e}),kl=(e,t,r,o)=>{let n=Ne(o),s=K("x",t.dataType,t.dims,n),u="threadMaxVector";n===2?u="max(threadMaxVector.x, threadMaxVector.y)":n===4&&(u="max(max(threadMaxVector.x, threadMaxVector.y), max(threadMaxVector.z, threadMaxVector.w))");let d=Oe(t.dataType),a=64,p=o/n;p<a?a=1:p/8<64&&(a=Math.ceil(p/8));let h=Math.ceil(o/n/a),v=g=>`\n  const dInv: ${d} = 1 / ${o};\n  const dComp = ${o/n};\n  var<workgroup> wgMax: array<f32, ${a}>;\n  var<workgroup> wgSum: array<f32, ${a}>;\n\n  ${g.declareVariables(s)}\n  @compute @workgroup_size(${a}, 1, 1)\n  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_index) local_index : u32) {\n    let localOffset = local_index * ${h};\n    let offset: u32 = workgroup_id.x * dComp + localOffset;\n\n    var threadMaxVector = ${je("f32",n,"-3.402823e+38f")};\n    for (var i: u32 = 0; i < ${h} && i + localOffset < dComp; i++) {\n      threadMaxVector = max(${tt(d,n,"x[offset + i]")}, threadMaxVector);\n    }\n    wgMax[local_index] = ${u};\n    workgroupBarrier();\n\n    var maxValue = -3.402823e+38f;\n    for (var i = 0u; i < ${a}; i++) {\n      maxValue = max(wgMax[i], maxValue);\n    }\n\n    var sumVector = ${je("f32",n,"0")};\n    for (var i: u32 = 0; i < ${h} && i + localOffset < dComp; i++) {\n      sumVector += exp(${tt(d,n,"x[offset + i]")} - maxValue);\n    }\n    wgSum[local_index] = ${Xe("sumVector",n)};\n    workgroupBarrier();\n\n    var sum: f32 = 0;\n    for (var i = 0u; i < ${a}; i++) {\n      sum += wgSum[i];\n    }\n\n    if (sum == 0) {\n      for (var i: u32 = 0; i < ${h} && i + localOffset < dComp; i++) {\n        x[offset + i] = ${je(d,n,"dInv")};\n      }\n    } else {\n      for (var i: u32 = 0; i < ${h} && i + localOffset < dComp; i++) {\n        let f32input = ${tt(d,n,"x[offset + i]")};\n        x[offset + i] = ${s.type.value}(exp(f32input - maxValue) / sum);\n      }\n    }\n  }`;e.compute({name:"AttentionProbsSoftmax",shaderCache:{hint:`${o}`},getShaderSource:v,getRunData:()=>({outputs:[],dispatchGroup:{x:r}})},{inputs:[t],outputs:[]})},Pl=(e,t,r,o,n,s)=>{let u=[n.batchSize,n.numHeads,n.sequenceLength,n.kvSequenceLength+n.pastSequenceLength],d=s.scale===0?1/Math.sqrt(n.headSize):s.scale,a=Oe(t.dataType),p=Ne(n.headSize),h=V("q",t.dataType,t.dims,p),v=V("key",r.dataType,r.dims,p),g=K("output",t.dataType,u),w=n.headSize/p,y=n.sequenceLength,x=n.totalSequenceLength,A=w,$=12,_={x:Math.ceil(n.totalSequenceLength/$),y:Math.ceil(n.sequenceLength/$),z:n.batchSize*n.numHeads},R=[t,r],I=T=>`\n  const M: u32 = ${y}u;\n  const N: u32 = ${x}u;\n  const K: u32 = ${A}u;\n  const alpha: ${a} = ${d};\n  const beta: ${a} = 1.0;\n  const TILE_SIZE = ${$}u;\n\n  var<workgroup> tileQ: array<${h.type.storage}, ${$*$}>;\n  var<workgroup> tileK: array<${h.type.storage}, ${$*$}>;\n\n  ${T.declareVariables(h,v,g)}\n\n  @compute @workgroup_size(${$}, ${$}, 1)\n  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,\n   @builtin(local_invocation_id) local_id : vec3<u32>, @builtin(local_invocation_index) local_index : u32) {\n   let global_idx = (workgroup_id.z * ${_.x*_.y}u +\n          workgroup_id.y * ${_.x}u + workgroup_id.x) * ${$*$}u + local_index;\n\n    // x holds the N and y holds the M\n    let headIdx = workgroup_id.z;\n    let m = workgroup_id.y * TILE_SIZE;\n    let n = workgroup_id.x * TILE_SIZE;\n    let lm = m + local_id.y;\n    let ln = n + local_id.x;\n\n    let qOffset = ${n.sequenceLength*w} * headIdx + m * K;\n    let kOffset = ${n.kvSequenceLength*w} * headIdx + n * K;\n\n    var value = ${je(a,p)};\n    for (var w: u32 = 0u; w < K; w += TILE_SIZE) {\n      if (m + local_id.y < M && w + local_id.x < K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * K + w + local_id.x];\n      }\n      if (n + local_id.y < N && w + local_id.x < K) {\n        tileK[TILE_SIZE * local_id.y + local_id.x] = key[kOffset + local_id.y * K + w + local_id.x];\n      }\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < K; k++) {\n        value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = headIdx * M * N;\n    if (lm < M && ln < N) {\n      let outputIdx = headOffset + lm * N + ln;\n      output[outputIdx] = ${Xe("value",p)} * alpha;\n    }\n  }`,z=e.compute({name:"AttentionProbs",shaderCache:{hint:JSON.stringify(n)},getRunData:()=>({outputs:[{dims:u,dataType:t.dataType,gpuDataType:0}],dispatchGroup:_}),getShaderSource:I},{inputs:R,outputs:[-1]})[0];return kl(e,z,n.batchSize*n.numHeads*n.sequenceLength,n.totalSequenceLength),z},Rl=(e,t,r,o)=>{let n=[o.batchSize,o.sequenceLength,o.vHiddenSize],s=V("probs",t.dataType,t.dims),u=V("v",r.dataType,r.dims),d=K("output",t.dataType,n),a=Oe(t.dataType),p=12,h={x:Math.ceil(o.vHeadSize/p),y:Math.ceil(o.sequenceLength/p),z:o.batchSize*o.numHeads},v=g=>`\n  const M: u32 = ${o.sequenceLength}u;\n  const N: u32 = ${o.vHeadSize}u;\n  const K: u32 = ${o.totalSequenceLength}u;\n  const numHeads: u32 = ${o.numHeads}u;\n  const TILE_SIZE = ${p}u;\n\n  var<workgroup> tileQ: array<${s.type.storage}, ${p*p}>;\n  var<workgroup> tileK: array<${s.type.storage}, ${p*p}>;\n\n  ${g.declareVariables(s,u,d)}\n\n  @compute @workgroup_size(${p}, ${p}, 1)\n  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,\n   @builtin(local_invocation_id) local_id : vec3<u32>, @builtin(local_invocation_index) local_index : u32) {\n   let global_idx = (workgroup_id.z * ${h.x*h.y}u +\n          workgroup_id.y * ${h.x}u + workgroup_id.x) * ${p*p}u + local_index;\n\n   let headIdx = workgroup_id.z;\n   let m = workgroup_id.y * TILE_SIZE + local_id.y;\n   let n = workgroup_id.x * TILE_SIZE + local_id.x;\n\n   let offsetA = headIdx * (M * K) + m * K;\n   let offsetB = headIdx * (N * K) + n;\n\n   var value = ${a}(0);\n   for (var w: u32 = 0u; w < K; w += TILE_SIZE) {\n     if (m < M && w + local_id.x < K) {\n       tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\n     }\n     if (n < N && w + local_id.y < K) {\n       tileK[TILE_SIZE * local_id.y + local_id.x] = v[offsetB + (w + local_id.y) * N];\n     }\n     workgroupBarrier();\n     for (var k: u32 = 0u; k<TILE_SIZE && w+k < K; k++) {\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * k + local_id.x];\n     }\n     workgroupBarrier();\n   }\n\n   // we need to transpose output from BNSH_v to BSND_v\n   let batchIdx = workgroup_id.z / ${o.numHeads};\n   let currentBatchHeadNumber = workgroup_id.z % ${o.numHeads};\n   let headOffset = (batchIdx * M * ${o.numHeads} + currentBatchHeadNumber) * ${o.vHeadSize};\n   if (m < M && n < N) {\n     let outputIdx = batchIdx * ${o.sequenceLength*o.vHiddenSize} + m * ${o.vHiddenSize}\n       + currentBatchHeadNumber * ${o.vHeadSize} + n;\n     output[outputIdx] = value;\n   }\n  }`;return e.compute({name:"AttentionScore",shaderCache:{hint:JSON.stringify(o)},getRunData:()=>({outputs:[{dims:n,dataType:t.dataType,gpuDataType:0}],dispatchGroup:h}),getShaderSource:v},{inputs:[t,r],outputs:[0]})[0]},Gr=(e,t,r,o,n,s,u,d,a,p,h)=>{let v=Pl(e,t,r,a,p,h);Rl(e,v,o,p)},Bl=(e,t)=>{let r=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],o=Oe(e.inputs[0].dataType),n=t.sequenceLength,s=t.inputHiddenSize,u=t.headSize,d=12,a={x:Math.ceil(t.headSize/d),y:Math.ceil(t.sequenceLength/d),z:t.batchSize*t.numHeads},p=()=>`\n  const M: u32 = ${n}u;\n  const K: u32 = ${s}u;\n  const N: u32 = ${u}u;\n  const numHeads: u32 = ${t.numHeads};\n  const ldb = ${t.hiddenSize+t.hiddenSize+t.vHiddenSize}u;\n  const TILE_SIZE = ${d}u;\n\n  var<workgroup> tileInput: array<${o}, ${d*d}>;\n  var<workgroup> tileWeightQ: array<${o}, ${d*d}>;\n  var<workgroup> tileWeightK: array<${o}, ${d*d}>;\n  var<workgroup> tileWeightV: array<${o}, ${d*d}>;\n\n  @group(0) @binding(0) var<storage, read> input: array<${o}>;\n  @group(0) @binding(1) var<storage, read> weight: array<${o}>;\n  @group(0) @binding(2) var<storage, read> bias: array<${o}>;\n  @group(0) @binding(3) var<storage, read_write> outputQ: array<${o}>;\n  @group(0) @binding(4) var<storage, read_write> outputK: array<${o}>;\n  @group(0) @binding(5) var<storage, read_write> outputV: array<${o}>;\n\n  @compute @workgroup_size(${d}, ${d}, 1)\n  fn main(@builtin(workgroup_id) workgroup_id : vec3<u32>,\n   @builtin(local_invocation_id) local_id : vec3<u32>, @builtin(local_invocation_index) local_index : u32) {\n   let global_idx = (workgroup_id.z * ${a.x*a.y}u +\n          workgroup_id.y * ${a.x}u + workgroup_id.x) * ${d*d}u + local_index;\n\n    let batchIndex = workgroup_id.z / ${t.numHeads};\n    let headNumber = workgroup_id.z % ${t.numHeads};\n    let m = workgroup_id.y * TILE_SIZE + local_id.y;\n    let n = workgroup_id.x * TILE_SIZE + local_id.x;\n\n    let inputOffset = batchIndex * (M * K) + m * K;\n    let biasOffsetQ = headNumber * ${t.headSize};\n    let biasOffsetK = ${t.hiddenSize} + biasOffsetQ;\n    let biasOffsetV = ${t.hiddenSize} + biasOffsetK;\n\n    var valueQ = ${o}(0);\n    var valueK = ${o}(0);\n    var valueV = ${o}(0);\n    for (var w: u32 = 0u; w < K; w += TILE_SIZE) {\n      if (m < M && w + local_id.x < K) {\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\n      }\n      if (n < N && w + local_id.y < K) {\n        let offset = n + (w + local_id.y) * ldb;\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\n      }\n      workgroupBarrier();\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < K; k++) {\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = (m * N + n) % ${t.headSize};\n    valueQ += bias[headOffset + biasOffsetQ];\n    valueK += bias[headOffset + biasOffsetK];\n    valueV += bias[headOffset + biasOffsetV];\n\n    let offset = workgroup_id.z * M * N;\n    if (m < M && n < N) {\n      let outputIdx = offset + m * N + n;\n      outputQ[outputIdx] = valueQ;\n      outputK[outputIdx] = valueK;\n      outputV[outputIdx] = valueV;\n    }\n  }`,h=[e.inputs[0],e.inputs[1],e.inputs[2]];return e.compute({name:"AttentionPrepare",shaderCache:{hint:JSON.stringify(t)},getRunData:()=>({outputs:[{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:a}),getShaderSource:p},{inputs:h,outputs:[-1,-1,-1]})},wa=(e,t)=>{let r=Ol(e.inputs,t),[o,n,s]=Bl(e,r);return Gr(e,o,n,s,e.inputs[4],void 0,void 0,void 0,e.inputs[5],r,t)}});var Lr=Y(()=>{});var va=Y(()=>{Lr()});var $a,Sa=Y(()=>{$a="1.17.0"});var xa,Bn,Ca=Y(()=>{Sa();xa="warning",Bn={wasm:{},webgl:{},webgpu:{},versions:{common:$a},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);xa=e}},get logLevel(){return xa}};Object.defineProperty(Bn,"logLevel",{enumerable:!0})});var Ht,_a=Y(()=>{Ca();Ht=Bn});var Aa=Y(()=>{});var Ia=Y(()=>{Fr()});var Ea=Y(()=>{});var Oa=Y(()=>{Fr()});var Fr=Y(()=>{Aa();Ia();Ea();Oa()});var qr=Y(()=>{Fr()});var ka=Y(()=>{Lr();qr()});var Pa=Y(()=>{ka()});var Ra=Y(()=>{});var Ba=Y(()=>{Lr();qr()});var Ma=Y(()=>{Ba()});var jr=Y(()=>{va();_a();Pa();qr();Ra();Ma()});var zl,Vl,Ul,Da,za=Y(()=>{"use strict";jr();$e();Re();be();zl=(e,t)=>{if(!e||e.length!==5)throw new Error("BatchNormalization requires 5 inputs");let r=(o,n,s)=>{let u=n.length;if(u!==o.length)throw new Error(`${s}: num dimensions != ${u}`);n.forEach((d,a)=>{if(d!==o[a])throw new Error(`${s}: dim[${a}] do not match`)})};if(e[0].dims.length>1){let o=t.format==="NHWC"?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);r(e[1].dims,o,"Invalid input scale"),r(e[2].dims,o,"Invalid input B"),r(e[3].dims,o,"Invalid input mean"),r(e[4].dims,o,"Invalid input var")}else r(e[1].dims,[1],"Invalid input scale"),r(e[2].dims,[1],"Invalid input B"),r(e[3].dims,[1],"Invalid input mean"),r(e[4].dims,[1],"Invalid input var")},Vl=(e,t)=>{let{epsilon:r,spatial:o,format:n}=t,s=e[0].dims,u=o?Ne(s[s.length-1]):1,d=n==="NHWC"&&s.length>1?u:1,a=D.size(s)/u,p=ke(s.length)&&o,h=p?s.length:s,v=V("x",e[0].dataType,e[0].dims,u),g=V("scale",e[1].dataType,e[1].dims,d),w=V("bias",e[2].dataType,e[2].dims,d),y=V("inputMean",e[3].dataType,e[3].dims,d),x=V("inputVar",e[4].dataType,e[4].dims,d),A=K("y",e[0].dataType,h,u),$=()=>{let R="";if(o)R=`let cOffset = ${s.length===1?"0u":n==="NHWC"?`outputIndices[${s.length-1}] / ${u}`:"outputIndices[1]"};`;else if(n==="NCHW")R=`\n            ${A.indicesSet("outputIndices","0","0")}\n            let cOffset = ${A.indicesToOffset("outputIndices")};`;else{R=`var cIndices = ${g.type.indices}(0);\n                       cIndices[0] = outputIndices[${s.length-1}];`;for(let I=1;I<g.rank;I++)R+=`cIndices[${I}] = outputIndices[${I}];`;R+=`let cOffset = ${g.indicesToOffset("cIndices")};`}return R},_=R=>`\n  const epsilon = ${r};\n  ${R.registerUniform("outputSize","u32").declareVariables(v,g,w,y,x,A)}\n  ${R.mainStart()}\n  ${R.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n    var outputIndices = ${A.offsetToIndices(`global_idx * ${u}`)};\n    ${$()}\n    let scale = ${g.getByOffset("cOffset")};\n    let bias = ${w.getByOffset("cOffset")};\n    let inputMean = ${y.getByOffset("cOffset")};\n    let inputVar = ${x.getByOffset("cOffset")};\n    let x = ${v.getByOffset("global_idx")};\n    let value = (x - inputMean) / sqrt(inputVar + epsilon) * scale + bias;\n    ${A.setByOffset("global_idx","value")}\n  }`;return{name:"BatchNormalization",shaderCache:{hint:`${t.epsilon}_${t.format}_${o}_${u}`,inputDependencies:p?["rank","type","type","type","type"]:void 0},getShaderSource:_,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:p?[{type:"uint32",data:a},...j(s)]:[{type:"uint32",data:a}]})}},Ul=e=>ie(e),Da=(e,t)=>{let{inputs:r,outputCount:o}=e,n=Ul({...t,outputCount:o});if(Ht.webgpu.validateInputContent&&zl(r,n),t.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(Vl(r,n))}});var Wl,Nl,Va,Ua=Y(()=>{"use strict";$e();be();Wl=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Nl=e=>{let t=e[0].dims,r=e[0].dims[2],o=D.size(t)/4,n=e[0].dataType,s=V("input",n,t,4),u=V("bias",n,[r],4),d=V("residual",n,t,4),a=K("output",n,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:h=>`\n  const channels = ${r}u / 4;\n  ${h.declareVariables(s,u,d,a)}\n\n  ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n    let value = ${s.getByOffset("global_idx")}\n      + ${u.getByOffset("global_idx % channels")} + ${d.getByOffset("global_idx")};\n    ${a.setByOffset("global_idx","value")}\n  }`}},Va=e=>{Wl(e.inputs),e.compute(Nl(e.inputs))}});var Hl,Te,Wa,Na,Ha,Ga,La,Fa,qa,ja,Ka,Gl,Ya,Za,Xa,Ja,Kr,Qa,Yr,ei,ti,ri,ni,oi,ai,ii,si,ui,li,di,ci,pi,mi,fi,hi,gi,Mn=Y(()=>{"use strict";Ue();$e();Re();be();Hl=(e,t,r,o,n,s)=>{let u=Math.ceil(t/4),d="";typeof n=="string"?d=`${n}(a)`:d=n("a");let a=V("inputData",r,[u],4),p=K("outputData",o,[u],4);return`\n      ${e.registerUniform("vec_size","u32").declareVariables(a,p)}\n\n  ${s??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n\n    let a = ${a.getByOffset("global_idx")};\n    ${p.setByOffset("global_idx",d)}\n  }`},Te=(e,t,r,o,n,s=e.dataType)=>({name:t,shaderCache:{hint:n,inputDependencies:["type"]},getShaderSource:u=>Hl(u,D.size(e.dims),e.dataType,s,r,o),getRunData:u=>({outputs:[{dims:e.dims,dataType:s}],dispatchGroup:{x:Math.ceil(D.size(u[0].dims)/64/4)},programUniforms:[{type:"uint32",data:Math.ceil(D.size(e.dims)/4)}]})}),Wa=e=>{e.compute(Te(e.inputs[0],"Abs","abs"))},Na=e=>{e.compute(Te(e.inputs[0],"Acos","acos"))},Ha=e=>{e.compute(Te(e.inputs[0],"Acosh","acosh"))},Ga=e=>{e.compute(Te(e.inputs[0],"Asin","asin"))},La=e=>{e.compute(Te(e.inputs[0],"Asinh","asinh"))},Fa=e=>{e.compute(Te(e.inputs[0],"Atan","atan"))},qa=e=>{e.compute(Te(e.inputs[0],"Atanh","atanh"))},ja=e=>ie(e),Ka=(e,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute \'to\' from \'Cast\' operator): ${t.to}`)}e.compute(Te(e.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},Gl=e=>{let t=e.length>=2&&e[1].data!==0?e[1].getFloat32Array()[0]:Vr,r=e.length>=3&&e[2].data!==0?e[2].getFloat32Array()[0]:Ur;return ie({min:t,max:r})},Ya=(e,t)=>{let r=e.inputs.length===1?t:Gl(e.inputs),o=$t(e.inputs[0].dataType);e.compute(Te(e.inputs[0],"Clip",n=>`clamp(${n}, clip_min_, clip_max_)`,`\n    const clip_min_: vec4<${o}> = vec4(${o}(${r.min}));\n    const clip_max_: vec4<${o}> = vec4(${o}(${r.max}));\n`,r.cacheKey),{inputs:[0]})},Za=e=>{e.compute(Te(e.inputs[0],"Ceil","ceil"))},Xa=e=>{e.compute(Te(e.inputs[0],"Cos","cos"))},Ja=e=>{e.compute(Te(e.inputs[0],"Cosh","cosh"))},Kr=e=>ie(e),Qa=(e,t)=>{let r=$t(e.inputs[0].dataType);e.compute(Te(e.inputs[0],"Elu",o=>`elu_vf32(${o})`,`\n  const elu_alpha_ = ${r}(${t.alpha});\n\n  fn elu_f32(a: ${r}) -> ${r} {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<${r}>) -> vec4<${r}> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},Yr=(e,t="f32")=>`\nconst r0: ${t} = 0.3275911;\nconst r1: ${t} = 0.254829592;\nconst r2: ${t} = -0.284496736;\nconst r3: ${t} = 1.421413741;\nconst r4: ${t} = -1.453152027;\nconst r5: ${t} = 1.061405429;\n\nfn erf_vf32(v: ${e}) -> ${e} {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,ei=e=>{let t=$t(e.inputs[0].dataType);e.compute(Te(e.inputs[0],"Erf",r=>`erf_vf32(${r})`,Yr(`vec4<${t}>`,t)))},ti=e=>{e.compute(Te(e.inputs[0],"Exp","exp"))},ri=e=>{e.compute(Te(e.inputs[0],"Floor","floor"))},ni=e=>{let t=$t(e.inputs[0].dataType);e.compute(Te(e.inputs[0],"Gelu",r=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`,Yr(`vec4<${t}>`,t)))},oi=(e,t)=>{let r=$t(e.inputs[0].dataType);e.compute(Te(e.inputs[0],"LeakyRelu",o=>`select(leaky_relu_alpha_ * ${o}, ${o}, ${o} >= vec4<${r}>(0.0))`,`const leaky_relu_alpha_ = ${r}(${t.alpha});`,t.cacheKey))},ai=e=>{e.compute(Te(e.inputs[0],"Not",t=>`!${t}`))},ii=e=>{e.compute(Te(e.inputs[0],"Neg",t=>`-${t}`))},si=e=>{e.compute(Te(e.inputs[0],"Reciprocal",t=>`1.0/${t}`))},ui=e=>{let t=$t(e.inputs[0].dataType);e.compute(Te(e.inputs[0],"Relu",r=>`select(vec4<${t}>(0.0), ${r}, ${r} > vec4<${t}>(0.0))`))},li=e=>{e.compute(Te(e.inputs[0],"Sigmoid",t=>`(1.0 / (1.0 + exp(-${t})))`))},di=e=>{e.compute(Te(e.inputs[0],"Sin","sin"))},ci=e=>{e.compute(Te(e.inputs[0],"Sinh","sinh"))},pi=e=>{e.compute(Te(e.inputs[0],"Sqrt","sqrt"))},mi=e=>{e.compute(Te(e.inputs[0],"Tan","tan"))},fi=e=>{e.compute(Te(e.inputs[0],"Tanh","tanh"))},hi=(e,t)=>{let r=$t(e.inputs[0].dataType);return e.compute(Te(e.inputs[0],"ThresholdedRelu",o=>`select(vec4<${r}>(0.0), ${o}, ${o} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${r}>(${t.alpha});`,t.cacheKey)),0},gi=e=>{e.compute(Te(e.inputs[0],"Log","log"))}});var Fl,ql,yi,bi=Y(()=>{"use strict";$e();be();Mn();Fl=e=>{if(e[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(e[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},ql=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=V("input",e[0].dataType,e[0].dims,4),o=V("bias",e[0].dataType,[e[0].dims[2]],4),n=K("output",e[0].dataType,t,4),s=D.size(t)/4,u=Oe(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)}}),getShaderSource:a=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${a.declareVariables(r,o,n)}\n\n  ${Yr(`vec4<${u}>`,u)}\n\n  ${a.mainStart()}\n    ${a.guardAgainstOutOfBoundsWorkgroupSizes(s)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${n.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},yi=e=>{Fl(e.inputs),e.compute(ql(e.inputs))}});var jl,Kl,ct,wi,vi,$i,Si,xi,Ci,_i,Ai,Ii,Ti,Ei=Y(()=>{"use strict";Ue();$e();be();jl=(e,t,r,o,n,s,u,d,a,p,h,v,g)=>{let w,y;typeof d=="string"?w=y=(T,N)=>`${d}((${T}),(${N}))`:typeof d=="function"?w=y=d:(w=d.scalar,y=d.vector);let x=v?t.length:t,A=v?r.length:r,$=v?o.length:o,_=K("outputData",h,$,4),R=V("aData",a,x,4),I=V("bData",p,A,4),z;if(n)if(s){let T=D.size(t)===1,N=D.size(r)===1,U=t.length>0&&t[t.length-1]%4===0,G=r.length>0&&r[r.length-1]%4===0;T||N?z=_.setByOffset("global_idx",y(T?`${R.type.value}(${R.getByOffset("0")}.x)`:R.getByOffset("global_idx"),N?`${I.type.value}(${I.getByOffset("0")}.x)`:I.getByOffset("global_idx"))):z=`\n            let outputIndices = ${_.offsetToIndices("global_idx * 4u")};\n            let offsetA = ${R.broadcastedIndicesToOffset("outputIndices",_)};\n            let offsetB = ${I.broadcastedIndicesToOffset("outputIndices",_)};\n            ${_.setByOffset("global_idx",y(u||U?R.getByOffset("offsetA / 4u"):`${R.type.value}(${R.getByOffset("offsetA / 4u")}[offsetA % 4u])`,u||G?I.getByOffset("offsetB / 4u"):`${I.type.value}(${I.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}\n          `}else z=_.setByOffset("global_idx",y(R.getByOffset("global_idx"),I.getByOffset("global_idx")));else{if(!s)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let T=(N,U,G="")=>{let J=`aData[indexA${U}][componentA${U}]`,B=`bData[indexB${U}][componentB${U}]`;return`\n            let outputIndices${U} = ${_.offsetToIndices(`global_idx * 4u + ${U}u`)};\n            let offsetA${U} = ${R.broadcastedIndicesToOffset(`outputIndices${U}`,_)};\n            let offsetB${U} = ${I.broadcastedIndicesToOffset(`outputIndices${U}`,_)};\n            let indexA${U} = offsetA${U} / 4u;\n            let indexB${U} = offsetB${U} / 4u;\n            let componentA${U} = offsetA${U} % 4u;\n            let componentB${U} = offsetB${U} % 4u;\n            ${N}[${U}] = ${G}(${w(J,B)});\n          `};h===9?z=`\n            var data = vec4<u32>(0);\n            ${T("data",0,"u32")}\n            ${T("data",1,"u32")}\n            ${T("data",2,"u32")}\n            ${T("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:z=`\n            ${T("outputData[global_idx]",0)}\n            ${T("outputData[global_idx]",1)}\n            ${T("outputData[global_idx]",2)}\n            ${T("outputData[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables(R,I,_)}\n\n        ${g??""}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${z}\n      }`},Kl=(e,t,r,o,n,s,u=r.dataType)=>{let d=!D.areEqual(r.dims,o.dims),a=r.dims,p=D.size(r.dims),h=!1,v=!1,g=[d];if(d){let y=it.calcShape(r.dims,o.dims,!1);if(!y)throw new Error("Can\'t perform binary op on the given tensors");a=y,p=D.size(a);let x=D.size(r.dims)===1,A=D.size(o.dims)===1,$=r.dims.length>0&&r.dims[r.dims.length-1]%4===0,_=o.dims.length>0&&o.dims[o.dims.length-1]%4===0;g.push(x),g.push(A),g.push($),g.push(_);let R=1;for(let I=1;I<a.length;I++){let z=r.dims[r.dims.length-I]??1,T=o.dims[o.dims.length-I]??1;if(z===T)R*=z;else break}R%4===0?(v=!0,h=!0):(x||A||$||_)&&(h=!0)}else h=!0;g.push(h);let w=ke(r.dims.length)&&ke(o.dims.length)&&ke(a.length);return{name:e,shaderCache:{hint:t+g.map(y=>y.toString()).join("_"),inputDependencies:w?["rank","rank"]:["dims","dims"]},getShaderSource:y=>jl(y,r.dims,o.dims,a,h,d,v,n,r.dataType,o.dataType,u,w,s),getRunData:()=>({outputs:[{dims:a,dataType:u}],dispatchGroup:{x:Math.ceil(p/64/4)},programUniforms:w?[{type:"uint32",data:Math.ceil(D.size(a)/4)},...j(r.dims),...j(o.dims),...j(a)]:[{type:"uint32",data:Math.ceil(D.size(a)/4)}]})}},ct=(e,t,r,o,n,s)=>{e.compute(Kl(t,n??"",e.inputs[0],e.inputs[1],r,o,s))},wi=e=>{ct(e,"Add",(t,r)=>`${t}+${r}`)},vi=e=>{ct(e,"Div",(t,r)=>`${t}/${r}`)},$i=e=>{ct(e,"Equal",{scalar:(t,r)=>`u32(${t}==${r})`,vector:(t,r)=>`vec4<u32>(${t}==${r})`},void 0,void 0,9)},Si=e=>{ct(e,"Mul",(t,r)=>`${t}*${r}`)},xi=e=>{let t=V("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;ct(e,"Pow",{scalar:(o,n)=>`pow_custom(${o},${n})`,vector:(o,n)=>`pow_vector_custom(${o},${n})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},Ci=e=>{ct(e,"Sub",(t,r)=>`${t}-${r}`)},_i=e=>{ct(e,"Greater",{scalar:(t,r)=>`u32(${t}>${r})`,vector:(t,r)=>`vec4<u32>(${t}>${r})`},void 0,void 0,9)},Ai=e=>{ct(e,"Less",{scalar:(t,r)=>`u32(${t}<${r})`,vector:(t,r)=>`vec4<u32>(${t}<${r})`},void 0,void 0,9)},Ii=e=>{ct(e,"GreaterOrEqual",{scalar:(t,r)=>`u32(${t}>=${r})`,vector:(t,r)=>`vec4<u32>(${t}>=${r})`},void 0,void 0,9)},Ti=e=>{ct(e,"LessOrEqual",{scalar:(t,r)=>`u32(${t}<=${r})`,vector:(t,r)=>`vec4<u32>(${t}<=${r})`},void 0,void 0,9)}});var Zl,Xl,Jl,Ql,Oi,ki,Pi=Y(()=>{"use strict";$e();Re();be();Zl=e=>{if(!e||e.length<1)throw new Error("too few inputs");let t=e[0].dataType,r=e[0].dims.length;for(let o of e){if(o.dataType!==t)throw new Error("input tensors should be one type");if(o.dims.length!==r)throw new Error("input tensors should have the same shape")}},Xl=(e,t)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,Jl=(e,t)=>{let r=e.length,o=[];for(let n=0;n<r;++n){let s=t.setByOffset("global_idx",e[n].getByIndices("indices"));r===1?o.push(s):n===0?o.push(`if (inputIndex == ${n}u) { ${s} }`):n===r-1?o.push(`else { ${s} }`):o.push(`else if (inputIndex == ${n}) { ${s} }`)}return o.join(`\n`)},Ql=(e,t)=>{let r=e[0].dims.slice();if(t>=r.length||t<-1*r.length)throw new Error("axis specified for concat doesn\'t match input dimensionality");let o=t<0?r.length+t:t,n=r.slice(0);for(let I=1;I<e.length;I++){let z=e[I].dims.slice();for(let T=0;T<r.length;T++)if(T===o)n[o]+=z[T];else if(r[T]!==z[T])throw new Error("non concat dimensions must match")}let s=D.size(n),u=new Array(e.length),d=new Array(e.length),a=e[0].dataType,p=0,h=[],v=[],g=[],w=[{type:"uint32",data:s}];for(let I=0;I<e.length;++I)p+=e[I].dims[o],u[I]=p,g.push(ke(e[I].dims.length)),v.push(g[I]?e[I].dims.length:e[I].dims),d[I]=V(`input${I}`,a,v[I]),h.push(g[I]?"rank":"dims"),w.push({type:"uint32",data:u[I]});for(let I=0;I<e.length;++I)g[I]&&w.push(...j(e[I].dims));let y=ke(n.length);y&&w.push(...j(n));let x=y?n.length:n,A=K("output",a,x),$=A.indicesGet("indices",o),_=Array.from(Array(u.length).keys()).map(I=>`uniforms.sizeInConcatAxis${I}`).join(","),R=I=>`\n\n  ${(()=>{I.registerUniform("outputSize","u32");for(let z=0;z<e.length;z++)I.registerUniform(`sizeInConcatAxis${z}`,"u32");return I.declareVariables(...d,A)})()}\n\n  ${Xl(u.length,_)}\n\n  ${I.mainStart()}\n    ${I.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n    var indices = ${A.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${$});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${u.length}u>(${_});\n      ${$} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${Jl(d,A)}\n  }`;return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:h},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:w}),getShaderSource:R}},Oi=(e,t)=>{Zl(e.inputs),e.compute(Ql(e.inputs,t.axis))},ki=e=>ie({axis:e.axis})});var pt,Zr,St=Y(()=>{"use strict";$e();pt=(e,t)=>{switch(e.activation){case"Relu":return{activationFunction:"",applyActivation:`value = max(value, ${t}(0.0));`};case"Sigmoid":return{activationFunction:"",applyActivation:`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`};case"Clip":return{activationFunction:`const clip_min_=${t}(${e.clipMin});const clip_max_=${t}(${e.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},Zr=e=>{let t=e?.activation||"";if(t==="Clip"){let[r,o]=e?.activation_params||[Vr,Ur];return{activation:t,clipMax:o,clipMin:r,activationCacheKey:`${t}:${r},${o}`}}return{activation:t,activationCacheKey:t}}});var Le,Xr,Jr=Y(()=>{"use strict";Le=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Xr=e=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      `});var Qr,Dn=Y(()=>{"use strict";Qr=e=>`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));\n}\n`});var ed,td,dr,Ri,rd,cr,nd,en,pr=Y(()=>{"use strict";$e();be();St();Jr();ed=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,td=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${t===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,dr=(e,t,r="f32",o,n=!1,s=32,u=!1,d=32)=>{let a=t[1]*e[1],p=t[0]*e[0],h=n?a:s,v=n?s:a,g=h/t[0],w=s/t[1];if(!((n&&g===4&&e[1]===4||!n&&(g===3||g===4))&&h%t[0]===0&&s%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${n} is true, innerElementSize ${g} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${g} must be 3 or 4.\n  tileAWidth ${h} must be divisible by workgroupSize[0]${t[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${g}<${r}>, ${h/g}>, ${v}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${r}>, ${p/e[0]}>, ${s}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${g};\nconst tileInner = ${s};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${u?"0":"i32(globalId.z)"};\n  ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${a};\n\n  let numTiles = ${u?`${Math.ceil(d/s)}`:"(uniforms.dimInner - 1) / tileInner + 1"};\n  var kStart = ${u?`i32(globalId.z) * ${d}`:"0"};\n\n  var acc: array<vec4<${r}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${w};\n  for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${ed(n,o)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${o?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${g===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${td(n,g)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},Ri=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,rd=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",cr=(e,t,r="f32",o,n=!1,s=32,u=!1,d=32,a=!1)=>{let p=e[1]*t[1],h=e[0]*t[0],v=n?p:s,g=n?s:p;if(!(g%t[1]===0&&v%t[0]===0&&s%t[1]===0))throw new Error(`tileAHight ${g} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${v} must be divisible by workgroupSize[0]${t[0]}, tileInner ${s} must be divisible by workgroupSize[1]${t[1]}`);let w=g/t[1],y=v/t[0],x=s/t[1],A=a?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${p};\n    let globalColStart = i32(workgroupId.x) * ${h};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < numTiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${g}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${v}; inputCol = inputCol + ${t[0]}) {\n          ${Ri(n,o)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${h}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${o?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${r}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${p};\n\nlet tileRowA = i32(localId.y) * ${w};\nlet tileColA = i32(localId.x) * ${y};\nlet tileRowB = i32(localId.y) * ${x};\n// Loop over shared dimension.\nfor (var t = 0; t < numTiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${y}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${Ri(n,o)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${x}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${o?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${r}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${rd(n)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${r}, ${v}>, ${g}>;\n  var<workgroup> mm_Bsub : array<array<${r}, ${h}>, ${s}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${s};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${u?"0":"i32(globalId.z)"};\n    ${o?`let batchIndices = ${o.offsetToIndices("u32(batch)")};`:""}\n    let numTiles = ${u?`${Math.ceil(d/s)}`:"(uniforms.dimInner - 1) / tileInner + 1"};\n    var kStart = ${u?`i32(globalId.z) * ${d}`:"0"};\n\n    var acc : array<array<${r}, colPerThread>, rowPerThread>;\n\n    // Without this initialization strange values show up in acc.\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = 0.0;\n      }\n    }\n    ${A}\n  }\n`},nd=(e,t,r,o,n,s=!1)=>{let[u,d,a]=n,[p,h,v,g]=o,w=Wt(u,a),y=Wt(d,a),x=Oe(o[0].type.tensor),A=()=>{let R=h.rank,I=p.rank,z=`var aIndices: ${h.type.indices};`;for(let T=R-2-1,N=I-1;T>=0;T--,N--)z+=`\naIndices[${T}] = ${I>1?`batchIndices[${N}]`:"batchIndices"};`;return w.forEach(T=>{z+=`\naIndices[${T}] = 0;`}),z+=`\naIndices[${R-2}] = u32(row);\n                   aIndices[${R-1}] = u32(colIn);`,z},$=()=>{let R=v.rank,I=p.rank,z=`var bIndices: ${v.type.indices};`;for(let T=R-2-1,N=I-1;T>=0;T--,N--)z+=`\nbIndices[${T}] = ${I>1?`batchIndices[${N}]`:"batchIndices"};`;return y.forEach(T=>{z+=`\nbIndices[${T}] = 0;`}),z+=`\nbIndices[${R-2}] = u32(row);\n                   bIndices[${R-1}] = u32(colIn);`,z};return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${p.type.indices}) -> ${Le(e,x)} {\n      var value = ${Le(e,x)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dimAOuter && col < uniforms.dimInner)\n      {\n        ${A()}\n        value = ${h.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${p.type.indices}) -> ${Le(e,x)} {\n      var value = ${Le(e,x)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dimInner && col < uniforms.dimBOuter)\n      {\n        ${$()}\n        value = ${v.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Le(e,x)}) {\n      let col = colIn * ${e};\n      if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${s?"bias[colIn]":`${Le(e,x)}(bias[row])`};`:""}\n        ${r}\n        ${g.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},en=(e,t,r,o,n=!1)=>{let s=e[0].dims,u=e[1].dims,d=s.slice(0,-2),a=u.slice(0,-2),p=o?o.slice(0,-2):r.slice(0,-2),h=ke(p.length),v=h?p.length:p,g=Wr("batchDims",e[0].dataType,v,1),w=D.size(p),y=s[s.length-2],x=s[s.length-1],A=u[u.length-1],$=x%4===0&&A%4===0,_=y<=8?[4,1,1]:[4,4,1],R=[8,8,1],I=[Math.ceil(A/R[0]/_[0]),Math.ceil(y/R[1]/_[1]),Math.ceil(w/R[2]/_[2])],z=Oe(e[0].dataType),T=$?4:1,N=[...d,y,x/T],U=ke(N.length),G=U?N.length:N,J=[...a,x,A/T],B=ke(J.length),q=B?J.length:J,pe=[w,y,A/T],Q=V("a",e[0].dataType,G,T),we=V("b",e[1].dataType,q,T),Z=K("result",e[0].dataType,pe.length,T),ye=[Q,we],Ce=[{type:"int32",data:y},{type:"int32",data:A},{type:"int32",data:x}];h&&Ce.push(...j(p)),U&&Ce.push(...j(N)),B&&Ce.push(...j(J));let fe=[];fe.push(U?"rank":"dims"),fe.push(B?"rank":"dims");let ce=e.length>2,{activationFunction:We,applyActivation:Be}=pt(t,Z.type.value),He=nd(T,ce,Be,[g,Q,we,Z],[d,a,p],n);if(ce){let re=n?T:1;ye.push(V("bias",e[2].dataType,e[2].dims.length,re)),Ce.push(...j(e[2].dims)),fe.push("rank")}Ce.push(...j(pe));let L=re=>`\n  ${re.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").registerInternalVariables(g).declareVariables(...ye,Z)}\n  ${We}\n  ${He}\n  ${$?dr(_,R,z,g):cr(_,R,z,g)}\n                   `;return{name:"MatMul",shaderCache:{hint:t.activationCacheKey+`${_}${$}${n}`,inputDependencies:fe},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:I[0],y:I[1],z:I[2]},programUniforms:Ce}),getShaderSource:L}}});var od,Bi,Mi=Y(()=>{"use strict";vt();be();St();Jr();Dn();pr();od=(e,t,r,o,n=!1,s,u=4,d=4,a=4,p="f32")=>{let h=B=>{switch(B){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${p}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${B} is not supported.`)}},v=B=>{switch(B){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${B} is not supported.`)}},g=e?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,w=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,y=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",x=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",A=e?"row":"col",$=e?"col":"row",_=`\n    let inChannels = i32(uniforms.w_shape[2]);\n    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n    let outRow = ${A} / outWidth;\n    let outCol = ${A} % outWidth;\n\n    let WRow = ${$} / (filterDims[1] * inChannels);\n    let WCol = ${$} / inChannels % filterDims[1];\n    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];\n    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];\n    let xCh = ${$} % inChannels;\n    var resData = ${Le(u,p)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the \'same\' padding type.\n    if (xRow >= 0 && xRow < ${y} && xCol >= 0 && xCol < ${x}) {\n      ${g}\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\n      ${h(u)}\n    }\n    return resData;`,R=e?t&&o?`\n    let col = colIn * ${u};\n    ${_}`:`\n    let col = colIn * ${u};\n    if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n      ${_}\n    }\n    return ${Le(u,p)}(0.0);`:o&&r?`\n    let col = colIn * ${u};\n    ${_}`:`\n    let col = colIn * ${u};\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n      ${_}\n    }\n    return ${Le(u,p)}(0.0);`,I=`${v(d)}`,z=Le(a,p),T=e?Le(u,p):Le(d,p),N=e?Le(d,p):Le(u,p),{activationFunction:U,applyActivation:G}=pt(s,z);return`\n    ${U}\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${T} {\n      ${e?R:I}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${N} {\n      ${e?I:R}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${z}) {\n      let col = colIn * ${a};\n      if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${w}\n      ${Xr(n)}\n      ${G}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},Bi=(e,t,r,o,n,s,u,d)=>{let a=t.format==="NHWC",p=a?e[0].dims[3]:e[0].dims[1],h=r[0],v=a?r[2]:r[3],g=a?r[1]:r[2],w=a?r[3]:r[1],y=a&&(p%4===0||p%3===0)&&w%4===0,x=a?w:v*g,A=a?v*g:w,$=[8,8,1],_=o<=8?[4,1,1]:[4,4,1],R=[Math.ceil(x/$[0]/_[0]),Math.ceil(A/$[1]/_[1]),Math.ceil(h/$[2]/_[2])];Pe("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${R}`);let I=y?a&&p%4!==0?3:4:1,z=$[1]*_[1],T=$[0]*_[0],N=Math.max($[0]*I,$[1]),U=o%z===0,G=n%T===0,J=s%N===0,B=y?[I,4,4]:[1,1,1],q=Oe(e[0].dataType),pe=y?4:1,Q=[{type:"int32",data:o},{type:"int32",data:n},{type:"int32",data:s}],we=V("x",e[0].dataType,e[0].dims.length,I===3?1:I),Z=V("w",e[1].dataType,e[1].dims.length,pe),ye=[we,Z];Q.push(...j(e[0].dims)),Q.push(...j(e[1].dims));let Ce=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${y?`vec4<${q}>`:q}) {\n        result[flatIndex] = ${y?`vec4<${q}>`:q}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${y?`vec4<${q}>`:q}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${y?"/ 4":""}, value);\n      }`;if(u){let ce=V("bias",e[2].dataType,e[2].dims.length,pe);ye.push(ce),Q.push(...j(e[2].dims)),Ce+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${y?`vec4<${q}>`:q} {\n          return bias[coords.${a?"w":"y"}${y?"/ 4":""}];\n        }`}let fe=K("result",e[0].dataType,r.length,pe);return Q.push(...j(r)),{name:"Conv2DMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:R[0],y:R[1],z:R[2]},programUniforms:Q}),getShaderSource:ce=>`\n        ${Qr("uniforms.result_strides")}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${ce.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").declareVariables(...ye,fe)}\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[0]}, ${t.kernelShape[1]});\n        const pad : vec2<i32> = vec2<i32>(${t.pads[0]}, ${t.pads[1]});\n        const stride : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        ${Ce}\n        ${od(a,U,G,J,u,t,B[0],B[1],B[2],q)}\n            ${y?dr(_,$,q,void 0,!a,N):cr(_,$,q,void 0,!a,N,!1,void 0,d)}`}}});var zn,Di=Y(()=>{"use strict";$e();be();Un();St();zn=(e,t,r)=>{let o=e.length>2,n=o?"value += b[output_channel];":"",s=e[0].dims,u=e[1].dims,d=u[0]/t.group,a=t.format==="NHWC",p=Vn(s,u,t.dilations,t.pads,t.strides,a),h=D.size(p),v=K("output",e[0].dataType,p),{activationFunction:g,applyActivation:w}=pt(t,v.type.value),y=V("x",e[0].dataType,s),x=V("w",e[1].dataType,u),A=[y,x];o&&A.push(V("b",e[2].dataType,e[2].dims));let $=_=>`\n  const strides: vec2<u32> = vec2(${t.strides[0]}u, ${t.strides[1]}u);\n  const pads: vec2<u32> = vec2(${t.pads[0]}u, ${t.pads[1]}u);\n\n  ${_.declareVariables(...A,v)}\n\n  ${g}\n\n  ${_.mainStart()}\n    ${_.guardAgainstOutOfBoundsWorkgroupSizes(h)}\n\n    let outputIndices = ${v.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${a?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${a?1:2}], outputIndices[${a?2:3}]) * strides - pads;\n    let group_id: u32 = output_channel / ${d}u;\n\n    var value: ${v.type.value} = ${v.type.value}(0);\n    for (var wInChannel: u32 = 0u; wInChannel < ${u[1]}u; wInChannel++) {\n      let input_channel = group_id * ${u[1]}u + wInChannel;\n      for (var wHeight: u32 = 0u; wHeight < ${u[2]}u; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * ${t.dilations[0]}u;\n\n        if (xHeight < 0u || xHeight >= ${s[a?1:2]}u) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < ${u[3]}u; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * ${t.dilations[1]}u;\n          if (xWidth < 0u || xWidth >= ${s[a?2:3]}u) {\n            continue;\n          }\n\n          let xVal = ${a?y.get("batch","xHeight","xWidth","input_channel"):y.get("batch","input_channel","xHeight","xWidth")};\n          let wVal = ${x.get("output_channel","wInChannel","wHeight","wWidth")};\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${n}\n    ${w}\n    ${v.setByOffset("global_idx","value")}\n  }`;return{name:"GroupedConv",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r?r(p):p,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)}}),getShaderSource:$}}});var Wn,ad,zi,Nn=Y(()=>{"use strict";$e();pr();be();St();Wn=(e,t,r,o,n=!1)=>{let s=e[0].dims,u=e[1].dims,d=s[s.length-2],a=u[u.length-1],p=s[s.length-1],h=Ne(a),v=Ne(p),g=Ne(d),w=D.size(r)/h/g,y=e.length>2,x=o?o.slice(0,-2):r.slice(0,-2),$=[D.size(x),d,a],_=[{type:"uint32",data:w},{type:"uint32",data:d},{type:"uint32",data:a},{type:"uint32",data:p},...j(x),...j(s),...j(u)];y&&_.push(...j(e[2].dims)),_.push(...j($));let R=I=>{let z=Wr("batch_dims",e[0].dataType,x.length),T=V("a",e[0].dataType,s.length,v),N=V("b",e[1].dataType,u.length,h),U=K("output",e[0].dataType,$.length,h),{activationFunction:G,applyActivation:J}=pt(t,U.type.value),B=[T,N],q="";if(y){let fe=n?h:1;B.push(V("bias",e[2].dataType,e[2].dims.length,fe)),q=`${n?`value += bias[col / ${fe}];`:`value += ${U.type.value}(bias[row + i]);`}`}let pe=s.slice(0,-2),Q=u.slice(0,-2),we=Wt(pe,x),Z=Wt(Q,x),ye=(fe,ce)=>{let We=fe.rank,Be=fe.name;if(We===2)return`var ${Be}_indices = ${fe.type.indices}(0u, 0u);`;let He=z.rank,L=`var ${Be}_indices: ${fe.type.indices};`;for(let re=We-2-1,he=He-1;re>=0;re--,he--)L+=`\n${Be}_indices[${re}] = ${He>1?`batch_indices[${he}]`:"batch_indices"};`;return ce.forEach(re=>{L+=`\n${Be}_indices[${re}] = 0;`}),L+=`${Be}_indices[${We-2}] = 0u;\n                     ${Be}_indices[${We-1}] = 0u;`,L},Ce=()=>{let fe=`var a_data: ${T.type.value};`;for(let ce=0;ce<v;ce++)fe+=`\n              let b_data${ce} = b[(b_offset + (k + ${ce}) * uniforms.N + col) / ${h}];`;for(let ce=0;ce<g;ce++){fe+=`a_data = a[(a_offset + (row + ${ce}) * uniforms.K + k) / ${v}];`;for(let We=0;We<v;We++)fe+=`\n            values[${ce}] = fma(${N.type.value}(a_data${v===1?"":`[${We}]`}), b_data${We}, values[${ce}]);\n`}return fe};return`\n  ${I.registerUniform("outputSize","u32").registerUniform("M","u32").registerUniform("N","u32").registerUniform("K","u32").registerInternalVariables(z).declareVariables(...B,U)}\n  ${G}\n  ${I.mainStart()}\n    ${I.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n    let col = (global_idx % (uniforms.N / ${h})) * ${h};\n    var index1 = global_idx / (uniforms.N / ${h});\n    let stride1 = uniforms.M / ${g};\n    let row = (index1 % stride1) * ${g};\n    let batch = index1 / stride1;\n\n    ${r.length===2?"":`let batch_indices = ${z.offsetToIndices("batch")};`}\n    ${ye(T,we)}\n    let a_offset = ${T.indicesToOffset("a_indices")};\n    ${ye(N,Z)}\n    let b_offset = ${N.indicesToOffset("b_indices")};\n    var values: array<${U.type.value}, ${g}>;\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${v}) {\n      ${Ce()}\n    }\n    for (var i = 0u; i < ${g}u; i++) {\n      var value = values[i];\n      ${q}\n      ${J}\n      let cur_indices = ${U.type.indices}(batch, row + i, col);\n      let offset = ${U.indicesToOffset("cur_indices")};\n      ${U.setByOffset(`offset / ${h}`,"value")};\n    }\n  }\n  `};return{name:"MatMulNaive",shaderCache:{hint:`${t.activationCacheKey}_${h}_${v}_${g}_${n}`,inputDependencies:y?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:_}),getShaderSource:R}},ad=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},zi=e=>{ad(e.inputs);let t=it.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can\'t use matmul on the given tensors");let r=t[t.length-1],o=e.inputs[0].dims[e.inputs[0].dims.length-1];r<8&&o<8?e.compute(Wn(e.inputs,{activation:"",activationCacheKey:""},t)):e.compute(en(e.inputs,{activation:"",activationCacheKey:""},t))}});var Vn,Vi,id,Ui,Hn,sd,ud,Gn,Un=Y(()=>{"use strict";$e();Re();Mi();pr();Di();St();Nn();Nt();Vn=(e,t,r,o,n,s)=>{let u=e[0],d=e.slice(s?1:2,s?3:4),a=d.length,p=t[0],v=t.slice(2).map((y,x)=>y+(y-1)*(r[x]-1)),w=d.map((y,x)=>y+o[x]+o[x+a]).map((y,x)=>Math.floor((y-v[x]+n[x])/n[x]));return w.splice(0,0,u),w.splice(s?3:1,0,p),w},Vi=[2,3,1,0],id=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[1]*t.group;if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==n*2)throw new Error(`pads should be ${n*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},Ui=(e,t)=>{let r=e.kernelShape.slice();for(let s=2;s<t[1].dims.length;++s)r[s-2]===0&&(r[s-2]=t[1].dims[s]);let o=e.pads.slice();kt.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,o,e.format==="NHWC",e.autoPad);let n=Object.assign({},e);return Object.assign(n,{kernelShape:r,pads:o,cacheKey:e.cacheKey}),n},Hn=e=>{let t=Zr(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],n=e.dilations,s=e.group,u=e.kernel_shape,d=e.pads,a=e.strides,p=e.w_is_const();return ie({autoPad:o,format:r,dilations:n,group:s,kernelShape:u,pads:d,strides:a,wIsConst:p,...t})},sd=(e,t,r)=>{let o=Ui(r,t);if(r.group!==1){e.compute(zn(t,o));return}let n=r.format==="NHWC",s=t.length===3,u=t[0].dims[n?1:2],d=t[0].dims[n?2:3],a=t[0].dims[n?3:1],p=t[1].dims[2],h=t[1].dims[3],v=Vn(t[0].dims,t[1].dims,r.dilations,o.pads,r.strides,n),g=v[n?1:2],w=v[n?2:3],y=v[n?3:1],x=n&&p===u&&h===d&&r.pads[0]===0&&r.pads[1]===0;if(x||p===1&&h===1&&r.dilations[0]===1&&r.dilations[1]===1&&r.strides[0]===1&&r.strides[1]===1&&r.pads[0]===0&&r.pads[1]===0){let T=v[0],N,U,G,J=[];if(n){let pe=e.kernelCustomData.wT??e.compute(rt(t[1],Vi),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=pe),x){let Q=u*d*a;N=t[0].reshape([1,T,Q]),U=pe.reshape([1,Q,y]),G=[1,T,y]}else N=t[0].reshape([T,u*d,a]),U=pe.reshape([1,a,y]),G=[T,g*w,y];J.push(N),J.push(U)}else N=t[0].reshape([T,a,u*d]),U=t[1].reshape([1,y,a]),G=[T,y,g*w],J.push(U),J.push(N);s&&J.push(t[2]);let B=G[2],q=J[0].dims[J[0].dims.length-1];B<8&&q<8?e.compute(Wn(J,o,v,G,n),{inputs:J}):e.compute(en(J,o,v,G,n),{inputs:J});return}let A=!0,$=e.kernelCustomData.wT??e.compute(rt(t[1],Vi),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=$);let _=[t[0],$];s&&_.push(t[2]);let R=n?g*w:y,I=n?y:g*w,z=p*h*a;e.compute(Bi(_,o,v,R,I,z,s,A),{inputs:_})},ud=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&o.push(e.inputs[2]);let n=[0,t.pads[0],0,t.pads[1]],s=[1].concat(t.strides),u=[1].concat(t.dilations),d=[1].concat(t.kernelShape),a=Ui({...t,pads:n,strides:s,dilations:u,kernelShape:d},o);e.compute(zn(o,a,p=>r?[p[0],p[2],p[3]]:[]))},Gn=(e,t)=>{id(e.inputs,t),e.inputs[0].dims.length===3?ud(e,t):sd(e,e.inputs,t)}});var ld,Wi,Ni=Y(()=>{"use strict";vt();be();St();Jr();Dn();pr();ld=(e,t=!1,r,o=4)=>{let n=Le(o,"f32"),s=_=>{switch(_){case 1:return"return w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];";case 4:return`\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = w[getIndexFromCoords4D(coord, vec4<i32>(uniforms.w_shape))];\n            let v1 = w[getIndexFromCoords4D(coord1, vec4<i32>(uniforms.w_shape))];\n            let v2 = w[getIndexFromCoords4D(coord2, vec4<i32>(uniforms.w_shape))];\n            let v3 = w[getIndexFromCoords4D(coord3, vec4<i32>(uniforms.w_shape))];\n            return vec4<f32>(v0, v1, v2, v3);\n            `;default:throw new Error(`innerElementSize ${_} is not supported.`)}},u=e?`\n      let coord = vec4<i32>(batch, iXR, iXC, xCh);\n      `:`\n      let coord = vec4<i32>(batch, xCh, iXR, iXC);\n      `,d=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,a=e?"outBackprop[1]":"outBackprop[2]",p=e?"outBackprop[2]":"outBackprop[3]",h=e?"row":"col",v=e?"col":"row",g=`\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      let outRow = ${h} / outWidth;\n      let outCol = ${h} % outWidth;\n\n      let WRow = ${v} / (filterDims[1] * inChannels);\n      let WCol = ${v} / inChannels % filterDims[1];\n      let xR = f32(outRow - pads[0] + dilation[0] * WRow) / f32(strides[0]);\n      let xC = f32(outCol - pads[1] + dilation[1] * WCol) / f32(strides[1]);\n      if (xR < 0.0 || xR >= f32(${a}) || fract(xR) > 0.0) {\n        return ${n}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(${p}) || fract(xC) > 0.0) {\n        return ${n}(0.0);\n      }\n      let iXR = i32(xR);\n      let iXC = i32(xC);\n      let xCh = ${v} % inChannels;\n      ${u}\n      return x[getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape))/${o}];`,w=e?`\n      let col = colIn * ${o};\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ${g}\n      }\n      return ${n}(0.0);`:`\n      let col = colIn * ${o};\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n        ${g}\n      }\n      return ${n}(0.0);`,y=`\n      let col = colIn * ${o};\n      let inChannels = ${e?"outBackprop[3]":"outBackprop[1]"};\n      let coordX = filterDims.x - 1 - row / (filterDims[1] * inChannels);\n      let coordY = filterDims.y - 1 - (row / inChannels) % filterDims[1];\n      if (${e?"row < uniforms.dimInner && col < uniforms.dimBOuter":"row < uniforms.dimInner && col < uniforms.dimAOuter"}  && coordX >= 0 && coordY >= 0) {\n        let rowInner = row % inChannels;\n        let coord = vec4<i32>(coordX, coordY, col, rowInner);\n        ${s(o)}\n      }\n      return ${n}(0.0);\n      `,{activationFunction:x,applyActivation:A}=pt(r,n);return`\n      ${x}\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${n} {\n    ${e?w:y}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${n} {\n    ${e?y:w}\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${n}) {\n    let col = colIn * ${o};\n    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${d}\n      ${Xr(t)}\n      ${A}\n      result[getIndexFromCoords4D(coords, vec4<i32>(uniforms.result_shape))/${o}] = value;\n    }\n  }`},Wi=(e,t,r,o,n,s,u,d)=>{let a=t.format==="NHWC",p=a?e[0].dims[3]:e[0].dims[1],h=r[0],v=a?r[2]:r[3],g=a?r[1]:r[2],w=a?r[3]:r[1],y=a?p%4===0&&w%4===0:v%4===0&&w%4===0,x=a?w:v*g,A=a?v*g:w,$=y?[8,8,1]:[x<=4||A<=4?4:16,x>4&&A<=4?4:16,1],_=y?[4,4,1]:[x<=4?1:4,x>4&&A<=4?1:4,1],R=[Math.ceil(x/$[0]/_[0]),Math.ceil(A/$[1]/_[1]),Math.ceil(h/$[2]/_[2])];Pe("verbose",()=>`[conv_backprop_mm_webgpu] dispatch = ${R}`);let I=y?4:1,z=Math.max($[0]*I,$[1]),T=y?4:1,N=[{type:"int32",data:o},{type:"int32",data:n},{type:"int32",data:s}],U=V("x",e[0].dataType,e[0].dims.length,T),G=V("w",e[1].dataType,e[1].dims.length,1),J=K("result",e[0].dataType,r.length,T),B=[U,G];N.push(...j(e[0].dims)),N.push(...j(e[1].dims));let q="";if(u){let pe=V("bias",e[2].dataType,e[2].dims.length,T);B.push(pe),N.push(...j(e[2].dims)),q+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${y?"vec4<f32>":"f32"} {\n          return bias[coords.${a?"w":"y"}${y?"/ 4":""}];\n        }`}return N.push(...j(r)),{name:"Conv2DTransposeMatMul",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:R[0],y:R[1],z:R[2]},programUniforms:N}),getShaderSource:pe=>`\n        ${Qr("uniforms.result_strides")}\n        ${pe.registerUniform("dimAOuter","i32").registerUniform("dimBOuter","i32").registerUniform("dimInner","i32").declareVariables(...B,J)};\n        const outBackprop : vec4<i32> = vec4<i32>(${e[0].dims.join(",")});\n        const filterDims : vec2<i32> = vec2<i32>(${t.kernelShape[a?1:2]}, ${t.kernelShape[a?2:3]});\n        const effectiveFilterDims : vec2<i32> = filterDims + vec2<i32>(\n              ${t.dilations[0]<=1?0:(t.kernelShape[a?1:2]-1)*(t.dilations[0]-1)},\n              ${t.dilations[1]<=1?0:(t.kernelShape[a?2:3]-1)*(t.dilations[1]-1)});\n        const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${t.pads[0]+t.pads[2]})/2,\n                                         i32(effectiveFilterDims[1]) - 1 - (${t.pads[1]+t.pads[3]})/2);\n        const strides : vec2<i32> = vec2<i32>(${t.strides[0]}, ${t.strides[1]});\n        const dilation : vec2<i32> = vec2<i32>(${t.dilations[0]}, ${t.dilations[1]});\n        const dimAOuter : i32 = ${o};\n        const dimBOuter : i32 = ${n};\n        const dimInner : i32 = ${s};\n        ${q}\n        ${ld(a,u,t,I)}\n        ${y?dr(_,$,"f32",void 0,!a,z):cr(_,$,"f32",void 0,!a,z,!1,void 0,d)}`}}});var dd,Ln,Hi=Y(()=>{"use strict";vt();$e();be();dd=(e,t,r,o,n,s,u=!1,d)=>{let a=r.format==="NHWC",p=a?1:2,h=a?2:3,v=a?3:1,g=D.size(o),w=u?2:1,y=r.group,x=t[1].dims,A=x[0]/y,$=x[1],_=`\n  fn setOutputAtIndex(flatIndex : u32, value : ${u?`vec4<${d}>`:d}) {\n    result[flatIndex] = ${u?`vec4<${d}>`:d}(value);\n  }`;n&&(_+=`\n    fn getBiasByOutputCoords(coords : vec4<u32>) -> ${u?`vec4<${d}>`:d} {\n      return bias[coords.${a?"w":"y"}${u?"/ 4":""}];\n    }`);let R=u?4:1,I=V("W",t[1].dataType,t[1].dims,R),z=V("Dy",t[0].dataType,t[0].dims,R),T=[z,I];n&&T.push(V("bias",t[2].dataType,[o[v]],R));let N=K("result",t[0].dataType,o,R),U=`{\n        let batch: u32 = ${s?"global_id.z":"workgroup_id.z"} / outShape[1];\n        let r = ${s?"global_id.z":"workgroup_id.z"} % outShape[1];\n        let c = ${s?"global_id.y":"workgroup_id.y"} * ${w};\n        let d1: u32 = ${s?"global_id.x":"workgroup_id.x"} * 4;\n\n        let dyCorner = vec2<i32>(i32(r), i32(c)) - vec2<i32>(pads);\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd: array<vec4<${d}>, ${w}>;\n        for (var i = 0; i < ${w}; i++) {\n          dotProd[i] = vec4<${d}>(0.0);\n        }\n        for (var wR: u32 = 0; wR < filterDims[0]; wR = wR + 1) {\n          var dyR = (${d}(dyCorner.x) + ${d}(wR)) / ${d}(strides.x);\n          let wRPerm = filterDims[0] - 1 - wR;\n          if (dyR < 0.0 || dyR >= ${d}(outBackprop[1]) ||\n              fract(dyR) > 0.0 || wRPerm < 0) {\n            continue;\n          }\n          let idyR: u32 = u32(dyR);\n\n          for (var wC: u32 = 0; wC < filterDims[1]; wC = wC + 1) {\n            let dyC = (${d}(dyCorner.y) + ${d}(wC)) / ${d}(strides.y);\n            let dyC2 = (${d}(dyCorner.y) + 1.0 + ${d}(wC)) / ${d}(strides.y);\n            let wCPerm = filterDims[1] - 1 - wC;\n            if (wCPerm < 0) {\n              continue;\n            }\n            var bDyCVal = true;\n            var bDyCVal2 = true;\n            if (dyC < 0.0 || dyC >= ${d}(outBackprop[2]) ||\n                fract(dyC) > 0.0) {\n              bDyCVal = false;\n            }\n            if (dyC2 < 0.0 || dyC2 >= ${d}(outBackprop[2]) ||\n                fract(dyC2) > 0.0) {\n              bDyCVal2 = false;\n            }\n\n            let idyC: u32 = u32(dyC);\n            let idyC2: u32 = u32(dyC2);\n            if (bDyCVal && bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2 :u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${I.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${I.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${I.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${I.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${z.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n\n                xValue =  ${z.get("batch","idyR","idyC2","d2")};\n\n                dotProd[1] = dotProd[1] + vec4<${d}>(dot(xValue, wValue0),\n                                                    dot(xValue, wValue1),\n                                                    dot(xValue, wValue2),\n                                                    dot(xValue, wValue3));\n              }\n            } else if (bDyCVal) {\n              let d2Length = outBackprop[${v}];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${I.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${I.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${I.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${I.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${z.get("batch","idyR","idyC","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[0] = dotProd[0] + tmpval;\n              }\n            } else if (bDyCVal2) {\n              let d2Length = outBackprop[3];\n              for (var d2: u32 = 0; d2 < d2Length; d2 = d2 + 4) {\n                let wValue0 = ${I.get("u32(wRPerm)","u32(wCPerm)","d1","d2")};\n                let wValue1 = ${I.get("u32(wRPerm)","u32(wCPerm)","d1 + 1","d2")};\n                let wValue2 = ${I.get("u32(wRPerm)","u32(wCPerm)","d1 + 2","d2")};\n                let wValue3 = ${I.get("u32(wRPerm)","u32(wCPerm)","d1 + 3","d2")};\n\n                var xValue = ${z.get("batch","idyR","idyC2","d2")};\n                let tmpval = vec4<${d}>(dot(xValue, wValue0),\n                                      dot(xValue, wValue1),\n                                      dot(xValue, wValue2),\n                                      dot(xValue, wValue3));\n                dotProd[1] = dotProd[1] + tmpval;\n              }\n            }\n          }\n        }\n\n        for (var i: u32 = 0; i < ${w}; i = i + 1) {\n          let value = dotProd[i] + ${n?"bias[c+i]":"0.0"};\n          ${N.set("batch","r","c + i","d1","value")};\n        }\n      }`,G=`\n          let outputIndices = ${N.offsetToIndices("global_idx")};\n          let batch = ${N.indicesGet("outputIndices",0)};\n          let d1 = ${N.indicesGet("outputIndices",v)};\n          let r = ${N.indicesGet("outputIndices",p)};\n          let c = ${N.indicesGet("outputIndices",h)};\n          let dyCorner = vec2<i32>(i32(r), i32(c)) - pads;\n          let dyRCorner = dyCorner.x;\n          let dyCCorner = dyCorner.y;\n          let groupId = d1 / ${$};\n          let wOutChannel = d1 - groupId * ${$};\n          // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n          // ? = to be determined. : = across all values in that axis.\n          var dotProd = 0.0;\n          for (var wR: u32 = 0; wR < effectiveFilterDims.x; wR = wR + 1) {\n            if (wR % dilations.x != 0) {\n              continue;\n            }\n            let dyR = (${d}(dyRCorner) + ${d}(wR)) / ${d}(strides[0]);\n            let wRPerm = filterDims.x - 1 - wR / dilations.x;\n            if (dyR < 0.0 || dyR >= ${d}(outBackprop[${p}]) || fract(dyR) > 0.0 ||\n                wRPerm < 0) {\n              continue;\n            }\n            let idyR: u32 = u32(dyR);\n\n            for (var wC: u32 = 0; wC < effectiveFilterDims.y; wC = wC + 1) {\n              if (wC % dilations.y != 0) {\n                continue;\n              }\n              let dyC = (${d}(dyCCorner) + ${d}(wC)) / ${d}(strides.y);\n              let wCPerm = filterDims.y - 1 - wC / dilations.y;\n              if (dyC < 0.0 || dyC >= ${d}(outBackprop[${h}]) ||\n                  fract(dyC) > 0.0 || wCPerm < 0) {\n                continue;\n              }\n              let idyC: u32 = u32(dyC);\n              var inputChannel = groupId * ${A};\n              for (var d2: u32 = 0; d2 < ${A}; d2 = d2 + 1) {\n                let xValue = ${a?z.get("batch","idyR","idyC","inputChannel"):z.get("batch","inputChannel","idyR","idyC")};\n                let wValue = ${I.get("inputChannel","wOutChannel","u32(wRPerm)","u32(wCPerm)")};\n                dotProd = dotProd + xValue * wValue;\n                inputChannel = inputChannel + 1;\n              }\n            }\n          }\n          let value = dotProd + ${n?"bias[d1]":"0.0"};\n          ${N.setByOffset("global_idx","value")};\n        `;return`\n  ${e.declareVariables(...T,N)}\n  ${_}\n  const outShape : vec4<u32> = vec4<u32>(${o.join(",")});\n  const outBackprop : vec4<u32> = vec4<u32>(${t[0].dims.join(",")});\n  const strides : vec2<u32> = vec2<u32>(${r.strides[0]}, ${r.strides[1]});\n  const filterDims : vec2<u32> = vec2<u32>(${r.kernelShape[a?1:2]}, ${r.kernelShape[a?2:3]});\n  const dilations : vec2<u32> = vec2<u32>(${r.dilations[0]}, ${r.dilations[1]});\n  const effectiveFilterDims : vec2<u32> = filterDims + vec2<u32>(\n          ${r.dilations[0]<=1?0:(r.kernelShape[a?1:2]-1)*(r.dilations[0]-1)},\n          ${r.dilations[1]<=1?0:(r.kernelShape[a?2:3]-1)*(r.dilations[1]-1)});\n  const pads : vec2<i32> = vec2<i32>(i32(effectiveFilterDims[0]) - 1 - (${r.pads[0]+r.pads[2]})/2,\n                                     i32(effectiveFilterDims[1]) - 1 - (${r.pads[1]+r.pads[3]})/2);\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(g)};\n  ${u?U:G}}`},Ln=(e,t,r)=>{let o=e.length>2,n=t.outputShape,s=D.size(n),u=[Math.ceil(s/64),1,1];Pe("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${u}`);let d=Oe(e[0].dataType);return{name:"ConvTranspose2D",shaderCache:{hint:t.cacheKey},getRunData:()=>({dispatchGroup:{x:u[0],y:u[1],z:u[2]},outputs:[{dims:r?r(n):n,dataType:e[0].dataType}]}),getShaderSource:a=>dd(a,e,t,n,o,u[1]===1&&u[2]===1,!1,d)}}});var cd,pd,md,Gi,Li,fd,hd,gd,yd,Fi,qi=Y(()=>{"use strict";Re();Ni();Hi();St();Nt();cd=(e,t,r,o,n,s)=>(e-1)*t+r+(o-1)*n+1-s,pd=(e,t,r,o,n)=>{let s=Math.floor(e/2);t==="SAME_UPPER"?(r[o]=s,r[n]=e-s):t==="SAME_LOWER"&&(r[o]=e-s,r[n]=s)},md=(e,t,r,o,n,s,u,d,a,p)=>{let h=e.length-2,v=p.length===0;if(a.length===0)for(let y=0;y<h;++y)a.push(0);let g=e[0],w=t[d?3:1]*n;for(let y=0,x=e.length-h-(d?1:0);y<h;++y,++x){let A=e[x],$=v?A*u[y]:p[y],_=cd(A,u[y],s[y],t[x],r[y],$);pd(_,o,s,y,y+h),v&&p.push(u[y]*(A-1)+a[y]+(t[x]-1)*r[y]+1-s[y]-s[y+h])}p.splice(0,0,g),p.splice(d?3:1,0,w)},Gi=(e,t)=>{let r=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((g,w)=>g*w,1)===0){r.length=0;for(let g=2;g<t[1].dims.length;++g)r.push(t[1].dims[g])}let o=e.format==="NHWC";r.splice(0,0,t[1].dims[0]),r.splice(o?3:1,0,t[1].dims[1]);let n=e.pads.slice(),s=e.outputShape.slice(),u=e.outputPadding.slice(),d=t[0].dims,a=e.dilations.slice();if(a.reduce((g,w)=>g+w,0)===0){let g=t[0].dims.length-2;a=new Array(g).fill(1)}let p=e.strides.slice();if(p.reduce((g,w)=>g+w,0)===0){let g=t[0].dims.length-2;p=new Array(g).fill(1)}md(d,r,a,e.autoPad,e.group,n,p,o,u,s);let h=Object.assign({},e),v=e.cacheKey+[r.join("n,"),n.join(","),p.join(","),u.join(","),s.join(","),a.join(",")].join("_");return Object.assign(h,{kernelShape:r,pads:n,outputPadding:u,outputShape:s,dilations:a,strides:p,cacheKey:v}),h},Li=e=>{let t=Zr(e),r=e.format,o=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],n=e.dilations,s=e.group,u=e.kernelShape,d=e.pads,a=e.strides,p=e.wIsConst(),h=e.outputPadding,v=e.outputShape;return ie({autoPad:o,format:r,dilations:n,group:s,kernelShape:u,outputPadding:h,outputShape:v,pads:d,strides:a,wIsConst:p,...t})},fd=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");let r=e[0].dims[t.format==="NHWC"?e[0].dims.length-1:1],o=e[1].dims[0];if(r!==o)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let n=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==n))throw new Error("invalid bias");let s=e[0].dims.length-2;if(t.dilations.reduce((h,v)=>h+v,0)>0&&t.dilations.length!==s)throw new Error(`dilations should be ${s}D`);if(t.strides.reduce((h,v)=>h+v,0)>0&&t.strides.length!==s)throw new Error(`strides should be ${s}D`);if(t.pads.reduce((h,v)=>h+v,0)>0&&t.pads.length!==s*2)throw new Error(`pads should be ${s*2}D`);if(t.outputPadding.length!==s&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${s}D`);if(t.kernelShape.reduce((h,v)=>h+v,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},hd=[2,3,1,0],gd=(e,t,r)=>{let o=Gi(r,t),n=r.format==="NHWC",s=o.outputShape,u=s[n?3:1],d=t[0].dims[n?3:1];if(o.group!==1||u===1&&d===1){e.compute(Ln(t,o));return}let a=s[n?1:2],p=s[n?2:3],h=t[1].dims[2],v=t[1].dims[3],g=n?a*p:u,w=n?u:a*p,y=h*v*d,x=!0,A=e.kernelCustomData.wT??e.compute(rt(t[1],hd),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=A);let $=[t[0],A],_=t.length===3;_&&(!n&&t[2].dims.length===1?$.push(t[2].reshape([t[2].dims[0],1,1])):$.push(t[2])),e.compute(Wi($,o,s,g,w,y,_,x),{inputs:$})},yd=(e,t)=>{let r=t.format==="NHWC",o=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];o.length===3&&o.push(e.inputs[2]);let n=t.kernelShape;(n.length===0||n[0]===0)&&(n=[e.inputs[1].dims[2]]);let s=t.dilations;(s.length===0||s[0]===0)&&(s=[1]);let u=t.strides;(u.length===0||u[0]===0)&&(u=[1]);let d=t.pads;d.length===0&&(d=[0,0]),d=[0,d[0],0,d[1]],u=[1].concat(u),s=[1].concat(s),n=[1].concat(n);let a=Gi({...t,pads:d,strides:u,dilations:s,kernelShape:n},o);e.compute(Ln(o,a,p=>r?[p[0],p[2],p[3]]:[p[0],p[1],p[3]]))},Fi=(e,t)=>{fd(e.inputs,t),e.inputs[0].dims.length===3?yd(e,t):gd(e,e.inputs,t)}});var bd,ji,Ki,Yi=Y(()=>{"use strict";Ue();$e();Re();be();bd=(e,t,r,o)=>{let n=D.size(t),s=t.length,u=V("input",e,s),d=K("output",e,s),a=r.dataType===6?r.getInt32Array()[0]:Number(r.getBigInt64Array()[0]),p=D.normalizeAxis(a,s),h=v=>{let g=` i32(${u.indicesGet("inputIndices","uniforms.axis")}) `,w=Ie("uniforms.input_shape","uniforms.axis",s),y=o.reverse?g+(o.exclusive?" + 1":""):"0",x=o.reverse?w:g+(o.exclusive?"":" + 1");return`\n                ${v.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(u,d)}\n                ${v.mainStart()}\n                  ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n                  var inputIndices = ${d.offsetToIndices("global_idx")};\n                  var sum = ${d.type.value}(0);\n                  let first : i32 = ${y};\n                  let last : i32 = ${x};\n                  for (var i : i32 = first; i < last; i++) {\n                    ${u.indicesSet("inputIndices","uniforms.axis","u32(i)")};\n                    sum = sum + ${u.getByIndices("inputIndices")};\n                  }\n                  ${d.setByOffset("global_idx","sum")};\n                }`};return{name:"CumSum",shaderCache:{hint:o.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(n/64)},programUniforms:[{type:"uint32",data:n},{type:"int32",data:p},...j(t),...j(t)]}),getShaderSource:h}},ji=(e,t)=>{let r=e.inputs[0].dims,o=e.inputs[0].dataType,n=e.inputs[1];e.compute(bd(o,r,n,t),{inputs:[0]})},Ki=e=>{let t=e.exclusive===1,r=e.reverse===1;return ie({exclusive:t,reverse:r})}});var Fn,tn,Zi,wd,vd,qn,jn,Xi,$d,Ji,Qi,es=Y(()=>{"use strict";$e();Re();be();Fn="[a-zA-Z]|\\\\.\\\\.\\\\.",tn="("+Fn+")+",Zi="^"+tn+"$",wd="("+tn+",)*"+tn,vd="^"+wd+"$",qn=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,r){let o=this.symbolToIndices.get(t);o===void 0?o=[r]:o.push(r),this.symbolToIndices.set(t,o)}},jn=class{constructor(t,r){this.equation=r;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[o,n]=r.includes("->")?r.split("->",2):[r,""];if(!o.match(RegExp(vd)))throw new Error("Invalid LHS term");if(o.split(",").forEach((d,a)=>{let p=t[a].dims.slice();if(!d.match(RegExp(Zi)))throw new Error("Invalid LHS term");let h=this.processTerm(d,!0,p,a);this.lhs.push(h)}),n==="")n+=[...this.symbolToInfo.entries()].filter(([d,a])=>a.count===1||d==="...").map(([d])=>d).join("");else if(!n.match(RegExp(tn)))throw new Error("Invalid RHS");n.match(RegExp(Fn,"g"))?.forEach(d=>{if(d==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let a=this.symbolToInfo.get(d);if(a===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(a.dimValue)}}),this.rhs=this.processTerm(n,!1,this.outputDims)}addSymbol(t,r,o){let n=this.symbolToInfo.get(t);if(n!==void 0){if(n.dimValue!==r&&n.count!==1)throw new Error("Dimension mismatch");n.count++,n.inputIndices.push(o)}else n={count:1,dimValue:r,inputIndices:[o]};this.symbolToInfo.set(t,n)}processTerm(t,r,o,n=-1){let s=o.length,u=!1,d=[],a=0;if(!t.match(RegExp(Zi))&&!r&&t!=="")throw new Error("Invalid LHS term");let p=t.match(RegExp(Fn,"g")),h=new qn(n);return p?.forEach((v,g)=>{if(v==="..."){if(u)throw new Error("Only one ellipsis is allowed per input term");u=!0;let w=s-p.length+1;if(w<0)throw new Error("Ellipsis out of bounds");if(d=o.slice(a,a+w),this.hasEllipsis){if(this.ellipsisDims.length!==d.length||this.ellipsisDims.toString()!==d.toString())throw new Error("Ellipsis dimensions mismatch")}else if(r)this.hasEllipsis=!0,this.ellipsisDims=d;else throw new Error("Ellipsis must be specified in the LHS");for(let y=0;y<d.length;y++){let x=String.fromCharCode("0".charCodeAt(0)+y);h.addSymbol(x,g+y),this.addSymbol(x,o[a++],n)}}else h.addSymbol(v,g+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(v,o[a++],n)}),h}},Xi=e=>e+"_max",$d=(e,t,r,o,n)=>{let u=t.map((w,y)=>e[y]?w.length:w).map((w,y)=>V(`input${y}`,r,w)),d=D.size(n),a=ke(n.length),p=a?n.length:n,h=K("output",r,p),v=[...o.symbolToInfo.keys()].filter(w=>!o.rhs.symbolToIndices.has(w)),g=w=>{let y=[],x="var prod = 1.0;",A="var sum = 0.0;",$="sum += prod;",_=[],R=[],I=[],z=[],T=o.symbolToInfo.size===o.rhs.symbolToIndices.size;o.symbolToInfo.forEach((U,G)=>{if(o.rhs.symbolToIndices.has(G)){let J=o.rhs.symbolToIndices.get(G)?.[0];J!==void 0&&o.lhs.forEach((B,q)=>{if(U.inputIndices.includes(q)){let pe=B.symbolToIndices.get(G);if(pe===void 0)throw new Error("Invalid symbol error");pe.forEach(Q=>{y.push(`${u[q].indicesSet(`input${q}Indices`,Q,h.indicesGet("outputIndices",J))}`)})}})}else o.lhs.forEach((J,B)=>{if(U.inputIndices.includes(B)){let q=J.symbolToIndices.get(G);if(q===void 0)throw new Error("Invalid symbol error");q.forEach(pe=>{_.push(`${u[B].indicesSet(`input${B}Indices`,pe,`${G}`)}`)}),z.push(`prod *= ${u[B].getByIndices(`input${B}Indices`)};`)}}),R.push(`for(var ${G}: u32 = 0; ${G} < uniforms.${Xi(G)}; ${G}++) {`),I.push("}")});let N=T?[...y,`let sum = ${u.map((U,G)=>U.getByIndices(`input${G}Indices`)).join(" * ")};`]:[...y,A,...R,..._,x,...z,$,...I];return`\n            ${w.registerUniforms(v.map(U=>({name:`${Xi(U)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...u,h)}\n\n            ${w.mainStart()}\n            ${w.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n            var outputIndices = ${h.offsetToIndices("global_idx")};\n            ${u.map((U,G)=>`var input${G}Indices: ${u[G].type.indices};`).join(`\n`)}\n            ${N.join(`\n`)};\n            ${h.setByOffset("global_idx","sum")};\n          }`};return{name:"Einsum",shaderCache:{hint:o.equation,inputDependencies:e.map(w=>w?"rank":"dims")},getRunData:()=>{let w=v.filter(x=>o.symbolToInfo.has(x)).map(x=>({type:"uint32",data:o.symbolToInfo.get(x)?.dimValue||0}));w.push({type:"uint32",data:d});let y=t.filter((x,A)=>e[A]).map((x,A)=>[...j(x)]).reduce((x,A)=>x.concat(A),w);return a&&y.push(...j(n)),{outputs:[{dims:n,dataType:r}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:y}},getShaderSource:g}},Ji=(e,t)=>{let r=new jn(e.inputs,t.equation),o=e.inputs.map((u,d)=>ke(u.dims.length)),n=r.outputDims,s=e.inputs.map((u,d)=>u.dims);e.compute($d(o,s,e.inputs[0].dataType,r,n))},Qi=e=>{let t=e.equation.replace(/\\s+/g,"");return ie({equation:t})}});var Sd,ts,xd,Cd,rs,ns=Y(()=>{"use strict";Ue();$e();be();Sd=e=>{if(!e||e.length!==2)throw new Error("Expand requires 2 input.");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=r.length<t.length?0:r.length-t.length,n=t.length<r.length?0:t.length-r.length;for(;o<r.length&&n<t.length;++o,++n)if(r[o]!==t[n]&&r[o]!==1&&t[n]!==1)throw new Error("Expand requires shape to be broadcastable to input")},ts=(e,t)=>{let r=e.length-t.length,o=[];for(let n=0;n<r;++n)o.push(e[n]);for(let n=0;n<t.length;++n)o.push(t[n]===1?e[n+r]:t[n]);return o},xd=(e,t)=>e.length>t.length?ts(e,t):ts(t,e),Cd=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),o=xd(t,r),n=e[0].dataType,s=n===9?4:1,u=D.size(o)/s,d=ke(t.length),a=ke(o.length),p=v=>{let g=d?t.length:t,w=a?o.length:o,y=V("input",n,g,s),x=K("output",n,w,s),A;if(n===9){let $=(_,R,I="")=>`\n          let outputIndices${R} = ${x.offsetToIndices(`outputOffset + ${R}u`)};\n          let offset${R} = ${y.broadcastedIndicesToOffset(`outputIndices${R}`,x)};\n          let index${R} = offset${R} / 4u;\n          let component${R} = offset${R} % 4u;\n          ${_}[${R}] = ${I}(${y.getByOffset(`index${R}`)}[component${R}]);\n        `;A=`\n        let outputOffset = global_idx * ${s};\n        var data = vec4<u32>(0);\n        ${$("data",0,"u32")}\n        ${$("data",1,"u32")}\n        ${$("data",2,"u32")}\n        ${$("data",3,"u32")}\n        ${x.setByOffset("global_idx","data")}\n      }`}else A=`\n        let outputIndices = ${x.offsetToIndices("global_idx")};\n        let inputOffset = ${y.broadcastedIndicesToOffset("outputIndices",x)};\n        ${x.setByOffset("global_idx",y.getByOffset("inputOffset"))}\n      }`;return`\n    ${v.registerUniform("vec_size","u32").declareVariables(y,x)}\n    ${v.mainStart()}\n    ${v.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n    ${A}`},h=[{type:"uint32",data:u}];return d&&h.push(...j(t)),a&&h.push(...j(o)),{name:"Expand",shaderCache:{hint:`${o.length}`,inputDependencies:[d?"rank":"dims"]},getShaderSource:p,getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:h})}},rs=e=>{Sd(e.inputs),e.compute(Cd(e.inputs),{inputs:[0]})}});var _d,Ad,os,as,is=Y(()=>{"use strict";Ue();$e();Re();be();_d=e=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.")},Ad=(e,t)=>{let r=e[0].dims,o=e[1].dims,n=r.length,s=D.normalizeAxis(t.axis,n),u=r.slice(0);u.splice(s,1,...o);let d=r[s],a=e[0].dataType===9?4:1,p=D.size(u)/a,h=ke(e[0].dims.length),v=h?e[0].dims.length:e[0].dims,g=ke(e[1].dims.length),w=g?e[1].dims.length:e[1].dims,y=ke(u.length),x=y?u.length:u,A=[{type:"uint32",data:p},{type:"int32",data:d},{type:"uint32",data:s}];h&&A.push(...j(e[0].dims)),g&&A.push(...j(e[1].dims)),y&&A.push(...j(u));let $=[];$.push(h?"rank":"dims"),$.push(g?"rank":"dims");let _=R=>{let I=V("data",e[0].dataType,v,a),z=V("inputIndices",e[1].dataType,w),T=K("output",e[0].dataType,x,a),N=G=>{let J=o.length,B=`var indicesIndices${G}  = ${z.type.indices}(0);`;for(let q=0;q<J;q++)B+=`${J>1?`indicesIndices${G}[${q}]`:`indicesIndices${G}`} = ${u.length>1?`outputIndices${G}[uniforms.axis + ${q}]`:`outputIndices${G}`};`;B+=`\n          var idx${G} = ${z.getByIndices(`indicesIndices${G}`)};\n          if (idx${G} < 0) {\n            idx${G} = idx${G} + uniforms.axisDimLimit;\n          }\n          var dataIndices${G} = ${I.type.indices}(0);\n        `;for(let q=0,pe=0;q<n;q++)q===s?(B+=`${n>1?`dataIndices${G}[${q}]`:`dataIndices${G}`} = u32(idx${G});`,pe+=J):(B+=`${n>1?`dataIndices${G}[${q}]`:`dataIndices${G}`} = ${u.length>1?`outputIndices${G}[${pe}]`:`outputIndices${G}`};`,pe++);return B},U;if(e[0].dataType===9){let G=(J,B,q="")=>`\n          let outputIndices${B} = ${T.offsetToIndices(`outputOffset + ${B}u`)};\n          ${N(B)};\n          let offset${B} = ${I.indicesToOffset(`dataIndices${B}`)};\n          let index${B} = offset${B} / 4u;\n          let component${B} = offset${B} % 4u;\n          ${J}[${B}] = ${q}(${I.getByOffset(`index${B}`)}[component${B}]);\n        `;U=`\n        let outputOffset = global_idx * ${a};\n        var value = vec4<u32>(0);\n        ${G("value",0,"u32")}\n        ${G("value",1,"u32")}\n        ${G("value",2,"u32")}\n        ${G("value",3,"u32")}\n        ${T.setByOffset("global_idx","value")}\n      `}else U=`\n      let outputIndices = ${T.offsetToIndices("global_idx")};\n      ${N("")};\n      let value = ${I.getByIndices("dataIndices")};\n      ${T.setByOffset("global_idx","value")};\n      `;return`\n      ${R.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(I,z,T)}\n      ${R.mainStart()}\n        ${R.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        ${U}\n      }`};return{name:"Gather",shaderCache:{hint:t.cacheKey,inputDependencies:$},getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:A}),getShaderSource:_}},os=e=>ie({axis:e.axis}),as=(e,t)=>{let r=e.inputs;_d(r),e.compute(Ad(e.inputs,t))}});var Id,Td,ss,us,ls=Y(()=>{"use strict";$e();Re();be();Id=e=>{if(!e||e.length!==2)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},Td=(e,t)=>{let r=e[0].dims,o=e[0].dataType,n=r.length,s=e[1].dims,u=e[1].dataType,d=D.normalizeAxis(t.axis,n),a=r[d],p=s.slice(0),h=D.size(p),v=V("input",o,n),g=V("indicesInput",u,s.length),w=K("output",o,p.length),y=[{type:"uint32",data:h},{type:"int32",data:a},{type:"uint32",data:d}];return y.push(...j(r)),y.push(...j(s)),y.push(...j(p)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:p,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:y}),getShaderSource:$=>`\n      ${$.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(v,g,w)}\n      ${$.mainStart()}\n      ${$.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n      let outputIndices = ${w.offsetToIndices("global_idx")};\n\n      var idx = ${g.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + uniforms.axisDimLimit;\n      }\n      var inputIndices = ${v.type.indices}(outputIndices);\n      ${v.indicesSet("inputIndices","uniforms.axis","u32(idx)")};\n      let value = ${v.getByIndices("inputIndices")};\n\n      ${w.setByOffset("global_idx","value")};\n  }`}},ss=e=>ie({axis:e.axis}),us=(e,t)=>{let r=e.inputs;Id(r),e.compute(Td(e.inputs,t))}});var Ed,Od,kd,ds,cs,ps=Y(()=>{"use strict";$e();Re();be();Ed=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(e.length===3&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},Od=(e,t,r)=>{if(r.length===0)return"0u";let o=r.length===1&&e!==1||r.length===2&&r[0]!==e,n=r[r.length-1]!==t,s="0u";return o||(s+=`+ m * ${r[r.length-1]}u`),n||(s+="+n"),s},kd=(e,t)=>{let r=e[0].dims.slice(),o=e[1].dims.slice(),[n,s,u]=zr.getShapeOfGemmResult(r,t.transA,o,t.transB,e.length===3?e[2].dims:void 0),d=[n,s];if(!d)throw new Error("Can\'t use gemm on the given tensors");let a=D.size(d),p="";t.transA&&t.transB?p="value += a[k * M + m] * b[n * K + k];":t.transA&&!t.transB?p="value += a[k * M + m] * b[k * N + n];":!t.transA&&t.transB?p="value += a[m * K + k] * b[n * K + k];":!t.transA&&!t.transB&&(p="value += a[m * K + k] * b[k * N + n];");let h=Oe(e[0].dataType),v=t.alpha===1?"":"value *= alpha;",g=e.length===3?`value += beta * c[${Od(n,s,e[2].dims)}];`:"",w=[`@group(0) @binding(0) var<storage, read> a : array<${h}>;`,`@group(0) @binding(1) var<storage, read> b : array<${h}>;`];e.length===3&&w.push(`@group(0) @binding(2) var<storage, read> c : array<${h}>;`);let y=x=>`\n  const M: u32 = ${n}u;\n  const N: u32 = ${s}u;\n  const K: u32 = ${u}u;\n  const alpha = ${h}(${t.alpha});\n  const beta = ${h}(${t.beta});\n\n  ${w.join(`\n`)}\n  @group(0) @binding(${e.length}) var<storage, read_write> output : array<${h}>;\n\n  ${x.mainStart()}\n    ${x.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n\n    let m = global_idx / N;\n    let n = global_idx % N;\n\n    var value = ${h}(0);\n    for (var k: u32 = 0u; k<${u}u; k++) {\n      ${p}\n    }\n\n    ${v}\n    ${g}\n    output[global_idx] = value;\n\n  }`;return{name:"Gemm",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:y}},ds=(e,t)=>{Ed(e.inputs),e.compute(kd(e.inputs,t))},cs=e=>ie(e)});var Pd,Rd,Bd,Md,ms,fs,hs=Y(()=>{"use strict";Ue();$e();Re();be();Pd={name:"InstanceNormalization"},Rd=(e,t)=>{let r=e[0].dims,o=r,n=2,s=D.sizeToDimension(r,n),u=D.sizeFromDimension(r,n),d=Ne(u),a=u/d,p=r[1],h=V("x",e[0].dataType,[r[0],r[1],a],d),v=V("scale",e[1].dataType,e[1].dims),g=V("bias",e[2].dataType,e[2].dims),w=K("output",e[0].dataType,[r[0],r[1],a],d),y=[h,v,g,w],x=h.type.value,A=d===1?"f32":`vec${d}<f32>`,$=64,_=R=>`\n\n  const C: u32 = ${p};\n  const normSize: u32 = ${u};\n  const epsilon: f32 = ${t.epsilon};\n  var<workgroup> meanShared : f32;\n  var<workgroup> squaredNormShared : f32;\n  var<workgroup> workgroupShared : array<${A}, ${$}>;\n  const workgroupSize = ${$}u;\n  ${R.declareVariables(...y)}\n  ${R.mainStart($)}\n    let norm = global_idx / workgroupSize;\n    let batch = norm / C;\n    let channel = norm % C;\n    let localIndex = local_id.x;\n\n    // initialize workgroup memory\n    var initial = ${A}(0);\n    for (var h = localIndex; h < ${a}; h += workgroupSize) {\n      initial = initial + ${A}(${h.get("batch","channel","h")});\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the mean of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      meanShared = ${Xe("workgroupShared[0]",d)} / f32(normSize);\n    }\n    workgroupBarrier();\n\n    // reinitialize workgroup memory.\n    initial = ${A}(0);\n    for (var h = localIndex; h < ${a}; h += workgroupSize) {\n      let deviation =  ${A}(${h.get("batch","channel","h")}) - ${A}(meanShared);\n      initial = initial + deviation * deviation;\n    }\n    workgroupShared[localIndex] = initial;\n    workgroupBarrier();\n\n    // Calculate the sum of square of deviation of current channel data.\n    for (var currSize = workgroupSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (localIndex < currSize) {\n        workgroupShared[localIndex] = workgroupShared[localIndex] + workgroupShared[localIndex + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (localIndex == 0) {\n      squaredNormShared = ${Xe("workgroupShared[0]",d)};\n    }\n    workgroupBarrier();\n\n    let invStdDev = 1 / sqrt(squaredNormShared / f32(normSize) + epsilon);\n    let channelScale = invStdDev * f32(${v.getByOffset("channel")});\n    let channelShift = f32(${g.getByOffset("channel")}) - meanShared * channelScale;\n    for (var h = localIndex; h < ${a}; h += workgroupSize) {\n      let value = ${h.get("batch","channel","h")} * ${x}(${A}(channelScale)) + ${x}(${A}(channelShift));\n      ${w.set("batch","channel","h","value")};\n    }\n  }`;return{...Pd,shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:s}}),getShaderSource:_}},Bd=(e,t,r,o,n,s,u,d)=>{let a=Ne(u),p=V("input",t.dataType,t.dims,a),h=V("scale",r.dataType,r.dims,a),v=V("bias",o.dataType,o.dims,a),g=64,w=a===1?"vec2f":`mat2x${a}f`,y=a===1?"f32":`vec${a}f`,x=(z,T)=>`${w}(${z}, ${T})`,A=n*u/a,$=Math.ceil(s/g),_=z=>`\n  const H: u32 = ${s};\n  const C: u32 = ${u/a};\n  const imageSize: u32 = ${s*u/a};\n\n  ${z.declareVariables(p)}\n  @group(0) @binding(1) var<storage, read_write> output : array<${w}>;\n\n  ${z.mainStart(g)}\n    let currentImageNumber = global_idx / ${g} / C;\n    let currentChannelNumber = (global_idx / ${g}) % C;\n    let wgId = global_idx % ${g};\n    let wgOffset = wgId * ${$};\n    if (wgOffset >= H) {\n        return;\n    }\n    let wgMax = min(wgOffset + ${$}, H);\n\n    let offset = currentImageNumber * imageSize + currentChannelNumber;\n    var sum = ${je("f32",a)};\n    var squaredSum = ${je("f32",a)};\n    for (var i: u32 = wgOffset; i < wgMax; i++) {\n        let value = ${y}(input[offset + i * C]);\n        sum += value;\n        squaredSum += value * value;\n    }\n    output[global_idx] = ${x("sum","squaredSum")};\n  }`,R=e.compute({name:"InstanceNormComputeMean",shaderCache:{hint:JSON.stringify({components:a,n,h:s,c:u})},getRunData:()=>({outputs:[{dims:[n,u,g,2],dataType:1}],dispatchGroup:{x:n*u/a}}),getShaderSource:_},{inputs:[t],outputs:[-1]})[0],I=z=>`\n  const H: u32 = ${s};\n  const C: u32 = ${u/a};\n  const imageSize: u32 = ${g*u/a};\n  const epsilon: f32 = ${d};\n\n  @group(0) @binding(0) var<storage, read> input : array<${w}>;\n  @group(0) @binding(1) var<storage, read> scale : array<${h.type.storage}>;\n  @group(0) @binding(2) var<storage, read> bias : array<${v.type.storage}>;\n  @group(0) @binding(3) var<storage, read_write> output : array<${w}>;\n\n  ${z.mainStart()}\n    ${z.guardAgainstOutOfBoundsWorkgroupSizes(A)}\n    let currentImageNumber = global_idx / C;\n    let currentChannelNumber = global_idx % C;\n\n    let offset = currentImageNumber * imageSize;\n    var sum = ${je("f32",a)};\n    var squaredSum = ${je("f32",a)};\n    for (var i: u32 = 0; i < ${g}; i++) {\n        let value = input[offset + i + currentChannelNumber * ${g}];\n        sum += value[0];\n        squaredSum += value[1];\n    }\n    sum = sum / f32(H);\n    squaredSum = squaredSum / f32(H);\n    let invStdDev = 1 / sqrt(squaredSum - sum * sum + epsilon);\n    let channelScale = invStdDev * ${y}(scale[currentChannelNumber]);\n    let channelShift = ${y}(bias[currentChannelNumber]) - sum * channelScale;\n\n    output[global_idx] = ${x("channelScale","channelShift")};\n  }`;return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:JSON.stringify({components:a,n,h:s,c:u,epsilon:d})},getRunData:()=>({outputs:[{dims:[n,u,2],dataType:1}],dispatchGroup:{x:Math.ceil(A/64)}}),getShaderSource:I},{inputs:[R,r,o],outputs:[-1]})[0]},Md=(e,t,r)=>{let o=t[0].dims,n=o,s=o[0],u=o[o.length-1],d=D.sizeFromDimension(o,1)/u,a=Ne(u),p=D.size(n)/a,h=V("input",t[0].dataType,t[0].dims,a),v=K("output",t[0].dataType,n,a),g=Oe(t[0].dataType),w=a===1?"vec2f":`mat2x${a}f`,y=a===1?g:`vec${a}<${g}>`,x=Bd(e,t[0],t[1],t[2],s,d,u,r.epsilon),A=$=>`\n  const H: u32 = ${d};\n  const C: u32 = ${u/a};\n\n  @group(0) @binding(0) var<storage, read> input : array<${h.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scaleInput : array<${w}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${v.type.storage}>;\n\n  ${$.mainStart()}\n    let currentImageNumber = global_idx / (C * H);\n    let currentChannelNumber = global_idx % C;\n\n    let scaleOffset = currentImageNumber * C + currentChannelNumber;\n    let scale = scaleInput[scaleOffset];\n    output[global_idx] = fma(input[global_idx], ${y}(scale[0]), ${y}(scale[1]));\n  }`;e.compute({name:"InstanceNormalization",shaderCache:{hint:`${r.cacheKey}`},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)}}),getShaderSource:A},{inputs:[t[0],x]})},ms=e=>ie({epsilon:e.epsilon,format:e.format}),fs=(e,t)=>{t.format==="NHWC"?Md(e,e.inputs,t):e.compute(Rd(e.inputs,t))}});var Dd,zd,gs,ys,bs=Y(()=>{"use strict";Ue();$e();Re();be();Dd=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},zd=(e,t,r)=>{let o=e[0].dims,n=e[1],s=e[2],u=o,d=D.normalizeAxis(t.axis,o.length),a=D.sizeToDimension(o,d),p=D.sizeFromDimension(o,d),h=D.size(n.dims),v=s?D.size(s.dims):0;if(h!==p||s&&v!==p)throw new Error(`Size of X.shape()[axis:] == ${p}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${h} and bias size of ${v}`);let g=[];for(let I=0;I<o.length;++I)I<d?g.push(o[I]):g.push(1);let w=Ne(p),y=Oe(e[0].dataType),x=[V("x",e[0].dataType,e[0].dims,w),V("scale",n.dataType,n.dims,w)];s&&x.push(V("bias",s.dataType,s.dims,w)),x.push(K("output",e[0].dataType,u,w));let A=r>1,$=r>2;A&&x.push(K("meanDataOutput",1,g)),$&&x.push(K("invStdOutput",1,g));let _=I=>`\n  const normSize: f32 = ${p};\n  const normSizeVectorized: u32 = ${p/w};\n  const epsilon: f32 = ${t.epsilon};\n\n  ${I.declareVariables(...x)}\n  ${I.mainStart()}\n    ${I.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n    let offset = global_idx * normSizeVectorized;\n    var meanVector = ${je("f32",w)};\n    var meanSquareVector = ${je("f32",w)};\n\n    for (var h: u32 = 0u; h < normSizeVectorized; h++) {\n      let value = ${tt(y,w,"x[h + offset]")};\n      meanVector += value;\n      meanSquareVector += value * value;\n    }\n    let mean = ${Xe("meanVector",w)} / normSize;\n    let meanSquare = sqrt(${Xe("meanSquareVector",w)} \n      / normSize - mean * mean + epsilon);\n\n    for (var j: u32 = 0; j < normSizeVectorized; j++) {\n      let f32input = ${tt(y,w,"x[j + offset]")};\n      let f32scale = ${tt(y,w,"scale[j]")};\n      output[j + offset] = ${x[0].type.value}((f32input - mean) / meanSquare * f32scale\n        ${s?`+ ${tt(y,w,"bias[j]")}`:""}\n      );\n    }\n\n    ${A?"meanDataOutput[global_idx] = mean":""};\n    ${$?"invStdOutput[global_idx] = 1 / meanSquare":""};\n  }`,R=[{dims:u,dataType:e[0].dataType}];return A&&R.push({dims:g,dataType:1}),$&&R.push({dims:g,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${t.cacheKey}|${r}|${e.length}`},getRunData:()=>({outputs:R,dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:_}},gs=e=>ie({axis:e.axis,epsilon:e.epsilon}),ys=(e,t)=>{Dd(e.inputs),e.compute(zd(e.inputs,t,e.outputCount))}});var Vd,vs,ws,Ud,Kn,$s,Ss=Y(()=>{"use strict";$e();Re();Mr();Rn();be();Nt();Vd=(e,t)=>{let r=e[0],o=e[1],n=e[2],s=e[3],u=e[4],d=e[5],a=e[6],p=e[7];if(r.dims.length!==3&&r.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let h=!1,v=r.dims[0],g=r.dims[1],w=r.dims.length===3?h?r.dims[2]/3:r.dims[2]:t.numHeads*r.dims[4],y=g,x=0,A=0,$=Math.floor(w/t.numHeads);if(a&&p){if(a.dims.length!==4)throw new Error(\'Input "past_key" is expected to have 4 dimensions\');if(p.dims.length!==4)throw new Error(\'Input "past_value" is expected to have 4 dimensions\');x=a.dims[2],A=a.dims[2]}else if(a||p)throw new Error(\'Input "past_key" and "past_value" shall be both present or both absent\');let _;if(o){if(r.dims.length!==3)throw new Error(\'Input "query" is expected to have 3 dimensions when key is given\');if(o.dims.length<3||o.dims.length>5)throw new Error(\'Input "key" is expected to have 3, 4, or 5 dimensions\');if(r.dims[0]!==o.dims[0])throw new Error(\'Input "query" and "key" shall have same dim 0 (batch size)\');if(o.dims.length===3){if(o.dims[2]!==r.dims[2])throw new Error(\'Input "query" and "key" shall have same dim 2 (hidden_size)\');_=2,y=o.dims[1]}else if(o.dims.length===5){if(o.dims[2]!==t.numHeads||o.dims[3]!==2||o.dims[4]!==$)throw new Error(\'Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv\');if(n)throw new Error(\'Expect "value" be none when "key" has packed kv format.\');_=5,y=o.dims[1]}else{if(o.dims[1]!==t.numHeads||o.dims[3]!==$)throw new Error(\'Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key\');_=0,y=o.dims[2]}}else{if(r.dims.length!==3&&r.dims.length!==5)throw new Error(\'Input "query" is expected to have 3 or 5 dimensions when key is empty\');if(r.dims.length===5&&(r.dims[2]!==t.numHeads||r.dims[3]!==3))throw new Error(\'Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv\');_=3}if(s){if(s.dims.length!==1)throw new Error(\'Input "bias" is expected to have 1 dimension\');if(n&&r.dims.length===5&&r.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let R=0;if(u){R=8;let U=u.dims;throw U.length===1?U[0]===v?R=1:U[0]===3*v+2&&(R=3):U.length===2&&U[0]===v&&U[1]===y&&(R=5),R===8?new Error(\'Input "key_padding_mask" shape shall be (batch_size) or (batch_size, kv_sequence_length)\'):new Error("Mask not supported")}let I=!1,z=w;if(n){if(n.dims.length!==3&&n.dims.length!==4)throw new Error(\'Input "value" is expected to have 3 or 4 dimensions\');if(r.dims[0]!==n.dims[0])throw new Error(\'Input "query" and "value" shall have same dim 0 (batch_size)\');if(n.dims.length===3){if(y!==n.dims[1])throw new Error(\'Input "key" and "value" shall have the same dim 1 (kv_sequence_length)\');z=n.dims[2]}else{if(y!==n.dims[2])throw new Error(\'Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)\');z=n.dims[1]*n.dims[3],I=!0}}let T=x+y,N=!1;if(u)throw new Error("Key padding mask is not supported");if(d)throw new Error("extraAddQk is not supported");if(a)throw new Error("pastKey is not supported");if(p)throw new Error("pastValue is not supported");return{batchSize:v,sequenceLength:g,pastSequenceLength:x,kvSequenceLength:y,totalSequenceLength:T,maxSequenceLength:A,inputHiddenSize:0,hiddenSize:w,vHiddenSize:z,headSize:$,vHeadSize:Math.floor(z/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:R,scale:t.scale,broadcastResPosBias:N,passPastInKv:I,qkvFormat:_}},vs=e=>ie({...e}),ws=ie({perm:[0,2,1,3]}),Ud=(e,t,r,o,n,s,u)=>{let d=[o,n,s],a=D.size(d),p=Oe(t.dataType),h=v=>`\n  const biasOffset = ${u}u;\n  const hiddenSize = ${s}u;\n\n  @group(0) @binding(0) var<storage, read> qkv: array<${p}>;\n  @group(0) @binding(1) var<storage, read> bias: array<${p}>;\n  @group(0) @binding(2) var<storage, read_write> qkv_with_bias: array<${p}>;\n\n  ${v.mainStart()}\n    ${v.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n    let biasOffsetIdx = (global_idx % hiddenSize) + biasOffset;\n\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[biasOffsetIdx];\n  }`;return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{hint:JSON.stringify({batchSize:o,sequenceLength:n,hiddenSize:s,biasOffset:u})},getRunData:()=>({outputs:[{dims:d,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:h},{inputs:[t,r],outputs:[-1]})[0]},Kn=(e,t,r,o,n,s,u,d)=>{let a=s;if(u){if(o===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return a=Ud(e,s,u,t,o,r*n,d),a=a.reshape([t,o,r,n]),e.compute(rt(a,ws.perm),{inputs:[a],outputs:[-1]})[0]}else return s.dims.length===3&&(a=s.reshape([t,o,r,n])),e.compute(rt(a,ws.perm),{inputs:[a],outputs:[-1]})[0]},$s=(e,t)=>{let r=Vd(e.inputs,t);if(e.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(e.inputs[1]?.dims.length===5)throw new Error("Packed KV is not implemented");let o=e.inputs[1]&&e.inputs[2]&&e.inputs[1].dims.length===4&&e.inputs[2].dims.length===4,n=Kn(e,r.batchSize,r.numHeads,r.sequenceLength,r.headSize,e.inputs[0],e.inputs[3],0);if(o)return Gr(e,n,e.inputs[1],e.inputs[2],e.inputs[4],void 0,void 0,void 0,e.inputs[5],r,t);let s=Kn(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.headSize,e.inputs[1],e.inputs[3],r.hiddenSize),u=Kn(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.vHeadSize,e.inputs[2],e.inputs[3],2*r.hiddenSize);Gr(e,n,s,u,e.inputs[4],void 0,e.inputs[6],e.inputs[7],e.inputs[5],r,t)}});var Wd,Nd,Hd,Gd,Ld,Fd,qd,jd,Kd,xs,Cs,_s=Y(()=>{"use strict";Ue();$e();Re();be();Wd=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(e[0].dataType!==1)throw new Error("Input type must be float.");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},Nd=(e,t,r,o,n,s)=>{let u=t.length,d="";for(let a=u-1;a>=0;--a)d+=`\n            k = i32(${e.indicesGet("indices",a)}) - ${o[a]};\n            if (k < 0) {\n              break;\n            }\n            if (k >= ${t[a]}) {\n              break;\n            }\n            offset += k * ${r[a]};\n        `;return`\n          value = ${n}(${s});\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${d}\n            value = x[offset];\n          }\n      `},Hd=(e,t,r,o)=>{let n=t.length,s="";for(let u=n-1;u>=0;--u)s+=`\n                k = i32(${e.indicesGet("indices",u)}) - ${o[u]};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = ${2*(t[u]-1)};\n                  k = k % _2n_1;\n                  if(k >= ${t[u]}) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * ${r[u]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${s}\n              value = x[offset];\n          `},Gd=(e,t,r,o)=>{let n=t.length,s="";for(let u=n-1;u>=0;--u)s+=`\n                k = i32(${e.indicesGet("indices",u)}) - ${o[u]};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= ${t[u]}) {\n                  k = ${t[u]-1};\n                }\n                offset += k * ${r[u]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${s}\n              value = x[offset];\n          `},Ld=(e,t,r,o)=>{let n=t.length,s="";for(let u=n-1;u>=0;--u)s+=`\n                k = i32(${e.indicesGet("indices",u)}) - ${o[u]};\n                if (k < 0)  {\n                  k += ${t[u]};\n                }\n                if (k >= ${t[u]}) {\n                  k -= ${t[u]};\n                }\n                offset += k * ${r[u]};\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${s}\n              value = x[offset];\n          `},Fd=(e,t,r,o,n)=>{switch(o.mode){case 0:return Nd(e,t,r,o.pads,n,o.value);case 1:return Hd(e,t,r,o.pads);case 2:return Gd(e,t,r,o.pads);case 3:return Ld(e,t,r,o.pads);default:throw new Error("Invalid mode")}},qd=(e,t,r,o)=>{let n=t[0].dims,s=D.padShape(n.slice(),r.pads),u=D.size(s),d=D.computeStrides(n),a=K("output",t[0].dataType,s),p=V("x",t[0].dataType,n),h=Fd(a,n,d,r,o);return`\n              ${e.declareVariables(p,a)}\n              ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n\n              let indices = ${a.offsetToIndices("global_idx")};\n\n              var value = ${o}(0);\n              ${h}\n              output[global_idx] = value;\n          }`},jd=(e,t)=>{let r=D.padShape(e[0].dims.slice(),t.pads);return{name:"Pad",shaderCache:{hint:t.cacheKey},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(D.size(r)/64)}}),getShaderSource:o=>qd(o,e,t,"f32")}},Kd=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),o=e.length>=3&&e[2].data?e[2].getFloat32Array()[0]:0,n=e[0].dims.length,s=new Int32Array(2*n).fill(0);if(e.length>=4){let d=e[3].getBigInt64Array();for(let a=0;a<d.length;a++)s[Number(d[a])]=Number(r[a]),s[Number(d[a])+n]=Number(r[a+d.length])}else r.forEach((d,a)=>s[Number(a)]=Number(d));let u=[];return s.forEach(d=>u.push(d)),ie({mode:t.mode,value:o,pads:u})}else return t},xs=(e,t)=>{Wd(e.inputs);let r=Kd(e.inputs,t);e.compute(jd(e.inputs,r),{inputs:[0]})},Cs=e=>{let t=e.mode,r=e.value,o=e.pads;return ie({mode:t,value:r,pads:o})}});var rn,As,Is,Ts,Es,Yd,Zd,Os,ks,Ps,Rs,Bs,Ms,Ds,zs,Vs,Us,Ws,Ns,Hs=Y(()=>{"use strict";jr();$e();be();rn=e=>{if(Ht.webgpu.validateInputContent&&(!e||e.length!==1))throw new Error("Pool ops requires 1 input.")},As=(e,t,r)=>{let o=t.format==="NHWC",n=e.dims.slice();o&&n.splice(1,0,n.pop());let s=Object.hasOwnProperty.call(t,"dilations"),u=t.kernelShape.slice(),d=t.strides.slice(),a=s?t.dilations.slice():[],p=t.pads.slice();kt.adjustPoolAttributes(r,n,u,d,a,p);let h=kt.computePoolOutputShape(r,n,d,a,u,p,t.autoPad),v=Object.assign({},t);s?Object.assign(v,{kernelShape:u,strides:d,pads:p,dilations:a,cacheKey:t.cacheKey}):Object.assign(v,{kernelShape:u,strides:d,pads:p,cacheKey:t.cacheKey});let g=h.slice();return g.push(g.splice(1,1)[0]),[v,o?g:h]},Is=(e,t)=>{let r=t.format==="NHWC",o=D.size(e),n=D.size(t.kernelShape),s=[{type:"uint32",data:o},{type:"uint32",data:n}],u=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(t.kernelShape.length<=2){let d=t.kernelShape[t.kernelShape.length-1],a=t.strides[t.strides.length-1],p=t.pads[t.pads.length/2-1],h=t.pads[t.pads.length-1],v=!!(p+h);s.push({type:"uint32",data:d},{type:"uint32",data:a},{type:"uint32",data:p},{type:"uint32",data:h}),u.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let g=!1;if(t.kernelShape.length===2){let w=t.kernelShape[t.kernelShape.length-2],y=t.strides[t.strides.length-2],x=t.pads[t.pads.length/2-2],A=t.pads[t.pads.length-2];g=!!(x+A),s.push({type:"uint32",data:w},{type:"uint32",data:y},{type:"uint32",data:x},{type:"uint32",data:A}),u.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[s,u,!0,v,g]}else{if(r)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let d=D.computeStrides(t.kernelShape);s.push({type:"uint32",data:d},{type:"uint32",data:t.pads},{type:"uint32",data:t.strides}),u.push({name:"kernelStrides",type:"u32",length:d.length},{name:"pads",type:"u32",length:t.pads.length},{name:"strides",type:"u32",length:t.strides.length});let a=t.pads.reduce((p,h)=>p+h);return[s,u,!!a,!1,!1]}},Ts=(e,t,r,o,n,s,u,d,a,p,h,v)=>{let g=n.format==="NHWC",w=t.type.value,y=K("output",t.type.tensor,o);if(n.kernelShape.length<=2){let x="",A="",$="",_=r-(g?2:1);if(h?x=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${_}] = indices[${_}] * uniforms.sw - uniforms.pwStart + i;\n                  if (xIndices[${_}] < 0 || xIndices[${_}]\n                      >= uniforms.x_shape[${_}]) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${s}\n                }`:x=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${_}] = indices[${_}] * uniforms.sw - uniforms.pwStart + i;\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${s}\n                }`,n.kernelShape.length===2){let I=r-(g?3:2);v?A=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${I}] = indices[${I}] * uniforms.sh - uniforms.phStart + j;\n                  if (xIndices[${I}] < 0 || xIndices[${I}] >= uniforms.x_shape[${I}]) {\n                    pad += i32(uniforms.kw);\n                    continue;\n                  }\n              `:A=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${I}] = indices[${I}] * uniforms.sh - uniforms.phStart + j;\n                `,$=`\n              }\n            `}return`\n            ${e.registerUniforms(a).declareVariables(t,y)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n              let indices = ${y.offsetToIndices("global_idx")};\n              var xIndices = ${y.offsetToIndices("global_idx")};\n\n              var value = ${w}(${d});\n              var pad = 0;\n              ${A}\n              ${x}\n              ${$}\n              ${u}\n\n              output[global_idx] = value;\n            }`}else{if(g)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let x=n.kernelShape.length,A=n.pads.length,$="";return p?$=`\n                if (xIndices[j] >= uniforms.x_shape[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${s}\n              }`:$=`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${s}\n            `,`\n            ${e.registerUniforms(a).declareVariables(t,y)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n              let indices = ${y.offsetToIndices("global_idx")};\n              var xIndices = ${y.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${x}>;\n\n              var value = ${w}(${d});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${x-1}u; j++) {\n                  offsets[j] = offset / ${Ie("uniforms.kernelStrides","j",x)};\n                  offset -= offsets[j] * ${Ie("uniforms.kernelStrides","j",x)};\n                }\n                offsets[${x-1}] = offset;\n\n                isPad = false;\n                for (var j = ${r-x}u; j < ${r}u; j++) {\n                  xIndices[j] = indices[j] * ${Ie("uniforms.strides",`j - ${r-x}u`,x)}\n                    + offsets[j - ${r-x}u] - ${Ie("uniforms.pads","j - 2u",A)};\n                  ${$}\n              }\n              ${u}\n\n              output[global_idx] = value;\n            }`}},Es=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,Yd=e=>`${Es(e)};${e.countIncludePad}`,Zd=e=>`${Es(e)};${e.storageOrder};${e.dilations}`,Os=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),ks=(e,t,r,o)=>{let[n,s]=As(t,o,r),u=V("x",t.dataType,t.dims.length),d=u.type.value,a="value += x_val;",p="";n.countIncludePad?p+=`value /= ${d}(uniforms.kernelSize);`:p+=`value /= ${d}(i32(uniforms.kernelSize) - pad);`;let[h,v,g,w,y]=Is(s,n);h.push(...j(t.dims),...j(s));let x=["rank"];return{name:e,shaderCache:{hint:`${o.cacheKey};${g};${w};${y}`,inputDependencies:x},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(D.size(s)/64)},programUniforms:h}),getShaderSource:A=>Ts(A,u,t.dims.length,s.length,n,a,p,0,v,g,w,y)}},Ps=e=>{let t=e.count_include_pad!==0,r=Os(e);if(r.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let o={countIncludePad:t,...r,cacheKey:""};return{...o,cacheKey:Yd(o)}},Rs=(e,t)=>{rn(e.inputs),e.compute(ks("AveragePool",e.inputs[0],!1,t))},Bs={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},Ms=e=>{let t=e.format;return{format:t,...Bs,cacheKey:t}},Ds=(e,t)=>{rn(e.inputs),e.compute(ks("GlobalAveragePool",e.inputs[0],!0,t))},zs=(e,t,r,o)=>{let[n,s]=As(t,o,r),u=`\n      value = max(x_val, value);\n    `,d="",a=V("x",t.dataType,t.dims.length),p=["rank"],[h,v,g,w,y]=Is(s,n);return h.push(...j(t.dims),...j(s)),{name:e,shaderCache:{hint:`${o.cacheKey};${g};${w};${y}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(D.size(s)/64)},programUniforms:h}),getShaderSource:x=>Ts(x,a,t.dims.length,s.length,n,u,d,-1e5,v,g,w,y)}},Vs=(e,t)=>{rn(e.inputs),e.compute(zs("MaxPool",e.inputs[0],!1,t))},Us=e=>{let t=e.storage_order,r=e.dilations,o=Os(e);if(t!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(o.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let n={storageOrder:t,dilations:r,...o,cacheKey:""};return{...n,cacheKey:Zd(n)}},Ws=e=>{let t=e.format;return{format:t,...Bs,cacheKey:t}},Ns=(e,t)=>{rn(e.inputs),e.compute(zs("GlobalMaxPool",e.inputs[0],!0,t))}});var Jd,Qd,Gs,Ls=Y(()=>{"use strict";jr();Ue();be();Jd=(e,t,r)=>{let o=e===t,n=e<t&&r<0,s=e>t&&r>0;if(o||n||s)throw new Error("Range these inputs\' contents are invalid.")},Qd=(e,t,r,o)=>{let n=Math.abs(Math.ceil((t-e)/r)),s=[n],u=n,d=K("output",o,s),a=d.type.storage,p=h=>`\n        ${h.declareVariables(d)}\n        ${h.mainStart()}\n        ${h.guardAgainstOutOfBoundsWorkgroupSizes(u)}\n        output[global_idx] = ${a}(${e}) + ${a}(global_idx) * ${a}(${r});\n      }`;return{name:"Range",shaderCache:{hint:[e,t,r].map(h=>h.toString()).join("_")},getShaderSource:p,getRunData:()=>({outputs:[{dims:s,dataType:o}],dispatchGroup:{x:Math.ceil(u/64)}})}},Gs=e=>{let t=0,r=0,o=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],o=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],o=e.inputs[2].getFloat32Array()[0]),Ht.webgpu.validateInputContent&&Jd(t,r,o),e.compute(Qd(t,r,o,e.inputs[0].dataType),{inputs:[]})}});var ec,tc,rc,nc,oc,ac,ic,sc,uc,lc,dc,cc,pc,mc,fc,Fs,qs,js=Y(()=>{"use strict";$e();Re();be();ec=(e,t)=>{if(e.every(r=>r>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0){if(t.mode==="linear"){if(!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for linear mode")}else if(t.mode==="cubic"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},tc=(e,t,r)=>{t.every(n=>n>=0&&n<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let o=new Array(r).fill(1);return t.forEach((n,s)=>o[n]=e[s]),o},rc=(e,t,r,o,n,s)=>{let[u,d,a]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],p=e[0].dims.length;if(u>0&&e.length>u&&e[u].dims.length>0)e[u].getFloat32Array().forEach(h=>s.push(h));else if(t.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(d>0&&e.length>d&&e[d].dims.length>0){if(e[d].getFloat32Array().forEach(h=>o.push(h)),o.length!==0&&o.length!==p&&r>=18&&o.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");ec(o,t),t.axes.length>0&&tc(o,t.axes,p).forEach((h,v)=>o[v]=h)}if(a>0&&e.length>a&&(e[a].getBigInt64Array().forEach(h=>n.push(Number(h))),n.length!==p||r>=18&&n.length===t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(o.length!==t.axes.length)throw new Error(\'Resize requires "scales" input size to be of axes rank when axes attributes is specified\');if(n.length!==t.axes.length)throw new Error(\'Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified\')}if(typeof o<"u"&&typeof n<"u"&&o.length>0&&n.length>p)throw new Error("Resize requires only of scales or sizes to be specified")},nc=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: ${t}, xScale: ${t}, lengthResized: ${t},\n     lengthOriginal: ${t}, roiStart: ${t}, roiEnd: ${t}) -> ${t} { `+(()=>{switch(e){case"asymmetric":return"return xResized / xScale;";case"pytorch_half_pixel":return"if (lengthResized > 1) {                     return (xResized + 0.5) / xScale - 0.5;                   } else {                     return 0.0;                   }";case"tf_half_pixel_for_nn":return"return (xResized + 0.5) / xScale;";case"align_corners":return"if (lengthResized == 1) {                     return 0.0;                   } else {                     return xResized * (lengthOriginal - 1) / (lengthResized - 1);                   }";case"tf_crop_and_resize":return`if (lengthResized > 1) {                     return roiStart * (lengthOriginal - 1) +                           (xResized * (roiEnd - roiStart) * (lengthOriginal - 1)) / (lengthResized - 1);                   } else {                     return 0.5 * (roiStart + roiEnd) * ${t}(lengthOriginal - 1);                   }`;case"half_pixel_symmetric":return["const outputWidth = xScale * lengthResized;","const adjustment = lengthResized / outputWidth;","const center = lengthOriginal / 2;","const offset = center * (1 - adjustment);","return offset + ((xResized + 0.5) / xScale) - 0.5;"].join(`\n`);case"half_pixel":return"return ((xResized + 0.5) / xScale) - 0.5;";default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",oc=(e,t,r)=>`fn getNearestPixelFromOriginal(xOriginal: ${r}, isDownSample: bool) -> ${r} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",ac=(e,t,r)=>{let o=new Array(r).fill(0).concat(new Array(r).fill(1)),n=e.length===0?o:e.slice();return t.length>0?(t.forEach((s,u)=>{o[s]=n[u],o[u+r]=n[t.length+u]}),o):n},ic=(e,t,r,o)=>{let n=[];if(r.length>0)if(o.length>0){if(e.forEach(s=>n.push(s)),Math.max(...o)>e.length)throw new Error("axes is out of bound");o.forEach((s,u)=>n[s]=r[u])}else r.forEach(s=>n.push(s));else{if(t.length===0)throw new Error("Resize requires either scales or sizes.");n=e.map((s,u)=>Math.round(s*t[u]))}return n},sc=(e,t,r)=>{let o=(()=>{switch(r.keepAspectRatioPolicy){case"not_larger":return r.axes.length>0?Math.min(...r.axes.map(s=>t[s]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case"not_smaller":return r.axes.length>0?Math.max(...r.axes.map(s=>t[s]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${r.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let n=e.slice();return r.axes.length>0?(r.axes.forEach(s=>t[s]=o),r.axes.forEach(s=>n[s]=Math.round(e[s]*t[s]))):(t.fill(o,0,t.length),n.forEach((s,u)=>n[u]=Math.round(s*t[u]))),n},uc=(e,t,r,o,n)=>`\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${r.length}> {\n      var original_indices: array<${e.type.value}, ${r.length}>;\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var output_index = ${e.type.value}(${e.indicesGet("output_indices","i")});\n        var scale = ${Ie("uniforms.scales","i",o)};\n        var roi_low = ${Ie("uniforms.roi","i",n)};\n        var roi_hi = ${Ie("uniforms.roi",`i + ${t.length}`,n)};\n        if (scale == 1.0) {\n          original_indices[i] = output_index;\n        } else {\n          var input_shape_i = ${e.type.value}(${Ie("uniforms.input_shape","i",t.length)});\n          var output_shape_i = ${e.type.value}(${Ie("uniforms.output_shape","i",r.length)});\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                           input_shape_i, roi_low, roi_hi);\n        }\n      }\n      return original_indices;\n    }`,lc=(e,t,r,o,n,s,u)=>`\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n      var input_indices: ${e.type.indices};\n      for (var i:u32 = 0; i < ${o.length}; i++) {\n        var output_index = ${t.type.value}(${t.indicesGet("output_indices","i")});\n        var input_index: u32;\n        var scale = ${Ie("uniforms.scales","i",n)};\n        if (scale == 1.0) {\n          input_index = u32(output_index);\n        } else {\n          var roi_low = ${Ie("uniforms.roi","i",s)};\n          var roi_hi = ${Ie("uniforms.roi",`i + ${r.length}`,s)};\n          var input_shape_i = ${t.type.value}(${Ie("uniforms.input_shape","i",r.length)});\n          var output_shape_i = ${t.type.value}(${Ie("uniforms.output_shape","i",o.length)});\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                        input_shape_i, roi_low, roi_hi);\n          if (!${u} || (original_idx >= 0 && original_idx < input_shape_i)) {\n            if (original_idx < 0) {\n              input_index = 0;\n            } else if (original_idx > (input_shape_i - 1)) {\n              input_index = u32(input_shape_i) - 1;\n            } else {\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\n            }\n          } else {\n            input_index = u32(original_idx);\n          }\n        }\n        ${e.indicesSet("input_indices","i"," input_index")}\n      }\n      return input_indices;\n    }`,dc=(e,t)=>`\n    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var input_index = ${e.indicesGet("input_indices","i")};\n        if (input_index < 0 || input_index >= ${Ie("uniforms.input_shape","i",t.length)}) {\n          return false;\n        }\n      }\n      return true;\n    }`,cc=(e,t,r,o,n,s)=>{let[u,d,a,p]=r.length===2?[-1,0,1,-1]:o[1]===1?[0,2,3,1]:[0,1,2,3],h=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${h} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet("input_indices",d,`max(0, min(row, ${r[d]} - 1))`)};\n      ${e.indicesSet("input_indices",a,`max(0, min(col, ${r[a]} - 1))`)};\n      if (${r.length} > 2) {\n        ${e.indicesSet("input_indices",p,"channel")};\n        ${e.indicesSet("input_indices",u,"batch")};\n      };\n      return ${e.getByIndices("input_indices")};\n    }\n\n    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${h} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var row:${h} = originalIndices[${d}];\n      var col:${h} = originalIndices[${a}];\n      if (${n} && (row < 0 || row > (${r[d]} - 1) || col < 0 || col > ${r[a]} - 1)) {\n        return ${s};\n      }\n      row = max(0, min(row, ${r[d]} - 1));\n      col = max(0, min(col, ${r[a]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = 0;\n      var batch: u32 = 0;\n      if (${r.length>2}) {\n        channel = u32(originalIndices[${p}]);\n        batch = u32(originalIndices[${u}]);\n      }\n      var x11: ${h} = getInputValue(batch, channel, row1, col1);\n      var x12: ${h} = getInputValue(batch, channel, row1, col2);\n      var x21: ${h} = getInputValue(batch, channel, row2, col1);\n      var x22: ${h} = getInputValue(batch, channel, row2, col2);\n      var dx1: ${h} = row - ${h}(row1);\n      var dx2: ${h} = ${h}(row2) - row;\n      var dy1 = col - ${h}(col1);\n      var dy2 = ${h}(col2) - col;\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},pc=(e,t,r,o,n,s,u,d,a,p)=>{let[h,v]=r.length===2?[0,1]:n[1]===1?[2,3]:[1,2],g=e.type.value,w=y=>{let x=y===h?"row":"col";return`\n      fn ${x}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${g} {\n        var output_index = ${t.indicesGet("output_indices",y)};\n        var originalIdx: ${g} = getOriginalCoordinateFromResizedCoordinate(${g}(output_index), ${n[y]},\n        ${g}(${o[y]}), ${g}(${r[y]}), ${s[y]}, ${s[y]} + ${r.length});\n        var fractOriginalIdx: ${g} = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${d} && (originalIdx < 0 || originalIdx > (${r[y]} - 1))) {\n          return ${a};\n        }\n        var data: array<${g}, 4> = array<${g}, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${x}: ${g} = originalIdx + ${g}(i);\n          if (${x} < 0 || ${x} >= ${r[y]}) {\n            if (${p}) {\n              coefs[i + 1] = 0.0;\n              continue;\n            } else if (${d}) {\n              return ${a};\n            } else {\n              ${x} = max(0, min(${x}, ${r[y]} - 1));\n            }\n          }\n          var input_indices_copy: ${e.type.indices} = input_indices;\n          ${e.indicesSet("input_indices_copy",y,`u32(${x})`)};\n          data[i + 1] = ${y===h?e.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${w(h)};\n    ${w(v)};\n  fn getCubicInterpolationCoefs(s: ${g}) -> array<${g}, 4> {\n    var absS = abs(s);\n    var coeffs: array<${g}, 4> = array<${g}, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: ${g} = 1.0 - absS;\n    var twoMinusAbsS: ${g} = 2.0 - absS;\n    var onePlusAbsS: ${g} = 1.0 + absS;\n    coeffs[0] = ((${u} * onePlusAbsS - 5 * ${u}) * onePlusAbsS + 8 * ${u}) * onePlusAbsS - 4 * ${u};\n    coeffs[1] = ((${u} + 2) * absS - (${u} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${u} + 2) * oneMinusAbsS - (${u} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${u} * twoMinusAbsS - 5 * ${u}) * twoMinusAbsS + 8 * ${u}) * twoMinusAbsS - 4 * ${u};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<${g}, 4>, coefs: array<${g}, 4>) -> ${g} {\n    var coefsSum: ${g} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${g} {\n    var input_indices: ${e.type.indices} = output_indices;\n    return colCubicInterpolation(input_indices, output_indices);\n  }\n    `},mc=(e,t,r,o,n,s)=>{let u=e.dims,d=ac(s,t.axes,u.length),a=ic(u,o,n,t.axes),p=o.slice();o.length===0&&(p=u.map(($,_)=>$===0?1:a[_]/$),t.keepAspectRatioPolicy!=="stretch"&&(a=sc(u,p,t)));let h=K("output",e.dataType,a.length),v=V("input",e.dataType,u.length),g=D.size(a),w=u.length===a.length&&u.every(($,_)=>$===a[_]),y=t.coordinateTransformMode==="tf_crop_and_resize",x=v.type.value,A=$=>`\n      ${w?"":`\n      ${nc(t.coordinateTransformMode,x)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${dc(v,u)};\n              ${oc(t.nearestMode,r,x)};\n              ${lc(v,h,u,a,p.length,d.length,y)};\n              `;case"linear":return`\n              ${uc(h,u,a,p.length,d.length)};\n              ${cc(v,h,u,p,y,t.extrapolationValue)};\n              `;case"cubic":return`\n            ${pc(v,h,u,a,p,d,t.cubicCoeffA,y,t.extrapolationValue,t.excludeOutside)};\n            `;default:throw Error("Invalid resize mode")}})()};\n      `}\n      ${$.registerUniform("output_size","u32").registerUniform("scales","f32",p.length).registerUniform("roi","f32",d.length).declareVariables(v,h)}\n      ${$.mainStart()}\n        ${$.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n        ${w?"output[global_idx] = input[global_idx];":`\n        let output_indices = ${h.offsetToIndices("global_idx")};\n        var input_indices: ${v.type.indices};\n        ${(()=>{switch(t.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);\n                if (checkInputIndices(input_indices)) {\n                  output[global_idx] = ${v.getByIndices("input_indices")};\n                } else {\n                  output[global_idx] = ${t.extrapolationValue};\n                }`;case"linear":return"output[global_idx] = bilinearInterpolation(output_indices);";case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n        `}\n      }`;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${p.length>0?p:""}|${n.length>0?n:""}|${d.length>0?d:""}|${w}`,inputDependencies:["rank"]},getShaderSource:A,getRunData:()=>({outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:[{type:"uint32",data:g},{type:"float32",data:p},{type:"float32",data:d},...j(u),...j(a)]})}},fc=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},Fs=(e,t)=>{let r=[],o=[],n=[],s=fc(e);rc(e.inputs,t,s,r,o,n),e.compute(mc(e.inputs[0],t,s,r,o,n),{inputs:[0]})},qs=e=>{let t=e.antialias,r=e.axes,o=e.coordinateTransformMode,n=e.cubicCoeffA,s=e.excludeOutside!==0,u=e.extrapolationValue,d=e.keepAspectRatioPolicy,a=e.mode,p=e.nearestMode===""?"simple":e.nearestMode;return ie({antialias:t,axes:r,coordinateTransformMode:o,cubicCoeffA:n,excludeOutside:s,extrapolationValue:u,keepAspectRatioPolicy:d,mode:a,nearestMode:p})}});var hc,gc,Ks,Ys,Zs=Y(()=>{"use strict";Ue();$e();Re();be();hc=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],r=e[1],o=e[2];if(t.dataType!==r.dataType||t.dataType!==o.dataType)throw new Error("All inputs must have the same data type");if(t.dims.length!==3&&t.dims.length!==2)throw new Error("Input must be 2D or 3D");if(r.dims.length!==3&&r.dims.length!==2)throw new Error("Skip must be 2D or 3D");let n=t.dims[t.dims.length-1],s=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==n)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==s)throw new Error("Skip must have the same sequence length as input");if(o.dims.length!==1)throw new Error("Gamma must be 1D");if(o.dims[o.dims.length-1]!==n)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let u=e[3];if(u.dims.length!==1)throw new Error("Beta must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let u=e[4];if(u.dims.length!==1)throw new Error("Bias must be 1D");if(u.dims[u.dims.length-1]!==n)throw new Error("Bias must have the same hidden size as input")}},gc=(e,t,r,o)=>{let n=e[0].dims,s=D.size(n),u=n,d=s,a=n.slice(-1)[0],p=o?n.slice(0,-1).concat(1):[],h=e.length>3,v=e.length>4,g=o&&r>1,w=o&&r>2,y=r>3,x=Ne(a),A=[V("x",e[0].dataType,e[0].dims,x),V("skip",e[1].dataType,e[1].dims,x),V("gamma",e[2].dataType,e[2].dims,x)];h&&A.push(V("beta",e[3].dataType,e[3].dims,x)),v&&A.push(V("bias",e[4].dataType,e[4].dims,x)),A.push(K("output",e[0].dataType,u,x)),g&&A.push(K("meanOutput",1,p)),w&&A.push(K("invStdOutput",1,p)),y&&A.push(K("inputSkipBiasSum",e[0].dataType,u,x));let $=Oe(e[0].dataType),_=I=>`\n      const hiddenSize: f32 = ${a};\n      const hiddenSizeVectorized: u32 = ${a/x};\n      const epsilon: f32 = ${t.epsilon};\n\n      ${I.declareVariables(...A)}\n\n      ${I.mainStart()}\n        ${I.guardAgainstOutOfBoundsWorkgroupSizes(d/a)}\n        let offset = global_idx * hiddenSizeVectorized;\n        var sum = ${je("f32",x)};\n        var squareSum = ${je("f32",x)};\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          let skipValue = skip[offset + i];\n          let biasValue = ${v?"bias[i]":"0.0"};\n          let inputValue = x[offset + i];\n          let value = inputValue + skipValue + biasValue;\n          ${y?"inputSkipBiasSum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32Value = ${tt($,x,"value")};\n          sum += f32Value;\n          squareSum += f32Value * f32Value;\n        }\n        let mean = ${Xe("sum",x)} / hiddenSize;\n        let variance = sqrt(${Xe("squareSum",x)} / hiddenSize - mean * mean + epsilon);\n        ${g?"meanOutput[global_idx] = mean;":""}\n        ${w?"invStdOutput[global_idx] = 1.0 / variance;":""}\n        for (var i: u32 = 0; i < hiddenSizeVectorized; i++) {\n          output[offset + i] = (output[offset + i] - ${$}(mean)) / ${$}(variance) * gamma[i]\n           + ${h?"beta[i]":"0.0"};\n        }\n      }`,R=[{dims:u,dataType:e[0].dataType}];return r>1&&R.push({dims:p,dataType:1}),r>2&&R.push({dims:p,dataType:1}),r>3&&R.push({dims:n,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:t.cacheKey},getShaderSource:_,getRunData:()=>({outputs:R,dispatchGroup:{x:Math.ceil(d/a/64)}})}},Ks=(e,t)=>{hc(e.inputs);let o=[0];e.outputCount>1&&o.push(-3),e.outputCount>2&&o.push(-3),e.outputCount>3&&o.push(3),e.compute(gc(e.inputs,t,e.outputCount,!1),{outputs:o})},Ys=e=>{let t=e.epsilon;return ie({epsilon:t})}});var yc,nn,bc,Xs,wc,vc,Js,Qs,eu=Y(()=>{"use strict";Ue();$e();Re();be();yc=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((r,o)=>{if(e[o+1].dataType!==6&&e[o+1].dataType!==7)throw new Error(`Input ${o} must be an array of int32 or int64`)})},nn=(e,t)=>{let r=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(o=>r.push(Number(o)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(o=>r.push(Number(o)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return r},bc=(e,t)=>{if(e.length>1){let r=nn(e,1),o=nn(e,2),n=nn(e,3);return n.length===0&&(n=[...Array(e[0].dims.length).keys()]),ie({starts:r,ends:o,axes:n})}else return t},Xs=(e,t,r,o,n)=>{let s=e;return e<0&&(s+=r[o[t]]),n[t]<0?Math.max(0,Math.min(s,r[o[t]]-1)):Math.max(0,Math.min(s,r[o[t]]))},wc=(e,t,r)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n          var input_indices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${r.length}; i >= 0; i--) {\n            let input_shape_i = ${Ie("uniforms.input_shape","i",r.length)};\n            let steps_i = ${Ie("uniforms.steps","i",r.length)};\n            let signs_i = ${Ie("uniforms.signs","i",r.length)};\n            let starts_i = ${Ie("uniforms.starts","i",r.length)};\n            var output_index = ${t.indicesGet("output_indices","i")};\n            var input_index = output_index * steps_i + starts_i + carry;\n            carry = input_index / input_shape_i;\n            input_index = input_index % input_shape_i;\n            if (signs_i < 0) {\n              input_index = input_shape_i - input_index - 1u + starts_i;\n            }\n            ${e.indicesSet("input_indices","i","input_index")};\n          }\n          return input_indices;\n      }`,vc=(e,t)=>{let r=e[0].dims,o=D.size(r),n=t.axes.length>0?D.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],s=nn(e,4);s.forEach($=>$!==0||(()=>{throw new Error("step cannot be 0")})),s.length===0&&(s=Array(n.length).fill(1));let u=t.starts.map(($,_)=>Xs($,_,r,n,s)),d=t.ends.map(($,_)=>Xs($,_,r,n,s));if(n.length!==u.length||n.length!==d.length)throw new Error("start, ends and axes should have the same number of elements");if(n.length!==r.length)for(let $=0;$<r.length;++$)n.includes($)||(u.splice($,0,0),d.splice($,0,r[$]),s.splice($,0,1));let a=s.map($=>Math.sign($));s.forEach(($,_,R)=>{if($<0){let I=(d[_]-u[_])/$,z=u[_],T=z+I*s[_];u[_]=T,d[_]=z,R[_]=-$}});let p=r.slice(0);n.forEach(($,_)=>{p[$]=Math.ceil((d[$]-u[$])/s[$])});let h={dims:p,dataType:e[0].dataType},v=K("output",e[0].dataType,p.length),g=V("input",e[0].dataType,e[0].dims.length),w=D.size(p),y=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:u.length},{name:"signs",type:"i32",length:a.length},{name:"steps",type:"u32",length:s.length}],x=[{type:"uint32",data:w},{type:"uint32",data:u},{type:"int32",data:a},{type:"uint32",data:s},...j(e[0].dims),...j(p)],A=$=>`\n      ${$.registerUniforms(y).declareVariables(g,v)}\n        ${wc(g,v,r)}\n        ${$.mainStart()}\n          ${$.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n          let output_indices = ${v.offsetToIndices("global_idx")};\n          let input_indices = calculateInputIndices(output_indices);\n          ${v.setByOffset("global_idx",g.getByIndices("input_indices"))}\n      }`;return{name:"Slice",shaderCache:{hint:`${a.length}_${u.length}_${s.length}`,inputDependencies:["rank"]},getShaderSource:A,getRunData:()=>({outputs:[h],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:x})}},Js=(e,t)=>{yc(e.inputs,t);let r=bc(e.inputs,t);e.compute(vc(e.inputs,r),{inputs:[0]})},Qs=e=>{let t=e.starts,r=e.ends,o=e.axes;return ie({starts:t,ends:r,axes:o})}});var $c,Sc,tu,ru,nu=Y(()=>{"use strict";$e();Re();be();$c=e=>{if(!e||e.length!==1)throw new Error("Softmax op requires 1 input.")},Sc=(e,t)=>{let r=e.dims,o=D.size(r),n=64,s=t.axis;if(s<0&&(s=r.length+s),s<r.length-1)throw new Error("softmax only supports last axis for now.");let u=r[s],d=o/u,a=Ne(u),p=u/a,h=(A,$)=>$===4?`max(max(${A}.x, ${A}.y), max(${A}.z, ${A}.w))`:$===2?`max(${A}.x, ${A}.y)`:$===3?`max(max(${A}.x, ${A}.y), ${A}.z)`:A,v=V("x",e.dataType,e.dims,a),g=K("result",e.dataType,e.dims,a),w=v.type.value,y=Oe(e.dataType)==="f32"?`var threadMax = ${w}(-3.402823e+38f);`:`var threadMax = ${w}(-65504.0h);`,x=A=>`\n      var<workgroup> rowMaxShared : ${w};\n      var<workgroup> rowSumShared : ${w};\n      var<workgroup> threadShared : array<${w}, ${n}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${w} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${w}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${A.registerUniform("packedCols","i32").declareVariables(v,g)}\n      ${A.mainStart()}\n        let gindex = i32(global_idx);\n        let lindex = i32(local_idx);\n        const wg = ${n};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${y}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${w}(${h("threadShared[0]",a)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${w}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${w}(${Xe("threadShared[0]",a)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`;return{name:"Softmax",shaderCache:{hint:`${a}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:r,dataType:e.dataType}],dispatchGroup:{x:d},programUniforms:[{type:"uint32",data:p}]}),getShaderSource:x}},tu=(e,t)=>{$c(e.inputs),e.compute(Sc(e.inputs[0],t))},ru=e=>ie({axis:e.axis})});var xc,Cc,_c,Ac,Ic,ou,au,iu=Y(()=>{"use strict";$e();Re();be();xc=e=>{if(!e||e.length<1)throw new Error("too few inputs")},Cc=(e,t)=>{let r=[],o=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(n=>r.push(Number(n))),o=r.length),ie({numOutputs:o,axis:t.axis,splitSizes:r})},_c=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < ${Ie("uniforms.size_in_split_axis","i",e)}) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,Ac=e=>{let t=e.length,r=[];for(let o=0;o<t;++o){let n=e[o].setByIndices("indices","input[global_idx]");t===1?r.push(n):o===0?r.push(`if (output_number == ${o}u) { ${n} }`):o===t-1?r.push(`else { ${n} }`):r.push(`else if (output_number == ${o}) { ${n} }`)}return`\n      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${r.join(`\n`)}\n      }`},Ic=(e,t)=>{let r=e[0].dims,o=D.size(r),n=e[0].dataType,s=D.normalizeAxis(t.axis,r.length),u=new Array(t.numOutputs),d=V("input",n,r),a=new Array(t.numOutputs),p=[],h=[],v=0,g=[{type:"uint32",data:o}];for(let y=0;y<t.numOutputs;y++){v+=t.splitSizes[y],a[y]=v;let x=r.slice();x[t.axis]=t.splitSizes[y],h.push(x),u[y]=K(`output${y}`,n,x),p.push({dims:h[y],dataType:e[0].dataType})}g.push({type:"uint32",data:a}),g.push(...j(r)),h.forEach(y=>g.push(...j(y)));let w=y=>`\n  ${y.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",a.length).declareVariables(d,...u)}\n  ${_c(a.length)}\n  ${Ac(u)}\n\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}\n\n    var indices = ${d.offsetToIndices("global_idx")};\n    var index = ${d.indicesGet("indices",s)};\n    let output_number = calculateOutputIndex(index);\n    if (output_number != 0) {\n      index -= ${Ie("uniforms.size_in_split_axis","output_number - 1u",a.length)};\n      ${d.indicesSet("indices",s,"index")};\n    }\n    writeBufferData(output_number, indices, global_idx);\n  }`;return{name:"Split",shaderCache:{hint:t.cacheKey,inputDependencies:["rank"]},getShaderSource:w,getRunData:()=>({outputs:p,dispatchGroup:{x:Math.ceil(o/64)},programUniforms:g})}},ou=(e,t)=>{xc(e.inputs);let r=e.inputs.length===1?t:Cc(e.inputs,t);e.compute(Ic(e.inputs,r),{inputs:[0]})},au=e=>{let t=e.axis,r=e.splitSizes,o=e.numOutputs<0?r.length:e.numOutputs;if(o!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return ie({axis:t,numOutputs:o,splitSizes:r})}});var su,Tc,Ec,Oc,uu,lu=Y(()=>{"use strict";Ue();$e();be();su=e=>Array.from(e.getBigInt64Array(),Number),Tc=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 inputs.");if(e[0].dataType!==1&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error("Tile only support float, int32, and uint32 data types");if(e[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(e[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(su(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},Ec=(e,t)=>{let r=[];for(let o=0;o<e.length;++o)r.push(e[o]*t[o]);return r},Oc=e=>{let t=e[0].dims,r=su(e[1]),o=Ec(t,r),n=D.size(o),s=e[0].dataType,u=V("input",s,t.length),d=K("output",s,o.length),a=p=>`\n      const inputShape = ${u.indices(...t)};\n      ${p.registerUniform("output_size","u32").declareVariables(u,d)}\n      ${p.mainStart()}\n      ${p.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n      let output_indices = ${d.offsetToIndices("global_idx")};\n      var input_indices: ${u.type.indices};\n      for (var i = 0; i < ${t.length}; i++) {\n        let input_dim_i = ${u.indicesGet("uniforms.input_shape","i")};\n        let input_dim_value = ${d.indicesGet("output_indices","i")}  % input_dim_i;\n\n        ${u.indicesSet("input_indices","i","input_dim_value")}\n      }\n      ${d.setByOffset("global_idx",u.getByIndices("input_indices"))}\n    }`;return{name:"Tile",shaderCache:{hint:`${r}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)},programUniforms:[{type:"uint32",data:n},...j(e[0].dims),...j(o)]}),getShaderSource:a}},uu=e=>{Tc(e.inputs),e.compute(Oc(e.inputs),{inputs:[0]})}});var kc,Pc,du,cu=Y(()=>{"use strict";Ue();$e();be();kc=(e,t,r,o,n)=>{let s=K("output_data",n,r.length,4),u=V("a_data",t[1].dataType,t[1].dims.length,4),d=V("b_data",t[2].dataType,t[2].dims.length,4),a=V("c_data",t[0].dataType,t[0].dims.length,4),p,h=(v,g,w)=>`select(${g}, ${v}, ${w})`;if(!o)p=s.setByOffset("global_idx",h(u.getByOffset("global_idx"),d.getByOffset("global_idx"),a.getByOffset("global_idx")));else{let v=(g,w,y="")=>{let x=`a_data[index_a${w}][component_a${w}]`,A=`b_data[index_b${w}][component_b${w}]`,$=`bool(c_data[index_c${w}] & ${4278190080>>>(3-w)*8}u)`;return`\n            let output_indices${w} = ${s.offsetToIndices(`global_idx * 4u + ${w}u`)};\n            let offset_a${w} = ${u.broadcastedIndicesToOffset(`output_indices${w}`,s)};\n            let offset_b${w} = ${d.broadcastedIndicesToOffset(`output_indices${w}`,s)};\n            let offset_c${w} = ${a.broadcastedIndicesToOffset(`output_indices${w}`,s)};\n            let index_a${w} = offset_a${w} / 4u;\n            let index_b${w} = offset_b${w} / 4u;\n            let index_c${w} = offset_c${w} / 4u;\n            let component_a${w} = offset_a${w} % 4u;\n            let component_b${w} = offset_b${w} % 4u;\n            ${g}[${w}] = ${y}(${h(x,A,$)});\n          `};n===9?p=`\n            var data = vec4<u32>(0);\n            ${v("data",0,"u32")}\n            ${v("data",1,"u32")}\n            ${v("data",2,"u32")}\n            ${v("data",3,"u32")}\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:p=`\n            ${v("output_data[global_idx]",0)}\n            ${v("output_data[global_idx]",1)}\n            ${v("output_data[global_idx]",2)}\n            ${v("output_data[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables(a,u,d,s)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${p}\n      }`},Pc=e=>{let t=e[1].dims,r=e[2].dims,o=e[0].dims,n=e[1].dataType,s=!(D.areEqual(t,r)&&D.areEqual(r,o)),u=t,d=D.size(t),a=Math.ceil(d/4);if(s){let p=it.calcShape(it.calcShape(t,r,!1),o,!1);if(!p)throw new Error("Can\'t perform where op on the given tensors");u=p,d=D.size(u)}return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:p=>kc(p,e,u,s,n),getRunData:()=>({outputs:[{dims:u,dataType:n}],dispatchGroup:{x:Math.ceil(d/64/4)},programUniforms:[{type:"uint32",data:a},...j(o),...j(t),...j(r),...j(u)]})}},du=e=>{e.compute(Pc(e.inputs))}});var pu,mu=Y(()=>{"use strict";ya();Rn();za();Ua();bi();Ei();Pi();Un();qi();Yi();es();ns();is();ls();ps();hs();bs();Nn();Ss();_s();Hs();Ls();Nr();js();Zs();eu();nu();iu();lu();Nt();Mn();cu();pu=new Map([["Abs",[Wa]],["Acos",[Na]],["Acosh",[Ha]],["Add",[wi]],["ArgMax",[ga,Pn]],["ArgMin",[ha,Pn]],["Asin",[Ga]],["Asinh",[La]],["Atan",[Fa]],["Atanh",[qa]],["Attention",[wa,ba]],["AveragePool",[Rs,Ps]],["BatchNormalization",[Da]],["BiasAdd",[Va]],["BiasSplitGelu",[yi]],["Cast",[Ka,ja]],["Ceil",[Za]],["Clip",[Ya]],["Concat",[Oi,ki]],["Conv",[Gn,Hn]],["ConvTranspose",[Fi,Li]],["Cos",[Xa]],["Cosh",[Ja]],["CumSum",[ji,Ki]],["Div",[vi]],["Einsum",[Ji,Qi]],["Elu",[Qa,Kr]],["Equal",[$i]],["Erf",[ei]],["Exp",[ti]],["Expand",[rs]],["Floor",[ri]],["FusedConv",[Gn,Hn]],["Gather",[as,os]],["GatherElements",[us,ss]],["Gelu",[ni]],["Gemm",[ds,cs]],["GlobalAveragePool",[Ds,Ms]],["GlobalMaxPool",[Ns,Ws]],["Greater",[_i]],["GreaterOrEqual",[Ii]],["InstanceNormalization",[fs,ms]],["LayerNormalization",[ys,gs]],["LeakyRelu",[oi,Kr]],["Less",[Ai]],["LessOrEqual",[Ti]],["Log",[gi]],["MatMul",[zi]],["MaxPool",[Vs,Us]],["Mul",[Si]],["MultiHeadAttention",[$s,vs]],["Neg",[ii]],["Not",[ai]],["Pad",[xs,Cs]],["Pow",[xi]],["Range",[Gs]],["Reciprocal",[si]],["ReduceMin",[la]],["ReduceMean",[oa]],["ReduceMax",[ua]],["ReduceSum",[ca]],["ReduceProd",[da]],["ReduceL1",[aa]],["ReduceL2",[ia]],["ReduceLogSum",[ma]],["ReduceLogSumExp",[sa]],["ReduceSumSquare",[pa]],["Relu",[ui]],["Resize",[Fs,qs]],["Sigmoid",[li]],["Sin",[di]],["Sinh",[ci]],["Slice",[Js,Qs]],["SkipLayerNormalization",[Ks,Ys]],["Split",[ou,au]],["Sqrt",[pi]],["Softmax",[tu,ru]],["Sub",[Ci]],["Tan",[mi]],["Tanh",[fi]],["ThresholdedRelu",[hi,Kr]],["Tile",[uu]],["Transpose",[Fo,qo]],["Where",[du]]])});var on,fu=Y(()=>{"use strict";Ue();vt();be();on=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,r){this.repo.set(t,r)}run(t,r,o,n,s,u,d){let a=this.backend.device,p=this.backend.getComputePassEncoder();p.setPipeline(t.computePipeline);let h=[];for(let g of n)h.push({binding:h.length,resource:{buffer:g.buffer}});for(let g of s)h.push({binding:h.length,resource:{buffer:g.buffer}});d&&h.push({binding:h.length,resource:d});let v=a.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:h,label:t.programInfo.name});if(p.setBindGroup(0,v),p.dispatchWorkgroups(...u),this.backend.pendingDispatchNumber++,this.backend.isQueryEnabled()){typeof this.backend.queryData>"u"&&(this.backend.queryData=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE));let g=this.backend.gpuDataManager.create(this.backend.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.querySet,0,2,this.backend.queryData.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(this.backend.queryData.buffer,0,g.buffer,0,this.backend.querySetCount*8),this.backend.flush();let w=this.backend.currentKernelId,y=this.backend.kernels.get(w);g.buffer.mapAsync(GPUMapMode.READ).then(()=>{let x=new BigUint64Array(g.buffer.getMappedRange()),[A,$]=x,[_,R]=y;g.buffer.unmap(),typeof this.backend.queryTimeBase>"u"&&(this.backend.queryTimeBase=A);let I=Number(A-this.backend.queryTimeBase),z=Number($-this.backend.queryTimeBase);if(!Number.isSafeInteger(I)||!Number.isSafeInteger(z))throw new RangeError("incorrect timestamp range");if(this.backend.gpuDataManager.release(g.id),this.backend.env.webgpu.profiling?.ondata)this.backend.env.webgpu.profiling.ondata({version:1,inputsMetadata:r.map(T=>({dims:T.dims,dataType:Ot(T.dataType)})),outputsMetadata:o.map(T=>({dims:T.dims,dataType:Ot(T.dataType)})),kernelId:w,kernelType:_,kernelName:R,startTime:I,endTime:z});else{let T="";r.forEach((U,G)=>{T+=`input[${G}]: [${U.dims}] | ${Ot(U.dataType)}, `});let N="";o.forEach((U,G)=>{N+=`output[${G}]: [${U.dims}] | ${Ot(U.dataType)}, `}),console.log(`[profiling] kernel "${w}|${R}|${t.programInfo.name}" ${T}${N}execution time: ${z-I} ns`)}})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(t,r){let o=this.backend.device,n=[];o.features.has("shader-f16")&&n.push("enable f16;");let s=Go(r),u=t.getShaderSource(s),d=`${n.join(`\n`)}\n${s.additionalImplementations}\n${u}`,a=o.createShaderModule({code:d,label:t.name});Pe("verbose",()=>`[WebGPU] ${t.name} shader code: ${d}`);let p=o.createComputePipeline({compute:{module:a,entryPoint:"main"},layout:"auto",label:t.name});return{programInfo:t,computePipeline:p}}normalizeDispatchGroupSize(t){let r=typeof t=="number"?t:t.x,o=typeof t=="number"?1:t.y||1,n=typeof t=="number"?1:t.z||1,s=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(r<=s&&o<=s&&n<=s)return[r,o,n];let u=r*o*n,d=Math.ceil(Math.sqrt(u));if(d>s){if(d=Math.ceil(Math.cbrt(u)),d>s)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[d,d,d]}else return[d,d,1]}}});var Rc,Bc,an,hu=Y(()=>{"use strict";vt();Vo();Ho();mu();fu();Rc=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let o=0;o<e.length;++o){let n=e[o].dataType;switch(t[o]){case"none":{r.push("");break}case"type":{r.push(`${n}`);break}case"rank":{let s=e[o].dims.length;r.push(`${n};${s}`);break}case"dims":{let s=e[o].dims.join(",");r.push(`${n};${s}`);break}default:throw new Error(`unsupported input dependency: ${t[o]}`)}}return r.join("|")},Bc=(e,t,r)=>{let o=e.name;return e.shaderCache?.hint&&(o+="["+e.shaderCache.hint+"]"),o+=":"+r+`:${Rc(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,o},an=class{constructor(){this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.pendingDispatchNumber=0;this.querySetCount=2;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t,r){this.env=t;let o=[],n={requiredLimits:{maxComputeWorkgroupStorageSize:r.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.limits.maxStorageBufferBindingSize,maxBufferSize:r.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:r.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:r.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:r.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:r.limits.maxComputeWorkgroupSizeZ},requiredFeatures:o};r.features.has("timestamp-query")&&o.push("timestamp-query"),r.features.has("shader-f16")&&o.push("shader-f16"),this.device=await r.requestDevice(n),this.gpuDataManager=No(this),this.programManager=new on(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Do(t.logLevel,!!t.debug),this.device.onuncapturederror=s=>{s.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${s.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device})}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t={};this.isQueryEnabled()&&(typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1}),this.computePassEncoder=this.getCommandEncoder().beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.commandEncoder&&(this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0)}isQueryEnabled(){return this.device.features.has("timestamp-query")&&(this.env.webgpu.profiling?.mode==="default"||!this.env.webgpu.profiling?.mode&&this.env.webgpu.profilingMode==="default")}run(t,r,o,n,s){let u=[];for(let _=0;_<r.length;++_){let R=this.gpuDataManager.get(r[_].data);if(!R)throw new Error(`no GPU data for input: ${r[_].data}`);u[_]=R}let{outputs:d,dispatchGroup:a,programUniforms:p}=t.getRunData(r),h=o.length===0?d.map((_,R)=>R):o;if(h.length!==d.length)throw new Error(`Output size ${h.length} must be equal to ${d.length}.`);let v=[],g=[];for(let _=0;_<d.length;++_){if(!Number.isInteger(h[_])||h[_]<-3||h[_]>=d.length)throw new Error(`Invalid output index: ${h[_]}`);if(h[_]===-3)continue;let R=h[_]===-1,I=h[_]===-2,z=R||I?s(d[_].dataType,d[_].dims):n(h[_],d[_].dataType,d[_].dims),T=this.gpuDataManager.get(z.data);if(!T)throw new Error(`no GPU data for output: ${z.data}`);if(R&&this.temporaryData.push(T),I){let N=this.kernelPersistentData.get(this.currentKernelId);N||(N=[],this.kernelPersistentData.set(this.currentKernelId,N)),N.push(T)}v.push(z),g.push(T)}let w;if(p){let _=0,R=[];p.forEach(N=>{let U=typeof N.data=="number"?[N.data]:N.data;if(U.length===0)return;let G=U.length<=2?U.length*4:16;_=Math.ceil(_/G)*G,R.push(_),_+=U.length>4?Math.ceil(U.length/4)*16:U.length*4});let I=16;_=Math.ceil(_/I)*I;let z=new ArrayBuffer(_);p.forEach((N,U)=>{let G=R[U],J=typeof N.data=="number"?[N.data]:N.data;N.type==="int32"?new Int32Array(z,G,J.length).set(J):N.type==="uint32"?new Uint32Array(z,G,J.length).set(J):new Float32Array(z,G,J.length).set(J)});let T=this.gpuDataManager.create(_,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(T.buffer,0,z,0,_),this.gpuDataManager.release(T.id),w={offset:0,size:_,buffer:T.buffer}}let y=this.programManager.normalizeDispatchGroupSize(a),x=y[1]===1&&y[2]===1,A=Bc(t,r,x),$=this.programManager.getArtifact(A);return $||($=this.programManager.build(t,y),this.programManager.setArtifact(A,$),Pe("info",()=>`[artifact] key: ${A}, programName: ${t.name}`)),Pe("info",()=>`[ProgramManager] run "${t.name}" (key=${A}) with ${y[0]}x${y[1]}x${y[2]}`),this.programManager.run($,r,v,u,g,y,w),v}upload(t,r){this.gpuDataManager.upload(t,r)}memcpy(t,r){this.gpuDataManager.memcpy(t,r)}async download(t,r){await this.gpuDataManager.download(t,r)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,r,o,n){let s=pu.get(t);if(!s)throw new Error(`kernel not implemented: ${t}`);this.kernels.set(r,[t,n,s[0],[s[1],o]])}releaseKernel(t){let r=this.kernelPersistentData.get(t);if(r){for(let o of r)this.gpuDataManager.release(o.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,r,o){let n=this.kernels.get(t);if(!n)throw new Error(`kernel not created: ${t}`);let[s,u,d,a]=n;if(this.currentKernelId!==null)throw new Error(`kernel "[${s}] ${u}" is not allowed to be called recursively`);this.currentKernelId=t,a[0]&&(a[1]=a[0](a[1]),a[0]=void 0),Pe("info",()=>`[WebGPU] Start to run kernel "[${s}] ${u}"...`);let p=this.env.debug;this.temporaryData=[];try{return p&&this.device.pushErrorScope("validation"),d(r,a[1]),0}catch(h){return o.push(Promise.resolve(`[WebGPU] Kernel "[${s}] ${u}" failed. ${h}`)),1}finally{p&&o.push(this.device.popErrorScope().then(h=>h?`GPU validation error for kernel "[${s}] ${u}": ${h.message}`:null));for(let h of this.temporaryData)this.gpuDataManager.release(h.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,r,o,n){let s=this.sessionExternalDataMapping.get(t);s||(s=new Map,this.sessionExternalDataMapping.set(t,s));let u=s.get(r),d=this.gpuDataManager.registerExternalBuffer(o,n,u?.[1]);return s.set(r,[d,o]),d}unregisterBuffers(t){let r=this.sessionExternalDataMapping.get(t);r&&(r.forEach(o=>this.gpuDataManager.unregisterExternalBuffer(o[1])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let r=this.gpuDataManager.get(t);if(!r)throw new Error(`no GPU data for buffer: ${t}`);return r.buffer}createDownloader(t,r,o){return async()=>{let n=await _n(this,t,r);return zo(n.buffer,o)}}}});var gu={};Pr(gu,{init:()=>Mc});var mr,Yn,Mc,yu=Y(()=>{"use strict";Ue();hu();vt();$e();mr=class e{constructor(t,r,o,n){this.module=t;this.dataType=r;this.data=o;this.dims=n}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let t=D.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let t=D.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let t=D.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(D.size(t)!==D.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},Yn=class{constructor(t,r,o){this.module=t;this.backend=r;this.customDataOffset=0;this.customDataSize=0;let n=t.HEAPU32,s=o>>2;this.opKernelContext=n[s++];let u=n[s++];this.outputCount=n[s++],this.customDataOffset=n[s++],this.customDataSize=n[s++];let d=[];for(let a=0;a<u;a++){let p=n[s++],h=n[s++],v=n[s++],g=[];for(let w=0;w<v;w++)g.push(n[s++]);d.push(new mr(t,p,h,g))}this.inputs=d}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,r){let o=r?.inputs?.map(d=>typeof d=="number"?this.inputs[d]:d)??this.inputs,n=r?.outputs??[],s=(d,a,p)=>new mr(this.module,a,this.output(d,p),p),u=(d,a)=>{let p=ur(d);if(!p)throw new Error(`Unsupported data type: ${d}`);let h=p*D.size(a);return new mr(this.module,d,this.backend.gpuDataManager.create(h).id,a)};return this.backend.run(t,o,n,s,u)}output(t,r){let o=this.module.stackSave();try{let n=this.module.stackAlloc((1+r.length)*4),s=n>>2;this.module.HEAPU32[s++]=r.length;for(let u=0;u<r.length;u++)this.module.HEAPU32[s++]=r[u];return this.module._JsepOutput(this.opKernelContext,t,n)}catch(n){throw new Error(`Failed to generate kernel\'s output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(o)}}},Mc=async(e,t,r)=>{let o=e.jsepInit;if(!o)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");let n=new an;await n.initialize(t,r),o(n,s=>n.alloc(s),s=>n.free(s),(s,u,d,a=!1)=>{if(a)Pe("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${s}, dst=${u}, size=${d}`),n.memcpy(s,u);else{Pe("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${s}, gpuDataId=${u}, size=${d}`);let p=e.HEAPU8.subarray(s,s+d);n.upload(u,p)}},async(s,u,d)=>{Pe("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${s}, dataOffset=${u}, size=${d}`),await n.download(s,()=>e.HEAPU8.subarray(u,u+d))},(s,u,d)=>n.createKernel(s,u,d,t.debug||n.isQueryEnabled()?e.UTF8ToString(e._JsepGetNodeName(u)):`${u}`),s=>n.releaseKernel(s),(s,u,d,a)=>{Pe("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${d}, kernel=${s}, contextDataOffset=${u}`);let p=new Yn(e,n,u);return n.computeKernel(s,p,a)})}});var Eo;Eo=wo();var ju=Ao(),vn,$n=!1,Rr=!1,To=!1,Ku=()=>{try{return typeof SharedArrayBuffer>"u"?!1:(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}},Yu=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Zu=(e,t)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-simd.wasm":t?"ort-wasm-threaded.wasm":"ort-wasm.wasm",Oo=async e=>{if($n)return Promise.resolve();if(Rr)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(To)throw new Error("previous call to \'initializeWebAssembly()\' failed.");Rr=!0;let t=e.initTimeout,r=e.numThreads,o=e.simd,n=r>1&&Ku(),s=o&&Yu(),u=e.wasmPaths,d=typeof u=="string"?u:void 0,a=Zu(s,n),p=typeof u=="object"?u[a]:void 0,h=!1,v=[];if(t>0&&v.push(new Promise(g=>{setTimeout(()=>{h=!0,g()},t)})),v.push(new Promise((g,w)=>{let y=n?ju:Eo,x={locateFile:(A,$)=>{if(n&&A.endsWith(".worker.js")&&typeof Blob<"u")return URL.createObjectURL(new Blob([Io()],{type:"text/javascript"}));if(A.endsWith(".wasm")){if(p)return p;let _=d??$;return a==="ort-wasm-simd.wasm"?_+"ort-wasm-simd.jsep.wasm":a==="ort-wasm-simd-threaded.wasm"?_+"ort-wasm-simd-threaded.jsep.wasm":_+a}return $+A}};if(n)if(typeof Blob>"u")x.mainScriptUrlOrBlob=(void 0)(__dirname,"ort-wasm-threaded.js");else{let A=`var ortWasmThreaded=${y.toString()};`;x.mainScriptUrlOrBlob=new Blob([A],{type:"text/javascript"})}y(x).then(A=>{Rr=!1,$n=!0,vn=A,g()},A=>{Rr=!1,To=!0,w(A)})})),await Promise.race(v),h)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},De=()=>{if($n&&vn)return vn;throw new Error("WebAssembly is not initialized yet.")};var Ve=(e,t)=>{let r=De(),o=r.lengthBytesUTF8(e)+1,n=r._malloc(o);return r.stringToUTF8(e,n,o),t.push(n),n},sr=(e,t,r,o)=>{if(typeof e=="object"&&e!==null){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([n,s])=>{let u=t?t+n:n;if(typeof s=="object")sr(s,u+".",r,o);else if(typeof s=="string"||typeof s=="number")o(u,s.toString());else if(typeof s=="boolean")o(u,s?"1":"0");else throw new Error(`Can\'t handle extra config type: ${typeof s}`)})},Ee=e=>{let t=De(),r=t.stackSave();try{let o=t.stackAlloc(8);t._OrtGetLastError(o,o+4);let n=t.HEAP32[o/4],s=t.HEAPU32[o/4+1],u=s?t.UTF8ToString(s):"";throw new Error(`${e} ERROR_CODE: ${n}, ERROR_MESSAGE: ${u}`)}finally{t.stackRestore(r)}};var ko=e=>{let t=De(),r=0,o=[],n=e||{};try{if(e?.logSeverityLevel===void 0)n.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)n.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(n.terminate=!1);let s=0;return e?.tag!==void 0&&(s=Ve(e.tag,o)),r=t._OrtCreateRunOptions(n.logSeverityLevel,n.logVerbosityLevel,!!n.terminate,s),r===0&&Ee("Can\'t create run options."),e?.extra!==void 0&&sr(e.extra,"",new WeakSet,(u,d)=>{let a=Ve(u,o),p=Ve(d,o);t._OrtAddRunConfigEntry(r,a,p)!==0&&Ee(`Can\'t set a run config entry: ${u} - ${d}.`)}),[r,o]}catch(s){throw r!==0&&t._OrtReleaseRunOptions(r),o.forEach(u=>t._free(u)),s}};var Xu=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},Ju=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Qu=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(r=>(typeof r=="string"?r:r.name)==="webgpu")&&(e.enableMemPattern=!1)},el=(e,t,r)=>{for(let o of t){let n=typeof o=="string"?o:o.name;switch(n){case"xnnpack":n="XNNPACK";break;case"webnn":if(n="WEBNN",typeof o!="string"){let u=o;if(u?.deviceType){let d=Ve("deviceType",r),a=Ve(u.deviceType,r);De()._OrtAddSessionConfigEntry(e,d,a)!==0&&Ee(`Can\'t set a session config entry: \'deviceType\' - ${u.deviceType}.`)}if(u?.numThreads){let d=u.numThreads;(typeof d!="number"||!Number.isInteger(d)||d<0)&&(d=0);let a=Ve("numThreads",r),p=Ve(d.toString(),r);De()._OrtAddSessionConfigEntry(e,a,p)!==0&&Ee(`Can\'t set a session config entry: \'numThreads\' - ${u.numThreads}.`)}if(u?.powerPreference){let d=Ve("powerPreference",r),a=Ve(u.powerPreference,r);De()._OrtAddSessionConfigEntry(e,d,a)!==0&&Ee(`Can\'t set a session config entry: \'powerPreference\' - ${u.powerPreference}.`)}}break;case"webgpu":if(n="JS",typeof o!="string"){let u=o;if(u?.preferredLayout){if(u.preferredLayout!=="NCHW"&&u.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either \'NCHW\' or \'NHWC\': ${u.preferredLayout}`);let d=Ve("preferredLayout",r),a=Ve(u.preferredLayout,r);De()._OrtAddSessionConfigEntry(e,d,a)!==0&&Ee(`Can\'t set a session config entry: \'preferredLayout\' - ${u.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${n}`)}let s=Ve(n,r);De()._OrtAppendExecutionProvider(e,s)!==0&&Ee(`Can\'t append execution provider: ${n}.`)}},Po=e=>{let t=De(),r=0,o=[],n=e||{};Qu(n);try{let s=Xu(n.graphOptimizationLevel??"all"),u=Ju(n.executionMode??"sequential"),d=typeof n.logId=="string"?Ve(n.logId,o):0,a=n.logSeverityLevel??2;if(!Number.isInteger(a)||a<0||a>4)throw new Error(`log serverity level is not valid: ${a}`);let p=n.logVerbosityLevel??0;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log verbosity level is not valid: ${p}`);let h=typeof n.optimizedModelFilePath=="string"?Ve(n.optimizedModelFilePath,o):0;if(r=t._OrtCreateSessionOptions(s,!!n.enableCpuMemArena,!!n.enableMemPattern,u,!!n.enableProfiling,0,d,a,p,h),r===0&&Ee("Can\'t create session options."),n.executionProviders&&el(r,n.executionProviders,o),n.freeDimensionOverrides)for(let[v,g]of Object.entries(n.freeDimensionOverrides)){if(typeof v!="string")throw new Error(`free dimension override name must be a string: ${v}`);if(typeof g!="number"||!Number.isInteger(g)||g<0)throw new Error(`free dimension override value must be a non-negative integer: ${g}`);let w=Ve(v,o);t._OrtAddFreeDimensionOverride(r,w,g)!==0&&Ee(`Can\'t set a free dimension override: ${v} - ${g}.`)}return n.extra!==void 0&&sr(n.extra,"",new WeakSet,(v,g)=>{let w=Ve(v,o),y=Ve(g,o);t._OrtAddSessionConfigEntry(r,w,y)!==0&&Ee(`Can\'t set a session config entry: ${v} - ${g}.`)}),[r,o]}catch(s){throw r!==0&&t._OrtReleaseSessionOptions(r),o.forEach(u=>t._free(u)),s}};Ue();var Dc=(e,t)=>{De()._OrtInit(e,t)!==0&&Ee("Can\'t initialize onnxruntime.")},wu=async e=>{Dc(e.wasm.numThreads,lr(e.logLevel))},vu=async(e,t)=>{if(t==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let r=await navigator.gpu.requestAdapter();if(!r)throw new Error(\'Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.\');if(!e.wasm.simd)throw new Error("Not supported for WebGPU=ON and SIMD=OFF. Please set `env.wasm.simd` to true when using `webgpu` EP");let o=(yu(),Ut(gu)).init;await o(De(),e,r)}},fr=new Map,zc=e=>{let t=De(),r=t.stackSave();try{let o=t.stackAlloc(8);return t._OrtGetInputOutputCount(e,o,o+4)!==0&&Ee("Can\'t get session input/output count."),[t.HEAP32[o/4],t.HEAP32[o/4+1]]}finally{t.stackRestore(r)}},Zn=e=>{let t=De(),r=t._malloc(e.byteLength);if(r===0)throw new Error(`Can\'t create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},$u=(e,t)=>{let r,o,n=De();Array.isArray(e)?[r,o]=e:e.buffer===n.HEAPU8.buffer?[r,o]=[e.byteOffset,e.byteLength]:[r,o]=Zn(e);let s=0,u=0,d=0,a=[],p=[],h=[];try{[u,a]=Po(t),s=n._OrtCreateSession(r,o,u),s===0&&Ee("Can\'t create a session.");let[v,g]=zc(s),w=[],y=[],x=[];for(let $=0;$<v;$++){let _=n._OrtGetInputName(s,$);_===0&&Ee("Can\'t get an input name."),p.push(_),w.push(n.UTF8ToString(_))}for(let $=0;$<g;$++){let _=n._OrtGetOutputName(s,$);_===0&&Ee("Can\'t get an output name."),h.push(_);let R=n.UTF8ToString(_);y.push(R);{let I=typeof t?.preferredOutputLocation=="string"?t.preferredOutputLocation:t?.preferredOutputLocation?.[R]??"cpu";if(I!=="cpu"&&I!=="cpu-pinned"&&I!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${I}.`);x.push(I)}}let A=null;return x.some($=>$==="gpu-buffer")&&(d=n._OrtCreateBinding(s),d===0&&Ee("Can\'t create IO binding."),A={handle:d,outputPreferredLocations:x,outputPreferredLocationsEncoded:x.map($=>xn($))}),fr.set(s,[s,p,h,A]),[s,w,y]}catch(v){throw p.forEach(g=>n._OrtFree(g)),h.forEach(g=>n._OrtFree(g)),d!==0&&n._OrtReleaseBinding(d),s!==0&&n._OrtReleaseSession(s),v}finally{n._free(r),u!==0&&n._OrtReleaseSessionOptions(u),a.forEach(v=>n._free(v))}},Su=e=>{let t=De(),r=fr.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[o,n,s,u]=r;u&&t._OrtReleaseBinding(u.handle),t.jsepUnregisterBuffers?.(e),n.forEach(d=>t._OrtFree(d)),s.forEach(d=>t._OrtFree(d)),t._OrtReleaseSession(o),fr.delete(e)},bu=(e,t,r,o,n)=>{if(!e){t.push(0);return}let s=De(),u=e[0],d=e[1],a=e[3],p,h;if(u==="string"&&a==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");if(a==="gpu-buffer"){let w=e[2].gpuBuffer,y=ur(Sn(u));h=d.reduce((x,A)=>x*A,1)*y,p=s.jsepRegisterBuffer(o,n,w,h)}else{let w=e[2];if(Array.isArray(w)){h=4*w.length,p=s._malloc(h),r.push(p);let y=p/4;for(let x=0;x<w.length;x++){if(typeof w[x]!="string")throw new TypeError(`tensor data at index ${x} is not a string`);s.HEAPU32[y++]=Ve(w[x],r)}}else h=w.byteLength,p=s._malloc(h),r.push(p),s.HEAPU8.set(new Uint8Array(w.buffer,w.byteOffset,h),p)}let v=s.stackSave(),g=s.stackAlloc(4*d.length);try{let w=g/4;d.forEach(x=>s.HEAP32[w++]=x);let y=s._OrtCreateTensor(Sn(u),p,h,g,d.length,xn(a));y===0&&Ee(`Can\'t create tensor for input/output. session=${o}, index=${n}.`),t.push(y)}finally{s.stackRestore(v)}},xu=async(e,t,r,o,n,s)=>{let u=De(),d=fr.get(e);if(!d)throw new Error(`cannot run inference. invalid session id: ${e}`);let[a,p,h,v]=d,g=t.length,w=o.length,y=0,x=[],A=[],$=[],_=[],R=u.stackSave(),I=u.stackAlloc(g*4),z=u.stackAlloc(g*4),T=u.stackAlloc(w*4),N=u.stackAlloc(w*4);try{[y,x]=ko(s);for(let Q=0;Q<g;Q++)bu(r[Q],A,_,e,t[Q]);for(let Q=0;Q<w;Q++)bu(n[Q],$,_,e,g+o[Q]);let U=I/4,G=z/4,J=T/4,B=N/4;for(let Q=0;Q<g;Q++)u.HEAPU32[U++]=A[Q],u.HEAPU32[G++]=p[t[Q]];for(let Q=0;Q<w;Q++)u.HEAPU32[J++]=$[Q],u.HEAPU32[B++]=h[o[Q]];if(v){let{handle:Q,outputPreferredLocations:we,outputPreferredLocationsEncoded:Z}=v;if(p.length!==g)throw new Error(`input count from feeds (${g}) is expected to be always equal to model\'s input count (${p.length}).`);for(let ye=0;ye<g;ye++){let Ce=t[ye];await u._OrtBindInput(Q,p[Ce],A[ye])!==0&&Ee(`Can\'t bind input[${ye}] for session=${e}.`)}for(let ye=0;ye<w;ye++){let Ce=o[ye];n[ye]?.[3]?u._OrtBindOutput(Q,h[Ce],$[ye],0)!==0&&Ee(`Can\'t bind pre-allocated output[${ye}] for session=${e}.`):u._OrtBindOutput(Q,h[Ce],0,Z[Ce])!==0&&Ee(`Can\'t bind output[${ye}] to ${we[ye]} for session=${e}.`)}}let q;v?q=await u._OrtRunWithBinding(a,v.handle,w,T,y):q=await u._OrtRun(a,z,I,g,N,w,T,y),q!==0&&Ee("failed to call OrtRun().");let pe=[];for(let Q=0;Q<w;Q++){let we=u.HEAPU32[T/4+Q];if(we===$[Q]){pe.push(n[Q]);continue}let Z=u.stackSave(),ye=u.stackAlloc(4*4),Ce=!1,fe,ce=0;try{u._OrtGetTensorData(we,ye,ye+4,ye+8,ye+12)!==0&&Ee(`Can\'t access output tensor data on index ${Q}.`);let Be=ye/4,He=u.HEAPU32[Be++];ce=u.HEAPU32[Be++];let L=u.HEAPU32[Be++],re=u.HEAPU32[Be++],he=[];for(let Me=0;Me<re;Me++)he.push(u.HEAPU32[L/4+Me]);u._OrtFree(L);let Fe=he.reduce((Me,Ge)=>Me*Ge,1);fe=Ot(He);let Ze=v?.outputPreferredLocations[o[Q]];if(fe==="string"){if(Ze==="gpu-buffer")throw new Error("String tensor is not supported on GPU.");let Me=[],Ge=ce/4;for(let Ke=0;Ke<Fe;Ke++){let nt=u.HEAPU32[Ge++],Je=Ke===Fe-1?void 0:u.HEAPU32[Ge]-nt;Me.push(u.UTF8ToString(nt,Je))}pe.push([fe,he,Me,"cpu"])}else if(Ze==="gpu-buffer"&&Fe>0){let Me=u.jsepGetBuffer(ce),Ge=ur(He);if(Ge===void 0||!Ro(fe))throw new Error(`Unsupported data type: ${fe}`);Ce=!0,pe.push([fe,he,{gpuBuffer:Me,download:u.jsepCreateDownloader(Me,Fe*Ge,fe),dispose:()=>{u._OrtReleaseTensor(we)}},"gpu-buffer"])}else{let Me=Br(fe),Ge=new Me(Fe);new Uint8Array(Ge.buffer,Ge.byteOffset,Ge.byteLength).set(u.HEAPU8.subarray(ce,ce+Ge.byteLength)),pe.push([fe,he,Ge,"cpu"])}}finally{u.stackRestore(Z),fe==="string"&&ce&&u._free(ce),Ce||u._OrtReleaseTensor(we)}}return v&&u._OrtClearBoundOutputs(v.handle),pe}finally{u.stackRestore(R),A.forEach(U=>u._OrtReleaseTensor(U)),$.forEach(U=>u._OrtReleaseTensor(U)),_.forEach(U=>u._free(U)),y!==0&&u._OrtReleaseRunOptions(y),x.forEach(U=>u._free(U))}},Cu=e=>{let t=De(),r=fr.get(e);if(!r)throw new Error("invalid session id");let o=r[0],n=t._OrtEndProfiling(o);n===0&&Ee("Can\'t get an profile file name."),t._OrtFree(n)},_u=e=>{let t=[];for(let r of e){let o=r[2];!Array.isArray(o)&&"buffer"in o&&t.push(o.buffer)}return t};self.onmessage=e=>{let{type:t,in:r}=e.data;try{switch(t){case"init-wasm":Oo(r.wasm).then(()=>{wu(r).then(()=>{postMessage({type:t})},o=>{postMessage({type:t,err:o})})},o=>{postMessage({type:t,err:o})});break;case"init-ep":{let{epName:o,env:n}=r;vu(n,o).then(()=>{postMessage({type:t})},s=>{postMessage({type:t,err:s})});break}case"copy-from":{let{buffer:o}=r,n=Zn(o);postMessage({type:t,out:n});break}case"create":{let{model:o,options:n}=r,s=$u(o,n);postMessage({type:t,out:s});break}case"release":Su(r),postMessage({type:t});break;case"run":{let{sessionId:o,inputIndices:n,inputs:s,outputIndices:u,options:d}=r;xu(o,n,s,u,new Array(u.length).fill(null),d).then(a=>{a.some(p=>p[3]!=="cpu")?postMessage({type:t,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:t,out:a},_u(a))},a=>{postMessage({type:t,err:a})});break}case"end-profiling":Cu(r),postMessage({type:t});break;default:}}catch(o){postMessage({type:t,err:o})}};})();\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n'});var cn,Yt,So,pa,ha,pu,hu,Rn,Mn,u$,fa,cy,fy,py,hy,my,gy,by,mu=R(()=>{"use strict";Bt();ly();kn();cn=()=>!!xe.wasm.proxy&&typeof document<"u",So=!1,pa=!1,ha=!1,hu=new Map,Rn=(r,e)=>{let n=hu.get(r);n?n.push(e):hu.set(r,[e])},Mn=()=>{if(So||!pa||ha||!Yt)throw new Error("worker not ready")},u$=r=>{switch(r.data.type){case"init-wasm":So=!1,r.data.err?(ha=!0,pu[1](r.data.err)):(pa=!0,pu[0]());break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let e=hu.get(r.data.type);r.data.err?e.shift()[1](r.data.err):e.shift()[0](r.data.out);break}default:}},fa=typeof document<"u"?document?.currentScript?.src:void 0,cy=async()=>{if(!pa){if(So)throw new Error("multiple calls to 'initWasm()' detected.");if(ha)throw new Error("previous call to 'initWasm()' failed.");if(So=!0,cn())return xe.wasm.wasmPaths===void 0&&fa&&fa.indexOf("blob:")!==0&&(xe.wasm.wasmPaths=fa.substr(0,+fa.lastIndexOf("/")+1)),new Promise((r,e)=>{Yt?.terminate();let n=URL.createObjectURL(new Blob([dy()],{type:"text/javascript"}));Yt=new Worker(n,{name:"ort-wasm-proxy-worker"}),Yt.onerror=o=>e(o),Yt.onmessage=u$,URL.revokeObjectURL(n),pu=[r,e];let t={type:"init-wasm",in:xe};Yt.postMessage(t)});try{await Oh(xe.wasm),await ry(xe),pa=!0}catch(r){throw ha=!0,r}finally{So=!1}}},fy=async r=>{if(cn())return Mn(),new Promise((e,n)=>{Rn("init-ep",[e,n]);let t={type:"init-ep",in:{epName:r,env:xe}};Yt.postMessage(t)});await ny(xe,r)},py=async r=>cn()?(Mn(),new Promise((e,n)=>{Rn("copy-from",[e,n]);let t={type:"copy-from",in:{buffer:r}};Yt.postMessage(t,[r.buffer])})):fu(r),hy=async(r,e)=>{if(cn()){if(e?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Mn(),new Promise((n,t)=>{Rn("create",[n,t]);let o={type:"create",in:{model:r,options:e}},i=[];r instanceof Uint8Array&&i.push(r.buffer),Yt.postMessage(o,i)})}else return oy(r,e)},my=async r=>{if(cn())return Mn(),new Promise((e,n)=>{Rn("release",[e,n]);let t={type:"release",in:r};Yt.postMessage(t)});iy(r)},gy=async(r,e,n,t,o,i)=>{if(cn()){if(n.some(u=>u[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(o.some(u=>u))throw new Error("pre-allocated output tensor is not supported for proxy.");return Mn(),new Promise((u,a)=>{Rn("run",[u,a]);let s=n,l={type:"run",in:{sessionId:r,inputIndices:e,inputs:s,outputIndices:t,options:i}};Yt.postMessage(l,uy(s))})}else return ay(r,e,n,t,o,i)},by=async r=>{if(cn())return Mn(),new Promise((e,n)=>{Rn("end-profiling",[e,n]);let t={type:"end-profiling",in:r};Yt.postMessage(t)});sy(r)}});var yy,l$,ma,vy=R(()=>{"use strict";Bt();mu();ut();yy=(r,e)=>{switch(r.location){case"cpu":return[r.type,r.dims,r.data,"cpu"];case"gpu-buffer":return[r.type,r.dims,{gpuBuffer:r.gpuBuffer},"gpu-buffer"];default:throw new Error(`invalid data location: ${r.location} for ${e()}`)}},l$=r=>{switch(r[3]){case"cpu":return new gt(r[0],r[2],r[1]);case"gpu-buffer":{let e=r[0];if(!Wi(e))throw new Error(`not supported data type: ${e} for deserializing GPU tensor`);let{gpuBuffer:n,download:t,dispose:o}=r[2];return gt.fromGpuBuffer(n,{dataType:e,dims:r[1],download:t,dispose:o})}default:throw new Error(`invalid data location: ${r[3]}`)}},ma=class{async fetchModelAndCopyToWasmMemory(e){let n=await fetch(e);if(n.status!==200)throw new Error(`failed to load model: ${e}`);let t=await n.arrayBuffer();return py(new Uint8Array(t))}async loadModel(e,n){let t;typeof e=="string"?typeof process<"u"&&process.versions&&process.versions.node?t=await(void 0)(e):t=await this.fetchModelAndCopyToWasmMemory(e):t=e,[this.sessionId,this.inputNames,this.outputNames]=await hy(t,n)}async dispose(){return my(this.sessionId)}async run(e,n,t){let o=[],i=[];Object.entries(e).forEach(p=>{let g=p[0],b=p[1],y=this.inputNames.indexOf(g);if(y===-1)throw new Error(`invalid input '${g}'`);o.push(b),i.push(y)});let u=[],a=[];Object.entries(n).forEach(p=>{let g=p[0],b=p[1],y=this.outputNames.indexOf(g);if(y===-1)throw new Error(`invalid output '${g}'`);u.push(b),a.push(y)});let s=o.map((p,g)=>yy(p,()=>`input "${this.inputNames[i[g]]}"`)),l=u.map((p,g)=>p?yy(p,()=>`output "${this.outputNames[a[g]]}"`):null),d=await gy(this.sessionId,i,s,a,l,t),f={};for(let p=0;p<d.length;p++)f[this.outputNames[a[p]]]=u[p]??l$(d[p]);return f}startProfiling(){}endProfiling(){by(this.sessionId)}}});var d$,ga,wy=R(()=>{"use strict";Bt();mu();vy();d$=()=>{if((typeof xe.wasm.initTimeout!="number"||xe.wasm.initTimeout<0)&&(xe.wasm.initTimeout=0),typeof xe.wasm.simd!="boolean"&&(xe.wasm.simd=!0),typeof xe.wasm.proxy!="boolean"&&(xe.wasm.proxy=!1),typeof xe.wasm.numThreads!="number"||!Number.isInteger(xe.wasm.numThreads)||xe.wasm.numThreads<=0){let r=typeof navigator>"u"?(void 0)().length:navigator.hardwareConcurrency;xe.wasm.numThreads=Math.min(4,Math.ceil((r||1)/2))}},ga=class{async init(e){d$(),await cy(),await fy(e)}async createInferenceSessionHandler(e,n){let t=new ma;return await t.loadModel(e,n),Promise.resolve(t)}}});var xy={};kr(xy,{wasmBackend:()=>c$});var c$,$y=R(()=>{"use strict";wy();c$=new ga});var p$={};kr(p$,{InferenceSession:()=>nl,Tensor:()=>gt,TrainingSession:()=>sl,default:()=>f$,env:()=>xe,registerBackend:()=>sr});Bt();Bt();Bt();var ll="1.17.0";var f$=Sa;{let r=(hh(),Sr(ph)).onnxjsBackend;sr("webgl",r,-10)}{let r=($y(),Sr(xy)).wasmBackend;sr("webgpu",r,5),sr("cpu",r,10),sr("wasm",r,10),sr("xnnpack",r,9),sr("webnn",r,9)}Object.defineProperty(xe.versions,"web",{value:ll,enumerable:!0});return Sr(p$);})();
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/*! Bundled license information:

long/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=ort.all.min.js.map
